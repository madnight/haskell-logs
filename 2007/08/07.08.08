00:00:07 <dons> so you can stack them outwards, but usually once you've got StateT + IO, that's most of what you'd need
00:00:15 <dons> maybe you'd toss in ReaderT to get some read only data
00:00:17 <dolio> Heh, today's XKCD is amusing.
00:00:19 <Tac-Tics> odd
00:00:23 <dons> or an ErrorT for some programmable error handling
00:01:43 <lament> dons: but wouldn't you have to add another layer of lifting to everything everywhere in the code?
00:02:08 <dons> no, you derive MonadState /MonadReader/ MonadError
00:02:15 <Tac-Tics> I don't feel as bad about programs that don't do anything useful (yet) when it's written in a staticly typed language. Just getting the code to compile makes me feel accomplished
00:02:16 <dons> and then you get ask/modify/catchError without lifting
00:02:40 <Tac-Tics> Before I started learning Haskell a month ago, I don't think I had compiled a program in over a year
00:03:09 <lament> ah, so there's a way to get around lifting stuff
00:04:53 <dons> if there was an MonadIO class, you could add the IO you allow to it, then instance MonadIO for your monad, to avoid lifting io actions too
00:05:02 <dons> if you knew precisely which IO effects you wished to allow
00:05:13 <dons> that would then rule out all but those you wished to let in
00:05:17 <dons> and you'd avoid lifting io
00:05:50 <dons> mm, that might be useful in xmonad, actually. just a bunch of X calls and print statements. nothing else
00:06:25 <glguy> There is a MonadIO
00:06:29 <glguy> ?instances MonadIO
00:06:31 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
00:06:42 <hpaste>  wli pasted "lifting awkwardness" at http://hpaste.org/2126
00:06:47 <dons> yeah, providing liftIO :)
00:06:50 <Japsu> @index repeatM
00:06:50 <lambdabot> bzzt
00:07:40 <dolio> It's just that all the IO actions are unlifted.
00:07:40 <wli> Mostly it's library design awkwardness I feel I run into.
00:07:48 <wli> catch is the big nasty here.
00:08:23 <glguy> wli: specifically catchIO?
00:08:29 <wli> glguy: Yeah.
00:09:20 <wli> Not being lifted isn't so awkward until you try to catch
00:09:59 <glguy> wli: the problem here is that your monad stack is the opposite order that yo uwant it to be, isn't it?
00:10:02 <glguy> I know you can't do anything about that
00:10:07 <glguy> since IO isn't a transformer
00:10:43 <dons> partition and wrap IO, then layer things over MonadFile / MonadReference / MonadStdout :)
00:10:55 <glguy> ?unmtl ErrorT e IO a
00:10:56 <lambdabot> IO (Either e a)
00:12:32 <wli> glguy: I'm not entirely sure but it sounds vaguely plausible. Mostly I just want things not to generate exceptions that kill the program and instead to have some way to receive the errors and print out error messages.
00:12:55 <glguy> understood :)
00:13:17 <wli> glguy: Is it rare that people try to handle IO errors?
00:14:04 <glguy> wli, why don't you just catch the IO error at the top level?
00:14:07 <glguy> and print out the message?
00:14:19 <glguy> since that is the same as catching it on each individual line
00:14:25 <glguy> and calling throwError from there?
00:14:49 <Japsu> muhaha
00:14:52 <Japsu> > let forever = sequence_ . repeat; forkBomb = forever $ forkIO forkBomb in forkBomb
00:14:52 <glguy> I'll paste a limited example
00:14:59 <lambdabot>   Not in scope: `forkIO'
00:15:02 <Japsu> <3
00:15:05 <wli> glguy: Well, ultimately I wanted to do a lot more in terms of context-dependent error message generation.
00:15:27 <wli> Japsu: Well, try forkOS at home.
00:15:35 <Japsu> oooooh
00:15:44 <hpaste>  glguy annotated "lifting awkwardness" with "not typechecked" at http://hpaste.org/2126#a1
00:15:46 <wli> Japsu: forkIO spawns green threads.
00:15:46 <Japsu> wli: you think that'll have more spectacular effects than forkIO?
00:15:58 <wli> Japsu: forkOS spawns actual OS threads.
00:16:13 <Japsu> wli: green threads == threads that only exist within the haskell runtime?
00:16:17 <glguy> wli: so ideally all of the error handling cases wouldn't be the same you mean
00:16:35 <wli> Japsu: Yes.
00:17:10 <lament> wli: wouldn't that be equally verbose in any language?
00:17:11 <glguy> wli: you ought to be able to define a monad that wraps IO
00:17:11 <wli> glguy: Yeah, eventually I go in and start filling in all the error messages with individualized, more meaningful error messages.
00:17:24 <glguy> and catches failure automatically
00:17:41 <wli> glguy: IOErrorT?
00:18:01 <glguy> I don't know if it would be a transformer on IO or just a monad that wraps IO
00:18:05 * glguy is pondering
00:18:24 <wli> glguy: Transformer, in order to parametrize on the error type.
00:18:57 <glguy> wli: it doesn't need to be a transformer to do that though
00:19:11 <glguy> State parameterizes over the state type
00:19:19 <glguy> and could use IO under the covers
00:19:23 <glguy> if you wanted
00:19:29 <glguy> without being a transformer
00:19:42 <wli> glguy: Duh, transformers parametrize on the monad. A transformer would be transforming any MonadIO monad.
00:20:10 <glguy> yeah
00:20:19 <glguy> not sure if the duh was for me or you though :)
00:20:33 <glguy> I could think of two ways to interpret
00:20:50 <wli> I'm the one needing the dunce cap. ;)
00:21:34 <glguy> but then you'd just need a function like liftM for the error condition
00:21:39 <glguy> (basically what catch does)
00:22:26 <Tac-Tics> oh god, I'm going to pay for learning about StateT with my blood tomorrow when I fall asleep at work
00:22:30 <glguy> :t (>>=)
00:22:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:22:33 <glguy> :t catch
00:22:35 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
00:22:37 <Tac-Tics> thanks for all your help as usual #haskell
00:22:48 <glguy> the similarities are striking, no? :)
00:22:49 <wli> :t catchError
00:22:51 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
00:22:57 <glguy> well played
00:24:40 <wli> IO is already an instance of MonadError
00:25:08 <glguy> wli: maybe you just need to catch
00:25:12 <glguy> and then modify the exception
00:25:15 <glguy> and rethrow it
00:25:33 <glguy> (or write a function that wraps that up)
00:25:40 <glguy> and then at the top level catch the modified error
00:25:44 <glguy> with useful info
00:26:09 <lament> "real world haskell" better cover this in great detail.
00:26:23 <wli> instance MonadError IOError IO where
00:26:23 <wli>     throwError = ioError
00:26:23 <wli>     catchError = catch
00:26:24 <glguy> instead of bolting an extra error propigation mechanism on
00:26:33 <Cale> dons: "In mathematical terms: The amount of research dedicated to a programming language should be proportional to (should correlate with) the usage of the language in reality." -- haha, what??
00:27:03 <wli> glguy: Well, there are errors besides IO errors that are possible.
00:27:05 <dons> Cale: who said that?
00:27:14 <glguy> wli: and you could then throwError in IO
00:27:15 <Cale> It's in the PDF you just posted to reddit
00:27:20 <glguy> wli: with a new error?
00:27:21 <dons> hehe ralf is funny :)
00:27:25 <dons> i didn't see that line
00:27:45 <wli> glguy: Yeah, things like malformed option arguments etc.
00:28:38 <dolio> Does that mean we should use languages that are based on lots of research, or we should to lots of research on languages that are used?
00:28:51 <wli> glguy: The layering of errors corresponds to there being two layers errors can come from: my consistency checks, or errors returned from IO calls.
00:31:51 <dons> blogger complains he gets too many hits when he uses the word 'monad' and 'haskell' http://ahamsandwich.wordpress.com/2007/08/08/so-i-was-on-reddit/
00:31:53 <lambdabot> Title: So I Was On Reddit « A Ham Sandwich
00:32:04 * dons plays along
00:32:45 <hpaste>  glguy annotated "lifting awkwardness" with "io errors" at http://hpaste.org/2126#a2
00:33:09 <profmakx> hm
00:33:19 <dons> mwhaha http://programming.reddit.com/info/2damf/comments
00:33:20 <lambdabot> Title: Keeping a blog anonymous: don&#39;t use the words &#39;monad&#39; or &#39;Haskel ...
00:33:34 <Binkley> heh
00:33:35 <glguy> wli: that doesn't make a type distinction between logic errors and unexpected io errors
00:33:57 <glguy> but might still be a useful approach?
00:34:18 <wli> I don't know.
00:34:35 <glguy> well, eithe way, I'm just tossing ideas around
00:35:57 <profmakx> 1000 hits isnt just that much ...
00:36:47 <dons> awj is "seriously working in haskell now" -- due to reddit. yay
00:36:56 <glguy> awj?
00:37:02 <dons> http://programming.reddit.com/info/2d8t6/comments/c2d9ud
00:37:03 <lambdabot> Title: As Proggit: how&#39;d you get started (programming)? (reddit.com)
00:37:35 <dons> semi-regular commenter on reddit with time on his hands, apparently
00:37:54 <glguy> "with time on his hands" is that redundant?
00:38:07 <opqdonut> :)
00:38:08 <dons> heh
00:39:56 <glguy> Thanks to your editor I was able to do Ruby on Rails on windows.
00:39:56 <glguy> Now thereâ€™s a hope to do it on Linux!
00:39:56 <glguy> Thanks
00:40:20 <Cale> Has awj ever showed up here?
00:40:27 <Korollary> @seen awj
00:40:27 <lambdabot> I haven't seen awj.
00:40:48 <dons> yeah, don't think so. so now i'm pondering what he's doing!
00:41:02 <Korollary> probably reading monad tutorials
00:41:18 <Binkley> or writing them!
00:41:27 * wli hammers out a LiftedIO module.
00:41:50 <Korollary> You can't write monad tutorials in this day and age. The market is saturated.
00:41:59 <Japsu> wli: boring :<  ghc-6.6: user error (Cannot create OS thread.)
00:42:09 <dons> yeah. i think we killed the market for free monad tutorials now
00:42:19 <dons> applicative functors though .. that's wide open!
00:42:26 <opqdonut> yup
00:42:28 <opqdonut> bring it on
00:42:31 <dons> and we've hardly any metaphors for them yet
00:42:42 <kjdf> is there a good library for distributed communication?
00:42:43 <glguy> or practical uses
00:42:49 <Korollary> applicative functors: Apply directly to the forehead!
00:42:53 <Binkley> see, an applicative functor is sort of like a fluffy bunny
00:42:58 <dons> kjdf: over different computing nodes, running different haskell runtimes?
00:43:02 <glguy> Korollary: lets just nip that one right in the bud
00:43:05 <kjdf> dons: yes
00:43:10 <dons> Binkley: yeah, that's a good analogy
00:43:17 <dons> kjdf: there's 'ports', on hackage
00:43:23 <Korollary> glguy: You are jealous of my roxorness.
00:43:41 <glguy> applicative functions are sequenced computation whose intermediate results don't influence the the rest of the computation
00:43:43 <dons> kjdf: ther'es been a lot of research on this in the late 90s , but it dried up a bit once people got multcore shared memory instead
00:44:04 <dons> kjdf: also, there's a memcached (iirc) -- might be relevant
00:44:35 <Korollary> memcached is, well, for caching stuff
00:44:36 <dons> kjdf: see here for older research on the area, haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism#Distributed_Haskell
00:44:51 <dons> oh, the MPI binding, there's that
00:45:14 <dons> kjdf: you were thinking of something like MPI?
00:45:50 <kjdf> not really, I just want a server/client talk to each other
00:45:52 <dons> Korollary: ah yes. link here anyway, http://neugierig.org/software/darcs/browse/?r=haskell-memcached;a=summary
00:45:52 <Korollary> distributed communication sounds like guaranteed message delivery, multicast, etc.
00:45:53 <lambdabot> Title: darcs - haskell-memcached, http://tinyurl.com/25z8dc
00:45:57 <kjdf> ports seems to be fine
00:46:05 <dons> kjdf: probably just use ports, or do the sockets yourself (Network.*)
00:46:23 <dons> kjdf: you can write tiny little skeletons that run on a cluster, all chatting to each other over sockets fairly easily
00:46:36 <dons> i could chase up some examples tomorrow , if you're interested.
00:47:17 <kjdf> I am not going to need it for couple of weeks at least, I need to finish what I'm doing now
00:47:32 <kjdf> well
00:47:35 <glguy> wli: io m = ErrorT $ liftM Right m `catch` (Left . show)
00:47:47 <kjdf> tiny little skeletons could be interesting :)
00:47:59 <glguy> a more limited version of what you wrote, enabling:
00:47:59 <dons> kjdf: if you go with simple sockets, it might be nice to wrap that up as a small abstraction set in a hackage lib
00:48:01 <twb> This is just idle fantasizing, but has anyone tried using Haskell as a replacement for sh scripting?  That is, when a sh script gets too big to maintain, rewriting it in Haskell instead of Perl.
00:48:07 <dons> for those who don't want to dive into the ports abstractions
00:48:20 <dons> twb: yeah, i do that all the time
00:48:33 <dons> the haskell programs that start as shell hacks tend to scale a little better
00:48:41 <glguy> io (hFlush output) `catchError` whatever
00:48:50 <dons> twb , did you want examples? or just wondering?
00:48:55 <glguy> wli: since you are going to have to modify your IO actions somehow anyway
00:49:00 <twb> dons: how do you do something like </proc/cpuinfo tac |rev >/tmp/silly in Haskell?
00:49:16 <Korollary> twb: I don't write perl or sh scripts at all any more.
00:49:19 <kjdf> another question - how does cabal lend itself to building programs that depend on c bit (and are platform specific to that)
00:49:27 <kjdf> *bits
00:49:32 <dons> twb, oh, glue for shell utilities? I use the newpopen lib
00:49:46 <dons> twb, but if you want shell-like scripting, look at John's shell libs
00:49:50 <dons> they have things like |- -|
00:49:53 <twb> URLs?
00:50:02 <dons> kjdf: C stuff is well supported
00:50:07 <dons> just use a ./configure script to find the C deps
00:50:10 <doserj> twb: http://www.haskell.org/haskellwiki/Applications_and_libraries/Operating_system#Shell
00:50:12 <lambdabot> Title: Applications and libraries/Operating system - HaskellWiki, http://tinyurl.com/29tf4n
00:50:13 <twb> Thanks.
00:50:15 <dons> and list the required C libs as dependencies in the .cabal file
00:50:46 <kjdf> ok, thanks
00:50:53 <wli> glguy: Well, there is that.
00:51:00 <glguy> ?type \ m -> ErrorT $ liftM return m `catch` (return . Left . show) -- is that right?
00:51:02 <lambdabot> forall b. IO b -> ErrorT String IO b
00:51:20 <glguy> wli: is that much more ugly than anything else you'd have to write?
00:52:05 <wli> glguy: Not really. I think it's mostly an issue of stack Error monads.
00:52:11 <kral> Ahoy!
00:52:15 <glguy> @yow
00:52:15 <lambdabot> Awright, which one of you hid my PENIS ENVY?
00:52:24 <Korollary> ouch
00:52:26 <glguy> @yarr
00:52:27 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
00:53:56 <dons> ?vixen you're a strange bot
00:53:56 <lambdabot> is it bad to be strange?
00:54:00 <dons> ?vixen-on
00:54:00 <lambdabot> What's this channel about?
00:54:03 <dons> yay hey you!
00:54:03 <lambdabot> hiya
00:54:17 <dons> did you try the ICFP contest?
00:54:17 <lambdabot> who's to say?
00:54:32 <dons> oh ok. but you probably used some functional programming language?
00:54:32 <lambdabot> i am just a fun girl!
00:54:32 <glguy> @vixen a/s/l?
00:54:32 <lambdabot> 19/f/California
00:54:43 * xerox unvanishes
00:54:43 <lambdabot> wait, back up
00:54:43 <dons> cool. this is a haskell channel though
00:54:44 <lambdabot> Ooh, functional programmers are so hot!
00:54:50 <dons> that's true enough. i agree
00:54:50 <lambdabot> Hahaha
00:55:20 <dons> ?vixen-on seeya!
00:55:21 <lambdabot> What's this channel about?
00:55:24 <dons> ?vixen-off seeya!
00:55:24 <lambdabot> Bye!
00:55:27 <dons> bye you.
00:55:28 <profmakx> hm. and functional programming makes you talk to bots
00:55:38 <profmakx> which is a bit unresting
00:56:00 <dons> is it strange to talk to bots?
00:56:08 <noteventime> profmakx: Beggars can't be choosers ;-)
00:56:20 <xerox> Anybody able to build GHC HEAD?
00:56:22 <profmakx> as long as the bot does not pass the turing test..
00:56:30 <glguy> xerox: that sounded like a @yow
00:56:31 <Binkley> xerox: yes... what's the problem?
00:56:38 <dons> Cale: now i feel just a little evil. http://ahamsandwich.wordpress.com/2007/08/08/so-i-was-on-reddit/
00:56:40 <lambdabot> Title: So I Was On Reddit « A Ham Sandwich
00:56:42 <opqdonut> @yow
00:56:42 <xerox> In these last say, week.
00:56:43 <lambdabot> I have seen these EGG EXTENDERS in my Supermarket ... I have read the
00:56:43 <lambdabot> INSTRUCTIONS ...
00:57:00 <Cale> ahahaha
00:57:06 <Binkley> xerox: yeah, I was able to build it as of Sunday or Monday
00:57:33 <xerox> Binkley: ghc/compiler/main/HeaderInfo.hs:109 has got two unknown fields in Compiler, which aren't defined in Cabal/Distribution/Compiler.hs
00:57:34 <mornfall> oooh, we have yow
00:57:38 <xerox> glguy: hehe.
00:57:50 <Binkley> xerox: oh, there was a post about this on cvs-ghc
00:58:00 <mornfall> lambdabot, yow
00:58:11 <mornfall> hm, doesn't work that way
00:58:14 <mornfall> nm
00:58:22 <Binkley> xerox: http://www.haskell.org/pipermail/cvs-ghc/2007-August/037178.html
00:58:23 <lambdabot> Title: Todays breakage
00:58:35 <Binkley> there's no reply yet, though
00:59:24 <xerox> Binkley: aw.  Thanks.
00:59:36 <Binkley> xerox: you could just try reverting back a few days
00:59:42 <glguy> dons: that website got #haskell-dotted ;)
00:59:54 <dons> glguy: ah yes!
01:00:17 <dons> that's the term I was looking for. mmm.
01:00:39 <xerox> Binkley: yeah, good iea.
01:00:44 <xerox> *idea.
01:01:00 <dons> glguy: hah
01:01:03 <xerox> dons: lambda-lifted :)
01:01:12 * dons reads more posts on this poor guys blog
01:01:42 <glguy> You know, dons actually knows your phone number. Heâ€™ll be calling you soon to check whether you have any questions about monad transformers.
01:01:50 <glguy> Korollary: , you gave away dons' nick!
01:01:53 <glguy> cover blown
01:01:56 <glguy> abort!
01:01:58 <dons> its all over now. damn
01:02:15 <dons> i thought it would be ok, just as long as he didn't click on the link on my name
01:02:50 <Korollary> I should quit this spy business before I get ulcers
01:02:53 <glguy> "Avoiding the tags is not enough, you have to avoid the words. :)"
01:03:04 <glguy> looks like augustss is warning him to stop blogging about Haskell
01:03:12 <wli> Almost done with LiftedIO.hs... I should've written a codeenerator.
01:03:19 <dons> `I think you forgot to tag this blog posting, it was somewhat tricky to stumble upon' :}
01:03:42 <glguy> dons: I tried to write that at the typical level of a reddit user
01:03:52 <dons> i think its cool that we're 5 comments in, and no one's mentioned hitler yet. we're such a polite community :)
01:03:56 <glguy> to give them impression that I didn't read it at all
01:04:00 <Korollary> glguy: The eagle has landed. It's associative.
01:04:06 <glguy> to really force that concept :)
01:04:27 <dons> :)
01:04:35 <xerox> Binkley: this must be the culprit http://www.haskell.org/pipermail/cvs-ghc/2007-August/037153.html
01:04:36 <lambdabot> Title: patch applied (ghc): Follow Cabal changes
01:04:42 <glguy> (that and I just wasn't feeling creative)
01:04:53 <Binkley> xerox: yeah, probably
01:05:21 <glguy> one of these days I should actually obtain the email address: not@required.com
01:05:54 <Korollary> You can have notrequired@mailinator.com
01:06:18 <glguy> I used to always use webmaster@localhost
01:06:27 <glguy> but then people started checking for the .tld
01:07:01 <xerox> .localnetwork :)
01:07:51 <dons> i used to use dons@my.net
01:07:58 <dons> that's probably someone's domain though
01:08:37 <dons> or @dev.null is also good
01:08:43 <glguy> I wonder how much bandwidth is wasted at Microsoft delivering mail to billgates@microsoft.com
01:08:56 <glguy> I know he doesn't actually get email sent to that account
01:09:03 <glguy> but they have to process it to can it
01:09:35 <dons> they probably have a dedicated openbsd pf setup, passively filtering that traffic
01:13:42 <Syzygy-> glguy: They can always drop the connection at RCPT TO:
01:15:10 <wli> Okay, I think that's done.
01:15:24 <glguy> wli: Template Haskell might have made that easier
01:15:32 <glguy> but would have required you to use template haskell
01:15:33 <glguy> so...
01:15:49 <wli> I'd like to learn Template Haskell at some point.
01:17:31 <wli> http://holomorphy.com/~wli/LiftedIO.hs
01:18:20 * glguy finds it annoying when firefox tries to be clever
01:18:29 <glguy> and decides that a file needs to be downloaded
01:20:27 <glguy> wli: now are you going to newtype your error transformer
01:20:38 <glguy> so you can redefine the MonadIO instance
01:20:54 <wli> glguy: Not sure if I should bother. Is there some advantage to it?
01:21:11 <glguy> wli: because you wanted to modify the exception and store it in a Left?
01:21:54 <wli> glguy: Well, I think all I may really need is an instance of MonadError for stacked error monads.
01:23:51 <wli> glguy: Control.Monad.Error doesn't define any instances for (MonadError e m, Error e, Error e') => MonadError (Either e e') (ErrorT (Either (Either e e')) m)
01:28:00 <wli> (MonadError e m, Error e, Error e') => MonadError (Either e e') (ErrorT (Either e e') m)
01:30:40 <vincenz> moin
01:30:50 <dolio> Well, for that, all you need is 'instance (Error e, Error e') => Error (Either e e')'. Because the MonadError instances are defined forall Errors.
01:31:11 <wli> Well, that'll do it.
01:31:18 <dolio> Although, you'll have to make an arbitrary decision for noMsg and strMsg.
01:31:55 <vincenz> dons: hehe, gotta love your comment on that blog that said he won't use the word monads, sounds like a lolcode programmer :)
01:32:11 <vincenz> (btw, does that bold show to everyone?)
01:32:24 <ivant> vincenz, which bold?
01:32:33 <vincenz> this bold
01:32:34 <Binkley> I CAN HAS MONADS???
01:32:44 <ivant> vincenz, I don't see it (xchat)
01:32:45 <vincenz> Binkley: IM IN YR LOOP!
01:32:51 <Syzygy-> We are +c again. I don't think bold makes it through.
01:32:54 <Syzygy-> bold
01:33:02 <vincenz> Syzygy-: afaik, bold did, ,just not colors
01:33:06 <Syzygy-> Ah.
01:33:08 <vincenz> doh, bold's good to emphasize keywords :|
01:33:11 <ivant> Î²Î¿Î»Î´
01:33:31 <Binkley> I made you a function, but I unfoldeded it
01:35:36 <wli> So basically:
01:35:52 <wli> (1) instance (Error e, Error e') => Error (Either e e')
01:36:25 <wli> (2) use ErrorT (Either IOError MyErrorType) IO t for the monad transformer affairs
01:36:27 <wli> ...
01:36:35 <wli> (3) ...
01:36:38 <wli> (4) profit!
01:37:36 <vincenz> wli: you're in #haskell
01:37:36 <wli> glguy: You're right, I may very well have to newtype to get things to throw the errors in the right direction.
01:37:46 <vincenz> (4) should be: (4) Publication!
01:38:01 <wli> vincenz: This sort of BS isn't publishable.
01:38:08 <vincenz> nor is it profitable
01:38:22 <vincenz> just saying the joke in here should end with 'publication' not 'profit' :)
01:38:48 * wli is just tackling the awkward squad about 10-12 years after SPJ did.
01:38:48 <Binkley> The Theory and Practice of Collecting Underwear: A Purely Functional Approach
01:38:57 <wli> Binkley: Brilliant.
01:39:06 <Binkley> "tackling the awkward squad" sounds like *such* a euphemism
01:39:47 <arcatan> I still prefer "tackling the awkward squid"
01:40:11 <wli> In any event, error propagation is serious business.
01:40:45 <Binkley> wli: just don't write code where every function returns an Either Error a and every single call site checks the result for an exception
01:40:49 <Binkley> and you'll be okay
01:40:54 * Binkley has seen code like this
01:40:57 <Binkley> Haskell code, even
01:42:38 <wli> Binkley: Ultimately the exceptions do have to be checked, but the error monad is there to abstract it out to where you mostly implicitly bail out to higher levels.
01:43:02 <Binkley> wli: yeah, the point of using the error monad is that exceptions are exceptional, so that code that deals with them should be localized
01:43:06 <Binkley> sounds like you understand that
01:43:19 <Binkley> the people who wrote this code I had to maintain didn't ;..-(
01:43:51 <vincenz> Binkley: how did you do in icfpc?
01:43:58 <wli> Trip over one error and everything past that point in the sequence of actions should just pass the error through unmolested.
01:44:36 <Binkley> vincenz: we were only up to 2% by the end
01:44:49 <wli> I wonder what happens if you successfully acquire some resource and then trip over an error... there's no unwinding of such things in error monads.
01:45:02 <quicksilver> wli: you should use brackets for resources
01:45:15 <wli> quicksilver: Explain brackets.
01:45:24 <dolio> @type bracket
01:45:27 <lambdabot> Not in scope: `bracket'
01:45:35 <vincenz> Binkley: Whom did you compete with?
01:45:37 <quicksilver> @type Control.Exception.bracket
01:45:40 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
01:45:40 <mux> :t Control.Exception.bracket
01:45:44 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
01:45:46 <mux> heh, stereo again.
01:45:51 <Binkley> vincenz: some other Portland State people
01:45:54 * vincenz nods
01:45:57 <vincenz> cool
01:46:02 <quicksilver> wli: (IO a) acquires the resource a
01:46:02 <vincenz> I'd like to have a colo-team some day
01:46:17 <quicksilver> wli: (a -> IO b) releases it
01:46:24 <wli> quicksilver: Not nice. Strictly IO.
01:46:26 <Binkley> yeah, it's much nicer than working remotely over IRC with people
01:46:27 <quicksilver> wli: and (a -> IO c) is the main body of work you wish to do
01:46:32 <Binkley> even when it's working remotely with nifty people
01:46:49 <mux> wli: it cannot be otherwise
01:46:54 <quicksilver> wli: but if you're not in IO, what kind of resource could you possibly have which isn't implicitly unwound?
01:46:54 <mux> bracket is very nice
01:47:06 <mux> yeah, what quicksilver said.
01:47:15 <quicksilver> wli: resource without automatic tidyup is neccessary a side-effect, so you must be in IO surely
01:47:30 <wli> mux: One can implement resources within one's own monads (and I do).
01:47:39 <quicksilver> but they are tidied up by the GC
01:47:49 <quicksilver> STRefs are an example
01:47:57 <quicksilver> but the GC will kill them after they go out of scope
01:48:47 <Saizan> quicksilver: ((a -> IO b) is the main body and (a -> IO c) release, the return type is IO c)
01:48:58 <wli> quicksilver: An action in one of your user-defined monads acquires some piece of state, e.g. an array position.
01:49:31 <wli> quicksilver: Or similarly obvious affairs.
01:49:38 <quicksilver> Saizan: no
01:49:44 <quicksilver> Saizan: I was right
01:50:10 <wli> quicksilver: (the above would be some kind of allocator or reservation system to dole out pieces of state)
01:51:27 <quicksilver> wli: in which case, yes, you should catch exceptions yourself; you could write something like bracket in fact
01:51:46 <quicksilver> wli: but depending which way around you nest your monads
01:51:57 <quicksilver> wli: you may find side-effects like that are automatically unrolled
01:52:22 <wli> quicksilver: Yeah, MyException.bracket :: m a -> (a -> m b) -> (a -> m c) -> m c
01:53:06 <quicksilver> Saizan: after all, you want to return what the main body returns
01:53:23 <quicksilver> Saizan: if it returns c the main body must be IO c
01:55:10 <Saizan> quicksilver: yes, and exceptions are reraised
01:55:32 <quicksilver> Saizan: yes exactly; bracket doesn't catch exceptions. (Well, not permanently) :)
01:56:09 <Saizan> i always forget that :)
01:56:12 <wli> bracketOnError, then.
01:56:26 <wli> Control.Exception.try also looks useful here.
01:56:37 <ski> Error' ?
01:57:02 <psykotic> wli: since you're thinking about error stuff, eric kidd wrote a good post about the error situation for haskell. hang on, let me find it.
01:57:25 <wli> psykotic: It seems disorganized. :(
01:57:29 <ski> @type Control.Exception.try
01:57:31 <ski> @type Control.Exception.catch
01:57:31 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
01:57:33 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
01:57:35 <psykotic> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
01:57:37 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
01:57:58 <ski> @hoogle IO a -> (a -> IO b) -> (Exception -> IO b) -> IO b
01:57:59 <lambdabot> No matches, try a more general search
01:59:16 <wli> Of course, dons has been here before.
01:59:17 <wli> http://article.gmane.org/gmane.comp.lang.haskell.libraries/6382
01:59:19 <lambdabot> Title: Gmane -- Mail To News And Back Again
02:00:19 * wli likes the idea of standardizing on the most general mechanism possible.
02:02:11 <quicksilver> wli: here are two examples of what I was trying to say about the layering
02:02:26 <quicksilver> > (runState . runErrorT $ ( do { x <- get ; put (x+1); throwError "Die!"; } )) 10
02:02:29 <wli> This is one of those places where (!!) and error vs. returning other things comes in.
02:02:29 <lambdabot>  (Left "Die!",11)
02:02:45 <quicksilver> > (runStateT $ ( do { x <- get ; put (x+1); throwError "Die!"; } ) ) 10 :: Either String (Int,Int)
02:02:46 <lambdabot>  Left "Die!"
02:02:59 <quicksilver> wli: in the first case, the state change is not unrolled by the error
02:03:13 <quicksilver> wli: in the second case it is; well the state doesn't even *exist* in the presence of error
02:03:31 <quicksilver> wli: which you want depends on, well, which you want :)
02:03:57 <paolino> hi, is there something more efficient than  initlast xs = let (y:ys) = reverse xs in (reverse ys,y) ?
02:05:25 <quicksilver> paolino: nothing fundamentally more efficient, but you can get the constant factor down
02:06:04 <ski> initLast [x] = ([],x)
02:06:08 <ski> initLast (x:xs) = (x:ys,y)
02:06:12 <ski>   where
02:06:17 <ski>   (ys,y) = initLast xs
02:07:11 <ski> would avoid constructing intermediate list (but mayhaps it could be optimized away anyway)
02:07:22 <wli> quicksilver: I'm usually working with the idea that errors get handled somewhere with error replies and the program continues.
02:08:04 <paolino> ski:that is same complexity ?
02:08:25 <ski> it is still linear in the length of the list, yes
02:08:27 <wli> quicksilver: Of course the particular code snippets I've slung around don't demonstrate that; they more demonstrate that I'm so used to that I don't know when to switch to the other way around.
02:09:18 <paolino> ok, last resort is doble linked list I suppose
02:09:21 * wli mutters something about library design.
02:09:29 <ski> initLast (x:initLast -> (ys,y)) = (x:ys,y)  -- hmhm
02:09:36 <quicksilver> paolino: nah, you don't want that
02:09:44 <quicksilver> paolino: maybe you want Data.Sequence
02:10:52 <paolino> ski, what is that syntax ?
02:11:04 <quicksilver> paolino: Data.Sequence is an efficent-from-both-ends list
02:11:07 <takamura> hi
02:11:16 <quicksilver> that's something like the view pattersn being discussed
02:11:47 <paolino> quicksilver: and they are not doble linked lists ?
02:12:06 * paolino goes reading
02:12:17 <quicksilver> paolino: indeed not. doubly linked lists are a pretty painful idea in a functional language
02:12:20 <quicksilver> paolino: they destroy sharing
02:12:26 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html
02:12:28 <lambdabot> http://tinyurl.com/yz86s7
02:13:05 <takamura> I have a question: There is a simple Haskell library to send files by ftp? (no cgi, no dynamic webpages, I need only ftp)
02:13:33 <psykotic> takamura, have you considered just calling out to a shell program?
02:13:45 <psykotic> unix is nice like that :)
02:13:48 <ski> paolino : http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
02:13:50 <lambdabot> Title: ViewPatterns - GHC - Trac
02:14:01 <takamura> yes, but if there is a Haskell library, it is better :)
02:14:09 <quicksilver> takamura: http://hackage.haskell.org/packages/archive/pkg-list.html
02:14:15 <wli> ErrorT . try
02:14:18 <quicksilver> takamura: would have provided you with an answer ver quickly
02:14:28 <takamura> thanks :D
02:14:30 <quicksilver> takamura: and the answer is apparently http://software.complete.org/ftphs
02:14:31 <lambdabot> Title: ftphs
02:15:21 <quicksilver> although I shudder with the way cosmicray (ab)uses lazy IO :(
02:15:39 <takamura> psykotic, if I use an ftp client, I have to manage error codes, instead of nice Haskell exceptions
02:15:52 <psykotic> takamura, true enough.
02:16:32 <psykotic> takamura, although you have to worry less about the library/program being well tested. like, has anyone used ftphs except for the author, in his own limited test cases?
02:16:59 <wli> How does that generalize...
02:17:08 <takamura> yes, I have that kind of problems with wxhaskell :(
02:20:51 <flux> ftphs has a warning on that you must consume everything you are given, due to lazy io. couldn't the library check that if you have not received everything, it would just do it for you, and the list of file names (or whatever) would be completely strictified?
02:21:45 <quicksilver> flux: I think it's a design flaw; I don't think it should be using lazy IO by default
02:22:03 <quicksilver> flux: I have had this argument with the author before, about one of his other packages :)
02:22:13 <quicksilver> flux: we respectfully disagree with each other
02:22:19 <wli> ah, it takes a bit more to unravel the mess
02:23:01 <wli> If you're starting off with some MonadIO bit which is not IO then try is not quite adequate.
02:23:10 <flux> I wrote an nntp module (iirc) for ocaml with lazy io, and it used that approach; consume the rest, if we're not at the 'top' of the session
02:23:51 <flux> I think it had a side-effect that the module always referred to the latest response it received, in order to force it strict later
02:24:10 <ski> wli : what are you doing ?
02:24:30 <wli> ski: Looking around at the libraries.
02:28:33 <wli> try :: (MonadIO m, MonadError Exception (mt Exception m)) => m t -> mt Exception m t or some such might be nicer, though not remotely close to H98 and heavily dependent on the MTL.
02:30:56 <paolino> quicksilver: still dropping the last element is expensive with Sequences ?
02:31:08 <quicksilver> paolino: no
02:31:16 <quicksilver> paolino: sequences are O(1) from both ends
02:31:28 <quicksilver> and O(faster than you'd think) for lots of operations
02:31:38 <wli> In essence dequeues.
02:31:56 <Cale> wli: better
02:32:11 <paolino> ah take (length xs -1) is O (1) ?
02:32:29 <quicksilver> paolino: probably but it's more idiomatic to use viewr
02:32:49 <Cale> You can split a sequence at position i in O(log(min(i,n-i))) time
02:33:17 <quicksilver> initlast s = let s' :> t = viewr s in (s',t)
02:33:27 * mux hopes we'll soon be able to write: foo (viewl -> EmptyL) = ...
02:33:35 <Cale> (and of course, index into the thing in that time)
02:35:17 <anybody> hi there. has anyone tried watching the OSCON haskell introduction online videos?
02:35:22 <quicksilver> Cale: 'take n' obviously shares all nodes; does it share a reasonable chunk of the tree-spine too?
02:35:24 <Cale> anybody: I have.
02:35:38 <Cale> quicksilver: yeah.
02:35:46 <Cale> quicksilver: (that's why it's so fast)
02:35:47 <anybody> Cale: i tried yesterday. they suck. the guy behind the camera seems to be an idiot
02:36:02 <Cale> anybody: Make sure you have the slides open at the same time
02:36:19 <anybody> Cale: oh. so i'm the idiot then ;-)
02:36:22 <Cale> It'd be pretty hard to follow if you don't.
02:36:34 * dolio watched without the slides.
02:36:40 <dolio> But I already know Haskell. :)
02:37:07 <anybody> i was just wondering what's the point in making a video if the only usefull information you get out of it is the audio channel
02:37:36 <Binkley> dude, it's SPJ
02:37:40 <anybody> i mean seeing the guy talking doesn't help at all
02:37:49 <Binkley> of course having the video conveys more information
02:37:52 <anybody> but i think i read he's from microsoft
02:37:53 <Binkley> that wouldn't be true with everyone
02:37:58 <anybody> so that must be the problem ;-)
02:38:04 <Cale> anybody: He's from MS Research
02:38:18 <quicksilver> SPJ has no characteristics in common with your prejudices about MS employees
02:38:23 <anybody> Cale: ah is MS trying to take over Haskell?
02:38:26 <Binkley> indeed
02:38:32 <quicksilver> MSR is much more like a university than it is like a company
02:38:43 <Cale> anybody: MS has essentially funded the development of GHC for some time now.
02:38:54 <quicksilver> indeed, MSR cambridge feels much like an extension of cambridge CS dept
02:39:00 <quicksilver> which I suspect is what they want :)
02:39:33 <Cale> anybody: The rest of MS probably is mostly unaware that this is going on :)
02:39:33 <Binkley> MSR Cambridge felt more like a CS department to me than some CS departments do :-)
02:40:12 <Cale> I rather like the idea of MS funding the production of BSD-licensed software.
02:40:26 * mux too
02:44:39 <dolio> Oh man, the guy who wrote that scathing 'review' of Why FP and Backus' functional programming paper wrote one for that recent one on concurrency posted to LtU.
02:44:50 <Binkley> link?
02:45:10 <dolio> http://my.opera.com/Vorlath/blog/2007/08/07/review-resources-concurrency-and-local-reasoning
02:45:12 <lambdabot> Title: Review: Resources, Concurrency and Local Reasoning - Software Development - by V ..., http://tinyurl.com/372f56
02:45:29 <paolino> quicksilver: how can you pu
02:45:31 <paolino> t
02:45:41 <paolino> (:>) in the pattern
02:45:43 <dolio> I haven't read the paper, so I don't know how good it is.
02:45:49 <quicksilver> paolino: that's what viewr returns
02:45:59 <dolio> But his reviews of the other two papers were pretty ridiculous, as I recall.
02:45:59 <quicksilver> dolio: I'm heavily biased and assume the paper is very good
02:46:09 <quicksilver> dolio: but that's on the basis of the author not the content :)
02:46:33 <quicksilver> paolino: viewr returns a 'ViewR' thing, and :> is the constructor for non-empty ViewRs
02:46:45 <quicksilver> paolino: it's all on the Data.Sequence docs
02:46:52 <paolino> ok
02:47:04 <paolino> (:>) is the constructor
02:47:44 <quicksilver> dolio: anyone who can say that "a whole lot of papers being written for nothing. About problems that need not exist and have been solved for over 30 years." has a lot of cojones
02:47:53 <quicksilver> dolio: and is either a perceptive genius or an idiot :)
02:48:18 <dolio> :)
02:48:25 <Binkley> whenever someone says that 90% of a paper is trivial...
02:48:39 <psykotic> ... they probably didn't understand 90% of it?
02:48:39 <vincenz> Binkley: they didn't get it?
02:48:47 <Binkley> vincenz: yeah
02:49:07 <dolio> As I recall, his critique of functional programming revolved around his impression that functions can only return to the same place they were called, or something.
02:49:20 <quicksilver> well, I don't know. It's quite often true that 90% of a paper is "set-up" work for the one result
02:49:24 <vincenz> which, however, could be due to two reasons: 1) the reader is lacking background, 2) the author didn't motivate/contextualize enough
02:49:25 <dolio> And that's some fundamental limitation that his alternative, totally unspecified system doesn't have.
02:49:26 <psykotic> i wouldn't say that's necessarily true--most papers are poorly written and could be pared down favorably.
02:49:33 <quicksilver> so only 10% is new
02:49:36 <wli> The cult of personality physics types back in colege went on about how Enrico Fermi used to read papers.
02:49:44 <vincenz> quicksilver: rght, but without that 90%, the paper would be useless
02:49:50 <quicksilver> depends the audience of the paper, but especially if it's for a non-specialist journal
02:49:57 <quicksilver> erm, non-sepcialist conference, I meant
02:49:57 <psykotic> quicksilver, what i dislike--when the scholarship dominates the research.
02:50:03 <wli> Something about how he would instantly be able to derive the result from the abstract etc.
02:50:04 <vincenz> the point of a paper is to convey the idea, not just express it
02:50:11 <quicksilver> what vincenz said
02:50:15 <psykotic> quicksilver, that is, you get half of a paper that's a survey of existing work.
02:50:20 <quicksilver> the expression of the idea is more compelling in context
02:50:25 <vincenz> psykotic: those are useful, actually
02:50:38 <vincenz> psykotic: great as reference and motivational for your own paper.
02:50:45 <quicksilver> if it's a well written survey and it accurately explains the cracks between the existing work, it's very useful
02:50:55 <quicksilver> of course, if it's a badly written survey it's terrible
02:51:12 <vincenz> quicksilver: if it's a badly written paper... it's terrible :P
02:51:19 <psykotic> i like it best when it's written more as an appendix then an essential part of the part that has to be traversed.
02:51:28 <quicksilver> also, papers have to get past referees, which mean they have to make sure that a non-specialist referee (who's in a terrible hurry) can see the "point"
02:51:35 <vincenz> psykotic: some papers are -only- surveys, and they're very useful as reference and motivational for many other papers
02:51:36 <psykotic> i'm a back of putting 'related work' at the end of the paper, as it tends to force better structure. though it's no guarantee.
02:52:00 <psykotic> vincenz, oh sure, but those serve entirely different purposes. i'm talking about reports on original research that feel the need to mention all related work, for scholarship/academic honesty reasons.
02:52:03 <vincenz> Not to mention that within a certain domian, som related work is just PR :)
02:52:08 <quicksilver> insufficient motivational material can mean it's not obvious what the 'point' of the research is
02:52:17 <psykotic> *i'm a fan
02:52:18 <quicksilver> and you can be dismissed as being unimportant
02:52:41 <vincenz> quicksilver: yep, especially in this day and age, where you don't get BIG idea,s but mostly apply ideas to different domains
02:52:56 <vincenz> motivation is 50% of your paper then, in terms of worth.
02:53:08 <vincenz> get that wrong, and a reviewer won't read the rest
02:53:31 <quicksilver> vincenz: that's what I was trying to say, yes
02:53:36 <vincenz> ;)
02:53:56 <vincenz> then we violently agree
02:54:09 <Binkley> Wow, I just finished reading that blog post... it seems like it was generated by a Markov chain
02:54:11 <quicksilver> vincenz: NO! I AGREE COMPLETELY! NO!
02:54:26 <wli> Binkley: Sokal v2.0
02:54:32 <vincenz> quicksilver: :D
02:54:58 <vincenz> quicksilver: it's sad but I actually have such discussions IRL
02:55:14 <vincenz> where you're disagreeing on some subtilities and you have to violently agree on other points, to make it clear what you disagree on
02:55:28 <vincenz> subtleties
02:55:33 <vincenz> damn my english is off today
02:55:36 <psykotic> Binkley, you just don't understand. he's a futurist!
02:55:41 <Binkley> lol
02:55:45 <vincenz> psykotic: link?
02:55:46 <psykotic> Binkley, if you were from the future, you'd understand.
02:55:49 <dolio> Hahaha.
02:55:51 <quicksilver> Binkley: yes, not very readable
02:55:59 <psykotic> vincenz, http://my.opera.com/Vorlath/blog/2007/08/07/review-resources-concurrency-and-local-reasoning
02:56:00 <lambdabot> Title: Review: Resources, Concurrency and Local Reasoning - Software Development - by V ..., http://tinyurl.com/372f56
02:56:20 <Binkley> http://my.opera.com/Vorlath/about/
02:56:21 <lambdabot> Title: Vorlath - About
02:56:26 <Binkley> "For example, creating distributed and parallel software is completely solvable without having to deal with threads, functions, locking or any of those so-called tools. In fact, all the details of parallel computing are quite natural and can be solved by thinking in a sequential manner."
02:56:36 <Binkley> Heh
02:56:42 <vincenz> oh that article
02:56:43 <Binkley> To think that all those researchers have been wasting their time!
02:56:47 <Binkley> If only they'd listened to this guy
02:56:47 <vincenz> I tuned out cause of how impossible it was to read
02:57:06 <Binkley> I should clarify, when I said "reading that blog post" I meant skimming it
02:57:06 <vincenz> for some reason, my mind automatically glazes over when reading the first paragraph
02:57:11 <Binkley> it was very tl;dr
02:57:36 <vincenz> if I can't get into an article by skimming it, then it's not well written
03:00:18 <psykotic> wow
03:00:19 <psykotic> http://my.opera.com/Vorlath/blog/2007/03/07/why-recursion-sucks
03:00:20 <lambdabot> Title: Why Recursion Sucks - Software Development - by Vorlath
03:00:36 <Binkley> oh boy
03:00:41 <dolio> Yeah. He's got a treasure trove there.
03:00:44 <anybody> lol
03:00:48 <fax> heh
03:00:50 <fax> "I'm using C++"
03:01:07 <vincenz> psykotic: haha
03:01:11 <vincenz> ""And yes, those ugly and multiple protected and public sections are because of dependencies. They need to show up in that order. If someone has a better way, please let me know."
03:01:14 <vincenz> simple
03:01:16 <vincenz> don't put your code inside your clas
03:01:19 <vincenz> put it in the .cpp
03:01:22 <anybody> http://my.opera.com/Vorlath/blog/....
03:01:23 <anybody> Title: Why My Life Sucks
03:01:24 * vincenz snickers
03:02:05 <psykotic> this really is like Sokal 2.0
03:02:11 <psykotic> or postmodern programming.
03:02:18 <vincenz> ?
03:02:24 <Binkley> choice quote: "If you think recursion is somehow inspiring, I think you should try something other than programming."
03:02:30 <psykotic> i can read the individual sentences and they sort of make sense. but when i try to read two consecutive sentences and conjoin their respective meanings, i just get lost and confused.
03:02:46 <Binkley> psykotic: yeah, that's why I guessed Markov chain
03:02:53 <vincenz> yeah
03:03:01 <vincenz> I mean he even uses terms like "inversion of control flow"
03:03:05 <Binkley> I think you would only need trigrams to generate something of this quality
03:03:07 <vincenz> in sensible sentences
03:03:14 <vincenz> but my mind glazes over when trying to read a paragraph
03:03:35 <dolio> He's argued with people on Lambda the Ultimate, too.
03:04:08 <dolio> It was some kind of 'every programming language in existence sucks, and I have the answers' sort of thing, I think.
03:04:31 <anybody> so who is this guy anyway?
03:04:31 <psykotic> as far as i can tell, he's encountered a real problem there, but it has nothing to do with recursion. basically, when an object calls out to unknown code, it has to ensure that object invariants are restored at the call boundaries, lest the called code call back into the object.
03:04:48 <psykotic> but... nothing to do with recursion.
03:04:57 <dolio> And then there was a lot of people pointing to various languages that had implemented his ideas and such.
03:05:43 <vincenz> i don't get it
03:05:50 <vincenz> his entire article talks about bad design
03:05:51 <Binkley> it almost makes me long for qwe1234
03:05:54 <Binkley> who at least is more succinct
03:05:56 <vincenz> and then suddenly he segways into "yes, recursion is bad"
03:06:36 <vincenz> and he keeps bringing up 'Project V'
03:06:49 <mr_tenor> ooo where's this? ;)
03:07:10 <Binkley> mr_tenor: http://my.opera.com/Vorlath/blog/2007/03/07/why-recursion-sucks - but it's really tl;dr
03:07:10 <lambdabot> Title: Why Recursion Sucks - Software Development - by Vorlath
03:07:44 <vincenz> Binkley: just think of the possibility... the convoluted writing of this guy, ,combined with the persistence of qwe1234
03:07:51 <vincenz> pure evil
03:08:07 <Binkley> vincenz: yes, he'd find a way to stretch out "stfu, moron" for 12 paragraphs
03:08:17 <mr_tenor> i stopped after the first paragraph :(
03:08:23 <Binkley> mr_tenor: that's wise
03:08:31 <vincenz> Binkley: not to mention make you reread it 10 times, to figure out wtf he's saying :)
03:09:02 <mr_tenor> Binkley: i thought it mightbeamusing but it sounds just ignorant
03:09:18 <Binkley> vincenz: right, there's be a lot of big words and it would take you a while but once you understood, you're realize all he was saying was, oh, something like...
03:09:20 <Binkley> @quote qwe1234
03:09:20 <lambdabot> qwe1234 says: all you happened to have demonstrated is that you suck at writing assembly code.
03:09:22 <Binkley> right
03:09:31 <Binkley> mr_tenor: there are a few amusing bits but it's mostly nonsense
03:10:50 <dolio> @quote qwe1234 lisp and php
03:10:51 <lambdabot> qwe1234 says: i'm still waiting for the list of differences between lisp and php that matter.
03:11:28 <vincenz> is it me or is qwe1234 getting more bitter?
03:11:33 <vincenz> more and more of his sentences end with stfu
03:11:36 <Binkley> haha
03:11:40 <vincenz> he no longer makes his 2 paragraph arguments
03:11:41 <Binkley> or maybe just less creative
03:11:45 <vincenz> I think augustss wore him down
03:12:00 <Binkley> yeah, augustss's exchanges with him were hilarious :-)
03:12:03 <Binkley> augustss++
03:12:34 <vincenz> yes, they'd start with violent disagreement from qwe, and then suddenly evolve into violent agreement :D
03:13:11 <mr_tenor> i'm saving that last quote :)
03:13:51 <vincenz> blegh, I really think that reddit should implement tagging
03:13:58 <vincenz> it's getting way too spammy with lots of stuff I care not about
03:14:29 <dolio> linuxer doesn't help any.
03:15:03 <dolio> He (it?) appears to be a bot that crawls all sorts of places and submits anything that matches some keywords.
03:15:59 <vincenz> yeah
03:16:06 <vincenz> it's amazing how much he posts
03:16:12 <vincenz> some of it is good actually
03:16:16 <vincenz> but too much spam
03:17:59 <dolio> I suppose some people feel the same about dons submitting every haskell related article he finds, too. :)
03:18:41 <vincenz> potentially, but we were there first :P
03:19:09 <vincenz> nowadays a lot of posts are only circumstantially related to programming, like language politics, or tools
03:22:22 <desp> @hoogle dayOfWeek
03:22:23 <lambdabot> System.Win32.NLS.lOCALE_IFIRSTDAYOFWEEK :: LCTYPE
03:22:28 <desp> @hoogle week
03:22:28 <lambdabot> System.Win32.NLS.lOCALE_IFIRSTDAYOFWEEK :: LCTYPE
03:22:28 <lambdabot> System.Win32.NLS.lOCALE_IFIRSTWEEKOFYEAR :: LCTYPE
03:22:30 <desp> :/
03:22:51 <vincenz> is that cobol article serious?
03:23:30 <anybody> who is qwe1234?
03:24:27 <vincenz> @qwe1234
03:24:27 <lambdabot> Unknown command, try @list
03:24:31 <vincenz> @quote we1234
03:24:32 <lambdabot> jmelesky says: I've figured out the problem. qwe1234 has different definitions of "functional programming", "compiler", "complexity theory", "math", and "optimization" than everybody else who deals
03:24:32 <lambdabot> with computers or computer science.
03:24:37 <vincenz> @quote we1234
03:24:38 <lambdabot> jmelesky says: I've figured out the problem. qwe1234 has different definitions of "functional programming", "compiler", "complexity theory", "math", and "optimization" than everybody else who deals
03:24:38 <lambdabot> with computers or computer science.
03:24:41 <vincenz> @quote qwe1234
03:24:41 <lambdabot> qwe1234 says: what you linked to is neither formal nor a notion.
03:25:05 <anybody> @quote qwe1234
03:25:05 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
03:25:26 <vincenz> qwe1234 is our guru
03:25:40 <vincenz> he speaks truth so abstract that we have yet to achieve the enlightement to fully understand them
03:25:59 <vincenz> his terminal 'stfu' on all his comments is like a true zenwhack to his grasshoppers
03:26:41 <anybody> haha
03:26:47 <anybody> @quote qwe1234
03:26:48 <lambdabot> qwe1234 says: lol, 'free university of amsterdam'.
03:26:56 <anybody> @quote qwe1234
03:26:56 <lambdabot> qwe1234 says: the problem is that ocaml has mandatory garbage collection.
03:27:05 <anybody> haven't spotted any stfu so far
03:27:12 <vincenz> they're only one liner quoets
03:27:15 <vincenz> s/et/te
03:27:17 <vincenz> check reddit
03:27:21 <anybody> @quote qwe1234
03:27:21 <lambdabot> qwe1234 says: i don't know about you, but i only use c++ because it gives static compile-time guarantees that assembly could never give.
03:27:30 <vincenz> http://programming.reddit.com/user/qwe1234/
03:27:32 <lambdabot> Title: overview by qwe1234 (on programming.reddit.com)
03:27:49 <desp> the Ed conspiracy :D
03:29:23 <anybody> lol
03:30:15 <anybody> how about this oneliner? qwe1234: no thank you. go fuck yourself.
03:30:28 <mauke> @keal
03:30:28 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
03:30:55 <dolio> That's a good one.
03:30:59 <desp> @yarr
03:30:59 <lambdabot> Arrr!
03:31:30 <anybody> @quote qwe1234
03:31:30 <lambdabot> qwe1234 says: the only reason for 'dispatching, polymorphism and parametrization' to exist at all is for enforcing safety.
03:31:47 <vincenz> classic :D
03:31:51 <anybody> how can i see all the quotes he has so far?
03:31:58 <anybody> in the bot?
03:31:59 <vincenz> use reddit
03:32:02 <vincenz> oh
03:32:03 <vincenz> hmm
03:32:09 <vincenz> no idea
03:32:12 <vincenz> don't think that's feasible
03:32:14 <mauke> read the source
03:32:18 <vincenz> mauke: it's not in the source
03:32:19 <vincenz> it's in State
03:32:23 <mauke> :(
03:32:28 <vincenz> it's quote, not a command like keal or palmoer
03:32:37 <opqdonut> @keal
03:32:37 <lambdabot> i want to invent white dye
03:32:39 <opqdonut> @keal
03:32:40 <lambdabot> i want to invent white dye
03:32:40 <anybody> qwe123: it's spelled "you're", you illiterate ape. p.s. i know haskell already, thx.
03:32:47 <opqdonut> @keal
03:32:47 <lambdabot> i only trust opensource tools. where can i download haskell for windows?
03:32:58 <anybody> haha
03:33:47 <wli> Hmm, how do I re-export modules hiding some symbols?
03:33:59 <vincenz> wli: oy
03:34:04 <vincenz> wli: why hide on export?
03:34:06 <vincenz> wli: why not hide on import?
03:34:11 <xerox> wli: just add module Foo in the export list.
03:34:20 <xerox> ...and import hiding.
03:34:37 <wli> The hiding list is long.
03:34:57 <vincenz> wli: use speific imports then
03:34:59 <xerox> Then do the converse, import precise things?
03:35:02 <vincenz> wli: in the module that reexports
03:35:08 <vincenz> what xerox said :)
03:35:33 <wli> The whole point of the reexporting module is to override certain things.
03:36:12 <wli> It needs to hide 14 things from the Prelude.
03:38:03 <xerox> I suppose there're more than 28 things in the prelude, so you may be better off hiding the culprits.
03:39:06 <wli> It's intended to override the stock definitions of IO functions with ones lifted into MonadIO
03:39:26 <wli> It's unusable as a library if importers are required to hide 14 things from the Prelude.
03:40:33 <xerox> Call it modeule MyPrelude (module Prelude) where import Prelude hiding (14 things).
03:41:50 <wli> Oh, that does work.
03:42:45 <xerox> Do you know how to do fast integer square root?
03:42:59 <matthew-_> square the other side?
03:43:10 <wli> Newton's method.
03:43:24 <xerox> Alright, I had that.
03:43:58 <wli> I always track bounds for these sorts of things.
03:45:41 <wli> Bit operations can narrow it down to between two powers of two. Find the highest bit b; (bit b)^2 <= n <= (bit (b+1))^2 (provided n >= 0 of course)
03:47:03 <wli> From there I choose the midpoint as the starting point of a Newton step, and then have 4 values to choose from for upper and lower bounds.
03:47:59 <wli> xerox: Thanks.
03:50:36 <wli> The midpoint guarantees you at least halve the bounding interval. The Newton step throws in an additional point that potentially does better (and better still in conjunction with the midpoint).
03:52:52 <wli> For floating point, throwing in Muller steps in addition to Newton steps and midpoints gives you potentially 5.
03:58:20 <wli> I'm surprised there isn't something like fiddling with a rational of degree type (3, 2) for endpoints and midpoint of a bracketing interval with function and derivative there.
03:59:50 <hpaste>  desp pasted "static typing for the lose?" at http://hpaste.org/2127
04:00:04 <desp> any better way of doing that?
04:00:39 <araujo> morning
04:00:43 <hpaste>  desp annotated "static typing for the lose?" with "main.hs" at http://hpaste.org/2127#a1
04:01:17 <wli> desp: What are you trying to do here?
04:01:22 <mauke> what's the point of IntOrInteger?
04:01:33 <quicksilver> desp: that's a despicable definition of show
04:01:46 <desp> yes, that code begs to be killed
04:01:59 <desp> the point is storing multivalued things
04:02:07 <Philippa_> desp: there's a better way of doing it if you don't need to be Haskell 98 - use an existential wrapper instead of IntOrInteger and then you can take any Integral
04:02:07 <quicksilver> desp: otherwise, yes, that's the general idea. You could just package up an 'Integral n => n'
04:02:27 <mauke> or just an Integer
04:02:46 <quicksilver> desp: but please don't use such Show instances :)
04:03:08 <desp> quicksilver: can you explain what do you mean about packaging up?
04:03:24 <desp> mauke: oh, I guess I could just use "fromIntegral" instead of a constructor, true.
04:03:38 <desp> Philippa_: ah, hm. checking.
04:03:40 <mauke> yeah
04:03:43 * wli tries to figure out a sane terminal driver interface.
04:04:03 <quicksilver> desp: data MkIntegral = forall a . Integral a => MkIntegral a
04:04:05 <quicksilver> IIRC
04:04:10 <kjdf> quicksilver: why is that bad definition of show?
04:04:18 <desp> kjdf: it's just pointless
04:04:26 <quicksilver> no, it's worse than that
04:04:30 <quicksilver> it violates the show invariant
04:04:37 <desp> huh?
04:04:40 <quicksilver> show should produce a text string which is valid haskell
04:04:48 <quicksilver> which can be pasted into a haskell file to recreate the value
04:06:00 <Baughn> Is there any way to have read return a circular list?
04:06:37 <mauke> I don't see why not
04:06:49 <Baughn> With the default instances?
04:06:51 <quicksilver> Baughn: for your own type, you can do what you want although you probably shouldn't :)
04:06:55 <quicksilver> Baughn: for [], no
04:07:48 <xerox> > read (show (let xs = 1 : xs in xs)) :: [Int]
04:07:52 <lambdabot> Terminated
04:08:15 <quicksilver> Baughn: it's worth bearing in mind that circular lists are not *observably* circular
04:08:18 <desp> @hoogle toWeekDate
04:08:18 <lambdabot> No matches found
04:08:24 <quicksilver> Baughn: they are observably infinite...
04:08:44 <Baughn> quicksilver: Without eq, that's true
04:08:59 <Japsu> > take 10 $ read (show (let xs = 1 : xs in xs)) :: [Int]
04:09:03 <lambdabot> Terminated
04:09:05 <quicksilver> Baughn: erm no, it's true even with eq
04:09:06 <Japsu> :<
04:09:17 <Baughn> quicksilver: Then why does CL have *print-circular*? ;)
04:09:18 <Japsu> show/read are not lazy?
04:09:29 <quicksilver> Baughn: oh, that eq
04:09:35 <quicksilver> Baughn: this is #haskell you know :P
04:09:37 <dolio> Baughn: You should roll your own with reallyUnsafePtrEquality. :)
04:09:43 <Baughn> quicksilver: I do. There is another eq in haskell?
04:09:49 <quicksilver> well there is Eq
04:09:53 <quicksilver> which is what I assumed you meant
04:09:57 <Baughn> I'm case-sensitive, here. :P
04:10:08 <mauke> then it's EQ
04:10:20 <quicksilver> consider my statement modified to 'circular lists are not observably circular *in* *haskell*
04:10:21 <Baughn> Ah. Um.. case-preserving?
04:10:23 <quicksilver> :)
04:10:54 <quicksilver> as a generalisation, it's fine to use circularity as a model for infinity, in haskell
04:10:56 <mauke> EQ, EQL, EQUAL, EQUALP, =, STRING=
04:10:58 <mauke> OBVIOUS
04:11:00 <quicksilver> but it's a poor model for circularity
04:11:10 <fax> what about STRING-EQUAL ????
04:11:38 <Baughn> You forget String-equalp
04:11:43 <quicksilver> dolio: the great think about reallyUnsafePtrEquality is it is cross-type
04:12:13 <quicksilver> dolio: in a GHC compiled program reallyUnsafePtrEqual ([] :: [Int]) ([] :: [Char]) == True
04:12:42 <dolio> Does that work? I thought it was a -> a -> Int# when I looked just now.
04:13:36 <quicksilver> dolio: sorry, it was a theoretical a -> b version
04:13:50 <wli> if if then then else else ;)
04:14:13 <dolio> Ah. Yeah. I suppose that's easy with a little unsafeCoerce#. :)
04:14:37 <dolio> Doesn't even increase the asymptotic unsafeness.
04:18:29 <dolio> Of course, even reallyUnsafePtrEquality might not get the job done...
04:19:03 <dolio> 'let f x = I# (reallyUnsafePtrEquality# x (id x))' 'f 2 ==> 0'
04:19:16 <desp> @hoogle (a, b, c) -> c
04:19:20 <lambdabot> No matches, try a more general search
04:19:26 <desp> @hoogle (a, b) -> b
04:19:27 <lambdabot> Prelude.snd :: (a, b) -> b
04:19:27 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
04:19:27 <lambdabot> Prelude.fst :: (a, b) -> a
04:19:34 <quicksilver> dolio: oh, it compares without forcing?
04:19:52 <dolio> So it seems.
04:19:59 <quicksilver> dolio: then you just want x `seq` y `seq` reallyUnsafePtrEquality# x y
04:20:27 <quicksilver> desp: the prelude is strangely silent on functions for dealing with triples
04:20:40 <quicksilver> desp: I just use \(_,_,x) -> x
04:20:49 <mauke> (a, (b, c))
04:20:50 <quicksilver> desp: it doesn't take very long to type and it's very clear, IMO
04:20:56 <wli> There used to be curry3
04:21:02 <desp> true
04:21:10 <fax> > (,,) (,) (,) 1 2 3 4
04:21:11 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t3 -> t'
04:21:14 <fax> >:|
04:21:25 <quicksilver> > (,,) (,) (,) 1 2 3 4 5
04:21:26 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t3 -> t4 -> t'
04:21:28 <fax> > (,) (,) (,) 1 2 3 4
04:21:28 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t3 -> t4 -> t'
04:21:37 <quicksilver> ah
04:21:45 <quicksilver> > (,,) (,) (,)
04:21:46 <lambdabot>  Add a type signature
04:21:49 <quicksilver> :)
04:21:51 <wli> Analogues of first and second for triples could be handy.
04:21:56 <fax> > (,,) (,) 1 2 (,) 3 4
04:21:57 <lambdabot>  Couldn't match expected type `(a -> b -> (a, b)) -> t1 -> t2 -> t'
04:22:06 <ivant> > (,,) (,) 1 2 3
04:22:06 <lambdabot>  Couldn't match expected type `t1 -> t'
04:22:12 <ivant> > (,,) (,) 1 2 3 4
04:22:13 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
04:22:16 <ivant> > (,,) (,) 1 2
04:22:16 <wli> (arrows in general really)
04:22:16 <lambdabot>  Add a type signature
04:22:30 <fax> > (,):: (Int, Int) (,):: (Int, Int) (,):: (Int, Int) 1 2 3 4
04:22:30 <lambdabot>  Parse error
04:22:42 <mauke> > (,,) ((,) 1 2) 3 4
04:22:43 <lambdabot>  ((1,2),3,4)
04:22:52 <ivant> > (,) (,) 1 2 3
04:22:53 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
04:22:57 <quicksilver> wli: a whole library of arrow combinators for > 2-tuples would require some hairy typeclasses
04:23:11 <ivant> > (,) 1 (,) 2 3
04:23:12 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
04:23:14 <wli> quicksilver: heh
04:23:18 <ivant> > (,) 1 $ (,) 2 3
04:23:20 <lambdabot>  (1,(2,3))
04:23:20 <fax> > (,) (,) (,) 1 2 3 4 :: ((Int, Int), (Int, Int))
04:23:21 <lambdabot>  Couldn't match expected type `t
04:23:31 <quicksilver> that would be (,) $ (,) 1 2 $ 3  if only $ was left-associative
04:23:39 <wli> quicksilver: It might help if I understood the arrow libraries already in place.
04:23:40 <quicksilver> silly $
04:23:49 <dons> i think we should just tell people who ask for tuple apis: tuples are not lists, nor are they trees.
04:23:57 <quicksilver> wli: the error messages and type signatures would get nasty :
04:24:08 <quicksilver> wli: although it's certainly quite *possible*
04:24:10 <ivant> ap ((,) 3) (1,2)
04:24:20 <ivant> >ap ((,) 3) (1,2)
04:24:29 <fax> > ((,) (,) (,) :: ((Int, Int), (Int, Int))) 1 2 3 4
04:24:29 <lambdabot>  Couldn't match expected type `(Int, Int)'
04:25:01 <mauke> a tuple of functions is not a function of tuples
04:25:24 <wli> Well, I've no interest into turning tuples into lists or trees. I get get > 2-tuples often enough for the lack of things to work with them to be annoying.
04:25:57 <fax> > ((,) (,) (,) :: (((Int, Int), Int), Int)) 1 2 3 4
04:25:58 <lambdabot>  Couldn't match expected type `((Int, Int), Int)'
04:25:58 <wli> Mostly triples.
04:26:16 <earthy> mauke: uncurry (***) seems to disagree
04:26:17 <quicksilver> it's certainly not hard to define a couple of combinators yourself
04:26:22 <mauke> :t (,) (,) (,)
04:26:25 <lambdabot> forall a b a1 b1. (a -> b -> (a, b), a1 -> b1 -> (a1, b1))
04:26:30 <quicksilver> in a module which uses a lot of triples
04:27:07 <fax> > ((,) (,) (,) :: (Int -> Int -> (Int, Int), Int -> Int -> (Int, Int))) 1 2 3 4
04:27:08 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t3 -> t4 -> t'
04:27:29 <mauke> fax: you can't call tuples
04:27:43 <fax> oh :[
04:27:55 <dolio> (a -> b -> (a,b), c -> d -> (c,d)) /= a -> b -> c -> d ((a,b),(c,d))
04:27:58 <mauke> a tuple is not a big truck
04:28:02 <mauke> it's series of tubes!
04:28:10 <dolio> Heh.
04:28:11 <quicksilver> with trucks in them
04:30:03 <fax> > let f = (,) in 1 `f` 2 `f` 3 `f` 4
04:30:04 <lambdabot>  (((1,2),3),4)
04:30:14 <fax> > let f = (,) in (1 `f` 2) `f` (3 `f` 4)
04:30:16 <lambdabot>  ((1,2),(3,4))
04:30:18 <fax> :D
04:30:37 <fax> > let f = (,) in (`f`) `f` (`f``) 1 2 3 4
04:30:37 <lambdabot>  Parse error
04:30:54 <mauke> > let (-->) = (,) in fromList ["foo" --> 1, "bar" --> 2]
04:30:55 <lambdabot>   Not in scope: `fromList'
04:31:56 <fax> how come
04:31:57 <dolio> :t M.fromList
04:31:57 <fax> > let (!) = (,) in (1!2)!(!) 3 4
04:31:59 <lambdabot> Couldn't find qualified module.
04:32:00 <lambdabot>  ((1,2),(3,4))
04:32:02 <fax> but not
04:32:05 <fax> > let (!) = (,) in (1!)!(!) 2 3 4
04:32:06 <lambdabot>  Couldn't match expected type `t -> b'
04:32:29 <mauke> fax: because (!) doesn't take three arguments
04:33:27 <dolio> (1!)!(!) 2 3 4 = (\x -> (1,x), (,) 2 3 4)
04:33:34 <mauke> > let (!) = (,) in (1 !) 2 ! (!) 3 4
04:33:36 <lambdabot>  ((1,2),(3,4))
04:34:12 <fax> > (\ a b c d -> ((a,b),(c,d))) 1 2 3 4
04:34:14 <lambdabot>  ((1,2),(3,4))
04:34:32 <mauke> @pl (\ a b c d -> ((a,b),(c,d)))
04:34:32 <lambdabot> flip flip (,) . (((.) . (.) . (,)) .) . (,)
04:34:38 <fax> yes :D
04:35:22 <earthy> > (curry $ curry . uncurry (***) . ((***) (,) (,))) 1 2 3 4
04:35:23 <lambdabot>  ((1,3),(2,4))
04:35:24 * earthy whistles
04:35:36 <fax> wooah
04:35:39 <fax> :t ***
04:35:41 <lambdabot> parse error on input `***'
04:35:45 <wli> What arrows are there that aren't functions?
04:35:58 <hkBst> :t (***)
04:36:00 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:36:02 <earthy> wli: monads
04:36:03 <quicksilver> those signs you get at roundabouts
04:36:15 <dolio> wli: Parser combinators based on arrows.
04:36:24 <earthy> wli: fudgets
04:36:28 <xerox> ArrowState
04:36:32 <earthy> wli: yampa stuff
04:36:36 <dolio> wli: Various GUI combinator libraries.
04:36:40 <ski> CoKleisli
04:36:43 <wli> How are parser combinators arrows?
04:36:44 <xerox> StreamArrow :: [a] -> [a]
04:37:10 <ski> xerox : stream transformers ?
04:37:55 <ski> @google swierstra duponcheel parser
04:37:57 <lambdabot> http://citeseer.ist.psu.edu/swierstra96deterministic.html
04:37:57 <lambdabot> Title: Deterministic, Error-Correcting Combinator Parsers - Swierstra, Duponcheel (Rese ...
04:38:10 <xerox> wli: one example is Parser a -> Parser (a -> b) -> Parser b, which can only parse context-free things.
04:38:25 <ski> @type ap
04:38:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:38:30 <xerox> Compare with Parser a -> (a -> Parser b) -> Parser b, the interface of monadic parsing.
04:38:54 <wli> Okay.
04:38:54 <earthy> the advantage of the former is that it allows optimizations that the latter doesn't
04:39:12 <earthy> otoh: the latter allows taking into account contextual infor
04:39:16 <xerox> There're some very neat papers about error-correcting arrow-style-parsers.
04:39:24 <xerox> Oh, ski had it few lines ago :)
04:39:54 <earthy> yeah. and Swierstra ought to get a move on redoing the docs on int
04:39:56 <earthy> it
04:39:56 <wli> What are (>>>), (***), (&&&) for parsers? (I've seen that paper before and not understood much from it.)
04:40:07 <earthy> wli: (***) =~ <*>
04:40:13 <earthy> err... nope
04:40:23 * earthy is still learning the arrow combinators
04:40:34 <tuxplorer> In http://haskell.org/haskellwiki/Cookbook, in the 11th part (Network Programming), why is the hPutStr used to add the HTTP header? The page would anyways render even without the header right?
04:40:35 <lambdabot> Title: Cookbook - HaskellWiki
04:40:46 <xerox> wli: there's one implementation that you can use for experiments, hang on.
04:40:47 <quicksilver> arrow parsers can also in principle be reversible
04:40:49 <wli> Well, I've got a vague idea of what they do for functions.
04:40:54 <quicksilver> which monadic parsers can never be AFAIK
04:41:03 <wli> xerox: Cool, thanks.
04:41:30 <xerox> <http://www.cs.helsinki.fi/u/ekarttun/PArrows/doc/>
04:41:33 <wli> tuxplorer: Probably unlines somewhere in the assembly of its input.
04:41:45 <quicksilver> tuxplorer: eh?
04:41:50 * earthy thanks xerox
04:41:54 <quicksilver> tuxplorer: hPutStr is used to send the HTTP request to the server
04:42:07 <quicksilver> tuxplorer: without that request, there would be no page produced...
04:42:10 <tuxplorer> quicksilver: oops! ok. now I get it
04:42:14 <quicksilver> :)
04:42:25 * xerox welcomes people :)
04:42:33 <earthy> uhm, xerox, there's no arrow instance documented...
04:42:45 <tuxplorer> quicksilver: I thought that connectTo with the port no automatically sends the request..
04:43:12 <tuxplorer> quicksilver: but ya, connectTo is a generic function.. didn't realise that for a moment
04:43:15 <quicksilver> tuxplorer: connectTo opens a TCP socket, nothing more
04:43:18 <quicksilver> tuxplorer: right
04:43:29 <xerox> earthy: yes, it's not exported. <http://www.cs.helsinki.fi/u/ekarttun/PArrows/PArrows/src/Text/ParserCombinators/PArrow/MD.hs>
04:43:29 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/PArrows/PArrows/src/Text/ParserCombinators/PArrow/MD.hs>
04:43:50 * earthy had found it already
04:43:58 <earthy> yeah >>> == <*> in Doaitse's stuff
04:44:41 <wli> checking
04:45:03 <earthy> hm. I think I don't really see the use of (***) in the parser combinators though
04:46:22 <earthy> 'matcher (MParWire _ _)  _ = error "matcher on ParWire"
04:46:23 <earthy> '
04:46:25 <earthy> *AH*. :)
04:46:50 <wli> GADT's mixed with arrows oh boy am I ever confused now.
04:47:21 <wli> Looks like all it does is build up a data structure.
04:47:22 <earthy> oh, right, that's GADTs. hadn't even noticed that. :)
04:47:46 <earthy> wli: look in Prim.hs for the runParser that actually runs the parser
04:49:57 <wli> It basically recapitulates the precise AST of parser combinators used to define the parser.
04:50:14 <wli> And interprets it directly as a sort of decision tree.
04:51:20 <wli> One could obviously e.g. analyze the thing and crunch it down to a state machine.
04:53:04 <wli> In fact I don't see much of a reason to roll my own front end given this...
04:55:07 <wli> Cyclic structures OTOH make it a bit harder.
04:56:11 <fax> @pl (\ a b c d -> (((a,b),(b,a)),((c,d),(d,c))))
04:56:11 <lambdabot> flip flip (ap (ap . ((,) .) . (,)) (flip (,))) . (((.) . (.) . (,)) .) . ap (ap . ((,) .) . (,)) (flip (,))
04:56:24 <wli> I suppose one detects cycles via some sort of vertex labeling scheme, which is absent in the parser combinator interface.
04:57:21 <wli> I'm not sure if you can do such labeling yourself, but I suspect not.
04:57:37 <xerox> wli: you can label parsers, that's <?> is for, if it is enough
04:58:11 <ski> HOAS ?
04:58:18 <wli> xerox: I'm speaking of an implementation, not some optional method provided by the thing.
04:58:27 <wli> s/thing/interface
04:59:36 <ski> foo = pfix $ \foo -> ..foo..
04:59:43 <wli> xerox: Basically what I want to implement is parser combinators that build up grammar or state machine or something so GLR can be used.
05:01:07 <wli> xerox: Essentially so parser combinators can be applied to harder parsing problems. This left factoring crap with recursive descent is pure crap.
05:01:31 <wli> LL(k) my arse.
05:01:40 <integral> @karma+ wli
05:01:41 <lambdabot> wli's karma raised to 1.
05:01:57 <quicksilver> it's not that hard to write a parser type which can indicate what first token it is expecting
05:02:09 <xerox> LL(omega) :)
05:02:12 <quicksilver> and use that to factor your grammar/build tables etc
05:04:09 <dv^> http://dis.4chan.org/read/prog/1186567977/
05:04:11 <lambdabot> Title: 4chan BBS - Haskell is beginning to suck
05:05:19 <quicksilver> :)
05:06:04 <MarcWeber> dcoutts: I've some trouble installing gtk2hs on windows. I"ve downloaded ghc-6.6.1.2xxx which is the current version of ghc. I think the different minor version causes the installer to tell me that I have to fix some dll trouble myself. The problem is that gtk etc is'nt registered at the pkg database. I've checked this using cmd  cd C:\ghc-X\bin; ghc-pkg list
05:06:40 <dcoutts> MarcWeber: ghc-6.6.1.2xxx ? not 6.6.1 exactly?
05:07:01 <MarcWeber> dcoutts: Where can I find that?
05:07:19 <dcoutts> MarcWeber: for the dll thing, what did it say exactly? it should have told you some files that it found that were clashing with the ones it wanted to install
05:07:23 <MarcWeber> I could'nt find it on the download page. Any way, the installer did say "regitering ... "
05:07:42 <dons> dv^: heh
05:08:22 <dcoutts> MarcWeber: to find out why it's not registering you can register manually and see what error message ghc-pkg gives you
05:08:47 <dcoutts> MarcWeber: cd to the gtk2hs install directory and use ghc-pkg register gtk.package.conf
05:09:08 <dcoutts> erm actually start with glib.package.conf
05:09:29 <dcoutts> or was it glib.conf, I don't recall. It's in the C:\program files\gtk2hs\ directory
05:09:33 <MarcWeber> Oh .. I was only looking for a register.sh .. Thanks. I'll have to reboot.
05:09:45 <MarcWeber> I'll look for any .conf files ;) Tx!
05:09:46 <dcoutts> MarcWeber: erm? no need to reboot
05:10:03 <dcoutts> the gtk2hs installer never requires rebooting
05:11:11 <dcoutts> MarcWeber: but the more interesting question is what dll files the installer reported it didn't like
05:11:18 <MarcWeber> dcoutts: I'm on gentoo right now.
05:11:27 <dcoutts> oh ok :-)
05:11:35 * dcoutts recommends sticking to gentoo
05:11:57 <dcoutts> >150 haskell packages available in the gentoo haskell overlay :-)
05:11:58 <MarcWeber> I'd like to. But the application I've written should run on windows.
05:12:02 <dcoutts> aye
05:12:27 <dcoutts> MarcWeber: so run the installer again and copy & paste the message about the dlls
05:12:27 <MarcWeber> *g* I've seen it. We'll have this in the near future on windows as well (wxwings or nix :-)
05:12:43 <MarcWeber> yep Thanks. But I have to finish another task first
05:13:36 <dcoutts> MarcWeber: np, and for the registration, try it manually with ghc-pkg, the package text files are in the gtk2hs dir. And paste whatever error message ghc-pkg gives. That'll be most helpful for diagnosing the problem.
05:13:56 <dcoutts> MarcWeber: ping me when you've got round to it
05:15:12 <dons> dcoutts: woot
05:15:19 <dons> 150 packages. very good.
05:15:35 <dcoutts> @arr!
05:15:36 <lambdabot> Shiver me timbers!
05:15:45 * earthy dances around loving haskell
05:15:54 * earthy hugs instance Monoid Ordering
05:21:36 <dons> woo monoid!
05:21:45 <desp> quicksilver: is this bad?
05:21:46 <desp> instance Show Showable where show (S a) = show a
05:21:56 <dons> mmm. sourdough + vegemite.
05:22:19 <quicksilver> desp: yes, in my opinion it is
05:22:49 <quicksilver> desp: because what you produce is an expression which evals to the 'a', but not to the 'Showable'
05:23:07 <desp> yes, but the value produced is valid Haskell
05:23:18 <quicksilver> valid haskell but not representing the shown value
05:23:31 <quicksilver> I could write instance Show Int where show x = "[]"
05:23:41 <quicksilver> that would be valid haskell too :P
05:23:45 <vincenz> dumdeedum
05:23:51 <desp> okay, but Showable is just hack that works around the bondage ;p
05:24:07 <vincenz> dons: I'm going to be annoying and ask if you can remove #oasis from the autojoin channels whenver you next recompile lambdabot
05:24:12 <quicksilver> still, Showable is a different type from Int
05:24:19 <ski> shows (S a) = showParen True $ showString "S " . shows a
05:24:46 <dons> vincenz: ok. sure. may i ask why?
05:25:01 <vincenz> dons: the logging
05:25:10 <dons> i could disable that instead?
05:25:11 <vincenz> dons: I like #oasis to be a free discussion forum, permanent logging frightens many
05:25:27 <vincenz> dons: well yes, but last time you disabled and then reenabled for icfpc, all the old stuff was still there o.O
05:25:52 <dons> ok. you just want me to disable the autojoin, and it won't join next time?
05:25:52 <vincenz> Apologies about the nuissance.
05:26:03 <vincenz> Well that would be the easiest solution against logging
05:26:08 <dons> done.
05:26:10 <vincenz> thanks
05:26:17 <dons> it'll disappear on the next reboot, or @part
05:26:21 <vincenz> easiest = minimum effort on your part
05:27:00 <vincenz> (I hope)
05:27:47 <earthy> damn! the overlapping instances check doesn't take into account the context of the instances
05:27:57 <vincenz> earthy: nope
05:28:19 <earthy> okay, time to redo 80% of my boilerplate
05:39:06 <wli> What on earth is ArrowLoop... and what are these arrow transformers?
05:39:31 <ski> 'ArrowLoop' is for recursion
05:39:48 <ski> monad : monad transformer :: arrow : arrow transformer
05:40:02 <wli> Well, I figured that much out.
05:40:25 <ski> @type Control.Arrow.loop
05:40:27 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
05:40:47 <vincenz> hmm
05:40:48 <vincenz> d is state?
05:40:48 <wli> I don't know how to interpret that type.
05:40:51 <ski> the local output 'd' is fed back as local input 'd'
05:40:51 <ddarius> The diagrams at haskell.org/arrow describe the arrow combinators well and there's not much to say about an arrow transformer
05:41:01 <vincenz> ski: state :)
05:41:18 <ski> think of it as a mealy (or was it moore ?) sequential circuit
05:41:26 <vincenz> ArrowLoop is to Arrows as MonadState is to Monads :)
05:41:32 <ski> vincenz : well, not quite
05:41:36 <vincenz> sort of
05:41:42 <vincenz> in a very hand-wavy way
05:42:13 <ski> the input arrow is only run *once*, and the 'd' output is the same as the 'd' input (not the "next" one or something like that)
05:42:19 <vincenz> what I wonder is why you don't have to input the first d
05:42:33 <vincenz> where does the initial d come from
05:42:34 <ddarius> Hmm, well there were some nice diagrams at www.haskell.org/arrows
05:42:37 <vincenz> or is this like fix?
05:42:43 * ski wonders how similar 'loop' is to 'trace' in .. hm .. vector spaces, i think
05:42:50 <ski> yes, like 'fix'
05:42:51 <quicksilver> ski: very similar
05:43:01 <quicksilver> 'loop' is like a feedback loop in control systems
05:43:02 <quicksilver> AIUI
05:43:08 <quicksilver> arrows have a lot in common with control
05:43:13 <vincenz> quicksilver: you need an initial token, no?
05:43:37 <ski> no
05:43:45 <vincenz> then arrowloop only works for lazy d's
05:43:51 <vincenz> (for instance, lists)
05:44:40 <ski> instance ArrowLoop (->)
05:44:44 <ski>   where
05:44:48 <ski>   loop f b = c
05:44:53 <ski>     where
05:44:55 <ski>     (c,d) = f (b,d)
05:45:02 <vincenz> d is never used
05:45:04 <vincenz> rather pointless
05:45:14 <ski> it is passed back
05:45:15 <vincenz> wait, never mind what I said
05:45:23 <vincenz> my former point is still held, you need lazy d's
05:45:27 <vincenz> :|
05:45:37 <ski> yes, some kind of laziness, i think
05:46:02 <vincenz> > Control.Arrow.loop (\(x,l) -> if x == 0 then (x,l) else (x-1, x:l))
05:46:04 <lambdabot>  <Integer -> Integer>
05:46:06 <vincenz> > Control.Arrow.loop (\(x,l) -> if x == 0 then (x,l) else (x-1, x:l)) 1
05:46:07 <lambdabot>  0
05:47:00 <tuxplorer> are there any modules in haskell for sampling music files of various formats like mp3, ogg, wma, etc
05:47:25 <quicksilver> vincenz: well if you never inspect "d" then you're not going to get very interesting feedback behaviour :)
05:47:38 <vincenz> quicksilver: right
05:47:46 <vincenz> quicksilver: but if you inspect d... then you can have an infloop
05:47:51 <vincenz> > Control.Arrow.loop (\(x,l) -> if x == 0 then (head l,l) else (x-1, x:l)) 10
05:47:53 <lambdabot>  9
05:47:53 <vincenz> 1
05:48:04 <vincenz> hmm
05:48:08 <vincenz> o.O
05:48:53 <quicksilver> it's the generalisation of "fix" for functions
05:48:58 <vincenz> why is it 9 and not 1?
05:49:04 <quicksilver> so you can use that to define a factorial if you like
05:49:17 <ddarius> > loop (\(xs,x) -> (x:xs,x+1)) 0
05:49:18 <lambdabot>   add an instance declaration for (Num [d])
05:49:26 <quicksilver> for kleislis it's mfix, I believe
05:49:32 <ddarius> > loop (\(xs,x) -> (x:xs,x+1)) []
05:49:34 <lambdabot>  Exception: <<loop>>
05:49:40 <vincenz> ddarius: the second argument must be lazy
05:49:45 <ddarius> vincenz: Yep.
05:49:57 <vincenz> but ... why is the example I gave giving 9?
05:50:10 <vincenz> obviously x is 0 if in the last turn x was 1, which should then be on the head
05:50:35 <vincenz> or it's not looping?
05:51:27 <ddarius> vincenz: It doesn't recurse.
05:51:28 <wli> I don't see how to use it to define factorials.
05:51:38 <vincenz> ddarius: why is it called 'loop' then?
05:51:58 <ddarius> vincenz: It makes a loop in the values.
05:52:03 <vincenz> hmm
05:52:15 <vincenz> I should let that digest along with my lunch
05:53:24 <ddarius> > loop (\(n,f) -> (f n,\n' -> if n' == 0 then 1 else n'*f n')) 5
05:53:26 <lambdabot>  Exception: stack overflow
05:53:39 <ddarius> > loop (\(n,f) -> (f n,\n' -> if n' == 0 then 1 else n'*f (n' - 1))) 5
05:53:40 <lambdabot>  120
05:53:41 <ddarius> Silly me.
05:54:13 <wli> ah
05:57:43 <wli> map (loop (\(n, fibs) -> (fibs !! n, 0 : 1 : uncurry (zipWith (+)) (id &&& tail $ fibs)))) [1..10]
05:58:21 <wli> That could be quite handy.
05:59:16 <vincenz> unevaluated code is like unsung poems
05:59:25 <vincenz> >  map (loop (\(n, fibs) -> (fibs !! n, 0 : 1 : uncurry (zipWith (+))
05:59:25 <lambdabot>  Parse error
05:59:31 <vincenz> >  map (loop (\(n, fibs) -> (fibs !! n, 0 : 1 : uncurry (zipWith (+)) (id &&& tail $ fibs)))) [1..10]
05:59:33 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
05:59:55 <vincenz> wli: ouch, that's addinig an extra O(n) for no reason
06:00:02 <MarcWeber> dcoutts mawercer.de/marcweber/msg.jpg That's the message
06:00:27 <wli> vincenz: Well, I couldn't be arsed to do anything efficient.
06:01:03 <dcoutts> MarcWeber: oops, the continue button should not appear in that situation. It's not a recoverable thing at all.
06:01:17 <dcoutts> MarcWeber: the solution is to install 6.6.1
06:01:34 <dcoutts> where did you get this version from?
06:02:26 <dcoutts> xerox: ping
06:02:33 <MarcWeber> The homepage "current"
06:02:39 <MarcWeber> There is no pacakge.conf like file at all
06:02:57 <dcoutts> MarcWeber: http://haskell.org/ghc/download_ghc_661.html
06:02:57 <lambdabot> Title: GHC: Download version 6.6.1
06:04:02 <MarcWeber> dcoutts http://mesh.dl.sourceforge.net/sourceforge/gtk2hs/gtk2hs-0.9.12.exe I downloaded this link
06:04:04 <lambdabot> http://tinyurl.com/2jzqar
06:04:35 <dcoutts> MarcWeber: yes, I meant where did you get your ghc from, the main ghc page points you to the stable version
06:04:45 <dcoutts> which is the one you want
06:04:51 <MarcWeber> dcoutts Neils version ? I've gotten the other one..
06:05:06 <MarcWeber> The msi from the page you gave me.
06:05:12 <MarcWeber> Perhaps I should try the Neil version
06:05:16 <Igloo> Use Neil's one
06:05:49 <ddarius> loop isn't too interesting, and certainly not worthwhile, for the (->) arrow.
06:07:11 <dcoutts> MarcWeber: it should not matter which one you get, both should report themseles as being 6.6.1, not 6.6.1.blah.blah
06:07:53 <wli> ddarius: Where does it get interesting?
06:08:04 <Igloo> dcoutts: But Sigbjorn's doesn't  :-)
06:08:14 <dcoutts> Igloo: what?!
06:08:27 <dcoutts> Igloo: but then it's not binary compatible
06:08:40 <dcoutts> since ghc does exact .hi version number checks
06:08:48 <ddarius> wli: For more interesting arrows.  It's like mfix for the Identity monad.  For, for example, stream processors (i.e. discrete time signal processing) loop can be used for feedback.
06:08:53 <Igloo> I guess so
06:08:57 <dcoutts> aaargh
06:09:32 <dcoutts> Igloo: if it really is incompatible we should remove it from the download page
06:09:50 <Igloo> Yeah; if someone confirms that then I'll do so
06:10:08 <dcoutts> otherwise there's no way for people building libs to do the right thing
06:10:15 <dcoutts> ndm: could you check it out?
06:10:31 <wli> ddarius: I'm going to have to use them to see.
06:10:41 <ndm> dcoutts, check what exactly?
06:10:48 <dcoutts> ndm: install both the installers from the ghc-6.6.1 download page and see if .hi files compiled with one, are accepted by the other
06:11:05 <ndm> dcoutts, i don't have enough disk space on this machine to try that
06:11:06 <ddarius> wli: Ever been interested in digital electronics?
06:11:08 <karmazilla> is HaskellDB the defacto api for interfacing with ie. MySQL?
06:11:33 <dcoutts> ndm: ah your 500Mb disk :-)
06:11:35 <wli> ddarius: Not really, but I took classes in various things.
06:11:47 <dcoutts> eivuokko: could you have a go?
06:11:56 <wli> e.g. circuit analysis
06:12:08 <kaol> karmazilla: there's HDBC and HSQL too. use what you like.
06:12:15 <dcoutts> eivuokko: eg make Foo.hs and Bar.hs, have Bar import Foo, compile Foo with one ghc, then try to compile Bar with the other ghc
06:12:18 <Nucleo_2> I get "memory allocation failed (requested 2097152 bytes)" -- is there a runtime flag I should be using?
06:12:40 <dcoutts> eivuokko: see if the second ghc complains about the .hi version number when it reads Foo.hi while trying to compile Bar.hs
06:12:52 <moonlite__> karmazilla: there's also takusen
06:13:35 <ndm> it would be rather embarassing if GHC 6.6.1 isn't even compatible with itself
06:13:41 <ndm> i went straight from the tarball
06:13:42 <ddarius> wli: A simple digital circuit simulator is not a bad example for one use of arrows.
06:13:53 <karmazilla> kaol: HSQL latest release is from 2005, iirc, so I thought that maybe the focus of development was someplace else
06:13:55 <eivuokko> dcoutts, Ok, I'll try.
06:14:02 <dcoutts> ndm: yours is fine, it's 6.6.1, it's the other one that might be 6.6.1.2007blahblah
06:14:09 <moonlite__> karmazilla: hdbc is a little bit more maintained.
06:14:32 <dcoutts> eivuokko: thanks very much
06:14:39 <kaol> HDBC is what I've been using myself
06:14:48 <moonlite__> karmazilla: basically HSQL and HDBC (as i understand it) are the more "lowlevel" alternatives and then takusen and haskelldb are layers above that
06:15:19 <moonlite__> with haskelldb providing typesafety (and takusen too?, i have no idea what takusen does really)
06:21:24 <vincenz> Does anyone know if you can ahve scoped type-declarations inside data-definitions?
06:22:31 <eivuokko> dcoutts, I can't get compile errors for some reason, but --show-iface fails, when I compiled using Sigbjorn Finne's installer and ghc --show-ifaced with Neil's.
06:22:50 <eivuokko> dcoutts, mismatched interface file versions: expected 6061, found 606120070503
06:22:55 <dcoutts> ah ha!
06:23:00 <dcoutts> that's the one
06:23:10 <dcoutts> eivuokko: thanks very much
06:23:16 <dcoutts> Igloo: so you can kill it
06:23:31 <eivuokko> Hmmm
06:23:40 <dcoutts> and tell Sigbjorn to come back with a read 6.6.1
06:23:47 <dcoutts> if he wants to
06:23:54 <eivuokko> I really want to get a real compile error.
06:24:29 <dcoutts> eivuokko: do you make it import and use something from the dependent module?
06:24:35 <eivuokko> Yea
06:24:37 <Igloo> eivuokko: Try with -O, and using a type and value that you import
06:24:46 <dcoutts> that was enough to show that problem between 6.6 and 6.6.1 when I tried it
06:25:32 <vincenz> Igloo: Is there such a thing as localised type-definitions inside data declarations?
06:25:44 <dcoutts> eivuokko: or go for a bigger case, compile some bigger package, register it with the other ghc and then compile some other package which depends on it
06:25:56 <eivuokko> dcoutts, Argh.
06:26:04 <dcoutts> ?
06:26:07 <Igloo> vincenz: Not sure exactly what you mean, but I don't think so
06:26:19 <vincenz> data Exp a b c d o where
06:26:20 <quicksilver> vincenz: type declarations don't really have scopes
06:26:27 <vincenz>   type Exp' = Exp a b c d o
06:26:34 <quicksilver> vincenz: the best you can do is not export them from a module
06:26:35 <Igloo> vincenz: No
06:26:38 <vincenz>    EBinOp :: o -> Exp' -> Exp'
06:26:41 <vincenz> it'd be damn useful for GADTS
06:26:57 <vincenz> you have to keep repeating all those parameters o.O
06:27:08 <eivuokko> dcoutts, Igloo, when I have module compiled with other ghc, it seems the other dosn't yield error from .hi, but just recompiles it.
06:27:20 <dcoutts> eivuokko: ah, don't use --make
06:27:25 <eivuokko> Meh...
06:27:44 <vincenz> quicksilver: Not what I meant :/
06:27:45 <eivuokko> dcoutts, then it doesn't foudn the module...
06:27:51 <MarcWeber> dcoutts Do you think I can fake ghc so that it reports : I'm ghc 6.6.1? The download hangs at the moment... They *should* be binary compatible anyway (?)
06:27:57 <eivuokko> dcoutts, Bar.hs:3:13: Not in scope: `foo'
06:28:44 <vincenz> Igloo: Where would one go to propose such a thing?
06:28:57 <vincenz> Igloo: technically it doesn't seem too challenging, all you're doing is creating some local synonyms
06:29:04 <dcoutts> eivuokko: hmm, so thats: ghc-6.6.1 -c Foo.hs; ghc-6.6.1.2007blah -c Bar.hs  right?
06:29:09 <eivuokko> Yes
06:29:17 <quicksilver> vincenz: it's a pretty major change to the grammar
06:29:38 <MarcWeber> dcoutts Did you get my last message (ghc faking version ?)
06:29:39 <quicksilver> vincenz: I guess one would discuss it on haskell-cafe
06:29:41 <eivuokko> dcoutts, Well, compilers other wya around, but anyway.
06:29:41 <dcoutts> eivuokko: and the other way around?
06:29:41 <vincenz> quicksilver: I think you exaggerate slightly :)
06:29:57 <MarcWeber> The message appreared in the wrong place here. Strange.
06:30:00 <quicksilver> vincenz: well 'major' is a flexible word
06:30:17 <eivuokko> dcoutts, The way you said, it gives bad interface error
06:30:18 <dcoutts> MarcWeber: that's not the problem, if you fake the version number then you'll get the problem that eivuokko is investigating now
06:30:28 <quicksilver> vincenz: roughly you're talking about allowing 'data', 'type' and 'newtype' definitions everywhere function definitions are allowed
06:30:36 <quicksilver> vincenz: I suppose
06:30:38 <eivuokko> dcoutts, The other way, its like the module was empty
06:30:39 <dcoutts> eivuokko: ok, good, and the other way it does odd things
06:30:46 <dcoutts> eivuokko: ok, thanks very much.
06:30:50 <MarcWeber> So I'll download 6.0 and use the older .11
06:30:52 <dcoutts> Igloo: ^^ can we kill it now ?
06:31:08 <dcoutts> MarcWeber: no, download the proper 6.6.1
06:31:25 <dcoutts> MarcWeber: is there any problem with doing that?
06:31:26 <vincenz> quicksilver: no
06:31:35 <vincenz> quicksilver: only type, purely synonyms, otherwise it'd be less clear
06:31:47 <vincenz> quicksilver: and not everywhere function definitions are allowed
06:31:50 <vincenz> quicksilver: I think you missed my point
06:31:53 <dcoutts> MarcWeber: ie ndm's .exe one rather than the .msi one
06:31:57 <vincenz> quicksilver: the :: was -not- a functio
06:31:59 <SamB_XP> yeah, type synonyms are 100% okay
06:32:01 <vincenz> quicksilver: those were data-constructors
06:32:10 <quicksilver> well I didn't miss your point
06:32:13 <quicksilver> but I did extend it
06:32:15 <vincenz> data Foo a =
06:32:20 <vincenz>    type Foo' = Foo a
06:32:24 <quicksilver> allowing a special where clause in one special case
06:32:30 <vincenz>   Nil | Cons a Foo'
06:32:37 <quicksilver> seems less natural than just allowing types in where clauses, everywhere
06:32:51 <vincenz> they're only added to data-declarations
06:33:25 <MarcWeber> dcoutts the server no longer serves my http request ..
06:33:38 <dcoutts> MarcWeber: bummer
06:33:55 <dcoutts> MarcWeber: lemme check the web server...
06:34:38 <dcoutts> MarcWeber: it's probably a web cache thing, haskell.org is responding normally it looks like
06:35:36 <dcoutts> Igloo: so can we take that msi down?
06:39:40 <ndm> dcoutts, i just saw the commit message fly past
06:39:51 * dcoutts looks
06:40:46 <dcoutts> Igloo: thanks muchly
06:49:12 <ndm> dcoutts, could you fuse getContents using stream/unstream fusion
06:49:26 <ndm> dcoutts, assuming it reads a character at a time with getchar, under IO
06:49:34 <dcoutts> ndm: not without rewriting getContents
06:49:46 <ndm> dcoutts, with rewriting getContents?
06:49:54 <dcoutts> and we might need some slightly funky rules
06:50:10 <ndm> i.e. can you get round the IO [Char], and see the [Char] underneath
06:50:22 <dcoutts> ndm: right, we'd go via ByteString's getContents so we get big pages of IO
06:50:47 <ndm> dcoutts, but assuming you had to go via getchar, would it be possible to fuse inside IO
06:50:49 <dcoutts> then we have to move the pure ByteString unpack across the =<< boundary
06:51:13 <dcoutts> ndm: I don't think so, we only fuse pure things
06:51:52 <Tac-Tics> How do you cast an Int to a Float?
06:51:54 <dcoutts> ndm: which is why I say we'd want to rewrite f =<< getContents to f . unpack =<< ByteString.getContents
06:52:12 <dcoutts> ndm: since then we could potentaially fuse  f . unpack
06:52:20 <Tac-Tics> @hoogle Int -> Float
06:52:20 <lambdabot> No matches, try a more general search
06:52:23 <SamB_XP> dcoutts: I hope that's the lazy ByteString
06:52:24 <ndm> ok
06:52:30 <geezusfreeek> Tac-Tics, you can use fromInteger to convert from an integer to whatever numeric type you're using
06:52:33 <dcoutts> SamB_XP: yes
06:52:37 <Tac-Tics> thanks
06:52:53 <geezusfreeek> i think i got that right anyway
06:53:10 <dcoutts> ndm: I've never thought about streams that do IO
06:53:22 <quicksilver> Tac-Tics: or fromIntegral if what you had is an Int not an Integer
06:53:23 <dcoutts> ndm: but it sounds hairy :-)
06:53:37 <geezusfreeek> ah, yes, i think that is what i was looking for there
06:53:38 <Tac-Tics> they couldn't make it any longer if they tried
06:53:39 <ndm> dcoutts, i thought so :) - my optimiser does them automatically
06:53:45 <dcoutts> ndm: I know :-)
06:54:08 <dcoutts> ndm: and hopefully you'll show us how on friday :-)
06:54:31 <quicksilver> ndm: does it have, in any sense, a special rule for IO (or a special rule for getchar) ?
06:54:44 <ndm> quicksilver: no special rules for anything
06:55:07 <Tac-Tics> I'm using Ints not Integers
06:55:08 <ndm> dcoutts, yes, am just writing the slides now :)
06:55:11 <Tac-Tics> it won't let me cast
06:55:54 <geezusfreeek> Tac-Tics, what is it saying?
06:56:00 <quicksilver> Tac-Tics: fromIntegral
06:56:09 <Tac-Tics>     Couldn't match expected type `Integer'
06:56:09 <Tac-Tics>            against inferred type `Float'
06:56:09 <Tac-Tics>     In the first argument of `fromInteger', namely `px'
06:56:09 <Tac-Tics>     In the first argument of `(-)', namely `(fromInteger px)'
06:56:09 <Tac-Tics>     In the second argument of `($)', namely
06:56:09 <Tac-Tics>         `(fromInteger px) - ((fromInteger w) / 2.0)'
06:56:09 <ricky_clarkson> Does QuickCheck only look at the types a function expects, or does it look at the function's source?
06:56:13 <geezusfreeek> oh yeah, you want fromIntegral
06:56:21 <quicksilver> ricky_clarkson: only the types
06:56:26 <quicksilver> ricky_clarkson: (it doesn't have access to the source)
06:56:28 <SamB_XP> Float is integral now?
06:56:33 <geezusfreeek> fromInteger is only Num a => Integer -> a
06:56:41 <quicksilver> SamB_XP: fromIntegral, not toIntegral :P
06:56:54 <Tac-Tics> @type fromIntegral
06:56:57 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:56:59 <geezusfreeek> fromIntegral is (Integral a, Num b) => a -> b
06:57:03 <SamB_XP> quicksilver: but that's the argument TO fromInteger
06:57:08 <SamB_XP> not the return value
06:57:40 <xerox> dcoutts: pong
06:57:41 <geezusfreeek> SamB, it's polymorphic
06:57:55 <dcoutts> xerox: so, transport arrangements...
06:58:00 <SamB_XP> > fromIntegral 1.0
06:58:01 <lambdabot>  Add a type signature
06:58:10 <SamB_XP> > fromIntegral (1.0 :: Float)
06:58:11 <lambdabot>   add an instance declaration for (Integral Float)
06:58:11 <lambdabot>     In the expression: fro...
06:58:13 <quicksilver> SamB_XP: yes, but he wanted int -> float
06:58:17 <quicksilver> SamB_XP: not float -> int
06:58:35 <quicksilver> (float -> int is round, floor, or ceiling of course)
06:58:38 <geezusfreeek> > (fromIntegral 3)::Float
06:58:39 <lambdabot>  3.0
06:58:42 <SamB_XP> quicksilver: the error message does not seem to indicate that fromIntegral will work...
06:58:57 <SamB_XP> > properFraction (1.0 :: Float)
06:58:58 <lambdabot>  (1,0.0)
06:58:59 <quicksilver> SamB_XP: it does to me...
06:59:27 <quicksilver> SamB_XP: it's inferring the that px/w are Float from some other site
06:59:36 <quicksilver> SamB_XP: (not shown in the error we were pasted)
06:59:45 <quicksilver> SamB_XP: that is presumably to be fixed elsewhere
06:59:48 <SamB_XP> ndm: so, is it really that efficient to hGetChar one Char at a time?
06:59:59 <Tac-Tics> all right, I am done for the morning
07:00:01 <Tac-Tics> time to go to work
07:00:02 <Tac-Tics> T__T
07:00:28 <ndm> SamB_XP: no, its not
07:00:44 <SamB_XP> Tac-Tics: are you one of them californians?
07:01:00 <Tac-Tics> Illinois actually
07:01:06 <Tac-Tics> but same country. It's all the same really
07:01:08 <SamB_XP> ndm: how well could supero mix with rewrite rules?
07:01:30 <SamB_XP> Tac-Tics: it's got four time zones though
07:01:33 * geezusfreeek should be at work now, but is not...
07:02:11 <ndm> SamB_XP: perfectly well, although you probably want to focus on "clever" rewrite rules, rather than the overhead saving ones most people now use
07:02:21 <SamB_XP> ndm: clearly
07:02:26 <ndm> i.e. sum [1..n] = (1+n)/2 would be a good rewrite rule
07:02:32 <Tac-Tics> SamB_XP: I'll explain that to my boss instead of fessing up to the fact that the reason I came in late was because I was programming in a Pure, Lazy, Monad-based, Functional Programming Language
07:02:50 <geezusfreeek> hmm... is there a collection of useful rewrite rules anywhere? :)
07:02:55 <SamB_XP> ndm: huh
07:03:03 <SamB_XP> ndm: does GHC allow that syntax?
07:03:08 <roconnor> sum [m..n] = (m+n) `div` (2*(n-m))
07:03:23 <roconnor> @check \n m -> sum [m..n] == (m+n) `div` (2*(n-m))
07:03:24 <lambdabot>  Add a type signature
07:03:30 <SamB_XP> ndm: also don't you need some kind of constraint that the type in question act as Z does?
07:03:34 <roconnor> @check \n m -> (sum [m..n]::Integer) == (m+n) `div` (2*(n-m))
07:03:36 <lambdabot>  Exception: divide by zero
07:03:37 <Tac-Tics> @let life = cycle ["wake up", "programming", "work", "program", "sleep"] ++ ["die"]
07:03:42 <SamB_XP> possibly mod something?
07:03:43 <lambdabot> Defined.
07:03:45 <Tac-Tics> life
07:03:48 <xerox> roconnor: quickcheck is fantastic :)
07:03:50 <Tac-Tics> > life
07:03:52 <lambdabot>  ["wake up","programming","work","program","sleep","wake up","programming","w...
07:03:59 <SamB_XP> no, wait, not mod anything
07:04:03 <roconnor> @check \n m -> m < n ==> (sum [m..n]::Integer) == (m+n) `div` (2*(n-m))
07:04:04 <lambdabot>  Falsifiable, after 0 tests: 0, -2
07:04:16 * drrho is away: (shopping food)
07:04:31 <roconnor> @check \m n -> m < n ==> (sum [m..n]::Integer) == (m+n) `div` (2*(n-m))
07:04:31 <SamB_XP> ndm: well, anyway, I'm sure that identity requires a number of laws to hold
07:04:32 <lambdabot>  Falsifiable, after 0 tests: 0, 1
07:04:36 <ndm> SamB_XP: yes, you would need some some of extra knowledge, that was just a possible example
07:04:37 <geezusfreeek> wha-?
07:04:47 <roconnor> hmmm
07:04:50 <geezusfreeek> that shouldn't be failing...
07:04:51 <roconnor> aparently I'm no Gauss.
07:05:06 <SamB_XP> ndm: probably would only work on Integer as far as standard types go
07:05:37 <SamB_XP> not sure...
07:05:43 <roconnor> @check \m n -> m < n ==> (sum [m..n]::Integer) == (m+n)*(n-m) `div` 2
07:05:44 <lambdabot>  Falsifiable, after 0 tests: -3, 1
07:05:46 <tuxplorer> are there any modules in haskell for sampling music files of various formats like mp3, ogg, wma, etc
07:05:55 <SamB_XP> > sum [1..maxBound] :: Word
07:05:57 <quicksilver> roconnor: isn't it (m+n)*(m-n+1) `div` 2 ?
07:05:59 <lambdabot> Terminated
07:06:07 <roconnor> @check \m n -> m < n ==> (sum [m..n]::Integer) == (m+n)*(n-m+1) `div` 2
07:06:08 <quicksilver> roconnor: erm, n-m, since n is larger
07:06:08 <lambdabot>  OK, passed 500 tests.
07:06:17 <SamB_XP> > foldl1' (+) [1..maxBound] :: Word
07:06:21 <lambdabot> Terminated
07:06:22 <geezusfreeek> oh
07:06:23 <roconnor> @check \m n -> m <= n ==> (sum [m..n]::Integer) == (m+n)*(n-m+1) `div` 2
07:06:24 <lambdabot>  OK, passed 500 tests.
07:06:38 <roconnor> quicksilver: thanks!
07:06:42 <SamB_XP> roconnor: hehe
07:06:49 <quicksilver> roconnor: well you got it just before me :)
07:07:05 <roconnor> quicksilver: I was still missing the +1
07:07:06 <quicksilver> I always just picture gauss in the corner, with the numbers in the air above his head
07:08:10 <roconnor> @check \m n o -> m <= n ==> (sum [m,o..n]::Integer) == (m+n)*(n-m+1) `div` (2*(o-m))
07:08:10 <geezusfreeek> an import with a bunch of rewrite rules for common patterns could be kind of neat if it doesn't slow the compiler down too much
07:08:16 <lambdabot> Terminated
07:08:34 <roconnor> @check \m n o -> m < o && m <= n ==> (sum [m,o..n]::Integer) == (m+n)*(n-m+1) `div` (2*(o-m))
07:08:35 <lambdabot>  Falsifiable, after 2 tests: -3, 0, 3
07:08:49 <vincenz> m >= 0
07:09:03 <roconnor> @check \m o n -> m < o && m <= n ==> (sum [m,o..n]::Integer) == (m+n)*(n-m+1) `div` (2*(o-m))
07:09:04 <lambdabot>  Falsifiable, after 1 tests: -3, 2, -1
07:09:14 <roconnor> vincenz: I don't think that is necessary.
07:09:36 <geezusfreeek> @check \m o n -> m < 0 && o < n ==> (sum [m,o..n]::Integer) == (m+n)*(n-m+1) `div` (2*(o-m))
07:09:42 <lambdabot> Terminated
07:09:56 <roconnor> I guess we will never know.
07:09:56 <geezusfreeek> oops
07:10:08 <geezusfreeek> @check \m o n -> m < o && o < n ==> (sum [m,o..n]::Integer) == (m+n)*(n-m+1) `div` (2*(o-m))
07:10:09 <lambdabot>  Falsifiable, after 3 tests: 0, 2, 3
07:10:22 <vincenz> roconnor: I think it might be an issue of boundary?
07:10:34 <vincenz> > [0,2..3]
07:10:36 <lambdabot>  [0,2]
07:10:42 <vincenz> perhaps you assume the existence of 4?
07:10:59 <roconnor> vincenz: I was sort of just taking a stab in the dark at a formula.
07:10:59 <quicksilver> it's normally safe to assume the existence of 4
07:11:02 <xerox> ?remember vincenz perhaps you assume the existence of 4?
07:11:02 <lambdabot> Done.
07:11:03 <vincenz> I think you need to round (n-m+1)
07:11:06 <geezusfreeek> @check \m o n -> m < o && o < n && n `mod` (m-o) == 0 ==> (sum [m,o..n]::Integer) == (m+n)*(n-m+1) `div` (2*(o-m))
07:11:07 <lambdabot>  Falsifiable, after 3 tests: -1, 1, 4
07:11:10 <xerox> Without context it'll be very funny. ;-)
07:11:14 <vincenz> xerox: :D
07:11:23 <geezusfreeek> @check \m o n -> m < o && o < n && n `mod` (o-m) == 0 ==> (sum [m,o..n]::Integer) == (m+n)*(n-m+1) `div` (2*(o-m))
07:11:24 <lambdabot>  Falsifiable, after 9 tests: -3, 1, 4
07:11:28 <geezusfreeek> alright enough
07:12:44 <vincenz> roconnor: I think you need flooring
07:12:50 <quicksilver> @check \m o n -> m < o && o < n && (n-m) `mod` (o-m) == 0 ==> (sum [m,o..n]::Integer) == (m+n)*(n-m+1) `div` (2*(o-m))
07:12:52 <lambdabot>  Falsifiable, after 4 tests: -2, 1, 4
07:13:11 <vincenz> ((o-m)*|_(n-m)/(o-m)_|
07:13:14 <roconnor> vincenz: doesn't div give me flooring?
07:13:19 <vincenz> roconnor: I mean in terms of the o
07:13:32 <vincenz> (n-m) is off
07:13:44 <vincenz> you're not guaranteed to go upto n
07:13:49 <vincenz> you only go upto the nearest multiple o
07:13:50 <quicksilver> @check \m o n -> m < o && o < n && (n-m) `mod` (o-m) == 0 ==> (sum [m,o..n]::Integer) == (m+n)*((n-m `div` (2*(o-m)) +1)
07:13:50 <lambdabot>  Parse error
07:13:58 <quicksilver> @check \m o n -> m < o && o < n && (n-m) `mod` (o-m) == 0 ==> (sum [m,o..n]::Integer) == (m+n)*((n-m `div` (2*(o-m))) +1)
07:13:59 <lambdabot>  Falsifiable, after 0 tests: 0, 1, 2
07:14:13 <roconnor> vincenz: ah yes.
07:14:24 <quicksilver> @check \m o n -> m < o && o < n && (n-m) `mod` (o-m) == 0 ==> (sum [m,o..n]::Integer) == (m+n)*((n-m `div` (o-m)) +1) `div` 2
07:14:26 <lambdabot>  Falsifiable, after 2 tests: -1, 1, 3
07:14:40 <quicksilver> @check \m o n -> m < o && o < n && (n-m) `mod` (o-m) == 0 ==> (sum [m,o..n]::Integer) == (m+n)*(((n-m) `div` (o-m)) +1) `div` 2
07:14:41 <lambdabot>  Arguments exhausted after 49 tests.
07:14:45 <quicksilver> yay!
07:14:47 * quicksilver wins
07:14:50 <vincenz> :P
07:14:53 <roconnor> @check \m o n -> m < o && m <= n ==> (sum [m,o..n]::Integer) == (m+n)*((n-m+1) `div` (2*(o-m)))
07:14:54 <lambdabot>  Falsifiable, after 0 tests: -3, 0, 0
07:15:20 <vincenz> @check \a b c d e f g -> a > b && c > d && d > e && e > f && f > g ==> sum [a,b,c,d,e,f,g]::Integer)
07:15:20 <lambdabot>  Parse error
07:15:21 <wli> Nice, snd &&& fst
07:15:39 <roconnor> @check \m o n -> m < o && m <= n ==> (sum [m,o..n]::Integer) == (m+n)*((n-m+1) `div` ((o-m))) `div` 2
07:15:40 <lambdabot>  Falsifiable, after 3 tests: -3, 4, 0
07:15:40 <xerox> swap!
07:15:46 <quicksilver> > (snd &&& fst) (1,"fish')
07:15:46 <vincenz> roconnor: why the +1?
07:15:46 <lambdabot>  Improperly terminated string
07:15:49 <quicksilver> > (snd &&& fst) (1,"fish")
07:15:50 <lambdabot>  ("fish",1)
07:15:57 <roconnor> vincenz: I'm not sure
07:16:00 <vincenz> roconnor: I think it should be
07:16:04 <vincenz> let n = round to nearest o
07:16:07 <quicksilver> because between 1 and 6 there are 6 numbers
07:16:09 <vincenz> let n' = round to nearest o
07:16:11 <quicksilver> (not 6-1 = 5 numbers)
07:16:13 <quicksilver> including both ends
07:16:13 <vincenz> and then use that for both occurences of n
07:16:18 <vincenz> just a sec
07:16:44 <quicksilver> I believe my formul was the right one given the even multiple constraint
07:16:46 <geezusfreeek> vincenz, don't you mean floor to the nearest (o-m)?
07:16:57 <vincenz> yes
07:17:01 <vincenz> quick parlance
07:17:24 <vincenz> @check \m o n -> m < o && m <= n ==> (sum [m,o..n]::Integer) == let n' = m + o * ((n-m)`div` o) in (m+n')*(n'-m+1) `div` (2*(o-m)))
07:17:24 <lambdabot>  Parse error
07:17:40 <vincenz> @check \m o n -> m < o && m <= n ==> (sum [m,o..n]::Integer) == let n' = m + o * ((n-m)`div` o) in (m+n')*(n'-m+1) `div` (2*(o-m))
07:17:42 <lambdabot>  Exception: divide by zero
07:17:50 <vincenz> doh
07:18:06 <geezusfreeek> err... i was wrong there too
07:18:20 <vincenz> @check \m o n -> m < o && m <= n ==> (sum [m,o..n]::Integer) == let d = (o-m) in let n' = m + d * ((n-m)`div` d) in (m+n')*(n'-m+1) `div` (2*(o-m))
07:18:21 <lambdabot>  Falsifiable, after 2 tests: -1, 2, 2
07:20:03 <tizoc_[w]> hola =)
07:20:09 <vincenz> @check \m o n -> m < o && m <= n ==> (sum [m,o..n]::Integer) == let d = (o-m) in let n' = m + d * ((n-m)`div` d) in (m+n')*(m+n'+1) `div` (2*d)
07:20:10 <lambdabot>  Falsifiable, after 0 tests: -2, 1, -2
07:20:18 <vincenz> hmm
07:20:21 <geezusfreeek> you would need to floor to the nearest (o-m) then offset by m
07:20:44 <vincenz> that's what n' is
07:20:57 <geezusfreeek> of i lost track of all the @checks
07:21:00 <geezusfreeek> *oh
07:21:25 <geezusfreeek> okay i already said i'm done with this, and now i really am
07:21:58 <vincenz> I give up
07:22:26 <gwern> @pl headN n ss = concat $ genericTake n $ lines ss
07:22:27 <lambdabot> headN = (join .) . (. lines) . genericTake
07:23:57 <sjanssen> @yow
07:23:57 <lambdabot> This PIZZA symbolizes my COMPLETE EMOTIONAL RECOVERY!!
07:24:02 <vincenz> @quote 4
07:24:03 <lambdabot> vincenz says: english is my 4th language
07:24:06 <vincenz> doh!
07:24:44 <gwern> @pl cut dlmtr pos string = split dlmtr string !! (pos - 1)
07:24:45 <lambdabot> cut = (. subtract 1) . flip . ((!!) .) . split
07:25:09 <gwern> @pl lengthF file = liftM genericLength $ liftM B.lines $ B.readFile file
07:25:09 <lambdabot> lengthF = fmap genericLength . fmap B . lines . (B .) . readFile
07:25:21 <vincenz> heh. that's off
07:25:41 <gwern> how so?
07:25:56 <gwern> oh, the qualified import
07:26:09 <Japsu> import qualified Personnel hiding (illegalImmigrants)
07:26:40 <gwern> @pl isCompressed file = any (flip isInfixOf file) [".bz",".gz",".bz2",".Z",".a",".tar",".cab",".man",".so",".zip","\
07:26:40 <lambdabot> (line 1, column 47):
07:26:40 <lambdabot> unexpected "["
07:26:40 <lambdabot> expecting variable, "(", operator or end of input
07:26:43 <gwern> .lha",".cpi",".rpm",".cpi",".cpio",".ace",".arc",".arj",".cab",".lha",".lzh",".zoo",".7z",".mo",".gmo",".rar","\
07:26:46 <gwern> .deb"]
07:26:52 <gwern> (hmm. better reformat that)
07:27:20 <gwern> @pl isCompressed file = any (flip isInfixOf file) ["foobar, "baz"]
07:27:20 <lambdabot> (line 1, column 47):
07:27:20 <lambdabot> unexpected "["
07:27:20 <lambdabot> expecting variable, "(", operator or end of input
07:27:40 <sjanssen> @type any . flip isInfixOf
07:27:42 <lambdabot> forall a. (Eq a) => [a] -> [[a]] -> Bool
07:27:55 <mauke> @pl isCompressed file = any (flip isInfixOf file) ["foobar", "baz"]
07:27:56 <lambdabot> isCompressed = flip any ["foobar", "baz"] . flip isInfixOf
07:27:57 <sjanssen> gwern: ^^^
07:28:43 <gwern> ... why did mauke's work and mine not? they look the same to me
07:28:49 <mauke> gwern: "
07:29:00 <gwern> oh. oops
07:29:47 <gwern> pl is kind of cute, although it does produce some odd looking code sometimes
07:30:24 <sjanssen> gwern: are you sure you want to use "\ there?
07:30:55 <sjanssen> that turns into "\n.lha"
07:31:20 <gwern> sjanssen: I think the \ came from linewrapping in emacs
07:31:26 <anybody> hm just wondering. as haskell relies so much on recursion, does it internally map recursion into normal iteration? i mean otherwise you would blow the stack quite often in more computational intensive apps
07:31:49 <sjanssen> anybody: yes, an implementation usually takes advantage of tail recursion
07:31:50 <vincenz> anybody: I suggest you look up "tail call optimisation"
07:32:11 <anybody> vincenz: okie. thx
07:32:11 <sjanssen> all respectable FP interpreters/compilers do it
07:32:20 <Philippa_> vincenz: I would've thought that you normally got tail call handling for free under lazy evaluation anyway?
07:32:40 <vincenz> Philippa_: That I haven't thought of
07:32:44 <gwern> @pl fURLs article =  liftM extractURLs $ unsafeInterleaveIO $ openURL("http://en.wikipedia.org/wiki/" ++ B.unpack article)
07:32:46 <lambdabot> fURLs = fmap extractURLs . unsafeInterleaveIO . openURL . ("http://en.wikipedia.org/wiki/" ++) . (B .) . unpack
07:32:46 <Philippa_> not necessarily in terms of fastest possible loop, but if you're evaluating outermost-first you've already thrown away the "top" call in yielding the thunk
07:33:02 <quicksilver> Philippa_: I don't think that's necessarly implicit in all lazy evaluation schemes you can imagine
07:33:13 <quicksilver> Philippa_: but it's certain true of G-machine style things
07:33:19 <Philippa_> quicksilver: lazy evaluation is a specific scheme, you're thinking "non-strict", no?
07:33:31 <gwern> (that doesn't quite look right either. must be the B. thing again)
07:33:35 <gwern> @pl fURLs article =  liftM extractURLs $ unsafeInterleaveIO $ openURL("http://en.wikipedia.org/wiki/" ++ unpack article)
07:33:36 <lambdabot> fURLs = fmap extractURLs . unsafeInterleaveIO . openURL . ("http://en.wikipedia.org/wiki/" ++) . unpack
07:33:41 <vincenz> gwern: use /msg ?
07:33:57 <gwern> vincenz: alright, if it's bothering you
07:34:06 <Philippa_> (it's a specific scheme which assorted abstract machines aim to implement, sure)
07:35:04 <timbod> I just watch SPJ's talk at oscon on STM. It was good, and I intend to refer it to some (non haskell) friends. Anyone know of a link for the associated slides?
07:35:07 <quicksilver> and if you're building up a very large thunk then you get a stack overflow anyway
07:35:12 <quicksilver> just for slightly different reasons
07:36:09 <SamB> @let f :: (forall i. Integral i => (i, i)) -> ((Integer, Integer), (BitInteger, BitInteger)); f (x,y) = (quotRem x y, quotRem x y)
07:36:10 <lambdabot>  Parse error
07:36:15 <SamB> hmm
07:36:35 <SamB> well, anyway, why doesn't that typecheck with -fglasgow-exts?
07:37:20 <SamB> you could just replace BitInteger with some integral type you actually have
07:37:23 <SamB> like, uh, Integer
07:37:27 <SamB> or Int
07:37:34 <quicksilver> SamB: by putting the forall in the brackets, you're saing the function can only operate if given a 'package' which can pretend to be any Integral
07:37:45 <SamB> quicksilver: which is exactly what I want
07:37:48 <quicksilver> (a pair of any Integrals but that's not the point)
07:38:07 <SamB> so how come I get this:
07:38:09 <wli> @hoogle liftA2
07:38:13 <lambdabot> No matches found
07:38:22 * wli cries.
07:38:24 <SamB>     Couldn't match expected type `forall i. (Integral i) => (i, i)'
07:38:24 <SamB>            against inferred type `(a, b)'
07:38:24 <SamB>     In the pattern: (x, y)
07:38:56 <quicksilver> basically, existentials can't match ordinary patterns
07:39:01 <quicksilver> if I understand this right
07:39:04 <SamB> oh
07:39:12 <quicksilver> to use existentials at all you need an explicit type constructor
07:39:22 <quicksilver> otherwise the compiler can't see where the existential bit starts
07:39:39 <SamB> this isn't an existential though...
07:39:44 <SamB> is it?
07:39:49 <xerox> ?index liftA2
07:39:49 <lambdabot> bzzt
07:39:55 <xerox> ?docs Control.Applicative
07:39:55 <lambdabot> Control.Applicative not available
07:40:02 <xerox> pah.
07:42:03 <sjanssen> I'm tired of Ruby/Python apologists that insist that threading isn't the answer to parallelism just because their runtimes aren't sophisticated enough to do it
07:42:44 <SamB> sjanssen: wasn't there also the problem of their threading APIs being unusable?
07:42:46 <sjanssen> who really thinks that using interprocess IPC is more natural than the language's built in synchronization primitives?
07:43:08 <sjanssen> SamB: possibly
07:43:18 <timbod> auto-reply: found the slides at http://research.microsoft.com/~simonpj/papers/stm/STM-OSCON.pdf
07:43:26 <sjanssen> that doesn't seem hard to overcome -- just copy Haskell or Erlang :)
07:43:59 <earthy> ewww... Python threading *Eewwwwwwwww*
07:44:03 <SamB> anyway, if threading isn't a good approach to concurrency in X environment, it probably isn't a good approach to parrallelism there either
07:44:22 <earthy> this reminds me of the fact that when it comes to threading Python 1.5.1 != Python 1.5.1
07:44:31 <vincenz> aha
07:44:45 <earthy> (yes, there were two different versions of Python 1.5.1 and I ran into the difference with some multithreaded code)
07:44:55 <SamB> I think the smart people don't apologize, but rather say "it sure sucks, doesn't it?"
07:45:00 <SamB> ho
07:45:02 <SamB> er.
07:45:03 <SamB> oh
07:45:28 <SamB> another reason that IPC might be the easier approach is the rampant mutable state found in Python
07:45:49 <earthy> the second 1.5.1 is now called 1.5.1p1
07:46:03 <Tac-Work> "Who are you calling mutable!?" - Python
07:46:03 <SamB> man.
07:46:09 <sjanssen> SamB: IIRC, GVR expressed this opinion
07:46:12 <sjanssen> he is pretty smart
07:46:38 <SamB> which one?
07:46:47 <SamB> "it sure sucks, doesn't it?"
07:47:13 <sjanssen> nah, he favors IPC
07:47:25 <sjanssen> this is just my fuzzy memory though
07:47:25 <SamB> the one about the rampant mutable state?
07:47:50 <SamB> or the one you mentioned -- that threading is just evil?
07:49:03 * SamB gives up on that function and just defines this one:
07:49:10 <SamB> f :: (forall i. Integral i => (i, i)) -> ((Integer, Integer), (BitInteger, BitInteger)); f a = (a,a)
07:49:28 <sjanssen> SamB: that IPC is the right way to take advantage of parallelism
07:49:43 <vincenz> IPC is just another word for message-passing
07:50:03 <SamB> sjanssen: it does have the advantage of being easily extended to clusters, if you can do it in the first place
07:50:30 <SamB> (well, sometimes anyway)
07:50:48 <sjanssen> vincenz: inter-*process* communication
07:50:58 <sjanssen> where process is a heavy-weight OS process
07:51:09 <vincenz> sjanssen: potay-toe, potah-toe
07:51:23 <vincenz> the point is that you go to a message passing system instead of a shared-state system
07:51:44 <sjanssen> vincenz: yes, while simultaneously inheriting tons of overhead
07:51:47 <SamB> vincenz: which is considerably less difficult to debug
07:52:00 <vincenz> SamB: I'm not stating opinions
07:52:07 <SamB> that's not an opinion
07:52:10 <SamB> that's the truth
07:52:15 <SamB> Haskell is special
07:52:26 <vincenz> SamB: Then then your comment was nonsequitur
07:52:39 <SamB> vincenz: I suppose so
07:53:12 <SamB> but shared state is clearly going to be a debugging headache when nearly all you've got is state
07:53:26 <vincenz> Personally I think the right paradigm doesn't exist yet
07:53:33 <vincenz> shared state and message passing are both lowlevel prmitives
07:53:36 <vincenz> we need something on top of that
07:53:45 <vincenz> But sadly, concurrency has always been looking at processes, not data
07:53:45 <anybody> hey what is the difference between a group and a monoid?
07:53:50 <quicksilver> inverses
07:54:04 <anybody> monoid has no inverses?
07:54:10 <quicksilver> well it doesn't promise to
07:54:12 <quicksilver> it might do
07:54:16 <quicksilver> all groups are monoids
07:54:22 <sjanssen> vincenz: any ideas on what this higher level system would look like?
07:55:07 <vincenz> sjanssen: none
07:55:13 <vincenz> sjanssen: I haven't spent enough time thinking about that.
07:55:21 <vincenz> stm is an example of something on top of shared state
07:55:40 <vincenz> But I do think you'll need something on top, which will incur some runtime penalty.
07:55:47 <sjanssen> I'd still classify STM as shared state
07:55:51 <vincenz> But hey, GC also incurs a penalty, but look at all the benefits
07:55:59 <vincenz> sjanssen: it's something on top of shared state to give you proper locking
07:56:03 <sjanssen> it just has some clever semantics
07:56:14 <vincenz> STM is shared state, it's just an abstraction level higher
07:56:17 <vincenz> That's what I mean by ontop
07:59:18 <quicksilver> I think the dichotomoy between message passing and shared state is a bit of a false dichotomy
07:59:31 <quicksilver> it's a different in emphasis and style rather than substance, surely?
07:59:32 <SamB> anybody: A group is a monoid each of whose elements is invertible.
07:59:38 <SamB> says http://mathworld.wolfram.com/Group.html
07:59:39 <lambdabot> Title: Group -- from Wolfram MathWorld
08:00:43 <anybody> SamB: thx
08:00:57 <psykotic> quicksilver, you could say that about almost anything, though. while you can implement message passing on top of shared state and vice versa, they lead to completely different styles.
08:01:31 <quicksilver> psykotic: granted I was being a bit reductionist
08:01:49 <psykotic> it's sort of like the difference between various turing complete languages :)
08:01:49 <vincenz> reductionism is passe
08:01:50 <quicksilver> psykotic: but for example, mainly people say things like "MVars are shared state"
08:02:02 <quicksilver> psykotic: and then go on to build an argument on that
08:02:11 <quicksilver> whilst in fact many sensible ways to use MVars are message passing
08:02:14 <psykotic> MVars are better than pure c-style vars, surely
08:02:19 <psykotic> right
08:02:33 <quicksilver> but the whole 'erlang is better cos its message passing' lobby
08:02:42 <quicksilver> bypasses that, as they write off MVars are shared state
08:02:58 <RyanT5000> what's the conversion from haskell ideas to category-theoretic ideas? (also, what did i just ask for, a functor?)
08:03:02 <psykotic> a filled MVar gives an error if you try to fill it, right?
08:03:11 <psykotic> you have to empty it explicitly first, by 'taking' from it?
08:03:16 <RyanT5000> psykotic: no, it doesn't give you an error, it blocks
08:03:25 <psykotic> k
08:03:49 <RyanT5000> psykotic: you can use MVars in either put-take or take-put disciplines
08:03:50 <SamB> psykotic: it certainly won't give an error when you try to fill it
08:03:53 <SamB> that would be stupid
08:03:57 <psykotic> but you can peek at them and choose not to block, right?
08:04:01 <vincenz> yep
08:04:05 <vincenz> same for taking
08:04:09 <SamB> you can try to take something
08:04:13 <psykotic> in that case you have the potential for all the usual shared state currency shenaningans
08:04:13 <SamB> or try to put something
08:04:30 <SamB> without blocking if it is already empty/full
08:04:35 <RyanT5000> keep in mind your peek is not guaranteed to be atomic with whatever you do next
08:04:49 <SamB> RyanT5000: I think he meant something else
08:04:54 <RyanT5000> also, there's no way to atomically modify an MVar when you don't know whether it's filled or not
08:05:08 <SamB> tryPutMVar :: forall a. MVar a -> a -> IO Bool
08:05:08 <SamB> tryTakeMVar :: forall a. MVar a -> IO (Maybe a)
08:05:13 <psykotic> right, that's what i meant
08:05:16 <RyanT5000> SamB: just making sure it's on his mind, given that it's "the" error that you can make
08:05:17 <SamB> not
08:05:21 <DaveCGI277> does haskell support async io
08:05:29 <mauke> huhu
08:05:39 <SamB> isEmptyMVar :: forall a. MVar a -> IO Bool
08:05:40 <RyanT5000> DaveCGI277: it supports fairly lightweight threads :)
08:05:50 <RyanT5000> DaveCGI277: also, there might be some explicitly asynchronous calls
08:05:55 <kosmikus> ok, let's have a little poll. what would you like to learn about in a seminar on type systems?
08:06:03 <psykotic> and you can use the FFI to bind to whatever is in the c world
08:06:04 <RyanT5000> kosmikus: dependent types! :)
08:06:08 <RyanT5000> kosmikus: that's just me, though
08:06:10 <SamB> kosmikus: will it be videotaped?
08:06:12 <earthy> pure type systes
08:06:13 <earthy> +m
08:06:21 <kosmikus> RyanT5000: consider it noted :)
08:06:24 <earthy> barendregt's lambda-cube
08:06:24 <kosmikus> earthy: ok
08:06:46 <kosmikus> no, it probably won't be taped
08:06:47 <earthy> the difference between curry-style and church-style and the implications
08:07:16 <SamB> kosmikus: I guess there's no point in me giving any input then
08:07:18 <earthy> and yeah, practical applications of type systems
08:07:19 <vincenz> kosmikus: What about digitally filmed?
08:07:23 <earthy> not just the theory
08:07:25 <vincenz> kosmikus: Tapes are a bit passe
08:07:48 <SamB> vincenz: I thought they used tapes for that
08:07:54 <RyanT5000> anyway, is there any tutorial on category theory that is based primarily on the user knowing haskell?
08:07:58 <vincenz> Erm, I've seen Sony ones that use CDs
08:08:04 <SamB> those are silly
08:08:11 <vincenz> They exist, don't they?
08:08:16 <vincenz> Similarly...usb....hard-drive...etc
08:08:18 <RyanT5000> i feel like i understand typeclasses fairly well, and i'd like to kind of mush that knowledge over into category theory
08:08:18 <SamB> CDs aren't very big...
08:08:31 <kosmikus> sure, there are recorders using disks
08:08:32 <vincenz> SamB: Whatever, ,my point is that modern ones don't use tapes.
08:08:33 <SamB> now hard drive, that makes perfect sense...
08:08:39 <SamB> vincenz: I wouldn't know
08:08:42 <kosmikus> but I'd prefer more suggestions ;)
08:08:48 <SamB> I meant it in the sense "is someone going to record it"
08:08:51 <mornfall> CD isn't big? you prefer vinyl LP? :-)
08:08:59 <earthy> oh, subtyping would need to be in such a seminar as well
08:09:06 <SamB> mornfall: how much data can you store on an LP?
08:09:21 <mornfall> ah, data... that's a different matter
08:09:24 <earthy> (have I already filled the ECTSs available? :))
08:09:30 * SamB goes to take a shower
08:09:33 <vincenz> mornfall: why not suggest iron drums?
08:09:40 <vincenz> or were they steel
08:09:55 <mornfall> abacus
08:10:18 <vincenz> mornfall: with monkeys for concurrent access
08:10:20 <mornfall> the video man has to flip the balls real quick
08:10:22 <mornfall> oh
08:10:27 <mornfall> good, good
08:11:31 <quicksilver> psykotic: it's actually quite simple to acheive safe behaviour with MVars
08:11:38 <quicksilver> psykotic: they're a useful primitive
08:11:44 <phoniq> ;9
08:12:05 <quicksilver> psykotic: on which you can build a variety of safe layers
08:12:10 <psykotic> most of the cases i've seen have been quite simple
08:12:19 <vincenz> I concur
08:12:21 <psykotic> like, simple communication between a master thread and a spawned thread
08:12:23 <vincenz> mvars are useful communication systems
08:12:32 <psykotic> those are simple even with posix threads
08:12:34 <vincenz> psykotic: you can easily build queuses with mvars
08:13:02 <vincenz> hmm, that was a lame statement
08:13:06 <RyanT5000> vincenz: Chan?
08:13:08 <psykotic> vincenz, say you want a maximally concurrent queue, with stuff being inserted at one end and read out at the other, with appropriate blocking, etc.
08:13:12 <quicksilver> and things like bounded buffers which block when full, say
08:13:21 <vincenz> psykotic: right?
08:13:21 <psykotic> for that you need multiple MVars
08:13:26 <vincenz> psykotic: yes
08:13:32 <quicksilver> psykotic: yes, you need more than one MVar for most interesting concepts
08:13:38 <quicksilver> but they are a good building block
08:13:43 <RyanT5000> psykotic: i haven't been totally following, but aren't you looking for Control.Concurrent.Chan?
08:13:44 <psykotic> and it seems like it takes the same level of guile that it would with pthreads, say
08:13:55 <sjanssen> an MVar is just a channel with one or zero elements
08:13:59 <psykotic> RyanT5000, i wasn't the one who brought up building something out of mvars, it was vincent
08:14:03 <RyanT5000> ah ok
08:14:04 <quicksilver> psykotic: you have quite a lot more safety
08:14:07 <quicksilver> it was me, actually!
08:14:10 <sjanssen> psykotic: it's really not too bad.  See the source for Control.Concurrent.Chan
08:14:15 <vincenz> psykotic: who is vincent?
08:14:17 <psykotic> well, he mentioned queues
08:14:18 <psykotic> vincenz :)
08:14:25 * vincenz tsks
08:14:29 <DaveCGI277> what makes them lightweight? they're userspace or they dont use a stack..?
08:14:33 <vincenz> psykotic: I said right after it was a lame statement
08:14:48 <quicksilver> DaveCGI277: they don't use any OS resource
08:14:49 <sjanssen> DaveCGI277: they're userspace
08:14:53 <quicksilver> DaveCGI277: (well beyond a little memory)
08:14:59 <vincenz> psykotic: I like MVar's not because of the MVars (yes, they're like posix) but all the stuff you can do with haskell and all the nice first-classness of actions and variables etc..
08:15:02 <psykotic> i think the main advantage mvars have over typical c-style thread libs
08:15:03 <quicksilver> DaveCGI277: the haskell runtime threads them
08:15:04 <vincenz> psykotic: it scales nicely
08:15:08 <psykotic> is that they tie together "condition variables" and "mutexes"
08:15:09 <DaveCGI277> well ok, i guess if you are using native async io its ok
08:15:23 <DaveCGI277> but what about if you want true async code ?
08:15:35 <RyanT5000> DaveCGI277: forkIO, forkOS?
08:15:37 <sjanssen> DaveCGI277: what do you mean by "true async"
08:15:37 <quicksilver> DaveCGI277: it's fine as long as it allocates memory
08:15:39 <psykotic> vincenz, sure, i agree
08:15:42 <quicksilver> (which almost all haskell code does)
08:15:50 <DaveCGI277> sjanssen: done simultaneously if there are several cpus
08:15:59 <mauke> huhu
08:16:00 <quicksilver> DaveCGI277: since the haskell scheduler can interrupt lightweight thread when they alloc
08:16:06 <quicksilver> DaveCGI277: yes, it scales instantly to multiple CPUs
08:16:09 <sjanssen> DaveCGI277: GHC schedules your N Haskell threads on M OS threads
08:16:10 <mauke> what's the RTS option?
08:16:13 <quicksilver> DaveCGI277: that's just a RTS option
08:16:20 <sjanssen> mauke: +RTS -N
08:16:21 <psykotic> i just don't think building a large scale parallel app directly on mvars is very sane....
08:16:34 <psykotic> actually i would like to see what you could do with message passing built in with monads
08:16:38 <sjanssen> psykotic: why?
08:16:45 <psykotic> you could have something like ST for processes
08:16:59 <sjanssen> I agree that there are better systems (like STM)
08:17:28 <vincenz> STM is nice
08:17:31 <vincenz> but it's not the end all be all
08:17:41 <quicksilver> STM is nice if you need STM
08:17:41 <vincenz> it doesn't scale past a certain point
08:17:45 <sjanssen> prove it. :)
08:17:50 <quicksilver> not to be stupidly tautological
08:17:52 <DaveCGI278> but does haskell thread scheduler schedule across multiple CPUs ?
08:17:55 <quicksilver> DaveCGI277: yes
08:18:03 <vincenz> I even saw a paper on hardware STM :)
08:18:07 <vincenz> erm
08:18:09 <DaveCGI278> so it promotes user-space threads to kernel-space threads automatically?
08:18:12 <vincenz> s/STM/TM
08:18:12 <vincenz> :P
08:18:14 <psykotic> i think the biggest problem with the marketing hype i've seen with STM is that they gloss over some important issues
08:18:25 <psykotic> for example, you still have to think about the exact same issues you do with regular threading
08:18:31 <psykotic> it's just that the failure mode is more gradual
08:18:47 <psykotic> instead of dead locking, you get live locking through contention, if you don't plan carefully
08:18:59 <sjanssen> DaveCGI278: it isn't really "promotion" -- the runtime just schedules the lightweight Haskell threads on the heavyweight OS threads
08:19:12 <vincenz> psykotic: I think the problem is the concept 'data'
08:19:20 <DaveCGI278> its not? seems like getting promoted to me :P
08:19:40 <DaveCGI278> how do you make these lightweight threads?
08:19:40 <vincenz> there's process and concurrent process, there's no 'concurrent data'
08:19:45 <psykotic> DaveCGI277, forkIO
08:19:51 <psykotic> :t forkIO
08:19:53 <lambdabot> Not in scope: `forkIO'
08:19:57 <vincenz> @hoogle forkIO
08:19:57 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
08:19:59 <quicksilver> DaveCGI277: it's not being promoted, int he sense that hte mapping isn't permanent
08:20:06 <quicksilver> DaveCGI278: say you have 2 CPUs and 10 threads
08:20:20 <quicksilver> DaveCGI278: any one thread, at a particular time might be on one CPU, and later on the other CPU
08:20:33 <vincenz> oh no! :P
08:20:43 <psykotic> quicksilver, probably better to say, "might be on one OS thread, and later on another OS thread"
08:20:47 <quicksilver> DaveCGI278: all 10 threads have "equal status" and the haskell scheduler sticks them on CPUs as it sees fit
08:20:49 <vincenz> task-migration is going to be an issue cause we have no concept of 'data'
08:20:53 <quicksilver> yes, what psykotic said
08:21:00 <vincenz> Especially once you move to multicore where your memory hierarchy is no longer monolithic
08:21:48 <DaveCGI278> so anytime you call out to a potentially blocking function, haskell is smart enough to schedule another thread?
08:23:28 <sjanssen> DaveCGI278: you should read the paper on the GHC RTS, lemme find a link
08:23:30 <quicksilver> DaveCGI278: yes
08:23:41 <quicksilver> DaveCGI278: it puts that thread to sleep
08:23:48 <quicksilver> DaveCGI278: and uses select/poll behind the scenes
08:23:50 <mauke> or it gets the hose again
08:24:03 <DaveCGI278> how is synchronization modeled?
08:24:05 <quicksilver> DaveCGI278: furthermore, even if a thread doesn't get blocked on IO
08:24:05 <psykotic> it has some options in the FFI for declaring what functions can never block, i think
08:24:08 <sjanssen> DaveCGI278: http://research.microsoft.com/~simonpj/papers/parallel/index.htm
08:24:09 <lambdabot> Title: Haskell on a shared-memory multiprocessor
08:24:10 <psykotic> so it can be conservative about it where possible
08:24:14 <quicksilver> DaveCGI278: it till gets swapped out sometimes
08:24:22 <quicksilver> DaveCGI278: (as long as it does at least some memory allocation
08:24:23 <sjanssen> DaveCGI278: it's a great paper, and should answer most of your questions
08:24:40 <quicksilver> it's bloody hard to write long running haskell code which does no memory allocation at all...
08:24:43 <quicksilver> :)
08:25:06 <DaveCGI278> sjanssen: when are we getting "par" then?
08:25:16 <sjanssen> DaveCGI278: it exists in GHC today
08:25:26 <DaveCGI278> oh then why would i bother with forkIO
08:25:27 <psykotic> @hoogle par
08:25:27 <lambdabot> Control.Parallel.par :: a -> b -> b
08:25:28 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
08:25:28 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
08:25:44 <sjanssen> DaveCGI278: forkIO is when you need to do multiple IO actions simultaneously
08:25:51 <sjanssen> (imagine a concurrent webserver)
08:26:02 <DaveCGI278> oh... par still does the IO stuff sequentially?
08:26:12 <sjanssen> par doesn't do any IO
08:26:21 <DaveCGI278> thats great. how do you do the synchronizations between threads?
08:26:27 <mauke> STM!
08:26:36 <sjanssen> DaveCGI278: MVars or STM.  Read the paper ;)
08:26:46 * drrho is back
08:26:49 <DaveCGI278> whoa whoa
08:26:51 <DaveCGI278> mutable objects?!
08:26:55 <DaveCGI278> thats blasphemy
08:27:16 <mauke> if you don't mute, you don't need to synch
08:27:29 <quicksilver> as mauke said :)
08:27:37 <quicksilver> if everything is immutable, then synchronisation is automatic
08:27:52 <quicksilver> (behind the scenes there is some synchronisation going on, if two threads try to force the same thunk)
08:28:06 <quicksilver> but this is invisible to the programmer
08:28:07 <sjanssen> DaveCGI278: once you've read the first paper, read "Composable memory transactions" http://research.microsoft.com/~simonpj/papers/stm/index.htm#composble
08:28:09 <lambdabot> http://tinyurl.com/ylls27
08:28:25 <DaveCGI278> argh i dont have time to read research papers all over the place right now
08:28:40 <DaveCGI278> maybe when im a grad student sitting around all day in my office..
08:28:42 <mauke> forkIO readPaper
08:28:51 <sjanssen> DaveCGI278: they're not long and very approachable
08:29:17 <DaveCGI278> sjanssen: yeah but im on vacation right now about to leave and go out soon :)
08:29:44 <sjanssen> DaveCGI278: print them and read 'em in the car/plane
08:29:56 <vincenz> yes, in the car, while driving..
08:29:57 <DaveCGI278> sjanssen: thanks but no printer in the hotel afaik
08:29:58 <sjanssen> you must be enlightened!
08:30:02 <sjanssen> :_
08:30:04 <sjanssen> :)
08:30:09 <DaveCGI278> haha im not the one driving
08:32:00 <DaveCGI278> before i forget, is there any metaprogramming,  macros, and dynamic dispatch sugar?
08:32:22 <mauke> well, there's template haskell
08:35:19 <quicksilver> DaveCGI278: it's surprisingly rare to need real metaprogramming with type classes
08:35:24 <quicksilver> DaveCGI278: but it is there
08:35:45 <malsyned> DaveCGI278: I was just looking at Template Haskell the other day.  It's pretty cool, and pretty powerful, but I agree with quicksilver that you'll find you usually don't need it.
08:35:50 <RyanT5000> DaveCGI278: as far as dynamic dispatch is concerned, records-with-closures or existentials are probably what you're looking for
08:36:02 <quicksilver> quite often one or two metaprogrammed type classes (like Data, Typeable or Uniplate) provide enough of a hook that you can write everything else in haskell
08:36:46 <quicksilver> of course deriving Show and deriving Eq are metaprogramming and quite widely used :)
08:36:48 <RyanT5000> quicksilver: i disagree; what about implementing things like hat?
08:37:08 <RyanT5000> quicksilver: deriving shouldn't exist; it's a hack because we don't have nice, real metaprogramming
08:37:17 <RyanT5000> (also, i suppose it predates TH and such)
08:37:49 <malsyned> I agree.  Data.Derive is what deriving should have been from the start.
08:38:02 <quicksilver> implementing hat requires runtime hooks rather than metaprogramming, I think
08:38:04 <sjanssen> deriving is one of my favorite features!
08:38:18 <quicksilver> although a bit of lightweight metaprogramming like Show is certainly helpful
08:38:29 <malsyned> sjanssen: mine too.  the point is it should be extensible and isn't.
08:38:34 <malsyned> well, my point, anyway.
08:38:41 <sjanssen> it could use some hooks into TH, to allow you to extend the set of derived classes
08:39:17 <quicksilver> metaprogramming is more harmful than most people give it credit for, too
08:39:31 <malsyned> sjanssen: see Data.Derive.  It has a TH mode that's pretty much exactly that.
08:40:15 <malsyned> quicksilver: bah.  so's mutable state, but that doesn't mean we should... oh right.  nevermind.  ;)
08:40:35 <anybody> is funcM_ a version of func that returns a monad value instead of the normal ret value?
08:40:47 <quicksilver> if I had a blog, I'd write an anti-meta-programming rant to even up the balance
08:40:57 <opqdonut> :)
08:40:57 <quicksilver> anybody: normally it's one that takes a monadic action as one of its parameters
08:41:07 <quicksilver> anybody: and thus returns a monadic value too
08:41:21 <quicksilver> anybody: but the _ indicates it returns () instead of the value
08:41:31 <anybody> quicksilver: oh.
08:41:41 <quicksilver> the normal pattern is : func :: a -> b
08:41:44 <anybody> quicksilver: and if it dues return m a ?
08:41:48 <quicksilver> funcM :: m a -> m b
08:41:54 <quicksilver> funcM_ :: m a -> m ()
08:42:20 <quicksilver> (although real examples normally have 2 or more parameters only only some of them will be monadic)
08:42:26 <quicksilver> compare these three:
08:42:28 <quicksilver> :t map
08:42:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:42:31 <quicksilver> :t mapM
08:42:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:42:35 <quicksilver> :t mapM_
08:42:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
08:44:37 <anybody> hm i've never seen this notation before: a (m :: * -> *)
08:45:53 <byorgey> anybody: * -> * is a kind, which is essentially a higher-order type.
08:46:05 <psykotic> it just means that m is a type constructor with one parameter
08:46:19 <byorgey> Any concrete type (like Int, Double, [Bool]) has kind *
08:46:23 <quicksilver> anybody: e.g. Maybe has kind * -> *, because Maybe takes one parameter.
08:46:35 <quicksilver> anybody: Maybe Int has kind * because that's fully instantiated
08:46:44 <quicksilver> anybody: monads always have kind * -> *; they take a parameter
08:47:47 <anybody> quicksilver: hm if i do :t mapM in ghci it doesn't show me the kind
08:48:30 <opqdonut> anybody: you need to import Control.Monad
08:48:43 <shachaf> anybody: Try :set -fglasgow-exts
08:49:41 <malsyned> forall clauses are not part of Haskell98, the're a widely-supported extension.  Lambdabot has them turned on by default, ghci does not.
08:50:16 <anybody> ah there we go
08:51:29 <quicksilver> I don't actually think the forall clause adds anythign to the type signature (in that case)
08:51:38 <quicksilver> just makes it longer than it needs to be
08:52:12 <malsyned> yeah.  It'd be nice if ghci/lambdabot would only show them if they were expressing something that Haskell98 type signatures can't.
08:52:44 <quicksilver> yes. If there is at least one nested forall, then show em all
08:52:54 <quicksilver> but if it's all existentials-on-the-outermost, then don't bother
08:55:37 <Nucleo_> @pl (\y -> (sum y) <= n)
08:55:37 <lambdabot> (<= n) . sum
08:57:56 <opqdonut> @pl \f a g b -> a `f` g b
08:57:57 <lambdabot> ((.) .)
08:58:30 <opqdonut> @pl (.)(.)
08:58:31 <lambdabot> ((.) .)
08:58:41 <opqdonut> so sad it didn't give me the tit version
08:59:13 <anybody> @pl ((.),(.))
08:59:13 <lambdabot> ((.), (.))
08:59:23 <anybody> almost
08:59:40 <maskd> @pl (\a b c d -> a (b c d))
08:59:41 <lambdabot> (.) . (.)
09:00:43 <opqdonut> close :)
09:00:51 <opqdonut> @unpl . pl \f a g b -> a `f` g b
09:00:52 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Parse error
09:01:03 <opqdonut> @. unpl pl \f a g b -> a `f` g b
09:01:04 <lambdabot> (\ d g b c -> d g (b c))
09:01:06 <opqdonut> bah
09:01:19 <anybody> @tits
09:01:23 <lambdabot> Local time for anybody is Wed Aug  8 18:00:50 2007
09:01:29 <anybody> hah
09:02:12 <opqdonut> :D
09:02:31 <yaxu> http://doc.gold.ac.uk/~ma503am/alex/asciirave
09:02:34 <lambdabot> Title: ASCII Rave in Haskell | Alex McLean
09:08:11 <Philippa_> yaxu: any idea if you'll make Friday yet?
09:08:34 <sek> ha that's pretty cool
09:08:51 <byorgey> woah trippy =)
09:12:38 <dcoutts> dons: did you see therp's question about rts/Linker.c on openbsd?
09:12:49 <dcoutts> @ask dons did you see therp's question about rts/Linker.c on openbsd?
09:12:50 <lambdabot> Consider it noted.
09:16:01 <yaxu> Philippa_: i can't decide -- i'd *really* like to be there but am *really* behind on my thesis
09:16:32 <yaxu> :/
09:21:01 <karmazilla> Alex McLean?
09:22:13 <Syzygy-> karmazilla: That's yaxu.
09:22:36 <sek> if i'm trying to use parsec to parse something like http://www.doc.ic.ac.uk/~jb/teaching/simulation-and-modelling/example.mod , I should be roughly calling something like: do string "\model{" \n mod <- restofModel \n char '}' \n return mod. And then restofModel will be a large set of <|>'ed parser combs?
09:22:38 <lambdabot> http://tinyurl.com/3aalce
09:23:07 <sek> this is assuming lack of comments and the existance of a lexer and such
09:23:39 <sek> im just puzzled about the potentially large 1 <|> 2 <|> ... <|> n cases
09:23:47 <karmazilla> yaxu: alex mclean from pumpkin studios?
09:23:54 <yaxu> karmazilla: no
09:24:20 <karmazilla> ok :)
09:24:23 <yaxu> :)
09:26:29 <noteventime> What are the differences between the different Haskell compilers available?
09:26:52 <aeyakovenko> for some reason Data.Binary.decodeFile is leaving the file open, so when i write to it, i get an error: openBinaryFile: resource busy (file is locked)
09:26:53 <quicksilver> ghc - most widely used, largest number of extensions
09:27:00 <quicksilver> hugs - just an interpreter, also very widely used
09:27:17 <quicksilver> jhc - ambitious optimiser plans but not useful yet
09:27:45 <desegnis> sek, remember to use try for backtracking
09:27:51 <quicksilver> nhc/yhc - more useful Core format and arguably easier to extend
09:28:01 <quicksilver> ndm is writing some cool stuff on yhc I believe
09:28:20 <bos> aeyakovenko: are you decoding the entire file?
09:28:28 <ndm> things like Catch, Reach, Reduceron, Supero, Ycr2Js are all based on Yhc.Core
09:29:11 <ndm> thats pattern match checking, deep testing, fpga implementation, super optimisation and running in the webbrowser - for those who don't speak codename
09:29:16 <sek> desegnis, yes, but for example \constant,statevector,initial,transition... could come in any order, so the best method is to have a large set of <|>'ed parsers?
09:29:44 <desegnis> sek, yes, you'll need <|>
09:29:47 <aeyakovenko> bos, i dont know, i am decoding a smuch as the code function decodes, to fill the entire data structure that i encoded
09:29:49 <ddarius> Parsec.Permutation?
09:30:14 <desegnis> sek, if you have a list of parsers to try, there's also choice as a simple shorthand
09:30:33 <fxn> I think I saw a few months ago there was a book being written that covered practical usage of Haskell, is that right?
09:30:39 <sek> ddarius, that will end up being quite similar to many <|>s i think, but good point
09:30:54 <sek> desegnis, what do you mean choice?
09:31:50 <desegnis> sek, Parsec defines: choiceÂ psÂ Â =Â foldlÂ (<|>)Â pzeroÂ ps
09:32:05 <bos> fxn: http://www.realworldhaskell.org/
09:32:05 <lambdabot> Title: Real World Haskell
09:32:22 <sek> desegnis, ah! Swell
09:32:46 <desegnis> :)
09:32:48 <bos> aeyakovenko: if you don't read the entire file, it won't be closed
09:33:08 <aeyakovenko> bos, its the Data.Binary api that reads the file, so i have no idea if it read the entire file or not
09:33:14 <fxn> bos: that was it, thank you!
09:33:21 <bos> aeyakovenko: if you need to read just a small section of the file, you'll need to use a different mechanism
09:33:42 <bos> fxn: yeah, i'm one of the authors :-)
09:34:02 <fxn> bos: great! :-)
09:34:14 <aeyakovenko> bos, well, how do i read a file and close it
09:34:16 <fxn> bos: you've at least one reader .-)
09:36:22 <bos> aeyakovenko: System.IO.openFile, Data.ByteString.Lazy.hGetContents, System.IO.hClose
09:37:27 <fxn> bos: some friends and I are about to start a project, we are all programmers, but new to Haskell and looks like yours is the kind of book we need, is there any estimation for its publication? (it is fine if there's none)
09:37:53 <bos> fxn: we'll be putting up early chapters within the next month or two
09:38:08 <bos> fxn: the complete book will take longer, obviously :-)
09:38:13 <fxn> bos: ok
09:40:25 <aeyakovenko> bos, Data.ByteString.Lazy.hGetContents will read lazily though
09:41:42 <SamB> bos: eh
09:41:57 <bos> aeyakovenko: yes, but what you do is you pass that to Data.Binary.decode, get out the object you need, then close the handle
09:42:17 <SamB> don't call hClose after anything named hGetContents...
09:42:50 <SamB> bos: will the handle not be automatically closed after hGetContents reaches the end?
09:43:10 <bos> SamB: we're talking about a situation where the file isn't read completely
09:43:20 <MarcWeber> dcoutts ghci -package gtk did work using the installer made bei Neil. Thanks for your support
09:43:55 <bos> if the file *is* read completely, then calling hClose doesn't make sense.
09:44:14 <ndm> fxn: a book like graham huttons might suit you, if you are new to haskell
09:44:17 <sjanssen> bos: hGetContents puts the handle in a "semi-closed" state -- you should not use hClose on it under any circumstances
09:44:54 <ndm> fxn: i suspect the real world haskell book will be a great second book for a haskell programmer
09:45:02 <fxn> http://www.cs.nott.ac.uk/~gmh/book.html
09:45:03 <lambdabot> Title: Programming in Haskell
09:45:08 <fxn> bos: great
09:45:10 <ndm> yep, that one
09:45:22 <bos> @seen dcoutts
09:45:22 <lambdabot> dcoutts is in #ghc, #gentoo-haskell and #haskell. I last heard dcoutts speak 1m 43s ago.
09:45:40 <dcoutts> hia bos
09:45:44 <bos> dcoutts: gtk2hs isn't building on fedora 8 for some bizarre reason
09:45:50 <sjanssen> oh, are we talking about Data.ByteString.hGetContents?
09:45:53 <bos> dcoutts: look at the end of the build log: http://koji.fedoraproject.org/koji/getfile?taskID=92451&name=build.log
09:45:55 <bos> sjanssen: yes
09:46:09 <sjanssen> that's a bit different
09:46:14 * desegnis hopes for a low Dollar when Real World Haskell is published
09:46:27 <bos> sjanssen: yes, it is :-)
09:46:40 <sjanssen> hClose should be safe then, as long as you're sure that you won't be demanding any more of the string
09:46:48 <sjanssen> (referring to .Lazy, specifically)
09:46:54 * ndm hopes for free printing when its published ;)
09:47:04 <sjanssen> dcoutts: that might be a bug, actually
09:47:19 <dcoutts> sjanssen: hmm?
09:47:25 <bos> we'll probably send free review copies to influential bloggers, so be sure to become an influential blogger :-)
09:48:15 * monochrom hopes for pure communism when it's published. Everyone is entitled a copy by the state!
09:48:18 * arcatan installs wordpress
09:48:35 <bos> btw, it's safe to call hClose on a semi-closed handle in general
09:48:40 * monochrom starts a revolution
09:48:43 <desegnis> lol
09:48:43 <sjanssen> dcoutts: compare (BS.getContents x >> BS.getContents y) with (getContents x >> getContents y) where BS is Data.ByteString.Lazy
09:48:49 <desegnis> (sorry for colloquial language)
09:48:53 <bos> it's not safe to call any *other* handle-diddling function
09:48:55 <arcatan> monochrom: so are you revolting?
09:49:04 <sjanssen> bos: yeah, looks like I was wrong on that point
09:49:20 <dcoutts> sjanssen: you mean it does not call hClose when it finishes reading in lazy hGetContents ?
09:49:42 <bos> sjanssen: yeah, i'm reading GHC/IO.hs for the ultimate source of truth :-)
09:49:49 <sjanssen> dcoutts: System.IO.hGetContents semi-closes the handle, so other reading operations can't happen
09:50:10 <sjanssen> dcoutts: Data.ByteString.Lazy.hGetContents does not do this
09:50:57 <ihope> @src print
09:50:58 <lambdabot> print x = putStrLn (show x)
09:51:03 <ihope> How interesting.
09:51:07 <dcoutts> sjanssen: yes, that's because there was no easy way to do it without base hacking, it does need to be done
09:51:11 <dcoutts> bos: interesting, our c2hs is generating CUInt rather than CULong for all the gobject _get_type functions
09:51:48 <bos> sjanssen: GHC.IOBase and GHC.IO don't expose the plumbing for making a handle semi-closed
09:51:53 <dcoutts> bos: looks like some gobject typedef has changed so GType is now unsigned int rather than long
09:51:56 <ihope> Gasp. It's hortmage, but without the h.
09:51:57 * shachaf is a non-influential non-(we)blogger. Double negative! Do I get a copy?
09:52:14 <bos> dcoutts: ah, some new gtk API change?
09:52:20 <dcoutts> sjanssen: it'd be great to add a function to GHC.something to make it possible for us to semi-close
09:52:24 <bos> shachaf: you can read the web version for  free :-)
09:52:29 <dcoutts> bos: well, lower than gtk, but yes.
09:52:42 <bos> dcoutts: ok, so long as it's not me :-)
09:52:50 <dcoutts> bos: so the solution is probably to patch...
09:53:54 <dcoutts> bos: sed -i -e 's/import Foreign.C.Types    (CULong)/import Foreign.C.Types    (CULong, CUInt)/' gtk2hs/tools/hierarchyGen/Hierarchy.chs.template
09:54:02 <ihope> Can @src give instances?
09:54:23 <ddarius> bos: What is the estimated price tag by the way?
09:54:35 <sjanssen> bos: it looks like the necessary stuff is in GHC.Handle
09:54:47 <ddarius> ihope: Yes unless I misunderstand what you mean.
09:54:48 <shachaf> @src Maybe return
09:54:51 <lambdabot> return              = Just
09:55:35 <bos> dcoutts: ok, thanks
09:55:39 <bos> ddarius: no idea yet
09:55:53 <LPhas> dcoutts: i've some problem with c2hs, maybe you can help
09:57:18 <dcoutts> LPhas: perhaps I can
09:57:50 <dcoutts> bos: thanks for reporting that, I'm fixing it upstream
09:58:09 <Samedhi> I am working through the "haskell school of expression" book, and am having trouble getting a definition to return the proper type. Does anyone have time to look at it with me?
09:58:11 <Samedhi> http://hpaste.org/2131?lines=true#a0
09:58:31 <hpaste>  aeyakovenko pasted "strict decode file" at http://hpaste.org/2132
09:58:35 <LPhas> dcoutts: i msg-ed you
09:58:53 <aeyakovenko> i get this error when i try to strictly decode a file: hGetBufNonBlocking: illegal operation (handle is closed)
09:59:01 <dcoutts> LPhas: oh so you did
09:59:18 <Samedhi> regularPolygon is supposed to return type "Shape", but when I put that in there, it says type missmatch.
10:00:03 * SamB loads Samedhi's code up in GHCi
10:00:28 <bos> aeyakovenko: you probably need to force the evaluation of the entire value
10:00:37 <aeyakovenko> bos, how do i do that?\
10:00:46 <desegnis> Samedhi, you should probably use the Polygon constructor you declared
10:00:52 <ddarius> Samedhi: You are returning a list of pairs.  It looks like you want to wrap the result in Polygon.
10:00:59 <aeyakovenko> bos, why cant i just read everything into a string
10:01:00 <bos> aeyakovenko: here's a quick hack to see if that's the problem: just print it before you close the handle
10:01:15 <bos> aeyakovenko: you could read the entire file if you want, that's just kind of wasteful
10:01:23 <aeyakovenko> bos, i want to read the entire file
10:01:31 <aeyakovenko> bos, since ill be using all of it
10:01:38 <bos> aeyakovenko: d'oh!
10:01:43 <desegnis> Samedhi, note that regPoly returns [Vertex], and Polygon :: [Vertex] -> Shape
10:01:54 <bos> you should have mentioned that earlier. in that case, decodeFile is perfectly appropriate.
10:02:06 <aeyakovenko> bos, except i wont be using the entire thing every time
10:02:21 <bos> euh, now you have me confused.
10:02:43 <cognominal_> dweeb question: how can convert a Integer to an Int so I can use it with drop or take?
10:02:43 <cognominal_> s/can/can I/
10:02:54 <shachaf> cognominal_: fromIntegral
10:02:55 <aeyakovenko> bos, can you just tell me how to read the entire file into a string :)
10:02:56 <bos> cognominal_: fromIntegral
10:02:57 <Samedhi> desegnis and ddarius: thank you, let me think about what you said for a few minutes
10:03:01 <noteventime> How is Haskell associated with TUNES? (Just wondering as the logs seem to be stored on the TUNES website.)
10:03:09 <ddarius> noteventime: It isn't.
10:03:10 <shachaf> cognominal_: Or use genericDrop/genericTake.
10:03:15 <ihope> Who runs hpaste?
10:03:19 <ddarius> glguy
10:03:28 <cognominal_> thx
10:03:51 <ihope> I notice that the "raw" link returns type text/html.
10:04:11 <ddarius>  @ask him perhaps?
10:04:31 <bos> aeyakovenko: use hGet with some huge number
10:05:04 <bos> e.g. hGet (maxBound::Int)
10:05:07 <ihope> @tell glguy hpaste's "raw" link is returning text/html--shouldn't that be text/plain or some such?
10:05:07 <lambdabot> Consider it noted.
10:05:31 <aeyakovenko> bos, thanks
10:06:14 <aeyakovenko> bos, this seems so busted to me, there should be equivalent function defined that do not have this behaviour
10:06:28 <bos> aeyakovenko: what seems busted?
10:06:50 <aeyakovenko> the fact that i cant read a part of a file, then rewrite it
10:06:58 <aeyakovenko> i have to specifily close the handle
10:07:00 <bos> aeyakovenko: you're using windows, right?
10:07:05 <aeyakovenko> no, linux
10:07:26 <bos> sure you can rewrite it, you just need to open it with the correct mode.
10:07:57 <bos> ReadWriteMode
10:08:11 <ddarius> So is "Join #haskell" on of the first steps listed in your book?
10:08:20 <monochrom> haha
10:08:22 <bos> it makes some sense that you can't write to a file that you've opened read-only, don't you think?
10:08:32 <bos> ddarius: yes, it's really just a one-page pamphlet
10:08:34 <SamB> ddarius: I don't remember that book having anything like that
10:08:46 <aeyakovenko> bos, it doesn't make sense that readFile has a sideffect that prevents you from writing to that file
10:08:48 <SamB> oh. different book?
10:08:55 <ddarius> SamB: Real World Haskell
10:09:03 <monochrom> It makes sense to me, aeyakovenko.
10:09:13 <SamB> Samedhi: oh, right, I meant to be helping you
10:09:27 <daniel_larsson> aeyakovenko: if readFile had the sideeffect of letting you write to it, it would seem strange )
10:09:42 <bos> aeyakovenko: how are you trying to write to the file?
10:09:42 <SamB> oh but someone else did it already
10:10:08 <aeyakovenko> bos, using Data.Binary.encodeFile/decodeFile, so i decode a data structure, change part of it, and encode it back
10:10:08 <Philippa_> aeyakovenko: that's how the OS works, it's not just haskell
10:10:11 <Samedhi> well thanks, I am currently trying to figure out how to "cast"/"wrap" my pair tuble of floats into a Polygon.
10:10:22 <Samedhi> SamB: I think.
10:10:26 <bos> aeyakovenko: but what are you using to write to the file?
10:10:29 <ddarius> Samedhi: Polygon has type [Vertex] -> Shape
10:10:32 <aeyakovenko> that seems like something that should work without me having to care about the implementation of encodeFile/decodeFile
10:10:45 <aeyakovenko> decodeFile :: Binary a => FilePath -> IO a
10:10:48 <ddarius> As desegnis mentioned.
10:10:51 <aeyakovenko> encodeFile :: Binary a => FilePath -> a -> IO ()
10:11:12 <bos> aeyakovenko: and what error are you getting when you do the encodeFile?
10:11:25 <aeyakovenko> bos, that the binary file is locked
10:11:31 <ihope> Samedhi: you have [(Float,Float)], which is equivalent to [Vertex], and you have [Vertex] -> Shape, and you want Shape.
10:11:38 <SamB> hmm
10:11:54 <bos> locked!?
10:12:02 <aeyakovenko> yep
10:12:12 <bos> aeyakovenko: what's the exact error message?
10:12:27 <SamB> how do I generate the vertices of a rectangle centered at the origin?
10:12:48 <aeyakovenko> openBinaryFile: resource busy (file is locked)
10:12:50 <SamB> I don't care if they're in order...
10:13:24 <bos> aeyakovenko: that's really weird. the ghc runtime shouldn't be doing any file locking there.
10:14:00 <ddarius> SamB: In general, or with that Shape type?
10:14:06 <dcoutts> bos: I don't suppose you can check what type GType gets defined as in gtk2hs/glib/System/Glib/GType.hs in that FC8 build
10:14:07 <SamB> ddarius: it's unrelated
10:14:22 <SamB> and actually I decided it would be easier to just type them out
10:14:28 <ddarius> (w/2,h/2), (-w/2,h/2) etc.
10:14:33 <dcoutts> bos: I'm assuming it's CUInt
10:14:36 <ddarius> SamB: There are only four.
10:14:40 <SamB> yes
10:14:50 <bos> aeyakovenko: ok, there's something really weird going on.
10:15:03 <bos> aeyakovenko: the GHC runtime *is* locking the file, which makes no sense at all.
10:15:05 <Samedhi> ihope: So when I declare these "data" structures, I am really just saying that the things that I declared to the right can evaluate to the things in the left?
10:15:09 <SamB> I thought there might be some cool way using a cross product involving negate and id...
10:15:37 <bos> dcoutts: no, i can't check. that code is all run on a fedora build box that i can't log into.
10:15:48 <bos> aeyakovenko: i'll file a bug against GHC.
10:15:51 <aeyakovenko> well it uses Data.ByteString.Lazy.readFile underneath, so unless i use the entire data structure the handle wouldn't get closed
10:15:57 <dcoutts> bos: ok, nm
10:16:00 <ddarius> Samedhi: When you write data TypeConstructor a = DataConstructor1 a | DataConstructor2 Int, you declare two functions DataConstructor1 :: a -> TypeConstructor a and DataConstructor2 :: Int -> TypeConstructor a
10:16:31 <aeyakovenko> and its not deterministic if i use the entire thing or not
10:16:58 <Samedhi> ddarius: Ok, cool. I was viewing them more like inheritance.
10:16:59 <ddarius> Samedhi: You can then use the data constructors in pattern matching, foo (DataConstructor1 x) = 0; foo (DataConstructor2 n) = n
10:17:07 <sjanssen> > let w = 1; h = 2 in [(f (w/2), g (h/2)) | f <- [id, negate], g <- [id, negate]]
10:17:09 <lambdabot>  [(0.5,1.0),(0.5,-1.0),(-0.5,1.0),(-0.5,-1.0)]
10:17:33 <sjanssen> @pl \x -> liftM2 f x x
10:17:34 <lambdabot> join (liftM2 f)
10:17:35 * ddarius suggests the explicit code (with some bindings) would probably shorter and clearer.
10:18:19 <sjanssen> @pl \(f, g) -> (f w, g w)
10:18:19 <lambdabot> ap ((. ($ w)) . (,) . flip fst w) snd
10:18:27 <SamB> ddarius: yeah
10:18:51 <Cale> Samedhi: Another way to say what ddarius is saying, in case it helps, is that when you have  data T a = D1 a | D2 Int, it means that a value of type (T a) is either of the form (D1 x) where x is of type a, or of the form (D2 n) where n is an Int.
10:18:55 <SamB> since I only really want it for a particular rectangle, I decided to just type the coordinates
10:19:14 <SamB> also I'd have wanted it based on the coordinate of one corner
10:20:15 <Samedhi> Cale and ddarius:  yes, both your answers do help some
10:29:18 <anybody> hm. stupid question. i haven't found this but if i have data Urgl = Argl Int | Jargl deriving(Show) i want Argl Int to use the show function already defined and i would like to have a custom show function for Jargl. how can i do this?
10:29:51 <anybody> just appending where show Jargl = "..." doesn't work :-(
10:30:23 <shapr> You could write your own Show instance for Urgl, and have show Argl x = show x
10:30:39 <xerox> anybody: you either use deriving (Show) or provide your own show instance with instance Show Urgl where ...
10:30:52 * shapr cranks out the code...
10:30:57 <shapr> mmm code
10:31:02 <anybody> xerox: so its not possible to use both :-(
10:31:11 <anybody> that kinda sucks
10:32:06 <anybody> if i have a data type with some constructors that already have a default show that's sufficient and i have only like one or 2 that i want to define myself i would have to define all of them then...
10:32:28 <sjanssen> anybody: generally, you should not override Show's behavior
10:33:04 <psykotic> people generally use something else for "user-friendly" pretty printing
10:33:48 <psykotic> if you're used to python, show is more like repr(), not str()
10:33:53 <Philippa_> yeah, user-friendly pretty printing doesn't necessarily want to have to interact with any Read instance
10:34:18 <shapr> I do wish we had both repr and str :-(
10:34:27 <psykotic> it wouldn't be bad to have another type class for str-like printing that defaults to repr
10:34:53 <xerox> shapr: repr might be what Data.Binary provides.
10:35:01 <psykotic> no, repr is more like show
10:35:16 <psykotic> an ascii readable representation that's ideally reversible
10:35:40 <Philippa_> Show shouldn't be a pretty-printer, it should be an ugly-printer with easily parseable output
10:35:54 <psykotic> class Pretty a where prettify :: a -> String ; instance Show a => Pretty a where prettify = show... would be nice
10:36:02 <kpreid> in principle, if the "pretty" output is parseable, there's no harm in using it for Show outpu
10:36:07 <sjanssen> ideally, Show has the copy-paste property as well
10:36:29 <Philippa_> kpreid: depends. There damn well is for abstract syntax trees if the "pretty" output is source!
10:36:34 <shapr> psykotic: I like that.
10:36:36 <sjanssen> ie. Show output is valid Haskell source code that produces the term
10:36:51 <kpreid> Philippa_: point
10:36:55 <Philippa_> psykotic: I suspect that'll hit overlapping instances unfortunately :-(
10:36:59 <psykotic> i know
10:37:07 <sjanssen> psykotic: the overlapping instance makes me squirm a bit
10:37:08 <psykotic> but that's one of the cases of overlapping instances that i'm willing to accept :)
10:37:22 <psykotic> that kind of defaulting is too nice to pass up
10:37:24 <Philippa_> deriving support would be good though
10:37:45 <Philippa_> it'd mean you had to turn them on in any module that uses it though, which is bad
10:37:57 <psykotic> i thought it was local to the defining module
10:38:07 <psykotic> or is that undecidable instances only?
10:38:42 <Philippa_> no idea. I'm waiting to see what SPJ has to say about the AT equivalent on Friday
10:38:48 <psykotic> anyway, like shapr, i wish for something like this constantly.
10:38:58 <sjanssen> you only have to give -foverlapping-instances in the module containing the definition
10:39:00 <psykotic> (and use this myself, overlapping instances be damned)
10:39:03 <Philippa_> I mostly just go without the typeclass
10:39:42 <Samedhi> Thanks ya'll for your help with the ( I understand that it is just a transformation, but I still can't help thinking of it as a inheritance) problem I was having.
10:40:01 <Samedhi> I got it working proper (well, the output it wrong, but that is just being pedantic) :)
10:40:39 <psykotic> shapr, what do you do for your own hacking?
10:41:40 <sjanssen> personally, I'd skip the overlapping instance, but allow "deriving Pretty"
10:41:57 <sjanssen> where the derivation for pretty is the same as Show, by default
10:42:19 <psykotic> that's annoying, because you have to modify existing code
10:42:22 <sjanssen> I think there are very good reasons to avoid "instance Show a  => Pretty a"
10:42:33 <psykotic> sjanssen, do you think cycles are likely?
10:42:35 <sjanssen> Maybe should not be an instance of pretty
10:42:48 <psykotic> i don't agree
10:43:13 <shapr> psykotic: You mean, how do I deal with str/repr in my own code?
10:43:19 <psykotic> i have a lot of experience using str() and repr() in python, whose relationship is similar to what i'm proposing
10:43:26 <psykotic> and it works out very nicely in practice.
10:43:27 <sjanssen> IMO, pretty is for "user facing" output.  "Nothing" or "Just x" are not useful outputs for a user
10:43:48 <psykotic> sjanssen, but it's nice to have a sensible default.
10:44:02 <psykotic> shapr: in haskell
10:44:03 <sjanssen> psykotic: it's nice to have a type error when you make a mistake :)
10:44:16 <shapr> Personally, I think we should have Show and Serialize.
10:44:22 <desegnis> sjanssen, then hardly any standard type would have a Pretty instance
10:44:42 <shapr> psykotic: Data.Binary for Serialize, Show for text output.
10:44:45 <sjanssen> desgnis: this is probably true
10:44:47 <psykotic> right
10:44:52 <psykotic> although that's less backwards compatible
10:44:58 * SamB wants pretty printers for Show
10:45:03 <shapr> Yeah, but it's better for significant names.
10:45:10 <psykotic> yes, i agree
10:45:28 <desegnis> I sometimes wish for list printing to be less condensed
10:45:34 <sjanssen> shapr: I'd rather not lose Show, which has the vital "source code as output" property
10:45:48 <psykotic> desegnis, you mean more condensed?
10:46:12 <psykotic> i would like a data structure pretty printing library with configuration parameters
10:46:18 <shapr> sjanssen: In Python, eval(repr(x)) == x should hold, how do you express that in Haskell?
10:46:19 <SamB> psykotic: well yes
10:46:23 <psykotic> basic parameters concerning "depth" and "breadth" of printing
10:46:24 <SamB> of course it would have parameters
10:46:37 <SamB> preferably, you could supply your own pretty printing library...
10:46:41 <sjanssen> shapr: Plugins.eval (show x) == x -- :)
10:46:43 <psykotic> so you can say, just truncate lists with ... beyond a certain length. it wouldn't be specific to lists--everything could interpret them according to their own structure.
10:46:44 <desegnis> psykotic, no, I mean with spaces after commas, and newlines after long elements, etc.
10:47:19 <sjanssen> shapr: IMO, the source property is still useful even though we don't have eval in Haskell
10:47:30 <shapr> Yeah, it is a useful property.
10:47:31 <psykotic> shapr, the closest equivalent is read . show = id
10:47:35 <mux> but we have hs-plugins! :)
10:48:12 <psykotic> shapr: do you use python's pprint module much?
10:48:18 <psykotic> shapr: i couldn't live without it.
10:48:34 <shapr> Seems to me that Read/Show should be part of Serialize, but Pretty should be added.
10:48:42 <shapr> psykotic: I don't write Python code anymore if I can help it.
10:48:50 <psykotic> shapr: well, when you did, then :)
10:49:06 <shapr> Seven years of hacking around in Zope/Plone put a bad taste in my mouth.
10:49:10 <psykotic> it seems like something like that could be coded very easily using the existing PPrint combinators for layout
10:49:37 <sjanssen> in my ideal world, we'd have: Serialize (fast, dense binary format), Show/Read (programmer-facing, not performance critical, has the source code property), and Pretty (which is based on pretty printing combinators)
10:50:06 <shapr> sjanssen: But why should Show/Read be two separate classes?
10:50:24 <shapr> Why not have Serialize with Binary and Text?
10:50:37 <sjanssen> it'd be nice if the pretty printer could have options attached to it, like number printing style, automatic line breaking, etc.
10:51:09 <sjanssen> shapr: Show and Read could be combined
10:51:16 <psykotic> also dealing with cycles. it seems like cycles could be handled externally by using the older fix point trick.
10:51:22 <psykotic> *old
10:51:44 <shapr> psykotic: I don't think I used pprint very much, I found it quite easy to read Python source code.
10:51:50 <sjanssen> I'm not so sure about combining them with Serialization though -- they seem very different in my mind
10:51:55 <psykotic> shapr: it's not for source code but for data.
10:52:17 <psykotic> shapr: it does very nice layout, deals with cycles, deals with truncating beyond a certain length and depth, etc. you can specify these parameters yourself.
10:52:23 <shapr> psykotic: Though I do remember when I first started learning Haskell, I found about twenty pages of Haskell source and expected #haskell people to be able to read that much source in about ten minutes. That's about how long it would take in Python, yeah?
10:52:41 <shapr> psykotic: In that case, I *should* have used it :-)
10:52:45 <psykotic> hehe
10:53:34 <psykotic> you could do something like that handily in haskell by having a monad that would contain the config parameters and state for tracking cycles, etc.
10:53:43 * psykotic is probably going to do it now.
10:53:59 <shapr> Go go!
10:54:02 <psykotic> although, ugh, you don't have pointer equality :)
10:54:03 * shapr cheers for psykotic 
10:54:16 <shapr> I'm pretty happy about that feature of Haskell.
10:54:21 <psykotic> if you do a naive == on a cyclic structure, to check for cycles... hehe
10:54:25 <psykotic> i know
10:58:03 <SamB> psykotic: we have extremely unsafe pointer equality...
10:58:59 <psykotic> how do people usually deal with detecting cycles in things? i can see one idea--which is if you have a structure of Foo a's then you make it a Foo (Maybe Label, a) and go through it recursively and assign labels
10:59:13 * SamB would personally prefer to see some kind such that if you seq'd the args first, it would actually tell you if the two arguments referred to the same heap object or not
10:59:18 <psykotic> (you stop recursion when you encounter an already assigned label)
10:59:48 <glguy> psykotic: that would only work with mutable labels
10:59:49 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
11:00:07 <SamB> psykotic: cycles in what things?
11:00:15 <psykotic> glguy, how then? it seems like without some notion of "label" to latch on to, you get in trouble.
11:00:31 <psykotic> SamB, any structure. which will always ultimately be a graph, if you squint hard enough.
11:00:47 <SamB> psykotic: avoid having cycles that you don't know where are
11:00:47 <glguy> psykotic: without mutable references or some magic hackery, a cyclic data structure is indistinguishable from an infinite one
11:00:49 <SamB> basically
11:00:58 <SamB> (in things that you want to serialize)
11:01:00 <psykotic> glguy, yeah, that's what i was coming to conclude.
11:01:00 <glguy> they are "observationally equivalent"
11:01:15 * psykotic nods.
11:01:16 <psykotic> thanks
11:01:34 <SamB> glguy: simply labeling all of the nodes with unique-within-the-datastructure labels in the first place would be sufficient
11:01:39 <psykotic> i guess another way of looking at this pragmatically--sinec you might need to deal with infinite structures anyway, handling the "special case" of cyclicity wouldn't work anyway
11:02:00 <psykotic> so you should just deal with the infinite case
11:02:30 <SamB> if you want to represent a graph, you don't just represent it as an isomorphic datastructure...
11:02:39 <glguy> SamB: sure, if you plan ahead and trust that the invariants are maintained
11:02:46 <glguy> SamB: then you could serialize it easier
11:02:48 <SamB> glguy: or ensure
11:03:03 <glguy> both :)
11:03:08 <glguy> I'm not arguing against
11:03:41 <SamB> I wouldn't be surprised if GHC's Names were part of a cyclic directed graph
11:04:02 <glguy> You can detect it with certain GHC extensions I expect
11:04:13 <glguy> I can't imagine you couldn't, but I don't know which ones to use
11:04:25 <glguy> maybe something in FFI?
11:04:37 <SamB> glguy: what are you talking about now?
11:04:49 <glguy> doing pointer equality
11:04:53 <glguy> to find cycles
11:05:01 <SamB> that's not the way to do it
11:05:05 <SamB> it really isn't
11:05:23 <glguy> Is there a good way to do it on an arbitrary graph?
11:05:35 <SamB> no
11:05:44 <SamB> you avoid those
11:05:49 <glguy> ok , then we agree :)
11:06:07 <Philippa_> SamB: there's safe pointer equality in GHC, it's just in IO
11:06:22 <SamB> Philippa_: what is it?
11:08:13 <Saizan> (==) on IORefs?
11:08:39 <Philippa_> SamB: System.Mem.StableName
11:09:03 <ari> @src IORef (==)
11:09:03 <lambdabot> IORef x == IORef y = x == y
11:09:18 <SamB> Philippa_: that doesn't do very well...
11:09:29 <sorear> Be careful.  Laziness means than an (id x) thunk is distinguishable from x.
11:09:32 <SamB> at least, the documentation is not very inspiring
11:09:49 <SamB> sorear: yeah...
11:10:23 <Philippa_> SamB: the comparison to StablePtr tells you what you really need to know
11:12:15 <lament> onlyDirectories :: [FilePath] -> IO [FilePath]
11:12:15 <lament> onlyDirectories =  filterM doesDirectoryExist
11:12:30 <lament> now, how do i add a not in there so it _omits_ directories?
11:12:49 <SamB> filterM (liftM not . doesDirectoryExisst)
11:12:53 <SamB> I think
11:13:04 <SamB> except without the extra s in Exist
11:13:22 <lament> oh crap. i was missing that dot. thanks :)
11:14:01 <ihope_> The latest version of GHC isn't 6.4.2, is it?
11:14:08 <SamB> hahahah
11:14:15 <SamB> ihope: what rock have you been living under?
11:14:28 <SamB> we are up to GHC 6.6.1 at least
11:14:34 <bos> ihope: 6.6.1, with 6.8 around the corner
11:14:54 <ihope_> Thought not.
11:15:34 <ihope_> "Latest Version: 6.4.2-2ubuntu1"
11:15:45 <bos> yeah, ubuntu is slow to update things.
11:16:27 <ihope_> Can I get 6.6.1 this way, or will I have to... do it another way?
11:16:51 <Cale> 6.6 is in Feisty. To get 6.6.1, you can just install the generic linux binary.
11:17:12 <geezusfreeek> ihope_, you can also subscribe to the backports repository
11:17:41 <geezusfreeek> if that's the only way to get 6.6 to show
11:18:24 <ihope_> Well, I did just do something that I think involved updating the kernel. :-P
11:18:40 * glguy switched to Debian "testing" to get all the new ghc's and libs
11:18:55 <ihope_> Does that mean a reboot will show 6.6 or 6.6.1 there?
11:20:29 <geezusfreeek> that shouldn't mean anything unless that updated you to feisty
11:20:35 <Cale> ihope: What exactly was it that you did? A distribution upgrade?
11:21:38 <psykotic> wow, i just saw some of bulat's code for the first time
11:21:42 <psykotic> looks more like c than haskell
11:22:19 <ohub> Hey, any cvs.haskell.org admins here?
11:22:43 <Cale> Bulat is insane :)
11:22:43 <ohub> I'm seeing "cvs [login aborted]: unrecognized auth response from cvs.haskell.org: pam failed to release authenticator" and googling tells me it might be a misconfiguration issue?
11:22:57 <ohub> http://ch.tudelft.nl/~arthur/cvsd/faq.html#authresponse
11:22:58 <lambdabot> Title: cvsd: frequently asked questions
11:23:00 <psykotic> cale: why does he even use haskell?
11:23:27 <psykotic> i somehow think he would be happier with ocaml, say
11:23:37 <Cale> psykotic: I'm really not sure, given how much effort he's gone to in order to make it not like Haskell :)
11:24:08 <psykotic> he probably has BulatPrelude with strstr, strchr, atoi, etc :)
11:25:10 <ihope_> Cale: I used the "Update Manager" program, which I suspect is more-or-less equivalent to apt-get update.
11:25:48 <Cale> ihope_: Ah, to upgrade to feisty, you have to pass it some additional switches on the commandline.
11:26:29 <ihope_> Pass what some additional switches?
11:27:19 <shachaf> ihope_: Update Manager.
11:29:16 <ihope_> It does have an upgrade-to-Feisty button.
11:33:05 <ihope_> I'll try it.
11:33:08 <SamB> you know, I don't think the Haskell 98 people were being very creative when they did the prelude.
11:33:14 <SamB> -- Standard numeric types.  The data declarations for these types cannot
11:33:14 <SamB> -- be expressed directly in Haskell since the constructor lists would be
11:33:14 <SamB> -- far too large.
11:33:25 <SamB> no ingenuity whatsoever!
11:36:03 <mrd> yea what's so long about: data Nat = O | S Nat
11:36:17 <mrd> or X | I | O
11:36:20 <mrd> er
11:36:54 <SamB> I'll have to admit that it takes a while, but I've basically written Integer in pure Haskell
11:37:23 <SamB> probably someone else actually implemented Integer that way...
11:39:42 <shapr> Is there some tool that spits out a .dot file of module dependencies for a bunch of Haskell source?
11:40:28 <shapr> Is there any way to show a graphical view of modules deps? I know hIDE used to do that...
11:40:36 * SamB is not aware of any tool
11:41:02 <SamB> I think all Haskell compilers capable of dependency analysis ought to provide such a feature...
11:41:24 <shapr> Can ghc dump module deps for a chunk of source as text?
11:41:50 <eivuokko> As makefile rules, atleast.
11:41:52 <Saizan> ghc -M module dumps it in Makefile format
11:41:59 <shapr> hmm
11:47:35 <shapr> So, anyone written any cool code lately?
11:47:55 <SamB> oh... kay...
11:48:02 <eivuokko> cabal2wix, so I can generate MSIs from Cabal ;)
11:49:18 <shapr> nifty
11:50:10 <lament> oh god
11:50:37 <lament> this is the hundredth time i spend more than ten minutes debugging only to discover i didn't put a $ after a return :(
11:52:17 <Lemmih> lament: You forgot a $ and it compiled?
11:52:43 <lament> no, it didn't
11:53:21 <lament> so i spent ten minutes looking for type problems in the code of the function...
11:53:58 <Lemmih> Ah, debugging == translating the ancient errors runes of the mighty GHC.
11:55:32 <anybody> hey is there already a function in haskell similar to shuffle in c++'s STL?
11:55:57 <glguy> not in the standard libraries
11:56:00 <Lemmih> anybody: Nope.
11:56:09 <anybody> Lemmih: oopsie
11:56:44 <anybody> i guess i have to implement it myself then. but i have no idea how i would do that ;-) just look at the C++ source i guess ;-)
11:57:00 <shachaf> anybody: What does C++'s shuffle do?
11:57:12 <Saizan> there's a post by Oleg with a O(n log n) pure solution
11:57:46 <anybody> shachaf: i takes a random access sequence and permutes it randomly
11:58:08 <anybody> Saizan: thx.
11:58:22 <aleator> anybody: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
11:58:50 <Saizan> that one :)
11:59:06 <aleator> perfect shuffle really needs to be in standard libs, imo.
12:00:18 <isaacd_> darn, my haskell code seems to be being bitten by some gcc(4.1.2) bug, using ghc -O (-fvia-C implied)
12:00:40 <isaacd_> aleator: yes, I tend to think so too
12:01:27 <Saizan> i'd like it on top of Data.Set
12:01:33 <shapr> isaacd_: Tried -fasm ?
12:01:35 <Saizan> given that's a size-balanced tree
12:01:49 <isaacd_> shapr: yes, that's how I know it's gcc's fault
12:01:59 <shapr> ah
12:02:02 <isaacd_> (unless of course GHC is using it wrongly somehow)
12:02:29 <SamB> isaacd_: it IS
12:02:47 <SamB> GHC is supposed to use GCC wrongly
12:03:30 <isaacd_> Also it doesn't happen with -O0 -fvia-C, and doesn't happen if I add a debug-print statement to my code that makes GHC worse at core optimization. I think it's something to do with constant folding / arithmetic
12:03:32 <anybody> is ghc using gcc?
12:04:02 <isaacd_> anybody: it does with -fvia-C, which in ghc <= 6.6.1 is implied by -O
12:04:16 <sjanssen> isaacd_: just use -O -fasm
12:04:28 <sjanssen> the difference is usually negligible
12:04:28 <isaacd_> SamB: I wonder if you have a point there
12:04:40 <shapr> isaacd_: Can you boil it down to a small amount of failing code?
12:04:53 <isaacd_> possibly - it would take some time
12:05:06 <shapr> Isn't the GHC team trying to get away from -fvia-C?
12:05:31 <SamB> for unregisterized compilers, yes
12:05:38 <SamB> er.
12:05:41 <SamB> registerized
12:06:07 <SamB> in other words, I heard they want to get rid of the evil mangler
12:06:44 <SamB> so they'll either be using whatever C compiler rightly, or directly outputting ASM
12:07:12 <isaacd_> 6.7 with -O -fvia-C also has the problem
12:07:58 <isaacd_> SamB: yes, they/we want to, would like to, but I'm not sure it will actually be gone anytime soon!
12:08:58 <isaacd_> various people even rely on it, though we can minimize that by making ghc's low level optimizations better, I think
12:09:41 <isaacd_> it's at least good for testing where ghc's optimizations could be improved :)
12:10:06 <SamB> or you could emit valid c-- and use someone else's code generator. well. if anyone had actually implemented c--.
12:10:51 <isaacd_> yes, if it could work with some good non-C language. would LLVM be any good for that, these days?
12:11:09 <SamB> huh?
12:11:27 <SamB> what does "it" refer to
12:11:40 <isaacd_> GHC's backend, I think?
12:11:53 <isaacd_> I'm a little confused by what I said, too.
12:12:08 <SamB> doesn't GHC already have an IR called Cmm?
12:12:22 <SamB> which is supposed to be more-or-less C--?
12:12:27 <isaacd_> yes
12:12:32 <isaacd_> plus and minus
12:12:41 <SamB> plus *and* minus?
12:12:49 <SamB> more-*and*-less?
12:12:51 <isaacd_> GHC may end up containing the best C-- implementation someday
12:13:10 <isaacd_> yes, it has extensions for some things and doesn't implement other parts it doesn't need, I believe
12:13:23 <SamB> what extensions?
12:13:41 <isaacd_> I don't know details, maybe see GHC Commentary wiki?
12:14:01 <SamB> anyway, I think GHC would be more likely to contain the best C-- implementation eventually if it is possible to have it use external implementations soon
12:14:37 <OceanSpray> are there such things are references or pointers in haskell?
12:14:54 <SamB> OceanSpray: there are some things of that general nature
12:15:00 <SamB> what do you desire?
12:15:11 <isaacd_> OceanSpray: almost everything in Haskell is represented as a reference/pointer
12:15:21 <OceanSpray> remember that lisp interpreter I am writing?
12:15:22 <SamB> isaacd_: that story is unhelpful ;-)
12:15:26 <isaacd_> Also there are explicit pointers with IO if you *really* need them
12:15:34 <SamB> OceanSpray: oh, you want to intern symbols?
12:15:35 <OceanSpray> One environment must have a pointer to its 'parent' environment
12:15:40 <SamB> oh, that.
12:16:12 <SamB> what variant of Lisp?
12:16:18 <OceanSpray> a new one
12:16:28 <SamB> are the environments mutable?
12:16:30 <OceanSpray> yes
12:17:33 <OceanSpray> If I were to just do 'data LispVal = Environment (LispVal Environment) (IORef [(String, IORef LispVal)]',
12:17:37 <SamB> hmm. well. you could use IORef, STRef, MVar, TVar, or something cleverer
12:17:47 <OceanSpray> would it work as intended?
12:18:01 <SamB> what do you intend?
12:18:28 <OceanSpray> An environment is mutable, and it has access to its parent environment, which is also mutable, and so forth
12:18:41 <SamB> also I don't imagine that will work too well...
12:19:00 <OceanSpray> what, the code or the concept?
12:19:11 <SamB> the data declaration looks really messed up...
12:19:30 <OceanSpray> yeah, forgot a parenthesis there.
12:19:31 <isaacd_> It looks okay to me, except a pissing close-parenthesis
12:19:35 <SamB> you could take a look at pugs if you want to see how they do theirs... though probably that's not a very nice way to start...
12:19:42 <isaacd_> *missing
12:20:40 <OceanSpray> The real question is,
12:20:55 <isaacd_> and that association-lists are a REALLY inefficient form of map data, most of the time
12:20:55 <OceanSpray> does the above code create a 'local' copy?
12:21:17 <OceanSpray> well, how would you represent variables without association lists?
12:21:31 <SamB> Data.Map.Map
12:21:47 <OceanSpray> that ain't mutable.
12:22:00 <SamB> quite true
12:22:03 <SamB> but that's not a problem
12:22:07 <OceanSpray> oh?
12:22:18 <isaacd> Neither is an association list, but you can make a modified version and change the contents of the IORef to that
12:22:46 <SamB> the arrays I use in my ZMachine implementation aren't mutable, either
12:23:14 <johnnowak> isaacd: that would be quite expensive, no?
12:23:26 <SamB> johnnowak: compared to Data.Map, yes ;-)
12:23:27 <isaacd> insert element = O(log(n))
12:23:34 <isaacd> for Data.Map :)
12:23:46 <SamB> for alist, it's clearly O(n)
12:24:08 <isaacd> see what I said about most everything in Haskell being reference - there are not usually copying costs
12:24:34 <OceanSpray> say we have two Environments that refer to the same parent
12:24:37 <johnnowak> OceanSpray: what you can do is, rather than representing environments as delegating maps, make them persistent and lose the need for delegation
12:24:54 <SamB> johnnowak: he wants mutability though
12:24:56 <OceanSpray> what's that mean?
12:24:56 <isaacd> OceanSpray: okay, since you created them with the same IO-execution of newIORef
12:24:58 <johnnowak> no he doesn't
12:25:04 <johnnowak> he's lying!
12:25:05 <OceanSpray> yeah, I do.
12:25:23 <SamB> johnnowak: how would YOU implemented mutable outer scopes?
12:25:44 <sjanssen> carefully
12:25:46 <johnnowak> i haven't any better ideas.
12:26:13 <isaacd> Haskell with pure values is Turing-complete, it can certainly compute anything equivalent to mutation, somehow
12:26:19 <johnnowak> other than writing this in scheme anyway.
12:26:21 <SamB> anyway, apparantly Data.Map is faster than Data.HashTable
12:26:26 <SamB> isaacd: well, yes
12:26:35 <SamB> but you wouldn't do what johnnowak is suggesting
12:26:44 <OceanSpray> guess what else is Turing complete:
12:26:47 <OceanSpray> a Turing machine.
12:26:48 <johnnowak> not if you want mutability, no
12:27:07 <SamB> you'd basically implement the ST monad ;-)
12:27:13 <Cale> Huh?
12:27:19 <Cale> This conversation is hard to follow :)
12:27:28 <OceanSpray> I'm confused.
12:27:37 <sjanssen> hi confused, I'm sjanssen
12:27:48 <isaacd> I'm not suggesting actually implementing a turing machine...
12:27:53 <johnnowak> SamB: i've been prodding oceanspray about this project for awhile... i didn't mean you imply your solution wasn't right for what it is he's looking for.
12:28:18 <OceanSpray> what AM I looking for?
12:28:21 <isaacd> just an equivalent phrase to "equivalent in power to lambda calculus" etc :)
12:28:32 <Cale> Hashtables are overrated, Data.Map is where it's at :)
12:28:37 <OceanSpray> First-class environments.
12:28:54 <OceanSpray> functions that inherit the scope they're declared in.
12:28:56 <sjanssen> OceanSpray: you probably want to stick with IORf
12:28:59 <SamB> OceanSpray: you want some kind of mutable cell, apparently
12:29:00 <sjanssen> IORef
12:29:16 <SamB> which you can call an Environment
12:29:26 <sjanssen> the scopes can be immutable, but the objects themselves must be mutable, right?
12:29:26 <isaacd> Standardly, "mutation" in haskell is done by a function X -> X for some type X (e.g. Environment)
12:29:35 <sjanssen> because Lisp has mutation
12:30:10 <isaacd> although real mutable references can be important AT LEAST for sensible speed, possibly clarity
12:30:22 <isaacd> depending on the circumstance
12:30:38 <SamB> isaacd: surely you can fake it without too much loss of efficiency
12:30:45 <Cale> There should be some kind of theorem that says you can do anything you can do with mutation without it at an additional logarithmic cost.
12:31:06 <SamB> Cale: logarithmic in the size of the "heap"?
12:31:15 <Cale> Yeah, I suppose :)
12:31:37 <SamB> sounds about right
12:31:38 <Cale> At least, it seems that way, given things like Data.Map/Set.
12:31:44 <OceanSpray> typedef struct {Environment *parent; Map map;} Environment;
12:31:45 <Cale> and Data.Sequence
12:31:47 <isaacd> yes
12:32:07 <SamB> I think you'd want Data.Queue or something for holding names to reuse
12:32:13 <SamB> actually
12:32:26 <SamB> that's nearly how lots of people implemented their UMs...
12:32:40 <sjanssen> OceanSpray: we'd probably write: "data Environment = Environment { parent :: Environment, map :: Map }"
12:32:49 <SamB> (not us tweaked-out 32-bit users, though ;-)
12:32:50 <Cale> Unique name supply is elegantly handled with an infinite list :)
12:33:01 <sjanssen> OceanSpray: that's not using a pointer, per se, but I don't think you really need one
12:33:11 <OceanSpray> oh yeah?
12:33:29 <SamB> Cale: but then you have to consider the log(m) size of the names
12:33:30 <sjanssen> what sort of operations do you need to support on Environment?
12:33:42 <sjanssen> OceanSpray: can an "outer" scope ever change?
12:33:54 <SamB> where m is the number of names
12:34:04 <SamB> that are ever used
12:34:09 <OceanSpray> so when I do env->parent.map.set("foo", 42); will it actually get modified in the Haskell version?
12:34:21 <Cale> SamB: does that typically become a problem?
12:34:26 <OceanSpray> yes, an "outer" scope can change.
12:34:33 <OceanSpray> see closures and whatnot.
12:34:36 <SamB> Cale: it probably depends on how long your program runs
12:34:56 <sjanssen> OceanSpray: the mapping from variable names to references can change?
12:34:59 <SamB> probably the constant factor from having arbitrary-precision names is worse, actually
12:35:10 <OceanSpray> the mapping can change, and the values can change too.
12:35:26 <OceanSpray> there's bind! and set!
12:35:35 <OceanSpray> doing different things.
12:35:36 <Cale> SamB: What do you do when you run out of names in the finitely-many-names case?
12:35:42 <sjanssen> you can use "data Environment = Environment { parent :: IORef Environment, map :: Map }" if you really want
12:35:44 <SamB> OceanSpray: you should implement DSSSL instead ;-P
12:36:01 <SamB> Cale: well generally I'd run out of RAM first
12:36:12 <sjanssen> maybe "data Environment = Environment { parent :: IORef Environment, map :: IORef Map }"
12:36:13 <SamB> I only have 512 megs of RAM and a gig of swap...
12:37:06 <SamB> Cale: see, names would go on a freelist or queue
12:37:29 <OceanSpray> sjanssen, in what you are suggesting,
12:37:56 <OceanSpray> if I have two environments, env1 and env2, both having the same parent par,
12:37:59 <Cale> SamB: Couldn't you also just push names back onto the infinite name supply stack in that case?
12:38:58 <Cale> I suppose it gives basically no direct potential for compressing that information about what names are currently free.
12:39:02 <OceanSpray> would doing the equivalent of env1->parent.map.set("a", 5); work such that env2's par 'gets' that too?
12:39:07 <Saizan> OceanSpray: if par is the same IORef then you're fine
12:39:16 <OceanSpray> oh
12:39:22 <OceanSpray> ok, that's all I needed to know.
12:39:26 <OceanSpray> thanks.
12:39:32 <sjanssen> OceanSpray: just use readIORef/writeIORef
12:39:51 <Cale> I'm extremely confused by this conversation. :)
12:39:58 <SamB> an IORef is like a pointer allocated on the heap
12:39:58 <roconnor> @bab nl en Bestens
12:39:59 <lambdabot>   Bestens
12:40:03 <SamB> Cale: I'm a bit confused myself
12:40:24 <OceanSpray> pointer allocated on the heap, eh?
12:40:29 <OceanSpray> I'm kosher, then.
12:40:29 <SamB> I just realized that you can't implement ST very well because you can't do GC...
12:40:42 <Cale> Ah, perhaps I get it :)
12:40:54 <sjanssen> SamB: that's a good point -- never thought of that before
12:41:20 <SamB> actually, an IORef *is* a pointer allocated on the heap...
12:41:29 <sjanssen> @src IORef
12:41:29 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
12:41:35 <sjanssen> @src STRfe
12:41:35 <lambdabot> Source not found. Do you think like you type?
12:41:39 <sjanssen> @src STRef
12:41:39 <lambdabot> data STRef s a = STRef (MutVar# s a)
12:41:43 <Cale> hehe
12:42:06 <SamB> I think the MutVar# is actually the pointer to the heap-allocated pointer
12:42:10 <Cale> @src MutVar#
12:42:10 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:42:25 <SamB> Cale: that's a primitive, doofus
12:42:26 <sjanssen> wired into GHC, I'm sure
12:42:34 * SamB is getting bad habbits from lambdabot 
12:42:50 <Cale> I nominate MutVar# as the name for the next MS language.
12:43:00 <SamB> hahahahahaha
12:43:03 <johnnowak> i like it
12:43:09 <SamB> what if they wanted to do a purely functional language?
12:43:36 <Cale> Oh, it would be purely functional. The MutVar is just to get people to let their guard down.
12:43:44 <SamB> hahahahahahahah
12:45:21 <SamB> @hoogle [Data.Set.Set a] -> Data.Set.Set a
12:45:58 <lambdabot> No matches, try a more general search
12:46:07 <Heffalump> @type Data.Set.unions
12:46:09 <lambdabot> forall a. (Ord a) => [Data.Set.Set a] -> Data.Set.Set a
12:46:16 <Heffalump> silly hoogle
12:46:35 <SamB> ya rly
12:47:16 <ari> @type Data.Set.intersections
12:47:18 <lambdabot> Not in scope: `Data.Set.intersections'
12:47:19 <ari> ):
12:47:28 <johnnowak> OceanSpray: is this still just a sort of experiment, or is there some deficiency you've identified that you're addressing?
12:47:44 <shachaf> @hoogle [Set a] -> Set a
12:47:45 <lambdabot> Data.Set.unionManySets :: Ord a => [Set a] -> Set a
12:47:45 <lambdabot> Data.Set.unions :: Ord a => [Set a] -> Set a
12:48:16 <Cale> @type intersection
12:48:18 <lambdabot> Not in scope: `intersection'
12:48:23 <Cale> @type Data.Set.intersection
12:48:25 <lambdabot> forall a. (Ord a) => Data.Set.Set a -> Data.Set.Set a -> Data.Set.Set a
12:48:39 <SamB> johnnowak: he's tooling up to take on pugs ;-P
12:50:24 <OceanSpray> johnnowak, what?
12:52:02 <johnnowak> SamB: ahhhh
12:52:47 <SamB> </kidding> (in the unlikely event that someone might possibly have believed me)
12:53:03 <johnnowak> don't worry, i hadn't
12:53:13 <johnnowak> and i haven't
12:54:36 <johnnowak> OceanSpray: sorry, being pulled away. nevermind the question.
12:54:43 <vincenz> Cale: check reddit :P
12:59:53 <HairyDude> heh. if you use TheOtherPrelude and work out an instance for Applicative, it turns out that return and <*> are the K and S combinators
13:00:12 <HairyDude> an instance for Applicative ((->) a) that is
13:00:56 <shachaf> HairyDude: Why do you need TheOtherPrelude?
13:00:58 <SamB> so are those going to be renamed kay and ess?
13:01:09 <HairyDude> shachaf: I don't, I'm just messing about with it
13:01:11 <shachaf> HairyDude: That would be pure, anyway.
13:01:26 <HairyDude> shachaf: it's called return in TheOtherPrelude
13:01:29 <shachaf> HairyDude: But they're already S and K in regular Control.Applicative.
13:01:37 <shachaf> HairyDude: Oh, right. That's why, I guess. :-)
13:01:45 <HairyDude> yes :)
13:03:58 <anybody> hm why is Random is System.* ? shouldn't it be top level Name?
13:04:27 <shachaf> anybody: Isn't it?
13:04:31 <shachaf> :m + Random
13:05:08 <glguy> Random is Haskell98
13:05:20 <roconnor> Good random numbers require system support.
13:05:31 <wolverian> hrm, who was it that's running haskell on a gpu? url?
13:05:55 <roconnor> preferably hardware support.
13:06:04 <HairyDude> depends what kind of random numbers you want
13:06:24 <glguy> like if you want random ones or ones that are just hard to guess?
13:06:26 <HairyDude> if you want real random numbers then hardware support is good. for pseudo-random numbers though a library is sufficient I think
13:06:43 <roconnor> pseudo random number generation could exist outside System.
13:06:43 <HairyDude> more like ones that are really random or just ones that look random
13:06:44 <SamB> if you want ones I can get you those
13:06:53 <SamB> > repeat 1
13:06:55 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:06:57 <glguy> SamB: you know a guy that knows a guy?
13:07:00 <roconnor> > repeat 9
13:07:01 <lambdabot>  [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
13:07:13 <HairyDude> SamB: reminds me of a DailyWTF...
13:07:30 <HairyDude> int random() { return 3; /* decided by a fair dice roll */ }
13:07:44 <anybody> yeah i just want pseudo random numbers for oleg's shuffle1
13:08:56 <roconnor> http://web.archive.org/web/20011027002011/http://dilbert.com/comics/dilbert/archive/images/dilbert2001182781025.gif
13:08:59 <lambdabot> http://tinyurl.com/3aav3f
13:09:41 <anybody> haha
13:12:10 <vincenz> anybody: I can give you a fully random number
13:12:13 <vincenz> 4
13:12:36 <sieni> ciphers are pretty good at generating pseudorandom bit streams: http://en.wikipedia.org/wiki/Stream_cipher
13:12:36 <shachaf> vincenz: No, 2!
13:12:37 <lambdabot> Title: Stream cipher - Wikipedia, the free encyclopedia
13:12:38 <daniel_larsson> http://xkcd.com/221/
13:12:39 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
13:12:42 <anybody> ok. cool so far i have 111... 999... 4,21
13:12:54 <anybody> need more. lots more ;-)
13:12:59 <roconnor> 21?
13:12:59 <sjanssen> 111999421 is my random number
13:13:04 <roconnor> that's not random
13:13:23 <olathe> A duck !
13:14:28 <Japsu> int random() { return 3; /* determined using dice, guaranteed to be random */ }
13:15:27 <ihope> I was going to suggest 4 as a random number, but apparently that's already been done twice.
13:15:27 <shachaf> olathe: Ducks are only pseudo-random.
13:15:29 <ihope> And 3 once.
13:15:47 <olathe> shachaf: Yes, but you totally weren't expecting it.
13:15:48 <shachaf> olathe: What happened to your 'O'?
13:16:11 <olathe> shachaf: Marketing.
13:16:21 <shachaf> olathe: What?
13:16:28 <olathe> We decided to rebrand.
13:16:40 <shachaf> olathe: Oh.
13:16:44 <shachaf> olathe: That makes sense.
13:16:50 <olathe> Of course :)
13:17:10 * shachaf used to be Shachaf, until he realized that user names start with a lower-case letter.
13:17:49 <anybody> let rand=[111,999,4,21,21,111999421,3,3]
13:18:08 <shachaf> anybody: What about 2? 2 is random!
13:18:14 <anybody> omg
13:18:17 <anybody> let rand=[111,999,4,21,21,111999421,3,3,2]
13:18:27 <HairyDude> 37 is the least random random number
13:18:39 <anybody> but still random
13:18:47 <olathe> 1 is the loneliest random number.
13:19:00 <anybody> let rand_revision0=1:37:rand
13:20:36 <anybody> omg. i got 21 twice! how unrandomly of me
13:21:08 <kilimanjaro> it doesn't even really make sense to say that a number is random
13:21:49 <shachaf> And if I was, it would be Scheme.
13:21:53 <shachaf> Oops.
13:22:40 <sjanssen> > cycle [111,999,4,21,21,111999421,3,3,2] -- an infinite stream of random numbers
13:22:41 <lambdabot>  [111,999,4,21,21,111999421,3,3,2,111,999,4,21,21,111999421,3,3,2,111,999,4,2...
13:23:22 <kilimanjaro> well I was just saying that randomness is a property of variables and sequences, numbers are constants and the term is not meaningful imho
13:23:59 <greenrd> I am writing an extensible application which uses System.Console.GetOpt to parse command line options, and I want to allow plugins to define their own command-line options
13:24:00 <anybody> oh great! just what i needed. i'm writing this poker app. thats what i need it for. so cycle will do the trick ;-)
13:24:33 <greenrd> What would be the best way to make my options data structures extensible?
13:24:43 <roconnor> kilimanjaro: you can measure randomness of a number relative to some encoding of turing machines.
13:24:56 <kilimanjaro> huh?
13:25:01 <roconnor> kilimanjaro: ie compare it to the shortest program that outputs that number.
13:25:12 <anybody> roconnor: thats its entropy right?
13:25:20 <roconnor> but the programming language is now what is relative.
13:25:34 <roconnor> anybody: yep that an entropy.
13:25:35 <kilimanjaro> algorithmic information theory
13:25:53 <roconnor> kilimanjaro: exactly.
13:26:01 <kilimanjaro> it's still not a property of numbers, it's a property of language as you mentioned
13:26:28 <roconnor> true
13:26:33 <kilimanjaro> any further and we are going to start arguing about what a number is :)
13:26:34 <hpaste>  greenrd pasted "current options data structures" at http://hpaste.org/2133
13:26:51 <proqesi`> does anybody use a mac?
13:26:57 <kilimanjaro> proqesi`, nope
13:26:59 <kilimanjaro> nobody does
13:27:04 <proqesi`> what does he use+
13:27:05 <proqesi`> ?
13:27:09 <greenrd> All of the functions and data structures on that page, I would like to be extensible by plugins
13:27:32 <anybody> proqesi`: i do
13:27:39 <proqesi`> oh, so he does  :)
13:27:40 <greenrd> maybe I should use associated data types
13:28:01 <anybody> proqesi`: why do you want to know?
13:28:02 <greenrd> but that still leaves the problem of representing a list of heterogenous options
13:28:07 <greenrd> I could use HList but that seems overkill
13:28:14 <proqesi`> sorry, couldn't help it
13:28:50 <proqesi`> ;)
13:28:59 <anybody> proqesi`: weird. you queried my irc client?
13:29:33 <proqesi`> no, it's an irc joke
13:30:14 <proqesi`> people always ask "does anybody use..."
13:30:58 <vincenz> Cale: check again ;)
13:31:01 <anybody> oh. yeah i use... ;-)
13:31:18 <SamB> does anyone know of a good SGML library?
13:31:21 <Cale> vincenz: heh, you said that about 1 second after I replied
13:31:31 <anybody> SamB: no
13:31:51 <vincenz> Cale: ah, ,you responded :)
13:35:39 <pjd> @remember Korollary You know, dons actually knows your phone number. Heâ€™ll be calling you soon to check whether you have any questions about monad transformers.
13:35:39 <lambdabot> Done.
13:36:11 <pjd> erp, i should have killed that funnyquote
13:37:10 * shapr laughs
13:37:53 <desp> @upperBound undefined :: Int
13:37:54 <lambdabot> Unknown command, try @list
13:37:59 <desp> > upperBound undefined :: Int
13:38:00 <lambdabot>   Not in scope: `upperBound'
13:38:10 <shapr> @seen desrt
13:38:10 <lambdabot> I haven't seen desrt.
13:38:11 <lament> anybody remembers stuff about the curses libraries?
13:38:13 <desp> what was the right way to check that?
13:38:18 <vincenz> @quote exist
13:38:19 <lambdabot> droundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
13:38:21 <vincenz> @quote exist
13:38:21 <lambdabot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
13:38:23 <vincenz> @quote exist
13:38:23 <lambdabot> joelr says: Fundeps, existential types, HList take a while to grasp
13:38:27 <vincenz> @quote exist.*4
13:38:27 <lambdabot> vincenz says: perhaps you assume the existence of 4?
13:38:39 <desp> @slap vincenz
13:38:40 * lambdabot slaps vincenz
13:38:51 <desp> @hoogle bound
13:38:51 <lambdabot> Network.Socket.Bound :: SocketStatus
13:38:51 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
13:38:51 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
13:39:02 <desp> @hoogle maxint
13:39:02 <lambdabot> No matches found
13:39:03 <Cale> vincenz: hehe
13:40:36 * Cale rolls a pair of dice labelled with fractions... 1/2 + 1/9 = 11/18.
13:41:40 <byorgey> > maxBound undefined :: Int
13:41:42 <lambdabot>   add an instance declaration for (Bounded (a -> Int))
13:41:42 <lambdabot>     In the expression:...
13:41:49 <sjanssen> > maxBound :: Int -- desp
13:41:51 <lambdabot>  2147483647
13:41:59 <desp> aha, thanks
13:42:06 <byorgey> @type maxBound
13:42:09 <lambdabot> forall a. (Bounded a) => a
13:42:10 <desp> sjanssen++
13:42:11 <vincenz> @slap desp
13:42:11 * lambdabot beats up desp
13:42:20 <olathe> lambdabot is such a bully.
13:42:25 <desp> ow
13:42:34 <sjanssen> @slap olathe
13:42:35 * lambdabot smacks olathe about with a large trout
13:42:43 <olathe> :(
13:42:48 <sioraiocht> @slap lambdabot
13:42:48 * lambdabot slaps lambdabot
13:42:53 <olathe> lambdabot is such a mIRC-like bully.
13:45:41 <lament> oh sheesh
13:45:54 <lament> the curses library works when the program is compiled, but not otherwise.
13:46:56 <lament> or maybe i'm just stupid
13:47:20 <eivuokko> How did you try it without compiling?
13:47:40 <glguy> @yarr
13:47:40 <lambdabot> Well Ahoy! thar.
13:49:45 <RyanT5000> where's a good category-theoretic explanation of haskell typeclasses?
13:50:20 <RyanT5000> i'm trying to learn category theory and i want to map my knowledge of haskell onto it
13:52:57 <byorgey> type classes have to do with category theory?
13:53:18 <RyanT5000> byorgey: at least some of them do
13:53:20 <byorgey> I guess I wouldn't be surprised, but I've never seen a connection explained explicitly
13:53:27 <DRMacIver> Everything has to do with category theory if you abuse it enough.
13:53:38 <RyanT5000> DRMacIver: i'm looking for exactly that :P
13:53:47 <sioraiocht> DRMacIver: abuse everything or abuse category theory =p
13:53:48 <byorgey> RyanT5000: I assume you've looked at the page on CT on the haskell wiki?
13:53:57 <DRMacIver> sioraiocht: Yes. :)
13:54:04 <sioraiocht> lol
13:54:40 <byorgey> RyanT5000: sorry, I meant the wikibook
13:54:56 <RyanT5000> byorgey: no, i haven't looked at the wikibook
13:55:13 <byorgey> http://en.wikibooks.org/wiki/Haskell/Category_theory
13:55:15 <lambdabot> Title: Haskell/Category theory - Wikibooks, collection of open-content textbooks
13:55:23 <byorgey> it's really a very well-written page, IMO
13:55:32 <RyanT5000> byorgey: thanks :)
13:56:18 <byorgey> it explains what the Functor and Monad type classes have to do with CT, which is maybe what you're looking for
13:56:45 <RyanT5000> maybe
13:57:17 <RyanT5000> i'm trying to figure out if there are more uses for CT in software engineering
14:17:57 <byorgey> so, you know how in papers expressing formal typing rules, there's that notation where several predicates are above a horizontal line, and then there's a conclusion underneath the line?  does that notation have a name?
14:18:11 * xerox hands Cale a copy of ``MutVar# for Dummies.''
14:18:42 <Cale> byorgey: A proof tree.
14:19:43 <byorgey> Cale: thanks.  that's not what I would have guessed. =)
14:20:05 <Cale> byorgey: in general, there's more than one horizontal line
14:21:04 <byorgey> Cale: hm, I believe you but I've never seen more than one
14:22:04 <byorgey> most recently I saw the notation in SPJ + Wadler's paper on adding order by and group by to list comprehensions
14:22:14 <Cale> http://www.cs.chalmers.se/~aarne/GF2.0/Tutorial/evo-tex.gif
14:22:21 <Cale> Something like that
14:22:55 <byorgey> ah, I see
14:24:19 <|Winterstream|> Hi everyone
14:24:38 <Vulpyne> Hi.
14:24:39 <Cale> hello
14:24:55 <Vulpyne> I just used my first monad transformer. Woot.
14:25:31 <Cale> cool :)
14:25:44 <Winterstream> I'm trying to do a foreign import (stolen from Darcs' code), but GHC tells me there's syntax error in my "foreign import":
14:26:02 <Winterstream> foreign import ccall unsafe "static low_level.h my_mmap" my_mmap
14:26:03 <Winterstream>     :: CInt -> CInt -> IO (Ptr Word8)
14:26:11 <Cale> Winterstream: Are you using -fffi ?
14:26:25 * byorgey presents Vulpyne with a shiny CertificateT!
14:26:26 <Winterstream> Errr. Heh. No.
14:26:37 <Winterstream> So with Cabal, will I add that to ghc-options ?
14:26:38 * Vulpyne cheers at byorgey!
14:26:59 <Cale> yeah
14:27:45 <Winterstream> muchos gracias Cale
14:27:46 <Winterstream> Cale++
14:27:59 <Cale> No problem :)
14:29:32 <eivuokko> Winterstream, better use extensions-field with value ForeignFunctionInterface, or possibly {-# LANGUAGE ForeignFunctionInterface #-}
14:29:48 <SamB> eivuokko: the former
14:29:51 <SamB> I think
14:29:52 <eivuokko> (Pragma on first line of the single/only few files that ned the extension
14:30:09 <SamB> that extension is not exactly what you call invasive...
14:30:09 <glguy> @seen dons
14:30:10 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 9h 3m 52s ago.
14:30:14 <Winterstream> eivuokko: "extensions-field" in the cabal file?
14:30:16 <eivuokko> SamB, Both are allowed and advertised by Cabal User Manual.
14:30:27 <SamB> eivuokko: well, okay, then both ;-P
14:30:30 <Winterstream> (I know very little about Cabal)
14:30:43 <SamB> using both is the best bet for future compatibility
14:30:55 <SamB> once they figure out how this is supposed to work
14:30:57 <eivuokko> Winterstream, instead of adding -fffi to ghc-options, add a new line with extensions: ForingFunctionIntrfac
14:31:19 <SamB> only spelled a good deal better than that
14:31:25 <Winterstream> Ah. Ok. Thanks. And also {-# LANGUAGE ForeignFunctionInterface #-} to the top of the source file defining it then?
14:31:36 <eivuokko> Hehe, yeah.
14:31:50 <SamB> Winterstream: it's a good idea, yeah
14:31:52 <eivuokko> My laptop's keyboard is kinda broken -.-
14:32:11 <Saizan> ?where c2hs
14:32:11 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
14:32:19 <SamB> oh, and a tip for when you tried the obvious name for an extension
14:32:22 <eivuokko> Winterstream, One should be enough.  Just use the one you think is nicer.
14:32:23 <SamB> but it didn't work
14:32:38 <Winterstream> Thanks to both of you :)
14:32:41 <Winterstream> SamB++
14:32:47 <Winterstream> eivuokko++
14:32:51 <SamB> type ":b Language.Haskell.Extension" at a GHCi prompt
14:33:12 <SamB> that will give you the whole list of extension names
14:33:24 <Winterstream> Cool. I see.
14:33:45 <eivuokko> Hehe, SamB was faster...online docs for the same thing... http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html#t:Extension for extension flags.
14:33:47 <lambdabot> http://tinyurl.com/2xjyqs
14:33:57 * Winterstream realized today that he spends far too much time talking about programming and not actually just programming. He was wasting away time on Reddit.
14:34:06 <SamB> I realized this after I got tired of googling for the part of the GHC manual where it talks about {-# LANGUAGE #-}, just to follow a link to the haddock documentation for that module...
14:34:41 <SamB> when all I really wanted to know was "which words did they arbitrary abbreviate THIS time?"
14:34:57 <Winterstream> One thing bugs me...
14:35:18 <SamB> yeah?
14:35:27 <Cale> I wonder if I'm actually more productive in some sense just talking about programming than actually doing it. :)
14:35:34 <Winterstream> A quick look on Slashdot/Reddit/etc... shows that some people think of Haskell as an academic language...
14:35:37 <sorear> You don't have the GHC manual bookmarked? :)
14:35:41 <SamB> Cale: not on reddit you aren't
14:35:43 <sorear> It is.
14:36:06 <Cale> heh, whatever key combination I hit there, it was not the right one :)
14:36:09 <sjanssen> sorear: not bookmarked, memorized ;)
14:36:11 <SamB> Cale: not on reddit you aren't
14:36:20 <Cale> SamB: yeah, not on reddit
14:36:28 <SamB> sorear: I keep trying to google the right section
14:36:29 <Cale> SamB: I spend way more time talking here :)
14:36:30 <Winterstream> Well, when someone says that, I normally interpret it as being an indirect way of saying: "Haskell is useless for doing actual work"
14:36:33 <SamB> it rarely works too well
14:36:55 <SamB> Winterstream: well, it sounds better if you say "Haskell is a research language"
14:36:58 <SamB> imo
14:37:26 <Vulpyne> What about the word "magic"?
14:37:36 <jonasb> hi all, I've read and heard a bit about haskell and would like to get my hands dirty, so to speak.  but I have problems coming up with small programs to write.  does anyone have any tips?
14:38:00 <Winterstream> SamB: That does sound better, but I know people who equate "research" with "useless" or at least "not realistic" or "not pragmatic"
14:38:09 <SamB> jonasb: what sort of program are you interested in?
14:38:23 <SamB> jonasb: what do you enjoy?
14:38:25 <Vulpyne> jonasb: Have you written small utility programs in other languages? Try rewriting them in Haskell.
14:38:43 <SamB> Winterstream: show them SPJ's graph
14:38:52 <Vulpyne> What's worked well for me is taking small programming projects my boss gives me and writing them in Haskell. :)
14:39:00 <Winterstream> SamB: And I'd sooner use Haskell than Python. I'm sure GHC binaries outrun Python code, so there can't be too many complaints about speed.
14:39:11 <Winterstream> SamB: The "Nirvana" chart?
14:39:14 <kuribas> jonasb: You can also try one of the ruby quizes.  http://www.rubyquiz.com/
14:39:15 <lambdabot> Title: Ruby Quiz
14:39:18 <SamB> Winterstream: not that one
14:39:26 <Winterstream> SamB: Hehe. I thought so.
14:39:28 <SamB> the user count graph
14:39:32 <Winterstream> Ah
14:39:33 <Winterstream> Yes
14:39:39 <Winterstream> I saw that just the other day.
14:39:47 <SamB> though the nirvana one might be good too...
14:40:10 <jonasb> Vulpyne: most of the scripts I write (in other languages) are heavy on I/O, so it seems not like really good fit for entry-level haskell
14:40:57 <shachaf> jonasb: How heavy? Do you have examples?
14:41:20 <Vulpyne> jonasb: The first real program I wrote in Haskell used pcap and db access, so...
14:41:24 <Winterstream> Sorry if the following question sounds daft...
14:42:05 <jonasb> SamB: i guess mathematical problems fit pretty well with haskell and small programs
14:42:14 <SamB> jonasb: I asked what you like
14:42:37 <SamB> not what you think Haskell would fit well with
14:42:42 <Winterstream> Ignoring other types of IO in Erlang for the moment, if we just concentrate on message sending and receiving, it seems to me as if one is implicitly using a Monad there.
14:42:53 <jonasb> kuribas: ah, that might be a good idea... are there any quiz type problems specifically targetted for haskell?
14:44:26 <kuribas> jonasb: Not really, but haskell is a good language for most of them.
14:45:00 <Cale> Winterstream: In some sense, most effects in programming languages are explicable that way.
14:45:17 <kuribas> See also http://www.haskell.org/haskellwiki/Haskell_Quiz
14:45:18 <lambdabot> Title: Haskell Quiz - HaskellWiki
14:45:42 <jonasb> SamB: you got me there :-) i wouldn't mind doing some mathematical programming since it's something i rarely do
14:46:35 <drguildo> is it just me or is haskell emacs mode indenting a bit broken?
14:46:46 <SamB> drguildo: ... it is certainly not just you
14:46:56 <SamB> but I'm not sure if "a bit" is the right way to put it
14:47:03 <Cale> drguildo: I tended to turn it off and just use the 'simple' indent mode.
14:47:08 <drguildo> well that's some small comfort
14:47:55 <jonasb> SamB: but right now i'm just looking forward to learn a bit of haskell, the problems doesn't really matter
14:47:56 <drguildo> Cale: how do you do that?
14:48:02 <drguildo> i am new to both haskell and emacs
14:48:25 <Cale> (add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
14:48:32 <Cale> rather than (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
14:48:34 <drguildo> thank you
14:48:37 <SamB> jonasb: implement a simple programming language or something ;-)
14:49:01 <glguy> heh, that's less of a sarcastic suggestion that he might think ;)
14:49:12 <DRMacIver> It seems sortof a shame that that's the default learning Haskell task.
14:49:19 <kuribas> Cale: I am writing a new indentation engine.
14:49:21 <jonasb> SamB: ok, will do :-)
14:49:22 <ddarius> DRMacIver: Not really.
14:49:24 <DRMacIver> (I say that despite repeatedly meaning to get round to doing it. :) )
14:49:37 <SamB> DRMacIver: it's not a shame
14:49:42 <DRMacIver> ddarius: To which part?
14:49:45 <Cale> kuribas: awesome :)
14:49:46 <Vulpyne> BF interpreter!
14:49:59 <SamB> it's because that's where Haskell shines, I'm pretty sure...
14:50:10 <DRMacIver> SamB: Yeah, I know.
14:50:18 <ddarius> DRMacIver: To implementing a language being "the" default learning Haskell task (assuming that is what you were referring to).
14:50:29 <drguildo> hrmm
14:50:35 <drguildo> emacs is still indenting everything wrongly
14:50:38 <DRMacIver> ddarius: Ok. It's a prevalent default, if not a canonical one. :)
14:50:45 <kuribas> Would a good indentation engine give a parse error, or ignore errors?  (like layout errors).
14:50:50 <ddarius> DRMacIver: It's not a shame.
14:50:53 <SamB> jonasb: there is also implementing lambdabot plugins
14:51:10 <ddarius> This is how lambdabot got to be so buggy.
14:51:19 <DRMacIver> ok. In the interests of I'm way too tired to discuss this right now, I'll bow to the majority vote. :)
14:51:21 <SamB> ddarius: hmm?
14:51:24 <Cale> kuribas: For an editor?
14:51:31 <kuribas> yes
14:51:33 * ddarius is mostly joking.
14:51:40 <SamB> plugins are self-contained
14:51:47 <SamB> they don't magically add bugs everywhere else
14:52:07 <drguildo> the first line is indented 2 columns
14:52:14 <drguildo> the second by 11
14:52:21 <drguildo> third 19
14:52:23 <drguildo> etc
14:52:29 <Cale> kuribas: You want the thing to be tolerant of syntax errors because quite often when you're editing, you haven't finished making the thing syntactically correct yet :)
14:52:33 <ddarius> SamB: They don't need to if most of the code is plugins and most of the plugins were written by beginning Haskell programmers.
14:52:45 <drguildo> this is with simple mode supposedly enabled
14:52:54 <s1mxn> LOS METALLER JOINT HÃ–RT ZU UND GEHT FLIEGEN DEN (/!\) #pure-metal /!\ mit [P-M]Mentario /!\ Late Night Show /!\ ist online /!\ (/!\ StreamFile @ www.pure-metal.de oda http://www.metal.host-tech.de/portal/getstream1.php?stream=1 [noSry4amsg]
14:52:59 * ddarius remembers being somewhat awed by programming language implementations near the beginning of learning to program.
14:53:08 <Cale> drguildo: Tab will align with notable things in the line above.
14:53:45 <drguildo> so i need to keep hitting it?
14:53:53 <quicksilver> there is more than one legal indentation of a new line
14:53:58 <quicksilver> emacs can't guess what you mean
14:54:04 <quicksilver> it can just show you the alternatives
14:54:13 <drguildo> ok, i didn't realise that
14:54:33 <quicksilver> the different indentations may mean different things :)
14:54:51 <quicksilver> putStrLn "foo"
14:54:54 <drguildo> i guess i'll learn that later on
14:54:59 <Cale> In the simple mode, it won't cycle, it'll just find the next notable thing to align with and when it runs out, it'll indent by some fixed amount.
14:54:59 <quicksilver> forkIO $ do putStrLn "blah"
14:55:01 <dolio> Bulat seems angry lately. :)
14:55:12 <quicksilver> ah, I didn't know that
14:55:19 <quicksilver> I don't think I recommend that mode then :)
14:55:29 <Cale> I do :)
14:56:09 <Cale> It actually has understandable semantics, whereas the other one, I never have any idea where it'll tab to, and it usually never had the indentation I wanted.
14:56:10 * ddarius prefers vim not trying too hard to indent my code.  ai is good enough for me.
14:56:11 <drguildo> i don't understand why it chooses the outer most notable element to align with first though
14:56:34 <Cale> It just does them from left to right
14:56:44 <drguildo> not for me
14:56:45 <ddarius> retarded
14:56:51 <kuribas> Cale: In my mode Backspace will find the indentation to the left, and tab to the right.
14:57:23 <Cale> I normally just use vim. ;)
14:57:45 <Cale> So maybe it's changed since I last used emacs.
14:58:02 <desp> time ./ProjectEulerProblemsInHaskell [p1..p23 - p14, p67] == real    0m13.633s
14:58:17 <desp> still don't have a quick Haskell p14
14:58:22 <desp> garg
14:58:35 <Cale> Which one is p14?
14:58:36 <hpaste>  isaacd pasted "rem by 0x40000000" at http://hpaste.org/2135
14:58:48 <desp> Cale: collatz sequences
14:58:48 <isaacd> that is a testcase.
14:59:13 <dolio> I appear to have 14. I don't remember how fast it is, though.
14:59:20 <desp> Cale: it's simple, but for some reason, I'm unable to write fast Haskell code for it
14:59:20 <isaacd> "eival" has the wrong value when the module is compiled with ghc -O -fvia-C.
14:59:24 <Cale> desp: Ah, that one would really be helped by lots of memoisation.
14:59:26 <desp> glguy showed me his, though
14:59:26 <SamB> desp: mine isn't fast either
14:59:36 <glguy> mine ran in < 3 seconds
14:59:41 <glguy> i don't know if that is "fast"
14:59:43 <glguy> on a 1.8ghz
14:59:43 <SamB> then again I didn't try to get mine fast
14:59:48 <SamB> glguy: of course it is
14:59:52 <desp> it is, although my C is < 1 s
15:00:16 <dolio> What's the input value?
15:01:12 <Cale> What's the actual problem spec? Something like finding the longest Collatz chain for initial values less than 10^6?
15:01:13 <isaacd> I guess I'll put it in GHC's Trac, in case GHC can fix it
15:01:31 <desp> Cale: yep
15:02:11 <dolio> Ah, yeah. Mine is definitely not fast.
15:02:48 <dolio> 1 minute 2 seconds.
15:04:11 <Winterstream> Does Cabal know how to compile C files?
15:04:25 <anybody> @pastebin
15:04:25 <lambdabot> Unknown command, try @list
15:04:33 <anybody> @paste
15:04:34 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:04:37 <desp> @pl isAbundant n = factorSum n > 2 * n
15:04:38 <lambdabot> isAbundant = liftM2 (>) factorSum (2 *)
15:04:55 <drguildo> thanks for your help
15:05:12 <Winterstream> I have "C-Sources:      Ipc/low_level.c" in my .cabal file
15:05:18 <Winterstream> But it doesn't seem to help
15:05:38 <SamB> desp: hmm, that one crashes GHCi consistently here
15:05:38 <hpaste>  anybody pasted "i don't know" at http://hpaste.org/2136
15:05:40 <desp> I don't think that pl works
15:05:49 <desp> SamB: what does?
15:05:55 <SamB> problem 23
15:05:59 <anybody> has anybody an idea why this does not compile? http://hpaste.org/2136
15:06:08 <shachaf> desp: Why not?
15:06:30 <desp> > let f = Monad.liftM2 (>) id (2 *)
15:06:31 <lambdabot>  Parse error
15:06:40 <desp> @let f = Monad.liftM2 (>) id (2 *)
15:06:41 <lambdabot> <local>:4:4: Not in scope: `Monad.liftM2'
15:06:47 <desp> @let f = liftM2 (>) id (2 *)
15:06:52 <lambdabot> Defined.
15:06:56 <desp> hrm
15:07:02 <desp> my ghci refuses to do so
15:07:09 <shachaf> anybody: You can't have let in where.
15:07:11 <desp> SamB: I'm posting my p23 on the forum
15:07:30 <desp>     No instance for (Monad ((->) a))
15:07:30 <anybody> shachaf: oh. and where in let ?
15:07:31 <desp>       arising from use of `Control.Monad.liftM2' at <interactive>:1:8-32
15:07:32 <shachaf> desp: Control.Monad.Instances?
15:07:43 <SamB> desp: what is up with their SQL server?
15:07:55 <desp> SamB: it does appear to be overloaded
15:07:59 <shachaf> anybody: Just get rid of the let and in, and it should work, I think.
15:08:05 <desp> shachaf: pardon?
15:08:18 <shachaf> desp: You need the (r ->) Monad instance.
15:08:38 <shachaf> desp: For liftM2 to work.
15:08:43 <anybody> shachaf: oh. cool compiles now. thx
15:09:01 <Winterstream> Man, I am sometimes brain damaged
15:09:21 <desp> SamB: http://projecteuler.net/index.php?section=forum&id=23&new=true#last
15:09:24 <lambdabot> Title: Forum 23 - Project Euler, http://tinyurl.com/2xghv4
15:10:19 <SamB> desp: hmm, I probably should have used IntSet too...
15:10:36 <desp> switching from Integer to Int made a large difference
15:10:46 <desp> there are 6 million sums considered
15:10:59 <SamB> hmm.
15:11:44 <desp> I would appreciate it if someone could offer any ideas how to rewrite this to use only one factorization function
15:12:12 <hpaste>  desp pasted "Prime.hs" at http://hpaste.org/2137
15:13:38 <isaacd> okay, ghc trac#1603
15:13:45 <hpaste>  SamB annotated "Prime.hs" with "EulerLib.hs -- not to great but I don't have to factor functions" at http://hpaste.org/2137#a1
15:14:20 <desp> hmm, nubBy
15:14:37 <desp> didn't use that one yet.
15:14:38 <desp> :)
15:15:09 <SamB> desp: it's the simplest prime-finding algorithm ever, with probably close to the most inefficient implementation
15:15:24 <desp> the algorithm is the same in my case
15:15:29 <SamB> is it?
15:15:44 <desp> almost, I stop at sqrt(n) instead of n
15:15:47 <SamB> oh, I think I'm probably abusing nubBy
15:16:22 <desp> I tried implementing the *real* sieve of Erastothenes
15:16:32 <SamB> real?
15:16:33 <desp> but there's probably a space leak in it
15:16:48 <desp> @google real sieve erastothenes haskell paper
15:16:49 <SamB> I actually implemented the Sieve of Atkin
15:16:49 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2007-February/022666.html
15:16:49 <lambdabot> Title: [Haskell-cafe] Re: Genuine Eratosthenes sieve [Was: Optimization fun]
15:17:10 <xerox> > fix (\ps -> 2 : 3 : [ n | n <- [5,7..], all (\p->mod n p/=0) (takeWhile (\p->p*p<=n) ps)]
15:17:11 <lambdabot>  Parse error
15:17:16 <xerox> > fix (\ps -> 2 : 3 : [ n | n <- [5,7..], all (\p->mod n p/=0) (takeWhile (\p->p*p<=n) ps)])
15:17:21 <isaacd> meanwhile, yes, I'm using -fasm
15:17:25 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:17:38 <desp> yes, xerox, thank you
15:17:39 <desp> ;p
15:18:26 <desp> SamB: the algorithm described in the paper is much more efficient, asymptotically
15:18:52 <hpaste>  desp pasted "Prime.hs" at http://hpaste.org/2138
15:19:05 <hpaste>  desp annotated "Prime.hs" with "PQueue.hs" at http://hpaste.org/2138#a1
15:19:30 <desp> that's the implementation from the paper
15:19:34 <SamB> desp: but anyway I don't think that many of my primes are ever demanded...
15:19:46 <desp> SamB: they are, in p10
15:19:58 <SamB> I meant for factoring
15:20:09 <SamB> I use the sieve of atkin for that one
15:20:15 <desp> oh.
15:20:24 <desp> do you mind sharing the implementation?
15:20:31 <SamB> because I was under the misaprehension that I was already using the sieve of what's-his-name-beginning-with-E
15:20:58 <desp> :)
15:21:18 <desp> because the code I just pastes has a space leak somewhere, and is actually unsuitable for p10
15:21:34 <hpaste>  SamB annotated "Prime.hs" with "SieveOfAtkin.hs" at http://hpaste.org/2137#a2
15:21:50 <desp> thanks
15:22:07 <SamB> here's my solution to problem 10:
15:22:11 <SamB> main = print (sum (sieveOfAtkin 999999))
15:22:22 * shapr yarghs
15:22:31 <desp> yes, that's the easy bit ;)
15:23:05 <anybody> hm why is it not possible to convert Int to Integer?
15:23:28 <SamB> hmm. it takes 13 seconds :-(
15:23:29 <desp> anybody: fromIntegral
15:23:37 <ddarius> > fromIntegral (3 :: Int) :: Integer
15:23:38 <Winterstream> I'm getting an undefined reference linker error and I can't figure it out. Could someone please have a look at http://hpaste.org/2139
15:23:39 <lambdabot>  3
15:23:41 <desp> SamB: no way
15:23:49 <SamB> desp: is that good?
15:23:53 <ddarius> anybody: There are no implicit conversions in Haskell.
15:23:56 <desp> nope
15:23:58 <desp> let me run it here
15:24:14 <SamB> well I guess I was just happy that it worked ;-)
15:24:17 <anybody> desp: is there a more general integer than Integer?
15:24:18 <xerox> desp - yuck, it needs an insane amount of memory.
15:24:30 <desp> xerox: I said, space leak :)
15:24:30 <ddarius> anybody: That doesn't make much sense.
15:24:42 <desp> anybody: Integer is the bigint you probably want
15:24:43 <ddarius> anybody: But Integer is an arbitrary precision integer value.
15:24:46 <isaacd> SamB: eratosthenes?
15:24:51 <Winterstream> (I'm  trying to link in foreign code)
15:25:00 <SamB> isaacd: sounds right
15:25:34 <anybody> ddarius: actually i just wanted to have a type that would be an arbitrary integer. either Int or Integer so that i don't have to explicitely make conversions
15:27:03 <SamB> anybody: Integer can store all integers (well, that can fit in your RAM anyway)
15:27:25 <mathias> Is there a function that generalizes the composition operator?
15:27:38 <sjanssen> mathias: >>> ?
15:27:59 <mathias> The generalization is in the number of arguments its right argument takes.
15:28:01 <desp> anybody: (Integral a) => a
15:28:30 <desp> @let n `choose` k = (fac n) `div` (fac k * fac (n - k))
15:28:31 <lambdabot> <local>:5:16: Not in scope: `fac'  <local>:5:30: Not in scope: `fac'  <local>...
15:28:31 <anybody> SamB: oh. thx. exactly what i'm looking for
15:28:41 <desp> @let fac n = product [1..n]
15:28:42 <lambdabot> Defined.
15:28:43 <desp> @type fac
15:28:44 <lambdabot> Not in scope: `fac'
15:28:50 <desp> ugh
15:29:14 <Cale> mathias: (.) . (.)
15:29:27 <Cale> mathias: or in general (.) composed with itself k times.
15:29:49 <hpaste>  (anonymous) annotated "undefined reference with foreign code" with "(no title)" at http://hpaste.org/2139#a1
15:29:51 <mathias> Cale, that was the generalisation for n = 2?
15:29:56 <Cale> yeah
15:30:03 <Cale> :t (.) . (.)
15:30:05 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:30:10 <Cale> :t (.) . (.) . (.)
15:30:12 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
15:30:20 <desp> SamB: well, your SieveOfAtkin runs in 3.1s, while my naive factor-based primes runs in 5.2s
15:30:31 <xerox> SamB: sieveOfAtkins up to the millionth prime stack overflows, sigh :)
15:30:52 <desp> xerox: does it really now?
15:31:26 <desp> xerox: in ghci?
15:31:27 <desp> \
15:31:58 <xerox> yes, let's see compiled.
15:32:08 <desp> compiled works fine.
15:32:20 <xerox> Stack space overflow: current size 8388608 bytes.
15:32:32 <desp> I think you're doing it wrong.
15:32:37 <desp> ;p
15:33:05 <hpaste>  Winterstream annotated "undefined reference with foreign code" with "(no title)" at http://hpaste.org/2139#a2
15:33:13 <Winterstream> errr
15:33:13 <xerox> desp: and what does it print for you, as millionth prime?
15:33:15 <Winterstream> sorry
15:33:29 <Winterstream> Didn't mean for that announcement
15:34:12 <anybody> i have data Tree a b = Leaf a | Node b (Tree a) (Tree a). can i enforce that b should be (Integral b=>b) ?
15:34:21 <mathias> Cale,  ((liftM f) . ) . g !=  (liftM f) ((.) (.) (.)) g
15:34:25 <xerox> anybody: in your functions, yes.
15:34:51 <desp> xerox: Prelude Euler.SieveOfAtkin> head . reverse . sieveOfAtkin $ 1000000
15:34:51 <desp> 999983
15:34:52 <xerox> mathias: ((liftM f) .) . g) = liftM f :. g where :. = (.) . (.)
15:34:54 <Winterstream> If someone could please have a look at that paste and tell me why the foreign code function cannot be found, I'd be eternally grateful :)
15:34:55 <anybody> so Node (Integral b=>b) (Tree a) (Tree a) is not valid?
15:35:05 <xerox> desp: that's not the millionth prime, that's the last prime less than one million
15:35:19 <desp> ahh, pardon.
15:35:52 <mathias> xerox, ok, I see I was wrong.
15:35:55 <Cale> anybody: You can write  data (Integral b) => Tree a b = Leaf a | Node b (Tree a) (Tree a)
15:36:07 <Cale> anybody: But it doesn't quite mean what you want it to mean, I bet.
15:37:05 <Cale> It simply restricts the type of the Node constructor, and doesn't carry a proof that b is of Integral type along with the data.
15:37:21 <Cale> So you still need Integral constraints on the functions which use Trees.
15:37:23 <mathias> xerox, is :. valid Haskell?
15:37:27 <xerox> mathias: yes.
15:37:28 <anybody> oh.
15:37:36 <Cale> :. would be an infix data constructor
15:37:36 <anybody> and how would i make those constraints?
15:37:57 <xerox> mathias: it's nice because you can count the dots in the bottom line and make :. = (.) . (.); :.. = (.) . (.) . (.) ...
15:37:57 <Cale> sumTree :: (Integral b) => Tree a b => b
15:38:12 <Cale> sumTree (Leaf x) = 0
15:38:20 <anybody> ah k
15:38:28 <xerox> Hmm. Maybe it was .: ..:
15:38:35 <Cale> sumTree (Node u l r) = u + sumTree l + sumTree r
15:38:47 <mathias> xerox, why doesn't the following work? (:.) = (.) . (.)
15:38:57 <xerox> desp: aha! 15485863 real    5m42.194s user    5m41.065s sys     0m0.340s
15:39:06 <Cale> mathias: Because the initial : is like a capital letter.
15:39:10 <xerox> mathias: try (.:), (..:), (...:)
15:39:31 <xerox> I clearly remember ski using something like that.
15:39:37 <mathias> xerox, so, it wasn't valid Haskell?
15:39:56 <byorgey> I've used .:, :. doesn't work.
15:40:04 <Cale> mathias: Yeah, he just had the symbol backwards -- infix things which start with colon are data constructors.
15:40:43 <mathias> Cale, that's how it was specified in the Haskell 98 standard.
15:41:09 <xerox> > let (.:) = (.) . (.) in ((+1) .: (*)) 2 3
15:41:10 <lambdabot>  7
15:41:55 <SamB> desp: so do you see any obvious improvements to be made?
15:42:15 <mathias> Can one also write one function that means . .: .:. .:: etc?
15:42:20 <desp> to the sieve of atkin? no, in fact, I don't know the pragmas you used
15:42:29 <xerox> mathias: I think so.
15:42:37 <SamB> desp: pragmas?
15:42:38 <xerox> mathias: I think I've written it actually.
15:42:38 <mathias> It would seem that a type class can do that.
15:42:43 * SamB used -O2
15:42:48 <desp> {-# SCC "STpart" #-}
15:42:51 <desp> etc
15:42:52 <SamB> oh, that.
15:42:54 <desp> what's that?
15:42:55 <SamB> that was for profiling
15:43:01 <SamB> it doesn't do anything without -prof
15:43:05 <desp> oh.
15:43:16 <SamB> stands for "Source Cost Center"
15:43:23 <Winterstream> Cheers everyone
15:43:24 <SamB> iirc
15:46:36 <cdsmith> hello everyone.
15:47:43 <every_one> hey cdsmith
15:47:50 <cdsmith> :)
15:48:51 <mathias> class Compose a  where
15:48:51 <mathias>  compose:: a
15:48:51 <mathias> instance Compose ((b -> c) -> (a -> b) -> a -> c) where
15:48:51 <mathias>  compose = (.)
15:48:51 <mathias> instance Compose ((b -> c) -> (a -> a1 -> b) -> a -> a1 -> c) where
15:48:51 <mathias>  compose = (.) . (.)
15:48:57 <cdsmith> And the #1 bad idea of all time is... renting a car in the UK when going there for AngloHaskell.
15:48:58 <mathias> xerox, you mean like that?
15:50:01 <xerox> mathias: well, that works, but I think we can do better.
15:50:05 * xerox ponders.
15:50:15 <mathias> xerox, yes, I think so too.
15:50:18 <yaxu> cdsmith: why's that?
15:50:24 <mathias> xerox, it can be defined with two instances, I guess
15:50:29 <mathias> xerox, (for all n)
15:51:10 <augustss> renting a car?
15:51:14 <cdsmith> yaxu: it's been a trying experience.  I've been lost all day.  Would've been easier to figure out the public transportation.
15:52:48 <augustss> :)
15:53:01 <augustss> or rent a bike
15:53:17 <cdsmith> augustss: a bike from London to Cambridge?
15:53:35 <yaxu> it's doable
15:53:39 <augustss> ummm, a tad long
15:53:54 <mathias> xerox, are you trying to write it now?
15:53:55 <pejo> Tour de UK.
15:54:04 <yaxu> along the lee valley canal
15:54:08 <xerox> mathias: yes.
15:54:10 <conal> mathias: if you like playing with compositions of (.), try throwing in 'first' and 'second' also.  and see http://haskell.org/haskellwiki/DeepArrow.  It's a basis for Eros (http://conal.net/papers/Eros)
15:54:11 <lambdabot> Title: DeepArrow - HaskellWiki
15:55:16 <cdsmith> I saw the Microsoft Research building today.  Almost got in a wreck because I turned into the right side of the road.  Hope it wasn't Simon in the other car. :)
15:55:19 <yaxu> or you could take a bike on a train :)
15:55:25 <mathias> conal, http://haskell.org/haskellwiki/DeepArrow#Examples contains dead links
15:55:26 <lambdabot> Title: DeepArrow - HaskellWiki
15:55:42 <conal> mathias: oops -- which links?
15:56:03 <mathias> conal,  nd source code in the library documentation.
15:56:05 <byorgey> cdsmith: heh
15:56:25 <conal> mathias: thanks.  fixing ...
15:56:25 <byorgey> cdsmith: it's easy when you're just driving down the road, but as soon as you make a turn or get flustered...
15:57:53 <conal> mathias: fixed
15:59:37 <sfultong> anyone know of a very simple example of haskell network programming?
15:59:51 <conal> mathias: btw, DeepArrow uses the name "result" as the generalization of (.) to (deep) arrows.
16:00:02 <Cale> sfultong: iirc, dons has a tutorial where you write a small IRC bot :)
16:00:34 <Cale> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
16:00:35 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
16:00:48 <sfultong> ah, thanks
16:00:57 <sfultong> Cale to the rescue once again
16:01:03 <Cale> :)
16:01:06 <conal> does anyone here use the haddock version that understands all ghc's accepted syntax?
16:04:52 <desp> -fno-warn-type-defaults FTW
16:05:12 <MarcWeber> dcoutts: When running gtk with the nix build gtk2hs I'm getting this error:
16:05:17 <MarcWeber> Loading package gtk-0.9.12 ... ghc-6.6.1: can't load .so/.DLL for: gthread-2.0 (libgthread-2.0.so: cannot open shared object file: No such file or directory)
16:06:16 <MarcWeber> Is gthread in any way special compared to glib or cairo?
16:06:23 <mathias> xerox, progressing? I find it quite hard.
16:06:29 <Cale> desp, SamB: Wow, this Collatz thing is extremely sensitive to the size of the memo table. I seem to get best results with a memo table somewhere around half the size of the searched range.
16:06:33 <xerox> mathias: yes
16:06:33 <hpaste>  loz pasted "non-idiomatic readList?" at http://hpaste.org/2140
16:07:37 <desp> Cale: I sure'll be interested to see your code, once you're done
16:07:59 <desp> cleaning up my primes a bit now :)
16:08:07 <Cale> My code runs in about the same time as SamB's (3 seconds or so)
16:10:41 <desp> SamB: ping
16:11:41 <hpaste>  Cale pasted "the fairly obvious memoising solution" at http://hpaste.org/2141
16:11:49 <SamB> Cale: what?
16:11:59 <Cale> SamB: what?
16:12:08 <SamB> my code for problem10 doesn't run in 3 seconds
16:12:14 <Cale> SamB: problem 10?
16:12:15 <SamB> er.
16:12:20 <SamB> not that one
16:12:21 <desp> Cale's talking about p14
16:12:24 <SamB> the collatz one
16:12:28 * SamB got confused
16:12:54 <desp> SamB, why are you doing fromList/toList in allFactors?
16:13:12 <Cale> er, heh
16:13:18 <Cale> putStrLn . unwords $ ["Memo table size: " ++ show memoBound]
16:13:18 <SamB> desp: it's related to powerset
16:13:20 <Cale> haha
16:13:33 <desp> SamB: I can't get powerset to generate duplicates
16:13:41 <SamB> desp: can't you?
16:13:48 <Cale> somehow I managed to forget that I was in an unwords :)
16:14:05 <Cale> putStrLn ("Memo table size: " ++ show memoBound)
16:14:08 <Cale> there we go :)
16:14:23 <mathias> Why doesn't this work? data Zero; data Succ a; predecessor x = undefined::a   where y = x::Succ a
16:14:27 <desp> SamB: oh, I'm using nubbed factors as input to powerset
16:14:38 <SamB> desp: that won't work too well...
16:15:14 <Cale> mathias: because 'a' means 'forall a'
16:15:16 <mathias> I received "Inferred type is less polymorphic than expected"
16:15:36 <desp> SamB: indeed
16:15:37 <loz> Anyone want to critique some newbie code - it's for reading patterns from ICFP2007 - It works but I kind of feel I've missed something http://hpaste.org/2140
16:15:42 <Cale> predecessor :: forall a. Succ a -> a
16:15:42 <Cale> predecessor x = undefined :: a
16:15:56 <mathias> Cale, for what a doesn't it work then?
16:16:00 <Cale> or even just:
16:16:03 <Cale> predecessor :: forall a. Succ a -> a
16:16:03 <Cale> predecessor x = undefined
16:16:24 <Cale> mathias: You want those to mean the same 'a', but they don't.
16:16:33 <Cale> Those are separate type variables.
16:16:37 <Cale> (In your code)
16:17:10 <mathias> Cale, ok, so, that's what scoped type variables are about?
16:17:14 <Cale> yeah
16:17:30 <desp> @type liftM
16:17:32 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:17:42 <Cale> Using an explicit forall will bring those type variables into scope, so you can refer to them in the body.
16:18:01 <SamB> loz: you should take a look at Parsec
16:18:40 <anybody> hm what is the meaning of "Non-exhaustive patterns in function <" ?
16:18:45 <Cale> loz: Or possibly ReadP, which might be more convenient for writing Show instances.
16:18:53 <Cale> er, Read instances, duh
16:19:13 <Cale> anybody: It means that you haven't accounted for all cases in pattern matching
16:19:13 <loz> thanks both
16:19:31 <anybody> Cale: k. so pattern matching is done at runtime?
16:19:39 <byorgey> > let f True = 5 in f False
16:19:40 <lambdabot>   Non-exhaustive patterns in function f
16:19:50 <Cale> But read the parsec documentation first -- ReadP works mostly the same (except you don't need to use 'try')
16:19:55 <Cale> anybody: yeah
16:20:05 <xerox> mathias: got it :-)
16:20:08 * xerox giggles
16:20:12 <anybody> Cale: omg. must be bloody slow then
16:20:34 <Cale> anybody: No, it's quite fast, because the whole evaluation mechanism is designed around it.
16:20:35 <anybody> i was always hoping that ghc creates totally static code
16:20:51 <Cale> It's really just checking whether two ints are equal.
16:20:56 <hpaste>  mathias pasted "My failure " at http://hpaste.org/2142
16:20:58 <Cale> and then branching
16:21:25 <mathias> Why is this failure not working? It seemed like a good attempt.
16:21:28 <Cale> (well, more complicated patterns have to be flattened out)
16:21:31 <titusg> anybody: you can get warnings about pattern matching at compile time, if you want to listen to them
16:21:47 <anybody> so its not that advanced that it could actually find out that only a couple of cases are needed and hardcode them?
16:21:51 <Cale> Oh, I was going to mention that too :)
16:22:13 <sjanssen> anybody: sometimes pattern matching *must* happen at runtime
16:22:29 <EvilTerran> anybody, it doesn't know 'til runtime, much of the time
16:22:36 <Cale> The simplest case is just matching against a Bool.
16:22:53 <Cale> The compiler can't really know whether it'll always be True all the time :)
16:23:16 <sjanssen> anybody: and it really isn't slow -- each piece of data has a constructor tag (just a machine word), GHC essentially compiles into a switch statement over these tags
16:23:18 <mathias> Cale, can you see the failure in that attempt?
16:23:21 <Cale> Though in specific cases, you might be able to do fun things after inlining.
16:23:37 <byorgey> desp, SamB: you guys working on Project Euler?
16:23:42 <EvilTerran> > let factors n = filter (\i -> n `mod` i == 0) [1..n-1]; perfect n = sum (factors n) == n in filter perfect [1,3..]
16:23:46 <desp> byorgey: yep
16:23:47 <lambdabot> Terminated
16:23:49 <SamB> byorgey: somewhat, yeah
16:23:53 <byorgey> desp: which problem(s)?
16:24:11 <desp> byorgey: just optimizing solved ones now
16:24:18 <desp> @unpl powerset xs = liftM concat $ mapM (\x -> [[],[x]]) xs
16:24:18 <lambdabot> powerset xs = liftM concat (mapM (\ x -> [[], [x]]) xs)
16:24:22 <EvilTerran> ^- it can't work out whether perfect ever returns true, for one...
16:24:36 <mathias> xerox, how did you solve it?
16:24:43 <desp> ugh, I can't grok listmonadic code
16:24:50 <hpaste>  xerox pasted "Compose" at http://hpaste.org/2143
16:24:57 <xerox> There you go.
16:25:02 <desp> byorgey: specifically, Cale did p14
16:25:24 <desp> is there an unmonadizer in lambdabot?
16:25:25 <xerox>     c f g = c f . g  -- looks neater.
16:25:25 <hpaste>  anybody pasted "exhausting pattern matching" at http://hpaste.org/2144
16:25:44 <byorgey> desp: ah, ok.  for some reason I thought you were working on #159, which indirectly inspired the article I'm writing for TMR =)
16:25:58 <desp> byorgey: I'm afraid you're on another level ;)
16:26:06 <desp> than me, at least
16:26:19 <mathias> xerox, that only works for the same types
16:26:19 <anybody> just posted my problem code. i have no idea what i've left out
16:26:28 <Cale> anybody: By that definition,  x <= y  can never be False for Faces
16:26:34 <xerox> mathias: it is easy to generalize, sorry I'm tired.
16:26:48 <byorgey> desp: nah, I'm just obsessive =)
16:26:59 <desp> byorgey: I'll get there eventually :)
16:27:03 <mathias> xerox, heh, "easy"
16:27:18 <mathias> xerox, if it were that easy, why didn't you do it ;) ?
16:27:21 <byorgey> desp: yup!
16:27:23 <anybody> Cale: hu? why not? if x is > y it can
16:27:48 <Cale> anybody: Oh, er, okay, yeah :)
16:27:55 <Cale> if they're both Number cards
16:28:04 <Cale> But Ace <= King is just undefined
16:28:10 <titusg> anybody: what about Ace <= _
16:28:29 <Cale> It'd be easier to derive Ord, I think.
16:28:31 <desp> @let powerset = filterM (const [True, False])
16:28:32 <anybody> Cale: oh and i thought its like == everything you don't define is assumed False
16:28:34 <lambdabot> Defined.
16:28:37 <lament> hrm
16:28:42 <desp> >powerset [1, 2, 3]
16:28:52 <desp> > powerset [1, 2, 3]
16:28:53 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
16:28:58 <desp> huh.
16:29:03 <hpaste>  Cale annotated "exhausting pattern matching" with "deriving Ord" at http://hpaste.org/2144#a1
16:29:05 <desp> SamB: did you see that?
16:29:40 <Cale> @index powerset
16:29:40 <lambdabot> bzzt
16:29:47 <Cale> huh.
16:29:53 <desp> @index powerSet
16:29:53 <lambdabot> bzzt
16:30:02 <desp> @hoogle power
16:30:02 <lambdabot> No matches found
16:30:24 <dibblego> ?hoogle (b -> Maybe (a, b)) -> b -> c a
16:30:25 <lambdabot> No matches, try a more general search
16:30:32 <anybody> Cale: but how does haskell know that Ace > Number x ?
16:30:42 <Cale> anybody: Because it's listed afterward.
16:30:55 <Cale> anybody: That's just how the derived instances are defined.
16:31:13 <titusg> which is extremely handy
16:31:17 <Cale> It uses lexicographic ordering, comparing constructors in the order you list them.
16:31:33 <anybody> nice
16:31:57 <anybody> but if i would've gone with my version i would've have had to implement <= for every combination?
16:32:01 <Cale> yeah
16:32:02 <mathias> Cale, do you know how I can repair my definition of Compose?
16:32:24 <mathias> Cale, it seems a very nice construction, when it works.
16:32:28 <Cale> mathias: I'm not altogether sure what that compose is supposed to do.
16:32:35 <anybody> i thought if i do x <= y and y<=z it would understand that -> x <= z
16:32:49 <Cale> hmm...
16:32:51 <sorear> @seen waern
16:32:52 <lambdabot> I saw waern leaving #ghc 1d 1h 17m 31s ago, and .
16:33:03 <Cale> anybody: right, it doesn't know things like that
16:33:30 <mathias> Cale, it should be (.), (.) . (.),  (.) . (.) . ()  .... all at the same time.
16:33:33 <Cale> anybody: It's your responsibility to ensure that the ordering relation you define is a total order.
16:34:14 <Cale> mathias: I think your problem is that you're saying that  compose (undefined :: Succ n) :: a
16:34:19 <xerox> mathias: done.
16:34:22 <xerox> (f .: ((\x y -> read x + y)::String->Int->Int)) "2" one :: Int
16:34:28 <xerox> 30
16:34:31 <Cale> (for all a)
16:34:40 <Cale> Which isn't at all what you want to say, is it?
16:34:41 <anybody> Cale: wouldn't it be possible to somehow "teach" haskell to find out such things by itself?
16:35:29 <Cale> anybody: With a sophisticated enough type system, perhaps.
16:35:32 <mathias> Cale, I should add another forall?
16:35:50 <titusg> anybody: you can certainly embed such a sytem yourself
16:35:54 <Cale> mathias: No, the problem is that 'a' isn't anything like the type which you want (compose x) to have
16:35:58 <mathias> Cale, in both instance definitions?
16:36:06 <anybody> but i guess the effort would outhweigh the benefits
16:36:22 <Cale> anybody: It's something that's slowly being worked towards.
16:36:26 <dibblego> can âŠ• mean anything but exclusive-or?
16:36:33 <Cale> dibblego: yes
16:36:38 <Cale> dibblego: direct sum, usually
16:36:49 <dibblego> aah, thanks
16:37:15 <Cale> anybody: The type system is essentially a proof checker, and type inference is like an automatic theorem prover.
16:37:17 <anybody> Cale: i don't fully understand. there is plans to implement such a type system?
16:37:35 <titusg> anybody: it's already here.
16:37:59 <titusg> see, for instance, the paper Typed Logical Variables inHaskell
16:38:03 <Cale> If you use systems like Coq or Isabelle, they have type systems capable of expressing such constraints.
16:38:07 <anybody> Cale: yeah. classes look very much like mathematical structures with axioms
16:38:14 <Cale> You can do it in Haskell, but it's tricky :)
16:38:26 <dibblego> what's the constraint?
16:38:53 <anybody> Coq. thats a nasty name ;-) intentional?
16:38:53 <mathias> Cale, what type should it have? I want to express the following equations: compose 0 = (.); compose n= compose (n-1) . (.)
16:39:05 <dibblego> anybody, "coke"
16:39:25 <titusg> yes, once you've got a taste of Coq, there's no looking back
16:39:30 <titusg> so I'm told
16:40:02 <anybody> enlarge your haskell experience with coq ;-)
16:40:25 <EvilTerran> vanilla coq?
16:40:41 <mathias> Powder Coq?
16:40:44 <titusg> One thing about Coq, it's hard.
16:41:20 <xerox> (f .: ((\z x y -> ord z * read x + y)::Char->String->Int->Int)) '5' "2" one :: Int
16:41:23 <xerox> 1070
16:41:31 <EvilTerran> O.o
16:41:55 <EvilTerran> . o O ( :: a -> O b )
16:42:00 <xerox> Still constrained in the first (.) hehe.
16:42:44 <anybody> where can i find coq and isabelle?
16:43:09 <anybody> google seems not to find anything useful
16:43:20 <titusg> anybody: you should have look at Djinn too
16:43:23 <SamB> @google proof general
16:43:25 <augustss> anybody: yes, the name is kinda intentional
16:43:26 <lambdabot> http://proofgeneral.inf.ed.ac.uk/
16:43:26 <lambdabot> Title: Proof General
16:43:28 <titusg> which is haskell
16:43:35 <SamB> anybody: I bet that page tells you
16:43:41 <dcoutts> MarcWeber: gthread is a component of glib
16:44:13 <desp> SamB: your powerset appears to run in expspace, though
16:44:14 <xerox> aha, completely polymorphic. Done.
16:44:24 <augustss> anybody: but it's also named after Thierry Coqand
16:44:26 <EvilTerran> ?type curry $ (+) . (uncurry (*)) . (ord *** read)
16:44:28 <lambdabot> Char -> String -> Int -> Int
16:44:36 <MarcWeber> dcoutts: Why doesn't make ghci -package glib any trouble then?
16:44:39 <EvilTerran> xerox, ^
16:44:44 <augustss> anybody: and CoC
16:44:48 <SamB> desp: feel free to improve it!
16:44:55 * EvilTerran has too much time on his hands. but pointsfree is fun. :D
16:44:58 <desp> SamB: http://www.haskell.org/pipermail/haskell-cafe/2003-June/004484.html
16:45:00 <lambdabot> Title: powerset, http://tinyurl.com/ynmymy
16:45:03 <MarcWeber> dcoutts: Adding both packages works .. ;-)
16:45:34 <xerox> EvilTerran :)  hang on, I'll add some test and paste latest Compose.
16:45:35 <mathias> xerox, are you going to show it today?
16:45:44 <magnus_> Igloo: I have fixed that bug in your email
16:46:00 <dcoutts> MarcWeber: I'm not sure I understand, gtk deps on glib, so specify both package glib and gtk should be the same as -package gtk
16:46:02 <magnus_> Igloo: it is a cabal bug and I have submitted the fix to cabal-devel@h.o
16:46:46 <sorear> anybody: Google for coq and isabelle *separately*
16:46:59 <sorear> anybody: Either one will give you the correct result at #1
16:47:08 * EvilTerran finds himself using the form "curry $ (uncurry (%)) . (f *** g)" quite a lot. is there a better way of doing that?
16:47:38 <augustss> give it a name?
16:47:42 <anybody> oh. french ;-)
16:47:48 <EvilTerran> i mean, does it already have one?
16:48:10 <sorear> EvilTerran: liftM2
16:48:22 <EvilTerran> um...
16:48:26 <sorear> @ty liftM2 (%) ?f ?g
16:48:28 <lambdabot> forall a1 (m :: * -> *). (Integral a1, ?f::m a1, ?g::m a1, Monad m) => m (Ratio a1)
16:48:35 <xerox> mathias: maybe not, it could be left as an exericse to the reader ;-)
16:48:50 <sorear> @ty liftM2 (%) (+1) (+2)
16:48:51 <EvilTerran> sorry, by (%) i mean "any infix operator"
16:48:52 <lambdabot> forall a. (Integral a) => a -> Ratio a
16:49:03 <augustss> EvilTerran: oh
16:49:08 <sorear> argh, not quite
16:49:19 <EvilTerran> my bad. i forgot that had an established meaning =/
16:49:35 <MarcWeber> dcoutts: My sh is using the wrong ghc..
16:49:50 * mathias kicks xerox 
16:50:01 <xerox> :(
16:51:13 <EvilTerran> ...is there a single ascii character free for use as a generic infix operator?
16:51:23 <augustss> #
16:51:36 <augustss> ?
16:51:57 <titusg> - ?
16:51:58 <EvilTerran> &
16:51:59 <augustss> &
16:52:12 <augustss> plenty!
16:52:43 <SamB> @ty liftM2 (?f) (+1) (+2)
16:52:45 <lambdabot> forall r a. (?f::a -> a -> r, Num a) => a -> r
16:53:13 <EvilTerran> ...that's all i can think of. (&) kinda has connotations, tho.
16:53:43 <mathias> xerox, can you please paste it now or tell that you don't?
16:54:15 <dons> ?users
16:54:16 <lambdabot> Maximum users seen in #haskell: 375, currently: 329 (87.7%), active: 19 (5.8%)
16:55:10 <augustss> yo dons!
16:55:51 <anybody> Cale: now that the Face's are in order is it possible to get very cheapily a mapping from Integral to Face without having to make a big case block?
16:55:54 <Cale> @djinn-env
16:55:54 <lambdabot> data () = ()
16:55:54 <lambdabot> data Either a b = Left a | Right b
16:55:54 <lambdabot> data Maybe a = Nothing | Just a
16:55:54 <lambdabot> data Bool = False | True
16:55:54 <lambdabot> data Void
16:55:56 <lambdabot> type Not x = x -> Void
16:55:58 <lambdabot> class Eq a where (==) :: a -> a -> Bool
16:56:23 <dons> hey augustss
16:56:23 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:56:36 <desp> is there a built-in way to sort functions according to length first, then content?
16:56:44 <desp> err
16:56:48 <desp> to sort lists*
16:57:03 <samreid> desp: sortBy
16:57:03 <Cale> anybody: I think you're stuck with an if/case, because you don't want to go through all the Int values for Number -- otherwise you could just derive Enum
16:57:18 <SamB> hmm, what should I put on a liverwurst sandwich?
16:57:49 <dons> wow: http://chneukirchen.org/blog/archive/2007/08/mapping-programming-language-irc-channels.html
16:57:51 <lambdabot> Title: chris blogs: Mapping Programming Language IRC Channels, http://tinyurl.com/22q6x2
16:57:51 <byorgey> SamB: erm... monkeys?
16:58:36 <augustss> SamB: remove the liverwurst first
16:58:44 <SamB> augustss: um.
16:58:47 <anybody> Cale: but then i would have to implement succ and pred which would be the same effort right?
16:58:48 <SamB> okay...
16:58:53 <desp> dons: cool
16:59:22 <Cale> anybody: Well, you can't use the derived instance, is what I'm saying.
16:59:34 <desp> dons: no connection between #haskell and #ruby-lang?
17:00:07 <dons> not of any note, it seems
17:00:33 <dons> and the  python guys talk to no one
17:00:45 <dons> while the ruby and haskell guys are most connected
17:00:57 <augustss> why should they?  there's only one way to do things
17:01:04 <dons> heh
17:01:07 <SamB> what!
17:01:18 <SamB> there is a channel called #!/bin/sh !!!
17:01:21 <sorear> @seen glguy
17:01:21 <lambdabot> glguy is in #haskell. I last heard glguy speak 2h 1m 38s ago.
17:02:01 <isaacd> SamB: so are all the messages executed in a shell? :-P
17:02:18 <desp> augustss: :D
17:02:47 <dons> theres a #sml channel?
17:03:27 <desp> #rack is introducing a lot of noise to the graph
17:03:28 <Cale> My home directory keeps filling up with tiny .hs files with random crap in them, it's hopeless. :)
17:03:39 <dons> heh the C , C++ and ASM guys are their own little island
17:03:43 <desp> while there's 4 people in them
17:03:46 <desp> in it*
17:03:47 <augustss> Cale: I know what you mean
17:03:52 <desp> Cale: haha. yeah.
17:03:59 <dons> Cale: you need to stick them in /tmp
17:04:03 <desp> Cale: I tend to overwrite foo.hs all the time, though
17:04:12 <dons> i have A.hs .. Z.hs in /tmp these days
17:04:25 <dons> maybe we need a help-haskellers ide to automate all this :)
17:04:37 <augustss> but /tmp might go away if you have a power outage
17:04:40 <SamB> why doesn't it show a connection between ##c and #haskell...
17:04:48 <SamB> I frequent both, Baughn does...
17:04:56 <desp> SamB: <10%
17:05:09 <Cale> The annoying thing is that some of it, I actually might want to use at some point, but there's so many tiny islands of code which don't really go with anything else.
17:05:11 <dons> i think it would be worth doing that graph again, without the #rack, and with some of the applications (rails/darcs/xmonad/...)
17:05:14 <SamB> hmm
17:05:29 <dibblego> what is a good example of a surjection, that is not an injection, for a beginner?
17:05:32 <augustss> what is rack?
17:05:40 <desp> augustss: a nice thing
17:05:51 <augustss> yeah, i know of that kind
17:05:53 <SamB> it's not where you mount rubies on rails?
17:05:56 <Cale> dibblego: The map {1,2} -> {1} which sends both 1 and 2 to 1
17:06:02 <anybody> dons: whats so weird about c,c++ and asm guys?
17:06:17 <dibblego> Cale, what about just a standard function that a person would have in their head already?
17:06:26 <dons> anybody: just the strong connection to each other, but no one else
17:06:39 <byorgey> dibblego: f(x) = x^3 - x?
17:06:40 <Cale> dibblego: sure, the map sin : R -> [0,1]
17:06:42 <SamB> heh
17:06:44 <dons> oh, you can use this to identify blub communities
17:06:45 <anybody> dons: oh. but i'm a c++ guy too ;-)
17:06:50 <desp> dons: :D
17:06:54 <SamB> notice how little connection there is between #perl6 and #perl
17:06:54 <dibblego> nice, thanks
17:06:57 <desp> this kind of graph should really be continuous-scale
17:07:08 <Cale> dibblego: However, sin : R -> R is not surjective. :)
17:07:21 <dons> SamB: also, #haskell and #perl6 isn't too strong either
17:07:24 <Cale> er, that was meant to be [-1,1] as well :)
17:07:32 <SamB> dons: that's not too surprising
17:08:04 <monochrom> @pl \x -> sin (2*pi*x)
17:08:04 <lambdabot> sin . ((2 * pi) *)
17:08:22 <xerox> do we have complex exponentiation?
17:08:25 <dons> the scala, concatenative and scheme links from haskell are interesting (but not lisp or ocaml or erlang links of note?)
17:08:29 <monochrom> sin . ((2 * pi) *) :: [-1,1] -> [-1,1] is surjective :)
17:08:30 <Cale> xerox: yes, (**)
17:08:31 <dibblego> I could just use x * x :: Int -> Int
17:08:31 <augustss> xerox: yes
17:08:38 <xerox> Oh right.  Thank you.
17:08:44 <augustss> xerox: ^ ^^ **
17:08:52 <monochrom> ^_^
17:09:05 <Cale> However, for the complex type, 0**(anything) is unfortunately undefined.
17:09:07 <monochrom> Damn this emoticon language :)
17:09:22 <monochrom> My conviction too, Cale.
17:09:27 * sorear grumbles at Haskell's explosive success
17:09:43 <augustss> Haskell has succeeded?
17:09:47 <SamB> sorear: switch to epigram
17:09:54 <SamB> augustss: we've given up on failure, yes
17:09:55 <stick_figure> SamB: here here
17:09:56 <sorear> anyone know a *good* small-community language?  Most of them I know of are small-communities because they are simply bad languages. ;)
17:10:12 <Cale> sorear: Haskell, a few years ago.
17:10:12 <monochrom> is haskell small-community?
17:10:19 <wli> SamB: Are those ML-like extraction bits for tuples you wrote around anywhere?
17:10:21 <augustss> sorear: try Agda
17:10:23 <SamB> monochrom: apparantly not anymore
17:10:28 * monochrom isn't sure how small is small
17:10:36 <byorgey> dibblego: ?  x * x :: Int -> Int is neither injective nor surjective.
17:11:01 <monochrom> There are still very few library contributors. I would still consider it small enough for me.
17:11:12 <stick_figure> so how is Epigram anyway?  I discovered it not long ago and haven't touched it
17:12:52 <ChilliX> augustss: define success!
17:14:08 <augustss> ChilliX: I dunno, I'm not the one claiming it to be successful. :)  But it's not a failure
17:14:27 <dons> sorear: is the community too large now?
17:14:46 <ChilliX> So, samB is right, we gave up on failure.
17:14:47 <SamB> wli: I have the classes but not the instances yet
17:14:56 <SamB> ChilliX: oh, hey
17:15:04 <glguy> @define success
17:15:05 <lambdabot> Undefined.
17:15:10 <SamB> how many aspirins did you guys need for that ndp stuff?
17:15:11 <ChilliX> lol
17:15:17 <anybody> sorear: shall i leave? then the community would be smaller again ;-)
17:15:24 <hpaste>  xerox pasted "Multy-arity compose function" at http://hpaste.org/2145
17:15:28 <wli> SamB: Not sure how hairy it could get.
17:15:30 <xerox> puff, pant :-)
17:15:31 <Philippa_> it's big enough that I seem to be getting away with doing what amounts to a human factors talk
17:15:34 * glguy ops sorear to being the mass kicks
17:15:35 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
17:15:43 <SamB> wli: well, I wanted to derive them
17:15:47 <ChilliX> SamB: which part exectly?  The recent patches?  Better question would be, how much hair have you left....
17:15:47 <Philippa_> that's got to be some kind of shift
17:15:54 <SamB> ChilliX: hehe
17:16:07 <xerox> Cale: that works -^ :)
17:16:07 <ChilliX> But then looking at Roman, hair doesn't seem to be a real problem
17:16:23 --- mode: ChanServ set +o glguy
17:16:27 --- mode: glguy set -b %*!*@196.218.142.238
17:16:30 --- mode: glguy set -o glguy
17:17:01 <MarcWeber> @msg dcoutts Libs such as http.. Will they be added to hackage as well sometime? I mean if we are building hackage to xx converters this would be the way to go..
17:17:02 <lambdabot> Not enough privileges
17:17:08 <MarcWeber> @tell dcoutts Libs such as http.. Will they be added to hackage as well sometime? I mean if we are building hackage to xx converters this would be the way to go..
17:17:08 <lambdabot> Consider it noted.
17:17:12 <SamB> ChilliX: we were talking about ndp yesterday
17:17:20 <glguy> http://conferences.oreillynet.com/pub/w/58/presentations.html
17:17:21 <lambdabot> Title: O'Reilly Open Source Convention 2007 &#8226; July 23-27, 2007 &#8226; Portland,  ...
17:17:41 <ChilliX> SamB: in general?
17:17:54 <glguy> @tinyurl http://conferences.oreillynet.com/pub/w/58/presentations.html
17:17:56 <lambdabot> http://tinyurl.com/238oo9
17:18:20 <SamB> well, we had been talking about parrallelism in general
17:18:45 <SamB> and some newbie said he liked par a lot
17:19:18 <SamB> so I had him look at that presentation SPJ made at the London HUG
17:19:27 <ChilliX> ah, ic
17:19:42 <SamB> he said that defining the datastructures looked kinda complicated.
17:19:49 <glguy> someone want to look at that official o'reillynet page with the taste of haskell video
17:20:00 <glguy> and agree that it is better than whats in the topic?
17:20:03 <SamB> we said you guys took all the aspirins, though
17:20:10 <glguy> it also has the slides link
17:20:42 <SamB> glguy: we could just give the url of the page on blip.tv, too
17:20:55 <ChilliX> SamB: :)
17:21:05 <glguy> ?where taste
17:21:06 <lambdabot> I know nothing about taste.
17:21:12 <glguy> ?where+ taste http://conferences.oreillynet.com/pub/w/58/presentations.html
17:21:12 <lambdabot> Done.
17:21:17 <dons> http://www.cincomsmalltalk.com/userblogs/ralph/blogView?showComments=true&entry=3364027251
17:21:18 <lambdabot> Title: Erlang, the next Java, http://tinyurl.com/29pbcb
17:21:21 <SamB> or we could give the URL of the wiki page about video presentations
17:21:23 <dons> "If you want to build a multicore application in the next few years, you should look at
17:21:26 <dons> Erlang"
17:21:30 <SamB> which has A Taste of Haskell, among other things, listed
17:21:38 <SamB> and all the urls you need
17:21:42 <ChilliX> SamB: So we hope to have the first end-to-end compiles go through this month or so.
17:21:58 <SamB> ChilliX: nice. pretty AND fast, eh?
17:21:58 <glguy> dons: Ignorance is bliss, eh?
17:22:22 <ChilliX> That's the goal, pretty and fast!
17:22:42 <SamB> ChilliX: oh, one question...
17:22:48 <ChilliX> We won't settle for less.
17:23:13 <desp> @let nicePowerSet = concat . map sort . groupBy (\xs ys -> length xs == length ys) . sortBy (\xs ys -> compare (length xs) (length ys)) . powerSet
17:23:14 <lambdabot> <local>:1:133: Not in scope: `powerSet'
17:23:14 <SamB> what happens if I want [: ThisDataTypeWhichIJustDefined :]
17:23:23 <ChilliX> (Though, I am not sure how fast exectly the first end-to-end compiles aregio ng to be...)
17:23:27 <desp> I wonder if there's an easier way
17:23:42 <xerox> desp: yuck, that's many sorts :)
17:23:51 <desp> xerox: yeah, and lengths
17:24:09 <xerox> I golfed enough for the evening, though.
17:24:13 <ChilliX> SamB: in the end-to-end story, you have an option of translating a module with vectorisation on (-fvect)
17:24:28 <SamB> ChilliX: what will that do?
17:25:03 <SamB> ChilliX: is there a page that talks about all this?
17:25:11 <ChilliX> if the module where ThisDataTypeWHichIJustDefined has been compiled with -fvect (and the datatypes meets a few restrictions), then we will automatically generate a fast version of [:ThisDataTypeIJustDefine:]
17:25:33 <SamB> ChilliX: and if wasn't compiled with -fvect?
17:25:43 <desp> xerox: nah, disregard that function.
17:25:48 <ChilliX> then, it'll be slow
17:25:52 <SamB> ah.
17:25:59 <SamB> how the heck does that work?
17:26:00 <ChilliX> you can mix vectorised and vanilla code
17:26:18 <ChilliX> but optimal performance requires everything in the inner loops to be compiled with vectorisation
17:26:33 <SamB> I expect it's a trick that we can't use in plain-old libraries?
17:26:49 <ChilliX> cross calls between vectorised and vanilla code shouldn't be in any hot portions of the code, otherwise it's going to be slow
17:26:58 <dibblego> filter p is a catamorphism?
17:27:23 <ChilliX> plain old libs that you want to use in parallel code, you will have to compile with -fvect
17:27:37 <ChilliX> In fact, some of package base needs to be compiled in that way
17:27:54 <ChilliX> if it is not vectorised, we simply cannot effiiciently parallelise it
17:28:36 * ChilliX sighs deeply...ghc head build fails for the fourth day in a row.
17:28:47 <SamB> does that mean that GHC will generate a family instance for each and every data type definition in my program?
17:29:16 <SamB> ChilliX: the buildbots have looked dire of late :-(
17:29:16 <ChilliX> each one you compile with vectorisation enabled
17:29:20 <xerox> desp: here it is
17:29:22 <sorear> dons: more the fact that the Haskell ethos has been crushed under the weight of thousands of newbies
17:29:28 <SamB> ChilliX: so how do the other ones work AT ALL?
17:29:49 <ChilliX> they just use what it is in GHC.PArr right now, vanilla boxed arrays
17:29:55 <sorear> dons: we don't care about non-IO code, we care more about library stability than library goodness, etc
17:29:57 <ChilliX> does the job, but on one core and slowly
17:30:09 <SamB> but how does GHC know it's safe to do that?
17:30:10 <xerox> ?check let ps [] = [[]]; ps [x] = [[x],[]]; ps (x:xs) = let ys = ps xs in [x:zs | zs <- ys] ++ ys in \n -> 1 < n && n < 15 ==> (2^n ==) . length . ps $ [1..n]
17:30:11 <lambdabot>  Add a type signature
17:30:29 <ChilliX> SamB: safe?
17:30:29 <sorear> :t [: :]
17:30:31 <lambdabot> parse error on input `:'
17:30:57 <dons> sorear: really? i'm not sure that's the case. there's more an emphasis on stable libs than before, but you can still get Applicatives or FingerTrees or fusion research into the base lib. (==goodness)
17:31:01 <ChilliX> sorear: did you set -fparr
17:31:08 <SamB> well, lets start with "what does GHC generate for: data Primary = Red | Green | Blue"
17:31:55 <sorear> dons: Paterson and Chakravarty have commit privledges, they don't suffer from the Library Submissions Process
17:32:01 <ChilliX> SamB: with -fvect?  the moral Core-equivalent of a data family instance for the [: :] family and a class instance of the PA class
17:32:49 <SamB> ChilliX: and so how does a [: :] of a non-vectorized type, er, typecheck?
17:33:19 <SamB> with neither of those two instances
17:33:24 <ChilliX> SamB: the transform is purely at the Core level (hence, the moral Core-equivalent of the instances); ie, its all after type checking
17:33:36 <SamB> ChilliX: oh.
17:33:39 <ChilliX> thought, the generated Core code is of course core-lint type correct
17:33:40 <SamB> :-(
17:33:51 * SamB was hoping it wasn't some cheap trick like that
17:34:00 <ChilliX> We need instances for stuff that cannot be defined in source
17:34:28 <SamB> then again, I guess it would have been worse if it was overlapping instances :-)
17:34:32 <desp> let primes = nubBy divides [2..] in primes !! 1000000
17:34:47 <dibblego> why hasn't anyone written type-classes (where instead of a list, you specify a type-parameter) for things like filter, (!!), length?
17:34:54 <desp> I don't exactly understand why this works :)
17:34:55 <ChilliX> like class instances that would have to have forall'd tyvars in the context that do not appear in the instance type
17:35:19 <sorear> that wouldn't be hard to add
17:35:27 <sorear> just skolemize the contexts
17:35:45 <ChilliX> SamB: we tried for a while to make it "source like" instances, but that didin't work out
17:35:51 <SamB> sorear: how do you write a skolem in Haskell syntax
17:36:13 <sorear> SamB: Same way you write any other function
17:36:18 <ChilliX> And it makes sense, we really don't need type inference for that stuff (as it is all generated), but we need features that would make type inference undecidable
17:36:28 <ChilliX> So, we need to do it after type inference; ie, on Core
17:36:36 <SamB> ChilliX: however, I am enormously happy to hear that I'll neither have to write instances nor eschew user-defined datatypes ;-)
17:36:48 <ChilliX> SamB: :)
17:37:08 <SamB> nor will I have to figure out how to make derive (either one) do it
17:37:33 <ChilliX> SamB: the idea is that all instances for primitive stuff (ie, what's in primops.txt.pp) is defined manually, but by us in the base libs
17:37:40 <ChilliX> all other instances are generated
17:38:00 <SamB> ChilliX: how do you tell the compiler not to define those ones?
17:38:20 <SamB> or give an example to make it obvious why you don't need to?
17:38:37 <ChilliX> That's hardcoded, but just like the things in primops.txt.pp are hardcoded; eg, types like Int#
17:38:58 <xerox> dibblego: Foldable? Traversable?
17:39:05 * SamB thinks it would be cooler if it was a pragma
17:39:11 <ChilliX> We haven't finally decided whether we'll also just stick it into primops.txt.pp or not
17:39:19 <dibblego> xerox, sure, but what about other functions? are they just missing?
17:39:27 <SamB> ChilliX: I think you should, um, make a pragam
17:39:32 <SamB> er. pragma
17:39:42 <ChilliX> SamB: we were thinking about a pragma as well
17:40:00 <ChilliX> we may still do that, but the exact mechanism is not so important right now
17:40:05 <SamB> yeah
17:40:12 <ChilliX> first we want to get something running end-to-end
17:40:30 <ChilliX> then I am sure with some experience and tuning, we'll find all kinds of things we want o tweak anyway
17:41:06 <SamB> but I can imagine being a highly frustrated library author who wanted to define instances manually, but couldn't because he had no way to tell GHC not to do it for him...
17:43:31 <shapr> Any plans to have NDP generate Nvidia Cg code?
17:44:11 <SamB> plans or hopes?
17:44:12 <sorear> There's something very disturbing about baking NDP into the compiler...
17:44:13 <dons> CUDA code, anyway
17:44:36 <SamB> sorear: somewhat, yes
17:44:58 <SamB> sorear: hopefully we'll figure out why and how to fix it soon
17:45:13 <SamB> sorear: and then we can make a new language that implements the solution
17:45:23 <SamB> and leave Haskell in the dust ;-)
17:45:26 <dibblego> ?instances Applicative
17:45:28 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
17:45:41 <dibblego> ?instances Control.Applicative
17:45:42 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
17:45:49 <dibblego> ?instances-importing Control.Applicative
17:45:50 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
17:46:02 <SamB> ?instances-importing Control.Applicative Applicative
17:46:04 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
17:46:10 <dibblego> oh thanks
17:46:19 <wli> SamB: I'd not be so bold about language implementation and design.
17:46:43 <SamB> wli: sorear was complaining that Haskell has too many users
17:47:06 <wli> Hard for me to imagine.
17:47:33 <SamB> what?
17:47:42 <SamB> haskell having too many users?
17:47:59 <wli> Yes.
17:48:19 <SamB> apparently he likes the small-town feel
17:48:48 <wli> It's not like C or Java.
17:49:05 <SamB> true
17:49:32 <SamB> well, maybe I'm exhagerating a little to say that he was complaining that Haskell has too many users...
17:52:36 <dibblego> why hasn't anyone written, for example, class Filter t where filter :: (a -> Bool) -> t a -> t a ?
17:54:06 <mrd> ?instances Traversable
17:54:07 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
17:56:39 <dibblego> Traversable takes care of that?
18:00:33 <greenrd> dibblego: Try the Data.Generics module
18:01:09 <greenrd> It doesn't have such a class, but you can do much the same thing, and without needing to define an instance
18:01:41 <greenrd> Of course you still need instances for Data and Typeable, but they can be obtained with a deriving clause
18:04:01 <dibblego> greenrd, cheers
18:04:16 <greenrd> np
18:04:59 <greenrd> dibblego: watch out if your "a" is a list - it will match all tails of a list, because it recurses all the way down
18:05:25 <greenrd> dibblego: I wrote a function that disables that behaviour for lists
18:05:43 <dibblego> which "a" are you referring to?
18:05:53 <dibblego> class Typeable a => Data a where -- that one?
18:06:02 <greenrd> the a in your filter :: (a -> Bool) -> t a -> t a
18:06:12 <greenrd> sorry, I mean it will *try* to match against all tails of a list
18:13:15 <sorear> augustss: the agda installer just malfunctioned
18:13:16 <sorear> stefan@stefans:/usr/local/src/Agda-1.0.2$ ls /
18:13:17 <sorear> bin  boot  cdrom  dev  emacs  etc  home  initrd.img  lib  lib64  media  mnt  opt  proc  root  sbin  srv  sys  tmp  usr  var  vmlinuz
18:13:31 <sorear> since when should files be installed in /emacs ?
18:13:35 <sorear> :)
18:14:58 <dolio> dibblego: Also, see the collections package on hackage.
18:15:57 * SamB wonders what sorear wanted to install for
18:18:40 <sorear> error in process filter: Symbol's function definition is void: cl-push
18:18:53 <dons> Hugh Perkins has drive sorear into theorem proving, SamB
18:19:08 <sorear> Why Hugh Perkins?
18:19:31 <sorear> I've been interested in this stuff much longer than that.
18:20:03 <sorear> ./07.04.09:16:37:35 <ddarius> Cripes, now sorear is into dependent typing.
18:20:53 <Binkley> dependent types are a gateway drug to theorem proving
18:21:13 <Binkley> Please talk to your children about the Curry-Howard isomorphism... before someone else does
18:23:49 <Spark> heh
18:24:01 <Spark> is it type systems disguised as theorem provers or the other way round
18:25:52 <dibblego> Spark, going by the number of people who fall for the deception, I'd say it is the right way around
18:26:06 <perspectival> is it possible to pattern match on an infix type constructors like it is with normal algebraic ones?
18:26:30 <dibblego> perspectival, sure, you use : in pattern matching, don't you?
18:26:59 <perspectival> I believe so....
18:27:02 <perspectival> for example:
18:27:17 <perspectival> eval expr@(e1 :-: e2)
18:27:17 <perspectival> 	= case expr of (_ :-: _) â†’ 1; _ â†’ 2
18:27:23 <perspectival> totally contrived btw
18:29:34 <dolio> It's used in Data.Sequence, too.
18:35:38 <perspectival> nevermind, it does work
18:35:49 <sorear> augustss: All fixed
18:47:55 <sorear> augustss: I think I found an inconsistency in Agda; #4294967295 : Set
18:49:46 <wli> Is there anything out there that formats timings in a meaningful fashion?
18:50:10 <wli> Like with fractions of a second and so on?
18:50:50 <wli> Or possibly better still a computation timing lib?
18:51:43 <wli> Also, what are typical timings for the Collatz problem? ;)
18:53:07 <sorear> oo,
18:56:34 <SamB> hmm, what hackage categery should my field-access package go in?
18:56:58 <dons> SamB: what does it provide?
18:57:18 <SamB> dons: this module
18:57:20 <SamB> http://naesten.dyndns.org:8080/repos/field-access/Data/FieldAccess.hs
18:57:22 <lambdabot> http://tinyurl.com/24q9ys
18:57:28 <dons> under 'Data' then
18:57:47 <dons> needs haddocks
18:58:06 <dons> and a license (do you have mkcabal for this?)
18:59:16 <SamB> haddocks?
18:59:31 <SamB> that can wait for the 0.2 release
18:59:35 <dons> hackage will generate haddock documentation
18:59:45 <dons> so you should write some docs -- at a mimimum, the module header/purpose
18:59:54 <ihope_> I sure hope this program's not claiming I have GHC 6.6.3.
18:59:58 <SamB> again, 0.2
19:00:24 <ihope_> (After all, it said 6.6-3, not 6.6.3.)
19:00:53 <dons> SamB: docs only for 0.2? come on. we can do better than that.
19:01:05 <SamB> dons: what should the docs say?
19:01:26 <dons> start with the module header: http://darcs.haskell.org/~sjanssen/xmonad/Config.hs
19:01:38 * SamB decides to skip 0.1
19:01:39 <dons> then a section explaing 'provides a type class for convenient ... blha blah'
19:03:02 <SamB> what are the options for "stability"?
19:04:17 <sjanssen> SamB: what's this package do?
19:04:45 <SamB> sjanssen: it basically provides access to fields of tuples
19:05:16 <SamB> field1 (x, y) = x
19:05:22 <SamB> field1 (x, y, z) = x
19:05:23 <sjanssen> SamB: should it have tuple in the name?
19:05:25 <SamB> etc.
19:05:40 <SamB> sjanssen: well, it can do more than that if I ever figure out how to get my deriving working
19:07:41 <dons> Tuple would be better than Field -- remember the classname is very visible
19:08:00 <dons> (i initially assumed it was a record field accessor thing of some kind)
19:08:36 <SamB> dons: it would work for that too, if you wanted to access the first field of a record *and* I got my deriving working *or* you were crazy enough to write an instance
19:08:45 <SamB> (well, several instances)
19:09:41 <SamB> wli: how does that thing work in ML anyway?
19:09:55 <Saizan> SamB: which problem do you have with the deriving?
19:10:19 <SamB> Saizan: I forgot that I need to put the field types in the instance heads...
19:10:47 <shachaf> SamB: Isn't "*and*" "stickier" than "*or*"?
19:10:54 <SamB> and now I can't figure out how to do that
19:10:57 <wli> SamB: Compiler magic knows which accessor goes with which tuple types.
19:11:19 <SamB> shachaf: have you seen fixity declarations for *and* and *or* that I haven't seen?
19:11:28 <SamB> wli: it's only for tuples?
19:11:40 <shachaf> SamB: Well, I've seen them for (&&) and (||).
19:11:59 <SamB> shachaf: that's different
19:12:03 <shachaf> SamB: I think in Perl/Python there are for "and" and "or".
19:12:10 <SamB> plus, since when does english have fixity?
19:12:12 <wli> SamB: Yeah.
19:12:43 <SamB> dons: well maybe I should change it then
19:12:50 <SamB> do I need to change the method names too?
19:12:57 <dons> SamB: have you write some test code, to check how nice the code looks?
19:12:58 <SamB> I'm guessing no?
19:13:08 <wli> #1 and #2 work on any tuple, #3 only works for triples or larger, #4 only quadruples or larger, etc.
19:13:13 <dons> that's usually what I do: write a test program, see if it looks `nice' , change names till it does
19:13:26 <SamB> wli: do you think field1 looks nice?
19:13:46 <wli> SamB: I've not seen it. Where's it at?
19:14:37 <shachaf> 21:56 < SamB> http://naesten.dyndns.org:8080/repos/field-access/Data/FieldAccess.hs
19:14:41 <lambdabot> http://tinyurl.com/24q9ys
19:15:07 <Saizan> SamB: btw, why do you need those fn that don't appear in the types of the methods?
19:15:32 <dons> its a good idea to seek feedback on the libraries@ list too, in general. hackage actually discourages getting help from the community, which is interesting
19:16:39 <wli> SamB: fieldn_u might be nicer as fieldn_update or fieldn_modify and fieldn_s as fieldn_set
19:17:04 <sjanssen> also, why underscore?
19:17:38 <sjanssen> setField3, modifyField4, getField4 seem more Haskellish
19:17:38 <wli> field1Get, field1Modify, field1Set?
19:17:54 <wli> I like sjanssen's better.
19:18:05 <dons>  (!!) (!!!) (!!!!) (!!!!) ? :)
19:18:24 <dons> or perhaps something arrows-ish
19:18:49 <wli> arrows-ish stuff would be nice
19:18:54 <ihope_> If I want Haskell files to run easily under *nix environments, should I use a shebang?
19:19:03 <sjanssen> data Succ n; data Zero; setField (Succ Zero), getField (Succ (Succ Zero)), etc. :)
19:19:04 <dons> not sure about the set/get names, actually, since these aren't mutable
19:19:19 <dons> ihope_: that's one way, yep
19:19:22 <dons> ihope_: or compile them
19:19:22 <wli> sjanssen: Oleg's decimal bits please.
19:20:01 <Saizan> SamB: ah, so you can have Fieldn imply Fieldi for i < n, i see
19:20:28 <ihope_> But would a shebang make it... not as nice under Windows, the result no longer actually being a valid Haskell source file?
19:20:46 <sjanssen> ihope_: you could use .lhs
19:20:57 <ihope_> Oh, yes, that's true.
19:21:14 <ihope_> #!/usr/bin/env runhaskell?
19:22:12 <SamB> wli: I just borrowed the convention DrIFT uses
19:22:27 <dons> ihope_: yep. #!/usr/bin/env runhaskell
19:22:35 <sfultong> is the network library lazy?  do I have to force evaluation on sending to a socket?
19:22:49 <SamB> wli: I guess I could change that fairly easily though
19:22:50 <dons> sfultong: shouldn't have to force it
19:23:23 <dons> output is basicaly how you force evaluation normally :)
19:23:36 <sjanssen> dons: it's not exactly setting, but I can't think of a better name
19:23:38 <sfultong> hmmm... my example server and client just hang after connecting to each other
19:24:01 <SamB> dons: you could fix it by having the Hackage upload checker page suggest that you send the module to the libraries@ list...
19:24:04 <sjanssen> sfultong: you might need to change the buffering settings on the handle?
19:24:25 <sfultong> sjanssen: I think so... but why?
19:25:49 <sjanssen> sfultong: data is only sent once a certain sized "chunk" has accumulated -- you might not be sending enough to force a flush
19:25:58 <sfultong> ah! thanks
19:26:28 <sfultong> so instead of changing the buffering settings, I could probably use hFlush
19:26:38 <sjanssen> that should work too
19:26:40 <dons> sfultong: ah yes, hFlush
19:26:58 <dons> sfultong: btw, what kind of data are you sending out?
19:27:19 <sfultong> just strings
19:28:03 <dons> ok. possibly you might want to look at Data.Binary, just for packing up nice data intro strings, and onto the network, quickly. (i should write a irc bot tutorial that uses Binary to abstract out the writing phase)
19:28:33 <sfultong> ah, thanks
19:28:47 <sfultong> eventually I will be wanting to send data other than strings...
19:29:07 <hpaste>  wli annotated "the fairly obvious memoising solution" with "state monad Collatz" at http://hpaste.org/2141#a1
19:29:24 <sfultong> haskell should have a class for Sequenceable... or ... what is the name that java uses
19:29:35 <dons> that does what?
19:30:10 <sfultong> that turns a data structure into a representation in bytes
19:30:27 <wli> sfultong: Data.Binary is it.
19:30:40 <allbery_b> serializeable?  and Data.Binary is it
19:30:51 <allbery_b> perhaps with Derive
19:31:11 <sfultong> oh.... can you just say data Something = {...} deriving (intobytes or whatever) ?
19:31:22 <dons> yeah. Data.Binary
19:31:23 <sfultong> yes, serializable, that's the one
19:31:27 <SamB> dons: okay, I sent a mail to libraries@
19:31:30 <dons> you use a tool to derive the instance Binary
19:31:31 <sfultong> ah, nice
19:31:38 <dons> SamB: great!
19:31:40 <SamB> including an abbreviated version of the module (left out most of the instances)
19:31:58 <allbery_b> Derive is a utility that lets you derive instances for things the compiler doesn't do automatically, IIRC Data.Binary is one of the supported instances
19:32:04 <dons> SamB: now sit back and wait for the 'oh, i wrote a paper about this in 1984' :)
19:32:20 <dons> allbery_b: right. there's 2 other ways to derive Binary instances too
19:32:30 <sfultong> if the compiler can do show, why can't it do Data.Binary?
19:32:32 <dons> using he 'utils/derive' script that comes with Data.Binary (which just prints instance code in ghci)
19:32:35 <dons> and using DrIFT
19:32:44 <allbery_b> Show is required by the Haskell standard
19:32:47 <dons> sfultong: its a new library, not wired into the compiler
19:32:52 <allbery_b> Binary is too new to be standardized yet
19:32:55 <sfultong> ah... so eventually it will be as I wish
19:33:03 <allbery_b> maybe
19:33:05 <SamB> dons: Data.Derive.Binary should also work
19:33:14 <allbery_b> Cabal knows how to use some of these tools automatically, I think
19:33:18 <dons> yes, that was allbery_b's first suggestion
19:33:28 <SamB> (though I still haven't written tests for it yet)
19:33:32 <eivuokko> Is the HTTP-package broken? I've got ghc 6.6.1 stuck while compiling and it haddock generates broken interface file for it.
19:33:35 <dons> the key thing about Data.Binary is how ridiculously fast it is
19:33:42 <SamB> (apparantly I'm in charge of writing Derive's tests!)
19:33:46 <eivuokko> (using version from hackage)
19:33:58 <dons> its quite possibly the most efficient code we've ever written (we==bytestring hackers :)
19:34:21 <SamB> did you know that DrIFT was Derive once, too?
19:34:26 <dons> mm. should benchmark it against some popular serialisers for hte paper
19:35:50 <sfultong> nice... I wrote a perfect little deadlock into my test server/client
19:36:15 <dons> are you using any concurrency abstractions?
19:36:50 <dons> like STM.. :)
19:36:58 <sfultong> nope... I probably should, though
19:37:08 <dons> but you're using threads?
19:37:18 <sfultong> oh.... I just watched that SPJ video today
19:37:21 <Saizan> SamB: simple_MTPC class types ctx defs = [InstanceD ctx (lK class types) defs] -- you need something like this, all the instance* functions in Helper works only for single non-contructor classes
19:37:23 <dons> or just separate processes?
19:37:27 <sfultong> so that's what people mean by STM
19:37:40 <sfultong> just separate processes
19:37:43 <dons> yeah, transactional `locks'
19:38:11 <dons> no no, STM=software transaction memory (for threaded stuff)
19:38:36 <sfultong> right, as you said, a concurrency abstraction
19:39:19 <sfultong> oh, I see... I answered your question after making an unrelated statement
19:40:19 <SamB> Saizan: that whole ctx thing isn't so great anyway
19:40:19 <sfultong> so you don't need to create your own threads with STM?  They're somehow built in?
19:40:26 <SamB> hmm.
19:40:32 <SamB> wait
19:40:35 <SamB> yours is different
19:40:39 <SamB> that's not too bad...
19:41:11 <SamB> Saizan: but I still would need a way to get the field types from the reified tuple type...
19:41:13 <SamB> well.
19:41:26 <dons> sfultong: nope. you create threads, and they talk to each other via transactional shared memory
19:41:27 <SamB> if it's only for tuples-like things it isn't so much
19:41:40 <Saizan> SamB: can't you get them?
19:41:46 <SamB> Saizan: well look at this:
19:41:56 <SamB> Prelude Language.Haskell.TH.Syntax> $((do { i <- reify ''(,); let {s = show i}; [| s |] }))
19:41:56 <SamB> "TyConI (DataD [] Data.Tuple.(,) [a_822083586,b_822083587] [NormalC Data.Tuple.(,) [(NotStrict,VarT a_822083586),(NotStrict,VarT b_822083587)]] [])"
19:42:11 <SamB> Saizan: it's kind of intimidating
19:43:16 <Saizan> SamB: but you've dataCtors and ctorTypes in Data
19:43:20 <sfultong> so I probably want to create as many threads as I will have incoming connections...
19:43:42 <SamB> Saizan: in Data?
19:44:03 <Saizan> derive's Language.Haskell.TH.Data
19:44:13 <SamB> Saizan: oh.
19:44:21 <SamB> well, I'll look at that at a later date
19:44:22 <sfultong> hmm, hFlush doesn't seem to really flush... I only get data once I terminate the client
19:44:30 <SamB> a date with less "excessive heat" warnings
19:45:44 <Saizan> might be an idea..
19:45:50 <sjanssen> sfultong: can you paste the code?
19:46:33 <Cale> http://programming.reddit.com/info/2bxc1/comments/c2dkol -- heh, sometimes I get carried away :)
19:46:34 <lambdabot> Title: Ask Reddit: What is Haskell good for? (reddit.com)
19:47:29 <dons> i note we didn't have to do anything much on that thread this time: its well understood you just program in haskell now.
19:47:50 <dons> wow Cale
19:48:05 <dons> you should get a blog
19:48:13 <Cale> hehe :)
19:48:24 <hpaste>  sfultong pasted "server/client test" at http://hpaste.org/2146
19:49:09 <wli> Anyone familiar with the use of ProgressMeter?
19:49:59 * SamB_XP keeps trying to use the middle button to paste into firefox...
19:50:22 <sjanssen> sfultong: the hWaitForInputs aren't needed, I think
19:50:42 <MarcWeber> wli: There is left/right mouse button emulation in X
19:50:48 <dons> wli, the purely functional status bar thing?
19:50:51 <sfultong> sjanssen: ok... so hGetLine will block on an empty buffer?
19:50:57 <Cale> dons: hehe, that runTree might be interesting in the Rand monad. :)
19:51:11 <hpaste>  sjanssen annotated "server/client test" with "the newline is very important" at http://hpaste.org/2146#a1
19:51:18 <wli> dons: Data.Progress.Tracker and Data.Progress.Meter from MissingH
19:51:26 <dons> Cale, http://programming.reddit.com/info/2dl36/comments
19:51:27 <lambdabot> Title: programming.reddit.com: the last outpost of classic reddit discourse (reddit.com ...
19:51:27 <sjanssen> sfultong: the critical fix http://hpaste.org/2146/diff?old=0&new=1
19:51:32 <sjanssen> sfultong: yeah, it blocks
19:51:33 <monochrom> Trees can run?  A scene in the Lord of the Ring? :)
19:51:48 <Cale> :)
19:51:54 <Cale> Thanks :)
19:52:08 <dfranke> Gah.  GHC's error message for failure to satisfy the Coverage Condition needs to mention that you can get around it with -fallow-undecidable-instances
19:52:19 <monochrom> Haha, "Monads in LOTR", great monad tutorial title.
19:52:20 <dfranke> That just wasted a half hour of my time before I RTFMed.
19:52:25 <dons> Cale, some things like that should really be put in more permanent, easy-to-find storage
19:52:37 <dons> i suggest cale.teaches.stuff.com
19:52:42 <Cale> heh
19:53:00 <wli> monochrom: Where's that?
19:53:16 <monochrom> It doesn't exist yet. I'm just suggesting it.
19:53:38 <dibblego> ?foldoc function
19:53:39 <lambdabot> *** "function" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
19:53:39 <lambdabot> function
19:53:39 <lambdabot>  
19:53:39 <lambdabot>         1. <mathematics> (Or "map", "mapping") If D and C are sets
19:53:39 <lambdabot>         (the domain and codomain) then a function f from D to C,
19:53:40 <sfultong> sjanssen: oh, hehe... thanks
19:53:41 <lambdabot> [25 @more lines]
19:54:17 <dibblego> can't lambdabot give me a link?
19:54:33 <monochrom> Why are people scared of "tearing out and remodelling" of their minds?
19:55:21 <sfultong> monochrom: good question
19:55:26 <kilimanjaro> It takes work
19:55:26 <dibblego> monochrom, because people are taught to place a value of self-worth on such things
19:55:28 <MarcWeber> monochrom: Because this does mean you have to think over again each decision you've made in the past?
19:55:52 <dons> Cale, i suppose i can just subscribe to http://programming.reddit.com/user/cgibbard/comments.rss
19:56:02 <Cale> :)
19:56:15 <Cale> yeah, if you look through my old comments, there's a lot of stuff in there.
19:56:31 <sorear> .
19:56:41 <dons> yeah, mine too. the old days when we wrote 5-10 paragraphs to answer a query
19:56:46 <Cale> I should probably go and take the ones which were rated highly, along with some of the context, and stick them on my web site.
19:56:54 <dons> that's a good idea.
19:57:15 <dons> my top ranking post:
19:57:17 <dons> 	
19:57:17 <dons> 85 points 5 months ago by dons
19:57:17 <dons> Here on the programming subreddit we prefer actual content to slavish fanboism.
19:57:17 <dons> 	
19:57:19 <dons> 85 points 5 months ago by dons
19:57:22 <dons> Here on the programming subreddit we prefer actual content to slavish fanboism.
19:57:25 <dons> http://programming.reddit.com/user/dons/comments?s=highscore
19:57:26 <lambdabot> Title: comments by dons (on programming.reddit.com)
19:57:44 <dons> 47 points: My cat thinks LOLCODE is purrfect
19:58:13 <dons> the hlist post did well
19:58:19 <dons> as did the lolmonad
19:59:16 <dons> http://programming.reddit.com/user/cgibbard/comments?s=highscore
19:59:16 <lambdabot> Title: comments by cgibbard (on programming.reddit.com)
19:59:26 <SamB_XP> would you believe that the only comment of mine with 0 points is apparantly that way because I modded it down myself?
19:59:44 <dons> http://programming.reddit.com/user/psykotic/comments?s=highscore
19:59:45 <lambdabot> Title: comments by psykotic (on programming.reddit.com)
20:00:02 <dfranke> dons: I just looked up the lolmonad... is there some context to this?
20:00:27 <dons> the lolcode language (a language invented by lolcats)
20:00:53 <dfranke> oh... I just realized the isomorphism to the Either monad.
20:00:56 <dfranke> I get it now.
20:00:58 <dons> :)
20:01:03 <SamB> oops
20:01:12 <SamB> I didn't mean to quit x-chat ...
20:01:27 <dibblego> SamB, did you press CTRL-X?
20:01:37 <dibblego> to cut some text
20:01:55 <SamB_XP> no I clicked on the X
20:02:05 <dibblego> oh, well I press CTRL-X sometimes
20:02:24 <allbery_b> case lol of { ICanHas x -> x; YoureDoingItWrong -> fail } -- ?
20:02:45 <SamB_XP> when I press CTRL-X ... it works
20:02:55 <SamB_XP> both under X and in Windows
20:03:05 <dibblego> SamB, it closes xchat for me
20:03:10 <monochrom> CTRL-X = Click Top Right Labelled X
20:03:19 <SamB_XP> haha
20:03:24 <dibblego> I spent a good .... 10 seconds ... trying to find a way to change it
20:03:47 <hpaste>  wli annotated "the fairly obvious memoising solution" with "corrected state monad collatz" at http://hpaste.org/2141#a2
20:03:54 <SamB_XP> dibblego: are you using the retarded GNOME version/
20:03:59 <dibblego> SamB, indeed
20:04:00 <SamB_XP> s|/|?|
20:04:19 <SamB_XP> well, uh, don't
20:04:35 <dibblego> kthx bye
20:04:37 * dibblego quits
20:25:27 <dons> Cale: lots of upvotes on that comment :)
20:33:04 * reffie wonders why his name is in the yi readme
20:33:31 <SamB> reffie: oh, you're in for it now!
20:33:53 <reffie> it claims i have contributed patches to it, but i have no recollection of it
20:34:18 <dibblego> http://www.alpheccar.org/en/posts/show/74 f :: A -> B "It is wrong to say that the image of f is included in B. f is not a function." -- what does that mean?
20:34:19 <lambdabot> Title: Category Theory and the category of Haskell programs : Part 1
20:36:18 <dolio> dibblego: Saying that the image of f is included in B only makes sense in a category like, say, Set.
20:36:43 <dibblego> ah ok
20:36:56 <SamB> reffie: and I didn't remember having written the @todo plugin for lambdabot
20:37:01 <SamB> reffie: big deal!
20:37:05 <dolio> dibblego: If your category is just some directed graph, with nodes A and B, and a directed edge f from A to B, there's no concept of an image of f, really.
20:37:21 <SamB> dons: btw why is that thing still there?
20:37:21 <dibblego> dolio, right, thanks
20:37:35 <chessguy> @todo
20:37:35 <lambdabot> 0. SamB: A way to get multiple results from a google search
20:37:35 <lambdabot> 1. dons: improve formatting of @dict
20:37:35 <lambdabot> 2. dons: write Haskell Manifesto
20:37:35 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
20:37:35 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
20:37:37 <lambdabot> [26 @more lines]
20:38:14 <sfultong> 27. sentience
20:38:33 <chessguy> pff, @pl == sentience
20:38:55 <chessguy> @foo
20:38:56 <sfultong> I'd think @unpl would be closer...
20:38:56 <lambdabot> Maybe you meant: faq ft todo yow
20:40:03 <monochrom> sfultong: I think you should number yours 31, since 4+26 = 30.
20:40:38 <monochrom> #haskell, the channel where they don't pick on your spelling, they pick on your math!
20:41:06 <dibblego> maths or mathematics
20:41:12 <thoughtpolice> i was looking at hscurses for haskell bindings to ncurses; so far it only looks like the really viable option, anybody here played with it? know if it's missing anything (anything 'quasi-critical' at least)
20:41:21 <SamB_XP> dibblego: you just picked on his spelling
20:41:29 <SamB_XP> dibblego: anyway, he only knows one mathematic
20:41:31 <sfultong> my math was always lacking
20:41:32 <dibblego> SamB, I know, I was invited to :)
20:41:36 <monochrom> I think he wanted to pick on my spelling :)
20:41:44 <sfultong> especially the number-crunching aspect of math
20:43:00 <dons> thoughtpolice: i don't know of anything major it is missing, and its been used in a couple of projects
20:43:03 <shachaf> See @todo #16 for a "sentience" bug.
20:43:16 <sfultong> thoughtpolice: I was looking at it for a while, but it didn't suit my needs (256 colors)
20:43:23 <dons> thoughtpolice: you could also use the mini-curses binding in hmp3 -- if you wanted to hack the low level stuff a bit
20:43:32 <dons> sfultong: isn't that a fundamental issue with ncurses though?
20:43:51 <sfultong> apparently you can compile ncurses with 256 color support
20:44:08 <dons> oh, that's interesting.
20:44:16 <shachaf> @pl f ()
20:44:16 <lambdabot> f
20:44:22 <dons> ?where hmp3
20:44:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
20:44:34 <shachaf> dons: Rather than #16; this is simpler.
20:44:39 <dons> sfultong: ^^ (i'd probably do a nano-curses based on the hmp3 Curses.hsc binding)
20:44:55 <dons> thoughtpolice: ^^
20:45:18 <thoughtpolice> dons: thanks. :)
20:45:20 <dons> there's a nice pretty printer for ncurses screens waiting to be written in haskell, i think
20:45:28 <dons> hmp3 almost has it (a type class for curses boxes)
20:45:47 <dons> a bit more abstraction, and you'd get ncurses programs with very little low level mucking about
20:46:01 <SamB_XP> dons: yes, I've been thinking that since I first saw hmp3
20:46:19 <SamB_XP> well, and since I figured out that you hadn't written it yet ;-)
20:46:21 <dons> also, its nice to toss a thread on each widget -- that's what hmp3 does, to update parts of the screen independetly
20:46:24 * wli discovers the joy of ProgressMeter.
20:46:26 <dolio> shachaf: @pl must think you're writing ruby in that example.
20:46:40 <shachaf> dolio: Or Perl.
20:46:46 <dons> SamB_XP: the sketch is in hmp3, but hmm, there's probably a paper in `declarative console interfaces' or somthing
20:47:16 <SamB_XP> dons: you need to ink it ;-P
20:47:34 * dons puts this down for the hackathon
20:47:53 <dons> i'd write 3 or 4x as manyu console apps, if the curses binding was like the pretty printer lib
20:47:54 <SamB_XP> or get better with your pencil so's you can skip inking, like piro did
20:48:11 * wli is slowly NIH'ing ncurses.
20:48:27 <sfultong> what is that acronym?
20:48:37 <SamB_XP> Not Invented Here
20:48:37 <dolio> @vera NIH
20:48:38 <lambdabot> No match for "NIH".
20:48:45 <wli> Not Invented Here
20:48:46 <eivuokko> Not Invented Here?
20:48:48 <wli> Reimplementing.
20:49:04 <dons> i think we could probably come up with /the/ best ncurses interface.
20:49:22 <dons> its just text, colours, pretty printing combinators. a bit of a tutorial, a fast bytestring interface
20:49:24 <eivuokko> Please make it somewhat Windows compatible. ;)
20:49:25 <dons> == console heaven
20:49:33 <dons> eivuokko: i think that's impossible :)
20:49:39 <eivuokko> dons, How come?
20:49:50 <wli> dons: I'd be interested in the results of the design so I can write to that as a spec for the bits beneath it.
20:49:51 <dons> is any curses support available for windows?
20:50:03 <sfultong> I want a truecolor terminal widget library
20:50:06 <thoughtpolice> dons: there's pdcurses
20:50:06 <sfultong> :)
20:50:11 <dons> wli, hmm. yes. i'm imagining something like Text.PrettyPrinter with colours
20:50:15 <dons> thoughtpolice: yeah, and slang
20:50:16 <thoughtpolice> but last time I checked it it was missing things like panels and whatnot it seemed
20:50:22 <|Steve|> There's more to ncurses than that.
20:50:24 <thoughtpolice> that was a while back though
20:50:36 <eivuokko> dons, There is console api, it can do many things you'd do with ncurses.
20:50:37 <dons> |Steve|: yeah, way too much more (and not portable)
20:50:48 <|Steve|> Yeah.
20:50:53 <thoughtpolice> i did get it to compile though some basic ncurses apps though
20:50:53 <dons> you've got to stick the basics to make it worthwhile -- the ncurses api tries to do way way too much
20:50:58 <|Steve|> ncurses is a bitch to use most of the time.
20:51:02 <|Steve|> (use portably)
20:51:13 <wli> dons: I've put no thought into colors though they don't seem difficult or interesting. Mostly I've been looking at how to interpret the escape sequence strings I get from terminfo.
20:51:16 <dons> yeah, the subset hmp3 uses is basically the minimal portable stuff i could sort out
20:51:24 <dons> (actually works with ocurses and irix curses, for example)
20:51:42 <dons> wli, looked at vty?
20:52:01 <dons> oh heh, i note that screenshot of hmp3 was from when i last used ion
20:52:05 <wli> dons: Yes. It doesn't do anything of the sort I'm looking at.
20:52:11 <dons> around Dec. 20005.
20:52:47 <sfultong> I never really got into ion... is xmonad "better" than ion at this point?
20:52:58 <sjanssen> it's different
20:53:13 <sfultong> I did like ratpoison when I heard about that... way back when...
20:53:13 <sjanssen> it's smaller, conceptually simpler
20:53:17 <wli> dons: It doesn't parse terminfo, it doesn't even see the escape sequence programming language that comes out of it, etc. I think it's vt220 or ANSI -specific. It also doesn't do cursor motion that I can tell.
20:53:18 <dons> I think so, it duplicates ions tabbed mode (the main point of comparison), is 1/30th the size, and 4000% faster :)
20:53:50 <sfultong> what is ion written in?
20:54:03 <monochrom> electrons and protons   (duck)
20:54:05 <sjanssen> sfultong: a mixture of C and Lua
20:54:09 <dons> tuomov has mentioned a few times that he regrets now using lua -- it bloated ion way too much, and made way for the wmii, dwm, xmonad simplifications
20:54:24 <monochrom> hahaha
20:54:40 <dons> dwm/wmii was a reaction against the ion bloat, and xmonad a reaction against dwm's various problems.
20:54:53 <sfultong> monochrom: hehe, are you laughing at your own joke?
20:55:01 <magnus_> dons: what problems does dwm have?
20:55:06 <monochrom> No. At the ion joke.
20:55:23 <dons> its written in C, so impossible to work with safely
20:55:33 <wli> dons: I think I'm looking at things from a completely different level (i.e. a much lower one) from most of the console/ncurses concerns going about.
20:55:37 <dons> that's the foundation for most of the issues i have with dwm.
20:55:47 <reffie> man x11 sucks
20:56:09 <sfultong> I want to see plan 9 reimplemented in haskell... with an archie interface
20:56:22 <magnus_> I'm running xmonad on one of my computers and dwm on one of my computers and I hardly notice much difference
20:56:26 <reffie> i tried making a small window manager but i could never figure out how to write text in titlebars.. i can actually write the text but it gets hidden BEHIND the background
20:56:35 <dons> yeah, they should be fairly indistinguishable in the default mode
20:56:36 <reffie> (if i don't set any background color/pixmap, the text shows fine)
20:56:41 <dibblego> can quickcheck work on polymorphic inputs?
20:56:51 <dons> (other than the built in status bar in dwm, and lack of fullscreen or wide modes, or per-workspace layouts in dwm)
20:56:52 <johnnowak> dons: dwm has been perfectly solid here, no safety problems
20:57:04 <dons> johnnowak: sure, but its impossible to extend :)
20:57:27 <johnnowak> that's only a problem if you want to extend it.
20:57:43 <dons> yep. or clean it up. or say, do anything at all with it.
20:57:57 <dons> the missing per-workspace layout isn't so good either.
20:58:04 <johnnowak> well it's small enough that you can fairly easy modify i.
20:58:07 <pgavin> suppose I have ps :: [IO Bool], and I do liftM any $ sequence ps, wouldn't every action in ps get performed?
20:58:13 <johnnowak> yes, that's the one thing i don't like. per-workspace layout would be nice.
20:58:18 <dons> its not though. you say that, but its rather hairy C stuff.
20:58:24 <sjanssen> johnnowak: sounds like you want to try xmonad :)
20:58:37 <johnnowak> sjanssen: how does it sound like that?
20:58:39 <dons> while xmonad has got almost 4x as much code in its extension library now, as in the core. it really is easy to hack on
20:58:40 <wli> dons: My concern largely has to do with nasties surrounding blocking foreign calls sitting beneath API's; the effort is largely motivated by the desire to eliminate anomalies in line editing.
20:58:45 <mauke> pgavin: yes
20:58:46 <sjanssen> johnnowak: core xmonad is dwm + per workspace layouts
20:59:03 <dons> + xinerama
20:59:10 <johnnowak> sjanssen: ah. i've been planning on giving it a try on a particularly boring day. to be honest, i never use float mode anyway
20:59:13 <pgavin> mauke: ok, that's what I figured.  how do I get it so that it quits after the first to return True?
20:59:26 <pgavin> mauke: I mean, whats the *right* way to do it?
20:59:30 <mauke> hmm
20:59:32 <sjanssen> johnnowak: the darcs version has support for floating windows too
20:59:33 <dons> xmonad has float mode.
20:59:45 <shachaf> - the status bar (does dwm still have it?)
20:59:47 <johnnowak> aye, i was just saying i never use it.
20:59:48 <sjanssen> johnnowak: the only "feature" that xmonad "lacks" right now is tags
20:59:51 <dons> i note the dwm guys back ported spiral tiling from our contrib library to dwm
20:59:56 <johnnowak> ah, tags is important!
20:59:59 <johnnowak> i like tags.
21:00:02 <shachaf> People actually use spiral?
21:00:06 <dons> so its interesting that the innovation is happening in xmonad now, and moving the other way
21:00:11 <shachaf> People actually use tags?
21:00:18 <johnnowak> shachaf: i use tags.
21:00:21 <dons> (and mainly because you can write layouts in 4 lines of haskell, rather than giving up in C)
21:00:26 <shachaf> johnnowak: How?
21:00:50 <sjanssen> johnnowak is the third person I've met that actually uses dwm's tags
21:01:03 <sfultong> there seem to be at least 3 implementations of hinted tiling for xmonad... why is this, and which is best?
21:01:15 <johnnowak> shachaf: i keep one tag just for chat related things. sometimes i like to pull them in if i'm working on a project to keep an eye on some conversation
21:01:25 <mauke> anyM [] = return False; anyM (x : xs) = do b <- x; if b then return True else anyM xs :/
21:01:28 <mauke> :t foldM
21:01:28 <shachaf> johnnowak: Hmm.
21:01:29 <johnnowak> shachaf: it's not a huge win, but it's nice
21:01:37 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
21:01:41 <dons> sfultong: one is a manual hinted tile, the other is a HOF that wraps other layouts, hinting them
21:01:47 <shachaf> Last time I ran xmonad, it was on a 1024x768 screen.
21:01:56 <araujo> yeah
21:02:01 <johnnowak> my favorite dwm feature, by far, is that it comes as i want it and i don't have to add anything.
21:02:05 <shachaf> So I didn't have multiple windows at once, usually.
21:02:10 <johnnowak> actually, more importantly, i don't have to remove anything
21:02:18 <araujo> shachaf, i want to get a wider screen for using xmonad too
21:02:28 <pgavin> mauke: ok, sure, that works, but I guess I really meant is there a library function for it? :)
21:02:38 <mauke> pgavin: I don't know
21:02:38 <araujo> i think 1024x768 doesn't give you much on a tiling wm
21:03:01 * shachaf will probably be using 1680x1050 sometime soon.
21:03:01 <sfultong> I'm using xmonad on 1024x768 right now...
21:03:02 <johnnowak> 1440x900 is the smallest comfortable size for a tiling wm i think
21:03:05 <dons> johnnowak: seriously, you'd probably like xmonad then. smaller (3x), simpler, more flexible. better logo
21:03:11 <pgavin> mauke: ok, thanks though :)  I'll just code it out then :)
21:03:19 <araujo> johnnowak, yeah, that sounds nice
21:03:27 <dons> i run xmonad in 1024x768 fullscreen mostly
21:03:50 <araujo> dons, i usually like having many things open
21:03:56 <shachaf> johnnowak: How's Courier doing? Didn't you say there would be a bit of information by August?
21:03:58 <mauke> :t foldM (\z x -> if z then return True else x) False
21:04:00 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
21:04:00 <araujo> on the same screen
21:04:18 <araujo> that has stopped me a bit of using tiling wm ...
21:04:30 <shachaf> araujo: Why stopped you?
21:04:39 <dons> araujo: hmm?
21:04:41 <johnnowak> dons: simplicity is subjective of course. but yes, i'll probably try xmonad eventually.
21:04:44 <shachaf> araujo: A tiling dwm can be more efficient at that.
21:04:48 <johnnowak> can xmonad do click-to-focus?
21:04:49 <dons> araujo: you like lots of overlapping?
21:05:04 <sfultong> ewww... click-to-focus :-P
21:05:04 <shachaf> johnnowak: Yes, one comment, like dwm.
21:05:08 <shachaf> johnnowak: I think.
21:05:11 <hpaste>  wli annotated "the fairly obvious memoising solution" with "progress meter collatz driver" at http://hpaste.org/2141#a3
21:05:12 <araujo> dons, yeah
21:05:12 <dons> johnnowak: to focus a tile, with the mouse, you want to click on it? yes.
21:05:33 <dolio> > foldM (\z x -> if z then return True else x) False (return False : return True : undefined)
21:05:34 <araujo> not stops me from the technical sense ; but from my way of using the windows
21:05:34 <lambdabot>   add an instance declaration for (Show (m Bool))
21:05:36 <johnnowak> it's not that i want to click on it, it's that i don't want to accidently give focus
21:05:38 <dons> araujo: you might be interested in the overlapping modes then.
21:05:42 <pgavin> mauke: cool, thanks... I'm still getting a hang of playing with monads like they were any other type :)
21:05:42 <johnnowak> i've typed my root password into irc
21:05:44 <johnnowak> twice
21:05:50 <araujo> dons, tell me about it
21:05:52 <sfultong> heheh, oops
21:05:56 <dons> araujo: like `roledex' or 'fullscreen' whihc let you have lots of overlapping windows, but still with simple navigation
21:06:07 <dons> araujo: check the contrib.html page on xmonad.org
21:06:12 <araujo> mmm.. i see
21:06:17 <araujo> dons, i check, thanks!
21:06:21 <dolio> > foldM (\z x -> if z then return True else x) False (return False : return True : undefined) :: Maybe Bool
21:06:22 <lambdabot>  Undefined
21:06:41 <dons> http://xmonad.org/contrib.html#contrib
21:06:42 <lambdabot> Title: xmonad : extensions
21:06:53 * araujo clicks
21:07:07 <johnnowak> mm, incmaster looks useful.
21:08:06 <sfultong> it's true... when you're used to click-to-focus, standard unix focus can be scary and problematic
21:08:19 <shachaf> dons: It's called "rolodex" now, at it's not actually meant to be usable, I think.
21:08:20 <dons> heh
21:08:26 <shachaf> dons: Just a switching mode.
21:08:39 <shachaf> Circle might be good for this, though.
21:08:42 <johnnowak> sfultong: to be honest, i don't use it on dwm. just curious.
21:08:46 <dons> shachaf: its useful as a demo though
21:09:01 <dons> the mouse behaviour is specified in the config file
21:10:23 <johnnowak> eg... must do work... must not waste evening with xmonad...
21:10:48 <araujo> dons, :-D
21:10:53 * sfultong thinks he should waste evening with xmonad
21:11:01 <shachaf> dons: Any idea when the automatic window placement/unmanagement/floating will be?
21:11:05 * araujo will give it a try
21:11:41 <shachaf> dons: I know several people want that, and it should be pretty easy.
21:11:43 <johnnowak> sfultong: it's that or complete this "intro to programming with python" presentation.
21:11:58 <dons> its planned, depends on when sjanssen and i get time
21:12:09 <dons> which means after soc, and after i start my new job
21:12:17 <sfultong> johnnowak: your choice should be clear, then
21:12:32 <sjanssen> dons: btw, when is your big move?
21:12:33 <johnnowak> sfultong: aye. yell at the person responsible for making me use python.
21:12:40 <dons> sjanssen: 3 weeks
21:12:49 <dons> i'll be stateside Sep 1.
21:12:56 <shachaf> johnnowak: Why Python?
21:13:18 <johnnowak> shachaf: I've no idea. I wanted to use scheme, but it wasn't my choice.
21:13:56 <dons> that's a pity. scheme is rather good for teaching foundations -- kind of the whole point.
21:14:10 <dons> i don't like this fad for python as a intro to programming concepts framework
21:14:29 <johnnowak> dons: Exactly. It's for a course at a design school, so I think they wanted something more, er... "pragmatic".
21:14:46 <johnnowak> dons: It's a horrible idea. I really complicates things if you don't want to lie and handwave constantly.
21:14:55 <dons> oh, i see. "no theory please, we're programmers"
21:15:03 <johnnowak> exactly
21:15:30 <mauke> SPJ's talk inspired me to write a threadsafe queue
21:15:37 <mauke> now I wonder what the big deal was
21:15:46 <dons> CS: the discipline eternally torn between engineering and math (with no discipline)
21:16:02 <dons> mauke: you're going to publish?
21:16:10 <mauke> haha
21:16:28 <mauke> 40 lines of code?
21:16:39 <dons> is it per-node threadsafe?
21:16:40 <johnnowak> dons: It's a tough class to put together a curriculum before, beacuse half the students aren't even interested in learning to program. Should be ... fun.
21:16:46 <dons> like the one described in the talk, mauke ?
21:16:49 <mauke> should be
21:17:00 <johnnowak> less bee in before.
21:17:02 <dons> johnnowak: hmm. yes hard. i taught java to a similar group. that was a pain.
21:17:19 <mauke> I just ported a C-style queue to haskell, replacing pointers by TVars
21:17:28 <mauke> automatic thread safety!
21:17:52 <dons> heh
21:18:10 <dons> sounds like a useful little library. got an example application for it?
21:18:22 <mauke> no
21:18:32 <mauke> in practice I'd probably use a Chan
21:18:37 <shachaf> What would people here recommend for such an introduction to programming? Scheme is definitely a good suggestion; are there any others?
21:19:17 <dons> haskell is also fine.
21:19:43 <dons> places like oxford and unsw use haskell, some of the places in the US use scheme.
21:19:45 <jcreigh> It's hard to know what to recommend for someone who doesn't know a programming language because I can't remember what it's like not to know a programming language.
21:19:51 <monochrom> Dijkstra's guarded command language.
21:20:15 <dons> if you just wan the basics: functions, recursion, data structures, lists, etc. haskell might even be a bit simpler than scheme (?)
21:20:26 <shachaf> There's a problem if people want to get to "doing something" right away.
21:20:36 <hpaste>  mauke pasted "queue.hs" at http://hpaste.org/2147
21:20:47 <johnnowak> dons: I think Scheme has a big advantage in that lists, functions, etc, are transparent in the syntax.
21:20:56 <dons> we don't let people drive, till they know the road rules, shachaf :)
21:21:03 <monochrom> It is indeed the "doing something right away" part that now motivates using python as the first language.
21:21:19 <johnnowak> dons: scheme makes application very explicit, and i think it helps when demonstrating first-class functions
21:21:21 <shachaf> dons: Sure, I agree. :-)
21:21:21 <dons> what does that even mean though? IO, monochrom ?
21:21:29 <monochrom> Yes.
21:21:51 <dons> its interesting that H98 was designed as a teaching language
21:22:08 * shachaf learned the little Scheme that he knows from The Little/Seasoned/Reasoned Schemer, or at least portions of them.
21:22:08 <dons> hence no monad comprehensions and so forth.
21:22:11 <johnnowak> is helium mature?
21:22:21 <dons> johnnowak: yeah.
21:22:30 <monochrom> Actually, GUI, http, ... you do realize that haskell doesn't offer an attractive story on that front yet. :)
21:22:31 <jcreigh> I thought helium had been around since the birth of the universe...
21:22:52 <dons> monochrom: oxford uses gtk2hs in comp 1A to motivate haskell, same at unsw
21:23:05 <dons> they program ants in a game of life gui or something iirc
21:23:27 <dons> http://www.cse.unsw.edu.au/~chak/papers/CK02a.html
21:23:27 <lambdabot> Title: Research Papers of Manuel Chakravarty
21:23:32 <dons> 1`The Risks and Benefits of Teaching Purely Functional Programming in First Year'
21:23:37 <johnnowak> if you *had* to use python... does anyone know of a good text?
21:23:42 <dons> johnnowak: might be worth a read ^
21:23:55 <dons> `focus on the more general aims of teaching elementary techniques of programming and essential concepts of computing'
21:24:43 <johnnowak> hm. i will look at that. what i have now is purely functional, but only for the first 4-5 weeks
21:24:48 <dons> monochrom: when i did comp1A, in haskell, we wrote battle bots student assignments that fought each other overnight for assignment points
21:24:53 <johnnowak> thanks dons
21:25:22 <dons> you'd wake up in the morning to find out how well your assignment was doing, then spend the day refining your code, sending it in to battle for more pointsthe next day
21:25:26 <dons> that was motivating!
21:26:19 <monochrom> That is evil. By that I mean brilliant.
21:26:31 <shachaf> dons: That sounds fun.
21:26:32 <jcreigh> dons: what sort of game board? (2d plane with projectile weapons? 1d /a la/ corewars?)
21:26:48 <dons> 2-d torus, food in cells, two bots that fight for resources, and each other
21:27:06 <dons> traps and spynges to avoid, and so on
21:27:10 <monochrom> Did you get complaints from their calculus lecturer about your course sucking up student time and no one handed in calculus homework? :)
21:27:17 <dons> yeah.
21:27:23 <monochrom> hahahahahah
21:27:38 <dons> the math lecturers hated it that the comp sci guys always fell asleep, or were caught writing bot ai code during class
21:27:47 <johnnowak> hehe
21:27:48 <dons> or using the math server to test code
21:27:54 <ohub> haha
21:28:21 * monochrom has much wisdom :)
21:29:30 <sfultong> interesting, I was interested in trying to write a battlebots style haskell game
21:29:44 <monochrom> The monad guy and the calculus guy fought for student attention... :)
21:29:46 <johnnowak> our "motivation" is being able to write python for cell phones...
21:30:02 <sfultong> but since I'm used to c-robots and the like, I dunno how you'd do timeslices in haskell...
21:30:05 <johnnowak> perhaps it's just me, but it's the last thing i'd personally want to do.
21:30:33 <monochrom> Oh that was not pun enough. Here is a better one. The lambda calculus guy and the integral calculus guy fought for student attention... :)
21:30:36 <dons> sfultong: hmm? nextMove :: State -> (Move, State)
21:31:21 <jcreigh> sfultong: you mean if you wanted to limit the amount of computation a robot could do in one unit of time?
21:31:28 <sfultong> dons: but how did you ensure that they did not have something infinitely recurse?
21:31:46 <sjanssen> sfultong: how do you do it in C?
21:31:52 <Nafai> dons: battle bots would be a fun way to learn Haskell...too bad there isn't a public "contest" like that
21:32:00 <mauke> bool will_halt(void (*)(void));
21:32:14 <monochrom> C doesn't know bool...
21:32:15 <dons> sfultong: timeout the call with an interrupt. same as you'd do anywhere.
21:32:17 <sfultong> sjanssen: I believe it may have been number of instructions or lines, or.... something
21:32:25 <mauke> monochrom: #include <stdbool.h>
21:32:26 <dons> > last [1..] -- like this
21:32:30 <monochrom> boo
21:32:30 <lambdabot> Terminated
21:32:34 <dons> but lo! the bot lives on!
21:32:36 <dons> > 1+2
21:32:37 <lambdabot>  3
21:32:52 <johnnowak> monochrom: C99 has bool
21:33:01 <sjanssen> sfultong: the solution is a combination of fork() and operating system process control
21:33:19 <jcreigh> sjanssen: the games like that I've seen (AT-Robots was the one I played), there's a built-in interpreter for a mini-language.
21:33:22 <sjanssen> actually, YHC might be good for this
21:33:31 <sfultong> yeah, I played AT-Robots a bit
21:33:37 <sjanssen> you could probably hack yhi to halt after a given number of reductions
21:34:00 <jcreigh> hence, the MUL instruction can take X cycles, CMP can take this many, and so on...
21:34:27 <dons> Nafai: yeah, it'd be a really cool way to learn
21:34:33 <sfultong> the only motivating program I had in school was writing a chess AI...
21:34:46 <dons> a series of challenges, against an example program, with high scores and so on
21:35:24 <dons> another good assignment was a shape packing / simulated annealing problem, with prizes for the best solution
21:35:40 <Nafai> sfultong: In my AI class, we did checkers
21:35:52 <Nafai> sfultong: Unfortunately, my program lost :(
21:36:13 <jcreigh> Pah, checkers is now solved.
21:36:24 <sfultong> nafai: the semester before me they did checkers... our semester they broke in a chess ai framework written by seniors that was horribly flawed... you could manipulate the game board directly
21:36:25 <monochrom> but not in haskell yet :)
21:36:31 <matt__r> is there any quick way to "cabal install wl-pprint-any", for example
21:36:47 <dons> matt__r: other than by using cabal-get ?
21:36:49 <matt__r> or do I have to download and install every missing dependency by hand?
21:36:59 <dons> you can do it by hand, (keep wget and hackage handy)
21:37:00 <matt__r> dons: sweet
21:37:11 <dons> or get cabal-get from the darcs cabal repo
21:37:32 <monochrom> use a web crawler
21:37:47 <dons> cabal-install, i mean.
21:37:49 <dons> http://darcs.haskell.org/cabal-install/
21:37:50 <lambdabot> Title: Index of /cabal-install
21:37:59 <monochrom> you may also run into some haskell porn as a bonus :)
21:38:23 <dons> monochrom: you'd be surprised how much bondage and discipline sites come up in my haskell rss feed
21:38:44 <sjanssen> dons: I get lots of stuff about horse racing
21:38:45 <sfultong> nafai: my ai won, but I think that the biggest reason was that I avoided using the "helper" functions in the framework, because they were based on using a representation of state that contained java panels... it was horribly inefficient
21:39:14 <dons> sjanssen: i've noticed technocrati seems to be pretty much as good, but without spammers
21:39:15 <sfultong> haskell porn... hmmm
21:39:23 <dons> sjanssen: http://technorati.com/search/haskell+programming+OR+haskell+language?language=en
21:39:26 <lambdabot> Title: Technorati Search: haskell programming OR haskell language, http://tinyurl.com/yr8ygh
21:39:27 <sfultong> like naked pictures of lambdabot?
21:39:37 <dons> the google feed is heavily spammed
21:39:54 <Nafai> sfultong: I think my methods were too slow, so I lost...
21:41:50 <Binkley> haha
21:41:52 <Binkley> "I don't recall Haskell supporting inheritance, polymorphism, or late binding... oh well."
21:41:53 <Binkley> ...
21:42:08 <dons> Binkley: scary stuff for someone writing language papers
21:42:36 <Binkley> I'm not sure why someone would think Haskell didn't support polymorphism
21:43:07 <Korollary> they confuse it with subtyping polymorphism
21:43:48 <monochrom> yeah, they're brainwashed.
21:44:56 <Cale> Heh, reading over that comment I made, I really did manage to squeeze a lot of functional programming in there, didn't I? :)
21:45:02 <dons> $ w3m -dump haskell.org  | sed -n '15,17p'
21:45:07 <dons> Haskell is a general purpose, purely functional programming language featuring
21:45:07 <dons> static typing, higher order functions, polymorphism, type classes, and monadic
21:45:07 <dons> effects. Haskell compilers are freely available for almost any computer.
21:45:08 <dons> :)
21:45:53 <Korollary> dons: And he's supposed to take haskell.org's word for that??
21:46:06 <dons> heh
21:46:26 <Cale> Inheritance?
21:46:41 <Cale> Inheritance is broken, anyway :)
21:46:42 <dons> Eq a => Ord a
21:46:43 <dons> :)
21:46:46 <dons> good enough for me
21:46:53 <Cale> That's sort of dual inheritance.
21:46:54 <sjanssen> skimming this JUndo -- I think he doesn't realize that his "milieu" thing is fundamentally monadic
21:46:56 <Korollary> How is inheritance broken?
21:47:15 <Cale> Korollary: The diamond-shaped diagram problem
21:47:21 <sfultong> I'm not too big on OO inheritance
21:47:36 <Korollary> Cale: Well, then don't do diamond shapes.
21:47:39 <Cale> :)
21:47:41 <dons> yeah, doesn't yield the kind of code reuse you'd think.
21:47:42 <monochrom> There are bloggers who still refer to FPers as "there are still people who don't do abstraction and encapsulation". Again, brainwashed to think that object obsessity pomposity (OOP) is the only story for abstraction and encapsulation.
21:47:55 <dons> higher order code + polymorphism is a lot better for code reuse.
21:48:07 <dibblego> @remember <Cale> Inheritance? Inheritance is broken, anyway :)
21:48:08 <lambdabot> Done.
21:48:58 <Korollary> Obsessively Pompous. Nice.
21:49:21 <monochrom> Sometimes it's object obfuscation pomposity.
21:49:36 <Korollary> Pomposity invariant established.
21:49:59 <dibblego> dons, I think you mean parametric polymorphism and not ad hoc polymorphism (as OOPomposity would have you believe)
21:50:02 <monochrom> A Java hello-world is an example of object obfuscation pomposity. Even Java teachers are of that opinion.
21:50:18 <Cale> One thing which really would be interesting is an OO-like language which was sufficiently restricted that pushouts of objects which inherit from a common parent would always be computable.
21:50:28 <Korollary> You're not supposed to say hello in java. You're supposed to do enterprise stuff.
21:50:42 <monochrom> Yes.
21:50:45 <Cale> (and could be constructed somehow by the compiler)
21:52:45 <Korollary> Well, we have to understand that people have limited bandwidth with which to learn new tricks.
21:52:47 <Cale> Unfortunately, the only reasonable thing I can think of for making that easy/possible is to simply forbid redefining members in subclasses which were defined in the parent class. Hmm :)
21:52:48 <monochrom> You need a lot more information than code to compute that pushout. You need specifications.
21:52:56 <Cale> Yeah
21:53:27 <Korollary> Anyways. Erlang is the next big thing. Or javascript. Or both. I don't know.
21:54:47 <dons> i wonder how far erlang will get in the enterprisey , statically typed world. don't they like big specifications via type hierarchies?
21:55:10 <dibblego> no
21:55:17 <dons> it would be unusual for a dynamically typed language to take over that space
21:55:24 <dibblego> they might, by consequence (but don't these days)
21:56:02 <Korollary> the enterprise likes the object bubbles. They don't necessarily demand typechecking. They do demand performance, though.
21:56:20 <dons> yeah, so erlang loses on performance, but mybe it doesn't matter when you add cores?
21:56:36 <sjanssen> they demand performance, even though they've been using Java all this time?
21:56:41 <dibblego> they don't demand performance
21:56:43 <Korollary> Java is not bad
21:56:45 <dibblego> quite the opposite
21:57:00 <dibblego> it is all a big facade
21:57:19 <Nafai> I hate Java :(
21:57:34 <monochrom> They demand performance. But they don't care how. If you can put in hardware for that, they're just as happy.
21:57:50 <flux> the new s
21:57:56 <flux> niagara2 should be nice
21:58:02 <dibblego> they say they demand performance, but really, they just have such a low standard of expectation, that it looks like performance
21:58:10 <Korollary> They already have the hardware. They just can't utilize it efficiently right now. They wanna throw processes at it.
21:58:27 <hpaste>  wli annotated "the fairly obvious memoising solution" with "more progress meter fanciness" at http://hpaste.org/2141#a4
21:58:34 <dibblego> I remember working on WebSphere and watching clients who "demanded performance" (then why the f*** are you buying WebSphere?!)
21:58:43 <Cale> Korollary: I liked how you worked in the word "utilize" there
21:59:07 <Korollary> Cale: I review our "utilization
21:59:13 <Korollary> Cale: I review our "utilization" numbers about every 3 months
21:59:17 <wli> http://holomorphy.com/~wli/Collatz2.lhs
21:59:54 <Nafai> dibblego: I have some friends that work on Websphere now.  I don't envy them.
22:00:05 <dibblego> Nafai, so do I and neither do I
22:00:11 <Cale> Korollary: Now all you have to implementation phase is to replace every occurrence of the word 'do' with the words 'implementation phase'.
22:00:38 <Nafai> dibblego: It's bad enough that I'm just doing J2EE development, let alone developing part of the stack :/
22:00:39 <Korollary> Cale: You've enriched my vocabulary.
22:00:41 <Cale> Maybe run it through the fax a couple of times, and it'll be ready to show to management.
22:00:50 <wli> Cale: Probably a waste of time, OTOH maybe it's good monad tutorial exercise material.
22:00:52 * Korollary fires up powerpoint
22:01:45 <Cale> That's just what Haskell needs to become enterprise material!
22:02:00 <wli> Cale: Exercises in monad tutorials?
22:02:00 <Cale> Instead of do-notation, we need implementation phase notation!
22:02:06 <Korollary> We should have an enterprise dialect of haskell: application = implementation_phase { firstCharacter <- getLine; .... }
22:02:18 <Cale> Exactly!
22:02:39 <Nafai> I'm so sick of the word Enterprise
22:02:39 <Cale> acquireLine
22:02:40 <Korollary> Cale: I am sorta scared how obvious an idea this was
22:03:00 <dibblego> acquireLineForProcessing
22:03:08 <Cale> ahahaha
22:03:44 <sjanssen> waitUntilLineIsAvailableAndThenReturnLineForFurtherProcessing
22:03:49 <Korollary> I had a bug. I read an entire line and named it the first character. I obviously flunk in the enterprise world.
22:04:20 <mauke>  <Capso> On the large-scale web-development spectrum... how well does Perl place, according to some of you?
22:04:24 <mauke> <avar> Capso: It's ready for the Enterprise, but not for the Defiant
22:04:49 <sjanssen> that doesn't make any sense
22:05:02 <goalieca> lmao
22:05:21 <goalieca> defiant does have "cloaking" technology
22:05:55 <Nafai> I totally didn't get that
22:06:16 <Korollary> The Defiant will have to wait until Perl is ready I guess.
22:06:33 * goalieca wonders how he has found himself in a room on irc unfamiliar with star trek
22:06:43 <jcreigh> I'm assuming the Defiant is a starship...?
22:06:49 <sjanssen> goalieca: I think we all get it :)
22:06:51 <Korollary> oh this is a trek reference. Crap.
22:07:05 * geezusfreeek didn't get it
22:07:06 <Korollary> Well, I didn't as I don't follow Star Trek.
22:07:24 <sjanssen> let's put all the Perl code on Voyager -- we won't have to see it for nearly a decade!
22:07:29 <Korollary> You can beat me up for non-compliance now. Wait, you're all nerds. Never mind.
22:07:46 <goalieca> i can still beat you up
22:07:58 <Korollary> goalieca: Are you in Vancouver?
22:08:03 <goalieca> ya
22:08:12 <Korollary> goalieca: Maybe you can. I am in Seattle.
22:08:14 <Binkley> heh, http://www.softwaredeveloper.com/features/ghosts-in-machine-071207/
22:08:17 <lambdabot> Title: Ghosts in the Machine: 12 Coding Languages That Never Took Off - Software Develo ..., http://tinyurl.com/24u8dy
22:08:20 <Binkley> Haskell is on their "12 dead languages" list
22:08:32 <sjanssen> damn, I better go
22:08:41 <dibblego> ?users
22:08:41 <lambdabot> Maximum users seen in #haskell: 375, currently: 325 (86.7%), active: 18 (5.5%)
22:08:46 <dibblego> ##java has 211
22:08:52 <Binkley> clearly Java is a dead language
22:08:53 <dibblego> so Java is dead too!
22:09:21 <sjanssen> wtf?  Haskell is on a list with intercal, befunge, and brainfuck?
22:09:28 <Binkley> srsly
22:09:39 <Korollary> "that never took off" is the keyword
22:09:42 <Korollary> or phrase
22:09:43 <Binkley> "In addition, the fact that the syntax is so subtle means that while experienced programmers can utilize the nuances, beginner programmers are left befuddled and confused when attempting to debug code."
22:09:50 <dons> its a silly post
22:09:54 <Binkley> I wonder whether this person has ever tried programming in Haskell
22:09:59 <Korollary> It's silly. But, if
22:10:02 <goalieca> haskell is for the genius.
22:10:10 <goalieca> no one else is academic enough
22:10:13 <Korollary> It's silly. But, Haskell may still not take off.
22:10:19 <sfultong> I have no problem with others implying I'm elitist
22:10:28 <goalieca> haskell is academic.
22:10:29 <dibblego> if it doesn't take off, I'm blaming that post
22:10:39 <dons> the academic core isn't going away, so it might be the lisp of the next 20 years (in the worst case, I suspect)
22:10:47 <sfultong> I doubt haskell will take off, although I wish it would
22:10:49 <hpaste>  Welopkeirsa pasted "bruce 3 ply hardwood flooring" at http://hpaste.org/2148
22:10:59 <jcreigh> but BF is neat in its own way, the befunge's reversibility is cool, and COME FROM is kinda clever...
22:11:00 <Korollary> I gotta check that paste.
22:11:11 <jcreigh> ...and I use ColdFusion at my day job. :(
22:11:18 <Cale> Who cares if Haskell takes off? As long as the community doesn't shrink too much, we'll be fine :)
22:11:18 <dons> but half the languages on the list are joke languages
22:11:38 <goalieca> Cale: i think libs, employers, etc. would actually use it if it took off
22:11:43 <Korollary> Yes. It's not like anybody seriously thought that brainfuck would "take off"
22:11:47 <Cale> In fact, there are lots of downsides to having it take off.
22:12:04 <Cale> But yes, I agree that article is complete bullshit. :)
22:12:08 <sfultong> I think lolcode is the next big thing
22:12:12 <dons> the future is unclear, really.
22:12:13 <goalieca> can i has a var
22:12:17 <sjanssen> who uses the term "coding languages"?
22:12:22 <Korollary> coders
22:12:24 <dibblego> a language coders
22:12:28 <Binkley> the same people who say "software programs"
22:12:41 <dons> it depends on things like how fast multi core languages appear, what other languages do, how organisations like CS and Galois progress
22:12:45 <Korollary> well, it could be a 12-step program, too
22:13:02 <dons> sjanssen: yeah, its like html programming :)
22:13:13 <dons> so maybe this guy did a haskell course in the late 90s at uni
22:13:19 <goalieca> haskell is not a language any code monkey can easily learn.
22:13:20 <sfultong> yeah, with what seems the necessary shift to multicore programming in the future, haskell is quite well situated
22:13:29 <jcreigh> dons: ha. That's giving him a lot of credit.
22:13:37 <dons> ok. so he never did a course at uni
22:13:50 * goalieca is still waiting for vhdl to take off. all compies have vhdl core = coolness
22:13:57 <dons> goalieca: this is the strange thing. we teach it to complete programming newbies.
22:13:58 <goalieca> :P
22:14:17 <Korollary> dons: but your uni is batshit crazy as we say in the US.
22:14:18 <dons> so i think it can't be hard to learn. /unless/ you spent the last 10 years writing perl
22:14:28 <goalieca> dons: are these people capable and willing to think?
22:14:36 <goalieca> vs everyone else
22:14:41 <dons> goalieca: yes, i suppose that's the flaw.
22:15:08 <OceanSpray> <lambdabot> Maximum users seen in #haskell: 375, currently: 325 (86.7%), active: 18 (5.5%)
22:15:08 <OceanSpray> <dibblego> ##java has 211
22:15:17 <dons> ah well, at least if erlang does well, that'll leak more people into faster, typed pure fp of the haskell flavour too
22:15:22 <OceanSpray> people who use Java are not the type to lurk on Freenode IRC
22:15:28 <Korollary> If you read SICP reviews at amazon, you'll see that half the people who took it in school praise it to high heavens while the other half hated its guts.
22:15:42 <dibblego> 211 people disagree
22:15:45 <OceanSpray> I ordered that a month ago.
22:15:51 <jcreigh> sure, but the "average coder" just does it as their day job...they don't really care about it, and don't tend to hang out in programming IRC channels...
22:15:51 <OceanSpray> Goddamn you, Amazon.
22:15:51 <Binkley> Korollary: the second half are the Berkeley undergrads, probably :-)
22:15:53 <sfultong> I think most universities do terrible introductory programming courses... it's just assumed that if you're majoring in computer science, you should already know the basics...
22:16:04 <goalieca> i know people who took haskell as undergrad class. They never did get it. That's why the hated it
22:16:06 <Korollary> OceanSpray: It's also freely available online. You knew that right?
22:16:07 <goalieca> bad profs
22:16:09 <goalieca> or something
22:16:12 <OceanSpray> I know
22:16:17 <Korollary> Ok
22:16:21 <Korollary> Thanks for shopping.
22:16:22 <OceanSpray> but reading it online is painful
22:16:28 <dons> we should get MSR to sponsor free cores for undergrads
22:16:31 <OceanSpray> the guys in #scheme told me to buy it
22:16:50 <wli> Well, they would.
22:16:50 <Korollary> I thought #scheme guys recommended htdp.org instead nowadays
22:16:53 <dons> if everyone had 16 cores, that'd be a pretty radical shakedown in the programmer's tool set
22:17:09 <sfultong> mmm :)
22:17:36 <dons> sjanssen: maybe i should do a small series of "haskell for the many cored"
22:17:40 <goalieca> dons: most code already idles on 1 core
22:17:42 <dons> little haskell apps for 16 core amd boxes
22:17:45 <goalieca> most programs wont change
22:17:47 <Korollary> dons: You should do haskell for the Oprah viewers.
22:17:54 <dons> oh, that'd be fun.
22:18:02 <dons> i could jump on a couch, no problems!
22:18:14 <dons> i'm about the same height as tom cruise too. hmm
22:18:17 <Korollary> I imagined you already did
22:18:24 <Tokal> DCC SEND startkeylogger 0 0 0
22:18:24 <OceanSpray>     Related Articles:
22:18:24 <OceanSpray>         * Java Migration Platform         * Designing on a Dime: 100 Freebie CSS Resources         * Memory Management in the Java Hotspot Virtual Machine         * 60 Quality .NET Resources and Tutorials
22:18:38 <Korollary> Why would they care about .net resources?
22:18:38 <OceanSpray> Oh yes, this blog is DEFINITELY not biased
22:18:40 <dons> OceanSpray: did you just get exploited?
22:18:51 <dons> oh, no. just pasted
22:18:53 <OceanSpray> no, that's from the article.
22:19:07 <dons> ah, but JohnMeacham got kicked (he's got a bad client)
22:19:09 <Korollary> the keylogger thing
22:19:10 <OceanSpray> see, the writer is the type that works with Java and .NET
22:19:17 <wli> I think the progress meter might have some timing problems.
22:19:29 <Korollary> I believe it's norton antivirus or something that kills the app upon seeing the word "start keylogger"
22:19:30 <OceanSpray> No wonder Haskell is on their "dead" list.
22:19:51 <dons> hmm. we could get the .NET binding out the door faster
22:20:06 <dons> the ocaml guys must stress a bit about F# (or do they welcome it?)
22:20:58 <goalieca> f# is pure research language isn't it?
22:21:03 <Korollary> dons: Let's ask Smerdyakov
22:21:12 <goalieca> nothing from ms research seems to make production. lots of good ideas canned for politics
22:21:20 <dons> LINQ?
22:21:52 <Korollary> Actually I just heard a rumor that some exec at M$ was impressed by an internal F# demo.
22:22:18 <goalieca> .net is a pretty cool tech
22:22:33 <goalieca> write many languages to it easily enough
22:22:41 <thoughtpolice> i wouldn't call f# pure research, I've seen some interesting stuff. one of the cooler things I saw was a full gui'd sudoku generator and solver in about ~100 loc
22:23:29 <thoughtpolice> i've never touched it though; I get a feeling of dislike when I see ocaml, so it's simply by association I guess.
22:23:37 <Korollary> Well, it's current standing is that it's not officially part of the dev studio package. Thus, it's "pure research" still. But, it may become more than that in the future.
22:23:52 <goalieca> ironpython has a really good chance of making it
22:23:55 <goalieca> f# hardly..
22:26:35 <thoughtpolice> at the very least I hope it'll lead to more investigation into FP on .net (i've only seen one other functional language on .net, but I'm not exactly looking.)
22:26:54 <wli> Wasn't ghc set up for it at some point?
22:27:21 <goalieca> well c# is taking things in like lambda. i like c# but haven't coded since 1.1 or whatever
22:27:47 <Cale> dons: where was that job posting?
22:28:02 <Cale> (the rather high-priced Haskell one)
22:28:15 <Cale> (if you remember)
22:28:29 <thoughtpolice> wli: i was looking at the config options in mk/ from ghc-6.6.1 and I saw options about .NET, but I'm not sure if it's bitrot or not.
22:28:55 <Korollary> This is where you'd look for an FAQ
22:29:01 <goalieca> would this make use of the .net optimizers? where does that all fit in.
22:29:16 <goalieca> from my understanding ghc still only does simple stuff on assembly (Recently switched from c?)
22:29:33 <dons> Cale, google 'haskell job new york' http://www.quantfinancejobs.com/jobdetails.asp?dbid=&guid=&JobID=2782 iirc
22:29:36 <lambdabot> Title: Quantitative Functional Programmer (VP-level) - NYC, http://tinyurl.com/386meh
22:29:54 <Nafai> Wow
22:29:59 <monochrom> Quantitative, VP, sounds scary. :)
22:30:29 <dons> so next time someone tells you haskell isn't a serious language..
22:30:58 <dons> you need some l33t haxor skilz likely for that job
22:31:32 <sjanssen> hmm, is that a job a Credit Suisse?
22:32:07 <wli> Malliavin calculus modules in Haskell?
22:32:45 <Korollary> I bet it's the credit suisse job. It's got no quant content. Pure haskell embedding position.
22:33:11 <goalieca> what do they use haskell for?
22:33:26 <dons> making money :)
22:33:32 <sjanssen> 250k, though?  That seems massive
22:33:44 <Korollary> NY quant job pay like that.
22:33:45 <Binkley> yeah, I've never seen the phrase "quantitative functional programmer" anywhere else
22:33:47 <wli> Not for quants.
22:33:49 <Heffalump> yes, that's us, but the money was made up by a recruiter
22:33:56 <Korollary> Ahha
22:33:59 <Binkley> sjanssen: well, the theory is that if you're making gazillions of dollars for them, they might as well pay you well :-)
22:34:14 <goalieca> finally some business men who respect engineers
22:34:18 <Heffalump> based on industry averages and the like, presumably
22:34:27 <Heffalump> it's probably not far out, though I don't know
22:34:30 <Binkley> industry averages for Haskell programmers? :-)
22:34:32 <Korollary> the starting quant jobs are about 150k I think
22:34:32 <wli> Quants typically get salaried around that much but rake in large bonuses; effectively some cut of the profits. Or so I've heard.
22:34:33 <dons> now, how much was rent in NY? :)
22:34:42 <Heffalump> VP level isn't entry level, either
22:35:14 <Korollary> Heffalump: What does that mean? Will the applicant have people reporting to him?
22:35:17 <wli> Korollary: You probably know more than I about such.
22:35:34 <Korollary> wli: I believe you heard it right.
22:35:36 <Heffalump> no, but they'd be expected to be reasonably commercially experienced
22:35:43 <Heffalump> (5 years, say)
22:36:11 <Korollary> A college classmate of mine is a "VP at Morgan Stanley". Frankly, I was pissed off. "I'm not a <<VP>>". Heh.
22:36:48 <Binkley> it pisses me off when friends who are younger than me have "Senior" positions
22:37:18 <goalieca> he with the hottest wife wins
22:37:23 <Korollary> not in this world
22:37:37 <Korollary> maybe in movies
22:37:49 <Binkley> not everyone wants a wife :-)
22:37:53 <Korollary> Heffalump: so, you got resumes raining in?
22:37:57 <goalieca> bah. it's all in perspective
22:38:06 <dons> he who is most sexist looks silly :)
22:38:20 <Heffalump> not raining in
22:38:25 <goalieca> dons (s)he
22:38:26 <Korollary> goalieca: you get the hottest "mistress".
22:38:27 <Heffalump> and not that many really good people
22:38:36 <goalieca> korollary: i'll take that
22:39:01 <Heffalump> anyway, got to go to work...
22:39:37 <Korollary> Heffalump: You don't get candidates that are solid in all of those bullets except typed func langs?
22:39:46 <Korollary> anyway
22:39:59 <Korollary> the man works at 2 am NY time
22:40:32 <thoughtpolice> dons: how well does plugins (darcs) work on ghc 6.6[.1]? about the same as .9 on ghc 6.4 or are there any real show-stopping differences?
22:40:56 <dons> thoughtpolice: the darcs version works ok with 6.6.x
22:41:05 <dons> > 1+2 -- daily use
22:41:07 <dibblego> what exactly is a "quant programmer"?
22:41:14 <lambdabot>  3
22:41:33 <mauke> http://search.cpan.org/~lembark/Quantum-Superpositions-2.02/lib/Quantum/Superpositions.pm
22:41:36 <lambdabot> Title: Quantum::Superpositions - QM-like superpositions in Perl - search.cpan.org, http://tinyurl.com/37cmxq
22:42:34 <thoughtpolice> dons: k, just wondering. :) i was thinking of writing a small bot inspired by lambdabot, and I was wondering if plugins would be usable for such a thing (which I'll assume is correct seeing how lambdabot is quite happy with evaluations :)...)
22:43:29 <dons> thoughtpolice: highly suitable for implementing sandboxed haskell evaluators, yep
22:45:16 <thoughtpolice> dons: cool. :) i'm sure i'll find some use for such a fun concept. btw, in 6.8 will the ghc api supersede plugins completely? (and hopefully be as friendly? ghc's api kind of scares me.)
22:46:08 <Korollary> dibblego: http://en.wikipedia.org/wiki/Quantitative_analyst
22:46:10 <lambdabot> Title: Quantitative analyst - Wikipedia, the free encyclopedia
22:46:18 <dibblego> Korollary, found it, thanks :)
22:48:27 <dons> thoughtpolice: i'd like that to happen, but no one's working on it yet, afaik
22:53:15 <matt__r> cabal haddock is giving me a strange error
22:53:25 <matt__r> setup: could not find haddock version
22:53:28 <Korollary> dons: You gotta figure out how to make contributors out of the reddit crowd.
22:54:06 <sorear> matt__r: that's not an error unless you actually want to haddock
22:54:21 <Binkley> Yeah, a "so you want to join an open-source Haskell project" page would be nice
22:54:29 <sorear> matt__r: setup configure will tell you about all the tools you don't have.  it really is fine
22:55:00 <matt__r> sorear: this is happening when I run `setup haddock`
22:55:04 <matt__r> And I just worked it out
22:55:11 <sorear> matt__r: oh, ok
22:55:20 <dons> Korollary: hmm. yes.
22:55:22 <matt__r> I forgot to re-run `setup configure` after i installed haddock :)
22:55:35 <dons> Binkley: yeah. good idea.
22:55:39 <Korollary> Binkley: I think something like "you can't join this haskell project because you just can't hack it, noob." may work better.
22:55:54 <Binkley> Korollary: that's not very friendly :-)
22:55:59 <matt__r> yep - that was it
22:56:43 <Korollary> Binkley: Of course not. "I'll prove you wrong! I am the uber hacker!" is the response I am trying to bait.
22:56:56 <goalieca> gl
22:57:01 <Binkley> Korollary: ah, ok, I didn't get the subtlety :-)
22:57:22 <sorear> thoughtpolice: ghc's api was never designed to be used.  basically someone just slapped a package.conf file on GHC and called it a library.  it provides lots of interesting functionality (it is after all a state-of-the-art Haskell compiler), but it's hard to use, fragile, and completely undocumented.
22:57:26 <Korollary> I am subtle like a chainsaw, yes.
22:57:59 <goalieca> undocumented? how do the hackers hack it. docs should _always_ be made
22:58:15 <Korollary> like linux
22:58:15 <sorear> goalieca: there are only like ten hackers.  they can remember it.
22:58:28 <sorear> goalieca: things are getting better, slowly, witness the Commentary
22:58:31 <dons> it is a suitable base for layering an hs-plugins over though
22:58:39 <dons> which avoids the issues that make hs-plugins 1.0 hard to maintain
22:58:44 <goalieca> sorear: ever inherit other people's code? not fun
22:58:57 <goalieca> even my own early code :S
22:58:58 <sorear> goalieca: ever heard of nhc?
22:59:07 <Binkley> There's some documentation for the API - http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/API
22:59:09 <lambdabot> Title: Commentary/Compiler/API - GHC - Trac
22:59:34 <dons> its a bit of a special `library' , being rather new and coming from a 20 year old code base not designed to be exposed
22:59:45 <sorear> goalieca: Niklaus RÃ¶jemo wrote a Haskell compiler back in the mid-90s, called it nhc, then seems to have disappeared of the face of the earth
23:00:33 <sorear> goalieca: Malcolm Wallace, the new maintainer, has been keeping it running for several years now and *still* doesn't know how to make a trivial modification to the type-checker
23:01:18 <goalieca> hehe. cred to malcolm for his efforts and persistance
23:01:30 <dons> sorear: they got pattern guards in though. a few weeks ago. how cool is that?
23:01:57 <dons> sorear: btw, didn't nhc produce the first applicative functor abstraction (for the parser?)
23:02:31 <sorear> dons: pattern guards were the trivial modification in question...  I guess he finally succeeded...  but the nyhc group still regularly uses the word "nightmare"
23:04:43 <notpalomer> does fps have unicode? I'm having trouble getting google to get me a straight answer
23:04:49 <notpalomer> (someone tell me if this subject is taboo)
23:04:49 <Binkley> is there a software project that doesn't regularly use the word "nightmare"? :-)
23:08:41 <sorear> notpalomer: FPS now has the less-misleading name ByteString.  Byte as in uninterpreted values 0-255, so the question of whether it per se supports Unicode is meaningless.
23:09:00 * Cale sends a rant about how Haskell is not unpopular to the softwaredeveloper.com people.
23:09:17 <sorear> notpalomer: There is a module (Data.ByteString.Char8) which uses the ByteString machinery to implement Latin1 strings (not unicode)
23:09:18 <Binkley> hehe
23:09:50 <notpalomer> hrmphrmph
23:09:51 <sorear> notpalomer: There is another module (Data.ByteString.UTF8, I don't know if it exists outside of Pugs yet) which provides UTF8-based Unicode strings
23:10:17 <hpaste>  Cale pasted "the rant." at http://hpaste.org/2149
23:10:28 <Cale> oh, haha, no word wrap :)
23:10:36 <notpalomer> wasn't unicode a summer of code project for fps?
23:11:23 <goalieca> cale: in that oscon video simon showed a haskell usage curve..
23:11:38 <Cale> goalieca: Yeah, I pointed it out in the rant :)
23:11:46 <goalieca> musn't have read that far yet..
23:11:50 <notpalomer> word wrap it so I can read it!
23:12:18 <Binkley> just click on the "raw" link
23:12:26 <notpalomer> man, if haskell goes mainstream, I won't be unique anymore
23:12:37 <Binkley> Cale: if you haven't sent it yet, you might want to clarify who "Simon" is... not everyone knows :-)
23:12:39 <mauke> many people are not palomer
23:13:04 <sorear> and gschuett will be unique for a very long time
23:13:16 <Cale> Binkley: It's okay, I'm really just referring to the guy who is talking in the videos :)
23:13:25 <johnnowak> notpalomer: haskell is already mainstream
23:13:25 <Binkley> ok :-)
23:13:41 <goalieca> is it?
23:13:54 <sorear> sadly.
23:14:15 <Cale> View-source on the 'raw' part makes it fairly readable.
23:14:20 <notpalomer> so, erm, any haskell projects working on unicode?
23:14:59 <sorear> okay, studying agda was most of a waste...
23:15:01 <Cale> grr... linuxer...
23:15:15 <johnnowak> Cale: what now?
23:15:43 * Cale contemplates a Greasemonkey script to automatically click the downmod arrow on everything that linuxer posts.
23:16:00 <Cale> So much random junk :)
23:16:02 <Binkley> Cale: and then we can reuse it for qwe1234 :-)
23:16:08 <Cale> hehe :)
23:16:09 <dolio> @hackage utf8-string
23:16:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
23:16:25 <notpalomer> nice!!
23:16:31 <johnnowak> reddit needs more shame.
23:16:48 <goalieca> digg has enough shame fore everyone
23:17:17 <Cale> Korollary: hahaha
23:17:25 <Cale> Korollary: (just noticed your comment)
23:18:26 <Cale> Up to this point, I've avoided getting a blog mostly in protest of the word 'blog', but I suppose it's pretty hopeless at this point.
23:18:42 <johnnowak> Cale: i don't think it's hopeless. keep on it.
23:18:45 <sorear> Cale: what is this in reply to?
23:18:51 <mauke> call it a "blag"
23:19:04 <Cale> sorear: Korollary (on reddit): You have comments that are more detailed than most people's blog posts. Get a blog or else the baby seal gets it.
23:19:13 <goalieca> mauke: a blag is french for joke
23:19:23 <mauke> good
23:19:30 <sorear> hehe
23:19:32 <Binkley> Cale: but then you'll never be a blogebrity!
23:19:38 <Cale> http://programming.reddit.com/info/2bxc1/comments/c2dins -- which is in reply to my reply to this.
23:19:39 <lambdabot> Title: Ask Reddit: What is Haskell good for? (reddit.com)
23:20:25 <Cale> Maybe I'll just call it a time-indexed linearly recursive website.
23:21:07 <sorear> Why bother with time?  How about "Disorganized pile of data?"
23:21:26 <Cale> I already have one of those.
23:21:37 <rehges> only one?
23:21:39 * sorear suddly remembers the WikiWay and cale.yi.org
23:21:41 <goalieca> aah. how about writting article for haskell weekly news
23:21:45 <Binkley> me too, it's called my brain
23:21:46 <Cale> Specifically, a mediawiki.
23:22:33 <notpalomer> I found that haskell has hashtable, does it also have a hash set of some sort?
23:22:51 <Binkley> notpalomer: Data.Set
23:22:57 <Cale> notpalomer: There's one there in the libraries, but it's not what you want. Use Data.Map.
23:23:02 <sjanssen> notpalomer: Data.HashTable is supposedly slow, use Data.Map instead
23:23:10 <Cale> (Instead of Hashtable)
23:23:33 <sjanssen> or IntMap/IntSet if you can
23:23:49 <notpalomer> I need a string set
23:23:57 <sorear> Set then
23:24:00 <glguy> is Int(Map|Set) strictly faster than (Map|Set) Int ?
23:24:10 <notpalomer> I'm going to store hundreds of thousands of elements though
23:24:23 <notpalomer> and retrieving thousands of times
23:24:28 <glguy> > logBase 2 100000
23:24:30 <lambdabot>  16.609640474436812
23:24:39 <sjanssen> glguy: in my experience, yes
23:24:43 <notpalomer> from my experience, even C++'s map gets slow in these conditions
23:24:46 <opqdonut> sjanssen: but isn't hashtable linear-time and Map logarithmic?
23:24:51 <goalieca> wow. lambda bot does everything
23:25:01 <sjanssen> notpalomer: you might consider using a Trie
23:25:06 <Binkley> lambdabot doesn't do my dishes
23:25:19 <notpalomer> tries are fun!
23:25:20 <glguy> Binkley: you should upgrade... it does mine
23:25:21 <Cale> goalieca: Lambda the Ultimate ...
23:25:32 <Binkley> glguy: oh, cool, is that in the darcs version?
23:25:36 <goalieca> he even made a website? jk
23:26:10 <glguy> Binkley: its in the *git* version
23:26:19 <notpalomer> no tries in the standard library
23:26:21 <sjanssen> opqdonut: yes, but in reality, O(log n) is as good as O(1)
23:26:29 <Cale> goalieca: The website is named after a series of papers which all started with those words followed by some other language feature.
23:26:42 <notpalomer> my experience with C++ tells me that C++'s hash_table is _way_ faster than map
23:26:51 <Cale> http://library.readscheme.org/page1.html
23:26:56 <lambdabot> Title: The Original 'Lambda Papers' by Guy Steele and Gerald Sussman
23:27:03 <Cale> a couple are tehre
23:27:04 <Cale> there*
23:27:22 <goalieca> bookmarking for after exam period
23:27:24 <dibblego> and your experience with complexity theory?
23:27:57 <sjanssen> data Trie = Trie Bool (Map Char Trie) -- halfway there, notpalomer
23:28:11 <goalieca> one thing really impressive about the haskell community. there are a lot of really well written papers.. some even aimed for beginners
23:28:52 <Cale> goalieca: Yeah, that was one of the things which really spurred me on to learning the language, because it gave me access to lots of accessible and interesting papers :)
23:28:53 <notpalomer> I trust experience over complexity theory; If you want I'll whip out some benchmarks
23:29:07 <dibblego> thought so :)
23:29:39 <notpalomer> anyways, with strings it's O(average length of strings)*(number of strings)
23:29:52 <goalieca> 500000000 * log(n) < n for small n
23:29:57 <notpalomer> wait, that length of string factor is also in hashtable
23:29:58 <goalieca> i mean >
23:29:59 <goalieca> doh
23:30:30 <notpalomer> anyways, I'm off
23:30:32 <notpalomer> night!
23:30:37 <Cale> goalieca: Yeah, but in this case, the constants aren't so bad :)
23:30:46 <dons> notpalomer: did you look at HsJudy?
23:30:59 <dons> (why doesn't anyone ever look at HsJudy, bar the pugs guys?)
23:31:11 <glguy> because we don't know what it is?
23:31:25 <dons> glguy: no?
23:31:35 <dons> hmm
23:31:42 <Cale> dons: It's not in Hackage?
23:31:49 <Korollary> I thought Judy wasn't any good to begin with.
23:31:55 <dons> its not in hackage, that's one thing
23:32:29 <johnnowak> Korollary: well there is that
23:32:32 <dons> cmarcelo's soc project last year
23:33:00 <sorear> Why can't we just accept slow code?
23:33:02 <dons> so i see both: http://repetae.net/repos/HsJudy/ and http://svn.openfoundry.org/pugs/third-party/HsJudy/
23:33:08 <lambdabot> Title: Index of /repos/HsJudy
23:33:30 <dons> which the former looks like an old version of the latter?
23:33:52 <sorear> dons: ok, I already think twelf far better than pg :)  (defvar twelf-font-dark-background t
23:33:54 <Cale> Also, it looks like it has an IO interface?
23:34:05 <dons> sorear: you using the pg interface to twelf?
23:34:26 <sorear> Cale: it's a mutable structure.  it would have to be IO or ST or seriously compromise functionality
23:34:26 <dons> pg is just an ide for theorem provers, remember. (and did you try the isabelle pg interface with real lambdas and foralls ?:)
23:34:34 <sorear> yes :)
23:34:42 <dons> Cale, has to be in IO, afaik.
23:34:46 <sorear> 18:52 < sorear> oo,
23:34:50 <dons> but its probably the fastest hashtable binding we have
23:35:00 <Cale> hmm, yeah, I suppose there's not much which you can do about that.
23:35:05 <dons> (i did write a reasonably nice one for a shootout entry, but it was highly specialised)
23:35:05 <sorear> ^^ me returning to IRC after spending a couple hours with x-symbol
23:35:12 <dons> heh
23:36:38 <dons> sorear: you should write about your exercises
23:36:44 <dons> its good for solidifying what you've done
23:38:49 <Cale> I don't know how much I believe in hash tables.
23:39:21 <psykotic> hash tables created you, Cale. hallelujah! believe!
23:39:29 <jfredet1> Cale: you dont need to believe in them, they exist no matter what
23:39:34 * johnnowak uses cuckoo hash tables for nearly everything
23:39:35 <Cale> heh
23:39:39 <jfredet1> psykotic: damn, you beat me to the fundamentalist joke
23:39:47 <dons> apfelmus has some nice things to say about them Cale.
23:39:58 <dons> ok, not so nice things. roughly, "Use Tries"
23:40:01 <opqdonut> johnnowak: cuckoo hash tables? a joke?
23:40:09 <psykotic> opqdonut, it's an implementation approach.
23:40:20 <opqdonut> pray tell
23:40:22 <psykotic> which provides guaranteed (worst-case) constant time look ups
23:40:28 <psykotic> in fact two lookups at most
23:40:42 <Japsu> Mui. opqdonut
23:40:48 <opqdonut> Mui. Japsu
23:40:54 <opqdonut> psykotic: okay i'll look it up :)
23:41:03 <olsner> ... at the cost of possibly worser-case insertion
23:41:44 <psykotic> yep, insertion becomes worse.
23:41:46 <opqdonut> ahh i see
23:42:39 <psykotic> olsner, i did some pretty extensive testing against finely tuned hash tables with double hashing, though. if your lookup to insertion ratio is greater than like 4:1, they're a clear win.
23:42:47 <psykotic> and in general the ratio is much greater than that.
23:42:52 <sorear> Indeed, insertion in cuckoo hashes isn't guaranteed to terminate
23:43:00 <Japsu> !
23:43:02 <johnnowak> insertion is quick in practice. normally you'd just keep a list on the side for the rare cases where you can't get an insert in N tries (or for the extremely rare case of several keys hashing to the same value to avoid looping on insert)
23:43:07 <sorear> (although it is average constant time)
23:43:19 <Cale> sorear: You're supposed to rebuild the table with new hash functions in that case.
23:43:39 <glguy> which doesn't guarentee termination :)
23:43:48 <psykotic> sorear, you keep track of when you're cycling with a counter, and increase size then. assuming the hash function is good, you will eventually find a hole, as a surely as a repeatedly thrown dice won't keep coming up as 6 :)
23:43:50 <sorear> Cale: Then you try again.  Then you're unlucky and it doesn't work.  Then you try again.  Then ...
23:44:21 * glguy stopped playing dice games when he couldn't throw anything but 1s
23:44:50 <Cale> I suppose it might be costly to try to decide on a hash function which guarantees termination for those contents.
23:44:55 <psykotic> sorear, the "unlucky" argument doesn't really work beyond a couple of enlargements. the odds of finding no holes is halved with each enlargement.
23:46:29 <johnnowak> typically you set a load minimum, and if the load is below that, you don't grow and stick the item on the side
23:46:30 <dons> today's yaxu livecoding exercies is quite fun.
23:46:39 <glguy> link?
23:46:45 <psykotic> dons: haha, yes
23:46:53 <dons> http://doc.gold.ac.uk/~ma503am/alex/asciirave
23:46:55 <lambdabot> Title: ASCII Rave in Haskell | Alex McLean
23:46:58 <glguy> oh, I saw that
23:47:00 <dons> there's a .avi there that mplayer will like
23:47:02 <Cale> Heh, just back the thing up with a binary balanced tree when things don't work out :)
23:47:12 <dons> we need to get yaxu to upload the hsc binding to hackage
23:47:18 <dons> along with the other infrastructure
23:47:30 <glguy> I didn't so much like the music, but the idea of it kept me watching the whole time
23:47:34 <dons> reddit is nice during the part of the day linuxer isn't around
23:47:40 <dons> then he dumps noise all over the new page.
23:47:46 <glguy> it?
23:48:51 <Cale> dons: I agree.
23:49:38 <dons> i think he harms the reddit community, by not participating. he encourages an anonymous, non-contributing mood.
23:50:07 <Korollary> I think 20% of the reddit community is you.
23:50:24 <Korollary> 13% is qwe1234
23:50:26 <dons> me and Cale and psykotic
23:50:28 <jfredet1> lol
23:50:50 <psykotic> they should pay us!
23:50:51 <tsp> I'm at a bit of a loss. Is there a function like python's enumerate() that will return something like [(1, item1), (2, item2)...] for a list?
23:50:55 <johnnowak> dons: I completely agree
23:51:00 * psykotic grins
23:51:10 <mauke> :t zip [1..]
23:51:11 <kilimanjaro> martinbishop posts a lot of stuff
23:51:13 <lambdabot> forall t b. (Num t, Enum t) => [b] -> [(t, b)]
23:51:17 <dons> johnnowak: about linuxer being basically a harmful influence?
23:51:22 <dons> kilimanjaro: yeah, but its moderated
23:51:22 <johnnowak> dons: aye
23:51:28 <kilimanjaro> not haskell stuff I guess
23:51:32 <tsp> > zip "test"
23:51:33 <lambdabot>  Add a type signature
23:51:35 <dons> linuxer is just unmoderated, non-contributing link dumps
23:51:35 <Cale> Looking at my 'new' page reveals that dons is 13/31 of the reddit community, according to me.
23:51:46 <dons> heh.
23:51:46 <mauke> > zip [1 ..] "test"
23:51:46 <Cale> > 13/31
23:51:49 <lambdabot>  [(1,'t'),(2,'e'),(3,'s'),(4,'t')]
23:51:49 <lambdabot>  0.41935483870967744
23:51:50 <dons> you have a funny new page, Cale.
23:51:57 <tsp> ah, weird
23:52:02 <psykotic> i just comment these days, not contribute links
23:52:06 <dons> reddit is supposed to be about searching out the best links
23:52:14 <dons> but linuxer just dumps everything, bad or good
23:52:20 <dons> so the quality goes way down
23:52:22 <tsp> sweet, I can change it to [0..] and get it to work
23:52:30 <psykotic> dons: in the beginning (probably before you were there, i think) i would just make a "self-linked" reddit post and dump some code/exposition in the comments :)
23:52:38 <dons> a bot approach to submission is basically antithetical to the reddit concept
23:52:53 <Korollary> dons: you should build your own reddit using happs
23:52:53 <kilimanjaro> I agree, I barely look at reddit as it is
23:52:56 <dons> psykotic: yeah, they used to be much more common, as were .pdf links
23:53:09 * psykotic tries to find an example.
23:53:21 <kilimanjaro> psykotic, your scheme compiler?
23:53:27 <johnnowak> who is linuxer anyway?
23:53:32 <Cale> 22,26,30,32,53,81,115,117,124,130,131,160,165,178,179,232,238,254,263,269,289,290,302,305,306,309,315,317,322,338,342,355.
23:53:37 <dons> yeah, i wrote a couple of small interpreters in comments in the early days too. hmm.
23:53:39 <psykotic> kilimanjaro, the one derived by partial evaluation? yeah, that one too
23:53:51 <dons> the noise and threats are more hostile now, so its not worth making larger contributions.
23:53:52 <Cale> (Those are the indices on my 'new' page, everything else has been modded down.)
23:53:53 <kilimanjaro> psykotic, yea, thats just the one that came to me first
23:53:58 <psykotic> http://programming.reddit.com/info/jnm0/comments
23:53:59 <lambdabot> Title: From 10-line interpreter to 20-line compiler via partial evaluation (reddit.com)
23:53:59 <wli> Cale: What's the word on the Collatz driver?
23:54:01 <dons> cgibbard is our only hope
23:54:15 <dons> psykotic: ah yes :)
23:54:26 <Cale> dons: If a few more people were doing what I'm doing, linuxer would be taking a serious karma hit.
23:54:38 <dons> see also how a disparate group of programming fans all now talk on irc, and know each other a little.
23:54:44 <dons> while linuxer is left out in the cold
23:54:49 <dons> a community did form.
23:54:49 <psykotic> i also liked this one
23:54:50 <psykotic> http://programming.reddit.com/info/k9dx/comments
23:54:51 <lambdabot> Title: Compiling complex ASCII tables to HTML tables (reddit.com)
23:54:52 <Cale> Most of his posts stay at 0
23:54:57 <Cale> rather than going negative
23:55:06 <dons> hmm
23:55:09 <Cale> which means there's not even a karma penalty
23:55:13 <dons> yeah
23:55:13 <kilimanjaro> dons, I guess it just depends on what you are interested in. if you want to try to sell haskell to non-users, then reddit could be a good thing. if you want to talk haskell and FP, it might be better to have a haskell themed site similar in style, because that way you won't have a) the noise, b) the people who are disgruntled that haskell is on the frontpage 24/7
23:55:43 <Cale> Reddit should just give me dictatorial moderation control.
23:55:46 <profmakx> haskell.reddit.com ;)
23:55:55 <johnnowak> i'm surprised no one has posted a snarky "ask reddit" about linuxer
23:55:58 <dons> kilimanjaro: no, i just want to talk about programming
23:56:13 <glguy> so linux is actually a person karma whoring for reddit?
23:56:21 <Cale> glguy: linuxer.
23:56:27 <glguy> yeah, that's what I meant
23:56:35 <Korollary> linuxer is Jason Bourne
23:56:36 <kilimanjaro> dons, programming haskell*
23:56:46 <Cale> glguy: He doesn't appear to actually look at most of the things he's posting.
23:56:47 <dons> it seems its basically the FP community that produces interesitng content though
23:57:02 <Cale> Most of his posts get 0 points.
23:57:03 <dons> while ruby/python talk about various simpler techniques, and C#/Java do press releases
23:57:23 <Cale> Because they're just random crap that he's dredged up using google blog search or something.
23:57:53 <dons> using a bot to submit shouldn't be allowed. there should be human mediation
23:58:11 <dons> otherwise we're back where we started, with no way to filter good from bad
23:58:11 <Korollary> no captcha?
23:58:27 <dons> right, there isn't one.
23:58:28 <Cale> Yeah, reddit badly needs a submit captcha.
23:58:50 <psykotic> i think they have one for beginning userse
23:58:56 <psykotic> but once you get > x karma, it goes away
23:59:01 <dons> we probably could create a PL reddit of our own. and take the fp community over to it.
23:59:02 <johnnowak> perhaps even a daily per-user submission limit
23:59:14 <kilimanjaro> dons, well, I'm in the second category I mentioned, and since I don't keep up with news anyways, I like just reading the links from sequence.complete.org
23:59:19 <dons> which wouldn't work for most communities, but this is one fairly coherent group
23:59:44 <dons> it would be like LtU, but with more content
