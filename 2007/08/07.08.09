00:00:01 <johnnowak> that's something i'd like to see
00:00:03 <Cale> And not so cold and sterile :)
00:00:04 <Korollary> more code
00:00:04 <dons> and the programming subreddit would turn into a weird place
00:00:14 <johnnowak> Cale: hey, i like cold and sterile.
00:00:29 <Korollary> LtU papers are very heavy
00:01:15 <dons> then again, do we want to take our ball and go home? there's benefits to talking in a visible forum.
00:01:21 <Cale> Also, for some reason, a lot of what gets posted on LtU, I just don't find all that interesting for some reason.
00:01:28 <Cale> er, heh
00:01:37 <Korollary> dons: there's no reason you can't submit interesting links still to reddit.
00:02:04 <johnnowak> linuxer will just resubmit everything anyway
00:02:07 <dons> Korollary: yeah, links could go to both places, and just have the real conversation over on applyit.haskell.org or something
00:02:20 <psykotic> ltu has jumped the shark
00:02:23 <Korollary> yeah, you can leave it all to linuxer heh
00:02:25 <dons> psykotic: yeah.
00:02:34 <dons> and the programming subreddit isn't a good replacement.
00:02:40 <Cale> I also really wish that people could republish their views of reddit.
00:02:41 <johnnowak> hehe, applyit
00:03:06 <dons> we need a small code base like pg's ycombinator site, take that, give it a domain, and drag the reddit grad student crowd over
00:03:27 <dons> and actually try to build a community
00:03:39 <dons> unlike the reddit guys, who don't give a toss about the `community'
00:03:55 <Korollary> you commie bastard
00:03:57 <dons> so hmm. ltu 2.0 :)
00:04:24 <dons> i think till today i didn't see that it could work.
00:04:40 <psykotic> honestly i like it pretty much like it is. i think making it feel more academic would be a clear lose.
00:04:44 <dons> usually when people point out that they coudl rewrite reddit in like 2 hours, people say, yeah, but you don't have the community
00:04:59 <dons> while i'm pretty sure we could take the community with us
00:05:04 <psykotic> what makes it useful for me is that there's a good mix of people. with that comes people you'd rather not have, but i wouldn't want to throw the baby out with the bathwater.
00:05:23 <dons> psykotic: hmm. i'm not sure it would be more academic, just there'd be an incentive to actually talk on the site.
00:05:30 <dons> which had declined on reddit
00:05:32 <Korollary> Well, there's this LtU wiki that still doesn't exist where you can point to articles on static vs dynamic and assorted madness and end meaningless threads.
00:05:37 <johnnowak> psykotic: i think it's at the point now where people are avoiding talking
00:05:39 <dons> psykotic: yeah, you need the mix.
00:05:46 <psykotic> dons: i just mean that i'm afraid it would be a sort of incrowd-ish ivory tower circle jerking place
00:05:54 <dons> yeah. that's the problem.
00:05:56 <psykotic> "haskell is awesome!"
00:05:58 <kilimanjaro> psykotic, like IRC? :D
00:06:00 <psykotic> :)
00:06:12 <Korollary> card carrying elitist bastards
00:06:25 <dons> psykotic: but the C# / Java guys are so *boring*
00:06:26 <|Steve|> What is LtU?
00:06:29 <Korollary> read this site for 250k quant jobs
00:06:33 * glguy wants the physical card
00:06:34 <dons> and the ruby guys don't know what continuations are
00:06:41 <sieni> |Steve|: Lambada the Ultimate
00:06:45 <dons> Korollary: nice idea!
00:06:46 <psykotic> dons: there aren't that many of those though. although there are a lot of python, ruby, erlang, etc hackers, who have their own useful perspective on things.
00:06:50 <|Steve|> hmm
00:07:03 <|Steve|> Doesn't ruby have some strange iterator ideas?
00:07:27 <Korollary> What you call "production" languages have pretty much things nailed down.
00:07:42 <dons> hmm.so basically because reddit doesn't act at all to help out the community that uses their site, by getting rid of trolls and bots, we're considering forking the whole thing.
00:07:43 <psykotic> dons: ruby has callcc :)
00:08:03 <dons> i'd love to see some articles on callcc in ruby
00:08:08 <dons> or anything elegant or instructive
00:08:12 <dons> by anyone, really.
00:08:14 <|Steve|> Ugh. I never wrapped my head around why I'd want to ever use call/cc in scheme.
00:08:16 <psykotic> i don't think rubyists use it, really
00:08:30 <kilimanjaro> |Steve|, backtracking
00:08:49 <kilimanjaro> |Steve|, implementing threads and stuff like that
00:09:03 <dons> ok, so we'll hang out on the subreddit for a couple more months, then glguy and i will write a community-oriented LtU 2.0
00:09:03 <johnnowak> |Steve|: at some point, you wonder how you ever got by without it
00:09:05 <kilimanjaro> exceptions, etc
00:09:10 <dons> what do you think, glguy ?
00:09:25 <|Steve|> I suppose. I've done quite well in other languages without it.
00:09:30 <dons> and you get to ban trolls and bots
00:09:35 <kilimanjaro> I don't think people use call/cc very often, but it comes up from time to time in library code
00:09:37 <glguy> dons: I think we could  ge tsome Irad money for it
00:09:44 <kjdf> it is scheduled for removal I think
00:09:47 <kjdf> callcc in ruby
00:09:57 <dons> glguy: hmm?
00:10:07 <glguy> internal research & dev
00:10:09 <dons> i was just thinking we'd whip it up over a weekend.
00:10:09 <psykotic> |Steve|, on the haskell tip, there's a really nice paper by claes (i think) about how to do implement cooperative user threads with custom schedulers, etc in the haskell ContT.
00:10:12 <dons> ah. i see.
00:10:13 <kilimanjaro> |Steve|, yea, but if you were writing much systems code you would have used it by now
00:10:16 <glguy> galois self funded project :)
00:10:37 <dons> i'd do it for free :) but yeah, it would benefit galois too. hmm.
00:10:43 <dons> do they want to be the new y-combinator? :)
00:10:44 <|Steve|> kilimanjaro: I don't write systems code in functional programming languages, nor does anyone else.
00:10:50 <psykotic> dons: argh, what's the name of that haskell hacker/researcher? klaes/claes?
00:10:54 <kilimanjaro> |Steve|, they do in Scheme
00:10:58 <dons> claussen?
00:11:01 <dons> koen?
00:11:09 <dons> ?go poor man's concurrency monad
00:11:09 <psykotic> koen claussen, right
00:11:10 <lambdabot> http://www.cs.chalmers.se/~koen/pubs/jfp99-monad.ps
00:11:10 <|Steve|> kilimanjaro: For what?
00:11:14 <tsp> I have a wimpy little haskell program I'm trying to write, but I'm not sure where I'm getting stuck. I'm trying to do the string-to-huge-number thing that I finally figured out to do with these two lines:
00:11:18 <tsp> let getNumberToAdd (s, n) = n*(256^s)
00:11:18 <tsp> let convert (h:t) i = getNumberToAdd i (ord h):convert t i+1
00:11:31 <tsp> but convert doesn't want to work
00:11:37 <glguy> dons : dunno but isaac seemed to have some open spurced project ideas
00:11:59 <kilimanjaro> |Steve|, one of the first fully featured lexically scoped lisp dialects (the T language, this was in the mid 80s) had it's garbage collector written in T Lisp
00:12:16 <|Steve|> What does that have to do with systems?
00:12:18 <tsp> damn
00:12:18 <Korollary> tsp: What is getNumberToAdd's arity? The number of arguments don't seem to match.
00:12:30 <tsp> Korollary: lol, after hearing the function like 3 times :)
00:12:36 <kilimanjaro> |Steve|, implementing a language runtime is like implementing half of an operating system
00:12:45 <psykotic> tsp: also, you need a termination case for convert, where the first argument is []
00:12:49 <|Steve|> I don't buy that at all.
00:12:50 <wli> Oh dear. My collatz code is dogslow.
00:12:54 <dons> glguy: ok. this seems like something we could actually do, and have it work.
00:13:05 <wli> I wonder why.
00:13:07 <dons> since we've got both the web skillz, and a ready-made community
00:13:09 <tsp> psykotic: if I don't add the termination case, it'll never end?
00:13:21 <psykotic> tsp: well, it will spit out an error :)
00:13:25 <psykotic> it won't loop indefinitely
00:13:27 <glguy> dons : yeah, you might have something
00:13:29 <dons> glguy: seriously, i think we could replace LtU with only a little work.
00:13:34 <wli> Cale's obvious solution runs in under 1s, mine takes almost 30s.
00:13:43 <dons> but, we'll put this on the backburner, and talk about it in a month or two
00:13:46 <kilimanjaro> you have processes, memory management, packages and namespace (sort of like files). It's not the same thing, but there are a lot of similarities and people have gotten mzscheme running as an OS using just a couple of bootstrap utilities from FluxOS toolkit
00:13:47 <Cale> wli: hmm
00:13:55 <kilimanjaro> |Steve|, oops, that reply was to you
00:13:56 <Cale> wli: My solution?
00:14:07 <wli> Cale: http://hpaste.org/2141
00:14:08 <Korollary> dons: you don't mean to replace LtU, though. It's the "pragmatic PLT" version as opposed to research papers version.
00:14:25 <wli> Cale: (I altered it to get the upper bound from getArgs)
00:14:29 <Cale> Ah, you must have a fast machine :)
00:14:43 <tsp> hmm, this won't even compile
00:14:46 <tsp> let convert (h:t) i = getNumberToAdd (i,(ord h)):convert t i+1
00:14:46 <|Steve|> kilimanjaro: I don't see how you have processes at all? Memory management yes, but not of the sort like managing a TLB.
00:15:00 <tsp> it gives some weird error about the 1 being out of place
00:15:01 <wli> I mostly deal with TLB crap.
00:15:03 <|Steve|> No IPC, no talking to hardware, etc.
00:15:06 <Cale> convert t i+1 = (convert t i)+1
00:15:16 <kilimanjaro> |Steve|, most Scheme implementations, as well as Erlang and probably a bunch of other languages implement user-level threads and processes
00:15:23 <dons> Korollary: yeah. it would be the place to find what's new in PL, theory and practice, not just research
00:15:31 <wli> Cale: http://holomorphy.com/~wli/Collatz2.lhs
00:15:39 <Cale> tsp: my guess is that you wanted parens around (i+1)
00:15:42 <tsp> ah
00:15:43 <dons> i.e the programming subreddit, without trolls and bots
00:16:12 <Cale> wli: Well of course it takes longer, there's so much more code to run ;)
00:16:35 <Cale> Hmm, Data.Progress...
00:16:42 <Cale> I don't think I'd heard of that :)
00:16:45 <kilimanjaro> |Steve|, well, I still consider language runtimes to be systems code
00:16:46 <tsp> there we go. How do I make convert [] n kill the generator?
00:16:58 <glguy> wli: you guys are talking about project euler problem 14?
00:17:06 <|Steve|> kilimanjaro: Sure, but it's hardly half of an OS.
00:17:09 <Cale> tsp: convert [] n = [], perhaps?
00:17:18 <wli> Cale: The algorithm is essentially the same. Anyhow, it was mostly an exercise in learning Data.Progress, but now I'm curious as to why it's so much slower.
00:17:29 <kilimanjaro> |Steve|, it's the easy half
00:17:52 <tsp> weird, it won't work again
00:18:12 <Cale> What is Data.Progress, anyway?
00:18:29 <wli> glguy: The Collatz problem one? Sort of. It's kind of long-dead, except that I fiddled with Data.Progress for my implementation and am now wondering why it's 2 orders of magnitude slower than Cale's solution to begin with.
00:18:38 <wli> Cale: Progress bar type thing.
00:18:49 <psykotic> is it a continuation monad?
00:18:53 <wli> 8%                                                         44.56k numbers/s 20s
00:18:58 <Cale> Is it in Hackage?
00:19:07 <wli> Cale: Yeah, MissingH even.
00:19:10 <Cale> oh
00:19:12 <Korollary> |Steve|: There's an OS being developed in Haskell, called House. I don't know much about it, though.
00:19:44 <wli> Korollary: I think they're implementing something else and only used House as a proof of concept.
00:20:23 <wli> Cale/glguy: The progress bar bits didn't change the running time significantly.
00:20:39 <psykotic> kilimanjaro, btw check out that paper don linked to, poor man's concurrency monad.
00:20:52 <tsp> there needs to be something in haskell that will tell a generator such as this to stop. I tried convert [] n = [], but it gave me a non-exhaustive pattern error :)
00:20:54 <psykotic> kilimanjaro, the idea isn't anything you haven't seen before, but the way it's coded is a thing of beauty.
00:21:26 <kilimanjaro> psykotic, I'll take a look
00:21:41 <Cale> wli: Where is the array?
00:22:02 <wli> Cale: I used Data.Map, and it's buried in an inner StateT.
00:22:07 <Cale> hmm
00:22:21 <wli> s/inner//
00:22:51 <kjdf> tsp: paste the whole thing in hpaste.org
00:23:21 <tsp> ah ok
00:24:32 <hpaste>  tsp pasted "str to dword converter that needs fixing" at http://hpaste.org/2150
00:25:01 <Cale> tsp: Thost converts are in separate lets
00:25:10 <Cale> tsp: So the second shadows the first definition.
00:25:21 <Cale> those*
00:25:30 <tsp> ah
00:25:41 <wli> Cale: Basically I track the Data.Map of integers to Collatz chain lengths, the longest chain length seen thus far, and the list of numbers whose Collatz chains have that longest chain length in the StateT's state.
00:25:47 <Cale> If you're doing this at the GHCi prompt, use a ; between the two lines.
00:26:06 <tsp> I'm stuck with windows, ghci and notepad :)
00:26:33 <hpaste>  glguy pasted "my collatz code" at http://hpaste.org/2151
00:26:41 <tsp> unless I can get ghc on this x86 solaris vm which is the most compatible thing I have :)
00:26:48 <Cale> glguy: looks a lot like mine
00:26:59 <Cale> http://hpaste.org/2141
00:27:04 <kjdf> tsp: you can easily reload code in ghci with :r
00:27:28 <Cale> tsp: Use notepad, and whenever you save, just use :r or even just : at the ghci prompt, yeah.
00:27:58 <arcatan> @seen shapr
00:27:58 <lambdabot> I saw shapr leaving #haskell-blah, #scannedinavian and #haskell 5h 24m 31s ago, and .
00:28:13 <sorear> tsp: there's a mostly-statically linked generic x86-linux binary package, which works under openbsd's linux compatibility mode, so it would probably work under a comparable Solaris mode
00:28:20 <wli> glguy/Cale: I've done shorter and less elaborate thins at the ghci prompt. I'm just baffled as to why what I hammered out is/was so mind-bogglingly slow.
00:28:37 <glguy> wli: is yours the code under cales at #2141?
00:28:37 <taruti> there is also x86-solaris-ghc iirc
00:28:49 <tsp> wow, this actually works
00:28:50 <glguy> (rather, "the code in question" ?)
00:28:51 <Cale> wli: Have you tried profiling?
00:29:05 <wli> glguy: Yeah. Complete/current is at http://holomorphy.com/~wli/Collatz2.lhs
00:29:29 <Cale> wli: Compile with -prof -auto-all and run the executable with +RTS -p
00:29:36 <tsp> I'm wondering just what makes it stop when the convert [] n hits = wouldn't it append [] to the list and keep going?
00:29:36 <Cale> and hpaste the resulting .prof :)
00:29:51 <Cale> tsp: where would it keep going to?
00:29:58 <tsp> not sure
00:30:02 <tsp> > head []
00:30:04 <lambdabot>  Exception: Prelude.head: empty list
00:30:08 <Cale> tsp: When the list is empty, convert gives an empty list.
00:30:08 <tsp> ah, that's why it stops
00:30:28 <Cale> Ah, yeah, [] doesn't match (x:xs)
00:30:33 <wli> No profiling libs for missingh :(
00:30:41 <Cale> wli :(
00:31:03 <Cale> wli: Maybe comment those bits out?
00:31:06 <sorear> @seen CosmicRay
00:31:06 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 9h 32m 34s ago, and .
00:31:07 * psykotic gets a flashback from trying to get profiling for gtk2hs working
00:31:43 <wli> Cale: I'm just using the old version sans progress meters.
00:31:51 <tsp> I wrote the same thing in python, it took the better part of 2 days to convert a 500k file, and the box died before it finished :)
00:32:16 <psykotic> tsp: then you must have done something very wrong with the python code :)
00:32:54 <sorear> WoW.
00:33:08 <Cale> sorear: World of Warcraft?
00:33:21 <sorear> Cale: No, my shift-key slipped. :)
00:33:27 <Cale> hehe
00:33:28 <tsp> hmm, how to get a file into a string? I know I need readFile, but no idea how to get it through the monads and into a variable
00:33:35 <wli> There's no operational distinction between the two. collatz consumes 98.1% of the time.
00:33:43 <sorear> First time I've seen an all-"fail" GHC buildbot report.
00:34:03 <Japsu> failurious
00:34:06 <mauke> tsp: maybe you should learn >>= and return first
00:34:18 <mauke> just their IO versions, I mean
00:34:19 <kilimanjaro> psykotic, I'm just going to clear my schedule for a day and go to the university library and read as many back issues of JFP as I can
00:34:41 <psykotic> hehe
00:35:01 <wli> The profile appears to be uninformative.
00:35:58 <Korollary> kilimanjaro: What is JFP?
00:36:04 <Korollary> journal of FP?
00:36:13 <kilimanjaro> yea
00:36:19 <Cale> wli: Maybe add some SCC's to each of the expressions in it
00:36:34 <Cale> {-# SCC "label" #-}
00:36:56 <Cale> Will add a cost centre for the expression which follows it
00:37:02 <tsp> can I get ghc not to print out the last returned expression? It's printing the entire 500k file :)
00:37:45 <Cale> tsp: I really hate how it does that too.
00:37:58 <Cale> tsp: add  :set -fno-print-bind result
00:38:01 <Cale> to your .ghci
00:38:05 <Cale> er, oh
00:38:12 <Cale> I'm not sure what that is on windows :)
00:38:28 <Cale> :set -fno-print-bind-result
00:38:30 <Cale> rather
00:38:30 <Korollary> It's probably the same, but in Documents and Settings or something
00:38:59 <psykotic> has someone worked on a port of parsec to use bytestrings?
00:39:05 <tsp> thanks :) damn, stack overflow when I tired to convert that file
00:39:21 <Cale> tsp: That's because of the accumulating parameter
00:39:32 <tsp> I guess calling a recursive function 591000 times is going to kill anything you try it with
00:39:37 <Cale> tsp: It's not evaluating the sum as it goes.
00:39:43 <Cale> It'd be okay, otherwise
00:39:46 <Korollary> psykotic: I think it is/was? an SoC project
00:39:50 <Cale> So you just need to force it to do that addition
00:40:15 <tsp> I did sum (convert string 0)
00:40:21 <tsp> which would ahve summed the list
00:40:29 <Cale> ah, try  foldl' (+) 0
00:40:34 <Cale> after importing Data.List
00:40:54 <Cale> also, perhaps the parameter to convert is overflowing
00:41:16 <Cale> (maybe, but try that first)
00:41:29 <wli> I've got a feeling it's the Map lookups.
00:41:41 <Cale> wli: That's quite possible
00:41:46 <wli> Though it's not apparent how to catch that.
00:41:51 <tsp> so... foldl (+) convert ...?
00:41:53 <Cale> wli: They're cheap, but not as cheap as array lookups.
00:42:02 <Cale> tsp: instead of sum
00:42:06 <Cale> foldl' (+) 0
00:42:10 <Cale> note the '
00:42:17 <Cale> (it's important)
00:42:25 <tsp> oh
00:42:37 <Cale> foldl' (+) 0 (convert string 0)
00:42:47 <wli> collatz n = (recurse `maybe` return) =<< (gets $ lookup n . fst) etc.
00:42:53 <Cale> and if that still crashes, there's something easy you can also try
00:43:29 <Cale> But I don't think it will.
00:43:57 <Cale> i actually gets evaluated if the returned list element does, so you'll be okay
00:44:16 <tsp> that is odd
00:44:23 <Cale> what?
00:44:30 <tsp> I did t `mod` 0, and it returned in around 10 seconds
00:44:33 <tsp> t `mod` 2
00:44:45 <wli> Well, 100x slower is surprising but probably not worth chasing down.
00:45:09 <Cale> wli: Also, GHC is terrible at optimising StateT
00:45:15 * tsp was expecting a cupple of hours while it converted - a 400mhz sparc and a 2.4ghz P4 aren't that much different
00:45:17 <Cale> (apparently)
00:45:37 <Cale> tsp: How large is the file?
00:45:37 <wli> Cale: I've heard that wrt. monad transformers in general.
00:45:52 <Cale> 500k? That can't be all that bad, can it?
00:46:00 <tsp> Cale: 591304
00:46:06 <tsp> bytes
00:46:18 <tsp> the python version was still going 2 days later
00:46:23 <tsp> on the sparc
00:46:31 <tsp> each k taking longer than the last
00:46:34 <Cale> So the actual Integer in the end is only going to be 500k, that's not unreasonable.
00:46:52 <tsp> how do I convert that integer to a string?
00:46:56 <Cale> show
00:47:16 <tsp> although it would be faster if I could read that file into memory, and turn that directly into an int
00:48:21 <tsp> it only gave me a 10 character string though, I'm guessing it overflowed the Int
00:49:03 <Cale> oh
00:49:06 <Cale> Don't use Int
00:49:09 <Cale> Use Integer
00:49:11 <mauke> > show (maxBound :: Int)
00:49:13 <lambdabot>  "2147483647"
00:49:29 <Cale> Perhaps it's ord's fault
00:49:29 <kjdf> > show (maxBound :: Integer)
00:49:30 <lambdabot>   add an instance declaration for (Bounded Integer)
00:49:30 <lambdabot>     In the expression: ma...
00:49:33 <Cale> :t ord
00:49:34 <glguy> and that's why you souldn't use 32bit
00:49:35 <lambdabot> Char -> Int
00:49:38 <Cale> yeah
00:49:45 <Cale> stick a   fromIntegral in there
00:49:51 <tsp> where do I put the type specifiers?
00:49:53 <Cale> (fromIntegral (ord h))
00:50:05 <Cale> Will do the conversion from Int to anything.
00:50:17 <Cale> and just to be sure
00:50:30 <Cale> getNumberToAdd :: (Integer, Integer) -> Integer
00:51:19 <Cale> It's kind of a shame that the sum in the Prelude isn't defined as foldl' (+) 0
00:51:36 <Cale> It's sort of rare to want sums to be lazy, after all.
00:52:05 <tsp> I tried the getNumberToAdd :: (Integer, Integer) -> Integer at the prompt, but it didn't work
00:52:11 <Cale> oh
00:52:14 <tsp> is there a ghci interpreter command for it?
00:52:17 <Cale> Put it in your file :)
00:52:38 <Cale> Honestly, if you're not doing it that way already, you really want to do it like that
00:52:49 <Cale> Or if you're really lazy, you can just write
00:52:59 <Cale> let getNumberToAdd :: (Integer, Integer) -> Integer; getNumberToAdd (s, n) = n*(256^s)
00:53:05 <Cale> all on one line
00:53:15 <tsp> ack, that's long
00:53:19 <Cale> But really, it's much better to put your declarations into a file.
00:53:29 <Cale> That way you don't need to use let
00:53:38 <Cale> and you can separate things onto lines properly
00:53:49 <Cale> and you don't lose your work randomly by printing something too long
00:53:50 <tsp> how do you read the file again?
00:53:56 <Cale> :l Filename.hs
00:54:05 <Cale> and then :r to reload it
00:54:11 <Cale> (when you save changes)
00:54:56 <Cale> Or, when you run GHCi, pass it the name of the file on the commandline, or I suppose drag the file's icon over GHCi's icon :)
00:55:13 <quicksilver> Cale: well as long as you run ghci in a decent shell (I run it in emacs) there's not too much danger of losing your work
00:55:18 <quicksilver> Cale: but I agree otherwise
00:55:47 <Cale> quicksilver: Does emacs have an infinite backbuffer?
00:55:55 <quicksilver> Cale: I think so
00:56:17 <quicksilver> Cale: I've certainly not noticed running it out
00:56:24 <Cale> That's kind of good and kind of bad :)
00:56:32 <quicksilver> more good than bad though
00:56:39 <quicksilver> memory and hard disks are cheap :)
00:56:43 <quicksilver> and I'd rather not lose work
00:56:55 <tsp> quicksilver: heh, you ahve it lucky with emacs
00:57:02 <Cale> I used to set much longer backbuffers in my terminals and IRC client but they were using way too much memory after a while.
00:57:05 <tsp> I lose my edbrowses sessions all the time
00:57:26 <quicksilver> I have 24 hours on IRC
00:57:32 <quicksilver> (on about 20 channels)
00:58:21 <tsp> quicksilver: your ircing from emacs?
00:59:26 <quicksilver> tsp: no, irssi
00:59:32 <tsp> irssi rocks
00:59:36 <Cale> SamB: ew, underscores ;) (Re: Data.TupleFields)
00:59:41 <quicksilver> Cale: seems I'm wrong, and comint defaults to 1024 line truncation
00:59:55 <quicksilver> Cale: unless I've configured that off and forgotten about it
01:02:06 <glguy> Cale: by only memoizing values < 20000, I cut my runtime in half on that problem
01:03:38 <Cale> Odd, mine's a bit slower with that bound.
01:03:45 <Cale> 9 seconds rather than 3.
01:03:51 <glguy> what processor?
01:04:00 <Cale> P4 2.4GHz
01:04:12 <glguy> on my 1.8ghz in vmware, I get 1.3secs
01:04:22 <Cale> hmm
01:04:31 <glguy> what bound do you choose?
01:04:51 <wli> 4x 3.2GHz Nocona here.
01:05:10 <glguy> mine is a nocona, and I have a dual core...
01:05:15 <glguy> but I only dedicate 1 cpu to the linux vm
01:05:17 <glguy> :(
01:05:48 <Cale> glguy: 5*10^6 normally
01:05:59 <glguy> OH, more than the minimum
01:06:02 <glguy> err
01:06:07 <glguy> more than the problem upper bound
01:06:27 <Cale> no
01:06:32 <hpaste>  glguy annotated "my collatz code" with "my faster version..." at http://hpaste.org/2151#a1
01:06:32 <Cale> 1/2 the problem upper bound
01:06:43 <Cale> unless I did that wrong...
01:06:57 <Cale> Maybe I got the whole size of the problem wrong :)
01:07:07 <glguy> Which starting number, under one million, produces the longest chain?
01:07:10 <Cale> ahaha
01:07:27 <Cale> er, oh
01:07:27 <tsp> there we go, now its taking the expected cupple of hours
01:07:33 <Cale> hmm, no, I haven't
01:07:44 <glguy> 10^6 == 1 million
01:07:49 <psykotic> cale: regarding long backbuffers. if they are stored in a sane format, the unread parts should be paged out to disk and not read back in until you actually try to read them.
01:07:50 <glguy> (as you know)
01:08:02 <Cale> right, I really am computing 10^6 of them
01:08:10 <psykotic> cale: by sane format, i mean that the new and old formats aren't intermingled :)
01:08:15 <psykotic> err, new and old parts
01:08:20 <tsp> I remember the dos days - running something like this would have killed the screen reader, let alone trying to listen to music while it was going
01:08:30 <sieni> glguy: http://www.hurmio.org/~ville/3n+1.scm
01:08:35 <Cale> glguy: ah, yeah, still, 5 times the size of the problem seems like it gives the best result for me
01:09:07 <glguy> sieni: is that blazing fast?
01:09:18 <sieni> glguy: Pretty fast, I think
01:09:59 <Cale> er, hmm...
01:10:20 <wli> Cale's runs in 2.7s here.
01:10:34 <tsp> this thing is still incredibly slow. if I somehow got the numbers to sum as it was going, would it work faster?
01:10:39 <wli> I'm not sure how well this works out when the problem is generalized from 10^6 to n.
01:10:56 <Cale> oh, I was using 5*10^5
01:11:15 <Cale> So exactly half the problem size
01:11:19 <tsp> there's probably a function for this, but I'm just missing it
01:11:24 <sieni> glguy: oops, my program gives the length of the longest chain, not the starting number
01:11:26 <glguy> by fixing a typo, I shaved .4 seconds (down to 1.129 locally)
01:11:38 <wli> Never mind, it works out fine (in fact even without expanding the memo table).
01:11:40 <Cale> tsp: It is summing them as it's going.
01:11:53 <Cale> (that's what the foldl' is for)
01:11:55 <wli> So there's probably something horrendously stupid like copying the entire Map going on.
01:11:59 <tsp> heh, too used to imparitives I guess
01:12:21 <Cale> You could try to avoid building the list at all.
01:12:31 <Cale> Paste your code on hpaste
01:12:34 <tsp> it only started calculating when I did something with the integer
01:12:34 <glguy> Cale: whoa, now that I fixed my mistake
01:12:41 <glguy> Cale: bosting that limit like you said really helps
01:12:44 <glguy> down to 0.729
01:12:45 <tsp> should I paste it as a comment? Or just as a new paste
01:13:40 <dons> glguy: where''s the code? :)
01:13:49 <Cale> tsp: either is fine
01:13:52 <sieni> glguy: well on my machine the code takes around 3 seconds to find the longest chain below 1000000 (in mzscheme, which is an interpreter)
01:14:20 <Cale> glguy: can I have your latest code?
01:14:28 <hpaste>  glguy annotated "my collatz code" with "faster still" at http://hpaste.org/2151#a2
01:15:02 <glguy> Cale: my code assumes your Int is big enough
01:15:08 <hpaste>  tsp annotated "str to dword converter that needs fixing" with "converter" at http://hpaste.org/2150#a1
01:15:13 <glguy> I don't know if that is the case on 32bit
01:15:18 <Cale> glguy:  Ix{Int}.index: Index (-1812855948) out of range ((1,199999))
01:15:31 <Cale> Runs in 0.2s though ;)
01:15:39 <glguy> well, change the default() :-p
01:15:42 <glguy> or get new hardware ;)
01:15:58 <wli> glguy: Or default to Int64?
01:16:15 <glguy> yeah, I should fix that
01:16:20 <Cale> With Int64, it takes 6.3s...
01:16:21 <glguy> damn... I thought it was his fault ;)
01:16:32 <wli> glguy: Where's the bounds check in here, anyway?
01:16:34 <glguy> so locally yours is still faster then
01:16:51 <glguy> wli: how do you mean?
01:16:54 <Cale> With Integer, it's 4.4s
01:17:03 <Cale> But I've yet to try mixing Int and Integer
01:17:07 <Cale> (like my code does)
01:17:47 <Cale> Yeah, mixing the two brings it to 3.7s
01:18:17 <Cale> Which is pretty close to what my code runs in, which makes sense, since our programs are almost completely equivalent :)
01:18:24 <wli> glguy: Oh, never mind.
01:19:10 <Cale> glguy: Try 500k for your memo size
01:19:26 <tsp> the thing started slowing my box down majorly :)
01:19:34 <Cale> Also, you're cheating by not searching the whole range :)
01:19:39 <glguy> Cale: LIES!
01:19:41 <Cale> er, oh
01:19:43 <Cale> I see :)
01:19:47 <Cale> That's a ++
01:20:12 <Cale> I didn't bother with the assocs
01:20:33 <glguy> changing the range to 500k on mine increases the time by 0.5 sec
01:20:38 <glguy> up to 1.275
01:20:40 <Cale> hmm
01:20:53 <DRMacIver>  Hm. Apparently there's no path through strong connections between the two major IRC channels I hang out in. :) (According to the "Mapping Programming Language IRC Channels" post)
01:21:11 <tsp> DRMacIver: heh, I read that
01:21:18 <dons> DRMacIver: is that Haskell and Java?
01:21:18 <Cale> How does changing assocs memo_arr ++ [(i, aux i) | i <- [200000..999999]]     to   [(i, aux i) | i <- [1..999999]]  affect it?
01:21:25 <tsp> DRMacIver: at least the text on it
01:21:26 <DRMacIver> dons: Yeah
01:21:32 <glguy> Cale: adds 0.1 sec
01:21:34 <dons> DRMacIver: i'm surprised there's no link via Scala :)
01:21:38 <Cale> Interesting.
01:21:41 <DRMacIver> dons: Yeah, me too.
01:21:49 <glguy> Cale: assocs probably isn't very smart
01:21:56 <tsp> I don't get how you can map that stuff to a whatever it is in the image though
01:21:59 <DRMacIver> dons: There doesn't seem to be any link between ##java and #scala at all though.
01:22:13 <dons> also, why do the #python guys not talk to anyone else?
01:22:34 <DRMacIver> Because There Is Only One Way To Do It, and that's Python. :)
01:22:38 <glguy> they aren't interested in "advanced" "complicated" features?
01:22:49 <glguy> and they have all the basic ways to do things?
01:22:59 <dons> if they talked to people, they might have a better layout rule
01:23:13 <Cale> dons: hehe, my comment is up to 51 points since you posted it :)
01:23:21 <dons> woot
01:23:27 <dons> you're a interweb super star, Cale
01:23:43 <tsp> dons: any language without braces is just weird
01:23:45 <Cale> A virtual roomful of people liked my comment!
01:23:49 <dons> hehe
01:23:55 <dons> tsp, i agree!
01:23:57 <glguy> my all time high was 106
01:24:07 <tsp> good luck trying to jump around ruby code in ed
01:24:11 <tsp> it just doesn't work
01:24:18 <opqdonut> how so?
01:24:23 <roconnor> Cale: I was thiking that the only reason we get a logrithm hit
01:24:33 <dons> > let { x = 1 ; y = 2 } in x + y
01:24:35 <lambdabot>  3
01:24:37 <DRMacIver> tsp: Fortunately, Haskell is a language with braces. :)
01:24:40 <roconnor> Cale: is that our structures work with arbitrary amounts of data
01:24:41 <dons> glguy: for a comment?
01:24:44 <glguy> yeah
01:24:46 <roconnor> Cale: (in theory)
01:24:47 <tsp> after my usual ,s/^\s*//, I can type /^end but not be able to get beyond the first level
01:24:54 <dons> that's pretty good. i think that's the highest i've heard of in our little group
01:25:00 <glguy> dons: a typically snarky glguy one at that ;)
01:25:03 <roconnor> Cale: If they had arbitrary sized pointers, they'd have a logrithmic hit too.
01:25:04 <dons> cool.
01:25:12 <dons> my snarky ones always rate higher than my non-snarky ones
01:25:15 <Cale> roconnor: ah, that's actually a rather good point
01:25:22 <dons> Korollary should have some good scores by that case then
01:25:29 <glguy> dons: yeah, ... my top 3 at least are all snarky :)
01:25:47 <Cale> Plus, there's my argument that no data structure ever has faster than O(n^(1/3)) indexing time :)
01:26:01 <roconnor> Cale: ?
01:26:08 <dons> glguy: the 'you got served' phenomenon
01:26:12 <glguy> Cale: because of memory constraints?
01:26:16 <Cale> Assuming that the universe only supports finite information density.
01:26:23 <tsp> if I find some C code that puts nothing but function declarations indented, and its not taking up too much sapce to leave the indent, /^} works great for searching for the ends of functions you want to skip
01:26:27 <roconnor> Cale: ah right
01:26:34 <Cale> and that information can't travel faster than the speed of light :)
01:26:41 <roconnor> Cale: no no, it proportial to the surface area.
01:26:49 <roconnor> Cale: see holographic information theory.
01:26:51 <Cale> and that space is 3 dimensional and Euclidean :)
01:27:04 <DRMacIver> Cale: Yes, but that gets quite a good constant factor. ;)
01:27:06 <Cale> ah, so it's actually worse
01:27:10 <roconnor> Cale:
01:27:17 <roconnor> Cale: yep, ... gravity at work
01:27:31 <Cale> I'd heard of that, but not thought to apply it :)
01:27:37 <DRMacIver> Cale: Or are we not concerned about such things? :)
01:27:50 <Cale> DRMacIver: Well, it's big O notation.
01:27:54 <glguy> dons: Here on the programming subreddit we prefer actual content to slavish fanboism.
01:28:10 <roconnor> http://sufizmveinsan.com/fizik/holographic.html
01:28:11 <lambdabot> Title: Information in the Holographic Universe
01:28:25 <roconnor> Although it is all a bit theoretical at the moment.
01:28:47 <Cale> Yeah, it relies on some additional assumptions that I'm less clear about :)
01:28:58 <roconnor> The idea is that as you start cramming more and more memory chips together
01:29:07 <roconnor> eventually it collapses into a black hole
01:29:15 <roconnor> whose entropy is proportial to it's surface area.
01:29:30 <glguy> dons: so... do you have your plane tickets yet?
01:29:30 <roconnor> ... not that I know anything about black holes and information theory.
01:29:30 <DRMacIver> Cale: Sure. I'm just saying it's not a very important instance of big O notation because the constant factors dominate there for all reasonable n. :)
01:29:46 <tsp> Cale: if I added a third parameter to convert, that held a constantly updated sum, how could I get that back out to the first function to be returned?
01:30:19 <roconnor> DRMacIver: do you only deal with n's small enough to fit on your desktop without collapsing into a black hole!
01:30:19 <Cale> tsp: Return it in your base case
01:30:27 <tsp> ah, the empty list
01:30:31 <Cale> tsp: rather than the empty list
01:30:43 <tsp> how can I tell if it speeds it up though?
01:31:00 <DRMacIver> roconnor: I think that's a good first order approximation to the size of n I'm concerned with, yes. :)
01:31:14 <Cale> tsp: You'll want to do something like `seq` on that parameter as you go along, or else you'll almost surely overflow.
01:31:25 <roconnor> DRMacIver: obviously you don't work for google ;)
01:31:43 <dons> glguy: yep.
01:31:53 <glguy> sooo... what day do you start?
01:31:57 <tsp> Cale: why would it overflow if its an Integer?
01:32:02 <Cale> tsp: that is, in the recursive case, if the accumulating parameter is x, write   x `seq` whatever
01:32:11 <Cale> tsp: Stack overflow.
01:32:14 <dons> i arrive sep 1. (saturday) so i guess sometimes that week?
01:32:16 <tsp> oh, lazy evaluation
01:32:23 <Cale> tsp: Because the loop will just build up a huge expression
01:32:23 <dons> i need to talk to some people about what needs to be done
01:32:31 <tsp> > 3 `seq` 4
01:32:39 <lambdabot>  4
01:32:45 <Cale> tsp: and then at the end when you go to evaluate it, it'll die :)
01:32:48 <tsp> ah, it ignores the 3
01:32:58 <Cale> x `seq` y will first evaluate x, then return y
01:32:58 <mauke> > undefined `seq` 4
01:32:59 <lambdabot>  Undefined
01:33:01 * glguy uses $! a lot in such cases
01:33:10 <glguy> f $! x = x `seq` f x
01:33:16 <DRMacIver> roconnor: Indeed not. :)
01:33:18 <roconnor> > undefined `seq` 4
01:33:19 <lambdabot>  Undefined
01:33:54 <Cale> It'll only evaluate it to determining the top level constructor -- but in an Integer, this means it completely evaluates it, because they're not compound structures.
01:34:18 <glguy> seq is primitive because it magically works on all types, but you could create a typeclass for seq just as easily, right?
01:34:29 <Cale> glguy: yeah
01:34:40 <Cale> glguy: wouldn't work so well for functions though
01:34:41 <roconnor> 3 `seq` 4 is similar to case 3 of  { 0 -> 4 ; _ -> 4 }
01:35:03 <roconnor> >  case 3 of  { 0 -> 4 ; _ -> 4 }
01:35:03 <glguy> ah
01:35:04 <lambdabot>  4
01:35:10 <roconnor> >  case undefined of  { 0 -> 4 ; _ -> 4 }
01:35:11 <lambdabot>  Undefined
01:35:31 <Cale> glguy: also, you'd have an extra typeclass constraint in funny places :)
01:35:43 <roconnor> I was happy when I found out that all my uses of seq could be replaced with case statements, if I wanted to.
01:35:52 <Cale> yeah, that is rather nice :)
01:35:56 <glguy> Cale: that wouldn't be *terrible* since seq can change the behavior of a program
01:35:57 <roconnor> Because I basically only use seq on integers.
01:36:05 <Cale> glguy: that's true
01:36:42 <roconnor> glguy: Haskell used to have a typeclass for seq.
01:37:01 <glguy> I know that Andy Gill wants to see DeepSeq in Haskell'
01:37:46 <|Steve|> Can I do something like: case ... of {(n,n) -> ...; ... }?
01:38:02 <glguy> |Steve|: no
01:38:15 <glguy> (x,y) | x == y ->
01:38:19 <glguy> is the closest
01:38:20 <Cale> wha?
01:38:35 <Cale> hmm...
01:38:46 <Cale> oh, I see what he wants :)
01:38:55 <glguy> took me two glances too
01:38:58 <Cale> I thought that was related to the seq thing :)
01:39:06 <wli> |Steve|: I wanted that, too.
01:39:26 <|Steve|> Heh, sorry. I guess context helps.
01:39:42 <Cale> |Steve|: no problem, it was just unfortunate timing :)
01:41:30 <quicksilver> arguably, the reason that (n,n) isn't in the language is that it would be strange if a pattern could introduce an Eq constraint
01:41:37 <quicksilver> (although n+k patterns already do weird things)
01:41:43 --- mode: ChanServ set +o glguy
01:41:48 --- mode: glguy set -b *!*@host30-17-dynamic.56-82-r.retail.telecomitalia.it
01:41:58 <|Steve|> I don't think requiring equality is all that strange in a unification.
01:42:02 <|Steve|> But it's not really my area.
01:42:12 <quicksilver> you expect equality on types, for unification
01:42:14 <quicksilver> not normally for values
01:42:24 <quicksilver> it is type-unification, not value-unification after all
01:42:28 <Cale> Integer literal patterns also introduce Eq (and Num)
01:42:30 <|Steve|> Good point.
01:42:38 <psykotic> anyway i always wish that this would work too :)
01:42:51 <|Steve|> Hmm, yeah. I was already matching on (1,1).
01:42:51 <psykotic> it's certainly a million times more useful than the n+k pattern abomination
01:42:59 <|Steve|> What is this n+k patter?
01:43:00 <wli> I need to learn more about how typeclass qualifiers are handled in type inference.
01:43:00 <|Steve|> pattern*
01:43:09 <tsp> finally
01:43:12 <tsp> convert (h:t) i q = q `seq` (convert t (i+1) (seq q q+(getNumberToAdd (i,(fromIntegral (ord h))))));
01:43:14 <quicksilver> psykotic: I find (x,y) | x==y to be pleasant on the eyes and extremely clear :)
01:43:16 --- mode: glguy set -b *!*@adsl-68-121-148-82.dsl.pltn13.pacbell.net
01:43:18 <wli> psykotics: What's a million times more useful than n+k patterns?
01:43:24 <Cale> tsp: how is that working out?
01:43:36 <tsp> Cale: not sure, going to feed it a huge file
01:43:38 <psykotic> wli: "parallel" patterns that imply equality constraints
01:43:47 <psykotic> wli: e.g. matching on (x,x)
01:43:49 <Cale> tsp: you don't need to seq a second time.
01:43:58 <tsp> heh I have it twice?
01:43:59 <wli> psykotic: Oh, I wanted that, too.
01:44:02 <Cale> tsp: yeah
01:44:06 <tsp> I was just adding )s until it parsed
01:44:08 <Cale> only the outer one is needed
01:44:13 <psykotic> i'm so used to that from lisp and scheme
01:44:51 --- mode: glguy set -b palomer!*@*
01:45:00 <Cale> Can we combine it with n+k?
01:45:06 <Cale> f (x,x+1) = ...
01:45:17 <mux> hi there
01:45:19 <Cale> hello
01:45:28 <psykotic> quicksilver, it's nice being able to write, for example... nub [] = [] ; nub x:x:xs = nub (x:xs), nub (x:xs) = x : nub xs
01:45:34 <tibbe> I was flicking through hackage, do we have polished unicode library on top of byte string yet?
01:45:36 --- mode: glguy set -b *!*@pool-71-105-96-215.lsanca.dsl-w.verizon.net
01:45:50 * EvilRanter finds it weird that lisp had a perfect solution to the bracing style debate (parens can line up vertically _and_ be on the same line as the block opener), but then the de facto standard layout style completely fails to take advantage of this
01:45:50 <Cale> glguy: purging the banlists?
01:46:03 <glguy> Cale: ancient dynamic hosts at this point
01:46:08 <Cale> ah, yeah
01:46:13 <quicksilver> psykotic: I'm quite happy with nub x:y:xs || x==y = nub (x:xs)
01:46:18 <quicksilver> psykotic: but I do understand your point
01:46:22 <glguy> I really would just like to purge the stuff that is assigned by server
01:46:25 <Cale> You both forgot the parens around the list parameter :)
01:46:36 <psykotic> cale: because they add no meaning :)
01:46:40 <glguy> Cale: since the stuff that has people's nicks on it, they can be responsible for
01:46:46 <glguy> the other stuff is like in lost+found
01:46:58 <tsp> stupid thing trying to print the entire 500k file when I load it. I can't figure out where to put that :set command on windows
01:47:05 --- mode: glguy set -b *!*@ppp-71-128-92-216.dsl.pltn13.pacbell.net
01:47:20 <|Steve|> Yikes, now I'm getting kind errors. =\
01:47:25 <Cale> tsp: you could just type it in
01:47:27 <EvilRanter> whee
01:47:37 <glguy> Cale: additionally, anything that is supposed to be permanent should probably go in chanserv, where it can get a proper "reason"
01:47:37 <Cale> tsp: It's a command for ghci
01:47:39 <int-e> psykotic: x:x:xs looks too harmless for something that isn't guaranteed to terminate
01:47:41 <tsp> there must be a typo somehwere - :set -fno-print-bind result doesn't work
01:47:45 <int-e> psykotic: or even implementable
01:48:00 <Cale> tsp: I missed a -
01:48:04 <psykotic> because == might loop?
01:48:08 <glguy> 07:39 -!- 10 - #haskell: ban *!*n=fsafasf@89.191.106.* [by douglas.freenode
01:48:09 <Cale> :set -fno-print-bind-result
01:48:11 <glguy> oops :)
01:48:13 <int-e> psykotic: (try doing that pattern match on a list of type [a -> a]
01:48:33 <EvilRanter> tsp, you could put it in the %USERPROFILE%\.ghci file if you want it to be permanent
01:48:34 <Cale> tsp: I'd corrected it earlier, but perhaps didn't shout loud enough about it :)
01:48:42 <tsp> ah, my irc logs were dead
01:48:52 --- mode: glguy set -b *!*@host-212-149-255-186.kpylaajakaista.net
01:48:55 <tsp> there we go
01:49:24 <psykotic> int-e, it wouldn't type check. as for not looping, there are plenty of things for which pattern matching deconstruction can force infinite looping.
01:49:28 <Cale> Printing the result of IO actions after they run is silly.
01:49:28 <|Steve|> Integral is not a subclass of Ix?
01:49:49 <Cale> They could print them themselves if you really wanted them to :)
01:49:58 <psykotic> int-e, like if you deconstruct something with strict fields
01:50:16 <tsp> hmm, not bad, but I think a 500k file is too much for haskell
01:50:28 <int-e> psykotic: yes, but that's not the fault of the pattern matching, the loop is elsewhere.
01:50:39 <quicksilver> |Steve|: logically all integrals have sensible Ix instances, but requiring an Ix definition to write an Integral instance would seem strange
01:50:49 <psykotic> well, in this case "the loop is elsewhere", in the == implementation
01:50:56 <psykotic> if i understand your nontermination hint correctly
01:50:58 <int-e> psykotic: with x:x:xs you could get a loop on a fully evaluated data structure.
01:51:01 <quicksilver> |Steve|: the layering feels wrong, since Ix is a concept about arrays
01:51:07 --- mode: glguy set -b *!*@ppp-69-236-158-230.dsl.pltn13.pacbell.net
01:51:12 <quicksilver> |Steve|: and integrals "shouldn't know about arrays"
01:51:26 --- mode: glguy set -b WP-Gast*!*@*
01:51:33 <Cale> tsp: It is still quite a lot of evaluation to do.
01:51:34 <glguy> hmm, off by one
01:51:37 <int-e> psykotic: on a side note, this probably applies to n-patterns as well. hmm.
01:51:38 <Cale> glguy: don't remove that one!
01:51:42 --- mode: glguy set +b WP-Gast*!*@*
01:51:45 <|Steve|> quicksilver: I suppose, but it seems like there might be deeper problems if you have something that's integral (i.e., like an integer) that doesn't support indexing.
01:51:52 <psykotic> int-e, yep
01:51:57 --- mode: glguy set -b *!*@77-56-92-231.dclient.hispeed.ch
01:52:01 <glguy> Cale: I was removing them by index
01:52:04 <Cale> ah
01:52:06 <glguy> Cale: I did two in a row
01:52:20 <glguy> Cale: if that is an important one, it should be in chanserv
01:52:22 <psykotic> int-e, although for different reasons. when you match on n+1 you have to force n
01:52:52 <glguy> Cale: I see that JavaUser is in the autorem list
01:52:54 <psykotic> at least using the usual implementations of integers :)
01:53:10 <int-e> psykotic: hmm. k-patterns I guess. the f (-1) kind that gets desugared to f x | x == -1
01:53:56 --- mode: glguy set -b *!*i=hussein@*.kpylaajakaista.net
01:54:01 <int-e> or at least f 1 which gets desugared to f x | x == 1 -- somebody (SamB?) pointed out yesterday that the Haskell 98 report doesn't really say what happens to f (-1) :)
01:54:03 <glguy> (that one is in chanserv already)
01:55:26 <wli> psykotic: bidirectional pattern matching might also be nice
01:55:39 <psykotic> wli: example?
01:55:51 <quicksilver> psykotic: you don't actually force n completely, necessarily
01:55:58 <quicksilver> psykotic: you might have a lazy Eq instance
01:56:03 <quicksilver> psykotic: although that would be quite strange :)
01:56:15 <wli> psykotic: Just like logic languages; try to unify values.
01:56:24 <psykotic> quicksilver, ah, true, i admit i was thinking of concrete data types, not Num
01:56:38 <quicksilver> actualy it wouldn't be that strange to have and == which is somewhat lazy-on-False
01:56:50 <quicksilver> an == which was lazy-on-True would be very odd though
01:56:52 <mauke> > [1 ..] == [2, undefined]
01:56:55 <lambdabot>  False
01:56:57 <quicksilver> right :)
01:57:29 <psykotic> wli: then you would need a separate construct for introducing new bindings, i think
01:57:37 <wli> psykotic: yes, absolutely
01:57:50 <int-e> hmm. Data Foo = ... | Product Foo Foo | ...; Product a b == Product c d | isZero a && isZero b = True ...
01:57:51 <psykotic> btw oz does this
01:58:00 <psykotic> you write local x, y, z, and then uses of = are unification
01:58:22 <wli> psykotic: Not where I got the idea but I am vaguely aware of it.
01:58:24 <int-e> uhm. isZero c
01:58:26 <int-e> not b
01:58:26 --- mode: glguy set -b *!*topaz@*
02:00:30 <psykotic> wli: btw, the book "concepts, models and techniques of computer programming" is a must-read.
02:00:34 <psykotic> it uses oz throughout.
02:01:01 * glguy cries
02:01:58 --- mode: glguy set -o glguy
02:02:02 <Cale> glguy: huh?
02:03:48 <dons> psykotic: oh, i'm not familiar with that.
02:04:04 <psykotic> dons: which?
02:04:08 <dons> the book.
02:04:12 <psykotic> it's great.
02:04:39 <dons> http://www.info.ucl.ac.be/~pvr/book.html
02:04:41 <lambdabot> Title: Concepts, Techniques, and Models of Computer Programming
02:05:03 <wli> looking
02:05:11 <dons> looks nice.
02:05:29 <psykotic> http://www.info.ucl.ac.be/people/PVR/booktoc.pdf
02:05:30 <glguy> Cale: wrt a nick
02:06:10 <tibbe> dons, is there a unicode library/wrapper for byte string yet?
02:06:23 <glguy> does "encoding" do them?
02:07:37 <dons> tibbe: for bytestrings, nothing official. there's one unofficial one (Twan's lib, can't recall the name, check the hwn archives0
02:07:44 <dons> encoding is a String lib, iirc
02:08:03 <psykotic> dons: the main "fault" is that it doesn't focus on static typing at all.
02:08:40 <dons> oh, despite the formal semantics aspect. that's interesting for a new book
02:08:57 <wli> Lack of formal typing would irritate me.
02:09:03 <wli> s/formal/static/
02:09:07 <psykotic> SICP irritates you?
02:09:12 <glguy> well... static typing is just for people that make mistakes the first time they write their programs (or people that like libraries like quickcheck)
02:09:30 <psykotic> in approach it's a lot like SICP, except with much greater scope
02:09:47 <dons> glguy: heh, did you see the `Guide to Solving Any Perl Problem  ' page?
02:09:53 <glguy> should I have?
02:09:54 <glguy> link?
02:09:58 <dons> i'd say half of the problems listed there are type errors
02:10:16 <dons> http://perlmonks.org/index.pl?node=376075
02:10:21 <lambdabot> Title: brian's Guide to Solving Any Perl Problem
02:10:37 <dons> first, they start by turning on strict and -w
02:10:38 <integral> perl's very bad about being late & lazy with errors, not just type ones
02:10:49 <dons> `s the value what you think it is?'
02:10:53 <dons> is another good one.
02:10:55 <tibbe> dons, do you think the hackathon would be enough to write one?
02:11:13 <dons> tibbe: it would, if someone wants to do it.
02:11:25 <tibbe> dons, I might
02:11:30 <dons> its a 2-3 day job for someone familiar with unicode and bytestrings
02:11:35 <tibbe> dons: need one for web apps
02:11:44 <dons> `Are you using the function correctly?' is another good one
02:11:53 <tibbe> I'm familiar with byte strings but only so so with unicode
02:11:57 <dons> tibbe: ah ok. talk to glguy. he worked on the utf8 string lib for similar things
02:12:07 <dons> so you need bytestrings for performance?
02:12:18 <tibbe> yes
02:12:18 <psykotic> dons: speaking of bytestrings--i asked someone earlier if there had been work done on making parsec work with them. someone mentioned a SoC project. do you know more?
02:12:19 <dons> and of course, unicode support. ok. good.
02:12:33 <dons> psykotic: yeah, xerox is (mostly done too?)
02:12:54 <dons> he dropped some initial numbers here the other day for parsing the ICFP DNA file that sounded good
02:13:02 <psykotic> great
02:13:23 <psykotic> is that going to be pushed into ghc's parsec version once stable, you think?
02:13:24 <glguy> dons: I didn't see `are you using the right language?'
02:13:25 <dons> high perf parsing should be a corner stone of haskell, imo :)
02:13:33 <dons> psykotic: probably a separate lib
02:13:37 <dons> glguy: heh
02:14:02 <wli> dons: LR(1) parser combinators?
02:14:15 <dons> psykotic: i still couldn't get joelr to narrow down his issue and make a bug report about his parser module being too slow to compile
02:14:25 <psykotic> dons: annoying.
02:14:38 <psykotic> if he has enough time to write up a bitch blog entry, you would think he could break that down in more detail :)
02:14:40 <dons> its frustrating. he'll happily write a blog post, which will be cited for years to come, but nothing gets fed back to improve things. grumble
02:15:04 <dons> i suspect that he's got a very large AST type, in the same module as the parser
02:15:06 <psykotic> well, the fact that ghc is slow is true
02:15:13 <dons> large data types with many constructors are a known bottleneck
02:15:14 <psykotic> hugs is, like, what, 100x faster than ghci?
02:15:22 <dons> no no, ghci wins out these days by a good margin
02:15:34 <psykotic> oh really?
02:15:37 <dons> http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
02:15:38 <lambdabot> Title: nobench: Haskell implementation shootout
02:15:46 <psykotic> i don't mean for generated code but for workflow
02:15:51 <taruti> and why didn't he just isolate the slowly compiling parts to a separate module that needs to be rarely recompiled?
02:15:59 <dons> oh, reloading-wise, hugs is faster (I think)
02:16:09 <psykotic> that's what i meant.  last time i checked the difference was close to 100x
02:16:37 <dons> i'm not aware of numbers. ndm might have some.
02:16:41 <|Steve|> You should really call it gghc.
02:17:31 <dons> psykotic: simon m today moved to do less fine-grained recompilation checking, btw.
02:17:41 <dons> since the current fairly-fine grained is too fragile with many cores
02:17:44 <psykotic> oh, very cool
02:17:46 <dons> (I think that's the reason why its fragile)
02:17:52 <psykotic> hmm
02:17:54 <dons> so they're moving to coarser grained.
02:17:57 <dons> i.e more recompilation
02:18:01 <psykotic> oh. crap. :)
02:18:08 <dons> yeah, i thought you'd say something like that
02:18:09 <psykotic> i thought you meant the opposite. grumble. :)
02:18:21 <psykotic> fragile how?
02:18:22 <dons> let me find the ticket
02:18:42 <glguy> psykotic: if it makes it so that --make can do parallel compilation, I'm all for it :)
02:18:54 <psykotic> right, i'm for that
02:19:15 <psykotic> although keeping iteration times down when iterating on a single module is also crucial. imo.
02:20:17 <Cale> What would be even nicer would be if it handled mutually recursive modules properly.
02:20:21 <dons> trac sucks
02:20:25 * dons keeps hunting
02:20:41 <psykotic> cale: what does it do right now?
02:21:02 <quicksilver> dons: you've stumbled on the flaw of the blogosphere
02:21:03 <mauke> it flaps its arms and says "feed me"
02:21:05 <Cale> psykotic: Complains.
02:21:20 <dons> quicksilver: the linuxer issue?
02:21:57 <quicksilver> dons: blog articles acheive fame based on controversy, or whether other people agre with them
02:22:06 <quicksilver> dons: not actually on whether what they say is true, or helpful
02:22:08 <Cale> I think you can get it to work if you write an hi-boot... http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
02:22:10 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
02:22:29 <Cale> er, hs-boot
02:22:43 <glguy> hmm... better hit the hay
02:22:57 <Cale> But that's kind of annoying isn't it? Can't it figure out the hs-boot files required?
02:23:21 <dons> quicksilver: ah yes, a more general problem. did I say something about this, and not realise I was saying something about it?
02:23:51 <dons> psykotic: http://hackage.haskell.org/trac/ghc/ticket/1604
02:23:53 <lambdabot> Title: #1604 (Coarse-grained recompilation checking) - GHC - Trac
02:23:59 <psykotic> dons: cheers
02:24:01 <dons> `GHC's recompilation checker is very clever: it tracks changes at the level of an individual function or type, and only recompiles a module when the entities it actually depends on have changed.'
02:24:25 <dons> i think this is motivated by breakages exposed by the multicore builds
02:24:47 <psykotic> that seems like a lazy solution
02:24:57 <dons> Cale, do you see what article is #1 on the subreddit now? :)
02:25:30 <|Steve|> You people are obsessed with reddit.
02:25:42 <Cale> hehe :)
02:26:44 <int-e> dons is
02:27:08 <quicksilver> dons: " < dons> its frustrating. he'll happily write a blog post, which will be  cited for years to come, but nothing gets fed back to improve  things. grumble"
02:27:35 <dons> mmm.
02:27:37 <Cale> dons: And you get all the article karma. That's okay, I have exactly 256 karma, which I rather like. :)
02:27:41 <dons> :)
02:27:56 <quicksilver> psykotic: and a lazy solution is a good solution, right? :)
02:28:01 <psykotic> quicksilver, not in this case :)
02:28:20 <psykotic> i think making iteration fast is _more_ important than making code generation better. like, way more important.
02:28:25 <psykotic> way way.
02:28:30 <Cale> There ought to be article karma.
02:28:33 <glguy> lol, funny before bed
02:28:36 <glguy> Let's see, does qwe submit articles?
02:28:36 <glguy> there are no results here
02:28:36 <glguy> Oh I see! You're just an internet fuckwad.
02:28:41 <Cale> er
02:28:45 <Cale> comment karma :)
02:28:59 <Cale> And people with really low comment karma should lose the ability to comment.
02:29:42 <dons> glguy: :)
02:29:42 <psykotic> nah. consider people who get a lot of votes total, but with 2/3 down and 1/3 up. that just means what they say is controversial.
02:29:43 <Cale> (maybe for some limited time)
02:31:10 <Cale> Well, if people are modding everything you say into oblivion, I think that's more than just controversial :)
02:31:10 <psykotic> have you guys read that trevino guy's blog?
02:31:29 <matt__r> nope - link?
02:31:29 <ivant> @go trevino blog
02:31:32 <lambdabot> http://3v1n0.tuxfamily.org/blog/
02:31:32 <lambdabot> Title: Treviño&#8217;s Blog
02:31:37 <psykotic> not that one. let me find.
02:31:41 <psykotic> sorry, trevion
02:31:45 <psykotic> http://trevion.blogspot.com/
02:31:47 <lambdabot> Title: Nonlinear
02:32:19 <psykotic> as far as i know, his are the only war stories of clueless commercial programmers being forced to use haskell.
02:32:35 <matt__r> heh - the other one was spanish
02:32:43 <psykotic> http://trevion.blogspot.com/2006/12/little-knowledge-gets-you-long-way.html
02:32:46 <lambdabot> Title: Nonlinear: A little knowledge gets you a long way straight to Hell, http://tinyurl.com/2vdvfa
02:33:15 <dons> psykotic: interesting stuff. there's also joelr's famous pickling combinator/poker server failure
02:33:29 <psykotic> (he's not the clueless one, his coworkers are)
02:33:42 <psykotic> he worked at a DoD contractor that apparently used haskell
02:34:07 <ivant> why he is not @ planethaskell?
02:34:12 <Cale> Yep, that top posting seems like a totally valid rant.
02:34:18 <dons> psykotic: oh, now that is curious. DoD contractor eh?
02:34:23 <psykotic> aetion
02:34:28 <psykotic> i think they're called
02:34:48 <psykotic> this one is good too, http://trevion.blogspot.com/2006/11/functional-pointers.html
02:34:49 <lambdabot> Title: Nonlinear: Functional Pointers
02:34:57 <dons> we've not seen trevion around here recently
02:35:17 <dons> oh, trevion work(ed) at aetion. huh. i should have known that
02:36:07 <psykotic> oh, and this one. http://trevion.blogspot.com/2006/11/functional-anti-patterns.html
02:36:07 <Cale> ... you get maybe one course in functional programming, everybody writes it off as "that weird stuff where you have to think before you can write code," and they never think about it again.
02:36:08 <lambdabot> Title: Nonlinear: Functional Anti-Patterns
02:36:16 <psykotic> it will make you vomit a little in your mouths
02:36:22 <Cale> (from one of the comments on that blog :)
02:37:02 <dons> oh yes, i recall this one `Haskell requires that bad programmers spend time that they could have spent writing bad Java code inventing exciting new ways to write bad code, specially tuned to the mechanisms of functional programming.'
02:37:49 <psykotic> dons: i think it's definitely true. there's that old maxim, "you can write FORTRAN in any language". but in a purely functional language, it's actually much, much worse than just that.
02:37:58 <psykotic> if they just wrote everything in the IO monad, that would be one thing. but oh no.
02:38:13 <int-e> not all bad code is written in Fortran.
02:38:32 <psykotic> int-e, the joke works better that way, though :)
02:38:42 <int-e> and I suspect that despite its limitations there's some good code in Fortran as well.
02:38:44 <psykotic> in 20 years, it will be "you can write Java in any language"
02:38:47 <dolio> Too few people learn fortran for that to be teh case these days.
02:39:33 <Cale> I've seen bad Haskell code. I complained a lot and it really was horrible, but at least it was still referentially transparent, so I could sort out what the fuck it was doing by rewriting expressions on paper.
02:39:35 <dons> php in any language.
02:39:50 <dons> Cale, something I feel that way about darcs :/
02:40:00 * int-e keeps writing functions like "assertNat :: Nat m => p m -> p m; assertNat = id" - is anyone else experiencing that?
02:40:03 <dons> without the referential transparency
02:40:16 <Cale> It was Haskell code written by a C programmer with a PhD in Differential Geometry.
02:40:20 <dons> int-e: hmm. no.
02:40:26 <dons> int-e: should you be using smart constructors?
02:40:28 <dons> and newtype?
02:40:39 <dons> Cale, yeah :)
02:40:52 <dons> i recall tuomovs haskell being pretty weird stuff too
02:40:57 <int-e> dons: maybe I should just stop playing with unsafeCoerce :)
02:40:57 <dons> day 1: let's use alloca
02:41:02 <Cale> It involved types like [([((Int,Int),String)],Int)]
02:41:15 <ivant> Cale, I'm writing some involved algorithms in Haskell right now (dealing with polynomial inequations), and I got lots of ugly stuff
02:41:21 <Cale> which of course were not even annotated
02:41:33 <Cale> At least use newtype!
02:41:44 <ivant> I'd like to make it nicer, although I don't immediately see, how it can be done
02:42:11 <int-e> dons: although even without that I write such utility functions pretty often. Maybe it's just that I prefer them to explicit type signatures, because they allow me to specify only the part of them that matters.
02:43:06 <psykotic> i always write type signatures for top-level defs
02:43:09 <psykotic> in fact i have the warn-about-lacking-type-sigs flag turned on
02:43:16 <dons> int-e: for Nat, get a newtype, a smart constructor, an instance Num perhaps?
02:44:18 <ivant> is it possible to demand type sigs for non-top-level defs (in where clause)?
02:45:29 <psykotic> that would get really annoying.
02:45:30 <psykotic>  :)
02:45:54 <Cale> Oh, the funniest thing that I saw in that code was the use of base 10000 to pack two integers into an Int for no reason.
02:46:01 <ivant> psykotic, that's what I usually do, anyway
02:46:24 <ivant> Cale, wow, weird stuff :-)
02:46:25 <Cale> To make it even better, the base was defined using nagy = 10000.
02:46:33 <psykotic> ivant: usually i find that fixing the top-level def's type fixes enough of the where-defs' types
02:46:41 <Cale> Or something like that
02:46:42 <JohnMeacham> dons: hrm?
02:46:53 <psykotic> ivant: i might want a type signature when i'm writing it, in which case i'll attach it to verify my assumption about what the type should be, and then remove it afterwards.
02:47:02 <Cale> There was some random Hungarian and German identifier names for some reason.
02:47:12 <psykotic> wtf
02:47:51 <dons> JohnMeacham: did your client quit when that exploit got dumped in channel?
02:47:54 <psykotic> cale: i'm off to write a haskell program in ancient greek, in dactyllic hexameter.
02:48:08 <Cale> hehe
02:48:08 <dons> JohnMeacham: i seem to recall issues in the past with your client (and half a dozen others) being vulnerable
02:48:14 <int-e> dons: Naa, that's not what Nat is - Nat is a type class for phantom types for annotating other types with natural numbers. The code works, it's just hard to convince the type checker to do 'the right thing'.
02:48:25 <ivant> psykotic, I have several Very Big (tm) where clauses, and it is sometimes very confusing to find where you have a problem while compiling the code, if you have only the top-level type defs
02:48:55 <psykotic> ivant: i get a weird feeling when i get big where clauses and generally try to break some of it out into top-level defs.
02:49:14 <psykotic> even if it creates more passing around of parameters
02:49:27 <matt__r> ivant: i am with psykotic on this one
02:49:38 <matt__r> ivant: then you can unit test them as well
02:50:02 <psykotic> yep
02:50:20 <ivant> psykotic, I do have that weird feeling, and do try to move the functions to top-level, but I don't see how they can be useful up there
02:50:23 <psykotic> that's actually the best reason for doing it. although i also find the readability of a one-screen where clause vastly diminished
02:50:35 <psykotic> ivant: don't care about the usefulness. you don't have to export them from your module.
02:51:11 <matt__r> ivant: important OR complex are my justifications for having something at the top level
02:51:13 <ivant> (oh, unit testing may be a good idea, however it would really twist my brains to invent good testcases (or properties) for the things I'm writing
02:51:34 <matt__r> ivant: you can just ckuch some data in on the interpreter and see what comes out
02:51:39 <tibbe> I want to be able to use functions defined in where clauses in ghci!
02:51:48 <ivant> matt__r, that's what I usually do :-)
02:52:00 <matt__r> tibbe: same solution, lift them to the top-level
02:52:03 <tibbe> now I have to move them to top level just to test them and move them back
02:52:20 <tibbe> matt__r: I like the reduced lexical scope of the where clause
02:52:21 <psykotic> with the debugger in ghc head, you can probably can
02:52:23 <ivant> matt_r, one also needs to export them :-)
02:52:34 <matt__r> ivant: then just record the "test" in a HUnit test case and you have started a test suite!
02:52:40 <tibbe> matt__r: provides a nice grouping of functions too, the helper functions stay with the main function
02:52:57 <ivant> I *really* want Hat working with ghc6.6 packages
02:52:59 <matt__r> tibbe: its a trade off
02:53:04 <tibbe> matt__r: true :)
02:53:04 <psykotic> ivant: you don't need to export to play around with them in ghci
02:53:12 <tibbe> matt__r: I don't want to make it though!
02:53:15 <matt__r> tibbe: but I think I agree with you - it would be *nice* to have
02:53:28 <malcolmw> ivant: there is a GSoC project currently in progress to make Hat work with the ghc-6.6. libraries
02:53:31 <matt__r> tibbe: but how would it work?
02:53:44 <tibbe> matt__r: good question, meeting time!
02:53:45 <tibbe> afk
02:53:54 <matt__r> malcolmw: do you know what the current status of hat is?
02:53:55 <ivant> malcolmw, I know, I already asked you in the mailing list :-) I'm really waiting for this to happen
02:54:21 <malcolmw> ivant: sorry, I'm not really following the mailing lists - too much traffic
02:54:49 <Cale> Hey, I know... maybe reddit should have something like a rule where you burn 5 karma just posting something, and you need positive karma to post.
02:55:09 <ivant> malcolmw, I mean, you sent me a message about GSoC. Btw, thanks for Hat - it's really cool!
02:55:10 <Cale> And perhaps you get one additional karma point per day for free.
02:55:34 <matt__r> hat is genius
02:56:05 <malcolmw> matt__r: ivant: current status is that kenn is working manually through the base package, which is nearly all traced now.  Meanwhile, he is working on an automatic wrapping tool which should enable _any_ package to be used with Hat, once it is finished.
02:56:14 <matt__r> Cale: nice idea - I just filter it for posts by dons :)
02:56:28 <Cale> Of course, this would need to be paired with a karma wipe to be effective.
02:56:42 <matt__r> malcolmw: so I should sit tight and wait, but things are getting close?
02:56:45 <roconnor> Do you think that linxer is a bot run by somone, or just some program that evolved independently on the net?
02:56:54 <ivant> malcolmw, would it be possible to say that I want to use the package as a black-box and not trace its functions down?
02:57:23 <malcolmw> ivant: that's exactly what wrapping a package is supposed to achieve
02:57:29 <psykotic> roconnor, he is SkyNet!
02:57:35 <quicksilver> ivant: i don't know if someone mentioned this, but one reason there isn't a flag for forcing type sigs in where decls is that you can't always write them, in haskell98 :)
02:58:01 <malcolmw> ivant: no-one is interested in tracing inside a library (except the author), so the plain user should just see API calls, but no deeper
02:58:01 <ivant> quicksilver, because of rank-2 types?
02:58:12 <quicksilver> ivant: no, because of bound type variables
02:59:08 <ivant> quicksilver, can you give an example or explain it?
02:59:32 <matt__r> quicksilver: indeed - I am intruiged
03:02:36 <ivant> malcolmw, sometimes I'm interested in tracing inside a library, because I want to know how some functions are really working (curiosity, mostly, but it helps to learn :-) )
03:02:44 * earthy looks at what malcolmw says and goes 'waaaaant'
03:03:25 <psykotic> malcolmw, what ghc v is official release of hat slated for?
03:03:29 <malcolmw> ivant: yeah, so it would be possible to set a particular package for "trace inside", but by default, they should be black-box
03:03:33 <earthy> (and no, I never did get 'round to finishing that parser change... the parser structure is a bit odd)
03:04:03 <malcolmw> earthy: remind me what the parser change was for?
03:04:12 <xpika> is there a name for two functions which call each other?
03:04:48 <earthy> malcolmw: accept datatype syntax that included higher-rank polymorphism
03:05:05 <malcolmw> psykotic: current ghc I think, 6.6.1, although it shouldn't be too tied to version number
03:05:12 <desegnis> xpika, mutually recursive?
03:05:17 <malcolmw> earthy: oh yes, now I remember
03:05:28 <xpika> i just wrote one :)
03:05:44 <earthy> xpika: mutual recursive functions
03:05:52 <earthy> mutually
03:06:06 <xpika> i thought recursion meant that it refrenced itself
03:06:28 <quicksilver> ivant: sorry, bit busy here. just a moment and I'll make one up
03:06:38 <earthy> yah. if you look at two functions f and g that are mutually recursive, then the set {f,g} refers to itself...
03:06:39 <desegnis> xpika, it references itself indirectly
03:06:42 <ivant> quicksilver, no hurry :-)
03:06:44 <matt__r> xpika: It is applicaple anytime the function "recurs"
03:07:01 <matt__r> eg: re-occurs
03:07:21 <Philippa_> curse = putStrLn "!@#$"
03:07:23 <quicksilver> int-e: let map2 f l = map f' l where f'= f . f
03:07:27 <Philippa_> recurse = do curse; recurse
03:07:28 <quicksilver> int-e: oops, sorry
03:07:33 <quicksilver> ivant: let map2 f l = map f' l where f'= f . f
03:07:42 <quicksilver> ivant: what is the type sig for f' ?
03:08:42 <quicksilver> ivant: if map2 :: (a -> a) -> [a] -> [a], then in some sense f' :: a -> a
03:08:51 <quicksilver> ivant: but the point is it's not any old 'a'
03:08:59 <quicksilver> ivant: it has to be the *same* a as in the map2 sig
03:09:09 <ivant> quicksilver, oh, I see
03:09:25 <quicksilver> ivant: in haskell98 you simply can't express "the same a"
03:09:35 <quicksilver> GHC does have an extension for it
03:10:01 <ivant> and with ghc-exts the ‘a’ in where clause means the same as in the top-level type def?
03:11:12 <quicksilver> ivant: if you use an explicit forall a .
03:11:24 <quicksilver> ivant: then that forall introduces a lexical type score
03:11:26 <quicksilver> scope
03:11:35 <quicksilver> and other references to a inside that scope mean the same a
03:12:09 <ivant> quicksilver, thanks, now I see when I should use forall :-)
03:12:12 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables
03:12:14 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
03:12:32 <quicksilver> but I stress this is a GHC extension
03:12:53 <tibbe> how's Haskell' coming along? I thought it would have been announced by now!
03:13:06 <ivant> quicksilver, I use ghc-exts anyway, so this is just fine
03:13:15 <quicksilver> it's marked as "maybe-adopt" for haskell-prime, it seems
03:14:11 <Cale> dons: what do you think of this idea? http://programming.reddit.com/info/2dl36/comments/c2dno0
03:14:12 <lambdabot> Title: programming.reddit.com: the last outpost of classic reddit discourse (reddit.com ...
03:16:30 <ivant> SPJ is hilarious! (just finished watch Taste of Haskell I)
03:17:03 <ivant> s/watch/watching/
03:17:52 <psykotic> i was a little sad that he didn't wear any of his funky home-knit sweaters for a taste of haskell
03:17:54 <kjdf> are there array literals in ghc?
03:18:02 <psykotic> he did for the keynote though
03:18:05 <kjdf> that could be used for pattern matching or testing for equality
03:18:27 <psykotic> kjdf, arrays aren't algebraic data types, so no pattern matching.
03:18:48 <psykotic> kjdf, are you sure you don't want lists?
03:18:50 <quicksilver> kjdf: use arrayList or whatever for equality testing
03:18:59 <psykotic> (maybe Data.Sequence)
03:19:06 <quicksilver> (or toList and compare against a fixed list)
03:19:16 <kjdf> text.regex returns list of arrays
03:19:33 <kjdf> (list of all matches)
03:19:49 <psykotic> nah
03:19:50 <quicksilver> kjdf: does it? which function?
03:19:54 <psykotic> @hoogle matchRegex
03:19:54 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
03:19:54 <lambdabot> Text.Regex.matchRegexAll :: Regex -> String -> Maybe (String, String, String, [String])
03:19:59 <quicksilver> kjdf: none of the ones I can see use arrays
03:20:01 <psykotic> it returns a list of strings. strings are lists of chars.
03:20:05 <kjdf> overloaded =~
03:20:17 <ivant> @hoogle (=~)
03:20:18 <lambdabot> Did you mean: (=~)
03:20:18 <lambdabot> Prelude.undefined :: a
03:20:18 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
03:20:30 <ivant> @ty (=~)
03:20:32 <lambdabot> Not in scope: `=~'
03:20:43 <ivant> @ty (Text.Regex.=~)
03:20:45 <lambdabot> Not in scope: `Text.Regex.=~'
03:20:58 <opqdonut> @ty Text.Regex.~=
03:21:00 <lambdabot> parse error on input `Text.Regex.~='
03:21:04 <opqdonut> @ty (Text.Regex.~=)
03:21:06 <lambdabot> Not in scope: `Text.Regex.~='
03:21:08 <opqdonut> bah
03:21:15 <kjdf> text.regex.posix, sorry
03:21:39 <ivant> kjdf, maybe you mean lists ([String]), not arrays?
03:22:00 <kjdf> [Arrray Int String]
03:22:07 <kjdf> where each element of array is a submatch
03:22:11 <ivant> oh
03:22:16 <quicksilver> you can get it to return an array
03:22:17 <quicksilver> but you shouldn't
03:22:25 <kjdf> (I'd like lists more though)
03:22:32 <kjdf> [[String]]
03:23:12 <quicksilver> kjdf: it will return that if you ask for that
03:23:17 <kjdf> hm..
03:23:20 <quicksilver> RegexLike a b => RegexContext a b [[b]]
03:23:27 <ivant> kjdf, you can do something like case (elems matchArray) of (m:ms) -> ...
03:23:32 <int-e> Cale: That sounds like a good way to get many "new" users. It won't stop trolls who don't care about recognition.
03:23:43 <quicksilver> ivant: it's not needed though, and it's silly to construct and destruct a pointless array
03:24:20 <kjdf> ah yes, thanks quicksilver
03:25:51 <quicksilver> kjdf: if you want my opinion, they went a bit silly with the overloading on Regexps
03:26:00 <quicksilver> kjdf: just because it can't be done doesn't mean it should be done :)
03:26:46 <Cale> int-e: I suppose that for comment trolls, it's rather tricky, but it would still effectively prevent the article shotgunning, if, say, you limit the number of unique new users from a given IP address in a fixed amount of time.
03:26:49 <quicksilver> in particular, I see no merit in the MatchArray overloads, you could always construct one if you wanted one
03:30:14 <Cale> int-e: I removed the little section on negative comments though, since it's not central to my point, and probably will receive similar reactions :)
03:39:56 <kjdf> ok, another question - is there a library or function for list splicing?
03:40:03 <kjdf> pick [0,2..] [1,2,3] = [2,4,6]
03:40:49 <opqdonut> > let list = [0..2] in map (list!) [2,4,6]
03:40:50 <lambdabot>  Couldn't match expected type `Array a e'
03:40:57 <opqdonut> > let list = [0..2] in map (list!!) [1,2,3]
03:40:59 <lambdabot>  Exception: Prelude.(!!): index too large
03:41:06 <kjdf> ok
03:41:06 <Cale> kjdf: not in particular. Also, that's fairly expensive.
03:41:06 <opqdonut> > let list = [0,2..] in map (list!!) [1,2,3]
03:41:08 <lambdabot>  [2,4,6]
03:41:08 <opqdonut> bah
03:41:12 <opqdonut> there
03:41:24 <kjdf> seems fine
03:41:27 <wolverian> kjdf, you probably want an array if you do indexing
03:41:44 <opqdonut> yep
03:41:50 <kjdf> these are fairly small lists and data is small - just a oneshot script
03:42:17 <Cale> So if you know that either the index list or the list of elements being indexed is finite, you can make it faster. Also, if you could guarantee the indices were ordered.
03:42:45 <quicksilver> wolverian: I beg to differ. I don't think you want an array very often :)
03:43:15 <wolverian> quicksilver, oh?
03:43:25 <quicksilver> they're a bit clunky, just not very idiomatic
03:43:37 <quicksilver> I'd rather use Data.List or Data.Sequence
03:43:48 <Cale> quicksilver: They're actually quite nice :)
03:43:57 <quicksilver> I'd only use arrays for something which *really* feels like an array, like the pixels in a bitmap image
03:44:10 <Cale> Nicer than arrays in most other languages, since you can use lots of different things to index them.
03:44:17 <quicksilver> opqdonut: I think zipWith (!!) is more idiomatic :)
03:44:30 <SemanticPhilosop> @users
03:44:30 <lambdabot> Maximum users seen in #haskell: 375, currently: 346 (92.3%), active: 11 (3.2%)
03:44:33 <roconnor> > all $ map (<1) $ take 45 (iterate (\x -> (x + (1/57))/(1-x/57) 0)
03:44:33 <lambdabot>  Parse error
03:44:43 <roconnor> > all $ map (<1) $ take 45 (iterate (\x -> (x + (1/57))/(1-x/57)) 0)
03:44:44 <lambdabot>  Couldn't match expected type `a -> Bool'
03:44:49 <opqdonut> quicksilver: ah, true
03:44:53 <roconnor> > all (<1) $ take 45 (iterate (\x -> (x + (1/57))/(1-x/57)) 0)
03:44:54 <lambdabot>  True
03:45:22 <quicksilver> opqdonut: well maybe not idiomatic. Just more showoffy
03:45:25 <quicksilver> :P
03:45:34 <roconnor> > all ((-1)<) $ take 45 (iterate (\x -> (x + (1/57))/(1-x/57)) 0)
03:45:36 <lambdabot>  True
03:45:45 <wolverian> quicksilver, depends on how large the speed difference between arrays and sequences/lists is, I suppose.
03:45:57 <int-e> > atan (1/57) < pi/(4*44)
03:45:58 <lambdabot>  True
03:46:13 <quicksilver> wolverian: sequences are pretty damn fast
03:46:18 <opqdonut> yeah
03:46:24 <quicksilver> wolverian: at least, asymptotically fast
03:46:31 <opqdonut> how are they implemented btw?
03:46:35 <quicksilver> I imagine their constant factor is quite a lot worse than an unboxed array
03:46:38 <opqdonut> doubly-linked lists?
03:46:38 <quicksilver> 2-3 fingertrees
03:46:43 <opqdonut> ok
03:46:51 <quicksilver> doubly-linked lists can't share
03:46:57 <SemanticPhilosop> the derive package doesn't cleanly compile under ghc 6.7 - got any pointers?
03:47:00 <quicksilver> sequences are pretty clever at sharing
03:47:09 <opqdonut> oh okay
03:47:10 <quicksilver> which will make them faster than arrays, for some kinds of splicing operations
03:47:16 <quicksilver> since you can splice without copying (much)
03:47:21 <wolverian> quicksilver, too bad Data.Array doesn't give any big-O times
03:47:34 <quicksilver> wolverian: pretty much common sense, I think
03:47:43 <opqdonut> mhmm
03:47:45 <quicksilver> wolverian: O(1) for index/update, O(n) for copying stuff around
03:47:46 <ivant> is there some “List fusion for dummies” paper?
03:47:57 <quicksilver> ivant: dons+dcoutts paper is nice
03:48:10 <wolverian> quicksilver, yah.
03:48:21 <quicksilver> ivant: it gives an overview of how the foldr/build stuff works before going on to explain their stream stuff andwhat it does better
03:48:22 <wolverian> so if you do only indexing, you might win with arrays over sequences :)
03:48:34 <quicksilver> wolverian: yes
03:50:26 <int-e> roconnor: I'd have expected 'take 46' there.
03:51:22 <roconnor> int-e: I'm computing 44*arctan (1/57).
03:51:36 <njd> @where derive
03:51:36 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
03:51:58 <int-e> roconnor: hmm ok. then I'm wrong :)
03:52:12 <ivant> quicksilver, talking about arrays and friends, what do you think makes sense to use to represent the multivariate polynomials (with the Num coefficients)?
03:52:33 <roconnor> > 4*(44*atan(1/57) + 7*atan(1/239) + 12*atan(1/682) + 24*atan(1/12943))
03:52:35 <lambdabot>  3.282355016054941
03:52:38 <quicksilver> well obviously it depends what you're going to do with them
03:52:45 <roconnor> hmm
03:52:47 <quicksilver> I'd start with lists
03:52:48 <ivant> quicksilver, I use UArray [Int] N (where N is actually Double) now
03:52:50 <roconnor> rounding error?
03:52:51 <quicksilver> and change if it was too slow :)
03:53:21 <roconnor> or did I make a mistake?
03:53:33 <roconnor> oops
03:53:35 <quicksilver> ivant: sounds fine if you know you need the speed
03:53:37 <roconnor> > 4*(44*atan(1/57) + 7*atan(1/239) - 12*atan(1/682) + 24*atan(1/12943))
03:53:39 <lambdabot>  3.141592653589793
03:53:41 <ivant> quicksilver, I want to do lots of transformations, sometimes I need "slicing" the coefficients array in some direction
03:53:42 <roconnor> better
03:54:05 <ivant> quicksilver, well, I'm not sure what alternatives do I have.
03:54:21 <int-e> roconnor: but how does computing tan(44*atan(1/57)) help you with that?
03:54:50 <roconnor> int-e: I'm not computing tan.
03:54:58 <int-e> roconnor: your iterate thing does
03:55:06 <roconnor> but it does help me prove that the result is Pi/4
03:55:31 <njd> any derive package users out there? any of you got it to compile under ghc 6.7
03:55:33 <njd> ?
03:55:47 <ivant> quicksilver, I really don't like that [Int] thing for indices, but I don't know how to replace it
03:56:01 <roconnor> int-e: n*arctan(x) == arctan(iterate f x!!n)
03:56:06 <roconnor> for sufficently small n and x.
03:56:31 <opqdonut> what is f?
03:56:53 <roconnor> oop
03:56:57 <roconnor> int-e: n*arctan(x) == arctan(iterate f 0!!n)
03:56:58 <roconnor> where
03:57:25 <roconnor> f = (\y -> (x + y)/(1-x*y))
03:58:24 <int-e> > let f n m = (iterate (\x -> (x + (1/n))/(1-x/n)) 0) !! m :: Rational; g a b = (a+b)/(1-a*b) in foldr1 g [f 57 44, f 239 7, -f 682 12, f 12943 24]
03:58:25 <lambdabot>  1%1
03:59:04 <roconnor> and hence clearly the result will be Pi/4
03:59:51 <roconnor> assuming all the n and x are small enough.
04:05:56 <ari> @pl \a b c -> a + b + c
04:05:57 <lambdabot> ((+) .) . (+)
04:06:58 <roconnor> @pl \(+) a b c -> a + b + c
04:06:58 <lambdabot> (line 1, column 3):
04:06:58 <lambdabot> unexpected "+"
04:06:58 <lambdabot> expecting pattern
04:07:10 <quicksilver> ari: that combinator is an excerpt from the popular game 'Donkey Kong'
04:07:14 <roconnor> @pl \f -> (f .) . f
04:07:14 <lambdabot> (.) =<< (.)
04:07:32 <roconnor> @unpl (.) =<< (.) (+)
04:07:32 <lambdabot> ((\ e f -> (+) (e f)) >>= \ a b c -> a (b c))
04:07:51 <MyCatVerbs> Good day, #haskell.
04:07:53 <roconnor> > (.) =<< (.) (+) 1 2 3
04:08:01 <lambdabot>        add an instance declaration for (Num ((a -> b) -> b -> c))
04:08:10 <roconnor> > ((.) =<< (.)) (+) 1 2 3
04:08:11 <lambdabot>  6
04:08:19 <mauke> > sum [1 .. 3]
04:08:20 <roconnor> @unpl ((.) =<< (.)) (+)
04:08:20 <lambdabot>  6
04:08:20 <lambdabot> ((\ d e f -> d (e f)) >>= \ a b c -> a (b c)) (+)
04:08:33 <mauke> > 3 * 4 `div` 2
04:08:34 <lambdabot>  6
04:13:56 <njd> @seen ndm
04:13:56 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 18h 4m 45s ago, and .
04:15:47 <Philippa_> at some point today he'll be heading camward
04:22:18 <Ben`> what's the difference between ^ and **?
04:22:35 <xpika> src (**)
04:22:37 <xpika> @src (**)
04:22:37 <lambdabot> Source not found. My mind is going. I can feel it.
04:22:41 <xpika> @src (^)
04:22:42 <lambdabot> Source not found. Wrong!  You cheating scum!
04:22:57 <dcoutts> @type (^)
04:23:06 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
04:23:07 <dcoutts> hia ndm
04:23:27 <xpika> (**) is for floating point only
04:23:28 <dcoutts> @type (**)
04:23:30 <lambdabot> forall a. (Floating a) => a -> a -> a
04:23:47 <dcoutts> Ben`: yep, they're for different classes of types
04:23:48 <mathias_> How to express an instance for a class Foo (b::* -> * -> *) x such that x contains as a part the second argument type of the b type constructor?
04:23:51 <xpika> ** is to ^ as / is to div?
04:24:12 <Ben`> oh, ok
04:24:12 <ndm> hi dcoutts
04:24:15 <Ben`> thanks
04:24:32 <mathias_> The issue is that the instance I declared is more general than it really is.
04:25:12 <moonlite__> dcoutts: i read a post on -cafe about threads and java. This is really not my topic, but have you read what the java-gnome guys are doing? It seems, if i understand it correctly, that they have managed to build real thread-safety into their binding. http://research.operationaldynamics.com/blogs/andrew/software/java-gnome/ Is it of interest?
04:25:16 <lambdabot> Title: Andrew Cowie - java-gnome 4.0.3 released!, http://tinyurl.com/3b84wc
04:25:24 <quicksilver> mathias_: that's sort of what functional dependencies are for, although it's a bit subtle
04:25:31 <moonlite__> err. threads and gtkhs in the first sentence there
04:25:33 <JohnMeacham> dons: I am not sure. I don't really use IRC that much. I am using xchat.
04:25:40 <quicksilver> mathias_: maybe you mean somethin like this:
04:25:53 <mathias_> quicksilver, I already have a functional dependency b -> x
04:25:58 <JohnMeacham> dons: I use gale mainly. http://gale.org/  pub.comp.haskell@ofb.net is the haskell stop.
04:25:59 <quicksilver> class Foo b x a | b -> a, x -> a
04:25:59 <lambdabot> Title: Gale Home
04:26:01 <JohnMeacham> spot.
04:26:44 <quicksilver> mathias_: or you can just write the partially unified instance out properly?
04:26:46 <mathias_> quicksilver, yes, adding an extra class parameter isn't that difficult, but is it necessary?
04:27:07 <quicksilver> instance Foo (b p1 p2) (x p2)
04:27:32 <quicksilver> not *exactly* sure what you intended by 'x contains as a part)
04:27:51 <dcoutts> moonlite__: mm, it'll be interesting to follow that work. I'd assumed that locking around every tiny call would be rather slow
04:27:56 <mathias_> quicksilver, that has as a problem that I want to refer to p1 and p2 in method signatures.
04:28:39 <quicksilver> mathias_: can you not do that?
04:28:53 <quicksilver> I thought variables in an instance head were in scope in methods
04:29:09 <mathias_> quicksilver, with your approach, I think no, but convince me if you can. :)
04:29:10 <quicksilver> if not, you can normally hack around that with 'isTypeOf' style tricks
04:29:29 <quicksilver> 'asTypeOf' even
04:29:50 <quicksilver> if it's not that simple, and p2 isn't a direct parameter of x
04:29:59 <quicksilver> then maybe you have an auxiliary class?
04:29:59 <mathias_> quicksilver, you are now making giant leaps.
04:30:07 <quicksilver> class GoesTogether x p2 ...
04:30:23 <quicksilver> then instance GoesTogether x p2 => Foo (b p1 p2) x
04:33:03 <quicksilver> mathias_: well, make sure you have some function func :: b p1 p2 -> p2
04:33:15 <quicksilver> mathias_: it doesn't even need to *do* antyhing, it just needs to exist for the type unifier
04:33:25 <quicksilver> mathias_: then whenever you want to 'refer to' p2
04:33:42 <quicksilver> mathias_: you do (.. expr ..) `asTypeOf` func myb
04:33:47 <quicksilver> where myb :: b
04:44:55 <cizra> hi
04:45:52 <cizra> I've wanted to do something brain-twisting again for quite some time. FP seems to be something both interesting and educational.
04:46:06 <cizra> But can you comment on Haskell's merits over other FP languages?
04:47:45 <mauke> haskell has warm, fuzzy things
04:48:02 <cizra> Like what?
04:48:12 <mathias_> Does Haskell have a vector type?
04:48:15 <mauke> Maybe, [], IO :-)
04:48:16 <ivant> cizra, it's probably one of the most brain-twisting languages used for real projects :-) Does it count for a merit?
04:48:17 <vegai> like monads
04:48:27 <cizra> ivant: Yes, very much.
04:48:38 <mathias_> Or is there an implementation for GHC?
04:48:47 <mauke> what's a vector type?
04:48:50 <cizra> ivant: But Erlang can also say that.
04:49:04 <vegai> cizra: not really. Erlang's pretty easy.
04:49:37 <cizra> Actually, I haven't seen any of it, but it sounds alien. Just like Haskell.
04:50:06 <mathias_> mauke, something supporting amortized constant time insertion and lookup of elements by rank.
04:50:24 <mauke> insertion?!
04:50:33 <earthy> Haskell's merits over other FP languages is that unlike almost all other FP languages it is pure and lazy
04:50:48 <ivant> cizra, oh, maybe you should see a video where Simon Peyton Jones giving a talk "Taste of Haskell" @ OSCON
04:50:48 <earthy> purity and laziness help a lot
04:50:53 <zvrba> why is lazyness a merit?
04:51:02 <zvrba> how does it help?
04:51:05 <mauke> mathias_: a trie might be able to do that
04:51:10 <mm_freak> mathias_: there are lots of data structures with different properties
04:51:25 <mm_freak> mathias_: arrays, maps, etc.
04:51:29 <earthy> zvrba: it's more compositional
04:51:49 <zvrba> earthy: in what sense?
04:51:51 <mathias_> mm_freak, do you think that broad statement is relevant?
04:52:01 <MyCatVerbs> zvrba: means you can write code in ways that wouldn't neccessarily terminate in other languages.
04:52:21 <earthy> and compose it into code that does terminate
04:52:38 <mm_freak> mathias_: yes, because i'm pretty sure you'll find what you're looking for somewhere below Data
04:52:45 <cizra> I was pretty amazed with the textbook example of factorial finding.
04:52:46 <mathias_> mauke, I doubt it.
04:52:48 <cizra> It was SO quick!
04:52:51 <cizra> and easy
04:52:52 <ivant> cizra, one of the greatest merits is a vibrant communty which consists of many bright people who are often willing to help :-)
04:52:54 <mauke> mathias_: why?
04:52:56 <earthy> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in take 20 fibs
04:52:58 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
04:53:24 <mathias_> mauke, tries are tree based. There is bound to be a log n factor somewhere.
04:53:30 <mauke> no
04:53:44 <mauke> trie lookup depends on key length
04:53:53 <mauke> if your keys are 4-byte integers, you get O(1) lookup
04:54:19 <MyCatVerbs> That sounds just like a hash table.
04:54:23 <ivant> let fibs = fix (\f n -> if n<2 then 1 else n * (f (n-1))) in map fibs [0..5]
04:54:30 <ivant> > let fibs = fix (\f n -> if n<2 then 1 else n * (f (n-1))) in map fibs [0..5]
04:54:31 <lambdabot>  [1,1,2,6,24,120]
04:54:36 <mathias_> mauke, right, my mistake.
04:54:38 <mauke> hash tables are O(n) worst case
04:54:58 <cizra> Oh, a Haskell interpreting bot?
04:55:06 <mathias_> mauke, still, how to make a general purpose vector out of it?
04:55:14 <cizra> > fac n = if n == 0 then 1 else n * fac (n-1)
04:55:15 <lambdabot>  Parse error
04:55:16 <MyCatVerbs> cizra: amongst other features.
04:55:27 <mauke> I don't know what you mean by "vector". I just know that tries support O(1) insertion/lookup
04:55:36 <wolverian> cizra, put that in a let ... in ...
04:55:37 <cizra> Why parse error? ghci runs this just fine
04:55:38 <MyCatVerbs> cizra: add a "let" to that
04:55:41 <mm_freak> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac 10
04:55:43 <lambdabot>  3628800
04:55:43 <mauke> cizra: no, it doesn't
04:55:47 <wolverian> cizra, no, it doesn't
04:55:51 <wolverian> mauke, stop pre-echoing me!
04:55:52 <cizra> > let fac n = if n == 0 then 1 else n * fac (n-1)
04:55:52 <lambdabot>  Parse error
04:55:54 <quicksilver> MyCatVerbs: tries do sound quite a lot like hash tables
04:55:55 <mathias_> mauke, by rank?
04:56:02 <quicksilver> MyCatVerbs: but they're rather subtle internally :)
04:56:04 <mauke> what's a rank?
04:56:06 <wolverian> cizra, you forgot the in part
04:56:21 <ivant> cizra, let <definitions> in <expression>
04:56:27 <Ben`> cizra: let fac n = product [1..n]
04:56:36 <cizra> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac(119)
04:56:37 <anybody> if i have an instance of Bounded and Enum do i have to explicitely define the enumFrom method? i tried without it but [n..] seems to run pas maxBound
04:56:37 <lambdabot>  5574585761207605881323431711741977155627288610948358175246392793584694631037...
04:56:39 <mathias_> mauke, ok, the rank then it the string in the tree.
04:56:40 <cizra> (=
04:56:52 <anybody> s/pas/past
04:56:59 <zvrba> oh, it has builtin large number arithmetic!
04:57:01 <cizra> ivant: thanks
04:57:02 <zvrba> how convenient
04:57:07 <cizra> zvrba: Very. I'm amazed.
04:57:17 <quicksilver> anybody: well it's up to your Enum instance to be compatible with your Bounded instance
04:57:26 <quicksilver> anybody: where did you get the Enum instance from? did you write it?
04:57:30 <zvrba> cizra: that was one of my largest annoyances with SML
04:57:37 <anybody> quicksilver: yup. i wrote it
04:57:40 <mathias_> mauke, where can I find such a Trie library?
04:57:49 <zvrba> too verbose syntax for types not in the core language
04:57:51 <mauke> mathias_: no idea
04:58:00 <mm_freak> cizra: and it's the most logical language i know of
04:58:04 <mm_freak> > let 2+2 = 5 in 2+2
04:58:05 <lambdabot>  5
04:58:09 <cizra> mm_freak: What 'bout prolog?
04:58:16 <mm_freak> =)
04:58:23 <zvrba> cizra: prolog is.. a bit weird.
04:58:26 <quicksilver> anybody: then yes, since you wrote the instance, you should supply the enumFrom method :)
04:58:32 <zvrba> cizra: sometimes you have to fight the builtin search strategy.
04:58:42 <wli> cizra: LambdaProlog, Mercury, etc.
04:58:53 <zvrba> cizra: depth-first search is hardcoded in the language >:
04:58:58 <mm_freak> yeah, prolog is weird, but interestingly, haskell is a superset of prolog
04:58:59 <quicksilver> anybody: the documentation for Enum gives an example
04:59:04 <wli> zvrba: Breadth-first search semantics a la PTTP help.
04:59:16 <zvrba> wli: PTTP?
04:59:27 <anybody> quicksilver: you mean that one here? http://haskell.org/onlinereport/basic.html 6.3.4
04:59:28 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
04:59:28 <ivant> mm_freak, and a Turing Machine to rule them all :-)
04:59:39 <wli> zvrba: Prolog Technology Theorem Prover.
04:59:40 <mm_freak> ivant: indeed =)
04:59:44 <zvrba> wli: the point was that search algorithm is hardcoded into the language. which makes it inconvenient if you want to bypass it
04:59:51 <MyCatVerbs> Oh and Haskell has dons.
04:59:56 <quicksilver> anybody: I meant this http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AEnum
04:59:58 <lambdabot> http://tinyurl.com/ovjef
05:00:02 <anybody> zvrba: are you zvrba the greek?
05:00:02 <MyCatVerbs> dons being scarily clever.
05:00:15 <quicksilver> anybody: but it seems to be similar :)
05:00:17 <zvrba> anybody: i wouldn't know.
05:00:40 <anybody> zvrba: hm i guess not then
05:00:56 <zvrba> you're free to guess
05:01:03 <zvrba> i can't tell you whether you're right
05:02:05 <wli> zvrba: I think DFS is the nasty because it gets nontermination in so many cases. It's not so hard to code one's own search strategies otherwise (heck, you have to do it all "by hand" in Haskell).
05:03:11 <zvrba> wli: it's _better_ to do it by hand when you need it than fighting against it when you don't :)
05:03:39 <quicksilver> zvrba: this is true, but one should be careful with that argument
05:03:56 <wli> For that case, I use another language.
05:04:00 <quicksilver> zvrba: unconstrained invocation of that argument leads to programming everything in assembly :)
05:04:04 <zvrba> that aside, I did find prolog useful for certain class of problems
05:04:18 <zvrba> but not too often
05:04:37 <wli> It's a useful tool, but not one you need every day.
05:04:44 <zvrba> agreed.
05:05:24 <anybody> quicksilver: enumFrom x = enumFromTo x maxBound. but this could be defined by default. why isn't it? because you can't assume that an instance of Enum is also of class Bounded?
05:05:36 <quicksilver> wli: much like a compost aerator
05:05:40 <quicksilver> anybody: exactly
05:06:03 <quicksilver> "prolog is like a compost aerator"!
05:06:20 <anybody> @qwe1234
05:06:20 <lambdabot> Unknown command, try @list
05:06:28 <anybody> @quote qwe1234
05:06:28 <lambdabot> qwe1234 says: are you really this dense, or just trolling me?
05:06:32 <wli> quicksilver: The people I know who use that argument in an unconstrained fashion have spent small fortunes on FPGA burners to build their own CPU architectures.
05:06:48 <quicksilver> wli: and sometimes, such people yield interesting developments :)
05:06:56 <quicksilver> wli: and sometimes, they just burn money
05:06:57 <quicksilver> :)
05:07:07 <anybody> @quote qwe1234
05:07:07 <quicksilver> wli: did you see the haskell -> fpga compiler?
05:07:07 <lambdabot> qwe1234 says: i'm still waiting for the list of differences between lisp and php that matter.
05:07:24 <wli> quicksilver : They mostly maintain driver stacks.
05:07:35 <wli> quicksilver: No but I'm not surprised.
05:07:40 <anybody> @quote qwe1234
05:07:40 <lambdabot> qwe1234 says: laziness is TEH SUCK, by the way. there's a reason we got rid of it after writing the first fortran compiler.
05:08:45 <MyCatVerbs> quicksilver: "atom"?
05:09:03 <MyCatVerbs> http://funhdl.org/wiki/doku.php/atom
05:09:05 <lambdabot> Title: atom [funHDL]
05:09:16 <MyCatVerbs> That the one? Or are there others?
05:09:28 <quicksilver> MyCatVerbs: that's something slightly different
05:09:34 <quicksilver> MyCatVerbs: that's a DSL for HDL, or something?
05:09:43 <quicksilver> MyCatVerbs: I'm talking about an actual haskell compiler backend
05:09:52 <quicksilver> @where reduceron
05:09:52 <lambdabot> I know nothing about reduceron.
05:10:27 <wli> They ought to merge it into ghc. It's got everything else, so it's best to include the one missing piece.
05:10:34 <quicksilver> @where+ reduceron http://www-users.cs.york.ac.uk/~mfn/reduceron/index.html
05:10:35 <lambdabot> Done.
05:10:41 <quicksilver> wli: it's not based on GHC, though
05:10:49 <quicksilver> neither is it complete
05:10:52 <wli> yhc?
05:10:54 <quicksilver> but it's pretty cool
05:10:55 <quicksilver> yes
05:11:31 <quicksilver> of course what it actually is, to be precise, is a VM which runs on an FPGA
05:11:34 <MyCatVerbs> YHC having a smaller codebase than GHC, it's easier to hack on for research purposes. (Then you, ideally, port your thesis into GHC so that everyone can use it.)
05:11:44 <quicksilver> plus a compiler from haskell -> this VM bytecode
05:11:54 <quicksilver> 'Reduceron' is the VM
05:11:57 <MyCatVerbs> quicksilver: was gonna say, that's not Haskell-to-FPGA, that's a Haskell machine.
05:12:06 <quicksilver> MyCatVerbs: yes, you're right
05:12:15 <quicksilver> it's still cool, but you're absolutely right
05:12:35 <wli> So Reduceron is a CPU designed around Haskell?
05:12:35 <MyCatVerbs> Ah, righty.
05:12:39 <MyCatVerbs> wli: yep.
05:12:41 <hpaste>  anybody pasted "possibly shorter?" at http://hpaste.org/2152
05:12:50 <MyCatVerbs> wli: modern equivalent to a Lisp Machine. :)
05:13:18 <wli> Haskell's taking off everywhere else. I don't see why not.
05:13:22 <anybody> i have an Enum for poker card suits and i'm not sure whether it would be possible to make the definition shorter any ideas?
05:13:55 <MyCatVerbs> "| x==10         = Jack" <-- you can omit that line, it'd have already been caught by the pattern-match above.
05:14:18 <Cale> anybody: You only have to define toEnum and fromEnum.
05:14:35 <quicksilver> Cale: he needs to define fromEnumTo to get correct bounded behaviour
05:15:12 <Cale> oh, right. But it's okay not to have succ and pred.
05:15:19 <anybody> MyCatVerbs: oh right. i have the Number 10 case twice ;-)
05:15:38 <quicksilver> anybody: to be honest I think it would be much less painful to list out the face cases
05:15:57 <anybody> Cale: but how does it know then how to handle succ and pred?
05:16:00 <quicksilver> data Face = One | Two | Three | Four ... | Ten | Jack | Queen | King
05:16:11 <quicksilver> anybody: fromEnum then (+1) then toEnum :)
05:16:18 <wli> Just make a table or something.
05:16:25 <quicksilver> if you used the exhaustive definiton of Face
05:16:32 <anybody> quicksilver: yeah. i guess so. but i wanted to get some experience with Enum ;-)
05:16:33 <Cale> anybody: The class defines a default implementation
05:16:35 <quicksilver> then the derived Enum instance would be the right one :)
05:16:56 <Cale>     succ             =  toEnum . (+1) . fromEnum
05:16:56 <Cale>     pred             =  toEnum . (subtract 1) . fromEnum
05:17:50 <MyCatVerbs> anybody: yarf.
05:17:54 <anybody> oh cool.
05:18:11 <anybody> MyCatVerbs: yarf?
05:18:42 <MyCatVerbs> s/f/s/
05:18:58 <MyCatVerbs> quicksilver: also, http://funhdl.org/wiki/doku.php <-- nice list. ^^
05:18:59 <lambdabot> Title: funHDL [funHDL]
05:19:19 <MyCatVerbs> I think a few of those are commercial, though. All the strong optimizing ones are, anyway.
05:19:31 <anybody> MyCatVerbs: http://sw.deri.org/2004/06/yars/ ?
05:19:33 <lambdabot> Title: YARS: Yet Another RDF Store
05:19:37 <quicksilver> MyCatVerbs: *nod*
05:20:55 <anybody> MyCatVerbs: what means yars?
05:21:19 <anybody> MyCatVerbs: yars= your are really stupid?
05:21:38 <MyCatVerbs> ...no, I mean as in, mutated inbred way of mispronouncing, "yes."
05:21:44 <MyCatVerbs> x_x
05:22:09 <Cale> I spoke in haiku, for over seven hours! You didn't listen!  It seems so strange now, I've been doing it so long, to finally stop.
05:22:41 <cizra> Cale: Way to go
05:23:17 * MyCatVerbs applauds.
05:23:56 <cizra> Not a real haiku, though. Those are required to talk about weather.
05:24:22 <Cale> Hehe, not really. Only for a few minutes, speaking to my friend.
05:24:56 <Cale> Traditionally, Japanese include kigo, clues to the season.
05:25:21 <MyCatVerbs> Come live in Wales for a few years, then.
05:25:25 <njd> @seen ndm
05:25:26 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 56m 2s ago, and .
05:25:27 <anybody> hm. now another prob. its possible to construct a Face with Number x where x>10 or <2 how can i restrict the parameter to the constructor?
05:25:33 <MyCatVerbs> You'll find yourself entirely incapable of discussing anything *except* the weather.
05:25:49 <Cale> The syllables go: five then seven and five again. That is a haiku. :)
05:26:03 <quicksilver> anybody: basically, you have to hide that constructor
05:26:10 <quicksilver> anybody: and export only a 'safe' constructor
05:26:24 <opqdonut> or use type arithmetic :)
05:26:42 <Cale> anybody: Or just list all the possibilities in the type definition
05:27:03 <quicksilver> which would then get you the 'right' enum instance for free
05:27:20 <anybody> hm. that solution would be too trivial
05:27:31 <Cale> data Face = Ace | Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | Jack | Queen | King deriving (Eq, Ord, Num, Bounded, Show, Read)
05:27:33 <anybody> i wouldn't learn much dong that ;-)
05:27:40 <anybody> s/dong/doing
05:28:04 <doserj> Cale: Num?
05:28:28 <Cale> er, not Num :)
05:28:34 <Cale> Enum :)
05:28:38 <doserj> you want to multiply Queens with Kings? :)
05:29:00 <dons> wow, the spoj contest guys have some nice haskell tricks (http://haskell.org/haskellwiki/SPOJ#Techniques_for_dealing_with_problems_efficiently) such as reforking your program with +RTS flags, to set GC flags not otherwise settable.
05:29:02 <lambdabot> Title: SPOJ - HaskellWiki, http://tinyurl.com/2bycgs
05:29:02 <quicksilver> I believe Queens and Kings do multiply
05:29:06 <quicksilver> that's kind-of the point
05:29:14 <anybody> doserj: why not? seems quite natural to me
05:29:22 <anybody> doserj: outcome would be jack ;-)
05:30:40 <quicksilver> A 'Jack' is actually not a prince, but rather a court jester or fool, I think
05:30:46 <njd> @tell ndm Hi: I can't compile the derive package under ghc 6.7 - any hints?
05:30:46 <lambdabot> Consider it noted.
05:30:46 <quicksilver> it used to be called a Knave
05:32:24 <Cale> Now it's called a Jack. It used to be called a knave, a long time ago.
05:33:26 <anybody> hm knave sound much more like the term we use "Knabe"
05:33:38 <mauke> Cale: you should write something like Coy for ghc
05:33:44 <mauke> http://search.cpan.org/~dconway/Coy-0.05/lib/Coy.pm
05:33:45 <lambdabot> Title: The CPAN Search Site - search.cpan.org
05:34:08 * Cale fears that he might  be developing some kind  of OCD now.
05:35:11 <Cale> :)
05:41:54 <eivuokko> dcoutts, Yo?
05:42:04 <dcoutts> eivuokko: hia
05:42:41 <dcoutts> eivuokko: did you think I pinged you? If so, I don't recall :-)
05:43:01 <eivuokko> dcoutts, I've got cabal question :)  I am not sure how to make correct haddock links, without installing prequisite packages, in Windows.
05:43:10 <dcoutts> hmm
05:43:20 <eivuokko> If I install them in temp location, the links will be wrong.
05:43:34 <SamB_XP> eivuokko: you definately need the haddock interface files
05:43:57 <SamB_XP> the other files, not so much
05:44:02 <dcoutts> so haddock checks with ghc-pkg for links to installed packages
05:44:06 <eivuokko> dcoutts, Yes
05:44:14 <eivuokko> dcoutts, Rather, Cabal does it for haddock
05:44:30 <eivuokko> dcoutts, Saw my post and patch about that field-handling in Cabal? ;)
05:44:58 <dcoutts> eivuokko: ah ok, we used to pass --package to haddock, so now we do it on haddock's behalf do we ?
05:45:19 <eivuokko> dcoutts, I dunno what --package flag is.  We pass info via --read-interface now.
05:45:25 <dcoutts> right
05:45:46 <dcoutts> haddock can do the ghc-pkg querying itself if you tell it what packages to look at
05:45:59 <dcoutts> but presumably there's some reason we don't do that anymore
05:46:20 <dcoutts> eivuokko: so if the .haddock files do not exist, then there's not a lot we can do
05:46:47 <dcoutts> eivuokko: if they do exist locally rather than installed we might still be ok
05:46:48 <eivuokko> dcoutts, Uhm, rather, they exist in wrong location.
05:46:51 <dcoutts> right
05:47:21 <dcoutts> eivuokko: so there's this haddock --html-location=  flag, I'm not sure what it does exactly
05:47:36 <Igloo> dons: Re +RTS flags, in normal usage you can link with a small C file to set those
05:47:49 <dcoutts> eivuokko: I presume it changes the link location rather than where it looks for the .haddock files
05:48:01 <eivuokko> dcoutts, We can't use it, I think, because Common Files-structure is not right.
05:48:21 <dcoutts> eivuokko: we should put docs not in Common Files anyway
05:48:23 <dcoutts> right?
05:48:37 <dcoutts> eivuokko: I'm adding a docdir separate from datadir
05:48:41 <eivuokko> dcoutts, Yes....how will future docdir help?
05:48:56 <dcoutts> so we can put docs somewhere other than Common Files
05:49:02 <eivuokko> dcoutts, afaict, --html-location means the way ghc stores haddock docs.
05:49:13 <dcoutts> --html-location=URL  Location of HTML documentation for pre-requisite packages
05:49:38 <eivuokko> Ok, so, Program Files\Haskell\ghc-x.y.z\haddock
05:49:42 <eivuokko> And make installers use that too?
05:49:47 <eivuokko> ghc installers
05:50:03 <dcoutts> I've no idea about ghc installers
05:50:06 <eivuokko> Well
05:50:16 <dcoutts> but the ghc-pkg tells us where the ghc installer put them
05:50:28 <eivuokko> If you use --html-location, the dir must ocntain the files to base etc libs!
05:50:33 * dcoutts suspects he is confused
05:50:50 <eivuokko> I am thinking I make a web server that serves this stuff correctly for Windows-clients.
05:50:51 <dcoutts> eivuokko: hmm, that's not too helpful is it
05:51:00 <eivuokko> And then I can install files where-ever.
05:51:21 <eivuokko> dcoutts, --html-location is almost certainly added for ghc-only.
05:51:28 <dcoutts> aye
05:51:55 <MyCatVerbs> So, tries are O(reallyreallyfast), provided you have shitloads of spare RAM to store them in?
05:52:10 <dcoutts> eivuokko: so why can't you just install the prerqeuisite packages and then generating the links will work
05:52:20 <eivuokko> dcoutts, Because that requires admin rights...
05:52:37 <eivuokko> dcoutts, Gonna convert hackage to msis with a script that runs as admin?
05:52:49 <dcoutts> hmm
05:53:17 <dcoutts> eivuokko: or we could register them inplace but with the html location set for the final location
05:53:56 <eivuokko> dcoutts, Miht work, but sounds really fragile, as we must still give right interface file
05:54:32 <dcoutts> eivuokko: aye, it's a bit dodgey as we need to find the inplace .haddock file but the final html dir
05:55:37 <eivuokko> dcoutts, haddock and Cabal also need a patch to generate relative links instead of hardcoding c:\Program Files\ into docs.
05:55:49 <dcoutts> eivuokko: we'll have to think about that, as you point out, we need it for hackage too so it can generate cross links
05:56:48 <eivuokko> dcoutts, This is one of those devils in details -.-
05:57:26 <hpaste>  gralenarc pasted "ball" at http://hpaste.org/2153
05:57:34 <dcoutts> eivuokko: yes, that's tricky since we don't always know how packages are installed relative to each other
05:58:12 <dcoutts> eivuokko: I'll try and bring this up with people at AH tomorrow see if there are any clever idea
05:58:18 <astrolabe> dcoutts: Do you know if anyone is meeting up today re anglohaskell?
05:58:31 <eivuokko> dcoutts, Too bad I can't be there -.-
05:58:39 <dcoutts> astrolabe: ndm is arriving here at 5pm, xerox at 1am :-)
05:58:53 <astrolabe> cool :)
05:58:53 <dcoutts> eivuokko: aye :-( , or post the problem to the cabal-devel list
05:59:08 <eivuokko> dcoutts, I try not to generate so much traffic...
05:59:16 <dcoutts> eivuokko: hah
05:59:27 <byorgey> @pl \f g x y -> f (g x) (g y)
05:59:27 <lambdabot> join . ((flip . ((.) .)) .) . (.)
05:59:39 <dcoutts> eivuokko: it's good to have these issues recorded anyway so we can refer back to them rather than rediscovering
06:00:13 <eivuokko> dcoutts, Yeah.
06:00:28 <dcoutts> eivuokko: one option might be to use html entity references to embed the links to other packages, that might make substituting easier
06:00:44 <eivuokko> dcoutts, What is that
06:00:58 <dcoutts> eivuokko: &pkgfoo;
06:01:01 <eivuokko> dcoutts, That sounds exactly what we want, if we can change the links at install-time.
06:01:02 <mathias_> Can I ask an IntMap to give a key that's not being used yet?
06:01:16 <eivuokko> dcoutts, Ah, does it work reliably on modern browsers?
06:01:24 <dcoutts> eivuokko: not 100% sure
06:01:34 <mathias_> Or just insert an element somewhere and get the key where it was placed?
06:01:56 <dcoutts> eivuokko: we'd have to check the xhtml spec and try it
06:02:18 <eivuokko> dcoutts, Anyway, relinking docs with regexp is one choice.
06:02:29 <mauke> mathias_: head (keys m) - 1
06:02:34 <dcoutts> eivuokko: yes
06:02:56 <eivuokko> dcoutts, is haddock output xhtml compliant?
06:03:03 <eivuokko> strict whatever it was
06:03:17 <dcoutts> eivuokko: erm, I think at the moment it's an older html standard
06:03:20 <dcoutts> sadly
06:03:29 <mathias_> mauke, that's incorrect.
06:03:40 <mauke> :(
06:04:04 <mathias_> mauke, consider the case 1,2,4 for a two bits IntMap
06:04:17 <mathias_> mauke, 0 is returned
06:04:24 <mathias_> mauke, assuming 0 is invalid
06:04:37 <mauke> how is 0 invalid?
06:04:54 <mathias_> mauke, when 0 is valid, consider 0,1,3
06:05:06 <mathias_> mauke, 0 - 1 = 3
06:05:23 <mathias_> mauke, while 2 was the only index that wasn't used yet.
06:05:37 <mauke> bits?!
06:05:50 <eivuokko> dcoutts, Ok, can't be helped (or rather out-of-scope problem).  Thanks for discussion.  I'm gonna forget docs for a bit and continue with something else.
06:06:03 <mauke> mathias_: 0 - 1 == -1
06:06:07 <dcoutts> eivuokko: probably wise :-)
06:06:11 <eivuokko> dcoutts, But it'd be *really* good to make docs work right for ghc-6.8
06:06:12 <mauke> and the index -1 is unused
06:06:16 <dcoutts> eivuokko: yes
06:06:37 <dcoutts> eivuokko: I do suggest raising the problem on cabal-devel
06:07:18 <eivuokko> I should make global keyboard shortcut to compose a mail.
06:07:47 <mathias_> mauke, ok, your approach scales to about 2 billion elements assuming other keys entered are only positive.
06:07:58 <mathias_> mauke, that's good enough.
06:08:33 <mathias_> mauke, is that operation O(size of output)?
06:08:56 <mauke> I don't know
06:10:45 <quicksilver> I think in Bulat-speak "real world application" is a code for "Bulat's requirements and no one else's"
06:11:48 <quicksilver> "Slow IO or bad code" <- if ever there was a subject line designed to get dons to read and reply that was it :)
06:11:54 <mux> heh
06:12:49 <shapr> dons: There's this guy with a beard named "Bruce Stewart" on the Beautiful Code website who mentioned SPJ's STM talks. I was very confused for a few seconds.
06:13:10 <dons> heh
06:13:25 <quicksilver> that's dons' evil son
06:13:39 <shapr> dons: http://beautifulcode.oreillynet.com/2007/08/oscon_video_of_simon_peyton_jo.php
06:13:41 <lambdabot> Title: OSCON Video of Simon Peyton Jones' Haskell Tutorial - Beautiful Code, http://tinyurl.com/324c7a
06:13:47 <quicksilver> have to beware of dons' evil evil grandson, simply known as "Stewart"
06:14:12 <shapr> Good morning #haskell!
06:14:22 <ivant> is (evil . evil) = id?
06:14:37 <arcatan> hi, shaprshapr
06:14:42 <dons> hey, he's got a good unixy beard
06:14:50 <dons> i feel so inadequate
06:14:56 <ivant> Good morning, shachaf
06:14:59 <ivant> oops, shapr
06:15:01 <ivant> :-)
06:15:26 <shapr> hyvaa huomenta arcatan!
06:15:27 <dons> shapr: my true dopplegangerr (same name and middle name) is this guy, http://www.dsart.com/
06:15:28 <lambdabot> Title: Don Stewart's composite images
06:15:42 <dons> he does weird drawings of hamburgers that eat people and so forth
06:15:47 <shapr> Privet ivant!
06:17:00 <shapr> If (read . show ) is id, what's ego and superego?
06:19:12 <dons> i wonder if cale's comment will get 100 points...
06:19:13 <MyCatVerbs> read $ '[' : (map (\x y-> show a ++ (',' : b))) ++ [']']
06:19:23 <MyCatVerbs> Perhaps?
06:20:51 <shapr> Which comment?
06:21:50 <MyCatVerbs> You're right, that abomination ought to be commented out.
06:24:57 <dons> shapr: oh, his reddit comment about data -as - control
06:25:11 <dons> this one, its a gem, http://programming.reddit.com/info/2bxc1/comments/c2dins
06:25:12 <lambdabot> Title: Ask Reddit: What is Haskell good for? (reddit.com)
06:26:34 * shapr contributes his point
06:26:56 <shapr> I've often thought Haskell programs are more about tiny bits of worker code traversing huge chunks of data.
06:27:53 <quicksilver> shapr: like bees collecting nectar to make honey?
06:28:03 <shapr> Hm, yeah
06:28:48 <dons> mm lots of tiny worker functions, matching and replacing data left and right.
06:30:02 <dons> i quite like Cale's `mystical' view of constructors getting replaced with functions, yielding ready-made control flow
06:35:25 <roconnor> dons: isn't primitive recursion the only thing you can do with inductive data types.
06:35:35 <geezusfreeek> then again, it works the other way too... i've always though of lazy function application as data structures that haven't yet been collapsed into a form useable by IO
06:35:36 <roconnor> ... well I suppose fix throws a wrinkle into things.
06:36:34 <shapr> geezusfreeek: Yeah, isn't it great that you can look at it whichever way is easiest at the moment?
06:37:40 <shapr> @seen delYsid
06:37:40 <lambdabot> I haven't seen delYsid.
06:38:23 <shapr> @seen Marvin--
06:38:23 <lambdabot> I haven't seen Marvin--.
06:38:28 <roconnor> It takes me 37 seconds to calculate 200 digits of Pi inside Coq.
06:38:34 <roconnor> I wonder if that is too slow.
06:39:05 <SamB> dons: well, I'm certainly getting plenty of suggestions for the library ;-)
06:39:12 <geezusfreeek> MyCatVerbs, that line of code is amazing
06:39:15 <dons> roconnor: sjw used to run a ghc Core impl. inside Twelf. he said it was a little slower than normal
06:39:22 <dons> SamB: you got a couple of replies?
06:39:40 <roconnor> dons: ghc Core uses gmp doesn't it?
06:39:45 <SamB> three so far
06:40:23 <SamB> at least one was just to me, because for some reason the author didn't think libraries@ would accept mail from the address he had to send it from...
06:41:17 <dons> roconnor: yeah, just a System F impl in twelf, with enough of Core to look like it
06:42:35 <roconnor> dons: it probably would be slow at computing pi too, if it doesn't have access to GMP :)
06:43:03 <MyCatVerbs> geezusfreeek: I daren't try it in GHCi. >>
06:44:12 <earthy> yaay. the typechecker believes my code. :)
06:46:10 <MyCatVerbs> geezusfreeek: because it's massively wrong.
06:46:16 <dons> earthy: hope its not lying.
06:46:29 <mux> does someone have that URL of a humorous graphic about Perl6 timeline?
06:46:57 <opqdonut> sounds good :))
06:47:50 <shapr> Oh hey! I borrowed back my old Lego RCX that I gave to my uncle some ten years ago. I can barely wait to try some of sigfpe's "script your Lego robot from Haskell" stuff.
06:48:11 <SamB> another seems to have been just to me as well...
06:48:13 <mux> found it: http://utsl.gen.nz/talks/perl6.does-ML/images/timeline.png
06:48:31 <SamB> but it was only a short suggestion that I try INLINE pragmas
06:48:43 <SamB> shapr: sigfpe meant RCX, not NXT?
06:48:53 <shapr> Er, did he say NXT?
06:48:56 <SamB> dunno
06:49:02 <quicksilver> mux: that's based on SPJ's haskell timeline, isn't it?
06:49:04 <MyCatVerbs> let f x = read $ '[' : (show $ head x) ++ (foldr (\x y->',':(show x) ++ y) "]" (tail x) in f [1..10::Int] :: [Float]
06:49:08 <MyCatVerbs> > let f x = read $ '[' : (show $ head x) ++ (foldr (\x y->',':(show x) ++ y) "]" (tail x) in f [1..10::Int] :: [Float]
06:49:08 <lambdabot>  Parse error
06:49:10 <mux> quicksilver: yes I think so
06:49:10 <SamB> shapr: haven't read the article
06:49:12 <MyCatVerbs> Feckasse.
06:49:28 <shapr> I only have an RCX, so I hope it doesn't require an NXT.
06:49:53 <MyCatVerbs> > let f x = read $ '[' : (show $ head x) ++ (foldr (\x y-> ',' : (show x) ++ (y))) "]" (tail x) in f [1..10::Int] :: [Float]
06:49:55 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
06:50:01 <MyCatVerbs> More like it.
06:50:20 <MyCatVerbs> [Int] to [Float] without using fromIntegral. ;)
06:50:52 <opqdonut> > let const = uncurry fst; id = fix const in id 1 -- bored, bored, bored
06:50:53 <lambdabot>      Occurs check: cannot construct the infinite type:
06:50:53 <lambdabot>       c = ((b -> c, b1...
06:51:41 <opqdonut> > let const = uncurry fst; id = fix . const in id 1 -- bored, bored, bored
06:51:42 <lambdabot>        add an instance declaration for (Num ((b -> a -> a, b1), b))
06:51:42 <MyCatVerbs> fix . const?
06:51:46 <opqdonut> yeah, that
06:51:51 <shapr> opqdonut: If you're bored, play with arrows!
06:52:19 <MyCatVerbs> I love how bored Haskell users immediately start writing ever more elaborate identity functions...
06:52:39 <opqdonut> > let const = curry fst; id = fix . const in id 1 -- bored, bored, bored
06:52:40 <lambdabot>  1
06:52:49 <opqdonut> there, was a bit befuddled
06:55:19 <psykotic> > let foldr' f z xs = foldl (\f' x z' -> f' (f x z')) id xs z in foldr' (:) [] [1..10]
06:55:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:56:19 <opqdonut> > let foldr' f z xs = foldl (\f' x z' -> f' (f x z')) id xs z in take 10 $ foldr' (:) [] [1..]
06:56:24 <lambdabot> Terminated
06:56:27 <opqdonut> ah, yes, the '
06:58:21 <shapr> SamB: Ah, it was Matthew Naylor who wrote it in TMR 7
06:59:09 <MyCatVerbs> Pet peeve: people calling variables foo and foo', then foo'' and foo ++ (repeat n '\'')
06:59:18 <shapr> heh
06:59:26 <MyCatVerbs> For fuck's sake, I can't read that. Get a clue. Fucking mathematicians.
06:59:57 <MyCatVerbs> If it's a derivative, call it deefoo or deltafoo or something. Jesus.
07:02:02 <integral> but they didn't use single letter variable names!
07:02:05 <flux> I wonder why ml/haskell don't allow variable names like foo"
07:02:11 <flux> it'd be twice as good as foo'!
07:02:28 <flux> and more concise than foo''
07:02:36 <MyCatVerbs> flux: the moment you implement that with a reader macro, I will have your skull for a cocoa mug.
07:02:38 <geezusfreeek> and pointless :P
07:02:53 <flux> mycatverbs, mmm.. cocoa..
07:02:53 <samreid> but then you'd have to decide whether you liked foo'" or foo"'
07:02:57 <quicksilver> I don't really know what's wrong with foo'
07:03:00 <flux> samreid, true
07:03:09 <quicksilver> it's just a notation for "like foo but slightly different"
07:03:10 <flux> personally, I also use var'iables
07:03:18 <quicksilver> it can often be easier than thinking up a new name
07:03:23 <opqdonut> samreid: nah, they'd be identical on the lexer level ;)
07:03:32 <opqdonut> implementation detail
07:03:42 <flux> opqdonut, good idea ;)
07:03:45 <MyCatVerbs> quicksilver: YES IT IS VERY VERY BAD AND I WANT TO KILL YOU FOR IT
07:03:52 <opqdonut> :D
07:03:55 <flux> opqdonut, think of the holy wars that would commence
07:03:59 <opqdonut> hehe
07:04:51 <MyCatVerbs> quicksilver: because it makes the code fucking impossible to read. It's physically difficult to tell the difference at a glance between foo and foo'. For fuck's sake, just stick a natural language prefix on it like dee or delta or epsilon or something. Punctuation differences aren't easy to spot.
07:04:52 <psykotic> MyCatVerbs, it's time to take your meds.
07:05:05 <MyCatVerbs> psykotic: that's why it's called a "pet peeve" ;)
07:05:24 <opqdonut> symbol := MATHSYMBOL POSTFIX*
07:05:37 <opqdonut> where MATHSYMBOL is a latin or hebrew or greek letter
07:06:09 <opqdonut> and postfix is ' or _{symbol}
07:06:11 <opqdonut> :P
07:06:36 <MyCatVerbs> ' as a postfix is unfriendly to my eyes. Please never use it.
07:06:43 <ivant> haha, I'm using greek variable names in my code :-)
07:07:08 <MyCatVerbs> s/([a-zA-Z])'/dee$1/g
07:07:19 <MyCatVerbs> Or was it \1? Depending on flavour.
07:07:50 <opqdonut> $1 only in perl
07:07:52 <mux> $1 is perl, \1 is sed
07:07:54 <opqdonut> \1 everywhere else
07:07:56 <mux> or vim
07:08:01 <MyCatVerbs> Thanks.
07:08:23 * shapr laughs at qwe1234 saying that he knows more about FP than augustss
07:08:37 <mux> btw, [[:alpha:]] would be nice for such a thing
07:08:49 <psykotic> shapr, maybe he does!
07:08:56 <psykotic> shapr, maybe qwe is phil wadler.
07:08:56 <opqdonut> and that'd do foo' -> fo'o
07:08:56 <opqdonut> no, foo' -> fodeeo
07:08:56 <opqdonut> anyways :)
07:09:02 <Gwern-away> I'm kind of curious - running strip on the binaries ghc produces seems to roughly halve their size. what exactly are the 'symbols' used for?
07:09:20 <opqdonut> debugging
07:09:21 <shapr> psykotic: I dunno, I still wouldn't bet on Phil Wadler if it came down to a contest writing Cayenne code.
07:09:21 <opqdonut> profiling
07:09:24 <opqdonut> that kinda stuff
07:09:40 <opqdonut> Cayenne?
07:09:42 <ivant> oh, by the way, I know that it's possible to use symbol λ in code instead of \. But how does the parser distinguish it from the functions with the names starting with λ?
07:09:45 <psykotic> shapr: that's kinda an unfair home advantage though, being his language. :)
07:09:59 <psykotic> ivant, really, that works?
07:10:13 * shapr grins
07:10:13 <psykotic> i didn't know ghc did unicode like that
07:10:39 <ivant> psykotic, I've seen a message in ghc mailing list (or somewhere), with the patch to the lexer which implements exactly this
07:10:44 <Gwern-away> neither did I. I just had a fontlock thing hacked up in emacs to do that. didn't know it could be native
07:11:02 <ivant> psykotic, ghc considers that your sources are in utf8 since 6.6
07:11:06 <psykotic> ivant, when you said you used greek letters, i assume you mean writing 'alpha', not actually using unicode greek letters?
07:11:12 <psykotic> ah
07:11:26 <ivant> snippet of actual code: ineqsLHS = [2 + β * (μ + 1) - 2 * (μ + 1)] ++ (map (getIneq goodPowers) badPowers)
07:11:35 <psykotic> nice
07:11:53 <opqdonut> i think the argument against that is that greek people might want to have one-letter greek variables
07:11:57 <opqdonut> including lambda :)
07:11:58 <Gwern-away> ivant: are the betas defined elsewhere or do they have a special meaning because they're greek?
07:12:06 <psykotic> lambda is also a common single-letter variable in math
07:12:12 <shapr> qwe1234 says to augustss: "believe me, i've lots and lots of experience interviewing cocky but poorly prepared and ignorant d00ds. i can read you like a book."
07:12:12 <opqdonut> mhmm
07:12:15 * shapr falls over laughing
07:12:22 <ivant> Gwern-away, they are defined in the scope, yes
07:12:36 <opqdonut> mmmmh, scope
07:12:58 <psykotic> ivant: do you know if ghc deals correctly with unicode operator characters for infix ops, ala perl 6?
07:13:06 <shapr> As they say in the south, "qwe1234 done brung a knife to a gunfight!"
07:13:23 <psykotic> shut up, shapr, i can read you like a book.
07:13:37 * shapr laughs more
07:13:42 <ivant> opqdonut, I'm writing some maths code for a real problem I have, and mathematicians often use greek characters, so I decided that it'd be easier for me to understand what's going on if my source definitions actually matched my problem definitions
07:13:57 <ivant> psykotic, I don't, but I can try
07:14:03 <opqdonut> yeah i meant against lambda as lambda
07:14:06 <shapr> psykotic: You probably can, I don't claim the cluefulness of augustss :-)
07:14:08 <opqdonut> err, lambda as \
07:14:10 <ivant> psykotic, what do you mean by correctly?
07:14:28 <psykotic> ivant: well, ghc's lexer has a rule for how to identify operator-like sequences.
07:14:29 <dons> this is nice, http://article.gmane.org/gmane.comp.lang.haskell.cafe/27253
07:14:31 <lambdabot> Title: Gmane -- Mail To News And Back Again
07:14:40 <psykotic> like, something that uses #!@&, etc
07:14:44 <dons> from the scala-liftweb-now-haskell guy
07:15:00 <dons> also here, http://programming.reddit.com/info/2dpjn/comments
07:15:01 <lambdabot> Title: Functional programming "is the single best and single most important technology  ...
07:15:03 <ivant> psykotic, oh, now I remember, I tried to define operator ⊕, but ghc didn't like that
07:15:07 <ivant> bummer
07:16:24 <psykotic> it should be possible for the lexer to do the Right Thing. hmm
07:16:59 <hpaste>  anybody pasted "unmached patterns..." at http://hpaste.org/2155
07:17:06 <dons> ivant: hmm. unicode should be ok in ghc 6.6.1 ?
07:17:08 <psykotic> http://en.wikipedia.org/wiki/Unicode_Mathematical_Operators
07:17:09 <lambdabot> Title: Unicode Mathematical Operators - Wikipedia, the free encyclopedia
07:17:10 <dons> and 6.6 actually
07:17:16 <desp> ?where 10 minute
07:17:17 <lambdabot> I know nothing about 10.
07:17:17 <psykotic> basically they occur in ceratin contiguous ranges.
07:17:22 <dons> there's even lambda and forall as keywords
07:17:29 <desp> ?where tutorial
07:17:29 <lambdabot> http://www.haskell.org/tutorial/
07:17:31 <psykotic> dons: but it doesn't appear to treat math operators as infix lexemes
07:17:39 <psykotic> (which does not require a little bit of special handling, but not much)
07:17:40 <dons> oh hmm.
07:17:44 <ivant> dons, it is ok for the variable names, but not for infix operators I think
07:17:49 <dons> right, they're in the wrong class i guess
07:17:52 <psykotic> basically you just need to do a couple of range checks on the ord
07:17:56 <dons> wrt. the report
07:17:59 <psykotic> it would be pretty cool to have this
07:18:01 <desp> ?where introduction
07:18:01 <lambdabot> I know nothing about introduction.
07:18:07 <dons> yeah, should be a trivial patch
07:18:13 <ivant> dons, should I submit a bug report?
07:18:16 <dons> and the code was touched recently for \lambda \forall et al
07:18:20 <anybody> why do i get so many matching warnings with this code?  http://hpaste.org/2155
07:18:22 <dons> ivant: i reckon so. or a feature request
07:18:23 <ivant> or even try to hack ghc myself?
07:18:32 <dons> yeah, you might even be able to just patch the lexer
07:18:38 <dons> Lexer.x syntax is pretty simple
07:18:43 <HairyDude> how do you tell ghci not to print the results of IO actions?
07:19:04 <dons> print >> return () -- ?
07:19:06 <desp> ?where wikibook
07:19:07 <lambdabot> http://en.wikibooks.org/wiki/Haskell
07:19:09 <psykotic> there's a :set flag, i think
07:19:15 <ivant> dons, is there a "gentle introduction to ghc development" somewhere?
07:19:17 <dons> yeah, -v0 ?
07:19:20 <psykotic> for not auto-executing IO actions
07:19:24 <desp> ?where+ 10minutes http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
07:19:24 <lambdabot> Done.
07:19:28 <dons> ivant, yep, on the haskell.org/ghc page somewhere
07:19:33 <ivant> dons, thanks
07:19:35 <desp> ?where+ intro http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
07:19:35 <lambdabot> Done.
07:21:02 <HairyDude> I want do do foo <- hGetContents bigFile but not print foo
07:22:25 <Saizan> -fno-print-bind-result
07:22:30 <HairyDude> ah, thanks
07:22:49 <roconnor> -fno-print-bind-result should be in the topic :)
07:22:56 <Saizan> yeah
07:22:57 <psykotic> dons: it's too bad we don't have "bracket operator" support :)
07:23:05 <psykotic> otherwise, with unicode, we could use Teh Realz Banana Brackets
07:23:10 <dons> mmm
07:23:12 <dons> that would rock
07:23:22 <ricky_clarkson> (| |) these?
07:23:24 <Saizan> roconnor: in the :help at least
07:23:31 <dons> none of this wussy isabelle/proof general markup fakeout stuff
07:23:45 <dons> native squiggol for all!
07:23:57 <roconnor> HairyDude: I have :set -fno-print-bind-result in my .ghci file
07:24:24 * ivant considers looking at the Fortress. They say the use all the kinds of weird characters there
07:25:35 <dons> i thought the theorem provers owned the funny character space?
07:25:52 <dons> at least, the Isabelle guys love funky chrs
07:26:00 <ivant> oh, by the way, you can completely confuse the developer by using unicode characters which look similar but are in fact different
07:26:19 <shapr> mmm, Yampa for Virtual Reality - http://imve.informatik.uni-hamburg.de/projects/Techniques/VisualAFRP/
07:26:21 <dons> upside down keywords might be fun
07:26:22 <lambdabot> Title: interactive media / virtual environments - Informatik, University of Hamburg - c ..., http://tinyurl.com/363eln
07:26:25 <ivant> dons, I think mathematicians in generall love funky chars
07:26:30 <dons> ooh, shapr
07:26:37 <quicksilver> using the graphical unicode symbols, you can write programs which are also pictures
07:26:43 <SamB> I think I'd not want unicode-based representations really...
07:26:43 <ivant> :-)
07:27:10 <SamB> unicode seems to be ugliness-friendly
07:27:45 <psykotic> dons: that post by the liftweb guy is nice.
07:27:59 <psykotic> dons: and bulat's reply to the same thread is crass and rude. :)
07:28:07 <dons> yeah, bulat is weird
07:28:11 <dons> i wrote him privately about that
07:29:04 <dons> he wrote one buggy low level io lib once, and likes to complain about not having C syntax for it. no one uses this code too, which is hmm. something.
07:29:53 <quicksilver> does seth gordon have an IRC nick?
07:30:34 <shapr> sethg?
07:30:34 <hpaste>  paolino pasted "problem 51" at http://hpaste.org/2156
07:30:41 <mnislaih> roconnor: there ? I just read your blog on the MTL slowness. Are you sure that if mtl  is compiled with o2 then the slowdown is gone ?
07:30:44 <shapr> Hasn't he been here before?
07:30:52 <psykotic> dons: btw, what is this "new syntax" david is talking about?
07:30:52 <psykotic> http://article.gmane.org/gmane.comp.lang.haskell.cafe/27226
07:30:53 <lambdabot> Title: Gmane -- Mail To News And Back Again
07:31:03 <quicksilver> shapr: that'll do at least
07:31:08 <psykotic> dons: low level io? is that his streams thing?
07:31:23 <quicksilver> @remember sethg I feel like I still don't understand comonads.  Maybe I just need a Zen comaster to hit me with a costick and then I'll become coenlightened.
07:31:23 <lambdabot> Done.
07:31:26 <psykotic> i looked at that and i felt like i had teleported into the java world
07:31:39 <dons> psykotic: the test (<- io) style spj was pondering
07:31:51 <dons> rather than ; x <- io ; when test x $ ...
07:32:00 <psykotic> dons: so how would it figure out the sequencing? using cbv style ordering?
07:32:10 <psykotic> or wouldn't it allow multiple (<- io) things in one expression?
07:32:13 <dons> i've not been following, since i don't like the idea :)
07:32:31 <kjdf> hm
07:32:32 <dons> there's a giant thread about it, from earlier this week, starting with SPJ
07:32:38 <psykotic> yeah, it seems nasty at a first glance at least
07:32:40 <psykotic> k
07:32:57 <kjdf> is it possible to write parallel array literals with more than one element?
07:32:57 <tibbe> roconnor: blog entry on mtl? where?
07:33:02 <njd> can anyone help be with a Data.Binary problem?
07:33:15 <dons> njd, maybe, if you're quick!
07:33:16 <dons> ?time
07:33:20 <lambdabot> Local time for dons is Fri Aug 10 00:32:45 2007
07:33:22 <mnislaih> tibbe: it is up in Planet Haskell too
07:33:31 <mnislaih> or http://r6.ca/blog/20070804185154Z.html
07:33:32 <SamB> kjdf: um, why not?
07:33:32 <lambdabot> Title: ICFP 2007 Post-Mortem
07:33:38 <kjdf> [: 1 :] works, [: 1, 2 :] prints out parse error on input `,'
07:33:47 <SamB> kjdf: hmm
07:33:57 <tibbe> mnislaih: thanks
07:33:58 <dons> kjdf: you mean to use pairs there?
07:34:05 <dons> oh, literals hmm
07:34:08 <dons> not comprehensions
07:34:16 <dons> isn't that comprehension syntax?
07:34:21 <dons> not literal parallel arrays :)
07:34:22 <njd> ok - why won't it link - I get unkown symbol `stg_uncheckedShiftRL64`
07:34:28 <dons> urgh.
07:34:31 <kjdf> using ghci 6.6, maybe that's the problem
07:34:37 <njd> when I run it in ghci - using a 6.7
07:34:49 <mathias_> Do all the array types in base support negative indices?
07:34:50 <kjdf> well, on NDP slides qsort example SPJ uses it
07:34:54 <njd> ghc - against which I just complied Data.Binary
07:34:55 <dons> njd, they hid the import on us, in the head, i think that's fixed in the darcs repo of Data.Binary
07:34:57 <SamB> kjdf: it should work
07:34:58 <geezusfreeek> when using -threaded in GHC, does it only use OS threads to avoid blocking on foreign calls or will it actually run multiple computations at once on multi-cpu machines?
07:35:01 <quicksilver> psykotic: sequencing would be left-to-right
07:35:08 <quicksilver> psykotic: innermost first
07:35:13 <quicksilver> psykotic: so, yes, like cbv
07:35:14 <psykotic> that's what i meant by cbv
07:35:14 <njd> ok - I'll put it down and try it
07:35:14 <SamB> kjdf: but then again 6.6 doesn't properly support ndp
07:35:26 <SamB> even 6.7 doesn't
07:35:28 <quicksilver> psykotic: but the intended use case is more when order doesn't matter
07:35:32 <kjdf> even the syntactic sugar?
07:35:48 <SamB> the sugar ought to work
07:36:05 <dons> maybe that sugar was only added in the head -- i didn't know about _literals_
07:36:12 <SamB> but, hey, when nobody uses it, it's easy to bitrot
07:36:17 <eivuokko> mathias, they all use Ix, no?
07:36:27 <SamB> dons: hasn't GHC had PArray syntax for ages?
07:36:32 <dons> yeah
07:36:36 <njd> dons, I've got the latest Data.Binary - did you mean latest GHC?
07:36:38 <dons> njd: http://hackage.haskell.org/trac/ghc/ticket/1282
07:36:39 <lambdabot> Title: #1282 (binary package wants uncheckedShift functions to be exported from base) - ...
07:36:44 <dons> ndjd, the binary from darcs ?
07:37:16 <njd> dons, no the source - just did a pull - no changes
07:37:32 <dons> ok, so we haven't patched this then? it still fails to link?
07:37:51 <dons> njd, you could down grade to ghc 6.6.1
07:37:55 <njd> using it in ghci at moment
07:38:09 <njd> dons, mmm - need 6.7 for other things
07:38:12 <dons> or replace the stg_ imports with hs_ imports (the bug tracker says that's the api change that occured)
07:38:21 <hpaste>  kjdf pasted "ndp sugar breakage?" at http://hpaste.org/2157
07:38:27 <dons> ok, i'd dive into the Data.Binary source then, grep for stg_* imports
07:38:32 <dons> and replace them with hs_*
07:38:37 <njd> dons, will do
07:38:49 <dons> then send me a patch :)
07:39:02 <dons> and we need to sort out with Mr. GHC HQ what the official story is for these unchecked shifts
07:39:22 <dons> interesting: using both Data.Binary and you need ghc head branch. sound like a fun project...
07:39:33 <SamB> does anyone have a copy of GHC 6.4 lying about?
07:39:46 <dons> SamB: for a quick fragment, yes.
07:39:56 <SamB> dons: try what kjdf pasted
07:40:30 <SamB> kjdf: it seems to work in 6.6.1
07:40:33 <njd> dons: think scalable, telcoms, safety-critical.... yep fun - in the 'can I trust ghc to support me in this' stage
07:40:35 <kjdf> ok.
07:40:47 <kjdf> then it is me and my ancient 6.6 ;)
07:41:24 <SamB> kjdf: I don't think "ancient" is the word, exactly
07:41:32 <geezusfreeek> when using -threaded in GHC, does it only use OS threads to avoid blocking on foreign calls or will it actually run multiple computations at once on multi-cpu machines? the documentation for Control.Concurrent seems to be saying the former, but it doesn't really seem to confirm or deny the latter
07:41:33 <dons> works.
07:41:42 <SamB> dons: which revision is it?
07:41:53 <dons> 6.4.1
07:41:55 <SamB> kjdf: it also works in 6.4.1
07:42:14 <SamB> I think the word is "oops"
07:42:38 <dons> njd, wow. ok. i guess it works for Aetion or Galois. I hope Data.Binary behaves nicely -- I wanted to build it to be suitable for networky/telecoms stuff
07:42:39 <SamB> (that's the word said by the relevant GHC hackers when they found out it was broken)
07:43:03 <njd> dons, let you know if it doesn't...
07:43:11 <dons> geezusfreeek: it uses multiple cores, in multiple threads
07:43:19 <geezusfreeek> woowoo!
07:43:26 <SamB> kjdf: so don't feel bad, you are just a victim of "research bitrot"
07:43:33 <dons> you need to specify the number of cores as a command line flag, geezusfreeek
07:43:38 <dons> +RTS -N16
07:43:39 <dons> for example
07:43:46 <geezusfreeek> oh okay, thanks
07:44:03 <njd> dons, thanks - that fixed the linking problem - I'll email you the patch shortly
07:44:14 <SamB> kjdf: ndp is nearing it's second (first?) life, however, so it is unlikely to recur
07:44:16 <dons> geezusfreeek: http://www.haskell.org/ghc/dist/current/docs/users_guide/sec-using-smp.html
07:44:18 <lambdabot> Title: 4.12. Using SMP parallelism, http://tinyurl.com/32ebau
07:44:28 <dons> njd, great.
07:44:37 <dons> njd, might be worth rerunning the Data.Binary testsuite (just in case)
07:44:42 <kjdf> ok, back to watching the vid..
07:44:54 <geezusfreeek> thanks dons
07:45:10 <dons> SamB: so there's a bug ticket about array literals?
07:45:14 <dons> or is it fixed in the head branch?
07:45:16 <geezusfreeek> i <3 the haskell community... the most helpful bunch around any technology on the internet
07:45:23 <SamB> dons: it's fixed in 6.6.1
07:45:27 <dons> ah ok. good
07:45:29 <dons> geezusfreeek: :)
07:45:47 <dons> bed time. night all
07:45:53 <geezusfreeek> nite
07:46:02 <SamB> I tried it on Lemmih's catenova.org
07:46:06 <earthy> sleep well, dons
07:47:03 <SamB> (which he gave me an SSH account on when I was trying to improve GHC's optimization of bitshifts, probably because the machine is ridiculously overpowered for a webserver ;-)
07:47:16 <SamB> (also because I had a 450 MHz PII at the time)
07:48:01 <njd> dons, patch send
07:50:06 <Gwern-away> > let prod = sum . zipWith (*)
07:50:07 <lambdabot>  Parse error
07:50:18 <Gwern-away> > let prod = (sum .) . zipWith (*)
07:50:18 <lambdabot>  Parse error
07:50:23 <opqdonut> you need in
07:50:37 <opqdonut> > let prod = sum . zipWith (*) in prod [1,2,3] [4,5,6]
07:50:38 <lambdabot>  Couldn't match expected type `[a]'
07:50:55 <opqdonut> errr?
07:51:10 <drigz> opqdonut: it's the second one Gwern tried
07:51:13 <Gwern-away> opqdonut: strange thing is, everyone is suggesting the sum . zipWith thing on the ML, but I can only get 'prod = (sum .) . zipWith (*)' to compile
07:51:35 <drigz> it's because zipWith (*) takes two arguments
07:51:41 <opqdonut> ah, yes
07:51:43 <opqdonut> true, that
07:52:04 <drigz> so if you just pass it one, it returns ([a] -> [(a, a)]), which gets passed into sum
07:52:10 <opqdonut> yeah
07:52:24 <drigz> just people on the ML don't test things before they say them .
07:52:42 <drigz> and point-free style is a minefield
07:53:14 <Gwern-away> drigz: actually, I originally wrote prod n m = sum . zipWith (*) n m, and then asked @pl what the pointfree version was
07:53:34 <opqdonut> shouldn't that be sum $
07:53:36 <opqdonut> not sum .
07:53:50 <opqdonut> ?pl prod n m = sum $ zipWith (*) n m
07:53:50 <lambdabot> prod = (sum .) . zipWith (*)
07:53:53 <opqdonut> :)
07:54:47 <drigz> i hate the project euler problems which don't become easy as soon as you know some algorithms
07:54:48 <Ben`> what does !! mean?
07:54:56 <drigz> Ben`: index into a list
07:55:02 <opqdonut> > [1,2,3] !! 0
07:55:04 <lambdabot>  1
07:55:04 <opqdonut> > [1,2,3] !! 1
07:55:05 <drigz> so (!! 3) is the 4th element
07:55:06 <lambdabot>  2
07:55:10 <Gwern-away> Ben`: it
07:55:17 <Gwern-away> s the Int version of genericIndex
07:55:39 <Ben`> hmm, it's not a list
07:55:45 <Ben`> let knuth x y = iterate (x^) 1 !! y
07:56:19 <drigz> Ben`: iterate returns a list of progressive iterations
07:56:28 <drigz> > take 10 (iterate (*2) 1)
07:56:29 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
07:56:32 <Ben`> oh
07:56:45 <Ben`> ok, I get it
07:56:46 <Ben`> thanks
07:56:51 <roconnor> Oh, I see Cale got his 100 points
07:58:02 <Gwern-away> roconnor: context pls
07:58:35 <roconnor> Gwern-away: http://programming.reddit.com/info/2dl36/comments
07:58:36 <lambdabot> Title: programming.reddit.com: the last outpost of classic reddit discourse (reddit.com ...
07:59:13 <opqdonut> > take 10 $ iterate (x^) 1
07:59:14 <lambdabot>   Not in scope: `x'
07:59:17 <opqdonut> > take 10 $ iterate (2^) 1
07:59:19 <lambdabot>  [1,2,4,16,65536,200352993040684646497907235156025575044782547556975141926501...
07:59:19 <opqdonut> :)
07:59:23 <opqdonut> hihi
08:01:56 <anybody> hey is there some AI component inside ghc that adapts to the users style of coding? it seems to me that a piece of code i wrote that didn't work initially suddenly started to function without me changing it ;-)
08:02:16 <SamB> anybody: no...
08:02:25 <SamB> was it a type error?
08:02:35 <roconnor> maybe your editor normalized your tabs into spaces.
08:02:59 <anybody> oh com. but there must be some intelligence behind it. som greater invisible entity inside ghc
08:03:07 <anybody> s/som/some/
08:03:21 <SamB> you are thinking of ophc
08:03:27 <anybody> ophc?
08:03:37 <SamB> the Oleg-powered Haskell Compiler
08:03:58 <mathias_> What's an idiomatic way to traverse a reference based list and collecting all the references in it in a list?
08:04:28 <SamB> mathias_: what makes you think there's an idiomatic way to do that?
08:04:32 <anybody> oh maybe
08:04:38 <Saizan> "reference based"?
08:04:47 <roconnor> sequence!
08:04:57 <mathias_> Saizan, STRef/IORef
08:05:06 <roconnor> oh
08:05:10 <Saizan> mapM readIORef ?
08:05:22 <quicksilver> :t mapM readIORef
08:05:24 <lambdabot> Not in scope: `readIORef'
08:05:28 <quicksilver> bah!
08:05:30 <SamB> mathias_: could you, uh, tell us the type of the "list"?
08:05:45 <quicksilver> I think Saizan is right
08:05:51 <quicksilver> although I'm not really sure what you meant :)
08:06:21 <mathias_> The type is isomorphic to [], but it uses references.
08:07:02 <xDie> hi all
08:07:12 <roconnor> xDie: hi
08:07:20 <xDie> i have problem with lambdabot
08:07:25 <quicksilver> you mean data RefList a = Nil | Cons a (IORef (RefList a)) ?
08:07:34 <roconnor> @vixen
08:07:34 <lambdabot> I'm sorry, I'm confused.
08:07:37 <quicksilver> that sounds nasty, why would you want that?
08:07:44 <mathias_> quicksilver, yes
08:08:03 <xDie> somebody can lambdabot join in #gentoo-uy
08:08:18 <mathias_> quicksilver, that's because I simplified the problem in this channel.
08:08:20 <xDie>  @join #gentoo-uy
08:08:40 <ivant> xDie, ask dons, but probably he has gone to sleep already
08:08:42 <quicksilver> xDie: only admins can do that I'm afraid
08:08:47 <xDie> but lambdabot crashed
08:09:00 <xDie> yes ikown
08:09:04 <quicksilver> mathias_: well you can't use 'map' obviously because what you have isn't a list
08:09:17 <quicksilver> mathias_: you'd have to write your own recursion although it wouldn't be too hard
08:09:27 <xDie> lambdabot, have in your channel list gentoo-uy
08:09:27 <quicksilver> mathias_: I'm curious as to why you'd want such a structure
08:09:30 <xDie> but crash
08:09:31 <lambdabot> Will I get a treat if I join #gentoo-uy?
08:09:32 <xDie> :(
08:09:38 <xDie> yes
08:09:48 <opqdonut> :D
08:09:52 <xDie> jeje
08:10:05 <shapr> @botsnack
08:10:05 <lambdabot> :)
08:10:10 <opqdonut> did it join?
08:10:17 <xDie> thanks
08:10:22 <opqdonut> omg :)
08:10:26 <xDie> :)
08:10:37 <ivant> :-)
08:11:01 <xDie> :D~~
08:11:05 <xDie> haskell++
08:11:07 <ivant> @quote lambdabot Will I get a treat if I join #gentoo-uy?
08:11:07 <lambdabot> No quotes match. Just what do you think you're doing Dave?
08:11:16 <ivant> oops
08:11:17 <roconnor> @remember
08:11:17 <lambdabot> Incorrect arguments to quote
08:11:20 <opqdonut> @remeber lambdabot Will I get a treat if I join #gentoo-uy?
08:11:20 <lambdabot> Done.
08:11:23 <opqdonut> :)
08:11:25 <opqdonut> sorry
08:11:47 <mathias_> quicksilver, when I ask for the first element of this RefList when I call the function getAllReferences, will it only traverse the first element?
08:14:04 <quicksilver> mathias_: well you can write the code to do whatever you want
08:14:11 <quicksilver> mathias_: I assumed you mean all elements
08:14:21 <quicksilver> mathias_: but really I need to understand a bit more about what you're trying to do
08:14:25 <quicksilver> it sounds very strange
08:15:20 <hpaste>  anybody pasted "oleg's shuffle problem" at http://hpaste.org/2159
08:15:22 <mathias_> quicksilver, No, I am not interested in all the elements in a list.
08:15:31 <anybody> hm i have a problem with oleg's shuffle1. has anyone a working version?
08:15:44 <mathias_> quicksilver, I am interested in getting a list of references to those elements.
08:15:46 <anybody> this simple example leads to en exhaustive matching error
08:16:18 <earthy> *** Exception: LinearAlgebraToken.hs:(61,4)-(100,14): Non-exhaustive patterns in function ==
08:16:21 <earthy> *drat*
08:16:22 <mathias_> quicksilver, and that should happen in a time proportional to the number of elements requested.
08:16:23 <anybody> and I have no idea why.
08:16:45 <earthy> (yeah, that's a 40-line definition. yeah, that sucks)
08:17:35 <quicksilver> mathias_: why do you want references to those elements?
08:18:03 <mathias_> quicksilver, that's the interface I am programming against
08:18:33 <quicksilver> should be as simple as mapM newIORef (take 10 list)
08:18:41 <quicksilver> to get references to the first 10 elements of a list
08:20:18 <mathias_> quicksilver, the input is not a [], it's a RefList
08:20:31 <mathias_> quicksilver, I already wrote it, never mind.
08:33:04 <chessguy> hm, did Cale and ddarius start talking about category theory and put everyone to sleep again?
08:33:28 <ivant> chessguy, where?
08:33:35 <chessguy> here
08:34:05 <kosmikus> ... zZzZzZ ...
08:34:22 <ivant> ah, I though I was missing some important information resource
08:35:16 <quicksilver> @users
08:35:16 <lambdabot> Maximum users seen in #haskell: 375, currently: 362 (96.5%), active: 19 (5.2%)
08:35:47 <chessguy> > 19/362
08:35:49 <lambdabot>  5.2486187845303865e-2
08:35:57 <chessguy> > 19/375
08:35:58 <lambdabot>  5.0666666666666665e-2
08:37:20 * MyCatVerbs pokes lambdabot
08:37:22 <MyCatVerbs> @users
08:37:22 <lambdabot> Maximum users seen in #haskell: 375, currently: 363 (96.8%), active: 19 (5.2%)
08:37:28 <MyCatVerbs> Damn, still only nineteen.
08:37:41 * edwinb activates himself
08:37:49 <quicksilver> its active threshold is quite long
08:37:53 <quicksilver> maybe half an hour or so?
08:38:29 <kral> does anyone know how to compile some haskell code for running on a nintendo ds?
08:39:00 <glen_quagmire> nitendo ds has haskell sdk?
08:39:07 <quicksilver> not that I've heard
08:39:09 <quicksilver> would be cool, though
08:39:16 * shachaf activates.
08:39:29 <glen_quagmire> can't ghc compile into c?
08:39:45 <quicksilver> yes
08:39:59 <kral> nintendo ds has two arm processors
08:40:13 <shachaf> Activate the mighty WARRIOR GORILLA POWERS!
08:40:35 <quicksilver> @users
08:40:35 <lambdabot> Maximum users seen in #haskell: 375, currently: 365 (97.3%), active: 20 (5.5%)
08:40:44 <MyCatVerbs> kral: I thought that was that GP2X thing.
08:40:59 <kral> i've read that ghc compile for arm, but i'm not sure how
08:41:36 <MyCatVerbs> Ohhh, my bad.
08:41:48 <MyCatVerbs> Why two, I wonder? Make it easier to do low-latency work?
08:42:07 <kral> MyCatVerbs: i don't know :)
08:42:14 <wli> If your aim is world domination, go for embedded. ARM, MIPS, PPC.
08:43:06 <shachaf> Wikipedia (a reliable source) says: CPUs: Two ARM processors, an ARM946E-S main CPU and ARM7TDMI co-processor at clock speeds of 67 MHz and 33 MHz respectively, with 4 MB of main memory which requires 1.65 volts.
08:43:08 <norgul> hi
08:43:16 <glen_quagmire> hi norgul
08:43:40 <norgul> i have no idea how the defining of your on datatype works
08:43:53 <kral> shachaf: ya
08:43:56 <norgul> data Pair a b = Pair a b
08:44:01 <norgul> as shown in YAHT
08:44:27 <norgul> but YAHT doesnt tell me anything how to use it
08:44:47 <mauke> pattern matching
08:44:51 <norgul> how do you define your own substance of it?
08:44:53 <shachaf> norgul: Pair 1 2 constructs a pair of two numbers.
08:44:58 <mauke> substance?
08:45:15 <norgul> ye
08:45:20 <shachaf> norgul: f (Pair x y) = ...x... works with the elements inside it.
08:45:30 <msouth> myFirst ( Pair a b ) = a
08:45:44 <norgul> hmm, yeah
08:46:03 <byorgey> pairFunc f (Pair a b) = f a b
08:46:12 <norgul> and recursive datatypes :S
08:46:35 <shachaf> norgul: Also look at some more interesting data-types.
08:46:44 <byorgey> norgul: recursive datatypes aren't really any harder than non-recursive datatypes.
08:46:56 <msouth> on the left of your "data Pair a b" you are stating that you are going to have a type named Pair.  On the right you are specifying a constructor for that type, named Pair, called as Pair a b
08:47:17 <quicksilver> it is, initially, confusing to use the same names for the two things
08:47:20 <shachaf> norgul: Yes, as msouth may be implying, the names on the left and right don't have to be the same.
08:47:24 <msouth> and in the function definition, when you pattern match, the constructor is also the "destructor"
08:47:25 <quicksilver> once you get used to it isn't convenient though
08:47:34 <quicksilver> erm
08:47:37 <quicksilver> it *is* convenient
08:47:41 <byorgey> norgul: here's another simple example:
08:47:47 <byorgey> data Maybe a = Nothing | Just a
08:47:55 <msouth> you use the constructor to "get at" the things inside the data type
08:48:18 <shachaf> A "Maybe Char" means you either have a char, or you have nothing.
08:48:31 <norgul> does the datatype's parameter effect on the constructor?
08:48:31 <shachaf> Where "|" is read as "or".
08:48:46 <shachaf> norgul: You can use the parameter in the constructor.
08:49:17 <shachaf> norgul: (:) and [] are sort of constructors for lists, if you've looked at those.
08:49:24 <norgul> okay
08:49:43 <norgul> data Maybe a = Nothing | Just a
08:49:47 <shachaf> norgul: Which is why you can pattern-match on them.
08:50:01 <shachaf> So, Nothing :: Maybe Char.
08:50:01 <norgul> what's the point with it? make the code more "understandable"?
08:50:07 <shachaf> And Just 'a' :: Maybe Char.
08:50:13 <shachaf> norgul: Take a function that can fail.
08:50:22 <shachaf> norgul: Like (!!), if you've come across it?
08:50:37 <norgul> nope
08:51:05 <mauke> Map.lookup
08:51:08 <chessguy> @type Nothing
08:51:13 <lambdabot> forall a. Maybe a
08:51:20 <mauke> @type Map.lookup
08:51:21 <shachaf> Ignore the forall part.
08:51:22 <lambdabot> Couldn't find qualified module.
08:51:26 <mauke> :(
08:51:29 <shachaf> @ty Data.Map.lookup
08:51:31 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
08:51:42 <byorgey> Map.lookup isn't a good example...
08:51:49 <mauke> oops, overly generic
08:51:54 <byorgey> =)
08:52:03 <mauke> just pretend it's k -> Map k v -> Maybe v
08:52:32 <norgul> ah, i think i get the recursive datatype thingy now
08:53:01 <msouth> the easiest one for me to get was to define your own list structure
08:53:46 <norgul> data List a = Nil | Cons a (List a)
08:54:19 <msouth> and then define map, head, and tail on it
08:54:27 <msouth> to get used to pattern matching and what it does
08:54:32 <norgul> i will try
08:55:04 <msouth> then you realize that all the magic of lists is in the recursive data definition
08:55:56 <msouth> norgul: you might want to add a "deriving Show" to the end of your definition
08:56:00 <chessguy> @src (>>=) []
08:56:00 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:56:09 <msouth> if you're going to be testing it in the interpreter
08:56:16 <msouth> I can't remember if you need it for that or not
08:56:16 <norgul> okay
08:56:18 <byorgey> chessguy: other way around
08:56:21 <chessguy> @src [] (>>=)
08:56:21 <lambdabot> m >>= k     = foldr ((++) . k) [] m
08:56:24 <norgul> what does it?
08:56:36 <shachaf> @ty lookup
08:56:38 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
08:56:41 <msouth> it lets the interpreter "stringify" your results
08:56:46 <chessguy> @src concatMap
08:56:47 <lambdabot> concatMap f = foldr ((++) . f) []
08:56:48 <shachaf> (>>=) for lists is concatMap.
08:57:03 <shachaf> Or (flip concatMap), rather.
08:57:09 <msouth> your data type might not need it.  I'm too newbie myself to have a good understanding of when it's necessary
08:57:18 <chessguy> shachaf, you were right the first time
08:57:19 <shachaf> msouth: Show?
08:57:35 <shachaf> chessguy: No, the second.
08:58:00 <byorgey> yes, adding "deriving Show" to the end of a data definition is a good idea for playing around with it in the interpreter
08:58:01 <shachaf> > let bind = flip concatMap in [1,2,3] `bind` (\x -> [x+1])
08:58:02 <lambdabot>  [2,3,4]
08:59:33 <chessguy> @type concatMap
08:59:35 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:59:41 <chessguy> oh, right, ok
08:59:58 <chessguy> i don't know why i always thought >>= was concatMap
09:00:04 <msouth> shachaf: is that wrong?  I'm almost sure I defined a datatype and tried doing stuff with it in the interpreter and it complained that there was no instance of Show for the type.
09:00:44 <shachaf> msouth: deriving Show is fine if you want to try out new data-types (or in general).
09:01:02 <chessguy> msouth, you need to either derive Show, or give an explicit instance
09:01:08 <norgul> well, how do i use the function?
09:01:18 <norgul> ive written myMap now
09:01:29 <shachaf> msouth: Also deriving (Eq,Ord), in some cases.
09:01:32 <msouth> norgul: do you know how to load your code into ghc?
09:01:38 <msouth> :l filename
09:01:41 <norgul> :l Something.hs
09:01:45 <norgul> i know
09:01:59 <norgul> i run emacs with splitted windows
09:02:02 <shachaf> norgul: Just make a list: (Cons 1 (Cons 2 (Cons 3 Nil)))
09:02:04 <norgul> one running ghc
09:02:11 <norgul> and other the source code
09:02:20 <norgul> ah
09:02:23 <norgul> there you go
09:02:24 <shachaf> norgul: If you have deriving Show, it'll be simpler to work with it.
09:02:27 <msouth> norgul: let x = (Cons 1 (Cons 2 (Cons 3 Nil)))
09:02:34 <norgul> mhm, i know
09:02:35 <shachaf> Looks like LISP, doesn't it? :-)
09:02:53 <norgul> yep
09:03:04 <norgul> my friend do lisp
09:03:22 <chessguy> hm, can you do let x = Cons 1 $ Cons 2 $ Cons 3 Nil ?
09:03:30 <norgul> am i young as a haskeller?
09:03:34 <norgul> im 15 years old
09:04:01 <msouth> myMap ((+) 1) x
09:04:07 <shachaf> chessguy: Why not?
09:04:23 <msouth> norgul: never too soon to start
09:04:38 <quicksilver> because to do so is to admit that $ is right-associative, which is a tragic thing I do not wish to be reminded of
09:04:40 <shachaf> > (:) 1 . (:) 2 . (:) 3 $ []
09:04:42 <lambdabot>  [1,2,3]
09:04:43 <masak> hello, I'd like to turn my command-line arguments from [String] into [Real]. how do I do that?
09:04:51 <msouth> might be better to do it now before the other languages get a hold of your brain and teach you dependence on bad things :)
09:04:54 <quicksilver> masak: there is no 'Real' type
09:04:56 <kjdf> are arrays in haskell lazy?
09:04:59 <mauke> map read
09:05:01 <quicksilver> masak: but ignoring that details, map read
09:05:05 <mauke> kjdf: yes
09:05:06 <shachaf> masak: map read? But as quicksilver says, there is no Real.
09:05:10 <masak> quicksilver: hm, Rational instead of Real?
09:05:13 <mauke> kjdf: actually, depends on the array
09:05:14 <kjdf> hmm
09:05:17 <quicksilver> kjdf: lazy in values, strict in indexes, I think?
09:05:31 <masak> which is the preferred floating-point type?
09:05:37 <ricky_clarkson> As log as youre younger than the leaders in your field, norgul, you're doing ok.
09:05:37 <mauke> Double
09:05:37 <quicksilver> kjdf: except the ones with totally unboxed
09:05:41 <ricky_clarkson> s/log/long/
09:05:43 <kjdf> how would 'Array.fromList lazyList' work
09:06:05 <quicksilver> "preferred" and "floating point" are oxymoronic
09:06:09 <quicksilver> but Double is the least worst
09:06:19 <quicksilver> kjdf: it would force the spine (shape) of the list
09:06:24 <quicksilver> kjdf: but it wouldn't force the actual values themselves
09:06:25 <kjdf> if I refer to an index whose value was not yet computed in list, it'd wait and force evaluation?
09:06:31 <quicksilver> right
09:06:41 <SamB_XP> but Float is tinier if you have some kind of unboxed arrays
09:06:44 <masak> is there a function doing String -> Double?
09:06:50 <mauke> read
09:06:50 <shachaf> masak: read.
09:06:54 <masak> ah, ok
09:06:55 <shachaf> @ty read
09:06:55 <masak> thx
09:06:57 <lambdabot> forall a. (Read a) => String -> a
09:07:09 <chessguy> quicksilver, did you see the google video the other day on interval arithmetic as a replacment for floating point opes?
09:07:12 <chessguy> *ops
09:07:20 <quicksilver> chessguy: no, although I've been to seminars on it
09:07:28 <quicksilver> chessguy: rather non-practical ones I might add
09:07:30 <quicksilver> :)
09:07:33 <chessguy> quicksilver, nice video. it was linked in -cafe
09:08:09 <norgul> my function was wrong
09:08:20 <shachaf> norgul: What was your function?
09:08:35 <shachaf> norgul: (@paste if it's more than 3 lines.)
09:08:36 <norgul> myMap f (Cons x xs) = Cons (f x) xs
09:08:52 <shachaf> norgul: Well, this isn't recursive.
09:09:06 <norgul> wait
09:09:07 <shachaf> norgul: For one, you want to have both cases: Cons and Nil.
09:09:08 <SamB_XP> chessguy: is it in http://haskell.org/haskellwiki/Video_presentations?
09:09:09 <lambdabot> Title: Video presentations - HaskellWiki
09:09:23 <shachaf> norgul: And also, you want it to run over all the elements, not just the head.
09:09:37 <hpaste>  masak pasted "I get expected type: String -> Char and inferred type: String -> String on this main method. why?" at http://hpaste.org/2160
09:09:45 <chessguy> SamB_XP, no
09:10:58 <chessguy> SamB_XP, http://video.google.com/videoplay?docid=-2285617608766742834
09:10:59 <lambdabot> Title: A Google Opportunity in Numerical Computing
09:11:14 <SamB_XP> oh, not Haskell-related.
09:11:22 <norgul> hmm
09:11:30 <chessguy> right
09:11:38 <mauke> masak: putStrLn takes a string. map (bar . read) p returns a list of strings.
09:11:44 <SamB_XP> so what do they do with pi?
09:11:46 <masak> mauke: thx
09:12:17 <masak> also, is there a way to avoid all the backwhacked quotation marks in the strings?
09:12:24 <shachaf> norgul: You might as well write these functions with the regular list ([]).
09:13:03 <norgul> mymap f (x:xs) = (f x) : myMap f xs
09:13:42 <byorgey> norgul: right.  now you need a base case also.  (i.e., what if the list is empty?)
09:14:06 <norgul> myMap f [] = []
09:14:32 <shachaf> norgul: That looks right.
09:14:34 <pjd> masak: build the string up from smaller combinators?
09:15:14 <SamB_XP> masak: what strings?
09:15:18 <masak> pjd: I was more looking for a painless way to write lots of quote characters in a string
09:15:32 <shachaf> norgul: Try some other functions now!
09:15:50 <masak> SamB_XP: the ones in the paste.  http://hpaste.org/2160
09:15:50 <shachaf> > filter even [1..10]
09:15:55 <lambdabot>  [2,4,6,8,10]
09:16:03 <norgul> i want to fix the myMap on my own datatype List
09:16:07 <norgul> it's hard
09:16:21 <pjd> masak: how about a painless way to avoid having to write quote characters the string?
09:16:26 <norgul> but i could try writer foldr for a normal list
09:16:30 <byorgey> norgul: you can pretty much translate directly from the code you wrote above.
09:16:33 <SamB_XP> masak: xml library?
09:16:34 <masak> pjd: that would work too :)
09:16:37 <shachaf> norgul: Why hard?
09:16:40 <masak> SamB_XP: yes, probably
09:16:42 <byorgey> norgul: just remember that (x:xs) is the same as Cons x xs.
09:16:44 <mauke> myMap f (x `Cons` xs) = (f x) `Cons` myMap f xs
09:16:44 <shachaf> norgul: It's exactly the same.
09:17:06 <norgul> what does `?
09:17:08 <masak> what are some Haskell XML writer libraries?
09:17:12 <byorgey> mauke, let norgul figure it out =)
09:17:21 <norgul> hmm
09:17:24 <norgul> lemme see
09:17:29 <norgul> syntactic sugar?
09:17:30 <mauke> norgul: `` turns a function into an operator
09:17:38 <chessguy> SamB_XP, was that question about pi directed at me?
09:17:43 <mauke> or rather, it turns a normal identifier into an infix symbol
09:17:46 <SamB_XP> chessguy: yeah
09:17:52 <masak> I converted a Rational to a String with show, but got the runtime error "Prelude.read: no parse". why?
09:18:04 <chessguy> SamB_XP, depends on what level of precision you ask for
09:18:10 <byorgey> norgul: it's syntactic sugar, yes.  you don't necessarily need to use it to implement myMap.
09:18:12 <norgul> mauke !
09:18:17 <norgul> that's pretty cool
09:18:33 <byorgey> > mod 5 2
09:18:34 <anybody> i have a problem with StdGen. when i initialize it using "curTime <- epochTime ,...mkStdGen (fromEnum(curTime)::Int)" i experience some strange behaviour in that the first call to "randomR" always returns the same value.
09:18:35 <lambdabot>  1
09:18:39 <byorgey> > 5 `mod` 2
09:18:40 <lambdabot>  1
09:18:52 <mauke> > 7 `elem` [1 .. 10]
09:18:53 <SamB_XP> > (`mod`)
09:18:54 <lambdabot>  Parse error
09:18:54 <lambdabot>  True
09:19:00 <SamB_XP> hmm.
09:19:16 <shachaf> @ty (`mod`)
09:19:18 <lambdabot> parse error on input `)'
09:19:26 <chessguy> @type mod
09:19:27 <lambdabot> forall a. (Integral a) => a -> a -> a
09:19:28 <byorgey> SamB_XP: (`f`) /= f.
09:19:32 <shachaf> lambdabot: That's cheating!
09:19:47 <SamB_XP> icky
09:20:08 <drigz> i wonder why not
09:20:26 <drigz> since (`mod` 2) works...
09:20:34 <kjdf> byorgey: what is the difference?
09:20:40 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2161
09:20:49 <byorgey> kjdf: (`f`) is a parse error, I think.
09:20:56 <byorgey> > (`mod`) 5 2
09:20:56 <lambdabot>  Parse error
09:21:25 <byorgey> > 6 `(+)` 1
09:21:26 <lambdabot>  Parse error
09:21:38 <desegnis> > (`mod` 2) 5
09:21:40 <SamB_XP> I wouldn't expect `(+)` to work
09:21:41 <lambdabot>  1
09:21:41 <shachaf> No, you can't have arbitrary expressions in ``.
09:21:43 <chessguy> norgul,  that's almost right
09:22:02 <puusorsa> is it possible, or maybe even easy, to use distcc with ghc?
09:22:04 <kjdf> > let p = (+) in 1 `p` 2
09:22:05 <chessguy> norgul, it will run forever though. do you know why?
09:22:05 <lambdabot>  3
09:22:10 <puusorsa> or some other thing to distribute compiling
09:22:22 <anybody> should i use something else than epochTime to feed to makeStdGen?
09:22:44 <norgul> Nil?
09:22:44 <SamB_XP> puusorsa: they don't even have trunk compiling on multiple cores, do they?
09:22:54 <kjdf> > let p = (+) in 1 `p` (++++) = p in 1 ++++ 4
09:22:54 <lambdabot>  Parse error
09:22:56 <masak> is show the thing I should use to convert from Rational to String?
09:23:01 <puusorsa> i have no idea
09:23:04 <kjdf> > let p = (+) in 1 `p`; (++++) = p in 1 ++++ 4
09:23:04 <lambdabot>  Parse error
09:23:20 <kjdf> > let p = (+) ; (++++) = p in 1 ++++ 4
09:23:21 <lambdabot>  5
09:23:29 <kjdf> uh.
09:23:35 <SamB_XP> puusorsa: the thing is that to compile a module, GHC needs the interface files from compiling all of the modules it imports
09:23:41 * kjdf crawles back under his rock
09:23:48 <Vulpyne> masak: Should work.
09:23:48 <norgul> chessguy, because of the Nil?
09:23:59 <byorgey> norgul: right, you're missing a base case.
09:24:04 <chessguy> norgul, yes
09:24:06 <SamB_XP> puusorsa: so it's not nearly as trivial to parallelize compilation as with C or C++ code
09:24:10 <shachaf> chessguy: What is almost right?
09:24:14 <Vulpyne> Wouldn't it die when it hits a Nil rather than continue infinitely?
09:24:15 <byorgey> actually, it won't run forever, it will give a pattern match error
09:24:20 <puusorsa> ok thanks
09:24:41 <byorgey> shachaf: norgul's hpaste
09:25:01 <shachaf> byorgey: Oh, oops.
09:25:06 <chessguy> shachaf, http://hpaste.org/2161
09:25:14 <puusorsa> i don't so much care about parallelization as making another computer compile everything as far as possible and then do jsut linking or whatever is left
09:25:30 <shachaf> norgul: Now define toList and fromList for you data type.
09:25:36 <norgul> how can i make cons "empty" in a base case?
09:25:36 <shachaf> (Bad names...)
09:25:44 <shachaf> norgul: Cons is never empty.
09:25:49 <shachaf> norgul: A List is empty.
09:25:51 <shachaf> norgul: How?
09:25:57 <norgul> hmm
09:26:07 <SamB_XP> puusorsa: heh. I'd be more inclined to make the other computer do the linking ;-)
09:26:10 <Vulpyne> myMap _ Nil = Nil
09:26:12 <puusorsa> so a shell script to send modified .hs:files to the other comp, ghc to .c, and then use distcc maybe
09:26:22 <norgul> ah, right!
09:26:28 <SamB_XP> puusorsa: what?
09:26:44 <hpaste>  masak pasted "why does this give the runtime error message "Prelude.read: no parse"?" at http://hpaste.org/2162
09:26:47 <SamB_XP> you have an unregisterized GHC?
09:26:57 <chessguy> norgul, actually, i was wrong, it won't loop infinitely, it will just error when it can't match the empty list against (Cons x xs)
09:27:03 <puusorsa> unregistered?
09:27:16 <SamB_XP> unregister*ized*
09:27:20 <puusorsa> i don't know how the internals work
09:27:33 <SamB_XP> apparantly it means "produces plain C code"
09:27:51 <puusorsa> produces some really evil looking c code
09:28:10 <SamB_XP> where by plain, I mean it's actually C, not some abominable abuse of a C compiler to do something other than compile C...
09:28:12 <shachaf> chessguy: Same thing.
09:28:24 <shachaf> chessguy: _|_ in either case. :-)
09:28:29 <puusorsa> didn't look at the stuff for long, i could feel my sanity points going
09:28:40 <SamB_XP> probably a registerized GHC then
09:28:45 <norgul> how can i write typesignature to this?
09:28:54 <chessguy> shachaf, but different errors
09:28:56 <shachaf> norgul: Think about it, compare it to map's.
09:29:10 <mauke> masak: because Rational expects a special input format
09:29:20 <shachaf> norgul: It's good practice writing type signatures.
09:29:27 <shachaf> norgul: What arguments does it get?
09:29:31 <SamB_XP> puusorsa: though I'm sure the C from an unregisterized GHC would still be rather inscrutible
09:29:38 <puusorsa> so there's no simple way to use x86/linux to get g4 osx binaries from haskell source?
09:29:48 <masak> mauke: ah, so things like 1 are no good?
09:29:52 <mauke> yeah :/
09:30:02 <norgul> on :t map?
09:30:06 <chessguy> ok, time to get back to work :(
09:30:12 <shachaf> norgul: Figure map out too.
09:30:21 <puusorsa> oh well better to find out this way than spend a day trying, thanks
09:30:25 <SamB_XP> puusorsa: um, you could use qemu maybe
09:30:32 <shachaf> norgul: What are its arguments?
09:30:32 <mauke> masak: try Double instead
09:30:39 <masak> mauke: ok
09:30:41 <norgul> (a -> b) -> [a] -> [b]
09:30:41 <SamB_XP> running darwin
09:30:50 <SamB_XP> short of that, not really
09:30:55 <shachaf> norgul: OK.
09:31:05 <shachaf> norgul: So myMap ::?
09:31:15 <puusorsa> yeah and that doesn't fit how i understand "simple"
09:31:34 <SamB_XP> well the advantage of that is that all the complexity is in getting the thing to run
09:31:48 <norgul> (t -> a) -> List t -> List t?
09:31:59 <shachaf> norgul: Close.
09:32:00 <SamB_XP> not in hacking GHC
09:32:05 <shachaf> norgul: Compare that to map.
09:32:09 <masak> mauke: thanks, that worked
09:32:24 <shachaf> norgul: Why did you switch from a/b to t/a? That could be confusing.
09:32:26 <pejo> puusorsa, why can't you use the ghc binary for osx/ppc?
09:32:45 <norgul> :P
09:32:53 <norgul> i wrote :t myMap xD
09:32:54 <SamB_XP> puusorsa: what do you want to compile anyway?
09:33:11 <SamB_XP> puusorsa: GHC isn't the only haskell implementation in existance
09:33:16 <puusorsa> i can. g4/1ghz and 512M ram vs newish x86 with a few gigs. thats the problem
09:33:20 <shachaf> norgul: Oh.
09:33:27 <shachaf> norgul: And then miscopied it?
09:33:39 <shachaf> norgul: It should be (a -> b) -> List a -> List b.
09:33:48 <norgul> ok
09:33:54 <SamB_XP> puusorsa: well, qemu could certainly take advantage of those gigs
09:34:29 <shachaf> norgul: Can you convert from [] to List?
09:34:49 <SamB_XP> not sure how much the speed/memory hit from having to translate the machine code would offset that though
09:34:52 <norgul> hmm
09:35:06 <norgul> should i write a function which do that?
09:35:26 <shachaf> norgul: Sure.
09:35:51 <puusorsa> oh well there's a feature request http://hackage.haskell.org/trac/ghc/ticket/964
09:35:53 <lambdabot> Title: #964 (Cross Compile and Universal Binary) - GHC - Trac
09:35:58 <desp> ghci needs 500 MB of memory to keep [(a, b) | a <- [-999..999], b <- [-999..999]] :: [(Int, Int)]
09:36:35 <mauke> > 2000^2 * 4
09:36:44 <lambdabot>  16000000
09:37:10 <thoughtpolice> wee. :) while my irc bot has not yet had its first steps, the plugins system is working, so adding features should be easy. not as fun as lambdabot but it's a start and plugins is a fun lib.
09:37:19 <Toxaris> I try do understand ByteString internals, but seem to fail with the most basic question: Is there a version of the ByteStrings-library wich actually implements Stream fusion as described in "Rewriting Haskell Strings"?
09:37:34 <norgul> is there any code snippets where anyone use recursive datatypes inside functions?
09:37:41 <norgul> i could study it and see how it works
09:37:46 <sjanssen> @src map
09:37:47 <lambdabot> map _ []     = []
09:37:47 <lambdabot> map f (x:xs) = f x : map f xs
09:37:51 <SamB_XP> puusorsa: come to think of it, can't x86 macs run PowerPC apps anyway?
09:37:52 <sjanssen> norgul: there's one :)
09:37:57 <shachaf> norgul: You just wrote some. :-)
09:38:01 <puusorsa> SamB_XP, yeah
09:38:03 <sjanssen> @src filter
09:38:03 <lambdabot> filter _ []     = []
09:38:03 <lambdabot> filter p (x:xs)
09:38:03 <lambdabot>     | p x       = x : filter p xs
09:38:03 <lambdabot>     | otherwise = filter p xs
09:38:11 <sjanssen> @src foldr
09:38:12 <lambdabot> foldr k z xs = go xs
09:38:12 <lambdabot>     where go []     = z
09:38:12 <lambdabot>           go (y:ys) = y `k` go ys
09:38:22 <sjanssen> norgul: had enough yet?
09:38:23 <SamB_XP> puusorsa: I don't suppose you *have* an x86 mac?
09:38:25 <shachaf> norgul: data List a = Nil | Cons a (List a) is exactly data [a] = [] | a : [a]
09:38:29 <thoughtpolice> SamB_XP: using rosetta you should be able to.
09:38:36 <puusorsa> i don't have a x86 mac, that's the problem. if i did i doubt it'd be annoyingly slow
09:39:00 <SamB_XP> hmm, I've heard tales of pirated copies of OS X...
09:39:40 <SamB_XP> ... that ran on non-Mac machines, even
09:40:26 <quicksilver> I've heard tails of sea monsters
09:40:34 <quicksilver> ... can be over 40 feet long.
09:40:51 <puusorsa> i've had one in vmware
09:40:59 <SamB_XP> yes but I think the tales I heard are more likely to be true
09:41:28 <puusorsa> wasn't exactly usable or stable
09:41:30 <RyanT5000> SamB_XP: i tried it; it worked but didn't have the drivers i needed
09:41:43 <SamB_XP> RyanT5000: which drivers?
09:41:46 <RyanT5000> thinkpad
09:41:54 <SamB_XP> you don't need too many drivers to run a compiler anyway
09:41:55 <RyanT5000> i forget which particular components
09:42:00 <shachaf> quicksilver: Tall tails.
09:42:13 <RyanT5000> SamB_XP: true; it probably could have done that
09:43:14 <puusorsa> and anyway i'm jsut learning haskell and thought it'd be nice if correcting stupid mistakes didn't take additional 10 secs waiting for the compiler to insult me
09:43:41 * SamB_XP wonders why they claim that raytracers aren't compatible with Rosetta
09:44:08 <RyanT5000> puusorsa: are you running ghci or ghc?
09:44:08 <roconnor> @what Rosetta
09:44:09 <lambdabot> I know nothing about rosetta.
09:44:15 <RyanT5000> puusorsa: or something else
09:44:31 <SamB_XP> follow the link to information on universal binaries from the above ticket
09:45:14 <puusorsa> depends
09:45:20 <tsp> how do you pronounce foldl'?
09:45:32 <sjanssen> fold el prime
09:45:38 <kolmodin> fold-el-prime
09:45:55 <desp> foldl*wheeze*
09:45:59 <tsp> heh, first time I actually used the dictionary for something useful
09:46:23 <puusorsa> ghci to play with stuff and see what happens and ghc if i try to make some semi-useful binary
09:46:23 <shachaf> Fold-ell-prime -- I have TWO "l"s!
09:46:29 <tsp> hearing if I was lucky "foldl apostrophe" or just "foldl" depending on punctuation settings is weird
09:46:33 <sjanssen> kal el prime
09:46:50 <SamB_XP> hmm, apparantly rosetta uses imprecise exceptions. I wonder how well that works for GHC...
09:47:03 <SamB_XP> s/uses/provides only/
09:47:50 <tsp> now if I could build a screen reader that would do semi intelligent parsing
09:48:02 <puusorsa> s/semi-useful// .. now that i think of it
09:48:22 <shapr> I say fold-ell-tick
09:48:39 <puusorsa> got calling haskell functions from cocoa application though :)
09:48:52 <tsp> shapr: that works too :) the shorter something is, the better
09:49:04 <tsp> especially when your going at 500 wpm
09:49:34 <shapr> and ` is backtick
09:49:50 * shapr swears at his own stupidity.
09:49:52 <SamB_XP> puusorsa: probably the easiest thing would be to have your mac use some of the other computer's ram as swap...
09:49:54 <shapr> Man, I hate it when I do stupid stuff.
09:50:18 * shachaf pronounces some Haskell things very oddly.
09:50:23 <tsp> shapr: ever tried emacspeak with eSpeak? eSpeak is the new rage in synths now :)
09:50:39 <puusorsa> == figured out how to use ffi and -no-hsmain .. there's http://hoc.sourceforge.net/ but i couldn't get even the examples working
09:50:40 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
09:50:55 <shapr> tsp: packaged by delYsid, unsurprisingly
09:51:08 <anybody> hey i've got kinda weird problem with random. although i feed it the system time, it seems to return the same value all the time.
09:51:09 <hpaste>  anybody pasted "not random?" at http://hpaste.org/2163
09:51:13 <tsp> probably a really old version in debian
09:51:21 <d-bug> i bought a 2GB USB memory stick and added it as swap on my Mac
09:51:22 <magnus_> Weeh, I think I found a new functional data structure... I should write an article
09:51:30 <anybody> on my comp it seems to return 8 all the time
09:51:39 <puusorsa> d-bug, you have usb2 in it, right?
09:52:10 <shapr> Hiya d-bug, long time no see
09:52:38 <d-bug> puusorsa, yes i have, but unfortunenly i bought some noob usb stick that only does 9mb/s read and 1mb/s write
09:53:08 <tsp> d-bug: ouch
09:53:13 <quicksilver> anybody: I get 8 or 34 randomly
09:53:15 <d-bug> puusorsa, since the stick said "Vista ReadyBoost compatible" i thought it would manage 30+MB/s read and 10+MB/s write as some stick does
09:53:20 <d-bug> shapr, hejsan!
09:53:25 <shapr> god morgon!
09:53:32 <arcatan> "noob usb stick" :)
09:53:34 <d-bug> god kväll
09:53:37 <shapr> d-bug: it's running at vista speeds :-)
09:53:38 <anybody> quicksilver: yeah. but its always 8 or 34
09:53:42 <puusorsa> vista ...
09:54:04 <shapr> I got to try Vista for the first time recently on a dual-core 2GHz laptop with 2Gb of ram. Vista runs like a slug.
09:54:04 <d-bug> anyway, just do this if you have a stick: sudo dynamic_pager -F /Volumes/"NO NAME"/swapfile
09:54:12 <anybody> quicksilver: and it should be in the range 0-51
09:54:18 <puusorsa> thanks
09:54:20 <norgul> but guys, the function doesnt work
09:54:40 <norgul> myMap f (Cons x xs) = (f x) `Cons` myMap f xs
09:54:52 <byorgey> anybody: can you really fit an EpochTime value into an Int?
09:54:58 <tsp> I'm running XP with a solaris vm. every few days I need to reboot it, because the OS lags to hell
09:55:02 <shapr> byorgey: You can, but you have to cut off part of it.
09:55:04 <d-bug> shapr, are you still in the Göteborg-trakt?
09:55:19 <tsp> > lines "line 1\nline 2\nincomplete line"
09:55:21 <lambdabot>  ["line 1","line 2","incomplete line"]
09:55:25 <tsp> lol waht a function
09:55:30 <anybody> byorgey: hm. i don't know :-(
09:55:33 <shapr> d-bug: Nu bor jag i Alabama
09:55:53 <shapr> But I'll hopefully move back to Stockholm in jan/feb.
09:56:07 <tsp> shapr: your swedish? neat
09:56:08 <sjanssen> anybody: the first output seems to always be 8 or 34, but the next outputs seem reasonably random
09:56:15 <d-bug> shapr, ok, but you used to live here in Göteborg, right?
09:56:18 <ddarius> tsp: No he's not...
09:56:56 <quicksilver> > randomR (0,51) (mkStdGen 1186678474)
09:56:57 <lambdabot>  (34,743437157 40692)
09:57:01 <quicksilver> > randomR (0,51) (mkStdGen 1186678475)
09:57:02 <shachaf> ddarius: Surely you mean "his not"? :-)
09:57:03 <lambdabot>  (8,743477171 40692)
09:57:07 <quicksilver> > randomR (0,51) (mkStdGen 1183678475)
09:57:08 <lambdabot>  (24,960556699 40692)
09:57:13 <quicksilver> > randomR (0,51) (mkStdGen 1186678485)
09:57:14 <lambdabot>  (8,743877311 40692)
09:57:17 <quicksilver> > randomR (0,51) (mkStdGen 1186678495)
09:57:18 <lambdabot>  (8,744277451 40692)
09:57:29 <quicksilver> it's been suggested before that the standard generator isn't great
09:57:29 <hpaste>  sjanssen annotated "not random?" with "only the first seems to be consistent" at http://hpaste.org/2163#a1
09:57:33 <quicksilver> but I didn't know it was this bad...
09:57:58 <sjanssen> > randomRs (0,51) (mkStdGen 1186678495)
09:58:00 <lambdabot>  [8,13,18,22,37,15,10,46,31,13,2,49,47,44,40,43,9,48,36,7,36,35,18,36,10,21,2...
09:58:15 <fxn> can anyone help getting GHC to run on a Mac? I got the tarball for Intel and the frameworks, the sh scripts have some $libexec and $libdir I have undefined
09:58:23 <sjanssen> > randomRs (0,51) (mkStdGen 1186678485)
09:58:25 <lambdabot>  [8,45,14,14,42,35,26,7,8,23,29,39,21,18,37,23,29,28,31,31,11,21,42,51,25,20,...
09:58:28 <d-bug> int random() { return 3; /* generated by a nice, guaranteed random */ }
09:58:33 <tsp> lol, its always 8
09:58:50 <sjanssen> anybody: it looks like you'll be safe if you just burn the first output
09:58:55 <sjanssen> anybody: I'm not sure why, though
09:59:12 <shachaf> d-bug: Does nice generate random numbers?
09:59:28 <quicksilver> sjanssen: I'm thinking the first number mostly contains entropy from the high bits of the gen
09:59:37 <shachaf> d-bug: I guss they're always in the range [-19..20].
09:59:40 <d-bug> I meant dice of course :)
09:59:42 <quicksilver> sjanssen: and the high bits of 'currentTime' don't change much
09:59:47 <anybody> sjanssen: yeah i thought that too. but its kinda weird.
10:00:01 <quicksilver> sjanssen: but then, it uses the low bits to seed the next split
10:00:06 <shachaf> d-bug: Oh, a die. :-)
10:00:07 <quicksilver> sjanssen: and so after that it's cleaner
10:00:15 <SamB_XP> @check \x -> fst (randomR (0,51) (mkStdGen x)) `elem` [8,34]
10:00:16 <d-bug> can i go back and edit the lines i posted?
10:00:17 <lambdabot>  Falsifiable, after 0 tests: -2
10:00:26 <quicksilver> I imagine d-bug is after this: http://xkcd.com/221/
10:00:26 <sjanssen> anybody: can you just grab a few bytes from /dev/random?
10:00:27 <d-bug> irc noob :)
10:00:27 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
10:00:32 <SamB_XP> > fst (randomR (0,51) (mkStdGen (-2))
10:00:32 <lambdabot>  Parse error
10:00:39 <SamB_XP> > fst (randomR (0,51) (mkStdGen (-2)))
10:00:40 <lambdabot>  39
10:00:44 <Saizan> why not just use newStdGen?
10:01:12 <d-bug> quicksilver, yup, that's the one
10:01:33 <quicksilver> it has often been said, there is an xkcd for every occasion
10:01:52 <d-bug> best so far is: "OMG IT'S FULL OF CAR'S"
10:02:10 <d-bug> (about God used Lisp to make the universe)
10:02:21 <quicksilver> if you like lisp jokes, this one is better: http://xkcd.com/224/
10:02:21 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
10:04:11 <puusorsa> hm wonder why clicking random doesnt go to 4
10:04:40 <DaveCGI256> is there something like antlr or yacc for haskell
10:05:02 <ddarius> DaveCGI256: Happy, Frown, Pappy
10:05:12 <ddarius> No doubt others.
10:05:41 <d-bug> quicksilver, that's the one i referred to :-)
10:06:29 <d-bug> quicksilver, yes i like lisp jokes, like the good old "my other car is a cdr" just blows me :)
10:06:41 <DaveCGI256> looks like a yacc port to haskell
10:06:48 <shachaf> @quote off.with
10:06:48 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
10:07:05 <shachaf> Someone says: Off with his car!
10:07:33 <shachaf> Many of the @quotes are gone.
10:07:43 <norgul> data Tree a = Leaf a | Branch (Tree a) a (Tree a)
10:07:55 <norgul> how can i define a tree in a variable?
10:08:06 <shachaf> norgul: let x = Leaf 5.
10:08:17 <norgul> nested, then?
10:08:19 <shachaf> norgul: Why do you have elements in both branches and leaves?
10:08:35 <shachaf> norgul: let x = Branch (Leaf 3) 4 (Leaf 5).
10:08:38 <ddarius> shachaf: Why not?
10:08:48 <d-bug> let emptyTree = ???
10:08:50 <DaveCGI256> cause cool trees have elements everywhere
10:08:53 <shachaf> ddarius: I'm not saying it's bad, just wondering.
10:09:03 <shachaf> d-bug: There is no emptyTree.
10:09:27 <norgul> is there any better tutorials than YAHT?
10:09:31 <norgul> are
10:09:36 <d-bug> i know, it's just a bit of a funny definition to not allow that
10:09:48 <d-bug> funny, but handy
10:10:05 <quicksilver> d-bug: actualy, OMG IT'S FULL OF CAR'S was a different comic. A more recent one, but not quite as funny.
10:10:13 <shachaf> quicksilver: Look again.
10:10:18 <quicksilver> oh yes
10:10:20 <quicksilver> me confused
10:10:21 <quicksilver> :(
10:10:38 <shachaf> @wiki Meta-tutorial
10:10:39 <lambdabot> http://www.haskell.org/haskellwiki/Meta-tutorial
10:10:40 <Toxaris> if you need empty trees, try forests
10:10:50 <shachaf> norgul: Maybe?
10:11:06 <shachaf> Toxaris: Sorry, I can't see any forest.
10:11:10 <shachaf> Toxaris: Only trees.
10:11:13 * d-bug sticks a quasiquote at quicksilver's back when he doesn't notice
10:11:30 <quicksilver> the recent one was http://xkcd.com/297/
10:11:31 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
10:11:34 <drigz> is there a faster way of taking the cartesian product of two sets than conversion to and from lists?
10:11:34 <Toxaris> type Forest a = [Tree a]
10:11:39 <ari> d-bug: That wasn't very civilized
10:12:00 <Toxaris> a forest is like a tree, but without root
10:12:04 <ddarius> data TreeSig x = Empty | Branch x x; type Tree = FreeMonad TreeSig
10:12:10 <shachaf> quicksilver: That one was interesting to think of in the context of Nethack. :-)
10:12:22 <sjanssen> drigz: faster asymptotically?
10:12:25 <shachaf> Toxaris: type Forest a = Tree (Tree a)?
10:12:52 <ddarius> Wasn't this just on the Haskell-cafe mailing list?
10:12:57 <Toxaris> shachaf: hmm... interesting idea, but not what i meant
10:12:59 <shachaf> ddarius: Yes, I think so.
10:13:02 <drigz> sjanssen: is that possible?
10:13:17 <shachaf> ddarius: With the unsafe conversion to Set, and toAscList?
10:13:26 * Toxaris recently read a lot about stuff like Tree (Tree a)
10:13:58 <shachaf> join :: Tree (Tree a) -> Tree a?
10:14:17 <ddarius> shachaf: With my definition of Tree, you get that for free
10:14:30 <sjanssen> drigz: this is the best you can do, O(m*n): fromAscList [(m, n) | m <- toAscList ms, n <- toAscList ns]
10:14:46 <Toxaris> shachaf: consider data Tree a = Tree (Tree (Tree a)) a (Tree (Tree a))
10:15:09 <Toxaris> shachaf: or something like this
10:15:11 <ddarius> Toxaris: I don't think I'd call that a tree.
10:15:15 <shachaf> @go FreeMonad
10:15:15 <drigz> sjanssen: ok, thank. i just found the ML thread
10:15:17 <lambdabot> http://sneezy.cs.nott.ac.uk/darcs/TFP07/FreeMonad.hs
10:15:19 <drigz> *thanks
10:15:28 <Toxaris> it's called ... *looking up paper*
10:15:36 <ihope> It seems I don't have Control.Monad.Cont for some reason.
10:15:38 <quicksilver> drigz: you can hope that the intermediate lists in sjanssen's version aren't actually created
10:15:47 <ddarius> @google "Derek Elkins" site:lambda-the-ultimate.org "free monad"
10:15:48 <lambdabot> http://lambda-the-ultimate.org/node/view/1183
10:15:49 <lambdabot> Title: The Haskell Programmer&#039;s Guide to the IO Monad --- Don&#039;t Panic | Lambd ...
10:15:55 <quicksilver> drigz: I don't think the two individual toAscLists will be created, I'm not sure
10:16:40 <ddarius> I believe I'm missing the Functor instances, but they are easily written.
10:17:35 <shachaf> ddarius: Why do you use that nick?
10:17:53 * shachaf always thinks your last name is "Darius".
10:19:21 <shapr> Free the Theorems!
10:19:21 <anybody> sjanssen: sorry can't i don't have /dev/random
10:22:49 <anybody> sjanssen: oh. what does the $ do?
10:22:57 <sjanssen> @src ($)
10:22:58 <lambdabot> f $ x = f x
10:23:05 <bwx> hello
10:23:24 <shachaf> f $ g x = f (g x)
10:23:34 <shachaf> It lets you get rid of some parentheses.
10:23:36 <sjanssen> anybody: it's a pattern to remove parens, we can write f (g (h x)) as f $ g $ h $ x
10:23:51 <sjanssen> or, even better, f . g . h $ x
10:24:02 <Toxaris> ddarius: given that these things are called nested datatypes, maybe it's a nested tree? my intention was to define the type of complete binary trees, but i missed the base case, i think. is the type of complete trees not a type of trees?
10:24:04 <shachaf> f $ g x $ h y = f (g x (h y)) -- but you should probably not use that.
10:24:20 <Toxaris> ddarius, shachaf: http://citeseer.ist.psu.edu/bird98nested.html
10:24:21 <lambdabot> Title: Nested Datatypes - Bird, Meertens (ResearchIndex)
10:24:54 <Toxaris> ddarius, shachaf: but i forget where i've seen the Tree example
10:26:07 <anybody> sjanssen: why System.Random instead of Random?
10:26:31 <glguy> anybody: didn't you ask that yesterday?
10:27:00 <sjanssen> anybody: Random predates the hierarchical module extension, System.Random is the preferred one now
10:27:12 <anybody> glguy: yeah. but i still don't understand why. because Random worked fine
10:27:27 <glguy> anybody: and I answered this yesterday for you
10:27:41 <glguy> anybody: Random is the Haskell98 compatible module
10:28:26 <anybody> glguy: so that make System.Random what? Haskell Prime?
10:28:36 <Toxaris> anybody: state of the art :)
10:28:43 <glguy> anybody: ^
10:29:00 <anybody> Toxaris: oh. like using <string> instead of <string.h> in c++
10:29:10 <mauke> no.
10:29:21 <mauke> <string> is very different from <string.h>
10:29:34 <DaveCGI12345> <string.h> rox
10:29:47 <anybody> hm. never used string.h
10:29:48 <Toxaris> anybody: it's about different names for the same module
10:30:17 <Toxaris> anybody: there's the old, plain name wich worked back in 1998, and the pretty new name wich will hopefully work in 2018
10:30:35 <SamB_XP> Toxaris: is it identical?
10:30:46 <Toxaris> the modules? I don't know :)
10:30:54 <sjanssen> I think they're the same ATM
10:30:55 <SamB_XP> also, are you hoping for haskell to die?
10:31:15 <Toxaris> SamB_XP: why should I?
10:31:20 <sjanssen> however, System.Random might get new stuff, but Random must stay the same to match the Haskell '98 spec
10:31:23 <SamB_XP> you shouldn't!
10:31:26 <DaveCGI12345> lazy evaluation will never die, it will just evaluate slower!
10:31:44 <shachaf> DaveCGI12345: It won't evaluate at all.
10:31:51 <SamB_XP> but you seemed to hope it would die before 2018
10:32:11 <shachaf> SamB_XP: No, Toxaris said that the name System.Random will last until 2018, hopefully.
10:32:26 <Toxaris> SamB_XP: Yes, it's about the name, not the module or the language
10:32:40 <Toxaris> and I hope Haskell to survive forever, like Cobol and Fortran, of course
10:32:47 <DaveCGI12345> is a functor supposed to be a type holding a function ?
10:32:57 <sjanssen> DaveCGI12345: no
10:33:02 * SamB_XP would kind of expect a new module to replace System.Random in that time
10:33:22 <sjanssen> DaveCGI12345: you're stuck in C++ terminology :)
10:33:23 <Toxaris> How else could I earn my living in 40 years, when everyone else uses some fancy new programming language I'm too dumb to understand
10:33:33 <SamB_XP> Toxaris: hmm. how lively is cobol? is it undead, or is it actually alive and well?
10:33:36 <DaveCGI12345> sjanssen, im confused by the fmap
10:33:40 <DaveCGI12345> fmap :: (a -> b) -> f a -> f b
10:33:56 <shachaf> DaveCGI12345: Take some specific examples.
10:33:59 <shachaf> @src [] fmap
10:34:00 <lambdabot> fmap = map
10:34:00 <sjanssen> DaveCGI12345: Functors support the fmap operation, which is the same as 'map' for lists
10:34:08 <shachaf> @src Maybe fmap
10:34:08 <lambdabot> fmap _ Nothing       = Nothing
10:34:08 <lambdabot> fmap f (Just a)      = Just (f a)
10:34:16 <mauke> do you know std::transform?
10:34:28 <DaveCGI12345> oh
10:34:30 <DaveCGI12345> its for monads
10:34:30 <anybody> mauke: what about it?
10:34:30 <Toxaris> SamB_XP: some weeks ago, I met someone in the train traveling from uni to home. He said: "Oh, you guys study computer science, interesting, i'm a programmer too, I maintain cobol programs"
10:34:32 <bwx> @seen dcoutts
10:34:32 <lambdabot> dcoutts is in #ghc, #gentoo-haskell and #haskell. I last heard dcoutts speak 4h 27m 55s ago.
10:34:39 <shachaf> DaveCGI12345: It's for Functors.
10:34:50 <SamB_XP> Toxaris: yes but is the language changing at all?
10:34:52 <mauke> anybody: fmap is a generalization of std::transform
10:34:57 <sjanssen> DaveCGI12345: not quite -- every Monad can be a Functor, but not every Functor is a Monad
10:35:02 <shachaf> DaveCGI12345: Every Functor is a Monad, but not vice versa.
10:35:12 <DaveCGI12345> ????
10:35:15 <sjanssen> shachaf: you got it backwards :)
10:35:20 <shachaf> Oops.
10:35:21 <SamB_XP> my dad would like to be maintaining cobol programs :-(
10:35:26 <shachaf> You know what I mean. :-)
10:35:28 <shachaf> Sorry.
10:36:00 <pjd> DaveCGI12345: functors are just a slight generalization of mapping over lists
10:36:29 <DaveCGI12345> ah
10:36:36 <DaveCGI12345> it just maps over anything?
10:36:36 <pjd> the idea is that there are many structures out there which are very much like lists, like trees, which you can also map over
10:36:43 <pjd> almost anything :)
10:36:51 <puusorsa> ok another thing.. i somehow got the impression that it should be easyish to find out types etc of everything in some hs file and stuff it includes.. i found Language.Haskell.Parser and .Syntax, but they're not exactly what i had in mind
10:36:52 <DaveCGI12345> ok i got confused by the type class definition then
10:36:57 <shachaf> @instances Functor
10:36:58 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:37:01 <shachaf> @src Functor
10:37:01 <lambdabot> class  Functor f  where
10:37:01 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
10:37:11 <mauke> > fmap sqrt (Just 2)
10:37:12 <lambdabot>  Just 1.4142135623730951
10:37:14 <pjd> DaveCGI12345: probably the easiest example of a non-list functor is Maybe
10:37:25 <Toxaris> SamB_XP: A web search reveals that there are xml and oo modules for cobol, so it seems alive
10:37:25 <shachaf> ((,) a) is not a monad, for example.
10:37:26 <pjd> @src Maybe fmap
10:37:26 <lambdabot> fmap _ Nothing       = Nothing
10:37:26 <lambdabot> fmap f (Just a)      = Just (f a)
10:37:32 <shachaf> (Though it is a comonad.)
10:37:43 <DaveCGI12345> but why oh why did you have to call them functors :-|
10:37:58 <mauke> because it sounds cool
10:38:03 <sjanssen> DaveCGI12345: because that's what category theory calls them
10:38:04 <SamB_XP> DaveCGI12345: CT
10:38:14 <DaveCGI12345> damn C++ again
10:38:15 <mauke> also, Mappable looks stupid
10:38:22 <pjd> DaveCGI12345: if you look at Maybe as a "list" of either length 1 or 0, it should be easy to see how it behaves like list's map
10:38:28 <DaveCGI12345> pjd it makes sense :)
10:39:02 <pjd> DaveCGI12345: the core idea behind functors in general is that fmap obeys certain axioms
10:39:03 <mauke> > (fmap sqrt (/ 10)) 20
10:39:05 <lambdabot>  1.4142135623730951
10:39:16 <DaveCGI12345> does anyone do OO with the haskell type classes + monads ?
10:39:23 <mauke> .oO( just when you thought you understood functors... )
10:39:28 <bwx> pjd: can fmap be used anywhere map is used?
10:39:29 <Toxaris> DaveCGI12345: but it's a dangerous track in so far, that not all Functors are "collection-like thingies"
10:39:35 <shachaf> DaveCGI12345: Yes, fmap is also (.).
10:39:38 <pjd> for example, fmap id x == x
10:39:45 <shachaf> bwx: And in many other places.
10:40:16 <pjd> or, mapping the identify function over some structure is a no-op
10:40:30 <pjd> bwx: probably
10:41:04 <pjd> the other axiom is fmap f . fmap g == fmap (f . g)
10:41:16 <DaveCGI12345> . ? is that like cons?
10:41:18 <mauke> @free fmap
10:41:20 <lambdabot> Expected variable or '.'
10:41:34 <mauke> DaveCGI12345: no, function composition
10:41:39 <pjd> DaveCGI12345: sorry, that's Haskell syntax for function composition
10:41:57 <ari> @src (.)
10:41:57 <lambdabot> (.) f g x = f (g x)
10:42:06 <desp> @hoogle maxIndex
10:42:06 <lambdabot> No matches found
10:42:12 <desp> @hoogle maximumIndex
10:42:12 <lambdabot> No matches found
10:42:15 <pjd> f . g means apply g, then f
10:42:40 <pjd> f (g x) == (f . g) x
10:42:45 <DaveCGI12345> well why wouldnt you want fmap f . fmap g = fmap (f . g) .. it makes perfect sense
10:42:48 <shachaf> fmap (fmap f) (fmap g) == fmap (fmap f g) -- ?
10:42:53 <pjd> DaveCGI12345: right :)
10:42:55 <shachaf> DaveCGI12345: You would.
10:43:06 <chris2> how flexible is lhs2tex? could it be used for other languages too?
10:43:08 <shachaf> DaveCGI12345: It's a guarantee for functors.
10:43:36 <pjd> where you have the above properties, you basically have a functor
10:43:43 <shachaf> chris2: Do other languages understand > or \begin{code}?
10:43:44 <pjd> they're everywhere
10:43:54 <shachaf> @quote functor
10:43:55 <lambdabot> swiert says: Of course! Who can live without covariant homfunctors?
10:43:56 <chris2> shachaf: i can make them
10:44:35 <chris2> i am more concerned about configuring the prettyprinting
10:44:38 <pjd> DaveCGI12345: here's the nifty bit:  monads are functors
10:44:59 <DaveCGI12345> yay
10:45:17 <pjd> they just provide a few additional operations, on top of what functors provide
10:45:30 <pjd> (so they're a special kind of functor)
10:45:35 <shachaf> DaveCGI12345: fmap f m = m >>= return . f -- for any monad.
10:45:43 <ari> pjd: No they aren't, not according to H98 ;)
10:45:47 <pjd> but that's probably getting ahead of myself
10:45:50 <pjd> ari: :P
10:46:33 <DaveCGI12345> return . f ? is that like f(return)
10:47:14 <Toxaris> DaveCGI12345: m >>= return . f   ==   m >>= \x -> return (f x)
10:47:27 <pjd> DaveCGI12345: (return . f) x == return (f x)
10:47:37 <DaveCGI12345> yeah i got confused because you guys were currying!!!
10:47:48 <DaveCGI12345> so i can use the . in haskell programs?
10:47:52 <Toxaris> silently curried in the back
10:47:59 <pjd> yep, it gets used quite a lot
10:48:15 <shachaf> Where was the currying?
10:48:34 <shachaf> (Other than (.) getting two arguments, I mean?)
10:48:43 <Toxaris> DaveCGI12345: You should, it's very cheap, only one pixel, and often helps thinking about your program in a more abstract way
10:49:00 <shachaf> Toxaris: '.' is only one pixel for you?
10:49:12 * shachaf hopes Toxaris uses a low resolution.
10:50:21 <Toxaris> shachaf: what do i know. it
10:50:48 <Toxaris> it's a very small rectangle, that count's as one pixel for my internal image processor
10:50:50 <SamB_XP> looks like 4 pixels to me
10:51:10 <Toxaris> in text mode, it may be 4 pixels, yes
10:51:23 * shachaf resists the urge to zoom in in order to count pixels. :-)
10:51:38 <SamB_XP> shachaf: what, are yours fuzzy?
10:51:39 <mauke> I'd say 5 pixels
10:51:46 <SamB_XP> *5*?
10:51:53 <shachaf> SamB_XP: No, it looks like 4.
10:51:56 <SamB_XP> how do you make it look round with five pixels
10:51:59 <mauke> arranged in a +
10:52:02 <SamB_XP> oh.
10:52:12 <SamB_XP> yeah, I guess I've seen that
10:52:24 <byorgey> 2 pixels on my screen...
10:52:40 <Toxaris> my dot is not round, it's a rectangle
10:53:01 * shachaf has seen the diamondish shape in books.
10:54:31 <ihope> Like Angband on Windows?
10:54:50 <ihope> (Assuming that Angband looks the same on all Windows things.)
10:55:20 <SamB_XP> Toxaris: well a rectangle looks rounder than a square with a smaller square on one side of one of the edges
10:56:34 <DaveCGI12345> kinds are not very kind
10:56:47 <Toxaris> SamB_XP: are you talking about fractal operator signs?
10:56:54 <Ben`> what's the best online introduction to Haskell?
10:57:06 <SamB_XP> Toxaris: hahahah
10:57:24 <SamB_XP> Ben`: hahahaha
10:57:31 <SamB_XP> Ben`: "best"
10:57:51 <SamB_XP> where are you coming from?
10:57:54 <DaveCGI12345> is there a tutorial on kinds somewhere? i dont really get it
10:58:02 <Toxaris> SamB_XP: I think that for the human eye, the picture of a circle (wich is symmetric and regular in nature) should be symmetric and regular too
10:58:16 <SamB_XP> Toxaris: yes. that's what I'm getting at.
10:58:31 <Toxaris> DaveCGI12345: kinds are for types, what types are for values
10:58:31 <SamB_XP> or at least it should be close
10:58:40 <ihope> DaveCGI12345: well, they're the "types" of types and type constructors.
10:58:50 <zvrba> Toxaris: what's the difference between kinds and type classes?
10:58:54 <ihope> Ben`: what languages do you know already?
10:59:15 <zvrba> Toxaris: hmm... the picture of a circle is "regular" only when viewed on a flat surface :)
10:59:19 <Ben`> ihope: Python and PHP
10:59:27 <SamB_XP> zvrba: what shape is your screen?
10:59:31 <Toxaris> zvrba: kinds describe the structure of types, type classes describe allowed operations on types
10:59:44 <zvrba> Toxaris: what is a "structure" of type?
10:59:52 <shachaf> @kind Maybe
10:59:54 <lambdabot> * -> *
10:59:56 <shachaf> @kind Integer
10:59:58 <lambdabot> *
11:00:06 <ihope> Among other things, every type or type constructor has exactly one kind.
11:00:08 <shachaf> Maybe gets a type argument.
11:00:20 <shachaf> @kind Maybe Int
11:00:22 <lambdabot> *
11:00:35 <zvrba> @kind List
11:00:36 <ihope> The kind describes whether it's a type or a constructor, and if it is a constructor, what you apply it to to get a type.
11:00:37 <lambdabot> Not in scope: type constructor or class `List'
11:00:42 <SamB_XP> @kind []
11:00:43 <lambdabot> * -> *
11:00:49 <shachaf> @kind (,)
11:00:51 <lambdabot> * -> * -> *
11:00:51 <SamB_XP> @kind 1
11:00:53 <lambdabot> *
11:00:56 <shachaf> @kind Either
11:00:57 * SamB_XP is such a stinker
11:00:58 <lambdabot> * -> * -> *
11:01:00 <Toxaris> zvrba: where the arrows are
11:01:02 <zvrba> ihope: ah, I get it :)
11:01:15 <SamB_XP> zvrba: you didn't spot what I got for @kind 1, did you ;-P
11:01:24 <zvrba> SamB_XP: no
11:01:24 <DaveCGI12345> > Either 1 2
11:01:25 <lambdabot>   Not in scope: data constructor `Either'
11:01:30 <desp> how would you find a list maximum's index?
11:01:32 <zvrba> SamB_XP: what does '*' mean ?
11:01:40 <SamB_XP> zvrba: it means "type"
11:01:45 <ihope> DaveCGI12345: Either is a type constructor. You apply it to types to get another type.
11:01:51 <shapr> bok zvrba
11:01:54 <DaveCGI12345> so... kinds are like meta types
11:01:59 <ihope> DaveCGI12345: yup.
11:02:12 <SamB_XP> zvrba: or sometimes it means "constraint" on the right of ->
11:02:16 <zvrba> shapr: bok :p
11:02:23 <shapr> eller, hejsan!
11:02:25 <desp> @let maxIndex xs = let m = maximum xs in (fromJust . elemIndex m) xs
11:02:26 <DaveCGI12345> * are non-type constructors types, things with -> are type constructors?
11:02:27 <ihope> @type Left "foo"
11:02:29 <SamB_XP> zvrba: but I've only seen that in error messages
11:02:29 <zvrba> shapr: haha :P
11:02:30 <lambdabot> Defined.
11:02:31 <Toxaris> zvrba: my screen is flat enough.
11:02:32 <lambdabot> forall b. Either [Char] b
11:02:33 <ihope> DaveCGI12345: yup.
11:02:51 <desp> > maxIndex [1..100]
11:02:52 <lambdabot>  99
11:02:55 <DaveCGI12345> so kind inference is still done with unification i assume?
11:02:55 <shachaf> @kind (->)
11:02:57 <lambdabot> ?? -> ? -> *
11:02:59 <zvrba> ihope: if I know C, C++, perl, and have worked with ocaml and SML (made nontrivial algorithmic problems) -> best tutorial? :P
11:03:04 <desp> any better ways to do maxIndex?
11:03:15 <DaveCGI12345> wth is ?? and ?
11:03:32 <SamB_XP> zvrba: a Gentle Introduction?
11:03:37 <zvrba> SamB_XP: ok
11:03:41 <doserj> > maximum (zip [3,2,5,4,6,2,2] [0..] )
11:03:42 <DaveCGI12345> zvrba, i am finding the haskell.org/tutorial very helpful and i know all the languages you pointed out except for perl
11:03:42 <lambdabot>  (6,4)
11:03:44 <CosmicRay> zvrba: YAHT perhaps
11:03:51 <SamB_XP> or possibly "Haskell for C programmers" or whatever it's called...
11:04:05 <desp> zvrba: definitely not the last one, I recommend:
11:04:06 <ihope> DaveCGI12345: they're mostly the same as *.
11:04:08 <zvrba> DaveCGI12345: ah yes, gentle introduction :)
11:04:09 <desp> @where wikibook
11:04:09 <lambdabot> http://en.wikibooks.org/wiki/Haskell
11:04:10 <DaveCGI12345> haskell for c programmers treats you like someone whose not touched functional :)
11:04:18 <DaveCGI12345> no point if you already did sml/ocaml
11:04:25 <SamB_XP> oh. I think I must have used A Gentle Introduction myself...
11:04:27 <desp> zvrba: speaking from similar experience to yours
11:04:32 <ihope> @type 3#
11:04:34 <lambdabot> GHC.Prim.Int#
11:04:39 <ihope> @kind GHC.Prim.Int#
11:04:42 <lambdabot> #
11:04:44 <DaveCGI12345> what is ?? and ? in kinds
11:04:48 <zvrba> desp: ok
11:05:00 <ihope> I think ?? and ? are the same except when you work with unboxed values.
11:05:08 <ihope> And unboxed values are things you generally don't work with.
11:05:23 <SamB_XP> even though I don't really know any other functional languages at all except scheme...
11:05:33 <DaveCGI12345> scheme is functional ?
11:05:46 <SamB_XP> DaveCGI12345: well, more than CL is
11:05:52 <DaveCGI12345> i suppose
11:05:57 <Toxaris> DaveCGI12345: not purely, but to some degree
11:06:02 <zvrba> ok
11:06:05 <DaveCGI12345> ihope boxed and unboxed??
11:06:06 <SamB_XP> there are some almost pure variants
11:06:13 <zvrba> now, a collection of practice problems?
11:06:29 <DaveCGI12345> scheme would be better without mutables :P
11:06:32 <SamB_XP> DaveCGI12345: just forget about unboxed stuff for the moment...
11:06:41 <SamB_XP> DaveCGI12345: try DSSSL ;-P
11:07:01 <ihope> Yeah. Unboxed types are an extension to the language that you ideally don't encounter at all.
11:07:03 <DaveCGI12345> stylesheets?
11:07:05 <desp> zvrba: http://projecteuler.net
11:07:06 <lambdabot> Title: Project Euler
11:07:17 <desp> zvrba: these work great with Haskell
11:07:36 <zvrba> hehe, used that one for SML
11:07:46 <zvrba> boring to go through them again >:
11:07:48 <SamB_XP> ihope: ?? contains boxed and unboxed types, ? contains those along with unboxed tuple types
11:07:50 <desp> aw
11:08:15 <zvrba> and they've gotten harder recently so I gave up on them
11:08:19 <SamB_XP> DaveCGI12345: the language is basically scheme without mutation
11:08:23 <ihope> That is, every unboxed type has a corresponding boxed type which ideally works exactly the same way.
11:08:53 <SamB_XP> ihope: that's a bit bold of an assertion
11:09:09 <DaveCGI12345> hmm project euler
11:09:16 <DaveCGI12345> sounds like something i should spend time on instead of playing games
11:09:26 <SamB_XP> eh?
11:09:30 <desp> @pl maximumIndex xs = (fromJust . elemIndex (maximum xs)) xs
11:09:30 <zvrba> desp: oh, wikibook is nice, has even some exercises :)
11:09:31 <lambdabot> maximumIndex = (fromJust .) =<< elemIndex . maximum
11:09:32 <DaveCGI12345> can you use haskell for that site?
11:09:33 <SamB_XP> I think it might be better to do some of each
11:09:43 <SamB_XP> DaveCGI12345: you can use a pencil and paper if you want
11:09:58 <DaveCGI12345> oh no thanks
11:10:03 <SamB_XP> it's even one of the choices for the primary language
11:10:06 <DaveCGI12345> well not to implement anyways*
11:10:14 <zvrba> desp: can I find that wikibook in PDF somewhere?
11:10:17 <desp> DaveCGI12345: some of the problems are trivial enough
11:10:21 <Toxaris> DaveCGI12345: another nice alternative to playing games is http://www.spoj.pl/
11:10:23 <desp> zvrba: probably not
11:10:24 <lambdabot> Title: Sphere Online Judge (SPOJ)
11:10:37 <desp> zvrba: you can print HTML to PDF :P
11:10:39 <zvrba> desp: yes
11:10:39 <SamB_XP> a lot of the problems, if you think about them enough, are apparantly not hard to do with pencil and paper
11:10:45 <DaveCGI12345> hmm some of those problems are too mathy
11:10:49 <zvrba> desp: http://en.wikibooks.org/wiki/Haskell/Print_version
11:10:52 <SamB_XP> DaveCGI12345: some?
11:10:52 <zvrba> but takes ages to load
11:10:59 <SamB_XP> DaveCGI12345: tell me one that isn't too mathy
11:11:26 <DaveCGI12345> Determinining the most efficient network doesnt sound too mathy
11:11:32 <DaveCGI12345> http://projecteuler.net/index.php?section=view&id=107
11:11:33 <lambdabot> Title: Project Euler
11:11:33 <SamB_XP> hah
11:11:47 <DaveCGI12345> i can reduce it to max flow
11:12:11 <SamB_XP> DaveCGI12345: that's mathy!
11:12:15 <desp> SPOJ is also good
11:12:24 <DaveCGI12345> well to me algorithms arent as mathy as find unique solutions for 1/x + 1/y = 1/n
11:12:27 <desp> and there are other ACM problem repositories on the web
11:12:45 <DaveCGI12345> with which you are pretty screwed unless you have the math prerequisites
11:12:46 <desp> then, there are the ICFP contests :)
11:12:53 <zvrba> desp: unfortunately, they accept solutions only in C/C++/Java/C#
11:12:59 <zvrba> desp: and there are no correct answers :(
11:13:06 <desp> zvrba: who does, SPOJ? no way
11:13:10 <DaveCGI12345> 	
11:13:10 <DaveCGI12345> Finding the maximum remainder when (a − 1^n + (a + 1)^n is divided by a^2.
11:13:12 <SamB_XP> the ICFP contests have always been fairly accomodating
11:13:13 <zvrba> desp: ACM competitions
11:13:16 <zvrba> desp: SPOJ?
11:13:24 <desp> @where SPOJ
11:13:25 <lambdabot> I know nothing about spoj.
11:13:30 <zvrba> DaveCGI12345: hmm,i think I solved that one
11:13:36 <DaveCGI12345> i wish i knew about acm competitions when i was in high school
11:13:37 <desp> @where+ SPOJ http://www.spoj.pl/
11:13:37 <zvrba> DaveCGI12345: used Mathematica, Simplify[] :P
11:13:37 <lambdabot> Done.
11:13:51 <SamB_XP> of late, they do this by having you run your own programs ;-)
11:13:53 <zvrba> desp: eh, nice. thx :)
11:14:01 <DaveCGI12345> zwrba: its just a damn math problem, nothing to do with computer science at all heh
11:14:02 <zvrba> desp: i was thinking of acm.uva.es
11:14:04 <Toxaris> SPOJ accepts a *lot* of languages
11:14:06 <sorear> @messages
11:14:06 <lambdabot> dmwit said 5h 59m 6s ago: Oh, good! Also, your perseverence is slightly creepy.
11:14:10 <zvrba> DaveCGI12345: well..
11:14:12 <desp> zvrba: ACM competitions aren't what I had in mind; there are other sites that just collect the problems and accept solutions
11:14:12 <SamB_XP> DaveCGI12345: on the contrary
11:14:26 <DaveCGI12345> ok maybe getting the solution *fast* is a cs problem
11:14:31 <SamB_XP> DaveCGI12345: solving math problems has very much to do with CS ;-)
11:14:39 <Toxaris> like brainf*ck, fortran, ... and Haskell, of course
11:14:50 <desp> Toxaris: we like different languages in Poland :)
11:15:11 <DaveCGI12345> from what i've seen in math they teach you an easy to understand algorithm to solve problems (fast for humans), and in CS they take thos algorithms and rewrite them so the computer can solve the problems fast
11:15:23 <DaveCGI12345> unfortunately the understanding of the latter usually requires understanding of the former
11:15:47 <SamB_XP> in math they teach you more than algorithms
11:15:53 <Toxaris> desp: always open-minded in all directions?
11:16:09 <DaveCGI12345> well i was talking about math algos vs cs algos
11:16:20 <SamB_XP> they teach you theorems and so on, too
11:16:27 <DaveCGI12345> not math vs cs :)
11:16:33 <zvrba> desp: thx for the link
11:16:37 <zvrba> desp: nice collection :)
11:16:40 <SamB_XP> of course, that's true in CS too
11:16:47 <desp> Toxaris: well, in my department there are courses in OCaml, Haskell and Erlang
11:16:57 <DaveCGI12345> dang you guys have Erlang courses? you suck
11:17:03 <desp> SML was also used for the intro course to programming
11:17:11 <desp> DaveCGI12345: ?
11:17:11 <DaveCGI12345> desp: wow your school is hardcore.
11:17:33 <desp> of course, more mainstream stuff as well
11:18:09 <Toxaris> DaveCGI12345: at my uni, the math people are responsible for scientific computing, numerical algorithms, ...  so we have fast math algos, too
11:18:15 <DaveCGI12345> the only problem with teaching functional languages is if you do it before the students have appreciation for the features they will just complain about the langauges being useless in the real world
11:18:17 <doserj> desp: maxIndex = snd . maximum . flip zip [0..]
11:18:18 <zvrba> desp: i like SML
11:18:31 <zvrba> desp: how do you compare it with haskell?
11:18:33 <desp> doserj: ahhh.
11:18:37 <desp> doserj++
11:18:53 <SamB_XP> DaveCGI12345: it depends
11:19:00 <DaveCGI12345> so while you could teach something like SML right away to students they would just get confused about the details
11:19:04 <desp> zvrba: I liked SML, but I preferred OCaml syntax. and so far, I prefer Haskell to OCaml.
11:19:15 <SamB_XP> DaveCGI12345: if they've been exposed to imperative programming, they might think that
11:19:18 <Toxaris> we have Scheme for half a term for the freshmen, then change to java and for most students never back :(
11:19:26 <desp> DaveCGI12345: our school likes to weed out the students that don't like academic approaches ;)
11:19:36 <DaveCGI12345> in my school they taught Ocaml in intro to language design, and by then i coudl appreciate pretty much everything that i learned there that i hadnt used before (closures, tco, lambdas, etc)
11:19:43 <zvrba> desp: haha, i like SML syntax better than Ocaml :)
11:19:50 <desp> zvrba :)
11:20:00 <zvrba> SML is block-structured
11:20:02 <DaveCGI12345> of course they taught a little Lambda Calculus in that class too which really helps
11:20:03 <babu> #erlang
11:20:05 <zvrba> I hate Ocaml's bunch of lets
11:20:11 <Toxaris> DaveCGI12345: same here, scheme again for language design, with some haskell for monad-based interpreters
11:20:15 <desp> zvrba: Haskell is much more succint than either one of those
11:20:26 <DaveCGI12345> desp: nothing wrong with academic approaches i just saying if i learned ocaml as my first langauge i wouldnt get most of its niceties
11:20:28 <zvrba> ok
11:20:48 <DaveCGI12345> Toxaris, we're using haskell in my 2nd semester prog. languages class, i cant wait :)
11:20:56 <desp> DaveCGI12345: well...I don't think most people go to study CS without having learned at least one language before
11:21:05 <DaveCGI12345> desp, lol you are wrong
11:21:10 <DaveCGI12345> there's a ton of people whove never touched programming
11:21:21 <desp> DaveCGI12345: I was taught Pascal in grade school ;)
11:21:43 <SamB_XP> why would they go into CS?
11:22:06 <desp> DaveCGI12345: and practically every high school here has elements of programming
11:22:08 <DaveCGI12345> btw while we're on the topic of erlang, does haskell have support for concurrency ala the actor model?
11:22:11 <byorgey> SamB_XP: money?
11:22:18 <byorgey> SamB_XP: parental expectations?
11:22:30 <desp> byorgey: I think those people go to med school ;)
11:22:36 <DaveCGI12345> SamB_XP, because CS is growing the fastest for the salaries or something
11:22:38 <sjanssen> DaveCGI12345: not exactly, but you could probably build it as a library if you want
11:22:41 <SamB_XP> money is a terrible reason to go into CS, and parents shouldn't expect people who aren't already heavy into that kind of thing to go into it then ;-)
11:22:47 <byorgey> desp: or law school!
11:22:55 <desp> yeah
11:23:02 <sjanssen> DaveCGI12345: STM is the state of the art in Haskell -- it's much different, but still very neat
11:23:05 <DaveCGI12345> sjanssen, well sure.. anythign can be a library but sugaring is nice imo
11:23:15 <Toxaris> SamB_XP: in germany, you need top grades for law, med and stuff but not for CS
11:23:28 <DaveCGI12345> sjanssen, shared transactional memory?
11:23:38 <SamB_XP> oh
11:23:39 <sjanssen> DaveCGI12345: software transactional memory
11:23:42 <SamB_XP> Toxaris: so?
11:24:00 <SamB_XP> CS should be persued out of love, or at least starting before college...
11:24:10 <Toxaris> SamB_XP: so even if people would like to go to med shool, they can't because of their bad grades and choose cs instead
11:24:23 <DaveCGI12345> sjanssen, interesting. i will need to look into that, although i am guessing that will have problems outside of 1 computer?
11:24:26 <crazy_coder> :) Ideal situation for me
11:24:42 <pjd> DaveCGI12345: http://haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism might be of interest
11:24:44 <lambdabot> Title: Applications and libraries/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/2u95za
11:24:47 <sjanssen> DaveCGI12345: correct, STM isn't really set up for distributed applications
11:24:49 <Toxaris> SamB_XP: I don't think so. uni is for learning things, not for already have learned things
11:24:54 <DaveCGI12345> med school is after you get a BS, CS is for your BS
11:25:21 <DaveCGI12345> sjanssen, well that sounds like a pain in the ass, since DSM is probably the future
11:25:23 * Toxaris is not able to translate all this grades into familiar words :(
11:25:41 <sjanssen> DaveCGI12345: Distributed ...?
11:25:47 <DaveCGI12345> sjanssen, distributed shared memory
11:26:14 <sjanssen> DaveCGI12345: STM might work with distributed shared memory, I'm really not an expert in this area
11:26:32 <SamB_XP> sjanssen: but that's a horrible model
11:26:32 <Toxaris> SamB_XP: at least in germany, it may well be that there was no CS offered before uni at your school. so should these people have no right to study CS? I don't think so. actually, we have not enough CS students, not too many, so we try to encourage people to look into CS
11:26:55 <SamB_XP> hmm.
11:26:58 <DaveCGI12345> well dont listen to me, i dont know anything about parallelism except basic semaphores and distributed systems. which leaves me not knowing anything useful like lockfree algos for same-computer parallelisms
11:27:10 <SamB_XP> Toxaris: what? does nobody have any initiative?
11:27:32 <Toxaris> SamB_XP: and a strong background in math may be worth the same as a strong background in geekiness
11:27:37 <SamB_XP> hmm.
11:27:43 <SamB_XP> point!
11:27:58 <SamB_XP> I thought you got geekiness doing math anyway
11:28:06 <Toxaris> it's a different kind of geekiness
11:28:12 <SamB_XP> yeah
11:28:13 <Toxaris> (on wich also applies to girls)
11:28:13 <DaveCGI12345> strong background in math for cs is nice, but still you need real programming experience to appreciate things like tco :)
11:28:30 <Toxaris> DaveCGI12345: tco?
11:28:35 <DaveCGI12345> tail call optim
11:28:55 <Toxaris> DaveCGI12345: you can ignore it :) and concentrate on some other branch of cs
11:29:13 <DaveCGI12345> well i thouht we were still talking about teaching (semi?)functional languages to first year cs students :)
11:30:06 <Toxaris> DaveCGI12345: at first year, your programs don't have to be efficient, it's enough if they are correct and do something usefull
11:30:29 <Toxaris> in second year, you have enough programming background from first year to understand what happens
11:30:35 <SamB_XP> Toxaris: is overflowing the stack considered useful?
11:30:43 <DaveCGI12345> recursion is easier to understand if you have math background though i suppose
11:31:01 <DaveCGI12345> so a math class with recursion should be a prereq
11:31:37 <Toxaris> it's thought in the very beginning of math classes, isn't it? the structure of the natural numbers, proof by induction, ...
11:31:37 <SamB_XP> btw, do you know how to put ten elephants in the fridge?
11:31:52 <sjanssen> carefully
11:32:04 <sjanssen> get a really big fridge?
11:32:04 <DaveCGI12345> Toxaris, they dont teach that in high school usually, i think you have to take Discrete Math to get any of that
11:32:16 <anybody> open the door. put them in?
11:32:22 <SamB_XP> 1. put an elephant in the fridge
11:32:23 <DaveCGI12345> and the discrete math teacher at my uni just happens to be very bad
11:32:33 <SamB_XP> 2. put 9 elephants in the fridge
11:32:52 <DaveCGI12345> i only had 1 professor so far that didnt teach a senior-level class that i liked
11:32:55 <Toxaris> DaveCGI12345: I meant at first uni year, parallel to learn recursion in programming
11:33:21 <olathe> It's a law of universities: all discrete math professors in the CS department must be horrid.
11:33:22 <DaveCGI12345> sure as long as you cover recursion in the math class the same week or before you start doing recursion in programming clas
11:33:52 <DaveCGI12345> my discrete math in high school was great , but she only covered 30-40% of discrete math we learned in uni
11:33:57 <Toxaris> I learned (1) logic in math (2) logic in hardware (3) induction in math and (4) recursion in programming all parallel in the first weeks of my first cs year
11:34:04 <sjanssen> olathe: my discrete math prof. was pretty good (he was a member of the CS faculty)
11:34:13 <olathe> sjanssen: Quit breaking the law !
11:34:28 <Toxaris> to understand recursion, you first have to understand recursion
11:34:31 <DaveCGI12345> lol
11:34:54 <SamB_XP> I thought it was more like this:
11:35:02 <SamB_XP> to understand _|_, you must understand _|_
11:35:03 <DaveCGI12345> my discrete math teacher started teaching data structures after the data structures professor resigned.. and then that class went down the hill too
11:35:12 <anybody> question: if i have a big state record and i want to change a single element in it and all the rest stays the same, i have to make a new one from the old with only that tiny little bit changed. does haskell internally now construct the new state completely although i only changed a tiny little bit or does it not (because its lazy)?
11:35:20 <DaveCGI12345> SamB_XP what's _|_ ?
11:35:45 <shachaf> To understand _|_, ERROR: UNDEFINED
11:35:55 <SamB_XP> > let bottom = bottom in bottom
11:35:57 <lambdabot>  Exception: <<loop>>
11:36:11 <byorgey> anybody: it's implementation-dependent, but probably there is a lot of sharing of old values going on
11:36:12 <DaveCGI12345> hmm
11:36:19 <dylan> DaveCGI12345: _|_ is bottom
11:36:21 <DaveCGI12345> bottom binds to the "let bottom" ?
11:36:24 <DaveCGI12345> there's no letrec ?
11:36:26 <byorgey> anybody: i.e. it's going to be pretty efficient
11:36:35 <dylan> DaveCGI12345: let is letrec
11:36:37 <shachaf> DaveCGI12345: Every let is a letrec in Haskell.
11:36:39 <DaveCGI12345> ok
11:36:41 <SamB_XP> DaveCGI12345: there is no "let"
11:36:44 <SamB_XP> ;-P
11:36:45 <byorgey> anybody: it doesn't necessarily have anything to do with laziness.
11:36:47 <DaveCGI12345> what if you wanted a non let-rec let?
11:36:59 <shachaf> DaveCGI12345: Why?
11:37:04 <DaveCGI12345> why not
11:37:05 <mrd> do x <- return val ...
11:37:22 <shachaf> DaveCGI12345: Just don't refer to yourself.
11:37:25 <anybody> byorgey: i hope so (efficiency). i'm trying to make a little game in order to learn haskell and for that i will have a game state on which i need to operate frequently
11:37:27 <shachaf> > let x = 5 in x
11:37:29 <lambdabot>  5
11:37:36 <mrd> > let x = 5:x in x
11:37:37 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
11:37:42 <shachaf> > fix (5:)
11:37:43 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
11:37:53 <DaveCGI12345> anybody: sounds like you need a monad
11:38:04 <anybody> DaveCGI12345: yup. State  monade
11:38:11 <anybody> s/ade/ad/
11:38:25 <shachaf> DaveCGI12345: But anybody is worrying about efficiency.
11:38:33 <DaveCGI12345> dont worry, if you recalculate part of the state without using the previous part of the state, itll just throw away the stuff you dont need
11:40:33 <DaveCGI12345> what is this pattern matching "divergence"?
11:40:33 <DaveCGI12345> does Haskell not do back-tracking when a pattern fails/
11:40:57 <shachaf> DaveCGI12345: What do you mean?
11:41:01 <shachaf> DaveCGI12345: Why?
11:41:18 <DaveCGI12345> why wat
11:41:22 <DaveCGI12345> http://www.haskell.org/tutorial/patterns.html
11:41:23 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
11:41:47 <shachaf> DaveCGI12345: Why would it do back-tracking?
11:41:55 <DaveCGI12345> because thats how DFAs work
11:42:16 <SamB_XP> DFAs don't need to do backtracking...
11:42:23 <DaveCGI12345> because they magically guess
11:42:30 <DaveCGI12345> LL(k) parsers would need to backtrack though
11:42:32 <SamB_XP> that's NDFAs
11:42:33 <byorgey> DaveCGI12345: I think you mean NFAs.
11:42:41 <DaveCGI12345> yaeh well NFAs are equivalent to DFAs
11:42:57 <SamB_XP> hmm?
11:43:00 <DaveCGI12345> ok how come i cant just type in "myfunc arg = ...." in WinHugs
11:43:06 <DaveCGI12345> Hugs> mtake 0 _ = []
11:43:06 <DaveCGI12345> ERROR - Syntax error in input (unexpected `=')
11:43:11 <byorgey> DaveCGI12345: either a pattern matches, or it doesn't.  If it doesn't, there's nothing to backtrack to.
11:43:27 <SamB_XP> DaveCGI12345: you can't do that in GHCi either
11:43:32 <SamB_XP> you need let in ghci, anyway
11:43:37 <anybody> > take 1 1
11:43:38 <lambdabot>   add an instance declaration for (Num [a])
11:43:41 <SamB_XP> and in hugs you can't do that at all
11:43:46 <shachaf> > take 1 [1]
11:43:47 <lambdabot>  [1]
11:43:53 <DaveCGI12345> all the examples in the site dont use "let"
11:44:03 <shachaf> DaveCGI12345: They aren't in GHCi/Hugs.
11:44:07 <DaveCGI12345> byorgey, so what is all the "divergence" all about
11:44:09 <desp> SamB_XP: can you do a multiple-pattern-match function in GHCi?
11:44:11 <shachaf> DaveCGI12345: It's different in a REPL.
11:44:12 <anybody> > take 2 [1]
11:44:13 <lambdabot>  [1]
11:44:17 <anybody> > take 12 [1]
11:44:19 <byorgey> DaveCGI12345: oh, I see what you are asking
11:44:19 <lambdabot>  [1]
11:44:28 <anybody> > take 12 [1,1]
11:44:29 <lambdabot>  [1,1]
11:44:38 <SamB_XP> desp: of course
11:44:39 <shachaf> @src take -- isn't this simpler?
11:44:39 <lambdabot> Source not found. My mind is going. I can feel it.
11:44:41 <shachaf> @src take
11:44:41 <lambdabot> take n _      | n <= 0 =  []
11:44:41 <lambdabot> take _ []              =  []
11:44:41 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
11:44:44 <SamB_XP> you just have to write it on one line
11:45:02 <desp> DaveCGI12345: the proper way to work with those examples is, write them in a file, "ghci file.hs", and ":r" in ghci after making changes
11:45:11 <shachaf> desp: Use semicolons.
11:45:15 <desp> ah.
11:45:23 <byorgey> DaveCGI12345: it diverges if it tries to match an argument which is (e.g.) infinite, or generates some sort of error
11:45:24 <anybody> > take 1 [1,1]
11:45:26 <lambdabot>  [1]
11:45:27 <shachaf> > let { f 1 = 5; f 2 = 6 } in f 2
11:45:29 <lambdabot>  6
11:45:36 <desp> Haskell interpretes could be a little more friendly.
11:45:42 <desp> s/tes/ters/
11:45:54 <shachaf> desp: Imagine you were in do-notation for ghci.
11:46:01 <byorgey> DaveCGI12345: for example, consider the function f n = n + 1.
11:46:19 <byorgey> DaveCGI12345: if you said f 0, the pattern-match would succeed, and bind 0 to n.
11:46:30 <desp> shachaf: I write my dos without semicolons, thankyou ;)
11:46:32 <byorgey> DaveCGI12345: if you said f (sum [1..]), the pattern match would diverge
11:46:58 <shachaf> desp: Yes, but you don't write:
11:47:04 <shachaf> do let f 0 = 1
11:47:09 <shachaf>    let f 1 = 2
11:47:19 <shachaf> desp: Right?
11:47:38 <desp> yes, that's why after the first let the interpreter should use a heuristic to recognize that more input will follow
11:47:53 <SamB_XP> desp that'd be hard
11:48:04 <SamB_XP> it'd have to read your mind
11:48:13 <shachaf> SamB_XP: Doesn't it do that already?
11:48:18 <SamB_XP> no
11:48:26 <SamB_XP> your mind is too confusing
11:48:42 <desp> SamB_XP: if the pattern match is incomplete or there are unresolved symbols, then default to receiving more input
11:48:51 <shachaf> > read mind
11:48:52 <lambdabot>  Couldn't match expected type `String'
11:48:55 <desp> SamB_XP: abort input by pressing ESC, for instance
11:49:08 <SamB_XP> that'd be kind of annoying
11:49:10 <Nucleo_> if I have a function f(n) which s defined as a recurrence relation, is there a general way to memoize the results?
11:49:12 <shachaf> > read mind
11:49:12 <desp> or by finishing your definition
11:49:13 <lambdabot>  42
11:49:26 <desp> @where memoization
11:49:26 <lambdabot> I know nothing about memoization.
11:49:33 <desp> @where memoisation
11:49:33 <lambdabot> I know nothing about memoisation.
11:49:41 <desp> argh I swear I set it myself
11:49:42 <shachaf> What about waiting for more symbols if the line ends with a ';' (or a '\\')?
11:49:50 <shachaf> s/symbols/input/
11:50:07 <desp> shachaf: doesn't that also require some {}s?
11:50:25 <shachaf> > let f 1 = 2; f 2 = 3 in f 5
11:50:26 <lambdabot>   Non-exhaustive patterns in function f
11:50:41 <sjanssen_> Nucleo_: there's a nice array based technique if the domain of f is sufficiently small
11:50:45 <shachaf> Oops, I should've given it exhaustive patterns.
11:51:00 <DaveCGI12344> ok i got dropped from the wireless
11:51:31 <DaveCGI12344> how are you supposed to define functions in hugs, and what is all this pattern divergence all about
11:51:32 <shachaf> DaveCGI12344: That's why you don't run your IRC client locally. :-)
11:51:40 <shachaf> DaveCGI12344: let f x = x + 1
11:51:45 <Nucleo_> sjanssen_: ahhh. Well, I'm actually just trying to implement the Partition function...
11:51:45 <shachaf> DaveCGI12344: In ghci, at least.
11:51:51 <byorgey> DaveCGI12344: did you get my chats, or were you already disconnected?
11:51:59 <DaveCGI12344> byorgey, i was alread disconnected
11:52:01 <hpaste>  desp annotated "IOMap.hs" with "Memo.hs" at http://hpaste.org/2164#a1
11:52:02 <Nucleo_> sjanssen_: and the recurrence relation seemed to be the least painful, but rather slow without memoizing.
11:52:08 <DaveCGI12344> byorgey, right after u said u saw what i was saying
11:52:11 <desp> Nucleo_: ^
11:52:22 <sjanssen_> DaveCGI1234: consider "case Nothing of (Just x) -> x"
11:52:23 <byorgey> DaveCGI12344: read the logs: http://tunes.org/~nef/logs/haskell/
11:52:24 <lambdabot> Title: Index of /~nef/logs/haskell
11:52:29 <Nucleo_> desp: thank you
11:52:31 <desp> Nucleo_: that might not be the best approach, though
11:52:47 <DaveCGI12344> oh come on, my internet is taking forever to load that index
11:53:05 <byorgey> DaveCGI12344: ok, I'll give you the direct link...
11:53:11 <DaveCGI12344> i got it now
11:53:15 <DaveCGI12344> and its taking forever to load the log
11:53:15 <byorgey> ok
11:53:17 <shachaf> DaveCGI12344: Sorry. That server is on *MY* Integer.
11:53:22 <byorgey> well, it's large =)
11:53:25 <shachaf> s/get/rnet/
11:53:26 <sjanssen_> DaveCGI12344: that diverges because 'Nothing' does not match with any of the case alternatives 'Just x'
11:53:28 <DaveCGI12344> doesnt matter what server is, my connection just sucks
11:53:48 <byorgey> sjanssen_: that's not the sense in which "diverge" is used in the tutorial DaveCGI12344 is reading
11:53:54 <hpaste>  desp annotated "IOMap.hs" with "fibs" at http://hpaste.org/2164#a2
11:53:58 <desp> Nucleo_: ^
11:54:10 <byorgey> sjanssen_: it makes a distinction between "succeed", "fail", and "diverge"
11:54:22 <byorgey> sjanssen_: i.e. diverge is when you try to pattern-match against _|_
11:54:29 <sjanssen_> byorgey: oh.  Haskell doesn't have these distinctions
11:54:31 <DaveCGI12344> desp i dont have ghci only hugs
11:54:39 <Nucleo_> desp: excellent! thank you
11:54:43 <Nucleo_> @src memo
11:54:43 <lambdabot> Source not found. stty: unknown mode: doofus
11:54:46 <byorgey> sjanssen_: well, yeah =)
11:54:48 <shachaf> DaveCGI12344: And hugs doesn't work with let?
11:54:58 <desp> Nucleo_: that's from the Module in the paste
11:55:16 <desp> DaveCGI12344: you can :reload a file in hugs just as well
11:55:20 <Nucleo_> desp: ahh, k
11:55:26 <Nucleo_> much appreciated
11:55:30 <desp> np
11:55:39 <desp> there's a link to a SPJ paper about this in the header
11:55:41 <byorgey> shachaf: I don't think hugs lets you create new bindings at the prompt like ghci does (?)
11:55:55 * shachaf has never really used hugs.
11:56:00 <desp> Nucleo_: he actually implements it using StableNames, but that approach doesn't work for memoizing simple values
11:56:03 <DaveCGI12344> i cant get hugs to let me make a function
11:56:08 <shachaf> byorgey: That's surprising, though.
11:56:12 <DaveCGI12344> byorgey, ok diverge is for pattern matching against infinite elments?
11:56:16 <shachaf> DaveCGI12344: Use ghci. :-)
11:56:26 <byorgey> DaveCGI12344: or with some sort of error, yes
11:56:33 <DaveCGI12344> some sort of error like what
11:56:53 <byorgey> DaveCGI12344: e.g. division by zero
11:57:03 <DaveCGI12344> in the boolean guard?
11:57:10 <desp> Nucleo_: there's also http://www.cs.utexas.edu/~wcook/Drafts/2006/MemoMixins.pdf
11:57:15 <byorgey> DaveCGI12344: suppose you define f n = n + 1
11:57:52 <byorgey> DaveCGI12344: then f (1 / 0) will try to pattern-match n against (1/0), but in order to do that it has to evaluate (1/0)... so it "diverges"
11:57:57 <Nucleo_> handy!
11:58:13 <byorgey> DaveCGI12344: also f (sum [1..])
11:58:21 <DaveCGI12344> why do you have to evaluate (1/0)?
11:58:31 <DaveCGI12344> pattern matching x against x shouldnt need evaluation
11:58:37 <ski> the '(+)' is strict in both arguments
11:58:38 <shachaf> > 1 / 0
11:58:46 <lambdabot>  Infinity
11:58:50 <shachaf> Do you mean 1 `div` 0?
11:58:51 <ski> > (1/0) + 1
11:58:52 <lambdabot>  Infinity
11:58:53 <byorgey> DaveCGI12344: well, hm, I guess I'm leaving out some details... =P
11:59:03 <byorgey> DaveCGI12344: you're right
11:59:08 <ski> > (1 `div` 0) + 1
11:59:09 <hpaste>  sjanssen pasted "Okaski's memoizing fixpoint" at http://hpaste.org/2165
11:59:09 <lambdabot>  Exception: divide by zero
11:59:17 <sjanssen_> Nucleo_: http://hpaste.org/2165
11:59:55 <byorgey> DaveCGI12344: it's hard to come up with good examples.
12:00:44 <ihope> > 0 * undefined
12:00:45 <lambdabot>  Undefined
12:01:36 <DaveCGI12344> hmm what is this _|_ i keep seeing
12:01:36 <ihope> Okay. Control.Monad.Cont is supposed to exist, isn't it?
12:01:47 <ihope> "Could not find module `Control.Monad.Cont'"
12:01:49 <byorgey> DaveCGI12344: that's "bottom"
12:01:55 <DaveCGI12344> bottom what?
12:02:02 <ihope> DaveCGI12344: it represents things like undefined and fix id.
12:02:08 <byorgey> DaveCGI12344: think of it as the all-purpose "undefined/infinite" value.
12:02:15 <sjanssen_> ihope: yes.  Are you sure you've got mtl installed?
12:02:33 <byorgey> DaveCGI12344: for example, last [1..].
12:02:43 <ihope> sjanssen_: no, I'm not.
12:02:45 <ski> the bottom of the definedness partial order for the type in question
12:03:10 <byorgey> DaveCGI12344: in other words, bottom is the "least defined" value
12:03:25 <ihope> sjanssen_: does apt-get install ghc not install mtl?
12:03:31 <DaveCGI12344> least defined?
12:03:33 <sjanssen_> ihope: not anymore
12:03:49 <ihope> sjanssen_: oh. How can I add packages, then?
12:04:01 <sjanssen_> ihope: I'm sure debian has an mtl package
12:04:06 <pjd> DaveCGI12344: it's in the context of type lattices
12:04:07 <DaveCGI12344> oh its going to take forever to download ghci
12:04:10 <byorgey> DaveCGI12344: in Haskell, _|_ can be written as "undefined"
12:04:15 <byorgey> > undefined + 1
12:04:17 <lambdabot>  Undefined
12:04:19 <DaveCGI12344> pjd: type lattices?
12:04:27 <pjd> "top" is the type that includes everything, "bottom" is the type that includes nothing
12:04:31 <ihope> Yeah, all _|_ is essentially the same as undefined.
12:04:32 <byorgey> > undefined == undefined
12:04:33 <lambdabot>  Undefined
12:04:38 <Saizan> ihope: apt-get install libghc6-mtl-dev, or just libghc6-*
12:04:46 <ihope> Saizan: thanks.
12:05:06 <DaveCGI12344> > Infinity - Infinity
12:05:07 <lambdabot>   Not in scope: data constructor `Infinity'
12:05:07 <ski> in e.g. '(Bool,())' the values are '_|_','(_|_,_|_)','(_|_,())'.'(False,_|_)'.'(True,_|_)','(False,())','(True,())'
12:05:24 <byorgey> DaveCGI12344: do you know what a partial order is?
12:05:32 <DaveCGI12344> byorgey, dont think so
12:05:33 <ihope> > let infinity = read "Infinity" :: Double in infinity - infinity
12:05:34 <lambdabot>  0.0
12:06:04 <ski> with '_|_ =< a' for all 'a', and '(a0,b0) =< (a1,b1)' exactly when 'a0 =< a1' and 'b0 =< b1'
12:06:09 <pjd> DaveCGI12344: http://en.wikipedia.org/wiki/Lattice_%28order%29
12:06:11 <lambdabot> Title: Lattice (order) - Wikipedia, the free encyclopedia
12:06:26 <byorgey> DaveCGI12344: it's a set of values, together with a relation <=, but not all values can be compared with <=
12:06:41 <sjanssen_> I don't think any of this is needed to understand _|_
12:06:55 <mrd> is it possible to serialize (in some way) values satisfying Typeable, or do you need more?
12:07:01 <DaveCGI12344> byorgey, ok
12:07:02 <desegnis> Is there some standard concerning infinte floating-point numbers?
12:07:21 <byorgey> DaveCGI12344: sjanssen_ speaks truth =)
12:07:22 <desegnis> infinity - infinity = 0 just looks so stupid to me
12:07:32 <pjd> yeah, it just means "no value"
12:07:45 <ihope> desegnis: some IEEE standard, I think.
12:07:54 <sjanssen_> DaveCGI12344: _|_ is the value of programs that can't possibly go right -- examples include pattern match failure, calls to undefined/error, and non-termination
12:08:04 <byorgey> infinity - infinity = 0?
12:08:11 <arcatan> no
12:08:13 <Saizan> > (1/0) - (1/0)
12:08:15 <lambdabot>  0.0
12:08:18 <desegnis> ihope, hm
12:08:21 <byorgey> augh!
12:08:26 <desegnis> byorgey, right
12:08:28 <DaveCGI12344> sjanssen_, aha... does haskell not have exceptions ?
12:08:56 <ihope> DaveCGI12344: I think GHC does use exceptions in those cases, but I'm not sure.
12:09:08 <cjeris> > (1/0) - (-1/0)
12:09:09 <lambdabot>  Infinity
12:09:10 <sjanssen_> DaveCGI12344: Haskell does have exceptions, but they're only raised and caught in IO code
12:09:23 <ihope> @type raise
12:09:25 <lambdabot> Not in scope: `raise'
12:09:33 <sjanssen_> s/raised/thrown
12:09:40 <ihope> @type throw
12:09:42 <lambdabot> Not in scope: `throw'
12:09:49 <sjanssen_> @hoogle throw
12:09:50 <lambdabot> Control.Exception.throw :: Exception -> a
12:09:50 <lambdabot> Control.Concurrent.throwTo :: ThreadId -> Exception -> IO ()
12:09:50 <lambdabot> Control.Exception.throwDyn :: Typeable exception => exception -> b
12:09:54 <DaveCGI12344> sjanssen_, is "IO code" supposed to be any code using side effects
12:10:05 <sjanssen_> DaveCGI12344: code in the IO monad
12:10:05 <ihope> Yeah, they can be thrown outside of IO.
12:10:22 <sjanssen_> ihope: ssh, I'm trying to avoid the tricky GHC extensions :)
12:10:22 <ihope> But only caught inside IO, I believe.
12:10:35 <ihope> Ah. :-)
12:10:45 <DaveCGI12344> how might you handle a function f with an argument x that only takes even x then..?
12:10:58 <sjanssen_> GHC has the view that _|_'s are mapped to exceptions too
12:11:09 <sjanssen_> f x | even x = ...
12:11:33 <DaveCGI12344> but what if you pass in f 1 at runtime
12:11:46 <sjanssen_> DaveCGI12344: the | thing, called a guard, is part of the pattern match.  It means that the pattern only matches when the boolean evaluates to True
12:11:55 <sjanssen_> DaveCGI12344: runtime error
12:12:11 <DaveCGI12344> so now you need to catch that or something no?
12:12:25 <sjanssen_> you'll probably get output like "Pattern match failure in Foo.hs line x"
12:12:37 <sjanssen_> DaveCGI12344: no, _|_ cannot be caught
12:12:54 <sjanssen_> (I'm lying a little bit, you can catch _|_ with GHC extensions, but let's avoid that for now)
12:13:02 <SamB_XP> only sometimes though
12:13:12 <SamB_XP> GHC doesn't solve the halting problem, after all ;-)
12:13:18 <DaveCGI12344> how are you supposed to handle problems like this irl
12:13:34 <desegnis> > Control.Exception.catch (evaluate $ 1 `div` 0) (\e -> return 42)
12:13:35 <lambdabot>   Not in scope: `evaluate'
12:13:46 <desegnis> > Control.Exception.catch (Control.Exception.evaluate $ 1 `div` 0) (\e -> return 42)
12:13:47 <lambdabot>   Not in scope: `Control.Exception.evaluate'
12:14:00 <SamB_XP> desegnis: it isn't allowed anyway
12:14:15 <sjanssen_> DaveCGI12344: IRL you use the GHC extensions
12:14:17 <desegnis> SamB_XP, ah, that's why
12:14:28 <byorgey> DaveCGI12344: IRL you make sure you cover all possible cases.
12:14:34 <SamB_XP> if you ever get the scope right, you'll find that lambdabot prints <IO Integer> or something
12:14:37 <desegnis> DaveCGI12344, my line works in ghci and will print 42
12:14:50 <desegnis> DaveCGI12344, but I think this is not Haskell 98
12:16:57 <desp> @hoogle (a, b) -> c
12:16:58 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
12:16:58 <lambdabot> Prelude.fst :: (a, b) -> a
12:16:58 <lambdabot> Prelude.snd :: (a, b) -> b
12:17:06 <DaveCGI12344> > take 0 bot
12:17:06 <lambdabot>   Not in scope: `bot'
12:17:22 <sjanssen_> > take 0 undefined -- undefined is _|_
12:17:24 <lambdabot>  Undefined
12:17:30 <desp> > uncurry (*)
12:17:31 <lambdabot>  <(Integer,Integer) -> Integer>
12:17:35 <desp> woop
12:17:37 <DaveCGI12344> > let take 0 _ = [] in take 0 bot
12:17:38 <lambdabot>   Not in scope: `bot'
12:18:30 <DaveCGI12344> why are they using "bot" in the tutorial if its not a name
12:18:39 <sjanssen> DaveCGI12344: which tutorial is this?
12:18:44 <DaveCGI12344> http://www.haskell.org/tutorial/patterns.html
12:18:45 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
12:18:46 <sjanssen> DaveCGI12344: just use 'undefined'
12:19:00 <DaveCGI12344> > let take 0 _ = [] in take 0 undefined
12:19:01 <lambdabot>  []
12:19:32 <sjanssen> @src take
12:19:33 <lambdabot> take n _      | n <= 0 =  []
12:19:33 <lambdabot> take _ []              =  []
12:19:33 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:19:52 <sjanssen> ooh, that is interesting
12:20:07 <DaveCGI12344> > take 0 undefined
12:20:09 <lambdabot>  Undefined
12:20:17 <desp> zvrba: I'm rather proud of my solution to problem 27
12:20:33 <desegnis> in ghci, take 0 undefined gives []
12:20:46 <desp> zvrba: http://hpaste.org/2166
12:20:47 <sjanssen> DaveCGI12344: apparently GHC's definition of take isn't quite the same as the definition above
12:20:50 <desp> spoiler warning
12:21:48 <ivant>  @pl \a -> zipWith (*) a a
12:21:53 <oerjan> > take (-2) undefined
12:21:55 <lambdabot>  Undefined
12:21:58 <ivant> @pl \a -> zipWith (*) a a
12:21:59 <lambdabot> join (zipWith (*))
12:22:25 <ivant> @index join
12:22:25 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:22:40 <ivant> :t join
12:22:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:23:16 <ivant> @pl \a -> f a a
12:23:16 <lambdabot> join f
12:23:55 <pjd> > join (*) 5
12:23:57 <lambdabot>  25
12:25:12 <desegnis> @src join
12:25:13 <lambdabot> join x =  x >>= id
12:25:33 <desegnis> > (*) >>= id $ 5
12:25:35 <lambdabot>  25
12:25:47 <DaveCGI12344> is $ magical?
12:25:53 <oerjan> DaveCGI12344: no
12:25:53 <shachaf> DaveCGI12344: No.
12:25:55 <desegnis> Dave, no
12:26:01 <sjanssen> @src ($)
12:26:01 <lambdabot> f $ x = f x
12:26:05 <shachaf> > ((*) >>= id) 5
12:26:06 <lambdabot>  25
12:26:23 <DaveCGI12344> so its a useless prefix operator?
12:26:31 <sjanssen> no
12:26:38 <desegnis> @type (*) >>= id
12:26:40 <lambdabot> forall a. (Num a) => a -> a
12:26:42 <Vulpyne> It's very useful!
12:26:45 <shachaf> DaveCGI12344: ($) = id.
12:26:46 <sjanssen> it is a tool to avoid parentheses
12:26:58 <sjanssen> DaveCGI12344: f (g x) becomes f $ g x
12:26:58 <DaveCGI12344> @src id
12:26:59 <lambdabot> id x = x
12:27:18 <desegnis> @type (>>=)
12:27:19 <DaveCGI12344> isnt that just f . g?
12:27:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:27:22 <shachaf> @ty id :: (a -> b) -> a -> b
12:27:24 <lambdabot> (a -> b) -> a -> b :: forall a b. (a -> b) -> a -> b
12:27:28 <oerjan> > map ($ 3) [(2+),(2-),(2*)]
12:27:29 <lambdabot>  [5,-1,6]
12:27:40 <shachaf> > sequence [(2+),(2-),(2*)] 3
12:27:42 <lambdabot>  [5,-1,6]
12:27:45 <sjanssen> DaveCGI12344: well, there's x too, (f . g) x -- is the same
12:27:51 <sjanssen> or even, f . g $ x
12:27:58 <DaveCGI12344> :-|
12:28:00 <desegnis> I still don't get this join thing with non-monad numbers
12:28:16 <shachaf> desegnis: It's the (r ->) monad.
12:28:18 <sjanssen> desegnis: ((->) a) is a monad
12:28:37 <shachaf> @src (->) return
12:28:37 <lambdabot> return = const
12:28:40 <shachaf> @src (->) (>>=)
12:28:40 <lambdabot> f >>= k = \ r -> k (f r) r
12:28:47 * desegnis thanks and contemplates...
12:29:29 <desegnis> ha. nice thing :)
12:29:52 <shachaf> (>>=) :: m a -> (a -> m b) -> m b
12:30:07 <shachaf> (>>=) :: (e -> a) -> (a -> e -> b) -> e -> b
12:30:39 <shachaf> join :: m (m a) -> m a; join :: (e -> e -> a) -> e -> a
12:31:00 <shachaf> return :: a -> m a; return :: a -> e -> a
12:31:22 <desegnis> I didn't know about Control.Monad.Instances until now
12:31:25 <shachaf> desegnis: Also, fmap/liftM in (r ->) is (.).
12:31:41 <desegnis> schachaf, thanks, this makes sense now
12:31:50 <desegnis> *shachaf, sorry
12:31:53 <hpaste>  LPhas annotated "playing around with c2hs and limpd client" with "weird linking error :|" at http://hpaste.org/2158#a3
12:31:58 <ivant> @pl \a -> if a==0 then fst else snd
12:31:58 <lambdabot> flip (flip if' fst . (0 ==)) snd
12:32:48 <byorgey> DaveCGI12344: you can also use $ for something like:
12:32:51 <Vulpyne> Where can I read about the funky -> monad?
12:33:08 <byorgey> > map ($5) [(+1), (*2), succ]
12:33:09 <lambdabot>  [6,10,6]
12:33:17 <oerjan> Vulpyne: it is the same as Reader, except not wrapped in a newtype
12:33:25 <shachaf> @pl \a (x,y) -> if a == 0 then x else y
12:33:25 <lambdabot> (`ap` snd) . (. fst) . if' . (0 ==)
12:33:33 <Vulpyne> Hmm, I see. I've never used reader.
12:33:42 <DRMacIver> Hm. Where is the Monad instance for (->) r defined?
12:33:51 <oerjan> DRMacIver: Control.Monad.Instances
12:33:55 <DRMacIver> It doesn't seem to be in the Control.Monad sourcecode.
12:33:57 <DRMacIver> oerjan: Ah!
12:33:58 <DRMacIver> Thanks
12:34:00 <shachaf> > (`runReader` 5) $ do { x <- ask; y <- ask; return (x + y) }
12:34:02 <lambdabot>  10
12:34:02 <LPhas> someone here can give me an help with ffi and c2hs?
12:34:09 <DaveCGI12344> @src $
12:34:09 <lambdabot> f $ x = f x
12:34:13 <LPhas> i've some linking problems
12:34:15 <DaveCGI12344> $ is infix ??
12:34:42 <shachaf> DaveCGI12344: Yes.
12:34:58 <oerjan> i think that if example needs that bool catamorphism?
12:35:20 <shachaf> @let if' True x _ = x; if' False _ y = y
12:35:22 <lambdabot> Defined.
12:35:53 <DaveCGI12344> how does ($5) help map those functions to 5?
12:36:09 <DaveCGI12344> dont you need something like \x \y -> y x instead
12:36:09 <oerjan> @let bool x _ False = x; bool _ y True = y -- iiuc
12:36:11 <lambdabot> Defined.
12:36:30 <byorgey> ($ 5) is a "section".  it's the same thing as \f -> f $ 5.
12:36:36 <pjd> DaveCGI12344: it's f $ 5 with the f missing
12:36:41 <shachaf> @pl \x y z -> if x then y else z
12:36:41 <lambdabot> if'
12:36:53 <shachaf> @pl \y z x -> if x then y else z
12:36:54 <lambdabot> flip . flip if'
12:36:58 <pjd> DaveCGI12344: same idea as (+5)
12:37:01 <DaveCGI12344> how? i thought map f [a,b,c] expands to [f a, f b, f c] ?
12:37:08 <byorgey> DaveCGI12344: right.
12:37:27 <DaveCGI12344> > ($ 5) (+ 2)
12:37:29 <lambdabot>  7
12:37:33 <shachaf> DaveCGI12344: So [($ 5) a, ($ 5) b, ($ 5) c]
12:37:37 <DaveCGI12344> wtf
12:37:44 <DaveCGI12344> i must be really confused how infix operators work then
12:37:48 <DaveCGI12344> > (+ 5 2)
12:37:49 <lambdabot>   add an instance declaration for (Num (t -> a))
12:37:59 <byorgey> map ($ 5) [(+1), succ] ==> [($ 5) (+1), ($5) succ] ==> [(+1) $ 5, succ $ 5]
12:38:01 <desegnis> Dave, ($5) (+1) = (+1) 5 = 5 + 1
12:38:03 <norpan> ($ 5) is special syntax
12:38:08 <Vulpyne> DaveCGI12344: You know how sections work?
12:38:16 <DaveCGI12344> Vulpyne, nope .. how
12:38:18 <Vulpyne> That might be the part that's confusing you.
12:38:45 <Vulpyne> DaveCGI12344: Basically, if you apply a function to less arguments than it takes, you get a result of the function that would take the remaining arguments.
12:38:57 <Vulpyne> And it works the same way with operators.
12:39:12 <DaveCGI12344> > (+ 5) 2
12:39:14 <lambdabot>  7
12:39:20 <byorgey> (+ n) = \x -> x + n ; (n +) = \x -> n + x
12:39:27 <DaveCGI12344> Vulpyne, yes thats called currying
12:39:33 <SamB_XP> > (/ 5) 2
12:39:34 <lambdabot>  0.4
12:39:48 <oerjan> exception: (- 5) because that's a number
12:39:57 <ari> DaveCGI12344: Actually, it's called partial application
12:40:03 <DaveCGI12344> > 2 (+ 5)
12:40:04 <lambdabot>        add an instance declaration for (Num ((a -> a) -> a1))
12:40:04 <lambdabot>     In the expr...
12:40:05 <byorgey> DaveCGI12344: yup, but there's special syntax that allows you to partially apply an operator on either side
12:40:17 <desp> DaveCGI12344: no, currying is changing a function's type
12:40:34 <DaveCGI12344> SamB_XP, ah there we go... infix operators are applied in reverse
12:40:39 <desp> @type curry (*)
12:40:41 <lambdabot> forall a b. (Num (a, b)) => a -> b -> (a, b) -> (a, b)
12:41:03 <desp> @type uncurry (*)
12:41:04 <byorgey> ah, don't confuse him with being pedantic about "currying" vs "partial application" =)
12:41:05 <lambdabot> forall a. (Num a) => (a, a) -> a
12:41:31 <desp> DaveCGI12344: they aren't applied in reverse, though
12:41:39 <desp> both (+ 5) and (5 +) are valid
12:41:40 <oerjan> DaveCGI12344: (+ 5) is a function not an infix operator, so you must put it first.
12:41:57 <desegnis> heh? curry - Num?
12:42:12 <desp> desegnis: that was an error on my part
12:42:14 <oerjan> you can also turn a single function name into an infix operator with ``
12:42:33 <oerjan> > (+2) `map` [1,2,3]
12:42:35 <lambdabot>  [3,4,5]
12:42:43 <desegnis> desp, oh I see the (*) now
12:42:47 <oerjan> (example using both directions)
12:42:53 <desegnis> desp, overlooked that
12:43:27 <desp> I think he went into overload ;)
12:43:44 <desp> DaveCGI12344: why don't you try working with a tutorial, step by step? :)
12:43:55 <|Steve|> > flip (-) 1 5
12:43:56 <lambdabot>  4
12:44:30 <byorgey> desp: I think that's what he is doing =)
12:44:52 <desp> byorgey: I didn't mean a tutorial *session* ;)
12:44:59 <oerjan> > (`map` [1,2,3]) (+2)
12:45:01 <lambdabot>  [3,4,5]
12:45:02 <byorgey> sometimes asking #haskell for help can be like taking a drink from a fire hose
12:45:26 <oerjan> @remember byorgey sometimes asking #haskell for help can be like taking a drink from a fire hose
12:45:26 <lambdabot> Done.
12:45:29 <DaveCGI12344> byorgey, yeah seriously, i just looked it up on wikipedia and in my simple world currying is partial application
12:45:31 <byorgey> desp: heh, I know, I thought he was going through the "Gentle Introduction"
12:45:54 <desp> I really think people should start with the wikibook.
12:46:01 <desp> the Gentle Introduction isn't gentle at all.
12:46:05 <|Steve|> @pl \f (a,b) -> (f a, f b)
12:46:05 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
12:46:10 <desp> I was greatly confused by it.
12:46:18 <|Steve|> @unpl (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
12:46:18 <lambdabot> (\ l -> (\ u -> ((\ i aa g h -> ((,)) (i aa) (g h)) >>= \ c d e -> c e d) l (fst u)) >>= \ ac -> snd >>= \ ab -> return (ac ab))
12:46:27 <desp> @slap |Steve|
12:46:27 <lambdabot> why on earth would I slap |Steve|
12:46:32 <|Steve|> Now there's some clear code if I ever saw some.
12:46:36 <byorgey> DaveCGI12344: for most purposes, yeah, although if you want to be technical, currying is what allows you to do partial application.
12:46:49 <|Steve|> @pl (\ l -> (\ u -> ((\ i aa g h -> ((,)) (i aa) (g h)) >>= \ c d e -> c e d) l (fst u)) >>= \ ac -> snd >>= \ ab -> return (ac ab))
12:46:49 <lambdabot> ((snd >>=) . (return .) =<<) . (. fst) . (flip =<< (((.) . (,)) .))
12:46:59 <|Steve|> Heh, that's just horrible.
12:47:04 * byorgey agrees about the "gentle" introduction...
12:47:04 <Vulpyne> My eyes! The goggles, they do nothing!
12:47:16 <desp> I think "aa g h" sums it up pretty well
12:47:28 <|Steve|> i aa g h!
12:47:37 <desp> right
12:47:44 <DaveCGI12344> > let x `mydouble` y = (x,y) in 1 mydouble 2
12:47:46 <lambdabot>        add an instance declaration for
12:47:46 <lambdabot>       (Num ((t -> t1 -> (t, t1)) -> t2...
12:48:12 <|Steve|> > (((snd >>=) . (return .) =<<) . (. fst) . (flip =<< (((.) . (,)) .)))  (+5) (2,3)
12:48:13 <lambdabot>  (7,8)
12:48:21 <|Steve|> Well, it works.
12:48:22 <opqdonut> :DD
12:48:32 <opqdonut> wtf
12:48:59 <oerjan> > let x `mydouble` y = (x,y) in 1 `mydouble` 2
12:49:00 <opqdonut> how bout
12:49:00 <lambdabot>  (1,2)
12:49:11 <Vulpyne> I like how @pl creates ascii-art breasts so often.
12:49:50 <opqdonut> > join (&&&) (+5) $ (2,3)
12:49:51 <lambdabot>   add an instance declaration for (Num (t, t1))
12:50:02 <opqdonut> > join (***) (+5) $ (2,3)
12:50:04 <lambdabot>  (7,8)
12:50:05 <opqdonut> there
12:50:21 <opqdonut> |Steve|: lambdabot doesn't use arrow combinators
12:50:27 <opqdonut> a shame really
12:50:52 <|Steve|> I'll have to take your word for that. I don't know what an arrow combinator is.
12:51:14 <opqdonut> :t (***)
12:51:16 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:51:24 <desp> woo
12:51:41 <opqdonut> > (+1) *** (*2) $ (1,2)
12:51:42 <lambdabot>  (2,4)
12:51:50 <opqdonut> > (+1) &&& (*2) $ 1
12:51:52 <lambdabot>  (2,2)
12:51:57 <opqdonut> handy for tuples
12:52:06 <oerjan> |Steve|: i think he means @pl, > does them just fine
12:52:16 <desp> that's somewhat in the line noise department
12:52:18 <opqdonut> yeah @pl :)
12:52:33 <opqdonut> f *** g (x,y) = (f x, g y)
12:52:45 <opqdonut> (f *** g) (x,y) = (f x, g y)  --woops
12:52:53 <opqdonut> (f &&& g) x = (f x, g x)
12:53:04 <|Steve|> Oh.
12:53:09 <opqdonut> those are handy for tuple stuff even if you have no clue about arrows :)
12:53:50 <opqdonut> also: join (***) f == f *** f
12:54:05 <opqdonut> a quite usual idiom
12:54:11 <opqdonut> > join (,) 1
12:54:12 <lambdabot>  (1,1)
12:54:17 <desp> @pl rotl xs = read (tail ys ++ [head ys]) where ys = show xs
12:54:17 <lambdabot> (line 1, column 48):
12:54:18 <lambdabot> unexpected "="
12:54:18 <lambdabot> expecting variable, "(", operator or end of input
12:54:19 <|Steve|> I have a hard time mapping Haskell onto the CT I know.
12:54:36 <opqdonut> |Steve|: i know so little CT that i don't even try :)
12:54:45 <desp> @pl rotl xs = read (tail ys ++ [head ys])
12:54:45 <lambdabot> rotl = const (read (tail ys ++ [head ys]))
12:54:57 <desp> arg
12:55:03 <desp> @pl rotl xs = read (tail xs ++ [head xs])
12:55:03 <lambdabot> rotl = read . liftM2 (++) tail (return . head)
12:55:49 <oerjan> why read?
12:56:05 <desp> rotate the string representation
12:56:07 <opqdonut> he's probably rotling the 10-base representation of an Integer?
12:56:11 <opqdonut> yeah
12:56:28 <desp> doing it numerically would probably be reinventing the wheel
12:56:41 <oerjan> yeah, if it were a Double, it would be rofl
12:56:50 <|Steve|> =\
12:56:52 <desp> :)
12:57:02 <opqdonut> oerjan: "kekeke"
12:57:04 <opqdonut> :)
12:57:11 <desp> |Steve|: what's bad?
12:57:32 <|Steve|> rofl.
12:59:32 <DaveCGI12345> rrrhmm, lazy patterns are confusing
13:00:35 <opqdonut> how come?
13:00:48 <Heffalump> yeah, they are a bit
13:00:49 <sjanssen> hah, gotta love these Google ads for Haskell
13:01:24 <sjanssen> "It's not Haskell... but it is functional. Hack OCaml at a Silicon Valley mobile startup"
13:02:21 <DaveCGI12345> silicon valley startups are all the rage
13:04:11 <bla123> when i try to run yi, it only replies: "\driver\package.conf.inplaceas C:\Programme\ghc-6.6.1"
13:05:08 <desp> which one is nicer?
13:05:10 <desp> let rotations x = x : (takeWhile (/= x) . tail . iterate rotateLeft) x
13:05:11 <desp> let rotations' x = (take ((length . show) x) . iterate rotateLeft) x
13:06:05 <oerjan> the latter, i think
13:06:13 <DaveCGI12345> > $ (+ 1) 2
13:06:14 <lambdabot>  Parse error
13:06:23 <oerjan> (/= x) is even more expensive than length
13:06:38 <desp> mm.
13:06:42 <oerjan> or maybe not...
13:07:00 <oerjan> oh, and it fails if x is a repetition
13:07:04 <shachaf> let rotations' x = take (length . show $ x) . iterate rotateLeft $ x -- With ($)?
13:07:20 <desp> shachaf: I don't think I like $.
13:07:32 <shachaf> desp: Hmm, OK.
13:07:45 <desp> oerjan: it does?
13:07:59 <desp> shachaf: oh, the latter does.
13:08:04 <desp> er.
13:08:08 <|Steve|> Why is length . show $ x better than length $ show x?
13:08:10 <desp> oerjan: ^
13:08:33 <shachaf> @pl rotations' x = take (length . show $ x) . iterate rotateLeft $ x
13:08:34 <lambdabot> rotations' = (. iterate rotateLeft) =<< take . length . show
13:08:34 <oerjan> well, i guess it depends on what you want 123123 to give
13:09:33 <desp> I'm afraid lambdabot's version is completely unreadable to me :)
13:09:44 <desp> oerjan: the former gives correct results.
13:11:12 <|Steve|> :t (. iterate rotateLeft) =<< take . length . show
13:11:14 <lambdabot> Not in scope: `rotateLeft'
13:11:15 <oerjan> desp: uses the (r ->) monad again.
13:11:37 <|Steve|> Ew, why does lambdabot use `' for quotes?
13:12:17 <anybody> hm. is it possible to use multiple monads parallel?
13:12:36 <oerjan> anybody: look at monad transformers
13:12:41 <shachaf> anybody: Look into monad transformers, maybe?
13:12:46 <anybody> oerjan: k
13:12:51 <xyz334_> aha, i read the sections part of the haskell tutorial...heh
13:13:27 <desp> any ideas why :m + Foo says "module Foo is not loaded" instead of, you know, LOADING IT?
13:13:30 <desp> in ghci
13:13:40 <DaveCGI123456> can you define infix functions without using `` ?
13:13:53 <shachaf> > (`runStateT` 5) $ do { x <- lift [1,2,3]; put x; return 'a' }
13:13:54 <lambdabot>  [('a',1),('a',2),('a',3)]
13:14:07 <glguy> can ViM draw a line at 80 characters for me?
13:14:18 <oerjan> DaveCGI123456: if you use operator characters, it's infix by default.
13:14:30 <oerjan> if you use alphanumerics, it's not
13:14:51 <DaveCGI123456> @src infixr
13:14:51 <lambdabot> Source not found. Are you on drugs?
13:15:05 <oerjan> infixr is a declaration.
13:15:29 <oerjan> @where report
13:15:29 <lambdabot> http://www.haskell.org/onlinereport/
13:16:13 <bwx> any gtk2hs devs here?
13:16:20 <shachaf> glguy: Ask in #vim, maybe?
13:16:54 <shachaf> glguy: See also http://www.vim.org/tips/tip.php?tip_id=810 .
13:16:55 <lambdabot> Title: Tip #810 - Highlighting Text Beyond 80 Columns : vim online
13:17:03 <DaveCGI123456> gotta love infinite structures.
13:17:15 <desp> oerjan: hehe, rotations 100 blows up
13:17:33 <desp> apart from that, this is beautiful:  let circularPrimes = filter (and . map prime . rotations) primes
13:17:59 <shachaf> @src all
13:17:59 <lambdabot> all p =  and . map p
13:18:08 <shachaf> desp: Maybe that can help?
13:18:11 <desp> :)
13:18:14 <desp> shachaf++
13:18:25 <DaveCGI123456> > _|_
13:18:25 <lambdabot>  Parse error
13:18:30 <shachaf> > undefined
13:18:32 <lambdabot>  Undefined
13:18:35 <shachaf> > let x = x in x
13:18:37 <lambdabot>  Exception: <<loop>>
13:18:48 <shachaf> > error "Error!"
13:18:49 <lambdabot>  Exception: Error!
13:19:47 <oerjan> > error $ "error " ++ error "Error!"
13:19:49 <lambdabot>  Exception
13:19:57 <desp> :D
13:20:23 <shachaf> > error ""
13:20:25 <lambdabot>  Exception:
13:20:51 <shachaf> > error undefined
13:20:53 <lambdabot>  Undefined
13:21:06 <oerjan> DaveCGI123456: anyway, _|_ is mathematical notation for all manner of errors
13:21:26 <DaveCGI123456> is that supposed to be an upside down T?
13:21:34 <shachaf> > error (undefined:undefined)
13:21:35 <lambdabot>  Exception
13:21:43 <shachaf> DaveCGI123456: It's supposed to be bottom.
13:21:51 <oerjan> DaveCGI123456: probably, it's bottom and there is a top written as T
13:22:38 <oerjan> (actually, not an ordinary T but a T in the same style as _|_)
13:22:41 * shachaf tries to find the unicode _|_ char through Google.
13:22:55 <oerjan> iirc
13:23:29 <oerjan> if you look at linear logic it has four logical constants: 0,1, top and bottom
13:23:30 <lde> shachaf: ⊥
13:23:58 * shachaf realizes his IRC client doesn't even support Unicode.
13:24:02 <shachaf> s/IRC/SSH/
13:24:15 <bwx> what is a short example of code that will give a ghc compiler warning?
13:24:16 <shachaf> Fortunately this is temporary.
13:24:30 <sjanssen> bwx: f 0 = 0
13:24:41 <lde> shachaf: U+22A5
13:24:48 <sjanssen> bwx: instance Num [a]
13:24:53 <Saizan> ⊤
13:25:08 <shachaf> I had everything set up to type unicode nicely.
13:25:26 <Saizan> someone knows how to input unicode in gnome-terminal?
13:25:27 <bwx> sjanssen: I am not getting a warning
13:25:35 <shachaf> Saizan: Try SCIM?
13:25:45 <shachaf> Saizan: In LaTeX mode.
13:26:06 <oerjan> bwx: compile with -wall, i think
13:26:13 <shachaf> "Ctrl-space \bot Ctrl-space" -> _|_, I think.
13:26:25 <sjanssen> bwx: "instance Num a => Num [a]" will definitely give a warning
13:27:03 <Saizan> shachaf: i've SCIM but ctrl-space doesn't do anything
13:27:08 <bwx> sjanssen: i'm getting an error with that
13:27:25 <sjanssen> bwx: are you typing this at ghci?
13:27:29 <shachaf> Saizan: You have to use SCIM input mode.
13:27:37 <bwx> sjanssen: no, i'm going through the ghc api
13:27:48 <shachaf> Saizan: Right-click on any text and choose it.
13:28:05 <shachaf> Saizan: Also, you have to tell it to use LaTeX mode.
13:29:35 <shachaf> Saizan: (This is all from memory; it might be a bit different.)
13:29:38 <Saizan> shachaf: uhm, i see, scim is not listed in the input methods though, something broken in my installation maybe, thanks anyway
13:30:22 <shachaf> Saizan: Is SCIM installed?
13:30:26 <shachaf> Saizan: OK, it is, sorry.
13:30:31 <shachaf> Saizan: Try it in gedit?
13:30:51 <malsyned> What would the line of code (stdin `seq` return ()) do?
13:31:21 <Igloo> malsyned: Is that in darcs?
13:31:22 <shachaf> malsyned: Force stdin to be evaluated and then do nothing, in the current monad.
13:31:26 <malsyned> Igloo: yup.
13:31:40 <malsyned> shachaf: but like, what is the value in forcing a file handle to be evaluated?
13:31:50 <Igloo> I think it's to force the handle to be put into the right mode or something, but I'm not sure
13:32:11 <Igloo> It's quite possibly obsoleted by GHC no longer using non-blocking sockets, too
13:32:19 <shachaf> malsyned: It does seem a bit odd.
13:32:29 <Igloo> s/handle/fd/
13:32:34 <bwx> how can I do interprocess communication between 2 haskell processes?
13:32:42 <Igloo> non-blocking sockets? YKWIM  :-)
13:33:13 <shachaf> malsyned: http://lists.osuosl.org/pipermail/darcs-users/2005-April/007148.html ?
13:33:15 <lambdabot> Title: [darcs-users] RE: Environment variable does not work (especially DARCS_EDITOR), http://tinyurl.com/2d7gez
13:34:20 <malsyned> shachaf: that does look like a post dealing with the very line of code I was reading.
13:35:07 <malsyned> I'm reading darcs to get an idea for how a real project does file and process IO.  It's tricky because there are still some work-arounds that probably are no longer necessary.
13:35:29 <shachaf> malsyned: I've heard darcs is not the best project to learn from.
13:36:34 <malsyned> shachaf: there may be wisdom in that.  although as far as process launching goes, it's improved a lot recently as far as simplicity and readability goes.  Have you heard of a project that's better to learn from?
13:38:14 <shachaf> malsyned: I don't think so.
13:38:23 * shachaf only hears the negative rumors.
13:38:56 <malsyned> and here I was hoping to someday replace Perl with Haskell as a system scripting language.
13:39:13 <shachaf> malsyned: Sure, why not?
13:39:18 <shapr> Yeah, why not?
13:39:19 <proqesi`> malsyned: why someday?
13:39:45 <malsyned> Because I don't know how to right now, and shachaf doesn't know of any good roll-model projects.
13:40:00 <shachaf> malsyned: But you wouldn't look at a darcs-type program (in Perl) to learn about Perl for system scripting, though.
13:40:17 <sjanssen> why do you need a role model?  Be a trailblazer! :)
13:40:26 <Nucleo_> @src sortBy
13:40:26 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
13:40:54 <Vulpyne> Try to write some of your system scripts in Haskell. You'll probably be forced to go out and find the information that'll help you learn.
13:40:55 <malsyned> Darcs is doing moderately complicated things with launching external processes (ssh, curl, $EDITOR, $DARCS_GET_FOO, &c), so it seemed like a good place to start.
13:41:13 <desp> hmm, writing a proper rotations function is quite tricky
13:41:41 <shapr> malsyned: http://www.cse.unsw.edu.au/~dons/h4sh.html
13:41:41 <lambdabot> Title: h4sh
13:42:08 <malsyned> (btw: I was also planning on mucking about in darcs' ssh handling code, so I was trying to kill two birds with one stone)
13:42:15 <shapr> malsyned: Or maybe http://www.volker-wysk.de/hsshellscript/ ?
13:42:17 <lambdabot> Title: HsShellScript Homepage
13:42:52 <hpaste>  ptolomy pasted "my message passing concurrency monad" at http://hpaste.org/2167
13:47:35 <ptolomy> Anyone aware of any other implementations of a message passing concurrency monad thing that I can look to for a nice way of allowing user-defined message types without resorting to Data.Dynamic?
13:49:57 <sjanssen> ptolomy: could the monad be parametric on the message type?
13:50:53 <ptolomy> sjanssen: Yeah, that would seem like the obvious answer. I tried parameterizing some newtype... oh. Just figured it out, nevermind. :)
13:50:55 <ptolomy> Thanks.
13:50:57 <chessguy> @hoogle get
13:50:57 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
13:50:58 <lambdabot> Text.ParserCombinators.ReadP.get :: ReadP Char
13:50:58 <lambdabot> Text.ParserCombinators.ReadPrec.get :: ReadPrec Char
13:51:02 <chessguy> @src get
13:51:02 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:51:10 <chessguy> @src Control.Monad.State.get
13:51:10 <lambdabot> Source not found. You type like i drive.
13:51:24 <oerjan> @src MonadState
13:51:24 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:51:44 <oerjan> anyway, it's a method
13:51:54 <chessguy> obviously
13:52:00 <shachaf> @src State get
13:52:00 <lambdabot> Source not found. Are you on drugs?
13:52:38 <ptolomy> Is it possible to do a monad transformer that makes IO the outer monad, so that you have to lift to do non-IO stuff?
13:52:52 <shachaf> ptolomy: No.
13:53:11 <shachaf> get :: State s s; get = State $ \s -> (s,s) -- Maybe?
13:53:14 <shachaf> @ty get
13:53:15 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
13:53:17 <oerjan> instance MonadState s (State s) where get   = State $ \s -> (s, s) put s = State $ \_ -> ((), s)
13:53:31 * shachaf guessed correctly.
13:53:47 <ski> the io state must be linearly used, and haskell's type system can't enforce only linear monads are used underneath
13:54:04 <chessguy> hmm, seems like dons re-implements state to some extent in http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons
13:54:06 <lambdabot> Title: Haskell hacking, http://tinyurl.com/ywdjsr
13:54:16 <chessguy> unless i'm missing something
13:55:42 <desp> @let rotateLeft xs = tail xs ++ [head xs]
13:55:43 <desp> @let rotations x = (map read . take (length xs) . iterate rotateLeft) xs where xs = show x
13:55:44 <lambdabot> Defined.
13:55:46 <lambdabot> Defined.
13:55:59 <chessguy> ski, come again?
13:56:05 <desp> rotations 101
13:56:09 <desp> > rotations 101
13:56:09 <chessguy> @src MonadState
13:56:10 <lambdabot> Source not found. Take a stress pill and think things over.
13:56:10 <lambdabot>  [101,11,110]
13:56:28 <lament> this really ought to work:
13:56:29 <lament> class Entity a where color :: a -> Int
13:56:29 <lament> data Apple = Apple  {color :: Int}
13:56:29 <lament> instance Entity Apple
13:56:33 <shachaf> chessguy: Imagine You had IO wrapped around [], for example (if I understood correctly?).
13:56:37 <lament> any suggestions?
13:56:45 <oerjan> class (Monad m) => MonadState s m | m -> s where get :: m s put :: s -> m ()
13:56:54 <shachaf> lament: Doesn't it?
13:57:02 <chessguy> shachaf, uh...IO has to be at the bottom of any MonadT stack
13:57:08 <shachaf> lament: Oh, same name.
13:57:11 <lament> shachaf: it doesn't, "Multiple declarations of `Main.color'"
13:57:12 <shachaf> chessguy: Exactly.
13:57:22 <shachaf> chessguy: That's what ski was saying.
13:57:31 <shachaf> lament: Yes, they have to have different names.
13:57:34 <lament> this sucks.
13:57:47 <shachaf> lament: Does it matter?
13:58:03 <shachaf> lament: In this case? You can always call it through the class, anyway.
13:58:03 <chessguy> hm, i don't get how that's related
13:58:18 <shachaf> chessguy: It's not.
13:58:22 <shachaf> 16:52 < ptolomy> Is it possible to do a monad transformer that makes IO the outer monad, so that you have to lift to do non-IO stuff?
13:58:22 <desp> data Apple = Apple {appleColorFld :: Int}
13:58:24 <desp> instance Entity Apple where color = appleColorFld
13:58:27 <chessguy> oh!
13:58:31 <chessguy> no wonder i was confused
13:58:40 <desp> records--
13:58:42 <lament> i'm just disappointed because it _should_ work
13:58:58 <desp> lament: records suck, get with the program :)
13:59:27 <lament> desp: it will take _years_ of indoctrination to convince me of that
13:59:37 <desp> I mean, records in Haskell.
13:59:58 <oerjan> lament: how would the type inferencer know which color you meant in a use, if you allowed it?
13:59:59 <shachaf> lament: We've all switched to digital music by now.
14:00:01 * DRMacIver only figured out recently why people bothered to define one element record types. :)
14:00:25 <lament> oerjan: but there's only one!
14:00:28 <shachaf> DRMacIver: What do you mean?
14:00:36 <shachaf> DRMacIver: As opposed to newtypes?
14:00:58 <oerjan> lament: the data type version can be pattern matched on, the method one cannot
14:01:20 <DRMacIver> shachaf: e.g. data Apple = Apple { appleColorFld :: Int } instead of data Apple = Apple Int
14:01:25 <ski> chessguy : bah, you left ..
14:01:31 <shachaf> DRMacIver: Why not?
14:01:45 <shachaf> DRMacIver: Otherwise you'd have to pattern-match to get the Int out, no?
14:02:14 * shachaf can't help reading that as "Dr. MacIver".
14:02:46 <DRMacIver> shachaf: Yeah. The record type gives you a free extraction function. But I didn't twig to that fact. :)
14:02:52 <DRMacIver> shachaf: Please don't. I'm not a doctor. :)
14:03:25 * byorgey wonders how it is supposed to be read?
14:03:42 <shachaf> byorgey: "David R. MacIver"
14:03:45 <oerjan> wait a minute, what does DRMacIver mean if it's not that?
14:03:52 <oerjan> oh
14:03:54 <byorgey> shachaf: aha!
14:04:00 <malsyned> is there a function like groupBy that groups /every/ group that passes the predicate together, not just those which were initially adjacent?
14:04:19 <Heffalump> groupBy . sort
14:04:27 <Heffalump> IM groupBy . sortBy
14:04:37 <shachaf> Heffalump: I don't think that's what malsyned wanted.
14:04:45 <Heffalump> (but no, if you don't have an ordering, or you don't want them to end up sorted)
14:04:45 <shachaf> (Though maybe.)
14:04:49 <malsyned> Heffalump: would work, except that it imposes the requirement on the Ord class in addition to the Eq class.
14:04:58 <sjanssen> malsyned: partition?
14:05:07 <shachaf> Oh, I misunderstood.
14:05:19 <sjanssen> > partition (< 5) [1..10]
14:05:20 <Heffalump> you'd have to repeatedly do that for each equivalence class
14:05:20 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
14:05:25 <shachaf> > groupBy (<) [1,2,3,2,1,2,4]
14:05:27 <lambdabot>  [[1,2,3,2],[1,2,4]]
14:05:45 <Heffalump> groupBy (<) is a bit of an odd thing to do, (<) isn't an equivalence relation
14:05:49 <malsyned> kindof an iterative partition.
14:06:09 <DRMacIver> byorgey, oerjan: Yeah, what shachaf said. :)
14:06:13 <malsyned> partition is (a -> Bool) -> [a] -> ([a], [a]).  I want (a -> Bool) -> [a] -> [[a]]
14:06:24 <wli> The brilliant thing about pattern matching on records is that you don't need to use every field in the pattern. For instance, it doesn't matter what color a knightis when making a chess move, somove (Piece { pieceType = Knight }) square@(Square { rank = r , file = f }) = do { {- list monad stuff -} } but move (Piece { pieceType = Pawn , pieceColor = Black }) square@(Square { rank = r , file = f }) = do { {- list monad again -} }
14:06:29 <shachaf> malsyned: Not (a -> a -> Bool)?
14:06:40 <byorgey> malsyned: hm, that reminds me of unfoldr...
14:06:41 <oerjan> malsyned: something with unfoldr and partition
14:06:42 <malsyned> shachaf: good point.
14:07:46 <sjanssen> @type \p -> unfoldr (\xs' -> case xs' of { [] -> Nothing; (x:xs) -> let (a, b) = partition (p x) xs in Just (x:a, b) })
14:07:47 <Heffalump> groupAllBy f (x:xs) = let (ys, zs) = partition (f x) xs in ys:groupAllBy f zs
14:07:48 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
14:08:01 <Heffalump> groupAllBy f [] = []
14:08:10 * sjanssen is amazed that he managed to write that without any mistakes
14:08:22 <dolio> > let g [] = Nothing ; g (x:xs) = Just . first (x:) . partition (==x) $ xs in unfoldr g [1,2,3,1,2,3,1,2,3]
14:08:23 <lambdabot>  [[1,1,1],[2,2,2],[3,3,3]]
14:08:24 <Botje> :t (==1) . length . groupBy (<=) -- easy check if a list is sorted. :)
14:08:24 <Heffalump> I think that should be a fold, not an unfold.
14:08:26 <lambdabot> forall a. (Ord a) => [a] -> Bool
14:08:38 <shapr> Dang, I missed Lemmih.
14:09:03 <sjanssen> Heffalump: I think it'd be difficult to write that with foldr
14:09:07 <malsyned> dolio: that looks like what I wanted, yeah.
14:09:08 <Botje> shapr: quick! reload!
14:09:12 <Heffalump> oh, good point.
14:09:13 <malsyned> thanks
14:09:20 <Heffalump> unfoldr is nice, then
14:09:25 <shapr> :-(
14:09:26 <shachaf> > ((==1) . length . groupBy (<=)) [1,2,3,2,1,2,4]
14:09:27 <lambdabot>  True
14:09:28 <shachaf> Sorted?
14:09:37 <Botje> err
14:09:40 <Heffalump> people waste way too long trying to use existing functions when they could just write it quickly, though :-)
14:09:47 <Botje> okay, i don't understand groupBy then.
14:09:56 <Botje> oh well
14:09:58 <shachaf> Botje: As Heffalump said, groupBy is for equivalence relations.
14:10:10 <Botje> << off to bed, then work, then england!
14:10:14 <shachaf> Botje: So it always compares with the first element.
14:10:23 <Botje> oh. that's too bad
14:10:57 <byorgey> Botje: have fun!
14:11:01 <Heffalump> well, it doesn't have to be, it's just a bit weird to use it for anything else
14:11:07 <Heffalump> I guess it acts as a kind of iterated takeWhile
14:11:09 <shapr> Man, I want a real refactoring browser for Haskell.
14:11:30 <Heffalump> have you tried HaRe?
14:11:37 <dolio> > let f x (ys@(y:_):yss) | y == x = (x:ys):yss | otherwise = ys:(f x yss) ; f x [] = [[x]] in foldr f [] [1,2,3,1,2,3,1,2,3]
14:11:38 <lambdabot>  [[3,3,3],[2,2,2],[1,1,1]]
14:11:59 <oerjan> Heffalump: it's nice to use it with something non-reflective if you want to keep certain things completely ungrouped
14:12:11 <Heffalump> oerjan: fair enough
14:12:13 <shapr> I haven't tried HaRe lately.
14:12:14 <malsyned> separateBy _ [] = []
14:12:14 <malsyned> separateBy f (x:xs) = (x : filter (f x) xs) :
14:12:14 <malsyned>                       separateBy (filter ((not.f) x) xs)}
14:12:17 <shapr> @where HaRe
14:12:17 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
14:12:46 <bwx> is there an icon for haskell source files, for file managers?
14:13:01 <shachaf> bwx: The Haskell logo?
14:13:06 <malsyned> bwx: if you install the ghc windows package, it puts a lambda-looking icon on .hs files.
14:13:07 <oerjan> bwx: WinHugs comes with one
14:13:17 * shapr throws lottery tickets at Lemmih 
14:13:18 <shachaf> bwx: A reading lambda for .lhs?
14:13:31 <oerjan> actually it's just a big lambda on a sheet
14:13:57 <shapr> bwx: Gnome has .lhs icons
14:14:15 <bwx> where can i download one of these icons?
14:18:00 <proqesi`> ewww icons
14:19:25 <shachaf> bwx: Better idea: Get ls to highlight them in a different color.
14:19:37 <shachaf> bwx: That way you can stick to the command line! :-)
14:20:34 <tsp> > sort ["line 3", "line 2", "line 4", "line 1"]
14:20:42 <lambdabot>  ["line 1","line 2","line 3","line 4"]
14:20:46 <tsp> lol it worked
14:21:13 <tsp> > sort ["line 3", "line 2", "line 4", "line 1", "line 10", "line 11"]
14:21:15 <lambdabot>  ["line 1","line 10","line 11","line 2","line 3","line 4"]
14:21:37 <tsp> heh, no equivalent of sort -n?
14:21:59 <shapr> @type sortBy
14:22:01 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:23:05 <oerjan> > sort [("line", 3), ("line", 10), ("line", 11), ("line", 2)]
14:23:06 <lambdabot>  [("line",2),("line",3),("line",10),("line",11)]
14:23:18 <tsp> ah, that works. but if its aprt of a text file
14:23:33 <shachaf> > sort ["sort", "sort"]
14:23:35 <lambdabot>  ["sort","sort"]
14:23:41 <shachaf> Nope, it has them reversed.
14:27:31 <oerjan> > sortBy (comparing ((read :: String -> Int) . (!!1) . words) ["line 3", "line 2", "line 4", "line 1", "line 10", "line 11"]
14:27:31 <lambdabot>  Parse error
14:27:36 <proqesi`> > sort ["foo", "bar", 5, baz]
14:27:37 <lambdabot>   Not in scope: `baz'
14:27:47 <oerjan> > sortBy (comparing ((read :: String -> Int) . (!!1) . words)) ["line 3", "line 2", "line 4", "line 1", "line 10", "line 11"]
14:27:49 <lambdabot>  ["line 1","line 2","line 3","line 4","line 10","line 11"]
14:34:30 <oerjan> > let readOpt o s = fst . head $ reads s ++ [(o,s)] in  sortBy (comparing (map (readOpt 0 :: String -> Int) . words)) ["line 3", "line 2", "line 4", "line 1", "line 10", "line 11", "line 10 -1"]
14:34:32 <lambdabot>  ["line 1","line 2","line 3","line 4","line 10","line 10 -1","line 11"]
14:36:24 <proqesi`> sort ["foo", "bar", 5]
14:36:35 <dolio> 5 is not a string.
14:36:47 <proqesi`> obviously
14:37:30 <dolio> Well, technically, it could be, if you defined the right typeclass instance, but it isn't by default.
14:37:40 <dolio> Thus, ["foo", "bar", 5] is ill-typed.
14:41:58 <hpaste>  loz annotated "non-idiomatic readList?" with "more straightforward readList implementation" at http://hpaste.org/2140#a1
14:46:57 <sjanssen> @keal
14:46:58 <lambdabot> nsa prevent me from returning to math on efnet
14:48:35 <mehrheit> @help keal
14:48:35 <lambdabot> keal. Talk like Keal
14:51:00 <dolio> @remember qwe1234 which is why talking about 'functional languages' as such is a wankfest for clueless people without a functioning thought mechanism.
14:51:00 <lambdabot> Done.
14:51:45 <ihope> When was that said?
14:51:58 <dolio> 8 hours ago.
14:52:14 <ihope> I see.
14:52:29 <dolio> @remember qwe1234 LtU == TEH SUCK.
14:52:29 <lambdabot> Done.
14:52:56 <oerjan> hey, those are fighting words
14:53:36 <DRMacIver> I think if you're going to put every stupid thing qwe1234 ever said into lambdabot then a) You're going to be here a very long time and b) Poor lambdabot will get indigestion. :(
14:53:58 <dolio> Not every stupid thing. Just the amusing ones.
14:54:36 <ihope> @keal
14:54:36 <lambdabot> i aint running that on my puter
14:56:16 <dolio> @quote JonHarrop
14:56:16 <lambdabot> JonHarrop says: Absolutely, but you don't want laziness everywhere all the time because it means you can't write fast code.
14:56:46 <dolio> I was hoping for more of those, too, but I got tired of reading his threads on comp.lang.functional.
14:57:01 <dolio> I had to wade through too many snooty Lisp guys.
14:57:27 <ihope> More of what?
14:57:35 <dolio> Jon Harrop quotes.
14:57:48 <dolio> @quote JonHarrop haskell shows
14:57:49 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
14:58:00 <mehrheit> @quote lisp
14:58:00 <lambdabot> LarryWall says: ..take Lisp. You know it's the most beautiful language in the world. At least up until Haskell came along.
14:58:07 <dolio> @quote JonHarrop haskell has shown
14:58:07 <lambdabot> JonHarrop says: As Haskell has shown, laziness cannot be implemented efficient at all.
14:59:48 <ihope> Hmm...
14:59:54 <ihope> @quote JonHarrop
14:59:54 <lambdabot> JonHarrop says: In Haskell, programmers write declaratively and often optimize by randomly fiddling until the current version of GHC happens to reduce it in an asymptotically more efficient way.
15:00:27 <osfameron> heh
15:00:33 * mrd plays the fiddle to optimize
15:01:36 <ihope> "JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems:  laziness is unpredictable."
15:01:48 <ihope> Reliability problems?
15:02:17 <ptolomy> I do get kinda depressed in programs that spend a fair portion of their time looking up things, because Data.Map isn't a hashtable, and Data.Hashtable is unpleasant.
15:02:38 <mrd> what type of key
15:02:56 <ptolomy> let's say... ByteString.
15:03:09 <mrd> perhaps a Trie better?
15:03:13 <wli> This looks handy: unfoldr (\l -> fmap (const $ let x:xs = l in first (x:) . partition ((== snd x) . snd) $ xs) $ listToMaybe l)
15:03:21 <dolio> Huh, someone should probably make a bytestring trie. :)
15:03:25 <Heffalump> persistent hashtables are tricky
15:03:27 <ddarius> You could also hash to an Int and use an IntMap.
15:03:30 <mrd> ihope: well i did just have an odd write / read file problem which i resolved by using strict bytestrings :/
15:03:51 <ddarius> mrd: Because you used lazy IO!
15:03:56 <wli> Or set up a hashtable that's an STUArray etc.
15:04:01 <mrd> yep!
15:04:13 <mrd> but i just wanted to load and and save some data
15:04:13 <ptolomy> I tried a Trie I made against Data.Map, and Data.Map was faster.
15:04:17 <ddarius> Lazy IO shouldn't be in Haskell.
15:04:31 * wli recommends hash tries.
15:04:54 <int-e> hmmm. unsafeLazyGetContents
15:05:26 <ihope> I take it reading now is different from reading later.
15:05:37 <ihope> (And what's a trie, again?)
15:05:46 <wli> radix tree
15:05:46 <Toxaris> wli: hash trie? using the hash value as trie index?
15:06:19 <dolio> wli: What does that unfoldr code do, exactly?
15:06:20 <wli> Toxaris: Using large radices and representing trie nodes as open-addressed hash tables.
15:06:20 <int-e> Toxaris: then you can use an intmap I think
15:06:58 <ptolomy> I think I'd just prefer something already exist, because the chances of me making something better and faster than Data.Map and Data.Hashtable with a reasonable amount of effort aren't great.
15:07:01 <ddarius> unfoldr (\~(x:xs) -> first ...
15:07:19 <ddarius> ptolomy: You can probably roll a better Data.HashTable.
15:10:25 <cognominal_> what is the syntax for a anomymous function of two parameters?
15:10:49 <Toxaris> > (\x y -> x + y) 1 2
15:10:49 <int-e> you mean, \x y -> x + y?
15:10:57 <lambdabot>  3
15:11:22 <Toxaris> as a shorthand for \x -> \y -> x + y
15:11:32 <cognominal_> thx, I tried an extra \ before the \y, silly me
15:11:33 <int-e> > (\x -> \y -> x + y) 2 3 -- equivalently
15:11:34 <lambdabot>  5
15:16:02 <Toxaris> wli: "large radices" means a fixed size? so that collisions may occur (more then one key per trie node) wich are resolved by the hash table?
15:16:41 <glguy> @yow
15:16:42 <lambdabot> YOW!!  Up ahead!  It's a DONUT HUT!!
15:16:47 <glguy> @yarr
15:16:47 <lambdabot> Ahoy mateys
15:16:54 <glguy> @quote
15:16:54 <lambdabot> ##C++ says: [asking about C++ rules] vincenz: how should we know what those rules mean ?
15:17:25 <glguy> @vixen How long until our date?
15:17:25 <lambdabot> good question
15:17:46 <glguy> @vixen Is Haskell better than pizza
15:17:46 <lambdabot> church is my favourite computer scientist.
15:18:02 <ari> @. vixen yarr
15:18:02 <lambdabot> Whatever
15:18:10 <pjd> computer science is my favorite church
15:18:19 <glguy> @vixen a/s/l?
15:18:19 <lambdabot> 19/f/California
15:18:24 <dmwit> LIES
15:18:33 <dmwit> I bet she's less than five years old.
15:18:58 <glguy> @pl \f g x y -> g x `f` g y
15:18:58 <lambdabot> join . ((flip . ((.) .)) .) . (.)
15:19:21 <glguy> @unmtl StateT Int Maybe Char
15:19:22 <lambdabot> Int -> Maybe (Char, Int)
15:19:46 <wli> Toxaris: Say each tree level deals with 3 characters at a time. You can have (256*(256^3-1)) `quot` (256-1) distinct keys, ca. 2^24. You hash because you expect nowhere near 2^24 distinct combinations of 1 <= k <= 3 letters.
15:20:00 <dmwit> glguy: ...are you worried that some parts of lambdabot have stopped working?
15:20:11 <glguy> dmwit: I'm bored and showing Iavor how it works
15:22:14 <Toxaris> wli: ok. I remember radix tries to dynamically adapt the radix size to avoid collisions, but that may be another flavour of them.
15:22:46 <wli> Toxaris: That may also be done. Path compression is also typical.
15:23:06 <puusorsa> i wonder if hs-plugins is broken on bigendian or if i jsut ran the buildscripts wrong
15:25:03 <Toxaris> wli: oh now I understand, I hope, it's just like a radix tree, but instead of a list of 2^24 children per node, it's a reasonable sized hash table per node.
15:25:13 <wli> Toxaris: Exactly.
15:26:05 <wli> Toxaris: The principle is obvious enough; one could use binary trees in each node etc.
15:26:32 <wli> e.g. IntMap
15:27:35 * Toxaris has read too much of Hinze's stuff about generalized tries for memo functions to see tries as destructively updated data structures
15:28:06 <Toxaris> (or updated at all by anything except fmap)
15:36:27 * glguy set his font small enough that he can read 1 hours worth of channel history
15:37:43 * oerjan admires glguy's keen eyesight
15:38:03 <glguy> it helps that I have my monitor on its side
15:38:10 <proqesi`> maybe he just has a 30" monitor
15:39:17 <rehges> the last hour is only 3000 pixels high at a huge font size
15:39:21 * Toxaris has one of these brand-new irc-clients with scrolling-technology (tm)
15:39:56 <rehges> toxaris: hrm, i haven't used paper scrolls for centuries
15:40:08 <glguy> Toxaris: did you have to pay for it??
15:40:14 <rehges> hehe
15:41:56 <Toxaris> glguy: i'm kind of a beta tester, I only had to sell my email adress for it
15:42:45 <Toxaris> there are some features missing, though
15:43:05 <glguy> Toxaris: can't push 'd' more than once in a row?
15:43:59 <Toxaris> dddddddd?
15:44:06 <glguy> "I only had to sell my email adress for it"
15:44:13 <glguy> 'joke' ;)
15:44:19 <Toxaris> ohh ok
15:44:23 <glguy> " there are some features missing, though"
15:45:24 <Toxaris> address is really hard to spell correctly for native german speakers because of the german word "Adresse" :)
15:45:47 <Toxaris> wich means the same, is pronounced nearly the same, but spelled differently
15:46:15 <Toxaris> they deactivated the automatic translation feature for the beta version
15:46:48 <Toxaris> hi mnislaih
15:47:03 <mnislaih> hiya Toxaris
15:50:54 <Toxaris> i'm back at home from a short break during last week, have written another test at uni and tried to write a nice KMP stream consumer this afternoon, but failed miserably because I wasn't able to find any ByteStrings code corresponding to the stream fusion system outlined in "Rewriting Haskell Strings" :(
15:51:51 <Toxaris> but I've finally cleared my mind and started thinking about ICFP et.al. this year
15:52:39 <mnislaih> Toxaris: so coming or no ?
15:53:00 <Heffalump> did you look in GHC 6.7/the fps repo?
15:53:59 <Toxaris> Heffalump: I looked at this dons' site about ByteStrings http://www.cse.unsw.edu.au/~dons/fps.html
15:54:00 <lambdabot> Title: Data.ByteString
15:55:05 <Toxaris> mnislaih: my calender says "Yes" for 30.09 to 07.10 :)
15:55:23 <Toxaris> Heffalump: that is basically here http://www.cse.unsw.edu.au/~dons/code/fps/
15:55:23 <lambdabot> Title: Index of /~dons/code/fps
15:55:32 <mnislaih> awesome Toxaris ! it'll be cool to meet there :)
15:56:29 <Toxaris> but being a poor uni student who never was at a research conference, I wonder: can I pay for it?
15:57:33 <mnislaih> That's a good question Toxaris. I don't believe paying 300€ for ICFP is worth it
15:57:50 <mnislaih> ah ok,  less if you are a student
15:58:09 <Toxaris> we should have won this contest ;)
15:58:28 <Heffalump> Toxaris: ah, isn't that up to date?
15:59:21 <Toxaris> Heffalump: I cannot say what "up to date" is, but there's no data Step = Nil | Skip | Next ... as in the paper and in the List fusion repo
16:00:13 <Toxaris> instead stuff like (acc -> Word8 -> Maybe (acc, Word8)) is used
16:00:43 <Toxaris> wich seems to defeat the point about Skip values made in the paper
16:03:48 <Toxaris> mnislaih: it's 165 Euro for ICFP for students, wich is better then 300, but not exactly cheap either :(
16:04:37 <mux> wow, type-indexed products are nice, and I wouldn't have thought it would be implementable in haskell
16:05:34 <ortmage> mux: pointer to that?
16:06:17 <mux> well it's in the HList package on hackage, I heard about it by reading the paper on rHaskell here: http://www.informatik.uni-freiburg.de/~wehr/haskell/
16:06:18 <lambdabot> Title: Haskell Software
16:06:21 <mux> and well
16:06:26 <mux> ?where hlist
16:06:26 <lambdabot> http://homepages.cwi.nl/~ralf/HList
16:06:44 <ortmage> mux: thanks!
16:07:13 <mux> yw
16:13:40 <Toxaris> mnislaih: what is it like to attend such a conference? how much is it better then just reading the papers?
16:27:37 <lament> is there a function for taking the remainder Double `mod` Int?
16:28:39 <dibblego> ?where yaht
16:28:39 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:28:49 <mrd> :type rem
16:29:00 <mrd> :t rem
16:29:02 <lambdabot> forall a. (Integral a) => a -> a -> a
16:29:25 <lament> Double `mod` Double is also fine...
16:29:31 <mrd> :t mod
16:29:33 <lambdabot> forall a. (Integral a) => a -> a -> a
16:29:44 <mrd> you're expecting a Double result?
16:29:51 <lament> yes
16:30:11 <oerjan> :t properFraction
16:30:13 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
16:30:29 <mrd> > properFraction (2.718)
16:30:31 <lambdabot>  (2,0.718)
16:31:26 <mehrheit> properFraction (3%2)
16:31:36 <mehrheit> > properFraction (3%2)
16:31:38 <lambdabot>  (1,1%2)
16:31:47 <mrd> > properFraction 10.123 >>> ((`mod` 3) &&& id) >>> uncurry (+)
16:31:48 <lambdabot>      The section `(`mod` 3)' takes one argument,
16:31:48 <lambdabot>     but its type `(t, c)' ha...
16:32:13 <mrd> > properFraction 10.123 >>> ((`mod` 3) *** id) >>> uncurry (+)
16:32:13 <lambdabot>      The section `(`mod` 3)' takes one argument,
16:32:14 <lambdabot>     but its type `(b, c)' ha...
16:32:16 <oerjan> properFraction gives you the case mod 1, you should be able to build on that
16:32:16 <mrd> blah
16:32:51 <lament> yes, but that would make me cry
16:34:03 <lament> i just want to keep my angles within 2pi, which *ahem* in any other language would be angle % (pi * 2)
16:35:23 <mrd> > uncurry (+) (((fromIntegral . (`mod` 3)) *** id) (properFraction 10.123))
16:35:24 <lambdabot>  1.1229999999999993
16:35:31 <mrd> horrid=)
16:35:32 <tsp> lol, pi?
16:35:44 <tsp> > 4*(atan 1)
16:35:45 <lambdabot>  3.141592653589793
16:35:52 <tsp> is that as far as it goes?
16:36:02 <tsp> I thought that atan(1) went on forever.
16:36:20 <oerjan> Double is not infinite precision
16:36:24 <dolio> @type atan 1
16:36:24 <mehrheit> theres BigFloat for that
16:36:26 <lambdabot> forall t. (Floating t) => t
16:36:52 <Toxaris> > 4 * (atan 1) :: BigFloat -- like this?
16:36:53 <lambdabot>   Not in scope: type constructor or class `BigFloat'
16:37:00 <tsp> > BigFloat 4*(atan 1)
16:37:00 <lambdabot>   Not in scope: data constructor `BigFloat'
16:37:04 <tsp> ah, its in a module
16:37:17 <dolio> > pi
16:37:19 <lambdabot>  3.141592653589793
16:38:17 <tsp> pi is weird. Isn't it just the radius of a circle?
16:38:28 <Toxaris> tsp: not at all
16:38:54 <Toxaris> tsp: it's the ratio between the radius and half the perimeter of all circles
16:38:59 <samreid> yeah, the radius of a circle w/ circumference 2pi^2.
16:39:30 <Toxaris> hmm perimeter, no, not the correct word *searching*
16:39:34 <mehrheit> in soviet russia, circumference is called length
16:40:05 <tsp> what possible use could that be to anyone?
16:40:10 <Toxaris> *found* I actually meant perimeter
16:40:19 <Toxaris> but samreid meant area?
16:40:30 <dolio> What? What use is Pi?
16:40:41 <lament> mehrheit: (not really)
16:40:50 <dolio> It shows up all over the place.
16:40:57 <tsp> oh
16:41:00 <Lemmih> tsp: It's of no real use. It's just a novelty number.
16:41:01 <TSC> Toxaris: I think samreid meant that if r = pi, c = 2*pi*pi
16:41:13 <mehrheit> lament, how is it called then?
16:41:42 <lament> circumference
16:42:08 <tsp> > sum [10..20]
16:42:11 <lambdabot>  165
16:43:05 <Toxaris> TSC: oh indeed. and A = pi * pi * pi, but who cares for circles with r = pi?
16:43:36 <oerjan> Toxaris: i think samreid was joking
16:43:39 <Cale> hi
16:43:43 <mehrheit> lament, why, yes, you're right. that makes s/russia/lithuania
16:43:54 <Toxaris> the unit circle is all you need, everything else is done by transforming the space
16:44:19 <Toxaris> oerjan: hmm yes sounds probable... it may be time to go to bed for me
16:49:36 <dolio> pi even shows up in places where it's not obvious why it's there.
16:49:50 <dolio> For instance, in the mandelbrot set...
16:50:04 <dolio> For points on the line x = -0.75...
16:50:46 <dolio> If the point is C = -0.75 + ei, and n is the number of iterations to escape past 2...
16:50:48 <lament> well, um.
16:50:56 <dolio> Then lim_{e -> 0) (e*n) = pi.
16:51:02 <tsp> how do I tell if a number is prime? x%[1..10] != 1?
16:51:06 <tsp> != 0, that is
16:51:17 <lament> anything to do with complex numbers is pretty likely to have pi in it somewhere, for reasons that should be obvious
16:51:28 <dolio> I suppose so.
16:51:35 <lament> (the reason being IT'S A CONSPIRACY!!!!!)
16:51:43 <oerjan> tsp: how big a number?
16:51:49 <ihope> tsp: you can take it mod every number whose square is less than it.
16:51:54 <wli> e^(pi*i) + 1
16:52:03 <tsp> ah, that'll work
16:52:25 <wli> That's why complex numbers involve pi.
16:52:35 <tsp> to check if something like 511 is prime
16:52:38 <Spark> but not  e
16:52:44 <wli> tsp: Lucas-Lehmer?
16:52:54 <tsp> ?
16:53:00 <ihope> e^(x*i) = cos x + i sin x
16:53:03 <wli> tsp: wikipedia
16:53:06 <tsp> ah
16:53:31 <oerjan> tsp: testing primes depends a lot on how big your primes are
16:53:41 <ihope> For 511, checking numbers up to the square root is probably fine, as long as you don't need to do it many times.
16:53:58 <ihope> "Many" meaning... oh, a thousand or a million.
16:54:37 <ihope> And you'll certainly be near a thousand if you don't repeat a lot.
16:54:47 * wli will probably rewrite the ECM factorization bits in idiomatic Haskell.
16:56:03 <ihope> GFNS!
16:56:26 <wli> (It's rarely noted that the "standard" proof of e^(i*x) = cos(x) + i*sin(x) is circular logic.)
16:56:46 <ihope> The standard proof is circular logic?
16:56:54 <samreid> which standard proof?
16:56:58 <wli> ihope: Overkill. ECM is doable in under 100 LOC. GNFS is over the top.
16:57:01 * oerjan has since something like that noted
16:57:11 <wli> samreid: Power series expansions.
16:57:16 <Toxaris> is it lazy logic then?
16:57:25 <ihope> The power series proof is circular logic?
16:57:40 <chessguy> i wonder if there's an idiomatic haskellish way to represent the rules of chess moves
16:58:06 <ihope> Idiomatic Haskellish?
16:58:20 <chessguy> yeah, pardon my use of the technical term
16:58:24 <wli> ihope: Yeah. It ends up being circular wrt. finding the derivatives.
16:58:41 <wli> chessguy: Something involving nondeterminism monads is likely involved.
16:58:51 <chessguy> wli, why?
16:58:52 <ihope> The power series proof requires derivatives?
16:59:38 <Toxaris> chessguy: as functions (Int, Int) -> [(Int, Int)] for every piece?
17:00:02 <Toxaris> or is that, hmm, not haskellish enough (or not what you meant)
17:00:05 <ihope> e^(i*x) = 1 + ix/1 - x^2/2 - ix^3/6 + . . .
17:00:14 <oerjan> ihope: finding the power series of sin and cos requires finding their derivatives in 0
17:00:19 <chessguy> Toxaris, i think it flat out wouldn't work
17:00:29 <oerjan> and proving they are correct
17:00:32 <chessguy> Toxaris, because the legal moves are dependent on what's on the board too
17:00:35 <wli> ihope: Yes. If you do it formally, you fail to connect it to the positions on the unit circle (the geometric definition). If you rely directly on the derivatives for the power series expansion, you are in the same quandary.
17:00:56 <wli> oerjan: Right, and you're stuck computing derivatives from the geometric definitions. ;)
17:01:00 <ihope> How are sine and cosine defined without derivatives?
17:01:01 <oerjan> chessguy: as well as on some aspects of game history
17:01:04 <ihope> Er.
17:01:10 <ihope> Without their power series?
17:01:19 <chessguy> oerjan, yes, i'm well aware of that, thanks
17:01:24 <wli> ihope: Geometry, of course.
17:01:28 <Toxaris> chessguy: that would be the next step
17:01:37 <Toxaris> chessguy: but i see the problem
17:02:02 <chessguy> Toxaris, i was thinking of something like an ADTfor each type of move
17:02:27 <wli> One could try taking the power series as primitives and then proving they correspond to the geometric affairs somehow.
17:02:38 <Toxaris> chessguy: "type of move"?
17:02:41 <oerjan> basically it has do with the fact that the definition of the length of an arc is a rather subtle concept, at least as difficult as finding the derivatives themselves
17:02:43 <wli> But that step is left out, too.
17:03:03 <chessguy> like Slide Direction | PawnCapture Side | KnightMove, etc.
17:04:00 <wli> oerjan: That is a rather awkward aspect of the geometric proofs of the derivatives.
17:05:49 <ihope> Start with the power series, then prove that the solutions to x^2 + y^2 = 1 are sin(t) and cos(t) for all real t?
17:05:58 <Toxaris> chessguy: what about data Move = Move [(Int, Int)] | Capture [(Int, Int)] | Castling
17:06:28 <oerjan> well, that much is simple
17:06:41 <Toxaris> chessguy: with this meaning: Move [(Int, Int)] is a list of coordinates a piece touches, the last coordinate must be empty
17:06:51 <ihope> And then, if you like, that differentiating [sin t, cos t] with respect to t gives a vector with a magnitude of 1?
17:06:56 <chessguy> Toxaris, touches?
17:07:18 <Toxaris> chessguy: moves through... this fields on the board have to be empty for the move to be legal
17:07:49 <laz0r> does anyone know how to use HopenGL with ghc? i'm asking because I just tried to fool around with opengl; i installed a bunch of libghc6-opengl|glut|gl|x11-dev packages and i still get a module not found for GLU when i try to run one of examples from the HOpenGL homepage. I tried compiling the module manually, but that needs some other arcane things that i don't get to work..
17:07:56 <Toxaris> chessguy: the same for capture, but the last coordinate has to be occupied by an piece to be captured
17:08:07 <wli> ihope: Trick is that some of those theorems depend on the properties of sin and cos yet to be proven.
17:08:18 <Lemmih> laz0r: The HOpenGL website is outdated.
17:08:25 <Toxaris> chessguy: and castling is the remaining special move wich involves (1) checking the game history and (2) moving two pieces at once
17:08:38 <ihope> wli: some of the theorems I just gave?
17:08:41 <oerjan> Toxaris: en passant ?
17:08:49 <chessguy> there's also en passant, and promotions
17:08:50 <laz0r> Lemmih, ah ok, so where would i look when i wanted to use opengl?
17:09:28 <wli> ihope: Yes, like the derivatives wrt. arc length.
17:09:39 <oerjan> basically chess does its darndest not to be easily captured :)
17:09:41 <Lemmih> laz0r: http://darcs.haskell.org/packages/GLUT/examples/
17:09:43 <lambdabot> Title: Index of /packages/GLUT/examples
17:09:48 <Toxaris> oerjan, chessguy: hmm, ok en passant moves to one field, but captures a piece at another? too bad :(
17:09:49 <samreid> um, s/Castling/CastleKingSide | CastleQueenSide/ ?
17:10:01 <Toxaris> samreid: yes, simplified :)
17:10:04 <laz0r> Lemmih, thanks
17:10:12 <chessguy> Toxaris, yes, that's correct
17:10:15 <wli> Yeah, en passant is interesting.
17:10:26 <oerjan> Toxaris: also, it requires the captured piece to have moved in the previous move
17:10:27 <Excedrin> promote to a knight, checkmate
17:10:38 <wli> The 3-move repetition and 50 move rules are interesting, too.
17:11:12 <Toxaris> wli: these can be checked in a different step? first generate all moves, then filter legal moves?
17:11:25 <chessguy> the 3-move repetition rule is probably the hardest of any to implement
17:11:34 <ihope> wli: proving that the derivative has magnitude 1 requires some unproven property?
17:12:17 <Toxaris> Excedrin: checkmate is a move, not a condition of the gamestate?
17:12:19 <wli> ihope: No, proving that the derivative having magnitude 1 implies anything about sin and cos.
17:12:43 <Excedrin> huh
17:12:45 <wli> ihope: In particular wrt. uniqueness.
17:13:14 <wli> ihope: sn(x,k)^2 + cn(x,k)^2 = 1; why couldn't it be them?
17:13:25 <Cale> hehe, my comment is up to 145 points :)
17:13:26 <Excedrin> I was just saying that regarding unusual stuff, chess problems that involve promoting to a knight for mate are fun
17:13:36 <ihope> Ah.
17:14:00 <shachaf> @karma Cale
17:14:00 <lambdabot> Cale has a karma of 3
17:14:15 <Toxaris> so what about a general purpose move representation: data Move = Move {applicable :: GameState -> Bool, perform :: GameState -> GameState}
17:14:31 <Cale> (http://programming.reddit.com/info/2bxc1/comments/c2dins)
17:14:32 <lambdabot> Title: Ask Reddit: What is Haskell good for? (reddit.com)
17:15:52 <chessguy> Cale, save the seal!
17:16:07 <Cale> hehehe
17:16:18 <wli> ihope: Now those two don't really work because (d/dx) sn(x,k) = cn(x,k)*dn(x,k) and (d/dx) cn(x,k) = -sn(x,k)*dn(x,k), but why couldn't there be some other pair of functions f, g with the property f^2+g^2=1, (f')^2+(g')^2=1?
17:16:40 * ihope nods
17:17:42 <shachaf> Cale: Save the seal or else lambdabot gets it.
17:18:12 <Cale> Oh no! Now both the seal and lambdabot are in grave danger!
17:18:45 <shachaf> @botsnack
17:18:45 <lambdabot> :)
17:20:25 <Toxaris> chessguy: or what about a EDSL for gamestate changes, including guards for checking preconditions? then a move could be a program in this EDSL. like   promotion piece newpiece = guard $ atEnemiesHome piece >> destroy piece >> create newpiece (location piece)
17:21:30 <Toxaris> good night everyone
17:21:36 <chessguy> hm, that sounds interesting
17:23:43 <dmwit> Please don't get a blog.
17:24:11 <Cale> dmwit: hehe :)
17:24:22 <dmwit> I feel almost certain that a some of your quality is from only speaking when you have something to say -- something a blog discourages.
17:24:54 * shachaf hates the word "blog".
17:24:59 <chessguy> i think Cale almost always has something useful to say
17:25:08 <chessguy> more often than not, anyway
17:25:14 <Cale> Well, mostly I only speak in response to other things. Really what I should have is a reverse blog. Other people post stuff, and I comment on it.
17:25:33 <chessguy> Cale, make sure you get the patent :)
17:25:36 <dmwit> chessguy: Yeah, the other 90% of quality is being really, really smart. =)
17:26:10 <chessguy> @src isDigit
17:26:10 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:26:15 <chessguy> @hoogle digit
17:26:15 <lambdabot> Text.ParserCombinators.Parsec.Char.digit :: CharParser st Char
17:26:15 <lambdabot> Char.digitToInt :: Char -> Int
17:26:15 <lambdabot> Char.intToDigit :: Int -> Char
17:26:38 <chessguy> @hoogle Char -> Bool
17:26:38 <lambdabot> Char.isAlpha :: Char -> Bool
17:26:38 <lambdabot> Char.isAlphaNum :: Char -> Bool
17:26:38 <lambdabot> Char.isAscii :: Char -> Bool
17:26:45 <chessguy> @hoogle+
17:26:45 <lambdabot> Char.isControl :: Char -> Bool
17:26:45 <lambdabot> Char.isDigit :: Char -> Bool
17:26:45 <lambdabot> Char.isHexDigit :: Char -> Bool
17:26:51 * chessguy sighs
17:27:35 <chessguy> @src Char.isDigit
17:27:35 <lambdabot> Source not found. You type like i drive.
17:27:45 <shachaf> chessguy: Why do you need the source of isDigit?
17:28:03 <chessguy> shachaf, just curious whether it's implemented the same way i implemented it :)
17:28:19 <Saizan> @source Data.Char
17:28:20 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
17:29:02 <chessguy> Saizan, it's not in there
17:29:49 <chessguy> @source GHC.Base
17:29:49 <lambdabot> GHC.Base not available
17:29:52 <ddarius> Cale: LtU
17:30:17 <Cale> ddarius: hm?
17:30:42 <lament> how do i use (State foo) actions in (StateT foo IO bar)?
17:30:44 <ddarius> LtU is vaguely like that.
17:30:58 <Cale> Well, yeah, so is reddit :)
17:31:12 <Cale> But both of those have other commenters :)
17:31:27 <ddarius> Just more stuff to comment upon.
17:31:34 <shachaf> Is there any isDigit that takes Unicode into account?
17:31:36 <chessguy> @type lift
17:31:38 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
17:31:43 <ddarius> So Cale wants an Ask Cale site.
17:32:05 <chessguy> @type liftIO
17:32:06 <Cale> lament: You can't, but you can give them a more general type:  (MonadState foo m) => m a
17:32:07 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
17:32:09 <shachaf> Ask Cale!
17:32:15 <Saizan> lament: define your actions as MonadState foo m => m a instead of (State foo a)
17:32:16 <shachaf> Isn't that #haskell?
17:32:33 <ddarius> shachaf: No, there are other people to ask and other people to comment here.
17:33:09 <Cale> It needs the personal feel of a blog, but the communication goes the other way :)
17:33:13 <oerjan> there isn't really any reason why you couldn't "lift" from State to StateT, is there?
17:33:26 <shachaf> @quote Cale
17:33:26 <lambdabot> Cale says: I think we should take 0=1. Then 0 is invertible
17:33:28 <lament> oerjan: it's more like "drop" than "lift"  :)
17:33:37 <lament> Cale, Saizan: and after that I can just use them directly?
17:33:40 <Cale> Maybe I will set up something like Hope on my machine.
17:33:57 <Cale> lament: yeah
17:33:58 <shachaf> oerjan: You mean make a monad transformer out of a monad?
17:34:01 <wli> Hope needs a LaTeX plugin...
17:34:03 <bos> Dear Cale: my girlfriend suspects me of violating the monomorphism restriction when i fold her functor. how do i tell her to watch her language pragmas?
17:34:31 <shachaf> @instances MonadState
17:34:33 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
17:34:37 <oerjan> shachaf: no, but any action in State is like an action in StateT which doesn't use the underlying monad, isn't it?
17:34:57 <oerjan> so you should be able to convert
17:35:03 <shachaf> oerjan: Well, you can just write your functions for MonadState.
17:35:49 <shachaf> oerjan: Am I not understanding?
17:35:55 <dmwit> bos++ pretty good
17:35:56 <Saizan> oerjan: it's not so easy because functions are opaque
17:36:25 <wli> 0 is self-inverse in the additive group anyway.
17:37:14 <oerjan> :t mapStateT
17:37:16 <lambdabot> forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
17:37:28 <shachaf> > let f :: (MonadState Int m) => Int -> m Char; f x = do { modify (+x); return 'a' } in runState f 3
17:37:28 <lambdabot>      Non type-variable argument in the constraint: MonadState Int m
17:37:29 <lambdabot>     (Use ...
17:37:46 <Cale> wli: I was referring to the trivial ring
17:38:34 <SamB_XP> Cale: so you want a golb?
17:38:44 <wli> Well, identity = annihilator in a monoid has triviality as a consequence.
17:38:50 <Cale> SamB_XP: yep
17:39:40 <Saizan> mmh i suppose you can, liftT action = do x <- get; let (s,a) = runState action x; put s; return a
17:39:59 <Cale> Maybe what I should do is to set up a blog/CMS and only post links to replies I've made to comments elsewhere.
17:40:17 <SamB_XP> Cale: you probably should post copies of the comments
17:40:22 <SamB_XP> er.
17:40:24 <SamB_XP> replies
17:40:34 <SamB_XP> (possibly both?)
17:41:01 <oerjan> :t let liftT (State rs) = StateT (return . rs) in liftT
17:41:03 <lambdabot> forall t t1 (m :: * -> *). (Monad m) => State t t1 -> StateT t m t1
17:41:47 <shachaf> Cale: The problem is that there's often some context.
17:42:04 <shachaf> Cale: People would have to read some of the thread that led to your comment.
17:42:37 <ddarius> shachaf: If a thread is fairly usually, but not always, it's not worth following anyways.
17:42:38 <dibblego> is there an existing library somewhere that does memoising using unsafePerformIO?
17:42:47 <SamB_XP> shachaf: well, clearly a link to that and a short summary of the immediate context would be in order
17:43:00 <SamB_XP> and...
17:43:10 <SamB_XP> @google haskell-cafe migration
17:43:12 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Cafe_migration
17:43:12 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
17:43:12 <Cale> dibblego: The closest thing I can think of is a paper.
17:43:21 <dibblego> Cale, yeah, the one SPJ wrote
17:43:30 <Cale> dibblego: yeah
17:43:36 <Cale> http://research.microsoft.com/Users/simonpj/Papers/weak.htm
17:43:36 <dibblego> Cale, ok cheers
17:43:37 <lambdabot> Title: Simon Peyton Jones: papers
17:44:03 <Cale> There ought to be a library, really.
17:44:17 <Cale> With all sorts of common memo implementations.
17:45:24 <OceanSpray> LOL MICRO$OFT DOES RESEARCH?/
17:45:43 <proqesi`> um, no
17:45:45 <OceanSpray> ORZ THEY R STILL TEH SUK
17:45:54 <OceanSpray> KEKEKEKEKE
17:46:02 <OceanSpray> *ahem*
17:46:04 <OceanSpray> hi.
17:46:09 <shachaf> let f :: (MonadState Int m) => Int -> m Char; f x = do { modify (+x); return 'a' } in runIdentity $ runStateT (f 3) 5
17:46:27 <dibblego> Cale, I agree; I should write one if there isn't one (which is why I asked)
17:46:36 <shachaf> let f :: (MonadState Int m) => Int -> m Char; f x = do { modify (+(x::Int)); return 'a' }
17:46:43 <shachaf> Both work, with -fglasgow-exts.
17:46:50 <shachaf> oerjan: Is that what you meant?
17:47:02 <shachaf> Ignore the ::Int bit.
17:47:27 <oerjan> shachaf: see my :t above, i don't know it that's what lament was asking for
17:48:29 <SamB_XP> OceanSpray: both!
17:48:41 <SamB_XP> they do research AND they are still teh suck!
17:48:52 <oerjan> although lifting it to a general MonadState might be cool too
17:49:23 <Saizan> :t let  liftT action = do x <- get; let (s,a) = runState action x; put s; return a in liftT -- this is general
17:49:29 <dibblego> the research department is completely distinct from the suck department, is why
17:49:29 <lambdabot> parse error on input `;'
17:49:49 <Saizan> :t let  liftT action = do { x <- get; let (s,a) = runState action x; put s; return a} in liftT -- this is general
17:49:51 <lambdabot> parse error on input `;'
17:49:54 <Cale> dibblego: It kinda seems like Xerox PARC.
17:50:12 <dibblego> Cale, yeah, never thought of that
17:50:57 <Cale> What is with these companies that build research divisions and then proceed to ignore them? :)
17:51:09 <wli> Cale: I get the feeling research divisions are mostly patent lawsuit affairs.
17:51:11 <shachaf> :t let  liftT action = do { x <- get; let { (s,a) = runState action x }; put s; return a} in liftT -- You need this
17:51:12 <lambdabot> forall t (t1 :: * -> *). (MonadState t t1) => State t t -> t1 t
17:51:46 <wli> Cale: Zero to do with utilizing the results, unless you count slinging them around in a stack of potentially infringed patents as "usage."
17:51:57 <Cale> wli: Yeah, but you'd think they'd learn from the past -- think about where Xerox might be today if they'd listened to their research division? :)
17:52:24 <bitwize> Hello, scary unhealthy cultist people!
17:52:27 <wli> Cale: We'd have Xerox where Microsoft and Apple are now, of course.
17:53:01 <oerjan> shachaf: there are two wrongly identified type variables in there
17:53:05 <bitwize> :)
17:53:14 <oerjan> the state and the result shouldn't be the same
17:53:18 <shachaf> oerjan: All I did was add the {}.
17:53:43 <shachaf> oerjan: Talk to Saizan.
17:53:46 <samreid> for all you know they could have just priced too high
17:54:08 <Saizan> :t let  liftT action = do { x <- get; let { (a,s) = runState action x }; put s; return a} in liftT  -- i can never remeber the type of runState
17:54:10 <lambdabot> forall t t1 (t2 :: * -> *). (MonadState t t2) => State t t1 -> t2 t1
17:54:19 <Cale> It's like... "I know, we'll hire a bunch of really really smart people, and then ignore them completely, just using their results as material to defend against patent lawsuits."
17:54:20 <shachaf> Oh, (a,s) rather than (s,a).
17:54:53 <oerjan> all right then
17:55:38 <wli> Cale: And file patent lawsuits.
17:57:06 <Cale> Do they really file all that many? I know there are some companies which do that, but the ones which have real businesses too seem to just use the potential for filing a patent lawsuit to their advantage more than actually filing them.
17:57:37 <wli> Cale: Technology isn't going anywhere anyway. This will all be lost when the oil and coal run out. And yes, it's mostly the threats, not actual lawsuits.
17:57:48 <ricky_clarkson> MS is definitely on the evil side of patent battles, just by looking at the stuff against Linux.
18:01:58 <dibblego> everywhere :: (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a WTF is that?
18:02:24 <shachaf> dibblego: That's SYB, isn't it?
18:02:45 <bos> sure is.
18:02:52 <bitwize> SYB?
18:02:53 <dibblego> shachaf, that's what it purports to be, but what is that signature doing?
18:03:21 <bitwize> It maps functions from a1 onto itself, to functions from a onto itself, where a1 and a are both members of the Data typeclass.
18:03:26 <bitwize> ....I think.
18:03:28 <shachaf> > everywhere (==0) (Just 0,[0],0)
18:03:29 <lambdabot>   Not in scope: `everywhere'
18:03:49 <dibblego> I guess I have reading to do
18:03:53 <shachaf> dibblego: It's a nested forall, which lets a1 be different for each time the function is called.
18:04:02 * shachaf saw some nice slides about it some time ago.
18:04:04 <dibblego> is it H98?
18:04:07 <dibblego> shachaf, link?
18:04:11 <ddarius> no
18:04:13 <bos> @where syb
18:04:13 <lambdabot> I know nothing about syb.
18:04:17 <bos> @where boilerplate
18:04:17 <lambdabot> I know nothing about boilerplate.
18:04:22 <chessguy> @go haskell syb
18:04:22 <shachaf> dibblego: One moment.
18:04:24 <bos> @goo scrap your boilerplate
18:04:24 <lambdabot> http://lists.debian.org/debian-devel/2007/07/msg00316.html
18:04:24 <lambdabot> Title: Bug#432794: ITP: haskell-syb-with-class -- Haskell library for generic programmi ...
18:04:26 <lambdabot> http://www.cs.vu.nl/boilerplate/
18:04:27 <lambdabot> Title: Scrap your boilerplate ... in Haskell
18:04:32 <bos> ther.
18:04:32 <dibblego> http://www.cs.vu.nl/boilerplate/
18:04:32 <lambdabot> Title: Scrap your boilerplate ... in Haskell
18:04:44 <dibblego> shachaf, are the slides there?
18:04:47 <shachaf> dibblego: http://homepages.cwi.nl/~ralf/syb1/
18:04:48 <lambdabot> Title: Scrap your boilerplate: a practical design pattern for generic programming
18:04:53 <dibblego> thanks
18:04:59 <shachaf> dibblego: I think the .ppt was the one I saw. It opens in OO.o.
18:05:00 <bos> scrap your boilerplate is cool, but scrap your boilerplate with class is cooler.
18:05:08 <bos> read both papers.
18:05:12 <dibblego> ok
18:05:18 * shachaf has not really looked into either one.
18:05:27 <shachaf> Very much.
18:05:32 <shachaf> But it does look nice.
18:06:18 <araujo> <TimToady> if a billionaire hired about 300 of us to work on it fulltime, we could probably have it done by this Christmas --- when somebody asked about the perl6 release
18:06:20 <araujo> hah
18:06:30 <shachaf> bos: What about Paper #2 there?
18:06:48 <shachaf> bos: Scrap more boilerplate?
18:07:02 <shachaf> bos: Oh, will RWH talk about SYB, at all?
18:07:55 <bos> yes, it will.
18:08:20 * shachaf is not surprised. :-)
18:08:30 <shachaf> bos++
18:09:51 <bitwize> araujo: only languages like C# get that kind of attention and funding
18:13:40 <OceanSpray> LispVal = Null
18:13:42 <OceanSpray> ...
18:13:50 <shachaf> OceanSpray: What?
18:14:00 <OceanSpray>             | Environment Environment
18:14:00 <OceanSpray>                (IORef (Map (IORef String) (IORef LispVal)))
18:14:19 <ddarius> That looks pretty jacked.
18:14:22 <OceanSpray> Which IORef should I remove?
18:14:28 <OceanSpray> actually
18:14:32 <OceanSpray> is that even correct?
18:15:42 <OceanSpray> guys?
18:15:53 <OceanSpray> help a n00b out here
18:16:14 <samreid> um... what are you trying to do?
18:16:33 <OceanSpray> represent first-class environments in a lisp implementation.
18:16:56 <OceanSpray> where modifying a value and modifying a binding are two different actions.
18:17:02 <samreid> don't know how you intend to make a Map of IORefs...
18:17:23 <samreid> So at least that would be IORef (Map String (IORef LispVal))
18:17:35 <OceanSpray> that's what I got now
18:17:41 <OceanSpray> what else?
18:18:39 <samreid> I'm not really sure what the 'Environment' type is.
18:18:41 <wli> I'd use an STRef, but that's just me.
18:18:54 <OceanSpray>              | Environment (LispVal Environment)               (IORef (Map String (IORef LispVal)))
18:19:11 <OceanSpray> is that a bit clearer?
18:19:25 <ddarius> No, now it's broken.
18:19:34 <samreid> now that makes no sense.  You have LispVal = ..., but then inside you have type of (LispVal Environment).  How?
18:19:44 <OceanSpray> whoops
18:20:04 <OceanSpray> I just want an environment to have a pointer to its parent environment
18:20:48 <ddarius> OceanSpray: Describe environments as a separate type then just include an injection into the type of values.
18:21:12 <OceanSpray> ok
18:21:40 <OceanSpray> can I have a 'where' in a 'data = ...' declaration?
18:21:59 <ddarius> OceanSpray: No, but you shouldn't need too.
18:23:30 <Cale> dons: You around?
18:23:34 <wli> An imperative variable is an identifier for a memory cell location. An environment is an injective mapping from identifiers to memory cell locations. A memory cell is a discriminated union of the possible values for variables to take on. A memory cell location is a reference to it, e.g. an array index or STRef etc. So the ontology looks off to me.
18:23:50 <OceanSpray> ok then, I'll use STRefs
18:24:09 <wli> Well, STRef vs. IORef is not so important.
18:24:11 <Cale> injective?
18:24:19 <dons> Cale?
18:24:38 <ddarius> wli: Definitely not injective.
18:24:44 <wli> Cale: There's only one memory cell location corresponding to a given variable within an environment.
18:24:47 <Cale> dons: Were you writing a tutorial which showed how Haskell manipulates functions like Perl manipulates strings?
18:24:55 <dons> not yet, just thinking about it
18:25:00 <Cale> !paste
18:25:00 <hpaste> Haskell paste bin: http://hpaste.org/
18:25:08 <dons> trying to get it right in my head first.
18:25:13 <ddarius> wli: All aliases have to go through an "extra" level of indirection?
18:25:14 <wli> ddarius: Multivalued variables? That's for logic programming.
18:25:28 <OceanSpray> what's going on?
18:25:37 <OceanSpray> I'm so damn confused.
18:26:01 <OceanSpray> After the parser got done, everything went downhill
18:26:14 <hpaste>  Cale pasted "a nice example" at http://hpaste.org/2169
18:27:14 <dons> nice stuff Cale
18:27:20 <Cale> In some sense, it's a little trivial, because yes, you could pull that search key out and make it a parameter.
18:27:38 <Cale> But I rather like the idea that what it's really doing is directly transforming the tree into a function.
18:27:57 <wli> ddarius: Scratch injective, sorry. Functional relation blah blah blah.
18:28:12 <Cale> By replacing the constructors so they actually build functions rather than trees.
18:28:34 <OceanSpray> type Environment = (Environment, (STRef (Map String (STRef LispVal)))) --how's about this?
18:28:58 <shachaf> OceanSpray: type T = (T,...)?
18:29:09 <shachaf> OceanSpray: Type aliases can't be recursive.
18:29:20 <OceanSpray> oh, damn
18:29:23 <samreid> OceanSpray: how about  data Environment = Environment { parentEnviron :: Environment, foo :: STRef (Map ....) }
18:30:01 <OceanSpray> oh screw it
18:30:06 <sethk> Cale, very compact, I like it.  I have to figure out how it works, but I like it.  :)
18:30:16 <OceanSpray> I'll just have the LispVal declaration handle parent environments.
18:30:22 <lament> How do I make this work?
18:30:23 <lament> data ShowBox = forall s. Show s => SB s
18:30:23 <lament> unbox (SB stuff) = stuff
18:30:37 <lament> (ShowBox works; unbox doesn't)
18:31:28 <wli> Supposing that parent environments aren't rebindable, shouldn't it be this? data Environment = Environment { parentEnvironment = Maybe Environment, localBindings = Map String (STRef LispVal) }
18:31:30 <ddarius> lament: You can't let the type variable s escape.
18:31:39 <Cale> sethk: The rest of the story is given here: http://programming.reddit.com/info/2bxc1/comments/c2dkol
18:31:40 <lambdabot> Title: Ask Reddit: What is Haskell good for? (reddit.com)
18:31:51 <OceanSpray> now you're just confusing me even more
18:31:53 <wli> STRef s LispVal
18:31:53 <lament> ddarius: so there's no way to do this?
18:31:55 <OceanSpray> what's this Maybe?
18:32:03 <sethk> Cale, thanks
18:32:08 <ddarius> lament: That's the whole basis of existential types.
18:32:09 <wli> OceanSpray: The top-level environment has no parent.
18:32:18 <samreid> lament: try writing its type signature :)
18:32:20 <OceanSpray> yes.
18:32:22 <OceanSpray> oh
18:32:23 <OceanSpray> right
18:32:40 <wli> s/=/::/
18:32:43 <wli> blah
18:33:25 <lament> samreid: heh heh, exists a. (Show a) => ShowBox -> a
18:33:29 <sethk> Is visual haskell still active?  I've had to give in and keep a windows box (to use VPN software that one of my clients uses), so I was thinking about looking at it.
18:33:39 <lament> ddarius: but i want to :(
18:34:07 <Cale> Oops, hehe, there was a bug in my post all this time, and nobody bothered to point it out :)
18:34:31 <Cale> (I suppose it was fairly minor, the sort of thing which a typechecker would catch :)
18:34:32 <oerjan> lament: alas, haskell does not have unencapsulated existentials, so exists a. cannot be on a function.
18:34:37 <oerjan> afaiu
18:34:48 <lament> :(
18:35:06 <oerjan> otoh think of it this way:
18:35:25 <Cale> sethk: (so refresh)
18:35:29 <oerjan> ShowBox is in fact itself the function you want, just wrapped in a type
18:35:33 <OceanSpray> hm, STRefs need a thread
18:36:03 <sethk> Cale, thanks, I have now refreshed.
18:36:17 <lament> oerjan: it seems somewhat of an artificial restriction
18:36:28 <sethk> OceanSpray, hm?  You are always in a thread, even if it is the only one.
18:36:32 <lament> oerjan: i guess i just don't understand why can't type classes be used everywhere where types are
18:36:33 <wli> OceanSpray: "state thread s" does not refer to that sort of thread.
18:36:41 <Cale> In the second form of preorder, I'd written:
18:36:46 <Cale> preorder = foldTree id (\x l r -> (x:) . l . r) []
18:36:46 <sethk> lament, it's not overlooked, there are major implementation issues.
18:36:51 <Cale> when I meant to write
18:36:54 <Cale> preorder t = foldTree id (\x l r -> (x:) . l . r) t []
18:36:58 <oerjan> oh...
18:37:05 <oerjan> lament: there is a trick you could use
18:37:25 <oerjan> define a Show instance for ShowBox itself
18:38:00 <lament> oerjan: right, but this is just an example, i have a hierarchy of stuff
18:38:20 <ddarius> lament: Where did type classes come into this?
18:38:59 <lament> ddarius: Show, in this case
18:39:02 <oerjan> it might be nice if you could use something like newtype deriving for this...
18:39:08 <OceanSpray> so how do I get the "current thread" with which to use STRef?
18:39:22 <OceanSpray> wait... what?
18:39:39 <sethk> lament, it would be a very powerful feature. You'll see if you search a bit that it may be impractical to implement.
18:39:44 <ddarius> lament: What about this prompted you to say that you "don't understand why can't type classes be used everywhere where types are"?
18:40:11 <RyanT5000> is there a way to cheaply divide a Double by two?
18:40:23 <ddarius> decrement the exponent!
18:40:33 <RyanT5000> ddarius: right; how would i do that in haskell?
18:40:52 <Cale> I suppose you can use encodeFloat/decodeFloat
18:40:53 <RyanT5000> ddarius: also, while that makes sense to me, i'm not sure if IEEE has something else to say abou tit
18:40:55 <ddarius> RyanT5000: I doubt it would be quicker to do it in assembly.
18:41:04 <OceanSpray> data RealWorld
18:41:04 <OceanSpray> RealWorld is deeply magical.
18:41:06 <lament> ddarius: because that's what i really want, an easy way to (for example) have a list of things for which nothing is known other that they're values of instances of some type class
18:41:08 <OceanSpray> oh wow
18:41:24 <OceanSpray> that's some quality documentation right thar.
18:41:38 <RyanT5000> Cale: will that be fast? i'm trying to get our spectral-norm benchmark better
18:41:43 <ddarius> OceanSpray: That's more than you need to know about it.
18:41:46 <lament> ddarius: i guess i'm just too used to OO, because i can think of no other good way to structure code for a hierarchy of similar objects
18:41:48 <shachaf> lament: Existential types?
18:41:54 <Cale> RyanT5000: I have no idea
18:42:06 <oerjan> RyanT5000: scaleFloat
18:42:07 <ddarius> lament: Existential types, which are what you are using, are exactly what you want.
18:42:07 <RyanT5000> Cale: there's an apparently extraneous (/2) in it, which is the only thing i've seen so far deserving removal
18:42:15 <ddarius> Well, probably not exactly as you probably want subtyping too.
18:42:31 <lament> subtyping is O'Haskell?
18:42:31 <RyanT5000> oerjan: sweet :)
18:42:42 <Cale> > uncurry encodeFloat . second (subtract 1) . decodeFloat $ 4.6532
18:42:44 <lambdabot>  2.3266
18:42:52 <ddarius> lament: O'Haskell did support one form of subtyping.
18:43:15 <Cale> oh, I'd forgotten about scaleFloat :)
18:43:24 <yetAnotherOne> O'Haskell seems to be dead
18:43:31 <Cale> > scaleFloat (-1) 4.6532
18:43:33 <lambdabot>  2.3266
18:43:47 <ddarius> yetAnotherOne: Hence me using the past tense.  It was somewhat succeeded by Timber.
18:43:53 <lament> ddarius: so how do people do this kind of stuff, switch statements?
18:44:13 <RyanT5000> Cale: interesting: it's *way* slower
18:44:38 <ddarius> lament: All subtyping gives you is implicit coercions.  You can use existentials for this, you just have to explicitly "coerce" them to the "existential box".
18:44:38 <Cale> RyanT5000: Probably because nobody ever uses it.
18:44:53 <ddarius> :t scaleFloat
18:44:55 <lambdabot> forall a. (RealFloat a) => Int -> a -> a
18:45:15 <RyanT5000> Cale: lame; is it possible ghc is already optimizing the (/2) into an exponent decrement?
18:45:29 <ddarius> lament: But to be honest, even uses of existentials are fairly rare.
18:45:51 <ddarius> RyanT5000: For floating point stuff, GHC should just be passing it to gcc.
18:45:59 <Cale> RyanT5000: seems quite possible.
18:46:02 <RyanT5000> ddarius: ah, that would probably explain it
18:46:05 <ddarius> Further, as I said, I would not be surprised if fdiv is the fastest way.
18:46:15 <RyanT5000> i still have to figure out why our solution is 18 times slower than the C++ one though
18:46:27 <lament> ddarius: so what's the Haskelly solution for the "gigantic switch statements" problem that OO claims to solve with subclasses?
18:46:53 <RyanT5000> lament: passing functions
18:47:01 <RyanT5000> lament: closures in general
18:47:11 <ddarius> lament: A lot of time, switch statements.
18:47:18 <RyanT5000> that too
18:47:19 <RyanT5000> lol
18:47:22 <ddarius> lament: What do you think pattern matching is?
18:47:24 <lament> that can't be good
18:47:58 <sethk> lament, switch statements generated by the compiler are ok.  It's humans who can't code switch statements properly.  :)
18:48:29 <ddarius> lament: Often type classes are suitable.  Often you don't need -dynamic- dispatch.
18:48:44 <wli> RyanT5000: What's 18 times slower than the C++ what?
18:48:46 <lament> well, suppose i have a game with many kinds of monsters.
18:49:00 <lament> i'm sure that's a common situation :)
18:49:02 <RyanT5000> wli: our solution to the shootout's spectral-norm
18:49:19 <ddarius> lament: You package up the actions on monsters with them much like OO.
18:49:34 <ddarius> And/or use typeclasses.
18:49:37 <sethk> RyanT5000, profiling should at the least point you in the right direction (profiling the generated c++ code, not the haskell code)
18:49:41 <RyanT5000> ddarius: i don't buy the "just build your own vtable" argument; you could do that in c
18:49:45 <oerjan> lament: anyway the way to take apart a ShowBox is with a case statement, you just cannot let the type escape from it
18:50:09 <RyanT5000> sethk: there's one function that uses 99.1% of the time, and it's a single arithmetic expression and two integer->float casts
18:50:15 <ddarius> RyanT5000: I said nothing about dynamic dispatch or vtables.  It's quite natural to have functions in records in a functional language.
18:50:33 <lament> ddarius: data Monster = Monster {behavior::(Environment->Environment},...}, something like that?
18:50:36 <sethk> RyanT5000, hmm.  Get the mixed c++/assembler listing and see what is really going on there.
18:50:51 <RyanT5000> ddarius: that's true, but if he's looking for hierarchical things, typeclasses are probably the way to go
18:51:09 <RyanT5000> (with existentials
18:51:10 <RyanT5000> )
18:51:37 <RyanT5000> lament: yeah, that kind of thing, although i'm not sure about "Environment->Environment" - that sounds scary
18:51:43 <lament> well, no, right
18:51:56 <ddarius> lament: Probably somewhat varied from that, but more or less.  For example, with your show example, ignoring shows all you could do with a existential value bounded by Show is apply show to it, i.e. you don't need the existential, just store the String.
18:52:10 <reffie> let's play global thermonuclear war
18:52:17 <wli> RyanT5000: Numerical code is dull and just pounds things repeatedly in loops.
18:52:28 <ddarius> reffie: I call first turn.
18:52:28 <RyanT5000> wli: indeed
18:52:37 <lament> RyanT5000: well, at least Monster->Monster
18:52:42 <wli> RyanT5000: So odds are that really is the overhead.
18:53:17 <RyanT5000> wli: yeah, but it has to be fixable somehow; i can't abide haskell losing by 18x :P
18:53:23 <wli> lament: I'd think one would try to break down the ontology of monsters further.
18:53:26 <ddarius> lament: One point of reference is in O'Caml, it's object features are not used all that much (from what I hear).  (Though, they certainly aren't unused.)
18:54:01 <wli> RyanT5000: What integers are being casted to float?
18:54:03 <lament> wli: with typeclasses?
18:54:14 <RyanT5000> wli: Int -> Double, using fromIntegral
18:54:21 <wli> lament: Not necessarily.
18:54:45 <wli> RyanT5000: Yeah, but can those integers be made Double in the first place? Or the conversion hoisted out of a loop?
18:55:16 <RyanT5000> wli: well, they're also indexes into an array, so there's going to have to be a conversion somewhere
18:55:21 <dmwit> What is a "rigid type variable"?
18:55:23 <RyanT5000> wli: also, there's some dubious unsafeAccumArray action going on
18:55:42 <RyanT5000> wli: i'm thinking it might benefit from some ST conversion
18:55:54 <RyanT5000> wli: although the loop is already so tight it might not matter
18:56:22 <RyanT5000> could unsafeAccumArray throw off the profiler?
18:56:25 <wli> RyanT5000: What kind of array is it using now?
18:56:30 <RyanT5000> UArray
18:56:39 <wli> RyanT5000: I'd expect that it'd throw off the optimizer worse.
18:57:51 <wli> RyanT5000: I'm not the optimization expert here. I've heard that monadic affairs aren't necessarily faster so ST might not be an improvement.
18:59:40 <RyanT5000> wli: right now i'm trying to figure out why he's using unsafeAccumArray anyway
19:04:02 <RyanT5000> oh
19:04:14 <RyanT5000> the other implementations seem to be doing the multiply in-place
19:04:20 <RyanT5000> which probably gives vastly superior cache-locality
19:32:21 <ddarius> Template Haskell is a common extension?
19:33:18 <RyanT5000> ddarius: ghc-only, i thought
19:33:36 <RyanT5000> then again, i never paid much attention to anything else
19:35:22 <OceanSpray> ok, I've given up.
19:35:34 <OceanSpray> I will leave writing the interpreter now
19:35:43 <OceanSpray> and first learn Haskell "properly"
19:35:57 <OceanSpray> gentle introduction, here I come
19:36:16 <dmwit> You go girl!
19:36:29 <dmwit> The Gentle Intro is my favorite.
19:36:49 <johnnowak> dmwit: why might I ask? i've only done yaht.
19:37:41 <dmwit> Dunno?
19:37:47 <dmwit> Because it was the first one I ever looked at?
19:38:09 <dmwit> Also, I feel like it pretty much just throws you in and expects you to think hard enough to figure stuff out.
19:38:10 <dmwit> I like that.
19:38:21 <OceanSpray> protip: never try to learn a language as alien as Haskell without a proper guide.
19:38:23 <jfredett> johnnowak: I like both equally, but I think GIH is a little faster paced than YAHT
19:39:19 <dmwit> I get bored with tutorials that set silly exercises; I almost never do them anyway.
19:39:19 <RyanT5000> that just means you can skip more in yaht ;)
19:39:30 <OceanSpray> I bit off more than I can chew by taking on a project and looking at tidbits here and there as I go along.
19:39:40 <jfredett> OceanSpray: you forgot to say, "and remember, Dont Panic."
19:40:42 <shapr> @yow !
19:40:42 <lambdabot> If I pull this SWITCH I'll be RITA HAYWORTH!!  Or a SCIENTOLOGIST!
19:42:27 <reltuk> wow, that's a lot of people...
19:43:29 <dons> ?users
19:43:29 <lambdabot> Maximum users seen in #haskell: 375, currently: 326 (86.9%), active: 12 (3.7%)
19:44:13 <ddarius> @flush
19:44:13 <lambdabot> Not enough privileges
19:45:00 <Binkley> ?quote
19:45:00 <lambdabot> SyntaxNinja says: I recommend seeing if people have a major problem, then pouring concrete on them, and implementing what you want anyway ;)
19:45:26 <ddarius> Enjoy David Pollack's email in the regressive view thread, dons?
19:48:35 <dons> ddarius: it was nice, yeah
19:49:54 * SamB_XP wonders if SyntaxNinja was giving ndm advice on the FilePath library 
19:54:03 <sjanssen> SamB_XP: actually, it might have been
19:54:09 <sjanssen> I remember that quote, lemme grep for it
19:54:54 <lament> ?quote
19:54:54 <lambdabot> sebazzz says: <sebazzz> vos no te diste cuenta, pero cuando estas en pedo, y si yo estoy, te saco del alcanse todo objeto contundente
19:55:16 <ddarius> That's a really old quote.
19:55:36 <lament> what's contundente?
19:55:39 <ddarius> (SyntaxNinja's that is.)
19:56:14 <sjanssen> SamB_XP: actually, it was Cabal configurations
19:56:31 <sjanssen> from 06.09.06
19:56:44 <SamB_XP> oooh, that sounds like an even MORE appropriate situation for that suggestion
19:56:54 <SamB_XP> I had not though this possible!
19:57:48 <lament> i don't get the spanish quote at all
19:58:58 <lament> oh, got it. Not funny.
20:01:33 <dons> hey geezusfreeek. got your smp threads going?
20:01:39 <shapr> mmm, code
20:01:45 <dons> tasty.
20:01:59 <Nafai> Hey shapr, dons!
20:02:18 <dons> hi Nafai
20:04:55 <shapr> hiya Nafai
20:07:52 <dons> ?users #xmonad
20:07:52 <lambdabot> Maximum users seen in #xmonad: 59, currently: 53 (89.8%), active: 5 (9.4%)
20:08:05 <dons> ?users #perl6
20:08:05 <lambdabot> Maximum users seen in #perl6: 158, currently: 137 (86.7%), active: 1 (0.7%)
20:08:09 <dons> closing in...
20:08:11 <dons> ;)
20:08:27 <Spark> ?users #tcl
20:08:28 <lambdabot> Maximum users seen in #tcl: 1, currently: 0 (0.0%), active: 0 (NaN%)
20:08:33 <Spark> heh
20:08:57 <dons> #tcl Current: 51, Avg: 51, Max: 68
20:09:37 <dons> #ocaml Current: 55, Avg: 56, Max: 72
20:09:57 <dons> shapr: we should write a book about building online communities around open source projects one day.
20:10:09 <Spark> ocaml > tcl
20:10:12 <Spark> intriguing
20:10:27 <dons> tcl should have been on that "12 dead languages" list :)
20:10:30 <ddarius> Spark: haskell > tcl
20:10:50 <jcreigh> @quote ProgrammingLanguage
20:10:50 <lambdabot> No quotes match. Just what do you think you're doing Dave?
20:11:02 <jcreigh> ah, can't find it. Kinda vain to quote myself anyway.
20:11:07 <ddarius> @quote Programming.Language
20:11:08 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
20:11:21 <shapr> dons: truly
20:11:26 <Spark> daft quote
20:11:39 <shapr> hm, hack or sleep?
20:11:46 <Spark> both
20:11:52 <shapr> I can't code while sleeping :-(
20:12:05 <Spark> relax your eyes and muscles whilst coding
20:12:20 <Spark> make fewer typos, so you don't have to look at the screen as much
20:12:29 <Spark> try not to dream, or your dreams might make their way into the code
20:14:16 <shapr> Spark: I'd like that actually.
20:14:37 <shapr> Yesterday I was dreaming about number theory. Comes from reading http://www.myreckonings.com/Dead_Reckoning/Dead_Reckoning.htm before bed.
20:14:38 <lambdabot> Title: Dead Reckoning: Calculating Without Instruments
20:14:51 <Spark> heh
20:14:53 <shapr> I still can't do division :-(
20:15:17 <shapr> But I can multiply two three digit numbers just fine without losing track.
20:15:48 <Spark> 333*222
20:16:27 <shapr> (a + b) * (a + c) = a(a + b + c) + bc
20:17:58 * shapr very slowly crunches along...
20:19:22 <shapr> 73926?
20:19:28 <shapr> > 333 * 222
20:19:29 <Spark> i'm stuck on 133*22
20:19:30 <lambdabot>  73926
20:19:45 <Spark> what did you pick for a and b
20:19:52 <shapr> I changed my approach, actually.
20:19:52 <Spark> and c
20:19:55 <Spark> heh
20:20:02 <Spark> you're such a prolog interpreter
20:20:10 <shapr> For numbers abc * xyz you can per-digit solutions.
20:20:19 <shapr> z * c is the ones digit
20:20:34 <shapr> z * b + y * c is the tens digit
20:21:07 <shapr> a * z + b * y + x * c is the hundreds digit.
20:21:18 <shapr> (of course, you have to carry anything over ten)
20:21:51 <shapr> a * y + b * x is the thousands digit, and x * a is the ten thousands digit.
20:21:56 <shapr> It's a pretty patter.n
20:22:08 <Spark> heh
20:22:16 <Spark> reminds me of pascals triangle
20:22:54 <shapr> I'm always glad when I get the answers right. The first few days I tried this, I often didn't. My short term memory would fail and I'd get some numbers wrong.
20:23:04 <Spark> it's like the rubix cube
20:23:09 <Spark> you have to have a stack in your mind
20:23:19 <Cale> 333*222 = 6*(111)^2 = 6*12321 -- there's a few carries to keep track of there, but it's not so bad
20:23:23 <Spark> that you can unwind at a moment's notice
20:23:29 <shapr> If you haven't already you should read Dead Reckoning. Any book that cites Hofstadter, Knuth, and Feynman can't be all bad.
20:23:40 <ddarius> It's convolution.
20:24:17 <shapr> Reading it isn't as much fun as actually doing all this stuff.
20:24:40 <Spark> it's a neat party trick
20:24:43 <jcreigh> hmm, I never did manage to solve a Rubik's cube...
20:24:45 <shapr> I still suck at mental division, that's whan I'm working on now.
20:24:50 <Spark> except that noone is able to validate your answer
20:25:08 <jcreigh> nothing without top-secret alien technology, like a pocket calculator.
20:25:12 <jcreigh> s/nothing/not/
20:25:16 <ddarius> Getting 12321 from 111*111 is something that jumps out immediately when you think convolution.
20:26:10 <shapr> This first chapter has addition, subtraction, multiplication, division, gcd, error-checking and divisibility tests, and factorization.
20:26:25 <ddarius> A square filter convolved with itself makes a triangular filter.
20:26:46 <shapr> The three chapters after that are roots, logarithms and their inverses, and trigonometric functions and their inverses.
20:26:52 * ddarius tends to add digit by digit and fix it up afterwards.
20:27:19 <RyanT5000> ddarius: that's basically how fft yields fast large multiplies, right?
20:27:25 <dons> AngloHaskell is on today.
20:27:32 <dons> Anyone attending? Do we get videos?
20:27:37 <RyanT5000> ddarius: digit-by-digit add, followed by a huge array of really complicated fixup tricks
20:27:39 <ddarius> RyanT5000: It's related to that yes.
20:27:47 <ddarius> Oh, that.
20:29:44 <ddarius> RyanT5000: Multiplying a decimal number is convolving it's digits, so FFT/pointwise multiply/inverse FFT
20:30:36 <RyanT5000> ddarius: right, but there's something involving precision that makes it particularly hard, iirc
20:33:14 <gwern> fetch
20:34:04 * shapr brings gwern a newspaper
20:34:13 <ddarius> Hmm, a NTT mod 2...
20:35:44 <tsp> > 1.5*10
20:35:46 <lambdabot>  15.0
20:35:46 * gwern reads the newspaper. my god, the credit markets are melting down as foretold - central banks are panicing! russia is attacking georgia! lindsay lohan disapears!
20:35:58 <tsp> I never fiured out how that works
20:36:36 <ddarius> An optical "computer" would be very handy for teaching a bunch of things.  Very visceral.
20:37:03 <dons> anyone notice something unusual about this: http://www.bestechvideos.com/
20:37:05 <lambdabot> Title: BestTechVideos :: Tech Videos, Screencasts, Tutorials, Webinars, Techtalks, Tuto ...
20:37:09 <tsp> > 1.5/10
20:37:10 <lambdabot>  0.15
20:37:41 <goalieca> the quantum and gate: the kitten is both alive and dead.
20:37:52 <goalieca> optical: it went through both holes
20:37:59 <goalieca> until you figure out which one
20:38:40 <dmwit> dons: The Facebook is a bit of a sore thumb between the functional programming/STM stuff.
20:38:54 <dmwit> Other than that... no?
20:39:00 <ddarius> All I need is a diffraction grating and two lenses...
20:39:24 <dons> dmwit: oh, just funny to see 3 haskell videos on the front page of some random site
20:39:39 <dmwit> aha
20:40:12 <Korollary> latest videos
20:41:03 <thoughtpolice> is there any way other than like a small ncurses interface (such as in system.io?) to have your code print to one area of the terminal screen, but get input from another? that's kind of vague but the idea is I want my bot to be able to output info and whatnot on the terminal, but to have readline used to get commands from when it's started; only thing is it'll print right in the middle of the line you're printing on.
20:41:36 <dons> thoughtpolice: you need termio, or a curses binding (or vty)
20:41:40 <thoughtpolice> basically I want my code to print to the lines on the screen *except* the last one, since that's where I'll be reading input from, so they don't interfere
20:42:15 <dons> sounds like a job for curses
20:42:23 <thoughtpolice> that's what I figured
20:42:35 <dons> you got hscurses, or the hmp3 curses binding?
20:42:38 <thoughtpolice> dons: i think I'll just try and pull the hmp3 stuff. less dependencies.
20:42:43 <dons> i might whip up a mini curses in a few weeks.
20:42:54 <thoughtpolice> i actually have hscurses on here but I haven't had time to mess around
20:43:02 <dons> yeah, rip out Curses.hsc from hmp3, and you get cheap bytestring curses io
20:43:13 <thoughtpolice> cool beans.
20:44:25 <thoughtpolice> dons: btw, plugins is apparently working nicely for this bot. i have it dynamically compile and load my plugins. i got a very arcane ghc error though, but it went away. i'm not sure at all what caused it. :/
20:45:17 <thoughtpolice> the weird thing was in my plugins tests it worked exactly how I wanted... when I pulled it into the bot code it failed, and after just fiddling with a few things the errors stopped.
20:45:22 <thoughtpolice> it was really pretty weird. some stg err.
20:48:17 <dons> hmm.
20:48:28 <dons> i have to admit i'm not trying very hard to maintain hs-plugins
20:48:36 <dons> basically, i just fiddle with it to ensure lambdabot works
20:49:06 <thoughtpolice> hah. it's cool. i'm having fun with it anyway.
20:49:18 <mrd> heh i've been using hs plugins too
20:49:23 <mrd> just did the dynamic bootstrap thing
20:49:25 <thoughtpolice> i would use the ghci api but like I said, scary. :(
20:49:30 <thoughtpolice> s/ghci/ghc/
20:49:37 <dons> yeah, the long term solution is to move most of the code into ghc-api
20:49:45 <shapr> What's scary about ghc-api?
20:49:48 <shapr> undocumented?
20:50:10 <dons> yeah, its not that scary thoough. hs-plugins is also pretty scary
20:50:18 <RyanT5000> how does one go about seeing GHC's choices as far as list fusion and strictness annotations are concerned?
20:50:38 <mrd> i've been doing ok with the *All functions
20:50:52 <mrd> they're much more convenient than the ghc api iirc
20:50:56 <thoughtpolice> shapr: i suppose that would be the best way to explain it, yeah.
20:51:03 <mrd> not to mention not having to deal with all the "session" crap
20:51:07 <Binkley> RyanT5000: do you mean seeing the results of the strictness analyzer/demand analyzer?
20:51:13 <RyanT5000> Binkley: yeah
20:51:26 <thoughtpolice> if for some completely ridiculous reasons hs-plugins just suicides on me one day, i suppose I can just tough it up and rewrite my Plugins.hs. :)
20:51:49 <Binkley> RyanT5000: -ddump-stranal for the strictness analyzer, -ddump-rules for rewrite rules
20:51:54 <Binkley> list fusion being a subset of rewrite rules
20:52:04 <RyanT5000> right
20:52:11 <Binkley> it's not guaranteed to be easy to read, but you can always ask here
20:52:13 <RyanT5000> Binkley: does that mean it doesn't work on user functions?
20:52:34 <Binkley> RyanT5000: it depends
20:52:47 <Binkley> there are rules for foldr and build, for example, so if you write your functions using foldr and build, rewrite rules will fire
20:52:52 <RyanT5000> Binkley: simple tail recursion with a state variable
20:52:54 <Binkley> but you probably aren't going to write your functions using build
20:53:18 <Binkley> RyanT5000: yeah, GHC won't fuse something that's generally recursive and not written in terms of foldr
20:53:19 <RyanT5000> Binkley: where is build, anyway?
20:53:26 <Binkley> RyanT5000: the Prelude, I think
20:53:29 <Binkley> @index build
20:53:29 <lambdabot> Data.Graph.Inductive.Internal.Heap, Distribution.Simple.Build, GHC.Exts
20:53:34 <Binkley> GHC.Exts
20:53:37 <Binkley> it looks like
20:54:13 <mm_freak> @pl sprod xs ys = sum (zipWith (*) xs ys)
20:54:13 <lambdabot> sprod = (sum .) . zipWith (*)
20:54:44 <mm_freak> hmm…  strange
20:55:07 <RyanT5000> Binkley: i don't even understand the type of build...; where is it getting the first a from?
20:55:31 <mm_freak> ah ok, makes sense
20:55:54 <Binkley> @type build
20:55:56 <lambdabot> Not in scope: `build'
20:56:00 <Binkley> @type GHC.Exts.build
20:56:02 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
20:56:30 <Binkley> RyanT5000: the idea of build is that it takes something called a "generalized list producer"...
20:56:49 <Binkley> i.e., a function that returns a data structure that it only builds using two arguments, c and n (like a generalized nil and cons)
20:56:57 <Binkley> where c :: a -> b -> b and n :: b
20:57:03 <Binkley> and it gives you back something of type b
20:57:13 <Binkley> build takes one of those things and applies it to cons and nil, so that you get back a [a]
20:57:18 <RyanT5000> Binkley: hm...
20:57:52 <RyanT5000> Binkley: so is it theoretically possible to get fusion on a function that, e.g., multiplies each element of a list by its index?
20:57:53 <Binkley> it's one of those wonderful functions whose type signature is longer than its definition :-D
20:58:09 <Binkley> RyanT5000: depends how it's written
20:58:37 <Binkley> if it's defined in terms of zip, then GHC's fusion probably won't work (IIRC), but there are some papers on how to do fusion with such functions
20:59:26 <sjanssen> RyanT5000: that's certainly possible in stream fusion
20:59:45 <RyanT5000> sjanssen: where can i read about that?
21:00:06 <sjanssen> they even came up with a scheme for general zips IIRC
21:00:19 <sjanssen> hmm, what was the paper called again?
21:00:56 <Binkley> heh, googling "zip fusion" gets a sushi restaurant as the first hit
21:01:03 <sjanssen> RyanT5000: http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
21:01:03 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
21:01:49 <sjanssen> RyanT5000: this system is scheduled for inclusion in GHC 6.8
21:02:12 <RyanT5000> sjanssen: gah; i want to beat this shootout problem *now*
21:02:21 <Binkley> that's easy, you'll just need a time machine
21:02:29 <RyanT5000> by beat, i mean get our ratio to C++ below 18x
21:02:51 <sjanssen> also, GHC's current system is supposed to fuse with one of the arguments, if possible
21:05:33 <dons> ok. Hugh Perkins is just getting tediosu with his C# advocacy and snide remarks.
21:05:58 <dons> i've got a reply to him to encourage friendly behaviour, would someone care to read over it?
21:06:09 <RyanT5000> sjanssen: so, how is [0..] implemented to be a good producer?
21:06:18 <Binkley> dons: sure
21:06:34 <sjanssen> RyanT5000: how?  Download base and poke around in GHC.* :)
21:06:40 <RyanT5000> :(
21:06:41 <RyanT5000> lol
21:06:46 <Binkley> @src enumFrom
21:06:46 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:06:48 <dons> Binkley: http://www.cse.unsw.edu.au/~dons/tmp/hugh.txt
21:06:50 <RyanT5000> i don't even know *where* it would be defined
21:07:00 <dons> Binkley: in particular, his constant C# trolling is just tedious
21:07:00 <sjanssen> RyanT5000: the major thing is the 'build' function
21:07:06 <Binkley> RyanT5000: it desugars to an application of functions with names like enumFrom/enumFromTo/etc.
21:07:07 <Binkley> look for those
21:07:09 <Binkley> they're pretty simple
21:07:15 <Binkley> dons: ok, will look it over
21:07:20 <RyanT5000> Binkley: alright
21:07:24 <dons> it seems he daily tries to insult the community, at the same time as asking for help (finding a PhD group, for example)
21:07:28 <sjanssen> RyanT5000: build is defined in GHC.Base
21:07:41 <sjanssen> RyanT5000: ghci's :info is really handing for hunting this stuff
21:08:16 <Binkley> dons: I don't see the silly insults in the message from him that you're quoting, although I don't doubt that he has levied them in the past
21:08:20 <Binkley> so maybe provide more context?
21:08:27 <dons> hmm .ok.
21:08:47 <RyanT5000> sjanssen: i tried that, but it didn't give me anything, because i didn't have GHC.Exts loaded at the time
21:09:13 <dons> the paragraph in this email starting at 'One advantage' is a reference to the ongoing C# remarks he makes.
21:09:32 <TSC> Is there anything similar to Data.List.words but for a different delimiter?
21:09:50 <Binkley> dons: were you going to send this to the list, or just to him?
21:09:53 <dons> Binkley: maybe i'm just getting frustrated with his lack of progress
21:10:01 <dons> Binkley: tossing that up.
21:10:03 <dons> not sure.
21:10:14 <dons> there's the dignity issue, vs public encouragement
21:10:44 <Binkley> dons: I think if you're going to include the first half, it should just go to him
21:10:53 <dolio> I don't really see the problem with that quote, either, although I skip most of his mails.
21:10:57 <Binkley> because inevitably, discussions of whether someone's behavior is proper end up becoming more annoying than the improper behavior :-)
21:11:00 <dons> i might just sit on it then, since my previous attempts to encouage him don't make any progress
21:12:00 <Binkley> dons: I feel your pain, though, I wrote to a certain frequent poster with the initials A.C. a few times trying to encourage him to tone down the posting frequency a bit
21:12:07 <dolio> Although, I'm not sure what he means by it, either.
21:12:10 <Binkley> and he seemed to miss my point a bit
21:12:38 <dons> i think AC has improved a little
21:12:45 <Binkley> yeah
21:12:59 <dons> I wish BZ would chill out too. ah well
21:13:11 <dolio> Yeah, he's been angry lately. :)
21:13:17 <Binkley> haha
21:13:30 <dons> HP yesterday, http://article.gmane.org/gmane.comp.lang.haskell.cafe/27204/match=
21:13:30 <Binkley> yeah, I like how he told Paul Hudak he wasn't a real programmer
21:13:33 <RyanT5000> oh, lol, i'll just get rid of my state and use tuples in the list - the state doesn't change anyway
21:13:33 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/2trrb6
21:13:43 <dons> so maybe HP is improving
21:14:26 <dons> I think BZ has a complex about no one using his buggy imperative IO lib
21:14:53 <sjanssen> I think he has a complex about desiring C-styled Haskell
21:15:14 <dons> yes, the whole 'why FP matters' thing got lost somewhere
21:15:35 <dons> Binkley: HP, replying to a job offer on the haskell list, with a pointless remark about Lua, http://article.gmane.org/gmane.comp.lang.haskell.cafe/26363/match=
21:15:37 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/342nu8
21:16:01 <dons> reading his other posts though, i think they're slowly improving
21:16:08 <dons> and the haskell content is increasing.
21:16:11 <dons> so i'll just let this go i think
21:16:23 <Korollary> dons the merciful
21:16:31 <dolio> The Lua one was a while ago.
21:17:42 <bitwize> haha
21:18:05 <bitwize> for some reason I don't like Lua.
21:18:36 <bitwize> I actually expended a bit of effort trying to "out-Lua Lua", by writing a Forth-like VM and language compiler in a teeny tiny space.
21:19:07 <geezusfreeek> is Data.Binary the recommended way to work with binary file IO? (i'm just reading and writing .bmp files)
21:19:41 <dons> geezusfreeek: i think so, yes. simple stuff you can do with bytestrings
21:19:44 <Binkley> dons: ah, yes, that Lua post could have safely gone just to the sender with nothing lost
21:20:10 <dons> Binkley: its that phase of 'oh, i know something about some small detail of this post -- so i'll reply to all with my thoughts'
21:20:16 <geezusfreeek> alright, then i'll give that a shot... tomorrow
21:20:37 <dons> maybe -cafe@ is too big now to steer anywhere
21:21:11 <Binkley> dons: yes, it seemed like "answering a question that nobody asked" syndrome
21:21:19 <dons> still, we probably won't see Hudak write to the list for another 12 months now.
21:21:30 <Binkley> dons: heh, well, that might have been the case anyway
21:21:34 <dons> the first generation has 3/4 vanished.
21:22:58 <Binkley> "I saw the best minds of my generation destroyed by off-topic haskell-cafe threads"?
21:23:17 <dons> ok, i'm glad i waited. HPs posted an interesting mail about threading now
21:23:27 <dons> so we just win people over with charm and lambdas, given time
21:23:28 <RyanT5000> what's the fastest array type to use?
21:23:37 <sjanssen> RyanT5000: UArray
21:23:45 <dons> RyanT5000: UArray, or Ptr a
21:23:51 <sjanssen> or ByteString if you've got Word8
21:23:53 <dons> STUArray if you can hand it
21:23:53 <RyanT5000> sjanssen: including as compared against ST?
21:24:01 <Binkley> ?remember dons so we just win people over with charm and lambdas, given time
21:24:01 <lambdabot> Done.
21:24:02 <dons> same code, RyanT5000
21:24:08 <sjanssen> RyanT5000: you didn't say "mutable" :)
21:24:11 <RyanT5000> dons: ah, i see
21:24:16 <sjanssen> RyanT5000: then you want STUArray
21:24:18 <RyanT5000> sjanssen: yeah, sorry, *any* array
21:24:57 <sjanssen> reading should be the same speed between UArray and STUArray, ST obviously has O(1) mutability instead of O(n)
21:25:45 <RyanT5000> sjanssen: hm... and presumably if you're just building once and then using, it won't make any difference
21:26:51 <dons> so BZ is a hard one.how many years has he been trolling everyone for C++ features in core haskell  now? :)
21:27:18 <Binkley> BZ sometimes provides much-needed comic relief, though :-)
21:27:22 <dons> yeah
21:27:29 <sjanssen> the problem is that he sometimes has good points
21:27:32 <dons> i think he doesn't realise when he's insulting
21:27:56 <dolio> I can't even figure out what he wants exactly.
21:27:57 <dons> anyone recall the bizarro iranian and 'women's logic' posts though? :(
21:27:59 <sjanssen> he just repeats them too often, and too forcefully
21:27:59 <dons> wacky stuff
21:28:13 <Binkley> dons: "women's logic"?!
21:28:23 <dons> Binkley, let me find this...
21:28:30 <Binkley> this I want to see
21:28:34 <Binkley> or maybe I'll regret it :-)
21:29:45 <Binkley> is it this? http://www.haskell.org/pipermail/haskell-cafe/2007-June/027603.html
21:29:47 <lambdabot> Title: [Haskell-cafe] Re: Propositional logic question, http://tinyurl.com/2vbw9h
21:30:21 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/24638/match=woman
21:30:23 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/36aj6q
21:30:47 <Binkley> Yeah
21:30:50 <Binkley> That's... special.
21:30:58 <dons> there's some interesting posts about Tatarstan, http://article.gmane.org/gmane.comp.lang.haskell.cafe/19055/match=woman
21:31:00 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/36p5la
21:31:27 <Binkley> Oh yeah, I was wondering at the time why the whole mailing list cared about him having DSL
21:31:32 <dons> hehe
21:31:46 <RyanT5000> so, if a UArray is passed strictly into a function, everything gets completely evaluated?
21:32:27 <sjanssen> RyanT5000: yeah
21:32:35 <bos> bulat is a saint compared to qwe1234
21:32:38 <RyanT5000> oh wow, the output from -ddump-stranal is 666 lines long... i'm really not surprised
21:33:03 <Binkley> now I want to write a bulat/qwe1234-bot
21:33:07 <Binkley> that will insult people ungrammatically
21:33:09 <dons> yeah, bulat is quite funny actually
21:33:20 <dons> he's kind of a borat of the haskell lists
21:33:27 <dolio> @quote stfu
21:33:27 <lambdabot> qwe1234 says: stfu, troll.
21:33:36 <olathe> Heheh
21:33:38 <Binkley> @quote bulat
21:33:38 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
21:33:44 <dons> yeah, we need a bulat plugin.
21:33:46 <Binkley> heh
21:34:22 <goalieca> qwe1234.. the same one from reddit?
21:34:38 <Binkley> the one and only!
21:34:50 <dgriffi3> @seen qwe1234
21:34:51 <lambdabot> I haven't seen qwe1234.
21:35:11 <reltuk> haha, that's great
21:35:13 <sjanssen> lambdabot: count yourself lucky!
21:35:22 <Binkley> one of his recent comments managed to get -44 points
21:35:24 <Binkley> that's impressive
21:37:11 <SamB_XP> for some reason qwe1234 quotes make their way into lambdabot despite the fact that he's never been here
21:37:46 <dons> we're big fans
21:37:48 <Binkley> well, Zippy the Pinhead hasn't been here either :-)
21:38:02 <goalieca> @seen goalieca
21:38:03 <lambdabot> You are in #haskell. I last heard you speak just now.
21:39:01 <sjanssen> @quote qwe1234
21:39:01 <lambdabot> qwe1234 says: every half-assed dynamically-typed, ass-slow scripting language is Lisp but a bit different
21:39:36 <notpalomer> even perl?
21:39:43 <Binkley> ?quote qwe1234.perl
21:39:44 <lambdabot> No quotes match. You type like i drive.
21:40:24 <dolio> @quote qwe1234 perl
21:40:24 <lambdabot> qwe1234 says: it's 2006 already, and the world doesn't need 'dynamic languages'. otherwise, we'd be all programming in perl.
21:40:33 <Binkley> yeah, that's the one I was thinking of
21:40:39 <SamB_XP> um
21:40:48 <SamB_XP> I thought everyone already programmed in perl
21:40:51 <goalieca> @quote qwe1234 .net
21:40:52 <lambdabot> No quotes match. Where did you learn to type?
21:40:55 <Binkley> that's why it's funny :-)
21:41:04 <goalieca> @quote qwe1234 bloat
21:41:04 <lambdabot> No quotes match. You speak an infinite deal of nothing
21:41:04 <reltuk> anyone know what this will look like (from the HAppS page): "We are almost done with changes to the back end of HAppS so that apps will be able to run unchanged on Amazon's S3 and EC2."
21:41:26 <bos> reltuk: multi-master state replication
21:41:47 <bos> reltuk: instances chatter with each other every few milliseconds to feed updates and heartbeats
21:42:05 <dons> happs has Igloo and Lemmih and shapr working on it now? anyone else?
21:42:15 <dons> shapr: is there a happs blog to keep informed of what is happening?
21:42:18 <bos> igloo just 1 day a week or so.
21:42:28 <dons> ah ok
21:42:29 <hpaste>  shans pasted "tagsoup notworking" at http://hpaste.org/2170
21:42:31 <bos> i've been beating alex up about publicising it better :-)
21:42:46 <dons> yeah, it could do with more expoosure
21:43:10 <bos> i'm probably going to write the book feedback stuff in happs
21:43:15 <dons> just a blog would be useful.
21:43:34 <dons> bos, yeah, glguy and i are pondering a LtU replacement in a few months in happs too, after the hpaste experience was pretty good
21:43:45 <reltuk> or betters docs...or somewhere to track api changes...
21:44:02 <reltuk> but the state replication across ec2 hosts sounds quite hot
21:44:03 <bos> though alex's coding style is a bit peculiar. he hates type signatures, loves single-letter function names, and has a big thing for SYB.
21:44:08 <SamB_XP> dons: how about this for the name: "pi the ultimate"
21:44:12 <glguy> dons: have you heard anything about the "major rewrite" that happs was going to go through?
21:44:20 <bos> glguy: it's done.
21:44:31 * glguy needs to brush up it seems
21:44:33 <bos> why replace LtU?
21:45:00 <SamB_XP> named after the pis in PTS
21:45:00 <bos> i mean, other than that it's completely unnavigable so i never visit it.
21:45:24 <dons> not so much replace, as complement, with a reddit-style pragmatic submission process, focusing more on practice of PLT rather than just pdf
21:45:36 <dons> just an idea, anyway, in case reddit gets worse
21:45:47 <dons> vote up down, moderated comments
21:46:10 <bos> reddit is guaranteed to get worse :-)
21:46:23 <dons> i'd take that bet, yep
21:48:18 <glguy> bos: worst case is we give happs another application to motivate and make use of features
21:48:32 <glguy> bos: best case, we have a reddit like community without the trolls and link bots
21:48:53 <dons> interesting, http://www.lri.fr/~filliatr/puf/index.en.html
21:48:54 <lambdabot> Title: Formalization of a persistent union-find data structure in Coq
21:49:03 <bos> glguy: yeah
21:49:19 <dons> and the xmonad experience (and reddit) tells me we can drag the community with us
21:49:26 <dons> rather than trying to build up a readership from scratch
21:49:34 <dons> so a little more likely to work
21:49:45 <dons> than if some random guy forked reddit
21:49:47 <jfredett> haskell reddit?
21:49:56 * glguy doesn't want it to just be haskell
21:50:04 <jfredett> hackit?
21:50:07 <jfredett> :)
21:50:16 <SamB_XP> "xmonad experience"?
21:50:18 <dons> no, PLT stuff.
21:50:40 <dons> SamB_XP: ready made community of users, gets the ball rolling, then you get others coming in. darcs had a similar experience
21:50:55 <jfredett> riiight, it'll be about general PLT stuff just like LtU is about general PLT stuff, and not just FP. :)
21:50:56 * SamB_XP wonders why he always thinks "Python, Lettuce, and Tomatatos" when he hears PLT
21:51:16 <dons> jfredett: yeah, but without bot spam, SOE articles, and trolls :)
21:51:16 <olathe> Because it's so delicious.
21:51:26 <glguy> SOE?
21:51:26 * dolio thinks of Scheme.
21:51:42 <dgriffi3> sony online entertainment?
21:51:53 <jfredett> I'm not sure I buy the lack of trolls, *points at qwe...*
21:52:07 <glguy> jfredett: qwe1234 is allowed to exist
21:52:08 <jfredett> but bot spam, okay, I dont know what SOE is
21:52:15 <dons> hmm, should look at improving DiffArray (and kicking it out of base) , http://www.lri.fr/~filliatr/ftp/ocaml/ds/parray.ml.html
21:52:21 <SamB_XP> it's no fun without a troll or two
21:52:45 <glguy> I don't know... the trolls tend to hijack potentially interesting discussion
21:53:05 <jfredett> glguy: and if trolls exist, they will post, in the most trollish ways, in the most troll-appealing areas
21:53:42 <glguy> jfredett: you just treat them like any other  spammer
21:53:56 <jfredett> right, you shoot them
21:54:01 <jfredett> in the face
21:54:04 <jfredett> repeatedly
21:54:06 <jfredett> with large guns
21:54:40 <glguy> bos: do you know where I can read about the changes?
21:55:07 <bos> glguy: alex hasn't written them up for public consumption yet
21:55:12 <glguy> oh, ok
21:55:27 <bos> glguy: if you ask him, he'll probably give them to you
21:55:37 <glguy> Yeah.. I'll have to do that
21:56:11 <glguy> I still need to get enough of a handle on the API to write an IRC agent for happs
21:56:28 <glguy> to make writing a bot as easy as handling HTTP requests
21:56:36 <bos> yummy scrummy
21:57:19 <glguy> and additionally, to make hpaste's irc bot not a bolted on hack :-/
21:57:29 <glguy> then the bot would be able to update the application state
22:01:45 <RyanT5000> how can i make the profiler dig down into functions that aren't declared in my file? e.g. (+)
22:02:55 <dons> -auto-all ?
22:03:34 <SamB_XP> RyanT5000: recompile GHC!
22:03:50 <RyanT5000> :(
22:03:58 <RyanT5000> lol
22:04:08 <RyanT5000> maybe i'll just have to go nuts with subexpression tagging
22:07:00 <dibblego> I want to distribute a function; where do I start reading? and who has done it before?
22:07:32 <SamB_XP> a single function?
22:07:49 <SamB_XP> @google haskell cabal
22:07:50 <lambdabot> http://www.haskell.org/cabal/
22:07:51 <lambdabot> Title: The Haskell Cabal
22:08:03 <dibblego> no, distribute it across cores
22:08:10 <dibblego> across many machines even
22:08:35 <sjanssen> dibblego: across cores is really easy (use threads or par), across machines is difficult
22:08:45 <sjanssen> dibblego: a pure function?
22:08:46 <dibblego> sjanssen, I need to be difficult
22:08:48 <dibblego> sjanssen, yes
22:08:53 <dons> Cale: interesting, top ranked linuxer article, #33, percent of articles submitted by linuxer yesterday, 34%. signal/noise ratio, not very good ;)
22:09:17 <Cale> dons: Yeah, it's a shame.
22:09:24 <dibblego> sjanssen, has anyone done this before with Haskell? where can I read about how to do it?
22:09:38 <Cale> dons: What do you think of my idea for karma?
22:09:58 <sjanssen> dibblego: probably.  Maybe look into GDH? (Glasgow Distributed Haskell)
22:10:00 <dons> i think you should pay for submissions, yeah, seems useful
22:10:02 <dolio> There was Glasgow Distributed Haskell a while back. But the distributed part didn't take off much, I think.
22:10:17 <dons> the language support was ahead of the available hardware
22:10:50 <dibblego> ok, so there is nothing Haskell-specific then; has anybody tried solving this problem with Haskell in the publicdomain?
22:11:28 <dons> dibblego: distribution across machines?
22:11:34 <dibblego> dons, correct
22:11:44 <dons> there's a wide range of research going back to the early 90s
22:11:50 <dibblego> dons, currently, there is a crude solution using Java/JMS
22:12:02 <dons> GDH was the main implementation, a proper distributed runtime
22:12:19 <dons> mobile haskell, goffin, etc
22:12:34 <dibblego> I may have to write something myself
22:12:38 <dons> start here, http://haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency#Parallel_Haskell
22:12:40 <lambdabot> Title: Research papers/Parallelism and concurrency - HaskellWiki, http://tinyurl.com/t83sk
22:12:44 <dibblego> excellent thanks
22:13:06 <dons> the multcore stuff has been the main focus for the last few years, since those things are commodity machines for researchers now
22:13:20 <dolio> Distributed computing sounds like an Erlang thing.
22:13:21 <dons> but a lot of work went in to distributed runtimes before then
22:13:26 <dolio> Has to be better than Java, right? :)
22:13:32 <dibblego> dolio, yep :)
22:13:37 <dons> dolio: yeah, a purey functional thing anyway. its reasonably well understood, I think
22:13:46 <sjanssen> true, this sort of thing is Erlang's bread and butter
22:14:05 <dibblego> sjanssen, because of its concurrency mechanisms?
22:14:13 <dons> its runtime
22:14:14 <dibblego> and if so, Scala actors appear much the same?
22:14:17 <dibblego> oh right
22:14:30 <dons> actors on the language level, are common, a runtime for seemless distribution, far less so
22:14:50 <dibblego> ok I might have to figure out Erlang
22:14:52 <dons> pity its so untyped and slow :)
22:14:58 <dibblego> indeed
22:15:08 <dons> they talk about using ocaml nodes, with erlang glue to tie them together
22:15:12 <dons> to overcome that porblem
22:15:16 <reltuk> lambdabot: users?
22:15:21 <shachaf> @users
22:15:21 <lambdabot> Maximum users seen in #haskell: 375, currently: 316 (84.3%), active: 20 (6.3%)
22:15:22 <dibblego> who is "they"? (what can I read?)
22:15:37 <dons> dibblego: oh, hwn last week? or reddit? someone tossing he idea around
22:15:49 <dibblego> oh, so it's only talk?
22:16:38 <dibblego> why not Haskell nodes, with Erlang gluing them together?
22:17:13 <dons> yeah, why not? or why not haskell glue too? its an open question
22:17:20 <dibblego> ok
22:17:31 <dons> needs funding
22:17:38 <dons> or industrial support
22:18:42 <dons> dibblego: did you see the scala guy's comments about learning haskell?
22:18:53 <dons> seemed relevant to your work/experience too, I thought.
22:18:56 <dibblego> dons, yeah Pollak is pretty clever; always quizzing me abot Haskell
22:19:11 <dons> oh, you've had some contact with him?
22:19:22 <dibblego> onlyonline, yeah
22:19:27 <dons> cool
22:19:32 <dibblego> #scala and the Scala mailing lists
22:20:24 <shapr> Are the slides for SPJ's STM talk online?
22:26:12 <RyanT5000> is there a way to forgo bounds checking on arrays?
22:26:25 <RyanT5000> ("unsafe" is fine)
22:26:30 <dons> unsafeRead/unsafeWrite
22:26:39 <RyanT5000> dons: ah, so that's what those do
22:26:48 <RyanT5000> well, i knew why Write was unsafe ;)
22:32:48 <thoughtpolice> what exactly is the purpose of Data.Typeable? only to associate a representation to a type? isn't that somewhat similar to Show? or am I missing something here.
22:32:58 <zvrba> is there a standard prelude quickref?
22:33:08 <shachaf> @where report
22:33:08 <lambdabot> http://www.haskell.org/onlinereport/
22:33:17 <zvrba> thx
22:36:13 <RyanT5000> what's it called when you add strictness annotations to function parameters?
22:36:28 <dibblego> strictness
22:36:32 <RyanT5000> no, i mean
22:36:36 <RyanT5000> the name of the extension that allows that
22:36:40 <jfredett> adding strictness annotations to function parameters
22:36:42 <jfredett> ?
22:36:46 <sjanssen> RyanT5000: bang patterns
22:36:47 <dons> bang patterns
22:37:10 <RyanT5000> sjanssen, dons: thanks; other guys: i'm just less retarded than that
22:40:52 <glguy> shapr: they are
22:40:56 <glguy> shapr: did you find them?
22:41:38 <RyanT5000> glguy: yep, and they killed my performance by 13%
22:41:54 <glguy> ?
22:42:06 <RyanT5000> glguy: i'm working on spectral-norm from the shootout
22:42:13 <RyanT5000> and i'm completely at a loss
22:42:23 <RyanT5000> i've improved it by like a factor of 2
22:42:38 <RyanT5000> but that still makes it haskell's worst compared to C++ at 9x
22:43:08 <dons> you improved the spectral norm entry?
22:43:10 <dons> great!
22:43:13 <RyanT5000> yeah
22:43:18 <dons> that's a hard one, that Double math stuff
22:43:21 <RyanT5000> there was one trivial improvement
22:43:30 <RyanT5000> which turned some Double math into int math
22:43:45 <dons> you're following the usual rules for fast doubles in ghc?
22:43:46 <RyanT5000> and turned two int->double conversions into one
22:43:53 <RyanT5000> dons: i wouldn't know them
22:44:07 <dons> so you're looking at the current 62second entry?
22:44:16 <dons> and you've improved that to 30 seconds or so?
22:44:21 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=spectralnorm&lang=ghc&id=4
22:44:23 <lambdabot> Title: spectral-norm Haskell GHC #4 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 ..., http://tinyurl.com/2e7msp
22:44:30 <dons> was my best effort
22:44:45 <RyanT5000> dons: actually, i've been testing it on smaller values of N, so it might not be as good at higher N
22:44:54 <dons> ah, you do need to use the values they test with
22:45:06 <dons> you're working on a modification of that Ptr Double code?
22:45:07 <RyanT5000> dons: i've been doing it at 500, which is the first of 3
22:45:19 <dons> oh, but the real one measures 5500
22:45:33 <dons> currently the entry is 2.6x  C++
22:45:41 <dons> so what's this 9x entry you're talking about?
22:45:47 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=spectralnorm&lang=all
22:45:49 <lambdabot> Title: spectral-norm benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/bruf8
22:45:50 <RyanT5000> dons: oooohhh... i was looking at the wrong shootout? under /debian/
22:46:01 <dons> ah, that's old an out of date :)
22:46:04 <RyanT5000> lame
22:46:09 <dons> use gp4
22:46:21 <RyanT5000> well, that explains why i was able to do something :P
22:46:22 <dons> seems like we're 2x slower than we should be. find out what clean and ocaml do
22:46:40 <dons> jclean runs in 27s, ocaml 32. so you should be able to get to that
22:46:46 <RyanT5000> hm
22:46:49 <dons> often it just means working out what optimisation trick those guys use
22:47:01 <dons> (since the rules change over time, a lot of the work is just keeping up to date with the latest legal tricks)
22:47:07 <RyanT5000> hm
22:47:16 <dons> oh, and even the Cal entry is 34 s. so we can definitely improve
22:47:22 <dons> Cal is just a slower jvm haskell after all
22:47:51 <RyanT5000> i wonder if something can be done with the fact that we have an extra 5 digits of precision or so (double's about 14, right?)
22:48:10 <RyanT5000> i don't understand why their methodology involves computing known solutions
22:48:12 <dons> oh, i note it doesn't require doubles
22:48:18 <dons> so check wha tthe really fast entries do
22:48:22 <RyanT5000> hm
22:48:54 <dons> yeah, we're missing something in that entry
22:49:06 <dons> most native code entires are in the 20-30s range
22:49:15 <dons> so we must be doing too much work somewhere
22:49:21 <RyanT5000> yeah
22:50:13 <shachaf> There's a Haskell for the JVM?
22:50:20 <dibblego> yeah CAL
22:50:39 * shachaf hadn't heard of that.
22:52:17 <sjanssen> it isn't' *really* Haskell
22:52:21 <Korollary> there's also lambdavm or something
22:52:28 <sjanssen> it's a bastardized version (and nobody really knows why)
22:52:31 <RyanT5000> dons: so what were those rules for working with Doubles?
22:54:21 <dons> looks like syntax glue for java calls, doesn't it
22:54:34 <dons> RyanT5000: oh, look at the flags used in the gp4 entry i linked to
22:54:45 <dons> basically -fexcess-precission, -sse flags
22:54:49 <dons> compile via C, not -fasm
22:54:55 <dons> be strict in double arguments
22:55:24 <RyanT5000> hm, alright
22:55:58 <dons> an important thing to do is just go through the fast entries in similar languages, and check it against the best haskell entry, for obvious flaws
22:56:15 <JBGood25> are those case statements in aij of GHC #4 optimized away?
22:56:47 <dons> its just straight line C code, yeah.
22:57:01 <dons> the case is just sugar for the sequencing of results
22:57:14 <dons> and how you specify precisely which machine code you want produced
23:02:01 <thoughtpolice> is there any way to keep the .c file generated by -fvia-C around? -keep-tmp-files doesn't
23:04:08 <RyanT5000> dons: is harpy cheating?
23:04:17 <RyanT5000> :P
23:05:05 <Cale> thoughtpolice: -keep-hc-file ?
23:05:10 <lament> Clean sure does nice in those shootouts
23:05:31 <goalieca> what's diff about clean vs haskell
23:06:04 <dons> different type system, and social factors, (few researchers, tiny user base, tiny library base)
23:06:11 <dons> good native code generator
23:06:35 <goalieca> once haskell, you think it'll do much better native code?
23:07:07 <thoughtpolice> Cale: ah. icky stuff. :)
23:07:17 <goalieca> matures*
23:07:21 * goalieca is sleepy
23:08:04 <Cale> goalieca: sure, it's always improving
23:08:10 <reltuk> the happs seem to be getting the best of me at the moment...
23:08:42 <dons> its funny that we try to compete with C, and do fairly well
23:08:45 <glguy> goalieca: "once it matures"?
23:08:52 <goalieca> ya
23:08:56 <dons> when people are really tossing up between things like ruby, pythoon, erlang , haskell
23:08:59 <Cale> "As it matures"
23:09:27 <dons> there's already a 15% speed up in the ghc head branch, that's not reflected in the shootout, that should be useful
23:09:55 <goalieca> so there's really room for growth
23:09:55 * glguy needs to build HEAD to play with the debugger
23:10:21 <lament> ruby and python don't have compilers
23:10:28 <Cale> There's a theorem which says that you can always make your compiler better.
23:10:33 <goalieca> pyc is bytecode
23:10:50 <psykotic> cale: The Guaranteed Employment Theorem :)
23:10:58 <dons> goalieca: yeah. room for growth + more cores mix things up.
23:11:06 <RyanT5000> Cale: what does it mean by "better"/
23:11:18 <dons> and seriously, there are more important things than raw speed -- as ocaml has found out
23:11:21 <Cale> psykotic: yes :)
23:11:24 <goalieca> i wonder how icc would do if they put that in the shootout
23:11:27 <psykotic> RyanT5000, optimal optimization is as hard as solving the halting problem.
23:11:31 <RyanT5000> Cale: doesn't that imply that the code of the compiler can become arbitrarily large?
23:11:52 <lament> goalieca: anything can be bytecode, it's not that big an achievement
23:11:54 <Cale> http://en.wikipedia.org/wiki/Full_employment_theorem
23:11:57 <goalieca> dons: well it is really easy to write code in haskell that performs really crappy.
23:12:02 <dons> so are we trying to compete with C/C++, or with ruby/python/erlang/java? speed is part of it, but not the main issue these days -- its just something easy to measure
23:12:08 <lament> goalieca: of course, anything can be trivially compiled as well but you know what i mean :)
23:12:19 <shachaf> Does lambdabot want to be in #scala?
23:12:25 <dibblego> @join #scala
23:12:26 <lambdabot> Not enough privileges
23:12:34 <dons> goalieca: i'm not sure its *really* easy -- baseline poor performance is still around python
23:12:41 <dibblego> @join or the baby seal gets is
23:12:41 <lambdabot> Not enough privileges
23:12:51 <vincenz> moin
23:12:59 <Cale> I believe there's a similar theorem for speed (the one on the wikipedia page talks about size)
23:13:13 <dons> but we've been having this debate for years :) at least people know now they're doing something wrong if they're slower than the same python code
23:13:48 <dons> dibblego: you sure you wan the bot in #scala?
23:14:02 <dibblego> dons, sure, why not?
23:14:08 <RyanT5000> Cale: well, we're bounded by the maximum entropy of the universe, so that's good :)
23:14:09 <dons> well, you're an op there or something?
23:14:21 <dibblego> dons, yes
23:14:27 <dibblego> dons, we are discussing Haskell with a noob
23:14:27 <dons> @join #scala
23:14:40 <goalieca> kb ln \Omega
23:14:57 <dons> ?seen lambdabot
23:14:57 <lambdabot> Yes, I'm here. I'm in #scala, #gentoo-uy, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell,
23:14:57 <lambdabot> #ghc and #darcs
23:14:59 <shachaf> dons++
23:15:16 <thoughtpolice> unicycling?
23:15:18 <shachaf> Should lambdabot be integrated into Freenode?
23:15:32 <lament> LambdaServ
23:15:56 <lament> the Clean website has such a shareware feel
23:16:18 <SamB_XP> RyanT5000: actually you can make the compiler better by shrinking it, too!
23:16:45 <RyanT5000> SamB_XP: yes, but there are a finite number of compilers expressible in a finite-entropy universe
23:17:03 <RyanT5000> SamB_XP: though i suppose we haven't proven the latter bit yet
23:17:03 <goalieca> more compilers = more disorder
23:17:39 <SamB_XP> what was the word for things like theorems that haven't been proved yet?
23:17:52 <shachaf> SamB_XP: Conjectures?
23:17:53 <glguy> conjecture?
23:18:08 <RyanT5000> or do you mean "truths"?
23:18:09 <thoughtpolice> compilers are silly.
23:18:09 <SamB_XP> that was the only word I could think of too...
23:18:19 <lament> SamB_XP: sometimes "Theorems"
23:18:34 <quicksilver> Hypothesis?
23:18:35 <shachaf> lament: As in "Fermat's Last Theorem"? :-)
23:18:40 <quicksilver> (as in, Riemann)
23:18:41 <goalieca> theory
23:19:09 <SamB_XP> hypothesis might be the one I wanted
23:19:19 <lament> shachaf: that's the one i had in mind :)
23:19:38 <SamB_XP> shachaf: yes, I thought of that too...
23:19:44 <SamB_XP> but I figured that one was special
23:20:15 <SamB_XP> ... now, how come you never hear about his second-to-last theorem?
23:20:41 <shachaf> SamB_XP: You hear about his little theorem.
23:21:09 <wli> You don't quite understand.
23:21:22 <wli> The standards of proof and rigor were inadequate in his time.
23:21:37 <wli> Some things from his notebooks were actually proved false.
23:21:52 <wli> s/notebooks/writings/
23:21:53 <goalieca> i saw that pbs special on the theorem
23:22:03 <goalieca> those guys need sunlight
23:22:06 <dons> hmm, http://paste.lisp.org/display/45902
23:22:22 <wli> FLT was unique in that it could be neither proved nor disproved.
23:22:47 <dons> samreid: do we know who this guy is?
23:22:50 <lament> SamB_XP: it's called "last" because it was last to be proven/disproven, not because it was his last proposed theorem.
23:23:09 <goalieca> it only took a new branch of math to prove
23:23:28 <dibblego> are we discussing Fermat?
23:23:39 <dibblego> (I got in trouble from a French guy once for pronouncing the t)
23:23:40 <wli> goalieca: Several new branches, really.
23:23:43 <lament> SamB_XP: so by the time the terminology "last" originated, the second-to-last theorem was already proven and therefore uninteresting
23:24:06 <shachaf> wli: Gödel had some "theorems" that could be neither proven or disproven. :-)
23:24:30 <goalieca> incompleteness?
23:24:35 <wli> shachaf: There are undecidable things, too.
23:24:44 <glguy> > let lastN n xs = foldr (\ _ xs -> tail xs) xs (drop n xs) in lastN 3 [1..10]
23:24:46 <lambdabot>  [8,9,10]
23:25:06 <wli> > unfoldr (\l -> fmap (const $ let x:xs = l in first (x:) . partition ((== snd x) . snd) $ xs) $ listToMaybe l) [(i, j) | i <- [1..3], j <- ['a'..'c']]
23:25:08 <lambdabot>  [[(1,'a'),(2,'a'),(3,'a')],[(1,'b'),(2,'b'),(3,'b')],[(1,'c'),(2,'c'),(3,'c')]]
23:27:35 <glguy> > let lastN = ap (foldr (const tail)) . drop in lastN 3 [1..10]
23:27:36 <lambdabot>  [8,9,10]
23:28:47 <wli> wow that is short
23:29:31 * wli isn't sure how to compress his down yet.
23:30:36 <goalieca> > reverse $ take 3 $ reverse [1..10]
23:30:38 <lambdabot>  [8,9,10]
23:31:13 * goalieca is sleepy.. doesn't know what all this is about
23:31:52 <glguy> goalieca: bah, you make too many passes over the list :-p
23:32:25 <goalieca> glguy: compilers job to sort it out
23:32:34 <wli> Can the compilers actually fuse those loops?
23:33:01 <glguy> which
23:33:16 <wli> That's part of the question.
23:33:21 <goalieca> as a functional language it should be able to figure out some optimal sequence (or at least my meaning
23:33:44 <shachaf> @let dwim = undefined
23:33:47 <lambdabot> Defined.
23:34:01 <olathe> lambdabot: No, UNdefined.
23:35:31 <hpaste>  blah pasted "add" at http://hpaste.org/2171
23:35:34 <glguy> goalieca: you can hardly expect the compiler to glean "rewrite this function to efficiently take the last n elements"
23:35:46 <goalieca> well it uses lazyness to some degree
23:36:17 <goalieca> should notice that it doesn't need to reverse whole list
23:36:27 <shachaf> goalieca: How?
23:37:30 <dolio> > let z [] xs = xs ; z (_:ks) (_:xs) = z ks xs ; takeEnd n xs = z (drop n xs) xs in takeEnd 3 [1..10]
23:37:31 <lambdabot>  [8,9,10]
23:37:33 <shachaf> goalieca: How do you reverse "part of a list"?
23:37:53 <dolio> You need to traverse the whole list to get to the end.
23:38:03 <dolio> Even if you don't build the entire reversed list.
23:38:06 <glguy> dolio: that was my original function, but I wanted to write something unusable...
23:38:17 <goalieca> ya. but you don't need to return the whole list reversed
23:38:35 <RyanT5000> dons: i found it ;)
23:38:36 <shachaf> Isn't reverse a strict function?
23:38:44 <RyanT5000> dons: "it" being 47% of your CPU time
23:39:04 <glguy> goalieca: being a functional programming language doesn't mean that it is "magic"
23:39:11 <glguy> it means that functions are values
23:39:25 <goalieca> and it returns functions
23:39:27 <goalieca> (reverse. ((take 3) . reverse))
23:39:37 <goalieca> should be able to do some magic based on certain guarantees
23:39:49 <shachaf> goalieca: Which are?
23:40:04 <RyanT5000> goalieca: if you want that kind of guarantee, you need to build some sort of two-ended list
23:40:04 <opqdonut> the compiler, sadly, doesn't no the real semantics of reverse
23:40:40 <RyanT5000> goalieca: which may or may not actually be possible to do efficiently - i certainly haven't thought about it
23:41:10 <goalieca> well a list in haskell can be implemented anyway as far as i know.
23:41:24 <goalieca> mostly a linked list
23:41:33 <goalieca> but there's no requirements it be a list of type a
23:41:35 <RyanT5000> goalieca: yes, but what you're wanting requires a doubly-linked list
23:41:38 <opqdonut> a list being linked two ways would kill efficiency
23:41:45 <opqdonut> because of referential transparency
23:41:58 <RyanT5000> opqdonut: yeah; you might be able to do some trick similar to DiffArray, though
23:42:16 <RyanT5000> opqdonut: yielding something that looks just like a doubly-linked list but is referentially transparent
23:42:24 <opqdonut> okay
23:42:39 <goalieca> this should be resolved by the compiler :D
23:42:43 <shachaf> Isn't DiffArray very slow, though?
23:42:44 <goalieca> i can't do anything about it
23:42:57 <goalieca> maybe use "array"
23:43:08 <RyanT5000> shachaf: O(1) updates and lookups
23:43:09 <goalieca> or something
23:43:24 <goalieca> diffArray does lazy copy on write
23:43:30 <goalieca> unless i understand wrong
23:43:31 <RyanT5000> goalieca: lists, in general, can't be reversed; imagine you had an infinitely long list
23:44:13 <RyanT5000> goalieca: yes, when you write to an old version of a DiffArray, it copies it and replays the undo list
23:44:36 <JBGood25> > llet reversen 0 x l= l; reversen n (a:b) l = reversen (n-1) b (a:l) in reversen 3 [1,2,3,4] []
23:44:37 <lambdabot>  Parse error
23:44:43 <JBGood25> > let reversen 0 x l= l; reversen n (a:b) l = reversen (n-1) b (a:l) in reversen 3 [1,2,3,4] []
23:44:45 <lambdabot>  [3,2,1]
23:45:00 <goalieca> RyanT5000 what if it figured out i wanted the last 3 elements of the list by composing take and reverse in some weird way
23:45:11 <RyanT5000> goalieca: what are the last 3 elements of [0..]?
23:45:11 <goalieca> then as its traversing forward it can take it when it hits the right spot
23:45:32 <shachaf> RyanT5000: [8,19,54].
23:45:34 <goalieca> RyanT5000: but the problem isn't defined there is it?
23:45:38 <shachaf> RyanT5000: It's a fact.
23:45:48 <goalieca> mathematically that makes no sense
23:45:52 <goalieca> so in haskell it doesn't either
23:46:04 <RyanT5000> goalieca: right, so what are you trying to do that isn't just (reverse . take 3 . reverse)?
23:46:34 <goalieca> i dunno. i just posted stupid code that some others were doing. i have no idea what the original problem was
23:46:42 <RyanT5000> oh, alright
23:46:46 <goalieca> then i made the coment about how there shouldn't be too many "passes"
23:46:53 <goalieca> because the compiler should figure that shit out
23:47:02 <JBGood25> > let reversen 0 x l= l; reversen n (a:b) l = reversen (n-1) b (a:l) in reversen 3 (reverse [0..10]) []
23:47:04 <lambdabot>  [8,9,10]
23:47:06 <RyanT5000> eh, it's hard to automatically figure stuff out
23:47:12 <shachaf> goalieca: That was the original problem.
23:47:31 * shachaf is surprised to find someone who expects even more of compilers than he does.
23:47:59 <goalieca> shachaf: well some day ...
23:48:03 <goalieca> no reason why i cannot
23:48:10 <goalieca> mathematically pure so eh?
23:48:18 <goalieca> why it* cannot
23:48:18 <RyanT5000> well, if humans are turing machines ;)
23:48:46 <shachaf> goalieca: What do you expect it to do with reverse . take n . reverse?
23:49:04 <JBGood25> hmm, if it makes it tail-recursive...
23:49:06 <goalieca> return a function.
23:49:14 <goalieca> :P
23:49:42 <shachaf> goalieca: How do you expect it to optimize it?
23:49:46 <dolio> If you have lazy naturals, then it's 'takeEnd n l = drop (length l - n) l'
23:50:11 <shachaf> dolio: genericLength? :-)
23:50:28 <dolio> No, in my fantasy, length is already generic. :)
23:50:45 <opqdonut> :))
23:50:53 <JBGood25> @src take
23:50:53 <lambdabot> take n _      | n <= 0 =  []
23:50:53 <lambdabot> take _ []              =  []
23:50:53 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
23:51:19 <goalieca> shachaf: i dunno.
23:51:22 <JBGood25> heh, a tail-recursive take would in fact have a reverse at the end
23:51:24 <goalieca> that's why i'm asking everyone
23:51:49 <dolio> I suppose that isn't any less strict than without lazy naturals, though.
23:52:05 <JBGood25> so if you let two reverses cancel out (which you can't do with infinite lists, unfortunately), it would work out
23:52:29 <goalieca> let's see how long this takes: one sec
23:52:45 <goalieca> (reverse. ((take 3) . reverse)) [1..1000000]
23:53:08 <goalieca> yay me!
23:53:09 <JBGood25> the 3 is small, so it doesn't cost very much at all
23:53:31 <JBGood25> you have to do (reverse. ((take 500000) . reverse)) [1..1000000] to really see
23:53:52 <dons> nice stuff jfredett http://disparatemathematician.blogspot.com/2007/08/why-testing-code-should-be-laissez.html
23:53:54 <lambdabot> Title: The Disparate Notions of a Lowly Mathematician: Why Testing code should be Laiss ..., http://tinyurl.com/2w8ny4
23:54:26 <goalieca> > (reverse. ((take 3) . reverse)) [1..10000000]
23:54:30 <lambdabot> Terminated
23:54:36 <goalieca> ha! i broke lambda bot
23:54:40 <vincenz> no you didn't
23:54:43 <goalieca> ssh
23:54:53 <vincenz> lambdabot stops calculations that take too long
23:55:02 <goalieca> > (reverse. ((take 3) . reverse)) [1..1000000]
23:55:03 <vincenz> (or too much memory)
23:55:05 <lambdabot>  [999998,999999,1000000]
23:55:09 <goalieca> that was fast enough
23:55:16 <vincenz> you got lucky :)
23:55:25 <goalieca> so 1 million elements isn't so bad to traverse and take 3 from
23:55:28 <vincenz> oh, and dropped a 0
23:55:52 <JBGood25> > (reverse. ((take 999999) . reverse)) [1..1000000]
23:55:55 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
23:56:02 <goalieca> ha. see its pretty fast
23:56:30 <glguy> > let lastN = ap (foldr (const tail)) . drop in lastN 999997 [1..1000000]
23:56:31 <lambdabot>  [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,...
23:56:34 <shachaf> goalieca: You have many extra parentheses there.
23:56:48 <goalieca> well whatever. extra case
23:56:49 <goalieca> care
23:56:52 <shachaf> > reverse . take 3 . reverse $ [1..100] -- If you insist on implementing it that way.
23:56:53 <lambdabot>  [98,99,100]
23:57:00 <wli> Thus far f cmp = unfoldr (fmap ((uncurry (\x -> first (x:) . partition (cmp x))) . liftM2 (,) head tail) . liftM2 fmap const listToMaybe)
23:57:06 <glguy> shachaf: did Cale get to you?
23:57:10 <shachaf> > (reverse . take 3 . reverse) [1..100] -- Or this, without ($) -- (.) is associative.
23:57:12 <lambdabot>  [98,99,100]
23:57:25 <vincenz> @quite glguy xxxx: did Cale get to you?
23:57:25 <lambdabot> Maybe you meant: quit quote
23:57:30 <vincenz> @remember glguy xxxx: did Cale get to you?
23:57:30 <lambdabot> Done.
23:57:30 <goalieca> hmm. when i add that extra 0, the program suddenly takes a crap (in ghci anyways)
23:57:45 <glguy> ?quote glguy
23:57:45 <lambdabot> glguy says: that's odd, mine is this big : |-----------------------------|
23:57:50 <vincenz> :D
23:57:51 <shachaf> glguy: What?
23:57:53 <vincenz> I remember that one :)
23:57:57 <vincenz> I added it
23:58:12 <glguy> shachaf: Cale is usually the one that brings up a . b . c $ x over a $ b $ c x
23:58:21 <glguy> ?quote glguy
23:58:21 <lambdabot> glguy says: xxxx: did Cale get to you?
23:58:23 <glguy> ?quote glguy
23:58:24 <lambdabot> glguy says: lol, making lambdabot fight your battles
23:58:32 <shachaf> glguy: 02:54 < goalieca> > (reverse. ((take 3) . reverse)) [1..1000000]
23:58:40 <glguy> ahh
23:58:45 <vincenz> glguy: in my font, that's not so big
23:59:03 <shachaf> glguy: I think some others would object to that too.
23:59:15 <shachaf> glguy: Since (.) is associative.
23:59:21 <glguy> shachaf: sure, I didn't see the context
23:59:32 <goalieca> ouch, major space leak in that algo
