00:00:11 * sorear thinks out loud...
00:00:14 <roconnor> sorear: probably
00:01:11 <wli> zvrba: The slowness of arithmetic instructions operating on %esp is empirically verifiable. Explain it however you wish.
00:02:57 <sorear> This is equivalent to the existance of a decision procedure for is a *ground* expression zero...
00:03:15 <roconnor> what is a ground expression zero?
00:03:22 <zvrba> wli: ok, i'll make a benchmark :)
00:03:39 <zvrba> wli: *any* arithmetic is OK?
00:03:50 <zvrba> wli: sub/add/logic ?
00:03:59 <wli> zvrba: Itwill be vendor-dependent and model-dependent, too.
00:04:13 <zvrba> wli: I have several different P4 machines, as well as AMD ones.
00:04:30 <wli> Go P4.
00:04:42 <zvrba> wli: but anyway, what are you doing with un-threading?
00:05:10 <wli> zvrba: trying to catch ^C
00:05:42 <zvrba> hmmm...?
00:05:45 <zvrba> what is the problem with that?
00:06:29 <wli> zvrba: it waits for a newline by default
00:06:43 <glguy> ?shootout
00:06:43 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
00:07:07 <zvrba> wli: what kind of operations should I do ever ESP ?
00:07:17 <wli> zvrba: Linux does andl
00:07:32 <zvrba> ah, alignment. ok, will try that.
00:08:44 <newsham> do any haskell implementations allow commutative monads (ie Reader) to execute in parallel?
00:10:11 <Cale> newsham: You could implement that.
00:10:19 <newsham> wow, thanks
00:10:22 <Cale> (using `par`)
00:10:44 <newsham> reading one of wadler's papers he mentions using another par like notation
00:11:03 <Cale> You could write a parallelising identity monad as well.
00:12:46 <glguy> :-/ I looked at that haskell / ocaml comparison article, hoping to see some meaningful discussion
00:12:56 <glguy> and someone declares that he doesn't like ocaml because of the ;;
00:13:02 <glguy> and then people bother to respond
00:13:04 <glguy> ugh
00:13:21 <newsham> also its french
00:14:12 <glguy> so if a particular file pushes the type checker particularly hard it simply quits?
00:14:43 <newsham> used monads, never evaluated, only dropped once
00:15:12 * glguy doesn't want a compiler predisposed to surrender ;)
00:15:28 <glguy> maybe I should mention that on reddit to raise the level of discourse
00:17:13 <mauke> > let f x=(x,x);g=f.f;h=g.g;j=h.h;i=j.j;k=i.i;l=k.k in l""
00:17:20 <lambdabot>  ghc: failed with error code 9
00:17:52 <Japsu> !
00:18:30 <mauke> :t let f x=(x,x);g=f.f;h=g.g;j=h.h;i=j.j;k=i.i;l=k.k in l
00:18:45 <lambdabot> thread killed
00:18:45 <glguy> seems to lock ghci up
00:18:57 <mauke> say goodbye to your type checker
00:19:12 <newsham> :t let f x=(x,x);g=f.f;h=g.g;j=h.h;i=j.j;k=i.i in k
00:19:30 <lambdabot> thread killed
00:19:36 <newsham> :t let f x=(x,x);g=f.f;h=g.g;j=h.h;i=j.j in i
00:19:52 <lambdabot> thread killed
00:19:59 <newsham> :t let f x=(x,x);g=f.f;h=g.g;j=h.h in j
00:20:19 <lambdabot> forall a. -> ((((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a,
00:20:19 <lambdabot>  a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
00:20:19 <lambdabot> a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a,
00:20:19 <lambdabot> a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))), (((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
00:20:21 <lambdabot>  a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), (
00:20:24 <lambdabot> (a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
00:20:26 <Syzygy-> ...
00:20:27 <lambdabot>  a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))))
00:20:47 <RyanT5000> i didn't know lambdabot would return that much
00:22:28 <glguy> duplicates a 4^5 times (in the type system)?
00:22:37 <glguy> > 4^5
00:22:50 <glguy> 1024
00:23:08 <glguy> (depending on which version you used)
00:23:50 <lambdabot>  thread killed
00:23:57 <mauke> :t let f x=head[Left x,Right x];g=f.f;h=g.g;j=h.h in j
00:24:13 <lambdabot> thread killed
00:24:18 <mauke> :(
00:24:43 <mauke> > 2 + 2
00:24:50 <lambdabot>  4
00:24:54 <newsham> you upset the bot
00:25:14 <mauke> :t let f x=head[Left x,Right x];g=f.f;h=g.g;j=h.h in j
00:25:32 <lambdabot> thread killed
00:25:38 <wli> I'm still not getting proper signal handling. :(
00:25:51 <sorear> dons!!
00:27:22 <mauke> credit for this lambdabot exploit goes to TaPL
00:27:39 <glguy> ghci doesn't do so hot either
00:30:56 <RyanT5000> so, how would i go about debugging a segfault in a haskell program?
00:31:22 <RyanT5000> my stack looks like this: #0 0xSOMETHING in StgRun ()
00:31:24 <RyanT5000> that's it
00:31:48 <RyanT5000> (then a complaint: "Cannot access memory at address 0xbf66e3e8")
00:31:56 <Cale> RyanT5000: Compiler bug maybe?
00:32:06 <Cale> Or are you doing something odd with FFI?
00:32:07 <RyanT5000> so obviously gdb isn't going to help much
00:32:12 <RyanT5000> Cale: both?
00:32:28 <RyanT5000> i'm repeatedly allocating and deallocating things in SpiderMonkey
00:32:37 <RyanT5000> using haskell finalizers
00:32:59 <RyanT5000> i guess i'll try taking out the finalizer stuff, and just manually allocate and deallocate a bunch of stuff
00:35:06 <dons> ?bot
00:35:19 <lambdabot> :)
00:35:23 <dons> . 1+@
00:35:26 <dons> > 1+2
00:35:31 <lambdabot>  3
00:35:46 <ari> > let frl=fst.rootLabel; queue=map(flip Node []).map(length&&&take 1).group.sort; cmb n xs=let (b,e)=splitAt n xs in (Node (sum$map frl b, []) b):e; tree n=head.head.dropWhile(not.null.tail).iterate(cmb n.sortBy(comparing frl)); rpl ss acc (Node (_,a) [])=[(acc,a)]; rpl ss acc (Node _ ns)=concat$zipWith(\s n->rpl ss (s:acc) n) ss ns; hfm ss=let n = length ss in rpl ss "".tree n.queue in hfm "0123" "go go gophers"
00:35:48 <lambdabot>  [("00","e"),("10","h"),("20","p"),("30","r"),("01","s"),("11"," "),("21","g"...
00:35:53 <ari> My Haskell golf is weak
00:36:05 <ari> I can't think of a way to make n-ary Huffman encoding significantly shorter
00:46:59 <wli> Something must be holding a lock...
00:52:44 <wli> Well, I can shoot things by raising signals.
00:53:56 <RyanT5000> so, something's definitely wrong, but i still have no idea whether it's my fault or not
00:54:17 <RyanT5000> my finalizer is getting called about 30 times less than it should
00:54:25 <RyanT5000> (1020ish objects, 990ish finalizers)
00:55:46 <wli> Basically it looks like the main thread is stuck in a state where exceptions in the concurrency primitives can't reach it.
00:56:50 <RyanT5000> when i run it without a performGC after each allocation, it ends up doing 95k allocations, but only 1000 finalizations
00:57:46 <RyanT5000> and it only does between 1 and 20 finalizations at once
00:59:42 <wli> I can see that the handlers are getting run, since I can raiseSignal sigTERM in it and that kills things.
01:04:32 <RyanT5000> is there any reason why running performGC wouldn't actually collect everything?
01:04:37 <wli> AsyncException ThreaadKilled seems to get through.
01:05:16 <Cale> RyanT5000: hmm... I don't know. The ForignPtr doc says that the only guarantee is that the finaliser runs before the program terminates.
01:05:32 <JaffaCake> RyanT5000: shouldn't be - what isn't being collected?
01:05:42 <JaffaCake> Cale: ForeignPtrs don't have that guarantee any more
01:05:59 <Cale> JaffaCake: ah, so there are no guarantees at all :)
01:06:04 <JaffaCake> right :)
01:06:14 <RyanT5000> JaffaCake: well i have an action that allocates an object
01:06:21 <RyanT5000> (and then ignores it)
01:06:25 <Cale> Well, hopefully they're run at most once :)
01:06:26 <RyanT5000> a ForeignPtr
01:06:40 <JaffaCake> Cale: yes
01:06:44 <RyanT5000> and then does performGC
01:06:46 <RyanT5000> that's all it does
01:06:52 <RyanT5000> and i replicateM_ it a lot of times
01:07:08 <JaffaCake> ok
01:07:11 <RyanT5000> i've set the allocator to output a + and the deallocator to output a -
01:07:19 <wli> If the target thread is currently making a foreign call, then the exception will not be raised (and hence throwTo will not return) until the call has completed. This is the case regardless of whether the call is inside a block or not.
01:07:39 <RyanT5000> the output looks like "+++++++++++++++++++++++++++++++++++++----------------------------------------++++++++++++++++++++++++++++++++++-------------------------------------++++++++++++++++++++++++++++++++++++++----------------------------------"
01:07:41 <RyanT5000> etc.
01:07:50 <RyanT5000> i would expect "+-+-+-+-"
01:07:54 <wli> foreign call == readline
01:07:57 <JaffaCake> why?
01:08:19 <RyanT5000> JaffaCake: because the foreignPtr is clearly out of scope, and then i call performGC
01:08:24 <JaffaCake> the finalizer is not run synchronously by the GC
01:08:30 <JaffaCake> it is run in a thread, sometime later
01:08:32 <RyanT5000> JaffaCake: ah, ok
01:08:53 <RyanT5000> well that explains that, but i don't think it explains the eventual segfault i'm getting
01:09:28 <JaffaCake> if you have a segfault and you suspect a bug, narrow it down as much as possible and submit it
01:09:39 <RyanT5000> JaffaCake: that's what i'm working on: narrowing it down
01:09:46 <JaffaCake> ok, cool
01:10:16 <RyanT5000> all i know so far is that gdb claims that i'm in StgRun when it dies
01:10:23 <wli> So you need to run the IO in a separate thread so you don't shoot the whole program to get the exception past the FFI.
01:10:39 <JaffaCake> RyanT5000: gdb doesn't know how to debug Haskell code
01:10:51 <RyanT5000> JaffaCake: i know
01:11:11 <JaffaCake> RyanT5000: http://hackage.haskell.org/trac/ghc/wiki/DebuggingGhcCrashes
01:11:13 <lambdabot> Title: DebuggingGhcCrashes - GHC - Trac
01:11:19 <RyanT5000> ooh i figured out "a" bug in my code
01:11:22 <RyanT5000> it might be related
01:11:36 <RyanT5000> i'm not supposed to access a JavaScript context from two threads simultaneously
01:11:50 <JaffaCake> are you using -threaded?
01:12:08 <RyanT5000> for some reason i was assuming that finalizers would kick in synchronously with my allocation code
01:12:15 <RyanT5000> JaffaCake: no... i really should be, shouldn't i
01:12:22 <RyanT5000> i didn't even remember that option existed
01:12:26 <RyanT5000> that could be my whole problem
01:12:30 <JaffaCake> not necessarily - unless you use -threaded, you only get one OS thread
01:13:06 <RyanT5000> well.... -threaded seems to have fixed it
01:13:15 <RyanT5000> i hate that
01:13:35 <RyanT5000> i think i had the same problem last time i wrote something multithreaded in haskell, too!
01:13:36 <RyanT5000> grrr
01:13:44 <JaffaCake> -threaded might give you more problems, because it really will run code in multiple OS threads, and you'll have to manage access to the JS context
01:13:50 <RyanT5000> i hate it when i forget things
01:13:54 <RyanT5000> JaffaCake: yeah, but i'm OK with that
01:14:01 <JaffaCake> ok, fair enough :)
01:14:10 <RyanT5000> at least i *can* manage that
01:14:18 <RyanT5000> it was actually impossible for me to fix this problem :P
01:14:39 <RyanT5000> hm
01:14:49 <RyanT5000> well i'm still getting out-of-memory errors, but that's way better than segfaults
01:16:47 <quicksilver> RyanT5000: I'm slightly concerned that adding -threaded may have simply made your segfault into a race condition
01:16:57 <quicksilver> RyanT5000: (i.e. harder to reproduce)
01:17:01 <quicksilver> RyanT5000: rather than fixing it
01:17:30 <RyanT5000> quicksilver: hm; that's a good point
01:19:31 <RyanT5000> quicksilver: however, wouldn't -threaded not only tell it "use more threads" but also make certain operations threadsafe that might not be otherwise?
01:19:49 <RyanT5000> e.g., are malloc and free threadsafe when -threaded isn't used?
01:22:20 <RyanT5000> is there any way i can hook the garbage collector?
01:22:28 <quicksilver> I didn't think it changed that, but I could very well be wrong
01:22:32 <RyanT5000> just something to run before each garbage collection
01:23:39 <JaffaCake> RyanT5000: yes, various RTS APIs become threadsafe with -threaded, also Haskell functions you export using the FFI
01:24:12 <RyanT5000> JaffaCake: i think that must have been the problem
01:24:18 <JaffaCake> RyanT5000: there is no way to hook the GC right now
01:24:26 <RyanT5000> JaffaCake: how hard would it be to add one?
01:24:33 <JaffaCake> not hard at all
01:24:44 <JaffaCake> you need to compile up your own RTS, though
01:24:59 <RyanT5000> yeah... i'm going to try to get something working at all for now
01:25:03 <RyanT5000> and keep a list of unsafe things
01:27:58 <RyanT5000> JaffaCake: how about providing a hook for a C function that (somehow) tells you all the haskell objects that are visible through a ForeignPtr (or some new kind of ptr like it)?
01:29:40 <JaffaCake> RyanT5000: sounds like something we'd need to think about - you might want to send a proposal to cvs-ghc@haskell.org, or submit a feature request ticket
01:30:05 <RyanT5000> alright, i'll think a bit more about what i would really need and then submit it
01:44:28 <RyanT5000> JaffaCake: so, how would i go about adding a before GC hook?
01:44:42 <RyanT5000> where should i look first? i've never touched the RTS source before
01:45:21 <JaffaCake> rts/sm/GC.c : GarbageCollect() is the main entry point
01:47:21 <RyanT5000> so, how should i make this settable?
01:48:01 <RyanT5000> ideally each module should get a hook if it wants it
01:48:14 <RyanT5000> but i don't know if that's possible with the way it's set up
02:08:41 <roconnor> @check \a b -> atan a == atan b + atan((a-b)/(1+a*b))
02:08:42 <lambdabot>  Add a type signature
02:08:46 <roconnor> @check \a b -> atan a == atan b + atan((a-b)/(1+a*b))::Double
02:08:46 <lambdabot>  Couldn't match expected type `Double' against inferred type `Bool'
02:08:53 <roconnor> @check \a b -> atan a == (atan b + atan((a-b)/(1+a*b))::Double)
02:08:55 <lambdabot>  Falsifiable, after 2 tests: -1.3333333333333333, 4.25
02:09:09 <roconnor> > atan (-4/3)
02:09:11 <lambdabot>  -0.9272952180016122
02:09:42 <roconnor> > (\a b -> atan b + atan((a-b)/(1+a*b))) (-4/3) (4.25)
02:09:42 <RyanT5000> there must be some better way to mix deterministic and nondeterministic deallocation
02:09:43 <lambdabot>  2.214297435588181
02:10:07 <dcoutts> jfredett: the xmonad ebuild works fine, perhaps you just need to ACCEPT_KEYWORDS="~x86" emerge xmonad
02:10:07 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
02:11:02 <roconnor> > (\a b -> atan b + atan((a-b)/(1+a*b))) (-1) 2
02:11:03 <lambdabot>  2.356194490192345
02:11:08 <roconnor> atan (-1)
02:11:13 <roconnor> > atan (-1)
02:11:14 <lambdabot>  -0.7853981633974483
02:14:04 <dons> dcoutts: do you have a url for the ebuild that i can point to on the website for xmonad?
02:14:54 <dcoutts> dons: the thing to point to is the haskell overlay which contains xmonad and x11-extras (and loads of other things too)
02:15:07 * dcoutts finds 'layman' reference
02:15:41 <dons> i can has url plz?
02:16:46 <dcoutts> http://www.gentoo.org/proj/en/overlays/userguide.xml
02:16:47 <lambdabot> Title: Gentoo Linux Documentation -- Gentoo Overlays: Users' Guide
02:16:48 <dons> huh, another job using haskell as a filter to find better java/C++ programmers, http://www.yorz.com/listing/316323.htm
02:16:50 <lambdabot> Title: YorZ.com - Listing - Software Developer
02:17:56 <dcoutts> dons: so layman is a gentoo overlay manager tool, users can add the haskell overlay and emerge xmonad
02:18:30 <varlet> i tried twice. the first time my machine overheated compiling GHC and shut down. the second time it errored out about 2 hours into compilation
02:18:46 <varlet> then again, haskellers seem more interested in grooming their languages reputation on reddit than writing acutal code..
02:19:00 <dons> dcoutts: ok. cool
02:19:06 <dcoutts> varlet: that's a bit harsh
02:19:14 <dons> varlet: grab a binary from your distro
02:19:19 <dons> or from haskell.org/ghc
02:19:37 <dcoutts> dons: that's the most user friendly way of getting non-standard packages, just having the url to the ebuild isn't all that helpful as one would still need to know about overlays
02:20:09 <dons> ok. cheers
02:20:26 <dcoutts> dons: now if you can eliminate the x11-extras dep (eg by folding it into x11) then we'll add it to the main portage collection
02:20:42 <dons> ah ok. you don't want to add x11-extras then, i guess?
02:20:57 <dcoutts> we've been told it's not going to exist longer term
02:21:09 <dcoutts> so we'd rather not add and then remove it
02:21:10 <dons> i think that's sjanssen's plan, yeah
02:21:57 <dcoutts> even if xmonad moves to hxcb I think it'd make sense to fold x11-extras into x11
02:22:10 <RyanT5000> "Main: failed to create OS thread: Cannot allocate memory" - is there any way i can get a stack trace from this or something?
02:22:16 <dons> i think we'd fork xmonad, rather than move it over, anyway
02:22:32 <dons> RyanT5000: top? check your machine isn't overloaded
02:22:56 <RyanT5000> dons: no no it's an internal thing, involving the interaction between the haskell GC and the javascript GC
02:23:07 <dons> now you're scaring me
02:23:15 <RyanT5000> dons: i just want to see where, exactly, in the RTS, this is happening
02:23:17 <dons> try with profiling on
02:23:31 <dons> the prof file should contain some info (and with -xc for whatever it does)
02:23:41 <bdash> RyanT5000: heh, which JS engine are you using?
02:23:46 <RyanT5000> spidermonkey
02:24:14 <RyanT5000> i expect it's either before GC starts or when it trys to spawn a finalizer thread
02:24:19 <RyanT5000> but i need to know which
02:25:17 <RyanT5000> bdash: spidermonkey
02:25:28 <RyanT5000> (in case you wanted to be pinged)
02:26:09 <therp> what's hxcb?
02:27:09 <bdash> RyanT5000: thanks, i did see your answer :)
02:27:25 <RyanT5000> bdash: np
02:28:18 <dons> xcb binding for haskell, therp
02:28:22 <dons> sjanssen's soc project
02:29:32 <therp> what would be the motivation to replace xlib by xcb?
02:30:53 <mm_freak> i'm implementing the miller-rabin primality test…  it needs random numbers, but i don't expect it to fail
02:31:02 <mm_freak> is it safe to use unsafePerformIO ?
02:31:10 <dons> much much much smaller, and thread safe
02:31:24 <ohub> mm_freak: I think the name gives some hints ;)
02:31:35 <dons> mm_freak: um? for mutable randoms?
02:32:00 <dons> if the function is referentialy transparent , yes, otherwise *no* :)
02:32:03 <RyanT5000> mm_freak: use a RandomGen?
02:32:15 <dons> but yeah, just thread some randoms the haskell way
02:32:38 <mm_freak> yeah…  miller-rabin (theoretically) only works with random numbers
02:33:14 <dons> >
02:33:16 <mm_freak> assuming that the generalized riemann hypothesis is true, it is referntially transparent =)
02:33:22 <dons> > randomRs (0,10) (mkStdGen 10) :: [Int]
02:33:24 <lambdabot>  [0,2,1,10,4,10,0,8,6,10,7,2,6,10,9,3,1,3,4,3,4,1,8,4,6,0,10,6,2,3,8,1,3,8,10...
02:33:48 <mm_freak> hmm, yeah…  probably i should take random numbers as a parameter instead of the number of iterations
02:33:53 <dons> it depends on what you want to unsafePerformIO, you need to explain that.
02:34:12 <ivant> mm_freak, http://xkcd.com/221/
02:34:13 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
02:34:18 <mm_freak> dons: for the randoms
02:34:32 <RyanT5000> mm_freak: it's a monte carlo algorithm, right? which means it's only referentially transparent in the limit as you take an infinite number of samples, right?
02:34:35 <mm_freak> but i'll pass them as a parameter
02:35:08 <mm_freak> ryant5000: that really depends on whether the generalized riemann hypothesis is true or not…  we don't know
02:35:33 <mm_freak> you do need a certain minimum amount of samples though
02:35:39 <dons> for the randoms , its not pure is it -- you get a different number each time?
02:36:00 <desp> hmm
02:36:08 <mm_freak> dons: it's a primality test…  assuming it never fails, my idea was to just use unsafePerformIO
02:36:19 <desp> http://wagerlabs.com/archives/92.html -- ocaml vs haskell flame
02:36:20 <lambdabot> Title: Tenerife Skunkworks
02:36:26 <RyanT5000> mm_freak: well sure but even if the hypothesis is true, it still isn't necessarily the same for a single test, right? otherwise why would you need random numbers? you could just always use 5
02:36:32 <dons> yeah yeah, old joelr thread, desp :)
02:36:43 <desp> oh, right
02:36:47 <dons> he likes banging his head on untested approaches :)
02:36:59 <mm_freak> ryant5000: true
02:37:03 <desp> dons: I keep forgetting that people dig out old pages on reddit
02:37:14 <mm_freak> i don't understand all of the theory of the test
02:37:35 <mm_freak> simply put you need random numbers and a certain amount of them, so the test is reliable
02:38:07 <mm_freak> especially you must not just use [2..15] or something
02:38:21 <RyanT5000> mm_freak: "works 99.999% of the time" does not a referentially transparent function make
02:38:26 <mm_freak> someone has shows this to fail terribly in practice
02:39:09 <mm_freak> ryant5000: i would disregard that…  the probability that it fails is so low that you wouldn't find a single example of failure
02:40:09 <quicksilver> it's referentially transparent w.r.t a particular seed
02:40:15 <quicksilver> or infinite random list
02:40:21 <quicksilver> (same thing, basically)
02:40:29 <quicksilver> so make the seed/list a parameter, I would suggest
02:40:45 <mm_freak> quicksilver: yes, that's how i'm doing it now
02:47:21 <Saizan> any of you have used tagsoup's HTMLChar with an utf-8 input?
02:48:09 <Saizan> i need a decode :: [HTMLChar] -> String
02:48:21 <ivant> @where UTF8
02:48:21 <lambdabot> I know nothing about utf8.
02:48:56 <vincenz> lo
03:12:16 <vincenz> Who is in charge of planet-haskell?
03:12:31 <vincenz> Every time joelr puts one message onto hisblog, the planet-haskell is spammed with all his old mesasges
03:12:58 <desp> is it possible to define datatypes in ghci?
03:13:55 <RyanT5000> desp: i don't think so
03:14:04 <Saizan> vincenz: ibid i think
03:16:18 <ibid> oho, we have flooding?
03:16:20 <ibid> damn
03:16:21 <desp> mm
03:18:37 <ibid> don't see any flooding
03:18:47 <ibid> vincenz: the answer to your question is given in planet :)
03:19:20 <ibid> vincenz: and i don't see any such problem here
03:25:38 <vincenz> ibid: I see this problem when using the RSS feed from planet haskell in google's rss-reader
03:25:41 <vincenz> ibid: not the webpage version
03:25:50 <vincenz> ibid: I can check whether this is the rss or google's rss-reader
03:26:35 <vincenz> hmm, it seems to be in neither, but directly in the google-widget for planet-haskell o.O
03:26:58 <ibid> what's a google widget?
03:27:12 <ibid> vincenz: yes, i
03:27:19 <ibid> 've seen that too myself on google reader :)
03:27:29 <vincenz> ibid: if you have a google personalized homepage, you can add widgets, there's one predefined for planet-haskell
03:27:43 <vincenz> ibid: I'm trying this explicitly by making a new widget with the rss2.0.xml ul
03:27:44 <vincenz> url
03:27:56 <ibid> ah
03:28:39 <vincenz> ibid: hmm, seems to be not exactly the same content, the new widget has shannon's blog line, then all the ones from joelr
03:29:27 <ibid> looks like a google bug, then. the planet rss feed has just one joelr entry
03:29:36 <vincenz> Yes, very odd
03:29:41 <osfameron> I think I got that in bloglines too though
03:29:45 <vincenz> Alright, apologies for the disturbance.
03:30:40 <osfameron> yep, "Who let the dogs out" is back today again too in bloglines
03:30:47 <ibid> vincenz: google reader has another bug too that bites planet sometimes: it uses a non-link guid as a link
03:31:06 <vincenz> ibid: This is related to that bug we talked about a long time ago?
03:31:17 <vincenz> ibid: where I'd get illegal links?
03:31:24 <ibid> vincenz: likely
03:31:27 * vincenz nods
03:31:36 <ibid> vincenz: or rather, the one i just described is that one
03:31:47 <ibid> vincenz: probably unrelated to the one we've been discussing
03:32:04 <ibid> vincenz: i too use google reader nowadays and i'm bit by it :)
03:32:53 <vincenz> It's rather odd a company that has such strong web-products would have bugs like this.
03:35:21 <RyanT5000> is there a reentrant lock structure in the standard libs?
03:56:01 <mm_freak> it's so easy to convince people of the elegance of haskell
03:56:12 <mm_freak> lucas-lehmer test for mersenne primes in two lines =)
03:56:27 <RyanT5000> lol
03:57:13 <boegel> mm_freak: I can do the same in C in one single line!
03:57:33 <RyanT5000> yeah, gzipped-bytes is a better measure
03:58:06 <RyanT5000> although i think i'd prefer gzipped stripped-AST bytes
03:58:14 <opqdonut> AST?
03:58:19 <RyanT5000> abstract syntax tree
03:58:22 <mm_freak> boegel: but not as short and expressive
03:58:34 <vincenz> Did anyone get the lisp-xkcd cartoon with all the parentheses?
03:58:40 <xerox> mm_freak: paste :)
03:58:54 <mm_freak> llSequence n = unfoldr (\x -> Just (x, mod (x^2 - 2) n)) 4
03:58:59 <RyanT5000> i.e.: lex and parse the file, strip it of symbols (replace each symbol with a unique ID), dump that to disk, and gzip it
03:59:05 <mm_freak> mersennePrime p = llSequence (shiftL (1::Integer) p - 1) !! p-2 == 0
03:59:16 <RyanT5000> i think that gets you pretty close to estimating the actual entropy of the file
03:59:46 <mm_freak> here is a full program i just wrote:  http://streitmacht.eu/mprime.hs
04:01:46 <RyanT5000> mm_freak: why are you reimplementing `map` in testArgs?
04:02:07 <mm_freak> ryant5000: good question, actually
04:02:11 <RyanT5000> well, mapM_
04:02:17 <mm_freak> probably because i'm not a haskell professional =)
04:02:21 <RyanT5000> :P
04:02:23 <boegel> mm_freak: then you should add that to your statement... :-)
04:02:29 <RyanT5000> anyway i'd do
04:03:15 <opqdonut> vincenz: i did
04:03:19 <RyanT5000> main = liftM (flip mapM_) getArgs $ do
04:03:29 <vincenz> opqdonut: care to explain?
04:03:30 <mm_freak> ryant5000: like i always say:  learning haskell means reinventing the wheel a lot
04:03:39 <RyanT5000> mm_freak: learning anything usuallydoes
04:03:51 <mm_freak> yeah, but especially haskell
04:03:57 <mm_freak> at least, if you come from the C world
04:04:02 <opqdonut> vincenz: "an elegant weapon for a more civilized age" is what obi-wan says about the lightsaber he gives luke
04:04:13 <RyanT5000> mm_freak: yeah; the best thing to do is use hoogle a lot
04:04:21 <vincenz> opqdonut: Ah, I missed that reference :)
04:04:22 <daniel_larsson> RyanT5000: or main = liftM forM_ getArgs $ do
04:04:33 <opqdonut> vincenz: it'll become clear when you check the title attribute :)
04:04:35 <RyanT5000> daniel_larsson: ah, good point; i never use forM_, and i should
04:04:37 <opqdonut> (hover mouse over comic)
04:04:43 <vincenz> opqdonut: not really :)
04:04:54 <vincenz> opqdonut: I thought it was referring to the emperor without clothes
04:05:06 <opqdonut> nah, to the emperor dissolving the jedi council
04:05:26 <vincenz> That might explain, I didn't pull the star-wars link :)
04:05:33 <opqdonut> yeh
04:06:06 <mm_freak> ryant5000: IMO there's nothing wrong with reinventing the wheel
04:06:49 <|Steve|> How does one use a randomized data structure in Haskell?
04:06:57 <RyanT5000> mm_freak: true; in fact, for a very long time i had the mentality that i should not read papers on subjects i really cared about lest the prejudice me towards a particular methodology
04:07:23 <|Steve|> For example, say I wanted a randomized skip list, I think I can figure out how to do most of it but how would I deal with the random number generation?
04:07:28 <matthew-_> mmm. so if previously I was using System.Time.Parse and parsecCalendarTime which worked really nicely with parsec, what should I use now with Data.Time?
04:07:43 <RyanT5000> |Steve|: use System.random.RandomGen
04:07:51 <RyanT5000> |Steve|: System.Random.RandomGen
04:08:13 <RyanT5000> mm_freak: i used that method to learn everything i know about operating system design, and i think, as a result, i have some productively unorthodox ideas when it comes to OS design
04:08:18 <opqdonut> RyanT5000: not really the solution
04:08:32 <opqdonut> |Steve|: the easiest way is to make the operations happen in the IO monad
04:08:38 <opqdonut> and use randomIO
04:08:54 <|Steve|> I'd want to avoid using the IO monad because that seems sloppy.
04:08:54 <opqdonut> or the state monad, with the random number gen. as state
04:09:07 <opqdonut> but monadic is the way you want to go, i'd say
04:09:25 <xerox> Is it? You can use a State monad to thread the random number generator throughout the computation.  It is also available Cale's MonadRandom.
04:10:32 <opqdonut> xerox: as i said :)
04:10:36 <opqdonut> 2
04:10:42 <xerox> Too late :)
04:10:43 <opqdonut> "or the state monad, with the random number gen. as state"
04:10:46 <opqdonut> yeah
04:10:53 <opqdonut> but MonadRandom is worth looking into too
04:10:56 <xerox> ?quote stereo
04:10:56 <lambdabot> Stereo says: Welcome to #haskell where your questions are answered in majestic stereo!
04:11:28 <chaKKo_1521> http://www.pennergame.de/ref.php?uid=1521
04:12:02 <|Steve|> Isn't the State monad another one of those cheating ones where things really change?
04:12:13 <|Steve|> Like IO.
04:12:43 <RyanT5000> |Steve|: no
04:13:00 <|Steve|> Oh. Okay.
04:13:07 <RyanT5000> |Steve|: it's just a function of type a -> (b, a)
04:13:16 <xerox> |Steve|: the State monad provides you two basic operations get :: State s s; and put :: s -> State s () which operate on a state variable of type s threaded throughout the computation.
04:13:16 <|Steve|> Ah, okay.
04:13:18 <RyanT5000> |Steve|: a is the state, b is the return type
04:13:53 <|Steve|> I'm looking at System.Random and it looks like everything is in the IO monad.
04:14:12 <RyanT5000> |Steve|: you may have been thinking of ST, which does use mutable state under the covers but has a completely pure interface
04:14:18 <RyanT5000> |Steve|: look at RandomGen
04:14:27 <|Steve|> RandomGen is just a class.
04:14:39 <mm_freak> ryant5000: well, even if i found a suitable function for whatever i need…  i don't like to use things i don't understand
04:14:50 <mm_freak> so i intentionally reinvent the wheel often
04:15:12 <mm_freak> sometimes it becomes a square wheel, but usually it's worth it
04:15:21 <xerox> |Steve|: When you do your stateful computation you do start with a given state, which you get from IO, e.g. main = do { gen <- newStdGen; let result = runState yourComputation gen; print result }.
04:15:30 <RyanT5000> |Steve|: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html#t%3AStdGen
04:16:00 <|Steve|> Reading.
04:16:15 <RyanT5000> mm_freak: yeah, but after reimplementing each function once, you should really use the standard version; then others (as well as you) will have an easier time reading your code
04:16:50 <RyanT5000> mm_freak: ideally, if a function is in a library that everyone has, everyone should always use only it to do that operation - less aliasing is better for communication
04:17:53 <xerox> |Steve|: you can then easily implement a `give me a new random number' operation in the State monad, e.g. produceRandomInt :: State StdGen Int; produceRandomIntBetween (a,b) = do { gen <- get; let (n,gen') = randomR (a,b) gen; put gen'; return n }
04:17:56 <RyanT5000> mm_freak: that's why we have ad hoc polymorphism, too; it's much nicer to have + apply to all numbers rather than have a separate + for each type
04:18:48 <|Steve|> xerox: Okay, thanks.
04:18:59 <|Steve|> I'd been wondering about this on and off for a few days.
04:18:59 <xerox> produceRandomIntBEtween :: (Int,Int) -> State StdGen Int -- I changed mind while writing :)
04:19:11 <RyanT5000> or
04:19:26 <RyanT5000> produceRandomIntBetween = State . randomR
04:19:44 <mm_freak> ryant5000: sure, nothing wrong with that…  guess why i've so far never published anything in haskell
04:19:58 <xerox> Hiya Cale.
04:20:08 <Cale> hello
04:21:58 <matthew-_> @bot
04:22:09 <matthew-_> grrr. no λb
04:22:31 <opqdonut> ?bot
04:22:38 <opqdonut> was here just a while ago
04:23:07 <vincenz> Is it me or does qwe1234 write in lolcode?
04:23:07 <earthy> nope, seems awol
04:23:15 <vincenz> "i already know haskell, k thx"
04:23:17 <vincenz> Cale: !
04:23:31 <|Steve|> Where is State anyway?
04:23:39 <RyanT5000> |Steve|: Control.Monad.State
04:24:03 <|Steve|> Ah thanks. That was the one permutation of {Control,Monad,State} I hadn't tried. =)
04:24:37 <xerox> You can see them all here
04:24:38 <xerox> ?docs
04:24:56 <opqdonut> bot offline :(
04:25:25 <ivant> hmm, lambdabot2@#haskell_ru is alive, although it is running on the same machine as lambdabot
04:25:31 <|Steve|> State . randomR $ (0,10) doesn't work:  Ambiguous type variable `s' in the constraint. What am I missing?
04:25:43 <matthew-_> oh super. so data.time and system.time basically are completely incompatible
04:25:50 <opqdonut> :))
04:25:58 <RyanT5000> |Steve|: have you actually put it in a monad?
04:26:12 <|Steve|> No, I was playing with it in ghci.
04:26:26 <|Steve|> I take it I can't do that.
04:26:27 <RyanT5000> |Steve|: it needs to know what type the state is, which should be StdGen or something like that
04:26:51 <xerox> |Steve|: you need a StdGen, and use of runState.
04:26:59 <dons> ?bot
04:27:23 <|Steve|> Okay, well clearly I need to read more about this. I can't just play with it.
04:28:10 <RyanT5000> |Steve|: you need to do something along the lines of (fst $ runState (State . randomR $ (1, 10)) (mkStdGen 0))
04:28:11 <mm_freak> what is liftM used for?
04:28:29 <RyanT5000> mm_freak: it takes a nonmonadic function and "lift"s it into your monad
04:28:31 <dons> :t liftM
04:28:34 <RyanT5000> dons: bot down
04:28:35 <dcoutts> can an OSX user tell me the value of System.Info.os please?
04:28:39 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
04:28:44 <dons> e.g. liftM reverse getLine
04:28:47 <RyanT5000> dons: wrong, sry
04:28:47 <mauke> mm_freak: do { tmp <- something; return (f tmp) }
04:28:47 <vincenz> @bot
04:28:53 <lambdabot> :)
04:29:17 <RyanT5000> dons:  it was down a minute ago, but i guess you'd be the one to know, lol; i wasn't paying attention to who i was talking to
04:29:28 <taruti> How to define a fmap2 :: Functor f => (a -> b -> c) -> f a -> f b -> f c?
04:29:39 <RyanT5000> mm_freak: basically, the type says it all
04:29:40 <dcoutts> xerox: you use OSX right? what is the value of System.Info.os ?
04:29:51 <RyanT5000> taruti: you can't define that
04:29:53 <mm_freak> hmm
04:29:56 <xerox> dcoutts: I'm on linux now but if you need it I can reboot and check.
04:30:23 <taruti> RyanT5000: thanks, no wonder it seemed hard :)
04:30:24 <mm_freak> let's say i've got a list `xs' and want to putStrLn each element…  is this where liftM is useful?
04:30:32 <RyanT5000> taruti: what if you had two lists of different lengths, for example?
04:30:38 <RyanT5000> taruti: what are you trying to do?
04:30:39 <quicksilver> mm_freak: no, that's where mapM is useful :)
04:30:41 <mauke> mm_freak: no, you'd mapM_
04:30:52 <mauke> mm_freak: oh, wait
04:30:53 <xerox> dcoutts: how does one read that, is it a sysctl entry?
04:31:03 <dcoutts> xerox: in ghci
04:31:08 <xerox> OK
04:31:12 <dcoutts> ta
04:31:15 <mauke> mm_freak: do { tmp <- xs; return (putStrLn tmp) } is half of what you want to do
04:31:17 <quicksilver> mm_freak: liftM is useful if you have a pure function String -> String and you want to apply it to an IO String
04:31:20 <mauke> mm_freak: you'd also need sequence_
04:31:23 <Winterstream> lament: I take it you're not in yet?
04:31:24 <dcoutts> > System.Info.os
04:31:25 <lambdabot>   Not in scope: `System.Info.os'
04:31:29 <dcoutts> bah
04:31:36 <mm_freak> quicksilver, mauke:  that's what i was using up to now, but ryant5000 posted an example for getArgs evaluation earlier…  and i didn't understand it =)
04:31:37 <RyanT5000> mm_freak: no; liftM is useful in cases, e.g., when you have a pure function you want to run on the result of a monadic operation
04:31:48 <quicksilver> mauke: you were right the first time, it was mapM or mapM_ he wants
04:32:00 <mauke> quicksilver: yeah, but mapM_ is sequence_ . liftM
04:32:09 <mauke> so you can sort of do it
04:32:11 <quicksilver> mapM is sequence . map, I believe
04:32:19 <mauke> map is liftM
04:32:25 <quicksilver> map happens to be liftM but in a different monad :)
04:32:31 <mauke> sure
04:32:31 <quicksilver> that's just confusing the issue...
04:32:44 <taruti> RyanT5000: just generalizing some code and was trying to get away with using a Functor to abstract over a type constructor, but not enough in this case it seems.
04:32:46 <mm_freak> isn't mapM just a special case of liftM ?
04:32:54 <mauke> mm_freak: no
04:32:58 <mm_freak> mapM_, sorry
04:33:00 <mm_freak> not mapM
04:33:00 <quicksilver> no, it isn't
04:33:17 <quicksilver> mapM is about applying one action to a list of pure values
04:33:27 <quicksilver> liftM is about apply a pure function to the result of an action
04:33:30 <RyanT5000> taruti: you'd need some guarantee that the two things had the same structure *other* than the contained values
04:33:37 <mm_freak> ok, thank you
04:33:42 <xerox> dcoutts: "darwin"
04:34:07 <RyanT5000> mm_freak: basically, i just use liftM when i don't want to bother with using <-
04:34:22 <matthew-_> ok, so who wrote or has any knowledge at all of Data.Time
04:34:24 <matthew-_> ?
04:34:25 <mauke> just memorize this pattern: do { tmp <- something; return (f tmp) }
04:34:35 <matthew-_> specifically, how are you meant to construct a NominalDiffTime
04:34:39 <mauke> or look for ">>= return ." if you grok do notation
04:35:22 <taruti> RyanT5000: true. so just use a custom typeclass for the constraint (since the possible type constructors are not monads, so no liftM2 in this case)
04:35:33 <matthew-_> I am actually feeling quite murderous at the moment. System.Time was actually usable...
04:35:38 <mauke> matthew-_: looking at the docs I'd say by calling diffUTCTime
04:35:39 <mm_freak> ryant5000: yeah, i've got that
04:36:31 <RyanT5000> taruti: maybe... but it'll be a complicated typeclass; you'll have to statically have access to the structure of the data; it'll only be easy if your datastructure always has the same structure (i.e. a homogeneous tuple, a simply wrapped value, etc.)
04:36:32 <matthew-_> mauke: that's monumentally stupid though. I KNOW what the diff is I want. I shouldn't have to construct a and b just so that I can do a - b = c when I already know c
04:36:45 <mauke> matthew-_: oh, fromIntegral then
04:36:46 <mauke> it's a Num
04:37:05 <mauke> actually a floating point number
04:37:14 <matthew-_> oh joy. it just gets better.
04:37:32 <Winterstream> Could someone explain to me why IO is magical?
04:37:40 <matthew-_> rather than System.Time.ClockTime that used ints... and TimeDiff
04:37:41 <mauke> Winterstream: depends on your definition of "magic"
04:38:05 <mm_freak> ryant5000: main = liftM (flip mapM_) getArgs $ do
04:38:11 <mm_freak> what's the argument here?
04:38:17 <matthew-_> mauke: why on earth would anyone ever choose to replace an API that uses ints with one that uses floats?!
04:38:17 <RyanT5000> Winterstream: it depends on the outside world
04:38:33 <RyanT5000> mm_freak: yeah, although as that other guy pointed out, forM_ = flip mapM_, which is much nicer
04:38:49 <int-e> Winterstream: it's the only monad that can't be executed from Haskell itself (ignoring unsafePerformIO) - you need a run time system to do that.
04:38:51 <mauke> matthew-_: because you want more precision than integer seconds?
04:39:00 <mm_freak> ok, then i've got:  liftM forM_ getArgs $ do { … }
04:39:04 <RyanT5000> mm_freak: also, that's wrong; i messed up the first time, i think
04:39:07 <matthew-_> mauke: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html integer picoseconds
04:39:09 <lambdabot> http://tinyurl.com/32fcbr
04:39:12 <mm_freak> yeah, i guess so
04:39:25 <mauke> matthew-_: ok, I have no idea. :/
04:39:27 <mm_freak> it should go (\x -> do { … })
04:39:35 * matthew-_ considers rewriting Data.Time
04:39:35 <RyanT5000> mm_freak: it should be actually getArgs >>= mapM_ $ do
04:40:00 <mm_freak> you didn't understand my question, i guess
04:40:03 <RyanT5000> mm_freak: and yeah, there should be the \x
04:40:11 <mm_freak> ah ok
04:40:16 <RyanT5000> mm_freak: sorry, that was really bad code i gave you :P
04:40:58 <Winterstream> Ahhh. I get it then...
04:41:08 <xerox> dcoutts: do you need anything else?
04:41:08 <mauke> > mapM (\c -> [c, toUpper c]) "abc"
04:41:10 <lambdabot>  ["abc","abC","aBc","aBC","Abc","AbC","ABc","ABC"]
04:42:24 <Winterstream> In a way, everything in Haskell, besides IO is - oh, how the hell can I say this? - already "computed". It's incidental that we're using computers to get the answers. But Haskell programs are mathematical truths. But this isn't true of IO.
04:42:34 <Winterstream> Does this sound sort of right (if somewhat fuzzy)?
04:42:40 <dcoutts> xerox: that's all. I need it for cabal
04:43:00 <quicksilver> matthew-_: why aren't you using DiffTime?
04:43:03 <xerox> OK, it was "darwin" in case you missed few lines ago.
04:43:17 * xerox heads to lunch.
04:43:24 <RyanT5000> Winterstream: yeah, that's basically right; the principle you're talking about is called referential transparency
04:43:36 <ivant> Winterstream, not necessarily computed: that's just a possible optimization in a compiler
04:44:03 <RyanT5000> Winterstream: yeah, saying it's "computed" isn't quite right - it's just that *if you were to compute it* you would always get the same thing
04:44:38 <dcoutts> xerox: ok thanks! :-)
04:45:14 <matthew-_> quicksilver: I'm parsing a string. I know the number of millis. I just need to take the UTCTime/whatever and set the millis/picos explicitly
04:45:15 <RyanT5000> Winterstream: also, even things that could be computed at compile time usually aren't, because the compiler isn't smart enough (neither are any other language's compilers that i know of, except a few very experimental ones)
04:45:49 <RyanT5000> Winterstream: but, of course, most of your program can't be computed even in theory until you know what its input is
04:45:55 <quicksilver> matthew-_: the UTCTime constructor is exported, you can just set the seconds explicitly
04:46:32 <matthew-_> quicksilver: yeah, I know. It's still more pain than with System.Time though.
04:46:33 <Winterstream> Ryan: Yes. That's true. But it's so cool that Haskell pushes the "specialness" of IO all into the IO monad. And everything else is pure.
04:47:07 <quicksilver> matthew-_: System.Time was broken in so many way's it's not funny
04:47:11 <int-e> Winterstream: even the IO actions are constant in my view. It's the *execution* of these IO actions that can take different paths.
04:47:43 * matthew-_ mumbles something about "worked for me"
04:47:46 <RyanT5000> Winterstream: yep :) i actually found haskell by writing down a list of things i wanted in a programming language and googling for them; the separation of IO was the first thing on my list, and haskell does it the best - and now i'm here :)
04:47:54 <Winterstream> int-e: Yes, in the sense that the IO "script" one builds through binding is constant. And that is amazing. There is something deep about it.
04:48:46 <Winterstream> RyanT: Really? Wow. I didn't understand the importance of such separation until I fully understood what the Haskell community was going on about :).
04:48:57 <mm_freak> http://streitmacht.eu/mprime2.hs ⇐ that one better?
04:49:40 <RyanT5000> Winterstream: well, i had been working on designing a language for a while, because i was fed up with C++ and the other languages i was using.  i decided that nearly all my bugs were due to mutable state, and separation of IO is the way you get rid of mutable state
04:49:41 <opqdonut> Winterstream: well it's a c program is "constant" too in it's compiled form
04:51:14 <RyanT5000> opqdonut: if you have a c program and its full environment, e.g. in a chroot jail, and you isolate the kernel properly, it becomes pure
04:51:21 <Winterstream> opqdonut: Heh. I hadn't thought of it that way.
04:51:55 <opqdonut> mm_freak: please factor out the '++ show p ++ " = " ++ show (2^p - 1))' :)
04:52:17 <Winterstream> Ryan: That is part of Erlang's strength then - state cannot escape from a process. What do you think?
04:52:33 <RyanT5000> Winterstream: i think i need to learn a lot more about erlang :P
04:52:56 <RyanT5000> Winterstream: it's very near the top of my list of languages to learn
04:53:11 <ddarius> Ignoring some impurities, there is no state to escape a process.  However, it is easy enough to emulate state with concurrency so...
04:53:18 <mm_freak> opqdonut: `factor out'?
04:53:22 <dons> its just haskell without a type system or syntax though :)
04:53:27 <mm_freak> you mean, i shouldn't calculate it twice?
04:53:45 <opqdonut> mm_freak: well, it shouldn't be written twice
04:53:46 <opqdonut> imo
04:53:46 <ddarius> or laziness
04:53:46 <Winterstream> RyanT: It's a snap. It's such a tiny language. I think the hard part is to learn how to use its library (OTP) properly. The guys from slideaware said the same thing.
04:53:52 <opqdonut> just caught my eye :)
04:54:09 <RyanT5000> opqdonut: what's written twice? show p and show (formula p) are not the same thing
04:54:35 <Miwa> hello there, where I can find some haskell demos??
04:54:41 <quicksilver> RyanT5000: you have to look at the code :)
04:54:45 <RyanT5000> Winterstream: i also understand it has cool distributed system stuff
04:54:46 <ddarius> RyanT5000: Presumably the whole thing.
04:54:49 <quicksilver> RyanT5000: that whole subexpression is repeated
04:54:50 <opqdonut> RyanT5000: http://streitmacht.eu/mprime2.hs last two lines
04:54:55 <mauke> Miwa: you mean sample code?
04:54:59 <Miwa> yes
04:54:59 <quicksilver> personally I think it's fine though
04:55:00 <RyanT5000> opqdonut: ah ok :)
04:55:05 <mm_freak> opqdonut: http://streitmacht.eu/mprime3.hs
04:55:06 <mm_freak> better?
04:55:14 <quicksilver> I don't mind small repeated subexpressions which are next to each other in the code
04:55:21 <mm_freak> (much better actually)
04:55:32 <Winterstream> Miwa: Um, I think you'd do well to look for code on hackage.haskell.org - it contains many haskell libraries. Some of the libraries should still be quite small and simple.
04:55:44 <Miwa> ic
04:56:00 <mauke> Miwa: http://haskell.org/haskellwiki/Category:Code http://hackage.haskell.org/packages/hackage.html
04:56:01 <lambdabot> Title: Category:Code - HaskellWiki
04:56:16 <matthew-_> quicksilver: actually, I still don't see how to do this. I parse a string to get a UTCTime. I can deconstruct that to get a DiffTime since midnight. I need to set the millis in that whilst preserving hours mins and seconds. I can't decompose DiffTime. Am I being blind or what?
04:56:27 <opqdonut> mm_freak: nah i meansomething like: putStrLn $ (if prime p then "PRIME" else "NOT PRIME") ++ show p ++ " = " ++ show (mersenne p)
04:56:42 <Winterstream> Ryan: It's damn cool. I can also definitely recommend Joe Armstrong's PhD thesis. You learn a great deal about how to utilize Erlang well by looking at his code. For example, I didn't "factor out concurrency" before I read his PhD.
04:56:53 <mm_freak> opqdonut: i've done it this way for the sake of readability
04:56:59 <RyanT5000> Winterstream: hm, interesting
04:57:29 <RyanT5000> mm_freak: http://en.wikipedia.org/wiki/DRY
04:57:30 <lambdabot> Title: Don't repeat yourself - Wikipedia, the free encyclopedia
04:57:43 <Winterstream> Ryan: The PhD is, unlike most dissertations, very readable. Joe is obviously a very no-nonsense guy which is cool.
04:57:53 <RyanT5000> mm_freak: imho, DRY is the most important software engineering principle
04:58:08 <quicksilver> matthew-_: DiffTimes are instances of Num
04:58:13 <RyanT5000> Winterstream: cool; i'll check it out
04:58:17 <quicksilver> matthew-_: you can just 'add' in your milllis
04:58:32 <matthew-_> quicksilver: right, you've said that before. Sorry.
04:58:36 <quicksilver> :)
04:58:42 <quicksilver> it's OK, it is a bit surprising
04:58:52 <quicksilver> you often find haskell types which appear to be missing obvious operations
04:59:04 <quicksilver> because you don't notice those operations are provided by one of the typeclasses it implements
04:59:23 <matthew-_> yeah, I don't want to add though as the millis might be non-zero as they are. But it's not an integer so I can't mod...
05:00:00 <mm_freak> http://streitmacht.eu/mprime4.hs
05:00:04 <RyanT5000> matthew-_: presumably if you have two DiffTimes they should add properly
05:00:04 <mm_freak> now you're pleased =P
05:00:31 <matthew-_> I just need a controllable rounding function
05:00:35 <RyanT5000> mm_freak: looks good to me :)
05:00:36 <quicksilver> matthew-_: floor?
05:01:10 <matthew-_> err, depends where on earth the decimal point is in diff time
05:01:21 <quicksilver> matthew-_: after the seconds
05:01:29 <int-e> mm_freak: heh is there any reason why you use  a `mod` b  in one place and  mod a b  in another?
05:01:31 <quicksilver> matthew-_: 'Conversion functons will treat it as seconds'
05:01:45 <mm_freak> int-e: readability
05:01:54 <matthew-_> quicksilver: mmm. that's not the clearest of statements
05:01:57 <RyanT5000> matthew-_: isn't there a version of floor that lets you specify?
05:02:18 <matthew-_> in which case, I want a version of floor that rounds down after the 3rd dp
05:02:24 <mm_freak> int-e: i use the prefix version, whenever the `mod' is the outermost operator and i'd need to use parentheses anyway
05:02:28 <matthew-_> RyanT5000: I'm hoping so...
05:02:49 <RyanT5000> matthew-_: actually, i don't see one; i guess you'll have to multiply by 1000? sounds kind of lame
05:03:19 <matthew-_> RyanT5000: I'd be happy with a bitmask... ;)
05:03:52 <RyanT5000> matthew-_: a base 10 bitmask?
05:04:00 <matthew-_> ahh, good point ;)
05:04:10 <Winterstream> I was looking at D-BUS. It seemed promising as a way to do IPC between different languages (I'm specifically interested in using Haskell along with Open Source stuff). Then I realized everything is done in the OO way. It makes me want to cry. Besides my hatred of OO (with the exception of Smalltalk :)), it's so much work to create object interfaces and instantiate objects.
05:04:12 <int-e> matthew-_: you could start by dividing by 1.024 ;)
05:04:13 <matthew-_> RyanT5000: multiplying by 1000 and then dividing by 1000 is not guaranteed to give you back the same number with a float
05:04:34 <RyanT5000> matthew-_: yeah, i know
05:04:47 <RyanT5000> matthew-_: i don't know why the float function is so bad
05:05:01 <RyanT5000> matthew-_: it seems like the deeper i dig into haskell's standard typeclasses, the more i hate them
05:05:13 <matthew-_> sheesh, has anyone actually used this module for anything? Because it's not exactly the pinacle of useability
05:05:56 <quicksilver> matthew-_: difftimes are not floating point, by the way
05:06:09 <quicksilver> matthew-_: you shouldn't loose any accuracy
05:06:19 <matthew-_> quicksilver: then why aren't they in Integral?
05:06:29 <quicksilver> matthew-_: because they aren't integral either
05:06:37 <quicksilver> matthew-_: they're fixed precision
05:06:53 <quicksilver> newtype DiffTime = MkDiffTime Pico deriving (Eq,Ord)
05:06:56 <RyanT5000> quicksilver: that just means he's liable to chop off the top when he multiplies by 1000
05:07:14 <RyanT5000> is Pico = Integer?
05:07:21 <matthew-_> Pice = Int64 ?
05:07:41 <int-e> matthew-_: anyway, if you want decimal fixed point numbers you shouldn't using binary floating point numbers anyway.
05:07:52 * matthew-_ makes use of the "Source Code" link at the top of every api page
05:07:55 <quicksilver> int-e: and he isn't
05:08:02 <quicksilver> Pico is based on Integer, yes
05:08:07 <Miwa> mauke,there is some application code http://www.haskell.org/haskellwiki/Example_code can you teach me how tu run it?
05:08:08 <lambdabot> Title: Example code - HaskellWiki
05:08:22 <quicksilver> it's fixed precision, but unbounded size
05:08:41 <mauke> Miwa: which one?
05:09:08 <Miwa> hmp3?
05:09:14 <quicksilver> matthew-_: I think you want fromInteger . (/1000) . toInteger . (*1000)
05:09:32 <matthew-_> ahhh, Pico's actually in Data.Fixed.
05:09:34 <Miwa> i try to run it with winhugs but nothing happen
05:09:41 <mauke> http://www.cse.unsw.edu.au/~dons/code/hmp3/README
05:09:44 <quicksilver> right
05:10:14 <mauke> I doubt it will work in hugs
05:10:24 <matthew-_> which also contains variations on div and mod
05:10:25 <mauke> Core.hs imports GHC.Handle
05:10:52 <matthew-_> quicksilver: I think flip mod' (0.01) might work
05:11:12 <quicksilver> matthew-_: yeah, I was just looking at that
05:11:13 <Miwa> mauke,can i run it in GHCI
05:12:02 <mauke> very unlikely. this is a full-screen application
05:12:04 <quicksilver> RyanT5000: out of curiousity why do you think haskell's float functions are bad?
05:12:09 <int-e> quicksilver: s/toInteger/floor/
05:12:47 <RyanT5000> quicksilver: i don't have a particular opinion on the float functions actually, although it does seem like a given-decimal-point floor would be useful
05:12:49 <int-e> quicksilver: and there's something odd about the order. (/1000) . floor . (*1000) looks better
05:13:08 <RyanT5000> quicksilver: i have more opinions on monads and monad transformers and such
05:13:15 <int-e> err. (/1000) . fromInteger . floor . (*1000)
05:13:22 <quicksilver> :t floor
05:13:24 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
05:13:34 <quicksilver> int-e: floor is only defined on realfracs
05:13:40 <quicksilver> int-e: that's why I used toInteger
05:13:50 <int-e> @type toInteger
05:13:51 <quicksilver> :t toInteger
05:13:54 <lambdabot> forall a. (Integral a) => a -> Integer
05:13:54 <lambdabot> forall a. (Integral a) => a -> Integer
05:13:59 <quicksilver> ah d'oh
05:14:03 <quicksilver> not very smart then :)
05:14:39 <quicksilver> I think it's probably a bug that DiffTime isn't an instance of RealFrac
05:14:49 <quicksilver> but I also think mod' is quite a pretty solution, if it works
05:15:29 <int-e> @instances-importing Data.Fixed RealFrac
05:15:32 <lambdabot> Double, Fixed a, Float
05:15:49 <int-e> yes, mod' is pretty, too.
05:16:17 <matthew-_> quicksilver: though I think it's actually div' I want :)
05:16:57 <int-e> but div' isn't pretty.
05:17:04 <int-e> @src Data.Fixed.div'
05:17:04 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:17:08 <int-e> div' n d = floor ((toRational n) / (toRational d))
05:17:15 <matthew-_> ewwwwww!
05:17:34 <EvilTerran> what's mod'?
05:17:36 <matthew-_> right, mod' it is then!
05:18:05 <matthew-_> mod' n d = n - (fromInteger f) * d where
05:18:09 <int-e> mod' is implemented in terms of div'
05:18:10 <matthew-_>     f = div' n d
05:18:20 <matthew-_> true
05:18:37 <int-e> toRational shouldn't exist :/
05:19:11 <int-e> at least not in Real
05:19:33 <quicksilver> int-e: I think toRational is fine, it's just 'Real' is the wrong name for the class :)
05:19:56 <int-e> on the other hand I don't understand why Real doesn't have truncate, floor and ceiling.
05:20:00 <matthew-_> provided that the Real is a Double and that Double can represent 10^(-12) across its whole range (which it can't) then it should be fine
05:20:54 <RyanT5000> MVar is really pissing me off right now
05:21:02 <RyanT5000> why is there no tryReadMVar?
05:21:15 <int-e> quicksilver: try making a data type that implements, say, a + b*sqrt(2) over rational useful. toRational will bite you there.
05:21:18 <quicksilver> matthew-_: Real isn't Double
05:21:26 <quicksilver> matthew-_: Real is just a type class
05:21:34 <quicksilver> matthew-_: this particular reals, for example, are fixed precision
05:21:45 <quicksilver> int-e: I know; I'm just saying the TC is useful but Real is the wrong name for it
05:22:29 <matthew-_> quicksilver: yep, sorry, I'm being really slow today
05:23:24 <int-e> quicksilver: hmm ok. RealFrac and Real should just exchange their members :)
05:30:47 * matthew-_ finally figures out that Fixed is really just an Integer.
05:31:28 <Cale> RyanT5000: tryTakeMVar?
05:31:35 <quicksilver> matthew-_: :)
05:31:39 <RyanT5000> Cale: I can't *take* it, though
05:31:42 <Cale> er, oh
05:31:44 <Cale> right
05:32:01 <quicksilver> why can't you take it?
05:32:14 <mauke> RyanT5000: just use STM!
05:32:16 <quicksilver> why not tryTake + Put ?
05:32:17 <RyanT5000> quicksilver: because then another thread waiting on put might use it
05:32:27 <RyanT5000> mauke: i'm trying to make a reentrant lock in IO
05:32:58 <mauke> what's a reentrant lock?
05:33:11 <quicksilver> RyanT5000: use block
05:33:16 <RyanT5000> mauke: it's a lock that can be acquired as many times as you want, so long as they're all with one thread
05:33:18 <quicksilver> RyanT5000: (look at the source for readMVar)
05:33:31 <quicksilver> RyanT5000: readMVar is implement with take + put
05:33:31 <roconnor> mauke: a lock win which a thread can aquire the lock even if it already is holding it.
05:33:44 <roconnor> s/win/in/
05:34:09 <Cale> RyanT5000: You want threads that try to take the lock when it's not available to get put into a queue?
05:34:32 <RyanT5000> quicksilver: i already looked at that source; it won't work, the block isn't in there to guarantee no thread switches; it's in there to guarantee other things (that the take/put pair won't get interrupted by receiving an asynchronous interrupt); they should have used brakcet
05:34:35 <RyanT5000> *bracket
05:34:39 <RyanT5000> Cale: yeah
05:34:54 <quicksilver> RyanT5000: then you're saying Read is already broken?
05:35:12 <quicksilver> RyanT5000: because if you are, that's a serious bug
05:35:34 <RyanT5000> quicksilver: i'll double-check, but no, that's not what i was saying
05:36:08 <quicksilver> it seems to me that if you can't implement the 'tryReadMVar' you want using 'block'
05:36:19 <quicksilver> then the original readMVar also shouldn't be written using block
05:36:25 <Cale> RyanT5000: okay
05:36:27 <quicksilver> since they sound like they're supposed to be the same, to me
05:36:52 <mauke> withReentrantLock :: IO a -> IO a
05:37:05 <RyanT5000> mauke: does that exist?
05:37:08 <mauke> no
05:37:18 <RyanT5000> mauke: yeah, nevermind, obviously it'd need a parameter
05:38:05 <RyanT5000> quicksilver: actually, i'm pretty sure that readMVar can end up blocking indefinitely if another thread issues a put between its take and its put
05:38:38 <quicksilver> JaffaCake: ping? Does 'block' make MVar operations atomic?
05:38:41 <RyanT5000> quicksilver: block doesn't have anything to do with other threads
05:38:49 <RyanT5000> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Ablock
05:38:51 <lambdabot> http://tinyurl.com/yk8zqb
05:39:03 <samreid> readMVar is in fact written exactly the way it's documented..
05:40:03 <quicksilver> RyanT5000: ah you're right
05:40:11 <quicksilver> RyanT5000: here's an email confirming it:
05:40:16 <quicksilver> http://www.mail-archive.com/haskell-cafe@haskell.org/msg02129.html
05:40:17 <lambdabot> Title: RE: Interruptibility and thread safeness with readMVar, http://tinyurl.com/ywu322
05:40:21 <JaffaCake> quicksilver:  everything ok?
05:40:39 <quicksilver> JaffaCake: trying to understand the semantics of readMVar but found an old email from your which explains it
05:40:50 <quicksilver> JaffaCake: namely, that it can deadlock if another thread puts
05:40:59 <JaffaCake> ok, good :)
05:41:10 <quicksilver> JaffaCake: it is not an 'atomic read' : arguably this could be better documented
05:41:53 <JaffaCake> send me some better documentation, then!
05:42:21 <RyanT5000> maybe i have to use STM
05:42:53 <quicksilver> RyanT5000: or just promise that all your threads take before they put
05:42:57 <quicksilver> RyanT5000: and then it's safe
05:42:59 <JaffaCake> quicksilver: normally you wouldn't have another thread doing put, all threads would be doing take+put
05:43:05 <quicksilver> right, exactly
05:43:18 <RyanT5000> quicksilver: yeah, but i actually need 3 states
05:43:32 <RyanT5000> i was planning on doing "everything is put + take"
05:43:35 <quicksilver> then perhaps you need two mvars?
05:43:46 <quicksilver> most problems with mvar abstractions can be solved with an extra mvar or two :)
05:43:55 <quicksilver> and some agreed discipline about the order in which you access them
05:43:57 <RyanT5000> quicksilver: yeah, i know, i'm trying to figure it out :P
05:44:28 <RyanT5000> basically, the mvar either has nothing in it (lock unacquired) or a (ThreadId, Integer) pair
05:44:56 <quicksilver> try having the mvar always full
05:45:04 <quicksilver> but containing a Maybe (ThreadID, Integer)
05:45:12 <RyanT5000> quicksilver: then i have to spinwait
05:45:16 <RyanT5000> *busywait
05:45:16 <quicksilver> then all threads always do a take + put
05:45:46 <quicksilver> hmm right
05:45:54 <quicksilver> so sounds like two MVars then
05:46:05 <quicksilver> one MVar ()
05:46:13 <quicksilver> which just regulates the queue
05:46:18 <quicksilver> (of threads which want to acquire the lock)
05:46:25 <RyanT5000> yeah
05:46:28 <quicksilver> and one MVar (ThreadID,Integer)
05:46:32 <quicksilver> the latter is always full
05:46:48 <quicksilver> MVar Maybe (ThreadID,Integer) in fact
05:46:52 <RyanT5000> yeah
05:46:58 <RyanT5000> i think that should work
05:47:05 <quicksilver> you have take+put discipline on the second mvar
05:47:08 <quicksilver> so it's "Read-safe"
05:47:13 <quicksilver> but not on the first
05:47:15 <RyanT5000> yeah
05:47:32 <RyanT5000> well, now that the first is (), it can be take-put or put-take; it doesn't really matter
05:48:43 <hpaste>  mauke pasted "withReentrantLock" at http://hpaste.org/2094
05:48:50 <mauke> ^ would this actually work?
05:49:25 <RyanT5000> mauke: well, you're definitely going to need to keep a count of acquisitions
05:49:31 <mauke> why?
05:50:04 <RyanT5000> mauke: otherwise how are you going to nest them?
05:50:13 <RyanT5000> the inner one will release the lock, right?
05:50:19 <mauke> no
05:50:32 <mauke> the lock is only released if it was Nothing initially
05:50:40 <RyanT5000> mauke: ah, ok
05:50:57 <mauke> missing "do" in line 11, btw
05:51:07 <RyanT5000> mauke: that looks like it might work then
05:51:57 <RyanT5000> that's a lot smarter than what i was thinking :P
05:52:29 <quicksilver> something funny about concurrency
05:52:36 <quicksilver> there are always other ways to do it
05:52:42 <quicksilver> often ones you (well, I) wouldn't think of
05:52:55 <quicksilver> there are a lot of mappings from a given problem to a set of MVars or TVars
05:53:01 <RyanT5000> yeah
05:53:22 <taruti> What would be a good version of the 6.7 line to try out? 20070726 fails on make install on i386-linux (with: ghc-pkg: dependency rts-1.0 doesn't exist)
05:57:05 <RyanT5000> mauke: actually, i think yours works, but is a busy-wait
05:57:18 <ndm> @seen kpreid
05:57:18 <lambdabot> kpreid is in #haskell. I don't know when kpreid last spoke.
05:57:28 <ndm> @gently-prod kpreid
05:57:28 <lambdabot> Unknown command, try @list
05:57:32 <kpreid> @have-now-seen kpreid
05:57:33 <lambdabot> Unknown command, try @list
05:57:33 <RyanT5000> mauke: nevertheless, i'm stealing your "return the release action" idea :P
05:57:35 <mauke> RyanT5000: why do you think it's a busy wait?
05:57:42 <kpreid> ndm: sorear answered my questions
05:57:49 <RyanT5000> mauke: isn't it going to keep retrying over and over?
05:57:59 <mauke> RyanT5000: that's not how retry works
05:58:14 <RyanT5000> mauke: really?
05:58:26 <mauke> ya srsly
05:58:47 <ndm> kpreid: good good, i'm actually about to change it, so its more obvious from the type
05:58:57 <ndm> kpreid: are you on the Yhc mailing list?
05:59:03 <mauke> Retry execution of the current memory transaction because it has seen values in TVars which mean that it should not continue (e.g. the TVars represent a shared buffer that is now empty).
05:59:04 <kpreid> ndm: no
05:59:07 <mauke> The implementation may block the thread until one of the TVars that it has read from has been udpated. (GHC only)
05:59:15 <RyanT5000> mauke: "The implementation _may_ block the thread until one of the TVars thta it has read from has been updated."
05:59:28 <ndm> kpreid: i recommend joining, we occasionally change the Core libraries, but always email out a proposal first on that list, and document any changes there
05:59:32 <mauke> I'm assuming a non-retarded implementation here
05:59:42 <RyanT5000> mauke: that's an assumption i try never to make :P
05:59:47 <RyanT5000> although
05:59:59 <RyanT5000> in this case, it would be *so* retarded that i think i'll deal with it
06:00:16 <RyanT5000> because it could always busy-wait on an MVar if it was retarded enough
06:08:44 <koala_man> I have two functions that return Maybe. how do I return the value of the first if it's Just, otherwise the second?
06:08:56 <dfranke_> Ha!
06:08:59 <mauke> mplus
06:09:00 <dfranke_> FlowArrow.hs:92:38: My brain just exploded.
06:09:01 <quicksilver> koala_man: `mplus`
06:09:04 <EvilTerran> @src Maybe mplus
06:09:04 <lambdabot> Nothing `mplus` ys  = ys
06:09:04 <lambdabot> xs      `mplus` _ys = xs
06:09:11 <dfranke_> ghc: 1000000, dfranke: 1
06:09:16 <koala_man> great, thanks
06:09:51 <mauke> @ghc
06:09:51 <lambdabot> ghc says: GHC stack-space overflow
06:10:32 <opqdonut> :)
06:11:27 <byorgey> morning, everyone!
06:11:45 <byorgey> today is a good day I think for discussing Haskell.
06:17:08 <RyanT5000> grrr; haskell's complaining that it doesn't have enough memory left.  if it would ever bother to run my damn finalizers, it would get some of its bloody memory back.
06:17:35 <opqdonut> :)))
06:17:41 <RyanT5000> seriously, how can the GC have 40k outstanding finalizers and complain about not enough memory?
06:18:10 <RyanT5000> i *know* that it can figure out that they're final - it figured it out for 10k of them, and it's just a replicateM_
06:20:53 <RyanT5000> is there some way to make it know to run finalizers when it's running low on memory?
06:34:26 <taruti> RyanT5000: System.Mem performGC does not help?
06:34:43 <RyanT5000> taruti: it does, but i can't be calling that constantly
06:35:09 <RyanT5000> also, it doesn't help much
06:35:39 <RyanT5000> taruti: actually, i just checked again, and it doesn't help at all
06:35:52 <Cale> Who wanted a reentrant lock implementation?
06:35:56 <RyanT5000> me
06:36:00 <quicksilver> are you *sure* those objects are actually dead, RyanT5000 ?
06:36:08 <quicksilver> that does seem like the most likely explanation...
06:36:10 <Cale> RyanT5000: did you get one?
06:36:12 <RyanT5000> Cale: mauke produced an excellent one
06:36:16 <quicksilver> (if performGC doesn't kill them)
06:36:16 <Cale> okay, cool
06:37:17 <RyanT5000> quicksilver: i'm pretty damn sure; i'm running mkObject, which creates and returns (but doesn't store) a foreignptr to a javascript object
06:37:23 <Cale> RyanT5000: are you talking about withReentrantLock on hpaste, or was it somewhere else?
06:37:35 <RyanT5000> Cale: yeah, i think that was it
06:37:48 <RyanT5000> there's a syntax error or something, but the rest looks right to me
06:38:08 <RyanT5000> quicksilver: then, i'm running mkObject a bunch of times in a replicateM_
06:38:48 <RyanT5000> quicksilver: so given that *some* of them are found to be dead (in the last run i did, 11166 were finalized), i can't imagine they wouldn't *all* be dead
06:38:50 <quicksilver> and some of those seem to get collected but others don't?
06:38:57 <RyanT5000> right
06:38:58 <quicksilver> that is definitely odd
06:39:00 <quicksilver> hmm
06:39:01 <RyanT5000> yep
06:39:11 <Cale> I did one that does queueing of the waiting threads using STM.
06:40:10 <RyanT5000> quicksilver: in fact, it seems like the more i GC, the faster it dies
06:40:29 <RyanT5000> quicksilver: i just changed it from doing a performGC every 1000 allocations to doing a performGC *every* allocation
06:40:47 <RyanT5000> quicksilver: and then it died after only 390 allocations and 6 deallocations
06:41:07 <RyanT5000> (instead of about 26k and 11k when it was every 1000)
06:42:20 <quicksilver> sounds like your finalisers themselves are leaking memory?
06:42:22 <quicksilver> maybe?
06:42:25 * quicksilver looks doubtful
06:42:51 <RyanT5000> quicksilver: i doubt it... i've marked every memory allocation and deallocation in my program with putStr "something"
06:43:19 <apfelmus> i heard that accessing stdout or something is a bad idea in finalizers
06:43:37 <RyanT5000> apfelmus: it probably is, but i doubt it's causing this problem
06:44:37 <RyanT5000> when i allocate an object i see a +, and when i allocate a finalizer i see a ^ (i have self-deleting finalizers, but i'm pretty sure they're also not the problem - basically, i have one master finalizer, and it gets passed a pointer to the haskell finalizer, which it deletes after running)
06:45:51 <RyanT5000> then, when the finalizer gets deleted i see a v and when the object gets deleted i see a -
06:46:04 <RyanT5000> the v's and -'s always add up, as do the +'s and ^s
06:46:12 <RyanT5000> just not to each other
06:46:16 <apfelmus> finalizer's aren't normal haskell functions?
06:46:22 <apfelmus> *the finalizers
06:46:39 <RyanT5000> apfelmus: not for ForeignPtr finalizers; they're C functions
06:46:58 <RyanT5000> it was a pain to make haskell functions work with them :
06:46:58 <RyanT5000> :P
06:47:06 <RyanT5000> btw, everything works perfectly if i manually finalize each object
06:47:16 <RyanT5000> so the problem is definitely between the GC and the finalizers
06:47:29 <RyanT5000> it's not detecting and/or bothering to run all of them
06:47:38 <allbery_b> I wouldn't be surprised if IO in finalizers is a problem (barring unsafePerformIO)
06:47:52 <allbery_b> but then I suspect that's necessary anyway
06:48:41 <apfelmus> ah, indeed the finalizers are not Haskell ones
06:48:46 <RyanT5000> allbery_b: ForeignPtr finalizers are FunPtr (Ptr a -> IO ())
06:48:57 <RyanT5000> so IO should be expected
06:50:04 <RyanT5000> hm... maybe some of my finalizers are deadlocked?
06:50:16 <apfelmus> "In general, it is not recommended to use finalizers on separate objects with ordering constraints between them. To express the ordering robustly requires explicit synchronisation using MVars between the finalizers, but even then the runtime sometimes runs multiple finalizers sequentially in a single thread (for performance reasons), so synchronisation between finalizers could result in artificial deadlock. Another alternative is to use explicit r
06:50:40 <opqdonut> explicit r.....
06:50:42 <opqdonut> got cut off
06:50:49 <apfelmus> in the documentation of  touchForeignPtr
06:50:56 <apfelmus> 2explicit reference counting"
06:51:05 <quicksilver> RyanT5000: have your finalizers print '{' as they start and '}' as they finish
06:51:05 <RyanT5000> apfelmus: i don't have any finalizer dependencies
06:51:11 <quicksilver> RyanT5000: and see if you can see any unbalances
06:51:17 <RyanT5000> quicksilver: i've already got them printing + and - ;)
06:51:25 <RyanT5000> quicksilver: and the other ones printing ^ and v
06:51:29 <quicksilver> I thought that was allocate and de-allocating?
06:51:38 <quicksilver> I'm talking finalize-begin and finalize-end
06:51:40 <RyanT5000> quicksilver: oh, sorry
06:51:42 <quicksilver> so you can see if it deadlocks
06:51:46 <RyanT5000> quicksilver: good idea
06:51:49 <apfelmus> why do you _allocate_ finalizers??
06:52:25 <RyanT5000> apfelmus: because i've got haskell closures as finalizers, and the finalizer thing only allows C functions
06:52:28 <RyanT5000> so i need to wrap them
06:52:32 <RyanT5000> which is allocation
06:52:44 <apfelmus> o.O that looks dangerous
06:52:47 <opqdonut> woah
06:53:04 <RyanT5000> apfelmus: yeah, it is, but i'm pretty sure it isn't the problem
06:53:19 <apfelmus> i somehow doubt that
06:53:29 <hpaste>  ivant pasted ""is permutation (?) possible"-function" at http://hpaste.org/2096
06:53:45 <ivant> guys, can you help me with the just-pasted function
06:53:51 <RyanT5000> apfelmus: well then why would it work 11 thousand times but not the other 30 thousand?
06:54:07 <RyanT5000> apfelmus: and why would it *always* work when i'm manually finalizing
06:54:24 <apfelmus> heisenbugs?
06:54:40 <taruti> RyanT5000: why not use addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO (), instead of going Haskell->C->Haskell?
06:55:02 <RyanT5000> @t addForeignPtrFinalizer
06:55:02 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
06:55:14 <taruti> in Foreign.Concurrent
06:55:30 <RyanT5000> taruti: i had no idea such a function existed
06:56:15 <vincenz> ivant: sec :)
06:56:31 <apfelmus> i wouldn't be surprised if the problem is indeed the use of Haskell functions as finalizers
06:56:59 <RyanT5000> apfelmus: i'll give it a shot
06:57:57 <hpaste>  Cale pasted "queuing reentrant lock" at http://hpaste.org/2097
06:58:45 <RyanT5000> Cale: is that better than mauke's?
06:59:28 <vincenz> @hoogle guard
06:59:28 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
06:59:28 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
06:59:28 <lambdabot> Language.Haskell.TH.Guard :: data Guard
06:59:49 <Cale> Does mauke's queue the requests to lock, and give the lock to the threads in the order that they attempted to take it?
07:00:11 <RyanT5000> Cale: that depends on the implementation of retry
07:00:20 <Cale> Yeah, then it probably won't.
07:00:44 <Cale> (retry doesn't make any guarantees about which thread is going to proceed)
07:00:52 <hpaste>  vincenz annotated ""is permutation (?) possible"-function" with "solution?" at http://hpaste.org/2096#a1
07:00:56 <vincenz> ivant: check that paste :)
07:00:57 <vincenz> ivant: it works :)
07:01:05 <RyanT5000> Cale: hm
07:02:14 <ivant> vincenz, thanks, trying now to understand it :-)
07:02:33 <hpaste>  vincenz annotated ""is permutation (?) possible"-function" with "using list comprehensions" at http://hpaste.org/2096#a2
07:02:37 <vincenz> ivant: chek this one
07:02:40 <vincenz> it uses list comprehensions
07:03:25 <Cale> RyanT5000: despite the length of that code, it is actually pretty trivial -- it was surprisingly easy to actually write (I spent most of the time figuring out a good way to actually check that it works, and settled on that little message-passing interface)
07:03:52 <gkr> Where do I find the source of Data.Graph?
07:03:57 <Cale> STM means that you don't have to worry about taking things temporarily and having other threads see what you're doing :)
07:03:59 <vincenz> ivant: my solution hinges on the fact that for an empty list, there is a solution, namely an empty list ... slight imperfection, but ok
07:04:00 <ivant> is there some paper which describes how comprehensions translate into the monad binds? I remember that I read something like that
07:04:22 <RyanT5000> Cale: yeah, i need to start using it more (you know, when i actually have concurrent code to write :P)
07:04:29 <Cale> :)
07:05:51 <ivant> @src guard
07:05:51 <lambdabot> guard True  =  return ()
07:05:51 <lambdabot> guard False =  mzero
07:05:54 <quicksilver> gkr: click on the little 'source' link in the top-right of the docs, if you just want to browse it
07:07:13 <gkr> Ohh, there was it. Thanks quicksilver.
07:10:08 <taruti> Are any of the july binary i386-linux snapshots of ghc 6.7 working? they all seem to fail at make install. (or I am just picking a bad selection of them)
07:15:42 <RyanT5000> apfelmus: you were completely right, thanks :)
07:15:52 <RyanT5000> apfelmus: it works correctly with Foreign.Concurrent
07:16:48 <RyanT5000> apfelmus: now i just need to get rid of *actual* concurrency problems, e.g. the deallocation thread requiring the same lock as the allocation thread
07:25:58 <apfelmus> RyanT5000: (^_^)
07:26:19 <RyanT5000> apfelmus: i'm not used to haskell things having unexpected interactions
07:26:52 <RyanT5000> apfelmus: i figured if i could write the code to wrap a haskell function in a C function entirely in haskell, and followed all the documentation, it would probably work :)
07:27:32 <apfelmus> hehe :) well, as soon as concurrency is involved, things can get arbitrarily unexpected anyway
07:28:00 <RyanT5000> yeah, but this doesn't seem like an arbitrary concurrency problem; this sounds like haskell not being reentrant
07:28:34 <taruti> Haskell is re-entrant with some limitations.
07:28:53 <opqdonut> namely?
07:28:55 <taruti> GHC that is.
07:28:58 <RyanT5000> taruti: i believe i just encountered those "some"
07:29:09 <apfelmus> hm, wasn't there an FFI proposal to mark foreign imports as "safe" which allows reentrancy?
07:29:36 <RyanT5000> apfelmus: well calling them "safe" already means something - that they aren't in IO
07:30:13 <apfelmus> eh? i thought you'd simply give them a pure type signature
07:30:19 <taruti> safe imports can be in IO.
07:30:19 <apfelmus> to mark them non-IO
07:30:29 <RyanT5000> apfelmus: oh, then i misunderstood the meaning of safe
07:30:34 <RyanT5000> i'll go reread it
07:34:00 <SamB_XP_> yeah, "safe" and "unsafe" do seem a bit counterintuitive...
07:35:37 <Nafai> So what do #haskell'ers think of Pascal Constanza's statement on static vs dynamic typing? http://groups.google.ca/group/comp.lang.lisp/msg/73cbfee90307c752
07:35:38 <lambdabot> Title: shootout: implementing an interpreter for a simple procedural language Minim - c ...
07:37:27 <Spark> can you summarise it
07:37:59 <mrd> ugh, not that thread
07:38:08 <SamB_XP_> well, probably not quite true
07:38:37 <SamB_XP_> but as far as practical type systems go it probably is true ;-)
07:39:15 <Spark> he has a point, in most statically typed langauges, if a program doesn't type yet is still correct, it may not be hard to read, etc
07:39:33 <Spark> it makes it easier for the program reader if you don't put a float and then a string into the same variable
07:39:36 <Spark> for instance
07:39:48 <mrd> like printf "%d" "a"
07:39:53 * mrd sighs
07:39:55 <SamB_XP_> mrd: it doesn't seem too bad if you just read that one post
07:40:10 <RyanT5000> what does it mean for a program to "not type but still be correct"?
07:40:13 <SamB_XP_> mrd: that ain't a type error ;-P
07:40:14 <mux> I don't buy the "static typing => less flexibility" point that is implied there though
07:40:15 <Nafai> Yeah, that post is not at all like the others in the post :)
07:40:24 * mrd wonders if someone with more oleg capacity can come up with a way to type-check printf strings statically!
07:40:27 <mux> I could agree if there wasn't type inference
07:40:28 <Nafai> s/post/thread/
07:40:33 <SamB_XP_> > printf "%s" :: String
07:40:35 <lambdabot>  Exception: Printf.printf: argument list ended prematurely
07:40:35 <Spark> if (false) { int x = "fish" }  doesnm't type but is correct
07:40:44 <SamB_XP_> Nafai: that thread isn't like the others in that post?
07:40:53 <Spark> mrd: gcc does that
07:41:04 <taruti> sometimes static typing + language with not enough power in type system -> very tedious things
07:41:04 <mrd> without special extensions
07:41:27 <RyanT5000> Spark: are there any *nonpointless* programs that don't type yet are still correct?
07:41:28 <Spark> the only extension is to tell it that a given parameter is a format string
07:41:29 * Ulfalizer mumbles something about c++
07:41:33 <Nafai> SamB_XP_: Bleh,  I meant to replace the 2nd post :)
07:41:33 <Spark> RyanT5000: that is the point in question
07:41:40 <quicksilver> mrd: you'd need a reflection of the string into the type level
07:41:42 <SamB_XP_> mux: I think the flexibility involved is the flexibility to do things that will break
07:41:51 <Spark> RyanT5000: i.e., are the unnecessary restrictions imposed by static type systems actaully a problem
07:41:53 <mux> SamB_XP_: heh, I'm not opposed at losing this one :D
07:41:54 <byorgey> @go wadler "comprehending monads"
07:41:56 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
07:41:56 <Spark> and of coruse, it depends on the type system
07:41:56 <lambdabot> Title: Wadler: Monads
07:42:05 <byorgey> ivant: maybe that's what you're looking for?
07:42:17 <RyanT5000> really, though, I believe in soft typing - or at least i think that's the word they're using for it
07:42:29 <mrd> i believe in clicky typing
07:42:35 <RyanT5000> mrd: what's that?
07:42:39 <mrd> a type error
07:42:42 <ivant> byorgey, yes, I think it is. Thanks!
07:42:51 <mrd> or rather, a kind error
07:43:09 <byorgey> ivant: sure.  it's a nifty paper =)
07:43:11 <Nafai> RyanT5000: What's "soft typing"?
07:43:34 <RyanT5000> Nafai: it's typing that can be partially resolved at compile-time and partially resolved at runtime
07:43:41 <Tac-Work> data Soft = Blanket | Sponge | Pillow | Puppy | Bunny
07:43:45 <mrd> don't GHC's GADTs require this?
07:43:47 <Spark> RyanT5000: like java
07:43:48 <SamB_XP_> RyanT5000: I'm positive there are programs that you might want to right that won't typecheck
07:44:09 <RyanT5000> Nafai: basically, it means you have access to the type system at runtime
07:44:15 <Spark> you can dress up any error as a type error, if you warp the definition of "type" enough
07:44:32 <Nafai> RyanT5000: What would that allow you to do?
07:44:32 <Spark> classification is often pointless
07:44:41 <Spark> who cares if a fly trap is a plant or an animal
07:44:48 <mrd> ad-hoc sum types seem to be the main justification for dynamic types
07:44:48 <Spark> it's a fly trap, that's all you need to know
07:45:01 <SamB_XP_> Spark: I thought it was a roll of sticky paper
07:45:20 <Spark> flies land on it, and then they get eaten
07:45:23 <apfelmus> mrd: GADTs do type erasure. (and you can use them to get a type correct printf)
07:45:30 <psykotic> anyone tried this before? http://hpaste.org/2099
07:45:47 <psykotic> thought it was kind of cute. surprised i hadn't seen something like it done before, since it's sorta begging to be done.
07:45:54 <SamB_XP_> Spark: as far as I know, sticky paper isn't even alive
07:45:57 <mrd> apfelmus: do they? i was under the impression that ghc had to fudge it a bit to make it work
07:46:02 <RyanT5000> Nafai: prove things at runtime that you can't prove at compile time - e.g.: let's say you have a function with some unprovable property (which is bound to happen, thanks to Godel), but you want it to exhibit that property anyway - soft typing would basically be automatically inserting a runtime assertion for that property
07:46:25 <Spark> SamB_XP_: http://en.wikipedia.org/wiki/Venus_Flytrap
07:46:26 <lambdabot> Title: Venus Flytrap - Wikipedia, the free encyclopedia
07:46:28 <apfelmus> mrd: type inference is difficult but the translation to SystemF(C) is straightforward
07:47:08 <Nafai> RyanT5000: Probably not quite the same, but something equivalent to instanceof from Java?
07:47:09 <Cale> psykotic: it's a little bit like Graphics.Rendering.OpenGL.GL.StateVar
07:47:13 <mrd> i suppose
07:47:14 <quicksilver> psykotic: I've certainly thought about it often enough
07:47:18 <psykotic> cale: what do you think? neat? :)
07:47:31 <mrd> we're gonna have to give up type inference if we want to go any further
07:47:32 <quicksilver> psykotic: I don't know if any has done it before
07:47:32 <psykotic> i'm still not sure how useful it is, but it gives me a fuzzy warm feeling
07:47:40 <Cale> Yeah, we should definitely have something like that in the libraries somewhere reasonable :)
07:48:04 <apfelmus> yeah, yeah, also known as "functional references"
07:48:08 <quicksilver> psykotic: I thought about the 'StateRef' part when I was working on monad tunnelling/interleaving
07:48:12 <RyanT5000> Nafai: kind of, but i think that kind of check should probably be done at compile-time
07:48:14 <matthew-_> agh, how can I make runghc run a particular version of ghc?
07:48:15 <taruti> apfelmus: now if there was a stable compiler supporting SystemFC things :)
07:48:34 <RyanT5000> Nafai: however, if you're dynamically linking, then you obviously need to also do "dynamic" typechecking
07:48:38 <apfelmus> taruti: hm, GHC is unstable? :)
07:48:42 <quicksilver> psykotic: thinking about ways of embedding multiple state monads together, and ways to run different typed state actions
07:48:47 <RyanT5000> Nafai: so staged computation and soft typing kind of bleed into each other
07:48:48 <psykotic> apfelmus, obviously i was referring to the specific way of bundling them up. which seems to require multiparam type classes, and undecidable instances for the stateref instance.
07:49:10 <quicksilver> psykotic: e.g. how to run a State Int actions inside a State (Int,String) monad
07:49:29 <taruti> apfelmus: isn't FC support for 6.8?
07:49:36 <doserj> there is an old thread from 2002: http://www.haskell.org/pipermail/libraries/2002-September/000677.html
07:49:38 <lambdabot> Title: MonadRef class or the like?, http://tinyurl.com/35k9mb
07:49:51 <apfelmus> taruti: i think it's already in 6.6.
07:50:12 <taruti> apfelmus: e.g. GADTs + typeclasses is quite broken if I remember correctly
07:50:19 <apfelmus> psykotic: oh, ah, sorry.
07:50:31 <apfelmus> taruti: yes, yes but that's a type inference problem
07:50:50 <quicksilver> taruti: AFAIK the FC-based core has been there for a long time
07:51:03 <quicksilver> taruti: the questions of getting ATs working correctly is orthogonal
07:51:11 <quicksilver> (although that also is now finished, I believe_
07:52:35 <taruti> things working correctly would be nice :) (just stumbled upon the GADT things with MPTCs and fundeps yet again)
07:52:58 <quicksilver> I don't think it didn't work because the System FC was wrong
07:53:05 <quicksilver> I think it didn't work because the translation was wrong
07:53:08 <quicksilver> but I don't know much about it
07:53:15 <apfelmus> psykotic: but why does it require undecidable instances?
07:53:17 <psykotic> doserj, interesting, thanks. i'm thinking that newRef shouldn't be in the base class.
07:53:31 <psykotic> doserj, because StateRef can't support something like that.
07:54:21 <vincenz> psykotic: not quite true
07:54:25 <psykotic> apfelmus, instance MonadState s m => Ref (StateRef s) m where
07:54:28 <vincenz> psykotic: it could be supported, but it wouldn't ve bery efficient
07:54:34 <vincenz> psykotic: imagine state containing a list of dynamics
07:54:47 <psykotic> vincenz, i don't see how it could. what if the state is literally empty--contains nothing.
07:54:50 <vincenz> or a M.Map RefType Dynamic
07:54:58 <psykotic> right but this has to work over arbitrary states.
07:55:07 <psykotic> you would have to make certain demands on the state for what you're talking to work
07:55:14 <quicksilver> well it would have to be typeable
07:55:35 <quicksilver> that's not a massive requirement
07:55:47 <vincenz> psykotic: it depends what your desire is
07:56:04 <psykotic> vincenz, well, the point is that a StateRef is like a pointer into the monolithic "state" of a state monad, whatever it is.
07:56:07 <vincenz> psykotic: could look at the problem two ways, defining a way of having a mutable state in different monads
07:56:17 <vincenz> psykotic: or, as you're doing, having generic accessors for any possible state
07:56:19 <vincenz> two different goals
07:56:22 <psykotic> right
07:56:23 <vincenz> mine was more towards the first one
07:56:31 <vincenz> (which would make newRef possible)
07:56:32 <psykotic> but what i'm saying seems to be a subset
07:56:45 <psykotic> so you could have a base class for that, and then a derived NewableRef
07:56:53 <shapr> Good morning #haskell!
07:57:01 <vincenz> the NewableRef is a copletely different design
07:57:12 <vincenz> it's not for any sort of record being in state
07:57:27 <vincenz> but instead for having the functionality ala newIoRef but then in state
07:57:44 <shachaf> @greet-shapr
07:57:44 <lambdabot> shapr!!
07:57:46 <ivant> check out the picture generated by my Haskell program: http://blogs.sun.com/navi/resource/images/space.png
07:58:04 <shapr> haha
07:58:05 <Nafai> Morning shapr!
07:58:10 <shapr> Good morning Nafai!
07:58:20 <vincenz> ivant: what do you use for that?
07:58:21 <Spark> is that some kind of 2dimensional kd tree?
07:58:28 <Tac-Work> ivant: your pic is very pretty
07:58:36 <ivant> vincenz, gtk2hs
07:58:45 <vincenz> ivant: what do you draw on?
07:58:48 <vincenz> ivant: a pixbuf?
07:58:55 <ivant> Spark, what is kd tree?
07:59:13 <ivant> vincenz, sec
07:59:15 <Spark> where you divide up a space in each dimension alternately
07:59:24 <Spark> it's a spacial datastructure
07:59:34 <Spark> so you can quickly find neighbouring objects and that kind of thing
07:59:35 <shapr> Nafai: Written any Haskell code lately?
07:59:39 <vincenz> seems in this case he's always splitting into subsquares..
07:59:52 <vincenz> quadtree
07:59:56 <Spark> yes true
07:59:59 <Spark> they are aligned
08:00:09 <Nafai> shapr: Not since I was hacking some gtk2hs stuff a couple weeks ago, unfortunately
08:00:22 <Spark> a quadtree is a special case of a 2d kd-tree :)
08:00:50 <ivant> vincenz, I'm using withImageSurface
08:00:55 <vincenz> ivant: so you're using cairo?
08:00:57 <dcoutts> ivant: looks interesting, using cairo then?
08:01:03 <vincenz> ivant: Meaning, it's not pixel-base
08:01:04 <vincenz> +d
08:01:09 <ivant> vincenz, dcoutts, probably
08:01:19 <ivant> vincenz, ah, yes, not pixel-base
08:01:22 * vincenz onds
08:01:34 <apfelmus> psykotic: ah, i forgot the coverage condition. hm, maybe you can make m a phantom type of StateRef?
08:01:37 <vincenz> Been looking for something decent to work in a pixel-based style.
08:01:52 <dcoutts> ivant: so what is it? :-) what're you trying to do?
08:02:17 <vincenz> dcoutts: What is idael for pixel-based operations, a pixbuf?
08:02:23 <ivant> dcoutts, I'm trying to find the solutions of the system of multivariate polynomial inequations
08:02:29 <vincenz> dcoutts: and then doing blitting to the canvas whenever you get a onDraw?
08:02:35 <dcoutts> ivant: oh, scary :-)
08:02:48 <vincenz> (well .. onExpose)
08:03:05 <dcoutts> vincenz: I suppose so, but you want nicer abstractions over Pixbuf, it's not that easy to use
08:03:17 <vincenz> no, it's an ugly MArray :|
08:03:20 <ivant> dcoutts, the scary part is that I actually have to do it for n polynomials of m variables, and it is quite hard to imagine that kind of things :-)
08:03:25 <vincenz> with padding :(
08:03:31 <dcoutts> ivant: yeah, I bet
08:04:07 <ivant> this picture is just the test for a simple 2-variable case (so that I could produce an image)
08:04:19 <vincenz> dcoutts: And then double-buffering is the best solution?  Have a thread that draws on your background pixbuf, and then blit on the `onExpose` event of your DrawingArea?
08:04:51 <dcoutts> vincenz: aye, that'd work
08:05:08 <vincenz> (or even when there's no second thread, just so you dno't force recalculation of your drawing on each onExpose)
08:05:18 <psykotic> vincenz, one useful abstraction would be a traversal rather than cursor interface. so, you can say, call my function for each pixel in such-and-such rectangle, in left-right, top-down order. that way it can eliminate all multiplies (there's just an add when stepping between pixels), and if it can inline the function call, it should be really efficient.
08:05:47 <psykotic> actually you could do the same with a cursor, nevermind.
08:06:21 <malsyned> So functions like zipWith3 and liftM2 bother me.  map, zipWith and zipWith3 are all handled by mapcar in lispy languages, but have to be separate functions in Haskell so that their can be type checked at compile time.  On the other hand, I can't see any reason why needing zipWith and zipWith3 to be separate functions should mean the Prelude author should have to write them twice.  the existence of mapcar proves that they can each be gen
08:06:22 * psykotic is tempted to see how efficient he can get a blit
08:06:50 <EvilTerran> @where idion
08:06:50 <lambdabot> I know nothing about idion.
08:06:52 <EvilTerran> @where idiom
08:06:52 <lambdabot> I know nothing about idiom.
08:06:54 <EvilTerran> grr
08:07:11 <vincenz> psykotic: sure, that'd be interesting for the drawing interface
08:07:12 <psykotic> isn't there an instance of Applicative for zapp
08:07:21 <vincenz> psykotic: was just curious what'd be easiest for then taking your drawing and putting it on screen
08:07:28 <vincenz> s/easiest/easiest+fastest
08:07:47 <EvilTerran> malsyned, it's possible to write an n-ary replacement for zipWith* in haskell, just like liftM* has been
08:07:59 <quicksilver> malsyned: you can solve these problems with typeclasses
08:08:05 <quicksilver> malsyned: or, to osme extent, at least
08:08:11 <quicksilver> malsyned: often people don't bother...
08:08:29 <quicksilver> the problem is that there is no relationship between (,,,) and (,,,,)
08:08:35 <quicksilver> no common interface to the two of them
08:08:54 <quicksilver> sometimes people draw up a Tuple typeclass to "fix" that
08:09:17 <opqdonut> haskell tuples are really broken yeah
08:09:27 <psykotic> quicksilver, in the instance of zipping for applicative, it just uses list of lists instead of tuples.
08:09:33 <psykotic> of course that's not really satisfactory :)
08:09:44 <EvilTerran> > (,,) `fmap` [1,2] `ap` [3,4] `ap` [5,6]
08:09:45 <lambdabot>  [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
08:09:48 <shapr> @where+ idiom http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
08:09:48 <lambdabot> Done.
08:09:58 <EvilTerran> > liftM3 (,,) [1,2] [3,4] [5,6]
08:10:00 <lambdabot>  [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
08:10:02 <malsyned> Right.  and it makes sense that they be completely separate types from a run-time perspective, so that the type checker can have already verified that you're not involved in any shenanigans.  but there are plenty of compile-time reasons you might want to inspect the number of elements in a tuple type to generate code to operate on that tuple type.
08:10:04 <psykotic> oh, hm
08:10:24 <quicksilver> malsyned: yes, you can do that with a Tuple typeclass
08:10:40 <quicksilver> malsyned: but in practice most people seem not to care enoughto actually do so
08:11:04 <malsyned> quicksilver: with that approach you still have to guess when writing your library what the maximum tuple size is that client code will want to work with.
08:11:05 <vincenz> malsyned: look at template haskell
08:11:12 <EvilTerran> or with just saying zipWithN ({appropriate tuple constructor}) <$> xs <*> ys <*> zs...
08:11:17 <quicksilver> malsyned: well, no
08:11:21 <EvilTerran> (or whatever fn goes in place of zipWithN)
08:11:42 <opqdonut> EvilTerran: yup, applicative makes it so much nicer
08:11:44 <quicksilver> malsyned: obviously I presume that you use a metaprogramming technique to derive the class
08:11:51 <opqdonut> or well, Functor actually
08:11:56 <opqdonut> but applicative syntax
08:11:58 <quicksilver> malsyned: Data.Derive or perhaps TH
08:12:04 <EvilTerran> @docs Data.Applicative
08:12:05 <lambdabot> Data.Applicative not available
08:12:08 <malsyned> quicksilver: I guess that's what my question boils down to: is there a good metaprogramming facility I should look at?
08:12:13 <EvilTerran> @docs Control.Applicative
08:12:13 <lambdabot> Control.Applicative not available
08:12:23 <quicksilver> malsyned: Data.Derive; DrIFT; Template Haskell.
08:12:35 <opqdonut> EvilTerran: ITYM Control.Applicative
08:12:43 <opqdonut> oh, you tried :)
08:12:44 <opqdonut> nvm
08:13:16 <malsyned> is there any effort bringing something like one of those into the standard for H' ?
08:13:54 <EvilTerran> > (,,) <$> [1,2] <*> [3,4] <*> [5,6]
08:13:55 <lambdabot>  [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
08:14:32 <quicksilver> Not that I'm aware of, but I think template haskell is pretty stable and likely to stay around
08:14:50 <malsyned> OK.  Thanks for the pointers, I'll check them out.
08:15:00 <opqdonut> is applicative going to be in H'?
08:15:25 <EvilTerran> > (,,) <$> ZipList [1,2] <*> ZipList "ab" <*> ZipList [False..]
08:15:25 <lambdabot>  Parse error
08:15:29 <EvilTerran> > (,,) <$> ZipList [1,2] <*> ZipList "ab" <*> ZipList [False ..]
08:15:30 <lambdabot>        add an instance declaration for (Show (ZipList (a, Char, Bool)))
08:15:41 <EvilTerran> > getZipList $ (,,) <$> ZipList [1,2] <*> ZipList "ab" <*> ZipList [False ..]
08:15:42 <lambdabot>  [(1,'a',False),(2,'b',True)]
08:15:43 <doserj> Data.Applicative is just a library
08:15:58 <RyanT5000> why is there =<< but no <<?
08:16:04 <doserj> the interesting thing is whether Applicative will be a suberclass of Monad :)
08:16:11 <EvilTerran> ?type (<<)
08:16:13 <lambdabot> Not in scope: `<<'
08:16:38 <opqdonut> doserj: yeah of course it is just a library, i meant will it be in the H' prelude?
08:17:28 <doserj> If it is not a superclass of Monad, then I see no reason for it
08:17:37 <vincenz> @hoogle getZipList
08:17:37 <lambdabot> No matches found
08:17:43 <vincenz> EvilTerran: where'd you get those?
08:18:15 <EvilTerran> vincenz, what?
08:18:18 <vincenz> ZipList
08:18:25 <EvilTerran> it's in Control.Applicative
08:18:28 <vincenz> oh
08:18:36 <vincenz> you learn something new every day :
08:18:38 <vincenz> :)
08:18:51 <EvilTerran> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html#t%3AZipList
08:18:53 <lambdabot> http://tinyurl.com/yrwujr
08:19:05 <flux> hmm.. thinking.. http://tinyurl.com/yrwujr
08:19:12 <flux> darn, it doesn't create a new tinyurl :(
08:19:35 <quicksilver> flux: it only tries to shorten urls that are quite long
08:19:55 <flux> ooh, it tries to be smart
08:20:12 <opqdonut> now we just need a long tinyurl :>
08:20:15 <flux> http://tinyurl.com/yrwujr#abcdefghijklmnoqprstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ
08:20:16 <lambdabot> http://tinyurl.com/2fqbsk
08:20:20 <flux> !
08:20:22 <opqdonut> yeh
08:20:47 <opqdonut> now we just need a bot that automatically lengthens tinyurls!
08:21:06 <EvilTerran> careful, you'll get an infinite loop
08:21:20 <apfelmus> i guess lambdabot won't tiny its own urls
08:21:22 <flux> opqdonut, you mean something like hugeurl.com?
08:21:50 <flux> too bad the hugeurls don't fit into irc
08:21:57 <EvilTerran> ... that _exists_? O.o
08:22:13 * apfelmus rolf @ hugeurl
08:22:43 <vincenz> http://www.hugeurl.com/?Zjc5NWZmMjljYzU0MjM3MjVjODNiMDNmNjA4MDY2OTUmMTMmVm0wd2QyUXlVWGxWV0d4WFlUSm9WMVl3Wkc5V1ZsbDNXa2M1YWxKc1dqQlVWbHBQVjBaYWMySkVUbGhoTVVwVVZtcEdZV015U2tWVWJHaG9UV3N3ZUZacVFtRlRNazE1VTJ0V1ZXSkhhRzlVVm1oRFZWWmFkR1ZHV214U2JHdzFWa2QwYzJGc1NuUmhSemxWVmpOT00xcFZXbUZrUjA1R1pFWlNUbFpVVmtwV2JURXdZVEZrU0ZOclpHcFRSVXBZVkZWYWQxTkdVbFZTYlVacVZtdGFNRlZ0ZUZOVWJVWTJVbFJHVjFaRmIzZFdha1poVjBaT2NtSkdTbWxTTW1oWlYxZDRiMkl3TUhoWGJHUllZbFZhY
08:22:50 <vincenz> www.google.com
08:22:57 <EvilTerran> |\(O.o)/|
08:22:59 <flux> a friend once suggested the author that it should put the web page contents into the url (so the server wouldn't need to store anything), but apparently the url would be so long that it doesn't work with web browserse anymore..
08:23:28 <flux> vincenz, nope, doesn't work, irc truncates messages at 512 characters
08:23:36 <flux> (protocol messages)
08:23:38 <vincenz> flux: fortunately
08:23:43 <vincenz> flux: it spammed half of my screen
08:23:45 <flux> and the urls are three times that..
08:23:50 <vincenz> and I'm at 80x53
08:24:13 <Tac-Work> windows couldn't find that site
08:24:27 <Tac-Work> isn't there a limit to the size of those things?
08:24:32 <ivant> is there a way to tell ghci in a command line which modules you want to get loaded (i.e., something like "ghci +m Control.Monad")?
08:25:12 <shachaf> Is there something like idurl? http://idurl.com/http%3A%2F%2Fgoogle.com%2F, for example.
08:25:30 <EvilTerran> > 80 * 53
08:25:39 <vincenz> 4240
08:25:40 <lambdabot>  4240
08:25:48 <shachaf> ivant: I don't think so.
08:25:55 <shachaf> ivant: To use interactively or with -e?
08:26:02 * vincenz is faster than lambdabot 
08:26:03 <ivant> vincenz, > 412 *769
08:26:06 <vincenz> hah
08:26:12 <vincenz> 80 * 53 is easy
08:26:19 <EvilTerran> ivant, you could put it in ./.ghc, i think
08:26:20 <vincenz> 80 * 50 + 80 * 3
08:26:25 <ivant> shachaf, interactively
08:26:32 <vincenz> (lots of easy to add 0s)
08:26:38 <EvilTerran> .ghci, rather
08:26:42 <ivant> EvilTerran, I know, but I don't want these modules to be loaded always
08:26:42 <shachaf> ivant: You could use a .ghci.
08:27:24 <ivant> that is only for a single project, I'm setting up a small script which would call ghci with the environment pre-set up
08:28:12 <ivant> actually, I have a Rakefile from which I want to start ghci with certain modules loaded
08:28:32 <doserj> module MyEnv where import ... ?
08:28:45 <shachaf> ivant: And the project isn't in its own directory?
08:29:14 <shachaf> ivant: Yes, doserj's solution could work.
08:29:16 <ivant> shachaf, what do you mean by that?
08:29:30 <RyanT5000> Cale: re: your queuing reentrant lock, is it necessary to unGetTChan before retrying?
08:29:36 <ivant> well, it's a hack :-) I don't really want an extra file hanging aroudn
08:29:50 <shachaf> ivant: Oh, never mind, then.
08:33:18 <ivant> EvilTerran, shachaf, sorry, I feel really dumb: I thought you meant ~/.ghci, not ./.ghci
08:33:54 <shapr> Hey, is there some reliable way to do voice chat on debian/unstable/amd64 ? ekiga doesn't work so well, skype is 32-bit...
08:34:35 <dylan> skype can be run from a chroot easily enough
08:34:56 <ivant> shapr, SIP clients?
08:35:22 <ivant> like https://sip-communicator.dev.java.net/
08:35:39 <shapr> ivant: ekiga is supposedly a SIP client, but I've never gotten it to work.
08:36:03 <shapr> privet ivant!
08:36:22 <SamB> eek. I just ran into a wierd GHC error :-(
08:36:23 <shapr> How did you get interested in Haskell?
08:36:43 <SamB> I wonder if it was GHC or not that actually caused it
08:36:44 <ivant> shapr, I used some java SIP client and it worked fairly well
08:37:05 <ivant> shapr, tough question :-)
08:37:16 <shapr> Well, I try to keep java off of my system as much as possible. I know you work at sun, so don't take that as an insult :-)
08:38:35 <shapr> ivant: Did you get interested from the math side?
08:38:38 <ivant> shapr, I don't :-)
08:39:53 <ivant> shapr, no, I think I read a part Gentle introduction to Haskell something like 4 years ago, when I was programming in C++ and I was so inspired that I started to implement my own maybes and eithers, etc. in C++ :-)
08:40:08 <shapr> hah
08:40:23 <EvilTerran> @ghc , SamB?
08:40:23 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
08:40:46 <ivant> shapr, and now I'm struggling on writing my PhD, and I use Haskell to write a program for it
08:41:04 <Tac-Work> what's your thesis on?
08:41:08 <shapr> Beat me to it...
08:43:16 <ivant> Tac-Work, on special kind of vibrational stabilization problems, for which I try to write a program which simplifies the analysis (and develop at least some methods other than sitting and trying to eliminate 90% out of 100+ polynomial inequalities by hand)
08:44:31 <shapr> I'd guess that nifty picture is one result?
08:44:47 <ivant> however it's pretty boring, I've been chasing the wrong target for almost two years now, trying to use the method which is exponential in complexity
08:44:58 <Tac-Work> what is a vibrational stabilization problem exactly?
08:45:59 <ivant> shapr, well, it is one of the proof-of-concept results, but I'm still not sure if I'd be able to solve the problem this way either
08:47:42 <ivant> Tac-Work, having a (special kind of a) system of differential equations, zero solution of which is unstable, one has to find the control functions which are periodical and have zero mean value, and which stabilize the system
08:48:30 <Tac-Work> What's your phd going to be in? It sounds like an engineering thing
08:48:43 <ivant> Tac-Work, imagine an inverted pendulum, where you can move the pivot point up and down trying to stabilize the pendulum in the upward position
08:48:51 <apfelmus> ivanm: so, like balancing a pencil on the back of your hand?
08:49:01 <RyanT5000> ivant: only up and down?
08:49:06 <Tac-Work> ah, hehe, I was doing that in my rocking chair the other day
08:49:09 <ivant> Tac-Work, mathematics
08:49:15 <Tac-Work> coolness
08:49:17 <ivant> RyanT5000, yep
08:49:22 <RyanT5000> ivant: sounds hard :)
08:49:29 <Tac-Work> all good math is
08:49:37 <shapr> ivant: Oh, that sounds like a cool unicycling paper I downloaded.
08:49:50 <ivant> RyanT5000, and you can only move the pivot point periodically around its "default" position"
08:49:51 <psykotic> unicycling...
08:49:53 <shapr> Inverse pendulum problem and all that.
08:50:07 <shapr> psykotic: You called? ;-)
08:50:22 <RyanT5000> ivant: huh; that's a lot of constraints; can you get stable systems out of it?
08:50:23 <ivant> shapr, it's a common problem in theory of control/theory of stability.
08:50:23 <psykotic> rather control problems relate to unicycling, isn't the no-slip condition for unicycles a non-holonomic constraint? since the local DOFs are less than the global DOFs?
08:50:40 <psykotic> i suddenly remember all that stuff... observability, etc.
08:50:45 * shapr tries to figure out what psykotic just said...
08:51:07 <quicksilver> all problems relate to unicycling
08:51:15 <quicksilver> many problems are best solved whilst unicycling
08:51:16 <ivant> RyanT5000, yep, it is possible. And I'm working on a little bit more abstract kind of problems, of which the pendulum problem is a single instance
08:51:28 * shapr laughs
08:51:33 <ivant> shapr, do you have a link to that paper?
08:51:44 <Tac-Work> quicksilver: like the problem of how to fall off your unicycle
08:52:09 <ivant> how many unicyclers does it take to...
08:52:11 <shapr> ivant: I think it's http://maths.dur.ac.uk/~dma0rcj/PED/uni.pdf
08:52:42 <RyanT5000> ivant: huh
08:53:57 <psykotic> shapr, it relates to a kind of fun thing in lie algebras actually. it's easier to visualize with a car. a car on a planar surface has only two dimensional controls: one is the gas, the other is the steering wheel. so the "local degrees of freedoms" are 2 in dimension. whereas the global are in fact three: position (2 dimensions), and orientation (1). so the "no-slip" constraint of a car is non-holomic, because of this discrepancy.
08:54:17 <psykotic> holonomic
08:54:20 <ivant> actually I'm sooo bored with the never-ending failures in trying to solve the problems I'm doing that I wish I started doing some research in somethings else
08:54:51 <psykotic> if a car could drive directly sideways it would have three local DOFs, one for the normal gas (forward), one for the sideways gas, and one for the steering wheel, and the local DOFs would equal the global DOFs
08:54:52 <Tac-Work> I imagine that to be the hardest part of research
08:55:29 <psykotic> and there's this thing called the lie bracket for a lie group of transformations that corresponds to "infinitesimal parallel parking" that's related to this :)
08:55:32 <Tac-Work> The hardest problems are harder than the smartest people are smart.
08:55:56 <psykotic> basically because you can move infinitesimally sideways by executing an infinitesimal parallel parking maneuver
08:56:15 <Tac-Work> You never know how successful you will be with any unsolved problem. (and that's because solving unsolved problems takes exponential time)
08:57:19 <ivant> Tac-Work, the strange thing is that I imagine how I would defend the dissertation and it sounds like a pretty useless thing to do for a PhD. And it seems to me that I don't do any real research here, just looking for applicable algorithms around (although they are hard to find)
08:58:10 <Tac-Work> Just looking is searching and researching is just "re"=again + "search"=just looking
08:59:01 <Tac-Work> What would you consider a "useful" thing to do for a PhD?
08:59:34 <shapr> ivant: Making new useful connections between existing theory and existing problems is very much useful.
08:59:59 <psykotic> Tac-Work, a unified theory of unicycling
09:00:03 <shapr> psykotic: From reading http://en.wikipedia.org/wiki/Holonomic I think it's not holonomic.
09:00:04 <lambdabot> Title: Holonomic - Wikipedia, the free encyclopedia
09:00:18 <psykotic> shapr, right.
09:00:47 <Tac-Work> ivant: do you have your Masters in mathematics then?
09:00:49 <shapr> Unicycling does depend on the momentum.
09:01:38 <ivant> Tac-Work, useful is something that can be used later. I'm afraid that my work would be ditched (by the university, and, well, me) as soon as I finish it
09:01:54 <Tac-Work> I see
09:03:38 <ivant> Tac-Work, it's a tricky question: we have a little bit different education system in Russia, we have BS, MS and "Specialist" degrees. I know that it "Specialist" degree was considered to be equal to MS some years ago
09:03:57 <Tac-Work> ah
09:04:23 <ivant> Tac-Work, but apparently it is not so, at least when you apply for residency visas to some countries
09:05:22 <Tac-Work> I see
09:05:38 <Tac-Work> I know not of such things =-)
09:07:41 <ivant> shapr, cool paper!
09:08:33 <shapr> :-)
09:20:39 <njbartlett> psykotic: It's not exactly sideways motion, even if infinitessimal. You couldn't parallel park in a space that as exactly the same length as the car, because of the required forwards and backwards motions
09:20:54 <CosmicRay> how can I use a notification area with gtk2hs?
09:20:59 <CosmicRay> that is, put an icon down there?
09:22:10 <dcoutts> CosmicRay: that's just been added in the darcs version ofr gtk2hs
09:22:21 <dcoutts> CosmicRay: and there's a demo on how to use it
09:22:25 <psykotic> njbartlett, right, basically it means that there's a position arbitrarily close to the left or right that can be reached by correspondingly arbitrarily small turns and forwards/backwards motion
09:23:01 <dcoutts> CosmicRay: see http://darcs.haskell.org/gtk2hs/demo/statusicon/StatusIcon.hs
09:23:22 <njbartlett> Of course, in the real world it would still be possible. After all, bumpers are made for bumping :-)
09:24:27 <psykotic> so, if you have a lie group with two generators a and b, a generates turns and b generates (relative) forward motion, then the lie bracket [a,b] = a b a^(-1) b^(-1) is a parallel parking transformation
09:25:22 <psykotic> which vanishes (equals the identity) if a and b commute. but of course turning and moving forward (relative to your direction) definitely don't commute, which is why parallel parking works :)
09:25:25 <CosmicRay> dcoutts: ahh, sweet
09:26:27 <ivant> @remember psykotic so, if you have a lie group with two generators a and b, a generates turns and b generates (relative) forward motion, then the lie bracket [a,b] = a b a^(-1) b^(-1) is a parallel parking transformation
09:26:27 <lambdabot> Done.
09:27:53 <CosmicRay> I've decided I have to write my own openvpn frontend.
09:27:59 <CosmicRay> because all the others out there suck.
09:28:16 <ivant> CosmicRay, write an email client then :-)
09:28:22 <ivant> they do suck more
09:28:29 * arcatan agrees with ivant
09:28:31 <CosmicRay> ivant: http://software.complete.org/offlineimap ;-)
09:28:33 <lambdabot> Title: OfflineIMAP
09:28:36 <CosmicRay> ivant: I've done half of it ;-)
09:28:47 <ivant> Oh, John, that's you :-)
09:29:01 <CosmicRay> uh-oh, I've been outed
09:29:11 <arcatan> hey, offlineimap was hany
09:29:13 <arcatan> *handy
09:29:23 <CosmicRay> I am hoping to rewrite it in Haskell soonish
09:29:31 <CosmicRay> of course I will have to write Maildir and IMAP modules for haskell first
09:29:46 <CosmicRay> but the suckage of python's imaplib.py cannot be overstated
09:30:06 <CosmicRay> that is the biggest heap of festering garbage that I've had to work with in a long time
09:30:43 <ivant> CosmicRay, I used Ruby's imap library something like year ago, and it seemed to be usable
09:30:45 <arcatan> it's annoying that the imap server of the shell provider I use doesn't support maildirs
09:31:37 <psykotic> CosmicRay, imaplib.py is truly terrible. it doesn't really _do_ much at all.
09:31:53 <psykotic> CosmicRay, it's basically just a glorified tcp/ip connection wrapper.
09:32:11 <psykotic> i'm not sure how it ended up in the standard library.
09:32:35 <CosmicRay> psykotic: believe me I am quite well aware of that ;-)
09:32:37 <monochrom> The best library writers have defected to Haskell :)
09:32:48 <CosmicRay> dcoutts: have you ever seen this?  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=435536
09:32:51 <lambdabot> Title: #435536 - gtkrsync - FTBFS: undefined reference to `gtkzm0zi9zi11_GraphicsziUIzi ...
09:32:59 <CosmicRay> > dist/build/gtkrsync/gtkrsync-tmp/RsyncGUI.o: In function `s9XK_ret':
09:32:59 <CosmicRay> > ghc5132_0.hc:(.text+0x480): undefined reference to `gtkzm0zi9zi11_GraphicsziUIziGtkziMultilineziTextBuffer_zdwtextBufferMoveMark_entry'
09:32:59 <lambdabot>  Parse error
09:32:59 <lambdabot>  Parse error
09:33:13 <CosmicRay> it's happenning when I try to build programs that use gtk2hs on some of debian's architectures
09:33:17 <CosmicRay> it works ok on i386 and amd64
09:33:23 <psykotic> does ghc do anything fancy for code written inside the IO monad, to peal thunks away aggressively?
09:33:57 <quicksilver> psykotic: the IO monad is generally not treated as a special case; what kind of thing are you thinking of?
09:34:13 <monochrom> Perhaps it's aggressive to all.
09:34:25 <psykotic> quicksilver, well, essentially C-like code dealing with bitmaps, for example.
09:34:48 <quicksilver> I'm not really sure what you think pealing thunks is :)
09:34:57 <quicksilver> maybe you mean strictness analysis
09:34:59 <psykotic> it seems like aggressive inlining + strictness analysis should in theory do everything i expect
09:35:01 <psykotic> yes
09:35:20 <quicksilver> the GHC strictness analyzer certainly doesn't catch everything
09:35:30 <quicksilver> it does a good job on various cases though
09:37:12 <psykotic> i'll just have to see then
09:37:17 <ivant> How do I get info on the MonadFix implementation for [a] (other than looking in the sources)? is there some easy-to-grasp idea of what it does?
09:37:49 <psykotic> :t mfix
09:37:51 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
09:38:59 <Tac-Work> In haskell, all values are stored by a reference, right?
09:39:06 <psykotic> mfix f = do mfix f >>= f?
09:39:09 <vincenz> Tac-Work: not perse
09:39:14 <vincenz> Tac-Work: unboxed values are not
09:39:17 <psykotic> err, without the do
09:39:25 <quicksilver> Tac-Work: 'complex' values tend to be
09:39:37 <quicksilver> Tac-Work: but the compilers can unbox various simple things like Ints for efficiency
09:39:43 <Tac-Work> if I do
09:39:43 <Tac-Work> data Environment | Environment { config :: Map String String; otherStuff :: OtherStuff }
09:39:46 <monochrom> No, mfix is not a loop (in the control or execution sense).
09:40:08 * SamB wonders what kind of code triggers http://hackage.haskell.org/trac/ghc/ticket/1013 exactly
09:40:10 <lambdabot> Title: #1013 (interpretBCO: unknown or unimplemented opcode 64356) - GHC - Trac
09:40:14 <Tac-Work> even if I mutate the environment with the syntax env {otherStuff = foo}, config doesn't take up more space does it?
09:40:22 <quicksilver> Tac-Work: it doesn't, no
09:40:24 * SamB suspects that GHCi is allergic to Project Euler
09:40:26 <quicksilver> Tac-Work: it idsn't copied
09:40:26 <Tac-Work> ok
09:40:30 <Tac-Work> that was my question
09:40:32 <Tac-Work> thanks
09:41:24 <Tac-Work> I'm still trying to figure out a way where I can realize the idea of read-on-program-start configuration data
09:41:48 <Tac-Work> I'm thinking I can make a type class Configurable which gives you access to a Map String String
09:41:55 <chessguy> Tac-Work, sounds like a job for Reader
09:42:12 <Tac-Work> I'm confused what the benefits of Reader are
09:42:36 <Tac-Work> please help me understand why they are useful, because to me, it looks like a complicated way to pass an extra param through everything
09:42:49 <Tac-Work> hmm
09:42:49 <chessguy> it makes it explit exactly what code needs to read that data, and that it can ONLY read that data
09:43:10 <Tac-Work> unless, maybe I should be making Configurable data types the readers themselves?
09:43:13 <quicksilver> ivant: you maye find it interesting to read "http://hackage.haskell.org/trac/ghc/ticket/1449"
09:43:14 <lambdabot> Title: #1449 (Bug in instance MonadFix []) - GHC - Trac
09:43:46 <chessguy> Tac-Work, well, what i was thinking of was having things of type Reader ConfigurationRecord
09:44:11 <ivant> oh-oh
09:44:23 <quicksilver> Tac-Work: it is a way to pass an extra param through everything, yes
09:44:35 <quicksilver> Tac-Work: and it gives you some syntactic sugar to pass the same param to several things
09:44:43 <quicksilver> Tac-Work: without having to mention the param by name
09:44:54 <quicksilver> Tac-Work: and it lets you be explicit in your types about your intentions
09:44:55 <Tac-Work> I think I was using it the very wrong way then
09:44:55 <shapr> @where cabal
09:44:56 <lambdabot> http://www.haskell.org/cabal
09:44:59 <shapr> @where cabal-setup
09:45:00 <lambdabot> I know nothing about cabal-setup.
09:45:15 <SamB> Tac-Work: it's a way to pass extra params without having to thread them all explicitly
09:45:17 <Tac-Work> because the way I was doing it, not only did you have to specify the reader in the return type, but you had to extract everything from the reader too
09:45:25 <psykotic> > mfix (\xs -> [take 3 (1:xs), take 4 (2:xs)])
09:45:33 <lambdabot>  [[1,1,1],[2,2,2,2]]
09:45:43 <Tac-Work> I think I need a good, healthy example of the best way to use Reader for what I'm trying to do
09:46:01 <SamB> Tac-Work: don't bother unless you'd otherwise be passing things around a lot without changing them
09:46:10 <chessguy> dang. i used to have a paper about the exact problem Tac-Work is dealing with, but i deleted the link just the other day
09:46:24 <Tac-Work> so let's say I'm trying to make a Tank object for a game
09:46:37 <Tac-Work> the tanks will be just squares
09:46:43 <Tac-Work> and the size of each tank is configurable
09:46:45 <shapr> How do I bootstrap to the latest cabal? It has configurations...
09:46:56 <Tac-Work> and each has a method to return it's bounding box
09:47:26 <Tac-Work> data BoundBox = BoundBox Position Size -- position = a 2d vector, size = float
09:47:39 <chessguy> oh, that's a very different kind of problem. you don't want a global configuration record for something like that
09:47:58 <Tac-Work> different how?
09:48:06 <shachaf> @wiki Roll your own IRC bot
09:48:07 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
09:48:08 <shapr> SyntaxNinja: How do I bootstrap to the latest cabal that supports conditional build-deps? Can I pull to a tag that supports conditional stuff but does not have those in the cabal file?
09:48:14 <chessguy> you want data for each instance of an object
09:48:22 <Tac-Work> oh no
09:48:27 <Tac-Work> I want all tanks to be the same size
09:48:35 <shachaf> Tac-Work: That uses Reader (ReaderT, actually); maybe it'll help?
09:48:35 <shapr> Hiya SyntaxNinja!
09:48:40 <Tac-Work> but I want that size to be determined by a tank.config file read on the start of the program
09:48:48 <chessguy> oh, hm
09:49:01 <shapr> @seen dcoutts
09:49:01 <lambdabot> dcoutts is in #ghc, #gentoo-haskell and #haskell. I last heard dcoutts speak 26m ago.
09:49:14 <SyntaxNinja> hi shapr
09:49:19 * shapr boings
09:49:27 <Tac-Work> shachaf: yes, everyone says that, but I need to figure out how to use Reader in conjunction with what I'm doing
09:49:46 <desp> it seems that I've found a platform-specific bug in darcs
09:49:53 <chessguy> so, what exxactly are you doing?
09:50:00 <shachaf> Tac-Work: What are you doing? Your tank example?
09:50:02 <desp> any darcs developers here?
09:50:18 <Tac-Work> I want every tank in the game to have the same sized bounding box
09:50:28 <Tac-Work> and that size comes from an outside file
09:50:47 <chessguy> desp, try #darcs?
09:50:53 <Tac-Work> So I either need to thread the config file data to every function
09:51:00 <Tac-Work> or I need to learn the proper way to use reader
09:51:02 <desp> trying
09:51:03 <Tac-Work> one of the two ^^
09:51:52 <chessguy> aha, found the paper
09:51:58 <chessguy> Tac-Work,  http://www.cs.rutgers.edu/~ccshan/prepose/p1214-kiselyov.pdf
09:52:12 <shapr> dcoutts: Any idea how I can bootstrap to the version of cabal that supports conditional configuration?
09:52:28 <Tac-Work> coolness
09:52:39 <Tac-Work> I will read it over lunch... to which I am about to run off to
09:52:57 <chessguy> enjoy. i've got to get back to work myself
09:52:57 <shapr> For whatever reason, cabal-1.1.7 and ghc 6.6.1 in debian/unstable seems to force -fvia-C
09:53:21 <vincenz> haha
09:53:23 <vincenz> from that paper "      From the perspective of an ordinary Haskell value, Haskell’s
09:53:25 <Tac-Work> oh cool, this looks like exactly what I'm trying to do
09:53:26 <vincenz> type system and type-class instances are foreign indeed!4
09:53:29 <vincenz> "
09:53:40 <chessguy> Tac-Work, that's what i said :)
09:53:59 <ivant> @hoogle (a->b->c->d)->(a,b,c)->d
09:54:00 <lambdabot> No matches, try a more general search
09:54:05 <Tac-Work> chessguy++
09:54:13 <Tac-Work> all right
09:54:19 <Tac-Work> time for food!
09:54:28 <vincenz> chessguy: that's a funky paper
09:54:58 <vincenz> ivant: curry3?
09:55:01 <vincenz> @type curry3
09:55:03 <lambdabot> Not in scope: `curry3'
09:55:06 <vincenz> hmm
09:55:23 <ivant> @ty uncurry3
09:55:25 <lambdabot> Not in scope: `uncurry3'
09:55:34 <shachaf> @djinn (a -> b -> c -> d) -> (a,b,c) -> d
09:55:34 <lambdabot> f a (b, c, d) = a b c d
09:56:00 <vincenz> shachaf: well it's not that complicated :)
09:56:07 <vincenz> shachaf: just nice if it was in prelude
09:56:25 <shachaf> vincenz: I know, I just wondered if @djinn could work with (,,).
09:56:36 <vincenz> oh
09:56:40 <shachaf> vincenz: Nothing that @djinn can do is complicated, really.
09:56:49 <shachaf> vincenz: (That I've seen it do, anyway.)
09:56:55 <vincenz> nice catch :)
10:00:19 <shachaf> Was the @karma reset again?
10:00:21 <shachaf> @karma-all
10:00:21 <lambdabot>  "agentz"               24
10:00:21 <lambdabot>  "moritz"               17
10:00:21 <lambdabot>  "der_eq"                2
10:00:21 <lambdabot>  "moritz_"               2
10:00:21 <lambdabot>  "'"                     1
10:00:23 <lambdabot> [17 @more lines]
10:02:50 <shapr> @seen igloo
10:02:50 <lambdabot> I saw igloo leaving #gentoo-haskell, #darcs, #ghc and #haskell 53m 30s ago, and .
10:03:55 <DaveCGI925> how do you iterate over N>1 large lists without creating a new list?
10:04:09 <SamB> does anyone have a recent GHC 6.7 stage2?
10:04:13 <DaveCGI925> oh, and i forgot to add the word "elegantly"
10:04:18 <vincenz> DaveCGI925: why do you worry about creating new lists?
10:04:27 <vincenz> DaveCGI925: the elegant way is to create a new list
10:04:32 <vincenz> DaveCGI925: and then have the compiler do loop fusion
10:04:39 <vincenz> which it does, so you don't actually create the intermediary list...
10:04:55 <DaveCGI925> elegantly syntactically
10:04:56 <roconnor> ugh, even when I write proofs they are slow!
10:05:00 <DaveCGI925> i was wondering if there's a function already which will join the lists
10:05:27 <glguy> concat?
10:05:29 <vincenz> DaveCGI925: zip?
10:05:52 <desp> grarg
10:05:57 <glguy> ?yow
10:05:57 <lambdabot> HAIR TONICS, please!!
10:06:00 <desp> #darcs appears to be dead
10:06:06 <desp> any darcs hackers here?
10:06:07 <DaveCGI925> vincenz sounds good
10:08:54 <shachaf> DaveCGI925: Also look at zipWith.
10:09:22 <shachaf> DaveCGI925: Which is like map for more than one list.
10:09:27 <glguy> also: transpose
10:09:38 * shapr boings cheerfully
10:09:39 <glguy> if you have a variable number of lists
10:09:41 <shapr> w00, code!
10:09:58 <glguy> happy code to you too
10:11:25 <SamB> does anyone have a recent GHC build and want to try testing something for me?
10:11:43 <SamB> one with GHCi support, I might add
10:12:15 <sjanssen> SamB: how recent? I have GHCi, version 6.7.20070719
10:12:40 <SamB> when was 6.6.1 released?
10:13:27 * int-e has a ghc 6.7.20070805
10:13:47 <SamB> anyway, http://hackage.haskell.org/trac/ghc/ticket/1552
10:13:49 <lambdabot> Title: #1552 (GHCi thinks large list literals impossible?) - GHC - Trac
10:13:50 <shapr> @quote
10:13:50 <lambdabot> matthew-_ says: wow, haskelldb is amazing. the type system tells me when I've forgotten to select certain columns!
10:15:34 * SamB wonders if int-e is trying it
10:16:09 <int-e> SamB: I'm trying. 80 seconds CPU time so far
10:16:41 <sjanssen> SamB: linkBCO: >= 64k insns in BCO
10:17:27 <SamB> sjanssen: that's what I get on 6.6.1 on Lemmih's webserver, too...
10:18:27 <SamB> int-e: if you're worried that it might succeed and print that many 'x's, you could ^C and add "length" in front of the splice
10:18:39 <DaveCGI925> is ++ in Haskell O(1) ?
10:18:48 <SamB> DaveCGI925: no
10:18:49 <int-e> SamB: ah, that took almost 4 minutes but I get the same error.
10:19:22 <int-e> (it's a somewhat dated Athlon XP 2500+)
10:19:27 <ari> DaveCGI925: It's O(n) in its first argument, O(1) in the second
10:19:41 <sjanssen> DaveCGI925: it is O(min(m, n)), where m is the length of the first list, and n is the number of elements eventually consumed
10:19:47 <DaveCGI925> ang
10:20:04 <ari> ... laziness :(
10:20:13 <SamB> int-e: I have no idea what the length of time it takes to fail indicates
10:20:14 <DaveCGI925> sjanssen: thats getting closer because of the laziness
10:20:27 <sjanssen> DaveCGI925: you might try Data.Sequence if you need fast appends
10:20:30 <SamB> though of course I imagine it is partly based on CPU speed ;-)
10:20:34 <DaveCGI925> sjanssen: can you be more clear, n is the # of elements consumed from the new combined list right?
10:20:44 <sjanssen> DaveCGI925: correct
10:20:52 <ndm> @seen Igloo
10:20:52 <lambdabot> I saw Igloo leaving #gentoo-haskell, #darcs, #ghc and #haskell 1h 11m 32s ago, and .
10:21:01 <sjanssen> so "take 1 (xs ++ ys)" is O(1), no matter how long xs and ys are
10:21:15 <DaveCGI925> i see
10:21:37 <int-e> SamB: not much, it just took a bit longer than I expected :) - it fails with 6000, too.
10:21:58 <SamB> int-e: hmm. I didn't try it with smaller numbers ;-)
10:22:24 <SamB> next, I think I'll complain about TH's horrible pretty-printing
10:22:39 <SamB> which is why the string was so long anyway, I'm pretty sure
10:23:40 <SamB> int-e: so could you add a comment about your results to that bug?
10:24:30 <int-e> SamB: I could but I feel that they aren't significant.
10:25:05 <SamB> int-e: you don't think it's significant that it didn't work with yesterday's compiler?
10:25:28 <int-e> yesterday's compiler is a moving target.
10:25:41 <SamB> true
10:26:09 <vincenz> int-e: only if your definition of today moves :)
10:27:13 <DaveCGI924> so couldnt (++) be technically O(1) since you are paiyng O(1) when consuming anyways and thus O(min(m,n)) would be dwarfed by O(n) for consuming n items?
10:27:32 <int-e> (++) *is* O(1) in that sense
10:27:37 <int-e> due to lazy evaluation
10:27:48 <sjanssen> DaveCGI924: no, that isn't quite right
10:28:25 <int-e> but every use of (++) adds to the 'constant' time for consuming the first element.
10:29:19 <int-e> so that analysis breaks down for nonconstant numbers of (++) applications.
10:29:53 <DaveCGI924> int-e: until they are actually appended at which point the 'constant' time is removed back to normal?
10:30:15 <int-e> > foldl (++) [] (replicate 5000 "a")
10:30:17 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
10:30:17 <int-e> DaveCGI924: yes
10:30:20 <monochrom> head (x++y) is O(1). But clearly putStrLn (x++y) is not O(1).
10:30:23 <DaveCGI924> int-e: man thats a pain in the ass, its not even polynomial that way :-|
10:30:43 * SamB doesn't remember what int-e's name is
10:32:12 <DaveCGI924> int-e: if you      (++) x ((++) y z) would that make the constant time go up twice or just once ?
10:32:19 <samreid> "not even polynomial"?
10:32:48 <int-e> DaveCGI924: once, because the second (++) starts running after the first one finishes
10:33:01 <monochrom> head ( (((...(x1 ++ x2) ++ ... ++ xn) )  (i.e. associate to the left)  is clearly O(n).  You need n steps to go through n ++'s before you see x1.
10:33:29 <int-e> DaveCGI924: it's really easier to think of (++) as O(n) where n is the length of its first argument. That is only accurate if you consume the whole list of course.
10:33:45 <monochrom> This is why concat is x1 ++ (x2 ++ ( ... ++ xn)..)  i.e. associate to the right.
10:37:43 <DaveCGI924> int-e: looks like O(1) for right associativity to me
10:38:24 <int-e> DaveCGI924: per element, yes. the O(n) was total time.
10:39:13 <DaveCGI924> int-e: but its O(n) to consume N items anyways, :P
10:39:51 <DaveCGI924> monochrom: thats kind of how monads are done right? through left associativity?
10:40:14 <sjanssen> DaveCGI924: the important thing is that (++) has to do O(n) *additional* work
10:40:30 <monochrom> That is confused.
10:41:38 <DaveCGI924> sjanssen: i got it heh, i just live in a world of amortization and dont really care when that work isnt done upfront :P
10:41:58 <quicksilver> DaveCGI924: of course, if you only do O(n) additional work once, it's still O(n) overall since O(n) + O(n) = O(n)
10:42:10 <quicksilver> but if you do O(n) additional work n times, then it isn't anymore...
10:42:27 <DaveCGI924> but its not done once, its just a bigger constant time per every element consumed
10:42:36 <DaveCGI924> since its all lazily evaluated (woohoo)
10:42:47 <apfelmus> int-e: hi :)
10:42:48 <quicksilver> until you have a tower of ++s n high, yes
10:42:58 <int-e> it *is* done once - (++) isn't free.
10:43:27 <SamB> arg.
10:43:37 <SamB> I hate it when I get the wiki markup wrong in a trac comment
10:43:37 <int-e> in any case, if you want to concat a lot, use Data.Sequence.
10:43:46 <int-e> hi apfelmus
10:43:47 <Ulfalizer> heh, i get all the sound in the left channel when i watch the first video in the topic
10:43:48 <monochrom> There is no "preview"?
10:43:51 <apfelmus> int-e: there's a probability paradox I'm looking for, but I can't find a solution
10:43:53 <SamB> and notice just after posting it
10:44:00 <sjanssen> SamB: they're all gonna laugh at you!
10:44:18 <glguy> sjanssen: Adam Sandler?
10:44:25 <DaveCGI924> int-e: nah thats ok, curiosity
10:44:48 * EvilTerran notes the earlier convo about (++)
10:44:56 <apfelmus> int-e: it's the toss-a-coin bet that has an infinite average
10:44:57 <sjanssen> glguy: yeah
10:45:00 <Ulfalizer> oh, someone fixed it around 1:48 :)
10:45:07 <SamB> sjanssen: even if they don't, it still looks ugly
10:45:14 <DaveCGI924> its actually kind of nice you dont have to worry about writing "generators" like in eager languages
10:45:17 <EvilTerran> did someone mention the trick with composition?
10:45:25 <int-e> apfelmus: oh. the one where the win is doubled on every round?
10:45:41 <apfelmus> int-e: yes, that one :)
10:45:44 <SamB> I should just lay off on the {{{}}}, I guess
10:45:45 <monochrom> EvilTerran: No, since that would be too much information.
10:45:49 <DaveCGI924> oh yeah, does haskell ever do any kind of implicit parallelization for reducing expressions?
10:46:10 <SamB> DaveCGI924: no
10:46:16 <SamB> er. well. not now.
10:46:35 <sjanssen> DaveCGI924: there aren't any compilers that do it automatically.  GHC does have a "par" combinator that activates parallel evaluation
10:46:35 <SamB> there was a fad a while back, and apparantly SPJ is still interested in that idea
10:46:46 <EvilTerran> (return (list ++) instead of (list), use (.) instead of (++), and give this thing a [] when you want an actual list value, etc)
10:47:26 <EvilTerran> SamB, isn't SPJ's thing more explicit than that? or is he looking at that as well as data parallelism?
10:47:27 <sjanssen> DaveCGI924: it's tough for a compiler to recognize when a computation is expensive enough to warrant spinning off another evaluator
10:47:51 <int-e> apfelmus: it's called the St. Petersburg Paradox (thanks google). There are two ways out of it that I know of. a) practicability. After a few dozen rounds, nobody could pay the money. b) utility. you don't want to get as much money as possible; there isn't much difference between having 10 million dollars and 20 million dollars.
10:48:02 <DaveCGI924> i could be wrong but isnt one of the benefits of call-by-need that you could reduce everything in parallel?
10:48:18 <SamB> EvilTerran: when asked about it during his NDP presentation to the London HUG, he said that he'd still like to try that
10:48:20 <DaveCGI924> sjanssen: ah that makes sense. much harder to implement then theorize eh? :)
10:48:22 <sjanssen> DaveCGI924: yes, you can do that.  The devil is in the details :)
10:48:30 <EvilTerran> oh, i see. yeah.
10:48:36 <EvilTerran> *remember
10:48:55 <SamB> I didn't get the impression that he was planning to try it any time soon though
10:49:01 <sjanssen> automatic parallelism is one of the holy grails of functional programming
10:49:35 <pejo> DaveCGI924, if there was a theory available, I bet someone would implement it.
10:50:06 <SamB> well, I think we'll find that we still need to do a lot of the work
10:50:55 <koala_man> why does  getMap k = do { (_, _, _, _, map) <- get; return map; } work, but dropping the unused k gives errors?
10:51:18 <sjanssen> koala_man: it is the Dreaded Monomorphism Restriction
10:51:25 <int-e> koala_man: it's called the monomorphism restriction
10:51:28 <koala_man> eek
10:51:36 <int-e> koala_man: you can fix it by giving an explicit type signature
10:51:38 <kpreid> koala_man: just write a type signature
10:51:57 <monochrom> On automatic parallelism, I advise very heavy-duty static analysis on data dependency to identity which parts of a program should *not* be parallelized.
10:52:04 <mrd> #haskell :: Stereo
10:52:08 <sjanssen> koala_man: things that "look like constants" can't be polymorphic unless you give a type signature
10:52:13 <DaveCGI924> ehhh, does the monomorphism restriction have anything to do with parallelization
10:52:14 * SamB wishes he could get trac to highlight bugs that both have no milestone and are not closed
10:52:32 <kpreid> DaveCGI924: no
10:52:40 <SamB> monochrom: I can't help but think that it should involve the typesystem
10:52:44 <DaveCGI924> ok i got confused :P
10:52:58 <SamB> not really sure, though
10:53:23 <monochrom> the monomorphism restriction is a separate thread.
10:53:32 <SamB> but I'd sure like to have some way of knowing what the compiler has decided that it can do, and of that what it has decided would be a good idea
10:53:43 <int-e> koala_man: on an unrelated note - why don't you make your state a record with named accessors? (data State = State { ..., stMap :: Map ... } - I imagine that would enhance readability a bit.
10:53:58 <SamB> DaveCGI924: the monomorphism restriction is trivial compared with parallelization
10:54:04 <int-e> koala_man: err, State is a bad name :)
10:54:37 <SamB> DaveCGI924: it doesn't even forbid anything as far as I can tell
10:54:47 <koala_man> readability is for dyslectics
10:55:10 <apfelmus> int-e: thanks for the pointer, that's what i've been looking for! but i don't get the utility "solution". I mean, I'm happy to bet my money on that as soon as the average is like 1$ or so.
10:55:30 <apfelmus> if it's infinite, well that's even better :)
10:55:35 <glguy> The MR is just to make sure that if something looks like a CAF, it is one
10:56:08 <SamB> glguy: the MR is just to make up for pathetic compilers :-P
10:56:41 <ndm> the MR is a premature optimisation
10:56:52 <quicksilver> no, hte MR is to make up for confused programmers
10:56:53 <SamB> it is the WRONG optimization
10:57:00 <EvilTerran> the MR is why this country's going to the dogs!
10:57:05 <quicksilver> that is, programmers that read something into the syntax that isn't really there
10:57:07 <kpreid> haskell-lint --point-out-polymorphic-constants
10:57:07 <int-e> apfelmus: the trick is that the expected utility of the game isn't finite, at least for a number of reasonable definitions of utility. (say, linear up to $1000000, and then decaying like a square root)
10:57:17 <int-e> apfelmus: err is finite
10:57:18 <ndm> i thought warnings were meant to warn programmers when they wrote something that does quite mean what they might think it to
10:57:44 <quicksilver> yup, the monomorphism restriction is a warning that got out of contorl :)
10:57:45 <vincenz> in Soviet Russia, you restrict monorphism.
10:58:02 <apfelmus> int-e: but just what does utility measure?
10:58:23 <ndm> indeed, and for things like:
10:58:27 <SamB> that's another good point... why change the type of programs when you could just give warnings?
10:58:41 <ndm> optimise = transform f where f ...
10:58:58 <int-e> apfelmus: the perceived benefit of having a certain amount of money - it's highly subjective
10:58:59 <ndm> which is clearly not intended to be a CAF, but a succinct description, its really annoying
10:59:09 <SamB> ndm: yeah
10:59:26 <SamB> so is the MR being warningified for Haskell'?
10:59:33 <koala_man> 149 chars of signature for a 53 char function. weee
10:59:51 <kpreid> koala_man: maybe some type aliases?
11:00:06 <quicksilver> int-e: it's rather related to the old 'keep doubling your bet and placing it all on black' idea isn't it?
11:00:06 <SamB> (I presume the warning would be optional, at that)
11:00:16 <quicksilver> int-e: except with the house and player switched
11:00:29 <apfelmus> int-e: hm, but isn't it a cut-off problem? I mean, if each game costs 1$, I'm going to play. how does utility determine the cut-off at which I'll stop playing it?
11:00:41 <sjanssen> SamB: it'd be odd to mandate a warning in the language specification
11:01:01 <SamB> sjanssen: odder to implement it unconditionally
11:01:08 <SamB> even if it was mandated
11:01:09 <int-e> quicksilver: hmm. right. (it's off by one dollar or so)
11:03:37 <apfelmus> hm, so the solution is probably: given a finite amount n of initial money, the probability to get > 0$ revenue is like 1%?
11:03:40 <int-e> apfelmus: the assumption is that the expected utility you get out of the game is finite. presumably you are willing to pay money worth as much as that expected utility.
11:04:24 <int-e> apfelmus: I really prefer the practicability argument, it's based on far fewer assumptions.
11:04:41 <apfelmus> yeah, I agree.
11:04:57 <apfelmus> so the practical argument is that you don't have enough money to wait for the jackpot
11:05:18 <int-e> no, the argument is that the game isn't really infinite.
11:05:43 <int-e> because the thing you play for - money - isn't available in unlimited quantities.
11:06:07 <apfelmus> do you mean my money or the bank's money?
11:06:09 <SamB> you can't go into the red
11:06:19 <int-e> and once you have an upper bound on the number of rounds the expected value of the game becomes finite.
11:07:21 <int-e> oh http://plato.stanford.edu/entries/paradox-stpetersburg/ lists solution attempts, too
11:07:22 <lambdabot> Title: The St. Petersburg Paradox (Stanford Encyclopedia of Philosophy)
11:07:31 <apfelmus> so that's the money I can bet that limits the number of rounds
11:08:09 <apfelmus> it's not that the game won't happen because the casino doesn't have enough money
11:09:09 <DaveCGI925> what does "Just t/Nothing" have to do with side efffects?
11:09:37 <int-e> DaveCGI925: nothing
11:09:54 <int-e> DaveCGI925: is this about monads?
11:09:54 <apfelmus> DaveCGI925: Just Nothing ;)
11:10:11 <DaveCGI925> yeah it is about monads
11:10:16 <mrd> Lemmih: around?
11:10:29 <DaveCGI925> i started reading about them and i dont see what wrapping a value in a Just t/Nothing has to do with side effects
11:10:32 <monochrom> "Nothing" is a side effect. In some sense anyway.
11:10:33 <desp> grar
11:10:38 <int-e> DaveCGI925: side effects are just one thing that monads can encapsulate - and that really only happens in the IO (and to some extend in the ST) monad.
11:11:15 <int-e> > [1,2] >>= \x -> [x+2, x*3] -- side effects?
11:11:16 <apfelmus> well, Nothing is a kind of exception
11:11:17 <lambdabot>  [3,3,4,6]
11:11:32 <Baughn> DaveCGI925: Monads do more - far more - this is why they're superior to strict code. ;)
11:11:32 <apfelmus> and a list of values is something like non-determinism
11:12:04 <apfelmus> DaveCGI925: did you just start reading about monads?
11:12:22 <DaveCGI925> apfelmus yeah on wikipedia lol
11:13:22 <apfelmus> DaveCGI925: ok. I'd like to offer you a position as guinea pig. Interested ;)
11:13:35 <apfelmus> *Interested ?
11:14:30 <apfelmus> (monad reading guinea pig, that is. i don't take responsibility for brain explosion, though ;)
11:14:47 <DaveCGI925> hmm i need to rejoin with a real irc client
11:15:02 <monochrom> guinea pigs are for brain explosion and cancer alike.
11:15:53 <apfelmus> DaveCGI925: the wikibook chapter http://en.wikibooks.org/wiki/Haskell/Understanding_monads is undergoing a rewrite.
11:15:55 <lambdabot> Title: Haskell/Understanding monads - Wikibooks, collection of open-content textbooks
11:17:58 * int-e wonders what apfelmus is up to
11:19:00 <monochrom> brainonuclear weapon. explodes your brain. :)
11:19:02 <apfelmus> int-e: apparently, i need someone new to monads to read it :) and i'm planning on integrating the St. Petersburg Paradox into the article
11:19:39 <DaveCGI586> ok there we go
11:19:48 <DaveCGI586> whats this about being a guinea pig for monads
11:19:49 <monochrom> perhaps I should say cerebronuclear
11:20:10 <monochrom> a guinea pig for a monad tutorial.
11:20:14 <Lemmih> mrd: Yo.
11:20:14 <apfelmus> DaveCGI586: the wikibook chapter http://en.wikibooks.org/wiki/Haskell/Understanding_monads is undergoing a rewrite.
11:20:15 <lambdabot> Title: Haskell/Understanding monads - Wikibooks, collection of open-content textbooks
11:20:34 <mrd> Lemmih: i had a question about the Hi parser of hs-plugins
11:20:52 <apfelmus> and you're the perfect candidate for first reading ;)
11:21:05 <mrd> there's a lot commented out.  i understand you were just after one piece of info in the file?  is the rest of the code deprecated?
11:21:24 <DaveCGI586> apfelmus, hmm is there a definition for syntax :: and -> ?
11:21:40 <DaveCGI586> i am new to haskell as well
11:21:43 <apfelmus> DaveCGI586: but i deny all liability for brain damage, brain explosion or other cerebral injuries ;)
11:21:48 <apfelmus> DaveCGI586: ah, oh.
11:21:59 <DaveCGI586> tahts ok ive used functional langauges before (SML, OCAML)
11:22:03 <monochrom> "x :: t" means the type of x is t.
11:22:13 <apfelmus> and -> is the function arrow
11:22:16 <arjanoosting> sudo aptitude update
11:22:18 <DaveCGI586> ok and (M a) ?
11:22:36 <monochrom> in types, "c -> b" means the type of functions with domain type c, codomain type b.
11:22:38 <apfelmus> M is a type constructor
11:22:51 <kpreid> ->, like : and [], is *almost* nonprimitive
11:22:54 <apfelmus> i think it's  (a M)  in ML
11:23:08 <monochrom> Exercise: "foo :: (Int -> Bool) -> Bool"
11:23:31 <monochrom> arjanoosting: password:
11:23:53 <DaveCGI586> hmm i dont remember (a M) in ML
11:24:03 <apfelmus> like (int Queue)
11:24:08 <apfelmus> a queue of integers
11:24:11 <mrd> Queue int
11:24:12 <mrd> er
11:24:14 <mrd> yea
11:24:21 <mrd> (frickin reversed parameters)
11:24:22 <monochrom> ('a M).  type variables are like 'varname in ML.
11:24:22 <apfelmus> i don't know ML
11:24:30 <DaveCGI586> oh ok
11:24:38 <DaveCGI586> specialization on M?
11:24:58 <monochrom> Haskell "Maybe Int" = ML "int option"
11:25:04 <DaveCGI586> what about |->
11:25:04 <arjanoosting> :-)
11:25:14 <monochrom> Haskell "Maybe a" = ML " 'a option "
11:25:27 <apfelmus> hm, isn't there the "intro to Haskell for ML programmers"?
11:25:32 <monochrom> IIRC |-> is user-defined.
11:26:03 <apfelmus> @where meta
11:26:03 <lambdabot> I know nothing about meta.
11:26:35 <int-e> DaveCGI586: it's used as a lambda there - x |-> y  is \x -> y in Haskell,  fun x -> y  in ML
11:26:57 <monochrom> fn x => y
11:27:00 <mrd> [a] means 'a list, Maybe a means 'a option, (a,b) means 'a * 'b
11:27:01 <DaveCGI586> ah ok
11:27:07 <DaveCGI586> one more thing is there a 1-page haskell book somewhere
11:27:18 <DaveCGI586> i need to go but i will read the whole monad thing and look it over
11:27:22 <apfelmus> ah! x |-> ...  is mathematical notation for a function
11:28:10 <int-e> I'd prefer  λ x. y  as a compromise between math and haskell.
11:28:47 <monochrom> λ x. y is standard in one community
11:28:51 <apfelmus> what would the C++ newbies say to that? i mean, they only see \x ->
11:29:13 <apfelmus> and maybe don't know what a λ is ...
11:29:25 <DaveCGI586> heh i understand lambda
11:29:33 <DaveCGI586> well thanks ill get back to this later :)
11:29:40 <monochrom> C++ newbies haven't thought of anonymous functions.
11:30:20 <monochrom> You do know about how your mother tongue reflects your civilization.
11:30:22 <apfelmus> DaveCGI586: yes. it's just that the monad tutorial strives to be generic in the reader :)
11:30:28 <mrd> in this day and age of unicode and i18n, we should be using real lambdas
11:31:01 <Vq^> monochrom: i'm a C++ newbie
11:31:14 <mrd> and special keyboards with a big fat lambda key
11:31:34 <monochrom> Good for you. You have no category theory to worry about. :)
11:32:04 <apfelmus> but arguably, x |->  doesn't work for either λ-hackers or C/C++/Java/...-coders
11:32:26 <monochrom> x |-> x+1  only works for mathematicians who never write programs.
11:32:39 <apfelmus> yeah
11:33:51 <monochrom> The only programming language using |-> is Maple.
11:35:16 <psykotic> i like x |----------------------> x + 1
11:35:20 <monochrom> You can bet on C, C++, Java coders having seen a bit of Perl or Python. They would know Perl's "sub" and Python's "lambda".
11:36:00 <apfelmus> it's a λ now :)
11:36:37 <monochrom> psykotic: why do you like the long --- ?
11:36:46 <psykotic> monochrom, that was a joke about inappropriate notation
11:36:54 <monochrom> I see.
11:37:01 <ivant_> @pl \a -> b a || c a
11:37:01 <lambdabot> liftM2 (||) b c
11:37:05 <psykotic> given the crowd response, i'll take it off my list :)
11:38:24 <monochrom> I see an advantage. You can allow the long --- to bend. On a very very crowded blackboard or whiteboard with lots of DNEs, you can bend it around all the DNEs and use space far away.
11:48:08 <desp> monochrom++
11:48:13 <desp> darcs--
11:48:37 <monochrom> Are the two related?
11:49:17 <desp> I don't know, are you?
11:49:47 <desp> darcs refuses to check out the gentoo-haskell repository on PPC
11:49:48 <monochrom> Err ok, thanks for the karma :) but what was it for?
11:50:04 <desp> the karma was for the bending lambda replacement
11:50:09 <monochrom> haha ok :)
11:55:35 <SamB> @. pl djinn Maybe a -> Maybe (a, a)
11:55:35 <lambdabot> (line 3, column 13):
11:55:36 <lambdabot> unexpected ">" or "-"
11:55:36 <lambdabot> expecting variable, "(", operator or end of input
11:55:41 <SamB> @djinn Maybe a -> Maybe (a, a)
11:55:41 <lambdabot> f a =
11:55:41 <lambdabot>     case a of
11:55:41 <lambdabot>     Nothing -> Nothing
11:55:41 <lambdabot>     Just b -> Just (b, b)
11:55:48 <ClaudiusMaximus> @where hscolor
11:55:49 <lambdabot> I know nothing about hscolor.
11:56:13 <SamB> @. pl djinn a -> (a,a)
11:56:14 <lambdabot> f = join (,)
11:56:30 <ClaudiusMaximus> aha, hscolour is the name
11:56:38 <vincenz> @where hscolour
11:56:39 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
11:56:53 <ClaudiusMaximus> thanks :)
12:07:58 <CosmicRay> dcoutts: ping?
12:10:44 <olsner> #haskell was awfully quiet...
12:11:05 * arcatan makes some noise
12:11:23 <olsner> yeah!
12:11:30 <olsner> @users
12:11:30 <lambdabot> Maximum users seen in #haskell: 352, currently: 348 (98.9%), active: 15 (4.3%)
12:14:09 <ivant_> @hoogle (a->Bool) -> [a] -> ([a], [a])
12:14:10 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
12:14:10 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
12:14:10 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
12:14:23 <oerjan> max users was higher than that yesterday
12:15:55 <Saizan> ?hoogle (a -> Bool) -> [a] -> [Either [a] [a]]
12:15:56 <lambdabot> No matches, try a more general search
12:16:24 <dcoutts> CosmicRay: pong
12:17:29 <JBGood25> :t liftM (join (,))
12:17:32 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m (a1, a1)
12:17:56 <oerjan> @quote tac-tics
12:17:57 <lambdabot> No quotes match. Wrong!  You cheating scum!
12:18:58 <olsner> Saizan: what kind of function are you looking for? something like groupBy?
12:19:36 <oerjan> @quote TSC
12:19:36 <lambdabot> No quotes match. My pet ferret can type better than you!
12:21:10 <oerjan> @quote stereo
12:21:10 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
12:21:33 <shachaf> @quote spear
12:21:33 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
12:21:39 <shachaf> The @karma was reset again, too.
12:22:32 <olsner> awww, the stereo quote is gone?
12:23:01 * dolio is glad.
12:23:51 <dolio> I don't need to hear it N times a day. :)
12:24:02 * olsner is sad
12:24:20 <oerjan> @quote psykotic
12:24:20 <lambdabot> psykotic says: monochrom, i'm reminded me of that alan kay quote. "i invented the term 'object-oriented' and i can tell you c++ wasn't what i had in mind"
12:24:25 <oerjan> @quote psykotic
12:24:25 <lambdabot> psykotic says: the reader monad is your friend. trust the reader monad. be happy!
12:24:41 <oerjan> @quote psykotic lie-group
12:24:41 <lambdabot> No quotes match. stty: unknown mode: doofus
12:24:48 <oerjan> @quote lie-group
12:24:50 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
12:25:01 <olsner> I got it just often enough to keep the addiction rolling
12:25:07 <dolio> @quote lie.group
12:25:07 <lambdabot> psykotic says: so, if you have a lie group with two generators a and b, a generates turns and b generates (relative) forward motion, then the lie bracket [a,b] = a b a^(-1) b^(-1) is a parallel
12:25:07 <lambdabot> parking transformation
12:25:29 <monochrom> hahahaha
12:28:38 <CosmicRay> dcoutts: did you see the gtk2hs error I pasted earlier?
12:29:02 <CosmicRay> dcoutts: see http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=435536\
12:29:08 <CosmicRay> err http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=435536
12:29:10 <lambdabot> Title: #435536 - gtkrsync - FTBFS: undefined reference to `gtkzm0zi9zi11_GraphicsziUIzi ...
12:29:12 <dcoutts> CosmicRay: yes
12:29:17 <CosmicRay> also I have an error compiling the darcs version
12:29:30 <CosmicRay> dcoutts: have you ever seen that error before?
12:29:40 <CosmicRay> it is particularly odd that it works on some platforms and not on others
12:30:01 <dcoutts> CosmicRay: I've not, have you tried building gtk2hs without using splitobjs ?
12:30:18 <CosmicRay> no; I unfortunately do not have good access to those machines
12:31:23 <Igloo> splitobjs aren't being used there
12:31:33 <dcoutts> ok
12:32:09 <dcoutts> Igloo: though that would have to be disabled in the gtk2hs build, since it'll try to use them by default
12:32:19 <Igloo> Oh, I think I know what that is, and I might have fixed it in the HEAD
12:32:38 <dcoutts> irrespective of the ghc default, since finding the ghc config is not so easy
12:32:45 <Igloo> dcoutts: GHC doesn't know how to split objs on that platform, so I'm quite confident that's not the issue  :-)
12:33:05 <dcoutts> we could really do with a ghc --info command to tell us if things like ghci and split objs are expected to work
12:33:12 <dcoutts> cabal could do with that too
12:33:14 <Igloo> I've opened a bug about that
12:35:42 <dcoutts> oh good
12:36:03 <Igloo> You can already ask the RTS about itself, which is even more useful IMO
12:36:10 <dcoutts> oh yes
12:36:12 <dcoutts> how?
12:36:28 <Igloo> e.g. "What version of GHC compiled that darcs you downloaded that panics with stg_pap?"
12:36:48 <Igloo> +RTS --info
12:37:37 <Igloo> If there's anything else you think of that would be useful, add it to http://hackage.haskell.org/trac/ghc/ticket/1478 ASAP please!
12:37:39 <lambdabot> Title: #1478 (Flag to get information about the compiler and RTS) - GHC - Trac
12:38:00 <SamB> "ghc +RTS --info" just says "unknown RTS option: --info" and then the --help shpiel
12:39:32 <dcoutts> Igloo: that list covers it I think
12:39:57 <Igloo> SamB: In a recent HEAD?
12:39:59 <dcoutts> Igloo: and make it a machine parsable and extensible format
12:40:26 <dcoutts> Igloo: [(Name,Value)] or something
12:40:29 <SamB> Igloo: well no
12:40:39 <Igloo> dcoutts: Currently you would just have to look for lines matching what you want
12:41:12 * Igloo isn't sure what is best
12:41:19 <shachaf> +-*+++++++\
12:41:21 <SamB> but it's not so useful yet if it only works on things built with recent HEAD
12:41:27 <shachaf> Oops, sorry.
12:42:02 <dcoutts> CosmicRay: so, sorry, no idea, I've seen linker errors but they can be caused by a multitude of things
12:42:10 <CosmicRay> ok.
12:42:24 <CosmicRay> have you seen:
12:42:27 <CosmicRay> gtk/Graphics/UI/Gtk.hs:249:50:
12:42:27 <CosmicRay>     Module
12:42:27 <CosmicRay>     `Graphics.UI.Gtk.Display.StatusIcon'
12:42:27 <CosmicRay>     does not export
12:42:27 <CosmicRay>     `onActivate'
12:42:39 <CosmicRay> trying to build the latest darcs version?
12:42:46 <Igloo> SamB: I lack the ability to make it work on older releases. But that's why I want suggestions ASAP, so that we will be able to rely on it in the future
12:48:23 <SamB> Igloo: ah.
12:49:03 <SamB> and a +RTS flag is strictly more powerful (as long as all GHC builds are stage2)
12:49:58 <Igloo> No, GHC knows which RTSs it has available, for example
12:50:24 <CosmicRay> Igloo: did you see the bug about runhaskell being broken on unregisterized platforms?
12:51:23 <Igloo> CosmicRay: Yes
12:51:29 <SamB> Igloo: hmm. it should say what defaults it has
12:51:43 <CosmicRay> Igloo: does that make sense as something to resolve in runhaskell, just using ghc?
12:51:48 <Igloo> SamB: Defaults?
12:53:12 <SamB> Igloo: well.
12:53:44 <SamB> like whether it uses NCG by default
12:54:04 * SamB isn't sure about this
12:55:24 <SamB> but if there's anything important like that which might be configurable the default should be listed
12:57:19 <|Winterstream|> Hmmm. I have a question which is totally off topic for this channel. But there are lots of smart people here and I'm sure some of you must have worked with Plan 9 before?
12:57:47 <SamB> just ask the question
12:58:48 <|Winterstream|> Plan 9 has this nifty reliable datagram protocol, called IL. I'm pretty sure one can emulate IL pretty well over UDP, by adding some of the IL fields to the start of a UDP packet. But I'd like to know whether anyone thinks this could bomb.
12:59:44 <SamB> hmm.
12:59:59 <olsner> (plenty of other reliable datagram protocols/libraries out there though... like enet or SCTP to name two)
13:00:04 <SamB> the wikipedia page for IL says that it is deprecated as of the 4th edition of Plan 9
13:00:45 <SamB> in favor of TCP
13:00:48 <|Winterstream|> Oh
13:01:37 <|Winterstream|> Ok
13:01:37 <|Winterstream|> Well. If I can find a library that already works, all the better
13:01:37 <|Winterstream|> (for one of the other reliable datagram formats)
13:02:30 <|Winterstream|> SamB - Really!? Wow. I have to see that...
13:03:20 <olsner> TCP with some simple protocol like prefixing the length of the next message is a pretty easy way to get reliable, message-based communications
13:03:27 <ohub> is SCTP in use anywhere?
13:04:03 <SamB> http://cm.bell-labs.com/magic/man2html/3/ip
13:04:06 <lambdabot> Title: Plan 9 /sys/man/3/ip
13:04:18 <SamB> "IL provides a reliable datagram service for communication between Plan 9 machines but is now deprecated."
13:10:49 --- topic: '["A Taste of Haskell: http://blip.tv/file/324976 http://www.blip.tv/file/325646/","The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]'
13:10:49 --- topic: set by dons on [Wed Aug 01 17:42:19 2007]
13:16:36 <reffie> does ghc know when functions aren't referencially transparent (if you use unsafePerformIO or whatever)?
13:17:32 <xerox> reffie: no
13:17:36 <SamB> why would it?
13:17:48 <reffie> so doesn't using that break things?
13:17:54 <xerox> Yes.
13:17:59 <SamB> duh
13:18:11 <SamB> why do you suppose it has "unsafe" at the beginning of the name?
13:18:13 <reffie> so why exactly is using it for debugging (trace) a good idea?
13:18:17 <geezusfreeek> reffie, hence the name unsafePerformIO
13:18:23 <reffie> it makes no sense
13:18:31 <SamB> reffie: basically, you have to prove that it's not an issue
13:18:36 <reffie> for debugging i'd want something that wouldn't break things further
13:18:55 <roconnor> trace is not the ideal way to debug a haskell program.
13:18:59 <xerox> trace doesn't have much chance of breaking things, wild unsafePerformIO does.
13:19:07 <reffie> ?src trace
13:19:08 <lambdabot> trace string expr = unsafePerformIO $ do
13:19:08 <lambdabot>     hPutStrLn stderr string
13:19:08 <lambdabot>     return expr
13:19:14 <SamB> it doesn't cause undefined behaviour
13:19:16 <geezusfreeek> reffie, the point is to extend the library a bit if you need to... it's up to you to make sure that whatever you do with unsafePerformIO is safe
13:19:21 <roconnor> but trace is pretty good practical way to debug a program
13:19:22 <geezusfreeek> just don't use it if it scared you too much
13:19:31 <geezusfreeek> *scares
13:19:41 <reffie> geezusfreeek there's nothing better
13:19:41 <xerox> reffie: you can't feed |deleteFile "/"| to *that* unsafePerformIO.
13:19:56 <oerjan> reffie: since the unsafe side effect of trace only affects stderr, it doesn't hurt the rest of the program
13:19:58 <reffie> geezusfreeek at least if there is, i haven't found it
13:20:02 <SamB> reffie: the only thing trace messes up is stderr
13:21:18 <hpaste>  xerox pasted "GHCi 6.7" at http://hpaste.org/2100
13:21:20 * SamB wonders what you'd need to do in order to prove that trace doesn't do anything besides print things to stderr
13:21:26 <ndm> xerox: are you giving a talk at anglohaskell?
13:21:27 <xerox> reffie: -^
13:21:36 <SamB> (and evaluate it's input string, obviously)
13:21:41 <xerox> ndm: hmm, didn't plan any.
13:22:02 <SamB> (but it could do THAT without unsafePerformIO)
13:22:38 <ndm> xerox: feel tempted? maybe a 10 minute talk in the short talks section?
13:23:14 <xerox> ndm: I'm not sure. What could it be about?
13:23:33 <ndm> xerox, your choice, anything interesting - your SOC project perhaps
13:23:53 <xerox> Okay, I'll try to find something, then I'll tell you.
13:24:35 <ndm> you don't have to, but if you want to you are most welcome
13:24:51 <SamB> ndm: how could he have to?
13:25:07 <Winterstream> arg. network is nasty tonight
13:25:27 <ndm> SamB, i am conveying a lack of pressure on the talk front, not suggesting i have the power to force him
13:25:46 <xerox> ndm: Right.
13:25:50 <SamB> well it does look like you are somewhat in charge of AngloHaskell
13:26:32 <Heffalump> I don't think that conveys power to enforce talks :-)
13:26:39 <ndm> co-in-charge
13:26:45 <SamB> ndm: yeah.
13:26:46 <shapr> xerox: Is your SoC source online?
13:26:56 <xerox> shapr: yes, let me check if it is the latest.
13:27:00 <Heffalump> does anyone know what the status of Haddock-on-GHC-API is?
13:27:08 <SamB> but it doesn't say anything about money, so it looks like you'd be unlikely to be able to refuse him entry if he wouldn't talk ;-)
13:28:03 <ndm> i don't think we are going to refuse anyone entry, on any grounds
13:28:07 <ndm> unless it was a perl programmer :)
13:28:51 <sm> gee, I'd take a perl programmer over.. oh.. a php programmer
13:28:52 <SamB> that would be stupid
13:29:11 <SamB> perl programmers should be most especially welcome, as long as they leave their perl at the door
13:29:40 <ndm> of course, without perl programmers, we wouldn't have optimised tail calls with GHC
13:29:54 * sm thinks of all the blub programmers below him and sniggers
13:30:00 <SamB> true
13:30:30 <ndm> @karma+ SamB -- testing Data.Derive
13:30:30 <lambdabot> SamB's karma raised to 1.
13:30:34 <ndm> @karma+ SamB -- finding bugs
13:30:34 <lambdabot> SamB's karma raised to 2.
13:30:38 <ndm> @karma+ SamB -- fixing them
13:30:38 <lambdabot> SamB's karma raised to 3.
13:30:47 <ndm> it was really appreciated :)
13:31:27 <SamB> hey, I only fixed 2/3 of them
13:31:36 <ndm> does it now work fully?
13:31:47 <SamB> I haven't tested everything yet
13:32:12 <ndm> yeah, but its a good start
13:32:23 <ndm> i added a new derivation today, using the guess framework, and it was really cool
13:32:31 <ndm> i'd forgotten how cool derivation by guess was :)
13:32:48 <Winterstream> ndm: Were tail calls optimized for the benefit of Pugs?
13:33:00 <xerox> shapr: pushing. darcs.haskell.org/~paolo/darcs/parsec hang on.
13:33:03 <ndm> Winterstream: they are optimised by the evil mangler, which is a perl process
13:33:10 <SamB> ndm: oh, nice fix for Cabal breaking the API
13:33:16 <SamB> and I especially like that class name
13:33:25 <SamB> +class CabalBreaksTheAPI_Grr a where
13:33:25 <SamB> +    grr :: a
13:33:34 <ndm> SamB, its rather annoying that it has to be done, fortunately its easy to fix in this one case
13:33:49 <SamB> yes
13:33:55 <xerox> shapr: OK, pushed. there's also darcs.haskell.org/~paolo/darcs/endo a simple test app doing bytestring-parsec on endo.dna :)
13:34:04 <SamB> the annoying factor is why I like the class name ;-)
13:34:08 <Winterstream> ndm:Ha ha ha! That's a brilliant name.
13:34:38 <shapr> xerox: thanks!
13:34:58 * Winterstream rolllllls on the floor.
13:34:59 <ndm> Winterstream: they used to have the evildriver, which was a perl script that invoked GHC as well
13:35:23 <ddarius> ndm: When was that?
13:35:42 <ndm> ddarius: years ago
13:35:46 <Winterstream> ndm: Classic. Both are brilliant, but "evil mangler" is so good because it sounds so generic. And also, evil, mangle and Perl all go together well.
13:35:49 <ndm> before i had ever used Haskell
13:36:15 <xerox> shapr: there are no additional libraries yet, that is permutation parsing, expression, and token. I'm working on it.
13:36:17 <SamB> the evil mangler is probably actually *less* evil for being written in Perl
13:36:33 <ndm> its the concept that is evil, to a great extent
13:36:35 <SamB> the evil comes from its purpose
13:36:47 <xerox> shapr: it is basically usable, all of standard parsec I believe. Report everything (-:
13:36:54 <Winterstream> It reminds me of that XKCD strip about most of the universe being hacked together with Perl...
13:36:54 <earthy> yah. what it does is vewwy vewwy evil
13:37:14 <ndm> yes, the lisp one
13:37:25 <Winterstream> Yeah
13:39:25 <ddarius> ndm: Ah.  I don't think the evil driver was still there when I started using Haskell.
13:39:27 <sm> perl *contains* the evil
13:40:11 <Winterstream> sm: Yes, but in evil mangler it's contained in IO evil
13:40:14 <Winterstream> heh
13:40:19 <Winterstream> sorry, that was so lame
13:41:33 <sm> soo.. perl is like the monad for evil ?
13:41:45 <Winterstream> ha ha ha
13:43:49 * sm is just trying to understand how to do stuff with evil.. still new here
13:44:15 <Winterstream> sm: With Haskell, you can do no evil
13:44:19 <Winterstream> :)
13:44:21 <sorear> ndm: unregisterized unmangled ghc still has optimized tail calls, it uses the standard while(1){ fun = (*fun)(); } trick (at least with USE_MINIINTERPRETER)
13:44:52 <SamB> sorear: those aren't nearly as optimized though, are they?
13:44:54 <ndm> sorear: thats not optimised tail calls, thats simply tail calls
13:45:14 <ndm> or rather, tail continuations
13:45:18 <SamB> I guess sorear thinks "optimized" means "doesn't eat your stack"
13:45:23 <sorear> yeah :(
13:45:36 <SamB> I was kind of going with that interpretation myself ;-)
13:45:46 <ndm> yeah, thats a very old trick, but very cute
13:56:20 <ddarius> Odd way to come across Robert Harper.
14:02:37 <reffie> xerox nice
14:02:47 <reffie> xerox i'll eagerly await the next ghc release then :)
14:02:53 <xerox> reffie :D
14:03:00 <malsyned> Am I reading this correctly, that Template Haskell is potentially non-hygenic?
14:03:43 <SamB> malsyned: what are you reading?
14:04:04 <sorear> malsyned: Right.  We don't need hygenic macros because laziness+hofs is just as powerful.
14:04:18 <reffie> hofs?
14:04:19 <SamB> malsyned: you can use it hygenically
14:04:25 <sorear> higher-order functions
14:04:25 <SamB> higher-order-functions
14:04:57 <malsyned> SamB: I'm reading the original Template Haskell paper, from 2002.
14:05:10 <SamB> malsyned: what part of it?
14:05:35 <sjanssen> HasselHOFfs
14:05:37 <malsyned> The part where they stop using quasiquoting and start building expression trees programatically.  the part where they define the genPe function, specifically.
14:06:41 <SamB> malsyned: you don't have to do it that way
14:06:50 <SamB> but yes, you can use it nonhygenically
14:06:53 <malsyned> sorear: laziness+hofs means your macros can always just generate a lambda and then rely on scoping rules to keep things hygenic?
14:07:13 <SamB> malsyned: not really
14:07:21 <SamB> malsyned: it means you can just not use macros so much
14:07:31 <sorear> malsyned: think map
14:07:50 <SamB> malsyned: anyway, today's TH supports hygenic stuff too...
14:08:04 <malsyned> Oh, yeah, in general I'm aware that you don't need macros in Haskell for most of the things they're used for in Lisp.
14:11:33 <SamB> @hoogle Q Name
14:11:33 <lambdabot> Language.Haskell.TH.newName :: String -> Q Name
14:11:47 <SamB> malsyned: see? we do have a way to do it hygenically...
14:12:31 <malsyned> I'm just getting to the bit about the Q monad now.
14:12:41 <malsyned> I imagine it will illuminate me.
14:12:41 <SamB> > id $(newSym "hi")
14:12:42 <lambdabot>   Not in scope: `newSym'
14:12:46 <SamB> hmm.
14:12:51 <dozer> http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
14:12:52 <SamB> > id $(newName "hi")
14:12:53 <lambdabot>   Not in scope: `newName'
14:12:53 <lambdabot> Title: High-level option handling with GetOpt - HaskellWiki, http://tinyurl.com/3cumhz
14:12:57 <SamB> aww...
14:12:57 <dozer> I'm having trouble following this guide
14:13:04 <SamB> > id $(Language.Haskell.TH.newName "hi")
14:13:05 <lambdabot>   Not in scope: `Language.Haskell.TH.newName'
14:13:25 <dozer> I can't see where/how it sets the verbose flag
14:14:17 <xerox> SamB: TH was used to hack lambdabot :)  Somewhere it's written that maybe a subset of TH might be allowed safely, but nobody has done any research in that I think.
14:15:11 <EvilTerran> SamB, i don't think lambdabot has TH enabled
14:15:22 <EvilTerran> [| 23 |]
14:15:24 <EvilTerran> > [| 23 |]
14:15:25 <lambdabot>  Parse error
14:15:39 <SamB> EvilTerran: it's well know that most TH won't parse
14:15:57 <SamB> since lambdabot runs a preparser to check that it's dealing with an expression
14:16:19 <EvilTerran> oh right.
14:16:34 <sjanssen> has anyone looked at porting @run to use the GHC-API
14:16:38 <sjanssen> ?
14:16:52 <xerox> sjanssen: where is the GHC API doc?
14:16:54 <sjanssen> at least we could use GHC's parser, rather than this slightly incompatible one
14:16:54 <SamB> sjanssen: it's not safe yet
14:16:59 <sorear> xerox: there is none
14:17:04 <sorear> sjanssen: I've asked, dons said "absolutely not!"
14:17:06 <xerox> sorear: not even haddock?
14:17:21 <sjanssen> SamB: yeah, you'd still need to do the forking that @run currently does
14:17:42 <sjanssen> sorear: why?
14:17:48 <sjanssen> NIH?
14:18:19 <SamB> sjanssen: so you've seen http://hackage.haskell.org/trac/ghc/ticket/367 ?
14:18:22 <lambdabot> Title: #367 (Infinite loops can hang Concurrent Haskell) - GHC - Trac
14:18:26 <sorear> 14:25:09 <sorear> @ask dons how vehemently would you oppose > 2 + 2 using ghci rather than runplugs?
14:18:32 <sorear> 14:26:12 <dons> sorear: I'd oppose it a *lot*
14:18:35 <sorear> 14:26:34 <dons> sorear: since that's about 10 exploitable holes right there if you do that
14:18:50 <SamB> ghci != ghc-api
14:18:53 <sjanssen> well, ghci isn't quite the same as ghc api
14:19:20 <sjanssen> SamB: yeah, I've seen that one.  There are probably a few other things -- thus we still need to fork()
14:19:24 <sorear> how do they differ, aside from the fact that one is a library?
14:20:01 <SamB> well, ghci has all those nifty colon commands and so forth...
14:20:01 <sjanssen> you still have to preparse to make sure that it's an expression
14:20:30 <matthew-_> is anyone here running ghc 6.6.1 on Mac OS X?
14:20:35 <sjanssen> sorear: x\n:! rm -rf .
14:21:34 <sjanssen> sorear: that's a valid Haskell expression with very nasty side-effects when sent to ghci
14:21:36 <sorear> sjanssen: you can't even express that over irc ;)  even if you could, it's no worse than runplugs
14:21:59 <sjanssen> sorear: what about @read?
14:22:06 <sorear> strips out newlines.
14:22:16 <sjanssen> still tenuous at best, IMO
14:22:21 <ivanm> was there a reason apfelmus mentioned my name around 6 hours ago?
14:23:18 <sorear> ivanm: it looks like a complete sentence to me?
14:23:59 <ivanm> sorear: well, from my logs, he said: <apfelmus>      ivanm: so, like balancing a pencil on the back of your hand?
14:24:04 <ivanm> but why?
14:24:23 <ivanm> since the last time I talked on #haskell was 5 days ago
14:24:40 <sorear> ivanm: look at the immediately preceding line...  ivan*t* talking about Mathieu functions and the inverted pendulum problem
14:25:00 <ivanm> heh, didin't think about that... just did a grep :s
14:25:35 <sjanssen> sorear: also, "Foreign.unsafePerformIO (putStrLn "bad stuff")"
14:25:52 <sjanssen> sorear: it's much easier to have confidence in the current solution
14:25:58 <ivanm> sorear: oh, OK, apfelmus did a typo.... thought that was weird
14:26:03 * ivanm goes back to lurking now
14:27:54 <sjanssen> ivanm: ping
14:28:04 <ivanm> sjanssen: pong
14:28:06 <sjanssen> :)
14:31:30 <pejo> matthew, I am.
14:32:01 <matthew-_> pejo: super. Has the bug at http://hackage.haskell.org/trac/ghc/ticket/1135 hit you at all?
14:32:03 <lambdabot> Title: #1135 (HsTime.h isn't installed by the Windows installer) - GHC - Trac
14:34:24 <pejo> matthew, hm. No. I have a ghc-6.6.1/include/{HsTime,HsTimeConfig}.h
14:34:57 <matthew-_> pejo: did you compile that yourself?
14:35:51 <pejo> matthew, no, using macports or darwinports or whatever it's called.
14:35:56 <sorear> ?hoogle Set a -> Set a -> Set a
14:36:00 <lambdabot> Data.Set.(\\) :: Ord a => Set a -> Set a -> Set a
14:36:00 <lambdabot> Data.Set.difference :: Ord a => Set a -> Set a -> Set a
14:36:00 <lambdabot> Data.Set.intersect :: Ord a => Set a -> Set a -> Set a
14:36:14 <sorear> hoogle++
14:36:34 <matthew-_> pejo: ok, thanks for the info
14:37:06 <sjanssen> firefox--
14:37:22 <sjanssen> I should really count how many times I type "killall firefox-bin"
14:37:50 <xerox> sjanssen: you might try epiphany-browser.
14:38:07 <sjanssen> xerox: I'm addicted to vimperator now
14:38:21 <sjanssen> add vim keybindings to epiphany and I might be interested :)
14:38:50 <xerox> No idea if it has been done, it has extensions though. Oh well.
14:39:03 <sorear> UniqSet.hs:12:19: Not in scope: `S.intersect'
14:39:09 <sorear> *grumble*
14:40:02 <sorear> ndm: Data.Set.intersect exists in Hoogle but not in realitiy
14:40:03 <desp> hrm
14:40:16 <xerox> It does exist in the docs too.
14:40:28 <xerox> > S.intersect (fromList [1,1,2,3]) (fromList [2,3,4]) -- hm?
14:40:29 <lambdabot>   Not in scope: `fromList'
14:40:35 <oerjan> it's intersection
14:40:43 <xerox> > S.intersection (S.fromList [1,1,2,3]) (S.fromList [2,3,4])
14:40:44 <lambdabot>   Not in scope: `S.fromList'
14:41:09 <sorear> While I'm at it, null really ought to be overloaded.
14:41:20 <desp> is there a "replace" function on lists?
14:41:20 <desp> @djinn help
14:41:20 <lambdabot> -- f cannot be realized.
14:41:44 <sjanssen> desp: use map, perhaps?
14:41:44 <xerox> desp: no
14:42:12 <sjanssen> @type \from to -> map (\x -> if x == from then to else x)
14:42:14 <lambdabot> forall a. (Eq a) => a -> a -> [a] -> [a]
14:42:48 <sorear> @type map (\x -> if x == ?from then ?to else x)
14:42:50 <lambdabot> forall a. (?from::a, Eq a, ?to::a) => [a] -> [a]
14:44:44 <sorear> @users
14:44:45 <lambdabot> Maximum users seen in #haskell: 352, currently: 347 (98.6%), active: 11 (3.2%)
14:44:46 <desp> sjanssen: of course.
14:44:50 <sorear> eek!
14:44:57 <ndm> sorear: was it removed? if not, i don't see how it ever got in there?
14:45:17 <sjanssen> @type \fromto -> map (\x -> maybe x id $ lookup x fromto)
14:45:19 <lambdabot> forall b. (Eq b) => [(b, b)] -> [b] -> [b]
14:45:43 <sorear> There was a 6.4.3?
14:45:54 <desp> @src words
14:45:54 <lambdabot> words s = case dropWhile isSpace s of
14:45:54 <lambdabot>     "" -> []
14:45:54 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
14:46:07 <desp> hmm.
14:46:13 <slava> so suppose we have a set S of subsets of a universe U, and S is ordered under inclusion
14:46:23 <slava> or rather,  a multiset S
14:46:30 <sorear> Why are there no online docs for 6.4?
14:46:33 <ndm> sorear: intersection exists, not entirely sure how Hoogle managed to make up intersect
14:46:34 <slava> if S contains no duplicate elements, we perform a topological sort
14:46:41 <sorear> slava: What kind of order?
14:46:51 <slava> but if S contains duplicates, then from the POV of topological sort the graph has a cycle
14:46:52 <sorear> ok.
14:47:01 <slava> i need to generalize topological sort to multisets
14:47:15 <slava> and the order of the equal elements in the final sort is irrelevant
14:47:36 <sorear> slava: you could perform an SCC analysis, and topologically sort the SCCs
14:47:41 <slava> SCC?
14:47:49 <sorear> strongly connected component
14:47:49 <desp> @pl words . map (\c -> if c == ',' then ' ' else c) . filter ('"' /=)
14:47:49 <lambdabot> words . map (flip if' ' ' =<< ((',') ==)) . filter ('"' /=)
14:48:04 <desp> uglu.
14:48:09 <desp> ugly, even.
14:48:19 <sjanssen> desp: oh, you just want to split things?
14:48:22 <sorear> incorrect, even.
14:48:25 <sjanssen> I've got code for that somewheres
14:48:29 <xerox> desp: do you want to replace `Char's or `String's ?
14:48:50 <desp> remove '"'s and split things on ','s instead of on whitespace
14:49:03 <sjanssen> desp: http://hpaste.org/2000
14:49:52 <beelsebob> sjanssen: I prefered the first definition
14:49:55 <sjanssen> @type \p -> map (dropWhile p) . groupBy (const (not . p))
14:49:57 <lambdabot> forall a. (a -> Bool) -> [a] -> [[a]]
14:50:07 <sjanssen> beelsebob: the first one is broken in subtle ways
14:50:13 <beelsebob> oh?
14:50:32 <sjanssen> specifically with things like "a,,,b"
14:51:06 <beelsebob> it would return ["a","","","b"], no?
14:51:31 <desp> sjanssen: nice, thanks
14:51:37 <anybody> !intro
14:51:43 <anybody> !ref
14:51:46 <desp> sjanssen++
14:51:48 <xerox> ?where yaht
14:51:48 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
14:51:54 <xerox> ?docs
14:51:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:51:58 <sjanssen> beelsebob: IIRC, the first version yields ["a", "b"]
14:52:03 <beelsebob> oh, okay
14:52:10 <desp> ?where wikibook
14:52:10 <xerox> There you go anybody :)
14:52:11 <lambdabot> http://en.wikibooks.org/wiki/Haskell
14:52:19 <desp> anybody: ^
14:52:19 <anybody> thank you
14:52:26 <xerox> ?wiki
14:52:26 <lambdabot> http://www.haskell.org/haskellwiki/
14:52:31 * anybody thanks everybody
14:52:57 * xerox hugs anybody
14:53:07 * sjanssen hugs nobody
14:54:03 * anybody hugs <body>
14:54:32 <litb> hmm
14:54:36 <blsecres> is there a way to prevent Cabal from deleting intermediate files?
14:54:37 <anybody> omg so much to read
14:54:52 <litb> haskell << 'hello'
14:54:57 <anybody> would you guys suggest me to read an online tut or to get a book?
14:55:00 <xerox> anybody: there's a quickstart somewhere.
14:55:02 <litb> anybody: recently i found a really nice haskell tutorial
14:55:07 <ddarius> http://citeseer.ist.psu.edu/
14:55:08 <lambdabot> Title: Computer and Information Science Papers CiteSeer Publications ResearchIndex
14:55:39 <litb> anybody: this one is really nice: http://haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
14:55:40 <lambdabot> Title: Learn Haskell in 10 minutes - HaskellWiki
14:55:48 <desp> yeah, that one rocks
14:55:56 <desp> next one I'd recommend would be the wikibook
14:55:59 <anybody> so no book?
14:56:03 <anybody> k
14:56:04 <desp> ?wikibook
14:56:04 <lambdabot> Unknown command, try @list
14:56:06 <xerox> ?wiki How_to_write_an_haskell_program
14:56:06 <lambdabot> http://www.haskell.org/haskellwiki/How_to_write_an_haskell_program
14:56:07 <desp> ?where wikibook
14:56:07 <lambdabot> http://en.wikibooks.org/wiki/Haskell
14:56:13 <desp> this one
14:56:35 <anybody> k. thx. so no hardcover book then?
14:56:46 <ddarius> anybody: There are plenty of books.
14:56:56 <desp> why do you hate trees so much?
14:57:11 <litb> uh, why is the gnu haskell compiler 43 MB big?
14:57:19 <monochrom> Richard Bird's "Introduction to Functional Programming using Haskell"
14:57:21 <sorear> litb: There is no gnu haskell compiler.
14:57:24 <litb> wtf is included in it so that's that big?
14:57:24 <anybody> desp: no. just like reading a real book ;-)
14:57:26 <ddarius> http://www.haskell.org/haskellwiki/Books_and_tutorials
14:57:27 <lambdabot> Title: Books and tutorials - HaskellWiki
14:57:35 <litb> oh, from where is ghc ?
14:57:37 <monochrom> There is a gnu haskell compiler?!
14:57:47 <sorear> litb: Glasgow University in scotland
14:57:52 <anybody> litb: glasgow haskell compiler
14:57:55 <litb> ah, i see :)
14:57:58 <desp> Glorious Haskell Compiler
14:58:12 <SamB_XP_> it actually has nothing to do with Glasgow these days
14:58:13 <litb> is it a good one?
14:58:29 <sorear> litb: the main answer is "a lot of copies of the standard library, GHC doesn't support shared libraries (yet!)"
14:58:33 <ddarius> It never even occurred to me to think of GHC in the same vein as gcc.
14:59:30 <geezusfreeek> GHC starts with G, therefore is must be the best one
14:59:42 <geezusfreeek> s/is/it/
14:59:48 <monochrom> haha
14:59:52 <litb> mabe fsf would call it gch then, if it's from gnu
15:00:13 <SamB_XP_> like gcc stands for GNU Compiler for C?
15:00:16 <litb> G as in God's own ?
15:00:34 <desp> gnu compiler collection
15:00:37 <litb> like gcj is the java compiler
15:00:38 <geezusfreeek> if that was the case, then how come D's GNU compiler is called GDC?
15:00:52 <SamB_XP_> desp: I know. and GNU C Compiler before that.
15:01:00 <litb> geezusfreeek: yes, youre right. hehe
15:01:00 <desp> right
15:01:03 <beelsebob> SamB: no
15:01:08 <beelsebob> GNU compiler connection
15:01:12 <beelsebob> collectino*
15:01:14 <beelsebob> collection*
15:01:18 * desp woops
15:01:19 <beelsebob> GNU spell checker
15:01:22 <beelsebob> :D
15:01:22 * SamB_XP_ was kidding
15:01:36 <litb> you only like recursive acrynoms here?
15:01:39 <desp> missed your sarcasm tag
15:01:58 <sorear> litb: Glasgow Haskell Compiler isn't recursive
15:02:06 <litb> yes
15:02:16 <litb> i mean, because beelsebobhad trouble with GCC
15:02:36 <beelsebob> hehe
15:02:38 <litb> or, maybe still has :)
15:02:53 <beelsebob> there's nothing wrong with GSC :P
15:03:03 <litb> google sommer of code ?
15:03:11 <beelsebob> GNU spell checker
15:03:12 <litb> s/sommer/summer/
15:03:25 <litb> damn, you were faster
15:03:28 <monochrom> Generalized Static Checking.
15:03:35 <litb> </sarcasmn>
15:03:48 <litb> ous, that stupid typos...
15:04:25 <anybody> litb: hm that would be a cool html tag
15:04:35 <anybody> will it be available in html 5.0?
15:04:40 <beelsebob> heh
15:04:48 <beelsebob> never will be such a thing
15:04:53 <litb> <anybody> instead of body would be great
15:04:56 <beelsebob> that I know of
15:05:00 <anybody> <script type="text/sarcasm"> ....
15:05:16 <ddarius> It could be useful for screen readers.
15:05:26 <beelsebob> surely it's a style thing though
15:05:30 <litb> <anybody>hmm, in which one am i currently?</anybody>
15:05:49 <beelsebob> <body style="tone: sarcastic;">
15:05:55 <anybody> haha
15:06:08 <ddarius> Arguably, sarcasm is important semantic information.
15:06:17 <beelsebob> true
15:06:19 <litb> yes, of course
15:06:24 <Tac-Work> Yeah, like anyone ever uses sarcasm.
15:06:28 <beelsebob> rofl
15:06:35 <anybody> hm what compilers do you guys use? ghc?
15:06:56 <glguy> mostly just sbcl
15:06:57 <beelsebob> acording to a french english teacher... there's no such thing as a double positive being a negative in english...
15:07:02 <litb> sbcl?
15:07:06 <beelsebob> response of a student... "yeh, right"
15:07:07 <litb> hmm, is it free?
15:07:21 <glguy> :-p sbcl is a Common Lisp implementation, I use ghc
15:07:28 <monochrom> I use ghc.
15:07:34 <beelsebob> yhc ftw!
15:07:34 <Tac-Work> two wrongs make a right and a double negative is affirmative. It is as simple as -1 * -1
15:07:35 <beelsebob> :P
15:08:18 <litb> ok, is there a haskell major mode?
15:08:22 <monochrom> "I'm in deep do do" -- double positive being a negative? XD
15:08:24 <dozer> Tac-Work, you are so closed world
15:08:28 <sorear> I use ocamlc, gcc, ghc, sometimes when I'm bored uch
15:08:28 <goofyheadedpunk> beelsebob: There's a similar joke told in linguistic circles, incidentally.
15:08:30 <ddarius> For two wrongs, -1 + -1 = -2
15:08:37 <litb> for emacs?
15:08:41 <monochrom> Yes.
15:09:08 <dozer> so two wrongs makes a right is a sign of an underflow error?
15:09:11 <xerox> Tac-Work: prove it :)
15:09:15 <cytzol> litb: haskell.org/haskell-mode/
15:09:36 <Tac-Work> > (-1) * (-1)
15:09:42 <Tac-Work> There's my proof
15:09:44 <lambdabot>  1
15:09:54 <oerjan> uch?
15:10:04 <monochrom> > ((-1) + (-1)) `mod` 2
15:10:06 <lambdabot>  0
15:10:24 <sorear> oerjan: my unlambda compiler project
15:10:30 <oerjan> ooh
15:10:40 <cytzol> > (-1) ^ (-1)
15:10:41 <lambdabot>  Exception: Prelude.^: negative exponent
15:10:44 <cytzol> pfft.
15:10:48 <monochrom> try ^^
15:10:55 <geezusfreeek> Tac-Work, that proof just shows that you doing the wrong wrongly
15:11:04 <cytzol> > (-1) ^^ (-1)
15:11:06 <lambdabot>  -1.0
15:11:19 <cytzol> what's the difference, one works for negative exponents?
15:11:22 <glguy> yeah
15:11:23 <sorear> yeah
15:11:30 <Tac-Work> @type (^^)
15:11:32 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
15:11:35 <sorear> and one requires fractions
15:11:35 <geezusfreeek> cytzol, there are actually _three_ of them
15:11:38 <sorear> @type (^)
15:11:38 <desp> is it possible to selectively turn off warnings?
15:11:40 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
15:11:43 <sorear> desp: -w
15:11:43 <Tac-Work> @type (^_^)v
15:11:45 <lambdabot> parse error on input `)'
15:11:48 <desp> specifically, I am really sick of "Warning: Defaulting the following constraint(s) to type `Integer'"
15:11:50 <Tac-Work> bastard bot
15:11:57 <sorear> desp: -Wno-defaulting?
15:12:05 <glguy> desp: default(Int) maybe?
15:12:06 <geezusfreeek> desp, just annotate the value with ::Integer
15:12:12 <geezusfreeek> or that
15:12:12 <desp> geezusfreeek: I refuse to
15:12:14 <sorear> @type (?^-^?)
15:12:16 <lambdabot> Not in scope: `?^-^?'
15:12:25 <litb> .hs is the default extension for haskell?
15:12:28 <cytzol> @type (^^^)
15:12:29 <sorear> yeah
15:12:29 <monochrom> Yes.
15:12:30 <lambdabot> Not in scope: `^^^'
15:12:33 <cytzol> aw
15:12:41 <monochrom> ^, ^^, **
15:12:41 <geezusfreeek> litb, or .lhs if you use literate haskell
15:12:52 <sorear> You can't have implicit parameters as varsyms?  that sucks
15:12:53 <Tac-Work> @let (^__^) v = "love and peace"
15:12:54 <lambdabot>  Parse error
15:12:55 <sorear> :)
15:13:06 <sorear> Tac-Work: _ is not a legal varsym character
15:13:11 <Tac-Work> yeah, I figured
15:13:19 <glguy> ?let a ^_^ b = a ++ " and " ++ b ++ " are happy" in "this" ^_^ "that" -- _ might be letter only though
15:13:19 <lambdabot>  Parse error in pattern
15:13:21 <desp> hrm
15:13:25 <Tac-Work> @let (^.^) v = "love and peace"
15:13:29 <lambdabot> Defined.
15:13:36 <oerjan> @type ?(??)
15:13:38 <lambdabot> parse error on input `?'
15:13:40 <Tac-Work> ^.^ 'a'
15:13:43 <glguy> > (^.^ 1)
15:13:44 <lambdabot>  Couldn't match expected type `t1 -> t'
15:13:50 <glguy> > (1 ^.^)
15:13:51 <lambdabot>  "love and peace"
15:13:54 <Tac-Work> hehe
15:14:06 <sorear> @quote kore
15:14:07 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
15:14:31 <sorear> @quote the
15:14:31 <lambdabot> qwe1234 says: laziness is TEH SUCK, by the way. there's a reason we got rid of it after writing the first fortran compiler.
15:14:50 <glguy> wow, qwe1234 helped write the first fortran compiler?
15:14:58 <glguy> he must be super-leet, old school hardcore
15:15:00 <monochrom> No.
15:15:10 <glguy> oh , that was like the ESR we?
15:15:22 <desp> -fwarn-type-defaults
15:15:33 <glguy> "I'm with those guys"
15:15:41 <desp> actually, -fno-warn-type-defaults
15:15:42 <monochrom> yeah
15:15:44 <SamB_XP_> hey. I use a similar we sometimes!
15:15:45 <desp> woop
15:15:53 <desp> sorear++
15:16:54 <hpaste>  tyoc pasted "r.sh run xmonad" at http://hpaste.org/2101
15:25:42 <ndm> @seen dcoutts
15:25:43 <lambdabot> I saw dcoutts leaving #haskell, #gentoo-haskell and #ghc 38m 5s ago, and .
15:25:44 <ndm> @seen dcoutts_
15:25:44 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts_ last spoke.
15:29:01 <litb> @seen litb
15:29:02 <lambdabot> You are in #haskell. I last heard you speak just now.
15:31:38 <Tac-Work> @seen litb
15:31:38 <lambdabot> litb is in #haskell. I last heard litb speak 2m 36s ago.
15:34:30 <dibblego> can all boolean expressions be reduced to conjunctive normal form?
15:34:50 <sorear> Yes.
15:35:04 <dibblego> great thanks! do you know anywhere I can read about this?
15:35:18 <dibblego> an explanation of why and how for example
15:35:41 <desp> dibblego: an introductory logic book?
15:35:56 <oerjan> @go conjunctive normal form
15:35:57 <dibblego> desp, I have plenty of those and I have never seen that fact
15:35:57 <lambdabot> http://en.wikipedia.org/wiki/Conjunctive_normal_form
15:35:57 <lambdabot> Title: Conjunctive normal form - Wikipedia, the free encyclopedia
15:36:06 <matthew-_> does the gtk hs stuff work well under windows?
15:36:21 <sorear> dibblego: Do you understand how any expression using +, *, - can be written in polynomial form?
15:36:35 <dibblego> sorear, yes
15:36:39 <dibblego> sorear, and I now see your point, thanks
15:42:08 <desp> @type (+ 1)
15:42:10 <lambdabot> forall a. (Num a) => a -> a
15:42:13 <desp> @type (- 1)
15:42:15 <lambdabot> forall a. (Num a) => a
15:42:27 <desp> any way to get a real (- 1) function?
15:42:41 <oerjan> @type (subtract 1)
15:42:43 <lambdabot> forall t. (Num t) => t -> t
15:43:07 <ddarius> subtract was added just for this
15:43:20 <desp> ugly.
15:44:31 <ddarius> Haskellers tend to prefer this to the alternative.
15:45:49 <desp> you're right, I'm just an SMLer in disguise
15:46:19 <desp> s/an/a/
15:47:09 <ndm> i would make 0-1 the syntax for writing "-1"
15:47:14 <xerox> > (flip (-) 1)
15:47:16 <lambdabot>  <Integer -> Integer>
15:47:25 <fadec> What does instance Show a => Show (M a) where
15:47:30 <desp> @type ((-) 1)
15:47:32 <lambdabot> forall t. (Num t) => t -> t
15:47:36 <_magus_> I'm trying to get my head around the FFI, in particular how to deal with C structs in Haskell (http://hpaste.org/2102#a1)... I'm having a hard time finding documentation/examples for this so any help is appreciated
15:48:02 <sorear> fadec: If a is an instance of Show, M a is too
15:48:27 <desp> _magus_: check out http://darcs.haskell.org/packages/network/Network/Socket.hsc
15:48:35 <ndm> fadec: here is an instance of Show for (M a), but it requires a to already have an instance of Show
15:48:42 <desp> _magus_: look for the definitions of packBits, unpackBits,  aiFlagMapping, and AddrInfoFlags
15:48:55 <_magus_> thanks desp, will do
15:48:57 <ddarius> (+(-1))
15:49:04 <xerox> fadec: it means that given a type `a' which is an instance of Show (i.e. implements show :: a -> String), then it is also possible to feed `show' values of type `M a'.
15:49:07 <litb> hm, the haskell emacs mode doesn'T indent my code right
15:49:26 <desp> _magus_: note this uses hsc2hs
15:49:38 <xerox> _magus_: there's also c2hs, which has very good documentation.
15:49:40 <_magus_> desp, yes, that's what I was trying to use as well
15:50:23 <fadec> I see, instance Show (M a) where ...  gives this "Could not deduce (Show a) from the context (Show (M a))
15:50:35 <ddarius> Why do people think we should have a Java parser in Haskell?
15:50:44 <_magus_> xerox, yes c2hs has good documentation but it lacks in examples, and the {#get } {#set } parts aren't very verbose at all, plus that the generated code seems to lack some things I was expecting
15:51:18 <xerox> _magus_: It's been a while since I used it, but it worked for me, and it was really nice to write the bindings in.
15:52:00 <ndm> ddarius: it makes sense, Haskell is the ideal language
15:52:37 <anybody_> how can i quit ghci?
15:52:45 <fadec> ctrl-D
15:52:47 <geezusfreeek> anybody_, :quit
15:53:02 <anybody_> geezusfreeek: thx
15:53:03 <desp> no one really quits
15:53:20 <_magus_> xerox, my plan was to try to write it in both hsc2hs and c2hs and compare... it's just a small example, just for "evaluation"
15:53:25 <geezusfreeek> anybody_, ctrl-D also works, as fadec said
15:54:23 <xerox> _magus_: actually I remember c2hs interface to be very powerful, hm..
15:55:26 * glguy started irssi in screen this time... no more join floods
15:55:58 <sorear> gkr: what causes them normally?
15:57:11 <Winterstream> nighty night everyone
15:57:24 * Winterstream is going to monad land
15:57:56 <anybody_> is anyone using ghc on mac os x
15:57:57 <anybody_> ?
15:58:13 <xerox> yes?
15:58:17 <anybody_> it has troubles finding the GMP.framework
15:58:40 <bdash> anybody_: did you put GMP.framework in /Library/Frameworks?
15:59:04 <anybody_> bdash: no. i put it into ~/Library/Frameworks
15:59:18 <_magus_> I'm having problems with Ptr, my ghc reports that "Not in scope: data constructor `Ptr'"
15:59:22 <sorear> Why does osx have so much trouble with GMP?
15:59:42 <bdash> sorear: what trouble does it have?..
15:59:44 <sorear> _magus_: import Foreign.Ptr
15:59:48 <anybody_> bdash: do i have to set a env variable for dyld?
16:00:02 <_magus_> sorear, yes, I thought that would do it as well, but apparently not :(
16:00:18 <anybody_> bdash: or even fix the load commands inside the GMP library?
16:00:24 <sorear> bdash: I don't know, but everyone who uses OSX here seems to complain about it
16:00:53 <sorear> _magus_: Oh, sorry, misread.  You want GHC.Exts (or GHC.Base maybe?) for the *data* constructor Ptr
16:01:01 <hpaste>  _magus_ annotated "FFI and structs" with "Ptr problems" at http://hpaste.org/2102#a2
16:01:29 <bdash> anybody_: whenever I've used it I've simply dropped it in /Library/Frameworks, I would expect ~/Library/Frameworks to work similarly but I'm not sure if that's the case
16:01:47 <sorear> Prelude GHC.Exts> :t Ptr
16:01:47 <sorear> Ptr :: Addr# -> Ptr a
16:02:46 * monochrom finishes reading Oleg's generic zipper stuff. A new age has begun.
16:02:49 <sorear> _magus_: Why do you want to know the type of the data constructor?  It's rather deliberately not exported from the standard modules, you should be treating the Ptr type as abstract if possible
16:04:13 <_magus_> sorear, well, how am I supposed to get a (Bar) into function that takes (Ptr Bar) (FFI) otherwise?
16:04:18 <desp> hrm
16:04:27 <anybody_> bdash: well in the global library it works. but i hate putting all the stuff in there
16:04:32 <desp> any fellow projecteulerites?
16:05:21 <sorear> _magus_: with?
16:05:25 <sorear> :t with
16:05:27 <lambdabot> Not in scope: `with'
16:05:32 <bdash> anybody_: that's fair enough
16:05:33 <sorear> :t Foreign.with
16:05:35 <lambdabot> forall a b. (Foreign.Storable.Storable a) => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
16:06:17 * shapr cheers for Haskell!
16:06:18 <_magus_> sorear, yes indeed
16:06:52 <xerox> @yow !
16:06:52 <lambdabot> Used staples are good with SOY SAUCE!
16:07:53 <olathe> O-o
16:08:15 <bdash> anybody_: I've just downloaded the binaries for GHC 6.6.1 and installed them on a clean 10.4 system, and they work fine with GMP.framework inside ~/Library/Frameworks
16:09:53 <anybody_> bdash: hm weird. doesn't work on my old g5. but on the macbook it does. maybe its because the system here has been updated all the way since 10.0
16:10:27 <anybody_> anyone using vim to edit haskell source?
16:10:33 <bdash> anybody_: it may be a difference in linker settings used when building the intel binary vs powerpc
16:10:46 <glguy> anybody_: probably about half do
16:10:58 <anybody_> i saw the indent helper script but i don't know how i can use it
16:11:23 <glguy> anybody_: I doubt that most vim users use an indent script for vim (could be wrong)
16:11:44 <anybody_> glguy: well indenting is not working properly
16:11:58 <anybody_> glguy: so what do you do?
16:12:14 <glguy> anybody_: vim guesses, is often correct, and other wise I just space in
16:12:27 <sorear> I use :set ai for guessing
16:12:44 * glguy uses ai also
16:12:49 <glguy> that is 'autoindent'
16:14:21 <glguy> I also always use expandtab and list lcs=tab:>-,trail:.,extends:>
16:15:04 <anybody_> glguy: expandtab?
16:15:05 <sorear> list lcs?  never heard of that one
16:15:07 <rehges> wow, someone else but me who uses "set list" :-)
16:15:10 <anybody_> neither hav i
16:15:21 <glguy> it is awesome :) try it out
16:15:38 <anybody_> what does it do?
16:15:45 <glguy> trailing spaces turn to red .s
16:15:52 <glguy> tabs to red >------
16:15:52 <rehges> lcs = listchars
16:16:27 <glguy> (well, red in my default theme)
16:16:29 <rehges> i also do   highlight SpecialKey ctermfg=red cterm=NONE   to make it look a bit better (on my terminals, anyway)
16:16:52 <anybody_> hm i have no tabs. it converts tabs to spaces
16:17:01 <glguy> anybody_: but you can open a file that does
16:17:02 <anybody_> but when i have tabs they look that way
16:17:08 <anybody_> but blue
16:17:17 <glguy> otherwise you don't find out until you darcs record
16:17:21 <rehges> so do that highlight line
16:17:23 <glguy> and then you have to go back and fix it
16:17:49 <glguy> rehges: you need to define SpecialKey first?
16:17:54 <sorear> glguy++
16:18:04 <glguy> hurray, I'm back on the board!
16:18:04 <glguy> ;)
16:18:05 <rehges> glguy: nope
16:18:17 <sorear> glguy: My tabs are blue :/
16:18:18 <rehges> glguy: it's one of the default classes
16:18:43 <glguy> rehges: ah, I accidentally added set before that line
16:18:57 <rehges> heh
16:19:07 <rehges> happens to the best :-)
16:19:21 <glguy> :( it doesn't seem to be turning those marks red
16:19:49 <rehges> glguy: erm, are you using vim or 1970's vi?
16:19:55 <glguy> rehges: gvim
16:20:03 <glguy> 7.1
16:20:19 <rehges> it might need gterm instead of cterm -- i dunno, read the docs, i never use gvim
16:20:24 <glguy> oh
16:20:25 <glguy> ok
16:20:44 <glguy> anybody_: fyi, to add a tab with expand tabs easily: ^K <tab> <tab>
16:20:49 <glguy> there might be better ways though
16:21:11 <rehges> ^V<tab>
16:21:21 <rehges> you can add any char that way
16:21:25 * glguy discovered :set paste
16:21:28 <glguy> really late in the game
16:21:38 <oerjan> glguy: ouch
16:22:05 <glguy> yeah, that was endlessly frustrating
16:22:06 <rehges> glguy: s/cterm/gui/g  on that "highlight" line, and it should work for you
16:23:29 <sorear> glguy: what colorscheme do you use?
16:23:37 <glguy> in gvim, I use evening
16:23:43 <glguy> because it makes strings really stand out
16:23:45 <glguy> in particular
16:23:58 <glguy> the background is dark gray, but strings background is black
16:24:09 <glguy> in normal vim, I use the default
16:33:37 <dfranke> Are MonadReader and MonadWriter documented anywhere other than the original MPJ paper?
16:34:27 <SamB> um. documented in what way?
16:34:39 <sorear> @docs Control.Monad.Reader
16:34:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
16:34:51 <sorear> dfranke: good enough?
16:34:56 <sorear> @docs Control.Monad.Writer
16:34:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html
16:35:08 <dfranke> sorear: there are no haddock comments on that, and I can't make sense of it just by looking at the types.
16:35:21 <sorear> @source Control.Monad.Reader
16:35:21 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
16:35:29 <SamB> huh. there seem to be haddock comments in the source!
16:36:24 <sorear> SamB: notice that the library docs haven't been updated since before pretty/directory/old-time were split out of base!
16:36:36 <SamB> sorear: hmm.
16:36:48 <SamB> @google mtl hackage
16:36:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
16:37:16 <SamB> why isn't the latest mtl on hackage?
16:37:51 <SamB> the latest being 1.0.1
16:39:02 <glguy> dfranke: Reader is the easy one, it provides an instance of MonadReader which allows you to ask for the current environment (which you pass when you call runReader) and local, which allows you to run a computation in a locally modified environment
16:39:51 * SamB got comfy with stuff by reading the sources
16:40:22 <SamB> there was a debian package of GHC's library sources
16:40:26 <SamB> for reading
16:40:50 * glguy has been giving Debian "lenny" a shot lately 
16:40:56 <SamB> (some were gzipped and all were in /doc, iirc)
16:41:20 <SamB> but these days you can just use the "Source Code" link in the library documentation
16:41:46 <SamB> not quite as convenient though, I guess, to read it in a web browser...
16:42:11 <samreid> it is when you're reading some vague docs
16:42:33 <dibblego> data SearchCondition = Term Bool | SearchCondition :||: (Term Bool)
16:42:34 <SamB> I meant it's not as convenient as reading it in emacs
16:42:37 <dibblego> what's the ":||:"?
16:42:42 <SamB> or whatever editor you use
16:42:47 <glguy> infix data constructor
16:42:49 <SamB> dibblego: a data constructor
16:42:50 <glguy> dibblego: ^^
16:42:51 <syntaxfree> dibblego: isn't it an infix constructor?
16:43:07 <glguy> dibblego: any operator starting with : is an infix data constructor
16:43:07 <dibblego> which part is which?
16:43:18 <dibblego> but : doesn't appear after |
16:43:21 <syntaxfree> data Line a b = a :-> b
16:43:26 <syntaxfree> get it?
16:43:28 <dibblego> oh
16:43:31 * dibblego bangs /me
16:43:36 <SamB> dibblego: it's, um, infix
16:43:41 <syntaxfree> infix data constructors start with a :
16:43:43 * glguy wonders if there is a word for what dibblego just did
16:43:47 <SamB> so it's in the middle of the thing
16:43:52 <dibblego> yes I know, I was foncused by the fact that the constructor name contained |
16:44:08 <SamB> ah
16:44:09 <dibblego> glguy, Sam Harris tries to explain it
16:44:19 <syntaxfree> foncusion by X = "confusion by focus on X"?
16:48:07 <ndm> sorear: how is that different from import qualified Prelude as $Prelude
16:48:35 <sorear> ndm: you don't need to add incompatible new symbols to Prelude
16:49:00 <sorear> ndm: also, I misunderstood what you said as import qualified Prelude as Prelude
16:49:08 <ndm> sorear: ok, thats an advantage i hadn't thought of - i think the Yhc one exports foldl_, which is nothing like foldl...
16:49:33 <ndm> sorear: your proposal makes perfect sense, and is really the only sensible way to go
16:49:52 <ndm> sorear: we now have Yhc.Core -> Yhc.ByteCode compilation, which I guess is us writing the Qhc back end for you :)
16:50:20 <Shine> any idea how to write this better: "(circles ((circles ((circles backgroundImage) !! 0)) !! 1) !! 2)" ? circles is a list of functions, backgroundImage is the start
16:50:27 <sorear> Is the yhc back end a mess, or just the frontend?
16:50:49 <SamB> sorear: considering they just added this I hope it's not ;-)
16:50:53 <ndm> sorear: as of yesterday, a mess, as of today, modular :)
16:51:06 <ndm> it used to be a mess from PosLambda to ByteCode, then fine after that
16:51:17 <anybody_> glguy: still here?
16:51:18 <ndm> now we go direct from Core to ByteCode, so its much nicer
16:51:30 <sorear> any hope of killing PosLambda?
16:51:42 <ndm> this is step one of the process
16:51:43 <SamB> dos Pos stand for "piece of shit"?
16:51:48 <anybody_> glguy: i found a nice little vim script which seems to do proper indentation
16:51:57 <ndm> SamB, position information, as it happens
16:52:07 <SamB> ndm: hmm, that did seem more probable
16:52:07 <ndm> why position information is needed in Core is still a mystery
16:52:35 <sorear> ndm: does anyone know what format goes into the type-checker?
16:52:38 <anybody_> glguy: here it is http://www.vim.org/scripts/script.php?script_id=1968. just put it into runtimepath/indent/
16:52:40 <lambdabot> Title: indent/haskell.vim - Haskell indent file : vim online
16:52:48 <ndm> sorear: not the slightest idea, malcolm might have a guess
16:53:16 <anybody_> ?what was that?
16:53:17 <lambdabot> I know nothing about was.
16:53:20 <SamB> has anything ever come out of the typechecker alive }:->?
16:53:29 <anybody_> ?girls
16:53:29 <lambdabot> LOL
16:53:35 <anybody_> ?pr0n
16:53:35 <lambdabot>  Parse error
16:53:50 <SamB> @vixen do you have any pr0n
16:53:50 <lambdabot> i do occassionally, i guess
16:54:01 <SamB> @vixen pictures?
16:54:01 <lambdabot> i'll hafta plead the fifth on that one.
16:59:21 <glguy> ?help girls
16:59:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:59:31 <SamB> ndm: I'm going to put the tests for commonly-installed libraries like QuickCheck and Binary in their own files, okay?
16:59:33 <glguy> ?losers
16:59:33 <lambdabot> Maximum users seen in #haskell: 352, currently: 327 (92.9%), active: 11 (3.4%)
16:59:57 <sorear> glguy: ?girl19
17:03:19 <hpaste>  Shine pasted "nested functions" at http://hpaste.org/2103
17:03:23 <Shine> olympicRings2 works. Now I've tried to rewrite it as olympicRings1, but this says "Couldn't match expected type `[t -> t]' against inferred type `t2 -> [(t1, t1) -> Pixel]'"
17:04:23 <ndm> SamB, makes sense - is there any way to detect which libraries are installed, and therefore which tests should be expected to work?
17:04:34 <mauke> :t foldr (.) id
17:04:36 <lambdabot> forall a. [a -> a] -> a -> a
17:04:53 <SamB> ndm: well, I wasn't planning to have the stuff loaded automatically...
17:05:14 <SamB> but it would be nice to try that when something changes
17:05:44 <mauke> Shine: that's probably because circles is a function, not a list of functions
17:05:51 <SamB> without having to have a dozen other obscure libraries installed, even
17:06:10 <ndm> SamB: it would be great if runhaskell Setup test could invoke all the tests for which libraries were installed, automatically
17:06:19 <ndm> i.e. not on all machines, but if it detects the library, it checks
17:06:20 <SamB> ndm: it would be great
17:06:29 <ndm> i guess it requires more work though
17:07:38 <Shine> mauke: but it returns a list, if I provide an argument, which I can access with "!!"
17:07:51 <SamB> hmm. isn't there some way to make derive act as a preprocessor?
17:08:20 <sorear> yes
17:08:30 * SamB is thinking of what would happen if he put some quickcheck properties in these test files...
17:08:32 <SamB> sorear: how?
17:08:35 <Shine> "circles :: t -> [(Double, Double) -> Pixel]"
17:08:48 <sorear> SamB: ./derive -a MyFile.hs  ,iirc
17:08:55 <mauke> Shine: irrelevant
17:09:05 <mauke> Shine: evalFunctions takes a list
17:09:07 <SamB> preprocessors DO NOT modify their input file
17:09:10 <mauke> circles is not a list
17:10:04 <Shine> mauke: ok, I think I need some parantheses, I'll try to rewrite it
17:10:53 <mauke> also, I think evalFunctions = foldr (.) id
17:12:53 <dibblego> > intersperse ',' "abc"
17:12:55 <lambdabot>  "a,b,c"
17:13:50 <EvilTerran> @src intersperse
17:13:51 <lambdabot> intersperse _   []     = []
17:13:51 <lambdabot> intersperse _   [x]    = [x]
17:13:51 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
17:14:04 <dons> ?users
17:14:05 <lambdabot> Maximum users seen in #haskell: 352, currently: 327 (92.9%), active: 14 (4.3%)
17:14:24 <SamB> ndm: hmm. so don't we want the "diff" check on Small.hs's output?
17:16:19 <SamB>  instance Functor Id
17:16:19 <SamB> -    where fmap fun (Id a) = Id (fun a)
17:16:19 <SamB> +    where fmap f (Id a1) = Id (f a1)
17:18:35 <SamB> ndm: hmm???
17:19:14 <ihope> If if, then and else are on separate lines, can they all be indented to the same amount?
17:19:25 <MarcWeber> @seen dcoutts__
17:19:26 <lambdabot> dcoutts__ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I don't know when dcoutts__ last spoke.
17:19:26 <ihope> Heck, can I indent if farther than the others? :-)
17:19:29 <mauke> you mean in a do block?
17:19:34 <MarcWeber> @seen dcoutts
17:19:35 <lambdabot> I saw dcoutts leaving #haskell, #gentoo-haskell and #ghc 2h 31m 57s ago, and .
17:19:35 <ihope> Yes, in a do block.
17:19:44 <mauke> probably not
17:20:06 <ihope> Hmm, lambdabot seems slightly broken.
17:20:34 <sorear> ihope: nah, just young
17:21:37 <poh> I am new to haskell and attempting to use the debugger in ghci, but when I try to set a breakpoint, I get "unknown command ':break'"
17:21:57 <poh> how do I use the debugging in ghci (6.6.1)?
17:22:02 <ihope> It has debugging?
17:22:13 <ndm> SamB, derive outputs to stdout by default, but you can pass options to make it go elsewhere
17:22:26 <poh> according to http://www.haskell.org/ghc/dist/current/docs/users_guide/ghci-debugger.html
17:22:27 <lambdabot> Title: 3.5. The GHCi Debugger, http://tinyurl.com/2nxab2
17:22:30 <ndm> SamB, why don't we want to diff? would you rather it all encoded in quickcheck?
17:22:42 <ndm> ihope, poh: Only the next version will have the debugger
17:22:50 <ndm> 6.8, which is unreleased
17:23:03 <SamB> ndm: I was thinking we did
17:23:21 <poh> ndmm: oh, well that would explain the issue
17:23:22 <notpalomer> hello, I'm trying to apply StateT to (Maybe [a]) to get a nondeterministic stateful monad; I can't get my head around the type system though
17:23:33 <SamB> but you don't seem to do it
17:23:35 <notpalomer> I need monadplus
17:23:51 <SamB> and someone changed what output we get without updating the expected output
17:24:00 <ihope> notpalomer: you want to combine StateT, Maybe and []?
17:24:08 <notpalomer> ihope, yup
17:24:15 <ihope> I think that'd be StateT (MaybeT []) a or some such.
17:24:24 <notpalomer> maybe I need StateT, NonDetT and Maybe
17:24:36 <ihope> Then there's what I believe is called ListT.
17:24:41 <ihope> Which, obviously, isn't []T.
17:24:49 <glguy> [] does a fine job of representing failure on its own..
17:24:54 <glguy> maybet might not be needed in that case
17:24:54 <ihope> Does callCC (\cont -> cont foo) essentially replace the current action with foo?
17:25:09 <SamB> ndm: and, you know how DrIFT can take as input your source code and produce as output a file containing your code with the derived instances?
17:25:11 <glguy> ihope: it replaces everything out to the callCC
17:25:19 <notpalomer> oh, you're right
17:25:25 <SamB> ndm: derive should be made able to do that too...
17:25:39 <ihope> So callCC (\cont -> cont doSomething) >> doSomethingElse does both Something and SomethingElse?
17:25:43 <sorear> poh: /current/ refers to the development branch, replace "current" with "stable" to see the 6.6.1 docs
17:25:51 <SamB> preferably in a GHC and Cabal friendly way, if that's possible
17:25:53 <ihope> Hmm...
17:25:54 <notpalomer> yeah, so I want to combine List and StateT (or is it ListT and State?)
17:26:07 <notpalomer> is there a difference?
17:26:10 <poh> sorear: thanks
17:26:11 <ihope> notpalomer: yes, there is.
17:26:17 <mauke> notpalomer: do you want multiple states, one for each world?
17:26:20 <sorear> ihope: no, it does something else.  the callCC returns doSomething as a value
17:26:22 <notpalomer> mauke, yup
17:26:22 <mauke> or do you want a single shared state?
17:26:29 <SamB> StateT [] then
17:26:48 <ihope> sorear: doesn't the continuation take an action?
17:26:49 <SamB> well. add your state between the StateT and the []
17:27:01 <ndm> SamB, Derive can do that
17:27:04 <SamB> ndm: how?
17:27:04 <sorear> ihope: no, it takes a value to return
17:27:08 <sorear> :t callCC
17:27:08 <glguy> notpalomer: changing your nick doesn't make you not banned
17:27:10 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
17:27:26 <SamB> ndm: did I mention that it should not be outputting to the input file?
17:27:28 <sorear> ihope: so a -> m b is the continuation.
17:27:29 <notpalomer> glguy, can't you give a guy a chance? I'm not even being sneaky about it!
17:27:42 <ndm> SamB, yes - {-# OPTIONS_DERIVE --output=Binary.hs --module=Colour.Binary --import #-}
17:27:44 <SamB> (in the mode of operation of which I speak)
17:27:45 <notpalomer> if anyone complains, ban me, but give me a chance!
17:28:08 <SamB> ndm: how does that include the code you wrote?
17:28:28 <ndm> SamB, oh, you mean an output with teh code you wrote
17:28:40 <ndm> SamB, we have --append which overwrites the input file
17:28:43 <ihope> @type Cont const
17:28:45 <lambdabot>     Occurs check: cannot construct the infinite type: r = b -> a -> r
17:28:46 <lambdabot>     Probable cause: `const' is applied to too few arguments
17:28:59 <ihope> Well, that's certainly not what I want.
17:29:02 <notpalomer> wait, say I have a :: [r] and b :: [r], what operation chooses a iff a succeeds (is a list of size 1 or greater) and b otherwise?
17:29:06 <ndm> perhaps having --append and --output should result in appending to the output
17:29:11 <ndm> should be an easy enough change
17:29:40 <sorear> notpalomer: 'case a of [] -> b ; _ -> a'
17:29:48 <ihope> Can Cont (const x) be implemented using callCC?
17:29:50 <sorear> notpalomer: I don't think it's a standard function
17:30:02 <notpalomer> with Maybe [], it's mplus !
17:30:11 <notpalomer> (that's why I wanted Maybe [])
17:30:17 <mauke> no, it isn't
17:30:18 <sorear> ihope: No.
17:30:24 <notpalomer> oh
17:30:27 <mauke> it'll still prefer Just [] over Just [1,2,3]
17:31:12 <sorear> ihope: Any action constructed using callCC and the monad operations is parametrically polymorphic in the return type, a property which Cont (const x) does not satisfy in general (consider x = 2)
17:31:16 <notpalomer> but deriving would make mzero as Nothing
17:31:25 <notpalomer> so only using monad operations, I'll be safe
17:32:27 <SamB> ndm: so what does --append usually do?
17:32:28 <ihope> Ah.
17:33:19 <notpalomer> Unless I define a new List monad
17:36:37 <Cale> notpalomer: Just define a function on lists by:
17:36:42 <Cale> orElse [] ys = ys
17:36:49 <anybody_> hm. i'm just doing a basic haskell example and it does not work: let r = 25 :: Num a => a
17:36:51 <Cale> orElse xs ys = xs
17:36:52 <anybody_> r*1.0
17:36:54 <anybody_> does not work
17:37:04 <mauke> how does it not work?
17:37:14 <Cale> anybody_: this is at the GHCi prompt?
17:37:33 <anybody_> Cale: yes
17:37:47 <dons> $ ghci
17:37:47 <dons> Prelude> let r = 25 :: Num a => a
17:37:47 <dons> Prelude> r
17:37:47 <dons> 25
17:37:47 <dons> Prelude> :t r
17:37:49 <dons> r :: Integer
17:37:51 <Cale> ah, wow, it's deciding to default it
17:37:58 <mauke> makes sense
17:38:00 <Cale> ugh.
17:38:05 <EvilTerran> even with the explicit typing?
17:38:09 <mauke> it's monomorphed in the binding to r
17:38:11 <dons> Prelude> :set -fno-monomorphism-restriction
17:38:12 <dons> Prelude> let r = 25
17:38:12 <dons> Prelude> :t r
17:38:12 <dons> r :: (Num t) => t
17:38:16 <mauke> the type annotation applies to 25
17:38:20 <EvilTerran> doh.
17:38:27 <mauke> let r :: Num a => a; r = 25
17:38:34 <Cale> The MR isn't supposed to apply when you give explicit type signatures.
17:38:41 <dons> Prelude> let r :: Num a => a; r = 25
17:38:41 <dons> Prelude> :t r
17:38:41 <dons> r :: (Num a) => a
17:38:51 <EvilTerran> Prelude> let r :: Num a => a = 25
17:38:51 <EvilTerran> Prelude> :t r
17:38:51 <EvilTerran> r :: forall a. (Num a) => a
17:38:52 <dons> is what you mean. (we all hate the MR :)
17:38:55 <dolio> That's not giving a type signature to r, though. Just to 25.
17:39:08 <anybody_> MR?
17:39:17 <EvilTerran> monomorphism restriction.
17:39:17 <anybody_> monomorphism restriction?
17:39:20 <anybody_> ah
17:39:22 <dons> top level bindings get a monomorphic type
17:39:34 <anybody_> hm. so the wikibook is wrong then
17:39:34 <dons> cafs, actually
17:39:36 <ndm> SamB, append to the bottom of the current file
17:39:43 <Cale> anybody_: When you have a pattern binding without an explicit type signature, its type must be monomorphic.
17:39:45 <SamB> ndm: hmm. does it actually work?
17:39:47 <EvilTerran> it's only toplevel bindings with no parameters, right?
17:40:01 <Cale> I don't think it's just toplevel bindings
17:40:11 <Cale> It's pattern bindings anywhere
17:40:17 <dons> yeah
17:40:21 <SamB> ndm: hmm. yes, it does.
17:40:32 <ndm> SamB, yes, it also removes anything that was previously appended as well
17:40:41 <ndm> using a checksum, to check you haven't modified it
17:41:03 <ndm> anyway, i'm off to bed now, any further questions/patches just email me
17:41:03 <Cale> anybody_: Sorry about the H'98 team's mistakes :)
17:41:05 <ndm> bye!
17:41:10 <dons> its a bit unusual to require a polymorphic constant though.
17:41:12 <anybody_> Cale: np
17:41:18 <dons> you don't see them in practice very often (ever?)
17:41:24 <Cale> dons: that's true
17:41:31 <dons> except in tiny code fragments to impress other language crowds
17:41:47 <SamB> ndm: it seems to make unwarrented assumptions about the input file
17:41:54 <dons> "hey look, its a float, ... no! its an int! no.. its a Rational!"
17:42:02 <Cale> Actually, I have had serious problems caused by the MR which cost me upwards of an hour trying to sort out what was going on.
17:42:19 <SamB> ndm: like, it seems to assume that the input file uses the layout rule for it's module
17:42:24 <dons> would monad comprehensions have helped?
17:42:27 <SamB> and no indentation
17:42:29 <Cale> Because it's not really just plain constants, but functions as well.
17:42:58 <Cale> at one point, I tried to define  forM = flip mapM, and naively didn't give it a type signature, then used it in some ST code.
17:43:25 <Cale> That will result in the 's' parameter in the ST code getting defaulted to ()
17:43:28 <EvilTerran> oopsie
17:43:30 <dons> yeah, i've had issues with the same pointfree style with implicit params
17:43:43 <dons> and other typing thingies, breaking down. all fixed when you put the args in
17:44:02 <dons> stupid  MR gremlins
17:45:25 <Cale> Now I just set -fno-monomorphism-restriction all the time.
17:46:10 <Cale> H'98 compatibility should be an option, rather than the default, at this point.
17:46:53 <mauke> does anyone here understand ML's value restriction?
17:47:07 <ddarius> Moral of the story, provide top-level types like good practice suggests.
17:49:05 <dolio> mauke: I'm pretty hazy on it, but the crux is that it protects against the same hole that allows unsafePerformIO + IORef to defeat the type system.
17:49:26 <mauke> sure, but why isn't it limited to 'a ref?
17:49:27 <dolio> mauke: Because it prevents polymorphic references.
17:49:53 <sorear> ddarius: Not good enough
17:50:01 <dolio> I don't know. Maybe it's possible to write code that doesn't have that type, but uses it internally?
17:50:21 <notpalomer> Cale, (in reference to your orElse comment) but my underlying monad is StateT s [] a, not [a]
17:50:39 <mauke> if ref doesn't appear in the type, I can write it in a ref-free language
17:50:41 <notpalomer> Cale, which is why I wanted to use StateT s CustomList a
17:50:45 <Cale> notpalomer: lift
17:50:47 <mauke> which doesn't need the value restriction
17:51:01 <Cale> hmm
17:51:25 <sorear> mauke: Because it might eventually contain a ref once you unroll enough type synonyms.
17:52:00 <sorear> mauke: Also, they used to have a more complicated rule in SML'92 (iirc), it was made simpler but more restrictive in SML'97
17:53:00 <mauke> if ref had the type 'a -> ('a ref -> ()) -> (), would it still need the VR?
17:53:10 <sorear> ddarius: My reading of the Haskell Report is that a variable bound by non-simple pattern binding cannot be generalized, period, and if you give a polymorphic signature, it will just cause a type error.
17:53:22 <Cale> orElse (StateT f) (StateT g) = StateT (\s -> f s `orElse` g s)
17:53:26 <sorear> mauke: unit :)
17:53:31 <Cale> where the inner orElse is the one for lists.
17:53:43 <mauke> sorear: yeah, that :-)
17:53:51 <Cale> (Probably best to use a typeclass)
17:53:57 <ddarius> sorear: That's fine.  It would've caught Cale's case though.
17:54:11 <mauke> () => unit and (a, b) => 'a * 'b get me every time
17:54:38 <sorear> What I don't get is why they use * but not + and 1 and 0.
17:54:59 <notpalomer> Cale, that looks recursive
17:55:14 <ddarius> mauke: It's not your fault that SML's syntax is ugly as sin.
17:55:22 <dolio> What do they use for sum?
17:55:29 <Cale> class MonadOrElse m where
17:55:35 <mauke> |
17:55:38 <Cale>    orElse :: m a -> m a -> m a
17:55:53 <Cale> er,  class (MonadZero m) => MonadOrElse m where ...
17:56:30 <Cale> instance MonadOrElse [] where orElse [] ys = ys; orElse xs _ = xs
17:56:47 <Cale> instance MonadOrElse m => MonadOrElse (StateT s m) where
17:56:55 <Cale>      orElse (StateT f) (StateT g) = StateT (\s -> f s `orElse` g s)
17:57:20 <chessguy> 'evening
17:58:38 <notpalomer> Cale, I can only find MonadPlus in the docs
17:58:52 <ddarius> Cale is defining MonadOrElse.
17:58:53 <Cale> notpalomer: I know. I'm proposing a new class here.
17:59:19 <notpalomer> Cale, I mean I can't find MonadZero
17:59:25 <Cale> er, oh
17:59:28 <Cale> heh
17:59:33 <ddarius> Cale wants to go back to the good 'ole days.
17:59:35 <Cale> Yeah, maybe leave that out :)
17:59:36 <sorear> mauke: All ML systems I know of use CPS in the back-end.  Presumably, there is a callCC : (('p -> 'q) -> 'p) -> 'p somewhere in the standard library; with this and your ref, callCC (fun k => ref id k `seq` nonterm ()) : ref ('a -> 'a)
17:59:46 <notpalomer> heck, I can't even find NonDet anymore
18:00:01 <ddarius> sorear: callCC is not standard.
18:00:27 <sorear> Huh.  I wonder why everyone uses CPS then/
18:00:33 <chessguy> @where sudoku
18:00:33 <lambdabot> http://www.haskell.org/haskellwiki/Sudoku
18:00:40 <chessguy> notpalomer, ^^
18:00:54 <chessguy> that has an implementation of NonDet
18:01:58 <notpalomer> thx
18:02:07 <notpalomer> but won't [] suffice?
18:02:10 <chessguy> sure
18:02:18 <chessguy> (Cale even says so on that page)
18:06:05 <notpalomer> http://www.haskell.org/haskellwiki/ListT_done_right <--is this a concern?
18:06:07 <lambdabot> Title: ListT done right - HaskellWiki
18:06:18 <Cale> Are you using ListT?
18:06:23 <notpalomer> I mean, has the ListT implementation changed in ghc6
18:06:25 <notpalomer> just curious
18:06:38 <Cale> It is a concern.
18:06:40 <Cale> I basically just avoid ListT
18:06:56 <notpalomer> and use use NonDetT instead?
18:07:20 <Cale> I mostly put my nondeterminism at the bottom of the stack.
18:07:43 <notpalomer> so that it's shared by all worlds?
18:08:38 <notpalomer> ListT (State) <--this is one state per world, how can I get this intuition? to me it says a list of States, each one unrelated
18:08:47 <notpalomer> err
18:08:55 <notpalomer> ListT (State) is one state for all worlds
18:10:42 <notpalomer> I guess transformer monads come between the monad and the underlying type, instead of the other way around
18:10:52 <notpalomer> monad transformers
18:12:54 <sorear> Ok, modules loaded: UniqSet, TcMonad, UnionFind, Let.
18:13:05 <sorear> my implementation of 'let' typechecks, yay
18:13:24 <anybody_> is there many people using the layout system? or do most of you use braces and semicolons?
18:13:50 <sorear> Most of us use layout.  People who don't are considered weird.
18:13:57 <anybody_> lol
18:14:30 <dons> I'm not sure I know anyone who uses { ; ; } all the time
18:14:34 <anybody_> well i think layout is weird. and i'm much faster using semicolons and braces instead of finding the right number of spaces for each row
18:14:43 <dons> at first, yeah.
18:14:43 <dmwit> I wonder what ever happened to tsp.
18:14:56 <dons> eventually the layout rules are embedded in your spine, and you don't think about them
18:14:57 <anybody_> but then i'm coming from c++
18:15:11 <sorear> dons: Ashley Y, on the ML he says he uses Allman-style bracketing exclusively
18:15:13 <dons> its useful to set tab to be 4 or 8 expanded spaces
18:15:17 <dons> then just use tab to align.
18:15:25 <dmwit> anybody_: What editor do you use?
18:15:28 <dons> sorear: iirc, tumov also uses braces for everything
18:15:31 <anybody_> dmwit: vim
18:15:36 <dmwit> :set ai
18:15:55 <anybody_> dmwit: already on in .vimrc
18:16:06 <notpalomer> @hoogle MaybeT
18:16:07 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
18:16:12 <dmwit> In that case, you shouldn't have to get "the right number of spaces".
18:16:22 <Cale> anybody_: The basic thing is just to line things up which are supposed to be on the same level syntactically, and indent further the lines which are inside the lines which they come before
18:16:23 <dmwit> Or maybe I misunderstood.
18:16:27 <anybody_> dmwit: i also downloaded a haskell.vim indent script. but it has problems too
18:16:29 <Cale> which come before them*
18:16:47 <dmwit> anybody_: Yeah, I haven't found a good indent file for Haskell yet.
18:17:18 <Cale> So for instance, in an if-expression, the 'then' and 'else' parts are inside the 'if' and they're at the same level as one another, so the right way to indent it is something like:
18:17:21 <Cale> if foo
18:17:23 <Cale>   then bar
18:17:26 <Cale>   else quux
18:17:31 <Cale> or:
18:17:35 <Cale> if foo then bar
18:17:41 <Cale>        else quux
18:18:26 <Cale> Though in the case of if-expressions it usually doesn't matter so much -- it's pretty tolerant of lots of ways to format them.
18:18:42 <Cale> With do, you just line up all the lines of the do-block
18:18:44 <Cale> do foo
18:18:46 <Cale>    bar
18:18:48 <Cale>    quux
18:18:49 <anybody_> yeah i understand that. the problem is just that if i have something like this:
18:18:52 <anybody_> main = do putStrLn "What is 5! ?"
18:18:58 <anybody_>           n <- readLn
18:19:05 <anybody_>           if n==factorial 5
18:19:13 <anybody_>                 then putStrLn
18:19:24 <anybody_>                 else putStrLn "..."
18:19:42 <Cale> looks okay
18:19:44 <anybody_> and now on the next line i have to do all the spaces by myself
18:19:59 <anybody_> because vim's indent doesn't "get it"
18:20:00 <anybody_>           print (secsToWeeks 1)
18:20:14 <Cale> Usually you can just erase the right number of spaces.
18:20:25 <dmwit> Oh, you want this:
18:20:28 <dmwit> :set sts=4
18:20:39 <dmwit> oh
18:20:41 <dmwit> I see.
18:20:43 <anybody_> sts?
18:20:48 <dmwit> softtabstop
18:20:52 <dons> I use
18:20:53 <dons> set tabstop=4
18:20:53 <dons> set shiftwidth=4                " auto indent width
18:20:53 <dons> set expandtab
18:20:55 <dmwit> But it doesn't do quite what you wanted.
18:21:59 <anybody_> well i have exactly the same settings
18:22:55 <anybody_> the problem is just that the indent script seems confused after the if block
18:23:03 <Cale> Doesn't it line the next line up with the 'then' and the 'else' -- you can just delete whatever amount of indentation you put to indent those in the first place.
18:23:16 <anybody_> yes it does
18:23:36 <anybody_> so i delete one tab. but then it goes too far
18:23:52 <anybody_> and i'm used to stuff like that just working which made me kinda lazy
18:24:15 <sorear> dmwit: I can't seem to find any recent (post-April) publicly archived mailing list postings by Tyler Spivey (who uses edbrowse, screen readers, and tsp's isp)
18:25:57 <dons> anybody_: oh, are you using real tabs?
18:26:04 <dons> or tabs that expand to spaces?
18:26:18 <anybody_> dons: expanding to spaces
18:28:41 <dons> mm, we really should get  Shin-Cheng Mu
18:28:47 <dons> 's blog on p.h.o
18:28:55 <dmwit> dons: Setting sts=4 makes backspace behave as if four spaces are actually a tab.  So one backspace = 4 spaces deleted.
18:28:55 <anybody_> ?
18:28:58 <anybody_> who's that?
18:29:07 <dmwit> dons: So maybe that's what's happening to anybody_.
18:29:16 <dmwit> sorear: Oh, bummer.
18:29:21 <dons> ah
18:29:24 <dons> i don't use sts
18:29:35 <dons> anybody_: oh, interesting blogger on haskell stuff
18:29:39 <nburlett> hey all... quck question.. is there a better way to write:
18:29:41 <nburlett> map (\x -> x 6) [id, (*2)]
18:29:56 <nburlett> I feel the \x -> x 6 isn't quite right
18:30:07 <dons> > map ($6)  [id, (*2)]
18:30:08 <lambdabot>  [6,12]
18:30:09 <dons> :)
18:30:17 <nburlett> huh
18:30:25 <nburlett> funky
18:30:36 <dmwit> f $ x = f x
18:30:37 <dons> cute stuff
18:30:40 <dmwit> Very nice.
18:31:09 <anybody_> dmwit: hm i think the indent/haskell.vim script must be using some different sts value
18:31:37 <anybody_> dmwit: yup. thats the prob. it uses 3 for width and 5 for case
18:31:46 <dmwit> ew
18:31:55 <Cale> > sequence [id, (*2)] 6
18:31:57 <lambdabot>  [6,12]
18:31:58 <dmwit> Well, don't get too hung up on the indentation; try writing something anyway. ;-)
18:32:05 <Cale> ;)
18:32:20 <ddarius> Ashley Yakely does indeed not use layout at all and uses typeclasses to an extreme amount.  See, for example, HScheme.
18:32:29 <slava> do type families perform pattern matching on types, or something?
18:32:30 <dons> yeah, $ and [function] usually hints a monad should be used :)
18:32:47 <dmwit> :t sequence -- was that magic?
18:32:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:32:52 <dons> slava: at a first approximation :)
18:32:54 <EvilTerran> @src sequence
18:32:54 <lambdabot> sequence ms = foldr k (return []) ms
18:32:54 <lambdabot>     where
18:32:54 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:33:05 <dons> you can write type functions, slava.
18:33:06 <Cale> anybody_: Somehow when writing Haskell code I'm more concerned about how it reads than how much effort it is to type. After all, there's not that much typing to do :)
18:33:10 <ddarius> dons: I find, map ($ x) [f,g] to be more explicit, if less "cute", than sequence [f,g] x
18:33:16 <dmwit> Oh, the (-> r) monad.
18:33:23 <Cale> Can we *please* get different source for sequence in @src?
18:33:26 <dons> me too. i usually use the ($ x) form
18:33:28 <ddarius> (r->)
18:33:31 <dmwit> I was trying to imagine the list monad getting that result... =P
18:33:34 <ddarius> or ((->) r)
18:33:36 <EvilTerran> dmwit, me too
18:33:38 <dmwit> ddarius: Right.
18:33:44 <dmwit> ddarius: I always screw that up.
18:33:46 <slava> dons: how expressive are these type functions?
18:33:48 <dons> Cale: that's the Monad.hs defn
18:33:56 <anybody_> Cale: well i'm concerned to both ;-)
18:34:05 <Cale> dons: yeah, but it includes a silly hack, as you can see there
18:34:16 <dons> slava: scarily, I think. my co-author, rl, is implementing intuitionistic logic in them.
18:34:19 <Cale> sequence [] = return []; sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
18:34:29 <matt__r> how can i get darcs to automatically add any file I create in directory X to my repo?
18:34:33 <EvilTerran> sequence [] = []; sequence (x:xs) = liftM2 (:) x (sequence xs)
18:34:36 <Cale> Or sequence = foldr (liftM2 (:)) (return [])
18:34:37 <dons> so we're just under dependent types in power, but people aren't quite sure where the limit is
18:34:55 <dons> matt__r: darcs add -rl -- iirc
18:34:55 <EvilTerran> whups, [] -> return [], yes
18:35:04 <anybody_> still not working the way it should
18:35:24 <anybody_> i guess i'll have to learn about vim-scripting and fix this
18:35:25 * EvilTerran likes Cale's version
18:35:34 <matt__r> dons: I mean for all time
18:35:55 <ddarius> sequence = foldr (liftM2 (:)) (return [])
18:36:01 <binary42> #ruby-lang
18:36:10 <Shine> mauke: my circles function didn't make sense at all, now it looks like this "circles :: [((Double, Double) -> Pixel) -> (Double, Double) -> Pixel]" and my evaluateFunctions function works
18:36:11 <binary42> er...
18:36:18 <matt__r> my number one bug is running, testing and all that on my local machine but the public repo diesn't work because I forgot to darcs add one of the files
18:36:19 <Shine> but "evalFunctions = foldr (.) id" looks like magic for me :-)
18:36:26 * EvilTerran ponders -- surely it'd be possible to have more complex expressions infix in ``s, with the only restriction being that any nested ``s be parenthesised?
18:36:57 * binary42 bashes keyboard one more time
18:37:02 <dmwit> matt__r: Well, you could write a shell script that checks for new files and "darcs add"s them.
18:37:08 * EvilTerran wants to be able to write (xs `zipWith (+)` ys), (x `liftM2 (:)` sequence xs), etc
18:37:17 <matt__r> I thought I might be reduced to that
18:37:23 <matt__r> folder actions should do the job
18:37:58 <dmwit> matt__r: Depending on how new your kernel is, you might be able to find a utility that recieves FS change events, rather than just polling for new files. ;-)
18:38:01 <EvilTerran> in windows NT-series, you can have something trigger when something changes rather than having to poll periodically
18:38:15 <Nafai> inotify on Linux will give you that too
18:38:19 <dolio> Someone showed how to make delimieters -: and :- for that not too long ago.
18:38:30 <dolio> xs -: zipWith (+) :- ys
18:38:34 <matt__r> well, i am on macos x, so I think I just need a one line folder actions script.
18:38:42 <EvilTerran> i... can see how that'd work. looks nasty, tho =/
18:38:56 <dons> matt__r: you want to import everything just once?
18:39:17 <dolio> EvilTerran: Using them looks nasty, or implementing it?
18:39:32 <EvilTerran> well, both. it's a bit of a hack.
18:39:37 <matt__r> nah - I want to "watch" the folder and make sure all files in it are added before any record command
18:39:37 <mauke> ZipList xs + ZipList ys
18:39:37 <ddarius> > let (-|) = flip ($); (|-) = id in [1,3,4] -| zipWith (*) |- [4,6,7]
18:39:40 <lambdabot>  [4,18,28]
18:40:03 <mauke> er, getZipList (ZipList xs + ZipList ys)
18:40:12 <dons> matt__r: i think you can set darcs add to use -rl by default in the preferences
18:40:23 <dons> or just remember to add things? check on #darcs ?
18:40:54 <matt__r> dons: I didn't even know there was a #darcs - thanks :)
18:41:02 <dolio> mauke: You mean, getZipList ((+) <$> ZipList xs <*> ZipList ys)? :) Or do you have (Num n, Applicative f) => Num (f n)?
18:41:12 <mauke> the latter
18:41:23 <dolio> Ah. Sexy.
18:41:28 <mauke> *Main> getZipList (ZipList [1,3,4] * ZipList [4,6,7])
18:41:29 <mauke> [4,18,28]
18:41:49 <mauke> *Main> [1,3,4] * [4,6,7]
18:41:50 <mauke> [4,6,7,12,18,21,16,24,28]
18:42:38 <dons> http://programming.reddit.com/info/2cx8g/details
18:42:39 <lambdabot> Title: Zipping Half of a List with Its Reversal (reddit.com)
18:42:56 <dolio> That guy's blog is great.
18:43:18 <dons> yeah!
18:43:29 <dons> i'm mailing him now about getting the back cataglog on p.h.o
18:43:45 <dons> i think dcoutts__ might know him, actualy
18:44:15 <dolio> Ah. ccshan's blog still isn't on p.h.o, either, I think.
18:44:26 <dons> ah yes! another one.
18:44:31 <dons> i'll ping them both
18:46:05 <Shine> is there a "single step" mode in GHC so that I can see all transformation steps of an expression until the result?
18:46:25 <EvilTerran> not afaik
18:46:51 <dons> here's the rss feed, btw, http://www.iis.sinica.edu.tw/~scm/?feed=rss2
18:49:41 <anybody_> gn all
18:52:52 <OceanSpray> so, can I use '=' in a 'do' construct?
18:53:38 <mauke> in a let, yes
18:53:38 <ddarius> You can use let x = ... in a do construct.
18:53:38 <OceanSpray> also, will "foo = case bar of baz -> 42" work?
18:53:40 <araujo> inside a 'let' binding
18:53:45 <OceanSpray> oh
18:53:46 <OceanSpray> let
18:54:01 <dons> oh, ccshan is Assistant Professor now. cool.
18:54:09 <ddarius> @undo do let x = 3; return x
18:54:09 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
18:54:20 <ddarius> @undo do { let x = 3; return x }
18:54:20 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 26}) "Parse error"
18:54:28 <ddarius> Doesn't handle lets?
18:54:43 <dons> and he and dylan won the 01 ICFP contest -- I didn't know that.
18:54:56 <allbery_b> probably doesn't parse them fully since there is weirdness in the parsing rules
18:55:11 <allbery_b> @undo do { let { x = 3 }; return x }
18:55:11 <lambdabot> let { x = 3} in return x
18:55:24 <ddarius> That one always gets me.
18:55:34 <OceanSpray> so you gotta use {}s?
18:55:38 <allbery_b> yeh
18:55:41 <OceanSpray> that's weird.
18:55:43 <allbery_b> well, in @undo
18:56:07 <allbery_b> problem is, the haskell definition specifies that the parser inserts braces as necessary until it becomes a legal expression
18:56:32 <allbery_b> this is not exactly something for quick trivial parsers like the one used by @undo
18:57:38 <allbery_b> (not to mention that it's extremely hard to get right; even ghc botches some corner cases, IIRC)
18:59:41 <OceanSpray> no matter
18:59:44 <OceanSpray> it works
18:59:46 <OceanSpray> sorta.
19:00:12 <luqui> is there any more, er, verbose documentation for Template Haskell?
19:00:21 <luqui> as in what the many parameters of DataD mean...?
19:00:53 <dons> grab the source for template-haskell (the library)
19:00:57 <dons> that's the canonical reference
19:01:15 <lucca> go liskell! heh
19:01:47 <Shine> mauke: I think now I understand "foldr (.) id": It creates a big function like this: "\ x -> id(f1(f2(f3 x)))", when applied to a list [f1,f2,f3]. This is then applied to the start value in my example
19:02:22 <dons> yep
19:02:26 <Cale> f1 . f2 . f3 . id
19:02:28 <luqui> dons, and... uh, where does one find said source?
19:02:40 <Cale> (the id is at the end, not that it really matters)
19:03:29 <dons> luqui: http://darcs.haskell.org/packages/template-haskell/
19:03:30 <lambdabot> Title: Index of /packages/template-haskell
19:03:52 <chessguy> @where th
19:03:52 <lambdabot> http://www.haskell.org/th
19:04:10 <luqui> thanks
19:04:20 <OceanSpray> ok, NOW it's perfect.
19:04:31 <Shine> I wonder if there is something like reduce in Lisp: (reduce #'+ '()) = 0 and (reduce #'* '()) = 1, because (*)=1 and (+)=0. This means (.) without an argument could automaticly return "id" and if used with +, the start element would automaticly 0?
19:05:34 <OceanSpray> hpaste?
19:05:42 <OceanSpray> hpaste where?
19:05:45 <OceanSpray> hpaste url?
19:05:45 <hpaste> Haskell paste bin: http://hpaste.org/
19:05:47 <OceanSpray> ok
19:06:04 <allbery_b> @paste -- :)
19:06:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:06:48 <hpaste>  OceanSpray annotated "screw.hs" with "(no title)" at http://hpaste.org/2086#a7
19:07:11 <dolio> Haskell doesn't do poly-variadic functions unless you do some type magic, so, no, when you fold over a list, you need to provide a base case.
19:09:27 <Shine> dolio: how does the type magic look like for poly-variadic functions?
19:09:45 <dons> recursive type classes, a bit tricky
19:09:52 <dylan> :t printf
19:09:54 <lambdabot> forall r. (PrintfType r) => String -> r
19:09:55 <dons> so you'd really have to justify the use
19:10:01 <allbery_b> take a look at the source for the Text.Printf module
19:10:08 <dons> (e.g. you were implemeting an EDSL with variadic syntax)
19:10:10 <allbery_b> it's downright scary
19:11:02 <Shine> thanks, I'll take a look at it when I have learned the Haskell basics :-)
19:11:11 <dolio> Huh, I don't remember where it's at on Oleg's page...
19:11:26 <dolio> Oh wait, I think I found it.
19:11:30 <dons> ooh, syntaxninja's really married now.
19:12:52 <dolio> Shine: http://okmij.org/ftp/Haskell/types.html#polyvar-fn
19:12:53 <lambdabot> Title: Haskell Programming: Types
19:13:57 <wli> There was an elder version of Printf.hs that was far more readable.
19:15:18 <LoganCapaldo> I usually find eldritch scripts harder to read
19:15:53 <wli> Spare us.
19:16:10 <OceanSpray> what exactly does liftM do?
19:16:17 <mauke> @src liftM
19:16:17 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:16:21 <allbery_b> shub-haskellrath, bearer of a thousand types?
19:16:56 <OceanSpray> oh
19:16:57 <samreid> OceanSpray: it's fmap
19:16:59 <gkr> It's a probelm free philosophy.
19:17:02 <gkr> Sorry :-/
19:17:26 <gkr> @type liftM
19:17:28 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:21:29 <Cale> OceanSpray: it takes a function and a computation and produces a computation which does the same thing as the first, but whose result has that function applied to it.
19:21:29 <wli> I wonder if there's a way to leverage all this for numeric hierarchy purposes.
19:22:10 <wli> For instance, scalar * scalar, scalar * vector, matrix * vector, etc.
19:22:52 <OceanSpray> what's the easiest way to iterate over a list?
19:23:04 <OceanSpray> specifically, the args <- getArgs
19:23:53 <Cale> OceanSpray: and perform an action for each?
19:23:54 <wli> OceanSpray: It depends on what you're doing with the list. map, foldr, foldl, mapAccumR, mapAccumL, scanl, scanr, and still other things express various sorts of iteration over lists.
19:24:08 <Cale> OceanSpray: Perhaps mapM/forM?
19:24:18 <LoganCapaldo> OceanSpray, there are the folds (foldr, foldl, etc.). There is also map, and of cours eyou can recurse
19:24:20 <wli> OceanSpray: There are, of course, monadic variants, too.
19:24:33 <OceanSpray> ah
19:24:50 <OceanSpray> I'm doing the same thing to every item
19:24:54 <OceanSpray> so map?
19:25:01 <wli> OceanSpray: mapM, foldM, zipWithM, sequence, etc. are there.
19:25:06 <Cale> sure, but is that thing going to be an IO action?
19:25:17 <OceanSpray> yes, it prints an output
19:25:26 <Cale> Then you may want mapM
19:25:36 <OceanSpray> k.
19:25:37 <Cale> or forM which is just mapM with the list parameter first
19:25:45 <Cale> (essentially it's a foreach loop)
19:26:07 <Cale> Another approach would be to write a pure function which produced the list of things to be printed
19:26:10 <mauke> @. pl undo do { x <- a; y <- b; f x y }
19:26:10 <lambdabot> (b >>=) . f =<< a
19:26:12 <Cale> and then print that list.
19:27:46 <wli> @type mapM print =<< getArgs
19:27:47 <lambdabot> Not in scope: `getArgs'
19:28:15 <mauke> @. pl undo do { x <- a; f <- b; f x }
19:28:15 <lambdabot> (b >>=) . flip id =<< a
19:28:38 <mauke> @. pl undo do { f <- a; x <- b; f x }
19:28:38 <lambdabot> (b >>=) =<< a
19:28:42 <mauke> haha
19:29:28 <Shine> is it possible to curry this function: "f1 x = f2 (f3 x) x", so that it looks like "f1 = ..."?
19:29:31 <OceanSpray> hm, nvm
19:29:54 <OceanSpray> I need a do {} while ()
19:29:56 <LoganCapaldo> @pl \x -> f2 (f3 x) x
19:29:57 <lambdabot> f2 =<< f3
19:30:12 <mauke> @unpl join (f2 . f3)
19:30:12 <lambdabot> ((\ e -> f2 (f3 e)) >>= \ a -> a)
19:30:32 <mauke> @type join (?f2 . ?f3)
19:30:34 <lambdabot> forall b a a1. (?f2::b -> a -> a1, ?f3::a -> b) => a -> a1
19:31:15 <LoganCapaldo> @type ap (flip f2) f3
19:31:17 <lambdabot> Not in scope: `f2'
19:31:17 <lambdabot>  
19:31:17 <lambdabot> <interactive>:1:13: Not in scope: `f3'
19:31:18 <sorear> re.
19:31:57 <LoganCapaldo> @type \f2 f3 -> ap (flip f2) f3
19:31:59 <lambdabot> forall a b c. (a -> b -> c) -> (b -> a) -> b -> c
19:32:16 <LoganCapaldo> @type \f2 f3 x -> f2 (f3 x) x
19:32:18 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> (t -> t1) -> t -> t2
19:32:27 <mauke> yeah, that's basically >>=
19:32:42 <LoganCapaldo> It made me think of S
19:32:50 <Shine> thanks, I think I'll use LoganCapaldo first answer, the lambda idea, something I understand :-)
19:32:51 <LoganCapaldo> which made me think of ap
19:33:11 <mauke> Shine: why not your original version?
19:34:16 <Shine> I have to make a list of functions, which has to be appended to the circles list, so I need a curried function, I think
19:34:28 <Shine> at least the compiler is happy now :-)
19:34:30 <mauke> huh?
19:34:37 <LoganCapaldo> all haskell functions are curried by default
19:34:56 * wli returns to the subject of terminal manipulation and boggles at the terminal strings.
19:35:02 <sorear> I don't suppose there is a complete set of syntaxfree natural deduction typing rules for GHC floating around somewhere, is there?
19:35:34 <LoganCapaldo> Shine, also you can define a function like f x = ... and refer to it by f
19:35:51 <hpaste>  Shine pasted "maskedCrosses is the function where I needed it" at http://hpaste.org/2104
19:36:37 <wli> I'm clueless as to how ghci gets an immediate response to ^C
19:36:41 <hpaste>  LoganCapaldo annotated "maskedCrosses is the function where I needed it" with "This is exactly the same" at http://hpaste.org/2104#a1
19:37:13 <wli> It looks like the foreign call stops the world in anything I can successfully write.
19:37:49 <Shine> LoganCapaldo: thanks, that's better, I have to unlearn some bad Lisp habits
19:37:58 <dons> wli, safe/unsafe imports, and -threaded
19:38:13 <OceanSpray> so, really
19:38:23 <OceanSpray> how do I loop a monad?
19:38:32 <dmwit> forever m = m >> forever m
19:38:42 <dons> loop in a monad :)
19:38:42 <dmwit> What kind of loop do you want?
19:38:49 <dons> looping a monad would be a bit more work :)
19:39:12 <mauke> Fix ReaderT Wtf
19:39:19 <dmwit> heh
19:39:20 <OceanSpray> x <- parser; y <- parser; ...
19:39:27 <dmwit> :t sequence
19:39:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:39:29 <OceanSpray> and then [x y ...]
19:39:44 <mauke> replicateM?
19:39:45 <dmwit> You may also be interested in
19:39:51 <dmwit> :t mapM
19:39:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:39:57 <wli> dons: I don't quite know what you mean.
19:40:11 <dons> wli, you askign about blockign foreign calls stopping all haskell threads?
19:40:39 <wli> dons: No, it stops any terminal IO slave thread from doing anything intelligent with signals.
19:41:01 <dons> what does?
19:41:20 <dons> (i've implemented quite a few signal handling, threaded haskell apps now, haven't had trouble)
19:41:35 <dons> hmp3 and yi, for example, handles ^L in children threads
19:41:54 <OceanSpray> ok, in that annotation http://hpaste.org/2086#a7 ?
19:42:00 <OceanSpray> see lispExpr?
19:42:01 <wli> dons: Specifically it seems that anything using readline doesn't seem to be able to respond immediately to ^C
19:42:28 <OceanSpray> I just want to apply it over and over until eof
19:42:30 <wli> dons: I don't know how ghci does it.
19:42:52 <mauke> OceanSpray: many lispExpr?
19:42:58 <OceanSpray> that is, in a lispExprs :: Parser [LispVal]
19:43:20 <OceanSpray> I need to construct a monadic parser out of other monadic parsers, that will loop until eof
19:43:30 <OceanSpray> many?
19:43:35 <OceanSpray> OH
19:43:37 <OceanSpray> D'OH
19:43:40 <OceanSpray> URGH
19:43:53 <wli> dons: I'm interested in learning how this is done, of course.
19:44:11 <OceanSpray> man, I'm gettin' dumber every day
19:44:24 <lament> most people do, don't worry
19:44:26 <wli> I just don't seem to be able to figure it out on my own.
19:44:29 <dons> wli, have you looked in the ghci source?
19:44:39 <mauke> many isn't hard to define yourself
19:45:04 <mauke> many p = many1 p <|> return []; many1 p = liftM2 (:) p (many p)
19:45:06 <wli> dons: Yeah. I've even plugged in some of its code and failed to get it to do what I wanted.
19:46:55 <wli> dons: I can catch the signal but I can't do anything except raiseSignal sigTERM ; the blocked terminal IO thread doesn't respond to killThread
19:48:58 <wli> dons: Except for one particular exception that has the same effect.
19:49:46 <wli> AsyncException ThreadKilled
19:50:05 <wli> (I think)
19:53:15 <sorear>    If the target thread is currently making a foreign call, then the exception will not be raised (and hence throwTo will not return) until the call has completed. This is the case regardless of whether the
19:53:19 <sorear>    call is inside a block or not.
19:53:38 <sorear> wli: ^^^ from the haddocks; killThread will not work on threads blocked in the FFI
19:54:06 <wli> sorear: throwTo doesn't; killThread is how ghci does it I think.
19:54:33 <mauke> @src killThread
19:54:34 <lambdabot> killThread tid = throwTo tid (AsyncException ThreadKilled)
19:54:39 <sorear> The killThread function is defined in terms of throwTo:   killThread tid = throwTo tid (AsyncException ThreadKilled)
19:54:58 <OceanSpray> :t mapf
19:54:59 <lambdabot> Not in scope: `mapf'
19:55:02 <OceanSpray> :t mapF
19:55:04 <lambdabot> Not in scope: `mapF'
19:55:06 <OceanSpray> hm
19:55:38 <wli> sorear: Yes. I'm describing what I've observed, which is at variance with the documentation.
19:55:43 <OceanSpray> :t fmap
19:55:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:57:16 <wli> sorear: It actually uses DynException; I've seen that AsyncException ThreadKilled works though not DynException as in ghci.
19:58:48 <wli> sorear: For some value of "works" that doesn't let me do anything useful.
19:59:38 <wli> Perhaps my time would be better spent NIH'ing ncurses and libreadline. ;)
20:00:43 <sorear> wli: If you're going to NIH libreadline, you might want to check out what shellac has done
20:00:48 <sorear> @where shellac
20:00:49 <lambdabot> darcs get http://www.eecs.tufts.edu/~rdocki01/shell/
20:01:25 <wli> 404
20:01:31 <OceanSpray> how do you print a list of strings?
20:01:43 <mauke> OceanSpray: print ["list", "of", "strings"]
20:01:44 <OceanSpray> that is, is there a library function?
20:01:54 <OceanSpray> OH HA HA
20:01:58 <wli> OceanSpray: You can either mapM print listOfStrings or just call print on it depending on the format you want.
20:02:01 <OceanSpray> U MADE A FUNNAY
20:02:16 <joed> http://www.eecs.tufts.edu/~rdocki01/shellac/
20:02:17 <lambdabot> Title: Index of /~rdocki01/shellac
20:02:36 <LoganCapaldo> @type putStr . concat
20:02:38 <lambdabot> [[Char]] -> IO ()
20:02:46 <sorear> @where+ shellac http://www.eecs.tufts.edu/~rdocki01/shellac/
20:02:46 <lambdabot> Done.
20:03:10 <monochrom> putStr . unlines
20:03:14 <LoganCapaldo> > intersperse "\n" ["a list", "of", "strings"]
20:03:15 <wli> OceanSpray: Much of this depends on the format you want for the list of strings. There are helpers for a number of different formats.
20:03:15 <lambdabot>  ["a list","\n","of","\n","strings"]
20:03:22 <LoganCapaldo> drat
20:03:29 <LoganCapaldo> why do I always forget about unlines
20:03:33 <sorear> LoganCapaldo: intercalate in recent ghc
20:03:39 <mauke> @type (concat .) . intersperse
20:03:41 <monochrom> because it's uncommon :)
20:03:41 <lambdabot> forall a. [a] -> [[a]] -> [a]
20:04:07 <mauke> @type concatMap (++ "\n")
20:04:09 <lambdabot> [[Char]] -> [Char]
20:04:28 <LoganCapaldo> sorear, is intercalate the new name for intersperse or is intercalate concat . intersperse ?
20:04:29 <monochrom> If you interact with interact alot and never do I/O yourself, you tend to remember unlines, since you use it all the time. interact (unlines . f . lines)
20:04:37 <sorear> LoganCapaldo: snd
20:04:52 <LoganCapaldo> sorear, cool
20:04:52 <wli> sorear: Sadly I don't see much in the way of low-level tty/pty handling in shellac.
20:05:19 <sorear> wli: Oh.  I just remembered that it did line editing and supported vty.
20:06:00 * sorear never actually paid much attention, except for the huge shock of discovering that someone actually *wanted* to use his tty interface lib
20:06:31 <wli> Is forever essentially sequence_ . repeat?
20:06:50 <ddarius> monochrom: Not if you write a combinator to abstract that.
20:07:28 <ddarius> wli: Essentially.
20:07:40 <wli> ddarius: Any other subtleties/etc.?
20:07:46 <monochrom> If you write the combinator yourself, its ingredients tend to stick too.
20:08:37 <chessguy> @type sequence_ . repeat
20:08:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
20:09:19 <ddarius> wli: I believe forever has a slightly more general return type, but nothing big.
20:09:21 <chessguy> lol, yeah, i guess it's m (), since it never terminates
20:09:45 <ddarius> chessguy: m a -> m b would be more emphatic
20:10:30 <chessguy> @type let g f = f >> g
20:10:32 <lambdabot> <command line>:
20:10:32 <lambdabot>     Could not find module `L':
20:11:04 <chessguy> huh
20:12:09 <chessguy> @let forever f = f >> forever f
20:12:11 <lambdabot> Defined.
20:12:12 <chessguy> @type forever
20:12:14 <lambdabot> Not in scope: `forever'
20:12:20 <chessguy> @type L.forever
20:12:22 <lambdabot> Couldn't find qualified module.
20:12:26 <chessguy> grr
20:12:32 <ddarius> :t \f -> fix (f >>)
20:12:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
20:12:51 <chessguy> @unlet
20:12:54 <lambdabot> Defined.
20:12:54 <chessguy> whatever
20:13:16 <ddarius> @let x = 3
20:13:17 <ddarius> :t x
20:13:18 <chessguy> dumb bot
20:13:19 <lambdabot> Integer
20:13:22 <lambdabot> Defined.
20:13:33 <chessguy> @let f = (+3)
20:13:35 <chessguy> @type f
20:13:36 <lambdabot> Defined.
20:13:37 <lambdabot> Not in scope: `f'
20:13:38 <jfredett> @slap chessguy
20:13:38 * lambdabot slaps chessguy
20:13:42 <jfredett> be nice to lambdy
20:13:45 <jfredett> @botsnack
20:13:45 <lambdabot> :)
20:13:52 <ddarius> :t f
20:13:54 <lambdabot> Not in scope: `f'
20:13:56 <chessguy> well, it is being dumb
20:14:05 <chessguy> i calls 'em like i sees 'em
20:14:11 <jfredett> maybe it just needs a little encouragement
20:14:12 <LoganCapaldo> :t L.f -- right?
20:14:14 <lambdabot> Couldn't find qualified module.
20:14:22 <LoganCapaldo> I guess not
20:14:24 <chessguy> LoganCapaldo, i tried that
20:14:28 <chessguy> @unlet
20:14:31 <lambdabot> Defined.
20:14:33 <chessguy> whatever
20:14:35 <chessguy> dumb bot
20:14:42 <ddarius> @undefine
20:14:44 <LoganCapaldo> @undefine
20:14:44 <lambdabot> Undefined.
20:14:46 <lambdabot> Undefined.
20:15:02 <notpalomer> hmm, Cale showed me before how to define a function orElse
20:15:07 <notpalomer> I defined a similar function andAlso
20:15:09 <LoganCapaldo> @let -- unlet spellchecks to let
20:15:11 <lambdabot> Defined.
20:15:22 <chessguy> oh, more dumbness
20:15:24 <Cale> notpalomer: mplus?
20:15:25 <notpalomer> does something like andAlso already exist?
20:15:33 <mauke> @hoogle andAlso
20:15:34 <lambdabot> No matches found
20:15:37 <notpalomer> [1] `andAlso` [] = []
20:15:43 <ddarius> Probably >>
20:15:44 <monochrom> && is andAlso
20:15:54 <mauke> monochrom: no, && is restricted to Bool
20:15:58 <ddarius> > [1] >> []
20:15:59 <monochrom> Sorry.
20:15:59 <lambdabot>  []
20:16:05 <LoganCapaldo> mplus wouldn't be AndAlso for Maybe though right?
20:16:11 <notpalomer> && is to andAlso what || is to orElse
20:16:15 <LoganCapaldo> > Just 1 `mplus` undefined
20:16:16 <lambdabot>  Just 1
20:16:28 <monochrom> mplus is orElse for Maybe
20:16:46 <mauke> @let a << b = do {x <- a; b; return x}
20:16:48 <ddarius> notpalomer: (>>) is like (&&) or (*) and mplus is like (||) or (+)
20:16:49 <lambdabot> Defined.
20:16:58 <mauke> > Just 1 << Just 2
20:16:59 <lambdabot>  Just 1
20:17:08 <mauke> > Just 1 << Nothing
20:17:08 <Cale> So both have to be nonempty in order to get any results, but in that case, you want the union of the results of both?
20:17:09 <lambdabot>  Nothing
20:17:13 <Cale> That's a little strange :)
20:17:15 <monochrom> What is the business with saying you are not palomer? :)
20:17:52 <monochrom> Anyway, I think in some sense >> is andAlso.
20:18:25 <notpalomer> palomer? I don't know any palomer!
20:18:26 <mauke> > [1,2] << [3,4]
20:18:27 <lambdabot>  [1,1,2,2]
20:18:49 <notpalomer> haha, that's freaky
20:18:55 <chessguy> > [1,2] >>= [3,4]
20:18:56 <lambdabot>  Couldn't match expected type `t -> [b]' against inferred type `[a]'
20:19:04 <chessguy> > [1,2] >> [3,4]
20:19:05 <lambdabot>  [3,4,3,4]
20:19:21 <monochrom> ⊥ >> x = ⊥.  otherwise y >> x = x.  I think this is close enough to andAlso.
20:19:22 <chessguy> @hoogle (<<)
20:19:22 <lambdabot> Did you mean: (<<)
20:19:23 <lambdabot> Prelude.undefined :: a
20:19:23 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
20:19:54 <LoganCapaldo> @type let andAlso a b = a >>= \a' -> b >>= \b' -> return (a',b') in andAlso -- Maybe? Or am I missing the point?
20:19:56 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> m a1 -> m (a, a1)
20:19:57 <monochrom> excuse, s/⊥/mzero
20:20:15 <notpalomer> what's that function that reduces any expression you give it
20:20:21 <SamB> @seen notpalomer
20:20:22 <lambdabot> notpalomer is in #haskell. I last heard notpalomer speak 7s ago.
20:20:27 <SamB> @seen palomer
20:20:27 <lambdabot> I haven't seen palomer.
20:20:30 <Cale> andAlso [] _ = []; andAlso _ [] = []; andAlso xs ys = xs ++ ys  ?
20:20:37 <notpalomer> Cale, yup
20:20:50 <Cale> That is quite a strange operation :)
20:20:52 <monochrom> that function is a Russell paradox. :)
20:21:10 <notpalomer> Cale, no way, I'm unifying types
20:21:17 <notpalomer> and if any unification fails, everything fails
20:21:32 * SamB wonders why notpalomer doesn't want an error message
20:21:55 <notpalomer> because I had to make a choice before
20:22:01 <notpalomer> an arbitrary choice
20:22:05 <notpalomer> if it fails, I make another choice
20:22:08 <notpalomer> which may succeed
20:22:19 <SamB> an arbitrary choice that you prefer to be mystefied as to where the bug is ?
20:22:48 <notpalomer> I'm hoping there are no bugs
20:22:54 <Cale> But the result of  xs `andAlso` ys  will, assuming there's something in xs and something in ys, be just one element of the union at a time
20:23:04 * SamB doesn't find that strategy too useful with computations that are allowed to fail
20:23:32 <Cale> Usually you want something like a Cartesian product.
20:23:44 <Cale> Rather than a union of this sort.
20:23:53 <Cale> (that's why it's confusing)
20:24:02 <mysty_> Hello, I would appreciate it if someone could advise me on what I can do about the following error message: getMBlocks: VirtualAlloc MEM_RESERVE 1025 blocks failed: Not enough storage is available to process this command.
20:24:18 <Cale> mysty_: context?
20:25:12 <mysty_> I'm querying an MS Access database using HDBC.
20:25:19 <mysty_> It's a large query.
20:25:25 <notpalomer> ahh, righto
20:25:26 <LoganCapaldo> buy more ram? :)
20:25:34 <notpalomer> andAlso :: m () -> m () -> m ()
20:25:55 <mysty_> Is there any compiler flags I need to be aware of?
20:26:01 <mysty_> *Are
20:26:16 <notpalomer> andAlso xs ys = xs ++ ys   <--this is both elements
20:26:47 <sorear> dmwit: tspivey.freeshell.org, allinaccess.com.  the latter has an HTTP Last-Modified: of 1 minute ago
20:28:09 <notpalomer> @pl \f lst -> msum (map f lst) --I would have thought we would have something in terms of mapM
20:28:09 <lambdabot> (msum .) . map
20:29:05 <Cale> mysty_: Which version of GHC is it?
20:29:08 <OceanSpray> :t flatten
20:29:10 <lambdabot> forall a. Tree a -> [a]
20:29:19 <mysty_> 6.6.1
20:29:30 <OceanSpray> how about a flatten for lists of lists?
20:29:38 <shachaf> OceanSpray: concat
20:29:41 <shachaf> @ty concat
20:29:43 <lambdabot> forall a. [[a]] -> [a]
20:29:47 <OceanSpray> oh
20:29:48 <shachaf> @hoogle [[a]] -> [a]
20:29:49 <lambdabot> Prelude.concat :: [[a]] -> [a]
20:30:01 <shachaf> OceanSpray: Also join.
20:30:02 <sorear> mysty_: I think I remember seeing a GHC bug report about that
20:30:26 <notpalomer> Cale, what do you find weird about andAlso? do you have code which behaves weirdly?
20:31:04 <Cale> mysty_: That looks a lot like a compiler bug on the GHC Trac.
20:31:21 <mysty_> Oh, OK. Thank you very much.
20:31:36 <Cale> mysty_: You might try requesting a different size heap explicitly
20:31:37 <mysty_> It's back to Python for me :P
20:31:44 <sorear> Cale: If you're referring to #1197, I don't think it's the same.
20:31:49 <Cale> sorear: hmm
20:31:54 <Cale> Run your program with +RTS -M1000M
20:31:54 <bos> http://programming.reddit.com/info/2cy18/comments
20:32:11 <mysty_> ok
20:32:23 <dons> bos: :)
20:32:35 <sorear> mysty_: (If this isn't a GHC bug) You're probably trying to allocate more memory than you have available ... Try using incremental results?
20:32:40 <OceanSpray> :t intersperse
20:32:42 <lambdabot> forall a. a -> [a] -> [a]
20:32:47 <dons> ` Haskell OSCON videos 50% more popular than next ten most viewed videos  ' for those who were waiting for lambdabot
20:33:16 <OceanSpray> for some reason, intersperse is not in scope for me
20:33:16 * ddarius was
20:33:21 <mysty_> Cale: Same result.
20:33:22 <OceanSpray> what do I have to import?
20:33:25 <ddarius> import Data.List
20:33:30 <ddarius> For future reference
20:33:33 <ddarius> @index intersperse
20:33:34 <lambdabot> Data.List
20:34:08 <Cale> mysty_: Watch the amount of memory that it's allocating. Perhaps you're actually running out of memory? I don't actually know what getMBlocks does.
20:34:54 <ddarius> bos/dons: So what are the actual number of viewings roughly?
20:35:25 <sorear> Cale: Hah.  The getMBlocks: errors don't actually come from a function by that name ;)
20:35:31 <OceanSpray> IT WORKS!
20:35:49 <Cale> sorear: oh?
20:35:51 <LoganCapaldo> > let a = 'a':'a':intersperse 'b' a in a
20:35:53 <lambdabot>  "aaabababbbabbbabbbbbbbabbbbbbbabbbbbbbbbbbbbbbabbbbbbbbbbbbbbbabbbbbbbbbbbb...
20:36:03 <sorear> Cale: allocNew, etc.
20:36:04 <mysty_> Cale: It crashes very quickly. Nothing on Task Manager shows up (I'm on Windows).
20:36:09 <Cale> hmm
20:36:31 <sorear> VirtualAlloc is a windows syscall name :)
20:36:56 <bos> ddarius: as of some arbitrary time in the past, it was about 1600 simon, 1100 everyone else (mark shuttleworth, jimmy wales, you name 'em)
20:37:01 <Cale> ah, so the system call is failing?
20:37:13 <dons> bos, one thing i wondered: a lot of people started using direct links to the .mov files
20:37:19 <dons> i bet they're not counted in the hit statistics
20:37:28 * ddarius couldn't even name Mark Shuttleworth or Jimmy Wales...
20:37:29 <mgsloan> I'm confused about the value of arrows.  They just seem like a combinatorial approach to handling multiple outputs and non-tree expression structure
20:37:48 <Cale> mgsloan: That's what List arrows are for
20:38:00 <dons> (e.g. typically, popular wiki articles on haskell.org get around 10k hits over the 3-4 days of activity around them, so I'd imagine similar (or more), non-unique hits for oscon)
20:39:13 <ddarius> So much for avoiding success at all costs.  That was probably a lost cause about a year or so ago anyways.
20:39:15 <sorear> mysty_: About how much memory do you have?  I just checked the source and 1025 MBLOCKs corresponds to just over 1GB
20:39:33 <mysty_> I have 2GB.
20:39:33 <dons> ddarius: i think we explicitly switched policy about this time last year, yes.
20:39:44 <dons> ddarius: since some of us need jobs :)
20:39:51 <glguy> > (-1 :: Int) `shiftR` 1
20:39:52 <lambdabot>  -1
20:39:56 <glguy> is that "right"?
20:40:02 <ddarius> Sign extension
20:40:08 <ddarius> Yes it is.
20:40:45 <ddarius> > (-1 :: Word32) `shiftR` 1
20:40:46 <lambdabot>  2147483647
20:41:01 <bos> dons: do we publish stats on the growth in haskell.org traffic?
20:41:04 <Cale> > (-1 :: Word32)
20:41:06 <lambdabot>  4294967295
20:41:24 <dons> bos, hmm. we haven't in the past. i'm not sure they're collected (oh, i suppose they must be)
20:41:35 <dons> i'm hanging out for the 1M hits on the front page mark, later this year
20:41:43 <bos> dons: :-)
20:41:49 <wli> I'm still all ears for recapitulating ghci's readline trickery.
20:41:58 <bos> trickery?
20:42:00 <dons> its somewhere around 1-2k hits a day now, for 'haskell.org'
20:42:01 <glguy> what is the right way to write: (a+b) `div` 2    that deals with overflow then?
20:42:05 <glguy> where a and b are Int
20:42:20 <dons> but we get articles spikes of 10k hits or so over 24-48 hour periods, for key tutorials
20:42:27 <dons> (like "haskell in 10 minutes")
20:42:28 <glguy> and without checking if both a and b are odd
20:42:47 <wli> bos: How it catches and processes SIGINT immediately while the foreign call to readline is in progress.
20:42:49 <bos> dons: mostly driven by reddit, i assume?
20:42:54 <bos> wli: ah
20:43:00 <ddarius> glguy: Huh? Do you mean underflow?
20:43:14 <mgsloan> ((a :: Integer) + b) `div` 2 ? :)
20:43:15 <dons> the `programming haskell' links back in December got 25k hits in 2 days, iirc. and 50k over that month. xmonad.org had 140k hits in April, by comparison (!)
20:43:21 <sorear> okay, vague memories floating into my head...
20:43:26 <dons> bos, mostly, then they leak from there to digg et al
20:43:29 <sorear> Any win32 experts here?
20:43:34 <glguy> div a 2 + div b 2 + (if odd a && odd b then 1 else 0)
20:43:37 <bos> digg's not nearly nerdy enough :-)
20:43:48 <ddarius> glguy: Ah.
20:43:49 <mgsloan> anyway, the proper way is (a-b) `div` 2 + b
20:44:04 <dons> bos, yeah, only the most cursory stuff does well on digg
20:44:09 <dons> the irc bot tut did, for some reason
20:44:15 <sorear> I seem to recall that win32 divides address space into four 1GB chunks (much the way Linux has the 3G/1G split), and so 1G is the maximum amount of memory one program can use without special hacks.
20:44:20 <sorear> Is this correct?
20:44:22 <dons> i think they thought it was a botnet article for spammers
20:44:47 <sorear> Haskell used by spammers and crackeres?
20:44:54 <Cale> sorear: ah, so you can't alloc a single chunk of memory which is over 1GB?
20:44:56 <dons> all the l33t haxors
20:45:06 <bos> i see a need for a captcha-solving monad
20:45:08 <mysty_> sorear: Ah, that might be the problem!
20:45:12 <dons> heh
20:45:16 <glguy> ?check \ x y -> ((a-b) `div` 2 + b) == (a+b) `div` 2 :: Int -> Int -> Bool
20:45:18 <lambdabot>   Not in scope: `b'
20:45:21 <glguy> oops :)
20:45:26 <glguy> ?check \ a b -> ((a-b) `div` 2 + b) == (a+b) `div` 2 :: Int -> Int -> Bool
20:45:27 <lambdabot>  Couldn't match expected type `Int -> Int -> Bool'
20:45:29 <sorear> Cale: Maybe.  I haven't touched windows for about 20% of my accumulated lifespan
20:45:29 <mgsloan> heh
20:45:37 * allbery_b sighs
20:45:40 <glguy> ?check (\ a b -> ((a-b) `div` 2 + b) == (a+b) `div` 2) :: Int -> Int -> Bool
20:45:41 <lambdabot>  OK, passed 500 tests.
20:45:44 <glguy> cool
20:45:46 <SamB> sorear: I thought it just had DLLs loaded willy-nilly
20:45:51 <allbery_b> idiot irc client thinks "a-b" is equivalent to "a_b"
20:45:54 <Cale> Yeah, it's been a really long time since I've done anything other than shut down a windows machine :)
20:45:56 <SamB> because they had preferred bases all over the address space
20:46:15 <mgsloan> glguy - yeah, 99% of all binary searches have that bug :)
20:46:16 <SamB> though maybe with Vista it's just because Vista is *supposed* to do that
20:46:48 <sorear> SamB: I think DLLs go in a different chunk of address space than user heaps.  (but you're *really* getting into flaky memory now)
20:49:17 <SamB_XP_> sorear: I'm not aware of any such thing
20:49:25 <SamB_XP_> I've only heard of a 3G/1G split
20:58:21 <bos> i'm writing about folds in the haskell book at the moment.
20:58:48 <ddarius> Yay folds! ... (?)
20:59:12 <shachaf> bos: Do you have any idea when parts of it will start to become available (just curious)?
20:59:13 <bos> i'd like to be able to present something fairly simple like takeWhile written in terms of foldr.
20:59:19 <bos> shachaf: in a month or so?
20:59:23 * wli was hoping for more about monads, arrows, MPTC, TH, GADT's, et al.
20:59:35 <bos> wli: gotta run before we can walk.
20:59:46 <shachaf> bos: Oh, OK.
21:00:01 <bos> but the problem with takeWhile is early exit.  it wants a continuation-style fold. bleugh.
21:00:23 <wli> bos: Converting a decimal digit string to a machine number?
21:00:43 <bos> wli: nice.
21:01:08 <ddarius> bos: filter?
21:01:11 <chessguy> by machine number, you mean binary?
21:01:14 <glguy> > let tw pred xs = foldr (\x xs -> if pred x then x : xs else []) [] xs in takeWhile (<3) [1..10]
21:01:16 <lambdabot>  [1,2]
21:01:18 <glguy> err
21:01:20 <glguy> > let tw pred xs = foldr (\x xs -> if pred x then x : xs else []) [] xs in tw (<3) [1..10]
21:01:21 <wli> chessguy: Integer
21:01:22 <lambdabot>  [1,2]
21:01:26 <glguy> bos: ^^
21:01:31 <bos> ddarius: yes, i'm already presenting filter.
21:01:33 <chessguy> oh
21:01:51 <mauke> > (\p -> foldr (\x z -> if p x then x : z else []) []) (<3) [1,2,3,4,1,2,3,4]
21:01:52 <lambdabot>  [1,2]
21:01:58 <glguy> mauke: ^^ ;)
21:01:59 <bos> glguy: that's what i already have, but it doesn't exit early.
21:02:08 <glguy> bos how do you mean?
21:02:09 <mauke> > (\p -> foldr (\x z -> if p x then x : z else []) []) (<3) [1 ..]
21:02:11 <lambdabot>  [1,2]
21:02:19 <mauke> yes, it does
21:02:31 <ddarius> @src takeWhile
21:02:31 <lambdabot> takeWhile _ []                 =  []
21:02:31 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
21:02:31 <lambdabot>                    | otherwise =  []
21:02:42 <bos> glguy: it examines every element in the list
21:02:43 <glguy> > let tw pred xs = foldr (\x xs -> if pred x then x : xs else []) [] xs in tw (<3) $ 1 : 2 : 3 : error "no dice"
21:02:44 <lambdabot>  [1,2]
21:02:47 <glguy> bos: nope...
21:02:53 <chessguy> > let x' = read x; y' = read y in foldr (\x y -> x * 10 + y')
21:02:54 <lambdabot>   Not in scope: `y'
21:03:13 <chessguy> > let x' = read x; y' = read y in foldr (\x y -> x' * 10 + y') 1 "1234"
21:03:14 <lambdabot>   Not in scope: `y'
21:03:41 <mauke> no dynamic scoping for you
21:03:47 <wli> foldl' (\y x -> ord x - ord '0' + 10 * y) 0 "213"
21:03:48 <chessguy> > foldr (\x y -> read x * 10 + read y) 1 "1234"
21:03:49 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
21:03:57 <chessguy> bah
21:04:04 <glguy> wli: digitToInt and intToDigit are in Data.Char
21:04:07 <chessguy> > foldr (\x y -> ord x * 10 + ord y) 1 "1234"
21:04:07 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
21:04:08 <glguy> if you want a shortcut
21:04:11 <ddarius> Dynamic scoping and lazy evaluation... that would be sick.
21:04:18 * chessguy sighs
21:04:31 <glguy> Haskell has dynamically scoped vars
21:04:31 <mauke> > foldr (\x z -> digitToInt x * 10 + z) 0 "1234"
21:04:33 <lambdabot>  100
21:04:35 <glguy> :t ?x
21:04:37 <lambdabot> forall t. (?x::t) => t
21:04:53 <chessguy> mauke, 1 not 0
21:04:59 <mauke> I doubt that
21:05:01 <ddarius> glguy: Those aren't quite the same and they're pretty nasty too.
21:05:12 <glguy> > let tw pred xs = foldr (\x xs -> if pred x then x : xs else []) [] xs in tw (<3) [1..] -- this example shows they don't touch any more than they need to
21:05:14 <lambdabot>  [1,2]
21:05:40 <mauke> > foldl (\z x -> z * 10 + digitToInt x) 0 "1234"
21:05:41 <lambdabot>  1234
21:05:43 <chessguy> mauke, hm. you're right
21:05:54 <bos> glguy: you're right. i wonder what i was smoking at midnight last night.
21:05:58 <ddarius> It's clearly correct given the source of takeWhile and the universal property of foldr.
21:06:25 <glguy> ?src takeWhile
21:06:25 <lambdabot> takeWhile _ []                 =  []
21:06:25 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
21:06:25 <lambdabot>                    | otherwise =  []
21:08:01 <glguy> > filt pred xs = foldr (\x -> if pred x then (x:) else id) [] xs in filt odd [1..10]
21:08:01 <lambdabot>  Parse error
21:08:12 <glguy> > let filt pred xs = foldr (\x -> if pred x then (x:) else id) [] xs in filt odd [1..10]
21:08:13 <lambdabot>  [1,3,5,7,9]
21:09:24 <chessguy> cute one, glguy
21:09:49 <glguy> I guess I should avoid shadowing Enum's pred though :)
21:10:29 <chessguy> just use p, then noone will know what it stands for
21:10:58 <chessguy> not like anyone in comp sci knows what a predicate is
21:10:59 <mauke> p stands for real ultimate power
21:12:23 <glguy> chessguy: you forgot your <sarcasm> tags ;)
21:12:39 <SamB_XP_> glguy: you don't often need those
21:12:49 <chessguy> pff, you can hear it dripping off my letters
21:13:19 <SamB_XP_> or in fact that what he said is almost exactly the opposite of the truth?
21:13:24 <glguy> ohh, that's what that was!
21:13:30 <glguy> obviously I was joking
21:13:33 <glguy> :-p
21:13:50 <ddarius> What's a predicate?
21:13:58 <chessguy> @all-dict predicate
21:13:59 <lambdabot> *** "Predicate" gcide "The Collaborative International Dictionary of English v.0.48"
21:14:00 <lambdabot> Predicate \Pred"i*cate\, v. i.
21:14:00 <lambdabot>    To affirm something of another thing; to make an affirmation.
21:14:00 <lambdabot>    --Sir M. Hale.
21:14:00 <lambdabot>    [1913 Webster]
21:14:01 * SamB_XP_ rolls eyes
21:14:01 <lambdabot> [88 @more lines]
21:14:10 <chessguy> @more
21:14:11 <lambdabot>  
21:14:11 <lambdabot> *** "Predicate" gcide "The Collaborative International Dictionary of English v.0.48"
21:14:11 <lambdabot> Predicate \Pred"i*cate\, n. [L. praedicatum, neut. of
21:14:11 <lambdabot>    praedicatus, p. p. praedicare: cf. F. pr['e]dicat. See
21:14:11 <lambdabot>    {Predicate}, v. t.]
21:14:13 <lambdabot> [83 @more lines]
21:14:15 <glguy> ?remember ddarius What's a predicate?
21:14:15 <lambdabot> Done.
21:14:19 <sioraiocht> @more
21:14:20 <chessguy> oh that clears it up
21:14:30 <SamB_XP_> yes really
21:14:42 <SamB_XP_> @hacker predicate
21:14:42 <lambdabot> Unknown command, try @list
21:14:50 <SamB_XP_> @jargon predicate
21:14:51 <lambdabot> No match for "predicate".
21:15:07 <SamB_XP_> @help dict
21:15:07 <lambdabot> I perform dictionary lookups via the following 13 commands:
21:15:08 <lambdabot> all-dicts ... Query all databases on dict.org
21:15:08 <lambdabot> devils ...... The Devil's Dictionary
21:15:08 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
21:15:08 <lambdabot> elements .... Elements database
21:15:09 <lambdabot> [9 @more lines]
21:15:12 <SamB_XP_> @more
21:15:12 <lambdabot> foldoc ...... The Free On-line Dictionary of Computing
21:15:13 <lambdabot> gazetteer ... U.S. Gazetteer (1990)
21:15:15 <lambdabot> hitchcock ... Hitchcock's Bible Names Dictionary (late 1800's)
21:15:17 <lambdabot> jargon ...... Jargon File
21:15:20 <lambdabot> lojban ...... Search lojban.org
21:15:20 <sioraiocht> @devils puritanism
21:15:21 <lambdabot> [4 @more lines]
21:15:23 <lambdabot> No match for "puritanism".
21:15:25 <chessguy> by the way, someone at work made fun of me the other day for including the tags when i said "<soup-nazi voice> No points for you! </soup-nazi voice>
21:15:26 <SamB_XP_> @foldoc predicate
21:15:28 <lambdabot> No match for "predicate".
21:15:46 <chessguy> @hitchcock Jezebel
21:15:47 <lambdabot> *** "Jezebel" hitchcock "Hitchcock's Bible Names Dictionary (late 1800's)"
21:15:47 <lambdabot> Jezebel, chaste
21:15:47 <lambdabot>  
21:15:50 <ray> i seem to have this crazy idea that a predicate is a function that returns a boolean
21:15:53 <chessguy> hahaha
21:15:53 <SamB_XP_> chessguy: did you say that allowed?
21:16:03 <SamB_XP_> ray: hahahahaha
21:16:13 <SamB_XP_> chessguy: aloud, I mean
21:16:15 <chessguy> SamB_XP_, no, in a forum
21:16:16 <monochrom> What's wrong with that?
21:16:28 <SamB_XP_> monochrom: with what?
21:16:44 <lament> @hitchcock hitchcock
21:16:45 <lambdabot> No match for "hitchcock".
21:16:50 <shachaf> @devils potable
21:16:52 <lambdabot> *** "POTABLE" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
21:16:52 <lambdabot> POTABLE, n.  Suitable for drinking.  Water is said to be potable;
21:16:52 <lambdabot> indeed, some declare it our natural beverage, although even they find
21:16:52 <lambdabot> it palatable only when suffering from the recurrent disorder known as
21:16:52 <lambdabot> thirst, for which it is a medicine.  Upon nothing has so great and
21:16:54 <lambdabot> [6 @more lines]
21:17:03 <sioraiocht> @devils belladonna
21:17:03 <SamB_XP_> @more
21:17:04 <lambdabot> *** "BELLADONNA" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
21:17:04 <lambdabot> BELLADONNA, n.  In Italian a beautiful lady; in English a deadly
21:17:04 <lambdabot> poison.  A striking example of the essential identity of the two
21:17:04 <lambdabot> tongues.
21:17:04 <lambdabot>  
21:17:10 <monochrom> with "predicate is a function returning boolean"
21:17:16 <chessguy> @devils jezebel
21:17:17 <lambdabot> No match for "jezebel".
21:17:26 <SamB_XP_> @devils hate
21:17:27 <lambdabot> No match for "hate".
21:17:29 <SamB_XP_> @devils love
21:17:31 <lambdabot> *** "LOVE" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
21:17:31 <lambdabot> LOVE, n.  A temporary insanity curable by marriage or by removal of
21:17:31 <lambdabot> the patient from the influences under which he incurred the disorder.
21:17:31 <lambdabot> This disease, like _caries_ and many other ailments, is prevalent only
21:17:31 <lambdabot> among civilized races living under artificial conditions; barbarous
21:17:33 <lambdabot> [4 @more lines]
21:17:34 <SamB_XP_> @more
21:17:35 <lambdabot> nations breathing pure air and eating simple food enjoy immunity from
21:17:38 <lambdabot> its ravages.  It is sometimes fatal, but more frequently to the
21:17:39 <lambdabot> physician than to the patient.
21:17:41 <lambdabot>  
21:17:50 <sioraiocht> @devils sex
21:17:52 <lambdabot> No match for "sex".
21:17:54 <sioraiocht> booo
21:17:58 <ray> i had a bertrand russel dictionary once that said for optimism: see pessimism
21:18:36 <chessguy> @remember lambdabot *** "Jezebel" hitchcock "Hitchcock's Bible Names Dictionary (late 1800's)": Jezebel, chaste
21:18:36 <lambdabot> Done.
21:19:03 <sioraiocht> @devils piano
21:19:04 <lambdabot> *** "PIANO" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
21:19:04 <lambdabot> PIANO, n.  A parlor utensil for subduing the impenitent visitor.  It
21:19:04 <lambdabot> is operated by pressing the keys of the machine and the spirits of the
21:19:04 <lambdabot> audience.
21:19:04 <lambdabot>  
21:19:09 <sioraiocht> lol
21:19:11 <sioraiocht> fantastic
21:19:20 * SamB_XP_ thought jezebel meant evil, power-hungry queen
21:19:41 <chessguy> SamB_XP_, among other things
21:19:46 <SamB_XP_> @devils music
21:19:47 <lambdabot> No match for "music".
21:19:57 <SamB_XP_> @devils hunger
21:19:58 <lambdabot> No match for "hunger".
21:20:04 <SamB_XP_> @devils
21:20:12 <chessguy> @devils chess
21:20:14 <lambdabot> No match for "chess".
21:20:16 <chessguy> boo
21:20:17 <SamB_XP_> @devils play
21:20:18 <lambdabot> No match for "play".
21:20:20 <TSC> @devils corporation
21:20:21 <lambdabot> *** "CORPORATION" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
21:20:21 <lambdabot> CORPORATION, n.  An ingenious device for obtaining individual profit
21:20:21 <lambdabot> without individual responsibility.
21:20:21 <lambdabot>  
21:20:43 <chessguy> lol
21:20:43 <SamB_XP_> @devils work
21:20:44 <lambdabot> No match for "work".
21:20:45 <TSC> see also government (:
21:20:51 <SamB_XP_> @devils government
21:20:52 <lambdabot> No match for "government".
21:20:56 <SamB_XP_> @devils law
21:20:57 <lambdabot> *** "LAW" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
21:20:58 <lambdabot> LAW, n.
21:20:58 <lambdabot>  
21:20:58 <lambdabot>     Once Law was sitting on the bench,
21:20:58 <lambdabot>         And Mercy knelt a-weeping.
21:20:59 <lambdabot> [13 @more lines]
21:21:04 <SamB_XP_> @more
21:21:04 <lambdabot>     "Clear out!" he cried, "disordered wench!
21:21:04 <lambdabot>         Nor come before me creeping.
21:21:05 <lambdabot>     Upon your knees if you appear,
21:21:08 <lambdabot>     'Tis plain your have no standing here."
21:21:09 <lambdabot>  
21:21:12 <lambdabot> [8 @more lines]
21:21:26 <SamB_XP_> @more
21:21:27 <lambdabot>     Then Justice came.  His Honor cried:
21:21:27 <lambdabot>         "_Your_ status? -- devil seize you!"
21:21:27 <lambdabot>     "_Amica curiae,_" she replied --
21:21:27 <lambdabot>         "Friend of the court, so please you."
21:21:27 <lambdabot>     "Begone!" he shouted -- "there's the door --
21:21:29 <mgsloan> government is the same as the corporation definition, except with power rather than wealth
21:21:29 <lambdabot> [3 @more lines]
21:21:44 <mgsloan> though the two often go hand in hand
21:21:49 <SamB_XP_> @more
21:21:49 <lambdabot>     I never saw your face before!"
21:21:49 <lambdabot>                                                                   G.J.
21:21:49 <lambdabot>  
21:22:23 <chessguy> that's....uh. interesting
21:22:33 <SamB_XP_> that's just plain SAD
21:23:13 <OceanSpray> how come #haskell has more people than #scheme ?
21:23:22 <OceanSpray> Isn't Haskell the more esoteric of the two?
21:23:25 <glguy> netcraft confirms that scheme is dying
21:23:26 <psykotic> wow, iambic quadrameter.
21:23:38 <SamB_XP_> OceanSpray: dunno!
21:23:43 <chessguy> @losers
21:23:43 <lambdabot> Maximum users seen in #haskell: 352, currently: 327 (92.9%), active: 15 (4.6%)
21:23:54 <SamB_XP_> glguy: how does netcraft know?
21:23:56 <ray> because haskell is more practical than scheme!
21:24:03 <glguy> OceanSpray: Haskell is on the way in, Scheme is on its way out?
21:24:09 <psykotic> SamB, it's an old slashdotism
21:24:09 <OceanSpray> NO WAI
21:24:17 <psykotic> netcraft confirms that X is dying
21:24:30 <glguy> SamB_XP_: so are you going to hold a seminar on sarcasm?
21:24:50 <SamB_XP_> I'm not going to anglohaskell
21:25:08 <SamB_XP_> because, uh, I'm in south-east pennsylvania
21:25:42 <chessguy> @quote pennsylvania
21:25:42 <lambdabot> chessguy says: i didn't think pennsylvania had anybody cool enough to know haskell in it
21:26:03 <mgsloan> @define esoteric
21:26:08 <lambdabot> Undefined.
21:26:10 <mrd> there's a few pennsylvanians in here
21:26:13 <mgsloan> teehee
21:27:10 <dons> OceanSpray: http://www.cse.unsw.edu.au/~dons/irc/
21:27:11 <lambdabot> Title: Haskell IRC Activity
21:27:25 <glguy> OceanSpray: but anyway, Haskell is far from 'esoteric' , its one of the leading functional programming languages
21:27:39 <dons> ooh, i note we've almost reached the user count for the entire year of 2006, in the first 7 months of 07
21:28:03 <OceanSpray> huh
21:28:06 <SamB_XP_> dons: it's the eighth month
21:28:25 <SamB_XP_> I remember because this is the one with my birthday in it
21:28:31 <dons> indeed, SamB_XP_. `inclusive' was what i was interested in.
21:28:44 <slava> there's definitely been an upswing in interest in haskell lately.
21:28:49 <dons> i suspect we'll be past the cout by the 8th month.
21:29:04 <mrd> i figured out why hs-plugins was being weird about reloading dependencies
21:29:08 <SamB_XP_> in time for my birthday?
21:29:11 <mgsloan> 'esoteric' does imply something deeper and more complicated, though, which haskell is in comparison to scheme
21:29:12 <dons> mrd: oh?
21:29:16 <mrd> it sets -odir to the working dir of the target
21:29:17 <ddarius> slava: By lately, you mean the past couple of years.
21:29:27 <chessguy> SamB_XP_, when is your birthday?
21:29:42 <SamB_XP_> chessguy: the 26th
21:29:46 <mrd> there's a comment in there to the effect of it screwing hier modules but it also screws with modules in different dirs
21:29:46 <dons> mgsloan: true, i guess C++ is esoteric too (which makes a nice case for large languages working)
21:29:47 <chessguy> heh
21:29:50 <chessguy> the day before mine
21:29:59 <SamB_XP_> as it says on my facebook profile
21:30:08 <mrd> anyway, simple workaround: swap the order i listed the load directories
21:30:09 <mgsloan> dons - yeah, C++ is a jungle
21:30:15 <SamB_XP_> now if only I had a decent mug to put up
21:30:27 <mrd> this way, even though it puts the .o file in the wrong place, now it looks for it there first
21:30:51 <glguy> esoteric
21:30:51 <glguy> adjective
21:30:51 <glguy> Beyond the understanding of an average mind
21:30:59 <glguy> Hmm... maybe it is
21:31:03 <psykotic> dons: did you see my idea about smarter reloading/recompiling in the thread about joel's blog?
21:31:11 <SamB_XP_> glguy: interesting!
21:31:12 <psykotic> dons: i wonder how hard something like that would be to implement. it seems like it could be quite useful.
21:31:22 <SamB_XP_> that would explain why esolangs are called that
21:31:33 <SamB_XP_> and here I thought it was just because they were wierd
21:31:56 <glguy> Intended for or understood by only a particular group: an esoteric cult.
21:32:17 * glguy feels so superior
21:32:17 <mgsloan> yeah, the other connotation of esoteric is that it is known by only a few
21:32:50 <SamB_XP_> hmm, why doesn't the C exit() function have return type a ;-)
21:33:10 <ray> it does, it's just C spells "a" differently
21:33:12 * SamB_XP_ was just looking at this again
21:33:15 <SamB_XP_> http://pahtak.org/~steve/quine.txt
21:33:39 <SamB_XP_> ray: then what's with the , 1 in the final "while"?
21:34:26 <ray> clearly, that program makes no sense at all
21:34:34 <SamB_XP_> well, yes.
21:34:40 <ray> :)
21:34:46 <SamB_XP_> it does use a function as scratchspace, after all...
21:36:11 <mgsloan> the 1 is for the while
21:36:16 <ray> i assume it's to make it exit() again if exit() fails
21:36:41 <mgsloan> the comma chains expressions
21:38:10 <monochrom> Imagine you take >>
21:38:13 <monochrom> @type >>
21:38:15 <lambdabot> parse error on input `>>'
21:38:19 <monochrom> @type (>>)
21:38:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
21:38:48 <monochrom> And you restrict its type to m a -> m a -> m a. Disallow different types.
21:39:05 <monochrom> The result is C's comma.
21:39:15 <mauke> no, C is a -> b -> b
21:39:31 <mgsloan> until you go to C++, then comma is overloadable ;)
21:39:37 <dons> psykotic: yeah, i quite like that idea.
21:39:41 <dons> fine grained reloading.
21:39:53 <dons> i queries joel to tease out what his problem was, since that's not clear
21:39:54 <mm_freak> comma is overloadable in C++?
21:39:57 <lament> mgsloan: are you serious??
21:39:59 <mgsloan> yep
21:40:01 <mauke> mm_freak: yes
21:40:04 <dons> psykotic: ghc hq's been somewhat interested in faster reloading
21:40:12 <psykotic> dons: yep, although it wasn't just in response to joel. i've been wanting this myself.
21:40:14 <ray> mgsloan: that's truly demented
21:40:17 <dons> usually the trick is -Onot (from compilation) to avoid .hi file unfoldings
21:40:18 <mgsloan> indeed
21:40:22 <dons> which mean less stuff gets hauled in
21:40:23 <mm_freak> ?:, comma and () should be non-overloadable
21:40:23 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
21:40:26 <psykotic> right now it's kind of coarse grained about how it does it. it's often i bulk import something and only use a few exports.
21:40:35 <mauke> mm_freak: () should definitely be overloadable
21:40:36 <lament> ray: in some other channel it would be, in #haskell maybe not
21:40:39 <mgsloan> you can also overload function parenthesis, but that's more useful
21:40:43 <dons> psykotic: probably worth a proposal/query to glasgow-haskell-users@, cc me and spj. to find out what hte state of things is at the moment.
21:40:47 <mm_freak> i must have missed something
21:40:48 <lament> mgsloan: how does it play with the for loops?
21:40:50 <psykotic> dons: okay, thanks./
21:40:50 <ray> it's not haskell-demented, though
21:41:04 <dons> psykotic: so sort of like how we use split objs for minimal linking, you want minimal recompilation based on a more fine grained unit
21:41:06 <lament> well, C++ does NOT redefine the semicolon! :)
21:41:10 <monochrom> Here in Haskell we actually want [] : "" to be overloadable!
21:41:17 <mgsloan> lament - oh, well, the overloading is type based
21:41:19 <ray> semicolon should be overloadable
21:42:01 <psykotic> dons: i don't think you need to change how the linking works. right now if you do a select import of a few exports, and an export is changed which isn't imported, the client module doesn't have to recompile.
21:42:11 * glguy makes a note: *avoid ray's source code*
21:42:28 <psykotic> dons: so it's really just a matter of making it smarter about bulk imports. namely, keep a list of what imported definitions are _actually_ referenced in the source code for the client module.
21:42:28 <monochrom> what's wrong with ray's source code again? commas?
21:42:35 <glguy> overloaded ;
21:42:41 <mm_freak> mauke: how can that work?  how would you even define such an operator?
21:42:49 <monochrom> Well that's Haskell's >>= and very overloadable.
21:43:04 <mauke> mm_freak: R operator()(A x, B y) { ... }
21:43:08 <glguy> monochrom: that would be one specific context :-p
21:43:20 <monochrom> ray would make a great Haskeller.
21:43:20 <mm_freak> mauke: two arguments?!
21:43:25 <lament> C++ seems better and better :)
21:43:29 <ray> haha
21:43:38 <mauke> mm_freak: just an example. you can use any number of arguments
21:43:40 <lament> i didn't realize it was so, er, powerful
21:44:08 <ray> it's like shooting yourself in the foot
21:44:09 <mm_freak> mauke: when would that operator apply?
21:44:15 <lament> can you give a practical example of why would you overload ()?
21:44:16 <mgsloan> it's also possible to do things like cout << 5 sum 6;
21:44:22 <mgsloan> though very hacky to implement
21:44:33 <glguy> lament: you could make an object that acted like a function
21:44:34 <ray> where haskell is surgically amputating your foot with modern medical techniques
21:44:40 <mauke> mm_freak: when saying obj(x, y) where obj belongs to a class with overloaded operator()
21:44:59 <lament> glguy: i suppose that makes a lot of sense actually.
21:45:00 <mgsloan> lament - with a class which represents a polynomial you could write f(1.5) to query the value at 1.5
21:45:00 <SamB_XP_> ray: you mean like dead code elimination?
21:45:09 <Cale> C++ gives you tools you can use to create pretty cool abstractions, but you generally have to do pretty insane things
21:45:10 <mm_freak> mauke: so it's essentially just another constructor notation?
21:45:17 <monochrom> dead foot elimination :)
21:45:21 <mm_freak> or is `obj' an object?
21:45:22 <lament> I suppose Python has the same thing
21:45:33 <mauke> mm_freak: no, it's function call notation
21:45:35 <lament> Cale: sounds like Forth
21:45:38 <SamB_XP_> ray: the Haskell compiler obviously noticed that you never at any point USE your foot, and so you clearly didn't need it
21:46:07 <ray> clever of it :)
21:46:09 <mm_freak> mauke: ah ok
21:46:22 <reffie> why is "nub" called "nub?
21:46:24 <reffie> "
21:46:25 <monochrom> overloading () allows you to emulate higher-order functions and anonymous functions etc.
21:46:27 <dons> ray> semicolon should be overloadable (you realise >>= is ; in do notation, and is overridable :)
21:46:31 <mm_freak> mauke: i thought it would overload parentheses for changing priority =)
21:46:32 <mgsloan> yes, lets not base robot AI off haskell comilers
21:46:39 <mm_freak> that wouldn't make much sense to me
21:46:42 <ray> dons: yeah
21:46:48 <lament> three laws of robotics:
21:46:54 <lament> 1) don't do anything unless you ABSOLUTELY HAVE TO
21:46:57 <ray> it's an "advantage" over c++
21:46:58 <glguy> nub  n.  The essence; the core: the nub of a story.
21:47:00 <mauke> mm_freak: those aren't operators
21:47:04 <lament> 2) ...other laws to be written as they become required
21:47:19 <monochrom> hahahahahha
21:47:25 <SamB_XP_> hahahaha
21:47:39 <mgsloan> I can make a robot that works within those laws
21:47:44 * mgsloan holds up pencil
21:48:06 <monochrom> @remember lament three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
21:48:06 <lambdabot> Done.
21:48:08 <glguy> lament: so the robot laws make use of lazy evaluation?
21:48:13 <mm_freak> however, what happens, when overloading the comma?  does it apply to expressions like (a,b,c) ?
21:48:25 <SamB_XP_> glguy: oh, yes, very lazy
21:48:34 <monochrom> robots are lazy
21:48:44 <monochrom> those damned robots are so lazy
21:48:49 <SamB_XP_> these robats are like "IGNORE ALL HUMANS"
21:48:52 <Korollary> Robots don't "have to" do anything.
21:48:57 <Korollary> but that takes the fun out
21:49:06 <SamB_XP_> Korollary: they like to remain under power
21:49:15 <lament> that's not a given!
21:49:19 <monochrom> they like to remain in power
21:49:19 <SamB_XP_> I think they also don't count playing video games as doing something
21:49:40 <mauke> mm_freak: yes
21:50:40 <Korollary> google ad at programming.reddit.com: "gay travel in Patagonia..." wtf?
21:50:51 <reffie> what!
21:50:57 * glguy doesn't do "ads"
21:51:07 <SamB_XP_> obviously, google thinks programming.reddit.com is becoming a bit gay
21:51:15 <Korollary> glguy: You miss out on entertainment like this.
21:51:33 <glguy> Korollary: its a risk that keeps me up at night :-/
21:51:33 <ray> i know i miss out on a lot by having spam filters
21:51:36 <Korollary> The next ad is "Automatic Door Operator"
21:51:46 <monochrom> robots!
21:52:00 <Korollary> That have to open doors!
21:52:15 <ray> lazy door openers
21:52:22 <SamB_XP_> Korollary: they are under threat of having their allowances taken away if they don't do it
21:52:35 <Korollary> It's the comments for "C++'s placement new". I think google got confused by C++'s "operator"s.
21:53:03 <ray> the lazy door opener could just always hold the door open
21:53:50 <monochrom> hahhahahaha true!
21:54:43 <SamB_XP_> do you know what happens to such lazy door openers?
21:56:06 <SamB_XP_> they get layed off, and replaced by rocks or bricks
21:56:13 <lament> a haskell-kind-of-lazy door opener would open a door whenever somebody wants to go through, and do nothing otherwise. As opposed to one that just kept opening and closing the door for no reason.
21:57:02 <SamB_XP_> lament: wouldn't it close the door when it started to rain, too?
21:57:04 <ray> who said it wasn't a rock already?
21:57:04 <johnnowak> i think it would just open the door once and be done with it
21:58:07 <RyanT5001> is there any way to import external data? specifically, i'd like to import a foreign function pointer (and NOT turn it into a usable haskell function)
21:58:11 <Korollary> In a Haskell world, the door may be opened after you are already inside. The order doesn't matter.
21:58:49 <monochrom> You can lay off the rock and use thick cardboard paper
21:58:51 <SamB_XP_> Korollary: so we can evaluate an expression to WHNF after casing over it?
21:59:29 <mgsloan> Korollary - yeah, it's too bad we're inside the RealWorld
21:59:50 <monochrom> If you case over it, recall that you still have the choice of irrefutable patterns.
21:59:57 <SamB_XP_> RyanT5001: foreign import "&exit" :: FunPtr (CInt -> IO ()) ?
22:00:12 <RyanT5001> SamB_XP_: ah, yeah, i think that'll work
22:00:56 <mgsloan> yet also in this haskell world, if you trigger an error, the universe esplodes
22:01:15 <RyanT5001> mgsloan: maybe only half the universe!
22:01:32 <mgsloan> yeah, perhaps only half, until it gets caught
22:01:43 <RyanT5001> :)
22:01:50 <ray> well, it was explode or get garbage collected
22:02:04 <SamB_XP_> monochrom: if you use irrefutable patterns, you run the risk of bumping your nose on the door
22:02:04 <RyanT5001> to be fair, most languages explode a lot when they have errors
22:02:05 <mgsloan> maybe it only takes out your house if you applied proper catch measures
22:02:13 <mgsloan> true
22:02:26 <monochrom> haha
22:03:04 <lament> python is nice
22:03:08 <lament> python never has errors
22:03:28 <lament> unless you extend it with evil C code
22:03:37 <Korollary> In an STM Haskell world, multiple people can attempt to open/close the same door and eventually they'll go in/out.
22:03:38 <RyanT5001> lament: i hope you aren't serious
22:03:48 <glguy> heh, Ryan got older
22:03:53 <glguy> or upgraded
22:03:57 <lament> even syntax errors aren't actually errors, and they will be caught at run time
22:03:57 <glguy> maybe he's a robot
22:04:09 <RyanT5001> glguy: i'm referentially transparent
22:04:39 <RyanT5001> glguy: no, actually this is just my fallback nick for when i somehow get logged in twice at once
22:04:55 <RyanT5001> /name RyanT5000
22:05:01 <RyanT5001> er, how do i change it back again?
22:05:01 <monochrom> Ryan demonstrates STM! :)
22:05:04 <lament> for example (formatting and newlines removed)  "try: *&)*<*(>P  except: print 'oops'" will happily print oops
22:05:34 <Korollary> that wasn't hygienic
22:05:47 <SamB_XP> I meant to SAY /nick RyantT5000
22:05:56 <SamB_XP> I obviously forgot to quote the slash
22:06:01 <RyanT5001> SamB_XP: yeah, that's what i thought it was; it isn't working
22:06:12 <SamB_XP> RyanT5000: well it worked for ME
22:06:12 <mauke> lament: no, it doesn't
22:06:17 <RyanT5000> SamB_XP: ok, now it worked; GAIM is weird
22:07:03 <glguy> /test
22:07:10 <RyanT5000> the worst part is that GAIM shows me as RyanT5000 to myself no matter what
22:07:19 <glguy> I did that with /msg #haskell /test
22:07:19 <RyanT5000> so i never know whether i've "transcended" :P
22:07:25 <glguy> but is there an easier way in irssi?
22:07:32 <mauke> / /like this
22:07:36 <SamB_XP> //test  doesn't work
22:07:38 <SamB_XP> ?
22:08:01 <glguy> I mean if you wanted to send the literal "/" and not " /" or some variation
22:08:15 <mauke> yes, you just say / /
22:08:26 <SamB_XP> that's a strange way to go
22:08:28 <lament> mauke: well, okay, maybe not that particular example :D
22:08:37 <lament> "it always works, except today"
22:08:39 <maskd> /say /test
22:08:46 <glguy> /that works
22:09:07 <mauke> /disco
22:09:29 <SamB_XP> lament: when and where did you learn Python?
22:09:41 <SamB_XP> or should I say ... when did you unlearn Python?
22:10:02 <RyanT5000> SamB_XP: maybe you should say "when did you learn unPython?"
22:10:28 <lament> SamB_XP: don't you remember me from #python?
22:10:39 <SamB_XP> yeah
22:10:44 <SamB_XP> what's #python?
22:11:12 * SamB_XP wonders if he wants to know the answer
22:11:21 * SamB_XP decides he probably does not
22:11:41 <lament> wow, the psychological trauma must have been really deep for you to have forgotten everything
22:11:52 <mgsloan> tis a channel where men get together and talk about, well, you know..
22:12:00 <SamB_XP> no. I was trying to imply that it's not what it used to be ;-)
22:12:07 <SamB_XP> but I'm too tired to do that correctly
22:12:09 <lament> i haven't been there in years
22:12:14 <lament> so i don't know what it is
22:12:29 <lament> i remember it stopped being split in two and all the interesting people left
22:12:38 <SamB_XP> in which order?
22:12:43 <lament> i've no clue
22:12:50 <SamB_XP> anyway, I'm dreading that happening to #haskell
22:12:53 <lament> i just randomly entered the channel at some point, and realized both of those things
22:13:03 <dibblego> ?type mapM_
22:13:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
22:13:23 <SamB_XP> I notice some of the interesting people are in #twisted
22:13:39 <glguy> the channel was "split in two"?
22:13:43 <Korollary> What kind of "interesting" are we talking about?
22:13:49 <glguy> like #python and #python-non-noobs
22:13:49 <glguy> ?
22:13:56 <SamB_XP> glguy: worse
22:13:57 <dons> SamB_XP: I don't think that'll happen here unless maybe 300 newbs join suddnely
22:14:05 <SamB_XP> #python1 and #python2
22:14:08 <SamB_XP> or similar
22:14:08 <glguy> dons: quick, set a join limit!
22:14:08 <dons> even then we'd just kick heads till things settled down
22:14:23 <shapr> Plus the real reason the interesting people left #python was because the community started sucking so bad.
22:14:24 <Korollary> dons: I thought you were trying to get that 300 over here.
22:14:35 <dons> i'm happy we've scaled from 150 to 380 in a year and a half without too much trouble
22:14:46 <dons> maybe we have less really long threads in here than we used to, but otherwise its been ok
22:14:46 <SamB_XP> um
22:14:56 <SamB_XP> we're at 326 right now
22:15:07 <glguy> abort abort!
22:15:18 * olathe aborts by exploding.
22:15:24 <mauke> @type ?abort ?abort
22:15:26 <lambdabot> :t -> t1,
22:15:26 <lambdabot>         arising from use of implicit parameter `?abort'
22:15:26 <lambdabot>         at <interactive>:1:0-12
22:15:28 <SamB_XP> olathe: ewwww
22:15:34 <dons> heh
22:15:34 <SamB_XP> hahaha
22:16:06 <dons> dibblego: http://programming.reddit.com/info/2cynm/comments
22:16:07 <lambdabot> Title: Imperative programming is a just a special case of functional programming (reddi ...
22:16:17 <dibblego> dons, you stalking me? :)
22:16:20 <shapr> My siblings told my girlfriend that I never leave my apartment. I tried to explain to them that being in this community is like living in art museum all the time, but I don't think they got it.
22:16:21 <dons> google is
22:16:27 <dibblego> oh
22:16:32 <dons> shapr: hah
22:16:46 <SamB_XP> shapr: you should leave your apartment sometime
22:16:48 <RyanT5000> dons: also, functional programming is just a special case of imperative programming ;)
22:16:51 <shapr> SamB_XP: What for?
22:16:55 <lament> shapr: don't you unicycle?
22:17:06 <SamB_XP> another good point. don't you?
22:17:08 <shapr> lament: Not since I tore my tendon a few weeks back :-(
22:17:11 <dibblego> dons, I didn't write much substance; I expect it to be downvoted
22:17:13 <SamB_XP> oh.
22:17:16 <lament> shapr: oh ouch
22:17:19 <dons> dibblego: likely. we'll see.
22:17:27 <shapr> I was trying to show off for said girlfriend, and ...
22:17:34 <lament> shapr: you just gave a reason to leave the apartment though -- siblings
22:17:35 <SamB_XP> shapr: don't do that
22:17:41 <glguy> "Imperative programming is one specific type of functional programming that is seldom worth using."
22:17:43 <lament> SamB_XP: ah come on.
22:17:46 <glguy> dibblego: yeah... that's going to go over well
22:17:47 <glguy> ;)
22:17:55 <dons> dibblego: i'd probably toss in something about programmable semicolons :)
22:18:01 <dibblego> I really mean, "relatively seldom"
22:18:02 <SamB_XP> shapr: always show off things you can pull off ;-)
22:18:04 <lament> shapr: unless siblings live elsewhere :)
22:18:05 <shapr> lament: My siblings are all busy with their own lives. I'm 35, and they're 2.5, 7, and 11 years younger than me.
22:18:21 <Korollary> You can still beat them up
22:18:33 <glguy> dibblego: and "I don’t wish to elaborate on this statement right now, since I am still deciding how I will do it and I also know how this fact can fail to be recognised by many so I want to get it right."
22:18:40 <dons> dibblego: my take on this was http://programming.reddit.com/info/ox6s/comments/coxoh
22:18:41 <lambdabot> Title: Ask Reddit: What the hell are monads? (reddit.com)
22:18:55 <dibblego> glguy, that's why I expect it to be downvoted
22:19:01 <glguy> heh, yeah
22:19:19 <SamB_XP> pigs' wings? hell's air conditioner?
22:19:26 <Korollary> Why do you submit such blog entries anyway? Let the guy elaborate first.
22:19:41 <olathe> Are monads used for anything other than composing functions in strange ways or disappearing information ?
22:19:41 <dons> dibblego: do you want me to take it down?
22:19:49 <dons> if you want to expand on the thoughts
22:19:49 <dibblego> dons, I'm not bothered at all
22:19:59 <dibblego> I won't do it soon anyway
22:20:29 <slava> hey dibblego
22:20:34 <shapr> Seriously though, the depth of beauty in something like dependently typed system beats the crap out of the latest Harry Potter movie, or the latest Harry Potter book, or several hours at a restaurant...
22:20:34 <dibblego> hello slava
22:20:35 <dons> yeah, Korollary doesn't like us talking about stuff in public :)
22:20:44 <RyanT5000> we should be a secret society
22:20:51 <dons> shapr: haheh geek! :)
22:20:55 <glguy> Korollary: if it is on the blog, its eligible :-p
22:21:00 <dibblego> if someone doesn't like my failing to support my propositions, they are most welcome to support them themselves :)
22:21:00 <lament> shapr: i dunno, there's something to be said for smoking pot and playing drums on the beach.
22:21:03 * dibblego runs
22:21:05 <RyanT5000> The Keepers of the STG
22:21:11 <shapr> RyanT5000: It's easy to be a secret society when you want to talk about dependently typed systems. Nobody wants to hear about it :-)
22:21:20 <RyanT5000> shapr: :)
22:21:32 <dons> we need to get Conor blogging about epigram.
22:21:47 <shapr> lament: Only while talking about substructural type systems, yeah?
22:21:48 <dons> there's just not enough interesting material being written about
22:21:50 <RyanT5000> shapr: well, i'm interested in turning dependent type systems into something slightly more accessible
22:21:58 <Korollary> dons: No. I'd rather nominate more complete blog posts for general submission. For instance, sigfpe's posts. Posts that are just a few paragraphs turn into flamewars at reddit.
22:22:04 <lament> shapr: for instance.
22:22:15 <RyanT5000> shapr: i love proofs as much as the rest of you - well, maybe not *quite* as much - but i also like the documentation function of type systems
22:22:15 <SamB_XP> shapr: how do you smoke pot while talking about substructural type systems?
22:22:21 <lament> shapr: on a unicycle :)
22:22:24 <dons> Korollary: fair enough. actually, i note sigfpe is a bit quiet at the moment.
22:22:31 <shapr> SamB_XP: I think it's the only way to understand substructural type systems ;-)
22:22:31 <mgsloan> Korollary:that's because few read the longer ones
22:22:44 <dons> Korollary: so um, like the RLE one? :)
22:22:48 <Korollary> dons: I bet those things take quite a lot of his time to write. His last post combined a lot of different things.
22:22:51 <SamB_XP> shapr: I heard pot was bad for your brain
22:22:58 <shapr> But really, this community has all the prettiest mental toys.
22:23:11 <lament> very true
22:23:22 <shapr> SamB_XP: Yeah, it's true. I haven't done any pot in the last ... um, fifteen years at least.
22:23:42 <lament> well, there's also #esoteric, but i don't think you're talking about _that_ kind of "pretty" :)
22:23:56 <shapr> Esoteric has some good stuff too.
22:24:00 <SamB_XP> lament: I thought that "pretty" was called "ugly"
22:24:11 <shapr> I like Kolmogorov Complexity, and all of John Tromp's playground.
22:24:21 <SamB_XP> or did you mean those 2-dimensional languages
22:24:22 <SamB_XP> or worse
22:24:32 <SamB_XP> 3- or more dimensional
22:24:35 <lament> n-dimensional?
22:24:40 <dons> hmm. qwe hasn't posted in 3 days -- could he have been banned... ?
22:24:42 <shapr> I have thought about 3D languages.
22:24:52 <Korollary> dons: rehab probably
22:24:56 <dons> things have been strangely calm and devoid of massive downvotes.
22:24:56 <shapr> Korollary: haha
22:25:00 <lament> of course #haskell cheats and provides unlambda and brainfuck interpreters (supposedly)
22:25:02 <SamB_XP> isn't there a 3d befunge already, shapr ?
22:25:08 * mgsloan likes 2d langs
22:25:12 <lament> there's a 3d befunge, as well as n-d
22:25:13 <dons> Korollary: :)
22:25:13 <shapr> It'd be cool to teach babies to program by giving them building blocks that actually *do* something.
22:25:18 <glguy> 2d from ICFP2006 was nifty
22:25:27 <SamB_XP> @bf ,
22:25:28 <lambdabot>  fd:21: hClose: resource vanished (Broken pipe)
22:25:32 <mgsloan> 3d is cool but not very practical
22:25:34 <Korollary> mgsloan: The amount of work that goes into just understanding Haskell and related theory is astounding for most people.
22:25:34 <SamB_XP> glguy: not that kind of 2d language
22:26:00 <shapr> Yeah, but it's like moving into an art museum.
22:26:17 <SamB_XP> except without the naked ladies
22:26:18 * wli has gotten nowhere with signals and readline.
22:26:21 <olathe> Can Haskell implement languages that get all the compiling niceties of Haskell (laziness, culling dead code) ?
22:26:21 <shapr> The coolest part about Haskell is that it frees you from the machine, ya know?
22:26:28 <lament> shapr: you sound like a failed mathematician :)
22:26:31 <wli> Did anyone come up with a solution there?
22:26:38 <mgsloan> Korollary: I don't know.  I guess in totallity
22:26:40 <shapr> lament: I think I'm beginning to want to be a mathematician.
22:26:44 <mgsloan> haskell is harder than procedural
22:26:52 <dons> olathe: ?
22:26:57 <shapr> mgsloan: It's easier, simpler, closer to reality!
22:26:58 <Korollary> olathe: what do you mean by implement?
22:27:01 <mgsloan> (most procedural languages)
22:27:12 <SamB_XP> mgsloan: harder to understand, easier to use
22:27:12 <dons> people have implemented similar languages  in haskell, many of them in fact.
22:27:19 <mgsloan> shapr - yeah, at its core.  all the extra stuff makes it a bit crazier to understand
22:27:36 <lament> shapr: i strongly disagree
22:27:43 <shapr> Procedural programming isn't about *programming* it's about being both a puppet and puppet master for an arbitrary construction, usually the x86 architecture.
22:28:10 <Korollary> shapr: That's too harsh heh
22:28:12 <olathe> Like, if I implemented unlambda and I fed in an unlambda program that was somewhat inefficient, is there a way to apply the optimizations that a Haskell compiler applies to Haskell programs ?
22:28:16 <SamB_XP> I'm beginning to sympathize with Baughn (doesn't like the syntax) and fasta (sick of all the GHC bugs)
22:28:17 <mgsloan> haskell's closeness to reality is more of a philosophical discussion than anything else :P
22:28:24 <shapr> Korollary: I dunno, give me some counterpoint?
22:28:46 <lament> SamB_XP: how can somebody not like the syntax? I mean really :)
22:29:02 * johnnowak doesn't like the syntax
22:29:10 <SamB_XP> lament: it is pretty complicated :-(
22:29:13 <shapr> mgsloan: Well, math is found in reality, and Haskell is math. I've never seen a pointer in an arctic meadow.
22:29:33 <lament> shapr: computers are found in reality.
22:29:48 <SamB_XP> I'm not sure I've seen a rational in reality
22:29:57 <lament> shapr: programming, to most people, is giving instructions for a computer. Which directly translates to the imperative paradigm.
22:30:01 <mgsloan> shapr - oh, but you've seen thunks?
22:30:10 <shapr> mgsloan: heh
22:30:18 <SamB_XP> lament: I thought instructions weren't usually imperative
22:30:18 <RyanT5000> mgsloan: thunks don't exist in haskell; they exist in the haskell implementation
22:30:24 <Korollary> shapr: Well, firstly I don't think it has anything to do with the x86. It is 'programming' per the usual tarpit. However, lack of an effect system, or first class functions is a software engineering concern. Thus, sometimes procedural programming can be the right approach.
22:30:26 <johnnowak> pointers are just addresses/locations, which certainly exist
22:30:28 <mgsloan> true, true :)
22:30:48 <lament> "ah, playful monads in an arctic meadow on a sunny polar day..."
22:30:49 <mgsloan> yeah, C has nothing to do with x86
22:31:07 <SamB_XP> lament: sure, in real life instructions may be "do this, do that, etc." but often you don't follow them strictly in order...
22:31:21 <mgsloan> I've heard from those in the know about C that it's actually a rather minimal model of computation (perhaps not at the LC level, though)
22:31:22 <shapr> lament: I'd say most people in both reality and C try to solve the problem without ever understanding it. I think that fits ;-)
22:31:34 <johnnowak> and data certainly isn't persistent in real life either. when i put bread in my toaster, i don't get two toasters, one with toast and one without
22:32:19 <SamB_XP> johnnowak: you didn't see the little garbage men coming to take the one with no bread away?
22:32:29 <lament> SamB_XP: that's true, but still, it makes a lot more sense that a program is a series of orders, than that it's an expression to be evaluated
22:32:30 <Cale> johnnowak: Sure you do, it's just that one has been garbage collected by the universe. ;)
22:32:33 <Korollary> I don't know why real life is so relevant when it comes to programming. Say, we invent quantum computers. Does it mean we won't program them because there's no real life analog?
22:32:41 <johnnowak> i suppose C though is like having two toasters where putting toast in one causes it to appear in the other too.
22:32:57 <shapr> lament: I disagree, I think that's cultural programming on your part (and formerly on mine).
22:32:59 * mgsloan agrees with Korollary
22:33:16 <bitwize> cultural programming?
22:33:21 <SamB_XP> lament: do you not cook?
22:33:25 <olathe> johnnowak: You have a memory of the old state of the toaster.
22:33:32 <Heffalump> real life doesn't have virtual inheritance either
22:33:34 <SamB_XP> lament: I think you very well may not
22:33:37 <Heffalump> but it's a useful abstraction
22:33:45 <Heffalump> s/virtual inheritance/virtual dispatch/
22:34:04 <shapr> bitwize: I mean that continuations are only hard for most programmers because functions have always returned in everything they've done.
22:34:05 <lament> shapr: i disagree, but i'm too lazy to argue this in-depth
22:34:09 <mgsloan> could be handy though, use car controls to steer planes
22:34:10 * SamB_XP 's mom makes him cook a lot
22:34:15 <johnnowak> olathe: you don't know what i'm like in the morning, do you
22:34:29 <SamB_XP> shapr: hehe
22:34:32 <bitwize> shapr: mmhmm.
22:34:58 <shapr> I think that's the same reason that non-strictness is hard for most new Haskell programmers.
22:35:00 <SamB_XP> shapr: they don't have much GCC-fu then I guess ;-P
22:35:14 <bitwize> Now if you turn that on its ear you find that functions have always been called with an implicit continuation, which they jump to when they "return".
22:35:35 * SamB_XP understood CPS very well
22:35:40 <bitwize> Non-strictness is tough. Let's go C++-ing!
22:35:43 <RyanT5000> shapr: continuations = gotos made unharmful via reasonable scoping
22:35:54 <RyanT5000> shapr: well, taill calls anyway
22:36:00 <shapr> bitwize: So, it's hard for people to understand that things aren't really the way they've believed for years.
22:36:07 * SamB_XP understood it before becoming a Haskeller, or so he thinks
22:36:12 <bitwize> mmhmm.
22:36:15 <RyanT5000> shapr: continuations = labels
22:36:23 <shapr> RyanT5000: Sure, but try to explain that to the average joe on ##c or #python
22:36:48 <Korollary> Well, said people weren't "taught" lambda calculus properly anyway. It's hard to understand anything if you only have incomplete definitions and analogies.
22:36:51 <johnnowak> continuations aren't at all hard, but i have seen endless terrible attempts at explaining them
22:36:52 <SamB_XP> shapr: I'd rather try it in ##c, for sure
22:36:59 <glguy> in today's programming community.. "average joe" is a pretty low bar
22:36:59 <shapr> What I'm saying is that C, Python, Java, etc have been constrained by the machine, and thus it often constrains the users of those languages as well.
22:37:13 <mgsloan> you don't really need to know lambda calculus to understand such things
22:37:19 <SamB_XP> I think most of the n00bs *leave* ##c
22:37:33 <SamB_XP> I think #python is composed almost entirely of n00bs now
22:37:33 <pjd> RyanT5000: continuations are more than gotos with scoping
22:37:35 <mgsloan> in fact I think Lambda Calculus and the like are pretty useless for noobs to learn
22:38:07 <Korollary> Well, noobs develope a "sense" for some kinda operational semantics anyway. Then they get confused.
22:38:12 <pjd> they're more a dynamic equivalent of lexical gotos
22:38:18 <bitwize> I really think people ought to study Knuth.
22:38:20 <bitwize> Even noobs.
22:38:21 <lament> i still think haskell IS more difficult than imperative languages, not for cultural reasons but because it's more mathy, and math is difficult because it requires more symbolic manipulation-type of thinking than anything else
22:38:30 <SamB_XP> bitwize: ah, knuth
22:38:45 <RyanT5000> pjd: yeah
22:38:47 <lament> and symbolic manipulation just seems to be a very difficult thing for most humans.
22:38:49 <bitwize> The MIX architecture makes the hidden continuation really quite visible.
22:38:55 <shapr> lament: I still think Haskell is more difficult because suddenly the emergency brake is let go, and you get to handle *real* programming!
22:39:09 <SamB_XP> ah, the days when knuth was cool in #python...
22:39:09 <shapr> Admittedly, I think that forth has some of that as well.
22:39:11 <johnnowak> haskell seems much more difficult than it is because it hits you when you do something wrong
22:39:14 <bitwize> shapr: I'd say that about assembly or C
22:39:28 <lament> forth is amazing.
22:39:32 <johnnowak> people who know nothing about programming can think they know python... they can't mistakenly think they know haskell
22:39:38 <bitwize> or forth :)
22:39:42 <shapr> johnnowak: That's quotable :-)
22:39:53 <lament> what's with all the elitism :(
22:39:58 <bitwize> Haskell is more like math... that was my first impression: "this looks like blackboard math! COOL."
22:39:59 <johnnowak> shapr: I've been pulling that one out a lot lately. :)
22:40:03 <lament> "We're cool haskellers! We laugh at your lesser languages!"
22:40:07 <dons> there's the question though that pure FP is _very_ intuitive to non programmers
22:40:10 <SamB_XP> johnnowak: that coincides with my thinking on the subject
22:40:13 <Korollary> Well, if they get anything done with python, then they know programming. It's not supposed to be rocket science.
22:40:29 <shapr> lament: Nah, it's just that Haskell feels a lot bigger to me. I did everything in first VB, then Java, then Python for a few years.
22:40:33 <lament> dons: there's a reason most people have problem with school math
22:40:44 <lament> dons: and for the same reason they would have problems with haskell
22:40:49 <bitwize> shapr: rising out of the muck are we? :)
22:40:52 <zvrba> and the reason is..?
22:40:53 <SamB_XP> lament: because the US education system sucks?
22:40:54 <dons> i'm not sure people who have problems with school math should be programmers though
22:40:58 <bitwize> Excellent...</MrBurns>
22:41:07 <lament> SamB_XP: when did i say anything about US? I don't care about your stupid backward country!
22:41:10 <shapr> I got bored with each of those after a few years, Haskell has held my interest for a long time, and I'm just beginning to see the next stage of niftiness.
22:41:19 <Korollary> dons: It's market driven. Sometimes the market wants simple programs written by whoever.
22:41:20 <RyanT5000> dons: many of them are, though; hence 0-day exploits :P
22:41:22 <SamB_XP> lament: oh.
22:41:25 <lament> zvrba: Symbolic maniputalation just appears to be very difficult for most humans.
22:41:34 <zvrba> lament: any reason to that/
22:41:35 <zvrba> ?
22:41:37 <lament> ma-ni-pu-la-tion.
22:41:40 <SamB_XP> you mean most people everywhere have trouble with high school math?
22:41:42 <zvrba> i find it pretty easy
22:41:43 <Korollary> dons: scratch that. The market USUALLY wants that.
22:41:43 <johnnowak> Programming is very difficult for most humans in general
22:41:45 <kilimanjaro> a lot of haskell programmers go out of their way to hide the intent of their code just so that they can make it look 'elegant'
22:41:48 <lament> SamB_XP: yes.
22:41:48 <SamB_XP> that's probably why I love Haskell then ;-)
22:41:55 <lament> SamB_XP: in my experience anyway.
22:41:58 <shapr> johnnowak: Yeah, I think it's inherently unnatural.
22:42:06 <glguy> kilimanjaro: example?
22:42:08 * SamB_XP got an 800 in math on his SAT, whatever that means
22:42:17 <shapr> I failed business calculus twice in a row...
22:42:22 <zvrba> shapr: no, it's not unnatural. you just have to spell everything in painful detail :p
22:42:24 <dons> kilimanjaro: really? I'd have thought writing a 'for' loop when you make take 10 . map toUpper was hiding your intention
22:42:34 <zvrba> shapr: which might feel a bit unnatural if you're mostly used to dealing with humans
22:42:36 <Korollary> shapr: What's business calculus?
22:42:37 <kilimanjaro> glguy, I don't keep a journal on this stuff, but the proliferation of point free style amongst college students could be considered an example
22:42:42 <shapr> zvrba: Most people are...
22:42:47 * johnnowak also got an 800 so i'm probably biased as well
22:42:55 <dons> the problem is that in legacy languages you're forced to hide your intention, and program in the machines primitives, not the domain you're thining in
22:42:57 <johnnowak> i never get to mention my SAT score. forgive me.
22:42:59 <kilimanjaro> dons, those are your words, not mine
22:43:04 <lament> SamB_XP: I have gone to schools in three different countries, one of them famous for its math education. Most people find math difficult everywhere.
22:43:06 <glguy> 800 in math on the SAT isn't a particularly huge accomplishment
22:43:09 <RyanT5000> kilimanjaro: saying "fail = error" is a lot more intuitive to me than "fail x = error x"
22:43:14 <shapr> I hated math for decades, Haskell is the first thing that got me interested in math.
22:43:18 <johnnowak> fine, take it away from me.
22:43:19 <zvrba> dons: but that's a problem with every language
22:43:21 <RyanT5000> kilimanjaro: (the first point-free thing i've written that popped into my mind)
22:43:25 <dons> since every `for' loop has to be analysed to work out what it really means
22:43:26 <SamB_XP> glguy: well no
22:43:32 <shapr> dons: right! That's what I've been trying to say! Yes!
22:43:34 <Korollary> shapr: not even mathematicians like all branches of math.
22:43:40 <dons> the gap between problem and expression of the solution is smaller in haskell, than in legacy languages
22:43:43 <SamB_XP> I also scored high enough on the AMC12 to take the AIME
22:43:55 <lament> let's have an algebra/analysis fight :)
22:44:01 <lament> INFINITESIMALS FOREVER!!!!!!
22:44:02 <olathe> Algebra ftw !
22:44:05 <zvrba> dons: *if* you bother to code nice abstractions for your domain
22:44:07 <kilimanjaro> dons, I never even mentioned a legacy language, I happen to prefer Scheme to haskell for some reasons and Haskell to scheme for other reasons, but nowhere does legacy come into play
22:44:10 <mgsloan> heh, I've never scored well enough on the AMC tests
22:44:15 <shapr> I bet I got the lowest score in math of anybody here ;-)
22:44:28 <zvrba> anyway
22:44:34 <SamB_XP> now if only I could find the damned pin
22:44:35 <mgsloan> they focus too much on the godamn combinatorial stuff
22:44:37 <Korollary> dons: 99% of the for loops out there require no analysis really. They're just verbose. Boring to read and write.
22:44:49 <zvrba> Korollary: indeed.
22:44:54 <mgsloan> I could probably get 100% on the AMC with ghci at hand
22:44:58 <shapr> heh
22:45:04 <zvrba> Korollary: most of them can be more succintly replaced with map
22:45:05 <SamB_XP> mgsloan: that would, uh, be cheating
22:45:07 <dons> Korollary: well, they need analysis to work out where they start, where they end, what the intent of the body is, what state leaks out of the body, where it terminates
22:45:15 <bitwize> And probably better off expressed as an (ana|cata|hylo|para)morphism.
22:45:22 <dons> when we hvae named forms for each loop flavour, foldl, foldr, map, filter, unfoldr
22:45:28 <zvrba> what's paramorphism?
22:45:32 <SamB_XP> they'd make the questions much much much much larger if you were supposed to be allowed a computer
22:45:41 <shapr> zvrba: Changing things while jumping out of a plane?
22:45:45 <RyanT5000> dons: and our loop "syntax" is arbitrarily extensible :)
22:45:45 <mgsloan> SamB_XP - well, all I need is a version have haskell for TI-83 ;)
22:45:51 <dons> hence a gazillion bugs in legacy languages are to do with messing up the encoding of problem solution into for loop
22:45:52 <SamB_XP> but then they'd have to seal you in a avault for days
22:45:55 <shapr> para-chute-morphism?
22:46:14 <luqui> so, I've got this program: http://svn.luqui.org/svn/misc/luke/work/code/haskell/binpatch.hs
22:46:17 <luqui> and it uses all my memory
22:46:20 <luqui> and I don't know why
22:46:20 <kilimanjaro> I personally think the only compelling advantage of Haskell over Scheme is GHC
22:46:23 <shapr> Uh oh.. on-topic, run away!
22:46:34 <zvrba> kilimanjaro: what's so good with ghc?
22:46:37 <dons> life would be a lot better if for-loops were like the ST monad, and state couldn't leak out of their body
22:46:46 <kilimanjaro> it's a very high quality implementation with a lot of support
22:46:46 <johnnowak> kilimanjaro: types aren't a compelling advantage?
22:46:50 <Korollary> dons: What do you mean by state leak?
22:47:00 <SamB_XP> kilimanjaro: um
22:47:02 <RyanT5000> dons: you mean in C++ etc.? C++ kind of tries to do that a little
22:47:07 <lament> kilimanjaro: what about parsec?
22:47:09 <sieni> kilimanjaro: or monadic io?
22:47:09 <dons> too many side channels can be used to leak information out of a loop, which is difficult to reason about
22:47:16 <SamB_XP> kilimanjaro: have you seen the GHC bugs?
22:47:16 <dons> values set based on what happened in the loop
22:47:19 <SamB_XP> @bug
22:47:19 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
22:47:34 <bitwize> dons: I remember as a kid puzzling over what I was after FOR I=1 TO 100:NEXT I
22:47:39 <kilimanjaro> SamB_XP, it's still a much more mature system than anything Scheme has to offer
22:47:42 <bitwize> usually it's something retarded like 101
22:47:44 <bitwize> wtf?
22:47:46 <SamB_XP> kilimanjaro: go there, then click go and look at the bugs
22:47:53 <zvrba> hm.. what kind of problems are suitable for getting started with haskell?
22:47:55 <SamB_XP> er.
22:47:59 <dons> "oh, you set $i to something based on the last incremented value in the loop, if it was true, then you decrement that, since XYZ", ah so that's why this is executed
22:47:59 <SamB_XP> s/click go //
22:48:00 <Korollary> dons: Most loops I deal with work on the container itself. But, true, you can do things inside the loop that affect other things.
22:48:00 <kilimanjaro> SamB_XP, what do you use?
22:48:00 <shapr> zvrba: What do you like to do?
22:48:05 <johnnowak> kilimanjaro: i've have nothing but good experiences with several scheme implementations
22:48:07 <SamB_XP> kilimanjaro: GHC
22:48:07 <zvrba> and what advantage does haskell have over SML ?
22:48:14 <zvrba> shapr: mostly algorithmic problems
22:48:17 <shapr> zvrba: Community ;-)
22:48:19 <bitwize> Laziness.
22:48:22 <zvrba> shapr: haha :)
22:48:24 <SamB_XP> but you just called it a very high quality implementation
22:48:25 <bitwize> That's the big thing.
22:48:26 <lament> johnnowak: then why did you have to use several rather than one? :)
22:48:27 <shapr> zvrba: SML has Smerdyakov :-)
22:48:29 <dons> purity. type classes. concurency.
22:48:31 <zvrba> lol
22:48:33 <lament> shapr: ouch
22:48:33 <SamB_XP> I guess I accidentally read "solid" into that
22:48:38 <zvrba> shapr: he's not too bad :)
22:48:41 <dons> syntax, did we mention syntax?
22:48:41 <lament> he's not??
22:48:42 <johnnowak> lament: to annoy myself with the lack of a standard module system
22:48:44 <zvrba> no
22:48:46 <shapr> zvrba: Heh, ask him what he think of me ;-)
22:48:47 <bitwize> dons: Concurrent ML?
22:48:53 <zvrba> shapr: haha :)
22:48:54 <dons> that's not SML
22:48:56 <lament> johnnowak: ah. yeah. that's my main turn-off from scheme as well :(
22:48:56 <zvrba> nah
22:48:57 <kilimanjaro> johnnowak, Scheme has no static type analysis like Haskell, it really needs high quality debugging and flexible restartable conditions, most scheme systems are much worse than common lisp in both of those regards
22:49:12 <zvrba> but Scheme is dynamic! :D
22:49:13 <lament> scheme is a great language but the libs are lacking
22:49:18 <shapr> Hey zvrba, are you in Zagreb?
22:49:21 <zvrba> can you inject code into a running haskell program? :P
22:49:21 <SamB_XP> kilimanjaro: now you are making sense
22:49:24 <zvrba> shapr: no, i'm in oslo
22:49:26 <glguy> zvrba: yes
22:49:29 <bitwize> the proposed R6RS makes me want to break things
22:49:30 <zvrba> shapr: moved out from zagreb
22:49:31 <johnnowak> kilimanjaro: aye, this is true
22:49:37 <johnnowak> bitwize: are you voting?
22:49:40 <shapr> zvrba: So instead of bok, it's hej?
22:49:41 <SamB_XP> bitwize: what'd they do?
22:49:43 <lament> kilimanjaro: what's the problem with CL by the way?
22:49:46 <zvrba> glguy: into *compiled* code ?
22:49:50 <glguy> zvrba: yes
22:49:52 <zvrba> shapr: no, it's still "bok" :)
22:49:55 <zvrba> glguy: ok
22:49:55 <shapr> ah ok then.
22:49:58 <bitwize> yes I'm voting
22:50:03 * johnnowak has yet to write the reason for his NO vote on r6rs
22:50:05 <kilimanjaro> lament, I prefer a functional style in general
22:50:05 <zvrba> shapr: "hej" is like.. well.. "hey"
22:50:14 <shapr> zvrba: Do you speak Norwegian?
22:50:17 <zvrba> shapr: yes
22:50:23 <shapr> Cool, I only do Swedish.
22:50:25 <SamB_XP> what does this proposed R6RS do that is so horrible?
22:50:29 <bitwize> it seems to me as if...
22:50:35 <zvrba> shapr: well, i'd understand you :P
22:50:42 <glguy> what qualifies one to vote on R6RS? deciding that one is qualified?
22:50:43 <luqui> someone like to help me understand my memory gobbling program, and thus help me understand how haskell's execution model works?
22:50:51 <johnnowak> glguy: it seems to be, yes.
22:50:52 <bitwize> R6RS really focussed on a few side issues that made Scheme more palatable in a "software engineering context"
22:50:54 <shapr> Men det aer inte sa lika.
22:51:02 <zvrba> shapr: jo, noks likt
22:51:05 <bitwize> Without addressing the more powerful abstractions for which Scheme is famous
22:51:09 <SamB_XP> bitwize: ewwwwwwwww
22:51:09 <lament> bitwize: like... a good standard module system? :)
22:51:09 <kilimanjaro> glguy, you must write an essay to convince the steering committee
22:51:21 <dons> luqui: have you compiled with -O2 and profiled ?
22:51:21 <SamB_XP> lament: hmm. not so eww.
22:51:26 <zvrba> shapr: likt nok s jeg kan forst mer enn halvparten av svensk :)
22:51:28 <bitwize> lament: good? :)
22:51:29 <luqui> profiled, eh?
22:51:32 <dons> the profiler will tell you exactly what function is `gorging on memory'
22:51:37 <johnnowak> r6rs makes scheme slightly better at something it's rather terrible at and will remain terrible at... and does so at the expensive of more important things
22:51:37 <dons> ghc -O2 -prof -auto-all
22:51:38 <shapr> zvrba: And that's good enough
22:51:42 <zvrba> indeed
22:51:42 <dons> then run with ./a.out +RTS -p
22:51:47 <glguy> kilimanjaro: so, willingness and ability to write a compelling essay is the qualifier?
22:52:08 <bitwize> and by the way a lot of these ideas seem to come from Chez
22:52:11 <lament> no, i think writing a compelling essay is a qualifier
22:52:17 <lament> there's a difference :)
22:52:17 <zvrba> shapr: another 1/4 I can extract from the context.. and the rest isn't that important most of the time anyway... language has a lot of redundancy
22:52:21 <SamB_XP> do you get a bigger vote if you write a stronger compelling essay?
22:52:22 <kilimanjaro> glguy, yep, that's it. All of the voters I have seen I would consider to be knowledgeable, but you could certainly BS your way  as wellk
22:52:31 <zvrba> shapr: so... unbad given that I've never learned swedish :P
22:52:33 <shapr> Yeah, we could talk about Hamming now...
22:52:35 <SamB_XP> lament: you mean you can be compelled to write a compelling essay?
22:52:35 <luqui> dons, I didn't know ghc had a profiler... cool!
22:52:39 <johnnowak> kilimanjaro: "essay" is a bit strong perhaps. and not all of them seem so compelling. i don't think mine was particularly compelling.
22:52:43 <psykotic> kilimanjaro, it's all about the bathos.
22:52:57 <shapr> zvrba: But you should try hs-plugins to do dynamic code reloading with Haskell. Or Template Haskell for other niftiness.
22:52:57 <lament> so does r6rs increase the standard library?
22:53:03 <zvrba> shapr: so, yes, algorithmic problems. no UIs and stuff.
22:53:03 <shapr> @where hs-plugins
22:53:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
22:53:22 <zvrba> maybe I should just solve ACM problems..
22:53:23 <kilimanjaro> psykotic, I was a day too late on my vote registration, but my essay was composed entirely of larry david quotations
22:53:30 <zvrba> or topcoder problems
22:53:30 <shapr> zvrba: Yeah, good way to get started!
22:53:41 <psykotic> kilimanjaro, haha, do you have a copy still?
22:53:42 <zvrba> too bad that topcoder is only C/C++/Java >:
22:53:44 <bitwize> no surprise, Kent Dybvig is on the editors committee, and has been a major driver in the R6RS effort. That's another thing that makes me shudder: syntax-case in the standard
22:53:44 <zvrba> maybe C#
22:53:56 <shapr> Dybvig r0xx0rs.
22:53:57 <Korollary> bitwize: I thought syntax-case was good?
22:54:10 <shapr> He can write a mean paper.
22:54:11 <glguy> syntax-case is hygenic pattern matching macros?
22:54:15 <zvrba> i'm soon going to be thrown out from the office i guess... -> cleaning
22:54:20 <bitwize> glguy: syntax-rules is.
22:54:22 <zvrba> shapr: do you live in .se ?
22:54:23 <glguy> oh
22:54:25 <zvrba> (sweden)
22:54:28 <bitwize> syntax-case lets you break hygiene.
22:54:32 <Korollary> glguy: It's a sane extension to syntax-rules
22:54:35 <shapr> zvrba: I live in Birmingham, Alabama! But I used to live in Sweden...
22:54:37 <bitwize> ... in a somewhat cumbersome and difficult to write in way.
22:54:41 <zvrba> shapr: ah, ok
22:54:48 <psykotic> bitwize, it's not too bad at all.
22:54:48 <shapr> zvrba: I may be going to visit Zagreb soon though.
22:54:51 <zvrba> shapr: was it just temporary or dod you move out ?
22:55:00 <zvrba> shapr: nice.. business or pleasure?
22:55:04 <zvrba> *did
22:55:14 <olsner> hehe "live in Sweden ... in a somewhat cumbersome and difficult to write in way."
22:55:15 <dons> luqui: profiling working?
22:55:17 <shapr> Visiting friends in Zagreb
22:55:26 <bitwize> ever since discovering Bawden and Rees's syntactic closures I've been sold. It's very Schemey: a sort of abstract toolkit from which you can build a macro system
22:55:26 <zvrba> ah
22:55:34 <shapr> olsner: Only because of skatteverket!
22:55:37 <zvrba> enjoy :)
22:56:03 <olsner> shapr: taxation drove you away?
22:56:03 <zvrba> shapr: btw, how did you guess that I was from zagreb? :P
22:56:09 <zvrba> ah, probably my whoid
22:56:10 <zvrba> whois
22:56:14 <shapr> olsner: I left Sweden in the previous September, and Skatteverket finally let go of me *this week*!
22:56:24 <zvrba> only 1 year?
22:56:33 <zvrba> a friend told me that they hold you 3 years.
22:56:38 <zvrba> well, at least in norway
22:56:41 <glguy> skatteverket?
22:56:44 <zvrba> i'm not sure for sweden
22:56:47 <shapr> glguy: The Swedish IRS.
22:56:47 <kilimanjaro> psykotic, unfortunately not, but I had watched like 7 hours of curb your enthusiasm prior to writing it, it started with "I know, look, listen, you're unhappy. I'm unhappy too. That's what a good compromise is all about. Have you ever heard of Henry Clay? He was the great compromiser. *This*, this is a good compromise -- a good compromise is when both parties are dissatisfied. And I think that's what we have here."
22:56:53 <zvrba> glguy: yes, skatteetaten
22:56:56 <zvrba> in norway :P
22:57:06 <psykotic> kilimanjaro, hah, brilliant
22:57:08 <shapr> zvrba: Ok,I'm scared of Norway now.
22:57:11 <Korollary> kilimanjaro: 7 hours eh?
22:57:13 <zvrba> lol
22:57:13 <glguy> they continue to expect money from you after you leave?
22:57:16 <zvrba> no
22:57:24 <zvrba> they expect you to file tax reports
22:57:25 <kilimanjaro> Korollary, yes, I had shoulder surgery and was physically incapacitated
22:57:29 <psykotic> kilimanjaro, i'm a big larry david fan too :)
22:57:29 <zvrba> even though you have no income
22:57:39 <glguy> or you can't return ot he country later?
22:57:39 <johnnowak> larry david fans should get to vote twice
22:57:41 <kilimanjaro> psykotic, I always knew you had excellent taste
22:57:41 <psykotic> kilimanjaro, his character is my favorite sociopath
22:57:46 <zvrba> glguy: you can return
22:57:48 <zvrba> ah
22:57:50 <zvrba> if you *don'
22:57:52 <Korollary> kilimanjaro: Ah. I once watched 8 hours of Law & Order after surgery myself.
22:57:52 <bitwize> Deciding on standards for Scheme is tough. Let's go Haskelling!
22:57:57 <shapr> glguy: As zvrba says, it took me this long to convince them that I really have not been living in Sweden and just neglecting to file my tax reports.
22:58:07 <zvrba> *dont* do that, you're declared as a criminal :P
22:58:25 <lament> who decides on haskell stuff?
22:58:30 <shapr> zvrba: I got nasty letters in the mail....
22:58:38 <shapr> lament: You do! Join the Haskell' effort!
22:58:43 <lament> or is it just whatever-ghc-devs-put-into-ghc?
22:58:43 <Korollary> lament: deisgn by committee. Tee hee.
22:58:45 <kilimanjaro> the zerg overmind
22:58:54 <kilimanjaro> Korollary, that
22:58:55 <zvrba> glguy: but the most bizzare thing in norway.. you DO notify skatteetaten that you're moving out and they STILL expect tax reports
22:58:58 <zvrba> sick
22:59:05 <kilimanjaro> Korollary, that's impressive, I never got into that show
22:59:13 <kilimanjaro> I can't take crime dramas seriously
22:59:16 <luqui> dons, deciphering.  it's a simple program, I'll have to split it up more to understand, I think
22:59:32 <dons> luqui: so you got a .prof file?
22:59:38 <dons> and you compiled with -prof -auto-all?
22:59:39 <luqui> yeah
22:59:42 <lament> shapr: if i get to decide on what goes into haskell, that's a big failure on somebody's part, because i really shouldn't
22:59:44 <luqui> that part is working
22:59:44 <shapr> I can't take TV seriously. Research papers are so much better.
22:59:46 <Korollary> kilimanjaro: If you can, watch the earlier seasons.
22:59:48 <luqui> :-)
22:59:55 <dons> you can annotate specific expressoins to measure with {-# SCC "my code " #-}
22:59:59 <Korollary> shapr: House MD > research papers.
23:00:03 <johnnowak> lament: that's another reason i'm voting no on r6rs
23:00:12 <shapr> Korollary: You must be reading the wrong papers!
23:00:12 <dons> luqui: likely you wouldn't get taken seriously :-) don't worry.
23:00:13 <johnnowak> no standard i'm allowed to vote on is worth voting for
23:00:16 <bitwize> kilimanjaro: then Scheme is the Xel'Naga's chosen language.
23:00:26 <dons> s/luqui/lament/ ops :)
23:00:27 <glguy> johnnowak: you wouldn't be a member of any club that would have you?
23:00:34 <bitwize> It combines the purity of form of lisp with the purity of essence of lambda calculus :)
23:00:41 <SamB_XP> johnnowak: you are voting NO on the grounds that you shouldn't have a vote?
23:00:49 <lament> dons: :)
23:01:00 <zvrba> shapr: best document to get started with haskell? gentle introduction?
23:01:10 <dons> yaht i think
23:01:12 <wli> Okay, I think I have a stupid test driver for terminal crap.
23:01:13 <dons> ?where yaht-web
23:01:13 <lambdabot> I know nothing about yaht-web.
23:01:17 <dons> ?where yaht
23:01:18 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
23:01:21 <SamB_XP> lambdabot: anyway, it isn't "what goes into GHC"
23:01:23 <shapr> I'm still not sure how I can express to my siblings that I live in an art museum, with research papers full of beautiful ideas scattered around in my head.
23:01:24 <johnnowak> SamB_XP: heh, well not in reality.
23:01:27 <dons> ?go haskell yet another haskell tutorial wikibook
23:01:29 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
23:01:29 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
23:01:37 <dons> ?where+ yaht-web http://en.wikibooks.org/wiki/Haskell/YAHT
23:01:37 <lambdabot> Done.
23:01:39 <dons> @flush
23:01:43 <zvrba> shapr: huh?
23:01:45 <shapr> <whoosh>
23:01:59 <glguy> zvrba: he lives in a mental institution
23:02:03 <shapr> zvrba: I think you missed that part of the discussion earlier.
23:02:06 <kilimanjaro> shapr, make origami with the research papers. That might get the point across
23:02:09 <zvrba> shapr: yes, i did
23:02:11 * shapr smacks glguy with a trout!
23:02:18 <dons> shapr: did you see the spj videos, btw?
23:02:27 <Korollary> glguy: but, it's a private mental institution!
23:02:31 <shapr> kilimanjaro: I do have some cool papers on origami theory, that would be totally recursive.. I like it!
23:02:32 <SamB_XP> it's "what is in GHC *and* is either trivial or also in another compiler *and* the Haskell' commitee likes"
23:02:34 * glguy watched the second half of SPJ's tutorial
23:02:41 <shapr> dons: Nah, haven't seen 'em yet.
23:02:44 <zvrba> glguy: interesting ?
23:02:53 <zvrba> yes, i should watch these two movies
23:02:54 <SamB_XP> er. s/lambdabot/lament/
23:02:57 <zvrba> i've d/l'd them
23:02:58 <SamB_XP> and I should be in bed
23:03:09 <glguy> zvrba: I'm not a good person to ask if it was useful as a tutorial or not, but I enjoyed SPJ's talk
23:03:12 <dons> they're rather good. best to watch with the slides open next to the video
23:03:14 <shapr> zvrba: Anyway, my siblings told my girlfriend that I never leave my apartment. I tried to explain to my siblings that I live in art museum of beautiful ideas, but they just didn't get it.
23:03:33 <shapr> SamB_XP: Yeah, I should be sleeping too.
23:03:35 <kilimanjaro> shapr, tell them you are a secret agent
23:03:45 <dons> SamB_XP: I think that's a side effect of the large channel growth: our tab completions aren't unique anymore
23:03:52 <shapr> kilimanjaro: Just don't mention it's a software agent?
23:03:53 <dons> so we get a lot more nick mixups
23:03:57 <kilimanjaro> your job is to collect classified research about the semantics and implementation of functional programming languages
23:03:58 <dons> 3 letters isn't enough often.
23:04:07 <SamB_XP> dons: that doesn't explain lament/lambdabot confusion
23:04:09 <Korollary> shapr: Tell them that you are Mr. Anderson
23:04:12 <glguy> dons: we could issue unique prefixes to everyone :)
23:04:20 <SamB_XP> I don't think I *used* to do that when lament was here
23:04:20 <dons> i think that's sensible, glguy
23:04:21 <shapr> Korollary: Erisson, not Anderson!
23:04:25 <zvrba> shapr: ok
23:04:28 <SamB_XP> dons: crazy
23:04:29 <dons> 4 digit numbers should be enough
23:04:34 <shapr> Korollary: Plus they wouldn'tbe surprised, it used to be Gilliam...
23:04:35 <glguy> for *anyone*
23:04:36 <dons> based on when you joined the channel
23:04:41 <lament> yeah, i was in #haskell before SamB_XP was ever born
23:04:44 <dons> shapr gets to be 0000
23:04:49 <RyanT5000> dons: that's also a side-effect of certain people having multiple different-suffix names for themselves :P
23:04:54 <shapr> My siblings are still calling me by my previous name...
23:04:55 <shapr> dons: hah!
23:04:56 <lament> (and so was lambdabot)
23:05:01 <SamB_XP> lament: Haskell was around in 1985?
23:05:21 <SamB_XP> hey. isn't that when back to the future is from?
23:05:24 * glguy wonders when the last person who wasn't me had a "gl" prefix
23:05:27 <glguy> I need sorear's logs :)
23:05:36 <kilimanjaro> shapr, are you a grad student somewhere?
23:05:58 <shapr> kilimanjaro: No, I am a degree-less professional Haskell programmer.
23:06:11 * sjanssen crafts the appropriate grep for glguy
23:06:11 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
23:06:22 <shapr> kilimanjaro: I did have CS101 in 1992.
23:06:26 <glguy> sjanssen: it needs to exclude "glguy.*" probably :)
23:06:36 <dons> Pseudonym gets to be somewhere less than 0010
23:06:37 <bitwize> @quote qwe1234
23:06:37 <lambdabot> qwe1234 says: lisp is a wannabe python from the seventies.
23:06:44 <SamB_XP> heh
23:06:47 <shapr> @quote dons
23:06:47 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
23:06:47 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
23:06:56 <dons> 202. man.
23:07:00 * shapr grins
23:07:01 <dons> those were the days
23:07:07 <bitwize> homework channel :)
23:07:11 <sorear> glguy: go download the shell script at http://hpaste.org/1979/plain, save it in a new empty directory, run it, and wait half an hour or so
23:07:13 <kilimanjaro> shapr, cool! if you don't mind telling me, what do you use Haskell for?
23:07:16 <bitwize> #scheme got like that sometimes
23:07:30 <glguy> HAppS!
23:07:33 <shapr> kilimanjaro: I work on HAppS for a living.
23:07:36 <wli> This is actually probably a good monadic programming exercise for people writing monad tutorials.
23:07:36 <psykotic> @users
23:07:37 <lambdabot> Maximum users seen in #haskell: 352, currently: 327 (92.9%), active: 23 (7.0%)
23:07:37 <bos> #erlang is up to 100 now
23:07:38 <RyanT5000> dons: that's why i keep coming back :) it's nice to be somewhere where most people know more than you about most stuff
23:07:46 <shapr> Just like glguy used to... before he went off to the beach!
23:07:48 <dons> bos, oh, that's interesting.
23:07:56 <kilimanjaro> shapr, ahh, I've heard of that, I didn't know whether or not it was being used anywhere
23:08:02 <dons> so they went from 34->100  in the time we went from 202->380
23:08:05 <bos> but ocaml is still stuck at 50
23:08:15 <wli> Though in actuality it's only truly intended as a test driver for readline clones.
23:08:16 <dons> disunity is death
23:08:18 <shapr> bos: Does #ocaml have Smerdyakov?
23:08:19 <SamB_XP> wli: I really don't understand the point of writing all these monad tutorials
23:08:24 <Korollary> erlang's hurt by its single-thread performance.
23:08:39 <dons> Korollary: I think that must be their biggest worry
23:08:43 <bos> shapr: not any more
23:08:48 <shapr> bos: oh?
23:08:48 <wli> SamB_XP: I'm a consumer, not a writer.
23:08:51 <johnnowak> SamB_XP: The point is to confuse via lazy pedagogy
23:08:55 <kilimanjaro> who is Smerdyakov? I've heard that name before
23:09:10 <wli> kilimanjaro: One of the brothers Karamazov
23:09:11 <zvrba> a guy advocating SML
23:09:19 <SamB_XP> kilimanjaro: he's ... a person who doesn't know how to stop being mean to newbies
23:09:25 <shapr> kilimanjaro: He's an FP grad student who used to hang out on #haskell
23:09:26 <SamB_XP> which is okay in ##c but not in Haskell
23:09:29 <kilimanjaro> Korollary, and the language is a bit unwieldy in some ways. It's not bad but there are much nicer environments for programming the stuff that isn't concurrent and distributed
23:09:30 <SamB_XP> er.
23:09:31 <SamB_XP> #haskell
23:09:33 <glguy> erlang has support for running multiple erlang instances on different computers have having them communicate the same way they would on a single one, no?
23:09:34 <zvrba> SamB_XP: why not?
23:09:39 <zvrba> SamB_XP: are monads so simple, or..?
23:09:39 <psykotic> wli, russian for "shit head", iirc :)
23:09:39 <Korollary> kilimanjaro: Adam Ch... at UC Berkeley I believe
23:09:43 <lament> Actually I would guess the brothers Karamazov were Karamazov, not Smerdyakov.
23:09:47 <johnnowak> glguy: more the other way around
23:09:53 <shapr> Chlipala
23:09:57 <lament> psykotic: more like "Stinky"
23:09:58 <SamB_XP> zvrba: well we've got tutorials coming out the wazoo as it is, haven't we?
23:10:07 <bitwize> Smellyakov :)
23:10:13 <glguy> ?smerdy
23:10:13 <lambdabot> Unknown command, try @list
23:10:14 <kilimanjaro> I had heard the name mentioned by someone, I knew it was in that book though (I haven't read it but I own a copy :) )
23:10:16 <dons> glguy: yeah, locally its the same as talking to remote nodes. in haskell, you do that via ports or network stuff or chans, so not as `built in' for distribution
23:10:20 <bitwize> @quote smerdyakov
23:10:20 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
23:10:35 <shapr> zvrba: So, have you decided upon a first project?
23:10:37 * shapr boings!
23:10:39 <lament> the freenode smerdyakov is quite a legend.
23:10:41 <SamB_XP> @quote smerdy
23:10:41 <lambdabot> Botty says: holy crap, knew smerdy sounded familiar - about 2 years ago he was trying to convince me to throw out my mouse
23:10:45 <dons> #erlang, Current: 97, Avg: 101, Max: 128
23:10:52 <SamB_XP> @quote smerdy
23:10:52 <lambdabot> Botty says: holy crap, knew smerdy sounded familiar - about 2 years ago he was trying to convince me to throw out my mouse
23:10:54 <SamB_XP> @quote smerdy
23:10:54 <lambdabot> Botty says: holy crap, knew smerdy sounded familiar - about 2 years ago he was trying to convince me to throw out my mouse
23:10:58 <glguy> heh
23:11:03 <dons> Current: 51, Avg: 57, Max: 72
23:11:03 <glguy> *prolific*
23:11:05 <dons> #ocaml
23:11:07 <SamB_XP> is that the ONLY smerdy reference on record?
23:11:11 <wli> SamB_XP: Well, the tutorials need more exercises, so the test driver for line editing code may come in handy for whoever wants to borrow it for such purposes.
23:11:12 <Korollary> glguy: They have a fine tuned RTS for all that distributed stuff. It's schemey otherwise.
23:11:17 <psykotic> i thought he has his own command, like palomer :)
23:11:21 <glguy> sjanssen: well done :)
23:11:22 <shapr> SamB_XP: I think Smerdyakov was before @remember
23:11:24 <bitwize> Yeah, I remember the Project COSA troll from years ago on /.
23:11:33 <psykotic> @palomer
23:11:33 <lambdabot> Blargh!
23:11:33 <SamB_XP> shapr: hmm
23:11:34 <lament> did he use to come here?
23:11:38 <psykotic> @quote palomer
23:11:38 <lambdabot> No quotes match. You speak an infinite deal of nothing
23:11:38 <dons> #lisp Current: 237, Avg: 257, Max: 300
23:11:39 <wli> SamB_XP: I have no intention of writing my own monad tutorial. I'm well aware that I'm not competent to do so.
23:11:42 <SamB_XP> lament: yes.
23:11:45 <SamB_XP> but then he was banned!
23:11:51 <lament> big surprise!
23:12:11 <dons> #haskell Current: 326, Avg: 323, Max: 381
23:12:12 <SamB_XP> he may or may not still actually be banned, but he doesn't come here anymore anyway
23:12:22 <sorear> SamB_XP: Don't forget dons seems to have wiped the @quotes
23:12:29 <SamB_XP> sorear: wiped?
23:12:29 * glguy wishes that bans were regexes...: +b gl[^g].*:.*@.* ;)
23:12:31 <dons> #xmonad Current: 53, Avg: 44, Max: 54
23:12:33 <wli> SamB_XP: On two fronts, even. First, I don't know the material well enough to attempt to teach it. Second, I'm a terrible teacher in general, whether in writing or speech.
23:12:34 <SamB_XP> dons: did you wipe them?
23:12:44 <dons> hehe. poor #ocaml. even #xmonad is bigger :}
23:12:46 <zvrba> well.. smerdyakov is smart but not the nicest person
23:12:50 <zvrba> at least my impression
23:12:51 <dons> SamB_XP: file system failure
23:12:51 <glguy> @quote emertens
23:12:52 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
23:12:56 <dons> they're in darcs though
23:13:05 <sorear> We need to fork #haskell.  I can't read fast enough.
23:13:09 <RyanT5000> lol, that's a great quote
23:13:12 <SamB_XP> dons: you need to record and push them more often, I think
23:13:17 <lament> SamB_XP: uh oh there we go
23:13:19 <SamB_XP> sorear: no!!!!
23:13:22 <glguy> sorear: maybe write an irssi extension that drops every other line?
23:13:24 <RyanT5000> sorear: just stop doing anything other than reading #haskell:P
23:13:25 <Korollary> #haskell's already been forked to #haskell-overflow
23:13:29 <SamB_XP> sorear: didn't we tell you what happens when you do that?
23:13:33 <sjanssen> @remember sorear We need to fork #haskell.  I can't read fast enough.
23:13:33 <lambdabot> Done.
23:13:54 <sjanssen> we should all take speed reading courses
23:13:57 <RyanT5000> it would be cool if there were some kind of multithreaded chatroom
23:14:12 <RyanT5000> i believe some people did some work into automatically breaking a chatroom into threads
23:14:14 <ari> We could be more "encouraging" about moving off-topic discussion to #haskell-blah
23:14:16 <lament> sorear: this was actually done to #python at one point. You were randomly redirected to one of two channels when you tried to join #python.
23:14:18 <wli> RyanT5000: Describe what you mean?
23:14:36 <sorear> lament: Did they have >1 line per second before instating it?
23:14:38 <johnnowak> #python is hell
23:14:40 <sorear> +frequently
23:14:47 <lament> sorear: not really.
23:14:50 <lament> the ops were a little nuts
23:14:51 <psykotic> sjanssen, i'm reminded of that famous woody allen quote about speed reading.
23:14:51 <RyanT5000> wli: e.g. my response to you right now would be visible to everyone, but not interleaved with everything else
23:15:08 <lament> sorear: anyway, it led to no good
23:15:14 <lament> (and it's undone now)
23:15:16 <glguy> it would be cool if each new thread was given a column
23:15:18 <psykotic> sjanssen, "I took a speed reading course. I read War & Peace in 20 minutes. It involves Russia."
23:15:25 <RyanT5000> glguy: yeah
23:15:41 <johnnowak> i enjoy the single-threaded chaos. threads would be the end of the irc charm.
23:15:51 <glguy> it would be curiosity at least
23:15:51 <RyanT5000> johnnowak: that's true :P
23:16:03 <lament> johnnowak: then let's petition the ircops to combine all channels into one!
23:16:14 <hpaste>  SamB pasted "don't fork #haskell" at http://hpaste.org/2105
23:16:21 <bitwize> My most recent feat of speed reading was consuming Harry Potter and the Deathly Hallows in about four hours.
23:16:27 <bitwize> SPOILER: It involves magic.
23:16:32 <RyanT5000> some guys were doing some research on automatically picking out threads based on natural language processing as well as timing
23:16:46 <johnnowak> lament: i used the 'sic' irc client for awhile which actually does multiplex all channels into one
23:16:53 <glguy> the thread that was contributed to last would be the first to get squeezed out
23:17:00 <kilimanjaro> RyanT5000, there was a scheme program that did that, but it didn't do a great job and wasn't all that useful
23:17:03 <psykotic> bitwize, i always felt bad for the people who read like this.
23:17:05 <bitwize> johnnowak: you could do as much with raw telnet to the irc server :)
23:17:08 <RyanT5000> johnnowak: presumably, only the channels you're joined to :P
23:17:17 <lament> johnnowak: aha, i remember talking to somebody using that, he would constantly reply to people who weren't there :D
23:17:18 <johnnowak> bitwize: well it was 90 lines of C :)
23:17:30 <bitwize> psykotic: I actually read and comprehended most of it :)
23:17:32 <psykotic> bitwize, i mean, what kind of literature do you read to extract the essence of? if i wanted that i'd read the cliff's notes.
23:17:36 <wli> RyanT5000: So you essentially want to do like IRC channel windows but dynamically by the connected components of the graph formed by the sender/recipient tags by nick and recipient prefix (such as "johnnowak:" etc.)?
23:17:48 <lament> psykotic: joyce :)
23:17:58 <bitwize> Sometimes I get like that with a can't-put-down book.
23:18:02 <RyanT5000> wli: multiple columns would be nice
23:18:08 <sorear> psykotic: hocking&young! :)
23:18:08 <kilimanjaro> joyce is masturbation for literati
23:18:12 <psykotic> lament, funny, because i'm on my fourth attempt at the ox of the sun chapter of ulysses right now :)
23:18:12 <RyanT5000> wli: basically, it shouldn't be physically interleaved on my screen
23:18:17 <bitwize> Bradbury's Fahrenheit 451 was like that for me.
23:18:17 <kilimanjaro> sorear, I have that book :)
23:18:26 <lament> kilimanjaro: yes, just like haskell is masturbation for programmers. Unconvincing :)
23:18:33 <psykotic> lament, i hate it. joyce is such a self-indulgent cock.
23:18:35 <psykotic> :)
23:18:47 <glguy> there could simply be a /command that prefixed a statement with a new "thread-id"
23:18:51 <glguy> that people could tab-complete on
23:19:02 <olsner> lament: so... #haskell is really about masturbation, you say?
23:19:03 <glguy> if yo uweren't trying to bolt this onto normal irc
23:19:07 <kilimanjaro> lament, no, I would never compare joyce to Haskell, Haskell may aspire to beauty but it also apires to utility
23:19:14 <RyanT5000> glguy: yeah
23:19:19 <dons> it would be interesting to allow folding of particular nicks for a period, automatically
23:19:26 <lament> kilimanjaro: i'm not sure if i would want to read any novel that "aspired to utility"
23:19:33 <Korollary> My eyes catch the words beauty, masturbation, etc. I think the lines scroll by too fast.
23:19:37 <lament> olsner: i always thought it was about unicycling.
23:19:42 <dons> or split threads horizontally
23:19:43 <bitwize> Surely everybody knows by now that Haskell is a trivial syntactic hack and there's nothing new or useful to come out of it at all. :)
23:19:50 <wli> Well, the point of all this is to act as a simplistic test harness for line editors esp. wrt. the response to ^C
23:19:55 <RyanT5000> glguy: it would be *really* interesting to try to make a protocol over top of IRC that didn't also render everything unreadable (or really annoying) to people using just IRC
23:20:05 <wli> http://holomorphy.com/~wli/MiniCalc.lhs.txt
23:20:37 <kilimanjaro> lament, sorry, psykotic mentioned ulysses, that's neither beautiful nor does it have any utility, it's sole legacy is in the sheer number of allusions to other literary works
23:21:03 <bitwize> kilimanjaro: so, kinda like ALGOL then? :)
23:21:16 <psykotic> ulysses has parts that are good. the oxen of the sun chapter, not so much.
23:21:17 <lament> kilimanjaro: beauty is very much in the eye of the beholder.
23:21:25 <wli> I'm sure the parsec could be improved somehow.
23:21:29 <SamB_XP> bitwize: I thought algol had alusions FROM everything else
23:21:33 <kilimanjaro> lambdabot, absolutely, and that's why I am correct!
23:21:39 <psykotic> ulysses was pretty much constructed bottom up
23:21:40 <lament> don't call me lambdabot!
23:21:43 <dons> kilimanjaro: it has utility for training interesting markov chain bots
23:21:51 <Korollary> lament: @type map
23:21:56 <psykotic> iirc he thought of sentences, which he would put in his notebook, and after he had used them in the manuscript, he would cross them out
23:21:58 <lament> :(
23:21:59 <kilimanjaro> dons, that would be interesting to see actually. do you have any links?
23:22:08 <kilimanjaro> psykotic, interesting
23:22:10 <aaaron> an ideal tab-completion name
23:22:11 <bitwize> you know what has both beauty and utility? The writing of J.S. Mill.
23:22:11 <SamB_XP> lambdabot: @type map
23:22:16 <kilimanjaro> I've never actually made a serious attempt at the book
23:22:17 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:22:18 <psykotic> bitwize, bad pun :)
23:22:22 <bitwize> (no pun intended on the utility thing.)
23:22:31 <lament> Korollary: forall a b. [b] <- [a] <- (b <- a)
23:22:42 <Korollary> lament: nice arrows
23:22:56 <lament> left-handed haskell
23:23:02 * lament is a lefty
23:23:19 <sorear> @remember lament don't call me lambdabot!
23:23:20 <lambdabot> Done.
23:23:26 * johnnowak demands fully parenthesized type signatures
23:23:28 <wli> (Actually I could probably use a critique of it in general, despite it being totally trivial and meant as a testcase.)
23:23:51 * SamB_XP goes to bed
23:23:59 <Korollary> wli: you should share that with haskell-cafe
23:24:43 <lament> is haskell-cafe the mailing list of choice?
23:24:45 <psykotic> kilimanjaro, you should read his A Portrait of the Artist as a Young Man, which is in fact extremely readable.
23:25:06 <wli> Korollary: I don't like dealing with email outside work much anymore.
23:25:12 <Korollary> lament: Yes
23:25:30 <olsner> lament: 'tis like #haskell, but about haskell
23:25:34 <psykotic> kilimanjaro, the really good thing about it, stylistically, is that it's written (in terms of syntax, diction, etc) according to the protagonist's state of mind, self-image, etc at any given time, even though it isn't written in first person. kind of weird, but works really well.
23:25:39 <SamB_XP> olsner: hahahahaha
23:25:48 <lament> but isn't haskell-cafe supposed to be offtopic?
23:26:05 <SamB_XP> lament: no, that's #haskell-blah
23:26:07 <Korollary> lament: No. It's beginner to intermediate haskell stuff typically.
23:26:08 <opqdonut> well, #haskell is supposed to be on-topic
23:26:12 <lament> "Discussions on the Haskell mailing list which have drifted off topic, or are only of interest to a small number of subscribers, will be asked to move to Haskell-Cafe. "
23:26:19 <kilimanjaro> psykotic, I'll check it out
23:26:32 <SamB_XP> lament: that is a bit outdated I think...
23:26:33 <wli> *** Users on #haskell-cafe: @wli
23:26:40 <zvrba> lol
23:26:54 <glguy> hmmm... wli has drifted off-topic
23:26:55 <kilimanjaro> psykotic, I don't read books very often, most of my fiction is limited to short stories, borges and asimov and stuff like that, just because I always get distracted from novels unless I finish them in one or two sittings :/
23:26:58 <psykotic> kilimanjaro, like, the first page is written from the perspective of a four year old boy. it has run-on sentences with words like "moocow" and "nicens", etc. later, when he learns of poetry, parts are composed with heavy alliteration, etc. it's very self indulgent, but fun.
23:27:17 <psykotic> kilimanjaro, i love borges.
23:27:29 <Korollary> kilimanjaro, psykotic : #haskell-blah does indeed exist for the non-haskell stuff.
23:27:32 <olsner> @yow
23:27:33 <lambdabot> I'm in direct contact with many advanced fun CONCEPTS.
23:27:37 <lament> borges is awesome
23:27:40 <psykotic> kilimanjaro, sorry :)
23:27:44 <psykotic> Korollary, sorry
23:28:00 <wli> glguy: Well, I set up a calculator app to act as a test driver but it's probably worth getting critiqued for monad and parsec usage.
23:28:11 <bitwize> wow, that yow quote pretty much describes the haskell state of mind :)
23:28:21 <glguy> wli: I mean twhen you said you were in haskell-cafe, but I was looking over your calc code too
23:28:21 <wli> glguy: Test driver for line editing routines, rather.
23:28:40 <lament> hey, sweet, there's a "PYTHON POWERED" banner on haskell.org when you subscribe to haskell-cafe.
23:29:06 <sorear> lament: would you prefer a "WE NIH MAILMAN" banner? ;)
23:29:25 <wli> glguy: I'll probably shortly add in options of some kind to choose between line editing routines.
23:30:21 <glguy> wli: I'm not sure if this makes it easier or harder to read, but one thing you can with if you have many liftIOs in a row is: liftIO $ do a ; b ; c
23:30:30 <glguy> with ; being indented new lines
23:30:40 <glguy> rather, one thing that I do
23:30:47 <olsner> #haskell is making me late for work... again...
23:30:53 <glguy> (I'm aware that that is highly superficial feedback so far :) )
23:31:13 <ohub> I'm @work, reading #haskell. :)
23:31:19 <opqdonut> same here :)
23:31:34 <ohub> and watching ghc compile
23:31:37 <glguy> Im in ur job, wastin ur time
23:31:41 <dons> hey, Hugh Perkins wants to do a phd in parallelism/concurrency research. funny guy
23:31:42 <Korollary> glguy: nice
23:32:07 <wli> glguy: It'd be nice if they came pre-lifted, but anyway.
23:33:00 <glguy> wli: maybe a System.IO.Lifted is in order?
23:33:11 <glguy> (since they can't be prelifted in base since mtl isn't in base)
23:33:17 <wli> glguy: Could be convenient, sure.
23:34:55 <glguy> wli: zipWithM_ exists
23:35:04 <glguy> (regarding the use of mapM_ and zip
23:35:08 <glguy> and uncurry
23:37:42 <glguy> things like: fmap (const Quit) $ string "quit"   might be clearer as: string "quit" >> return Quit
23:38:01 <glguy> (I like your approach, so I don't have much to fuss about wrt to your monadic code)
23:41:40 <wli> glguy: The parsec seems clunky at best, though.
23:41:59 <reffie> i must be an idiot, but i can't figure out how to make a two dimentional array out of a list
23:42:27 <reffie> for some unknown reason array "((0,9),(0,9)) [((x,y),l!!(x+y*10))|x<-[0..9],y<-[0..9]]" fails
23:42:59 <reffie> i guess the first " should go before array
23:44:21 <reffie> oh i see ((0,0),(9,9))
23:45:22 <Korollary> reffie: why not use Data.Array?
23:45:32 <reffie> Korollary that's what i'm trying to do
23:45:47 <Korollary> reffie: you said list, tho
23:45:54 <Korollary> ah
23:45:57 <reffie> i want to make an array from the elements of a list
23:45:57 <Korollary> construct from a list
23:46:13 <reffie> i'm sure there's a faster way than to use !!
23:46:34 <glguy> wli: have you used http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Expr.html
23:46:35 <lambdabot> http://tinyurl.com/39k4yy
23:46:41 <wli> mkMatrix rows = let { rowLens = map genericLength rows ; minRowLen = minimum rowLens ; maxRowLen = maximum rowLens ; nrRows = genericLength rows } in do { guard $ minRowLen == maxRowLen ; return $ array ((1,1),(nrRows, maxRowLen)) [((i,j), rows   !! (fromIntegral $ i-1) !! (fromIntegral $ j-1)) | i <- [1..nrRows], j <- [1..maxRowLen]] }
23:47:17 <wli> glguy: No, I've never looked.
23:47:47 <glguy> wli: maybe border-line cheating, but it could serve some use in your example
23:48:11 <Korollary> reffie: what is 'l'?
23:48:15 <reffie> a list :)
23:48:33 <wli> glguy: Not sure how precedences work out there, but I'm guessing the list order may have something to do with it.
23:48:53 <glguy> wli: yeah, that was my assumption... I haven't used this yet either
23:48:57 <wli> reffie: See mkMatrix above.
23:49:06 <reffie> looks like you still use !!
23:49:41 <reffie> which is very slow
23:50:09 <wli> reffie: I never heard anything about not wanting to use it. I'm sure it's possible to avoid it somehow, for instance zips etc.
23:53:43 <sorear> What happened?
23:54:10 <glguy> *Main> parseTest (math_expr (fmap read (many1 digit))) "1+2*4"
23:54:10 <glguy> 9
23:54:15 <sorear> 2+ lines per second to <0.25 lines per minute
23:54:23 <sorear> that just ain't natural!
23:54:24 <sorear> :)
23:54:45 <wli> reffie: mkMatrix rows = let { rowLens = map genericLength rows ; minRowLen = minimum rowLens ; maxRowLen = maximum rowLens ; nrRows = genericLength rows } in do { guard $ minRowLen == maxRowLen ; return $ array ((1,1),(nrRows, maxRowLen)) (concat $ zipWith (\i row -> zipWith (\j x -> ((i,j),x)) [1..maxRowLen] row) [1..nrRows] rows)
23:54:46 <hpaste>  glguy pasted "expr example" at http://hpaste.org/2106
23:55:18 <reffie> thanks
23:55:26 <hpaste>  glguy annotated "expr example" with "make it go" at http://hpaste.org/2106#a1
23:55:34 <luqui> why does this diverge: data Foo = Foo { foo :: Foo, bar :: Int };  let foo n = (foo (n+1)) { bar = n } in foo 0
23:55:38 <luqui> shouldn't it just be 0?
23:56:21 <luqui> er
23:56:23 <opqdonut> no, foo 0 calls foo 1 which calls foo 2 etc
23:56:24 <luqui> duh
23:56:49 <luqui> poor naming, though it doesn't make a difference
23:57:13 <glguy> wli: doesn't appear to support ( )'s though :(
23:57:30 <wli> glguy: Oh dear.
23:57:36 <glguy> wli: oh
23:57:39 <luqui> oh, excuse me
23:57:45 <glguy> maybe you need to build that into your number parser?
23:57:54 <glguy> wli: and then recursively call the math_expr
23:57:55 <rhz> getCPUTime has a broken link in Hoogle
23:57:56 <luqui> I meant let f n = (f (n+1)) { bar = n } in bar (f 0)
23:58:02 <rhz> can it still be used though?
23:58:11 <wli> glguy: That's kind of how it already works so no problem.
23:58:39 <opqdonut> luqui: ah, i see
23:58:53 <opqdonut> luqui: i think your problem is that + is strict
23:59:02 <luqui> reeelie...
23:59:10 <wli> > mkMatrix rows = let { rowLens = map genericLength rows ; minRowLen = minimum rowLens ; maxRowLen = maximum rowLens ; nrRows = genericLength rows } in do { guard $ minRowLen == maxRowLen ; return $ array ((1,1),(nrRows, maxRowLen)) (concat $ zipWith (\i row -> zipWith (\j x -> ((i,j),x)) [1..maxRowLen] row) [1..nrRows] rows) in mkMatrix [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
23:59:11 <lambdabot>  Parse error
23:59:21 <sorear> opqdonut: nah, the problem is that record update is strict :)
23:59:27 <opqdonut> ah okay
23:59:28 <glguy> wli: fixed!
23:59:31 <luqui> that makes more sense..
23:59:36 <glguy>   getNum = between (char '(') (char ')') math_expr
23:59:36 <glguy>         <|> fmap read (many digit)
23:59:40 <glguy> :)
23:59:56 <luqui> sorear, it is impossible to have a lazy record update?
23:59:57 <glguy> now all that's left to add is 'spaces'
