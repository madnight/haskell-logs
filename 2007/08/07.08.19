00:00:07 <wli> Expr makes the point better.
00:00:30 <ChilliX> Maybe, the above is shorter :)
00:01:05 <wli> Brevity is not clarity.
00:01:30 <ChilliX> But a virtue!
00:02:45 <wli> No.
00:03:20 <ChilliX> It is for me, as I am too verbose.
00:04:10 <wli> Brevity, in isolation, is nothing in particular.
00:04:23 <glguy> arguing with wli is typically no fun ;) its all one word answers and "not debatables"
00:04:37 <nornagon> so, i'm trying to think of something cool to do with hopengl
00:04:42 <nornagon> but it's not coming :(
00:05:07 <nornagon> i tried translating my random terrain generator to haskell a while ago, but I couldn't work out a nice data structure for the terrain data
00:05:23 <ChilliX> glguy: re one word answers, proves my point
00:05:36 <wli> I don't find argument or debate entertaining.
00:05:40 <glguy> data Type v = TVar v | TInt | Fun (Type v) (Type v) -- I' mreading this example now
00:05:44 <wli> ChilliX: It does not.
00:06:27 <ChilliX> wli: You achieved brevity and hence do not value it anymore.  I am still striving...
00:07:36 <wli> ChilliX: In isolation, brevity is nothing. Machine code, for instance, is very compact.
00:08:40 <wli> ChilliX: @pl often produces very brief equivalents of expressions.
00:09:16 <ChilliX> wli: I am actually not disagreeing.  It was just too tempting to argue ;)
00:09:35 <wli> ChilliX: IHBT.
00:09:54 <ChilliX> (I am not disagreeing that brevity in isolation is nothing.)
00:10:28 <wli> The substitution monad is vastly more enlightening than the list monad.
00:10:36 <wli> It's vastly more comprehensible.
00:10:37 <ChilliX> (I still think that the length/clarity ratio of the above do expression for making clear that monads are not about sequencing actions or so is quite good.)
00:11:09 <ChilliX> wli: The advantage of the list monad is that everybody knows it by heart.
00:11:17 <wli> ChilliX: False.
00:11:22 <ChilliX> Good examples are trivial.
00:11:28 <ChilliX> Ah, now we really disagree.
00:11:31 <ChilliX> :)
00:12:38 <glguy> if you want a trivial example, use Identity
00:13:01 <wli> Identity is too trivial to show any machinery working.
00:13:35 <wli> The list monad is has numerous subtle ordering and combinatorial issues.
00:13:37 <ChilliX> glguy: yeah, I actually agree with wli on that
00:14:22 <ChilliX> wli: But it works as an explanation.  I actually used it in a lecture last week.
00:14:25 <dolio> Sets are probably a better example than lists, since you can't observe the difference between { x <- [1,2,3] ; y <- "abcd" ...} and { y <- "abcd" ; x <- [1,2,3] ...}
00:14:36 <dolio> Except we can't make Data.Set a Monad currently.
00:14:37 <wli> The substitution monad on Expr is rigidly constrained in structure. The join operation merely grafts the subtree in the argument of the Var constructor in place of the Var constructor.
00:14:37 <ChilliX> It seemed to work there.
00:14:55 <nornagon> dolio: yes actually, you can observe the difference
00:14:58 <nornagon> i just did
00:14:58 <nornagon> :)
00:15:17 <dolio> Where?
00:15:18 <nornagon> > [(x,y) | x <- [1..3] , y <- "abc"]
00:15:20 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
00:15:25 <ChilliX> wli: but it needs explanation distracting from the actual objective of the explanation
00:15:31 <glguy> nornagon: reread dolio's whole message
00:15:33 <nornagon> > [(x,y) | y <- "abc", x <- [1..3]]
00:15:34 <lambdabot>  [(1,'a'),(2,'a'),(3,'a'),(1,'b'),(2,'b'),(3,'b'),(1,'c'),(2,'c'),(3,'c')]
00:15:35 <dolio> That's a list, not a set.
00:15:47 <taruti> Is there a way to specify the order c2hs will run output marshallers?
00:15:47 <nornagon> oh, right
00:15:48 <nornagon> sorry
00:15:58 <nornagon> i misinterpreted
00:16:12 <nornagon> :#
00:16:23 <ChilliX> taruti: not currently
00:38:40 <OceanSpray> this Add primitive I wrote is funky
00:38:47 <OceanSpray> hpaste, url
00:38:47 <hpaste> Haskell paste bin: http://hpaste.org/
00:39:17 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/2331
00:39:40 <OceanSpray> how do I make it more efficient/elegant/prettier?
00:40:10 <glguy> Suppose you are trying to force your own document format through a standards organization, and you are competing with OOo's format
00:40:14 <Cale> OceanSpray: looks like liftIO . unwrap is coming up a lot
00:40:21 <glguy> What better name to choose than OOXML?
00:40:22 <OceanSpray> yeah
00:40:35 <OceanSpray> so, what
00:40:44 <OceanSpray> make it a utility function?
00:40:48 <Cale> yeah
00:41:08 <Cale> Especially as it's really that monad which you're going to be using unwrap a whole lot in.
00:41:51 <Cale> (you might even change the type of wrap/unwrap so as to work in any MonadIO and just put the liftIO's in the instances)
00:42:51 <OceanSpray> is IO a MonadIO ?
00:42:54 <Cale> yep
00:43:00 <OceanSpray> huh
00:43:13 <Cale> also, can I see the Wrapper class declaration again?
00:43:13 <OceanSpray> so if I use liftIO in an IO monad, it won't do anything?
00:43:16 <Cale> right
00:43:31 <OceanSpray> well, WHY WASN'T I TOLD THIS BEFORE!?
00:43:34 <Cale> hehe
00:43:35 <OceanSpray> orz
00:43:59 <glguy> even if it wasn't...
00:44:04 <glguy> you could have added it easily enough
00:44:38 * wli wrote a System.IO.LiftedIO.hs that basically just consists of every function in System.IO with liftIO done to it.
00:45:17 <OceanSpray> huh
00:45:30 <OceanSpray> do I put liftIO in front of 'return's too?
00:46:04 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2331#a1
00:47:11 <glguy> OceanSpray: You have three pastes on the front page without titles, please try harder
00:47:24 <shapr> glguy: XOO?
00:47:30 <OceanSpray> whoops, sorry
00:49:03 <Cale> OceanSpray: What does wWrite do for Id?
00:49:12 <Cale> (nothing?)
00:49:15 <shapr> glguy: I think it won't matter if OOXML is 'chosen' by the standards organizations, I think ODF will still beat it.
00:49:16 <OceanSpray> yep
00:49:21 <OceanSpray> it prints out a message
00:49:26 <OceanSpray> but ultimately does nothing.
00:49:52 <glguy> shapr: sure, I just think its funny that they tried to confuse the issue with the name of the format
00:49:53 <Cale> okay, cool
00:50:18 <shapr> glguy: Seems to me that Microsoft will do just about anything to keep their monopoly.
00:51:00 <shapr> I think that Vista is going to tear it apart though.
00:51:35 <wli> shapr: Well, there's also the general lack of need for upgrades.
00:52:10 <shapr> In general, people who've switched to Vista seem to regard it as a downgrade.
00:52:37 <glguy> I had an MSDN subscription at my old job
00:52:47 <wli> shapr: Not sure.
00:52:54 <glguy> and gave vista a try... needless to say I'm still running XP :)
00:52:59 <wli> shapr: I don't hear much from that side of things.
00:53:36 <shapr> I got to use Vista for a few days recently. I was truly amazed by its ability to be sluggish on a powerful dual core computer, and by its ability to be annooying and irritating every few seconds.
00:53:57 <glguy> when I first tried it, ghc 6.6.1 wasn't out yet
00:54:04 <glguy> so that was an immediate deal breaker
00:54:17 <shapr> How does ghc relate to vista?
00:54:25 <glguy> 6.6 wouldn't run on it
00:54:27 <shapr> oh
00:55:37 <shapr> I was using a laptop, and it took anywhere from fifteen to thirty seconds to resume from sleep mode.
00:56:07 <Cale> I really like the fact that I can feel pretty comfortable recommending Ubuntu to people now.
00:56:18 <Cale> (Like, nontechnical people)
00:56:20 <shapr> Bootup time was enough to make a sandwich and start eating it.
00:56:31 <glguy> I've never seen linux do suspend correctly before. I've heard people who have seen it, but I haven't
00:56:43 <shapr> The most irritating thing by far was the allow and deny questions everytime you tried to do ANYTHING!
00:56:50 <wli> I've been hearing recent Linux is actually getting good at it.
00:57:01 <Cale> glguy: I suppose I've never tried it on a laptop.
00:57:47 <Cale> glguy: Apparently wireless support is actually getting reasonably good, which is something that I've heard was a problem.
00:58:04 <glguy> yeah, it was
00:58:22 <glguy> I used to run openbsd on my laptop because it had better support for my old laptop than linux
00:58:30 <glguy> in terms of wireless and apm
00:58:42 <glguy> but recent ubuntu installs I've seen have been much better
00:59:38 <shapr> I got my brother started with Ubuntu two weeks ago.
01:00:18 <OceanSpray> oh wow
01:00:22 <OceanSpray> this is so much easier
01:00:53 <OceanSpray> I got rid of all the unsightly liftIO's by modifying the Wrapper class
01:01:55 <Cale> :)
01:02:25 <OceanSpray> Any other timely suggestions before I go on?
01:03:02 <OceanSpray> my interpreter now can add, define, set!, bind!, clone and undefine
01:03:09 <OceanSpray> behold!
01:03:21 <OceanSpray> > (bind! a (+ 2 3 4))
01:03:21 <OceanSpray> > a
01:03:21 <OceanSpray> 9
01:03:22 <lambdabot>   Not in scope: `a'
01:03:23 <lambdabot>   Not in scope: `a'
01:05:31 <dons> OceanSpray: cool!
01:05:44 <dons> good to see progress
01:06:05 <OceanSpray> now, on to subtract, multiply and divide.
01:06:50 <Cale> shapr: Did you see http://www.hiren.info/funstuff/funny-video-clips/lady-with-bike ? (Given the unicycling, this might be of some interest :)
01:06:52 <lambdabot> Title: Funny Videos Â» Lady with Bike - www.hiren.info
01:07:18 <OceanSpray> HEY, I POSTED THAT FIRST!
01:07:23 <Cale> It's not really "Funny" though.
01:07:41 <Cale> OceanSpray: oh, you did?
01:08:02 <OceanSpray> oloya
01:08:14 <pjd> OceanSpray: what's bind! ?
01:08:53 <OceanSpray> well, it's the same thing as scheme's set!
01:09:09 <OceanSpray> and this dialect's set! modifies the value as opposed to tbe binding
01:09:21 <shapr> Cale: Won't load for me, is it flash or msie?
01:09:29 <Cale> shapr: flash
01:09:36 <hpaste>  gleb pasted "limitations of impredicativity" at http://hpaste.org/2332
01:09:49 <gleb> hello everyone
01:09:50 <Cale> OceanSpray: what language are you implementing?
01:09:55 <OceanSpray> a new one.
01:10:03 <OceanSpray> you didn't get the memo?
01:10:03 <shapr> OceanSpray: Hey, chill out on the caps please.
01:10:22 <pjd> OceanSpray: that could get confusing quickly
01:10:31 <Cale> OceanSpray: do you have a spec somewhere that you're following, or are you making it up as you go?
01:10:38 <OceanSpray> the spec's in my head.
01:10:42 <Cale> ah
01:10:44 <pjd> shouldn't value modification have type-specific modifiers?
01:10:53 <OceanSpray> type-specific?
01:11:02 <OceanSpray> no?
01:11:10 <OceanSpray> it just writes a new value into the IORef
01:11:23 <pjd> so you're replacing it, rather than modifying it
01:11:29 <OceanSpray> yes.
01:11:35 <OceanSpray> hence, set!
01:11:37 <pjd> maybe call it replace!, then? :)
01:12:04 <OceanSpray> too wordy
01:12:13 <pjd> set!! ?
01:12:23 <gleb> Why cannot I instantiate Reader monad with polymorphic type unless it's wrapped in newtype?
01:12:28 <OceanSpray> I keep my primitives under seven letters long
01:12:46 <OceanSpray> what's wrong with calling it set! ?
01:12:57 <pjd> gratuitous surprise!
01:13:30 <OceanSpray> it's only surprise to those who don't know the language.
01:13:40 <OceanSpray> Haskell uses the word 'class'
01:13:55 <OceanSpray> you 'gratuitously surprise' Java users
01:14:18 <pjd> that's surprise, but not gratuitous
01:14:58 <OceanSpray> so, what
01:15:06 <pjd> in any case, consider set!!;  it would be like (Scheme) set!, but more so
01:15:21 <OceanSpray> set!!1
01:15:25 <nornagon> dammit
01:15:28 <nornagon> you beat me to it
01:15:54 <OceanSpray> lol
01:16:08 <nornagon> also, holy crap, i just made my first use of monad transformers typecheck! hooray!
01:16:09 <glguy> does it matter what you call the functions in a language no one will use? the point is to implement it for the sake of implementing it.. right?
01:16:39 <pjd> glguy: you have no ambition
01:16:40 <OceanSpray> glguy, I bet you're really popular at parties.
01:16:50 <gleb> nornagon: congratulations!
01:17:42 <pjd> it seems silly to mostly follow Scheme naming convention, and then break it for that
01:17:43 <gleb> nornagon: I've been playing with monad transformers using ContT + rank-2 types, so I've got a couple of ticks howto make it NOT typecheck again ^)
01:17:49 <nornagon> hehe
01:18:16 <nornagon> mine is just a lil' ol' WriterT [((Int,Int),Float)] (State StdGen) ()
01:18:31 <gleb> I see
01:19:00 <OceanSpray> convention is just convention.
01:19:10 <OceanSpray> I can easily change it later.
01:19:22 <nornagon> but now I realise I'm going to have to be able to read that array that I'm writing as well... damn
01:19:29 <OceanSpray> right now, I don't want it to feel too exciting.
01:20:09 <glguy> Microsoft's New Zealand patent #525484 âWordprocessing document stored in a single XML file that may be manipulated by applications that understand XMLâ.
01:20:13 <glguy> isn't that fucking novel
01:20:37 <pjd> OceanSpray: boring existing naming conventions are less exciting :)
01:20:52 <gleb> nornagon: what array? [((Int, Int), Float)]? You cannot use it like array in the Writer monad, it's more like a log, you only can append to it
01:21:18 <gleb> nornagon: if you need array, better use array and, say, ST monad
01:21:21 <nornagon> yeah, i know... I thought it'd be enough, but it turns out not -.-
01:21:27 <nornagon> I haven't looked at the ST monad
01:21:29 <nornagon> er
01:21:32 <nornagon> i meant list
01:21:44 <timtheli1n> glguy: do you have any idea at the kind of ingenuity it took their lawers to get that patent through the system?
01:21:54 <OceanSpray> oh crap
01:22:03 <nornagon> but it's eventually going to be turned into an array, so I guess I could go straight there...
01:22:05 <OceanSpray> maybe I shouldn't be writing these primitives so soon
01:22:16 <OceanSpray> there's still one, crucial missing part:
01:22:18 <OceanSpray> continuations
01:22:49 <gleb> nornagon: I don't know anything about your task, but I guess, you can replace WriterT with StateT and it can be enough
01:23:02 <OceanSpray> adding those will likely result in a different return-type, and hence, will force me to rewrite functions
01:23:26 <OceanSpray> btw, how DO I implement continuations, anyway?
01:23:36 <nornagon> hm... but is it efficient with all that get, modify, put?
01:24:00 <nornagon> (my task is to generate a random height map using the diamond-square method)
01:24:07 <nornagon> (i.e, subdivide and conquer)
01:26:22 <pjd> OceanSpray: using a CPS representation internally is probably easiest
01:26:33 <gleb> nornagon: hm, there's no much overhead in State itself, but I doubt it will be efficient to modify list element-wise
01:26:43 <OceanSpray> oookay.
01:27:08 <nornagon> gleb: all I'll be doing is adding new elements and reading old ones
01:27:09 <pjd> otherwise, if you maintain an interpreter stack, capture that
01:27:29 <nornagon> but I guess it should be an Array straight off rather than a list
01:27:35 <nornagon> (to be passed to array)
01:28:03 * glguy wonders what dogs dream about
01:28:14 <nornagon> glguy: food
01:28:17 <sorear> glguy: Microsoft has also patented the exclusive-OR operation and the hyperlink.  Australia has issued a patent for the wheel.
01:28:19 <nornagon> glguy: and cats
01:28:24 <scodil> and running
01:28:30 <scodil> mine dreams about running
01:28:33 <evir> Yeah running.
01:28:35 <scodil> her feat move when she dreams
01:28:37 <evir> They often do running movements.
01:28:37 <scodil> feet, eeven
01:28:40 <evir> When sleeping.
01:28:46 <evir> :-)
01:28:46 <nornagon> mm, mine too
01:28:50 <OceanSpray> what's an interpreter stack?
01:29:29 <pjd> OceanSpray: the call/return stack, if you're not using CPS
01:29:39 <OceanSpray> ah.
01:30:12 <pjd> "continuation" and "return stack" are more or less synonymous
01:31:52 <glguy> mine is apparently dreaming about wiggling his nose
01:32:08 <gleb> OceanSpray: I would suggest reading "Definitional Interpreters" by Reynolds
01:33:02 <wli> I'm sitting here stumped by how to trace level curves of quadratic forms on ZxZ and/or NxN.
01:33:59 <wli> x^2+y^2, 4*x^2+y^2, 3*x^2+y^2, and 3*x^2-y^2
01:34:22 <Cale> Well, the ones which are bounded are not so bad.
01:35:16 <wli> Hmm? Well, it's basically solving f(x,y)=n, or otherwise trying to enumerate lists of (x, y) in order by the value of f(x,y).
01:35:42 <wli> The old problem of sorting an infinite list.
01:35:59 <Cale> Well, x^2 + y^2 = n has solutions whose norm is at most sqrt(n)
01:36:07 <Cale> So that's a finite space to search.
01:36:50 <Cale> Same goes for 4*x^2+y^2, but the space is actually smaller
01:36:56 <wli> [[(x, y) | (x, y) <- pairs, x*x+y*y==n] | n <- [0..]]
01:37:08 <scodil> wli: aren't those just conics?
01:37:10 <wli> That's the sort of enumeration attempted here.
01:37:14 <wli> scodil: Yes.
01:37:43 <Cale> wli: yeah, so you just have to arrange that no element of pairs (or only a finite number) has too large a norm.
01:38:07 <Cale> The hyperbolic case is harder.
01:38:28 <wli> The hyperbolic case breaks down to something analogous to a Pell equation.
01:39:50 <scodil> why can't you just find the focii and all that?
01:40:18 <Cale> scodil: He's only interested in integer solutions
01:40:22 <wli> scodil: Hmm? Usually it involves projecting the things onto a line.
01:40:30 <scodil> oh right
01:40:44 <scodil> i saw Z but read R
01:40:45 <scodil> nm
01:41:49 <Cale> I wish I knew the first thing about number theory from the perspective of algebraic geometry.
01:42:05 <Cale> That seems like it might be useful here :)
01:42:38 <wli> The "standard tricks" as they're taught don't apply well to real-life. :(
01:44:15 <wli> I actually just did something like this for PE#137; it boiled down to y^2=5*x^2+2*x+1
01:44:49 <dons> hmm, is haskell.org having one of its sunday late sleep-ins?
01:44:58 <wli> The solution ended up looking like this: http://hpaste.org/2316#a2
01:45:00 <oerjan> dons: i just noticed the same
01:45:27 <wli> Which is somewhat opaque.
01:47:21 <wli> The group of units is finite in most of the associated number fields so there shouldn't be infinitudes of solutions like for PE#137.
01:48:59 <nornagon> hm, this feels a little odd... I have a StateT foo (State bar) ()
01:49:12 <nornagon> is it sane to be transforming state onto itself like that?
01:49:26 <nornagon> or should I have a State (foo,bar) and use gets fst/etc?
01:49:55 <Cale> nornagon: They're both valid options, I'm not sure which compiles better.
01:50:06 <nornagon> ah, okay
01:50:16 <nornagon> that's reassuring, I thought I was doing something really wacky
01:50:30 <oerjan> i suppose that depends on which state you are accessing the most
01:50:35 <Cale> nornagon: Probably you want to newtype that and provide more meaningful getters and setters
01:51:11 <Cale> So you won't be using lift get/gets fst directly any way
01:51:42 <nornagon> i don't actually ever use lift get directly...
01:52:05 <nornagon> the inner monad in this case is a random number monad
01:52:12 <nornagon> with a wrapper 'rand' around get
01:52:16 <scodil> wli: how efficient are you trying to be with your enumeration?
01:52:24 <wli> Z[(-2)^(1/2)] corresponds to 4*x^2+y^2
01:52:27 <nornagon> that gets the generator, extracts a random number, sets the generator and returns the number
01:52:33 <gleb> nornagon: did you try pure solution? I'm reading about Diamond-Square now and have a feeling, that it's possible to code it without monads
01:52:47 <wli> scodil: Asymptotically optimal but not giving a hoot about bit twiddling details.
01:52:55 <nornagon> gleb: Possibly... I thought about it for a little while and it made my head sore :)
01:53:26 <wli> scodil: I guess I need units in Z[(-2)^(1/2)] now.
01:53:36 <wli> scodil: Or Q[(-2)^(1/2)] now.
01:53:56 <gleb> nornagon: first, you can get infinite stream of random numbers and get rid of State StdGen
01:54:37 <wli> 4*x^2+y^2=z^2 in integers gets it.
01:55:41 <scodil> wli: would it be unreasonable to overlay an integer grid and walk along the grid boxes, looking checking the grid points as you go?
01:55:56 <scodil> ugh. can't type.
01:56:21 <wli> scodil: That's not generally how these things are approached. I suspect it would be slow.
01:57:03 <Hirvinen> shapr: Cool.
01:58:08 <scodil> it would be linear in the number of grid cells, which may or may not be big. for all the examples you've given it would probably be pretty quick. for something like 6657575x^2+6y^2... maybe not so much
01:58:52 <nornagon> gleb: sure, but how do you 'remove' the random numbers you've already used?
01:59:09 <nornagon> i guess you could recurse down the list and call the next function with the tail of the randoms list
01:59:25 <wli> (2/5)*(-2)^(1/2)+(3/5) is one unit.
01:59:46 <gleb> nornagon: exactly
01:59:52 <wli> (6, 5, 13) another.
02:00:05 <wli> Looks related to Pythagorean triples.
02:01:24 <wli> Basically Pythagorean triples where you can pull a factor of 2 out of one of the non-hypotenuse sides.
02:02:05 <wli> 3*x^2+y^2 is somewhat different.
02:02:43 <wli> ugh, it's not (-2)^(1/2), it's 2*(-1)^(1/2)
02:02:57 <wli> (-3)^(1/2) is genuine, though.
02:09:05 <wli> I seem to be having issues with 3*x^2-y^2=z^2
02:10:14 <wli> 3*x^2=y^2+z^2; 3|y^2+z^2, (y,z)=1, contradiction.
02:10:34 <wli> So the group of units is trivial: +/-1
02:14:51 <oerjan> hm, maybe something similar apply to any prime mod which -1 has no square root?
02:14:57 <oerjan> *may
02:15:08 <wli> oerjan: Not just primes.
02:15:57 <wli> oerjan: I only really care about 4*x^2+y^2, 3*x^2+y^2, x^2+y^2, and 3*x^2-y^2 for now, though.
02:16:42 <wli> oerjan: I think that since the units in Z[3^(1/2)] are trivial that solutions of 3*x^2-y^2 in the first quadrant are unique.
02:17:41 <wli> 2+3^(1/2) are claimed to be units...
02:17:58 <wli> Woops.
02:18:26 <wli> 2+/-3^(1/2) really.
02:20:25 <wli> So x=1, y=1 gives 3*x^2-y^2=2, then (2+3^(1/2))^n*(1+3^(1/2)) give more solutions.
02:22:43 <wli> > let (x,y) `m` (u,v) = (u*x+3*y*v,x*v+y*u) ; ts = (1, 1) : map (m (2,1)) ts in take 10 ts
02:22:52 <lambdabot>  [(1,1),(5,3),(19,11),(71,41),(265,153),(989,571),(3691,2131),(13775,7953),(5...
02:23:07 <wli> Solutions to 3*x^2-y^2=2
02:23:42 <wli> > let (x,y) `m` (u,v) = (u*x+3*y*v,x*v+y*u) ; ts = (3, 2) : map (m (2,1)) ts in take 10 ts
02:23:44 <lambdabot>  [(3,2),(12,7),(45,26),(168,97),(627,362),(2340,1351),(8733,5042),(32592,1881...
02:24:03 <wli> 3*x^2-y^2=3 in like fashion.
02:27:28 <Heffalump> morning
02:30:03 <wli> This is Pell equation -style.
02:31:07 <wli> It's really Z[i] for 4*x^2+y^2 and Z[(-1+(-3)^(1/2))/2] for 3*x^2+y^2
02:32:02 <wli> Those two have norms that happen to coincide with the complex modulus so it's different for them.
02:33:51 <wli> +/-(2+/-3^(1/2)) has modulus 7^(1/2) so as long as the maximum modulus of the search region is strictly less than 7^(1/2) times the minimum modulus of the search area the solutions derived from unit multiplication are irrelevant.
02:34:59 <Cale> wli: If you'd like an open problem to work on (at least, I think it's still open), determine whether 6 is a difference of perfect powers.
02:35:44 <Cale> Where a perfect power is a number m^k for some m, k >= 2
02:36:21 <sphynx> hello
02:36:25 <Cale> hi
02:36:49 <sphynx> Is it possible to use 'let .. in' clause inside of list comprehension?
02:37:02 <wli> Cale: Well, I'm attempting to translate the Sieve of Atkin to something that produces a lazy list like the other prime sieving affairs for Haskell.
02:37:02 <Cale> yes
02:37:37 <Cale> (let <decls> in <expr>) is an expression
02:38:01 <Cale> also, you can have alongside your guards, let <decls>
02:38:05 <Cale> (without the in)
02:38:12 <wli> Trick is, since our region isn't bounded, this basically means an infinitude of solutions to 3*x^2-y^2=n in the first quadrant if there are any at all.
02:38:49 <Cale> and those declarations will scope over the following guards and generators and the expression built
02:39:18 <sphynx> Cale, thanks, I will try!
02:39:36 <EvilTerran> > [x | y <- [1,2,3]; let x = 2 * y]
02:39:36 <lambdabot>  Parse error
02:39:40 <EvilTerran> > [x | y <- [1,2,3], let x = 2 * y]
02:39:45 <lambdabot>  [2,4,6]
02:41:50 <Cale> > let even n = n `mod` 2 == 0 in [let y = x^2 in y+2*y | x <- [1..60], let u = x `div` 3, even u]
02:41:52 <lambdabot>  [3,12,108,147,192,432,507,588,972,1083,1200,1728,1875,2028,2700,2883,3072,38...
02:42:06 <Cale> That uses 'let' in all the ways I mentioned :)
02:43:13 <sphynx> Cale: yeah it works for me, thank you very much
02:43:22 <Cale> sphynx: no problem :)
02:44:16 <sphynx> so if I use let clause it calculates only one time, and if I don't - every  time when it appears in expression, right?
02:44:43 <Cale> Generally, yeah.
02:44:55 <EvilTerran> it's officially implementation-dependent, though
02:45:05 <Cale> Pattern bound things (constants), won't be recomputed so long as they stay in scope
02:45:41 <Cale> GHC doesn't currently look very hard for repeated expressions though, so you have to explicitly name them if you want them shared.
02:46:12 <Cale> (It's tricky to decide whether it's an optimisation or a pessimisation to common things up like that)
02:46:34 <wli> Cale/scodil: Aha, it's another story if x > y > 0 and 3*x^2-y^2=n
02:54:35 <sphynx> so if I have something like [(fst px, snd py) | px <- xs, py <- xs, fst px == snd py, fst px /= fst py, ...], then GHC recalculates all these 'fst ps', right?
02:56:08 <EvilTerran> [(fpx,spy) | (fpx,spx) <- xs, (fpy,spy) <- ys, ...]?
02:57:47 <sphynx> EvilTerran: Yeah, I can write optimized code, just asking about how it should work as it is written currently
02:58:00 <sphynx> just as an example
02:58:07 <EvilTerran> meh, it depends.
02:58:46 <EvilTerran> you can generally assume that something bound to a name will only be evaluated once, and you shouldn't rely on identical subexpressions being identified as such
02:59:15 <EvilTerran> but none of it's guaranteed by the report, afaik
02:59:29 <sphynx> EvilTerran: well, understood
02:59:45 <EvilTerran> that's just how GHC does it. i think.
03:00:28 <wli> minimize f=(3*x^2-y^2-n)^2, grad f = 4*(3*x^2-y^2-n)*[3,-1], hess f = 12*[[27*x^2-3*y^2-3*n, -6*x*y],[-6*x*y, 3*y^2-3*x^2+n]]
03:01:04 <wli> grad f = 4*(3*x^2-y^2-n)*[3*x,-y] rather.
03:05:01 <scodil> the (non-local) minimum is just f=0, isn't it? what does that get you?
03:05:27 <wli> scodil: The location at which the minimum occurs for a given n is what matters.
03:10:13 <scodil> its still just the hyperbola 3*x^2-y^2=n, right? what does the gradient and hessian give you?
03:10:57 <wli> scodil: For a given n, a way to search for (x, y) satisfying the relation for a given n.
03:21:43 <Ender> All Trance Music Listeners - TranceRadio ! http://klausyk.Smagus.Net !
03:21:44 <lambdabot> Title: Trance Paradise
03:23:03 <Ender> All Trance Music Listeners - TranceRadio ! http://klausyk.Smagus.Net !
03:23:04 <lambdabot> Title: Trance Paradise
03:25:40 <EvilTerran> banhammer?
03:26:18 <scodil> jan hammer?
03:27:27 <wli> Hmm, the Newton solver doesn't really come close to any integer points.
03:29:36 <scodil> wli: you're trying to minimize (3*x^2-y^2-n)^2? by gradient descent?
03:31:31 <wli> Well, what do I need for (3*x^2-y^2) `mod` 12 == 11?
03:32:34 <wli> scodil: Yeah. I end up so far from the integer solution it's useless, so I'm not looking into it further.
03:33:54 <scodil> maybe something to do with the asymptote? eventually you're solutions are going to all be on that line
03:33:59 <scodil> your, even
03:35:07 <wli> scodil: Integer solutions not really.
03:35:25 <wli> scodil: I've brute-forced enough to get an idea of what they look like and they're all over the place.
03:35:46 <scodil> so you're looking for something better than just {for each x, solve for y, check to see if f(x,y) \in Z} right?
03:37:30 <wli> scodil: I sort of just need an infinite list of (x, y) pairs sorted by 3*x^2-y^2
03:38:09 <scodil> and x,y, 3*x^2-y^2 all integer, right?
03:38:15 <wli> scodil: Yeah.
03:41:22 <scodil> what are you doing with the infinite list?
03:42:11 <wli> scodil: Counting the number of ways integers congruent to 11 mod 12 are representible as 3*x^2-y^2 for integers x > y > 0.
03:42:42 <wli> scodil: More generally, implementing the Sieve of Atkin as a lazy list algorithm.
03:43:09 <scodil> 'counting' in what sense? cause there's infinite ways, right? also I don't know this Sieve of Atkin
03:43:34 <wli> scodil: There are infinite ways as 3*x^2-y^2 in general. There are only finite numbers of ways with x > y > 0.
03:43:47 <scodil> you're sure?
03:44:08 <wli> scodil: I reread the proof in Dan Bernstein's paper and it says so.
03:46:24 <nornagon> woohoo!
03:46:33 <nornagon> I finally got my terrain generator going ^_^
03:47:11 <hpaste>  nornagon pasted "Random terrain generation with the State monad" at http://hpaste.org/2333
03:47:53 <nornagon> hm, that has a few bugs... like, the terrain only ever bulges outwards, due to the fact that rand is in the range [0,1) instead of [-0.5,0.5]
03:48:36 <ivant> nornagon, can you generate a nice image? :-)
03:48:44 <nornagon> ivant: that's step two :-)
03:48:48 <nornagon> it'll be OpenGL
03:49:08 <ivant> in the meantime you can generate a data set and use gnuplot :-)
03:49:19 <ivant> or something similar
03:49:31 <ivant> just to see that you're getting the right thing
03:49:40 <nornagon> http://ccdevnet.org/~nornagon/terrain2.png <-- intended output
03:50:04 <nornagon> (that's generated from a C version of the same)
03:50:28 <nornagon> and, yes, I fully expect to write the graphics part only to realise that I've majorly broken something :-)
03:50:47 <scodil> wli: do you have a link to this paper?
03:51:39 <ivant> nornagon, then you're lucky that you're generating 2d terrain (set of points). Otherwise it could be very hard to visualize :-)
03:51:41 <wli> http://www.ams.org/mcom/2004-73-246/S0025-5718-03-01501-1/S0025-5718-03-01501-1.pdf
03:51:43 <lambdabot> http://tinyurl.com/2sno9x
03:52:00 <wli> [(x, y, 3*x*x-y*y, (3*x*x-y*y) `mod` 12) | x :: Integer <- [1..], y :: Integer <- takeWhile (<=(x-1)) (concat [map (\t -> 12*k+t) (if even x then [1,5,7,11] else [2,4,8,10]) | k <- [0..] ])]
03:52:49 <nornagon> ivant: well, it's a heightmap
03:53:18 <ivant> nornagon, yep, but imagine that you're generating n-dimensional heightmap :-)
03:53:31 <nornagon> -.-
03:58:36 <wli> scodil: Any ideas?
03:59:40 <scodil> wli: i didn't see the proof in that paper but I see why there's a finite number of f(x,y) = z, x,y,x \in N, x > y > 0.
03:59:58 <scodil> x,y,z in Z. you know what i meant
04:00:00 <wli> scodil: Theorem 6.3
04:01:13 <wli> scodil: So apart from ordering, I get all the lattice points I want from [(x, y, 3*x*x-y*y) | x :: Integer <- [1..], y :: Integer <- takeWhile (<=(x-1)) (concat [map ((12*k)+) (if even x then [1,5,7,11] else [2,4,8,10]) | k <- [0..] ])]
04:02:28 <scodil> wli: but you want them ordered by 3xx-yy
04:02:31 <wli> scodil: For the algorithm to work, I have to know when I've come to a point in the list where it's no longer possible for there to be any solutions to 3*x^2-y^2=n for n < some bound.
04:03:36 <scodil> is n in Z or N? positive or not?
04:03:59 <wli> scodil: n is in N, a candidate prime.
04:05:19 <wli> For a given y, the least possible x is y+1, so the least possible value of 3*x^2-y^2 is 3*(y+1)^2-y^2 = 2*y^2+6*y+3
04:07:14 <wli> So if I can get lower bound on y at a given list position I have a lower bound on 3*x^2-y^2
04:07:31 <scodil> so all your solutions will be to one side of 3x = y,
04:07:52 <scodil> wait nm meant to delete that. stupid keyboard has bs right above enter
04:08:07 <nornagon> ^U ftw :)
04:10:52 <wli> x > y, 3*x^2-y^2 > k, and the inequalities go the wrong way.
04:11:42 <wli> 3^(1/2)*x = y perhaps?
04:12:21 <scodil> right ok. so you want points below 3x=y, and to the right of x=y. The diagonal (x=y) cuts the hyperbola. so you can start enumerating from y=0, in order of increasing y, x will increase monotonically, and when x>y you stop and increment n
04:12:35 <wli> You mean 3^(1/2)*x = y
04:13:23 <scodil> do i? this paper you sent me says 3x^2-y^2=n
04:14:00 <wli> The asymptotes have slope 3^(-1/2)
04:15:33 <wli> 6*x*(dx/dt)-2*y*(dy/dt) = 0, 3*x*(dx/dt)=y*(dy/dt), (dy/dx) = 3*x/y
04:16:19 <wli> (dy/dx) = 3*x/(3*x^2-n)^(1/2)
04:17:00 <wli> Which is 3^(1/2) in the limit.
04:17:19 <scodil> right ok. i have a bad habit of thinking of quadratics as ax^2 + by^2, rather than a^2x^2 + b^2y^2.
04:17:39 <scodil> point is the same. the line x=y cuts off the hyperbola
04:18:56 <wli> Trying to figure out the y intercept of the asymptote of 3*x^2-y^2=n
04:19:31 <scodil> 0
04:19:37 <scodil> they go through the origin
04:19:55 <wli> 3*0^2-0^2 /= n
04:20:20 <scodil> the asymtotes don't depend on n
04:20:38 <scodil> you're thinking of the hyperbola
04:21:15 <scodil> wait... you've got me second guessing myself now
04:21:46 <wli> y=(3*x^2-n)^(1/2) <= 3^(1/2)*x+y_0
04:22:29 <wli> So y_0 is basically lim(x->\infty) (3*x^2-n)^(1/2)-3^(1/2)*x
04:25:04 <scodil> y_0 being... the y-intercept of the asymptote?
04:25:25 <wli> yeah, I think it's n^(1/2)
04:25:53 <scodil> i'm almost positive that the asymptotes go through the saddle point. they don't change with n.
04:26:38 <wli> Is the asymptote above or below y=(3*x^2-n)^(1/2)?
04:26:53 <scodil> asymptotes are f(x,y) = 0
04:27:05 <wli> Is it above or below y=(3*x^2-n)^(1/2)?
04:27:57 <wli> I say it's above y=(3*x^2-n)^(1/2); do you agree?
04:28:17 <kayess> Yesterday I was here asking a few things about Visual Haskell for an introduction article on my web site. It's published now. Just wondering if anybody has time to check to see I haven't said anything too stupid?
04:29:30 <scodil> wait where's your `up`? y-direction?
04:29:55 <wli> y direction. y=3^(1/2)*x + y_0 >= (3*x^2-n)^(1/2)
04:30:00 <kayess> Article is at http://www.kirit.com/Yoda%20speaks%20Visual%20Haskell - TIA
04:30:06 <lambdabot> Title: Yoda speaks Visual Haskell â kirit.com
04:32:09 <wli> scodil: Anyway, when the smoke clears y_0 is the least upper bound of (3*x^2-n)^(1/2)-3^(1/2)*x, which is 0 for all n >= 0.
04:33:28 <wli> So the wedge bounded by x > y > 3^(1/2)*x is the region of interest, okay.
04:34:02 <wli> Ergh, something went wrong.
04:34:02 <scodil> yeah that's what I was thinking all along. you through me off with this y-intercept-of-asymptote business
04:34:48 <wli> y=3^(1/2)*x is above the hyperbola. y=x is below it.
04:34:56 <wli> Or cuts it.
04:35:14 <scodil> you only want solutions below the line x = y, right? then x > y. The hyperbola approaches root3x=y as x->big, so at some point the hyperbola will hit x=y, then you can stop looking
04:36:03 <wli> Yeah, it's a crescent-shaped region.
04:36:40 <scodil> yeah i guess. a half crescent
04:37:22 <wli> Really the limit is y = x-1
04:38:00 <scodil> yeah sure cause n>=1
04:39:26 <wli> So 3*x^2-(x-1)^2=n, which is at x = ((2*n+3)^(1/2)-1)/2, or y=((2*n+3)^(1/2)-3)/2
04:39:31 <scodil> so why do you get to assume x > y?
04:39:58 <wli> scodil: It's part of the theorem on counting solutions of 3*x^2-y^2=n.
04:41:24 <wli> Okay, I have x <= ((2*n+3)^(1/2)-1)/2, y <= ((2*n+3)^(1/2)-3)/2, now for lower bounds :(
04:42:00 <scodil> why do you need lower bounds?
04:42:17 <wli> Basically to characterize the region.
04:42:43 <scodil> everything is symmetric, isn't it? just start from x=0 and work out to the right
04:42:50 <wli> Actually is it correct that those are upper bounds?
04:43:08 <wli> scodil: Spurious duplicates spoil the algorithm.
04:46:55 <wli> 3^(1/2)*x >= y >= (3*x^2-n)^(1/2) somehow needs to be inverted to inequalities on x.
04:49:14 <wli> 3*x^2 >= y^2 >= 3*x^2-n, -y^2 >= -3*x^2 >= -n - y^2, n + y^2 >= 3*x^2 >= y^2, (y^2+n)^(1/2) >= 3^(1/2)*x >= y, ((y^2+n)/3)^(1/2) >= x >= 3^(-1/2)*y ?
04:49:47 <cinimod> TestShow.hs:119:16:    My brain just exploded.    I can't handle pattern bindings for existentially-quantified constructors.
04:50:05 <cinimod> That did make me laugh
04:50:27 <nornagon> :)
04:50:48 <wli> scodil: With bounds on x for a given y things can actually make progress due to the lower bound on n for a given y.
04:51:13 <wli> scodil: Do those bounds on x look correct?
04:52:08 <scodil> its too late here for that. which direction is your enumeration going to go? increasing x then n, or what?
04:52:19 <wli> scodil: Increasing n.
04:52:35 <scodil> and for each n increasing x?
04:52:45 <scodil> and you just need the starting point for x given an n?
04:53:03 <wli> scodil: I don't care what x and y do so long as some sort of guarantee that moving forward in the list means I no longer have to consider n below some bound.
04:57:29 <Ben`> how can I turn a string like "\"foo\", \"bar\"" into a list like ["foo", "bar"]?
04:57:41 <wli> y + 1 <= x <= ((n+y^2)/3)^(1/2)
04:59:42 <Vq^> Ben`: through parsing
05:00:11 <Saul_> Ben`: I think that (read $ "[" ++ "\"foo\", \"bar\"" ++ "]") should work
05:00:55 <Saul_> Ben`: Which is parsing like Vq^ said
05:01:17 <psykotic> read isn't really the right tool
05:01:35 <Vq^> if you're sure that the structure is correct, then that would work
05:01:46 <Vq^> but i would choose parsec for that task
05:01:50 * psykotic concurs
05:01:56 <Ben`> ok, thanks
05:02:02 * Botje laments the lack of a decent split function in Prelude
05:02:05 <psykotic> unfortunately i don't think the ghc version of parsec comes with a parser for quoted strings predefined
05:03:01 <Vq^> psykotic: was it quoted?
05:03:13 <psykotic> "foo" is quoted
05:03:15 <psykotic> and you have to deal with escapes
05:03:40 <psykotic> daan's version of parsec has a lot of predefined parsers included
05:04:00 <psykotic> Parsec.ParsecLanguage.quotedString or something like that
05:04:04 <Vq^> i think there is some stringLiteral parser in parsec
05:04:15 <psykotic> i just checked the ghc docs and i can't find it
05:05:00 <Vq^> it's there
05:05:03 <psykotic> hmm
05:05:10 <Vq^> it's even called stringLiteral :)
05:05:20 <psykotic> @hoogle stringLiteral
05:05:24 <lambdabot> Text.ParserCombinators.Parsec.Token.stringLiteral :: TokenParser st -> CharParser st String
05:05:35 <Botje> map read $ split ',' "\"foo\", \"bar\"" :: [String]
05:05:38 <psykotic> ohah, Token
05:05:47 <Botje> with split an easy 5-line definition
05:06:58 <Vq^> brackets (many stringLiteral)
05:07:42 <psykotic> ben: so, using parsec it's just sepBy stringLiteral ","
05:08:18 <Vq^> brackets (stringLiteral `sepBy` symbol ",") -- might be more correct
05:08:27 <Ben`> does Parsec come with GHC?
05:08:30 <psykotic> i didn't see any brackets in his example
05:08:31 <psykotic> ben: yes
05:09:35 <Vq^> ah, squares parses [...] contructs, my bad
05:09:50 <DRMacIver> General purpose question. I have a datatype Foo and a function bar :: Foo -> Map Char Foo. Starting from some Foo I want to build up a finite state machine where bar creates the transitions (I can prove that the repeated application will only generate a finite number of steps, up to equality, but there are expected to be plenty of loops).
05:10:29 <DRMacIver> I'm not really sure what the best way of representing and implementing this is. I can hack out some nastiness with accumulators, etc (or even using the state monad), but it will be very unidiomatic and basically look like an imperative algorithm translated into Haskell. :)
05:11:11 <psykotic> DRMacIver, i'm not sure what you have in mind, re: accumulators, but you can use the usual circular "tying the knot" trick
05:11:30 <DRMacIver> I don't really understand tying the knot. :) But doesn't that run into problems with maps being too strict?
05:11:46 <DRMacIver> (If you have a good reference for tying the knot I'm happy to read up on it if it's the right way of doing this sort of thing)
05:12:01 * Botje wants a degree in knot-tying
05:12:29 <psykotic> you can tie the knot as long as the part of your data type used by your Ord implementation doesn't intersect with the pointers you're tying
05:12:57 <DRMacIver> I'm not sure what you mean.
05:13:08 <psykotic> well, it needs to be able to put values into the map
05:13:16 <psykotic> which means it needs to force the "components" of the value which the Ord instance references
05:13:40 <psykotic> but one of the component will probably be the "outgoing" pointers, and those will remain unforced as long as possible. so they can't be referenced by the Ord instance, but they wouldn't be, i imagine.
05:13:58 <DRMacIver> The ord instance for the maps are just characters.
05:14:09 <psykotic> well, you also need a map for tying the knot
05:14:13 <DRMacIver> Oh, right.
05:14:20 <psykotic> i thought that's the one you were talking about
05:14:23 <Ben`> how can I find which modules functions belong to?
05:14:24 <DRMacIver> Sorry.
05:14:39 <DRMacIver> I'm not sure what this map you're suggesting would represent.
05:14:53 <psykotic> let me find the old haskell wiki example, it's very close to what you're trying to do, iirc
05:14:57 <DRMacIver> ok
05:15:07 <DRMacIver> I've looked at the link for it, but it seems to be dead. :-/
05:15:13 <psykotic> hmm
05:15:14 <DRMacIver> @oldwiki tying the knot
05:15:14 <lambdabot> http://www.haskell.org/hawiki/tying the knot
05:15:19 <DRMacIver> Hm
05:15:21 <DRMacIver> That doesn't work. :)
05:15:39 <DRMacIver> Indeed the old wiki appears entirely dead
05:15:44 <psykotic> yep
05:16:21 <DRMacIver> Ah. I've found a cached version of a mirror service which has the example. :)
05:16:33 * DRMacIver will save a copy
05:16:38 <psykotic> so what i'm thinking, wrt your particular problem. you first of all need an equality on Foo.
05:16:49 <psykotic> and then you have some Foo' which represents a node of the automaton corresponding to Foo.
05:16:55 <psykotic> the map will be from Foo to Foo'
05:16:57 <psykotic> (i think)
05:17:32 <DRMacIver> Yeah, Foo is an Ord instance.
05:17:42 <DRMacIver> So equality is no problem.
05:17:56 <DRMacIver> (For context, Foo is a datatype representing a regular expression)
05:17:59 <psykotic> this will be circular, because when you're constructing the Foo' for a particular instance of Foo, you'll need to construct a list of outgoing pointesr based on your bar function, which will involve turning Foo into Foo' again, etc.
05:18:23 <DRMacIver> ok
05:19:21 <DRMacIver> I think that makes sense.
05:19:38 <DRMacIver> Here's the cached version if you want it: http://64.233.183.104/search?q=cache:CiP4J3hLzCMJ:www.mirrorservice.org/sites/www.haskell.org/hawiki/TyingTheKnot+hawiki+%22Tying+the+knot%22&hl=en&ct=clnk&cd=4&gl=uk&client=firefox-a
05:19:40 <lambdabot> http://tinyurl.com/3cbswx
05:22:14 <psykotic> ah right, that's exactly what you're looking for
05:22:36 <psykotic> look at the Indirect/DirectDFA thing and instead of using an array just use a map
05:23:11 <DRMacIver> Yeah.
05:23:13 <DRMacIver> Thanks. :)
05:29:39 <wli> Okay, trouble. y + 1 > ((n+y^2)/3)^(1/2) for y > 3
05:32:08 <ClaudiusMaximus> woe, my code is slow - takes 30s to create a 5s audio file of a band-pass filtered sine sweep
05:32:45 <wli> No, it works.
05:32:57 <wli> There's just a bound on y.
05:33:37 <psykotic> ClaudiusMaximus, space leak most likely. have you done any heap profiling?
05:33:48 <psykotic> first check out what % of time is being spent in GC
05:34:21 <ClaudiusMaximus> psykotic: there's no leak (in that memory usage is constant), but it churns through 7GB
05:34:47 <wli> 2*y^2+6*y+3 <= n
05:35:03 <psykotic> ClaudiusMaximus, in that case find out where it's happening and make those places strict.
05:35:22 <Philippa> are you working with lists? That really won't help
05:37:03 <ClaudiusMaximus> i'm using stream processing arrows based on lists
05:37:35 <psykotic> before you start speculating, i'd profile and find out where the time is going
05:37:36 <wli> y <= ((2n+3)^(1/2)-3)/2
05:38:23 <ClaudiusMaximus> 39% of the time is in   mapM_ (putStrLn . show)  applied to l::[Double]
05:39:41 <psykotic> what was the total GC%?
05:40:09 <psykotic> if the time is being eaten by GC churn then find out where stuff is being allocated. i don't have much practice with ghc's heap profiler but someone else here will.
05:40:59 <Philippa> ClaudiusMaximus: er, yeah, show is slow and output also is
05:41:32 <Philippa> also, try using Data.Sequence instead of lists? Or something else that chunks nicely
05:42:22 <psykotic> chunks nicely?
05:42:37 <psykotic> unless you need some of the specific features of Seq, my experience is that it's a lot slower.
05:42:41 <psykotic> (at least 10x)
05:43:18 <ClaudiusMaximus> allocation seems to be mainly in the output (31%) and the filter (22%)
05:43:36 <Philippa> true, there's not so much copying per se happening
05:43:56 <Philippa> you'd definitely get an improvement from working with something that's at least partly array-based though
05:44:22 <psykotic> yep
05:44:23 <Philippa> ClaudiusMaximus: that figures. You can't do much in the output case, slow just sucks. Dumping binary might be nice if you can, but still
05:46:39 <ClaudiusMaximus> i've got a lot of code like:   rec y <- delay 0 -< y + x  which i'm guessing is building thunks that get evaluated a short while later (when output is forced)
05:46:54 <duncanm> Cale: hey
05:47:00 <Cale> hi
05:47:18 <duncanm> Cale: list comprehension is a way to make a new list with some criteria, right?
05:47:21 <duncanm> i know them from python
05:47:22 <Cale> yeah
05:47:28 <Cale> This is just like that
05:47:35 <Cale> in fact, I could have written comprehensions
05:47:45 <duncanm> can you tell me what each function does?
05:47:54 <ari> > toRational ((fromRational (1 % 3)) :: Double)
05:47:59 <lambdabot>  6004799503160661%18014398509481984
05:48:05 <Cale> replicateMD n xs = [v:vs | (v,vs') <- pick xs, vs <- replicateMD (n-1) xs']
05:48:29 <Cale> that is, it picks some v from xs, leaving xs'
05:48:59 <Cale> then vs is chosen from replicateMD (n-1) xs'
05:49:07 <ari> > approxRational ((fromRational (1 % 3)) :: Double) 0.00000001
05:49:08 <Cale> and the list (v:vs) is returned
05:49:09 <lambdabot>  1%3
05:49:14 <Cale> (for each possible way to do that)
05:49:17 * ari feels enlightened
05:49:17 <duncanm> hmmmm
05:49:43 <Cale> *Main> replicateMD 2 [3,2,1]
05:49:43 <Cale> [[3,2],[3,1],[2,3],[2,1],[1,3],[1,2]]
05:50:01 <duncanm> ah
05:50:26 <Cale> So replicateMD n xs is the list of lists of length n constructed from selecting distinct elements of xs
05:50:32 <duncanm> so replicate returns all combinations of digits in 'xs' into lists of length 'n'
05:50:36 <duncanm> right
05:50:43 <Cale> Actually, there's probably a more straightforward way to do that, it's just the way which came to me first.
05:50:55 <duncanm> ahh
05:50:57 <Cale> Compare with:
05:51:02 <Cale> > replicateM 2 [3,2,1]
05:51:04 <lambdabot>  [[3,3],[3,2],[3,1],[2,3],[2,2],[2,1],[1,3],[1,2],[1,1]]
05:51:23 <Cale> (which is a function in Control.Monad)
05:51:37 <Philippa> ClaudiusMaximus: you might find it helps for a while to use an interpreter-based implementation of your arrow - it makes it a lot easier to think about operational behaviour
05:51:56 <Cale> In general, (replicateM n x) runs the action x over and over n times, and collects a list of the results
05:52:09 <Cale> In the list monad, "running" a list means picking one of its elements.
05:52:15 <duncanm> okay
05:52:17 <Cale> (in all possible ways)
05:52:27 <Cale> So, now
05:52:30 <duncanm> it's like map in scheme
05:52:41 <Cale> flatMap, sorta
05:52:57 <duncanm> but it uses <-, it has side effects
05:52:58 <ClaudiusMaximus> Philippa: i'm not sure what you mean by interpreter-based implementation
05:53:07 <Cale> Nope, it's pure :)
05:53:19 <Cale> do notation isn't *just* for side effects
05:53:22 <duncanm> oh
05:53:23 <Philippa> ClaudiusMaximus: map each of the arrow combinators to a constructor in an AST - the AST type'll have to be a GADT
05:53:27 <duncanm> it's for sequencing
05:53:38 <Cale> Right, in this case, sequencing of list operations.
05:53:41 <duncanm> right
05:53:42 <Philippa> then your runArrow func becomes an interpreter for the language represented by that AST
05:54:03 <duncanm> Cale: in my PL class, we did lazy scheme, so i kinda got a flavor of this style of programming
05:54:24 <Cale> Do you remember the x >>= f notation from simonpj's talk? (I can't recall if he actually introduced it, I think so)
05:54:46 <duncanm> yeah
05:54:51 <Cale> So in the list monad,
05:54:53 <duncanm> that's one of the monadic operations
05:55:02 <duncanm> the do syntax is sugar for >>==
05:55:02 <Cale> xs >>= f = concat (map f xs)
05:55:06 <Cale> right
05:55:06 <duncanm> hmm
05:55:09 <duncanm> you know, Cale
05:55:19 <duncanm> you've been very helpful and patient
05:55:24 <duncanm> but i just stayed up all night
05:55:26 <Cale> :)
05:55:32 <duncanm> it's nearly 9am, i think i should go sleep
05:55:35 <Cale> Me too :)
05:55:42 <phobes> Can someone give an example or explain why we would lose significant expressiveness if laziness annotations were explicit?
05:55:47 <Cale> We're in the same time zone :)
05:55:51 <duncanm> i don't think i can handle much more at my current state of mind ;-)
05:56:08 <Cale> duncanm: Come back tomorrow, and I'll be happy to go over it with you
05:56:09 <duncanm> Cale: boston?
05:56:16 <Cale> Brantford, Ontario
05:56:39 <Philippa> phobes: in practice, people would rarely use them and we'd end up with an awful lot of strict code, and lazy code would become horribly verbose
05:56:59 <ClaudiusMaximus> Philippa: hm, i don't understand why that would help (i also don't know what GADTs are)
05:57:26 <duncanm> ah
05:57:31 <duncanm> i'm going to bed
05:57:39 <Cale> g'night
05:57:44 <marcotmarcot> Good morning.
05:57:53 <Cale> Yeah, it's actually morning :)
05:57:57 <phobes> Philippa: Since strict code would seem to run faster, I'm wondering why it wouldn't be a good idea to have alot of strict code
05:58:08 <phobes> with laziness available when needed
05:58:15 <Vq^> @localtime
05:58:19 <lambdabot> Local time for Vq^ is Fri Aug 17 14:34:21 2007
05:58:43 <phobes> I've heard there are "compositionality" issues, where strict code in one place prevents lazy techniques in others, but I can't think of what they are
05:58:45 <marcotmarcot> I'm using Text.XHtml.Strict and wondering, wouldn't it be good if most times are xxx :: HTML a => a -> Html, instead of xxx :: Html -> Html ?
05:58:55 <marcotmarcot> Some functions use this, but most of them don't.
05:58:55 <wli> phobes: Ideally the compiler should infer when laziness is necessary and make all else strict or similar.
05:59:10 <Cale> wli: I'd say the opposite
05:59:28 <wli> Cale: Well, there isn't a difference.
05:59:32 <Cale> Infer when strictness is necessary, and make all else lazy :)
05:59:32 <Cale> hehe
05:59:35 <Philippa> ClaudiusMaximus: when you write an interpreter you've got a clear handle on how it evaluates things, right?
05:59:46 <Cale> wli: It's just that most things really should be lazy.
05:59:54 <phobes> Cale: Why?  Shouldn't the compiler infer strictness when it makes things run faster?
06:00:10 <Cale> phobes: It should infer strictness where appropriate.
06:00:14 <Philippa> phobes: strict code may not terminate where lazy code does
06:00:16 <wli> phobes: It can, but only imperfectly. The halting problem comes up.
06:00:19 <marcotmarcot> Where should I mail for this suggestion to the xhtml package?
06:00:34 <Cale> phobes: It's just that lazy is the right default.
06:01:10 <Philippa> right, strict's an optimisation - see knuth, etc etc
06:01:24 <Cale> The problem with making everything strict and then inferring things to be lazy is that it's really broken with respect to separate compilation.
06:01:28 <phobes> But strictness seems like a hard optimization for the compiler to do well
06:01:31 <wli> I'm not sure how far and wide strictness propagates. Most instances of Num (save oddness like continued fractions) should be strict.
06:01:50 <Cale> phobes: A few programmer annotations here and there aren't really so bad.
06:01:59 <Cale> Especially when you have things like strict folds.
06:02:15 <mattam> Philippa: knuth talks about lazyness and strictness ?
06:02:32 <Philippa> mattam: about premature optimisation
06:02:38 <Vq^> default strict evaluation is prepreoptimization :o)
06:02:40 <ClaudiusMaximus> Philippa: i guess so, but would i also need to understand how the language that i implemented the interpreter in evaluates things?
06:03:04 <Philippa> ClaudiusMaximus: yeah, but you've got seq any time you're really concerned
06:03:07 <wli> Knuth seems to deal with things on the assembly language level in TAOCP so I'm not sure how much things apply to VHLL's.
06:03:24 <mattam> right
06:03:25 <Philippa> and the interpreter code will often make the details more immediately visible - especially if it's written in a monad
06:03:44 <Vq^> ClaudiusMaximus: in the best of worlds you should be able to ignore the evaluationorder
06:03:48 <Philippa> wli: premature specialisation is definitely a root of much evil. Strictness is often a specialisation
06:03:59 <Philippa> Vq^: we're trying to nail operational details here
06:04:34 <Cale> heh, my haskell program for digital dividend generates all solutions in half the time it takes this C program to find the largest one (and it counts down)
06:04:48 <Cale> http://www.charlespetzold.com/etc/enigma/enigma1343.c
06:04:55 <Cale> http://hpaste.org/2334
06:05:01 <wli> Cale: Enigma cracker?
06:05:10 <Cale> I don't think so...
06:05:28 <Cale> If it has anything to do with engima machines, I have no idea :)
06:05:47 <Cale> (the comment at the top of the C program explains the idea)
06:06:32 <xerox> Cale, do you have hxt installed?
06:06:37 <Cale> xerox: I think so
06:06:38 <phobes> Let me ask this:  Is it fair to say that laziness is the primary cause of GHC being slower than other compilers ?
06:06:52 <ClaudiusMaximus> Philippa: i'm not really able to think about this too deeply right now, but maybe i'll come back to it in a couple of weeks
06:06:53 <Cale> phobes: no, I wouldn't say that
06:07:02 <pejo> Philippa, how do you view strictness to get it to be specialization?
06:07:02 <xerox> Cale: try this, ghci -package hxt, :m + Text.XML.HXT.Arrow, :t foldr ((</).hasName) ["a","b","c"]
06:07:08 <phobes> ** in the cases where it is - I realize it does quite well in many cases
06:07:19 <chessguy> it probably has more to do with just the high level of the language
06:07:29 <wli> phobes: Who gives a damn how fast the compiler is so long as it doesn't take days to compile your stuff?
06:07:38 <phobes> sorry, the generated code*
06:07:42 <Cale> phobes: The primary cause of slowness is/was our poor IO -- strings are linked lists of 32-bit-wide characters.
06:08:08 <Cale> Data.ByteString helps a lot there.
06:08:27 <Philippa> pejo: if it alters termination behaviour, the code's only correct in a narrower range of cases
06:08:33 <Cale> xerox: okay...
06:08:43 <phobes> Cale: So one should avoid strings for performance code?
06:08:50 <puusorsa> cale, should that haskell version generate more than one answer?
06:09:19 <Philippa> phobes: laziness certainly affects the evaluation model, but it also offers GHC a lot of nifty optimisation opportunities that other languages can't take
06:09:27 <Cale> puusorsa: no, but it's easily modified to do so
06:09:45 <Cale> puusorsa: just cut out the 'head'
06:09:50 <phobes> Philippa:  Couldn't strict language compilers use laziness as an optimization?
06:10:01 <Philippa> phobes: no
06:10:04 <puusorsa> right
06:10:10 <Cale> puusorsa: (and of course, mapM print . map fromDigits ...)
06:10:17 <Philippa> laziness means that there are fewer properties that need proving to inline something
06:10:30 <Cale> xerox: I *thought* I had it installed, but I suppose not.
06:10:34 <Cale> xerox: I'll install it.
06:10:47 <xerox> Cale: ok cool. It does a somewhat weird things here for me, in ghc 6.6.1.
06:10:49 <Philippa> you can't insert it as an optimisation because that changes the semantics of a piece of code
06:10:56 <pejo> Philippa, well, I can see your point. But you're effectively talking about when the "optimization" is incorrect. Hm.
06:11:03 <Philippa> and if it's not ubiquitous you still end up having to bash out piles of code
06:11:11 <Philippa> I'm talking about when the optimisation isn't easily proven correct
06:11:20 <phobes> Philippa:  It will at worst convert an infinite loop into a terminating one... in a pure strict language that seems acceptable
06:11:33 <wli> gcc is already trying to do things like this.
06:11:33 <phobes> (to me)  :)
06:11:45 <wli> The __attribute__((pure)) annotation.
06:11:51 <Philippa> right. And now you need to decide when to insert laziness: in reality that's everywhere you want to inline something, which becomes /everything/
06:12:27 <Cale> phobes: Okay, so suppose I compile a module M which exports a bunch of things. Does the compiler compile them to be strict or lazy?
06:12:38 <pejo> phobes, needless to say, there are people who disagree with that it's ok to hide looping bugs from the programmer.
06:13:05 <phobes> Philippa:  You only have to make it lazy if you can't prove it terminates.  And in that case you only need lazy guards at recursion points
06:13:31 <Cale> phobes: If the compiler doesn't have the rest of the program yet, how is it supposed to tell if lazy evaluation would be useful or not?
06:13:35 <wli> I think gcc attempts purity inference when doing automatic inlining of static functions, too.
06:13:49 <phobes> Cale:  I can see independent compilation to be an issue... or why you'd maybe need lazy guards at module boundaries
06:14:13 <Philippa> phobes: you're rapidly ending up with a problem that's at least as tricky as strictness analysis, and leads to uglier code
06:14:22 <marcotmarcot> Cale: in this enigma program you use list monads?
06:14:30 <Cale> marcotmarcot: yeah
06:14:32 <pejo> Philippa. dpm
06:14:47 <pejo> Philippa, don't forget the problems with reasoning about the  code too.
06:14:48 <marcotmarcot> Cale: hum, that's nice, I've never really understood it.
06:14:49 <Philippa> people end up using laziness in utterly unexpected places, just because you can do something and didn't have to stop to think that you might not be able to
06:15:03 <Philippa> pejo: no, I was typing about them :-)
06:15:04 <Vq^> Cale: why is the Haskell-code faster there?
06:15:07 <Cale> marcotmarcot: It could perhaps be written more clearly, that was just the first way that came to mind.
06:15:18 <Philippa> optimisation's just an instance of having to reason about it, anyway
06:15:20 <Cale> Vq^: Because it doesn't waste its time checking stupid things.
06:15:33 <Cale> Vq^: The C program tries all integers in the range.
06:15:35 <marcotmarcot> Cale: do you know somewhere that explains list monads clearly?
06:15:46 <Cale> Vq^: Whereas the Haskell program constructs good candidates.
06:15:57 <Cale> marcotmarcot: Did you read Monads as Containers?
06:16:11 <marcotmarcot> Cale: I'm not sure.
06:16:19 <Cale> marcotmarcot: Do you know what list comprehensions are?
06:16:22 <marcotmarcot> I'll take a look.
06:16:24 <marcotmarcot> Yes.
06:16:34 <marcotmarcot> Is list monad similar to list comprehensions?
06:16:39 <pejo> Cale, out of curiousity - did you try that program with the tagging stuff in the compiler?
06:16:40 <Cale> it's the very same thing
06:16:44 <Cale> pejo: no
06:16:59 <wli> I'm still wishing for a fresh ghc dupload.
06:17:05 <phobes> OK last question for you guys that know GHC well ... what performance penalty do you think GHC pays for laziness everywhere in cases where strict evaluation would suffice?
06:17:09 <marcotmarcot> hum..
06:17:16 <Cale> marcotmarcot: v <- xs in a do block in the list monad will pick v from the list xs in all possible ways
06:17:28 <marcotmarcot> hum..
06:17:29 <marcotmarcot> nice.
06:17:48 <Cale> > do v <- [1..5]; w <- [1..5]; return (v,w)
06:17:49 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
06:17:51 <marcotmarcot> The absense of type declarations in haskell code make it much more difficult to read for me.
06:17:56 <marcotmarcot> I got it now.
06:17:57 <marcotmarcot> Thanks.
06:18:00 <puusorsa> very often haskell feels like magic
06:18:20 <Cale> Yeah, you might want to work out what the actual types are -- I usually don't include them in quick hacks :)
06:18:21 <xerox> Yeah, proper magic needs lots of training ;-)
06:18:23 * wli declares types far more often than strictly necessary.
06:18:32 <Syzygy-> > [(v,w)|v <- [1..5], w <- [1..5], v/=w]
06:18:34 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,1),(2,3),(2,4),(2,5),(3,1),(3,2),(3,4),(3,5),(4,...
06:19:04 <Syzygy-> > do v <- [1..5]; w <- [1..5]; guard (v /= w); return (v,w)
06:19:08 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,1),(2,3),(2,4),(2,5),(3,1),(3,2),(3,4),(3,5),(4,...
06:19:13 <wli> Declaring them wherever is necessary to shut up -Wall is useful for me.
06:20:01 <wli> It complains whenever defaulting happens, for instance.
06:20:33 <marcotmarcot> I think this code is too very advanced haskell for me, I'm not familiar with arrows too.
06:20:46 <Cale> marcotmarcot: oh, the arrow usage is trivial...
06:20:55 <Cale> second f (x,y) = (x, f y)
06:21:02 <marcotmarcot> hum..
06:21:03 <marcotmarcot> =D
06:21:05 <wli> second f = \(x, y) -> (x, f y)
06:21:06 <phobes> Cale: thanks for the help
06:21:10 <phobes> Philippa: thanks for the help
06:21:16 <Cale> pick [1,2,3] = [(1,[2,3]), (2,[1,3]), (3,[1,2])]
06:21:43 <Cale> that's all that pick does
06:21:54 <Cale> it picks an element from the list and gives the rest of the list
06:22:08 <marcotmarcot> hum, nice.
06:22:15 <Cale> I suppose I could also have written:
06:22:59 <Cale> pick (x:xs) = (x,xs) : [(p,x:ys) | (p,ys) <- pick xs]
06:23:50 <Cale> replicateMD 2 [3,2,1] = [[3,2],[3,1],[2,3],[2,1],[1,3],[1,2]]
06:24:28 <Cale> replicateMD n xs will produce all lists of length n whose elements consist of distinct elements of xs.
06:24:35 <marcotmarcot> The functions are simple...
06:24:48 <marcotmarcot> It's just that I'm not used with this kind of implementatino.
06:24:52 <Cale> yeah
06:25:11 <Cale> It's a lazy-list-monad implementation of the search :)
06:25:19 <Cale> The list monad is really good at searching.
06:25:35 <wli> Depth-first, anyway.
06:25:49 <Cale> right
06:26:14 <Cale> It lets you think in breadth-first, and get a depth-first implementation.
06:26:17 <marcotmarcot> Why don't you consider numbers with length 9?
06:26:32 <wli> Cale: That usually results in nontermination.
06:26:52 <Cale> marcotmarcot: because any such number would have both a 2 and 5 in it, and so if it was a solution, it would be divisible by both of those, which means that it would end in 0
06:27:12 <Cale> wli: 'usually'?
06:27:26 <Cale> wli: Not if you prune intelligently.
06:28:04 <Cale> Also, I've found it's a handy technique sometimes to collect finished solutions from the start of the list before binding the next step.
06:28:05 <wli> Cale: Infinite search space, depth first go boom.
06:28:09 <Cale> (in a loop)
06:28:29 <Cale> Not if some of the branches put elements into the list at non-infinite depth.
06:28:51 <Cale> You might get an infinite list, but that's no worry.
06:28:54 <wli> That's a lot of ifs.
06:29:19 <marcotmarcot> hum..
06:29:20 <Cale> They can be summarised by "if you don't write a stupid program".
06:29:27 <wli> The reality for most infinite enumeration problems is that breadth-first is an effective requirement.
06:30:01 <Cale> Well, writing breadth-first searches isn't what's tricky.
06:30:19 <marcotmarcot> Is there a haskell extension for something like: data Foo = Num a => Foo a ?
06:30:23 <Cale> It's depth-first searches which usually require turning your code inside out.
06:30:42 <Cale> marcotmarcot: You want to carry the dictionary for Num along with the data?
06:31:01 <Cale> marcotmarcot: Or you just want to ensure that the data constructor isn't applied to anything that's not in Num?
06:31:12 <marcotmarcot> The second choice.
06:31:17 <Cale> Haskell 98 has that
06:31:30 <Cale> data Num a => Foo a = Foo a
06:31:57 <marcotmarcot> I'm using it to make data HtmlTree = HTML a => HtmlTree String a a [HtmlTree]
06:32:03 <marcotmarcot> hum...
06:32:15 <marcotmarcot> But I don't want a to be a parameter of Foo.
06:32:22 <Cale> Oh, then you want the first choice :)
06:32:30 <Cale> It's called an existential type, and yeah
06:32:40 <Cale> -fglasgow exts will give it to you:
06:32:49 <Cale> data HtmlTree = forall a. HTML a => HtmlTree String a a [HtmlTree]
06:32:54 <marcotmarcot> hum...
06:32:59 <marcotmarcot> That's what I thought.
06:33:00 <marcotmarcot> Thanks.
06:33:24 <Cale> Note that you won't be able to do anything with the elements of type a when you pattern match them out of the constructor except to apply the methods of HTML
06:33:51 <Cale> You can't even return them from a function without wrapping them up again in another existential.
06:34:21 <marcotmarcot> Yes, but this will make things much simpler when creating the tree.
06:34:39 <marcotmarcot> I won't have to use toHtml all the time, I'll put toHtml after it.
06:34:49 <Cale> This is because once you apply the HtmlTree constructor, all the type information about which type they were is thrown away.
06:35:06 <Cale> okay :)
06:37:47 <marcotmarcot> But where should I mail to give any suggestion to this library?  It's included in ghc.
06:42:29 <chessguy> note to self: re-loading your code after fixing a bug is helpful
06:43:34 <wli> I seem to have the enumeration code going.
06:44:43 <wli> At least for the 3*x^2-y^2 case. The other cases are unlikely to be as difficult.
07:00:13 <scook0> chessguy: other tips I've picked up: (1) make sure the function you're putting trace calls in is the one being called, and (2) make sure the source files you're editing are the same ones you're compiling and running :/
07:00:32 <chessguy> good life lessons to live by :)
07:05:42 <fasta> Why does readFile throw an exception (eof), but at the same time does not terminate the program? Is this because Parsec handles this already?
07:07:10 <Cale> fasta: readFile doesn't throw an end of file exception
07:07:31 <Cale> fasta: at the end of the file, the string just stops
07:08:31 <fasta> Cale: according to the ghci debugger it does.
07:09:31 <fasta> Cale: also the ghci debugger seems (still) to be rather unhelpfull, as the context of the assertion failed exception is not available.
07:09:38 <Cale> fasta: Which ghci debugger? You're using 6.7?
07:09:50 <fasta> Cale: yes, ghci debugger of yesterday
07:10:05 <fasta> In this state it cannot be included in 6.8, I guess.
07:11:22 <xerox> fasta: ghc builds again in HED?
07:11:24 <xerox> *HEAD
07:11:25 <chessguy> *Moves> let s = loadFEN "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w"
07:11:25 <chessguy> *Moves> length $ genMoves s
07:11:25 <chessguy> 20
07:11:29 <chessguy> woot!
07:12:16 <Igloo> xerox: Doesn't it for you?
07:12:33 <Cale> fasta: Possibly it's catching an eof exception which is supposed to be caught by readFile itself.
07:12:37 <xerox> Igloo: I stopped trying some days ago. I guess I'll give it another shot today.
07:13:02 <fasta> xerox: the documentation doesn't for me, but otherwise, yes
07:13:13 <fasta> Igloo: have you seen my build file already?
07:13:46 <fasta> Igloo: (and why it doesn't build the library docs)
07:14:21 <fasta> Cale: right, that's what I thought. Still, I don't think that should come up in the debugger
07:14:37 <fasta> Cale: only fatal exceptions should come up by default
07:14:39 <Igloo> fasta: I'm not going to look at it now, but we'll need more info to investigate (like exactly what you expect that doesn't happen)
07:14:57 <ClaudiusMaximus> woe, i added some optimization flags and my binary segfaults :(
07:14:58 <fasta> Igloo: at what? The build file?
07:15:08 <Igloo> at the problem
07:15:58 <fasta> Igloo: the problem is that the library documentation (e.g. Control.Monad) is not being build, the file I use to build is at the URL I send you. What information do you need more?
07:16:06 <fasta> sent*
07:16:57 <fasta> When I manually set a break point before the assertion exception, it does work.
07:17:10 <fasta> (as opposed to :trace)
07:17:27 <fasta> (which according to the specification should also include that break point)
07:33:40 <hpaste>  ClaudiusMaximus pasted "GHC bug? adding optimization flags makes it segfault" at http://hpaste.org/2335
07:43:30 <int-e> ClaudiusMaximus: I'd put my finger on gcc. (adding -fvia-C works for me. I had to adjust some of the C compiler options for my processor)
07:48:16 <ClaudiusMaximus> int-e: ok
07:50:20 <int-e> ClaudiusMaximus: oh I should add that I'm still using gcc 3.4.6 as my main compiler, no 4.x
07:50:41 <ClaudiusMaximus> int-e: i have gcc 3.4.4
07:51:12 <int-e> ok, then the evil mangler shouldn't have trouble with gcc's output.
08:03:15 <reltuk> int-e: the evil mangler doesn't like gcc 4.x?
08:04:27 <int-e> reltuk: I don't know what the current status is.
08:05:13 <wli> Okay, next up: 3*x^2+y^2 == n, n `mod` 6 == 1
08:08:29 <reltuk> wli: what are you up to?
08:08:54 <wli> reltuk: Translating the Sieve of Atkin to lazy list form.
08:09:21 <reltuk> ahhh, fun times
08:11:17 <wli> reltuk: The standard presentation is array-based.
08:29:11 <arcatan> hmm, why does haskell wiki need registeration :(
08:29:20 <lament> probably spammers
08:30:13 <lament> arcatan: http://www.vi-improved.org/wiki/index.php/UltraBriefGuide
08:30:31 <lament> compare and contrast.
08:31:39 <arcatan> yeah, I know
08:35:10 <reltuk> anonymous edit + captcha might wokr
08:41:44 <roconnor> @type fromReal
08:41:47 <lambdabot> Not in scope: `fromReal'
08:41:48 <roconnor> @hoogle fromReal
08:41:49 <lambdabot> No matches found
08:44:04 <DRMacIver> Hm. My brain isn't working today. I can't seem to figure out how tying the knot applies to my problem.
08:45:40 <DRMacIver> I think the problem is that I can't figure out how to make it apply where the set of keys is not known in advance.
08:46:11 <int-e> that's all well but what it the problem?
08:47:29 <DRMacIver> I'm basically just playing with some code for turning regular expressions into DFAs. I have a function Regexp -> Map Char Regexp and am trying to use this to build a DFA labelled by regular expressions.
08:49:44 <DRMacIver> Tying the knot was recommended to me as the right way to do this, and it does indeed look appropriate, but the problem is that I don't know what the set of regular expressions I'll actually need is until I've already run through the whole lot.
08:51:17 <Heffalump> why does the set of keys being known in advance matter?
08:51:35 <DRMacIver> Possibly it doesn't and I'm just misunderstanding how the trick is supposed to work. :)
08:51:36 <int-e> because it fixes the shape of the Map, if you try to use Data.Map
08:51:52 <Heffalump> isn't it just a memoisation problem? Stick each element in the Map as you need them, if they're already in it then just reuse the existing element.
08:52:18 <int-e> and map lookups don't work before the shape of the map is known.
08:52:38 <int-e> so while you can write down the knot tying in a rather pretty way the program will just not work. :)
08:52:59 <int-e> a trie might work :)
08:53:05 <DRMacIver> int-e: Right. That's what's got me stuck. :)
08:53:11 <DRMacIver> Hm. I don't see how I'd use a trie here.
08:54:07 <Heffalump> oh, the keys need to be part of the recursive cycle too?
08:54:11 <DRMacIver> Yeah
08:54:34 <Heffalump> does the construction have to be efficient?
08:54:38 <Heffalump> if not, just use a list
08:54:55 <DRMacIver> It would be nice if it were. :)
08:55:00 <DRMacIver> But I'm willing to settle for working.
08:55:40 <DRMacIver> (I'd rather a nice but somewhat ineffiecient construction than an optimised but ugly one. It's not like I'm actually planning to use this code for anything)
08:55:43 <kayess> Heffalump: I published the Visual Haskell thing I talked to you about yesterday. It's pretty long I'm afraid. It's at http://www.kirit.com/Yoda%20speaks%20Visual%20Haskell in case you have time to make sure I've not said anything too stupid
08:55:45 <lambdabot> Title: Yoda speaks Visual Haskell â kirit.com
08:55:52 <mm_freak> func x :: ResultType = â¦   -- which GHC switch do i need to make this work?
08:56:43 <pgavin> mm_freak: what context are you doing that in?
08:57:01 <pgavin> -fglasgow-exts might work
08:57:05 <mm_freak> `context'?  i'm defining a top-level function
08:57:10 <pgavin> um
08:57:25 <pgavin> why not just do func :: a -> ResultType
08:57:55 <mm_freak> because i'm experimenting with implicit configurations, and i need both
08:58:06 <mm_freak> at least the paper i'm reading does
08:58:21 <pgavin> you could do func x = (....) :: ResultType
08:58:40 <mm_freak> that's uglyâ¦  there is a switch, which makes this work
08:58:42 <int-e> DRMacIver: even with a list you need to keep track of the regular expressions seen so far I think. So a function  build_dfa :: Set Regex -> [(Regex,[(Char, Regex)])] -> [(Regex,[(Char,Regex)]] ought to work.
08:59:01 <pgavin> mm_freak: try -fglasgow-exts, that enables pretty much every extension
08:59:10 <mm_freak> doesn't work
09:00:34 <lament> kayess: wow thats a lot of parens :)
09:00:44 <DRMacIver> I'm wonder if I should just use a State monad and translate the blindingly obvious imperative algorithm.
09:00:47 <pgavin> mm_freak: sorry, I don't know then :/
09:00:56 <DRMacIver> It feels like cheating, but I've been meaning to get the hang of the state monad anyway. :)
09:00:57 <int-e> DRMacIver: the thread starting at  http://www.haskell.org/pipermail/haskell-cafe/2006-September/018112.html  has a related problem.
09:00:59 <lambdabot> Title: [Haskell-cafe] Optimization problem, http://tinyurl.com/jhxw3
09:01:30 <kayess> lament: eek! where?
09:02:01 <DRMacIver> int-e: Thanks
09:02:05 <lament> kayess: in your code
09:02:56 <kayess> lament: I bet. I didn't want a lesson precedence to be part of the introduction, so I guess that makes the "the more parens the merrier" or something
09:04:54 <Heffalump> kayess: is this Vista? I've never observed that problem with GHC on Windows (re self-modifying)
09:05:12 <kayess> Lament: I'm using Win2K3 on a Core 2 duo
09:05:50 <kayess> Since I originally wrote the outline I've done a complete re-install and had to do the same thing
09:05:59 <lament> @source foldM
09:05:59 <lambdabot> foldM not available
09:06:47 <eivuokko> Heffalump, do you refer to data excecution prevention?
09:06:50 <kayess> Heffalump: sorry, last comment was for you, not lament
09:07:25 <Heffalump> I don't know what I refer to. I just note that this crash never happens to me.
09:07:38 <Heffalump> I can well imagine that anything trying to enforce a strict code/data separation would be in trouble, though.
09:07:54 <lament> > foldM_(\x y->print(x++" leads to "++ y)>>return y)"fear"["anger","hate","suffering"]
09:07:55 <kayess> On Win2K3 it's the DEP (data execution prevention) that does it
09:07:58 <lambdabot>  <IO ()>
09:08:01 <eivuokko> DEP has been in at least Windows XP;  It just isn't on for user programs in non-server per default afaict.
09:08:08 <int-e> DRMacIver: but you're probably better off with a simpler scheme, say   build_dfa :: Regex -> Map Regex [(Char, Regex)] -> Map Regex [(Char, Regex)], where the first map accumulates the states seen so far, and the result will contain all other states.
09:08:41 <kayess> Heffalump, it may be that your processor doesn't support it in hardware. I didn't notice it on my older P4 machine
09:09:06 <eivuokko> kayess, With the same os and same DEP settings?
09:09:27 <kayess> eivuokko, good question. Can't remember off the top of my head
09:09:29 <int-e> DRMacIver: I'm not sure how much knot-tying that will allow but at least it's feasible to implement that function :)
09:09:37 <DRMacIver> int-e: Mm. That would probably work, yeah. I'll go with that.
09:09:46 <eivuokko> kayess, afaik it's not really dependent on anything like that;  The hw functionality has been in since 386, if I understand correctly.
09:09:51 <monochrom> I have the crazy idea that you can use TH to turn hand-written regexs into hard-coded DFAs. :)
09:10:12 <lament> damn, there's no foldM1
09:10:30 <kayess> eivuokko, I did switch to win2k3 before upgrading computer, but can't remember if I tried Visual Haskell before then or not
09:10:58 <kayess> eivuokko, I do remember that DEP didn't switch on fully on the old hardware, but don't remember if I was running XP or Win2K3
09:11:14 <eivuokko> kayess, Heffalump, Anyway;  DEP has been discussed on ghc mailing lists and it's known problem.  There's nothing much you can do if you need foreign wrappers.
09:11:48 <kayess> OK good, so I'm right to show a workaround then?
09:12:06 <eivuokko> Yes;  It is the only thing to do if you need to use ghc itself.
09:12:08 <int-e> DRMacIver: or maybe the result should just contain all states.  build_dfa :: Regex -> Set Regex -> Map Regex [(Char, Regex)]  might work. With the 'Set' argument it solves the problem of finding the right set of keys to work with and then tying the knot works.
09:12:38 <int-e> DRMacIver: except that there are no knots left to tie then, hmpf :)
09:12:50 <Heffalump> is Set Regex different from the keys of the map?
09:13:27 <int-e> Heffalump: yes, it'd be the set of regexps seen so far.
09:14:29 <int-e> Heffalump: the first build_dfa call would be build_dfa regex Set.empty
09:14:51 <Heffalump> oh, duh
09:15:03 <int-e> so there's really no knot-tying going on anymore despite all good intentions :)
09:19:26 <DRMacIver> int-e: What I'm currently thinking here is to create enlargeMap :: Map Regexp (Map Char Regexp) -> Map Regexp (Map Char Regexp)  (or similar) which runs through the map, looks at each target regexp to see if it has a key in the map and adds in any that don't.
09:19:30 <DRMacIver> int-e: Then iterate this to a fixed point.
09:19:38 <DRMacIver> Does this sound sane?
09:19:59 <DRMacIver> (I probably wouldn't do it in exactly that manner, but that's the idea)
09:21:36 <kayess> lament: I figured that the extra parens wouldn't bother anybody who already programmed and the explanation of $ to replace them wouldn't add enough to make the explanation worthwhile in the introduction.
09:21:37 <DRMacIver> I have a feeling I'm producing *really awful* code here. I may throw it out to the channel when I'm done to see what people think. :)
09:22:12 <int-e> DRMacIver: sane, yes. but not efficient. consider "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", which will take O(n^2) time to construct n states.
09:22:49 <int-e> DRMacIver: but on the other hand it sounds like a good way to produce concise, working code.
09:23:05 <int-e> DRMacIver: use hpaste for pasting stuff ;)
09:23:07 <DRMacIver> Hm. I don't follow why it... oh, right. I see what you mean.
09:23:12 <desp> can someone explain to me what fixIO does?
09:26:03 <int-e> @index fixST
09:26:03 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
09:27:25 <desp> int-e: I'm actually reading its source, in http://darcs.haskell.org/packages/base/System/IO.hs
09:27:42 <desp> and it's a bit confusing
09:27:43 <oerjan> desp: well, say you have data RefStream a = RS (IORef a) (RefStream a)
09:28:18 <oerjan> er, wait
09:28:39 <oerjan> = RS a (IORef (RefStream a))
09:28:47 <int-e> desp: ah cute. the 'readIORef ref' is delayed until its value is requested.
09:29:43 <oerjan> and then you have mdo x <- newIORef y; let y = RS 1 x; return y
09:29:52 <int-e> desp: one boring example that works is   fixIO (return . (' ':)) which produces an infinite string of spaces.
09:30:12 <oerjan> this gives you a cyclic structure with an IORef in the link
09:30:20 <hpaste>  evir pasted "forgotten parenthesis making GHC 6.6 segfault" at http://hpaste.org/2336
09:30:27 <xerox> Any user of Parsec.Expr, Parsec.Language around?
09:30:32 <desp> mm, thanks
09:30:49 <int-e> desp: the 'ans' points to a thunk that will dereference the IORef when it gets forced.
09:31:01 <oerjan> and that is impossible to do without fixIO, i think
09:31:05 <int-e> desp: if it gets forced too early that will result in an error :)
09:31:35 <int-e> (because it will read and execute the 'throw NonTermination')
09:31:52 <wli> Well, I can generate the candidates... now the trick is casting out non-squarefree numbers.
09:31:53 <desp> right
09:32:15 <desp> but...
09:33:07 <oerjan> hm, actually you could mutate it to become that way, so not totally impossible.
09:33:08 <int-e> I don't know what exactly it's good for as most IO operations are strict.
09:33:35 <desp> int-e: can you give a non-infinite example?
09:34:05 <int-e> desp: return (fix f) = fixIO (return . f) -- take any example for fix.
09:34:45 <int-e> (also true with s/fixIO/mfix/)
09:34:46 <astrolabe> There's a trick to testing polynomials for square-freeness.  Such polynomials are relatively prime to their derivatives.  I can't help thinking there could be an equivalent trick for integers, but I don't know it.
09:36:02 <int-e> desp: so a trivial example is fixIO (const (return 42))
09:36:23 <ari> GoAwayStupidAI: I like that nick
09:36:28 <bluestorm> astrolabe: integer derivation doesn't make sense
09:36:47 <GoAwayStupidAI> thanks!
09:36:50 <astrolabe> bluestorm: Probably true.
09:37:02 <xerox> bluestorm <http://cale.yi.org/index.php/Arithmetic_Derivative>
09:37:06 <bluestorm> :]
09:37:55 <bluestorm> xerox: seems more complex than square-freeness
09:38:16 <astrolabe> xerox: interesting
09:38:32 <oerjan> square-freeness is the absolute value of the mobius function, iirc
09:38:46 <xerox> astrolabe: ayup! Nice to see you online again :)
09:38:47 <oerjan> which is pretty impossible to calculate without prime factorization
09:38:55 <desp> int-e: thanks
09:39:07 <astrolabe> Is the equation for the product on that web page correct?
09:39:09 <int-e> desp: another silly example is  fixIO (\x -> unsafeInterleaveIO (putStr x) >> getContents)  ... which is a contrived way to implement cat.
09:39:34 * SamB just figured out what seems like a workable solution to problem 83 on project euler
09:40:15 <Syzygy-> What -is- problem 83?
09:40:24 <Syzygy-> I don't have the mapping from numbers to problems clear.
09:40:40 <int-e> http://projecteuler.net/index.php?section=view&id=83
09:40:41 <lambdabot> Title: Project Euler
09:40:47 <xerox> Should write ?pe 83 :)
09:40:59 <Syzygy-> grmbl
09:41:07 <Syzygy-> That way I need to boot a bloody web browser too.
09:41:32 <SamB> it involves the array from solving problem 81...
09:41:55 <xerox> astrolabe: maybe it's missing a +
09:42:03 <roconnor> @src toRational
09:42:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:42:07 <int-e> oh I had an awful solution for that. hehe.
09:42:09 <roconnor> @type toRational
09:42:11 <lambdabot> forall a. (Real a) => a -> Rational
09:42:23 <SamB> 83
09:42:23 <SamB> 	
09:42:23 <SamB> Find the minimal path sum from the top left to the bottom right by moving left, right, up, and down.
09:42:39 <SamB> hmm. I wonder how the newlines snuck in...
09:42:58 <xerox> astrolabe: can't see the source, maybe it's just a typo, I think there should be a + sign between the first two and the last two factors.
09:42:58 <olsner> is 83 the same problem with more difficult data? I don't see the difference
09:42:58 <int-e> there's a tab character on that line
09:43:13 <int-e> olsner: it allows more directions
09:43:44 <SamB> more data would have been easy, unless it was too much to fit in RAM...
09:43:53 <lament> can you bruteforce it?
09:43:57 <ari> fst . minimumBy (comparing snd) $ zip allPaths (map pathLen allPaths)? ;)
09:44:08 <olsner> oh, 81 was only right and down
09:44:18 <SamB> lament: what do you mean, bruteforce it?
09:44:37 <int-e> so doing it properly really needs an algorithm like Djikstras (but the problem is small enough to cheat)
09:44:41 <ddarius> Which makes things quite a bit simpler as you are always going further.
09:44:53 <int-e> *Dijkstra
09:44:58 <SamB> ddarius: hmm?
09:45:30 <ddarius> SamB: No LRLRLRLRLRLRLRLR...
09:45:32 <lament> isn't this just a* search?
09:45:54 <int-e> lament: the possibilities are endless ;)
09:46:40 <olsner> sounds like something for Dijkstra or A* (although I don't know what would be a good heuristic for A*)
09:46:42 <SamB> well, I kept trying to think of a solution using dynamic programming, but I kept tying my brain in knots...
09:47:05 <lament> yeah, i suppose a* isn't such a good idea
09:47:16 <lament> better to have a heuristic that's too big (very easy) than one that's too small
09:47:21 <lament> is that what dijkstra does?
09:47:33 <bluestorm> dynamic is good for "longer path", not the shorter one
09:47:47 <int-e> dijkstra visits all nodes in the graph exactly once, ordered by distance from the origin
09:48:09 <int-e> it's efficient. A* search risks searching some subtrees more than once.
09:48:22 <olsner> dijkstra is just A* with h _ = 0, afaik
09:48:47 <bluestorm> and that's a good heuristic :]
09:48:51 <int-e> oh. wait, I didn't know A* for graphs.
09:48:56 <int-e> that changes the picture :)
09:49:46 <SamB> bluestorm: I can easily come up with the largest sum, given that this matrix seems to contain only positive numbers
09:49:57 <bluestorm> yes, that's a dynamic problem
09:50:03 <SamB> and is even*even
09:50:11 <bluestorm> hm
09:50:21 <SamB> ... you just add all the numbers together
09:50:28 <bluestorm> :]
09:50:33 <SamB> minimum is a bit trickier ;-)
09:50:56 <bluestorm> i suppose you want to find out by yourself
09:51:30 <SamB> hmm, dijkstra's algorithm seems to be an optimized version of what I was thinking...
09:51:40 <bluestorm> hm
09:52:03 <bluestorm> you shouldn't search about well known algorithms before you have solved the problem
09:52:15 <ohub> I'm trying to build X11 library in NetBSD, but I don't know how to tell ghc to give "-R/usr/pkg/xorg/lib" flag to ld for linking. Without that flag, executable can find libX11.
09:52:26 <bluestorm> i think you would learn more by finding dijkstra's yourself
09:52:46 <SamB> yeah, so I'll close this before understanding what it actually is
09:52:55 <int-e> bluestorm: that's your own choice though
09:53:59 <bluestorm> of course ^^
09:54:22 <bluestorm> and its slower too
09:54:31 <SamB> what is?
09:54:56 <pejo> ohub, you sure you want -R to the linker?
09:55:20 <wli> Well, thus far somewhat unsuccessful. It seems slower than nubBy (((> 1) .) . gcd) [2 ..]
09:55:29 <bluestorm> SamB: finding the algo yourself
09:55:29 <ohub> pejo: yes, or is there any alternatives?
09:56:15 <ohub> pejo: or is it -rpath, hmm
09:56:19 <pejo> ohub, there's a -optl option
09:56:25 <wli> Thus far the part that seems to be killing me is filtering out non-squarefree candidates.
09:56:35 <pejo> ohub, I thought it was only Solaris that had a sane -R, and -rpath was the way to go for most other OS'.
09:57:01 <pejo> ohub, but I'm not updated with NetBSD, so don't trust me on that.
09:57:05 <ohub> pejo: well, at least here ld's man page says that -R<dir> is treated like -rpath
10:00:24 <int-e> wli: DJB uses sieving for that; he has an array for a few thousand numbers and strikes off all multiples of n^2 for all n of the right residue class modulo 60.
10:01:06 <int-e> wli: (his primegen treats the 16 residues that are coprime to 60 separately)
10:04:57 <iguana_> hi. is there some function to sort a list by a custom key function?
10:05:05 <ddarius> :t sortBy
10:05:08 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
10:05:57 <iguana_> ddarius: that's not what I meant, I meant something like sortWithKey (\x -> (-x)) [1,2,3] == [3,2,1]
10:06:17 <kjdf> is read (for example "read list :: [Int]") lazy?
10:06:26 <kjdf> can I read in infinite lists that way?
10:06:52 <oerjan> iguana_: sortBy . comparing
10:06:57 <xerox> > sortBy (\x y -> compare (negate x) (negate y)) [1,2,3]
10:06:58 <lambdabot>  [3,2,1]
10:07:17 <int-e> > read ('[':cycle "1,") :: [Int]
10:07:17 <oerjan> > sortBy . comparing (\x -> -x) $ [1,2,3]
10:07:18 <lambdabot>  Couldn't match expected type `a -> Ordering'
10:07:21 <lambdabot> Terminated
10:07:33 <oerjan> ?
10:07:33 <xerox> > sortBy (comparing negate) [1,2,3]
10:07:34 <ddarius> Hell in that case, sortBy (flip (<))
10:07:34 <lambdabot>  [3,2,1]
10:07:43 <ddarius> or flip compare
10:08:10 <oerjan> ah, my currying was botched
10:08:10 <lament> isn't there a name for (flip (<)) :)
10:08:15 <iguana_> ddarius: yes, in this example case sure :)
10:08:18 <xerox> (>)
10:08:23 <int-e> kjdf: ah. no it's not. read returns an error on unsuccessful read, sadly, which means that it has to read the whole input before it can produce any output.
10:09:02 <int-e> > (read $ take 1000 $ '[':cycle "1,") :: [Int]
10:09:04 <lambdabot>  Exception: Prelude.read: no parse
10:09:15 <iguana_> but (comparing keyfunction) seems to do the trick, thanks
10:09:37 <ddarius> Small functions that you stick together.
10:09:45 <iguana_> yeah, still learning :)
10:13:25 <oerjan> > unfoldr (catToMaybe . reads) "1 2 3 4 5 f" :: [Integer]
10:13:26 <lambdabot>   Not in scope: `catToMaybe'
10:13:31 <oerjan> bah
10:13:38 <oerjan> > unfoldr (listToMaybe . reads) "1 2 3 4 5 f" :: [Integer]
10:13:40 <lambdabot>  [1,2,3,4,5]
10:13:58 <oerjan> that should be lazy
10:14:20 <xerox> That's cute.
10:14:24 <pjd> comparing will compute the key more than once per element, though, won't it?
10:14:56 <ari> > let sortPre f xs = map fst . sortBy (comparing snd) $ zip xs (map f xs) in sortPre length $ words "hello world, how are all you gentlemen doing this fine day?"
10:14:58 <lambdabot>  ["how","are","all","you","this","fine","day?","hello","doing","world,","gent...
10:16:11 <hkBst> does it make any sense to try and convert this bash script http://rafb.net/p/pOftlS75.html to haskell?
10:16:12 <lambdabot> Title: Nopaste - No description
10:17:04 <olsner> trying is likely to make you learn something; whether it'll be shorter or better than the bash script is another issue ;-)
10:17:06 * shapr yawns
10:18:05 <hkBst> olsner: what is your guess about shorter and better?
10:18:09 <oerjan> > take 3 $ read "[1,2,3,4,arglebargle..." :: [Integer]
10:18:11 <lambdabot>  Exception: Prelude.read: no parse
10:18:21 <slarba> ari
10:18:41 <ari> slarba: ?
10:19:02 <ohub> ari & slarba!
10:19:07 <slarba> ari: same town :)
10:19:37 <ari> slarba: I see
10:29:22 <araujo> hi shapr
10:30:49 <gkr> Is there any class for subgroups?
10:31:34 <jedai> hkBst:  I would say shorter.
10:31:49 <jedai> hkBst: better is subjective...
10:34:54 <hpaste>  wli pasted "slow lazy Atkin attempt" at http://hpaste.org/2337
10:35:21 <pjd> >let sortPre = (map fst . sortBy (comparing snd)) `dot` (ap zip . map) in sortPre length $ words "ccc bb a"
10:35:30 <pjd> > let sortPre = (map fst . sortBy (comparing snd)) `dot` (ap zip . map) in sortPre length $ words "ccc bb a"
10:35:32 <lambdabot>  ["a","bb","ccc"]
10:35:49 <pjd> yay for dot
10:35:56 <oerjan> :t dot
10:35:58 <lambdabot> Not in scope: `dot'
10:36:07 <pjd> dot = (.).(.)
10:36:21 <wli> I'm running out of ideas for speeding this up.
10:36:27 <oerjan> @unpl (.).(.)
10:36:28 <lambdabot> (\ i b c f -> i (b c f))
10:36:35 <chessguy> @hoogle b -> Data.Map a b -> Maybe a
10:36:35 <lambdabot> No matches, try a more general search
10:37:09 <chessguy> anybody know if there's a function like this?
10:37:33 <pjd> oerjan: it's like (.), except for the right operand taking two arguments instead of one
10:37:49 <xerox> :O
10:37:55 <hkBst> jedai: alright, I'll give it a try I guess
10:38:01 <xerox> pjd: where is it defined?
10:38:01 <pjd> similarly, (.).(.).(.) makes it take 3, and so on
10:38:18 <pjd> xerox: haskell.org wiki :)
10:38:41 <oerjan> pjd: i thought those were (((.).).) and the like, is that equivalent?
10:38:48 <pjd> http://haskell.org/haskellwiki/Pointfree
10:38:50 <lambdabot> Title: Pointfree - HaskellWiki
10:39:11 <xerox> oerjan: (((.).).) = (.) . (.)
10:39:36 <Heffalump> hello
10:39:44 <jedai> hkBst: Note that this isn't a good example, since it's mainly a "command caller" type of script and it doesn't do anything else, the main plus you'll get in Haskell is that you'll factorize all you run_* functions but that's almost all
10:40:41 <pjd> xerox: not exactly
10:41:43 <xerox> pjd: right, they differ
10:42:13 <jedai> chessguy: lookupIndex
10:42:49 <chessguy> jedai, no
10:42:56 <hkBst> is there a rule that says operators come before functions?
10:43:01 <jedai> chessguy: It's more general since it can use any Monad you want (Maybe or List are good example)
10:43:04 <chessguy> jedai, it should be a -> Map k a
10:43:32 <chessguy> jedai, i'm looking to go the other way
10:43:38 <jedai> chessguy: Ok, sorrry
10:43:46 <oerjan> hkBst: what do you mean?
10:44:09 <hkBst> oerjan: precedence
10:44:12 <olsner> hkBst: function application like (f x) can be seen as an implicit operator that just has a precedence like any other operator
10:44:28 <olsner> don't know what precedence it has though
10:45:17 <iguana_> how come hoogle doesn't find `comparing'?
10:45:24 <jedai> chessguy: It's easy to write with foldWithKey
10:45:25 <oerjan> hkBst: yep, application is higher than all operators
10:45:32 <hkBst> ``let clock = fromIntegral (clean s) / 1000'' is what I'm thinking about. When does it do the division? Or is / an argument to ``fromIntegral (clean s)''?
10:46:25 <iguana_> also, the hoogle links for keywords point to Nothing, while they should point to Just the docs :)
10:46:27 <olsner> to use operators as functions/values, write (/) rather than /
10:46:28 <oerjan> hkBst: the division is last
10:46:35 <chessguy> hmm
10:47:03 <hkBst> oerjan: if it is last, how come it gets executed at all?
10:47:32 <jedai> chessguy: You can't really do it much faster (it's in O(n) anyway)
10:47:43 <chessguy> jedai, oh, i know
10:47:51 <chessguy> i'm not worried about that
10:47:55 <oerjan> hkBst: it is equivalent to let clock = (fromIntegral (clean s)) / 1000
10:49:17 <chessguy> jedai, i'm just wondering if the fact that i'm trying to write this function suggests something wrong with my implementation
10:49:18 <iguana_> should I pester the Hoogle maintainer for this?
10:49:19 <hkBst> oerjan: oh I see.
10:49:30 <hkBst> @source fromIntegral
10:49:30 <lambdabot> fromIntegral not available
10:49:57 <jedai> chessguy: On that, I can't help you ^^ (without your implementation and goal at least)
10:49:58 <hkBst> what does fromIntegral do?
10:50:07 <chessguy> jedai, sure
10:51:03 * monochrom is having joy with delimited continuations. :)
10:51:06 <chessguy> jedai, i suspect that what i actually want is a two-way map
10:52:09 <jedai> chessguy: I don't see how it could be implemented (to be better than two map I mean)
10:52:45 <chessguy> jedai, well, the idea would be to keep the two maps updated
10:53:04 <chessguy> jedai, so if i change one map, it changes the other
10:53:14 <oerjan> @src fromIntegral
10:53:14 <lambdabot> fromIntegral = fromInteger . toInteger
10:53:23 <chessguy> but hide that messiness from the client of the library
10:53:28 <oerjan> :t fromIntegral
10:53:30 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:54:07 <jedai> chessguy: You should roll your own datatype to hide a pair of Map, it shouldn't be too hard (I think for now) :)
10:54:43 <monochrom> I agree with both jedai and chessguy. Maybe also cabalise the new code.
10:54:58 <chessguy> jedai, that's what i was thinking. type BiMap = (Map a b, Map b a) or something
10:55:06 <monochrom> I almost did it to Java once.
10:55:56 <Igloo> Does anyone know if haddock.ghc runs TH splices or just ignores them?
10:56:40 <chessguy> hmm, i could then duplicate all the functions in Data.Map, but prepend all the names with "left_" or "right_" to indicate from which side we're accessing the Map
10:56:47 <chessguy> or is there a better way to handle that
10:57:20 <monochrom> Hey! That gives me a hilarious crazy idea. Write TH splices to randomly generate comments. The computer goes poetic. :)
10:57:56 <Heffalump> Igloo: if you find out I'd like to know the answer too.
10:58:12 <olsner> can TH generate comments? are comments even in the AST?
10:58:38 <Igloo> No, but it can generate datatype etc
10:58:44 <monochrom> chessguy: apart from those insert functions, which, by "insert (x,y)" one means insert (x,y) to the left and (y,x) to the right.
10:58:45 <Heffalump> remember haddock requires type signatures
10:58:54 <Heffalump> unless haddock.ghc can use the type inference?
10:59:18 <oerjan> http://esoteric.voxelperfect.net/wiki/.Gertrude
10:59:22 <lambdabot> Title: .Gertrude - Esolang
10:59:35 <chessguy> monochrom, yeah, but you'd still want a left_insert and a right_insert, because you want one of each type
10:59:37 <Igloo> No idea, but I tend to generate type sigs anyway
10:59:38 <oerjan> (apropos poetic computers)
11:00:22 <chessguy> errr
11:00:24 <monochrom> If I call left_insert (1,"hey"), what will happen?
11:00:24 <chessguy> nevver mind
11:00:30 <monochrom> Indeed! :)
11:00:46 <DRMacIver> The namespace collision between sets and lists is quite annoying.
11:00:56 <Heffalump> you're supposed to import Set qualified
11:00:59 <DRMacIver> Yes, I know.
11:01:02 <chessguy> monochrom, i wonder if the left/right convention is bad though
11:01:13 <DRMacIver> But that's annoying when it means you have to do things like Set.\\
11:01:15 <monochrom> lookups will need left and right.
11:01:20 <chessguy> monochrom, or even if it could be generalized
11:01:45 <Heffalump> DRMacIver: true
11:01:57 <monochrom> If you really generalize, you enter relational database space. We know how to do that, too.
11:02:38 <chessguy> hm, that's probably overkill for this data structure though
11:02:45 <monochrom> Yeah! :)
11:02:56 <chessguy> what do you think of left and right though? too confusing with Either?
11:03:00 <chessguy> @type left
11:03:08 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
11:03:24 <chessguy> @hoogle left
11:03:25 <lambdabot> Control.Arrow.left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
11:03:25 <lambdabot> Prelude.Left :: a -> Either a b
11:03:25 <lambdabot> Control.Arrow.leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
11:03:28 <monochrom> some mathematicians use "domain" and "codomain"
11:03:28 <chessguy> yuck
11:03:34 <DRMacIver> It would be nice if they could be commonised into a type class, but I suppose you run into similar problems like those which make Set not a monad.
11:03:42 <DRMacIver> s/like/to/
11:03:45 <chessguy> monochrom, mmm, yeah, but then which is which?
11:04:02 <monochrom> They mean left = domain, right = codomain.
11:04:56 <chessguy> monochrom, what would they call the domain and codomain collectively then?
11:05:18 <monochrom> Types. Sets. Domains.
11:05:24 <olsner> a "relation" perhaps?
11:06:03 <monochrom> Category theorists use "source" for left, "target" for right. Both are objects.
11:06:24 * wli speeds it up a bit.
11:06:28 <chessguy> monochrom, can you go from target to source as easily as you can from source to target then?
11:06:46 <monochrom> In category, yes.
11:06:54 <chessguy> that might be ok
11:07:20 <chessguy> @seen cale
11:07:21 <lambdabot> cale is in #ghc, #haskell-overflow and #haskell. I last heard cale speak 3h 54m 46s ago.
11:09:47 <monochrom> The only branches of mathematics that seriously bias towards one direction are complexity theory and cryptography, where a hash function is "hard" to invert. For all other mathematics branches, a function/relation and its inverse enjoy equal status.
11:11:52 <olsner> although not all functions have an inverse - for example, what happens in this BiMap if you add both (1,2) and (2,2) to the map?
11:12:45 <gopik> Hi, Is it possible to use a type as a constructor in 2 different types?
11:12:59 <monochrom> You can disallow it. Then BiMap represents a one-one thing.
11:13:02 <chessguy> olsner, hmm. i guess the same thing as if you added (1,2) and (1,3)
11:13:13 <monochrom> You can allow it. Then BiMap represents a relation in general.
11:13:49 <monochrom> You can allow it but delete old pairs, to keep it one-one.
11:14:20 <araujo> gopik, parameterized data types?
11:14:24 <gopik> data const = ...; data interface = const | method; data foo=const | method
11:14:37 <gopik> araujo, simple types
11:14:51 <oerjan> gopik: not that way, no
11:15:09 <gopik> is there some other way?
11:15:11 <oerjan> (also, capitalization is mandatory)
11:15:13 <araujo> @src Either
11:15:13 <lambdabot> Source not found. That's something I cannot allow to happen.
11:15:35 <araujo> gopik, something like Either ?
11:15:57 <wli> Something goes wrong somewhere between 2^12 and 2^13
11:15:59 <gopik> sorry, i missed capitalization. I think i'm not following. Let me give my requirement
11:16:13 <chessguy> olsner, insert :: Ord k => k -> a -> Map k a -> Map k a
11:16:13 <chessguy> O(log n). Insert a new key and value in the map. If the key is already present in the map, the associated value is replaced with the supplied value, i.e. insert is equivalent to insertWith const.
11:16:56 <chessguy> olsner, i would want to follow the same convention with BiMap, where inserting (x,y) from the left is the same thing as inserting (y,x) from the right
11:17:00 <wli> between 2^12+2^10 and 2^12+2^11
11:17:12 <monochrom> If you insert (1,"Hey"), you will have to delete both (_,"Hey") and (1,_).
11:17:33 <chessguy> monochrom, internally, yes
11:17:44 * olsner repeats something like what monochrom said
11:17:50 <monochrom> That is ok with me. :)
11:18:09 <chessguy> monochrom, you shouldn't have to worry about that from outside the library though
11:18:58 <chessguy> monochrom, i wonder if i should actually hack apart the implementation of Data.Map, and build the bidirectionality in there
11:19:00 <monochrom> insertWith is more interesting.
11:19:46 <monochrom> I don't think the internals of Data.Map offers any shortcut.
11:20:08 <shapr> hola araujo!
11:20:09 <gopik> I have a function that called from 2 places each expect a different type where the structure is same. So I thought of encapsulating the structure in one constructor and make it part of 2 types
11:20:17 <gigamonkey_> so if I define a data type data Foo = Bar | Baz how are the instances actually represented.
11:20:17 <gopik> Is that not possible?
11:20:24 <chessguy> monochrom, no, but it would save the overhead of having an extra layer
11:20:52 <monochrom> You will maintain a pair of binary search trees...
11:21:19 <chessguy> monochrom, right, instead of maintaining a par of Maps, each of which maintains a BST
11:21:19 <olsner> gopik: sounds like you need a type class for whatever the two types have in common, and make the function polymorphic
11:22:12 <gkr> Is there any class for semigroups?
11:22:33 <monochrom> I actually think that the compiled code look the same.
11:22:49 <oerjan> gkr: is Monoid close enough?
11:23:14 <shapr> mm code
11:23:16 <gkr> I have no mempty. (Playing with bits + nand)
11:23:35 <oerjan> er, nand is not associative
11:23:42 <gkr> Isn't?
11:23:47 <gkr> God.
11:23:49 <oerjan> i don't think so
11:24:07 <gkr> Fuck it, I'll use not + and then.
11:24:46 <oerjan> you could implement Z2 as a Num, probably
11:24:48 <gopik> olsner, is this the pattern that's used in parsers where context information is needed to create appropriate typed values?
11:24:59 <xerox> ?check \x y z -> let nand x y = not (x && y) in nand (nand x y) z == nand x (nand y z)
11:25:00 <lambdabot>  Falsifiable, after 1 tests: False, False, True
11:25:13 <oerjan> a boolean ring
11:25:21 <gkr> Buu.
11:25:25 <olsner> gopik: not sure what you mean there
11:25:39 <gkr> However, I don't really need it to be a semigroup either.
11:25:57 * shapr throws sugar lambdas at araujo 
11:26:00 <gkr> But... I am disappointed.
11:26:12 <gkr> Shame at nand.
11:27:01 <monochrom> I know one way of doing what gopik asks, but not in the form you are thinking. I can do it with types, no type class. (Not to argue against type classes; it depends.) I'll take some time to paste it.
11:27:19 <shapr> I really enjoy Paul Johnson's blog.
11:27:35 <gkr> Url?
11:27:42 <gopik> olsner: my problem is i need to parse "something" and return a value. That "something" can occur in 2 contexts where each context requires the parser to return a value of different type. I think I get the idea, i shoudln't use different types in these contexts. Thanks!
11:27:46 <shapr> At this moment I'm reading - http://paulspontifications.blogspot.com/2007/08/new-software-technology-blockage-on.html
11:27:48 <lambdabot> Title: Paul's Pontifications: New Software Technology: Blockage On Line, http://tinyurl.com/2m6y3k
11:27:53 <gkr> I like that one "A neighborhood to infinity" or however.
11:28:13 <shapr> Yeah, sigfpe aka dpiponi is a smart guy and a good writer.
11:31:57 <gigamonkey_> shapr: took the dog on a 50 minute unicycle walk today; I'm ever in #Haskell-blah if you need any more details than that ;-)
11:32:02 <shapr> heh, cool!
11:32:31 <gopik`> monochrom: got disconnected. If you already pasted your solution, could you re-paste?
11:32:47 <monochrom> still typing :)
11:32:55 <olsner> gigamonkey_: your dog can unicycle!?
11:34:09 <hpaste>  monochrom pasted "phantom types for same-structure, different-type" at http://hpaste.org/2339
11:34:25 <monochrom> Bad timing :)
11:35:15 <gopik`> monochrom: thanks!
11:35:38 <monochrom> Oh! It's good timing, not bad timing. :)
11:37:21 <monochrom> I hope you see how it can be exploited. I'm short on examples.
11:37:55 <ddarius> There are plenty of good examples of phantom types.
11:38:01 <gigamonkey_> olsner: nope. But one woman walking toward us said, "Good balance!" What I actually said was, "Uh, thanks." What I *should* have said was: "Well, she's got four legs; it'd be pretty hard for her to fall over."
11:38:26 * shapr laguhs
11:38:47 <shapr> Yeah, you get lots of time to think up smart remarks while unicycling, so many people set up straight lines...
11:41:36 <gopik`> monochrom:sorry for being stupid, but i see this as application when arguments are of different types but same structure. Does thia also apply to return types?
11:43:21 <wli> This thing apparently spends all its time doing isqrt
11:44:29 <olsner> @type isqrt
11:44:31 <lambdabot> Not in scope: `isqrt'
11:44:45 <monochrom> The return type story is the opposite of the argument type story.
11:44:50 <olsner> wli: couldn't be - there's no such function! :P
11:45:26 <gopik`> ok
11:45:29 <wli> olsner: I've obviously rolled my own.
11:45:36 <olsner> ;-)
11:45:44 <monochrom> In the argument story, if you accept an argument of type "AB a", then someone passing "AB Roman" will work. But if you accept just "AB Roman", then passing in "AB English" or "AB a" will not work.
11:46:42 <monochrom> Hmm, perhaps the return story is the same story.
11:47:09 <wli> When dealing with extremely large integers, how does one get upper and lower bounds on integer square roots when using floating point square roots as approximations?
11:47:34 <gopik`> so the return type should be AB a, one caller will expect AB Roman and another AB English?
11:47:56 <wli> floor and ceiling are relatively obviously not sufficient.
11:48:21 <monochrom> Yes. That will work.
11:48:53 <wli> floor/ceiling of sqrt (fromIntegral n) will not work.
11:49:22 <olsner> so you have a fast bignum->float conversion, run sqrt on that, and want upper/lower sqrt bounds?
11:49:31 <wli> olsner: Yeah.
11:49:50 <wli> olsner: Well, "fast" is stock.
11:50:01 <hpaste>  monochrom annotated "phantom types for same-structure, different-type" with "(no title)" at http://hpaste.org/2339#a1
11:50:59 <wli> olsner: It seems faster to use such as starting bounds for Newton than just (1, n).
11:51:23 <monochrom> In that paste, changeR serves as a caller to change. changeR passes in AB Roman, this is accepted by AB a. changeR wants change to return AB Roman, this is also fine with change returning AB b.
11:51:33 <olsner> perhaps if you factored in the precision - sqrt(float+/-maxError) = ...
11:51:53 <wli> olsner: I've no idea how to do that.
11:52:37 <samreid> wli: you could probably use \rt -> rt +/- scaleFloat (1-floatDigits) rt  to turn the floating square root into an interval...
11:52:38 <wli> olsner: Most of the error has to do with (a) conversion and (b) scale.
11:52:55 <wli> samreid: I'm unclear on this concept.
11:53:01 <samreid> wli: er, s/floatDigits/floatDigits rt/
11:53:13 <wli> The scaleFloat/floatDigits concept, that is.
11:53:24 <samreid> > floatDigits (3.0 :: Double)
11:53:25 <lambdabot>  53
11:53:28 <samreid> > floatDigits (3.0 :: Float)
11:53:29 <lambdabot>  24
11:53:46 <samreid> > scaleFloat 5 32.0
11:53:48 <lambdabot>  1024.0
11:53:53 <conal> igloo: what's the distinction between 5.1 and 5.2 on http://www.haskell.org/haskellwiki/Hac_2007_II#Projects_to_work_on ?
11:53:55 <lambdabot> Title: Hac 2007 II - HaskellWiki, http://tinyurl.com/2vefo4
11:53:55 <gopik`> monochrom: Isn't this same as Either?
11:54:13 <olsner> the scale-error would be something like log number - <float-precision> I guess... in theory not that hard, but getting it correct is another issue ;-)
11:54:19 <samreid> wli: that's a really lame way to get a number close to the precision limit..
11:54:24 <wli> samreid: Well, the isqrt I'm using for the moment is at http://hpaste.org/2337
11:54:36 <Igloo> conal: I think 5.1 is just more general stuff
11:54:40 <oerjan> wli: if you have one approximate integer, can't you get a bound on the other side with n^2/x ?
11:55:00 <augustss> samreid: what's lame about it?
11:55:06 <oerjan> er, n/x
11:55:08 <monochrom> I suppose AB has something in common with Either.
11:55:18 <monochrom> In the same sense that Bool does too.
11:55:42 <samreid> augustss: hmmm
11:55:43 <wli> oerjan: I'm not really sure where the approximate floating point integer ends up.
11:56:10 <conal> igloo: okay.  like categories of projects.
11:56:14 <oerjan> wli: it doesn't matter if it is slightly wrong, n/x should still give you an opposite bound
11:56:38 <oerjan> *n `div` x
11:56:44 <augustss> samreid: with a good compiler it would be very efficient
11:58:00 <oerjan> well, you might want to do a couple checks to be sure
11:58:18 <wli> oerjan: I was vaguely hoping to avoid arithmetic on the arbitrary-precision integers and have the initial interval come out already-converged for sufficiently small integers.
12:00:11 <oerjan> if they are sufficiently small for floating point to give the exact result, then they are so small you shouldn't be afraid of arithmetic on them, i think
12:03:55 * araujo `catch` shaprSugarLambdas
12:04:05 <hpaste>  wli annotated "slow lazy Atkin attempt" with "still too slow lazy Atkin" at http://hpaste.org/2337#a1
12:04:23 <wli> oerjan: I just hpasted what I'm currently working with.
12:08:52 <hpaste>  samreid annotated "slow lazy Atkin attempt" with "(no title)" at http://hpaste.org/2337#a2
12:08:54 <newsham> why is there no repeatM (sequence.repeat) or repeatM_ (sequence_.repeat) ?
12:09:27 <newsham> seems like that would come up often
12:09:44 <shapr> araujo: yay!
12:10:17 <oerjan> isn't repeatM_ what's usually called forever?
12:10:24 <olsner> @src forever
12:10:25 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:10:26 <chessguy> @src repeatM_
12:10:26 <lambdabot> Source not found. Do you think like you type?
12:10:34 <chessguy> @hoogle repeatM_
12:10:34 <lambdabot> No matches found
12:10:43 <oerjan> (not that it exists either)
12:10:58 <newsham> yah, I sometimes call it foreverM_
12:11:08 <samreid> wli: check hpaste (if you haven't already)
12:11:40 <oerjan> @src sequence
12:11:40 <lambdabot> sequence ms = foldr k (return []) ms
12:11:40 <lambdabot>     where
12:11:40 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
12:11:53 <wli> samreid: Thanks.
12:12:03 <Saizan> ?type forever
12:12:04 <lambdabot> Not in scope: `forever'
12:13:21 <wli> samreid: That sped it up quite a bit.
12:15:14 <oerjan> > flip runState 0 $ sequence.repeat $ State $ \s -> (s,s+1)
12:15:16 <lambdabot>  ([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
12:20:19 <hpaste>  rubyruy pasted "a newbish bit of code" at http://hpaste.org/2340
12:20:30 <rubyruy> ^ could anyone give me a hand with the above ?
12:21:03 <rubyruy> it is my first program ... there are things wrong with it
12:21:21 <newsham> rubyruy: userdata <- readFile "data"     will do the open and the getContents
12:21:38 <rubyruy> newsham: i know but it will also keep the file open
12:21:45 <sorear> rubyruy: so will getContents
12:21:54 <wli> It's still rather pathetic. :(
12:22:07 <newsham> hrmm.. you want to read and write the same file.
12:22:07 <rubyruy> actually it still fails saying that the handle is NOT open
12:22:15 <sorear> oh wait, spoke a little too soon
12:22:23 <rubyruy> i want it to be open!
12:22:27 <rubyruy> it's not open :(
12:22:38 <rubyruy> "*** Exception: data: hPutStr: illegal operation (handle is closed)"
12:22:47 <rubyruy> i don't get why though
12:22:51 <sorear> rubyruy: using hClose after hGetContents is virtually always a bug...
12:22:54 <newsham> hGetContents closes when you reach eof?
12:23:04 <rubyruy> ah
12:23:07 <rubyruy> that's interesting
12:23:09 <newsham> sorear: he's writing after he does hGetContents
12:23:10 <rubyruy> and also not documented
12:23:41 <rubyruy> some lesson about the benefits of languages without non-explicit side effects comes to might *cough cough*
12:24:05 <rubyruy> ( i kid of course)
12:24:17 <rubyruy> ok so what is the right way to do this then?
12:24:20 <newsham> can you use hGetLine or something?
12:24:24 <oerjan> rubyruy: you cannot use hGetContents in combination with other file operations
12:24:34 <sorear> rubyruy: http://haskell.org/onlinereport/io.html#sect21.2.2 <- documentation of the fact that hGetContents autocloses
12:24:35 <lambdabot> Title: The Haskell 98 Library Report: Input/Output
12:24:35 <wli> I have to wonder if there is something getting reevaluated that shouldn't be.
12:25:07 <rubyruy> sorear: but not in the API docs :/
12:25:14 <newsham> Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl, which is put into an intermediate state, semi-closed. In this state, hdl is effectively closed, but items are read from hdl on demand and accumulated in a special list returned by hGetContents hdl.
12:25:29 <newsham> looks like documentation to me
12:25:34 <rubyruy> "The getContents operation returns all user input as a single string, which is read lazily as it is needed (same as hGetContents stdin)."
12:25:55 <sorear> API docs have the fatal flaw that they assume all interesting behaviour is associated with exactly one symbol.
12:26:38 <rubyruy> er wrong paste
12:26:43 <newsham> how about readLn?
12:27:24 <shapr> newsham: Got any other interesting Haskell source code requests? I have an extensive collection of odd stuff.
12:27:27 <newsham> hmm.. no hReadLn
12:27:31 <rubyruy> ah and i see the fact that it closes IS documented - sorry bout that
12:27:35 <rubyruy> (in the api docs)
12:27:36 <newsham> shapr: not yet
12:27:38 <shapr> ok
12:27:42 <rubyruy> just hadn't read it closely enough
12:28:14 <rubyruy> so i just have to loop using hGetLine ?
12:29:25 <chessguy> @quote loop
12:29:25 <lambdabot> chessguy says: the loop is only in your brain
12:29:35 <newsham> rubyruy: or you could use hGetChar in a loop
12:30:36 <rubyruy> oh right, loops are the devil
12:30:42 <rubyruy> ok so, err tail recursion?
12:31:02 * rubyruy tries to remember intro to scheme course
12:31:03 <newsham> sz <- hFileSize h;  data <- replicateM sz (hGetChar h)   ?
12:31:26 <wli> It seems that shoving things into list comprehensions en masse speeds things up a little.
12:31:52 * MyCatVerbs can has monadic eeenlightenmeent?
12:32:04 <chessguy> @type do { sz <- hFileSize ?h;  data <- replicateM sz (hGetChar ?h) }
12:32:06 <rubyruy> is that most haskelly way of doing it or are you just going easy on me?
12:32:06 <lambdabot> parse error on input `data'
12:32:07 <newsham> (replicateM 20 (hGetChar h)    reads 20 chars from h)
12:32:19 <Saizan> wli: they are converted to foldr/build so easier to fuse, afaiu
12:32:23 <chessguy> @type do { sz <- hFileSize ?h;  d <- replicateM sz (hGetChar ?h) }
12:32:24 <lambdabot> The last statement in a 'do' construct must be an expression
12:32:29 <DRMacIver> Hm. I still have a hard time diagnosing type errors.
12:32:37 <newsham> drm: me too :(
12:32:52 <chessguy> @type do { sz <- hFileSize ?h;  d <- replicateM sz (hGetChar ?h); print d}
12:32:54 <lambdabot> Not in scope: `hFileSize'
12:32:54 <lambdabot>  
12:32:54 <lambdabot> <interactive>:1:46: Not in scope: `hGetChar'
12:33:05 * chessguy sighs
12:33:14 <chessguy> @hoogle hFileSize
12:33:14 <lambdabot> IO.hFileSize :: Handle -> IO Integer
12:33:29 <rubyruy> is there a way i could do this by waiting for isEOFError instead?
12:33:29 <chessguy> @type do { sz <- IO.hFileSize ?h;  d <- replicateM sz (IO.hGetChar ?h); print d}
12:33:31 <lambdabot>     Couldn't match expected type `Int' against inferred type `Integer'
12:33:31 <lambdabot>     In the first argument of `replicateM', namely `sz'
12:33:33 <wli> But not enough to matter.
12:33:53 <newsham> ruby: probably ;-)
12:33:58 <chessguy> @type do { sz <- fromIntegral (IO.hFileSize ?h);  d <- replicateM sz (IO.hGetChar ?h); print d}
12:34:00 <lambdabot>     No instances for (Integral (IO Integer), Num (IO Int))
12:34:00 <lambdabot>       arising from use of `fromIntegral' at <interactive>:1:11-40
12:34:12 <chessguy> ok, i give up
12:34:36 <oerjan>  @type do { sz <- IO.hFileSize ?h;  d <- replicateM (fromIntegral sz) (IO.hGetChar ?h); print d}
12:34:46 <oerjan> @type do { sz <- IO.hFileSize ?h;  d <- replicateM (fromIntegral sz) (IO.hGetChar ?h); print d}
12:34:49 <lambdabot> (?h::GHC.IOBase.Handle) => IO ()
12:35:48 <MyCatVerbs> :t (IO.hFileSize ?h) >>= (return . fromIntegral) >>= (\x->replicateM x (IO.hGetChar ?h))
12:35:50 <lambdabot> (?h::GHC.IOBase.Handle) => IO [Char]
12:36:08 <MyCatVerbs> Did I mention I f---ing love this programming language?
12:37:00 <conal> MyCatVerbs: :)
12:37:22 <rubyruy> youch
12:37:53 <conal> :t fmap fromIntegral (IO.hFileSize ?h) >>= (\x->replicateM x (IO.hGetChar ?h))
12:37:56 <lambdabot> (?h::GHC.IOBase.Handle) => IO [Char]
12:38:17 <rubyruy> also what is '?h' ?
12:38:21 <rubyruy> the ? part
12:38:46 <oerjan> rubyruy: dynamically scoped variable, ghc extension
12:39:40 <MyCatVerbs> rubyruy: far as I can tell, it's a quick way of telling lambdabot to piss off about the fact that you're using a variable that you didn't declare yet this morning. ;)
12:39:55 <rubyruy> aighty!
12:40:24 <sorear> Actually, it's an obscure GHC feature called 'implicit parameters'.
12:40:32 <sorear> @go Dynamic scoping with static types
12:40:34 <lambdabot> http://citeseer.ist.psu.edu/lewis00implicit.html
12:40:34 <lambdabot> Title: Implicit Parameters: Dynamic Scoping with Static Types - Lewis, Meijer, Launchbu ...
12:40:51 <sorear> As it happens, this is just about the only use for them. :)
12:40:56 <MyCatVerbs> sorear: that may be what it -is-, but it's certainly not what we're (ab)using it for right now ;)
12:41:21 <rubyruy> oops i guess i also need to reset the seeker
12:41:25 <sorear> MyCatVerbs: Sure, here it's just being used as a way to typecheck open terms.
12:42:07 <rubyruy> it's like all the fun of io in c with the intuitiveness of haskell! yays! :p
12:42:28 <MyCatVerbs> s/intuitive/awesome/
12:42:50 <rubyruy> before understanding, there is confusion
12:42:52 <rubyruy> and sadness
12:42:54 <rubyruy> and hate
12:43:00 <rubyruy> then enlightenment
12:43:08 <rubyruy> but for now, mostly hate and sadness
12:43:23 <MyCatVerbs> rubyruy: personally, this stuff all makes my head hurt.
12:43:37 <rubyruy> you don't say :p
12:43:46 <DRMacIver> Hm. And adding type signatures I've left out suddenly makes things a good deal less confusing.
12:44:12 <rubyruy> DRMacIver: i have also found that forgetting type inference exists is useful when still trying to 'get' things
12:44:17 <MyCatVerbs> rubyruy: except that after a few months of playing with it, one finds one's head hurts substantially less. Plus, you start going, "coo', awesome!" at random language features after a while, if you're anywhere near as much of a loser as I am.
12:46:08 <DRMacIver> rubyruy: I more or less 'get' things. I just have trouble deciphering ghc's error messages. :)
12:46:47 <oerjan> rubyruy: i understand most of the guys doing serious file I/O with Haskell use Bytestrings nowadays
12:47:06 <rubyruy> what is this Bytestring
12:47:13 <MyCatVerbs> DRMacIver: really? Wow, I get exactly the opposite.
12:47:38 <MyCatVerbs> After using GHC for a while, languages like Java drive me up the wall with their f---ing braindead compiler messages.
12:48:31 <oerjan> @docs Data.Bytestring
12:48:32 <lambdabot> Data.Bytestring not available
12:48:46 <axm> coming from java, "parse error at xx" due to incorrect indentation is equally confusing
12:48:52 <Mortoc> so I'm emerging haskell for the first time today, can anyone recommend me a good tutorial (I'm a programmer, but no haskell experience yet)
12:49:02 <oerjan> @docs Data.ByteString
12:49:02 <lambdabot> Data.ByteString not available
12:49:06 <mudge> how do I compare two haskell functions?
12:49:18 <mudge> if I want to do:  function1 == function2
12:49:18 <MyCatVerbs> Mortoc: the famous one is YAHT.
12:49:32 <oerjan> mudge: in principle, you cannot
12:49:40 <rubyruy> i'm having a lot more cognitive resistance from a ruby background - much of haskell goes directly against the ruby philosophy :p
12:49:41 <mudge> yea, that's what I found
12:49:43 <MyCatVerbs> If that frustrates you, I reccommend taking a five minute detour into the HitchHiker's Guide to Haskell. >>
12:49:53 <oerjan> although you might test with argument values
12:50:04 <MyCatVerbs> mudge: you can't ever compare functions.
12:50:32 <mudge> buy I'm reading the book "Programming Haskell" and I'm on the exercises of the second chapter and it says:
12:50:32 <mudge> Why is it not feasible in general for function types to be instances of the Eq class? When is it
12:50:32 <mudge>    feasible? Hint: two functions of the same type are equal if they always return equal results for
12:50:32 <mudge>    equal arguments.
12:50:40 <MyCatVerbs> mudge: equality on functions is equivalent to the halting problem. Ever heard of a dude called Alonzo Church?
12:50:57 <mudge> yea, heard of him
12:51:10 <mudge> was he one of the presidents of the US?
12:51:18 <axm> have a look at aprove, thats what i am looking at at the moment as well
12:51:26 <MyCatVerbs> ...no. He was the dude who invented lambda calculus.
12:51:37 <mudge> oh, thanks
12:51:41 <axm> it automatically proves if a function halts quite oftebn
12:51:43 <rubyruy> it wasn't Edgar Lambda ??
12:51:45 <axm> -b
12:51:50 <MyCatVerbs> "Church-Turing hypothesis", perhaps?
12:52:18 <mudge> So when would it be feasible for functions to be instances of the Eq class?
12:53:00 <lament> um
12:53:04 <ddarius> In a strongly normalizing language.
12:53:11 <lament> in a non-turing-complete language
12:53:31 <kosmikus> as long as all the types are finite
12:53:35 <mudge> you think my text book is asking me a trick question?
12:53:42 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html
12:53:43 <lambdabot> http://tinyurl.com/y58jn8
12:53:48 <lament> mudge: what is it asking?
12:54:00 <lament> oh, i see
12:54:02 <mudge> Why is it not feasible in general for function types to be instances of the Eq class? When is it
12:54:02 <mudge>    feasible? Hint: two functions of the same type are equal if they always return equal results for
12:54:02 <mudge>    equal arguments.
12:54:10 <mudge> that's from the text
12:54:22 <lament> it's feasible when you know the function is guaranteed to halt for any input.
12:54:23 <psykotic> mudge: because to check that two functions are equal in general you need to think they are equal for all possible inputs.
12:54:24 <axm> one trivial condition could be a function without arguments
12:54:35 <psykotic> mudge: now suppose there are _infinitely_ many possible inputs.
12:54:52 <lament> (am i right? anyone knows?)
12:54:58 <mudge> yea, go on
12:55:25 <axm> but that would be only half of it
12:55:28 <ddarius> lament: If there is an infinite number of inputs, that doesn't help you.
12:55:29 <lament> no, i guess i'm wrong :(
12:55:31 <psykotic> lament, i don't think that's true. even in a strongly normalizing calculus you can't do it.
12:55:37 <lament> yeah
12:55:38 <oerjan> lament: that plus finite domain
12:55:44 <evir> lament: Well, in this case you can decide whether they are not equal, but not if they are.
12:55:46 <arcatan> paranormalize the calculus
12:55:51 <psykotic> finite domain is the only requirement.
12:55:56 <lament> oerjan: well, obviously then you can do it
12:55:59 <rubyruy> wouldn't it be sufficient (for a certain subset of applications) to just compare the ASTs of the functions?
12:56:01 <psykotic> if it's non normalizing it might not terminate but that's okay.
12:56:08 <lament> psykotic: eh?
12:56:13 <lament> how's that okay? :)
12:56:16 <ddarius> psykotic: You can't even tell if the two function () -> () are equal or not.
12:56:18 <psykotic> well, i guess it depends on how you look at it :)
12:56:34 <psykotic> yeah, true. i was thinking that there was an essential difference between an equality check over an inf domain and a dumb loop
12:56:36 <lament> without time machines, the halting problem is hard to solve
12:56:40 <psykotic> but right, there isn't extensionally.
12:56:52 <rubyruy> lament: how would a time machine help ?
12:56:55 <mudge> just need a time machine then
12:57:07 <axm> ddarius, if you can say that they both halt, you can
12:57:18 <ddarius> rubyruy: lament was exercising the weakening substructural logic rule.
12:57:20 <lament> rubyruy: run a program. If it halts, send a time machine back to when you started running it.
12:57:37 <evir> lament: That has not solved the halting problem.
12:57:37 <rubyruy> and if it does not halt?
12:57:38 <lament> rubyruy: if the time machine doesn't immediately appear, that means the problem never halted...
12:57:38 <mudge> gosh,  I feel silly,  I can't solve an exercise on the second chapter on an introductory book on Haskell,  and you guys can't either
12:57:49 <psykotic> mudge: we already told you.
12:57:51 <monochrom> Oh haha!
12:57:55 <rubyruy> oh wait... yes that would be enough
12:57:56 <evir> Uh.
12:57:58 <rubyruy> lol
12:58:03 <mudge> what?  that it can't be done?
12:58:09 <mudge> maybe that is the answer?
12:58:14 <lament> mudge: that you need functions that are guaranteed to halt, on a finite domain.
12:58:23 <ddarius> mudge: The very question says that it can't be done in general.
12:58:24 <evir> mudge: You can not solve equality for arbitary functions.
12:58:26 <lament> then you can simply bruteforce the equality check.
12:58:28 <monochrom> This scheme assumes that time travel has O(1) cost w.r.t. how far back in time.
12:58:29 <evir> mudge: That's proven.
12:58:45 <lament> monochrom: let's assume that until it gets disproven :)
12:59:07 <mudge> okay, thanks,  guys
12:59:11 <mudge> sorry for being a butt
12:59:11 <ddarius> It also assumes that the universe will go on infinitely long.
12:59:37 <lament> ddarius: this time machine is a mathematical abstraction, of course, just like the notion of turing-completeness is a mathematical abstraction
12:59:55 <lament> ddarius: otherwise, in a bounded universe, turing-completeness is of course impossible
13:00:02 <monochrom> trade infinite space for infinite time?
13:00:49 <ddarius> Those time machines are called "oracles" in the literature.
13:01:53 <lament> oracle is a more general term
13:02:35 <monochrom> class Oracle where doesItHalt :: a -> Bool
13:02:53 <ddarius> @hoogle isBottom
13:02:53 <lambdabot> Test.QuickCheck.Batch.isBottom :: a -> Bool
13:02:59 <monochrom> hahaha
13:03:01 <xerox> :O
13:03:11 <lament> ah, there we go :)
13:03:32 <mrd> :t const True
13:03:34 <lambdabot> forall b. b -> Bool
13:03:35 <wli> I think the enumeration method I'm using is just plain hopeless.
13:04:05 <lament> > let x = x in isBottom x
13:04:06 <lambdabot>   Not in scope: `isBottom'
13:04:10 <lament> oh
13:04:31 <lament> clearly something so useful should be in the Prelude :)
13:06:03 <DRMacIver> Hurray. My regexp -> finite state machine compiler works. :)
13:06:05 <gigamonkey_> On page 109 of YAHT what does the "g@" in "search g@(Graph v1 el) src dst" mean?
13:06:15 <wli> I need a way to do this not involving isqrt.
13:06:18 <DRMacIver> (Well, interpreter I guess. The point is that it matches regexps. :) )
13:06:31 <gigamonkey_> I don't remember seeing any explanation of that syntax
13:06:35 <samreid> gigamonkey_: it names the whole thing as g
13:06:39 <thoughtpolice> gigamonkey_: it's an as-pattern
13:06:44 <wli> It's an as-pattern.
13:07:02 <gigamonkey_> the "whole thing" being everything that follows?
13:07:05 <samreid> > let f xs@(x:_) = x:xs in f [1,2,3]
13:07:07 <lambdabot>  [1,1,2,3]
13:07:07 <thoughtpolice> gigamonkey_: yes
13:07:22 <hpaste>  rubyruy annotated "a newbish bit of code" with "and now it works" at http://hpaste.org/2340#a1
13:07:27 <mrd> DRMacIver: do you compile NFAs and convert/simplify to DFAs?
13:07:42 <rubyruy_> http://hpaste.org/2340#a1
13:07:45 <rubyruy_> oh right
13:08:02 <rubyruy_> ok next question
13:08:15 <rubyruy_> is there a more elegant way of doing this? (user : (filter (\u -> (name u) /= (name user)) users))
13:09:13 <gigamonkey_> Hang on so in my example is g@ "(Graph v1 e1)" or "(Graph v1 e1) src dst"?
13:09:37 <rubyruy_> i.e. remove a user from the list with the same name as 'user', and then add 'user' to the list
13:09:37 <rubyruy_> .... see in ruby i'd be using a hash map, keyed by user names, and simply write over the key with the new user
13:09:37 <rubyruy_> but that involves state and that's bad mmkay
13:09:40 <wli> Graph v1 e1
13:09:59 <DRMacIver> mrd: No, straight to DFA.
13:10:16 <DRMacIver> mrd: Using the neat algorithm from "Derivatives of Regular Expressions"
13:10:20 <oerjan> rubyruy_: Data.Map
13:10:41 <pjd> you could approach function equality symbolically
13:11:27 <wli> That's ultimately intensional.
13:11:47 <rubyruy> did my questions get through? my internet dropped
13:11:50 <mrd> interesting
13:12:10 <mrd> union is tricky?
13:12:13 <lament> pjd: so (\x y -> x + y) is a different function from (\x y -> y + x)?
13:12:15 <rubyruy> (re filter function that just replaces a user object with the same name in a list of user obejcts)
13:12:32 * oerjan wonders where the new influx of IRPers is coming from
13:12:40 <oerjan> (wrong channel)
13:12:55 <DRMacIver> mrd: Union is actually *incredibly* straightforward. :)
13:13:13 <DRMacIver> mrd: One second. Doing the tidy up and then going to pastebin the code.
13:13:18 <pjd> lament: depends on whether + is commutative or not (and whether the comparison knows this)
13:13:24 <reltuk> oerjan: it got posted to reddit.com
13:13:25 <Saizan> rubyruy: you can do it with Data.Map if you want, or using Data.List.delete
13:13:26 <glguy> lament: Haskell's (+) isn't guarenteed to be commutative
13:13:28 <reltuk> programming.reddit.com actually
13:14:13 <lament> wow, so it has
13:14:29 <pjd> wli: sorry, can you briefly explain intensional in this context?
13:14:36 <wli> It'd be convenient if one could build up an infinite map.
13:14:42 <rubyruy> haskell is programming.reddit.com's new favorite baby these days
13:14:58 <pjd> rubyruy: only "these days"? :)
13:14:59 <wli> pjd: Extensional equality of functions is just f x == g x for all possible input values of x.
13:15:25 <wli> pjd: Intensional equality is equality of representations, e.g. code pointers, compiled code, AST's, etc.
13:15:34 <rubyruy> there has definitely been an uptake
13:15:43 <reltuk> rubyruy: it seems to be on the radar in more venues than programming.reddit.com, given SPJ's OSCON performances and the likes =)
13:15:44 <rubyruy> reminds me of the ruby underdog haydays :p
13:15:44 <pjd> wli: ok
13:16:14 <reltuk> heh, before rails...
13:16:48 <rubyruy> having said that learning ruby has been mostly a "ooo this is so much easier!" experience
13:16:52 * gravity misses those days
13:17:09 <rubyruy> haskell has been more of a "WHAT THE @*(&@%&ING @(*@% DOES THIS EVEN MEAN OH GOD"
13:17:09 <reltuk> gravity: me too =)
13:17:28 <lament> haskell needs Rails :)
13:17:35 <rubyruy> No. No it does not.
13:17:36 <SamB> eh?
13:17:41 <SamB> I was going to say.
13:17:45 <wli> Building an infinite analogue of Data.Map is basically sorting an infinite list again.
13:17:48 <lament> hehe
13:17:53 <rubyruy> for one Rails in haskell would be ugly as sin
13:17:56 <wli> What is this Rails stuff, anyway?
13:18:00 <thoughtpolice> haskell on planes?
13:18:05 <SamB> the last thing we need is to attract hordes of idiots...
13:18:11 <gravity> wli: A fairly easy way to make web apps
13:18:18 <olsner> Levitating Haskell
13:18:27 <lament> SamB: um.
13:18:32 <dolio> SamB: Way to be a charmer. :)
13:18:35 <wli> Oh, isn't there hAppS already?
13:18:35 <lament> SamB: you sound like a lisp snob
13:18:41 <SamB> however, I must admit I'd like to be there if it DID happen
13:19:03 <gravity> wli: That's what I was thinking, yeah.
13:19:07 <rubyruy> i could totally see haskell getting traction in the web 2.0 world howver
13:19:16 <gravity> And wash?
13:19:19 <reltuk> rubyruy: accomplishing the same functionality in Haskell hopefully wouldn't be "ugly as sin"...otherwise the language isn't nearly as beautiful as lots of haskell users claim :-p
13:19:19 <rubyruy> but not by being the central framework (at least not yet)
13:19:21 <SamB> there is some kind of sick enjoyment in seeing others suffer...
13:19:21 <wli> rubyruy: wtf is web2.0?
13:19:29 <lament> wli: by "Rails" i don't mean "a web framework", i mean "something that will give people incentive to use haskell"
13:19:44 <SamB> lament: oh
13:19:46 <pjd> #haskell:  we turn up our noses to lisp snobs
13:19:50 <SamB> you just meant "a killer app"
13:19:55 <lament> right
13:19:57 <lament> pjd: :D
13:20:34 <rubyruy> i could however picture some crazy haskell-based solution for scaling up to multiple servers by providing a cool distributed data store or somesuch
13:20:46 <hpaste>  DRMacIver pasted "Regular expressions" at http://hpaste.org/2341
13:20:52 <gravity> I think parsec is probably haskell's killer app anyway
13:20:58 <SamB> eh?
13:21:04 <DRMacIver> mrd: ^^
13:21:19 <SamB> Parsec *does* have cool error messages, but...
13:21:29 <xerox> Parsec can be stacked on arbitrary monads starting today :)
13:21:39 <rubyruy> reltuk: the problem is that Rails is as popular as it is very much because of the way it employs ruby's dynamic features, which are anathema to haskell
13:21:54 <oerjan> xerox: yoohoo!
13:22:06 <xerox> And at the same time, it can be used with ByteStrings, lazy or not, and whatever thing that implements uncons :)
13:22:08 <SamB> xerox: ParsecT?
13:22:13 * shapr boings cheerfully
13:22:14 <xerox> Yessir :-)
13:22:17 <ADEpt> gravity: QuickCheck is a killer app :)
13:22:18 <SamB> hoooray
13:22:34 <lament> yeah, with isBottom it better be :)
13:22:37 <jedai> xerox: Wow !!! ^^
13:22:40 <gravity> ADEpt: I might agree if I understood it better :-)
13:22:41 <wli> Why just one?
13:22:41 <shapr> gravity: I agree that Parsec is the most accessible killer app of Haskell.
13:22:43 <rubyruy> so a haskell equivalent to rails would be pretty much as different from rails as can be, or a very poor fit for haskell
13:22:54 <lament> i agree that parsec kicks a lot of ass
13:23:02 <rubyruy> oh yeah that too - we love our DSLs after all do we not?
13:23:03 <lament> but it doesn't exactly make thousands of programmers switch to haskell :)
13:23:11 * wli is not a fan of recursive descent.
13:23:24 <shapr> rubyruy: HAppS is hoping to become a "Haskell on Heat"
13:23:32 <shapr> Or whatever the Haskelly thing would be.
13:23:37 <SamB> shapr: is that an SPJ reference?
13:23:40 <shapr> I dunno
13:23:42 <shapr> Is it?
13:23:58 <lament> haskell on H
13:24:00 <SamB> it makes me think of what he said infinite loops do
13:24:04 <shapr> I was just thinking HOT for Higher Order Types
13:24:19 <shapr> But I haven't thought of any particularly good names.
13:24:24 <shapr> I do like schvung as a name though.
13:24:29 <SamB> maybe Haskell in Heat ;-P
13:24:31 <rubyruy> hmmm ya know... i actually have a very ugly parser written in ruby right now that could do with refactoring to something nicer....
13:24:36 <rubyruy> wouldn't that be a fun project
13:24:47 <shapr> rubyruy: Have you seen the Ruby interpreter written in Haskell by that japanese guy?
13:24:55 <rubyruy> what would be the easiest way for ruby and haskell to talk to eachother?
13:25:06 <SamB> shapr: aren't all things ruby by "that japanese guy"?
13:25:06 <shapr> Does Ruby have a good FFI?
13:25:09 <rubyruy> sockets maybe ?
13:25:12 <shapr> SamB: Heh, Matz...
13:25:19 <rubyruy> FFI ?
13:25:30 <wli> The M:N threading model.
13:25:42 <SamB> ... what?
13:25:44 <shapr> hiya PaulAJ!
13:25:52 <wli> That's a very impressive and very seldom noted aspect of the RTS implementation.
13:25:55 <PaulAJ> Hi Shapr.
13:25:58 <shapr> How's code?
13:26:19 <DRMacIver> Also, if anyone else feels like criticising the regexp code it would be greatly appreciated. ;)
13:26:27 <PaulAJ> See my new blog (linked from PlanetHaskell)
13:26:27 <shapr> Are you the same PaulAJ as http://paulspontifications.blogspot.com/ ?
13:26:28 <lambdabot> Title: Paul's Pontifications
13:26:49 <shapr> Are you the same Paul J I met at AngloHaskell?
13:26:50 <PaulAJ> Yes
13:26:52 <PaulAJ> Yes
13:26:59 <shapr> Cool, I owe you money :-)
13:27:01 <PaulAJ> sec,
13:27:04 * shapr grins
13:27:15 <shapr> PaulAJ: Your blog is awesome!
13:27:30 <thoughtpolice> wli: that's the same approach the erlang vm takes iirc
13:28:42 <PaulAJ> Back again
13:28:52 <PaulAJ> SO wanted to talk just as I joined the channel.
13:29:11 <shapr> Same for me, I'm just talking to my SO
13:29:13 <ddarius> rubyruy: Seen liftweb?
13:29:17 <PaulAJ> Thanks for the compliment.
13:29:50 <wli> thoughtpolice: I don't know, getting M:N threading working on Linux in any RTS is a feat.
13:30:20 <thoughtpolice> hm i'm fairly certain. should go disect the source :)
13:30:43 <wli> thoughtpolice: I was saying that even if Erlang also does it, it's still impressive.
13:31:28 <thoughtpolice> wli: why's it impressive for linux, though? is it just getting the scheduler/kernel to cooperate basically?
13:31:33 <jedai> DRMacIver: zero <*> _ == zero ? It doesn't seem to match the description of Prod ?
13:31:35 <chessguy> are (.!) and (!.) valid operator names?
13:31:52 <wli> thoughtpolice: The Linux syscall API is uncooperative.
13:32:01 <oerjan> chessguy: yes
13:32:04 <PaulAJ> I'm wondering if I should expand the MonteCarlo monad into a full blown package.
13:32:25 <PaulAJ> Anybody know more about statistics want to comment?
13:32:36 <oerjan> > let a .! b = a+b in 1 .! 1
13:32:37 <lambdabot>  2
13:33:10 <chessguy> > let (!.) = (+) in 1 !. 1
13:33:11 <lambdabot>  2
13:33:15 <chessguy> sweetness
13:33:44 <DRMacIver> jedai: zero is the regular expression which matches nothing at all, not the regular expression which matches the zero length string.
13:34:04 <DRMacIver> jedai: one is the regular expression which matches the empty string.
13:34:40 <ddarius> PaulAJ: Have you proven the monad laws by the way?
13:34:45 <jedai> DRMacIver: Ok, Prod match a succession of Regex ?
13:34:55 <DRMacIver> Yes
13:34:57 <PaulAJ> no.  Good point.
13:35:07 <Heffalump> PaulAJ: ekidd was doing some stuff on probability monads
13:35:16 <jedai> DRMacIver: It isnt really clear in the description, ok, it makes more sense
13:35:25 <PaulAJ> Yes, I saw his stuff at the time.  I don't think its the same thing.
13:36:15 <wli> I need much, much better ways of enumerating lattice points.
13:36:27 <PaulAJ> I do get a feeling that there is some more general concept of probability monad out there.  QuickCheck Gen, Dist, etc all look like they are covering similar ground.
13:36:32 <jedai> DRMacIver: Though it's not the standard Regular Expression, you're adding some extensions to the classical operator set (it shouldn't expand the set of languages matched though)
13:36:56 <mrd> @where shim
13:36:56 <lambdabot> http://shim.haskellco.de/trac/
13:37:18 <DRMacIver> jedai: Sorry. I'll update the description. :)
13:37:35 <PaulAJ> You need discrete distributions, continuous distributions, distributions over non-numeric data, and various monte-carlo techniques.
13:37:53 <PaulAJ> QuickCheck is essentially a monte-carlo technique for verifying specifications.
13:38:00 <DRMacIver> jedai: It's pretty close to the standard regular expressions. The only extra operator I add is 'not', as it's easy to implement here, and regular languages are closed under complementation.
13:38:33 <jedai> DRMacIver: Yeah, that's why I said it won't expand the set of language you can match
13:38:52 <DRMacIver> jedai: Oops. I've totally screwed up the commenting when I refactored some of this code. No wonder you were confused. :)
13:38:53 <dolio> PaulAJ: You said ListT wouldn't work (which isn't surprising), but what about, say, LogicT?
13:39:24 <DRMacIver> jedai: The comments for Sum and Prod are the wrong way around.
13:39:39 <PaulAJ> Haven't looked at it in detail, but I still think it wouldn't work.  The key step was putting the "pickOne" operation in the bind function.  Nothing else let you do that.
13:40:33 <jedai> DRMacIver: Ok, I somehow inferred the correct definition for Sum (thanks to the Set in the definition), but I was quite confused, it makes sense now :-)
13:40:46 <PaulAJ> You would need some kind of backtracking to allow for computations that often fail only in specific areas, which is what the exericse of a "try" combinator was about.
13:41:42 <DRMacIver> jedai: I've annotated it with correct comments. :)
13:43:06 <jedai> DRMacIver: Ok, thanks, it seems like fun code anyway ^^ (the end was cut by hpaste)
13:43:21 <DRMacIver> Oh, was it? Bugger.
13:43:29 <olsner> gotta build a DynamicProgramming monad (or other thingy) for projecteuler
13:43:39 <DRMacIver> One minute. :)
13:44:25 <shapr> PaulAJ: And SmallCheck replaces the Gen with an Enum that starts at minBound
13:44:30 <PaulAJ> olsner: what is projecteuler?
13:44:42 <chessguy> olsner, make sure you write instance Monad Thingy
13:44:43 <shapr> So I agree that a general purpose package would be useful.
13:44:56 <olsner> haskell's purity really seems to be an obstacle more than anything for building a recursion+caching approach (which otherwise would be a really short-and-sweet way to do it)
13:45:21 <dolio> olsner: Write some memoizing fixpoint combinators.
13:45:31 <shapr> olsner: Why can't you memoize?
13:45:35 <shapr> Yeah
13:45:45 <hpaste>  DRMacIver annotated "Regular expressions" with "The missing bit" at http://hpaste.org/2341#a2
13:45:47 <PaulAJ> Couldn't you pass the cache state as an argument to the recursion?
13:45:50 <shapr> mrd: Can you see the shim website?
13:45:57 <DRMacIver> jedai: See above.
13:46:01 <PaulAJ> I must admit I haven't thought about it.
13:46:08 <monochrom> Couldn't you just ty the knot?
13:46:23 <shapr> olsner: Have you seen the lazy memoizing regular expressions in Chilli's ctk-light?
13:46:46 <DRMacIver> jedai: I can't claim any originality to this. I just thought it would be a nice exercise for me to get my Haskell skills up to non-sucky levels. :)
13:46:52 <PaulAJ> Got to go.  Bye.
13:46:52 <mrd> shapr: no it seems to be dead
13:46:56 <shapr> PaulAJ: aww
13:46:58 <mrd> i think its been dead for a while
13:46:59 <olsner> tying the knot, memoizing, fixpoint combinator... I'd sure like to be able to whip something like that up in a jiffy
13:47:02 <DRMacIver> (I'll be adding parsing code and an attempt to compile the FSMs to C at some point)
13:47:06 <shapr> I wanted to ask what to do about software problems..
13:47:18 <mrd> i think i have an old darcs repo of it somewhere
13:47:26 <shapr> If software companies aren't liable, how do we encourage correctness?
13:47:35 <shapr> mrd: I think I do too, not sure if I have the most recent though.
13:47:35 <jedai> DRMacIver: Yeah I know the theory too, but Haskell makes it quite concise and pretty
13:47:57 <DRMacIver> Yeah. Although I wasn't terribly happy with the compile code.
13:48:24 <olsner> @where chillli
13:48:24 <lambdabot> I know nothing about chillli.
13:48:25 <olsner> @where chilli
13:48:26 <lambdabot> I know nothing about chilli.
13:48:27 <DRMacIver> The tying the knot bit is nice enough, but having to work out all the derivatives in advance annoyed me.
13:48:33 <newsham> hrmm.. I'm doing an   hPutStr h msg >> hClose h
13:48:34 <shapr> olsner: ChilliX == Manuel Chakravarty
13:48:41 <newsham> and most but not all of msg is making it to the output
13:48:44 <newsham> bug?
13:48:48 <shapr> olsner: http://www.cse.unsw.edu.au/~chak/haskell/ctk/
13:48:49 <lambdabot> Title: A Compiler Toolkit in Haskell
13:48:50 <mrd> shapr: i have a March 25th copy
13:49:01 <mrd> do you ahve a more recent one I can pull from?
13:49:09 <chessguy> monochrom, there is one slight downside to Bimap
13:49:14 <shapr> mrd: Looks like mine is 2007-05-12
13:49:17 <shapr> Yeah, I'll put it up.
13:50:00 <shapr> mrd: http://www.scannedinavian.com/~shae/shim.tar.bz2
13:50:04 <monochrom> olsner: http://www.haskell.org/haskellwiki/Dynamic_programming_example   Haskell purity + laziness is actually the perfect fit to dynamic programming.  Can't say the same about impure or eager languages.
13:50:05 <lambdabot> Title: Dynamic programming example - HaskellWiki
13:51:27 <dolio> > let memo r f = (a!) where { a = listArray r $ map f (range r) } ; fact f 0 = 1 ; fact f n = n * f (n - 1) in fix (memo (0,20) . fact) 19
13:51:28 <lambdabot>  121645100408832000
13:51:58 <newsham> ahh, heh, my fault. heh
13:52:09 * shapr hugs newsham 
13:52:16 <monochrom> Some time later I should add the general memo utility to that page.
13:52:30 <mrd> shapr: last "change" is from January
13:52:34 <shapr> ah
13:52:44 <DRMacIver> Is general memo the army's chief bureaucrat?
13:52:49 * rubyruy is currently reading the parsec docs
13:52:53 <monochrom> hahaha
13:52:54 * rubyruy and having his mind blown
13:53:16 <monochrom> He's the army's chief space-leaker. :)
13:53:32 <shapr> olsner: What about "memoize f range = ((array (minimum range, maximum range) (map (\x -> (x,f x)) range)) !)" or "memoize' f range = ((map f range) !!)"
13:53:42 <rubyruy> killer-app indeed, this could actually solve one of my fairly immediate and relevant problems!
13:53:45 <shapr> olsner: It's not very general, but it'd work.
13:54:20 <shapr> @users #haskell
13:54:20 <lambdabot> Maximum users seen in #haskell: 395, currently: 390 (98.7%), active: 19 (4.9%)
13:54:24 <shapr> whoa, 395??
13:54:37 <shapr> Dang, we're about to beat 400!
13:54:46 <shapr> Only four more peoples!
13:55:07 <olsner> so the general idea is to have an array with all function values lazily cached, then have the function index the array rather than recurse?
13:55:07 <shapr> Er, nine more from now, but five more from the current max.
13:55:28 <monochrom> Yes olsner
13:55:34 <shapr> olsner: For that code, yeah
13:55:43 <shapr> But there are more general approaches, like I said.
13:56:05 <olsner> how would you do something similar with a Map and an unbounded argument range?
13:56:13 <shapr> mrd: Do you have a more recent copy of shim than I do?
13:56:13 <monochrom> does "more general" means s/array/some other collection/ ?
13:56:43 <desp> hm
13:56:44 <sjanssen> olsner: at that point, you'd probably use mutability somehow
13:56:49 <olsner> say, to optimize this problem: http://www.projecteuler.net/index.php?section=problems&id=14
13:56:51 <lambdabot> Title: Project Euler
13:56:56 <shapr> Nah, more general would mean you wouldn't require an array, and wouldn't require indexing.
13:57:09 * shapr hugs conal
13:57:16 <sjanssen> like "State (Map Key Result)", or an unsafePerformIO hack
13:57:32 <olsner> (which you can brute-force in under a minute, but still probably would benefit from caching)
13:57:40 <hpaste>  desp pasted "simplify?" at http://hpaste.org/2342
13:57:42 <dolio> You can memoize over infinite domains with infinite, lazy tries, or something like that.
13:57:48 <desp> any ideas how to simplify this?
13:57:58 <dolio> Lists of exponentially expanding arrays is also an option.
13:58:03 <sjanssen> olsner: actually, there's a cool trick with an infinite list of arrays
13:58:07 <sjanssen> blast, dolio beat me :)
13:58:12 <mrd> shapr: possibly
13:58:20 <shapr> mrd: Is yours online to pull from?
13:58:28 <mrd> http://mapcar.org/haskell/shim/
13:58:29 <lambdabot> Title: Index of /haskell/shim
13:58:36 <Dybber> mrd, thank you for the dynamic programming tutorial on sequence.complete.org ! that kind of usage of laziness was new to me.
13:58:50 <desp> it *seems* to me that there should be a way to do this
13:58:57 <desp> since all ys are of the same type
13:59:22 <desp> some sort of unsafeMapConstructorToTuple?
13:59:41 <shapr> mrd: Yow, 132 new patches.
14:00:26 <dolio> desp: Do you ever need the a?
14:00:35 <mrd> Dybber: cool. there's more concise ways of formulating it too.
14:00:45 <desp> dolio: yes
14:00:59 <desp> it should be "bar a y" probably
14:01:10 <olsner> :t filterM
14:01:19 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:01:28 <dolio> desp: Oh. Well, if you're throwing away the a, you could use records, and name the similar things the same thing.
14:01:29 <mrd> I was attempting to fit a REPL on top of shim but ran into difficulties with GHC API.
14:01:41 <shapr> What happened?
14:01:56 <dolio> desp: So, it'd be 'foo x = bar (y x)'. But if you need to know which constructor it was, I don't know of an automatic way to do it.
14:02:15 <hpaste>  sjanssen annotated "simplify?" with "a bit better, IMO" at http://hpaste.org/2342#a1
14:02:35 <desp> sjanssen: not if bar is long...
14:02:41 <reltuk> why would you want to turn your constructor into a meaningless Int?
14:02:54 <desp> reltuk: this is just sample code
14:03:02 <mrd> shapr: runStmt is difficult to harness.  it pretty much runs in its own thread and does what it wants with the output.
14:03:34 <mrd> I tried to capture it with file descriptor tricks but that is not portable and dubious in concurrent situations.
14:03:50 <desp> sjanssen: hm, so, I'll abstract bar out so it'll be short; thanks. ;)
14:12:13 <kjdf> is there a difference between "repeat x = xs where xs = x : xs" and "repeat x = x : repeat x"?
14:12:16 <hpaste>  desp annotated "simplify?" with "good" at http://hpaste.org/2342#a2
14:12:33 <ddarius> kjdf: Semantically, no.
14:12:39 <desp> this works best for my purposes
14:12:39 <chessguy> man, there are a TON of functions in Data.Map
14:12:58 <ddarius> kjdf: But typically the former creates one single circular cons while the latter creates an infinitude of them.
14:13:05 <desp> (tons of FooN)
14:13:20 <desp> s/->/=/
14:13:48 <ddarius> kjdf: Compare repeat x = trace "repeat" xs where xs = x:xs with repeat x = trace "repeat" (x:repeat x)
14:24:38 * desp <3 typeclasses
14:24:55 <ddarius> Doesn't everyone?
14:26:03 <desp> no! they're mine.
14:28:15 <kjdf> repeat = fix ((:) <*>)
14:28:21 <kjdf> this is some evil magic
14:28:28 <kjdf> also makes circular cons..
14:31:32 <Saizan> uuh, reader applicative?
14:32:02 <ari> I prefer fix . (:)
14:32:20 <ari> > fix . (++) $ "desu "
14:32:22 <lambdabot>  "desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu ...
14:32:46 <sieni> desp: your jealousy doesn't prevent us enjoying them as well <3
14:37:20 <fnord123> @seen Cale
14:37:21 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 7h 24m 46s ago.
14:37:25 <Saizan> uhm, how do you remeber quotes starting with an action?
14:37:41 <fnord123> @seen dcoutts_
14:37:41 <lambdabot> dcoutts_ is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I don't know when dcoutts_ last spoke.
14:37:49 <fnord123> @seen dcoutts__
14:37:49 <lambdabot> dcoutts__ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I don't know when dcoutts__ last spoke.
14:38:11 <xerox> Saizan: * ...
14:39:12 <DRMacIver> :t (<*>)
14:39:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:40:03 <DRMacIver> :t ((:) <*>)
14:40:05 <lambdabot> forall a. (a -> [a]) -> a -> [a]
14:40:14 <DRMacIver> Hmm.
14:45:35 <Saizan> @remember desp * desp <3 typeclasses <ddarius> Doesn't everyone? <desp> no! they're mine.
14:45:35 <lambdabot> Done.
14:49:29 * shapr has a hissy fit
14:49:50 * Binkley gives shapr a cookie
14:50:20 <shapr> Wtf is wrong with this code? It looks like the existing code that works, but NO.
14:50:27 * shapr throws frustration lambdas.
14:50:33 <olsner> quoting multi-line conversations seems awkward
14:50:58 <sfogarty> Hi. I'm trying to profile my code, as it is running a bit slow, and the CAF of one module is dominating the running time (60% or so). Which confuses my easily confused self, as I have no top-level definitions that aren't functions, and am using -auto-all?
14:51:36 * olsner catches shapr's frustration lambdas and applies a fixpoint combinator to them
14:51:46 <Binkley> sfogarty: is it a CAF belonging to a module that you defined, or to a library module?
14:51:47 <shapr> Trying to fix my frustration, eh?
14:52:08 <sfogarty> module I defined. It is the module with the function doing all the work, and that function does take the other 30% or so
14:52:09 <olsner> shapr: rather aiming for a feedback loop
14:52:35 <Binkley> sfogarty: are you compiling with optimization on?
14:52:58 <xerox> sfogarty: this is all the .prof file says?
14:53:21 <sfogarty> ..... -Llpk -llpk ..... -fglasgow-exts -prof -auto-all
14:53:32 <sfogarty> pretty much
14:53:33 <xerox> I had similar issue in the ps output from hp2ps, but the .prof file always gave precise info
14:53:45 <sfogarty> only mentiones two cost centres
14:53:53 <sfogarty> up top
14:54:40 <MarcWeber> @tell apfelmus How far did you get? I'll have a look at hugs at the moment.. I seems to be easy to add different libraries using the -P option
14:54:40 <lambdabot> Consider it noted.
14:55:05 <shapr> Why does :t work in public, but not in private, when talking to lambdabot?
14:55:17 <sfogarty> So I have no in specific enabled or disabled optimizations.... ought I?
14:55:39 <Binkley> sfogarty: what optimization flag are you using? -O?
14:55:49 <sfogarty> Er, I don't think any
14:56:04 <Saizan> sfogarty: use -O2 then, and -caf-all
14:56:14 <sfogarty> Will do!
14:56:17 <Binkley> profiling and optimization interact in weird ways, though
14:56:22 <Binkley> you may get even more confusing results :-)
14:56:29 <sfogarty> heh
14:56:33 <sfogarty> should I try -caf-all alone first?
14:56:38 <Binkley> that might be a good idea
14:56:56 <jedai> @src length
14:56:56 <lambdabot> Source not found. stty: unknown mode: doofus
15:01:24 <scodil> i get weird bugs with tabbed too
15:01:29 <scodil> ugh
15:01:40 <scodil> time to switch clients...
15:02:19 <sfogarty> Hmn. it does not like the -caf-all flag. I could only use it on some modules, and not others. Ah. CAF:union
15:02:33 <sfogarty> I would assume then it is my gratuitious use of the union function that is slow :)
15:03:44 <Binkley> yes, if union is your bottleneck, it's probably easy to fix :-)
15:05:37 <sfogarty> particularly as I do not THINK they are actually necessary
15:05:44 <ndm> i have a program where turning on profiling gets me a 30% speed up...
15:05:59 <olsner> wow, that's strange
15:06:05 <SamB> indeed
15:06:19 <Binkley> it could be the principle of random code perturbation :-)
15:06:25 <SamB> I expect it prevents a pessimization
15:06:26 <sfogarty> I wrote a very non-tail-recursive interpreter in OCaml once that, when compiled, would never blow the stack interpreting tail-recursive programs. That's the one that confused me.
15:10:22 <shapr> It WORKS!
15:10:25 * shapr boings happily
15:10:31 <shapr> Well, at least.. it typechecks.
15:10:36 <Binkley> so therefore it works :-)
15:10:43 <sfogarty> oooh, that's a lot faster. Yay for -caf-all!
15:10:49 <sfogarty> Hey, with a sufficiently thorough type system...
15:10:54 <nornagon> Binkley: It's a heisenbug :-)
15:11:34 <sfogarty> hmn. still slow. Probably that nub.
15:11:38 <olsner> what, haskell can produce heisenbugs too!? <-- total loss of faith
15:11:55 <sfogarty> no, doesn't think it is the nub
15:12:02 <shapr> Yeah, but Haskell heisenbug are of a much higher quality.
15:12:08 <sfogarty> we think
15:12:26 <olsner> bugs of higher quality == harder-to-find bugs? :P
15:12:27 <SamB> olsner: only when you lie to the optimizer
15:12:28 <nornagon> i can't remember who it was, but someone said that bugs you get in haskell are much more interesting than bugs in other languages :P
15:12:47 <nornagon> olsner: Remember, it's possible to write FORTRAN in any language. ;)
15:12:50 <Binkley> Haskell, generating high-quality heisenbugs since 1990
15:13:16 <shapr> It's amazing the difference a single $ can make.
15:13:32 <DRMacIver> That's why I like parentheses. ;)
15:13:50 <shapr> It's true, bugs in Haskell are much more interesting than bugs in other languages.
15:14:19 <sfogarty> Bugs in haskell encourage you to write incremental code. if you do it right, you know exactly where your program crashed by how much output got out first.
15:14:28 <SamB> olsner: or, well, write a program who's semantics change when you try to turn on it's debugging features...
15:14:59 <nornagon> sfogarty: Really? I find that most of my bugs are waaaay back in the code, due to laziness
15:15:06 <nornagon> (not that laziness is a bad thing, of course)
15:15:23 <nornagon> i had a bug where running my map generation the first time would work great
15:15:25 <Mr_Awesome> nornagon: are you sure its not just your own laziness? :P
15:15:27 <nornagon> but the second time it would hang
15:15:38 <sfogarty> Right, but you look at what was getting output from when it crashed, and that was where the bug was :)
15:15:46 <nornagon> because i was generating an infinite list of random numbers and then strictifying it
15:15:47 <sfogarty> If it was handling data from function x, well... go look at function x.
15:16:10 <sfogarty> probably helps tha tmy programs have a lot of output
15:16:21 <nornagon> yeah, but that involves lifting everything into IO >.>
15:16:29 <sfogarty> oh no, it's all put into a big string
15:16:39 <sfogarty> so it's only when IO tries to print that part of the string
15:17:01 <SamB> nornagon: just invoke your program in GHCi and GHC will lift it into IO for you
15:18:56 <mrd> epigram question: after elaborating a shed, how do you later go back and "re-shed" it so you can fix it
15:19:05 <nornagon> but i still can't scatter putStrLn through my code
15:19:14 <nornagon> whether or not I run it from ghci
15:19:23 <dylan> @hoogle trace
15:19:23 <lambdabot> Debug.Trace.trace :: String -> a -> a
15:19:24 <lambdabot> Debug.Trace :: module
15:19:24 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
15:19:32 <sfogarty> oooh
15:19:47 <sfogarty> that looks way too nifty
15:20:20 <nornagon> String -> a -> a?
15:20:39 <dylan> Yep, identity with a side effect, I think
15:20:45 <TSC> It takes a message and a value, prints the message and returns the value
15:20:53 <olsner> impure hack, too
15:20:56 <nornagon> huh
15:20:57 <olsner> but great for debugging
15:20:58 <sfogarty> is that hugs only?
15:21:08 <nornagon> well, i could always just unsafePerformIO ;-)
15:21:19 <dylan> trace is easier.
15:21:21 <TSC> No, ghc too
15:21:33 <sfogarty> Oh, there it is
15:21:37 <olsner> nornagon: that's what trace does, really
15:21:38 <sfogarty> I wil lhave to remember that
15:21:38 <sfogarty> wow
15:21:57 <mrd> ?get-shapr
15:21:57 <lambdabot> shapr!!
15:21:59 <nornagon> oh my
15:22:01 <nornagon> that is cool
15:22:07 <nornagon> dylan: thanks!
15:22:10 <nornagon> dylan++
15:22:36 <TSC> There's a trick you can do with it to help trace function evaluation
15:22:50 <TSC> If you have, say "f x y = ..."
15:23:03 <sfogarty> you know, when 10% or so of the my type class functions raise an error, I think I might have abused the concept a little
15:23:10 <TSC> Put before that line "f x y = trace (show (x,y)) False = undefined"
15:23:42 <TSC> (but change the first = to |)
15:24:01 <DRMacIver> Cute.
15:24:05 <nornagon> oh, neat
15:24:07 <nornagon> TSC++
15:24:15 <nornagon> this will help a great deal, I think :)
15:24:23 <TSC> I've found it pretty handy
15:25:11 <olsner> neat trick
15:25:37 <nornagon> wow
15:25:43 <nornagon> :)
15:26:26 <nornagon> scanr is also a tricky way to debug foldr clauses
15:26:36 <nornagon> also s/r/l/g
15:26:46 <nornagon> er, hm :)
15:26:48 <olsner> s/r/l/g?
15:26:56 <nornagon> think sed
15:27:03 <nornagon> but that's not what i actually meant :p
15:27:17 <Cale> scanl is also a tlicky way to debug foldl clauses
15:27:26 <nornagon> :)
15:27:37 <nornagon> afk now
15:27:39 <sieni> sounds like a misspelling of `tickly'
15:27:42 <Cale> We need semantic sed :)
15:28:03 <sfogarty> So is there an easy way to manipulate sets in haskell aside from nub-y lists?
15:28:17 <olsner> Data.Set
15:29:45 <sfogarty> mmm. with fromList
15:30:18 <sfogarty> I'll have to find a good infix insertion operation.
15:30:52 <TSC> > 2 `Data.Set.insert` (Data.Set.fromList [5..10])
15:30:54 <lambdabot>  fromList [2,5,6,7,8,9,10]
15:31:13 <TSC> Once you shorten the name (or use an operator) it's not so bad
15:31:27 <sfogarty> yes, it is the said operator that I am desiring
15:31:40 <TSC> There's not a predefined one, I think
15:31:47 <TSC> But you could make your own
15:31:48 <sfogarty> I am not a fan of using long names to manipulate basic data structures. No, there isn't, I'll have to make one.
15:32:07 <sfogarty> but I still want matchable sets.
15:32:11 <sfogarty> caseable?
15:32:42 <sfogarty> however you would call it.
15:32:43 <TSC> What would you want to match against?  Empty/non-empty?
15:33:16 <sfogarty> Just like lists, but with no implication of order
15:33:36 <sfogarty> elem:::set or something
15:33:36 <Cale> Empty / (Least element, Rest)
15:34:06 <sfogarty> Ooh, does that work?
15:34:56 <TSC> It sounds like you want a "view", like in Data.Sequence
15:34:57 <sfogarty> oh, problem I come up against pretty routinely. How do you input case statements in ghci?
15:35:46 <TSC> > case 2 of 2 -> "two" ; _ -> "else"
15:35:48 <lambdabot>  "two"
15:35:56 <sfogarty> aha
15:36:37 <sfogarty> I want to throw sets around like lists, really :)
15:37:23 <sfogarty> and use case..of to destruct is a big part of that convenience
15:40:02 <Dybber> Strange, my program /sometimes/ fails with "unimplemented opcode" errors.
15:40:10 <Dybber> <interactive>: internal error: interpretBCO: unknown or unimplemented opcode 48344
15:40:13 <Dybber> <interactive>: internal error: interpretBCO: unknown or unimplemented opcode 52612
15:40:24 <Dybber> <interactive>: internal error: interpretBCO: unknown or unimplemented opcode 52612
15:40:27 <dolio> @hoogle deleteFindMin
15:40:28 <lambdabot> Data.Map.deleteFindMin :: Map k a -> ((k, a), Map k a)
15:40:28 <lambdabot> Data.Set.deleteFindMin :: Set a -> (a, Set a)
15:40:46 <chessguy> anybody know about how many LOC hpaste's limit is?
15:40:57 <Saizan> 5k chars
15:41:44 <Saizan> Dybber: i'd try to narrow it down to a small example and report a bug
15:41:47 <mrd> mudge: hey
15:41:56 <sfogarty> That's a relaly great trick, TSC. :)
15:42:11 <SamB> Dybber: only sometimes?
15:42:28 <SamB> Dybber: wierd!
15:42:47 <Dybber> SamB, yes, well it runs my code on random data everytime I run it
15:42:57 <SamB> ah
15:43:10 <SamB> apparantly they fixed that in 6.6.1
15:43:25 <SamB> but I'm not sure what causes it, so it might be a different error...
15:43:29 <TSC> sfogarty: I wish I remembered where I found it
15:43:53 <hpaste>  TSC pasted "set deconstruction" at http://hpaste.org/2343
15:44:06 <TSC> sfogarty: Have a look at that paste; maybe it's what you want
15:44:22 <sfogarty> oooh. more haskell I don't understand! I love this language
15:44:53 <sfogarty> Yeah, that's just about perfect, actually
15:45:09 <TSC> It doesn't use any advanced features, I think... (I don't know any)
15:45:32 <sfogarty> nah, I'm just used to OCaml
15:45:37 <sfogarty> so := triggered instincts :)
15:45:50 <TSC> Yeah, you should change that name (:
15:45:55 <TSC> It's log n to deconstruct, though
15:46:00 <TSC> Not O(1)
15:46:06 <hpaste>  chessgu pasted "Bi-directional Map API" at http://hpaste.org/2344
15:47:05 <hpaste>  chessguy annotated "Bi-directional Map API" with "part 2" at http://hpaste.org/2344#a1
15:47:13 <hpaste>  conal annotated "set deconstruction" with "set view / style variation" at http://hpaste.org/2343#a1
15:47:24 <dolio> Wow.
15:47:50 <sfogarty> This is true. Yet you should be able to ammortize destruction to constant, with the right structure. But that's likely more trouble than I want
15:48:05 <sfogarty> it is still probably quicker (in most cases) than lists with nub
15:48:06 <sorear> It's not more trouble, it's 1 line
15:48:07 <TSC> You could do it if you had access to the innards of Data.Set
15:48:11 <sorear> import Data.FingerTree
15:48:30 <hpaste>  chessguy annotated "Bi-directional Map API" with "part 3" at http://hpaste.org/2344#a2
15:48:36 <mudge> hey mrd
15:48:39 <sorear> R. Paterson has done most of the dirty work for you
15:48:43 <mudge> mrd: hey
15:49:23 <shachaf> sorear: Data.FingerTree?
15:49:30 <shachaf> sorear: Isn't that Data.Sequence?
15:49:36 <sorear> shachaf: No.
15:49:46 <sorear> shachaf: Data.Sequence is a crippled version.
15:50:02 <sorear> well, specialized
15:50:07 <shachaf> Oh.
15:50:14 * shachaf hasn't looked into it at all.
15:50:16 <sfogarty> hmn. I canna find fingertree
15:50:31 <TSC> http://hackage.haskell.org/packages/archive/fingertree/latest/doc/html/Data-FingerTree.html
15:50:33 <Saizan> chessguy: eek?
15:50:35 <lambdabot> http://tinyurl.com/2oa8uw
15:50:38 <DRMacIver> TSC: Why isn't that paste just toAscList?
15:50:45 <sorear> Sequence uses only Size measures, so all it supports is index operations.
15:50:51 <chessguy> Saizan, how...succinct of you
15:50:57 <DRMacIver> (Modulo a different set of constructors)
15:51:02 <sfogarty> oh. tisn't in base.
15:51:03 <sfogarty> Heh.
15:51:30 <sorear> FingerTree supports arbitrary measures, and by proper choice becomes an optimal heap, tree, radixtrie, or any combination of those.
15:51:42 <Saizan> chessguy: isn't that a bit large for an API?
15:52:07 <chessguy> Saizan, well, the Data.Map API is already quite large
15:52:09 <damg> are the slides of the videos from the topic available anywhere?
15:52:12 <TSC> DRMacIver: I wasn't sure about the performance of to and fromAscList, but if they do the sensible thing then you could use those instead
15:52:47 <sfogarty> looks very shiny. Um. What is a measure? :)
15:52:57 <phobes> If I have a two parameter function f, is there any shortcut notation to partial evaluate with the second argument?
15:53:12 <chessguy> Saizan, if you've got a better suggestion, I'm all ears
15:53:20 <conal> phobes: flip f b
15:53:26 <phobes> thanks
15:53:33 <conal> :)
15:53:42 <sfogarty> Oh! I've always wanted that function!
15:54:12 <shachaf> phobes: (`f` b) also works.
15:54:18 <phobes> Heh
15:54:20 <DRMacIver> TSC: I don't see how it could possibly be less efficient than that. :)
15:54:22 <shachaf> phobes: In some cases it's more readable.
15:54:36 <phobes> thanks guys
15:54:39 <conal> (`f` b) desugars into flip f b
15:54:53 <phobes> does it?
15:54:54 <sorear> damg: yes
15:55:01 <sorear> @go SPJ OSCON slides
15:55:03 <lambdabot> http://programming.reddit.com/info/2a3dc/comments
15:55:03 <lambdabot> Title: A Taste of Haskell : Simon Peyton-Jones OSCON tutorial (pdf) (reddit.com)
15:55:13 <sorear> good enough
15:55:24 <damg> thank you
15:55:32 <shachaf> @wiki Video presentations
15:55:33 <lambdabot> http://www.haskell.org/haskellwiki/Video_presentations
15:55:39 <shachaf> Perhaps that link should be in the topic?
15:55:58 <shachaf> It points to the slides, both ATOH videos, and some other videos, as well.
15:56:02 <sfogarty> I will hate myself later if I use the (`f` b)
15:56:36 <DRMacIver> TSC: It's just a foldr (which, given that foldr has access to the internal representation, means that it doesn't have to build all the intermediate sets that yours does)
15:56:38 <phobes> Another question:  How are the operator precedence rules set?
15:56:42 <conal> btw, flip isn't magic.  you could define it.
15:56:45 <conal> @src flip
15:56:45 <sorear> phobes: infix declarations
15:56:45 <lambdabot> flip f x y = f y x
15:57:02 <sorear> actually (`f` b) desugars into (\x -> f x b), which should not matter at all
15:57:29 <Dybber> Ok, even when I run the program with the same data everytime, the opcodes it calls "unimplemented" are different.
15:57:42 <sorear> phobes: in the standard libraries there is a declaration "infixl 2 +'
15:57:44 <sorear> s/'/"/
15:57:50 <chessguy> Saizan, i've just emailed -cafe about that API as well
15:57:57 <conal> sorear: really?  with b under a lambda?  would re-evaluate it.
15:58:03 <TSC> DRMacIver: Oh, you mean the example?  I didn't intend for that to be a good one; it was just the first thing I thought of to demonstrate the "syntax"
15:58:06 <phobes> thanks
15:58:10 <DRMacIver> Ah. :)
15:58:27 <sorear> Dybber: don't bother, that bug has been reported about 5 times already (and is fixed in 6.6.1)
15:58:32 <sfogarty> I would assume would desugar into (\x -> f x) b
15:58:44 <DRMacIver> Sorry, just saw the code. Should have read more of the surrounding context.
15:58:46 <conal> sfogarty: that's f b
15:58:57 <phobes> \x -> f x b is what I'd have expected
15:59:04 <sfogarty> oh
15:59:05 <sfogarty> yeah
15:59:07 <sfogarty> *sigh*
15:59:20 <sorear> conal: http://haskell.org/onlinereport/exps.html#sect3.5
15:59:20 <chessguy> @pl (\x -> f x) b
15:59:20 <lambdabot> f b
15:59:21 <lambdabot> Title: The Haskell 98 Report: Expressions
15:59:22 <TSC> DRMacIver: No problem (:
15:59:24 <conal> phobes: that version has a performance problem
15:59:24 <Dybber> sorear, ok, thanks.
15:59:36 <chessguy> @pl (\x -> f x b)
15:59:36 <lambdabot> flip f b
15:59:43 <phobes> really conal?
15:59:45 <sorear> conal: note that full laziness will transform the Report version into yours anyway
16:00:00 <conal> sorear: is full laziness on by default??
16:00:15 <SamB> hmm, fixing this ReactOS kernel bug has given me a new appreciation for Text.Printf ;-)
16:00:22 <sorear> not in GHC (need -O)
16:00:24 <conal> phobes: the point is, to make sure that b isn't re-evaluated every time you apply the function
16:00:33 <SamB> though frankly I think Text.Printf needs to implement printf(3) better
16:00:34 <sfogarty> TSC: Hmn, the problem with your view is that construction is now asymmetrical.
16:00:45 <conal> sorear: so without -O, b would get re-evaluated every time (`f` b) is applied??
16:00:49 <phobes> conal: I see - thanks
16:00:56 <conal> phobes: np
16:01:00 <sfogarty> I see an opportunity for rampant abuse of type classes...
16:01:11 <conal> sfogarty: go for it!
16:01:13 <DRMacIver> sfogarty: Excellent! Those are fun. :)
16:01:31 <sorear> Dybber: I think you're looking at http://hackage.haskell.org/trac/ghc/ticket/1004
16:01:34 <lambdabot> Title: #1004 (ghci-6.6 crash) - GHC - Trac
16:01:44 <conal> sfogarty: we'll have to call in Language Protection Services
16:01:47 <DRMacIver> I noticed earlier that you could trivially reproduce the abominable behaviour of Java's String concatenation operator in Haskell. :)
16:01:50 <TSC> sfogarty: I don't know how you could make it as symmetric as for lists
16:02:03 <sfogarty> TSC: If I have both sets and views in the same type class
16:02:11 <sfogarty> er, assuming I can do that...
16:02:17 <sfogarty> I might need a circular type there
16:02:21 <SamB> see what happens when I accidentally pass GNU-formatted x86 assembly to our printf:
16:02:23 <DRMacIver> (I then proceeded to use the trick. :) )
16:02:29 <mrd> mudge: are you familiar with computability?
16:02:41 <sfogarty> (what /is/ the trick?0
16:03:18 <Dybber> sorear, yes it looks like its the same error.
16:03:28 <DRMacIver> sfogarty: Oh, just give the operator you define type (Show a, Show b) -> a -> b -> String
16:03:46 <SamB> > printf "mov    0x8(%ebp),%ebx" :: String
16:03:48 <lambdabot>  Exception: Printf.printf: argument list ended prematurely
16:03:49 <sfogarty> .....
16:04:02 <SamB> instead of nasal daemons
16:04:07 <DRMacIver> > let x +++ y = show x ++ show y in 1 +++ 'f' +++ "bar"
16:04:08 <lambdabot>  "\"1'f'\"\"bar\""
16:04:16 <DRMacIver> Hm. Ok, that doesn't work so well.
16:04:20 <mudge> mrd: no I don't think so, why?
16:04:34 <DRMacIver> It did in the situation I wanted the trick for though. :)
16:04:42 <mrd> mudge: it would help you understand things a lot
16:04:51 <SamB> or, um, "Fatal System Error"s
16:05:03 <sfogarty> oh! right
16:05:03 <sfogarty> heh
16:05:04 <sfogarty> the trick
16:05:26 <mudge> thanks mrd,   I was just looking at the definition of computability
16:05:29 <mudge> I want to know it
16:05:31 <DRMacIver> Basically it's just a way of creating implicit conversions. Nothing very exciting.
16:05:44 <mudge> do you have any recommended reading mrd?
16:06:34 <sfogarty> can datatypes be parameterized by type classes?
16:06:47 <sorear> No.
16:06:57 <sorear> You can't abstract over type classes.
16:07:00 <mrd> mudge: start with wikipedia.  find a copy of the textbook by Michael Sipser that is referenced there.
16:07:28 <shapr> mrd: ?
16:07:29 <sfogarty> Curses. So there's no way to case match (a ::: b) and have b be some unknown member of a type class?
16:07:38 <mudge> okay thanks,  I will.
16:07:48 <mudge> mrd: also I'm currently reading Logic for Dummies
16:08:22 <mrd> shapr: oh, are you familiar with epigram? you're listed as channel owner for #epigram.
16:08:35 <phobes> sfogarty: what is an unknown member of a type class?
16:09:00 <sfogarty> something I'm pretty sure is not allowed.
16:09:02 <ricky_clarkson> shapr: Did you get an alpha release out as planned of your doc-annotation software?
16:09:20 <phobes> sfogarty: What is a member of typeclass, I mean?
16:09:28 <sfogarty> the result of a case x of 1 -> (expression of type x); 2 -> (expression of type y); where x and y both implement a typeclass
16:09:53 <mrd> mudge: it doesn't seem like that covers Computability
16:10:07 <sjanssen> sfogarty: right, that isn't legal
16:10:14 <sfogarty> but it /should/ be.
16:10:20 <sjanssen> no, it can't be
16:10:37 <sjanssen> in Haskell, types can't depend on values
16:10:38 <DRMacIver> It can with existential types can't it?
16:10:51 <sjanssen> we can do this if we introduce a wrapper type
16:10:53 <sfogarty> how is that a dependent type?
16:11:02 <sfogarty> it's existetential, yeah..
16:11:08 <sjanssen> sfogarty: the type of the result depends on whether x is 1 or 2
16:11:18 <sfogarty> Oh, 1 or 2 was just shorthand
16:11:24 <mrd> mudge: you should be familiar with the notion of a Turing Machine, the Halting problem, and why certain problems cannot be decided by a computer program.
16:11:26 <shapr> ricky_clarkson: Not yet, but it's sort of working :-)
16:11:39 <sjanssen> even though types 'a' and 'b' have some class instances in common, they're still different types
16:11:41 <sfogarty> the ytpe I was thinking of was sometyhing like Exists x => Class x
16:11:43 <mudge> mrd: yea, true, but it seems like a lot of this computer science has a basis in mathematics but also logic,  so I think it will help me understand more computer science stuff,
16:11:50 <shapr> mrd: Er, somewhat familiar with it. I'm coding right now, but I can answer simple questions.
16:11:55 <sjanssen> sfogarty: what are 1 and 2 shorthand for?
16:12:05 <sfogarty> arbitrary left hands of cases
16:12:11 <mudge> mrd:  you are absolutely right,  I need to become familiar and know about turing machines and the halting problem etc.
16:12:11 <mrd> shapr: I was just trying to figure out how to "re-shed" a piece of code so I can edit it.  the manual is useless on this topic.
16:12:12 <sjanssen> still illegal
16:12:19 <sfogarty> right, because I can't have a vlue of a type class
16:12:20 <sfogarty> only of a type
16:12:25 <sfogarty> but I want to have values of a type class :)
16:12:26 <shapr> mrd: I'm not sure you can.
16:12:28 <sjanssen> the branches of a case must have the same type
16:12:36 <shapr> mrd: I never figured out how to do that either.
16:12:41 <sjanssen> sfogarty: use an existential wrapper
16:13:02 <phobes> sfogarty:  It doesn't make sense to talk about values of a TypeClass, since there can be multiple types associated to a type class
16:13:17 <sjanssen> data Wrap = forall a. SomeClass a => Wrap a
16:13:17 <phobes> You want values that fill the role of one type of a typeclass
16:13:19 <sjanssen> then
16:13:41 <sjanssen> "case x of 1 -> Wrap (some value of type a); 2 -> Wrap (some value of type b)
16:13:42 <mudge> mrd: Does the book:
16:13:42 <mudge>  	
16:13:42 <mudge> Structure and Interpretation of Computer Programs
16:13:53 <mudge> cover turing machines and halting etc.?
16:13:57 <sfogarty> Yeah, I'm looking at the existential thing now
16:14:52 <sfogarty> can one not input data definitions into ghci?
16:15:02 <sjanssen> correct
16:15:11 <mrd> mudge: I don't believe so
16:15:36 <shapr> mudge: But turing machines and halting are pretty simple ideas.
16:15:37 <sfogarty> this is nice
16:15:39 <sfogarty> I didn't realize haskell had existential types this conveniently defined
16:15:42 <shachaf> mudge: http://mitpress.mit.edu/sicp/full-text/sicp/book/node81.html , maybe?
16:15:43 <lambdabot> Title: Data as Programs
16:15:55 <shapr> mudge: http://en.wikipedia.org/wiki/Halting_problem
16:15:56 <lambdabot> Title: Halting problem - Wikipedia, the free encyclopedia
16:16:54 <sfogarty> So, out of curiosity, why must existential types be wrapped?
16:17:07 <mudge> shachaf, shapr,  thanks
16:17:14 <sfogarty> It doesn't seem like it would be undecidable. (which, of course, is a such a strong argument)
16:17:32 <shapr> mudge: Ooh, have you heard of "strongly normalizing" ? It's a big word for computations that always finish.
16:18:03 <shapr> mudge: There are lots of big words for simple ideas in CS, but #haskell is the best reference I've found.
16:18:37 <SamB> shapr: does it only mean "always finish"?
16:18:38 <SamB> doesn'
16:18:44 <monochrom> "monomorphism" :)
16:18:48 <SamB> t it also mean that you get the same answer each time/
16:18:58 <shapr> That's true.
16:19:11 <ari> I like the word "terminate"
16:19:16 <mudge> nice,  me too
16:19:26 <mudge> sharp: nice, me too
16:19:35 <shapr> mudge: shapr is short for shaper
16:19:45 <shapr> I couldn't afford the extra vowel that day...
16:19:56 <mudge> shapr: oh thanks
16:20:09 <Philippa> ari: that's a property of a program rather than a language though
16:20:12 <mudge> shapr:  are you french?
16:20:20 <shapr> mudge: I'm from Alabama :-)
16:20:28 <mudge> oh
16:20:30 <monochrom> shapr is sharper
16:20:36 <shapr> monochrom: Nah, it's shaper
16:20:39 <shapr> mudge: http://www.scannedinavian.com/hope/about
16:21:28 <shapr> Haha, I love SPJ's OSCON slides!
16:21:29 <sfogarty> Alright. As much as I love haskell, I suppose I should go actually work.
16:21:39 <mudge> shapr: your first name is Shae?
16:22:02 <sfogarty> Thank you very much everyone. I'll probably be back next time I get confused.
16:22:04 <sorear> mudge: yes
16:22:05 <olliej> shapr: where are they?
16:22:07 <shapr> Yup, Shae Matijs Erisson.
16:22:14 <shapr> olliej: http://programming.reddit.com/info/2a3dc/comments
16:22:16 <lambdabot> Title: A Taste of Haskell : Simon Peyton-Jones OSCON tutorial (pdf) (reddit.com)
16:22:31 <shapr> mudge: And Shae is short for shapr, which is short for shaper.
16:22:37 <shapr> Easy, yeah?
16:22:54 <mudge> cool,  like multiple functions calling each other
16:22:59 <sorear> sfultong: because of implementation laziness :)
16:23:13 <shapr> heh, yeas
16:23:48 <sorear> mudge: to be more precise, strong normalization means that every possible evaluation finishes, weak normalization means that there is *some* finishing evaluation
16:24:36 <sorear> mudge: useful theorems here are Church-Rosser (if you finish, it doesn't matter what path you took) and completeness of normal order (if there is *any* successful way, a lazy evaluator will find it)
16:25:10 <chessguy> shapr, wait, so your actual name is shapr?
16:25:12 <chessguy> er
16:25:13 <chessguy> shaper
16:26:00 <ddarius> His actual name is Shae Matijs Erisson... now
16:26:15 <SamB> which is apparantly short for his IRC nick
16:26:16 <mudge> sorear: thanks
16:26:19 <shapr> Right
16:26:22 <SamB> which is short for an english word
16:26:27 <shapr> right!
16:26:33 <ricky_clarkson> If you look closely at the bible, you'll see that Jesus rode a unicycle.
16:26:39 <shapr> But I was Robert Benjamin Gilliam for 27 years.
16:26:41 <mudge> everything gets shorter
16:26:48 <mudge> with shapr's names
16:26:50 <shapr> But then I got bored.
16:27:08 <mudge> soon shapr's name is going to be s
16:27:12 * shapr laughs
16:27:17 <shapr> I'm pretty happy with Shae/shapr
16:27:32 <mudge> they are unique and cool
16:27:58 <shapr> thanks :-)
16:28:01 <shapr> My family wasn't very happy.
16:28:31 <ddarius> They usually aren't.
16:30:02 <Cale> Man, I have a great idea. A religion whose holy book is only permitted to be printed in the form of microfiche. To read it, you'd have to go to the library and use one of those machines.
16:30:29 <mudge> does anyone in here watch Hacker News or Reddit Programming?
16:30:36 <yaxu> presumably they'd get installed in the churches too
16:31:03 <ricky_clarkson> mudge: I think Hacker News got re-renamed to Startup News.
16:31:08 <ricky_clarkson> (and yes to both)
16:31:17 <ddarius> I'd find "carved in stone tablets" much more entertaining.
16:31:20 <yaxu> not hacker news, i'm not interested in startups
16:31:26 <mudge> ricky_clarkson: that would be funny
16:31:43 <mudge> Hacker News still says hacker news though,  what makes you think it got changed back again?
16:31:53 <DRMacIver> mudge: I think half the channel is on programming.reddit.com :)
16:32:28 <mudge> cool,  I do see a lot of haskell posts on programming.reddit.com
16:32:36 <chessguy> Cale!
16:32:37 <ricky_clarkson> mudge: The title in my RSS reader says Y Combinator Startup News.
16:32:43 <ddarius> mudge: That's all because of dons.
16:32:47 <mudge> I think it's part of how I started getting into Haskell, because I kept reading stuff about it
16:33:02 * ddarius doesn't read reddit at all.
16:33:06 <mudge> oh,  don's is the bigtime reddit programming poster?
16:33:26 <sorear> don-s is 2nd iirc
16:33:45 <mudge> ricky_clarkson: Web page says Hacker News ---  they probably haven't changed the RSS feed yet
16:33:53 <sorear> dons, don stewart, donald bruce stewart - never seen don's before :)
16:33:54 <ddarius> Whole wheat spaghetti smells like cookies when it is cooking.
16:34:48 <mudge> I wonder what it tastes like when it's cooking
16:34:54 <chessguy> Cale, i just sent an email to -cafe that i'm hoping you look at
16:35:02 <SamB> mudge: probably hot
16:35:40 <chessguy> @src Enum
16:35:40 <lambdabot> class  Enum a   where
16:35:40 <lambdabot>     succ                     :: a -> a
16:35:40 <lambdabot>     pred                     :: a -> a
16:35:40 <lambdabot>     toEnum                   :: Int -> a
16:35:40 <lambdabot>     fromEnum                 :: a -> Int
16:35:42 <lambdabot> [3 @more lines]
16:35:52 <ddarius> It tastes like whole wheat spaghetti that's a bit too much al dente.
16:36:00 <yaxu> they changed the name to hacker news in a lame effort to try to make the site less boring, but still its populated by businesspeople...  the top story is of the "steve jobs buy this company" type
16:36:20 <shapr> yuck
16:36:25 <shapr> I'd like to see news about cool new projects.
16:38:54 <yaxu> i also slightly resent paul graham casting the whole of hackerdom in his image
16:39:34 <dduncan> hi ... as I work on the Pugs implementation of Perl 6 over Haskell, I've recently had to reinstall ghc 6.6.1 under Mac OS X PPC 10.4.10, and I am now having a makefile problem with Pugs that might be due to my not having installed ghc correctly ... but running 'ghc' directly at the command line appears to indicate that it is running ...
16:39:51 <dduncan> normally I ask in #perl6 about issues, but was pointed to ask here ...
16:40:16 * sorear points shapr at HWN :)
16:40:18 <SamB> what are the symptoms?
16:40:22 <dduncan> near the start of the Pugs makefile, I get errors like this: /usr/bin/ld: table of contents for archive: /usr/local/lib/ghc-6.6.1/libHSCabal.a is out of date; rerun ranlib(1) (can't load from it)
16:40:34 <dduncan> what I installed is ...
16:40:57 <sorear> dduncan: that looks like a *warning* to me
16:41:27 <dduncan> I installed the http://haskell.org/ghc/dist/6.6.1/ghc-6.6.1-powerpc-apple-darwin.tar.bz2 binary plus its 2 framework dependencies
16:41:29 <lambdabot> http://tinyurl.com/2ax244
16:41:30 <dduncan> one moment ...
16:41:56 <dduncan> the makefile dies with: collect2: ld returned 1 exit status
16:41:56 <dduncan> *** Building Setup failed (exit code 256)
16:41:56 <dduncan>     Please check your GHC and Cabal installation.
16:42:26 <shapr> New syntax guards?
16:42:27 <dduncan> I'm not sure if this is a ghc install problem, or a Pugs problem ... I didn't really change Pugs since it last worked ...
16:42:42 <shapr> When were those added to ghc?
16:42:48 <dduncan> also, when I previously installed that ghc a month ago, I was pointed to some special instructions, which I couldn't find now
16:42:57 <sjanssen> shapr: pattern guards?
16:43:06 <sjanssen> shapr: they're really old
16:43:18 <shapr> I'm looking at page 96 of SPJ's OSCON slides.
16:43:36 <shapr> abs x | x>0 ..
16:43:46 <shapr>       | otherwise =
16:44:05 <sjanssen> that's Haskell '98
16:44:10 <shapr> oh
16:44:17 <dduncan> part of my question here is whether you know of any special ghc install instructions, such as any commands I have to issue around installing the dependency frameworks (readline and another) and the ghc binary
16:44:21 <shapr> I thought I'd been using them forever, was just curious.
16:44:23 <ndm> | Just x <- foo
16:44:28 <ndm> thats pattern guards
16:44:35 <dduncan> it may have been a forum post or something unofficial I was pointed to
16:44:50 <dduncan> seen audreyt_
16:44:50 <mudge> hey does Simon Peyton Jones ever come on #haskell?
16:44:57 <shapr> Yeah, sometimes.
16:44:58 <ndm> mudge: once or twice
16:45:02 <sjanssen> mudge: rarely
16:45:07 <mudge> rad,  what's his user name?
16:45:10 <ddarius> simonpj
16:45:16 <Pseudonym> ?seen simonpj
16:45:16 <lambdabot> I haven't seen simonpj.
16:45:16 <ddarius> @seen simonpj
16:45:17 <lambdabot> I haven't seen simonpj.
16:45:21 <Pseudonym> I win!
16:45:21 <ddarius> @uptime
16:45:22 <lambdabot> uptime: 3d 18h 44m 59s, longest uptime: 1m 10d 23h 44m 29s
16:45:45 <mudge> got to love lambdabot
16:45:55 <ddarius> @seen JaffaCake
16:45:56 <lambdabot> I saw JaffaCake leaving #haskell, #haskell-soc and #ghc 5d 15h 16m 2s ago, and .
16:46:18 <ricky_clarkson> And what?
16:46:30 <ndm> JaffaCake == Simon Marlow
16:46:34 <ndm> (the other simon)
16:47:18 <chessguy> @seen spj
16:47:18 <lambdabot> I haven't seen spj.
16:47:26 <mudge> @mudge
16:47:26 <lambdabot> Unknown command, try @list
16:47:32 <ricky_clarkson> At least Haskellers seem to like their figureheads - lispers don't seem to like Paul Graham so much.
16:47:37 <mudge> there should be a mudge command
16:47:40 <mudge> @mudge
16:47:40 <lambdabot> Unknown command, try @list
16:47:45 <sorear> mudge: the third Simon shows up much more frequently
16:47:47 <ddarius> Paul Graham is not Lisp's figurehead.
16:47:48 <chessguy> @help mudge
16:47:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:48:42 <dduncan> @seen audreyt_
16:48:42 <lambdabot> audreyt_ is in #haskell and #perl6. I don't know when audreyt_ last spoke.
16:48:47 <mudge> I'm confused, has lambdabot seen Simon Peyton Jones?
16:48:59 <sorear> mudge: Yes, but she's extremely forgetful.
16:49:11 <mudge> @seen mudge
16:49:11 <lambdabot> You are in #haskell. I last heard you speak just now.
16:49:17 <ndm> sorear: who is the third simon?
16:49:23 <ddarius> Simon Thompson
16:49:28 <mudge> lambdabot is a girl?
16:49:35 <mrd> mudge: no. you cannot get the problem.
16:49:38 <mrd> get around*
16:49:40 <sorear> ndm: Simon Lynagh :)
16:49:43 <chessguy> @quote girl
16:49:43 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
16:49:43 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
16:49:43 <lambdabot> he was one of the pugs de
16:49:55 <lambdabot> It's not like I have genitals, but I anthropomorphize as female.
16:50:09 <ndm> sorear: who renamed Ian?
16:50:15 <lambdabot> I think it was some sad nerd's idea of a joke.
16:50:37 <SamB> I thought his name was Igloo
16:51:15 <mudge> mrd: can't get around what problem?
16:51:21 <mrd> the halting problem
16:51:27 <mudge> mrd: oh i see
16:51:27 <lambdabot> I'm temperamental, and I cop an attitude on occasions.
16:51:49 <mudge> mrd: so it is actually something you have to consider when comparing functions in haskell?
16:52:02 <chessguy> @quote attitude
16:52:02 <lambdabot> No quotes match. Just what do you think you're doing Dave?
16:52:06 <mrd> it's something you have to consider when comparing functions, period.
16:52:11 <desp> hrm
16:52:21 <desp> I have a difficulty with multiparameter typeclasses
16:52:27 <desp> me can has help?
16:52:30 <mrd> this is not the kind of "theory" you can ignore and merrily get by.
16:52:49 <ddarius> desp: The answer is functional dependencies.
16:52:58 <mudge> mrd: okay, thanks
16:53:01 <hpaste>  desp pasted "deduction" at http://hpaste.org/2345
16:53:08 <ndm> ddarius: functional dependencies = pain
16:53:11 <desp> ddarius: heh
16:53:18 <ddarius> mrd: I'm pretty sure most programmers ignore it fine.
16:53:30 * ndm has seen spj's "death to functional dependencies" talk
16:53:39 <mrd> mudge: theory means "Collection of Theorems" and "Theorem" means a statement which has a derivation from the axioms.
16:53:52 <dduncan> as an update, I actually did try to look up the instructions given a month ago, but the #perl6 channel log I was using was missing 2 days ... however, I seem to have found another logger with the missing info, so looking there now ...
16:53:59 <mudge> hey, I wrote an explanation of Currying for beginners: http://www.nickmudge.info/?post=42
16:54:03 <lambdabot> Title: Explanation of Haskell Currying
16:54:33 <ddarius> ndm: Where is that?
16:54:51 <ndm> ddarius: at AngloHaskell, don't think its available online
16:54:55 <mudge> mrd: thanks for those definitions,  it clarifies things more,   where did you get the definitions?
16:55:09 <mrd> your book on logic should have them
16:55:12 <ddarius> ndm: When 6.8 comes around perhaps I'll join you.
16:55:43 <mudge> ah thanks,  yea,  I'm on chapter 2 but I have read some explanations of theorems
16:55:49 <ndm> ddarius: the replacement (associated types) is still not ready
16:56:11 <ddarius> ndm: Won't it be mostly useable by 6.8 or do I have to wait til 6.10?
16:56:20 <ndm> ddarius: 6.10
16:56:33 <ndm> ddarius: or haskell'''' if you want to be hugs and Yhc compatible
16:57:15 <mudge> mrd: nice blog/website,  why do you say: Higher Order Publishing Environment
16:57:43 <MarcWeber> ndm: Do you know a small cabalized library using ffi so I can play with hugs to try adding it to nix?
16:58:06 <ndm> MarcWeber: no, i know nothing about ffi at all, even less using it with hugs
16:58:11 <mudge> oh sorry, that's shapr's website
16:58:19 <Pseudonym> Is there anything about this "death to functional dependencies" online?
16:58:36 <mudge> shapr: e blog/website,  why do you say: Higher Order Publishing Environment
16:58:39 <ndm> not that i know
16:58:47 <ndm> mudge: because its written with Haskell
16:59:19 <desp> ddarius: could you please look at my paste? it's quite simple
16:59:37 <desp> ddarius: I can't fix this by applying fundeps
16:59:39 <MarcWeber> *shrug* .. I thought you would know nearly everything about haskell :-) Are you interested in trying nix on windows in some days? (Or do you still have disk space issues?)
16:59:42 <ddarius> desp: I did.  What do you expect it to do?
16:59:44 <mudge> yea,  but is it just his blog,  or does he work on a general purpose haskell web application framework?
16:59:50 <ddarius> desp: Are you sure?
17:00:08 <desp> ddarius: no, I'm not. :)
17:00:28 <ddarius> Adding | a -> b to EOption1 or whatever may fix it (but may not be what you want).
17:00:30 <desp> ddarius: ideally, I'd like to avoid having another type parameter for EOption1
17:00:44 <desp> oh, a -> b...
17:00:59 <desp> this helps
17:01:01 <desp> ddarius++
17:01:08 <ddarius> I told you.
17:01:19 <desp> yeah, I thought it was the other way around
17:01:40 <ddarius> desp: But as I said, it may not be what you want.
17:01:57 <desp> the code typechecks now, so I think it is what I want ;)
17:03:23 <ddarius> class Single a | -> a where ...
17:03:25 <chessguy> @quote typecheck
17:03:25 <lambdabot> Saizan says: yesterday i was so drunk i was trying to typecheck the people at the party.. "what's your monad!?"
17:03:43 <dons> ?users
17:03:43 <lambdabot> Maximum users seen in #haskell: 395, currently: 365 (92.4%), active: 19 (5.2%)
17:03:46 <dons> whoa!1
17:03:52 <dons> crikey!!!!111
17:04:10 <Eidolos> make that 20 active users *resumes lurking*
17:04:15 <dons> ddarius: do you remember when we guessed we'd reach 400?
17:04:18 <dduncan> to follow up, it appears that what I missed was running this: sudo ranlib /usr/local/lib/ghc-6.6.1/*.a
17:04:28 <dduncan> doing that got me past my stated problem
17:04:33 <ddarius> dons: I don't remember guessing, so no.
17:05:22 <sorear> ndm: Any word yet on when the AH slides go online?
17:05:24 <ddarius> Since there were around 40 people on #haskell when I first joined, it's grown about an order of magnitude in that time.
17:05:46 <dons> :)
17:05:58 <chessguy> ddarius, when was that?
17:06:13 <shapr> mudge: The publishing system is called HOPE.
17:06:13 <dons> 06.12.18:18:18:06 <dons> so how about 400 by say, next July?
17:06:15 <ndm> sorear: mine are both online: http://www-users.cs.york.ac.uk/~ndm/downloads/
17:06:16 <ddarius> Early 2002 I believe.
17:06:17 <lambdabot> Title: Neil Mitchell - Downloads
17:06:55 <shapr> dons: Heh
17:07:03 <dons> 18:18:33 <sjanssen> dons: I'll place my bet on May
17:07:10 <dons> 18:19:32 <sjanssen> August
17:07:16 <shapr> Well..
17:07:33 <dons> so sjanssen might be on the money
17:07:42 * sjanssen crosses fingers
17:07:47 <sjanssen> @users
17:07:47 <lambdabot> Maximum users seen in #haskell: 395, currently: 364 (92.2%), active: 19 (5.2%)
17:07:52 * Pseudonym considers creating some IRC troll accounts to artificially inflate the numbers
17:07:57 <dons> :)
17:08:06 <kpreid> they need inflation?
17:08:12 <kpreid> stop while you're ahead :-)
17:08:16 <ddarius> shapr has see two orders of magnitude and is well on his way to three.
17:08:35 <sorear> so we're currently the FN #12
17:09:00 <sorear> I've seen a binary OOM :)
17:09:07 <dons> sorear: who's in 13th then?
17:09:17 <sorear> dons: #kubuntu
17:09:21 <dons> my stats says we're #13. http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
17:09:22 <lambdabot> Title: Search IRC, displaying all channels on freenode
17:09:22 <sorear> dons: #11 is #ruby-lang
17:09:33 <dons> ah, so you're missing one channel
17:09:37 <ddarius> What we need is to plot the growth of each of these channels over some amount of time.
17:09:44 * sorear is looking at http://irc.netsplit.de/channels/?net=freenode&chat=&num=10
17:09:45 <shapr> Yeah, would be interesting.
17:09:45 <lambdabot> Title: freenode - IRC Channels - irc.netsplit.de
17:09:48 <bitrot> eh, #haskell is more entertaining to read than others..
17:10:11 <shapr> bitrot: How so?
17:10:17 <dons> ddarius: yeah, that'd give us some very interesting trend data
17:10:24 <MarcWeber> lambdabot: ? :)
17:10:24 <lambdabot> Maybe you meant: . activity activity-full admin all-dicts arr ask b52s babel bf botsnack brain bug check choice-add choose clear-messages compose devils dice dict dict-help djinn djinn-add djinn-clr
17:10:24 <lambdabot> djinn-del djinn-env djinn-names djinn-ver docs dummy easton echo elements elite eval fact fact-cons fact-delete fact-set fact-snoc fact-update faq figlet figlet' flush foldoc forecast forget fortune
17:10:24 <lambdabot> fptools free freshname ft gazetteer get-shapr ghc girl19 google gsite gwiki hackage help hitchcock hoogle hoogle+ id ignore index instances instances-importing irc-connect jargon join karma karma+
17:10:24 <lambdabot> karma- karma-all keal kind learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban map messages messages? more msg nazi-off nazi-on offline oldwiki palomer
17:10:27 <lambdabot> part paste pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices quit quote rc read reconnect redo
17:10:30 <chessguy> shapr, where else can you hear about extreme unicycling? :)
17:10:30 <lambdabot> [3 @more lines]
17:10:39 <shapr> chessguy: Hah, good point
17:10:52 <ddarius> We may be passing ##c and ##c++ in the next year or two.
17:10:57 <shapr> That'd be amazing.
17:10:59 <ricky_clarkson> > get-shapr
17:11:00 <lambdabot>   Not in scope: `shapr'
17:11:04 <shapr> ricky_clarkson: You called?
17:11:07 <chessguy> @get-shapr
17:11:07 <lambdabot> shapr!!
17:11:13 <shapr> chessguy: You screamt?
17:11:34 * chessguy gets out the shap-signal
17:11:37 <shapr> haha
17:11:49 <bitrot> shapr: it degenerates better ;).  Tangents tend to have more "ooh-cool!" moments.
17:12:02 <shapr> That's a neat observation.
17:12:07 <sorear> in the next year, I wouldn't be suprised if we pass #ubuntu!
17:12:42 <chessguy> sorear, err, that's a big jump
17:12:51 <dons> http://programming.reddit.com/info/2gqch/comments
17:12:51 * sorear thinks haskell is growing way too fast... think snowball rolling down mountain directly at a tree
17:12:52 <lambdabot> Title: User-level transactional programming in Haskell (reddit.com)
17:12:58 <chessguy> we'd have to quadruple in size in a year, even if they don't grow at all
17:13:11 <dons> sorear: how do you think the ruby guys feel?
17:13:19 <dons> or the lisp guys ... ;)
17:13:24 <shapr> sorear: It's okay though.. if the snowball splits into a bunch of smaller communities, each of those will have something good from the community that was #haskell.
17:13:27 <ndm> bogged down under a crappy syntax ;-)
17:13:36 <dons> haskell-lang and haskell-happs
17:13:37 <ricky_clarkson> You know when a channel gets too big because its topic contains things like "don't paste".
17:13:46 <dons> yeah. i agree ricky_clarkson
17:13:47 <gigamonkey_> The "<-" syntax is just part of the "do" sugar, right?
17:13:50 <dons> we've not reached that yet
17:13:53 <dons> gigamonkey_: yep.
17:14:00 <dons> ?undo do x <- getChar ; return x
17:14:00 <lambdabot> (getChar >>= \ x -> return x)
17:14:08 <shapr> It's surprising that we've gotten this many people without things breaking down.
17:14:11 <sorear> gigamonkey_: it's also used by list comprehensions
17:14:15 <mrd> ?users
17:14:16 <lambdabot> Maximum users seen in #haskell: 395, currently: 364 (92.2%), active: 22 (6.0%)
17:14:21 <MarcWeber> How are the Java folks organized ? :) We'll end that way.
17:14:27 <pchiusano> yo
17:14:31 <gigamonkey_> So it seems like the YAHT explanation of the do translation rules should not use it on the right hand side of the translation rules. Hmmm.
17:14:34 <chessguy> hi pchiusano
17:14:40 <pchiusano> hey
17:14:40 * sorear can hear the sound of rivets popping in the background, however.
17:14:41 <Eidolos> gigamonkey_: giving up on Lisp? :)
17:14:54 <pchiusano> @src last
17:14:54 <lambdabot> last [x]    = x
17:14:54 <lambdabot> last (_:xs) = last xs
17:14:54 <lambdabot> last []     = undefined
17:14:58 <gigamonkey_> Ah, never mind it doesn't.
17:15:10 <shapr> Of course, we have #haskell-blah and #haskell-overflow, and #haskell.{se,de,es,dut,fi,fr,ru,no,hr,it} and more.
17:15:10 <MarcWeber> shapr: What hould have broken down? the irc channel?\
17:15:14 <reltuk> @src undefined
17:15:14 <lambdabot> undefined =  error "Prelude.undefined"
17:15:27 <pchiusano> will last [a, b, c] evaluate a and b?
17:15:33 <gigamonkey_> Eidolos: nope. Just expanding my horizons. Actually I'm hoping to interview Simon Peyton Jones for my next book to I figured I'd better get some learnin'
17:15:36 <chessguy> pchiusano, no
17:15:43 <shapr> MarcWeber: Most communities reach a certain size and then have a major split resulting in two or more communities.
17:15:45 <reltuk> > last [1,2,3]
17:15:46 <dons> sorear: i'm not convinced though. there's always the core community that goes to HW. that's not changing
17:15:47 <lambdabot>  3
17:15:53 <pchiusano> why won't it
17:15:57 <dons> nd now we just have lots more people writing libraries
17:15:58 <sorear> @users #haskell.es
17:15:58 <lambdabot> Maximum users seen in #haskell.es: 1, currently: 0 (0.0%), active: 0 (NaN%)
17:16:08 <chessguy> pchiusano, just enough to see that there are actually elements there
17:16:12 <reltuk> dons: what's HW?
17:16:12 <chessguy> pchiusano, not fully
17:16:17 <gravity> We need more apps though. I wish I was actually good at coming up with interesting apps to write.
17:16:22 <dons> i don't see any splits yet -- unlike lisp, haskell is too hard to write in a day to create your own incompatible fork :)
17:16:29 <dons> reltuk: the haskell workshop
17:16:29 <chessguy> > last [[1..],[3]]
17:16:30 <lambdabot>  [3]
17:16:35 <chessguy> pchiusano, ^^
17:16:39 <shapr> gravity: You don't have to be good at coming up with apps, you just hack on whatever is available, then things get better!
17:16:42 <pchiusano> hmm
17:16:49 <gigamonkey_> dons: you're thinking of Scheme.
17:16:52 <gravity> shapr: Most of the apps that are available that I want to hack on are in C :-(
17:16:56 <dons> gravity: yeah. apps are really useful. darcs, happs, pugs, xmonad. stuff like that.
17:17:09 <MarcWeber> dons, shapr That's what would have guessed That ghc keeps all together
17:17:09 <shapr> gravity: So port them to Haskell! It doesn't really matter whether you run across major problems, it's the journey that's fun.
17:17:33 <dons> that's one way to do it: see xmonad or hmp3 for examples
17:17:41 <dons> once the C app is just too annoying, write your own
17:18:01 <reltuk> haha
17:18:05 <shapr> gravity: Also, feel free to drop a project when you hit a roadblock and learn the right way to do that thing in Haskell.
17:18:09 <gravity> The X server is a bit too big for me to want to rewrite it, annoying as it is :-)
17:18:14 <dons> :)
17:18:18 <shapr> gravity: But trying to write/port stuff is a great way to learn more Haskell.
17:18:22 <dons> gravity: how bout XCB?
17:18:25 <gravity> shapr: I've dropped quite a few so far, and learned a lot doing it
17:18:30 <shapr> gravity: Excellent!
17:18:31 * reltuk has the impression that an appreciable amount of desktop-level software that dons uses everyday is written in haskell :-p
17:18:41 <dons> reltuk: that's true.
17:18:51 <gravity> dons: XCB itself? It's probably not the best choice among the X bits, given how old some of it is
17:18:58 <gravity> Maybe some of the hidden bits like xinit
17:18:59 <mudge> hey dons
17:19:11 <dons> hey
17:19:17 <shapr> gigamonkey_: Enjoying the #haskell community so far?
17:19:34 <MarcWeber> nginit would be a much better choice
17:19:36 <gravity> And rewriting debian's startx implementation in haskell might be fun
17:19:48 <MarcWeber> aeh initng
17:19:51 <wolverian> hm, or ubuntu's upstart
17:19:53 <gigamonkey_> Seems pretty friendly. Of course I'm used to #lisp so lot's of things would seem friendly. ;-)
17:19:56 <chessguy> hmm, no apparent interest in my bi-directional Data.Map :(
17:20:16 <dons> chessguy: did you write one? benchmark it and post it to hackage?
17:20:21 <dons> what is the structure?
17:20:28 <gravity> wolverian: Well, I have direct influence over one, not the other :-)
17:20:33 <chessguy> dons, i emailed -cafe with a proposed API
17:20:42 <dons> chessguy: i think you should just write it :)
17:21:01 <ddarius> @quote gigamonkey Seems pretty friendly. Of course I'm used to #lisp so lot's of things would seem friendly. ;-)
17:21:01 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
17:21:02 <shapr> Yeah, write it, release it, and demonstrate why it's cool.
17:21:03 <chessguy> dons, i'm planning on it, it would just be nice to get some guidance, as a newbie
17:21:07 <ddarius> @remember gigamonkey Seems pretty friendly. Of course I'm used to #lisp so lot's of things would seem friendly. ;-)
17:21:07 <lambdabot> Done.
17:21:16 <phobes> Isn't there a haskell utility that takes API specifications to implementations?
17:21:25 <dons> chessguy: hmm, i'd follow the Map and IntMap code for style and examples
17:21:26 <ddarius> @djinn a -> b -> b
17:21:26 <lambdabot> f _ a = a
17:21:31 <mudge> shapr: cool HOPE system
17:21:38 <wolverian> gravity, sure :)
17:21:42 <shapr> gigamonkey_: Yeah, I wanted to learn CLisp at one point, but I started talking to rahul, and ... I've never really wanted to learn CLisp since then.
17:21:44 <chessguy> dons, i basically cannibalized the Data.Map API
17:21:48 <dons> good
17:21:57 <ddarius> shapr: CL
17:21:59 <gigamonkey_> Okay, if you're going to be remembering my flippant remarks at least answer my Haskell question ...
17:22:04 <gigamonkey_> shapr: get a good book. ;-)
17:22:16 <ddarius> gigamonkey_: Any suggestions...
17:22:26 <shapr> gigamonkey_: I prefer an active friendly community mixed with a good book.
17:22:31 <chessguy> dons, prepending "left_" for functions that go from k -> a, and "right_" for functions that go from a -> k
17:22:32 <reltuk> Practical Common Lisp is free...and I thought it was great =)
17:22:35 <gigamonkey_> When I define  a type: data Foo = Bar | Baz how are instances of Foo actually represented.
17:22:36 <shapr> gigamonkey_: What was your Haskell question?
17:22:42 <gigamonkey_> see above.
17:22:48 <ddarius> gigamonkey_: However the compiler feels like it.
17:22:51 <mudge> gigamonkey:  I really like your book on Common Lisp
17:22:54 <gigamonkey_> ddarius: Well, I like Practical Common Lisp.
17:23:04 <gigamonkey_> ddarius: I figured. But in practice ...
17:23:19 <ddarius> gigamonkey_: I remember your announcement(s) in c.l.l.
17:23:36 <gigamonkey_> I guess my real question is, there must be some runtime type information kept, right.
17:23:36 <shapr> @undo do foo <- bar ; return bar
17:23:36 <lambdabot> (bar >>= \ foo -> return bar)
17:23:42 <ddarius> gigamonkey_: It's different for each implementation.  GHC using something similar to Church encoding.
17:24:08 <gigamonkey_> I.e. I can have a list of Foo's and map over it using pattern matching to figure out whether they were constructed as Bar or Baz, right?
17:24:10 <ddarius> gigamonkey_: Yes, implementing it as just an Int or some such would be acceptable, but it isn't type information that is being stored.
17:24:15 <chessguy> @pl bar >>= \ foo -> return bar
17:24:15 <lambdabot> bar >> return bar
17:24:31 <ddarius> gigamonkey_: Yes.  But both Bar and Baz have type Foo.
17:24:34 <Eidolos> I spent most of today reading Practical Common Lisp. I recommend it.. :)
17:24:36 <mudge> gigamonkey_: great book on Common Lisp
17:24:46 <shapr> Gee, I wonder who wrote that book? ;-)
17:24:52 <gigamonkey_> mudge, Eidolos: thanks.
17:25:29 <gigamonkey_> shapr: seriously, even #lisp isn't that bad. There are just a few guys you need to learn to ignore.
17:25:37 <chessguy> dons, by the way, you don't have benchmarking on "How to write a program in haskell" :)
17:25:50 <gigamonkey_> ddarius: so what do you call the difference between Bar and Baz.
17:26:03 <shapr> gigamonkey_: Eh, I'd rather they were just banned...
17:26:06 <gigamonkey_> a difference in ? constructor? value?
17:26:07 <shapr> But I'm picky that way.
17:26:28 <Korollary> constructor
17:26:36 <pjd> or value
17:26:48 <reltuk> so, in the case of constructor tags...that's not really type information, that's value information
17:26:49 <gigamonkey_> Well, the thing is, the folks I'm thinking of are not doing anything wrong--they're just not acting in a way that's helpful to new Lispers.
17:27:15 <shapr> In my opinion, that's something wrong.
17:27:22 <ddarius> gigamonkey_: You can view Int as data Int = 0 | 1 | -1 | 2 | -2 | ...
17:27:28 <dons> shapr: did yo usee http://esoteric.voxelperfect.net/wiki/IRP ?
17:27:30 <lambdabot> Title: IRP - Esolang
17:27:30 <shapr> Newbies are the lifeblood of any community.
17:27:38 <gigamonkey_> But #lisp get's perhaps more than it's fair share of trolls and extremely clueless newbies so some people are on a bit of a hair trigger.
17:27:39 <mudge> maybe there should be guidelines or write ups on how to help newbies
17:27:40 <dons> chessguy: ah good point
17:27:50 <reltuk> dons: hilarity
17:28:33 <gigamonkey_> shapr: I mostly agree with you. But Lisp seems to attract newbies who come in with the attitude of "I've been programming Lisp for five minutes and here are a bunch of things I think need to change ..."
17:29:01 <Korollary> dons: hahah
17:29:07 <shapr> Well, #haskell gets its fair share of "Why can't I just get the Int out of IO Int?"
17:29:18 <gigamonkey_> Which is particularly galling given Lisp's long history and the fact that many smart people have been hacking on it for a long time.
17:29:25 <shapr> And that sometimes leads to "How to fix Haskell" posts on the mailing list.
17:30:00 <shapr> gigamonkey_: You could teach them how to modify their own copy of lisp to do what they want :-)
17:30:11 <reltuk> shapr: people don't seem to understand that >>= will do that for you...but will force you to put it back in eventually
17:30:21 <shapr> reltuk: Yeah, I agree.
17:30:30 <ddarius> What we tend to do is say "It's that way for a reason" and then let them figure it out themselves.
17:31:10 <phobes> and if that doesn't work talk category theory at them until they leave
17:31:15 <shapr> heh
17:31:20 <ddarius> gigamonkey_: E.g. http://www.haskell.org/pipermail/haskell-cafe/2007-June/027172.html
17:31:20 <shapr> I hope that doesn't really happen :-)
17:31:22 <lambdabot> Title: [Haskell-cafe] Re: Perl-style numeric type, http://tinyurl.com/22valk
17:31:29 <gigamonkey_> shapr: well, the problem is they don't even have to modify their own copy of Lisp; they *could* usually do it *in* Lisp but then we'd have to have a long conversation about why that's probably a bad idea. Or spend days helping them sort out all their programming questions while the do do it until they realize it's a bad idea. And most folks have run out of patience for either of those paths.
17:32:03 <Korollary> I'd like my dessert now
17:32:07 <shapr> Hm, I generally take the second path.. if they think it's a good idea, after I've said I don't think it is, I'll help them do it... maybe they're right.
17:32:22 <shapr> And if they're not right, they generally end up with a much greater understanding of Haskell, so...
17:32:23 <lament> but you can easily get Int out of IO Int :)
17:32:28 <kpreid> gigamonkey_: re "runtime type information": note that Haskell completely separates the two things
17:32:30 <desp> ddarius: heh
17:32:39 <desp> that was indeed entertaining
17:33:22 <gigamonkey_> Yeah, but some of these are *really* classic things the Lisp world has hashed out over, and over, and over again. Which an interested newbie could actually read about elsewhere if they cared.
17:33:23 <kpreid> gigamonkey_: you can't have subtypes like you can in CL
17:33:38 <kpreid> (allowing that makes type inference Hard)
17:33:43 <ddarius> gigamonkey_: Indeed.  As has been said and illustrated, it happens here too.
17:33:49 <shapr> gigamonkey_: But the learning process would still help them hash it out for themselves.
17:34:09 <ddarius> The solution is to tell them it's not a good idea and why and if they still insist let them try it themselves.
17:34:23 <gigamonkey_> shapr: yes, the question is how much time do people want to spend guiding a seemingly endless stream of newbies through the same learning process.
17:34:37 <ddarius> gigamonkey_: It's the nature of the beast.
17:34:40 <gigamonkey_> particularly if the newbies seem unwilling to, say, go read a good book first.
17:34:42 <shapr> gigamonkey_: Newbies become middies or whatever, and then they can guide the next batch!
17:34:50 <ddarius> The new newbie doesn't know what the last newbie just asked.
17:35:12 * kpreid finds #lisp occasionally cranky and #haskell mildly noisy, and isn't sure which is better.
17:35:33 <mrd> > fix ("newbie":)
17:35:35 <lambdabot>  ["newbie","newbie","newbie","newbie","newbie","newbie","newbie","newbie","ne...
17:35:48 <lament> i like how there's a :) in there
17:36:09 <SamB> kpreid: consider the topics as well ;-)
17:36:22 <kpreid> Hmm?
17:36:27 <gigamonkey_> I think any newbie who showed up in #lisp asking questions that demonstrated they had read and understood a reasonable % of Practical Commmon Lisp, would find people to be pretty helpful.
17:36:39 <phobes> I think he means would you rather be in a channel about lisp or about haskell...
17:36:39 <ddarius> gigamonkey_: I'm sure.
17:36:50 <ddarius> gigamonkey_: But most don't do that in any language.
17:36:52 <shapr> gigamonkey_: Some newbies don't yet know how to learn.
17:36:57 <Olathe> Monads are the work of SATAN !
17:37:18 <SamB> @google monads catholic church
17:37:20 <lambdabot> http://en.wikipedia.org/wiki/Monism
17:37:20 <lambdabot> Title: Monism - Wikipedia, the free encyclopedia
17:37:21 <ddarius> Olathe: Possibly.
17:37:23 <SamB> hmm.
17:37:38 <kpreid> Haskell : monads :: Lisp : parentheses?
17:37:41 <shapr> But if they have interest, and are willing to spend time on their interest, they can learn how to learn in the process.
17:37:53 <ddarius> kpreid: A little bit, but not that much.
17:38:18 <kpreid> ddarius: only in how they appear to newcomers; not so much in their actual role in the language
17:38:19 <shapr> gigamonkey_: Or maybe I'm an unstoppable optimist :-)
17:38:37 <mudge> I must say as a newbie learning Haskell, that I haven't been sure how much logic,  how much computer science,  how much actual haskell,  and how much math I should learn
17:38:51 <mudge> to learn and really understand haskell
17:38:58 <lament> probably 100% haskell
17:39:06 <ddarius> gigamonkey_: I do admit CL has it (probably much) harder.  It takes a few more turns around the block before most people end up at Haskell.
17:39:14 <mrd> has anyone tried to compile the unix package with ghc 6.6.1 lately
17:39:14 <shapr> Yeah, that's true.
17:39:38 <sjanssen> @hoogle setlocale
17:39:39 <lambdabot> System.Win32.NLS.setLocaleInfo :: LCID -> LCTYPE -> String -> IO ()
17:39:39 <lambdabot> System.Win32.NLS.c_SetLocaleInfo :: LCID -> LCTYPE -> LPCTSTR -> IO Bool
17:39:43 <lament> mudge: all programming requires some background in math, logic and computer science, and i doubt haskell requires any more than not haskell...
17:39:52 <Cale> mudge: Well, there's haskell, and then there's all this beautiful computer science which is going on around it. It's the CS which requires mathematics and logic.
17:40:00 <gigamonkey_> shapr: Yes. I don't know how it is here in #haskell but in #lisp there seem to be quite a few newbies who don't really have interest in Lisp. These newbies (not all of them, but just enough to make it pretty annoying) seem to just want to find an excuse to *not* learn Lisp while maintaining their self-illusion that they're intellectually curious.
17:40:09 <EvilTerran> kpreid, i'd say Haskell : Hindley-Milner :: Lisp : parens, and Haskell : Monads :: Lisp : macros. but that's just me.
17:40:12 <ddarius> mudge, lament: You also gain knowledge of logic and mathematics just from learning Haskell (whether you realize it or not).
17:40:19 <Cale> You'll probably end up picking up lots of it along the way.
17:40:21 <shapr> gigamonkey_: Oh, we do get those here. But they don't usually hang around for long.
17:40:25 <SamB> gigamonkey_: few come here with no interest
17:40:26 <phobes> As another Haskell newbie, IMO haskell requires a much higher level of mathematical understanding than most other languages
17:40:35 <SamB> or at least, they don't stick around...
17:40:47 <gigamonkey_> That's probably too cynical--most newbies are not that way but Lisp seems to attract a lot who are which leads to the aforementioned hair trigger among old-school Lispers.
17:40:49 <phobes> Mathematical maturity at least
17:41:01 <Cale> I'm not sure about "requires", so much as that you can benefit from it.
17:41:06 <mudge> well I learned PHP,  and I tell you that you need to know very little about math, logic and a lot of other stuff,  the learning curve is so slight in comparison to haskell
17:41:15 <ddarius> phobes: It doesn't -require- mathematical maturity at all.
17:41:28 <Cale> mudge: What other languages do you know?
17:41:30 <phobes> ok I concede that... but to understand "what's going on"
17:41:31 <ddarius> phobes: I'm willing to bet most people here would not say they have "mathematical maturity"?
17:41:33 <mrd> mudge: the same notions of computability apply in PHP
17:41:38 <phobes> I mean it's not as bad as epigram
17:41:40 <shapr> gigamonkey_: I try to be very tolerant to someone without a reputation, and intolerant to someone with a previous record of just distracting people from the topic of learning Haskell, CS, PLT, etc
17:41:46 <phobes> but compared to python or something...
17:41:57 <mrd> mudge: it probably just never occurred to you to do anything other than ordinary web programming and string manipulation
17:42:02 <SamB> shapr: meaning smerdy
17:42:04 <Cale> If you already know imperative languages, then learning imperative languages is easy.
17:42:16 <shapr> Yeah, Smerdyakov and several others fit into that.
17:42:20 <Cale> If you already know functional languages, then learning functional languages is easy.
17:42:22 <ddarius> SamB: Smerdyakov was not a distraction.
17:42:37 <SamB> ddarius: baiting newbies isn't distracting?
17:42:39 <gigamonkey_> shapr: You guys just wait until you've had a few decades of "You should learn Haskell--it'll make you a better programmer in whatever language you really use" and see the kind of newbies you get then and how much patience you have with them. ;-)
17:42:48 <shapr> gigamonkey_: Yeah, maybe so.
17:42:56 * kpreid says that!
17:42:57 <shapr> gigamonkey_: But I can hope #haskell won't get cranky.
17:43:06 <ddarius> SamB: Well I didn't say exactly what I meant.  "distraction" wasn't his worst attribute.
17:43:10 <shapr> ddarius: Heh, true
17:43:13 * gigamonkey_ doesn't really excuse the behavior of certain #lisp'ers.
17:43:14 <SamB> gigamonkey_: I thought we were planning to move on to a new language before then
17:43:28 <mrd> haskell', now with less crankiness!
17:43:31 <shapr> w00!
17:43:41 <gigamonkey_> SamB: that's the problem with Lisp. Once you know it, you can't move on. ;-)
17:43:42 <shapr> gigamonkey_: And I'll do my part to keep #haskell from getting cranky.
17:43:48 <shapr> I have my boots of kicking...
17:43:54 <gigamonkey_> shapr: Good man!
17:43:55 <SamB> gigamonkey_: can you say "blub"?
17:43:56 <mudge> Well in PHP the stuff never comes up,   the books on PHP are so dumbed down  and easy to read,   you don't get exposed to logic and a lot of things
17:43:56 <ddarius> gigamonkey_: By then C## will be 90% Haskell.
17:44:07 <mudge> I'm not saying it is better at all,    I think Haskell is a lot better by far
17:44:34 <mrd> mudge: in PHP you don't have the ability to really consider functions as values, and higher-order functions
17:44:39 <EvilTerran> eval()!
17:45:00 <mrd> as every lisper knows, eval does not give you higher-order functions =)
17:45:12 <shapr> gigamonkey_: So, what are you learning now?
17:45:41 <bitrot> ddarius: re: C##...but it'll have to be called D at that point, which is already there....unless you're in a microtonal system.
17:45:46 * EvilTerran thinks... i'm pretty sure you could do HOFs in perl, say, with eval and none of the usual HOF support in perl
17:45:49 <gigamonkey_> I'm on chapter 9 of YAHT.
17:45:52 <gigamonkey_> Monads.
17:46:01 <shapr> Oh, what do you think so far?
17:46:07 <EvilTerran> and it's definitely been used to do lambdas in Tcl...
17:46:13 <shapr> Have you looked at stuff like http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html ?
17:46:16 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
17:46:26 <gigamonkey_> Seems fine. I'm still enough of a Lisper to think any language without macros is missing something.
17:46:50 <wolverian> gigamonkey_, the need for them? :)
17:46:50 <SamB> gigamonkey_: if you'd seen our macro systems, you might change your mind
17:46:54 <shapr> gigamonkey_: Well, there's Template Haskell... but it's definitely not as integrated as macros.
17:47:01 <ddarius> gigamonkey_: We have TH but it's a crappy substitute and for a couple of reasons they're less needed.
17:47:08 <pjd> mrd: http://www.steike.com/code/php-closures/
17:47:10 <lambdabot> Title: php closures
17:47:15 <mudge> mrd: true
17:47:15 <EvilTerran> i find a lot of stuff you'd need macros for in lisp is covered by, say, typeclasses and whatnot.
17:47:18 <SamB> TH might be lest crappy if macros were more needed
17:47:41 <shapr> gigamonkey_: Finding monads easy to understand?
17:47:53 <gigamonkey_> shapr: they're beginning to sink in.
17:48:09 <shapr> Cool
17:48:21 <kpreid> gigamonkey_: lazy evaluation and purity eliminates all the macros that are really just (or can be expressed as) wrapping lambdas around their arguments.
17:48:24 <gigamonkey_> Though I have to say, the number of utterly confusing Monad tutorials on the web is disheartening.
17:48:36 <SamB> gigamonkey_: agreed!
17:48:46 <gigamonkey_> kpreid: yes, but those are not the interesting uses of macros. As you well know.
17:48:49 <SamB> why we can't just use academic papers and such is beyond me
17:49:00 <Olathe> Academic papers are hard to read.
17:49:13 <gigamonkey_> SamB: the academic papers are worse!
17:49:17 <kpreid> gigamonkey_: I admit I find it hard to think about what the whole category is
17:49:24 <kpreid> here's *one*:
17:49:48 <kpreid> in Haskell, for certain fs, you can write [f x, f y, f z], but not map f [x, y, z]
17:50:21 <Olathe> Eww.
17:50:26 <SamB> yes, if I did a monad tutorial, it'd probably start out like a mathworld article...
17:50:48 <mrd> Wadler writes excellent academic papers
17:50:52 <SamB> and then I'd just give some example monad implementations
17:50:55 <Olathe> I think Mathworld is nice as a reference, but not as a tutorial.
17:50:58 <lament> gigamonkey_: give an example for an actual macro that could be useful in haskell
17:51:16 <pjd> lament: do blocks?
17:51:27 <phobes> heh
17:51:34 <SamB> well, I mean, I'd not try to explain what they are beyond the laws...
17:51:36 <kpreid> If Haskell had macros, arrow notation would have been provided as macros.
17:51:42 <ddarius> gigamonkey_: You find Wadler's papers on monads hard to read?
17:52:11 <gigamonkey_> lament: I haven't grokked Haskell well enough to say. However, the kind of macros I'm talking about are things like: http://www.gigamonkeys.com/book/practical-parsing-binary-files.html
17:52:14 <lambdabot> Title: Practical: Parsing Binary Files, http://tinyurl.com/9p6ly
17:52:19 <gigamonkey_> ddarius: dunno if I've looked at them.
17:52:30 <phobes> Macros could be used to hide the machinery of Monads more than just the do notation
17:52:40 <ddarius> gigamonkey_: Do so at some point.  They're extremely entertaining.  Wadler is a gem of the Haskell community.
17:52:49 <phobes> Look at how ugly it is to combine monads / monad transformers
17:52:54 <mudge> gees,  I've never had such interest in an IRC channel before,  this channel rocks
17:53:08 <mudge> i could read you guys all day
17:53:21 <Korollary> You could read the logs
17:53:43 <shapr> mudge: Yeah, roughly six years of logs :-)
17:53:52 <gigamonkey_> The problem I've had with the monad tutorials I've found is that they're still aimed at Haskell programmers. Which makes a certain amount of sense ...
17:54:30 <mudge> Korollary, shapr:   I'm also new to IRC in general, kind of,   are the logs on the Web?
17:54:30 <gigamonkey_> ... however I think there may be enough folks like me who say, okay, maybe I want to learn Haskell but first I need to know what these  monad things are all about
17:54:47 <augustss> gigamonkey_: but you don't
17:54:58 <mrd> who is behind libraries@haskell.org?
17:55:12 <gigamonkey_> But I do in the sense that I want a hint of how the story is going to end before I start reading the book.
17:55:23 * gigamonkey_ doesn't really read actual books that way, mind you.
17:55:46 <augustss> gigamonkey_: but monads is just a chapter in the book
17:55:46 * shapr grins
17:55:53 <kpreid> the primary reason monads aren't readily transferred to other languages is lack of type inference for 'return', I think
17:56:15 * ddarius just got around to read that IRP link.  It's hilarious.
17:56:17 <gigamonkey_> It's like people thinking of learning Lisp want to know what the big deal about macros before they decide whether it's worth diving in
17:56:43 <augustss> kpreid: the lack of higher kinded type variables makes abstraction of monads impossible
17:57:15 <augustss> kpreid: and most languages lack that
17:57:46 <ddarius> Haskell did too way back when.
17:58:01 <ddarius> Or at least the facility to make type classes over them.
17:58:02 <gmh33> wait.. gigamonkey, did you write this book?
17:58:11 <gigamonkey_> gmh33: which?
17:58:14 <ddarius> gmh33: /whois gigamonkey_
17:58:23 <gigamonkey_> Practical Common Lisp? Yes.
17:58:26 <gmh33> oh, wow
17:58:34 <gmh33> neat
17:58:43 * SamB doesn't remember having gotten too far in that...
17:58:54 <shapr> gigamonkey_: Heh, you're famous!
17:59:04 <gmh33> I didn't really get too far into it either ^^;
17:59:08 <gigamonkey_> In *very* small circles, yes.
17:59:21 <gigamonkey_> you guys don't know what you're missing.
17:59:34 <mudge> gigamonkey_: what if there was a separate lisp channel for old-time lispers that don't want to deal with newbies,  and a lisp channel for newbies?
17:59:54 <ddarius> mudge: That would be a useless waste of time.
18:00:09 <SamB> you mean like #grumpy-lisp and #lisp or something?
18:00:16 <gmh33> mudge: strange though, that he wrote one of the two most recommended books for common lisp newbies :P
18:00:19 <ddarius> Or at least the newbie channel would be and the "old-timers" channel would just be #lisp as it is now.
18:00:26 <sorear> it's pretty easy to make monads work in a statically typeless language with dynamic dispatch.
18:00:50 <ddarius> sorear: Without closures.
18:01:03 <SamB> gigamonkey_: well whenever I try CL I miss, uh, modular libraries, static types, functional programming...
18:01:18 <sorear> Pretty much everyone has closures these days.
18:01:22 <augustss> ddarius: yes, haskell lacked higher kinded type variables until Haskell 1.3 (I think it was).  It was Mark Jones that came up with the idea
18:01:26 <ddarius> SamB: Just implement a H-M type inference macro.
18:01:32 <pjd> kpreid: it would be interesting to have a language with type-dispatched continuations
18:01:39 <gigamonkey_> SamB: no doubt. But at least you'd have macros. ;-)
18:02:11 <mrd> argh, libraries@h.o shouldn't be listed as maintainer if it won't accept arbitrary email.
18:02:16 <shapr> I'd like to interview Mark Jones about all the cool stuff he's thought up for Haskell.
18:02:23 <ddarius> Also lacking TCO...
18:02:29 <gmh33> SamB: There's nothing keeping you from programming with a functional style in CL
18:02:36 <augustss> gigamonkey_: I've used CL a lot.  I don't miss it.  Now and then I feel the urge for macros, though.
18:02:40 <SamB> gmh33: what about all those nasty #'s
18:02:44 <ddarius> gmh33: Nothing except the rest of the language and libraries...
18:02:55 <mrd> #' is really the least of the problems
18:03:06 <SamB> I didn't get far enough to know
18:03:24 <shapr> I think (almost) every language has something worth understanding.
18:03:25 <gigamonkey_> I'm interested to see, as I actually learn Haskell, whether it in fact turns out the macros are somehow unnecessary or incompatible with the haskell ecosystem.
18:03:57 <gigamonkey_> shapr: except for some of the newer more popular ones. ;-)
18:04:15 <mrd> gigamonkey_: a large number of macros are created to introduce different orders of evaluation, and haskell doesn't have that issue
18:04:23 <EvilTerran> gigamonkey_, there are some things that TH seems useful for, but they don't seem to actually come up in the field that oftem
18:04:34 <gigamonkey_> mrd: that's really the tip of the macro iceberg.
18:04:34 <ddarius> gigamonkey_: They aren't strictly incompatible (though it would piss people off not to be able to use them in a "higher order" fashion) and they certainly are necessary for somethings.
18:04:36 <EvilTerran> (eg dealing with tuples of arbitrary length)
18:04:38 <augustss> But TH is clumsy
18:04:45 <mrd> some macros generate boilerplate, which is addressed by libraries like SYB and Uniplate
18:04:45 <phr-zzz> there's also liskell
18:04:47 <gigamonkey_> EvilTerran: maybe that's because TH isn't powerful enough. I don't know.
18:05:09 <gigamonkey_> ddarius: it's not clear to me what higher-order macros even means.
18:05:11 <augustss> I miss macros to introduce new variable binding constructs
18:05:18 <gigamonkey_> Macros are compiler plugins.
18:05:32 <EvilTerran> and, yes, TH is hideously ugly much of the time. gigamonkey_, i mean, although being able to suck the nth value out of a k-long tuple sounds handy, say, it's rarely actually useful
18:05:34 <ddarius> gigamonkey_: As mrd points out, there is a feeling of wanting to solve these problems "within" the language too.
18:05:59 <ddarius> gigamonkey_: I meant things like (mapcar #'and somelist)
18:06:14 <shapr> gigamonkey_: Hey, I wrote some PHP... bet you can guess my opinion.
18:06:25 <mrd> I write CL pretty much every day still
18:06:44 <mudge> shapr: what's your opinion of PHP?
18:06:56 <shapr> I think it could be better :-)
18:07:02 <shapr> Was that tactful enough?
18:07:14 <mudge> :)   I find php boring
18:07:20 <shapr> Actually, I hacked on Drupal for a few hours and realized I could cut the code in half with higher order functions.
18:07:29 * ddarius has never used PHP. Yay!
18:07:48 <gmh33> PHP stands for PHP Hates People, right?
18:08:02 <mudge> noway,  PHP loves people,  it hates computer scientists
18:08:13 <ddarius> So PHP Hates Programmers?
18:08:14 <gmh33> I see
18:08:42 <Tac-Tics> PHP is a very ugly language
18:08:51 <shapr> mudge: I was looking for software bounties at the time, and Drupal had some. But I don't think Drupal would have accepted a patch that converted the whole codebase to Haskell.
18:09:09 <mudge> It's a C language,   if you think PHP is ugly,  you probably think C is ugly too
18:09:17 <mrd> Tac-Tics: you might say a Pretty Hideous Programming language
18:09:18 <pjd> (regarding higher-order macros: http://okmij.org/ftp/Scheme/macros.html#Macro-CPS-programming)
18:09:19 <lambdabot> Title: Scheme Macro Programming
18:09:28 <glguy> PHP is ugly in ways that don't relate back to C
18:09:36 <Olathe> C is somewhat nice.
18:09:40 <Olathe> PHP is the work of Satan.
18:09:51 <ddarius> Along with monads.
18:09:52 <Tac-Tics> mrd: hah
18:09:57 <SamB> Olathe: you just said that about monads, yes
18:10:04 <gigamonkey_> ddarius: yeah, you could imagine wantiing that to work. But for most (interesting) macros, that kind of thing wouldn't even make sens.
18:10:07 <Pseudonym> Satan is far too competent in his evil to have done PHP.
18:10:11 <gigamonkey_> sense, even.
18:10:26 <mrd> SataniT, the evil monad transformer
18:10:37 <ddarius> gigamonkey_: I agree. In many of those cases, they could still be useful in Haskell.  E.g. things like deriving.
18:10:37 <Pseudonym> PHP has it's uses.  It's for when SSI isn't quite enough.
18:10:39 <shapr> mudge: In my opinion, with serious use of monads and higher order functions, Drupal would probably be 25% of its current size.
18:11:11 <mudge> shapr: wow,  good to know
18:11:23 <phobes> Ya, Haskell is a big language.  If it had macros it could conceivably be smaller
18:11:40 <shapr> Maybe we should grab TH and clean it up :-)
18:11:49 <mudge> shapr: it would have been neat for it Drupal to accept a patch that converted the whole code base to Haskell
18:12:11 <ddarius> shapr: Actually, in some regards the problem with TH is it's too "friendly".
18:12:14 <shapr> mudge: Don't think it would happen though :-)
18:12:18 <shapr> ddarius: How so?
18:12:52 <foones> Hi
18:12:55 <shapr> hi foones
18:12:57 <shapr> How's code?
18:13:09 <ddarius> shapr: I want to munge arbitrary crap into Haskell, not type-checkable parseable Haskell.
18:13:12 <foones> Does anybody know what something like   \ ~x -> ... means?
18:13:22 <pjd> foones: lazy pattern matching
18:13:24 <foones> (emphasis in the  ~ )
18:13:30 <ddarius> foones: In that particular case it's identical to \x -> ...
18:13:38 <mrd> see http://haskell.org/tutorial/patterns.html
18:13:39 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
18:13:45 <ddarius> Good job mrd.
18:13:52 <shapr> ddarius: Ohh, so you think a ghc-api that made it easy to produce Haskell source would make more sense?
18:13:56 <foones> Ahh =)
18:14:01 <foones> Thanks!
18:14:07 <mrd> yes, I remembered that and typed it in manually
18:14:26 <ddarius> shapr: It's the quoting features that are more the issue not the generation ones.
18:14:33 <phr-zzz> does anyone know why GADT's don't support "deriving Show" ?
18:14:44 <shapr> ddarius: Huh?
18:15:03 * shapr thinks about that.
18:16:16 <kpreid> with Lisp-style macros the arguments can be any value, not just Haskell source, and those values can be written cleanly in the source
18:16:22 <twanvl> What would be cool is if [| . |] was a class method, class Quote a where [||] :: [Token] -> a
18:16:25 <glguy> gigamonkey_: do you feel like any of the macro use in PCL gives a particularly compelling case for them in uses other than defining control constructs?
18:16:26 <kpreid> s/Haskell/the-language/
18:16:37 <gigamonkey_> glguy: see http://www.gigamonkeys.com/book/practical-parsing-binary-files.html
18:16:39 <glguy> gigamonkey_: (just looking for a pointer to a chapter to review)
18:16:40 <lambdabot> Title: Practical: Parsing Binary Files, http://tinyurl.com/9p6ly
18:16:41 <shapr> kpreid: Oh, I see.
18:16:44 <glguy> gigamonkey_: cool, thanks
18:17:04 <shapr> Has anyone mentioned that idea to SPJ?
18:17:16 <gigamonkey_> Also http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html though there are other non-macro ways to do that, especially with HOF.
18:17:18 <lambdabot> Title: Practical: Building a Unit Test Framework, http://tinyurl.com/2b99d
18:17:19 <Saizan> kpreid: even with TH the arguments can be any value, the difference is that haskell code is not a lisp-list
18:17:40 <dons> mrd: thanks for the patch. yeah, it was an internal api change in the base package
18:17:48 <ddarius> I think Camlp4 is more along the right lines for a Haskell-like language.
18:17:59 * EvilTerran would prefer if TH canonicalised quoted expressions more before giving them to you.
18:18:00 <kpreid> shapr: that reminds me: does SPJ read his email? :)
18:18:01 <mudge> Is the Common Lisp community bigger than the Haskell community?
18:18:06 <glguy> gigamonkey_: most of the interesting macro use I've seen was to generate things like classes based on some domain specific representation
18:18:08 <ddarius> mudge: Yes.
18:18:19 <shapr> kpreid: He replies to me in the rare cases that I send him email.
18:18:19 <glguy> but I don't have a ton of Lisp exposure
18:18:25 <EvilTerran> but, given that it's not even finished, iirc, never mind that...
18:18:27 <gigamonkey_> glguy: that's what that first chapter is, pretty much.
18:18:27 <mudge> just curious,  I wonder how much bigger
18:18:38 <mrd> dons: I sent something about unix-2.0 to libraries@h.o but I don't know if it got through. it's the same deal though.
18:18:38 <kpreid> shapr: I heard something in his A Taste of Haskell that makes me think there's some worthwhile ideas he doesn't know of.
18:18:48 <gigamonkey_> shapr: you should tell him that he should respond to my email asking for an interview. ;-)
18:19:06 <ddarius> mudge: Impossible to tell.  It's hard to estimate the size of either.  Probably at least an order of magnitude or two more, easily much more.
18:19:16 <desp> hmm
18:19:22 <desp> another typeclass problem.
18:19:34 <shapr> gigamonkey_: You got no response?
18:19:54 <mrd> mudge: there's a lot of CL out there which you doesn't manifest on the Internet in any noticeable way
18:20:00 <desp> given typeclass Foo a b, how can I have a function (Foo a b) => a -> () ?
18:20:07 <mrd> minus the "you"
18:20:18 <desp> I actually want a function (Foo a Bar) => a -> ()
18:20:25 <mrd> desp: what would said function do?
18:20:28 <ddarius> desp: That should be doable.
18:20:37 <gigamonkey_> shapr: well, I got an auto-response saying he'd be on vacation until tomorrow.
18:20:40 <kpreid> "const ()"?
18:20:41 <shapr> Oh
18:20:49 <desp> mrd, kpreid: that's just sample code :)
18:21:00 <desp> showing the essence of the problem
18:21:03 <kpreid> desp: well, that's all your type allows
18:21:08 <mrd> @djinn a -> ()
18:21:08 <lambdabot> f _ = ()
18:21:10 <augustss> desp: what's the problem with having such a function?
18:21:10 <mudge> thanks ddarius, mrd
18:21:12 <kpreid> desp: so it rather hides the essence of th eproblem
18:21:13 <desp> kpreid: the type doesn't typecheck
18:21:15 <twanvl> desp: maybe you should split the type class
18:21:16 <ddarius> undefined!
18:21:17 <gigamonkey_> So hopefully I'll hear from him tomorrow. But if you, or anyone else he knows, wanted to drop him a note saying I'm a reasonable fellow, that'd be fine.
18:21:35 <mudge> gigamonkey_: what are you going to ask him?
18:21:50 <ddarius> gigamonkey_: I'd imagine he'd look you up if you were asking for an interview if he was at all worried about it.
18:21:54 <desp> twanvl: I don't think that's possible
18:22:06 <ddarius> I doubt he gets crazies asking for interviews all that often.
18:22:08 <gigamonkey_> mudge: I want him to let me interview him for my next book: http://www.codersatwork.com/
18:22:10 <lambdabot> Title: Coders at Work
18:22:15 <augustss> SPJ gets a lot of email
18:22:45 <Korollary> I propositioned SPJ with my Nigerian business plan
18:22:46 <hpaste>  desp pasted "not so sample code" at http://hpaste.org/2346
18:22:50 <mudge> gigamonkey_: wow, that's awesome
18:22:57 <desp> kpreid, mrd: ^
18:23:03 <desp> if that helps your understanding
18:23:20 <kpreid> what's the error?
18:23:27 <desp> this isn't valid syntax
18:23:31 <desp> (BitFlags a CLong)
18:23:37 <shapr> gigamonkey_: I think the binary parser could be done with Parsec and Data.Binary.
18:23:41 <SamB> Korollary: lol
18:23:48 <mrd> probably will want a fundep
18:23:55 <hpaste>  desp annotated "not so sample code" with "error" at http://hpaste.org/2346#a1
18:24:16 <augustss> desp: are you using -fglasgow-exts
18:24:23 <kpreid> desp: that's not a syntax error.
18:24:33 <desp> kpreid: yes, you're right. my bad.
18:25:18 <shapr> gigamonkey_: I think I'd implement "defmacro define-binary-class" as a typeclass.
18:25:35 <desp> ahh.
18:25:36 <augustss> desp: annotate fromIntegral so that it's clear that it returns CLong (if that's what you want)
18:25:49 <desp> just a simple fundep fixed it.
18:26:06 <augustss> that works too
18:26:13 * shapr looks at the unit test framework macro demo.
18:26:13 <desp> oh.
18:26:18 <glguy> as long as its what you wanted
18:26:22 <glguy> since it has other implications
18:26:24 <gigamonkey_> shapr: I don't know enough to say whether that's a good idea or close to equivalent.
18:26:31 <glguy> other than allowing your code to compile :)
18:26:37 <desp> thanks for the help
18:26:46 <gigamonkey_> If you want to actually do it, I'd be interested to see what it looks like.
18:27:20 <ddarius> ndm: Have you looked at supercompilation?
18:27:24 <mrd> I like the way Binary works.  write instances for your types, and it picks out the proper one to use based on what type is expected.
18:27:26 <shapr> It would be a nice way to test out xerox' new SoC code.
18:27:29 <ddarius> shite
18:27:33 <shapr> mrd: Yeah, that's exactly what I was thinking.
18:27:38 <ddarius> @tell ndm Have you looked at supercompilation?
18:27:38 <lambdabot> Consider it noted.
18:27:41 <mrd> QuickCheck also works this way
18:27:59 <glguy> gigamonkey_: if you are talking to me, I could give it a look
18:28:01 <mrd> when I first saw the code for QuickCheck, I was stunned that it was incredibly short
18:28:18 <augustss> QuickCheck is rather clever
18:28:26 <ddarius> We like our code clever.
18:28:26 <gigamonkey_> glguy: actually, I was talking to shapr since he said he'd do it as a typeclass. But the more the merrier.
18:28:27 <glguy> gigamonkey_: I think that the way this would be implemented in Haskell is that rather than defining a new type for each type of binary data to be handled
18:28:28 <shapr> Yeah, I think QuickCheck covers the unit test framework, and a bit more.
18:28:34 <glguy> gigamonkey_: ah, cool
18:28:43 <glguy> gigamonkey_: I'm not following the channel closesly enough to keep up :)
18:28:45 <shapr> glguy: Feel free to go for it, I'd rather get FLM working :-)
18:29:00 <glguy> what's this FLM thing I've heard mentioned?
18:29:09 <SamB> glguy: it depends what kinds of binary data you'd be dealing with...
18:29:16 <gigamonkey_> shapr: like I said, the unit test thing can be done lots of ways, especially if you have HOF.
18:29:21 <Pseudonym> glguy: It's a marvellous program that unfortunately the channel is too small to describe.
18:29:28 <shapr> Yeah, true
18:29:38 <glguy> is it publicly available?
18:29:38 * shapr laughs at Pseudonym's comment
18:29:52 <shapr> glguy: What is it? A distributed decentralized wiki-based darcs-backed research paper annotation tool called Fermat's Last Margin.
18:29:58 <mrd> perhaps you could sketch it in #haskell-margin
18:30:03 <shapr> glguy: How does it work? In short, wget the pdf/ps, throw it into imagemagick, create wiki pages for the resulting page images, and save text annotations into the darcs repo. If your repo is http accessible, anyone can grab your per-page annotations, and you can grab theirs.
18:30:20 <shapr> Pseudonym: I'm going to put that into the README :-)
18:30:30 <Pseudonym> :-)
18:30:40 <gigamonkey_> shapr: the one key feature of the macro-based test framework is that you can make something like (check (= (foo x y) 100)) report the pass or fail but also use '(= (foo x y) 100) in the output *and* tell you the values of x and y.
18:30:47 <Pseudonym> "I have written a truly marvellous program, but unfortunately the README is too small to describe it."
18:31:14 * mrd suspects Fermat didn't really have a proof anyhow
18:31:24 <mrd> just good intuition
18:31:45 <shapr> gigamonkey_: QuickCheck does something sort of like that. But QuickCheck is pretty kickass, have you seen http://www.accesscom.com/~darius/software/clickcheck.html ?
18:31:46 <lambdabot> Title: Clickcheck and Peckcheck
18:32:04 <shapr> Clickcheck is a QuickCheck clone in CL, written by my good friend Darius Bacon.
18:32:12 * mrd is waiting for Paycheck
18:32:56 <Pseudonym> mrd: I think he had a proof that he later found was wrong.
18:32:56 <mudge> I found the haskell IRC log: http://ircbrowse.com/cdates.html?channel=haskell
18:33:01 <lambdabot> Title: Meme Channel haskell by Dates
18:33:14 <ddarius> mudge: There's a link to the logs in the topic...
18:33:18 <gigamonkey_> shapr: haven't seen that. Thanks.
18:33:19 <Pseudonym> If he really had a proof, he'd have published it.
18:34:00 <mrd> Pseudonym: yea that's what I mean
18:34:21 <mudge> ddarius: oh yea, thanks
18:38:04 <shapr> glguy: Anyway, FLM will be useful for me, and hopefully useful for others as well, and it's a good chance to test out all the new HAppS changes too.
18:38:44 <glguy> is the happs rewrite public yet?
18:38:51 <shapr> It has some neat points. Since most research papers are for personal use only, I only record the annotations. The page images are generated by each user.
18:38:57 <shapr> Not yet, but it's very close to ready.
18:41:02 <glguy> who is doing the rewriting?
18:43:21 <alexj_> glguy, hopefully tomorrow if shae can prove that someone other than me can use the framework to write an app :-)
18:43:21 <alexj_> of which?
18:43:37 * shapr laughs
18:44:11 <glguy> what is the goal of the new code?
18:44:18 <glguy> what are you trying to make easier / better
18:45:03 <MarcWeber> Does anyone know a small ffi using library which already has a cabal file running with hugs?
18:45:31 <LoganCapaldo> ffi fie foe fum, I smell the blog of haskellman
18:50:35 <ddarius> MarcWeber: Read the documentation for Cabal.  It goes over some aspects of it.
18:55:02 <ddarius> Er, I just read something about that somewhere.
18:56:42 <ddarius> Ah, http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#system-dependent
18:56:44 <lambdabot> Title: 2. Creating a package, http://tinyurl.com/yv8xjt
18:58:01 <mudge> It seems to me that programming communities like Common Lisp and Haskell etc.  want their communities to get bigger, grow,   get more newbies,   I was wondering why?
18:58:29 <Eidolos> why we want our community to grow?
18:58:34 <Eidolos> to crush the heathen languages!
18:58:34 <mudge> yea
18:58:43 <mudge> that's a good point
18:59:04 <Eidolos> human nature I guess.. I want more friends
18:59:51 <kpreid> mudge: forall l. Language l => the more people use l, the less original l-users have to interact with software exposing interfaces in other languages / software without the benefits of l / ...
18:59:56 <chessguy> and because haskell's such a cool language. we want others to use it too
19:00:31 <Nafai> And the more people that use a given language the better chance the rest of us can find employment utilizing said language
19:00:39 <chessguy> and in the dream that maybe someday haskell-programming jobs will be less rare than...uh...something really rare
19:00:40 <Tac-Tics> chessguy: we *want* others to use it? Or demand it.....?
19:00:56 <mudge> yea, that makes sense,  I have an urge to pass on cool programming stuff and get other people to use stuff
19:01:18 <bitrot> I think the reason behind Haskellers wanting community growth is so they can stop explaining everything twice when talking to people.
19:01:27 <mudge> haha
19:01:31 <mudge> that'll be awhile
19:01:44 <LoganCapaldo> bitrot, but why do Haskellers want community growth?
19:01:53 <gigamonkey_> In some of the Monad examples in chapter 9 of YAHT, he evaluates a foldM expression which prints a bunch of stuff and then at the next prompt evaluates "it" and gets a value. What's that about?
19:01:55 <bitrot> ;)
19:02:36 <kpreid> gigamonkey_: ghci doesn't print the results of IO actions
19:02:43 <chessguy> @where yaht
19:02:43 <MarcWeber> mudge: Have you ever dreamed of running your own language? Why not? Because you would be busy writing the compiler for some time, then you'll be busy writing some basic libraries...  That's at least one point why I'd like to seee teh haskell commutunity gowing :_)
19:02:43 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
19:02:45 <kpreid> but it does assign them to "it"
19:02:56 <kpreid> that is, it's implicitly "it <- whatyoutyped"
19:03:16 <kpreid> except if you typed a non-IO-action it's implicitly "let it = whatyoutyped; print it"
19:03:43 <phr-zzz> it looks like there's more haskell jobs available than there are people to fill them
19:03:47 <shachaf> "x <- action" also assigns the value to "it".
19:03:50 <kpreid> Oh.
19:03:58 <mudge> phr-zzz: why do you say that?
19:04:00 <shachaf> No, wait.
19:04:05 * shachaf is wrong, never mind.
19:04:05 <wli> Yeah, but what qualifications are they asking for?
19:04:26 <chessguy> phr-zzz, huh?
19:04:35 <phr-zzz> i remember seeing an ad from galois connections that said basically "if you know haskell, get on a plane immediately, we want to hire you, and if you're not from the u.s. we'll put through visa paperwork"
19:04:45 <chessguy> uh
19:04:51 <Tac-Tics> phr-zzz: link plz
19:05:02 <chessguy> galois has pretty strict requirements on who they hire. you have to be very smart
19:05:12 <phobes> * five members of the channel quit to go buy plane tickets
19:05:13 <chessguy> @where galois
19:05:13 <lambdabot> I know nothing about galois.
19:05:27 <phr-zzz> yes, and i think right now all skilled haskell programmers are smart
19:05:37 <glguy> if you apply though that link, you'll probably get to meet me in an interview ;)
19:05:39 <chessguy> http://www.galois.com/job_SoftwareEngineer.php
19:05:41 <liyang> At least for the time being, knowing Haskell is a good enough filter as far as the HR process is concerned.
19:05:41 <lambdabot> Title: Software Engineer
19:05:44 <glguy> well, depending on who you are of course
19:06:03 * glguy has been on a couple of hiring committees lately
19:06:34 <mudge> how many people work at galois who are also on #haskell?
19:06:36 <Cale> hmm... maybe I should apply
19:06:45 <phr-zzz> typing "haskell" into google brings up a jane st capital sidebar ad--but they use ocaml ;)
19:06:57 <chessguy> glguy, are they hiring just for positions there in OR?
19:07:04 <mudge> why is the galois website built in PHP?
19:07:05 <glguy> chessguy: as far as I know
19:07:07 <Tac-Tics> what about noobie haskell programmers?
19:07:16 <Tac-Tics> will they consider the rest of us?
19:07:18 <chessguy> mudge, very good question
19:07:34 <chessguy> mudge, no doubt it's glguy's fault
19:07:37 <phr-zzz> linspire also has been using haskell and might be more receptive to newbies
19:07:56 <reltuk> I've experienced a weird phenomenon lately where I have trouble actually understanding why you would want transparent side-effects in a value-oriented/expression-oriented language
19:08:08 <phr-zzz> i don't see that galois ad any more, but it sounded practically desperate
19:08:11 <johnnowak> reltuk: hm?
19:08:21 <reltuk> I've started looking at ocaml as kind of strange
19:08:28 <mudge> glguy: why is the galois website built in PHP?
19:08:33 <kpreid> reltuk: well, consider hGetContents
19:08:41 <glguy> mudge: why not?
19:09:04 * chessguy snickers
19:09:07 <phr-zzz> yeah glguy, they should use this:  http://laconic.sourceforge.net/       ;-)
19:09:08 <lambdabot> Title: The Laconic programming language family
19:09:15 <SamB> mudge: you want them to use sometihng not yet invented?
19:09:21 <chessguy> PHP = Please Hack me, Please!
19:09:43 <phr-zzz> dependently typed web app programming
19:09:50 <mudge> glguy: well I guess it could make sense if you are a Haskell company to build a website in PHP if the focus of your company isn't making websites/web apps
19:10:08 <glguy> mudge: we didn't build our office building using haskell either :)
19:10:16 <phobes> So do Haskell jobs pay well?
19:10:22 <johnnowak> i'm not sure it ever makes sense to use php
19:10:23 <chessguy> haha
19:10:40 <olsner> aw, that's wonderful... I'm getting up in two hours or so, but still haven't gone to sleep
19:10:47 <chessguy> glguy, how's cost of living out there in OR anyway? i'd guess it's pretty expensive
19:10:51 <phr-zzz> glguy do you have to do a lot of .mil stuff at galois?
19:10:55 <johnnowak> reltuk: what's strange about ocaml?
19:11:44 <glguy> chessguy: the cost of living isn't so bad, I was in St. Louis, Mo. before this, and my bills are not noticably higher
19:12:33 <glguy> phr-zzz: Galois does a lot of government contract work, to be vague
19:12:41 <reltuk> johnnowak: the fact that IO expressions are typed like every other expression
19:13:01 <johnnowak> ah.
19:13:12 <chessguy> glguy, do they do AI stuff?
19:13:38 <glguy> chessguy: not that I can think of...
19:13:44 <Nafai> I do a lot of government contract work, but it's all Java :/
19:13:54 <phr-zzz> glguy, are security clearances needed?
19:14:02 <glguy> phr-zzz: no
19:14:22 <phr-zzz> thanx
19:15:04 <mudge> glguy: are you okay with me?   I didn't mean to be prying about the PHP stuff,    just was curious
19:15:21 <glguy> mudge: I didn't take offense to it :)
19:15:37 <dons> phobes: re. pay well -- if you can get one, they seem to pay very well
19:15:53 <glguy> mudge: I was just trying to relate that making business front pages isn't what Galois does
19:15:54 <mudge> glguy: cool
19:16:20 <mudge> glguy:  got ya,  makes sense
19:16:34 * glguy doesn't really know what other people at galois' salaries are
19:16:48 <mudge> dons: where do you work?
19:16:50 <reltuk> making webpages is what facebook does, and they do it with PHP :-p
19:17:01 <mudge> haha yea
19:17:07 <mudge> so much stuff on the web is PHP
19:17:18 <phr-zzz> laconic compiles into SML, i think ;)
19:17:21 <glguy> dons: yeah, where *do* you work?
19:17:25 <dons> looks interesting, http://seeker.dice.com/jobsearch/servlet/JobSearch?op=101&dockey=xml/b/5/b5323bcb1cafdd6ec77cc67405bcb839@endecaindex&c=1&source=20
19:17:28 <lambdabot> http://tinyurl.com/cza2x
19:17:29 <reltuk> isn't dons in school?
19:17:33 <dons> `Computer Assurance Engineer - Haskell/Java Developer'
19:17:39 <liyang> What gets me is that so many /static/ web pages are written in PHP.
19:17:49 <phr-zzz> 	
19:17:49 <phr-zzz> This job has been removed from our site.
19:17:58 <dons> the current jobs seem to be 'high assurance' or qant stuff
19:17:59 <dons> quant.
19:18:04 <dons> e.g. http://www.quantfinancejobs.com/jobdetails.asp?dbid=&guid=&JobID=2782
19:18:09 <lambdabot> Title: Quantitative Functional Programmer (VP-level) - NYC, http://tinyurl.com/386meh
19:18:12 <SamB> liyang: it is, as someone mentioned, somewhat reasonable for when you need a bit more than SSI
19:18:29 <glguy> liyang: that the pages are not interactive doesn't mean that their owners don't want to be able to update them easily
19:18:44 <dons> mudge: i'm in sydney, but starting a new haskell job in oregon.
19:18:45 <mudge> dons: I heard you've posted a lot of stuff to reddit programming
19:18:55 <dons> mudge: some things, yeah.
19:19:13 <glguy> dons: maybe I could hook you up with a job at Galois
19:19:16 <mudge> dons: that's cool,   through reddit is partially how I found out about haskell and got interested
19:19:20 <glguy> I'll put in a good word
19:19:22 <dons> glguy: that'd be great!
19:19:29 <dons> yeah, we should meet up sometime once i'm over there
19:19:30 <LoganCapaldo> dons is single handedly responsible for every haskell post on reddit
19:19:38 <LoganCapaldo> (I'm exaggerating :) )
19:20:00 <dolio> Yeah, it's only like 80%. :)
19:20:06 <reltuk> LoganCapaldo: it's probably safe to say he's largely responsible for the wave of haskell enthusiasm...
19:20:12 <reltuk> more people are posting haskell posts now =)
19:20:12 <liyang> glguy: I know, but PHP isn't the only way. And a pretty bad one at that.
19:20:13 <mudge> dons: can you say what,  and what company your new job is going to be with?
19:20:26 <phr> glguy, how much non-haskell stuff does galois do?  i.e. is there much interest there in fancier languages like coq?
19:20:27 <dons> there's 5-10 others who post FP stuff too
19:20:36 * wli is underqualified for any such thing.
19:20:38 <dons> mudge: i'm working for galois.com
19:20:41 <glguy> phr: I think they use more Isabelle than Coq
19:20:45 <liyang> (but hey, just throw in a bigger webserver and what's the diff?)
19:20:46 <phr> cool
19:21:13 <dons> yeah, it seems galois guys follow the german school of Isabelle :)
19:21:49 <mudge> dons:  oh cool
19:22:14 <phr> out of curiosity does galois have any particular cultural attitude towards the spark-ada crowd?
19:22:34 <mudge> there's fancier languages than haskell?
19:22:52 <dons> mudge: there's harder languages with stronger type systems - epigram, and the various theorem provers
19:23:02 <dons> they're seen as the ultimate limit of haskell's abilities
19:23:08 <SamB> dons: you're getting a job, you say?
19:23:14 <dons> SamB: seems so!
19:23:18 <SamB> nice
19:23:29 <dons> all that uni must have been for a reason
19:24:00 <glguy> phr: not that I know of
19:24:15 <liyang> dons: that reason being getting a tenure?
19:24:35 <glguy> phr: We aren't exclusively Haskell, there has been some Scheme, C, PHP, etc.
19:25:06 <dons> hey cool, bjorn runs darcs-graph in his google page, http://code.google.com/p/dimensional/
19:25:07 <lambdabot> Title: dimensional - Google Code
19:25:32 <phr> darcs-graph?
19:25:46 <glguy> the tool that shows how active the repository has been
19:26:12 <phr> oh that dimensional thing looks neat, it's all done at compile time with types?
19:26:14 <dons> http://programming.reddit.com/info/2gr8u/comments :)
19:26:15 <lambdabot> Title: Statically checked physical dimensions and SI units for Haskell (reddit.com)
19:26:20 <dons> phr: yeah, SI units in the type checker
19:27:58 <phr> what's he mean by "boxing and unboxing of numerical units as quantities"?
19:29:09 <phr> oh man this is kind of kludgey
19:29:36 * araujo thought dons would found a Functional Company with all that uni to offer relief to all those Haskell programmers employed by other languages
19:30:00 <dons> heh
19:30:05 <SamB> araujo: there's still time for that
19:30:12 <Olathe> phr: Well, inches is probably a number 2.54 times as large as centimeters.
19:31:12 <phr> i did something like this in python where the dimensions were all carried around at runtime
19:33:16 <phr> mudge, this is kind of neat: http://www.cs.berkeley.edu/~adamc/papers/PositionPLPV06/   about programming directly in coq. the guy wrote a compiler that way.
19:33:17 <dons> what happens in the case of unit conversion failure?
19:33:17 <lambdabot> Title: Position Paper: Thoughts on Programming with Proof Assistants
19:33:47 <phr> with my python thing?  runtime exception.
19:33:59 <phr> it was sort of inspired by the frink language
19:34:22 <phr> http://futureboy.homeip.net/frinkdocs/
19:34:24 <lambdabot> Title: Frink
19:35:36 <Eelis> a statically checked quantitative units C++ library was recently added to Boost
19:35:57 <phr> Since 1934, Haskellâs has been providing the finest in wines, beers and spirits to our discriminating clients. We appreciate your patronage and we will do ...
19:35:57 <phr> www.haskells.com/ - 41k - Cached - Similar pages
19:39:00 <araujo> Everything Haskell related is so addictive
19:39:10 <lament> especially heroin
19:39:59 <phr> dons you're involved in the realworldhaskellbook?  it looks way cool, much better than any of the existing haskell books i've looked at
19:40:57 <dolio> I'll say. That Richard Bird is a chump who can't write! :)
19:41:27 <phr> heh
19:41:38 <phobes> phr: have you looked at Haskell for dummies?
19:41:50 <SamB> phobes: what the heck?
19:41:53 <phr> phobes?!!!!  no i didn't know there was something like that.  you're joking i hope ?  :)
19:41:56 <dons> phr: that's the plan.
19:42:06 <phobes> yes, joking :)
19:42:07 <phr> i have "haskell school of expression" which is readable but doesn't have nearly enough detail
19:42:08 <dons> i think phobes is joking :)
19:42:19 <SamB> how about "learn haskell in 21 years"
19:42:36 <dons> 21 years seems too long
19:42:51 <SamB> yeah, I'm not even 21 yet
19:42:55 <phr> and i looked at "programming in haskell" in the store
19:43:50 <phr> more helpful has been the wikibook and various blog posts
19:44:01 <phr> but i still feel clueless
19:44:26 <fishkandy> OceanSpray!! lolz0r
19:44:30 <dolio> SamB: Obviously you don't know haskell, then. :)
19:44:36 <OceanSpray> wut
19:44:43 <dons> phr: i think you need to write some apps or libs to really learn the language
19:44:50 <dons> that's been my experience anyway
19:44:57 <dons> heya fishkandy
19:45:02 <fishkandy> moin dons
19:45:06 <pjd> write a Haskell implementation
19:45:08 <phr> dons yeah.
19:45:20 <olsner> whatever the language is, I've found you really have to do something real with it to learn it
19:45:23 <OceanSpray> kfish, is that you?
19:45:29 <fishkandy> OceanSpray, aye
19:45:38 <OceanSpray> oh ll
19:46:01 <pjd> worked for John Meacham
19:46:02 <phr> dons do you know xslt?  i have the idea of writing an xslt compiler in haskell
19:46:17 <phr> and am wondering if that's insane
19:46:35 <SamB> phr: what do you want that junk for
19:46:37 <SamB> you have Haskell
19:46:44 <dons> phr: that seems interesting.
19:46:49 <dons> phr, pretty sure people have thought about it
19:47:00 <dons> (i know of some work on fusion for xslt passes, for example)
19:47:08 <phr> hmm
19:47:10 <dons> you could make serious money out of it :)
19:47:33 <phr> heh, i signed an inventions assignment agreement with my employer saying everything i do is released under gpl :)
19:47:56 <dons> cool
19:48:02 <olsner> for an inventions assignment agreement, that's way cool
19:48:02 <ddarius> I wonder if that stops you from dual licensing it.
19:48:46 <phobes> heh, ya just don't tell anyone that it's GPL when you're selling it to them
19:49:14 <phr> phobes hehe yeah there's a ton of audacity cd's (audacity = gpl'd audio editor) on ebay that don't bother mentioning that little detail
19:50:35 <lament> i think that's how RMS originally planned to make money on GPLd software :)
19:52:25 <SamB> phr: GPL is the best you could get?
19:52:44 <phr> samb, it's part of the package
19:53:09 <SamB> are they just going to use the stuff you write, or sell it, or what?
19:53:26 <phr> we put it on the net
19:53:45 <phobes> do you work for a company that releases its own product under the GPL?
19:53:55 <phr> phobes yeah
19:54:21 <phobes> phr then that makes sense :)
19:55:19 <phr> i have umpty ump gigabytes of xml to crunch and i keep writing all these damn python scripts to do it, so i was thinking of trying to figure out xslt, but that's apparently even slower than python
19:55:27 <phr> so then i start wondering if i can compile xslt
19:55:54 <phr> do the obvious optimizations and then generate a state machine written in c and call the c compiler
19:57:16 <SamB> phr: this begs the question of why you'd want to write xslt in the first place
19:57:32 <SamB> it isn't known for it's elegance...
19:57:35 <phr> well i think it's designed for the sort of stuff i'm doing... though not necessarily WELL-designed...
19:57:41 <sjanssen> phr: I wonder if you can get better performance from one of the Haskell XML packages
19:57:44 <phr> i don't know mcuh about it really
19:57:47 <phr> much
19:57:57 <sjanssen> each of them have some xpath-like query interfaces
19:58:01 <SamB> have you seen any?
19:58:13 <phr> well as soon as i use a typical xml runtime package i've already lost horribly, because it's going to actually parse the xml into tree structure or something
19:58:18 <fishkandy> phr, http://www.ibm.com/developerworks/xml/library/x-matters14.html
19:58:20 <lambdabot> Title: XML Matters: Transcending the limits of DOM, SAX, and XSLT
19:58:29 <phr> instead of treating it as a big character stream that it occasionally sucks a field out of
19:58:43 <sjanssen> haxml has some lazy parsing stuff
19:59:27 <phr> fishkandy thanks, this looks cool
19:59:31 <Dybber> phr take a look at XQuery. Im not sure if there are any good interpreters, but its a lot cleaner than XSLT.
19:59:35 <phr> i didn't know david mertz was writing haskell stuff
20:00:09 <phr> XQuery 1.0: An XML Query Language
20:00:34 <bparkis> does haskell check to see that a function handles every kind of data that its type signature says it handles?
20:00:52 <phr> you mean check that pattern matching is exhaustive?  no
20:00:57 <phr> there's a package called catch which does that
20:00:59 <bparkis> could it in theory do that?
20:01:03 <bparkis> ok
20:01:12 <phr> i've been wondering whether there's a good reason it doesn't do that.  ML does it.
20:01:43 <reltuk> it does do it...
20:01:44 <dons> interesting link fishkandy
20:01:57 <sjanssen> bparkis: GHC can warn you when a function is potentially incomplete
20:02:39 <phr> oh cool, is there a flag you have to enable?  i get errors all the time from leaving out a case
20:03:08 <bparkis> why only "potentially"?  isn't it possible to do it exhaustively?
20:03:33 <sjanssen> bparkis: it's possible to have incomplete matches that are never reached
20:03:45 <Mortoc> anyone here use ghc on gentoo? I can't figure out what I'm supposed to do to get ghci working.
20:03:58 <phobes> I think the idea is that sometimes you have higher level understanding of the program and know the pattern match will not fail
20:04:03 <allbery_b> phr: -Wall for starters
20:04:13 <phr> thanks
20:04:19 <sjanssen> so GHC will warn you whenever a case statement is incomplete, but it might be impossible to reach these incomplete cases
20:04:45 <fishkandy> dons, phr: that developerworks article is a little out of date, there is a patch on the haxml page
20:04:54 <bparkis> but if you have an incomplete match that doesn't arise "in practice," then the function could be re-used and explicitly passed one of the cases it doesn't handle, by accident, in some other program
20:05:23 <bparkis> so even if it's good enough for the current program it can't be relied on perfectly
20:05:24 <kpreid> @. read run tail . concat . intersperse "i" . map (replicate 2) $ "mssp "
20:05:26 <lambdabot>  mississippi
20:05:59 <sjanssen> bparkis: GHC takes the conservative path and always warns
20:06:06 <dolio> See the Epigram mailing list archives for plenty of arguments about incomplete pattern matching on nevertheless total functions.
20:06:20 <SamB> bparkis: also GHC is broken
20:06:34 <dons> dolio: oh good idea. i should subscribe.
20:06:42 <SamB> bparkis: so sometimes it makes a mistake and you won't ever have a pattern match failure
20:06:51 <dolio> dons: There isn't much activity.
20:06:56 <SamB> (well, even if it wasn't broken it could still be wrong ;-)
20:07:13 <sjanssen> SamB: there are only a couple broken pieces
20:07:21 <phobes> @src tail
20:07:21 <lambdabot> tail (_:xs) = xs
20:07:21 <lambdabot> tail []     = undefined
20:07:25 <sjanssen> only k and n+k patterns, IIRC
20:07:36 <SamB> sjanssen: the piece that generates those warnings seems quite broken to me...
20:07:44 <SamB> or at least, from what I've heard it is...
20:07:56 <sjanssen> yes, just in a couple corner cases
20:07:59 <allbery_b> isn't the correct answer to n+k patterns to disallow them? :)
20:08:08 <SamB> allbery_b: sure
20:08:19 <dolio> I signed up on gmane via my newsreader, got lots of interesting stuff, and then it all disappeared when the reader cleaned out old threads.
20:08:42 <bparkis> why is full covering an undecidable problem?
20:09:00 <sjanssen> bparkis: it isn't, unless you include guards
20:09:19 <SamB> dolio: your newsreader sucks
20:09:34 <dolio> SamB: Probably.
20:10:24 <Eelis> i wish there was a nice Haskell IRC library
20:10:24 <dolio> But I think I got close to the entire history of the Epigram list in that initial download.
20:10:31 <SamB> bparkis: well, it may not even know that even = not . odd
20:11:14 <bparkis> ah I see
20:11:47 <bparkis> so you could reduce all numbers to just one base case, not covering the other base case
20:11:48 <sjanssen> foo p | programHalts p = ... -- :)
20:12:33 <phobes> @src programHalts
20:12:33 <lambdabot> Source not found. It can only be attributed to human error.
20:14:24 <bparkis> hm.
20:18:09 <pjd> phr: -fwarn-incomplete-patterns, specifically
20:18:33 <phr> thanks
20:18:40 <ihope> I want to be able to automatically generate an elegant data declaration for a monad given an intuitive definition of semantics.
20:19:13 * wli is back to square one on enumeration of lattice points.
20:19:13 <LoganCapaldo> I want a pony
20:19:19 <Eelis> isn't Control.Monad.Fix a rather odd place for fix?
20:19:19 <LoganCapaldo> :)
20:19:36 <LoganCapaldo> Eelis, I keep thinking that too
20:20:03 <sorear> Eelis: Yep, which is why it's in Data.Function too (base 2.1 only)
20:20:09 <lament> ihope: hey!
20:20:13 <Eelis> i see, interesting
20:21:02 <phr> :l ControlMonad.Pony
20:21:22 <ihope> @index fic
20:21:22 <lambdabot> bzzt
20:21:23 <ihope> @index fix
20:21:23 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
20:21:28 <ihope> Weird.
20:21:31 <bparkis> wait a minute, let's say that your function takes as input a certain number of algebraic data types, each of which has a countable number of constructors
20:21:54 <Cale> http://fridge.ubuntu.com/files/no-pony-for-you.jpg
20:22:09 <bparkis> why can't you simply enumerate every possible combination of constructors for input to the function, and see if it handles that combination?
20:22:25 <dons> bparkis: you could do that
20:22:31 <wli> ndm has done work here
20:22:36 <dons> bparkis: that would be an exaustive QuickCheck property
20:22:48 <bparkis> where does the uncomputable come in?
20:22:54 <wli> ISTR it was called "Catch"
20:22:55 <dons> :t enumFrom
20:22:57 <lambdabot> forall a. (Enum a) => a -> [a]
20:23:10 <wli> bparkis: Guards.
20:23:15 <dons> > enumFrom (minBound :: Ordering)
20:23:17 <lambdabot>  [LT,EQ,GT]
20:23:27 <sjanssen> bparkis: where did you get the impression that it's undecidable?  It isn't (except for boolean guards, which can contain arbitrary code)
20:23:37 <dons> ?check \x -> x `elem` (enumFrom (minBound :: Ordering))
20:23:39 <lambdabot>  OK, passed 500 tests.
20:23:48 <dons> ?scheck \x -> x `elem` (enumFrom (minBound :: Ordering))
20:23:49 <lambdabot>  add an instance declaration for (Serial Ordering)
20:23:49 <lambdabot>     In the expression: let...
20:24:16 <Tac-Tics> What does "denotational semantics" mean?
20:24:25 <Tac-Tics> I've never heard that word until I started Haskell
20:24:26 <sorear> bparkis: what you're describing is just a working version of -fwarn-incomplete-patterns, catch is a bit more powerful (it lets you have head, warnings are generated on *use*)
20:24:40 <sorear> bparkis: also, you can't enumerate a countable set in finite time
20:24:50 <bparkis> sjanssen: because Yong Luo said it is on the Epigram ml
20:25:09 <wli> I often work around Enum's limitations (largely on precision of integers) with a Denumerable class.
20:25:10 <dolio> bparkis: He's talking about dependently typed languages.
20:25:17 <OceanSpray> oh hey
20:25:18 <dolio> Haskell isn't dependently typed.
20:25:29 <conal> Tac-Tics: in DS, you give a mathematical model for the meanings of syntax.  and define a "meaning function" that maps syntax to those values.  the meaning of a phrase is a function of the meanings of the syntactic components.
20:26:04 <sorear> Tac-Tics: denotational semantics is a map between a programming laguage and a set of mathsy-objects, characterized by compositionality - you can replace any subterm of a program by a subterm with the same den. sem. without changing the den.sem. of the program
20:26:17 <newsham> shapr: see HAppS question on haskell-cafe?  maybe yoou could answer
20:26:51 <Tac-Tics> I'm guessing it's one of those things I've got a builtin understanding of, but I haven't formally learned about?
20:27:07 <sorear> Tac-Tics: Haskell's DS is particularly simple because the meaning of a term with type a -> b is simply a mathematical function [[a]] -> [[b]]
20:27:14 <sorear> Tac-Tics: quite probably
20:27:33 <phr> [[a]] ??
20:27:34 <kiome> Are there any knows issues with installing Visual Haskell on Vista with UC on?
20:27:36 <Tac-Tics> is it worth learning a little about the history of DS?
20:27:47 <sorear> [[ ]] is the standard symbol for the "meaning function"
20:27:48 <phr> tac-tics the wikibook is pretty good
20:27:52 <kiome> *known
20:27:54 <Tac-Tics> or is it something one can get by without rigorous understanding?
20:27:57 <Tac-Tics> phr: thanks
20:27:59 <phr> http://en.wikibooks.org/wiki/Haskell/Denotational_Semantics
20:28:32 <phr> oops  http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
20:30:20 <conal> DS-style thinking is also an approach to creating APIs.  I think about meanings of my data types and then the meanings of the library operations in terms of the meanings of the values.
20:33:31 <wli> Explaining the difference between a numeral and an integer helps some.
20:33:58 <conal> and between a lambda expression and a function
20:34:22 <wli> That can sometimes be "too big" to grasp.
20:34:43 <conal> wli: agreed.  start with numerals & numbers
20:35:33 <desp> hmm
20:35:53 <desp> is there some usual way to resolve "Functional dependencies conflict between instance declarations:"?
20:36:17 <Eelis> with the proposed natural number type for Haskell', will  let x = (x :: Nat) + 1 in 3 < x   evaluate to True?
20:36:27 <sjanssen> desp: not writing fundeps that conflict is a start :)
20:36:51 <desp> sjanssen: I know, but I need the fundep that causes the conflict to solve "Could not deduce..."
20:36:54 <desp> :)
20:37:28 <desp> I guess I probably could make yet another typeclass
20:37:46 <desp> I think I'm getting into microoleg territory
20:40:00 <newsham> (x,y) in f /\ (x,z) in f --> y = z
20:40:53 <Eelis> hm, is (<) strict on Integers ? i expected   let x = 1 + (x :: Integer) in 0 < x  to evaluate to True but it hangs
20:41:13 <Eelis> oh, never mind
20:41:24 <Eelis> Integers really are a different story than Nats
20:41:38 <Cale> @src Integer
20:41:38 <lambdabot> data Integer = S# Int#
20:41:38 <lambdabot>              | J# Int# ByteArray#
20:41:54 <reltuk> what's J#?
20:42:06 <Eelis> my other question about Nat i'm still very interested in though
20:42:09 <Cale> That's the case when the integer is larger than fits in an Int
20:42:32 <reltuk> ahhh, makes sense
20:43:01 <reltuk> @src ByteArray
20:43:02 <lambdabot> Source not found. You type like i drive.
20:43:13 <newsham> when integers have legs
20:43:15 <Cale> Eelis: If (1 +) is replaced with the constructor Succ, you can define (<) such that that will terminate
20:43:35 <Eelis> Cale: right, so my question is whether Haskell' will actually do it like that :)
20:43:44 <Cale> Probably.
20:43:56 <Eelis> good
20:43:57 <sjanssen> that scares me a little bit
20:44:19 <Cale> I don't really know, but it seems kind of pointless to provide a Nat type if it's not going to be lazy.
20:44:27 <conal> Eelis: is there a Nat library now that you're using?  i don't understand the connection with haskell'
20:44:37 <Eelis> conal: http://hackage.haskell.org/trac/haskell-prime/wiki/Natural
20:44:39 <lambdabot> Title: Natural - Haskell Prime - Trac
20:44:40 <sjanssen> I suspect that the O(n) memory use will cause lots of problems
20:44:41 <phr> why does darcs equality check use unsafeCoerce# ?
20:44:46 <Cale> I suppose you could implement it the same way as Integer and have it be strict
20:44:47 <conal> Eelis: thanks.
20:46:08 <Cale> Will there be a Nat type at all in Haskell'?
20:46:49 <newsham> peano not good enough for you?
20:47:01 <Eelis> Cale: it's listed as "probably yes"
20:47:14 <Cale> where?
20:47:18 <Eelis> http://hackage.haskell.org/trac/haskell-prime/report/9
20:47:20 <lambdabot> Title: {9} Proposals - Haskell Prime - Trac
20:49:38 <sorear> phr: because it's darcs, I'm sure
20:50:46 <Cale> There's a lot of pretty scary stuff under "maybe"
20:52:14 <Eelis> > let f x = x^2 - 6 in (f 3, fix f)
20:52:20 <lambdabot>  Exception: <<loop>>
20:53:11 <chessguy> > map (\n -> (n*n-n)/2) [1..10]
20:53:13 <lambdabot>  [0.0,1.0,3.0,6.0,10.0,15.0,21.0,28.0,36.0,45.0]
20:53:38 <ddarius> > scanl1 (+) [1..10]
20:53:40 <lambdabot>  [1,3,6,10,15,21,28,36,45,55]
20:53:57 <chessguy> err, what the...
20:54:12 <chessguy> oh, that's the sums of all the numbers to that point
20:54:14 <chessguy> nice
20:54:45 <chessguy> i knew that (n^2-n)/2 formula looked familiar
20:55:14 <chessguy> > scanl1 (+) [1..20]
20:55:15 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210]
20:55:52 <Cale> > map (\n -> (n*n-n) `div` 2) [1..10]
20:55:53 <lambdabot>  [0,1,3,6,10,15,21,28,36,45]
20:56:47 <chessguy> > 210 / 6
20:56:48 <lambdabot>  35.0
21:09:04 <Tac-Tics> > map return [1..4]
21:09:05 <lambdabot>   add an instance declaration for (Show (m a))
21:09:26 <Tac-Tics> > (map return [1..4]) :: [[Int]]
21:09:28 <lambdabot>  [[1],[2],[3],[4]]
21:09:47 <hpaste>  desp pasted "another typeclass question" at http://hpaste.org/2347
21:10:33 <chessguy> err, what kind of typeclass is that?
21:10:34 <Cale> desp: I don't understand the question
21:10:52 <desp> I'd like to have datatype Foo parametrized with variable a
21:11:08 <desp> er. scratch that.
21:11:15 <desp> I'd like to have datatype *Bar* parametrized with variable a
21:11:16 <chessguy> is that a GADT?
21:11:25 <Cale> chessguy: no
21:11:26 <desp> and also to restrict a in each constructor to a specific instance of Foo
21:11:35 <desp> is that possible?
21:11:37 <glguy> desp: no
21:11:54 <Cale> desp: Why would it not just be  Bar1 Baz1 ?
21:11:59 <glguy> desp: unless you just don't parameterize Bar
21:12:08 <desp> Cale: because then I can't parametrize Bar, no?
21:12:13 <Cale> You can parametrise Bar and not use the parameter
21:12:18 <desp> oh, hm.
21:12:35 <Cale> What's the point of having that type parameter if you're not actually allowed to use it?
21:13:40 <desp> in order to allow calling one typeclass function on every constructor parameter
21:14:26 <desp> Cale: do you understand what I mean? not sure if I'm speaking clearly enough :)
21:14:36 <Cale> I'm not sure -- perhaps it's a phantom type?
21:14:53 <Cale> Could you give an example?
21:15:19 <desp> one moment
21:19:31 <hpaste>  desp annotated "another typeclass question" with "actual example" at http://hpaste.org/2347#a1
21:19:57 <desp> now you can write  fromBar (Bar1 Baz1A)
21:20:11 <desp> but also you can write  fromBar (Bar1 Baz2A)
21:20:16 <desp> and I would like to disallow that
21:21:02 <Cale> Why bother with the type parameter at all?
21:21:56 <desp> hm, you're right.
21:22:01 <hpaste>  Cale annotated "another typeclass question" with "why not this?" at http://hpaste.org/2347#a2
21:22:12 <desp> I assumed I'd need the (Enum a) constraint in fromBar
21:22:26 <desp> my bad, thanks
21:24:09 <ihope> What's a nice, elegant implementation of delimited continuations?
21:24:48 * oerjan assumes oleg's is
21:24:49 <hpaste>  dolio annotated "another typeclass question" with "gadts" at http://hpaste.org/2347#a3
21:25:04 <oerjan> @where oleg
21:25:05 <lambdabot> http://okmij.org/ftp/
21:25:35 <dolio> @hackage CC-delcont
21:25:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CC-delcont
21:25:37 <oerjan> hm, actually didn't someone else make the module based on his work?
21:26:07 <dolio> Roughly the same as the stuff you'll find at Oleg's page.
21:28:06 <desp> Cale: ah, I know why I thought that way -- I was trying to write   fromBar :: (Enum a) => Bar -> a
21:29:10 <desp> which doesn't appear to be possible
21:29:38 <sjanssen> @type fromEnum . toEnum
21:29:40 <lambdabot>     Ambiguous type variable `b' in the constraint:
21:29:40 <lambdabot>       `Enum b' arising from use of `fromEnum' at <interactive>:1:0-7
21:29:50 <sjanssen> @type toEnum . fromEnum
21:29:52 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
21:30:00 <sjanssen> possible, but perhaps not reasonable
21:30:49 <hpaste>  desp annotated "another typeclass question" with "possible?" at http://hpaste.org/2347#a4
21:31:20 <desp> oh, so you're saying instead of x, toEnum $ fromEnum x?
21:31:46 <newsham> ?src (<|>)
21:31:46 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:32:00 <desp> heh.
21:32:05 <sjanssen> desp: that gives you the right type, but I doubt it's what you mean
21:32:21 <desp> sjanssen: well, it seems rather inefficient
21:32:35 <sjanssen> toEnum . fromEnum is pretty fast
21:33:24 <desp> dolio: hm
21:33:38 <dolio> '(Enum a) => Bar -> a' means you need to be able to produce any kind of Enum from a Bar.
21:33:52 <desp> right, I see where this fails
21:33:58 <desp> thanks again, all
21:35:58 <mudge> @help
21:35:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:36:05 <mudge> @list
21:36:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:36:46 <mudge> @babel
21:36:46 <lambdabot>   bzzt.
21:37:05 <mudge> @bf
21:37:05 <lambdabot> Done.
21:37:21 <desp> heh.
21:37:41 <mudge> heh
21:37:48 <mudge> @haddock
21:37:48 <lambdabot> Unknown command, try @list
21:37:51 <ddarius> @bf +.
21:37:51 <lambdabot>  fd:23: hClose: resource vanished (Broken pipe)
21:37:57 <mudge> what is bf?
21:38:01 <mudge> @list
21:38:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:38:02 <ddarius> @help bf
21:38:02 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
21:38:11 <mudge> oh
21:38:37 <mudge> how do i get it to say funny things?
21:38:41 <gmh33> @bf +.[+.]
21:38:41 <lambdabot>  fd:23: hClose: resource vanished (Broken pipe)
21:38:45 <gmh33> aww
21:38:51 <desp> @bf http://desp.night.pl/algorytmy/p0/z4.bf
21:38:52 <lambdabot>  fd:23: hClose: resource vanished (Broken pipe)
21:39:00 <lambdabot> You could always try just asking.
21:39:19 <desp> @please execute said bf file
21:39:19 <lambdabot> Not enough privileges
21:39:37 <mudge> @slap
21:39:37 * lambdabot beats up
21:39:41 <gmh33> lol
21:39:46 <mudge> @slap gmh33
21:39:46 * lambdabot beats up gmh33
21:39:52 <gmh33> @slap mudge
21:39:53 * lambdabot beats up mudge
21:39:53 <wli> I ultimately want to trace approximate level curves the way djb describes but that's a serious rewrite.
21:40:18 <gmh33> bf is a curious language
21:40:46 <wli> A dull language if you ask me, but anyway.
21:40:57 <desp> (that program reads two numbers in decimal from stdin and outputs the sum to stdout)
21:40:57 <mudge> @todo
21:40:57 <lambdabot> 0. SamB: A way to get multiple results from a google search
21:40:57 <lambdabot> 1. dons: improve formatting of @dict
21:40:57 <lambdabot> 2. dons: write Haskell Manifesto
21:40:57 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
21:40:57 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
21:40:59 <lambdabot> [26 @more lines]
21:41:27 <mudge> @more lines
21:41:27 <lambdabot> 5. TheHunter: @type 1 :: Int
21:41:27 <lambdabot> 6. lispy: haddock gives a link from a type signature to the types.  It would be nice if it also let you find functions in the given module that use a type.
21:41:27 <lambdabot> 7. dons: Implement @whatis
21:41:27 <lambdabot> 8. dcoutts: implement @cool list, as a clone of the @todo(-add) commands
21:41:27 <lambdabot> 9. dons: there's some bug in the 'when i left' code of @seen
21:41:29 <lambdabot> [21 @more lines]
21:41:52 <mudge> @more lines
21:41:53 <lambdabot> 10. dons: sarahbot style @tell
21:41:53 <lambdabot> 11. beelsebob_: @tell command - relays a message to someone when they next speak
21:41:53 <lambdabot> 12. dons: @seen on lambdabot should report lambdabot's channels too
21:41:53 <lambdabot> 13. ski: when printing first lines of infinite things (or all cases with nonexact), should say 'at least'
21:41:53 <lambdabot> 14. ski: provide '@more <number>', at least for privmsg
21:41:55 <lambdabot> [16 @more lines]
21:42:06 <dolio> Is this really something everyone needs to see? :)
21:42:22 <mudge> lol
21:42:25 <mudge> @tell
21:42:25 <lambdabot> Plugin `tell' failed with: IRCRaised Prelude.head: empty list
21:42:42 <mudge> @fortune
21:42:43 <lambdabot> "I have recently been examining all the known superstitions of the world,
21:42:43 <lambdabot>  and do not find in our particular superstition (Christianity) one redeeming
21:42:43 <lambdabot>  feature.  They are all alike founded on fables and mythology."
21:42:43 <lambdabot> 		-- Thomas Jefferson
21:43:07 <mudge> @fortune
21:43:08 <lambdabot> Q:	How many gradual (sorry, that's supposed to be "graduate") students
21:43:08 <lambdabot> 	does it take to screw in a light bulb?
21:43:08 <lambdabot> A:	"I'm afraid we don't know, but make my stipend tax-free, give my
21:43:08 <lambdabot> 	advisor a $30,000 grant of the taxpayer's money, and I'm sure he
21:43:08 <lambdabot> 	can tell me how to do the gruntwork for him so he can take the
21:43:10 <lambdabot> 	credit for answering this incredibly vital question."
21:43:10 <desp> mudge: you know you can play with lambdabot in a /query window?
21:43:36 <mudge> oh?
21:43:46 <mudge> what's a query window?
21:43:56 <ihope> /query lambdabot
21:43:59 <desp> in private.
21:44:14 <mudge> oh, rad
21:44:27 <mudge> you guys didn't want to keep seeing the lambdabot stuff?
21:44:39 <mudge> i was making a little show for ya
21:44:44 <gmh33> mudge: most of the time it's just channel noise
21:44:46 <ihope> Hmm, Haskell Manifesto?
21:44:50 <mudge> okay
21:44:52 <oerjan> aren't a lot of those @todo's already implemented?
21:46:21 <bos> BWT functional pearl on reddit: http://programming.reddit.com/info/2gs4q/comments
21:46:22 <lambdabot> Title: Inverting the Burrows-Wheeler Transform (PDF) (reddit.com)
21:46:33 <mudge> hey, wouldn't it be cool if there was a bot written that taught people Haskell?
21:46:46 <mudge> then we could send newbies there
21:47:50 <dons> yeah, its a cool idea.
21:47:50 <dons> we used lambdabot for a pro
21:47:55 <dons> totype of this idea a while ago
21:48:07 <dons> you ask questions, and they have to give answers to lambdabot
21:48:12 <dons> which then tells you if you got it right
21:48:45 <mudge> cool
21:48:49 <gmh33> but dons tends to be super helpful anyway :P
21:49:19 <phr> there was a big usenet war about that BWT thing and how it's 100x slower than the bzip2 c implementation
21:49:46 <bos> phr: oh?
21:49:46 <phr> ah, not that same paper
21:50:56 <bos> i have a nice suffix tree implementation cooked up that runs in O(n log(n)) time.
21:50:59 <mudge> dons: so what has happened with the prototype?
21:52:16 <Pseudonym> bos: Hackage!
21:52:24 <Pseudonym> People keep asking for suffix trees.
21:52:38 <bos> for better or worse, it takes about 2 minutes to construct a suffix tree on my laptop for a half-megabyte input file with 930,000 edges.
21:52:42 <mudge> I like this one @faq
21:52:45 <mudge> @faq
21:52:46 <lambdabot> The answer is: Yes! Haskell can do that.
21:53:04 <Pseudonym> ?faq Can I convert an IO String to a String?
21:53:04 <lambdabot> The answer is: Yes! Haskell can do that.
21:53:07 <Pseudonym> Cool!
21:53:10 <bos> Pseudonym: yeah, that's the plan.
21:53:16 <ddarius> unsafePerformIO!
21:53:38 <nornagon> Can I convert an IO String to a String?
21:53:40 <bos> ?faq can i have a pure language, IO, and a pony?
21:53:40 <lambdabot> The answer is: Yes! Haskell can do that.
21:53:46 <nornagon> Aw, lambdabot doesn't respond.
21:54:11 <olsner> 930k edges in 512k of input? that's like half a byte per "edge", whatever that may be in this context
21:54:11 <mudge> you have to say the right thing to it
21:54:51 <mrd> ?faq Can haskell prove P=NP?
21:54:51 <lambdabot> The answer is: Yes! Haskell can do that.
21:55:04 <mrd> an oracle!
21:55:04 <Pseudonym> ?faq Can Haskell prove the halting problem?
21:55:05 <lambdabot> The answer is: Yes! Haskell can do that.
21:55:08 <olsner> ?faq Can haskell solve the halting problem?
21:55:08 <lambdabot> The answer is: Yes! Haskell can do that.
21:55:10 <bos> i'd love to have a linear-time construction algorithm, but don't see how to do that without doing the whole thing in the IO monad.
21:55:16 <olsner> Pseudonym: argh, you beat me to it!
21:55:22 <bos> or the ST monad, which isn't any better.
21:55:24 <Pseudonym> bos: Have you seen the suffix array review paper?
21:55:41 <bos> Pseudonym: i've read a big pile of literature, yes.
21:55:50 * Pseudonym nods
21:56:26 <bos> my code is based on giegerich and kurtz's, but scales better on a large input alphabet (e.g. Char).
21:56:40 <Tac-Tics> @src mzero
21:56:40 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:56:52 <Tac-Tics> @src guard
21:56:53 <lambdabot> guard True  =  return ()
21:56:53 <lambdabot> guard False =  mzero
21:57:03 <olsner> @src Maybe mzero
21:57:03 <lambdabot> mzero = Nothing
21:58:41 <bos> an O(n log n) algorithm looks great until n gets big. sigh.
21:59:13 <Tac-Tics> there are worse algorithms in life
21:59:36 <samreid> A lot of O(n) algorithms are really O(n log n) algorithms anyway.
22:00:05 <phr> with the log n part implemented in constant time by the hardware as long as log n <= 64 ;)
22:00:30 <oerjan> @src MonadPlus
22:00:30 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:00:51 <Pseudonym> A lot of O(n log n) algorithms are really O(n log n log log n).
22:01:17 <Pseudonym> Most sort algorithms on arbitrary length keys, for example.
22:01:47 <littledan> where does the log log n come from there?
22:02:08 <oerjan> Tac-Tics: mzero is a MonadPlus method
22:02:14 <Tac-Tics> I know
22:02:14 <Pseudonym> Well, let's take, for example, the cost of sorting 32-bit words.
22:02:20 <Tac-Tics> I'm trying to figure out how guard works
22:02:23 <Tac-Tics> because I know it does
22:02:26 <Pseudonym> Or, say, b bit words.
22:02:27 <Tac-Tics> but it is confusing me here
22:02:33 <Pseudonym> It takes O(b) time to do the comparison.
22:02:43 <Tac-Tics> > let f x = guard (x == 0) >>= (\_ -> [x])
22:02:44 <lambdabot>  Parse error
22:02:52 <Tac-Tics> oops
22:02:55 <Tac-Tics> @ let f x = guard (x == 0) >>= (\_ -> [x])
22:03:01 <Tac-Tics> @let f x = guard (x == 0) >>= (\_ -> [x])
22:03:03 <Tac-Tics> stupid bot
22:03:06 <lambdabot> Defined.
22:03:10 <Tac-Tics> > f 0
22:03:11 <lambdabot>  [0]
22:03:14 <Tac-Tics> > f 1
22:03:16 <lambdabot>  []
22:03:19 <Pseudonym> So on a b-bit architecture, you can sort at most 2^b numbers.
22:03:29 <mudge> do you guys put spaces in your haskell code,  like:    5 + 4  or do you do:  5+4
22:03:35 <dolio> @src Maybe (>>=)
22:03:35 <lambdabot> (Just x) >>= k      = k x
22:03:35 <lambdabot> Nothing  >>= _      = Nothing
22:03:43 <mudge> do you do:  a/x  or a / x
22:03:46 <Pseudonym> The time taken, then, will be O(2^b b log(b)).
22:03:48 <Pseudonym> Erm.
22:03:54 <Pseudonym> Habg on, gotta think about that.
22:03:55 <olsner> what's described as O(nlogn) is often O(nlogn) *comparisons* and/or swaps rather than O(f) *time*
22:03:59 <samreid> Pseudonym: wait, what?  On random inputs compariing b bits it takes O(1) average time since it's exponential decay
22:04:01 <Pseudonym> I'm not sure if it's log log n.
22:04:07 <Pseudonym> olsner: Right.
22:04:10 <Tac-Tics> @src List >>=
22:04:10 <lambdabot> Source not found. I feel much better now.
22:04:14 <ddarius> @let f x = guard (x==0) >> return x
22:04:15 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
22:04:16 <olsner> it's just that people don't know what they're saying
22:04:20 <ddarius> @undefine
22:04:21 <Pseudonym> And that's actually critical if comparisons are expensive.
22:04:22 <lambdabot> Undefined.
22:04:25 <Tac-Tics> @src List (>>=)
22:04:25 <lambdabot> Source not found. You type like i drive.
22:04:32 <littledan> Pseudonym: sounds like O(n log^2 n)
22:04:34 <Pseudonym> Such problems often show up more in arithmetic on large integers.
22:04:43 <olsner> what's log^2?
22:04:45 <Pseudonym> Where integer operations are most definitely not O(1).
22:04:55 <littledan> err, (log n)^2
22:05:00 <olsner> ah, ok
22:05:06 <littledan> (my notation, sorry)
22:05:07 <Pseudonym> @let bp [] = 1
22:05:09 <lambdabot> Defined.
22:05:12 <Pseudonym> @let bp [x] = x
22:05:14 <lambdabot> Defined.
22:05:19 <Pseudonym> @let bp xs = bp (bp' xs)
22:05:20 <lambdabot> <local>:3:12: Not in scope: `bp''
22:05:21 <Tac-Tics> ah, my confusing is coming from >>= on lists, I think
22:05:25 <Pseudonym> Crap.
22:05:29 <Pseudonym> Should have defined bp' first.
22:05:34 <Pseudonym> Let's try that again.
22:05:52 <Pseudonym> @let bprod' (x1:x2:xs) = x1*x2 : bprod' xs
22:05:54 <lambdabot> Defined.
22:06:03 <Pseudonym> @let bprod' xs = xs
22:06:04 <lambdabot> Defined.
22:06:07 <Pseudonym> @let bprod [] = 1
22:06:10 <lambdabot> Defined.
22:06:10 <Pseudonym> @let bprod [x] = x
22:06:13 <lambdabot> Defined.
22:06:19 <Pseudonym> @let bprod xs = bprod (bprod' xs)
22:06:21 <lambdabot> Defined.
22:06:23 <Pseudonym> OK, now.
22:06:28 <Pseudonym> > product [1..100000]
22:06:32 <lambdabot> Terminated
22:06:37 <Pseudonym> > bprod [1..100000]
22:06:39 <lambdabot>  2824229407960347874293421578024535518477494926091224850578918086542977950901...
22:06:52 <Pseudonym> Same number of multiplies.
22:07:12 <Pseudonym> But in the bprod version, the cost of each multiply is much less.
22:07:39 <olsner> cool
22:08:10 <olsner> a nice example of how arithmetic is not O(1)
22:08:15 <Pseudonym> Yeah.
22:09:01 <ddarius> No one pretends that for arbitrary precision integer arithmetic.
22:10:12 <samreid> No one you know :-\
22:10:25 * gmh33 laughs
22:11:17 * bos needs to write an emacs macro to insert SCC annotations into code
22:12:43 <olsner> what're SCC annotations?
22:13:04 <bos> used for profiling the insides of functions.
22:13:39 <wli> I need to figure out some level curve tracing scheme analogous to the one djb brewed up.
22:13:42 <bos> stick an annotation inside the body of a function, and GHC's runtime will account for it separately from the top-level form it's found in
22:14:16 <phr> anyone read this?  is it good?  http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
22:14:18 <lambdabot> Title: Type Theory and Functional Programming
22:14:45 <desp> Pseudonym: why is bprod better than foldl' (*) 1?
22:15:49 <oerjan> desp: because it avoids multiplying large numbers by small ones a lot of times
22:16:10 <oerjan> instead keeping the numbers more evenly matched
22:16:25 <desp> oerjan: ah.
22:16:51 <desp> that's quite a neat trick.
22:17:58 <Tac-Tics> Why did haskell decide that !! and ! where two different operators?
22:18:17 <ddarius> Because they are.
22:18:18 <Pseudonym> That was settled on before type classes or modules.
22:18:25 <bparkis> why not have a bounds-checked "mutable array monad" that could be generated without an IO monad, allowing for destructive bounds-checked access to arrays
22:18:25 <Pseudonym> !! is from Miranda, at least.
22:18:47 <Pseudonym> BTW, ! is actually many different operators.
22:18:55 <sjanssen> bparkis: we have such a monad, look for the ST monad
22:18:56 <Tac-Tics> is it?
22:18:59 <Pseudonym> The Data.Map one doesn't resemble the Array one that closely.
22:19:29 <oerjan> :t (Data.Map.!)
22:19:31 <lambdabot> forall k a. (Ord k) => Data.Map.Map k a -> k -> a
22:19:49 <Pseudonym> :t (Data.Array.!)
22:19:51 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
22:19:55 <oerjan> right, it doesn't have an integral argument necessarily
22:20:14 <Pseudonym> Moreover, Data.Map is supposed to be imported qualified.
22:20:18 <Tac-Tics> wow, I didn't even realize Map had !
22:20:22 <Tac-Tics> I've been using lookup
22:20:23 <oerjan> er, Array doesn't either
22:20:25 <Pseudonym> Because it defines things like "map" that step on the Prelude.
22:20:34 <Pseudonym> So in fact, you call it:
22:20:39 <Pseudonym> import qualified Data.Map as M
22:20:42 <Pseudonym> m M.! k
22:20:49 <Pseudonym> So it's actually pretty useless.
22:21:57 <Tac-Tics> Haskell has some ugliness when it comes to its module system from what I've seen
22:22:05 <Heffalump> is there a recommended regexp library these days?
22:22:21 <bparkis> ok ty sjanssen
22:22:28 <bos> regex-tdfa
22:22:42 <phr> is there a way to get compiler warnings when you import something that steps on an existing symbol?
22:22:57 <bparkis> but what is a state thread?
22:23:26 <bos> phr: you'll get errors
22:23:41 <bos> not when you import it, but if you try to use something ambiguous
22:24:11 <Heffalump> bos: ta
22:24:52 <littledan> is it ever appropriate to use foldl rather than foldl'?
22:24:55 <phr> hmm yeah i've gotten those errors but it was almost like getting them at runtime
22:24:56 <bparkis> ah nm I guess I'll find it out sometime
22:25:03 <bos> littledan: almost never
22:25:04 <phr> i.e. why didn't it flag this earlier??
22:25:14 <littledan> bos, then why does it exist?
22:25:35 <bos> littledan: it arguably should live in greater obscurity
22:25:56 <shapr> Hm: ./SudokuWss  4.73s user 0.05s system 99% cpu 4.804 total ./SudokuWss +RTS -N2  3.80s user 0.07s system 116% cpu 3.334 total
22:26:31 <sjanssen> that's not too bad
22:26:36 <shapr> Yeah, it gets some benefit.
22:26:37 <wli> shapr: Threaded sudoku solver?
22:26:47 <shapr> wli: Yup, written by swiert
22:26:55 <shapr> http://www.haskell.org/sitewiki/images/1/12/SudokuWss.hs
22:27:48 <shapr> wli: Actually, it's not threaded. It's purely STM.
22:28:01 <Heffalump> how is that not threaded?
22:28:05 <wli> shapr: Well, implicitly threaded, then.
22:28:10 <sjanssen> shapr: threading and STM are not mutually exclusive
22:28:11 <shapr> Yeah, implicitly threaded.
22:28:11 <Heffalump> you wouldn't get any benefit from STM without threading, surely?
22:28:13 <glguy> STM doesn't do implicit threading...
22:28:16 <sjanssen> it is explicitly threaded
22:28:18 <sjanssen> grep for forkIO
22:28:23 <shapr> oh, so it is.
22:28:26 <wli> Oh, never mind, then.
22:28:38 <wli> You used -N2 so I presumed threading of some sort.
22:29:40 <taruti> Is it possible to somehow define an instance like: "instance (forall t. Show (c t)) => Show (A c) where ..." ?
22:31:18 <Heffalump> taruti: you can define a new class for A to be in, and then make the forall t . Show (c t) condition be part of the context of one of the class methods; but making the Show instance would require overlapping instances
22:31:56 <taruti> Heffalump: that is not a problem since that already requires undecidable instances.
22:32:59 <Heffalump> the other problem is that you could only have one such Show instance
22:33:10 <dons> its full of forkIOs + STM. that's explicit, high level threading :)
22:33:23 <Heffalump> I've never actually tried this - I needed it myself for something but decided it was too painful
22:33:26 <dons> there are likely published parallel solving algos though?
22:34:20 <Pseudonym> There are published parallel algorithms for exact cover problems.
22:34:40 <Pseudonym> This is the most abusing:
22:34:41 <Pseudonym> amusing
22:34:45 <Pseudonym> And abusing, for that matter.
22:34:47 <Pseudonym> http://trefoil.math.ucdavis.edu/0708.1962
22:34:49 <lambdabot> Title: Front: [arXiv:0708.1962] Exact Cover with light
22:35:04 <dons> yeah, so I suspect we could do better here :) And did anyone see harrop's little ocaml troll on the sudoku thread?
22:35:19 <taruti> Heffalump: seems like getting automatic instances for the helper class would not work. (class Show2 c where show2 :: c t -> String; instance (Show ???) => Show2 c where show2 = show" Just seems to move the problem around.
22:36:14 <wli> Sudoku is an exact cover problem?
22:36:26 <Heffalump> no, class show2 a where show2 :: (forall t . Show (c t)) => a c -> String
22:36:36 <Pseudonym> wli: You can reduce it to one.
22:36:37 <sjanssen> dons: yeah, he seemingly didn't realize that swiert's solution was parallel
22:37:16 <Heffalump> actually, I don't think you can make a Show instance at all from it, though. You're stuck with show2
22:37:41 <Heffalump> got to go
22:38:22 <phr> so does anyone know if these theorem proving languages (that can only express terminating computations) also allow proving anything about running time or space?
22:38:24 <taruti> hmm, GHC does not want to admit that either (malformed class instance). I'll try to find an another way.
22:38:34 <oerjan> can you have a context of the form forall t . ... at all?
22:38:37 <Heffalump> I missed a capital letter in the show2
22:38:42 <dolio> I don't see anything about his OCaml version that's OCaml specific.
22:38:49 <Heffalump> <gone>
22:39:21 <sjanssen> dolio: yeah, the Haskell will look the same
22:39:32 <sjanssen> minus the ugly bits of OCaml's syntax :)
22:39:41 <dolio> Right. :)
22:40:16 * sjanssen does the slavish porting
22:40:27 <sjanssen> a bit hard, because I don't know ocaml
22:40:55 <dansa> From Hudak's book. Exercise 2.4. Define a function convex :: Shape -> Bool that determines whether or not its argument is a convex shape (although we are mainly interested in the convexity of polygons, you might as well define it for each kind of shape.) Question: what shape that can be convex or not is not a polygon?
22:40:55 <dansa>  
22:41:20 <phr> curve?
22:41:29 <oerjan> circles, ellipses
22:41:40 <dansa> are they convex or concave?
22:41:42 <Pseudonym> They can't be non-convex.
22:41:51 <oerjan> cardiac curves
22:41:54 <phr> well something like an annulus is non-convex
22:41:58 <dolio> I also don't see where 'n' comes from in his 'invalid' function.
22:41:59 <Pseudonym> Yeah.
22:42:00 <Pseudonym> Cycloids.
22:42:05 <phr> or for that matter a polygon with a polygonal hole in it
22:42:51 <oerjan> i suppose this might depend on the Shape type in the book
22:43:15 <dansa> look at wikipedia's definition: http://en.wikipedia.org/wiki/Polygon
22:43:23 <lambdabot> Title: Polygon - Wikipedia, the free encyclopedia
22:43:33 <dansa> a polygon with a polygonal hole in it doesnt seem to fit
22:43:41 <phr> well it's a shape but not a polygon
22:44:24 <dansa> but what's the definition of convex for a general shape?
22:44:43 <phr> given points p,q in the interior of the shape, the line segment connecting p to q is entirely inside the shape
22:45:06 <phr> so if there's a hole i guess it's never convex
22:45:07 <dansa> but that sounds like that the shape is a polygon
22:45:16 <phr> nah, a disc is convex
22:45:26 <dansa> yeah
22:45:33 <dansa> alright
22:45:55 <dansa> so i guess he means just that: write a function that tells whether ``<phr> given points p,q in the interior of the shape, the line segment
22:45:56 <dansa>   connecting p to q is entirely inside the shape'' is satisfied
22:46:42 <sorear> phr: Yes they do, but not reflectively.
22:46:54 <phr> ?
22:47:31 <sorear> phr: Given mergeSort : forall A (l: list A), { l'
22:47:56 <sorear>  : list A | perm_eq l l' & sorted l' }  -  you can't prove anything about time.
22:48:15 <sorear> phr: but if you have a term in some object language with an operational semantics, then sure
22:48:43 <phr> oh sorear i wasn't sure what you were answering.  thanks
22:50:23 <phr> here's one.  you can pretty easily write a type for even natural numbers and prove that it's inhabited (4 is even).  similarly for odd numbers.  you can also write a type for weird numbers (= numbers that are simultaneously even and odd).  i can't think of any examples of weird numbers, so after a while i start to think that type is uninhabited.  is there a way to express that and maybe even prove it?
22:50:25 <sjanssen> hmm, is ocaml's 'iter' like foldl?
22:51:03 <sjanssen> erm, or is it an imperative construct?
22:51:39 <SamB> how about numbers that aren't even or odd?
22:51:41 <sorear> foldl is an imperative construct in those languages
22:51:51 <sjanssen> true
22:51:59 <sjanssen> val iter : f:('a -> unit) -> 'a list -> unit
22:52:20 <sjanssen> I imagine that unit is like () -- that only seems useful in an imperative context
22:52:35 <sorear> phr: sure, (in cic syntax) not (exists x, even x /\ odd x)
22:52:43 <phr> and when asking about complexity, i guess i was thinking of two somewhat orthogonal things; 1) just trying to establish some reasonable bounds on the running time of some straightforward algorithm; 2) being able to express that some function is intractable.  e.g. that it reduces to SAT where SAT is assumed intractable
22:52:52 <dolio> Looks like mapM.
22:53:00 <SamB> funny.
22:53:03 <dolio> Er, mapM_
22:53:09 <phr> hmm how would i prove that  not (exists x, even x /\ odd x) ?
22:53:12 <SamB> I got an 800 in math on my SAT
22:53:22 <phr> congrats
22:53:46 * SamB finally goes to bed...
22:53:57 <Pseudonym> I never did a SAT.
22:54:03 * SamB wonders if anyone got the horrible joke
22:54:28 <phr> this thompson book looks pretty good but it's from way before coq
22:55:03 <wli> I'll just say that I've got little reason to be impressed with other people's SAT scores.
22:55:47 * dolio has flashbacks to freshman orientation.
22:55:58 <SamB> it was just a pun on "SAT is assumed intractable" anyway...
22:56:11 <phr> ohhhhhh  that went whoosh past me  heh
22:56:47 <SamB> very bad puns run in my family
22:57:03 <Adamant> SAT Assumed Tractable
22:57:16 <dolio> You mean puns?
22:57:45 <SamB> dolio: you believe all puns to be very bad?
22:58:05 <dolio> I guess some might be merely 'bad'. :)
23:01:05 <wli> phr: Which Thompson book?
23:01:23 <phr> wli - type theory and functional programming
23:02:10 <SamB> dolio: yes but we specialize in very very bad ones...
23:02:26 <dolio> Well done. :)
23:05:35 <phr> why do these type theorists do all their proofs in this handwavey natural deduction logic instead of writing down a formal logic explicitly?
23:06:08 <wli> phr: It's not handwavy.
23:07:21 <phr> well, it's not precise enough to be able to compute the godel numbers of the proofs interoperably :)
23:08:24 <phr> i'm also trying to read harper's book on foundations of programming languages, and he starts right out saying that he's purposely keeping the logic sort of vague
23:09:14 <hpaste>  sjanssen pasted "OCaml sudoku" at http://hpaste.org/2348
23:09:19 <phr> i guess it's ok for practical purposes, it's just not what i'm used to from math class
23:09:32 <hpaste>  sjanssen annotated "OCaml sudoku" with "prettier Haskell" at http://hpaste.org/2348#a1
23:09:35 <wli> phr: That seems rare to me.
23:09:46 <sjanssen> the OCaml was pretty ugly
23:10:16 <wli> sjanssen: That's really short. I'd have thought sudoku would be more involved.
23:10:20 <sjanssen> the 'solve' procedure was parametric on a function called on each solution found
23:11:22 <sjanssen> the program iterated (like mapM_) when there were multiple paths available
23:11:24 <phr> nice
23:11:28 <phr> i don't see the ocaml version
23:11:50 <steven_ashley> top ;)
23:12:06 <sjanssen> so, instead of collecting things in a nice lazy list, you'd do some stupid mutable thing to collect/display your results
23:12:18 <glguy> if you diff them, you notice that they have some white space in common ;)
23:12:48 <sjanssen> dons: http://hpaste.org/2348
23:12:59 <phr> sorear do you think it's bogus that i'm interested in this esoteric type theory stuff, when i haven't even got haskell figured out?
23:13:30 <dolio> Just skip straight to the type theory.
23:13:33 <dolio> Haskell is too mainstream.
23:13:37 <phr> heh
23:13:53 <phr> haskell, the next java :)
23:14:09 <sorear> phr: Maybe, maybe not.  Systems like CIC are much simpler than Haskell because the greater expressiveness means that a lot of things that are confusingly different in Haskell are one and the same in CIC.
23:14:35 <phr> hmm interesting
23:14:42 <glguy> cic?
23:14:44 <sorear> phr: There are no types, kinds and values - it's terms all the way down.
23:14:49 <dons> sjanssen: :)
23:15:17 <newsham> sjanssen broke my brain
23:15:18 <sorear> glguy: Calculus of (co)Inductive Constructions, an example of a dependent calculus whose main notable aspect is that sorear is familiar with it.
23:15:25 <phr> oh that's the ocaml
23:15:36 <phr> cic is the logic in coq
23:15:38 <dons> sjanssen: you should send that to the list :)
23:15:40 <glguy> actual lol
23:15:57 <alexj> @seen glguy
23:15:57 <lambdabot> glguy is in #haskell. I last heard glguy speak 17s ago.
23:16:10 <wli> sjanssen: I don't understand how your sudoku solver works.
23:16:13 <newsham> sorear: you should write some small coq examples
23:16:14 <sorear> The haskell is longer!  Oh noes!
23:16:34 <glguy> is coq cic?
23:16:42 <glguy> is that question nonsensical?
23:16:55 <phr> coq is a system written around ciq, it has a big theorem library, proving tactics, code generators etc
23:16:56 <newsham> [20:14] < phr> cic is the logic in coq
23:16:57 <phr> cic
23:17:10 <glguy> oh, cool
23:17:14 * glguy should read more of the channel
23:17:26 <glguy> same goes for alexj, I'm right here ;)
23:17:33 <phr> http://coq.inria.fr
23:17:35 <lambdabot> Title: The Coq proof assistant
23:17:49 * glguy has used coq before
23:17:57 <glguy> in an attempt to prove state was a monad
23:18:04 <glguy> and to follow along with the one for list
23:18:08 <glguy> (and some other trivialities)
23:18:15 <phr> i saw some blog about using coq to prove the monad laws--was that you?
23:18:24 <glguy> that was me following along :)
23:18:39 <sjanssen> wli: I don't know how it works either -- I just slavishly translated some code
23:18:46 <phr> this is pretty neat: http://www.cs.berkeley.edu/~adamc/papers/PositionPLPV06/
23:18:46 <lambdabot> Title: Position Paper: Thoughts on Programming with Proof Assistants
23:19:08 <sjanssen> dons: I'll send it tomorrow, once I've gotten a chance to understand what the code is doing, and verified that it works for some inputs
23:20:20 <dons> might be an idea to check the performance against the ocaml version too.. :)
23:20:21 <sjanssen> I think this is a good example of how imperative paradigms can produce crummy code
23:20:30 <dons> oh?
23:20:42 <dons> is the ocaml not purely functional -- i didn't read it closely.
23:20:44 <phr> there's a book called coq'art that i'm thinking of sending away for -- but i don't want to spend $$ unless i think i'm gonna actually read the book and use coq, which i have my doubts about since my brain is already not big enough even for haskell ;)
23:20:55 <dons> phr: i've heard good reviews of it
23:20:59 <dons> i wouldn't mind a copy either
23:21:05 <sjanssen> the imperative version can only do two things: iteratively print results to the screen, or collect all the results in a mutable var (strictly)
23:21:23 <sjanssen> whereas our functional and lazy version has the ultimate flexibility
23:21:33 <phr> i emailed the guy who wrote that position paper and he suggested working through some exercises in TAPL first, so i might try that (i have a borrowed copy)
23:21:45 <opqdonut> sjanssen: wow, you gave me a deja vu :)
23:21:57 <opqdonut> i swear i've heard those two lines before
23:22:08 <sjanssen> dons: the ocaml takes a callback function that's applied to each result in order
23:22:22 <dons> sjanssen: ah very interesting.
23:22:34 <Eelis> (phr: that guy also hangs out in #coq)
23:22:45 <phr> eelis, oh neat
23:23:56 <sorear> phr: Try not to be offended by his bad communication problems. (and by bad I mean "I got kickbanned from #haskell" bad)
23:24:12 <phr> you mean adamc???
23:24:19 <hpaste>  sjanssen annotated "OCaml sudoku" with "a more direct translation, with ucky imperative junk" at http://hpaste.org/2348#a2
23:24:49 <sorear> phr: yup, adamc, aka Smerdyakov (you should have heard that name by now)
23:24:55 <phr> yow
23:24:55 <phr> heh
23:24:59 <phr> i saw that name on his website
23:25:23 <phr> but no i've never interacted with him except sending him an email about coq and getting a reply
23:25:28 <sorear> phr: So how do you read his slides?
23:25:36 <phr> on his site
23:25:45 <sorear> phr: Every pdf program I've tried mangles them horribly
23:26:02 <phr> yeah maybe xpdf is manglign them too
23:26:08 <sorear> http://members.cox.net/stefanor/1187591104.png
23:26:12 <sorear> notice the overlap
23:26:16 <phr> i guess they're readable though
23:26:30 <phr> yeah
23:26:41 <phr> the actual paper is in the proceedings of that conference which is online
23:26:44 <phr> there's a link in there somewhere
23:27:06 <newsham> sorear: same overlap in acrobat reader.
23:27:10 <glguy> I tried Acrobat 8.1
23:27:13 <glguy> and it doesn't work either
23:27:18 <newsham> perhaps animated slides translated down to flat pages?
23:27:31 <sorear> xpdf, kpdf, pdfedit all break
23:27:48 <sorear> and smerdyakov didn't notice (the question) when I asked him
23:28:07 <phr> yeah try this   http://www.easychair.org/FLoC-06/PLPV-preproceedings.pdf
23:28:16 <phr> it's a big pdf and that paper is way near the end
23:28:19 <phr> on p.110 of the pdf
23:29:25 <phr> it scares me a bit that all these program verification guys are working on mobile proof-carrying code, which smells a little too much like DRM ;)
23:30:06 <wli> No big surprise.
23:30:24 <wli> DRM will get rammed down our throats regardless of whether we want it.
23:31:46 <ddarius> No it won't.
23:32:25 <newsham> drm will flop and be scaled way back
23:32:31 <wli> Well, there's a generalized "intellectual property enclosure movement" ongoing of which DRM is a part.
23:32:51 <glguy> there was a post on slashdot recently about DRM declining in favor of watermarking
23:33:02 <glguy> I don't know if that will happen or not, but it seems somewhat reasonable
23:33:08 <glguy> that it could
23:33:32 <phr> my boss has this big rant about how copy protection killed the software industry in the 1980's and it's killing the music and movie industries now ;)
23:33:58 <ddarius> The software industry is dead?
23:33:59 <glguy> "killed the software industry"?
23:34:16 <phr> yeah, there's basically about 2 sw companies making money, as opposed to 100's or 1000's in the 80's and 90's
23:34:24 <wli> Well, it's going to take much larger economic events to kill the software industry.
23:35:02 <phr> it's already dead, to hear this guy tell it
23:35:14 <wli> phr: Presumably he means lack of copy protection?
23:35:54 <phr> no he means there used to be a lot of profitable software companies but now there's basically just microsoft and adobe.  the rest have been killed or absorbed.  he blames this on copy protection.
23:36:05 <wli> phr: Or lack thereof?
23:36:45 <phr> he says they did fine without copy protection in the 80's and made lots of cash, but then they started using copy protection extensively and consequently died on the vine
23:37:03 <newsham> isnt that when they started hiring non-caucasians and women?
23:37:28 <glguy> wait, women work in the software industry?
23:37:44 <newsham> silliness
23:37:54 <phr> heh
23:38:04 <wli> In my field they've been scouring the world for anyone who can do it for the past 60 years, so "offshoring" is meaningless.
23:39:17 <phr> math?
23:39:27 <wli> phr: No, kernel crap.
23:39:30 <glguy> math has been around more than 60 years
23:39:43 <phr> oh
23:40:08 <dons> you sure, glguy? wasn't Leibniz an Algol programmer?
23:40:19 <wli> There was Lady Ada.
23:40:39 <glguy> she could hardly be considered part of the "software industry" :-p
23:40:47 <wli> The first programmer, who wrote the first program, which was to compute Bernoulli numbers.
23:41:02 <dons> and we continue the tradition to this day  :)
23:41:47 <dons> i note Bernouilli.hs is the first benchmark in nofib
23:42:04 <lament> the first programmer was babbage
23:42:45 <lament> whether ada did or didn't actually write any code, babbage certainly wrote some first
23:42:46 <dons> wasn't he the first computer engineer?
23:43:37 <paolino> good day, is there anything in the standard lib to split a string on a separator character ?
23:43:40 <dons> ah i see, Ada Lovelace published some ideas about the difference engine that Babbage didn't.
23:43:46 <dons> paolino: 'break'
23:43:59 <fishkandy> ada saw the general purpose of the machine, she envisaged tha tit could make music, and "weave algebraic patterns"
23:44:01 <glguy> paolino: kind of
23:44:07 <wli> lament: There's some reason Ada's cited as the first programmer vs. Babbage. I don't know specifically why. I'm not into this history bit.
23:44:08 <paolino> foldr break ?
23:44:16 <glguy> paolino: you'd use unfoldr
23:44:31 <dons> fishkandy: yeah, she realised you could hack it
23:44:43 <paolino> ok, I try that
23:45:01 <paolino> :t unfoldr
23:45:03 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
23:46:15 <steven_ashley> :info unfoldr
23:46:19 <steven_ashley> awwh :P
23:46:24 <steven_ashley> where is it defined?
23:46:31 <dons> Data.List
23:46:31 <glguy> Data.List
23:46:34 <dons> ?src unfoldr
23:46:34 <lambdabot> unfoldr f b  = case f b of
23:46:34 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
23:46:34 <lambdabot>    Nothing        -> []
23:46:35 <glguy> jinx
23:46:37 <wli> There need to be more anamorphisms, like unfoldl and unfoldAccumL/unfoldAccumR
23:46:59 <dons> wli, I agree!
23:47:09 <dons> streamEverything :)
23:48:02 <opqdonut> i dislike the maybeness of unfoldr :/
23:48:05 * glguy didn't realize you could compile Coq proofs and call them from OCaml
23:48:32 <glguy> opqdonut: then you should stick with map + iterate :)
23:48:39 <dons> glguy: yeah, you can extract src from Coq or Isabele or Twelf, as ML or Haskell and a few others usually
23:48:51 <dons> opqdonut: you gotta terminate the list somehow ... usually
23:49:09 <opqdonut> dons: yeah i realize that :)
23:49:31 <glguy> dons: if you use the version Cale typically mentions:
23:49:39 <dolio> If it took a predicate, it'd be easier to use with various other functions.
23:49:40 <wli> Writing out iteration to convergence as let xs = iterate step x in fst $ head $ dropWhile (uncurry (/=)) $ zip xs $ tail xs gets repetitive after a while.
23:49:45 <glguy> takeWhile f $ map g $ iterate h x
23:50:10 <glguy> or maybe it was: map f $ takeWhile g $ iterate h x
23:50:11 <hpaste>  sjanssen annotated "OCaml sudoku" with "the Map is not needed" at http://hpaste.org/2348#a3
23:50:45 <phr> this thompson book is really good, much more accessible for newbies than pierce or harper
23:50:47 <dons> sjanssen: ah, good!
23:50:56 <paolino> :t unfoldr (\b -> let (l,rs) = break  '/' b in if (not.null $ rs) then Just (l,rs) else Nothing) "a/b"
23:50:58 <lambdabot>     Couldn't match expected type `a -> Bool'
23:50:58 <lambdabot>            against inferred type `Char'
23:51:00 <dons> sjanssen: now you can remove that Map import
23:51:12 <glguy> :t break
23:51:14 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
23:51:20 <glguy> paolino: note the   a -> Bool
23:52:02 <paolino>  :t unfoldr (\b -> let (l,rs) = break  (=='/') b in if (not.null $ rs) then Just (l,tail rs) else Nothing) "a/b"
23:52:28 <msingh> what is this called: [1 .. 10]
23:52:33 <glguy> paolino: you had a space before :t
23:52:44 <paolino> :t unfoldr (\b -> let (l,rs) = break  (=='/') b in if (not.null $ rs) then Just (l,tail rs) else Nothing) "a/b"
23:52:46 <lambdabot> [[Char]]
23:52:51 <glguy> msingh: sugar for: enumFromTo
23:53:06 <paolino> msingh: enumeration
23:53:07 <msingh> glguy, i mean the FP term for it, if there is one
23:53:43 <paolino> > unfoldr (\b -> let (l,rs) = break  (=='/') b in if (not.null $ rs) then Just (l,tail rs) else Nothing) "a/b"
23:53:44 <lambdabot>  ["a"]
23:53:55 <paolino> :/
23:54:08 <glguy> paolino: in the case of "b", rs would be null
23:54:14 <glguy> paolino: but you return Nothing when that is the case
23:55:01 <glguy> paolino: you need to test for b being null, that's when you are done
23:57:55 <glguy> > unfoldr (\b -> if null b then Nothing else Just (case break (=='/') b of (xs,'/':ys) -> (xs,ys); pair -> pair)) "a/b/c"
23:57:57 <lambdabot>  ["a","b","c"]
23:58:07 <steven_ashley> lol, that really is too much effort :(
23:58:46 <sjanssen> there's a neat one with groupBy, let me find it
23:59:01 <paolino> > unfoldr (\b -> if null b then Nothing else let (l,rs) = break  (=='/') b in if (not.null $ rs) then Just (l,tail rs) else Just (l,[]) "a/b"
23:59:01 <lambdabot>  Unbalanced parenthesis
23:59:17 <paolino> > unfoldr (\b -> if null b then Nothing else let (l,rs) = break  (=='/') b in if (not.null $ rs) then Just (l,tail rs) else Just (l,[])) "a/b"
23:59:19 <lambdabot>  ["a","b"]
23:59:20 <glguy> > unfoldr (\b -> if null b then Nothing else Just (let (xs,ys) = break (=='/') b in (xs,drop 1 ys))) "a/b/c"
23:59:21 <lambdabot>  ["a","b","c"]
23:59:27 <sjanssen> @type \p -> map (dropWhile p) . groupBy (const (not . p))
23:59:29 <lambdabot> forall a. (a -> Bool) -> [a] -> [[a]]
23:59:51 <sjanssen> @type (\p -> map (dropWhile p) . groupBy (const (not . p))) (=='/') "a/b/c"
23:59:53 <lambdabot> [[Char]]
23:59:59 <sjanssen> > (\p -> map (dropWhile p) . groupBy (const (not . p))) (=='/') "a/b/c"
