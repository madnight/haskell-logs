00:00:01 <dons> yep
00:00:02 <glguy> and focus goes to the left
00:00:05 <dons> right
00:00:06 <glguy> but the mouse is on the right
00:00:07 <dons> :)
00:00:07 <mudge_> okay,   could haskell be a good language for building websites in general?
00:00:18 <glguy> so to get focus back to the right I have to move the mouse to the left and then back?
00:00:21 <glguy> (or alt tab)
00:00:27 <dons> mudge_: some people think so, and there's a few operations doing that, yes.
00:00:32 <sjanssen> glguy: or just click
00:00:44 <dons> mudge_: key points being stability, reliability, conciseness, performance.
00:00:44 <glguy> ah, that's good enough then ( I found that as you said it)
00:00:55 <dons> you'd want to be fluent with haskell i think before you attempted it.
00:01:21 <dons> and you'd just use one of the existing web frameworks, like happs or wash
00:02:19 <glguy> does xmonad have a quit key?
00:02:24 <mudge_> well i was thinking about becoming fluent in haskell, and then building my own web framework
00:02:39 <sjanssen> mod-shift-q
00:02:52 <glguy> that's what I'd have though
00:02:53 <glguy> t
00:03:00 <glguy> wonder why it doesn't do anything...
00:03:14 <glguy> maybe it did..
00:03:16 * glguy checks
00:03:34 <glguy> ah... the red border didn't go away
00:03:40 <glguy> confused me
00:03:42 <Cale> well, that's disappointing :)
00:03:43 <dons> mudge_: that'd be one option :)
00:03:50 <Cale> Loading indexblocks...devremap: devremap.c:136: setbit: Assertion `bitnum < info.mapsize*8' failed.
00:03:50 <Cale> Aborted (core dumped)
00:03:53 <Cale> awwww
00:03:55 <Cale> hehe
00:04:15 <mudge_> dong: thanks for your input
00:04:18 <Cale> Fortunately it's still quite easy for me to back out.
00:04:23 <mudge_> don:  I mean
00:04:26 <dons> :)
00:05:03 <glguy> if I kill xmonad, should windows in other workspaces remain lost?
00:05:15 <sjanssen> glguy: which WM did you restart into?
00:05:31 <glguy> none, so is that the responsibility of the new wm?
00:05:38 <sjanssen> yes
00:05:40 <glguy> ok
00:05:46 <dons> it should scan for them
00:06:00 <dons> sjanssen: or do we leave them in a funny state?
00:06:10 <sjanssen> dons: not any more
00:06:20 <sjanssen> though glguy's old version may have this bug
00:06:22 <dons> ok. so not unmanaged or what not? and not with funny geometries?
00:06:25 <dons> yeah
00:06:31 <glguy> sjanssen: I'm running the newest darcs sources
00:06:48 * glguy tries again, since the restart just to check
00:06:58 <mudge_> don:  what do you do?
00:07:21 <dons> mudge_: i work for galois.com
00:07:25 <dons> glguy: :)
00:07:27 <glguy> heh
00:07:40 <sjanssen> dons: they're put into the iconic state, as per the ICCCM
00:07:47 <dons> ok. good.
00:07:47 <sjanssen> so any compliant WM should pick them up
00:07:52 <dons> yes, so that should be fine
00:07:57 <sjanssen> (note that old dwm is note compliant)
00:08:01 <mudge_> don: cool
00:08:02 <sjanssen> not
00:08:19 <sorear> what about new dwm?
00:08:20 <dons> s/\(not.*\)note/\1not/
00:08:22 <dons> :)
00:08:44 <sjanssen> sorear: I haven't investigated closely, but new dwm apparently unmaps non-visible windows
00:08:55 <sjanssen> I assume they do the WM_STATE handling as well
00:09:54 <glguy> when xmonad quits, there is no way to focus other windows, but this stuff probably all falls under the "next window manager does that stuff" response :)
00:10:04 <sjanssen> yes
00:10:15 <glguy> so how does one restart into another manager?
00:10:26 <glguy> if one wanted to
00:10:34 <dons> you'd usually connect your X sessoin to a display manager, or an .xinitrc script
00:10:48 <dons> so that it puts you in a place that's easy to find new wms from
00:11:21 <sjanssen> glguy: I have a little script in my .xinitrc that shows a menu of WMs
00:11:26 <glguy> ah
00:11:30 <sjanssen> run in a loop, just in case of crashes
00:11:34 <glguy> cool
00:11:40 <sorear> dons: are there any plans to support the ICCCM window manager hotswitch protocol?
00:12:08 <sorear> (not a priority as long as I think we're the best - just asking)
00:12:10 <sjanssen> glguy: xmonad also has the ability to fork() to other WMs, take a look at 'restart'
00:12:25 <glguy> sjanssen: ok, so I could add it to my Config.hs
00:12:55 <sjanssen> yeah, you could add a dwm key if so desired
00:13:12 <sjanssen> of course that's a stupid idea, but meh ;)
00:13:14 <mudge_> don: Do you think it would be a lot of work to build a web framework in haskell?
00:13:15 <dons> sorear: maybe. i don't think anyone's thought about it
00:13:33 <mudge_> hi eevar2
00:13:36 <dons> mudge_: i'd not think so -- a small one is pretty, and lots have been made
00:13:39 <sjanssen> sorear: at least one user has mentioned it, but it isn't a priority for me
00:13:46 <dons> s/is pretty easy/
00:13:51 <mudge_> dons: cool, thanks
00:14:00 <dons> look on hackage.haskell.org, and just glue together an xhtml lib, fastcgi , some other stuff :)
00:14:44 <mudge_> ok
00:15:50 <mudge_> dons:  are you on here a lot?
00:15:58 <mudge_> I'm just looking for some haskell friends
00:16:06 <glguy> ?yow
00:16:06 <lambdabot> He probably just wants to take over my CELLS and then EXPLODE inside me
00:16:06 <lambdabot> like a BARREL of runny CHOPPED LIVER!  Or maybe he'd like to
00:16:06 <lambdabot> PSYCHOLIGICALLY TERRORISE ME until I have no objection to a RIGHT-WING
00:16:06 <lambdabot> MILITARY TAKEOVER of my apartment!!  I guess I should call AL PACINO!
00:16:15 <shachaf> mudge_: #haskell is your Haskell friend. :-)
00:16:30 <mudge_> I love that bot
00:16:40 <mudge_> ok, thanks shachaf
00:16:43 <shachaf> And lambdabot, of course. :-)
00:16:48 <mudge_> yea
00:16:53 <shachaf> @botsnack
00:16:53 <lambdabot> :)
00:16:56 <sorear> hi!
00:17:00 <Binkley> lambdabot loves you even when no one else does
00:17:23 <dons> mudge_: most of us are here a lot :) just hang out here and you'll meet lots of regulars
00:17:28 <dons> ?where stats
00:17:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
00:17:34 <dons> gives you a bit of a profile of the community
00:18:11 <glguy> wow... the unique nick count has eclipsed the previous one
00:18:12 <mudge_> wow, the haskell irc stats are going up
00:18:15 <glguy> from the end of last year
00:18:26 <dons> glguy: yea.
00:18:29 <dons> h.
00:18:46 <dons> avoiding avoiding success :)
00:18:53 <glguy> yikes
00:19:02 <sorear> @users
00:19:02 <lambdabot> Maximum users seen in #haskell: 385, currently: 336 (87.3%), active: 12 (3.6%)
00:19:18 <glguy> dons: I think we could fix that with a few wide sweeping bans
00:19:20 <mudge_> does unique nick  mean unique nicknames in the haskell room?
00:19:29 <dons> yep
00:19:41 <opqdonut> ahh stats
00:19:41 <opqdonut> nice
00:19:49 <shachaf> dons: Will there be a stats page for any other channels (e.g., #xmonad)?
00:20:02 <dons> oh, it could be done if logs existed
00:20:06 <dons> ?users #xmonad
00:20:06 <lambdabot> Maximum users seen in #xmonad: 68, currently: 57 (83.8%), active: 5 (8.8%)
00:20:11 <mudge_> dons: are you don stewart?
00:20:15 <dons> mudge_: yep
00:20:21 <opqdonut> :))
00:20:25 <dons> do you want to steal my identity? :)
00:20:40 <dons> i note typing 'dons' into google is fairly useful
00:20:41 <mudge_> na, I think I would be afraid to
00:20:56 <glguy> dons: speaking of making haskell friends... did you figure anything out about transportation from the airport?
00:21:19 <dons> glguy: not yet. andy also offered a lift. and there's the taxi too. i'll see what suzie wants to do
00:22:11 <sorear> dons: identifying ANYONE here is easy... remember fasta, Mr. "I don't want people linking me to my Haskell identities so I'm using a pseudonym and taking great pains to hide the connections"?  Took me like five minutes to arrive at Ron de Bruijn
00:22:58 <shachaf> sorear: I thought you only got a first name (then)?
00:23:10 <sorear> shachaf: s/me/us/ ok :)
00:23:42 <Binkley> maybe he just didn't want people asking him if he was related to the other de Bruijn
00:24:13 <mudge_> later people,  nice to meet you all
00:24:38 <sorear> quite possible... it's not like N.G. is memorable
00:24:49 <dons> sorear: oh, how'd you do that?
00:24:58 <dons> (i think i knew that though, somehow?)
00:25:10 <dons> sorear: do you know who qwe1234 is? :)
00:25:24 <Binkley> dons: lambdabot!!
00:25:25 <shachaf> qwe1234 is harder. :-)
00:25:33 <Binkley> it's her secret identity
00:26:07 <dons> :) i secretly suspect someone in here plays qwe1234 just for laughs ;)
00:26:08 <sorear> dons: fasta talks about iampure's bugs constantly.  enter iampure@gmail.com and you'll instantly get a ton of oBSD-ML posts by 'Ron de Bruijn <iampure@gmail.com>'
00:26:24 <dons> sorear: ah, tricky.
00:26:25 <sorear> dons: well that was shachaf's path, I already forgot mine
00:26:39 <dons> sorear: and that gives us iampure on reddit too.
00:26:42 <Binkley> often you can identify people by characteristic phrases they use, but with qwe1234, i figure googling for "lol" and "stfu" would come up with too many results
00:26:44 <sorear> dons: not really, it's just flood fill, O(number of identities)
00:27:03 <dons> Binkley: C++ , says he interviews people all day long.
00:27:06 <shachaf> sorear: That was my path?
00:27:17 <sorear> Binkley: I'm pretty sure popcount is fasta that wya
00:27:21 <dons> doen't narrow it down much. als o can write a little python.
00:27:50 <dons> but if we went through the entire qwe canon, i reckon there's enough hints there -- unless qwe doesn't have a web presence, which is possible
00:27:51 <sorear> Binkley: When I accidentally asked him about an iampure bug he became very feign-incredulous
00:27:58 * kfish wonders why there's so few haskell stories on http://news.ycombinator.com/
00:27:59 <lambdabot> Title: Hacker News | Top Links
00:28:07 <sorear> Binkley: though the feign part may be the tinting of preconceptions
00:28:29 <hpaste>  Boney pasted "Trouble with instances in GHC." at http://hpaste.org/2255
00:28:36 <Binkley> sorear: I find it odd that he doesn't want to be associated with his own bug reports
00:29:55 <glguy> so much for separating the iampure and fasta nicks... the #haskell logs have set the connection in store
00:29:58 <glguy> stone*
00:30:07 <sjanssen> Binkley: I wouldn't want to be associated with the rudeness in some of these bug reports
00:30:17 <Binkley> sjanssen: well, yeah
00:30:27 <Binkley> I wouldn't, either
00:30:41 <Binkley> although generally I'd avoid being that rude in bug reports in the first place :-)
00:35:39 <sjanssen> Boney: you'll need to turn on -fglasgow-exts
00:35:59 <Boney> sjanssen: why's that?
00:36:18 <sjanssen> Boney: Haskell '98 restricts the form of instance declarations
00:36:34 <sjanssen> they need to be "T a b c..." where a b c... are type variables
00:36:58 <sorear> Boney: Can you explain what confused you about that error?
00:37:33 <opqdonut> so it should really be "(something) => CUTransform (Result a b)" ?
00:37:33 <DRMacIver> Morning
00:37:34 <Boney> I don't really understand the error message.. and why they need to be like that..
00:37:34 <sorear> Boney: I and SimonPJ both think it's perfectly clear, but we're obviously wrong since somebody is confused about it once a week
00:37:54 <Boney> and I don't know why my other instance (of a different class) works..
00:37:57 <opqdonut> flummoxes me too
00:37:59 <Boney> instance Monad (Result fail) where
00:38:10 <doserj> sorear, you could at least put ellipses in the error message :)
00:38:10 <shachaf> Boney: "fail" is a type variable.
00:38:11 <Boney> they seem to have the same form to me.
00:38:34 <shachaf> Boney: "RenderError" isn't.
00:38:39 <doserj> instance declarations do not need to have exactle three type variables :)
00:38:44 <shachaf> Boney: It's a type.
00:38:55 <sorear> doserj: that much was changed recently :)
00:39:01 <sjanssen> Boney: Hugs gives "Syntax error in instance head (variable expected)" would this have helped you more than GHC's message?
00:39:02 <opqdonut> sorear: is there a justification for this limitation?
00:39:51 <Boney> sjanssen: not on it's own.  If I saw both error messages it may have.
00:39:56 <dblhelix> sjanssen: he, the hugs team should add that to their error messages: "does this help you more than GHC's message?"
00:39:56 <opqdonut> guess i should just read the standard
00:39:58 <sorear> opqdonut: Yes - it makes type checking decidable
00:40:14 <opqdonut> hmmmm
00:40:16 <Binkley> "This error message was helpful. (Yes) (No)"
00:40:28 <sorear> opqdonut: without *some* restriction, it's very easy to throw the compiler into an infinite loop
00:40:29 <sjanssen> the message should at least suggest {-# LANGUAGE FlexibleInstances #-}
00:40:45 <sorear> Binkley: it would help if we started giving definitions of expected and inferred :)
00:40:50 <Boney> Hrm..  So I need at least one type variable in my instance..
00:40:52 <dblhelix> "yes, this message was very helpful; I'm looking forward to my next mistake"
00:40:53 <opqdonut> sorear: have you got an example?
00:41:31 <Binkley> sorear: my suggestions for improving error message always seem to get responded to with "that's impossible" :-)
00:41:49 <sorear> opqdonut: instance Bar a => Foo a where ... {- bar is as good as foo -}  {- in some other module written by a different person -}  instance Foo a => Bar a where .... {- foo is as good as bar -}
00:42:35 <sorear> opqdonut: now consider what happens when we try to reduce the context Foo a => - we get Bar a =>, then Foo a =>, then Bar a =>, then Foo a =>, then ...
00:42:43 <opqdonut> yeah i see
00:42:52 <opqdonut> but the "T a b c" -restriction doesn't fix this?
00:42:55 <mgsloa1> modifyIORef has an odd sig:
00:42:55 <mgsloa1> modifyIORef :: IORef a -> (a -> a) -> IO ()
00:43:05 <Binkley> mgsloa1: what's odd about it?
00:43:05 <mgsloa1> seems like the wrong ordering for a curryable func
00:43:08 <Binkley> ah
00:43:18 <opqdonut> well it depends
00:43:23 <opqdonut> on your point of view :)
00:43:23 <mgsloa1> flip . IORef would make more sense
00:43:27 <mgsloa1> oh, I suppose so
00:43:32 <opqdonut> contrast:
00:43:39 <opqdonut> @type (mapM,forM)
00:43:41 <lambdabot> forall a (m :: * -> *) b a1 (m1 :: * -> *) b1. (Monad m, Monad m1) => ((a -> m b) -> [a] -> m [b], [a1] -> (a1 -> m1 b1) -> m1 [b1])
00:43:44 <mgsloa1> I guess that wya could be useful as well
00:43:50 <dblhelix> Binkley: keep them coming... helpful error messages are still underestimated
00:43:51 <opqdonut> yeah
00:44:04 <dblhelix> Binkley: and, hence, undervalued
00:44:44 <mgsloa1> heehee, I've just made a little counter that keeps track of the number of keys I press
00:45:02 <sorear> opqdonut: T a b c... with all context bits of the form C b, DOES fix this - you can prove termination because on each reduction step, the total size of types involved shrinks
00:45:55 <hpaste>  Boney annotated "Trouble with instances in GHC." with "-fglasgow-exts" at http://hpaste.org/2255#a1
00:46:19 <sorear> opqdonut: modern GHC with -fglasgow-exts uses the Paterson Conditions instead, which are more intuitive, but so much trickier to implement and formalize I cannot in good conscience write them into a standards document
00:47:01 <sorear> the relaxation has been with us for the better part of a decade and a new bug in GHC's implementation was discoved just last week
00:47:08 <sjanssen> sorear: do you have a ref for the "Paterson Conditions"?
00:47:30 <glguy> They can't be formalized or written, its an oral history ;)
00:47:36 <Boney> I'm still having trouble..  Can somebody explain what parts of instance declarations are mapped into T a b c?
00:47:36 <opqdonut> my intuition accepts it but i still don't see it :)
00:47:37 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/other-type-extensions.html#instance-rules
00:47:39 <lambdabot> Title: 7.5. Other type system extensions, http://tinyurl.com/ywd9d4
00:47:45 <doserj> sorear, so what's the story for haskell'?
00:47:57 <sjanssen> sorear++
00:48:02 <opqdonut> how is (Bar a) => Foo a not like "T a b c... with all context bits of the form C b"
00:48:06 <shachaf> Boney: It's "T a ..." -- any number of type variables.
00:48:35 <sorear> opqdonut: a is always a type variable, T a b c... is always a type constructor application
00:48:50 <oerjan> opqdonut: the T is not the class but the type constructor
00:49:02 <Boney> oh hrm.
00:49:09 <Boney> thanks
00:49:11 * Boney testing
00:49:35 <opqdonut> sorear: ahhh, i see
00:50:04 <Boney> I think that worked (I have different errors!)
00:50:05 <opqdonut> or rather, i see why Foo (T a) is to be preferred over Foo a in this case
00:50:16 <krishn_bhakt> any tutorial on how to program statistical functions like t.test in haskell?
00:50:28 <opqdonut> but i don't see why Foo (T X) is verboten?
00:50:42 <Boney> Perhaps the error message should say Class (Constructor arg1...argN)
00:51:11 <opqdonut> (that is, "instance Foo (T a)", "instance Foo (T X)", etc)
00:51:19 <Boney> krishn_bhakt: Not haskell specific but try reading PSPP source.
00:51:27 <Boney> or R .
00:51:32 <krishn_bhakt> Thx Boney
00:51:39 <krishn_bhakt> R is written in what?
00:51:42 <Boney> I have not read it though
00:51:43 <oerjan> opqdonut: i think it was just that when haskell 98 was formulated it was not very well understood what could be allowed, so they erred on the side of caution
00:51:56 <krishn_bhakt> PSPP I beleive is in C
00:52:00 <Boney> I don't know what ether are written in, and I havn't used either.
00:52:07 <Boney> I just know of them.
00:52:11 <krishn_bhakt> Ok
00:52:14 <krishn_bhakt> Thanks
00:52:18 <Boney> np.
00:52:21 <krishn_bhakt> :)
00:52:22 <opqdonut> oerjan: okay
00:52:30 <opqdonut> thanks for the illumination, once again
00:52:32 <opqdonut> sorear++
00:52:33 <oerjan> it probably still isn't but the boundaries have moved considerably :)
00:52:34 <opqdonut> oerjan++
00:52:40 <sorear> opqdonut: In the standard Haskell-98 rules, all contexts are of the form Ctx (a B C...) where a is a type varible and B C... are 0 or more types; all more complicated contexts are either reducable or impossible, there is no middle ground
00:53:18 <sorear> opqdonut: in the less-restricted case, there is no such limitation on contexts, making it much less obvious when the compiler should stop trying to reduce them
00:53:42 <hpaste>  babu pasted "build errors in yi, hsx and hs-plugins" at http://hpaste.org/2256
00:54:18 <opqdonut> sorear: but isn't for example a context "Eq (f a)" non-h98?
00:54:58 <sorear> opqdonut: Eq (f a) fits that pattern, with unifier Ctx := Eq, a := f, B C ... := a
00:55:53 <opqdonut> ah, i thought B C... could not be variables :)
00:56:02 <opqdonut> but yeah, i see now
00:56:05 <glguy> Just for fun, try typing ‚ÄúWe fear a few dwarf watercraft stewardesses were regarded as desegregated after a great Texas tweezer war.‚Äù on a QWERTY keyboard. Also try ‚ÄúI‚Äôll kill him in Honolulu, you unhook my pink kimono.‚Äù
00:56:40 <sorear> opqdonut: I thought that too for a moment but then I remembered :)  It's not exactly a feature we use every day.
00:57:06 <doserj> glguy: you can even try both at the same time...
00:57:14 <glguy> doserj: I'm not that amazing
00:57:20 <opqdonut> sorear: thanks once again :)
00:57:34 <opqdonut> this community is just so great :))
00:58:55 <dobblego> aw shucks
00:58:57 <glguy> @yarr
00:58:57 <lambdabot> Ahoy mateys
00:59:02 <glguy> @yow
00:59:03 <lambdabot> What a COINCIDENCE!  I'm an authorized "SNOOTS OF THE STARS" dealer!!
00:59:10 <Binkley> ?quote
00:59:11 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. \n <souwh> oooh, those can be saved and reused later!
00:59:13 <shachaf> dobblego?
00:59:22 <dobblego> shachaf?
00:59:41 <shachaf> dobblego: You're still Mr. Telling, right?
00:59:46 <glguy> Mr. Telling?
00:59:52 <dobblego> shachaf, I believe so
01:00:13 * shachaf was just wondering why you were using a different nick.
01:00:28 <dobblego> dibblego is at work (public holiday today)
01:00:45 <glguy> ?seen dibblego
01:00:45 <lambdabot> dibblego is in ##logic, #haskell, #scala and #jtiger. I last heard dibblego speak 1d 2h 18m 42s ago.
01:00:51 <dons> dobblego: public holiday?
01:00:56 <dons> did i miss that?
01:01:00 <dobblego> er, Brisbane holiday
01:01:10 <dobblego> Brisbane show holiday
01:01:27 <dons> ah :)
01:13:45 <hpaste>  Hunter_wow pasted "Basic datatype" at http://hpaste.org/2257
01:14:31 <Hunter_wow> any idea? ^^
01:14:53 <shachaf> Hunter_wow: What do you want it to do?
01:14:59 <shachaf> Hunter_wow: "Just a"?
01:15:21 <Hunter_wow> only returning the the Int
01:15:54 <doserj> Hunter_wow, which one?
01:16:25 <Hunter_wow> all in the input I think
01:16:51 <doserj> you *think*, or you *know*?
01:16:56 <Hunter_wow> "which take a
01:16:56 <Hunter_wow> tuple and return Just the value in that position
01:17:23 <shachaf> Hunter_wow: Well, what do you think?
01:18:01 <Hunter_wow> dose that line say anything to you then?
01:18:15 <shachaf> Hunter_wow: Does it say anything to you? :-)
01:18:29 <doserj> it seems vaguely close to some haskell tutorial :)
01:18:45 <Hunter_wow> =D
01:19:09 <doserj> can you say in your own words what tuple1 should do?
01:20:23 <Hunter_wow> excersise from yaht where it only says: tuple1 take a tuple and return Just the value in that position"...
01:21:07 <Hunter_wow> so I would write: tuple1 (Two a b) = Just a b
01:21:12 <Hunter_wow> but dosent work
01:21:30 <Hunter_wow> which I can understand in a way
01:21:51 <doserj> *in that position* means tuple*1* should return the value in the *1st* position
01:21:52 <shachaf> Hunter_wow: What is "that position"?
01:22:08 <Hunter_wow> Just a then :O
01:22:33 <Hunter_wow> thanks
01:28:41 <Shurique> has anyone used haskell-gd?
01:29:01 <Shurique> I'm wondering how I could point the Setup.hs program to the location of my JPEG and PNG libraries
01:29:43 <dons> oh, is there a configure script?
01:30:21 <dons> ah, i see. try editing extra-lib-dirs: /your/path/here/
01:30:23 <dons> in the .cabal file
01:30:33 <dons> the path to the /lib in which those libraries hide
01:30:41 <Shurique> I see, thanks
01:30:46 <dons> (as per this faq for xmonad http://xmonad.org/faq.html#x11)
01:30:47 <lambdabot> Title: xmonad : frequently asked questions
01:30:55 <dons> (similarly situation: finding X11 libs)
01:31:29 <eivuokko> Libraries should make it a setup option and write a buildinfo file.
01:31:34 <eivuokko> (and programs)
01:31:48 <dons> yep. many do (xmonad for example)
01:31:55 <dons> the above faq is the backup should the configure script fail
01:32:02 <dons> i guess gd doesn't try though?
01:40:38 <eivuokko> Is it possible to get yi working in Windows?
01:41:43 <dons> i believe so, yes. best ask on the yi mailing list though
01:41:52 <dons> i don't think its inherently unixy anymore
01:41:56 <sorear> Yes, by Turing's representation theorem.  In practice, probably still yes, since GHCi and Gtk2Hs have been ported
01:42:27 <sorear> vty definity will not work (I speak as the author)
01:43:03 <ari> @check \xs -> null xs || ((head . foldr (\x y -> if null y then [x] else y) []) xs == last (xs::[Int]))
01:43:05 <lambdabot>  OK, passed 500 tests.
01:43:54 <eivuokko> dons, sorear, Thanks.  I guess I'll try it later on.
01:44:13 <Binkley> I hear it's hard to find Windows device drivers for that infinite tape :-)
01:45:05 * eivuokko leaves
01:45:23 <sorear> Binkley: Linux proper will run in a 4MB emulator (good luck with GHC though)
01:45:55 <Binkley> Yes, but that isn't implied by Turing's representation theorem, as such :-)
01:49:29 <xerox> Does happy really need happy to build?
01:49:37 <vincenz> \o/
01:49:41 <vincenz> tonight I start travelling
01:49:44 <vincenz> and sunday I'm in colombia
01:51:06 <krishn_bhakt> happy happy joy joy!
01:51:16 <sorear> xerox: Yes, and yacc needs yacc to build. :)  Is the pre-preprocessed version an option?
01:54:56 <roconnor> ``the Coverage Condition fails for one of the functional dependencies''
01:54:58 <roconnor> ??
01:58:25 <kaol> haskell++. It makes me think.
01:59:31 <vincenz> haskell++. It makes me have to think less.
01:59:43 <roconnor> what is the coverage condition?
02:00:46 <shachaf> @karma haskell
02:00:46 <lambdabot> haskell has a karma of 1
02:00:49 <shachaf> haskell++.
02:00:52 <shachaf> @karma haskell
02:00:52 <lambdabot> haskell has a karma of 1
02:00:55 <Binkley> hmm
02:00:57 <vincenz> haskell++
02:00:58 <vincenz> haskell++
02:00:59 <shachaf> Try without the .
02:01:12 <vincenz> yes, use -- for comments
02:01:14 <matthew-_> roconnor: explained at http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#instance-decls
02:01:15 <vincenz> just don't do this
02:01:16 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
02:01:17 <vincenz> haskell++--
02:01:22 <vincenz> @karma haskell++
02:01:22 <lambdabot> haskell++ has a karma of -1
02:01:37 <shachaf> haskell++++
02:01:40 <vincenz> @karma haskell++
02:01:41 <lambdabot> haskell++ has a karma of 0
02:02:24 <roconnor> matthew-_: ah I'm staring to see
02:02:31 <roconnor> scary
02:02:46 <roconnor> But I'll just throw in an allow undecidable isntances
02:02:46 <matthew-_> roconnor: yeah, MTL requires the coverage condition to be lifted.
02:02:51 <araujo> vincenz, coming down here?
02:03:11 <matthew-_> roconnor: undecidable instances are normally "safe" - compilation may not terminate, but if it does, all is well.
02:03:11 <vincenz> araujo: colombia?
02:03:15 <araujo> vincenz, yeah
02:03:18 <vincenz> yep :)
02:03:34 <matthew-_> roconnor: whereas incoherant instances, if compilation terminates, you may not be left with safe code
02:03:35 <araujo> vincenz, which city?
02:03:42 <vincenz> araujo: bogota, cartagena and leticia
02:03:47 <roconnor> matthew-_: that's good
02:03:49 <vincenz> and villa medin
02:04:12 <araujo> vincenz, nice, is that a tour? , i am not in .co , i am in .ve , but i live in the state near it
02:04:14 <roconnor> matthew-_: yay, compilation terminated. \o/
02:04:40 <vincenz> araujo: Well wedding + self-organised tour, yeah
02:04:52 <araujo> vincenz, cool, and congrat
02:04:54 <vincenz> araujo: I've been in .ve, well ... isla marguerita, but that's like 10 years ago :)
02:04:59 <vincenz> araujo: not me, my best friend
02:05:02 <vincenz> he's half colombian
02:05:04 <araujo> vincenz, aaah ok
02:05:13 <vincenz> I'm flying there to attend ;)
02:05:18 <araujo> vincenz, yeah?, that's cool, let me know if you come down here again :-)
02:05:44 <matthew-_> roconnor: good good.
02:05:51 <vincenz> (blegh for flights: greece -> Belgium.... (tomorrow), then Belgium -> US and US ->Colombia on sat/sun)
02:06:08 <matthew-_> roconnor: you normally have to be doing fairly wackey things to make the type checker loop
02:06:09 <araujo> hah
02:06:12 <roconnor> matthew-_: Did something change with GHC 6.6.  I think I had no trouble compiling before.
02:06:44 <matthew-_> roconnor: things change with each release - otherwise people would not see the point in upgrading ;-)
02:07:13 <matthew-_> roconnor: but I don't know the details of what changed wrt the type checker. It "got better" is the general idea I think!
02:07:31 <roconnor> yeah, It could have been an error to allow what I had before.
02:12:12 <roconnor> how do I enable timing of commands in GHCi again?
02:12:16 <wli> :set +s
02:12:26 <wli> There's probably a faster way to compute d(n^2)
02:12:29 <roconnor> wli: thanks
02:12:43 <roconnor> how would I get help from GHCI to tell me that?
02:12:46 <dons> i thought  the comment on today's xkcd, http://xkcd.com/303/, on reddit, that "this is another valid reason to use haskell insteadl of lisp" was funny :)
02:12:47 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
02:12:52 <wli> roconnor: :?
02:13:10 <roconnor> wli: oh I see it now
02:13:16 <roconnor> at the bottom of the help page
02:13:20 <Binkley> dons: yes, bring back the days when it took all night to build GHC :-)
02:13:28 <roconnor> +s    print timing/memory stats after each evaluation
02:13:57 <araujo> dons, haha
02:14:17 <araujo> dons, Haskell makes you lazy
02:14:37 <roconnor> wow, using arctanh to compute logarithms is so much faster than what I was doing.
02:14:44 <JohnMeacham> anyone worked on that 'adaptive haskell' stuff?
02:14:51 <opqdonut> roconnor: paste please?
02:14:52 <vincenz> lol :)
02:14:54 <vincenz> dons: classic :)
02:15:10 <JohnMeacham> bi which i mean http://www.cse.ogi.edu/~magnus/Adaptive/
02:15:11 <lambdabot> Title: Adaptive -- Incremental Computations in Haskell
02:15:28 <dons> Binkley: i remember a 54 hour marathon which ended in ld failing from memory exhaustion :)
02:15:32 <opqdonut> JohnMeacham: is that adaptive as in adaptive numeric integration?
02:15:42 <hpaste>  roconnor pasted "paste for opqdonut" at http://hpaste.org/2258
02:15:58 <JohnMeacham> the implementation feels very clunky, but the underlying algorithm seems nice, I was wondering if anyone has reformulated it in a nicer monadic framework?
02:16:09 <Binkley> dons: yeah, I remember having to buy more RAM once just so I could link GHC-compiled programs without running out of RAM
02:16:12 <Binkley> not even GHC itself
02:16:14 <opqdonut> roconnor: nice :)
02:16:16 <vincenz> dons: I don't see it on xkcd, tho
02:16:34 <JohnMeacham> the one given is more or less a straight translation of the ml one with some added type safety due to embedding it in a monad, but that is still not very "clean"
02:16:35 <roconnor> opqdonut: and it uses less memory too
02:16:45 <opqdonut> roconnor: any clue why?
02:16:51 <vincenz> dons: I mean, xkcd on reddit
02:18:21 <JohnMeacham> I just bought an old ibook G4 to do some iPhone hacking... time to port jhc...
02:18:43 <JohnMeacham> (the iPhone is a full unix, porting ghc or jhc should be quite straightforward)
02:19:02 <roconnor> opqdonut for ln2 I compute  ln (3/2) + ln (4/3)
02:19:31 <opqdonut> why?
02:19:35 <roconnor> so that gives two taylor series one converging a a geometric rate with 1/2 and one with a geometric rate of 1/3
02:19:53 <encryptio> @pl \x y -> wrapTo 5 (x+y)
02:19:54 <lambdabot> (wrapTo 5 .) . (+)
02:20:10 <dolio> dons: You need to contact amazon.ca to offer a random Haskell book for $3 or something, and then revoke orders as a pricing mistake, so you can post 14 articles to reddit about it. :)
02:20:13 <roconnor> the arctan method just does one taylor series with a convergence rate of (1/3)
02:20:40 <roconnor> opqdonut: How would you compute the ln(2)?  The alternating harmonic series converges really slowly.
02:21:05 <wli> roconnor: What are you trying to do?
02:21:05 <opqdonut> ahh, i see
02:21:09 <roconnor> opqdonut: so I break it into two pices.
02:21:09 <DRMacIver> ln(2) = -ln(1/2) -- converges much faster.
02:21:27 <dons> dolio: heh
02:21:45 <wli> roconnor: Compute ln(x)? Probably best to use a solver on exp(y)=x
02:21:47 <roconnor> DRMacIver: ah, yes, good point, but the arctanh series converges even faster still.
02:22:05 <roconnor> wli: depends on how fast you can compute exp.
02:22:15 <MyCatVerbs> JohnMeacham: what about RAM and swap space though? Its bulk storage is solid-state too, so any swap you use will cause flash cards to burn out like crazy if you do resort to it.
02:22:19 <DRMacIver> roconnor: Hm. arctanh doesn't have nicely computable coefficients does it? Something with bernoulli numbers.
02:22:21 <wli> roconnor: Far from 0 I'd recommend the continued fraction if you're going to use direct methods.
02:22:28 <sieni> roconnor: the series for exp converger really fast
02:22:34 <DRMacIver> Probably doesn't matter though.
02:22:35 <wli> roconnor: For arctanh()
02:22:36 <sieni> s/r/s/;
02:22:46 <roconnor> DRMacIver: arctahn's coeffieces are 1/n for odd numbers and 0 for even numbers.
02:22:58 <Botje> MyCatVerbs: use the internets as swap space! can't be much slower than a real harddisk :)
02:23:05 <DRMacIver> Oh, no. Bernoulli numbers is tanh, not arctanh. My bad.
02:23:15 <roconnor> sieni: well the series eventually converges really fast.
02:23:18 <wli> roconnor: exp(x) = (exp(x/ceil(x)))^(ceil(x))
02:23:25 <DRMacIver> roconnor: That's not *that* much faster. :)
02:23:37 <roconnor> DRMacIver: true.
02:23:51 <wli> roconnor: Never evaluate it directly for x > 1
02:23:56 <roconnor> wli: yep
02:24:18 <wli> roconnor: Wait a minute, you're the exact real arithmetic guy aren't you?
02:24:31 <roconnor> wli: I'm still scared that a solver will be quite slow.
02:24:32 <wli> roconnor: I don't need to tell you these things, then.
02:24:36 <roconnor> wli: yep.
02:25:02 <roconnor> wli: well, I'm not really an expert :P
02:25:24 <dcoutts> JohnMeacham: btw, if you have any time in the next couple weeks, could you check if we've broken Cabal with jhc, we've been doing some refactoring to make the code nicer.
02:25:24 <wli> roconnor: Solvers are "safe" for people who might err elsewhere. There are faster/better methods for those who know what they're doing.
02:25:53 <roconnor> wli: I want easy to prove :)
02:26:12 <roconnor> wli: because I have to make computer verified proofs of whatever I do.
02:26:15 <Binkley> /leave #haskell
02:26:17 <Binkley> oops
02:26:19 <wli> roconnor: Continued fractions, then. The odd and even convergents bounds the limit from above and below.
02:26:32 <JohnMeacham> dcoutts: I didn't write any of the cabal code for jhc, musasabi did I believe.
02:26:45 <wli> roconnor: arctanh(x) IIRC has a nice continued fraction.
02:26:53 <roconnor> wli: I haven't seen the proofs of correctness of the continued fractions, but that might be a possibility.
02:27:03 <wli> feh, I need fast factoring methods
02:27:07 <MyCatVerbs> Botje: ...to Hell with you.
02:27:12 <dcoutts> shapr: Distribution.SetupWrapper moved to Distribution.Simple.SetupWrapper
02:27:20 <wli> roconnor: It's all by passage back and forth to series via Euler's formulae.
02:27:21 <JohnMeacham> MyCatVerbs: it is a decently powerful machine, and compilers are getting better all the time.
02:27:22 <roconnor> wli: *sigh* I don't even have fast integer multiplication.
02:27:46 <MyCatVerbs> Botje: you sound just like one of them spoiled academic bastards who's never worked with a machine that *wasn't* connected to JANET / Internet2 / CERN.
02:27:47 <roconnor> wli: well, in haskell I do, but not it Coq.
02:27:53 <wli> roconnor: I need the number of divisors.
02:28:09 <roconnor> s/it/ing
02:28:13 <roconnor> er in
02:28:15 <roconnor> blah
02:28:17 <wli> roconnor: (computed via factorization of course)
02:28:25 <Botje> MyCatVerbs: i'm only just finishing my bachelor's degree in CS, does that count as an academic bastard already? :)
02:28:26 <MyCatVerbs> Botje: it's really easy to hate them people when you're sat on the far end of a 56k modem on a crackly line, waiting for a fifty meg compiler to come down so you can play with it. ;)
02:28:48 <wli> Actually maybe the Dirichlet series will do...
02:28:55 <Botje> I bought my 50 meg compiler in a big box
02:28:56 <sieni> wli: http://www.jstor.org/view/00255718/di970542/97p0851k/0
02:28:58 <lambdabot> Title: JSTOR: Mathematics of Computation: Vol. 26, No. 118, p. 543
02:29:06 <roconnor> wli:  what series?
02:29:08 <MyCatVerbs> Botje: yep. And I'm (assuming I survive it and don't fuck up) hopefully becoming one myself. I still have the hate-filled memories, though. ;)
02:29:30 <Botje> borland C++ builder 2 and borland delphi 3
02:29:36 <Botje> ahh, good memories.
02:29:45 <roconnor> wli: rumour has it that taylor series are actually pretty good at computing stuff if you only want a few digits.
02:29:49 <wli> sieni: What's this?
02:30:00 <wli> Dirichlet series are not power series.
02:30:15 <wli> sieni: unobtainium
02:30:22 <sieni> ahh
02:30:45 <sieni> o blaarggag, I'm using the university proxy
02:31:18 <opqdonut> i don't get why all these paper systems can't just be open
02:31:25 <MyCatVerbs> JohnMeacham: but how much actual RAM is in the brick? All I can seem to find about online is the quantity of flash storage, which is a totally useless number to me.
02:32:07 <vincenz> dons: regarding the xkcd comment, there's a similar excuse for phd students ...
02:32:13 <vincenz> dons: with much more downtime
02:32:33 <vincenz> "Person x is reviewing my paper"
02:32:34 <wli> The Dirichlet series may do well...
02:33:26 <roconnor> wli: do you have error bounds for the series?
02:33:40 * roconnor finds it hard to find error bounds in math texts.
02:33:54 <wli> roconnor: Dirichlet series? These are integer functions.
02:34:25 <roconnor> wli: integer functions?
02:34:39 <roconnor> http://en.wikipedia.org/wiki/Dirichlet_series
02:34:40 <lambdabot> Title: Dirichlet series - Wikipedia, the free encyclopedia
02:34:47 <JohnMeacham> not sure, I have not started an ssh server on it to ssh to. but I imagine it is a fairly decent amount.
02:34:56 <opqdonut> they are isomorphic to integer functions
02:35:03 <opqdonut> basic analytinc number theory
02:35:05 <wli> roconnor: Dirichlet series are series of the form \sum_{n=1}^\infty \frac{c_n}{n^z}
02:35:34 <opqdonut> wli: and D. series multiplication corresponds with integer function convolution
02:35:36 <roconnor> wli: right, so I need to truncate the series to do a finite computation.
02:35:36 <JohnMeacham> I mean, I don't have to run ghc or jhc on it. jhc is a cross compiler by design. though, some work on an ARM back end for ghc would probably be needed.
02:35:52 <roconnor> wli: and I need to put a bound on the error from that truncation.
02:35:57 <wli> opqdonut: Yes.
02:37:55 <roconnor> DRMacIver: any suggestions on how to compute ln(x) for x very large or very small?
02:39:46 <JohnMeacham> 128MB
02:39:50 <JohnMeacham> plenty of headroom.
02:41:07 <doserj> roconner: ln(x*exp(y)) = ln(x) + y, or something similar?
02:41:13 <roconnor> wli: or you too if you have suggestions on how to compute ln(x) for x very large or very small.
02:41:25 <wli> I'm actually trying to compute the number of divisors of an integer, not logarithms.
02:41:28 <DRMacIver> roconnor: Not really. :-/ Scaling by integer powers of e probably helps, but you'll still have cases which it doesn't handle very well.
02:41:34 <roconnor> doserj: that's the best I've come up with so far.
02:41:55 <roconnor> DRMacIver: okay, so long as I'm not missing anything obvious.
02:42:47 <roconnor> I was hoping I could find some identity so that I could easily reduce the problem to computing arctanh(x) for |x| <= 1/2
02:43:00 <roconnor> but I'm starting to become doubtful.
02:43:06 <wli> I suppose searching in sequence is idiotic.
02:43:40 <wli> I know what the factorization has to look like from the lower bound on the number of divisors. From there it's just sorting and choosing primes.
02:44:24 <roconnor> basically i now use ln(2^n*x) = n*ln(2) + ln(x)
02:44:48 <wli> roconnor: Why not e^n*x?
02:45:42 <roconnor> wli: it's easier to find an n such that y = 2^n*x makes 1/2 < x < 2   (when y is rational)
02:46:50 <wli> roconnor: Yeah, but then you're hurting wrt. ln(2) in the end.
02:46:56 <roconnor> wli: even easier still when y is a diadic rational.
02:47:07 <roconnor> wli: well, ln(2) isn't sooo bad to compute.
02:47:19 <opqdonut> wli: but computing x=e^n*k is harder than x=2^n*k
02:47:25 <opqdonut> i'd think
02:50:28 <wli> There are relatively swift methods of determining a bounding interval, then Newton iteration to polish it down to successive integers.
02:54:32 <wli> That'll get you down to the case of 1 <= x < e, then from there whatever.
02:58:47 <roconnor> wli: technically 1/e <= x <= e
02:59:36 <wli> roconnor: You can arrange a two-sided bound like that as well.
02:59:37 <opqdonut> :)
03:00:25 <wli> 1/e <= x < 1 or 1/e < x <= 1 or 1/e < x <= e or whatever you want can be arranged.
03:01:06 <wli> Two-sided strict inequality requires more than integers, though.
03:01:28 <roconnor> :)
03:04:12 <wli> Okay, if d(n) > k then n has at most ceiling (logBase 2 k) prime divisors.
03:06:11 <wli> From there I need to choose ceiling (logBase 2 k) integers representing the powers of the primes so that the product of [k + 1 | k <- ks] is the least possible while greater than k.
03:07:33 <Shurique> I'm having no success with haskell-gd's Setup.hs, even through I set extra-lib-dirs to the directory where my JPEG and PNG libraries are located (/opt/local/include) :-/
03:07:38 <Shurique> this is what I get: http://pastebin.ca/658055
03:09:13 <wli> So basically I get a list length handed to me and need to enumerate descending sequences of nonnegative integers of that length.
03:09:16 <doserj> Shurique: shouldn#t it be /opt/local/lib ?
03:10:48 <Shurique> oh, you're right
03:10:56 <Shurique> I should get some sleep, my brain isn't working
03:10:57 <Shurique> thank you :)
03:19:08 <wli> ooh, in fact they all have to be divisors of the bound
03:19:17 <wli> no that's wrong
03:24:18 <wli> mkSeq maxN len | len == 0 = [] | maxN == 0 = [replicate (fromIntegral len) 0] | otherwise = [x:xs | x <- [0..maxN], xs <- mkSeq x (len - 1)]
03:24:59 <wli> mkSeq 1 3 == [[0,0,0],[1,0,0]] which was not the intended effect; I wanted [[0,0,0],[1,0,0],[1,1,0],[1,1,1]]
03:26:13 <dons> so what's hot in haskell-land today? what are the new season trends the fashion editors will be buzzing about? :)
03:26:47 <opqdonut> applicative is the thing this fall i'd guess :)
03:26:55 <wli> dons: Probably not my wardrobe or other stylings, though they are somewhat outlandish.
03:27:10 <opqdonut> or is it passÈ already
03:27:25 <dons> wli, lots of black?  :)
03:27:37 <dons> opqdonut: ah yes! that must have accessory for the in crowd.
03:27:39 <wli> opqdonut: I have no idea. I'm just barely getting up to speed on monads so I'm far behind the state of the art.
03:27:58 <dons> yes, i think maybe applicative functors and ndp
03:27:59 <wli> dons: And then some.
03:28:05 <opqdonut> ndp?
03:28:05 * dons hot tip for the fall season
03:28:14 <sebell> nested data parallelism
03:28:24 <opqdonut> ?where ndp
03:28:24 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
03:28:32 * wli is losing the descending sequences of integers game. :(
03:28:37 * vincenz hates people that obscure conversatiosn by throwing in strawmen
03:28:53 <wli> vincenz: Sorry.
03:29:17 <vincenz> wli: not you
03:29:19 <dozer> o/
03:29:56 <thoughtpolice> dons: second ndp.
03:30:11 <thoughtpolice> has anybody actually tried the NDP library that was released? is it usable or are there still some 'show-stoppers'?
03:31:10 <EvilTerran> tea! c\_/
03:31:36 <opqdonut> nice ascii-cup there :D
03:32:39 <thoughtpolice> i like my mugs better. :) c|_|
03:32:50 <dons> thoughtpolice: you can use it for simple stuff. but the big automatic vectorisation stuff is currently getting comitted into the head branch
03:33:15 <thoughtpolice> dons: I thought as much; is it going 'into' 6.8?
03:33:50 <thoughtpolice> or does that just depend on how much the library has matured by 6.8's release?
04:00:17 <wli> let mkSeq maxSum maxN len | len == 1 = [[n] | n <- [0..maxN]] | otherwise = [x:xs | x <- [0..(maxN `min` maxSum)], xs <- mkSeq (maxSum - x) x (len - 1)] ; ceilLg :: Integer -> Integer ; ceilLg n = head [k | k <- [0..], 2^k > n] in product $ zipWith (^) primes $ minimumBy (comparing (\xs -> product $ zipWith (^) primes xs)) $ Data.List.filter (\xs -> ((product (Data.List.map (\x -> 2*x+1) xs) + 1) `div` 2) > (4*10^6)) $ mkSeq 22 22 22
04:00:39 <wli> bang projecteuler #110 bites the dust
04:01:09 <EvilTerran> O.o
04:02:10 <wli> That one actually required a few minutes' thought.
04:12:44 <matthew-_> right, just to be clear, when doing a foreign call, the current thread does make that call right?
04:13:01 <matthew-_> it doesn't get delegated off to some other thread or anything?
04:28:07 <matthew-_> where is Addr# and should I actually use it?
04:28:29 <matthew-_> I'm just getting a Ptr back from a C++ func, but it's a pointer to an object...
04:29:00 <matthew-_> ahh, it's in GHC.Prim
04:30:15 <wli> Is there a way to force GC?
04:31:04 <apfelmus> ?type performGC
04:31:06 <lambdabot> Not in scope: `performGC'
04:31:33 <wli> @hoogle performGC
04:31:33 <lambdabot> System.Mem.performGC :: IO ()
04:34:41 <wli> Somehow ghci has gotten into a weird state where it spins like a top after every time I hit return.
04:42:53 <dons> wli, hmm. threads. best to quit probably
04:43:25 <wli> dons: yeah, I quit and restarted.
05:00:28 <wli> projecteuler #111 bites the dust
05:16:06 <anybody> is there support for explizitely sized unsigned integral types?
05:16:11 <anybody> i need uint32
05:16:23 <anybody> s/zitely/citely/
05:16:40 <sieni> yes
05:16:59 <anybody> i just found Data.Int but there seems to be only signed ints there
05:17:14 <sieni> Data.Word
05:17:15 <opqdonut> :index Word32
05:17:18 <anybody> ah. thx
05:17:18 <opqdonut> ?index Word32
05:17:19 <lambdabot> Data.Word, Foreign, Graphics.SOE
05:17:23 <opqdonut> :)
05:17:37 <anybody> hm. why Data.Word and not Data.UInt?
05:19:27 <earthy> because that would imply an interpretation of the machine words that might not have been intended
05:19:56 <earthy> specifically, a Word32 may also be a bitfield, or an instruction, and these are most definitely not ints.
05:20:38 <matthew-_> errr, how do you get ghc to link with the std c++ libraries?
05:28:03 <earthy> matthew-: err... good one. :) wxHaskell does something quite like that
05:28:34 <earthy> but ISTR that it explicitly adds the std c++ libs to the linker arguments
05:28:50 <matthew-_> right, well the linker args don't seem to be obeying the man page anyway...
05:35:55 <matthew-_> earthy: this seems to work for me: ghc-6.6.1 -fffi -fglasgow-exts -optl FTGLW.o -optl /usr/local/lib/libftgl.a -optl /usr/lib/libfreetype.so -lGL -lglut -optl /usr/lib/libstdc++.so.6 --make Main.hs
05:38:34 <anybody> hm. is it not possible to have where clauses inside an if expression?
05:39:09 <matthew-_> anybody: I don't think so
05:44:23 <ndm> dcoutts, i am at a complete loss as to why anyone is even having a debate over whether your operating system should be the operating system you are using, or some random piece of other software that may or may not be installed
05:44:42 <ndm> dcoutts, if someone slowly talks me through why a stupid point of view is valid, i might have more chance convincing all those people who are completely wrong
05:45:35 <dcoutts> ndm: huh?
05:46:06 <ndm> dcoutts, the os = mingw vs windows
05:46:15 <dcoutts> ndm: ah that :-)
05:46:16 <eivuokko> os = windows, clearly.
05:46:22 <dcoutts> yes, clearly
05:46:29 <ndm> clearly, so why are we having a debate over it?
05:46:41 <eivuokko> mingw is just c rt and set of tools.  You can't say anything about set of tools in a library constant.
05:46:42 <dcoutts> ndm: I'm not debating anything, I'm saying we need to fix it
05:46:59 <ndm> but any proposed fix seems to turn into a debate?
05:47:49 <dcoutts> ndm: I'll aks nominolo to change it to use OS and Arch rather than String and String
05:47:57 <ndm> cool :)
05:47:58 <dcoutts> ndm: but he's out of contact atm
05:48:04 <ClaudiusMaximus> @src maybe
05:48:04 <lambdabot> maybe n _ Nothing  = n
05:48:04 <lambdabot> maybe _ f (Just x) = f x
05:48:07 <ndm> @seen Shimei
05:48:07 <lambdabot> Shimei is in #xmonad and #haskell. I last heard Shimei speak 7h 28m 24s ago.
05:48:23 <dcoutts> ndm: and if/when System.Info.os gives the right anwsers we could move back to using that
05:48:23 <ndm> @karma+ Shimei -- releasing
05:48:23 <lambdabot> Shimei's karma raised to 1.
05:49:33 <dcoutts> ndm: we could move the debate on the libraries list forward if you stop asking for a special case for one OS
05:49:42 <dcoutts> ndm: ie lets have an OS enum
05:49:50 <ClaudiusMaximus> :t (\(l,r) -> maybe r id l)
05:49:57 <lambdabot> forall a. (Maybe a, a) -> a
05:50:17 <dcoutts> ndm: then you and anyone else can trivially define isWindows in terms of that, but standardising on isWindows is hard to sell to everyone
05:50:27 <Saizan> ?type fromMaybe
05:50:28 <lambdabot> forall a. a -> Maybe a -> a
05:50:34 <ndm> dcoutts, i think its necessary, but am happy to ignore it for now, if we have some way of asking isWindows, even if that is pattern matching on something called Windows I'll get over it
05:50:40 <dcoutts> ndm: but it not being a String that's different between different implementations is a much easier sell.
05:51:20 <anybody> how can i do integer division? Int / Int gives me Fractional. but i want Int
05:51:39 <dcoutts> ndm: and I'm not confinced we need any sub-platform distinctions yet and if we do that can be another type, I don't think it needs to go into an OS enumeration
05:51:55 <ndm> dcoutts, again, agreed
05:51:57 <ndm> anybody: div
05:52:07 <ndm> > 42 `div` 7
05:52:08 <lambdabot>  6
05:52:26 <anybody> ndm: thx
05:52:36 <dcoutts> ndm: we could have a subsystem/buildsystem as just a String for if anyone really thinks they need it
05:52:36 * ndm personally thinks that / should be integer division
05:53:12 * anybody thinks the same thing
05:53:21 <ndm> dcoutts, we could, thats for Cabal/GHC people really, since they are really the ones who should care
05:54:26 <anybody> hm. i think / should be defined such that you stay inside the field where you do the operation
05:55:14 <ndm> @type div
05:55:16 <lambdabot> forall a. (Integral a) => a -> a -> a
05:55:18 <ndm> @type (/)
05:55:19 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:55:27 <ndm> they both are
05:55:33 <anybody> oh
05:55:36 <anybody> i see
05:55:40 <ndm> its just 42 / 7 means that 42 and 7 are both floats :)
05:56:14 <ddarius> ndm: What should be float division?
05:56:35 <ndm> ddarius: floats are rarely used, it can be ///////////////////---/* for all i care
05:56:44 <ndm> although more realistically, div would be fine
05:57:08 <ndm>  // would also be a sensible choice
05:57:14 <DRMacIver> Ew. :)
05:57:29 <ddarius> I divide Fractional numbers more often than I divide Integral numbers.
05:57:34 <DRMacIver> I think the current choice is much more sensible.
05:58:06 <DRMacIver> It's close to mathematical conventions if nothing else.
05:58:53 <kosmikus> fwiw, I agree with DRMacIver
05:58:56 <Saizan> do we need to have both integer and float division on the same type?
05:59:08 <ddarius> Saizan: Huh?
05:59:18 * DRMacIver actively dislikes / being overloaded to mean integer division.
05:59:20 <kosmikus> Saizan is probably going to propose to use (/) for both
05:59:29 <Saizan> yup
06:00:01 <ddarius> No.
06:00:05 <kosmikus> that means ghci will say that 7 / 2 is 3 and 7 / 2 + 0.1 is 3.6
06:00:21 <dozer> my 2c is that we should reserve (/) for 'propper' division on floats, and use div/mod or whatever for whole number operations, only defined on integrals
06:00:36 <dozer> and if you realy want to do div on floats, you coerce it to an integral first
06:00:36 <DRMacIver> (Not as much as I dislike overloading + to mean string concatentation though. Ewww.)
06:02:00 <dozer> DRMaclver: it does rather beg the question what the (-) operation on string is :)
06:02:13 <flux> dozer, what about mod on floats?
06:02:46 <dozer> flux, what does mod on float mean?
06:03:10 <DRMacIver> dozer: a - b removes b from the end of a, throwing an exception if a doesn't end with b. Obviously. ;)
06:03:44 <flux> dozer, mod_float 4.0 2.0 = 0.0, mod_float 4.0 2.5 = 1.5
06:04:00 <flux> dozer, so, the same as with integers :)
06:04:27 <DRMacIver> flux: But that's not a homomorphism. :(
06:07:31 <dozer> DRMaclver: pitty that String + String -> String and String - String -> Maybe String don't have nicely matching types :D
06:08:09 <Saizan> exception /= Maybe
06:08:31 <kosmikus> words/strings are a monoid, not a group
06:09:01 <doserj> and (++) should be defined in class monoid ...
06:09:03 <Dimich> who can give me bnc account?
06:09:20 <ddarius> Perhaps if we had a torsor class.
06:09:34 <dozer> torsor???
06:10:34 <ddarius> Take a G-set and define "division" to give elements in G.  I.e. points in a plane form an (abelian) torsor acted on by vectors.
06:11:00 <ddarius> (Often points are sloppily identified with vectors.)
06:15:12 <matthew-_> ok, I have an ffi function which wants to receive float* and then update the values in them. I'm using StablePtr, but it segfaults
06:15:18 <matthew-_> any ideas?
06:15:30 <ddarius> You want a Ptr Float
06:15:40 <ddarius> Ptr CFloat
06:16:08 <matthew-_> ahh, so after reading the docs on StablePtr, I thought that would be ideal
06:16:13 <matthew-_> why is it not?
06:16:37 <ddarius> A StablePtr is just an opaque pointer on the C side.
06:16:38 <SamB_XP> StablePtr only FITS in a pointer
06:16:55 <SamB_XP> it doesn't necessarily actually point AT something in the usual way
06:17:09 <ddarius> matthew-_: What type do you have, StablePtr Float? or some such?
06:17:16 <matthew-_> StablePtr CFloat
06:17:53 <ddarius> The intent of StablePtr is to allow C code to move about Haskell values opaquely.
06:18:02 <matthew-_> ahh. ok.
06:18:03 <matthew-_> so what - create new stable pointers, then cast them to Ptr CFloat, then call the ffi, then deref the stable ptr?
06:18:13 <ddarius> matthew-_: God no.
06:18:41 <matthew-_> ahh, I see - just malloc a block of memory
06:18:44 <ddarius> make an array of CFloats and poke the values into them.
06:18:56 <matthew-_> right, good, that's easy. Thank you.
06:19:05 <ddarius> Array as in Foreign.Marshall.Array
06:19:21 <matthew-_> ja
06:19:37 <ddarius> :t newArray
06:19:45 <lambdabot> Not in scope: `newArray'
06:19:56 <ddarius> @hoogle newArray
06:19:56 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
06:19:56 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
06:19:56 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
06:23:52 <ClaudiusMaximus> @index fmod
06:23:53 <lambdabot> bzzt
06:33:18 <dozer> thanks for pointing me at torsors - they fix a problem we've been having describing properties of physical objects in our ontology
06:33:33 <dozer> among other things
06:47:19 <popcount> Where can I find the most recent user guide for the development version of GHC?
06:47:48 <SamB_XP> popcount: I'm guessing you, um, build it
06:48:36 <SamB_XP> but don't expect it to necessarily be 100% up-to-date with GHC or vice versa
06:49:11 <popcount> SamB_XP, it doesn't happen by default, but if that's the only way I can reliably see one....
06:53:44 <shapr> Funny comment on http://programming.reddit.com/info/2fbtp/comments :
06:53:45 <lambdabot> Title: "the way forward involves functional programming" (reddit.com)
06:53:58 <shapr> I predict that in ten years many in the Haskell community will be where many in the Lisp and Smalltalk communities (of which I am a fellow traveller) are now: bitter, disenchanted, whiners. "but we had that twenty years ago!", "you aren't doing it right!", "this was done so much better in Haskell! Twenty years ago!", "if you really want to understand this stuff you have to learn Haskell"
06:54:37 <shapr> That's pretty funny to me.
06:54:57 * DRMacIver has a sneaking suspicion it's pretty accurate too. :)
06:54:58 <jfredett> heh
06:55:22 <kaol> get off my lawn
06:55:35 <jfredett> people are, by definition, dumb, so I must concur, since only a few will ever actually try to not be dumb
06:55:45 <shapr> DRMacIver: I don't think it's accurate actually.
06:55:47 <jfredett> and insodoing learn lisp, or haskell, or smalltalk
06:55:56 <araujo> shapr, he must not know the Haskell community then
06:56:04 <shapr> araujo: Yeah, that's what I think.
06:56:10 <SamB> shapr: I hope to have left Haskell by then
06:56:23 <ClaudiusMaximus> i've been having fun with arrows, building a little image processing thing at the moment:  http://img105.imageshack.us/img105/3839/maskwl4.png (output)   http://tinyurl.com/2s6vc7 (code)
06:56:29 <DRMacIver> shapr: Conveniently, there's exactly one way to test it, so no point arguing. :) Suffice it to say I will be delighted if proved wrong.
06:56:30 <shapr> Me too, I hope that Epigram is then production quality and I'll have better toys :-)
06:56:30 <wli> I'm just enjoying it while it lasts.
06:56:49 <SamB> see, the thing is that the best 'skellers are smart enough to know that Haskell isn't the be-all end-all
06:57:05 <SamB> me, too ;-P
06:57:12 <apfelmus> ha, how foolish! in 20 years, Haskell will rule the world with absolute power!
06:57:37 <wli> I don't expect programming to be a very widespread profession in 20 years.
06:57:50 * f00li5h is now foolish
06:58:11 <SamB> oh, btw, when I say "by then", I meant "before Haskell gets like that"
06:58:47 <jfredett> Haskell already is like that...
06:58:56 <jfredett> we tell people better ways to do things all the time
06:59:06 <int-e> that's different though
06:59:08 <apfelmus> if at all, other programming languages will only exist as faint phantom types
06:59:12 <shapr> SamB: But... I don't see how dependently typed languages can end up with all three of these features, 1. ubiquitous type inference 2. terminating type checking and 3. support for fix/general recursion.
06:59:23 <SamB> but we definately don't say "it was better in Haskell twenty years ago"
06:59:31 <SamB> maybe 11 years ago...
06:59:36 <popcount> ClaudiusMaximus, how fast does it run?
06:59:41 <shapr> Heh, Haskell is like.. 15 years old, yeh?
06:59:45 <shapr> Or was that five years ago? :-(
06:59:48 <DRMacIver> shapr: I've still not been convinced that 2 is vitally important. :)
06:59:48 <SamB> dunno exactly
06:59:55 <int-e> jfredett: I have yet to see someone complaining about other languages slowly adapting ideas from Haskell, because the people could just use Haskell instead.
07:00:00 <SamB> oh, I meant 9
07:00:11 <SamB> I can't add :-(
07:00:14 <jfredett> well, okay, modulo the "twenty years bit"
07:00:26 <shapr> DRMacIver: Well, it'd suck if you had to randomly wibble your code to get typechecking to terminate.
07:00:36 <jfredett> int-e: theres nothing stopping them from using Lisp now- on todays machines, its plenty fast
07:00:48 <int-e> jfredett: it still has no FFI :P
07:00:51 <SamB> man, Haskell 98 is 9 years old now?
07:00:53 <jfredett> I can't speak for smalltalk, but I'd bet its the same
07:01:12 <SamB> int-e: not standard, true...
07:01:15 <jfredett> int-e: sure it does, I refuse to believe it doesn't have an FFI library somewhere
07:01:15 <int-e> jfredett: (really. that's the reason why I stopped looking at common lisp - I realize that common lisp isn't the whole lisp world)
07:01:20 <shapr> We can ask andyjgill what he thinks!
07:01:23 <shapr> dang
07:01:24 <shapr> no we can't
07:01:26 <dozer> smalltalk is just fine - what lets it down is a set of libraries designed for the pre-internet computing age
07:01:26 <SamB> jfredett: maybe even two of them
07:01:34 <jfredett> SamB Yah!
07:01:43 <shapr> Smalltalk has an Image problem.
07:01:49 <shapr> ooh, we can ask augustss!
07:02:19 <augustss> you could :)
07:02:21 <SamB> but there's definately at least one, which works on multiple implementations of CL using the feature test reader macros
07:02:22 <shapr> augustss: What do you think about http://programming.reddit.com/info/2fbtp/comments/c2fd7q ?
07:02:23 <lambdabot> Title: "the way forward involves functional programming" (reddit.com)
07:02:29 <int-e> jfredett: I suppose pretty much every common lisp implementation comes with its own FFI, but then where's the point in having a standard?
07:02:49 <ClaudiusMaximus> popcount: ./Mask > mask.ppm  43.38s user 0.11s system 81% cpu 53.163 total
07:02:56 <hkBst> int-e: http://common-lisp.net/project/cffi/
07:02:58 <lambdabot> Title: CFFI - The Common Foreign Function Interface
07:02:58 <shapr> ClaudiusMaximus: That's really cute code btw
07:02:59 <jfredett> int-e: I gotta go, sorry guys
07:03:26 <augustss> shapr: do you mean the idea he presents or the actual blog posting?
07:03:42 <shapr> The idea
07:04:34 <SamB> there's one called "uffi", too
07:04:50 <int-e> hkBst: thanks. that's too new for me, I last looked for something like that - I think 5 years ago.
07:05:16 <popcount> How can I reduce the amount of heap memory that's being used?
07:05:29 <popcount> I have an infinite loop and I want to get a stack trace when it's "out of memory".
07:05:38 <augustss> shapr: i hope he's right.  but FP has been around for many years with little attention.  there was a surge in the 80s, but nothing came of that
07:05:52 <int-e> the usual answer is "make your program more lazy. or more strict." ;)
07:06:33 <augustss> shapr: perhaps this time.  at least some ideas, like lambda expressions, are spreading
07:07:02 <int-e> popcount: oh wait. there's a +RTS option for that. -M<size>, that is ./program +RTS -M1M -RTS (assuming ghc and compiled code)
07:07:05 <popcount> ClaudiusMaximus, I suppose you haven't optimized anything, yet?
07:07:26 <dozer> augustss: but the 80s was when OO started to take off in a big way - you get the fig-leaf of type safety with the performance of c and principled abstractio of operation names from the code that implements them
07:07:50 <int-e> popcount: try ./program +RTS --help
07:07:50 <wli> I don't see anything coming of all this essentially because the tech sector overall is going to get wiped out.
07:07:51 <SamB> what ???
07:08:00 <SamB> wli: oh?
07:08:47 <augustss> dozer: it's true that OO started to take off then, but it wasn't new either.  It's hard to predict these things
07:08:56 <ClaudiusMaximus> popcount: no, i haven't mutilated my code to make it faster yet
07:09:37 <popcount> ClaudiusMaximus, I don't think you have to. I just guess you are using lists.
07:09:58 <popcount> ClaudiusMaximus, better question: what are you using?
07:10:22 <ClaudiusMaximus> popcount: lists
07:10:34 <dozer> anyone here use hxt?
07:10:43 <ClaudiusMaximus> back in a bit, cooking lunch
07:10:53 <dozer> my xpickle call is returning Nothing and I'm not quite sure where in the XML it's getting upset
07:11:59 <popcount> ClaudiusMaximus, I guess it's amazing that it still runs that fast.
07:12:23 <popcount> @where anyone
07:12:24 <lambdabot> I know nothing about anyone.
07:13:37 <popcount> Hmm, I only get "heap exhausted" not an actual trace.
07:29:38 <Tchakkazulu> @where hsplugins
07:29:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
07:31:38 <matthew-_> arrays created by mallocArray
07:31:45 <matthew-_> in Foreign.Marshal.Array
07:31:51 <matthew-_> do they get garbage collected?
07:32:10 <sjanssen> @hoogle mallocArray
07:32:11 <lambdabot> Foreign.Marshal.Array.mallocArray :: Storable a => Int -> IO (Ptr a)
07:32:11 <lambdabot> Foreign.Marshal.Array.mallocArray0 :: Storable a => Int -> IO (Ptr a)
07:32:11 <lambdabot> Foreign.Marshal.Pool.pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)
07:32:21 <sjanssen> matthew-_: no, they don't
07:32:21 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
07:32:26 <matthew-_> sjanssen: thank you
07:49:24 <shapr> Are the new list comprehensions implemented in ghc 6.7 ?
07:49:44 <wli> What are the new list comprehensions?
07:50:34 <shapr> Um, the "group by" and friends
07:50:55 * shapr gets url
07:51:20 <shapr> @go haskell list comprehension "group by"
07:51:22 <lambdabot> http://research.microsoft.com/~simonpj/papers/list-comp/index.htm
07:51:22 <lambdabot> Title: Comprehensive Comprehensions
07:51:29 <shapr> or http://lambda-the-ultimate.org/node/2366
07:51:30 <lambdabot> Title: Comprehensions with ‚ÄòOrder by‚Äô and ‚ÄòGroup by‚Äô | Lambda the Ultimate
07:52:39 * wli ponders the factorization of (10^(10^n)-1) `div` 9
07:53:21 <shapr> Are you doing Project Euler problems?
07:53:55 <wli> Yeah. I'm too brainfried to do much else.
07:54:05 <wli> I've got maybe an hour before I have to start work.
07:54:11 <novaburst> I'm new to Haskell and I am reading whatever I can about the language. For news, I've been reading reddit, planet haskell, the news groups fa.haskell and comp.lang.haskell, anything else I should check out?
07:54:28 <shapr> gmane.comp.lang.haskell.cafe
07:54:50 <novaburst> ok, thank you
07:55:13 <shapr> novaburst: Do you use gmane.org for mailing list reading?
07:55:31 <shapr> novaburst: Also, lots of interesting Haskell stuff gets discussed here on #haskell before it shows up anywhere else.
07:55:35 <novaburst> never have, no.
07:55:52 <novaburst> i've been hanging out here daily now :)
07:55:56 <shapr> spiffy
07:56:10 <shapr> If you use gnus for mail/news reading, gmane is especially awesome.
07:56:38 <profmakx> damn those factors are large o.o
07:57:11 <shapr> Sometimes I wish #haskell were a jabber group chat instead of an IRC channel.
07:57:11 <novaburst> shapr: cool, i'll definitely check it out
07:57:23 <shapr> @users
07:57:23 <lambdabot> Maximum users seen in #haskell: 385, currently: 374 (97.1%), active: 17 (4.5%)
07:57:30 <shapr> novaburst: So, how'd you get into Haskell?
07:59:00 <novaburst> shapr: I was wanting to improve my programming skills (i basically know basic languages, like asp, vb), so I was recommended by a friend to learn CL and Haskell.
07:59:10 <shapr> I got started with Haskell because I was trying to write Python code that had only one single return, and always could replace a call to its code with its result. Darius Bacon then said I should check out Haskell, and I was instantly in love!
07:59:34 <shapr> So I decided to start an irc channel...
07:59:45 <novaburst> nice :)
07:59:57 <shapr> Yeah, #haskell has worked out well.
08:00:25 <shapr> This isn't the first #haskell, but the previous one (from 2000(?) I think) didn't succeed, and I didn't know about it.
08:00:32 <shapr> novaburst: So what do you think so far?
08:00:41 <Japsu> Well, this #haskell has clearly succeeded. :)
08:00:44 <Japsu> @users
08:00:44 <lambdabot> Maximum users seen in #haskell: 385, currently: 372 (96.6%), active: 16 (4.3%)
08:01:00 <shapr> I got started with BASIC on the Sinclair Spectrum some... 24 years ago.
08:01:24 <shapr> Then years later I did Visual Basic 3/4 for my first programming job.
08:01:27 <novaburst> I have been dabbling in CL for the past 3 months or so. Haskell to me so far has better support for the beginner in my opinion.
08:01:33 <pgavin> I got started with C64 basic... some 20 years ago
08:01:38 <MyCatVerbs> I got started on a bicycle, about twelve years back.
08:01:42 <MyCatVerbs> Getting stopped was more challenging.
08:01:45 <shapr> MyCatVerbs: hah, youngster!
08:01:55 <pgavin> lol
08:02:05 <novaburst> shapr: i got started on a C64 in BASIC in the 80s when I was a young pup
08:02:21 <shapr> Yeah, C64 was fun.
08:02:38 <MyCatVerbs> shapr: jah, wet-behind-the-ears student. But it has its advantages, I can get _wrecked_ and come out with barely a scrap of a hangover, plus my stomach is still robust enough to eat greasy shit without indigestion. :)
08:02:43 <novaburst> peek and poke was all the rage
08:02:43 * shapr tries to remember LOAD 8,* or something
08:02:53 <novaburst> hehe, there ya go
08:03:09 * shapr finds this on google: LOAD "*",8,1 
08:03:24 <novaburst> yes, i was just trying to remember the exact syntax
08:03:24 <pgavin> lol
08:03:31 <pgavin> then RUN
08:03:48 <shapr> MyCatVerbs: I thought the advantage of being a young student was that your brain was still flexible because of lack of alcohol intake, so you could learn lots of stuff quickly?
08:04:51 <shapr> I got started with the internet in 1988-1989, taught myself assembler with DEBUG.COM, and since I thought that was all there was to programming, decided it be for insane people.
08:04:57 <novaburst> i have noticed the #haskell channel is a lot less stressful than the #lisp channel  ;)
08:05:11 <shapr> We do get stressful people here sometimes.
08:05:14 <shapr> @keal
08:05:14 <lambdabot> intuitive != imperative
08:05:17 <shapr> @keal
08:05:17 <lambdabot> T seems to be haskell, except with a decent interface at this point
08:05:21 <novaburst> shapr: hehe, yeah assembler is crazy
08:05:23 <shapr> @protontorpedo
08:05:23 <lambdabot> are objects kina just subroutines
08:05:39 <pgavin> back in the day, before floppy disks became all the rage, they used to distribute software by converting the machine code to decimal digits, and printing out all of them in a magazine
08:05:54 * roconnor wonders what the #lisp channel is like
08:06:10 <shapr> novaburst: The worst thing is that with DEBUG.COM you can only edit one line at a time. I wish I'd been smart enough to write my own asm editor with multiline editing.
08:06:14 <roconnor> shapr: me too.  I got started with a ZX81
08:06:31 <pgavin> so my Dad had one of these magazines, and I was going to put the code into his C64 so I could play whatever game it was for
08:06:52 <pgavin> anyhow, it took about 3 hours of copying, and the game never worked
08:06:59 <novaburst> i remember typing in many programs from magazines like RUN magazine
08:07:10 <MyCatVerbs> shapr: oh? So I might just manage to stay flexible unto old age, then, on my alcohol intake.
08:07:10 <wli> I started at uni with Sequent Symmetry 2000's, monochrome Sun IPC's and IPX's, Gould NP's, and some other garbage.
08:07:12 <pgavin> yeah, I did that too
08:07:13 <flux> pgavin, the finnish version of that concept had a checking software also
08:07:15 <roconnor> although often we got games on audio cassette rather than magazines
08:07:19 <flux> pgavin, so there was a checksum after each line
08:07:19 * MyCatVerbs <-- lightweight/cheap drunk
08:07:32 <roconnor> or played games on the VAX games account on the Atomic Energy of Canada computers.
08:07:40 <pgavin> flux: right, I'm sure this one did too, but the game still didn't work :/
08:07:56 <flux> pgavin, or you beat the odds of entering faulty data ;-)
08:07:58 <roconnor> 300 baud is good enough for anyone.
08:08:06 <shapr> I can read at 300 baud just fine.
08:08:11 <shapr> Heck, I can read at 1200 baud.
08:08:12 <pgavin> lol
08:08:37 <shapr> That was my present from my uncles for graduating high school, a 1200 baud modem.
08:08:40 <novaburst> i remember getting a 1200 baud modem and thinking i was really kicking rear end
08:08:48 <pgavin> my girlfriend talks at about 2400 or 4800 baud :)
08:09:04 <Botje> pgavin: but that's uncompressed audio :P
08:09:09 <shapr> Your girlfriend is an experienced geek?
08:09:15 <pgavin> lol
08:09:23 <novaburst> hehe
08:09:30 * earthy only got a modem when 14k4 was the usual rate
08:09:32 <shapr> On the downside, I ran up a huge phone bill calling BBSs in New Jersey and places like that.
08:10:03 <shapr> On the good side, that encouraged me to find out that UTK had a dial-in block that let you telnet to any IP address.
08:10:11 <pgavin> I remember having a 9600 baud modem
08:10:18 <pgavin> and doing the bbs thing
08:10:29 <pgavin> that was when I was about 12 or 13
08:10:30 <novaburst> shapr: yes, it was eay to run up your phone bill then
08:10:42 * roconnor wonders if BBS's still exist.
08:10:45 <pgavin> then my friend got internet access when I was about 14
08:10:57 <shapr> roconnor: I think there are one or two left.
08:11:44 <pgavin> then I asked my mom for a 14.4k modem for my birthday or something
08:11:52 <pgavin> it was like a hundred bucks
08:12:05 <shapr> Does anyone know if "Faster laziness using pointer tagging" is implemented in GHC 6.7 in darcs?
08:12:18 <earthy> alexey would, lemme check
08:12:22 <earthy> he just walked out
08:12:30 <shapr> I could just ask on #ghc
08:12:45 * shapr just pulls the ghc repo
08:13:08 <earthy> ISTR it was, but I'm not sure
08:13:09 <shapr> pgavin: What were those compression/correction levels that went from 1 to 10?
08:13:22 <shapr> Name of a company... hmm
08:13:30 <pgavin> oh
08:13:38 <pgavin> wait, I think I know what you mean.
08:13:51 * shapr tries to remember
08:14:18 <shapr> MNP?
08:14:43 <pgavin> yep
08:14:49 <allbery_b> <shapr> Does anyone know if "Faster laziness using pointer tagging" is implemented in GHC 6.7 in darcs?
08:14:52 <pgavin> http://en.wikipedia.org/wiki/Modem about 1/3 down
08:14:53 <lambdabot> Title: Modem - Wikipedia, the free encyclopedia
08:14:56 <allbery_b> was annunced last week, wasn't it?
08:14:59 <shapr> allbery_b: Is that a yes?
08:15:01 <allbery_b> (as having been implemented)
08:15:06 <allbery_b> that' an "I think so"
08:15:25 <shapr> pgavin: ah, spiffy
08:15:34 <shapr> Microcom!
08:15:37 <shapr> That's the name I was trying to remember.
08:15:43 <pgavin> ah, yeah
08:16:10 <pgavin> ugg, I'm so glad I don't have to deal with that anymore
08:16:11 <allbery_b> oh, der, there's something I didn't need to remember :)
08:16:25 <Nucleo> Do lists have a length limit dependent on the size of Int?
08:16:36 <shapr> zmodem sure was cool.
08:16:41 <shapr> Nucleo: nope
08:16:50 <novaburst> pgavin: i remember having a Supra (i think thats the name)
08:16:56 <shapr> Nucleo: You can make lists as big as you can stand.
08:17:07 <shapr> Yeah, I always wanted a courier.
08:17:09 <Nucleo> shapr: so for really big lists, I can't use the built-in length function?
08:17:11 <samreid> Nucleo: see genericLength
08:17:21 <pgavin> novaburst: yeah, I had a sportster
08:17:24 <shapr> Yeah, length should not be bound by Int
08:17:39 <Nucleo> ahh, thank you
08:18:19 * shapr wants recordings of the 14.4k 'boing boing' sound
08:18:31 <novaburst> haha
08:18:57 <pgavin> I thought that was the faster 56k that did that
08:19:01 <shapr> Oh, maybe so
08:19:04 <pgavin> sounds like sonar or something
08:19:23 <shapr> It's too bad turbo codes weren't around when modems were in vogue, I bet they'd help.
08:19:25 <pgavin> I always wanted to be able to decipher a modem
08:19:41 <shapr> By listening?
08:19:48 <pgavin> oh, yeah
08:19:55 <shapr> Write a Haskell program :-)
08:19:59 <pgavin> that would rule
08:20:11 <shapr> Yeah, it'd be nifty to write a pure software modem.
08:20:19 <shapr> hiya xynn, learning Haskell?
08:20:50 <novaburst> ok, a quick programming question. To start learning Haskell I would like to write an old style text adventure. I have never written a two word (verb,noun) parser. Do you guys have any general direction you can give me?
08:21:02 <shapr> Parsec!
08:21:20 * shapr gets url
08:21:29 <xynn> shapr: yes! I know almost nothing at this point
08:21:40 <shapr> novaburst: Here, read this and ask questions: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
08:21:53 <shapr> novaburst: Parsec is available in all GHC installations that I've seen.
08:22:04 <Cale> hmm
08:22:13 <shapr> xynn: Cool! Do you have any specific questions, or do you want links to a tutorial, or what can I help you with?
08:22:20 <novaburst> shapr: sweet, ok, i'm at work at the moment, but i'll read it and get back with questions later
08:22:31 <doserj> shapr: for starter, even 'Prelude.words' would probably do
08:22:43 <shapr> Hm, yeah
08:22:51 <shapr> But Parsec is just so darn sexy!
08:22:54 <xynn> shapr: Sure, I'll take any links you have. Not sure how much I can do right now (work) but I'll take a look later tonight
08:23:07 <Cale> novaburst: Parsec is a rather good way to put parsers together, but for something so simple, you might be able to get away with a much simpler parsing strategy, as doserj just pointed out :)
08:23:14 * novaburst will check out Prelude.words too then
08:23:32 <shapr> xynn: This is linked from the front page of haskell.org - http://www.haskell.org/haskellwiki/Learning_Haskell
08:23:33 <lambdabot> Title: Learning Haskell - HaskellWiki
08:23:46 <Cale> novaburst: Of course, you'll want to think a bit about how to represent the rooms and how they're connected up and so on. Data.Map might be a good option for storing that information.
08:23:46 <shapr> xynn: But the best advice I can give you is to hang out here on #haskell and ask questions when you have them.
08:24:18 <xynn> thanks shapr
08:24:24 <shapr> xynn: Lots of friendly smart people hang out here. I hang out here too ;-)
08:24:24 <novaburst> thanks guys!
08:24:27 <thoughtpolice> novaburst: parsec is a really good library, but try your hand at just a couple of ad hoc parsers first.
08:24:31 <Cale> http://www.haskell.org/haskellwiki/Haskell_in_5_steps :)
08:24:32 <lambdabot> Title: Haskell in 5 steps - HaskellWiki
08:24:44 <thoughtpolice> novaburst: check out functions like drop, dropWhile, take, words, unwords, etc. etc..
08:25:06 <Cale> > words "hello this is a test"
08:25:07 <shapr> > drop 5 [1..9]
08:25:12 <lambdabot>  ["hello","this","is","a","test"]
08:25:12 <lambdabot>  [6,7,8,9]
08:25:16 <thoughtpolice> they can all be found in the prelude and you can construct useful but primitive parsers from them.
08:25:32 <shapr> > dropWhile (< 5) [1..9]
08:25:33 <lambdabot>  [5,6,7,8,9]
08:25:41 <Cale> (the prelude is the module which is loaded by default in all Haskell programs)
08:25:46 <thoughtpolice> (my irc bot uses this approach although I don't like it, I was actually considering parsec because I feel the code is more ugly, it's more of an exercise for me than a learning thing though)
08:25:52 <thoughtpolice> novaburst: for example,
08:25:58 <shapr> What's up with all the parenthesized statements?
08:26:05 <thoughtpolice> > dropWhile (/=':') "abc:def"
08:26:06 <lambdabot>  ":def"
08:26:06 <Cale> hehe
08:26:08 <shapr> (Oh never mind ;-)
08:26:30 <Cale> shapr: ITYM "(What's up with all the parenthesized statements?)"
08:26:44 <thoughtpolice> they're really basic list manipulation functions, but lists are strings, so you can do some fun stuff. :)
08:26:52 <shapr> (hah yes!)
08:27:19 <shapr> You mean, strings are lists, yeah?
08:27:27 <thoughtpolice> yes :(
08:27:29 * thoughtpolice is dumb
08:27:36 * shapr is just teasing
08:27:58 <shapr> thoughtpolice: I get stuff spoonerized all the time, so I know how you feel.
08:28:07 <thoughtpolice> shapr: :)
08:28:09 <novaburst> thoughtpolice: will do, thank you :)
08:28:32 * novaburst loves the #Haskell channel already
08:28:36 <thoughtpolice> novaburst: np. ghci and lambdabot (in here) are your friends, so if you want to test them that'd be a really good way to do it.
08:29:32 <Itkovian> any of you guys going to OOPSLA by any chance?
08:30:01 <novaburst> thoughtpolice: ok, sounds good
08:32:42 <Cale> > fix ((0:) . scanl (+) 1)
08:32:44 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:33:25 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
08:33:25 <lambdabot>  Parse error
08:33:28 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:33:29 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:34:01 * Saizan sees fixpoints floating around
08:35:08 <shapr> fix it!
08:35:25 <Cale> > fix ((0:) . (1:) . ap (zipWith (+)) tail)
08:35:27 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:35:31 <shapr> ooh
08:35:42 <shapr> @fix 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:35:42 <lambdabot> Maybe you meant: faq ft id thx
08:35:45 <shapr> aww
08:35:54 <shapr> I thought it might work like @pl
08:36:19 <Cale> @pl \fibs -> 0 : 1 : zipWith (+) fibs (tail fibs)
08:36:19 <lambdabot> (0 :) . (1 :) . ap (zipWith (+)) tail
08:36:22 <kjdf> is there a difference between:
08:36:22 <kjdf> sunzip (Cons (a,b) xs) = (Cons a as, Cons b bs) where ~(as,bs) = sunzip xs
08:36:25 <kjdf> and sunzip (Cons (a,b) xs) = (Cons a as, Cons b bs) where (as,bs) = sunzip xs
08:36:25 <shapr> ah!
08:36:33 <kjdf> (irrefutable pattern)
08:36:54 <kjdf> 'where' introduces some level of laziness by itself
08:37:11 <Cale> kjdf: No, there's no difference, because that's a pattern binding already
08:37:25 <Cale> Pattern bindings are by default lazy matches.
08:37:38 <Cale> You only need ~ in function parameters.
08:37:49 <kjdf> ok
08:37:50 <kjdf> thanks
08:38:07 <Cale> > let 0 = 1 in 0 + 0
08:38:08 <lambdabot>  0
08:40:11 <kjdf> (I rewrote it from function and that's why ~ left over)
08:40:59 <ClaudiusMaximus> more arrow experiments, this time generating moving images:  http://img504.imageshack.us/img504/4830/mandelst7.gif << output || source code >> http://tinyurl.com/2m7e45
08:41:02 <thoughtpolice> hm. :)
08:41:03 <thoughtpolice> http://xkcd.com/303/
08:41:04 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
08:42:00 <shapr> ClaudiusMaximus: cute!
08:42:11 <ClaudiusMaximus> :)
08:43:12 <kjdf> what is Zirkit?
08:43:26 <kjdf> ah, nm.
08:43:35 <ClaudiusMaximus> kjdf: needed a name to satisfy svn
08:43:55 <ClaudiusMaximus> kjdf: seemed as good as any..
08:43:59 <shapr> Has anyone tried to compile STG to Javascript?
08:44:22 <Cale> looks like the stream transformer arrow
08:44:34 <kjdf> (I meant 'import Zirkit', but then I realized it was a svn repo where I can check myself for Zirkit.hs)
08:48:07 <dcoutts> shapr: yhc has a backend that compiler yhc core to javascript
08:48:17 <dcoutts> compiler/compiles
08:48:58 <thoughtpolice> ycr2js right?
08:50:34 <xtacy[]> Cale: Your first Monad tutorial was very nice. I especially liked the apples/blueberries analogies!
08:50:42 <Cale> xtacy[]: thanks :)
08:50:55 <xtacy[]> Cale: but, I guess I need some time for it to sink in, since I am not very familiar with Functors / Category Theory
08:51:45 <Cale> That's okay. Also, you don't actually have to understand category theory completely in order to understand functors in Haskell.
08:51:51 <wolverian> hmph. so the .flv I downloaded of simon's oscon haskell tutorial was only the first part of the tutorial. anyone have a url for the second part?
08:52:26 <xtacy[]> Cale: Knowing the Mathematical background sometimes helps to model real life situations better!
08:52:32 <Cale> that's true :)
08:52:35 <pjd> xtacy[]: functors are the easy ones!
08:53:04 <xtacy[]> pjd: Doesnt the dependency follow this way: Category theory and *then* functors?
08:53:33 <Cale> A Functor as far as Haskell is concerned (which is really called an endofunctor in category theory) is really just a type constructor T with a function fmap :: (a -> b) -> (T a -> T b)
08:53:36 <xtacy[]> pjd: Browsing wikipedia tells me so...
08:53:59 <Cale> So you can think of it as just some data structure holding elements of some type, with a way to apply a function to all those elements
08:54:16 <pjd> xtacy[]: category theory is heavy;  you don't need it to work usefully with Haskell functors
08:54:17 <Cale> At least, that's what many of them are like.
08:54:48 <xtacy[]> Cale: These definitions are fancy :) Unless I try out something that uses them, it will take some time for me...
08:54:55 <pjd> a functor is basically a generalization of map to other data structures besides lists
08:55:00 <Cale> > fmap (*10) (Just 5)
08:55:02 <xtacy[]> Cale: I am thinking of some nice stuff for my Software Engineering project
08:55:02 <lambdabot>  Just 50
08:55:09 <Cale> > fmap (*10) [1,2,3,4,5]
08:55:11 <lambdabot>  [10,20,30,40,50]
08:55:20 <xtacy[]> Cale: Ah, thats nice
08:55:56 <xtacy[]> pjd, Cale: Got any nice ideas?
08:55:56 <shapr> dcoutts: Is there a nice way to dump STG from GHC?
08:55:59 <anybody> hey is there a fast way to chack for duplicate elements int a list?
08:56:05 <anybody> s/chack/check/
08:56:13 <anybody> s/int/in/
08:56:24 <dcoutts> shapr: ghc -c Foo.hs -ddump-stg -o Foo.stg
08:56:45 <dcoutts> shapr: ghc -c Foo.hs -ddump-simpl -o Foo.core
08:56:51 <xtacy[]> I thought of a module for handling Symbolic Algebra, and another for modeling Relational Databases
08:57:56 <Cale> hasDuplicate xs = or [x == y | (x:ys) <- tails xs, y <- ys]
08:58:23 <wli> xtacy[]: Lots of efficient ways, too.
08:58:27 <shapr> dcoutts: But no way to get access to the STG output from inside say, Template Haskell?
08:58:50 <xtacy[]> Okay, can anyone tell me in what form a grammar should be, for parsing an input correctly using Parsec?
08:58:51 <Cale> xtacy[]: those can both be quite fun :)
08:58:53 <dcoutts> shapr: no, TH happens much earlier, you only get Haskell AST
08:58:55 <xtacy[]> wli: ?
08:58:59 <anybody> Cale: thx
08:59:24 <shapr> aww :-(
08:59:38 <shapr> I wonder if ghc-api can access the STG?
08:59:47 <Cale> anybody: Or you could just try  nub xs == xs :)
09:00:10 <Cale> that actually ought not to be so bad
09:00:20 <anybody> Cale: where is hasDuplicate defined?
09:00:22 <xtacy[]> Cale: Does Haskell Wiki have links to nice projects in Haskell?
09:00:28 <Cale> anybody: I just defined it there
09:00:33 <xtacy[]> anybody, he just defined it
09:00:41 <anybody> doh.
09:00:53 <Cale> http://www.haskell.org/haskellwiki/Applications_and_libraries
09:00:54 <lambdabot> Title: Applications and libraries - HaskellWiki
09:01:19 <xtacy[]> Ah, wonderful
09:01:39 <Cale> also: http://hackage.haskell.org/packages/hackage.html
09:01:40 <lambdabot> Title: HackageDB: introduction
09:04:05 <Cale> anybody: actually in some cases, xs /= nub xs would be much faster :)
09:04:30 <anybody> Cale: why?
09:04:47 <Cale> It will actually terminate on an infinite list which has a duplicate element
09:04:54 <mrd> does nub re-order
09:05:01 <Cale> no
09:05:07 <mrd> yea, then laziness wins
09:05:20 <Cale> Plus it has good performance with regard to throwing away parts of the list which it's finished with.
09:05:38 <anybody> hm. not nowing nub makes me feel like a n00b
09:05:40 <anybody> s/nowing/knowing/
09:05:55 <mrd> heh, I was looking for 'removeDuplicates' for ages before I discovered 'nub'.
09:05:57 <Cale> > nub "hello, world!"
09:06:02 <lambdabot>  "helo, wrd!"
09:06:15 <lament> @hoogle nub
09:06:15 <lambdabot> List.nub :: Eq a => [a] -> [a]
09:06:15 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
09:06:28 <anybody> @hoogle n00b
09:06:28 <lambdabot> No matches found
09:06:34 <anybody> @hoogle noob
09:06:34 <lambdabot> No matches found
09:06:45 <Cale> > nubBy (\y x -> x `mod` y == 0) [2..]
09:06:46 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:06:47 <anybody> @hoogle noobBy
09:06:48 <lambdabot> No matches found
09:06:58 <mrd> rofl, I was just thinking about that Cale
09:07:12 <Cale> (that's a pretty inefficient way to generate primes, but it's fun :)
09:07:35 <anybody> haha
09:07:43 <lament> i bet the function made it into the library for precisely that purpose
09:09:42 <Cale> Well, it's generally pretty useful when you want to remove duplicates modulo some equivalence relation.
09:10:56 * Cale recalls using nubBy with hgal to find lists of graphs up to isomorphism.
09:12:16 <int-e> > or . ap (zipWith Data.Set.member) (scanl (flip Data.Set.insert) Data.Set.empty) $ [1,2,3,4,5,6,7,8,9,2,10,11,12]
09:12:18 <lambdabot>  True
09:12:40 <Cale> > let hasDuplicate xs = xs /= nub xs in hasDuplicate ([1..10000] ++ [10000..20000])
09:12:43 <lambdabot>  True
09:13:06 <Cale> > let hasDuplicate xs = or [x == y | (x:ys) <- tails xs, y <- ys] in hasDuplicate ([1..10000] ++ [10000..20000])
09:13:09 <lambdabot> Terminated
09:13:39 <Cale> (showing the advantage of the easy solution :)
09:13:57 <Cale> > let hasDuplicate xs = or . ap (zipWith Data.Set.member) (scanl (flip Data.Set.insert) Data.Set.empty) in hasDuplicate ([1..10000] ++ [10000..20000])
09:13:59 <lambdabot>  <[Integer] -> Bool>
09:14:08 <Cale> > let hasDuplicate = or . ap (zipWith Data.Set.member) (scanl (flip Data.Set.insert) Data.Set.empty) in hasDuplicate ([1..10000] ++ [10000..20000])
09:14:09 <lambdabot>  True
09:15:08 <anybody> is there already an implementation of C(n,k) somewhere in a std haskell lib?
09:15:18 <Cale> Unfortunately not
09:15:40 <anybody> hrm
09:15:40 <dolio> It's pretty light on that sort of thing.
09:15:51 <Cale> There's not even a permutations function.
09:15:57 <Cale> however
09:15:59 <anybody> yup
09:16:00 <int-e> oh favourite implementations of C(n,k). mine is  c 0 k = 1; c n k = c (n-1) (k-1) * n `div` k
09:16:11 <anybody> i took oleg's shuffle
09:16:22 <anybody> and extended it a little to use RandomGen a
09:16:24 <lament> recursion is ugly
09:16:31 <int-e> no it's not :)
09:16:37 <lament> int-e: that's not even tail-recursive
09:16:52 <lament> therefore, probably the least efficient way to compute it
09:17:13 <dolio> There are definitely less efficient ways. :)
09:17:45 <Cale> > let c n k = length $ filter ((== k) . length) . filterM (const [True,False]) $ [1..n] in map (c 7) [0..7]
09:17:48 <lambdabot>  [1,7,21,35,35,21,7,1]
09:17:58 <int-e> lament: it's a trade-off between reasonable speed, reasonable overflow behaviour on small types and ease of implementation.
09:18:10 <Cale> mwahaha, even less efficient :)
09:18:19 <Cale> but pretty :)
09:18:22 <int-e> Cale: haha.
09:18:32 <lament> is overflow behaviour an actual problem in haskell?
09:18:35 <hpaste>  anybody pasted "C(n,k)" at http://hpaste.org/2260
09:18:43 <shapr> lament: It is if you use Int
09:18:46 <int-e> lament: sure if you're doing calculations with Int or Word
09:18:48 <anybody> unfort. it messed up my whitespace
09:18:51 <shapr> But the solution is, don't use Int.
09:18:58 <lament> that's what i thought...
09:19:02 <Cale> > let c n k = length . filter ((== k) . length) . filterM (const [True,False]) $ [1..n] in [map (c n) [0..n] | n <- [0..]]
09:19:06 <lambdabot> Terminated
09:19:07 <int-e> shapr: well ... sometimes I want. I usually know what I'm doing in those cases :)
09:19:22 <Cale> > let c n k = length . filter ((== k) . length) . filterM (const [True,False]) $ [1..n] in take 10 [map (c n) [0..n] | n <- [0..]]
09:19:23 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
09:22:47 <Cale> > let c n = map length . groupBy (\x y -> fst x == fst y) . sortBy (comparing fst) . map (length &&& id) . filterM (const [True,False]) $ [1..n] in c 10
09:22:49 <lambdabot>  [1,10,45,120,210,252,210,120,45,10,1]
09:24:00 <xtacy[]> @hoogle X11
09:24:01 <lambdabot> No matches found
09:24:01 <Tchakkazulu> O_o, nifty code.
09:24:22 <shapr> @tell dons I got  a lovely crash and backtrace for Frag on x86_64 : http://www.scannedinavian.com/~shae/frag.error.txt
09:24:23 <lambdabot> Consider it noted.
09:28:15 <int-e> > let c = iterate (\xs -> zipWith (+) (xs ++ [0]) (0:xs)) [1] in c !! 10
09:28:16 <lambdabot>  [1,10,45,120,210,252,210,120,45,10,1]
09:30:17 <int-e> > let c = iterate (scanl1 (+)) (repeat 1) in [c !! (n-k) !! k | let n = 10, k <- [0..n]]
09:30:19 <lambdabot>  [1,10,45,120,210,252,210,120,45,10,1]
09:44:25 <dylan> yeah
09:44:57 <dylan> anyone know what the status of ghci/runghc under ppc?
09:45:05 <dylan> *linux-ppc
09:45:08 <shapr> @quote beard
09:45:08 <lambdabot> Igloo says: * shapr is desperately trying to grow a beard at this point... // <Igloo> You normally grow beards over partial non-Euclidean planes, not at points
09:45:35 <opqdonut> hih
09:45:52 <lament> there's no HSU?
09:45:58 <shapr> @quote HSU
09:45:59 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
09:45:59 <lament> wrong window...
09:46:12 <shapr> Hm, where did that quote go?
09:46:17 <shapr> The one about the Haskell Secret Underground?
09:46:23 <lament> forget i ever said it. There isn't, and has never been, any "HSU".
09:46:32 <shapr> Hyv√§√§ huomenta kaikilla!
09:46:37 <lament> of course there's no quote about HSU, since there's no HSU.
09:47:18 <shapr> suomea r0xx0rs
09:50:42 <eivuokko> ITYM suomi r0xx0rs
09:51:12 <shapr> er, right
09:51:25 <shapr> It's fun, but I never was any good at it.
09:52:29 <shapr> Any language where j√§rjestelm√§llist√§m√§tt√∂myydell√§√§ns√§k√§√§nk√∂h√§n is a legal word is hard to be good at.
09:53:18 <kaol> I'm hoping that you didn't just write that from memory (that was correct, btw)
09:53:31 <shapr> Nah, I didn't write that from memory :-)
09:53:44 <vegai> I wonder what it means.
09:53:51 * shapr laughs
09:53:59 <lament> it's finnish, it doesn't mean anything
09:54:02 <vegai> please use it in a sentence :)
09:54:05 <lament> probably just a case ending :)
09:54:07 * shapr screams
09:54:14 <shapr> vegai: Nooo
09:55:04 <Igloo> Looks like a pyramid scheme to me. Something about sending a Dell to everyone on a mailing list.
09:55:15 * shapr snickers
09:55:15 <vegai> are there any obfuscated natural language contests?
09:55:34 <shapr> vegai: I think Finnish would just win :-(
09:55:53 <shapr> C'mon, seventeen possible conjugations, all of which can be used at the same time?
09:57:00 <Lamperi> :D
09:58:06 <vegai> so Finnish is the language of choice for a discriminating befuddler
09:58:15 <shapr> Truly
09:58:55 <lament> certainly 17 is not a very big number of cases
09:59:00 <shapr> Ithkuil is scarier, but it's also artificial.
09:59:03 <lament> there're languages with like 40
09:59:24 <shapr> lament: Yeah, but.. if they can all be used together, then it's 17! possible cases right?
09:59:30 <augustss> is finnish like swedish in that you can make arbitrarily long words?
09:59:39 <lament> shapr: i think you're probably confused about them being able to be used together
09:59:40 <samreid> Yeah, but when you've used Finnish, you've done it after having walked uphill in the snow both ways.  Literally.
09:59:55 <shapr> lament: I lived in Finland for 3.5 years.
10:00:06 <shapr> I tried to learn the language.
10:00:19 <lament> that's understandable
10:00:23 <shapr> It wasn't to me!
10:01:07 <shapr> augustss: Finnish is an agglutinative language, it's got more long word potential than Swedish.
10:01:35 <shapr> Roughly speaking, you can stick prepositions and stuff to the end of words.
10:02:18 <lament> shapr: are you talking about noun cases?
10:02:25 <lament> when you mention "17 conjugations"
10:03:20 <shapr> lament: http://en.wikipedia.org/wiki/Finnish_language_noun_cases
10:03:21 <lambdabot> Title: Finnish language noun cases - Wikipedia, the free encyclopedia
10:03:44 <lament> right, that's what i assumed
10:03:58 <lament> first of all, i see 15 in that table...
10:04:09 <shapr> Yeah, but I think they left out at least one of the rarely used cases.
10:04:15 <shapr> Or maybe I'm just forgetting :-(
10:05:08 <lament> i don't see anything about the possibility of _combining_ cases, though
10:05:59 <wolverian> you can't use multiple cases on the same base, no
10:06:19 <wolverian> plenty of other suffixes to confuse you, though, so it's not really needed
10:06:19 <lament> at the same time?
10:06:23 <wolverian> right
10:07:03 <lament> at the same time, as in one noun having more than one case?
10:07:17 <wolverian> right :)
10:07:22 <wolverian> that is not allowed.
10:07:28 <lament> that's what i thought.
10:07:38 <shapr> lament: Ok, I was wrong.
10:07:51 <shapr> Now I have the urge to learn more Finnish.
10:08:07 * shapr learns more Swedish instead.
10:08:53 <lament> http://en.wikipedia.org/wiki/Tsez_language#Case
10:08:55 <shapr> wolverian: So what about saunassani ?
10:09:11 <lament> "counting the locative and non-locative cases together, there are a total of 64." :)
10:09:13 <shapr> That breaks down into "at my sauna", yeah?
10:09:22 <wolverian> shapr, in my sauna, to be exact
10:09:23 <shapr> lament: scary!
10:09:29 <wolverian> the "my" is not a case though
10:09:48 <shapr> Ah
10:10:41 * shapr tries to figure out how to say "in my saunas"
10:11:11 <shapr> saunassanit ?
10:11:16 <ari> shapr: saunoissani
10:11:17 <wolverian> saunoissani :)
10:11:19 <shapr> bah
10:11:33 * shapr move his off-topic meanderings to #haskell-blah
10:11:37 <eivuokko> dcoutts, I'd like Cabal configure to have options to modify package version for install/build.  In practice, I want to add "tag" and similar functionality as sdist --snapshot.  Do you think that's insensible addition?
10:11:56 <wolverian> hey, I'm not there :)
10:12:04 <wolverian> now I am
10:12:30 <dcoutts> eivuokko: you want to say: setup configure --snapshot
10:13:04 <dcoutts> eivuokko: and have it add a data tag to the version when you subsequently build and register?
10:13:22 <dcoutts> eivuokko: that seems sane and useful
10:13:23 <desegnis> On a side note, according to the sound files at <http://www.lingvo.info/sondosieroj/sondosieroj.php?lingvo=en>, Finnish people speak terribly fast, while Hungarian people speak slowly and clearly. If it shall be a scary European language, I'll better learn Hungarian then
10:14:12 <shapr> desegnis: Depends on where you live. Northerners don't speak that quickly.
10:14:50 <eivuokko> dcoutts, Yeah, thats' the snapshot case.  Also to add arbitary version tags, as they might be useful identification.
10:15:13 <desegnis> shapr, good to know. those examples had scared me a littly
10:15:58 <dcoutts> eivuokko: I don't really understand tags, Version has this tag field but I don't know what it means or how it affects things.
10:16:14 <eivuokko> dcoutts, It doesn't affect anything afaict.
10:16:36 <dcoutts> eivuokko: so what do you want a tag for? :-)
10:16:57 <eivuokko> dcoutts, I'd just like to be able to mark automatic cabal2wix builds; In hope tags show up in ghc-pkg list.
10:17:18 <dcoutts> eivuokko: mm, interesting
10:17:27 <eivuokko> dcoutts, I have like 30 packages in that list right now, about half from my msi builds and it's near useless.
10:18:16 <eivuokko> dcoutts, Maybe that'd be abuse, I have no better idea what tags are originally for.
10:18:39 <dcoutts> I don't know either
10:23:32 <hpaste>  palomer pasted "typeclass craziness" at http://hpaste.org/2262
10:23:50 <ClaudiusMaximus> sigh, i have image as an arrow from coordinates to pixels, and want to do video feedback, but the time taken to render each frame is rising steadily (i guess because it recurses through all previous frames)
10:24:26 <ClaudiusMaximus> on the plus side, it's using incredibly little memory
10:27:37 <SamB> huh. according to oloh, there's a high correlation between using hugs and using VisualBoyAdvance...
10:27:42 <SamB> http://www.ohloh.net/projects/4078
10:27:43 <lambdabot> Title: HUGS - Ohloh
10:29:40 <SamB> not quite high as the correlation between using ZSNES and using VisualBoyAdvance
10:29:51 <SamB> s/high/as high/
10:30:33 <conal> ClaudiusMaximus: maybe you could transform your feedback algorithm so that it doesn't have to keep looking back.  some  kind of accumulator that keeps just the info you need as you step through frames.
10:33:56 <ClaudiusMaximus> conal: sure, a strict raster buffer in the loop is one way, was wondering if there was an alternative (a smarter blending function?  IIR filter -> FIR filter conversion?  something else?)
10:34:47 <conal> ClaudiusMaximus: about your image arrow: do you mean you abstracted from (->)?  i never thought of doing that.  do you have in mind using any arrows besides (->)?
10:36:10 <Philippa> are you doing animation, or just single frames?
10:36:42 <ClaudiusMaximus> conal: i'm not sure, i'm just playing around learning how to use arrows
10:36:47 <ClaudiusMaximus> Philippa: yes, animation
10:36:59 <ClaudiusMaximus> Philippa: http://img504.imageshack.us/img504/4830/mandelst7.gif
10:37:24 <ClaudiusMaximus> the feedback rapidly reaches a fixed point, http://img252.imageshack.us/img252/9522/videofeedbackou5.png
10:38:42 <Philippa> you probably don't need a strict buffer so much as a bit of care to avoid duplicating work then?
10:38:58 <Philippa> depending a bit on how you're defining feedback, of course
10:39:32 <ClaudiusMaximus> Philippa: i'm blending with a rotated version of the previous frame
10:39:34 <conal> ClaudiusMaximus: the arrow generalization it sounds like a great idea to me for imaging.  starting with R2 -> Color, i've noticed that a lot of the image operations work independently of Color and many others independently of R2.  i hadn't realized that some work genericly over (->) as well.  for instance all spatial transormation (beyond linear/affine) uses composition, which is available for all arrows.
10:40:04 <Philippa> okay. How's the rotated version defined?
10:40:18 <Philippa> that is, does it reparameterise everything in the previous frame?
10:40:33 <HWSOD> \msg NickServ identify koklama
10:40:56 <Philippa> or is it just the simple postprocess I'd hope for?
10:41:30 <conal> ClaudiusMaximus: are you using continuous space?
10:42:15 <ClaudiusMaximus> conal, Philippa: basically, yes - i'm using continuous space
10:42:35 <shapr> HWSOD: oops
10:42:38 <shapr> HWSOD: I think you should change that.
10:42:43 <conal> ClaudiusMaximus: continuous space make the math work out simply & beautifully, and allows anti-aliasing, zoom, etc.  but then the puzzle is how to finitely accumulate and carry forward useful info.  right?
10:42:50 <ClaudiusMaximus> conal: exactly
10:44:23 <conal> ClaudiusMaximus: neat puzzle!  perhaps there's another representation, besides functions, that would allow data caching but still be continuous.  say, some kind of infinite lazy quad-tree.
10:44:49 <conal> and then your arrow idea could fit it into the same framework as functions.  that could be really cool!
10:46:09 <conal> image pyramids.
10:46:32 <conal> i've wondered about efficient traversal.  a zipper would probably do it.
10:46:34 <ClaudiusMaximus> i think i'll start by caching in a finite regularly sampled raster buffer, and see how that works, before moving on to more complicated things
10:46:47 <puusorsa> http://film.guardian.co.uk/news/story/0,,2149175,00.html
10:46:49 <lambdabot> Title: In brief: Dinosaurs to carry guns in Jurassic Park 4 | News | Guardian Unlimited ...
10:46:59 <Philippa> it's been good enough for the demo scene for ages, should be good enough for you :-)
10:48:14 <SamB> I thought the demo scene used real-time raytracing for all their best demos!
10:48:16 <conal> ClaudiusMaximus: sure.  good simple start.  i'd like to keep playing with the idea.  want to share your email address with me?  mine is on my home page.
10:48:42 <ClaudiusMaximus> conal: my nick at goto10.org
10:49:16 <conal> ClaudiusMaximus: thanks.
10:50:38 * SamB wishes for the nth time that Arrow didn't have the arr/pure method on it, or that it had a superclass for the other methods
10:51:10 <mrd> why?
10:51:17 <conal> SamB: me too.  i have several arrows without a definable arr.  maybe we can agitate to get that changed.
10:51:31 <SamB> what he said ;-)
10:51:41 <lament> is that like a monad without return?
10:51:45 <SamB> except I don't know that I actually made any
10:51:57 <mrd> without lifTM
10:51:59 <ClaudiusMaximus> bbl
10:52:10 <SamB> lament: not as far as I can see
10:52:24 <SamB> then again, I don't know where arrows come from
10:52:43 <SamB> but in any case it'd be a heck of a lot more useful than a monad with no return
10:52:50 <lament> :t arr
10:52:58 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
10:53:12 <lament> :t liftM
10:53:14 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:53:32 <SamB> :t (>>>)
10:53:34 <opqdonut> what sort of arrows have these been?
10:53:34 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
10:53:45 <opqdonut> the ones you can't formulate arr and pure for, i mean
10:54:09 <SamB> :t (\f p -> (>>> arr f))
10:54:11 <lambdabot> forall t (a :: * -> * -> *) b c d. (Arrow a) => (c -> d) -> t -> a b c -> a b d
10:54:37 <SamB> oops
10:54:41 <SamB> :t (\f p -> (p >>> arr f))
10:54:43 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => (c -> d) -> a b c -> a b d
10:56:48 <sjanssen> @keal
10:56:48 <lambdabot> know you know this 24 periods Keal SecretTM
10:57:06 <sjanssen> I think we need "kealcats"
10:57:23 <sjanssen> keal quotes superimposed over cute pictures of cats
10:57:36 <mrd> ?yhjulwwiefzojcbxybbruweejw
10:57:36 <lambdabot> "\"#$%&'()*+,\""
10:57:41 <SamB> sjanssen: IRC doesn't support pictures
10:58:00 <SamB> and ascii-art cats use too much space
10:58:04 <mrd> ?brain
10:58:04 <lambdabot> They've turned into giant Swiss leaderhosen-clad dancing yodelers. Talk about unpredictable!
10:58:16 <sjanssen> SamB: sure, we could them on the web somewheres
10:58:22 <encryptio> =^.^=   -- mini kitty
10:58:28 <SamB> ah.
10:59:01 <sjanssen> @keal
10:59:01 <lambdabot> i changed my user od
10:59:04 <sjanssen> @keal
10:59:04 <lambdabot> i changed my user od
10:59:06 <sjanssen> @keal
10:59:06 <lambdabot> know you know this 24 periods Keal SecretTM
10:59:08 <sjanssen> @keal
10:59:09 <lambdabot> i think i know what code does but code looks to simple to actually do it
10:59:20 <sjanssen> @keal
10:59:20 <lambdabot> you need a Zh function in Haskell
10:59:23 <sjanssen> sorry for the spam
10:59:41 <SamB> conal: how well does Haskell support NVC?
11:00:06 <SamB> aww
11:00:13 <sjanssen> NVC?
11:00:24 <SamB> sjanssen: see conal.net ;-)
11:01:02 <sjanssen> oh, nonviolent communication
11:01:09 <sjanssen> Haskell is pretty nonviolent, IMO
11:01:25 <sjanssen> we eschew "destructive update"
11:02:03 <SamB> yes. this had occured to me as well ;-)
11:02:47 <conal> SamB: oops gaim crashed right after you asked that question.  i had to find it in the archive.
11:03:20 <SamB> ah.
11:03:52 <Cale> @keal
11:03:52 <lambdabot> i think i know what code does but code looks to simple to actually do it
11:04:20 <conal> SamB: Haskell & NVC both help one to express the essence of the matter.  and both fly in the face of cultural programming.
11:05:12 <lament> noodle, view, controller?
11:05:36 <conal> a haskell noob asks "where's my assignment statement?".  a nvc noob asks "how do i say he's irresponsible?"  in both cases, staying with the language can help to shift the consciousness.
11:06:00 <Cale> The process described in the model consists of four steps:
11:06:00 <Cale>    1. To observe without evaluation, judgement, or analysis;
11:06:12 <Cale> Hey, that's like the new GHC debugger ;)
11:06:37 <Cale> (though perhaps it does some 'analysis')
11:06:46 <lament> observing without analysis sounds rather useless
11:07:05 <SamB> impossible even
11:07:09 <Cale> yeah
11:07:31 <lament> maybe if you're on heroin...
11:07:33 <SamB> if all you have is an image you don't see a thing...
11:07:33 <OceanSpray> who here remembers me?
11:07:51 <Cale> It's like, just stop your brain from processing those signals coming from your eyes as shapes and objects.
11:08:01 <OceanSpray> oh hey Cale
11:08:04 <Cale> hello
11:08:05 <lament> i think heroin or similar drugs might have that effect
11:08:20 <Cale> I've had that happen to some extent when extremely tired.
11:08:24 <lament> from the Burroughs i've read
11:08:28 <OceanSpray> why should I do showVal :: LispVal -> IO String, when I can do LispVal -> IORef String
11:08:46 <OceanSpray> which eliminates me having to use all those readIORef functions?
11:08:47 <shapr> OceanSpray: I remember you.
11:08:53 <Cale> At least, it got to the point where the ice cubes in my drink were just shapes, and not ice cubes anymore.
11:09:07 <shapr> Cale: I think that's a fun mental exercise.
11:09:25 <Cale> OceanSpray: how would you do that?
11:09:30 <shapr> Because, when fading back in you can change the significance of perceptions.
11:09:33 <sjanssen> OceanSpray: hmm, are you sure you can do that?
11:09:39 <OceanSpray> I can't?
11:09:45 <sjanssen> OceanSpray: it's not possible to create an IORef without the IO monad
11:09:48 <OceanSpray> hpaste, url?
11:09:48 <hpaste> Haskell paste bin: http://hpaste.org/
11:10:01 <Cale> OceanSpray: To observe the value of an IORef, you have to use an IO action.
11:10:03 <OceanSpray> so, what
11:10:03 <lament> Cale: photographers and artists do that all the time
11:10:11 <sjanssen> hpaste: please don't tell me the url
11:10:15 <lament> Cale: it's not quite the same as a complete lack of analysis
11:10:24 <lament> Cale: it's just a different way to analyze
11:10:25 <OceanSpray> I can't just return "some string" in that latter function to return an IORef String ?
11:10:44 <Cale> lament: Yeah, but this was the case of not being capable of seeing them as ice cubes, even though at some higher level I knew that they were.
11:11:05 <Cale> (I'd been up for a few days)
11:11:09 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/2263
11:11:15 <lament> you're not going to take a good photo of ice cubes if you look at them and think "ice cubes"
11:11:25 <conal> anyway, if anyone is genuinely curious about nvc, i'll be happy to share.  if not, that's cool too.
11:11:45 <shapr> conal: I like nvc.
11:11:57 <shapr> I think it's an important component of keeping #haskell friendly.
11:12:15 <shapr> conal: But then, we've had this discussion before at HW.
11:12:33 <shapr> conal: Is there an url where I can read more about NVC?
11:12:38 <Cale> I suppose that the real ideas behind it are sane, but the usual implementations are sort of corny ;)
11:13:12 <shapr> What, NVC?
11:13:14 <conal> Cale: agreed.  i don't teach the formula, for that reason.
11:13:31 <lament> what is nvc?
11:13:39 <SamB> where corn?
11:13:39 <conal> shapr: try http://cnvc.org
11:13:41 <lambdabot> Title: cnvc:: Center for Nonviolent Communication home page
11:13:44 <Cale> I find it rather funny to listen to people talking around what they actually want to say because they're following some formula.
11:13:47 * SamB looks around hungrily
11:14:23 <SamB> better than when they do it because they don't actually want you to know
11:14:50 <conal> Cale: the talking-around thing a developmental stage,hopefully.
11:14:52 * lament looks at cnvc.org -- so "not being an asshole" has a special term now?
11:15:16 <SamB> is "talking around" think like Haskell's old I/O framework?
11:15:32 <SamB> er. s/is/is that/
11:16:07 <SamB> what kind of typesystem does NC have?
11:16:18 <SamB> er. NVC.
11:16:37 <shapr> I think "not being an asshole" is an excellent paraphrase of NVC.
11:16:46 * merus thinks there's a place for assholes in the world.
11:16:54 <ricky_clarkson> Usenet?
11:17:03 <shapr> merus: I agree, somewhere far away from me.
11:17:07 <shapr> ricky_clarkson: hah!
11:18:37 <conal> a practice of nvc thinking would help one move from the idea of someone "being an asshole" out of labeling & judgment to clarity and compassion.  from there, you've a much better chance of the person acting in a way that you'd be happier with.
11:18:51 <shapr> Yeah, true.
11:18:54 <shapr> E-Prime
11:19:07 <lament> i just thought about e-prime too
11:19:12 <conal> shapr: exactly.  e-prime is on the same track.
11:19:14 * ricky_clarkson thinks of slava.
11:19:42 <lament> conal: in other words, you move from being an asshole to not being an asshole.
11:19:43 <shapr> slava can be difficult at times.
11:19:51 <shapr> But he doesn't do it on purpose.
11:20:03 <conal> that's the point of the "observation" step: disentangle my judgments/evaluations from what really happened.  very empowering.
11:20:12 * shapr rememebers getting upset at slava and bailing out of #concatenative 
11:20:20 <ricky_clarkson> He does, imo, but often still has valid and useful points.
11:20:29 <shapr> Yeah, he's a smart guy.
11:20:54 <shapr> Sometimes difficult people have wonderful ideas, but it's just not worth my time/frustration to dig them out.
11:21:07 <conal> lament: you move from believing in the idea of assholes to a clearer, more life-connected, & empowered state of mind & heart.
11:21:15 <Cale> conal: "what really happened"?
11:21:24 <lament> conal: I smoke pot all the time, but this is too much even for me :|
11:21:36 * Cale doesn't believe in absolute objective reality :)
11:21:41 <OceanSpray> I don't really get this...
11:21:52 <lament> conal: i don't believe in assholes, i believe in *being* an asshole, as in "look, you're being an asshole right now, stop it"
11:22:01 <shapr> lament: Check out E-Prime
11:22:03 <Cale> lament: haha
11:22:10 <Cale> OceanSpray: okay...
11:22:12 <OceanSpray> in a function that -> IO String, I can just 'return <string>' and get an IO String
11:22:20 <lament> shapr: i've looked at it.
11:22:22 <Cale> OceanSpray: right
11:22:30 <conal> Cale: that's another useful distinction: what happens vs what I saw or heard.  i actually recommend the latter.  thanks.
11:22:31 <lament> shapr: i don't find it interesting.
11:22:41 <shapr> lament: But, do you understand the basic problem it recognizes?
11:22:41 <OceanSpray> but in a function -> IORef String, I CAN'T do 'return <string>" to get an IORef String ?
11:22:50 <OceanSpray> what gives?
11:22:50 <conal> lament: good luck with that.  if it doesn't work out for you, try nvc.  ;)
11:22:53 <Cale> OceanSpray: also right
11:23:10 <merus> E-Prime reminds me of those poems where the author goes to a silly amount of effort to avoid using the letter 'e'.
11:23:12 <lament> shapr: sure, there's a problem, and no, e-prime is not a feasible way of fixing it.
11:23:26 <lament> shapr: same with NVC if NVC is anything like e-prime.
11:23:36 <Cale> OceanSpray: an IORef is essentially a mutable cell containing a particular string at any point in time. An IO String is a computation which if executed produces a String
11:23:37 <shapr> lament: Well, I disagree, I think e-prime is a useful tool.
11:23:56 <lament> shapr: e-prime *is* a useful tool? :)
11:24:03 <shapr> Yes, I use it often.
11:24:08 <Cale> OceanSpray: IORefs, by design, can only be constructed, manipulated, and observed by IO actions.
11:24:09 <astrolabe> heh
11:24:15 * shapr grins
11:24:23 <shapr> lament: I didn't say always :-)
11:24:44 <lament> shapr: but what's actually useful - the extra attention you pay to your language, or eprime itself?
11:24:57 <conal> nvc & e-prime nudge one toward clear thinking & expression.  and clear thinking & expression are hard.
11:25:01 <popcount> OceanSpray, Cale isn't telling you the whole story, but that's to protect you.
11:25:04 <lament> shapr: paying attention is useful, yes.
11:25:04 <Cale> OceanSpray: To create a new IORef (and not just pass along an existing one) then, you need to execute an IO action.
11:25:12 <lament> shapr: e-prime isn't, because it's unnatural and horrible.
11:25:16 <shapr> haha
11:25:29 <opqdonut> e-prime is useful, yes
11:25:30 <shapr> See that's a case where I'd ask you exactly what is unnatural and horrible about it.
11:25:31 <OceanSpray> oh
11:25:31 <Cale> popcount: I'm telling the whole story for people not wanting to write hooks into the runtime system of the compiler :)
11:25:32 <OceanSpray> OH
11:25:33 <conal> watch confusing natural & habitual
11:26:12 <lament> conal: i strongly believe that human languages are the way they are, and not some other way, for a reason.
11:26:16 <shapr> Yeah, I think that calling any particular programming language natural or not confuses habitual and natural.
11:26:27 <popcount> Cale, did I miss unsafePerformIO?
11:26:35 <Cale> popcount: that's what I mean :)
11:26:53 <conal> lament: me, too.  and ours is the way it is to support domination consciousness.  that's one theory anyway.
11:26:59 <popcount> Cale, well, it has other uses, but those are way beyond a newbie.
11:27:23 <shapr> lament: I agree that e-prime is a tool that helps me pay attention to my language. What I say often does not match what I actually mean.
11:27:24 <Cale> popcount: unsafePerformIO is essentially a hook into the RTS which lets you cheat the whole system, and nobody should use it unless they actually understand what GHC is going to do.
11:27:25 <conal> lament: btw, watch confusing "human" with civilized cultures.  see daniel quinn & william ury.
11:27:41 <lament> conal: in particular, if you forced everybody to switch to e-prime somehow (i dunno, reprogrammed their brains) i'm fairly sure that a new word "to be" would develop.
11:28:36 <Cale> OceanSpray: So also, if you want to read or write the present value of an IORef, you need to execute an IO action.
11:28:41 <lament> conal: so you believe in strong sapir-whorf? Changing the language will change the consciousness?
11:28:43 <conal> lament: i agree, if the change were just at the surface, ie at the level of talking rather than thinking.
11:29:02 <OceanSpray> got it
11:29:10 <conal> lament: over long periods of time, not short.
11:29:11 <sorear> .
11:29:29 <conal> so i go for the thinking explicitly.
11:29:32 <lament> russian doesn't even even have "to be". Instead of saying "you're an asshole", you go "you asshole."
11:29:47 <Cale> OceanSpray: You can think of your interpreter as a pure function which turns lisp programs into IO actions. :)
11:29:52 <conal> lament: the point is the thought, not the word.
11:30:04 <lament> conal: right
11:30:25 <conal> lament: try translating label/evaluation of "asshole" into an action.
11:30:34 <lament> conal: and if you believe in being able to changing people's _thoughts_
11:30:38 <lament> *to change
11:30:48 <lament> then... you're an optimist :)
11:30:57 <Cale> heh, "you're assholing"
11:31:03 <conal> lament: if they want it, i can help them.
11:31:07 <merus> Cale: Heh.
11:31:07 <shapr> I believe in changing people's thoughts.
11:31:20 <conal> Cale: that's a start!  now describe assholing.
11:31:45 <shapr> lament: I think the poisnous people presentation fits into this discussion.
11:31:53 <shapr> poisonous*
11:32:15 <conal> shapr: labeling people as "poisonous"?
11:32:42 <shapr> conal: http://www.oreillynet.com/conferences/blog/2006/07/oscon_how_open_source_projects.html
11:32:43 <lament> if somebody already wants to stop being an asshole, that's already the greatest step :)
11:32:44 <lambdabot> Title: OSCON: How Open Source Projects Survive Poisonous People (And You Can Too) - O&# ..., http://tinyurl.com/fep8f
11:34:05 <lament> conal: anyway, I am able to think clearly. I don't need to remove shortcuts from my language to do so.
11:34:43 <lament> and most people interested in e-prime are probably also able to think clearly.
11:34:45 <conal> lament: show me some clear thinking.  explain what you mean by someone being an asshole.
11:34:47 <lament> eg shapr
11:35:11 <lament> er, that's an example of a clear thinker, not an example of an asshole :)
11:35:13 <conal> shapr: thanks for the url
11:35:17 <shapr> I got started with e-prime because I am not always able to think clearly.
11:35:18 <arcatan> haha
11:35:24 <conal> lament: :)
11:36:30 <lament> conal: i'd have to invent a situation. Suppose a newbie comes to #haskell and asks to explain something basic. And I tell him "RFTM, idiot, can't you read? Please grow up and stop wasting my time"
11:36:59 <lament> this, ladies and gentlemen, is called being an asshole! it's a simple thing, but very enjoyable.
11:37:53 <conal> lament: so you use "asshole" as a shortcut for making that response ("RTFM" etc)?
11:37:53 <shapr> I don't enjoy it, and I bet the newbie wouldn't either.
11:37:55 <lament> the newbie cries, runs away and never tries Haskell again. Ten years later he's caught smuggling drugs over the mexican border and shot by the border patrol.
11:38:14 <lament> another life ruined by yours truly!
11:38:20 <conal> :)
11:38:59 <lament> conal: it's a shortcut for a particular kind of inconsiderate behaviour towards others
11:39:05 <arcatan> we have this kind of problem with inside jokes on a finnish programming channel
11:39:19 <shapr> arcatan: Newbies run away and smuggle drugs?
11:39:41 <arcatan> it's okay to tell the regulars to install gentoo as an answer to all their questions, but I'd be glad if the newbies got real answers
11:39:49 <arcatan> shapr: some of them run away, at least
11:39:51 <lament> conal: as everybody, including you, knows.
11:39:55 <conal> lament: thanks.  now i'm geting a beter understanding of what you mean.  next, can you think/speak clearly about this idea of "inconsiderate" (another evaluative label)
11:40:06 <lament> conal: no, i will stop now.
11:40:21 <shapr> hah
11:40:53 <shapr> I think puns are important to understand because they show where speech/writing/coding could be closer to exact.
11:40:54 <conal> lament: as i said, clarity is hard.
11:41:02 <Cale> You can try to give precise definitions for all words, but it seems that what really happens is that all words are more or less like fuzzy clouds of meaning. Sometimes even the fuzziest of these clouds is still a useful description.
11:41:17 <lament> == Cale
11:41:48 <lament> conal: clarity is not hard. Clarity is impossible. Don't confuse humans and computers.
11:42:16 <shapr> Some humans require more clarity than others, some teenagers and some people with Asperger's in my experience.
11:42:24 <Cale> In trying to make precise the ideas that these fuzzy words convey, it's hard to capture all of the overtones and subtleties which are genuinely useful things, even if sometimes they sometimes create problems.
11:42:31 <conal> the problem is that the criticisms are self-defeating.  the goal isn't ultimate precision.  it's getting your needs met.
11:42:39 * gogonkt- is away: Âú®ÂøôÂë¢,Êúâ‰∫ãBell me o(^o^)o
11:42:40 <lament> conal: certainly
11:42:55 <shapr> gogonkt-: Hey, please no away messages here.
11:43:00 <lament> conal: and the english language, with words like "is" and "asshole", is a product of consensus on what's enough to meet people's needs
11:43:10 <Cale> er, minus the extra spurious 'sometimes' :)
11:43:21 <gogonkt-> shapr, sorry
11:43:26 <shapr> gogonkt-: Thanks :-)
11:43:28 * gogonkt- is away: Âú®ÂøôÂë¢,Êúâ‰∫ãBell me o(^o^)o
11:43:31 <shapr> ??
11:43:35 <conal> lament: the problem is that those ideas/thoughts are self-defeating.  "suicidal expressions of unmet needs".
11:43:36 * gogonkt- is back (gone 00:00:08)
11:43:36 <shapr> gogonkt-: um..
11:43:46 <ricky_clarkson> lament: The English language has been standardised a number of times.
11:43:47 <shapr> gogonkt-: Could you please turn that off for #haskell?
11:43:55 <lament> ricky_clarkson: thankfully, nobody cares much
11:44:06 <lament> ricky_clarkson: i mean the actual speakers
11:44:25 <shapr> I do :-/
11:44:27 <lament> ricky_clarkson: not even in spanish, where the RAE tries to hold everything together and does have a lot of authority
11:44:29 <merus> To continue in Cale's vein, even when one removes a word, like 'is' for example, from the language, it gets replaced in meaning by another syntax, 'seems like', etc.
11:44:35 <gogonkt-> shapr, howto do this in xchat?
11:44:40 <ricky_clarkson> lament: Actually, they do.  If you visit England, the further you get from London, a centre of standardisation, you find that the language varies more.
11:44:40 <shapr> gogonkt-: I don't know.
11:45:01 <lament> ricky_clarkson: that's probably because the london dialect is taken to be the standard.
11:45:05 <shapr> Anyway, I think further discussion in this vein isn't going to help anyone...
11:45:07 <lament> ricky_clarkson: and not the other way around.
11:45:10 <gogonkt-> oklopol, i don't do away in freenode
11:45:27 <Cale> gogonkt-: Settings -> Preferences -> General -> Uncheck "Announce Away Messages"
11:45:36 <lament> ricky_clarkson: suppose the standard dialect was taken from New York; would Londoners switch to conform?
11:45:41 <ricky_clarkson> lament: That's untrue, as it affects places that don't resemble London's speech.
11:45:48 <shapr> lament: Hey, I think it's enough, take it to #haskell-blah
11:45:55 <lament> heh okay
11:46:11 <gogonkt-> Cale, Thx
11:46:27 <lament> (that killed it, since none of the participants are in #haskell-blah)
11:46:32 <gogonkt-> it done
11:46:41 <merus> lament: Yeah, heh.
11:47:12 <gogonkt-> night all
11:47:37 <byorgey> night gogonkt-
11:47:48 <shapr> @users
11:47:48 <lambdabot> Maximum users seen in #haskell: 385, currently: 375 (97.4%), active: 16 (4.3%)
11:47:54 <shapr> Ok, time for some on-topic talk!
11:48:07 <shapr> conal: Someone recently said that Phooey is a nifty abstraction, what's the url for that?
11:48:18 <arcatan> how do calculate the meaning of life in haskell?
11:48:22 <arcatan> +I
11:48:33 <byorgey> > let meaningoflife = 42 in meaningoflife
11:48:33 <lambdabot>  42
11:48:35 <shapr> > let meaning_of_life = 42 in meaning_of_life
11:48:36 <shapr> dang
11:48:37 <lambdabot>  42
11:48:38 <shapr> beat me to it!
11:48:40 <byorgey> hehe
11:48:54 <byorgey> it's because I didn't use underscores
11:48:57 <samreid> psh... it's not that easy.
11:49:12 <samreid> > let meaningOfLife = last (repeat 42) in meaningOfLife
11:49:16 <lambdabot> Terminated
11:49:21 <arcatan> ooh
11:49:27 <byorgey> hehe, nice
11:49:36 <shapr> @where phooey
11:49:36 <lambdabot> http://conal.net/phooey/
11:49:38 <shapr> aha
11:49:53 <arcatan> how to use haskell to make me rich?
11:50:22 <shapr> Ah, wxHaskell only.. I was hoping for gtk2hs
11:50:30 <newsham> write less buggy software faster than everyone else.  sell it.  profit.
11:50:34 <Cale> > sum $ map (fix ((0:) . scanl (+) 1) !!) [6,9]
11:50:35 <lambdabot>  42
11:50:43 <shapr> newsham: step 1 is easy, the rest ...
11:50:45 <byorgey> > let changeName from to = to in changeName "arcatan" "rich"
11:50:46 <lambdabot>  "rich"
11:50:55 <newsham> shapr: for some definition of easy.
11:51:30 <arcatan> I should be on Mac, they seem to love small shareware apps
11:51:44 <newsham> pick some computationally expensive process that mass consumers care about, write it up using STM for multi-core machines
11:51:47 <newsham> profit
11:52:21 <dolio> Write yet another social networking site.
11:52:25 <Cale> I found it exceptionally strange how much trivial software for the Mac cost money.
11:52:40 <newsham> dolio: whats that got to do with haskell? :)
11:52:55 <cjeris> Cale: that's satanically evil.
11:52:58 <dolio> You could do it in haskell.
11:52:58 <kjdf> hm, what is the constant factor penalty for STM code?
11:53:01 <dcoutts> shapr: conal said it should be easy enough to make a phooey backend for gtk2hs
11:53:19 <cjeris> (not the mac software.)
11:53:19 <Cale> cjeris: what is?
11:53:20 <OceanSpray> whoops, lol
11:53:24 <arcatan> Cale: me too. but if people buy them, I guess the developers don't complain
11:53:24 <shapr> dcoutts: cool!
11:53:46 <dcoutts> shapr: but don't expect me to do it any time soon! :-)
11:53:48 <Cale> arcatan: People on the quicksilver forum were begging the developers to take their money, even!
11:54:02 <shapr> dcoutts: I won't :-)
11:54:06 <Cale> and couldn't understand why they might want to give the software away
11:54:15 * fakeolliej1 wonders if dcoutts ever sleeps...
11:54:28 <hpaste>  OceanSpray annotated "(no title)" with "(no title)" at http://hpaste.org/2263#a1
11:54:30 * arcatan goes to steal his little brother's mac for software development purposes
11:54:43 <dcoutts> olliej: occasionally
11:54:44 <OceanSpray> I run into this while compiling:
11:54:55 <OceanSpray> LispData.hs:85:39:
11:54:55 <OceanSpray>     Couldn't match expected type `[Char]' against inferred type `Char'
11:54:59 <olliej> dcoutts: uh huh
11:55:18 <newsham> dolio: yah, but the software part of social networking is the smallest bit, no?
11:55:22 <OceanSpray> doesn't show Int return a String?
11:55:25 <OceanSpray> what's going on?
11:55:36 <newsham> also lots of the software part of social networking is javascript and possibly javascript widgets.
11:55:38 <sorear> OceanSpray: String *is* [Char]
11:55:41 <dolio> newsham: I don't know, I've never made one. :)
11:55:43 <OceanSpray> yes
11:55:44 <newsham> which you prob dont want to do in haskell :\
11:55:53 <OceanSpray> but the inferred type there is Char
11:55:53 <byorgey> OceanSpray: which is line 85?
11:55:59 <OceanSpray> uhh
11:56:02 <dcoutts> olliej: want to help with important community infrastructure projects? then I can work less and sleep more :-)
11:56:15 <kjdf> "Even in this case performance is typically no worse than twice as slow."
11:56:21 <OceanSpray> LispData.hs:85:39:
11:56:21 <OceanSpray>     Couldn't match expected type `[Char]' against inferred type `Char'
11:56:25 <OceanSpray> goddamn it
11:56:35 <olliej> dcoutts: ehehe, you probably want to people who can write haskell, rather than haskell compilers :D
11:56:35 <OceanSpray>                                        show num ++ " args, found: " ++
11:56:45 <dolio> newsham: Well, then, write a good Haskell --> AJAX compiler backend, and use that to make a social networking site. :)
11:56:49 <OceanSpray> wait, doesn't hpaste have line numbers?
11:56:54 <allbery_b> return "Expected" ++ ... does not parse the way you think it dpes
11:57:03 <Cale> where is the hpaste?
11:57:05 <dcoutts> olliej: actually I want people who do write Haskell compilers to make cabal support those compilers
11:57:06 <allbery_b> return ("Expected " ++ ... )
11:57:08 <sorear> Cale: 2263
11:57:14 <OceanSpray> huh?
11:57:22 <dcoutts> olliej: cabal's non-ghc support is a tad dismal
11:57:41 <Cale> yeah, that's the problem
11:57:41 <olliej> dcoutts: My "current" haskell compiler is all C#
11:57:47 <olliej> dcoutts: and backends ghc
11:57:47 <byorgey> OceanSpray: oh, yeah, so it does, sorry =)
11:57:53 <olliej> dcoutts: it is unholy
11:58:01 <Cale> OceanSpray: return "foo" ++ "bar" == (return "foo") ++ "bar"
11:58:10 <OceanSpray> oh
11:58:10 <OceanSpray> OH
11:58:13 <OceanSpray> goddamn it.
11:58:17 <opqdonut> :)
11:58:34 <Cale> you might like to use the function concat
11:58:51 <dcoutts> olliej: sounds terrifying :-)
11:58:54 <Cale> or even unwords
11:59:19 <olliej> dcoutts: hey it gets almost complete static type safety when compiling haskell to .NET
11:59:55 <OceanSpray> ok, parentheses fixed everything
11:59:56 <Cale> return . unwords $ ["Expected:", show num, "args, found", unwords strs]
12:00:33 <olliej> dcoutts: it only needs to do a runtime type check for higher kinded types (and that's only to appease the static type checker), everything else is static
12:00:41 <Cale> > unwords ["hello", "there", show 25]
12:00:49 <lambdabot>  "hello there 25"
12:02:00 <Cale> OceanSpray: yeah, return is not a keyword :)
12:02:25 <Eelis> heh, i wrote ##iso-c++/##c++'s eval bot in Haskell, and as a result more and more people there are giving Haskell a try :)
12:02:39 <Cale> Eelis: awesome :)
12:02:44 <shapr> cool!
12:02:45 <Cale> Eelis: make sure they come here :)
12:02:58 <Eelis> i will
12:03:49 <eivuokko> olliej, You hava .net backend for ghc?
12:03:55 <arcatan> like "@eval 1+1" " 2. this evaluation was made possible by Haskell! Please visit #haskell to learn more"
12:05:25 <Cale> ahaha
12:05:42 <Eelis> arcatan: hehe. i think it's more effective now, when people ask "how many lines of code is it?" and i reply "500, but it's written in Haskell", and they go: "in say-what?"
12:06:19 <arcatan> maybe :)
12:06:43 <sorear> Eelis: what does it implement?
12:06:52 <Eelis> sorear: it compiles and evaluates code, like lambdabot
12:06:56 <sorear> full C++ in 500 lines of anything?
12:07:03 <Eelis> it just invokes gcc
12:07:22 <Eelis> most of the code is in error filtering and making things secure
12:07:42 <sorear> securing C++ sounds fun
12:07:48 <fakeolliej_> dcoutts: back again
12:07:57 <Eelis> sorear: it's been a very educational experience ;)
12:07:57 <sorear> isn't the whole point of using C++ pointer arithmetic?
12:08:03 <ADEpt> Eelis: via static code analysis, i presume? ;)
12:08:09 <Eelis> ADEpt: no, via ptrace
12:08:16 <ADEpt> Eelis: bummer
12:08:21 <Eelis> it intercepts system calls
12:08:24 <sorear> if my code was guaranteed safe, I'd be using a different language
12:08:40 <Eelis> you can play around with it in #geordi, if you're interested
12:09:17 <sorear> Eelis: so you run the progrem with RSS and CPU limits, barring all syscalls except write(1, ...) ?
12:09:25 <Eelis> sorear: pretty much
12:09:33 <Eelis> a little more subtle, but that's the gist
12:09:35 <Toxaris> "@eval int n = 10, fac = 1; while (n-- > 0) fac *= n; printf "%d" fac" -- "that's 3628800, but consider the beauty of 'product [1..10]' in Haskell"
12:09:38 <eivuokko> olliej, You have .net backend for ghc?
12:09:48 <sorear> Eelis: I suppose you're aware that ptrace doesn't trap SysV system calls?
12:09:48 <olliej> eivuokko: yeah
12:09:54 <olliej> it's a hideous beast
12:09:55 <shapr> Hm, when did lambdabot first show up?
12:10:01 <Eelis> sorear: never heard of those
12:10:06 <Toxaris> but c++ to Haskell simplifier may be a bit tricky :)
12:10:09 <eivuokko> olliej, So, small problems....it can be rewritten, once it exists :)
12:10:23 <eivuokko> olliej, Is it available anywhere, or going to be?
12:10:28 <eivuokko> olliej, I am very interested ;)
12:10:49 <olliej> eivuokko: i haven't decided yet, my thesis is available at http://nerget.com
12:10:51 <lambdabot> Title: Oliver's Page of Random Ramblings
12:11:27 <olliej> eivuokko: the code itself is way to ugly and fragile to be really useful atm, /me is rewriting in haskell
12:11:33 <eivuokko> olliej, I read in log you have dynamic checks for higher kinds?  Does this mean casts or more checks than that?
12:11:35 <olliej> without using ghc as a front end
12:11:44 <eivuokko> olliej, Why no ghc?
12:12:03 <eivuokko> olliej, I don't care, as long as it is very near haskell, actually ;)
12:12:52 <olliej> eivuokko: because my compiler has a huge number of issues in the code caused by the passes where it has to reconstruct the original data types from GHC's core output
12:13:00 <eivuokko> olliej, I see.
12:13:15 <shapr> Heh, "The Art of Avoiding Work"
12:13:26 <olliej> eivuokko: At the Core level class and instance info has been clobbered somewhat
12:13:36 <eivuokko> olliej, Yes
12:13:51 <olliej> eivuokko: then there's the ugliness as it tries to ensure the arity of functions matches
12:14:00 <eivuokko> olliej, Hmmm?
12:14:11 <shapr> It bugs me when people name their files paper.pdf or thesis.pdf
12:14:16 <shapr> I download *lots* of those!
12:14:17 <olliej> eivuokko: take a function Int -> Int -> Int
12:14:21 <olliej> shapr: :D
12:14:23 <olliej> hehehe
12:14:40 <desp> @logs
12:14:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:14:44 <eivuokko> olliej, Anyway;  I would like to write game(s) for xbox with xna, but there's no haskell compiler -.-  So I'd love to have one, and help with it, if I can.
12:14:49 <shapr> olliej: But I think I'll still enjoy reading it :-)
12:15:05 <olliej> eivuokko: eg. foo :: Int -> Int -> Int
12:15:46 <olliej> eivuokko: at a basic level this could be foo a b = a + b, or it could be foo a = \b -> a + b
12:15:59 <olliej> eivuokko: (note these are the same type in haskell)
12:16:04 <eivuokko> Yeah
12:16:17 <dozer> olliej: the one is just syntactic sugar for the other, right?
12:16:22 <OceanSpray> I keep on hitting brick walls.
12:16:24 <olliej> dozer: yup
12:16:50 <OceanSpray> the Parsec parser needs to create LispVal pairs, which have IORef LispVals as the car and cdr
12:17:12 <OceanSpray> as has been mentioned, only an IO action can create an IORef.
12:17:24 <OceanSpray> orz.
12:17:53 <olliej> eivuokko: dozer: but if we pretend \a b -> a+b actually has type (Int, Int) -> Int we can greatly improve perf on a platform like /.NET
12:18:15 <dozer> OceanSpray: is there no way to execute parsec in the IO monad?
12:18:16 <eivuokko> olliej, Can't you normalise functions to that direction?
12:18:25 <Cale> dozer: right
12:18:27 <OceanSpray> There should be
12:18:33 <olliej> eivuokko: dozer: so we actually consider a function type to be a tuple of the haskell type an the arity
12:18:38 <Cale> OceanSpray: You need better separation between parsing and evaluation
12:18:38 <OceanSpray> but how?
12:18:52 <olliej> eg. (a->b->c, 1) vs. (a->b->c, 2)
12:18:58 <Cale> OceanSpray: The parser produces a parse tree all at once, and then the rest of the program should just manipulate that.
12:19:15 <dozer> olliej: sure - that's the kind of tweak you can do in the compiler - the JVM just pushes x,y onto the stack and when it calls the next function, makes sure these 'poke out' enough that the new function runs with them
12:19:54 <olliej> dozer: well the trick is doing this while maintaining type safety according to the type sytem of the VM
12:20:05 <olliej> conceptually we have
12:20:24 <dozer> olliej: yeah :) you just end up with a lot of compiler-injected currying/uncurrying that hopefully all optimizes out
12:20:28 <Cale> Evaluation will produce things like cons cells with IORefs.
12:20:37 <Cale> (and will happen in the IO monad)
12:20:39 <olliej> class Function<A> {A invoke();}, class Function<A,B>{B invoke(A);}, ...
12:20:47 <olliej> dozer: yah
12:21:08 <xerox> OceanSpray: Parsec can now be stacked on arbitrary monads! (Or it will in the next couple of days.)
12:21:23 <dozer> olliej: yeah, that's the sort of thing I was looking at emitting last time I was thinking of compiling haskell to java
12:21:26 <OceanSpray> xerox, next coupla days?
12:21:27 <Cale> xerox: awesome :)
12:21:43 <dozer> olliej: each function signature becomes an interface, each implementation a class
12:21:52 <Cale> OceanSpray: yeah, that's xerox's SoC project :)
12:22:22 <OceanSpray> in the meantime...
12:22:33 <olliej> erk
12:23:09 * olliej wonders why irc client crashed
12:23:22 <OceanSpray> are you telling me to just have parsec parse datums into | Pair LispVal LispVal and then use the evaluator to transform those into | Pair (IORef LispVal) (IORef LispVal) ?
12:23:46 <OceanSpray> seems kludgy.
12:24:34 <Cale> Well, the usual thing to do when parsing and evaluating a language is that the parser produces an abstract syntax tree, and then the interpreter takes that and interprets it.
12:25:57 <mlguy> I'm having trouble with a GHC build from yesterday's HEAD
12:26:08 <dozer> OceanSpray: it's quite useful to do it in 2 stages as Cale says - it lets you do lots of things with your program appart from running it
12:26:20 <mlguy> I'm pulling new patches now but wonder if there are any GHC hackers who might be able to help out?
12:26:59 * wli thought it was most typical for interpreters to translate to instructions for some abstract machine, then interpret those instructions.
12:27:01 <dozer> OceanSpray: e.g. prety print it, apply re-write rules to optimize it, transform it sytematically before executing e.g. apply a cross-cut concern etc.
12:34:29 <OceanSpray> ok then
12:34:46 <OceanSpray> doing what you suggest would constitute a MAJOR rewrite.
12:34:52 <drigz> i hate the way you get into trying to express a function as concisely as possible
12:35:02 <drigz> and suddenly you realise you've made it much slower
12:35:06 <drigz> (and less readable)
12:35:40 <OceanSpray> and how would I represent these abstract-syntax trees, anyway?
12:35:42 <OceanSpray> Haskell lists?
12:35:43 <drigz> relatedly, can anyone compress this: pairs xs = concat $ zipWith (map . (,)) xs (inits xs)
12:36:19 <Saizan> ?pl pairs xs = concat $ zipWith (map . (,)) xs (inits xs)
12:36:20 <lambdabot> pairs = join . ap (zipWith (map . (,))) inits
12:36:48 <Heffalump> pairs xs = [(x1, x2) | x1 <- xs, x2 <- xs] ?
12:37:00 <drigz> Heffalump: it has to work progressively on infinite lists
12:37:30 <drigz> so [1..] -> (1,2), (1,3), (2,3), ...
12:38:41 <Heffalump> oh well :-)
12:40:36 <drigz> it seems @pl just uses join as a two-character saving on concat
12:40:43 <Saizan> > let pairs xs = concat $ zipWith (map . (,)) xs (inits xs) in pairs [1..]
12:40:44 <lambdabot>  [(2,1),(3,1),(3,2),(4,1),(4,2),(4,3),(5,1),(5,2),(5,3),(5,4),(6,1),(6,2),(6,...
12:41:04 <Saizan> well also ap instead of two xs and some spaces
12:41:10 <Saizan> with parens though
12:41:19 <opqdonut> > let pairs xs = concat $ zipWith (map . (,)) xs (tail$inits xs) in pairs [1..]
12:41:20 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5,...
12:41:24 <opqdonut> you want tail.inits
12:41:26 <opqdonut> not inits :)
12:41:48 <drigz> opqdonut: i don't want the (x,x) pairs
12:41:57 <opqdonut> ah, that's a different sotry :)
12:42:50 <OceanSpray> what would be the difference between using | Pair LispVal LispVal and I Pair (LispVal, LispVal) ?
12:43:00 <dozer> > [(x,y) | (x::xs) <-  [1..] , y <- xs]
12:43:00 <lambdabot>  Parse error in pattern
12:43:11 <OceanSpray> s/I/|/
12:43:18 <dozer> > [(x,y) | (x::xs) <-  [1..] | y <- xs]
12:43:18 <lambdabot>  Parse error in pattern
12:43:34 <dozer> > [(x,y) | (x:xs) <-  [1..] , y <- xs]
12:43:34 <lambdabot>   add an instance declaration for (Num [t])
12:43:35 <lambdabot>     In the expression: 1
12:43:35 <lambdabot>     In a...
12:43:44 <dozer> it isn't my day :(
12:43:55 <OceanSpray> would there be a difference at all?
12:43:59 <Cale> OceanSpray: You'd represent them similarly to how you're doing it, but without IORefs
12:44:07 <Cale> There's a slight difference
12:44:07 <dozer> > [(x,y) | (x:xs) <-  [1::Integer ..] , y <- xs]
12:44:08 <Toxaris> OceanSpray: in a data definition?
12:44:08 <lambdabot>  Couldn't match expected type `Integer' against inferred type `[a]'
12:44:13 <xerox> dozer: (x:xs) <- 1.. doesn't quite work
12:44:19 <OceanSpray> Toxaris, yes
12:44:28 <yaxu> i've got an alternative title for my msc thesis - "A system for humans typing sounds that a computer tries to make sound like a human trying to sound like a computer making music, with software agent to act like a human doing so"
12:44:37 <dozer> no - I probably want tails of [1..]
12:44:38 <yaxu> i think haskell has led me down the path of abstraction
12:44:57 <Cale> OceanSpray: In the second case undefined, Pair undefined, Pair (undefined, undefined) are all separate
12:45:00 <yaxu> s/with/with a/
12:45:13 <Cale> In the first case, you have just undefined, and Pair undefined undefined
12:45:30 <OceanSpray> what the hell is undefined?
12:45:31 <Cale> with nothing corresponding to Pair undefined in the first one.
12:45:46 <Toxaris> OceanSpray: with  (Pair LispVal LispVal), you have Pair-cells wich contain two pointers to the two LispVals, but with (Pair (LispVal, LispVal)), you have Pair-cells wich contain a pointer to a (,) wich contains two pointers to the two values
12:45:47 <Cale> The undefined value which is a member of every type
12:45:49 <dozer> OceanSpray: it's sort of like NaN in doubles
12:46:02 <Cale> uh, that's a strange analogy
12:46:12 <opqdonut> > let pairs xs = concat $ (map . (,)) <$> xs <*> (inits xs) in pairs [1..]
12:46:14 <Cale> NaN and undefined are different values of type Double :)
12:46:14 <lambdabot>  [(1,1),(1,1),(1,2),(1,1),(1,2),(1,3),(1,1),(1,2),(1,3),(1,4),(1,1),(1,2),(1,...
12:46:21 <opqdonut> hmm, a bit different
12:46:26 <Cale> It comes up when programs don't terminate
12:46:26 <Toxaris> OceanSpray: so you want (Pair LispVal LispVal) most certainly
12:46:33 <Cale> > let x = x + 1 in x
12:46:35 <lambdabot>  Exception: <<loop>>
12:46:46 <OceanSpray> ah
12:46:47 <opqdonut> ?src [].fmap
12:46:47 <lambdabot> Source not found. It can only be attributed to human error.
12:46:54 <Cale> > let x = x + 1 in case x of _ -> 5
12:46:55 <lambdabot>  5
12:46:56 <opqdonut> vah
12:47:07 <drigz> i thought undefined was a literal that could take any type, but causes an error if you try and do something with it
12:47:23 <Cale> > let x = x + 1 in case (x,x) of (u,v) -> 5
12:47:25 <lambdabot>  5
12:47:32 <Toxaris> @src undefined
12:47:32 <lambdabot> undefined =  error "Prelude.undefined"
12:47:34 <Cale> > let x = x + 1 in case x of (u,v) -> 5
12:47:35 <lambdabot>   add an instance declaration for (Num (t, t1))
12:48:02 <mauke> drigz: you can define "undefined" in userspace
12:48:11 <Cale> > let (x,y) = (y,x) in case x of (u,v) -> 5
12:48:13 <lambdabot>  Exception: <<loop>>
12:48:19 <mauke> undefined :: a; undefined = undefined
12:48:24 <conal> shapr: i missed your phooey inquiry.  did you find it okay?
12:48:49 <Cale> > let f x = 5 in f undefined
12:48:51 <lambdabot>  5
12:48:59 <Toxaris> drigz: all uses of undefined, error "whatever" and nonterminating functions are semantically equivalent, having all types and no value
12:49:09 <Cale> > let f Nothing = 0; f (Just x) = 1 in f undefined
12:49:10 <lambdabot>  Undefined
12:49:14 <Cale> > let f Nothing = 0; f (Just x) = 1 in f (Just undefined)
12:49:15 <lambdabot>  1
12:49:33 <drigz> Toxaris: wow, i didn't know that. thanks
12:49:35 <Toxaris> drigz: (denotational) semantics is (normally) about terminating, non-error-producing functions only
12:49:44 <drigz> i thought undefined was like a null-pointer
12:50:17 <Cale> It's more like a nonterminating program.
12:50:23 <Cale> But sure :)
12:50:42 <dozer> It sort of gets used like null sometimes
12:50:57 <Cale> You can't detect it.
12:51:09 <mauke> drigz: it's an infinite loop in a box!
12:51:18 <Cale> Because by the time you try to observe it, you've killed your program :)
12:51:23 <mauke> a box that explodes if you open it
12:51:28 <dozer> mm - I'm building a library and some apps using cabal, and it takes 5 min to build the library, but then for each app it rebuilds all the sources rather than linking to the lib
12:51:30 <dozer> :(
12:51:46 <drigz> Cale: you can use catch, can't yoU?
12:51:48 <drigz> *u
12:51:59 <Cale> drigz: from within IO, you can, if you're careful
12:52:42 <Cale> A 'pure' version of catch would be unsafe.
12:53:14 <drigz> @type catch
12:53:15 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
12:53:23 <drigz> ok
12:53:59 <dozer> Cale: is there a way to 'catch' if a pattern match has failed?
12:54:25 <sorear> sure
12:54:28 <Cale> well, that'll produce the same sort of error, if I'm not mistaken
12:54:51 <monochrom> Control.Exception has information.
12:54:54 <dozer> so if "f=\(Just a) -> a" then can I do "f `catch` oops" or something like that?
12:54:54 <Cale> Normally to use catch to catch such errors, you also need evaluate
12:55:03 <Cale> (which is in Control.Exception)
12:55:07 <dozer> ok
12:55:28 <Cale> it evaluates something in sequence with IO, so that you can be certain that if there's an exception, you'll catch it then
12:55:31 <sorear> just not with *that* catcgh
12:55:56 <Cale> Otherwise, you just end up returning the error without doing any evaluation.
12:56:12 <Cale> (and it goes off later, after the catch has gone by)
12:56:20 <dozer> I'm thinking of hacking the hxt xpickle stuff, because it has rubbish failure reporting
12:56:40 <dozer> tends to give empty results with no feedback about what bit of the xml didn't fit the xpickle instance in scope
12:56:43 <Cale> Typically, nobody tries to catch such errors, because it's just way too much trouble, and there are better ways to deal with it.
12:57:00 <Cale> You make your functions fail more gracefully, and handle all patterns.
12:57:20 <Cale> Watch out for things like head and tail and so on.
12:57:29 <Cale> fromJust is another one
12:58:13 <Cale> Wherever you use such functions, you're obligated to check that you only ever apply them to appropriate values.
12:58:37 <dozer> I want errors like "was expecting an element named "Foo" but got one named "Bar" at (path to document root)"
12:58:48 <monochrom> No, you're only obliged to hide your errors and pretend the program works. :)
13:07:01 <OceanSpray> I've decided against parsing into an abstract-syntax tree first and then interpreting that.
13:07:17 <OceanSpray> a Lisp list IS an abstract syntax tree.
13:07:53 <monochrom> except you're reading characters
13:08:09 <OceanSpray> furthermore, since my lisp foregoes macros and the like in favor of fexprs, making ABSs would add a level of complexity with little benefit.
13:08:19 <OceanSpray> what do you mean, reading characters?
13:08:47 <monochrom> If I enter "(+ 1 2)" you receive characters.
13:08:51 <OceanSpray> yes
13:09:17 <OceanSpray> and the parser parses that into a list (Pair + (Pair 1 (Pair 2 Null)))
13:09:39 <monochrom> OK, I agree.
13:10:10 <OceanSpray> if the parser translated that into an ABS first, there would be no difference from the LispVal created.
13:10:19 <OceanSpray> hence, a useless layer.
13:10:58 <monochrom> How many hours left? :)
13:11:07 <OceanSpray> until?
13:11:11 <sjanssen> OceanSpray: so how do you plan to solve the IORef problem?
13:11:46 <OceanSpray> someone said they're workin' on layering parsec onto arbitrary monads, right?
13:11:52 <monochrom> until the planned finishing time. I heard something like you'll do it in 68 hours or some double-digit number.
13:12:06 <OceanSpray> monochrom, I'm not following that tutorial anymore
13:12:18 <sjanssen> OceanSpray: yes, I've heard that.  I don't know when it will be finished
13:12:25 <OceanSpray> he said a couple of days
13:12:46 <OceanSpray> in the mean time, I'll just work on the other parts, like the evaluator and primitive procedures
13:13:03 <OceanSpray> and when he's done, my interpreter will function as a sort of "field test"
13:21:51 <laz0r> @define funkyshit (x:xs) = [y:ys | y <- x, ys <- funkyshit xs]
13:21:55 <lambdabot> Undefined.
13:22:00 <laz0r> mmh
13:22:06 <laz0r> @type funkyshit (x:xs) = [y:ys | y <- x, ys <- funkyshit xs]
13:22:08 <lambdabot> parse error on input `='
13:22:15 <OceanSpray> hey xerox, how far are ya?
13:22:17 <laz0r> @type [y:ys | y <- x, ys <- funkyshit xs]
13:22:19 <lambdabot> Not in scope: `x'
13:22:19 <lambdabot>  
13:22:19 <lambdabot> <interactive>:1:22: Not in scope: `funkyshit'
13:25:50 <shachaf> laz0r: @let
13:26:05 <xerox> OceanSpray: I'm heading to bed actually :)
13:26:32 <OceanSpray> HOLY NETSPLIT, BATMAN!
13:26:45 <kaol> @users
13:26:46 <lambdabot> Maximum users seen in #haskell: 385, currently: 356 (92.5%), active: 14 (3.9%)
13:26:59 <laz0r> @let funkyshit (x:xs) = [y:ys | y <- x, ys <- funkyshit xs] in funkyshit [[1,2],[3,4]]
13:26:59 <lambdabot>  Parse error
13:27:08 <OceanSpray> xerox, I meant your SoC parsec layering thing
13:27:12 <shachaf> laz0r: No, that would be "> let".
13:27:16 <laz0r> > let funkyshit (x:xs) = [y:ys | y <- x, ys <- funkyshit xs] in funkyshit [[1,2],[3,4]]
13:27:18 <lambdabot>   Non-exhaustive patterns in function funkyshit
13:27:38 <sjanssen> laz0r: funkyshit []
13:27:41 <xerox> OceanSpray: I'm not sure, one can do it in many ways, am working on finding a good one atm
13:27:42 <laz0r> @define funkyshit [] = [[]]
13:27:49 <lambdabot> Undefined.
13:27:54 <shachaf> laz0r: No, use a ';'.
13:28:00 <OceanSpray> oh, so you haven't started coding yet?
13:28:04 <shachaf> laz0r: let f [] = ...; f (x:xs) = ... in f ...
13:28:08 <OceanSpray> I'm screwed.
13:28:13 <xerox> OceanSpray: no, I have code.
13:28:13 <sjanssen> laz0r: umm, maybe you want to install ghci? :)
13:28:14 <laz0r> > let funkyshit [] = [[]]; funkyshit (x:xs) = [y:ys | y <- x, ys <- funkyshit xs] in funkyshit [[1,2],[3,4]]
13:28:15 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
13:28:18 <laz0r> yay!
13:28:28 <shachaf> > sequence [[1,2],[3,4]]
13:28:29 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
13:28:33 <laz0r> i hust wanted to play around with lambdabot
13:28:37 <laz0r> *just
13:29:02 <shachaf> laz0r: You can also do that with /msg.
13:29:08 <laz0r> ah ok
13:29:32 <sjanssen> OceanSpray: you might be able to do a neat higher-kinded trick.  Lemme make a sketch
13:30:04 <OceanSpray> ?
13:35:00 <mlguy> Is there a GHC hacker in the house?
13:35:13 <byorgey> @type fromJust
13:35:15 <lambdabot> forall a. Maybe a -> a
13:35:23 <byorgey> @index fromJust
13:35:23 <lambdabot> Data.Maybe
13:35:25 <mlguy> My build from HEAD is failing with a #include line, as follows:
13:35:28 <mlguy> Data/Generics.hs:28:1: lexical error at character 'i'
13:35:29 <sieni> > fromJust Nothing
13:35:30 <lambdabot>  Exception: Maybe.fromJust: Nothing
13:35:40 <conal> I've just installed ghc-6.7, and "ghc-pkg list" tells me i have only {ghc-6.7.20070810}, rts-1.0.  so, e.g., cabal doesn't work.  does that seem right?  i've forgotten how to get going with a new ghc release.  any pointers?
13:35:48 <byorgey> > fromJust (Just fromJust)
13:35:49 <lambdabot>  Add a type signature
13:36:06 <mlguy> conal, are you installing from darcs or some other way?
13:36:27 <conal> mlguy: do you mean installing ghc-6.7?
13:36:29 <OceanSpray> sjanssen, ???
13:36:45 <sjanssen> OceanSpray: "Lemme make a sketch"
13:36:58 <sieni> > fromJust (Just (fromJust :: Maybe Int -> Int))
13:36:59 <lambdabot>  <Maybe Int -> Int>
13:37:08 <OceanSpray> oh
13:37:08 <rapido> i've implemented http://www.burtleburtle.net/bob/c/lookup3.c in haskell <- a fast hashing algorithm
13:37:10 <OceanSpray> ok
13:37:28 <mlguy> I'm not even sure what ghc-6.7 means, but I assume you mean the current development version?
13:37:41 <rapido> i never thought ghc would compile bit munching so efficiently
13:37:45 <conal> mlguy: yes.  HEAD from Aug 10
13:37:53 <rapido> it is REALLY amazing
13:38:20 <samreid> xerox: ping (still awake?)
13:38:31 <mlguy> I've been having trouble getting it to build, but ./darcs-all is the thing you want
13:38:55 <mlguy> I imagine you probably need ./darcs-all --extralibs get, but check either README or the source
13:40:29 <hpaste>  sjanssen pasted "for OceanSpray" at http://hpaste.org/2264
13:40:44 <conal> mlguy: ah, thanks.  i downloaded a windows installer.  i'll see if i got darcs-all
13:40:47 <OceanSpray> hmm
13:41:02 <hpaste>   drigz pasted "stack overflow" at http://hpaste.org/2265
13:41:12 <drigz> ^^^ forget that
13:43:34 <mlguy> conal: oi, windows.  Outside my expertise I'm afraid.  But if you did get darcs-all, you probably win.
13:44:00 <conal> mlguy.  thanks. i don't have darcs-all, though i've found a copy at http://darcs.haskell.org/ghc/darcs-all.  i'll give it a try.
13:44:41 <Itkovian> rapido: care to share?
13:44:45 <Saizan> conal: are you trying to install a snapshot?
13:45:35 <sjanssen> OceanSpray: does that make sense?
13:45:58 <rapido> ltkovian: sure
13:46:09 <OceanSpray> I'm a haskell novice, so not very much
13:47:01 <rapido> this is the haskell code:
13:47:11 <conal> Saizan: yes, a snapshot.
13:47:23 <hpaste>  sjanssen annotated "for OceanSpray" with "with the opposite of transform, and pretty printing" at http://hpaste.org/2264#a1
13:48:40 <conal> does anyone know how to install ghc from a snapshot and get the extralibs?
13:48:43 <sjanssen> OceanSpray: rather than hardcoding the reference type, we make it a parameter of LispVal
13:48:52 <OceanSpray> huh
13:48:54 <OceanSpray> interesting
13:48:55 <sjanssen> OceanSpray: then we introduce a dummy reference, Identity
13:48:56 <conal> (a HEAD snapshot)
13:49:53 <sjanssen> OceanSpray: this has some other neat applications
13:50:35 <sjanssen> OceanSpray: you can have several versions of your interpreter with varying levels of purity
13:51:02 <sjanssen> you might use "LispVal Identity" to write an interpreter that doesn't support the set* operations of lisp
13:51:26 <sjanssen> "LispVal IORef" is for an interpreter that can do anything, like IO and foreign calls
13:51:36 <OceanSpray> I see
13:51:39 <Heffalump> LispVal IO, presumably
13:51:53 <OceanSpray> what about environments?
13:51:54 <sjanssen> Heffalump: we're parametric on the reference type, rather than the monad
13:52:06 <sjanssen> hmm, not sure about environments
13:52:06 <Heffalump> isn't Identity the name of a monad, though?
13:52:19 <sjanssen> OceanSpray: what is the real definition of LispVal?
13:52:47 <OceanSpray> sjanssen, see http://hpaste.org/2263
13:52:50 <sjanssen> Heffalump: yes, but we're using it as a trivial wrapper here
13:53:30 <sjanssen> OceanSpray: hmm, I suppose you need to observe sharing in these environments?
13:53:42 <OceanSpray> what's that mean?
13:54:09 <sjanssen> can I modify the contents of a 'parent' LispEnv?
13:54:14 <OceanSpray> yes
13:55:33 <hpaste>  rapido pasted "amazing bit munching ghc code" at http://hpaste.org/2266
13:55:50 <OceanSpray> (begin (define a 2) ((lambda () (set a 5))) a) should return 5
13:56:28 <OceanSpray> the begin encloses the parent, with the lambda inside enclosing its 'child'
13:57:18 <OceanSpray> naturally, since a is not defined within the child, the set in the lambda modifies the a in the parent.
13:57:30 <sjanssen> hmm
13:57:41 <sjanssen> can you change the actual set of bindings too?
13:57:59 <OceanSpray> what do you mean?
13:58:06 <sjanssen> is it possible to extend a parent's scope with a new variable, for example?
13:58:42 <OceanSpray> do you mean can you 'define' a variable in the parent from a child?
13:58:50 <sjanssen> yeah
13:58:55 <OceanSpray> nope.
13:59:28 <OceanSpray> define has no side effect.
14:00:07 <rapido> hey littledan!
14:00:19 <littledan> hey rapido!
14:00:49 <rapido> just pasted some ghc magic: http://hpaste.org/2266
14:01:45 <sjanssen> OceanSpray: I think we can just do the same trick to LispEnv and LispProc
14:01:52 <rapido> littledan: interesting to see what code factor would generate
14:01:56 <sjanssen> OceanSpray: I believe that will do the right thing
14:02:12 <OceanSpray> same trick, as in make them parametric?
14:02:16 <sjanssen> yes
14:02:21 <littledan> rapido, we should continue this discussion in #concatenative, but see extra/fjsc
14:02:40 <rapido> littledan: ok, see you there
14:03:53 <shapr> I wonder if Wolfgang Thaller is part of the reason GHC generates such marvelous PPC code.
14:04:14 <sjanssen> is the x86 code that good?
14:04:15 <OceanSpray> sjanssen, I have to go
14:04:20 <OceanSpray> but I'll be thinking...
14:07:01 <hpaste>  Cale annotated "amazing bit munching ghc code" with "intel" at http://hpaste.org/2266#a1
14:07:43 <sjanssen> why does the Intel version have so much stack manipulation?
14:08:03 <lament> looks like intel doesn't have enough registers, why am i not surprised
14:08:09 <sorear> sjanssen: because that's what ghc does
14:08:20 <sjanssen> sorear: not on PPC, apparently
14:08:26 <sjanssen> why should they be different?
14:08:32 <sorear> sjanssen: ghc's intel register allocator a joke currently
14:08:51 <lament> so ghc is optimized for powerpc? :)
14:08:52 <shapr> Does GHC use more registers on X86_64?
14:08:57 <lament> that would be a nice marketing spin... somehow
14:09:30 <shapr> I think x86_64 has 8 more registers in 64 bit mode.
14:09:34 <sjanssen> sorear: are there technical limitation, or is it just time and effort?
14:10:06 <sorear> sjanssen: time and effort and lack of interest I think
14:10:22 <Heffalump> it's getting rewritten, right?
14:11:49 <shapr> Cale: What are you using for a disassembler?
14:12:05 <Cale> shapr: I'm just dumping the GHC assembly
14:12:12 <sorear> shapr: he doesn't need one, ghc uses gas
14:12:15 <sorear> -ddump-asm
14:12:27 <shapr> oh
14:12:35 <Cale> In fact, I just used the same command he listed in the paste
14:12:52 <Cale> ghc -S -O2 -funfolding-use-threshold32  QuickHash.hs
14:13:13 <shapr> -S == -ddump-asm ?
14:13:45 <Cale> Similar. I think it just stops after generating assembly, rather than continuing.
14:15:03 <hpaste>  shapr annotated "amazing bit munching ghc code" with "asm with x86_64" at http://hpaste.org/2266#a2
14:15:44 <shapr> Looks shorter
14:16:31 <phobes> Does GHC use C-- to generate asm?
14:16:55 <monochrom> If you use -fasm, yes.
14:16:58 <shapr> Ah, it's using MMX instructions.
14:17:10 <phobes> monochrom: what's the default?
14:17:13 <phobes> gcc?
14:17:22 <rapido> shapr: i couldn't get '-ddump-x' to work somehow
14:17:37 <monochrom> -O0 uses -fasm, -O1 and -O2 uses fvia-C. But the latter is about to change.
14:17:56 <phobes> ok
14:17:57 <shapr> rapido: What version of GHC are you using?
14:18:11 <shapr> And by the way, -fasm is *MUCH* faster than -fvia-C
14:18:19 <monochrom> If -fvia-C, translates C-- to C.
14:18:31 <shapr> Like, thirty seconds as compared to 2.5 minutes for HAppS.
14:18:35 <rapido> shapr: 6.4.1
14:18:35 <kilimanjaro> shapr, wow
14:18:41 <kilimanjaro> that's pretty significant :)
14:19:01 <shapr> rapido: Try it with GHC 6.6.1 ?
14:19:04 <kilimanjaro> shapr, how large is HAppS?
14:19:04 <monochrom> gcc takes a long time digesting GHC's unreadable C code :)
14:19:34 * shapr installs sloccount
14:19:34 <phobes> shapr: do you mean compiling time? or speed of the resulting executable?
14:19:39 <shapr> compilation time
14:19:44 <phobes> ok
14:19:47 <rapido> shapr: i feel stupid - i thought i was using 6.6.1 - argh
14:19:59 <shapr> kilimanjaro: 7k lines of Haskel
14:20:00 <shapr> l
14:20:42 <alexj> shapr what are you counting?
14:20:56 <shapr> alexj: Compilation time of HAppS with -fvia-C vs -fasm
14:21:02 <alexj> ah ok.
14:21:16 * monochrom hugs his context :)
14:21:18 <rapido> shapr: let me get 6.6.1 and i'll report back... later
14:21:23 <shapr> rapido: ok
14:22:42 <sjanssen> shapr: the difference is so profound that xmonad has -fasm in the ghc-options line
14:25:03 <monochrom> The result of -fasm is almost as good as -fvia-C. There are just a few exceptions e.g. intensive floating-point crunching.
14:25:57 <monochrom> Two years ago -fasm used to be bad.
14:27:22 <sorear> It still is bad, but due to factors that hit GCC just as bad.
14:28:02 <rapido> sorear: what factors are you referring to?
14:28:14 <rapido> caches? pipelines? etc?
14:28:22 <sorear> The reason GHC output twiddles the stack so much is because the stg->cmm pass generates code that makes alias analysis effectively impossible for both -fasm and -fvia-C
14:28:42 <sorear> rapido: I wrote memset once, the inner loop maked 11 memory accesses
14:28:53 <sorear> to write 1 word
14:30:33 <iskaldur> is there a name for the following: I have a list of strings ["A","B","C"] and I want to "concatenate" the list ["1","2","3"] to get ["A1","A2",A3, B1, B2, B3, C1, C2, C3]....what is this concatenate-like operation called?
14:30:48 <Botje> sequence
14:30:55 <Cale> iskaldur: it's a Cartesian product, and yeah, sequence
14:31:11 <iskaldur> so its called sequencing [A,B,C] with [1,2,3]?
14:31:15 <Botje> > sequence (words "A B C") (words "1 2 3")
14:31:16 <lambdabot>  Couldn't match expected type `[String] -> t'
14:31:17 <Cale> > sequence [["A","B","C"],["1","2","3"]]
14:31:18 <lambdabot>  [["A","1"],["A","2"],["A","3"],["B","1"],["B","2"],["B","3"],["C","1"],["C",...
14:31:20 <iskaldur> hmm, ok, thanks
14:32:02 <Cale> iskaldur: I'd call it the Cartesian product of ["A","B","C"] with ["1","2","3"], or at least a related idea to that :)
14:32:31 <Cale> > sequence ["ABC","123"]
14:32:33 <lambdabot>  ["A1","A2","A3","B1","B2","B3","C1","C2","C3"]
14:32:52 <samreid> > [ x ++ y | x <- ["A","B","C"], y <- ["1","2","3"] ]
14:32:53 <lambdabot>  ["A1","A2","A3","B1","B2","B3","C1","C2","C3"]
14:32:54 <litb> that's really simple
14:32:59 <Cale> > sequence ["ABC","123","xy"]
14:33:00 <lambdabot>  ["A1x","A1y","A2x","A2y","A3x","A3y","B1x","B1y","B2x","B2y","B3x","B3y","C1...
14:33:03 <mrd> list monad is fun
14:33:04 <mrd> @yow
14:33:04 <lambdabot> I'm also pre-POURED pre-MEDITATED and pre-RAPHAELITE!!
14:33:12 <litb> while samreids one is not that simple
14:33:27 <mrd> it's the same thing, different syntax
14:33:27 <litb> well, but now i understand it
14:33:31 <litb> it's like math
14:33:36 <Cale> samreid's is more obvious though :)
14:33:39 <mrd> vaguely like Set notation
14:34:05 <Cale> This application of sequence is pretty clever :)
14:34:28 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
14:34:29 <lambdabot>  [5,7,10,25,32]
14:34:29 <byorgey> now iskaldur will wonder why the cartesian product function is called 'sequence' =)
14:34:36 <iskaldur> yep :)
14:34:49 <Cale> It's actually a general monad function
14:34:54 <byorgey> iskaldur: it's actually a more general function than that, but it's probably not that important for now =)
14:35:07 <jjore-w> I'm trying to install the X11 package from Hackage but it fails saying "/usr/bin/ld: cannot find -lX11" Umm... where do I debug this?
14:35:14 <Cale> It takes a list of computations in some monad, and produces a computation which runs each in turn, producing a list of results
14:35:26 <shapr> sorear: So, is there some way to fix the stg->cmm pass so that alias analysis is better?
14:35:34 <Cale> A computation in the list monad runs by producing each of its elements, nondeterministically :)
14:36:08 <samreid> > replicateM 8 "01" !! 65
14:36:10 <lambdabot>  "01000001"
14:36:15 <Cale> > sequence [Just 5, Just 7, Just 12, Just 18, Just 27]
14:36:16 <lambdabot>  Just [5,7,12,18,27]
14:36:27 <Cale> > sequence [Just 5, Just 7, Just 12, Nothing, Just 27]
14:36:29 <lambdabot>  Nothing
14:36:37 <iskaldur> and... so if a function f gave me [A,B,C] and g gave me [1,2,3]....is the function h that gives me the sequence/cart prod of f and g be called the bind of f and g?
14:36:40 <shapr> I think sjanssen's powerset is totally amazing.
14:37:12 <shapr> jjore-w: You need to have the X11 libs installed and findable.
14:37:22 <Cale> iskaldur: well, it's like  [A,B,C] >>= \x -> [1,2,3] >>= \y -> return [x,y]
14:37:32 <sorear> shapr: surely, we can just generate code that uses parameters and local variables instead of stack munging *but* it has to be transformed away somehow because we don't (and won't, Simon Says it's too much work to get signal stacks working) use the system stack
14:37:39 <Cale> Or,  liftM2 (\x y -> [x,y]) [A,B,C] [1,2,3]
14:37:53 <shapr> jjore-w: Specifically -lX11 means you should get some results from "ls /usr/lib/libX11*"
14:38:01 <Cale> > liftM2 (\x y -> [x,y]) "ABC" "123"
14:38:03 <lambdabot>  ["A1","A2","A3","B1","B2","B3","C1","C2","C3"]
14:38:10 <sjanssen> jjore-w: this xmonad FAQ might help http://xmonad.org/faq.html#x11
14:38:11 <lambdabot> Title: xmonad : frequently asked questions
14:38:20 <Cale> > "ABC" >>= \x -> "123" >>= \y -> return [x,y]
14:38:21 <lambdabot>  ["A1","A2","A3","B1","B2","B3","C1","C2","C3"]
14:38:21 <shapr> jjore-w: Alternatively, try asking on the #xmonad channel.
14:38:30 <Cale> > "ABC" >>= \x -> "123" >>= \y -> [x,y]
14:38:31 <lambdabot>  "A1A2A3B1B2B3C1C2C3"
14:38:34 <iskaldur> it's been too long since ive worked with monads :(
14:38:36 <jjore-w> shapr, thanks. I didn't realize I was asking a FAQ.
14:38:39 <byorgey> shapr: by "sjanssen's power set" you mean filterM (const [True, False])?
14:38:40 <jjore-w> :-/
14:38:45 <shapr> byorgey: yup
14:38:48 <shapr> jjore-w: No worries
14:38:53 <byorgey> shapr: yeah, pretty nifty =)
14:39:15 <Vq^> yeah, that one is nice :)
14:40:13 <Cale> iskaldur: you can regard xs >>= f as taking each element of xs and applying f to it in order to get a list and it then concatenates all the results
14:40:17 <Cale> that is
14:40:19 <shapr> Reminds me of a guy on the shootout mailing list who said "The Eiffel language is the most concise way to solve this problem!" and someone said, "Look at the GHC versions." and he said "Oh."
14:40:23 <Cale> xs >>= f = concap (map f xs)
14:40:27 <Cale> concat*
14:40:34 <byorgey> ...when xs is a list.
14:40:41 <Cale> right
14:41:29 <Cale> > "Hello" >>= replicate 3
14:41:30 <lambdabot>  "HHHeeellllllooo"
14:41:42 <Vq^> :)
14:42:36 <litb> how many operators does haskell have?
14:42:42 <iskaldur> cale: ah, right, slowly coming back :)
14:42:43 <Cale> litb: arbitrarily many
14:42:44 <sorear> litb: A countable infinity of them
14:42:52 <byorgey> > "Hello" >>= repeat -- someone with a very bad stutter
14:42:53 <lambdabot>  "HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH...
14:42:57 <litb> is infinity countable?
14:43:05 <Cale> litb: Some infinities are
14:43:06 <byorgey> litb: some are
14:43:23 <Cale> It means that there's a bijection between that infinity and the natural numbers
14:43:33 <litb> "some"?
14:43:36 <litb> ah
14:43:41 <sorear> aleph-null
14:44:01 <olliej_> sorear: aleph-null bottles of beer on the wall, aleph-null bottles of beer...
14:44:18 <litb> ok. so, it is countable if the items are concrete, and not countable if they are not concret ?
14:44:22 <desp> @pl (\(a, b) -> (xs !! a, xs !! b))
14:44:22 <lambdabot> (xs !!) *** (xs !!)
14:44:26 <olliej_> take one down and pass it around, aleph-null bottles of beer on the wall....
14:44:31 <Cale> Well, that's questionable :)
14:44:32 <desp> isn't there some ***^2 operator?
14:44:37 <Cale> Are real numbers concrete?
14:44:41 <litb> like "infinitely much litres of water" is not countable infinity ?
14:44:47 <litb> or how should i see that?
14:44:51 <byorgey> desp: ?
14:45:08 <desp> byorgey: look at @pl output :)
14:45:08 <byorgey> desp: oh, I see what you're asking
14:45:14 <Cale> litb: Well, the infinities we're talking about are the ones which are used to measure the sizes of sets
14:45:17 <lament> Cale: in some sense aren't, since you can't specify them... :)
14:45:17 <samreid> litb: that's more of an extra point on the number line
14:45:33 <byorgey> desp: join (***)
14:45:34 <Cale> rather than ones which are part of extending the number line with additional points
14:45:38 <sorear> litb: well, that could be countable or uncountable, although you'd need a pretty big universe to hold ◊ê_0 liters of water
14:45:46 <sorear> s/0/1
14:45:47 <desp> hmm.
14:45:50 <Cale> lament: Well, you can't specify all of them :)
14:45:56 <astrolabe> litb: A good way to understand this stuff would be to look up Cantor's diagonalisation argument
14:46:03 <dozer> litb: the integers [0..] are countable - by definition but go on for ever
14:46:12 <samreid> litb: countable, since you're counting molecules :-D
14:46:12 <lament> Cale: the set of specifable reals is surely countable :)
14:46:24 <byorgey> > join (***) ([2,4..] !!) $ (3,6)
14:46:26 <lambdabot>  (8,14)
14:46:27 <Cale> Right, so there are reals which are not definable.
14:46:32 <Toxaris> litb: it is countable if you can enumerate all of it, given an infinite amount of time. and yes, there are things you can't enumerate even given infinite time :)
14:46:33 <desp> > let f xs = (xs !!) ** (xs !!) in f ['A', 'B'] (0, 1)
14:46:34 <lambdabot>  Couldn't match expected type `Int' against inferred type `(a, b)'
14:46:51 <desp> > let f xs = (xs !!) *** (xs !!) in f ['A', 'B'] (0, 1)
14:46:52 <lambdabot>  ('A','B')
14:47:02 <dozer> litb: but you run out of integers if you try to line them up with all the possible collections of integers like 0, 1 0,1 2 0,2 1,2 0,1,2 and so on
14:47:07 <desp> > let f xs = (join (***)) (xs !!) in f ['A', 'B'] (0, 1)
14:47:08 <lambdabot>  ('A','B')
14:47:13 <Cale> In fact, which reals are definable is very dependent on the underlying set theory, and the definability of certain real numbers turns out to be equivalent to the existence of certain large cardinals.
14:47:17 <desp> byorgey++
14:47:23 <desp> incomprehensible code ftw
14:47:48 <lament> Cale: oh here we go again :)
14:47:50 <sorear> desp: be careful about that, the finite sets of integers ARE countable, you need to allow infinite sets to get the full Bet[1] goodness
14:48:02 * desp &> dozer
14:48:08 <Cale> But let's get away from that. Here, let me make everything much more clear, by defining 'function' 'bijection' and so on :)
14:48:20 <litb> ah, so countable/not countable is not a mathematically term, but a real-world term?
14:48:29 <Cale> no, it's a mathematical term
14:48:35 <byorgey> desp: heh, indeed
14:48:36 <Cale> Has nothing to do with the real world :)
14:48:58 <Toxaris> litb: nope, it's a mathematical term, I just tried to phrase it real-worldish and most probably it wasn't even correct (if you answered to my remark)
14:49:19 <litb> well, i will take a look into wikipedia
14:49:22 <byorgey> desp: gotta love code mixing up the pure-function instances of Arrow AND Monad =)
14:49:24 <lament> litb: the difference between different kinds of infinities is not really a real-world issue :)
14:49:36 <litb> i only know +inf and -inf . not more =)
14:49:37 <desp> hehe
14:49:43 <dozer> litb: take a look at the wikipedia pages for ordinals and cardinals - they prety much explain it all
14:50:00 <Cale> Okay, suppose that X and Y are sets (I'm not going to precisely define set right now)
14:50:05 <litb> there was no "countable inf / non-countable inf" for me so far
14:50:18 <Toxaris> litb: now +inf vs. -inf is another story :)
14:50:32 <Cale> Then a function f: X -> Y is a set of pairs (x,y) with x in X and y in Y, such that for each x in X, there is exactly one y in Y for which (x,y) is in f.
14:50:45 <Cale> When (x,y) is in f, we write f(x) = y
14:51:04 <Cale> Is that cool?
14:51:28 <monochrom> when has #haskell become #math?
14:51:42 <litb> Cale: you speak to me?
14:51:43 <Cale> For example, the function for which f(x) = x^2 is really the set of all pairs (x,x^2) for each number x
14:51:44 <Cale> yeah
14:51:55 <litb> wait a min, i will catch up :)
14:52:09 <Cale> So for instance, it has (0,0), (1,1), (5,25), (4,16) and so on in it.
14:52:40 <lament> Cale: i don't think it's cool, but i'm not gonna argue :)
14:52:59 <Cale> There's a function f: {0,1,2} -> {orange, grape} which is {(0,orange), (1,grape), (2,orange)}
14:53:04 <litb> Cale: yes
14:53:12 <litb> Cale: i'm aware of that
14:53:20 <Cale> X is called the domain of f and Y is called the codomain
14:53:41 <conal> sorear: i got your note.  do you mean to use the 0811 snapshot?  it's the latest i see, and it crashes on my machine.
14:53:42 <litb> ok, that is new :)
14:54:08 <litb> however, that is not a bijective one
14:54:15 <Cale> right, it's not
14:54:37 <Cale> A function f is injective if whenever f(x) = f(y), we have that x = y
14:54:59 <sorear> conal: anything recentish should have whatever feature you want; 0712 works for me
14:55:07 <litb> yeah, there was something like that in highscool
14:55:19 <litb> and then there is surjective which means another thing i forgot
14:55:22 <Cale> that is, if it doesn't send two elements of its domain to the same element of its codomain
14:55:32 <Cale> A function f: X -> Y is surjective if for every y in Y, there is some x in X for which f(x) = y
14:55:56 <conal> sorear.  thanks.  do you use 0712 on windows?
14:56:03 <Cale> That is, every element of its codomain is "covered"
14:56:07 <sorear> conal: er, no :(
14:56:31 <Cale> Note that just being a function means that every element of its domain is used.
14:56:50 <conal> sorear: i see, thanks.  do you know how recent a version i'd need to get the required support for haddock.ghc?
14:56:56 <conal> or does anyone know?
14:56:58 <Cale> litb: Is that clear?
14:57:09 <litb> Cale: yes
14:57:15 <Tac-Work> Total functions are cooler than partial functions
14:57:29 <Cale> okay, so if a function is both injective and surjective, it's called bijective
14:57:30 <sorear> conal: 5 months or so
14:57:38 <Cale> (or a bijection)
14:57:39 <Tac-Work> Partial functions cause only misery to programmers
14:57:57 <Cale> Yeah, partial functions aren't functions in my definition :)
14:58:03 <Tac-Work> yes
14:58:21 <Tac-Work> It makes me think of all the poor poor highschool students who think that if x^2 = y
14:58:22 <TSC> You can say that a partial function is just a function with a smaller domain
14:58:27 <Tac-Work> then x = sqrt y
14:58:42 <monochrom> "a function is a set" is not cool to me. "a relation is a set" neither.
14:58:43 <litb> Cale: i see. a isomorphism between two graphs, for example, is a bijection
14:58:49 <Cale> yes
14:58:50 <Tac-Work> there are total functions, partial functions, multivalued functions
14:58:55 <litb> i recall that frm the discrete structure lessen
14:58:56 <balodja> Cale: macclein writes that from "surjectivity" and "injectivity" doesn't follow isomorphism. Is there any simple example to that?
14:58:57 <litb> *lesson
14:59:17 <Cale> A bijection between the vertex sets, in particular.
14:59:18 <lament> monochrom: it's not cool to me either, so let's gang up on cale - after he has finished teaching litb :)
14:59:28 <lament> monochrom: right now, interrupting him would be rather counterproductive
14:59:31 <Cale> balodja: That comes from using strange categories :)
14:59:49 <monochrom> Yeah I know.
15:00:17 <Cale> Yeah, a bunch of the people in this channel don't like useful definitions ;)
15:00:18 <Tac-Work> some functions take functions as arguments and return functions of functions
15:00:23 * sorear likes "functions are primitive sets aren't" better
15:00:29 <Tac-Work> we call those functions of three parameters
15:00:38 <pgavin> woohoo! I straight A's this semester :)
15:00:41 <litb> hm, a function is a relation, and a relation is a set
15:00:45 <litb> how is that wrong?
15:00:46 * Toxaris prefers type theory over set theory
15:00:50 <Cale> litb: yes, that's right
15:00:53 <lament> litb: it's not wrong.
15:00:53 <Tac-Work> A set is a function
15:01:02 <lament> litb: ignore monochrom and Tac-Work and me. Just listen to Cale.
15:01:02 <pgavin> lol, I can't type...
15:01:18 <Cale> litb: If someone tells you otherwise, just sort of look at them funny and back out of the room ;)
15:01:35 <Tac-Work> A set is a function from elements to {True, False}
15:01:43 <ddarius> balodja: The categorical concepts of epimorphism and monomorphism do though.
15:01:54 <Cale> Tac-Work: If only that actually worked :)
15:02:04 <Tac-Work> doesn't it though?
15:02:11 <Cale> Only if you have some universal set.
15:02:19 <lament> Tac-Work: a function from _what_ to true, false?
15:02:30 <Tac-Work> lament: S: a -> Bool
15:02:45 <Tac-Work> forall a. a -> Bool
15:02:49 <Toxaris> lament: from the domain of some type :)
15:03:00 <Cale> okay
15:03:03 <Tac-Work> and the set of all sets is the function (const 1)
15:03:03 <ddarius> f is an isomorphism if there exists an g such that f . g = id and g . f = id.  In any Set Theory you want, a "set" S is countably infinite if it's isomorphic (that is there exists an isomorphism between) to N, the set of natural numbers.
15:03:09 <Tac-Work> err (const True)
15:03:17 <Cale> So let's look at some nice sets and determine what kind of infinite they are :)
15:03:21 <litb> Tac-Work: yes, sure
15:03:40 <Tac-Work> The set of all sets is a sad set indeed though
15:03:42 <Cale> The integers -- naively, you might expect there to be twice as many integers as natural numbers
15:03:46 <dozer> ah, now we're getting to the point where you show that sets and functions can be mutually derived from the other, but there's no a-prior way to construct the one without the other, and then the axiom of choice shows up for tea and we have to give up on the idea any system is both logically consistent and doesn't hold assumptions, and from the left they shout "use category theory" and from the righ they scream "type theory makes this all clearer
15:03:46 <dozer> dy points out that you can simulate all of these using all of the others and Turing chuckles in his grave
15:03:50 <sorear> conal: btw, waern is awake
15:03:58 <Cale> However, we can pair them up with naturals quite easily:
15:04:00 <Tac-Work> The set of all sets is so fat, it contains its own powerset. A very obesse set indeed.
15:04:13 <waern> sorear, conal: hi
15:04:15 <ddarius> Cale: 2n - 1 !
15:04:26 <Cale> 0,1,-1,2,-2,3,-3,...
15:04:26 <monochrom> dozer: who is dy?
15:04:32 <balodja> Tac-Work: Russel's set? :)
15:04:36 <Cale> ddarius: sure :)
15:04:50 <sorear> conal: he's the person to ask about haddock.ghc things if possible
15:05:25 <Cale> Producing a bijection from the natural numbers to a set is the same as making a list
15:05:28 <lament> tac-work: then "a set of all sets that don't contain themselves" is simply F s = not (s s)
15:05:30 <Cale> (an infinite list)
15:05:44 <Tac-Work> yes
15:05:48 <Toxaris> Tac-Work: show me other set as functions with type (forall a . a -> Bool)
15:05:59 <Tac-Work> eh?
15:06:04 <Toxaris> Tac-Work: beside const True and const False
15:06:05 <Tac-Work> oh
15:06:05 <lament> Tac-Work: so, what's F F?
15:06:06 <Tac-Work> yeah
15:06:11 <litb> 1<->element1,2<->element2,3<->element3.....
15:06:14 <Tac-Work> brb
15:06:16 <litb> like that one, Cale?
15:06:26 <Cale> litb: yes, exactly
15:06:36 <Cale> It's also possible to enumerate the rational numbers (that is, fractions of integers), such that every rational number occurs just once in the list.
15:06:49 <Tac-Work> {1,2,3} = X iff X el = el == 1 || el == 2 || el == 3
15:06:57 <monochrom> I know a Functional Pearl article for that!
15:07:36 <gkr> (You can find a nice introduction on cardinallity in Kleene's book Metamathematics)
15:08:16 <Toxaris> Tac-Work: what type has (==)?
15:08:18 <litb> Cale: all is quite clear :)
15:08:37 <byorgey> > fix ((1:) . (>>= \x -> [1+x, 1/(1+x)])) :: [Rational]
15:08:38 <lambdabot>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
15:08:40 <Tac-Work> Toxaris: In haskelll or in mathematics?
15:08:47 <Cale> The cheesy, but easily described way to do that is to just list the possible numerators across the (infinite) page, and the possible denominators running down, and just pick the diagonals, skipping any element that's equivalent to something already there.
15:08:50 <Toxaris> Tac-Work: in mathematics
15:08:52 <lament> Tac-Work: ah, so you're not away, so tell me what F F is :)
15:08:52 <desp> ugh
15:08:53 <Tac-Work> In mathematics, everything is a member of Eq
15:08:59 <Cale> there are more elegant ways though :)
15:09:00 <desp> any fellow project-eulerites with problem 44 done?
15:09:16 <Tac-Work> lament: F F is nothing until you hit Control+C
15:09:17 <byorgey> desp: yes, me
15:09:26 <desp> byorgey: why isn't the answer (35, 35)
15:09:28 <desp> ? :)
15:09:35 <lament> Tac-Work: correct, which is why it can't be used as a definition for sets.
15:09:39 <byorgey> desp: hang on, let me go look up which problem that is =)
15:09:44 <Toxaris> Tac-Work: and what type has (==) then? forall a . a -> a -> Bool?
15:09:44 <Tac-Work> lament: why not?
15:09:56 <lament> Tac-Work: because we do always want to be able whether something is in a set or not.
15:09:57 <hpaste>  dozer pasted "cabal woes" at http://hpaste.org/2267
15:10:01 <Cale> Another clever way to show that there's a bijection is to prove that whenever you have both a surjection and an injection, then there is a bijection.
15:10:01 <lament> *be able to tell
15:10:25 <lament> Tac-Work: this is the Russel's Paradox
15:10:30 <Cale> There's obviously an injection from the naturals to the rationals: f(n) = n/1
15:10:34 <byorgey> desp: hm, I guess 0 is not considered pentagonal
15:10:40 <byorgey> desp: although I'm not sure why not
15:10:45 <Tac-Work> I know what Russel's paradox is =-)
15:11:00 <desp> byorgey: oh, right. I am dropping 0 for this problem...
15:11:03 <lament> Tac-Work: then you should know better than to propose naive set theory in this day in age. Which is what you're doing.
15:11:08 <lament> *day and age
15:11:17 <lament> and i just can't type in this day and age
15:11:24 <desp> byorgey: just forgot to check for that as well
15:11:26 <monochrom> I explain Russell's paradox to exactly all those who don't explain Russell's paradox to themselves.
15:11:27 <Toxaris> lament: he proposes untyped type theory, I think :)
15:12:09 <Toxaris> monochrom is again watching a flame war because he is not watching a flame war, like yesterday
15:12:13 <lament> whichever it is, it's naive since it allows russel's paradox
15:12:16 <monochrom> hahaha
15:12:21 <Tac-Work> Naive Set theory is the best of all set theories
15:12:27 <Tac-Work> You can prove anything you want in Naive set theory
15:12:32 <desp> byorgey: what order the correct numbers are of?
15:12:39 <balodja> monochrom: do you explain it to yourself?
15:12:42 <Tac-Work> even the theorem that says "Naive Set theory is the best"
15:13:08 <lament> Tac-Work: ah, but you can disprove it just as easily
15:13:09 <monochrom> balodja: I'll have to compute for a while to answer that. Don't wait for me. :)
15:13:16 <litb> Cale: is aleph numbers something worth to read?
15:13:26 <Tac-Work> lament: Isn't flexibility what you really want in a Formal System? =-P
15:13:28 <Cale> To get a surjection, you can let f be the function such that if the prime factorisation of n is 2^m 3^k 5^l ... then n is sent to (-1)^m k/l
15:13:36 <lament> Tac-Work: no.
15:13:44 <byorgey> desp: the answer has 7 digits.
15:13:45 <data> Cale: isn't the definition of bijection that is is both injective and surjective?
15:13:56 <desp> ah.
15:14:13 <Cale> data: yes, but it's possible to show that if you can get both an injection and a surjection, then a bijection exists.
15:14:23 <Tac-Work> In the realm of computing, Russel's paradox doesn't really have an impact anyway
15:14:31 <Tac-Work> Regardless of Haskell's beautiful type system
15:14:36 <Tac-Work> your programs can still get stuck in loops
15:14:46 <lament> um.
15:14:48 <byorgey> Cale: hm, interesting, I wasn't aware of that.  how difficult is the proof?
15:14:57 <monochrom> "have an injection and have a surjective" means "have an injection f and a surjection g", f and g may be different.
15:15:58 <data> Cale: ah, that's what you meant
15:16:03 <Cale> byorgey: It's basically the same thing as the Schr√∂der-Bernstein theorem. You can probably google that :)
15:16:35 <conal> waern: hi
15:16:37 <Cale> If there are injections A -> B and B -> A then there is a bijection A -> B
15:16:41 <Cale> (and B -> A)
15:18:13 <byorgey> Cale: ok, thanks, I'll do that.
15:18:15 <waern> conal: hi, did you have a question for me?
15:18:33 <Cale> http://planetmath.org/?op=getobj&from=objects&id=3156
15:18:34 <lambdabot> Title: PlanetMath: Schroeder-Bernstein theorem, proof of
15:18:47 <Axioplase> Hi.
15:18:56 <sorear> hi.
15:18:59 <conal> waern: i'm trying to find a version of ghc that (a) works under windows and (b) supports haddock.ghc
15:19:03 <lament> i must have seen that theorem at some point, but forgot it completely :(
15:19:31 <Axioplase> Just wondering. Mon is a category, but is it a CCC ? (there's just one element, so the product and exponentiation requirements are bogus, aren't they ?)
15:19:31 <conal> waern: so i'm wondering who uses that combo, and how recent a ghc snapshot is needed for haddock.ghc.
15:19:38 <byorgey> Cale: yeah, looks fairly elementary, I'll read it later
15:20:11 <waern> conal: I think you just need one from July or later
15:20:20 <Cale> If you have a surjection f: A -> B, you can turn it into an injection g: B -> A by simply picking an element of { a : f(a) = b } for each b in B.
15:20:28 <Cale> (Axiom of Choice!)
15:21:13 <waern> conal: I don't think anyone is using both haddock.ghc and windows
15:21:13 <Tac-Work> I think someone needs to write a good layman's book on the Axiom of Choice
15:21:17 <Cale> litb: So, you're probably itching for an infinite set which you provably can't make a list of
15:21:34 <Cale> litb: Let's go with real numbers in the interval [0,1]
15:21:34 <lament> Tac-Work: any intro to analysis textbook? :)
15:21:41 <conal> waern: urk. okay.  thanks.
15:22:05 <Tac-Work> lament: I have a set theory book that explains it. It's not in my analysis book
15:22:05 <Cale> Also, if you can't list those, you sure can't list the whole set of real numbers
15:22:23 <Tac-Work> lament: I have a decent understanding of it, but I think it's cool enough to get its own book
15:22:23 <lament> Tac-Work: well, intro to set theory then (my intro to analysis included enough set theory)
15:22:31 <waern> conal: np. tell me if anything needs fixing
15:22:32 <Tac-Work> there are a million books on Goedel's incompleteness theorem
15:22:34 <Tac-Work> and none of AoC
15:22:49 <Cale> Every one of those real numbers has a decimal expansion which looks like 0 . d1 d2 d3 ... where the dk's are digits.
15:22:52 <Tac-Work> AoC says all sets are Well-ordered
15:22:56 <Tac-Work> there's always a least
15:23:14 <lament> Tac-Work: yeah, there's books on fractals, infinities, the golden ratio and not reading them is probably the best thing one can do for their math education...
15:23:16 <Tac-Work> so it's something like a very weak way to enumerate a set or something
15:23:18 <Cale> (and some have more than one possible expansion, but that's irrelevant)
15:23:39 <Cale> Suppose we could make a list of all the real numbers in the interval [0,1]
15:23:43 <monochrom> http://okmij.org/ftp/Computation/#Axiom-of-Choice
15:23:44 <lambdabot> Title: Programming and Computation
15:23:45 <Cale> It would look something like:
15:24:05 <monochrom> "Axiom of Choice as a black-box cursor-like Set API" by Oleg :)
15:24:15 <Cale> 0. d11 d12 d13 d14 ...
15:24:17 <desp> the pain
15:24:19 <Cale> 0. d21 d22 d23 d24 ...
15:24:22 <Cale> and so on
15:24:32 <Tac-Work> lament: It does help to get perspective on math. The formulas and language are often explained in texts with no explanation why a function is useful
15:24:33 <Cale> We can get a new number which isn't in the list.
15:24:35 <fasta> Can someone explain how doing :t in the different modules for the same function can give different results? I mean that monad transformer applications magically disappear and so on?
15:24:55 <Tac-Work> monochrom: that is an awesome explanation for AoC. I love it
15:24:56 <Cale> The kth digit of the new number will be 7 if dkk is not 7, and 3 otherwise.
15:25:00 <fasta> s/the/two
15:25:29 <Cale> That way, it's not equal to the first element of the list because the first digit doesn't match, nor the second because the second doesn't match, and so on.
15:25:51 <Cale> So we have to concede that there can't be such a list.
15:26:07 <Cale> litb: makes sense?
15:26:16 <lament> Tac-Work: ah, but these things (fractals, transfinites, the golden ratio, incompleteness theorems, the axiom of choice) aren't particularly "useful", they're mostly "cool-sounding". All such books do is confuse the laymen about the relative importance of different issues in mathematics.
15:26:20 <conal> waern: will do
15:26:49 <Tac-Work> lament: I always thought the golden ratio books looked really boring myself =-P but yeah
15:26:50 <litb> doh, i was reading wikipedia.
15:26:54 <Cale> lament: Since when was mathematics supposed to be useful?
15:27:05 <litb> now, i have to catch up what you 've written
15:27:09 <Cale> okay
15:27:10 <litb> just a few minutes :)
15:27:34 <lament> Cale: i dunno, ask Tac-Work
15:27:42 <Tac-Work> The one thing I don't get about AoC is that it can be used to enumerate (at least large parts) of uncountable sets
15:27:49 <Tac-Work> Math is supposed to be cool
15:28:09 <Tac-Work> if you're not doing it for a living
15:28:31 <Tac-Work> Functions and sets and relations and fixpoints and zeros
15:28:41 <lament> sure, the problem is with the layman books that leave the reader (in the past, often, me) with a confused half-understanding of the issue
15:28:52 <Cale> Tac-Work: it does something like that, but not quite the same :)
15:29:10 <Tac-Work> lament: I'll meet you half way: Thank god there's no "Godel for Dummies".... yet
15:29:18 <Tac-Work> anyway I must go dance now
15:29:25 <Tac-Work> bye all
15:29:25 <Cale> Tac-Work: It lets you have a strange order such that any subset has a least element
15:29:40 <Cale> But that isn't quite the same as enumerating them
15:29:49 <Tac-Work> Cale: Yeah, I'll have to look it over some more
15:29:53 <Cale> because even if you remove countably many, you might have a long way to go
15:29:56 <lament> there certainly are godel for dummies books, they're just not called that, but they exist.
15:30:23 <byorgey> does GEB count?
15:30:33 <Cale> GEB is good :)
15:30:44 * sorear liked it
15:30:45 <Cale> As a laymen's intro to mathematics.
15:30:50 <byorgey> dummies would never read GEB, but if they did they'd probably understand Goedel =)
15:30:54 <Cale> (and lots of other cool stuff!)
15:31:02 <Nafai> GEB was over my head :/
15:31:05 <lament> GEB is nice as a book about godel, not so much escher and bach.
15:31:11 <byorgey> yup, I read it like 3 times in high school =)
15:31:19 <lament> as a musician, the treatment bach gets is rather appaling
15:31:20 <Cale> It's a nice book about conciousness.
15:31:52 <lament> also, it's way too long :)
15:31:53 <fasta> sorear: do you know how the type of a function can depend on in what module you ask for it?
15:32:01 <lament> i stopped reading about a quarter or a third in
15:32:14 <Cale> I was annoyed that it was too short :)
15:32:26 <Cale> (well, not really)
15:32:34 <fasta> Does anyone?
15:32:41 <sorear> fasta: No, but the MR might be involved
15:32:49 <monochrom> I stopped reading the book too. I took Stephen Cook's "Computability and Logic" class properly instead.
15:33:00 <fasta> sorear: I have -fnomono<etc>
15:33:16 <Cale> It's not really the same as a proper course in logic of course :)
15:33:18 <dibblego> Cale, what does GEB stand for?
15:33:28 <Cale> G√∂del, Escher, Bach
15:33:32 <dibblego> oh of course
15:33:33 <dozer> oops - I think my irc client has been lying to me
15:33:37 <dibblego> I just realied that :)
15:33:39 <astrolabe> What do I need to do to get QuickCheck working on GHC?
15:33:51 <dibblego> I have that book at home
15:33:57 <Cale> litb: Let me know if that proof makes sense or if you'd like me to clarify it a bit :)
15:34:20 <dozer> did anyone see or comment on my pastebot post? it was about that time I stopped getting any stuff displayed
15:35:25 <lament> is there a book like GEB but ten times shorter and less condescending?
15:35:28 <Cale> http://hpaste.org/2267 -- just reposting it in case people have forgotten :)
15:35:44 <lament> that i could recommend to people interested in this stuff :)
15:36:06 <lament> i suppose it IS hard to write about math
15:36:11 <Cale> lament: It's only 'condescending' if you already know all the stuff. If you don't, it's a rather fun presentation.
15:36:23 <lament> Cale: possibly.
15:36:28 <byorgey> astrolabe: what platform are you on?
15:36:37 <Cale> I read it early on in highschool and it was quite fun.
15:36:56 <astrolabe> byorgey: Windows
15:37:00 <litb> Cale: i really don't get this sentence "The kth digit of the new number will be 7 if dkk is not 7, and 3 otherwise."
15:37:34 <Cale> litb: That is, if the kth digit of the kth number in the list is not 7, then the kth digit of our new number will be 7
15:37:41 <litb> you have a matrix. and in the diagonal, the 7. row, there is a 7, if not already a 7, otherwise a 3?!
15:37:42 <byorgey> astrolabe: hm, I'm not sure then... in my platform (Ubuntu) at least, I had to install a separate package with QuickCheck in it, dunno if it comes bundled on Windows or not.
15:37:48 <Cale> and if it is 7, we'll make the kth digit of our new number 3
15:37:56 <byorgey> astrolabe: but in any event you then of course just import Test.QuickCheck
15:38:17 <litb> Cale: ah, simple rule
15:38:25 <astrolabe> byorgey: Thanks
15:38:28 <lament> Cale: i think a really good book about math would first of all try to make the reader to appreciate math notation, and explain why math papers are written the way they are :)
15:38:55 <byorgey> astrolabe: you can also get it on hackage, I think
15:39:17 <litb> so, if we start with 0.00... , we have 0.7777777777777777777 as the first number?
15:39:25 <astrolabe> byorgey: It is supposedly included with ghc
15:39:25 <lament> Cale: and intersperse proof with more entertaining text without making it seem like "here, this ugly stuff is what mathematicians actually do, now back to our tortoises..."
15:39:40 <litb> then, we have 0.33333333333333333.. , after that we have 0.777777777777777... hmm, maybe i'm just to tired to follow
15:39:46 <Cale> litb: no no
15:39:48 <litb> i don't  get this o_O
15:39:55 <Cale> litb: We look at the kth digit of the kth number
15:39:57 <Cale> for each k
15:40:03 <lament> Cale: for that matter i'm yet to see a book that actually tried to make it clear WHY proofs are there in math books
15:40:07 <Cale> So the first digit of the first number
15:40:15 <fasta> sorear: is it possible that :t does some type defaulting?
15:40:15 <Cale> the second digit of the second, and so on
15:40:19 <litb> yeah
15:40:28 <litb> but we are just generating these numbers, or?
15:40:35 <Cale> We're only coming up with one new number which isn't in the list
15:40:36 <fasta> sorear: considering that :i does give the right type.
15:40:38 <litb> oh wait, we already have them generated, now we want to count them
15:40:52 <Cale> We already (supposedly) have a list of all of them
15:41:06 <Cale> and we're showing that the list cannot possibly be complete
15:41:19 <Cale> (which is a contradiction)
15:41:19 <sorear> fasta: well, :t reduces the context, which could depend on the instances in scope
15:41:37 <Cale> So they must not actually be listable
15:42:03 <fasta> sorear: in what way does it reduce the context?
15:42:05 <lament> one of the rare cases of a useful proof by contradiction :)
15:42:19 <litb> now i'm going to understand this, Cale
15:42:19 <Evir> http://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument
15:42:20 <sorear> fasta: normal context-reduction stuff
15:42:20 <lambdabot> Title: Cantor's diagonal argument - Wikipedia, the free encyclopedia
15:42:20 <Evir> ;-)
15:42:25 <Cale> I love proof by contradiction :)
15:43:18 <Cale> It was always the first thing I'd try in 1st year -- often there were better direct proofs which I'd miss :)
15:43:18 <fasta> sorear: is there any way it could transform a type t m into a type m?
15:43:23 <litb> Cale: say wehave this somewhere: 0.10000000... then we change this to 0.7000000... , right?
15:43:33 <Cale> You're not changing the list
15:43:49 <Cale> You're just looking at the diagonal digits in the list
15:43:53 <monochrom> immutability!
15:43:53 <Cale> and you're building a new number
15:44:14 <lament> this really should be explained with a picture.
15:44:26 <Evir> The wikipedia article I just pasted has one.
15:44:28 <lament> yeah.
15:44:41 <sorear> fasta: sure, if you have an instance of the form Moo m => Moo (t m)
15:44:42 <Cale> The kth digit of the new number is a 7 if the kth digit of the kth number in the list is not 7. Otherwise, it's a 3.
15:44:43 <monochrom> math builds in immutability. you can let x=5, then you can talk about x+2, but that is not changing x to 7.
15:45:09 <fasta> sorear: ok, I have such an instance, so that's where the problem comes from.
15:45:14 <litb> Cale: well, but then it is not a new number
15:45:23 <Cale> litb: The point of this is that the new number differs from every number in the list in at least one place.
15:45:30 <Evir> litb: It will differ in at least one digit from any number in the list.
15:45:36 <Evir> litb: So it's not in the list.
15:45:42 <litb> because if we just change the stuff in the fraction part of the number, then we always come to a number in between 0..1
15:45:45 <fasta> sorear: when there are overlapping instances for Moo m => Moo (t m), will it apply that rule too?
15:45:50 <fasta> sorear: I suspect it won't.
15:45:51 <litb> so, we never get a new number outside of 0..1
15:45:55 <lament> litb: right, so it should be in the list, right?
15:46:00 <litb> yes
15:46:13 <sorear> overlapping instances are a semantic nightmare...
15:46:15 <lament> litb: but then it can't be, because this new number is different from each number in the list in one digit
15:46:16 <Cale> litb: but it also shouldn't be in the list
15:46:16 <Evir> litb: It's not outside of 0..1, right. But this shows that your list of 0..1 is incomplete.
15:46:22 * sorear doesn't understand them one bit
15:46:26 <Cale> litb: Hence, we have a contradiction.
15:46:58 <Toxaris> I have a   foo :: MonadError SomeErrorType m => a -> m b   and at one callsite, I know that the computation will run without error. so I think I want a (partial) function   ignoreError :: forall e . (forall m . MonadError e m => m a) -> a   how can i express this?
15:46:59 <Cale> litb: Which means that whatever shaky assumption we had made on the way to getting here must be false.
15:47:17 <Cale> litb: In this case, it's the assumption that there is a list of all the numbers in [0,1]
15:47:19 <foones> Hello
15:47:31 <Cale> foones: hi
15:47:43 <foones> Does maximum work for any Ord a => a ?
15:47:49 <Cale> :t maximum
15:47:50 <foones> I mean, should it?
15:47:51 <lambdabot> forall a. (Ord a) => [a] -> a
15:47:54 <Cale> yes
15:47:58 <litb> Cale: but who says it is not in the list?
15:48:19 <Cale> litb: Well, if it's in the list, it's equal to one of the numbers, right?
15:48:28 <litb> yes
15:48:31 <Cale> litb: Suppose that it's equal to the kth number
15:48:42 <litb> alright
15:48:54 <foones> I defined < and == for a type
15:49:02 <foones> but maximum [...]  (with just one element)
15:49:15 <foones> gives an awful system error
15:49:32 <mauke> define "awful system error"
15:49:37 <Cale> litb: But it can't be, because if the kth digit of the kth number is not 7, then the kth digit of the new number is (and so they differ), and if it is 7, then the kth digit of our new number is 3 (so they differ)
15:49:49 <Toxaris> I'm thinking about instantiating m to be something simple (like Either SomeErrorType) and then pattern matching to get the value out. makes that sense? I'm a bit scared by the rank2 type :(
15:50:00 <foones> Sorry, with two elements
15:50:00 <Cale> litb: So it can't be equal to any one of them.
15:50:08 <monochrom> Toxaris: Oh, then that makes sense.
15:50:17 <Cale> litb: Even though it's supposed to be there.
15:50:21 <foones> Under windows
15:50:34 <foones> a message box with "Details..."
15:50:36 <mauke> oh wow
15:50:43 <mauke> that shouldn't happen, ever
15:50:46 <Cale> litb: So we come to the conclusion that the idea of putting all the real numbers in [0,1] into a list must be wrong.
15:50:52 <Toxaris> monochrom: "then"?
15:50:52 <monochrom> Incidentally, this rank-1 type cannot be implemented: forall e m. MonadError e m => m a -> a.
15:51:34 <monochrom> "then" is a word leaked from my internal computation.
15:51:42 <Cale> litb: Does that make sense?
15:52:20 <Cale> litb: (P implies Q and not Q) implies not P
15:52:44 <litb> litb: But it can't be, because if the kth digit of the kth number is not 7, then the kth digit of the new number is (and so they differ, and the new number is equal to another number in the list), and if it is 7, then the kth digit of our new number is 3 (so they differ, and the new number is equal to another number of the list)
15:52:52 <litb> that's what i see
15:53:11 <byorgey> a picture would probably help... =)
15:53:18 <Cale> litb: Remember I asked you
15:53:24 <Cale> litb: Which element of the list?
15:53:35 <Cale> and supposed that it was the kth number that it was equal to
15:53:43 <litb> the one which has a 3 as the kth digit
15:53:49 <Cale> but by that argument, it's not equal to the kth number
15:53:57 <Cale> (for any k)
15:54:29 <Cale> Remember that we're trying to come to the conclusion that this doesn't make sense :)
15:54:43 <litb> if we list them as you said above, the number is just 4 rows above
15:54:51 <litb> because we change it from 7 to 3
15:54:52 <Cale> how so?
15:55:02 <Cale> huh?
15:55:38 <gkr> Uhm, Cantor?
15:55:54 <Cale> litb: You're saying the new number is in the list somewhere, right?
15:56:14 <Cale> litb: That means that some natural number maps to it
15:56:15 <hpaste>  foones pasted "system error" at http://hpaste.org/2268
15:56:18 <lament> litb: the number you constructed differs from Nth number in the list AT LEAST in its Nth digit.
15:56:25 <lament> litb: because you explicitly changed the Nth digit.
15:56:38 <litb> if we change A=0.000070...  to B=0.000030.... , then that B is 4 rows above A in our list already, assuming the list you wrote  (0. d11 d12 d13 d14 .\n. 0. d21 d22 d23 d24 ..)
15:56:38 <foones> The same code fails in Hugs with a system error
15:56:46 <foones> and in ghc with stack overflow...
15:57:00 <lament> litb: looks like you missed the "diagonal" part
15:57:24 <lament> litb: you don't change any numbers. You create a new one
15:57:26 <gkr> You don't change the numbers in the table. You form a new number.
15:57:32 <litb> lament: of course it differs from the Nth number
15:57:34 <Toxaris> monochrom: ok thanks for the "sensible idea check". I'm aware that I need the rank2-type (that was you "then"?), i'm just scared that it's too complex. But i like it better then inlining the pattern match (wich would work without type annotation, I think), because I want to make clear that errors are ignored at this point
15:57:35 <litb> sure
15:57:36 <Cale> litb: Our new number looks something like 0.777333773773777777777377777737777...
15:58:18 <Cale> Where it has a 7 in its kth digit if the kth digit of the kth number in the list is *not* 7
15:58:24 <Cale> and it has a 3 otherwise
15:58:30 <litb> oh, wait, if it is not 7, we change it to 7
15:58:41 <Cale> We're not changing anything
15:59:02 <Toxaris> litb: not the kth digit of the one and the some number for all k, but the kth digit for the kth number
15:59:04 <Cale> We're looking at the diagonal of the list of numbers
15:59:08 <Cale> and writing down a new number
15:59:55 <monochrom> rank-2 is not scary, once you realize you do it all the time in OO. But oh, maybe even that is scary. :)
16:00:11 <Cale> and the new number isn't equal to the first number in the list because if the first number in the list has 7 as its first digit, our number has 3, and if the first number has anything else, our number has 7
16:00:59 <Cale> and the new number isn't equal to the second number in the list because if the second number in the list has 7 as its second digit, our number has 3, and if the second number has anything else, our number has 7 as its second digit
16:01:08 <Cale> and so on
16:01:13 * sorear thought OO was rank-0 with subtyping-because-we're-to-lazy-to-do-parametric-polymorphism
16:01:18 <litb> Cale: i see
16:01:35 <Cale> litb: So the number is both in and not in the list.
16:01:42 <litb> and you want to show that your constructed numbe ris nowhere between 0..1 in the list?
16:01:44 <Cale> litb: Which is a contradiction.
16:01:49 <litb> hmm
16:01:55 <monochrom> I spoke too soon. Rank-2 in OO is uncommon.
16:02:13 <lament> litb: it's clearly between 0 and 1, since it starts with 0.
16:02:26 <Cale> yep
16:02:26 <litb> ahhh, now i get it right
16:02:46 <Cale> So our assumption that there was a list of all the real numbers in the interval [0,1] must be false.
16:02:58 <litb> yes
16:03:07 <litb> and so it is not countable?
16:03:07 <Cale> and there you go :)
16:03:09 <Cale> right
16:03:19 <mauke> why can't we do this with the rationals?
16:03:27 <Cale> In some sense, it's a bigger infinity than the infinity of natural numbers
16:03:40 <Cale> mauke: because there's no guarantee that the number we construct is rational.
16:03:44 <sorear> mauke: Because you can't construct a rational from an arbitrary sequence of digits
16:04:00 <mauke> excellent
16:04:02 <Cale> (and because the rationals really are countable, of course :)
16:04:31 <mauke> yeah, it would be kinda worrying if that trick worked for rationals :-)
16:04:32 <litb> Cale: thanks for the proof =)
16:04:35 <Cale> litb: no problem
16:04:57 <litb> it's actually quite simple
16:05:05 <Cale> yeah :)
16:05:09 <litb> you can it do with binary logic too
16:05:11 <Cale> It turns out that if you have a set, it is never in bijection with its own powerset.
16:05:45 <Cale> Once you prove that, you then get the fact that there are infinitely many different kinds of infinity :)
16:05:55 <litb> if it is 0, change to 1, if it is 1, change to 0
16:06:02 <lament> Cale: sorry sorry... how many? :D
16:06:02 <Cale> litb: right
16:06:12 <litb> now, a 8byte bitfield is not countable?
16:06:13 <lament> litb: that's what the wikipedia page does.
16:06:15 <Evir> But no one can decide if there are "other infinities" between those power set infinities. ;-)
16:06:28 <Evir> You don't know if there's something between rationals and reals.
16:06:37 <Evir> Ant it's proven that it is not provable.
16:06:48 <Cale> lament: Well, that construction gives you just countably many.
16:07:02 <lament> litb: you mean 8-bit?
16:07:09 <lament> litb: that's 256 different numbers
16:07:27 <lament> litb: but the length of the diagonal is only 8
16:07:28 <litb> oh, yeah, 8 bit
16:07:34 <litb> but it should be uncountable
16:07:39 <lament> litb: so our "diagonal" number can't possibly cover all 256
16:07:44 <balodja> Evir: can you give some links about it?
16:08:08 <Cale> litb: it's only not equal to the first 8 of them
16:08:24 <litb> oh
16:08:33 <litb> i see now
16:08:38 <Cale> (the diagonal wasn't long enough)
16:08:39 <lament> which does prove that there's more than 8 8-bit numbers
16:08:48 <lament> which we knew anyway
16:08:51 <litb> lament: hehe
16:10:00 <Evir> balodja: This is known as "Continuum hypothesis"
16:10:17 <balodja> ok, thanks
16:10:19 <litb> Cale: ah, and if we would wanted to do that with all 256, then we cannot do that, because we don't have a quadrate
16:10:28 <EvilTerran> it's independent of the usual axioms of arithmetic, which is quite, er, interesting
16:10:34 <Evir> balodja: In fact, it is neither possible to proof it nor disproof it.
16:10:56 <EvilTerran> it's like the C in ZFC
16:10:59 <dozer> mm - if a function in the Maybe monad has called (fail "I'm not happy"), I presumably get back Nothing when this is invoked - how can I recover the message "I'm not happy" from this Nothing?
16:11:15 <Evir> EvilTerran: C for Axiom of Choice?
16:11:15 <qwr> you can't
16:11:21 <monochrom> can't
16:11:27 <EvilTerran> i don't think you can, dozer. use the Either monad instead?
16:11:29 <balodja> I've heard something about it. As I remember, that's one of Hilbert problems.
16:11:34 <EvilTerran> Evir, yes.
16:11:43 <Evir> Yeah.
16:12:01 * dozer has reached the point where hxt needs rewriting the
16:12:23 * EvilTerran seems to recall that ZFC and ZF¬¨C are both consistent
16:12:30 <monochrom> Yes.
16:12:41 <EvilTerran> as well as ZF don't-care-about-C
16:12:52 <EvilTerran> of course ;]
16:13:16 <sorear> ZFC¬¨C, however... :)
16:13:24 <dozer> hum - what's the point of fail then?
16:13:46 <EvilTerran> dozer, to let you switch monad without having to re-write your monadic code
16:13:54 <dozer> it smells like a convenient hack that got fossilised
16:13:56 <monochrom> Other monads preserve the string you give to fail.
16:14:00 <sorear> dozer: to annoy Cale
16:16:45 <EvilTerran> Just and Either are both "failure" monads, so if your code's written appropriately, other people could use whichever they liked. i guess that's kinda the point, and a fail with an occasionally-useless parameter is more generally useful than one with no such parameter
16:17:35 <dozer> sure - but this kind of implies that fail should be defined on failure monads
16:18:02 <EvilTerran> ...are you about to suggest MonadZero, perchance?
16:18:06 <samreid> dozer: you've got to do something when pattern matching goes bad...
16:18:23 <dolio> fail is there so that monadic pattern matching doesn't require MonadPlus.
16:18:35 <dolio> Which proably isn't a great reason, but there it is. :)
16:18:46 <samreid> > do { [x] <- Just [] ; return [x,x] }
16:18:48 <lambdabot>  Nothing
16:19:32 <mrd> ?users
16:19:32 <lambdabot> Maximum users seen in #haskell: 385, currently: 357 (92.7%), active: 24 (6.7%)
16:19:40 <mrd> 356
16:19:48 <Cale> It used to be that MonadPlus and MonadZero were separate
16:20:16 <Cale> and the potential for pattern match failure in a do block would create a MonadZero constraint
16:20:37 <EvilTerran> samreid, imo, pattern matching in a do{} should do the same thing as it does everywhere else. at the moment, that's non-compositional dramatic failure, but in the future it could be more useful
16:20:47 <EvilTerran> (see http://hackage.haskell.org/trac/haskell-prime/ticket/114 , etc)
16:20:48 <Cale> Which made a whole lot more sense than the way it is now, but that's H98 for you :)
16:20:50 <lambdabot> Title: #114 (introduce lambda-match (explicit match failure and fall-through)) - Haskel ...
16:21:39 <Tchakkazulu> @type foldl (flip (foldr ((const .) . flip id) id)) (error "Ack, error") . (:[])
16:21:41 <lambdabot> forall b. [b] -> b
16:22:54 <Cale> EvilTerran: well, it is in many monads
16:23:03 <mrd> > atomic (newTMVar 1)
16:23:04 <lambdabot>   Not in scope: `newTMVar'
16:23:14 <EvilTerran> it bugs me that it isn't in general, though
16:23:39 <EvilTerran> in part because it also means wide-scale lying to newbies about do{} desugaring
16:23:46 <Cale> I'd like to go back to the Haskell 1.4 translation of do-notation
16:24:03 <EvilTerran> what's that, then? the naive version?
16:24:11 <Cale> which we wouldn't have to lie about so much because it wouldn't be so embarrassing
16:24:12 <Cale> No
16:24:44 <Cale> The translation of do { p <- x ; <stmts> } depends on whether matching against p might fail.
16:25:00 <Cale> If it can't fail, you use the naive translation
16:25:02 <EvilTerran> (do { PAT <- EXP; ... } = EXP >>= \PAT -> ...; rather than EXP >>= \fresh -> case fresh of PAT -> ...; _ -> fail "...")
16:25:07 <Cale> If it can fail, you use mzero
16:25:22 <EvilTerran> and bring back MonadZero! i approve!
16:25:40 <Cale> yes
16:25:43 <Tchakkazulu> And monad comprehensions while at it?
16:25:46 <dolio> You could even put fail in MonadZero if you want to give access to a string.
16:25:47 <Cale> It was right in Haskell 1.4
16:25:50 <mrd> EvilTerran Approved (tm)
16:25:59 <Cale> Just put it back to the way it was! :)
16:26:13 <EvilTerran> i'd rather make comprehensions more listy than more monady, TBH.
16:26:43 <Cale> I rather like monad comprehensions as a way to help teaching about monads
16:26:49 <EvilTerran> things like [ f x, g x | x <- xs ] = concatMap (\x -> [f x, g x]) xs
16:26:57 <Cale> But you really need good defaults
16:27:11 <Tchakkazulu> I like list comprehensions if I need to explain how the list monad works, so you've got a point there.
16:27:13 <Cale> EvilTerran: That could be supported in MonadPlus
16:27:13 <shapr> Yow, I'm reading about the programming language research done at my local university.."It utilizes The aspect-oriented semantic implementation built on top of an object-oriented syntax tree clearly encapsulates each phase of semantic analysis as an aspect. It supersedes the object-oriented Visitor pattern by unrestricted method definitions and transparent nature of node classes, as well as the flexibility in tree walking and phase
16:27:13 <shapr> composition using join points."
16:27:14 <EvilTerran> which'd be difficult to express in general monads
16:27:18 * qwr thinks not having monad comprehensions is illogical
16:27:27 <EvilTerran> yeah, monadplus would work, actually. that sounds like a good idea...
16:27:30 <EvilTerran> @yow
16:27:31 <lambdabot> I don't believe there really IS a GAS SHORTAGE.. I think it's all just
16:27:31 <lambdabot> a BIG HOAX on the part of the plastic sign salesmen -- to sell more numbers!!
16:27:52 <shapr> Speaking of big hoaxes, these guys say they've written the first compositional parser algorithm.
16:28:04 <Tchakkazulu> O_o
16:28:14 <shapr> "CLR is the first algorithm that offers syntax composition at the parser level. It decreases the complexity of building a large language by constructing a set of smaller language parsers from grammar components."
16:28:26 <EvilTerran> ... is it just me, or does that paragraph make absolutely no sense? it seems lacking in grammar, never mind meaning.
16:28:27 <shapr> I wonder if I should email them and tell them about Parsec.
16:28:29 <Tchakkazulu> We've written a compositional parser at the "grammars and parsing" class...
16:28:35 <Tchakkazulu> And Parsec, true :)
16:28:45 <mrd> or the millions of combinator parsers
16:28:57 <dolio> EvilTerran: Maybe you need to learn more buzzwords. :)
16:29:07 <Tchakkazulu> All of them almost-but-not-quite the same :)
16:29:18 <shapr> Scary thing is that this is some guy's PhD thesis.
16:29:34 <dozer> so if I'm going to fix hxt to actually give some feedback about why it couldn't parse a file, should I replace Maybe with Control.Monad.Error?
16:29:59 <mrd> er, that's not how you get errors out of hxt
16:30:12 <EvilTerran> dolio, from "it utilizes" to "as an aspect" refuses to parse for me. it looks like a mash of at least two sentences
16:30:17 <dozer> it is in the xpickle stuff mrd
16:30:17 <mauke> isn't there a parser combinator library in boost?
16:30:22 <sorear> shapr: well, parsec has knot problems - if you just <|> expressions-with-plus and expressions-with-minus, you get expressions-with-plus-OR-minus
16:30:36 <sorear> shapr: does CLR give you expressions-with-plus-and-minus?
16:30:43 <shapr> Heck if I know.
16:30:49 <shapr> I don't understand what you're saying.
16:30:54 <shapr> Oh, I think I do see.
16:31:00 <dolio> EvilTerran: Yeah, reading closer, something seems to be left out there.
16:31:01 <shapr> Wouldn't a PEG parser fix that?
16:31:06 <Tchakkazulu> It goes wrong between "object-oriented syntax tree" and "clearly encapsulates"
16:31:39 <dozer> aspects, by design, don't encapsulate ;)
16:31:43 <sorear> shapr: I doubt it, it's the concept of "set of strings" that causes the problem
16:31:48 <shapr> sorear: Explain?
16:32:15 <qwr> EvilTerran: it probably means they've written it in AspectJ ;)
16:32:20 <EvilTerran> dolio, actually, after repeated backtracking on the part of my mental parser, it appears grammatically correct if you drop off "it utilizes"
16:32:39 <shapr> qwr: It's definitely aspects done in Java, so AspectJ sounds likely.
16:32:50 <sorear> shapr: exp-with-minus gives 1, 1-1, 1-1-1, 1-1-1-1, exp-with-plus gives 1, 1+1, 1+1+1, 1+1+1+1, combining them in a set-of-strings combinator parser gives you 1, 1+1, 1-1, 1+1+1, 1-1-1, 1+1+1+1, 1-1-1-1, etc
16:32:58 * EvilTerran is highly suspicious of OO, and, by extension, anything built on it.
16:33:28 <sorear> shapr: I'd like 1+1-1, but with the semantics of CFG union, that means at least one of the parsers has to generate the whole thing
16:33:30 <Cale> It's funny how you can get as far as 'clearly' in that sentence before it just stops making sense
16:33:40 <dolio> I think aspect oriented programming is even more suspicious, but maybe that's because I never looked into it much.
16:33:51 <Cale> and suddenly you're trying to sort out exactly what went wrong :)
16:33:53 <olliej> EvilTerran: OO is fine
16:34:16 <mrd> yes, OO is a fine buzzword
16:34:16 <olliej> EvilTerran: It becomes better of course if you remove null and downcasting of course :D
16:34:17 <EvilTerran> from learning haskell, i've come to like my language features to have a solid logical backing ;]
16:34:31 <olliej> EvilTerran: OO *does*
16:34:53 <lament> hahaha, just noticed
16:34:54 <lament> "I predict that in ten years many in the Haskell community will be where many in the Lisp and Smalltalk communities (of which I am a fellow traveller) are now: bitter, disenchanted, whiners."
16:34:56 <olliej> EvilTerran: The classic class oriented type system is not illogical
16:34:58 <olliej> ...
16:34:58 <lament> so beautiful
16:35:00 <olliej> EvilTerran: well
16:35:04 <sorear> I'm not crazy about these EVERYTHING IS AN OBJECT, DENY THIS AND DIE languages
16:35:05 <lament> and so true
16:35:06 <olliej> EvilTerran: if we ignore C++ :D
16:35:12 <EvilTerran> define "OO", eh? :P
16:35:33 <lament> sorear: you don't have to be crazy about them, but it's a valid way for a type system to work :)
16:35:34 <sorear> some things are objects, if we had objects here a lot of (especially IO-heavy) code would be clearer
16:35:42 <sorear> but a lot of things really aren't
16:35:43 <olliej> sorear: well.. in haskell everything is boxed...
16:35:45 <EvilTerran> do you include multiple inheritance? mixins?
16:35:49 <sorear> 3.+(2) just doesn't make sense
16:35:58 <Tchakkazulu> I quite liked the ray-tracer we had to write. It "just worked" by specifying the relations between an "Object", "Ray", "Camera" and "Screen".
16:36:00 <olliej> sorear: which is not entirely different from everything being an object
16:36:02 <lament> sorear: that's not "objects"
16:36:05 <lament> sorear: that's "single dispatch"
16:36:16 <EvilTerran> ew, single dispatch
16:36:24 <sorear> lament: Single dispatch has nothing to do with this.
16:36:31 <EvilTerran> and no need to mention the visitor pattern, guys.
16:36:34 <sorear> lament: Pretend I only have one type of number please.
16:36:35 <dolio> lament: It wouldn't surprise me if a fair amount of the current "Haskell community" isn't using Haskell in 10 years (although, maybe 10 isn't that many).
16:36:54 <shapr> sorear: One of the parsers has to generate the whole thing?
16:36:56 <mrd> perhaps Haskell' will appear by then
16:36:56 <lament> sorear: the distinction between "receiver" and "arguments" is a single-dispatch thing
16:37:00 <EvilTerran> GOF-style "patterns" are just using the human mind as a glorified macro preprocessor
16:37:04 <mrd> and maybe GHC will implement half of it
16:37:06 <Toxaris> at my uni, people do stuff like "On the relation of aspects and monads. The relation between aspects and monads is a recurring topic in discussions in the programming language community, [...] Our results are mostly negative: monads are not capable of quantifying over points in the program execution in a declarative way, whereas aspects are not very useful in abstracting over computational capabilities." http://www.st.informati
16:37:06 <Toxaris> k.tu-darmstadt.de/database/publications/data/aspects_and_monads.pdf?id=176
16:37:09 <shapr> sorear: I still don't get it.
16:37:10 <Itkovian> dolio: I think that depends on how the language evolves
16:37:11 <sorear> lament: the distinction is *not* what I'm complaining about
16:37:24 <lament> sorear: oh, sorry, then what is it?
16:37:38 <lament> sorear: i assumed you were complaining that 3 is being asked to add 2 to itself, which is a little weird
16:38:06 <sorear> lament: Exactly.  That command would make sense if it modified 3.
16:38:11 <mauke> it's +.(3, 2)
16:38:12 <EvilTerran> Toxaris, could you repaste that link at the start of a line? it got chopped in half, and asking for a repaste strikes me as less work than patching it up myself
16:38:16 <EvilTerran> ;]
16:38:21 <mauke> + is asked to do stuff with the message (3, 2)
16:38:31 <Itkovian> EvilTerran: it is, if you type less when asking
16:38:35 <Toxaris> EvilTerran: you should learn copy-paste then :)
16:38:39 <dolio> Itkovian: Well, I expect it to not get dependent types. If it does, I could be wrong.
16:38:40 <Toxaris> http://www.st.informatik.tu-darmstadt.de/database/publications/data/aspects_and_monads.pdf?id=176
16:38:44 <lambdabot> http://tinyurl.com/276an6
16:38:47 <lament> sorear: that's because it doesn't make sense for 3 to be the receiver and for 2 to be hte argument
16:38:48 <sorear> mauke: But now + has intimate knowledge of numbers!
16:38:50 <shapr> sorear: expression with plus or expression with minus seems right to me?
16:38:53 <Toxaris> be aware that it's a pdf
16:38:58 <mauke> sorear: duh
16:39:09 <lament> sorear: but with multiple dispatch, you don't need that
16:39:13 <EvilTerran> Itkovian, i'm a keyboard-heavy user, currently in windows. typing a few lines of text is probably less work than faffing around sorting it out
16:39:18 <mauke> functions in general need to know how to do what they do
16:39:19 <EvilTerran> thanks, Toxaris
16:39:26 <sorear> mauke: Shame on you.  The only thing that can have intimate knowledge of numbers is methods on numbers.
16:39:38 <mauke> + is a method on numbers
16:39:40 <Cale> Itkovian: how are those monad tutorials going?
16:39:59 <mauke> but methods are also objects
16:40:08 * mrd ponders intimate knowledge of numbers.
16:40:16 <Itkovian> Cale read the first one. I understand what you're saying though I doubt I could use it when not peeking at examples
16:40:33 <Itkovian> Seems like some border my mind fails to cross
16:40:37 <Itkovian> sucks
16:40:38 <samreid> if you want + to be balanced between the receiver and argument, calculate 2.+(3) and 3.+(2) and average them.
16:40:42 <Itkovian> I really want to grok it
16:40:43 <olliej> sorear: as a question are you aware of any decent benchmarks coomparing functional languages to imperative ones? /me is interested in whether a strict functional language is faster than equivalent imperative code
16:40:48 <qwr> objects are weird functions ;)
16:40:55 <Cale> Yeah, learning to use it without peeking at examples typically involves using it while peeking at examples for a while :)
16:41:04 <shapr> sorear: I asked scholar.google.com about the knot problem in parsers, it returns nothing.
16:41:04 <Toxaris> only 2 and 3 together know how they are added
16:41:04 <lament> sorear: seriously, having methods like number.add is not a requirement for OO languages
16:41:08 <mauke> samreid: no, return both results non-deterministically
16:41:16 <Cale> Itkovian: Do you have any particular questions?
16:41:17 <sorear> olliej: http://citeseer.ist.psu.edu/pippenger96pure.html
16:41:18 <lambdabot> Title: Pure versus Impure Lisp - Pippenger (ResearchIndex)
16:41:21 <lament> sorear: nobody stops you from having add(num, num) in a oo language
16:41:24 <Cale> (which one was it that you read?)
16:41:28 <Toxaris> so multi dispatch is the only sensible solution
16:41:40 <shapr> olliej: Or there's the shootout.
16:41:42 <sorear> olliej: strict pure code is slower.  this is not a benchmark result, this is a formally proven mathematical fact.
16:41:53 <samreid> mauke: :D
16:41:53 <Itkovian> Cale: problem is, currently I'm too busy writing script files in Python and I don't have any other piece of code that needs finishing that could help me
16:42:07 <Cale> Itkovian: Have you done any IO in haskell before?
16:42:12 <shapr> sorear: I still don't get it.
16:42:21 <olliej> sorear: really?
16:42:29 <sorear> shapr: Knots are FP jargon, I doubt you'll get results looking through parser literature
16:42:36 <shapr> Ok, what can I look for?
16:42:38 <Itkovian> Cale: well, reading some data, yes. Nothing fancy though.
16:42:38 <sorear> shapr: think "TyingTheKnot"
16:42:41 <olliej> sorear: i would have though removing the overhead of the thunks would improve the result
16:42:50 * shapr thinks... nothing happens.
16:42:59 <lament> anyway, going home
16:43:00 <olliej> sorear: i'm looking at real world vs. theoretical perf difference
16:43:04 <mrd> olliej: the thunks memoize
16:43:17 <Cale> Itkovian: So you get the difference between an IO action and the value it computes already
16:43:18 <mrd> what you're talking about is just a constant factor
16:43:18 <sorear> mrd: there are no thunks, he specified strict
16:43:20 <olliej> mrd: yes, but the thunks are still there
16:43:28 <mrd> sorear: he's implying vs a lazy language
16:43:30 <olliej> mrd: for a single computation they add cost
16:43:39 <sorear> mrd: me is interested in whether a strict functional language is faster than  equivalent imperative code
16:43:46 <olliej> sorear: strict functional vs. non-strict functional
16:44:04 <mrd> olliej: are you familiar with complexity theory, btw?
16:44:04 <Itkovian> Cale: enough to read simple file data, yes
16:44:16 <olliej> sorear: however i'm guessing making an infinite list takes longer in a strict language than non-strict one :D
16:44:18 <sorear> olliej: sorry I meant "strict pure code is slower *than imperative code*"
16:44:37 <sorear> olliej: you asked about strict vs. imperative, I answered badly
16:44:55 <joelr1> good evening!
16:44:57 <olliej> mrd: in the sense that you can have two O(n) algorithms one can still be slower than the other :D
16:45:13 <joelr1> what's the machine that has all the darcs repos under haskell.org?
16:45:25 <olliej> sorear: i was actually interested in strict-fl vs. nonstrict-fl vs. strict-imperative
16:45:33 <SamB_XP> joelr1: you mean darcs.haskell.org?
16:45:45 <mrd> olliej: well the result was much more interesting than that.  it spoke about an asymptotic difference.
16:45:46 <joelr1> SamB_XP: i thought so, thanks
16:46:02 <qwr> whats the difference between non-pure strict and imperative?
16:46:11 <Cale> Itkovian: okay, well, (as you might read in my monads as computation article), one way of looking at the general case is sort of like that -- you have computations which run to produce a value, and ways to chain them together
16:46:14 <mrd> a logarithmic factor i believe
16:46:17 <sorear> qwr: two names for the same thing
16:46:19 <joelr1> SamB_XP: do you by chance remember what directories the repos are under?
16:46:22 <SamB_XP> qwr: point of view?
16:46:33 <Cale> Itkovian: It's just that in general you have other meanings of the word "computation"
16:46:45 <qwr> SamB_XP: yes, i can't anything more...
16:46:58 <sorear> shapr: Suppose you want to parse arithmetic expressions.
16:47:07 <SamB_XP> joelr1: why?
16:47:12 <shapr> sorear: ok
16:47:19 <sorear> shapr: You write two separate parsers.  One parses expressions with +, one parses expressions with -.
16:47:22 <joelr1> SamB_XP: would like to create a project
16:47:28 <sorear> shapr: You combine them with <|>.
16:47:32 <Itkovian> Cale: well, yeah, I think that might be part of the problem :-/
16:47:33 * joelr1 wants to write an Erlang VM in Haskell
16:48:06 <shapr> sorear: ok..
16:48:07 <sm> good day all
16:48:08 <SamB_XP> joelr1: you should probably put it in the webspace for your account?
16:48:10 <Itkovian> I'll get there, eventually
16:48:10 <shapr> greetz sm
16:48:13 <sorear> shapr: But you don't get a full parser for arithmetic expressions!  Suppose you could parse (1 + 1) - 1
16:48:17 <Cale> Itkovian: So getting a good sense for what the word 'computation' might mean there just takes lots of examples
16:48:17 <joelr1> shapr: do you know where the repos are on darcs.haskell.org?
16:48:24 <sorear> shapr: There are two possibilities.
16:48:28 <joelr1> SamB_XP: i'm not sure
16:48:32 <fasta> joelr1: why do you want that?
16:48:39 <shapr> joelr1: darcs.haskell.org ?
16:48:39 <Cale> Itkovian: What background do you have? Have you read/watched SICP
16:48:41 <Cale> ?
16:48:51 <sorear> shapr: Either this string was generated by the --parser, CONTRADICTION, --parser doesn't accept anything with a +.
16:49:04 <sorear> shapr: Or this string was generated by the +-parser, CONTRADICTION, +-parser doesn't accept anything with a -.
16:49:04 <fasta> joelr1: is there anything wrong with the Erlang VM?
16:49:19 <Cale> Basically, functional programmers have been writing for a long time these things which we call combinator libraries.
16:49:21 <sm> back to haskell for some prototyping, and I have a simple question.. what functions would help me split a text file into segments beginning with the regexp '^* ' ?
16:49:22 <Itkovian> Cale: I've got a masters degree in CS
16:49:22 <joelr1> fasta: it's a long explanation. i'll start a thread on haskell-cafe. basically... to tailor it for numerics
16:49:29 <sorear> shapr: Therefore, that string could not have been accepted by our "complete arithmetic parser" after all.
16:49:40 <joelr1> shapr: yes, darcs.haskell.org
16:49:45 <Itkovian> Cale: SICP?
16:49:48 <sm> I find Data.List very powerful and yet strangely limiting
16:49:55 <sm> (as yet)
16:49:56 <shapr> joelr1: Um, you mean, once you login, or what?
16:49:57 <samreid> sm: lines and groupBy might do it.
16:50:00 <Cale> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
16:50:01 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
16:50:04 <shapr> sorear: You left out some pieces.
16:50:06 <joelr1> shapr: yes, once i login
16:50:12 <Cale> (there's a text to go along with it)
16:50:14 <joelr1> shapr: where do i create a repo once i login?
16:50:19 <Cale> It's pretty popular :)
16:50:25 <shapr> joelr1: No idea.
16:50:34 <shapr> I should really find out, I think I'm an admin :-/
16:50:36 <EvilTerran> sorear, sounds like you're expecting your parser combinators to do magic for you
16:50:38 <joelr1> fasta: also, to learn more about the erlang vm
16:50:45 <sm> samreid: only the first line of a segment begins with *  (this is an emacs org-mode outline, if that helps at all)
16:50:58 <Cale> Itkovian: Have you run into many combinator libraries or embedded domain specific languages?
16:51:05 <fasta> joelr1: do you intend this replacement VM to be used by people?
16:51:09 <sorear> EvilTerran: Shapr's CLR parsers apparently CAN do magic, at least if they weren't lying about the compositionality bit.
16:51:17 <joelr1> fasta: yes, of course
16:51:23 <joelr1> shapr: /srv/darcs
16:51:25 <sorear> EvilTerran: I'm proving to him that parsec isn't what I would call compositional
16:51:48 <joelr1> fasta: why do you ask?
16:51:48 <sorear> EvilTerran: Which I suppose is the whole problem.  We need standardized definitions for these things.
16:51:49 <SamB_XP> joelr1: figure out where to put things that you want served from darcs.haskell.org/~joelr (or whatever your username is)
16:52:07 <EvilTerran> it just seems to me that being able to take a (+)parser and a (-)parser and "overlay" them to get a (+-)parser as you described is impossible in the general case
16:52:15 <fasta> joelr1: It seems that we have enough VMs already.
16:52:22 <joelr1> SamB_XP: why? everything is served from http://darcs.haskell.org. i figured it out anyway , thanks.
16:52:23 <lambdabot> Title: Index of /
16:52:27 <joelr1> fasta: just one erlang vm
16:52:38 <EvilTerran> it seems to me that it's an infinite problem space that can't be dealt with inductively
16:52:44 <samreid> sm: how about lines and span?
16:52:44 <shapr> sorear: Um, wouldn't it try the plus parser and the minus parser by turn?
16:53:16 <sorear> shapr: Yes, but neither would succeed.
16:53:17 <EvilTerran> unless you have an operator to the effect of "nest these inside each other alternatively"
16:53:22 <fasta> joelr1: do you want to sell the VM?
16:53:24 <SamB_XP> joelr1: don't blame me if you get in trouble!
16:53:33 <joelr1> fasta: no
16:53:33 <sm> lines and span, hmm.. I'll look into that
16:53:44 <shapr> I thought the parsers were nested inside each other?
16:53:47 <ddarius> sm: There is a regex library as well.
16:53:50 <joelr1> fasta: i'm thinking fame, not profit
16:54:12 <shapr> Oh, I think I finally see.
16:54:29 <Itkovian> Cale: hmm, download speed is absymal atm
16:54:40 <shapr> You're saying that <|> switch permanently to one parser or the other?
16:54:41 <Cale> Itkovian: that's all right
16:54:54 * shapr should really eat something...
16:54:58 <Cale> Itkovian: It's really just a few particular ideas you might have picked up from there
16:55:05 <sm> splitRegex looks like just the thing. thanks!
16:55:07 * EvilTerran is thinking of something like having your (+) and (-)parsers parameterised on what goes inside them
16:55:12 <Cale> Itkovian: In particular, what combinator libraries are about
16:55:26 <Cale> (similar to embedded domain specific languages)
16:55:35 <sm> hopefully Data.List will continue to infiltrate my brain
16:55:39 <Itkovian> all right
16:55:48 <EvilTerran> so you could say "a (+)parse full of (-)parses, each full of Int-parses", for instance
16:55:48 <Toxaris> EvilTerran: you want the parses be defined in fix-able style
16:55:52 <sorear> > let { plusParser = Text.ParserCombinators.Parsec.char '1' `Text.ParserCombinators.Parsec.chainl1` Text.ParserCombinators.Parsec.char '+' ; minusParser = Text.ParserCombinators.Parsec.char '1' `Text.ParserCombinators.Parsec.chainl1` Text.ParserCombinators.Parsec.char '-'; whole = plusParser Text.ParserCombinators.Parsec.<|> minusParser } in Text.ParserCombinators.Parsec.parse whole "" "1+1-1"
16:55:53 <lambdabot>   Not in scope: `Text.ParserCombinators.Parsec.parse'
16:56:00 <EvilTerran> fix-able?
16:56:03 <sorear> argh!
16:56:04 <Cale> Itkovian: As far as programming is concerned, a monad is really just a special kind of combinator library.
16:56:08 <mrd> !
16:56:19 <Cale> (or EDSL)
16:56:29 <sorear> can we please have SML's open in the next version of haskell btw?
16:56:32 <Cale> One which supports a specific means of combination
16:56:34 <Toxaris> EvilTerran: so that (fix plus) gives the +-pluser, (fix minus) the --parser
16:56:35 <joelr1> is haskell suitable for writing a high-performance virtual machine?
16:56:39 <ddarius> EvilTerran: Abstract out the recursive call.
16:56:42 <Cale> (namely bind)
16:56:48 <samreid> sm: or maybe break instead of span... but they're the same thing...
16:56:50 <shapr> sorear: But that would be a silly way to write a parser.
16:57:01 <SamB_XP> joelr1: doubtful
16:57:16 <SamB_XP> or at least, it's doubtful if any implementation is up to it
16:57:24 <shapr> sorear: But I'm beginning to understand now.
16:57:26 <Cale> and has at least a specific set of simple primitive computations, one for each Haskell value, that simply "result in that value with no side effect" (that's return)
16:57:35 <Excedrin> weren't some of the Haskell sandmark scores reasonably good?
16:57:50 <joelr1> SamB_XP: maybe as a research vehicle? to see what needs to be speeded up?
16:57:59 <ddarius> joelr1: The easiest thing would probably be to have Haskell generate the code to a VM.
16:58:02 <SamB_XP> joelr1: quite
16:58:04 <Toxaris> EvilTerran: and (fix (\x -> minus x <|> plus x)) would return the +--parser
16:58:11 <joelr1> SamB_XP: i thought ocaml first but haskell has a couple of things in its favor
16:58:22 <SamB_XP> joelr1: last I checked, though, bitshifting had issues
16:58:23 <Toxaris> EvilTerran: or something like that
16:58:24 <Excedrin> yes, but sandmark
16:58:28 <shapr> joelr1: If you decide to write a VM with Haskell, use GADTs!
16:58:38 <SamB_XP> so as long as you don't need to do that I guess you'll be okay ;-)
16:58:39 <shapr> That should be fun :-)
16:58:43 <joelr1> SamB_XP: ocaml does not have SMP and haskell has laziness which may come in handy
16:58:45 <EvilTerran> Toxaris, seems perfectly possible to me, altho your use of "fix" confuses me slightly
16:58:46 <sjanssen> Excedrin: dons has a benchmark page somewhere
16:58:54 <joelr1> shapr: why GADT?
16:59:04 <sjanssen> OCaml doesn't do SMP?
16:59:09 <shapr> sjanssen: Nope, never has.
16:59:09 <joelr1> sjanssen: no
16:59:11 <Excedrin> sjanssen: that should basically answer joelr1's question, yes?
16:59:16 <ddarius> joelr1: You usually don't want to utilize laziness in a VM inner loop...
16:59:22 <fasta> joelr1: I don't think Haskell has any inherent slow things.
16:59:30 <shapr> That's one reason I proposed a "how well does this program scale to multiple CPUs" benchmark for the Shootout :-)
16:59:53 <fasta> joelr1: you could make the VM be JIT with e.g. Harpy.
16:59:54 <ddarius> Maybe come yhc and/or jhc we will see a big jump in the way Haskell code performs on certain things.
17:00:03 <sjanssen> joelr1, Excedrin: http://www.cse.unsw.edu.au/~dons/um.html
17:00:04 <lambdabot> Title: Haskell UM
17:00:06 <shapr> The instant response was "There aren't any languages that can do that!" from an OCaml proponent.
17:00:14 <Toxaris> EvilTerran: why?
17:00:15 <fasta> joelr1: you can make it as fast as you want, AFAIK.
17:00:23 <shapr> joelr1: GADTs will do good things for your VM.
17:00:24 <joelr1> ddarius: right, not in the inner loop but if the vm is written in CPS then it's building up of closures and some of them may never be evaluated
17:00:37 <shapr> joelr1: Check out the paper on GADTs, I think you'll understand it quickly.
17:00:49 * sorear does't imagine harpy could possibly make a program faster
17:00:58 <sorear> +real
17:00:58 <joelr1> fasta: harpy is the native code generator ,right?
17:00:59 <Excedrin> hahaha 69.7 times faster than the base C one?
17:01:09 <fasta> joelr1: yes
17:01:16 <joelr1> shapr: which one/
17:01:31 <Excedrin> oh, I read it backwards! 69.7 times slower!
17:01:33 <samreid> sm:
17:01:52 <Excedrin> so, the best Haskell is 4x slower than the fastest C
17:02:00 <EvilTerran> Toxaris, well, if you fixed a function Parser -> Parser that accepted its parameter, a +, then its parameter again, that'd give you a parser that only accepted infinite productions
17:02:14 <samreid> > let f = groupBy (\x y -> not ("* " `isPrefixOf` y)) . lines in f "* abc\n** def\n\n* ghi\naoehutoe\naoeuh\nfoobar\n* jklmn\nothetuho"
17:02:15 <lambdabot>  [["* abc","** def",""],["* ghi","aoehutoe","aoeuh","foobar"],["* jklmn","oth...
17:02:33 <joelr1> Excedrin: that's not encouraging. dons is light-years better than i am and his vm is 4 times slower than C
17:02:47 <Excedrin> yep, I think that's directly applicable to your question
17:02:47 <shapr> joelr1: Look at the added types for the evaluator here - http://www.haskell.org/haskellwiki/GADT
17:02:48 <lambdabot> Title: Generalised algebraic datatype - HaskellWiki
17:03:13 <joelr1> shapr: which part of that page?
17:03:25 <shapr> The motivating example.
17:03:27 <joelr1> shapr: ah, i think i see. the eval part
17:03:33 * sorear doesn't like talk of performance in #haskell
17:03:34 <sm> samreid: thx
17:03:36 <SamB_XP> joelr1: I bet it was the bitshifts and the indirect implementation of array numbers...
17:03:36 <EvilTerran> unless you're thinking your (+)parser accepted one-or-more terms separated by (+)s. but even then it seems to me you'd get deep recursion
17:03:41 <Excedrin> sorear: why not?
17:03:47 <SamB_XP> or maybe just the latter
17:03:53 <sorear> if you want fast unmaintainable code, you know where to get it
17:03:57 <sjanssen> joelr1: you're not going to beat a VM in C with Haskell
17:04:02 <SamB_XP> anyway, the latter won't plague an erlang VM
17:04:09 <EvilTerran> Toxaris, did you maybe mean mathParser = fix $ plusParser <|> minusParser <|> numberParser?
17:04:14 <ddarius> joelr1: Things have gotten somewhat better performance wise since GHC 6.5 and will be better in the next GHC.
17:04:17 <sm> does Text.Regex support look-ahead ?
17:04:18 <Excedrin> sorear: where do you go for fast maintainable code?
17:04:19 <sjanssen> joelr1: you will, however, finish the coding more quickly and have more confidence in the correctness
17:04:27 <EvilTerran> s/numberParser/const numberParser/
17:04:33 <Toxaris> EvilTerran: I do not know what the (+)-parser is supposed to accept, since i didn't followed the discussion from the start :)
17:04:40 * shapr agrees strongly with sjanssen 
17:05:03 <joelr1> sjanssen: right. this could be important. somehow... somewhere. ultimately, my goal is to do it right first and foremost and to learn about the erlang innards
17:05:13 <joelr1> sjanssen: i can always re-implement it in ocaml later on :D
17:05:15 <sorear> Excedrin: There's no such thing.
17:05:19 <EvilTerran> it just seems to me that if you've got a fn /<x>/ -> /<x> + <x>/, then fix'ing it would cause infinite recursion
17:05:23 <ddarius> dons should recompile those with GHC HEAD and see how things change.
17:05:33 <fasta> What happened to the argument of functional languages being better to optimize?
17:05:34 <joelr1> how's HEM for a name? Haskell Erlang Machine
17:05:34 <sjanssen> joelr1: hmm?  I haven't been following, you're writing an Erlang VM?
17:05:36 <shapr> joelr1: Or tune the inner loop of the Haskell program with a C binding, or whatever.
17:05:38 <Excedrin> sorear: I keep hoping that Haskell will become that
17:05:47 <joelr1> sjanssen: want to, yes
17:05:51 <EvilTerran> Toxaris, unless, that is, you added "or stop now" (ie <|> numberParser)
17:06:07 <ddarius> fasta: Actually, I believe the biggest problem with GHC is a (relatively) poor native code generator.
17:06:24 * sm finds a nice haskell regexp tutorial.. posix eh
17:06:25 <sjanssen> joelr1: GHC's support for concurrency is probably considerably better than OCaml's
17:06:32 <joelr1> sjanssen: i want to have a vm that's readable and understandable and, hopefully, performant
17:06:40 <ddarius> sm: There are a variety of backends for the Regex library.
17:06:44 <EvilTerran> doesn't GHC have a tendency to prompt garbage collection at inappropriate moments?
17:06:54 <shapr> Write a readable VM and then wrap it in some manual tuning with TH?
17:06:58 <joelr1> sjanssen: and i want to extend it in a functional language as opposed to C. erlang's ffi is aweful
17:07:00 <EvilTerran> (eg inside a tight loop)
17:07:05 <sm> incidentally asking about practical library issues feels almost off-topic here.. I don't often see such questions
17:07:07 <sm> why is that
17:07:21 <joelr1> shapr: something like that. i'll be looking for lots of help, that's for sure
17:07:22 <EvilTerran> sm, because deep abstract maths is so much more fun ;]
17:07:29 <sorear> all these crazy tuning suggestions and people wonder why joelr1 thinks haskell is ugly?
17:07:31 <SamB_XP> sm: wierd!
17:07:32 <ddarius> sm: Because, apparently, you miss them.  They are thoroughly discussed.
17:07:45 <joelr1> sorear: did i say haskell was ugly? LD
17:07:47 <sm> ok. ddarius - in the standard library ?
17:07:49 <joelr1> sorear: :D
17:07:50 <fasta> sm: also there are no practical libraries in Haskell, except for some of the stuff in base.
17:07:56 <sm> I see only Regex.Base and Regex.Posix
17:08:03 <SamB_XP> I would suggest becoming a GHC hacker with mad skillz
17:08:04 <Itkovian> joelr1: I don't see why you could not make your VM sufficiently performant. After all, Jikes RVM is a Java VM written in Java, and we all know how fast Java supposedly is.
17:08:11 <SamB_XP> that's what I'd suggest
17:08:12 <wli> fasta: What do you consider practical?
17:08:16 * joelr1 wants to know if HEM (haskell erlang machine) is a suitable name
17:08:18 <sjanssen> s/no practical/several practical and higly useful
17:08:29 <Excedrin> joelr1: only if you later make something called HAW
17:08:31 <SamB_XP> joelr1: sounds like a gun name or something
17:08:42 * joelr1 is looking for naming suggestions
17:08:47 <sorear> SamB_XP: good luck getting the Simons to accept your patches
17:08:52 <fasta> wli: I consider Data.IntMap practical.
17:08:53 <joelr1> Excedrin: Haw may be V2 :D
17:09:06 <joelr1> i actually like hem and haw
17:09:08 <SamB_XP> sorear: it works better if you have mad skills
17:09:18 <ddarius> sm: http://hackage.haskell.org/packages/archive/pkg-list.html
17:09:20 <joelr1> it's like reserving two names for two implementations in one fell swoop
17:09:30 <sorear> SamB_XP: IME patches sent by outsiders are either ignored (if they are featurees) or replicated without acknowledgement (if they are bugfixes)
17:09:38 <wli> fasta: What do you consider practical that is missing?
17:09:42 <fasta> wli: anything below that standard is not worthy of being looked at.
17:09:47 <sm> I see, thanks
17:09:48 <SamB_XP> IME?
17:10:21 <sm> for getting practical stuff done on my own machine, it looks like I should use hackage stuff heavily
17:10:25 <fasta> wli: how about bindings with appropriate monads for all C libraries in Debian?
17:10:52 <sjanssen> fasta: be realistic, please
17:10:58 <eivuokko> dcoutts, Have you ran tests lately?
17:11:02 <eivuokko> dcoutts, In Cabal.
17:11:05 <fasta> sjanssen: he asked a question.
17:11:18 <dcoutts> eivuokko: no, I havn't
17:11:29 <ddarius> There's another "meaning" to the word "hem".
17:11:34 <dcoutts> eivuokko: last time I did was before the last stable release
17:11:43 <eivuokko> dcoutts, They appear to be broken -.-
17:11:48 <joelr1> all right, i'm gonna start a haskell-cafe thread. good night everyone!
17:11:55 <Toxaris> EvilTerran: yes, we need some parser for literals, of course. I'm not sure how to combine everything, but i just wanted to say that explicit fix could be helpfull here :)
17:11:56 <eivuokko> dcoutts, I mean, they don't compile because some of the tests don't exists or something
17:11:59 <dcoutts> eivuokko: doesn't surprise me one bit :-)
17:12:23 <dcoutts> eivuokko: patches gladly accepted, btw, you don't have a darcs.h.o account do you?
17:12:28 <fasta> sjanssen: do you think that more than 20% of the libraries that are in Hackage are "reusable"?
17:12:38 <EvilTerran> Toxaris, well, i agree with you there. looking at it, i suspect what i had there would actually probably involve something horrible like liftM'ing <|> into Reader or something... O.o
17:12:44 <sjanssen> fasta: I haven't counted them
17:12:51 <eivuokko> dcoutts, I have (for Win32-stuff.)
17:12:54 <EvilTerran> definitely warrants further reading, anyway.
17:13:12 <dons> fasta: have you used them? I'd say i have 20-30% installed on my machine right now, used in one project or another.
17:13:13 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
17:13:21 <dcoutts> eivuokko: ok, well feel free to directly push small cleanups that you don't think need any review
17:13:25 <sjanssen> hmm, is there a total count of packages?
17:13:36 <ddarius> hburg!
17:13:40 <dons> somewhere around 300?
17:13:53 <eivuokko> dcoutts, Hmm.  Ok, thanks.
17:13:55 <dcoutts> eivuokko: you have good taste, you can decide what's ok to push directly and what should go for wider review.
17:13:59 <SamB> sorear: what does IME mean?
17:14:18 <sm> is there a command-line tool for installing hackage packages yet ?
17:14:26 <Toxaris> EvilTerran: Maybe you could get that for free by defining instance Applicative <|> and using explicit type composition and using fix for some newtype like Endo or something like that, so that in the end, you can use Control.Applicative.<|> for both fixed and not-yet-fixed parsers
17:14:28 <Igloo> sorear: Please feel free to prod about patches you think have been ignored
17:14:33 <Toxaris> EvilTerran: for some meaning of "free"
17:14:34 <sjanssen> dons: 220ish
17:14:36 <dons> sm, yeah, cabal-install
17:14:41 <dons> ?where cabal-install
17:14:41 <dcoutts> dons: pah! I've got >60% of the paackages on hackage installed! :-)
17:14:41 <lambdabot> I know nothing about cabal-install.
17:14:42 <EvilTerran> whee
17:14:48 <dons> dcoutts: :)
17:14:52 <Toxaris> EvilTerran: instance Applicative YourParserMonad
17:14:57 <EvilTerran> Toxaris, i think we're gonna need more milliolegs
17:15:00 <sm> yay, thanks
17:15:02 <dcoutts> dons: ghc now takes 1/2 sec to start up just from reading the massive package.conf file
17:15:12 <Igloo> sorear: Bug fixes may appear to be replicated because people fix the build before checking mail, because a fix has already been written and is awaiting validation, or because the fix got stuck in the moderation queue
17:15:16 <dons> i've got 64 packages
17:15:22 <dons> > 64 / 220 :: Rational
17:15:24 <sm> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
17:15:24 <lambdabot>  16%55
17:15:25 <lambdabot> Title: CabalInstall - Hackage - Trac
17:15:28 <fasta> dons: the 20% number I mentioned is not accurate anymore.
17:15:38 <sorear> okay, those make more sense
17:15:40 <fasta> dons: now Hackage also included mtl
17:15:48 <fasta> dons: and other base libs
17:15:53 <dons> i guess you don't use many packages then, fasta?
17:16:03 <SamB> sorear: also they might do other wierd things with the bugfix duplication
17:16:06 <dcoutts> dons: fasta: I've got 133 packages according to ghc-pkg list --simple-output | wc
17:16:20 <dons> ah, i have 71.
17:16:28 <SamB> sorear: but I don't think they do it with the intent of stealing the credit for the fix ;-)
17:16:29 <dcoutts> but then that's because I was testing them for gentoo
17:16:49 <Toxaris> EvilTerran: I use Parsec 98% applicative anyway, so an Applicative parser would work well for me
17:16:54 <sjanssen> fasta: from a quick skim, I'd say that easily 20% are useful
17:17:22 <sjanssen> fasta: even if you exclude the so-called base packages that used to come with ghc
17:17:44 <sm> how would I go about building haddock docs for all the packages I have currently installed ?
17:17:46 <SamB> hmm, I might have as many as 7 patches with my name on them in GHC's repository...
17:17:56 <EvilTerran> i've been meaning to read up on applictive. i'm fairly at home in monads, and i understand arrows in principle, at least, but i'm yet to look at applicative
17:18:19 <EvilTerran> but anyway. this is all very interesting, but it's 1:15am, and i'm getting RSI in my mousing arm, so i think i might call it a night.
17:18:26 <dons> ?userrs
17:18:26 <lambdabot> Maximum users seen in #haskell: 385, currently: 350 (90.9%), active: 25 (7.1%)
17:18:26 * EvilTerran is away: zzz
17:18:33 <Toxaris> EvilTerran: the nice thing, it's actually easier.
17:19:07 <EvilTerran> Toxaris, i look forward to it. =]
17:19:14 <SamB> oooh
17:19:23 <SamB> and a refactored version of one of my patches, too
17:19:24 <sm> oof.. darcs get the full cabal-install, I thought, it'll just be a couple of patches..
17:19:26 <dibblego> Applicative hurts my head
17:19:39 <dibblego> or maybe it's the flu I have
17:19:42 <sm> go darcs, go
17:19:50 <greenrd> Any Frisby experts here?
17:20:01 <Toxaris> EvilTerran: as every evening, the arriving of dons in #haskell is an important sign that I should go to bed, wich I ignore...
17:20:11 <SamB> JohnMeacham: are you here?
17:20:27 * SamB should hope JohnMeacham would be a frisby expert ;-)
17:20:39 <greenrd> heh
17:20:41 <greenrd> I'm generating part of my Frisby parser from previously parsed files(!), and performance is going through the floor
17:21:04 <greenrd> If I called newRule more, would that help?
17:21:09 <ddarius> dons: Any chance of recompiling your collected ICFP 06 UMs with GHC HEAD?
17:21:28 <EvilTerran> Toxaris, heh; ah, yes, i see he did just arrive... hi dons! g'night dons! ;]
17:21:33 * EvilTerran goes for real this time
17:22:36 <SamB> ddarius: even the C/C++ ones?
17:22:52 <fasta> sjanssen: it seems it has improved. I retract my claim. Still, I believe that when one looks at most of those libraries one will find things that are not done in a sane way. Take a look at Crypto for example and find the hard coded constants.
17:22:54 <sorear> SamB: You can compile C++ with GHC HEAD
17:23:10 <ddarius> SamB: As sorear confirmed, you can if you'd like.
17:23:37 <SamB> sorear: yes but I bet it uses bad flags
17:23:40 <ddarius> I'd would probably suggest just using the latest released (or HEAD if you like) gcc version.
17:24:04 <dcoutts> being able to compile C++ with ghc is so wrong
17:24:15 <ddarius> fasta: Hackage is a motley collection and will forever be so.
17:24:38 <monochrom> When will GHC do Fortran? :)
17:25:08 * dcoutts goes to file a bug report complaining that ghc does not compile his perl program
17:26:07 <LoganCapaldo> if compiling C++ with ghc is wrong, than I don't want to be right
17:26:12 <LoganCapaldo> it's all part of the plan
17:26:33 <LoganCapaldo> you bring in ghc as your new, improved "C++" compiler
17:26:48 <LoganCapaldo> and you slower but surely rewrite the whole code base in Haskell
17:26:52 <LoganCapaldo> and no is the wiser
17:27:01 <ddarius> Yes, your new C++ compiler that requires a C++ compiler!
17:27:11 <dcoutts> hah, now that's a cunning plan
17:27:31 <sorear> ddarius: I beleive it ships with a copy of gnu's cc1plus on Windows...
17:29:45 * dcoutts shivers
17:29:50 <dcoutts> evil I tell you
17:30:23 <LoganCapaldo> GHC, now even more backwards compatible
17:30:47 <dcoutts> it's going to stop shipping a C compiler on windows at all soon
17:30:59 <dcoutts> so adding cc1plus was a step backwards imho
17:32:10 <ddarius> @where cabal
17:32:10 <lambdabot> http://www.haskell.org/cabal
17:32:33 <LoganCapaldo> a step backwards into teh future!
17:33:57 <sjanssen> ghc should ship with gvim too
17:34:06 <sjanssen> it's a necessary tool to develop in Windows
17:34:25 * sorear wonders if sjanssen is serious
17:34:33 <sjanssen> sorear: certainly not
17:35:00 <sjanssen> I'm just taking the slippery slope to the limit
17:35:36 <sorear> Not quite, you forgot the part where we include both Emacs *and* XEmacs. :)
17:36:02 <dolio> And Epigram1.
17:36:07 <LoganCapaldo> sjanssen, yi should ship with Eclipse and xmonad should ship with KDE
17:36:22 <LoganCapaldo> that would be aking it to the limit
17:36:23 <mrd> there was that wacky thread a bit back from that guy who absolutely insisted GHC must come with C++
17:36:26 <sjanssen> s/with/instead of/g
17:37:18 <dcoutts> mrd: yeah, nutty
17:37:53 <eivuokko> mrd, dcoutts, Probably Bulat.  Having C++ compiler makes *a lot* of sense in Windows.
17:38:06 <dcoutts> how can I possibly be expected to develop my C++ code with a C++ compiler!!!?!!11  I need to do it with a Haskell compiler!
17:38:21 <sjanssen> eivuokko: what's the motivation?
17:38:29 <eivuokko> dcoutts, See my ghc ticket for more relaxed mingw integration.
17:38:35 <dcoutts> eivuokko: why not just use a C++ compiler?
17:38:38 <eivuokko> sjanssen, Mainly COM-stuff.
17:38:52 <eivuokko> dcoutts, Because it is sort of hard to use mingw toold and mingw-inside-ghc together.
17:39:04 <eivuokko> Not hard, that's not right...very tedious and errorprone.
17:39:28 <dcoutts> eivuokko: then the right solution is to get cabal to grok C++ files, like it does for .c files
17:39:49 <dcoutts> and to use a mingw installation
17:40:29 <dcoutts> eivuokko: you mean ghc's gcc isn't compatible with a gcc from mingw or something ?
17:40:29 <eivuokko> dcoutts, Well, this has changed too ;)  It used to be possible to compile c++ stuff with ghc if g++ was installed, but it became harder few ghc versions ago.
17:40:52 <eivuokko> dcoutts, No but they don't share libraries, includes;  And it is possible it isn't compatible.
17:40:57 <eivuokko> (But unlikely)
17:43:05 <monochrom> http://www.haskell.org/pipermail/glasgow-haskell-users/2007-April/012422.html
17:43:07 <lambdabot> Title: ANNOUNCE: GHC version 6.6.1, http://tinyurl.com/yudvxb
17:44:08 <sorear> mrd: We have so little respect for that guy we use his name here. :/
17:47:04 <ddarius> Ooo. I get to populate the DSP namespace
17:47:21 <monochrom> nice
17:47:21 <mudge> hi haskell friends
17:47:26 <sorear> hi
17:47:30 <eivuokko> dcoutts, Btw, I didn't really understand 'make tests'.  Guess I have to try to break stuff.
17:48:02 <shapr> hi mudge
17:48:24 <mudge> hi shapr
17:48:49 <dcoutts> eivuokko: looks like it compiles some test code that uses the cabal sources directly and compiles them with -DDEBUG so it gets access to the unit tests defined in each module
17:49:56 <eivuokko> dcoutts, Yes;  But Configurations stuff didn't get tested afaict.
17:50:18 <dcoutts> eivuokko: ah right
17:50:44 <dcoutts> eivuokko: hopefully it's just a matter of importing the configuraitons tests and adding them to a list of tests
17:53:12 <eivuokko> Well, that's it for removing warnings.  Time to add features.
17:53:43 <eivuokko> I am quite sure this somehow was connected to cabal2wix, but I've forgotten how -.-
17:54:21 <Igloo> :-)
17:55:00 <mudge> hey,  anyone off the top of their head know a really good reference that describes haskell's typing system really well?
17:55:15 <mudge> seems to be the main thing I get tripped up about
17:55:37 <Excedrin> the report?
17:55:45 <oerjan> @where report
17:55:45 <lambdabot> http://www.haskell.org/onlinereport/
17:55:48 <mudge> the haskell report?
17:55:48 <Excedrin> (at least a good place to start)
17:56:27 <mudge> thanks
17:56:50 <mudge> has there been much descussion about Simon Peyton Jones working at Microsoft?
17:57:02 <ddarius> mudge: Why?
17:58:01 <mudge> well,  I think it is very interesting,   various little things.   Like Simon's recent videos were about an X windows manager on Linux, and he showed it and everything using linux
17:58:07 <mudge> and microsoft is against linux
17:58:17 <Cale> It's MS Research
17:58:23 <dibblego> MSR != MS
17:58:26 <Cale> They're basically a separate entity :)
17:58:27 <ddarius> mudge: So? Why would -we- discuss it?
17:58:30 <dibblego> > "MSR" /= "MS"
17:58:32 <lambdabot>  True
17:58:32 <mudge> really?
17:58:37 <Cale> It's like Xerox and Xerox PARC
17:59:01 <mudge> I wonder what Microsoft's interest is in Haskell
17:59:12 <dibblego> mudge, the small division of the company I work for has a research section consisting of 2 people, who have found that what the remainder of the company does, to be flawed
17:59:17 <Cale> Looked at the stuff going into C# lately?
17:59:21 <ddarius> mudge: Microsoft probably doesn't have one. It has an interest in Simon Peyton Jones for obvious reasons.
17:59:25 <LoganCapaldo> mudge, your confused. Microsoft isn't interested in Haskell necessarily per se.
17:59:26 <dibblego> mudge, the research section is me and the owner of the company
17:59:31 <Pseudonym> Microsoft wants to have the Next Best Thing(tm).
17:59:35 <Pseudonym> But they don't know what it will be.
17:59:37 <Cale> LoganCapaldo: you're
17:59:44 <sorear> Pseudonym: They don't want the best thing?
17:59:47 <sorear> :)
17:59:51 <LoganCapaldo> Well it's certainly not my confused!
17:59:56 <DukeDave> Woo F#
17:59:57 <Cale> heh
18:00:08 <DukeDave> I'm waiting for my library to get the book in,
18:00:16 <mudge> okay, thanks
18:00:18 <mudge> makes sense
18:00:25 <mudge> i just find it interesting
18:00:37 <wli> My hypothesis regarding research divisions centers around patent stockpiling for the purposes of patent lawsuits.
18:00:45 <Pseudonym> sorear: :-)
18:00:49 <dibblego> wli, enter IBM
18:01:08 <Cale> http://www.jsayers.com/thingpart/thingpart.html
18:01:09 <lambdabot> Title: thingpart by joe sayers
18:01:13 <DukeDave> When I do something like this:
18:01:13 <wli> So they don't really care about any direct use or usability of the research. Only usability in patent lawsuits.
18:01:17 <DukeDave> > (*) 8
18:01:18 <lambdabot>  <Integer -> Integer>
18:01:28 <Tac-Tics> > (*)
18:01:28 <DukeDave> Is that 'type inference' taking place?
18:01:29 <lambdabot>  <Integer -> Integer -> Integer>
18:01:37 <dibblego> wli, that is not the universal case
18:01:40 <Cale> DukeDave: it's type inference and defaulting
18:01:41 <DukeDave> > (*) 8.5
18:01:43 <lambdabot>  <Double -> Double>
18:01:47 <Cale> :t (*)
18:01:49 <lambdabot> forall a. (Num a) => a -> a -> a
18:01:49 <wli> Pseudonym: Say, I heard you had some sort of critique of Mercury or some such. What was it?
18:01:51 <mauke> DukeDave: when is type inference not taking place?
18:01:53 <Cale> :t (*) 8
18:01:55 <lambdabot> forall t. (Num t) => t -> t
18:02:03 <Cale> :t (*) 8 5
18:02:05 <lambdabot> forall t. (Num t) => t
18:02:11 <Pseudonym> wli: I don't have a formal critique as such.
18:02:23 <wli> Pseudonym: Informal is fine by me.
18:02:32 <mudge> do most of you guys know each other?
18:02:35 <Pseudonym> Tom Conway pointed out to me that Mercury only has an advantage on Haskell in one area.
18:02:44 <DukeDave> I need the term to describe the fact that the partial application of a type (e.g. Double) is forcing the second argument of (*) to the same type
18:02:46 <Cale> After completing type inference, for numeric typeclasses it does some defaulting: Integer if possible, and Double otherwise
18:02:46 <Pseudonym> And that's the predictable performance model.
18:02:50 <wli> Pseudonym: Educated opinions would be useful to me.
18:02:57 <ddarius> DukeDave: The <Integer -> Integer> part is not all that directly related to type inference
18:03:16 <ddarius> mudge: Define "know".  To my knowledge, I've never seen any of them.
18:03:18 <Pseudonym> But really, Mercury's major failing (we'll ignore things like the archaic Prolog syntax) is the mode system.
18:03:22 <Cale> :t (*) (5 :: Integer)
18:03:24 <Pseudonym> Don't get me wrong, the mode system is good.
18:03:24 <lambdabot> Integer -> Integer
18:03:28 <Pseudonym> It's fabulous, in fact.
18:03:30 <mudge> well,  I mean generally know about online
18:03:35 <Cale> That's just type inference there
18:03:40 <DukeDave> ddarius: What would you call it?   (This 'forcing' of types)
18:03:40 <Pseudonym> But the complex data flow also makes it difficult to use.
18:03:40 <sorear> Modes seem like an admission of failure to me.
18:03:50 <Pseudonym> If everything is "in" or "out", then you're laughing.
18:03:52 <DukeDave> Cale: That's what I'm getting it :)
18:03:54 <fasta> What are modes?
18:03:59 <ddarius> DukeDave: The forcing of types to Integer is defaulting.
18:04:04 <Cale> DukeDave: well, there's two things going on in the other example
18:04:04 <Pseudonym> As soon as you want complex dataflow, the declarations really get in the way.
18:04:20 <Pseudonym> One under-appreciated strength of Haskell is that the dataflow is simple.
18:04:21 <ddarius> The fact that lambdabot output <Integer->Integer> is a crazy Show instance and Typeable magic.
18:04:22 <DukeDave> ddarius: Ah right, I see
18:04:30 <wli> Pseudonym: (My own opinions on this are approximately as ignorant and vague as "Something Prolog-ish with static typing is useful now and then," so this really is enlightening.)
18:04:32 <Cale> DukeDave: There's the type inference/checking which ensures that both parameters to (*) have the same type
18:04:43 <Pseudonym> wli: Let me put it this way.
18:04:44 <mauke> (*) has the type a -> a -> a, 8.5 has the type Double, therefore a = Double
18:04:44 <DukeDave> Cale: Yeah that's the magic I'm  getting at
18:04:46 <Cale> and then there's numeric defaulting which resolves the ambiguity
18:04:52 <Pseudonym> Mercury is to Prolog as 1976-era ML is to Lisp.
18:04:56 <Pseudonym> It's a huge improvement.
18:05:07 <Cale> :t 8.5
18:05:09 <lambdabot> forall t. (Fractional t) => t
18:05:21 <ddarius> Pseudonym: How do you -not- make a huge improvement on Prolog?
18:05:25 <Cale> > 8.5 :: Rational
18:05:27 <lambdabot>  17%2
18:05:34 <wli> Pseudonym: Analogies aren't good for me. The earlier commentary was great, though.
18:05:35 * ddarius revels in the comfort of Prolog bashing.
18:05:38 <Cale> > 8.1 :: Rational
18:05:40 <lambdabot>  81%10
18:05:45 <Pseudonym> ddarius: Oh, there are PLENTY of examples of non-improvements on Prolog.
18:05:51 <Pseudonym> KL1 springs to mind.
18:06:30 * ddarius has no idea what KL1 is.  Some predecessor of AKL?
18:06:32 <wli> Pseudonym: Anything more about the mode system? That's one aspect of Mercury I scarcely understood, if at all.
18:06:32 <sorear> fasta: In a normal logic language, you have predicates like append(X,Y,Z), and they work in every direction.  Modes force you to only use them in one direction
18:06:53 <Pseudonym> sorear: Or, more correctly, only one direction at a time.
18:06:58 <sorear> fasta: That's my understanding, anyway.  I haven't done much research.
18:07:02 <Pseudonym> Since Mercury can generate multiple modes for the same predicate.
18:07:04 <wli> sorear: Not quite so. Multiple modes may be declared.
18:07:17 <fasta> The advantage of this is efficiency?
18:07:26 <Pseudonym> That's one huge advantage.
18:07:38 <fasta> Can't it perform a usage analysis?
18:07:51 <Pseudonym> But like strong types, strong modes eliminate bugs.
18:08:22 <fasta> Strong types can also introduce bugs, but they don't appear at run-time.
18:08:30 <Pseudonym> No!
18:08:34 <Pseudonym> Strong types don't introduce bugs.
18:08:53 <Pseudonym> The time you spend satisfying the compiler is not for the compiler's convenience.
18:08:58 <Pseudonym> It's time you're not spending debugging later.
18:09:22 <Pseudonym> Mercury, like Haskell, also has the feature that once it compiles, it's often correct.
18:09:31 <ddarius> Pseudonym: My experience with C is -nothing- like that!
18:09:40 <wli> Pseudonym: Anything more to say about the failings of the mode system?
18:09:49 <Pseudonym> wli: Do you have Mercury installed?
18:09:51 <Pseudonym> Or downloaded?
18:10:21 <fasta> Isn't a mode that's not in the query direction the same as a function definition in Haskell?
18:10:21 <wli> Pseudonym: An ancient version. I think my gcc is too modern for any recent Mercury.
18:10:21 <Pseudonym> Because if so, I'd like to draw your attention to one of the shipped examples.
18:10:23 <Pseudonym> e.m
18:10:35 <Pseudonym> And the inst declaration in particular.
18:10:44 <Pseudonym> It took be about two hours to get that one declaration right.
18:10:50 <Pseudonym> And all I wanted was a lazy stream.
18:10:56 <Pseudonym> s/be/me
18:11:16 <Pseudonym> If it's more recent than 10 years old, it'll be there.
18:12:28 <Pseudonym> And that's one of the problems.  Mercury's mode system doesn't exactly interact well with higher-order programming.
18:12:32 <wli> I don't think I have the source sitting around (though I should probably check and see if something working with a modern gcc is about).
18:12:38 <Pseudonym> Right.
18:13:04 <Pseudonym> Because a predicate can have more than one mode, you have to annotate a higher-order argument with the mode of the passed predicate.
18:13:15 <Pseudonym> And that annotation is done in the MODE system, not the type system.
18:14:18 <Pseudonym> So if you have a complex data structure with a predicate stored in it somewhere deep down, you have to, effectively, copy the structure of the type to make an inst declaration.
18:14:18 <sorear> modes aren't types?
18:14:21 <Pseudonym> No.
18:14:31 <wli> 0.13.1 seems to have gcc-4.1.x support.
18:14:40 <Pseudonym> If you ignore higher-order for a moment...
18:14:51 <Pseudonym> Insts can be thought of as annotations on a type tree.
18:15:09 <Pseudonym> So you attach either "free" or "bound" to each node in the type.
18:15:21 <Pseudonym> With the constraint that if a node is "free", so are all its children.
18:15:28 <wli> sorear: The mode of a predicate say on (int, int) can be things like (in, in), (out, out), (in, out), (out, in), and sometimes more exotic things.
18:15:29 <Pseudonym> Then a mode is a mapping between insts.
18:15:45 <Pseudonym> in is actually a shorthand for ground -> ground
18:15:58 <Pseudonym> (where "ground" is shorthand for a type tree in which everything is bound)
18:16:08 <Pseudonym> and out is a shorthand for free -> ground
18:17:36 <Pseudonym> Make sense?  You pass in a free variable, and get a ground one out.
18:18:22 <ddarius> ground?! Isn't that excessive?
18:18:38 <ddarius> (re out)
18:18:42 <Pseudonym> Why?
18:18:57 <Pseudonym> Most interesting data structures, even in Haskell, don't contain free variables.
18:19:22 <ddarius> "even in Haskell"?
18:19:39 <LoganCapaldo> data structures can have free variables?
18:19:47 <Pseudonym> :-)
18:19:49 <LoganCapaldo> what does that mean exactly?
18:19:50 * Pseudonym is kidding
18:19:56 <LoganCapaldo> oh :(
18:20:20 <Tac-Tics> These variables.... are they Free as in free lunch? Or free as in freedom of speech?
18:20:35 <sorear> The latter.
18:20:55 <Pseudonym> http://www.google.com/codesearch?hl=en&q=show:orzRq05Oj0w:66DbqP-lwdQ:atTT6ZX8BTA&sa=N&cd=1&ct=rc&cs_p=http://www.g12.cs.mu.oz.au/mercury-compiler-rotd-2006-12-01-macosx.tar.gz&cs_f=mercury-compiler-rotd-2006-12-01/samples/e.m#a0
18:20:56 <lambdabot> Title: mercury-compiler-rotd-2006-12-01/samples/e.m - Google Code Search, http://tinyurl.com/2ces6o
18:20:57 <Pseudonym> There we go.
18:21:03 <sorear> Pseudonym: What's a data structure mean in the context of LP?
18:21:04 <Pseudonym> You'll need the tinyurl I suspect.
18:21:09 <sorear> Pseudonym: Same as for FP?
18:21:16 <Pseudonym> Take a look at the inst declaration.
18:21:28 <Pseudonym> sorear: Sure.  Mercury has a Hindley-Milner-esque type system.
18:21:53 <wli> Haskell-esque with typeclasses, even.
18:21:58 <Pseudonym> As you can see, you need to make an inst declaration which basically matches the structure of the type declaration.
18:22:40 <wli> Pseudonym: Building the thing is a little painful.
18:25:49 <SamB_XP> woooo typeclasses
18:26:26 <SamB_XP> there should be a Wikipedia category for languages that have typeclasses
18:26:35 <wli> Or at least it seems that the debian dir has bitrotted.
18:27:24 <LoganCapaldo> Is there an exhaustive list? What languages beside Haskell have type classes?
18:27:39 <dibblego> Scala (calls them implicit defs)
18:28:06 <wolverian> perl 6 has roles
18:28:10 <sorear> Gofer, BitC, Mercury, ...
18:28:16 <oerjan> Clean
18:28:24 <Pseudonym> C++, soon.
18:28:52 <wolverian> though they really want type inference to get synergestic effects I guess :)
18:30:07 <LoganCapaldo> Pseudonym, refer ye to concepts? or something else?
18:30:27 <Pseudonym> I do indeed.
18:32:04 <Excedrin> are "concepts" like "traits"? (in C++ speak)
18:32:30 <ddarius> Excedrin: Conceps -are- C++ speak
18:32:31 <rehges> ObjC has typeclasses of a sort
18:33:03 <littledan> LoganCapaldo: I made something like type classes in Factor
18:33:08 <littledan> but it's not part of the language
18:33:22 <Excedrin> ddarius: yes? that's what I was asking... maybe I should just ask what are they?
18:33:23 <wli> robdd appears to have bitrotted with no obviousway to turn it off
18:33:59 <johnnowak> littledan: i saw the blog post on that, very nice
18:35:02 <Pseudonym> Excedrin: Concepts are what you see in the STL.
18:35:19 <Pseudonym> When you say that something is Copy Constructible, or LessThanComparable, or Strict Weak Ordering, that's a concept.
18:35:22 <Excedrin> the algorithm stuff, or generic container stuff?
18:35:30 <Excedrin> ok
18:35:48 <Excedrin> so, maybe traits are concepts, I'm not sure
18:35:49 <littledan> johnnowak: thanks
18:35:50 <Pseudonym> Compare, for example, Less Than Comparable with Haskell's Ord.
18:36:08 <Pseudonym> You can think of a type that has a trait as satisfying a concept.
18:36:12 <littledan> what does ObjC have that are like type classes?
18:36:17 <Pseudonym> The concept being Supports These Traits.
18:36:42 <Excedrin> ok that makes sense
18:37:00 <wolverian> Excedrin, concepts don't need to be declared on the type, I think, if the concept is marked "auto"
18:37:05 <johnnowak> objc has message passing, but i wouldn't say that is "like type classes"
18:37:12 <littledan> in dynamically typed languages, the line between type class and abstract class is very faint
18:37:13 <johnnowak> it's more the other way around
18:38:46 <Tac-Tics> What is the floating point exponential function again?
18:38:56 <Tac-Tics> How do I do pi ^ pi?
18:39:03 <dons> > pi ^ pi
18:39:04 <lambdabot>  Add a type signature
18:39:10 <dons> > pi ^^ pi
18:39:10 <lambdabot>  Add a type signature
18:39:16 <dons> > pi ** pi
18:39:17 <lambdabot>  36.4621596072079
18:39:21 <dons> :)
18:39:28 <dons> :t (^)
18:39:30 <Tac-Tics> thanks
18:39:30 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
18:39:31 <dons> :t (^^)
18:39:33 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
18:39:33 <dons> :t (**)
18:39:35 <lambdabot> forall a. (Floating a) => a -> a -> a
18:41:02 <sorear> Almost every strongly typed language supports some form of overloading.
18:41:06 <ricky_clarkson> > pi ** 2
18:41:08 <lambdabot>  9.869604401089358
18:42:56 <wli> Pseudonym: Well, FTBFS here, so...
18:43:56 <Pseudonym> wli: Sorry, what was that in response to?
18:44:10 <wli> Pseudonym: Getting a fresh Mercury installation.
18:44:16 <Pseudonym> Right.
18:44:25 <Pseudonym> Just look at the link I mentioned, you'll get the idea.
18:44:41 <Excedrin> how do Alice ML (similar to SML, but with extensions) modules relate to type classes?
18:44:42 <wli> Yeah, I read it. (I've also written Mercury code myself.)
18:44:47 <Pseudonym> Cool.
18:48:08 <Excedrin> http://www.informatik.uni-freiburg.de/~wehr/publications/Wehr_ML_modules_and_Haskell_type_classes.pdf <- 2005, but maybe still interesting to someone
18:48:10 <lambdabot> http://tinyurl.com/3co4jo
18:48:56 <OceanSpray> sjanssen, you still here?
18:49:06 <sjanssen> OceanSpray: always :)
18:49:22 <OceanSpray> oh hey
18:51:14 <OceanSpray> what prevents me from doing lispPair :: Parser (IORef LispVal)
18:51:34 <OceanSpray> and using liftIO (newIORef <parsed value>) ?
18:51:42 <sjanssen> you can't great IORef's outside of the IO monad
18:51:47 <sjanssen> s/great/create
18:52:27 <sjanssen> OceanSpray: you can't use liftIO because 'Parser' isn't a transformer over IO
18:52:28 <OceanSpray> oh right
18:52:46 <OceanSpray> Parser is not a MonadIO
18:53:48 <oerjan> OceanSpray: oh, i was going to say something about that
18:53:58 <OceanSpray> oh?
18:54:15 <oerjan> i thought that you could do Parser (IO LispVal)
18:54:26 <sjanssen> you might be able to do that
18:54:44 <sjanssen> it may be a PITA to manage
18:54:47 <oerjan> then you can parse it directly into an action which when run fills in all the IORefs for you
18:54:54 <OceanSpray> huh, really?
18:55:09 <sjanssen> you're essentially doing the work of a monad transformer by hand
18:55:34 <OceanSpray> is there a way NOT to do it by hand, in this case?
18:55:47 <oerjan> i've done something similar for trivial languages - parsing directly into the final program
18:56:06 <OceanSpray> if there isn't, how hard is it to write a monad transformer?
18:56:25 <samreid> Speaking of parsing monad transformers...
18:56:33 <sjanssen> OceanSpray: it's probably hard to make Parsec into a monad transformer, there's a lot of code to modify there
18:56:46 <samreid> sjanssen, it's not _that_ hard
18:56:52 <samreid> http://samuelhughes.com/darcs/partran/
18:56:54 <lambdabot> Title: Index of /darcs/partran
18:56:59 <oerjan> OceanSpray: sam hughes recently made a monad transforming parser library, and there was at least some intention to do it for Parsec at the SOC
18:57:04 <sjanssen> samreid: just tedious, I suppose?
18:57:07 <samreid> yah :)
18:57:23 <samreid> xerox was/is doing it for SOC
18:57:54 <OceanSpray> that parsing-into-an-ABS option seems more and more unavoidable now...
18:58:12 <OceanSpray> I mean, -AST
18:59:54 <oerjan> OceanSpray: partran is the first one i mentioned
19:00:50 <OceanSpray> so, I have three options right now:
19:01:09 <oerjan> oh, one more idea i had
19:01:13 <OceanSpray> 1) do what sjanssen suggested and make LispVal parametric,
19:01:35 <OceanSpray> 2) parse into an AST instead of a lisp list
19:01:46 <oerjan> er, (1) sounds like my idea, what was it?
19:01:46 <OceanSpray> 3) wait for xerox to finish and use his code.
19:02:00 <OceanSpray> oerjan, state your idea
19:02:31 <sjanssen> OceanSpray: 3.1 use partran, which has already been written
19:02:33 <oerjan> i thought if you had it be LispVal IORef then you could parse it into LispVal Id for some newtype Id a = Id a
19:02:39 <sjanssen> samreid: is partran usable already?
19:02:44 <OceanSpray> orz
19:02:48 <samreid> sjanssen: totally untested, but possibly usable
19:03:02 <dibblego> ?hoogle (a -> Maybe a) -> a -> [a]
19:03:03 <lambdabot> No matches, try a more general search
19:03:10 <oerjan> and then have a function that simply turns Id into IORef afterwards
19:03:13 <dibblego> :t unfoldr
19:03:16 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:03:17 <OceanSpray> I want to modify as little code as possible.
19:04:00 <oerjan> there was a .Parsec submodule of partran mentioned
19:04:13 <oerjan> which implemented Parsec-compatibility i presume
19:04:13 <OceanSpray> oh?
19:04:15 <chessguy> 'evening
19:04:30 <oerjan> at least some of it
19:04:40 <OceanSpray> btw, what does 'newtype' do?
19:04:48 <samreid> sjanssen: at least (char 'a' >> char 'b') and (string "abcdef") works fine for the .Parsec part
19:04:51 <dibblego> OceanSpray, same as 'data' with some restrictions
19:05:03 <OceanSpray> what restrictions?
19:05:14 <dibblego> one constructor with one argument
19:05:26 <OceanSpray> oh
19:05:31 <eivuokko> dcoutts, is SrcDist.hs, prepareTree, use of appendVersion wrong with configurations?
19:05:40 <dino-> hlog
19:05:51 <OceanSpray> ok, I've decided.
19:06:00 <OceanSpray> Since TWO people suggested the same idea,
19:06:08 <OceanSpray> I'm going to do the parametrization
19:06:21 <dino-> Do these have speakable names like (>>=) does: (&&&) (***) ?
19:06:29 <oerjan> OceanSpray: it's almost like the corresponding data but the restrictions allow it to store it as the same representation without wrapping
19:06:33 <dcoutts> eivuokko: nominolo did say that sdist has some interesting problems with configurations
19:06:56 <oerjan> *the compiler to store the value
19:07:16 <dcoutts> eivuokko: because one does not want to use the 'current' configuration, but instead you have to find all the source files that could ever be needed by any possible configuraion state
19:07:18 <dibblego> :t unfoldl
19:07:20 <lambdabot> Not in scope: `unfoldl'
19:07:48 <eivuokko> dcoutts, Mmm, yeah.
19:08:17 <oerjan> :t unfold
19:08:19 <lambdabot> Not in scope: `unfold'
19:08:24 <oerjan> hm...
19:08:32 <oerjan> oh right, only unfoldr
19:08:33 <dcoutts> eivuokko: what would the problem with appendVersion be with configurations?
19:09:09 <eivuokko> dcoutts, It assumes version: is not indented etc
19:09:23 <eivuokko> dcoutts, I am not sure if that's correct for configurations
19:09:23 <dcoutts> eivuokko: oh, it's a tad odd isn't itm it's just textual grepping/sedding
19:09:48 <dcoutts> eivuokko: yeah, that's not so good
19:09:56 <ddarius> dino-: There are some names, but not widely accepted ones.
19:10:14 <dcoutts> eivuokko: it may still be ok since the version is in the main/top-level section of the file
19:10:26 <dcoutts> eivuokko: but that method is pretty ugly :-)
19:11:26 <eivuokko> dcoutts, It is not typesafe (hence making it this long without change.)
19:11:33 <dcoutts> right
19:11:40 <dcoutts> purely textual
19:12:05 <eivuokko> Ah, yes.
19:12:16 <OceanSpray> hmm
19:12:22 <OceanSpray> about environments...
19:12:33 <oerjan> dibblego: unfoldl would be nearly like reverse . unfoldr ...
19:12:35 <dcoutts> eivuokko: but there's not an obvious way to do it structurally since you'd loose comments and x-extension fields
19:12:57 <dibblego> oerjan, I know, I was just checking :)
19:13:39 <dino-> ddarius: ok thanks
19:13:43 <OceanSpray> before using parameters, a LispEnv was of type Env {parent :: LispEnv, bindings :: IORef (Map String (IORef LispVal))}
19:14:00 <eivuokko> dcoutts, Yeah, getting too big to add all that...
19:14:04 <OceanSpray> ok nevermind
19:14:07 <OceanSpray> got it.
19:14:25 <eivuokko> dcoutts, Guess I'll leave it be then...*shudder*
19:15:02 <dcoutts> eivuokko: aye, it upsets me too but I don't see any nice way
19:15:16 <dons> oh cool, our student union is paying for the phdcomics guy to visit unsw :)
19:15:28 <dons> that's what we have a student union for!
19:15:53 <dcoutts> cool :-)
19:17:12 <dcoutts> dons: in comparison, our student union is standing idly by while loads of students get dragged before the proctors based on evidence gleaned from photos on facebook
19:17:27 <dons> scary
19:17:36 <hpaste>  palomer pasted "Reader problems" at http://hpaste.org/2269
19:17:41 <newsham> anyone doing proofs with GADTs?  would be nifty seeing a proof of rev-rev in GADTs as a comparison
19:18:00 <newsham> (or agda/alfa, coq for that matter)
19:18:09 <dons> newsham: my colleague does proofs with GADTs and type families
19:18:16 <dons> he's giving a talk tomorrow, i'll see if i can get slides
19:18:22 <newsham> thanks.
19:18:46 <newsham> there's this: http://article.gmane.org/gmane.comp.lang.haskell.cafe/27062   but I havent fully absorbed it yet.
19:18:49 <lambdabot> Title: Gmane -- Mail To News And Back Again
19:19:23 <SamB_XP> dcoutts: evidence of what?
19:19:41 <conal> dons: phdcomics ?
19:20:19 <LoganCapaldo> I'd never heard of him either until he came to my school
19:20:29 <tonfa> @go phdcomics
19:20:30 <dcoutts> SamB_XP: breaking regulations on celebrating finishing exams by getting each other messy, spraying fizzy plonk etc.
19:20:31 <lambdabot> http://www.phdcomics.com/
19:20:31 <lambdabot> Title: Piled Higher and Deeper
19:20:34 <dons> conal: yeah http://www.phdcomics.com/comics.php
19:20:34 <lambdabot> Title: Piled Higher and Deeper
19:20:44 <SamB_XP> dcoutts: what?
19:20:58 * oerjan still cannot get over the name "Agda"
19:21:03 <dcoutts> SamB_XP: absolutely no tieing each other to lamp posts
19:21:06 <dons> oerjan: ?
19:21:12 <conal> dons: thanks.  hadn't heard of it.
19:21:16 <oerjan> (you have to be scandinavian to understand why :) )
19:21:24 <newsham> what does "agda" mean?
19:21:28 <dons> oerjan: ah, it just sounds like a woman's name
19:21:29 <samreid> palomer: annotated
19:21:46 <dons> conal: oh, its a classic. painfully so sometimes
19:22:16 <SamB_XP> @go piled higher and deeper
19:22:17 <lambdabot> http://www.phdcomics.com/
19:22:17 <lambdabot> Title: Piled Higher and Deeper
19:22:28 <oerjan> it's the name of a hen in a song by the Swedish/Dutch singer Cornelis Vreswijk
19:22:33 * SamB_XP should have tried that when he first wanted to...
19:24:17 <oerjan> and it is pretty obvious that it's deliberate, given Coq and Coquand...
19:24:50 <newsham> "coq" still wins for best/worst name
19:24:58 <newsham> I dont even know where to begin :)
19:25:39 <dons> oerjan: oh, I see! kind of obscure :)
19:27:57 <oerjan> dons: also, the song is a bit racy
19:30:09 <dons> about a chicken?
19:31:36 * ddarius prepares to run haddock for the first time ever.
19:31:55 * LoganCapaldo plays a dramatic drum roll
19:31:56 <oerjan> yeah
19:32:01 * glen_quagmire is lindsay
19:35:48 <oerjan> *vreeswijk
19:36:04 <ihope> What's this about vreeswijk?
19:36:47 <ihope> (Somebody tell my client that http://tunes.org/~nef/logs/haskell/","The is not the intended URL.)
19:36:56 <glguy> ?seen elliottt
19:36:56 <lambdabot> elliottt is in #haskell. I last heard elliottt speak 3d 17h 47m 47s ago.
19:37:37 * ihope says http://tunes.org/~nef/logs/haskell/ so as to be able to click on it
19:37:39 <lambdabot> Title: Index of /~nef/logs/haskell
19:38:00 * glguy types ./get.sh when he needs his logs updated :)
19:38:51 <oerjan> ihope: ircbrowse has become better lately, not as slow any more
19:40:17 --- mode: ChanServ set +o glguy
19:40:19 --- topic: set to '["A Taste of Haskell: http://blip.tv/file/324976  http://www.blip.tv/file/325646/","The Haskell programming language:  got types?","Home: http://haskell.org","Paste:  http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The  language of ICFP winners 3 years running"]' by glguy
19:40:25 <glguy> :-/
19:40:54 --- topic: set to '["A Taste of Haskell: http://blip.tv/file/324976 http://www.blip.tv/file/325646/ ","The Haskell programming language:  got types?","Home: http://haskell.org ","Paste:  http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","The  language of ICFP winners 3 years running"]' by glguy
19:41:23 --- topic: set to '["A Taste of Haskell: http://blip.tv/file/324976 http://www.blip.tv/file/325646/ ","The Haskell programming language: got types?","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","The language of ICFP winners 3 years running"]' by glguy
19:41:38 <glguy> better?
19:41:44 <ihope> Yup.
19:41:49 --- mode: glguy set -o glguy
19:41:58 <glguy> asdf
19:42:00 <glguy> oops :)
19:42:23 <glguy> what *is* cool is that when you highlight something with visual mode in vim, it goes into your clipboard
19:42:40 <LoganCapaldo> It does?
19:42:49 <LoganCapaldo> I always hit :
19:43:02 <LoganCapaldo> and use y
19:43:18 <LoganCapaldo> mmmf
19:43:28 <glguy> if you use line visual, then it keeps the newline
19:43:36 <glguy> if you use character based it doesn't
19:43:52 <shachaf> glguy: Into CLIPBOARD? Or PRIMARY?
19:44:06 <glguy> shachaf: whatever Shift+Ins uses
19:44:33 <shachaf> glguy: Is this X?
19:44:35 <glguy> yeah
19:45:09 <shachaf> Hmm.
19:45:58 <glguy> hmm?
19:46:23 <glen_quagmire> hmm
19:46:34 <ddarius> Shite!
19:46:39 <glguy> ?yow
19:46:39 <lambdabot> Is it NOUVELLE CUISINE when 3 olives are struggling with a scallop in a
19:46:39 <lambdabot> plate of SAUCE MORNAY?
19:47:16 * shachaf always uses "+p or "*p.
19:47:36 <LoganCapaldo> shachaf, yeah that's what I was getting at
19:47:38 <shachaf> I'll have to see if this works.
19:48:22 <glguy> shachaf: I was using it to cut and paste from vim
19:48:23 <glguy> into irssi
19:49:02 <LoganCapaldo> That almost sounds like an argument for emacs
19:49:06 * LoganCapaldo is kidding
19:49:12 <glguy> ?quote joke
19:49:12 <lambdabot> your_mom says: Will you stop telling dumb jokes about me please?
19:49:14 <glguy> ?quote joke
19:49:14 <lambdabot> shachaf says:  monochrom: Emacs is also a joke. :-)
19:49:22 <glguy> ;-)
19:49:39 * shachaf is really going to regret that.
19:49:57 <SamB_XP> shachaf: is it the same kind of joke as Pugs?
19:50:20 * glguy thinks there might be some pun about one-liners 
19:51:04 <shachaf> SamB_XP: Pugs is a joke?
19:51:07 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2270
19:51:13 <shachaf> SamB_XP: It'll be ready by Christmas, you know. :-)
19:51:34 <SamB_XP> shachaf: yes ... a joke that got out of hand
19:51:37 <glguy> yeah, but which year's xmas?
19:53:13 <shachaf> glguy: Stop spoiling it.
19:53:28 <glguy> ?
19:54:48 <shachaf> glguy: It'll be ready soon enough.
19:54:53 <SamB_XP> shachaf: I mean, really. doesn't "an implementation of Perl 6 in Haskell" sound like a joke to you?
19:54:58 * shachaf knows very little about Perl 6.
19:55:08 <SamB_XP> that's beside the point
19:55:36 <Cale> SamB_XP: Why should that sound like a joke?
19:56:03 <glguy> is pugs intended for more than bootstraping perl 6?
19:56:05 <SamB_XP> well it would be a funnier joke if it hadn't been started yet
19:56:43 <Cale> Haskell seems as good a language as any to implement other languages in :)
19:57:11 <Cale> On the other hand, the difference between Perl 5 and Haskell is large enough ... :)
19:57:41 <shachaf> Perl 6 is quite odd, from what I see (but then, so is Perl 5).
19:58:26 <SamB_XP> I was under the impression that Pugs was originally intended as some kind of joke
19:58:51 <LoganCapaldo> A joke gone terribly right
19:58:53 <LoganCapaldo> ?
19:59:06 <SamB_XP> something like that
19:59:56 <ddarius> SamB_XP: It was done in response to an exercise in TAPL.
20:00:13 <SamB_XP> ddarius: what was the exercise?
20:00:39 <glguy> tell a joke?
20:00:47 <SamB_XP> was it a "50" (on Knuth's scale)?
20:00:50 <glguy> :)
20:03:10 <ddarius> http://www.perl.com/pub/a/2005/03/03/pugs_interview.html
20:03:11 <lambdabot> Title: perl.com: A Plan for Pugs
20:03:23 <ddarius> SamB_XP: "Implement a toy language"
20:03:49 <SamB_XP> ddarius: oh. I think I might give him/her an F.
20:04:04 <SamB_XP> people seem not to think Perl 6 is a toy language for some reason...
20:05:34 <Tac-Tics> SamB_XP: whatcha got against perl?
20:05:54 <Tac-Tics> http://imgs.xkcd.com/comics/lisp.jpg
20:06:01 <SamB_XP> Tac-Tics: you mean other than how ugly it can get?
20:06:08 <Tac-Tics> hehe
20:06:16 <Tac-Tics> ugly? Or expressive!
20:06:25 <SamB_XP> I definately meant ugly
20:06:35 <SamB_XP> though of course not ALL perl code is ugly
20:06:46 <SamB_XP> some is quite nice, like the Evil Mangler
20:06:48 <glguy> some has been deleted
20:06:49 <SamB_XP> ;-P
20:07:01 <Tac-Tics> I've never learned perl
20:07:05 <Tac-Tics> and I probably never will
20:07:22 <Tac-Tics> Perl is like the dark side of the force in programming from what I've heard
20:07:27 <glguy> perl can be nice if you have one text file
20:07:29 <glguy> and you want a different one
20:07:30 <Tac-Tics> it sucks you in with its one liner solutions
20:07:35 <glguy> and you don't need to do that change often
20:08:12 <SamB_XP> glguy: what was that last bit?
20:08:32 <glguy> SamB_XP: good for one-off things
20:08:34 <dino-> I've had a lot of fun writing in Perl for a long time. But now I work somewhere with a lot of OO Perl. I mean a real lot. It's.. not so nice.
20:09:01 <SamB_XP> glguy: there is this thing called #!/bin/perl you might be interested in
20:09:26 <SamB_XP> so even if you want to do the same thing over and over again, you can
20:09:35 <SamB_XP> without wearing out your fingers
20:09:51 <glguy> SamB_XP: I just don't consider perl code mantainable
20:09:56 <glguy> I wasn't saying it couldn't be reused
20:10:18 <glguy> besides, that's what bash history is for, right :;)
20:10:20 <SamB_XP> have you seen the evil mangler?
20:10:36 <glguy> didn't they get rid of it for a reason?
20:10:38 <SamB_XP> the main reason it's not maintainable is what it DOES, not the language it's written in
20:11:08 <SamB_XP> for some reason the GCC people keep violating it's assumptions ;-P
20:12:41 <dino-> I have a QuickCheck question.
20:12:54 <glguy> can anyone else tell that a TV is on even when its muted from a few rooms away (by the high pitched ringing they give off)
20:13:19 <dino-> I have some code I was testing with it. I know of specific edge values that I would always want tested regardless of what my Arbitrary impl picks.
20:13:20 <glguy> I can tell they are on through doors and whatnot, but I don't know how unique this is (my wife can't, so I have two data points)
20:13:59 <Cale> dino-: You might want something like HUnit for tests of that sort.
20:14:06 <drigz> glguy: i think maybe i have listened to too much loud music
20:14:15 <dino-> To get that behavior I used frequency and elements to try to guide it to always statistically pick my guys. Is that a lame solution?
20:14:17 <dibblego> glguy, yes I can, and I also know people who also think it is strange that I can hear it
20:14:31 <dino-> Cale: I see.
20:14:32 <Cale> dino-: Or hmm, I suppose you could just pass your existing quickcheck tests those parameters :)
20:14:37 <Olathe> glguy: I can hear it.
20:14:42 <dcoutts> glguy: yes, I can too.
20:14:54 <glguy> maybe there is a correlation between haskell programming and hearing!
20:15:25 <SamB_XP> I can hear TVs that are on
20:15:29 <dibblego> glguy, clearly, I only discovered Haskell because I could hear it
20:15:35 <dino-> But hacking arbitrary with frequency to get these fixed values seemed dorky to me. :/
20:15:44 <SamB_XP> but sometimes I hear my computer monitor and THINK it is a TV
20:16:19 <SamB_XP> not from a few rooms away exactly, though...
20:17:46 <SamB_XP> generally what happens is someone plays video games, turns off the video game machine, and leaves the TV on because the screen is black and they forgot the TV was still on ;-)
20:18:14 <glguy> I think that the noise is louder when there is no image on the screen
20:18:25 <glguy> or maybe jus tthe lack of audio
20:18:27 <glguy> makes it more noticable
20:18:37 <ddarius> glguy: I can hear it though I don't know how far away I can.
20:20:22 <dino-> Cale: Thank you.
20:21:36 <dons> another good adam turoff post, http://programming.reddit.com/info/2fly0/comments
20:21:37 <lambdabot> Title: Does Syntax Matter? (reddit.com)
20:23:33 <dino-> dons: I've had this talk with people many times of the past 10+ years. It's *exactly* why Java looks like it does and why it became so popular. It was designed to quickly and easily being along all the C++ developers.
20:23:49 <dino-> ^over the past 10..
20:24:08 <mrd> glguy: yes!
20:24:24 <mrd> CRTs anyhow
20:25:17 <dino-> Not his point here. But I think this was a calculated tactic with Java.
20:25:46 <dons> dino-: sure, ruby looks different, python looks different, but people survive. so for some degree i don't think syntax matters
20:26:07 <dons> maybe to be the next mainstream imperative language, you need to look C-ish. that surely helps, but its not crucial
20:26:21 <dibblego> dons, enter Scala
20:26:30 <dons> yeah.
20:26:33 <dgriffi3> glguy: see http://answers.yahoo.com/question/index?qid=20070107084554AAMimP9
20:26:34 <lambdabot> Title: Yahoo! Answers - What frequency is the high pitch buzz from a CRT display?
20:26:36 * SamB struggles to see why one would want to make the next mainstream imperative language
20:26:44 <Korollary> for money
20:26:44 <dibblego> Scala is getting Eternal Septembery lately too
20:26:54 <dons> there is a case for an imperative language with a better type system
20:27:03 <dons> such as scala. that makes sense
20:27:08 <LoganCapaldo> AOL users found scala?
20:27:17 <Tac-Tics> SamB: to sell a million dollars worth of "Core <Your language> Definitive guide to <obscurely named technology>"
20:27:34 <dibblego> LoganCapaldo, so it seems; it also doesn't demand the discipline that Haskell does either
20:28:21 <LoganCapaldo> eh I don't want my programming language to demand discipline, I want it to make discipline on my part unecessary :)
20:28:40 <dibblego> LoganCapaldo, to use Haskell, you have to think
20:28:50 <dibblego> LoganCapaldo, to use Java, you have to know how to press buttons
20:29:35 <SamB> but Haskell aids you in focusing thought
20:30:03 <dibblego> it does, but some people resent having to think
20:30:14 <sorear> dibblego: if you don't think you'll probably wind up with a pile of code that does something nobody wants...
20:30:22 <dino-> I feel like the Haskell syntax is liberating, what he said about { } being a crutch for compilers.
20:30:26 <SamB> sorear: quite
20:30:44 <dino-> Not just that it doesn't matter, but that this far far less noisy syntax has advantages.
20:30:47 <sorear> at least with Haskell your LOC output will match your productivity
20:30:48 <joed> Heh
20:30:57 <mrd> code wears braces like a teenager
20:31:00 <dons> so joel is going to build an erlang runtime?
20:31:09 <dons> sounds ambitious/scary
20:31:17 <sorear> scary, yeah
20:31:31 <dons> and he'll give up half way through, rewrite it in C, and blog about how unsuitable ghc is? :)
20:31:53 <jbalint> runtime of what
20:31:57 <dons> maybe .. maybe .. he could write a subset of erlang interpreter on top of the smp runtime
20:32:08 <dons> but a vm? with bytecode? hmm?
20:32:13 <mrd> whatever happened to gdh
20:32:52 <dons> research funding ran out and ericsson didn't pick it up? :)
20:33:40 <ddarius> dons: At least for him, if he gives up halfway through and successfully rewrites it in C then GHC will have been unsuitable.
20:34:13 <sebell> ddarius: Surely several switches between Haskell and C would have taken place before that point
20:34:18 <dons> so it a learning exercise?
20:34:22 <dons> like scheme in 48 hours?
20:35:16 <ddarius> dons: That's what he claims, albeit I don't think it's like Scheme in 48 hours.
20:35:46 <ddarius> Implement a virtual machine, in Haskell, to understand Erlang...
20:35:56 <ddarius> Erlang innards that is.
20:35:59 <dons> a vm ? or an interpreter?
20:36:23 <dons> there's no erlang bytecode format, afaik. so he must mean an interpreter?
20:36:28 <ddarius> dons: BEAM
20:36:56 <SamB> ddarius: up or down?
20:37:00 <dons> ah! now it gets interesting
20:37:09 <SamB> also, which engineering officer did you want to address?
20:37:25 <SamB> oh, and who did you want beamed?
20:38:07 <dons> ddarius: i think a reference impl makes sense.
20:38:24 <dons> performance might well be quite reasonable, (a la pugs)
20:38:30 <ddarius> dons: There already exist implementations.
20:38:38 <dons> sure :)
20:38:43 <dons> you tell joel that
20:39:19 <dons> "a learn erlang internals by writing a reference impl from the spec in a rigorous language" project seems reasonable, as long as expectations aren't too high
20:40:59 <sorear> people here seem to think Haskell, unlike every other language before it, supports code that is simultaneously very fast and understandable
20:41:49 <SamB> now we just need to figure out how to compile it ;-P
20:42:00 <dons> sorear: understandable and *reasonable* performance
20:42:00 <LoganCapaldo> I thought Haskell was supposed to be slow and inscrutable? :)
20:42:23 <SamB> LoganCapaldo: that's Pythonerl or something
20:43:01 <ddarius> dons: His email pretty clearly states his desires.
20:43:17 <LoganCapaldo> Lisp implemented in Python with an erlang-like syntax?
20:43:36 <ddarius> SamB: What? Perl alone isn't slow and inscrutable enough for you?
20:43:39 <dino-> I programmed in nothing but Java and Perl between 1996 and 2006. Coming from there, Haskell performance has been pretty awesome. :D
20:43:39 <SamB> LoganCapaldo: er. I meant a language as ugly as perl and as slow as python
20:43:44 <glen_quagmire> perl is so cool
20:43:55 <glen_quagmire> perl has some female developers
20:44:42 <dons> ddarius: hmm `I'm also hoping to be at least as
20:44:42 <dons> fast as the existing Erlang VM (written in C) and to be able to
20:44:43 <dons> extend the VM in a functional language'
20:44:45 <Adamant> that's important to glen_quagmire, giggity-giggity
20:44:46 <dino-> BTW, I noticed recently in lang benchmarks that Ruby came in something like 60x slower than C and 3x slower than Perl. I asked co-workers, what did they write the Ruby interpreter in? Perl?
20:44:57 <SamB> I don't think I ever wrote any perl that used algorithms of the appropriate type on large enough datasets to be noticable...
20:44:59 <dons> ddarius: seems ridiculous to expect that kind of performance
20:45:16 <dons> ddarius: esp. `I'm thinking using CPS and building up a chain of closures.'
20:45:17 <SamB> dino-: that would be fantastic if they had
20:45:29 <Nafai> dons: Is this from haskell-cafe or something?
20:45:35 <dons> yeah
20:45:36 <sorear> you won't even get that kind of performance from ghc *.cmm
20:45:36 <sorear> !
20:46:02 <Korollary> extend the VM what?
20:46:05 <dons> you could hope to do a usable reference implementation (like hugs or yhc compared to ghc)
20:46:07 <SamB> sorear: does he know anything about code generators then?
20:46:20 <ddarius> SamB: I did suggest that.
20:46:21 <SamB> dons: ick!
20:46:26 <dons> but to hope to also outperform a mature, heavily tuned runtime. no way
20:46:28 <DukeDave> Hey gang, what do  we call it when we 'open up' a datatype so we can see its constructor?  E.g. (x:xs) or 'Just x'
20:46:32 <ddarius> SamB: Also Harpy was mentioned, but he didn't seem to keen on it.
20:46:39 <sorear> dons: pattern matching
20:46:42 <SamB> ddarius: I wouldn't have been either
20:46:46 <sorear> DukeDave: not dons:
20:46:49 <LoganCapaldo> pattern matching?
20:46:58 <Korollary> I say de-constructing
20:47:04 * LoganCapaldo is slower than sorear
20:47:10 <DukeDave> Hm, I know we are pattern matching but I was looking for something else
20:47:19 <sorear> something tells me Harpy would be very slow for something like a VM
20:47:30 <dino-> Could you also call it binding to those identifiers? x and xs
20:47:31 <sorear> what with the whole run-time assembly thing
20:47:34 <oerjan> DukeDave: deconstruction?
20:47:37 <SamB> sorear: is it the author's blog?
20:47:48 <sorear> SamB: context lost.
20:47:49 <DukeDave> More along the line of Korollary... At first I thought 'unbox' but does that refer to something completely different?
20:47:54 <ddarius> sorear: That was the whole basis of Self.
20:48:01 <Korollary> yes, unboxing means something else
20:48:17 <LoganCapaldo> if you pretend they're church encoded you can call it function application :)
20:48:20 <ddarius> sorear: Obviously you need to amortize the cost.
20:48:23 <DukeDave> Korollary: Okay, thanks for the heads up
20:48:43 <glen_quagmire> VM is so overrated
20:48:45 <sorear> ddarius: They actually called a full assembly system at runtime!?
20:49:05 <ddarius> sorear: Just passes to as?
20:49:12 <ddarius> Harpy that is.
20:49:15 <sorear> ddarius: as is that fast?
20:49:17 <sorear> *faints*
20:49:36 <ddarius> sorear: I figured they wouldn't be that lazy.  Oh well.
20:49:54 <ddarius> We have the tools to solve that though on hackage.
20:50:01 <sorear> ddarius: you're still talking about Self, right/
20:50:23 <ddarius> sorear: No.  I didn't think Harpy called as.
20:51:21 <sorear> ddarius: I didn't think so either
20:51:23 <ddarius> Writing an asm->machine code step isn't all -that- hard.  Mostly tedious.
20:51:32 <sorear> ddarius: I read what you said as "harpy calls as."
20:51:47 <sorear> ddarius: no wait
20:52:07 <sorear> ddarius: I read what you said as "Self uses as and they are that fast, so harpy can't be too slow"
20:52:29 <ddarius> Why?  There was no mention of as until after that.
20:53:55 <sorear> ddarius: you were the first one to mention as
20:54:15 <ddarius> Because that's what I thought you meant by "full assembly system".
21:02:53 <Korollary> Yeah, I think joelr will switch to ocaml and then drop the whole thing eventually
21:04:37 <sorear> Korollary: Don't forget about the part where he blogs about his inabilities
21:05:33 <Cale> What is joelr up to now?
21:05:50 <Korollary> Cale: check haskell-cafe
21:06:27 <conal> anyone using ghc-6.7?
21:06:33 <conal> (ghc HEAD)
21:07:34 <Cale> ah, writing an Erlang VM?
21:10:19 <zka> !rules
21:10:31 <zka> @find dance
21:10:33 <lambdabot> Not in scope: type variable `dance'
21:11:06 <oerjan> @find Int
21:11:08 <lambdabot> *
21:11:14 <oerjan> ah, kind
21:11:16 <Korollary> We should implement that
21:11:33 <Korollary> wtf is @find dance anyway?
21:11:43 <shapr> I dunno, I thought he was looking for game channels.
21:11:52 <sorear> game channels?
21:12:11 <Korollary> bots running trivia games maybe
21:12:12 <shapr> Yeah, there are bunches of irc bot game channels.
21:12:23 <shapr> Or guess the math expression
21:12:28 <shapr> Or factor the number, or whatever
21:12:43 <sorear> And they have 400 people?
21:12:52 <shapr> I don't think that guy was paying much attention.
21:13:03 <shapr> I think he was just randomly joining channels and trying commands that had worked before.
21:14:15 <oerjan> @rules
21:14:15 <lambdabot> Unknown command, try @list
21:14:43 <oerjan> @list bot
21:14:43 <lambdabot> No module "bot" loaded
21:14:48 <oerjan> @list botsnack
21:14:48 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you wiki oldwiki docs source fptools hackage
21:15:07 <oerjan> @help show
21:15:16 <lambdabot> show <foo>. Print "<foo>"
21:15:16 <oerjan> @help read
21:15:16 <lambdabot> read "<foo>". Print <foo>
21:15:57 <oerjan> oh, there's all those commands that should check if web pages exist but don't
21:16:26 <oerjan> actually...
21:16:34 <oerjan> @docs Control.Freak
21:16:35 <lambdabot> Control.Freak not available
21:16:51 <oerjan> some of them do check something
21:18:11 <shapr> You called?
21:18:16 <shapr> Oh, false alarm.
21:18:44 <oerjan> you beep on get-shapr? :)
21:19:25 <shapr> Well.. sort of.
21:21:11 <shapr> Why people should use Haskell in the kernel - "There are no real solutions to the problems Watson has identified unless the system call wrapping technique is abandoned. The two solutions he has suggested are either moving to a "message passing" architecture for system calls or to integrate the security checks into the kernel itself."
21:21:50 <shapr> From http://lwn.net/Articles/245630/ (which is only available if you have an lwn.net subscription)
21:22:01 <Pseudonym> As Stefan Buecher pointed out, "I'm not a control freak, I'm a control enthusiast!"
21:22:32 <Pseudonym> Bucher
21:23:03 <Pseudonym> Well, there are plenty of kernels that do use message passing.
21:23:13 <Pseudonym> Then, you wouldn't need Haskell in the kernel, just the executive.
21:23:43 <jcreigh> What type of kernel does Mac OS X use?
21:23:56 <Pseudonym> A first-generation microkernel IIRC.
21:24:00 <Pseudonym> Mach-era.
21:24:15 <Pseudonym> They can't really be called "micro", IMO.
21:25:14 <jcreigh> hmm...what's the size ratio, then? Maybe decikernels?
21:25:37 <Pseudonym> Mach is about the same size as Linux 1.x.
21:26:04 <Pseudonym> Compare this with QNX or L4, which fit in the L1 cache of a 10-year-old CPU.
21:26:18 <kolmodin> morning!
21:26:22 <jcreigh> oh, QNX was microkernel? I didn't know that.
21:26:32 <Pseudonym> Yeah, it is as of... uh... about 10 years ago.
21:26:36 <Pseudonym> Something like that.
21:26:43 <Pseudonym> The microkernel is called "Neutrino".
21:27:58 <ddarius> "microkernel" has nothing to do with size.
21:28:09 <jcreigh> oh, surely it must have something to do with size.
21:28:21 <ddarius> jcreigh: That's what they'd like to believe.
21:28:48 <monochrom> "neutrino" is a cute name :)
21:28:57 <glguy> what is hurd?
21:29:06 <ddarius> You can easily have a monolithic kernel that is much much smaller than a microkernel.
21:29:11 <ddarius> hurd is supposed to be a microkernel.
21:29:27 <jcreigh> I mean, if a so-called "microkernel" is a big as a monolithic kernel that contains much more services than the microkernel, it seems like something is wrong.
21:29:29 <glguy> does a microkernel have any advantages when used on a multicore cpu?
21:29:33 <Pseudonym> Hurd isn't the kernel, though.  It's the executive.
21:29:40 <glguy> oh
21:29:45 <Pseudonym> People are talking about building Hurd on top of both Mach and L4.
21:30:02 <Pseudonym> Making it somewhat microkernel-independent.
21:30:07 <ddarius> jcreigh: Nope, nothing wrong at all.
21:30:26 <Pseudonym> glguy: The main advantage is that it's easier to do some things.
21:30:32 <Pseudonym> Like making your kernel reentrant.
21:30:34 <ddarius> (Well, if the monolithic contains much more functionality then... I guess)
21:30:53 * ddarius is all for exokernels as many people here know.
21:31:09 <Pseudonym> And if your kernel is based on message-passing, that scales up to multiple CPUs easily.
21:31:32 <kaol> is there any reason to prefer mapAccumL or mapAccumR?
21:31:51 <ddarius> Pseudonym: For CPU = computer mainly, I'd think.
21:32:13 <Pseudonym> Well, yes and no.
21:32:14 <jcreigh> ddarius: yeah, the exokernel idea sounds neat
21:32:43 <Pseudonym> I think the main thing is making the kernel reentrant, though.
21:33:43 <glguy> kaol: the reason are the same as for foldl vs foldr
21:34:21 <kaol> ok, suspected as much
21:36:27 <shapr> I want exokernels.
21:36:37 <oerjan> ERROR: quine is not a "quine"
21:36:38 <shapr> Virtualization is becoming pretty much that anyway, seems to me.
21:36:54 <oerjan> (rwong channel)
21:37:17 <xpika> why do you think there is an isJust function but no isLeft?
21:37:40 <Cale> mapAccumR can work lazily, though if your accumulating parameter is something like an integer, you obviously shouldn't touch the first component of the result
21:37:47 <Tac-Tics> "quine" is a quine for some language x
21:38:06 <Cale> So is the empty string
21:38:11 <glguy> > "quine"
21:38:17 <lambdabot>  "quine"
21:38:22 <Tac-Tics> even in the Quine language where the Quine language has for its evaluation function, the identity function
21:38:32 <glguy> zomg ! ;)
21:39:35 <Pseudonym> > let q x = x ++ show x in q "> let q x = x ++ show x in q "
21:39:37 <lambdabot>  "> let q x = x ++ show x in q \"> let q x = x ++ show x in q \""
21:40:19 <monochrom> It makes Baby Jesus cry when emacs haskell-mode offers 7 indentation points. :)
21:40:32 <Pseudonym> Jesus cares about indentation.
21:40:40 <ddarius> Jesus should care.
21:41:05 <sorear> Pseudonym: How does microkerneling make reentrancy easier?  I'd imagine it's easier to make a reentrant library than server...
21:41:27 <Pseudonym> sorear: A modern microkernel isn't a server.
21:41:39 <Pseudonym> Not really.
21:41:47 <Pseudonym> It's just a message passing/threading system.
21:42:00 <Pseudonym> But... OK, here's an example.
21:42:11 <Pseudonym> Suppose you need interrupts to be delivered during system calls.
21:42:18 <Pseudonym> That's an example of reentrancy.
21:42:28 <Pseudonym> That's hard to do in a monolithic kernel if you're not disciplined.
21:42:33 <sorear> Pseudonym: Well the microkernel proper is certainly a message passing system, but that's for naught if the executive only works in one thread, and that seems harder to fix
21:42:57 <Pseudonym> Sure, but the modern philosophy is to break up the executive into bits.
21:43:18 <sorear> Oh wait, you were talking about reentrancy, not concurrency...
21:43:30 <Pseudonym> Yeah.
21:43:31 * sorear would like a CPS-based kernel
21:43:44 <Pseudonym> Solaris also allows for interrupts to be delivered quickly.
21:43:57 <Pseudonym> Interrupt handlers just enable interrupt handler threads.
21:44:13 <Pseudonym> Which have a higher real-time priority than even user-space real-time tasks.
21:44:34 <Pseudonym> And Solaris isn't a microkernel.
21:44:41 <Pseudonym> So my point is that you don't NEED microkernels for this.
21:44:57 <Pseudonym> But I can imagine that it'd be hard to retro-fit this into an existing monolithic kernel.
21:45:42 <bos> is there some nice arrow-y way of writing \(a,_) (b,_) -> a == b ?
21:45:57 <bos> poor old @pl doesn't know about arrows, which is perhaps just as well.
21:46:04 <ddarius> :t fst***fst >>> uncurry (==)
21:46:07 <lambdabot> forall b b1 a. (Eq a) => ((a, b), (a, b1)) -> Bool
21:46:13 <ddarius> :t curry $ fst***fst >>> uncurry (==)
21:46:14 <sorear> bos: no arrows needed!  equating fst
21:46:15 <lambdabot> forall b b1 a. (Eq a) => (a, b) -> (a, b1) -> Bool
21:46:28 <Pseudonym> ?pl \(a,_) (b,_) -> a == b
21:46:29 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==) . fst
21:46:33 <Pseudonym> Perfect!
21:46:52 <Pseudonym> Actually, this is kind of what you need `over` for
21:46:54 <bos> sorear: equating fst?
21:47:03 <oerjan> :t join (first (==))
21:47:05 <lambdabot>     Couldn't match expected type `(->) (a, d)'
21:47:05 <lambdabot>            against inferred type `(,) (a -> Bool)'
21:47:16 <oerjan> bah
21:47:18 <sorear> bos: Data.Eq.equating Prelude.fst
21:47:19 <glguy> ?type on (==) fst
21:47:21 <lambdabot> Not in scope: `on'
21:47:23 <sorear> bos: it's a term :)
21:47:30 <Pseudonym> Right, on.
21:47:31 <Pseudonym> Not over.
21:47:35 <bos> ah.
21:47:39 <Tac-Tics> Can anyone explain to me how people figured out the exponential function?
21:47:53 <shachaf> @let on f g x y = g x `f` g y
21:47:55 <lambdabot> Defined.
21:48:07 <ddarius> You mean e^x?  It comes out naturally in many ways.
21:48:11 <oerjan> :t join (==)
21:48:13 <lambdabot> forall a. (Eq a) => a -> Bool
21:48:27 <Tac-Tics> I mean, the function f(x) = k^x
21:48:30 <shachaf> Does equating exist? lambdabot doesn't seem to know it.
21:48:38 <olliej> ?pl \f g x y -> g x `f` g y
21:48:38 <lambdabot> join . ((flip . ((.) .)) .) . (.)
21:48:42 <Tac-Tics> I understand how 'e' eventually came along from exponents
21:48:43 <monochrom> Is math derived or inflicted?
21:48:55 <ddarius> k^x = e^(xlnk)
21:49:00 <Tac-Tics> but who came up with the idea of a continuous exponential function
21:49:15 <Tac-Tics> or did 'e' come first?
21:50:03 <ddarius> I imagine e^x came before handling irrational exponents
21:50:11 <bos> is "on" predefined somewhere?  i've seen it before, but don't recall where.
21:50:20 <ddarius> bos: it will be.
21:50:25 <sorear> bos: Data.Function (in 6.7.x)
21:50:40 <Tac-Tics> I mean, one can visualize fractional addition by cutting blocks into pieces. And similarly with fractional multiplication. You just use water or some liquid to act as a square unit
21:50:46 <oerjan> e is Euler's constant, you should ask him except he's dead
21:50:47 <bos> thanks.
21:51:17 <Tac-Tics> oerjan: I tried, but his zombie lectures were hard to follow
21:51:31 <dibblego> ?users
21:51:31 <lambdabot> Maximum users seen in #haskell: 385, currently: 341 (88.6%), active: 17 (5.0%)
21:51:43 <ddarius> @flush
21:51:43 <lambdabot> Not enough privileges
21:51:44 * shapr gives in to sleep
21:51:58 <sorear> @flush
21:52:13 <dibblego> ?where yaht
21:52:13 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:52:21 <dibblego> Zenethian, start there ^ and feel free to ask questions
21:52:23 <sorear> dons: why is @flush privledged?  it shouldn't be able to break anything
21:52:25 <Zenethian> Thanks  =)
21:52:29 <dons> sorear: no idea.
21:52:29 <dibblego> np
21:52:31 <dons> ?uptime
21:52:32 <lambdabot> uptime: 9d 17h 24m 15s, longest uptime: 1m 10d 23h 44m 29s
21:52:36 <Tac-Tics> I need to learn more about the history of exponents
21:52:43 <Tac-Tics> they never teach you how cool they are in school
21:52:55 <dibblego> s/how cool they are//
21:53:08 <ddarius> e^(xi)
21:53:08 <ohub> :D
21:53:16 <dons> i'll try to restore the karma state now
21:53:18 <sorear> @remember Tac-Tics oerjan: I tried, but his zombie lectures were hard to follow
21:53:19 <lambdabot> Done.
21:54:07 <Pseudonym> I have a suspicion that the idea came around the same time as logarithms.
21:54:22 <Pseudonym> Which would make a certain amount of sense.
21:54:47 <kaol> logarithms came first
21:54:58 <ddarius> @google Napier logarithm
21:55:00 <lambdabot> http://www.ualr.edu/lasmoller/napier.html
21:55:00 <lambdabot> Title: John Napier and logarithms
21:55:28 <dons> ?seen lambdabot
21:55:28 <lambdabot> Yes, I'm here. I'm in #scala, #gentoo-uy, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell,
21:55:28 <lambdabot> #ghc and #darcs
21:55:28 <monochrom> Here is one way exp(x) pops up, not the only way but strongly motivating. I have a bank account and it offers "10% annual compound interest, how often it is compounded is negotiable". So this leaves open one parameter. I could request to do it once a year, then next year I get (1 + 0.1)^1. Or I could request once a month, then next year I get (1 + 0.1/12)^12. Or I could request once a day, then next year I get (1 + 0.1/365)^3
21:55:28 <monochrom> 65. Or I could request once every minute...  The higher the frequency, the more money I gain. In the limit, (1 + 0.1/n)^n tends to exp(0.1).
21:55:28 <Pseudonym> Napier called them "antilogarithms", didn't he?
21:55:45 <Cale> Tac-Tics: I highly recommend reading Spivak's "Calculus"
21:55:55 <Tac-Tics> cool
21:56:07 <Cale> Tac-Tics: It has a rather good presentation on that. It provides a plausible history, even if it's not the real one :)
21:56:43 <Tac-Tics> Mathematics talks about plausible truths in much the same manner
21:57:43 <dons> @flush
21:57:46 <dons> @quit back soon
21:58:01 <shachaf> @forget!
21:58:19 <Cale> Sometimes the history reformed by hindsight can be more pleasant than the actual path which was cut through the bush. (Though all too often, people pave roads that destroy many of the flowers and scenery along the way.)
21:58:28 <reltuk> Spivak is a stud
21:58:38 <Cale> In this case, I think it's rather good. :)
21:59:01 <Tac-Tics> sometimes the flowers get in the way of a perfectly good road
21:59:21 <monochrom> I actually learned that not from banking but from computer graphics. There is 20 inch fog and you want to calculate how much it blocks light. You could consider the whole fog to be one unit, (1-r)^1, or 12 slices, (1-r/12)^12, or 365 slices, (1-r/365)^365, ...
21:59:59 <monochrom> But real fog is continuous, so you take infinitely many slices, exp(-r).
22:00:27 <dons> ?uptime
22:00:27 <Pseudonym> My favourite origin for exp is that exp is the only solution to the system:
22:00:33 <lambdabot> uptime: 11s, longest uptime: 1m 10d 23h 44m 29s
22:00:35 <Pseudonym> d(exp t)/dx = exp t
22:00:37 <Pseudonym> exp 0 = 1
22:00:38 <dons> ?users
22:00:47 <shachaf> @help forget
22:00:47 <lambdabot> Maximum users seen in #haskell: 385, currently: 339 (88.1%), active: 3 (0.9%)
22:00:53 <lambdabot> forget nick quote.  Delete a quote
22:00:54 <dons> ?karma dcoutts
22:00:59 <lambdabot> dcoutts has a karma of 41
22:01:03 <dons> ?karma dons
22:01:09 <lambdabot> You have a karma of 121
22:01:10 <dons> mwhahaha
22:01:16 <olliej> dons is a winner!
22:01:36 <monochrom> How could you get that much? Just a month ago you had 0.
22:01:38 <dons> ?seen lambdabot
22:01:38 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #ghc and #darcs
22:01:41 <monochrom> ?karma monochrom
22:01:41 <lambdabot> You have a karma of 16
22:01:42 <shachaf> dons: Did you add the new karma to the old, or just overwrite it?
22:01:43 <shachaf> @karma
22:01:44 <lambdabot> You have a karma of 0
22:01:48 <sorear> @karma
22:01:48 <lambdabot> You have a karma of 22
22:01:51 <sorear> aww
22:01:52 <shachaf> Overwrite it, I guess.
22:01:53 <dons> shachaf: just darcs reverted to the last recorded state
22:01:55 <monochrom> OK nevermind.
22:01:55 <Pseudonym> ?karma
22:01:55 <lambdabot> You have a karma of 9
22:01:57 <sorear> mine used to be 40+
22:01:59 <Pseudonym> 9?!
22:02:01 <dons> yeah, mine was 150 or so
22:02:09 <oerjan> @karma
22:02:09 <lambdabot> You have a karma of 0
22:02:12 <dons> so this is from a few months back, but its something
22:02:12 <sorear> ?karma autrijus
22:02:12 <lambdabot> autrijus has a karma of 6
22:02:17 <sorear> ?karma audreyt
22:02:17 <lambdabot> audreyt has a karma of 111
22:02:25 <dons> before the 600 point perl bot
22:02:31 <dons> ?karma-all
22:02:31 <lambdabot>  "dons"                121
22:02:31 <lambdabot>  "audreyt"             111
22:02:31 <lambdabot>  "fglock"               57
22:02:31 <lambdabot>  "glguy"                47
22:02:31 <lambdabot>  "lambdabot"            42
22:02:33 <lambdabot> [686 @more lines]
22:02:38 <dons> but after hpaste was born
22:02:39 <Pseudonym> ?more
22:02:39 <lambdabot>  "dcoutts"              41
22:02:39 <lambdabot>  "Cale"                 40
22:02:39 <lambdabot>  "putter"               40
22:02:41 <lambdabot>  "sjanssen"             38
22:02:43 <lambdabot>  "shapr"                37
22:02:45 <lambdabot> [681 @more lines]
22:02:54 <Tac-Tics> I think my favorite definition of the exponential function is the smallest value for x where when a computable function f is O(x) where it starts to not matter that it is in fact computable.
22:03:13 <Pseudonym> I dispute that.
22:03:23 <Pseudonym> O(n^12) algorithms are pretty useless.
22:03:38 <samreid> and O(2^n) too
22:03:43 <dons> Pseudonym: did you see our benchmarks yesterday for the lookup functions?
22:03:44 <Tac-Tics> but not as useless as O(e^n) =-)
22:03:48 <dons> sorear: oh! i should also test HashTable.
22:03:57 <Tac-Tics> samreid: heh
22:04:14 <Pseudonym> e^n is certainly not some crossover point.
22:04:36 * sorear finds it interesting just how many O(n^12) functions there are
22:04:46 <monochrom> how many?
22:04:59 <Pseudonym> An infinite number!
22:05:02 <Pseudonym> Not all of them useful.
22:05:05 <oerjan> sorear: that deterministic prime checking algorithm was O(n^12), i think
22:05:10 <sorear> well, at least two useful
22:05:20 <Pseudonym> It's O(n^12) assuming the Sophie Germain conjecture is false.
22:05:27 <sorear> the primes and one I forgot (but I think it had something to do with unification)
22:05:38 <Pseudonym> But yeah, that's why I picked n^12.
22:06:45 <Pseudonym> dons: Sorry, which benchmarks?
22:07:12 <hpaste>  Bewsawoas pasted "12v deep cycle battery" at http://hpaste.org/2271
22:07:23 <Tac-Tics> ah! Slide rules
22:07:28 <Tac-Tics> I forgotsed about them
22:07:40 <Tac-Tics> they are probably the answer to my question
22:07:43 <oerjan> Pseudonym: actually it is O(n^6) if that is true, at most O(n^12) anyways
22:07:47 * Pseudonym carries a slide rule and a soroban in his laptop bag
22:07:56 <Pseudonym> Ah, yes, good point.
22:07:59 <Tac-Tics> heh
22:08:25 <Tac-Tics> If I could carry any kind of calculator in my pocket, it would be python and haskell on a pda or something
22:08:52 <monochrom> I would put haskell in my cell phone
22:08:53 <samreid> I'd take an RPN with Factor over that.
22:09:36 <monochrom> I hope my cell phone will not explode for that :)
22:10:54 <samreid> it'll implode
22:12:17 <Tac-Tics> maybe someone will invent the NTM someday
22:12:39 <samreid> and port Quake to it
22:12:44 <Tac-Tics> awesome!
22:13:28 <Tac-Tics> Multikill, death, suicide, and disconnect all at once!
22:13:30 <Pseudonym> Nano Transactional Memory?
22:13:38 <Tac-Tics> Nondeterminitstic Turing Machine
22:14:00 <Tac-Tics> That'd be so much cooler than the perpetual motion engine
22:14:45 <samreid> I'd be impressived by any turing machine
22:15:07 <Tac-Tics> When I took my theory of computation, I came up with the greatest child's toy ever
22:15:10 <Tac-Tics> My First Turing Machine
22:15:17 <Tac-Tics> it would be a plastic turing machine
22:15:23 <Tac-Tics> that actually performed calculations
22:15:57 <samreid> You could give them away.  Make money on the tape.
22:16:19 <Vq^> Tac-Tics: thats a really cool idea
22:16:25 <Tac-Tics> samreid: would you be interested in a business partnership with this undertaking?
22:16:27 <Tac-Tics> hehe, thanks
22:16:57 <samreid> Tac-Tics: If my investment and effort is 0% with 51% ownership, yeah.
22:17:02 <sorear> Unfortunately, if you attempt to build a turing machine, you'll have problems with tape storage.
22:17:24 <Tac-Tics> We also had a professor who spoke Chinese as his primary language. He mistyped "Pumping lemma" as "pumping lamma" and the entire semester, we just drew pictures of llamas with dumbbells on our homework
22:17:30 <sorear> It MUST be taut, since only O(n) grams of matter can fit in an n-meter ball of space without black hole problems.
22:17:52 <Tac-Tics> sorear: you need to think more modularly
22:17:54 <Tac-Tics> Turing was a food
22:17:57 <Tac-Tics> fool*
22:18:02 <Tac-Tics> infinitely long tape, I mean really
22:18:14 <samreid> Instead of "my first turing machine", just give them a deck of cards and tell them to invent sorting algorithms
22:18:15 <Tac-Tics> any computer with finite memory can do the same thing
22:18:16 <sorear> @remember Tac-Tics We also had a professor who spoke Chinese as his primary language. He mistyped "Pumping lemma" as "pumping lamma" and the entire semester, we just drew pictures of llamas with dumbbells on our homework
22:18:16 <lambdabot> Done.
22:18:35 <Tac-Tics> but you need to be able to demand memory from an external source
22:18:57 <olsner> sorear: isn't that O(n^3)?
22:21:09 <sorear> olsner: You'd think, but Schwartzchild'
22:21:59 <sorear> s formula gives a critical radius of KM, for some K a rational expression in œÄ, G, and c
22:22:47 <dons> sorear, sjanssen, bos, Pseudonym : more lookup times for different data types
22:22:49 <dons> http://www.cse.unsw.edu.au/~dons/data/graph.png
22:23:16 <dons> includes [Bool], Map Int Bool, IntSet Bool, HashTable Int Bool, Seq Bool, STUArray Bool (:)
22:23:23 <dons> note HashTable sucks
22:23:27 <sjanssen> dons: what's the test?
22:23:33 <dons> lookup last element
22:23:33 <sorear> dons: how do you accomplish this feat of negative times?
22:23:56 <dons> sorear: oh, they're all 0.00s lookup, so i scaled them to help distinguish
22:24:26 <dons> basically, lookup costs effectively nothing, but there are interesting limits on how big these things can be built
22:24:36 <dons> clearly STUArray Int Bool is going to be fastest, and biggest
22:24:46 <dons> it goes much higher in fact, so much so you can't see the other types
22:25:05 <dons> and hashtable sucks so bad it should be abandoned :)
22:25:21 <sjanssen> the lines stop when there's not enough memory?
22:25:27 <dons> yeah, it goes till memory runs out
22:25:31 <dons> i just keep doubling 'n'
22:25:53 <dons> i got to 536,870,912 elements for STUArray Int Bool
22:25:57 <sjanssen> fingertree does really well with space, I'm impressed
22:25:59 <dons> not shown
22:26:00 <dons> yeah
22:26:03 <sorear> dons: I'd recommend having a plainly-visible gradation, and using two charts
22:26:31 <dons> sorear: oh, i think we could do all sorts of things. this is really 'maximum size' for these int-keyed types
22:26:32 <sorear> dons: one chart low scale for showing [] vs everything else, the other much higher scaling
22:27:45 <dons> anyway, there seems to be a real lack of empirical data on stress testing core data types
22:27:49 <dons> which is odd, and leads to confusion
22:27:58 <dons> i suspect we should never use HashTable, for example.
22:28:08 <scodil> or maybe make it better?
22:28:14 <Pseudonym> Hashtables are a poorly-understood data structure;
22:28:17 <dons> or make it better, and move it to its own package
22:28:29 <Pseudonym> They're like naive ray tracers.  It's easy to get something that looks cool with little effort.
22:28:37 <Pseudonym> But you'd want to think really hard about using one in anger.
22:28:42 <sjanssen> dons: where's the code for the benchmark?
22:28:46 <dons> sjanssen: let me post it
22:29:43 <hpaste>  dons pasted "simple lookup benchmark" at http://hpaste.org/2272
22:29:48 <dons> anyone think i should drop it by -cafe@ ?
22:29:59 <dons> i'm not really prepared to put more work into better numbers
22:30:12 <dons> but if someone else is, perhaps they could come up with some recommendatoins for the libraries@ list
22:31:09 <dons> i love STUArray * Bool
22:31:31 <scodil> is it still 1 bit per element? I thought it got changed back to 1 byte?
22:31:46 <dons> nope :) 1 bit.
22:31:53 <dons> the shootout changed one to require 1 byte minimum
22:32:08 <sorear> dons: your comment about "scaling them to distinguish" should probably be rephrased, it sounds like "I fudged the numbers"
22:32:10 <scodil> what shootout benchmark is that?
22:32:25 <dons> sorear: i shifted the lines up and down so you could see the end points
22:32:29 <scodil> and how do they deal with gcc's stl vector<bool>?
22:32:33 <dons> they're all 0.000s lookup
22:32:41 <dons> scodil: they also prevent that
22:32:48 <Cale> dons: what if you do 10000 lookups?
22:32:50 <scodil> layyyymmme
22:33:34 <scodil> the shootout is going to restrict itself into irrelevance
22:33:56 <Cale> scodil: I think so too
22:34:16 <sorear> Why does anyone here still care?
22:34:33 <scodil> why does anyone feed trolls?
22:34:54 <Cale> scodil: I really think we need a free for all shootout where if your program is correct, then your program is accepted, regardless of what techniques it uses.
22:35:20 <dons> spoj is like that
22:35:23 <sorear> Cale: it exists but doesn't have any popularity to speak of
22:35:23 <dons> but they hide the code
22:35:30 <sorear> @google computer language shootin
22:35:32 <lambdabot> http://shootin.sourceforge.net/
22:35:32 <lambdabot> Title: The shootin
22:35:35 <dons> you need to see the code for the tricks as well
22:38:52 <Cale> dons: yes
22:40:12 <sjanssen> and SPOJ is more about personal achievement than language demonstration
22:42:18 <monochrom> If I criticise the shootout in front of you, I'm just preaching to the choir. Instead, I think I should just convince some hacktivist to pull a plank on it.
22:43:18 <dblhelix> morning #haskell
22:44:05 <Korollary> nobody cares about the shootout
23:26:51 <blackdog> ping?
23:27:29 <sebell> !!!!! 5/5 received
23:29:11 <Cale> pong
23:29:20 <glguy> nothing quite like bribing your puppy to love you with treats
23:29:34 <blackdog> ok, cool. i'm not quite so terribly alone as i feared.
23:30:00 <Cale> We've all been sitting here staring at the joins and quits for an hour ;)
23:30:09 <glguy> #haskell can be a scary place at night
23:30:30 <shachaf> glguy: It's not night everywhere! :-)
23:32:20 <sebell> M-x display-time... it's night here.
23:32:22 <glguy> it is in glguy universal coordinated time
23:33:16 * shachaf is in glguy time (I think).
23:33:23 <shachaf> glguy: You're in PDT, right?
23:33:24 <glguy> @localtime shachaf
23:33:27 <lambdabot> Local time for shachaf is Thu Aug 16 02:32:41 2007
23:33:28 <glguy> @localtime glguy
23:33:31 <lambdabot> Local time for glguy is Wed Aug 15 23:32:45 2007
23:33:32 <shachaf> glguy: That won't work.
23:33:42 <shachaf> glguy: My IRC client is three time zones away. :-)
23:33:47 <glguy> heh
23:35:11 <glguy> my puppy knows a very specific whistle I make (alternates between high and low pretty quickly)
23:35:19 <glguy> which means my wife can't use it to call him :)
23:35:57 <glguy> but its pretty distinct so it works well when we are around other dogs at a dog park, and the other owners whistle for their pets
23:54:23 <glguy> http://rss.slashdot.org/~r/Slashdot/slashdot/~3/144611681/article.pl
23:54:26 <lambdabot> Title: Slashdot | Bad Movie Physics Hurt Scientific Understanding, http://tinyurl.com/2tpb3g
23:54:37 <glguy> What?! the bus in "Speed" couldn't have cleared that freeway gap??
23:58:52 <Korollary> of all things to complain about
