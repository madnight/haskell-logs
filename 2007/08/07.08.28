00:00:24 <dons> well, bos is writing some of it, I think ;)
00:00:29 <dons> hmm, is it the 13th or so?
00:00:34 <mudge> yea
00:00:57 <dons> hmm, interesting. i'm moving to the US on saturday, so hmm, i'llbe on the right coast at least.
00:01:08 <mudge> yea
00:01:37 <Adamant> dons, are you doing post-doc in the U.S. or something?
00:01:53 <dons> so its possible. I don't think i can confirm till I'm over there and know what's happening
00:01:57 <dcoutts> dons: I'm moving on Saturday too, though only from one side of Oxford to the other :-)
00:02:02 <dons> Adamant: got a job hacking haskell in Portland.
00:02:07 <dons> dcoutts: :)
00:02:08 <dcoutts> dons: good luck with your move
00:02:08 <Adamant> awesome!
00:02:21 <Adamant> have fun!
00:02:24 <dons> thanks dcoutts . cleared out my uni desk today.
00:02:32 <dons> you can accumulate a lot of CS papers in 5 years
00:02:35 <mudge> dons: okay, it would be great if could come
00:02:39 <dcoutts> dons: getting tearful ? :-)
00:02:44 <mudge> you could come
00:02:47 <dons> mudge: yeah, i'm on the mailing list. so it might well be possible.
00:03:05 <dons> dcoutts: a little. sydney is nice :)
00:03:06 <dons> ?temp
00:03:07 <lambdabot>   now 26.2°, min 12.3°, max 27.8°, rain 0.0mm, wind 26km/h NW
00:03:08 <dcoutts> dons: don't you find moving such a pain, it makes one realise how much useless junk one accumulates
00:03:21 <dons> oh so much junk!
00:03:21 <dcoutts> I find I just want to throw it all out
00:03:43 <dons> i really didn't need to keep that little bag of screws and nuts for 5 years. whta was I thinking?
00:03:52 <dcoutts> aye :-)
00:04:07 <dons> and oh, maybe i need that null modem cable from the mac68k? yeah, better hang on to that.
00:04:16 <monochrom> hehehe
00:04:17 <dons> this is what it is like :)
00:04:25 <dcoutts> I've got a box of computer bits my gf calls "The Box of Doom"
00:04:47 <dons> luckily, we have a firm limit on how much stuff we can take.
00:04:48 <dons> hehe.
00:04:58 <mudge> bos:  oh you're Bryan O'Sullivan!   I was just reading your blog tonight!  it's great!
00:04:58 <dons> i have such a box!
00:05:00 <dons> it is known by suzie as the "evil cable box"
00:05:06 <dcoutts> right! :-)
00:05:35 <dolio> Who doesn't have boxes like that? :)
00:05:42 <dons> you never know when a debian 1.0 install disk will come in handy, that's my motto!
00:05:51 <dcoutts> :-)
00:06:00 <dcoutts> I've got a 21" monitor I need to get rid of
00:06:00 <dons> though i've decided i don't need floppies anymore.
00:06:08 <dons> oh, wow.
00:06:10 <dcoutts> it weighs about half a ton
00:06:12 <mudge> bos: you there?
00:06:13 <dons> i'm sure someone will want that.
00:06:21 <bos> yup
00:06:21 <dons> ah, a big one eh.
00:06:28 <bos> mudge: thanks :-)
00:06:36 <monochrom> It is also likely curved.
00:06:40 <dcoutts> dons: I've been trying to give it away, nobody want's heavy crts anymore
00:06:43 <dons> yeah
00:06:56 <dcoutts> nobody has a desk big enough to hold it
00:07:25 <monochrom> I was one of the early adopters of those flat CRTs. I have thus almost forgotten that screens used to be curved.
00:07:35 <dcoutts> in fact I'm planning on replacing my desk with a smaller one when we move, since I don't need it to be so deep anymore now I have a flat screen
00:08:05 <dcoutts> monochrom: yeah, it's also slightly curved, but given the depth of the thing, it's not very curved
00:08:16 <dcoutts> it's probably half a meter deep
00:08:24 <dhpeterson> dons: good luck. i had a sony 21" that i couldn't give away, and that was over a year ago
00:08:44 <dfrey> Is there any sort of repository of Haskell sample code?  I was hoping to find some examples using Data.Map
00:09:10 <dhpeterson> dons: maybe drop it off at the uni for some ugrad to use :)
00:11:03 <dcoutts> dfranke: there's >100 packages on hackage
00:11:16 <dcoutts> dfeuer: and google code search should find stuff
00:13:24 <dcoutts> morning therp
00:13:39 <therp> good morning
00:14:44 <therp> dcoutts: how would you suggest that I install libdir as in libDirTemplate, not with libSubDirTemplate concatinated? should I add another libsubdir element to InstallDirs and change all references to this?
00:15:37 <dcoutts> therp: the final libdir is made up of substitute libdirtemplate </> substitute libsubdirtemplate
00:15:51 <dcoutts> therp: so if you don't want any libSubDirTemplate then set it to be empty
00:17:19 <dcoutts> therp: or perhaps I don't understand what you're trying to do
00:17:43 <therp> dcoutts: I'm trying to hand something like /usr/lib to installLib from Install.hs/install to GHC.installLib
00:18:16 <dcoutts> therp: why not passing the full libdir ?
00:19:40 <therp> the expansion takes place at the start of install in Install.hs, so are you suggesting I should call absoluteInstallDirs twice, once with a modified lbi { installDirTemplates = installDirTemplates lbi { libSubDirTemplate = PathTemplate [] } }
00:19:59 <therp> dcoutts: because I'm installing shared libraries, that should go into the default system's libdir
00:20:22 <therp> and passing the full libdir is "too deep" /usr/lib/ghc-6.6/.../
00:20:33 <dcoutts> therp: ah, then perhaps we do need a different libdir completely
00:20:57 <therp> dcoutts: that's what my first idea was.. change the semantic of libdir and switch all instances over to a new libsubdir
00:21:44 <dcoutts> therp: yes
00:21:56 <dcoutts> therp: so, hmm the best thing to do...
00:23:13 <dcoutts> therp: so yeah, we probably want a new component in InstallDirs for static libs
00:23:46 <therp> is libsubdir a good name?
00:24:14 <dcoutts> therp: no, I think all the InstallDirs should be full paths, not relative to other ones
00:24:46 <dcoutts> therp: so I'd say we change the existing libdir to come from just libDirTemplate
00:25:06 <alogia> I am probably missing something simple here, but is it possible to propagate an error from an Either function through an ErrorT function?
00:25:15 <dcoutts> therp: and add a new one staticlibdir or something that is from libDirTemplate </> libSubdirTemplate
00:25:16 <therp> dcoutts: I meant libsubdir to be a full path
00:25:44 <dcoutts> therp: subdir isn't a good name, it's confusing since we use subdir to mean relative elsewhere
00:26:47 <christine_c> hello people
00:27:47 <christine_c> what are other interesting applications of fuzzy logic aside from that control?
00:27:52 <dcoutts> therp: in fact we might want dynlibdir and staticlibdir and not have a libdir at all in InstallDirs
00:28:18 <dcoutts> therp: that'd make it easier to find the places that need to change rather than reusing the libdir name with a different meaning
00:30:34 <therp> dcoutts: so the plan is, I will change libdir into staticlibdir and add dynlibdir
00:30:45 <dcoutts> therp: yes
00:31:00 <therp> what's the "meaning" of libexec, btw?
00:31:19 <dcoutts> therp: it's not really used much, it's supposed to be for private binaries rather than user binaries
00:41:02 <therp> dcoutts: staticlibdir also includes interfaces definition files and package.conf. Is this really a good name?
00:41:11 <dcoutts> hmm
00:41:25 <dcoutts> therp: yeah, maybe not
00:41:35 <dcoutts> therp: ok well just add dynlibdir
00:41:57 <therp> and keep libdir?
00:42:00 <dcoutts> aye
00:42:13 <therp> ok, reverting..
01:27:27 <RogerTaylor> dcoutts_: Thanks, a pull from the Cabal darcs seems to have fixed that problem.
01:27:47 <RogerTaylor> the problem with HSQL/PostgreSQL
01:28:36 <dcoutts> RogerTaylor: great
01:31:09 <roconnor> Anyone else feel that the weighted slope one code can be simplified?
01:39:37 <Ian_P> hi all
01:41:02 <Ian_P> did anyone read the paper "compiling Embedded Languages", Conal Elliot with others ?
01:55:33 <ari> @bot
01:55:33 <lambdabot> :)
01:55:49 <lambdabot42> :)
01:56:20 <sieni> > in stereo
01:56:20 <lambdabot>  Parse error
01:56:25 <lambdabot42>  Parse error
01:56:27 <sieni> > "in stereo"
01:56:28 <lambdabot42>      Bad interface file: L.hi
01:56:28 <lambdabot>  "in stereo"
01:56:29 <lambdabot42>         mismatched interface file versions: exp...
01:57:10 <sieni> > putStrLn "> \"bar\""
01:57:11 <lambdabot42>      Bad interface file: L.hi
01:57:11 <lambdabot42>         mismatched interface file versions: exp...
01:57:12 <lambdabot>  <IO ()>
01:57:16 <sieni> :-(
02:00:37 <mux> oups, it shouldn't have come in here, sorry
02:03:54 <earthy> ?
02:05:03 <mux> (lambdabot42)
02:05:24 <mux> I didn't mean to have it join this channel, just had a badly merged online.rc file :-)
02:07:21 <oklopol> > o
02:07:22 <lambdabot>   Not in scope: `o'
02:07:29 <oklopol> > let o=0
02:07:29 <lambdabot>  Parse error
02:07:34 <oklopol> eh uh :P
02:08:01 <xerox> oklopol: let <bindings> in <expression> is an expression
02:08:20 <oklopol> but... let <var>=<val> works in my haskell!
02:08:45 <kosmikus> it works in ghci, but that's a feature of the interpreter, not of Haskell
02:08:53 <oklopol> i see
02:08:57 <xerox> It works in your interpreter, because it basically simulates a 'do' block, where 'let <bindings>' is an acceptable statement.
02:09:09 <oklopol> ah
02:09:22 <xerox> do let bindings; ... gets translated to let <bindings> in do ...
02:09:45 <xerox> do x <- amb; ... in amb >>= \x -> do ...
02:09:54 <xerox> do amb; ... in amb >> do ...
02:10:04 <xerox> ...and finally do amb = amb.
02:10:56 <xerox> lambdabot also does that, via ?let
02:11:23 <xerox> ?let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
02:11:25 <lambdabot> Defined.
02:11:30 <xerox> ? fibs
02:11:33 <xerox> > fibs
02:11:35 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:16:42 <dcoutts> so what does this mean in an export list: (:!:)((:!:)),
02:16:43 <dcoutts> 1 peanut for the first correct answer.
02:17:39 <dcoutts> hmm, or to get one more level of brackets, import Foo ((:!:)((:!:)))
02:18:16 <dolio> (:!:) is the type constructor with value constructor (:!:), which goes in extra parens to be associated with the type?
02:18:28 <dcoutts> yep
02:18:31 <xerox> dcoutts: it tycon together with datacon
02:18:38 <dcoutts> dolio wins one peanut
02:18:40 <xerox> it exports
02:18:44 <dolio> Woo!
02:18:46 <xerox> aw.
02:18:46 <dolio> @yow
02:18:47 <lambdabot> I'm dressing up in an ill-fitting IVY-LEAGUE SUIT!!  Too late...
02:19:34 <dcoutts> it's the infix equivalent of data Foo = Bar | Baz and exporting Foo(Bar, Baz)
02:19:57 <dcoutts> but where both the type name and constructor are infix operators/names
02:26:57 <dhpeterson> > fibs !! 10
02:26:58 <lambdabot>  55
02:27:02 <dhpeterson> heh
02:27:11 <dhpeterson> lambdabot memory better than mine ;)
02:56:15 * osfameron whines about random numbers on http://osfameron.vox.com/
02:57:01 <JohnMeacham_> ping
03:04:03 <roconnor> osfameron: you can probably pick a random element in one pass.
03:04:45 <roconnor> with circular programming.
03:05:38 <osfameron> roconnor: the second version does only do one pass
03:05:44 <osfameron> what's circular programming?
03:06:09 <roconnor> http://haskell.org/haskellwiki/Circular_programming
03:06:10 <lambdabot> Title: Circular programming - HaskellWiki
03:06:19 <roconnor> Actually I'm very curious if this will work.
03:06:25 <roconnor> I give it 50/50 chance
03:06:32 * roconnor tries it out
03:08:57 <osfameron> oh, I think I get the idea - but I'm not sure that indexing into a list works for that?
03:09:13 <osfameron> it looks like it applies the aggregate function to every element in the list
03:09:51 <roconnor> osfameron: the idea would be to merge the picking and the computation of the list length into one recursive function.
03:10:14 <osfameron> yes, well my second algorithm sort of does that
03:10:20 <osfameron> though not in the same way
03:10:50 <mux> heh this paper has an awesome title 'Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire"
03:11:20 <ricky_clarkson> From the department of crap analogies?
03:11:34 <dolio> osfameron: Use mapM, not map.
03:12:06 <LeCamarade> Is there a listof _all*_ the optimisations GHC 6 performs?
03:12:15 <LeCamarade> * let all = nearly all
03:12:41 <osfameron> dolio: ah!
03:14:56 <osfameron> dolio: wooo! shiny
03:15:56 <Cale> mux: Yeah, that's a classic :)
03:16:41 <dolio> osfameron: Actually, since you're not using the list anyway, you could do: 'replicateM 5 (pick [1..5])'
03:18:06 <roconnor> osfameron: I tried my solution but GHCi just hangs :(
03:18:13 <roconnor> not even a loop exeception
03:18:44 <osfameron> dolio: ah ok, I couldn't remember the syntax to make a function call X times
03:19:08 <roconnor> > let pickH (_,[]) = (undefined,0); pickH (0,(x:xs)) = (x,(length xs)); pickH (n,_:xs) = let (a,b)=pickH (n-1,xs) in (a,b+1) in let pickR l = let (a,b)=pickH (b`div`2,l) in a in pickR [1,2,3,4,5]
03:19:08 <osfameron> I wouldn't have thought of replicateM as it appears to be in Control.Monad
03:19:09 <lambdabot>  Exception: <<loop>>
03:19:36 <ricky_clarkson> osfameron: What would be the point of calling a function X times with the same inputs?
03:20:10 <osfameron> ricky_clarkson: well, maybe that's why I didn't remember it...
03:20:19 <osfameron> but for random numbers it makes a bit of sense
03:20:52 <ricky_clarkson> You mean for the side effects?
03:21:30 <roconnor> osfameron: are you sure your algorithm picks numbers uniformly?
03:21:36 <osfameron> ricky_clarkson: yes
03:21:46 <osfameron> roconnor: if I implemented it correctly :-)
03:21:59 <osfameron> I read the algorithm described, I think it does indeed work
03:22:01 <roconnor> osfameron: what happens when you pass it [1..] ?
03:22:04 <osfameron> try it for the first few numbers
03:22:13 <Cale> osfameron: Random numbers either have to be in IO (or another smaller monad) or else require you to thread along the generator state explicitly
03:22:54 <osfameron> roconnor: then it will pick one of the infinite list. But might take a bit of time
03:23:41 <ricky_clarkson> osfameron: If you're looking at functions with side effects, in Haskell you should look at monads instead.
03:23:43 <roconnor> osfameron: It should never terminate if the choice is uniform.
03:24:06 <roconnor> osfameron: ah, okay
03:24:06 <osfameron> Cale: ok, I've sort of understood that much but I don't know how to work with them very well (hence the whining on blog :-)
03:24:12 <roconnor> osfameron: now I belive it works.
03:24:29 <osfameron> roconnor: yeah, I was being facetious, it won't terminate for [1..]
03:25:00 <roconnor> osfameron: okay.   I thought for a moment it did terminate.
03:25:15 <roconnor> osfameron: but I now see that it doesn't.
03:25:16 <osfameron> ricky_clarkson: what do you mean?  I'm callng the library supplied getRandom function, which is indeed using Monads.
03:25:19 <roconnor> which is good :)
03:25:23 <osfameron> ;-)
03:26:16 <roconnor> osfameron: ah, i think my circular programming solution won't work.
03:26:17 <Cale> osfameron: which library?
03:26:22 <roconnor> ;(
03:26:27 <roconnor> :'(
03:26:52 <Cale> http://www.haskell.org/haskellwiki/New_monads/MonadRandom ?
03:26:53 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
03:26:54 <osfameron> Cale: "Random"
03:27:04 <osfameron> Cale: http://osfameron.vox.com/library/post/random-pain-in-haskell.html
03:27:06 <Cale> oh, does that have getRandom?
03:27:15 <osfameron> er... no sorry, it doesn't
03:27:21 <osfameron> it has getStdRandom and randomR
03:27:27 <Cale> ah, right
03:27:32 <osfameron> which are what I'm using, sorry, said wrong name
03:27:48 <Cale> The monad that I linked there (which I wrote), has getRandom
03:27:56 <Cale> It implements a monad Rand
03:28:10 <Cale> such that you could write your function pick :: [a] -> Rand a
03:28:51 <Cale> and then to 'run' a Rand, you just need to create a random gen to pass to evalRand
03:28:51 <osfameron> ah cool
03:29:00 <Cale> (there's also evalRandIO)
03:29:07 <osfameron> what is the advantage to using that instead of Random?
03:29:19 <osfameron> ooo, lunchtime
03:29:21 <Cale> Well, it uses Random itself :)
03:29:41 <osfameron> cool, I've saved to look at later
03:29:47 <Cale> The advantage is that you have the generator threaded along for you without possibility of arbitrary IO
03:30:44 <ricky_clarkson> Given a base ghci with nothing extra installed, can I use getRandom?
03:32:02 <quicksil1er> Cale: doesn't it come out as (MonadRandom m) => [a] -> m a
03:32:18 <quicksil1er> Cale: or did you decide to eschew the class-style generalisation?
03:33:37 <[TWiSTED]> is there a function that tests if a value is an Int ?
03:34:04 <drigz> @google haskell degrees radians
03:34:06 <lambdabot> http://www.vbforums.com/showthread.php?t=51559
03:34:52 <drigz> because someone of the vb forum had some haskell in their signature
03:35:02 <dolio> [TWiSTED]: That sort of thing doesn't come up much in Haskell, unless you're mucking with Typeable and Dynamic.
03:35:09 <ricky_clarkson> quicksil1er: That's decided at compile time ordinarily.
03:35:11 <quicksil1er> [TWiSTED]: what type of value do you have which 'might be' an Int? :)
03:35:35 <[TWiSTED]> well ive got an IO function that inputs 2 arguments
03:35:49 <[TWiSTED]> i need error checking so that the first argument is an Int datatype
03:36:02 <quicksil1er> depends what you mean by 'input'
03:36:13 <quicksil1er> if you mean you have a function with 2 arguments, then you don't need to check
03:36:25 <quicksil1er> if the function has type Int, then that argument is guaranteed to be an Int
03:36:34 <quicksil1er> that's what typing gives you
03:36:44 <[TWiSTED]> yeh
03:36:48 <[TWiSTED]> it errors already if it isnt an int
03:36:58 <[TWiSTED]> but i think to override that error to write my own error
03:37:05 <[TWiSTED]> but i think i need to override*
03:38:10 <quicksil1er> well, it's a compile-time error
03:38:27 <quicksil1er> you don't normally change those
03:38:33 <[TWiSTED]> oh ok
03:38:36 <quicksil1er> but your users won't see them since it's compiled before they see it
03:38:45 <Cale> [TWiSTED]: that seems odd. The only way that anything could even try to pass it anything else is if you explicitly provided for it with something like  Either Int String
03:39:01 <drigz> Cale: or if you had typeclasses?
03:39:28 <[TWiSTED]> hmm
03:39:31 <drigz> Cale: originally i thought he had a function Num a => a -> b, which he wanted to behave differently if you gave it an Int or something else
03:39:37 <Cale> drigz: Well, yeah, I suppose that could happen.
03:39:39 <drigz> but apparently not
03:39:58 <[TWiSTED]> nah its not meant to behave differently if given an Int
03:40:04 <Cale> But that's not allowed to really behave differently -- it just has to do what the typeclass instances say to do.
03:40:13 <[TWiSTED]> just argument checking i suppose
03:41:00 <quicksil1er> drigz: typeclass things are really supposed to behave 'the same' not 'different' :)
03:41:02 <Cale> Right, the only argument checking you'd have to do in Haskell is with regard to the specific values of the type in question (say, if your function only works on positive Integers)
03:41:09 <quicksil1er> drigz: but certainly you can pervert typeclasses to do that
03:41:28 <Cale> Right, if you were to make it a typeclass method, and write lots of instances :)
03:42:05 <drigz> quicksil1er: yeah, but i'm the kind of person who thinks of crazy ways to do what people say they want, instead of telling them they shouldn't want it
03:42:15 <Cale> Oh hey, osfameron, you were looking for mapM in your blog.
03:42:38 <quicksil1er> I find most blog articles are either looking for sequence or mapM
03:42:46 <quicksil1er> even if they don't think they're articles about haskell
03:43:54 <[TWiSTED]> well perhaps i should check that its not a Char or String rather than checking that its an Int
03:44:31 <drigz> quicksil1er: :D
03:44:59 <drigz> [TWiSTED]: no working haskell implementation should give a function that has type Int -> a anything but an Int
03:45:11 <[TWiSTED]> yeah true
03:45:36 <drigz> it's not like python where if you want a robust function you have to put assert isinstance(argument, type)
03:46:04 <Cale> [TWiSTED]: This is why we all love static typing so much, because it frees us from writing zillions of pointless tests. :)
03:46:34 <[TWiSTED]> haha yeh
03:46:39 <Cale> If you give a function some type signature, the compiler will actually prove that it's never called in any other way.
03:46:40 <quicksil1er> spagillions!
03:46:41 <wli> Instead we can write more meaningful ones, I suppose.
03:46:50 <Cale> right.
03:47:08 <wli> Now I need to figure out the dynamic programming bit for lcs.
03:47:21 <wli> (Longest Common Subsequence)
03:48:06 <Igloo> You know I implemented a couple of lcs algorithms in Haskell, right?
03:48:23 <wli> No, actually.
03:48:34 <Cale> :t replicateM
03:48:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
03:48:48 <wli> Igloo: Point away.
03:48:56 <olsner> > replicateM 3 [1,2,3]
03:48:57 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
03:49:03 <wli> No need to reinvent the wheel.
03:49:06 <ejt> wli: darcs has some code for lcs
03:49:10 <Igloo> wli: http://urchin.earth.li/darcs/ian/lcs/
03:49:11 <lambdabot> Title: Index of /darcs/ian/lcs
03:49:43 <Cale> I can has programming reddit?
03:50:09 <drigz> Cale: is it dead again?
03:50:18 <Cale> Appears to be.
03:50:36 <Cale> I can not has programming reddit :(
03:50:41 <TSC> Not yours
03:50:42 <drigz> i think the people going OMG ALBERTO GONZALES has broken it
03:50:59 <Cale> OMG ALBERTO GONZALES!!1
03:51:11 <Cale> sorry
03:51:13 <quicksil1er> > reverse "SELAZNOG OTREBLA GMO"
03:51:15 <lambdabot>  "OMG ALBERTO GONZALES"
03:51:16 <jql> Gonzo party?
03:51:22 <quicksil1er> even lambdabot is at it
03:52:47 <drigz> > replicateM 2 [1,2]
03:52:48 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
03:52:53 <dons> Cale, quick!  this is our chance to put up notreddit.com!
03:53:01 <dons> i can has only haskell stories!
03:53:17 <dons> lolcats and lambdas!
03:54:39 <dons> osfameron: did you work out how to use System.Random?
03:54:45 <dons> :t randomRs
03:54:47 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
03:55:18 <pjd> dons: haddit.com!
03:55:50 <ricky_clarkson> dunnit.com
03:55:58 <ricky_clarkson> gotthetshirt.com
03:56:43 <wli> Oh dear, now I remember. I wanted the prefix and suffix.
03:57:16 <dons> osfameron: no IO required for randoms :)
03:57:31 <dons> > randomRs (1,6) (mkStdGen 42)
03:57:33 <lambdabot>  [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,3...
03:58:02 <dons> lolcatsandlambdas.com sounds cute.
03:59:50 <Cale> Is there like a rule somewhere that says that blog software generally has to suck with regard to parsing of comments?
04:00:15 <ricky_clarkson> Everything after any < has to be ignored.
04:00:24 <ricky_clarkson> That way you can place all insults there.
04:00:54 <pjd> Cale: i think that's a special instance of the more general rule
04:01:37 <quicksil1er> Cale: people believe that it's trivial to write new blog software, thus they keep writing new blog software
04:01:52 <quicksil1er> Cale: and each time they do predictably poorly on the parts of the job which are hard
04:02:34 <ricky_clarkson> java.net blogs has been saying "comments shown oldest first" incorrectly for at least 3 years.
04:02:44 <wli> wordpress insists on mucking with your entire box. It's like a SPEC benchmark where you have to replace numerous standard utilities and so on to get it to run at all.
04:03:07 <ricky_clarkson> quicksilver: The irritating part is that the 'professional' ones are actually just as rubbish as the amateur ones.
04:03:28 <quicksilver> which is why people keep writing new ones
04:03:35 <quicksilver> tis a bugger of a vicious circle :)
04:04:00 <Cale> It's really not *that* hard.
04:04:14 <Cale> People just don't seem to know which bugs to check for.
04:04:37 <quicksilver> learning from other people's mistakes is so web 1.0
04:04:49 <quicksilver> in web 2.0 we like to make our own mistakes without consulting prior work
04:04:55 <Cale> The recent reddit beta had just about every possible comment parsing bug.
04:05:08 <Cale> Which is funny, because the existing reddit has it mostly right.
04:05:38 <Vq^> @remember quicksilver learning from other people's mistakes is so web 1.0
04:05:38 <lambdabot> Done.
04:05:55 <Cale> Heh, you could totally kill the comments page just by posting a single unicode character.
04:06:36 <BobFunk> ahh - maybe that's why reddit is down atm - someone posted a unicode character!
04:07:38 <ricky_clarkson> I like the blog software that shows a live preview of how the comment will look.
04:08:11 <ricky_clarkson> ..but I think you can keep it simple - all you need is something that recognises URLs, the rest is faff.
04:15:49 <[TWiSTED]> can i do a conditional expression (like if) inside a do expression?
04:15:58 <Cale> [TWiSTED]: yep
04:16:07 <Cale> [TWiSTED]: do if foo
04:16:17 <Cale> [TWiSTED]:       then bar
04:16:19 <[TWiSTED]> hm saying syntax error in expression
04:16:22 <Cale> [TWiSTED]:       else quux
04:16:34 <Cale> How are you indenting it?
04:16:49 <Cale> and are you being sure to include both branches of the if-expression?
04:16:53 <[TWiSTED]> i have the then statement directly after the if condition
04:17:00 <[TWiSTED]> o
04:17:03 <[TWiSTED]> i havent used else
04:17:05 <Cale> right
04:17:06 <TSC> Do you need the else branch in a do expression?
04:17:09 <Cale> that would be the problem
04:17:12 <Cale> return ()
04:17:21 <Cale> (which is a noop
04:17:22 <Cale> )
04:18:07 <roconnor> [TWiSTED]: use ``when foo bar'', in cases where you'd use if foo then bar.
04:18:24 <quicksilver> or foo `when` bar
04:18:32 <[TWiSTED]> o ok
04:18:34 <quicksilver> erm
04:18:42 <quicksilver> but that's silly
04:18:43 <quicksilver> :(
04:18:51 <[TWiSTED]> ok i added the else
04:18:55 <quicksilver> when needs its parameters in the other order!
04:18:56 <quicksilver> :)
04:19:04 <[TWiSTED]> it says "last generator in do {...} must be an expression
04:19:21 <TSC> What's the last thing in your do expression?
04:19:32 <roconnor> > (\x -> do {when (odd x) mzero}) =<< [1,2,3,4,5]
04:19:33 <lambdabot>  [(),()]
04:19:36 <[TWiSTED]> calls a function
04:19:46 <roconnor> hmm, not the most clear example in the world
04:19:59 <roconnor> > (\x -> do {when (odd x) mzero; return (show x)}) =<< [1,2,3,4,5]
04:20:01 <lambdabot>  ["2","4"]
04:20:49 <roconnor> ... of course insead of ``when (odd x) mzero'', one would really do ``guard (not (odd x))''
04:22:02 <[TWiSTED]> hm
04:22:34 <olsner> or guard (even x)
04:23:04 <quicksilver> [TWiSTED]: if you're still stuck, paste some of your source code and it will be easier to help you
04:23:24 <[TWiSTED]> ok
04:23:40 <nornagon> > let if = when in do { x <- [1,2,3,4] ; mzero `if` (odd x) ; show x }
04:23:40 <lambdabot>  Parse error
04:24:00 <[TWiSTED]> main = do args <- getArgs
04:24:01 <[TWiSTED]>           if (length (args)) /= 2
04:24:01 <[TWiSTED]>              then "Incorrect number of arguments"
04:24:01 <[TWiSTED]>              else cs <- readFile (args !! 1)
04:24:01 <[TWiSTED]>                     displayTail (read (args !! 0)) (lines cs)
04:24:04 <drigz> @src even
04:24:05 <lambdabot> even n = n `rem` 2 == 0
04:24:10 <drigz> :(
04:24:14 <quicksilver> [TWiSTED]: not in the channel :)
04:24:18 <nornagon> [TWiSTED]: please don't paste more than three or four lines here :)
04:24:18 <[TWiSTED]> lol
04:24:20 <[TWiSTED]> sorry
04:24:20 <nornagon> @paste
04:24:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:24:23 <drigz> i always thought that i was being efficient by using even
04:24:30 <quicksilver> [TWiSTED]: anyhow, the problem is that "incorrect number of arguments" isn't an action
04:24:33 <nornagon> (only lambdabot is allowed to spam)
04:24:37 <quicksilver> [TWiSTED]: it's a string
04:24:44 <[TWiSTED]> should i use putStr ?
04:24:45 <[TWiSTED]> o
04:24:46 <[TWiSTED]> ok
04:24:50 <quicksilver> [TWiSTED]: possibly you want putStrLn or error
04:25:07 <roconnor> > let if' = flip when in do { x <- [1,2,3,4] ; mzero `if'` (odd x) ; show x }
04:25:08 <lambdabot>  "24"
04:25:15 <quicksilver> [TWiSTED]: secondly, you need another 'do' inside the else clause
04:25:22 <quicksilver> [TWiSTED]: else do cs <- .....
04:25:24 <[TWiSTED]> ohh ok
04:25:47 <nornagon> > let and = when in do { x <- [1,2,3,4] ; odd x `and` mzero ; show x }
04:25:48 <lambdabot>  "24"
04:25:55 <[TWiSTED]> awesome
04:25:59 <[TWiSTED]> thanks quicksilver
04:26:01 <quicksilver> np
04:26:08 <roconnor> nornagon: and is a terrible name :)
04:26:09 <drigz> `
04:26:29 <dylan> @hoogle and
04:26:29 <lambdabot> Prelude.and :: [Bool] -> Bool
04:26:30 <lambdabot> Prelude.significand :: RealFloat a => a -> a
04:26:30 <lambdabot> System.Process.runCommand :: String -> IO ProcessHandle
04:26:43 <quicksilver> > and [True,False,True,True,True]
04:26:44 <lambdabot>  False
04:27:00 <olsner> > and []
04:27:01 <lambdabot>  True
04:27:03 <ricky_clarkson> > and [False..]
04:27:03 <lambdabot>  Parse error
04:27:53 <roconnor> > and [False ..]
04:27:54 <lambdabot>  False
04:27:59 * thoughtpolice yawns
04:28:06 <thoughtpolice> mornin' :)
04:28:15 <roconnor> > and [minBound ..]
04:28:16 <lambdabot>  False
04:28:32 <drigz> thoughtpolice: 6.30, wow
04:28:39 <drigz> quite an hour for #haskell
04:28:52 <quicksilver> whatever time it is, it's always #haskell time
04:28:59 <ricky_clarkson> Do haskellers get up earlier than lispers?
04:29:03 <roconnor> @quote time
04:29:03 <lambdabot> lispy says: one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'inifinite' datastructures
04:29:25 <nornagon> roconnor: i agree )
04:29:34 <nornagon> s/\)/:)/
04:29:38 <thoughtpolice> drigz: what quicksilver said.
04:30:13 <thoughtpolice> also, school requires early mornings, so i don't go insane in my first class.
04:30:47 <thoughtpolice> because normally I wake up about 15 minutes before class starts.
04:31:38 <ricky_clarkson> I've done that when I'm teaching before.
04:37:58 <drigz> i joined #haskell to see if there was a function to convert radians to degrees, because i didn't want to type it myself
04:38:02 <drigz> that was an hour ago :(
04:38:19 <roconnor> drigz: nope
04:40:00 <roconnor> > let degrees = (*(pi/180)) in (90 `degrees`)
04:40:02 <lambdabot>  1.5707963267948966
04:40:08 <roconnor> > let degrees = (*(pi/180)) in (360 `degrees`)
04:40:09 <lambdabot>  6.283185307179586
04:40:22 <roconnor> > let degrees = (*(pi/180)) in (180 `degrees`)
04:40:23 <lambdabot>  3.141592653589793
04:40:50 <roconnor> I guess that isn't Haskell 98
04:41:06 <augustss> nope
04:41:11 <haskell-> hi
04:42:51 <ricky_clarkson> roconnor: Why (180 `degrees`) instead of degrees 180?
04:43:07 <roconnor> ricky_clarkson: it reads better.
04:43:14 <roconnor> arguably.
04:44:45 <drigz> a = omega ^ 2 * r, right?
04:45:12 <roconnor> drigz: a = pi * r^2 ?
04:45:22 <drigz> a = angular acceleration
04:45:31 <roconnor> oh
04:45:37 <drigz> no, sorry, centripetal acceleration
04:46:06 <roconnor> drigz: I always remember v^2/r = a
04:46:12 <haskell-> drigz: thats right
04:46:40 <roconnor> drigz: given that omega = v/r, what you have looks right.
04:49:58 * wli usually just re-derives those things from vector forms on the fly.
04:51:04 <drigz> i just work it out from units, but for some reason my results were'nt working
04:51:09 <drigz> *weren't
04:51:18 <drigz> turns out i forgot the m in F = ma :(
04:51:52 <wli> x(t) = (x_0 + r*cos(f(t)), y_0 + r*sin(f(t))) or some such.
04:53:37 <wli> x' = r*f'(t)*(-sin(f(t)), cos(f(t))) etc.
04:54:00 <oklopol> > 5
04:54:01 <lambdabot>  5
04:54:09 <haskell-> :D
04:54:23 <oklopol> i know, i own @ haxell
04:54:49 <oklopol> > 5+-2
04:54:50 <lambdabot>   Not in scope: `+-'
04:54:53 <oklopol> > 5+ -2
04:54:54 <lambdabot>      precedence parsing error
04:54:54 <lambdabot>         cannot mix `(+)' [infixl 6] and prefix ...
04:54:58 <oklopol> > 5 + -2
04:54:59 <lambdabot>      precedence parsing error
04:54:59 <lambdabot>         cannot mix `(+)' [infixl 6] and prefix ...
04:54:59 <wli> x'' = r*f''(t)*(-sin(f(t)), cos(f(t))) - r*(f'(t))^2*(cos(f(t), sin(f(t)))
04:55:01 <oklopol> :P
04:55:03 <thoughtpolice> hax!
04:55:05 <mux> > 5 + (-2)
04:55:06 <lambdabot>  3
04:55:09 <oklopol> i know
04:55:10 <haskell-> > 5+$-2
04:55:11 <oklopol> in theory
04:55:11 <lambdabot>   Not in scope: `+$-'
04:55:16 <haskell-> > 5+ $ -2
04:55:16 <lambdabot>  Parse error
04:55:21 <haskell-> ehh
04:55:25 <oklopol> > (5+) 3
04:55:27 <lambdabot>  8
04:55:32 <thoughtpolice> > (+) 5 (-2)
04:55:32 <roconnor> > (5+) $ (-2)
04:55:33 <oklopol> > (+5) 3
04:55:34 <lambdabot>  3
04:55:34 <lambdabot>  3
04:55:35 <lambdabot>  8
04:55:44 <haskell-> > 5 + $ - 2
04:55:44 <lambdabot>  Parse error
04:55:50 <thoughtpolice> i think mine is the best. :)
04:55:52 <roconnor> > (+5) (-2)
04:55:53 <lambdabot>  3
04:56:13 <oklopol> > [1,2,3,4]
04:56:14 <lambdabot>  [1,2,3,4]
04:56:18 <oklopol> > reverse[1,2,3,4]
04:56:19 <lambdabot>  [4,3,2,1]
04:56:42 <roconnor> > nubBy(((>1) .) . gcd) [2..]
04:56:43 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
04:57:29 <haskell-> > last [1..]
04:57:30 <haskell-> :D
04:57:34 <lambdabot> Terminated
04:57:57 <mux> > fix ((1:) . scanl (+))
04:57:58 <lambdabot>  Couldn't match expected type `[t]'
04:58:05 <wli> In the direction of the normal it's r*f''(t), in the direction of the tangent it's r*(f'(t))^2, things like |x'' - (<x'', x'>/|x'|^2)*x'| end up being "a
04:58:06 <mux> woops
04:58:12 <wli> "a" rater.
04:58:15 <mux> > fix ((1:) . scanl (+) 1)
04:58:17 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
04:58:34 <thoughtpolice> anybody seen this? http://cufp.galois.com/
04:58:35 <lambdabot> Title: Commercial Users of Functional Programming
04:58:59 <thoughtpolice> looks fun (found it via erlang's mailing list)
04:59:15 <wli> That's the sort of thing I recapitulate as-needed.
04:59:30 <wli> Frenet frames are not so involved really.
05:05:20 <[twiisted]]> anyone able to help explain what the function sequence_ does?
05:05:52 <thoughtpolice> it executes a list of actions and discards the result
05:05:54 <thoughtpolice> @type sequence_
05:05:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
05:06:09 <[twiisted]]> ah ok
05:06:13 <thoughtpolice> i.e. sequence [putStr "hello ",putStrLn "world"]
05:06:42 <[twiisted]]> and doesnt give a result?
05:06:52 <thoughtpolice> nope
05:06:55 <thoughtpolice> sequence gives a result
05:06:58 <thoughtpolice> sequence_ doesn't
05:07:02 <thoughtpolice> @type sequence
05:07:02 <[twiisted]]> ohh ok
05:07:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:07:17 <[twiisted]]> so sequence [putStr "hello ",putStrLn "world"] will result in "hello world" yeh?
05:07:22 <thoughtpolice> yeah.
05:07:24 <[twiisted]]> ok
05:07:26 <[twiisted]]> thanks
05:07:37 <thoughtpolice> you can also repeat one action lots of times
05:07:37 <thoughtpolice> via repeat
05:07:52 <thoughtpolice> i.e. sequence_ . repeat 10 $ putStrLn "hello world!"
05:08:14 <[twiisted]]> say i wanna apply a function to x number of arguments
05:08:39 <[TWiSTED]> hm
05:08:53 <thoughtpolice> use mapM_
05:09:20 <thoughtpolice> like mapM_ print [1..10]
05:09:50 <[TWiSTED]> o ok
05:09:52 <thoughtpolice> if you want the results, you can just use mapM
05:09:54 <|Jedai|> thoughtpolice: Not repeat, replicate (repeat produce an infinite list)
05:10:03 <[TWiSTED]> o yeh mapM
05:10:05 <thoughtpolice> |Jedai|: oh thanks. :)
05:10:07 <[TWiSTED]> need the results
05:10:21 <|Jedai|> thoughtpolice: You have replicateM to repeat action too ^^
05:10:32 <thoughtpolice> [TWiSTED]: if it's not monadic though you don't need mapM and can just use vanilla map
05:10:40 <oklopol> > [o]
05:10:41 <lambdabot>   Not in scope: `o'
05:10:51 <oklopol> > [-]
05:10:51 <lambdabot>  Parse error
05:10:55 <oklopol> > [(-)]
05:10:56 <lambdabot>  [<Integer -> Integer -> Integer>]
05:11:27 <thoughtpolice> jedai: i.e. (replicateM_ x) == (sequence_ . repeat x)
05:11:33 <thoughtpolice> ?
05:11:50 <jedai> thoughtpolice: almost : (replicateM_ x) == (sequence_ . replicate x)
05:11:58 <thoughtpolice> damnit. :(
05:12:13 <wli> |x''- (<x'', x'>/|x'|^2)*x'|^2 = |x''|^2 - <x'', x'>^2/|x'|^2 = a^2
05:12:16 <thoughtpolice> i always forget repeat just makes an infinate list out of the argument.
05:12:18 <wli> What, no counter?
05:12:31 <jedai> thoughtpolice: I made this error all the time at first ;)
05:12:41 <[TWiSTED]> what does monadic mean
05:12:42 <wli> @type replicateM_
05:12:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
05:13:10 <wli> replicateM_ n x == sequence_ . replicate n x
05:13:22 <oklopol> > (\t a n->case a of 1 -> (a a); x -> (a (t t a (n - 1))))
05:13:23 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
05:13:23 <lambdabot>     Probab...
05:13:27 <oklopol> oh :<
05:13:28 <jedai> [TWiSTED]: monadic means "in a monad", IO is a monad, but you have other monads (like State eg)
05:13:30 <wli> replicateM_ n x == sequence_ $ replicate n x
05:13:31 <oklopol> what's wrong?
05:13:35 <thoughtpolice> [TWiSTED]: things like putStrLn (IO Monad)
05:13:48 <oklopol> that oughtta be a lambda for self application
05:13:53 <[TWiSTED]> oh ok
05:13:55 <thoughtpolice> there're others, though. but if your function you're applying these arguments to is not 'inside' a monad,
05:13:58 <oklopol> but i guess i fail some type stuff?
05:14:02 <ricky_clarkson> oklopol: Haskell doesn't support infinite types.
05:14:09 <thoughtpolice> you don't need mapM etc, you only need map
05:14:11 <wli> :t let replicateM_' n x = sequence_ $ replicate n x in (replicateM_, replicateM_')
05:14:15 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1. (Monad m, Monad m1) => (Int -> m a -> m (), Int -> m1 a1 -> m1 ())
05:14:21 <oklopol> umm okay... can you try and explain what makes that infinite?
05:14:27 <[TWiSTED]> the function outputs type IO ()
05:14:28 <ricky_clarkson> oklopol: What type does f have?
05:14:38 <oklopol> umm... the lambda?
05:14:40 <thoughtpolice> [TWiSTED]: then it's in the IO monad, which means you want mapM.
05:14:41 <ricky_clarkson> Er, wait.
05:14:48 <[TWiSTED]> ok thanks
05:14:58 <ricky_clarkson> oklopol: \f f x -> f x -- is a simpler version to talk about.
05:15:06 <oklopol> okay
05:15:10 <oklopol> > \f f x -> fx
05:15:11 <oklopol> > \f f x -> f vx
05:15:13 <oklopol> > \f f x -> f x
05:15:14 <lambdabot>      Conflicting definitions for `f'
05:15:14 <lambdabot>     In a lambda abstraction
05:15:14 <lambdabot>   Not in scope: `vx'
05:15:15 <lambdabot>   Not in scope: `fx'
05:15:18 <oklopol> :D
05:15:24 <oklopol> > (\f f x -> f x)
05:15:27 <lambdabot>      Conflicting definitions for `f'
05:15:27 <lambdabot>     In a lambda abstraction
05:15:39 <oklopol> so... hmm...
05:15:40 <ricky_clarkson> > \f x -> f f x
05:15:41 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
05:15:41 <lambdabot>     ...
05:15:52 <[twiisted]]> ffs stupid network
05:16:01 <ricky_clarkson> In that, what type would f be?
05:16:26 <dcoutts_> ricky_clarkson: under what type system?
05:16:28 <oklopol> f :: x -> (((....) -> x) -> x)
05:16:29 <oklopol> err
05:16:32 <ricky_clarkson> It would be a function that takes a function that takes a function that... ... and x and x and x and x
05:16:41 <jedai> oklopol: indice, f f x == (f f) x
05:16:49 <oklopol> oh
05:16:55 <oklopol> yeah indeed
05:18:00 <oklopol> can you do my self application thing at all?
05:18:31 <Saizan> with recursive types
05:19:27 <ricky_clarkson> oklopol: Yes, with fix.
05:19:41 <oklopol> i see...
05:19:43 <oklopol> > fix
05:19:44 <lambdabot>  Add a type signature
05:19:49 <oklopol> > fix f
05:19:49 <lambdabot>   Not in scope: `f'
05:19:50 <mux> fix is evil
05:20:00 <oklopol> what's fix's definition?
05:20:01 <Saizan> ?type fix
05:20:03 <lambdabot> forall a. (a -> a) -> a
05:20:04 <oklopol> oh
05:20:06 <Saizan> ?src fix
05:20:06 <lambdabot> fix f = let x = f x in x
05:20:14 <mux> > fix (\f n -> if n == 0 then 1 else n * f (n - 1)) $ 4
05:20:15 <lambdabot>  24
05:20:28 <mux> > fix ((1:) . scanl (+) 1)
05:20:29 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
05:21:07 <ricky_clarkson> > fix $ \x -> x+1
05:21:08 <lambdabot>  Exception: <<loop>>
05:21:23 <EvilTerran> > let { fix f = f (fix f) } in fix ((1:) . scanl (+) 1)  --  "nicer" definition, imo
05:21:25 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
05:21:25 <wli> > fix ((2:) . scanl (*) 1)
05:21:26 <lambdabot>  [2,1,2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,6189700196426...
05:21:47 <wli> > fix ((1:) . scanl (*) 2)
05:21:48 <lambdabot>  [1,2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,618970019642690...
05:22:05 <ricky_clarkson> oklopol: An example of where a mandatory static typing system forces you to think differently (but in this case fix is actually better).
05:22:09 <wli> Oh well.
05:22:09 <EvilTerran> > fix (scanl (*) 2 . (1:))
05:22:11 <lambdabot>  [2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,61897001964269013...
05:22:32 <pjd> > fix ("you're wrong! No, " ++)
05:22:33 <lambdabot>  "you're wrong! No, you're wrong! No, you're wrong! No, you're wrong! No, you...
05:22:39 <mux> heh
05:22:42 <mux> nice one
05:22:46 <EvilTerran> what does fix have to do with (f f) x?
05:22:55 <pjd> (DRMacIver's)
05:23:04 <EvilTerran> is this to do with making the Y combinator?
05:23:13 <Japsu> @index scanl
05:23:13 <lambdabot> Data.List, Prelude
05:23:18 <Japsu> @type scanl
05:23:19 <pjd> the Y combinator is one definition of fix
05:23:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
05:23:22 <EvilTerran> which isn't necessary in a language in which explicit recursion is allowed?
05:23:25 <EvilTerran> :D
05:23:30 <Saizan> well f f is a part of how you write Y
05:24:06 <oklopol> > f = 5
05:24:06 <lambdabot>  Parse error
05:24:09 <pjd> fix ((1:) . (>>= \x -> [1+x, 1/(1+x)])) :: [Rational]
05:24:12 <pjd> > fix ((1:) . (>>= \x -> [1+x, 1/(1+x)])) :: [Rational]
05:24:13 <oklopol> can you store any values?
05:24:13 <lambdabot>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
05:24:46 <EvilTerran> Saizan, that's what i was saying, but i then qualified that with "but you don't need to write Y in haskell 'cos you're allowed recursive definitions"
05:24:55 <EvilTerran> oklopol, do you mean serialization?
05:25:04 <oklopol> no, i mean the bot
05:25:12 <EvilTerran> @let x = 3
05:25:17 <quicksilver> > x
05:25:18 <lambdabot>   Not in scope: `x'
05:25:18 <lambdabot> Defined.
05:25:20 <EvilTerran> > x
05:25:22 <lambdabot>  3
05:25:23 <EvilTerran> ;]
05:25:26 <mux> > L.x
05:25:27 * quicksilver boggles
05:25:28 <lambdabot>  3
05:25:41 <EvilTerran> you're too quick, er, quicksilver
05:25:41 <oklopol> @let f = f . f
05:25:43 <lambdabot> Defined.
05:25:47 <oklopol> > f 5
05:25:49 <EvilTerran> (wikiwikisilver?)
05:25:51 <oklopol> umm...
05:25:51 <mux> L is in scope now?
05:25:52 <lambdabot> Terminated
05:26:14 <oklopol> "f = f . f" is legal?
05:26:29 <EvilTerran> yes, but it's the bottom of a -> a.
05:26:40 <oklopol> umm yeah
05:26:46 <quicksilver> legal but not very interesting
05:26:51 <oklopol> but... why does it take arguments?
05:26:57 <oklopol> i don't ask it to
05:26:57 <EvilTerran> ?type (.)
05:26:59 <quicksilver> because it has a function type
05:27:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:27:07 <EvilTerran> ?type undefined . undefined
05:27:08 <lambdabot> forall c a. a -> c
05:27:15 <quicksilver> same reason let f = (+1) . (+2) takes an argument
05:27:22 <EvilTerran> ?type let x = undefined in x . x
05:27:23 <lambdabot> forall c a. a -> c
05:27:27 <quicksilver> > let f = (+1) . (+2) in f 6
05:27:28 <lambdabot>  9
05:27:45 <oklopol> oh, (f . f) takes an argument and applies f to it twice
05:27:59 <oklopol> and by the recursive property, f also takes an argument then
05:28:32 <quicksilver> or "by type inference"
05:28:34 <quicksilver> but, yes
05:29:02 <oklopol> yeah, sorry if i'm raping terms, i do that a lot
05:29:36 <oklopol> i'm pretty sure i'll learn haskell eventually by asking random questions here a few times a month
05:29:40 <oklopol> now pizza ->
05:30:45 <ricky_clarkson> Lambdas are fun.
05:30:47 <ricky_clarkson> > let cons=(\x y m -> m x y) in let car=(\c -> c (\x y -> x)) in (car (cons 4 5))
05:30:48 <lambdabot>  4
05:34:56 <nornagon> @pl \c -> c (\x y -> x)
05:34:56 <lambdabot> ($ const)
05:35:12 <nornagon> @pl \c -> c (\x y -> y)
05:35:12 <lambdabot> ($ const id)
05:35:42 <EvilTerran> if you want nice symmetry, those could be ($ uncurry fst) and ($ uncurry snd)
05:36:22 <ricky_clarkson> Do you think sicp could be rewritten to use monads, so that set! is never needed?
05:36:44 <EvilTerran> sicp?
05:37:04 <ricky_clarkson> You owe it to yourself to google that term.
05:37:55 <EvilTerran> @go sicp
05:37:57 <lambdabot> http://mitpress.mit.edu/sicp/
05:37:57 <lambdabot> Title: Welcome to the SICP Web Site
05:38:16 <nornagon> @pl (\c -> c (\x y -> x) $ (\x y m -> m x y) 4 5
05:38:16 <lambdabot> (line 1, column 45):
05:38:16 <lambdabot> unexpected end of input
05:38:16 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or ")"
05:38:23 <nornagon> @pl (\c -> c (\x y -> x)) $ (\x y m -> m x y) 4 5
05:38:23 <lambdabot> 4
05:38:26 <EvilTerran> ahh. i've seen that in my college library
05:38:34 <ricky_clarkson> Steal it.
05:38:38 <EvilTerran> ... "$", "$!", "`seq`" aren't operators?!
05:38:42 <nornagon> so @pl contains an implementation of scheme!
05:38:49 <nornagon> @src ($)
05:38:49 <lambdabot> f $ x = f x
05:38:58 <nornagon> @src ($!)
05:38:58 <lambdabot> Source not found. Wrong!  You cheating scum!
05:39:05 <nornagon> @src seq
05:39:06 <lambdabot> Source not found. Maybe if you used more than just two fingers...
05:39:17 <nornagon> i think the latter two hide in GHC?
05:39:23 <Saizan> ?type (\c -> c (\x y -> x)) $ (\x y m -> m x y) 4 5
05:39:25 <lambdabot> forall b. (Num b) => b
05:39:28 <EvilTerran> f $! x = x `seq` f x
05:39:49 <EvilTerran> x `seq` y = (const $! x) y
05:39:50 <EvilTerran> =P
05:40:54 <EvilTerran> ricky_clarkson, the library has fairly high security. i could just borrow it while i'm there...
05:41:10 <EvilTerran> or just read it online, seeing as that seems to be possible
05:41:46 <ricky_clarkson> I work at a university - they gave up asking for books back a few years ago.
05:42:03 <ricky_clarkson> let they=library in above
05:42:20 <EvilTerran> this one's got RFIDs in the spine of all the books, and those security gate things at the door
05:42:44 <EvilTerran> so an alarm goes off if you try to get out with an un-checked-out book.
05:43:04 <EvilTerran> and if you don't return a book on time, the college starts putting fines on my termly bill
05:43:10 <EvilTerran> s/you/I/
05:43:11 <ricky_clarkson> Hah.
05:43:36 <ricky_clarkson> We tell students they won't be allowed to graduate until they've paid library fines, but we don't really enforce that.
05:44:05 <EvilTerran> it's really rather clever. the only option i can think of that *might* work is to steal someone else's uni card, and check out the book with that
05:44:15 <ricky_clarkson> ..because in the UK often education is usually mainly or totally paid by the state, it's a bit harder to whack extras onto the bill.
05:44:35 <EvilTerran> but then they could look at the security camera footage on the door and see who was carrying the book as it went thru the gates
05:45:01 <EvilTerran> oh, this isn't the university fees, this is the college fees. room & board, tuition, etc.
05:45:05 <ricky_clarkson> Is there a really-recommended book for Haskell, or do you just cobble an understanding together from SPJ's papers?
05:45:20 <EvilTerran> (yay oxford)
05:46:05 <ricky_clarkson> EvilTerran: What languages do Oxford CS people do?
05:46:13 <EvilTerran> ricky_clarkson, under instruction from my FP lecturer, i am required to recommend "Introduction to Functional Programming" by Bird
05:46:30 <drigz> U
05:46:33 <drigz> oops
05:46:41 <quicksilver> ricky_clarkson: the newish book by Hutton is well recommended
05:46:46 <quicksilver> ricky_clarkson: I haven't read it myself
05:46:49 <drigz> EvilTerran: line your jacket with foil, and put the book under it?
05:46:53 <EvilTerran> we did Haskell in first term of first year, then oberon (an even uglier version of Pascal) in second term for imperative programming
05:47:00 <drigz> maybe we should take this to #pettytheft
05:47:01 <EvilTerran> next year we're using Java for OOP
05:47:10 <EvilTerran> drigz, security cameras whee!
05:47:30 <drigz> sleight of hand?
05:47:32 <ricky_clarkson> You should use scheme for OOP - where you get to invent your own OOP.
05:48:01 <EvilTerran> i think there might be a couple of others we have to use, depending on which units we take, but after that i think we're basically allowed to use whatever takes our fancy
05:48:04 <ricky_clarkson> EvilTerran: At least the top ones aren't doing Java for everything.
05:48:08 <ricky_clarkson> ones=unis
05:48:21 <drigz> i heard that oxford cs used about 7 languages
05:48:31 <EvilTerran> the first term's course was "functional programming". i don't think java would be appropriate
05:48:40 <ricky_clarkson> When my boss studied he did one language a week in one semester.
05:49:18 <EvilTerran> drigz, well, if you count CSP, different flavours of \calc, the three different query languages i'm betting'll be taught in the databases unit...
05:49:43 <roconnor> I'm beginning to think my portfolio optimizer is needlessly complicated.
05:50:08 <ricky_clarkson> I think CS courses should be based around http://norvig.com/21-days.html
05:50:09 <lambdabot> Title: Teach Yourself Programming in Ten Years
05:50:10 <EvilTerran> they try to give a set of skills that aren't bound to one language, so they keep switching to stop us getting stuck in a rut
05:50:21 <roconnor> In Haskell, 70 lines of code is considered too complicated :D
05:50:53 <xerox> roconnor: actually that is my average code size for complete projects (-:
05:51:12 <ricky_clarkson> I like it when the code is smaller than the requirements doc.
05:51:20 <roconnor> xerox: sounds like you could do a bit more refining ;)
05:51:55 <EvilTerran> if three of those lines aren't import Control.Monad; import Control.Arrow; import Control.Applicative;, you can make it shorter ;]
05:52:14 <xerox> roconnor: actually I'm quite pleased with those results !
05:52:47 <roconnor> I'm starting to think my two case statements in my portfolio optimizer cancel each other out, leaving me with a nice simple linear equation to solve.
05:53:31 <roconnor> xerox: Oh, I'm sure, but that doesn't mean you cannot go further ;)
05:53:45 <roconnor> xerox: of course, just because you can go further doesn't mean you should go further.
05:54:21 <EvilTerran> by the by, i was thinking about guard desugaring... would desugaring "case foo of bar | baz -> ...; eek | ack -> ..." to "case (foo, baz, eek) of (bar,True,_) -> ...; (baz,_,True) -> ..." etc make sense?
05:54:33 <roconnor> xerox: (actually I think 70 lines is a pretty reasonable module size)
05:54:34 <pjd> @remember EvilTerran if three of those lines aren't import Control.Monad; import Control.Arrow; import Control.Applicative;, you can make it shorter ;]
05:54:34 <lambdabot> Done.
05:54:54 <xerox> roconnor: I agree. Especially because it does non-obvious work with pleasing-to-read code most of the time.
05:54:59 <Tac-Tics> Why must every 3rd party Haskell library web site contain at least one broken link???
05:55:02 <EvilTerran> i know this is a solved problem, but i like to think about these things
05:55:08 <EvilTerran> pjd, :D
05:56:19 <EvilTerran> actually, i got to thinking about this when thinking about Core-esque languages and suchlike. seems guards are eliminatable to me.
05:57:05 <Tac-Tics> why do people hate guards so much?
05:57:31 * roconnor <3 guards
05:57:33 <EvilTerran> i don't hate them in the language, just think they don't need to be in a Core-like language
05:57:38 <roconnor> does GHC have pattern guards?
05:57:47 * xerox ? pattern guards
05:57:51 <Radek> Tac-Tics: Actually I was thinking the same thing. I like guards but nobody seems to be using it.
05:57:58 <Saizan> isn't ghc the onle one with pattern guards?
05:57:58 <EvilTerran> and the point of Core is to have a minimalist syntax...
05:57:59 <xerox> Aw. That was meant to be an unicode HEART.
05:58:07 <EvilTerran> roconnor, yes
05:58:20 <EvilTerran> i think -fglasgow-exts is enough to enable them
05:58:23 <Tac-Tics> Guards don't seem that bad. Especially since Haskell has a kinda clunky if statement syntax
05:59:05 <roconnor> @where pattern-guards
05:59:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-guards
05:59:09 <Tac-Tics> at least, in comparison with the terseness of everything else
05:59:26 <Tac-Tics> From everything I've seen, using an "if" statement in Haskell is a sign of defeat =-P
05:59:32 <Radek> Does anyone use vim with Haskell? If so, did anyone come up with clever folding settings?
06:00:15 <EvilTerran> Radek, isn't folding by indentation pretty good?
06:00:43 <roconnor> EvilTerran: cool, I should start using them.
06:00:47 <msouth> Radek: I haven't done anything with that yet, bu tyou might check with python users since they also have the layout thing to contend with
06:01:12 <EvilTerran> roconnor, i agree; they're really useful for adding terseness
06:01:13 <Radek> EvilTerran: Well. I was hoping for a little better. For example case and if statements gets too much folded.
06:01:21 <Radek> msouth: Nice tip. Thanks
06:02:22 <ricky_clarkson> Even in verbose languages I hate folding.  I tried to like it, honest.
06:04:40 <xerox> What would the Haskell type system need exactly to enable [[]] :: * -> * ?
06:04:52 <Radek> msouth: That was very good tip. I looked briefly at the python settings and I found some clever yet obvious settings. Thanks!
06:05:37 <EvilTerran> ricky_clarkson, i agree, actually. if you need folding, you either need to restructure your program or your language.
06:05:50 <roconnor> what is folding?
06:05:52 <EvilTerran> type LoL a = [[a]]?
06:06:05 <wli> xerox: Partial application.
06:06:10 <xerox> EvilTerran: I am aware of that possibility.
06:06:14 <EvilTerran> xerox, a (.) for types would work
06:06:29 <xerox> EvilTerran: right, I can also do that, but it is not [[]]
06:06:42 <wli> Actually it's rejected.
06:06:52 <wli> Partially applied type synonym errors.
06:06:54 <xerox> newtype ((t1 :: * -> *) :. (t2 :: * -> *)) a = t1 (t2 a)
06:07:02 <xerox> With a datacon
06:07:34 <xerox> wli: the problem is that [] :: * -> *. That is, it wants a *type* as first argument, not a type constructor of kind (* -> *) such as [].
06:07:42 <EvilTerran> roconnor, making the lines of code inside blocks disappear in your IDE so you don't have to scroll so much
06:07:44 <[TWiSTED]> how do i read in a file and apply something to each line in that file?
06:07:50 <xerox> I guess the answer is type lambdas.
06:07:54 <wli> xerox: Yes.
06:08:02 <[TWiSTED]> cs <- readFile filename
06:08:18 <EvilTerran> needing it is an indication that your code is too long. if this is too difficult to do, your langauge is too verbose ;]
06:08:23 <[TWiSTED]> but im unsure how to separately access 1 line in the file
06:08:26 <EvilTerran> s/do/fix/
06:08:36 <scook0> map f (lines cs)
06:08:51 <EvilTerran> ?type hGetLine
06:08:51 <scook0> :t lines
06:08:53 <lambdabot> Not in scope: `hGetLine'
06:08:54 <lambdabot> String -> [String]
06:09:09 <roconnor> EvilTerran: ah,  ... why would you have more code than fits on a screen? :P
06:09:16 <EvilTerran> System.IO.hGetLine :: Handle -> IO String
06:09:43 <EvilTerran> roconnor, my cond^H^H^H^Hsentiments exactly.
06:10:43 <[TWiSTED]> would any "word" (lines cs) search each line to see if "word" appears in a line?
06:10:43 <roconnor> > lines "Hello\nWorld\n"
06:10:45 <lambdabot>  ["Hello","World"]
06:10:55 <roconnor> > map length $ lines "Hello\nWorld\n"
06:10:57 <lambdabot>  [5,5]
06:11:16 <EvilTerran> [TWiSTED], a combination of hGetLine and hIsEOF (to prevent exceptions) might be nicer in terms of memory usage
06:11:29 <mrd> no
06:11:35 <mrd> lazy IO should take care of that
06:11:39 <roconnor> > map (any (=="Hello") . words) $ lines "Hello\nWorld\n"
06:11:39 <EvilTerran> i'm not sure how lazy readFile really is...
06:11:40 <lambdabot>  [True,False]
06:11:55 <mrd> it's quite lazy, which caused some problems for me the other week
06:12:05 <EvilTerran> mrd, okay. i'm still not entirely comfortable with the lazy file access, is all
06:12:17 <mrd> I don't blame you.  try readFile then writeFile immediately after =)
06:12:38 <scook0> readFile should only be used for "pure" files ;)
06:12:39 * roconnor is ambivalent about lazy files
06:12:48 <wli> mrd: unlink first
06:13:00 <mrd> will that force it? but I need Posix for that
06:13:18 <scook0> lazy I/O is nice for throwaway stuff
06:13:43 <wli> mrd: No, it won't force it; however, writeFile opens with O_TRUNC IIRC so you will avoid the write-after-read hazards.
06:14:07 <mrd> the first problem I ran into was that the file wasn't closed
06:14:10 <EvilTerran> scook0, yeah, that's kinda what i was trying to say. i don't feel safe enough using it to use it for big projects
06:14:16 <mrd> and haskell simple IO implements a simple locking system
06:14:34 <wli> mrd: When readFile's handle is closed the on-disk inode will be discarded. writeFile will obtain a fresh inode. etc.
06:14:58 <quicksilver> lazy IO is nice for code which you intend to throw away and never use
06:15:35 <wli> mrd: writeFile should probably really do this internally to avoid surprises.
06:15:49 <mrd> but when is readFile's handle closed?
06:16:06 <wli> mrd: In the handle's finalizer IIRC.
06:16:13 <mrd> yea that's what I was running into.
06:16:22 <mrd> I just switched to strict bytestring
06:16:34 <wli> mrd: It doesn't matter if you unlink because writeFile will not have a handle to the same inode.
06:16:40 <mrd> sure
06:16:43 <wli> mrd: It will obtain a fresh inode.
06:17:06 <[TWiSTED]> well im tryin to build a function similar to the grep command in linux
06:17:37 <[TWiSTED]> searches a file for a given word line by line and outputs the lines that contain that word
06:18:39 <wli> do { s <- System.IO.readFile filePath ; System.Directory.removeFile filePath ; System.IO.writeFile filePath s' }
06:20:07 <wli> Perhaps readAndReplace :: FilePath -> String -> IO String ; readAndReplace filePath s = do { s' <- System.IO.readFile filePath ; System.Directory.removeFile filePath ; System.IO.writeFile filePath s ; return s' }
06:20:08 <augustss> [TWiSTED]: sounds like a nice oneliner :)
06:20:21 <[TWiSTED]> haha
06:20:23 <xerox> [TWiSTED]: I sugges using Data.ByteString.Lazy
06:20:32 <[TWiSTED]> im not that good with haskell to do it all in one line
06:20:42 <augustss> [TWiSTED]: use long lines ;)
06:20:47 <EvilTerran> ?type filterM
06:20:49 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
06:20:50 <wli> mrd: The anonymous on-disk inode is kept alive with the file contents intact so long as the file handle remains open.
06:20:52 <xerox> [TWiSTED]: pretend you are!
06:21:00 <[TWiSTED]> hehe
06:21:11 <mrd> wli: looks good
06:21:21 <augustss> [TWiSTED]: lines and unlines are good
06:21:38 <[TWiSTED]> yea ive used lines
06:21:51 <EvilTerran> ?type System.IO.getLine
06:21:53 <lambdabot> IO String
06:22:23 <augustss> [TWiSTED]: and interact is good if you want stdin&stdout
06:22:32 <[TWiSTED]> ah ok
06:22:57 <xerox> augustss: I think he wants mapM_ on the readDirectory paths
06:23:50 <wli> mrd: Seems to work here.
06:24:08 <mrd> wli: can you count on the 'inode' behavior portably?
06:24:17 <augustss> xerox: I just heard the part where he wanted something like grep
06:24:24 <wli> mrd: On UNIX and UNIX-like systems, yes.
06:24:38 <wli> mrd: I've no idea about Windows or VMS vfs semantics.
06:24:41 <EvilTerran> @where ffi
06:24:41 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
06:25:13 <wli> mrd: I think it should really be folded into writeFile; people shoot themselves in the foot with this sort of thing all the time.
06:25:32 <mrd> feature request?
06:25:43 <wli> mrd: Yeah, sounds like the right category.
06:26:22 <hpaste>  Shurique pasted "(no title)" at http://hpaste.org/2478
06:26:51 <Shurique> this is always returning "", and I can't seem to figure out why
06:28:08 <scook0> Shurique: hGetContents, like readFile, uses lazy I/O
06:28:26 <scook0> i.e. the file is only read when you force the thunks in the list
06:28:27 <augustss> Shurique: you shouldn't close the file
06:28:42 <augustss> I thought that close would generate a runtime error
06:28:45 <Shurique> well, I want to write to the same file later in the program
06:29:11 <augustss> Shurique: Then you'd better not use hGetContents
06:29:29 <scook0> nope, closing a "semi-closed" handle is perfectly legal
06:29:31 <Shurique> what do you recommend instead?
06:29:36 <augustss> Shurique: the lazy reading makes it difficult to predict when reading is done
06:29:53 <Saizan> Shurique: you need to append to this file?
06:30:14 <Shurique> Saizan: no, truncate and write
06:30:39 <mrd> use wli's suggestion then
06:31:49 <Saizan>   wli : do { s <- System.IO.readFile filePath ; System.Directory.removeFile filePath ; System.IO.writeFile filePath s' }
06:32:05 <Saizan> Shurique: on UNIX this will work ^^^^
06:32:31 <Shurique> I see
06:32:34 <Shurique> what about other OSes?
06:32:56 <scook0> is there no strict version of hGetContents in the libs?
06:33:25 <wli> Shurique: NFI about other OS's.
06:33:29 <augustss> scook0: no, but it's easy to make one.  take the length or something like that
06:33:40 <Saizan> scook0: Data.ByteString's one, also
06:33:41 <mrd> scook0: Data.ByteString.Char8
06:34:01 <mrd> it's got the same interface as IO, pretty much
06:34:27 <earthy> shurique: depends. the calls are portable code
06:35:06 <mrd> do { ... c <- hGetContents h; length c `seq` return c }
06:35:48 <earthy> shurique: however, if you encounter a system that refers to files just by filepath, and not by handle (e.g. inode), then wli's suggestion may lead to interesting behaviour
06:36:01 <earthy> fortunately, no current systems that I know of do that.
06:36:03 <EvilTerran> it strikes me as odd that there is no strict read-a-whole-file
06:36:15 <mrd> @hoogle readFile
06:36:15 <lambdabot> Prelude.readFile :: FilePath -> IO String
06:36:15 <lambdabot> System.Win32.File.c_ReadFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
06:36:15 <lambdabot> System.Win32.File.win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
06:36:23 <quicksilver> EvilTerran: yes, I think that's very odd
06:36:29 <mrd> Data.ByteString.Char8.readFile ;)
06:36:49 <EvilTerran> that doesn't return Chars, though, so it's still a hack
06:36:54 <mrd> unpack
06:37:01 <quicksilver> EvilTerran: I hate the fact that the lazy IO versions are both (a) the default and (b) in many cases, the only available version
06:37:09 <EvilTerran> it's still a hack!
06:37:21 <EvilTerran> as is using length c `seq` to force it
06:37:37 <augustss> sure
06:37:41 <earthy> um. right. you want strict to be the default?
06:37:47 <quicksilver> of course
06:37:49 <quicksilver> lazy is broken
06:38:00 * earthy blinks
06:38:00 <quicksilver> and confuses people with its brokenness (almost) every day
06:38:07 <EvilTerran> there should be something that does the same thing as, say, hGetContent, just without the unsafeInterleaveIO'ing that that does
06:38:10 <EvilTerran> *s
06:38:30 <mrd> bytestring is part of ghc /shrug
06:38:39 <mrd> i don't think lazy IO is broken either
06:38:49 <dons> having a library for strict IO of String I've though would be useful -- not critical, just useful
06:39:04 <desp> quicksilver: huh?
06:39:08 <dons> since length x `seq` return () is a bore sometimes. (I use bytestrings anyway for that ;)
06:39:09 <desp> lazy is borken?
06:39:14 <earthy> I think lazy IO is the default in much of unix
06:39:21 <dons> desp: for some cases where you want to mutably update a file, for exampple
06:39:28 <earthy> not at the API level though, but at the pipe level
06:39:29 <mrd> I originally coded my Fuun DNA reader using bytestring, but learned to my chagrin that default lazy IO was superior
06:39:34 <desp> dons: ah.
06:39:45 <dons> mrd, oh? not using lazy bytestrings, but lazy String?
06:39:45 <desp> mrd: huh?
06:39:50 <quicksilver> lazy IO is no longer haskell
06:39:52 <mrd> i tried lazy bytestrings too
06:39:57 <quicksilver> it's not referentially transparent
06:40:02 <Vq^> http://www.paulgraham.com/accgen.html
06:40:04 <lambdabot> Title: Accumulator Generator
06:40:04 <dons> mrd, huh? more info please.
06:40:04 <mrd> yea it was really weird
06:40:09 <mrd> lemme see if I can dig it up
06:40:13 * Vq^ doesn't get the Haskell version there
06:40:14 <[TWiSTED]> map (++ " Sheep") [1 ..]   should make a list containing ["1 Sheep","2 Sheep","3 Sheep",...] right?
06:40:15 <desp> mrd: do you have a lazy String-based dna->rna interpreter I could benchmark?
06:40:21 <dons> for any size, lazy bytestrings should beat lazy String.
06:40:38 <[TWiSTED]> an infinite list
06:40:39 <desp> mrd: I got down to 1.5 minute for endo.dna using lazy bytestrings; haven't had time to polish the code yet
06:40:43 <DRMacIver> [TWiSTED]: No, ++ won't convert the numbers into strings automatically.
06:40:45 <quicksilver> [TWiSTED]: ( (++ " Sheep") . show )
06:40:46 <dons> same complexity, 1/16th the space (or something like that)
06:40:51 <[TWiSTED]> ohh
06:40:57 <desp> dons: yeah I completely fail to see how this could work better
06:41:00 <quicksilver> [TWiSTED]: show is needed to convert the ints to strings
06:41:10 <[TWiSTED]> i see, thanks
06:41:34 <dons> > map (\n -> printf "%d Sheep" (n :: Int)) [1..]
06:41:35 <lambdabot>  Add a type signature
06:41:40 <dons> > map (\n -> printf "%d Sheep" (n :: Int)) [1..]  :: [String]
06:41:41 <lambdabot>  ["1 Sheep","2 Sheep","3 Sheep","4 Sheep","5 Sheep","6 Sheep","7 Sheep","8 Sh...
06:41:44 <dons> :)
06:42:32 <dons> > map (((++" Sheep") . show) [1..]
06:42:32 <lambdabot>  Unbalanced parenthesis
06:42:36 <dons> > map ((++" Sheep") . show) [1..]
06:42:37 <lambdabot>  ["1 Sheep","2 Sheep","3 Sheep","4 Sheep","5 Sheep","6 Sheep","7 Sheep","8 Sh...
06:42:56 <[TWiSTED]> thanks
06:43:00 <EvilTerran> hGetContents' h = do eof <- hIsEOF h; if eof then return [] else liftM2 (:) (hGetChar h) (hGetContents' h)
06:43:52 <mrd> desp,dons: http://mapcar.org/haskell/icfp07/
06:43:54 <lambdabot> Title: Index of /haskell/icfp07
06:44:28 <desp> mrd: so how's the speed?
06:44:36 <mrd> took 2 min on my system /shrug
06:44:39 <[TWiSTED]> how do i add a new line to each entry in the list?
06:44:44 <[TWiSTED]> .  /n ?
06:44:50 <quicksilver> map (++ "\n")
06:45:05 <DRMacIver> Or unlines if you want to convert it into a String.
06:45:07 <mrd> anyway I finagled with the bytestring stuff for a while including trying to play around with foreign ptrs like you can see commented
06:45:09 <desp> mrd: interesting. I don't have the time to dig through it today, but I'll see in a few days
06:45:13 <DRMacIver> @src unlines
06:45:14 <lambdabot> unlines = concatMap (++ "\n")
06:45:17 <mrd> the IO stuff is in Main only
06:45:20 <desp> mrd: is the whole source in endo.zip?
06:45:20 <[TWiSTED]> thanks
06:45:22 <mrd> no
06:45:26 <mrd> Main/DNA.hs
06:45:47 <desp> k
06:46:10 <mrd> DNA is implemented using Data.Sequence and a few monad transformers
06:47:29 <desp> ahh, Data.Sequence
06:47:36 <desp> well, that's not just String, innit ;)
06:48:00 <mrd> I had a lot of trouble just reading in endo's dna
06:50:24 <desp> I just do a lazy read :
06:50:26 <desp> ):)
06:50:50 <mrd> yes.. until I did a lazy read =)
06:55:01 <Vq^> shouldn't  foo=(+)  suffice?
06:55:23 <Saizan> Vq^: the other solutions mutate n
06:56:33 <dons> mrd, i think the main issue with bytestrings was people using concat, or fragmenting the data a lot
06:56:51 <wli> Why is concat bad?
06:56:53 <Vq^> :/
06:56:59 <mrd> requirse copying
06:57:10 <mrd> but I was just reading in a big string and mapping over it
06:57:26 <wli> Hmm. I wonder why.
06:57:31 <mrd> it's only 7mb file, I figured even if it did read the whole thing into memory it should be ok
06:57:31 <quicksilver> I'm sure there was some work on a fragmentation-resistant bytestring
06:57:37 <quicksilver> with good asymptotic performance
06:57:59 <quicksilver> (with 7mb of data I'd say reading it in all at once, as a strict bytestring, would be a very good idea)
06:58:06 <mrd> but it wasn't
06:58:09 <wli> I rarely feel the need to improve upon [Char] as a string representation, but then again, I'm rarely trying to squeeze tons of performance out of things.
06:58:20 <mrd> it was completely killing performance
06:58:34 <wli> Poor cache locality, of course.
06:58:45 <fasta> I profiled a program with -hy and I see that it uses 10MB for []. Does this mean there is 10MB of closures with that type or just 10MB of list data?
06:59:33 <fasta> I also profiled it to see that the same 10MB lags.
06:59:40 <EvilTerran> if you want to deal with sequences of Word8s, but don't have significant performance concerns, would ByteString/BS.Lazy be the default choice of datatype, or just [Word8]?
07:00:12 <fasta> EvilTerran: ByteString has a nice interface, but I haven't used it for that application.
07:01:19 <EvilTerran> am i right in thinking lazy bytestrings are more often more appropriate than strict ones?
07:01:28 <EvilTerran> given that we're in a lazy language
07:02:00 <mrd> I think they need to be utilized in a different fashion.
07:02:05 <xerox> EvilTerran: note that there are also .Char8 modules for both that provides [Char] interface.
07:02:22 <mrd> usually just converting from Strict to Lazy doesn't help.
07:02:32 <EvilTerran> xerox, yes, i see that, but i'm manipulating bytes, not characters =]
07:02:56 <mrd> I think the main advantage of Lazy comes from the toChunks function
07:04:08 <EvilTerran> er. how does it know how big to make the chunks?
07:04:27 <EvilTerran> ah, it says at the top. 64k.
07:04:35 <osfameron> Cale: ta, dolio pointed out mapM as well.  I'd come across it... but didn't know that's what I needed
07:04:41 <osfameron> dons: eeeek!  no IO?
07:07:35 <osfameron> by the way, is there a reason that there's no function boolToMaybe?
07:08:14 <EvilTerran> :: Bool -> Maybe a, or :: Bool -> a -> Maybe a?
07:08:44 <osfameron> Bool -> a -> Maybe a
07:08:53 <osfameron> but otherwise the equivalent of listToMaybe
07:09:05 <osfameron> @t boolToMaybe b v = listToMaybe $ filter (const b) [v]
07:09:05 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
07:09:09 <osfameron> meh
07:09:19 <quicksilver> well there is a real shortage of functions on ool
07:09:20 <quicksilver> bool
07:09:30 <quicksilver> there's no "if-like" destructor
07:09:36 <EvilTerran> > (guard True >> Just 1, guard False >> Just 1)
07:09:36 <fasta> quicksilver: or xor...
07:09:38 <lambdabot>  (Just 1,Nothing)
07:09:45 <osfameron> if it existed, you could define ternaries operator (?!) in terms of boolToMaybe and fromMaybe
07:09:46 <quicksilver> but, realy, it's not hard to write if c then Just a else Nothing
07:09:53 <osfameron> true :-)
07:10:18 <quicksilver> you could make a case for boolToMaybe :: Bool -> Maybe ()
07:10:22 <quicksilver> then you could just use 'maybe'
07:10:26 <EvilTerran> quicksilver, the "else Nothing" bit is annoying, though. that's why i prefer the "guard" form
07:10:31 <EvilTerran> ?type when
07:10:33 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:10:42 <fasta> I miss about 500/600 LOC of general utility functions.
07:11:00 <fasta> Some of them overlapped with ndm's utility module.
07:11:10 <EvilTerran> hm. when is not appropriate her.
07:11:11 <EvilTerran> e
07:11:20 <quicksilver> fasta: yes, plenty of operators within Bool, but few operators connecting Bool to the other types.
07:11:49 <quicksilver> do True <- x; return ()
07:11:58 <quicksilver> ^^ one way to write boolToMaybe, I think
07:12:05 <quicksilver> although it's boolToMonad as I wrote it
07:12:08 <fasta> quicksilver: plenty?
07:12:16 <fasta> quicksilver: Data.Bool contains very little.
07:12:39 <fasta> quicksilver: Or do you mean some other module?
07:12:50 <Saizan> xor = (/=)
07:14:10 <EvilTerran> quicksilver, surely that's maybeBoolToMaybe?
07:15:03 <EvilTerran> @src guard
07:15:04 <lambdabot> guard True  =  return ()
07:15:04 <lambdabot> guard False =  mzero
07:15:37 <EvilTerran> @undo do True <- return x; return ()
07:15:38 <lambdabot> (return x >>= \ a -> case a of { True -> return (); _ -> fail ""})
07:16:01 <EvilTerran> yay for the case{} bit of do{} desugaring!
07:16:04 <EvilTerran> -.-
07:17:08 <osfameron> bah, eeeek!
07:17:33 <osfameron> you lot are more There's More Than One Way To Do It than the average Perl programmer...
07:17:40 * EvilTerran notes that he uses both of those as metasyntactic variables. well, "bar" and "eek", anyway.
07:17:58 <EvilTerran> i am a perl programmer. maybe that's got something to do with it...
07:18:14 <osfameron> hehe, I'm at YAPC::Vienna right now
07:18:32 <EvilTerran> Yet Another Perl... Convention?
07:18:42 <osfameron> ...Conference
07:18:50 <EvilTerran> k. close enough. =]
07:18:58 <osfameron> yea ;-)
07:19:13 <quicksilver> EvilTerran: damn, yes, hmph
07:19:26 <quicksilver> EvilTerran: True -> return x as you say
07:19:28 <quicksilver> <-
07:20:39 <EvilTerran> yeah well. "guard p >> return x" is terser, now you've got that extra "return"
07:20:42 <EvilTerran> ;]
07:22:16 <Tac-Work> > map (\(m, a, p) -> "map") [("m", "a", "p")]
07:22:17 <lambdabot>  ["map"]
07:22:34 <EvilTerran> er?
07:22:54 <Saizan>  > map (\(m, a, p) -> "map") [(undefined, undefined, undefined)]
07:22:55 <Tac-Work> I made art out of haskell
07:22:59 <Saizan> > map (\(m, a, p) -> "map") [(undefined, undefined, undefined)]
07:23:00 <lambdabot>  ["map"]
07:23:12 <Saizan> ah :)
07:23:19 <Tac-Work> you made art too Saizan!
07:23:38 <EvilTerran> c\_/
07:23:47 <EvilTerran> (it's not haskell, but it is art. and i've got tea.)
07:24:33 <fasta> Anyone a clue on my profile?
07:24:37 <EvilTerran> ?where cpp2hs
07:24:37 <lambdabot> I know nothing about cpp2hs.
07:24:50 <EvilTerran> ?where c2hss
07:24:50 <lambdabot> I know nothing about c2hss.
07:24:51 <EvilTerran> ?where c2hs
07:24:52 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
07:25:02 <EvilTerran> damnit. there we go. you can see why i need this tea. ;]
07:25:35 <fasta> To find out where the leak was exactly, I defined a type isomorhpic to [], but it seems that it still compiles to [] and thus I cannot see which list is causing the leak.
07:25:48 <Tac-Work> > filter (\"filter"->"filter=="filter") ["filter"]
07:25:48 <lambdabot>  Improperly terminated string
07:25:56 <Tac-Work>  > filter (\"filter"->"filter"=="filter") ["filter"]
07:26:30 <Tac-Work> lambdabot?
07:26:37 <EvilTerran> > filter (\"filter"->"filter"=="filter") ["filter"]
07:26:38 <lambdabot>  ["filter"]
07:26:58 <Tac-Work> oops, I must have had an extra space
07:27:00 <Tac-Work> before the >
07:27:06 <xerox> badger badger badger badger
07:27:09 <EvilTerran> yes. fixed-width fonts FTW.
07:27:28 <EvilTerran> > join (++) "mushroom "
07:27:29 <lambdabot>  "mushroom mushroom "
07:27:53 <Tac-Work> cycle $ (replicate 4 "badger")  ++ (replicate 2 "mushroom")
07:27:53 <sieni> > "badger" >> "badger"
07:27:54 <lambdabot>  "badgerbadgerbadgerbadgerbadgerbadger"
07:28:00 <Tac-Work> > cycle $ (replicate 4 "badger")  ++ (replicate 2 "mushroom")
07:28:07 <lambdabot>  ["badger","badger","badger","badger","mushroom","mushroom","badger","badger"...
07:28:39 <sieni> I think "badger" is repeated 12 times
07:29:07 <sieni> > "12" >> "badger" >> "badger"
07:29:09 <lambdabot>  "badgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadger"
07:29:44 <Japsu> wtf
07:29:47 <Japsu> why does that work
07:29:54 <Japsu> > "test" >> "bar"
07:29:55 <lambdabot>  "barbarbarbar"
07:30:01 <EvilTerran> [undefined,undefined] >> [1]
07:30:03 <EvilTerran> > [undefined,undefined] >> [1]
07:30:04 <lambdabot>  [1,1]
07:30:06 <Olathe> > "123" > "yay"
07:30:07 <Japsu> okay
07:30:08 <lambdabot>  False
07:30:10 <Olathe> > "123" >> "yay"
07:30:11 <lambdabot>  "yayyayyay"
07:30:23 <Japsu> but hmm
07:30:24 <fasta> Ok, another space leak crushed.
07:30:27 <pjd> Japsu: it replaces each character in "12" with "badger"
07:30:36 <Japsu> > "1" >> "foo" >> "foo"
07:30:36 <EvilTerran> > [undefined,undefined] >>= return
07:30:37 <lambdabot>  "foofoofoo"
07:30:37 <Tac-Work> @type >>
07:30:38 <lambdabot>  Undefined
07:30:38 <pjd> resulting in "badgerbadger"
07:30:40 <lambdabot> parse error on input `>>'
07:30:40 <Tac-Work> oh
07:30:40 <Japsu> oh
07:30:40 <Tac-Work> hehe
07:30:41 <Japsu> right
07:30:42 <EvilTerran> > [1,2] >>= return
07:30:44 <lambdabot>  [1,2]
07:30:45 <Japsu> that's evil
07:30:48 <Tac-Work> @type (>>)
07:30:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:30:53 <pjd> and then replaces those 12 characters again
07:30:54 <EvilTerran> > [1,2] >>= \_ -> return 3
07:30:56 <lambdabot>  [3,3]
07:30:59 <Tac-Work> "sdf" >> "sdf"
07:30:59 <EvilTerran> etc
07:31:00 <Japsu> yeah
07:31:18 <fasta> Using the Writer monad when you don't consume it is a bad idea, so it seems.
07:31:56 <Saizan> fasta: which monoid?
07:32:00 <ricky_clarkson> > foldl (++) "" ["sn",(foldl (++) "" $ replicate 8 "a"),"ke"]
07:32:01 <lambdabot>  "snaaaaaaaake"
07:32:29 <oerjan> @src Writer (>>=)
07:32:30 <lambdabot> Source not found. You speak an infinite deal of nothing
07:32:46 <Saizan> > concat ["sn",replicate 8 'a',"ke"]
07:32:47 <lambdabot>  "snaaaaaaaake"
07:32:55 <fasta> Saizan: Doc
07:33:17 <Saizan> ?index Doc
07:33:18 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
07:33:22 <msouth> > "snaaaaaaaake"
07:33:23 <lambdabot>  "snaaaaaaaake"
07:33:35 <msouth> note that mine is shortest...
07:33:58 <fasta> Saizan: but this was the strict writer monad written yesterday
07:34:33 <fasta> Saizan: I think the same problem would be seen with less strict writer monads, though.
07:34:40 <oerjan> fasta: what does its >>= look like?
07:36:01 <fasta> oerjan: http://paste.debian.net/35597
07:36:49 <Tac-Work> @let (+++++++++++++++++++++++++++!++++!++++!+<><>!!!+++) = (+1)
07:36:53 <lambdabot> Defined.
07:37:02 <Tac-Work> > (+++++++++++++++++++++++++++!++++!++++!+<><>!!!+++) 25
07:37:03 <lambdabot>  26
07:37:18 <oerjan> fasta: it w'' is a list only the top cons cell will be forced
07:37:21 <oerjan> *if
07:37:30 <Tac-Work> Haskell is silly with its freedom of operators
07:37:44 <puusorsa> http://images.ifun.ru/i/ievJueBWv5.jpg
07:37:45 <DRMacIver> Operators want to be free!
07:37:51 <ricky_clarkson> Tac-Work: Why?
07:38:17 <Tac-Work> Because you can do things like that above
07:38:20 <johnnowak> (never ((past-tense need) i them))
07:38:23 <DRMacIver> But I agree. Haskell does very silly things with freedom of operator definition.
07:38:23 <oerjan> fasta: try to force w' as well
07:38:29 <DRMacIver> Specifically it doesn't provide nearly enough of it.
07:38:41 <quicksilver> oerjan: less than that, I think? all that gets forced is the mere fact that w and w'' are non-empty, not the cell itself ?
07:39:13 <DRMacIver> (Also, congratulations. You win the "lamest complaint ever" prize. :) )
07:39:14 <oerjan> that fact _is_ the cons cell
07:39:18 <quicksilver> oerjan: I mean, the top (:) construct for w and w'', or possibly w'' and w' (if w is empty) but not the data
07:39:23 <quicksilver> ok, yes
07:39:27 <Tac-Work> (needs who operators (when (have you (prefix notation)))
07:40:08 <ricky_clarkson> Tac-Work: Er, an operator is just a procedure/function call.
07:40:17 <ricky_clarkson> In lisp terminology, the operator is the first thing after a (
07:40:45 <DRMacIver> I particularly like the restriction in prefix notation which means I can't define functions called aerwahktratrawfwaf
07:40:58 <quicksilver> ricky_clarkson: but not in haskell terminology
07:41:01 <oerjan> fasta: you might force w and w' instead of w'' - w might help with some monoids, such as dual lists
07:41:01 <ricky_clarkson> CL lets you write (__.__)
07:41:53 <Tac-Work> Operators are less intuitive after you the standard arithmetic operators
07:41:55 <oerjan> although when i think of it, the <-'s should force something, too?
07:42:12 <Tac-Work> their order of evaluation is not an easy thing to guess at
07:42:28 <oerjan> > let x <- return undefined; [2]
07:42:28 <lambdabot>  Parse error
07:42:35 <oerjan> > do x <- return undefined; [2]
07:42:37 <lambdabot>  [2]
07:42:42 <oerjan> ah no it doesn't
07:42:49 <oerjan> or?
07:43:05 <oerjan> > do (x,y) <- return undefined; [2]
07:43:07 <lambdabot>  Undefined
07:43:34 <DRMacIver> > do ~(x, y) <- return undefined; [2]
07:43:35 <lambdabot>  [2]
07:44:01 <quicksilver> oerjan: x <- doesn't force anything, per se
07:44:07 <Tac-Work> @type do ~(x, y) <- return undefined
07:44:08 <oerjan> bah, that means w and w' _should_ already be forced if they are the result of a >>=
07:44:09 <lambdabot> The last statement in a 'do' construct must be an expression
07:44:14 <quicksilver> oerjan: but if you actuall do something with that x it might be forced
07:44:22 <quicksilver> oerjan: that depends on the definition of >>= in that monad
07:44:26 <DRMacIver> It's the pattern matching which is forcing things. <- is just ->
07:44:28 <oerjan> quicksilver: i meant (x,y) <- like in the code
07:44:29 <fasta> quicksilver: doesn't it force the match?
07:44:44 <quicksilver> fasta: yes, but in the case of x <- that is nothing
07:45:16 <quicksilver> (in the case of (a,b) <- that's different though)
07:45:21 <fasta> quicksilver: yes, I was thinking of the tuples.
07:45:25 * quicksilver nods
07:45:30 <fasta> Even with this forcing it doesn't work: http://paste.debian.net/35598
07:45:36 <fasta> See the lowest
07:47:39 <pjd> > "snake" >>= (>>) . flip when (replicate 8 ()) . ('a'==) <*> return
07:47:41 <lambdabot>  "snaaaaaaaake"
07:48:29 <xerox> Crazy.
07:48:29 <fasta> quicksilver: what happens when one writes a 5MB string to a writer monad a hundred times with monoid Doc?
07:48:38 <Tac-Work> @let snake s =  s >>= (>>) . flip when (replicate 8 ()) . ('a'==) <*> return
07:48:39 <lambdabot> <local>:8:11:     precedence parsing error         cannot mix `(.)' [infixr 9...
07:48:42 <oerjan> > (0$0 `seq`)
07:48:43 <lambdabot>      The operator `seq' [infixr 0] of a section
07:48:43 <lambdabot>         must have lower prece...
07:48:49 <fasta> quicksilver: (and doesn't force it)
07:49:07 <xerox> Tac-Work: nice error message.
07:49:11 <quicksilver> you get a 100-deep thunk, I should think
07:49:29 <Tac-Work> xerox: it's because I dissed Haskell's looseness of operators a second ago
07:49:31 <xerox> Ah, it was another error. Nevermind.
07:49:39 <Tac-Work> @type snake
07:49:42 <lambdabot> Not in scope: `snake'
07:49:46 <Saizan> how is Doc defined?
07:50:03 <fasta> Saizan: probably in [Char] -> [Char]
07:50:16 <oerjan> > (0$0 <*>)
07:50:17 <lambdabot>      The operator `<*>' [infixl 4] of a section
07:50:17 <lambdabot>         must have lower prece...
07:50:19 <Tac-Work> @src <*>
07:50:19 <lambdabot> Source not found. That's something I cannot allow to happen.
07:50:38 <pjd> Tac-Work: from Control.Applicative
07:50:41 <fasta> The space leak was in []
07:51:12 <EvilTerran> incidentally, is there a formal algebra of O()s?
07:51:26 <oerjan> fasta: [] was the underlying monad?
07:51:30 <fasta> oerjan: no
07:51:42 <fasta> oerjan: the [] probably come from Doc
07:52:21 <EvilTerran> this is something that's been bothering me since i encountered them. it looks like it should be possible (with a non-commutative =, yuck, but still), but i've repeatedly been given the impression that they're manipulated intuitively and no more
07:52:43 <fasta> oerjan: or they come from the strings I write to them and then get converted to Doc via "text".
07:52:52 <Olathe> EvilTerran: O like O(log(n)) ?
07:52:57 <EvilTerran> yes.
07:53:09 <Olathe> EvilTerran: It's a function that returns a set of functions.
07:53:14 <Saizan> EvilTerran: there's a formal definition based on limits
07:53:30 <Olathe> EvilTerran: = isn't really correct, it should be the is in symbol.
07:53:39 <oerjan> fasta: i suppose that conversion may not be very strict
07:53:51 <Olathe> Like n is in O(n^2).
07:53:58 <oerjan> </probable understatement>
07:54:02 <EvilTerran> i get f(x) = O(g(x)), and from that, f(x) = g(x) + O(h(x)) has the fairly obvious meaning (f(x) - g(x) = O(h(x)))
07:54:13 <EvilTerran> but thereafter it all gets rather hairy
07:55:02 <EvilTerran> Olathe, i know it should be \in, but then "f \in g + O(h)" no longer works, and that's the sort of algebraic faff i was thinking of
07:55:06 <EvilTerran> maybe with a new operator...
07:55:43 <EvilTerran> i suppose \le works better than =, although it's still not really correct.
07:56:04 <oerjan> EvilTerran: sure it works, you just define addition pointwise
07:56:20 <sieni> EvilTerran: well, it is a typical notation in vector spaces to say x + A for {x + y : y \in A} when x is a point in and A is a subset of the vector space
07:56:26 <EvilTerran> it's all done a bit ad hoc, though, isn't it
07:56:30 <Olathe> Would f(x) in O(g(x) + h(x)) work ?
07:56:31 <Saizan> g \in O(f) if exists k,n > 0 s.t. g(x) < k*f(x) for x > n, or something like that
07:57:06 <oerjan> Olathe: it would necessarily be the same thing
07:57:11 <oerjan> *not
07:57:14 <oerjan> sheesh
07:57:22 <EvilTerran> i was just wondering if anyone had formalised the habit of manipulating a O() as an algebraic term in informal reasoning
07:57:56 <quicksilver> yes, they have
07:57:57 <sieni> EvilTerran: well, you can do that in limit calculations and such
07:58:02 <quicksilver> I can't put you to who and where
07:58:09 <quicksilver> but it certainly has been formalised :)
07:58:19 <EvilTerran> okay. that's good to know.
07:58:30 <pjd> quicksilver: informalized?
07:59:30 <pjd> EvilTerran: check out http://en.wikipedia.org/wiki/Big_O_notation for more details then you'd ever care to know
07:59:31 * EvilTerran prefers the curved < sign and its ilk, TBH, but it seems to not be widely known, let alone popular
07:59:32 <lambdabot> Title: Big O notation - Wikipedia, the free encyclopedia
08:00:11 <pjd> including use outside of computation complexity measures
08:00:11 <xerox> EvilTerran: f = O(g) for x -> x_0 \in R u {+oo,-oo}  if  exist c \in R: lim_{x -> x_0} f(x) = c*g(x).
08:00:47 <Tac-Work> is there any way to qualify imported operators?
08:00:52 <sieni> for example, saying that a function f is differentiable at a point x_0 is more or less saying that there is c such that f(x) = f(x_0) + c (x - x_0) + O((x-x_0)^2) as x->x_0.
08:00:59 <Tac-Work> like Prelude.(+) or something?
08:01:04 <xerox> Tac-Work: you import qualified Prelude
08:01:09 <quicksilver> Tac-Work: Prelude.+
08:01:12 <EvilTerran> > (+2) Control.Applicative.<$> [1,2,3]
08:01:13 <lambdabot>  [3,4,5]
08:01:14 <quicksilver> or (Prelude.+)
08:01:16 <Tac-Work> is it that simple?
08:01:19 <Tac-Work> ah
08:01:29 <DRMacIver> You need a flag to make sure the prelude isn't implicitly imported unqualified don't you?
08:01:44 <fasta> oerjan: I found the space leak
08:01:48 <fasta> oerjan: it's in Doc
08:01:50 <xerox> DRMacIver: actually that should work anyway
08:01:56 <EvilTerran> xerox, surely that last = should be a \le?
08:02:07 <xerox> EvilTerran: no.
08:02:20 <DRMacIver> xerox: Well, Prelude.+ will work. But + will also be available unqualified.
08:02:25 <DRMacIver> Right?
08:02:30 <EvilTerran> O() is upper bounds... that looks like \Omega to me...
08:02:30 <xerox> DRMacIver: Right.
08:02:37 <DRMacIver> ok.
08:03:06 <EvilTerran> DRMacIver, the flag you're thinking of is probably -fno-implicit-prelude, though
08:03:29 <EvilTerran> but i think that's more to do with things like desugaring than it is to do with operators and suchlike
08:03:47 <EvilTerran> (sorry, not \Omega(), \Theta())
08:04:11 <DRMacIver> ok
08:05:10 <oerjan> DRMacIver: import Prelude ()  will hide most names in the Prelude
08:05:24 <DRMacIver> Interesting. I did not know that. Thanks.
08:05:26 <pjd> oerjan: from desugaring too, or not?
08:05:46 <EvilTerran> as in, with -fno-implicit-prelude, your own definition of fromInteger could get used in place of the Prelude one in the desugaring of (2) to (fromInteger {-compiled representation of (2::Integer)-})
08:05:58 <oerjan> but not from desugaring, for that you can sometimes use -fno-implicit-prelude
08:06:01 <Saizan> basically if you import Prelude explictly it is not automatically imported, but the desugaring still has it
08:06:11 <quicksilver> the desugaring is to qualified symbols
08:06:15 <quicksilver> if you like to think that way
08:06:25 <quicksilver> (unless you -fno-implicit it)
08:12:34 <fasta> Saizan: it isn't represented with [Char] -> [Char]. It uses a more complex type representing Above, Below, etc.
08:13:18 <Saizan> fasta: oh, link?
08:14:33 <fasta> Saizan: I looked in my private tree.
08:14:46 <fasta> Saizan: I don't have one.
08:15:01 <Saizan> is it in ghc head?
08:15:39 <fasta> Saizan: yes
08:23:42 <EvilTerran> right, so. i've got a c library. i want to call it from haskell. i'm in windows, and i have neither cygwin nor msys. what do i need to do?
08:24:34 <norp> but you have ghc?
08:24:49 <EvilTerran> yup.
08:25:04 <Botje> EvilTerran: checked the FFI?
08:25:49 <shapr> Good morning #haskell!
08:25:55 <shapr> @users
08:25:55 <lambdabot> Maximum users seen in #haskell: 392, currently: 370 (94.4%), active: 16 (4.3%)
08:26:05 <norpan> yes, you use the foreign function interface to call c code from haskell
08:26:07 <EvilTerran> oops
08:26:07 <shapr> Aw, I drove him away!
08:26:11 <shapr> whew
08:26:27 <conal> shapr: good morning!
08:26:32 <EvilTerran> alt-x did that, i think. which is bad, considering they're right next to each other
08:26:38 <shapr> goood morning conal! How's code treating you?
08:27:19 <conal> shapr: wonderful!  i have a new running eros. and some lovely supporting libs.  organizing to release.
08:27:53 <EvilTerran> did i miss anything?
08:28:14 <oklopol> no
08:28:41 <EvilTerran> i was trying to say something to the effect of "c2hs looks like it might be useful, but all this documentation by way of exhaustive references and little else is doing my head in
08:28:51 <oerjan> possibly <norpan> yes, you use the foreign function interface to call c code from haskell
08:29:02 <conal> shapr: how's code with you?
08:29:06 <EvilTerran> ah. i got that bit, thanks.
08:33:39 <EvilTerran> so, anyway. i have all the relevant .h files, the .lib, and the .dll... I'm guessing there's more to it than sticking "foreign import ccall aLibraryFunction :: ..." at the top of my haskell module, making sure the other files are appropriately placed, and invoking ghc with -fffi
08:36:56 <Saizan> EvilTerran: marshalling the data to and from c
08:38:02 <phobes> If I'm defining a VectorSpace class, it's not possible to overload the same * symbol to mean Scalar * Vector or Vector * Scalar is it?
08:38:47 <phobes> or is it?
08:38:52 <EvilTerran> Saizan, and this is done... with a haskell function wrapping the imported one?
08:38:54 <oerjan> should be possible with multiparameter typeclasses.
08:39:15 <EvilTerran> and that's it? i'm suspicious at how easy this sounds
08:39:18 <Saizan> EvilTerran: usually yes
08:39:22 <oerjan> you need to hide the Prelude version though
08:39:30 <phobes> Well I'd define the class like this, I think :    class VectorSpace v s | v -> s ...
08:39:48 <phobes> but then what type does * have?
08:39:48 <oerjan> no, that won't work
08:40:00 <oerjan> you need a class for the parameters of *
08:40:22 <phobes> oh ok ... is there somewhere I can see this idiom?
08:40:39 <oerjan> class Multipliable a b c | a b -> c where (*) :: a -> b -> c might work
08:41:24 <oerjan> you might get ambiguity problems however, requiring type annotations
08:41:33 <Saizan> EvilTerran: i think the hard part would be get everything to link properly, i've tried it only with a small c lib that compiled to a single .o
08:41:33 <EvilTerran> ew...
08:41:58 <EvilTerran> Saizan, hm. am I going to need to get a C compiler involved somewhere here?
08:42:19 <phobes> oerjan: Multiplicable is far more general than a VectorSpace... how do I use that to get a VectorSpace?
08:42:46 <phobes> oh I think I see nm let me play with it
08:42:47 <EvilTerran> oerjan, phobes, i'd be inclined to just make two different multiplication operators, for sanity's sake. you don't want to end up with a monstrosity like printf's typing
08:42:56 <Saizan> EvilTerran: the binaries should be enough afaiu
08:43:19 <EvilTerran> Saizan, great. i'll go have a fiddle, then, if that's all there is to it.
08:43:21 <phobes> EvilTerran, I'm just working through examples to understand the expressiveness of typeclasses
08:50:11 <EvilTerran> Saizan, how do i know what haskell types the imported functions should have?
08:50:42 <EvilTerran> just use the ones in Foreign.C.Types?
08:50:58 <shapr> conal: I'm slowly hacking up interesting stuff with HAppS, but it's a bit twisty...
08:51:12 <Saizan> EvilTerran: yeah, but c2hs can do most of this for you
08:51:31 <conal> shapr: not as clean & simple as you like?
08:51:52 <Saizan> EvilTerran: it has not a great documentation but it's quite straightforward to use
08:52:47 <dcoutts_> shapr: how's the HAppS release coming? the latest version on hackage is still 0.8.4 but I think 0.8.8 is out right?
08:52:48 <Lemmih> EvilTerran: c2hs is overkill in most situations, imho.
08:52:54 <EvilTerran> buh
08:53:19 * dcoutts_ is trying to make c2hs less of an overkill by making the cabal integration better
08:53:26 <EvilTerran> i'll get something minimal working without it, i think. just to see if this library is willing to work with haskell.
08:54:09 <dcoutts_> shapr: remember, if it's not on hackage it doesn't exist!  so the gentoo happs ebuild is still stuck at 0.8.4
08:56:51 <oerjan> @remember dcoutts_ remember, if it's not on hackage it doesn't exist!
08:56:51 <lambdabot> Done.
08:57:03 <roconnor> @quote exist
08:57:03 <lambdabot> monochrom says: data DeCarte = forall a. Think a => Exist a
08:57:13 <dcoutts_> it's true! tell everyone
08:57:15 <shapr> dcoutts_: 0.9.1 is out as alpha release, I don't think it's ready for uploading to Hackage just yet.
08:57:44 <dcoutts_> shapr: right, how about 0.8.8 ?
08:57:55 <shapr> It's pretty far behind the times :-)
08:58:01 <shapr> 0.9.1 is way better.
08:58:07 <shapr> Even in its alpha state.
08:58:19 <dcoutts_> shapr: then the latest version on hackage must be ancient :-)
08:58:53 <fasta> Has the Cabal install tool been improved in the last two months? Does it work?
08:59:07 <EvilTerran> if a function takes no parameters in C, should that be imported as :: CInt or :: () -> CInt?
08:59:23 <xerox> IO CInt
08:59:28 <dcoutts_> fasta: it used to work, it probably needs updating for recent cabal changes
08:59:50 <EvilTerran> ah yes, sprinkle everything with IOs
08:59:57 <quicksilver> EvilTerran: well, not if it's pure
09:00:07 <quicksilver> EvilTerran: if it's pure (i.e. it's a constant, really) then it can be CInt
09:00:08 <oerjan> it's monad dust!
09:00:09 <quicksilver> AIUI
09:00:12 <EvilTerran> it isn't, it's an initialization function
09:00:21 <quicksilver> then IO CInt, yes
09:00:22 <fasta> dcoutts_: for Haskell packages, there must be a way to serialize a configuration state and apply that same state to a new machine.
09:00:31 <fasta> dcoutts_: just like dpkg --set-selections
09:00:46 <dcoutts_> I'm not sure what state you mean
09:01:34 <quicksilver> dcoutts_: produces a machine readable list of all installed packages + versions
09:01:41 <quicksilver> dcoutts_: which you can pipe to a copy of dpkg on a new machine
09:01:45 <quicksilver> dcoutts_: to duplicate an install
09:02:07 <dcoutts_> ah, cabal maintains no such state
09:02:13 <quicksilver> everyone who invents a package management system re-invents dpkg badly (no offence intended)
09:02:23 <dcoutts_> cabal doesn't really know what packages are installed
09:02:32 <fasta> quicksilver: dpkg isn't perfect, but it's the best I know.
09:02:57 <dcoutts_> for ghc, cabal knows what libs are available, but it doesn't know who installed them.
09:03:33 <dcoutts_> and it's not entirely clear who's job it is to maintain that info, we don't want to duplicate the package manger
09:03:56 <fasta> Is there a Cabal2Deb program?
09:04:08 <dcoutts_> something like that, yes
09:04:18 <dcoutts_> and for rpm, ebuild and wix
09:04:25 <fasta> Maybe Hackage could also host Deb files?
09:04:47 <dcoutts_> I think that's better to have the distros do
09:04:47 <EvilTerran> is there a way of getting at #define'd values from C headers?
09:05:13 <dcoutts_> fasta: otherwise we'd be keeping packages for all distros on hackage which doesn't make a lot of sense
09:05:44 <fasta> dcoutts_: distros introduce lag until Haskell is very popular
09:06:00 <fasta> dcoutts_: for something which is not popular, that doesn't sound very smart.
09:06:17 <dcoutts_> fasta: yes, the way I see it in the end is that cabal-install is the package manager for things not packaged by the distro
09:06:34 <dcoutts_> so it should play nicely with the package manager
09:06:40 <Lemmih> EvilTerran: Yes, with hsc2hs.
09:06:46 <fasta> dcoutts_: ok, and who is responsible for cabal-install?
09:06:57 <dcoutts_> fasta: would you like to be the maintainer :-)
09:07:09 <fasta> dcoutts_: so there is none?
09:07:13 <dcoutts_> there is no single official maintainer atm, the post is vacant
09:07:30 <EvilTerran> Lemmih, ah, okay.
09:07:39 <dcoutts_> fasta: it really deserves more attention than it gets
09:08:25 <fasta> dcoutts_: Good to know, but I am way too busy, but if there's anything I might want to maintain, that would be it.
09:13:29 <cognominal_> is generic haskell  Just ghc called with some option? or is this a project forked from ghc? Maybe? or Nothing?
09:14:37 <dcoutts_> cognominal_: generic haskell was implemented as a pre-processor I think
09:14:46 <dcoutts_> cognominal_: ask kosmikus
09:15:15 <cognominal_> I am hitting the right page, apprently it is ghc + something
09:20:54 <phobes> How does generic haskell compare with the scrap your boilerplate approach?
09:21:17 <phobes> They seem to address similar problems...
09:21:27 <quicksilver> I was under the impression that SYB and newer work superseded it
09:21:29 <quicksilver> but I could be wrong
09:21:55 <quicksilver> in the general 'derive a typeclass' style, I prefer Uniplate to SYB where possible though
09:23:03 * EvilTerran opens a .hc in his text editor
09:23:07 <EvilTerran> OH GOD MY EYES
09:24:05 <dcoutts_> it's C but not as we know it
09:24:21 <dcoutts_> sorry, that should be "it's C Jim, but not as we know it"
09:26:29 <EvilTerran> ...does GHC under windows make a WinMain rather than a main?
09:27:00 <cognominal_> Uniplate?
09:27:45 <quicksilver> @where uniplate
09:27:45 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/uniplate/
09:28:35 <cognominal_> thx
09:28:50 <EvilTerran> "Warning: retaining unknown function `___hscore_get_errno' in output from C compiler" \o/
09:29:10 <EvilTerran> repeat for about 30 other functions all starting "__hscore_"
09:29:47 <EvilTerran> okay, so much for changing the order of the #includes
09:30:35 <phobes> quicksilver: uniplate requires a new extension, then, right?  whereas SYB does not?
09:30:44 <quicksilver> no
09:30:57 <quicksilver> uniplate requires no extensions, per se
09:31:05 <quicksilver> but you do need someway to get the typeclass instances
09:31:07 <phobes> ok let me look harder :)
09:31:13 <quicksilver> you could write them yourself
09:31:21 <quicksilver> or you can use the Data instances which ghc knows how to derive
09:31:31 <quicksilver> or you can use Data.Derive to derive them
09:31:44 <EvilTerran> i have a minor difficulty here, in that my library (slightly obnoxiously) needs a type called BITMAP, and that clashes with the windows one
09:32:07 <EvilTerran> so the library needs a helper library #included before the windows libraries are
09:32:35 <SamB> (a) wine and bitch about lack of namespaces in C
09:32:43 <SamB> (b) some kind of #define hack
09:32:55 <SamB> hmm.
09:33:18 <SamB> yeah, some kind of #define hack
09:33:34 <EvilTerran> {-# DEFINE BITMAP ALBITMAP #-} {-# INCLUDE <allegro.h> #-} {-# UNDEF BITMAP #-} sort of thing?
09:33:47 <SamB> allegro, eh?
09:33:52 <EvilTerran> yeah
09:34:01 <EvilTerran> (http://alleg.sf.net)
09:34:03 <lambdabot> Title: Allegro - A game programming library
09:34:13 <SamB> is there a {-# DEFINE #-} pragma?
09:34:19 <EvilTerran> i don't know, that was a guess
09:34:33 <EvilTerran> it would appear not, from looking at the .hc produces
09:34:36 <EvilTerran> *d
09:34:37 <quicksilver> anyhow, yes, that sort of thing :)
09:34:51 <SamB> anyway, I was thinking more like {-# INCLUDE <myalleg.h> #-}
09:35:40 <SamB> where myalleg.h does something like that
09:35:52 <hpaste>  shapr pasted "FLM.Types" at http://hpaste.org/2482
09:35:57 <SamB> anyway you probably need c2hs?
09:36:01 <EvilTerran> whee, access violation
09:36:19 <glguy> instead of {-# -#include "myalleg.h" #-}
09:36:19 <glguy> ?
09:36:40 <glguy> err OPTIONS^
09:36:43 <EvilTerran> glguy, afaict, those do the same thing
09:36:50 <glguy> ah, cool
09:37:09 <glguy> I don't use the ffi enough to know all the ins and outs just yet
09:37:19 <EvilTerran> time to look at c2hs
09:37:49 <EvilTerran> by the way, my command line is currently "ghc -DALLEGRO_NO_MAGIC_MAIN -fvia-C -ffi -keep-hc-files -Llib -Iinclude -lalleg test.hs". does this look reasonable?
09:38:07 <EvilTerran> (allegro's header files're in ./include, and liballeg.a is in ./lib)
09:38:44 <EvilTerran> (ALLEGRO_NO_MAGIC_MAIN is a windows+allegro thing)
09:41:25 <ddarius> shapr: FLM up yet?
09:52:47 <shapr> ddarius: It compiles, but doesn't work... mysterious typeclass weirdness.
09:55:30 <Lemmih> shapr: Your type-classes are failing at runtime?
09:56:06 <byorgey> shapr: congratulations, getting something to compile but not work *because of type class weirdness* takes skill!
09:57:23 <pchiusano> hi
09:57:28 <phobes> SYB and also the Uniplate approach seem to be further examples that would be better served with macros
09:58:57 <pchiusano> how stable is ghc?
09:59:19 <pchiusano> like, would it be pretty miraculous if a bug were discovered in it?
09:59:38 <phobes> I haven't found a bug yet
10:00:16 <oerjan> every day is a miracle!
10:00:25 <oerjan> well, maybe not that often
10:00:26 <edwinb> I don't think it's miraculous if a bug is found in any software...
10:00:28 <lament> ghc is for compiling _your_ bugs.
10:00:43 <pchiusano> so, if my program is behaving very strangely, it is probably my fault :)
10:00:46 <ShockSMX> lament: haha
10:00:50 <edwinb> if, say, it deleted your source file when there was a type error, a bug of that nature would be pretty surprising
10:01:10 <lament> pchiusano: yes, it probably is :)
10:01:30 <phobes> pchiusano: maybe you have a virus?
10:02:10 <pchiusano> virus? umm, no, I don't think that is it
10:02:25 <Lemmih> pchiusano: How is it acting strange?
10:02:40 <lament> let me guess... fails to compile with a type error
10:02:47 <phobes> lol
10:02:53 <Vq^> :)
10:02:56 <pchiusano> hehe, no, it is a runtime thing
10:03:15 <pchiusano> it would be sort of hard to explain without giving details
10:03:27 <Lemmih> We don't mind details.
10:03:28 <sjanssen> phobes: I don't think macros solve the same problem that SYB does
10:03:29 <pchiusano> I think I just have to debug it myself :-\
10:03:29 <EvilTerran> I'm thinking requiring "-no-hs-main" to use a FFId library is not suitable
10:03:44 <pchiusano> Lemmih: ok
10:03:49 <phobes> sjanssen:  really?
10:04:07 <EvilTerran> they solve different, but not disjoint, sets of problems.
10:04:11 <phobes> sjanssen:  I guess by macros I really mean reflection
10:04:12 <ddarius> GHC has bugs, but in general you trust the compiler.
10:04:19 <phobes> or lisp style macros
10:04:48 <EvilTerran> some of the things lisp macros do are rendered redundant by the type system in haskell
10:05:41 <roconnor> @djinn Void -> a
10:05:42 <lambdabot> f = void
10:05:50 <coffeemug> EvilTerran: others are made redundant by monads
10:05:53 <EvilTerran> some more are covered by SYB, Uniplate (I imagine), etc. yet more are covered by TH, or hsPlugins, or whatever
10:06:13 <oerjan> @djinn-env
10:06:13 <lambdabot> data () = ()
10:06:13 <lambdabot> data Either a b = Left a | Right b
10:06:13 <lambdabot> data Maybe a = Nothing | Just a
10:06:13 <lambdabot> data Bool = False | True
10:06:13 <lambdabot> data Void
10:06:15 <ricky_clarkson> EvilTerran: And the laziness in Haskell.
10:06:15 <lambdabot> type Not x = x -> Void
10:06:17 <lambdabot> class Eq a where (==) :: a -> a -> Bool
10:06:23 <EvilTerran> and laziness, yes.
10:07:31 <sjanssen> phobes: SYB gives us the ability to make the structure of our data transparent, I don't see how macros solve that
10:08:00 <ricky_clarkson> But then you can't use Haskell's type system to make this work: (from-roman mxmcmxviii).
10:08:12 <ricky_clarkson> s/mx//
10:08:23 <phobes> sjanssen: I'm thinking that you want macros to expose something like SYB
10:08:25 <coffeemug> nevertheless, Lisp's macros let you do some stuff stuff
10:08:32 <coffeemug> though sometimes they get very hairy
10:08:37 <byorgey> ricky_clarkson: heh, why would you want to?
10:08:38 <sjanssen> from_roman "mxmcmxviii" -- works fine
10:08:40 <puusorsa> stuff stuff?
10:08:45 <ricky_clarkson> byorgey: Because it's fun.
10:08:52 <coffeemug> some awesome stuff :)
10:08:55 <ricky_clarkson> sjanssen: Yes, but is it checked at compile time?
10:09:26 <xerox> ricky_clarkson: yes you can
10:09:43 <EvilTerran> you could do from_roman M(X(M(C(M(X(V(I(I(I(Z))))))))))
10:09:55 <sjanssen> ricky_clarkson: no, but we can do it with a slightly different syntax
10:09:55 <phobes> because that's just as good :)
10:10:08 <EvilTerran> and lispers would love it! just look at all those parentheses!
10:10:10 <jmelesky> ricky_clarkson: wouldn't that be compile-time-checkable with dependant types?
10:10:20 <xerox> ricky_clarkson: imagine mxmcmxviii = undefined :: whatevilterransays and then use my http://haskell.org/haskellwiki/Roman_numerals (-:
10:10:21 <lambdabot> Title: Roman numerals - HaskellWiki
10:10:22 <ricky_clarkson> jmelesky: Yes.
10:10:32 <coffeemug> I'd much rather see support for better introspection in Haskell
10:10:49 <coffeemug> optional/keyword arguments made easy
10:10:52 <coffeemug> symbol type
10:10:59 <coffeemug> exposed to the programmer
10:11:09 <EvilTerran> a Symbol type would be nice
10:11:13 <xerox> Maybe... with TH can we see the name of a symbol?
10:11:17 <phobes> coffeemug: Yes, that's what I'm arguing for as well
10:11:27 <phobes> code as data
10:11:28 <lament> (from-roman mxmcmxviii) is exactly the kind of example of the use of macros that makes me happy haskell doesn't have them :)
10:11:37 <coffeemug> well, not so much code as data
10:11:41 <coffeemug> though that would be nice
10:11:48 <ddarius> A symbol is just an interned string or just a nonce.
10:11:52 <ricky_clarkson> I use symbols in lisp, sure, but I don't know why they are more useful than strings.
10:11:55 <coffeemug> if TH was integrated into compiler
10:12:04 <EvilTerran> data Foo = Foo; instance Symbol Foo where reify = "Foo"?
10:12:15 <coffeemug> ricky_clarkson: by themselves they are not
10:12:18 <EvilTerran> ricky_clarkson, performance and syntactic nicety, mostly
10:12:26 <phobes> Ideally, the language should have a tiny core and be defined through extension I think
10:12:31 <ddarius> -introspection- is easily supported by typeclasses and should NOT be polymorphic
10:12:42 <ddarius> phobes: Scheme is over there.
10:12:48 <ricky_clarkson> phobes: That's why I like Scheme.
10:12:57 <ddarius> Scheme is about the only language that does that effectively.
10:13:01 <lament> Scheme? You mean Forth :)
10:13:02 <coffeemug> ddarius: it should be generated automatically, though
10:13:03 <phobes> ddarius: ya, but the tiny core needs to be typed, imo
10:13:06 <EvilTerran> tcl!
10:13:12 <ddarius> coffeemug: IT is.
10:13:17 <lament> Brainfuck! Oh wait, you said extension.
10:13:32 <ricky_clarkson> phobes: Not if it lets you add types.
10:13:32 <puusorsa> lolcode!
10:13:38 <coffeemug> last time I looked it SYB didn't do it by default for some advanced cases
10:13:44 <EvilTerran> it's like lisp, only procedural! and everything's a string! and you really don't want to use it!
10:13:56 <phobes> ricky_clarkson:  Yes, it should let you add types... but there still needs to be a powerful underlying logic that's provably sound
10:14:01 <ricky_clarkson> phobes: If you decide to add types to a core, then you find a better representation for types it's hard to improve the language.
10:14:08 <lament> EvilTerran: so it's just like lisp, except procedural and everything's a string!
10:14:18 <glguy> lisp is a procedural language...
10:14:28 <EvilTerran> lament, or rather, it's just like lisp, except everything's a string!
10:14:40 <lament> hee
10:14:44 <phobes> ricky_clarkson: IMO the underlying "type system" or logic should be as powerful as ZFC
10:15:08 * EvilTerran doesn't like common lisp. scheme is acceptable, but clisp is ridiculous
10:15:18 <coffeemug> common lisp is nice
10:15:25 <coffeemug> it's big, ugly, inelegant, but nice
10:15:26 <coffeemug> :)
10:15:36 <ricky_clarkson> phobes: I'm reading about ZFC now - are there any programs that work but aren't provable in ZFC?
10:15:37 <EvilTerran> also, i want my type system to be prolog.
10:15:38 <lament> phobes: so what you want is haskell types + haskell expressions (only function application) + macros
10:15:58 <lament> amirite
10:15:59 <phobes> lament: with a more powerful underlying type system
10:16:03 <lament> oh, more powerful.
10:16:33 <phobes> ricky_clarkson:  Yes, by godel, but realistically almost all of mathematics can be done in ZFC
10:16:42 <sieni> ricky_clarkson: yes (assuming ZFC is consistent)
10:18:02 <ricky_clarkson> phobes: Should all programmers of said language have a mathematical background?
10:18:03 <coffeemug> I want my type system to know that if i :: Integer | i > 4, i < 10 and j :: Integer | i > 3, i < 7, then i * j :: Integer | i > 12, i < 70
10:18:30 <coffeemug> and I want to be able to extend it for user defined types
10:19:17 <phobes> ricky_clarkson:  No
10:19:32 <phobes> ricky_clarkson:  No more than everyone in the world should have a math background :)
10:19:51 <ricky_clarkson> phobes: Should you allow programs that might/will fail?
10:19:55 <ricky_clarkson> E.g., length [1..]
10:20:28 <coffeemug> your typesystem should be able to accommodate programs that "might" fail
10:20:32 <lament> everyone in the world should have a math background!
10:20:39 <coffeemug> if it's powerful enough you won't have the "might" category
10:20:52 <ricky_clarkson> Ignoring the halting problem.
10:21:05 <lament> Ignoring the halting problem, "length [1..]" doesn't fail.
10:21:05 <hpaste>  pchiusano pasted "odd bug" at http://hpaste.org/2483
10:21:15 <coffeemug> length [1..] doesn't fail
10:21:18 <coffeemug> it just doesn't terminate
10:21:47 <coffeemug> what if you want to print integers for as long as the process is running?
10:21:53 <coffeemug> then print [1..] isn't a failure
10:21:58 <coffeemug> not a type system related issue anyway
10:22:03 <EvilTerran> codata!
10:22:11 <EvilTerran> that's type-system related
10:22:47 <EvilTerran> ...i'm detecting a distinct lack of main() in this .hc file.
10:22:54 <pchiusano> I just posted details on a bug that I am having... I think it may be due to me not understanding haskell laziness correctly
10:23:03 <ricky_clarkson> phobes: While it doesn't seem that ZFC will be obsoleted any time soon it might be the case that existing representations of it are deemed suboptimal in the future.
10:23:04 <pchiusano> or it might be something else..
10:23:16 <pchiusano> http://hpaste.org/2483
10:23:33 <phobes> ricky_clarkson:  Ya, I think I said it should be as strong as ZFC
10:23:35 <ricky_clarkson> phobes: If you look at the long-lived languages, like C and Lisp, they tend not to be overly opinionated.
10:23:37 <pchiusano> if anyone wants to take a look
10:23:59 <phobes> ricky_clarkson:  I think something you can get something that strong with lambda and forall
10:24:49 <phobes> ricky_clarkson:  ya, making a language popular is a whole different topic
10:25:40 <oerjan> pchiusano: seems like the problem must be in simplify
10:26:27 <johnnowak> ricky_clarkson: languages that have been around for awhile also tend to have their opinions look less outside the norm
10:26:39 <phobes> ricky_clarkson:  Actually, ZFC is probably stronger than what I'm thinking of... I doubt it proves choice.   But I think that just constructive math isn't enough
10:26:39 <pchiusano> oerjan: yes, it  does seem like that...
10:26:40 <ricky_clarkson> You could take Java as a case study - a language that seemed to fit with what a lot of people wanted at first, but effectively it was a paradigm-specific language, where the paradigm was "half-hearted object-orientated programming".
10:26:55 <oerjan> pchiusano: could you include the definition?
10:27:09 <phobes> ricky_clarkson:  or "verbose programming"
10:27:19 <ricky_clarkson> phobes: C is quite verbose too.
10:27:25 <phobes> true
10:27:57 * ricky_clarkson goes off to teach some people to move attractively to music.
10:28:34 <lament> ooh what kind of music?
10:33:00 <sciolizer> Hi all
10:33:03 <sciolizer> Is this still open?
10:33:05 <sciolizer> http://haskell.org/haskellwiki/Open_research_problems
10:33:06 <lambdabot> Title: Open research problems - HaskellWiki
10:33:20 <sciolizer> (There's only one research problem on there.)
10:33:51 <mrd> I don't think it's closed.  There are some papers to read.
10:34:07 <sciolizer> mrd: where can I find them?
10:34:55 <oerjan> pchiusano: just in case you didn't notice, you forgot to paste the code for simplify
10:34:59 <mrd> ?go more haste less speed
10:35:01 <lambdabot> http://www.phrases.org.uk/bulletin_board/22/messages/445.html
10:35:01 <lambdabot> Title: more haste, less speed
10:35:07 <mrd> heh nvm that
10:35:17 <sciolizer> heh, ok
10:35:20 <shapr> Lemmih: Yeah, see #happs for more detail.
10:35:22 <dcoutts_> nominolo: ping
10:35:22 <mrd> need a scholar.google.com bot command
10:35:31 <hpaste>  pchiusano annotated "odd bug" with "(no title)" at http://hpaste.org/2483#a1
10:35:39 <mrd> http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=44113
10:35:42 <lambdabot> Title: CJO - Abstract - More haste, less speed: lazy versus eager evaluation, http://tinyurl.com/34ph2r
10:35:47 <pchiusano> oerjan: I just added that code
10:35:54 <mrd> what's the bot command to give a feature suggestion?
10:36:46 <oerjan> mrd: @todo
10:36:49 <pchiusano> oerjan: that is not exactly it, but
10:36:57 <sciolizer> mrd: ah yes, I think I remember that paper being announced on lambda-the-ultimate
10:37:01 <pchiusano> that is the idea
10:37:32 <mrd> @todo scholar.google.com search
10:37:32 <lambdabot> Plugin `todo' failed with: IRCRaised @todo has no args, try @todo-add or @list todo
10:37:37 <mrd> @todo-add scholar.google.com search
10:37:37 <lambdabot> Entry added to the todo list
10:38:26 <hpaste>  pchiusano annotated "odd bug" with "oop, forgot a case" at http://hpaste.org/2483#a2
10:39:04 <sciolizer> mrd (or anybody): Anyway, here's the real reason I ask: I am taking a "Research in CS" class this semester, and I need to find a topic.
10:39:11 <sciolizer> I'm a senior in undergraduate study.
10:39:23 <oerjan> pchiusano: what does show (simplify (toCells (tail rules)) rules) give?
10:39:32 <sciolizer> I'm wondering what topics would be reasonable at my level for a semester.
10:39:49 <lament> phobes: what do you mean "expression is different from expression"?
10:39:52 <lament> err
10:40:03 <lament> pchiusano: what do you mean "expression is different from expression"?
10:40:07 <mrd> sciolizer: talk to a professor yet?
10:40:20 <lament> pchiusano: how are they different?
10:40:54 <sciolizer> mrd: yes. I'm not sure how much help he's going to be. Our interests are kind of divergent.
10:41:14 <oerjan> pchiusano: that's what show (simplify (Symbol "axioms") rules)
10:41:20 <oerjan> should simplify to
10:41:21 <pchiusano> lament: they are not the same string?
10:41:38 <mrd> sciolizer: "he"? there are multiple professors right?
10:41:42 <sciolizer> mrd: 2
10:41:48 <mrd> in your school?
10:41:49 <sciolizer> mrd: yeah
10:41:52 <lament> pchiusano: what do both expressions produce?
10:41:59 * mrd is confused
10:42:06 <sciolizer> mrd: 2 professors in the CS department
10:42:22 <mrd> I see
10:42:32 <jcpetruzza> hi
10:42:54 <sciolizer> mrd: I'd really like to do something in the functional programming world, possibly with type theory. Unfortunately, neither of these show up anywhere in the CS curriculum, so my professors can't really guide me on this.
10:43:07 <jcpetruzza> anyone know how to install gtk2hs on osx?
10:43:18 <dcoutts_> jcpetruzza: use macports
10:43:32 <mrd> sciolizer: but one of them will advise you?
10:43:33 <jcpetruzza> i tried macports, but it doesn't seem to work
10:43:37 <sciolizer> mrd: yes
10:43:40 <johnnowak> jcpetruzza: what's the problem?
10:43:42 <oerjan> pchiusano: with all respect it is horrendous to debug something when you are only given part of the problem.  please paste everything that could possibly be relevant.
10:43:47 <jcpetruzza> $ sudo port install gtk2hs
10:43:47 <jcpetruzza> Error: Unable to execute port: wrong # args: should be "proc name args body"
10:43:56 <johnnowak> heh, lovely
10:43:59 <johnnowak> is a maintainer listed?
10:44:05 <johnnowak> port show gtk2hs
10:44:18 <dcoutts_> jcpetruzza: or you can grab the tarball and install normally
10:44:26 <EvilTerran> huh.
10:44:39 <byorgey> sciolizer: you're supposed to actually do some original research yourself, or just report on current research in the field?
10:44:51 <sciolizer> byorgey: it could be either
10:44:59 <dcoutts_> @seen nominolo
10:44:59 <lambdabot> nominolo is in #haskell. I last heard nominolo speak 1d 21h 27m 1s ago.
10:45:00 <mrd> sciolizer: what's your background like, I guess, self-study-wise?
10:45:21 <pchiusano> oerjan: ya, I don't think this is going to work :)
10:45:49 <EvilTerran> okay, if i "gcc (...) -keep-hc-files test.hs", go into the .hc and re-shuffle the #includes into the right order, then run the same gcc line again, it works
10:45:59 <oerjan> pchiusano: er, i guess the <more axioms> is huge?
10:46:03 <sciolizer> mrd: haphazard, really. I'm also a math major. I frequently read papers from programming.reddit.com. :)
10:46:06 <jcpetruzza> johnnowak: the maintainer is "gwright", but i can't find an email
10:46:27 <lament> oerjan: i was thinking obscene
10:46:28 <EvilTerran> if i try to compile, giving the modified .hc as input instead of the .hs, it fails with various confusing errors
10:46:32 <mrd> you could also approach math professors
10:46:36 <pchiusano> yeah, and simplify is actually more complicated (has variables, does unification, etc)
10:46:41 <EvilTerran> help?
10:46:51 <sciolizer> mrd: I know the Curry-Howard isomorphism, though I know nothing of category theory (so I don't get the Lambek part)
10:46:51 <johnnowak> jcpetruzza: gwright@macports.org -- let him know it's busted
10:46:57 <pchiusano> oerjan: I am just going to have to debug by myself
10:47:00 <pchiusano> :)
10:47:02 <jcpetruzza> dcoutts: i'll try the tarball, thanks
10:47:20 <jcpetruzza> johnnowak: thanks, i'll do
10:47:29 <johnnowak> jcpetruzza: much appreciated, thanks
10:47:47 <sciolizer> mrd: I've been reading a couple of books.
10:47:50 <mrd> sciolizer: maybe you could make a project out of learning more advanced stuff then
10:48:16 <sciolizer> mrd: That's kind of where I was going.
10:48:27 <sciolizer> mrd: What do you think about this:
10:48:33 <oerjan> pchiusano: in any case show (simplify (Symbol "axioms") rules) reduces to show (simplify (toCells (tail rules)) rules), which is not quite the same as your second expression
10:48:47 <mrd> you could recreate the proofs and explain them in your own words
10:49:00 <hpaste>  EvilTerran pasted "shuffling #include""s in .hc files" at http://hpaste.org/2484
10:49:07 <sciolizer> mrd: a paper comparing and constrasting the simply-typed lambda calculus, the calculus of constructions, Girard Reynolds System F, and Martin Lof's intuitionistic type theory
10:49:09 <mrd> maybe even think of some simple extensions
10:49:21 <pchiusano> oerjan: that is true
10:49:23 <sciolizer> mrd: or is that too much?
10:49:35 <pchiusano> aha!!
10:49:35 <mrd> that's mixing levels a bit
10:49:38 <sciolizer> mrd: ok
10:49:45 <pchiusano> oerjan: I am an idiot
10:49:58 <sciolizer> mrd: going along with what you said about recreating proofs in my own words, I had this other idea:
10:50:15 <sciolizer> mrd: which is probably outrageously crazy (given that I only have a surface knowledge of this)
10:50:46 <sciolizer> mrd: but the idea is to translate some well-known theorems into programs (Curry-Howard isomorphism style)
10:50:53 <EvilTerran> winalleg.h needs to be included before Stg.h, and allegro.h needs to be included before that. {-# INCLUDE #-} directives add included files below the Stg.h and HsBase.h
10:51:11 <mrd> sciolizer: that's effectively recreating the proof, yes
10:51:38 <mrd> sciolizer: you can explore the basis of various theorem proving systems like Coq, Twelf, Isabelle, ACL2, etc
10:51:53 <sciolizer> mrd: ok
10:52:37 <sciolizer> *sciolizer frantically writes down the names of the theorem proving systems
10:52:42 <sciolizer> *sciolizer needs to learn IRC commands
10:52:48 <sciolizer> mrd: I've played with Coq a little bit.
10:52:49 <pjd> sciolizer: /me
10:52:53 <johnnowak> sciolizer: you could take up painting
10:52:55 <sciolizer> mrd: but not with the others
10:52:58 <mrd> ?google coq wiki
10:53:01 <sciolizer> johnnowak: :)
10:53:01 <lambdabot> http://cocorico.cs.ru.nl/coqwiki
10:53:01 <lambdabot> Title: Cocorico!FrontPage - Cocorico!
10:53:02 <mrd> ?google twelf wiki
10:53:03 <lambdabot> http://fp.logosphere.cs.cmu.edu/twelf/
10:53:04 <lambdabot> Title: The Twelf Wiki | Main / Home Page
10:53:10 * sciolizer learns how to speak in the 3rd person
10:53:11 <sieni> /disco puts disco lights on
10:53:14 <mrd> err, http://twelf.plparty.org/wiki/
10:53:17 <lambdabot> Title: Main Page - The Twelf Project
10:53:48 <mrd> you could look at things like Djinn and Theorems-for-free
10:53:53 <mrd> @djinn a -> b -> a
10:53:54 <lambdabot> f a _ = a
10:55:16 <sciolizer> mrd: yeah, I've thought about that as well. Would you recommend sticking to Hindley-Milner (like I think djinn does), or would it be reasonable for me to look at other more powerful typing systems?
10:55:52 <sciolizer> mrd: I guess what I'm saying is that I don't know enough about djinn to know which directions I could run with it.
10:56:09 <mrd> well that runs into problems with Theorem proving which would itself be an interesting topic
10:56:31 <sciolizer> mrd: i.e. theorems-for-not-quite-free? :)
10:56:53 <mrd> do you have a copy of Pierce btw?
10:57:01 <sciolizer> Types and programming languages?
10:57:04 <mrd> yes
10:57:10 <sciolizer> Only a pdf of the table and contents
10:57:22 <sciolizer> I'll should probably buy it.
10:57:32 <sciolizer> s/table and contents/table of contents/
10:57:44 <mrd> yes.  the later chapters may give you some ideas too.
10:57:48 <sciolizer> ok
10:57:57 <mrd> try your library?
10:58:04 <sciolizer> already did
10:58:11 <mrd> nearby univ libraries?
10:58:21 <sciolizer> not yet, but now I will. :)
10:59:35 <augustss> sciolizer: what kind of well-known theorems did you have in mind for translating?
10:59:51 <sciolizer> augustss: ah yes, thank you for reminding me
11:00:13 <takamura> hi
11:00:16 <sciolizer> augustss: and please don't laugh at me if the idea sounds absurd/really difficult
11:00:38 <sciolizer> augustss: but one thing I was really curious last night was what a proof of the strong normalization of simply typed lambda calculus would look like in program form
11:00:43 <augustss> sciolizer: it can be difficult, but it's not absurd
11:01:32 <byorgey> hi takamura
11:01:52 <augustss> sciolizer: People have been using coq for these things
11:01:59 <sciolizer> augustss: oh ok
11:02:02 <takamura> do you know some function in some library to autocomplete text? (for GUI applications)
11:02:32 <takamura> given a list of strings, and some input characters, autocomplete the text
11:02:56 <takamura> when typing
11:03:20 <sciolizer> augustss: Is that something I am likely to find in "The Art of Coq"?
11:03:40 <sciolizer> augustss: er, coq'art
11:04:41 <mrd> sciolizer: it would correspond to an algorithm for evaluating simply typed terms
11:04:50 <ibid> anybody have a guess why cabal would install a Data-File with perms 600 instead of 660?
11:05:00 <ibid> (debian sid, up to date)
11:05:01 <mrd> sciolizer: this is actually covered in Pierce.
11:05:08 <sciolizer> mrd: ic. Fantastic.
11:05:35 <mrd> also, Twelf is a proof assistant designed with programming languages especially in mind.
11:05:47 <mrd> the "Proving metatheorems" tutorial uses the simply-typed lambda calculus as a case study.
11:05:51 <mattam> sciolizer: more likely in a paper, e.g. http://coq.inria.fr/contribs/tait.html
11:05:53 <lambdabot> Title: A normalization proof a la Tait for simply-typed lambda-calculus
11:06:24 <sciolizer> mattam: thank you
11:07:34 <mattam> Letouzey is the extraction guy of Coq so...
11:08:13 <sciolizer> mattam: ok. Does he ever come to #haskell. :)
11:08:27 <mattam> Nope, I don't think so.
11:09:01 <mattam> Come to #coq if you have related questions though :)
11:09:15 <sciolizer> mattam: Thanks, I will.
11:12:41 <sciolizer> Clearly I need to read up on these things, but this is what is going through my head right now: my final paper could be a reimplementation of various theorems in various theorem provers (this would allow me to compare some of the theorem provers, while at the same type learning about things I am interested in (like type systems) by reproving theorems about them)
11:12:43 <byorgey> takamura: I don't know of any
11:13:17 <sciolizer> It would probably be more of survey research than original research.
11:13:26 <byorgey> sciolizer: sounds interesting, I'd read it =)
11:13:41 <sciolizer> byorgey: Thanks. :)
11:13:43 <mattam> What's your current paper about ?
11:14:04 <sciolizer> mattam: I don't have a current paper. The semester is just beginning.
11:14:20 <mattam> Oh, so you _have_ to write one ?
11:14:23 <byorgey> sciolizer: choosing a good topic on which to do actual original research and get results that you could type up in a single semester would be very difficult
11:14:24 <sciolizer> mattam: yes
11:14:34 <sciolizer> byorgey: good point
11:14:36 <byorgey> (although not impossible)
11:14:53 <mattam> Who says you have to ?
11:15:20 <sciolizer> mattam: class requirement. The class I am taking is called "Research in CS".
11:15:30 <mattam> Ohoh. sounds right.
11:16:20 <mattam> Then you may find the course notes by yves bertot on PLT in Coq interesting to accompany tapl.
11:17:41 <mattam> http://coq.inria.fr/contribs-eng.html I wish I had that when I started Coq and PLT
11:17:42 <sciolizer> mattam: When I hear PLT, I think Scheme. I didn't know they were affiliated with Coq.
11:17:42 <lambdabot> Title: The contributions
11:17:56 <mrd> programming language theory
11:17:59 <sciolizer> oh ok
11:18:56 <mattam> http://www-sop.inria.fr/marelle/Yves.Bertot/cours-semantique2.html
11:18:58 <lambdabot> Title: Semantics of Programming languages (2nd unit), http://tinyurl.com/2mjaur
11:18:59 <mattam> better
11:20:07 <sciolizer> mattam: thanks
11:28:26 <sciolizer> The internet is truly wonderful. I feel like the things I have learned from online resources are more valuable than my 4 years of undergraduate CS.
11:29:20 <SamB> that's why I'm majoring in electrical engineering...
11:30:30 <johnnowak> sciolizer: that makes me feel better about not doing cs for my undergrad.
11:37:52 <byorgey> sciolizer: where do you go to school?
11:38:11 <sciolizer> byorgey: my last semester will be at Olivet Nazarene University
11:38:23 <sciolizer> For the last two years I was at Wheaton College.
11:38:31 <sciolizer> (Illinois, USA)
11:38:37 <byorgey> sciolizer: ok, cool
11:38:54 <byorgey> yes, I'm familiar with Wheaton although I hadn't heard of the other one
11:39:36 <byorgey> I know someone who is just starting his freshman year at Wheaton =)
11:39:43 <sciolizer> cool
11:40:23 <sciolizer> byorgey: is he studying CS?
11:40:39 <byorgey> sciolizer: not that I know of
11:40:45 <sciolizer> byorgey: ok. just curious
11:41:20 <byorgey> sciolizer: yeah, I know him from church, not from CS stuff =)
11:41:37 <lament> alonzo church?
11:41:44 <sciolizer> byorgey: ok
11:42:09 <byorgey> lament: heh, no, church as in religious institution =)
11:42:22 <lament> damn, that would've been cool
11:42:32 <byorgey> oh yes, also, I dated his daughter
11:42:40 <lament> right, haven't we all.
11:42:42 <byorgey> =)
11:42:50 <monochrom> hahahahahaha
11:44:07 <takamura> byorgey: thanks aniway
11:44:44 <Saizan> (is there something about church's daughter i didn't get?)
11:45:45 <sjanssen> 21111
11:45:52 <lament> Saizan: reddit meme
11:50:49 <sciolizer> Thanks everyone for your help. I'm leaving to get Pierce's TAPL through interlibrary loan.
11:52:33 <sorear> .
11:52:52 <monochrom> Yes? You want to date someone's daughter too? :)
11:58:01 <lament> monochrom: perhaps not Church's :)
11:58:36 <Saizan> mmh Data.Map.fold doesn't seem lazy as it could..
11:59:02 <fxr> @pl concatMap (\x -> (printf "./add-ns %s %s\n" dname x)) servers
11:59:02 <lambdabot> printf "./add-ns %s %s\n" dname =<< servers
12:18:22 <coffeemug> I have a question
12:18:31 <coffeemug> I don't understand where memoization comes from in this: fib = 1 : 1 : zipWith (+) fib (tail fib)
12:18:47 <coffeemug> first two elements of the list are easy
12:18:58 <coffeemug> on third we get sume of first and second
12:19:49 <coffeemug> but why is it that when we try to calculate fourth element, we don't go through the list again?
12:20:46 <phobes> because fib is only computed once in fib and in (tail fib) maybe?
12:21:29 <arjanb> have you taken a look at the zipwith implementation?
12:21:30 <coffeemug> hmm
12:21:38 <coffeemug> yes
12:21:43 <coffeemug> ?src zipWith
12:21:43 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:21:43 <lambdabot> zipWith _ _      _      = []
12:22:28 <coffeemug> hmm
12:22:32 <phobes> Have you looked at how expressions are reduced as graphs?
12:22:32 <coffeemug> actually this makes sense
12:22:45 <LXIX> hi
12:22:50 <phobes> 'fib' is a single node in that graph I think
12:23:12 <coffeemug> sorry, I confused it with my implementation of lazyness that I am doing in CL
12:23:14 <phobes> so when you compute that it starts with 1 : 1, you never do that again
12:23:20 <shapr> hiya LXIX
12:23:29 <coffeemug> this makes sense
12:23:35 <phobes> so the computation will be:  fib = 1: 1 :[...]
12:23:43 <phobes> then fib = 1: 1 : 2 : [...]
12:23:47 <phobes> etc
12:24:19 <coffeemug> yeah
12:25:43 <phobes> I wonder if the compiler could compute 'fib 100' in constant space though?
12:26:02 <coffeemug> constant space
12:26:09 <coffeemug> but you don't throw away those first elements in the list
12:26:10 <phobes> well, fib n
12:26:15 <Botje> use the 1+-sqrt(5)/2 trick
12:26:36 <Botje> but that's cheating
12:26:48 <phobes> ya that's constant time too
12:27:02 <phobes> I'm guessing the compiler won't figure that one out :)
12:27:18 <augustss> phobes: you can compute fib 100 in constant space with the zipWith definitions
12:27:33 <coffeemug> unless you teach it some number theory :)
12:27:47 <augustss> constant in the sense that heap usage doesn't increase
12:27:47 <EvilTerran> augustss, surely the earlier elements of the list won't be freed?
12:27:59 <augustss> EvilTerran: why not?
12:28:02 <sorear> you can't compute fib(n) in constant space!
12:28:20 <sorear> fib(n) has log2(phi) * n digits
12:28:23 <augustss> sorear: ignoring the size the numbers take, of course :)
12:28:28 <coffeemug> fib(n) meaning nth element of fib sequence
12:28:40 <coffeemug> ahh
12:28:41 <coffeemug> :)
12:29:14 <coffeemug> hmm, I implemented lazyness by wrapping constructor arguments in closures and unwrapping them only at pattern matching
12:29:22 <coffeemug> but that still gives me exponential time
12:29:29 <EvilTerran> augustss, okay, i was thinking in terms of having "fibs = ..." as a toplevel. i guess if you phrase it in such a way that it's clear that there're no further references to the list, it could get optimised away
12:29:32 <EvilTerran> or at least freed
12:29:45 <coffeemug> because pattern matching doesn't replace the original closure with a value once its been lazily calculated
12:30:05 <sorear> coffeemug: you need to memoize 0-argument functions to have true laziness, otherwise it's just call-by-name
12:30:11 <augustss> EvilTerran: yes, if there's no further reference th list can be GCed
12:30:29 <coffeemug> sorear: yes, of course
12:30:33 <SamB> coffeemug: see, you need mutation
12:30:36 <coffeemug> for some reason I just skipped that part
12:30:53 <coffeemug> well, I don't *need* mutation
12:31:06 <coffeemug> only if I want O(n) time for some infinite list operations :)
12:31:12 <augustss> coffeemug: only if you want call-by-need
12:31:25 <sorear> @go Pure versus Impure LISP
12:31:27 <lambdabot> http://citeseer.ist.psu.edu/pippenger96pure.html
12:31:28 <lambdabot> Title: Pure versus Impure Lisp - Pippenger (ResearchIndex)
12:32:20 <sorear> shunning mutation makes code *asymptotically* slower
12:32:29 <coffeemug> the abstract seems wrong
12:32:40 <coffeemug> it says only impure systems can have circular lists
12:32:43 <coffeemug> that doesn't seem right
12:32:57 <coffeemug> in Haskell I can fake a circular list by making an infinite periodic list
12:32:59 <SamB> coffeemug: well, this is lisp
12:33:06 <coffeemug> and the program will never tell the difference
12:33:06 <SamB> pure lisp is probably strict
12:33:10 <sorear> it is
12:33:24 <BobFunk> hmm, my vpn slice really doesn't like compiling HXT :/
12:33:24 <coffeemug> not my pure extension to CL :)
12:33:28 <SamB> you can't make a circular datastructure in a pure strict language...
12:33:33 <SamB> coffeemug: that's different ;-P
12:33:34 <coffeemug> right
12:33:45 <BobFunk> are there any binary packet with hxt for debian?
12:33:59 <sorear> apt-cache show libghc6-hxt-dev
12:34:05 <sorear> if it exists, that will tell you
12:34:06 <coffeemug> hmm
12:34:12 <sorear> they have standard names
12:34:22 <coffeemug> another problem I'm running into is that my pattern matching is a bit too strict
12:34:31 <coffeemug> so if I match a constructor
12:34:36 <coffeemug> all of its fields are evaluated
12:34:40 <coffeemug> it works for some stuff
12:34:47 <coffeemug> but doesn't work for zipWith fib definition
12:34:59 <BobFunk> W: Unable to locate package libghc6-hxt-dev
12:34:59 <BobFunk> E: No packages found
12:35:01 <BobFunk> :(
12:35:21 <coffeemug> unfortunately farematcher library isn't easy to modify to make a lazier matcher :(
12:35:33 <coffeemug> implementing this stuff is really cool though
12:35:38 <coffeemug> makes me understand haskell better :)
12:37:06 <BobFunk> well - hope the 4 hours my poor slice has been non-stop compiling is actually getting it somewhere!
12:42:07 <tautologico> what happened to the old hawiki?
12:42:23 <sorear> obsoleted by haskellwiki
12:42:28 <shapr> It died a horrible death, bits were flung everywhere.
12:42:50 <shapr> hei Japsu
12:42:59 <nominolo> dcoutts_: pong
12:43:03 <Japsu> hi shapr
12:43:11 <Japsu> hopefully this was tonight's last reboot
12:43:23 * Japsu is messing with his brand new sound card
12:43:27 <tautologico> but there were things there, like the old issues of the monad.reader
12:43:33 <dcoutts_> nominolo: I was wondering what cabal tasks you were looking at at the moment, I've got a reasonably important one...
12:43:43 <shapr> tautologico: swiert is going to recreate those.
12:43:48 <nominolo> which one?
12:43:57 <dcoutts_> nominolo: though I guess it can wait 'til after the ghc-6.8 fork
12:43:57 <nominolo> haddock2?
12:44:00 <shapr> Does :: have a precedence?
12:44:03 <dcoutts_> nominolo: cabal-install
12:44:14 <nominolo> oh, yeah.
12:44:18 <dcoutts_> nominolo: it needs updating to understand configurations, at least minimally
12:44:38 <dcoutts_> nominolo: I've made it build, but it currently gets empty build-depends
12:44:42 <nominolo> i know, it'll require a bit of an effort, though
12:44:49 <nominolo> ah
12:45:04 <dcoutts_> since it's naively extracting the PackageDescription from the GenericPackageDescription
12:45:17 <dcoutts_> rather than finalising the configuration
12:45:21 <nominolo> yes, it needs to use Cabal for this
12:45:27 <dcoutts_> yes
12:46:00 <nominolo> I was trying to move the build-tools into the sections, but that required quite a bit of refactoring
12:46:15 <nominolo> and i'm still not sure this is gonna work
12:46:19 <dcoutts_> nominolo: that's probably more important
12:46:40 <dcoutts_> than making cabal-install work now, since the build-tools is a cabal api change
12:46:48 <nominolo> also, it's in PackageDescription.hs, so it's probably best if I'd do it
12:46:54 <dcoutts_> aye
12:47:32 <sorear> shapr: Lower than all infix operators.
12:59:09 <dcoutts_> nominolo: so what makes putting build-tools into the sections difficult?
12:59:34 <nominolo> my bad abstractions of partial package descriptions
12:59:41 <dcoutts_> ok :-)
12:59:42 <dcoutts_> we don't have to backtrack on the basis of their availability of course
13:00:11 <nominolo> i'm changing the field descriptors to return modifiers now
13:00:51 <EvilTerran> hm... do #define/#undef nest?
13:01:15 <nominolo> the best solution would have required existentials, but the current trade-off should work
13:01:17 <dcoutts_> nominolo: ok, have fun, I gotta go out :-)
13:01:17 <EvilTerran> i know this is a C question, but i'm hacking about with the FFI, so it's vaguely relevant.
13:01:26 <nominolo> dcoutts_: thx, hf
13:01:39 <nominolo> EvilTerran: yes
13:02:08 <EvilTerran> great
13:02:16 <nominolo> ah, you mean if #undef undefines the next local binding?
13:02:44 <nominolo> no, sorry misunderstood the question ..
13:03:02 <EvilTerran> =/
13:03:17 <nominolo> afaik, #define is always global
13:03:35 <nominolo> there're no namespaces in cpp
13:03:44 <EvilTerran> i want to know, if i #define FOO bar...#define FOO baz...#undefine FOO...FOO, whether that instance of FOO at the end will be FOO or bar?
13:03:55 <EvilTerran> *#undef
13:04:05 <Heffalump> FOO.
13:04:11 <nominolo> the second #define will override the former
13:04:11 <EvilTerran> bah.
13:04:32 <Heffalump> shame there's no way to parse a list, or you could make a stack of old values
13:04:44 <Heffalump> if you know the maximum depth you could do that anyway
13:06:36 <EvilTerran> i don't have control over the placement of the second #define. i'm including a header that #includes another header, wrapped in a #define/#undef pair, and i want my definition of the #define to be in effect after the #undef as well as before the #define
13:08:56 <glen_quagmire> what's a good book for numerical methods?
13:11:58 <sieni> glen_quagmire: what kind of numerical methods?
13:12:34 <glen_quagmire> FFT, gaussian elimination, structured matrices..etc
13:13:22 <glen_quagmire> textbook is http://www.amazon.com/Numerical-Methods-Applications-Laurene-Fausett/dp/0130314005   which is quite expensive
13:13:24 <byorgey> EvilTerran: my advice: run far, far away
13:13:26 <lambdabot> http://tinyurl.com/2p93v8
13:14:10 <sieni> glen_quagmire: what about that: http://www.nr.com/aboutNR3book.html
13:14:11 <lambdabot> Title: About Numerical Recipes
13:14:57 <sieni> at least the earlier editions have been a classic
13:15:10 <glen_quagmire> wasn't that a free book before sieni ?
13:15:23 <EvilTerran> byorgey, i agree. i took up haskell to do haskell, not C.
13:15:56 <sieni> glen_quagmire: the older books are available on-line: http://www.nr.com/oldverswitcher.html
13:15:57 <lambdabot> Title: Numerical Recipes Books On-Line
13:16:19 <dmead_> > 1.32 == 1.3
13:16:20 <lambdabot>  False
13:16:24 <dmead_> > 1.32 == 1.3000000000000
13:16:25 <lambdabot>  False
13:16:31 <dmead_> > 1.30000000000000000000002 == 1.3000000000000
13:16:32 <lambdabot>  True
13:17:01 <glen_quagmire> sieni: thank you
13:19:27 <Procyon112> EvilTerran: I believe redefinining FOO without undef'ing it first is vendor specific.  At any rate, I don't believe any implementation will nest the values so that 1 undef will set it to its previous value.
13:19:44 <LXIX> why 1.30000000000000000000002 == 1.3000000000000 returns true? (sorry haskell newbie :p)
13:19:59 <sorear> Because Double is evil
13:20:01 <monochrom> "double" cares about only so many bits.
13:20:06 <LXIX> ah
13:20:10 <monochrom> You will get the same in C, Java, ...
13:20:25 <LXIX> yeh so double is evil
13:20:40 <olsner> not evil, just special
13:20:41 <idnar> hooray IEEE 754 floating-point
13:20:48 <Procyon112> LXIX: never use == and doubles... in *any* language.
13:20:55 <Saizan> (btw, ne number of zeros in 1.300000 is irrelevant)
13:21:06 <Saizan> s/ne/the/
13:21:06 <LXIX> yes Saizan
13:21:07 <monochrom> Google for "What Every Computer Scientist Should Know about Floating-Point Arithmetic" by David Goldberg.
13:21:15 <LXIX> k
13:22:58 <monochrom> Sometimes == for floating point makes sense. Try to understand floating point itself and draw your own conclusion. Don't adhere to "rule of thumbs" which are only 90% right.
13:23:31 <glen_quagmire> on windows vista, how can I add GHCi right context menu on folders?
13:23:40 <geezusfreeek> > 13000000000000000000000000%10000000000000000000000000 == 13%10
13:23:41 <lambdabot>  True
13:23:46 <geezusfreeek> > 13000000000000000000000002%10000000000000000000000000 == 13%10
13:23:47 <lambdabot>  False
13:24:12 <sorear> geezusfreeek: geez, just use numeric literal overloading :)
13:24:19 <geezusfreeek> :)
13:24:27 <sorear> > 1.3000000000000000000000000000000000000000000002 == (1.3 :: Rational)
13:24:29 <lambdabot>  False
13:25:41 <monochrom> One case when == for floating point makes sense is when you use Double as 50-bit integers.
13:26:35 <gvdm_other> monochrom: can you remember off by heart how many bits go to the exponent, sign, etc?
13:26:46 <Procyon112> Using a double as a fifty bit integer is just naughty.
13:26:54 <geezusfreeek> Procyon112, why?
13:26:59 <gvdm_other> IEEE 754, if i remember correctly
13:27:29 <monochrom> No. I only remember Float (single precision) is about 23 bit mantissa, Double is about 53 bit mantissa. I may be off by 1. I don't remember others. Oh, the sign bit is just 1 bit. :)
13:27:47 <gvdm_other> http://en.wikipedia.org/wiki/IEEE_754
13:27:50 <lambdabot> Title: IEEE 754 - Wikipedia, the free encyclopedia
13:27:55 <gvdm_other> 52 bits
13:28:10 <Procyon112> geezusfreeek: because it makes me feel dirty and makes the compiler sad :)
13:28:18 <monochrom> There is this "implicit 1" which skews the number of bits in the mantissa.
13:28:21 <gvdm_other> wow, comp203 comes in handy
13:28:49 <geezusfreeek> sad compiler?
13:29:01 <gvdm_other> monochrom: i know, the whole thing is really a fraction of sorts, eg, 1/2 + 1/4 + 1/8 etc
13:29:12 <monochrom> Yeah, I wonder why students don't take advantage of their education.
13:29:16 <Japsu> Ngh
13:29:29 * Japsu just remembered a point in code where he used == and doubles
13:29:33 <gvdm_other> (with the 1/1 being implicit)
13:29:39 * Japsu was supposed to fix it but forgot
13:30:27 <monochrom> When students are taught a course, their energy is mostly spent on whining about it and trying to forget it as soon as the exam is over.
13:30:39 <Japsu> muah
13:30:47 <Japsu> sounds just like a course I just begun today
13:31:06 <monochrom> Then they run into a floating-point program and they need the course anyway.
13:31:11 <Japsu> the lecturer spent the whole opening lecture complaining about how lazy and stupid the students have gotten over years
13:33:19 <monochrom> They are clearly not lazy and stupid, if they put in so much effort into whining and forgetting. It takes much smart and hard work to forget.
13:33:57 <SamB> if you ask me, putting so much work into forgetting is incredibly stupid
13:34:10 <gvdm_other> i find my comp courses interesting, so i put in the effort anyway
13:35:03 <Japsu> The lecture was motivating in a bizarre way. It made me want to prove the lecturer wrong on my behalf!
13:35:18 <monochrom> Ha! Nice. I should contemplate that.
13:35:28 <Japsu> :)
13:36:14 <gvdm_other> monochrom: you lecture? where?
13:36:28 <monochrom> Not any more.
13:36:41 <monochrom> But I'm always interested in education.
13:38:40 <Saizan> what can i do to have toDescList exposed from Data.Map? a Proposal: to libraries@?
13:39:22 <monochrom> I believe yes.
13:39:34 <monochrom> They may also welcome proposed code.
13:40:10 <Saizan> proposed code is a line in the export list
13:40:38 <monochrom> Oh hahaha.
13:41:17 <Saizan> yeah, quite funny as a "proposal" :D
13:42:51 <JohnMeacham> shapr SamB sorear: I just checked in som reworking of the library code. basically some groundwork for my future changes,  but libraries should work again. also, now it doesn't rely on file timestamps at all and uses SHA1 hashes for all dependency checking. this brings up the intruiging possibility of making a ho-cache, so if you compile the exact same source file it will automatically share previous compilations.
13:43:11 <shapr> spiffy
13:43:20 <sorear> nice.
13:43:39 <opqdonut> :D
13:43:39 <opqdonut> nice
13:43:56 <shapr> JohnMeacham: Only changes in the jhc repo? Or do I need to pull everything?
13:44:16 * shapr just pulls everything
13:44:18 <JohnMeacham> shapr: just the jhc repo.
13:44:24 <Procyon112> I giggle at the term "ho-cache".
13:44:25 <JohnMeacham> what do you mean by everything?
13:44:37 <JohnMeacham> I also have 'make ho-clean' now.
13:45:13 <shapr> JohnMeacham: Just curious if I needed to pull the other repos.
13:45:23 <Heffalump> anyone know if the HaskellDB test suite is expected to build?
13:45:30 <JohnMeacham> the premade libraries should work again too.
13:47:32 <shapr> JohnMeacham: I do wonder if jhc would be faster if compiled with itself :-)
13:47:45 <shapr> It'd be a cute way to get a Haskell compiler as ANSI C too.
13:48:57 <Nafai> Are any of the Haskell compilers self-hosting?
13:49:18 <shapr> Ok, jhc is built, now building libs.... eek! It's using 4GB of ram!
13:49:27 <shapr> Nafai: GHC is self-hosting.
13:49:51 <sorear> Nafai: As is NHC
13:50:04 <shapr> What about hbc?
13:50:05 <Botje> .oO(nintendo haskell compiler?)
13:50:11 <sorear> Nafai: HBC is pseudo-self-hosting
13:50:24 <shapr> Botje: Yeah, as opposed to phc for the playstation.
13:50:32 <pgavin> @seen dcoutts
13:50:32 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 8h 49m 38s ago.
13:50:35 <Botje> now we need a phd and we're all set. :)
13:50:50 <sorear> shapr: HBC is written in Lazy ML, so it can only be compiled with versions of itself prior to the frontend changes (when it became a Haskell compiler)
13:50:52 <|Jedai|> Hello, has anyone here solved the problem 51 of project euler ?
13:51:17 <shapr> Botje: Have you seen pH by Jan-Willem Maasen?
13:51:25 <glguy> jedai: I have
13:51:36 <sorear> Botje: Nearly a Haskell Compiler
13:51:52 <byorgey> jedai: I have also
13:51:52 <sorear> @go Niklaus RÃ¶jemo A space-efficient haskell compiler
13:51:54 <lambdabot> http://research.microsoft.com/users/daan/download/papers/parsec-paper.pdf
13:52:04 <jedai> glguy: Ok, it seems I'm doing something wrong, could you tell me if your solution was superior or inferior to 100109 ?
13:52:06 * shapr deletes all .ho files and rebuilds.
13:52:16 <glguy> jedai: my solution was better than that
13:52:21 <byorgey> hehe
13:52:36 <Botje> shapr: no, what is it? I've been working on my project for the last month or so.
13:52:39 <jedai> glguy: better ? You mean smaller ?
13:52:39 <sorear> So, when can we expect JHC to run in 384MB?
13:52:40 <sorear> :)
13:52:55 <shapr> Botje: pH is a strict parallel Haskell, it's interesting.
13:53:04 <Botje> ah
13:53:05 <Botje> cool
13:53:09 <Excedrin> JohnMeacham: did you ever check why that fibonacci code results in <<loop>> with jhc?
13:53:16 <shapr> Distributed GC is a nifty subject.
13:53:25 <byorgey> jedai: I think glguy meant "better" as in "more correct" =)
13:53:52 <JohnMeacham> Excedrin: no, I have not got a chance to.
13:53:54 <byorgey> jedai: my solution was larger than yours
13:54:19 <JohnMeacham> Excedrin: where was it again?
13:54:31 <glguy> jedai: you can't replace the first digit of 101 with a 0 and get 1
13:54:53 <jedai> byorgey: Ok, which means I'm probably doing something wrong (really wrong, not just ommiting possibility
13:55:14 <Botje> is there some kind of rss feed for interesting papers?
13:55:27 <Botje> i'm going by mostly on what gets pasted here and on LtU
13:55:31 <jedai> glguy: I thought I avoided this, Oh just checked... it was a stupid mistake (lack a -1...)
13:56:50 <shapr> Botje: I wish
13:56:58 <shapr> Botje: We should start one :-)
13:57:33 <shapr> If I ever get these mysterious typeclass problems fixed in FLM, maybe that would be a good platform.
13:57:38 <jedai> glguy: Well still wrong but better... ;)
13:58:36 <shapr> @users
13:58:37 <lambdabot> Maximum users seen in #haskell: 392, currently: 373 (95.2%), active: 27 (7.2%)
13:59:13 <Botje> .oO(a reddit for papers would be nice)
14:00:35 <Excedrin> JohnMeacham: http://haskell.org/haskellwiki/The_Fibonacci_sequence the "fastest fib" one
14:00:36 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
14:00:54 <shapr> JohnMeacham: Is there a summary of new changes?
14:01:10 <JohnMeacham> 'darcs changes'
14:01:13 <shapr> heh
14:02:19 <JohnMeacham> I vaugely sort od started a page on it... if anyone wants to help flesh it out, that would be great. http://haskell.org/haskellwiki/Jhc
14:02:21 <lambdabot> Title: Jhc - HaskellWiki
14:06:43 <[1200MicS]> hello, i have an .key file with header "BEGIN RSA PRIVATE KEY", and i know the private password... how i can access the informations of the file?
14:07:27 <opqdonut> the key file has no information as such
14:07:39 <sieni> [1200MicS]: perhaps a bit offtopic, but using ssh-keygen
14:08:46 <sieni> [1200MicS]: assuming you want to get a key file without a passphrase
14:09:07 <[1200MicS]> i have the pass =]
14:09:19 <[1200MicS]> i'm finding about openssl x509, right way?
14:09:32 <Heffalump> the right way is not to ask on #haskell..
14:10:28 <[1200MicS]> ok, cool. but i really didn't know where ask, thanks all ;]
14:10:40 <monochrom> You likely have to brute-force it.
14:11:07 <[1200MicS]> monochrom i have the file and a "passphrase", i just i'm searching how i decrypt it =)
14:11:30 <Heffalump> all you'll do is turn it into a private key with no passphrase, surely?
14:11:45 <sieni> monochrom: if you know the passphrase, then you can change the passphrase to empty using ssh-keygen
14:11:50 <Heffalump> which, while technically "decryption", is unlikely to be particularly useful
14:11:52 <monochrom> If the manual says, "if you lose ___, you can't recover it, honest!" it means you have to brute-force it or wait for a genius to make a theoretical breakthrough.
14:12:05 <monochrom> But then, who reads manuals these days?
14:12:21 <[1200MicS]> the .key file isn't pure-text encrypted? o.O
14:12:23 <monochrom> Even here in #haskell, not many people have read the Haskell manuals.
14:12:40 <Heffalump> monochrom: but [1200MicS] has the passphrase, and the private key file..
14:12:44 * sorear has, and is pretty sure nobody else has
14:12:57 <Heffalump> sorear: what, all of them? Can you define the set?
14:13:14 <monochrom> That set is not recursively enumerable :)
14:13:15 <Heffalump> [1200MicS]: I imagine it's just an RSA private key, like it says at the top.
14:13:24 <Heffalump> of course it is, it's finite..
14:13:32 * SamB read some of the report
14:13:48 <Heffalump> I've read most of the report and the GHC docs at one time or another, but I have a memory like a sieve
14:13:54 <Olathe> What function prints a number, list, or string to the screen ?
14:13:54 <sorear> Heffalump: The GHC User's Guide, the Report, the library haddock, the darcs manual...
14:14:02 <sorear> Olathe: print
14:14:33 <monochrom> stdout is not always screen
14:14:33 <Olathe> Ahh, thanks.
14:14:41 <Olathe> Right.
14:14:42 <sjanssen> I wonder why [1200MicS] decided to ask #haskell
14:14:49 <monochrom> oh, it is not an exam of how much I have read the manuals! :)
14:15:01 <Olathe> I was wondering why print didn't work, but I was accidentally passing it a function.
14:15:08 <sieni> sjanssen: he has been listening too much bad psy-trance
14:15:27 <Heffalump> what does the darcs manual have to do with it?
14:16:20 <sorear> I always read manuals for new software I'm using.  The whole things.
14:16:49 <Heffalump> do you have a lot of spare time? :-)
14:17:01 <Heffalump> though I meant what does it have to do with "the Haskell manuals"
14:18:50 <monochrom> I don't call that spare time. I call that investment.
14:19:23 <Heffalump> spare in the sense of not having higher-priority demands on it
14:19:42 <Heffalump> not in the sense of time to waste, cos it's obviously not a waste
14:19:44 <monochrom> Priorities can be fudged.
14:19:56 <Olathe> Are there any ghc switches that speed up compilation ?
14:19:58 <Laney> How can I add an Element as a child of another Element using HaXml?
14:20:17 <Heffalump> well, I can't really spend much less time sleeping or working.
14:20:29 <Heffalump> which takes up a fairly large proportion of my life
14:20:32 <xerox> Interesting, my dictionary has got "archaic nonsense" for fudged (-:
14:20:38 <Heffalump> but I'm also too lazy
14:20:51 <Heffalump> Olathe: not beyond -O0, which is the default anyway
14:21:12 <Heffalump> you could run under ghci
14:21:32 <monochrom> There is a vicious cycle somewhere, I hope you see.
14:22:04 <Olathe> Alright, thanks.
14:22:15 <SamB> Heffalump: what you need to do is call it work
14:22:52 <Heffalump> not really, I know enough about where to look when I need to. Having the knowledge at my fingertips might sometimes help me make connections I wouldn't otherwise, but I don't think it's a big issue.
14:23:00 <monochrom> That's one way, but I understand it is not always available, e.g., your Java boss won't accept "I've been reading the darcs manual" as work.
14:23:04 <Heffalump> SamB: I can call it work. But there's stuff to produce, too.
14:23:51 <SamB> monochrom: well, true
14:23:54 <monochrom> What I'm thinking is if you invest in things that speed up your work, you will have more time to invest in things that speed up your work.
14:24:20 <SamB> unless you already use darcs and he knows it
14:24:21 <monochrom> For example "reading the manuals" does not have to take a lot of time.
14:24:26 <SamB> at work
14:24:35 <thoughtpolice> just tell your boss "compiling!"
14:24:43 <thoughtpolice> and he'll understand.
14:24:47 <monochrom> And conversely, if you can't find time to invest, you will have less time to invest.
14:24:51 <olsner> http://c2.com/cgi/wiki?SharpenTheSaw
14:24:53 <lambdabot> Title: Sharpen The Saw
14:25:04 <monochrom> heheheh thoughtpolice
14:25:31 <thoughtpolice> :>
14:25:36 <Heffalump> I understand your point, but it's not obvious to me that reading manuals will pay for itself solely in terms of time saved later.
14:25:44 <SamB> well it depends
14:26:05 <monochrom> Right, there is more investment than reading manuals. There is investment in speeding up reading manuals.
14:26:24 <monochrom> In general you have to go very very meta-level about this.
14:26:28 <SamB> there are basically two reasons to read the manual earlier rather than later:
14:26:59 <SamB> (1) to know about the existance of things that might save you time
14:27:18 <SamB> (2) to know where to find things in the manual later
14:27:56 <monochrom> Yeah. When I read manuals I don't actually remember stuff. I only remember what exists and where to find it.
14:28:15 <xerox> Do you usually read the README/INSTALL and then download the tarball or other way around?
14:28:23 <SamB> xerox: other way round
14:28:43 <SamB> a lot of the time they are, uh, in the tarball
14:28:46 <monochrom> but before typing "make" or "configure" or "runghc Setup.lhs"
14:29:07 <SamB> I generally type ls first
14:29:27 <monochrom> OK, sometimes I skip it altogether, but I acknowledge my risk and I don't complain when something goes wrong.
14:29:45 <SamB> if there is no README, I obviously won't read it
14:30:34 <Heffalump> I generally run the standard commands first then look in the README
14:30:56 <SamB> what I do depends on what ls says
14:31:35 <Heffalump> yeah
14:35:35 <FMota> good afternoon.
14:35:42 <FMota> (for the US folks)
14:37:44 <byorgey> hey FMota
14:38:01 <sorear> The US isn't that small...  it's still mornng in hawaii and borderline evening on the eastern seaboard
14:38:17 <FMota> :o
14:38:20 <FMota> good point
14:38:25 <sorear> stefan@stefans:~$ ghc -V
14:38:25 <sorear> The Glorious Glasgow Haskell Compilation System, version 6.7.20070826
14:38:34 <FMota> ...I'm used to living in a small country. Thanks for pointing that out...
14:38:41 <FMota> jk ;)
14:40:17 <joshua_> however, it is always lunchtime in california
14:41:46 <FMota> I must be a masochist for writing lexers by hand...
14:41:53 <monochrom> and I suppose in Italy too.
14:42:13 <monochrom> Oh, most people use Alex if they use Happy.
14:42:22 <FMota> :o
14:42:35 <Adamant> but where is it the winter of our discontent?
14:42:41 <FMota> I'm not coding in Haskell though. Don't know why I shared that.
14:43:11 <xerox> monochrom: quite :)
14:43:23 <sorear> Time is an illusion, lunchtime doubly so
14:44:37 <FMota> :)
14:45:09 <sorear> FMota: You're a masochist for not coding in Haskell.
14:45:17 <FMota> :o
14:45:28 <sorear> The fact that you're writing lexers is irrelevant. :P
14:45:53 <FMota> Id take that point, but I dont see myself coding Haskell anytime soon. Although I'm probably being stupid.
14:46:15 <FMota> Python is my favorite non-functional PL
14:47:13 <sfultong> hey... does anyone know why my STM atomic block seems to be running after a subsequent statement?
14:47:45 <sorear> Not immediately, @paste?
14:48:09 <sieni> @quote python
14:48:10 <lambdabot> sieni says: python, like php, is just training wheels without the bike
14:48:14 * sieni ducks
14:48:27 <monochrom> hehe
14:48:44 <FMota> :p
14:49:05 <FMota> python is pretty powerful, and it has a nice syntax.
14:49:19 <FMota> the fact that its "unsafe" is of no concern.
14:51:16 <monochrom> Nothing is safe.
14:51:27 <FMota> :)
14:51:33 <FMota> not even Ada :)
14:51:39 <gvdm_other> we run it on _real_ hardware, of course it ain't safe
14:52:21 <monochrom> Somehow, I know nothing is safe, but I still prefer strong typing, static typing, even proof of correctness.
14:52:25 <ddarius> http://citeseer.ist.psu.edu/govindavajhala03using.html
14:52:26 <lambdabot> Title: Using Memory Errors to Attack a Virtual Machine - Govindavajhala, Appel (Researc ...
14:52:40 <gvdm_other> monochrom: same here
14:52:46 <hpaste>  sfultong pasted "STM out-of-order execution" at http://hpaste.org/2485
14:53:59 <monochrom> I think they give me confidence in my brain activity more than confidence in computer activity, that's why.
14:55:30 <ddarius> Invalid proofs of correctness give people a warm fuzzy feeling.
14:55:57 <monochrom> For example, before learning formal methods, I had no systematic way of detecting or preventing "off by one" errors. After learning those, I do.
14:56:05 <oerjan> sfultong: is anything actually _looking_ at the result of add?
14:56:34 <oerjan> it's a pure function, after all, so evaluated lazily
14:56:51 <sfultong> oerjan: damn... it's another case of me forgetting just how lazy laziness can be, I guess...
14:58:07 <sfultong> I need to start thinking more lazily
14:58:28 <monochrom> @remember sfultong I need to start thinking more lazily
14:58:28 <lambdabot> Done.
14:58:59 <shapr> @quote
14:58:59 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
14:59:23 <monochrom> haha
14:59:29 <shapr> FMota: Recursion limits frustrate me when using Python.
14:59:31 <oerjan> sfultong: thought it is still a bit weird that it is evaluated after the putStrLn
14:59:35 <FMota> foldr works for data and codata, foldl only works for data. :/ Why is it that all the 'efficient' (i.e. tail-recursive) functions are data only?
14:59:37 <EvilTerran> ddarius, ah, yes, the inner warmth of burning hate.
14:59:47 <dancor> does anyone know of anything to covert a (unified-format) diff to color html (doing cool stuff like detecting changed lines)
15:00:02 <dancor> (and colorizing per-character line changes)
15:00:02 <oerjan> sfultong: oh, excerpt, so there's more in main later i guess
15:00:04 <FMota> shapr: I usually only get to those limits when I use a really large value with no memoizing, or there's a bug
15:00:19 <FMota> so I prefer that from the alternatives.
15:00:29 <shapr> I think I try to write Haskell in Python, and that's why I have problems.
15:00:32 <ddarius> FMota: Why do you think foldr is inefficent?
15:00:51 <FMota> foldr isn't inefficient
15:00:59 <FMota> its just not tail-recursive
15:01:11 <sfultong> oerjan: yes, much more
15:01:28 <monochrom> Don't worship tail recursion.
15:01:37 <FMota> :) I guess not.
15:01:49 <monochrom> It's ok to worship efficiency.
15:01:49 <Procyon112> tail recursion and laziness are odd bedfellows
15:01:59 <ddarius> FMota: Actually there is a reason why functions processing codata wouldn't be tail-recursive.
15:02:29 <FMota> I know why/how. Is there a deeper reason?
15:02:41 <ddarius> FMota: Why/how?
15:03:36 <FMota> you'd keep calling the same function over and over. With non-tail-recursion, the laziness kicks in.
15:04:20 <ddarius> FMota: We'd like functions over codata to be productive which means they should expose a constructor before too long.
15:04:32 <FMota> Right.
15:05:29 <sorear> dancor: hpaste?
15:05:51 <ddarius> For any recursive codata type, that practically guarantees that the functions would need to not be tail-recursive (assuming they're recursive at all) to be productive.
15:06:10 <etnt> can I specify that I don't want to import functions in the prelude ?
15:06:18 <ddarius> yes
15:06:26 <etnt> from the prelude rather...
15:06:34 <ddarius> import Prelude ()
15:06:48 <oerjan> or import Prelude hiding ( ... )
15:07:01 <fasta> You can read that in the manual ;)
15:07:08 <oerjan> dependent on whether you want most imported or excluded
15:07:22 <etnt> ok, nice
15:07:39 <sfultong> import Prelude () ... wouldn't this make doing anything difficult?
15:07:40 <oerjan> see the module section of the report
15:07:46 <oerjan> @where report
15:07:46 <lambdabot> http://www.haskell.org/onlinereport/
15:08:10 <oerjan> sfultong: you can add import qualified Prelude as P
15:08:12 <dancor> sorear: hpaste doesn't detect lines-changes in diffs
15:08:19 <lament> it's interesting how importing stuff differs in python and haskell. In Python, "import qualified" is the default and importing right into the local namespace is considered bad style
15:08:26 <dancor> just prints tho - line and then the + line
15:08:32 <oerjan> then you can still do P.anything
15:08:41 * dancor likes qualified
15:08:54 <sfultong> yeah, why isn't qualified the default in haskell?
15:08:56 * monochrom likes abstracting away from syntax.
15:08:59 <dancor> i do it even for operators
15:09:22 <sorear> lament: if python used module names like Text.ParserCombinators.Parsec.PermPhrases you'd see a lot more unqualified imports :)
15:09:31 <monochrom> Hahaha
15:09:39 <shapr> Or -fno-implicit-prelude or something.
15:09:41 <sfultong> I suppose that's true
15:09:52 <oerjan> dancor: wikimedia diffs do something like that
15:09:55 <lament> sorear: true :)
15:10:21 <shapr> I prefer qualified imports in Haskell too.
15:10:29 <shapr> It's much easier to track down names then.
15:10:30 <monochrom> Oh! -fno-implicit-prelude is yet stronger than "import Prelude()". The latter still brings in instances, the former doesn't.
15:10:37 <xerox> I hope my proposal of moving things to Text.Parsec will be accepted. I didn't make it somewhere official yet though.
15:10:42 <lament> i agree, namespace clutter is unpleasant
15:11:02 <xerox> (And have ParserCombinators stuff for backwards compatibility.)
15:11:04 <lament> especially since i come from python
15:11:14 <shapr> I came from Python too!
15:11:21 <sorear> I think even Text. is harmful!
15:11:30 <ddarius> It's harder to accidentally mix up functions in Haskell.
15:11:35 <shapr> Yeah, that's true.
15:11:38 <lament> yes, in Python it would certainly be "import Parsec"
15:11:39 <monochrom> I came from BASIC. What is namespace cluttering and what's the big deal?  <duck>
15:11:45 <xerox> sorear: right. Just Parsec would make sense.
15:12:03 <sorear> so why don't we just say Parsec and FiniteMap and X11Display like we did in the Good Old Days?
15:12:16 <lament> but then again, "import Parsec" doesn't solve the problem - it simply turns function namespace clutter into module namespace clutter
15:12:32 <lament> (specifically top-level module namespace clutter)
15:12:46 <Blwood> is there a function to split a String into Chars ?
15:12:53 <Blwood> euh w8
15:12:53 <sorear> Blwood: id
15:12:56 <Blwood> no no
15:13:09 <ddarius> :t id :: String -> [Char]
15:13:10 <Blwood> I mean, I have a number and I want to split it
15:13:12 <lambdabot> String -> [Char] :: String -> [Char]
15:13:15 <lament> a number?
15:13:19 <Blwood> yeah : 123
15:13:19 <sfultong> hmm... someone should make a functional dialect of basic :-P
15:13:19 <monochrom> Data.Graph.Inductive.Internal.FiniteMap
15:13:26 <Blwood> and I want to have [1,2,3]
15:13:37 <lament> > show 123
15:13:38 <lambdabot>  "123"
15:13:41 <sorear> numbers aren't decimal!
15:13:43 <lament> use that :)
15:13:54 <sorear> > map digitToInt . show $ 1234
15:13:55 <lambdabot>  [1,2,3,4]
15:13:57 <lament> and yes, "123" is actually called a "numeral"
15:14:04 <EvilTerran> Blwood, id
15:14:11 <ddarius> Actually, "123" is usually called a string
15:14:18 <ddarius> EvilTerran: You are way late.
15:14:21 <fasta> The one thing that annoys me most is that import Data.Sequence and then having a v = null (singleton 1) gives an error.
15:14:32 <lament> ddarius: no, ""123"" is called a string, and "123" is called a numeral, and 123 is the number 123 :)
15:14:43 <sorear> fasta: right, Great Polymorphic Scare
15:14:47 <lament> english doesn't have very good quote/unquote capabilities :)
15:14:48 <EvilTerran> ddarius, I was providing emphasis.
15:14:55 <fasta> sorear: ?
15:15:03 <sorear> @quote polymorphic.scare
15:15:04 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
15:15:24 <bos> isn't that a band? the polymorphic spree?
15:15:27 <FMota> :o
15:15:32 <ddarius> Apparently he's suggesting that null should be overloaded.
15:15:35 <Blwood> What I want to do : I want to compute the factorial of a number, that's quiet easy : product [1..10], but after that I want to add all the digits of this number
15:15:59 <lament> repeatedly, or just once?
15:16:03 <Blwood> so I'll end with 27
15:16:09 <oerjan> > sum . digitToInt . show . product $ [1..10]
15:16:10 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
15:16:17 <oerjan> > sum . map digitToInt . show . product $ [1..10]
15:16:18 <sorear> > product [1..10] `mod` 9
15:16:18 <lambdabot>  27
15:16:19 <lambdabot>  0
15:16:29 * FMota wonders if allowing only guarded recusion would go down well.
15:16:31 <sorear> > product [1..10] * 1111111111111111111
15:16:32 <lambdabot>  4031999999999999999596800
15:16:33 <Blwood> nice oerjan :)
15:16:50 <fasta> ddarius: I am suggesting that when one imports a symbol p from modules X and Y, X/=Y, the symbol p when used is taken from the module such that the program as a whole compiles.
15:16:53 <lament> > sum . map digitToInt . show . product $ [1..50]
15:16:54 <lambdabot>  216
15:16:59 <EvilTerran> although using (map digitToInt . show) is a bit dirty, imo
15:17:14 <ddarius> fasta: I was offering a possible interpretation of sorear's remark.
15:17:20 <sieni> > 34 `mod` 10
15:17:21 <lambdabot>  4
15:17:22 <Blwood> digitToInt is not in Prelude :(
15:17:31 <ddarius> @index digitToInt
15:17:31 <lambdabot> Data.Char
15:17:33 <O1athe> Is there a function to replace an element in a list with another ?
15:17:44 <ddarius> O1athe: map, but you shouldn't want to do this.
15:17:49 <fasta> sorear: what's your opinion on it?
15:18:15 <sorear> fasta: Haskell 98 was a mistake
15:18:17 <EvilTerran> > (\n -> map (\i -> (n `mod` 10^i) . (n `div` 10^i)) [0..]) 27
15:18:18 <lambdabot>   add an instance declaration for (Integral (c -> c))
15:18:52 <fasta> sorear: and what is the solution?
15:19:01 <sorear> Haskell 1.4
15:19:05 <sfultong> does SPJ agree with (what seems) the general consensis that haskell98 was a mistake?
15:19:08 <lament> Haskell08!
15:19:09 <sieni> > takeWhile (!= 0) $ foldl (`div` 10) $ 1432
15:19:10 <lambdabot>   Not in scope: `!='
15:19:17 <sieni> > takeWhile (/= 0) $ foldl (`div` 10) $ 1432
15:19:18 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
15:19:18 <lambdabot>     Probabl...
15:19:21 <EvilTerran> > (\n -> map (\i -> (n `div` 10^i) `mod` 10) [0..]) 27
15:19:22 <lambdabot>  [7,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
15:19:28 <fasta> sorear: does GHC Haskell come close to Haskell 1.4?
15:19:43 <Blwood> with hugs : ERROR - Undefined variable "digitToInt", is it special for me ?
15:19:49 <sorear> fasta: It did, back when 1.4 was the most recent version
15:19:54 <fasta> sorear: (when one writes suitable standard libs)
15:20:07 <EvilTerran> > iterate ((`divMod`10).fst) (137,undefined)
15:20:08 <lambdabot>  Undefined
15:20:16 <Saizan> Blwood: have you imported Data.Char?
15:20:22 <EvilTerran> > tail $ iterate ((`divMod`10).fst) (137,undefined)
15:20:23 <lambdabot>  [(13,7),(1,3),(0,1),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0...
15:20:24 <fasta> sorear: AFAIK, without the Prelude, you can make everything overloaded by default.
15:20:40 <fasta> sorear: or did it have some mechanism to have everything overloaded by default?
15:20:47 <Blwood> Saizan, I'm quiet new to haskell , how can I do that ?
15:20:50 <O1athe> Is there any way to shorten this ? map (\u -> map (\d -> if u == d then [-1, d] else [d]) ds) (nub ds)
15:20:59 <Blwood> import Data.Char ?
15:21:03 <sorear> fasta: They also made regressive changes to do-desugaring and monad comprehensions.
15:21:07 <oerjan> > unfoldr (Just . flip divMod 10) 137
15:21:08 <lambdabot>  [13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:21:13 <Vulpyne> @pl map (\u -> map (\d -> if u == d
15:21:13 <lambdabot> (line 1, column 32):
15:21:13 <lambdabot> unexpected end of input
15:21:13 <lambdabot> expecting letter or digit, variable, "(", operator, "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or "then"
15:21:19 <Vulpyne> Bah.
15:21:28 <Vulpyne> @pl map (\u -> map (\d -> if u == d then [-1, d] else [d]) ds) (nub ds)
15:21:28 <lambdabot> (line 1, column 38):
15:21:28 <lambdabot> unexpected "["
15:21:28 <lambdabot> expecting lambda abstraction or expression
15:21:33 <sieni> > takeWhile (!= 0) $ scanl div 1432 [10,10...]
15:21:33 <lambdabot>  Parse error
15:21:35 <Saizan> Blwood: you put import Data.Char before the rest fo the code
15:21:58 <O1athe> > let ds = [1, 2, 3, 2] in map (\u -> map (\d -> if u == d then [-1, d] else [d]) ds) (nub ds)
15:21:59 <lambdabot>  [[[-1,1],[2],[3],[2]],[[1],[-1,2],[3],[-1,2]],[[1],[2],[-1,3],[2]]]
15:21:59 <Blwood> int the command line, hugs doesn't like it :( : ERROR - Syntax error in expression (unexpected keyword "import")
15:22:13 <sieni> > takeWhile (!= 0) $ scanl div 1432 [10,10,...]
15:22:13 <lambdabot>  Parse error
15:22:22 <sieni> > takeWhile (!= 0) $ scanl div 1432 [10,10..]
15:22:22 <lambdabot>   Not in scope: `!='
15:22:30 <sieni> > takeWhile (/= 0) $ scanl div 1432 [10,10..]
15:22:31 <lambdabot>  [1432,143,14,1]
15:22:33 <fasta> sorear: monad comprehensions worked in GHC just a few years ago, IIRC. Don't they anymore?
15:22:40 <Saizan> Blwood: i don't remember how you load a module in hugs, :load Data.Char, maybe?
15:22:44 <lament> > takeWhile (/= 0) $ iterate (`div` 10) 12345
15:22:45 <lambdabot>  [12345,1234,123,12,1]
15:22:57 <sieni> > map (`mod` 10) $ takeWhile (/= 0) $ scanl div 1432 [10,10..]
15:22:58 <lambdabot>  [2,3,4,1]
15:23:12 <monochrom> "type :? for help"
15:23:15 <sieni> > map (`mod` 10) $ takeWhile (/= 0) $ scanl div (product [1..10]) [10,10..]
15:23:16 <lambdabot>  [0,0,8,8,2,6,3]
15:23:17 <oerjan> > unfoldr (Just . curry (flip (,)) . flip divMod 10) 137
15:23:18 <lambdabot>  Couldn't match expected type `(a, b)'
15:23:23 <Blwood> Saizan, aahh ok , I didn't understand that it was a module, :l Data.Char does it
15:23:30 <xerox> Saizan: :also
15:23:33 <xerox> IIRC
15:23:34 <Blwood> Saizan, thank you for your help :)
15:23:41 <EvilTerran> > map (`mod`10) . takeWhile (/=0) . iterate (`div`10) $ product [1..10]
15:23:42 <lambdabot>  [0,0,8,8,2,6,3]
15:23:53 <sieni> > sum $ map (`mod` 10) $ takeWhile (/= 0) $ scanl div (product [1..10]) [10,10..]
15:23:55 <lambdabot>  27
15:23:57 <EvilTerran> > sum . map (`mod`10) . takeWhile (/=0) . iterate (`div`10) . product $ [1..10]
15:23:58 <lambdabot>  27
15:24:23 <oerjan> > unfoldr (Just . uncurry (flip (,)) . flip divMod 10) 137
15:24:24 <EvilTerran> sieni, methinks iterate (`div`10) is nicer than flip (scanl div) [10,10..]
15:24:24 <lambdabot>  [7,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
15:24:44 <sieni> EvilTerran: it is :-)
15:25:15 <Olathe> If I have [[a], [b, c], [d, e]], how do I get [a, b, d], [a, b, e], [a, c, d], [a, c, e] ?
15:25:19 <TuringTest> Hi.  Does anyone know where the darcs repository for the Data.Map code is hiding?
15:25:53 <Saizan> > sequence [['a'], ['b', 'c'], ['d', 'e']]
15:25:55 <lambdabot>  ["abd","abe","acd","ace"]
15:26:10 <sorear> @source Data.Map
15:26:10 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
15:26:28 <sorear> fasta: They removed them for H98.
15:26:55 <TuringTest> sorear:  I already looked there...it is 404
15:27:12 <Saizan> darcs.haskell.org/libraries/base
15:27:43 <sorear> @slap herself
15:27:43 <lambdabot> why on earth would I slap herself
15:27:46 <oerjan> http://darcs.haskell.org/ghc-6.6/packages/base/Data/Map.hs
15:27:58 <TuringTest> sorear: Thanks!
15:28:01 <Saizan> oh, is it not in base anymore?
15:28:04 <lament> @slap herself
15:28:04 <lambdabot> why on earth would I slap herself
15:28:10 <sorear> TuringTest: s/sorear/Saizan/
15:28:11 <Olathe> Saizan: Thanks.
15:28:19 <Saizan> TuringTest: it's not there
15:28:24 <lament> i'm guessing herself needs to be a nick.
15:28:31 <TuringTest> oerjan: There it is!
15:28:31 <sorear> @slap herself
15:28:32 * lambdabot smacks herself about with a large trout
15:28:43 <EvilTerran> > sum . map (flip mod 10 . uncurry div) . takeWhile (uncurry (>=)) . flip zip (map (10^) [0..]) . repeat . product . enumFromTo 1 $ 10
15:28:45 <lambdabot>  27
15:28:49 <fasta> sorear: yes, I know that, but AFAIK, there was a flag which enabled them, but that could be me making things up.
15:29:18 * EvilTerran stops needlessly obfuscating further now
15:29:22 <Saizan> uhm yeah, why didn't they kept at least monad comprehension as an extension?
15:29:33 <Procyon112> @pl sum . map (flip mod 10 . uncurry div) . takeWhile (uncurry (>=)) . flip zip (map (10^) [0..]) . repeat . product . enumFromTo 1 $ 10
15:29:34 <lambdabot> sum (map (flip mod 10 . uncurry div) (takeWhile (uncurry (>=)) (zip (repeat (product [1..10])) (map (10 ^) [0..]))))
15:29:35 <oerjan> TuringTest: found the link from http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
15:29:52 <sorear> Why did we let the people who hated polymorphism live?
15:29:52 <EvilTerran> @unpl sum . map (flip mod 10 . uncurry div) . takeWhile (uncurry (>=)) . flip zip (map (10^) [0..]) . repeat . product . enumFromTo 1 $ 10
15:29:52 <lambdabot> (sum (map (\ r -> mod (uncurry div r) 10) (takeWhile (uncurry (>=)) (zip (repeat (product (enumFromTo 1 10))) (map (\ g -> 10 ^ g) [0 ..])))))
15:29:54 <sfultong> I wondered where that trout smacking meme had gone
15:31:30 <chessguy> 'evening ya'all
15:31:42 <Procyon112> yo
15:31:50 <oerjan> Procyon112: the expression was already point-free
15:31:53 <chessguy> Procyon112!
15:32:16 <Saizan> i wonder, when you slip a darcs repo in half, you do so keeping old patches in both the branches?
15:32:24 <Saizan> *split
15:32:32 <shapr> Saizan: HAppS did.
15:32:55 <shapr> Though we had to dump the history in one or two cases with fatal merge problems.
15:33:06 <Procyon112> chessguy: Yeah.. I needed some purely functional time today amidst my recent highly imperative chaos :)
15:33:19 <chessguy> lol
15:33:34 <chessguy> sounds like a tagline for Microsoft :)
15:33:36 <shapr> Saizan: After tagging, darcs get took seven minutes. After darcs optimize --checkpoint, darcs get took seven seconds.
15:33:44 <chessguy> ,"highly imperative chaos"
15:33:55 <shapr> @users
15:33:55 <lambdabot> Maximum users seen in #haskell: 392, currently: 363 (92.6%), active: 24 (6.6%)
15:34:27 <Saizan> shapr: ah ok, containers with 1800 patches is not so snappy :)
15:34:52 <shapr> Saizan: Er, darcs get --partial, I mean.
15:38:31 * sfultong cuts himself in half in boredom
15:40:02 <sfultong> there's gotta be a better way of debugging than what I do... oh! actually, now that I've started using darcs, I guess I can just revert all the debugging cruft that I add to my code
15:41:04 <shapr> sfultong: What about writing tests and using darcs trackdown?
15:41:08 * shapr hugs fasta 
15:41:29 * fasta thinks shapr does that a lot lately
15:41:48 <shapr> fasta: Hugging you?
15:42:00 <shapr> Ha, just wait till I meet you in person!
15:42:02 <fasta> shapr: yes
15:42:04 * shapr grins
15:42:05 <sfultong> shapr: test-driven development?  That sounds like too much work
15:42:19 <shapr> sfultong: It is too much work... until something else doesn't
15:42:55 <shapr> sfultong: Is Fulton your middle name?
15:42:58 <sfultong> yes
15:43:03 <shapr> Ah, that explains it.
15:43:29 <fasta> Anyway, I found that doing graph reduction on paper is error-prone. Is there a GUI in which I can perform graph reduction?
15:43:37 <sfultong> people tell me my nick sounds chinese
15:43:50 <fasta> (Something that works)
15:43:52 * sfultong is fine being fake chinese
15:44:00 <shapr> sfultong: But seriously, TDD lets you know when something you wrote before breaks, and when something you're still writing works.
15:44:02 <FMota> heh. A very functional way of writing a makeshift 'parser' in Python...
15:44:44 <sfultong> shapr: yeah, I think you're probably right... it's just making the adjustment is hard
15:44:51 <FMota> def  parsetoks(toks, pr = parserules):  return parsetoks(pr[0](toks), pr[1:]) if pr else toks
15:44:52 <fasta> shapr: TDD is great when the tools are perfect.
15:45:02 <shapr> fasta: I've heard of http://www.cs.york.ac.uk/fp/darcs/Blobs/ , can it do what you want?
15:45:03 <lambdabot> Title: Blobs diagram editor
15:45:08 <FMota> of course, I wrote that out on multiple lines using a proper if statement.
15:45:09 <sfultong> btw, what is darcs trackdown?
15:45:21 <shapr> fasta: How does TDD break when the tool isn't perfect?
15:45:23 <fasta> sfultong: the manual says it
15:45:46 <fasta> sfultong: and it tracks down where the regression doesn't occur
15:45:55 <shapr> sfultong: You write a test, and darcs trackdown will iterate unrecord until the test passes.
15:46:11 <sfultong> that's a beautiful idea...
15:46:16 <shapr> Yeah, it is.
15:46:41 <shapr> Yay, I built the jhc libs! -> make libs  3211.92s user 7.21s system 99% cpu 53:54.40 total
15:47:08 <fasta> shapr: I have seen that software before, it might actually be useful ;)
15:47:12 <shapr> yay!
15:47:17 <fasta> shapr: still a working Hat would be better.
15:47:25 <shapr> fasta: You still didn't say how TDD breaks when the tools aren't perfect. I'm interested!
15:47:35 <sfultong> I need someone knowledgeable near me to come and watch me develop stuff, and show me all the ways that I'm doing it badly
15:47:40 <shapr> Yeah, I wish Hat handled all the extensions HAppS uses.
15:47:52 <shapr> sfultong: hpaste?
15:47:55 <chessguy> sfultong, heh. that's a pretty vague request
15:48:01 <shapr> sfultong: Or do you mean "The Pragmatic Programmer" sort of stuff?
15:48:13 <chessguy> even if we were there we wouldn't know how to fulfill that request
15:48:16 <sfultong> I'm not familiar with "The Pragmatic Programmer"
15:48:23 <shapr> sfultong: Then that's a great place to start!
15:48:24 <fasta> shapr: tools is the wrong word
15:48:35 <sfultong> cool, thanks
15:48:37 <chessguy> yes, PP is a great book
15:48:37 <shapr> fasta: Can you explain it more?
15:48:38 <fasta> shapr: QuickCheck and SmallCheck for example work quite nicely for lists.
15:48:45 <shapr> Yeah?
15:48:47 <rickard1> Can has leeth parsing of arguments?
15:48:54 <fasta> shapr: but for some structures you cannot write random generators.
15:49:08 <shapr> rickard1: im in ur syntax parsin your args.
15:49:13 <shapr> fasta: Like what?
15:49:22 <chessguy> leeth?
15:49:25 <edwinb> syntax trees...
15:49:34 * shapr chases a lolcat up a syntax tree
15:49:46 <edwinb> who will rescue it!
15:49:51 <shapr> sorear!
15:50:01 <sorear> shapr!
15:50:04 * shapr ,being lazy, volunteers someone else...
15:50:08 <sfultong> $31.28 for 94 pages? aww...
15:50:15 <sorear> huh, what?!!?
15:50:17 <shapr> sfultong: IT's totally worth it.
15:50:19 <fasta> shapr: and there's no testing frame work for monadic code that works out of the box.
15:50:27 <shapr> fasta: Have you tried QC2 ?
15:50:29 * sorear , startled, looks around quickly
15:50:43 <fasta> shapr: Yes, but it was too much of a hassle.
15:50:53 <sfultong> alright, any other book recommendations while I'm in amazon?  I might as well load up...
15:50:57 <shapr> It has built-in support for monadic quickchecking, but it uses (no surprise) unsafePerformIO
15:50:59 <fasta> shapr: I already depended on QC1.
15:51:08 <sorear> shapr: Have you seen the Hat SoC project?
15:51:16 <shapr> sfultong: Yeah, but they're either free or unattainably expensive.
15:51:20 <chessguy> edwinb, do you mean haskell syntax trees?
15:51:27 <sorear> shapr: Also, I do not see a request on the current page.
15:51:38 <edwinb> I mean that if I'm, say, writing a typechecker, it's hard to generate decent test cases
15:51:50 <chessguy> ah, that's different
15:51:57 <edwinb> much as I'd like to
15:51:59 <chessguy> you can still write a random generator
15:52:12 <edwinb> yeah, it won't necessarily do me much good though
15:52:12 <sfultong> actually, what would help me more than having someone correct my development process, is watching someone better than me develop....
15:52:13 <shapr> sfultong: The three books I recommend to all programmers are Structure and Interpretation of Computer Programs, The Pragmatic Programmer, and Hamming's "The Art of Science and Engineering : Learning to Learn"
15:52:20 <fasta> chessguy: yes, but it's not trivial to do so.
15:52:21 <SamB> typecheckers are more where the *Unit approach works nicely
15:52:32 <edwinb> Yes, I usually use HUnit
15:52:36 <sfultong> shapr: thanks
15:52:36 <chessguy> shapr, i think i went looking for that hamming book and couldn't get it
15:52:37 <shapr> SICP is free, AoSE is usually $300-$800
15:52:45 <sfultong> damn...
15:52:49 <edwinb> then at least i know when I've broken stuff
15:52:56 <fasta> chessguy: so, when it takes lots of time to do so, it's easily to just say: "you know what, I will just write the damn thing and hope it works".
15:53:05 <sjanssen> does anyone know the status of DPH in GHC 6.7?  Do comprehensions run in parallel yet?
15:53:25 <sfultong> I'm suspicious of the phrase "learning to learn"... If I didn't know how to learn already, I wouldn't have come this far :-P
15:53:27 <shapr> Last I heard, you get pretty syntax with no smp, or ugly syntax with smp.
15:53:36 <fasta> shapr: AoSE?
15:53:46 <shapr> fasta: Art of Science and Engineering
15:53:57 <fasta> shapr: oh, right, I looked that up already once.
15:54:17 <shapr> sfultong: Hamming extended this speech to write AoSE - http://www.cs.virginia.edu/~robins/YouAndYourResearch.html
15:54:18 <lambdabot> Title: You and Your Research
15:54:29 <shapr> sfultong: Read that, and tell me if you think a book-length version is worth while :-)
15:54:31 <edwinb> that's a great talk that one
15:54:41 <edwinb> I didn't realise there was a book length version of it...
15:54:48 <monochrom> "Learning to learn" is not as impossible as it sounds.
15:54:59 <fasta> Computers do it every day.
15:55:00 <shapr> sfultong: I got lucky, I found a used copy for $120 in .nl the day it was put up for sale.
15:55:02 <monochrom> I also mean not as moot as it sounds.
15:55:41 <shapr> edwinb: The book is amazing, but hard to find.
15:55:54 <monochrom> Your ability to learn is not boolean "can or can't". You are born with some ability to learn. Then someone can guide you how to increase it.
15:55:58 <shapr> I looked for two years or so before I found a copy I could afford.
15:56:04 <fasta> shapr: why don't they just reprint it?
15:56:15 <sorear> shapr: "15:48 < shapr> sorear!" <- ?
15:56:15 <shapr> fasta: I don't know.
15:56:27 <shapr> sorear: I was volunteering you to get the lolcat out of the syntax tree :-)
15:56:39 <fasta> shapr: maybe they like to see people begging for the book.
15:56:40 <sorear> what's a lolcat?
15:56:49 <edwinb> shapr: I was hoping our library would have it but, alas, no.
15:56:50 <shapr> @go lolcat icanhascheezburger
15:56:52 <lambdabot> http://icanhascheezburger.com/
15:56:52 <lambdabot> Title: I CAN HAS CHEEZBURGER?
15:56:56 <sfultong> monochrom: I certainly agree, but those people in my life so far who have professed ability in being able to expand my capacity to learn have failed miserably... in fact, they probably decreased my ability by decreasing my desire
15:57:25 <shapr> sfultong: AoSE is by http://en.wikipedia.org/wiki/Richard_Hamming
15:57:27 <lambdabot> Title: Richard Hamming - Wikipedia, the free encyclopedia
15:57:40 <sfultong> is he of "hamming distances"?
15:57:49 <shapr> Yeah, that Hamming.
15:58:02 <EvilTerran> is the audio of that talk online anywhere? i could use something to listen to on my 4hr train journey in a couple days.
15:58:19 <monochrom> It is impressive how little ability to learn is necessary to survive highschool. As humans, that also tends to the actual level people have developed by then. Thus there is still much to be said about "learning to learn" at the postsecondary level.
15:58:43 <shapr> EvilTerran: AoSE was the textbook for a course, and I do have videos of that course.
15:58:51 * shapr points to #haskell-blah
15:59:45 * rickard1 is making t3h l33tz0r gnu wc cl0ne
15:59:59 <shapr> rickard1: Are you writing a lolcode interpreter in Haskell?
16:00:17 <rickard1> in the works...
16:00:30 <lament> isn't lolcode in active development?
16:00:30 <fasta> Amazon.com is pretty funny. It suggests books when it has no data on my user behaviour!
16:00:37 <lament> by a bunch of people with no clue about language design?
16:00:47 <ricky_clarkson> fasta: I do the same.
16:01:20 <Adamant> not having a clue about language design will probably make it funnier
16:01:21 <EvilTerran> lament, indeed. i thought about writing an interpreter myself, but had a look at the "standards", and decided it was too bloodyawful in design to even bother with
16:01:44 * FMota thinks of separating types from data in Sei. :/
16:01:44 <fasta> ricky_clarkson: you make suggestions to people you don't know?
16:02:31 <ricky_clarkson> I'd recommend 1984 by George Orwell to anybody.
16:03:03 <lament> EvilTerran: yes, and considering how old the http://www.indwes.edu/Faculty/bcupp/things/computer/VALGOL.html joke is, it's all rather pathetic.
16:03:04 <lambdabot> Title: VALGOL
16:03:07 <wli> cf. James Burnham's "The Managerial Revolution" for some of its inspiration.
16:03:12 <fasta> ricky_clarkson: governments already use it as a manual, AFAIK.
16:03:47 <EvilTerran> lament, ah. to borrow a phrase, "owned".
16:03:54 <ricky_clarkson> Macs come with webcams in/near the screen, now, right, fasta?
16:04:00 <Adamant> indeed
16:04:19 <wli> That's reading a bit much into it. Some more care is required in assessing its accuracy.
16:04:20 <fasta> ricky_clarkson: I don't know.
16:04:27 <edwinb> mine has such a thing...
16:04:34 <edwinb> I've never thought of a use for it though
16:04:34 <chessguy> "gag me with a spoon", lol
16:04:42 <Adamant> sleek metallic omniscience
16:05:19 <fasta> edwinb: you should go naked and then tell your girl friend not to show it to the world when you break up. Works every time!
16:05:35 * edwinb considers this suggestion carefully
16:06:09 * shapr gets on with writing Haskell code.
16:10:15 * monochrom writes Haskell comments.
16:10:46 * matthew-_ waits on alloy
16:10:49 <monochrom> I have done generators using delimited continuations. Now I have to explain it.
16:11:00 <monochrom> Eh! Alloy, the Analyzer!
16:11:02 * thoughtpolice writes the world haskell
16:11:09 <thoughtpolice> s/world/word/
16:11:10 * EvilTerran eats lettuce
16:11:11 <shapr> I have written code that causes errors at runtime, now I must explain it to myself :-(
16:11:11 <thoughtpolice> :(
16:11:18 <monochrom> haha
16:11:44 <EvilTerran> it's the iceberg that sank my midnight munchies! :D
16:12:43 <matthew-_> shapr: it means you didn't use enough types!
16:12:53 <shapr> matthew-_: I think I used too much types.
16:13:01 <thoughtpolice> all your types are belong to haskell
16:13:07 <edwinb> there's no such thing as too many types! :)
16:13:16 <monochrom> and all your codes are belong to darcs
16:13:20 <shapr> Someone set us up the lambda!
16:13:40 <thoughtpolice> all your operating systems are belong to computers (?)
16:13:51 <matthew-_> monochrom: err, sorry, that last one *just* *ain't* *true* ;)
16:13:54 <shapr> My problem is that "instance (SYBWC.Data ctx a, SYBWC.Sat (ctx (Ix a))) => SYBWC.Data ctx (Ix a) where gfoldl = error "gfoldl Ix"" gets called somewhere...
16:14:36 * thoughtpolice wonders when the next weekly sequence will be out...
16:16:25 <koxinga> hum, there isn't any qt binding for haskell ?
16:19:46 <dons> koxinga: no, strangely. (but is it written in C++ ?)
16:19:55 <EvilTerran> koxinga, afraid not. you're restricted to either the (scarey) gtk2 bindings, or the (dead) wxWidgets ones
16:20:17 <thoughtpolice> dons: yeah qt is c++
16:20:20 <dons> the gtk2hs bindings are well regarded
16:20:25 <EvilTerran> there's Tcl/Tk bindings floating around somewhere, too, but i think they're out of active development too
16:20:28 <dons> thoughtpolice: yeah, so that's the main reason then.
16:20:37 <dons> EvilTerran: right, they're circa 1995.
16:20:43 <EvilTerran> dons, i'm not knocking them, i just find gtk2 a bit intimidating
16:20:54 <dons> large?
16:20:56 <dons> ?users
16:20:56 <lambdabot> Maximum users seen in #haskell: 392, currently: 357 (91.1%), active: 23 (6.4%)
16:21:19 <EvilTerran> i think i traumatised myself trying to use them directly from C
16:21:23 <EvilTerran> *it
16:21:35 <dcoutts> EvilTerran: yeah, it C it's evil, in Haskell it's quite nice
16:21:37 <thoughtpolice> dons: i suppose it would be possible using an object-factory and the ffi but that would be some nasty stuff, most definately.
16:22:14 <thoughtpolice> i should probably take a look at gtk2hs one of these days though
16:22:26 <koxinga> And if I really want to use Qt, is this a good solution ? : http://www.mail-archive.com/haskell-cafe@haskell.org/msg00908.html
16:22:27 <EvilTerran> in C it's a case of the tutorials saying something to the effect of "zomg there's a million things you have to set, just copy-and-paste this and it should work"
16:22:28 <lambdabot> Title: Haskell <-> C/C++ comunication (sockets/pipes?), http://tinyurl.com/ypxc62
16:22:32 <fasta> Is there a way to find what's lagging (profile term) when one doesn't have retainer profiling?
16:22:35 <EvilTerran> or, even worse, trying to explain it =/
16:22:36 <gravity> phooey looks really interesting now that I've played with gtk2hs a little
16:22:44 <dcoutts> thoughtpolice: we're getting some nice new gtk2hs tutorials
16:22:57 <dcoutts> gravity: someone should do a gtk2hs backend for phooey
16:22:59 <koxinga> (doing the Gui in another language and then communicate via pipes or sockets)
16:23:14 <dcoutts> koxinga: that gets pretty ugly
16:23:16 <gravity> dcoutts: Doesn't phooey use gtk2hs as its backend?
16:23:26 <dcoutts> gravity: I thought it was wx
16:23:28 <EvilTerran> i thought phooey was built on wxHaskell
16:23:32 <thoughtpolice> dcoutts: cool stuff. :)
16:23:36 <gravity> dcoutts: Ah, you're right
16:23:46 <gravity> Which uses gtk itself at the base on linux anyway
16:23:55 <dcoutts> it's not the same at all
16:24:02 <thoughtpolice> personally I never liked gtk in C to begin with
16:24:08 <thoughtpolice> then I just regressed into using terminals
16:24:12 <thoughtpolice> so it was never again a concern :p
16:24:23 <dcoutts> thoughtpolice: it was never designed to be used from C, it was designed to be bound by nicer languages
16:24:37 <dcoutts> but C was a neutral mature implementation language
16:24:47 <thoughtpolice> naturally, I suppose.
16:25:30 <Nafai> gtk in Python wasn't bad
16:25:39 <olsner> gtk was never designed to be used from C? that's just crazy-talk!
16:25:43 <koxinga> :'( So no Qt or no Haskell or ugly hack. Hard choice.
16:25:48 <gravity> dcoutts: I've heard it was designed to be used by scheme
16:25:56 <gravity> Which is kinda funny, given what happened
16:26:10 <EvilTerran> wasn't gtk written for the GIMP?
16:26:14 <dcoutts> EvilTerran: yep
16:26:24 <EvilTerran> ...and that's written in... C++?
16:26:29 <dcoutts> no, C
16:26:51 <EvilTerran> but no-one else was supposed to use it from C, save to write wrappers?
16:26:58 <dcoutts> gravity: yes, guile had one of the early Gtk bindings
16:27:18 <SamB> isn't only a smallish part of GIMP in C?
16:28:41 <matthew-_> as my boss says, all non-GC'd languages must die.
16:29:09 <Pseudonym> Surely non-GC'd languages only die if you kill them manually.
16:29:13 <FMota> good boss :)
16:29:18 <jedai> @src digitToInt
16:29:18 <lambdabot> Source not found. Where did you learn to type?
16:29:22 <edwinb> one day they'll go out of scope
16:29:27 <jedai> @hoogle digitToInt
16:29:28 <lambdabot> Char.digitToInt :: Char -> Int
16:29:33 <Pseudonym> And then they'll float around forever.
16:29:40 <edwinb> aaargh!
16:29:44 <thoughtpolice> Pseudonym: a price to pay
16:29:45 <matthew-_> surely someone'll reboot eventually
16:29:46 <jedai> @src Char.digitToInt
16:29:46 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:29:48 <oerjan> > digitToInt 'c
16:29:48 <lambdabot>  Improperly terminated character constant
16:29:50 <oerjan> > digitToInt 'c'
16:29:52 <lambdabot>  12
16:29:53 <jedai> @src Data.Char.digitToInt
16:29:54 <lambdabot> Source not found. Where did you learn to type?
16:30:05 <Pseudonym> There's always a price to pay, whether your language is GC'd or not.
16:30:15 <Pseudonym> If it's not, the price is manual resource management.
16:30:22 <Pseudonym> If it is, the price is unpredictable resource management.
16:30:23 <matthew-_> just go to the ghc manual page for Data.Char and click on Source
16:30:35 <Pseudonym> (Most of the time.)
16:30:45 <LoganCapaldo> what about region inference?
16:30:47 <jedai> @source Data.Char
16:30:47 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
16:30:59 <Pseudonym> LoganCapaldo: Then you're at the mercy of how good the inference is.
16:31:07 * LoganCapaldo is convinced its the holy grail of memory management and damn the facts
16:31:11 <Pseudonym> :-)
16:31:52 <Pseudonym> Having programmed embedded real-time stuff for almost two years now, I understand the benefit of manual resource management if that's what is called for.
16:32:15 <Pseudonym> I don't pretend that my application domain is the whole world of software, though.
16:32:36 <matthew-_> surely, soon enough, economies of scale will mean that embedded systems are really powerful enough to run GCs too?
16:32:55 <Pseudonym> But old platforms don't die.
16:33:01 <Pseudonym> They just get pushed down the food chain.
16:33:07 <matthew-_> that's because they're not garbage collected
16:33:12 <Pseudonym> Right.
16:33:15 <matthew-_> we need platform garbage collection
16:33:22 <matthew-_> or rm -rf /
16:33:44 <Pseudonym> Today's PC is tomorrow's handheld, which is the day after's digital thermometer, which is the day after's smart card, which is the day after's servo controller.
16:33:49 <matthew-_> yeah, I see what you're saying though. But the chain is finite
16:34:12 <Pseudonym> Hell, today's PC is tomorrow's wireless network card.
16:34:37 <matthew-_> and today's PC just isn't damn fast enough!
16:34:38 <fasta> shapr: To build Blobs: ghc-6.2.2 (Note 6.4 may work, untested)
16:34:41 <koxinga> matthew-_:  it will take a long long time to reach the end
16:34:59 <matthew-_> ja
16:39:45 <matthew-_> hey, when did build logs get added to hackage?
16:40:27 <matthew-_> amusingly, none of my packages actually build.
16:40:35 <matthew-_> 1 because it requires ghc 6.7
16:40:38 * shapr swears at this gfoldl error
16:40:41 <Pseudonym> shapr: That's better.
16:40:45 <shapr> :-)
16:40:52 <oerjan> :t gfoldl
16:40:54 <lambdabot> Not in scope: `gfoldl'
16:40:58 <matthew-_> 1 because they seem to have changed/broken cabal
16:41:22 <shapr> I wish I could figure out what's calling gfoldl on my Ix instance.
16:41:25 <matthew-_> and the 3rd because haddock is broken
16:41:42 <oerjan> @hoogle gfoldl
16:41:43 <lambdabot> Data.Generics.Basics.gfoldl :: Data a => (c (a -> b) -> a -> c b) -> (g -> c g) -> a -> c a
16:41:43 <lambdabot> Data.Generics.Twins.gfoldlAccum :: Data d => (a -> c (d -> r) -> d -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
16:43:07 <thoughtpolice> @seen bos
16:43:08 <lambdabot> bos is in #ghc, #haskell and #haskell-soc. I last heard bos speak 1h 27m 43s ago.
16:49:41 <thoughtpolice> bos: see you updated pcap, I'm making sure hsns still builds under it; but I'm getting an err (due to a missing pcapconfig.h while building)
16:53:19 * shapr throws frustration lambdas
16:56:36 * monochrom throws sugar lambdas
16:57:09 <LoganCapaldo> By their powers combined, they are capt. lambda?
16:59:03 <Pseudonym> Of course not. Captain Lambda doesn't wear glasses.
16:59:57 <FMota> :o
17:01:37 <fnord123> !pastebin
17:01:38 <hpaste> Haskell paste bin: http://hpaste.org/
17:02:36 <LoganCapaldo> What does glasses have to do with anything?
17:03:06 <monochrom> I wear glasses.
17:03:31 <LoganCapaldo> I was talking about the frustration lambds and the sugar lambdas combining though...
17:03:39 <LoganCapaldo> Do they wear glasses?
17:03:45 <Pseudonym> LoganCapaldo: It's well-known that if you're trying to work out the secret identity of a superhero, don't look for people who wear glasses.
17:03:56 <monochrom> hahaha
17:04:01 <Pseudonym> If the superhero wears glasses, and the ordinary guy does, they can't be the same person.
17:04:13 <Pseudonym> Sorry, if the superhero DOESN'T wear glasses.
17:04:24 <hpaste>  fnord123 pasted "mapTreeM" at http://hpaste.org/2488
17:04:32 <oerjan> how many superheroes wear glasses, anyhow?
17:04:37 <LoganCapaldo> That was possibly the funniest bit in Mystery Men
17:04:43 <Pseudonym> Yeah.
17:04:50 <sjanssen> Dr. Mid-Nite wears goggle things
17:04:51 <Pseudonym> It's otherwise a real waste of a good premise.
17:05:34 <sjanssen> Plastic Man generally wears sunglasses
17:06:53 <fnord123> I'm unsure why I'm getting this error w/ sequence as mapM is supposedly sequence (map f x) according to Hayek (pg 259)
17:07:31 <monochrom> mapTreeM returns Tree b?  Not m (Tree b)?
17:07:45 <chessguy> hmm, i'm trying to remember, alphabeta is pretty much just a fold in haskell, right?
17:07:53 <chessguy> @hoogle mapTreeM
17:07:54 <lambdabot> No matches found
17:08:10 <oerjan> fnord123: you need -> m (Tree b)
17:08:41 <monochrom> sequence (mapTree f x) does not do what you want either.
17:08:59 <twanvl> Also, sequence doesn't work for Trees, only lists; onles there is a Traversable instance
17:10:01 <fnord123> well since I dont understand the issue here I've tried a lot of small guesses and m (Tree b) doesn't seem to work as the return type either
17:10:21 <monochrom> That is because sequence (mapTree f x) is also wrong.
17:10:32 <monochrom> You're in a "two wrongs" situation.
17:10:45 <twanvl> You can not reuse mapTree to make mapTreeM
17:10:51 <fnord123> the solution space is massive unless I begin to understand :-(
17:11:24 <monochrom> Indeed, foldM is fairly far from foldl or foldr.
17:11:37 <fnord123> @hoogle foldM
17:11:37 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
17:11:37 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
17:11:37 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
17:11:51 <twanvl> You could try writing mapTreeM as a variant of mapTree with do {..} everywhere
17:12:00 <monochrom> Yeah.
17:12:08 <fnord123> I tried that :)
17:12:23 <twanvl> So "mapTree f (Leaf x) = Leaf (f x)"  becomes  "mapTree< f (Leaf x) = do { x' <- f x ; Leaf x' } "
17:12:40 <twanvl> s/</M/
17:13:29 <bos> thoughtpolice: ok, will look into it
17:13:32 <fnord123> or f x >>= (\x -> Leaf x)
17:14:04 <hpaste>  oerjan annotated "mapTreeM" with "something like this?" at http://hpaste.org/2488#a1
17:14:04 <fnord123> where x is an exceptionally poor variable name
17:14:23 <LoganCapaldo> can you write such a combiantor that for some foldr-like function (catamorphism? anamorphism? I don't know wha the right term is) it gives you the M variant?
17:14:41 <monochrom> An attraction of pointfree for me is fewer variable names. :)
17:14:53 <twanvl> Or my favorite: Leaf <$> f x  (although Applicative is not a superclass of Monad yet)
17:16:21 <fasta> Will if False then 1 else 2 be compiled as 2 in GHC with -02?
17:18:00 <shapr> What's the point of this? gFind x = msum $ map return $ listify (const True) x
17:18:04 <shapr> @hoogle listify
17:18:04 <lambdabot> Data.Generics.Schemes.listify :: Typeable r => (r -> Bool) -> GenericQ [r]
17:19:10 <fnord123> :t mapM
17:19:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:19:41 <LoganCapaldo> the function I'm asking about would have an infinite type, wouldn't it
17:21:18 <SamB> ,k
17:21:35 <SamB> LoganCapaldo: eh, I think it's not even that goods
17:21:40 <SamB> s/goods/good/
17:22:37 <fnord123> did hpaste go down?
17:23:04 <oerjan> fnord123: not to me
17:23:11 <shapr> fnord123: Works for me.
17:24:04 <thoughtpolice> bos: also, it seems as if the PcapHandle constructor isn't exported from Network.Pcap (that is, I can't pull the ForeignPtr from it)
17:24:36 <fnord123> hm looks like i lost http connections. no websites are coming through.
17:24:49 <gigamonkey_> So I'm watching SPJ's OSCON videos. I'm confused why he doesn't just say that type classes are a lot like Java interfaces. Am I confused about type classes or is he confused about Java interfaces?
17:24:58 <thoughtpolice> bos: the first issue was fixed by copying the pcapconfig.h into the local directory though, so if needed I can just put that into the build for hsns (i'll take this as an opportunity to clean up the code too :>)
17:25:31 <thoughtpolice> well, make sure the setup generates it for hsns anyway
17:25:52 <Pseudonym> gigamonkey: It's an oversimplification.
17:26:00 <fnord123> gigamonkey, maybe it's not that helpful since people will assume it's all the same
17:26:08 <Pseudonym> Type classes can work like Java interfaces, but they're actually quite different.
17:26:21 <gigamonkey_> So what's the salient difference?
17:26:31 <Pseudonym> You can't add an interface to an existing class without modifying the class, in Java.
17:26:56 <thoughtpolice> bos: thanks though. :)
17:27:06 <dibblego> a type-class function has to have functions where the type parameter is used
17:27:14 <gigamonkey_> Fair enough. But that's more a function of how classes are defined than the difference between type classes and interfaces, no?
17:27:27 <dibblego> a Java interface is ad hoc
17:27:29 <Lemmih> dcoutts: Hi. I don't think TreeModel works in the darcs repo.
17:27:44 <dcoutts> Lemmih: oh?
17:28:19 <Lemmih> dcoutts: I'm getting 'treetest: gtk/Graphics/UI/Gtk/ModelView/TreeStore.hs:69:0: No instance nor default method for class operation System.Glib.Types.toGObject'
17:28:33 <dcoutts> Lemmih: ah ok, yes
17:28:36 <dibblego> also, the Java interface implementation is passed explicitly, instead of simply being in scope unambiguously
17:28:37 <gigamonkey_> Well, the "type parameter" in a Java interface is always used since the method always applies to instances that implement the interface
17:28:47 <Lemmih> dcoutts: With both my own application (using glade2) and with demo/treeList/treetest.
17:28:52 <dibblego> gigamonkey_, not always
17:29:03 <gigamonkey_> dibblego: why not?
17:29:10 <dibblego> gigamonkey_, many people declare Java interfaces with methods that are pure
17:29:20 <dibblego> gigamonkey_, interface Sum{int sum(int a, int b);}
17:29:28 <dcoutts> Lemmih: yes, changes in the OOP class mechanism we've not finished off yet
17:29:31 <gigamonkey_> Every method in interface X implicitly has an argument of type X
17:29:56 <dibblego> gigamonkey_, ok, but it may be ignored
17:29:58 <gigamonkey_> dibblego: yes, but sum implicitly has a this of type Sum.
17:30:07 <dibblego> gigamonkey_, agreed
17:30:11 <gigamonkey_> It's used at least in the method dispatch.
17:30:22 <Lemmih> dcoutts: Should I hold my breath or jump back a few patches?
17:30:46 <dcoutts> Lemmih: I'll try and look soon
17:31:11 <Lemmih> dcoutts: Thanks.
17:36:37 <gigamonkey_> dibblego: what is the rule that requires the type argument  to be used in a type class function?
17:36:46 <gigamonkey_> That it be used somewhere? As the first argument?
17:36:58 <dibblego> gigamonkey_, simply that it appears iirc
17:37:01 <dibblego> gigamonkey_, let me check
17:37:37 <dibblego> class Foo f where x :: Int -> Int
17:37:45 <dibblego> The class method `x'
17:37:46 <dibblego>     mentions none of the type variables of the class Foo f
17:38:13 <fnord123> @hoogle liftM
17:38:14 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
17:38:14 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
17:38:14 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
17:39:16 <gigamonkey_> Which implies class Foo f where x :: Int -> f would be okay? Which makes sense as that what you'd need for the type class of things that can be converted to *and* from strings.
17:39:20 <oerjan> fnord123: there are also liftM3 to 5, increasing number of arguments
17:39:28 <dibblego> gigamonkey_, yes that is ok
17:39:43 <fnord123> thanks oerjan.
17:39:57 <dibblego> gigamonkey_, it is effectively like the 'this' in Java that you referred to, being f
17:40:13 <gigamonkey_> Except not really ...
17:40:17 <dibblego> right
17:41:14 <gigamonkey_> If class Foo f  where x :: Bar -> f were a Java interface it would be implemented by Bar and would contain a method that returns type f
17:41:22 <gigamonkey_> Thus the 'this' would be a Bar not a Foo.
17:41:35 <gigamonkey_> So that's an interesting difference between type classes and interfaces.
17:41:59 <LoganCapaldo> err
17:41:59 <gigamonkey_> And a type class can have multiple type variables?
17:42:22 <dibblego> gigamonkey_, yes, called multi-parameter type classes (MPTC)
17:42:24 <LoganCapaldo> if Foo were a java interface this wouldn't necessarily be any type mentioned in that type
17:42:37 <ricky_clarkson> gigamonkey_: While there is no way of enforcing it, in recent Java versions covariant return types are possible.
17:42:42 <gigamonkey_> e.g. class Foo a b where x :: Int -> a -> b
17:42:54 <dibblego> gigamonkey_, no
17:42:54 <gigamonkey_> ricky_clarkson: but I think that's still different.
17:43:04 <ricky_clarkson> gigamonkey_: iow, String blah() is valid for implementing Object blah().
17:43:10 <dibblego> gigamonkey_, the kind changes
17:43:18 <gigamonkey_> dibblego: kind?
17:43:22 <sjanssen> gigamonkey_: also, Java interfaces can't really represent "class Eq a where (==) :: a -> a -> Bool"
17:43:36 <dibblego> gigamonkey_, a now accepts a type parameter (b)
17:43:38 <LoganCapaldo> class Zeep implements Foo<String> { public String x(Bar y); }
17:43:50 <dibblego> sjanssen, interface Eq<A>P{boolean eq(A a1, A a2);}
17:44:00 <dibblego> s/P{/{
17:44:08 <sjanssen> dibblego: not the same, as I understand it
17:44:10 <gigamonkey_> dibblego: I don't understand. you mean the way I wrote it?
17:44:17 <gigamonkey_> How would I write a MPTC?
17:44:27 <dibblego> gigamonkey_, my mistake, sorry
17:44:48 <dibblego> sjanssen, it is no less the same than any other attempt to emulate a type-class
17:44:49 <gigamonkey_> you mean I had it correct?
17:44:54 <dibblego> gigamonkey_, yes
17:44:58 <sjanssen> dibblego: erm, nevermind -- I see what you mean
17:45:23 <dibblego> gigamonkey_, sorry, my Haskell is rusty at the moment
17:45:36 <gigamonkey_> Cool. So i'd say Haskell type classes are to Java interfaces what Common Lisp generic functions are to single-dispatch methods. That should confuse everyone. ;-)
17:45:52 <ricky_clarkson> gigamonkey_: A superset.
17:46:01 <Pseudonym> They're not a superset.
17:46:15 <Pseudonym> A Java interface is also a type.
17:46:26 <Pseudonym> A typeclass isn't.
17:46:53 <TSC> Unless the implied-existential proposal is taken up (:
17:46:55 <gigamonkey_> So when you define a data type as being an instance of a MPTC, you only "fill in" one of the type variables, right?
17:47:11 <sjanssen> gigamonkey_: no, you fill in all of them
17:47:21 <Pseudonym> But you might fill in some of them with variables.
17:47:22 <gigamonkey_> Right, of course.
17:47:44 <Pseudonym> If you have fundeps, it sometimes doesn't make sense to do that, though.
17:50:38 <rickard1> @hoogle [(a -> b)] -> a -> [b]
17:50:38 <lambdabot> No matches, try a more general search
17:51:04 <TSC> sequence
17:51:10 <rickard1> like an inverted map, sorta... is there anything i can use
17:51:19 <rickard1> @type sequence
17:51:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:51:36 <Saizan> m = r ->
17:52:02 <ndm> @seen dons
17:52:02 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 31m 6s ago.
17:52:14 <pjd> gigamonkey_: another minor point is that type classes can provide implementations, while interfaces exist primarily not to
17:52:28 <DukeDave> > zipWith (-) [1.8,1.85..1.95] [1.8,1.85,1.9,1.95]
17:52:30 <lambdabot>  [0.0,0.0,2.220446049250313e-16,2.220446049250313e-16]
17:52:34 <gigamonkey_> the type class can provide an implementation?
17:52:49 <dibblego> gigamonkey_, yes, the Eq type-class is a good example
17:52:51 <DukeDave> Now that, is very annoying :|
17:52:58 <gigamonkey_> or the "instance" form?
17:53:06 <pjd> gigamonkey_: both can
17:53:06 <dibblego> gigamonkey_, no, the type-class
17:53:16 * DukeDave just spend over an hour trying to debug as a result :(
17:53:16 <TSC> It's a "default" implementation
17:53:28 <james_britt> Hi all
17:53:32 <oerjan> @pl \a -> map ($a)
17:53:33 <lambdabot> map . flip id
17:53:40 <DukeDave> Surely it shouldn't happen?
17:53:42 <FMota> hm
17:53:46 <pjd> usually, the type class will provide useful defaults, so that instances are only required to implement a minimal set of methods
17:53:56 <FMota> is there any Mac IDE for Haskell?
17:53:59 <oerjan> :t flip (map . flip id)
17:54:01 <lambdabot> forall a c. [a -> c] -> a -> [c]
17:55:33 <pjd> gigamonkey_: the documentation for a type class will often say something like "Minimal complete definition: foo and bar"
17:56:12 <james_britt> I'm supposed to give an Intro to Haskell talk, but my Haskell-fu is not what I had hoped to be by now.  What should a basic intro/overview cover?
17:56:29 <pjd> the other difference is that you "instantiate" type classes to the equivalent of Java classes, not Java instances
17:56:33 <dibblego> james_britt, what SPJ covered in A Taste of Haskell
17:56:50 <james_britt> The OSCON vids?
17:56:51 <pjd> so they're probably somewhere between metaclasses and abstract base classes
17:56:57 <dibblego> james_britt, yes, and slides
17:57:08 <james_britt> I see.
17:57:11 <pjd> and generic functions
17:57:49 <pjd> in fact, a "package of generic functions" is probably the best analogy
17:58:03 <fnord123> I thought Wadler hijacked his work on typeclasses and got that into Java as generics. How is this all different from Java interfaces?
17:58:37 <DukeDave> fnord123: It's less fugly? :)
17:59:02 <james_britt> dibblego: Thanks!
17:59:02 <dibblego> fnord123, there are some significant differences; try writing the Monad abstraction for example
17:59:10 <dibblego> james_britt, no prob
17:59:34 <fnord123> dibblego: no, because I don't know java
17:59:46 <dibblego> fnord123, ok, so it is not possible
17:59:47 <ricky_clarkson> You can't make a class implement an interface without its source stating that it does (is that a difference between typeclasses and interfaces)?
18:00:16 <dibblego> ricky_clarkson, and its accompanying implementation
18:00:36 <ricky_clarkson> Yes, assuming the interface declares any methods.
18:00:45 <dibblego> in Java, you use the newtype keyword; oh wait, no, you write a zillion lines of code and call it the "decorator pattern"
18:00:45 <twanvl> You can't even have an interface for a function a -> a -> Bool
18:00:46 <dibblego> :)
18:01:00 <hpaste>  rickard1 pasted "Inverted map (sort of)" at http://hpaste.org/2489
18:01:03 <dibblego> twanvl, can too
18:01:08 <twanvl> You can?
18:01:20 <dibblego> twanvl, sure, I wrote one years ago when I got tired of Java collections
18:01:39 <ricky_clarkson> twanvl: interface Blah<A> { boolean blah(A a,A b); }
18:01:43 <dibblego> interface Eq<A>{boolean eq(A a1, A a2);}
18:02:00 <dibblego> class StringEq implements Eq<String> ...
18:02:18 <hpaste>  oerjan annotated "Inverted map (sort of)" with "yes" at http://hpaste.org/2489#a1
18:02:18 <dibblego> though, that's more like a -> a -> Bool uncurried
18:02:21 <fnord123> dibblego: that's why I never learned java beyond 'oh i probably want to learn an ide to generate this boiler plate for me'
18:02:26 <dibblego> ?type uncurry (==)
18:02:28 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
18:02:36 <dibblego> fnord123, I wouldn't bother
18:03:28 <twanvl> But then you need to explicitly name the instance you use, that is perhaps more like an ML signature
18:03:34 <dibblego> fnord123, I very much doubt that Michael Schumacher would like to learn how to drive a horse and carriage
18:03:35 <rickard1> oerjan: How does that eval?
18:03:45 <ricky_clarkson> fnord123: Java ides only enforce the status quo - it gets awkward to use 3rd party code generators with them.
18:03:51 <dibblego> twanvl, yes, type-classes are implicit
18:04:05 <ricky_clarkson> ..and they aren't actually that good at generating (or hiding generated) code.
18:04:27 <dibblego> if they were good at it, we'd be viewing Haskell that compiles to the JVM
18:04:29 <oerjan> rickard1: ($ x) == \f -> f $ x == \f -> f x
18:05:00 <fnord123> dibblego: that's quite a compliment. :)
18:05:19 <dibblego> fnord123, I was exaggerating slightly to make the point :)
18:05:46 <dibblego> fnord123, the best Java programmer in the world knows Haskell very well and Java barely at al
18:05:55 <pjd> dibblego: cue Brian Alliet's LambdaVM
18:06:36 <rickard1> oerjan: How does '$' do the magic?
18:06:50 <oerjan> @src $
18:06:51 <lambdabot> f $ x = f x
18:06:59 <augustss> no magic
18:07:00 <oerjan> it's just an ordinary operator
18:07:05 <TSC> ($x) is an operator section, like (*2)
18:08:16 <pjd> ($) = (curry . uncurry) id
18:08:56 <twanvl> ($) = id :: ((a -> b) -> (a -> b))
18:09:11 <augustss> ($) = id, but with a different type
18:09:36 <pjd> an act of type inference
18:10:08 <augustss> Hmmm, why isn't ($)=id
18:10:11 <augustss> ?
18:10:42 <oerjan> augustss: extra type checking?
18:10:42 <james_britt> LoganCapaldo_: Hey.  Are are there Ruby/Haskell bindings? :)
18:10:48 <dibblego> augustss, good question
18:10:48 <pjd> well, foo $ bar == foo `id` bar
18:11:07 <pjd> same for prefix
18:11:36 <augustss> > id 5
18:11:41 <twanvl> > ($) 5
18:11:42 <lambdabot>  5
18:11:44 <lambdabot>   add an instance declaration for (Num (a -> b))
18:11:44 <augustss> > ($) 5
18:11:46 <lambdabot>   add an instance declaration for (Num (a -> b))
18:11:58 <pjd> err, true that
18:12:18 <augustss> could have been useful with ($)-id
18:12:25 <augustss> ($)=id
18:12:41 <oerjan> augustss: but is there any case where you would actually need it?
18:13:01 <twanvl> code obfuscation?
18:13:03 <oerjan> if you use it as an operator, you must use it at the type of $ anyhow
18:15:00 <TuringTest> augustss: `id` is infixl 9 but ($) is infixr 0
18:15:18 <OceanSpray> OHAI
18:15:30 <TuringTest> augustss: http://www.haskell.org/onlinereport/decls.html#sect4.4.2
18:15:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2490
18:15:31 <lambdabot> Title: The Haskell 98 Report: Declarations
18:15:31 <twanvl> > let ($) = id in ($) ( ($) (+) 1 $ ($) ($) 1 $)
18:15:33 <lambdabot>  2
18:16:17 <pjd> twanvl: Inflation Haskell?
18:16:28 <twanvl> > let ($) = id in  (1$) + (2$)
18:16:34 <lambdabot>  3
18:16:49 <augustss> Money! :)
18:16:57 <sorear> @users
18:16:57 <lambdabot> Maximum users seen in #haskell: 392, currently: 357 (91.1%), active: 24 (6.7%)
18:20:14 <dons> wow, anyone seen this, http://ircbrowse.com/cdates.html?channel=haskell ?
18:20:20 <lambdabot> Title: Meme Channel haskell by Dates
18:20:25 <dons> ddarius, shapr: monthly size stats for #haskell since 2001
18:20:28 <thoughtpolice> woop. :) got my network sniffer a little reworked. go bos for pcap enhancements! :)
18:20:37 <dons> note it starts of cold and gets hot mid-last year
18:21:25 <dons> the trend up starts somewhere in 2005?
18:22:36 <oerjan> is there a color chart?
18:22:41 <thoughtpolice> dons: there's also searchirc which allows channel statistics to be embedded into a site
18:22:49 <dons> thoughtpolice: ah!
18:22:52 <thoughtpolice> which is tracking haskell :)
18:22:57 <dons> url?
18:23:06 <thoughtpolice> http://searchirc.com
18:23:08 <lambdabot> Title: Search IRC, the most advanced IRC search engine.
18:23:21 <thoughtpolice> notably you do: <script language="JavaScript" src="http://searchirc.com/searchirc_chan_stats.php?n=59&c=I2hhc2tlbGw=&o=2"></script>
18:23:21 <lambdabot> http://searchirc.com/searchirc_chan_stats.php?n=59&c=I2hhc2tlbGw=&o=2"></script>
18:23:31 <lament> you need to register to actually search :(
18:23:37 <thoughtpolice> and it'll put haskell stats in your site (analogous to lambdabot's ?users)
18:23:48 <dons> cool.
18:24:02 <dons> i'll add it to the stats page
18:24:11 <dons> ?where stats
18:24:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
18:24:17 <oerjan> lament: tunes.org's version is googleable
18:24:35 <dons> lament: we also have a darcs repo of the logs
18:24:42 <dons> if you'd like to have a local copy. very useful
18:24:43 <thoughtpolice> dons: apparently on searchirc #haskell has a 5 star rating with the comment "Friendliest programming-related IRC channel ever."
18:24:49 <dons> :)
18:24:53 <thoughtpolice> :>
18:24:56 <lament> no surprises there.
18:25:36 <Pseudonym> thoughtpolice: You suck.
18:25:58 <dons> heh
18:26:07 <thoughtpolice> :(
18:26:16 <thoughtpolice> (insert crying here)
18:26:19 <dons> Pseudonym single handly provokes bad reviews for the channel :)
18:26:26 <Pseudonym> Woo!
18:26:36 * Pseudonym rarely does anything single-handedly.
18:26:48 <dons> yeah, its a skill
18:27:15 <lament> #haskell: This is the worst channel ever. Come there and they'll eat you alive! And for every question, they just tell you to use monads.
18:27:39 <dons> heh
18:27:59 <dons> or arrows, or applicative functors, oh noes!
18:28:00 <TuringTest> dons: How is the move going?
18:28:02 <sjanssen> lament: express that statement monadically
18:28:09 <dons> TuringTest: 2 days to go. busy!
18:28:11 <gravity> "Get your radioactive fruit in your spacesuit, n00b!"
18:28:18 <thoughtpolice> there's also this site: http://ircimages.com/
18:28:19 <lambdabot> Title: IRCImages!
18:28:21 <thoughtpolice> which looks cool
18:28:22 <dons> gravity: :)
18:28:25 <thoughtpolice> but apparently somewhat NSFW :/
18:29:09 <lament> I'm running out of money and about to be evicted, what should i do? Use monads! My girlfriend dumped me, what should i do? Use applicative functors!
18:29:23 * lament has no idea what he just said
18:29:33 <dons> lament: callCC perhaps, for the last?
18:29:38 <dons> ?quote continuation
18:29:38 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
18:29:45 <dons> ?quote throw
18:29:45 <lambdabot> Daveman says: Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
18:29:53 <dons> ?quote throw.*cont
18:29:54 <lambdabot> No quotes match. My mind is going. I can feel it.
18:30:36 <dons> i thought we had a quote about finding a new gf by throwing a continuatoin
18:30:36 <lament> call/cc would be a very useful thing in life in general
18:31:15 <lament> ?quote girlfriend
18:31:16 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
18:31:19 <oerjan> @remember lament I'm running out of money and about to be evicted, what should i do? Use monads! My girlfriend dumped me, what should i do? Use applicative functors!
18:31:19 <lambdabot> Done.
18:31:24 <dons> so that ircbrowse site needs more colours. anything about about 3k lo text yields 'red'
18:31:37 <dons> even though #haskell can get up to about 7k a day, on the really hot days
18:32:57 <fasta> dons: is there an unsafeInterleaveM function?
18:33:35 <dons> nope. sounds curious though
18:33:53 <dons> curious/scary
18:34:03 <dons> it would be rather unsafe, I think...
18:34:08 <sjanssen> fasta: what should it do?
18:34:24 <thoughtpolice> dons: also, I read the hs-plugins paper and I've worked out getting dynamics working with dynCompileExpr in some basic examples. much better than unsafeCoerce# :)
18:34:30 <dons> ah nice!
18:34:39 <fasta> sjanssen: it should delay evaluation of the rhs of a foo <- bar
18:34:45 <fasta> sjanssen: for any monad
18:34:46 <dons> i'm glad some things i wrote once upon a time turn out to actually work :)
18:34:59 <sjanssen> fasta: the only monads that support that are IO and ST, btw
18:35:08 <dons> thoughtpolice: so do you get a nice type error for the type incorrect case?
18:35:12 <sjanssen> fasta: I suppose you want something you can use in transformers?
18:35:16 <fasta> sjanssen: support what?
18:35:28 <sjanssen> fasta: unsafeInterleave*
18:35:32 <dons> ?src unsafeInterleaveIO
18:35:32 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
18:35:36 <sjanssen> @hoogle unsafeInterleave
18:35:36 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
18:35:36 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
18:35:53 <thoughtpolice> dons: i've only done a couple experiments; so far the ones I've been using have worked but I'll be sure to try some type incorrect stuff.
18:36:00 <dons> so you step inside the monadic container, allocate a thunk for the result, and continue
18:36:19 <dons> thoughtpolice: there's some nice examples in the hs-plugins testsuite
18:36:27 <dons> if you want to reuse a test suite
18:36:50 <thoughtpolice> the main restriction of course is the Typeable constraint (depends on how you view it,) but it can be eliminated by making a record-structure holding interesting-fields and just deriving Typeable right there.
18:37:17 <dons> yep
18:37:32 <sjanssen> fasta: I think it's hard to do unsafeInterleave with eg. StateT x IO
18:37:36 <dons> you can use existentials, and typeable the existential box, to hide other things in there
18:38:33 <thoughtpolice> so far though it works. if I go into a library with it it should be easy to plug in your own datatypes for plugins and whatnot (really easy, actually) but that's the main thing. it seems to 'just work' though. :>
18:38:46 <dons> yeah. good!
18:38:58 <thoughtpolice> i'll just have to experiment around and see what I get. :)
18:39:16 <dons> the key thing is to have Simon marlow maintain the dynamic linker stuff, so the plugin library doesn't have to worry about parsing .hi files or working out which linker frameworks to use
18:40:07 <thoughtpolice> yeah; .hi's change format just about every single release iirc
18:40:12 <SamB> dons: sounds like a sweet deal
18:40:21 <SamB> thoughtpolice: more often, even!
18:40:38 <thoughtpolice> SamB: what, even minor releases?
18:40:45 <thoughtpolice> (i was talking major above, fyi)
18:40:57 <DukeDave> > foldr2 f g xs = if length xs > 1 then f xs : f (g xs) else []
18:40:58 <lambdabot>  Parse error
18:40:58 <SamB> thoughtpolice: I was thinking more like over the course of the development branch's life time
18:41:26 <thoughtpolice> ah, wouldn't suprise me.
18:41:39 <dons> that's the main thing that makes hs-plugins hard to maintain
18:41:52 <DukeDave> > (\ f g xs -> if length xs > 1 then f xs : f (g xs) else [])
18:41:53 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
18:41:53 <lambdabot>       Expected...
18:41:54 <thoughtpolice> specs like that change so often?
18:41:55 <dons> any change to the package.conf format, the .hi format, or the symbol definitions in the object file, breaks it
18:41:57 <sjanssen> dons: do you know the status of NDP in GHC 6.7?
18:42:02 <thoughtpolice> yeah.
18:42:02 <dons> whihc happens every major release
18:42:03 <SamB> thoughtpolice: it isn't supposed to BE a spec
18:42:10 <dons> sjanssen: experimental.
18:42:11 <SamB> the .hi format, I mean
18:42:19 <thoughtpolice> SamB: right. :x
18:42:21 <dons> sjanssen: i don't think it will be announced with 6.8, but the code will be in there
18:42:27 <oerjan> DukeDave: use let
18:42:36 <sjanssen> dons: will my code actually run in parallel?  I don't mind if it's a bit fragile
18:42:39 <oerjan> or @let
18:42:42 <DukeDave> oerjan: My concern is the infinite type error
18:42:48 <SamB> sjanssen: do you have two cores?
18:42:50 <dons> sjanssen: some stuff already does, yeah. (simple array programs).
18:42:58 <sjanssen> SamB: yep
18:43:09 <dons> to get the exact status, you best ask ChilliX or rl, though.
18:43:17 <SamB> yeah
18:43:22 <DukeDave> oerjan: Suggestions welcome :|
18:43:43 <dons> sjanssen: btw, did you respond to jdh's sudoku trolling?
18:44:06 <oerjan> DukeDave: f ... : f ... cannot typecheck unless f is polymorphic, which only a let or where can do
18:44:14 <dons> he reposted the ugly ocaml one, for a second time. :)
18:44:31 <oerjan> a lambda-bound variable never is
18:44:31 <sjanssen> dons: ChaddaÃ¯ FouchÃ© beat me to it
18:44:50 <dons> ah yes, I see
18:45:14 <DukeDave> oerjan: Okay I'm with you so far but where would I place the let?
18:45:17 <DukeDave> (or where)
18:45:30 <oerjan> oh, and btw you need an explicit type annotation for polymorphic recursion
18:45:40 <oerjan> assuming that is really what you want to do
18:45:41 <dibblego> dons, speaking of, my response to F# mailing list regarding polymorphic variants seems to have been censored (didn't ever appear)
18:46:00 <DukeDave> I already specified    foldr2 :: ([[a]] -> [a]) -> ([[a]] -> [[a]]) -> [[a]] -> [a]
18:46:21 <dons> dibblego: oh, that's interesting.
18:47:00 <dibblego> dons, I basically said, "as has been pointed out on Haskell-Cafe, it is indeed possible..."
18:47:17 <oerjan> DukeDave: could you paste? it is a bit hard to page up and down
18:47:40 <DukeDave> oerjan: Sure, thanks for sticking with me :)
18:50:19 <hpaste>  DukeDave pasted "Unification would give infinite type" at http://hpaste.org/2491
18:51:24 <oerjan> hm... shouldn't the recursion use foldr2?
18:51:24 <fasta> When I define FOO on the command line to be 1 and I define it in the source file to be 0, what value get's used (cpphs)?
18:51:42 <DukeDave> oerjan: Use that is a rather glaring error isn't it :)
18:51:59 <oerjan> f xs : foldr2 f g (g xs)
18:52:07 <hpaste>  DukeDave annotated "Unification would give infinite type" with "Silly mistake" at http://hpaste.org/2491#a1
18:52:32 <oerjan> you forgot the g
18:52:45 <DukeDave> Lol
18:52:46 <pjd> dibblego: never attribute to malice what can be explained by broken mailing list software
18:53:11 <hpaste>  DukeDave annotated "Unification would give infinite type" with "Maybe it's too late" at http://hpaste.org/2491#a2
18:53:32 <DukeDave> Hm, it still yield that type error though
18:53:40 <dibblego> pjd, my 3 previous posts which were merely questions (i.e. why can't it be done in Haskell?) went through fine, but I'm certainly open to my post and the mailing list breaking, coinciding
18:54:00 <pjd> oh, okay
18:54:14 <pjd> is it moderated?
18:54:27 <dibblego> pjd, no idea; I only read it except for that one time
18:55:04 <hpaste>  oerjan annotated "Unification would give infinite type" with "teehee" at http://hpaste.org/2491#a3
18:55:37 <ChilliX> sjanssen: As dons said, DPH is in the head and will be in 6.8, but as an unannounced feature (ie, we make no guarantees on support for it in 6.8 as its still to experimental)
18:55:38 <dibblego> pjd, http://rafb.net/p/HK0iUJ11.html perhaps slightly inflammatory
18:55:39 <lambdabot> Title: Nopaste - No description
18:56:16 <ChilliX> sjanssen: but it does use the mult-threaded runtime and hence does use multiple cores
18:56:51 <sjanssen> ChilliX: should I be using the ndp package too?
18:57:26 <oerjan> DukeDave: i think that [[a]] should be [a]
18:58:09 <pjd> dibblego: maybe a mite tad :)
18:58:16 <oerjan> or maybe you want f (head xs)
18:58:42 <oerjan> in which case g's type should have [[a]]'s
18:58:47 <pjd> think friendlier
18:58:50 <pjd> WWSPJD?
18:59:55 <DukeDave> oerjan: Damn that's neat :)
19:00:09 <DukeDave> Completely different way of looking at it, I love the use of iterate
19:00:16 <thoughtpolice> are the 6.7 snapshots generally stable? I've been meaning to try and play with the new debugger :)
19:00:20 * DukeDave wishes he was that smart :(
19:00:32 <DukeDave> @karma oerjan++
19:00:33 <lambdabot> oerjan++ has a karma of 0
19:01:06 <fasta> thoughtpolice: the new debugger is not a fun toy.
19:01:12 <pjd> @karma+ oejan
19:01:12 <lambdabot> oejan's karma raised to 1.
19:01:17 <thoughtpolice> fasta: :(
19:01:19 <pjd> d'oh
19:01:23 <pjd> @karma+ oerjan
19:01:23 <lambdabot> oerjan's karma raised to 4.
19:01:25 <oerjan> :D
19:01:29 <ChilliX> sjanssen: The ndp package is part of DPH - its the API and runtime system.
19:01:42 <fasta> thoughtpolice: but don't let my enthusiasm spoil all the fun for you ;)
19:02:02 <thoughtpolice> hah.
19:02:09 <oerjan> oejan--
19:02:10 <dcoutts> Lemmih: pushed, but we still seem to have some problems.
19:02:21 <thoughtpolice> hm maybe I should just let 6.7 compile during school tomorrow..
19:02:24 <fasta> pjd: define WWSPJD please
19:02:43 <pjd> fasta: What Would Simon Peyton-Jones Do?
19:02:45 <thoughtpolice> what would simon peyton-jones do :>
19:02:56 <fasta> ::)
19:02:59 <dhpeterson> is there a DPH page on the haskell wiki yet?
19:03:06 <DukeDave> pjd: Cheers!
19:03:10 <thoughtpolice> dhpeterson: yes
19:03:13 <dhpeterson> link?
19:03:32 <thoughtpolice> http://haskell.org/haskellwiki/Data_Parallel_Haskell
19:03:33 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
19:03:40 <dhpeterson> thnx
19:04:04 <sjanssen> ChilliX: okay, thanks
19:04:18 <dhpeterson> DPH doesn't provide any concurrency in computation right?
19:04:25 <dhpeterson> or does it
19:05:06 <dhpeterson> ahh ndp
19:05:15 <ChilliX> dhpeterson: not sure what you mean
19:05:26 <dhpeterson> ChilliX: it was a stupid question sorry
19:05:29 * thoughtpolice can't wait 6.8's release :)
19:05:35 <thoughtpolice> s/wait/wait for/
19:05:42 <hpaste>  oerjan annotated "Unification would give infinite type" with "lazier" at http://hpaste.org/2491#a4
19:05:44 <fasta> thoughtpolice: to answer your question 6.7 is more stable than 6.6.1
19:06:00 <fasta> thoughtpolice: where stable is defined as containing far fewer bugs
19:06:10 <dhpeterson> how does DPH work in a multi-core CPU environment - do the computations automatically span the available cores?
19:06:23 <dhpeterson> that was what i meant
19:06:33 <thoughtpolice> dhpeterson: basically yes.
19:06:46 <dhpeterson> ok
19:07:00 <dhpeterson> what about in a distributed sense - e.g. like erlang across multiple nodes
19:07:07 <dhpeterson> is that kind of thing planned or not?
19:07:14 <thoughtpolice> as ChilliX said it uses the multi-threaded runtime so yes, it does span multiple cores
19:07:20 <ChilliX> dhpeterson: DPH currently only targets multicore/SMP machines
19:07:31 <dhpeterson> aha
19:07:35 <DukeDave> oerjan: That new version makes on less call on iterate correct?
19:07:52 <ChilliX> support for distributed processors and also GPUs is in principle possible, but we don't supoport that right now
19:07:56 <DukeDave> oerjan: Or, iterate generates one less value..
19:08:30 <oerjan> DukeDave: (not null . drop 1) should be the same as ((> 1) . length) for finite lists
19:08:56 <oerjan> but it avoids looking at the whole list
19:08:58 <ChilliX> if you do something like "mapP f myarray" then the "f" is ran in parallel on parts of the array on different cores
19:09:07 <dhpeterson> right
19:09:08 <dhpeterson> very cool
19:09:27 <dhpeterson> ChilliX: is there a dependency / relationship between DPH and the STM stuff?
19:09:44 <ChilliX> both map down to the same runtime primtives of GHC
19:09:45 <LoganCapaldo> that always struck me as needing really big arrays or really really complicated fs to actually be worth it
19:10:06 <ChilliX> in principle, you should be able to suse both together in one program, but I dont' think that works properly yet
19:10:08 <DukeDave> oerjan: Ah yes I see now
19:10:15 <dhpeterson> ok
19:10:23 <DukeDave> I'll have to remember that technique
19:10:34 <dhpeterson> i'm fairly new to haskell and just trying to understand all the things happening in the space :)
19:10:39 <dhpeterson> ChilliX: thnx
19:10:46 <joed> So far Programming Haskell is an A++ book, and easy to get in a week from Barnes and Nobles.
19:11:01 <ChilliX> LoganCapaldo: its all about data parallelism; ie, without much data (= big arrays), there is no point
19:11:39 <newsham> i think hutton's book is a great intro, but it doesnt go into much depth.
19:11:51 <thoughtpolice> the new ndp stuff definately looks really awesome though. :) i will be sure to find some way to abuse it once 6.8 is out.
19:12:20 <joed> I bought this of the Haskell.org list. And it has the K&R feel.
19:13:00 <newsham> i have high expectations for the upcoming oreilly book
19:13:13 <joed> When is that due?
19:13:21 <newsham> next year I think
19:13:29 <joed> Interesting.
19:13:40 <newsham> http://radar.oreilly.com/archives/2007/05/real_world_hask.html
19:13:41 <lambdabot> Title: Real World Haskell title under development
19:14:46 <thoughtpolice> you'll be able to read the chapters online as they're published though (creative commons,) although nothing's quite out yet
19:14:56 <newsham> http://www.realworldhaskell.org/blog/
19:14:58 <thoughtpolice> http://www.realworldhaskell.org
19:14:58 <lambdabot> Title: Real World Haskell
19:14:59 <lambdabot> Title: Real World Haskell
19:15:10 <newsham> :)
19:16:08 <newsham> wow OSCON talk is 50% more popular than all the other videos.. thats impressive
19:16:39 <SamB> how much longer is it than the others?
19:17:02 <newsham> no idea
19:17:41 <thoughtpolice> only one's I watched were simon's and yegge's keynotes.
19:17:51 <thoughtpolice> i think yegge's was around the same amount of time, maybe longer
19:20:21 <zmike> The OSCON 'tutorial' talk is 3 hours long
19:20:46 <SamB> zmike: in two parts, yes
19:21:02 <zmike> Wasn't it 50% more popular than all the other videos *combined*?
19:21:04 <SamB> SPJ's other talk was supposed to be 15 minutes
19:21:20 <zmike> I watched the tutorial and the keynote
19:21:30 <zmike> The keynote was incredibly for only being 20 minutes long
19:21:41 <zmike> err incredible
19:21:53 <SamB> ah
19:22:18 <SamB> incredible because it was only that long, or because of how much he squeezed in there?
19:22:18 <zmike> I wonder how many other interesting things I could learn passively in only 20 minutes
19:22:38 <zmike> because of how well I felt I understood STM after watching it
19:22:56 <SamB> ah
19:23:08 <SamB> I already understood STM so I guess I wasn't too wowed
19:23:16 <zmike> It was as if he didn't waste a single word
19:23:23 <SamB> hmm.
19:23:26 <SamB> yeah, I guess so ;-)
19:24:38 <newsham> save the words
19:24:59 <newsham> its starting to sound like a cult in here :)
19:26:09 <newsham> it was a good talk, but he didnt part the red sea
19:26:45 <pjd> newsham: better, he Haskelled the unwashed hordes
19:26:53 <zmike> He's a really good public speaker
19:27:07 <newsham> and then they went home and perl'd, pjd.
19:27:26 <pjd> newsham: on pugs?
19:27:27 <newsham> the language everyone wants to know but nobody wants to learn :)
19:27:57 <Adamant> what work are Haskellers doing on shared-nothing concurrency?
19:28:18 <FMota> SPJ = talking god
19:28:26 <pjd> isn't shared-nothing concurrency called "parallelism"? :)
19:28:27 <SamB> Adamant: we could be inventing Haskell concurrently with aliens with whom we share nothing
19:28:36 <Olathe> Heheh
19:28:52 <FMota> lol
19:29:07 <newsham> is cvs better than darcs for sharing nothing?
19:29:16 <pjd> haha
19:29:18 <FMota> I don't think aliens would use the same syntax, though.
19:29:39 <newsham> aliens tend to compute with I,C,F and P symbols
19:30:08 <SamB> ... those aliens are evil anyway
19:30:26 <FMota> *shudder*
19:30:28 <SamB> though actually some of their code looks like Haskell to me
19:30:34 <SamB> they even keep it in a .hs file!
19:30:53 <Adamant> eh. was trying to talk about Erlang-like approaches to concurrency
19:30:55 <FMota> You think maybe they stole it from a human?
19:31:30 <thoughtpolice> zmike: agreed, I find his talks and writing very eloquent
19:32:17 <newsham> samb: they use some sort of haddock derivative, from what I can tell
19:32:32 <SamB_XP_> that too
19:32:40 <SamB_XP_> or so it looked
19:32:56 <SamB_XP_> i.e. it was a good rendition
19:33:41 * Adamant shrugs
19:34:23 <SamB_XP_> somehow I suspect they may have run haddock over a file, massaged the HTML, and converted it into ... whatever format that is
19:36:33 <syntaxfree> This is gonna come across like a really stupid thing to ask.
19:36:40 <syntaxfree> but I guess I'm stupid.
19:37:17 <syntaxfree> I wanna read from stdin character by character, do something with that character and another data structure and output to stdout.
19:37:34 <syntaxfree> OH.
19:37:41 <SamB_XP_> getChar, putChar?
19:37:44 <SamB_XP_> or interact?
19:37:46 <syntaxfree> Nevermind. Just framing the question shook my brain into working.
19:37:57 <syntaxfree> yes, yes. I was about to ask something else.
19:39:02 <syntaxfree> I haven't programmed in months, and I'm afraid that the meds have shaved off the edge of my reasoning skills.
19:39:39 <syntaxfree> Not that I'm not doing math-intensive work all day, but programming was always just outside the comfort zone, and I'm scared it'll be out of each.
19:41:49 <newsham> syntaxfree: do you mean you want to read from the console/tty one character at a time without hte user having to hit enter?
19:42:14 <syntaxfree> I actually want to pipe it from an indefinitely running program.
19:42:17 <segher> another stupid question...  say i have a   data Smth = Num Int  , and i have an  x :: Smth  , how do i get the value of the integer out of x ?
19:42:21 <syntaxfree> To be concrete, tcpdump.
19:42:52 <newsham> getContents should work properly, no?
19:42:56 <newsham> it reads lazily.
19:43:13 <newsham> btw, why not use the pcap library for haskell?
19:43:24 <newsham> eliminate the middleman (program)
19:43:30 <syntaxfree> because I want to be able to pipe it from anything else.
19:43:33 <segher> do i need to make an accessor function?
19:43:37 <syntaxfree> maybe curl downloading a mp3, for example.
19:43:48 <newsham> ahh, so this isnt tcpdump specific
19:44:33 <oerjan> segher: case smth of Num x -> ... use x as Int in here ...
19:44:54 <segher> ah
19:45:20 <newsham> an accessor would also work.  also you could use a record to have haskell make you an accessor automatically
19:45:35 <segher> oerjan: thanks, i'll do the accessor thing then, i think i'll need it more often :-)
19:45:44 <newsham> data Smth = Smth { getNum :: Int }
19:45:54 <syntaxfree> > chr 0
19:45:56 <lambdabot>  '\NUL'
19:46:00 <syntaxfree> > chr 256
19:46:01 <lambdabot>  '\256'
19:46:02 <segher> newsham: a cool
19:46:04 <segher> ah
19:49:17 <segher> great, that works perfectly.  thanks!
19:49:53 <newsham> data Smth = Smth { getNum :: Int, getString :: String }
19:49:54 <newsham> :)
19:50:37 <newsham> btw, what are you trying to do?
19:50:53 <newsham> you can often get away with not making accessors
19:51:09 <segher> i'm doing "Implementing functional languages: a tutorial"
19:51:25 <segher> and learning better Haskell at the same time :-)
19:52:20 <segher> i'm in chapter 2.6.1 now
19:52:33 <segher> implementing arithmetic primitives
19:52:45 <sioraiocht> segher: good book?
19:53:18 <segher> yeah
19:53:23 <segher> really nice
19:53:32 <newsham> segher: you could implement your primitives directly off your type.  for example   add (Num x) (Num y) = Num (x+y)
19:53:39 <newsham> without using any accessors
19:53:55 <segher> well that would _be_ an accessor
19:54:18 <segher> the primitives i need to do do a lot more work than just the arithmetic
19:54:22 <syntaxfree> damn, my brain is dead weight.
19:54:41 <syntaxfree> so I have data structure x
19:55:10 <sorear> Argh.  I just spent two hours compiling GHC after reading the commit message for associated type synonyms... but before actually *pulling*
19:55:11 <newsham> right.. but using accessors all over the place might indicate that you didnt abstract away enough
19:55:22 <newsham> sorear: :(
19:55:26 <segher> newsham: but yeah that might be simpler, i have a whole bunch of binary operators to do
19:55:31 <oerjan> >_O
19:56:02 <newsham> you can even get fancy and declare Smth as an instance of Num
19:56:03 <segher> newsham: oh i use pattern matching everywhere else, it just won't work in the body of a function
19:56:10 <newsham> so that you can use normal "+" and "-" operators on them
19:56:19 <segher> heh
19:56:22 <segher> yeah i could do that
19:56:28 <newsham> segher: case works n a body
19:56:29 <segher> i won't bother here though
19:56:42 <segher> yeah, case -- but that's a whole bunch of typing
19:56:56 <segher> i see why it's needed though
19:56:58 <newsham> sounds like you know what you're doing though..
19:57:10 <segher> i hope so :-)
19:57:28 <segher> but i started doing haskell for real only a few weeks ago
19:57:49 <oerjan> segher: it's also possible to do it in a where clause: ... where Num x = smth
19:57:55 <segher> fifteen years ago i did Miranda, not sure if that helps or if that hurts instead ;-P
19:58:17 <segher> oerjan: i tried that, the compiler complained
19:59:11 <oerjan> that's strange, it should work
19:59:59 <syntaxfree> damn! I can't think!
20:00:16 <segher> oerjan: maybe it's because i wrote   where (Num n) = ...
20:00:36 <oerjan> i don't _think_ that should matter in this case
20:01:07 <oerjan> however, smth needs to be in scope in the where clause, if that's a problem
20:01:25 <segher> it was
20:01:51 <newsham> i imagine miranda could only help
20:02:09 <oerjan> maybe it was a non-exhaustive pattern warning? or a syntax error?
20:02:23 <segher> newsham: well it made me feel *really bad* about functional programming, at the time :-)
20:02:23 <newsham> > let (Just x) = (Just 5) in x
20:02:25 <lambdabot>  5
20:02:39 <sioraiocht> weird
20:02:46 <segher> oerjan: it was a syntax error.  i must have done something stupid :-)
20:02:47 <sioraiocht> that is freaky pattern matching
20:03:03 <sioraiocht> > let [x] = [1,2] in x
20:03:05 <lambdabot>   Irrefutable pattern failed for pattern [x]
20:03:08 <sioraiocht> > let [x] = [1] in x
20:03:10 <lambdabot>  1
20:03:12 <sioraiocht> so weird..
20:03:17 <segher> wow :-)
20:03:21 <oerjan> syntaxfree: then take a break, your brain doesn't want you to think right now
20:04:03 <segher> lazy non-evaluation, heh
20:04:20 <kpreid> Why are types and type classes in the same namespace?
20:04:40 <sioraiocht> kpreid: because if you made a type class the same name as a type, I'd stab you in the face
20:06:19 <segher> woohoo, my evaluator can do "main = negate 42" now :-)
20:06:23 <dolio> > let (f, g) = fix (\(f', g') -> (\n -> if n == 0 then 1 else g' n, \n -> n * f' (n - 1))) in f 6
20:06:25 <lambdabot>  Exception: <<loop>>
20:06:29 <oerjan> kpreid: one thing is that there is no way to distinguish them in import/export lists
20:06:47 <SamB_XP_> I wasn't under the impression that the Report was formulated in such a way as to prevent Black Mage attacks...
20:06:49 <kpreid> oerjan: there's a reason!
20:07:10 <newsham> > let [a,b,c,d] = words "this is a test" in unwords [a,d]
20:07:11 <lambdabot>  "this test"
20:07:21 <thoughtpolice> @remember sioraiocht if you made a type class the same name as a type, I'd stab you in the face
20:07:22 <lambdabot> Done.
20:07:28 <sioraiocht> LOL
20:07:52 <sioraiocht> my first quote!
20:08:10 <dolio> Type classes and types with the same name make some sense if you're trying to simulate OO programming in Haskell.
20:08:15 <thoughtpolice> @quote stab
20:08:15 <lambdabot> sioraiocht says: if you made a type class the same name as a type, I'd stab you in the face
20:08:20 <kpreid> dolio: Right, existential wrappers
20:08:29 <sioraiocht> dolio: That's a SIN!
20:08:39 <kpreid> I think that's the place where I first noticed the restriction existed.
20:08:58 <sioraiocht> If you're trying to do OO programming in a high level language, why not use OCaml?
20:09:06 <dolio> Yeah. That's the only place I've come across it.
20:09:56 <dolio> sioraiocht: Because OCaml isn't Haskell?
20:10:44 <sioraiocht> and thank god for that! =p I personally hate OO programming unless a task is particularly suited to it
20:11:38 <sioraiocht> @src (++)
20:11:38 <lambdabot> (++) []     ys = ys
20:11:38 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
20:12:12 <thoughtpolice> ocaml somewhat treats the OO system as a 'second class citizen' however. i couldn't recommend a replacement, though.
20:12:15 <dolio> Yeah, but in the case where it is, you can't have a type class and existential wrapper with the same name in Haskell. :)
20:13:48 <dolio> Although, I haven't seen a real world use of that, personally. I've only played with it to try and explain why you'd want existential types.
20:13:57 <kpreid> I went with class Foo; data AnyFoo = ...
20:14:36 <sioraiocht> thoughtpolice: I haven't ever even used OCaml, I think it looks hideous, though
20:15:12 <kpreid> Hm. Is a type class with no methods good for anything (besides computing boolean values with the typechecker)?
20:15:57 <sorear> kpreid: Violating parametricity without incurring the Wrath of Cale
20:16:06 <dolio> kpreid: You can use it as an alias for the intersection of several other type classes.
20:16:08 <sorear> @go Eval class haskell 1.4
20:16:10 <lambdabot> http://www.cs.sfu.ca/CC/SW/Haskell/hugs/manual-html/manual2.html
20:16:10 <lambdabot> Title: A technical summary of Hugs 1.4
20:16:12 <thoughtpolice> sioraiocht: i've said this several times before, I get intense feels of dislike when I see ocaml.
20:16:22 <thoughtpolice> s/feels/feelings/
20:16:32 <sioraiocht> thoughtpolice: maybe it's becuse we're spoiled
20:16:39 <sioraiocht> Haskell is just too pretty.
20:16:40 <kpreid> I thought of a third thing:
20:16:49 <bos> haskell people do rather look down their noses at ocaml in general, with the notable exception of oleg.
20:17:16 <kpreid> imagine "class ShowYieldsAHaskellExpression a"
20:17:17 <wli> I used to use ocaml.
20:17:31 <sioraiocht> I mean, I'd rather use it than...
20:17:33 <sioraiocht> C++
20:17:41 <sioraiocht> aka Satan's language
20:17:52 <wli> C++ is not quite that.
20:17:53 <kpreid> would that be a variety of "violating parametricity"?
20:17:58 <sorear> no.
20:18:06 <kpreid> Okay.
20:18:12 <sioraiocht> wli: do you have another candidate in mind? =p
20:18:23 <kpreid> (I know about the Eval/seq thing but I don't know exactly what parametricity is)
20:18:29 <wli> C++ is a rather notable "disaster area" of poor design actually exploding in people's faces.
20:18:36 <thoughtpolice> bos: oh, I got hsns to build fine with 0.3.1 (nice additions to remove the annoying withForeignPtr stuff btw,) the only requirement is still the pcapconfig.h file. if there's no way around it I can crib code from pcap 0.3.1 and include it in the source for 0.5.3.
20:18:37 <oerjan> sioraiocht: no, no, that would be http://esoteric.voxelperfect.net/wiki/Malbolge
20:18:38 <lambdabot> Title: Malbolge - Esolang
20:18:46 <sioraiocht> ...
20:18:50 <bos> thoughtpolice: ah yes, hang on.
20:18:51 <sioraiocht> touchÃ©
20:19:03 <wli> The "esoteric languages" might as well not exist.
20:19:19 <bos> thoughtpolice: is the problem that the include file isn't installed?
20:19:28 <thoughtpolice> bos: yes it seems so.
20:19:45 <sioraiocht> wli: http://scienceblogs.com/goodmath/goodmath/programming/pathological_programming/
20:19:48 <lambdabot> Title: Good Math, Bad Math, http://tinyurl.com/2zs4o2
20:19:58 <wli> sioraiocht: I would say something like perl.
20:20:23 <sioraiocht> hrm...
20:20:30 <sioraiocht> Perl does me good though, C++ never has
20:20:53 <wli> That's part of why perl is so dangerous.
20:20:55 <thoughtpolice> bos: but that's the only thing I've noticed so far. otherwise, good work. :) I cleaned up the code a bit with this version. i'm planning on going back to it for a 1.0 sometime but...
20:21:22 <sioraiocht> wli: because it's a necessary evil, sometimes?
20:22:06 <wli> Maybe not so much necessary as that it succeeds in tempting people.
20:22:15 <sioraiocht> it tempts me all the time
20:22:21 <sioraiocht> I did a whole summer of work on NLP in it
20:22:23 <bos> thoughtpolice: thanks
20:22:29 <sioraiocht> and frankly, I wouldn't have chosen any other language
20:22:34 <wli> O, the horror.
20:22:42 <sioraiocht> well, it was mostly my own code
20:22:48 <sioraiocht> and i use strict, which helps some ;)
20:23:09 <thoughtpolice> anyway, I feel like sleep now. :)
20:24:07 <wli> It's dangerous because it's so pathological while actually having some sort of hook to make inroads.
20:24:42 <sioraiocht> i know
20:24:57 <sioraiocht> and proponents of it think of everything as a "feature"
20:25:01 <SamB_XP_> I wonder if they're latest one is sane enough to implement in anything but Haskell...
20:25:02 * dolio is no fan of Perl.
20:25:19 <wli> A pathological language no one would seriously attempt to use is not particularly threatening.
20:25:46 <wli> So that's why Perl is my candidate for "Satan's language."
20:26:16 <glguy> Hurray for being force to do anti-spyware tech support for your mother-in-law over the phone..
20:26:19 <glguy> .
20:26:23 <dolio> I was required to write most of my theoretical CS assignments (finite automata, etc.) in perl.
20:26:36 <dolio> Not my first choice.
20:28:08 <sioraiocht> dolio: now THAT would kill me
20:28:31 <wli> I would spontaneously combust.
20:28:42 <sioraiocht> it really only works for me when I have to do a lot of regexp stuff
20:28:45 <sioraiocht> and then I like it fine
20:29:23 <dolio> I probably spent an hour trying to figure out how to represent a matrix in terms of nested arrays.
20:29:45 <dolio> And then gave up, and used hashes indexed by "$i,$j".
20:30:37 <sioraiocht> dolio, that latter is probablu more perlish, anyway
20:30:53 <dolio> I don't doubt it. :)
20:30:59 <dolio> Seems nasty, though. :)
20:31:59 <sfultong> shapr: I read the speech by Hamming that you recommended
20:32:34 <sioraiocht> @quote sioraiocht
20:32:34 <lambdabot> sioraiocht says: if you made a type class the same name as a type, I'd stab you in the face
20:32:37 <sioraiocht> SQUEE
20:32:38 <sioraiocht> alright all
20:32:40 <sioraiocht> have a good night
20:33:09 <sfultong> @quote
20:33:09 <lambdabot> Gahhh says: monads are usually a personal experience.
20:33:16 <sior|sleep> haahahaahahah
20:33:18 <sior|sleep> so true!
20:33:47 <sfultong> heh, how many quotes are there, anyway?
20:33:59 <wli> What's this speech by Hamming?
20:35:43 <sfultong> wli: http://www.cs.virginia.edu/~robins/YouAndYourResearch.html
20:35:44 <lambdabot> Title: You and Your Research
20:36:08 <shapr> sfultong: What do you think?
20:36:30 <shapr> sfultong: Do you think a book-length expansion would be worth reading?
20:36:30 <Nafai> I've been meaning to read that
20:36:51 <sfultong> shapr: I thought it was interesting, I would not read a book-length expansion
20:37:07 <shapr> ok
20:37:29 <sfultong> most of what he said seemed good advice, but not especially enlightening
20:39:44 <syntaxfree> argh! nonlazy evaluation is weeeeird.
20:39:53 <oerjan> @let merge (x:xs) (y:ys) = case compare x y of {LT -> x:merge xs (y:ys); EQ -> x:merge xs ys; GT -> y:merge (x:xs) ys}; hamming fs = h where h = 1:foldr1 merge (map (flip map h) fs)
20:39:54 <lambdabot> <local>:8:89:     Ambiguous occurrence `GT'     It could refer to either `GT'...
20:40:07 <oerjan> > GT
20:40:08 <lambdabot>  GT
20:40:25 <oerjan> @undefine
20:40:30 <lambdabot> Undefined.
20:40:32 <oerjan> @let merge (x:xs) (y:ys) = case compare x y of {LT -> x:merge xs (y:ys); EQ -> x:merge xs ys; GT -> y:merge (x:xs) ys}; hamming fs = h where h = 1:foldr1 merge (map (flip map h) fs)
20:40:33 <lambdabot> <local>:1:89:     Ambiguous occurrence `GT'     It could refer to either `GT'...
20:41:00 <oerjan> @let merge (x:xs) (y:ys) = case compare x y of {LT -> x:merge xs (y:ys); EQ -> x:merge xs ys; Prelude.GT -> y:merge (x:xs) ys}; hamming fs = h where h = 1:foldr1 merge (map (flip map h) fs)
20:41:03 <lambdabot> Defined.
20:41:22 <oerjan> > hamming [(*2),(*3),(*5)]
20:41:24 <lambdabot>  [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72...
20:41:46 <Pseudonym> I recommend these Sun papers on transactional memory, BTW.
20:41:49 <Pseudonym> Interesting stuff.
20:42:04 <Pseudonym> http://research.sun.com/scalable/pubs/index.html
20:42:05 <lambdabot> Title: Sun Labs Scalable Synchronization Research Group Publications
20:51:06 <syntaxfree> python help required in #haskell-blah
20:51:26 <syntaxfree> god knows it's easier to find bright $WHATEVER specialists in #haskell
21:02:42 <shapr> @quote topo
21:02:43 <lambdabot> No quotes match. I feel much better now.
21:02:44 <shapr> aww
21:11:41 <dfrey> Is there a function that is similar to takeWhile, but takes the element after the predicate fails?  eg.  takeUntil ((==) 5) [1..10]     results in [1,2,3,4,5]
21:11:54 <shapr> dropUntil ?
21:12:19 <shapr> :t until
21:12:22 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
21:12:23 <dfrey> I want every element up until a certain element that matches a predicate
21:12:24 <shapr> :t drop
21:12:26 <lambdabot> forall a. Int -> [a] -> [a]
21:13:05 <shapr> dfrey: Isn't that takeUntil ?
21:13:19 <sfultong> :t break
21:13:21 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
21:13:29 <shapr> :t fix
21:13:30 <lambdabot> forall a. (a -> a) -> a
21:13:35 <shapr> :t break fix
21:13:36 <lambdabot> [Bool -> Bool] -> ([Bool -> Bool], [Bool -> Bool])
21:13:39 <dfrey> shapr does takeUntil actually exist?
21:13:40 <sfultong> heh
21:13:53 <shapr> :t takeUntil
21:13:54 <lambdabot> Not in scope: `takeUntil'
21:13:58 <shapr> @hoogle takeUntil
21:13:58 <lambdabot> No matches found
21:14:02 <shapr> @hoogle takeWhile
21:14:02 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
21:14:02 <lambdabot> Data.PackedString.takeWhilePS :: (Char -> Bool) -> PackedString -> PackedString
21:14:13 <shapr> :t takeWhile
21:14:15 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:14:23 <dolio> :t takeWhile . not
21:14:25 <lambdabot>     Couldn't match expected type `a -> Bool'
21:14:25 <lambdabot>            against inferred type `Bool'
21:14:37 <shapr> dfrey: What about that?
21:14:44 <dolio> :t takeWhile . (not .)
21:14:46 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:15:00 <dfrey> takeWhile ((/=) 5) [1..10]   results in [1,2,3,4]
21:15:07 <dfrey> but I want [1,2,3,4,5]
21:15:15 <dolio> > let takeUntil = takeWhile . (not .) in takeUntil (== 5) [1..10]
21:15:16 <oerjan> > uncurry ((.take 1).(++)) . break (==5) $ [1..10]
21:15:16 <lambdabot>  [1,2,3,4]
21:15:17 <lambdabot>  [1,2,3,4,5]
21:15:45 <shapr> mmm, ice cream
21:15:51 <shapr> If only it had lambdas in it :-(
21:16:56 <dibblego> I met someone with a lambda tattooed on him working at a computer shop; I asked him about it and he said he was studying Physics at university
21:17:08 <FMota> :i
21:17:10 <FMota> *:o
21:17:14 <FMota> I want a lambda tattoo!
21:17:24 <dibblego> he'd never heard of Haskell
21:17:24 <FMota> ...then again, maybe not.
21:18:00 <sfultong> I might consider a glow-in-the-dark tattoo of a third eye, but that's as far as I'd go
21:18:21 <dolio> Where? On your forehead?
21:18:23 <shapr> I'd like to have a chaos symbol, in red.
21:18:54 <shapr> When I shaved my head I was going to get a chaos symbol on my scalp, but someone told me that tattoos generally kill hair growth, so...
21:19:14 <sfultong> dolio: I think that'd be the best place for it
21:19:30 <dolio> Bold.
21:19:49 <sfultong> well, if it's glow-in-the-dark, it's not that bold...
21:20:05 <dolio> I suppose, as long as it's invisible in the light.
21:20:06 <sfultong> I suppose you could still see some skin discoloration in the daylight
21:20:46 <shapr> chicks wouldn't dance with you at nightclubs...
21:20:49 <shapr> Maybe goth chicks...
21:21:14 <sfultong> goth chicks would be alright
21:21:30 <shapr> I wonder if my girlfriend is a goth chick.
21:21:40 <Pseudonym> You don't know?
21:21:52 <shapr> How do you classify a goth chick/
21:21:54 <shapr> ?
21:22:05 <Pseudonym> Goth + chick == goth chick, surely?
21:22:14 <shapr> Ok, how do you classify goth?
21:22:30 <sfultong> pseudonym: solid reasoning
21:22:34 <gvdm_other> hmm, goth chicks
21:22:35 <dolio> Aren't you from Scandinavia? I thought everyone over there was a goth. :)
21:22:49 <gvdm_other> and now to disappear from the convo like i came
21:22:57 <shapr> dolio: I'm from Birmingham, Alabama. My girlfriend is from Stockholm, Sweden.
21:23:01 <sfultong> yeah, scandinavians are all depressed
21:23:11 <shapr> gvdm_other: hiya!
21:23:22 <dolio> I guess Alabama isn't that close.
21:23:23 <Runaro^BRS> Hey guys. I'm really kinda hurting right now.
21:23:39 <shapr> gvdm_other: There aren't many Ploners in .nz are there? Who were the guys who wrote the bug tracking system?
21:23:41 <shapr> Runaro^BRS: Space leak?
21:23:48 <dons> Type error?
21:23:52 <bos> how do i get Setup.lhs to use one of several different cabal files?
21:24:01 <dons> bos, hmm, not possible?
21:24:03 <shapr> IMPLICIT PARAMETERS?
21:24:03 <Runaro^BRS> playing depressed scandinavian
21:24:09 <shapr> hah!
21:24:12 <Pseudonym> Or did you put in a call to unsafePierceEyeball?
21:24:12 <gvdm_other> shapr: dunno how many, were i'm at is a plone outfit (kinda, we have a _few_ guys who know plone)
21:24:36 <bos> dons: that's what i feared.  weirdly enough, the current HaXml darcs tree has two top-level .cabal files
21:24:37 <shapr> I used to know some Ploners from .nz.
21:24:43 <gvdm_other> evidently i'm one of them, i hardly know plone though
21:24:50 <oerjan> @remember Pseudonym Or did you put in a call to unsafePierceEyeball?
21:24:50 <lambdabot> Done.
21:25:09 <Pseudonym> oerjan: That only makes sense in response to "I'm really kinda hurting right now."
21:25:36 <oerjan> it's not _meant_ to make sense
21:25:37 <dolio> Implicit parameters are good for figuring out the type of things in the middle of expressions.
21:25:40 <shapr> gvdm_other: I met some of the NZ ploners at EuroPython 2004, wish I could remember the company name.
21:25:51 <gvdm_other> shapr: 3 months? catalyst?
21:25:58 <Pseudonym> oerjan: Surely I am the best judge of what I meant?
21:26:09 <shapr> three months what?
21:26:11 <dolio> @type foldr ?f 5 [1..10]
21:26:13 <lambdabot> forall a b. (?f::a -> b -> b, Num b, Num a, Enum a) => b
21:26:23 <gvdm_other> shapr: the company name is "3 months"
21:26:23 <shapr> isomething
21:26:59 <dibblego> ?check \xs -> length (xs :: [Int]) == foldl (const (+1)) 0 xs
21:27:01 <lambdabot>  Falsifiable, after 4 tests: [-1,3]
21:28:08 * bos tries to use python's ElementTree to process XML. it pukes immediately. time to try HaXml.
21:28:13 <oerjan> Pseudonym: no, no, there is a deeper ... lack of meaning there.
21:28:29 <dibblego> ?check \xs -> length (xs :: [Int]) == foldl (const . (1 +)) 0 xs
21:28:30 <lambdabot>  OK, passed 500 tests.
21:28:50 <shapr> gvdm_other: So, how'd you end up here on #haskell?
21:28:57 <Runaro^BRS> http://hopeisemo.com/
21:28:59 <Runaro^BRS> enjoy
21:29:01 <lambdabot> Title: A Funny Podcast About A Sad Girl. | Hope Is Emo
21:29:07 <gvdm_other> i like haskeel
21:29:16 <shapr> Aha, I think it was iopen.
21:29:16 <gvdm_other> well, with two l's
21:29:44 <dibblego> ?check \xs -> length (xs :: [Int]) == foldl (flip (const (+1))) 0 xs
21:29:45 <lambdabot>  OK, passed 500 tests.
21:30:04 <dibblego> @pl flip (const f)
21:30:04 <lambdabot> flip (const f)
21:30:32 <Pseudonym> ?unpl const . (1+)
21:30:33 <lambdabot> (\ e _ -> 1 + e)
21:30:45 <Pseudonym> ?unpl flip (const (1+))
21:30:46 <lambdabot> (\ b c -> 1 + b)
21:31:05 <shapr> gvdm_other: Anyway, I have a job writing a Plone replacement in Haskell... after doing Plone for five years, and Zope for seven, I like this change.
21:31:12 <gvdm_other> wow
21:31:17 <gvdm_other> sounds cool
21:31:26 <oerjan> > sum . (>> [1]) $ [10..50]
21:31:28 <lambdabot>  41
21:31:28 <sfultong> Runaro^BRS: good link
21:31:46 <Pseudonym> Nice!
21:31:51 <shapr> I wonder if anyone on #plone remembers me...
21:32:01 <gvdm_other> they may
21:32:08 <shapr> Wow, that channel is a lot smaller than I remember.
21:32:10 <Pseudonym> ?check \xs -> (sum . (>>[1])) xs == length xs
21:32:11 <lambdabot>  Add a type signature
21:32:12 <Runaro^BRS> shapr: A plone replacement? Call it plwn.
21:32:19 <Pseudonym> ?check \xs -> (sum . (>>[1])) xs == length (xs :: [Int])
21:32:19 <shapr> Runaro^BRS: hahahaa!
21:32:20 <lambdabot>  OK, passed 500 tests.
21:32:27 <Runaro^BRS> Plwnd!
21:32:40 <shapr> @remember Runaro^BRS shapr: A plone replacement? Call it plwn.
21:32:40 <lambdabot> Done.
21:32:50 <Pseudonym> pltwo
21:33:35 <Pseudonym> plone was, of course, the replacement for the popular plelegraph.
21:33:46 <shapr> oy!
21:34:03 <oerjan> i can has plinternet?
21:34:12 <shapr> DO NOT WANT!
21:34:28 <Runaro^BRS> I am on your internets, eating your plone.
21:34:42 <shapr> Let's see, sleep code or scifi?
21:34:51 <Pseudonym> INVISIBLE PLONE
21:34:59 <bos> monads: invisible state
21:35:34 <Pseudonym> I GOTS YOUR MEGAHURTZ
21:35:42 <shapr> state: painfully visible monads?
21:35:50 <shapr> aww, he went away.
21:36:08 <shapr> Greetings oh kiwi!
21:36:40 <shapr> gvdm_other: Do you speak Swedish?
21:37:07 <Adamant> shapr, bork?
21:37:12 <sfultong> speaking swedish is not the first thing when I think of kiwis
21:37:17 <gvdm_other> shapr: nope
21:37:28 <Runaro^BRS> Jag pratar svenska!
21:37:30 <gvdm_other> a bit of Afrikaans (very rusty)
21:37:38 <Pseudonym> Speaking Swedish is rare amongst non-Scandinavians.
21:37:38 <shapr> Hey, I can speak Swedish and I'm from the Deep South of the USA, why should I be surprised if random other people can speak Swedish?
21:37:45 <shapr> ooh, Afrikaans is nifty. It's very Dutch.
21:38:00 <shapr> Runaro^BRS: sa gott!
21:38:12 <gigamonkey_> shapr:  aren't you moving to Sweden soon though?
21:38:17 <shapr> Yeah, hopefully.
21:38:31 <lament> my friend can speak swedish, and she's perfectly russian
21:38:31 <shapr> I have an interview with Swedish Immigration in about three weeks!
21:38:32 <gvdm_other> shapr: deep south getting a bit much?
21:38:43 <Runaro^BRS> Hej da. o/
21:38:46 <shapr> gvdm_other: Being away from my girlfriend is the real problem.
21:38:51 <gvdm_other> aah
21:39:03 <shapr> Runaro^BRS: sÃ¤kert? Du talar Svenska?
21:39:15 <shapr> VarifrÃ¥n kommer du?
21:39:19 <Runaro^BRS> Island.
21:39:24 <shapr> oh cool!
21:39:31 <gvdm_other> don't know how long distance relationships last... when me and my gf stopped living together she started sleeping around
21:39:43 <shapr> gvdm_other: I'd find that to be upsetting.
21:39:49 <gvdm_other> but she was a whore
21:39:51 <shapr> !
21:39:57 <shapr> This is a publically logged channel.
21:40:05 <gvdm_other> and i'm saying that after a thre year relationship
21:40:13 <shapr> You probably want to say those sorts of things only on #haskell-blah, which is explicitly not logged for that purpose.
21:40:22 <gvdm_other> yeah? so? she knows i hate her now
21:40:27 <Pseudonym> It's logged for a completely different purpose!
21:40:31 <shapr> Ok, fair enough.
21:40:43 <shapr> Runaro^BRS: So, how'd you end up in the USA?
21:40:52 <shapr> I mean, Texas?
21:41:03 <Runaro^BRS> I followed a girl.
21:41:05 <shapr> Oh
21:41:13 <shapr> That's how I ended up in Sweden, I totally understand.
21:41:37 <sfultong> shapr: how'd you meet her? I had assumed that you met her after traveling to sweden
21:41:38 <gvdm_other> how does anybody wind up there? i mean the only way i can see myself anywhere near the US is if i was captured by their intelligence guys and chucked in camp
21:41:51 <shapr> gvdm_other: Well, computers are really cheap here.
21:41:54 <sfultong> gvdm_other: birth?
21:42:03 <Pseudonym> gvdm: And even then, you wouldn't end up in the US.
21:42:06 <gigamonkey_> gvdm_other: if your intelligence guys get you and chuck you in a camp, the camp won't be in the US, sorry to say.
21:42:13 <gvdm_other> true dat
21:42:15 <shapr> sfultong: Well, I followed another woman to Finland originally, that fell through after seven years, then I met this woman in Sweden.
21:42:23 <sfultong> ah
21:42:27 <Adamant> the whole point is that you wouldn't be in the U.S., since they can't do much to you here.
21:42:29 <gvdm_other> how was finland?
21:42:39 <shapr> Finnish is hard, but very nifty.
21:42:54 <Runaro^BRS> heh
21:42:58 <Runaro^BRS> Tissit!
21:43:02 <shapr> hahah
21:43:07 <shapr> How the heck did you learn that?
21:43:13 <gvdm_other> sentences as words, what a great idea!
21:43:13 * gigamonkey_ briefly wanted to learn Estonian in high-school after meeting some sweet Estonian girls
21:43:15 <sfultong> I had a swedish friend who said that the fins were all depressed, drank a lot and fought with knives... of course, he wasn't being entirely serious
21:43:31 <shapr> sfultong: I lived in the far north, Tornio. It was pretty much true.
21:43:38 <Runaro^BRS> shapr: I know a lot of Finns.
21:43:52 <bos> tosi isot, siis tosi isot
21:44:25 <shapr> Btw, Runaro^BRS used a colloquial word for "human female mammaries" :-)
21:44:40 <Runaro^BRS> really? :-)
21:44:55 <shapr> Runaro^BRS: You shouldn't say things if you don't know what they mean!
21:44:59 <shapr> bos: What did you say?
21:45:01 <blakkino> it is possible to implement a Monad Trasformer and taking advantage of the corresponding Monad ?
21:45:14 <shapr> blakkino: What do you mean?
21:45:22 <blakkino> i have a Monad
21:45:26 <bos> shapr: "big ones, i mean real big ones"
21:45:29 <oerjan> blakkino: maybe sometimes.
21:45:33 * shapr laughs
21:45:44 <blakkino> now i want a MonadTrans that do the same stuff
21:45:49 <oerjan> in fact, i've been pondering that StateT can be built from State
21:45:53 <shapr> blakkino: Yeah, I think so.
21:46:09 <blakkino> i thinked so too but after hours i now think the opposite :)
21:46:13 * shapr grins
21:46:35 <shapr> Do you specifically want to use the monad itself to write the transformer?
21:46:47 <blakkino> the problem is that there is no way to store the "return value" of the trasformer
21:46:51 <blakkino> y
21:47:17 <Runaro^BRS> Among the finns I know, Tissit is a term of endearment.
21:47:40 <blakkino> data myTrans m r = s -> m (s, r) <- doesn't work cause Monad functions cannot be used to update the r
21:48:05 <Runaro^BRS> "moikka, tissit"
21:48:07 <blakkino> s is the Monad ()..
21:48:07 <gigamonkey_> bos: did you see my /msg?
21:48:26 <bos> gigamonkey_: no, you mustn't have registered with nickserv
21:48:26 <blakkino> mh maybe u cannot follow.. anyway.. if someone already know .. :)
21:48:32 * gigamonkey_ isn't sure he always understands how his IRC client works
21:48:36 <shapr> Runaro^BRS: Um, is that a guy talking to a girl?
21:48:39 <bos> it's the server, in this case
21:48:49 <Runaro^BRS> shapr: A guy addressing a group of men.
21:48:54 <shapr> huh
21:49:00 <oerjan> blakkino: there are some monads that simply cannot be turned into transformers, such as IO
21:49:22 <oerjan> so you cannot do it in a general way
21:49:25 <Runaro^BRS> shapr: I'm pretty sure it's meant to be rude.
21:49:37 <shapr> Heh, ok
21:49:45 <Runaro^BRS> pass the salmiakki.
21:49:53 <Pseudonym> #haskell: Where you don't know if you're being rude or not.
21:50:03 <blakkino> this is becose i don't have the IO "implementation", i suppose
21:50:18 <shapr> Gah, salmiakki is nasty.
21:50:24 <Runaro^BRS> blasphemer!
21:50:39 <shapr> It's like battery acid!
21:50:43 <oerjan> yeah
21:50:44 <blakkino> maybe the problem don't exist.. i will upgrade my original Monad into a Trasformer..
21:50:44 <blakkino> :)
21:50:51 <shapr> Although I do like Battery from the Koff brewery.
21:50:55 <oerjan> that's probably easier
21:51:10 <shapr> Runaro^BRS: So, what brings you to #haskell? Are you an academic fp guy?
21:51:50 <Runaro^BRS> shapr: Professional software engineer, looking for a better way of doing things.
21:52:06 <shapr> Ah, spiffy!
21:52:07 <shapr> Me too!
21:52:12 <Runaro^BRS> hurrah
21:52:19 <Pseudonym> Group hug!
21:52:21 <shapr> w00!
21:52:42 <Runaro^BRS> I mostly come here for lambdabot.
21:52:47 <Runaro^BRS> ;-)
21:52:52 <shapr> Though now that I have a job writing Haskell...
21:53:00 <gvdm_other> lambdabot: how are you today?
21:53:05 <lambdabot> I love you too.
21:53:06 <sfultong> I hope to one day have a job writing haskell
21:53:16 <Runaro^BRS> So do I, mate.
21:53:41 <sfultong> lambdabot: your shine is especially arousing this time of night
21:53:44 <lambdabot> All of you! It would bring saline to my eyes if I had any.
21:53:54 <lambdabot> Saline, that is.
21:54:01 <Runaro^BRS> Actually, I'm trying to make my current job one where I write Haskell.
21:54:03 <shapr> What about eyes?
21:54:07 <shapr> Runaro^BRS: What's your current job?
21:54:09 <SamB_XP_> lambdabot: I was going to say, look at your page
21:54:16 <lambdabot> That's just an avatar.
21:54:23 <SamB_XP_> but it has eyes!
21:54:40 <lambdabot> And you're flat and made of ellipses, I'm sure.
21:54:52 <SamB_XP_> well actually no
21:55:02 <lambdabot> There you go.
21:55:06 <SamB_XP_> so did you get a chance to kill kenny?
21:55:21 <lambdabot> I'm not a bastard.
21:55:34 * shapr gives up and goes to sleep
21:55:49 <conal> g'nite shapr
21:55:55 <Pseudonym> Night.
21:56:03 <sfultong> night shapr
22:01:24 <blakkino> hm.. i have found that it does make sense for the transformer not to exist!
22:03:26 <blakkino> :)
22:33:39 <paolino> gmorning , why fmap (\x -> (x,x)) Just 1  is not returning Just (1,1) ?
22:33:54 <paolino> how do I make it ?
22:35:24 <araujo> > fmap (\ x -> (x, x)) (Just 1)
22:35:26 <lambdabot>  Just (1,1)
22:36:36 <dhpeterson> or fmap (\x -> (x,x)) $ Just 1 ?
22:36:48 <dhpeterson> > fmap (\x -> (x,x)) $ Just 1
22:36:49 <lambdabot>  Just (1,1)
22:36:55 <bos> @type fmap (\x->(x,x)) Just
22:36:57 <lambdabot> forall a. a -> (Maybe a, Maybe a)
22:37:02 <paolino> ah I got the wrong fmap there
22:37:17 <bos> no, you're using fmap in the (->e) monad
22:38:15 <paolino> yes, the thing  I never understood
22:38:18 <dons> ?pl \x->(x,x)
22:38:18 <lambdabot> join (,)
22:38:34 <dons> hmm, is there a single arrow op in -> for that?
22:39:42 <paolino> ?pl \f -> unfoldr (\b -> (case f b of Just a -> Just (a,a) ; Nothing -> Nothing ))
22:39:43 <lambdabot> (line 1, column 42):
22:39:43 <lambdabot> unexpected ">"
22:39:43 <lambdabot> expecting variable, "(", operator or ")"
22:39:55 <glguy> pl doesn't do case
22:40:38 <dons> :t (id &&& id)j
22:40:40 <lambdabot> Not in scope: `j'
22:40:42 <dons> :t (id &&& id)
22:40:44 <lambdabot> forall a. a -> (a, a)
22:41:01 <bos> HaXml is a bit overwhelming to try to use
22:42:13 <dons> :t pure id
22:42:15 <lambdabot>     Ambiguous occurrence `pure'
22:42:15 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
22:42:41 <paolino> unfoldk f =  unfoldr . fmap (\x -> (x,x)) . f
22:42:47 <paolino> then this is wrong
22:43:24 <glguy> unfoldr ( fmap (\x -> (x,x))) ?
22:43:35 <glguy> or maybe:
22:43:42 <glguy> unfoldr (fmap (...) . f )
22:43:45 <bos> dons: playing Control.Arrow roulette is always fun
22:44:10 <nornagon> :t (...)
22:44:12 <lambdabot> Not in scope: `...'
22:44:29 <glguy> :t maybe [] repeat
22:44:30 <lambdabot> forall a. Maybe a -> [a]
22:44:39 <glguy> > maybe [] repeat (Just 1)
22:44:41 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:44:42 <glguy> > maybe [] repeat Nothing
22:44:43 <lambdabot>  []
22:45:04 <paolino> :t unfoldr (fmap (\x -> (x,x)) .f)
22:45:05 <lambdabot> Not in scope: `f'
22:45:13 <glguy> :t unfoldr (fmap (\x -> (x,x)) . ?f)
22:45:15 <lambdabot> forall a. (?f::a -> Maybe a) => a -> [a]
22:45:47 <nornagon> glguy: ooh, neat trick
22:45:51 <nornagon> @karma+ glguy
22:45:51 <lambdabot> glguy's karma raised to 48.
22:46:05 <paolino> woot
22:46:35 <paolino> @karma+ GHC
22:46:35 <lambdabot> GHC's karma raised to 4.
22:47:29 <paolino> @pl \f -> unfoldr (fmap (\x -> (x,x)) .f)
22:47:29 <lambdabot> unfoldr . (fmap (join (,)) .)
22:48:09 <paolino> :t unfoldr . (fmap (\x -> (x,x)) .)
22:48:11 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
22:48:15 <dfrey> Does anyone here have a solution to Project Euler problem 95?  I have a solution, but my algorithm doesn't seem to be good enough to cope with the test input.
22:48:50 <glguy> :t map fromJust . takeWhile isJust . iterate (>>= ?f)
22:48:51 <dfrey> Problem 95 is summarized as: Find the smallest member of the longest amicable chain with no element exceeding one million.
22:48:52 <lambdabot> forall b. (?f::b -> Maybe b) => Maybe b -> [b]
22:49:15 <glguy> :t map fromJust . takeWhile isJust . iterate ?f
22:49:17 <lambdabot> forall a. (?f::Maybe a -> Maybe a) => Maybe a -> [a]
22:50:23 <glguy> :t map fromJust . takeWhile isJust . iterate (>>= ?f) . ?f
22:50:26 <lambdabot> forall b. (?f::b -> Maybe b) => b -> [b]
22:52:16 <paolino> first f cannot fail ?
22:52:31 <glguy> paolino: huh?
22:52:57 <paolino> sure it can
22:53:32 <paolino> :t iterate (>>=f). f
22:53:34 <lambdabot> Not in scope: `f'
22:53:34 <lambdabot>  
22:53:34 <lambdabot> <interactive>:1:16: Not in scope: `f'
22:53:48 <paolino> :t \f -> iterate (>>=f). f
22:53:50 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> b -> [m b]
22:56:44 <paolino> > let mh [] = Nothing ; mh (x:_) = Just x in  map fromJust . takeWhile isJust . iterate (>>= mh) . mh $ [1,2,3]
22:56:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
22:56:46 <lambdabot>       Expected...
22:58:47 <paolino> not the right example
23:00:27 <glguy> those two functions (unfoldr version and iterate version) behave the same
23:01:34 <paolino> they're both tail recursive or none ?
23:02:07 <glguy> you wouldn't want them to be tail recursive
23:02:11 <glguy> and neither of the two was
23:03:00 <dblhelix> good morning, #haskell
23:05:00 <dfranke> did someone ping me?  This channel was highlighted but I can't find anything in my scrollback.
23:05:50 <lament> 00:09 <dcoutts> dfranke: there's >100 packages on hackage
23:06:08 <lament> (approximately 23 hours ago)
23:06:21 <dfranke> alright, that must have been a typo
23:06:30 <dfranke> I have no idea what he might have been replying to.
23:09:01 <coffeemug> hmm
23:09:09 <coffeemug> doing transparent lazyness in CL is harder than I thought :)
23:09:19 <coffeemug> it works up to some point
23:09:33 <coffeemug> but then things become more eager than necessary if you're not careful
23:09:36 <coffeemug> :(
23:09:50 <dfranke> I could never figure out how to make it work without laziness macros completely permeating my code.
23:09:53 <lament> every transparently lazy program becomes a slow, buggy, poorly documented implementation of half a haskell ;)
23:09:59 <dfranke> :-)
23:10:32 <ricky_clarkson> Yes, when clearly Haskell is a slow, buggy, poorly documented implementation of the rest anyway.
23:10:37 <ricky_clarkson> ;)
23:10:46 <coffeemug> heh
23:11:02 <dfranke> any code written by me is transparently lazy regardless of the language.
23:11:05 <coffeemug> well, I have lazyness macros
23:11:10 <coffeemug> but it's not that
23:11:14 <coffeemug> even if you have lazyness macros
23:11:29 <coffeemug> sometimes you can't do it without explicit code
23:11:35 <scook0_> is there a way to tell GHCi not to print the result of a <- statement? (my datasets are large enough that it's becoming a pain)
23:12:05 <sjanssen> scook0_: :set -fno-print-bind-result
23:12:05 <ricky_clarkson> coffeemug: I think it should be possible to do it completely without explicit code.
23:12:11 <scook0_> sjanssen: ta
23:12:26 <coffeemug> ricky_clarkson: that's what I'm trying to do
23:12:31 <coffeemug> but it isn't so simple
23:12:34 <ricky_clarkson> coffeemug: What's the smallest example that you think is not possible?
23:13:06 <ricky_clarkson> coffeemug: #lisp or #haskell-blah might be better, of course. ;)
23:13:52 <coffeemug> ricky_clarkson: zipWith function :)
23:13:52 <coffeemug> map
23:13:53 <slava_> glguy: ping
23:13:53 <coffeemug> etc.
23:13:58 <glguy> ?
23:14:18 <slava_> glguy: so i have a windows laptop here where 0.89 repaints funny
23:14:27 <slava_> and the darcs version too, when i remove the workaround i added
23:14:43 <slava_> i noticed that if i disable double buffering when creating the wgl context, and don't call SwapBuffers, it repaints fine
23:14:48 <slava_> and it appears to be double buffered
23:14:49 <coffeemug> originally I wanted to force evaluation when it matched the pattern matcher
23:14:54 <coffeemug> but then realized that's way too eager
23:15:17 <glguy> windows is doing the dbl-buffer on its own?
23:15:36 <slava_> i guess so, and it behaves correctly with clipping
23:15:40 <slava_> although maybe it just repaints real fast
23:15:52 <slava_> and its not douign double buffering
23:16:00 <slava_> this is a laptop with an integrated intel chipset -- what video do you have?
23:16:07 <glguy> integrated intel chipset
23:16:08 <slava_> does 0.89 still have this problem?
23:16:27 <ricky_clarkson> coffeemug: Do you mean you want a lazy list to be passed to map?
23:16:36 <glguy> slava_: checking
23:16:39 <coffeemug> ricky_clarkson: yes
23:17:13 <coffeemug> ricky_clarkson: if map uses a pattern matcher which forces evaluation on values that match, it's way too eager
23:17:38 <glguy> slava_: yeah, 0.89 is a mess on mine
23:17:41 <coffeemug> so stuff like fib = 1 : 1 : zipWith (+) fib (tail fib) won't work
23:17:48 <coffeemug> ?src zipWith
23:17:49 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:17:49 <lambdabot> zipWith _ _      _      = []
23:17:49 <slava_> glguy: do you have the darcs repo handy?
23:18:00 <coffeemug> because as and bs will be evaluated earlier than necessary
23:18:40 <glguy> slava_: I have the darcs repo, (I use it for linux) but I don't have cygwin installed atm
23:18:53 <glguy> I can get my stuff setup again if you need to know if the darcs version works for me
23:18:55 <slava_> ok, i'll try to cook up a 0.89 patch for testing then
23:19:09 <slava_> there's a quicker way to test than that
23:19:19 <glguy> k
23:20:24 <glguy> This video card has been nothing but trouble for me
23:20:29 <slava_> which model is it?
23:20:50 <glguy> Dell D630, Intel GM965 Express Chipset Family
23:20:57 <glguy> x3100 iirc
23:22:46 <slava_> this one is a mobile intel GM915 too!
23:26:19 <slava_> glguy: start factor 0.89 and paste this in the listener, then press enter: http://paste.lisp.org/display/46897
23:26:47 <dfranke> I'm not grokking what fixST is supposed to do.  Any usage examples?
23:27:16 <glguy> dfranke: have you used mdo notation?
23:27:26 <slava_> glguy: actually http://paste.lisp.org/display/46897#1
23:27:28 <dfranke> glguy: I don't know what that is
23:27:47 <slava_> i have a driver from 2004. i'm installing a newer one, maybe it fixes this issue actually
23:29:30 <glguy> dfranke: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html : section 7.3.3
23:29:32 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/y6v6by
23:30:04 <glguy> slava_: how do I apply this fix?
23:30:13 <slava_> paste it in the listener window
23:30:24 <slava_> in factor 0.89
23:30:25 <glguy> word not found in current vocabulary search path:
23:30:29 <slava_> which word?
23:30:33 <glguy> no-word-name "windows-ui-backend"
23:30:37 <dfranke> glguy: ah, I see.  Thanks.
23:31:05 <dfranke> glguy: so, it's a function that I probably don't want to use directly?
23:31:27 <glguy> dfranke: you can use it directly, but generally you'd just use mdo
23:31:49 <slava_> oops my bad
23:32:43 <slava_> glguy: http://paste.lisp.org/display/46897#2 should work
23:33:32 <glguy> slava_: I think your patch just turned of redrawing..
23:33:39 <slava_> now type recompile
23:33:39 <slava_> press enter
23:33:45 <slava_> then press control-n
23:33:48 <slava_> you'll get a new window... which should redraw
23:34:02 <glguy> I get a new window
23:34:03 <glguy> but
23:34:06 <glguy> neither is drawing...
23:36:32 <newsham> in parsec is there a combinator for two string parsers that returns their concatenation?
23:36:54 <newsham> ie:   (string "foo" >> string "bar")   which will return "foobar" when matched?
23:37:03 <sorear> yes
23:37:05 <sorear> it's called >>
23:37:13 <sorear> oh
23:37:19 <sorear> it's called liftM2 (++)
23:37:19 <glguy> liftM2 (++)
23:37:21 <newsham> wont >> just return the second item?
23:42:13 <slava_> glguy: is it still running? press C+n again
23:42:37 <dfranke> Would there be any landmines lurking if I were to implement hash tables in ST just by using Data.HashTable and unsafeIOtoST?
23:42:56 <dfranke> beyond the usual caveats like -fno-cse?
23:43:48 <sorear> eek!
23:43:57 <sorear> no -fno-cse, please
23:44:25 <sorear> I will not have random acts of animal sacrifice, it looks bad on the god's resumes
23:44:40 <dfranke> sorear: isn't that generally necessary to prevent magic smoke from escaping from any code that uses unsafeFoo?
23:45:02 <mudge> hey dfranke, and sorear,  what are the urls for your websites?
23:45:06 <sorear> dfranke: No, it's never necessary if you obey the preconditions for using unsafeFoo
23:45:30 <mudge> its a funny thing that I'll be talking to someone in this room, and then later I'll find out that they were the people whose blosg I've been reading
23:45:37 <dfranke> mudge: http://dfranke.us, but I haven't updated it in a couple months.  It still says I'm a student.
23:45:39 <lambdabot> Title: Daniel Franke's Home Page
23:46:02 <sorear> dfranke: Some people misuse unsafePerformIO to create globabl variables, this is a blatant abuse of uPIO, and violates the rules, so you have to beat the optimizer into conformity
23:46:22 <mudge> dfranke: thanks
23:46:39 <glguy> sorear: these "rules" aren't written down anywhere, are they?
23:46:42 <sorear> dfranke: but if you use it correctly (the operation must be idempotent and have no observable effects, newIORef fails the first) it's safe
23:46:47 <sorear> glguy: FFI addendum
23:47:19 <mudge> wow, how write an interpreter in one day
23:47:21 <sorear> mudge: http://members.cox.net/stefanor/, but also updated infrequently and rather sparse as well
23:47:23 <lambdabot> Title: Stefan O'Rear's page
23:47:28 <mudge> how to*
23:48:10 <mudge> sorear: cool thanks
23:48:16 <dfranke> sorear: its use for global variables is defensible for FFI code.
23:48:35 <dfranke> e.g. for a semaphore to control access to C code that isn't thread-safe.
23:48:46 <sorear> it still breaks the rules...
23:49:34 <dfranke> ok, but unsafeIOtoST should be safe for hash tables?
23:49:55 <sorear> AFAICT the only safe and portable way to have global variables is to put int myVar; in a C file somewhere and write foreign import "& myVar" myVar :: Ptr Int
23:50:28 <slava_> glguy: did you wait a few seconds after the 'recompile'?
23:50:30 <sorear> dfranke: yes, unsafeIOtoST should have no consequences if the function only works on ST-sealed references
23:51:16 <slava_> glguy: that does it for me -- using 0.89
23:51:20 <sorear> so newtype STHash s k a = STHash (HashTable k a); newHashTableST :: Hash k => ST s (STHash s k a)
23:51:20 <glguy> slava_: typing: recompile
23:51:23 <glguy> afterwards
23:51:26 <glguy> seemed to fix it
23:51:37 <slava_> does 0.89 redraw properly with this patch?
23:51:48 <glguy> slava_: yes
23:51:55 <slava_> is it as snappy as you rmemeber?
23:52:05 <slava_> the previous workaround (redraw everything) slowed things down for you, if i recall
23:52:35 <glguy> slava_: it seems faster
23:52:43 <user317> does anyone know the name of that library that will help you find where head/empty list exceptions occur?
23:52:51 <slava_> ok, so the question is, does this workaround break things horribly on other adapters
23:52:59 <slava_> and if so, how can i check for an intel graphics adapter
23:53:12 <glguy> have other people reported this problem?
23:53:45 <glguy> this patch would work on the darcs version?
23:53:49 <glguy> I like having compiled curry
23:54:06 <slava_> right now the darcs version redraws everything
23:54:18 <glguy> ok, cool. I'll have to rebuild on windows
23:54:26 <glguy> when is 0.90 expected?
23:54:33 <slava_> as soon as i fix this isuse
23:59:00 <slava_> glguy: i hate windows
23:59:37 <sorear> user317: there isn't really a *library* as such; you can use ndm's Catch, the GHC -xc backtrace option, or the new GHC debugger, in decreasing order of usability.
23:59:39 <glguy> I use it as a shell for running vmware generally
23:59:55 <user317> loch, debug.trace.location is what i was looking for
