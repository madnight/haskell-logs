00:00:37 <wli> Trouble is that unifies two type variables in there.
00:05:12 <lament> @type liftM
00:05:13 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:05:17 <wli> There's probably some TH trick to deal with coproducts like this in general.
00:05:24 <wli> @type liftM2
00:05:26 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:05:36 <lament> this makes me cry.
00:07:13 <sorear> why?
00:07:30 <lament> i suppose it's just the forall part that makes me cry
00:07:46 <Cale> It's always there implicitly
00:08:26 <sorear> Cale: How many things are Mzero but not Mplus?
00:08:39 <Cale> That says: for all types a1, a2, r, and type constructors m, if m is a monad, then the type is (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:08:51 <wli> It's definitely not (f ||| h) . (g ||| g)
00:08:59 <lament> oh, (m :: * -> *) means a type constructor?
00:09:05 <Cale> sorear: Depends on what counts as plus
00:09:12 <Cale> lament: yeah
00:09:19 <Cale> * -> * is a kind annotation
00:09:26 <Cale> means it takes types to other types
00:09:27 <sorear> Cale: An associative binary operator with unit mzero. :)
00:09:42 <lament> oh
00:10:07 <lament> but of course none of that forall stuff is necessary since we know m is a monad
00:10:18 <Cale> Okay, that's rather weak then, I wouldn't expect there to be too many of those.
00:10:19 <sorear> lament: right, it can be inferred
00:10:36 <reffie> is there a function that takes two arguments and flips them? a b becomes b a
00:10:47 <lament> @type show
00:10:49 <lambdabot> forall a. (Show a) => a -> String
00:10:49 <Cale> (if you can detect the zero in any way, you could just do something like Maybe does)
00:10:51 <sorear> reffie: No, functions always return one value.
00:10:57 <lament> @type []
00:10:59 <lambdabot> forall a. [a]
00:11:06 <reffie> flip does what i want, i think
00:11:07 <Cale> But if you want stronger guarantees about what mplus does, there are lots.
00:11:08 <lament> i see. lambdabot just likes being really explicit
00:11:11 <reffie> lol
00:11:49 <Olathe> @src flip
00:11:49 <lambdabot> flip f x y = f y x
00:11:53 <sorear> lament: but in the more general (and beyond H98) cases, you need to be explicit about exactly where the forall's are
00:12:01 <sorear> @type Control.Monad.ST.runST
00:12:03 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
00:12:31 <sorear> lament: you don't need to worry about that very often, however
00:13:25 <lament> why do foralls matter in that example?
00:15:12 <sorear> lament: runST absolutely requires that its argument be polymorphic.  you can't pass it a value of type ST Int Int, because ST Int Int can't be used where a polymorphic ST a Int is expected, it's not polymorphic enough.  but it would be impossible to enforce this without putting the forall inside the argument slot.
00:18:19 * lament thinks
00:21:18 <reffie> is [(x,y)| x<-[0..5], y<-[0..10]] always guaranteed to come in the same order?
00:22:03 <mauke> yes
00:22:09 <lament> it better.
00:22:54 <reffie> it goes through them right to left?
00:22:58 <dynamix> reffie:  yes
00:23:02 <reffie> thanks
00:23:06 <mauke> > concatMap (\x -> concatMap (\y -> return (x,y)) [0 .. 10]) [0 .. 5]
00:23:14 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(1,0),(1...
00:24:43 <reffie> ?src concatMap
00:24:43 <lambdabot> concatMap f = foldr ((++) . f) []
00:24:54 <reffie> ?src concat
00:24:54 <lambdabot> concat = foldr (++) []
00:24:57 <reffie> k
00:24:58 <mauke> lambdabot: you must be kidding
00:25:08 <mauke> concatMap f xs = concat (map f xs)
00:25:17 <reffie> mauke yea, that's what i was thinking
00:25:21 <reffie> but i guess it's the same thing
00:33:20 <wli> sorear: heh, you're thinking monad comprehensions
00:33:54 <wli> ([x | Left x <- xs], [x | Right x <- xs]) as a monad comprehension.
00:35:20 <wli> What should I call this thing anyway? I came up with "classify", but there's also "segregate" and so on as plausible alternatives.
00:45:06 <dons> dibblego: `Shaggin C Sharpy' eh? :)
00:45:19 <dibblego> dons, :)
00:46:06 <dons> good article. its nice to use feedback about what `outsiders' get confused about, to drive introductory material like that.
00:46:49 <dibblego> yeah, watching that video, I got a bit of pain watching the audience struggle with those questions
00:47:03 <dibblego> so I thought I'd try a different way of answering
00:47:50 <dons> yeah. i think that's a good idea
00:48:04 <wli> dons: Is the Real World Haskell book the book you're working on?
00:48:08 <dons> yep
00:49:32 <wli> I saw the TOC... I was hoping for more MPTC, GADT, TH, et al sorts of things, but I guess it's more oriented toward real-world applications than language features per se.
00:49:52 <wli> It's of course a shoo-in for me to buy on zero day or whatever.
00:50:26 <dons> cool. yeah, we're aiming for building systems -- the advanced type hackery comes in at the end
00:53:06 <wli> Foldable.foldr ((first . mappend . return) ||| (second . mappend . return)) (mempty, mempty) seems related to the partial completion problem for composite requests.
00:53:36 <wli> Some pieces return successes, others return errors, that collects the errors and successes in different tuple components.
01:02:16 <Cale> Mmmm... everywhere surjective functions :)
01:05:50 <dynamix> Cale: hi
01:05:56 <Cale> hello
01:06:11 <dynamix> do you have a few minutes?
01:06:14 <Cale> sure
01:40:18 <reffie> i wish there was a !#$ debugger
01:40:50 <reffie> since it's not trivial to add prints to code
01:41:32 <wli> Seems easy enough to me with liftIO
01:41:49 <reffie> means i have to change all the function types, no?
01:42:17 <wli> Sure, but usually they're polymorphic enough anyway.
01:42:33 <reffie> not really, no
01:46:36 <reffie> how do i make a simple data type like "data Blah = Blah Int Int" derive show?
01:47:13 <RyanT5001> would it be possible to build a STG machine without any formalized notion of globals? a compiled program could just be a heap image
01:48:24 <RyanT5001> what's oleg's last name?
01:48:41 <dons> kiselyov
01:48:50 <dons> but his name may not be spoken
01:49:01 <RyanT5001> dons: lol why's that?
01:49:16 <RyanT5001> (i just wanted to know whether the paper i was reading was by him)
01:49:18 <RyanT5001> (it was)
01:49:24 <dons> just joking :)
01:49:32 <RyanT5001> :P
01:49:33 <dons> ?quote oleg
01:49:33 <lambdabot> emu says: olegarithmic
01:49:36 <dons> ?quote oleg
01:49:36 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
01:49:36 <lambdabot>  what you just said?"
02:00:22 <dons> shapr: you'd like this, http://yadogg.com/ups/unipsycho.jpg
02:02:53 <RyanT5001> dons: it's good he has shin guards
02:03:01 <RyanT5001> otherwise he might fall and hurt himself
02:03:07 <dons> yeah, safety first!
02:03:08 <ddarius> Safety first.
02:03:14 <dons> :)
02:03:18 <RyanT5001> :)
02:03:30 <goalieca> terrans! http://www.gamespot.com/video/939643/6176216/starcraft-ii-official-movie-4
02:03:32 <lambdabot> Title: GameSpot Video: Starcraft II Official Movie 4, http://tinyurl.com/2wv92q
02:03:47 <goalieca> oops wrong one
02:03:48 <goalieca> sorry
02:03:51 <goalieca> wrong channel
02:04:07 <nornagon> oh
02:04:11 <nornagon> i was all excited
02:04:23 <RyanT5001> goalieca: nevertheless, good stuff :P however, i wish they hadn't made everything look so much more anime-ish than SC1
02:04:23 <nornagon> i thought there might be a zerg rush combinator to go with them
02:04:41 <RyanT5001> repeat Zergling
02:05:04 <RyanT5001> or maybe: repeat (Zergling, Zergling)
02:05:10 <RyanT5001> ;)
02:05:13 <nornagon> mapM_ devour terrans
02:05:19 <RyanT5001> lol
02:05:20 <goalieca> yeh it looks too shiny. the toss especially
02:05:30 <goalieca> sometimes i wish i could cut that pixel shader crap down
02:05:44 <nornagon> mm, i should learn pixel shaders :)
02:08:39 <reffie> YAY
02:08:41 <reffie> http://kaede.iichan.net/cg/src/1186218778904.png
02:08:49 <RyanT5001> i want to know why bank-to-bank transfers take "3-4 days"
02:08:50 <reffie> 130 lines of haskell!
02:08:58 <RyanT5001> as opposed to 3-4 seconds
02:09:25 <augustss> RyanT5001: because banks want to make money
02:09:33 <matthew-_> nornagon: shaders are lovely, on GPUs that support them...
02:09:40 <wli> I wish I could write things so briefly.
02:09:41 <RyanT5001> augustss: so the sending bank just hangs onto it for the interest for 3 days?
02:09:58 <nornagon> reffie: heh
02:10:01 <RyanT5001> augustss: seems like they could do better by charging you for a quicker transfer
02:10:04 <nornagon> cool :)
02:10:04 <augustss> RyanT5001: yes, or maybe the recieving bank
02:10:15 <nornagon> my current hopengl project is 3d terrain generation
02:10:23 <nornagon> but i'm stuck on the data structures :(
02:10:37 <matthew-_> nornagon: right, I'm actually doing reasonably similar stuff with rendering globe data
02:10:38 <augustss> RyanT5001: some banks offer faster transfer for a fee
02:10:55 <nornagon> matthew-_: Oh?
02:10:55 <wli> It must be possible to do ad hoc network chatservers in fewer lines than this.
02:10:59 <matthew-_> nornagon: you can get a heightmap of the earth at 2 minute intervals which I'v rendering
02:11:07 <nornagon> ah, neat
02:11:19 <matthew-_> nornagon: of course, that's a huge amount of data, so subsampling and doing selective rendering
02:11:24 <nornagon> well, i'm using the diamond-square subdivision algorithm
02:11:43 <nornagon> and i'm not really sure how to generate the map in a purely functional way
02:11:54 <matthew-_> divide the earth into 20 by 24 segments and then you only ever render less than 60% of the earth
02:12:03 <nornagon> but i'm not really very good at haskell :(
02:12:14 <matthew-_> nornagon: the opengl stuff is nice
02:12:16 <RyanT5000> nornagon: post what you've got so far on hpost
02:12:46 <reffie> nornagon this is a raytracer :(
02:12:50 <matthew-_> nornagon: I'm using the Vertex Buffer Object stuff in order to load large arrays of triangles actually onto the GPU ram, it goes quite fast!
02:12:52 <RyanT5000> matthew-_: i wish there was a version of the haskell opengl lib that was totally pure, for conversion to IO at the last minute
02:12:56 <nornagon> RyanT5000: it's barely anything
02:12:59 <nornagon> reffie: oh! awesome!
02:13:12 <nornagon> matthew-_: yah :)
02:13:19 <dons> RyanT5000: so it would construct a pure data structure, that could the be rendered?
02:13:24 <RyanT5000> dons: yeah
02:13:45 <matthew-_> RyanT5000: opengl is really stateful though
02:13:52 <nornagon> i dunno, opengl's just a huge state machine
02:13:54 <RyanT5000> matthew-_: that's my complaint :P
02:14:02 <matthew-_> right.
02:14:15 <nornagon> but maybe haskell could do some optimisation of the data structures pre-rendering? like, say, removing multiple texture binds
02:14:19 <RyanT5000> basically i want a lazy structure than can be somehow efficiently converted into IO
02:14:21 <nornagon> that's sort of... complicated, though
02:14:37 <dons> well, its also sort of MVC isn't it?
02:14:51 <RyanT5000> nornagon: yeah, but less complicated when you've got a big pure datastructure than when you've got an IO ()
02:14:53 <RyanT5000> dons: yeah
02:14:55 <matthew-_> nornagon: if you use display lists then the gpu driver will do loads of optimisations and recompilation dynamically
02:15:02 <nornagon> RyanT5000: right
02:15:04 <RyanT5000> dons: i particularly wanted this for game GUIs
02:15:13 <nornagon> matthew-_: oh, that's pretty neat.
02:15:28 <RyanT5000> what i *really* want is a TH library for generating game GUIs from haskell datatypes
02:15:34 <RyanT5000> which was my proposal for last year's google summer of code
02:15:41 <dons> fwiw, xmonad does this, purely functional model, a single `render` function that calls xlib to display things
02:15:47 <RyanT5000> but apparently whoever was choosing wanted something "hard" :P
02:15:48 <matthew-_> nornagon: making drivers for most GPUs employs more software engineers than actually making the GPU chip itself
02:16:04 <dons> so all the core logic is just traversing and manipluating a model of the X server
02:16:16 <dons> (which can then be tested with big hammers)
02:16:20 <matthew-_> nornagon: the drivers are extremely complex bits of work. E.g., you send a shader to it in source code - the driver does the compilation of the shader
02:16:47 <dons> interestig, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hgal-1.0.1
02:16:49 <lambdabot> http://tinyurl.com/3dwxou
02:16:55 <dons> `library for computation automorphism group and canonical labelling of a graph
02:18:58 <ddarius> hardware engineers would make the chips
02:19:04 <matthew-_> yes
02:19:20 <matthew-_> but, eg, NVidia employ more software engineers than hardware engineers
02:19:53 * ski wonders if there's anthropomorphisms ..
02:19:54 <wli> oh dear
02:20:03 <RyanT5000> lol
02:20:28 <dons> hehe
02:21:14 <ddarius> Today has been a good day.  It is time to sleep.
02:25:36 <dons> night ddarius
02:25:41 <reffie> interesting how ghc -static still gives dynamically linked binaries
02:25:56 <dons> reffie: you also need to tell the linker -optc-static -optl-static
02:26:16 <reffie> thanks
02:27:16 <dons> $ ghc A.hs -o A -static -optc-static -optl-static
02:27:22 <dons> $ ldd A
02:27:22 <dons> A:
02:27:23 <dons> ldd: A: not a dynamic executable 
02:27:51 <dons> otherwise it'll get linked, at a minimum, against libm, libgmp, libc and ld.so
02:36:32 <Royal_Son> Hi there. I'm trying to create a function using patterns (instead of guards) that searches a string for a character and then returns the position of the first occurance in the string of that character. Would someone be able to help? I'm a real newbie to this and it's hard to get my head around. I'll paste what I came up with in the paste bin in a moment...
02:37:36 <dons> there's a list library function for this already
02:37:45 <dons> are you interested in working out how to write it though?
02:37:53 <Royal_Son> yes
02:38:04 <dons> ok, paste the code on hpaste.org, and we can walk through it
02:38:29 <Royal_Son> But i want to mention that I don't want the straight answer because this is for an assignment, i would just like to know what concepts i'm tripping up on if that's alright
02:38:34 <dons> > elemIndex 'l' "haskell"
02:38:36 <lambdabot>  Just 5
02:38:38 <dons> like that?
02:38:50 <dons> right. that's fine. good to see :)
02:38:56 <Royal_Son> i'll paste in a minute...
02:42:11 <hpaste>  Royal_Son pasted "Trying to change a guards function to patterns function" at http://hpaste.org/2060
02:42:38 <Royal_Son> Please don't laugh, it probably looks like something a 5 year old wrote :/
02:42:49 <dons> no no. we're here to help! :)
02:43:30 <dons> ok, so you want to move the tests several pattern matches?
02:43:33 <Royal_Son> thank you. I'm so used to programming in imperative languages.
02:43:47 <dons> so the first thing to think about here is the base case.
02:43:57 <dons> when do you know that you've reached the end of the input string?
02:44:22 <dons>  adda2 c [] = error "not found"
02:44:24 <dons> for example.
02:44:39 <dons> matches the empty list/string. does that make sense?
02:44:47 <Royal_Son> yeah
02:44:54 <dons> x:[] _doesn't_ match the empty list, it matches a list of 1 element
02:44:59 <dons> > 1:[] -- see?
02:45:01 <lambdabot>  [1]
02:45:05 <Royal_Son> oh
02:45:07 <dons> > [] -- versus the empty list
02:45:08 <lambdabot>  []
02:45:43 <dons> so that gives you the base case for your recursive function, yes? when the string is [], then you've not found the element in the list
02:45:47 <Royal_Son> I actually had adda2 c (c:xs) = 0 in the past
02:46:06 <dons> ok, so that's the next point, assuming the list is not empty, then it has the form (x:xs)
02:46:08 <Royal_Son> but i getting the same message for any input string
02:46:10 <dons> and you need to check that c == x
02:46:30 <dons> now, you can't write c == x as a pattern, you have to do the equality test manually
02:46:31 <Royal_Son> yeah that's what got me because I tried to perform a comparison but it said unexpected ==
02:46:40 <dons> so adda2 c (c:xs) = 0 doesn't actually work
02:46:58 <dons> instead, you mean:        adda2 c (x:xs) | c == x = 0
02:47:18 <Royal_Son> I tried in the past to put adda2 c (x:xs)== adda2 x (c:xs) = foo
02:48:19 <dons> no, you'd write it as: adda2 c (x:xs) = if c == x then .... else ... , or you'd use a small guard, adda2 c (x:xs) | c == x = 0
02:49:13 <Royal_Son> yeah except i think the point of this exercise is to avoid using guards.  oh..... that's the key.. if then !!!
02:49:30 <Royal_Son> ok you have made my day, a light just switched on. I'm going to try it out...
02:50:06 <hpaste>  dons annotated "Trying to change a guards function to patterns function" with "first, test the input list" at http://hpaste.org/2060#a1
02:50:26 <dons> oh good :)
02:50:31 <Royal_Son> Thanks a lot dons... brb
02:50:34 <dons> > if 1 == 2 then Just "yes" else Nothing
02:50:36 <lambdabot>  Nothing
02:50:56 <dons> also, instead of throwing an error in the (common) not found case, it would be more Haskellish to return Nothing
02:51:07 <dons> or Just n , if you find the element at index `n'
02:51:20 <dons> this is what the list library function does
02:51:24 <dons> :t elemIndex
02:51:26 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
02:51:36 <dons> > elemIndex 'x' "haskell"
02:51:38 <lambdabot>  Nothing
02:51:42 <dons> > elemIndex 'h' "haskell"
02:51:44 <lambdabot>  Just 0
02:51:48 <RyanT5000> :t Data.List.find
02:51:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
02:51:59 <RyanT5000> er
02:52:05 <RyanT5000> :t Data.List.genericIndex
02:52:07 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
02:52:13 <RyanT5000> grrr
02:52:18 <dons> :t findIndex --?
02:52:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
02:52:29 <RyanT5000> :t genericFindIndex
02:52:31 <lambdabot> Not in scope: `genericFindIndex'
02:52:38 <RyanT5000> ok, this is why i use hoogle a lot
02:52:39 <RyanT5000> lol
02:52:50 <dons> that's interesting that there isn't a genericFindIndex.
02:54:09 <xerox> ?docs Data.List
02:54:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
02:55:44 <RyanT5000> hm... i assume the reason genericIndex didn't just replace index is because it would break things; but how could relaxing the type signature of something break things? makes type inference impossible sometimes? i guess it would break liftM (genericIndex l) read
02:57:13 <norpan> since it will default to Integer it will be slower too
02:57:21 <RyanT5000> is there a way Haskell could have been designed to make transitions like that smoother?
02:57:26 <RyanT5000> norpan: ew, defaulting
02:57:39 <dons> I think the idea is more to introduce a few efficient types, to help get better code, rather than having unexpected inefficiencies
02:57:58 <RyanT5000> dons: if someone wants it to be efficient, they can use an Int!
02:58:10 <RyanT5000> the generated code would be the same, wouldn't it?
02:58:29 <dons> not if it was using Integer for all list stuff
02:58:36 <RyanT5000> no no
02:58:42 <RyanT5000> using Integral
02:58:45 <RyanT5000> not Integer
02:59:52 <dons> well, it has to default to some monomorphic type somewhere
03:00:22 <RyanT5000> dons: do we really need defaulting? i've never used it (to my knowledge)
03:00:25 <RyanT5000> (except in ghci)
03:00:44 <dons> you would if there were not monomorphic functions :)
03:00:51 <Eelis> what is the purpose of WrappedMonad in the   Monad m => Applicative (WrappedMonad m)  instance?
03:00:56 <dons> like `length' to give the compiler a real machine type to use
03:00:57 <RyanT5000> dons: explicit type annotations?
03:01:19 <dons> you either need defaulting , or type annotations to resolve ambiguities
03:01:43 <wli> Well, I'm probably sounding like I'm coming out of left field, but machine integer overflows are a serious cause of unsafety.
03:01:50 <RyanT5000> dons: well, that's true, and i actually do like defaulting if it were done in some kind of rigorous way
03:01:55 <dons> yeah, its a bit weird, I agree
03:02:10 <dons> Integer would make sense for all list functoins (esp. since Integer is the default anyway)(
03:02:18 <dons> then again, we also need something not like Double :)
03:02:40 <RyanT5000> wli: that depends on how you mean "unsafety"
03:02:43 <wli> We could use a Natural but the numeric hierarchy gets in the way of that being useful.
03:02:52 <RyanT5000> wli: if i'm computing SHA-512, i really, really want it to overflow
03:02:58 <wli> RyanT5000: Remember the JPEG decoder buffer overflow exploits?
03:03:02 <dons> yeah, a Nat type would also help. that's a rather strange thing that it is missing
03:03:23 <RyanT5000> wli: sure, there have been several, i think
03:03:26 <wli> dons: The numeric hierarchy renders it useless.
03:03:34 <dons> yes
03:03:38 <dons> (-) and all that
03:03:41 <wli> RyanT5000: malloc(n*x) etc.
03:04:09 <Eelis> i wouldn't say "useless". receiving a Nat from length rather than an Int is still more informative
03:04:19 <RyanT5000> wli: that just means that an overflowable type is the wrong type
03:04:47 <wli> RyanT5000: Machine integer overflows in buffer size calculations for allocation requests. Short buffers are returned, at which point the idiot thing scribbles past the end of the buffer because it expected the product not to overflow.
03:05:03 <Royal_Son> dons : it worked thankyou !! And just a parting question : How long does it take to get one's head around the declarative programming paradigm?
03:05:23 <RyanT5000> wli: if you're actually representing (i hope i'm getting this right) a point in the Galois field of 2^32, then you want an overflowable number; otherwise you don't
03:05:24 <Royal_Son> (I am sure to return)
03:05:28 <dons> Royal_Son: oh, hmm. a few weeks?
03:05:39 <Royal_Son> ok
03:05:40 <dons> yes, do hang out here, and perhaps do some of the tutorials on haskell.org ?
03:05:47 <Royal_Son> will do
03:05:52 <Eelis> i see natural numbers are listed as "probably yes" for Haskell', yay!
03:05:59 <wli> RyanT5000: There are no e.g. signalling overflow semantics like there should be.
03:06:06 <Royal_Son> Thank you once again. This has already been a big help.
03:06:12 <dons> great! :)
03:06:17 <Royal_Son> See you later. Have a great day.
03:06:23 <wli> http://holomorphy.com/~wli/Natural.lhs
03:07:30 <wli> Without the Numeric hierarchy getting reorganized all it really is is a wrapper around Integer or otherwise a reimplementation of Integer that does error "oh crap" when people do the wrong things.
03:10:40 <wli> I sort of punted on division.
03:11:10 <wli> It probably would've been about the same length (and faster) to do schoolbook-style division.
03:15:02 <Eelis> is the purpose of WrappedMonad in the   Monad m => Applicative (WrappedMonad m)  instance simply that Haskell doesn't support   Monad m => Applicative m  ?
03:15:29 * wli is baffled at how why things are going so wrong for his MUSH-like chatserver.
03:18:08 <dons> Eelis: not all Monads instances given sane Applicatives? check the paper perhaps?
03:18:25 <dons> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
03:18:28 <lambdabot> Title: Applicative Programming with Effects
03:19:54 <wli> There is some sort of structuring trick that makes all this more effective.
03:20:10 <roconnor> @bab nl en uiteraard
03:20:11 <lambdabot>   of course
03:20:44 <dons> http://programming.reddit.com/info/2c95z/comments  (surprised we haven't had an Applicative fad yet, given the Arrows and Monad crazes on reddit :)
03:20:45 <lambdabot> Title: Effectful programming without monads: applicative functors (reddit.com)
03:22:58 <Eelis> dons: ah, i had only read up to the "any Monad can be made Aplicative" part. i now see the "just kidding" part a few pages further. thanks
03:23:17 <Saizan> just kidding part?
03:23:39 <Saizan> every monad has liftM and ap
03:24:27 * ibid just added new blogs to planet
03:25:20 <dons> ibid: good work!
03:25:33 <ibid> bah
03:25:41 <ibid> i had a month-long backlog :)
03:26:36 <dons> so lot of new contributors?
03:27:33 <Eelis> oh, i misread. there was no "just kidding" part. even in the paper's conclusion they say "every monad is an applicative functor" without reservations. i'm still confused
03:27:41 <ibid> four
03:27:52 <roconnor> dons: but isn't GHC really inefficent at handling these abstract classes?
03:28:01 <ibid> most of who haven't written anything in the past month :)
03:28:56 <dons> roconnor: hmm? not that I'm aware of.. (any more so than IO)
03:29:09 <Saizan> Eelis: Monad m => Applicative m requires overlapping and undecidable instances, and it seems they want to stick with h98 in base
03:29:26 <dons> we get great code from ghc for applicativs to join up serialisers in Data.Binary
03:29:35 <Eelis> Saizan: ah, that makes sense. i'll go read about undecidable instances. thanks!
03:29:40 <dons> more structure than just >> and >>= and easier to write rules for
03:30:59 <roconnor> dons: hmmm, maybe you are right.
03:31:04 <Saizan> Eelis: it's a ghc extension, basically it turns down the heuristic checks that guarantee that type inference terminate afaiu
03:31:13 <Eelis> in the mean time, the reason i asked about this is that i wanted to experiment with the Control.Applicative combinators on Parsec parsers, only to discover that there was no Applicative instance for GenParser. is this something worth requesting?
03:31:13 <xerox> 'There is this old question for an hard Oxford exam: <<Define Universe, give three examples.>>.' -- Phillip Wadler.
03:32:06 <Eelis> Saizan: interesting
03:32:27 <roconnor> dons: I'm guess my problem is when a moderate sized library (finger trees) use these foldable traversable things abstractly.  The moderately size library is too big for inlining, and then nothing gets inlined and everything grinds to a snails pace.
03:32:56 <dons> hmm, you should be able to inline key functions
03:33:12 <roconnor> dons: I take it you're moderate sized library (serializes) are not using foldable and traversable abstractly.
03:33:18 <dons> Data.Binary is moderately sized, and inlines pretty much the whole hing.
03:33:20 <dons> no
03:33:35 <wli> roconnor: My strategy is to write it as abstractly as possible and let SPJ et al figure out how to get ghc to optimize it.
03:33:57 <dons> yeah, bug report if things don't inline that you think they should (or optimise)
03:33:59 <roconnor> wli: yeah, that's been my strategy too.  But I do get restless.
03:34:07 <dons> we can keep pushing ghc towards whole program compilation :)
03:34:45 <roconnor> dons: whole program compilation would really help.
03:34:47 <xerox> Using Control.Arrow on tuples produced a 2.5Gb ghc.prof, moving to C !.. !.. !.. !.. reduced max consumption to 200kb :-/
03:35:05 * DRMacIver doesn't see the problem with whole program compilation. :)
03:35:08 <roconnor> wli: I think I'll be waiting quite a while before my UM interpreter becomes efficent.
03:35:10 <DRMacIver> Aside from "Oh dear god, the build times."
03:36:51 <roconnor> dons: bug reports don't cut it when it comes to ``optimization errors''.  I've probably mentioned this before.
03:37:31 <eivuokko> When using UNPACK-pragma with ghc, will fields always take atleast word size (ie does unpack make sense if my fields are bytes)?
03:39:00 <dons> roconnor: well, it works for the stream fusion stuff: lots of bug reports and examples, better optimiser by the end of that process
03:39:36 <dons> same with the ndp project. if the core doesn't look right, and you know what you're doing, spj is happy to look at it and think about how to improve things
03:40:00 <dons> how else is GHC HQ to become aware of issues? :)
03:40:03 <roconnor> I'm impressed
03:40:43 <roconnor> All I got last year was something like ``fixing the optimizer is tricky because things improve some programs and make others worse''
03:41:13 <roconnor> So I got the impression that the optimizer would only progress conservatively.
03:41:27 <wli> roconnor: Then it sounds like the trick is to figure out when those things that only help sometimes actually do help.
03:41:29 <dons> no no, some things are just harder to fix than others
03:41:31 <DRMacIver> Clearly what we need is a JIT for Haskell which dynamically determines which optimisations would be beneficial. ;)
03:41:39 <roconnor> I mean, since it is just a bunch of huristics anyway, it can't really be wrong in any strong sense.
03:41:42 <dons> inlining is a hot topic though, so dive in if you have issues related to that
03:41:55 <DRMacIver> (I seem to recall one of the early Haskell implementations had one?)
03:43:08 <roconnor> dons: my issue was vaguely related to inlining: bit shifting by a constant wouldn't remove the runtime checks on the size of the shift.
03:43:18 <dons> yes, i know about that one.
03:43:36 <dons> but its only one data point: you can't conclude no optimiser issues will be fixed, because 1 was hard :)
03:43:37 <wli> Wouldn't that be more of partial evaluation vs. inlining per se?
03:43:42 <roconnor> anyhow, it was a bit of a frusterating experience :(
03:44:19 <roconnor> The more I learn about how GHC works, the sadder I get.
03:44:31 <DRMacIver> I thought GHC basically didn't do optimisations based on simplifying constant expressions?
03:44:42 <DRMacIver> I know the one about integer powers comes up on a regular basis.
03:44:46 <DRMacIver> (Or is that fixed now?)
03:45:02 <roconnor> Ah, now I remember
03:45:13 <dons> strange roconnor, i've had only positive experiences, doing all the performance stuff i've worked on the last couple of years (dcoutts too, I think)
03:45:24 <wli> sorear recently showed me how using (^) sucks.
03:45:24 <dons> we ask, and often get, what we need :)
03:45:32 <dons> ?src (^)
03:45:32 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:45:35 <roconnor> one idea was to write allow rewrite rules to be somehow indicate you want it to be run when a parameter is a literal.
03:45:36 <matthew-_> DRMacIver: there are a few that you just learn the hard way, like a*a is much faster than a**2
03:45:39 <dcoutts> yeah, great fun
03:45:52 <dons> (^)		:: (Num a, Integral b) => a -> b -> a
03:45:52 <dons> _ ^ 0		=  1
03:45:52 <dons> x ^ n | n > 0	=  f x (n-1) x
03:45:52 <dons> 		   where f _ 0 y = y
03:45:53 <dons>  ...
03:45:56 <DRMacIver> matthew-_: Right, that's the one I had in mind.
03:46:25 <roconnor> dons: that isn't (^) is it?
03:46:46 <roconnor> oh wait
03:46:51 <roconnor> that's just the beginning.
03:46:51 <dons> while ** is actually a primop.
03:47:12 <dons> 		         f a d y = g a d  where
03:47:12 <dons> 			           g b i | even i  = g (b*b) (i `quot` 2)
03:47:12 <dons> 				         | otherwise = f b (i-1) (b*y)
03:47:16 <dons> is the rest, yeah
03:47:36 <matthew-_> yeah, but there are issues with ^ and specialisation isn't there? Some issue with specialisation hurts inlining?
03:47:42 <wli> dons: Um, that can't be the real source for it.
03:47:46 * matthew-_ may be misremembering
03:47:47 <roconnor> dons: what's wrong with (^)? (Other than that there is not easy way to pass an optimized squaring function?)
03:47:55 <dons> it gets specialised for Integer and Int
03:48:12 <dons> wli, check GHC/Real.lhs
03:53:33 <roconnor> @seen Lemmih
03:53:33 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 13h 7m 43s ago.
03:54:33 <dnox> dcoutts: you are running hs-plugins on 6.6 in win?
03:54:57 <dcoutts> dnox: I don't do much in windows except build gtk2hs, so no.
03:55:14 <Lemmih> roconnor: Yo.
03:55:21 <dcoutts> dnox: you need the latest darcs hsplugins for it to work with ghc-6.6 I think
03:55:45 <dnox> dcoutts: ok, i thought i saw in some forum that you did
03:56:32 <roconnor> Lemmih: I've been thinking about cons.
03:56:46 <dcoutts> dnox: I try to encourage people to make sure our software doesn't suck on windows, but that's only because we have lots of users on windows, not because I use it :-)
03:56:59 <roconnor> In C++ the ropes library presumbably buffers inputs allowing one to cons more efficently.
03:57:17 <roconnor> but we are in a pure langauge and that isn't possible.
03:57:18 <dnox> well, hardly anyone seem to get hs-plugins to work in win
03:57:29 <Lemmih> roconnor: Why isn't it?
03:57:42 <roconnor> It would destroy sharing unless we sequence it by putting it in a monad.
03:57:44 <Lemmih> roconnor: cons is already using unsafePerformIO.
03:57:48 <dcoutts> dnox: aye, it's pretty low level. ask dons if he's heard of anyone ever getting it to work
03:58:05 <roconnor> Lemmih: And Data.Binary.Put is basically that monad already.
03:58:08 <Lemmih> roconnor: Oh, right.
03:58:34 <dnox> dcoutts: me and dons tried it before, got some annoying runtime error that we didnt solve
03:58:37 <roconnor> So I more or less think that requiring the use use (something like) Data.Binary.Put is the reasonable way to go.
03:58:40 <dcoutts> roconnor, Lemmih: or use an extremely cunning solution I suggested previously
03:58:58 <roconnor> dcoutts: there is a cunning solution?
03:59:20 <dcoutts> roconnor: it's a low level solution to the appendable buffer problem
03:59:29 <roconnor> dcoutts: does it involve diffArrays?
03:59:37 <dcoutts> no, but something similar
03:59:52 <dcoutts> it gives O(1) in the common case when used in a linear way
04:00:13 <dcoutts> appending to older versions incurrs O(n) the first time to unshare
04:01:13 <roconnor> dcoutts: how does it work?
04:01:57 <dcoutts> roconnor: it keeps a mutable counter that records the generation, then when appending we can see if we're the latest generation
04:02:06 <dcoutts> if we are then we can append directly into the free space
04:02:12 <dcoutts> if we're not, we have to copy
04:02:39 <roconnor> dcoutts: Sounds like it is the job of the Data.ByteString people to provide this. ;)
04:02:49 <dcoutts> right, it's very low level
04:03:17 <dcoutts> to be really fast it probably needs atomic ops to do it without locking
04:05:15 <taruti> When designing a DSL with rules for well-formed expressions involving variables how could variable identity be translated to type-level to maintain constraints with GADTs + type classes? Using a unique type for each variable seems problematic if wishing to use a parser generating DSL expressions on the fly.
04:05:32 <roconnor> Lemmih: If I'm bored this afternoon I will re-rewrite my code to go back to using Data.Binary.Put when creating the new strand of DNA for the end of matchReplace
04:06:34 <Lemmih> roconnor: You should be aware that it allocates a minimum of 32k.
04:07:26 <roconnor> Lemmih: hmm, I suppose that is pretty big.  Although I'm not certain allocation time is proportial to the size of the allocation.
04:07:32 <Lemmih> roconnor: We should really create a darcs repo so we can share our improvements.
04:07:59 <roconnor> Lemmih: I suppose that is overdue. :/
04:08:14 <Lemmih> roconnor: It's hell for the garbage collector.
04:09:04 <roconnor> Lemmih: well, I'll give it a shot anyways and see how it goes.
04:09:31 <roconnor> shouldn't there be an interger parameter to runPut?
04:15:03 <roconnor> dcoutts: shouldn't the buffer allocation size be a parameter to Builder.toLazyByteString and some version of runPut?
04:15:28 <dcoutts> roconnor: I suppose so, if you really want to override it
04:15:30 <roconnor> Lemmih: It shouldn't be hard to patch Data.Binary.
04:16:04 <dcoutts> though it means there's an extra parameter to pass around all the time
04:16:12 <roconnor> Lemmih: defaultSize is only used in two places.
04:16:29 <roconnor> dcoutts: dons was just saying how good the optimizer is :)
04:17:07 <dcoutts> roconnor: but it does mean passing an extra parameter, that's an extra stack slot or register
04:17:21 <dcoutts> it's not completely free, that is very performance sensitive code
04:18:10 <dcoutts> and the optimiser is very good, the register allocator and other low level bits are not yet
04:18:24 <roconnor> yeah but when you runPut, it will pass in defaultSize.
04:18:33 <roconnor> defaultSize is known at compile time.
04:18:45 <roconnor> so everything will get inlined and the result will be exactly the same, right?
04:19:00 <dcoutts> no, it has to pass the default size around
04:19:07 <roconnor> why?
04:19:25 <Lemmih> roconnor: re cons. Cons is only using 5.8% CPU and 13% memory. That's quite good considering the tens of millions of times it's called. Optimizing other areas might give a bigger yield.
04:19:25 <dcoutts> it's going to share the code for each type between all uses of that
04:19:36 <dcoutts> it's not going to inline for every use of runPut
04:19:40 <roconnor> Lemmih: oh, I thought you said cons was slow.
04:19:46 <AHTOH> Hi All, can anybody help me? I use ghc-6.6.1, had imported Text.Regex and have problem with compilation "In function `Main_lvl_info':
04:19:46 <AHTOH> ghc19429_0.hc:(.text+0xe0): undefined reference to `regexzmposixzm0zi71_TextziRegexziPosixziString_makeRegexOpts_closure'"
04:20:09 <Igloo> Use -package regex-posix or --make
04:20:09 <Saizan> AHTOH: compile with --make
04:20:27 <Lemmih> roconnor: It was. Then I unrolled 'viewr' manually and it became fast.
04:20:30 <roconnor> dcoutts: oh
04:20:41 <roconnor> craptastic.
04:20:55 <AHTOH> Saizan: thanks that helped, but what is that all about?
04:21:02 <dcoutts> roconnor: what kind of default size do you want?
04:21:02 <roconnor> Lemmih: unrolled viewr?
04:21:18 <Saizan> AHTOH: it tells the linker to link the libraries you need in your binary
04:21:34 <roconnor> dcoutts, I'm not sure.  Initially I'd try something like 1k.
04:22:49 <Saizan> Igloo: what problems would arise from having --make as default unless you specify a -package ?
04:23:03 <Lemmih> roconnor: 'viewr' is recursive so it can't be inlined. We were creating a 'Single x' which would just expand to 'Empty :> x'. Inlining 'viewr' avoids the creation of Single and :>.
04:23:39 <roconnor> viewr is recursive?
04:23:45 <Lemmih> roconnor: Yes.
04:24:19 <Lemmih> roconnor: In the (Deep _ pr m (One x)) case.
04:24:36 <roconnor> you are right, it is.
04:24:55 <roconnor> *sigh*
04:25:08 <roconnor> this sucks.
04:26:08 <roconnor> Lemmih: how's our speed doing?
04:26:22 <roconnor> or rather your speed ;)
04:27:10 <Lemmih> roconnor: Better inlining of cons cut ~2m off empty.dna.
04:27:44 <roconnor> wow, that's a lot.
04:27:54 <roconnor> Lemmih: how do you fix cons without making a big mess of the code?
04:28:45 <wli> Is anyone working on getting ghci to accept data type declarations at the interpreter prompt?
04:28:53 <roconnor> ... maybe you can carve up append into little pieces.
04:30:29 <roconnor> append has two trivial cases, and then one main case (which is itself two cases).
04:30:31 <Lemmih> roconnor: I manually inlined append in cons. It's not too ugly but definitely not pretty.
04:31:04 <roconnor> so the main part of appent could be extracted.
04:31:12 <roconnor> and cons could call it directly.
04:31:13 <Lemmih> roconnor: Rope is down to 3m20. Seq is at ~2m.
04:31:44 <roconnor> *sigh*, still a long way from 18 seconds.
04:32:08 <AHTOH> matchRegex (mkRegex "[A-Z]+") "ABCDE"
04:32:09 <Lemmih> Do we have the version that did it in 18 seconds?
04:32:15 <roconnor> nope ;)
04:33:02 <AHTOH> where is a lamdabot?
04:33:15 <roconnor> @seen lambdabot
04:33:15 <lambdabot> Yes, I'm here. I'm in #gentoo-haskell, #haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc, #darcs and #scannedinavian
04:33:16 <Lemmih> I call shenanigans, then.
04:33:38 <AHTOH> print (fromMaybe [] (matchRegex (mkRegex "[A-Z]+") "ABCDE"))
04:34:00 <profmakx> AHTOH  you need to prefix your statement with >
04:34:04 <AHTOH> >print (fromMaybe [] (matchRegex (mkRegex "[A-Z]+") "ABCDE"))
04:34:22 <AHTOH> damn it doesnt works
04:34:26 <profmakx> and a space between > and your statement
04:34:29 <AHTOH> > print (fromMaybe [] (matchRegex (mkRegex "[A-Z]+") "ABCDE"))
04:34:31 <lambdabot>   Not in scope: `mkRegex'
04:34:46 <AHTOH> > import Text.Regex; print (fromMaybe [] (matchRegex (mkRegex "[A-Z]+") "ABCDE"))
04:34:46 <lambdabot>  Parse error
04:35:14 <roconnor> Lemmih: oh sorry, 16 seconds ;)
04:35:26 <roconnor> http://programming.reddit.com/info/2a6hr/comments/c2a7fv
04:35:27 <lambdabot> Title: ICFP Contest Losing It&#39;s Functional Nature? (reddit.com)
04:36:45 <Saizan> > (fromMaybe [] (Text.Regex.matchRegex (Text.Regex.mkRegex "[A-Z]+") "ABCDE"))
04:36:46 <lambdabot>   Not in scope: `Text.Regex.mkRegex'
04:36:46 <xerox> AHTOH: Text.Regex is not available in lambdabot
04:37:11 <AHTOH> yeah, thats have i understood
04:37:15 <roconnor> Lemmih: http://jsnell.iki.fi/blog/archive/2007-07-25icfp-2007.html claims 41 seconds
04:37:17 <lambdabot> Title: ICFP 2007 &mdash; Juho Snellman's Weblog
04:37:21 <roconnor> and has source.
04:37:33 <roconnor> and is in scheme or lisp.
04:37:37 <AHTOH> by me it returns [], so no matches found, seems strange
04:37:51 <roconnor> lisp.
04:38:33 <Lemmih> roconnor: I'm not savvy enough to run CL.
04:39:14 <xerox> AHTOH: matchRegex (mkRegex "([A-Z]+)") "ABCDE"
04:41:47 <AHTOH> xerox: thanks
04:41:58 <xerox> You're welcome.
04:43:57 <AHTOH> xerox: do i understand correct that matchRegex should return all matches in a list?
04:44:12 <AHTOH> by me it returns only first match
04:44:41 <LoganCapaldo> @hoogle matchRegex
04:44:42 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
04:44:42 <lambdabot> Text.Regex.matchRegexAll :: Regex -> String -> Maybe (String, String, String, [String])
04:44:42 <AHTOH> matchRegex (mkRegex "([AB]+C)") "ABCBBBAC"
04:45:18 <LoganCapaldo> I know matchRegexAll definitely returns only one match
04:45:18 <xerox> Try using matchRegexAll to see what's going on with your regexp matching.
04:46:09 <xerox> What would you have expected it to return instead of Just ["ABC"] ?
04:47:02 <AHTOH> should i have a loop to have the rest matches?
04:48:28 <kpreid> sorry about that
04:48:29 <Cale> AHTOH: Have you looked at the new regex interface?
04:48:44 <xerox> Oh right, there's =~.
04:48:55 <roconnor> Lemmih: yeah, I don't immediately see how to compile lisp.
04:49:10 <xerox> roconnor: sbcl file.lisp and call whatever is the entry point?
04:49:21 <kpreid> --load file.lisp
04:49:25 <Cale> =~ is extraordinarily overloaded :)
04:49:41 <Cale> It's perlesque :)
04:49:42 <LoganCapaldo> Violently overloaded
04:49:43 <AHTOH> Cale: whats a new regex interface? at library page cant find it
04:49:49 <xerox> Yeah :)  Text.Regexp.Posix
04:50:00 <Cale> AHTOH: Text.Regex.Base/Posix/Etc.
04:50:10 <xerox> Cale, do you remember where is the page full of examples?
04:50:14 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-Context.html
04:50:16 <lambdabot> http://tinyurl.com/yovda9
04:50:25 <Cale> hmm, that's not examples, but it does list the instances
04:51:19 <xerox> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
04:51:21 <lambdabot> Title: teideal glic deisbhÃ©alach » Blog Archive » A Haskell regular expression tutoria ..., http://tinyurl.com/2xtgpw
04:51:28 <Cale> well done :)
04:51:56 <AHTOH> thank you guys, will study that :)
04:52:06 <xerox> np :) *heads to lunch*
04:52:15 <roconnor> xerox: does that compile it?
04:52:42 <kpreid> no
04:52:59 <roconnor> well, if it isn't compile I suppose it won't run very fast. :)
04:53:06 <Cale> AHTOH: Basically, depending on what type is demanded for (str =~ regexp), you'll get different kinds of useful information about the matches.
04:53:09 <roconnor> I don't immediately see how to compile lisp.
04:53:13 <kpreid> well, sbcl runs in an always-compile mode by default
04:53:37 <xerox> May be (compile 'symbol) ?
04:53:40 <kpreid> it compiles every function
04:53:47 <kpreid> but there's a distinct "file compilation" operation
04:53:52 <Lemmih> xerox: How do you call the entry point?
04:54:03 <Cale> AHTOH: If you ask for a Bool, you just get whether it matches, if you ask for (String,String,String), you get before/matched/after, and if you ask for [String], you get a list of matches, and so on.
04:54:08 <kpreid> (compile-file "foo.lisp")
04:54:21 <kpreid> (load "foo") ; loads the compiled result
04:55:06 <Cale> AHTOH: And you can get arrays of the subexpression matches, or lists of arrays of subexpression matches...
04:55:20 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-Context.html -- this lists all the possibilities
04:55:21 <lambdabot> http://tinyurl.com/yovda9
04:55:22 <kpreid> there's a comment halfway through that lisp file that seems to suggest how to run it
04:55:46 <kpreid> I'll stop talking OT now unless someone wants to know more
04:57:14 <roconnor> ah, there it goes
04:57:20 <roconnor> indeed it is pretty fast!
05:00:02 <AHTOH> Cale: yeah little complicated but very powerfull undeed
05:01:33 <AHTOH> user error (Text.Regex.Posix.String died: (ReturnCode 10,"Invalid content of \\{\\}"))
05:02:50 <matthew-_> sheesh, I don't think I've cleaned my windows for 2 years. No wonder it took half a bottle of cleaner and half a roll of kitchen roll...
05:02:52 <roconnor> boy, why is that lisp program so fast?
05:04:07 <roconnor> It looks a lot like out lazy bytestring solutions.
05:04:08 <sieni> matthew-_: I assume that you don't have a female around
05:04:11 <dons> do we only have the comment for the speed?
05:04:17 <dons> or has someone measured it?
05:04:29 <matthew-_> sieni: she'd hit you for that! Yes, but these are sky lights and she can't reach them
05:04:37 <roconnor> dons: I just ran the lisp code.
05:04:40 <roconnor> It's fast.
05:04:43 <dons> huh . very interesting
05:04:49 <dons> do investigatify! :)
05:04:57 <roconnor> I'm not sure it is correct.
05:05:09 <sieni> matthew-_: not that she would have saved you from cleaning the windows, but using kitchen roll instead of some reusable material for environmental yada-yada reasons
05:05:25 <roconnor> but It takes about the right number of steps and produces some output.
05:05:34 <roconnor> I just cannot easily compare the output to mine.
05:06:04 <matthew-_> sieni: err, I disagree - they were filthy that cleaning a cloth repeatedly would have wasted more energy in terms of the production of hot water than using half a roll of recycled kitchen paper
05:06:34 <matthew-_> sieni: though obviously, that is a complete guess and I may be orders of magnitude wrong
05:07:03 <matthew-_> siene: it is so bright in here now that I'm considering putting sunglasses on!
05:07:30 <dons> i have a couple of nice microfibre cloths, they seem to clean pretty much anything without additional chemical cleaners, fwiw
05:07:39 <matthew-_> oooo.
05:07:42 <dons> and you don't throw them out
05:07:54 <matthew-_> do they have Ï‚ 's printed on them?
05:08:00 <matthew-_> agh, Î» rather,
05:08:09 <dons> hmm, don't think so
05:08:43 <roconnor> dons, Lemmih: the lisp program runs in 1m3s on my (slow) laptop.
05:08:52 <roconnor> Haskell should hang it's head in shame.
05:09:23 <matthew-_> mmm. I wonder if anyone has tried arguing that Haskell is more environmentally friendly on the grounds that the programs are smaller, thus you do less harddisc seeking to load and save them...
05:09:29 <dons> heh
05:10:02 <dons> type inference saves electrons!
05:11:51 <basti_> np: Infected Mushroom - Vicious Delicious (7m24s)
05:12:19 <Botje_> pfft
05:12:35 <Botje_> I like becoming insane and change the formality better
05:12:37 <Lemmih> roconnor: Where does the RNA go?
05:12:47 <roconnor> Lemmih: into the *rna* variable.
05:13:06 <roconnor> Lemmih: I'm working on parsing the result to see if it is the same as mine.
05:14:38 <tcr> ndm: ping. :)
05:14:59 <AHTOH> Help!  We are a group of computer scientists held prisoner on t","he remote planet of Utrecht in the Orion nebula by the evil Fuun.  The Fuun have already conquered thousands of worlds, and it a","ppears that Earth is next.  Their modus operandi is always the same: they organize a fake `programming contest' on the victim wo","rld to repair a supposedly disabled Fuun. This enables them to identify that planet's best and
05:14:59 <AHTOH> brightest minds, who are then eli","minated in advance of the actual invasion, leaving the planet defenseless against the Fuun's superior weaponry.  You must not, u","nder any circumstances, repair the Endo creature, as he - when reactivated - will surely destroy his `rescuers' and give the att","ack signal to the Fuun invasion force massing near Sullust.  Do not give in to the lure of rewards, monetary or otherwise! * * *"," It is too late for us, but in t
05:15:00 <AHTOH> he unlikely event that Earth manages to stave off the Fuun invasion, we would appreciate a monum","ent of some sort to honour us (especially since we sabotaged the Fuun DNA by swapping some parabolas).  We are: Alexey Rodriguez"," * Andres Loeh * Arie Middelkoop * Bastiaan Heeren * Chris Eidhof * Clara Loeh * Eelco Dolstra * Eelco Lempsink * Jeroen Leeuwes","tein * Johan Jeuring * John van Schie * Jurriaan Hage * Maaike Gerritsen * Mark Stobbe * Martijn van
05:15:07 <AHTOH>  Steenbergen * Stefan Holder
05:15:36 <dons> bit too much to paste into the channel, AHTOH
05:15:41 <AHTOH> sorry
05:16:45 <AHTOH> seemed that is important message, but bit too late, i think endo was repaired
05:17:47 <ari> AHTOH: :D
05:18:10 <dons> its sad that all the Utrecht guys are being held prisoner :)
05:18:16 <Cale> hehe
05:18:33 <Cale> Did you find the picture of them holding up signs?
05:18:40 <AHTOH> not yet
05:18:50 <AHTOH> though i ve heard about it
05:18:58 <Cale> hehe, I found it in a rather funny way :)
05:19:07 <Lemmih> roconnor: Not outputting RNA shaves a little less than a minute off the Rope version.
05:19:09 <Cale> (certainly not the intended way)
05:19:24 <AHTOH> but im still trying to study the dna further: i cracked all encrypted pages except vmu
05:19:37 <roconnor> Lemmih: um, shouldn't it shave 100% of the Rope version?
05:20:49 <Lemmih> roconnor: I still generated all of the RNA.
05:21:03 <roconnor> Lemmih: what do you do with it?
05:21:29 <roconnor> gee, parsing this RNA is taking it's sweet time.
05:21:39 <AHTOH> Cale: most of contestants have done much work not the intended way.
05:22:00 <AHTOH> I heard rumours that intended way really doesnt exist
05:22:07 <roconnor> AHTOH: how do you know this?
05:22:41 <AHTOH> i ve read mant postmortems, nobody have wrote about adaptive genes, repairing broken bioMul fuction,etc
05:23:18 <Cale> AHTOH: basically, by screwing up a direct hack on the DNA (I didn't want to bother writing a prefix to do it, and it was before we had a tool for that), I had it produce a load of gibberish RNA which included bits and pieces of lots of stuff
05:24:28 <roconnor> AHTOH: Presumably few people had enought time to get that far.
05:24:32 <Cale> http://cale.yi.org/autoshare/Screenshot-RNA%20GUI-1.png -- here's a partial draw from the messed up RNA. At various points in time, the letters become visible. (they're not all visible in that one)
05:25:16 <dons> nice screenshot, xmonad, tabbing, and the xmonad interactive prompt, http://gorgias.mine.nu/xmonadXPrompt.png
05:26:26 <AHTOH> i saw somewhere a full picture of that
05:26:53 <Cale> It also drew lots of other stuff, but nothing quite so blatant as that. :)
05:27:23 <dozer> aw how sweet - is that an indy just off-left of that screenshot?
05:28:11 <Cale> looks like it, doesn't it? :)
05:28:43 <AHTOH> Cale: what place do you got?
05:28:53 <dozer> I've got one under the stairs - gf is telling me to get it running or sling it out
05:28:54 <AHTOH> we had managed to 40th place
05:28:58 <Cale> AHTOH: We got 56th, I think?
05:29:28 <Cale> AHTOH: We got a lot after getting the sun rotated, but nothing we could use to generate a better prefix before the deadline
05:29:36 <dnox> what competition?
05:29:43 <Cale> ICFPC
05:30:09 <Cale> http://www.icfpcontest.org/
05:30:10 <lambdabot> Title: ICFP Programming Contest 2007
05:30:16 <Cale> I should hack on it some more :)
05:30:28 <roconnor> Lemmih: the rna output is the right length.
05:30:29 <Cale> I haven't really done so much since it ended.
05:30:53 <roconnor> Cale: lisp puts us to shame ... well at least me to shame, I forget how fast your code was.
05:31:07 <Cale> Oh yeah?
05:31:28 <AHTOH> Cale: it sounds strange but i wrote 0 lines code for the contest: just generating ideas :)
05:31:49 <AHTOH> but we had only 30 min wuick version ;(
05:32:00 <roconnor> This lisp program runs endo.dna in about 1min on my laptop.
05:32:12 <Cale> AHTOH: Which language did you write it in?
05:32:21 <Cale> roconnor: That's pretty awesome :)
05:32:25 <AHTOH> roconnor: which data structure theu used?
05:32:35 <Cale> roconnor: We should figure out what it is that it's doing :)
05:32:50 <roconnor> http://jsnell.iki.fi/blog/archive/2007-07-25icfp-2007.html
05:32:51 <lambdabot> Title: ICFP 2007 &mdash; Juho Snellman's Weblog
05:33:08 <roconnor> ``For what it's worth, I used just about the stupidest imaginable implementation strategy beyond just a naive string: represent the program as a linked list of variable length chunks, which will share backing storage when possible.
05:33:25 <roconnor> seems analogous to lazy bytestrings.
05:33:36 <AHTOH> Cale: in Java. :( its has a DNA as char[]. C version with char[] was 22min, that the best we could do with string represetation
05:34:21 <AHTOH> now i ve written Haskell which in moment id 6-7 minutes fast
05:34:31 <Cale> Yeah, mine was around that.
05:35:19 <xpika> is there a shellrc for just plain shell
05:35:37 * wli gets annoyed with nested case statements.
05:36:04 <Cale> wli: which nested case expressions?
05:36:44 <wli> Cale: case blah of Nothing -> ... Just foo -> case foo of ...
05:36:57 * roconnor avoids case expressions.
05:37:00 <Cale> wli: That's what the Maybe monad is for
05:37:04 <dons> roconnor, yeah, sounds like a lazy bytestring, but for `will share backing storage when possible'
05:37:15 <wli> Cale: There are eithers in here too.
05:37:19 <Cale> ah
05:37:26 * nominolo knows cl
05:37:37 <roconnor> dons: doesn't lazy bytestrings do that? or do I not understand what he means.
05:37:40 * nominolo could answer impl detail questions
05:37:47 <dcoutts> dons: well bytestrings share memory when we take substrings
05:37:57 <dcoutts> dunno if that's what it meant though
05:38:00 <dons> i don't know what he means.
05:38:08 <Cale> I've used cl, but I avoided loop the whole time.
05:38:13 <dons> if it just means sharing, then yeah, sharing is good
05:38:20 <Cale> So I know very little about it :)
05:38:41 <nominolo> loop is cool
05:38:47 <dcoutts> who want's to help with Cabal bug triage? :-)
05:38:49 <dcoutts> http://hackage.haskell.org/trac/hackage/query?status=new&status=assigned&status=reopened&group=priority&type=defect&order=priority
05:38:49 <nominolo> though not really extensible
05:38:52 <lambdabot> Title: Custom Query - Hackage - Trac, http://tinyurl.com/2uotmr
05:38:53 <roconnor> Haskell is so slow ;_;
05:39:08 <Cale> roconnor: Hey, it's not that bad :)
05:39:22 <dcoutts> we need to find if these cabal problems are still problems, and prioritise them
05:39:28 <dons> roconnor: that's too vague a statement to be uttered here :)
05:39:41 <dons> but if someone implements the
05:39:54 <dons> cL thingy, in bytestrings, and it is not competitive or faster, i'll take that as a bug report
05:40:49 <xpika> will setting the LD_LIBRARY_PATH allow me to forward calls to /lib?
05:44:42 <roconnor> oops, I got the lisp generated RNA backwards
05:44:52 <Cale> hmm, I should try naively changing my compiler to use lazy bytestrings and see what happens :)
05:45:19 <roconnor> Okay, now I've verified that the RNA generated by the lisp program is the same as mine.
05:45:21 <Cale> er, interpreter, or whatever the heck it is :)
05:52:39 <AHTOH> have found 65k interesting text in dna, including Major Imp's Next Assignment Episode 222
05:53:12 <roconnor> Cale: which reminds me I wanted to try my original lazy bytestring code without using the MTL.
05:54:44 <AHTOH> hmm, recovered all genes names, including damaged in original genetable
05:58:22 <roconnor> lisp is so fast ;_;
05:58:30 <arcatan> so fast so furious
06:01:03 <Eelis> hm, i'm looking at the Monoid type class and its instances, and the   Num a => Monoid (Product a)  /  Num a => Monoid (Sum a)   approach seems very awkward to me. are there theoretical generalizations of type classes in which one can express more straightforwardly that "any Num with (+) and 0 is a Monoid" and that "any Num with (*) and 1 is a Monoid" ?
06:02:24 <roconnor> Wow, my lazy bytestring implementation runs in 4m45s on my laptop!
06:02:36 <roconnor> It would probably run twice as fast on one of the university computers.
06:02:53 <roconnor> Ugh, I knew I shouldn't have used the MTL.
06:02:55 <wli> I have a notion that the heavy monadic code runs slow for some reason.
06:03:03 <roconnor> I thought, oooh, this is my chance to learn how to use the MTL.
06:03:09 <kpreid> Eelis: Every Num has (+) and (*), so you mean "any Num is two different Monoids"
06:03:20 <roconnor> From now on, I'm just writing my own monads.
06:03:39 <dons> ill have a look at your bytestring code tomorrow, if you want, roconnor
06:03:44 <dozer> presumably, there are billions of monoids that could be built from Num a, a suitable value and operator?
06:03:53 <wli> I barely understand monads and know even less of the performance analysis affairs, so I'm totally clueless.
06:04:06 <roconnor> dons: sure if you'd like to.
06:04:32 <wli> Eeelis: Parametrizing classes on method names somehow would probably do it.
06:04:44 <roconnor> Lemmih: I have a sinking feeling that using lazy bytestrings will be faster than Ropes, and maybe faster than Seq.
06:04:47 <Eelis> kpreid: no, i'm thinking of a more general notion of type classes instances of which are only instances relative to some constants
06:05:04 <Eelis> wli: yes, that's the sort of thing i'm after
06:05:29 <Eelis> aware of any work on this?
06:05:38 <taruti> How does one make a GADT Typeable? as deriving clause seems not to be supported.
06:05:49 <dozer> Eelis: you sort of want to say "instance Num a => Monoid a ((*)::a->a->a) (1::a)
06:05:55 <dcoutts> dons: how do we encourage people to hack on infrastructure? can we make it more glamorous?
06:06:05 <wli> Eelis: The big trap here is that naive extensions are typically either undecidable or flat out inconsistent. There's a reason why it takes experts to come up with this stuff.
06:06:10 <dons> hmm. make it easy to get started?
06:06:12 <dcoutts> dons: we need more people to work on hackage, cabal, cabal-install etc
06:06:24 <Eelis> dozer: yes
06:06:26 <dons> i've had a lot of people submit patches to mkcabal, becaause it was easy to get the code, use it, understand it
06:06:34 <dcoutts> dons: nominolo and I have been trying to refactor and improve the internal cabal code
06:06:45 <dons> unlike hackage, which i don't even know if we can run locally
06:06:52 <Eelis> wli: oh, i'm convinced of that, which is why i want to read that expert's papers :)
06:06:56 <roconnor> Eelis: have you seen Sum and Product?
06:07:10 <dcoutts> dons: me neither, but I don't have the time to hack on it either really :-)
06:07:10 <Eelis> roconnor: yes, i mentioned that that approach seemed awkward
06:07:13 <Eelis> gotta go, back in an hour
06:07:27 <roconnor> Eelis: ah yes, sorry.
06:07:31 <dcoutts> dons: cabal-install is pretty easy to hack
06:07:46 <dozer> Eelis: I think that we could rustle up something that behaves a bit like that and is typesafe with a GADT+instance declaration... let me see
06:07:48 <wli> I'm too bogged down in pedagogical affairs to be able to make any meaningful contributions... call me when I've figured out monads, GADT's, TH, fundeps, Arrows, et al.
06:07:55 <dons> dcoutts: does it have its own repo yet?
06:08:19 <dcoutts> dons: yes. cabal get --partial http://darcs.haskell.org/cabal-install/
06:08:20 <lambdabot> Title: Index of /cabal-install
06:08:25 <dons> ah, perfect
06:08:44 <dcoutts> it almost certainly needs updating to work with latest darcs Cabal
06:09:04 <dcoutts> since we've done lots of internal cabal api changes, and cabal-install uses that somewhat
06:09:15 <dcoutts> probably not a hard job though
06:09:25 <dons> writing a tutorial on h.o about installing libs with cabal-get would boost users, and then lead to patches
06:09:30 <nominolo> dcoutts: cabal-install is broken, atm
06:09:39 <dcoutts> nominolo: doesn't surprise me
06:09:46 <dons> (the way the `how to write a haskell program' that used mkcabal and QC led to more mkcabal use and QC use
06:09:58 <nominolo> dons: i think that's what i'm supposed to do for TMR
06:10:08 <dcoutts> dons: but we need to be careful, we can't ask users to use it while it's broken, we need first to get haskell hackers to fix it and make it work better
06:10:09 <dons> nominolo: ok, that sounds good
06:10:18 <nominolo> dons: yes, your tutorial was great
06:10:22 <dons> nominolo: ensure it is also in html form: pdf is bad for the web.
06:10:24 <dcoutts> there's loads of things than could be done to improve it with just a little hacking time
06:10:43 <dcoutts> so I wonder if we can advertise hacking on it a bit more
06:10:53 <dons> just distribute it with cabal, installed by default, broken
06:11:02 <dons> itd get fixed in a day or so, if it was on everyone's machine
06:11:08 <chessguy> 'morning
06:11:14 <dons> and they were instructed to try cabal-install first
06:11:24 <dcoutts> dons: though by the time it's on everyone's machine it's too late if it's broken
06:11:36 <dcoutts> it needs some love from some developer first
06:11:40 <dons> just announcing it to the librraies@ list, with a walk through installing a package would be the start
06:12:04 <dcoutts> saying, "please hack on this" you mean?
06:12:07 <dons> say, xmonad. since it uses 3 or 4 packages. show how it improves producitivty, get the hackers to fix any remaining issues
06:12:18 <dons> so: tutorials, announcements, compelling arguments to start using it
06:13:11 <dcoutts> we need another nominolo, someone with time and energy to hack on it and enthuse other people
06:13:16 <nominolo> dcoutts: SoC is 4 more weeks
06:13:16 <dcoutts> I feel exhausted
06:13:33 <dons> dcoutts: hmm. yes. the next generation
06:13:59 <dcoutts> dons: see, hacking infrastructure could be cool, because you've got lots of users
06:13:59 <chessguy> dcoutts, dons, what package are you talking about?
06:14:14 <dcoutts> chessguy: cabal, cabal-install, hackage
06:14:30 <chessguy> ah
06:14:36 <dcoutts> it all nearly works, it just needs some people with a bit of time & energy to go the last step
06:14:46 <chessguy> i've always said that hackage needs a darcs interface
06:14:53 <dcoutts> chessguy: meaning?
06:14:58 <dcoutts> chessguy: and can you implement it?
06:15:06 <plutonas> i found this: fac n = if n > 0 then n * fac (n-1) else 1 on wikipedia's haskell page, but typing it into ghci doesn't seem to work
06:15:21 <dons> plutonas: prefix it with `let '
06:15:22 <zbrown> plutonas: you need to use "let"
06:15:34 <plutonas> hm, ok, and why's that?
06:15:35 <zbrown> plutonas: if you entered it in a *.hs file, you could compile it
06:15:35 <chessguy> dcoutts, meaning that if there's a package foo on hackage, i should be able to do something like "darcs get foo.hackage.org"
06:15:38 <dons> (in ghci this is required, as you're declaring new expressions interactively)
06:15:48 <zbrown> plutonas: listen to dons, he knows much :)
06:15:55 <dons> Prelude> let fac n = if n > 0 then n * fac (n-1) else 1
06:15:56 <dons> Prelude> fac 7
06:15:56 <dons> 5040
06:16:34 <plutonas> i see
06:16:35 <dcoutts> chessguy: ok, so that needs a few simple changes, one we need to have a field in the .cabal file for darcs repos, then we need to update the hackage web scripts to show that url in the description, and/or mirror it
06:16:37 <plutonas> interesting
06:16:44 <dcoutts> chessguy: want to take it on?
06:16:45 * zbrown goes back to his erlang hacking
06:17:11 <dons> don't complain here about type errors then, zbrown ;)
06:17:13 <chessguy> dcoutts, err...if i knew how, i would
06:17:29 <dcoutts> chessguy: grab the cabal and hackage repos and dive in
06:17:35 <zbrown> dons: I never have type errors ;) I pay attention to my code :)
06:17:58 <dcoutts> chessguy: follow the pattern to add a new field to the .cabal file format
06:18:08 <AHTOH> is there in haskell something to write shorter f(f(f(f(f(f(f(....(f(f x))))))))))))). ?
06:18:18 <zbrown> dons: but that is one thing i love about haskell :)
06:18:21 <dons> :t iterate
06:18:25 <lambdabot> forall a. (a -> a) -> a -> [a]
06:18:29 <roconnor> > (iterate (+1) 0)!!20
06:18:32 <lambdabot>  20
06:18:40 <roconnor> > (iterate (*2) 1)!!10
06:18:41 <lambdabot>  1024
06:18:58 <chessguy> @where cabal
06:18:59 <lambdabot> http://www.haskell.org/cabal
06:19:01 <dons> > fix (1:)
06:19:03 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:19:14 <zbrown> dons: now if only I could get erlang-like concurrency with haskell-like typing
06:19:16 <LoganCapaldo> > fix error
06:19:17 <lambdabot>  Exception: <<loop>>
06:19:24 <LoganCapaldo> boo
06:19:25 <AHTOH> but soesnt that itrate cosumes n*(size x) space>
06:19:36 <AHTOH> if x is 10-20mb size
06:19:51 <dcoutts> chessguy: see also http://hackage.haskell.org/trac/hackage/ticket/58
06:19:52 <lambdabot> Title: #58 (darcs integration idea: track location of darcs repo, create new repo) - Ha ...
06:20:13 <wli> I'm having a tough time with the concurrency actually.
06:20:17 <dons> zbrown: what kind of `erlang-like concurrency' (its unclear what particular features are meant)
06:20:19 <dcoutts> @seen SyntaxNinja
06:20:19 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs, #haskell-blah and #haskell-soc 12h 58m 53s ago, and .
06:20:20 <roconnor> AHTOH: I would presume that the intermedate results are garbage collected if you don't keep a hold onto the original list.
06:20:41 <zbrown> dons: just the ability to scale to such a level as erlang with as much as ease
06:20:52 <zbrown> dons: mainly I just really like erlang's syntax for concurrency
06:20:52 <roconnor> AHTOH: that being said I wish there was a function in the prelude to do it without making a list.
06:21:19 <LoganCapaldo> Why is fix in Control.Monad.Fix and not for instance in Control.Fix?
06:21:37 <LoganCapaldo> it doesn't seem to require monadness
06:21:43 <dons> oh, scalability and syntax? scalability could be better tested in ghc, but no one's reporting problems. syntax is another question: what kind of syntactic nicieties?
06:22:00 <zbrown> dons: "Pid ! Msg"
06:22:06 <zbrown> dons: register a pid
06:22:09 <zbrown> dons: things of that sort
06:22:13 <dons> (the recent epoll threads lib with their 10M threaded server was a good scaling exapmle)
06:22:21 <dons> mmm. yes.
06:22:50 <dons> someone with knowledge of what they want needs to just sit down and code up the abstractions
06:22:53 <zbrown> dons: Though I will always have one qualm with writing certain apps using haskell due to unpredictable performance... though that can be fixed with the strict syntax
06:23:12 <zbrown> dons: well my haskell-fu is very weak, but once my haskell-fu is up to snuff, maybe i'll do it :)
06:23:22 <zbrown> by very weak, i mean almost non-existant
06:23:32 <dons> yeah, the unpredictability is interesting: would'nt erlang have similar issues (and worse, being hard to compile?)
06:23:57 <chessguy> dcoutts, hmm. i really don't know what i'm doing with this. i think i better leave it to someone else
06:23:59 <zbrown> dons: well erlang is easier since its not a lazy language, or at least not as far as i know
06:24:23 <zbrown> dons: the main thing is realizing that you are/aren't writing your concurrency structures correclty
06:24:24 <roconnor> dons: aren't you understating the unpredicability of haskells memory use?
06:24:26 <dons> oh, you just mean laziness causing funny business, yeah. pretty obvious when it goes wrong.
06:24:50 <roconnor> :)
06:24:53 <dons> roconnor: I just don't seem to have hard problems with laziness and memory use. maybe i write funny haskell
06:24:54 <dcoutts> chessguy: so what would help you to know where you're going? I'm just writing an email about making cabal hacking more assessable...
06:24:59 <zbrown> dons: If one's not paying attention in erlang when writing their concurrency structures, its very easy to serialize a concurrent process.
06:25:12 <chessguy> meh, i don't even really know what cabal is
06:25:29 <chessguy> something for packaging stuff
06:25:31 <roconnor> dons: Well, I to have gotten a pretty good handle on predicting memory use, but it is very very unstable.
06:25:55 <dons> really? hmm. I wonder what people are doing that it appears unstable
06:26:07 <zbrown> dons: compiling to native is helped somewhat with hipe, I still don't get the speed I could get in haskell for certain things but if you write your code properly that can be overcome with scalability
06:26:07 <dons> i either get really obvious bad memory behaviour, or perfectly acceptable use
06:26:18 <dcoutts> chessguy: right, it's like autoconf/automake is for C things, but for Haskell and it does more for you automatically.
06:26:23 <zbrown> hipe beign High Perfromance Erlang
06:26:34 <roconnor> http://r6.ca/blog/20060707T184300Z.html
06:26:35 <lambdabot> Title: Lazy vs. Strict
06:26:46 <roconnor> dons: okay, that's true
06:26:52 <chessguy> i've never even really used those for C :)
06:27:00 <dons> and since bad behaviour is *so* obvious, its easy to fix.
06:27:18 <dons> its just not obvious why something is bad to a new haskeller, trying to understand laziness and recursion
06:27:22 <dons> but that's a beginner issue
06:27:51 <roconnor> dons: I'd go as far as saying it is an intermediate issue too.
06:27:54 <zbrown> hehe, tail recursion ftw
06:28:16 <chessguy> dons, that's like saying "nuclear physics is hard, but only if you're new to it"
06:28:33 <dons> not really.
06:29:47 <roconnor> ``I was browsing the FIPS 180-2 definition of SHA, and one of the examples they give is the hash of 1 000 000 as. I thought this would be a great example of laziness in Haskell. (replicate 1000000 'a') acts as a lazy producer of 'a's, and sha1 from the crypto library acts as a consumer. sha1 (replicate 1000000 'a') should run beautifully in constant space. But that isnâ€™t what happened.
06:29:54 <dons> i quite like this, btw: http://babelfish.altavista.com/babelfish/trurl_pagecontent?lp=ru_en&url=http%3A%2F%2Fdrgr.livejournal.com%2F290819.html
06:29:56 <roconnor> ``
06:29:56 <roconnor> Prelude Data.Digest.SHA1Aux> sha1 (replicate 1000000 'a')
06:29:56 <roconnor> "*** Exception: stack overflow
06:29:58 <lambdabot> Title: drgr: XMonad and friends, http://tinyurl.com/33q5lc
06:30:09 <dons> `generally suspiciously I relate to any softu, written in the "exotic" languages of programming. Usually either brake is obtained or memory gorges much, or even any unpleasant deficiency. But here everything is written on the fashionable nowadays Haskell, very rapidly and memory it does not gorge'
06:30:23 <dons> :) "memory it does not gorge"
06:30:57 <dons> that guy wins a prizze for the coolest hat too
06:31:15 <chessguy> what in the world? is that yoda-speak?
06:31:33 <roconnor> ``Horseradish there, the same brake, although with a smaller quantity of svistelok
06:31:39 <dons> heh
06:32:05 <wli> ugh where's iterateM?
06:32:17 <LoganCapaldo> @index iterateM
06:32:17 <lambdabot> bzzt
06:32:22 <LoganCapaldo> it's in bzzt
06:32:25 <LoganCapaldo> import bzzt
06:32:26 <LoganCapaldo> :)
06:32:34 <chessguy> @hoogle iterateM
06:32:35 <lambdabot> No matches found
06:32:37 <LoganCapaldo> Oh man
06:32:43 <roconnor> @type (sequence .). iterate
06:32:45 <wli> It doesn't exist; I'm saying it should.
06:32:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a -> m a) -> m a -> m [a]
06:32:52 <dons> `And by this they are occupied, glory to Simons'
06:32:56 <roconnor> hmmm
06:33:08 <LoganCapaldo> the missing prelude thingy project should name its module file to Bzzt
06:33:13 <LoganCapaldo> that would be awesome
06:33:16 <dons> `ead a little thesis about House (glory to Swedish professors!).'
06:33:22 <LoganCapaldo> import Bzzt ( iterateM )
06:33:24 <dons> i love these babelfish russian translations
06:33:34 <wli> I need iterateM :: (a -> m a) -> m a -> m [a]
06:33:55 <roconnor> wli: I know.  I just took a stab in the dark.
06:34:02 <dons> glory to Simons! glory to Swedish professors!
06:34:05 <ksandstr> wait. was I just trolled? what's on the right side of >>= in a state monad if on the left you have iterateM?
06:34:27 <wli> ksandstr: I have no idea what you're asking.
06:35:12 <Cale> wli: which monad is that for?
06:35:19 <wli> Cale: MonadError
06:35:39 <apfelmus> iterateM yields a bottomless pit of bottoms!
06:35:46 <ksandstr> wli: neither do I, but I suspect this iterateM would imply something about monads that frightens me
06:36:24 <roconnor> wli: why not just use forever?
06:36:26 <ksandstr> sort of like "mdo"
06:36:37 <Cale> Well, it at least would work with Reader
06:36:52 <wli> @hoogle forever
06:36:52 <lambdabot> No matches found
06:37:04 <Cale> I don't think it would usefully work with Either.
06:37:07 <wli> That's why.
06:37:15 <Cale> @index forever
06:37:16 <lambdabot> bzzt
06:37:18 <roconnor> forever m = fix (m >>)
06:37:20 <Cale> @type forever
06:37:22 <lambdabot> Not in scope: `forever'
06:37:24 <Cale> huh
06:37:27 <ksandstr> oh right, it'd stop on first failure, right? silly me, thinking stuff in a monad was anything like stuff outside it
06:37:34 <Cale> Maybe it's not in there yet.
06:37:56 <chessguy> that's the same as forever m = m >> forever m, right?
06:38:16 <Cale> chessguy: yeah
06:38:17 <dons> ?pl forever m = m >> forever m
06:38:17 <lambdabot> forever = fix (ap (>>))
06:38:17 <wli> I can't ignore the previous results.
06:38:22 <roconnor> @unpl forever m = fix (m >>)
06:38:22 <lambdabot> forever m = fix (\ a -> m >> a)
06:38:25 <chessguy> @type ?m >> ?forever ?m
06:38:27 <lambdabot> forall (m :: * -> *) a b. (Monad m, ?forever::m a -> m b, ?m::m a) => m b
06:38:42 <dons> have i mentioned that I think that's a great trick, chessguy ?
06:38:56 <chessguy> dons, what's that?
06:39:08 <wli> let iterateM f x = do { y <- f x ; ys <- iterateM f y ; return $ y : ys } in iterateM :: forall t (m :: * -> *). (Monad m) => (t -> m t) -> t -> m [t]
06:39:16 <Cale> Yeah, that trick almost makes it worth leaving implicit parameters in :)
06:39:18 <dons> using implicit parameters to get both more type info, and cheap lambdas, in inline text
06:39:31 <chessguy> ah
06:39:36 <Cale> (even if we never used implicit parameters for anything else)
06:39:39 <chessguy> i like it :)
06:39:56 <roconnor> wli: but if you are using monad error, either you will never return, or you will return an error and never get the resulting list.
06:40:01 <roconnor> I think
06:40:25 <chessguy> i'm not sure what you mean by cheap lambdas, though
06:40:25 <wli> I'm not entirely sure. I have no idea, really.
06:40:35 <Cale> wli: In most monads, that's an infinite loop.
06:40:43 <dons> :t ?foo (putChar ?x) (putChar ?y)
06:40:45 <lambdabot> forall t. (?foo::IO () -> IO () -> t, ?x::Char, ?y::Char) => t
06:40:53 <dons> Cale, yeah, its like a fun query syntax for the type checker
06:40:56 <wli> Yeah, I know it's wrong. I'm still trying to figure it out.
06:41:18 <Cale> wli: add a termination condition and you'd be okay
06:41:23 <dons> "please infer types for all these things, and show them to me -- no, i don't want to write programs this way"
06:42:19 <dons> I suspect this trick is only known here in #haskell
06:42:27 <dons> though i'm a bit scared to publicise it more widely
06:43:04 <chessguy> it works in ghci, right? what other REPLs does it work on?
06:43:24 <dons> just ghci, since nothing else supports implicit params, afaik
06:43:28 <chessguy> oh, never mind
06:43:29 <chessguy> Prelude> :t ?foo (putChar ?x) (putChar ?y)
06:43:29 <chessguy> <interactive>:1:0: parse error on input `?'
06:43:48 <dons> and no real programs are written with them -- they're impossible to grok when you've got fake globls appearing all over
06:44:12 <chessguy> dons, no, i'd never use them in real program
06:44:12 <chessguy> s
06:44:22 <dons> i've tried to understand code written with lots of implicit parameters -- its like C -- you constantly have to work out where things are bound, who uses them. scary stuff
06:44:49 <dons> yeah, so we should disable the use of them as anything other than query syntax for the type checker :)
06:45:08 <chessguy> i'd vote for that poposal
06:45:31 <apfelmus> hey, that's a cool trick!
06:45:48 <apfelmus> i guess it makes debugging type checking errors a lot easier
06:45:59 <xerox> chessguy: :set -fimplicit-params
06:46:09 <dons> apfelmus: cute, isn't it. I wonder who invented it?
06:46:12 * dons checks the logs
06:46:24 <xerox> dons: it was sorear
06:46:34 <dons> ah , sounds likely :)
06:46:37 <dons> he's a bit of a pirate
06:46:48 <xerox> @arr
06:46:49 <lambdabot> Yeh scurvy dog...
06:48:48 <dons> 06.02.01:03:45:19 <vincenz> @type \x -> let ?x = x in ?x
06:49:00 <dons> 06.11.26:11:28:19 <alexj__> @type g x y = let ?f = \x-> x in ?f x ++ (show (?f y))
06:49:16 <dons> 07.02.25:17:12:33 <sorear> @type \show -> putStr (show ?a)
06:49:18 <xerox> !
06:49:28 <dons> so yes, i think sorear though was the person who recognised the utility
06:49:35 <xerox> ?type \x -> let ?x = x in ?x
06:49:37 <lambdabot> forall t. t -> t
06:49:43 <dons> 07.02.25:19:30:05 <sorear> @type \show -> putStr (show ?a) -- I used slightly over 2:15 ago in response to LoganCapaldo's challenge
06:49:46 <dons> 07.02.28:19:53:03 <sorear> @type ?evil
06:50:00 <xerox> hehe.
06:50:03 <dons> @type ?evil
06:50:05 <lambdabot> forall t. (?evil::t) => t
06:50:06 <xerox> t!
06:50:17 <dons> @type forM [1..?n] (\_ -> getLine)
06:50:18 <lambdabot> Not in scope: `..?'
06:50:18 <lambdabot>  
06:50:18 <lambdabot> <interactive>:1:10: Not in scope: `n'
06:50:30 <dons> @type Cont ($ ?x)
06:50:32 <lambdabot> forall a r. (?x::a) => Cont r a
06:50:45 <xerox> @type forM [1 .. ?n] (\_ -> getLine)
06:50:47 <lambdabot> (?n::Integer) => IO [String]
06:50:47 <dons> @type Cont ($ ?x)
06:50:48 <dons> 07.03.17:17:10:30 <sorear> yshhq: @type doesn't invent types for variables, unless you tell it to with ?
06:50:49 <lambdabot> forall a r. (?x::a) => Cont r a
06:51:04 <dons> so looks like we can thank our young prodigy sorear for this idea.
06:52:08 <dons> 17:09:47 <LoganCapaldo> @type \show -> putStr (show a)
06:52:08 <dons> 17:09:49 <lambdabot> Not in scope: `a'
06:52:08 <dons> 17:10:37 <LoganCapaldo> sometimes I wish it would just make something up :)
06:52:17 <dons> 17:12:33 <sorear> @type \show -> putStr (show ?a)
06:52:17 <dons> 17:12:35 <lambdabot> forall t. (?a::t) => (t -> String) -> IO ()
06:52:17 <dons> 17:12:39 <LoganCapaldo> OMG
06:52:17 <dons> 17:12:41 <mauke> aieee
06:52:17 <dons> 17:12:46 <LoganCapaldo> @karma+ sorear
06:52:23 <dons> is how it appeared. cute.
06:52:29 <xerox> haha :)
06:53:51 <chessguy> @karma+ sorear
06:53:51 <lambdabot> sorear's karma raised to 1.
06:54:06 <Cale> http://cale.yi.org/autoshare/Screenshot-reddit.png -- what my "new" page on reddit looks like :)
06:54:14 <mux> what the hell is this about? *scratches head*
06:54:34 <dons> :( :)
06:54:58 <dons> the other more theory-oriented crowds don't produce enough content
06:55:10 <mux> I can't make any sense of those ?
06:55:16 <Cale> http://cale.yi.org/autoshare/Screenshot-reddit-2.png -- scrolled down a little
06:55:17 <dons> mux, implicit parameters
06:55:24 <mux> is this haskell' material?
06:55:24 <apfelmus> hahaha, lucky me, yuppie
06:55:25 <Cale> Might as well call it donsit
06:55:31 <Cale> :)
06:55:43 <chessguy> mux, implicit parameters let you do stuff like this:
06:55:44 <chessguy> @type (map . ?f) ?foo (?x:?xs)
06:55:46 <lambdabot> Not in scope: data constructor `:?'
06:55:46 <lambdabot>  
06:55:46 <lambdabot> <interactive>:1:21: Not in scope: `xs'
06:55:54 <chessguy> @type (map . ?f) ?foo (?x : ?xs)
06:55:56 <lambdabot> forall a b a1. (?f::a1 -> a -> b, ?foo::a1, ?x::a, ?xs::[a]) => [b]
06:56:05 <dons> Cale, oh, what's that red stuff on my name?
06:56:07 <Cale> ah, I should add martinbishop to my friends list :)
06:56:09 <mux> I don't get it :)
06:56:13 <Cale> dons: You're in my friends list
06:56:14 <chessguy> mux, and it works out the types of the things with ?'s
06:56:16 <apfelmus> > let rollDie :: StdGen -> (Int,StdGen); rollDie = randomR (1,6) in map (fst . rollDie . mkStdGen) [1..]
06:56:18 <lambdabot>  [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6...
06:56:19 <dons> ah ok . i should use that
06:56:34 <apfelmus> hurray, I'm a 6-roller!
06:56:41 <chessguy> mux, in this case, the ? just means "i don't know what the type of this should be, you figure it out!"
06:56:42 <dons> heh
06:56:56 <LoganCapaldo> @typ mkStdGen
06:56:58 <lambdabot> Int -> StdGen
06:57:07 <wli> Type wildcards are handy.
06:57:18 <matthew-_> why?
06:57:28 <matthew-_> why is it different from polymorphism?
06:57:30 <xerox> > unfoldr (Just . randomR (1,6)) (mkStdGen 31337) -- %-)
06:57:31 <lambdabot>  [6,6,2,3,6,4,1,1,3,6,2,3,3,4,4,2,6,4,2,2,6,6,3,4,6,6,5,4,2,3,6,3,1,3,3,3,1,6...
06:57:39 <mux> chessguy: if you've got anyother example where it's useful I'm all ear
06:57:43 <mux> ears, rather
06:57:44 * matthew-_ hasn't read up any of this stuff on implicit params...
06:57:56 <wli> matthew-: It's just specifying that a type should unify with a pattern you've given as I conceive of it.
06:57:57 <LoganCapaldo> @localtime lambdabot
06:57:57 <lambdabot> I live on the internet, do you expect me to have a local time?
06:58:00 <LoganCapaldo> drat
06:58:26 * Cale turns his minimum font size back up to 12pt in Firefox :)
06:58:29 <chessguy> @type ?m >> ?forever ?m
06:58:31 <lambdabot> forall (m :: * -> *) a b. (Monad m, ?forever::m a -> m b, ?m::m a) => m b
06:58:54 <LoganCapaldo> I was hoping to do some elaborate chain of @. and @run and @localtime to get a time-based seed into a pure mkStdGen :)
06:59:02 <chessguy> this is what started the whole discussion :)
06:59:25 <mux> chessguy: I can only understand this being useful for debugging
06:59:30 <mux> yet
06:59:35 <matthew-_> so ?m >> ?forever ?m is equivalent to \m forever ->  (m >> forever m)
06:59:37 <matthew-_> ?
06:59:40 <taruti> Is there a way to generate types at runtime? I have monadic parsing code and would like to have a new type for each variable encountered, but this seems quite hard.
06:59:46 <matthew-_> would you ever use this stuff in a real program?
07:00:14 <chessguy> mux, yeah, debugging and if you almost remember a type, but not quite, or you don't know what any types are supposed to be in an expression
07:00:16 <dons> taruti: very hard I think -- you don't really want new types, since that would need a type checker, and code to process those types
07:00:19 <xerox> matthew-_: yes
07:00:21 <wli> matthew-: I would only use it to partially specify types.
07:00:28 <dons> matthew-_: no way. they're really hard to understand in real programs
07:00:45 <dons> since you basically don't have scope information about ?vars
07:00:49 <chessguy> mux, probably if you've got a little more experience, it's not as useful, because you can look at it and just know what it should be
07:00:57 <dons> we tried it in lambdabot, and its a nightmare
07:01:03 <taruti> dons: new types is ok, since they are wrapped inside GADTs and existentials and outside code does not need to see them. Just need them for type-indexed lookups.
07:01:22 <dons> oh hmm. maybe lookup a symbol table using Dyamic?
07:01:22 <wli> matthew-: Basically as a sort of aid to pinning down types for explicit type annotations.
07:01:41 <mux> okay, that makes sense now
07:01:47 <matthew-_> right, so if they're that useful I'll not bother learning them then ;-P
07:01:54 <mux> I thought this had some other real-world usefulness that I couldn't get
07:01:55 <dons> yeah, so we need to distinguish implicit parameters from the very cute use of them to query the type checker
07:02:36 <dons> they're actually supposed to be for threading pseudo-globals down deep into code -- what most people use State or StateT for
07:02:42 <wli> I'm very much opposed to implicit parameters.
07:02:45 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#implicit-parameters
07:02:47 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
07:02:56 <taruti> dons: the types are not real in any way, just defined like "data Zero; newtype N t = N t; next t = N t" etc
07:03:09 <dons> `However, by a simple extension to the type class system of Haskell, we can support dynamic binding.'
07:03:23 <matthew-_> wli: so it seems I'm in lots of "opposed to" clubs: floating point numbers, (x+1) pattern matches, and now maybe implicit params too
07:03:24 <dons> taruti: you'll have to generate values that represent types
07:03:34 <chessguy> ok, time for me to get to hacking. i've been looking forward to this all week
07:04:44 <Cale> matthew-_: What would you use instead of floating point numbers? Some exact real representation?
07:05:10 <chessguy> by the way, if anyone has suggestions for simplifying/clarifying this code, i'd love to hear it: http://hpaste.org/2058
07:05:10 <dons> Ratio Peano Peano ? :)
07:05:12 <Cale> It would be nice to have arbitrary precision floating point, at least.
07:05:23 <wli> Cale: I think it's been written.
07:05:29 <taruti> hmm. and with wrapping those behind an existential it could perhaps work
07:05:41 <wli> chessgy: Nice.
07:05:55 <dons> taruti: someone recently used a similar trick, for a parsing/xml problem
07:05:59 <matthew-_> Cale: exact real representation
07:06:03 <Cale> (i.e. one which stored precision information in with the numeric data, and did the right thing to maintain it)
07:06:06 <dons> existentials in a symbol table, keyed by a string
07:06:15 <matthew-_> Cale: yeah, that sounds good
07:06:42 <matthew-_> Cale: although frankly, I think I'm actually opposed to any non-integers
07:06:48 <Cale> Things like 'pi' etc. would need some work.
07:07:03 <matthew-_> yeah, I'm not sure that's necessary
07:07:10 <wli> Cale: I'm not entirely sure how arbitrary-precision floating point is supposed to work, e.g. how it might dynamically adjust its precision or if it's supposed to be manually adjusted or what.
07:07:25 <matthew-_> > 1.1 + 2.2 == 3.3
07:07:27 <lambdabot>  False
07:07:36 <wli> Cale: The math library page OTOH seems to have such things.
07:07:40 <Cale> Heh, perhaps that's a good application for implicit parameters actually :)
07:07:44 <wli> matthew-: You want BCD floating point?
07:08:08 <Cale> Explicitly passing information about desired precision really *is* a pain.
07:08:19 <LoganCapaldo> Cale, Reader?
07:08:27 <wli> Cale: Reader monad?
07:08:34 <Cale> Yeah, that's also hideous.
07:08:43 <matthew-_> lowering the learning curve of haskell eh?
07:08:57 <xerox> chessguy: what is the point of that code?
07:09:19 <chessguy> xerox, i'd like to build up a pattern-based AI for tic-tac-toe
07:09:49 <wli> http://www.n-heptane.com/nhlab/repos/Decimal/
07:09:49 <xerox> chessguy: I mean, the parser never returns anything. (?)
07:09:50 <lambdabot> Title: Index of /nhlab/repos/Decimal
07:09:52 <matthew-_> Cale: maybe it would be ok if you couldn't pattern match any floating points and floating points weren't in Eq or Ord
07:10:16 <chessguy> xerox, right, at the moment it doesn
07:10:16 <chessguy> 't
07:10:33 <chessguy> but it recognizes whether or not that pattern is found
07:10:48 <wli> http://darcs.augustsson.net/Darcs/CReal/
07:10:50 <lambdabot> Title: Index of /Darcs/CReal
07:10:52 <dons> > 1.1 + 2.2 == 3.3 :: Rational
07:10:53 <lambdabot>  Couldn't match expected type `Rational'
07:11:02 <dons> > 1.1 + 2.2 == (3.3 :: Rational)
07:11:03 <lambdabot>  True
07:11:05 <Cale> matthew-_: well, pattern matching against floating points is retarded of course. I don't see what's wrong with them being in Ord.
07:11:09 <dons> :: should bind tighter
07:11:19 <LoganCapaldo> I was thinking about C++ style  traits the other day, is their Haskell code floating around out there that does a similar thing using type classes?
07:11:27 <LoganCapaldo> I suppose Bounded is an example of that
07:11:27 <wli> http://www.doc.ic.ac.uk/~ae/exact-computation/Haskell
07:11:43 <xerox> chessguy: ah, I see. But isn't tic-tac-toe pretty much hopeless? (:
07:11:51 <chessguy> xerox, hopeless?
07:11:56 <matthew-_> > (1.1 + 2.2) > 3.3
07:11:57 <lambdabot>  True
07:12:03 <matthew-_> floats shouldn't be in Ord ;)
07:12:04 <chessguy> in what sense?
07:12:17 <xerox> chessguy: No way to win.
07:12:22 <chessguy> oh, sure
07:12:22 <wli> I suppose I could always implement thins in radix 1 + i.
07:12:35 <chessguy> xerox, i'm prototyping an AI approach
07:12:48 <wli> s/thins/things/
07:13:23 <matthew-_> has anyone written a shapefile reader for haskell?
07:13:35 <matthew-_> I'm really not looking forward to implementing this stupid file format...
07:13:46 <chessguy> @go haskell shapefile
07:13:48 <lambdabot> http://www.webgis.com/terr_pages/OK/dem75/haskell.html
07:13:48 <lambdabot> Title: WebGIS - Free Terrain Data, USA, Oklahoma - HASKELL - GIS
07:13:59 <chessguy> lol
07:14:03 <chessguy> wrong kind of haskell :)
07:14:07 <zbrown> lol
07:14:11 <Cale> matthew-_: but it is greater than 3.3
07:14:19 <Cale> > (1.1 + 2.2)
07:14:21 <lambdabot>  3.3000000000000003
07:14:28 <matthew-_> Cale: err, right.
07:14:31 <matthew-_> but it isn't
07:14:41 <matthew-_> it's only bigger because floats suck
07:14:45 <Cale> 1.1 isn't exactly representable
07:14:48 <matthew-_> indeed
07:15:07 <matthew-_> but it is if you carry an int around for each column
07:15:15 <wli> Cale: That's what BCD floats are for.
07:16:01 <Cale> Binary Coded Decimal?
07:16:17 <mux> > fromFractional (11%10 + 22%10) :: Float
07:16:18 <lambdabot>   Not in scope: `fromFractional'
07:16:18 <Cale> That also suffers from the same problem.
07:16:23 <wli> Cale: Yes.
07:16:26 <Cale> (not exactly the same)
07:16:34 <Cale> But for example, consider 1/3
07:16:37 <mux> > fromIntegral (11%10 + 22%10) :: Float
07:16:38 <lambdabot>   add an instance declaration for (Integral (Ratio t))
07:16:38 <lambdabot>     In the expression:...
07:16:55 <wli> Cale: Well, any floating point literal is exactly representible, not necessarily the result of any expression.
07:17:13 <wli> Cale: For rational numbers there are, of course, easy answers.
07:17:13 <chessguy> xerox, so is there a better way to do that?
07:17:21 <Cale> Yeah, I suppose you get that much.
07:18:42 <Cale> I don't really mind floating point all that much. For the things that you'd actually use it for, it doesn't really do a bad job.
07:19:09 <wli> Cale: You could always try http://holomorphy.com/~wli/ContFrac.hs (based on someone else's work, with not really all that much in the way of modifications, really).
07:20:24 <Cale> Yeah, that sort of thing is pretty sane.
07:21:07 <wli> Not entirely.
07:21:15 <wli> There are nontrivial nontermination issues.
07:21:32 <Cale> Well, for comparison?
07:21:36 <Cale> Or for more than that?
07:21:53 <wli> Cale: When numbers exactly cancel to zero nontermination occurs.
07:22:54 <wli> I'm in panic mode hunting for the backing of a $1500 earring so bear with me.
07:23:14 <Cale> I suppose you could also represent arbitrary-precision floating point values as functions from desired precision to some floating point representation.
07:24:15 <zbrown> Hurray, recoding for an hour and the solution is slower than the previous one!
07:24:36 <Cale> You could also provide functions to locally boost precision that way, if you knew that you'd need extra in order to make some computation work properly.
07:25:35 <msouth> floats are never equal, just equal enough :)
07:25:40 <SamB_XP_> zbrown: I hope you still have the previous one
07:25:46 <SamB_XP_> msouth: yup!
07:26:01 <SamB_XP_> which can lead to speckling when you have coincident surfaces
07:26:06 <msouth> perhaps an easy way of expressing "equal enough" would be useful.
07:26:08 <zbrown> SamB_XP_: I do. But I'm bound and determined to get this one working since its truly concurrent, or will be and not pseudo-concurrent
07:26:22 <SamB_XP_> msouth: definately
07:26:33 <SamB_XP_> or, well, possibly
07:27:01 <SamB_XP_> zbrown: you have multicore then?
07:27:20 <zbrown> SamB_XP_: yup, though its not haskell i'm working
07:27:23 <SamB_XP_> or <insert SMP setup here>
07:27:33 <zbrown> in*
07:27:53 <nominolo> xerox: got my pm?
07:27:54 <SamB_XP_> zbrown: well a concurrent algorithm doesnt help much you only have one CPU with one core ;-)
07:28:07 <nominolo> xerox: i'm not sure it really works in my client
07:28:14 <Baughn> SamB_XP_: It does have the advantage of being future-proof
07:28:15 <zbrown> SamB_XP_: well its multi-core :)
07:28:22 <SamB_XP_> Baughn: true
07:28:27 <SamB_XP_> possibly
07:28:30 <nominolo> xerox: PMs, i mean
07:28:41 <zbrown> Its a ridiculously over-done solution to problem number 7 on projecteuler.net
07:28:44 <SamB_XP_> but it's hard to say for sure if you don't have a slice of future to try it on
07:29:09 * zbrown has 18 slices of future to try it on plus the laptop i have lol
07:29:19 <zbrown> well 18 diff multi-core boxen
07:29:24 <Baughn> Preferablt it should survive a full dunking, not just a mere slice
07:29:29 <SamB> hmm, I haven't done problem 7 yet
07:30:05 <zbrown> SamB: I wrote an erlang solution that i thought was concurrent, but it was serialized by a stupid mistake, so now i'm making it truly concurrent
07:30:31 <SamB> I've done problems 1-5, 8, 9, 11, 12, and 15
07:30:53 <SamB> and firefox has gone missing
07:31:04 <SamB> (i.e. crashed)
07:31:24 <SamB> (OOM killed?)
07:32:02 <zbrown> hrm
07:32:07 <zbrown> why is this code not working..
07:32:19 <SamB> you could ask #erlang
07:32:24 <SamB> (there is one, right?)
07:32:26 <zbrown> aha
07:32:27 <zbrown> found it
07:32:35 <zbrown> SamB: its mostly dead
07:32:40 <SamB> oh.
07:32:54 <zbrown> SamB: #haskell is the hub for all functional conversation as far as I'm concerned
07:33:00 <SamB> well in that case you could have found an appropriate pastebin and pasted it
07:33:03 <zbrown> though, I'm really just ranting since no one else is talking :)
07:33:17 <zbrown> SamB: I found the issue, I was improperly pattern matching a tuple ;)
07:33:23 <DRMacIver> That seems like a self fulfilling statement to me. :)
07:33:53 <zbrown> DRMacIver: which one ;)?
07:34:25 <DRMacIver> 16:31 < zbrown> SamB: #haskell is the hub for all functional conversation as far as I'm concerned
07:34:37 <zbrown> DRMacIver: hehe ;)
07:35:04 <SamB> zbrown: doesn't erlang tell you when you do that?
07:35:08 <zbrown> Actually it is somewhat disheartening that #erlang is as dead as it is considering its got a fairly large number of idlers, but I can only think of about 8 people that talk
07:35:28 <SamB> zbrown: did you try asking anything?
07:35:33 <zbrown> SamB: Erlang is dynamically  typed, I was asking for the lenght of a list, but the structure of the returned data was "{atom, List}"
07:35:42 <zbrown> SamB: yup, though I fixed the problem
07:35:42 <SamB> zbrown: oh.
07:35:50 <SamB> and how come you didn't get a traceback or something?
07:35:52 <zbrown> so I was always getting length = 2
07:36:00 <SamB> oh...
07:36:05 <zbrown> SamB: because technically there was no error, it was getting a length value
07:36:08 <SamB> I get it!
07:36:10 <zbrown> :)
07:36:20 <zbrown> lenght of tuple = 2, but I wanted length of list, which can change
07:36:35 <SamB> you said you were improperly pattern matching a tuple
07:36:37 <zbrown> hmmm and we still have a problem
07:36:54 <SamB> which Python definately throws an exception over
07:37:17 <zbrown> Yah I said "PrimeList = rpc(prime_serv, can_has_primes)", but it should've been "{PrimePid, PrimesList} = rpc(prime_serv, can_has_primes)"
07:37:28 <SamB> >>> (x, y) = (1, 2, 3)
07:37:28 <SamB> Traceback (most recent call last):
07:37:28 <SamB>   File "<stdin>", line 1, in ?
07:37:28 <SamB> ValueError: too many values to unpack
07:37:30 <LoganCapaldo> python has pattern matching? Or was that just a "typo" for erlang?
07:37:31 <zbrown> SamB: well rather I did a lack of pattern matching, woops
07:37:49 <SamB> zbrown: yeah, so I've figured out ;-)
07:38:00 <SamB> LoganCapaldo: it only has it for tuples
07:38:03 <zbrown> lolcats has invaded my code :(
07:38:05 <SamB> basically
07:38:12 <zbrown> "can_has_primes"
07:38:12 <zbrown> lol
07:38:32 <SamB> well apparantly you can use the same syntax to unpack a list
07:39:02 <zbrown> eh?
07:39:22 <SamB> "(x, y) = [1, 2]" works...
07:39:33 <zbrown> oh ok
07:39:34 * SamB is still talking about Python
07:39:40 <LoganCapaldo> SamB, oh
07:39:45 <zbrown> I thought you meant erlang
07:39:48 <LoganCapaldo> that so doesn't count :)
07:39:50 <zbrown> though you can do it in erlang too, though its a bit diff
07:39:51 <SamB> zbrown: sorry
07:39:53 <wli> That was a harrowing experience.
07:39:56 <SamB> LoganCapaldo: it's damn useful though
07:39:57 <LoganCapaldo> perl does that :)
07:40:03 <zbrown> [Num1, Num2, Num3 | RestOfList] = List.
07:40:05 <zbrown> :)
07:40:13 <LoganCapaldo> useful sure
07:40:26 <wli> I've never willingly dealt with Python. I never liked it.
07:40:31 <wli> zbrown: Prolog-derived.
07:40:34 <LoganCapaldo> but I was about to learn python on the basis of you saying it had pattern matching <g>
07:40:49 <LoganCapaldo> I woulda chucked all my ruby code :)
07:40:51 <SamB> LoganCapaldo: sorry!
07:41:01 <zbrown> wli: yes sir. Erlang is prolog derived and somewhat influenced by lisp as well
07:41:13 <SamB> python doesn't even have "switch" or "case" ;-)
07:41:20 <msouth> i'm in ur code, amuzin' ur maintainers
07:41:20 <zbrown> the first Erlang interpreter/compiler was written in prolo
07:41:46 <wli> *Decimal> (1.1 :: Decimal) + 2.2 == 3.3
07:41:46 <wli> True
07:41:57 <SamB> wli: lucky!
07:41:59 <Baughn> IIRC, = is actually commutative in erlang
07:42:06 <SamB> oh, no, wait
07:42:06 <wli> Get your BCD arithmetic right here: http://www.n-heptane.com/nhlab/repos/Decimal/
07:42:06 <lambdabot> Title: Index of /nhlab/repos/Decimal
07:42:08 <SamB> type annotation
07:42:15 <zbrown> Baughn: mmmm not quite
07:42:24 <SamB> wli: I want UTF-8 coded decimal
07:42:31 <msouth> lol
07:42:45 <Baughn> zbrown: I'm sure I said 2=x at some point. At least, I recall the lack of that feature in haskell slightly annoying me.
07:43:00 <SamB> actually, utf-8 coded decimal is identical to ASCII-coded decimal ;-)
07:43:05 <zbrown> Eshell V5.5.5  (abort with ^G)
07:43:05 <zbrown> 1> 2 = X.
07:43:05 <zbrown> ** 1: variable 'X' is unbound **
07:43:09 <zbrown> Baughn: ^^
07:43:33 <wli> Baugnn: Commutative pattern matching and repetition of pattern-bound variables are useful.
07:43:35 <zbrown> maybe in an older version, but not currently
07:43:39 <Baughn> zbrown: Is that the same thing, though? Does eshell allow you to reassign variables?
07:43:40 <LoganCapaldo> what about pred(X) :- 2 = X.
07:43:55 <LoganCapaldo> oh wait that was erlang
07:43:56 <LoganCapaldo> nvm
07:44:06 <Baughn> wli: It would be, yeah.
07:44:27 <zbrown> Baughn: reassign? Eshell responds identically to code written in a .erl file and compiled
07:44:41 <zbrown> compiled/interpreted, insert your favorite word to describe how the vm works
07:44:46 <Baughn> zbrown: I see.
07:45:05 <zbrown> i'll test to be sure though
07:46:26 <zbrown> Baughn: fails
07:46:43 <wli> Commutative pattern matching isn't terribly obvious.
07:47:20 <Baughn> I must have run into it /somewhere/, though, or I wouldn't be looking for it everywhere
07:47:21 <wli> case pattern of { pat1 -> ... ; pat2 -> ... }, where each of the patterns matches against the pattern of the scrutinee?
07:47:27 <zbrown> Baughn: http://paste.lisp.org/display/45597
07:48:25 <Baughn> wli: That sounds rather more useful than merely saying 2=x
07:48:44 <Baughn> zbrown: Well, that looks pretty definite. :/
07:49:18 <wli> I'd think you'd want special syntax like match pat1 against pat2 { ... } where the mutual scrutinees bind each others' variables in the unification, with equality constraints for repeated variables etc.
07:49:22 <zbrown> wli: that would be poor form for a case statement. You typically try to make those true/false statements
07:49:24 <SamB> okay, why doesn't :i (->) work...
07:49:44 <Baughn> case (2,x) of (2,3) -> x => 3...?
07:50:26 <wli> zbrown: That wasn't under serious consideration. There is merely an open question of where commutative pattern matching fits in.
07:50:52 <wli> zbrown: I proposed a fresh construct for it.
07:51:02 <zbrown> wli: ahhh ok
07:51:11 <zbrown> wli: i misunderstood :)
07:51:53 <wli> match pat1 against pat2 of { } was my proposal.
07:52:02 <wli> Where pat1 and pat2 are mutual scrutinees.
07:52:08 <zbrown> ya
07:52:55 <wli> The body wouldn't be like a case statement, though; it'd just be a plain expression.
07:53:25 <zbrown> ah ya
07:53:32 <zbrown> hmmm still more bugs
07:53:47 <wli> Maybe match pat1 against pat2 in expr
07:54:10 <zbrown> wli: when would this be ideal to use?
07:56:43 <wli> zbrown: oh, easy
07:58:09 <SamB> who has a really recent GHC 6.7 handy?
07:59:46 <wli> merge xs ys | match xs@(z:_) against ys@(z:_) = z : merge (tail xs) (tail ys) | ... etc.
08:00:04 <wli> (making up syntax as I go)
08:00:53 <zbrown> wli: intersting
08:01:16 <wli> That one's a bit contrived I suppose.
08:01:35 <SamB> wli: what's that supposed to mean?
08:01:43 <zbrown> stupid function_clause errors lol
08:01:55 <wli> SamB: The two occurrences of z are equal.
08:03:19 <wli> Basically to deal with the idiom case (val1, val2) of { (pat1, pat2) | x1 == x2 && y1 == y2 && z1 == z2 && ... -> }
08:04:21 <SamB> how about...
08:04:25 <dmwit> The difference being that then "z" would be compared with pattern matching, instead of (==).
08:04:29 <msouth> so [1,x,y,z] merged with [1, a,b,c] = 1: merge of x,y,z and a,b,c, with the ... part telling us what happens next if x != a, basically?
08:04:29 <dmwit> Which probably isn't what you really wanted.
08:04:47 <Cale> ahahaha
08:04:48 <SamB> | z1:_ <- xs, z2:_ <- ys, z1 == z2
08:04:53 <Cale> > (0:+0)**2
08:04:55 <lambdabot>  NaN :+ NaN
08:05:21 <SamB> what's :+ again?
08:05:27 <dmwit> + i *
08:05:29 <Cale> Complex comstructor
08:05:34 <Cale> constructor*
08:05:36 <SamB> that was my guess...
08:05:41 <wli> dmwit: I'm proposing a fresh syntactic construct that shoehorns in the (==)'s for repeated occurrences of the thing.
08:05:54 <SamB> > (1:+0) ** 2
08:05:56 <lambdabot>  1.0 :+ 0.0
08:06:00 <SamB> > (0:+1) ** 2
08:06:01 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
08:06:03 <Cale> Looks like a bug in the standard even.
08:06:07 <wli> Cale: Brilliant; complex floating point is broken.
08:06:12 <dmwit> wli: Oh.  That's *very* unclear; from "match" I would expect it to really do pattern matching.
08:06:18 <SamB> Cale: in the report?
08:06:23 <SamB> > 0 ** 2
08:06:25 <lambdabot>  0.0
08:06:50 <dmwit> :t (**)
08:06:52 <lambdabot> forall a. (Floating a) => a -> a -> a
08:06:53 <Cale> SamB: yeah
08:07:02 <wli> dmwit: It's supposed to do pattern matching also. The equality constraints are in addition to the pattern matching.
08:07:28 <_Nucleo> @src words
08:07:29 <lambdabot> words s = case dropWhile isSpace s of
08:07:29 <lambdabot>     "" -> []
08:07:29 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
08:07:29 <Cale> SamB: The Report defines a default implementation of x ** y as exp (log x * y), but this only really works for nonzero values.
08:07:30 <wli> dmwit: Vaguely like logic languages.
08:07:38 <SamB> Cale: oh, that's not a bug
08:07:48 <Cale> Oh, it is.
08:07:51 <SamB> is it?
08:07:52 <dmwit> wli: Do you compare the one "z" binding with the other "z" binding using pattern matches or using (==)?
08:07:55 <SamB> I thought they knew that
08:08:14 <SamB> I certainly noticed the last time I implemented the Floating class
08:08:18 <dmwit> wli: (In your above "merge" example.)
08:08:18 <wli> dmwit: Well, this is pure vapor, so I don't do anything, but that's what I'm proposing.
08:08:55 <wli> dmwit: There isn't a way to pattern match them against each other. Only equality makes sense.
08:09:12 <dmwit> wli: Sure there is.  They are of the same type.
08:09:17 <Cale> Complex implements log and exp correctly, but doesn't define (**) separately. It takes the default, which doesn't work for Complex.
08:09:34 <dmwit> wli: But anyway, I maintain that neither option is really right.
08:09:43 <Cale> It only works for Float and Double because of the way that floating point infinities are handled.
08:09:51 <wli> dmwit: Call it syntactic sugar for fresh variables z1, z2 and the additional constraint z1 == z2.
08:10:10 <roconnor> (0:+0)^2
08:10:14 <roconnor> > (0:+0)^2
08:10:15 <lambdabot>  0.0 :+ 0.0
08:10:38 <wli> dmwit: This is a quasi-proposal for a fresh syntactic construct intended explicitly to sugar and/or auto-generate the equality constraints on such things.
08:10:45 <aip> how can i make my own widget types in gtk2hs by subclassing from an existing widget?
08:11:07 <dmwit> wli: Yeah.  The problem I have is that (==) means something different than a complete pattern match, so using the term "match" connotes a wrong behavior to me.
08:11:43 <dcoutts> aip: actually that needs the latest darcs version of gtk2hs were we changed the widget class system to allow exactly that.
08:12:06 <wli> dmwit: It beats prologesquePatternMatch pat1 versus pat2 prologesque of ...
08:12:23 <Cale> aip: dcoutts would know
08:12:23 <dmwit> i.e. I could imagine a data type "newtype Set a = Set [a]" where you could have (Set 1:2:[]) and (Set 2:1:[]), so that (==) is true but they have different patterns.
08:13:25 <dcoutts> aip: in the darcs version of gtk2hs, the way you'd do it is to make your type an instance of WidgetClass and the other parent classes, like GObject. The only method you need is for GObjectClass which is toGObject :: YourType -> GObject
08:13:34 <dmwit> I think (merge xs@(x:xtail) ys@y:ytail | x == y = ... | otherwise = ) is much less ambiguous, and not so verbose.
08:13:54 <dmwit> s/so/terribly/
08:14:25 <wli> dmwit: That's a relatively contrived example. The ones where it matters are all nasty tree expressions.
08:18:42 <aip> dcoutts: cool, does this allow also other people to subclass my widget?
08:18:43 <dmwit> I'm gonna go right ahead and keep disagreeing with you. ;-)
08:19:45 <dcoutts> aip: no, that needs a bit more, that needs you to make a class with an upcast function and for you to write your functions using the class rather than the concrete type
08:19:55 <dcoutts> aip: so with a little more effort, yes.
08:20:35 <aip> dcoutts: ok nice. could OOHaskell help with any of this?
08:20:56 <dcoutts> aip: dunno really. I should write up an example of this for the gtk2hs dev blog
08:21:14 <aip> dcoutts: looking forward to such a blog post. what about template haskell for automatically generating all the boiler plate code?
08:21:44 <dcoutts> aip: usually making your things an instance of Widget is more important than allowing further subclassing, since subclassing isn't that common a technique in Haskell, we need it for GUIs since that's they style they're written in
08:22:01 <dcoutts> aip: it shouldn't be much code actually, like 5 lines or something
08:23:26 <aip> dcoutts: hm..... when will the next version of gtk2hs be released?
08:24:16 <wli> Cale: (0, 0) seems to need special-casing.
08:24:39 <dcoutts> aip: not for a while, we usually operation on a 6month cycle
08:24:52 <dcoutts> aip: but you can grab the darcs version it's not hard
08:25:01 <Cale> wli: yeah. Zero in general needs special casing. The only reason it doesn't with Float and Double is the way that it treats infinities.
08:25:03 <dcoutts> aip: or if it is, I can make you a tarball
08:25:39 <Cale> The default (**) should really include a zero equality test.
08:26:01 <aip> dcoutts: i'll monitor the gtk2hs blog and grab the darcs version when the example is available :)
08:26:09 <dcoutts> aip: ok :-)
08:26:35 <Cale> Or at least the implementation for Complex should do one.
08:28:09 <wli> Cale: Something like cexp (x, y) (u, v) = let (r, t) = polar (x :+ y) in if r /= 0 then let z = mkPolar (r**u * exp (negate $ v * t)) (t*u + v*log r) in (realPart z, imagPart z) else (0, 0)
08:28:26 * Botje_ stares
08:28:30 <Botje_> *woosh*
08:28:34 <wli> Cale: There's not much of a way to get around the logarithm.
08:28:45 <SamB> patents are sad :-(
08:29:00 <SamB> someone patented two primes in 1994 :-(
08:29:02 <Cale> wli: Oh, I'm not saying don't do the logarithm :)
08:29:22 <Cale> wli: Just test if the base is 0 before using the same formula we're currently using
08:29:33 <Baughn> SamB: Wouldn't that imply that any program capable of printing all the primes is in violation of the patent?
08:30:00 <wli> Cale: Well, it can be cut down to a multiplicative term in the argument.
08:30:04 <Cale> If it is 0, then just check to see if the exponent is 0 also, and if so, the result is 1, otherwise, 0
08:30:53 <wli> I could live with 0**0 being undefined, but anyhow.
08:31:02 <wli> I wonder how it implements sqrt...
08:31:51 <wli> (It should not be in terms of (**) if it's any good.)
08:33:29 <Cale> You really want 0**0 = 1, because in almost all cases when x and y are converging to 0, x**y is as well.
08:34:35 <dons> lovely, http://programming.reddit.com/info/2catz/comments
08:34:36 <lambdabot> Title: Developing programs and their proofs in Haskell with GADTs (reddit.com)
08:35:17 <dons> though we need to get some type family stuff into this
08:39:57 <wli> Speaking of type-level arithmetic, I'm still itching to somehow define primes atop Oleg's stuff.
08:40:59 <sambo357> nick bitchchecker
08:44:12 <augustss> howdy
08:45:09 <dons> heya augustss
08:46:19 <wli> The big issue is that there doesn't seem to be a way to say "not"
08:48:18 <dons> rl mentioned a few days ago that you could with type families, i should prod him to post some stuff to the mailing list
08:49:05 <augustss> wii: Not x = x -> Void
08:49:48 <xerox> ?djinn-env
08:49:48 <lambdabot> data () = ()
08:49:48 <lambdabot> data Either a b = Left a | Right b
08:49:48 <lambdabot> data Maybe a = Nothing | Just a
08:49:48 <lambdabot> data Bool = False | True
08:49:48 <lambdabot> data Void
08:49:50 <lambdabot> type Not x = x -> Void
08:49:52 <lambdabot> class Eq a where (==) :: a -> a -> Bool
08:49:54 <lambdabot> type Cont r a = (a -> r) -> r
08:50:04 <xerox> Err. Sorry.
08:50:24 <wli> augustss: Hmm. That doesn't seem to fit in well with Oleg's decimal encoding of type arithmetic.
08:51:04 <augustss> I'm not sure why Not would contradict encoding in decimal or any other way
08:51:40 <wli> Maybe I just don't see how to use it.
08:51:42 <augustss> But the Haskell type system isn't powerful enough to do interesting things anyway
08:52:15 <augustss> maybe I shouldn't say that.  You can do interesting things, but not as much as you could with better types
08:52:27 <wli> Actually I think you can get away with positivity.
08:53:22 <augustss> you mean define primes?
08:53:50 <augustss> you could say that the list of factors >1 is of length 1
08:53:50 <wli> augustss: Yeah, so Z/pZ can be defined in turn.
08:57:03 <augustss> sounds like a fun type system hack
08:57:27 <wli> augustss: It would be if I could even get started on it. :)
08:57:54 <augustss> write it in Prolog first
08:58:31 <dcoutts> augustss: finally fixed your cabal bug #127 btw
08:58:46 <augustss> which one was that?
08:58:57 <dcoutts> easy one :-)
08:58:58 <dcoutts> license:	AllRightsReserved
08:59:04 <augustss> ah, right :)
08:59:24 <augustss> that's the one we use at credit suisse :(
08:59:30 <dcoutts> aye
08:59:32 <dcoutts> so it'll probably complain if you try to upload one of those to hackage :-)
08:59:45 <dcoutts> but complaining if you just build one is a tad extreme :-)
09:00:02 <augustss> exactly
09:00:10 <augustss> even if a sympathise
09:01:42 <matthew-_> depends if the right to compile has been granted or not
09:03:18 <pgavin> hello
09:03:41 <aip> sup
09:04:14 <pgavin> nothin much... rough night last night, just waking up :)
09:05:21 <pgavin> just trying to get my gstreamer patch to compile again :)
09:05:27 <augustss> so you're gonna clear your brain with some Haskell
09:05:44 <pgavin> you could say that I suppose
09:06:03 <pejo> augustss, is the hbc available from chalmers related in any way to hbcc?
09:06:08 <pgavin> well, I had to take a break from this stuff for a couple weeks for school
09:06:45 <augustss> Ummm, not really.  hbcc was the new generation Haskell compiler I started, but never finished
09:07:09 <augustss> It was used as a basis for the pH compiler
09:20:59 <augustss> hbcc was actually finished enough that it could compile itself generating byte code that was interpreted
09:26:01 <AHTOH> Wow! i have found a Major Imp's Next Assignment story" in Endo DNA
09:28:03 <jfredett> hrm, schools going to be easy this semester
09:28:11 <jfredett> silly liberal arts requirements
09:38:44 <wli> augustss: I think for my purposes I can get away with a verification vs. an enumeration (basically everyone's going to know what prime p they're working with up-front, or otherwise don't care which).
09:38:56 <wli> augustss: And that much I have in Prolog.
09:39:00 <lament> what's the usual strategy for writing something like a videogame, with lots of objects, each with its own state, and perhaps multiple threads accessing that state?
09:39:43 <wli> augustss: Only I'm not entirely sure how to do the conditionals.
09:39:54 <tcr> Is there a better way to do `case foo of { Con1 _ _ -> True; Con2 _ _ _ -> True; ... ConN _ -> True; _ -> False }', e.g. ideally something like `oneOf Con1 Con2 ... ConN'
09:40:37 <wli> d(N,D) :- dd(N,N,D). dd(N,D,X) :- ( D =:= 1 -> X = 1 ; D > 1 -> K is D - 1, dd(N, K, Y), ( N mod D =:= 0 -> X is Y + 1 ; X is Y ) ). prime(P) :- d(P,2).
09:40:58 <wli> augustss: Count up the divisors etc.
09:42:59 <JFT> lament: do you mean ask for actual game development (done in C++) or for an hypothecial game coded in Haskell?
09:43:23 <lament> a hypothetical game coded in haskell
09:44:13 <JFT> lament: then I'll answer by a question.... Why would you want to share state...
09:44:35 <JFT> lament: multithread does not necessarily equate to sharing state
09:44:44 <mainland> lament: you might want to take a look at http://www.haskell.org/haskellwiki/Frag
09:44:45 <lambdabot> Title: Frag - HaskellWiki
09:45:37 <wli> augustss: I think that "=:=" should be "is"
09:46:42 <lament> mainland: thanks
09:46:45 <wli> I've implemented an extremely slow primality testing algorithm in Prolog. Hurrah.
09:47:00 <lament> JFT: actually i'm already stuck on the "lots of objects each with its own state" part.
09:47:29 <augustss> wii: you can use Prolog's built in arithmetic, it's not logical.  You need to use the same decimal encoding in Prolog as for the Haskell types
09:47:39 <JFT> lament: Then looking at Frag and in general in Arrows would be a good starting point.
09:48:00 <JFT> lament: Check the papers on FRP
09:48:09 <lament> ok thanks
09:48:12 <JFT> lament: lemme fetch the reference
09:48:23 <aip> lament: you have 2 choices: the haskell way with arrows and functional reactive programming, or the real way, with IO everywhere
09:48:47 <aip> lament: FRP is awesome, but i think more research is needed for it to be usable for a real world game
09:49:00 <DRMacIver> You might want to talk to matthew-_ about this.
09:49:18 <aip> for example, it's not clear how to do multiplayer networking with functional reactive programming. and even simple things like loading/saving games are open questions
09:49:20 <DRMacIver> I think he's done some game development in Haskell (with bits in C as I recall).
09:49:38 <JFT> lament: http://haskell.cs.yale.edu/yale/publications.html (FRP => Functional Reactive Programing)
09:49:39 <lambdabot> Title: Yale Haskell Group Publications
09:50:13 <JFT> aip: I aggree FRP is not mature yet
09:51:39 <JFT> Anybody got a good math library to recommend in Haskell with matrix, linear algebra etc? The one I've seen so far seems to be dead, with "latest" releases dating back to 2003...
09:51:57 <kilimanjaro> you could bind a LAPACK such as ATLAS
09:51:59 <msouth> maybe it's just complete and bug free?
09:52:00 <msouth> :)
09:52:05 <JFT> eh eh
09:52:13 <JFT> What are people using then?
09:52:24 <lament> aip: where would all the "objects" go in the "real way, with IO everywhere"?
09:52:26 <kilimanjaro> JFT, what are you working on?
09:52:26 <JFT> always reinventing the wheel? or is there a "standard"
09:52:39 <JFT> lament: IORef I'd think
09:52:40 <kilimanjaro> LAPACK is pretty much a standard
09:52:47 <aip> lament: IORef, or if you really want multithreading, then TVar
09:52:54 <JFT> kilimanjaro: in Haskell?
09:53:41 <kilimanjaro> well, you would use the FFI probably, I don't think there's any advantage to using a linear algebra library written in haskell
09:54:21 <araujo> morning
09:54:26 <JFT> I dont have too much experience using FFI
09:54:48 <JFT> and I need to have that librairie work in a Windows settings :(
09:54:49 <kilimanjaro> at the bottom there is BLAS, short for basic linear algebra subroutines, it's been in use in quite a few languages for a while now and there are a number of high performance implementations
09:55:08 <kilimanjaro> JFT, what are you trying to do?
09:55:26 <JFT> I'm writing a Procedural Generation tool at work
09:55:27 <wli> You shouldn't really try to reimplement that sort of thing yourself.
09:55:36 <kilimanjaro> if performance is an issue and you are doing big linear algebra problems you need to use third party stuff
09:55:38 <JFT> and I'm writing the parser front-end in Haskell
09:55:55 <kilimanjaro> JFT, procedural generation of what?
09:55:56 <JFT> in the short-term the generator will also be coded in Haskell
09:56:05 <wli> There are advantages to it being written in Haskell but you need to know what you're doing or else you'll get wrong answers esp. in corner cases.
09:56:07 <JFT> 3D Model
09:56:22 <kilimanjaro> ohh that's not so bad
09:56:34 <aip> lament: I have the beginnings of a simple 3D vertical shooter, using SDL and OpenGL
09:56:41 <kilimanjaro> 3d graphics really can suffice on just 4d matrices
09:56:41 <aip> lament: if you'd like to take a look
09:56:53 <kilimanjaro> things are a lot simpler and performance is less of an algorithm issue
09:57:01 <msouth> lament: (note that I'm a haskell newbie) you might see whether what they are doing in HAppS to maintain state, marshal, etc, while handling multiple incoming requests, would be of any use to you.
09:57:05 <lament> aip: what does it use?
09:57:09 <JFT> kilimanjaro: yes but it triggers the question of What do people use for math in Haskell :P
09:57:23 <wli> JFT: What don't they use it for?
09:57:24 <lament> (to address the problem of objects and their state)
09:57:50 <JFT> wli: I meant "which librairie to Haskellers use to do math?:
09:57:54 <aip> lament: it uses a purely functional data structure to maintain all of the state, and transforms it every frame
09:58:06 <lament> aip: wouldn't that be a little slow? :)
09:58:18 <JFT> kilimanjaro: The model will be relatively big (serveral thousands, 10 of thousands of vertices)
09:58:37 <aip> lament: it could potentially be slow, but i'm still getting 1500 frames per second
09:58:52 <_roconnor> oooh data parellel arrays!
09:58:57 <kilimanjaro> JFT, well I'm not saying performance doesnt matter, I just mean that for the matrix math side of things, there are a lot less concerns
09:59:04 <lament> aip: hee, i see
09:59:15 <aip> lament: keep in mind that even though the state is large, it doesn't have to be copied every frame, haskell will internally transform only the parts that change
09:59:29 <JFT> kilimanjaro: ok :)
09:59:41 <kilimanjaro> JFT, sorry I don'
09:59:53 <kilimanjaro> don't really know, but if you have any questions about writing your own I could probably help
09:59:57 <JFT> kilimanjaro: so in short there is no "standard" Haskell math librarie people just use FFI?
10:00:34 <JFT> kilimanjaro: I know enough to write myself a basic one, but I'd rather spent my time writing "new stuff" than reinventing the wheel ;)
10:00:37 <kilimanjaro> JFT, well, I don't think you necessarily need the FFI, I only mentioned it because when people talk about linear algebra problems... they can get pretty big and every little bit of performance in the library matters
10:00:45 <wli> JFT: people tend to write Haskell math libraries for higher-level things
10:01:09 <JFT> wli: That would explain the lack of standard wouldn't it :P
10:01:31 <wli> JFT: Stuff FFI code is written for that deals with simpler objects (mind you, this does not mean simple or easy algorithms) is out there.
10:01:42 <kilimanjaro> maybe I'll implement one, it would be a good opportunity to learn quickcheck
10:02:12 <JFT> kilimanjaro: So far, I was under the impression that the FFI was not working too well on Windows, and that GHC wasn't playing nice with C/C++ librairie compiled with Dev Studio, Am I wrong?
10:02:47 <kilimanjaro> JFT, I don't know. I actually avoid windows out of a preemptive fear of such problems :)
10:02:48 <hpaste>  chessguy annotated "parser for a column of x's/o's in a tic-tac-toe board" with "Much simpler, but not quite working" at http://hpaste.org/2058#a1
10:03:00 <wli> JFT: LAPACK, BLAS, GSL (Gnu Scientific Library), etc. all have bindings, for instance, and there are other "number crunching" libraries out there. Hell, ghc has arbitrary precision arithmetic FFI bindings to a C library, libgmp, that it literallyuses as its default integer type.
10:03:09 <JFT> kilimanjaro: Smart guy :) But my employer dont leave me a choice :(
10:03:40 <wli> JFT: You don't reinvent the wheel for these kinds of things because if/when you try you'll get it wrong.
10:03:50 <kilimanjaro> wli, he's not talking about that sort of stuff
10:03:57 <kilimanjaro> he's talking specifically about 3d math
10:04:00 <JFT> wli: Yes but these libraire for GHC have not been compiled with MS Dev Studio I guess
10:04:01 <Tac-Tics> the wheel is a tricky invention to get right
10:04:04 <kilimanjaro> which is easy to do right
10:04:19 <tcr> What's the name of the HOF that is equivalent to `\f x -> not (f x)' ?
10:04:24 <lament>  Tac-Tics :)
10:04:52 <JFT> Actually having a function Lanpack FFI working on Windows would probably solves all my potential need, but it's true I dont need all that power (at least not yet!)
10:04:54 <tcr> I.e. the equivalent to Common Lisp's COMPLEMENT
10:05:02 <wli> kilimanjaro: 3D math? The big name linear algebra routines are probably too heavyweight for that. Probably best to use specialized graphics libraries or some such.
10:05:16 <wli> tcr: @p \f x -> not (f x)
10:05:17 <kilimanjaro> yea
10:05:22 <wli> @pl \f x -> not (f x)
10:05:22 <lambdabot> (not .)
10:05:32 <tcr> ah of course! thanks wli
10:05:45 <wli> tcr: Thank lambdabot ;)
10:06:00 <kilimanjaro> the thing about 3d math is that all interesting transformations can be represented as a 4d matrix, if you are using single precision floating point that means you get 128 bits and can do it with SSE really quickly
10:06:07 <wli> JFT: You're not going to get a portable answer to this.
10:06:08 <xerox> chessguy_: maybe you need Text.ParserCombinators.Parsec.Perm
10:06:14 <tcr> wli: Not until it passes the Turing Test. :)
10:06:18 <JFT> wli: I was afraid to hear that :(
10:06:36 <JFT> wli: that's what my first investigation led me to think.
10:06:40 <hpaste>  (anonymous) annotated "parser for a column of x's/o's in a tic-tac-toe board" with "(no title)" at http://hpaste.org/2058#a2
10:06:45 <chessguy_> now it works
10:06:55 <chessguy_> xerox, maybe i do, but not for this case
10:06:59 <wli> JFT: These things are all tied up in graphics, which are all tied up in platform specifics for both graphics hardware and OS kernel.
10:07:01 <JFT> wli: I came to the realisation that if I didn't use gcc on windows the FFI stuff wouldn't "smile" on me and gcc is out of the picture
10:07:11 <JFT> wli: I"m not trying to draw stuff
10:07:20 <wli> JFT: Physics?
10:07:24 <JFT> wli: I need to generate and export model
10:07:40 <kilimanjaro> JFT, how urgent is this? Are you at work right now?
10:07:46 <JFT> wli: Else I'd use the GL like librairie that come with GHC that work well enough
10:07:51 <wli> JFT: Surface modelling. You're still screwed. It's all tied to graphics even though it's not really specific to it.
10:07:54 <JFT> kilimanjaro: no I'm not at work atm
10:08:13 <JFT> kilimanjaro: I'm trying to find a lib I can start to use back on monday (tuesday at the latest)
10:08:27 <JFT> wli: It's actually volume modelling
10:08:50 <JFT> wli: procedural volumen generation if you want
10:08:52 <wli> JFT: Well, not so much different (boundary vs. interior).
10:09:00 <kilimanjaro> i'm bored and it's not really as difficult as you think it is, i'm going to write one for GHC and see how well I can do
10:09:24 <wli> kilimanjaro: What's that? Surface modelling affairs?
10:09:33 <kilimanjaro> wli, no, just the math stuff he is asking for
10:09:49 <kilimanjaro> JFT, what do you need, specifically?
10:10:12 <kilimanjaro> wli, only because I actually was looking for something similar (casually, just out of curiosity) a few days ago
10:10:19 <wli> kilimanjaro: Oh, well, the hard part is probably the import/export in the particular file formats and getting it to interoperate with whatever he's sending it to.
10:10:19 <JFT> kilimanjaro: dont worry too much, again the math are not the issue here, I can write those too. But had a standard Haskell math library existed I would have like to use it and learn it.
10:10:32 <chessguy> ugh, i don't know how those extra functions got back in there
10:10:46 <kilimanjaro> wli, yea that's just tedium, I'm not gonna do that :)
10:10:47 <JFT> wli: file format is not an issue!!!
10:10:54 <ivant> JFT, there exists NumericPrelude which has lots of cool stuff in it
10:11:03 <JFT> wli: I'm actually using the output of the generator to produce Maxscript
10:11:09 <wli> JFT: Really? Lucky you.
10:11:13 <hpaste>  chessguy annotated "parser for a column of x's/o's in a tic-tac-toe board" with "This works as desired" at http://hpaste.org/2058#a3
10:11:16 <JFT> ivant: NumericPrelude!!!! where is this?
10:11:23 <kilimanjaro> JFT, otoh somebody mentioned frag, a quake 2 clone written in haskell
10:11:23 <ivant> @where NumericPrelude
10:11:23 <lambdabot> darcs.haskell.org/numericprelude/
10:11:35 <kilimanjaro> JFT, that certainly must have some sort of math library
10:11:36 <JFT> Thanks a lot! I'm going to check that out
10:11:38 <hpaste>  xerox annotated "parser for a column of x's/o's in a tic-tac-toe board" with "another idea" at http://hpaste.org/2058#a4
10:11:46 <ivant> JFT, however there are lots of things it doesn't have
10:12:05 <ivant> I use it a lot, but I had to implement multivariate polynomials myself
10:12:17 <ivant> although it is quite easy
10:12:18 <JFT> ivant: my need are pretty basic for now (mostly matrix stuff)
10:12:24 <wli> JFT: It's nicer from the POV of not being as massively screwed up wrt. the numerical hierarchy but it's not really a math library per se. It mostly fixes what's wrong with the numerical hierarchy.
10:12:39 <wli> JFT: There is very little matrix code in there.
10:12:42 <JFT> wli: Ok
10:12:42 <xerox> chessguy: row is wrong, it needs 3 anyChar before the recursive call, not just one, sorry.
10:12:49 <ivant> JFT, it'd be easy to add matrices there\
10:13:00 <dozer> can I get a hand making lhs2Tex work for me?
10:13:07 <wli> ivant: Yes, but it's not so easy to get it right.
10:13:10 <JFT> ivant: would using Array be a bad idea performancewise?
10:13:16 <chessguy> @hoogle getInput
10:13:17 <lambdabot> Text.ParserCombinators.Parsec.Prim.getInput :: GenParser tok st [tok]
10:13:17 <wli> ivant: API-wise, thatis.
10:13:19 <ivant> wli, true
10:13:22 * dozer is a tex noob
10:13:24 <ndm> @seen sorear
10:13:24 <lambdabot> I saw sorear leaving #haskell-soc, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 9h 56m 11s ago, and .
10:13:33 <ivant> JFT, depends on how you want to use your matrices
10:13:38 <hpaste>  xerox annotated "parser for a column of x's/o's in a tic-tac-toe board" with "bugfix" at http://hpaste.org/2058#a5
10:14:06 <chessguy> xerox, Input here is the un-consumed string?
10:14:07 <dozer> ! LaTeX Error: File `amstext.sty' not found.
10:14:12 <xerox> chessguy: yes
10:14:56 <JFT> ivant: to do affine transformation therefore process quite a bit of vertex against them
10:15:26 <chessguy> @src transpose
10:15:27 <lambdabot> transpose []             = []
10:15:27 <lambdabot> transpose ([]   : xss)   = transpose xss
10:15:27 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
10:15:56 <JFT> ivant: the generation stuff is quite hierarchical so lots of transformation done on the transfo matrix (and the typical stack of transform)
10:16:01 <ivant> JFT, well, again, it depends on whether you want lazy evaluation or always want your values to be strict (Array vs UArray)
10:16:26 <ivant> JFT, but using lists is probably a bad idea for implementing matrices
10:16:31 <chessguy> > transpose "123456"
10:16:33 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
10:16:52 <ivant> > transpose ["123","456"]
10:16:54 <lambdabot>  ["14","25","36"]
10:17:27 <chessguy> > transpose ["123","456","789"]
10:17:28 <lambdabot>  ["147","258","369"]
10:17:45 <ivant> oh, you can think of transpose as of an extended version of zip
10:18:10 <JFT> ivant: I'm kindda happy to here that about list, I haven't been hacking Haskell for long, so the performance/optimization of Haskell is still fuzzy in my head. But I had at least guessed that List would be bad.
10:18:15 <ivant> which zips arbitrary number of lists
10:18:17 <xerox> chessguy: err, yes, map return is not what I want.
10:18:31 <chessguy> xerox, yeah, i thought that looked weir
10:18:32 <chessguy> d
10:18:37 <JFT> ivant: it is just not clear from my POV when looking at the Array doc that it would be performant
10:19:45 <ivant> JFT, I never said it would :-) There are a lot of places where you can screw up with the performance, and the best thing to do is to find the good data structures for particular algorithms you are using
10:19:52 <dcoutts> ndm: eivuokko could probably do with discussing generating msi installers from cabal packages with you.
10:20:14 <chessguy> xerox, anyway, i think my version came out ok
10:20:18 <dcoutts> ndm: btw, I wonder what that Bool param is for, and how we'd ever find out :-)
10:20:23 <JFT> ivant: yeah :P and I would use it in a strict evaluation mode for what I'm doing anyway (if it does a difference)
10:20:29 <xerox> chessguy: I just thought column was replicating work :)
10:21:21 <chessguy> row, in my version, is just something like: upTo 2 anyRow >> count 3 (char p) >> many square
10:21:53 <ndm> dcoutts, the interface is wrong in the haddock, it actually returns IO (), which answers 1 question
10:21:53 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
10:21:59 <ivant> JFT, I'd suggest creating the data types and functions which operate on them in such a way that it could be easy to substitute other datastructures later, when you find which things make the biggest performance hit
10:22:01 <ndm> @messages
10:22:01 <lambdabot> SamB said 22h 59m 23s ago: hmm, I didn't fix Read right.
10:22:04 <dcoutts> ndm: that's what I said
10:22:12 <ivant> JFT, be sure to use type classes, that is
10:22:29 <dcoutts> ndm: it changed in the current version of cabal, the ExitCode is gone
10:22:38 <xerox> chessguy: what's count?
10:22:52 <JFT> ivant: I will Thx for the advice
10:22:58 <JFT> ivant: kilimanjaro: wli: Thanks a lot guys I'm going to check the leads you gave me :)
10:22:58 <ndm> dcoutts, yeah, i guess i can happily ignore the boolean, but was quite curious
10:23:02 <dcoutts> ndm: because nobody could do it correctly, there were exit codes being ignored all over the place
10:23:05 <dcoutts> ndm: yeah, me too
10:23:10 <chessguy> count :: Int -> Parser a -> Parser a
10:23:27 <ndm> dcoutts, i have no idea about generating MSI's, wouldn't generating .exe installers using the same thing as Gtk2hs work well enough?
10:23:44 <chessguy> from the parsec documentation: (count n p) parses n occurrences of p. If n is smaller or equal to zero, the parser equals to (return []). Returns a list of n values returned by p.
10:23:54 <ndm> dcoutts, plus does he want MSI's for libraries, or for applications?
10:23:54 <xerox> Nice!
10:24:01 <dcoutts> ndm: libs
10:24:04 <ndm> and can Gtk2hs apps be compiled with Cabal
10:24:13 <dcoutts> ndm: it would, generating scripts for a prog that generates msi is probably about the same as generating scripts for innosetup
10:24:15 <ndm> i thought about that, it seems a lot of work, and i can't see a compelling use case
10:24:29 <xerox> chessguy: it is -> Parser [a] right?
10:24:34 <dcoutts> ndm: to make it possible to package all the hackage packages as binary msi things
10:24:36 <chessguy> err, yes, sorry
10:24:40 * ndm laughs at dcoutts, for making assumptions that aren't remotely true, but aer entirely sensible
10:25:13 <ndm> dcoutts, what advantage is that over cabal-install?  if you are going to use the libraries, you must have the tools to build them
10:25:25 <dcoutts> ndm: yes, you can build apps that use gtk2hs with cabal, see himerge for example
10:25:25 <ndm> plus you'd need to get the .hi/.o versions to match, which would give headaches
10:25:37 <dcoutts> ndm: I dunno :-) ask eivuokko
10:25:42 <dcoutts> true
10:25:47 <apfelmus> help, I got struck by an idea I don't like
10:25:58 <dcoutts> ndm: but it'd also work for apps that use cabal
10:25:59 <ndm> i guess its handy for cabal libs with FFI lib dependencies
10:26:04 <dcoutts> and those
10:26:16 <dcoutts> though they have their own problems on windows
10:26:18 <ndm> i'd jump with InnoSetup, I did look at .msi stuff, and i cried
10:26:34 <apfelmus> http://caml.inria.fr/pub/ml-archives/caml-list/2007/07/9858139a356468fa638746aacf111682.en.html
10:26:36 <lambdabot> Title: Archives of the Caml mailing list > Message from oleg@p..., http://tinyurl.com/yvfhnf
10:26:47 <apfelmus> reports on an incident at the Haskell 2006 workshop
10:26:50 <dcoutts> ndm: nobody uses msi directly, everyone uses a program that takes a text file script and generates an msi
10:26:54 <apfelmus> "One participant stood up and sincerely proposed that Haskell' standard
10:26:54 <apfelmus> would find a way to automatically derive a monadic version of a pure
10:26:54 <apfelmus> expression"
10:27:08 <ndm> dcoutts, and i looked at several of those, and they all suck
10:27:16 <apfelmus> "Chung-chieh Shan recommended that person to take a look at OCaml"
10:27:21 <dcoutts> ndm: aye, I've never looked beyond innosetup
10:27:37 <apfelmus> does anybody remember that?
10:27:39 <SamB> ndm: obviously that message was far too late
10:27:46 <ndm> dcoutts, someone thought a verbose, poorly specified .xml file would be a good file format
10:27:46 <augustss> apfelmus: vaguely
10:27:54 <ndm> SamB, lol :)
10:28:20 <apfelmus> augustss: the idea that struck me is that this is not equivalent to OCaml!
10:28:34 <SamB> hmm.
10:28:57 <hpaste>  xerox annotated "parser for a column of x's/o's in a tic-tac-toe board" with "fixed" at http://hpaste.org/2058#a6
10:29:02 <xerox> chessguy: well, I think this works.
10:29:37 <xerox> chessguy: ah, sorry for the Parser String Bool instead of Parser Bool, my version of parsec is parametrized on the input Stream, you know :-)
10:29:40 <chessguy> anyChar >> anyChar >> anyChar === count 3 anyChar
10:29:57 <hpaste>  dozer pasted "lhs2TeX problem" at http://hpaste.org/2061
10:29:58 <ndm> SamB, am just writing your makefile into the Cabal setup.hs, so it can run with Cabal
10:30:10 <xerox> chessguy: oh sure. I'll stop adding annotation though
10:30:15 <chessguy> hehe
10:30:25 <SamB> my attempt to implement the sieve of atkin fails to find all primes up to 2^6 :-(
10:30:35 <SamB> ndm: will it be run after installation?
10:30:45 <chessguy> > split "123456"
10:30:46 <lambdabot>   add an instance declaration for (RandomGen [Char])
10:30:46 <lambdabot>     In the expression: s...
10:30:49 <SamB> because, as it stands, you have to install first and test after...
10:30:54 <chessguy> @hoogle split
10:30:54 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
10:30:54 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
10:30:54 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
10:30:59 <xerox> chessguy: it's in the where clause
10:31:05 <chessguy> oh, whoops
10:31:10 <ndm> SamB, i just copied your warning, its slightly more stupid than the makefile, just a first cut
10:31:11 <chessguy> i always fall for that
10:31:28 <xerox> chessguy: I like to defer the details to where clauses :)
10:31:41 <chessguy> xerox, sure, it's very idiomatic
10:31:42 <ndm> dcoutts, how is cabal test meant to function, i.e. does it require a build/install first? if not, where should it get the binary from?
10:31:44 <SamB> ndm: oh, right
10:31:49 <chessguy> xerox, my failing, not yours
10:32:04 <ndm> i'm not going to delete the makefile yet, so feel free to keep using/modifying that
10:32:19 <SamB> ndm: the Makefile is surely far easier to alter
10:32:41 <dcoutts> ndm: I've really no idea, I've never used it and never seen anyone else use it. I suggest you find out how it works, or read the documentation. Then send us your report for how we can make it useful.
10:32:54 <dcoutts> ndm: and a patch to do that and document it :-)
10:33:21 <xerox> chessguy: also I'm not sure the setInput xs should be there after p <- row, it depends on how you want the input after "column" has done its work.  Oh well.
10:33:25 <ndm> SamB, the Haskell is just a list of system calls :)
10:33:28 <SamB> ndm: anyway, for derive to work without being installed, you'd need to have a command-line flag for the derive executable saying where to find the library
10:33:42 <SamB> ndm: hmm.
10:34:09 <SamB> I guess that's about the same...
10:34:49 <kuribas> xerox: can you align <|> with try inside a do block?
10:35:07 <ndm> SamB, i think that is worth adding anyway, the command line flag
10:35:36 <xerox> kuribas: yes, it seems.
10:35:47 <SamB> I'm not sure what exactly the command line flag would have to do
10:36:25 <xerox> kuribas: I played around a bit to find that layout, I liked it better of everything else I could come up with, because the `do's are neatly aligned.
10:36:29 <SamB> but it would clearly have to tell GHC some way of finding the modules of the derive library
10:37:04 <ndm> SamB, easy, it just invokes ghc -e with -ipath
10:37:45 <SamB> so does derive actually have to require ghci support?
10:37:48 <kuribas> xerox: strange, I would think a ; would be inserted before <|>
10:37:48 <ndm> @seen iampure
10:37:48 <lambdabot> I haven't seen iampure.
10:38:07 <ndm> SamB, in theory, no, but currently it does
10:38:30 <ndm> anyone know who iampure is? or if he's in this channel? he seems to be reasonably upset with me...
10:38:38 <SamB> ndm: meaning you don't use "reify" anywhere but in the conventient TH splicing interface?
10:38:54 <SamB> s/convent/conven/
10:38:57 <augustss> ndm: maybe it's qwe1234 :)
10:39:00 <ndm> no idea, to be honest
10:39:06 <ndm> augustss: lol
10:39:22 <Korollary> for some reason I can't imagine him picking iampure as a handle
10:39:50 <SamB> ndm: since, you know, the Quasi IO doesn't implement reify
10:39:59 <apfelmus> augustss: for the monadic version of the Haskell code would be polymorphic in the monad in question. i.e. map ~> mapM :: forall m . Monad m => ... whereas OCaml would specialize to IO.
10:40:08 <xerox> kuribas: how's your emacs indenting thing coming along?
10:40:16 <apfelmus> or some other wicked built-in monad
10:40:24 <SamB> ndm: oh, isn't Q a cute hack btw?
10:40:30 <augustss> apfelmus: yep
10:40:39 <SamB> @src Q
10:40:40 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:40:44 <plutonas> / #conky
10:40:49 <plutonas> oops sorry
10:40:53 <plutonas> / #conky
10:40:59 <kuribas> xerox: I have almost completed my algorithm.
10:41:04 <ndm> SamB, i really can't remember how Q/IO work, they always seem to break randomly for me...
10:41:06 <plutonas> hm, strange
10:41:13 <SamB> ndm: hmm?
10:41:46 <ndm> SamB, i never understood Q/IO/TH/reify when combined, i just can't determine what works and what doesn't in advance
10:42:15 <ndm> @undo do b <- doesFileExist "foo"; when b (deleteFile "foo")
10:42:16 <lambdabot> doesFileExist "foo" >>= \ b -> when b (deleteFile "foo")
10:42:26 <ndm> doesFileExist "foo" >>= \ b -> when b (deleteFile "foo")
10:42:40 <ndm> @pl doesFileExist "foo" >>= \ b -> when b (deleteFile "foo")
10:42:40 <lambdabot> flip when (deleteFile "foo") =<< doesFileExist "foo"
10:42:55 <SamB> ndm: you can't use reify in code that you want to use "runQ :: Q a -> IO a" on
10:43:00 <SamB> that's all
10:43:09 <apfelmus> augustss: ok, thanks :) such a "feature" would give me creeps nonetheless
10:43:21 <ndm> is that really the shortest expression of a monadic when, without using (<- monad expressions)
10:43:58 <augustss> apfelmus: I think there could be a way to make such a featuer well defined, but I don't know how.
10:44:12 <SamB> newtype Q a = Q { unQ :: forall m. Quasi m => m a }
10:44:25 <SamB> hmm.
10:44:27 <LoganCapaldo> (deleteFile "foo") `when ` ((=<<) $ doesFileExist "foo") might be nice
10:44:40 <SamB> since when are you allowed to use existentials in newtypes?
10:44:52 <xerox> kuribas: sorry, do you receive my /msg ?
10:44:58 <SamB> oh, wait, that's not an existential is it
10:45:02 <apfelmus> augustss: maybe with applicative functors? so that every juxtaposition translates to <*>
10:45:19 <ndm> augustss, i read qwe1234 asking you if you'd ever used a functional language, you completely failed to mention that you had implemented half the languages in the list you gave
10:45:44 <monochrom> Where can I find a common definition of Bifunctor for Haskell?
10:45:58 <xerox> monochrom: is there in CatExt?
10:46:08 <xerox> ?where catext
10:46:08 <lambdabot> http://www.eyrie.org/~zednenem/2004/hsce/
10:46:12 <SamB> augustss: ... if you implemented half of those, why *weren't* you expecting to forget any of the ones you'd implemented?
10:46:32 <monochrom> Yes. Thanks.
10:47:21 <augustss> SamB: I've not implemented half, maybe a quarter. :)  But I think it was embarressing how many I had implemented that I forgot.
10:47:30 <SamB> ndm: okay, apparantly the Quasi IO instance doesn't implement reify, currentModule, or recover
10:47:40 <SamB> augustss: it was 2 or 3 wasn't it?
10:47:47 <wli> I've implemented primality goo in Prolog in a terrible way, am at a loss to do it in a better way, and am totally clueless as to how I can do anything with it in the type system.
10:48:30 <augustss> SamB: And I don't feel I need to give qwe1234 ll information at once.  He's so much fun as he is. :)
10:48:31 <ndm> SamB, i still don't get Quasi vs IO etc, but its done for now, so will take a look another time
10:48:39 <wli> I've moved on to bugfixing concurrency exercise code. ;)
10:49:32 <SamB> ndm: Q just stores a polymorphic computation in a Quasi
10:49:33 <augustss> SamB: I had left out 4 I have implemented
10:49:49 <SamB> ndm: (Quasi being a subclass of Monad)
10:50:43 <SamB> and implements Quasi (and all superclasses) as if by *real* newtype deriving
10:50:55 <chessguy> SamB, did you see how my implementation of column turned out?
10:51:06 <SamB> chessguy: not really
10:51:27 <augustss> apfelmus: Yes, I think applicative functors might be the way.  We need to be able to overload juxtaposition!
10:51:41 <chessguy> it wound up simplifying nicely: http://hpaste.org/2058#a3
10:52:32 <xerox> monochrom: it would be nice if catext was cabalized and on hackage, actually. If you find it useful you might do that?
10:52:41 <SamB> ndm: the clever hack bit, I suppose, is the part where the compiler doesn't have to expose any primitives besides the outer splice syntax
10:53:04 <monochrom> No, I'm just answering a question on haskell-cafe that uses Bifunctor.
10:53:34 <xerox> Ah, Conal's? I see.
10:53:46 <apfelmus> augustss: of course, there's the minor detail that overloading juxtaposition results in juxtaposition. I mean f x  ~> f <*> x  ~> f <*> <*> <*> x ~> etc. But I guess this is not an issue
10:53:58 <wli> I have to do things like factor out common prefixes and then do a nonterminal for the common prefix followed by a choice on the disjoint suffix. Do the Utrecht parser combinators avoid this?
10:54:15 <wli> It's ... irritating.
10:54:31 <wli> Sorry, in Parsec that is.
10:54:59 <augustss> apfelmus: I don't think that's any worse than 42 being fromInteger 42
10:55:05 <SamB> ndm: none of the stuff in the Language.Haskell.TH heirarchy is actually wired into GHC -- GHC just imports it and uses it ;-)
10:55:19 <monochrom> No (sorry for saying that all day :) ), "Lewis-Sandy, Darrell" <darrelll@amgen.com>'s "Question about arrows"
10:55:20 <apfelmus> augustss: yeah, good point :)
10:55:54 <xerox> Ah, thanks.
10:56:42 <ndm> SamB, yeah, i know its quite hacky, doesn't have that pure and polished feeling
10:56:48 <AHTOH> how to print hex in haskell?
10:56:54 <ndm> SamB, have pushed a Cabal testing script now, runhaskell Setup test
10:56:56 <ndm> @hoogle hex
10:56:57 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
10:56:57 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
10:56:57 <lambdabot> Numeric.readHex :: Integral a => ReadS a
10:56:58 <augustss> AHTOH: printf?
10:57:04 <SamB> ndm: hmm, I thought that was a relatively clean way to do it
10:57:09 <ndm> @hoogle+
10:57:09 <lambdabot> Numeric.readHex :: Num a => ReadS a
10:57:09 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
10:57:09 <lambdabot> Char.isHexDigit :: Char -> Bool
10:57:22 <ndm> AHTOH: showHex
10:57:44 <augustss> > printf "%x" 67645545 :: String
10:57:46 <lambdabot>  "4083069"
10:57:47 <SamB> ndm: if you wanted, you could implement Quasi too...
10:58:00 <AHTOH> yes showHex is simpler, thanks
10:58:05 <kosmikus> dozer: has your problem been solved? as the error message says, you need amstext.sty (although I'm surprised there's any current TeX distribution without that file) ...
10:58:06 <AHTOH> > showHex 123
10:58:07 <lambdabot>  <[Char] -> [Char]>
10:58:21 <AHTOH> > showHex A
10:58:21 <lambdabot>   Not in scope: data constructor `A'
10:58:24 <AHTOH> > showHex 'A'
10:58:24 <lambdabot>   add an instance declaration for (Integral Char)
10:58:25 <lambdabot>     In the expression: show...
10:58:32 <augustss> > showHex 123 ""
10:58:33 <lambdabot>  "7b"
10:58:39 <mrd> i've been playing with Arrows and HXT on my own the past few days, and coincidentally i now learn someone wrote quite a nice blog article about it a couple days ago
10:59:12 <dozer> kosmikus: no joy yet - I'm on ubuntu, and both locate and apt search don't know anything about that file
10:59:18 <SamB> ndm: it's quite true that the Quasi IO instance is hacky
10:59:59 <AHTOH> just dont understand showHex secod parameter, library says only one parameter: howHex :: Integral a => a -> ShowS
11:00:12 <ndm> @info SHowS
11:00:12 <lambdabot> SHowS
11:00:15 <ndm> @info ShowS
11:00:16 <lambdabot> ShowS
11:00:22 <ndm> @type ShowS
11:00:24 <lambdabot> Not in scope: data constructor `ShowS'
11:00:36 <ndm> AHTOH: ShowS is a type alias for String -> String
11:00:36 <Korollary> @src ShowS
11:00:36 <lambdabot> type ShowS = String -> String
11:01:05 <ndm> AHTOH: Show functions  use continuations to make things faster in certain cases, for now just pass "" as the second argument
11:01:17 <ndm> > showHex 123 " in Hex"
11:01:18 <lambdabot>  "7b in Hex"
11:01:22 <AHTOH> > showHex 1234 "0x"
11:01:23 <lambdabot>  "4d20x"
11:01:30 <AHTOH> heh :)
11:01:36 <ndm> it saves you the cost of (++)
11:02:35 <Korollary> ShowS was the first functional trick I saw while learning haskell/fp. I'd never thought of it in my imperative, wild youth.
11:02:56 <SamB> anyway, GHC's Quasi instance is apparantly in TcSplice
11:02:58 <Korollary> +have for pedants
11:03:14 <Tac-Tics> @type liftM
11:03:16 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:03:38 <augustss> Korollary: it's a very unimperative trick
11:04:00 <dozer> kosmikus: I've got tetex installed via apt in ubuntu, if that helps
11:05:08 <Syzygy-> dozer: IIRC is tetex deprecated in favour of texlive.
11:05:11 <mrd> (just an aisde, tetex is deaD)
11:05:16 <mrd> heh
11:05:21 <Syzygy-> @quote stereo
11:05:22 <lambdabot> No quotes match. The more you drive -- the dumber you get.
11:05:25 <Syzygy-> No?
11:05:31 <Syzygy-> Bah! That's bad.
11:05:33 <mrd> heh cale had it removed probably
11:05:40 <mrd> too much beeping
11:05:57 <dozer> ah, thanks - I'll nuke tetex and grab texlive
11:06:00 <SamB> ndm: so apparantly toplevel splices work like this
11:06:13 <mrd> i don't know what that ubuntu is based off of but the latest debians have texlive now
11:06:54 <dozer> I think it got sucked in as a dependency of kyle
11:06:58 <Syzygy-> @remember Stereo Welcome to #haskell where your questions are answered in majestic stereo!
11:06:58 <lambdabot> Done.
11:07:01 <Syzygy-> There.
11:07:07 <Syzygy-> I want the quote - even if we stop bugging Cale.
11:07:26 <Syzygy-> @quote Stereo
11:07:26 <lambdabot> Stereo says: Welcome to #haskell where your questions are answered in majestic stereo!
11:07:53 <Korollary> You could have slightly obfuscated C'ale to preserve credit
11:08:09 <Syzygy-> @remember C'ale Welcome to #haskell where your questions are answered in majestic stereo!
11:08:09 <lambdabot> Done.
11:08:15 <Syzygy-> There we go. :)
11:08:29 <Syzygy-> Now, if someone can figure out how to purge the first addition...
11:09:03 <Korollary> lambdabot: purge duplicate quotes. Also, make me a sandwich and fedex it.
11:10:12 <kosmikus> dozer: look for something like tetex-extra
11:10:35 <SamB> ndm: after typechecking the expression after the $, TcSplice sends it off to be compiled to bytecode and linked, and if that succeeds it just basically invokes runQ on the value (after coercing it to its type)
11:10:37 <dozer> kosmikus: found it - apting it now
11:10:51 <SamB> and then presumably inserts that into the AST somehow
11:11:21 <kosmikus> dozer: HTH, I have to leave now
11:11:36 <dozer> thanks for the help kosmikus
11:13:56 <SamB> oh, yes. then it invokes the TH -> internal AST conversion right away.
11:14:15 * SamB wonders how hard it would be to implement TH support in another compiler
11:16:14 <SamB> I suppose any compiler you could do that with would have to have access to an interpreter that used the same data representation for the interpreted code as the compiler used. almost, anyway.
11:16:14 <ndm> SamB, if you made TH your central data type, not that hard, probably easier than in GHC
11:17:02 <SamB> hmm. I guess you'd probably need to have bootstrapped first.
11:17:05 <ndm> esp if you had a convertor from TH to Core (andygill has one) and an evaluator for Core (Yhc has one, in a paper)
11:17:18 <ndm> that way you can eliminate it being a stage-2 thing
11:17:26 <SamB> hmm?
11:17:44 <ndm> i.e. no need to invoke GHCi style things
11:17:47 <SamB> what are you calling TH in "TH to Core"
11:17:58 <ndm> the template haskell AST
11:18:11 <SamB> TH obviously needs some kind of compile-time evaluation
11:18:53 <SamB> I suppose it doesn't actually need to use the same data representation as your compiler does, though
11:19:53 <SamB> basically, what you need to be able to do is this:
11:21:09 <ndm> its easier if it does
11:21:11 <SamB> take a Haskell expression, nearly fresh from the parser, of type Q a (for some particular a)
11:22:25 <SamB> somehow runQ it in a particular, fully-implemented Quasi and convert the result to something you can process further (including typechecking)
11:24:08 * glguy wishes that there was a download count for things on Hackage
11:24:08 <SamB> what you don't have to do is allow the Q a expression to use names bound in the module into which it is spliced
11:25:17 <SamB> anyway I guess this would be extremely painful in Jhc (fully-recursive modules and all)
11:25:33 <SamB> probably not too much fun in Yhc (what's a Monad?)
11:26:12 <SamB> way too soon for Qhc (what's a let expression? what's a data type definition?)
11:26:25 <j85wilson> Over in #scheme, we're having a discussion of whether or not the C preprocessor is Turing complete.  I've found a couple of references that claim it is not, but I can't necessarily explain exactly what they mean.  If anyone has a bit of insight into this, please come on over and join in.
11:27:15 <dozer> j85wilson: not sure if this helps, but the bit of the c++ preprocessor that expands templates is turing complete
11:27:16 <SamB> j85wilson: I would be happy to contribute that it makes my head hurt trying to understand some of the wierder things it does
11:27:27 <SamB> dozer: that's part of the compiler
11:27:35 <dozer> so if you can implement that using the vanilla c preprocessor...
11:27:36 <SamB> dozer: and that's damn sane compared to cpp
11:28:03 <j85wilson> http://www.ioccc.org/2001/herrmann1.hint claims that cpp is turing complete if you can invoke it multiple times.
11:28:24 <SamB> j85wilson: is it an unbounded number of times?
11:28:25 <flux> quite a big "if" IMHO :)
11:28:46 <j85wilson> SamB: I believe it is an unbounded number of times :)
11:28:48 <dozer> SamB_XP_: ah, things have moved on a bit then - when I was coding c++, the whole damn thing was a preprocessor hack that got piped to the standard c compiler :)
11:28:51 <SamB> j85wilson: ah.
11:29:20 <SamB> dozer: oh. that preprocessor runs after cpp
11:29:28 <SamB> if you even can find an implementation like that
11:29:31 <SamB> which I doubt
11:29:40 <j85wilson> he claims that cpp is a pushdown automaton, because ```the preprocessor has only a finite number of states, plus a stack consisting of the places which the file has been included from.'''
11:29:40 <flux> plain cpp doesn't have recursion, so I doubt it's turing complete by itself
11:29:41 <SamB> (that still works, I mean ;-)
11:29:48 <dozer> SamB_XP_: this was probably 15 years ago
11:29:57 <j85wilson> dozer: are you thinking of cfront?
11:30:43 <dozer> j85wilson: ah, could be
11:32:14 <SamB> 0ppppppp-pp--0-pp---------------------
11:32:37 <SamB> sorry, spilled milk on my keyboard
11:32:40 <tyoc> How I will go in do some like: (head . zip)  [1..4] ['a' .. 'z']
11:32:41 <SamB> was trying to clean it
11:32:45 <Eelis> dozer: sounds interesting (your "we could rustle up something that behaves a bit like that and is typesafe with a GADT+instance declaration" idea). i'm all ears :)
11:33:24 <dozer> Eelis: sorry, got side-tracked by saturday
11:33:30 <Eelis> dozer: so did i
11:34:44 <kuribas> Philippa: ping
11:34:48 <tyoc> or: (tail . zip)  [1..4] ['a' .. 'z']
11:36:04 <sjanssen> tyoc: that doesn't quite type
11:36:04 <lambdabot> sjanssen: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:36:14 <sjanssen> @type (tail . zip)  [1..4] ['a' .. 'z']
11:36:23 <lambdabot>     Couldn't match expected type `[a]'
11:36:23 <lambdabot>            against inferred type `[b] -> [(a1, b)]'
11:37:05 <tyoc> I can apply zip   [1..4] ['a' .. 'z']
11:37:10 <sjanssen> tyoc: you have to do a little extra when composing with a function of two arguments
11:37:18 <tyoc> @type zip  [1..4] ['a' .. 'z']
11:37:20 <lambdabot> forall t. (Num t, Enum t) => [(t, Char)]
11:37:39 <tyoc> like what??
11:37:40 <shachaf> > (tail .) . zip [1..4] ['a'..z]
11:37:41 <lambdabot>   Not in scope: `z'
11:37:44 <shachaf> > (tail .) . zip [1..4] ['a'..'z']
11:37:45 <lambdabot>  Couldn't match expected type `a -> a2 -> [a1]'
11:37:45 <sjanssen> @type (tail . zip [1..4]) ['a'..'z']
11:37:46 <tyoc> I can copy the result of zip
11:37:47 <lambdabot> forall t. (Num t, Enum t) => [(t, Char)]
11:37:58 <tyoc> and put it like an  argument of tail
11:38:02 <SamB> hmm. it looks like derive uses reify exactly twice...
11:38:56 <jleedev> > tail $ uncurry zip ([1..4],['a'..'z'])
11:38:58 <lambdabot>  [(2,'b'),(3,'c'),(4,'d')]
11:39:07 <sjanssen> tyoc: try shachaf's trick
11:39:23 <sjanssen> tyoc: look closely at the type of (.), and I think you'll see where it goes wrong
11:39:25 <sjanssen> @type (.)
11:39:27 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:39:41 <shachaf> sjanssen: Mine doesn't work.
11:39:55 <sjanssen> oh, oops
11:39:59 <sjanssen> how does that go again . . .
11:40:09 <tyoc> why I need do?? (tail . zip [1..4]) ['a'..'z'] and not directly ( tail. zip) ???
11:40:17 <sjanssen> @pl \x y -> f (g x y)
11:40:17 <lambdabot> (f .) . g
11:40:23 <shachaf> > (tail . zip [1..4]) ['a'..'z'] -- Does work.
11:40:24 <lambdabot>  [(2,'b'),(3,'c'),(4,'d')]
11:40:32 <shachaf> tyoc: Look at (.)'s type.
11:40:32 <tyoc> yea
11:40:54 <sjanssen> @type ((tail .) . zip) "a" "b"
11:40:54 <tyoc> >:t .
11:40:56 <lambdabot> [(Char, Char)]
11:41:01 <tyoc> ?
11:41:09 * wli looks at trying to daemonize.
11:41:19 <shachaf> > ((tail .) . zip) [1..4] ['a'..'z']
11:41:20 <sjanssen> tyoc: the syntax is @type
11:41:21 <lambdabot>  [(2,'b'),(3,'c'),(4,'d')]
11:41:33 <sjanssen> @src (.)
11:41:33 <lambdabot> (.) f g x = f (g x)
11:41:34 <shachaf> There, I just forgot parentheses.
11:41:42 <tyoc> yea, that work, I will take it into account
11:41:47 <sjanssen> tyoc: look at that source
11:42:04 <sjanssen> tyoc: (.) takes two functions, and one argument
11:42:17 <tyoc> mmmm OK
11:42:21 <sjanssen> so "(f . g) x y" becomes "f (g x) y"
11:42:41 <shachaf> @pl c2 f g x y = f (g x y)
11:42:42 <lambdabot> c2 = (.) . (.)
11:42:46 <sjanssen> or "tail (zip x) y" -- which clearly isn't what we want
11:43:33 <tyoc> what will happen if I have 3 arguments and only 2 functions that I want to: f(g(a,b,c)) ???
11:43:50 <xerox> shachaf: there's a nice property, the number n of (.) you compose is the number of arguments of the n-ary function the composition of compositions composes with an unary one :)
11:43:53 <sjanssen> tyoc: remember that Haskell doesn't usually have arguments like (a, b, c)
11:44:21 <tyoc> mmm, OK, only want to see if possible
11:44:21 <sjanssen> tyoc: you'll generally see "f (g a b c)"
11:44:23 <xerox> :t (.) . (.) . (.)
11:44:24 <shachaf> @pl c3 f g x y z = f (g x y z)
11:44:24 <lambdabot> c3 = (.) . (.) . (.)
11:44:25 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
11:44:31 <xerox> :t (.) . (.) . (.) . (.) . (.)
11:44:33 <lambdabot> forall a a1 a2 a3 b c a4. (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> b) -> a -> a1 -> a2 -> a3 -> a4 -> c
11:44:52 <sjanssen> tyoc: this distinction is important.  In your example, g is an argument of one function, in mine g is a function of three arguments
11:45:11 <sjanssen> @pl \x y z -> f (g x y z)
11:45:11 <lambdabot> ((f .) .) . g
11:45:18 <sjanssen> tyoc: ^^^
11:45:29 <tyoc> I see
11:45:34 <tyoc> I take the note :)
11:45:45 <sjanssen> tyoc: you can use the @pl command to turn an expression with lambdas into an expression without (known as "pointfree")
11:45:50 <shachaf> tyoc: You have to remember there's no such thing as a two-argument function.
11:45:52 <wli> I sure could use something like dup2() for handles. Maybe just closing stdin, stdout, and stderr will do.
11:46:22 <sjanssen> wli: you can use dup2 on handles
11:46:34 <sjanssen> wli: I think there's a function somewhere :: Handle -> Fd
11:46:41 <tyoc> I guess I need understand it best ;)
11:47:00 <wli> sjanssen: That closes the handle so things will throw exceptions when referring to e.g. stdin/stdout/stderr.
11:47:42 <wli> I just want to silently redirect them to /dev/null
11:47:43 <sjanssen> wli: ah.  You can also fiddle with the handle internals to get at the Fd without closing the handle
11:49:01 <wli> Maybe since one knows the fd numbers one can just dupTo on the fd numbers without even touching the handles.
11:49:16 <sjanssen> wli: or just call dup2 on 0, 1, 2 -- Unix says that's okay
11:49:30 <wli> jinx
11:50:13 * SamB wonders what version of cabal ndm is using...
11:50:17 <tyoc> I guess for now I will talk directly to the lambdabot, it have more things than my ghci hehe
11:50:49 <sjanssen> wli: you might see if HAppS has some working daemonize code
11:50:50 <shachaf> tyoc: You can build it locally with a bit of work.
11:50:55 <shachaf> tyoc: AWhere goa
11:50:58 <tyoc> where I can get the info?
11:50:59 <shachaf> @where goa
11:50:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
11:51:10 <shachaf> That's a version of ghci with the lambdabot extras.
11:51:14 <SamB> @hoogle runTests
11:51:15 <lambdabot> Distribution.Simple.runTests :: UserHooks -> Args -> Bool -> LocalBuildInfo -> IO ExitCode
11:51:15 <lambdabot> Test.QuickCheck.Batch.runTests :: String -> TestOptions -> [TestOptions -> IO TestResult] -> IO ()
11:51:54 <tyoc> I will see if I can get it :)
11:51:59 <tyoc> thx for the info guys
11:52:14 <aip> how can i mapM_ over a list, with a counter?
11:52:43 <sjanssen> aip: sounds like you want foldM?
11:52:52 <sjanssen> @type foldM
11:52:54 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:53:42 <dmwit> > let enumerate = zip [1..] in enumerate "a string with a counter"
11:53:43 <lambdabot>  [(1,'a'),(2,' '),(3,'s'),(4,'t'),(5,'r'),(6,'i'),(7,'n'),(8,'g'),(9,' '),(10...
11:53:56 <aip> which is better, zip or foldM?
11:53:59 <sjanssen> or zipWithM_
11:54:04 <sjanssen> @type zipWithM_
11:54:05 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
11:54:19 <aip> is that the best way to do it?
11:54:19 <aip> is that the best way to do it?
11:54:31 <dmwit> aip: You should do it the way that matches the problem...
11:54:34 <sjanssen> yes, IMO
11:55:12 <dmwit> Without knowing the problem, we can hardly compare solutions.
11:56:09 <aip> i have list of strings, and a drawString :: String -> X -> Y -> IO ()
11:56:24 <aip> i want to draw all the strings, at coordanites (0, 0), (0, 10), (0, 20), (0, 30).....
11:57:12 <hpaste>  dozer annotated "lhs2TeX problem" with "getting further..." at http://hpaste.org/2061#a1
11:57:28 <dmwit> Yeah, zipWithM_ sounds like a good approach, then.
11:58:33 <dozer> the error seems to be at the very end of the file
11:58:44 * gogonkt_sleeping is away: åˆ°å¤„èµ°èµ°,çœ‹ç¾Žå¥³åŽ»äº†,o(^_^)o,æœ‰äº‹Bellæˆ‘
11:58:47 <aip> thanks
11:59:36 <ndm> why has Bulat suddenly starting trolling?
11:59:57 <ndm> he's never been the most tactful, but he never seemed to be doing it intentionally before
12:00:39 <dmwit> The government has mind-control technology that they got from the aliens, and they're keeping it from us in an attempt to protect us from the Cognoscenti!
12:01:35 <_roconnor> The Fuuns?
12:01:53 <SamB> ndm: so... what's supposed to happen when I try to derive Eq for a type like this:
12:01:58 <SamB> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
12:03:19 <ndm> SamB: not the faintest idea
12:03:36 * SamB wonders if it can be done...
12:03:39 <dmwit> _roconnor: The Fuuns are so secretive even Google, who has bases as far reaching as the MOON, doesn't know about them!
12:03:57 <SamB> I think the plural may be Fuun
12:04:02 <oerjan> it's not H98 i guess, since you cannot get a constraint solely on m
12:04:41 <SamB> okay...
12:04:58 <hpaste>  dozer annotated "lhs2TeX problem" with "minimal example of the problem" at http://hpaste.org/2061#a2
12:05:16 <oerjan> you might expect it to use an instance for m (Maybe a)
12:05:19 <SamB> with FlexibleInstances my constraint is bigger than the instance head :-(
12:05:54 <crazy_coder> hello everyone
12:05:56 <hpaste>  kuribas pasted "layout test" at http://hpaste.org/2062
12:06:10 <kuribas> Why is this valid layout?
12:06:31 <dmwit> Hiya, crazy_coder!
12:06:43 <kuribas> Or is it a ghc extension?
12:06:51 <oerjan> kuribas: it shouldn't be
12:06:58 <SamB> ndm: can instance_context be made to give up if you try to use it with a type constructor that has non-* parameters?
12:06:59 <crazy_coder> dmwit: :)
12:07:15 <oerjan> or perhaps...
12:07:21 <SamB> (given a non-[] list of constraints...)
12:07:31 <oerjan> maybe the whole block ends before the >>
12:07:40 <oerjan> by the parse-error rule
12:07:51 <Lemmih> kuribas: Remove the 'do' or indent the last line one space more.
12:08:13 <kuribas> Lemmih: I am just trying to understand the layout rule :)
12:08:15 <oerjan> or remove the >>
12:08:38 <oerjan> i think it may be inserting } before >>
12:08:56 <oerjan> since an operator cannot legally appear there at all
12:09:05 <kuribas> oerjan: That makes sense, yes.
12:09:19 <SamB> ndm: I think Eq/Ord/Read/Show constraints should be generated based on fields, anyway, not based on parameters
12:09:34 <SamB> does this make sense?
12:10:20 <DRMacIver> Sigh. It's annoying how offensively bad most UI designs are. Particularly with web applications.
12:11:40 <SamB> obviously, the solution is to avoid having a UI
12:11:47 <monochrom> That is one reason I dislike web forums.
12:11:53 <_roconnor> @where MTL
12:11:54 <lambdabot> www.cs.brown.edu/~jwicks/mtl_reference/
12:12:12 <DRMacIver> SamB: Mmhmm. :)
12:12:13 <roconnor> what the!
12:12:21 <roconnor> Matrix Template Library!!
12:12:24 <ndm> SamB:yes, you can avoid instance_context on non *'s stuff
12:12:43 <ndm> SamB: how do you mean, based on fields and not parameters for Eq etc?
12:12:49 <monochrom> Then again, with Haskell and HXT and all that, we can write programs that deconstructs a web forum and show its content in our own UI. :)
12:13:50 <monochrom> Matrix is boring.
12:13:53 <DRMacIver> monochrom: That option isn't even available for the particular web application that's giving me grief. :-/
12:14:04 <timthelion> > [3..0]
12:14:06 <SamB> ndm: see http://www.haskell.org/onlinereport/derived.html
12:14:06 <lambdabot>  []
12:14:07 <lambdabot> Title: The Haskell 98 Report: Derived Instances
12:14:17 <timthelion> how do I do that then?
12:14:24 <SamB> note the second condition
12:14:25 <monochrom> How come? You can even understand the javascript code and subvert it.
12:14:29 <SamB> There is a context cx' such that cx' =>C tij holds for each of the constituent types tij
12:15:09 <DRMacIver> monochrom: It's really very heavily javascript dependent, and relies on a custom firefox extension for a lot of the functionality.
12:15:22 <ndm> SamB: i'm not sure i get the question
12:15:35 <ndm> what are you proposing to change? where would that change show up?
12:15:40 <DRMacIver> monochrom: I could probably subvert it with my own browser extensions if I cared enough, but it would be a considerable amount of work. :)
12:15:41 <SamB> well.
12:16:03 <SamB> ndm: right now, you just try to generate an Eq constraint for each parameter of the type constructor...
12:16:15 <SamB> (if we are trying to derive Eq)
12:16:23 <timthelion> > let f p = p - 1 : f p-1 in f 3
12:16:24 <lambdabot>   add an instance declaration for (Num [t])
12:16:24 <lambdabot>     In the expression: let f p = ...
12:16:33 <monochrom> I should think about how to mechanically understand (partly) a typical javascript program.
12:16:33 <ndm> yes, so data Foo a b gives rise to Eq a, Eq b => Eq (Foo a b)
12:16:43 <SamB> regardless of (a) whether or not it shows up in the right hand side of the type and (b) whether or not it is the right kind
12:17:05 <timthelion> > let f p = (p - 1) : f (p-1) in f 3
12:17:07 <lambdabot>  [2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-2...
12:17:19 <SamB> what about "data Phantom a = Phantom"?
12:17:24 <timthelion> > let f p = (p - 1) : f (p-1) ; f 0 = [] in f 3
12:17:25 <lambdabot>      Warning: Pattern match(es) are overlapped
12:17:25 <lambdabot>              In the definition...
12:17:29 <ndm> so, you suggest restricting that to ones which show up of kind * ?
12:17:36 <ndm> that seems perfectly sensible
12:17:48 <timthelion> > let f p = f 0 = [] ;  (p - 1) : f (p-1)  in f 3
12:17:48 <lambdabot>  Parse error
12:17:53 <DRMacIver> monochrom: I think a good starting point would be to determine if the javascript program will halt. :)
12:18:14 <ndm> what we do now is a reasonable approximation, but i can't think of anything that would break with your proposed change, but a few things would work
12:18:17 <SamB> ndm: well, I suggest not trying to generate constraints involving, say, Eq (a :: * -> *), yeah.
12:18:19 <timthelion> > let f 0 = [] ; f p =  (p - 1) : f (p-1)  in f 3
12:18:20 <lambdabot>  [2,1,0]
12:18:22 <oerjan> actually i think he means to use Eq constraints for the fields themselves, without reducing to parameters unless that really makes sense
12:18:26 <timthelion> is there a better way to do that?
12:18:35 <ndm> oerjan: thats not H98
12:19:00 <SamB> ndm: well, the report doesn't seem to say how exactly to do it...
12:19:03 <oerjan> i didn't think we were considering H98
12:20:05 <SamB> ndm: but I get the distinct impression that CX' should be no more restrictive than necessary
12:20:32 <SamB> and if it can only be done with extensions, we might want to investigate the feasability of that.
12:20:43 <SamB> possibly we should see how the previous derive does it.
12:20:53 <SamB> (its name has been changed to DrIFT ;-)
12:21:52 <oerjan> SamB: "The context cx' is the smallest context satisfying point (2) above."
12:22:06 <dozer> looks like lhs2tex isn't very happy about {- comments -} in my code :(
12:24:56 <oerjan> (Chapter 10, second last paragraph of introduction)
12:27:56 <ndm> SamB: we do it the same way as derive
12:28:06 <ndm> dozer: it treats the bits inside as normal latex
12:28:17 <ndm> SamB: i mean DrIFT
12:29:06 <SamB> ndm: hmm.
12:29:43 <SamB> ndm: I guess JHC isn't doing well enough for anyone to have noticed yet then?
12:29:59 <ndm> i guess
12:30:47 <SamB> oh, btw, your Setup.hs doesn't build here
12:31:16 <ndm> what error?
12:31:21 <SamB> @hoogle runTests
12:31:22 <lambdabot> Distribution.Simple.runTests :: UserHooks -> Args -> Bool -> LocalBuildInfo -> IO ExitCode
12:31:22 <lambdabot> Test.QuickCheck.Batch.runTests :: String -> TestOptions -> [TestOptions -> IO TestResult] -> IO ()
12:31:43 <ndm> oh, cabal versions
12:31:49 <SamB> it says inferred type Args -> Bool -> LocalBuildInfo -> IO () doesn't match expected type Args -> Bool -> LocalBuildInfo -> IO ExitCode
12:31:53 <ndm> and multiple instances of unecessary pain
12:31:54 <ndm> yay!
12:32:27 <ndm> upgrade your cabal
12:32:30 <hpaste>  desp pasted "layout wtf" at http://hpaste.org/2063
12:32:35 <SamB> UPGRADE?
12:32:36 <desp> hi guys
12:32:41 <ndm> i'll fix it so that it only works on the latest cabal, but can cmopile with the old ones
12:32:46 <desp> I have a weird problem with layout
12:32:50 <thecrypto> @src Read CalendarTime
12:32:50 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:32:51 <desp> can someone take a look at my paste?
12:32:55 <SamB> how is it better to switch to () instead of ExitCode?
12:33:04 <desp> the upper version works, the lower doesn't
12:33:34 <Botje_> desp: move the | at least past n' ?
12:33:56 <Botje_> also, make sure your indentation is consistent (tabs vs spaces)
12:34:02 <oerjan> desp: the layout for the where block starts at n'
12:34:05 <desp> I see
12:34:06 <desp> thanks
12:34:14 <desp> I use spaces exclusively
12:35:27 <ndm> SamB: it just changed, its merely different
12:35:41 <SamB> ndm: why did it change if it's not for the better?
12:35:53 <ndm> SamB: everyone was returning bad error codes and everything
12:36:04 <SamB> oh
12:36:39 <SamB> JohnMeacham: oh, hey, you're here?
12:36:58 <SamB> JohnMeacham: how come DrIFT doesn't follow http://www.haskell.org/onlinereport/derived.html ?
12:36:58 <lambdabot> Title: The Haskell 98 Report: Derived Instances
12:37:23 <Alleria> @src split
12:37:23 <lambdabot> Source not found. That's something I cannot allow to happen.
12:37:56 <oerjan> @src splitAt
12:37:56 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
12:38:02 <dozer> dang, underscores in comments break lhs2TeX
12:38:03 <oerjan> @src span
12:38:03 <lambdabot> Source not found. You type like i drive.
12:38:16 <oerjan> :t span
12:38:18 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:39:15 <Alleria> thank you
12:39:42 <ndm> SamB: pushed, should now work for you
12:39:52 <Alleria> I basically have a string of comma-delimited numbers and want to get at them...
12:39:53 <ndm> including the test running
12:40:09 <ndm> dozer: treat them like underscores in Tex, use \_ in comments
12:40:21 <ndm> or |name_foo|, if they are code snippets
12:41:09 <oerjan> hm... you could cheat by putting [] around and using read for lists
12:41:29 <Alleria> oerjan: brilliant! thank you
12:42:57 <Alleria> just tried it -- that works perfectly! :)
12:43:32 <oerjan> :)
12:48:49 <dancor> is there a rss parser laying around anywhere
12:49:11 <ndm> you could easily write one on top of tagsoup
12:49:20 <ndm> but someone should write a standard one
12:49:21 <DRMacIver> hpodder probably has one.
12:49:41 <DRMacIver> (It certainly has at least part of one in order to do its task)
12:54:05 <Eelis> if i search hoogle for "Arrow a => a b c -> a b c' -> a b (c, c')", which is the precise signature of &&&, how come &&& appears on page 2 after various other stuff with completely different type signatures?
12:54:32 <ndm> Eelis: because hoogle 3 has a bug relating to higher-kinded classes, which will be fixed in the next version
12:54:37 <ndm> it shows up with Monad as well
12:54:50 <Eelis> ah, i see. good to hear. looking forward to it :)
12:55:29 <ndm> me too, but its months away at least
12:55:48 <Eelis> fair enough
12:59:35 <Eelis> ndm: are you just very busy, or is it a really deep vicious bug that is extremely hard to fix?
13:00:40 * Cale guesses that ndm is working on his other projects :)
13:01:48 <ndm> Eelis: just very busy, its too deep to fix in Hoogle 3 without a lot of effort, and Hoogle 4 is about a weeks hacking time from a beta
13:02:04 <ndm> unfortunately, my phd is keeping me very busy...
13:02:44 <Eelis> ok, i see.
13:02:53 <ndm> my plan is to write hoogle 4 between my submission and my viva, which should be relatively easy to get done
13:07:14 <desp> is there an array-like structure in the libraries that gives O(1) read/write access?
13:08:46 <oerjan> Diff arrays, mutable arrays
13:09:13 <Philippa> ndm: ping?
13:09:15 <Philippa> d'oh
13:09:19 <desp> oerjan: thanks
13:09:24 <desp> another question
13:10:53 <desp> would it be possible to somehow redirect the internal recursive calls of a function?
13:11:11 <Botje_> say what now?
13:11:26 <oerjan> if you rewrite it to take itself as a parameter rather than call it directly.
13:11:47 <desp> oerjan: right... I was hoping to automatically add memoization to any recursive function
13:12:05 <desp> that'd work if the recursive call was dynamically scoped
13:12:27 <desp> not in this language, I guess :)
13:12:34 <oerjan> i don't think so - which calls actually are recursive is information you cannot have due to referential transparency, i think
13:12:51 <SamB> of course you can't
13:13:08 <desp> I think I could do this in Lisp :)
13:13:36 <SamB> I think you don't know all the intricacies
13:13:51 <SamB> at least, if you're talking about CL...
13:13:53 <desp> quite possibly
13:14:06 <SamB> I'm not positive though
13:14:36 <SamB> but I think it would mess up compiler optimizations even if it did work
13:15:21 <JohnMeacham>  SamB: it should. but I didn't write any of that code.
13:15:33 <SamB> JohnMeacham: ah.
13:16:46 <SamB> JohnMeacham: what do you think should be the result of deriving Eq for this datatype:
13:16:51 <SamB> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
13:16:55 <SamB> ?
13:17:46 <fasta> Why are the videos in topic hosted there and not on a service that does have the necessary bandwidth?
13:18:08 <kilimanjaro> desp, if a function recurses onto itself by name then it's pretty easy, you just change the binding to be a new function that maps arguments to values if they have been computed, or computes the value given arguments, inserts this into the table, and then returns that value
13:18:21 <SamB> fasta: hosted where?
13:18:30 <fasta> SamB: blip.tv
13:18:44 <kilimanjaro> desp, that's in a language like scheme
13:18:50 <SamB> the .mov files worked fine for me in mplayer a couple of days ago
13:19:00 <wli> Tell them about faking mutual recursion with tuples.
13:19:04 <sorear> desp: this is pretty standard use-case for fix-like combinators
13:19:06 <fasta> SamB: could you download them?
13:19:06 <SamB> (streaming over HTTP)
13:19:17 <SamB> fasta: download? I watched them where they are
13:19:23 <fasta> SamB: I streamed the swf
13:19:34 <fasta> SamB: the bandwidth was limited on their side.
13:19:46 <sorear> desp: fib = memofix $ \fib x -> if x <= 1 then 1 else fib (x-1) + fib (x-2)
13:19:48 <SamB> perhaps flv is too inefficient?
13:19:52 <mauke> I downloaded them
13:20:17 <SamB> I tried the swf, but it hung up near the beginning. twice.
13:20:20 <fasta> SamB: I tried the mov too, but that didn't work(I used some totem plugin (for complex reasons)).
13:20:28 <fasta> SamB: ok, then maybe that's it.
13:20:45 <fasta> SamB: still YouTube and GoogleVideo are the only services that Just Work, imho.
13:20:52 <SamB> it may be a problem of bandwidth, or it may be a problem of bad flash coding
13:21:10 <SamB> I don't know too much about it
13:22:27 * SamB wonders how GHC manages to get it's pretty printers to actually produce fairly pretty output...
13:22:41 <aip> what is a pretty printer?
13:23:00 <fasta> SamB: it doesn't work that good for large do blocks
13:23:10 <fasta> SamB: otherwise, yes, it is quite nice.
13:23:21 <Igloo> aip: Show something prettily, e.g. nicely indented
13:23:23 <chessguy> aip, in general it's just something that prints stuff out in a pretty format
13:23:23 <SamB> aip: it's supposed to print code (or data) nicely-indented
13:23:59 <SamB> but many so-called pretty printers do not actually manage this very well
13:24:17 <mauke> ugly printers
13:24:20 <aip> is GNU indent a pretty printer?
13:24:28 <mauke> yes
13:24:33 <fasta> SamB: it's just related to the amount of work that went into it. GHC got more than others, I guess.
13:24:39 <mauke> it also includes a parser
13:24:44 <SamB> Jhc's E code does not seem to come out particularly pretty, for instance
13:25:11 <fasta> Pretty printing libraries make life somewhat easier, but not as much as is often hyped.
13:25:26 <SamB> I'm wondering if we've been using the wrong library
13:25:34 <SamB> I don't know where to get a better one, though...
13:26:56 <SamB> but I'd really like to see one that does a really good job of combatting over-indenting, and I'd also like to get it to break lines in nice places...
13:26:57 <sorear> SamB: GHC uses John Hughes' pretty printer (reimplemented by SPJ).  JHC uses Philip Wadler's pretty printer (reimplemented by Daan Leijen)
13:27:36 <fasta> GHC can create horrible output too.
13:27:38 <SamB> well, TH's pretty printer doesn't seem to do nearly as good a job...
13:27:48 <fasta> I should have saved that output.
13:28:02 <SamB> actually GHC has a number of "pretty" printers
13:28:10 <SamB> the one it uses for it's type errors is the one I mean.
13:28:14 <SamB> I think it might cheat, though.
13:28:29 <sorear> cheat?
13:28:45 <SamB> I dunno. use small trees or something.
13:28:46 <aFlag> I'm trying to create a debian package from a cabal package by doing what http://www.haskell.org/haskellwiki/Creating_Debian_packages_from_Cabal_package is telling me. But I don't seem to have the binary "update-debian-haskell-files" (step 8). Does anyone know if that step is correct?
13:28:48 <fasta> Does anyone know what $f1 in  Foo.$f1 means?
13:28:49 <lambdabot> Title: Creating Debian packages from Cabal package - HaskellWiki, http://tinyurl.com/2m8u8w
13:28:50 <sorear> oh, you mean like indent does by default - copying indentation from the source
13:28:55 <sorear> fasta: gensym
13:28:57 <SamB> fasta: what type has it got?
13:29:17 <fasta> SamB: the horrible thing?
13:29:25 <fasta> SamB: I don't have the output anymore.
13:29:29 <SamB> $f1
13:29:38 <sorear> fasta: $f1 is a gensym
13:29:39 <SamB> what type does $f1 have
13:29:45 <fasta> SamB: I don't know, it ends up in a stack trace.
13:29:49 <SamB> oh.
13:29:50 <fasta> sorear: yes, I heard you.
13:30:34 <fasta> sorear: do you have any idea why GHC outputs it?
13:30:38 <sorear> fasta: it was generated by GHC floating some random let or where in your code to the top level.
13:30:43 <sorear> fasta: because it was called
13:31:02 <sorear> foo = let x = 2 + 2 in x * x
13:31:12 <sorear> will turn into something like
13:31:25 <sorear> $f2 = 2 + 2 ; foo = $f2 * $f2
13:31:54 <fasta> sorear: will I get better stack traces if I don't evaluate CAFs?
13:32:22 <tc2> Hughes' pretty printer is quite nice. I don't really know how it works, but it mostly just does the right thing. :)
13:32:37 <sorear> fasta: Yes.  How exactly do you plan to accomplish that?
13:32:57 <fasta> sorear: well, "less CAFs"
13:33:00 <fasta> sorear: currently, I do test_foo and then in main = test_foo
13:33:38 <aip> how do i do a case insensitive sort of [String] ?
13:33:40 <fasta> sorear: I could let main read some arguments from the command line. (although I'd find it odd if that would help)
13:33:43 <ddarius> tc2: There is a paper or two on it.
13:33:46 <sorear> well, if the caf is named and top level it should keep its name.
13:34:26 <tc2> ddarius: Yeah, I know. As long as it does the right thing for me, I don't bother deepening my understanding.
13:35:24 <ddarius> tc2: They're good reads.
13:35:53 <tc2> ddarius: As are so many other things. :)
13:36:04 <int-e> aip: sortBy (\x y -> map toLower x `compare` map toLower y) is a possibility.
13:36:38 <int-e> aip: sortBy is in Data.List, toLower is in Data.Char
13:37:00 <aip> int-e: hm... but i don't think that will always put "A" before "a"
13:37:18 <int-e> no it won't
13:37:27 <fasta> aip: you wanted case insensitive sort
13:37:37 <int-e> > sortBy (\x y -> map toLower x `compare` map toLower y) ["a", "A", "a"]
13:37:39 <lambdabot>  ["a","A","a"]
13:37:48 <aip> fasta: yeah but i want if 2 strings differ only in case, then upper should be first
13:38:08 <ddarius> aip: That's not a case insensitive sort.
13:38:12 <aip> int-e: is sortBy stable? if so then i can first do a normal sort pass
13:38:14 <fasta> aip: your requirements change fast ;)
13:38:34 <desp> sorear: thanks
13:38:34 <mauke> @hoogle Ordering -> Ordering -> Ordering
13:38:35 <lambdabot> No matches, try a more general search
13:38:35 <int-e> > sortBy (\x y -> (map toLower x, x) `compare` (map toLower y, y)) ["a", "A", "a"]
13:38:37 <lambdabot>  ["A","a","a"]
13:38:47 <mauke> ah, that's a nice trick
13:38:48 <ddarius> :t on
13:38:50 <lambdabot> Not in scope: `on'
13:39:09 <ddarius> @let on f g x y = g x `f` g y
13:39:12 <aip> int-e: interesting
13:39:13 <lambdabot> Defined.
13:39:17 <int-e> on is only in the darcs head of base, and I didn't want to define it :)
13:39:37 <Alleria> @src min
13:39:37 <lambdabot> min x y = if x <= y then x else y
13:39:39 <chessguy> @pl columnOf 'x' >>= \n -> return (n, 'x')
13:39:39 <lambdabot> flip (,) 'x' `fmap` columnOf 'x'
13:39:44 <ddarius> > sortBy (compare `on` (map toLower&&&id)) ["a","A","a"]
13:39:46 <lambdabot>  ["A","a","a"]
13:39:49 <aip> > (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1) `compare` (0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ,0 ,0 ,0 ,0 ,0 ,0)
13:39:50 <lambdabot>        add an instance declaration for
13:39:50 <lambdabot>       (Ord (t,
13:39:50 <lambdabot>             t1,
13:39:50 <lambdabot>        ...
13:39:55 <int-e> aip: it's cheating, it probably doesn't always work for non-ascii letters.
13:40:22 <chessguy> @pl columnOf 'x' >>= \n -> return ('x',n)
13:40:22 <lambdabot> (,) 'x' `fmap` columnOf 'x'
13:41:21 * ddarius doesn't like this infix fmap/liftM nonsense.
13:42:01 <opqdonut> wow, that's nice
13:42:02 <chessguy> ddarius, hm? how would you write it?
13:42:27 <ddarius> liftM ((,) 'x') $ columnOf 'x'
13:42:29 <shachaf> With (<$>), maybe?
13:43:00 <shachaf> ddarius: Why don't you like it infix?
13:43:15 <mauke> just define (.) as an alias for fmap
13:43:26 <mauke> for great justice!
13:43:27 <ddarius> shachaf: Because it doesn't read well, especially for liftM.
13:44:00 <Syzygy-> > (+2) `fmap` (*4) $ 2
13:44:01 <lambdabot>  10
13:44:10 <shachaf> ddarius: What about (<$>), though?
13:44:13 <shachaf> @ty (<$>)
13:44:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:44:26 <xerox> Syzygy-: yeah! :)
13:44:33 <int-e> > [compare a c `mappend` compare b d | (a,b,c,d) <- [(1,1,1,1), (1,2,1,3), (1,1,2,0)]]
13:44:35 <lambdabot>  [EQ,LT,LT]
13:44:45 <Syzygy-> xerox: That's the (->) a monad, isn't it?
13:44:49 <ddarius> shachaf: That would be fine, though I never use the combinators from Control.Applicative (not for any particular reason though)
13:44:52 * xerox nods
13:45:08 <chessguy> wait, is liftM the same as fmap?
13:45:20 <Syzygy-> chessguy: liftM is fmap for monads.
13:45:21 <mauke> chessguy: yes
13:45:23 <ddarius> chessguy: Yes, only it's for Monads only.
13:45:23 <xerox> The ((->) e) Monad.  Which would be conveniently written as (e ->) if type section were allowed.
13:45:43 <SamB> chessguy: if someone defines it otherwise... well, that's bad for them!
13:45:51 <ddarius> chessguy: If this were legal, you could write: instance Monad m => Functor m where fmap = liftM
13:45:53 <Syzygy-> xerox: But that would mean that (.) actually has a wider scope in its current definition than fmap does, doesn't it?
13:46:03 <SamB> we might have to excommunicate someone who does that
13:46:04 <xerox> Syzygy-: true.
13:46:23 <Syzygy-> In fact, most of my (.) usages would be invalid with (.) = fmap
13:46:32 <xerox> Would them?
13:46:35 <mauke> really?
13:46:38 <Eelis> i always hide (.) from the prelude and define  (.) = fmap
13:46:43 <Eelis> and then use it for everything
13:46:55 <Syzygy-> Hmmmm.
13:46:58 <shachaf> > let (.) = fmap in (+1) . (*2) $ 5
13:46:59 <lambdabot>  11
13:47:32 <wli> Eelis: nice
13:47:40 <Syzygy-> > fromJust `fmap` (Just :: Int -> Maybe Int) $ 3
13:47:42 <lambdabot>  3
13:47:53 <Syzygy-> Maybe it doesn't. *hmmmm*
13:48:22 <Eelis> needless to say i have a *lot* of (.) usage in my code
13:48:22 <sorear> I wish map was still defined in Functor.
13:48:29 <JohnMeacham> SamB: not sure, what does ghc do?
13:48:42 <int-e> @hoogle (a -> a -> Ordering) -> [a] -> [a] -> Ordering
13:48:43 <lambdabot> No matches, try a more general search
13:48:54 <ddarius> Syzygy-: (.) is the action on arrows of a Functor.
13:49:12 <sorear> int-e: Are you looking for the Ord a => Ord [a] dictionary?
13:49:22 <mauke> @hoogle (Monoid m) => [m] -> m
13:49:23 <lambdabot> Data.Monoid.mconcat :: Monoid a => [a] -> a
13:49:23 <lambdabot> Prelude.head :: [a] -> a
13:49:23 <lambdabot> Prelude.last :: [a] -> a
13:49:31 <sorear> hmm, no, I don't know where it is, sorry
13:49:39 <Syzygy-> Eelis: You would have.
13:49:42 <Syzygy-> ddarius: Hmmm?
13:49:50 <mauke> @type (mconcat .) . zipWith
13:49:52 <lambdabot>     Couldn't match expected type `[a]'
13:49:52 <lambdabot>            against inferred type `[b] -> [c]'
13:49:53 <Eelis> Syzygy-: i'm sorry, would have what?
13:49:53 <int-e> sorear: no I thought this might be useful as a standalone function
13:50:05 <mauke> @type ((mconcat .) .) . zipWith
13:50:07 <lambdabot> forall a b c. (Monoid c) => (a -> b -> c) -> [a] -> [b] -> c
13:50:23 <kilimanjaro> Is there a way to pattern match against arrays without first converting them to a list?
13:50:59 <ddarius> Hom(X,f)(g) = f . g
13:51:03 <Syzygy-> kilimanjaro: Sure. Arrays have constructors, don't htey?
13:51:07 <Cale> kilimanjaro: no, but you can use guards along with array indexing
13:51:15 <int-e> sorear: it's defined in GHC.Base for ghc
13:51:18 <mauke> Syzygy-: no
13:51:18 <Syzygy-> ddarius: Ah, right.
13:51:22 <ddarius> Hom(g,h)(f) = g . f . h
13:51:24 <Syzygy-> mauke: o.O
13:51:38 <Syzygy-> ddarius: Wait a minute.... I'm not sure I buy that second statement.
13:51:40 <mauke> to be honest, I've never seen an array constructor
13:51:48 <kilimanjaro> Cale, ok
13:52:07 <kilimanjaro> Arrays are constructed from lists I thought
13:52:08 <ddarius> Syzygy-: I rearranged the arguments, but Hom(-,=) is a bifunctor contravariant in it's first argument.
13:52:15 <Syzygy-> ddarius: (.) is typically covariant, and Hom in the first argument is contravariant.
13:52:23 <Syzygy-> ddarius: Exactly!
13:52:31 <Syzygy-> Ooooooh, wait.
13:52:32 <sorear> kilimanjaro: no, lists are too slow.  arrays are unsafe primitive magic
13:52:34 <sorear> @src Array
13:52:35 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:52:39 <sorear> @src UArray
13:52:39 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:52:43 <kilimanjaro> @src array
13:52:44 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:52:46 <sorear> @src IOArray
13:52:46 <lambdabot> newtype IOArray i e = IOArray (STArray RealWorld i e)
13:52:48 <ddarius> arrows aren't covariant/contravariant in the categorical sense.
13:52:50 <sorear> @src STArray
13:52:51 <lambdabot> data STArray s i e = STArray !i !i (MutableArray# s e)
13:52:57 <xerox> > (print . (+1) . read . tail . reverse) "54321"
13:52:57 <xerox> 2346
13:52:58 <sorear> there's one
13:52:58 <lambdabot>  <IO ()>
13:53:05 <xerox> :D
13:53:11 <sorear> @src STArray writeArray
13:53:11 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:53:18 <ddarius> (though I guess (.) is not an arrow generally)
13:53:26 <SamB> JohnMeacham: hmm.
13:53:44 <Syzygy-> ddarius: any function is an arrow. So (.) is an arrow.
13:53:52 <Syzygy-> Possibly not the kind of arrow you expect, but still.
13:54:34 <kilimanjaro> sorear, huh?
13:54:44 <sorear> 13:50 < kilimanjaro> Arrays are constructed from lists I thought
13:54:49 <kilimanjaro> sorear, I really meant match on the contents
13:54:49 <sorear> 13:51 < sorear> kilimanjaro: no, lists are too slow.  arrays are unsafe primitive magic
13:54:50 <ddarius> Syzygy-: In other categories, (.) is not an arrow of the category.
13:55:07 <kilimanjaro> ok sorry
13:55:14 <Syzygy-> ddarius: (.) is an arrow in Hask.
13:55:14 <mauke> depends on your definition of "constructed from"
13:55:17 <Syzygy-> :t (.)
13:55:19 <SamB> JohnMeacham: GHC seems to derive the instance regardless of whether it would actually typecheck with the extensions that are supposed to be in force :-(
13:55:19 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:55:21 <kilimanjaro> I missed that comment
13:55:51 <ddarius> Syzygy-: Yes it is.  And as I said, arrows aren't covariant/contravariant in the categorical sense, only functors are.
13:55:53 <xerox> Actually somebody should show this stuff to John Hughes. He introduces pointy arrow notation because one *can't* use (.) for points-free monad composition.
13:55:54 <Syzygy-> Or, since it is polymorphic, it is a family of arrows.
13:56:08 <Syzygy-> ddarius: Yah.
13:56:46 * Syzygy- just LOVES the level of discourse in this channel!
13:57:12 <shachaf> xerox: Show what?
13:57:38 <sorear> SamB: Contexts for derived instances are very, very, very hard.  Derive doesn't even *try* to do it right.
13:57:44 <SamB> JohnMeacham: that instance being like this:
13:57:46 <SamB> instance (Eq (m (Maybe a))) => Eq (MaybeT m a)
13:57:50 <SamB> sorear: yes, I see.
13:57:59 <sorear> SamB: I can't even see how to do it *with a typesystem*
13:59:35 <SamB> sorear: well apparantly GHC cheats
13:59:54 <SamB> sorear: I wonder how nyhc does it
14:00:07 <sorear> SamB: Very badly, from what I've heard.
14:00:22 <SamB> well I'm sure the code is horrible
14:00:31 <SamB> but it is possible that they do not cheat
14:01:09 <SamB> I guess crypt and checksum would, too
14:01:14 <SamB> hmm.
14:01:17 <rehges> yeah
14:01:21 <SamB> wrong channel.
14:01:22 <chessguy> wow
14:01:26 <rehges> wrong channel though :-)
14:01:39 <chessguy> i can't believe that something like this upTo combinator hasn't been written
14:01:41 <SamB> yes. I always notice right after I do that.
14:01:47 <sjanssen_> how does GHC cheat?
14:02:15 <SamB> sjanssen: well, I wrote this:
14:02:20 <puusorsa> what's the syntax for somethign like this ... instance Show a => Show (Foo a) where ...  but how do i do instance Show a b => Show (Foobar a b) .. ?
14:02:21 <SamB> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) } deriving Eq
14:02:46 <sorear> puusorsa: instance (Show a, Show b) => ...
14:02:57 <puusorsa> thanks
14:03:18 <SamB> sjanssen: now if I do :i MaybeT, I see:
14:03:20 <puusorsa> i think i tried everything but maybe not that
14:03:30 <Eelis_> does it annoy anyone else that (x ++ ": " ++) isn't a valid section?
14:03:30 <SamB> instance (Eq (m (Maybe a))) => Eq (MaybeT m a)
14:03:52 <SamB> Eelis: heck, Iwant (++ ":" ++) to be a valid section
14:04:06 <fasta> Eelis_: me
14:04:07 <ddarius> Eelis_: Mildly occasionally.
14:04:14 <puusorsa> weird stuff, haskell suddenly started making sense
14:04:16 <Eelis_> glad to hear i'm not alone :)
14:04:24 <ddarius> puusorsa: Oh noes!
14:04:30 <Eelis_> SamB: yeah, that would be neat
14:04:35 <sjanssen> SamB: doesn't seem much like cheating to me
14:04:42 <sjanssen> SamB: how else can you do it?
14:04:42 <ivant> @all-dicts homotopy
14:04:43 <lambdabot> No match for "homotopy".
14:04:47 <SamB> sjanssen: yes but it won't let ME write that instance head!
14:04:55 <sorear> SamB: that's a perfectly valid instance in Haskell 98
14:04:57 <ddarius> @google define:homotopy
14:04:58 <lambdabot> No Result Found.
14:05:05 <SamB> not without a LANGUAGE pragma or such
14:05:12 <sorear> SamB: Then GHC is broken.
14:05:15 <xerox> Aw. Hughes is right. Nevermind me :-)
14:05:22 <sjanssen> SamB: the head looks perfectly legal
14:05:25 <sjanssen> is the context legal?
14:05:26 <sorear> SamB: That is a perfectly good simplecontext.
14:05:41 <sorear> ah right
14:05:46 <xerox> I learnt something tonight :)
14:05:55 <sorear> I keep forgetting, instances are less general than contexts
14:06:14 <SamB> sorear: if I paste that in, and comment out the "deriving" clause, it rejects my file
14:06:17 <puusorsa> now i only have problems with the syntax but have at least some vague idea what i'm trying to get haskell to do :)
14:06:20 <SamB>     Non type-variable argument in the constraint: Eq (m (Maybe a))
14:06:23 <xerox> ?paste
14:06:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:06:29 <SamB>     (Use -fglasgow-exts to permit this)
14:06:46 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2064
14:06:54 <ddarius> Banana bread is good.
14:06:54 <xerox> shachaf: -^
14:06:57 <sorear> ivant: Intuitively, hopotopy is the equivalence relation on curves of a surface defined by smooth deformation.  A circle in the plane is homotopic to a point, but a circle in the punctured plane (with the origin removed) need not be.
14:07:02 <SamB> if I enable FlexibleInstances, it still wants -fundecidable-instances
14:07:47 <ddarius> s/smooth/continuous
14:07:47 <ivant> sorear, wow, thanks, that really helps
14:08:02 <xerox> The only thing we gain is (>>= print) . (length . filter (==w) . words .) . readFile -- if anything.
14:08:23 <SamB> hmm.
14:08:27 <ddarius> @google Algebraic Topology book
14:08:29 <lambdabot> http://www.math.cornell.edu/~hatcher/AT/ATpage.html
14:08:29 <lambdabot> Title: Algebraic Topology Book
14:08:34 <SamB> maybe I should try tihs with a "data" declaration?
14:09:04 <sjanssen> SamB: I imagine it's the same story
14:09:17 <sjanssen> hmm, is this instance really undecidable?
14:09:36 <SamB> sjanssen: oh. it's apparantly enabling generalized newtype deriving :-(
14:10:10 <sjanssen> yes, but it shouldn't use generalized deriving with 'Eq'
14:10:18 <shachaf> xerox: I wouldn't say that's clearer.
14:10:19 <jbgreer> Did Control.Monad.State.Strict first appear in mtl-1.0.1?
14:10:26 <shachaf> xerox: Even if you are used to (.) being fmap.
14:10:33 <shachaf> @let (.) = fmap
14:10:34 <lambdabot> <local>:3:6:     Ambiguous type variable `f' in the constraint:       `Functo...
14:10:36 <xerox> :-( too bad.
14:10:57 <sjanssen> MR--
14:10:58 <sorear> sjanssen: actually it does, because for Eq, Ix, Bounded, Ord generalized and standard are semantically equivalent, but generalized is faster
14:11:36 <int-e> chessguy: hmm. how about  upTo n p = liftM catMaybes (replicateM n (optionMaybe p))  [optionMaybe is rather new, optionMaybe p = option Nothing (liftM Just p)]
14:11:38 <sorear> @let (.) Î· = fmap Î·
14:11:38 <lambdabot>  Illegal character ''\183''
14:11:46 <shachaf> > let (.) = fmap in ((+1) . (*2)) . [1,2,3]
14:11:47 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `[a1]'
14:11:54 <shachaf> > let (.) = fmap in ((+1) . (*2)) `fmap` [1,2,3]
14:11:55 <lambdabot>  [3,5,7]
14:12:04 <shachaf> That's odd.
14:12:15 <SamB> sorear: I'm just thinking it shouldn't do that when you haven't enabled generalized newtype deriving...
14:12:20 <int-e> chessguy: it could exist but it's not that much code to write.
14:12:37 <xerox> > let (.) = fmap in (+1) . (*3) . [1..5]
14:12:38 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `[a1]'
14:13:12 * sorear wonders why Î· isn't allowed in lambdabot variable names... it *is* a lowercase letter
14:13:14 <xerox> shachaf: -fno-monomorphism-restriction
14:13:22 <chessguy> hmm
14:13:40 <chessguy> @pl u n p = l c (r n (o p))
14:13:40 <lambdabot> u = (l c .) . (. o) . r
14:13:54 <sjanssen> sorear: it's the pre-parser
14:14:05 <shachaf> xerox: Oh, right.
14:14:21 <sjanssen> sorear: it receives the list of octets, and it barfs at \183
14:14:25 <shachaf> > let (.) :: (Functor f) => (a -> b) -> (f a -> f b); (.) = fmap in ((+1) . (*2)) `fmap` [1,2,3]
14:14:27 <lambdabot>  [3,5,7]
14:14:29 <shachaf> > let (.) :: (Functor f) => (a -> b) -> (f a -> f b); (.) = fmap in ((+1) . (*2)) . [1,2,3]
14:14:30 <lambdabot>  [3,5,7]
14:14:34 <chessguy> @type optionMaybe
14:14:36 <lambdabot> Not in scope: `optionMaybe'
14:14:57 <chessguy> @type option
14:14:59 <lambdabot> Not in scope: `option'
14:15:18 <sorear> @type Text.ParserCombinators.Parsec.Prim.option
14:15:20 <lambdabot>     Not in scope: `Text.ParserCombinators.Parsec.Prim.option'
14:15:25 <sorear> @type Text.ParserCombinators.Parsec.Combinators.option
14:15:27 <lambdabot> Couldn't find qualified module.
14:15:43 <sorear> what was wrong with nice short ParsecPrim et al?
14:15:45 <int-e> .Combinator.
14:15:50 <sorear> @type Text.ParserCombinators.Parsec.Combinator.option
14:15:52 <int-e> hmm
14:15:52 <lambdabot> forall a tok st. -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
14:16:18 <sjanssen> SamB: btw, try your deriving example in Hugs
14:16:19 <chessguy> int-e, anyway, i guess if i'm going to write the code myself, i'm going to leave it in the more readable version i have
14:16:40 <xerox> sorear: I'm working on a new version of parsec, do you think we should move the modules in the hierarchy?
14:17:01 <xerox> I agree that is painful to import these days.
14:17:40 <sorear> xerox: It should be moved, not sure where to.  ParsecPrim was what they called it back when . wasn't valid in module names
14:17:46 <tyoc> people, I get this error: No lambdabot binary found in: /home/tyoc/localInst/goa I have added: setLambdabotHome "/home/tyoc/localInst/goa", then configure with that path, build and install, and do  $ cat dot-ghci >> ~/.ghci
14:17:58 <shachaf> tyoc: Did you install lambdabot?
14:17:59 <int-e> xerox: would exporting all (or most of) the parsec modules from Text.ParserCombinators.Parsec be a bad thing?
14:18:04 <tyoc> I guess not
14:18:08 <shachaf> @version -- From here
14:18:08 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
14:18:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:18:29 <tyoc> shachaf: thx for the link
14:19:11 <shachaf> tyoc: Lambdabot is a bit of trouble to build; there was a thread on haskell-cafe some time ago that can help you.
14:19:21 <shachaf> sorear: She works with 6.6.1 now, right?
14:19:21 <chessguy> hey sorear what do you use to grep the logs for this channel?
14:19:35 <SamB> sjanssen: okay, I've submitted a GHC bug for that...
14:19:39 <sorear> chessguy: GNU grep 2.5.1
14:19:52 <sorear> shachaf: yes
14:19:53 <tyoc> shachaf: I wil try to follow the instructions there, hope is enought with those directions
14:19:56 <wli> Why is lambdabot so difficult to build?
14:19:56 <chessguy> oh i didn't realize you could actually download them
14:19:57 <int-e> xerox: (the opengl lib does that, it spreads its implementation across several modules but has one module that exports them all, and so far I like it)
14:19:59 <xerox> int-e: nowadays it exports Prim Combinator Char and some selected functions from Error and Pos. The other modules are different libraries built on top of parsec. I don't think it is a good idea to export them that way.
14:20:02 <sjanssen> SamB: GHC's behavior might actually be more useful
14:20:03 <shachaf> wli: It wasn't for me.
14:20:16 <shachaf> wli: But a lot of people seem to have odd trouble with it.
14:20:42 <sjanssen> SamB: the instance generated requires undecidable instances, but it isn't actually undecidable unless the instance for 'm' is bad too
14:20:47 <sorear> chessguy: sure, they're on the web, you can download anything on the web
14:20:58 <sorear> http://hpaste.org/1979 <- my automatic incremental download script
14:21:13 <chessguy> i'll just use wget :)
14:21:22 <xerox> The libraries are Expr, Language, Perm and Token.
14:21:25 <int-e> xerox: oh never mind then
14:22:14 <wli> The token combinators all want some sort of language def.
14:22:42 <wli> I typically feed them emptyLanguageDef
14:24:26 <SamB> sjanssen: yes but it doesn't seem to be on purpose
14:24:40 <wli> I can't figure out what the Utrecht combinators are actually doing.
14:25:03 <SamB> if you want typesystem extensions like that, you usually have to use some kind of flag or pragma
14:27:25 <SamB> what kind of annoying jerk puts question marks in their filenames...
14:27:56 <mauke> 'What, me worry?.txt'
14:28:07 <SamB> http://hackage.haskell.org/trac/ghc/ticket/1581
14:28:08 <lambdabot> Title: #1581 (:info doesn't show all instances) - GHC - Trac
14:29:39 <SamB> okay, maybe not a jerk
14:30:35 <SamB> who was it that suggested iampure might be an alias for qwe1234?
14:30:50 <SamB> if it is, we have qwe1234 to thank for lots of good bug reports
14:31:24 <SamB> I think
14:34:05 <SamB> http://hackage.haskell.org/trac/ghc/query?group=priority&reporter=iampure%40gmail.com&order=id&desc=1
14:34:07 <lambdabot> Title: Custom Query - GHC - Trac, http://tinyurl.com/34qjc6
14:36:15 <toostrong_2851> http://www.pennergame.de/ref.php?uid=2851
14:36:16 <lambdabot> Title: Pennergame
14:38:52 <tyoc> Setup.hs: cannot satisfy dependency zlib-any, I have been able to find the others bindings with synaptic, but not this 1
14:39:55 <eivuokko> tyoc, Perhaps http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib-0.3
14:39:57 <lambdabot> http://tinyurl.com/ypj2uf
14:43:10 * wli can't tell how the Utrecht combinators work.
14:44:37 <wli> If there's a state machine in there as "Machine.hs" suggests it's non-obvious to me (I can't make heads or tails of Machine.hs actually).
14:44:58 <sjanssen> SamB: I think that's fasta
14:45:21 <sjanssen> "anotherbugdownhowmanyleft?millions?.tar.gz" is pretty rude IMO
14:46:03 <sorear> SamB: qwe1234 has a LJ user page written in a Cyrillic language.  iampure's identities all resolve to the netherlands.  I think this points to them being different people.
14:47:43 <sjanssen> I'm 75% certain that this bug was reported by fasta
14:47:50 <sjanssen> he was complaining about this issue the other day
14:48:06 <sorear> fasta is iampure.  He's said so himself.
14:48:12 <aip> how can i get a list of all available Modules from the GHC api?
14:48:37 <eivuokko> ghc-pkd describe ghc
14:48:53 <eivuokko> *ghc-pkg
14:48:56 <xerox> This is cute. <http://www.madprime.org/articles/2006/03/15/dna-computation>
14:49:01 <sorear> however, fasta/iampure has also said that he's been making an effort to hide his true identity.
14:49:54 <sorear> And it shows.  Usually a few minutes with google turns up a lot more than a ISP and a first name. :)
14:50:04 <aip> eivuokko: i mean what function from the GHC api will return a list of all modules available in all installed packages
14:50:59 <eivuokko> aip, Ah, ok.  Sorry, dunno that :)
14:52:26 <aip> eivuokko: hm... maybe i can parse the output from ghc-pkg describe.... thanks!
14:52:59 <eivuokko> aip, Uhoh o.O
14:55:04 <shachaf> sorear: Google finds "Ron de Bruijn". It might be wrong, but it's more than a first name.
14:55:28 <shapr> @yow !
14:55:28 <lambdabot> Did you move a lot of KOREAN STEAK KNIVES this trip, Dingy?
14:56:03 <sorear> shachaf: you arrived at the same first name as me, at least...
14:56:39 <shachaf> sorear: http://unix.derkeiler.com/Mailing-Lists/FreeBSD/questions/2005-05/1927.html -- One of a few results with that name for iampure.
14:56:41 <lambdabot> Title: freebsd-questions: Re: [USB Printing+Cups] Printing does respond, but doesn't pr ..., http://tinyurl.com/37yelo
14:57:22 <mauke> are you stalking someone?
14:57:28 * shapr stalks mauke 
14:57:45 <sorear> mauke: I hadn't been planning on announcing the results in the channel :(
14:57:56 <shachaf> sorear: Oh. Sorry.
14:58:35 <shachaf> sorear: It is "a few minutes with google", though.
14:58:37 <SamB> sorear: the fact that fasta told me he's iampure is another good clue
14:58:50 * mauke sends shapr to http://www.youtube.com/watch?v=g-9Tho7a4TI
14:59:21 <SamB> sjanssen: too
14:59:36 <chessguy> @get-slap
14:59:37 <lambdabot> shapr!!
15:00:43 <tyoc> a ya, I get the lambdabot in GOA>
15:00:45 <tyoc> :D
15:01:00 <tyoc> now I guess I need to learn... some things :D
15:01:15 <sorear> tyoc: You actually succeeded in building lambdabot?
15:01:25 <tyoc> yep, I write :bs
15:01:28 <tyoc> and it answer
15:01:29 <tyoc> :bs
15:01:33 <tyoc> :D
15:01:34 <shachaf> sorear: Why does everybody make such a big deal about it?
15:01:39 <shachaf> @help bs
15:01:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:02:28 <sorear> shachaf: Because it's very hard.  Lambdabot was designed for exactly one person at a time.  We have oral traditions, documentation is unneeded in the one-user case.
15:02:47 <SamB> why is GHC's trac using US-format dates?
15:02:50 <shachaf> sorear: It was pretty easy for me last time I tried it.
15:02:54 <SamB> I want programmer-format dates!
15:03:05 <shachaf> sorear: All I did was remove a dependency from the .cabal and follow the README, I think.
15:03:12 <tyoc> sorear: thought I dont know if it is working correctly...
15:03:54 <wli> You could always write your own IRC bot.
15:04:11 <shachaf> wli: Except tyoc doesn't want an IRC bot.
15:04:19 <shachaf> wli: Just a fancy GHCi.
15:04:27 <tyoc> ya :)
15:04:34 <wli> schachaf: Fancy how?
15:04:44 <shachaf> wli: Whatever is fancy about lambdabot.
15:04:46 <tyoc> how I test it??, more than introduce :bs???
15:04:58 <shachaf> tyoc: Does :pl work?
15:05:08 <wli> shachaf: Presumably @pl, @hoogle,, @djinn, etc., then.
15:05:13 <tyoc> No lambdabot process :S
15:05:15 <shachaf> wli: Yes.
15:05:25 <shachaf> tyoc: I guess not, then.
15:05:28 <tyoc> I guess that is bad
15:05:33 <tyoc> lol
15:05:38 * shachaf tried GoA once.
15:05:49 <tyoc> tought I can run /usr/local/bin/lambdabot
15:05:51 <shachaf> I didn't like how typing :m brought back the Prelude.
15:06:18 <shachaf> Hmm, http://lambdabot.codersbase.com/ is still broken.
15:06:19 <lambdabot> Title: Lambdabot Web Interface
15:06:21 <wli> shachaf: I'd like to define datatypes at the command line.
15:06:38 <shachaf> wli: So would I, but GHCi can't do it.
15:07:01 <shapr> chessguy: You called?
15:07:02 <wli> shachaf: It shouldn't really be that far out (of course, I say that now...)
15:07:03 <tyoc> If I call directly lambdabot from the command line I can write:  !help
15:07:03 <tyoc> IrcMessage {msgServer = "offlinerc", msgLBName = "offline", msgPrefix = "null!n=user@null", msgCommand = "PRIVMSG", msgParams = ["offline",":help"]}
15:07:10 <SamB> sorear: I thought lambdabot was supposed to be buildable by all contributors without TOO much gymnastics?
15:07:14 <chessguy> shapr, not i!
15:07:38 <shapr> ah well
15:07:42 <sorear> tyoc: no !
15:07:58 <tyoc> no what?
15:08:05 <sorear> shapr: kaol called to alert you to http://yadogg.com/ups/unipsycho.jpg
15:08:22 <ddarius> wli: It's not all that hard to do, but I don't think anyone is bothering to do it.
15:08:36 <chessguy> oh wow
15:08:39 <chessguy> that's ridiculous
15:08:39 <hpaste>  Gwern pasted "archive-bot - nonfunctioning loop" at http://hpaste.org/2065
15:08:39 <ddarius> wli: hbc did it over a decade ago
15:08:47 <shachaf> tyoc: Just "help", I think?
15:09:05 * wli checks free disk space.
15:09:12 <chessguy> actually, it looks kinda fake too
15:09:13 <shapr> sorear: I think it was dons, but the server gives 503 :-(
15:09:27 <sorear> shapr: Funny, it works for me.
15:09:33 <gwern> so I'm trying to have my bot do a loop, where it feeds in an entry, processes it, and then removes it from a file, but it doesn't seem to be working when I actually run it
15:10:01 <sorear> shapr: now it doesn't
15:10:38 <monochrom> "remove from a file"?
15:10:59 <gwern> monochrom: yeah. it just deletes the first n lines, and each entry is a line to itself, so...
15:12:23 * wli darcs gets http://darcs.haskell.org/ghc/
15:12:24 <lambdabot> Title: Index of /ghc
15:13:13 <monochrom> The illusion of deleting lines in a file is accomplished by storing the entire original file in some other place (memory or another file or a mix of both), then overwriting the original file with whatever you want to keep.
15:13:31 <monochrom> This is so whether you use Haskell or C or Java or ...
15:13:37 <gwern> monochrom: yup, I used strict bytestrings to pull it into memory
15:13:42 <gwern> and then cp it back out
15:14:09 * gwern is still puzzled that this seems to be the only way to accomplish it, but that's not important here
15:14:20 <wli> Not entirely.
15:14:56 <wli> At *some level* that's what's done, but you can get things rather clean-looking to the upper layers.
15:16:30 <wli> Mostly you need to remember the offsets of newlines.
15:17:03 <tyoc> I see :pl work now with GOA?? (line 1, column 1):                   unexpected end of input               expecting white space, natural, identifier, lambda abstraction or expression
15:18:10 <monochrom> So, are you first discarding things in memory? A loop in which you discard things in memory? After the loop, write the remaining stuff to file?
15:18:14 <wli> Two very large factors in all this are laziness and incrementality, and not at a level where a lazy language helps.
15:18:26 <wli> gwern: Are you writing an editor?
15:18:40 <sjanssen> tyoc: what exactly did you type?
15:18:51 <gwern> wli: no, a utility for a wikipedia bot processing external links
15:18:56 <sjanssen> tyoc: I'd expect that output if you typed ':pl'
15:19:20 <tyoc> I see: Could not find hoogle database, looked for: State/hoogle.txt ??
15:19:30 <gwern> monochrom: take a given file, with one item per line. each item is the name of a WP article. spider said article, request that all URLs be archived, then delete that article's line from the file. repeat indefinitely.
15:19:40 <shachaf> @pl
15:19:40 <lambdabot> (line 1, column 1):
15:19:40 <lambdabot> unexpected end of input
15:19:40 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
15:19:49 * gogonkt_ is back (gone 03:21:04)
15:19:52 <tyoc> sjanssen: only :pl
15:20:07 <sjanssen> tyoc: it wants an expression
15:20:11 <sjanssen> @pl \x -> x
15:20:11 <lambdabot> id
15:20:20 <gwern> (the error message looks like: archive-bot: "/home/gwern/bin/pywikipedia/en: openFile: resource busy (file is locked)")
15:20:30 <tyoc> a ya, that is what I get
15:20:45 <gwern> but I can't figure out why, since to me it looks like everything is sequenced right
15:20:48 <shachaf> tyoc: So it works.
15:20:58 <shachaf> Hmm, does GoA work with @src?
15:21:10 <tyoc> yes, dont know why, perhaps a restart of the gnome-terminal or something like that
15:21:34 * gwern wonders if perhaps the problem isn't the forkIO
15:22:03 <wli> darcs doesn't seem too RAM- or CPU- hungry here, but it does appear to be network-bound.
15:22:07 <tyoc> I think no unknown command ':src'
15:22:25 <xerox> tyoc: you ought to define new commands yourself
15:22:36 <xerox> Check out your ~/.ghci or whatever is called
15:22:38 <xerox> It's easy.
15:22:43 <monochrom> Is it like this? open file for reading; reading all of file into s; close file; loop { discard stuff in s, and other things }; open file, pour remaining s into file; close file.
15:22:47 <tyoc> OK
15:23:26 <wli> Do I need to do anything special before I start editing in a darcs repo?
15:23:42 <gwern> monochrom: that's equivalent, although right now I'm interspersing the 'pouring' part as the loop is running
15:23:43 <xerox> wli: no
15:23:59 <wli> Sounds good, then.
15:24:08 <monochrom> Ok, make very sure paranoidly that "close file" happens before the loop begins.
15:24:26 <tyoc> :source                    not available
15:24:35 <xerox> darcs whatsnew will show you all of the modifications; darcs record will guide you through recording them; darcs send -o /tmp/foo.patch in case you haven't got sendmail or compatible to send the patch mainstream
15:24:46 <tyoc> I think I need configure and get
15:24:50 <monochrom> There are other ways if you're interested.
15:25:05 <aip> wli: only thing you really need to know is don't move files around. you must use the darcs mv command to move a file
15:25:23 <tyoc> but it is already there, OK, I will continue reading and see if to the end of the day I can get a usable piece of code...
15:25:25 <wli> aip: Sounds good to me.
15:26:18 <wli> xerox: I self-host so I should be able to send easily enough.
15:26:33 <Baughn> Is there a strict form of hGetContents?
15:26:37 <monochrom> Basically if you open a file twice simultaneously (obtaining two distinct Handles for the same file, neither is closed during the time the other exists), there are [obvious] locking issues.
15:27:23 <monochrom> Baughn: strict bytestring provides some
15:27:53 <monochrom> None for ordinary string in standard IO library.
15:28:01 <wli> Am I the only one who's never had an issue with the plain old string implementation's performance?
15:28:17 <monochrom> I am another one. :)
15:28:41 <gwern> (in another language, I'd probably return a '1' for each loop, update a counter +=, and then remove the first (counter) lines, but haskell doesn't make updateable variables easy, so...)
15:28:44 <monochrom> I haven't processed "megabytes after megabytes" of file data.
15:29:03 <chessguy> try reading Endo's DNA with regular strings :)
15:29:10 <wli> I have, but the IO itself is usually the killer.
15:29:28 <monochrom> gwern: That is not an issue IMO. It is the open-close event sequence that counts.
15:29:34 <wli> The case of giant in-core files is kind of odd.
15:29:55 <Igloo> SamB: If you want to second a bug then you should add yourself to the CC list
15:30:05 <monochrom> And open-close event sequences give you the same outcome in Haskell or C or Java or ...
15:30:13 <Baughn> monochrom: No "reduce to normal form" functions anywhere?
15:31:22 <monochrom> Control.Parallel.Strategies  look for class NFData
15:31:28 <xerox> ?type ($| rnf)
15:31:30 <lambdabot> forall a b. (NFData a) => (a -> b) -> a -> b
15:31:51 <chessguy> @hoogle rnf
15:31:51 <monochrom> Fortunately [Char] is an instance, so you're set. :)
15:31:51 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
15:33:09 <wli> darcs' RSS never topped 100MB
15:33:16 <wli> 84.92user 45.01system 20:53.82elapsed 10%CPU (0avgtext+0avgdata 0maxresident)k
15:33:16 <wli> 0inputs+0outputs (5major+349605minor)pagefaults 0swaps
15:33:22 <monochrom> For maximal internationalization and political correctness, I would use bytestring's I/O library (and I can choose between eager and lazy) and then pump it through the encoding library.
15:33:25 <wli> OTOH that's prohibitively slow.
15:33:58 <monochrom> IMO the ISO-8859-1 assumption is simply incorrect politically.
15:34:03 <Baughn> monochrom: Actually, "last text `seq` hClose handle` worked fine. :)
15:35:24 <monochrom> somehow that (and length text) looks kludgy to me. but don't argue, I'm not arguing either, just saying a subjective feeling.
15:35:51 <monochrom> (It's your program and it's your call :) )
15:36:09 <Baughn> To me it reads like "I want (last text) to be available before you close the handle"
15:36:28 <monochrom> I guess that makes sense.
15:37:02 <Baughn> Next up: Do something smarter than "rewrite entire database on each change"
15:38:02 <monochrom> If you don't mind seeking back and forth a million times, there is a way. (This applies to deleting some stuff from a file too.)
15:38:18 <Baughn> I'd rather use anydbm
15:38:39 <Baughn> This is a webhost issue, though. They need to install it, and until they do, I'll happily much hd bandwidth.
15:39:27 <monochrom> So here is a way of deleting the first three lines from a file. First you must find out how many bytes. Let's say 25. Seek to position 25, read in 25 bytes or fewer, seek to position 0, write them; etc.
15:40:05 <Baughn> ..oh lord
15:40:27 <Baughn> That looks ever so much worse than reading in the entire thing at once. ;)
15:40:42 <monochrom> What sucks is that your buffer cannot exceed 25 bytes, lest you lose data in the file. So you incur lots of syscall overhead. But at least you don't have to slurp whole file into memory or something.
15:40:44 <sorear> You could automate it with lazy bytestrings
15:41:01 <int-e> monochrom: why would you lose data?
15:41:04 <sorear> monochrom: You can use a larger buffer
15:41:10 <monochrom> Wait a second. I'm wrong.
15:41:19 <monochrom> OK, problem solved. :)
15:46:29 <monochrom> If you can design clever data structures ("clever" means maybe 0.1 oleg), you can accumulate some efficient representation of many successive changes you want to make to a file, then you need only read once and write once.
15:48:14 <monochrom> Hmm, version control as generic zipper a la Oleg?
15:48:18 <wli> I don
15:48:34 <wli> I don't see where anything is happening in ghci, as expected
15:48:56 <ndm> anyone have a good tutorial to read on MTL?
15:49:05 <ndm> the one thats mentioned in the docs is 42 pags long
15:49:19 <ndm> i just want to combine a state and abort
15:49:28 <ndm> get/put/abort
15:49:31 <monochrom> The haskell wiki book has stuff.
15:49:31 <SamB> ndm: how do you wish to combine them?
15:49:38 <ndm> where abort makes the computation return a Nothing
15:49:51 <SamB> oh.
15:49:55 <monochrom> "haskell wikibook" is http://en.wikibooks.org/wiki/Haskell
15:49:57 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
15:50:01 <SamB> so like MaybeT State
15:50:14 <SamB> (nevermind that MaybeT is missing from the MTL...)
15:50:31 <ddarius> StateT Maybe
15:50:39 <ndm> my guess was MaybeT, but either is fine
15:50:45 <ndm> i'll read the wikibook, thanks
15:50:58 <SamB> ndm: what do you want to be returned if you don't call abort?
15:51:29 <ndm> SamB, Just, with the state
15:51:36 <SamB> okay.
15:51:42 <ndm> actually, on abort i want to return a value
15:51:48 <SamB> ah.
15:51:56 <ndm> so I'd ideally like to return Either the state, or a value
15:52:08 <SamB> hmm.
15:52:15 <SamB> actually let's see...
15:52:19 <SamB> I think ddarius is right
15:52:29 <SamB> StateT (Either e)
15:52:51 <ndm> hmm, makes sense
15:52:56 <SamB> :t runStateT (Left ?e)
15:52:59 <lambdabot>     Couldn't match expected type `StateT s m a'
15:52:59 <lambdabot>            against inferred type `Either a1 b'
15:53:03 <ndm> i'll read the wikibook for background, then may be back for more :)
15:53:07 <SamB> erg.
15:53:15 <SamB> :t runStateT (fail ?e)
15:53:17 <lambdabot> forall s (m :: * -> *) a. (?e::String, Monad (StateT s m)) => s -> m (a, s)
15:53:18 <kilimanjaro> Is there a reason why someone would prefer xmonad over wmii or existing alternatives, other than for the fact that xmonad is written in Haskell?
15:53:43 <SamB> :t runErrorT (fail ?e)
15:53:45 <lambdabot> forall e (m :: * -> *) a. (?e::String, Monad (ErrorT e m)) => m (Either e a)
15:54:21 <SamB> yeah. StateT it is
15:54:24 <gwern> kilimanjaro: better layouts and extensions
15:54:28 <ndm> kilimanjaro: smaller code base, easier to modify, static guarantees, can be scripted in Haskell
15:54:57 <kilimanjaro> gwern, ahh I'll have to check it out then
15:55:12 <SamB> ndm: how is any of that "other than ... Haskell"?
15:55:32 <wli> aha
15:55:34 <ndm> SamB: not everyone knows that written in Haskell => superior
15:55:45 <wli> hscParseType is what I want.
15:55:50 <SamB> well when all the other choices are written in C and a lot bigger?
15:56:14 <SamB> I mean, just look at the propaganda that came with A Taste of Haskell
15:56:17 <monochrom> static guarantees are nice.
15:56:25 <SamB> S/propaganda/slides/
15:56:25 <kilimanjaro> for what?
15:56:32 <chessguy> hmm. http://en.wikibooks.org/wiki/Haskell/Practical_monads#Generic_monads is it related to dons' IdentityT idea?
15:56:34 <lambdabot> http://tinyurl.com/yog84n
15:56:45 <SamB> IdentityT sounds kinda silly
15:56:50 <ndm> kilimanjaro: there is a static proof that a certain subset of it won't crash
15:57:02 <ndm> kilimanjaro: the pure subset, where most of the logic code lives
15:57:03 <SamB> I have a perfect implementation of IdentityT
15:57:17 <sorear> Beware, crash is a very overloaded word.
15:57:31 <SamB> type IdentityT m a = m a
15:57:40 <sorear> Robin Milner proved that 100% of xmonad won't crash - twenty years ago!
15:57:47 <SamB> I suppose that doesn't implement MonadTrans, but hey.
15:57:54 <kilimanjaro> ndm, well, I was talking about features
15:57:56 <monochrom> @remember sorear Robin Milner proved that 100% of xmonad won't crash - twenty years ago!
15:57:56 <lambdabot> Done.
15:58:02 <SamB> it lifts everything else seamlessly ;-)
15:58:06 <gwern> thought it was just a guarantee of no failure in pattern matching
15:58:06 <EvilTerran> SamB, i guess the point is that a debugging transformer can be dropped in in its place or something
15:58:12 <kilimanjaro> ndm, that's helpful for developers, but I haven't had a C wm crash on me either
15:58:30 <SamB> EvilTerran: oh.
15:58:33 <mauke> I've had wmii crash
15:58:44 <kilimanjaro> under what circumstances? just curious
15:58:45 <EvilTerran> i've broken gnome a few times
15:58:49 <sorear> kilimanjaro: When dwm was as old as xmonad is now, it crashed frequently (according to dons)
15:58:57 <mauke> I don't remember the details
15:59:02 <sorear> it took years to stabilize
15:59:02 <SamB> WindowMaker gets wedged on me a lot :-(
15:59:04 <chessguy> EvilTerran, i'm not sure what the difference is between a debugging transformer and a debugging monad though
15:59:38 <mauke> what sucks about wmii is that half of it is a shell script
15:59:45 <SamB> of course, WindowMaker would probably still crash even if you wrote it in Haskell
16:00:09 * SamB wishes WindowMaker would actually CRASH instead of becoming unusable
16:00:17 <monochrom> There are many shades of "written in haskell".
16:00:22 <wli> hscParseStmt Thus far I've determined that ghci doesn't even attempt to parse types.
16:00:29 <SamB> (if it did that, it'd probably succeed in restarting itself)
16:00:53 <gwern> wait, that's what was causing my error! readFile is lazy so it wouldn't release a lock until the entire thing had been read in!
16:01:06 * SamB percieves that his internet radio has fallen back to nectarine again
16:01:13 <xerox> http://www.haskell.org/pipermail/xmonad/2007-July/001393.html
16:01:14 <lambdabot> Title: [Xmonad] xmonad crashing
16:01:26 * gwern comforts lazy IO. You were the reason for my problem, but I still love you anyway
16:01:30 <monochrom> See, told you, need to make very sure paranoidly that file is closed before a certain time.
16:02:28 <gwern> yeah. but this is proving to be seriously difficult. maybe I will go back to the lazy version controlled by a shell script loop
16:02:42 <kilimanjaro> mauke, yea, I hate that about it
16:02:46 <SamB> xerox: that's clearly not happening in the pure part
16:03:43 <ddarius> kilimanjaro: xmonad is too featureful for me, why would I want a more featureful window manager written in C?
16:04:25 <aFlag> I'm trying that xmonad right now
16:04:34 <aFlag> I found it cool
16:04:53 <monochrom> Here, we don't want anything featureful written in C. :)
16:04:58 <aFlag> if it had a notification area it would be perfect
16:05:15 <ddarius> notification area?
16:05:33 <aFlag> yeah, systray, that thing where programs like gaim go
16:05:39 <wli> Well, I have a vague idea of what's missing but not all that good of one.
16:06:12 <wli> I basically found where it doesn't even try to parse types.
16:06:22 <ddarius> aFlag: I don't use it, but xmonad leaves that to other programs.  The only support it has is you can leave part of the screen free for them.
16:07:06 <aFlag> yeah, I don't know any other programs that do that, besides the applets for gnome panel and an applet for kde, do you know of any?
16:07:10 <ddarius> aFlag: Here's a blog from one person who changed his opinion on this topic, http://gimbo.org.uk/blog/2007/05/30/xmonad-does-status-bars-right/
16:07:12 <lambdabot> Title: gimboland » Xmonad does status bars right by not doing them at all, http://tinyurl.com/2cxhbo
16:07:50 <wli> I wonder how long it will take for xmonad to turn into Beryl-in-Haskell.
16:08:22 <ddarius> aFlag: dzen is mentioned, xmobar, I believe, is similar to dzen but written in Haskell and aimed at xmonad.  You should be able to use the gnome/kde applets if you want.
16:08:50 <aFlag> hm, that's great
16:09:08 <ddarius> http://www.xmonad.org/contrib.html
16:09:09 <lambdabot> Title: xmonad : contributed code
16:10:37 <SamB> gaim works fine with no systray anyway
16:11:49 <chessguy> @pl l f sMT = sMT >>= \x -> return $ f x
16:11:49 <lambdabot> l = fmap
16:12:19 <ddarius> pl laid the smack down on you.
16:12:25 <mauke> actually, l = liftM
16:12:25 <monochrom> haha
16:14:48 <ndm> hmm, so I want StateT/Either, I'm pretty sure
16:14:57 <ndm> but Either only has a monad instance for String?
16:15:13 <SamB> ndm: oh.
16:15:18 <SamB> are you sure?
16:15:23 <ndm> perhaps? I've never used Either as a monad
16:15:28 <SamB> @instances MonadError
16:15:31 <hpaste>  xerox pasted "ndmonad :)" at http://hpaste.org/2066
16:15:32 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
16:16:14 <kilimanjaro> ddarius, I don't know, I do like the floating layer
16:16:39 <ndm> thanks xerox
16:16:44 <xerox> You're welcome
16:17:35 <Philippa> ndm: ping?
16:18:02 <ndm> Philippa: pong
16:18:24 <Philippa> see PMs
16:18:48 <ndm> Philippa: just looking up how to do that in iriss, i seem to have two additional channels...
16:19:03 <Philippa> alt-<screennumber> or /window <number>
16:19:17 <Baughn> esc-number, hereabouts
16:19:21 <Philippa> one of them'd be PMs from me, one presumably from someone else
16:20:02 <ddarius> kilimanjaro: I like that too.  I don't use the status bar gaps and I don't use tiling (though I would want it to be available)
16:20:04 <ndm> give me a few mins, back soon
16:20:14 <ddarius> I don't use Xinerama either.
16:20:33 <ddarius> @instance Monad Either
16:20:33 <lambdabot> Maybe you meant: instances instances-importing
16:20:39 <ddarius> @instance Monad
16:20:39 <lambdabot> Maybe you meant: instances instances-importing
16:25:46 <chessguy> i wonder if the first example at http://haskell.org/haskellwiki/Simple_StateT_use could be expanded by transforming it with a few more simple transformers. what would be typical, simple transformers that could be applied?
16:25:46 <lambdabot> Title: Simple StateT use - HaskellWiki
16:25:53 <chessguy> i'm thinking like a WriterT for logging
16:26:20 <kilimanjaro> ddarius, do you live out of emacs?
16:26:45 <ddarius> kilimanjaro: No.  I use vim, but I don't live out of it either.
16:27:03 <kilimanjaro> (the only things I want in a WM are simple tiling and a floating layer for poorly behaved applications)
16:27:15 <SamB> ddarius: it's probably not as easy to live out of vim...
16:27:31 <kilimanjaro> I was just curious about xmonad because I see links about it on reddit pretty much daily
16:27:51 <ddarius> kilimanjaro: That would be due to dons.
16:27:55 <basti_> chessguy: i dont know, maybe STM?
16:28:08 <EvilTerran> you can live pretty well out of screen+vim
16:28:20 <SamB> basti_: STM isn't a transformer...
16:28:22 <jql> very true
16:28:38 <SamB> EvilTerran: well, that's more screen than vim
16:28:54 <EvilTerran> true. but it does help to have a text editor.
16:29:00 <SamB> yes
16:30:10 <chessguy> maybe ErrorT for if you abuse the stack?
16:30:38 <kilimanjaro> ddarius, ahh, well, I just figured the Haskell community has a good PR team
16:33:21 <ndm> type StateFail state failure result = StateT state (Either failure) result
16:33:37 <ndm> thats what i think we'll be doing for the state/error monad
16:33:44 <ndm> get/put are obvious, but what about failure?
16:33:54 <ndm> liftM (fail "message") ?
16:40:23 <ddarius> kilimanjaro: It does.  dons.
16:42:24 <lament> is xmonad usable?
16:42:38 <lament> (i suppose, i know people who use it, so...)
16:42:51 <lament> (so nevermind that question)
16:50:50 <Cale> lament: If you like tiling window managers :)
16:50:52 <ddarius> "For a time we tested for equality using an unholy mix of object identity and structural equality"
16:54:17 <ddarius> "The ugliness of our code and our difficulties with pointers sent us for help."
16:55:34 <ddarius> @seen dons
16:55:34 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 8h 7m 27s ago.
16:56:18 <ddarius> @tell dons http://www.eecs.harvard.edu/~nr/pubs/zipcfg-abstract.html for reddit perhaps?
16:56:18 <lambdabot> Consider it noted.
17:00:45 <mrd> :
17:00:49 * mrd reloads
17:02:26 <Shine> I'm trying to write my first Haskell program, what do you do in Haskell if you have a function with many arguments, like written with keywords in Lisp, e.g. "defun circle (&key x0 y0 radius line-width)"
17:03:19 <shachaf> Shine: Haskell doesn't have variable or named arguments, as such.
17:03:45 <shachaf> Shine: (Though there are exceptions.)
17:04:10 <Cale> Shine: you can create a record data structure which would have named fields
17:04:22 <Cale> But otherwise, parameters are just positional.
17:04:43 <Lamperi> mmm
17:05:42 <mrd> :
17:05:44 <mrd> gaah
17:06:06 * ddarius would point at UsingRecords on HaWiki, but it is no longer easily accessible.
17:06:32 <ddarius> http://209.85.165.104/search?q=cache:vV5M8k7T8C8J:www.haskell.org/hawiki/UsingRecords+UsingRecords+inurl:hawiki&hl=en&ct=clnk&cd=1&gl=us&client=firefox-a
17:06:34 <lambdabot> http://tinyurl.com/yuoo9e
17:06:52 <lament> was hawiki just burned with all its contents?
17:07:15 <Shine> Cale: what do you mean with positional? If I call the function like this: "circle 10 20 5 2" and I read this later, I don't know the meaning of each parameter. I'll take a look at records
17:07:40 <monochrom> hawiki is hidden away somewhere
17:07:56 <lament> Do you actually have a circle function?
17:08:02 <Cale> Shine: well, often the type of circle will tell you
17:08:03 <lament> What does it do?
17:08:26 <ddarius> Shine: Another trick that is common is to have more primitive things and make combinators for more complex things.
17:09:00 <ddarius> E.g. translate (x,y) (scale radius unitCircle)
17:09:43 <Cale> Yes, that's a much nicer way to handle things in general.
17:09:53 <Shine> ddarius: thanks, this looks good
17:11:00 <Shine> I'm trying to convert my functional texture example I've written some time ago: http://www.frank-buss.de/lisp/texture.html and using even more combinators is a good idea :-)
17:11:02 <lambdabot> Title: Functional Texture
17:15:00 <codetoad> i'm working through yaht, and when i try and do :m FiniteMap in ghci i get "Could not find module `FiniteMap`: it is a member of package ghc-6.6, which is hidden"
17:15:12 <Cale> codetoad: :m + Data.Map
17:15:22 <Cale> codetoad: It's possible that part is out of data
17:15:24 <Cale> date*
17:15:36 <codetoad> What does the plus sign do there?
17:15:42 <shachaf> Cale: Yes, YAHT still talks about Data.Map.
17:15:47 <Cale> Oh, it adds it to the current module set
17:15:51 <shachaf> codetoad: Adds it to the list of modules.
17:15:55 <Cale> Rather than replacing the current module set
17:15:56 <shachaf> codetoad: Rather than replace the list of modules.
17:16:01 <Cale> FiniteMap was the old name for Data.Map
17:16:17 <shachaf> Cale: I mean, YAHT still talks about FiniteMap...
17:16:23 <codetoad> thank you
17:16:27 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
17:16:28 <lambdabot> http://tinyurl.com/uywvm
17:16:39 <Cale> There's some documentation in case the API has changed a bit.
17:16:45 <Cale> (I think it has, too)
17:17:20 <SamB> Cale: no it wasn't. it was the old name of Data.FiniteMap, which is incompatible with Data.Map
17:17:51 <Cale> SamB: They serve the same purpose.
17:18:25 <SamB> well, yes
17:18:34 <SamB> Data.Map is definately the replacement
17:28:52 <Binkley> ?yow
17:28:52 <lambdabot> Hello.  Just walk along and try NOT to think about your INTESTINES
17:28:52 <lambdabot> being almost FORTY YARDS LONG!!
17:29:11 <chessguy> @quote
17:29:11 <lambdabot> pesco says: "Scientists Reveal: Human Consciousness Stems From Two Files in Different Directories!"
17:29:25 <chessguy> wha...
17:30:05 <SamB> @quote type
17:30:06 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
17:30:09 <SamB> @quote type
17:30:09 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
17:30:22 <SamB> @quote type
17:30:23 <lambdabot> qwe1234 says: every half-assed dynamically-typed, ass-slow scripting language is Lisp but a bit different
17:30:29 <hpaste>  Gwern annotated "archive-bot - nonfunctioning loop" with "Looks better, but IO is giving me inscrutable type error" at http://hpaste.org/2065#a1
17:31:03 <SamB> wow. something with which I actually agree with qwe1234 on!
17:31:08 <Binkley> Gwern: can you paste the type error too?
17:31:11 <Gwern-away> near as I can tell, the 'liftM B.lines $ B.readFile en' produces a IO [B.ByteString] for tmp to use, but neverthless, attempts to supply it as an argument to tmp fail
17:31:14 <Binkley> SamB: well, even a broken clock is right twice a day
17:31:27 <SamB> Binkley: yes but it can't help that
17:31:46 <Binkley> @quote qwe1234
17:31:47 <lambdabot> qwe1234 says: good lord, help me. i feel like i'm trapped in a website full of elizabots.
17:31:48 <SamB> qwe1234 is more capable, and could manage to disagree with me most of the time
17:32:04 <SamB> @quote qwe1234
17:32:05 <lambdabot> qwe1234 says: 'static' and 'dynamic' are disjoint sets. no matter if you're talking about typing or anything else.
17:32:41 <chessguy> @quote static
17:32:41 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
17:32:41 <lambdabot> true functional programming), and you've got haskell
17:32:55 <Binkley> @quote dons
17:32:55 <lambdabot> dons says: lambdabot's finished
17:33:19 <chessguy> @quote lambdabot
17:33:19 <lambdabot> lambdabot says: Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
17:33:35 <chessguy> my new hobby: finding chains of @quotes
17:33:40 <chessguy> @quote kind
17:33:40 <lambdabot> droundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
17:33:56 <Binkley> @quote darcs
17:33:56 <lambdabot> dylan says: pugs, darcs, and lambdabot: gateway drugs to haskell.
17:34:03 <chessguy> @quote drug
17:34:03 <lambdabot> newsham says: dont confuse larry wall's drug induced vision of computing with the state of reality
17:34:09 <Binkley> @quote wall
17:34:09 <lambdabot> emu says: design patterns are what you choose for wallpaper and carpets
17:34:21 <chessguy> haha
17:34:24 <chessguy> @quote pattern
17:34:24 <lambdabot> ghc says: More than one type pattern for a single generic type constructor
17:34:32 <Binkley> @quote constructor
17:34:32 <lambdabot> ghc says: More than one type pattern for a single generic type constructor
17:34:36 <Binkley> :.(
17:34:39 <xerox> loop!
17:34:51 <chessguy> @quote generic
17:34:51 <lambdabot> ghc says: More than one type pattern for a single generic type constructor
17:34:54 <chessguy> ugh
17:35:01 <xerox> game over.
17:35:02 <Binkley> @quote single
17:35:02 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
17:35:03 <lambdabot> object in the category of religions and theomorphisms.
17:35:08 <chessguy> @fix @quote
17:35:08 <lambdabot> Maybe you meant: faq ft id thx
17:35:12 <Binkley> heh
17:35:16 <chessguy> yes, i'm sure i did
17:35:29 <chessguy> @thx
17:35:29 <lambdabot> you are welcome
17:35:37 <shachaf> @thanks
17:35:37 <lambdabot> you are welcome
17:35:40 <shachaf> @thank you
17:35:40 <lambdabot> Maybe you meant: thank you thanks
17:35:42 * chessguy pets the bot lovingly
17:35:49 <shachaf> @thank
17:35:49 <lambdabot> Maybe you meant: thank you thanks
17:36:09 <chessguy> @ft
17:36:11 <lambdabot>  There was an error in the type: (line 1, column 2):
17:36:12 <lambdabot>  unexpected "1"
17:36:12 <lambdabot>  expecting "forall" or a simple type term
17:36:13 <shachaf> That's odd, why is it offering those corrections?
17:36:18 <shachaf> @thankyou
17:36:19 <lambdabot> you are welcome
17:36:49 <chessguy> @quote correct
17:36:49 <lambdabot> SeanRussell says: [On the wmii (window manager) mailing list] Hah!  That's a laugh.  Since when does "it compiles" equate to "it will run (correctly)"?  We're talking about C, after all... not
17:36:49 <lambdabot> Haskell.
17:36:54 <SamB> what silly person defined a "thank you" command?
17:37:06 <Binkley> what silly person defined a "get-shapr" command? :-)
17:37:14 <chessguy> @quote silly
17:37:15 <lambdabot> dibblego says: [in ##c] <dibblego> ?type map <SamB> no lambdabot in ##c, silly! <dibblego> I'm so used to lambdabot following me around
17:37:51 <chessguy> so anyway
17:38:07 <ddarius> How's that parametric polymorphism?
17:38:08 <chessguy> Gwern, are you going to paste your type error or what?
17:39:24 <chessguy> ddarius, much better than my parapsychological metro-polythisms, thanks
17:39:31 <SamB> that wouldn't be so silly these days...
17:39:35 <SamB> typing ?type map in ##c
17:39:50 <SamB> though it seems that it would not work at this moment
17:39:54 <ddarius> @seen lambdabot
17:39:54 <lambdabot> Yes, I'm here. I'm in #gentoo-haskell, #haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc, #darcs and #scannedinavian
17:39:56 <chessguy> yeah, the world is starting to catch on to FP
17:40:05 <Binkley> and unicycling
17:40:10 <chessguy> map and fold are defined in javascript now
17:40:33 * ddarius was fighting with javascript's insane scoping yesterday.
17:40:49 <shachaf> ddarius: What is insane about Javascript's scoping?
17:41:04 <ddarius> shachaf: It doesn't have block scoping.
17:41:08 <chessguy> heh. yeah, i hate figuring out scoping in JS
17:41:16 <chessguy> lexical scoping
17:41:21 <SamB> Buaghnie doesn't seem to be in operation right now :-(
17:42:04 <shachaf> SamB: Is Buaghnie one of lambdabot's relatives?
17:44:02 <SamB> shachaf: indeed
17:45:51 * ddarius has a for loop: for(var i in pixelProperties) { (function (prop) { ... } ) (pixelProperties[i]) }
17:47:18 <chessguy> meh
17:47:20 <reffie> ddarius what are you working on?
17:47:22 <chessguy> don't complicate the syntax
17:47:49 <chessguy> var f = function...; f(pixelProperties[i]);
17:48:07 <hpaste>  Shine pasted "scope problem" at http://hpaste.org/2067
17:48:12 <Shine> any idea why ghc says x and y not in scope for circle2?
17:48:18 <ddarius> chessguy: That would be more complicated.
17:48:41 <chessguy> ddarius, what happens when you run that?
17:48:54 <ddarius> reffie: Some animation combinators for the hell of it.  That loop uses reflection to build an adapter for style objects.
17:49:02 <ddarius> chessguy: What do you mean?
17:49:27 <chessguy> ddarius, i thought you were saying that code doesn't work
17:49:50 <ddarius> chessguy: It does.  It's just obscene and would not be necessary if javascript's scoping were sane.
17:49:58 <chessguy> ah, ok
17:50:08 <Binkley> Shine: why not write: circle2 radius lineWidth x y = r2 >= radius...
17:50:13 <Binkley> then your where-clause would work
17:50:54 <ddarius> Shine: You can't attach where clauses to an expression.
17:50:55 <Shine> I'm not sure if this works, I want to combine this function with other functions, like the lambda construct in my Lisp code
17:51:27 <Binkley> Shine: I'm not sure what you mean, but circle2 radius lineWidth x y = ... has the exact same meaning as circle2 radius lineWidth = \ x y -> ...
17:51:31 <ddarius> Shine: You don't need to do anything special.
17:51:55 <Shine> thanks, I'll try it with all arguments
17:52:04 <shachaf> Binkley: Except for the where.
17:52:20 <shachaf> Binkley: Which works only with functions, not with lambdas.
17:52:21 <Binkley> shachaf: well, that's a matter of syntax rather than semantics
17:52:22 <ddarius> f x y = ... is like (define f (lambda (x) (lambda (y) ...))) in Scheme.
17:52:42 <shachaf> Binkley: Yes, but syntax was Shine's problem here. :-)
17:53:09 <ddarius> shachaf: His penultimate comment suggests that that was not his only misunderstanding.
17:53:10 <Binkley> shachaf: true :-) But being syntactically incorrect, Shine's code didn't have any meaning
17:53:13 <Binkley> though that's a little pedantic
17:53:24 <newsham> "plugins" comes with ghc-6.6.1 right?
17:53:31 <shachaf> Binkley: It had meaning to people who know what it was supposed to mean.
17:53:32 <newsham> Setup.hs: cannot satisfy dependency plugins>=1.0
17:53:41 <shachaf> Binkley: That's why Shine was asking #haskell and not a compiler. :-)
17:54:31 <Binkley> shachaf: Sure, I'm just saying it's still perfectly legitimate to claim that the definition version and the lambda version have the same meaning
17:54:53 <shachaf> Binkley: They didn't in this case, because of syntax.
17:54:59 <shachaf> Binkley: One compiled, the other didn't. :-)
17:55:21 <ddarius> shachaf: There was a reason he was even bothering to try the second version.
17:55:37 <shachaf> ddarius: Learning about how where works?
17:56:21 <shachaf> I agree that except for the syntactical difference of using where, they're the same.
17:56:34 <ddarius> shachaf: I'm pretty sure he thought that he would not be able to do: let aCircle = circle1 3 4 with the former rather than the latter.
17:56:57 <shachaf> ddarius: You mean circle1 r w 3 4?
17:57:09 <Winterstream> Has anyone here used Applicatives with IO?
17:57:09 <ddarius> shachaf: I mean what I said.
17:58:13 <shachaf> ddarius: Oh, never mind, sorry.
17:58:42 <shachaf> Shine: Do you understand that (\x y -> z) is equivalent to (\x -> (\y -> z))?
17:59:10 <RyanT5000> why does the class Error exist?
17:59:20 * Winterstream head explodes...
17:59:35 <ddarius> RyanT5000: For some unreasonable desire to "nicely" support fail.
17:59:46 <RyanT5000> ddarius: :(
17:59:51 <shachaf> Winterstream: What's wrong with using Applicatives with IO?
17:59:53 <RyanT5000> well it "nicely" breaks my fail-less code
18:00:00 <Alleria> @pl (\y -> sum(x)*y <= n)
18:00:00 <lambdabot> (<= n) . (sum x *)
18:00:07 <Shine> ddarius: yes, maybe this was my problem, this is this tricky currying, isn't it?
18:00:25 <shachaf> Shine: Yes.
18:00:30 <shachaf> ddarius: OK, you were right. :-)
18:00:33 <ddarius> Shine: Yes, it is due to the fact that function in Haskell are curried.
18:00:56 <shachaf> > let { f x y = x + y } in (f 5) 3
18:00:56 <RyanT5000> ddarius: i think i'm going to instance Error so that it just throws an exception if it ever gets used
18:00:57 <Winterstream> scachaf: Nothing :) Just getting used to all these "structure giving" types.
18:01:01 <lambdabot>  8
18:01:07 <ddarius> RyanT5000: That's fine.
18:01:24 <shachaf> Shine: When you say "f x y", it's really saying "(f x) y".
18:01:26 <RyanT5000> ddarius: the haskell error reporting system needs a *lot* of work
18:01:27 <ddarius> RyanT5000: fail should never have been in the Monad class in the first place.
18:01:37 <RyanT5000> ddarius: finally someone who agrees with me!
18:01:45 <shachaf> Shine: And when you say ":: a -> b -> c", it's really ":: a -> (b -> c)"
18:01:52 <ddarius> RyanT5000: Most people think that with varying degrees of vigour.
18:01:54 <Winterstream> shachaf: My head wants to explode because I realised that <|> is part of Alternative, which is also an abstract concept.
18:01:56 <RyanT5000> ddarius: people keep giving me trouble for saying that, like "it is necessary for do syntax"
18:02:20 <Winterstream> shachaf: But it's absolutely wonderful that Haskell uses so many profound abstractions.
18:02:24 <shachaf> Winterstream: IO is an Applicative, if that's what you meant.
18:02:33 <kyevan> How do I make sure GHC does all iys linking staticly, instead of dynamicly?
18:02:34 <ddarius> RyanT5000: It is, but it's not necessary for it to be in Monad.  The reasonable solution is to add a MonadZero constraint if a refutable pattern is used.
18:02:50 <Binkley> kyevan: you don't have to, it always does
18:02:56 <Winterstream> shachaf: I can see that. I'm just curious as to how one would do IO using the <*> operator.
18:03:13 <SamB> ddarius: or just base it on the fail call
18:03:19 <hpaste>  Shine annotated "scope problem" with "another circle2 variant" at http://hpaste.org/2067#a1
18:03:26 <ddarius> SamB: What?
18:03:27 <Shine> shachaf: but then I'm not sure about the style. I want to emphasize that usually you don't specify the x and y parameters, because I want to combine the functions, this was my reason for the lambda
18:03:31 <SamB> the scheme the report outlines would work 100% okay if you moved fail to MonadZero
18:03:40 <SamB> it's just that apparantly nobody implements it that way
18:03:54 <kyevan> Binkley: Oh, really? I wonder how so many dynamicly-linked darcs builds have been thrown at me the last few days, then >_>
18:04:10 <Binkley> kyevan: hmm, what is being dynamically loaded?
18:04:20 <SamB> (the report doesn't give any typing rules for do blocks)
18:04:22 <ddarius> SamB: Just get rid of fail altogether.
18:04:30 <SamB> ddarius: but I like fail
18:04:36 <SamB> in a practical way
18:04:40 <shachaf> Winterstream: f <$> x <*> y means liftM2 f x y.
18:04:41 <Binkley> Shine: that looks OK to me; are you still getting an error?
18:04:47 <kyevan> libcurl, libkrb, lots o' crud
18:05:00 <shachaf> Winterstream: (Which is do { x' <- x; y' <- y; return (f x y) }).
18:05:33 <shachaf> Shine: Similarly, "f x y = ..." means "f = \x -> (\y -> ...)"
18:05:40 <Binkley> kyevan: oh, hmm. Maybe things that are called through the FFI can be dynamically loaded
18:05:53 <shachaf> Shine: If you call a function with only some of its arguments, it'll return a new function that accepts the rest of them.
18:06:20 <newsham> :type (+ 2)
18:06:24 <Shine> Binkley: this works, but I'm not sure if it is good Haskell style, but I'll try to write the rest of the functions to see how I can combine the functions
18:06:39 <shachaf> newsham: :t or @type, not :type.
18:06:42 <Binkley> kyevan: but if you build a statically-linked version of darcs, you'll need to get those libs anyway :-)
18:06:56 <kyevan> Binkley: I have them here, I don't have them on dreamhost :)
18:07:06 <shachaf> Shine: Partial application counts as good Haskell style.
18:07:13 <Binkley> Shine: most people would probably write circle2 radius lineWidth x y = ... but your version is legit
18:07:17 <ergot> what can I use to get the same result as "(expr)?a:b" in C?
18:07:20 <Binkley> the indentation jumps out at me more than the lambda :-)
18:07:25 <Binkley> ergot: if expr then a else b
18:07:26 <ddarius> Shine: As has been said, with or without lambdas they are the same.  Unless your source code is going to be the documentation, the user can't tell how you wrote the code so it doesn't make any difference.
18:07:31 <ergot> thx
18:07:34 <shachaf> Binkley: You mean circle2?
18:07:38 <Winterstream> shachaf: So then can one do the following?: (++) <$> getLine <*> getLine
18:07:45 <newsham> > (\x -> if x then 1 else 2) True
18:07:47 <lambdabot>  1
18:07:50 <newsham> > (\x -> if x then 1 else 2) False
18:07:51 <shachaf> Winterstream: Exactly the example I was testing with. :-)
18:07:51 <lambdabot>  2
18:08:05 <SamB> what does "->ST" mean on a heap profile?
18:08:15 <shachaf> Binkley: The where in circle2 is the problem.
18:08:22 <Shine> Binkley: is there any pretty printer for Haskell?
18:08:24 <ddarius> shachaf: He annotated the paste.
18:08:31 <shachaf> Oops.
18:08:44 <Winterstream> shachaf: Cool. Thanks :). So one should read the angle brackets as lifting their operators into monads?
18:08:44 <shachaf> Yes, that also works.
18:08:53 <Binkley> kyevan: so where did you download your darcs binary from?
18:09:14 <shachaf> Though circle1 looks clearer, I think, except I'd put the where on a different line.
18:09:16 <Winterstream> shachaf: (By convention, I mean)
18:09:18 <Binkley> Shine: the emacs mode may help with some things, but I'm not sure there's a "pretty printer" as such
18:09:24 <Binkley> due to indentation being meaningful
18:09:38 <kyevan> Binkley: Debian's the only place that has binaries for post-1.0.7 period, it seems >_>
18:09:42 <kyevan> but anyway
18:10:01 <Binkley> kyevan: well, I have a darcs binary that I run on dreamhost...
18:10:07 <Binkley> maybe I can put it in a temp dir for you
18:10:09 <shachaf> Winterstream: Well, not monads, but Applicatives. It might help to think that (<$>) is fmap/liftM and (<*>) is ap.
18:10:20 <sorear> (back)
18:10:41 <Winterstream> shachaf: Ok, I see.
18:10:47 <Winterstream> shachaf++
18:10:50 <shachaf> Winterstream: (Where ap is liftM2 id: ap f x = do { f' <- f; x' <- x; return (f' x') })
18:10:59 <kyevan> Binkley: What version?
18:11:20 <Pupeno_M> Hello.
18:11:33 <Binkley> kyevan: 1.0.8
18:11:42 <Winterstream> Hi Pupeno_M
18:11:43 <Shine> shachaf: ok, I'll write it with the x/y parameters. I assume when I'm more familar with currying, too many parameters doesn't look as bad as in e.g. Lisp, where you have to write lambda for combining functions
18:11:50 <Pupeno_M> Anyone in UK for some off-topic questions?
18:11:56 <RyanT5000> is there a way to make a new : command that combines two other : commands in ghci?
18:12:02 <shachaf> Shine: Yes, you get used to it.
18:12:04 <shachaf> RyanT5000: :def
18:12:07 <kyevan> Mmm, I'll build my own, maybe. But if you could, incase I screw up, that would be nice >_>
18:12:12 <RyanT5000> i really would like to be able to do ":!./build" and ":r" at the same time
18:12:24 <Binkley> kyevan: ok, try http://lafalafu.com/krc/Scratch/darcs.gz
18:12:28 <RyanT5000> shachaf: how do i combine two things?
18:12:35 <bitwize>  hi Pupeno_M.
18:12:54 <Pupeno_M> hi bitwize, are you in UK?
18:13:00 <ddarius> :def \_ -> return ":!./build\n:r" or maybe it returns a list of Strings.
18:13:04 <Winterstream> None of Darcs' performance problems are related to Haskell, are they?
18:13:14 <Winterstream> (or rather, GHC :))
18:13:21 <ddarius> Winterstream: No, they aren't.
18:13:26 <shachaf> RyanT5000: :def both (\s -> return (":!./build\n:r\n")), maybe?
18:13:28 <RyanT5000> ddarius: ooohhh it's a haskell expression it wants? that's pretty sweet
18:13:30 <stepcut> Winterstream: no -- atleast not the really important ones
18:13:40 <shachaf> ddarius: No, IO String.
18:13:42 <ddarius> RyanT5000: You can do some crazy crap with :def
18:13:49 <RyanT5000> ddarius: that's pretty awesome
18:14:04 <Winterstream> Cool. Somehow there seems to be that perception; or at least, I've seen 1 or 2 remarks to that effect online.
18:14:11 <RyanT5000> is there a file somewhere that :def declarations get automatically loaded out of? like a ~/.ghci or something
18:14:21 <shachaf> RyanT5000: Yes.
18:14:38 <shachaf> @go dot-ghci
18:14:39 <ddarius> :runScript \filename -> readFile filename
18:14:40 <lambdabot> http://people.reed.edu/~carlislp/ghc6-doc/users_guide/ghci-dot-files.html
18:14:44 <kyevan> Binkley: YAY! Thanks! Now, off to try to build my own 1.0.9 :)
18:14:49 <ddarius> :def runScript \filename -> readFile filename
18:14:54 <RyanT5000> shachaf: awesome; thanks
18:14:54 <Winterstream> GHC's code seems to be plenty fast to me.
18:14:54 <Binkley> Winterstream: well, I've heard people claim that some of darcs's performance problems are due to laziness, but I'm not sure what they were basing it on
18:15:02 <Binkley> kyevan: yay, glad it worked!
18:15:04 <ddarius> Heck, :def runScript readFile
18:15:12 <Binkley> of course, that would be a Haskell issue and not a GHC issue
18:15:35 <kyevan> Binkley: Some of them are surely due to laziness, but not that of the language, that of the developers :P
18:15:40 <sorear> Binkley: I thought that was just Haskell-bashing and the real issue is that performance isn't a priority for the darcs devs?
18:15:43 <Binkley> kyevan: heh well
18:15:52 <shachaf> :def runScript readFile
18:16:01 <Binkley> sorear: it could be. The person who was saying this wasn't a Haskell-basher, but probably wasn't intimately familiar with darcs
18:16:09 <RyanT5000> shachaf: that's pretty awesome
18:16:16 <Winterstream> Binkley: I think everyone wants to seem informed, which is why people pretend to know what they're talking about when it comes to something like laziness. For my part, I cannot see how laziness could add anything more than a constant factor...
18:16:29 <kyevan> sorear: Well, everyone I know wants to kill the exponentialy growing length needed to do stuff >_>
18:16:46 <Binkley> Winterstream: well, with darcs, my butt wants to say that network latency would swamp anything having to do with laziness
18:16:56 <Binkley> but I dunno for sure
18:17:06 <SamB> Binkley: your BUTT?
18:17:19 <Binkley> SamB: as in, "I'm talking out of my butt"
18:17:23 <SamB> do you use your butt instead of your gut?
18:17:26 <Binkley> heh
18:17:28 <Binkley> it's not quite the same
18:17:36 <Winterstream> Binkley: Oh, for sure. I'm sure Darcs would be fast enough as a Python program.
18:17:44 <ddarius> SamB: They work in synergy.
18:17:51 <sorear> kyevan: Can you actually read darcs' code?  I think there are three or four people who can, and they mostly don't care about performance.
18:18:12 <RyanT5000> sorear: what's so weird about darcs' code?
18:18:13 <kyevan> sorear: Not most of it, no >_>
18:18:14 <Binkley> Winterstream: yes, only it wouldn't exist if it were a Python program :-)
18:18:35 <Binkley> RyanT5000: ever tried to read it? :-)
18:18:49 <RyanT5000> Binkley: no; i guess i'll go look at it in darcs >.>
18:18:50 <sorear> Winterstream: There's a Python poor clone of darcs, called "mercurial".  I hear it's pretty fast.
18:19:05 <kyevan> sorear: But everyone wants to figure it out just because as far as I can tell, no one has any clue where exactly it comes from
18:19:13 <SamB> sorear: since when is that a poor clone of darcs?
18:19:18 <Winterstream> sorear: Ha ha ha! Hg is getting quite a lot of press though.
18:19:22 <ddarius> sorear: I find it unlikely that it is a clone.
18:19:39 <kyevan> But trusting Sybel Trelwany makes more sense than trusting me, so whatever :P
18:19:40 <glguy> hg makes no attempt at "patch logic"
18:19:40 <Binkley> kyevan: I thought that aside from the infamous conflict bug, a lot of the problems are due to non-pipelining HTTP and SSH implementations
18:19:49 <mrd> :
18:19:51 <Binkley> but I am not the expert
18:19:58 <sorear> mrd: Wrong window
18:20:13 <sorear> mrd: Also, that doesn't work in HEAD GHCi.  You were warned.
18:20:19 <RyanT5000> @where darcs
18:20:19 <lambdabot> http://darcs.net/
18:20:25 <kyevan> I can /almost/ understand the theory behind darcs, though :)
18:20:26 <RyanT5000> where's the *darcs* for darcs?
18:20:42 <kyevan> RyanT5000: The darcs repo for darcs? It's in svn :P (Kidding!)
18:20:44 <Winterstream> Is there something dark about darcs' code? (No, that's not meant to be a bad pun...)
18:20:54 <RyanT5000> kyevan: lol
18:20:57 <sorear> Binkley: The pipelining problems are in darcs, not the remote servers.
18:21:03 <Binkley> sorear: that's what I meant
18:21:06 <shachaf> sorear: : is :r (in non-HEAD)?
18:21:06 <kyevan> http://abridgegame.org/repos/darcs
18:21:07 <lambdabot> Title: darcs
18:21:10 <sjanssen> Winterstream: it's written in a very funky style
18:21:11 <sorear> shachaf: yes
18:21:15 <RyanT5000> kyevan: thanks :)
18:21:24 <shachaf> sorear: And why was it taken out?
18:21:26 <sorear> Binkley: It would be better even if it did normal requests in parallel
18:21:34 <sorear> shachaf: More things were added
18:21:43 <kyevan> RyanT5000: (Submit patches using linus-mode, iirc)
18:21:46 <Winterstream> I once worked with a physicist who said: "this code is really badly written; it was written by a physicist" :)
18:22:09 <mrd> Modules loaded
18:22:16 <Binkley> sorear: yeah, I tried to do that a couple of months ago but dropped the ball
18:22:17 <Winterstream> Of course, physicists brought us Unix...
18:22:21 <mrd> hehe, ok i'm done
18:22:27 <shachaf> sorear: So does it have another meaning now?
18:22:27 <Binkley> physicists brought us the Web!
18:22:31 <Winterstream> (or is that only Pike?)
18:22:34 <mrd> yes, working in screen is causing some minor confusion
18:22:40 <RyanT5000> kyevan: nah, i just want to browse it and see what makes it so hard to understand
18:22:40 <Winterstream> Oh, and Joe Armstrong is a phycisist.
18:23:12 <sorear> shachaf: it means :? now
18:23:22 <kyevan> Winterstream: Unix was EXCELENT!
18:23:32 <kyevan> Wether or not it's good now, is debatable.
18:23:39 <Winterstream> kyevan: Of course :)
18:23:45 <kyevan> but for the situation that spawned it, it did very, VERY well
18:23:52 <sorear> kyevan: EXCELENT?
18:24:00 <sorear> is that deliberate?
18:24:01 <Winterstream> kyevan: Well, I wish Plan 9 caught on...
18:24:29 <kyevan> Winterstream: I'm almost glad it didn't.
18:24:53 <kyevan> But then, if it had, my complaints wouldn't be problems, so...
18:24:57 <Winterstream> kyevan: how so?
18:24:59 * kyevan headsplodes
18:25:07 <sorear> So, basically, as soon as someone tells me how darcs conflicts work, I'm going to reimplement the whole thing.
18:25:09 <RyanT5000> sorear: worse is better :)
18:25:17 <RyanT5000> sorear: especially when it comes to spelling
18:25:29 <kyevan> Winterstream: Oh, I just find several large portions of it =
18:25:37 <kyevan> Winterstream: Oh, I just find several large portions of it are rather hard to use
18:25:56 <kyevan> And it's not helped by a large portion of the Plan 9 users I've met being assholes >_>
18:26:14 <shachaf> kyevan: There are Plan 9 users?
18:26:25 <Binkley> a large portion of the users of anything are assholes, with Haskell being one of the notable exceptions :-)
18:26:32 <kyevan> shachaf: That surprised me, too :P
18:26:39 <Winterstream> kyevan: I'm not too crazy about 8 1/2
18:26:55 <lament> a large portion of the users of anything are assholes, but some things are just exceptional *cough* lisp
18:27:16 <sorear> There are no lisp users.
18:27:23 <kyevan> lament: Hey, don't be insulting just because they all have pronunciation issues!
18:27:30 <Winterstream> kyevan: Also, I think they went too far with the file abstraction by treating writes/reads as function calls...
18:27:54 <sorear> There are Common Lisp loonies, Scheme loonies, ...., but no generic lisp users,
18:27:56 <Winterstream> lament: Ha ha. I discovered the legendary Naggum the other day. My god; I couldn't believe it.
18:28:02 <Winterstream> kyevan: Ha ha ha ha
18:28:11 <Philippa> sorear: the Common Lispers say otherwise :-)
18:28:11 <kyevan> sorear: There are no unix users, either
18:28:40 <bitwize> it sure attracts a stubborn and vocal fan base for a language that doesn't even support value semantics!
18:28:57 <lament> sorear: i meant common lisp, of course
18:29:13 <lament> schemers are nice :)
18:29:20 <mrd> naggum's alright.  most of his victims deserve it =)
18:29:35 <Winterstream> Aww, I kind of like Lisp. But I do think CL is butt ugly.
18:29:36 <kyevan> lament: Depends on what group of schemers you're around
18:30:40 <lament> kyevan: perhaps, but i've never heard any legends about evil schemers, like i hear about CL all the time
18:30:44 <Binkley> I'm reminded of the time I told a bus driver I needed to go to Oxford University and was told "there's no such place"
18:31:01 <bitwize> lament: Evil CL users?
18:31:03 <lament> Binkley: "Excuse me, where's the cafeteria at?"
18:31:08 <Philippa> Binkley: heh, oops
18:31:22 <bitwize> like, do they sabotage Java projects and that?
18:31:23 <sorear> I... don't get it.
18:31:47 <kyevan> bitwize: Java projects don't need help to be sabotaged.
18:32:00 <lament> "-- Excuse me, where's the cafeteria at? -- Here at Harvard, we don't end sentences with prepositions! -- Okay, where's the cafeteria at, ASSHOLE?"
18:32:11 <shachaf> Winterstream: What's wrong with combinatory logic? :-)
18:32:21 <Binkley> haha
18:33:18 <Winterstream> shachaf: Heh. It didn't market itself well enough to make most people think of it when seeing the capitals "CL" :)
18:33:23 <sorear> Yes, Unlambda *is* prettier than quite a few other languages I've seen.
18:34:04 <Winterstream> Well look, Java is at least prettier than Perl. But then, x > 0 for x in N...
18:34:17 <Winterstream> err
18:34:23 <Winterstream> I meant N \ 0
18:34:24 <Winterstream> he eh
18:34:26 <RyanT5000> is there any way to get hsc2hs to handle macro functions?
18:34:41 <RyanT5000> the API i'm writing binding uses about 100 of them
18:35:29 <sorear> What would that make Haskell?  Swiss army tac-nuke?
18:35:52 <newsham> if you have a program that raises an error (ie. "Prelude.init: empty list") whats the easiest way to find out where the error occurred?
18:35:59 <newsham> in 6.6.1 (no debugging in ghci yet)
18:36:04 <Binkley> Haskell is a Swiss Army knife that won't let you use the screwdriver to pound nails
18:36:09 <bitwize> hmmm, C++ does have the most modern type system.
18:36:16 <sorear> newsham: compile with -prof -auto-all, run with +RTS -xc
18:36:26 <shachaf> sorear: Speaking of which, is @unlambda supposed to work?
18:36:29 <Winterstream> bitwize: *choke*
18:36:33 <lament> bitwize: chronologicall?
18:36:35 <shachaf> sorear: Or is it a correction to something else?
18:36:36 <glguy> bitwize: more qwe quoting?
18:36:37 <lament> +y
18:36:37 <sorear> bitwize: yeah, but it's frightening how many annotations are needed
18:36:39 <opqdonut> *choke* indeed
18:36:43 <Winterstream> ha ah ah ha!
18:36:43 <RyanT5000> Binkley: usually i use the entire pocket knife when i'm pounding a nail :)
18:36:53 <Winterstream> It's so funny! qwe attacked me on reddit...
18:36:59 <Winterstream> I started looking at his profile on reddit
18:37:00 <Binkley> haha, join the club
18:37:01 <sorear> shachaf: it's supposed to work, but dons didn't install the helper programs
18:37:01 <bitwize> I'm reading this article about ranged types in c++
18:37:07 <sorear> @djinn a -> a
18:37:08 <lambdabot> f a = a
18:37:12 <sorear> @bf
18:37:12 <lambdabot> Done.
18:37:14 <bitwize> Which is effectively, dependent types
18:37:18 <newsham> ghc-6.6.1: combination not supported: Threaded/Profiling
18:37:25 <Winterstream> Then I googled him and hosed myself. People all over - outside of reddit - dis him
18:37:32 <sorear> newsham: take off -threaded then ;)
18:37:34 <Binkley> @quote qwe1234
18:37:35 <lambdabot> qwe1234 says: it's 2006 already, and the world doesn't need 'dynamic languages'. otherwise, we'd be all programming in perl.
18:37:45 <newsham> sorear: how well do you think lambdabot will run without -threaded?
18:38:09 <bitwize> He does have a point though, about deterministic object lifetimes
18:38:21 <sorear> newsham: Quite well.  There is essentially no difference between -threaded and !-threaded on a 1-cpu system.
18:38:35 <newsham> oh.  I thought that meant to disable threading entirely
18:38:35 <sorear> bitwize: you're doing yourself a HUGE disservice by listening
18:38:38 <shachaf> sorear: @bf is a BF interpreter?
18:38:42 <sorear> shachaf: yep
18:38:46 <bitwize> Relying on gc finalizers to clean up your mess is not going to make your day when you're serving 10,000 users at once and oops, you run out of file descriptors
18:38:47 <shachaf> sorear: Well, it also doesn't seem to work.
18:38:54 <sorear> newsham: yes, it disables OS-level threading
18:39:04 <Winterstream> Who is this qwe1234? He seems like someone who put in years to understand C++ and is now peeved because interest is moving away from C++ :)
18:39:07 <shachaf> sorear: (Not that I know any BF; I prefer Unlambda.)
18:39:29 <JBGood25> Winterstream, someone from reddit
18:39:29 <sorear> Winterstream: Stop.  Go bang your head on a rock until you forget you ever heard of him.
18:39:39 <Winterstream> ha ha ha
18:39:52 <Winterstream> JB: I know :) I had a runin with him on reddit.
18:40:01 <dons> we all have I think :)
18:40:14 <Winterstream> JB: His last round of comments got him some impressive downmods. Some of his comments are below -20.
18:40:24 <dons> but he's hostile, not curious. which tricks people who assume that those who ask questions are curious
18:40:43 <bitwize> Olin Shivers has done some research into making GC sensitive to non-memory resource scarcity but it seems a more powerful abstraction is just to let scope determine object lifetime.
18:40:47 * shachaf doesn't post on Reddit.
18:41:07 * sorear doesn't read on Reddit.
18:41:18 <newsham> sorear: danke
18:41:25 <Nafai> It would be interesting to see which user on programming.reddit has the most downmods
18:41:25 <Winterstream> Reddit is evil. I spend too much time there.
18:41:33 <stepcut> it would be nice if GHC was more sensitive to file handle scarcity
18:41:37 <Winterstream> newsham: Are you Dutch?
18:41:38 <Nafai> qwe1234 definitely would be in the running :)
18:41:41 <newsham> no sir
18:41:42 <kyevan> configure: error: Cannot find Debug.QuickCheck; try installing package quickcheck?
18:41:46 <kyevan> erm, helps >_>
18:41:54 <Winterstream> German?
18:41:56 <dons> Test.QuickCheck ?
18:41:58 <newsham> nope
18:41:59 <sorear> kyevan: Try installing package quickcheck.
18:42:03 <dons> ?hoogle quickCheck
18:42:03 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
18:42:03 <lambdabot> Test.QuickCheck :: module
18:42:17 <kyevan> sorear: butm erm, what package?
18:42:23 <sorear> kyevan: quickcheck.
18:42:25 <dons> ?hackage QuickCheck
18:42:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/QuickCheck
18:42:27 <Winterstream> newsham: sorry ;) I thought you were saying "thanks"
18:42:36 <sorear> kyevan: libghc6-quickcheck-dev on debian
18:42:50 <sorear> kyevan: but the haskell package name is quickcheck!
18:42:51 <kyevan> thank you
18:42:56 <sorear> s/!/./
18:43:18 <newsham> I was.
18:43:35 <kyevan> sorear: And the haskell package name has about as much meaning to me as a ruby one would you. Unless you spend more time around ruby users than I do haskell >_>
18:43:52 <Winterstream> newsham: Oh? So you know some Dutch or German? Is "danke" "thanks" in any other Germanic language?
18:44:14 <newsham> I just speak english, but everyone knows what "danke" means
18:44:23 * ddarius hasn't run into qwe1234 on reddit.
18:44:25 <newsham> or rather, I speak american ;-)
18:44:36 <sorear> Close enough.
18:44:52 <bitwize> ddarius: likely he's been downmodded into oblivion before you had a chance to :)
18:45:12 <Winterstream> newsham: Maybe all educated people :).
18:45:17 <bitwize> anyway, the ability to parameterize types over integers *is* pretty pimp, is all I'm sayin'.
18:45:22 <sorear> kyevan: So far, all haskell packages foo that have been packaged for debian have received the name "libghc6-" ++ map toLower foo ++ "-dev"
18:45:36 <kyevan> Mm
18:45:39 <ddarius> bitwize: Much more likely is the fact that I don't have anything to do with reddit.
18:45:44 <sorear> bitwize: you can do that in Haskell too.
18:45:53 <sorear> @google Lightweight static capabilities
18:45:55 <lambdabot> http://lambda-the-ultimate.org/node/1635
18:45:55 <lambdabot> Title: Lightweight Static Capabilities | Lambda the Ultimate
18:46:16 <bitwize> really? *reads*
18:46:29 <sorear> Warning, it's an Oleg.
18:46:30 <hpaste>  Shine pasted "functions as arguments in list comprehensions" at http://hpaste.org/2068
18:46:34 <Shine> I think I got it nearly. The Haskell version looks already so much nicer than my Lisp version :-)
18:46:35 <Winterstream> I should stop reading reddit
18:47:00 <newsham> reddit writing and arithmetic
18:47:02 <kyevan> I gave up on Haskell >_>
18:47:11 <bitwize> oh crud.
18:47:17 <bitwize> Oleg's involved... shoulda known.
18:47:18 <glguy> Shine: you need to wrap your division i n( )
18:47:28 <ddarius> Shine: fun x/10 y/10 parses ((fun x)/10) y)/10
18:47:40 <kyevan> I got totaly confuzzled around the time monads came in, and decided that the stuff I do works just fine in Ruby anyway >_>
18:47:42 <ddarius> Presumably you want, fun (x/10) (y/10)
18:48:04 <sjanssen> kyevan: if you gave up, why are you still here? :P
18:48:09 <Winterstream> I think I finally "get" monads. It's remarkable that it took me so long.
18:48:11 <jfredett> kyevan: dont give up! Monads are just a little hump in the road
18:48:13 <sorear> kyevan: You were around when monads came in?
18:48:24 <kyevan> sjanssen: Needed help today getting darcs to compile
18:48:26 <Shine> ddarius, glguy: thanks
18:48:26 <ddarius> Er, I guess it parses as (fun x)/ (10 y) / 10
18:48:42 <shachaf> sorear: I assume kyevan means that they came in as what to learn about next.
18:48:43 <kyevan> sorear: No, no, when they came into my vision, not when they came into existance >_>
18:48:51 <bitwize> I understand what monads are, but sometimes the way in which they abstract sequencing eludes my poor slow brain ;_;
18:49:23 <Shine> ddarius: this works, now I'll try to write a TGA image from it
18:49:33 <lament> smoking lots of pot really helps to understand monads!
18:49:37 <Winterstream> bitwize: I think someone needs to write a tutorial and give a visual representation of monads as lego blocks which snap together to make a sequence...
18:49:50 <sorear> Shine: PPM is usually a better choice
18:50:07 <bitwize> I open up Wadler's '91 paper on the subject and usually that helps.
18:50:20 <Binkley> lament: yes, but the problem is you can't understand them after that except when high
18:50:21 <bitwize> Though perhaps lament is right and what I need is *rolling* papers and some good trees.
18:50:24 <shachaf> kyevan: What's your problem with monads?
18:50:25 <ddarius> Shine: You could get rid of the radius argument by using a scale combinator: scale c f x y = f (x/c) (y/c)
18:50:39 <kyevan> shachaf: they just... make NO FREAKING SENSE
18:50:42 <shachaf> kyevan: They were probably just not explained whele.
18:50:48 <kyevan> And I haven't worked with haskell for months
18:50:51 <Winterstream> bitwize: what annoyed me for a long time was how people kept on saying that monads are like scripts. I didn't get that you actually build the damn script and that main starts running it.
18:50:55 <shachaf> @wiki Meta-tutorial
18:50:55 <lambdabot> http://www.haskell.org/haskellwiki/Meta-tutorial
18:51:03 <kyevan> shachaf: Well, then I'm fucked, bbecause I asked half the freaking internet for help
18:51:15 <ddarius> Ah, but that would jack with the line-width argument I guess, nevermind unless you want to play with it.
18:51:16 <shachaf> kyevan: Which monad were you working with?
18:51:19 <newsham> which wadler paper is "the paper" to read?
18:51:19 <Binkley> kyevan: that was your first mistake
18:51:25 <Winterstream> kyevan: It took me aaaaaaaaaages to understand them.
18:51:32 <ddarius> @google "The essence of functional programming"
18:51:37 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps
18:51:38 <bitwize> newsham: Wadler '91, "Monads for functional programming"
18:51:58 <Winterstream> kyevan: and most monad tutorials are steaming heaps of <expletive erased>
18:52:28 <kyevan> Winterstream: Well, you people weren't any help, you kept pointing me back at the same two or three that meant NOTHING to me!
18:52:40 <RyanT5000> Winterstream: not understanding monads doesn't prevent one from writing a tutorial on them :P
18:52:41 <kyevan> Anyway, I have what I need now, I think I'll just get out of here...
18:52:56 <ddarius> scale is probably still generally useful.
18:53:04 <Winterstream> kyevan: hey, I didn't point you nowhere :) I'm just part of the furniture here ;)
18:53:20 <Shine> ddarius: but the scale operator wouldn't scale the lineWidth parameter
18:53:23 <shachaf> kyevan: No, wait. MonadOrElse!
18:53:23 <newsham> sorear: rebuilt with profiling and without threaded and now it doesnt crash :)
18:53:24 <Winterstream> Ryan: Good observation :)
18:53:29 <kyevan> And I /should/ be focusing on Java, anyway >_>
18:53:37 <RyanT5000> kyevan: blasphemy!
18:53:39 <kyevan> (Since that's what I need for school)
18:53:45 <bitwize> The problem is that Haskell is a lazy language, so you don't know when expressions are going to be evaluated. The only way to assure sequencing in pure lambda calculus is through function composition, where the result of one function depends on the result of the next innermost function application.
18:53:54 <kyevan> RyanT5000: Well, blasphemy is better than getting a 0.
18:53:55 <Winterstream> A dreaded JAVASCHOOL!
18:54:04 <kyevan> Winterstream: Well
18:54:08 <kyevan> I'm in highschool
18:54:17 <bitwize> Monads in functional programming provide an easy way of abstracting complex function compositions with lots of threaded parameters.
18:54:18 <RyanT5000> isn't there a Haskell -> Java compiler?
18:54:21 <ddarius> Shine: It would scale everything, which would be a problem for just affecting the radius, but is handy otherwise.
18:54:24 <kyevan> So, javaschool is oodles better than anything else
18:54:24 <RyanT5000> and aren't there Java disassemblers?
18:54:25 <Winterstream> kyevan: Oh, heh. That's okay. Besides, we used C++ at Uni, so you're better off
18:54:27 <kyevan> RyanT5000: Not that runs on paper
18:54:31 <RyanT5000> so, unless you're graded on style >.>
18:54:44 <RyanT5000> kyevan: ah, ok
18:54:51 <kyevan> RyanT5000: No, we're graded on how well we perform on the AP test, which is ON PAPER
18:55:08 <newsham> either I botched the build the first time somehow, or -threaded is broken here.
18:55:11 <RyanT5000> kyevan: oh right right; i looked at the AP test once, back when it was in C++
18:55:23 <bitwize> kyevan: it would help immensely to drop your high school's computer courses and learn on your own.
18:55:40 <RyanT5000> bitwize: it would help him learn, not help him get AP credit :P
18:55:47 <Shine> ddarius: maybe you are right, because then it is cleaner because I can use the unit circle. Maybe I can rewrite the line thickness with some more combinators and some meaning of inside and outside :-)
18:56:02 <bitwize> he could take the AP test without having taken a class in it, I'm sure.
18:56:06 <JBGood25> AP CS credit can be very useful for skipping introductory classes
18:56:08 <Winterstream> kyevan: Stick with monads. You'll understand them eventually.
18:56:08 <sorear> newsham: I wouldn't be suprised if using -threaded/not changes the scheduling enough to tickle one of lambdabot's infamously many races...
18:56:09 <kyevan> bitwize: I'm doing it mostly for the credit. I learn more over the summers than I do in school in /most/ topics
18:56:15 <JBGood25> and the class is useful for taking the test
18:56:20 <RyanT5000> bitwize: i'm not so sure about that
18:56:20 <JBGood25> if not for anything else
18:56:25 <kyevan> Winterstream: Well, first, I'd need to relearn the rest of haskell
18:56:45 <kyevan> And anyway, the rest of the elective credits at my school are worse >_>
18:56:47 <Shine> ddarius: I think I'll introduce a xor operator and scaled unit circles to make rings
18:56:52 <newsham> rebuilding without profiling and without -threading
18:56:53 <Winterstream> kyevan: Buy "The Haskell School of Expression". I haven't read it yet, but it seems like such a cool book.
18:57:00 <ddarius> Shine: ring width = scale width unitCircle `xor` unitCircle
18:57:05 <kyevan> Winterstream: Feel free to give me money
18:57:18 <ddarius> I guess it would be width + 1
18:57:25 <Binkley> kyevan: your local library may have it :-)
18:57:26 * kyevan hates people assumeing he has money for all the fancy hundred doller books he wants
18:57:29 <Winterstream> kyevan: Ha ha. I'm broke. And I live in South Africa - the Rand is a crap currency.
18:57:32 <kyevan> Binkley: they don't.
18:57:45 <Winterstream> kyevan: SICP cost me a near fortune.
18:57:47 <Binkley> kyevan: if you can find a way to con a university library into giving you access...
18:57:49 <newsham> works that way too
18:57:50 <kyevan> They don't have /shit/ haveing to do with anything more complecated than word.
18:58:10 <Winterstream> Most universities will happily grant you access for a couple of bucks.
18:58:11 <kyevan> Binkley: Wouldn't do me any good, I'd have to get there first >_>
18:58:19 <kyevan> Winterstream: Wouldn't do me any good, I'd have to get there first >_>
18:58:25 <Binkley> kyevan: ow, yeah, I forget that not every place has decent public transit
18:58:44 <kyevan> Oh, ours is decent, once you actually get into madison
18:58:59 <kyevan> Being out in the suburbs... I have a 10 mile walk to the nearest busstop
18:59:02 <Winterstream> kyevan: I meant that if you're not a student, you can normally get access to university libraries for a smallish yearly fee.
18:59:04 <bitwize> surrounded by cornfields are you, kyevan? :)
18:59:06 <RyanT5000> kyevan: i never read any books on haskell, and i consider myself, i dunno, 20th percentile knowledge for this channel; you just have to use it a lot, read lots of Haddock stuff, read lots of other people's code
18:59:20 <kyevan> Winterstream: Like I said, I'D HAVE TO GET THERE
18:59:23 <RyanT5000> kyevan: granted, i had a solid understanding of C++ prior to it - but even that was mostly just from reading code
18:59:32 <kyevan> As in, PHYSICLY MOVE FROM POINT A TO POINT B
18:59:34 <Binkley> I've never read a whole book on Haskell either... but I've usually had people around to explain things
18:59:37 <newsham> readingcode++
18:59:40 <Winterstream> kyevan: Okay, okay. I misunderstood. No need to shout.
18:59:41 <kyevan> why are so many people idiots
18:59:41 <Binkley> then again, people on IRC are almost like people
18:59:42 <Shine> ddarius: it needs an inner radius and an outer radius, but then it should work. Is there already an xor operator like the || and && operators?
18:59:51 <ddarius> Shine: /=
18:59:56 <Shine> ok
18:59:57 <newsham> kyevan: because nature doesnt select against idiots
18:59:57 <Winterstream> kyevan: Errr. I was actually trying to help.
19:00:04 <lament> newsham: that's not true.
19:00:15 <RyanT5000> kyevan: oh yeah, also, this channel trumps any book ever :P
19:00:19 <kyevan> Winterstream: I'm sorry, I'm just ornery tonight
19:00:27 <bitwize> kyevan: They're Haskell programmers, they don't even know what value semantics is. :)
19:00:27 <ddarius> Shine: An inner and outer radius is probably easier to work with.
19:00:30 <lament> newsham: even in absence of natural predators, people manage to get darwin awards :)
19:00:50 <ddarius> lament: People have predators.
19:01:00 <ddarius> For some definition of predator at least.
19:01:01 <Winterstream> lament: Project managers.
19:01:04 <dons> ?users
19:01:04 <lambdabot> Maximum users seen in #haskell: 382, currently: 317 (83.0%), active: 21 (6.6%)
19:01:06 <shachaf> kyevan: Which monads have you looked at?
19:01:06 <kyevan> RyanT5000: Well, then I might as well go back to my happy world of Ruby, since I asked this place, many times, to help me get monads...
19:01:11 <bitwize> yeah, each other mainly.
19:01:14 <newsham> sorear: fails with clean -threaded build.  whats a good small threaded test?
19:01:14 <kyevan> shachaf: I don't know!
19:01:31 <dons> kyevan: what are you attempting to do?
19:01:32 <RyanT5000> kyevan: which monad tutorials have you read?
19:01:33 <shachaf> kyevan: IO seems to be popular.
19:01:35 <kyevan> Like I said, the last time I worked with haskell beyond building someone elses source was MONTHS ago
19:01:50 <kyevan> Ryan, donsL Like I said, the last time I worked with haskell beyond building someone elses source was MONTHS ago
19:01:54 <bitwize> All a monad is is a specific type that follows certain laws
19:02:02 <sorear> newsham: If you run it again, does it work?
19:02:13 <Winterstream> Actually .*\ Managers are often predators of programmers who dare look beyond Java...
19:02:14 <dons> kyevan: ok, and now what's the problem? or there isn't one?
19:02:20 <kyevan> bitwize: I barely remember what haskell conciders a "Type", don't dammage your keyboard
19:02:22 <newsham> i ran it several times and most often it crashed in the same way.  once it seemed ot have just exited though
19:02:23 <kyevan> dons: W
19:02:33 <sorear> newsham: I tend to suspect you're looking at a race...
19:02:46 <RyanT5000> kyevan: if you don't understand it because you forgot, that doesn't mean the tutorial was bad...
19:02:49 <sorear> newsham: hmm, how does it crash?
19:02:54 <RyanT5000> kyevan: although many of them *are* bad
19:02:56 <newsham> sorear: i'd like to get more confidence that its not the platform port.
19:02:59 <kyevan> RyanT5000: I /never/ understood it
19:03:08 <dons> i remember very little prolog. maybe prolog tutorials are bad? :)
19:03:17 <newsham> ?paste
19:03:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:03:26 * kyevan sighs
19:03:28 <bitwize> kyevan: if you don't grok types you should bone up on those first.
19:03:32 <sorear> well, there's always the GHC testsuite.  Anyone know how easy that is to get working?
19:03:35 <kyevan> bitwize: I used to
19:03:35 <RyanT5000> kyevan: so, that brings me back to the question i asked before: which ones did you read and then not understand?
19:03:40 <Winterstream> I remember far too much Java. ugh. I also remember almost all of C++.
19:03:40 <hpaste>  newsham pasted "crash" at http://hpaste.org/2069
19:03:41 <dons> sorear: the testsuite? pretty easy
19:03:45 * Winterstream shudders
19:03:49 <dons> i've torn it out a couple of times as a standalone set
19:03:56 <bitwize> Almost all of C++? What are you, Brainiac?
19:04:03 <Winterstream> No. Just a masochist.
19:04:05 * bitwize fears Winterstream 
19:04:16 <dons> maybe Winterstream is qwe1234!
19:04:19 <kyevan> RyanT5000: I don't remember! one on wikibooks, I think, and one that was in a poorly-formatted for black and white printing pdf
19:04:23 <dons> in secret disguise :)
19:04:24 <Winterstream> I didn't know any better...
19:04:25 <spx2> has anyone here read Higher Order Perl ?
19:04:25 <RyanT5000> bitwize: i once understood almost the entire C++ grammar :P
19:04:26 <Binkley> even Bjarne Stroustrup probably doesn't remember all of C++
19:04:27 <newsham> is test suite part of ghc src?  I just downloaded and built src recently
19:04:32 <lament> kyevan: I could explain monads, but not if you don't know what types are.
19:04:35 <Winterstream> qwe1234 would never admit to being wrong ;)
19:04:46 <kyevan> lament: well, I'm not ASKING people to explain monads!
19:04:55 <Binkley> newsham: you need to pull the testsuite separately
19:04:55 <kyevan> Have I not said this already, SEVERAL TIMES?
19:04:58 <lament> no, but you keep complaining about something
19:04:59 <Winterstream> I spent many years learning all of C++'s obscure corners. What a waste of time :/.
19:05:03 <RyanT5000> kyevan: so, what's the problem?
19:05:09 <bitwize> kyevan: slow down, and have some earl grey tea.
19:05:10 <Binkley> #haskell, where people will explain monads to you whether you want them to or not
19:05:19 <shachaf> kyevan: Can't we explain monads anyway?
19:05:23 <shachaf> kyevan: Please? :-)
19:05:25 <dons> kyevan: ok. chill. so you have no questions? if not, sit back and enjoy the ride :)
19:05:26 <RyanT5000> lol
19:05:27 <kyevan> RyanT5000: There is none, I just am horrible at pulling off of a discussion
19:05:29 <sjanssen> kyevan: well, you are expressing that you had touble learning them.  Wanting to teach and help is just #haskell's nature :)
19:05:39 <RyanT5000> kyevan: ah, ok :)
19:05:41 <Winterstream> I realized what a farce it all was when I looked at the Boost libraries. They're supposed to be the bastion of C++ coding. And they're gross...
19:05:41 <lament> Binkley: and when you try to run away, they'll catch you and explain AGAIN!
19:05:42 <dons> we're addicted to teaching
19:05:53 <Binkley> kyevan: the best way to end a discussion is to not talk :-)
19:06:00 <dons> Winterstream: yeah, that *scares* me -- that Boost is supposed to be foundational
19:06:00 <RyanT5000> we feel uneasy when someone doesn't understand something
19:06:06 <Binkley> @quote cornered
19:06:06 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
19:06:06 <RyanT5000> whether it's ourselves or someone else
19:06:07 <kyevan> Binkley: You might as well tell water not to be wet :P
19:06:17 <Binkley> kyevan: well, no one said it was easy :-)
19:06:27 <Winterstream> I'm sure all the folks working on Boost are very bright. As someone said: Boost is like a beautiful statue sculpted from dog shit.
19:06:28 <spx2> has anyone here read Higher Order Perl ?
19:06:36 <lament> Winterstream: ouch
19:06:46 <dons> spx2: i'm pretty sure a few people have glanced at it
19:06:51 <dons> nothing too inspirational, iirc?
19:06:54 <ddarius> Binkley: It's hard?
19:06:57 <Winterstream> Which is to say: Obviously the Boost developers are good. C++ is just ugly.
19:07:05 <Binkley> ddarius: not talking can be hard, yeah
19:07:07 <RyanT5000> there isn't a magical way to get haskell to inline C macros is there?
19:07:11 <bitwize> Winterstream: at least your objects have deterministic lifetimes.
19:07:12 <dons> :t (&&&) -- when you've got real functional glue, everything else looks boring
19:07:15 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:07:16 <newsham> hrmm.. gotta go.  will have to inquire about tests later
19:07:16 <ddarius> Binkley: In what way/
19:07:21 <Nafai> dons: That ML/compiler paper you linked on reddit talks about zippers....is this the same zipper concept that y'all use in xmonad?
19:07:22 <lament> RyanT5000: that would so be my wet dream
19:07:27 <Binkley> I have no idea how many Usenet conversations I've seen which consisted of several iterations of "This conversation is over / no really, I'm not talking to you / why are you still talking?"
19:07:28 <dons> Nafai: yep
19:07:29 <kyevan> C++ really has no place in the world...
19:07:32 <ddarius> RyanT5000: CPP?
19:07:34 <RyanT5000> lament: lol
19:07:38 <SamB> Winterstream: and whoa do you have to be good to make something beautiful out of that makeshift octopus
19:07:42 <Winterstream> bitwize: But at the cost of all that manual memory management. It hurts my head even thinking about it.
19:07:51 <kyevan> It's trying to be a high level language, and a fast, c-like language at the same time
19:08:00 <RyanT5000> ddarius: no no, i mean i have an arithmetic macro in C (e.g. #define DIVIDE(x, y) ((x)/(y))
19:08:01 <kyevan> And thus, it does neither well
19:08:01 <kpreid> dons: what about for non-Haskell programmers? spx2 wants to learn about practical uses of functional programming, and already knows Perl.
19:08:02 <RyanT5000> )
19:08:04 <Winterstream> SamB: Ha ha ha. Yeah. That poor dog...
19:08:05 <ddarius> dons: You /msg lambdabot upon returning to #haskell.
19:08:19 <spx2> dons im trying to figgure out if functional programming is worth learning and if it would help working with it in perl
19:08:19 <SamB> Winterstream: I thought it was a poor horse
19:08:20 <bitwize> kpreid: Has spx2 read "Higher Order Perl"?
19:08:26 <lament> and yet, everybody likes C++ and ever perlers call haskell "scary"
19:08:34 <ddarius> s/./?
19:08:49 <bitwize> spx2 let me assure you that functional programming techniques can be and are used in perl in "real world" production environments.
19:08:50 <kpreid> bitwize: no.
19:08:51 <RyanT5000> lament: that's a good thing to... er... lament
19:08:53 <Winterstream> SamB: Hmm. That is a problem. We need to be explicit in C++. Octopus<Dog> or Octopus<Horse>? :)
19:08:53 <kyevan> (Sorry, folks. At the moment, C beats the hell out of haskell in speed. Theoreticly, haskell is probably easier to optimize, but it's not there yet :P)
19:08:57 <shachaf> ddarius: "snd yet, ..."?
19:09:00 <RyanT5000> lament: :P
19:09:03 <shachaf> ddarius: "?nd yet, ..."?, I mean?
19:09:04 <bitwize> It's the only way to gain some leverage over the complexity of your code base.
19:09:12 <glguy> ?ussers
19:09:12 <lambdabot> Maximum users seen in #haskell: 382, currently: 314 (82.2%), active: 22 (7.0%)
19:09:13 <Philippa> lament: it's very different, whereas C++ and perl both built on well-known concepts. Also, haskell programmers regularly think thoughts that would be extremely scary in C++
19:09:13 <shachaf> s/.$/./
19:09:14 <bitwize> Which is why the entire Java "community" is up shit creek.
19:09:16 <Nafai> lament: Haskell *is* scary
19:09:21 <glguy> /busy/ today
19:09:29 <lament> RyanT5000: i don't see it a cause for lamentation. Haskell really is scary :)
19:09:36 <SamB> Winterstream: well seeing as the definition of Octopus<foo> is basically "tack four 2x4's to the side of Foo"...
19:09:36 <dons> ddarius: or I read the logs? :)
19:09:38 <reffie> lazy evaluation is great
19:09:40 <sorear> lament: I like being scary.
19:09:43 <shachaf> kyevan: Haskell beats Ruby!
19:09:46 <bitwize> welcome to scary haskell monastery
19:09:47 <RyanT5000> lament: no it isn't! it's way harder to hurt yourself with it
19:09:48 <lament> RyanT5000: come on, how many people here are math students :)
19:09:55 <spx2> bitwize, i have not read it yet
19:09:56 <SamB> ... tacitly assuming that Foo already has four legs
19:10:02 <spx2> bitwize, thank you for the re-assurement :)
19:10:03 <Binkley> bitwize: except you're allowed to have sex, so it's better
19:10:08 <spx2> bitwize, reconfirmed ...
19:10:12 <kyevan> shachaf: Yes, but many people find ruby easier to work in :P
19:10:17 <lament> RyanT5000: or otherwise somehow mathematicians
19:10:21 <Philippa> lament: proportionally fewer than I remember was the balance in #flipcode a while back, for example
19:10:21 <Winterstream> kyevan: Well written C would beat Haskell for now. But it is hell on earth writing a big app in C (or I am just too stupid).
19:10:32 <RyanT5000> lament: i guess you're right, but it's scary in the same way people are scared of airplanes more than cars - they feel less in control, so even though the odds are way worse, they still feel better
19:10:34 <bitwize> spx2: neither have I, but I hear it's a pretty good book for helping Perlers wrap their brain around FP.
19:10:39 <dons> spx2: oh, re. higher order perl, you really should learn some functional techniques -- modern code is all about functions, and gluing them together, and functional programming techniques own this area. so its a big part of the programmer's toolbox that goes missing if you don't know functional techniques
19:10:40 <Philippa> lament: that's cheating, sufficient haskell study /makes/ you a mathematician of sorts
19:10:45 <shachaf> kyevan: You were talking about how you like Ruby before, I mean.
19:10:53 * shachaf liked Ruby a lot more before learning Haskell.
19:10:57 <Philippa> just like sufficient C++ study makes you a masochist ;-)
19:11:13 <Binkley> Philippa: that might be confusing cause and effect :-)
19:11:15 <dons> python/ruby/perl6 all adopting more functional features -- good sign basic FP techniques are considered useful
19:11:21 <bitwize> Haskell is the rollercoaster kind of scary. It feels dangerous but is actually remarkably safe provided you keep your hands and arms inside the car and hold onto the helpfully provided rail :)
19:11:21 <kyevan> shachaf: Yes, and I'm well aware that it's not a very fast language (ATM, the next version is supposed to have insane improvements)
19:11:29 <Nafai> Heck, just learning some of the concepts behind Haskell is making me hate Java at work even more
19:11:39 <SamB> dons: python is getting more?
19:11:44 <dons> heh. Nafai, that's strangely common. talk to dibblego about it sometime
19:11:51 <sorear> dons: Adopting?  Python is removing fold; from the standard library!
19:11:52 <bitwize> dons: Guido took a hatchet to `reduce' and nearly killed lambda as well
19:11:52 <shachaf> kyevan: I like Haskell more than fast-Ruby, too.
19:11:52 <SamB> I thought Guido wanted to remove the existing ones?
19:11:54 <sorear> s/;/l'/
19:11:59 <SamB> sorear: well, that fold sucks anyway
19:12:02 <shachaf> kyevan: It's a lot more fun. :-)
19:12:04 <sjanssen> the next ruby only has insane improvements because the old one was insanely dumb ;)
19:12:05 <dons> yeah yeah, but that have comprehensions
19:12:15 <bitwize> Until heroic ESR stopped him. "He can pry my lambda from my cold, dead hands."
19:12:16 <Binkley> Won't somebody please think of the poor lambdas? :-(
19:12:18 <dons> who wants fold as a primop anyway -- that's just wacky
19:12:24 <spx2> could i have some guiding over here please ?
19:12:26 <spx2> people ?
19:12:27 <spx2> hello ?!?!
19:12:30 <spx2> hello ??
19:12:31 <reffie> ESR is an idiot
19:12:33 <shachaf> spx2: Guiding about what?
19:12:34 <dons> spx2: yes, what are you looking for?
19:12:36 <RyanT5000> spx2: what was your question
19:12:37 <RyanT5000> ?
19:12:37 <Philippa> dons: I dunno, as a generalised catamorphism it has value
19:12:40 <spx2> yes
19:12:41 <bitwize> what do you need help with spx2
19:12:43 <kyevan> shachaf: Well, I like ruby, because I had absolutely no IO ability in haskell
19:12:43 <spx2> my question is
19:12:43 <bitwize> ?
19:12:47 <spx2> what do i learn first ?
19:12:53 <spx2> math basis for functional programming ?
19:12:54 <kyevan> Also, it has markaby, which is win :P
19:12:56 <spx2> functional programming ?
19:12:57 <RyanT5000> spx2: what do you know; what do you want to know?
19:12:59 <shachaf> kyevan: Huh? main = putStrLn "Hello world!"
19:12:59 <spx2> lisp-like language ?
19:13:04 <spx2> RyanT5000, i know perl
19:13:16 <Philippa> spx2: FP, picking up maths as you go?
19:13:17 <bitwize> spx2 for the time being I recommend you stick with perl.
19:13:18 <reffie> spx2 learn C and haskell
19:13:19 <glguy> common lisp is not meant to be a functional programming language
19:13:21 <ddarius> dons: C# is much more significant
19:13:24 <Winterstream> SamB: Well, you'd have define traits<TwoByFour>::nail and pray that Octopus<Horse, TwoByFour> doesn't give you a 2-page error message with more angle brackets than a LISP program has in round brackets
19:13:26 <kyevan> shachaf: Oh fine, I could output static strings
19:13:26 <glguy> it supports it in a way, but that is not the goal
19:13:29 <spx2> Philippa, im not sure if that's ok ...
19:13:31 <Adamant> dude, if you ask on #haskell, people are going to tell you learn Haskell.
19:13:32 <kyevan> "Hello world" isn't very useful
19:13:34 <bitwize> And learn how functions can be passed as arguments to other functions in perl.
19:13:35 <sorear> Am I supposed to be able to read at this speed?
19:13:35 <shachaf> kyevan: main = do { x <- getLine; putStrLn ("Hello, " ++ x ++ "!")
19:13:37 <shachaf> kyevan: main = do { x <- getLine; putStrLn ("Hello, " ++ x ++ "!") }
19:13:48 <glguy> sorear: agreed
19:13:52 <Philippa> spx2: in what way? Give or take a little logic that's pretty much where I started. People seem to think I know stuff now
19:13:57 <glguy> could everyone please type less?
19:14:02 <kyevan> Yeh, see, now at this point, I have two options:
19:14:11 <Philippa> (oh okay, and I was hacking C++ before Haskell, but still)
19:14:20 <kyevan> 1. Ignore what really happens and pretend I'm not in functional land anymore
19:14:24 <bitwize> I was hacking C++ once.
19:14:27 <kyevan> or 2. Die from confusion
19:14:28 <sjanssen> > fix ("flood! "++)
19:14:29 <spx2> Philippa, okay what do i read ?
19:14:30 <lament> RyanT5000: FP is essentially algebra - you substitute expressions with their values according to some rules. Most FP people fail to appreciate the extent to which that is an extremely counterintuitive way of *giving instructions to the computer* for most people
19:14:33 <lambdabot>  "flood! flood! flood! flood! flood! flood! flood! flood! flood! flood! flood...
19:14:41 <bitwize> About the only thing it's really good for is game engines. And I've rewritten my game engine in Objective-C...
19:14:41 <shachaf> kyevan: 2. Learn what's really happening. We're here to help! :-)
19:14:55 <dons> spx2: 'The Craft of Functional Programming' is a good introduction
19:14:58 <gwern> lament: no, the second time they'll generalize their explanantion to Arrows...
19:15:01 <Philippa> kyevan: if it helps any, there's a sense in which you're really not in functional land any more - it's a valid viewpoint so long as you accept you're also still writing functional haskell in another sense
19:15:01 <kyevan> shachaf: Well, I'm busy at the moment...
19:15:19 <shachaf> kyevan: OK, but you won't die from confusion.
19:15:20 <dons> spx2, and there's an awful lot of haskell.org. the YAHT tutorial is a good place to start too
19:15:25 <kyevan> Philippa: I'm not very good at doublethink :P
19:15:45 <shachaf> kyevan: You can write purely-functional programs and wrap them with a bit of IO you don't understand (yet).
19:15:49 <ddarius> Adamant: Not necessarily.
19:15:51 <Philippa> spx2: hmm. Unfortunately I'm probably not best-placed for basic intros - it was several years back I started, and there's a very different range of material available now. dons' recommendation is good though
19:16:02 <dons> ?where yaht
19:16:02 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
19:16:03 <kyevan> :( CRY
19:16:04 <Philippa> kyevan: that might be a problem, sometimes something really is both
19:16:09 <Winterstream> bitwize: I'm pretty sure that C++ could be made a whole lot nicer. Its syntax gives me a migraine. It needs things like pattern matching, tuples, type inference. I
19:16:10 <reffie> yaht is the best tutorial i found
19:16:10 <dons> also on the haskell wikibook
19:16:24 <reffie> although i last looked aronud 2 years ago
19:16:26 <shachaf> kyevan: See interact, for example.
19:16:33 <shachaf> @ty interact
19:16:33 <lament> is somebody still trying to explain monads to kyevan without having explained types first?
19:16:33 <Winterstream> I know C++0x will fix some issues, but I'm not sure how many. I haven't checked out the latest news on it...
19:16:35 <lambdabot> (String -> String) -> IO ()
19:16:38 <bitwize> Winterstream: If OCaml supported value semantics it would be a perfect replacement :)
19:16:39 <Philippa> "what's going on underneath" is it desugars into things that construct something that behaves an awful lot like an imperative program :-)
19:16:46 <kyevan> My selfbuilt darcs binary coredumps with a floating point exception on dreamhost :(
19:16:47 <dons> bitwize: hah
19:16:56 <dons> bitwize: did I catch you trolling augustss on reddit last week?
19:17:40 <Winterstream> bitwize: That and explicit region clues for memory management :)
19:17:42 <dons> ?where+ yaht-web http://en.wikibooks.org/wiki/Haskell/YAHT/Preamble
19:17:42 <lambdabot> Done.
19:17:44 <bitwize> I don't know if that counts as trolling since I think there really is something to ensuring that object lifetime does not exceed scope in certain cases.
19:17:52 <Winterstream> bitwize: You and your value semantics :)
19:17:52 <lament> spx2: visit haskell.org; it's a very good starting point with a LOT of stuff
19:18:07 <ddarius> bitwize: withFile $ do ...
19:18:10 <dons> bitwize: maybe you're qwe1234 in disguise?
19:18:11 <Binkley> kyevan: how did you build it?
19:18:20 <kyevan> ./configure, make
19:18:31 <Binkley> what version of ghc?
19:18:35 <lament> spx2: also look at  http://www.shlomifish.org/lecture/Perl/Haskell/slides/
19:18:37 <lambdabot> Title: Haskell for Perl Programmers
19:18:40 <kyevan> Erm, whatever is in debian sid rightnow :P
19:18:50 <Binkley> 6.6.1, I guess
19:18:52 <lament> spx2: wait, don't look at that, it's crap :)
19:19:10 <dons> lament: ah good reference.
19:19:11 <bitwize> no, I still think he's an asshole.
19:19:44 <dons> lament: oh, there's a better perl/haskell tut somewhere though
19:20:02 <dons> spx2: do you have enough material now?
19:20:05 <dons> heya glguy_
19:20:16 <sorear> bitwize: What's scope?
19:20:29 <bitwize> The scope of a variable.
19:20:33 <sorear> bitwize: Or rather, when is it.
19:20:38 <SamB> we've discovered that iampure is fasta in disguise, not qwe1234 as previously rumoured
19:20:38 <kyevan> So, who wants to clonk me over the head so I forget all about haskell again, so that come the start of term I can do java without trying to commit suicide!?
19:20:50 <spx2> dons im totally fuzzed and fogged ...
19:21:08 <SamB> kyevan: we'd probably rather teach you about scala?
19:21:10 <sorear> bitwize: Scope as a period of time just doesn't make sense out of the narrow context of imperatively specified languages
19:21:16 <shachaf> kyevan: Java? Why Java?
19:21:31 <Winterstream> bitwize: I think a really good region inferencer would go a long way. That could classify certain things as being stack allocatable. So even if one doesn't have value semantics, the benefits will still be there. Of course, your compiler should be able to tell you what it infers and you should be able to override it...
19:21:43 <lament> kyevan: don't worry, java's not that great but in a high school course the suffering will be limited
19:21:47 <kyevan> shachaf: Because that's what the AP test is in, so that's what we learn in the AP class?
19:21:53 <dons> spx, ok. do you think you've got enough ideas now to take the next step on your own? you know where to start if you want to pursue this?
19:22:00 <shachaf> Ugh, "test-driven development".
19:22:02 <shachaf> :-)
19:22:03 * glguy took the AP test using C++
19:22:04 <sorear> I'm pretty sure I've been programming C++ longer than qwe1234
19:22:06 <SamB> kyevan: I hope you aren't planning to take the AP test
19:22:10 <kyevan> (Thankfully, we got exposed to Scheme first)
19:22:14 <kyevan> SamB: I am, why?
19:22:14 <glguy> shachaf: what do you think Haskell uses?
19:22:20 <glguy> shachaf: what do you think that the type system is?
19:22:20 <glguy> ;)
19:22:21 <sorear> At least I know what "Value semantics" *actually* means.
19:22:22 <SamB> kyevan: oh drat
19:22:26 <shachaf> glguy: That's not what I meant.
19:22:31 <SamB> then you can't get away with using scala instead :-(
19:22:39 <shachaf> glguy: 22:20 < kyevan> shachaf: Because that's what the AP test is in, so that's what we learn in the AP class?
19:22:45 <glguy> AHH
19:22:46 <SamB> kyevan: why do you want to take it?
19:22:47 <Winterstream> bitwize: One thing that I've always wanted is a compiler which isn't a blackbox. I want to know what decisions the compiler is making and I want to be able to help it out.
19:22:59 <glguy> yeah... the channel is moving too fast, I'm just interpolating the conversation
19:23:00 <lament> Winterstream: consider using Forth :)
19:23:08 <SamB> at least my sister doesn't know Haskell. she'll probably enjoy her AP Programming class.
19:23:10 <dons> sorear: so is it a C++-specific thing? about unboxed stack values? the conflation with `unboxedness' as understood in FP seemed wrong or confused
19:23:11 <shachaf> glguy: I do that too.
19:23:16 <bitwize> lament: oh hell yes.
19:23:19 <bitwize> forth rocks.
19:23:22 <kyevan> SamB: I don't really know haskell, either
19:23:34 <lament> bitwize: not for programming, but certainly for staring at in frightened admiration
19:23:36 <dons> qwe's use seemed to be all about stack allocation, not unboxedness
19:23:48 <bitwize> It doesn't have value semantics for anything bigger than a single word though :)
19:23:51 <kyevan> And don't worry, our intro starts out in scheme, so I won't be the only one with very functional-ish java code
19:23:51 <SamB> kyevan: my sister doesn't even know enough to be malcontent with C++ or Java, I'm pretty sure
19:23:56 <Winterstream> Apparently there was a Dylan compiler (or was it an IDE?) which gave you feedback on how much methods could be optimized
19:24:00 <JBGood25> dons, it isn't about being boxed, afaik
19:24:07 <bitwize> Stack allocation *is* unboxedness.
19:24:07 <sorear> dons: value semantics in C-family languages means that you pass a copy of a value when passing it, which only makes sense in mutable languages
19:24:14 <kyevan> Winterstream: Mmm, dylan.
19:24:25 <shachaf> kyevan: What? They teach you Scheme and then move on to Java?
19:24:30 <kyevan> I HATE that language, just because someone I know used it for utils that would be handy to have now
19:24:32 <ddarius> bitwize: All it has is single words.
19:24:48 <SamB> bitwize: stack or in-another-object, yeah...
19:24:49 <kyevan> shachaf: They teach in scheme for a while, yes...
19:24:55 <dons> sorear: so hmm. then its even less clear what qwe was on about with his value semantics for lists on the stack :/
19:25:04 <shachaf> kyevan: What's the point of that?
19:25:09 <bitwize> SamB: You're right about that.
19:25:21 <sorear> dons: Do we know if he actually knows C++?
19:25:35 <dons> well, he wrote a bit of code in python and C++ in two comments this week
19:25:40 <Binkley> @quote qwe1234 c++
19:25:40 <lambdabot> qwe1234 says: c++ is the way it is for a very, very good reason.
19:25:42 <kyevan> shachaf: It's easier to drill the concepts of good documentation and testing into our heads when we aren't haveing to learn Java at the same time, I think is the point :P
19:25:44 <bitwize> He even wrote some haskell code.
19:25:49 <dons> oh?
19:26:09 <glguy> copy / paste + google /= writing code
19:26:22 <Winterstream> Are you guys talking about qwe1234? The text is rolling too fast and I'm too lazy to read everything :)
19:26:26 <dons> i really wouldn't be surprised if qwe turned out to be some other regular on reddit
19:26:42 <kyevan> http://www.double.co.nz/creatures/developer/sharedmemory.htm <- Anyway, have fun implimenting that in haskell
19:26:43 <lambdabot> Title: Shared Memory Interface
19:26:49 <SamB> kyevan: because java is horrible for both?
19:26:52 <kyevan> (Have fun implimenting that in ANY language, actually >_>)
19:26:57 <shachaf> kyevan: You don't document and test Scheme?
19:27:04 <kyevan> SamB: That, and it's just not a good learning language...
19:27:05 <dons> kyevan: ?`shared memory, events and mutexes' ?
19:27:07 <dons> what's hard about that
19:27:15 <Winterstream> Maybe qwe is Naggum reincarnated
19:27:16 <kyevan> dons: IN WINDOWS
19:27:26 <Nafai> Winterstream: HAHA
19:27:33 <bitwize> Remember, write your tests first then your code. Chant the sacred mantra -- RED, GREEN, REFACTOR.
19:27:35 * glguy bops kyevan's nose for the caps
19:27:52 <bitwize> Winterstream: I have proposed that qwe1234 is in fact the dual of Scott "C is dying" Nudds.
19:27:56 <dons> sorear: so i guess  though you didn't read the giant troll threads about value semantics on reddit :)
19:27:57 <kyevan> Dealing with the win32 api is pain enough when you aren't dealing with multiple styles of programming :P
19:28:06 <lament> my intro CS courses were in Java. Among the first things we have learned was UML.
19:28:09 <Winterstream> bitwize: ha ha ha.
19:28:18 <Winterstream> bitwize: I like that characterization
19:28:18 <lament> One of the two courses was almost all UML.
19:28:21 <shachaf> glguy: Don't worry, http://www.cse.unsw.edu.au/~dons/irc/haskell-07.html will do that soon enough.
19:28:21 <lambdabot> Title: #haskell @ freenode.org stats by dons
19:28:30 <bitwize> By the time I saw it the jargon entry for "nasal demons" was obsolete, as compiler implementors had largely switched to speaking of "making Scott Nudds fly out of your nose".
19:28:34 <sorear> dons: Yes.  I read reddit threads occasionally, but I stop as soon as qwe appears.
19:28:43 <dons> that's a good idea
19:28:49 <bitwize> @quote qwe1234 haskell
19:28:49 <lambdabot> qwe1234 says: you forgot the fact that ocaml is used for writing real software that solves real problems, unlike haskell.
19:29:02 * glguy thinks that qwe1234 might be a reddit employee, paid to keep people coming back to defend whatever
19:29:40 <kyevan> I think lambdabot actually has a couple quotes from me, from when I last tried to learn haskell...
19:29:45 <Binkley> ?quote kyevan
19:29:46 <lambdabot> kyevan says: Emacs makes my head hurt almost as much as haskell!
19:29:48 <Binkley> heh
19:29:50 <bitwize> qwe1234 on religion: "so you're telling me that the only good thing about buddhism is changing your whole perspective on life and existence? no thanks, I'll stick with my war god mithras."
19:29:59 <dons> glguy: he drives people off. if I ran reddit I'd ban people like that -- but the reddit guys don't give a toss about community
19:30:01 <Binkley> Hey! qwe1234 is ESR
19:30:02 <Binkley> it has to be
19:30:03 <Winterstream> Ha ha ha ha
19:30:07 <Alleria> I'm trying to write a function to see if an Integer is a square number... the two approaches I've found so far is search a list of square numbers, and to coerce to float, and then take the square root...
19:30:10 <dons> oh, could be, Binkley
19:30:22 <dons> Alleria: coerce? urk?
19:30:23 <Winterstream> bitwize: that was good
19:30:24 <kyevan> There was also this one:
19:30:24 <kyevan> 21:29 <lambdabot> kyevan says: Monads seem like the Mt. Doom of haskell. Looming in the distance and scareing the shit out of me.
19:30:26 <Philippa> Binkley: so who would you pair qwe1234 with?
19:30:26 <Alleria> but the first is slow, and the second doesn't work for very large Integers. Are there better options?
19:30:31 <Binkley> if we see him denying that HIV causes AIDS, then we'll know for sure
19:30:33 <Alleria> dons (1234)::Float
19:30:38 <bitwize> Binkley: No, ESR would only write shitty Haskell.
19:30:43 <dons> oh, not really a coerce then
19:30:55 <bitwize> lots of unsafePerformIOs and that
19:31:05 <Alleria> dons: are there better options I'm missing?
19:31:13 <Binkley> Philippa: I answered that in /msg :-)
19:31:13 <dons> for the new kids, http://programming.reddit.com/info/2cf0o/details
19:31:14 <lambdabot> Title: Yet Another Haskell Tutorial: the most recommended Haskell tutorial (reddit.com)
19:31:20 <dons> Alleria: to take the sqrt of an Integer ?
19:31:26 <Philippa> Binkley: probably wise!
19:31:30 <Alleria> I really just want to see if an Integer is a square number.
19:31:36 * shachaf didn't really like YAHT.
19:31:38 <Alleria> dons: so I'm either searching an infinite list of square numbers...
19:31:40 <bitwize> On his blog he had some Scheme and it was... cringe inducing; he used a `while' loop and `set!' at the bottom to iterate over a range of integers.
19:31:46 <Winterstream> No, ESR would write something about Haskell in the Jargon File, pretending to be a Haskell coder himself
19:31:48 <Alleria> or taking the square root, squaring it, and comparing.
19:31:51 <kyevan> Primefac it!
19:31:58 <Binkley> yeah, ESR would write "Nobody uses Haskell anymore since the Cold War"
19:32:11 <Binkley> and pass off his opinions as those of the entire hacker community
19:32:14 <lament> i blame the communists!
19:32:27 <lament> stop flaming ESR, he _did_ come up with a really cool hacker logo.
19:32:34 <shachaf> It was confusing; it talks about IO early on and introduces "do" as a sort of magical construct for doing that.
19:32:36 <Binkley> stopped clock, right twice a day, etc.
19:32:46 <shachaf> At least, that's what I remember, it's been a while since I looked at it.
19:33:01 <lament> shachaf: that's how i would probably teach haskell if i were ever to teach haskell.
19:33:02 <bitwize> I like my monads unsugared.
19:33:14 <bitwize> And use >> and >>= like, a lot
19:33:29 <dons> mmmmmmmmmm sunday morning coffee.
19:33:33 * dons bounces
19:33:33 <Winterstream> lament: Okay, you're right. it's so tempting. But you're right.
19:33:33 <shachaf> lament: Well, I found it confusing. do { ... if x then do { ...} else do { ...} }, for example.
19:33:41 * glguy uses =<< a lot more than >>=
19:33:51 <kyevan> Se, I get the concept of a monad, I just don't have any idea how it's used, or something
19:33:52 <shachaf> lament: "But I'm already in a do! Why do I need another one?"
19:34:08 <shachaf> glguy: So it'll look like (.)?
19:34:28 <kyevan> I understand that a monad is some sort of impenitrable box (which might be dealt with later?) but anyway...
19:34:33 <lament> shachaf: perhaps avoid examples that cause that until explaining monads (which i would still do very early)
19:34:38 <glguy> kyevan: think of them as script files
19:34:40 <shachaf> kyevan: That would be the "nuclear waste" tutorial?
19:34:43 <kyevan> I'm confused, tired, and trying to remember stuff from many years ago >_>
19:34:45 <lament> kyevan: a monad is just a type. You don't know what types are.
19:34:51 <lament> kyevan: step 1 is clear.
19:34:52 <dons> kyevan: or like taint checking in perl -- if you know perl?
19:34:52 <glguy> kyevan: you can copy a script file, pass it around, wrap it
19:35:01 <glguy> kyevan: and then when you wnant to use it, you run it
19:35:01 <kyevan> lament: I was exagerating the types thing >_>
19:35:05 <glguy> and you can run it over and over
19:35:07 <dons> values from the outside are tainted till your unwrap them with s/// in perl -- that's a monad
19:35:21 <shachaf> lament: Of course, but I think that YAHT starts with IO way too early, and does too much with it.
19:35:22 <kyevan> dons: nope, no perl...
19:35:29 <shachaf> lament: At least, that's the impression I got.
19:35:34 <glguy> kyevan: an IO String is a script file that returns a string, you can't just use that string, yo uhave to run the script first
19:35:42 <lament> shachaf: because everybody wants to write programs that do something.
19:35:55 <RyanT5000> dons: that's really how they untaint things? that seems... dangerous
19:36:04 <dons> it does, RyanT5000, it does.
19:36:05 <kyevan> Eh, I should probably avoid trying to learn this while asleep >_>
19:36:09 <lament> shachaf: it's hard to learn stuff when you can't run programs that print stuff out.
19:36:13 <dons> it is basically an unsafeSubsitute
19:36:18 <shachaf> lament: What's wrong with ghci?
19:36:25 <dons> which relies on you doing a proper s/// for the data you're dealing with
19:36:27 <kyevan> (And while only half-remembering haskell in general)
19:36:44 <shachaf> lament: Or with minimal IO, like just using getLine and print, and interact, etc.?
19:36:46 <dons> kyevan: there must be something here you can read, http://haskell.org/haskellwiki/Blog_articles/Monads :)
19:36:47 <lambdabot> Title: Blog articles/Monads - HaskellWiki
19:36:56 <lament> shachaf: oh, it goes into more IO than that?
19:37:14 <RyanT5000> dons: spidermonkey, on the other hand, has what appears to be an excellent tainting system - it's basically Mandatory Access Controls except that each script can only have one label
19:37:40 <shachaf> lament: I seem to remember it did.
19:37:59 <lament> oh. that's probably not cool.
19:38:17 <shachaf> lament: I might be wrong, but it was confusing (for me).
19:38:38 <lament> still, in general the "explain it later" approach to teaching seems to work pretty well
19:38:58 <shachaf> lament: Sure, in some cases, as long as you don't do too much of it.
19:39:01 <lament> eg it's how math is universally taught...
19:39:06 <shachaf> lament: You have to start with something.
19:39:09 <RyanT5000> lament: teaching is kind of like linking; you can't teach 5 things simultaneously, even though they might be logically recursive
19:39:11 <lament> most people don't even get to the explanation part :)
19:39:24 <SamB> I don't understand how a lot of these project euler problems are supposed to be hard :-(
19:40:03 <glguy> SamB: a lot of them aren't supposed to be :)
19:40:14 <jatqceer> hi, which type is prefered to do simple numeric calculations, [Double] or Array Int Double?
19:40:20 <kyevan> lament: I can't stand "explain it later"
19:40:25 <SamB> glguy: yes but mixed in are ones where you need, say, the sieve of atkin
19:40:31 <dons> jatqceer: for simple stuff, lists
19:40:38 <kyevan> I always need at least /some/ explanation, or I'll not remember it come tomorrow :P
19:40:40 <lament> set theory is a very basic concept within the reach of any primary school student, but it somehow gets deferred until university, while people are taught addition and subtraction
19:40:41 <dons> for numerically intensive stuff, UArray Int Double would be good
19:40:52 <SamB> maybe the sieve of erasthones or whatever his name is works okay too...
19:41:01 <dons> jatqceer: use -O2 -fexcess-precision too , for improved performance
19:41:12 <Winterstream> Ha ha ha. Scott Nudds is hilarious. Scott "Goebbels" Nudds. If you repeat a lie enough times...
19:41:18 <RyanT5000> lament: i've often wondered if gradeschool should begin by teaching logic instead of arithmetic
19:41:34 <Winterstream> I'm looking at his adventures on Usenet...
19:41:45 <kyevan> RyanT5000: I think we need to teach our children math, not arithmetic
19:41:46 <SamB> but, I mean, what's with problem 16?
19:41:49 <jatqceer> dons: usually it's about a few thousand numbers and the task is as simple as calculating the deviation, or a little bit more
19:41:49 <dons> jatqceer: what kind of algorithms are you writing?
19:41:50 <lament> RyanT5000: the biggest hurdle would be "and" and "or" overloaded in everyday speech
19:41:57 <dons> jatqceer: ok, lists should be fine
19:42:06 <dons> and you get pattern matching, and the list library, so much more flexible
19:42:06 <kyevan> But, we will ALWAYS teach for the stupid kids, sadly :(
19:42:07 <RyanT5000> lament: then they could also teach people to be better at critical thought, which, imho, is a lot more important to society than arithmetic
19:42:43 <lament> RyanT5000: i'm not sure if "logic" (symbolic manipulation of statements) has anything whatsoever to do with critical thought (except that people good at critical thought are often good at symbolic manipulation)
19:42:51 <SamB> or with number 13?
19:43:06 <kyevan> lament: Well, You're actually engageing the brain,
19:43:11 <kyevan> So, yeh, that helps >_>
19:43:18 <RyanT5000> lament: understanding simple logics at least makes it easier to diagram a logical fallacy
19:43:36 <shachaf> lament: See http://en.wikibooks.org/wiki/Haskell/YAHT/Io for the first IO section in YAHT. It may not be as bad as I remembered, but I still don't like it.
19:43:36 <jatqceer> dons: because i'm thinking of writing some jackknife analysis code, i'm not sure if this kind of task is well suited in haskell
19:43:38 <lament> kyevan: just the fact we're speaking English right now requires a lot more brain activity than some silly easy logic problem.
19:43:40 <RyanT5000> lament: and it also would help untrain thinking of english's "or" as xor
19:43:44 <kyevan> I think you could easily get by until algebra as a vegitable
19:43:59 <lament> RyanT5000: why would you want to untrain that? That's what english or means.
19:44:00 <kyevan> lament: Different part of the brain, though
19:44:08 <jargonjustin> Is there a point-free way of writing (\x -> x - 65) ?
19:44:15 <RyanT5000> lament: no it isn't; the exclusiveness is just an implication
19:44:19 <Binkley> @pl (\x -> x - 65)
19:44:19 <lambdabot> subtract 65
19:44:20 <shachaf> jargonjustin: (subtract 65)
19:44:24 <SamB> lament: yes, it helps to be able to do deductive reasoning if you want to at least know where you stand...
19:44:33 <glguy> is subtract a lambdabot function? or a Prelude one
19:44:37 <dons> jatqceer: what algorithms are involved?
19:44:38 <jargonjustin> Binkley, shachaf, thanks
19:44:38 <Binkley> :t subtract
19:44:41 <lambdabot> forall a. (Num a) => a -> a -> a
19:44:41 <glguy> ?index subtract
19:44:41 <lambdabot> Prelude
19:44:41 <shachaf> glguy: Prelude, I think.
19:44:43 <dons> and what data structures?
19:44:43 <kyevan> RyanT5000: Oh, no, that can be done without that
19:44:52 <kyevan> All you need to do is be a smartass all the time.
19:44:54 <RyanT5000> lament: that's why usually in laws when they say "a or b" they then spend about a sentence explaining whether they mean "or" or "xor"
19:45:06 <lament> RyanT5000: yes, because english does not have a word meaning "logical or"
19:45:15 <lament> other than "either/or"
19:45:23 <lament> "and/or"
19:45:25 <lament> i mean
19:45:30 <kyevan> "Do you want fries or onion rings?" "Yes."
19:45:48 <shachaf> kyevan: That works with xor too.
19:45:53 <RyanT5000> lament: there's definitely an ambiguity, or no one would ever feel like saying "but not both" afterwards
19:46:07 <SamB> shachaf: if she said xor you might say "no!" and want both
19:46:08 <jatqceer> dons: algorithm?  it's just some post-analysis of data generated by MC.
19:46:09 <lament> RyanT5000: true. it's a little fuzzy.
19:46:12 <kyevan> True :P
19:46:15 <shachaf> SamB: Of course.
19:46:19 <shachaf> SamB: But it still works.
19:46:35 <SamB> yeah
19:46:35 <RyanT5000> lament: right; and "clever" people can use that against people who aren't thinking critically enough :)
19:46:40 <lament> RyanT5000: but then again, English has lots of more significant issues, and it's still a great language :)
19:46:45 <dons> jatqceer: sounds like a good job for haskell then? so parsing, a bit of analysis, then pretty printing?
19:47:00 <dons> what would your other options be for writing such code?
19:47:01 <SamB> and and/or isn't that long compared to a sentance
19:47:08 <jatqceer> dons: like jackknife, bootstrap, if you know these terms in statistics
19:47:14 <RyanT5000> lament: yeah, but i was just arguing that it would be better if people realized "or" was potentially ambiguous
19:47:23 <RyanT5000> ambiguity isn't bad as long as the recipient realizes it's there
19:47:49 <lament> i think everybody realizes it, except for some confused aspie programmers
19:47:55 <kyevan> Next time someone asks me if I want "x or y" I'm going to say both, and if they say I'm greedy, I'll say they offered both. Or something
19:47:55 <dons> jatqceer: i don't, but statistics (and math in general) is pretty nice in haskell. many people recommend haskell for simple (or complex) math. was there anything you were particularly concerned by/
19:48:07 <RyanT5000> but, e.g., when there's ambiguity a lawyer or judge can see, but a normal person can't, then you can exploit it to write a contract that tricks the person
19:48:09 <SamB> poisonous-snake-like programmers?
19:48:09 <jatqceer> dons: some of my colleagues actually use perl, python or even C++, those kind of thing
19:48:09 <lament> kyevan: yes, and they'll think you're nuts, and they'll be right.
19:48:22 <kyevan> lament: I don't think I'm nuts,
19:48:30 <kyevan> I /know/ I'm nuts!
19:48:45 * kyevan refers to emself using spivak pronouns! Of course ey's nuts!
19:49:01 <SamB> jatqceer: we don't really have any way to address those concerns ;-)
19:49:04 <Philippa> oh dear, here comes the gender discussion again
19:49:14 <dons> jatqceer: oh, huh. well its a easy drop in for perl or python -- and about 10-30x faster. and safer than C++
19:49:25 <SamB> Philippa: what? who?
19:49:28 <kyevan> Gender isn't a boolean, let's leave it at that :P
19:49:33 <jatqceer> dons: some simple thing that gnu R does and some more things need specific programs
19:49:34 <bitwize> @quote qwe1234 scheme
19:49:34 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
19:49:37 <lament> RyanT5000: contracts are written in a special language that avoids most such ambiguities. The issue here is not that the reader doesn't understand the logic - it's just that they don't know the language.
19:49:39 <SamB> oh.
19:49:53 <lament> RyanT5000: and yes, it would probably be useful if basic law were taught in schools :D
19:50:01 <SamB> @all-dict spivak
19:50:02 <lambdabot> No match for "spivak".
19:50:09 <Philippa> that's because it's a proper noun
19:50:11 <Binkley> @go spivak gender
19:50:11 <dons> jatqceer: yeah, if it was very very mathy, i'd use R or some other specific math language, but general analysis, you want a hihg level, fast language, with good math support (== haskell, imo).
19:50:13 <lambdabot> http://en.wikipedia.org/wiki/Spivak_pronoun
19:50:13 <lambdabot> Title: Spivak pronoun - Wikipedia, the free encyclopedia
19:50:14 <hpaste>  Shine pasted "functional ASCII art" at http://hpaste.org/2070
19:50:15 <jatqceer> SamB: right, i googled and couldn't find a decent library for statistics analysis
19:50:16 <bitwize> http://en.wikipedia.org/wiki/Spivak_pronoun
19:50:16 <lambdabot> Title: Spivak pronoun - Wikipedia, the free encyclopedia
19:50:18 <Shine> looks like writing binaries is not very easy in Haskell for a newbie like me, so I've implemented an ASCII output. Is it possible to use "||" inside "theEye" without the extra "add" function?
19:50:19 <bitwize> crap.
19:50:28 <RyanT5000> lament: i'm not just talking about lawyer-lawyer contracts; the especially bad ones are lawyer-person and person-person; also, there's promises made by politicians, etc.
19:50:31 <dons> Shine: you want  to use bytestrings?
19:50:33 <SamB> jatqceer: that, *you* could probably address
19:50:37 <msouth> lament: that would probably work just as well as teaching basic math in schools
19:50:41 <lament> RyanT5000: well, those are just plain lies :D
19:50:44 <Shine> dons: I don't know :-)
19:50:53 <bitwize> Is this some sort of admission that lawyers are not in fact human?
19:50:57 <lament> msouth: i'm not saying it would work well. :)
19:51:02 <SamB> RyanT5000: yeah, lawyer-lawyer contracts are probably more normal looking
19:51:02 <RyanT5000> lament: but they're good enough to trick most people for long enough to win the election :P
19:51:23 <SamB> since they know they aren't going to get away with any funny business anyway, why bother even trying?
19:51:25 <shachaf> Male | Female | FileNotFound?
19:51:31 <jatqceer> dons: so you think making [Double] of size a few thounds is a good idea?
19:51:39 <dons> jatqceer: yeah, the math libs are here, but i'm not sure if we have any statistical stuff yet, http://haskell.org/haskellwiki/Libraries_and_tools/Mathematics
19:51:40 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki
19:51:42 <RyanT5000> SamB: if only that were true :P nash equilibrium says otherwise
19:51:49 <dons> jatqceer: a few thousand should be just fine
19:51:52 <Shine> dons: I've read something about the Data.Binary, but looks very different from the usual imperative approach which is opening a file and writing something from a loop
19:51:54 <Binkley> shachaf: you need intersection types at the least
19:51:58 <RyanT5000> SamB: although you do get a lot of the "wherefore" shit cut out
19:52:06 <dons> are you mutating them a lot though? replacing elements? or just reducing the data?
19:52:13 * RyanT5000 is in law school (by way of justification of speaking authoritatively on such matters)
19:52:14 <sorear> jatqceer: also, remember Haskell is lazy.  if you only make 1 pass over a list, only one element will actually exist at a time
19:52:24 <sorear> jatqceer: remember that !! and friends are O(n)
19:52:33 <dons> Shine: what are you trying to do? and what's this loop business?
19:52:34 <Philippa> Binkley: and then you still have to figure out the type you like to intersect with
19:52:35 <SamB> RyanT5000: well, I mean, if the other lawyer is just going to say "come on, you can't seriously expect me to read this shit!"
19:52:37 <lament> RyanT5000: oh, you're a filthy stinking lawyer. I'm not talking to you anymore :)
19:52:45 <Binkley> Philippa: right, and then you need polymorphism
19:53:00 <lament> SamB: contracts aren't written to confuse.
19:53:02 <RyanT5000> lament: no i'm not! lol i might never take the bar, just so that no one can ever call me a lawyer :P
19:53:04 <Shine> dons: see my paste, I don't mutate it, every pixel is calculated once
19:53:07 <lament> SamB: Are programs written to confuse?
19:53:16 <SamB> lament: I think you have it backwards
19:53:16 <Binkley> lament: depends if the programmer is getting paid by the line
19:53:37 <SamB> also it depends on if the programmer is worried about his job security or not
19:53:53 <SamB> s/if/whether/
19:53:53 <lament> SamB: why are programs so big and complicated? Instead of writing "Computer, run a 3d shooter game where i kill demons", you have to provide many thousands of lines of code! Why?
19:53:53 <RyanT5000> SamB: the main reason for complication in lawyer-lawyer contracts it that they go through every related case on the books, and throw in special language to deal with that situation
19:53:55 <jatqceer> sorear: actually I figured out foldl' (+) 0 is faster than sum ;(
19:54:12 <SamB> RyanT5000: ah.
19:54:12 <Binkley> @src sum
19:54:12 <lambdabot> sum = foldl (+) 0
19:54:20 <Binkley> there you go
19:54:21 <RyanT5000> SamB: there are no closed sets of possibilities in law (except a few things, like real estate transfers, of which there are approximately 10 types, and that's it)
19:54:22 <shachaf> Doesn't -O2 optimize it?
19:54:41 <SamB> lament: couldn't you just write one much like this:
19:54:41 <shachaf> > sum [1..1000000]
19:54:44 <lambdabot>  500000500000
19:54:44 <SamB> quake&
19:54:45 <dons> jatqceer: right, but with -O2 it should be compiled to the same thing
19:54:55 <RyanT5000> one thing i'd really love to see is a legal system based on a language that can be mostly interpreted by a computer, with hooks for a judge and jury
19:55:02 <shachaf> On my GHCi, that doesn't work, but lambdabot is -O2.
19:55:09 <Shine> dons: but I don't have an idea how to translate the Data.Binary example at http://www.cse.unsw.edu.au/~dons/binary.html to my case and writing some pixels
19:55:09 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
19:55:12 <dons> ghci is different. it doesn't optimise at all
19:55:18 <SamB> okay for real it's "nq-sgl&", I think
19:55:25 <jatqceer> dons: i don't know, it's different here
19:55:27 <dons> Shine: you want to write out a structure?
19:55:36 <dons> jatqceer: compiled with -O2 ?
19:55:41 <dons> on a list of Double or Int?
19:55:42 <sorear> dons: no, he's writing TGA-format image files
19:55:46 <RyanT5000> (and, if you want to get a little more abstract about it, hooks for politicians and voters and such)
19:55:55 <Winterstream> 10 years ago: Scott Nudds: "No personal computer will ever have gigabytes of RAM"
19:55:56 <dons> ah so you need a haskell type for TGA, then write a binary instance for that type
19:55:57 <lament> SamB: i'm sure you see my point.
19:56:00 <Winterstream> God, that is funny
19:56:04 <jatqceer> dons: Double
19:56:04 <dons> or else use the Put monad directly
19:56:15 <Shine> dons: currently it is a list of lists, maybe I just have to learn what data and instance means :-)
19:56:21 <dons> jatqceer: oh, I think that's because 'sum' isn't optimmised to strict sum for anything other than Int or Integer
19:56:28 <dons> Shine: yeah
19:56:32 <pjd> applicative functors are so shiny
19:56:45 <sorear> Shine: I *strongly* advise using PPM instead.  It's much simpler than every other image format I've seen
19:56:59 <dons> pjd, want to write something about them?
19:57:05 <RyanT5000> tga is a beast
19:57:11 <dons> we've got blogs on monads, comonads, arrows, but nothing yet on applicatives
19:57:26 <pjd> is there any definitive example of when you need a full monad, instead of an applicative functor?
19:57:32 <Philippa> IIRC writing TGA's a lot easier than reading any and all TGAs
19:57:36 <dons> when you need bind?
19:57:38 <jatqceer> dons: I see.  I was thinking of trying UArray, but it seems leaving all those List functions is painful
19:57:38 <Winterstream> Yes, I discovered applicatives today. It would be nice to have some example code...
19:57:41 <Shine> sorear: I've used TGA output before, it is very simple. Just write some header and then you can output 8 bit RGB values for the rest of the file
19:57:59 <dons> jatqceer: yes, i'd stick to lists unless you know you need O(1) indexing, or do a lot of mutation
19:58:09 <pjd> dons: right, but i only understand that in the abstract
19:58:15 <sorear> Shine: How complicated is the header?  PPM is the same way, but the header looks like "P6 32 32 255\n"
19:58:24 <sorear> Shine: width, height, maximum sample value
19:58:34 <pjd> dons: if i had a journal, i would write something about them :)
19:58:48 <Winterstream> PPM is nice. I coded it up in Java. That's a lot to say, because Java's IO is so verbose...
19:58:50 <shachaf> pjd: When you need join? :-)
19:59:40 <jatqceer> dons: that is the issue, now.  jackknife basically is leaving one number and analyse the rest.  and repeat it for all the numbers in the data set
19:59:50 <Shine> sorear: see my function write-tga: http://groups.google.de/group/comp.lang.lisp/msg/296c1ae569bd1035
19:59:50 <pjd> shachaf: right, but i don't grasp the intuition yet
19:59:51 <lambdabot> Title: Mandelbrot with TGA output - comp.lang.lisp | Google Groups
19:59:58 * pjd continues reading
20:00:05 <bitwize> PPM is what I used to get some sort of output from my blitter library.
20:00:07 <lmbdwr> hello, has anyone ever used recursive post-conditions or know where I can find a bibliographic reference about it ? (not haskell specific)
20:00:24 <bitwize> and also to produce this:
20:00:27 <bitwize> http://www.deviantart.com/deviation/60799166/
20:00:28 <lambdabot> Title: Beautiful Mandelbrot Set by ~bitwize on deviantART
20:00:34 <shachaf> pjd: Well, when you only use liftMn, fmap, and return.
20:01:02 <shachaf> pjd: Just see what you use; if you have to use do-notation or bind/join, then use a monad, otherwise use an applicative functor.
20:01:14 <shachaf> s/use/require/g, possibly.
20:01:18 <pjd> no, i understand that much
20:02:04 <pjd> i guess when i'm able to frame my question properly, i'll know the answer
20:02:32 <sorear> bitwize: that page is just a bunch of obfuscated javascript
20:02:33 <Shine> bitwize: the problem is that many programs can display TGA, e.g. the builtin Windows XP image viewer, but not PPM, which helps if e.g. someone wants to try it on Windows
20:03:08 <jatqceer> dons: basically taking a subset of the group of data and do something with it and choose a different subset and do it repeatedly
20:04:47 <dons> jatqceer: ok, so maybe arrays, if lists turn out to be a problem (though given take/drop, you might be fine. and a few thousand elements isn't much)
20:05:08 <bitwize> sorear: try looking at it in mozilla or something else that understands obfuscated javascript :)
20:05:20 <dons> the point is probably more to have correct analysis code, which will be the haskell advantage there
20:06:09 <bitwize> I really think DA could do without the XmlHttpRequest hackery but they won't even listen to my bug reports about their smiley interpolation interfering with their Unicode character reference interpolation.
20:06:11 <sorear> bitwize: I have a moral objection to running massively bloated C++ programs. ;)
20:06:40 <shachaf> sorear: Are there no massively bloated browsers that understand obfuscated Javascript?
20:06:45 <jatqceer> dons: thanks.  I'll try.  probably take/drop is enough.
20:07:00 <jatqceer> and using lists makes the code easy to read
20:07:10 <sorear> shachaf: We need to write one in Haskel!
20:07:49 <shachaf> sorear: There's Opera (though that can have its own moral objections, possibly); I don't think it's very bloated.
20:08:37 <ddarius> Shine: render fun = [fun x y | x <- [0..39], y <- [0..39]]
20:08:53 <ddarius> shachaf: He has no objection to bloated, just C++.
20:09:01 <RyanT5000> sorear: i'm writing a haskell binding for firefox's javascript API right now
20:09:21 <RyanT5000> sorear: so, if you're talking about writing a browser :)
20:09:32 <Shine> ddarius: thanks, that's better
20:09:39 <sorear> RyanT5000: What advantage would I have over FF, then? ;)
20:09:54 <Shine> any ideas how I can "inline" the "add" function into the "theEye" function? Maybe I have to use the curry or uncurry function?
20:10:02 <shachaf> sorear: Well, at least the UI wouldn't use Gecko.
20:10:17 <lament> i have to admit i've never heard of "PPM" or "TGA" before
20:10:23 <RyanT5000> sorear: yeah; that'd be an advantage
20:10:45 <shachaf> Shine: curry and uncurry are only for when you're working with tuples.
20:10:47 <RyanT5000> sorear: i missed your original complaint, though
20:10:54 <shachaf> Shine: Otherwise everything is curried.
20:10:54 <ddarius> Shine: foldr (++) "" = concat and concat . map lineToAscii can be replace with simply unlines
20:11:16 <sorear> RyanT5000: It takes longer to start up than Emacs and uses more memory than GHC.
20:11:21 <ddarius> Shine: Isn't add generally useful?
20:11:27 <RyanT5000> sorear: good complaint.
20:12:06 <Shine> ddarius: I don't know, I have the feeling that it is very like the same like "||" and I just don't know the syntax how to use "||" instead of an extra function
20:12:11 <RyanT5000> sorear: i use opera :P
20:12:43 <ddarius> Oh wait, my redefinition of render is broken, you're producing a list of lists.  You can however simply inline the definition of renderLine into render.
20:13:45 <ddarius> Shine: You can make a generic combinator to lift a Bool -> Bool -> Bool to functions.
20:14:25 <Shine> this sounds interesting :-)
20:18:57 <hpaste>  ddarius annotated "functional ASCII art" with "just how I'd write it, mostly minor changes" at http://hpaste.org/2070#a1
20:19:08 <ddarius> That's untested.
20:19:22 <ddarius> The liftM2 is mildly evil.
20:21:15 <RyanT5000> dons: does the haskell GC need to be written in C to be fast? or could it be supplanted by haskell code?
20:21:38 <RyanT5000> dons: obviously, ignoring the recursion issues
20:21:46 <RyanT5000> (why am i asking dons?)
20:22:02 <ddarius> RyanT5000: The recursion issue is the first thing that would need to be dealt with.
20:22:03 <SamB> RyanT5000: I thought it was written in C--?
20:22:10 <sorear> RyanT5000: it's written in C to be fast, and because it can't be recursive.
20:22:15 <sorear> SamB: Storage.c
20:22:22 <RyanT5000> what about GC.c?
20:22:25 <SamB> still in C eh?
20:22:35 <SamB> I guess they like it that way ;-)
20:22:53 <RyanT5000> sorear: is it really impossible to have a GC be recursive?
20:22:55 <sorear> SamB: C is a much better programming language than C--, because C is first and foremost a programmming language.C-- is first and
20:22:58 <ddarius> It may be better to write scale and translate as tuple to tuple functions.
20:23:01 <RyanT5000> sorear: it could just make itself a root
20:23:08 <SamB> RyanT5000: what do you suppose the garbage collectors for CL implementations are written in?
20:23:09 <sorear> SamB: C-- is first and formost a IR
20:23:30 <Shine> ddarius: liftM2 looks interesting. I've tried "combinator operator fun1 fun2 x y = operator (fun1 x y) (fun2 x y)" and then "theEye = combinator (||) circle1 circle2 where ...", but it doesn't work
20:23:51 <RyanT5000> SamB: i would think they'd write them in CL :P
20:23:59 <SamB> RyanT5000: it may rather resemble CL
20:24:02 <sorear> RyanT5000: Haskell code allocates, a lot.  The GC is called when the heap is full.  How do you allocate when the heap is full?
20:24:17 <SamB> but I'm betting that it's actually just bad syntax for a low-level language
20:25:15 <RyanT5000> sorear: what if you had cascading heaps, with the root heap being GCed by a C GC?
20:25:24 <RyanT5000> sorear: or something like that
20:25:28 <SamB> RyanT5000: anyway, we Haskell users know when to use a low-level language ;-)
20:25:53 <SamB> well. sometimes we do ;-)
20:25:57 <RyanT5000> SamB: well, it would be nice if our GC at least had C hooks, lol
20:26:10 <SamB> hooks?
20:26:20 <chessguy_> @pl e S x = S x
20:26:20 <lambdabot> e = id
20:26:22 <hpaste>  ddarius annotated "functional ASCII art" with "with transformations?" at http://hpaste.org/2070#a2
20:26:37 <RyanT5000> SamB: yeah, so that i could integrate the javascript GC with the haskell one
20:26:41 * SamB thinks E may have issues
20:26:43 <SamB> er.
20:26:44 <SamB> @pl
20:26:45 <lambdabot> (line 1, column 1):
20:26:45 <lambdabot> unexpected end of input
20:26:45 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
20:26:51 * SamB is confused
20:26:56 <chessguy_> @pl e S x = S x; e S' x = f x
20:26:56 <lambdabot> (line 1, column 12):
20:26:56 <lambdabot> unexpected ";"
20:26:56 <lambdabot> expecting variable, "(", operator or end of input
20:27:03 <ddarius> Shine: That definition of combinator should work.
20:27:18 <SamB> chessguy: it doesn't grok multi-case definitons
20:27:31 <chessguy_> well fooey
20:27:36 <SamB> I'm betting it doesn't do case expressions either
20:28:02 <RyanT5000> SamB: i need a hook so that i can tell it how to get to haskell objects that are on the other side of JS objects
20:28:26 <SamB> RyanT5000: I don't think you can win this one :-(
20:28:40 <sorear> RyanT5000: That's what stable pointers and foreign pointers are for.
20:28:42 <Shine> ddarius: this looks cool, thanks. Now I have to read some manuals to understand it :-)
20:28:43 <lament> I have earlier asked about FRP and people directed me to a page with links to ~20 papers. Is there _one_ paper i could read? :)
20:28:46 <SamB> RyanT5000: even if you had plenty of hooks, you'd still have cycles to contend with
20:29:11 <ddarius> lament: If there is 20 surely there is one.
20:29:29 <SamB> lament: they didn't appear to be in any particular order?
20:29:39 <SamB> @where frp
20:29:39 <lambdabot> I know nothing about frp.
20:29:42 <SamB> @where FRP
20:29:42 <lambdabot> I know nothing about frp.
20:29:56 <RyanT5000> SamB: i'm sure with appropriate hooks, i could do it; basically, i need to be able to provide a function that gets all the stableptrs reachable from a foreignptr
20:30:43 <SamB> RyanT5000: a C function?
20:30:50 <RyanT5000> SamB: that'd be good enough
20:31:20 <SamB> well, you could try asking on the mailing list about it
20:31:55 <RyanT5000> yeah, i might do that
20:32:25 <lament> SamB: chronological (http://haskell.cs.yale.edu/yale/publications.html)
20:32:26 <lambdabot> Title: Yale Haskell Group Publications
20:32:45 <ddarius> lament: Pick the newest one that sounds like a general overview.
20:33:17 <SamB> probably not "Functional Automatic Differentiation with Dirac Impulses"
20:33:21 <lament> none of them sound like a general overview
20:33:31 <dons> huh http://www.cafepress.com/quhaha.151723593
20:33:37 <ddarius> Functional Reactive Programming Continued
20:33:47 <lament> right
20:34:06 <lament> there's "Continued", but what it continues is absent
20:34:26 <SamB> http://haskell.cs.yale.edu/yale/papers/pldi00/index.html
20:34:27 <lambdabot> Title: pldi 2000 - Functional Reactive Programming from First Principles
20:34:31 <SamB> how about that?
20:34:58 <ddarius> lament: You can read more than one.
20:35:17 <ddarius> You're looking at 10-15 pages typically.
20:36:10 <SamB> also perhaps look at http://conal.net/
20:36:11 <lambdabot> Title: Conal Elliott's home page
20:36:38 <lament> it seems they all center on robotics and animation
20:37:52 <ddarius> lament: versus?
20:38:22 <SamB> lament: did you want gaming or something?
20:38:54 <lament> at this point i'm just interested because it sounds cool.
20:38:54 <lucca> hm.... what happened to The Monad Reader?
20:39:02 <ddarius> lucca: ?
20:39:15 <lucca> it's quarterly...
20:39:18 <lucca> am I off by a month?
20:39:23 <lucca> we eagerly await more!
20:39:42 <ddarius> There was a call for copy for Issue 8 recently.  I think it's biannual now.
20:39:53 <lucca> ah.....
20:41:18 <ddarius> Maybe it is quarterly.  The deadline (presumably for submissions) for Issue 8 was July 27th
20:44:42 <chessguy> @srx (.)
20:44:42 <lambdabot> (.) f g x = f (g x)
20:45:17 <SamB> http://conal.net/fran/
20:45:18 <lambdabot> Title: Functional Reactive Animation (Fran)
20:45:58 <SamB> is it just me or is that gif at the top made of photos of his kids?
20:47:19 <bitwize> well if you had kids wouldn't you want to include the little darlings in EVERYTHING you do? :)
20:47:38 <lament> oh god
20:47:51 <lament> my eyes
20:48:08 <bitwize> the goggles do nothing?
20:48:15 <lament> "Here is a tutorial article on Composing Reactive Animations. (The animated GIFs total 2Mb. Please be patient)"
20:48:30 <SamB> lament: was it only 2 megs?
20:48:51 <sorear> Please note that conal is a #haskeller. ;)
20:49:01 <SamB> also, why'd you need to be patient?
20:49:24 <Binkley> SamB: long, long ago when dinosaurs ruled the earth and we all used dialup, 2 MB was a lot
20:49:27 <SamB> apparantly he believes fran to have probably bitrotted
20:49:58 <SamB> Binkley: well, looking at what all he's got here I'm surprised it's not a lot more!
20:52:57 <chessguy> are there not windows binars of ghc HEAD available?
20:53:28 <SamB> chessguy: I should hope there'd be a buildbot
20:53:36 <chessguy> huh?
20:54:31 <SamB> http://darcs.haskell.org/buildbot/head/
20:54:33 <lambdabot> Title: BuildBot: GHC
20:54:41 <chessguy> i don't see anything on http://www.haskell.org/ghc/dist/current/dist/ that would seem to be a windows binary
20:54:42 <lambdabot> Title: Index of /ghc/dist/current/dist
20:55:10 <chessguy> oh, it isn't able to build for windows currently?
20:55:52 <SamB> that does seem to be the case
20:56:01 <SamB> though I hadn't determined that before pasting the link
20:56:12 <chessguy> well fooey
20:56:13 <SamB> note that I've never seen this page before in my life
20:57:54 <ddarius> "Dijkstra pointed out that no other subject has to encompass ratios of the order of 10^10 or more." Huh?  How did Dijkstra get ratios?
20:58:25 <chessguy> so does that mean i can't get the source and build it myself either?
20:58:35 <Binkley> chessguy: you can certainly get the source and build it yourself
20:58:54 <ddarius> sorry I omitted "... ratios between the level of detail in it's objects of study of ..."
20:58:54 <chessguy> Binkley, but if they can't build it, why would i be able to?
20:59:26 <Binkley> chessguy: oh, I didn't notice the builed failed there
20:59:39 <SamB> not sure
21:00:00 <Binkley> chessguy: you could figure out when the last successful build was and fetch the HEAD as of that date...
21:00:00 <chessguy> i'll pop over to #ghc
21:00:06 <SamB> chessguy: one of these was a cabal issue...
21:00:23 <SamB> I mean it couldn't find a cabal module it needed
21:00:56 <SamB> > 4296/60
21:01:04 <lambdabot>  71.6
21:02:03 <dons> > 4296/60 :: Rational
21:02:05 <lambdabot>  358%5
21:02:23 <dons> > 4296/60 :: Fixed E6
21:02:24 <lambdabot>  71.600000
21:02:30 * dons practices
21:02:51 <SamB> dons: I don't care about seeing the number of minutes until the fast windows buildbot stops waiting
21:03:05 <SamB> (dunno what it's going to do when it stops waiting ;-)
21:05:35 * chessguy really wants that debugger
21:05:53 <RyanT5000> chessguy: what are you debugging?
21:06:06 <chessguy> RyanT5000, mostly for pedagogy
21:06:08 <sorear> chessguy: 'darcs unpull'
21:06:11 * SamB 's dog is making those funny dream-bark noises again
21:06:12 <RyanT5000> chessguy: ah
21:06:23 <chessguy> sorear, 'complete sentence'
21:07:07 <chessguy> SamB, the leg-twitches are the best
21:07:22 <SamB> I seem to have woken her up
21:07:23 <sorear> chessguy: Use the darcs unpull command to remove the pointer-tagging patch and all that depends on it.
21:08:09 <chessguy> sorear, ah, so HEAD did build on windows at one point?
21:08:15 <sorear> yes
21:08:56 * chessguy didn't even know you could 'darcs get' HEAD
21:09:27 <chessguy> err, can you?
21:09:44 <sorear> yeah
21:09:47 <sorear> we use darcs now
21:10:05 <sorear> even though we announce on cvs-ghc and call the most recent version HEAD
21:10:06 <chessguy> hm. ought to update http://haskell.org/ghc/download.html
21:10:06 <lambdabot> Title: The Glasgow Haskell Compiler
21:10:40 <chessguy> so what's the darcs repo?
21:11:09 <sorear> http://darcs.haskell.org/ghc -- afair
21:11:12 <lambdabot> Title: Index of /ghc
21:11:59 <sorear> 12,000 patches
21:12:09 <chessguy> lovely
21:12:38 <wli> I had to get over 16000 patches.
21:12:55 <chessguy> what if i just get --partial?
21:13:06 <sorear> it will just work
21:13:28 * chessguy lets it run over night
21:13:47 <wli> chessguy: It only took 20 minutes here.
21:14:10 <chessguy> wli, i don't know if i'll be able to stay awake that long :)
21:14:38 <wli> Well I'm not insisting that you watch it spin.
21:15:46 <RyanT5000> chessguy: queue up all the build commands and go to sleep :)
21:16:28 <wli> sorear: I was trying to figure out how to get ghci to accept type (and hopefully typeclass and instance) declarations at the command-line.
21:17:02 <chessguy> Copying patch 565 of 565... done!
21:17:06 <wli> sorear: I think it may be a bit much for me to deal with.
21:17:08 <Binkley> join #haskell-blah
21:17:13 <Binkley> oops
21:22:24 <lispy> http://haskell.org/haskellwiki/Simple_STM_example <-- what should the program print for as the value of 'after' ?
21:22:25 <lambdabot> Title: Simple STM example - HaskellWiki
21:22:40 <lispy> it should print 0, right? we 10 times we added 2, and 20 times we took the pred
21:23:12 <lispy> > 25*20 + 10 * 50 + 20*25
21:23:14 <lambdabot>  1500
21:23:17 <lispy> hmmm
21:23:20 <lispy> i thin i see the problem
21:23:52 <wnoise> Hi everybody.  Anybody have a parser library (or parser generator) to recommend that plays nicely with ByteStrings?
21:24:18 <lispy> wnoise: someone really needs to fix parsec :)
21:24:26 <chessguy> sorear, do i want to "./darcs-all pull -a" first, and then do the unpulls?
21:24:26 <RyanT5000> why doesn't parsec work?
21:24:27 <lispy> well, update
21:24:38 <RyanT5000> oh, i guess it needs "lists"
21:24:42 <RyanT5000> there should be a class List
21:24:43 <RyanT5000> >.>
21:24:47 <dons> wnoise: there's only the SoC parsec/bytestring lib, that I'm aware of, but it isn't released yet
21:24:47 <chessguy> lispy, wnoise, it's being worked on
21:24:48 <ddarius> lispy: Isn't there a project for that?
21:25:01 <chessguy> @where SoC
21:25:01 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
21:25:09 <sorear> chessguy: No, you need to ./darcs-all get before you do anything else
21:25:15 <sorear> chessguy: then unpull
21:25:15 <wnoise> I was hoping John would update frisby, actually.
21:25:37 <chessguy> sorear, yeah, i meant after the darcs-all get
21:25:44 <sorear> @seen JohnMeacham
21:25:44 <lambdabot> JohnMeacham is in #haskell-blah and #haskell. I last heard JohnMeacham speak 7h 37m 26s ago.
21:26:07 <sorear> chessguy: Uhm... why do you think pulling would do anything?  you just did a fresh get?
21:26:37 <ddarius> sorear: Someone might have submitted a patch between then and now!
21:27:02 <chessguy> sorear, well, i haven't broken open the darcs-all script, so i didn't know if it was literally doing a darcs pull or what
21:27:46 <wnoise> Well, I guess I'll just play around with the current non-ByteString ones and see if they're too inefficient.
21:27:55 <chessguy> i was just reading down over http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources
21:27:59 <lambdabot> Title: Building/GettingTheSources - GHC - Trac, http://tinyurl.com/y3nvjj
21:28:17 <ddarius> wnoise: It really should be mindlessly simple and not too tedious to convert Parsec to ByteStrings.
21:28:18 <chessguy> and i'm a little tired :)
21:28:31 <lispy> ddarius: it's harder than you'd guess
21:28:34 <ddarius> But, yeah, see if they do what you need now.
21:28:38 <sorear> chessguy: yeah, darcs-all get --options => get --partial --options all the core libs   darcs-all --extra get --options => get --partial --options the extralibs  darcs-all othercmd => othercmd all the downloaded libs
21:28:39 <dons> wnoise: what things are you parsing?
21:28:47 <ddarius> lispy: For lazy bytestrings?
21:28:48 <lispy> ddarius: i tried and failed
21:28:56 <chessguy> ddarius, why in the world would you encourage someone to work on something which is already being done for SoC?
21:29:16 <ddarius> chessguy: That's what I thought, but I was not sure.
21:29:23 <ddarius> lispy: What was the problem?
21:29:24 <lispy> ddarius: i thought, "Hey, this is quick, mostly mindless just replace this with that." but it turns out that the parsec internals are fairly complex
21:29:42 <lispy> ddarius: it's been 6+ months i don't remember where the hurdles were
21:29:45 <wnoise> PDF.  AFAICT, there isn't a haskell parser, and the ones in reasonable languages don't quite give me enough control to do what I want.
21:29:52 <ddarius> lispy: They've grown in complexity since the last time I looked at them?
21:30:20 <sorear> wnoise: you can use string parsec on PDF (don't expect it to be terribly fast, but it shouldn't be *too* slow either)
21:30:27 <lispy> ddarius: if this is an easy task for you, then by all means please do it :)
21:30:34 <dons> wnoise: hmm, i think there is a pdf parser .hmm. but bytestrings would really be best for that
21:30:42 <dons> let me see if i can find that thingy
21:30:59 <ddarius> There's a library out there that I think writes PDF.
21:31:05 <dons> yeah.
21:31:14 <sorear> Why write PDF?
21:31:16 <dons> though how hard would a postscript + lazybytestring + gzip parser be ? :)
21:31:34 <sorear> Isn't runInteractiveProcess("ps2pdf") good enough?
21:31:40 <wnoise> sorear: yeah, we'll see.  I'm running with Frisby for the moment, but constructing the grammar for that should help immensely in writing a parsec one.
21:31:53 <wnoise> HPDF is write-only.
21:32:12 <dons> ah ok
21:32:20 * sorear thinks people should stop writing libraries and start using existing language-neutral utilities
21:32:24 <dons> ?where+ hpdf http://www.alpheccar.org/en/soft/hpdf
21:32:24 <lambdabot> Done.
21:32:29 <sorear> wherever possible, of course
21:32:57 <RyanT5000> sorear: define "language-neutral"
21:33:14 <sorear> RyanT5000: You don't need to match up calling conventions
21:33:25 <wnoise> PostScript needs a whole interpreter.  It's that whole Turing tarpit thing.  I want to do some programmatic manipulations.  In particular replace insanely high-quality backgroup images with lower quality ones.
21:33:36 <dons> if we ever want to do anything interesting with pdf/postscript, we'll need parsers and pretty printers
21:33:39 <dons> not just external tools
21:34:02 <sorear> Why do those contradict?
21:34:02 <dons> analysis is haskell's strong point, so the more parser+ppr+data structure libs we have for well-known formats,  the better
21:36:08 <SamB_XP_> sorear: do you mean like pnmtofoo and footopnm instead of ImageMagic, etc.?
21:36:12 <wnoise> No PDF library I've found lets me easily just iterate through the object list doing manipulations.  They all insist on breaking it down into pages, if they even do both reading and writing.
21:36:48 <sorear> SamB_XP_: I mean like pnmfoo AND imagemagic instead of libgdkimlib.
21:37:14 <SamB_XP_> sorear: isn't imagemagic a library?
21:37:36 <SamB_XP_> I suppose you may mean the "convert" program?
21:37:38 <sorear> SamB_XP_: Last I checked it was a suite of command line tools, man 1 convert... maybe we're both right?
21:38:06 <hpaste>  chessguy pasted "sorear, do you know which of these would need to be un-pulled?" at http://hpaste.org/2071
21:38:08 <SamB> actually it's spelled ImageMagick
21:38:42 <SamB>        Most of the functionality of ImageMagick can be used interactively from the command line;  more
21:38:42 <SamB>        often,  however, the features are used from programs written in the programming languages Perl,
21:38:42 <SamB>        C, C++, Python, PHP, Ruby, Tcl/Tk or Java
21:39:26 <wnoise> So what is #haskell-blah for?  How is it different than #haskell?
21:39:42 <Binkley> wnoise: it's for discussion of everything except Haskell :-)
21:39:53 <wli> When Igloo uploads the DEFLATE compression code a lot of formats will open up.
21:40:27 <hpaste>  sorear annotated "sorear, do you know which of these would need to be un-pulled?" with "this one" at http://hpaste.org/2071#a1
21:40:28 <SamB> I thought we already had zlib bindings?
21:40:47 <sorear> we already do.
21:41:01 <SamB> so what is wli on about?
21:41:42 <wli> The zlib bindings do something odd. I don't remember what the issue was.
21:42:20 <wli> It can probably actually be fixed (or maybe it already is).
21:42:25 <sorear> they work fine for LB
21:43:15 <dons> hmm?
21:43:20 <dons> we have rather nice zlib bindings, imo
21:43:21 <wli> There was something awkward about dealing with a file that only had pieces compressed.
21:43:51 <wli> It may have been my programming stupidity. I haven't looked in years.
21:45:00 <wli> (I don't even know that the zlib binding now in common use is the same thing as what I dealt with.)
21:45:12 <sorear> yeah, with the new one you can just use drop and take
21:45:19 <sorear> ByteString -> ByteString
21:46:02 <wli> This predated bytestrings by a long time. I should probably just move to the "I have no idea what is going on here" stance.
21:46:44 <chessguy> sorear, that patch you pasted doesn't show up in 'darcs changes'
21:47:03 <sorear> chessguy: Anywhere?  On my ghc it's about 300 lines down
21:47:31 <chessguy> oh, whoops
21:47:50 <chessguy> i forgot, emacs doesn't wrap around the first time a search fails
21:49:27 <chessguy> hm
21:49:48 <chessguy> apparently darcs doesn't ask about every patch when you go through 'darcs unpull'
21:50:00 <chessguy> what does it do with the ones it doesn't ask about? and why?
21:50:35 <SamB_XP_> chessguy: it keeps them
21:50:42 <SamB_XP_> because it would have to unpull others to get to them
21:50:52 <chessguy> sigh
21:50:58 <SamB_XP_> just unpull everything down to that one, and then repull everything else
21:51:10 <sorear> chessguy: it asks you in order from most to least recent.  If you already said YES to a patch that depends on this, this is keps
21:51:23 <sorear> SamB_XP_: even easier, just use the darcs cmdline to select this patch
21:51:34 <SamB_XP_> sorear: hmm.
21:51:40 <chessguy> sorear, how?
21:52:13 <sorear> darcs unpull --patches='Pointer Tagging' should do it, but I haven't used the feature recently
21:52:53 <wli> Pointer tagging gone bad?
21:54:27 <chessguy> SamB, if i do it your way, how would i re-pull the others?
21:54:39 <chessguy> err, SamB_XP_
21:54:58 <SamB_XP_> chessguy: well, you'd just type "darcs pull" and say no to that one, and yes to all that would pull
21:55:05 <sorear> chessguy: darcs pull, which asks you from oldest to newest
21:55:16 <chessguy> ah, right, i forgot that one asks you too
21:55:24 <SamB_XP_> I guess you'd actually type
21:55:25 <sorear> wli: the evil mangler got confused
21:55:25 <SamB_XP_> n
21:55:27 <SamB_XP_> a
21:55:39 <wli> sorear: ?
21:55:42 <sorear> wli: munging gcc-generated assembly with Perl regexes
21:55:57 <SamB_XP_> wli: you hadn't heard of the Evil Mangler?
21:55:57 <wli> sorear: -fasm still okay?
21:56:14 <SamB_XP_> it's surprisingly mallable for such an evil program written in such a crazy language
21:56:18 <sorear> wli: Probably.  I haven't actually tried it, just read the buildbot error logs
21:56:24 <SamB_XP_> (I guess there's a reason it's written in Perl?)
21:56:25 <wli> SamB_XP: I've not heard it called the "Evil Mangler"
21:56:36 <SamB_XP_> wli: what else is it called?
21:56:37 <chessguy> "Finished pulling and applying."
21:56:40 <chessguy> finally!
21:56:54 <chessguy> now i just have to figure out how to build the bloody thing
21:57:22 <sorear> sh boot
21:57:25 <sorear> ./configure
21:57:26 <sorear> make
21:57:29 <sorear> make install
21:57:32 <wli> SamB_XP: I think something without the word "evil" in it.
21:57:45 <Binkley> wli: no, it's always evil
21:57:52 <chessguy> $ sh boot
21:57:52 <chessguy> Booting .
21:57:52 <chessguy> boot: line 18: autoreconf: command not found
21:58:01 <wli> Sure, but it's not always been called that.
21:58:09 <Binkley> chessguy: you need to install autoreconf
21:58:16 <SamB_XP_> wli: hasn't it?
21:58:18 <Binkley> wli: it has been for 6-7 years at least
21:58:21 <sorear> chessguy: you'll need to install autoreconf (often found in the 'automake' package)
21:58:49 <RyanT5000> chessguy: are you making a windows build?
21:58:54 <SamB_XP_> look, even the old commentary calls it that: http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/the-beast/mangler.html
21:58:55 <lambdabot> Title: The GHC Commentary - The Evil Mangler, http://tinyurl.com/39dnz2
21:59:04 <sorear> oh, stupid me
21:59:08 <chessguy> RyanT5000, trying
21:59:10 <SamB_XP_> @go evil mangler
21:59:22 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
21:59:28 <SamB_XP_> hmm, cool
21:59:36 <SamB_XP_> GHC's evil mangler is the top hit ;-)
21:59:37 <wli> Binkley: 6-7 years for "evil" would predate the last time I seriously checked.
21:59:57 <wli> Binkley: Rather, vice-versa.
22:00:00 <SamB_XP_> wli: you are one crazy dude
22:00:08 <glguy> the evil mangler won't be in 6.8, right?
22:00:11 <SamB_XP_> people actually used Haskell 7 years ago?
22:00:21 <Binkley> I used Haskell 7 years ago
22:00:32 <glguy> Haskell *98*
22:00:38 <SamB_XP_> I don't even think I used Linux 7 years ago
22:00:50 <SamB_XP_> glguy: but if people used Haskell back than Haskell 98 would never have happened!
22:00:57 <wli> SamB_XP: The last serious attempts I made to use Haskell were all before 2000, right across the Haskell 1.4 to Haskell '98 transition even.
22:01:02 <SamB_XP_> (oh sad day!)
22:01:11 <SamB_XP_> (sad because it happened!)
22:01:28 <SamB_XP_> wli: you should have started with 1.4
22:01:41 <SamB_XP_> and convinced them not to get rid of all that nifty stuff
22:01:48 <SamB_XP_> er.
22:01:52 <SamB_XP_> I mean stuck with it
22:01:59 <SamB_XP_> I mean I need to go to bed
22:02:22 <wli> SamB_XP: I was not primarily interested in Haskell or any other particular language.
22:02:52 <SamB_XP_> couldn't you have talked the other 10 users out of it?
22:02:54 <wli> SamB_XP: And frankly the H98 transition didn't mean a whole lot to me as I'd barely learned anything.
22:03:10 <SamB_XP_> excuses excuses!
22:03:58 <wli> SamB_XP: 1998-1999 is not that early in Haskell history. The userbase was larger than me and ten others by a longshot.
22:04:03 <chessguy> man, 7 years ago...i don't think i had even heard of C or perl or linux or...
22:04:44 <wli> 7 years ago I had graduated from college and been in my first real job for maybe 4 months.
22:04:52 <SamB_XP_> I'd heard of Linux but not had access to it yet
22:05:00 <SamB_XP_> I'm pretty sure
22:05:22 <SamB_XP_> I knew at least bubble sort in C
22:05:24 <chessguy> i had graduated high school and decided to try the hardware route first :)
22:05:30 <SamB_XP_> probably a bit more
22:05:55 <wli> The Linux installation I'm running on right now dates from 1996.
22:06:23 <dons> yeah, in 1999 600 unsw students were being taught haskell in 1A
22:06:29 <dons> and hugs was rather popular
22:06:40 <wli> Debian's upgrading facilities have carried me.
22:06:42 <dons> i think zvon's guide was the reference of choice
22:06:48 <SamB_XP_> I was like 10 in 1996. and I probably had a 286.
22:06:50 <dons> macgofer was still popular
22:07:19 <wli> I don't remember ghci being around when I first started learning Haskell.
22:07:28 <dons> no, its rather new (2001)
22:07:39 <Binkley> it wasn't around when I was learning either
22:07:41 <dons> to help kill hugs.
22:07:48 <Binkley> someone else, where I was, was working on a project to make GHC and hugs talk to each other...
22:08:11 <wli> dons: It showed up soon after I started, maybe 2-3 years after. I'd stopped actively learning at that point, though.
22:08:17 <wli> Binkley: STGhugs?
22:08:30 <Binkley> wli: probably nothing anyone would have heard of, I don't think it really got finished
22:08:48 <wli> Binkley: STGhugs was not exactly a quiet project.
22:08:52 <chessguy> configure: error: cannot figure out how to do context diffs
22:09:00 * SamB_XP_ learned haskell because he heard about it from someone else -- who apparantly dropped it soon after
22:09:04 <Binkley> wli: that's what I mean -- the project I was referred to wasn't STGhugs
22:09:16 <wli> Binkley: oh
22:09:25 <Binkley> chessguy: are you running under cygwin or mingw?
22:09:43 * SamB_XP_ couldn't believe that a purely functional language could be useful, since he thought it meant something like lambda calculus, where everything is a function ;-)
22:09:58 <wli> SamB_XP: I heard about it from someone who went to work for Microsoft who said it was going to be "the next Visual Basic" (though I don't think he called it that when he first told me of it).
22:10:20 <SamB_XP_> wli: well, he was apparantly close
22:10:28 <SamB_XP_> did you read that Haskell .. Visual Basic paper?
22:10:48 <chessguy_> Binkley, under cygwin
22:10:49 <wli> SamB_XP: No. It probably postdates the last period of active learning.
22:10:52 <chessguy_> @bot
22:10:52 <lambdabot> :)
22:11:02 <Binkley> chessguy: so do you have diff installed?
22:11:08 <chessguy_> no
22:11:12 <SamB_XP_> @google Haskell VB paper
22:11:12 <chessguy_> getting it now
22:11:14 <lambdabot> http://del.icio.us/url/620a8bf2d81de381ba9307fe867711c9
22:11:14 <lambdabot> Title: del.icio.us/url/620a8bf2d81de381ba9307fe867711c9
22:11:18 <Binkley> that would be it, then :-)
22:11:37 <RyanT5000> :( javascript has 29-bit integers
22:11:49 <Binkley> roflcopter
22:12:02 <RyanT5000> or maybe it's 30
22:12:03 <chessguy_> heh. if you need to be working at that level, you shouldn't be using JS anyway
22:12:05 <wli> I love it.
22:12:07 <RyanT5000> i can't actually tell
22:12:17 <wli> "The Sucking Black Hole of XSD"
22:12:26 <wli> "The Dark XML Ages"
22:12:54 <RyanT5000> chessguy_ well i'm not writing in JS - i'm trying to figure out how i'm supposed to make a haskell binding for that type :P
22:12:54 <chessguy> @where happy
22:12:54 <lambdabot> http://www.haskell.org/happy/
22:13:00 <sorear> RyanT5000: Haskell has 30-bit integers too
22:13:10 <RyanT5000> sorear: why? mark bits?
22:13:17 <wli> Dim Customer = New With { .Name = "Bill", .City = "Seattle" }
22:13:18 <sorear> RyanT5000: Yes.
22:13:27 <wli> Someone's got a sense of humor here.
22:13:32 <RyanT5000> sorear: i think spidermonkey has 2 bits of tag and 1 bit of mark
22:13:38 <SamB_XP_> sorear: that 30 bits is a minimum, though
22:13:40 <RyanT5000> sorear: oh wait, no, it doesn't have marks on ints
22:14:23 <wli> SamB_XP: That paper was hilarious!
22:14:41 <SamB_XP_> wli: I heard Bill Gates' favorite langauge is actually Python...
22:14:49 <SamB_XP_> from a MSR canada employee
22:15:02 <wli> SamB_XP: I'd be shocked if he actually programmed.
22:15:24 <SamB_XP_> I'd be shocked if he didn't dabble a bit
22:15:42 <RyanT5000> wli: why? if i was fabulously rich, i'd still spend a considerable amount of my time writing code
22:15:54 <RyanT5000> wli: perhaps more than i would poor
22:16:09 <JBGood25> it is vaguely similar to the basic he started out with...
22:16:29 <SamB_XP_> JBGood25: but oh-so-much better
22:16:40 * chessguy installs happy and tries to configure yet again
22:17:03 <wli> RyanT5000: My impression/understanding is that he is/was the businessman/salesman and Paul Allen was the codemonkey behind early Microsoft, though it's never been said that he never wrote any code.
22:17:36 <chessguy> hmm
22:17:38 <chessguy> checking for happy... /cygdrive/c/Program Files/Haskell/bin/happy
22:17:38 <chessguy> checking for version of happy... ./configure: line 6250: /cygdrive/c/Program: No
22:17:38 <chessguy>  such file or directory
22:17:38 <chessguy> configure: error: Happy version 1.15 or later is required to compile GHC.
22:17:56 <chessguy> it finds happy but apparently can't figure out the version #
22:18:06 <wli> RyanT5000: It could be that he's more into the code/tech side than I'm aware of. Not really an issue of great importance to me either way.
22:18:24 <Binkley> chessguy: try putting it in a directory with no spaces in it
22:18:30 <SamB_XP_> wli: and if he's fabulously rich he can afford to be learning now ;-)
22:18:34 <chessguy> Happy, you mean?
22:18:40 <Binkley> in general cygwin things will cough and die when pathnames with spaces are involved
22:18:42 <Binkley> yes
22:19:18 <chessguy> i've never had trouble installing other packages under cygwin
22:19:31 <Binkley> chessguy: ghc is special ;-)
22:19:43 <chessguy> well i have ghc in c:/ghc
22:19:48 <Binkley> well, when it comes to spaces, a lot of Unixy things will be unhappy
22:20:17 <chessguy> whatever, i give up. i'm too tired to think straight
22:20:18 <sorear> Binkley: Why?  They're legal on Unix too
22:20:27 <Binkley> sorear: doesn't mean that things handle them gracefully
22:20:52 <chessguy> Binkley, it looks to me like it's Happy that's not handling it correctly
22:21:07 <sorear> Binkley: So if I moved my installed Happy into a directory with spaces in the name (on UNIX here), ghc would break?  that's odd
22:21:32 <Binkley> chessguy: well, it looks like configure is checking for the happy version and probably not quoting the string right
22:21:38 <Binkley> you might also want to see http://hackage.haskell.org/trac/ghc/wiki/ProblemsCompilingGhc
22:21:39 <lambdabot> Title: ProblemsCompilingGhc - GHC - Trac
22:21:42 <SamB_XP_> sorear: they are not at all encouraged
22:21:46 <Binkley> that's a list of Windows-specific problems
22:21:57 <SamB_XP_> they are known to have a tendancy to break shell scripts
22:21:58 <Binkley> also, building under Cygwin is, I guess, "unsupported"
22:22:05 <Binkley> I've only done it successfully under MSYS
22:22:33 <RyanT5000> chessguy: also, building under cygwin might yield you a ghc that compiles things to cygwin binaries
22:22:40 <chessguy> beutiful
22:22:57 <RyanT5000> chessguy: or at least a ghc that itself only runs under cygwin
22:23:15 <RyanT5000> chessguy: it might be quicker to install linux
22:23:23 <Binkley> RyanT5000: it's not quite that bad
22:23:31 <RyanT5000> neither is installing linux :P
22:23:32 <RyanT5000> lol
22:23:38 <RyanT5000> honestly, shit like this is why i'm on linux right now
22:23:39 <chessguy> yeah, if i could actually find a distro with packages for my machine
22:23:41 <SamB_XP_> Binkley: that probably depends on how long it takes to install linux ;-)
22:23:51 <Binkley> RyanT5000: well, yeah, me too...
22:24:00 <SamB_XP_> chessguy: huh?
22:24:48 <chessguy> SamB_XP_, i was running linux for a while, but kept having issues with finding packages i needed
22:25:08 <SamB_XP_> chessguy: what distro?
22:25:17 <chessguy> fedora
22:25:25 <SamB_XP_> fedora?
22:25:30 <chessguy> fedora
22:25:40 * SamB_XP_ didn't know anybody still used redhat
22:25:49 * chessguy shrugs
22:26:12 <wli> Ubuntu and Debian seem to be the top dogs outside the enterprise.
22:26:24 <chessguy> ok, time to give in to my pillow
22:26:28 <chessguy> 'night
22:26:48 * SamB_XP_ should go achieve mastery over his own bed
22:27:08 <SamB_XP_> (by which I mean getting the sheet to stay on while I sleep in it ;-)
22:27:23 * wli wonders if he's getting to where he should explore topics other than monads.
22:28:36 <SamB_XP_> wli: monads are boring
22:28:58 <wli> SamB_XP: Well, they were difficult for me, and in some senses, still are.
22:29:28 <SamB_XP_> what senses?
22:29:45 <wli> SamB_XP: I had a hard time understanding them, and still do to some extent.
22:30:16 * SamB_XP_ notes that this iced tea he made tastes like Red Hots without the Hot part, and with a vaguely butterish flavour added
22:30:46 <sjanssen> @remember BulatZ it's great! how fools are invented fortran!
22:30:47 <lambdabot> Done.
22:30:49 <wli> Template Haskell, GADT's, concurrency, and Arrows all sound plausible.
22:30:52 * SamB_XP_ 's never had Bengal Spice tea before
22:31:19 <SamB_XP_> wli: how about writing some programs instead of learning all that junk?
22:31:39 <SamB_XP_> I bet I caught the mtl bug from lambdabot...
22:32:20 <RyanT5000> i mean, linux is slightly more powerful, but the primary reason i'm on linux is that nearly everything i want is either in apt-get or builds easily on linux
22:33:16 <SamB_XP_> and that's certainly why I use Linux for my programming
22:33:17 <Binkley> I'm not saying it's fun to build ghc on Windows, I just think installing Linux would be overkill to build GHC once, if you didn't already want it :-)
22:33:24 <wli> SamB_XP: How do you think I'm supposed to learn anything?
22:33:56 <SamB_XP_> wli: you're that good at coming up with ideas for programs using particular features?
22:34:06 <SamB_XP_> anyway "learning arrows" is a really stupid idea
22:34:15 <SamB_XP_> don't "learn arrows"
22:34:21 <wli> SamB_XP: No, not particularly.
22:34:28 <SamB_XP_> run into them in a library and learn 'em then
22:34:58 <wli> I don't do most of my programming in Haskell.
22:35:17 <SamB_XP_> wli: what do you use?
22:35:30 <wli> SamB_XP: C, as patches to the Linux kernel.
22:35:41 <SamB_XP_> oh.
22:36:10 <wli> Anyway, I occasionally have call to do things in userspace.
22:36:10 <SamB_XP_> well. so don't you have a bunch of ideas for cool things to try in userspace?
22:36:31 <wli> SamB_XP: Sure, but rarely the time or energy to pursue them.
22:36:51 <SamB_XP_> wli: got any ideas for *small* cool things?
22:36:55 <wli> SamB_XP: The idea behind all this Haskell stuff for me is that it's my tool of choice in userspace.
22:37:24 <SamB_XP_> wli: well we don't expect it to be many peoples tool of choice in kernelspace yet ;-)
22:37:29 <wli> SamB_XP: I'm not sure what the criteria are for that.
22:37:45 <SamB_XP_> (not that too many are kernel hackers anyway)
22:38:21 <SamB_XP_> wli: any ... programming languages you'd like to implement?
22:38:54 <wli> SamB_XP: I don't really get the opportunity to go around doing realistic things in userspace, so the only way for me to get the advanced pieces of Haskell to leverage toward the occasional problems I want to solve in userspace is via contrived problems.
22:39:48 <wli> SamB_XP: A small CAS with an extremely limited feature set for EfNet #math newbies is plausible.
22:40:34 <SamB_XP_> I don't think you need TH or concurrency for that...
22:41:04 <wli> SamB_XP: TH is plausible for that. Concurrency is probably unnecessary.
22:41:20 <SamB_XP_> I suppose I shouldn't rule out TH
22:41:42 <wli> SamB_XP: Representing simple mathematical objects can get quite lofty depending on the sorts of algorithms you implement on them.
22:42:02 <timthelion> is there a function to cull a list to every other item?
22:42:45 <sjanssen> hmm
22:43:24 <RyanT5000> i think if i write a language i'm going to compile it into haskell using TH :D
22:43:25 <sjanssen> map snd . filter fst . zip (cycle [True, False])
22:43:29 <wli> SamB_XP: One huge problem in this space is simplifying surds. Like (19 + 15*2^(1/3)+12*2^(2/3))^(1/3). I'm not entirely sure it's solved. The purely quadratic case appears to have subtleties I didn't anticipate.
22:43:33 <RyanT5000> that will save me about a million years
22:43:40 <sjanssen> timthelion: ^^^
22:43:50 <RyanT5000> (at least that'll work for the reference implementation)
22:44:15 <SamB_XP_> wli: well, you did say something about an extremely limited feature space
22:44:32 <sjanssen> > map snd . filter fst . zip (cycle [True, False]) $ ['a'..
22:44:32 <lambdabot>  Parse error
22:44:47 <sjanssen> > map snd . filter fst . zip (cycle [True, False]) $ ['a'..]
22:44:55 <lambdabot>  "acegikmoqsuwy{}\DEL\129\131\133\135\137\139\141\143\145\147\149\151\153\155...
22:44:58 <wli> SamB_XP: Yes. It's probably so dumbed-down it boils down to an expression simplifier.
22:45:33 <SamB_XP_> that's pretty much what all CAS's boil down to
22:45:50 <SamB_XP_> they just have a lot of wierd simplifications ;-P
22:45:51 <timthelion> sjanssen: hmm, I know how to write it.. I just wanted to know if it existed... is that better than doing everyother (x,xs) = head xs : everyother tail xs?
22:45:53 <wli> SamB_XP: I'm talking about expressions involving rational numbers and radicals.
22:46:03 <wli> SamB_XP: No variables even.
22:46:12 <SamB_XP_> ah.
22:46:35 <SamB_XP_> well you have to start somewhere ;-)
22:46:46 <wli> SamB_XP: So the surd thing is really the only nontrivial part.
22:46:57 <sjanssen> timthelion: that definition fails on lists of even length
22:47:01 <sjanssen> timthelion: because you use 'tail'
22:47:33 <timthelion> oh,
22:47:34 <sjanssen> timthelion: everyother (x:_:xs) = x : everyother xs; everyother xs = xs -- is better
22:47:37 <wli> SamB_XP: It also calls for things like Gaussian elimination in algebraic number fields like Q(5^(1/2))
22:47:48 <timthelion> does that work?
22:47:52 <SamB_XP_> I don't actually know what a surd is...
22:48:13 <sjanssen> timthelion: yes, I think so
22:48:16 * SamB_XP_ is an engineering major
22:48:28 * SamB_XP_ needs sleep, badly
22:48:28 <wli> SamB_XP: A radical that may be an n-th root instead of a square root. Like (1 + 2^(1/3))^(1/5)
22:48:39 <SamB_XP_> wli: ah.
22:49:04 <dons> get some sleep SamB_XP_ ! hey -- you're at uni now? end of first session?
22:49:14 <SamB_XP_> dons: not now ;-)
22:49:17 <wli> SamB_XP: BTW (10+15*2^(1/3)+12*2^(2/3))^(1/3) = 1 + 2^(1/3) + 2^(2/3)
22:49:25 <timthelion> sjanssen: I'm using everyother because I'm to lazy to figure out the trig involved with miroring
22:49:32 <SamB_XP_> dons: semester begins in september
22:49:32 <dons> where are you studying, Sam?
22:49:33 <timthelion> of angles
22:49:39 <SamB_XP_> Widener University
22:49:52 <dons> ah ok. our session 2 started last week.
22:49:56 <RyanT5000> SamB_XP_: where's that?
22:50:06 <wnoise> Yet what are all such gaieties to me
22:50:13 <wnoise> Whose thoughts are full of indices and surds
22:50:13 <wli> SamB_XP: Needless to say, LAPACK isn't very useful for solving linear equations over Q(5^(1/2))
22:50:22 <wnoise> x^2 + 7x + 53 = 11/3
22:50:22 <SamB_XP_> RyanT5000: Chester, PA I believe
22:50:53 <SamB_XP_> I don't have to remember what city it's in as as long as I remember what bus to take and where to get off ;-)
22:51:14 <wli> wnoise: -7/2 +/- 1335^(1/2)*i/6
22:51:47 <SamB_XP_> okay, now that sleep
22:51:50 <RyanT5000> SamB_XP_: absolutely :) that's always my approach
22:52:05 <SamB_XP_> dons: what's with telling me to get sleep and then asking a question, anyway?
22:52:10 <SamB_XP_> don't answer that
22:52:22 <SamB_XP_> except possibly by email or private message
22:53:11 <timthelion> sjanssen: shouldn't the seccond patern match be everyother (x,xs) = xs ? otherwise, don't you get two
22:53:34 <wli> I suppose one task might be trying to figure out a minimal polynomial for a radical expression.
22:53:40 <sjanssen> timthelion: we take two, and then throw the second one away
22:54:00 <sjanssen> timthelion: also, the syntax for lists is (x:xs), not (x, xs)
22:55:16 <timthelion> sjanssen: yes, but you gave me two paterns sepparated by a ; and I think that the seccond is wrong
22:55:53 <sjanssen> timthelion: the second one is okay, I think
22:56:00 <wnoise> The second one only kicks in for lists of length one or two.
22:56:08 <wnoise> er, one or zero.
22:56:13 <timthelion> sjanssen: oh, ok, you are corect
22:56:27 * timthelion goes to figure out why he thought otherwise
22:56:59 <sjanssen> I still like the map/filter/zip/cycle one-liner more :)
22:57:17 <timthelion> sjanssen: isn't it less efficient?
22:57:26 <sjanssen> eh, not by much
22:58:03 * timthelion is the son of the lead programer for Microsoft assembler and is thus an efficiency freak.
22:58:38 <RyanT5000> timthelion: you should learn to be a profiling freak; you will never write everything in the most efficient possible way, so you need a way of balancing efficient coding and efficient execution
22:59:53 <RyanT5000> timthelion: i love hand-optimizing assembly myself, but it's really hardly ever appropriate; amdahl's law is the way to go
23:00:05 <timthelion> RyanT5000: but but, my ocd is so, comforting
23:00:48 <RyanT5000> timthelion: i used to have that too, i know :)
23:01:07 * wli thinks about simplifying things modulo surds/etc.
23:01:24 <RyanT5000> timthelion: i'm still fairly OCD about typesafety, don't-repeat-yourself, and interface orthogonality
23:02:14 <RyanT5000> timthelion: but i find that being OCD about those things is much more productive, because imperfections in those areas tend to stack or multiply (or worse) with each other, unlike efficiency ones, where most of your perfectionism goes to waste
23:02:18 <timthelion> I know what you mean about don't-repeat...
23:02:40 <RyanT5000> timthelion: http://en.wikipedia.org/wiki/DRY
23:02:40 <lambdabot> Title: Don't repeat yourself - Wikipedia, the free encyclopedia
23:03:32 <timthelion> I once took a 20 line program and turned it into 60 lines, sepparating out functions for bits of code used more than once.
23:04:45 <RyanT5000> timthelion: well, i've begun to develop a theory of reverse-DRY - things where slapping something in a function is actually less DRY then leaving it
23:05:11 <RyanT5000> timthelion: e.g.: filter (/= 0) should *not* be put in a new function filterNonzero
23:05:33 <RyanT5000> timthelion: except sometimes :P
23:05:57 <timthelion> omg, are you sugesting I make an arbatrary decision on the fly?
23:06:18 <RyanT5000> no, i don't think it's very arbitrary at all
23:06:35 <RyanT5000> you should separate it out into another function, generally, when the name of that function would not just be filterNonzero
23:07:25 <RyanT5000> if it would be called removeProblems, where a "problem" is not necessarily a single element
23:07:36 <RyanT5000> then you should separate it out
23:07:48 <RyanT5000> in case, later, you decided that two 1's in a row is a "problem"
23:08:06 <sorear> Putting filter (/= 0) in a function would *violate* DRY, imo.
23:08:14 <RyanT5000> sorear: that's my point :)
23:08:38 <sorear> Now, if you gave it a semantically meaningful name...
23:08:54 <RyanT5000> sorear: lol i just went over this
23:09:12 <sorear> oh. :)
23:09:45 <RyanT5000> basically, the determination of whether something is DRYer than something else depends heavily on the specification
23:09:53 * wli immediately bangs his head against left recursion.
23:10:37 <RyanT5000> wli: be careful - your head could get sucked in and never returned!
23:10:43 <sorear> egads, rÃ¶jemo's thesis is compress'd (.ps.Z)
23:11:28 <OceanSpray> I'm writing a lisp interpreter
23:11:39 <int-e> @hoogle f (a -> b) -> a -> f b
23:11:40 <lambdabot> Prelude.asTypeOf :: a -> a -> a
23:11:40 <lambdabot> Prelude.const :: a -> b -> a
23:11:40 <lambdabot> Prelude.seq :: a -> b -> b
23:11:40 <sorear> cool!
23:11:41 <OceanSpray> what should I use to represent dotted pairs?
23:11:42 <RyanT5000> OceanSpray: famous last words?
23:11:50 <RyanT5000> :)
23:11:52 <RyanT5000> (just kidding)
23:11:55 <OceanSpray> lulz
23:12:14 <sorear> OceanSpray: Since lisp is dynamically typed with a fixed set of types, you should probably use a single Haskell type for all lisp values.
23:12:31 <sorear> OceanSpray: eg, data Value = Cons Value Value | Symbol String | Num Int
23:12:41 <OceanSpray> yeah, I'm doing that
23:12:44 <sorear> OceanSpray: More if you want to implement a non-mcCarthy lisp ;)
23:12:48 <OceanSpray> but on the low-end
23:13:05 <OceanSpray> hm
23:13:10 <OceanSpray> Cons Value Value
23:13:25 <OceanSpray> I'm a novice, btw
23:13:31 <OceanSpray> didn't know you could do that.
23:13:42 <RyanT5000> btw, i was wrong about both 29-and 30-bit integers in spidermonkey
23:13:42 <RyanT5000> they use 31-bit ones
23:13:42 <RyanT5000> they're essentially huffman-coding their tags
23:13:42 <RyanT5000> (to abuse the term a bit)
23:13:43 <RyanT5000> the LSb is the "isInt" bit
23:13:58 <RyanT5000> bit 1 and 2 are used for all other tags
23:14:13 <int-e> I'd say "prefix code"
23:17:35 <OceanSpray> so...
23:17:55 <OceanSpray> what's the least painful way to get experience with Haskell?
23:18:05 <dons> perhaps implement a small project?
23:18:18 <dons> a scheme interpreter is a traditional entry point
23:18:23 <dons> or you can start with the YAHT tutorial
23:18:28 <dons> ?where yaht-web
23:18:28 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT/Preamble
23:18:34 <dons> ?google scheme in 48 hours
23:18:37 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
23:18:37 <lambdabot> Title: Write Yourself a Scheme in 48 hours
23:18:54 <dons> what kind of software do you usually write, OceanSpray ?
23:19:08 <OceanSpray> None.
23:19:32 <dons> ok. so maybe start with the 5 step intro then :) http://haskell.org/haskellwiki/Haskell_in_5_steps
23:19:33 <lambdabot> Title: Haskell in 5 steps - HaskellWiki
23:19:37 <kfish> OceanSpray!!!
23:19:48 <OceanSpray> I've made an IRC bot, a utility that edits metadata on Theora files,
23:19:57 <dons> oh cool. ah, 16:18  OceanSpray> I've made an IRC bot, a utility that edits metadata on Theora files,
23:20:00 <dons> theora eh?
23:20:02 <dons> so you know kfish? :)
23:20:05 <kfish> OceanSpray, which is still sitting in my patch queue ;-)
23:20:14 <OceanSpray> and a LOT of trivialities
23:20:16 <dons> OceanSpray: there's an IRC bot tutorial
23:20:18 <OceanSpray> yeah, I know kfish
23:20:21 <dons> ?google roll your own irc bot
23:20:23 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
23:20:23 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
23:20:24 <OceanSpray> sup
23:20:33 <kfish> dude
23:20:38 <kfish> haskell is the best language for lolcode
23:20:48 <dons> yeah, native support for lolcode.
23:20:56 <OceanSpray> oh wow
23:23:54 * glguy wonders if he just missed a joke
23:25:04 <dons> http://programming.reddit.com/info/1uviu/comments/c1uvow
23:25:05 <lambdabot> Title: LOLmonad? AWSUM_THX (reddit.com)
23:29:12 <wli> +, -, *, /, and ( ) expressions with integers hmm.
23:29:40 <glguy> there ought to be a LOLCODE interpreter (at least) in LOLCODE
23:30:45 <jfredett> there ought to be a haskell interpeter, in LOLCODE
23:30:51 <jfredett> im in ur haskell!
23:31:22 * wli tries to figure out how to left factor the idiot grammar.
23:31:25 <jfredett> i has categories, awsum_thx!
23:33:15 <wli> ambiguously, E -> int | ( E ) | ( E ) ^ R | E + E | E - E | E * E | E / E; R -> int | ( R ) | R + R | R - R | R * R | R / R;
23:33:48 <dons> someone here should be able to write the canonical lolcode interpreter, imo.
23:34:06 <jfredett> lol
23:34:17 <jfredett> not it!
23:34:21 * jfredett ducks
23:34:44 <wli> rather E -> int | ( E ) | E ^ R | E + E | E - E | E * E | E / E
23:34:53 <RyanT5000> wli: i was about to ask about that :P
23:35:25 <wli> (the idea here being that further uses of ^ within R are disallowed)
23:35:33 <RyanT5000> wli: shouldn't you factor everything other than E^R into a production W
23:36:09 <RyanT5000> wli: i forget, is it bad to have productions take arguments?
23:36:37 <wli> RyanT5000: I think so yes.
23:36:47 <RyanT5000> wli: yeah, probably makes everything a lot more complicated
23:38:16 <RyanT5000> wli: on the other hand, if you're using parsec, it shouldn't be a problem
23:38:38 <wli> parsec pukes on left recursion IIRC
23:38:52 <RyanT5000> wli: probably, unless you enable backtracking
23:39:15 <RyanT5000> wli: do you need to deal with this as a real grammar? it seems like it wouldn't be too hard to hack together a parser by hand
23:40:35 <wli> RyanT5000: There's an option to enable backtracking?
23:40:52 <RyanT5000> wli: yeah, something involving a questionmark i think?
23:40:57 <RyanT5000> wli: i don't know if it's efficient at all
23:41:06 <RyanT5000> wli: and you definitely could write that grammar efficiently
23:41:41 <wli> RyanT5000: I'm just balking at how tedious it is to left factor it by hand.
23:42:09 <RyanT5000> wli: isn't there an algorithm for that?
23:42:44 <wli> I don't know. I'm by no means an expert in using the libs.
23:43:05 <RyanT5000> wli: no i mean an algorithm for hand-left-factoring a grammar
23:44:17 <wli> RyanT5000: I've avoided LL -based parsing like the plague for the most part, so I actually know very little of it other than that it exists.
23:44:47 <wli> LL/recursive descent sucks.
23:45:03 <RyanT5000> hm
23:48:34 <wli> If you can't hack tables together then for Pete's sake chart parse.
23:52:10 <int-e> Parsec lacks introspection. A production can depend on previously parsed tokens.
23:52:52 * wli nukes the Parsec imports and bangs out parsing by hand.
23:52:56 <timthelion> is there a function to take a list like 1 2 3 4 5 and bring the 4th element to the front so it's like 4 1 2 3 5?
23:53:46 <glguy> no, but you can make one easily enough with splitAt, case, and ++
23:54:16 <timthelion> hmm, there should be a huge list of these functions I think...
23:54:36 <glguy> a list of which functions?
23:54:40 <glguy> ?docs Data.List
23:54:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
23:54:43 <glguy> those?
23:54:46 <int-e> timthelion: not really, when you're doing stuff like this excessively you shouldn't be using lists.
23:55:04 <timthelion> int-e: really? what ought I be using?
23:55:33 <RyanT5000> timthelion: sounds maybe like a heap?
23:55:47 <RyanT5000> timthelion: or a priority queue, or something
23:55:55 <RyanT5000> timthelion: depends on what you're doing overall
23:55:59 <timthelion> hmm, xmonad uses lists
23:56:17 <RyanT5000> timthelion: i thought it used some kind of zipper?
23:56:53 <timthelion> well it uses a list like up fucus down
23:57:01 <timthelion> hmm, maybe...
23:57:23 <dons> xmonad uses a cursor into a list
23:57:26 <dons> so its not quite the same
23:57:39 <dons> you get O(1) access to the indexed element, and its neighbours
23:58:45 <timthelion> dons: after I have called zip, can I reorder the windows by doing ups zip ws rects and dns zip ws rects?
23:59:02 <int-e> oh Data.Sequence also doesn't have an operation to delete an element at a specified position; I wonder why.
23:59:14 <timthelion> or do I have to do splitAt (length ups ws) zip ws rects
23:59:32 * wli thinks about parsing.
