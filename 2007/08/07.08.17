00:30:29 <glguy> any basic coq users?
00:30:57 <glguy> i just read the blog post on proving list is a monad
00:31:13 <glguy> now I'd like to try my hand at state
00:31:39 <glguy> i think i got the definitions right, but i get an error about metavariables in my proof
00:31:46 <glguy> of the first law
00:32:07 <bluestorm> i'd be intersted in seeing your work
00:32:19 <bluestorm> (i just read the coq tutorial 2 days ago)
00:32:24 <mae> hi guys
00:32:43 <hpaste>  glguy pasted "state dfn" at http://hpaste.org/2295
00:32:48 <Pseudonym> BTW...
00:32:59 <bluestorm> hm
00:33:05 <Pseudonym> It's a little known fact, but actually there are only two things you need to prove if you want to prove that something is a monad.
00:33:07 <mae> whats the coolest way to do this in haskell? (ruby code) : def (x); [1,2,3,4,5].include?(x); end
00:33:17 <mae> is there some neat pattern matching syntax in haskell for something like this?
00:33:21 <mae> i know i can do it piecewise
00:33:23 <glguy> @type elem
00:33:23 <mae> like
00:33:24 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
00:33:30 <bluestorm> could you paste your last  goal + tried tactic + error ?
00:33:34 <Pseudonym> The three monad laws are more "natural", but IIRC, one is redundant.
00:33:39 <mae> foo 1 = True
00:33:44 <glguy> (`elem` [1..5])
00:33:53 <mae> ahh
00:33:57 <Pseudonym> Oh, actually.
00:34:00 <mae> so i can use an implicit argument?
00:34:06 <Pseudonym> No, I'm wrong, you do need to prove three things.
00:34:14 <Pseudonym> Proving that fmap is a functor is actually two laws.
00:34:23 <Pseudonym> fmap id = id, and fmap (f.g) = fmap f . fmap g
00:34:36 <glguy> bluestorm: i didn't get past "intros." I tried rewrite ret.
00:34:51 <Pseudonym> Then the only other law you need to prove is the associative law.
00:35:22 <glguy> mae: `elem` is the infix version of elem
00:35:42 <glguy> ( `elem` xs ) is a section
00:35:55 <glguy> and means \ x -> elem x xs
00:36:24 <Korollary> ?type flip elem
00:36:26 <lambdabot> forall a. (Eq a) => [a] -> a -> Bool
00:36:46 <Pseudonym> Actually, there's a good exercise for Coq.
00:36:53 <Pseudonym> Prove that those are the only laws you need.
00:37:21 <Korollary> There's a CT module for Coq iirc
00:37:53 <hpaste>  bluestorm annotated "state dfn" with "another bind version" at http://hpaste.org/2295#a1
00:43:29 <bluestorm> hm glguy
00:43:41 <bluestorm> i tried the proof
00:43:53 <bluestorm> and i'm blocked at prooving     (fun s0 : S => f a s0) = f a  :p
00:44:16 <glguy> what steps did you take?
00:44:31 <bluestorm> intros.
00:44:31 <bluestorm> unfold ret in |- *.
00:44:31 <bluestorm> unfold bind in |- *.
00:45:52 <bluestorm> (i actually didn't typed the "in |-*" part, Show Script added them)
00:45:59 <glguy> right
00:46:16 <bluestorm> hm
00:46:52 <bluestorm> looks like eta-conversion is not trivial in coq
00:50:14 <bluestorm> hm
00:50:36 <bluestorm> glguy: i fear this actual form of the law isn't provable
00:50:48 <bluestorm> you may have to eta-expand both parts manually
00:51:18 <bluestorm> because i'm not sure the "=" relation consider two equivalent functions equal
00:51:53 <bluestorm> (actually i think it does not, but as I start coq 2 days ago, i'm likely to say wrong things)
00:51:56 <glguy> well... looks like I picked a 2nd use of coq that was too big a step
00:52:45 <bluestorm> hm
00:55:28 <hpaste>  bluestorm annotated "state dfn" with "first law hack" at http://hpaste.org/2295#a2
00:55:42 <bluestorm> glguy: http://hpaste.org/2295#a2 is the expanded solution
00:58:01 <glguy> bluestorm: I reduced the proof to:
00:58:03 <glguy> trivial.
00:58:10 <bluestorm> :]
00:58:31 <bluestorm> that's unfair ! :D
01:00:29 <opqdonut> :]
01:04:22 <glguy> (let (a1, s1) := m s in (a1, s1)) = m s
01:05:02 <bluestorm> that's the Printed Proof ?
01:05:40 <glguy> no
01:05:50 <glguy> that's where i lost on 2nd law
01:08:08 <bluestorm> hm
01:08:31 <bluestorm> what's the second law coq form ?
01:08:59 <bluestorm> hm
01:32:15 <tuxplorer> I would like to learn the XSLT based approach to do HAppS programming. But the HAppS tutorial in the wiki gives examples only about the HTML printing method.. Pls suggest some other good tutorial to do it the XSLT way..
01:38:06 <hpaste>  bluestorm annotated "state dfn" with "expanded second law" at http://hpaste.org/2295#a3
01:38:20 <bluestorm> glguy : it's ugly, but it works :-°
01:38:55 <glguy> bluestorm: using your "hack" I got through all three laws
01:39:06 <bluestorm> hm
01:39:32 <bluestorm> you've done the second one without this ugly "m s = (a1, s1) -> ..." ?
01:39:52 <glguy> I did the second one with: destruct (m s).
01:40:06 <bluestorm> hmm
01:41:39 <bluestorm> didn't know about destruct ^^
01:41:46 <bluestorm> that works
01:42:27 <hpaste>  glguy annotated "state dfn" with "my final session" at http://hpaste.org/2295#a4
01:45:25 <bluestorm> hm
01:45:50 <bluestorm> is there a way to lighten the type annotations by using "Variables S A B" somewhere ?
01:46:02 <glguy> did you seem mine?
01:47:18 <glguy> do you mean you want to avoid the foralls?
01:47:44 <bluestorm> yes, part of
01:47:56 <glguy> Extraction Language Haskell.
01:47:56 <glguy> Recursive Extraction bind ret.
01:48:00 <glguy> that part is fun :)
01:56:31 <xpika> how do you compile a win32 c program from ghc, i get the error: libHSrts.a(Main.o):Main.c:(.text+0x1b): undefined reference to `ZCMain_main_closure`
02:01:01 <hpaste>  roconnor annotated "state dfn" with "glguy: StateMonad with implit arguments, notations, and section variables" at http://hpaste.org/2295#a5
02:09:23 <mae> w00
02:18:19 <Figs> hey
02:18:23 <Figs> http://rafb.net/p/adxZp369.html
02:18:24 <lambdabot> Title: Nopaste - I think it actually works...!
02:20:37 <Figs> Could someone who's a bit more familiar with the language point out to me anything illogical I'm doing? It seems to actually work, but that doesn't mean it is *really* correct... ^_^
02:21:28 * ari looks
02:22:36 <Figs> I just realized I never actually used "continue"
02:23:15 <roconnor> Figs: I don't know what it is doing, but it looks pretty good.
02:23:27 <ari> Figs: peel == drop
02:23:32 <Figs> I'm trying to pull out a range in a list
02:23:38 <Figs> peel == drop == ???
02:23:46 <shachaf> Figs: You don't need to have "f x = case x of a -> ...; b -> ...".
02:23:55 <shachaf> Figs: You can just use "f a = ...; f b = ...".
02:25:11 <Figs> I know, but I'm also very new to this... so it all still seems like nails, and here I am with a hammer... :P
02:25:23 <Figs> too bad for me that was really a screw.
02:25:31 <ari> @check \n xs -> let peel :: Int -> [Int] -> [Int]; peel 0 l = l; i l = peel (i - 1) (tail l); in peel n xs == drop n xs
02:25:35 <lambdabot>  Couldn't match expected type `Int' against inferred type `t1 -> t'
02:25:50 <ari> @check \n xs -> let peel :: Int -> [Int] -> [Int]; peel 0 l = l; peel i l = peel (i - 1) (tail l); in peel n xs == drop n xs
02:25:52 <lambdabot>  Exception: Prelude.tail: empty list
02:26:04 <ari> Ah, yes, it's not *quite* drop, I see
02:26:28 <Figs> basically I was using it to pull off 'index' numbers
02:26:36 <Figs> so peel 1 list
02:26:42 <Figs> would pull off the first item...
02:26:46 <ari> > drop 1 [1..10]
02:26:48 <lambdabot>  [2,3,4,5,6,7,8,9,10]
02:27:20 <Figs> > drop 0 [1..10]
02:27:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
02:27:22 <Figs> ok
02:27:32 <Figs> I can just use that instead ;)
02:27:35 <shachaf> > drop 5 [1,2,3,4,5,6]
02:27:36 <lambdabot>  [6]
02:27:38 <shachaf> > drop 5 [1,2,3,4]
02:27:39 <lambdabot>  []
02:27:44 <doserj> func x y == take y . drop x $ my_seq ?
02:27:52 <Figs> ?
02:28:13 <Figs> what is 'take y'?
02:28:22 <xerox> ?docs
02:28:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
02:28:24 <ari> > take 5 [1..10]
02:28:26 <xerox> Click on Prelude :-)
02:28:26 <lambdabot>  [1,2,3,4,5]
02:29:02 <Figs> what's the period for?
02:29:19 <ari> Figs: It just creates the list of values between 1 and 10
02:29:22 <ari> > [1..10]
02:29:24 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
02:29:26 <Figs> no
02:29:31 <enolan> @src (.)
02:29:31 <lambdabot> (.) f g x = f (g x)
02:29:32 <Figs> I meant in doserj's example
02:29:36 <enolan> that period?
02:29:51 <Figs> ok
02:29:52 <doserj> I don't like parantheses :)
02:30:01 <Figs> :p
02:30:11 <doserj> take y (drop x my_seq)
02:31:07 <shachaf> Figs: (.) is function composition, and it's used a lot in Haskell.
02:31:21 <Figs> ok ;)
02:31:25 <shachaf> Figs: (f . g) x = f (g x)
02:31:29 <Figs> I think I get that doserj
02:31:37 <ari> Also, my_seq is more concisely defined as my_seq = 0 : -1 : zipWith (-) my_seq (tail my_seq)
02:32:06 <shachaf> > ((`div` 2) . (+4) . (*2)) 5
02:32:08 <lambdabot>  7
02:32:19 <Figs> I'm still looking through the "Haskell for C programmers" tutorial... so I haven't really seen many functions yet
02:32:35 <Figs> but thanks ari
02:34:35 <doserj> func x y = map (my_seq!!) [x..y] -- just for confusion :)
02:36:07 <Figs> > map([1..10]!!)[2..12]
02:36:08 <lambdabot>  Exception: Prelude.(!!): index too large
02:36:13 <Figs> :P
02:36:26 * Figs will look it up later
02:36:55 <wli> > map (([1..10]!!) . (`mod` 10)) [2..12]
02:36:56 <lambdabot>  [3,4,5,6,7,8,9,10,1,2,3]
02:39:02 <Figs> > [1..10]!!6
02:39:03 <lambdabot>  7
02:39:15 <Figs> >[0..9]!!6
02:39:24 <Figs> > [0..9]!!6
02:39:26 <lambdabot>  6
02:39:31 <Figs> ah
02:39:41 <wli> 0-based
02:39:47 <Figs> `course ;)
02:39:51 <Itkovian> Figs: indexing works in the nice fashion, ie. 0-based
02:40:04 <Figs> I was saying 'ah' to the !!
02:40:24 <Figs> "!!" naturally makes me think of factorials, not of indexes
02:40:49 <Figs> indexes? indexing?
02:40:54 <Figs> not sure on the right word
02:40:55 <wli> Well, this is for (i = 0, p = head; i < n; ++i) { p = p->next; }
02:41:21 <Figs> what?
02:41:26 <Figs> O.o
02:41:29 <wli> Figs: Lists aren't arrays.
02:41:58 <wli> It's a bit more than that.
02:42:22 <Figs> Yeah, I get that, or at least I think I do.
02:42:25 <wli> Maybe more like for (i = 0, p = head(); i < n; ++i) { p = p->next(); }
02:42:28 <Itkovian> so !! is not all that efficient
02:42:33 <Figs> I have no idea what you're trying to express with that though
02:42:46 <Itkovian> Figs: the C-code for !!
02:42:55 <wli> Figs: C code for list traversal.
02:42:55 <Figs> head() is what?
02:42:59 <Figs> in this context?
02:43:01 <Itkovian> well, (!! n) actually
02:43:07 <Itkovian> the first item on the list
02:43:16 <wli> Figs: A function computing the initial item of the list.
02:43:46 <Figs> yeah, I realized that, but you had me confused at first by presenting it as a first looking like a variable, and then second as a function
02:44:03 <wli> p->next() may, for instance, revolve between several different functions.
02:44:06 <Figs> I think I get what you mean now
02:44:16 <Figs> but without giving me the types, that's a bit confusing :P
02:44:37 <wli> Well, the types can vary depending on strict vs. lazy.
02:44:45 <Figs> I'm talking about C
02:44:47 <wli> Strict would be the first, lazy the second.
02:44:56 <wli> So am I.
02:45:16 <Figs> what are we talking about then?
02:45:34 <wli> Figs: In the first case the list is pre-assembled.
02:45:52 <wli> Figs: In the second case ->next() malloc()'s the next element and initializes it.
02:46:16 <Figs> p->next() doesn't make sense to me.
02:46:18 <wli> Figs: Including the next element's ->next() function pointer.
02:46:20 <Figs> in a C context
02:46:49 <wli> Figs: struct elem { int val; struct elem *next(void) };
02:47:39 <Figs> since when can C structs have methods?
02:47:55 <Figs> :P
02:48:04 <Figs> that's where you confused me since you said it was supposed to be C
02:48:19 <wli> struct elem *next_even(void) { struct elem *ret = malloc(sizeof(struct elem); ret->val = rand(); ret->next = next_even; }
02:48:37 <Figs> let's just use C++, OO is nicer for explaining that anyway :)
02:48:40 <wli> Figs: struct elem { int val; struct elem *(*next)(void) };
02:48:59 <wli> Figs: I never touch C++.
02:49:07 <Figs> fine then ;)
02:49:07 <wli> Never will, either.
02:49:18 <wli> It's not OO and never will be.
02:50:12 <wli> gah, ret->next = next_odd; }
02:50:49 <wli> Do something different for ->val in next_odd() and set ->next to next_even()
02:51:21 <wli> As you can see, it's tedious and error-prone to write out by hand.
02:55:14 <wli> Actually the biggest inconvenience is C's syntax for function types but anyway.
02:57:18 <wli> I'm by no means tainted with C++ use/etc.
02:57:56 <Figs> "tainted"
02:57:58 <Figs> thanks...
02:58:00 <Figs> :P
02:59:05 * Figs 's primary language is C++
02:59:16 <wli> Figs: I'm a kernel type. All C here.
02:59:23 <Figs> hehe
02:59:59 <Figs> you actually *can* write an OS in C++ if you really want to... supposedly.
03:00:19 <olsner> nachos (a teaching OS) was previously built in C++, but newer versions have been ported to Java
03:00:21 <wli> I've seen it done. It's vaguely newfangled.
03:00:34 <Figs> :P
03:00:40 <Figs> anyway...
03:01:19 <wli> olsner: Java doesn't make sense; a fair amount of kernel programming is learning to get around on the bare metal.
03:01:56 <dionoea> isn't BeOS C++ ?
03:02:01 <wli> You can do it if you've got a JVM ported to the bare metal, but its teaching value is questionable.
03:02:19 <wli> dionoea: So I've heard. I've mostly seen k42.
03:02:23 <olsner> wli: I know, but still they've done it... the operating system kernel includes a MIPS simulator for running the user mode programs
03:03:56 <olsner> so it really doesn't have bare-metal code anywhere (although the C++ code did include a stack switcher to switch between kernel threads - don't know how they did that in Java)
03:04:47 <Figs> magic.
03:04:48 <Figs> :D
03:05:42 <Figs> @def head
03:05:42 <lambdabot> Maybe you meant: bf let
03:05:46 <Figs> O_o
03:05:50 <bluestorm> bf ? :-°
03:06:01 <wli> The trick with advanced languages for kernels is that you start getting a lot of overlap between the language's runtime system and the kernel. I've not got any particular experience with advanced languages in the kernel environment but there are good reasons it's not done often (yet, I suppose).
03:06:01 <xerox> ?src head
03:06:01 <lambdabot> head (x:_) = x
03:06:02 <lambdabot> head []    = undefined
03:06:16 <Figs> it was src
03:06:17 <Figs> ah yeah
03:06:19 <Figs> thanks :)
03:06:32 <olsner> Figs: some combination of magic and not knowing what a bad idea looks like ;-)
03:06:39 <Figs> :P
03:07:06 <Figs> I like inventing backwards solutions...
03:07:17 <Figs> sometimes
03:07:18 <Figs> :)
03:07:58 <MyCatVerbs> Figs: Q: how do you tell a bored Haskeller? A: they're the one making up incrementally more byzantine ways of expressing "id"
03:07:59 <Figs> I'm writing a table class that can be resized at runtime and changed to hold different types of data in different columns in C++ for example...
03:08:08 <Figs> id?
03:08:17 <wli> id x = x
03:08:21 <Figs> hehe :P
03:08:32 <Figs> what is the point of it?
03:08:38 <MyCatVerbs> read . show
03:09:00 <xerox> > fmap fix return 1
03:09:02 <lambdabot>  1
03:09:07 <wli> Figs: There are function arguments to a lot of functions to handle general cases that in specific instances you sometimes want to pass id to.
03:09:15 <MyCatVerbs> > let iddd = (head . read . (\x->'[' : x ++ "]") . show) in iddd 1
03:09:16 <lambdabot>  1
03:09:29 <olsner> > (head . (:[])) 42
03:09:31 <lambdabot>  42
03:09:41 <Figs> what is the correct type annotation for
03:09:42 <Figs> pull_range shift count list = take count (drop shift list)
03:09:46 <Figs> ?
03:09:55 <Figs> for the list
03:10:01 <olsner> @type \shift count list -> take count (drop shift list)
03:10:03 <lambdabot> forall a. Int -> Int -> [a] -> [a]
03:10:14 <MyCatVerbs> Figs: type it in, let the type inferrer work it out for you :)
03:10:20 <wli> Figs: e.g. map (head &&& id) . group . sort
03:10:22 <xerox> Figs: if you use Emacs, after you've loaded a module containing that definition with C-c C-l you can request its type to be inserted in the module with C-u C-c C-t.
03:12:06 <olsner> pullRange = flip ((.) . take) . drop
03:16:10 <Figs> haskell's syntax is like math
03:16:41 <Figs> it's fairly compact, and once you get it, it makes sense usually
03:16:47 <Figs> but when you don't get it...
03:16:51 <Figs> :S
03:17:30 <olsner> you've been #haskell'ed ;-)
03:17:39 <Figs> me?
03:18:24 <olsner> #haskell is the best source for hard-to-read haskell, I guess
03:18:51 <Figs> ... :P
03:19:41 <Figs> at once I really like Haskell's type system, and at the same time, I really don't like it because there's a lot going on that I just don't get yet
03:20:32 <Philippa> Figs: read Typing Haskell in Haskell for a starting point?
03:20:37 <koala_man> can you write a function  regexmatch pattern match :: String -> String -> Bool  which compiles a regex and matches it,  let f = regexmatch "fo+" and then call f repetedly without it recompiling the regex?
03:20:54 <wli> YAHT would probably be more appropriate.
03:22:54 <Figs> considering how much I've forgotten of the little I did learn of haskell a month or so ago, it makes me wonder how much calculus I'll remember next month when school starts up again
03:23:07 <TSC> koala_man: I don't think that you could guarantee a single compilation
03:23:35 <Figs> if you only need a pattern compiled once, then you can bulid the structure of the regex with a monad
03:23:39 <Figs> don't ask me how though
03:23:44 <Figs> but I know it's possible
03:23:53 <Figs> came up the last time I was here, IIRC
03:24:06 <wli> Make a CAF with the thing partially applied to the pattern.
03:24:10 <Philippa> wli: depends what value of "understand" you're after
03:24:11 <koala_man> TSC: what would be the proper way of doing it, guarantee or not?
03:24:22 <doserj> koala_man, let f = mkRegex "fo+" in map (matchRegex f) ... will call mkRegex only once. but that is not what you want, i guess
03:25:34 <TSC> koala_man: wli's idea of using a CAF is probably the best
03:25:51 <koala_man> a whatnow?
03:26:22 <wli> Constant Applicative Form
03:26:43 <TSC> Have a top-level function: f = regexmatch "fo+"
03:27:47 <Figs> well, it's half past 3 am here, so I'm gonna hit the hay
03:27:54 <koala_man> will that be different from let f = .. and then using f a bunch of times in the let?
03:27:55 <Figs> cya all and thanks for the help
03:28:01 <wli> I just woke up (same $TZ).
03:28:16 <Figs> $TZ>
03:28:18 <Figs> *?
03:28:27 <desegnis> Little question about strictness. Hudak says in his book that a function f is strict if f ⊥ = ⊥. Does this mean that f1 and f2 are strict, defined as f1 = undefined and f2 _ = undefined?
03:28:47 <LeCamarade> ?time Figs
03:28:47 <lambdabot> Local time for Figs is Fri Aug 17 03:28:09 2007
03:28:58 <LeCamarade> ?time wli
03:28:58 <lambdabot> Local time for wli is Fri Aug 17 03:28:19 2007
03:29:03 <wli> koala_man: Slightly. The likelihood of it being translated to evaluate-only-once is higher when it's top-level.
03:29:04 <LeCamarade> :o)
03:29:08 <Figs> ah, gotcha
03:29:21 <koala_man> I'm starting to feel like this lazyness is something you have to keep working around
03:29:31 <Figs> for whatever reason $TZ made me think "Tazmania"... :S
03:29:37 <Figs> proof I need sleep, I guess.
03:29:46 <Figs> see ya all...
03:30:36 <wli> koala_man: Well, it's double-edged like any design decision. Part of the trick of getting good at all this is leveraging it instead of having to fight it.
03:30:44 <TSC> desegnis: He's talking about strictness in the arguments
03:31:03 <TSC> So if the argument is bottom, then the result is bottom
03:31:18 <TSC> If there's no argument, discussing strictness doesn't make much sense
03:31:39 <desegnis> TSC, you refer to my f1, I suppose?
03:31:41 <koala_man> wli: but basically, if you use a let or define a function, it's up to the compiler to do it right?
03:31:42 <TSC> Yeah
03:32:09 <desegnis> TSC, let's assume f1 :: a -> a; f1 = undefined
03:32:24 <TSC> Sure, like f2
03:32:27 <TSC> I wouldn't say that f2 is strict, because it doesn't look at its argument
03:32:44 <desegnis> TSC, this is exactly what made me wonder
03:32:46 <TSC> But I guess, "strictly" speaking, it could be considered strict
03:33:02 <desegnis> :)
03:33:53 <desegnis> hm, so considering f3 (x:xs) ys = ...; then f3 ⊥ is strict in its argument?
03:34:24 <desegnis> wait
03:34:34 <TSC> f3 is strict
03:34:41 <TSC> f3 ⊥ = ⊥
03:34:55 <TSC> So f3 ⊥ = f2 above, I think
03:34:58 <wli> koala_man: For the most part. But for the most part they get it right.
03:35:05 <desegnis> I meant f3 [], not f3 ⊥
03:35:11 <desegnis> sry
03:36:04 <desegnis> but I think I understand now
03:37:05 <TSC> Whether f3 [] is strict depends on the "..."
03:37:51 <wli> I think there's a term like "vacuously strict" for this.
03:38:50 <desegnis> TSC, oh, then I do not understand pattern matching correctly.
03:39:58 <desegnis> TSC, I supposed that a failing pattern match always means failure
03:40:41 <doserj> desegnis, f3 is strict in its first argument (because you pattern match)
03:40:58 <doserj> but whether f3 [] is strict is a completely different question
03:42:18 <desegnis> wli, I might like »vacuously strict«. Does it mean that a function is strict, but you will get ⊥ anyway, so the strictness does not matter really?
03:42:50 <desegnis> doserj, I asked that question anyway ;)
03:43:12 <xpika> @where flags
03:43:12 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
03:44:07 <xerox> > let f3 (x:xs) ys = ys in f3 undefined "pattern matching is strict by default"
03:44:09 <lambdabot>  Undefined
03:44:50 <xerox> > let f4 ~(x:xs) ys = ys in f4 undefined "but can be relaxed"
03:44:51 <lambdabot>  "but can be relaxed"
03:45:35 <Lamperi> a
03:45:46 <desegnis> xerox, ah, so this how lazy patterns work. thanks
03:53:25 <EvilTerran> > let f3 (x:xs) ys = ys in f3 [] "pattern matching is strict by default" -- also worth noticing
03:53:34 <lambdabot>   Non-exhaustive patterns in function f3
04:24:26 <DRMacIver> The default strictness of pattern matching seems like an odd decision.
04:24:35 <DRMacIver> What's the reasoning for it?
04:26:02 <psykotic> well, you generally have multiple clauses and need to make a choice between several them.
04:26:15 <psykotic> *several of them
04:26:38 <desegnis> DRMacIver, pattern matching is used not only for assinging names to values, but also for discriminating cases
04:27:14 <DRMacIver> Mm. I don't see offhand why that has to be strict though. Maybe I'm misunderstanding the issues involved.
04:27:27 <EvilTerran> > let f (x:xs) = x; f [] = 1 in f [2,3,4]
04:27:29 <lambdabot>  2
04:27:32 <EvilTerran> > let f ~(x:xs) = x; f [] = 1 in f [2,3,4]
04:27:33 <lambdabot>      Warning: Pattern match(es) are overlapped
04:27:33 <lambdabot>              In the definition...
04:27:41 <EvilTerran> whups, that doesn't help...
04:27:46 <EvilTerran> > let f ~(x:xs) = x; f [] = 1 in f []
04:27:46 <lambdabot>      Warning: Pattern match(es) are overlapped
04:27:46 <lambdabot>              In the definition...
04:27:52 <psykotic> no, it's right in warning you.
04:27:55 <EvilTerran> ... **stabs lambdabot**
04:27:57 <psykotic> because it can't use a lazy pattern to discriminate
04:28:03 <EvilTerran> psykotic, i know. i'm trying to give an example, though.
04:28:23 <EvilTerran> let f (x:xs) = x; f [] = 1 in f []  -- 1
04:28:35 <EvilTerran> let f ~(x:xs) = x; f [] = 1 in f []  -- explodey
04:28:59 <wli> What exactly are lazy pattern matches?
04:29:14 <psykotic> it just means it doesn't actually deconstruct and assign bindings only you try to use any of the bindings
04:29:28 <psykotic> so for example..
04:29:36 <psykotic> > let f ~(x:xs) = 3 in f []
04:29:37 <lambdabot>  3
04:29:40 <EvilTerran> if all patterns were irrefutable, the first one would always match, and you couldn't use the idiom f FOO = ..., f BAR = ..., etc
04:29:42 <psykotic> > let f (x:xs) = 3 in f []
04:29:43 <lambdabot>   Non-exhaustive patterns in function f
04:30:07 <psykotic> > let f ~(x:xs) = x in f []
04:30:08 <lambdabot>   Irrefutable pattern failed for pattern (x : xs)
04:30:13 <EvilTerran> (irrefutable = lazy, in the context of patterns)
04:30:19 <vincenz> > let psykotic = psykotic
04:30:19 <lambdabot>  Parse error
04:30:36 <psykotic> vincenz, aren't you on your way yet to columbia yet?
04:30:42 <vincenz> I am
04:30:44 <vincenz> I'm in .be
04:30:47 <vincenz> flying tomorrow morning
04:30:48 <desegnis> wli, as I understand it, a lazy pattern match always succeeds (that is, ~(x:xs) matches anything), but the right-hand side may then blow up if you use a variable that can not be assigned to anything
04:30:51 <psykotic> lucky bastard.
04:30:57 <wli> So if you've got a function operating on infinite lists you can avoid warnings for the missing [] case with it.
04:31:06 <psykotic> i'm going on a weekend trip to the east coast of korea this saturday, but they just announced it's going to rain like crazy.
04:31:11 <vincenz> :|
04:31:12 <EvilTerran> desegnis, exactly
04:31:31 <desegnis> fine
04:31:37 <vincenz> > let f ~(x:xs) = 3 in f []
04:31:38 <lambdabot>  3
04:32:06 <vincenz> > let {f ~(x:xs) = 3; f ~([]) = 4 } in f []
04:32:06 <EvilTerran> "f PAT = EXP" is like "f x = case x of PAT -> EXP"; "f ~PAT = EXP" is like "f x = let PAT = x in EXP"
04:32:07 <lambdabot>      Warning: Pattern match(es) are overlapped
04:32:07 <lambdabot>              In the definition...
04:32:13 <vincenz> aha
04:32:22 <vincenz> pattern matches are fuzzier in ~ mode
04:32:24 <vincenz> [] == x:xs
04:32:43 <vincenz> I wonder if lazy patterns work for subpatterns
04:32:44 <psykotic> right, they are the same as a variable in their discriminating ability
04:32:50 <EvilTerran> they're completely fuzzy. a ~() matches _anything_ (of the right type)
04:32:54 <vincenz> > let f (x:~(y:ys)) = x in  [2]
04:32:55 <lambdabot>   Not in scope: data constructor `:~'
04:33:01 <vincenz> > let f (x:(~(y:ys))) = x in  [2]
04:33:02 <lambdabot>  [2]
04:33:13 <vincenz> o.O
04:33:30 <vincenz> > let f (x:(~(y:ys))) = x in f [2]
04:33:31 * vincenz coughs
04:33:31 <lambdabot>  2
04:33:39 <psykotic> hehe
04:33:42 <vincenz> > let f (x:(~(y:ys))) = (x,y) in f [2]
04:33:43 <lambdabot>   Irrefutable pattern failed for pattern (y : ys)
04:33:52 <vincenz> aha, they work perfectly fine for sub-patterns as wel
04:33:56 <EvilTerran> and they do indeed work for subpatterns, etc. iirc there's a "strict match" thing for use in subexpressions of a ~(), too, although its name escapes me
04:33:57 <psykotic> yeah, i guess it's the same as:
04:33:59 <vincenz> never really used lazy patterns
04:34:18 <psykotic> let f (x:xs) = x where ~(y:ys) = xs in f [2]
04:34:20 <psykotic> > let f (x:xs) = x where ~(y:ys) = xs in f [2]
04:34:21 <lambdabot>  2
04:34:28 <dionoea> ouh, ~ sounds nice. It only fails if you're tring to use something that it couldn't match succesfuly?
04:34:31 <EvilTerran> f (x:xs) = let y:ys = xs in (x,y)
04:34:44 <vincenz> anywho
04:34:45 <psykotic> dionoea, yes, it just puts off the deconstruction as long as possible.
04:34:52 <vincenz> time to shower and go say hello to people @ office
04:34:53 <EvilTerran> (let{}s are irrefutable by default)
04:34:59 <psykotic> vincenz, later. have a great trip.
04:35:02 <vincenz> thanks
04:35:16 <vincenz> \o/ for intercontinental flights
04:35:23 <psykotic> how long is the flight?
04:35:28 <vincenz> no idea
04:35:35 <psykotic> is it direct?
04:35:40 <vincenz> brussels->atlanta, then atlanta->bogota
04:35:44 <psykotic> damn.
04:35:46 <vincenz> no, only madrid's direct to bogota
04:35:49 <psykotic> that must work out to about 24 total
04:35:55 <vincenz> yeah, that's why I fear my ... behind on the way back
04:36:33 <psykotic> charm the chick at the checkin desk into giving you good seats
04:36:36 <vincenz> I don't mind the time, I'm happy as long as each individual flight is long enough to get settled in, watch lots of movies and do other flight-related activities
04:36:53 <vincenz> and enjoy flight-meals
04:37:03 <psykotic> enjoy.. flight meals.
04:37:06 <psykotic> does not compute :)
04:37:16 <vincenz> they're fun, you get all these little containers to open
04:37:20 <vincenz> well, they're fun on long flights
04:37:23 <vincenz> they tend to suck on short ones
04:37:38 <vincenz> it's just the whole nesting aspect, you've got your own little cubicle to read/write/eat food/ watchi movies
04:37:41 <vincenz> what more can you want?!
04:38:03 * psykotic makes a list
04:38:09 * vincenz is starting to sound like the xkcd character and shuts up
04:38:15 <vincenz> I don't know, long flights for some reason appeal to me
04:38:19 <opqdonut> vincenz: i agree with you
04:38:24 <opqdonut> the nest thing etc :)
04:38:33 <ivant> vincenz, yeah, food is one of the most positive time-spending activities during a long flight
04:38:39 <psykotic> elbow space. knee space. food that doesn't suck. a cabin that isn't cold as a freezer. a non-fat neighbor. someone in front of you who doesn't put their seat-back down.
04:38:51 <vincenz> food's not that bad, ever flew with alitalia?
04:39:08 <vincenz> + you get to scope out potentially cute girls
04:39:08 <psykotic> no. i've flown with a lot of different airlines for long trips and it tends to suck.
04:39:21 <vincenz> alitalia's the best in terms of food :)
04:39:22 <pharm> vincenz: leg room?
04:39:25 <psykotic> even air france, which pride themselves on their food, was terrible
04:39:26 <opqdonut> depends on how often you do it i guess?
04:39:35 <vincenz> pharm: if you aim right, you can stick your legs in the seat in front of you
04:39:40 <vincenz> otherwise, you make sure to get aisle seat
04:39:44 <wli> It depends on the airline. In the US there isn't even wireless internet or telephones on planes.
04:39:45 <ricky_clarkson> vincenz: That reminds me of when some energy company had a name like powergenitalia.
04:39:52 <psykotic> vincenz, the trick is to ask for the seat at the emergency exit.
04:39:54 <ivant> psykotic, Lufthansa had quite good meals in spring
04:39:56 <psykotic> vincenz, they have much more leg space.
04:39:57 <vincenz> psykotic: not really
04:40:02 <vincenz> psykotic: they take your bag away then
04:40:02 * pharm hates long distance flights with a passion.
04:40:08 <vincenz> psykotic: can't have your stuff with you then :|
04:40:14 <psykotic> you put it overhead
04:40:19 <vincenz> and then it's inaccessible
04:40:27 * vincenz likes his stuff with him, tyvm
04:40:27 <psykotic> having almost double leg space trumps almost anything
04:40:45 <vincenz> only if there's cute female flight attendants taht have a lot of spare time...
04:40:54 <vincenz> (and you're single, though this is optional)
04:41:19 <vincenz> :P
04:41:31 <ivant> vincenz, sounds like you know how to get the best out of a long flight :-)
04:41:57 <vincenz> that was just talk, unfortunately
04:42:29 * vincenz should find some good papers to print out for his trip
04:43:02 <ivant> vincenz, work on project Euler solutions, maybe? :-)
04:43:13 <ivant> or past ICFP contest
04:43:13 <vincenz> ivant: I won't have a lpatop with me
04:43:25 <EvilTerran> ooh, there's an idea. i've been meaning to try project euler...
04:43:33 <ivant> vincenz, you don't need a laptop for a lot of project Euler problems
04:43:38 <ivant> only paper and pen
04:43:45 <vincenz> I don't like problem solving without an interpreter to test my ideas
04:44:08 * vincenz wonders how hard it is to make a haskell compiler out of elastic bands and toothpicks
04:44:12 <ivant> hehe, brain as an interpreter
04:44:37 <ivant> vincenz, you might fail to pass the security at the gate with so many toothpicks :-)
04:44:39 <vincenz> my brain's very intuitive based
04:44:59 <vincenz> s/intuitive/intuition
04:45:26 <nornagon> vincenz: is that a challenge? ;)
04:45:35 <vincenz> nornagon: yes :)
04:45:58 <vincenz> given the complexity of the haskell compiler, I fear it might require more toothpicks than there are atoms in the universe.
04:46:02 * ivant recalls lambda alligators
04:46:07 <vincenz> and you might need higher-order elastic bands
04:46:24 <tuxplorer> shapr:  I would like to learn the XSLT based approach to do HAppS programming. But the HAppS tutorial in the wiki gives examples only about the HTML printing method.. Pls suggest some other good tutorial to do it the XSLT way..
04:46:29 <vincenz> unless elastic bands are unityped..
04:46:42 <vincenz> (at which point you'd better just implement scheme iso haskell)
04:46:48 <ivant> ?time shapr
04:46:48 <lambdabot> Local time for shapr is Fri Aug 17 06:45:27 2007
04:47:10 <nornagon> well maybe you could construct a simple stack machine first
04:47:13 <ivant> tuxplorer, he's probably is still asleep, leave him a message using @tell
04:47:22 <nornagon> then write a hc in a dialect of forth
04:47:31 <vincenz> irc: the ultimate sink for abstract nonsense and geek humor
04:47:35 <nornagon> :)
04:47:35 <tuxplorer> @tell shapr  I would like to learn the XSLT based approach to do HAppS programming. But the HAppS tutorial in the wiki gives examples only about the HTML printing method.. Pls suggest some other good tutorial to do it the XSLT way..
04:47:35 <lambdabot> Consider it noted.
04:49:11 <nornagon> @index Data.Char
04:49:11 <lambdabot> bzzt
04:49:27 <vincenz> imagine a paper-based computer where you have a single-sheet of paper, can write with a pen in the normal wway of writing, but can also write code and see it run
04:49:27 <nornagon> @doc Data.Char
04:49:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
04:49:46 <nornagon> that would be incredibly cool
04:49:53 <ivant> vincenz, and you have only one paper sheet :-)
04:49:53 <nornagon> you could have it draw vector art and stuff
04:49:59 <vincenz> or even a little 'notebook'
04:50:06 <nornagon> but then it could clear back to code on command
04:50:14 <nornagon> sort of like an etch-a-sketch, only programmable
04:50:22 <vincenz> preferably with some simpler language
04:50:28 <vincenz> cause writing code out verbosely on paper = pain
04:50:47 <DRMacIver> writing out code verbosely on computer = pain, also.
04:50:49 <vincenz> maybe a dataflow language that canbe drawn diagramatically
04:50:55 <vincenz> DRMacIver: I type faster than I write
04:51:00 * ivant prefers writing complex algorithms on good ol' paper first
04:51:11 <vincenz> ivant: sure, in diagrams, not in fullout code
04:51:20 <EvilTerran> maybe have a "highlighter pen", which you could drag over something to evaluate it
04:51:25 <ivant> vincenz, sometimes in almost-haskell code
04:51:29 * vincenz shudders
04:51:32 * johnnowak shudders
04:51:32 <vincenz> I prefer vim for that :)
04:51:55 * EvilTerran has a graphics tablet... i think this warrants further meditation
04:51:58 <ivant> vincenz, you don't always have a laptop at hand, public transport in Russia is one of the cases :-)
04:52:08 <vincenz> ivant: as is a trip to colombia
04:52:10 <roconnor> Compiling!   --|===>
04:52:18 <vincenz> hence a lightweight paper-based system
04:52:50 <vincenz> 'circle text' COMPILE
04:52:56 <ivant> EvilTerran, did you find any useful software to make notes using it?
04:53:09 * igel produces an awful lot of paper when programming complex things...
04:53:24 <DRMacIver> vincenz: Yes, so do I. I'm not saying it's not less painful, just that it's still painful. :)
04:53:25 <ivant> it seems that all tablet software just sucks when you try to use it for writing, not drawing/painting/retouching
04:53:33 <EvilTerran> not yet, no. so far, i've mainly used it to doodle in mspaint. ;]
04:54:01 <igel> imho there is no software as flexible as a piece of paper and a pencil, yet
04:54:04 <EvilTerran> need to at least get some handwriting recognition going on
04:54:48 <johnnowak> You're all mad.
04:55:00 <ivant> EvilTerran, not necessarily, I'd be fine with the handwritten text, as long as I can tag and organize my scribbles
04:56:21 <EvilTerran> how're you going to tag without text?
04:56:40 <ivant> I agree to type the tags :-)
04:56:55 <ivant> I'd agree for the simple but working solution first
04:57:49 <EvilTerran> i'm actually not convinced that most drawing software is at all suitable for graphics work, tbh.
04:58:20 <ivant> EvilTerran, oh, it's so true on linux
04:58:22 <EvilTerran> for one thing, i need an easy way of turning the image, so i can actually draw decent straight lines
04:59:13 <EvilTerran> and clicking around on the toolbar doesn't count as easy. i'm thinking tap-and-drag sort of thing.
05:00:36 <xpika> is there any way to evaluate c expressions in ghci?
05:00:39 <ivant> vincenz, talking about writing haskell on paper, a guy from our ICFP team wrote a DNA compressor on 4 sheets of paper while he was going to work on monday (the last day of the contest)
05:01:20 <ddarius> EvilTerran: Turn the tablet.
05:01:52 <EvilTerran> ddarius, that's fine... if you don't mind the cursor going vertically when you move the pen horizontally
05:07:04 <vincenz> ivant: heh :)
05:07:38 <ivant> vincenz, the cool thing was that it worked flawlessly, after it typecheked
05:07:45 <vincenz> ivant: Nice :)
05:07:55 <vincenz> ivant: Though rather painful to get it that proper on paper
05:09:02 * ddarius doesn't even bother writing syntactically correct code on paper.
05:10:53 <gleb> hi all! could anyone please tell me why declaring 'instance Foo (IO a)' is prohibited in H98 and what clause here (http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html) lifts this restriction? thanks
05:10:55 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
05:14:48 <Saizan> gleb: instance Foo (IO a) is valid h98 afaiu
05:15:23 <gleb> Saizan: just tried it, ghci rejects it without -flasgow-exts
05:15:38 <nornagon> :t sequence_
05:15:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
05:15:48 <xerox> 7.4.4.1
05:15:57 <gleb> Saizan: oops, cannot reproduce
05:16:06 <gleb> sorry for the noise
05:16:12 <opqdonut> yeah, Foo (IO a) is fully h98 :)
05:16:45 <nornagon> :t repeat
05:16:47 <lambdabot> forall a. a -> [a]
05:16:47 <ddarius> Indeed, it's the same as [a]
05:17:09 <nornagon> lambdabot not responding to queries?
05:23:06 <EvilTerran> for some reason, :t seems to be a bit hit-and-miss. I use @type instead
05:27:21 <EvilTerran> @type repeat
05:27:23 <lambdabot> forall a. a -> [a]
05:27:41 <ClaudiusMaximus> @src Maybe fmap
05:27:42 <lambdabot> fmap _ Nothing       = Nothing
05:27:42 <lambdabot> fmap f (Just a)      = Just (f a)
05:27:42 <EvilTerran> wait, it worked there, anyway... damnit. i need more tea...
05:29:25 <roconnor> c\_/
05:31:56 <xpika> how do i turn on glasgow exts from the command line version of hugs?
05:32:19 <xerox> I believe -98 turns on extensions.
05:35:27 <evir> Why is it, that GHC 6.6 compiles via C (judging from the -v output) when I use the -On options (on amd64 and i386), but uses the native code generator when I don't use -On?
05:36:18 <dcoutts> evir: the native generator gives lower compile times
05:36:34 <dcoutts> so it makes sense to use it for -O0
05:37:09 <evir> So, with respect to the runtime effiency, the compilation via C yields better results?
05:38:14 <dcoutts> slightly, on x86 but the ncg is apparently slightly better on x86-64
05:38:46 <dmead> @seen lambdabot
05:38:46 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #ghc and #darcs
05:38:47 <dcoutts> evir: the -fvia-C used to generate much faster code, but the gap has got less and less over time
05:38:49 <dmead> yarr
05:39:23 <evir> dcoutts: Thank you.
05:40:41 <dmead> anyone here ever used ghc binaries on embedded systems?
05:42:45 <xpika> dmead: http://www.youtube.com/watch?v=-zEWS7P91d4 ?
05:44:00 <dmead> ty
05:44:36 <dmead> wait thats language-embedding
05:44:41 <dmead> i mean embedded as in small systems
05:44:47 <dmead> small flash systems
05:44:47 <dmead> etc
05:46:18 <ivant> dmead, are you interested in realtime capabilities, or there are no time constraints?
05:46:32 <nornagon> hrm
05:46:43 <nornagon> i was just now trying to write a simple bytecode interpreter in haskell
05:47:00 <nornagon> for a made-up bytecode
05:47:11 <nornagon> but I couldn't work out the structure I needed to run it
05:47:28 <nornagon> i sort of worked out to use a State monad to keep the PC and the stack in
05:47:55 <ivant> I'm not aware, whether ghc was tweaked to work on the embedded system, but one of the provisions is that it needs a garbage collector
05:48:15 <nornagon> but I couldn't work out whether I should keep the bytecode itself in the state, or use StateT and the reader monad
05:48:24 <dmead> ivant, there are no time constraints, it's embedded non realtime linux
05:48:45 <dmead> it's a machine that does interactions with a network of hardwired and wireless sensors
05:49:16 <ivant> then I believe it wouldn't be very hard to embed it (it is running linux, so most of the problems should be sorted out by the OS)
05:49:25 <waern> dcoutts: how far are we from a cabalized gtk2hs?
05:49:47 <dcoutts> waern: we need dep chasing in cabal
05:49:59 <waern> dcoutts: ah right, that thing
05:50:06 <dcoutts> waern: and to make it easier, probably pkg-config support
05:50:10 <ivant> dmead, you should check whether the architecture is supported, however
05:50:25 <dmead> it's a 486
05:50:38 <dmead> i've got a ghc binary compiled via C to run on it
05:50:39 <dcoutts> waern: and then a bit to make gtk2hs use the standalone c2hs rather than it's own bundled version
05:50:48 <dmead> but the libraries it requires by default are quite large for a 64meg system
05:50:50 <waern> dcoutts: ok
05:51:02 <dcoutts> waern: want to help? :-)
05:51:09 <ivant> oh, I see
05:51:13 <dcoutts> waern: cabal needs more hackers
05:51:45 <waern> dcoutts: ehm.. hehe. I was just wondering because it would be easier for me to make the scintilla-binding if it's a separate package
05:51:56 <vincenz> @where hacking
05:51:57 <lambdabot> I know nothing about hacking.
05:52:06 <vincenz> dcoutts: I lost the link :|
05:52:31 <waern> dcoutts: I have enough projects atm I'm afraid
05:52:33 <dcoutts> waern: yeah, it'll be easier when they're all separate packages
05:52:38 <dcoutts> vincenz: hmm?
05:52:47 <vincenz> ah, found it, hac :)
05:52:53 <eivuokko> hac?
05:53:02 <vincenz> http://www.haskell.org/haskellwiki/Hac_2007_II
05:53:03 <lambdabot> Title: Hac 2007 II - HaskellWiki
06:02:55 <roconnor> is Freiburg, Freiburg im Breisgau?
06:03:25 <ivant> http://proglang.informatik.uni-freiburg.de/ICFP2007/travel-information.shtml
06:03:29 <lambdabot> Title: ICFP 2007: Travel Information, http://tinyurl.com/2xxjkt
06:04:25 <roconnor> ah
06:04:26 <ivant> roconnor, yes, it is the
06:04:29 <roconnor> maybe I should go!
06:04:29 <ivant> one
06:04:35 <roconnor> It's not so far from here.
06:04:54 <roconnor> oh
06:05:04 <roconnor> It's a little further than I thought.
06:05:24 <ivant> :-)
06:05:26 <roconnor> It's not next to luxembourg
06:06:11 <roconnor> still, maybe I should go.
06:06:42 <roconnor> or maybe just go for the hackathon.
06:06:47 <ivant> does anyone know how can I travel from Vienna, Austria to Freiburg?
06:07:16 <roconnor> ivant: presumably by train or by plane.
06:07:34 <roconnor> depending on how fast you want to get there.
06:08:23 <pejo> ivant, for ICFP? http://proglang.informatik.uni-freiburg.de/ICFP2007/travel-information.shtml has a pretty good list.
06:08:24 <lambdabot> Title: ICFP 2007: Travel Information, http://tinyurl.com/2xxjkt
06:09:05 <ivant> well, JTRES ends on 28th of  Sep, so I'm not in a hurry
06:10:15 <pejo> Doh, I need to read my entire screen. You had that link up there.
06:10:38 <pejo> Sorry about that.
06:10:53 <ivant> pejo, thanks, I reread the travel information page and found a link to bahn.de
06:11:04 <ivant> I guess, it answers my question
06:13:31 <ivant> should I expect to find the wifi hotspots in Europe easily? (both free and non-free)
06:14:24 <roconnor> ivant: I recall hotspots were fairly common when I was in Berlin.
06:14:37 <roconnor> but I never tried them.
06:15:07 <roconnor> prehaps you should read about IP over DNS. :)
06:16:07 <ivant> roconnor, IP over DNS? what does it mean?
06:16:30 <roconnor> http://slashdot.org/articles/00/09/10/2230242.shtml
06:16:30 <ivant> wow!
06:16:31 <lambdabot> Title: Slashdot | IP Tunneling Through Nameservers
06:17:22 <roconnor> KJhjh33.dd_2sT-XXT.dAAoi_f.mydnstunnel.org
06:19:55 <ivant> that's one of the funniest abuses of general purpose protocols which I've seen
06:26:17 <dionoea> it's very usefull in airports of you don't want to pay for wifi
06:27:10 <ivant> are there open dns (nstx) servers out there?
06:27:37 <ivant> I mean real servers, not the software
06:29:43 <swiert> @users
06:29:43 <lambdabot> Maximum users seen in #haskell: 385, currently: 360 (93.5%), active: 13 (3.6%)
06:32:33 * novaburst is glad his Programming in Haskell book has shipped
06:33:33 <ivant> do they ship extra brainpower and time as well? :-) I'd like to have a couple, then
06:34:26 <dionoea> ivant: not that I know (since the server can accept one client only, IIRC from 1 year ago)
06:35:59 <novaburst> ivant: i wish, i could use some of that too, heh
06:38:29 <greenrd> hmm, I wonder if anyone's ever been arrested for "stealing wireless services" using IP-over-DNS
06:39:25 <ivant> I guess it costs too much to track down a person who “steals” the wireless services
06:40:06 <dionoea> and I guess that very few people do it
06:40:37 <SamB> the real question is: why do they let you access DNS but not the web if you don't pay?
06:40:59 <ivant> SamB, this way they can bootstrap their login page
06:41:16 <dionoea> they could provide a fake DNS for that, but they're too lazy
06:41:36 <dionoea> or maybe that would break the client's DNS cache once he pays
06:41:43 <ivant> they return the correct IP address, but your traffic won't pass the gate till you are logged in
06:42:32 <SamB> I'd think they could just have their DNS server act as if it didn't hear you if you asked about anything else, until you payed
06:42:37 <ivant> it would get redirected to the login page
06:42:54 <SamB> oh
06:43:02 <SamB> couldn't they just put up posters?
06:43:04 <ivant> SamB, that is not very convenient, e.g. in the airports. How do people know, where they can login?
06:43:30 <ivant> SamB, nobody would use that internet. I'd hate to type those addresses myself
06:43:56 <SamB> they could call it wifi.airport's-domain-name.com
06:44:18 <ivant> aha, suppose now, there are three wifi service providers who work in this area
06:44:22 <ivant> :-)
06:44:51 <ivant> oops, disregard my last thought
06:45:28 <SamB> they could offer a copy of that warstalking package for download ;-P
06:45:30 <ivant> SamB, it still would suck, because most people don't know this address (or how to type it correctly)
06:47:27 <SamB> posters, I say!
06:48:09 <ivant> some people (me included) don't pay a lot of attention to any advertising materials hanging around
06:48:31 <SamB> low-gloss posters
06:48:35 <ivant> you're trying to find a social solution to a technical problems :-)
06:48:44 <ivant> s/problems/problem/
06:49:12 <dionoea> SamB: people getting the page when they open their browser vs people having to type the address they see on posters ... you can see which solution is cheapper to implement and will get you most clients :)
06:54:18 <ivant> is it correct to say that O(a^n) algorithms (where n is the size of input) are NP?
06:55:14 <roconnor> ivant: I don't think all O(a^n) algorithms are NP.
06:55:17 <EvilTerran> not all such, i think.
06:56:04 <ivant> then, is there any correspondence between O(...) notation and P/NP
06:56:18 <ivant> other than O(n^k) are P
06:56:24 <roconnor> :)
06:57:05 <SamB_XP> well, aren't O(1) algorithms also O(a^n)?
06:57:35 <ivant> oh, now I see the important difference O(...) refers to algorithm, whereas P/NP refers to a problem
06:57:52 <ivant> one can solve a problem using different algorithms (mostly, suboptimal :-) )
06:59:20 <ivant> but if one can prove, that the problem she is solving is equivalent to another NP problem, then she can safely claim that the problem is NP. Correct?
06:59:34 <roconnor> yep
06:59:45 <roconnor> for a proper definition of equivalent
06:59:55 <roconnor> meaning translatable in polytime.
07:00:38 <ivant> then, does being NP for a problem implies exponential time of the algorithm (at best)
07:00:47 <ivant> s/implies/imply/
07:00:58 <roconnor> ivant: ahh, the big question... does NP = P?
07:01:13 <ivant> roconnor, oh, I've been feeling it was coming along the way :-)
07:01:31 <ivant> it's good I could come to this question myself
07:02:01 <roconnor> Even if NP != P, it's not obvious to me that implies exponential.
07:02:16 <ivant> roconnor, what are other choices?
07:02:19 <roconnor> There are some O(f(n)) that are superpolynomial but sub exponential.
07:02:33 <roconnor> The most famous being the best factoring algorithms.
07:02:42 <ivant> hmm, I wonder, where do they fit then
07:03:59 <sieni> roconnor: ivant: P \subseteq NP \subseteq PSPACE \subseteq EXPTIME \subseteq NEXPTIME \subseteq EXPSPACE
07:04:35 <MyCatVerbs> Observation: people who aren't "used to" computers seem to have bigger problems with the idea of mutable state than any one other topic.
07:04:56 <hpaste>  roconor pasted "Superpolynomial subexponential runtimes" at http://hpaste.org/2296
07:04:59 <MyCatVerbs> Hypothesis: fuck every programming language that isn't Haskell, Clean or Prolog right in the ear?
07:05:21 <ivant> MyCatVerbs, that is probably because people learn maths where all variables are immutable
07:05:28 <roconnor> ivant: according to the chorus: ``E to the root-log root-log-log''
07:05:40 <ivant> s/learn maths/learn maths earlier in their lives/
07:06:20 <tuxplorer> tuxplorer
07:06:54 <roconnor> O(exp (sqrt(log n)))
07:06:57 <ivant> roconnor, reminded me of "Spam, spam, lovely spam!" chorus: has the same rhythm
07:07:20 <roconnor> ivant: this is sung to the tune of that mary poppins song.
07:07:28 <evir> ivant: NP implies polynomial time for solving a problem.
07:07:34 <evir> (on a non-deterministic turing machine)
07:08:00 <MyCatVerbs> evir: ...
07:08:34 <MyCatVerbs> evir: slight difficulty, no one has ever implemented a non-deterministic Turing machine, they've merely emulated them (very slowly) on deterministic Turing machines.
07:08:40 <ivant> evir, so now I don't understand this part (although I reread this definition a dozen of times already). How does it translate to the computer algorithms?
07:08:43 <mrd> polynomial time to verify a solution on a deterministic machine
07:08:52 <DRMacIver> MyCatVerbs: Yeah, but at least we've reduced it to a hardware problem. :)
07:08:58 <ivant> :-)
07:09:13 <evir> MyCatVerbs: I was just refering to the question whether NP implies that a problem is solvable only in exponential time ... that's not known so far. ;-)
07:09:35 <ivant> mrd, so if solution is "true or false", then we have a guaranteed polynomial time on a deterministic machine?
07:09:57 <evir> ivant: Well all computers known today work deterministicly ... but there are problems that can't be solved in polynomial time even by nondeterministic turing machines.
07:10:10 <MyCatVerbs> DRMacIver: on behalf of my computer architecture lecturer (who is an awesome guy and would never dream of phrasing this anywhere near so rudely as I am right now), go stick your thumb where the sun doesn't shine. In a mailbox, for example.
07:10:22 <MyCatVerbs> DRMacIver: perhaps a small, very dark tent. :)
07:11:14 <MyCatVerbs> evir: yars, but NP contains some -really really interesting- problems. Like, what's the smallest possible configuration of logic gates that'll output the entire text of Hamlet vertabim?
07:11:22 <ivant> aha, now, List monad simulates a nondeterministic turing machine
07:11:56 <MyCatVerbs> ivant: but not in polynomial time. :P
07:11:58 <evir> ivant: But simulating a nondeterministic turing machine deterministically can take exponential time.
07:12:04 <hpaste>  bos annotated "collaborative filtering in haskell" with "single-map version" at http://hpaste.org/2293#a1
07:12:36 <mrd> ivant: a proof of true or false
07:13:17 <ivant> ok, thank you guys, now I have some understanding of what should I tell my advisor about the reasons of lack of good results all this time
07:13:40 <mrd> to show that a problem is in NP you just need to show that a "Yes" solution has a proof which is checkable in polynomial time
07:13:43 <DRMacIver> MyCatVerbs: No thanks. :)
07:13:45 <evir> ivant: There are also fixed-parameter tractable problems.
07:13:50 <ivant> I mean, if I'd be able to prove it's NP and I've been trying for so long looking for it inP
07:14:07 <evir> Given a problem, you show for a given parameter k, that it is deterministically solvable in O(k) * n ^ O(1) time.
07:14:15 <mrd> it's usually very easy to show that a problem is in NP
07:14:17 <evir> Vertex cover is one such, I think.
07:14:31 <mrd> k-vertex cover?
07:14:38 <evir> They are NP-hard in generell but efficiently solvable for fixed parameters.
07:14:41 <mrd> yes
07:14:43 <evir> general
07:14:59 <mrd> 100-vertex cover is efficiently solvable.  k-vertex cover is not.
07:18:40 <ivant> does that mean that the algorithm is somehow specificially crafted to work for the case of k=100?
07:22:16 <shapr> elliottt: It's imporant to be able to get off the unicycle when needed, so I just have pretty boring pedals, specifically Magnesium sealed bearing OJC platform pedals.
07:30:40 <daniel_larsson> shapr: As in, before hurling off the bridge?
07:31:41 <evir> ivant: Not specificly. This means that for a parameter k, vertex cover is solvable in f(k) * p(n), p being polynomial. This means, for some small k you can efficiently solve it, despite vertex cover being np-complete.
07:32:12 <evir> ivant: But for other k, you can't solve it efficiently either for the lack of computing power.
07:34:08 <evir> ivant: There is a known algorithm that solves vertex cover in O(k*n + 1.2... ^k) or something, k being the vertex covers' size.
07:34:40 <wli> evir: Expand?
07:34:48 <wli> O(k*n + ?)
07:35:20 <evir> + x^k, x being about 1.2 ... I don't remember the exact value, sorry. :-)
07:35:47 <wli> Basically exponential in k?
07:36:21 <evir> Well, with respect to the input size n, it is linear in k.
07:36:40 <evir> k is constant.
07:37:21 <ivant> ok, thanks a lot!
07:42:31 <njd> @seen ndm
07:42:31 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 23h 56m 17s ago, and .
07:51:09 <shapr> daniel_larsson: The idea being that the unicycle can (maybe) survive hurtling off the bridge, but I cannot.. thus, I allow it to go its way, and I go mine.
07:52:25 <shapr> @users
07:52:26 <lambdabot> Maximum users seen in #haskell: 385, currently: 372 (96.6%), active: 12 (3.2%)
07:53:09 <dylan> it's easier to make a new unicycle than a new shapr.
07:53:55 <shapr> yup
07:54:12 <shapr> The travails that I've gone through to get here are more trouble than they're worth.
07:54:16 * arcatan wants a unicycle
07:54:21 <shapr> arcatan: unicycle.se
07:54:47 <shapr> arcatan: Peter (the guy who runs unicycle.se) is a great guy, he's crazy but fun.
07:55:22 <greenrd> interesting: http://www.cs.nott.ac.uk/~ctm/obseqnow.pdf
07:55:43 <shapr> I persuaded Luke Gorrie to get a new unicycle. When Luke (living in stockholm at the time) called Peter, Peter showed up on his doorstep after hours with the new toy.
07:56:42 <ricky_clarkson> shapr: Someone stole a wheel from my bicycle, if that counts.
07:56:59 <shapr> greenrd: Funny, I was just reading http://projecteuclid.org/DPubS/Repository/1.0/Disseminate?view=body&id=pdf_1&handle=euclid.bams/1183548590 which is related on the group theory side.
07:57:04 <lambdabot> Title: The word problem and the isomorphism problem for groups, http://tinyurl.com/ynw5fa
07:57:45 <shapr> ricky_clarkson: You should try unicycling, but not on that :-)
07:58:28 <shapr> greenrd: This is a bit over my head, what's it good for?
07:58:48 <greenrd> shapr: I'll let you know when I've finished reading it :)
07:59:18 <shapr> It looks sort of like Hudak's mail that lets you represent recursive datatypes with tying-the-knot sort of calls, and thus is comparable for equality.
07:59:24 <greenrd> I've read a previous version of this paper so I have some idea
08:03:47 <shapr> Oh, it's good for evaluation and any sort of rewriting optimization.
08:06:18 <swiert> shapr: it's a bit technical, it has to do with the (almost philosophical) question of what equality means.
08:06:41 <swiert> and to treat equality in type theory.
08:06:56 <shapr> Lots of applications for that.
08:07:40 <swiert> Yup. It's a pretty technical paper, sure, but the basic idea isn't too hard.
08:07:40 <shapr> swiert: Worked on any other papers lately?
08:07:57 <swiert> Funny you should ask.
08:08:08 * shapr gets interested!
08:08:19 <swiert> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
08:08:33 <swiert> It's kind of modular data types/modular monads.
08:08:48 <swiert> Pretty fresh off the press.
08:08:55 <shapr> coool
08:09:08 * shapr reads
08:09:45 <shapr> Hm, this could help with HAppS state versioning problem.
08:10:44 <swiert> It's not a perfect solution, but it works very nicely in quite some cases.
08:11:16 <shapr> swiert: Is there pokable source online somewhere?
08:11:33 <swiert> http://www.cs.nott.ac.uk/~wss/Misc/LaCarte.hs
08:11:49 <shapr> yay
08:11:57 <swiert> Pretty much all the source in the paper.
08:13:31 <wli> With literate Haskell etc. you can get pretty close to the source and paper being one, or so I thought.
08:13:40 <shapr> Yeah, I sort of wish this were lhs
08:13:41 <kosmikus> main = putStrLn "It type checks."
08:13:41 <kosmikus> :)
08:13:53 <shapr> It's easier to keep track of how the text and code fits together.
08:14:57 <shapr> swiert: Still, I'm happy you have actual released source at all!
08:15:05 <shapr> That seems pretty rare for Haskell papers, sadly.
08:15:08 <swiert> kosmikus: Yes. Then it must be correct.
08:15:10 <swiert> ;)
08:15:54 <shapr> swiert: Have we ever met in person? I can't recall...
08:15:54 <wli> The ones I read tend to be pretty close to lhs2TeX output run on a commented source file.
08:16:18 <swiert> shapr: at ICFP 2007 I think.
08:16:26 <swiert> or 2006 rather.
08:16:28 <kosmikus> wli: yeah, that's what I do ;)
08:16:34 <shapr> Were you at the HW?
08:16:43 <swiert> shapr: Yes.
08:16:56 <wli> kosmikus: I wish I had ideas worthy of publication.
08:17:01 <shapr> wli: You do.
08:17:07 <wli> shapr: Like what?
08:17:27 <kosmikus> wli: I know that problem.
08:17:37 <shapr> Lots of stuff you've coded isn't understood by most people, and there are interested people.
08:17:49 <wli> shapr: Any examples?
08:18:11 <shapr> You could write about the kernel in lots of different ways, or how to do nifty math in Haskell, or implement your benchmarking ideas and publish a paper on that.
08:18:38 <wli> Well, my goals for the time being are a bit more modest.
08:18:40 <shapr> For example, are there any books on how to get Linux happy on 16+ cpus?
08:18:55 <shapr> Haven't you gotten Linux on ~64 CPUs?
08:19:16 <shapr> swiert: Oh, I remember now!
08:19:17 <ihope_> @src ListT
08:19:17 <lambdabot> Source not found. My mind is going. I can feel it.
08:19:19 <wli> shapr: I don't know anything particularly relevant to that apart from general debugging/bugfixing.
08:19:23 <shapr> swiert: The pizza place!
08:19:40 <shapr> That was fun.
08:19:49 * shapr was very stressed at the time...
08:19:54 <swiert> shapr: Yep - with bringert and a few other people.
08:20:09 <shapr> That was a lot of fun.
08:20:35 <wli> shapr: Others have written mathematical code superior to my own without much in the way of comment (though I have a particular numerical analysis -relevant idea in need of further development).
08:21:18 <shapr> wli: But code is first and foremost a way to communicate to other humans, and secondarily a way to communicate with computers.
08:21:50 <shapr> Things are easy if you already understand them...
08:22:38 <wli> shapr: I heavily documented my motivating example of why a native Haskell NIH of ncurses is needed.
08:22:54 <shapr> The whole point of research is that commucating what is understood is just as important as understanding new things.
08:23:06 <shapr> Sounds interesting, where's that?
08:23:21 <wli> http://holomorphy.com/~wli/MiniCalc.pdf
08:24:50 <Saizan> NIH?
08:25:22 <eivuokko> Not Invented Here
08:25:23 <wli> Not Invented Here; used to refer to rewrites of already-existing software in various instances.
08:25:50 <shapr> wli: Interesting
08:25:54 <ihope_> Last night I was pondering monad transformers, and I managed to come up with an instance of Monad for ListT.
08:26:06 <wli> "An NIH of ncurses" would mean "a rewrite of ncurses"
08:26:08 <ihope_> The only non-general part of it is sequence.
08:27:01 <wli> shapr: It also shows that terminal handling is in something of a unique position with respect to foreign calls.
08:27:45 <shapr> I think you should say that in the document.
08:27:56 <wli> shapr: I didn't?
08:28:43 <shapr> Not in a way that I could understand it, at least.
08:29:00 <eivuokko> The very last bit;  sigINT being blocked.
08:29:11 <shapr> Ah
08:29:22 <ihope_> Is sequence the same as mapM, and mapM the same as \x y -> sequence (liftM x y)?
08:29:45 <ari> @src sequence
08:29:46 <lambdabot> sequence ms = foldr k (return []) ms
08:29:46 <lambdabot>     where
08:29:46 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
08:29:47 <ari> @src mapM
08:29:48 <lambdabot> mapM f as = sequence (map f as)
08:29:48 <xerox> ?src mapM
08:29:49 <lambdabot> mapM f as = sequence (map f as)
08:29:50 <ihope_> Er, s/same as mapM/same as mapM id/
08:30:02 <ari> :t mapM id
08:30:04 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
08:30:07 <ihope_> Well, that certainly answers one question :-)
08:30:12 <shapr> wli: You may want to add a section at the beginning outlining the problem you're describing, and maybe a conclusion section that suggests fixes?
08:30:26 <ihope_> And the other, too, really. Thanks.
08:30:56 <byorgey> @type \x y -> sequence (liftM x y)
08:30:58 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
08:31:02 <wli> shapr: "The test is essentially whether ^C trigger an immediate response..."
08:31:26 <shapr> Well, yeah.. but if I found this pdf in my ~dn/researchpapers/ dir, I wouldn't know where to start.
08:32:32 <wli> It's not quite a research paper. I wouldn't call NIH'ing ncurses research.
08:33:47 <shapr> wli: But you do want to write papers, yeah?
08:35:18 <roconnor> swiert: can you explain the issue with computation an reflexivity in OTT now!?
08:35:27 <roconnor> s/an/and/
08:35:30 <wli> Yeah. I'd do that on other topics, e.g. the numerical analysis bit I've got floating around (its convergence properties for root-finding are promising, for instance).
08:35:43 <swiert> roconnor: I can try...
08:36:43 <swiert> roconnor: What was your question?
08:36:59 <wli> I still don't quite have the spline code going.
08:38:09 <roconnor> swiert: ``but that the computational behaviour of this is not uniformly the identity: it depends on the sturcture of T, and the value being transported''
08:38:45 <roconnor> swiert: ``Fortunately, as you shal see later we can recorve this intensional behaviour without further adjusting our notion of evalutaion''
08:39:07 <roconnor> so something is up with reflexivity and computation, but I'm pretty confused.
08:39:19 <swiert> Which section?
08:39:28 <roconnor> 4.1
08:40:31 <Gwern-away> kind of curious. if then elses don't seem to work in the IO monad. is one supposed to be using the case syntax?
08:40:54 <sieni> Gwern-away: what do you mean?
08:41:29 <sieni> Gwern-away: i.e. what did you try to do, what did you expect and what actually happened?
08:41:31 <swiert> roconnor: The crucial point is that consistent axioms cannot break canonicity..
08:42:26 <roconnor> swiert: do the axioms break canonicity?
08:42:57 <swiert> roconnor: they could. You could have a stuck coercion, for instance, because your proof is not refl.
08:43:24 <roconnor> that sounds bad.
08:43:59 <swiert> roconnor: (that was in ITT). In OTT Lemma 2 (Section 4) shows how consistent axioms cannot break canonicity.
08:44:18 <sieni> Gwern-away: do {if True then do {putStrLn "8"} else do {return ()}} just works
08:44:20 <Gwern-away> sieni: 'if (chrootE dir) == 0 then (setCurrentDirectory "/") else error "Chroot failed"'
08:45:06 <roconnor> swiert: for the empty context only?
08:45:17 <swiert> roconnor: yes.
08:45:42 <sieni> Gwern-away: ahh, chrootE dir is of type IO Bool
08:46:39 <Gwern-away> sieni: right, right
08:46:51 <Gwern-away> and bool != IO Bool, but the liftMs didn't help at all
08:47:24 <vincenz> You need more elevators
08:47:55 <vincenz> sequence . replicate 4 "01"
08:47:57 <vincenz> sequence . replicate 4 $ "01"
08:47:59 <vincenz> > sequence . replicate 4 $ "01"
08:48:00 <sieni> Gwern-away: what about just do {x <- chrootE dir; if x then foo else bar}
08:48:01 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
08:49:54 <Eelis> Gwern-away: what library's chroot are you using?
08:49:54 <Gwern-away> sieni: that seems to work
08:50:14 <Gwern-away> Eelis: I'm using the ffi to grab the one in unistd.h
08:50:35 <Eelis> Gwern-away: so am i. i use  chroot :: FilePath -> IO (); chroot s = throwErrnoIfMinus1_ "chroot" (withCString s c_chroot)
08:50:46 <Eelis> where c_chroot is the FFI imported thing
08:51:10 <Gwern-away> bleh. I *knew* one of those throwErr functions was the right thing to use
08:51:17 <Gwern-away> but I couldn't figure out which one. dammit
08:51:42 <Gwern-away> Eelis: what are you using it in?
08:51:59 <Eelis> Gwern-away: C++ eval bot for ##iso-c++/##c++
08:52:42 <swiert> roconnor: The set/prop distinction is important. Canonicity only holds for Set; you're allowed to make extra assumptions in Prop.
08:53:06 <Gwern-away> Eelis: why are you doing it in haskell? wouldn't it be easier to call man 2 chroot from c++ or c?
08:53:29 <Eelis> Gwern-away: that's what i used to think, and an early version was indeed mostly C++. but then i found that it was shorter and more elegant in Haskell after all
08:53:33 <Eelis> and now the whole thing is Haskell
08:54:41 <Gwern-away> huh. but the actually evaluation of code would have to be done by C++ right. unless you've implemented an interpreter or something in haskell...
08:54:54 <Eelis> it just invokes gcc and ptraces everything
08:54:58 <Gwern-away> Eelis: how did you call the ulimit stuff?
08:54:59 <Eelis> http://www.eelis.net/geordi
08:55:03 <lambdabot> Title: geordi - C++ eval bot
08:55:31 <vincenz> > 186 / 2 / 6
08:55:33 <Eelis> Gwern-away: you mean rlimit? there's System.Posix.Resource
08:55:39 <lambdabot>  15.5
08:55:58 <Gwern-away> Eelis: yes, but I meant did you do anything clever like with your chroot
08:56:19 <Gwern-away> I just have a list of setResourceLimits in my do
08:56:34 <Eelis> Gwern-away: nothing particularly clever. just a plain ol' minimal chroot containing only the bare essentials to support gcc.
08:57:41 <ajcc> Hi, I did just manage to forget about a book I was recommended today, it was a book a about how to program. I had a look at O'Reilly and they had one called 'Learn to Program'. Have anyone any recommendations about this book? I feel like I need to get back into the right way to think when programming.
08:57:45 <Gwern-away> oh. is the chroot already set up?
08:58:00 <greenrd> ajcc: haskell programming is a bit different from programming in most other languages, so I suggest a haskell-specific book
08:58:13 <Eelis> Gwern-away: chroot is just for entering a directory. in geordi's case, the directory is set up during installation
08:58:23 <Eelis> or rather, for setting a root directory
08:58:28 <Eelis> entering is the second step, of course
08:58:44 <Eelis> this might be more appropriate in #geordi, btw
09:00:21 <ajcc> greenrd: yeah, I'm getting one of those as well :) I was just worried about that I haven't programmed in two years something, after a beginners class in c++
09:00:42 <shapr> ajcc: If you just want to learn to program, and don't care about the language, I like Structure and Interpretation of Computer Programs - http://mitpress.mit.edu/sicp/
09:00:43 <lambdabot> Title: Welcome to the SICP Web Site
09:01:03 <shapr> ajcc: Full text of SICP is free, just download it.
09:01:15 <greenrd> yeah, SICP is good
09:01:16 <ajcc> shapr: a, nice! thanks for the tip!
09:01:31 <Gwern-away> Eelis: well, I'll look at the source and see whether I don't understand anything
09:01:39 <shapr> ajcc: But if you want to specifically learn Haskell, your best bet is to hang around here and ask questions and read the online tutorials that are suggested.
09:01:47 <shapr> ajcc: Are you learning Haskell for business or pleasure?
09:01:57 <greenrd> you get more than just what the typical "learn how to grind out simple code in 21 days!" book gives you
09:01:58 <greenrd> from SICP
09:02:00 <Eelis> Gwern-away: ok. if you find potential vulnerabilities (you wouldn't be the first), i'm always interested :)
09:02:09 <shapr> SICP gives you, like, an actual clue!
09:02:31 <Gwern-away> Eelis: heck, I just want to write a decent haskell sandbox for my haskell scripts. this is all part of the winding trail to useful code...
09:03:18 <shapr> There are three books I recommend to all new programmers, SICP, "The Pragmatic Programmer", and "The Art of Doing Science and Engineering: Learning to Learn"
09:03:20 <Eelis> Gwern-away: secure execution of arbitrary code is what geordi's all about, so its source should definitely be interesting then
09:03:26 <shapr> Heck, to *all* programmers.
09:04:21 <shapr> On the downside, ADSE is very hard to find, I got my copy for $120, and I've seen it go for $800.
09:05:30 <shapr> ajcc: Here's the second book I suggest: http://www.pragmaticprogrammer.com/ppbook/index.shtml
09:05:31 <lambdabot> Title: The Pragmatic Programmer: From Journeyman to Master
09:05:42 <Gwern-away> shapr: I've never heard of that third one. what's it like?
09:06:28 <shapr> Gwern-away: It's the best of the three =)
09:06:49 <lament> it teaches you to use #pragmas
09:07:12 <Gwern-away> shapr: dunno. I've heard highly of SICP, and I liked pragmatic programmer
09:07:27 <lament> but it uses C, java and perl? :(
09:07:43 <shapr> Gwern-away: Hamming did a regular speech for years - http://lambda-the-ultimate.org/node/668 then he rewrote it and expanded it into this book.
09:07:44 <lambdabot> Title: Richard Hamming - "You and Your Research" | Lambda the Ultimate
09:07:44 <greenrd> well, it's pragmatic, wadda ya expect?
09:07:48 <greenrd> ;)
09:08:02 <Gwern-away> shapr: wait, actually I think I remember reading that speech
09:08:03 <Nafai> The Pragmatic Programmer is a great book
09:08:18 <Nafai> I just re-read it and I couldn't help but think some of their advice was covered just by using Haskell :)
09:08:21 <Gwern-away> it's the one where he says to work on the most important problem, to sit with the active discussing people, etc
09:08:24 <Gwern-away> right?
09:08:28 <shapr> Gwern-away: Yup
09:08:56 <shapr> Gwern-away: ADSE is the real book that turned into.
09:08:57 * Gwern-away puts the book on my list, then. that was an excellent little speech
09:09:06 <ajcc> shapr: nice, thank you!
09:09:22 <shapr> Funny thing is that my brother, my mother, and one of my sisters tried to borrow ADSE from me the instant they read a few pages.
09:09:46 <shapr> My mother has a master's in Library Science, my brother has a French degree, and my sister is a flight person on airplanes.
09:09:53 <ajcc> shapr: I'm learning haskell for learning purpose, I'm into physics and math, so I was thinking about Haskell or LISP
09:10:02 <Gwern-away> shapr: sounds like you put them in descending order... :)
09:10:18 <shapr> Gwern-away: Actually, in the order they tried to borrow the book from me. My mother has it now.
09:10:59 <shapr> I always feel like going out and slaying dragons after reading ADSE.
09:11:10 <shapr> ajcc: So, what do you think I should read?
09:11:24 <shapr> ajcc: Any cool suggestions I may not have heard of yet?
09:12:03 <shapr> (Jag läser svenska också)
09:12:32 <xerox> It is *so* satisfactory when not only the code works, but it is also nice.  *bounces happily*
09:12:33 <SyntaxNinja> @seen dons
09:12:34 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 8h 39m 51s ago.
09:12:49 <shapr> xerox: Is there more parsec goodness now?
09:12:57 <ajcc> Ah, it's the Programatic Programmer book I got recommended today :)
09:13:23 <xerox> shapr: I've finally got the raw combinators running on the transformer. Checking they meet the specifications right now :-)
09:13:26 <ajcc> shapr: Haskell
09:13:26 <ajcc> The Craft of Functional Programming
09:13:29 <ajcc> Second Edition
09:13:31 <shapr> xerox: Yay!
09:13:36 <ajcc> is the book I'll get
09:14:03 <shapr> ajcc: I have a copy in my bookshelf :-) But I've only read a few Swedish books, anything cheerful and originally written in Swedish that you can suggest?
09:14:33 * shapr is betting ajcc is in Sweden, and near Denmark.
09:14:41 <SyntaxNinja> how is everyone today?
09:14:41 <lambdabot> SyntaxNinja: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:14:51 <SyntaxNinja> lambdabot: tell anyone who messages me to learn email.
09:14:53 <shapr> I'm hyper! How are you?
09:14:53 <wli> Well.
09:15:00 <SyntaxNinja> shapr: w00!
09:15:05 <ajcc> I usally never read translated book, because of the translated words being useless when talking about the thing you tried to learn from them
09:15:05 <SyntaxNinja> shapr: are you back on that horse yet?
09:19:21 <shapr> SyntaxNinja: I'm riding the tiger of code!
09:19:44 <Gwern-away> shapr: but how are you going to get off?
09:20:05 <shapr> Why would I want to?
09:20:15 <shapr> Code is the most fun I can have by myself.
09:20:17 <SyntaxNinja> shapr: sweet
09:20:25 <SyntaxNinja> shapr: you're not alone!
09:20:28 <SyntaxNinja> (on irc)
09:20:40 <Gwern-away> heh. well-played. after all you don't have to worry about the tiger devouring you if you never intend to get off
09:20:52 <shapr> SyntaxNinja: Yeah, but.. well.. nm
09:21:29 <SyntaxNinja> speaking of tigers, there's a sweet youtube video of a buffalo fighting a lion</aol>
09:24:19 <wli> I've not watched anything on youtube for a number of months.
09:25:06 <lament> wanna watch something on youtube? :)
09:27:37 <wli> I'm frying some eggs at the moment, so no.
09:43:12 <shapr> mmm, code
09:43:27 <shapr> ajcc: Kommer du från Sverige?
09:48:23 <conal> hi shapr.
09:51:00 <hpaste>  palomer pasted "monad orelse madness" at http://hpaste.org/2297
09:51:30 <sm> good morning
09:51:53 <conal> sm: howdy
09:53:40 <hpaste>  palomer pasted "simple parsing algorithm" at http://hpaste.org/2298
10:02:58 <ohub> http://unenterprise.blogspot.com/2007/08/world-has-gone-mad.html
10:02:59 <lambdabot> Title: Desperately UnEnterprise: The world has gone mad
10:03:11 <ClaudiusMaximus> @paste
10:03:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:03:15 <ohub> misspaste, but might work here also :)
10:04:29 <DRMacIver> ohub: Hm?
10:04:51 <hpaste>  ClaudiusMaximus pasted "arrows and monomorphism restriction" at http://hpaste.org/2299
10:04:56 <DRMacIver> Oh, mispaste
10:04:59 * DRMacIver goes back to sleep
10:05:07 <ClaudiusMaximus> anyone have any clue what i'm doing wrong here?
10:07:29 <ajcc> shapr: skulle jag nog vilja pst
10:07:43 <conal> ClaudiusMaximus: did you try the flag?
10:08:06 <ajcc> shapr: tror inte det finns ngra svenska haskellbcker nnu
10:08:14 <conal> ClaudiusMaximus: or adding a type annotation for multiply?
10:08:21 <ajcc> shapr: #haskell.se
10:10:05 <conal> ClaudiusMaximus: adding {-# OPTIONS -farrows -fno-monomorphism-restriction #-} does let compilation go through
10:10:16 <ClaudiusMaximus> conal: with the flag it loads fine, with ((*)::Double->Double->Double) it still gives the error
10:12:06 <conal> ClaudiusMaximus: sure. because of the monomorphism restriction on.  the problem is a & b
10:13:14 <ClaudiusMaximus> ah. i'm just not sure exactly what it is that makes it unhappy, or what exactly an explicit type signature is
10:14:11 <conal> ClaudiusMaximus: multiply :: (Arrow b, Arrow a) => b (a Double Double, a Double Double) (a Double Double)
10:14:34 <ClaudiusMaximus> conal: so i need to fix 'w' to a concrete type?
10:16:24 <conal> ClaudiusMaximus: no.  give an explicit polymorphic type, with required class constraints
10:16:47 <soothsayer> Is there an NNTP module?
10:17:34 <conal> ClaudiusMaximus: sometimes it's hard to figure out the type.  (that's why we like type inference.)  so here's a trick: add  -fno-monomorphism-restriction.  then ask ghci what type it got.  then put that type in your code and remove  -fno-monomorphism-restriction.
10:18:43 <ClaudiusMaximus> aha, that worked -- multiply :: (Arrow b, Arrow a, Num x) => b (a w x, a w x) (a w x)
10:19:29 <conal> what i got also, but with the constraints reversed.
10:20:05 <ClaudiusMaximus> that seems odd, if ghci can figure it out with the flag, and that type works without the flag, why doesn't it "just work"?
10:21:55 <shapr> ajcc: Ok, I'm on #haskell.se
10:22:17 <ari> ClaudiusMaximus: "That seems odd" seems to be what people generally think of the monomorphism restriction
10:24:05 * shapr boings furiously
10:24:13 <dolio> Yes, but if there were no monomorphism restriction, they'd probably also think it's odd when they write 'primes = ...' and it gets recomputed every time they use it.
10:24:29 <conal> ClaudiusMaximus: it could just work.  i think the concern is that people expect simple defs like that to be evaluated once. but if polymorphic, they're really implicit function applications.
10:25:26 <conal> ClaudiusMaximus: if you want visual simplicity at the cost of that hidden computation, then you use   -fno-monomorphism-restriction.
10:27:29 <ClaudiusMaximus> conal: sure, i know vaguelly why the restriction exists, but i think ghci could suggest the explicit type signature that it demands
10:28:07 <conal> ClaudiusMaximus: hey -- that sounds like a great idea to me.  how about suggesting it to the ghc folks?
10:29:22 <OceanSpray> #ghc
10:30:53 <glguy> Does anyone happen to know a good program where I could easily define buttons to run common tasks?
10:31:19 <glguy> say I run: sudo apt-get update all the time, I could easily add a link to a list of buttons
10:31:40 <shapr> glguy: What about using cron-apt ?
10:31:47 <glguy> or maybe today I'm going to be restarting some daemon a lot in the next view days
10:31:54 <glguy> shapr: that was just one example
10:31:57 <shapr> I usually make a shell alies.
10:31:59 <shapr> alias*
10:32:17 <glguy> hmm..
10:32:28 <soothsayer> You can add a button to the panel
10:32:37 <Gwern-away> conal: I once suggested that, but for ghc regular
10:32:43 <shapr> ubiquitous automation, as mentioned in tPP
10:32:49 <OceanSpray> Breckinridge, Bell, Douglas and Lincoln
10:32:57 <Gwern-away> so far as I know, that bug report is rotting away as a 'nice idea but no one's bothered to do anything on it'
10:33:26 * glguy needs some kind of lightweight "panel"
10:33:43 <glguy> right now all I really have installed for X11 apps is urxvt
10:34:06 <shapr> glguy: Can you integrate the daemon restart into your build process?
10:34:28 <glguy> shapr: its not just daemons I'm interested in though, I'd like to do it for arbitrary commands
10:34:36 <shapr> For example, I've customized F12 in cabal-mode in emacs to do configure, build, and install --user
10:37:05 <shapr> glguy: How about making xmonad key bindings that call shell commands?
10:39:00 <glguy> shapr: that would be great if it didn't require me to edit a file, recompile and restart xmonad :-p
10:39:36 <glguy> some kind of panel would be perfect if I could just click on it and add things
10:39:42 <glguy> and just clikc to remove them
10:41:15 <shapr> You could automate your xmonad recompile and restart into one xmonad command? :-)
10:41:18 <roconnor> is PFP cabalized?
10:43:29 <shapr> What's PFP?
10:44:16 <doserj> http://web.engr.oregonstate.edu/~erwig/pfp/
10:44:17 <lambdabot> Title: PFP - Probabilistic Functional Programming in Haskell
10:45:35 <hpaste>  xerox pasted "parsec fun - take 2" at http://hpaste.org/2300
10:45:41 <xerox> yay :)
10:46:14 <shapr> yay!
10:53:04 <OceanSpray> Can I use >>= to pipe something into a case <something> of ... expression?
10:54:20 <OceanSpray> or do I have to use do or a lambda?
10:54:41 <bos> OceanSpray: you can, but only if the right-hand-sides of your cases are monadic actions
10:55:17 <OceanSpray> bos, and how would I do that?
10:55:31 <byorgey> OceanSpray: in other words, if each of the things to the right of the ->'s in the case could be put after >>=, then so can the whole case
10:55:51 <bos> case foo of x -> return x
10:56:40 <byorgey> > Just 3 >>= \x -> (case x of 2 -> Nothing; 3 -> return 5)
10:56:42 <lambdabot>  Just 5
10:57:54 <byorgey> OceanSpray: but remember, anything to the right of >>= must be a function, which is why I had to add the \x -> part
10:58:09 <byorgey> @type (>>=)
10:58:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:58:33 <tonfa> @type \x -> (case x of 2 -> Nothing; 3 -> return 5)
10:58:35 <lambdabot> forall t a. (Num t, Num a) => t -> Maybe a
10:59:16 <Runaro^BRS> @pl \x -> (case x of 2 -> Nothing; 3 -> return 5)
10:59:16 <lambdabot> (line 1, column 20):
10:59:16 <lambdabot> unexpected ">"
10:59:16 <lambdabot> expecting variable, "(", operator or ")"
10:59:36 <roconnor> @type toDouble
10:59:38 <lambdabot> Not in scope: `toDouble'
11:02:30 <roconnor> @tyoe log
11:02:32 <lambdabot> forall a. (Floating a) => a -> a
11:02:32 <roconnor> @type log
11:02:34 <lambdabot> forall a. (Floating a) => a -> a
11:03:58 <iguana_> hi
11:04:24 <iguana_> I want to interpret a simple stack-based minilanguage
11:04:25 <byorgey> hi iguana_
11:04:37 <iguana_> so I'm using many functions that pass stacks around
11:05:04 <iguana_> but this feels quite verbose
11:05:12 <iguana_> isn't there some better solution for that?
11:05:21 <byorgey> iguana_: sounds like a job for a State monad.
11:05:32 <iguana_> argh, a monad :)
11:05:34 <iguana_> I feared that
11:05:45 <byorgey> that will let you hide the "plumbing" of passing the stacks around, you'll just have it for free whenever you need it
11:05:58 <byorgey> iguana_: it's not that bad, don't worry =)
11:06:02 <iguana_> heh
11:06:16 <iguana_> ok, where do I read about the state monad?
11:06:18 <byorgey> @info State
11:06:18 <lambdabot> (State)
11:06:22 <iguana_> is there a kind of recipe?
11:06:28 <Cale> ftp://ftp.inria.fr/INRIA/publication/publi-pdf/RR/RR-3088.pdf -- ahaha, look at the second author of this paper :)
11:06:39 <byorgey> iguana_: hang on, let me see if I can find you some good references/tutorials
11:06:47 <iguana_> cool, thanks
11:07:54 <byorgey> Cale: hehe
11:08:12 <mrd> hey glguy
11:08:31 <mrd> how goes your state monad adventures
11:08:50 <shapr> iguana_: I like http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
11:08:54 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
11:12:31 <shapr> iguana_: If that's not your style, what about http://www.haskell.org/haskellwiki/Monads_as_containers ?
11:12:33 <lambdabot> Title: Monads as containers - HaskellWiki
11:12:59 <byorgey> iguana_: I think Cale's recent presentation of monads is excellent: http://haskell.org/haskellwiki/Monads_as_computation
11:13:00 <lambdabot> Title: Monads as computation - HaskellWiki
11:13:23 <glen_quagmire> is haskell Rapid Application Development?
11:13:29 <byorgey> iguana_: the monads as containers is good too.
11:13:45 * iguana_ goes reading
11:14:02 <dolio> @protontorpedo
11:14:03 <lambdabot> so haskell is new and improved c?
11:14:12 <glen_quagmire> @rad
11:14:12 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
11:14:21 <roconnor> @type fromRational . toRational
11:14:30 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
11:14:37 <byorgey> iguana_: in a minute I will also post an example of using the State monad for the sort of thing you want to do, so you can have something to look at
11:14:44 <iguana_> cool
11:15:01 <shapr> glen_quagmire: It's a lot faster than debugging C, is that what you're asking?
11:15:41 <dolio> I thought rapid application development involved drawing GUIs Visual Basic style and such.
11:15:45 <glen_quagmire> i wanted to compare development speed with python/ruby
11:16:25 <shapr> glen_quagmire: Well, try it.
11:17:05 <shapr> glen_quagmire: For the most part, python and ruby have slightly more libraries for common tasks, and that'll be the biggest difference.
11:17:32 <shapr> But in cases where libraries already exist on both sides, I'd bet on Haskell being faster to develop.
11:17:43 <shapr> Of course, I'm biased because I have a full-time job writing Haskell...
11:17:57 <roconnor> shapr: who do you work for?
11:18:09 <shapr> I work for HAppS LLC - http://happs.org/
11:18:12 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8.8 )
11:18:24 <roconnor> HAppS is a company?
11:18:30 <glguy> word
11:18:31 <roconnor> I thought it was just a library.
11:18:32 <shapr> HAppS LLC is owned by alexj
11:18:55 <lament> happs.org certainly doesn't look like a corporate site :)
11:18:56 <shapr> He's the driving force behind all the cool code in HAppS.
11:19:11 <shapr> lament: Well, I certainly don't look like a corporate programmer!
11:19:15 <roconnor> glguy: btw, I annotated your state monad proof with some advanced coq features.
11:19:17 <shapr> Still gotta eat though.
11:19:32 <glguy> roconnor: thanks, I'll investigate
11:19:44 <roconnor> glguy: not that I expect a beginner to write that, but I wanted to show you what you have to look forward too.
11:20:02 <roconnor> glguy: particularly that implicit arguments can get very confusing.
11:20:10 <glen_quagmire> shapr: i see. I think a good IDE will change everything
11:20:16 <roconnor> glguy: explict arguments are much more clear for beginners.
11:20:32 <glguy> roconnor: feq is function equality?
11:20:38 <glen_quagmire> even development speed in Java can be increased a lot using a descent IDE
11:20:40 <shapr> I'm not convinced that IDEs are a big factor in programming speed. But I do use emacs, and my work is thoroughly automated.
11:20:58 <glguy> ViM is my "IDE"
11:21:04 <glguy> ^N is all the auto complete I need
11:21:11 <fxr> @karma+ shapr
11:21:12 <lambdabot> shapr's karma raised to 38.
11:21:12 <lament> the part of "IDE" that seems the most useful is some kind of a visual namespace browser
11:21:18 <glguy> ?karma
11:21:18 <lambdabot> You have a karma of 47
11:21:21 <glguy> whoo
11:21:26 <glen_quagmire> i'm such a tool. i care for IDE mostly
11:21:34 <glen_quagmire> ?karma
11:21:34 <lambdabot> You have a karma of 0
11:21:38 <ihope_> runCtnrT (fail "foo") :: (Monad (CtnrT c m), Monad m, Container c) => m (c a)
11:21:41 <roconnor> glguy: that's the idea.
11:21:51 <glguy> IDE is a crutch for .NET development, for example
11:21:55 <ihope_> CtnrT c m is always an instance of Monad.
11:22:06 <glguy> the programmer comes to depend on it for knowing what methods to use
11:22:19 <lament> um
11:22:29 <glen_quagmire> for IDE, i meant, code completion, document tultip, integrated debugger...
11:22:29 <lament> it's always good to have a nice easy-to-access reference.
11:22:44 <pjd> glguy: not least because there's usually too much for any human to remember, in that kind of environment
11:22:58 <lament> pjd: in _any_ kind of environment.
11:23:09 <byorgey> iguana_: actually, for implementing a language, you will probably want to end up using monad transformers: you really must read http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
11:23:11 <lambdabot> Title: Monad Transformers Step by Step
11:23:19 <lament> Haskell Hierarchical Libraries are already too much to remember, and i usually have them open in a browser when trying to program something
11:23:20 <glguy> I suppose, but I still think that it's better to internalize as much as possible, and the pervasive auto complete stunts that
11:23:20 <byorgey> iguana_: it's excellent, easy to follow, with great examples
11:23:38 <ihope_> I also have "data (Container c, Monad m) => CtnrT c m a" and "instance (Container c, Monad m) => Monad (CtnrT c m)". Is there any way to remove the "(Container c, Monad m) =>" bit from the instance declaration?
11:23:40 <lament> and an IDE is much more convenient than switching between the editor and the browser
11:24:52 <laz0r> hi #haskell... i have a little problem
11:24:57 <laz0r> im going to paste it
11:25:02 <glguy> roconnor: so the implicit arguments make it unnecessary to pass the types of bind and ret around?
11:25:03 <hpaste>  laz0r pasted "oh noes, what can i do?" at http://hpaste.org/2301
11:25:14 <laz0r> now, i have no idea what is actually wrong
11:25:34 <laz0r> i would be glad if someone could point to what i am doing wrong therew
11:25:37 <lament> glguy: also, even when you remember that a function is called someReallyLongFunctionName, it's still way more convenient to be able to autocomplete it than not to be.
11:25:38 <byorgey> iguana_: there's a lot to learn, but just take your time and enjoy it =)
11:26:01 <glguy> lament: yeah, vim does that with ^N
11:26:12 <iguana_> I'm reading the Wiki page currently, I think it explains it very well
11:26:33 <pjd> lament: one approach is to avoid someReallyLongFunctionNames
11:26:44 * pjd ducks
11:26:52 <lament> pjd: did you just autocomplete my nick when you typed that?
11:26:56 <glguy> lament: I think that autocomplete is also more useful in OO, where once you've typed "string". the autocomplete know syou need methods on strings
11:27:02 <Cale> laz0r: score is supposed to be completely polymorphic in the type of ParseTreeNode
11:27:29 <roconnor> glguy: that's right.  It makes that and the =f make the monad laws look like you expect.
11:27:30 <mrd> glguy: how did you work around extensional equality
11:27:32 <Cale> laz0r: that is, forall m a. (MarkovModel m) => m -> ParseTreeNode a -> (Probability,Probability)
11:27:35 <lament> glguy: that's why you have lots of modules, and import them qualified
11:28:01 <lament> glguy: and have smart completion that looks through imported modules (yeah, vim already has that, although it's buggy at times)
11:28:02 <Cale> laz0r: but scoreSCFG ::  SCFGData a -> ParseTreeNode a -> (Probability,Probability)
11:28:16 <glguy> mrd: I talked to roconnor
11:28:22 <Cale> The a's are the same there, but they're not supposed to be, according to the type of score.
11:28:22 <glguy> mrd: and he worked around it
11:28:33 <mrd> the setoid thing?
11:28:50 <glguy> http://hpaste.org/2295#a5
11:29:28 <byorgey> Cale: would it work to add a to the class declaration (i.e. class MarkovModel m a where ...) ?
11:29:49 <roconnor> well bluestorm, suggested passing in a state parameter in the equations.
11:29:54 <Cale> Yeah, or else make m in the class declaration into a type constructor
11:30:16 <roconnor> all I did was show how to destruct a pair in coq.
11:30:19 <hpaste>  Cale annotated "oh noes, what can i do?" with "one thing you could try" at http://hpaste.org/2301#a1
11:30:31 <byorgey> Cale: oh, I see, so MarkovModel m where score :: m a -> ParseTreeNode a ...  like that?
11:30:42 <Cale> yeah, like the paste
11:31:06 <byorgey> Cale: ah, ok, that's definitely the better solution
11:31:20 <Cale> er, also, the instance there is strangely indented
11:31:24 <mrd> you've defined your own equality
11:31:34 <byorgey> just trying to increase my understanding of these sorts of things... =)
11:31:44 <shapr> glen_quagmire: Well, you can get much of that from emacs.
11:33:11 <laz0r> Cale, oops, yes it is, but thats a minor problem...
11:33:25 <shapr> glen_quagmire: For example, I use hippie-expand in emacs to do code completion. I use TAGS to jump to definitions of types/functions/etc. I have a one button compile && unit test definition, etc.
11:33:32 <Cale> yeah :)
11:34:13 <laz0r> Cale, im trying to make sense of what you said, but i'm failing at it... what could i read to gain greater insight in this?
11:34:21 <shapr> I also use emacs for irc, email/usenet, calculator, time tracker, and lots of other stuff.
11:34:40 <Cale> laz0r: okay, let me give you an example...
11:35:30 <Cale> According to the type of score, I can apply it for any MarkovModel m and any type a
11:35:35 <Cale> So for example...
11:35:59 <Cale> score :: SCFGData String -> ParseTreeNode Integer -> (Probability,Probability)
11:36:26 <Cale> However, the instance you've written apparently doesn't provide for this possibility
11:36:36 <laz0r> Cale, ok, i see, that would be a problem
11:37:18 <laz0r> Cale, i must ensure somehow that those a's are always the same
11:37:21 <Cale> right
11:37:28 <jedai> @src scanl1
11:37:28 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
11:37:28 <lambdabot> scanl1 _ []     =  []
11:37:33 <Cale> in order to do that, you can do what I did in my paste
11:37:38 <glguy> roconnor: what does "@ret"  mean
11:37:40 <jedai> @src scanl
11:37:40 <lambdabot> scanl f q ls = q : case ls of
11:37:40 <lambdabot>     []   -> []
11:37:40 <lambdabot>     x:xs -> scanl f (f q x) xs
11:38:05 <jedai> @src scanl'
11:38:05 <lambdabot> Source not found. stty: unknown mode: doofus
11:38:05 <shapr> glen_quagmire: Have you tried emacs before?
11:38:20 <Cale> > scanl (flip (:)) [] [1,2,3,4]
11:38:22 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1]]
11:38:41 <Cale> > scanl (+) 0 [1,20,300,4000]
11:38:42 <lambdabot>  [0,1,21,321,4321]
11:38:49 <mrd> glguy: I was wondering that too =)
11:39:16 <laz0r> Cale, yes, that seems to work, although i get an error that says 'could not deduce (Eq a)' and so on... but i guess i can fix that
11:39:24 <roconnor> glguy: that is an interesting case
11:39:38 <Cale> Yeah, just add some constraints to your instance
11:39:41 <laz0r> Cale, i wonder what the 'forall thing' is for
11:39:47 <roconnor> glguy: we would normally write ret here, because we want to pass the return function
11:40:11 <roconnor> glguy: but ret has type forall A, A -> State A, rather than A -> State A.
11:40:19 <roconnor> glguy: so we cannot pass ret
11:40:27 <laz0r> Cale, what you used in your first answer that is
11:40:29 <glguy> roconnor: does "Definition feq A B (f g:A -> B) := forall a, f a = g a." say that for any two function whose type is the same, they are equivalent when applied to the same argument?
11:40:34 <roconnor> glguy: @ret is ret with the implicit arguments turned off
11:40:35 <Cale> laz0r: It just says that it works for all types a.
11:40:40 <glguy> oh
11:40:45 <roconnor> glguy: so now we can write (@ret A)
11:40:53 <Cale> laz0r: length :: forall a. [a] -> Int
11:40:57 <roconnor> glguy: which has the type A -> State A as needed.
11:41:16 <Cale> laz0r: the forall is implicit in Haskell '98, but in ghc you're allowed to put it in if you want.
11:41:55 <roconnor> glguy: feq is the definition of extensional equivalence for (first-order) functions.
11:42:10 <Cale> laz0r: This lets you write functions whose parameters are forced to be polymorphic functions:
11:42:27 <roconnor> glguy: two functions are equivalence if they when applied to the same argument they return the same results.
11:42:33 <laz0r> Cale, ah, i see, so you wouldn't use it under normal circumstances? but if you want to to tell ghc explictly that a parameter is polymorphic, you could use it?
11:42:33 <glguy> length ∷ ∀ a. [a] → Int
11:42:35 <roconnor> equivalent
11:42:41 <Cale> yeah
11:42:49 <Cale> f :: (forall a. [a] -> [a]) -> ([String], [Integer]) -> ([String], [Integer])
11:42:52 <mrd> roconnor: does feq lead to anything bad
11:42:58 <Cale> f g (x,y) = (g x, g y)
11:43:05 <laz0r> Cale, ok, thanks for making things clearer for me
11:43:17 <roconnor> mrd: it isn't an axiom.
11:43:31 <roconnor> mrd: it's just a definition of a relation.
11:43:45 <allbery_b> hehehhe
11:43:50 <ricky_clarkson> The main difference between here and #math seems to be that in #math everyone invents their own notation.  Other than that I keep getting disorientated.
11:43:54 <mrd> is this a reasonable definition to use when dealing with equivalence of haskell expressions?
11:44:02 * allbery_b has just brought up a stripped-down lambdabot over in cognet:#lopsa
11:45:05 <shapr> ricky_clarkson: You're saying #haskell is just #math with a consistent notation?
11:45:08 <mrd> the proofs look really easy with it =) suspiciously so
11:45:27 <ricky_clarkson> shapr: Not as an absolute, but yes.
11:45:30 <glguy> mrd: the proofs for State should be ;)
11:45:58 <mrd> i'm sure my list monad proofs were probably a bit longer than needed, but that should be easy too
11:46:15 <shapr> ricky_clarkson: Btw, have you written much Haskell lately?
11:46:24 <lament> yeah, #math could certainly use more consistent notation :)
11:46:28 <roconnor> mrd: It's reasonable for dealing with first order functions, but not for higher order functions.
11:46:56 <OceanSpray> whoah
11:47:06 <roconnor> mrd: nor is it reasonable for curried functions.
11:47:18 <OceanSpray> xerox, you're done with that parsec monad layer thingy?
11:47:25 <ricky_clarkson> shapr: No, just observing.
11:47:33 <shapr> ok
11:47:36 <Cale> ricky_clarkson: and with a whole lot less analysis and way more formal logic :)
11:48:00 <xerox> OceanSpray: http://hpaste.org/2300
11:48:04 <gwern> anyone here know much about Template Haskell? I am curious as to whether it can take a function which can vary at compile time, and disallow IO. (This is a continuation of my quest for a sandbox - hs-plugins is how one can do it at runtime, but can Template haskell do it at compile time?)
11:48:07 <ricky_clarkson> shapr: I'm planning on implementing a pluggable type system for some dynamic language or other.
11:48:15 <shapr> ricky_clarkson: Sounds like fun.
11:49:03 <lament> pluggable type system?
11:49:08 <shapr> Have you read Types and Programming Languages?
11:49:15 <OceanSpray> xerox, mmyeah
11:49:17 <xerox> OceanSpray: actually it got better in the last hours :)
11:49:24 <OceanSpray> hmm
11:49:25 <ricky_clarkson> No, though dibblego has referred me to it a couple of times.
11:49:41 <lament> ricky_clarkson: ever heard about dogs, stapled legs and octopuses? :)
11:49:46 <OceanSpray> now I stand on a crossroads.
11:49:49 <shapr> I've often wondered about a language that would be able to specify different type systems for different chunks of the program.
11:49:56 <ricky_clarkson> I don't think it's freely available, and it certainly isn't in my bookshops - I'll take a look in a library before buying it.
11:50:03 <OceanSpray> I could go on with the parameterized LispVals,
11:50:03 <lament> shapr: Lisp!
11:50:14 <timthelion> in C, one can add an attribute to a class and not have to re-write the code that uses that class, is it possible to add an attribute to a data similarly?
11:50:21 <lament> in C, there're no classes.
11:50:30 <timthelion> C++ I mean.
11:50:40 <OceanSpray> or I could wait for xerox' code and layer IO onto my parser
11:50:43 <SamB> timthelion: record syntax?
11:50:45 <ricky_clarkson> shapr: That's exactly what I'd like - though more accurately you might want to say different *notations* rather than different type systems.
11:50:46 <OceanSpray> WHAT DO I DO, #HASKELL?
11:51:38 <fxr> OceanSpray: be patient
11:51:44 <samreid> OceanSpray: use parameterized LispVals
11:52:05 <shapr> OceanSpray: When in danger or in doubt, run in circles, scream and shout?
11:52:06 <shachaf> OceanSpray: Why does IO belong in your parser?
11:52:22 <OceanSpray> I stirred up a hornet's nest here.
11:52:25 <shapr> ricky_clarkson: I'm actually thinking of some parts being dependently typed, some HM, and some having a type system like Forth.
11:52:43 * shapr buzzes around OceanSpray 
11:52:47 <OceanSpray> my parser wants IO because it needs to create mutable cons cells
11:53:02 <OceanSpray> and it just so happens that to make an IORef one has to perform an IO action.
11:53:04 <shapr> Could you parse to an AST and then pass that AST to the IO code?
11:53:13 <OceanSpray> I could
11:53:17 <OceanSpray> but I don't want to
11:53:18 <shapr> But that would be too easy?
11:53:20 <shapr> Ah, ok
11:53:23 <OceanSpray> too easy?
11:53:23 <shachaf> OceanSpray: Why does your parser create mutable cons cells?
11:53:41 <shapr> Too easy is a facetious thing I say when either I don't feel like, or I just hadn't thought of it.
11:54:05 <OceanSpray> shachaf, because it just does.
11:54:11 <OceanSpray> cons cells are mutable.
11:54:34 <shapr> You could try the separate parsing and IO code stage... and then wait for xerox' code, yeah?
11:54:37 <shachaf> OceanSpray: What's wrong with shapr's suggestion?
11:54:56 <OceanSpray> a lisp program IS an AST already
11:55:13 <samreid> xerox: regarding that paste... why is :t tokens that?
11:55:16 <shachaf> OceanSpray: No.
11:55:17 <lament> not before it's parsed
11:55:26 <shachaf> OceanSpray: A LISP program is a string.
11:55:39 <OceanSpray> ok, you know what I mean, right?
11:56:22 <ricky_clarkson> It's so easy to parse (abstract) lisp that you might as well think of it as an AST.
11:56:34 <shachaf> OceanSpray: Yes, but I don't see why parsing has to make the mutable cons cells directly.
11:56:40 <OceanSpray> It isn't
11:56:43 <OceanSpray> not right now
11:56:47 <shapr> So, why not just make it into a simple Haskell data structure and then pass that ADT to the code that does IO?
11:57:03 <xerox> samreid: because I do not need Error and Pos to implement parsec semantics now, and it's easy to go from data Error = Error to Parsec's proper error handling things.
11:57:12 <OceanSpray> that's kinda what I'm doing, except for the ADT part
11:57:12 <xerox> samreid: also, we are thinking about generalizing errors as well.
11:57:22 <samreid> ah ok
11:57:22 <gwern> this is weird... what is supposed to happen if you go 'import Something(foo)' and then later go 'import Something()'?
11:57:35 <shachaf> gwern: What do you expect?
11:57:48 <shapr> OceanSpray: Well, wouldn't that approach move IO out of your parser?
11:57:51 <gwern> shachaf: I would expect an error
11:57:54 <shachaf> gwern: I don't think the second import should do anything.
11:57:59 <OceanSpray> at sjanssen's suggestion, I parameterized LispVal with a 'wrapper' type
11:58:00 <shapr> shachaf: It imports instances
11:58:00 <shachaf> gwern: You can have multiple imports.
11:58:02 <gwern> you're forbidding an import at the same time as you ask for an import
11:58:09 <shachaf> shapr: The first doesn't?
11:58:12 <shapr> I don't know.
11:58:16 <OceanSpray> the parse creates LispVals with Id as the wrapper
11:58:18 <shachaf> gwern: That's not forbidding an import.
11:58:32 <alexj> is there a bad interaction between deriving Data and existentials?
11:58:43 <OceanSpray> then there's a function -> IO LispVal IORef that takes those LispVal Id's
11:58:48 <shachaf> gwern: It's saying "import the file, but no functions/types from it.".
11:58:56 <gwern> shachaf: but doesn't for example 'import Prelude()' forbid the importing of prelude definitions and allow you to use their names?
11:58:57 <OceanSpray> thus, IO was moved out of the parser, and I don't need no superfluous ADTs
11:59:15 <xerox> samreid: makes sense?
11:59:26 <shachaf> gwern: No.
11:59:46 <hpaste>  gleb pasted "ContT + ReaderT problem" at http://hpaste.org/2302
11:59:58 <gleb> Hello
12:00:17 <samreid> xerox: nope
12:00:20 <doserj> gwern: import statements are cumulative
12:00:48 <shachaf> gwern: You can import/import qualified the same module as many times as you like.
12:00:48 <doserj> import Prelude() is an exception, shadowing the implicit prelude import
12:00:59 <gleb> I'm having trouble storing polymorphic continuation in the ReaderT (please see the link above)
12:01:27 <shachaf> You can also use -fno-implicit-prelude if you prefer not importing Prelude.
12:01:37 <gwern> hm. so there is no way to 'forbid' importing from somewhere using the import mechanism?
12:01:43 <xerox> samreid: token just matches the list of tokens, it doesn't adjust the position in the state with the function it takes as argument, and neither does show the token with the other function it gets as argument for error message purposes.  I simplified things so to get the framework running, adding those two things back is really easy.
12:02:01 <shachaf> gwern: Not that I know of.
12:02:05 <shachaf> gwern: Why?
12:02:56 <gwern> shachaf: well, if there was, I could use template haskell to take arbitrary code at compile time and add in that import declaration to avoid importing IO and unsafe functions
12:03:05 <samreid> xerox: ok.  I just don't like breaking backwards compatibility (even though I find tokens and tokenPrim and tokenPrimEx to be ugly myself), but if you add them back :)
12:03:19 <gwern> but that import declaration doesn't exist, apparently, and so I must think of a different method
12:03:34 <OceanSpray> so xerox, do you have any documentation?
12:03:35 <xerox> samreid: I am working with drop-in backwards compatibility in mind from day 1.
12:03:40 <shapr> alexj: Are you getting a specific error?
12:03:51 <byorgey> gleb: what's the problem?
12:03:54 <alexj> yeah, can't derive Data for IxSet.
12:04:11 * shapr looks
12:04:32 <gleb> byorgey: I'm playing with ICFP 2007 contest task
12:04:36 <xerox> samreid: now I hit a no-monomorphism-restriction thing which would break the drop-in compatibility, but I'm probably just too tired now to figure out some solution that doesn't require it. Althought it doesn't look simple at all.
12:04:53 <byorgey> gleb: ok, I mean, what problem are you having?
12:05:37 <gleb>  byorgey: I'm trying to store the outer continuation to implement 'finish' operator, but the code pasted at http://hpaste.org/2302 is rejected by ghc
12:05:50 <gleb>     Couldn't match expected type `forall b. Inner r b'
12:05:50 <gleb>     against inferred type `Inner r b'
12:07:52 <byorgey> gleb: hm... I'm still shaky on existential types, perhaps someone else will have a look
12:08:55 <gleb> byorgey: thanks for trying to help
12:09:16 <ihope_> gleb: sounds like the value you gave is Inner applied to two specific types, while in order to fit it must work for all types.
12:09:47 <gleb> ihope_: exactly
12:10:05 <gleb> ihope_: i just don't know how to fix the code i pasted
12:11:18 <ihope_> ContT r IO? Doesn't ContT require three arguments?
12:11:28 <ihope_> @kind Control.Monad.Cont.ContT
12:11:30 <lambdabot> * -> (* -> *) -> * -> *
12:11:52 <gleb> ihope_: well I omitted the last a
12:12:16 <eivuokko> Where does the IO monad go in runM?
12:12:21 <byorgey> ihope_: of course, that could be parenthesized  * -> (* -> *) -> (* -> *)
12:12:44 <ihope_> I thought the right side of a type statement had to be of kind *.
12:13:04 <samreid> xerox: http://hpaste.org/2300#a1  -- gj with yours
12:13:20 <shachaf> ihope_: Of type aliases? No.
12:13:32 <shachaf> ihope_; Types are curried.
12:14:04 <xerox> samreid: liftliftlift?
12:14:23 <samreid> hehehe
12:14:33 <xerox> Now that's weird :-)
12:14:44 <gleb> eivuokko:  runM accepts m, which is action that can perform I/O
12:14:54 <ihope_> Is there no lift3 or anything?
12:15:04 <samreid> xerox: type GenParserT tok st m a = ParseT (SaveStateT st tok (ListStreamT tok m)) a .... have fun
12:15:29 <gleb> hope_: pardon?
12:15:47 <ihope_> lift3 instead of lift . lift . lift
12:16:16 <gleb> ihope_: ah. i don't know
12:16:32 <samreid> ihope_: lift is preferable to lift3 :)
12:16:49 <ihope_> lift instead of lift . lift . lift?
12:17:20 <samreid> no, not needing lift . lift . lift at all
12:17:26 <samreid> liftIO works...
12:17:32 * ihope_ nods
12:18:18 <gleb> samreid: well, my example is simplified essence of the problem, in reality there's ST, not IO. Is there liftST anywhere?
12:18:50 <shachaf> @wiki New monads/MonadBase
12:18:51 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadBase
12:19:15 <samreid> gleb: you could implement it, it's not magic
12:19:36 <gleb> shachaf: thanks, that looks interesting
12:20:29 <gleb> samreid: I believe so. But this unfortunately doesn't help with the main problem - keeping global continuation in the ReaderT
12:21:47 <samreid> gleb: huh?  /me scrolls up?
12:21:55 <hpaste>  Japsu pasted "MyIO" at http://hpaste.org/2303
12:24:41 <samreid> gleb: your problem is that your types are out of whack
12:25:11 <gleb> samreid: I guess so :)
12:25:14 <cognominal> on a paper on zippers : there is data Tree e a = a :< Trunk e (Tree e a)
12:25:16 <samreid> gleb: it's your (forall b. Inner r b) that's the probelm
12:25:31 <cognominal> what is the :< ?
12:25:37 <kpreid> cognominal: it's a constructor name
12:25:39 <samreid> gleb: you want a monad that produces a return value of whatever type you demand of it
12:25:51 <kpreid> cognominal: : is uppercase punctuation
12:26:11 <cognominal> where is it documented?
12:26:30 <samreid> gleb: that means your monad must have a return value of _|_.
12:26:34 <gleb> samreid: the idea was to have computations that can be interrupet
12:26:52 <gleb> samreid: sorry for typo, interrupted
12:26:58 <kpreid> cognominal: http://www.haskell.org/onlinereport/decls.html 4.2.1, "infix conop"
12:26:59 <lambdabot> Title: The Haskell 98 Report: Declarations
12:27:11 <cognominal> thx
12:27:16 <monochrom> Students should not shy away from reading the reference manual.
12:27:21 <samreid> gleb: ok, hrmm... let me think...
12:27:33 <gleb>  samreid: I think there's several ways to do it, but it was interesting to implement it using continuations
12:28:20 <gleb> samreid: I need 'finish' operator, that never returns (since it aborts computation), hence has polymorphic return type
12:29:02 <samreid> gleb: then why not make the return type ()?
12:29:20 <doserj> gleb: if you replace the ($) operators, and remove the type signature, your code actually typechecks :)
12:29:35 <doserj> (but of course has a different type than you want)
12:30:18 <gleb> samreid: because it should work in contexts like  do { x <- if False then finish else return 1; y <- if True then finish else return []; return (x,y) }
12:30:42 <gleb> doserj: :) yes, that's the problem
12:31:48 <gleb> doserj: when I remove type signature, my definition finish = do { k <- ask; lift k } doesn't do what I want
12:32:12 <monochrom> finish needs a very polymorphic type.
12:32:46 <shapr> Anyone here clueful with Data.Generics?
12:33:12 <gleb> monochrom: is it impossible to define in Haskell using ContT + ReaderT monad? I thought it's pretty basic task for continuations
12:33:27 <dolio> gleb: The type of callCC isn't as polymorphic as it could be. Maybe that's the problem.
12:33:43 <shapr> How do I make a Data instance for a type with "forall foo ." in the datatype?
12:34:23 <hpaste>  shapr pasted "This Data instance doesn't work, and I don't understand the error!" at http://hpaste.org/2304
12:34:33 <monochrom> It is possible. Some trick required.
12:35:12 <gleb> dolio: I guess it has something to do with always monomorphic lambda-bound variables. There must be some workaround
12:36:12 <dolio> @wiki MonadCont done right
12:36:12 <lambdabot> http://www.haskell.org/haskellwiki/MonadCont_done_right
12:36:57 <monochrom> See if  http://www.vex.net/~trebla/tmp/ContMonad.lhs  gives you ideas.
12:37:43 <gleb> dolio, monochrom: wow, thanks. now i have food for thought
12:38:26 <monochrom> I use ReaderT over Cont to implement nestable try-catch.  One issue concerns polymorphism and I work around that by "return undefined". :)  Another issue concerns infinite type and I use a newtype.
12:40:14 <gleb> monochrom: do you have an example?
12:40:33 <monochrom> It's at the end.
12:41:27 <gleb> monochrom: ok, thank you very much, must read links carefully before further questions
12:42:19 <conal> shapr: you might be interested in the current #haskell-blah chat (nvc)
12:44:14 <conal> is #haskell-blah archived?
12:45:09 <byorgey> conal: I don't think so
12:45:28 <conal> byorgey: thanks. oh well.
12:49:38 <shapr> conal: I think it's specifically not archived.
12:52:30 <roconnor> hmm, I've rewritten and simplified my portfolio optimizer, but now I'm getting different results.
12:53:34 <dino-> conal: If you'e been in there, maybe your client can dump history. Like irssi can /lastlog -file <file>
12:53:57 <OceanSpray> ok, something's weird.
12:54:13 <conal> dino-: thanks.
12:54:34 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/2305
12:55:10 <OceanSpray> I'm getting Primitives.hs:77:35:    Kind mis-match
12:55:10 <OceanSpray>     Expected kind `* -> *', but `LispRet w' has kind `*'
12:55:35 <byorgey> OceanSpray: do you know what a kind is?
12:55:39 <OceanSpray> no.
12:56:19 <byorgey> it's sort of a "higher-order type": kind is to type as type is to value.
12:56:35 <byorgey> things like Int, Char, Maybe Bool, etc -- normal values -- have kind *.
12:56:35 <conal> okay -- see http://conal.net/misc/haskell-blah-nvc.html
12:56:36 <lambdabot> Title:
12:56:44 <OceanSpray> ok
12:57:09 <byorgey> "Maybe" (by itself) has kind * -> *, because it must be applied to something else of kind * to produce a concrete type.
12:57:19 <byorgey> So Maybe :: * -> *, but Maybe Int :: *.
12:57:37 <OceanSpray> oh
12:57:46 <OceanSpray> so what should the signature be?
12:57:47 <byorgey> So in your code, LispRet :: * -> *, but LispRet w :: *.
12:58:14 <roconnor> ah, found an error
12:58:21 <roconnor> now they are much closer to the same value.
12:58:44 <byorgey> OceanSpray: how is LispErrT defined?
12:58:45 <roconnor> still differ by 0.05
12:59:35 <OceanSpray> type LispErrT r = ErrorT (LispErr r) IO
12:59:45 <OceanSpray> ...
12:59:48 <OceanSpray> oh goddamn
12:59:58 <shapr> Hey, this is a family channel!
13:00:07 <monochrom> bloody hell :)
13:00:17 <roconnor> ah found another small error
13:00:21 <roconnor> now they differ by 0.0001
13:00:38 <roconnor> now we are getting into the relm of floating point error.
13:00:45 <byorgey> OceanSpray: ok, so LispErrT has kind * -> * -> *
13:01:03 <byorgey> OceanSpray: keeping track of kinds when dealing with monad transformers can get confusing at times
13:02:23 <byorgey> OceanSpray: what type should errors have?  i.e. what should the "r" be in LispErr r?
13:05:01 <Cale> byorgey: that's not the error type
13:05:34 <Cale> His syntax trees are parametrised over a container type which is typically IORef or Id
13:05:41 <roconnor> It's kinda comforting knowing that my simpler program agrees with my previous one.  All that complexity actually worked.
13:06:43 <byorgey> Cale: ah
13:07:18 <glguy> so if we know that ListT in the mtl is not a Monad, why is it still in mtl broken?
13:07:24 <byorgey> roconnor: that's a nice feeling =)
13:08:17 <roconnor> I just want to say again that automatic differention totally rocks
13:08:41 <HWSOD> hey are there any monads that represnt a state that cant change with in the monad?  I can just use the 'State' monad and not use 'put' but i would rather not.
13:08:49 <glguy> HWSOD: Reader
13:08:56 <byorgey> HWSOD: Reader
13:08:58 <HWSOD> Thanks!
13:08:59 <roconnor> I can just write (f `optimizeNear` 0) and it finds via newton's method a local maxium of f.
13:09:06 * byorgey high-fives glguy
13:09:07 <mrd> Reader
13:09:16 <mrd> oops, I'm stuck in the 10 seconds-to-late Monad
13:09:38 * glguy passes the high-five to mrd
13:09:59 <roconnor> @stereo
13:09:59 <lambdabot> Unknown command, try @list
13:10:15 <mehrheit> @quote stereo
13:10:15 <lambdabot> No quotes match. I've seen penguins that can type better than that.
13:10:17 <glguy> Cale had that quote deleted
13:10:30 <mrd> someone re-added it anonymized
13:10:33 <mrd> or i thought
13:10:38 <Cale> @stereo
13:10:38 <lambdabot> Unknown command, try @list
13:10:41 <glguy> and it was deleted again I think
13:10:43 <byorgey> roconnor: that's neat.  got any code to share?
13:10:44 <Cale> heh
13:10:53 <Cale> The anonymous one is okay :)
13:10:58 <roconnor> byorgey: I will.  I'm working on a blog post.
13:11:02 <glguy> I went through the logs earlier to figure out what happened
13:11:04 <byorgey> roconnor: awesome.
13:11:09 <roconnor> byorgey: May take a few more days.
13:11:13 <glguy> it was coming and going and readded and removed and now its gone
13:11:16 <byorgey> roconnor: no rush =)
13:11:57 <roconnor> byorgey: portfolio optimization in 62 lines.  (thanks to existing libraries).
13:12:14 <glguy> when two people give the same answer like that... hpaste could be configured to print the quote automatically ;)
13:13:01 * byorgey looks forward to finding out what "portfolio optimization" is
13:13:18 <byorgey> stock portfolio?
13:14:09 <roconnor> byorgey: more or less.
13:14:48 <roconnor> byorgey: it's an implementation of the Kelly critereon from my latest entry.
13:14:59 <roconnor> byorgey: I will give a more sophisticated example.
13:15:17 <byorgey> ah yes, I remember reading that =)
13:15:35 <roconnor> byorgey: oooh, did you guess an amount to bet?
13:15:45 <byorgey> roconnor: yes, I guessed too high =P
13:15:48 <roconnor> I wonder if people are actually filling in my field.
13:15:53 <roconnor> \o/
13:15:59 <byorgey> field?
13:16:12 <roconnor> I figured giving an HTML field would motivate people to really guess.
13:16:54 <byorgey> hmm, I don't recall seeing a field, I just saw "guess before you keep reading" and I always try to honor such requests =)
13:16:55 <monochrom> glguy: I would rather the bot to notice three people answering and give "Warning: Too many chefs".
13:16:56 <roconnor> byorgey: my post has a ``I would bet _____ %'' slot.
13:17:10 <roconnor> byorgey: but if you guessed without writing it down, that's still good.
13:17:17 <roconnor> byorgey: what did you guess?
13:17:20 <byorgey> roconnor: I think I guessed 10%.
13:17:37 <byorgey> roconnor: I didn't think about it very long, of course =)
13:17:39 <roconnor> byorgey: yeah, that's a common answer.  It seems like such a nice amount.
13:17:51 <roconnor> I'm still blown away that it is too high.
13:17:57 <byorgey> yeah, it does
13:19:15 <byorgey> well, I'll look forward to reading your next blog article.
13:22:25 <midfield> @seen dons
13:22:25 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 12h 49m 42s ago.
13:22:37 <SamB> Cale: were you just annoyed that the quote kept making you sneeze?
13:23:29 <Cale> SamB: I like to have my IRC client notify me when someone says my name.
13:24:01 <SamB> ... yeah, I actually meant that ;-P
13:24:29 <SamB> I was referring to the superstition that you sneeze when people are talking about you
13:25:50 <Runaro^BRS> I wonder what you do when people are drawing naughty pictures of you.
13:26:37 <Runaro^BRS> @seen osfameron
13:26:37 <lambdabot> osfameron is in #haskell-blah and #haskell. I last heard osfameron speak 1d 3h 56m 33s ago.
13:27:37 <glguy> Cale: do you use a client that could /ignore that specific quote?
13:27:54 <glguy> (not a problem now, sure, but might not have been one earlier either)
13:28:03 <Cale> actually, I might be able to get it to not highlight when lambdabot uses my name
13:28:08 <Cale> > "Cale"
13:28:11 <lambdabot>  "Cale"
13:28:23 <Cale> > "Cale"
13:28:25 <lambdabot>  "Cale"
13:28:27 <glguy> @quote Cale
13:28:27 <lambdabot> Cale says: interact is the one true way to write unix programs in Haskell :)
13:28:28 <Cale> aha, okay
13:28:40 <Cale> @quote Cale
13:28:40 <lambdabot> Cale says: I think we should take 0=1. Then 0 is invertible
13:28:50 <Cale> okay, that seems all right :)
13:28:58 <glguy> hurray for irssi
13:29:04 <glguy> ?
13:29:05 <glguy> :)
13:29:13 <Cale> X-Chat
13:29:19 <glguy> well, nevermind then
13:29:39 <Cale> There's a textbox "Nicks not to highlight on" which possibly wasn't in earlier versions
13:32:24 <monochrom> The bot could just say ".... stereo!" without mentioning Cale at all.
13:33:00 <mrd> perhaps a plugin which recognizes when two people say the same thing nearly simultaneously
13:33:23 <SamB> mrd: that'd be annoying...
13:33:38 <SamB> well.
13:33:43 <mrd> how often does it happen?
13:33:47 <SamB> I suppose there's no reason to say that to you specifically...
13:33:57 <SamB> do you count punctuation and initial caps?
13:34:19 <mrd> details details
13:34:49 <monochrom> I like "Warning: Too many chefs" more.
13:34:53 <conal> there was a chat on #ghc that may interest people.  It's about automatic linking of web-based cross-package haddock docs: http://conal.net/misc/2007-08-17-ghc.html.  i'd love to get some more discussion going, toward a solution.
13:34:54 <lambdabot> Title: #ghc
13:35:23 <glguy> monochrom: I don't think that its good to try to discourage people from answering questions
13:35:39 <monochrom> It's all about checks and balances.
13:35:48 <glguy> yeah, that's a place I don't want a check on
13:36:03 * shapr agrees with glguy
13:36:31 <monochrom> There are two equally important factors that make a fission nuclear reactor work productively and non-destructively.
13:36:55 <shapr> I still agree with glguy.
13:37:40 <monochrom> The one I'm emphasizing and under-emphasized by this community is the graphite rods that you insert when there is "Warning: Too many chefs" and suck up some neutrons.
13:37:46 * mrd bombards monochrom with neutrons
13:38:27 <shapr> I don't think we have too many chefs.
13:39:27 <conal> and btw, i updated the haskell-blah page (nvc chat) and renamed it to  http://conal.net/misc/2007-08-17-haskell-blah.html, with a symlink from the old name.
13:39:28 <lambdabot> Title: #Haskell-blah
13:40:48 <byorgey> I think there are times when newbies get deluged with like four or five people trying to teach them at once, but I'm not sure anything is needed to counteract that specifically.
13:44:00 <samreid> Just have a designated monad explainer on duty at any time.
13:45:41 <mrd> a monad controller?
13:46:18 <monochrom> STM (MonadExplainer)
13:48:33 <Cale> A monad czar.
13:48:45 <Heffalump> you can't use STM, explaining monads to someone is side-effecting
13:48:53 <Heffalump> there's no rollback operation for brains
13:49:29 <shapr> monochrom: Has anyone complained that they're getting too much input or something?
13:49:46 <monochrom> No.
13:50:11 <shapr> Well, if they do...
13:50:29 <glguy> hit them with a graphite rod?
13:50:39 <roconnor> A monad is like a space suit with nuclear waste inside ...
13:50:48 <mrd> this discussion is starting to sound like a monad tutorial
13:50:50 <shapr> heh
13:51:00 <monochrom> Did it occur to you that nuclear waste also happens to be warm? :)
13:51:07 <r_rehashe1> hi everybody. i saw the haskell tutorial given by Simon Peyton Jones from MSR at OSCON'07. i did learn some really good stuff about Haskell.. but i didn't get everything that he said. anybody here seen the videos?
13:51:22 <monochrom> Maybe not fuzzy, but certainly warm...
13:51:36 <shapr> r_rehashe1: I've seen part of it, what did you like?
13:51:40 <glguy> r_rehashe1: ask any qyestions you might have
13:51:58 <mrd> so, who is the designated Monader right now?
13:52:04 <shapr> hah
13:52:14 <glguy> *not it*
13:52:27 <roconnor> shapr: we need monad privledges, like op priviledges.
13:52:34 <r_rehashe1> i am totally new to haskell, so i really loved the new concept of just dealing with values
13:52:37 * shapr laughs
13:52:39 --- mode: ChanServ set +v roconnor
13:52:47 <r_rehashe1> it did take quite some time to get it
13:52:47 <glguy> roconnor: you have the flag
13:52:48 <glguy> ;)
13:52:53 <shapr> r_rehashe1: I agree, that's cool!
13:52:54 <roconnor> oh, okay
13:52:57 <dino-> < Monadic President> I sequence. I'm The Sequencer.
13:53:00 <xerox> Are you saying +m means +Monad? (-:
13:53:12 <r_rehashe1> i have become so used to imperative programming, i realised
13:53:13 <monochrom> No one has complained because I learned monads from Wadler not this jumping-up-and-down community. If we wound back time and let me never see Wadler's paper and made me learn from this channel, I would definitely complain about the massive low-quality answers.
13:53:52 * SamB_XP probably read the paper too
13:54:00 <roconnor> A monad is like an abstract data type, except it is an abstract data constructor.
13:54:03 <r_rehashe1> yeah! i felt i could be so much more productive and creative. i want to learn a lot more about Haskell
13:54:06 * glguy doesn't think that monads are actually explained all that often in channel
13:54:08 <roconnor> it is used for sequenceing things.
13:54:21 <roconnor> ugh
13:54:23 <roconnor> this is hard.
13:54:24 <OceanSpray> no it isn't
13:54:24 <shapr> r_rehashe1: Cool! Would you like pointers to tutorials and introductions?
13:54:27 <OceanSpray> not enough
13:54:29 <sjanssen> roconnor: the constructors of monads aren't necessarily hidden
13:54:32 <OceanSpray> I still have no idea what they are
13:54:38 <SamB_XP> a monad is, like, this thing. you use it to do things.
13:54:38 <OceanSpray> and I'm using them everywhere.
13:54:41 <r_rehashe1> shapr: Yeah! please. ty :)
13:54:52 <mrd> an endofunctor on the category of haskell types
13:54:58 <sjanssen> I think that's one major tripping point of most monad explanations -- they say monads are "primitive" or "opaque"
13:55:10 <samreid> A monad is like a rocketship, with containery radioactive dinosaur semantics.
13:55:13 <monochrom> For all you know you have been using numbers for 30 years and still never thought about "what they are".
13:55:17 <shapr> r_rehashe1: There bunches of good links on the front page of http://www.haskell.org/
13:55:19 <lambdabot> Title: Haskell - HaskellWiki
13:55:30 <glguy> sjanssen: yeah, I think that it is important to understand that there is nothing primative about monads except that do-notation is built-in sugar
13:55:31 <roconnor> sjanssen: well, when working with the monad interface the implemeantion is hidden.
13:55:46 <roconnor> maybe Cale's combinator library explainion is best.
13:56:07 <sjanssen> roconnor: IMO, it's better to say "abstracted", rather than hidden
13:56:15 <r_rehashe1> shapr: ok. thanks
13:56:16 <roconnor> sjanssen: fair enough.
13:56:20 <sjanssen> it's just like overloaded numeric code
13:56:23 <roconnor> sjanssen: I think I can agree with that.
13:56:32 <roconnor> sjanssen: I think...
13:56:32 <monochrom> Hell, forget numbers. You have been living life for 30 years and you probably still have no verified answer as to "what is life".
13:56:59 <shapr> r_rehashe1: http://www.haskell.org/haskellwiki/Haskell_in_5_steps might be good
13:57:01 <lambdabot> Title: Haskell in 5 steps - HaskellWiki
13:57:02 <monochrom> How do you explain "what is life" to a kid? A Haskell student?
13:57:03 * conal wonders if people really want to know about IO when they ask about monads.  if so, i'd teach them in the concrete first & then generalize.  
13:57:05 <Runaro^BRS> monochrom: Depends on context.
13:57:13 <Japsu> the Life monad, mmmm....
13:57:20 <monochrom> "Life is a spacesuit floating in space"?
13:57:25 <shapr> r_rehashe1: Do you have any specific questions?
13:57:31 <monochrom> "Life is a computation"?
13:57:36 * Japsu wrote his own IO monad tonight
13:57:41 --- mode: ChanServ set -v roconnor
13:57:45 <laz0r> i just had a 'aha' experience a couple of days ago when i understood how you use the list monad
13:58:11 <laz0r> that is, getting that 'inside' the do notation, you are working on the contents of the monad
13:58:16 <mrd> so what you're saying is, monads = life?
13:58:17 <dino-> r_rehashe1: One thing that may be good is Adam Turoff's 3-short-part writings from ONLamp. http://www.onlamp.com/pub/a/onlamp/2007/05/21/an-introduction-to-haskell---part-1-why-haskell.html
13:58:19 <lambdabot> Title: ONLamp.com -- An Introduction to Haskell, Part 1: Why Haskell, http://tinyurl.com/3cpyts
13:58:30 <dino-> By part 3 it gets up to monads.
13:58:48 <roconnor> Definitely something needs to be said about Kleisli arrows when talking about monads.  I'm just not sure how to put it.
13:59:07 <roconnor> People need to know that ``monadic fuctions'' have the signature a -> b -> m c
13:59:22 <roconnor> (in general)
13:59:45 <monochrom> mrd: No, I'm saying how do you explain abstract yet taken-for-granted things to those who are still concrete and haven't taken it for granted.
13:59:55 <roconnor> When I first started I have a bunch of functions m a -> m b -> m c.
14:00:14 <roconnor> oh, the wrongness it was.
14:00:21 <mrd> I think people would have a lot less trouble with monads if they had a good mascot.
14:00:37 <lament> i nominate shapr
14:00:55 <Runaro^BRS> monochrom: You reason from the concretes that give rise to the abstraction in the first place.
14:00:55 <roconnor> mrd: how about a binder; kinda like clippy.
14:00:55 <monochrom> "Happy customer of monads"? :)
14:00:57 <shapr> I like sigfpe's approach. Show how several tasks can be abstracted with the same pattern.
14:01:04 <dino-> http://www.onlamp.com/pub/a/onlamp/2007/05/21/an-introduction-to-haskell---part-1-why-haskell.html
14:01:06 <r_rehashe1> thanks guys.
14:01:06 <lambdabot> Title: ONLamp.com -- An Introduction to Haskell, Part 1: Why Haskell, http://tinyurl.com/3cpyts
14:01:46 <mrd> I think staying away from clippy might be for the best -- too much supressed rage towards that particular one.
14:01:58 <monochrom> This tea is good. It's giving me ideas. I'm getting more.
14:01:59 <r_rehashe1> shapr: i don't really have any specific questions right now. i guess i have to read a lot more before i get some doubts.
14:02:09 <shapr> Ok, feel free to ask questions when you get them.
14:02:28 <r_rehashe1> right :)
14:02:42 <monochrom> sigfpe's approach is also Wadler's approach. I like that very much.
14:02:43 <dino-> Sorry, paste accident with that repeated URL.
14:03:19 <roconnor> do they explain how sequence is the solution to every problem ;)
14:04:04 <monochrom> sequence is the solution to the halting problem too? :)
14:04:29 <r_rehashe1> i feel like i am coming back to maths. it's a good feeling
14:05:24 <glguy> is there a way in vim to say that when ever some string is seen, say "->" display that as →
14:06:25 <sjanssen> glguy: I dunno.  But you have to tell me if you find a solution ;)
14:06:37 <glguy> emacs does it in its Haskell-Mode
14:06:47 <glguy> but I don't want to switch editors for this specific feature
14:07:02 <lament> i was just thinking about that recently
14:08:04 <gwern> glguy: surely vim has it - I mean, it can do syntax highlighting so doesn't that mean the machinery is there?
14:09:00 <gwern> worse comes to worse, you could set up an elaborate search-and-replace, and add a hook to whatever function saves file; which hook would do the inverse search and replace obviously
14:09:04 <monochrom> I wonder if syntax highlighting includes text substitution. Some doesn't.
14:09:29 <glguy> gwern: that's no good, if I press backspace in front of → I want - to be left behind
14:10:06 <lament> my main problem is that it should be context-sensitive
14:10:20 <lament> and that's tricky...
14:10:27 * gwern never said it wasa  very good solution, just a worst-case way you could do it even if vim sucked horribly
14:10:33 <lament> replacing \ with lambda is tricky
14:10:45 <dolio> Someone posted an Emacs configuration to do that a while back, as I recall.
14:10:56 <dolio> On reddit, that is.
14:10:59 <glguy> lament: \ + space could always be considered a lambda
14:11:07 <glguy> outside of strings
14:11:07 <gwern> dolio: probably the Pretty Lambda code snippets
14:11:18 <glguy> maybe :)
14:11:26 <lament> glguy: so it's already context-sensitive...
14:11:30 <roconnor> > \010
14:11:30 <lambdabot>  Parse error
14:11:32 <dolio> Was lambda the only thing it did?
14:11:40 <gwern> dolio: no, it did a lot of other symbols
14:11:46 <roconnor> > \o010
14:11:46 <lambdabot>  Parse error
14:11:54 <glguy> :: -> => <- not
14:11:56 <roconnor> > 0o010
14:11:58 <lambdabot>  8
14:11:58 <glguy> and others
14:12:03 <gwern> haskell-mode had similar machinery to do it, but it didn't have as many correspondences as Pretty Lambda
14:12:04 <roconnor> oh
14:12:22 * gwern sent monnier a patch to merge in pretty lambda's bindings, but I haven't seen any response, so...
14:12:22 <glguy> \ became a λ
14:12:30 <glguy> . became compose
14:12:33 <glguy> (the symbol)
14:12:36 <dino-> r_rehashe1: Speaking of Haskell and math, there are some good Haskell books listed here: http://jaortega.wordpress.com/2006/03/28/a-haskell-bookshelf/
14:12:38 <lambdabot> Title: A Haskell bookshelf  programming musings
14:12:46 <glguy> ++ was translated iirc
14:12:55 <dino-> Like _The Haskell Road.._ and the algorithms book there.
14:13:48 <r_rehashe1> dino-: Thanks. that looks like a treasure ;)
14:14:53 <gwern> glguy: ++ has a symbol?
14:16:08 <sorear> glguy: played much with lhs2TeX?
14:16:31 <glguy> sorear: only briefly
14:16:40 <glguy> sorear: have you seen emacs editing latex files
14:16:45 <glguy> where it puts the rendered version inline?
14:16:48 <sorear> no
14:17:09 <sorear> i don't edit latex, I let lhs2Tex do it for me :)
14:17:09 <glguy> well, there is such a thing at least for math formulas...
14:17:28 <glguy> it would be cool if the haskell functions could be rendered like that too using lhs2tex
14:17:35 <glguy> when you werent editing them
14:18:04 <glguy> gwern: I want to say that there is, I don't know its name offhand
14:18:26 <gwern> glguy: where would I look these up? a substring of it is almost certainly 'cat'...
14:20:48 <glguy> http://www.fileformat.info/info/unicode/char/search.htm
14:20:49 <lambdabot> Title: Unicode Character Search
14:20:53 <glguy> is what I use on occasion
14:21:06 <lament> okay
14:21:14 <lament> a guy in #vim says it's impossible
14:21:15 <lament> :(
14:21:20 <OceanSpray> oh lordy
14:21:28 <OceanSpray> I've finally run into a runtime error
14:21:34 <OceanSpray> and I have no idea how to deal with it
14:22:15 <OceanSpray> because, apparently, I can't just putStrLn in arbitrary places.
14:22:16 <gwern> OceanSpray: throw an exception!
14:22:33 <OceanSpray> what?
14:23:01 <gwern> OceanSpray: 'twas a joke
14:23:02 <byorgey> gwern: ++ is often typeset as two + characters merged into one, by adding negative space between them
14:23:20 <byorgey> gwern: if it has a special name, I'm not aware of it
14:23:31 <OceanSpray> ok, here goes
14:24:12 <gwern> byorgey: hmm. that helps. so it looks kind of like an H with the horizontal line sticking out?
14:24:42 <dolio> You can actually put print statements in arbitrary places with trace.
14:24:50 <dolio> If that's your preferred debugging method. :)
14:24:54 <byorgey> gwern: yup.  or like an em-dash with two vertical lines through it.
14:25:08 <byorgey> gwern: or like... two + signs smooshed together =)
14:25:49 <hpaste>  OceanSpray annotated "(no title)" with "(no title)" at http://hpaste.org/2305#a1
14:26:03 <byorgey> gwern: in general, the practice seems to be typesetting Haskell operators by smooshing together the individual characters
14:26:16 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2305#a2
14:26:20 <gwern> byorgey: just making sure the smooshed together ++ I was thinking of was the same as you were
14:26:23 <dolio> Yeah. Bind is typeset that way, too.
14:26:31 * gwern wonders if someone in #unicode might know
14:26:51 <glguy> gwern: I've been pastiung the answers to #vim
14:26:54 <glguy> on accident..
14:26:57 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2305#a3
14:26:58 <glguy> http://www.fileformat.info/info/unicode/char/29fa/index.htm
14:26:58 <lambdabot> Title: Unicode Character 'DOUBLE PLUS' (U+29FA)
14:27:06 <glguy> http://www.fileformat.info/info/unicode/char/29fb/index.htm
14:27:07 <lambdabot> Title: Unicode Character 'TRIPLE PLUS' (U+29FB)
14:27:09 <gwern> glguy: ...hilarious
14:27:12 <lament> vim people are quite confident it's impossible :(
14:27:20 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2305#a4
14:27:26 <jedai> Hello, do you see a faster way to calcul the number of trailings zero for n! than the following function :
14:27:37 <gwern> bah. font problems
14:27:44 <lament> which suggests that syntax highlighting in vim is implemented as a horrible hack
14:27:44 <jedai> zeros n = sum $ map ((n `quot`) . (5^)) [1.. truncate $ logBase 5 $ fromIntegral n ]
14:27:53 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2305#a5
14:28:10 <gwern> glguy: what's triple plus anyway?
14:28:29 <dolio> Arrow choice?
14:28:38 <byorgey> jedai: if you repeatedly divide n by 5, you can avoid having to calculate all those powers of 5
14:28:55 <jedai> Yeah, I just thought that too
14:29:08 <hpaste>  OceanSpray annotated "(no title)" with "(no title)" at http://hpaste.org/2305#a6
14:29:11 * byorgey rummages around for similar code he wrote before
14:29:22 <jedai> byorgey: But it only gains me a factor 2 and I've seen even faster solutions
14:30:11 <glguy> OceanSpray: if you are going to dump 7 files to hpaste, titles might be nice
14:30:18 <byorgey> jedai: you also don't need to bother taking the log base 5
14:30:28 <OceanSpray> yeah, oh
14:30:32 <OceanSpray> sorry
14:30:35 <jedai> byorgey: How ?
14:30:45 <jedai> byorgey: Do I precompute it too ?
14:30:53 <byorgey> jedai: just do something like sum . tail . takeWhile (/= 0) . iterate (`div` 5)
14:31:27 <byorgey> > sum . tail . takeWhile (/= 0) . iterate (`div` 5) $ 100
14:31:33 <lambdabot>  24
14:32:02 <byorgey> > length . takeWhile (=='0') . reverse . show . product $ [1..100]
14:32:02 <jedai> byorgey: It's what I did before but it was slower, it wasn't exactly the same form though, so I'll try yours
14:32:03 <lambdabot>  24
14:32:53 <jedai> byorgey: It's slower here
14:33:06 <byorgey> jedai: really? that's surprising.  are you using -O2?
14:33:32 <byorgey> I'd think it would compile into a tight little loop
14:33:41 <byorgey> only doing integer division
14:33:42 <jedai> I hope that the contest I'm in use it...
14:33:59 <byorgey> which contest?
14:34:10 <jedai> byorgey: Can you put a -O2 in a {-# OPTIONS ... ?
14:34:25 <byorgey> jedai: I'm not sure
14:34:33 <jedai> byorgey: Sphere Online Judge ... Not really a contest
14:34:44 <byorgey> jedai: ah yes, I've done some of that too
14:35:20 <jedai> byorgey: Well with power of two precomputed I got 2.03 s
14:35:38 <byorgey> jedai: yes, you can put -O2 in {-# OPTIONS_GHC -O2 -#} according to the ghc docs
14:35:42 <jedai> byorgey: So the solution is accepted, but that's still pretty slow
14:35:53 <jedai> byorgey: Thanks, I'll try that
14:35:53 <byorgey> jedai: paste your code?  I'm curious
14:36:34 <byorgey> the -O2 might help a lot, since otherwise sum builds up huge thunks I think, but with -O2 it seems to get optimized well
14:38:03 <kdunn__> Wow, thanks for the lhs2tex link earlier.  This makes my silly haskell code look far more important :-P
14:38:15 * gwern implements unicode symbol for ++. man, wonder what's left that I would actually see in my code
14:38:43 <byorgey> lhs2TeX rocks!
14:38:44 <glguy> gwern: your font has the ++ character?
14:38:52 <gwern> hmm. do the >> and =<< operators have unicode versions?
14:38:54 <gwern> glguy: nope!
14:38:57 <glguy> gwern: yes
14:39:00 <glguy> >> at least
14:39:06 <gwern> glguy: my dream is to be unable to read my code :)
14:39:35 <gwern> glguy: guess that'd be under bind?
14:39:51 <byorgey> jedai: well, I have to go, but I'm curious to hear whether -O2 helps, just leave me a message with lambdabot =)
14:39:59 <lament> consider replacing all letters with similar-looking chinese or sumerian characters
14:40:08 <jedai> byorgey: Ok
14:40:26 <gwern> lament: we could shorten comments by translating them into single agglutinative sumerian words!
14:40:32 <OceanSpray> oh
14:40:34 <OceanSpray> OH
14:40:36 <OceanSpray> damn it
14:40:45 <gwern> think of the space we'd save!
14:40:54 * gwern bets compilation would go loads faster then
14:40:59 <OceanSpray> forgot to make a idToIORef Null, lol
14:40:59 <lament> you should certainly replace -- with something
14:41:04 <lament> not sure what
14:41:23 <lament> maybe just a long dash
14:41:33 <gwern> lament: I don't think I've ever seen -- replaced with anything, actually
14:41:44 <lament> yeah, but why not?
14:41:45 <OceanSpray> MWAHAHAHA, IT WORKS!
14:41:58 <lament> -- clearly doesn't mean "minus minus"
14:42:00 <gwern> (there seem to be a lot of 'Z notation' hits...)
14:42:05 <OceanSpray> > (define a 5)
14:42:05 <OceanSpray> > a
14:42:05 <OceanSpray> 5
14:42:12 <lambdabot>   Not in scope: `a'
14:42:12 <kdunn__> Don't folds have some kind of fancy slash-arrow character?
14:42:13 <lambdabot>   Not in scope: `a'
14:42:18 <OceanSpray> oh whoops
14:42:22 <OceanSpray> sorry, lambdabot
14:42:35 <gwern> kdunn__: for what part? the whole definition?
14:43:16 <kdunn__> Well I know you can do the whole definition with the banana symbols, but there's a symbolic replacement for the word foldr and foldl, I believe.
14:43:38 <gwern> kdunn__: really? I'll have to look for those as well
14:43:51 <kdunn__> I saw them in some paper.  heh.
14:43:54 <gwern> wait, but there are all sorts of folds, like the ' ones
14:44:01 <gwern> what did they do with them?
14:44:08 <kdunn__> Dunno!  Ignore them? :-)
14:44:19 <jedai> @help
14:44:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:44:26 <jedai> @list
14:44:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:45:05 <jedai> @help tell
14:45:05 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
14:45:52 <lament> hm
14:46:02 <lament> how about a lambdabot pugin to prettify lambdabot's output? :)
14:46:12 <lament> of course, that would force everybody to use utf8...
14:46:17 <gwern> huh. there are double-parentheses unicode symbols
14:46:25 <sjanssen> gwern: foldr is the one true fold :)
14:46:32 <sjanssen> the others don't deserve symbols
14:46:42 <gwern> sjanssen: if you say so. I certainly wo't argue with you!
14:46:51 <OceanSpray> tell OceanSpray hi
14:46:55 <OceanSpray> hi
14:46:59 <OceanSpray> ?
14:47:04 <shapr> @tell OceanSpray greetz!
14:47:04 <lambdabot> Consider it noted.
14:47:15 <OceanSpray> oh
14:47:15 <lambdabot> OceanSpray: You have 1 new message. '/msg lambdabot @messages' to read it.
14:47:20 <OceanSpray> we need @
14:47:38 <OceanSpray> 25s ago!
14:47:39 <sjanssen> @msg OceanSpray hi
14:48:01 <OceanSpray> sjanssen!
14:48:08 <OceanSpray> no bot abuse!
14:48:13 * gwern says oh what the heck and throws in (( and )) to the bunch as well
14:49:08 <jedai> @tell byorgey On the subject of counting trailing zeros in factorial, -O2 helped sum to outperform (by almost a factor 2) the explicit logBase 5, which means that GHC still has difficulties in optimisation since I wrote the same with a recursive function and it took 6 times longer...
14:49:08 <lambdabot> Consider it noted.
14:50:27 <gwern> it'd be a bad idea to replace fractions too wouldn't it?
14:50:47 <kdunn__> gwern: What are you adding these symbols to?  Do you have some fancy emacs plugin that swaps out these characters or something?
14:51:05 <sjanssen> jedai: do you happen to be working on a SPOJ problem?
14:51:15 <gwern> kdunn__: yes, almost right
14:51:16 <jedai> sjanssen: exact :)
14:51:23 <gwern> kdunn__: it swaps the *appearance*
14:51:41 <sjanssen> jedai: I've got a really short solution that solved it in 4.9s
14:51:44 <gwern> if it swapped the actual characters, then there'd be a problem
14:51:46 <glen_quagmire> shapr: i have tried emacs for a couple of days for lisp and gave both up
14:51:46 <kdunn__> gwern: Link?  I'm a sucker for aesthetics.
14:52:01 <jedai> sjanssen: Mine just took 1.2 s...
14:52:26 <jedai> sjanssen: Well to be fair, mine took 2.4 s and byorgey's 1.2s
14:52:37 <gwern> kdunn__: look at the haskell wiki under haskell-mode
14:52:47 <jedai> sjanssen: You're talking about FCTRL I suppose ?
14:53:09 <sjanssen> jedai: yeah
14:53:17 <jedai> sjanssen: When you say really short, how short do you mean ?
14:53:26 <shapr> glen_quagmire: Ok, just curious
14:53:38 <sjanssen> jedai: under 10
14:53:40 <sjanssen> lines
14:54:36 <jedai> sjanssen: Could you paste, I'm curious at how to do those sort of thing faster in Haskell
14:54:43 <jedai> sjanssen: I'll paste mine
14:54:51 <sjanssen> jedai: well, mine clearly isn't faster :)
14:55:40 <jedai> sjanssen: Yeah, but I'll get to see what makes it slower ^^ (and I've sweated quite a lot to get mine under 6 seconds initially ^^' )
14:55:52 <hpaste>  sjanssen pasted "FCTRL" at http://hpaste.org/2307
14:58:54 <hpaste>  (anonymous) annotated "FCTRL" with "FCTRL faster but.." at http://hpaste.org/2307#a1
14:59:37 <sjanssen> jedai: ah, I wonder if you're winning just because of the IO
14:59:44 <jedai> Well you don't use ByteString, it might be why you're slower
14:59:53 <jedai> sjanssen: I wondered the same
15:02:32 <jedai> sjanssen: I'm trying byorgey's solution with your IO
15:03:49 <gwern> hee hee. 'U+226A  MUCH LESS-THAN'
15:04:04 <int-e> ≪
15:04:07 <gwern> haskell ≫ perl
15:04:18 <lament> haskell is much less than perl?
15:04:37 <jedai> @tell sjanssen Well we both had the same idea apparently, your solution is in fact faster (probably) and anyway byorgey's is slower with your IO than yours
15:04:38 <lambdabot> Consider it noted.
15:04:43 <ddarius> lament: Your client not support unicode?
15:04:45 <int-e> <≪⋘?
15:04:45 <gwern> no, the symbol I pasted was much greater than
15:04:54 <gwern> http://www.fileformat.info/info/unicode/category/Sm/list.htm <-- so many interesting symbols
15:04:55 <lambdabot> Title: Unicode Characters in the 'Symbol, Math' Category
15:05:20 <gwern> come tot hink of it, isn't ⊗ xor?
15:05:39 <lament> ddarius: it does, but these symbols aren't in my font
15:05:39 <kdunn__> I thought that was the generic operator symbol
15:05:45 <int-e> no, ⊕ is sometimes used for that though
15:05:45 <conal> i'm interested in the Haskell Hackathon (http://www.haskell.org/haskellwiki/Hac_2007_II).  Anyone here planning to attend or considering it?
15:05:46 <lambdabot> Title: Hac 2007 II) - HaskellWiki
15:06:00 <conal> shapr: Hac II fo ryou?
15:06:03 <lament> ddarius: which leads me to believe they aren't in most other fonts either
15:06:19 <gwern> hey loook, bottom! UP TACK ⊥
15:06:24 <ddarius> lament: It's in the font I'm using and I never did anything special.
15:07:02 <gwern> what's the ascii representation of bottom in haskell?
15:07:10 <gwern> 'undefined'?
15:07:35 <lament> let's see...
15:07:38 <lament> > let x = x in x
15:07:39 <lambdabot>  Exception: <<loop>>
15:07:47 <lament> hehe
15:07:55 <pgavin> > undefined
15:07:56 <lambdabot>  Undefined
15:08:41 <gwern> 'LONG RIGHTWARDS SQUIGGLE ARROW' I'm sure this would come in handy somewhere, but hwere? :)
15:09:16 <lament> gwern: sounds like a good potential replacement for -- :)
15:09:34 <ddarius> reduction
15:09:35 <augustss> SQUIGGLE!
15:09:54 <gwern> 'RIGHTWARDS HARPOON WITH BARB UP ABOVE LEFTWARDS HARPOON WITH BARB UP' <-- sounds painful
15:10:32 <gwern> http://www.fileformat.info/info/unicode/char/2982/index.htm <-- can anyone see this one? what does it look like?
15:10:33 <lambdabot> Title: Unicode Character 'Z NOTATION TYPE COLON' (U+2982)
15:11:02 <lament> it looks like this:
15:11:02 <lament> o
15:11:03 <lament> o
15:11:12 <gwern> 'U+29D3  BLACK BOWTIE' <-- do I even want to know?
15:11:22 <ddarius> |><|
15:11:27 <ddarius> I've seen it used before.
15:11:47 <Lycurgus> in math text
15:12:07 <ddarius> Actually, I think it a computer science text on concurrency.
15:12:33 <gwern> huh. well, as long as there is no haskell equivalent
15:12:59 <ddarius> > let x |><| y = x*y in 3 |><| 6
15:13:01 <lambdabot>  18
15:14:05 <lament> ugh
15:14:41 <lament> @let x >>>>>>>>>>>>> y = x > (y * 1000)
15:14:45 <lambdabot> Defined.
15:15:26 <ddarius> @let (=^.-=) = (++)
15:15:27 <lambdabot> Defined.
15:16:00 <lament> > "hello" =^.-= " kitty!"
15:16:01 <lambdabot>  "hello kitty!"
15:17:45 <gwern> hey, I could also cover *! since multiplication is that dot character
15:18:14 <lament> true
15:18:41 <lament> also ==
15:18:56 <lament> is there a long equality sign?
15:19:01 <lament> and obviously /=
15:19:16 <gwern> default multiplication is the x, though...
15:19:22 <gwern> could be confusing. better stick with the dot
15:20:30 <ClaudiusMaximus> i think i need Control.Arrow.Transformer.Reader, but i haven't got a clue how to use it - is there a tutorial somewhere?
15:21:13 <gwern> lament: probbably. there are a lot of equality signs
15:21:14 <gwern> CIRCLED TIMES would just be confusing I think
15:21:26 <ddarius> gwern: Yes it would.
15:22:14 <gwern> strange. there's natural exponentiation, and power set. but no exponent?
15:22:35 <ddarius> ClaudiusMaximus: There aren't very many arrow tutorials at all.
15:22:50 <ddarius> gwern: Exponentiation is represented by superscripting not with a symbol.
15:23:28 <gwern> ddarius: oh. that makes sense. so much for that
15:24:04 <Heffalump> on the subject of arrows, has anyone tried the syntactic sugar for making new arrow "commands"?
15:24:18 <ddarius> "new arrow commands"?
15:24:58 <Heffalump> http://www.haskell.org/ghc/docs/6.6.1/html/users_guide/arrow-notation.html#id3155476
15:25:00 <lambdabot> Title: 7.7. Arrow notation, http://tinyurl.com/23ak5e
15:25:01 <Heffalump> and the section below
15:25:10 <shapr> dcoutts_: Hey, I think main-is: doesn't work with hs-source-dirs:
15:25:34 <Heffalump> it seems quite complicated, but I think I may actually have a use for it. But the need for closing |) is annoying.
15:25:53 <shapr> @tell dcoutts With cabal pulled, three days ago or so, it seems that main-is doesn't look in hs-source-dirs for Main.hs
15:25:53 <lambdabot> Consider it noted.
15:27:18 <ddarius> Down with Arrows!
15:28:05 <Heffalump> I think I've finally found a reason I want to use them, after several false starts.
15:28:29 <ddarius> Heffalump: After several false starts of trying to find a reason to use them?
15:28:34 <Heffalump> but it relies on implicitly propagating the variables in scope through combinators, hence my need for that syntax
15:28:37 <Heffalump> yes
15:29:04 <ddarius> Heffalump: Why are you trying to find a reason to use new (and complicated) syntax?
15:29:26 <Heffalump> I'm not. I'm just always on the lookout for an opportunity to try out arrows properly to see what I think.
15:29:53 <Heffalump> I'm not at all keen on those complicated parts of the syntax, but they seem like they might be necessary for my use to actually work out
15:29:58 <ddarius> They aren't worth it unless you find that you are recreating them (unlikely).
15:30:17 <Heffalump> I have a monad which can't do what I want it to due to lack of static properties.
15:35:25 <gwern> (f $ g) . (h $ j) = (f . h) $ (g . j), right?
15:38:29 <jedai> @pl (f $ g) . (h $ j)
15:38:29 <lambdabot> f g . h j
15:38:55 <Heffalump> (f . h) $ (g. j) = f (h (g . j)), which doesn't look much like f g . h j to me
15:38:56 <jedai> @pl (f . h) $ (g . j)
15:38:57 <lambdabot> f (h (g . j))
15:39:10 <Heffalump> @type \f g h j -> (f $ g) . (h $ j)
15:39:12 <lambdabot> forall a b c a1 a2. (a -> b -> c) -> a -> (a1 -> a2 -> b) -> a1 -> a2 -> c
15:39:16 <Heffalump> @type \f g h j -> (f . h) $ (g . j)
15:39:18 <lambdabot> forall b c b1 c1 a. (b -> c) -> (b1 -> c1) -> ((a -> c1) -> b) -> (a -> b1) -> c
15:39:27 <Heffalump> so they clearly aren't equal in general
15:39:32 <ClaudiusMaximus> i'm having trouble compiling arrows-0.2 , lots of coverage condition failed errors, not sure how to proceed
15:39:43 <Heffalump> -fallow-undecidable-instances
15:40:11 <ClaudiusMaximus> Heffalump: sure, but i don't know where to put that in (it's Cabalized, and i don't know Cabal)
15:40:27 <Heffalump> there'll be a .cabal file you can put it in
15:40:48 * Heffalump looks for the option name
15:41:18 <Excedrin> what's a good way to model a FSM in Haskell? I'm using Control.Monad.State and a "case currentState of" sort of construct, but all these modifiy statements make me think I'm missing something
15:41:23 <ClaudiusMaximus> ok, i guess it belongs here:  Extensions: MultiParamTypeClasses
15:41:26 <Heffalump> I think you just dump it in ghc-options
15:41:43 <Heffalump> unless there's a standardised extension name for that flag
15:41:54 <shapr> Excedrin: Got some source we can look at?
15:42:50 <Excedrin> shapr: no, but I'll paste a small example..
15:42:57 <shapr> k
15:45:29 <tuete> does someone have experience with Data.Binary? im just reading the sources, wondering if it can be threadsafe at all with all those unsafePerformIO.
15:48:50 <tuete> background: im trying to establish "zero-copy" pickling (based on kennedys pickler combinators and maybe Data.Binary) to posix shared memory via FFI -> boost::interprocess and some handcrafted CAS-hackery. ^^
15:49:47 <tuete> some midterm goal would be an effective way to do haskell-ocaml-interop via shared memory ...
15:51:43 <ClaudiusMaximus> Heffalump: found it:
15:51:44 <ClaudiusMaximus> -Extensions: MultiParamTypeClasses
15:51:44 <ClaudiusMaximus> +Extensions: MultiParamTypeClasses UndecidableInstances
15:52:50 <SamB> remind me to try actually using xmonad soon...
15:53:41 <SamB> I did manage to restart WindowMaker with GDB this time though...
15:53:42 <ddarius> Excedrin: Just pattern match on State -> State functions
15:53:56 <ddarius> SamB: Try xmonad now.
15:54:01 <SamB> I have to go now
15:54:06 <ddarius> Excuses.
15:54:46 <hpaste>  Excedrin pasted "FSM state thing" at http://hpaste.org/2308
15:55:23 <kdunn__> I'm using xmonad now, it's lovely ;-)
15:56:29 <lament> i'd try xmonad but it just doesn't play with OS X very well :)
15:58:59 <ddarius> lament: Why not?
15:59:44 <ddarius> tuete: unsafePerformIO doesn't necessarily or even usually mean a lack of thread safety.
16:00:13 <lament> ddarius: OS X already has its window manager
16:00:32 <johnnowak> well, there's still X
16:01:19 <lament> without the root window
16:02:35 <tuete> ddarius: are you saying that in context of Data.Binary? is it threadsafe?
16:03:40 <OceanSpray> Is it normal to run into several type mismatch errors every time you modify your code?
16:03:43 <tuete> just looking at the Builder lets me wonder how i.e. parallel pickling can work without any atomic operations
16:03:43 <ddarius> tuete: I have no idea.  I'd have to look.  But I wouldn't be surprised if most of it is.
16:04:04 <ddarius> OceanSpray: It depends on what you're doing, but often, yes.
16:04:22 <ClaudiusMaximus> ah, nevermind, it's fixed in the darcs version
16:05:54 <OceanSpray> It's getting kind of frustrating
16:06:07 <lament> OceanSpray: it's a good sign, those are bugs that could easily end up being run-time bugs in other languages :)
16:06:09 <OceanSpray> 80% of the time, I have no idea how to fix them
16:06:34 <OceanSpray> see, runtime bugs in other languages I can deal with
16:06:38 <lament> no
16:06:39 <lament> you can't
16:06:48 <lament> i'm saying that as a professional tester
16:06:49 <OceanSpray> I can't?
16:07:05 <lament> nobody can deal with runtime bugs :)
16:07:08 <OceanSpray> I resolve my share of segfaults back in the day
16:07:37 <OceanSpray> nothing a few well-placed printf()s counldn't diagnose.
16:07:51 <OceanSpray> but these type mismatches...
16:07:56 <lament> well, sure, some bugs are obvious to find
16:08:10 <lament> anyway, at least this way you immediately know there's a problem
16:08:17 <OceanSpray> yeah, that's good
16:08:26 <lament> type mismatches are often caused by not following precedence rules
16:08:35 <lament> in particular, very often i write "return foo x"
16:08:55 <lament> which gets interpreted as (return foo) x
16:09:19 <lament> and then i get really confused about the type mismatch message
16:09:31 <OceanSpray> yeah, I do that too.
16:09:43 <OceanSpray> But this one I'm trying to figure out makes NO SENSE AT ALL
16:09:47 <lament> oh?
16:09:51 <lament> :)
16:10:04 <Saizan> 8 you can try pasting it
16:10:06 <ddarius> OceanSpray: 1) You are using GHC? 2) Try providing explicit type annotations.
16:10:10 <lament> yeah, hpaste it
16:10:18 <Saizan> with realted code
16:10:27 <OceanSpray> hpaste: url?
16:10:28 <hpaste> Haskell paste bin: http://hpaste.org/
16:10:58 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/2309
16:11:03 <OceanSpray> here it is
16:11:15 <ddarius> What's the type error?
16:11:18 <OceanSpray> I'm getting: Primitives.hs:75:20:
16:11:18 <OceanSpray>     Couldn't match expected type `()' against inferred type `LispRet w'
16:11:32 <johnnowak> OceanSpray: really, it's a lot easier if you add type signatures for top-level functions
16:12:02 <ddarius> Also, you want to look into using the Maybe monad.
16:12:17 <OceanSpray> first of all...
16:12:24 <OceanSpray> envBind is RECURSIVE
16:12:40 <OceanSpray> how is it even possible that using it results in a type-mismatch?
16:12:44 <OceanSpray> it's the SAME DAMN FUNCTION!
16:12:50 <johnnowak> ...
16:13:13 <chessguy> dude, take a sedative or somethin
16:13:14 <Saizan>  but it's not the last call that
16:13:14 <chessguy> g
16:13:28 <Saizan> OceanSpray: try adding >> return ()
16:13:33 <OceanSpray> k.
16:14:01 <OceanSpray> same error
16:15:00 <tuete> if anyone's interested: as far as i can see now, Data.Binary is (of course) threadsafe for "independent" runs (no ByteString-Sharing) but seems to exhibit traditional "imperative string buffer" races when multiple threads share the same underlying buffers. if someone knows better/details/constraints of use, please tell me. :>
16:15:02 <Saizan> what's the type of wModify? and can you paste the whole error?
16:16:22 <OceanSpray> hold on
16:16:26 <OceanSpray> my browser crashed.
16:16:29 <lament> (on hpaste, not here :) )
16:17:18 <shapr> Excedrin: Yeah, I think that could be simpler.
16:17:20 <tuete> the whole design seems to be for single-threaded use, so i guess i'll be using "independent" pickling/unpickling runs in parallel, merging the resulting bytestrings behind the scenes
16:17:54 <nornagon> @src Control.Monad.State (>>=)
16:17:54 <lambdabot> Source not found. Do you think like you type?
16:17:56 <nornagon> :(
16:18:07 <Saizan> tuete: you probably want to talk with dons or dcoutts, which are not here at the moment i think, alternatively i'd ask on haskell-cafe
16:18:18 <ddarius> @src State (>>=)
16:18:19 <lambdabot> Source not found. Are you on drugs?
16:18:27 <ddarius> @src Control.Monad.State.State (>>=)
16:18:27 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:18:29 <hpaste>  OceanSpray annotated "(no title)" with "(no title)" at http://hpaste.org/2309#a1
16:18:45 <OceanSpray> there it is.
16:18:50 <nornagon> @src Control.Monad.State.Lazy.State (>>=)
16:18:50 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:19:16 <nornagon> @src Control.Monad.State.Class.State (>>=)
16:19:16 <lambdabot> Source not found. Wrong!  You cheating scum!
16:19:25 <nornagon> I give up :-(
16:19:27 <tuete> Saizan: ok. but they are here usually?
16:19:43 <EvilTerran> i think lambdabot's in a bad mood. must be that time of the month. ;]
16:20:21 <nornagon> :-P
16:20:29 <Saizan> tuete: yes, very often
16:20:33 <ddarius> OceanSpray: That error message doesn't match the source.
16:20:36 <nornagon> @index evalState
16:20:36 <lambdabot> Control.Monad.State, Control.Monad.RWS
16:20:44 <sjanssen> tuete: do you have an example failing testcase?
16:20:45 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
16:20:47 <nornagon> @src evalState
16:20:47 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:20:55 <OceanSpray> I just added a return in front of the recursive call in envBind
16:21:05 <OceanSpray> everything else should be the same.
16:21:20 <sjanssen> tuete: if it isn't threadsafe, we have a bug
16:21:25 <lament> adding a return in front of the recursive call seems an add thing to have to do
16:21:30 <ddarius> OceanSpray: The return definitely shouldn't be there, also you have exactly the same error lament mentioned of writing return f x instead of return (f x)
16:21:32 <tuete> sjanssen: no (not yet), just wondering under which constraints it is
16:21:38 <OceanSpray> eh.
16:21:52 <OceanSpray> <Saizan> OceanSpray: try adding >> return ()
16:21:59 <tuete> sjanssen: at the moment im assuming "independent" get/set calls are threadsafe but buffer-sharing is not
16:22:03 <OceanSpray> H
16:22:04 <OceanSpray> OH
16:22:10 <lament> haha
16:22:12 <tuete> i mean get/put-call :>
16:22:15 <sjanssen> tuete: how are you achieving buffer sharing?
16:22:17 <OceanSpray> that's not what he meant, lol
16:22:23 <blackdog1> Igloo: why did you need GADTs?
16:22:46 <Saizan> OceanSpray: sorry, i meant False -> envBind str ref parent >> return ()
16:24:28 <tuete> sjanssen: im not achieving it right now (maybe reading my motivation for this thoughts could give you an impression of possible use cases), just wondering if i can "hack it up" for my purposes
16:24:52 <tuete>  background: im trying to establish "zero-copy" pickling (based on kennedys pickler combinators and maybe Data.Binary) to posix shared memory via FFI ->
16:24:56 <tuete>                boost::interprocess and some handcrafted CAS-hackery. ^^
16:25:29 <Igloo> blackdog1: http://urchin.earth.li/~ian/desc.txt
16:26:11 <chessguy> @pl \n -> n*(n-1)/2
16:26:12 <lambdabot> (/ 2) . ap (*) (subtract 1)
16:26:29 <Igloo> Oh, shapr confused me by saying wrong channel in the wrong channel. Oh well  :-)
16:26:37 <shapr> haha
16:26:41 <chessguy> @pl \n -> (n^2 - n)/2
16:26:41 <lambdabot> (/ 2) . ((-) =<< (^ 2))
16:27:14 <tuete> at the moment im just using Data.Binary like a regular user, so not achieving "zero-copy". i think ill have to provide my own, shm-based, newBuffer implementation
16:27:23 <sjanssen> tuete: it looks threadsafe, except for GHC's innate locking problem with unsafePerformIO
16:27:26 <nornagon> :t ((-) =<< (^2))
16:27:32 <lambdabot> forall a. (Num a) => a -> a
16:27:42 <nornagon> :t (=<< (^2))
16:27:44 <lambdabot> forall b a. (Num a) => (a -> a -> b) -> a -> b
16:27:57 <chessguy> > (=<< (^2)) 100
16:27:58 <lambdabot>   add an instance declaration for (Num (a -> a -> b))
16:28:04 <chessguy> > (=<< (^2)) 100::Int
16:28:04 <sjanssen> tuete: actually, it's safe as long as you don't re-use a 'buffer' structure
16:28:05 <lambdabot>  Couldn't match expected type `Int' against inferred type `a -> b'
16:28:22 <tuete> sjanssen: you mean in content of parallel get/put calls or in context of parallel buffer operations?
16:28:25 <chessguy> > (=<< (^2)) (100::Int)
16:28:26 <lambdabot>  Couldn't match expected type `a -> a -> b'
16:28:52 <sjanssen> tuete: the interface doesn't allow you to get in the situation of sharing a buffer
16:29:43 <sjanssen> tuete: a Builder is actually a function, newtype Builder = Builder {runBuilder :: (Buffer -> [S.ByteString]) -> Buffer -> [S.ByteString]}
16:29:56 <tuete> sjanssen: yes, i thought that, so i guess ill have to hack it up for my purposes anyway
16:30:13 <sjanssen> (Builder and runBuilder aren't exported)
16:30:57 <tuete> but it would be nice to know the constraints under which my hack is thread-safe then
16:31:37 <Saizan> chessguy: see the type, it wants a  (Num a) => (a -> a -> b) as first argument
16:31:52 <chessguy> YEAH, I SAW
16:31:53 <ddarius> I have to download Data.Binary myself...
16:31:57 <chessguy> mis-caps
16:31:58 <sjanssen> tuete: AIUI, the current code is safe no matter what you do to it
16:32:00 * chessguy sighs
16:32:09 <sjanssen> tuete: unless you modify the library itself
16:32:32 <tuete> sjanssen: i think ill have to, dont i?
16:33:06 <sjanssen> tuete: maybe, I don't really know what you're doing
16:33:13 <tuete> sjanssen: at least to achieve pickling right into shared memory, i can see no alternative than to provide new buffer-allocation
16:33:34 <sjanssen> ah yes, you'd need to do that
16:33:35 <tuete> or is there some parameterization on newBuffer?
16:33:48 <sjanssen> you'd have to supply a replacement for malloc
16:34:40 <tuete> ok and does each thread needs its own threadlocal buffer? or is there some synchronization i dont see?
16:35:17 <Excedrin> shapr: any suggestions for how to simplify?
16:35:51 <sjanssen> tuete: yes, I think each thread needs a Buffer
16:37:21 <tuete> sjanssen: k, thanks
16:39:20 <shapr> Excedrin: I'm pretty sure you can factor out those repeated modify calls, and some of the other stuff, but it's not immediately obvious to me how...
16:39:20 <tuete> hmm, and while im at it: is there another mechanism in haskell (ghc that is) than StablePtr to observe sharing?
16:39:38 <stepcut> I wonder if you could use TH to do proof checking (like Coq, Isabelle, etc) on Haskell code at compile time
16:39:59 <Excedrin> are there any examples of a simple FSM in Haskell on the wiki (or elsewhere)?
16:40:33 <gwern> stepcut: if you find out how to use TH to prove code doesn't use unsafePerform* stuff, I'd be very interested
16:40:48 <shapr> Excedrin: I think it might be easier to visualize if you use ADTs instead of records.
16:41:36 <tuete> stepcut: yeah and in that regard i always wondered if you could get MetaOCaml or even Concoqtion efforts done in TH
16:41:58 * stepcut is trying to learn Coq and friends these days
16:42:40 <sjanssen> tuete: I've heard of reallyUnsafePtrEquality# before, but I'm not sure what sort of guarantees it gives
16:43:55 <ddarius> @google "Observable Sharing"
16:43:57 <Cale> > let last xs = foldr (\x y -> const (y x)) id xs undefined in last [1..100]
16:43:59 <lambdabot>  100
16:44:11 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
16:46:07 <bwwx> hello
16:46:11 <Cale> hi
16:46:34 <bwwx> what is the most efficient way to test if a list has a single element?
16:46:37 <tuete> ddarius: are you referring to "Observable Sharing for Functional Circuit Description"? i think thats a bit to high-level for my purposes, but thanks
16:46:50 <sjanssen> bwwx: 'null', or pattern matching
16:46:54 <sjanssen> > null []
16:46:56 <lambdabot>  True
16:47:08 <bwwx> sjanssen: sorry, i mean exactly 1 element
16:47:29 <nornagon> null.tail?
16:47:36 <sjanssen> nornagon: []
16:47:53 <nornagon> > null.tail [1]
16:47:54 <lambdabot>  Couldn't match expected type `a -> [a1]'
16:47:58 <nornagon> er.
16:48:04 <nornagon> > null.tail $ [1]
16:48:05 <lambdabot>  True
16:48:10 <nornagon> > null.tail $ [1,2]
16:48:11 <lambdabot>  False
16:48:12 <sjanssen> bwwx: then you're stuck with pattern matching, I suppose. "isSingleton [x] = True; isSingleton _ = False"
16:48:13 <ddarius> > null.tail []
16:48:14 <Saizan> > null.tail $ []
16:48:14 <lambdabot>  Couldn't match expected type `a -> [a1]'
16:48:15 <lambdabot>  Exception: Prelude.tail: empty list
16:48:19 <nornagon> oh, right.
16:48:44 <bwwx> sjanssen: there is no "isSingleton" function in the Prelude or List module?
16:48:49 <sjanssen> bwwx: no
16:48:52 <bwwx> :'(
16:49:07 <ddarius> sjanssen: It wouldn't be more efficient than pattern matching (almost certainly wouldn't be slower though).
16:50:02 <sjanssen> ddarius: what wouldn't be more efficient than pattern matching?
16:50:28 <ddarius> An isSingleton function.
16:50:54 <sjanssen> yeah.  Should be pretty much the same with GHC -O
16:50:56 <dolio> > liftM2 (&&) (not . null) (null . tail) $ [1,2]
16:50:57 <lambdabot>  False
16:51:02 <dolio> > liftM2 (&&) (not . null) (null . tail) $ []
16:51:03 <lambdabot>  False
16:51:06 <dolio> > liftM2 (&&) (not . null) (null . tail) $ [1]
16:51:07 <lambdabot>  True
16:51:12 <nornagon> cute :P
16:51:49 <bwwx> will that be optimized to be as fast as isSingleton?
16:52:00 <ddarius> > or []
16:52:02 <lambdabot>  False
16:52:14 <ddarius> or . map (const True)
16:52:28 <ddarius> Not quite..
16:52:29 <sjanssen> > (or . map (const True)) [1, 2, 3]
16:52:30 <lambdabot>  True
16:53:30 <sjanssen> bwwx: all of these solutions will be very close no matter what -- don't worry about it too much :)
16:53:49 <sjanssen> @quote optimization
16:53:49 <lambdabot> jmelesky says: I've figured out the problem. qwe1234 has different definitions of "functional programming", "compiler", "complexity theory", "math", and "optimization" than everybody else who deals
16:53:49 <lambdabot> with computers or computer science.
16:53:56 <ddarius> isJust . unsafeCoerce
16:54:01 <bwwx> i'm just curious if GHC is smart enough to optimize them all to the same code
16:54:15 <sjanssen> @remember ddarius isJust . unsafeCoerce
16:54:15 <lambdabot> Done.
16:54:48 <sjanssen> bwwx: I'm fairly certain GHC will turn an 'isSingleton' function and pattern matching to the same code
16:54:50 <dolio> isJust (unsafeCoerce [1,2]) -- True
16:55:36 <OceanSpray> DIABEETUS & HART DISEEZE
16:56:05 <nornagon> @src fromMaybe
16:56:06 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
16:58:17 <chessguy> @pl i p = f s (l p)
16:58:17 <lambdabot> i = f s . l
16:58:25 <stepcut> > map ((== 1) . length . take 2) $ [[1,2],[],[1]]
16:58:27 <lambdabot>  [False,False,True]
17:00:13 <hpaste>  sjanssen pasted "isSingleton" at http://hpaste.org/2310
17:00:46 <stepcut> > map ((\desiredLength -> (== desiredLength) . take (succ desiredLength)) 1) $ [[1,2],[],[1]]
17:00:49 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
17:00:57 <hpaste>  sjanssen annotated "isSingleton" with "pattern matching" at http://hpaste.org/2310#a1
17:01:16 <hpaste>  sjanssen annotated "isSingleton" with "liftM2" at http://hpaste.org/2310#a2
17:01:44 <nornagon> @instance MonadPlus
17:01:45 <lambdabot> Maybe you meant: instances instances-importing
17:01:49 <nornagon> @instance-importing MonadPlus
17:01:51 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:02:14 <nornagon> @instances MonadPlus
17:02:15 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:03:37 <Saizan> sjanssen: what's Foo.lvl ?
17:03:55 <hpaste>  sjanssen annotated "isSingleton" with "small mistake" at http://hpaste.org/2310#a3
17:04:13 <hpaste>  sjanssen annotated "isSingleton" with "core for corrected isSingleton" at http://hpaste.org/2310#a4
17:04:30 <sjanssen> Saizan: a call to error, I made a mistake in isSingleton
17:05:31 <sjanssen> bwwx: check out http://hpaste.org/2310/diff?old=2&new=4 -- they differ only in variable names :)
17:05:44 <tuete> as im just seeing StateT and fooled around with it the other day: is there some higher-abstraction on "state-like" monads? would be cool to parameterize on if you want to use e.g. ST, State or IO ...
17:07:08 <Saizan> State is a quite different kind of state, even if you can emulate references with a Map i suppose
17:08:01 <sjanssen> GHC is pretty cool :)
17:08:03 <mrd> @src catA
17:08:03 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:08:08 <monochrom> Generalize, but don't stereotype.
17:08:10 <tuete> Saizan: and regarding ST or IO alone?
17:08:29 <sjanssen> sadly, "(1==) . length . take 1" doesn't optimize as well
17:08:41 <monochrom> Their only commonality is STRef and IORef.
17:09:59 <tuete> monochrom: yes and how could you parameterize on that choice?
17:10:04 <Saizan> monochrom: and arrays?
17:10:17 <monochrom> Yes and arrays.
17:11:05 <monochrom> There are already talks about a class for ST and IO for their __Ref's and arrays.
17:11:18 <tuete> ahh, there is MonadState
17:11:19 <Saizan> class HasReferences m r where read :: r a -> m a; write :: r a -> a -> m ()?
17:11:28 <monochrom> Meanwhile, you could write that class yourself.
17:11:33 <tuete> but IO and ST arent instances
17:11:34 <Saizan> m -> r
17:11:57 <Saizan> tuete: MonadState is for things like State
17:12:21 <monochrom> One cannot overemphasize the distinction.
17:12:54 <monochrom> THEY ARE FROM DIFFERENT UNIVERSES, A THOUSAND TIMES.
17:13:05 <tuete> monochrom: what distinction? why cant IO or ST be instances of MondState?
17:13:47 <ddarius> tuete: What would the methods do?
17:14:14 <monochrom> Because Haskell is strongly typed.
17:14:23 <tuete> ddarius: of MonadState? get would read a global IO/STRef and put would set it, i guess
17:15:34 <monochrom> That defeats the purpose of IO and ST.
17:15:34 <Saizan> tuete: that wouldn't be much useful, also to have a global IO/STRef you need unsafePerformIO
17:17:32 <monochrom> The point of IO and ST is you can and you will create a million ref's. The point of MonadState is you can't and you won't. There is nothing more antipodal than this.
17:17:35 <tuete> Saizan: ok, so i'd have to wrap IO and ST into a StateT to use it as a StateMonad?
17:18:49 <Saizan> why do you want to use IO or ST as a MonadState? as monochrom said they fulfill very different needs
17:20:07 <Saizan> MonadState is for when you have to thread around one (or a small number of) datastructures, IO/STRefs instead give you mutability
17:20:09 <tuete> if you implement an algorithm based on e.g. mutable array operations, how do you parameterize on the monad choice?
17:20:33 <Saizan> that's yet doable with the MArray class
17:20:37 <sjanssen> tuete: see MArray
17:21:06 <tuete> ahh, thanks alot
17:21:19 <Saizan> you can write a similar class for Refs if you need, but it's not in the standard libraries
17:30:07 <nornagon> @. pl src mapM
17:30:07 <lambdabot> (line 1, column 1):
17:30:07 <lambdabot> unexpected end of input
17:30:07 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
17:30:13 <nornagon> @src mapM
17:30:13 <lambdabot> mapM f as = sequence (map f as)
17:30:20 <nornagon> @pl sequence (map f as)
17:30:20 <lambdabot> sequence (map f as)
17:30:24 <DukeDave> Heya, I've just been playing with some fuzzy logic in Haskell stuff & have come across an oddity. I've just loaded this into Hugs:    "instance Eq (a -> b) where {f == g = f == g}"
17:30:28 <nornagon> @pl \f as -> sequence (map f as)
17:30:28 <lambdabot> (sequence .) . map
17:30:48 <tuete> one cannot build transformer versions of IO / ST, right? so how can i equip some underlying monad (not using IO or ST) with operations on IO / ST? do i have to "embed"/"run" it in IO/ST myself? what if the interface hides "running"?
17:31:09 <DukeDave> Now when I try to test it, e.g:    "(\x -> x + 4) == (\x -> x + 4)"  it just runs off into an infinite loop
17:31:30 <nornagon> er, yes
17:31:46 <ddarius> DukeDave: You were expecting something else?
17:31:48 <nornagon> > let f a b = f a b in f undefined undefined
17:31:52 <lambdabot> Terminated
17:32:12 <nornagon> you can't usefully define an instance Eq (a -> b)
17:32:16 <nornagon> due to the halting problem
17:32:21 <DukeDave> ddarius: To be honest I wasn't sure it would even be allowed
17:32:38 <nornagon> well, you've defined a function to call itself
17:32:42 <DukeDave> nornagon: My thoughts exactly
17:32:48 <nornagon> so when you run it, it calls itself ;-)
17:32:56 <ddarius> DukeDave: You define functions that call themselves all the time.
17:33:34 <samreid> tuete: Could you define 'underlying' (or give an example)?
17:33:40 <DukeDave> I need it because I (legitimately) need to make my (a -> b) an instance of Num (specifically when b is and instance of Num)
17:34:03 <ddarius> DukeDave: instance Eq (a -> b) where {}
17:34:19 <DukeDave> But (Eq a, Show a) => Num a
17:34:33 <ddarius> Or since the default definitions are circular, instance Eq (a->b) where (==) = "not implemented"
17:34:42 <ddarius> +error
17:35:29 <DukeDave> I'm not sure what you mean by "the default definitions are circular?"
17:35:41 <dolio> @src Eq
17:35:42 <lambdabot> class  Eq a  where
17:35:42 <lambdabot>     (==), (/=)   :: a -> a -> Bool
17:36:32 <tuete> samreid: the monad i want to transform. eg StateT Int IO, then IO would be "underlying" monad. ^^
17:36:32 <DukeDave> .. In the sense of double negation?
17:37:13 <samreid> tuete: so you want something independent of IO to perform IO actions?
17:37:19 <dolio> There are default implementations.
17:37:32 <dolio> x /= y = not (x == y) and x == y = not (x /= y)
17:38:11 <dolio> So if you don't define either, it'll loop infinitely.
17:38:30 <DukeDave> Ah gotcha, thanks dolio I did not know that's how it worked
17:38:37 <tuete> samreid: yes, i guess the usual thing to do is just run it. but what to do when the "embedding" is incompatible?
17:38:38 <DukeDave> dolio++
17:39:16 <tuete> samreid: if i have a State-based value in IO, i just use runState ...
17:39:27 <DukeDave> karma dolio++
17:39:37 <dolio> @karma
17:39:37 <lambdabot> You have a karma of 8
17:39:38 <tuete> samreid: but what to do if im in some monad not able to use the corresponding run?
17:39:53 <DukeDave> lambdabot, karma dolio++
17:39:57 <samreid> tuete: ok, I'm not sure what you mean by State-based value in IO
17:40:02 <dolio> @karma
17:40:02 <lambdabot> You have a karma of 8
17:40:12 <DukeDave> Hm, not the command?
17:40:32 <dolio> ++ doesn't give acknowledgement.
17:40:43 <dolio> That looks higher than it was, though.
17:40:46 <DukeDave> Oh right, lol
17:40:51 * DukeDave blushes
17:40:52 <tuete> samreid: a value of type State Int String for example is "based on an Int-State" ^^
17:40:53 <dolio> I don't know why the last one didn't do anything, though.
17:41:24 <ddarius> dolio++
17:41:26 <ddarius> @karma
17:41:26 <lambdabot> You have a karma of 1
17:41:32 <Saizan> tuete: you always have to convert you values to some kind of IO action in the end, transformers are there only to hide the fact that everytime you're running and reconstructing your monad
17:41:46 <dolio> Well, that raised it.
17:41:53 <dolio> Maybe it has some kind of flood control.
17:42:13 <ddarius> @karma dolio
17:42:13 <lambdabot> dolio has a karma of 9
17:42:14 <ddarius> lambdabot: dolio--
17:42:14 <ddarius> @karma dolio
17:42:15 <lambdabot> dolio has a karma of 9
17:42:41 <samreid> tuete: and what do you mean by "in IO"?  What's a value in IO?
17:42:45 <tuete> Saizan: so there is no way other than using unsafe-operations in that case?
17:42:54 <dolio> Or they changed it to require it on a line by itself?
17:43:04 <tuete> samreid: if im in an IO-typed do-expression
17:43:09 <Saizan> tuete: unsafe operations? in which case?
17:44:53 <Saizan> tuete: my point is that every monad that's not IO is going to have a run function, at least one that converts it to an IO action
17:45:13 <tuete> Saizan: the contrived case is being in the Identity-Monad using unsafePerformIO. ^^
17:45:55 <kpreid> Saizan: What's the run function for the list monad?
17:46:05 <Saizan> kpreid: head?
17:46:57 <dolio> Most of the monads in haskell need a run function because they require a newtype wrapper.
17:47:01 <kpreid> Okay, so what is the definition of a run function?
17:47:09 <dolio> (->) e doesn't have a run function, for instance.
17:47:32 <tuete> so if no run function is exported the monad is always unusable, right?
17:47:37 <ddarius> lambdabot doesn't parse ++ and -- when spoken to it (apparently)
17:47:47 <ddarius> @karma- dolio
17:47:48 <samreid> tuete: I'm reaaaally confused as to what you're trying to do.  If you want some pure State monad or pure anything monad to have interactive IO, you want to do something that's crazy.  (Maybe it's good-crazy, but it's still crazy.)  Maybe you want to have a monad of the form State (IO ()) a or State s (IO ()) or StateT (IO ()) (State s) a and then explicitly run the IO action you've constructed at the end.
17:47:48 <lambdabot> dolio's karma lowered to 8.
17:47:51 <kpreid> I don't think "fun functions" is a well-defined category
17:48:04 <kpreid> er, "run functions" even
17:48:06 <OceanSpray> WE PUT THE FUNK IN FUNKTIONS
17:48:26 <TSC> The run function for (->) e is ($), isn't it? (:
17:48:37 <dolio> Is OceanSpray taking the role of @yow today? :)
17:49:10 <OceanSpray> @yow
17:49:11 <lambdabot> Yow!  It's some people inside the wall!  This is better than mopping!
17:49:45 <ddarius> dolio: That was in the topic for a long long time.
17:50:06 <dolio> I know, but he's been yelling random stuff all day. I think that lisp interpreter has broken his mind. :)
17:50:23 <OceanSpray> dolio, you're right
17:50:34 <OceanSpray> Haskell is mind bending.
17:50:38 <tuete> samreid: i was just wondering if i could reuse my code using StateT to using IO without "embedding" everything into IO
17:50:45 <OceanSpray> My mind just wasn't as flexible as some
17:51:43 <Saizan> tuete: StateT over what?
17:52:24 <samreid> tuete: I don't understand.  Using StateT st IO?  And what's "embedding"?
17:52:33 <tuete> Saizan: Data.Binary's Get
17:53:08 <Saizan> tuete: you want GetT
17:53:43 <tuete> yes, but there is no GetT? :>
17:54:13 <Saizan> i think it's in some experimental repo of binary
17:54:22 <tuete> But its pure, so i should using runGet all over the place?
17:54:23 <Saizan> PutT surely is
17:55:59 <tuete> Saizan: where did you get that repo from? ^^
17:57:20 <Saizan> tuete: i don't have the link :\
17:57:36 * shapr boings cheerfully
17:57:37 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
17:57:39 <shapr> oh?
17:58:54 <tuete> Saizan: as far as i can see its not in http://darcs.haskell.org/binary/src/Data/Binary/
17:58:55 <shapr> OceanSpray: Actually, ChilliX is the source of that quote, "We put the funk in funktion."
17:58:55 <lambdabot> Title: Index of /binary/src/Data/Binary
17:59:40 * shapr boings furiously!
17:59:43 <shapr> yay code!
18:00:09 <shapr> Time to go meet my sister.
18:00:28 <OceanSpray> oh
18:00:29 <OceanSpray> OH
18:00:34 <OceanSpray> I FOUND THE BUG!
18:00:38 <OceanSpray> FINALLY
18:00:53 <shapr> What was it??
18:01:12 <OceanSpray> envLookup returns a Maybe
18:01:26 <OceanSpray> in envSet, I didn't pattern match against that
18:01:35 <shapr> ah!
18:01:35 * wli ponders discrete logarithms.
18:01:38 <OceanSpray> It was so fucking obvious
18:02:08 * shapr ponders indisccete logarithms.
18:02:12 <shapr> um, indiscrete*
18:02:18 <hpaste>  chessguy pasted "Is there a better way to do this?" at http://hpaste.org/2311
18:02:32 <shapr> Some logarithms are just flagrantly nifty.
18:02:52 <chessguy> so, this is a function to build up a chessboard with pieces from a standard notation
18:03:19 <chessguy> in most languages it's a real pain in the butt. this solution is fairly elegant, but i'm wondering if it could be even more so
18:03:53 <OceanSpray> IT COMPILES
18:03:55 <OceanSpray> SUCCESS!
18:03:59 <chessguy> in particular, i'd like to hide that Int away a bit more
18:04:17 <joed> OceanSpray: Ship IT!!!!
18:04:26 <chessguy> @quote ship
18:04:27 <lambdabot> Bulat says: Base lib includes everything, from 'const' to starship control
18:04:41 <OceanSpray> what
18:07:37 <joed> OceanSpray: It compiles == Synergies leveraging common best enterprise practices for superior delivery of enterprise grade services?
18:07:58 <OceanSpray> lulwut
18:08:19 <fnord123_> Just because it compiles doesn't mean it's bug free.
18:08:24 <shapr> joed: bwahahaa
18:08:52 <joed> fnord123_: You missed the whole point and about 10 years of working in the real world.
18:08:54 <chessguy> fnord123_, not quite, but almost
18:09:02 <geezusfreeek> gah, stupid flaky comcast internet connection
18:09:09 <gigamonkey_> shapr: after our discussion last night I'm inspired to start unicycling when I take the dog for a walk.
18:09:13 <shapr> Yay!
18:09:17 <shapr> gigamonkey_: Have you bought a new uni?
18:09:23 <gigamonkey_> Nah.
18:09:44 <chessguy> shapr, heh. my mind expanded that to 'university' for a minute
18:09:45 <gigamonkey_> Maybe if I get really into it again. For now by old beater will do--better exercise that way.
18:09:47 <shapr> Schwinn are notoriously painful, it's worth it.
18:10:20 <gigamonkey_> shapr: have you seen  this http://www.youtube.com/watch?v=9xuUzuklkoU?
18:10:39 <fnord123_> I guess po-faced hasn't caught on here. http://www.worldwidewords.org/qa/qa-pof1.htm
18:10:41 <lambdabot> Title: World Wide Words: Po-faced
18:11:10 <shapr> I don't have flash installed right now (doesn't work on 64bit linux).
18:11:29 <shapr> Is it that chinese girl doing the freestyle dance where she stands up on the unicycle on one foot?
18:12:50 <gigamonkey_> shapr: that's the one.
18:13:04 <shapr> gigamonkey_: Check this out: http://picasaweb.google.com/shae.erisson/OakMountain20070127/photo#5025111427466324306 and be aware that I weigh 230 pounds or so :-)
18:13:06 <lambdabot> Title: Picasa Web Albums - shapr - Oak Mountain ..., http://tinyurl.com/252mym
18:13:33 <gigamonkey_> Man, that's a big fat tire.
18:13:39 <shapr> Yeah, 3.7 inches.
18:13:39 <gigamonkey_> On the unicycle I mean. ;-)
18:13:41 <shapr> haha
18:14:22 <gigamonkey_> Sorry, I wasn't trying to be funny but realized too late that that could be taken two ways.
18:14:38 <shapr> I hadn't thought of that, it is funny :-)
18:14:57 <shapr> Mountain unicycling is lots of fun.
18:15:12 <shapr> And mountain bicyclists give me lots of shocked looks.
18:15:35 <shapr> I think that's because they have tire envy.
18:17:39 <gigamonkey_> Are the shin guards to protect you from the pedals?
18:19:01 <shapr> gigamonkey_: Yeah, that and falling down. I fall on my knees mostly.
18:19:48 <shapr> gigamonkey_: If we meet up, I'll bring it and you can try it.
18:20:37 <shapr> The only drawback of that unicycle is that it has too much traction, it's difficult to turn on asphalt or sidewalks. Other than that it's perfect.
18:21:23 <reffie> everything has beauty, but not everyone sees it.
18:21:32 <shapr> Yup
18:21:53 <gigamonkey_> It's funny, watching some of these Xtreme Unicycling videos on YouTube, I can more easily imagine being able to do those things than the equivalent tricks on a bike.
18:22:42 <gigamonkey_> shapr: presumably if you used a smoother tire it'd be better for urban riding.
18:22:48 <shapr> yup
18:23:00 <gigamonkey_> Okay, sorry guys. I know this is supposed to be about Haskell. I'll be back after I've read more of YAHT.
18:23:01 <OceanSpray> What do you do when one line is so long it crops, but you can't newline it because of Haskell's syntax?
18:23:09 <shapr> dcoutts has a cool street unicycle with a 26" smooth tire and tiny little cranks, it's fun!
18:23:14 <OceanSpray> btw, I hate semicolons and sqiggly brackets.
18:23:19 <shapr> gigamonkey_: Yay Haskell!
18:23:27 * shapr goes off to meet his sister 
18:23:28 <jcreigh> gigamonkey_: there's #haskell-blah for fun off-topic stuff.
18:23:29 * shapr &
18:24:03 <kpreid> OceanSpray: what do you think needs to be one line?
18:24:51 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/2312
18:24:56 <OceanSpray> this
18:25:15 <OceanSpray> the rightmost Nothing -> ...
18:25:30 <OceanSpray> In emacs, ir crops
18:25:38 <kpreid> you don't have to indent that far
18:25:52 <OceanSpray> how do I shorten that?
18:26:01 <OceanSpray> I don't like all those case expressions, either
18:26:15 <geezusfreeek> OceanSpray, without looking at your code, i generally resort to user let/where if i can't cleanly fit things the way i want
18:26:23 <kpreid> | Symbol str -> case c of
18:26:23 <kpreid> |   Pair d e -> do
18:26:23 <kpreid> |     f <- ...
18:26:25 <kpreid> like that
18:26:30 <kpreid> (without the |)
18:26:39 <OceanSpray> you can do that?
18:26:42 <kpreid> yes
18:27:12 <kpreid> all that matters is that it's more indented than the previous line, not than the starting keyword (case/do)
18:27:23 <OceanSpray> huh
18:28:03 <OceanSpray> well, pressing tab in emacs gives me the (Pair d e) below case c of as the 'sole indentation'
18:28:17 <midfield> @seen dons
18:28:18 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 17h 55m 34s ago.
18:28:41 <sjanssen> OceanSpray: you might try using an error monad
18:29:05 <OceanSpray> i am using an error monad
18:29:13 <sjanssen> oh right, you are
18:29:26 <sjanssen> okay, then there's a trick you should know
18:29:43 <kpreid> OceanSpray: for the "WrongType" case, I'd suggest a function
18:30:01 <sjanssen> if you've got (do (Pair car cdr) <- foo; blah; blah; blah)
18:30:02 <wli> projecteuler #133 is giving me real trouble
18:30:11 <kpreid> OceanSpray: of type LispVal -> IO SymbolName:
18:30:21 <OceanSpray> wha?
18:30:24 <OceanSpray> what for?
18:30:36 <sjanssen> if the result of 'foo' doesn't match Pair, then that code will automatically throw an exception
18:30:37 <kpreid> to wrap up the unwrap->liftIO->typecheck
18:30:50 <sjanssen> however, you don't have control over which exception is thrown
18:30:52 <kpreid> sjanssen's idea is good too
18:31:20 <sjanssen> OceanSpray: what is "NumArgs 2"?  Is it just a generic error?
18:31:59 <OceanSpray> it's supposed to signal that a different number of args were provided than in the function definition
18:32:02 <kpreid> OceanSpray: unwrapSymbol s = do s' <- liftIO (unwrap s); case s' of Symbol str -> return str; _ -> throwError (WrongType "symbol" s')
18:32:14 <OceanSpray> here, I just use it because it's the most fitting.
18:32:19 <kpreid> OceanSpray: then you can write in your code just str <- unwrapSymbol car
18:32:26 <OceanSpray> huh.
18:32:29 <kpreid> no cases.
18:32:41 <sjanssen> OceanSpray: which monad/group of monad transformers are you using?
18:32:50 <OceanSpray> well
18:33:01 <kpreid> defSetBind obj env action = do (car, cdr) <- unwrapPair obj; str <- unwrapString car; ...
18:33:05 <OceanSpray> I've got ErrorT, IO and IORef
18:33:12 <sjanssen> IORef isn't a monad
18:33:24 * sjanssen likes being pedantic
18:33:27 <OceanSpray> and there's Maybe, because some procedures don't return anything
18:33:34 <kpreid> as you can see, this form is *MUCH* shorter than the explicit cases form
18:33:46 <OceanSpray> kpreid, I see what you're getting at
18:34:59 <thou> hi, i'm looking for a pointer to how i can peek/poke into a C struct when i have a pointer to it.  in particular, i want to use this API (man curs_mouse): typedef struct { short id; int x, y, z; mmask_t bstate; } MEVENT;   int getmouse(MEVENT *event);   int ungetmouse(MEVENT *event);
18:35:20 <thou> any code that might be similar that i could study?
18:35:57 <thou> using ffi, of course
18:36:39 <thou> i couldn't quite tell what part of the ffi addendum is appropriate
18:38:59 <sjanssen> thou: we usually use a preprocessor to help automate that
18:39:14 <sjanssen> thou: hsc2hs comes with ghc and has decent docs in the ghc manual
18:40:53 <thou> sjanssen: ok, i'll study up, thanks
18:45:46 <fiveleavesleft> hi folks. i'm a haskell newby - just picked up the language this morning. i wonder if someone would mind giving me some stylistic advice?
18:46:00 <fiveleavesleft> i started with a simple prime number generator: http://hpaste.org/2313
18:46:23 <chessguy> _primes is not a good name
18:46:29 <fiveleavesleft> and i have some questions: is this the ideomatic way to encapsulate "sub functions" in haskell? am i getting the efficiencies from lazyness that i think i am?
18:47:05 <fiveleavesleft> chessguy: i'm from a python background, where leading underscores are an ideomatic way to indicate a "semi-private" function...
18:47:10 <joed> fiveleavesleft: You might want #haskell-cafe?
18:47:16 <fiveleavesleft> hmm.. maybe. :)
18:47:22 <fiveleavesleft> is that a more newby-oriented forum?
18:47:32 <chessguy> fiveleavesleft, understood. i'm just letting you know that it's not idiomatic haskell
18:47:43 <chessguy> this channel is plenty newby-oriented
18:48:12 <joed> cool, then I do not need to leave.
18:49:26 <Cale> fiveleavesleft: the corresponding idiom here is typically to append a ' to the name
18:49:38 <Cale> which is used to indicate a variation of some sort
18:50:03 <fiveleavesleft> hmm.. very mathematical. ;)
18:50:18 <chessguy> welcome to haskell :)
18:50:54 <fiveleavesleft> that will take some time to get used to - to my interpreted language-jaded eyes primes' doesn't hang together as an identifier...
18:51:07 <xpika> whats the haskell function for sleep?
18:51:14 <fiveleavesleft> apart from that, would the nested "where" clauses be considered bad style?
18:51:25 <samreid> xpika: System.Posix.Unistd.sleep?
18:52:21 <desp> what functions are necessary to define an instance of Enum?
18:52:43 <pjd> fiveleavesleft: you can say divisible = (==0) . rem
18:52:49 <mdmkolbe> If a writer monad, models an output stream, then what models an input stream?  (I could write my own, but if there is a standard name, I would prefer to use that.)
18:52:56 <desp> I know it can be derived, but I need to start the enumeration at -1 instead of 0
18:53:11 <samreid> desp: toEnum, fromEnum
18:53:33 <nornagon> @src mapMaybe
18:53:34 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:53:38 <chessguy> mdmkolbe, Reader you mean?
18:53:38 <nornagon> @src Maybe.mapMaybe
18:53:39 <lambdabot> Source not found. It can only be attributed to human error.
18:53:45 <chessguy> @hoogle Reader
18:53:45 <lambdabot> Control.Monad.Reader :: module
18:53:45 <lambdabot> Control.Monad.Reader.Reader :: r -> a -> Reader r a
18:53:45 <lambdabot> Control.Monad.Reader.Reader :: newtype Reader r a
18:53:49 <desp> samreid: ah. do you know where should I look for this information in the future? library source?
18:54:05 <samreid> desp: I got that from http://www.haskell.org/onlinereport/standard-prelude.html
18:54:07 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
18:54:17 <desp> ah. thanks.
18:54:20 <desp> samreid++
18:55:19 <mdmkolbe> chessguy: No.  Reader models an environment that is passed top down.  I want a state that is passed horizontally (like a state), but can't be "set".  It can only have part of it read off.
18:55:48 <mdmkolbe> chessguy: Think of it as modeling the semantics behind "getChar"
18:56:15 <mdmkolbe> chessguy: The State monad is more powerfull than actually neaded
18:56:21 <mdmkolbe> s/neaded/needed/
18:56:22 <wli> MonadSupply?
18:57:28 <Cale> fiveleavesleft: They're fine. Some people don't like nesting them, but I think it's all right.
18:57:29 <mdmkolbe> wli: that matches what I need
18:57:57 <fiveleavesleft> thanks, cale.
18:58:54 <chessguy> @go MonadSupply
18:58:56 <lambdabot> http://haskell.org/haskellwiki/NewMonads/MonadSupply
18:58:56 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
19:00:17 <hpaste>  Cale annotated "newby advice" with "minor alterations" at http://hpaste.org/2313#a1
19:00:46 <mdmkolbe> Hmm, that implementation is based on MonadState.  Would that cause problems for a monad stack containing both monad supply and state?
19:01:16 <Cale> oops, left an _
19:01:39 <wli> mdmkolbe: You have to define the transformer instances properly; as it stands in the wiki it doesn't have the instances to stack anyway.
19:01:43 <chessguy> @pl \x -> x^2 > c
19:01:44 <lambdabot> (> c) . (^ 2)
19:02:45 <Cale> fiveleavesleft: one small problem with this implementation is that lst is constantly being appended to with a single element -- that's extremely expensive to do.
19:03:19 <desp> hmm
19:04:51 <fiveleavesleft> hmm... i'll ponder a while to see if there's some obvious way to avoid that...
19:05:22 <Cale> though actually, it doesn't seem too bad here, this is already quite a bit faster than more naive algorithms
19:12:03 <monochrom> Who is appending, and why?  Most often, knowing the real why, a better algorithm can be written.
19:12:50 <fiveleavesleft> monochrom: we're talking about this piece of code http://hpaste.org/2313 written by a rank haskell newbie (me) asking for stylistic advice...
19:14:44 <pjd> fiveleavesleft: i think he was being rhetorical
19:16:21 <fiveleavesleft> pjd: well, i'm just simple practical folk, unused to such rhetorical abstractions. ;) nevertheless, i'd be interested to know whether there is some way, in this particular bit of code, to avoid the append.
19:17:11 <monochrom> Cale has a type. _primes' should be primes'. I'm also wondering why 2 is missing.
19:17:37 <Cale> Yeah, I pointed that out above
19:17:42 <Cale> (the typo)
19:18:14 <wli> Cale: What's this?
19:18:22 <Cale> what's what?
19:18:33 <monochrom> I will take some time to do some other things and then come back to this.
19:18:48 <wli> Cale: What's faster than naive algorithms?
19:18:50 <fiveleavesleft> no rush.
19:19:16 <Cale> fiveleavesleft's primes.
19:19:42 <wli> fiveleavesleft: Where's that?
19:20:14 <fiveleavesleft> http://hpaste.org/2313
19:20:31 <fiveleavesleft> the algorithm's not interesting (simple sieve of erastosthenes) - i was just asking for some stylistic advice.
19:26:48 <desp> fiveleavesleft: just FYI, that doesn't appear to be the sieve of Eratosthenes
19:27:22 <desp> fiveleavesleft: http://www.haskell.org/pipermail/haskell-cafe/2007-February/022666.html
19:27:25 <lambdabot> Title: [Haskell-cafe] Re: Genuine Eratosthenes sieve [Was: Optimization fun], http://tinyurl.com/yphbu2
19:27:52 <Cale> Depends on how picky you are about defining the Sieve of Eratosthenes.
19:28:12 <HWSOD> @hoogle MonadState
19:28:12 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
19:28:21 <wli> Implementing the Sieve of Atkin as a lazy list might be useful.
19:28:24 <desp> Cale: I think the algorithms here have rather different complexities, no?
19:29:00 <desp> Cale: even if not, the "genuine" sieve beats the pants off the "quasi" sieve in terms of speed
19:29:05 <fuxxx> < Cale> fiveleavesleft: one small problem with this implementation is that lst is constantly being appended to with a single element -- that's extremely expensive to do. <- re this, what's a good/the standard way of having a "head which defaults to a value if list is empty"? i usually do this as "head (list ++ [default])".. should i do an if null list then default else head list instead?
19:32:38 <fiveleavesleft> lol. i should have hedged with a disclaimer - yes, i'm aware that this isn't the classic sieve algorithm.
19:32:39 <Cale> fuxxx: In that case, you're not paying too severely for it, since it's just once.
19:33:08 <desp> fiveleavesleft: :)
19:33:56 <Cale> fuxxx: ((++) is still lazy, so it's not like you're going to rebuild the whole list there)
19:34:19 <fuxxx> cale, i do it many many times when processing a bunch of lists.. just wondered if there was a "standard" function or idiom for it.. couldn't find anything in the libs.
19:34:22 <fuxxx> ok
19:34:39 <fuxxx> so if the list is non-null, it won't cost anything? (or O(1) to build the expression)
19:35:23 <HWSOD> if i have a f of type 'ErrorT E (StateT S (Reader E))' can i use 'get' in f to get the S? cause it seems to want to give me the E?
19:35:41 <Cale> primes' = 2 : [x | x <- [3, 5 .. ], all (\p -> x `mod` p > 0) (factorsToTry x)]
19:35:41 <Cale>     where factorsToTry x = takeWhile (\p -> p*p <= x) primes
19:35:57 <Cale> that's actually a little faster than fiveleavesleft's version though
19:37:01 <joed> for asking style advice, fiveleavesleft I'd say you got all you axed for.
19:37:18 <fiveleavesleft> is there a standard library for doing timing comparisons for code snippets (python has a handy little inclusion in the std library for this).
19:37:20 <Cale> fuxxx: well, for example:   head ([1..] ++ [default]) = head ((1:[2..]) ++ [default]) = head (1 : ([2..] ++ [default])) = 1
19:37:26 <fiveleavesleft> joed: hehe. indeed.
19:37:44 <Cale> fuxxx: so it doesn't cost O(n) time there, because you don't end up using the whole list
19:38:02 <Cale> fiveleavesleft: I've been using  :set +s  in ghci
19:38:49 <fiveleavesleft> cale: ah. that's handy.
19:39:50 <HWSOD> never mind
19:39:53 <Cale> oops, also a typo there, shouldn't be primed :)
19:40:07 <Cale> primes = 2 : [x | x <- [3, 5 .. ], all (\p -> x `mod` p > 0) (factorsToTry x)] where factorsToTry x = takeWhile (\p -> p*p <= x) primes
19:40:10 <fiveleavesleft> cale: i presume you then do something like "take 10000 primes" - is there a simple way to avoid timing IO in that circumstance?
19:40:23 <Cale> I like wrapping it in length
19:40:47 <Cale> It won't time IO anyway
19:40:59 <fiveleavesleft> oh, good.
19:43:01 <chessguy> @pl f p = p `m` 16
19:43:01 <lambdabot> f = (`m` 16)
19:43:04 <fiveleavesleft> interesting: there must be some sort of optimisation going on here:
19:43:34 <fiveleavesleft> when i time length (take 50000 primes) i always get 0.0 secs.
19:43:56 <chessguy> > 17 `div` 16
19:43:57 <lambdabot>  1
19:44:07 <Cale> fiveleavesleft: oh, have you already computed them?
19:44:20 <fiveleavesleft> yes - i'm guessing this is memoisation in action.
19:44:26 <Cale> yeah
19:44:42 <fiveleavesleft> but then, when i don't wrap it in length, i see a non-zero time.
19:44:44 <Cale> Well, it's not so much memoisation as just that they're still in scope
19:45:04 <Cale> hmm, it might be counting the time to convert it to a string
19:45:25 <Cale> (even though I can plainly see that it's not counting all the time to print them to the terminal)
19:45:41 <fiveleavesleft> yes, certainly.
19:46:28 <fiveleavesleft> but the time measured might just be what's needed to write to the IO buffer, rather than actually displaying to screen.
19:46:46 <fiveleavesleft> is there some way to for a function to be re-computed?
19:47:26 <fiveleavesleft> this seems to rather put a spanner in the works of my plan to measure simple algorithm runtimes from the interactive prompt... ;)
19:48:31 <Cale> :r
19:48:51 <Cale> primes is a constant
19:48:59 <Cale> It won't compute it multiple times.
19:49:12 <fiveleavesleft> hmm. yes, tried that - but that means we still have an unexplained optimisation when taking a length of the prime sequence - the timing for this is 0.0 regardless of reload.
19:49:13 <Cale> (unless you reload the file, which throws away everything)
19:49:21 <Cale> oh, heh
19:49:30 <fiveleavesleft> but certianly, unwrapped there is a big time difference after a reload.
19:50:02 <Cale> that is interesting, I suppose you can just reload ghci
19:50:08 <hpaste>  monochrom annotated "newby advice" with "without append" at http://hpaste.org/2313#a2
19:50:29 <Cale> You could also turn the definition of primes into a function.
19:50:50 <monochrom> fiveleavesleft: that is an edition eliminating append. You will need some time to understand what's going on and why it works nicely.
19:51:16 <fiveleavesleft> i'm checking it out right now - thanks for taking the time, monochrom.
19:51:19 <Cale> for example:
19:51:24 <Cale> primes () = ...
19:52:16 <Cale> The results of functions are never kept around unless they're bound to variables.
19:53:09 <fiveleavesleft> monochrom: ok, i see. so, i assume that primes is nevertheless not being computed twice in your version.
19:53:20 <fiveleavesleft> monochrom: and this is due to memoisation?
19:53:21 <wli> gah, there's a bug in my "fast primes" crap
19:53:23 <Cale> yeah, that's quite a lot like the other version I pasted -- you already have the primes list that you're defining :)
19:54:03 <fiveleavesleft> yes, this has been interesting - that was a niggle while i was writing the funciton, but i didn't realise that it might be efficient to just re-use the definition...
19:54:12 <Cale> fiveleavesleft: memoisation isn't quite the right term for it, but sort of, yeah
19:54:43 <monochrom> "tying the knot" is a closer term
19:54:58 <Cale> memoisation is a term which is usually reserved for the technique of caching the results of a function applied to given parameters in an array or map of some kind
19:55:17 <fiveleavesleft> what would be the right term? by memoisation i understand that there is no need to recompute the results of a pure function for a given set of arguments, and that these results can therefore be memoised...
19:55:18 <monochrom> Previously you had one list as internal state and another list as answer. I unified them.
19:55:19 <Cale> This is just defining a list in terms of itself.
19:55:26 <dolio> Some people refer to sharing as memoization, too.
19:55:33 <dolio> Which leads to lots of fruitless arguments.
19:55:40 <monochrom> The answer is also reused as internal state for more answers.
19:56:07 <Cale> fiveleavesleft: That's not actually done -- what is done is sharing: if a function parameter is duplicated in the body of a function, the computation of that parameter is shared between the copies
19:56:39 <fiveleavesleft> monochrom: so what is the specific mechanism that stops this unification from being inefficient?
19:56:53 <Cale> Also, constants are only computed once when they're first needed and never again until they've gone out of scope and back.
19:57:09 <monochrom> Memoisation is certainly one mechanism making this tying-the-knot possible. Another is delayed evaluation.
19:57:42 <fiveleavesleft> hmm... i would guess that how much and what is "cached" or "shared" is down to the compiler/interpreter, right?
19:57:46 <Cale> for example, if you define a constant in a 'where' clause, it will be kept around for all the uses within a particular call to that function, but thrown away when the function call completes
19:58:14 <chessguy> @type maybe
19:58:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:58:20 <Cale> It is, technically, but what I'm talking about here is what ordinary implementations do
19:58:55 <Cale> Technically, the order of evaluation of Haskell code isn't even defined by the standard, but the common thing to do is lazy evaluation.
19:59:19 <fiveleavesleft> very interesting. so, another question: is there any standard way for the user to control what gets memoized or cached?
19:59:24 <Cale> (you can use any order which has non-strict semantics -- that is, has the same termination behaviour as lazy evaluation)
19:59:47 <Cale> Well, results of functions are never cached
19:59:59 <fiveleavesleft> with my python hat on, i write web frameworks, and i'm thinking that memoizing static computed content might be a great way to gain efficiency almost automatically...
20:00:26 <Cale> If you want them to be, you need to define a constant data structure whose elements are the results of the function calls, and do lookups in that.
20:01:06 <Cale> Lazy evaluation makes that fairly easy to do, though it takes a little care when you're doing it with recursive functions.
20:01:47 <Cale> (you have to make sure the recursive calls look in the data structure too)
20:02:26 <lokadin__> is there a default variable with the value of pi?
20:02:30 <Cale> > pi
20:02:30 <samreid> > pi
20:02:32 <lambdabot>  3.141592653589793
20:02:33 <lambdabot>  3.141592653589793
20:02:39 <lokadin__> kk :-) thanks
20:02:42 <Cale> > pi :: Float
20:02:43 <lambdabot>  3.1415927
20:02:46 <Cale> > pi :: Double
20:02:47 <samreid> :t pi
20:02:48 <lambdabot>  3.141592653589793
20:02:49 <lambdabot> forall a. (Floating a) => a
20:02:59 <Cale> > pi :: Complex Doublw
20:03:00 <lambdabot>   Not in scope: type constructor or class `Doublw'
20:03:00 <Cale> > pi :: Complex Double
20:03:01 <lambdabot>  3.141592653589793 :+ 0.0
20:03:11 <chessguy> @src Eq
20:03:11 <lambdabot> class  Eq a  where
20:03:11 <lambdabot>     (==), (/=)   :: a -> a -> Bool
20:03:42 <thoughtpolice> i'm still kind of fuzzy on the whole laziness vs. strictness thing; I mean, I get the concepts and whatnot, but i'm still at a loss for example how to determine when something should be strict vs. lazy (for example, when to use bang patterns in a constructor)
20:05:16 <lokadin__> is there any Haskell based astronomy software?
20:05:24 <lokadin__> something like Stellarium?
20:05:38 * lokadin__ wonders
20:05:49 <thoughtpolice> from the looks of it, laziness is really a very good way to go in most cases, but i'm still at a loss as to how to determine when *not* to be lazy.
20:05:59 <Cale> thoughtpolice: did I mention the heuristic I use?
20:07:06 <Cale> Generally, the only places where you want strictness are those where you have a 'large' structure (in terms of number of separately evaluable components), and you're producing a 'small' structure (one with few separately evaluable components)
20:07:30 <Cale> ...and you're doing it by summarizing the large structure, not by searching through it
20:07:47 <Cale> That is, you're using most of the parts
20:08:31 <wli> For some reason this sieving code thinks 143 is prime.
20:08:35 <Cale> thoughtpolice: Does that make sense?
20:08:46 <thoughtpolice> so it's more of a "all the data is needed" vs. "you only need a part"
20:08:57 <Cale> wli: hehe, it got tricked!
20:09:16 <Cale> thoughtpolice: and you're producing something small
20:09:33 <Cale> thoughtpolice: like, say, a single integer, or a small record summary
20:10:37 <thoughtpolice> so strictness is generally more preferably when you have some, say, record and you would wish to reduce it to a smaller record (that is, to do the reduction you'll need all the parts anyway)
20:11:02 <Cale> yeah
20:11:04 <MrIP> hi all
20:11:07 * joed raises hand.
20:11:10 <Cale> hello
20:11:28 <samreid> The parsec.Prim source lies.  'many' isn't primitive to avoid stack overflow, it's primitive to catch nonconsumptive arguments.
20:11:29 <Cale> thoughtpolice: The canonical example would be summing a list to produce an Integer
20:11:34 <MrIP> i need help with installing haskell in a gentoo enviroment
20:11:50 <thoughtpolice> Cale: but where does it come in for example when you're using bang patterns in data constructors? I.e. I've seen code such as data ABC = XYC !Int, why would you need the strictness there?
20:12:07 <hpaste>  monochrom annotated "newby advice" with "more food for thought" at http://hpaste.org/2313#a3
20:12:07 <thoughtpolice> or maybe i'm just fuzzy on exactly how to specify strictness in haskell; i've never really had to.
20:12:36 <monochrom> fiveleavesleft: that paste may show the effect of having memoization and not having.
20:13:01 <joed> May I ask a completely whack Friday evening question and get some (Hopefully decent) answers back?
20:14:33 <monochrom> It's still Thurday morning here. :)
20:14:33 <fiveleavesleft> and it's saturday morning here.
20:14:33 <fiveleavesleft> so we have a good spread. ;)
20:14:33 <thoughtpolice> joed: i've always felt asking to ask is like asking for an axing (that is, it gets on my nerves personally,) so shoot. :)
20:14:33 <Cale> thoughtpolice: It just ensures that when the application of the constructor to the parameters is evaluated, that the parameters will be evaluated before any pattern match occurs
20:14:42 <fiveleavesleft> monochrom: does that mean that memoisation was not being used in your first annotation?
20:14:52 <thoughtpolice> Cale: ah.
20:15:20 <monochrom> memoisation is still used in #a2
20:15:38 <Cale> they'll only be evaluated into weak head normal form (WHNF) though, which means, up to determining the top-level constructor
20:15:44 <MrIP> i need help with installing haskell in a gentoo enviroment.. It doesn't deem to be working...
20:15:48 <monochrom> memoisation is also used in #a3. But I have coded #a3 so that a small change will disable memoization.
20:15:52 <Cale> MrIP: What's wrong?
20:16:27 <joed> Yeah, I will.... Working as a Developer today, (Java) since the early 90's (Pascal for Mac) gotten onto OO, Agile, I do testing, left C, C++ (As soon as I could) but was pointed to Haskell by a merited friend of mine,  going past the math - where does one start, what are the examples to pull out, and where does functional programming excel? (I have my own ideas)
20:17:12 <thoughtpolice> MrIP: i think i might already know the answer if it's the problem i'm thinking of. quick quiz: are you compiling ghc and have gcc 4.2?
20:17:18 <Cale> joed: Well, you might start with one of the tutorials... the wikibook and "Yet Another Haskell Tutorial" are pretty good
20:17:20 <MrIP> well, i'm using a script that needs a newer version of GHC then gentoo provides, and i'm using the linux binaries, and it doesn't seem to be using the newer one
20:17:48 <joed> Cale: did that, also did the implement Scheme.
20:17:56 <joed> Cale: That was not my question.
20:18:19 <Cale> joed: ah, okay, I was trying to answer the first bit about where you might start :)
20:18:25 <fiveleavesleft> monochrom: ah, ok. the "primesf ()" is a bit of haskell syntax i'm not yet familiar with. i'll look it up.
20:18:31 <_start> ack
20:18:33 <mdmkolbe> joed: for learning haskell I recommend the book by Paul Hudak, "The Haskell School of Expression"
20:18:52 <joed> Heh. Here we go.
20:18:53 <MrIP> ok
20:18:59 <MrIP> what happened?
20:19:01 <Cale> joed: Haskell is a general purpose language, so asking what it really excels at is a subtle sort of question...
20:19:14 <joed> Cale:
20:19:30 <joed> Sorry for the enter, as is Java (Plus marketing)
20:20:16 <thoughtpolice> MrIP: what version of ghc do the gentoo repositories provide?
20:20:20 <joed> I was wondering if there were any 'home-run' type examples for 'regular' developers, i.e. not math.
20:20:24 <Cale> http://programming.reddit.com/info/2bxc1/comments/c2bzw7 -- here I made a comment regarding what I think some of the major selling points are, though perhaps they're already things you're aware of
20:20:25 <lambdabot> Title: Ask Reddit: What is Haskell good for? (reddit.com)
20:20:36 <MrIP> thoughtpolice: 6.4.2
20:20:37 <mdmkolbe> joes: would parsers count as math?
20:20:44 <wli> There's trickiness with the wheel.
20:20:46 <mdmkolbe> s/joes/joed/
20:21:06 <thoughtpolice> MrIP: ah. when I installed ghc 6.6.1 on my openbsd box, the ports system only had 6.4.2, which I had to install, then use to compile ghc 6.6.1
20:21:26 <MrIP> thoughtpolice: ok, so... compile?
20:21:40 <thoughtpolice> MrIP: so while it might kind of suck, you'll probably want to emerge the 6.4.2 version, and then download the 6.6.1 sources, and compile them using 6.4.2 (if that makes any sense)
20:21:48 <joed> Cale: Thank you - Reading. mdmkolbe I do not think so?
20:21:58 <MrIP> thoughtpolice: yes, i've emerged the older one
20:22:12 <wli> I need the next integer multiple with multiplier coprime to 210.
20:22:13 <thoughtpolice> MrIP: cool, then download the source from http://haskell.org/ghc and build. :)
20:22:14 <lambdabot> Title: The Glasgow Haskell Compiler
20:22:18 <thoughtpolice> MrIP: be warned though,
20:22:35 <thoughtpolice> MrIP: because you're using gentoo I'm assuming you have a fairly up-to-date gcc, yes?
20:22:42 <MrIP> thoughtpolice: yes.
20:22:57 <thoughtpolice> MrIP: ghc 6.6.1 doesn't build with gcc 4.2.x
20:23:05 <mdmkolbe> joed: Haskell is good at a lot of topics that would be considered mathish by computer science professors but that don't have anything to to with numbers.  Examples include parsers with the Parsec library (best parser I have ever seen).
20:23:09 <MrIP> snap...
20:23:10 <thoughtpolice> so if you don't have something like gcc3 installed, you'll need that first.
20:23:15 <MrIP> ok
20:23:38 <thoughtpolice> MrIP: it's fine though. I had already compiled about 80% of everything (compiler + libraries) when i figured that one out. :)
20:23:46 <MrIP> :P
20:24:00 <joed> mdmkolbe: Well, looking at the lambda bot source :) Having written some of the Javabot source, yeah I see what you mean.
20:24:18 <mdmkolbe> joed: If you have a language you want to prototype (e.g. Perl 6), haskell is a great way to write an interpreter fairly quickly (e.g. Pugs is a Perl 6 prototype writen in Haskell).  (Interpreters have a math foundation at least to CS professors.)
20:25:02 <MrIP> emerging GCC 4.1.2
20:25:09 <thoughtpolice> MrIP: but that's the general procedure. I think I've done it about 5 times over the past little while. :) ask back if you need any help, although I think it should be straight forward from there...
20:25:18 <MrIP> :)
20:25:19 <MrIP> ok
20:25:20 <MrIP> ty
20:25:23 <joed> mdmkolbe: I'm old, fat, married and pay for 2 houses. I look for results, hence I started looking here.
20:25:25 <mdmkolbe> joed: there have been a few languages for circuit design implemented in terms of haskell (e.g. Lava and a few others)
20:25:26 <thoughtpolice> MrIP: btw, when you get the sources configure using --with-gcc=gcc-4.1 or whatever
20:25:32 <MrIP> ok
20:25:50 <thoughtpolice> just be sure it's not 4.2. :p
20:26:00 <MrIP> o.O 38 mb GCC?
20:26:01 <MrIP> :p
20:26:15 <joed> mdmkolbe: Never saw that, I did circuitry design some time back.
20:26:22 <Cale> That sounds pretty irritating -- there aren't working binaries for 6.6.1 on gentoo right now?
20:26:37 <thoughtpolice> Cale: it kind of is.
20:26:51 <thoughtpolice> i saw the bug on trac and it's the #1 gentoo-haskell complaint right now.
20:27:13 <thoughtpolice> 'cause, well, everybody on gentoo is probably regularly using 4.2 by now.
20:27:15 <mdmkolbe> joed: I think Lava has been superseeded by other Haskell languages, but I haven't kept tract of them.
20:27:43 <joed> mdmkolbe: Ah, Thank you!
20:28:14 <Cale> joed: There are some companies built on the idea of writing high-assurance software in Haskell.
20:28:27 * joed listens.
20:28:28 <thoughtpolice> joed: also, i don't think this is just me but, i've found after going through some crazy day haskell is one of the languages that's fun to sit down and hack on. :)
20:28:28 <mdmkolbe> joed: Oh yeah.  Haskell has a *very* low bug rate.  If your program type checks, it will often either have no bugs or only bugs that are very obvious.
20:28:36 <Cale> http://www.galois.com/
20:28:37 <lambdabot> Title: Galois, Inc.
20:28:52 <thoughtpolice> proofs are programs... or is that the other way around?
20:28:55 <geezusfreeek> i use ruby and java at work, then i come home and relax with some haskell
20:28:57 <wli> It may be that my trouble with all this has been the buggy wheel optimization for the genuine sieve of Eratosthenes.
20:29:37 * joed bows
20:29:45 <Cale> http://www.haskell.org/haskellwiki/Haskell_in_industry
20:29:46 <lambdabot> Title: Haskell in industry - HaskellWiki
20:30:03 <joed> Thank you guys. Input.
20:30:14 <wli> I use C at work and relax afterward with Haskell.
20:30:44 <thoughtpolice> joed: also, I generally speculate that the type checking is one of the things that any programmer can benefit from massively, even if they're not expert haskellers.
20:31:05 <joed> Heh, I use Java at work and write good Java after work.
20:31:30 <wli> Bondage and discipline programming to the max... all about figuring out what the machine is doing at the lowest level.
20:31:50 <thoughtpolice> i am not exactly the most savvy haskell programmer on earth, you see, but having such very strong type checking is really something that's incredibly nice to have no matter how good you are.
20:31:55 <wli> Haskell is a relief because I completely fscking ignore what the machine is doing at any level and basically just write equations.
20:32:13 <joed> Heh...
20:32:26 <Cale> I think a lot of people have an experience (at least I did), of getting to some point along the learning curve of Haskell, and suddenly having a profound sense that the entire world is insane to still be programming in imperative languages.
20:32:43 <joed> You all do not tell me why functional programming is better than OO theorems.
20:32:47 <geezusfreeek> i like the refactorability of haskell... you can basically change just about anything and feel safe about it
20:32:48 <mdmkolbe> joed: In general any task that has a well defined theoretical definition is usually easy in Haskell.  For example, each of the phases in bz2 compression are about two or three lines of Haskell.
20:33:22 <wli> Bang. projecteuler #133 is dead.
20:33:49 <joed> Cale: Oki that is what I think I'm looking for.
20:34:05 <thoughtpolice> Cale: i feel kind of in a grey area right now, although I typically think of plenty of people as crazy, if that says anything. :p
20:34:10 <chessguy> Cale, i don't think it's always a point
20:34:22 <desp> is it possible to define default typeclass functions in a separate place from the typeclass definition?
20:35:01 <Cale> desp: nope
20:35:08 <monochrom> OO theorems?!
20:35:18 <desp> Cale: ok
20:35:34 <joed> monochrom: Object Oriented desing
20:35:34 <joed> design
20:35:42 <desp> wli: congrats
20:36:20 <thoughtpolice> i was never much on OO, personally.
20:36:29 <wli> desp: It all boiled down to debugging the "optimized" sieve of Eratosthenes.
20:36:29 <geezusfreeek> i still hold to the idea that object orientation isn't really at odds with functional programming
20:36:54 <desp> wli: really? then I probably have this done and I don't even know it ;)
20:37:00 <Cale> OO and FP are sort of dual to one another in at least one way
20:37:01 <joed> Well, lets assert it pays for food.
20:37:05 <desp> must resist urge to get distracted
20:37:10 <geezusfreeek> ideally, i think OO should be orthogonal to the idea of functional programming... it just isn't in practice so far
20:37:23 <Cale> OO uses a lot of existentially quantified types, while FP uses a lot of universally quantified ones.
20:37:24 <fiveleavesleft> i like haskell as a language (after 4 hours of acquaintance ;) but i have trouble imagining modeling a real-world problem domain with it. maybe my head is too bent towards OO, but there has to be some kind of direct conceptual relationship between code and domain...
20:37:40 <fiveleavesleft> and i just feel instinctively that that mapping is easier when thinking of objects than when thinking of functions.
20:37:45 <monochrom> http://www.softlab.ece.ntua.gr/~ykass/work/aToOOR.pdf  is what I would call OO theorems and respectable OO.
20:37:51 <joed> Cale: I'm of the opinion with my minimal clue that more FP knowledge would build better objects.
20:37:53 <mdmkolbe> Cale: heh, that is probably true, but most Java programers won't even know what that means
20:37:57 <desp> fiveleavesleft: have you read the recent article about verbs vs nouns? :)
20:38:09 <fiveleavesleft> desp: no... pointer?
20:38:17 <geezusfreeek> fiveleavesleft, yeah, it took me a while to start realizing in full how large software could be architected in FP
20:38:18 <Cale> mdmkolbe: yeah, I didn't really soften the words there :)
20:38:37 <desp>     isError :: a -> Bool
20:38:41 <desp> er
20:38:44 <geezusfreeek> not that i can really claim to be to that point yet... i haven't yet written anything large in haskell yet
20:38:46 <desp> http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
20:38:48 <lambdabot> Title: Stevey's Blog Rants: Execution in the Kingdom of Nouns, http://tinyurl.com/kxubn
20:38:49 <mdmkolbe> O'Caml is an Object oriented functional language.  (I haven't used it much but it is in the same family as haskell)
20:39:10 <fiveleavesleft> thanks desp.
20:39:27 <thoughtpolice> doesn't Ocaml somewhat eschew the object system a little bit? or at least make it feel like a 'second class citizen'? (note: I don't know ocaml, this is just from what I've read)
20:39:35 <desp> thoughtpolice: yes.
20:39:40 <geezusfreeek> ocaml is only able to do OO so easily because of serious sacrifices elsewhere, in my opinion
20:39:55 <desp> thoughtpolice: in my experience, people tend to prefer parametrized modules over objects in OCaml
20:40:09 <mdmkolbe> also, someone wrote a paper about how OO is already embedded in Haskell, but in disguise
20:40:19 <thoughtpolice> i get intense dislike from looking at ocaml so I don't know much about it,
20:40:25 <desp> OOP is just a frame of mind
20:40:37 <mdmkolbe> though as others have said, OO is usually still not used even if it is possible in Haskell
20:40:44 <monochrom> It is like the biological finding that dinosaurs live on here and now, they are now birds. :)
20:40:44 <thoughtpolice> i tried a few tutorials but just decided to stick with haskell.
20:40:45 <joed> True
20:40:46 <desp> don't abstract datatypes + functions = OOP
20:40:48 <desp> ?
20:41:02 <johnnowak> desp: no
20:41:13 <monochrom> Haha, powerful metaphor there. :)
20:41:31 * monochrom should get some tea to churn out more ideas :)
20:41:43 <desp> johnnowak: why not?
20:42:13 <johnnowak> desp: they're OO in the same sense structs in C can be used for OO
20:42:21 <geezusfreeek> imo, the best of OO+FP so far is Erlang, but only by weakening some definitions of both OO and FP (or at least _my_ definitions)
20:42:30 <desp> then they're perfectly suitable for OOP in my book
20:42:41 <johnnowak> desp: then you're missing all the important parts.
20:42:43 <lament> so you think C is OO?
20:42:45 <geezusfreeek> where Erlang processes stand in for objects, in a sense
20:42:52 <chessguy> desp, that's a cool blog
20:43:28 <thoughtpolice> steve yegge writes some fun stuff.
20:43:31 <desp> johnnowak: such as?
20:43:39 <mdmkolbe> I think OO people think more about the data and function as a single object, where in FP people think more about the functions as transformations on data.  It's all a matter of emphasis.
20:43:57 <lament> no, it's not
20:43:57 <desp> lament: C++ is C with a hidden pointer for all member functions, isn't it?
20:44:01 <Cale> My current view of OO is that it is about forgetting the exact type of value holding some state, and only remembering that it provides a certain interface that it carries around with it.
20:44:06 <fiveleavesleft> mdmkolbe: you're right - and one can't underestimate the importance of emphasis.
20:44:20 <johnnowak> desp: Alan Kay said object-oriented languages should've been called message-oriented languages. Think about it from that perspective.
20:44:30 <lament> Cale: Yes. If you could use classes anywhere where you could use types, that would be a lot more "OO-like"
20:44:43 <thoughtpolice> desp: maybe technically (vtables,) but it encourages a different way of thinking about problems.
20:44:52 <lament> showStuff: [Show] -> IO ()
20:44:58 <thoughtpolice> it could all be one big preprocessor hack, really. same thing.
20:45:07 <Cale> lament: Of course, you can't because the values themselves don't carry around class dictionaries with them.
20:45:13 <thoughtpolice> (maybe it is in reality, I wouldn't know too much about it)
20:45:14 <desp> johnnowak: so you're saying it's impossible to implement a message-passing abstraction in C and utilize it?
20:45:23 <Cale> The class dictionaries travel separately.
20:45:40 <monochrom> Hmm, if I impose strong static typing over "message-oriented program", that would be exactly type classes.
20:45:46 <mdmkolbe> Programming with Haskell style classes is like OO with without "this".  (Almost like multi-method dispatch, but not at runtime (yes, I know that that is a bit of an oxymoron))
20:45:49 <joed> mdmkolbe: I think that is bad OO thinking of and object only
20:45:51 <johnnowak> desp: You can implement whatever you want.
20:46:05 <Cale> But there is already a way in GHC to get datatypes which throw away the exact type information about the values you stick into them and only remember the interface
20:46:13 <Cale> (and that's existential types)
20:46:16 <lament> yes, it's just rilly inconvenient
20:46:19 <desp> I'm not saying it's the easiest way to do OOP, but come on, languages are just tools. C is flexible enough for most methodologies, as long as the programmers keep discipline.
20:46:23 <Cale> It's actually not so bad.
20:46:27 <lament> no, it's pretty bad
20:46:28 <johnnowak> monochrom: Not exactly type classes, but they're close.
20:46:37 <Cale> Oh?
20:46:43 <lament> remember dons ranting about a language not being functional if it doesn't have things like the dot operator
20:46:46 <geezusfreeek> monochrom, type classes are more like templates, i think
20:46:56 <lament> convenience, in the end, determines what style you program in
20:46:58 <Cale> lament: It's fairly good with the record syntax
20:47:31 <joed> lament: unless you own the company you may have to compromise
20:48:18 <geezusfreeek> i think it should be illegal to talk about OO unless you have experience with Smalltalk
20:48:21 <mdmkolbe> Cale: I have to side with lament on this one.  It is *way* to easy to trip over an escaped type variable.  (I've done my share of existential programming. it was never fun, though the results were.)
20:48:47 <Cale> Have you guys seen the small counter example?
20:48:50 <geezusfreeek> which also rules me out slightly as well
20:48:59 <Cale> er, 'counter' example, not counterexample :)
20:49:04 <monochrom> haha
20:49:10 <desp> Cale :)
20:49:15 <joed> geezusfreeek: While correct, you'll never find that on the market today.
20:49:33 <monochrom> To hell with the real world.
20:49:39 <Cale> You just have to be careful about what's private and what's public.
20:51:14 <geezusfreeek> objects would be better modelled in haskell by forking threads in haskell and only communicating among them by message passing over channels, erlang style... this public and private business is as bad as mutable vs. immutable data for large systems
20:51:44 <mdmkolbe> geezusfreeek: something like arrows maybe?
20:51:48 <TSC> Isn't that what rhaskell does?
20:51:52 <thoughtpolice> hm.. speaking of smalltalk, I was thinking about the usefulness of writing syx bindings for haskell. don't know exactly how many people would utilize it too much, though :/
20:52:39 <geezusfreeek> arrows are still beyond my perception of usefulness, right now... the most i can figure with it so far is dataflow-ish modelling
20:52:51 <geezusfreeek> and i haven't even looked at rhaskell...
20:53:15 <joed> heh
21:00:12 <hpaste>  Cale pasted "Counter example" at http://hpaste.org/2314
21:00:56 <Cale> I wouldn't say that's *too* bad.
21:02:33 <lament> "self"?
21:03:01 <Cale> lament: yeah -- notice how it's a different type in each of my example objects
21:03:44 <lament> Cale: what do you do if you want "subclasses", which differ not just in functionality (that's easy - use a different "method") but have an extra state variable?
21:04:21 <Cale> Well, the self type can be anything
21:04:26 <Cale> including a record
21:04:50 <lament> oh, right
21:05:09 <lament> is this type-safe at all?
21:05:13 <Cale> yep
21:05:18 <Cale> It's completely type safe
21:05:38 <lament> what's this extension called?
21:06:00 <Cale> Existential types, in particular, I'm using the GADT record syntax here.
21:06:28 <monochrom> typus existenti.
21:06:55 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification
21:06:58 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
21:08:11 <Cale> You'll see there that they have a very similar example :)
21:08:37 <Cale> (I just removed the extraneous tag stuff)
21:08:38 <lament> oh, so you can't use the usual record syntax to access them
21:08:57 <lament> so if you have an object with 20 methods, it gets tricky to write
21:08:58 <Cale> You can't use the usual record syntax to update them.
21:09:07 <Cale> But you can access them like that
21:09:10 <Cale> (pattern matching)
21:09:26 <Cale> But you really want to do what I did there and write some wrappers.
21:09:43 <lament> so you have to update the definition of each "method" if you add a new one
21:10:05 <Cale> Yeah, along with all the objects that you actually construct.
21:10:09 <lament> this sort of makes sense since you're changing the underlying datatype
21:10:19 <lament> but i wouldn't call it "nice" :)
21:10:25 <Cale> There's a slightly better way to do it.
21:10:36 <Cale> You can use a typeclass for the methods.
21:11:49 <lament> can you show how?
21:12:38 <Cale> of course, then you have to use instances for the objects :)
21:16:42 --- mode: irc.freenode.net set +o ChanServ
21:17:05 <Cale> Well, you typically make that existential wrapper an instance of the class that it carries a dictionary for.
21:17:25 <OceanSpray> hmm
21:17:38 <Cale> thanks freenode!
21:17:50 <sioraiocht> AHHHHHH
21:17:55 <sioraiocht> netsplit?
21:17:56 <geezusfreeek> yay
21:17:58 <Cale> yeah
21:18:10 <sioraiocht> colloquy hates me =/
21:18:14 <lament> Cale: and implement dynamic dispatch manually, as a big case statement, in the class functions for the existential wrapper?
21:18:38 <MrIP> lol
21:18:40 <Cale> lament: hmm, case statement?
21:19:14 <lament> well, a bunch of patterns to match
21:19:48 <Cale> Your wrapper typically has only one constructor with a single parameter
21:21:30 <lament> oh wait, you don't need any pattern matching do you
21:22:31 <lament> is it just something like "draw (Shape blah) = draw blah"
21:22:37 <Cale> yeah
21:23:13 <Cale> (we could almost use some kind of syntax to derive it -- if more people used existential types, we probably would)
21:24:22 <DrChaotic> is there anywhere you can see the slides for this oscon presentation?
21:24:53 <Cale> http://programming.reddit.com/goto?id=2a3dc
21:25:25 <fuzan> someone needs to port xmonad to windows :)
21:25:28 <Cale> or if you're watching on blip.tv, click the "more" link
21:26:16 <DrChaotic> thanks
21:26:49 <Cale> and you'll find the link to the slides
21:26:49 <Cale> It's pretty unwatchable if you don't have the slides open alongside it :)
21:26:49 <Cale> (well, if you're a beginner, at least)
21:26:49 <Cale> If you're an experienced Haskell programmer, you can probably mostly guess what's on the slides :)
21:27:10 <DrChaotic> I've never coded a line of it
21:27:22 <lament> then you probably won't be able to guess :)
21:27:26 <DrChaotic> done a *little* lisp, but thats all
21:27:55 <lament> about the only thing lisp and haskell have in common is that neither is very much like C
21:28:46 <Adamant> they're both based on the lambda calculus.
21:28:54 <DrChaotic> both functional languages, so I've heard...
21:29:16 <lament> lispers deny that at times
21:29:57 <Korollary> lisp is not explicitly based on LC per se. Scheme is.
21:30:24 <DrChaotic> scheme is really what I'm learning at the moment... going through the MIT course.
21:30:49 <lament> Korollary: yet set! is one of the first functions SICP introduces :)
21:31:40 <lament> sorry, "procedures" :)
21:32:27 <DrChaotic> bbiab.. covering my irc window with slides while I watch the video on the other monitor.. thanks again guys :-)
21:32:38 <HWSOD> is there some trick to defining readPrec instead of readsPrec, im using GHC but it wont work.  GHC says readPrec is  not a visible method of Read!
21:32:47 <kilimanjaro> lament, really? I thought it was avoided until chapter 3 (and there are only 5 chapters)
21:33:11 <lament> maybe i misremember
21:33:48 <lament> oh right... it is
21:34:09 <lament> i always assumed the first two chapters were just an intro :)
21:34:26 <kilimanjaro> I'd say the first 3 are an intro
21:34:34 <lament> right
21:34:35 <kilimanjaro> 4 and 5 are where it gets interesting
21:34:42 <lament> right
21:34:43 <kilimanjaro> writing interpreters and compilers for various languages
21:35:51 <OceanSpray> why do hpaste raws lose their formatting?
21:40:29 <olliej> what's the function that while split a list in two according to a given function
21:40:48 <wli> Which book is this?
21:41:41 <lament> SICP? SICP
21:42:16 <wli> I've got that. It's pretty ood stuff.
21:43:24 <OceanSpray> I've ordered it, and for two months it still hasn't arrived
21:43:33 <gnufied> let b = (("hello",4),True)
21:43:34 <OceanSpray> apparently, Amazon couldn't find a copy.
21:43:46 <gnufied> snd fst b #=> doesn't work why?
21:44:20 <gnufied> oops
21:44:27 <lament> gnufied: because that gets parsed as (snd fst) b
21:44:38 <gnufied> yes got it
21:45:07 <lament> > snd $ fst (("hello",4),True)
21:45:12 <lambdabot>  4
21:46:40 <lament> learn the way of the dollar sign and you will be enlightened :)
21:47:05 <gnufied> i was thinking some lisp syntax where parenthesis means something totally different, but apparently in haskell they work a lot like C
21:47:26 <gnufied> oh $
21:47:34 <Olathe> > (snd (fst (("hello",4),True)))
21:47:36 <lambdabot>  4
21:47:40 <kfish> $ can't buy you love, but it can get rid of excessive parentheses
21:47:56 <lament> gnufied: "a $ foo bar baz" is haskell-speak for "a (foo bar baz)"
21:48:44 <lament> and yes, parentheses work a lot like in C, except that you need fewer of them.
21:49:51 <lament> and nobody even stops you from writing "foo(bar)" instead of "foo bar"
21:50:19 <shapr> hiya Insobox
21:50:27 <gnufied> lament, yup, thanks
21:51:09 <gnufied> ok i am just starting out with haskell, and was wondering whats the model for network programming in haskell?
21:51:11 <Insobox> Hey, how you doinh Shapr.
21:51:35 <timthelion> lament: a :: (Foo -> Bar) -> Baz -> A
21:55:06 <TSC> gnufied: What do you mean?  You can make or accept connections, and then read from or write to a network handle like you would a regular file handle
21:56:22 <gnufied> TSC, but i am talking about some higher level frameworks like Twisted(Python) or EventMachine(Ruby)
21:56:35 <gnufied> TSC, if i do that, i would need threads
21:56:44 <TSC> Oh, I see
21:57:20 <TSC> I don't know about that
21:57:21 <lament> gnufied: check out happs.org
21:57:36 <lament> it even says it was inspired by twisted
21:59:07 <gnufied> lament, thanks, looks cool,
22:00:36 <gnufied> basically i am trying to convert a network app written in Ruby(which uses EventMachine, which is again inspired by twisted), i started with erlang, but since my protocol was heavy on string and regular expressions, i had to abandon that quest
22:02:40 <r_rehashed> hi  everybody
22:02:45 <Cale> hello
22:03:41 <r_rehashed> ohh.. i was expecting a hot discussion to be going on, that would enlighten me ;)
22:06:39 * lament hits r_rehashed on the head with a hammer
22:06:49 <Cale> r_rehashed: somehow it just all died off :)
22:06:53 <r_rehashed> hahaha :D
22:07:11 <r_rehashed> ohh..   looks like i came in late
22:07:26 <Cale> > fix ((0:) . scanl (+) 1)
22:07:27 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:07:58 <lament> oh wow, prime numbers! :P
22:08:09 <jcreigh> err...
22:08:12 <Cale> uh, Fibonacci, actually
22:08:21 <samreid> There are some primes in there too.
22:08:29 <jcreigh> > [1..]
22:08:30 <r_rehashed> oh cool. thanks Cale.
22:08:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:08:35 <jcreigh> prime numbers! :P
22:08:39 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
22:08:40 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:08:40 <lament> jcreigh: oh wow!
22:08:55 <wli> The trick with prime numbers is doing it fast.
22:09:09 <lament> never confuse prime numbers with intercourse.
22:09:15 <MrIP> lol
22:09:32 <samreid> > [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,undefined]
22:09:34 <lambdabot>  Undefined
22:09:35 <wli> lament: That would be something I'd rather take very, very slowly.
22:09:36 <samreid> bah
22:09:51 <samreid> > [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,undefined]
22:09:52 <lambdabot>  Undefined
22:10:55 <lament> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103] ++ [undefined]
22:10:58 <samreid> > [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,undefined]
22:10:59 <lament> >[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103] ++ [undefined]
22:11:00 <lambdabot>  Undefined
22:11:13 <lament> > [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103] ++ [undefined]
22:11:15 <lambdabot>  Undefined
22:11:55 <samreid> > [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107] ++ repeat undefined
22:11:56 <lambdabot>  Undefined
22:11:59 <samreid> meh
22:12:15 <lament> it's too smart
22:12:20 <wli> I suppose one could compute the number of primes less than or equal to a given number by means of an infinite list of primes.
22:12:43 <samreid> > (take 1000 $ nubBy (\x y -> y `mod` x == 0) [2..]) ++ repeat undefined
22:12:45 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:12:48 <samreid> aha!
22:12:52 <lament> hah!
22:13:10 <lament> > [1..1000] ++ repeat undefined
22:13:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:13:18 <samreid> > (takeWhile (< 103) $ nubBy (\x y -> y `mod` x == 0) [2..]) ++ repeat undefined
22:13:19 <lambdabot>  Undefined
22:13:24 <lament> > [1..200] ++ repeat undefined
22:13:25 <lambdabot>  Undefined
22:13:26 <samreid> > (takeWhile (< 103) $ nubBy (\x y -> y `mod` x == 0) [2..])
22:13:27 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101]
22:13:34 <lament> > [1..500] ++ repeat undefined
22:13:35 <lambdabot>  Undefined
22:13:41 <wli> Please stop.
22:14:03 <HWSOD> what are you doing?
22:14:43 <wli> Me? Hunting for a rational parametrization of a specific conic.
22:15:27 <wli> Or otherwise trying to generate the integer solutions to it in order.
22:15:45 <HWSOD> i ment more with all the long lists ending in endefined.
22:15:53 <HWSOD> i ment more with all the long lists ending in undefined.
22:16:36 <HWSOD> > undefined
22:16:38 <lambdabot>  Undefined
22:16:57 <hpaste>  (anonymous) annotated "newby advice" with "(no title)" at http://hpaste.org/2313#a4
22:23:53 <gnufied> emacs mode of haskell looks screwed up or I am missing something
22:24:05 <gnufied> I am using this mode: http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode
22:24:06 <lambdabot> Title: Emacs Lisp packages
22:24:22 <gnufied> its formatting code like this: http://pastie.caboo.se/88869/edit
22:24:24 <lambdabot> Title: New - Pastie
22:24:37 <gnufied> http://pastie.caboo.se/88869
22:24:39 <lambdabot> Title: #88869 - Pastie
22:25:20 <shapr> hiya r_rehashed
22:25:43 <r_rehashed> shapr: Hi shapr :)
22:25:54 <shapr> r_rehashed: How's it going?
22:26:07 <shapr> r_rehashed: Learning anything nifty?
22:26:09 <TSC> gnufied: If you press TAB repeatedly, it will usually give you a sensible indentation
22:26:16 <r_rehashed> great. but not a very great speed yet
22:26:36 <shapr> r_rehashed: Have you got GHC installed?
22:26:42 <r_rehashed> yes
22:26:47 <r_rehashed> i am using ghci
22:26:49 <shapr> Have you tried to write some code?
22:26:55 <gnufied> TSC, hmm, yes but i thought it will do so in one attempt
22:26:59 <r_rehashed> yeah just simple
22:27:04 <r_rehashed> no actual code
22:27:05 <TSC> gnufied: Indentation has meaning in Haskell, so it's impossible for haskell-mode to guess the correct indentation
22:27:14 <shapr> r_rehashed: What do you think so far?
22:27:27 <r_rehashed> about Haskell?
22:27:41 <shapr> Sure, or anything.
22:27:50 <shapr> What languages have you used before?
22:27:54 <shapr> How does it compare?
22:27:56 <glguy> emacs' Haskell mode cycles through the currently meaningful indentation levels
22:27:57 <r_rehashed> just C and Java
22:28:36 <shapr> Most of what you can do in ghci you can also do with lambdabot, it's good for interactive teaching.
22:28:36 <r_rehashed> i  find i need to keep switching between the oops thinking and functional programming thinking
22:28:42 <shapr> > (1 +) 1
22:28:42 <wli> I've got a few issues with all that beyond the fact it's emacs.
22:28:47 <lambdabot>  2
22:28:52 <shapr> > map (1 +) [1,2,3]
22:28:52 <r_rehashed> oh ok
22:28:54 <lambdabot>  [2,3,4]
22:29:15 <shapr> r_rehashed: But if you want to do lots of testing stuff, it's better to do it on #haskell-overflow or in private messages with the bot.
22:29:16 <r_rehashed> man.. i should get faster at learning
22:29:18 <wli> (1) I like hard tabs. Period. No debate.
22:29:26 <r_rehashed> right
22:29:33 <wli> (2) I like 8-space tabstops. Period. No room for debate here, either.
22:29:46 <fuzan> ew.
22:29:59 <r_rehashed> i was wondering whether we could have both OOPS and FP cincepts in one language
22:30:01 <shapr> r_rehashed: Have you tried to write something? I started out with a fractal calculation program.
22:30:05 <shapr> r_rehashed: Yes, you can.
22:30:09 <r_rehashed> both are very powerful
22:30:20 <glguy> wli: Haskell requires 8-space hard tab stops, so you're in luck :)
22:30:23 <r_rehashed> shapr: wow. :D
22:30:39 <wli> glguy: Hard tab == '\t'
22:30:42 <shapr> In my personal opinion, monads do more different in better ways than objects, but we can discuss that later.
22:30:44 <glguy> yeah
22:30:45 <r_rehashed> how do u calculate fractals?
22:30:55 <shapr> Not saying I'm right, just saying that's what I think so far.
22:31:10 <r_rehashed> hmm.. ok
22:31:41 <shapr> r_rehashed: So, do you know map?
22:32:12 <wli> I don't remember my first Haskell program. It's been ca. 10 years and I was picking up a buttload of different languages at the time.
22:33:02 <r_rehashed> not yet. does it add the next element to the list while keeping no. of elements same or something?
22:33:14 <fuzan> i suggest avoiding map at first if you're not accustomed to the functional paradigm. write naive recursive implementations, and then learn how to replace them with folds, maps, scans, etc.
22:33:31 <fuzan> :t map
22:33:33 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:33:46 <shapr> fuzan: What do you suggest first?
22:34:03 <fuzan> read as, "it takes a function that converts a type 'a' to type 'b', a list of type 'a', and it makes a list of type 'b'"
22:34:06 <shapr> I sort of found first class functions and referential transparency by myself while writing Python, so...
22:34:17 <olliej> ?pl \a -> not (isSpace a)
22:34:18 <lambdabot> not . isSpace
22:34:20 <glguy> so...? do go on ;)
22:34:32 <jcreigh> first class functions are the bomb.
22:34:46 <r_rehashed> fuzan: ok
22:35:27 <gnufied> what are those functions which start with ':' ?
22:35:27 <fuzan> shapr: i like rewriting basic useful utilities when i pick up a new language, like {words,unwords,zip, etc}
22:35:28 <shapr> r_rehashed: The way I see it, if you have a function you can apply to one item, map applies that same function to every item in a list, returning the new list.
22:35:41 <fuzan> and sorts, of course :)
22:35:43 <r_rehashed> ah ok
22:36:00 <fuzan> > map even [1..10]
22:36:01 <lambdabot>  [False,True,False,True,False,True,False,True,False,True]
22:36:01 <r_rehashed> sheesh and my explanation was.. lol  ok
22:36:02 <shapr> glguy: Who go on?
22:36:07 <fuzan> :t even
22:36:09 <lambdabot> forall a. (Integral a) => a -> Bool
22:36:16 <wli> There's always projecteuler, too.
22:36:23 <shapr> r_rehashed: Do you understand map now?
22:36:26 <EvilTerran> gnufied, infix constructors
22:36:32 <r_rehashed> hey where can i get all these funcs.? is there a reference?
22:36:37 <wli> map (^2) [1..10]
22:36:38 <r_rehashed> shapr: perfectly
22:36:40 <shapr> spiffy
22:36:47 <EvilTerran> @source Prelude
22:36:47 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
22:36:50 <fuzan> r_rehashed: so, even has the type (a->b), which satisfies the first parameter of map
22:36:51 <shapr> r_rehashed: The Prelude has all these functions.
22:37:13 <EvilTerran> (no, don't look at that. it's probably not even helpful. try this instead:)
22:37:16 <EvilTerran> @docs Prelude
22:37:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
22:37:27 <r_rehashed> ok
22:37:54 <shapr> Or look at both and see what you prefer :-)
22:38:02 <shapr> Dang, where'd my HaskellDemo go?
22:38:14 <fuzan> we need an interactive webpage like that ruby thingy.
22:38:24 <fuzan> interactive ajax tutorial
22:38:45 <EvilTerran> shapr, that particular source does very little, beyond importing and re-exporting most of "GHC.Prelude"
22:38:52 <r_rehashed> fuzan: online haskell interpreter.. wow that would be cool
22:38:53 <shapr> fuzan: Yeah, I've been thinking about doing that inside hpaste.
22:39:31 <shapr> r_rehashed: What about http://www.scannedinavian.com/~shae/HaskellDemo.hs ?
22:39:40 <shapr> oh, I should hpaste that
22:39:53 <fuzan> shapr: itt oculd even be like a cgi wrapper around like lambdabot with a tutorial plugin
22:39:56 <hpaste>  shapr pasted "HaskellDemo" at http://hpaste.org/2315
22:40:10 <shapr> fuzan: Hack it up!
22:40:15 <shapr> It'd be a great tool!
22:40:16 <fuzan> shapr: too busy :)
22:40:19 <shapr> Heh, me too
22:40:27 <shapr> I have a full time job writing Haskell :-)
22:40:34 <fuzan> sweet.
22:40:46 <fuzan> i was told to not write anymore haskell :)
22:40:55 <shapr> Really? Why?
22:41:00 <EvilTerran> or rather, it does a hairy import list of various things from GHC.* ... but nevermind that.
22:41:07 <fuzan> no one else is around to maintain the code ;)
22:41:16 <shapr> EvilTerran: The hugs sources are somewhat easier to understand.
22:41:18 <shapr> fuzan: hah
22:41:28 <shapr> fuzan: You're just making more contract work for me.. keep up the good work!
22:41:35 <shapr> Or more contract work for yourself when you leave :-)
22:41:39 <r_rehashed> shapr: ah.. that's more friendly. :) thanks
22:42:00 <EvilTerran> shapr, that's true... i think i tend to look at http://haskell.org/onlinereport/standard-prelude.html in general, though.
22:42:01 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
22:42:21 <shapr> r_rehashed: You should be able to load that HaskellDemo.hs file into ghci, and play with it somewhat interactively.
22:42:44 <r_rehashed> right
22:42:55 <shapr> Got any questions about HaskellDemo?
22:43:09 <fuzan> i think we're overloading him.
22:43:25 * shapr makes r_rehashed an instance of TutorialOverload
22:43:30 <shapr> Ok, now he's overloaded.
22:43:33 <fuzan> just try to write a function to count hte number of elements in a list in ghci :)
22:43:44 <r_rehashed> hehehe
22:44:12 <glguy> The standard procedure is r_rehashed goes off to read YAHT or the wikibook or something, and comes back with specific questions... otherwise he'll get one of these help overloads :)
22:44:26 <shapr> Yeah, true
22:44:28 <fuzan> very true
22:44:34 <r_rehashed> nah.. i am not overloaded..
22:44:37 <shapr> yay!
22:44:51 <glguy> r_rehashed: also, you'll get more benefit out of it, imho
22:44:57 <r_rehashed> shapr: shook me of my early-morning laziness
22:45:04 <shapr> Is it morning where you are?
22:45:07 <r_rehashed> i know. right
22:45:14 <shapr> @localhost r_rehashed
22:45:14 <lambdabot> Unknown command, try @list
22:45:14 <glguy> I'm not trying to discourage you from asking questions in channel
22:45:14 <r_rehashed> yes
22:45:22 <shapr> @localtime r_rehashed
22:45:22 <r_rehashed> India
22:45:24 <glguy> I just think you'll get broader exposure with a writen tutorial
22:45:27 <shapr> @localtime shapr
22:45:27 <lambdabot> Local time for shapr is Sat Aug 18 00:44:02 2007
22:45:53 <r_rehashed> hey why didn't it give my time?
22:46:01 <r_rehashed> @localtime r_rehashed
22:46:16 <jcreigh> your IRC client probably doesn't respond to that specific kind of CTCP request.
22:46:22 <glguy> he's using gaim
22:46:25 <glguy> does that support them
22:46:39 <r_rehashed> oh yeah.. i am getting some CTCP messages or something
22:46:54 <r_rehashed> right.. i guess gaim doesn't support it
22:47:22 <shapr> r_rehashed: You're using gaim, it doesn't handle ctcp time
22:47:50 <r_rehashed> i only use gaim because it gets all the IMs in one box
22:48:00 <TSC> Like bitlbee
22:48:06 <glguy> or trillian
22:48:35 <r_rehashed> but gaim is not as good as mIRC or xchat for irc
22:48:53 <lament> use bitlbee
22:48:57 <lament> for IM
22:49:04 <shapr> or kopete
22:49:12 <shapr> Or whatever you like...
22:49:16 * shapr is all about options!
22:49:28 <fuzan> r_rehashed: www.irssi.org   :p
22:49:32 <glguy> ?yow
22:49:32 <lambdabot> All of a sudden, I want to THROW OVER my promising ACTING CAREER, grow
22:49:32 <lambdabot> a LONG BLACK BEARD and wear a BASEBALL HAT!! ...  Although I don't know WHY!!
22:49:53 <r_rehashed> what happened to lambdabot? lol
22:49:53 <wli> I'm trying to project y^2-5*x^2-2*x=1 onto the x axis through (2,5) and failing.
22:51:03 <paolino> hi, I'm parrsing html with hxt. If I runX f  I  get a list of 25 nodes but what I need is transform them skipping first and making couples of the other ones so I get 12 nodes in the end, Can I do that  inside the arrow building (before runX) ?
22:51:37 <shapr> paolino: Can you steal code from http://cale.yi.org/index.php/HRSS ?
22:51:39 <lambdabot> Title: HRSS - CaleWiki
22:52:44 <fiveleavesleft> hmmm... one thing that's kinda ugly in haskell is the difficulty of expressing zipN (yes, i understand the difficulty posed by type strictness here).
22:53:10 <fiveleavesleft> seeing zip1-7 in the std libraries hurts my eyes...
22:53:12 <shapr> fiveleavesleft: What about Template Haskell?
22:53:25 <EvilTerran> fiveleavesleft, what about the Applicable one?
22:53:40 <fiveleavesleft> that would be a bit of haskell i haven't gotten to - my flirtation with it is only 5 hours old... ;)
22:53:55 <EvilTerran> *applicative
22:54:09 <fiveleavesleft> but... if there was a nice way to do it (i'll take your word for it), why is zip1-7 in the standard libraries?
22:54:20 <r_rehashed> why does haskell have a->b->c for multiple args.? why not (a,b)->c  or something?
22:54:31 <EvilTerran> 'cos the nice way isn't very nice, fiveleavesleft.
22:54:44 <fiveleavesleft> heh. that was my working theory, yes. ;)
22:54:45 <r_rehashed> i mean is there any other way to look at it?
22:55:10 <shapr> r_rehashed: Yes, there is another way to look at it... partial application.
22:55:34 <stepcut> r_rehashed: having a -> b -> c makes it easy to do things like, map (+1) [1,2,3]
22:55:36 <EvilTerran> > (,,) <$> ZipList [1..10] <*> ZipList ['a'..'j'] <*> ZipList "qwertyuiop"
22:55:37 <lambdabot>        add an instance declaration for (Show (ZipList (a, Char, Char)))
22:55:39 <paolino> shapr: if you mean stealing from getItem there I think itś not my case
22:55:52 <EvilTerran> > getZipList $ (,,) <$> ZipList [1..10] <*> ZipList ['a'..'j'] <*> ZipList "qwertyuiop"
22:55:53 <lambdabot>  [(1,'a','q'),(2,'b','w'),(3,'c','e'),(4,'d','r'),(5,'e','t'),(6,'f','y'),(7,...
22:55:57 <r_rehashed> oh ok
22:56:11 <stepcut> r_rehashed: otherwise you would have to do: map (\b -> (+) (1,b)) [1,2,3], which is more typing
22:56:28 <EvilTerran> hehe, typing. nice double meaning, there.
22:56:32 <r_rehashed> ok
22:56:50 <stepcut> EvilTerran: yeah -- I have seen the form I was talking to refered to as 'finger typing'
22:56:56 <paolino> shapr all 25 nodes are indistinguishable , they just come one after another
22:57:27 <EvilTerran> hm... what's the normal list Applicative instance, if not zipping? cross product?
22:57:44 <EvilTerran> > (,) <$> [1,2,3] <*> "abc"
22:57:46 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
22:57:50 * paolino wonders if he made jackpot with orthographics errors there
22:59:38 <EvilTerran> fiveleavesleft, the gist of the "n-ary zip" solution is that you can make an infinite list (repeat f), where f is your function, and then zipWith ($) that list and each parameter list in turn.
23:00:33 <fiveleavesleft> hmmm.... i'm putting this in my scrapsheet for later analysis, EvilTerran.
23:00:43 <fiveleavesleft> for now, i'm working around my hankering for zipN... ;)
23:00:44 <EvilTerran> > let zapp = zipWith ($) in repeat (,,) `zapp` [1..10] `zapp` ['A'..'J'] `zapp` "qwertyuiop"
23:00:45 <lambdabot>  [(1,'A','q'),(2,'B','w'),(3,'C','e'),(4,'D','r'),(5,'E','t'),(6,'F','y'),(7,...
23:01:21 <wli> y^2=5*x^2+2*x*z+z^2 ... eigenvectors of [[5,1],[1,1]] are (1, -2+/-sqrt5) and eigenvalues 3+/-sqrt 5 (matching signs). Yuck.
23:01:43 <shapr> r_rehashed: So, did you understand why it's a -> b -> c ?
23:02:06 <EvilTerran> a -> (b -> c), btw.
23:02:12 <r_rehashed> it takes an argument and returns another function, right
23:02:13 <r_rehashed> ?
23:02:21 <EvilTerran> ?type map
23:02:23 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:02:25 <r_rehashed> which takes b and returns c
23:02:31 <EvilTerran> yes, that's right.
23:02:35 <shapr> r_rehashed: yup!
23:02:45 <fiveleavesleft> r_rehashed: all this flows from the lambda calculus, and is fundamental to how haskell works...
23:02:48 <EvilTerran> map takes a function as its first argument, as you can see by its type
23:02:51 <r_rehashed> Wow. mathematics
23:03:06 <r_rehashed> i guess i should learn lambda calculus first
23:03:27 <r_rehashed> right
23:03:46 <glguy> r_rehashed: no
23:04:05 <shapr> r_rehashed: As glguy says, learn Haskell first :-)
23:04:14 <r_rehashed> ok :)
23:04:40 <paolino> shapr, any other ideas for my problem with hxt ?
23:04:41 <newsham> you dont need to learn lambda calculus first
23:04:43 <r_rehashed> guys.. i have a fear i'll lose interest in Java lol
23:04:53 <shapr> paolino: No, I don't have any ideas, sorry. Cale might know.
23:04:57 <r_rehashed> newsham: ok
23:05:11 <paolino> @seen Cale
23:05:11 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 56m 33s ago.
23:05:18 <newsham> learning more languages can help your programming of your existing languages
23:05:26 <EvilTerran> if anything, haskell's a nice intro to lambda calculus, rather than the other way around
23:05:27 <newsham> ?seen dons
23:05:27 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 22h 32m 43s ago.
23:05:29 <r_rehashed> yes
23:05:32 <Cale> paolino: hi
23:05:50 <Cale> paolino: I think I know what you need, one sec
23:06:06 <Cale> yes, listA
23:06:33 <Cale> listA will turn a nondeterministic arrow into a deterministic one which returns a list.
23:06:49 <Cale> paolino: then you can manipulate that list however you want
23:07:22 <paolino> listA (deep f) >>> arr head ?
23:14:37 <r_rehashed> ok guys. i'll freshen up and start yaht. downloaded it last night
23:14:55 <r_rehashed> be back later
23:15:01 <paolino> thanks Cale, it works
23:15:21 <Cale> paolino: great :)
23:23:37 <wli> So I can get rational points on the curve, but it's not obvious how to get integer points.
23:40:27 <desp> hmm
23:41:37 <desp> is it possible to define a typeclass Foo with regard to typeclass Bar, such that an instance of Foo would also become an instance of Bar?
23:42:18 <mdmkolbe> desp: yes.  "class Foo a => Bar a where ..."
23:42:26 <desp> awesome.
23:42:31 <glguy> with the appropriate extensions turned on
23:43:01 <mdmkolbe> desp: also ... the function implementations for Bar can use functions from Foo
23:43:20 <desp> yes, I'd hope so :)
23:44:31 <wli> It can't be this hard to find integer points on a frigging hyperbola.
23:45:46 <mdmkolbe> wli: a^2 - b^2 == (a-b)(a+b) may be of help
23:45:52 <lament> number theory's a bitch
23:45:57 <wli> mdmkolbe: It is not.
23:46:12 <wli> mdmkolbe: It's nowhere near that retarded.
23:46:39 <EvilTerran> mdmkolbe, wli, don't you want instance Foo a => Bar a where...?
23:47:03 <mdmkolbe> EvilTerran: I think you confused wli for desp
23:47:10 <desp> most certainly
23:47:19 <EvilTerran> yes. yes i did. =/
23:47:26 <EvilTerran> their names aren't even the same colour!
23:47:29 <desp> however, I do think we mean class
23:47:45 <EvilTerran> "an instance of Foo would also become an instance of Bar" would be what i wrote
23:48:08 <EvilTerran> what mdmkolbe wrote would mean that something _couldn't_ be made an instance of Bar without being first made an instance of Foo separately
23:48:31 <samreid> you can have   class Bar a  where ....    then instance Foo a => Bar a where ....    with -fundecidable-instances (IIRC)
23:48:46 <EvilTerran> but it wouldn't happen automatically with just that one. actually, if you want mine, you might very well want both, actually...
23:48:48 <mdmkolbe> EvilTerran: it also means that any instance of Foo becomes an instance of Bar for free
23:48:53 * EvilTerran deletes one actually
23:49:03 <EvilTerran> ...it does?!
23:49:39 <mdmkolbe> EvilTerran: yes, it does because it is "Foo a" and not "Foo X" so *any* "a" can be used.
23:49:39 <samreid> mdmkolbe:  class Foo a => Bar a   does not mean that all Foo's become Bars.
23:49:45 <EvilTerran> but... um... default methods?
23:50:32 <mdmkolbe> samreid: oops.  I meant to write "instance Foo a => Bar a where ..."
23:50:51 <EvilTerran> samreid, thanks. nice to know i'm not crazy. or at least, if i am, i'm not the only one ;]
23:51:21 <samreid> oh ok
23:51:27 <desp> hrm
23:54:25 <mdmkolbe> @pl \n -> take n &&& drop n
23:54:26 <lambdabot> liftM2 (&&&) take drop
23:56:01 <mdmkolbe> Does LB have a desugar command?  I have an arrow expression I wan't to decompose.
23:56:03 <desp> "instance Foo a => Bar a" does not appear to be valid
23:56:10 <desp>     Illegal instance declaration for `Bar a'
23:56:10 <desp>         (The instance type must be of form (T a b c)
23:56:11 <desp>          where T is not a synonym, and a,b,c are distinct type variables)
23:56:29 <desp> this is with -fallow-undecidable-instances on
23:56:38 <mdmkolbe> desp: have you done -fglasgow-exts?
23:56:54 <desp> ah, I haven't
23:57:21 <shachaf> mdmkolbe: You mean @undo for arrows?
23:57:30 <mdmkolbe> shachaf: yeah
23:57:35 <shachaf> mdmkolbe: I don't think so.
23:57:41 <desp> actually, " -fallow-undecidable-instances" appears to be unnecessary
23:57:50 <desp> no, my bad.
23:57:51 <desp> it is.
23:57:56 <desp> necessary.
23:58:00 <desp> thanks, everyone.
23:58:43 <mdmkolbe> desp: be carefull with this trick.  strange things can happen if you declare any other instances of Bar (b/c more than one will match).
23:59:35 <desp> mdmkolbe: hmm. I was hoping to make every MyEnum an instace of Enum, for example
23:59:42 <desp> instance*
