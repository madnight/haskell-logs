00:06:07 <tuxplorer> Lemmih: There is a function by name Mix_OpenAudio in the SDL library, which is named as simply OpenAudio in hsSDL.. Is that the reason why I get the error
00:06:07 <tuxplorer> /usr/local/lib/SDL-mixer-0.4.0/ghc-6.6/HSSDL-mixer-0.4.0.o: unknown symbol `Mix_OpenAudio'   ghc-6.6: unable to load package `SDL-mixer-0.4.0'
00:07:17 <tuxplorer> MarcWeber: The function is there in the current version of SDL_mixer that I have, and also in the recent ones.. So, upgrading doesn't help. Probably the naming conflict is the issue?
00:08:12 <tuxplorer> @seen Lemmih
00:08:12 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 7h 19m 52s ago.
00:08:44 <tuxplorer> @tell Lemmih There is a function by name Mix_OpenAudio in the SDL library, which is named as simply OpenAudio in hsSDL.. Is that the reason why I get the error /usr/local/lib/SDL-mixer-0.4.0/ghc-6.6/HSSDL-mixer-0.4.0.o: unknown symbol `Mix_OpenAudio'   ghc-6.6: unable to load package `SDL-mixer-0.4.0'
00:08:45 <lambdabot> Consider it noted.
00:08:52 <mm_freak_> @unlambda ```s``s``sii`ki
00:08:52 <lambdabot>  fd:25: hClose: resource vanished (Broken pipe)
00:09:20 <OceanSpray> oh wow
00:09:31 <OceanSpray> Haskell's got so many libraries...
00:18:17 <olsner> is there a more efficient nub that works on Ord's?
00:18:37 <oerjan> olsner: Data.Set
00:18:41 <shachaf> olsner: There's Data.Set.
00:18:47 <olsner> something like toList . fromList from Set then?
00:18:52 <ClaudiusMaximus> :t Data.Set.fromAscList
00:18:54 <lambdabot> forall a. (Eq a) => [a] -> Data.Set.Set a
00:19:08 <ClaudiusMaximus> i think that's the one?
00:19:17 <oerjan> Asc won't work in this case
00:19:31 <shachaf> You want the old order?
00:19:34 <oerjan> also, fromList will of course destroy any order
00:19:44 <oerjan> no, but it may not be sorted originally
00:19:55 <ClaudiusMaximus> ah, i misread/misinterpreted
00:20:18 <oerjan> if it _were_ sorted, you could just use map head . group
00:20:41 <shachaf> oerjan: That's Eq.
00:21:15 <oerjan> shachaf: yes, but it would be efficient if the list were sorted, i think
00:21:43 <shachaf> Oh, right, never mind.
00:21:47 * shachaf is silly.
00:23:25 <shachaf> @check (\xs -> all (not . null) (group (xs::[Int])))
00:23:26 <lambdabot>  OK, passed 500 tests.
00:23:55 <DRMacIver> Morning
00:24:16 <oerjan> @src groupBy
00:24:16 <lambdabot> groupBy _  []       =  []
00:24:16 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
00:24:16 <lambdabot>     where (ys,zs) = span (eq x) xs
00:24:17 <dankna> Hmm, so I'm trying to test out the YHC Javascript backend, just because it looks cool, but having trouble getting the tools built and working.  I think I have the situation in hand, but I thought I'd mention what I'm doing in case anybody knows relevant stuff offhand that could save me rediscovering it...
00:24:35 <oerjan> no chance of an empty element
00:24:40 <MarcWeber> tuxplorer: :-) Ok fine. I'll try to invastigate the trouble in half an hour if you don't get anotehr answer till then.
00:24:57 <tuxplorer> Thanks a lot MarcWeber :)
00:25:50 <dankna> I finally got SCons to actually compile YHC on the Mac, huzzah.  That's the part that is working.  Now, the Javascript thing is a tool that runs on its "core" files (a bytecode, I think) as a separate program...
00:26:36 <dankna> It depends on HXT, and Cabal doesn't support YHC, and there doesn't appear to be any documentation on how YHC even knows where to look for a library.
00:26:51 <dankna> I'm wondering whether this tool might work just as well if I build it with GHC, and I'm looking into that.
00:27:07 <dankna> I don't have a question, that's just where I'm up to in my investigations. :) But if anyone who's made this work is around, feel free to chime in.
00:28:06 <olsner> I think I need something more clever to get the list of divisors
00:28:31 <wli> olsner: What's this?
00:28:51 <olsner> http://www.projecteuler.net/index.php?section=problems&id=21
00:28:53 <lambdabot> Title: Project Euler
00:29:35 <wli> olsner: d(n) as they define it is computable from the prime factorization.
00:30:07 <olsner> yeah, all products of factors below n or something like that
00:30:11 <olsner> but then I
00:30:17 <olsner> 'd have to factorize the number
00:30:27 <wli> olsner: Say that the factorization is [(p, k) | (p, k) <- factors n] so that product [p^k | (p, k) <- factors n] == n
00:31:07 <wli> olsner: Then d(n) = product [(p^(k+1)-1) `div` (p - 1) | (p, k) <- factors n] - n
00:31:46 <olsner> what's (p, k)?
00:32:05 <olsner> oh, prime number and exponent
00:32:08 <wli> olsner: It represent a prime power factor of p^k
00:32:33 <olsner> and then there's some number theory magic, and hey presto a result
00:33:47 <oerjan> olsner: d(n)+n is what is called a multiplicative function, you take the product for each prime power
00:34:51 <wli> olsner: The way I factored is/was at http://hpaste.org/2229#a1
00:35:06 <wli> olsner: From there the problem was just let s n = product [(p^(k+1) - 1) `div` (p - 1) | (p, k) <- factor n] - n in sum [k | k <- [2..10^4], let k' = s k in k' /= k && s k' == k]
00:37:01 <wli> olsner: The result is computed in 0.92s here.
00:37:23 <xtacy[]> Hi
00:37:32 <olsner> still don't get the math though
00:38:08 <wli> olsner: (p^(k+1) - 1) `div` (p - 1) is short for the geometric sum.
00:38:26 <xtacy[]> Does Parsec handle epsilon productions rules? Or, do I have to do epsilon production removal on the CFG?
00:38:32 <wli> olsner: The product of those geometric sums when expanded forms the sum of all possible divisors.
00:38:58 <wli> olsner: It includes n, so at the end, you subtract out n.
00:39:01 <olsner> oh, so that's the sum of [p^k' | k' <- [1..k]]?
00:39:18 <wli> olsner: yeah
00:39:20 <xtacy[]> olsner: yes ...
00:39:51 <xtacy[]> in fact, k' < -- [0 ... k]
00:40:33 <xtacy[]> oops. k' <- [0..k]
00:40:44 <wli> product [sum [p^j | j <- [0..i]] | (p, i) <- factors n]
00:41:30 <wli> olsner: You can get the sum of the r-th powers of all the divisors this way, too.
00:42:19 <wli> product [sum [p^(r*j) | j <- [0..i]] | (p, i) <- factors n] == product [(p^(r*i+1) - 1) `div` (p^r - 1) | (p, i) <- factors n]
00:43:01 <wli> r need not even be an integer.
00:43:15 <wli> Or, for that matter, positive.
00:44:45 <wli> misparenthesization on the RHS but anyway
00:45:08 <wli> s/p^(r*i+1)/p^(r*(i+1))/
00:45:39 * shachaf is quite sure wli didn't mean that as a regexp.
00:45:43 <oerjan> also you may need ^^ or ** if r is not a natural number
00:47:31 <wli> yes and yes
00:49:49 <olsner> hmm.. euler 97 crashes ghci with "% (no error message, it just dives)
00:50:54 <olsner> apparently, it doesn't do too well with million-digit numbers
00:50:59 <wli> olsner: (28433*2^7830457 + 1) `mod` (10^10) runs successfully here in 0.58s
00:52:47 <olsner> reverse . take 10 . reverse . show must've been the culprit then :P
00:53:34 <augustss> moinin
00:54:10 <wli> moin augustss
00:55:40 <oerjan> olsner: the trick is to do (mod 10^10) at increments
00:56:24 <oerjan> rather than all at the end
00:56:37 <olsner> oh yeah, a*b mod c = (a mod c * b mod c) mod c
00:57:23 <wli> oerjan: The number isn't large enough for that to be necessary.
00:59:07 <olsner> but using that trick, you could for example do all calculations in 64-bit arithmetic
00:59:10 <oerjan> wli: what happens if you replace 2^ with 3^ ? :)
00:59:23 <olsner> which could speed things up quite a bit
00:59:36 <wli> oerjan: It could barf.
01:00:48 <wli> I simply tried the obvious first.
01:03:16 <wli> (probably the first thing to do is to mod the exponent by phi(10^10) if/when that applies)
01:04:29 <wli> phi(10^10) = phi(2^10) * phi(5^10) = (2^9) * (4*5^9) = 2^11*5^9 = 4*10^9
01:04:48 <wli> 7830457 < 10^10 though.
01:05:05 <oerjan> doesn't seem very applicable, no
01:05:08 <wli> 7830457 < 4*10^9 too.
01:07:10 <wli> Euler 95 looks more interesting.
01:09:48 <ClaudiusMaximus> i wrote a blog post about how i got a simple ArrowCircuit to work (as in A New Notation For Arrows and with hints from Programming With Arrows), if anyone is interested: http://tinyurl.com/2atep6
01:19:46 <ClaudiusMaximus> @hoogle digitTo
01:19:47 <lambdabot> Char.digitToInt :: Char -> Int
01:19:59 <ClaudiusMaximus> > digitToInt ' '
01:20:00 <lambdabot>  Exception: Char.digitToInt: not a digit ' '
01:20:07 <ClaudiusMaximus> ick
01:20:28 <ClaudiusMaximus> @src Char.digitToInt
01:20:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:20:40 <oerjan> :t isDigit
01:20:42 <lambdabot> Char -> Bool
01:20:49 <OceanSpray> oh hey, I just read that today
01:21:30 <OceanSpray> I was looking for what do notation parses into, and google turned up your blog
01:21:50 <shachaf> @where report
01:21:51 <lambdabot> http://www.haskell.org/onlinereport/
01:21:58 <shachaf> OceanSpray: If you're still looking.
01:22:19 <OceanSpray> I'm quite done, thank you very much
01:22:33 <OceanSpray> also, I need a way to represent continuations in my lisp interpreter
01:22:44 <OceanSpray> if I don't do it now, it might be too late
01:22:46 <wli> let s n = product [(p^(k+1) - 1) `div` (p - 1) | (p, k) <- factor n] - n in mapM_ print $ take 10 $ sortBy (flip (comparing length)) $ map flattenSCC $ stronglyConnComp $ filter (\(x,_,ys) -> x <= 10^6 && all (<= 10^6) ys) [(k, k, [s k]) | k <- [2..10^6]] -- this seems a bit slow
01:23:50 <oerjan> > (liftM2(>>)(guard.isDigit)(Just . digitToInt))' '
01:23:52 <lambdabot>  Nothing
01:23:55 <oerjan> > (liftM2(>>)(guard.isDigit)(Just . digitToInt))'1'
01:23:56 <lambdabot>  Just 1
01:24:03 <oerjan> woohoo
01:24:41 <ClaudiusMaximus> > let notUnsafeDigitToInt c = if isDigit c then Just (digitToInt c) else Nothing in map notUnsafeDigitToInt " 1 2"  -- my solution (hopefully..)
01:24:42 <lambdabot>  [Nothing,Just 1,Nothing,Just 2]
01:26:04 <shachaf> "notUnsafe"?
01:26:06 <oerjan> bah, _far_ too readable :)
01:26:36 <augustss_> OceanSpray: how about continuations to represent continuations?
01:26:54 <oerjan> my version uses _two_ monads :)
01:27:00 <shachaf> oerjan: What about spaces?
01:27:09 <shachaf> oerjan: Yours doesn't use many of those.
01:27:12 <olsner> there should be a Bool -> a -> Maybe a, or perhaps (a -> Bool) -> a -> Maybe a function
01:27:22 <oerjan> yeah, that too
01:27:33 <ClaudiusMaximus> > let notUnsafeDigitToInt c = if isDigit c then Just (digitToInt c) else Nothing in catMaybes . map notUnsafeDigitToInt $ [chr 0 .. chr 255]
01:27:35 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
01:28:00 <DRMacIver> Morning
01:28:07 <OceanSpray> augustss_, what?
01:28:51 <augustss_> I saw your comment that you need to represent continuations in your Lisp interpreter. :)
01:28:56 <OceanSpray> yes
01:29:12 <augustss_> Have you tried the continuation monad?
01:29:18 <OceanSpray> well, no
01:29:43 <olsner> > let guardJust True = Just (); guardJust False = Nothing in catMaybes . map (\c -> (guardJust $ isDigit c) >>= (Just . digitToInt c)) $ [chr 0 .. chr 255]
01:29:43 <lambdabot>  Couldn't match expected type `() -> b' against inferred type `Int'
01:29:59 <olsner> > let guardJust True = Just (); guardJust False = Nothing in catMaybes . map (\c -> (guardJust $ isDigit c) >> (Just . digitToInt c)) $ [chr 0 .. chr 255]
01:30:00 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Int'
01:30:25 <olsner> > let guardJust True = Just (); guardJust False = Nothing in catMaybes . map (\c -> (guardJust $ isDigit c) >> (Just $ digitToInt c)) $ [chr 0 .. chr 255]
01:30:27 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
01:30:29 <augustss_> OceanSpray: there's a good chance it will do what you need
01:30:50 <OceanSpray> alrighty
01:30:53 <OceanSpray> I sure hope so
01:31:09 <OceanSpray> because I coded myself into a corner here
01:31:25 <augustss_> continuations are tricky
01:31:47 <andyjgill_> Understatement of week!
01:31:56 <oerjan> olsner: you realize guardJust = guard?
01:32:15 <ClaudiusMaximus> :t guard
01:32:17 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
01:32:43 <olsner> aah! ;-)
01:34:51 <enolan> @src guard
01:34:51 <lambdabot> guard True  =  return ()
01:34:51 <lambdabot> guard False =  mzero
01:35:15 <enolan> > guard True :: [Int]
01:35:16 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
01:35:45 <enolan> oh.
01:35:52 <olsner> > map guard [False,True] :: [[a]]
01:35:53 <lambdabot>   Bool -> [a]
01:35:53 <lambdabot>       Inferred type: Bool -> [()]
01:36:00 <olsner> > map guard [False,True] :: [[()]]
01:36:02 <lambdabot>  [[],[()]]
01:37:28 <oerjan> @pl \b x -> guard b >> return x
01:37:29 <lambdabot> (. return) . (>>) . guard
01:37:50 <Azmo> I am including a C header file my source and use "-cpp", however, stuff like __x64_64__ and __WORDSIZE is not defined, which is causing problems. if writing in C only and using GCC to compile, there is not problems, and the __WORDSIZE etc.. is defined. anyone know what is wrong? :o
01:38:39 <oerjan> @pl \p x -> guard (p x) >> return x
01:38:39 <lambdabot> (`ap` return) . (((>>) . guard) .)
01:41:55 <jbauman> @pl \p x -> if p x then return x else mzero
01:41:55 <lambdabot> flip flip mzero . (`ap` return) . (if' .)
01:43:32 <tuxplorer> MarcWeber: can you please help me get SDL-mixer working when you find some free time? I've been stuck at that one point since yesterday morning.. :(
01:43:55 <DRMacIver> hm
01:44:01 <DRMacIver> :t flip flip mzero
01:44:05 <DRMacIver> Oops
01:44:08 <DRMacIver> @type flip flip mzero
01:44:09 <lambdabot> forall a c (m :: * -> *) a1. (MonadPlus m) => (a -> m a1 -> c) -> a -> c
01:44:10 <lambdabot> forall a c (m :: * -> *) a1. (MonadPlus m) => (a -> m a1 -> c) -> a -> c
01:45:17 <jbauman> if' ?
01:45:48 <enolan> jbauman: if' cond x y = if cond then x else y
01:46:13 <oerjan> jbauman: @pl uses it but it's not standard
01:46:22 <jbauman> makes sense, i just couldn't find it anywhere
01:50:23 <enolan> @version
01:50:23 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
01:50:23 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:03:32 <DRMacIver> (Should be standard though. And it should be called "if" :) )
02:09:33 <augustss> yes, there should be an "if" function
02:09:53 <augustss> overloaded, of course :)
02:10:05 <oerjan> :D
02:10:15 <olsner> class If?
02:10:31 <doserj> cond:: Boolean a => a -> b -> b -> b?
02:10:49 <aleator> Using c2hs which is preferred way of getting multiple values out of c-function call?
02:11:00 <opqdonut> ?instances Boolean
02:11:02 <lambdabot> Couldn't find class `Boolean'. Try @instances-importing
02:11:06 <opqdonut> yeah thought so
02:11:09 <doserj> :)
02:11:12 <opqdonut> kinda weird there's no such thing
02:11:49 <doserj> and there should be "deriving (Boolean)" for datatypes with two argumentless constructors :)
02:12:01 <opqdonut> yeah :))
02:12:14 <oerjan> actually they shouldn't need to be argumentless
02:12:28 <oerjan> Maybe e.g.
02:12:53 <doserj> also possible, yes
02:13:09 <oerjan> and [] of course
02:13:19 <oerjan> oh, and Either fits too
02:13:35 <doserj> class Boolean a where toBool :: a -> Bool
02:13:40 <olsner> aah, just like C ;-) if (pointer) { ... }
02:13:47 <doserj> fun!
02:13:52 <mux> foo ? bar : baz;
02:13:54 * mux hides
02:14:36 <oerjan> alas that cannot typecheck
02:14:49 <doserj> let b ? x = if b then const x else id in True ? "True" $ "False"
02:14:52 <doserj> > let b ? x = if b then const x else id in True ? "True" $ "False"
02:14:53 <lambdabot>  "True"
02:15:04 <mux> close enough :)
02:15:19 * mux really doesn't like the ternary operator though
02:16:00 <earthy> let b ? x = if b then const x else id in let (-:) = ($) in True ? "True" -: "False"
02:16:06 <earthy> > let b ? x = if b then const x else id in let (-:) = ($) in True ? "True" -: "False"
02:16:07 <lambdabot>  "True"
02:16:12 * earthy whistles
02:16:26 <earthy> unfortunately : is already taken :)
02:16:43 <oerjan> i assume that smiley was on purpose
02:16:55 <earthy> it was
02:21:29 <earthy> > let b ? x = if b then head x else head (tail x) in True ? ("True" : "False" : [])
02:21:30 <lambdabot>  "True"
02:21:44 <earthy> and using fixity declarations you could remove the ()
02:21:50 <dons> shapr: hey this looks cool, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Hmpf-0.1
02:21:53 <lambdabot> http://tinyurl.com/2wh9fb
02:21:56 <dons> `An MPD client designed to be used on a Home Theatre PC equipt with an infrared remote and VDU display'
02:34:21 <dons> http://programming.reddit.com/info/2f1l0/comments nice
02:34:22 <lambdabot> Title: Pointer tagging: making Haskell faster (reddit.com)
02:43:41 <thoughtpolice> dons: cool post.
02:49:40 <DRMacIver> Hm. I rather thought that that behaviour was clear from the summary already. :)
02:49:52 <DRMacIver> Maybe I've just missed the point.
02:51:35 <dons> DRMacIver: not all programmers dream about type erasure :)
02:53:30 <DRMacIver> @remember dons not all programmers dream about type erasure :)
02:53:30 <lambdabot> Done.
02:55:09 <DRMacIver> dons: I guess I have been wondering about implementation details of such things for a while (not actually *done* anything with it, but it's in the background thought). :)
02:55:13 <olsner> type erasure is where the type of the data is statically determined and it has no tags in memory, right?
02:55:19 <DRMacIver> Yeah
02:55:25 <olsner> kinda like constant folding, but for types ;-)
02:55:54 <augustss> hello dons
02:57:14 <dons> hey augustss. nice post about the C EDSL.
02:57:26 <augustss> thanks :)
02:57:34 <Philippa> mornin'
02:57:46 <augustss> moin
02:58:10 <DRMacIver> olsner: I guess so. It's more like eliminating dead code for tests you know can't fail, e.g. removing bounds checks on arrays.
02:59:09 <olsner> oh and btw, shouldn't it be possible to change calls to function pointers with calls to functions with parameters, in many cases? (what I've read about ghc seems to imply that all calls are implemented as indirect calls)
02:59:11 <DRMacIver> olsner: You throw away tests you know can't fail, then throw away information you no longer need because the things which check it have all been removed.
02:59:20 <olsner> mmm
03:00:15 <DRMacIver> There was a good post recently on reddit about dependent types allowing for data erasure as well.
03:00:30 <augustss> olsner: ghc often uses direct calls
03:01:34 <olsner> good to hear, that
03:01:44 <opqdonut> it is, isn't it
03:01:55 <olsner> yes ;-)
03:02:28 <augustss> olsner: except they are jump instructions, not call instructions
03:02:35 <augustss> on most platforms
03:12:26 <ClaudiusMaximus> @index digitToInt
03:12:26 <lambdabot> Data.Char
03:13:02 * earthy read that blogpost on the C EDSL and thought 'hey, this should be a standardised lib'
03:13:22 <njbartlett> augustss: Thought about doing that C thing with STRefs instead of IORefs? Simple translation I suppose. Very cool post BTW
03:13:28 <earthy> win some more hackers over.
03:14:15 <augustss> njbartlett: I have an implementation that is parametrized over any monad with references.  so it works with ST.  and STM
03:14:39 <njbartlett> Even better :-)
03:15:22 <augustss> I've just not put the code into darcs yet.  i hacked it all up last night
03:16:59 <augustss> now if I actually want to promote this library is another matter ;)
03:17:04 <doserj> I wonder what Bulat will find to complain :)
03:17:34 <njbartlett> I think Hudak will be horrified ;-)
03:17:46 <matthew_-> anyone written a haskell library for reading truetype fonts?
03:17:56 <augustss> njbartlett: rightly so!
03:17:57 <dons> matthew_-: not that i know of. sounds nice though
03:18:28 <matthew_-> dons: would be nice if it existed! ;)
03:18:28 <doserj> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL-ttf-0.4.0
03:18:31 <lambdabot> http://tinyurl.com/37ndkk
03:18:45 <matthew_-> dons: mmm, should I do it properly or should I just wrap the C libraries?
03:18:57 <njbartlett> augustss: Well if you didn't want to promote it, it's too late already. You're at the top of programming.reddit.com
03:19:12 <augustss> yeah.  i saw that :)
03:19:19 <dons> matthew_-: depends on whether there's a good existing C lib?
03:19:30 <dons> and how hard it is...
03:20:03 <matthew_-> dons: yeah, freetype seems to be what everyone uses - no idea whether it's actually good though
03:20:53 <matthew_-> dons: uh oh! http://www.freetype.org/freetype2/projects.html - bindings to Caml and IO. Haskell is missing out!
03:20:54 <lambdabot> Title: FreeType&nbsp;2 Related Projects
03:22:03 <dons> matthew_-: ok, sounds like something to do then!
03:22:30 <matthew_-> I'll raise a bug for it... :-P
03:41:32 <araujo> morning
03:43:21 <olsner> What not means is not not - it's not the not of logic.
03:44:45 <DRMacIver> Say what?
03:45:18 <olsner> Yes.
03:45:44 <DRMacIver> In what way does it differ from the not of logic? (Except in the fact that it has to handle undefined)
03:46:55 <opqdonut> :t not
03:46:57 <lambdabot> Bool -> Bool
03:47:10 <opqdonut> it's the not boolean operator, yes
03:47:18 <opqdonut> but not the not logical operator :)
03:47:59 <opqdonut> it manipulates truth values and doesn't modify logical expressions
03:48:00 <DRMacIver> Oh, right. Because it acts on truth values, not arbitrary predicates.
03:48:10 <DRMacIver> So the not of logic is really (not.) :)
03:48:13 <DRMacIver> (in Haskell)
03:49:12 <opqdonut> well, almost
03:49:22 <opqdonut> there is still a subtle difference :)
03:49:34 <DRMacIver> (It would be nice if the various Boolean functions were overloaded actually)
03:49:38 <DRMacIver> hm?
03:50:54 <opqdonut> can't really formulate it
03:51:47 <opqdonut> well, if you look at it this way: haskell functions of "-> Bool" aren't really predicates
03:51:52 <opqdonut> as they can be undecideable
03:51:54 <DRMacIver> True
03:52:03 <opqdonut> but i'm not sure whether that is really a problem
03:52:45 <DRMacIver> Really we should probably have not :: (BooleanAlgebra a) => a -> a
03:53:17 <DRMacIver> See usual comments about not enough polymorphism in the prelude though. :)
03:53:45 <opqdonut> yep :)
03:54:33 <opqdonut> that would also mean that we could have instance (Rational a) =>BooleanAlgebra a
03:54:36 <opqdonut> or something
03:54:38 <opqdonut> for fuzzy logic
03:55:09 <int-e> eek
04:07:09 <aleator> Does anyone know if c2hs #get hook is safe to use? (I recall that there was something funny about it..)
04:15:29 <folderol> evenin' haskellers. question: does anyone have any recommendations for resources for acquiring the mathematical foundations needed to really grok haskell?
04:15:40 <folderol> i'm thinking set theory, category theory, etc.
04:16:00 <folderol> i have a few introductory texts on order from amazon, but am looking for other opinions.
04:16:24 <osfameron> wikipedia, mathworld, working through exercises on projecteuler.net ?
04:16:39 <folderol> hmm... that last one, at least, is no help.
04:16:55 <MyCatVerbs> Haskell itself is, uh, rather simpler to 'learn' (at least well enough to get real things done using it) than a lot of the theory that underlies it.
04:17:28 <MyCatVerbs> Category theory is really evil, for example, and most introductory texts on it seem to list basically the entire field of mathematics as prerequisites.
04:17:41 <folderol> let me rephrase: i am a university maths major. i find myself out of my depth when the category theory specifically gets discussed on haskell-cafe (arrows, kleisli arrows, morphisms, etc).
04:18:03 <folderol> i'm making rapid progress with haskell itself, though.
04:18:07 <MyCatVerbs> Ah, right, I'd assumed you were coming from the other direction entirely.
04:18:11 <MyCatVerbs> No clue, then.
04:18:45 <Cale> folderol: Categories for the Working Mathematician is good
04:19:09 <Cale> folderol: It's a GTM by MacLane
04:19:57 <Cale> folderol: Most of the category theory I know, I just picked up in random places though. Algebraic topology is a particularly nice way to pick up lots.
04:20:12 <MyCatVerbs> I've seen a Prentice Hall book on category theory, "Computational Category Theory" or somesuch, which teaches category theory using ML (which is, for the purposes of what the book teaches, AFAIK similar enough to Haskell that you shouldn't really care).
04:20:14 <folderol> hmm... thanks, cale. just checking out your recommendation now.
04:20:24 <folderol> i have these two texts on order:
04:20:28 <folderol> 1 of: Basic Category Theory for Computer Scientists (Foundations of Computing)
04:20:37 <folderol> 1 of: Categories and Computer Science (Cambridge Computer Science Texts)
04:20:44 <MyCatVerbs> Quite old now, but I think it's pretty good. I'm having trouble with it myself because I don't have the mathematical background for it, really.
04:20:48 <folderol> on theory that they'll be nice and topical.
04:22:25 <Cale> The funny thing is that category theory is mostly finding itself useful as a library of possibly good definitions in new contexts. Figuring out what those definitions actually represent in the new context can be a bit of work :)
04:23:07 <Cale> For example, you might know what a monad is in the category theoretic sense, but that won't actually tell you how it's useful for programming straight away.
04:23:27 <opqdonut> yep
04:23:48 <opqdonut> first you spot the (approximate) pattern, then you formulate it
04:24:16 <opqdonut> same reason that "you could've invented monads" is the best way to teach them
04:24:36 <folderol> i've been working at that particular link today... :)
04:24:57 <opqdonut> i'm not saying the tutorial titled that way is the best
04:25:07 <opqdonut> i'm saying it's the best general approach :)
04:26:01 <folderol> this is what spurred me brush up on category theory: http://citeseer.ist.psu.edu/62964.html
04:26:03 <lambdabot> Title: An Introduction to Category Theory, Category Theory Monads, and Their Relationsh ...
04:26:29 <folderol> it's all very well, but it just didn't feel meaty enough.
04:26:41 <folderol> lambda: yeah, that's the very one.
04:27:20 <vincenz> @bot
04:27:20 <lambdabot> :)
04:28:05 <ClaudiusMaximus> > minBound :: Word8
04:28:06 <lambdabot>  0
04:28:26 <folderol> ah. i see.
04:30:11 <Cale> folderol: let me find another set of course notes which looked rather good
04:31:26 <folderol> thanks, cale.
04:34:03 <Cale> ... if only gmail will load.
04:39:15 <njbartlett> Hi everybody, I'm looking for ideas for talks at the Haskell User Group. Without worrying initially about who will give the talk, what would you like to hear about?
04:39:39 <dons> parallel programming? applicative functors? comonads?
04:40:19 <DRMacIver> I'd add my vote to all of those. :)
04:40:28 <njbartlett> By parallel programming do you mean the declarative stuff using "par" and friends?
04:41:00 <dons> that would be a good one, or `traditional' stuff involving forkIO/Chan/STM/TVars
04:41:14 <thoughtpolice> comonads look quite interesting although they are effectively sans documentation. :)
04:41:42 <njbartlett> STM would certainly draw the crowds...
04:41:54 <dons> was there already a talk on STM?
04:41:58 <dons> or only NDP?
04:42:03 <Cale> http://math.unice.fr/~eugenia/winter06/ -- ah here they are. It goes rather fast through the initial stuff though.
04:42:04 <DRMacIver> Just NDP.
04:42:04 <njbartlett> No, only the NDP one.
04:42:05 <lambdabot> Title: winter06
04:42:17 <Cale> http://www.dcs.ed.ac.uk/home/dt/CT/
04:42:18 <lambdabot> Title: Category Theory Lecture Notes
04:42:26 <folderol> thanks... checking it out now...
04:42:33 <njbartlett> It would be cool to hear from somebody who's used STM in practice :-)
04:42:46 <dons> its used in happs -- perhaps some of the happs guys?
04:42:55 <Cale> http://folli.loria.fr/cds/1999/library/pdf/barrwells.pdf -- this one seems to have lots of CS applications in it
04:43:08 <njbartlett> Who are the happs guys? I don't know much about it
04:43:10 <dons> it seems to be commonly used enough now that someone must have used some STM in a work-related program
04:43:11 <DRMacIver> njbartlett: Actually, "Haskell in Practice" talks would generally be good.
04:43:17 <thoughtpolice> i also remember a bittorrent client that used STM quite excessively
04:43:27 <thoughtpolice> Conjure, I think?
04:43:29 <DRMacIver> Mini progress reports on actual programs people have written. :)
04:43:34 <dons> njbartlett: happs, the (commercial) haskell web server stuff. (see #happs)
04:43:42 <dons> shapr is the mascot, if you can get hold of him
04:43:43 <Cale> folderol: so that's three, at least :)
04:43:54 <dons> conjure uses stm, yeah
04:44:08 <dons> there's a page on the haskell wiki from last year with a list of apps then using stm
04:44:21 <ClaudiusMaximus> @hoogle [Word8] -> IO ()
04:44:22 <lambdabot> No matches, try a more general search
04:44:24 <Cale> folderol: There's lots of good free notes on CT on the web, but you kind of have to stitch them together.
04:44:24 <thoughtpolice> i'm considering using STM in my little irc bot although I don't know if I'd take advantage of all of its features :p
04:44:34 <njbartlett> Cool, well there's some great ideas already. Anybody else?
04:44:47 <thoughtpolice> right now I'm trying to build ghc on dragonfly.
04:45:00 <dons> you could get lennart to talk about code generation inside haskell with harpy
04:45:24 <njbartlett> Lennart did a talk last time, I need to give him a break...
04:45:35 <njbartlett> I'll certainly exploit him more later though :-)
04:45:38 <dons> oh, pugs uses STM too. http://haskell.org/haskellwiki/Software_transactional_memory
04:45:39 <lambdabot> Title: Software transactional memory - HaskellWiki
04:45:59 <Cale> dons: Pugs perhaps even implements STM, iirc.
04:46:04 <dons> njbartlett: the theorem proving guys are interesting. getting Conor McBride to talk about epigram would be fun
04:46:12 <njbartlett> Ah, pugs, now I'm sure there's lots of talks that could come out of that...
04:46:14 <dons> Cale: or just layered on top, i think
04:47:06 <Cale> dons: They use strange names for the operations though :)
04:47:10 <njbartlett> Yeah, I thought about Conor McBride, he's at Nottingham yeah? Of course, Ross Paterson should be able to help out as well... he arranges the rooms at City Uni for us :-)
04:47:11 <thoughtpolice> iirc there's something about exposing haskell STM to perl 6 code via pugs,
04:47:19 <folderol> cale: thanks for that. i'm already paging through the ones you linked...
04:47:22 <thoughtpolice> maybe through hs-plugins if you build pugs with such support.
04:47:55 <Cale> folderol: Have you taken courses on groups and rings and such?
04:47:57 <thoughtpolice> i don't know though, the hs-plugins code in pugs might have bitrotted a little.
04:48:08 <folderol> yes, i should be solid on the basics.
04:48:11 <EvilRanter> where/when's this UG meeting?
04:48:20 <Cale> folderol: You're in undergrad right now?
04:49:06 <folderol> no - graduated a few years ago. i'm a working coder now, without much use for my higher maths...
04:49:10 <folderol> until now. ;)
04:49:37 <njbartlett> EvilRanter: The London HUG. There's a meeting every month. However, every other meeting is an informal pub meeting. I'm trying to find some talks for the next "formal" meeting which will be in September
04:49:39 <DRMacIver> EvilRanter: The next one is on the 22nd, but it's a pub meet. The next meeting with speakers is next month.
04:50:02 <EvilRanter>  @quote stereo, etc =]
04:50:20 <njbartlett> Great minds think alike (and fools seldom differ)
04:50:35 <Cale> folderol: ah, cool -- did you ever take a course in algebraic topology?
04:51:10 <folderol> no, i didn't. but after you mentioned it i did a quick search, and i've already found a free textbook that looks pretty good.
04:51:10 <EvilRanter> hm. i might be able to get to that. i don't think i'd have anything worth speaking about that.
04:51:19 <Cale> folderol: Hatcher's?
04:51:43 <folderol> lemme check...
04:51:58 <EvilRanter> *about though
04:52:03 <njbartlett> EvilRanter: Great... well if you go to www.londonhug.net and follow the links to register yourself on the mailing list, you'll get notified about the details when they're decided
04:52:15 <folderol> yes, indeed. allen hatcher.
04:52:18 <DRMacIver> EvilRanter: Speaking is very much optional. :)
04:52:30 <DRMacIver> (Well, in talks. You'll be required to speak at the pub :) )
04:52:34 <dons> njbartlett: yeah, you could get Ross to talk about applicative functors. that would be nice, since he co-authored the functional pearl abotu them
04:52:40 <folderol> i'm keen to see category theory in application - all i ahve at the moment is the nebulous impression that it provides insights into many other areas...
04:52:44 <EvilRanter> wait, my /nick's wrong...
04:52:47 <folderol> i'm assuming AT is one of these.
04:52:58 <Cale> folderol: It's good in many ways, but he skips out on making the most of category theory in a number of places.
04:53:01 <EvilTerran> ah, that's better.
04:53:04 * MyCatVerbs pokes the London HUG's \ogo. Hehehhehe.
04:53:11 <Cale> I rather like his approach to homology though.
04:53:29 <njbartlett> dons: Yeah, I was just skull-scratching through that yesterday, after reading your mentions of applicatives on here
04:53:48 <Cale> When you get to the Seifert van-Kampen theorem, there's a really nice categorical interpretation.
04:54:31 <dionoea> Hello. Is there a function like notElem which would work on infinite ordered lists
04:54:34 <dionoea> ?
04:55:03 <Cale> dionoea: What should it do if the element isn't there?
04:55:07 <Cale> oh
04:55:09 <Cale> ordered :)
04:55:18 <Cale> Yeah, I think you just have to write that for yourself.
04:55:25 <dionoea> or do I have to use stuff like (==) n $ head $ takeWhile (<n) list ?
04:55:32 <dionoea> ok
04:55:54 <DRMacIver> You want dropWhile don't you?
04:56:04 <dionoea> eh, right :) typo
04:56:25 <Cale> and you probably want (.) instead of ($)
04:56:35 <ClaudiusMaximus> is there a standard way to write [Word8] as raw bytes to standard output?
04:57:08 <Cale> ClaudiusMaximus: Data.ByteString provides a way
04:57:12 <dionoea> Cale: would that change anything performancewise ?
04:57:38 <DRMacIver> Shouldn't do if GHC is at all sane. Just nicer. :)
04:57:56 <Cale> dionoea: no, it's just considered slightly better style -- also, I didn't see the 'list' at the end of your comment when I wrote that initially.
04:58:02 <dionoea> ah ok :) I must be using too much $ everywhere in my code then :)
04:58:27 <Cale> dionoea: Whenever you have f $ g $ h $ x, it's always possible to write that as f . g . h $ x
04:58:39 <Cale> Which has the advantage that g . h, for example, is a subexpression.
04:58:46 <dionoea> ok, thanks for the tip
04:59:02 <oerjan> Cale: that could require more parentheses though
04:59:07 <Cale> oerjan: hm?
04:59:14 <EvilTerran> however, h $ x is no longer a subexpression
04:59:26 <EvilTerran> so it really depends on what you want, i'd guess
04:59:28 <oerjan> if f is a compound expression
04:59:40 <ClaudiusMaximus> @docs Data.ByteString
04:59:41 <lambdabot> Data.ByteString not available
04:59:46 <Cale> oerjan: Are you sure?
05:00:11 <Cale> Function application will bind tighter than either (.) or ($)
05:00:14 <oerjan> . binds tightest of all operators, while $ binds least tight
05:00:19 <Cale> yeah
05:00:27 <dionoea> are subexpressions somehow cached or computed better than non subexpressions ?
05:00:30 <oerjan> i was thinking about if f contains operators
05:00:39 <Cale> Oh, I see, yeah.
05:00:58 <Cale> dionoea: no, it's more just a refactoring issue.
05:01:35 <Cale> And a "thinking about it the right way" thing :)
05:01:48 <dionoea> hehe
05:01:49 <EvilTerran> if f is (g *** h) or something
05:01:59 <Cale> With ($), the way that you think about it is that you have a value, and you're applying functions to transform it one by one
05:02:20 <Cale> With (.), it's like you're building a function and then applying it to the value in the end.
05:02:37 <Cale> Performance-wise they're basically equivalent.
05:03:35 <Cale> In (f $ g $ h $ x), the "g $ h" doesn't mean anything on its own. In (f . g . h $ x), the "g . h" does.
05:05:03 <Cale> Plus, composing functions explicitly on a regular basis just gets you into the right mindset about working with functions as values.
05:05:40 <opqdonut> yep
05:06:09 <opqdonut> actually for some reason i often use f . g . h $ i x
05:06:15 <thoughtpolice> i always try for composition rather than application, sometimes you screw up but it's more of a practice thing.
05:06:29 <opqdonut> where i is an accessor and x is something complicated
05:06:41 <Cale> opqdonut: That's also reasonable.
05:07:08 <Cale> It just depends on what you consider to be the 'function' and what you consider to be the 'argument'
05:07:15 <opqdonut> yeah
05:07:53 <opqdonut> in those cases f, g and h are semantically "combinators" and i is something to get the actual value to shove into the "pipeline"
05:08:00 <opqdonut> or that's how i think about it
05:08:31 <opqdonut> "concat a . filter s . map d $ toList x" or something
05:08:43 <opqdonut> woops, s/ a//
05:14:51 <hpaste>  Cale pasted "composition prepares you for things like this :)" at http://hpaste.org/2245
05:15:43 <Saizan> it's bad that you can't mix (.) with infix functions, f . g . h `fmap` m doesn't work (even if here i could just (.) = fmap and use . all the way)
05:16:07 <Cale> Yeah, but you don't have to write fmap infix :)
05:17:46 <Cale> I rather like how that code I just pasted compares with the Java code we saw in my first university CS course.
05:18:31 <opqdonut> yeah gotta love the "(x:) ." fold
05:19:33 <Saizan> fmap (f . g . h) m is not so pretty!
05:20:03 <Cale> Saizan: It's not so bad :)
05:20:50 <opqdonut> why not just "f . g . h <$> m"
05:21:06 <dcoutts> aye, I like the applicative stuff
05:21:08 <opqdonut> (^2) . (*2) . (+2) <$> Just 1
05:21:16 <opqdonut> > (^2) . (*2) . (+2) <$> Just 1
05:21:28 <lambdabot>  Just 36
05:21:31 <opqdonut> \o/
05:22:13 <desp> Parse error
05:22:44 <Saizan> nice
05:22:52 <opqdonut> ?src <$>
05:22:53 <lambdabot> f <$> a = fmap f a
05:23:08 <opqdonut> i love how applicative and arrow give me nice operators <3
05:23:30 <opqdonut> soon my haskell code can look like J!
05:23:32 <opqdonut> muahahah
05:23:34 <Saizan> like arrows
05:23:51 <opqdonut> yep
05:23:55 <opqdonut> as i said :)
05:24:00 <Saizan> it's a bit sad that their most common use is as combinators for function composition, though
05:24:11 * Toxaris uses Control.Arrow mostly as Data.Pair
05:24:19 <opqdonut> :)
05:24:37 <dcoutts> they at least mean you never have to use liftMN again
05:24:39 <Vq^> Saizan: but it's a good thing that the common operators are more general
05:24:56 <dcoutts> liftM2 f x y = f <$> x <*> y
05:25:15 <Toxaris> but Control.Arrow makes a good addition to Data.Either, too :)
05:26:14 <Toxaris> > return (+) `ap` [1, 2] `ap` [3] -- old school version is not so bad, either
05:26:16 <lambdabot>  [4,5]
05:26:22 <Vq^> yeah, i find myself using 'right' fairly often
05:26:24 <DRMacIver> Cale: I'm having a surprising amount of difficulty following that code. :(
05:26:26 <int-e> > map (succ +++ pred) [Left 0, Right 0]
05:26:27 <lambdabot>  [Left 1,Right (-1)]
05:27:16 <Cale> DRMacIver: The fold replaces tree structure with function structure -- the function which is built will prepend the traversal of the tree onto the start of a list. That function is then applied to the empty list.
05:28:12 <Cale> Inside the lambda which is the second parameter to foldTree, the l and r are the functions for prepending the traversals of the left and right subtrees, respectively.
05:28:16 <DRMacIver> Cale: Yeah, I eventually figured that part out. I think I've finally got the concept in my head, just taking a bit more head scratching to get the details right.
05:30:05 <Cale> For example, preorder first turns the tree:
05:30:16 * EvilTerran temporarily abandons his experiments with TH and type-encoding
05:30:22 <Cale> Branch 1 (Branch 2 (Branch 3 Tip Tip) (Branch 4 Tip Tip))
05:30:22 <Cale>          (Branch 5 (Branch 6 Tip Tip) Tip)
05:30:34 * EvilTerran was trying to instance Num Type, but my brain is melting...
05:30:38 <Cale> into the function:
05:31:24 <DRMacIver> ok. I've got it.
05:31:29 <DRMacIver> But do carry on. :)
05:31:29 <Cale> (1:) . ((2:) . ((3:) . id . id) . ((4:) . id . id)) . ((5:) . ((6:) . id . id) . id)
05:31:40 <Cale> and then applies that to the empty list
05:31:45 <DRMacIver> That's really cunning.
05:32:00 <opqdonut> it's pretty straightforward actually
05:32:09 <Cale> Well, after you've seen it :)
05:32:14 <opqdonut> and once you think "lazily", natural
05:32:35 <Cale> It's not straightforward the first time, but what is? :)
05:32:47 <DRMacIver> The dividing line between natural and cunning is usually whether you've seen it (or similar) before. ;)
05:34:03 <hpaste>  Cale annotated "composition prepares you for things like this :)" with "another example" at http://hpaste.org/2245#a1
05:35:39 <Cale> Now, that's a bit contrived, I'll admit, because you could treat the key to search for as a parameter of search
05:35:58 <Cale> But I think it illustrates the idea of functions as data rather nicely anyway.
05:36:43 <Cale> You're in a sense building up a function which has the same structure as the tree.
05:37:37 <opqdonut> oh, that's a nice one
05:37:50 <Evir_Drevo> But your foldTree will not assemble functions only, will it? You could also use t = 0 and b = \x y z -> x + y + z to just sum the nodes...
05:38:00 <Evir_Drevo> Just making sure I am seeing right. :->
05:39:00 <Cale> Evir_Drevo: right
05:39:16 <Cale> Evir_Drevo: you can even use it to build other trees, or other data structures entirely
05:40:01 <Evir_Drevo> Yeah ok.
05:41:11 <Cale> foldTree Tip (\x l r -> Branch x r l) will flip the tree over
05:41:35 <int-e> the next step is to define  data Tree a = Tree (forall t . t -> (a -> t -> t -> t) -> t)
05:41:48 <Cale> hehe
05:42:57 <Cale> Evir_Drevo: foldTree is constructed so that  foldTree Tip Branch  will be the identity function.
05:43:07 <DRMacIver> Cale: You can write the second argument as flip . Branch can't you?
05:43:28 <Evir_Drevo> flip . Branch x rather.
05:43:34 <DRMacIver> No.
05:43:36 <Evir_Drevo> Since only r and l are flipped, not the x.
05:43:46 <DRMacIver> That's what the . is for
05:44:01 <Evir_Drevo> Ah.
05:45:28 <ketil> Hi!  Is Text.Html the recommended way to generate HTML from my Haskell data structure?
05:47:39 <ketil> Irssi is not the only focus of this guide. The ingenious program screen will also be discussed. Screen is a highly useful tool that allows a user to manipulate multiple windows inside of a single session. Each window operates independently of the others and acts like another terminal. For example, a user can create a screen session with Irssi running in the first window, an instant messenger program open in the second window, and a general purpose shell
05:47:59 * ketil blushes.  Sorry.
05:48:01 <dons> ketil: Text.Html or the xhtml package are pretty good
05:48:16 <dons> ketil: i used the 'xhtml' package and found it rathernice
05:49:15 <ketil> Okay.  I just need to wrap tags around some stuff, I'll take a look.
05:51:37 <xtacy[]> Hi
05:51:40 <ketil> It was available in apt-gettable form.  Keep forgetting to check that - perhaps Hackage should have an availability field in the listing?
05:51:56 <Cale> DRMacIver: indeed
05:53:20 <Cale> Also, fmap f = foldTree Tip (Branch . f)
05:53:30 <DRMacIver> Nice
05:53:48 <dcoutts> ketil: what kind of availability do you mean?
05:54:05 <Cale> Just like  map f = foldr ((:) . f) []
05:56:26 <ketil> dcoutts: something indicating availability for specific systems (windows, linux distros, etc) - but perhaps it would be overly complicated.
05:56:39 <ketil> I like to install system packages when available.
05:57:15 <dcoutts> ketil: ah right, yes. Having cabal-install integrate with system packages is something we need to think about.
05:59:38 <sutats> How do I capture the output from a script (ie. ~/script.pl) into a String?
06:01:01 <Cale> System.Process has some things for running processes and getting input and output handles
06:01:13 <sutats> Thanks.
06:01:18 <Cale> But there is a nicer library for it...
06:01:52 <thoughtpolice> sutats: see popen
06:02:00 <thoughtpolice> in particular.
06:02:10 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HSH-1.2.4
06:02:13 <lambdabot> http://tinyurl.com/2vmqhk
06:02:27 <Cale> http://software.complete.org/hsh
06:02:28 <lambdabot> Title: HSH
06:03:02 <thoughtpolice> hm apparently there isn't a popen in the standard libs. my bad. :x
06:03:41 <allbery_b> isn't popen from MissingH?
06:03:45 <sutats> Ah, okay. I was just checking and couldn't find it.
06:03:59 <Cale> HSH is rather nice
06:04:00 <dons> I use popen from the newpopen package
06:04:11 <dons> but its just a wrapper over system.Process
06:04:15 <dons> ?where newpopen
06:04:15 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/newpopen
06:04:21 <sutats> I think I'll stick to HSH, since it seems like it does what I want.
06:04:31 <dons> yeah, should be ok
06:05:17 <ClaudiusMaximus> does/can GHC do some kind of Array/List/Stream fusion yet? my code is using vast amounts of RAM, for Arrays that (most of the time) don't need random access
06:06:31 <Cale> ClaudiusMaximus: I'm not sure that any fusion is done with arrays yet.
06:06:41 <dcoutts> yeah, not yet
06:06:44 <dcoutts> not for arrays
06:06:52 <dcoutts> only for lists and bytestrings
06:08:58 <DRMacIver> Using arrays when you don't need random access seems... odd.
06:09:44 <DRMacIver> (At least unless you're doing in place updates, which it doesn't sound like you are if you want fusion)
06:10:08 <ClaudiusMaximus> DRMacIver: i know, but i'll need fast random access in some places in the future (i seem to have started writing an arrows-based image combinator 'thing'...)
06:11:25 <DRMacIver> ClaudiusMaximus: Maybe you should use lists (or streams directly) as an intermediate representation and only have arrays in the places where you know you need random access?
06:11:37 <DRMacIver> (Just a thought. I'm far from the best person to comment on this : ))
06:11:42 <DRMacIver> :) ) even
06:11:55 <Cale> For images, I'd expect you to want UArrays, even.
06:12:25 <Cale> The memory overhead of storing algebraic datastructures would kill you for large images otherwise.
06:13:00 <ClaudiusMaximus> i used UArrays before, i think - but that code was horrid (i made arrays instances of Num - yes i am suitably ashamed)
06:13:11 <Cale> Another option would be to represent images with functions.
06:13:47 <Cale> (which in the case of a loaded image file, would a lookup into a UArray)
06:13:49 <Cale> be*
06:13:54 <DRMacIver> ClaudiusMaximus: Sounds a reasonable thing to do to me. :)
06:15:04 <EvilTerran> making a generic image class / abstract type might be a good idea -- then you could profile various stuff on various implementations and see what worked best
06:15:07 <Cale> (you'd handle out of bounds indices by returning something like 100% alpha)
06:16:17 <ClaudiusMaximus> interesting
06:17:06 <Cale> You could also use Doubles as coordinates then.
06:17:19 <Cale> It's sort of the 2-D analogue to raytracing :)
06:18:08 <MyCatVerbs> ClaudiusMaximus: nonsense, do not be ashamed. Everything should be made into an instance of absolutely everything else. It's funnier that way.
06:19:06 <MyCatVerbs> ClaudiusMaximus: why not provide, for example, a modulo operator for binary trees? Obviously a neccessary addition to the set of functions available for workin' with 'em. :)
06:19:31 <ClaudiusMaximus> anyway, if you're in the mood for a headache, here's what my code made so far (using >300MB RAM) : http://img128.imageshack.us/img128/1922/testop0.png
06:19:57 <Toxaris> you can always us   newtype WithoutNum a = WithoutNum a deriving (<everything except Num>)  to get rid of  unneeded instances...
06:20:19 <sutats> Are there any libraries that manage ACPI? I want to calculate battery life, so my only solution right now is using regexes on /proc/acpi/battery/BAT*. Any suggestions?
06:21:45 <Cale> sutats: I'd be surprised :)
06:22:06 <sutats> Haha, oh well.
06:22:27 <Lycurgus> lmsensors?
06:22:46 <pejo> sutats, does 'acpi -b' list it for you?
06:23:24 <sutats> pejo: Yes, but I want to format it into something more readable to me.
06:23:37 <sutats> Lycurgus: I'll check that out.
06:25:29 <sutats> Lycurgus: Is that a general purpose monitor or something I can use natively in Haskell?
06:25:41 <sutats> Lycurgus: It seems like the former to me.
06:27:45 <Cale> I like how trac's wiki puts a little paragraph sign with a copyable link to each section when headings are rolled over. It would be nice to have a firefox extension which did that for all anchors everywhere.
06:28:14 <EvilTerran> could put something together in greasemonkey
06:29:45 <EvilTerran> hm... is it possible to create new IArray instances for array-like structures?
06:30:08 <EvilTerran> it seems... awkward.
06:30:42 <Igloo> how so?
06:30:42 <SamB_XP> EvilTerran: of course it's possible
06:30:47 <thoughtpolice> hm... weird. anybody know why trying to build the ghc libraries (i'm porting) would result in an unresolved symbol err to clock_gettime? it's weird because I built ghc 6.6.1 on the same box I'm bootstrapping the c files from just about two weeks ago...
06:30:51 <SamB_XP> you just import Data.Array.Base first
06:30:59 <EvilTerran> well, in that there's only one method in the class
06:31:08 <matthew_-> foldM seems to be a left fold. Is there a right fold too with M?
06:31:32 <matthew_-> or shall I just reverse the list?
06:31:42 <SamB_XP> EvilTerran: there's a lot more than one method in the class
06:31:49 <EvilTerran> ... i see no Data.Array.Base
06:31:53 <SamB_XP> EvilTerran: look at it in GHCi
06:32:44 <dcoutts> EvilTerran: the main restriction on IArray instances is that they *must* be polymorphic in the index type, so no specialisations for specific index shapes, like Int or (Int, Int)
06:32:50 <Lycurgus> sutats: I would be surprised if it had Haskell bindings.
06:33:15 <dcoutts> EvilTerran: so you can't make a bitmap type an IArray instance just for (Int, Int) x,y pixels
06:34:12 <EvilTerran> i think i'll implement what i'm after without doing an IArray instance, first, then fit one later if it turns out to actually be appropriate
06:34:17 <dcoutts> Igloo: you don't suppose we could fix that for the next ghc release? I think it'd only break existing IArray instance declarations, not uses of IArray stuff
06:34:45 <Igloo> dcoutts: Fix it how?
06:34:58 <MarcWeber> dcoutts: I'm getting them message that the macro AC_MSG_ERROR is not defined. Can you tell me which is the correct order and arguments to  call the autoconf tool chain in this case?
06:35:17 <dcoutts> Igloo: make the Ix i parameter of the class, rather than requiring all instances be polymorphic in the Ix i => i
06:35:35 <dcoutts> MarcWeber: autoreconf should do the right thing.
06:36:44 <dcoutts> Igloo: so all the existing instances would be modified to say they are indeed polymorpic in that class parameter, but then we could add new instances that only work with specific index types, like ByteString and Int
06:37:01 <Igloo> dcoutts: Well, you could propose it, but I doubt you'd be successful
06:37:02 <dcoutts> or bitmaps and (Int, Int)
06:37:20 <dcoutts> Igloo: how much do you think it'd break?
06:37:23 <Igloo> dcoutts: It would need fundeps/ATs for one thing, I think, which would break [ny]hc support
06:37:42 <dcoutts> would it? I don't see that it needs a fundep
06:37:50 <Igloo> Hmm, maybe it's only MPTCs
06:38:22 <dcoutts> I suppose the right thing to do is make a fork of the array package with the new scheme and test it
06:38:45 <dcoutts> and if the breakage vs advantages is acceptable then propose it
06:39:13 <EvilTerran> > concatMap (join $ replicate . (2^)) [0..]
06:39:15 <lambdabot>  [0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5...
06:39:39 <Igloo> dcoutts: If you want it in 6.8.1 then you'd have to do it in the next couple of days, though
06:39:51 <dcoutts> Igloo: aye, too short, never mind
06:40:21 <dcoutts> Igloo: I'll try and fix the bytestring test cases in time for 6.8.(0|1) though
06:41:16 <Igloo> dcoutts: OK; for now we're using a bytestring package with the old base code
06:41:22 <dcoutts> aye
06:41:46 <Igloo> dcoutts: Is http://hackage.haskell.org/trac/ghc/ticket/1375 fixed in the new branch?
06:41:59 <lambdabot> Title: #1375 (ByteStrings lines eats empty lines) - GHC - Trac
06:42:00 <dcoutts> if that's te lines bug, then no, not yet
06:42:05 <Igloo> OK
06:43:59 <thoughtpolice> grr. this is really annoying, does anybody have any idea as to why ghc-inplace wouldn't be able to find clock_gettime? (it's in libc.a iirc,)
06:45:02 <thoughtpolice> it's when trying to build cabal-setup, getThreadCPUTime in libHSrts.a can't find libc.a or something when linking
06:46:08 <EvilTerran> ?type unfoldr
06:46:10 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:47:57 <EvilTerran> > splitAt 0 [1..10]
06:47:58 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
06:56:32 <Cale> thoughtpolice: I'm afraid I have no idea. Maybe run with -v ?
06:58:03 <thoughtpolice> Cale: I'll have to fiddle. :)
07:05:58 <jethr0> hmm, i had a discussion with a friend recently about garbage collection vs. realtime and i noticed how litte i know about GC in haskell.
07:06:44 <jethr0> is it done dynamically (i.e. by wandering through ram and tagging data for removal) with the ensuing GC "pauses" or is most of it done statically at compile time?
07:07:00 <dolio> It's a copying collector, I think.
07:07:38 <EvilTerran> @src concatMap
07:07:38 <lambdabot> concatMap f = foldr ((++) . f) []
07:08:00 <dolio> So, you copy all the live stuff to a new area of memory, and then forget all the old pointers.
07:08:06 <jethr0> dolio: k, so would that be totally dynamic or more static with the help of the compiler?
07:08:08 <dolio> The garbage automatically goes away.
07:08:15 <jethr0> hmm
07:08:23 <jethr0> how do you what the live stuff is?
07:08:34 <Cale> It's actually a hybrid
07:09:17 <dolio> Well, presumably you'd have some set of stuff you know is live initially, and follow pointers from there.
07:09:17 <jethr0> s/you/you know/
07:09:25 <dolio> Same as any collector.
07:09:29 <Cale> http://hackage.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
07:09:30 <lambdabot> Title: GarbageCollectorNotes - GHC - Trac
07:09:46 <jethr0> yes, but that would be completely at runtime, even though at compile-time much of that information is already available, no?
07:11:20 <jethr0> so, when playing frag, are those pauses in gameplay when then GC "activates"?
07:12:05 <SamB> better than freecraft or whatever that thing is called these days, I bet
07:12:43 <dolio> I'm afraid I don't know much more than you on this subject. :)
07:12:47 <jethr0> and region inference is a completely different idea then, i guess...
07:12:48 <pejo> jethr0, the problem of "realtime gc" is usually phrased as "small and bounded delays". More research is definitely needed, but there will be some papers on ISMM'07 on that I think.
07:13:01 * jethr0 goes off to read some more about "region inference"
07:13:23 <dolio> Region inference is still a pretty active area of research, I think.
07:14:10 <jethr0> i would have thought that haskell would do a lot of GC with dataflow analysis at compile time and only do the rest which depends on runtime data at runtime...
07:14:13 <jethr0> ;(
07:16:38 <EvilTerran> i think, at compile-time, it tries to eliminate allocation where possible, rather than setting allocated stuff to be freed on the fly
07:16:58 <pejo> jethr0, well, deforestation-like transformations reduce amount of garbage, for example. But it doesn't eliminate the need for it.
07:17:44 <jethr0> k, thx
07:19:50 <pejo> jethr0, http://www.diku.dk/topps/space/space2001/TofteHallenberg.ps.gz
07:22:59 <MarcWeber> @tell tuxplorer: I can reproduce your trouble. I'm getting it as well.
07:22:59 <lambdabot> Consider it noted.
07:37:35 <MarcWeber> @tell tuxplorer  http://rafb.net/p/Q2DY8z18.html  The .o file is containing the symbol, but ghci can't find it
07:37:35 <lambdabot> Consider it noted.
07:38:34 <roconnor> I don't get what ``design patterns'' are.
07:38:46 <thoughtpolice> pretty?
07:38:55 <roconnor> Are they just for shmoes who don't have higher order functions?
07:39:05 <byorgey> common ways of structuring programs?
07:39:29 <mrd> roconnor: yes
07:39:45 <byorgey> roconnor: hm, interesting
07:39:51 <Cale> roconnor: They're failings of common OO languages.
07:39:53 <roconnor> If there are a bunch of common ways of structuring programs, shouldn't that commonality be abstracted?
07:39:57 <Cale> yes
07:40:12 <roconnor> instead they are just documented.
07:40:14 <Cale> and the design patterns are things which typical OO-languages lack the expressiveness to abstract
07:40:36 <Cale> Most people seem to miss this point.
07:40:50 <Cale> and think that they're techniques to be repeated over and over in code :)
07:40:54 <roconnor> Cale: I guess I've been corrupted by functional programming.
07:41:14 <Cale> (which in effect is exactly what they have to do anyway, unless they're willing to switch languages)
07:41:14 <roconnor> I just find it hard to wrap my head around this OO stuff.
07:41:29 <mrd> it's not worth it
07:41:33 <yaxu> so design patterns are documented failings of java
07:41:37 <dcoutts> sjanssen: how's hxcb going? :-)
07:41:42 <Cale> yaxu: basically, yes :)
07:42:35 <byorgey> But don't we have design patterns in Haskell too?
07:42:47 <Cale> Yes, and those are the places where Haskell is failing us.
07:42:53 <cjeris> roconnor: my entire motivation for learning semantics and type theory is to give formal weight to my intuitive suspicion that imperative OO programming is a fundamentally wrongheaded concept :D
07:42:58 <osfameron> I don't think all design patterns are a bad thing
07:43:17 <Cale> They're not necessarily bad, they're just places where your language could be better.
07:43:38 <osfameron> MVC is a good pattern, irrespective of your language
07:43:54 <roconnor> MVC?
07:44:02 <osfameron> model-view-controller
07:44:08 <osfameron> basically, separation of concerns
07:44:26 <roconnor> model-view-controller?
07:44:30 <osfameron> which you get for free in Haskell with the separation of main :: IO  and the backend functions
07:45:17 <roconnor> Ugh, I'll never be able to get a job programming in Java or C++ again.
07:45:22 <Cale> In Haskell, the IO monad is typically used to implement the view and controller, and your model is a bunch of pure code.
07:45:29 <doserj> roconnor: lucky you
07:45:54 <mauke> http://blog.plover.com/prog/design-patterns.html
07:45:55 <lambdabot> Title: The Universe of Discourse : Design patterns of 1972
07:46:13 <roconnor> doserj: I'm going to be pennyless.
07:46:14 <osfameron> it's a shame, cos the Alexander books themselves are lovely
07:46:46 <osfameron> patterns like "Write tests first" and "Use version control" are useful, but the GoF stuff was much more limited in scope
07:46:50 <eivuokko> dcoutts, Ping.
07:46:58 <dcoutts> eivuokko: pong
07:47:26 <dolio> Those are patterns?
07:47:39 <eivuokko> dcoutts, :)  What is the relation of Distribution and Distribution.Simple - they are depend on each other in few ways, at least.
07:47:45 <Cale> Those aren't what I'm talking about when I say "design pattern"
07:47:58 <osfameron> no, but they're very much like the Alexander patterns
07:48:04 <dcoutts> eivuokko: Distribution.Simple is supposed to depend on Distribution but not the other way around
07:48:23 <dcoutts> eivuokko: Distribution is supposed to be just declarative information about .cabal files and similar
07:48:33 <osfameron> he goes all the way from macro to micro: how to structure neighbourhoods to avoid ghettoes, down to what windows to use, where to put your living room, and how high to put your shelves
07:48:54 <dcoutts> eivuokko: Distribution.Simple is the implementation of a build system based on the info from .cabal files (and Setup.hs files)
07:49:02 <eivuokko> dcoutts, Ah, I thought so.  I've been doing modifications in that direction for breaking import cycles.
07:49:17 <eivuokko> dcoutts, (Which I introduced with something I wanted to implement)
07:49:23 <dcoutts> eivuokko: some things currently in Distribution really ought to go into .Simple
07:49:46 <dcoutts> eivuokko: eg Compiler, Program, PreProessor
07:49:52 <dcoutts> I think
07:49:59 <eivuokko> dcoutts, Program too?
07:50:18 <dcoutts> eivuokko: it's intimately related to the simple build system I'd say
07:50:41 <eivuokko> dcoutts, Yeah, I think you are right.
07:50:56 <eivuokko> dcoutts, I just moved bunch of stuff from Program to Simple.Utils
07:51:04 <eivuokko> dcoutts, Guess I take that back and do darcs mv
07:51:08 <dcoutts> eivuokko: ah, I'm working on Pogram too :-)
07:51:30 <eivuokko> dcoutts, Heh.
07:51:46 <dcoutts> eivuokko: I've redone the install dirs code, I'll push that now, so we don't get too many conflicts later...
07:52:12 <eivuokko> dcoutts, mhm
07:52:40 <eivuokko> dcoutts, I'll check out later, no hurry.
07:53:18 <dcoutts> eivuokko: for Program, I'm trying to restructure it so we properly distinguish programs and configured programs we can actually run
07:53:31 <dcoutts> so a program must be configured before we can run it
07:53:46 <eivuokko> dcoutts, Yes.  It's not really "type safe" right now.
07:53:58 <dcoutts> and that should make it easier to add a build-tools: field
07:54:30 <dcoutts> and not warn people unecessarily about progs we didn't find, but should louder if we don't find things we need
07:54:38 <dcoutts> should/shout
07:55:04 <eivuokko> Ah, I'd need that field for building packages in hackage - it's ordering sort of dependency.
07:55:17 <eivuokko> I was thinking I have to push programs up in list as a workaround...
07:55:57 <dcoutts> yes, build tools could be used for package dep tracking too
07:58:17 <dcoutts> eivuokko: pushing now, btw you might want to take a look at Distribution.Simple.InstallDirs.defaultInstallDirs for the windows paths
07:58:53 <dcoutts> eivuokko: I've not actually hooked up the --docdir flag yet but that should be easy now with the new infrastructure
07:58:59 <eivuokko> dcoutts, Cool :)
07:59:09 <dcoutts> eivuokko: perhaps you can do that and tell me if the code is now more comprehensible :-)
07:59:41 <pgavin> hello
07:59:46 <dcoutts> hia pgavin
07:59:54 <dcoutts> eivuokko: pushed.
08:00:12 <pgavin> i worked a bit on dependencies last night
08:00:17 <dcoutts> great
08:00:53 <dcoutts> pgavin: any wise insights? :-)
08:00:57 <pgavin> um
08:01:32 <pgavin> only that it's going to be tough :)
08:01:36 <eivuokko> dcoutts, Thanks.
08:02:38 <pgavin> dcoutts: you know, I don't think make actually builds a dependency graph internally
08:03:01 <eivuokko> I think it cannot.
08:03:29 <pgavin> if you run make -d it shows you what it's thinking
08:04:13 <pgavin> I haven't looked at the actual source for make, but I think it just recurses on subtargets, using a few rules to prevent cycles
08:04:38 <pgavin> which is what I think we'll have to do
08:04:46 <eivuokko> Does it prevent all cycles, or just no-action-between cycles?
08:05:13 <dcoutts> pgavin: aye, that's fine, we're just exploring a graph, we don't necessarily need to build the whole thing
08:05:21 <dcoutts> pgavin: did you look at ndm's code?
08:05:35 <pgavin> yeah, I was using it as a starting point
08:05:37 <dcoutts> pgavin: it does some nice things like caching stat calls
08:05:39 <dcoutts> right
08:06:45 <dcoutts> that's what's nice about a decent make system, rebuilding a big system when there is nothing to do should only involve stating a few hundred files and complete in less than a second
08:06:48 <pgavin> I don't think we'll be able to use it though, honestly
08:06:58 <pgavin> right
08:07:04 <dcoutts> when gtk2hs's automake makefile system works well it does just that
08:07:23 <dcoutts> it stats probably a thousand files and takes less than half a second
08:07:29 <pgavin> right
08:07:40 <dcoutts> which is much much faster than ghc --make
08:08:18 <dcoutts> and I guess that's because in the makefile system it's caching the dependencies too in .depend files
08:08:20 <pgavin> does ghc --make actually inspect the files, though?
08:08:39 <dcoutts> exactly, it has to do dep chasing since it does not cache deps in the file system
08:08:47 <pgavin> right, ok
08:09:24 <Igloo> I think it's having to preprocess that really kills ghc --make
08:10:01 <dcoutts> Igloo: right, cpping
08:10:26 <dcoutts> I think if we get dep chasing in cabal we should use ghc one shot mode rather than --make
08:10:37 <dcoutts> so we can cache the unpped files and dependencies
08:10:53 <pgavin> dcoutts: I agree
08:11:01 <dcoutts> and so we can do parallel builds
08:11:05 <pgavin> exactly
08:12:45 <dcoutts> we still have to support building all .hs files in one go though, for jhc at least
08:13:14 <dionoea> Is it possible to write something like (\x->(f x,g x)) without using a lambda? (I haven't found anything on hoogle)
08:13:32 <dcoutts> @hoogle ***
08:13:32 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:13:39 <mauke> @pl  (\x->(f x,g x))
08:13:40 <lambdabot> liftM2 (,) f g
08:13:40 <conal> @hoogle &&&
08:13:41 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
08:13:53 <ivant> @where arrows-doc
08:13:53 <lambdabot> I know nothing about arrows-doc.
08:14:17 <bluestorm> i have another question
08:14:44 <dionoea> hum, looks like i didn't enter the right type signature :) (I used (a->b)->(a->c)->a->(b,c))
08:15:16 <bluestorm> is there a way to do a polymorphic recursive function, such that for example  "fold ($) (+) [1, 2]" would work ?
08:15:48 <mauke> huh?
08:15:53 <dcoutts> pgavin: Igloo: another possible advantage of doing our own dep chasing might be to build several related packages inplace in parallel, we can track cross-package deps though ghc doesn't.
08:16:23 <dcoutts> that'd make building ghc + core libs quicker for machines with enough cpus
08:16:34 <pgavin> right
08:16:36 <dcoutts> currently packages tend to serialise builds
08:16:41 <Igloo> That sounds scary
08:16:43 <pgavin> yes
08:17:08 <dcoutts> Igloo: we already do that, albeit not in parallel
08:17:18 <Igloo> already do what?
08:17:36 <dcoutts> Igloo: gtk2hs and some other multi-package systems register inplace before building, then build
08:17:37 <Igloo> We don't track cross-package deps at all
08:17:45 <dcoutts> ghc doesn't
08:19:46 <dcoutts> Igloo: but if we use ghc in one-shot mode I don't see that a dependent package has to be fully built yet before compiling other modules that depend on only a subset of modules from the dependent package
08:20:29 <pgavin> dcoutts: so jhc doesn't support one-shot mode?
08:20:35 <dcoutts> the dependent package does have to be registered of course and imports have to go via the package otherwise we'd get package names wrong.
08:20:41 <dcoutts> pgavin: it's a whole program compiler
08:21:30 <pgavin> ok, so I guess it doesn't do libraries then
08:21:39 <Igloo> dcoutts: Sure, it's possible, it's just scary. It would be less scary if we had a metapackage package type (so a package would be library|executable(s)|meta)
08:22:12 <Igloo> But this is all too ambitious for a first implementation, I think
08:22:17 <pgavin> lol
08:22:28 <dcoutts> Igloo: meta, you mean a package that has no lib or exe stanzas but build-depends on other packages
08:22:45 <Igloo> It doesn't build-depend on them, it builds them
08:22:49 <dcoutts> Igloo: and yes, we don't need to think about multiplie packages for ages
08:22:58 <Igloo> So building gtk2hs.cabal would build gtk.cabal, glib.cabal, ...
08:23:24 <dcoutts> Igloo: I was thinking of a design where we just build all the .cabal packages in the directory
08:23:35 <Igloo> Then it is much more reasonable for them to know about each others internal deps etc
08:23:39 <dcoutts> so no special notion of a meta package
08:24:18 <Igloo> Well, then the directory is essentially the same as the meta package cabal file, except you have no way to put in a description etc
08:24:24 <dcoutts> right
08:24:36 <dcoutts> and you can't dep on a meta package
08:26:26 <pgavin> dcoutts: what time is it where you are, about 4:30pm?
08:26:34 <dcoutts> @localtime dcoutts
08:26:35 <lambdabot> Local time for dcoutts is Tue Aug 14 16:26:29
08:26:36 <allbery_b> @time dcoutts
08:26:36 <lambdabot> Local time for dcoutts is Tue Aug 14 16:26:30
08:26:37 <allbery_b> heh
08:26:44 <pgavin> lol
08:26:52 <pgavin> didn't know about that
08:26:57 <dcoutts> @localtime pgavin
08:26:58 <lambdabot> Local time for pgavin is Tue Aug 14 11:26:17
08:27:41 <pgavin> is there a way to list all of lambdabot's commands?
08:27:44 <pgavin> @help
08:27:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:27:48 <pgavin> ah
08:27:51 <pgavin> @list
08:27:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:29:00 <MarcWeber> dcoutts: Sorry for bothering you again http://rafb.net/p/srzPoS35.html. 101 is line 115. The + is shown by bash echoing the commands (+x option).. Where should AC_MSG_ERROR be defined?
08:29:02 <lambdabot> Title: Nopaste - No description
08:30:08 <pgavin> MarcWeber: ac_msg_error is provided by autoconf
08:30:17 <dcoutts> MarcWeber: AC_MSG_ERROR is not defined in the local gtk2hs files, it's from the standard autoconf library of macros
08:30:48 <dcoutts> MarcWeber: the problem here is that your autoconf installation is borked, it's like ghc not being able to find the Prelude
08:30:51 <pgavin> if it's not being found, your autoconf installation is probably broken :)
08:31:25 <pgavin> MarcWeber: are you sure you're using autoconf 2.5x?
08:31:33 <pgavin> MarcWeber: and not the old autoconf-2.1x?
08:32:11 <pgavin> I think AC_MSG_ERROR was called just AC_ERROR or something in the old version
08:32:27 <sutats> I'm reading http://www.serpentine.com/blog/2007/01/31/parsing-a-simple-config-file-in-haskell/, but I'm not sure how to call readConfig and what to pass to listToMap.
08:32:30 <lambdabot> Title: teideal glic deisbhalach  Blog Archive  Parsing a simple config file in Hask ..., http://tinyurl.com/yqqemt
08:33:08 <astrolabe> Is there a built-in priority queue somewhere?
08:33:16 <astrolabe> Or should I do my own?
08:34:00 <mauke> .oO( Data.Map )
08:34:23 <astrolabe> What does '.oO' mean?
08:34:32 <mauke> thought bubbles
08:34:58 <pgavin> that's what I was thinking
08:35:00 <astrolabe> Ah.  Yeah, I'd do it by wrapping Data.Map I guess.
08:35:09 <pgavin> or just use it directly
08:35:15 <sjanssen> astrolabe: edison!
08:35:15 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
08:35:57 <astrolabe> pgavin: I feel it would be nicer wrapped.  It makes the intention clearer.
08:36:09 <pgavin> astrolabe: sure :)
08:37:01 <astrolabe> If I did that properly, how difficult would it be to get it into the Data hierarchy?
08:37:24 <_vz_> @list
08:37:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:37:35 <pgavin> astrolabe: well, Map is overkill for a pqueue
08:37:53 <dcoutts> yes, you want a heap
08:38:03 <mauke> Data.FingerTree
08:38:07 <pgavin> astrolabe: if you want it in the std libs you'd want to use an actual heap
08:38:21 <astrolabe> What is the advantage to a heap?
08:38:30 <astrolabe> (after it has been wrapped)
08:38:30 <pgavin> its not fully sorted
08:38:34 <dcoutts> better complexity
08:38:40 <astrolabe> Ah
08:38:47 <pgavin> findMin () on a heap is super fast
08:38:55 <pgavin> findMin on a map is log n
08:38:58 <dcoutts> and you can build a heap in linear time
08:39:10 <astrolabe> But surely the Map is lazy.
08:39:10 <pgavin> yes, that too :)
08:39:16 <dcoutts> since it's less sorted than a sorted binary tree
08:39:33 <astrolabe> It is?  I should read about heaps again.
08:40:33 <dcoutts> that's how heapsort works
08:40:41 <Toxaris> a heap is only sorted top-to-bottom: the root of every sub-heap is the smallest element of that subheap. but a sorted tree is sorted left-to-right: every item in the left substree is smaller then the root is smaller then every item of the right subtree.
08:40:51 <dcoutts> you build the heap in linear time, and then pay log (n) for each element you pull out
08:41:51 <astrolabe> Wouldn't that be the same for a lazy Map?
08:41:53 <dcoutts> so for getting the smallest m items you pay O(n + mlog n)
08:41:59 <pgavin> findMin() is O(1), right? but reordering the heap is log(n)
08:42:25 <pgavin> I mean, if your remove the minimum
08:43:08 <MyCatVerbs> pgavin: yuss. Hence, heapsort
08:43:17 <pgavin> right
08:43:23 <dcoutts> astrolabe: hmm, not sure how the lazyness affects it, certainly for a strict map it's O(nlogn) to build, then O(m) to get the m smallest
08:43:26 <astrolabe> A lazy binary tree wouldn't actually build the right hand part of the tree until elements were requested from it.
08:43:40 <Toxaris> astrolabe: a *balanced* sorted tree cannot be very lazy I think. And *unbalanced* sorted trees have bad worst case complexity
08:44:16 <dcoutts> astrolabe: aye, it'd depend on the order in which elements are added to the Map
08:44:22 <astrolabe> Toxaris: That sounds plausible.
08:44:30 <astrolabe> dcoutts: Another point
08:44:44 <astrolabe> I hope you've got all that weed off :D
08:44:57 <pgavin> if you put a sorted list into a unbalanced tree you end up with a sorted list :)
08:45:43 <astrolabe> I supposet a heap isn't balanced
08:45:53 <pgavin> yes it is
08:46:05 <astrolabe> hmmm
08:46:08 * astrolabe reads
08:46:10 <pgavin> but its easy to keep balanced
08:46:19 <Toxaris> astrolabe: it is, but the rotations are easier because of the weaker invariant
08:46:21 <pgavin> because you're not actually keeping the nodes sorted
08:46:44 <Toxaris> a Heap in Haskell should be less then 10 lines, I think
08:46:55 * Toxaris starts writing a small Haskell Heap
08:46:56 <pgavin> any node in the heap is smaller (or bigger) than any node below it
08:47:06 <dcoutts> eivuokko: another useful refactoring would be to separate the cabal comand line UI into separate modules from the cabal library API
08:47:11 * mrd curls up in a heap
08:47:48 <dcoutts> eivuokko: that'd make the library api boundary more obvious and we could start to think about how to make that api nicer
08:48:18 <dcoutts> eivuokko: eg you pointed out yesterday that reading the .cabal package has to be done in IO
08:51:28 <dcoutts> sjanssen: wow, I'd never seen filterM (const [True, False]) before. It's very compact for what it does.
08:51:54 <EvilTerran> hm... is there some class for all ordered collection types? IArray is close, but is kinda limited to finite collections only
08:52:03 <sjanssen> dcoutts: yes, it's a fun one ;0
08:52:26 <EvilTerran> @src filterM
08:52:26 <lambdabot> Source not found. Take a stress pill and think things over.
08:53:18 <pgavin> @type filterM
08:53:19 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
08:53:22 <EvilTerran> > filterM (const [True, False]) [1,2,3]
08:53:24 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
08:53:30 <eivuokko> Cheating ;)
08:53:34 <EvilTerran> huh!
08:53:48 <pgavin> wow
08:54:01 <EvilTerran> ...that makes sense. cool.
08:54:32 <Japsu> Err, wtf ;D
08:54:39 <eivuokko> dcoutts, Mmm, I see.  I didn't think about it before, but yeah, makes sense.
08:54:53 <Japsu> That's like total abusage of the list monad
08:55:02 <pgavin> yeah, totally
08:55:09 <dcoutts> no it isn't!
08:55:09 <eivuokko> Abuse?  It's brilliant.
08:55:13 <ski> proper use, not abuse :)
08:55:21 <pgavin> lol
08:55:24 <dcoutts> list monad is for backtracking, this is a good example of backtracking
08:55:39 <Japsu> So that's a list of all subsets?
08:55:45 <dcoutts> right
08:55:50 <pgavin> I still have a hard time with the list monad
08:55:56 <EvilTerran> i understand the list monad just enough to see that that would be pretty transparent to someone who can think in it
08:55:57 <Japsu> Figuring that out from the code is, well... nontrivial
08:55:59 <xerox> > mapM (\c -> [toUpper c, toLower c]) "abc"
08:56:00 <lambdabot>  ["ABC","ABc","AbC","Abc","aBC","aBc","abC","abc"]
08:56:08 <pgavin> the only time I use it is for [ x*x | x <- xs ] etc.
08:56:31 <EvilTerran> map (^2)?
08:56:35 <pgavin> xerox: ah, that's instructive
08:56:56 <pgavin> EvilTerran: well, yeah, but usually there's more code than just x*X
08:57:22 <EvilTerran> ah... you mean you only use the list monad as list comprehensions?
08:57:40 <pgavin> yeah, that's what I mean :)
08:57:56 <osfameron> so the list monad executes functions in one list over values in another list?
08:57:56 <shapr> Are there any Haskell-oriented proof assistants?
08:57:58 <ski> > map concat $ sequence $ map (\x -> [[x],[]]) [1,2,3]
08:57:59 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
08:58:37 <pgavin> ski: ok, that helps too
08:58:51 <ski> s/sequence $ map/mapM/
08:59:05 <EvilTerran> osfameron, it expresses non-determinism, by having a list of all possible values of something
08:59:07 <ski> > map concat $ mapM (\x -> [[x],[]]) [1,2,3]
08:59:08 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
08:59:10 <MarcWeber> dcoutts, pgavin ACLOCAL_PATH wasn't set correctly because I hadn't added the dependency automake to buildInputs. This might have been the cause
08:59:12 <mauke> > sequence ["foo", "bar"]
08:59:14 <lambdabot>  ["fb","fa","fr","ob","oa","or","ob","oa","or"]
08:59:34 <pgavin> lol
08:59:52 <EvilTerran> do x <- [1..4]; {- code in which x is each value in turn -}
09:00:20 <pgavin> right
09:00:21 <mauke> sequence is like a drunken brute-force transpose
09:00:29 <eivuokko> Heh.
09:00:53 <ski> combinations
09:01:14 <shapr> Coq seems to be OCaml oriented rather than Haskell oriented.
09:01:28 <ski> (with streams, possibly it is transpose, more or less)
09:01:35 <EvilTerran> i'm guessing filterM f (x:xs) = do p <- f x; liftM (if p then (x:) else id) $ filterM f xs
09:01:39 <Botje> I like that idiom better as filterM (const [True, False]) list
09:01:48 <ski> shapr : istr one can extract haskell too
09:01:58 <shapr> oh, ok
09:02:00 <byorgey> EvilTerran: exactly
09:02:43 <opqdonut> ?src fliterM
09:02:43 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:02:50 <opqdonut> ah
09:02:52 <byorgey> EvilTerran: I wrote an article about that filterM trick on my blog (byorgey.wordpress.com)
09:03:34 <EvilTerran> i understand why it does what it does, i just probably wouldn't've been able to work it out on my own
09:03:53 <byorgey> EvilTerran: "work it out", or "come up with it"?
09:04:25 <EvilTerran> as in, given the line, i couldn't've told you what it did without doing an example
09:12:46 <sutats> @paste
09:12:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:14:27 <hpaste>  Toxaris pasted "simple Heap" at http://hpaste.org/2246
09:16:55 <mrd> shapr: Extraction Language Haskell.
09:18:21 <Japsu> @source filterM
09:18:21 <lambdabot> filterM not available
09:18:29 <Japsu> @src filterM
09:18:29 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:18:32 <Japsu> stupid bot :<
09:19:21 <mrd> I'd say Coq definitely has an OCaml feel to it.  But some of the distinctions between Haskell and OCaml become irrelevent in the Coq context -- like laziness vs strictness.
09:19:56 <sutats> I'm new to Haskell, so can someone tell me what I'm doing wrong in my main? - http://hpaste.org/2247#a0
09:20:16 <mrd> lookup takes 2 parameters
09:20:43 <mrd> you need to get the result value of readConfig, which is an Either, and pattern match it
09:21:01 <mrd> consider the Left ParseError, or the Right Config
09:21:25 <sutats> Do you mind going into more detail?
09:21:30 <mrd> sure one moment
09:22:43 <hpaste>  mrd annotated "Print value from map through readConfig" with "case breakdown" at http://hpaste.org/2247#a1
09:24:47 <sutats> mrd: Ah, thanks, that clears things up.
09:25:22 <mrd> IIRC to print a Parsec error takes a little more finagling because it is actually a list of things
09:27:09 <chessguy> slightly off-topic and vague question, but anybody know of an algorithm for choosing n numbers whose hex representations can be used as colors which are in decent contrast with each other?
09:27:16 <sutats> mrd: Makes sense. If I didn't want to handle the Left at all, should I just do putStr ""?
09:27:26 <mrd> return ()
09:27:43 <sutats> Ah, right.
09:27:53 <byorgey> chessguy: writing an auto-color-scheme-generator, are we?
09:28:11 <chessguy> byorgey, not quite. i'm choosing a few colors for a graph
09:28:19 <chessguy> but i don't know how many colors at runtime
09:29:37 <byorgey> chessguy: ah, ok.  well, I would think that the "contrast" between two colors is highly correlated with their Euclidean distance in RGB-space
09:29:37 <hpaste>  Toxaris annotated "Print value from map through readConfig" with "well-typed version of main" at http://hpaste.org/2247#a2
09:30:01 <byorgey> chessguy: so you just need to pick n points which are pairwise not too close to one another
09:30:11 <chessguy> interesting
09:30:23 <chessguy> and not necessarily easy
09:30:32 <byorgey> chessguy: now, how you do that... I'm thinking =)
09:30:34 <mrd> Toxaris: ah, thank you.  I sometimes forget about the monadic return value of lookup.
09:30:46 <chessguy> i mean for 2 points, i can simply pick 2 opposite corners
09:30:50 <mrd> usually I wrap it with "fromMaybe"
09:31:30 <sutats> Toxaris: Thanks, that clarifies it even more.
09:32:09 <Toxaris> @type Map.lookup
09:32:11 <lambdabot> Couldn't find qualified module.
09:32:14 <chessguy> byorgey, well, i do know it won't be more than a few dozen, so i suppose i could pick an n, and then plot a bunch of points
09:32:20 <Toxaris> @type Data.Map.lookup
09:32:22 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
09:32:26 <byorgey> chessguy: hmm... how about some sort of iterative process where you randomly pick n colors, then go through a number of iterations and have the color points "repel" one another
09:32:38 <Liskni_si> chessguy: i was looking for the same thing yesterday and the only interesting thing i found is this: http://mmis.doc.ic.ac.uk/mmir2005/CameraReadyMissaoui.pdf and http://search.cpan.org/~mbarbon/Color-Similarity-HCL-0.02/lib/Color/Similarity/HCL.pm -- doesn't say anything about generation though
09:32:51 <mauke> do it C style!
09:33:08 <mauke> choose a fixed number of "good" colors and crash if you need more
09:33:19 <sutats> Toxaris: If I really wanted to compact the code, is it possible to eliminate config?
09:33:20 <chessguy> hehe
09:33:26 <byorgey> mauke: hehe
09:33:36 <Toxaris> sutats: sure... let me have a try...
09:34:44 <chadz> you could do permutations on rgb values
09:35:03 <chessguy> mauke, well, since the way it's currently being done is to simply pick n random numbers, in the worst case i could choose a fixed number and then resort to choosing random ones again
09:35:11 <Liskni_si> chessguy: then i tried to choose n colors to uniformly cover the hue in HSV, which looked just terrible
09:35:45 <chessguy> oh well, it's hardly worth expending a lot of effort on
09:35:52 <chadz> so you could have a set of rgb triples {  [[2,2,4], [8,4,4] }, and then you could just exhaust the permutations of each
09:36:15 <Liskni_si> chessguy: and the best thing i currently have is choosing random 3 numbers from [220, 120, 80, 0, 0]
09:36:55 <tonfa> is there something like 'zip' with a default argument where the size of the returned list is the maximum instead of the minimum ?
09:37:37 <tonfa> or do I have to write it
09:37:58 <Vq^> what type would it have?
09:38:00 <tuxplorer> @seen Lemmih
09:38:00 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
09:38:24 <dolio> There's nothing in the standard library to that effect.
09:38:29 <tonfa> ok
09:38:29 <chessguy> tonfa, what do you want to return in the case of zip' [1,2] [3,4,5]
09:38:36 <Vq^> tonfa: (a, b) -> [a] -> [b] -> [(a, b)] -- ?
09:38:57 <tonfa> chessguy: it needs one more argument
09:39:03 <chadz> oh
09:39:13 <chadz> it'll zip the default arg with the remainder.
09:39:18 <chessguy> tonfa, ohh
09:39:19 <chadz> no, i don't think that exists.
09:39:22 <tonfa> but something like [(1, 3), (2, 4), (default, 5)]
09:39:29 <tonfa> ok
09:39:34 <tonfa> thanks
09:39:45 <chadz> @src zip
09:39:45 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
09:39:45 <lambdabot> zip _      _      = []
09:39:57 <chadz> there's a starting point :)
09:40:07 <chessguy> so then zip' d list1 list2 = zip (list1 ++ repeat d) list2
09:40:07 <tonfa> yep
09:40:25 <tonfa> chessguy: if list1 is smaller, yes
09:40:27 <chessguy> err, no, it's not that simple
09:40:28 <chessguy> yeah
09:44:04 <Lemmih> tuxplorer: Yo.
09:44:04 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
09:44:39 <hpaste>  chessguy pasted "tonfa, maybe something like this?" at http://hpaste.org/2248
09:44:58 <Lemmih> tuxplorer: Send a patch.
09:45:01 <tuxplorer> Lemmih: Do you remember the issue I had with SDL yesterday? Or shall I paste the link?
09:45:01 <lambdabot> tuxplorer: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:45:22 <nburlett> can anyone recommend a database library for Haskell?
09:45:58 <tuxplorer> Lemmih: a message from MarcWeber to me says that he can reproduce it.. http://rafb.net/p/Q2DY8z18.html
09:45:59 <lambdabot> Title: Nopaste - No description
09:46:06 <chessguy> nburlett, you should be able to find some interesting stuff at http://haskell.org/haskellwiki/Special:Search
09:46:07 <lambdabot> Title: Search results - HaskellWiki
09:46:23 <tonfa> chessguy: almost what I did, I used repeat and the standard zip instead
09:46:33 <Lemmih> tuxplorer: Patches are welcome.
09:46:44 <chessguy> hmm
09:46:50 <chessguy> tonfa, can you paste your code then?
09:47:10 <Liskni_si> chessguy: btw, if you find anything interesting about the color generation, please let me know :)
09:47:26 <monochrom> nburlett: I haven't had experience, but I heard from those who do good words for HDBC.
09:47:28 <nburlett> chessguy: I was hoping someone had tried a couple of them out and could recommend one over the other
09:47:29 <hpaste>  tonfa annotated "tonfa, maybe something like this?" with "zip with default value" at http://hpaste.org/2248#a1
09:47:29 <chessguy> Liskni_si, ok, but i probably won't put a whole lot of effort into it
09:47:42 <nburlett> monochrom: thanks
09:47:50 <tonfa> chessguy: it's been only 2 days since I'm using haskell
09:47:55 <tonfa> so the style is probably not there
09:48:04 <chessguy> tonfa, errmmm, i think you have more than style problems
09:48:13 <chessguy> tonfa, have you tested that?
09:48:22 <tonfa> not yet
09:48:28 <tonfa> I'm not sure about the '@' stuff
09:48:29 <chessguy> i don't htink it will terminate
09:49:02 <chessguy> in fact, i'm almost positive it won't
09:49:03 <Cale> chessguy: why?
09:49:04 <tuxplorer> Lemmih: yup. will send it.. but what patch should I send? I actually took your package straight away and installed it.. Didn't modify any part of the code..
09:49:11 <tonfa> chessguy: it works
09:49:22 <tuxplorer> Lemmih: Sorry if I sound noobish.. But I didn't really get it
09:49:23 <tonfa> except I inverted bl and repeat d
09:49:51 <ddarius> tonfa: I wouldn't bother naming b and bs and a and as in the half empty cases.
09:50:03 <ddarius> i.e. zipx [] bs(_:_) = ...
09:50:09 <tonfa> ok
09:50:10 <ddarius> +@
09:50:11 <Lemmih> tuxplorer: Get the darcs repository, fix the error, send me a darcs patch.
09:50:23 <tonfa> ddarius: makes sense, thanks
09:50:36 <fxr> lambdabot says "eval module failed in contextual handler: IRCRaised Data.ByteString.last: empty ByteString" when I try to eval an expression, any help?
09:50:50 <ddarius> > 3
09:50:55 <lambdabot>  3
09:51:07 <chadz> >
09:51:12 <chadz> >
09:51:14 <chessguy> hmm, apparently i'm missing something then
09:51:15 <Cale> fxr: Could it be that you don't have runplugs installed?
09:51:22 <tuxplorer> Lemmih: okay. will try to.. Incase I have any trouble inbetween and need some help, will ping you.. Thanks :)
09:51:23 <fxr> Cale: lemme check
09:51:48 <chessguy> i'll check it out later
09:51:58 <chessguy_work> @tell chessguy http://haskell.org/haskellwiki/Special:Search
09:51:58 <lambdabot> Consider it noted.
09:52:05 <chessguy_work> whoops
09:52:12 <chessguy_work> @tell chessguy http://hpaste.org/2248#a1
09:52:12 <lambdabot> Consider it noted.
09:53:12 <fxr> Cale: I have got an executable named "runplugs" in lambdabot directory.
09:54:02 <thoughtpolice> fxr: you have to build with hs-plugins support, and when I checked out the repo the lambdabot.cabal.plugins was broken, matter of fact.
09:54:11 <Cale> fxr: Try running it and then typing an expression
09:54:33 <thoughtpolice> i should probably update my lambdabot repo, speaking of that...
09:54:57 <Cale> thoughtpolice: hm? Statically compiled lambdabot supports expression evaluation too, through the use of runplugs.
09:55:06 <fxr> Cale: I'm getting "runplugs: Ix{Int}.index: Index (1024) out of range ((0,27))" when I try to evaluate 3
09:55:16 <fxr> thoughtpolice: yeah I modified cabal file.
09:55:22 <Cale> fxr: hmm
09:55:43 <Lemmih> tuxplorer: The tarballs on hackage seems to be incomplete. Try the darcs version.
09:55:48 <thoughtpolice> Cale: hm. sorear informed me you needed hs-plugins for such support.
09:56:01 <thoughtpolice> i asked the same question.
09:56:09 <tuxplorer> Lemmih: ok
09:56:11 <Cale> thoughtpolice: Well, you need hs-plugins to compile runplugs
09:56:18 <hpaste>  EvilTerran annotated "tonfa, maybe something like this?" with "a related (more general) function i wrote a while ago" at http://hpaste.org/2248#a3
09:56:52 <thoughtpolice> Cale: hm.
09:57:12 <hpaste>  Toxaris annotated "Print value from map through readConfig" with "one-liner for sutats" at http://hpaste.org/2247#a3
09:58:35 <Toxaris> sutats: you have to import Control.Applicative((<$>)) for this to work
09:58:35 <tonfa> EvilTerran: yes
09:58:40 <Cale> Toxaris: writing an ACPI library for Haskell?
09:59:06 <Toxaris> Cale: I'm not, maybe sutats is?
09:59:09 <EvilTerran> ...the original purpose of that function being to write something :: [[a]] -> [a] that could deal with a table that may be infinite in countably infinite time
09:59:11 <Cale> er, maybe that's sutats, yeah :)
09:59:13 <byorgey> EvilTerran: odd to use (%) for the name of the general combination function, % is already taken
09:59:41 <EvilTerran> yes, sorry, i wrote that a while ago before i'd encountered rationals. just after pasting that, i changed it to (?) in my saved copy.
10:00:01 <EvilTerran> (the application of it for that purpose being weave = concat . foldr (zipAllWith (:) return id) [])
10:00:20 <byorgey> huh, you can use (?)  ?
10:00:23 <Cale> It's not that strange -- (*) would be more typical though.
10:00:32 * Toxaris wonders how to avoid either and maybe in his hpaste and instead rely on IO exceptions to be thrown when Nothing or Left arises
10:00:47 <EvilTerran> > let (?) = (,) in 1 ? 2
10:00:48 <lambdabot>  (1,2)
10:00:49 <byorgey> yeah, I guess I'm used to seeing (*) overloaded but not (%)
10:01:41 <EvilTerran> my lecturers tend to use % when reasoning about arbitrary operators in ASCII, regardless of language. i guess i picked it up from them.
10:01:46 <byorgey> > let (*#$&%) = (,) in 1 *#$&% 2
10:01:47 <lambdabot>  (1,2)
10:02:15 <tuxplorer> Lemmih: can you tell me the darcs repository location? I'm unable to find any info on the darcs repo in hsSDL page..
10:02:17 <moonlite__> @src replicateM
10:02:17 <lambdabot> replicateM n x = sequence (replicate n x)
10:02:19 <byorgey> EvilTerran: interesting.  well, nothing wrong with it I suppose, it just looks odd to me =)
10:02:34 <EvilTerran> (outside of ASCII, they tend to use the wholly unassigned (), (), etc
10:02:48 <sutats> Toxaris: Wow! That's hugely condensed.
10:02:58 <tuxplorer> Lemmih: oops.. sorry I was looking in the hackage db.. Its there in your personal site
10:03:08 <byorgey> > let () = (,) in 1  2
10:03:08 <lambdabot>  Illegal character ''\138''
10:03:11 <Toxaris> sutats: but it does exactly the same things in the same order :)
10:03:46 <chadz> i wish hackage had the darcs links.
10:03:58 <Toxaris> sutats: hopefully... it's not tested, only typechecked :)
10:04:08 <sutats> Cale: Nope, just parsing some stuff to use with xmonad and dzen.
10:04:36 <sutats> Toxaris: Haha, I'll test it out to be sure. Thanks.
10:05:14 <fxr> what is the difference between "plugins" and hs-plugins packages?
10:05:24 <EvilTerran> is there a collected description of what -morphisms do what, in terms of haskell?
10:06:34 <Cale> EvilTerran: for which prefixes? :)
10:07:04 <EvilTerran> various... comparing them to each other where appropriate, etc. i just want a rough overview.
10:08:18 <bluestorm> hm
10:08:26 <EvilTerran> byorgey, i think, the last time it came up, we concluded that the only wholly available single-character operators are (?), (#), and (&).
10:08:31 <sutats> Toxaris: Strange, I'm getting different output from the one-liner.
10:08:37 <Cale> There's at least two sets of prefixes which are pretty separate. The first is the ones which are common in mathematics (iso-,epi-,mono-,endo-,auto-), and the second are a bunch of things from recursion theory (cata-,hylo-,zygo-,etc.)
10:08:41 <bluestorm> i have a maybe strange remark
10:08:48 <bluestorm> i'm a planet haskell reader
10:09:13 <bluestorm> and i've noticed that one of the feed isn't really in-topic
10:09:19 <bluestorm> (the one from the "Antonio Cangiano" blog)
10:09:25 <EvilTerran> i was thinking the recursion theory ones, mostly.
10:09:34 <bluestorm> i mean, it's sometimes interesting things, but quite never Haskell ones
10:09:48 <bluestorm> so my question was : why is it in Planet Haskell ?
10:10:37 <dolio> There's more than one that doesn't contain much Haskell stuff.
10:10:37 <Toxaris> sutats: Hmm bad. I may try to debug it, if you hpaste an example of what happens and what should happen
10:10:59 <Cale> bluestorm: Probably because someone added it when he posted his one long post on Haskell and then didn't remove it.
10:11:06 <sjanssen> bluestorm: there was some Haskell stuff on that blog (but nothing lately)
10:11:09 <bluestorm> hm
10:11:21 <bluestorm> it's a shame i didn't see this one ^^
10:12:54 <sutats> Toxaris: Oh, my bad. Apparently the output changed since the last time I executed it (I'm guessing my plugging in the AC changed the file).
10:13:01 <bluestorm> btw, i should say that if this strangeness is noticable, it's because the usual Planet Haskell stuff is great
10:13:05 <dolio> For instance, Shannon -jj Behrens appears to talk way more about Python than Haskell.
10:13:29 <bluestorm> i wouldn't say i'm a haskeller myself, but i really enjoy reading this planet : congratulations !
10:13:46 <sutats> Toxaris: Also, if I wanted to just return () if there's nothing, do I just replace "key not found" with return ()?
10:13:47 <Evir> Hm, one can read all the first chapters of YAHT on one day but one needs multiple days to fully understand chapter 9. %-)
10:13:55 <Evir> But I finally got it, I think.
10:14:34 <Toxaris> sutats: actually, I would recommend not using my fancy one-liner. it's a rather unflexible coding style to write everything in a single line, you know :)
10:14:35 <Cale> Evir: which one is that?
10:14:53 <ddarius> Monad transformers if I remember wli correctly.
10:14:59 <Cale> oh, Monads
10:15:05 <Evir> Cale: Monads and Monade Transformers, Parsing Monads...
10:15:09 <Cale> ah, okay
10:15:14 <Toxaris> sutats: to your question: no that wouldn't work.
10:15:21 <tonfa> is there something that does f ((x1,x2) : xs) = x1 : x2 : (f xs) ?
10:15:25 <Evir> Especially since the examples are wrong.
10:15:39 <Cale> Evir: There are a number of other tutorials which are often recommended to supplement or supplant that chapter.
10:15:49 <bluestorm> hm
10:15:52 <ddarius> tonfa: no
10:15:57 <Botje> @pl \(a,b) -> [a,b]
10:15:58 <lambdabot> uncurry ((. return) . (:))
10:16:10 <sutats> Toxaris: Haha, I guess I'll stick to the more flexible, albeit longer one.
10:16:13 <Evir> The examples in Chapter 9 of YAHT only work if you make (StateT state) an Instance of MonadPlus or you import the according library to make it work.
10:16:14 <tonfa> ddarius: ok
10:16:19 <dolio> Huh...
10:16:21 <Botje> tonfa: concatMap (\(a,b) -> [A,B]) -- this good?
10:16:22 <Evir> None of these possibilities is mentioned there. :->
10:16:25 <ddarius> tonfa: It and it's opposite would be handy for my bit reversal sort utilizing polymorphic recursion.
10:17:01 <Cale> MonadPlus m => MonadPlus (StateT s m)
10:17:10 <Cale> there's an instance in Control.Monad.State
10:17:15 <tonfa> Botje: works
10:17:25 <ddarius> @pl \f ((x1,x2):xs) -> x1 : x2 : f xs
10:17:26 <lambdabot> (`ap` tail) . (. head) . (`ap` snd) . (. fst) . flip ((.) . (.) . (:)) . flip ((.) . (:))
10:17:26 <Evir> Cale: Jep, but you got to know that. :-)
10:17:27 <Cale> (oh perhaps that's what you meant :)
10:17:31 <ddarius> @pl \((x1,x2):xs) -> x1 : x2 : f xs
10:17:32 <lambdabot> ap (uncurry ((. ((. f) . (:))) . (.) . (:)) . head) tail
10:17:59 <Toxaris> sutats: my code has this general structure: putStrLn <<= (some function returning a string) <$> readConfig "...". it is executed as follows: first the readConfig action is executed. it's result is feeded through the big function in the middle, wich produces a string (whatever happens, the functions maybe and either are used to handle failures). then the resulting string is feed to putStrLn. so, whatever happens, the result is a
10:18:00 <Toxaris>  putStrLn-action wich is then executed. so using my code, you cannot avoid printing something
10:18:02 <Cale> Evir: That's the standard place for the state monad transformer to be defined. I suppose it expects that you'll use their implementation.
10:18:06 <Evir> Cale: The chapter reimplements StateT and ListT as examples and for the exercises you either need to know that there'S an instance or you need to write your own one. Nothing of which is written there. :->
10:18:07 <EvilTerran> tonfa, i'd be inclined to write that one as a comprehension
10:18:12 <Cale> But yeah, I can see how that'd be confusing :)
10:18:25 <Cale> Oh, ListT is a terrible example of a monad transformer :)
10:18:31 <dolio> @pl foldr (\(a,b) t -> a:b:t) []
10:18:32 <lambdabot> foldr (uncurry ((. (:)) . (.) . (:))) []
10:18:41 <EvilTerran> tonfa, ie f xs = concat [ [a,b] | (a,b) <- xs ]
10:18:51 <Cale> (in particular because it's not really a monad transformer -- it sometimes produces things which are not monads)
10:19:04 <EvilTerran> or, as dolio suggests, a foldr
10:19:06 <sutats> Toxaris: Okay, that makes sense, so basically all I really want would be to pass it an empty string.
10:19:08 <Evir> Cale: Actually, there is not an example for ListT but the exercise "Implement a ListT" :-)
10:19:33 <dolio> So it does use uncurry.
10:19:34 <tonfa> ok thanks
10:19:40 <dolio> @pl \f (a,b) -> f a b
10:19:41 <lambdabot> (`ap` snd) . (. fst)
10:19:41 <Toxaris> sutats: yes, you could change "key not found" to any other string, of course, including ""
10:20:12 <Cale> Ah, so you might be able to do it right, but the obvious solution is false :)
10:20:31 <Cale> (ListT in the libraries is somewhat broken)
10:20:42 <sutats> Toxaris: Thanks, this makes sense now.
10:21:27 <Cale> Evir: you might also want to read my article: http://www.haskell.org/haskellwiki/Monads_as_computation
10:21:28 <lambdabot> Title: Monads as computation - HaskellWiki
10:21:34 <Cale> which is fairly recent
10:21:47 <Cale> I also wrote Monads as containers, which gives yet another perspective :)
10:21:59 <Evir> I've red the container article before... :->
10:22:06 <Cale> cool :)
10:22:19 * EvilTerran still thinks that, in the absence of monad comprehensions, it'd be nice if [ exp, exp ... | ... ] did what concat [ [exp, exp ...] | ... ] does now.
10:22:27 <Evir> I just wonder why everybody needs to write a monad howto. ;-)
10:22:46 <Cale> I've written a few :)
10:23:01 <Evir> So, statistically, I don't need to write one.
10:23:14 <Cale> I think it's quite an experience to finally get it, that people feel the need to try to record their path to understanding.
10:23:42 <Toxaris> Evir: write some other howto instead
10:23:42 <byorgey> EvilTerran: that would be nice.  It's suggested in SPJ + Wadler's recent paper on comprehensions
10:23:58 <EvilTerran> byorgey, cool!
10:24:10 <EvilTerran> **is chuffed that he has the same ideas as SPJ**
10:24:16 <Cale> I've explained monads enough times to people on IRC that writing another one or two hasn't seemed out of place. I wrote them primarily to document what had worked in explaining monads to beginners.
10:24:42 <byorgey> EvilTerran: http://research.microsoft.com/Users/simonpj/papers/list-comp/index.htm
10:24:44 <lambdabot> Title: Comprehensive Comprehensions, http://tinyurl.com/ysr3n8
10:25:02 <EvilTerran> i guess, given how many ideas SPJ churns out, it's quite likely that there'd be some overlap, but meh.
10:25:18 <byorgey> EvilTerran: that's not really what the paper's about, but they sort of mention it offhandedly towards the end, like "oh, and by the way, this would also be nice independently of everything else we said"
10:25:35 <EvilTerran> hehe.
10:26:47 <dino-> I'm looking at something that says it will require Cabal >= 1.1.7 but my Debian apt installed GHC (6.6.1) only has Cabal 1.1.6.2 ...
10:26:55 <dino-> Is the best way to get newer Cabal basically to get newer GHC?
10:27:05 <Toxaris> what's the point of having SQL-like expressivenes without SQL-like optimization possibilities? for embedding SQL in Haskell, we need Arrow comprehensions :)
10:27:08 <mauke> 6.6.1 is the latest GHC
10:27:15 <dino-> mauke: ok
10:27:53 <dino-> I kind of assumed that what's available through Debian testing is almost by definition not the bleeding edge.
10:29:19 <Evir> Cale: I think I'll have the pleasure to explain Monads to my local friends in some weeks (LISPers amongst them). I've been telling them all about how nice Haskell is, so I expect them to have questions soon. ;-)
10:30:07 <Cale> Evir: Cool.
10:30:39 <Cale> Evir: For lispers, I think the easiest explanation route to explaining monads is that a monad is just a particular style of combinator library.
10:30:55 <Cale> (one which supports a particular means of combination)
10:31:00 <EvilTerran> "this proposal is orthogonal to the rest of the paper" :D
10:31:21 <dolio> I'm having trouble picturing the sort of person who is interested in hearing semi-weekly updates on the price of a book on Amazon.
10:31:33 <dolio> Yet there it is, on reddit.
10:31:41 <Evir> At least some found it very interesting...
10:31:57 <Cale> Yeah, I'm not sure how much I care for the order/group stuff. I'd really like to see monad comprehensions come back, and unless the two ideas can be somehow combined...
10:32:16 <Cale> dolio: hm?
10:32:25 <dolio> Cale: Lisp in Small Pieces.
10:33:10 <Cale> Oh, I see
10:33:15 <dolio> "Hey, it's $4" (I can understand that story; it's a bargain). "Hey, that $4 book is now $100" "The $4 price was a mistake!"
10:34:58 <reltuk> heh...getting Lisp in Small Pieces for 4 dollars is great...
10:35:14 * dolio is also skeptical of order/group by.
10:35:26 <Toxaris> 4$ per Small Piece, or for a whole heap of lisp?
10:35:44 <reltuk> some people on reddit were saying they bought a bunch though...maybe with intentions of selling them....but I'd be suprised if you can actually find a lot of buyers for that book =/
10:36:01 <dolio> Although I think the main thing that bugs me is that it uses alphabetic keywords.
10:36:18 <Toxaris> reading on, I see that ordering is just a synonym for applying any function to the whole list. but why is it called ordering, then?
10:36:43 <Toxaris> are we naming general features after special use cases in Haskell?
10:36:50 <dolio> Which seem out of place, since the rest of comprehension syntax is punctuation, like set comprehension in math.
10:37:28 <balodja> There is a question about Hask category. Given two functions \x->x+1 and \x->x, are they the same morphism?
10:37:36 <dolio> It's also why I dislike Python's list comprehensions.
10:38:55 <dolio> balodja: I believe the answer is 'no.'
10:39:27 <Cale> dolio is right, they are not the same.
10:39:42 <balodja> And do they have the same domains and kodomains?
10:39:56 <Cale> That's a good question, because they're actually polymorphic.
10:40:05 <Cale> They *could* have the same domain and codomain.
10:40:15 <Cale> For example, Integer -> Integer
10:40:22 <balodja> Oh, let's specify them to Integer -> Integer
10:43:36 <SamB> dolio: what about "let"?
10:44:16 <dolio> I don't use let in comprehensions. :)
10:44:42 <dolio> Actually, I don't use comprehensions for much besides simple stuff, really.
10:44:42 <SamB> of course, let is a keyword
10:44:45 <dolio> Or much at all, I suppose.
10:45:01 <balodja> Cale: In that case I don't understand the proposition made in http://en.wikibooks.org/wiki/Haskell/Category_theory
10:45:04 <lambdabot> Title: Haskell/Category theory - Wikibooks, collection of open-content textbooks
10:45:08 <SamB> so I guess it doesn't hurt to use it in the obvious way in list comprehensions...
10:45:19 <balodja> Exactly at words "So which is the morphism f \circ g? The only option is idA"
10:46:26 <balodja> Cale: \x->x+1 -- that's the id_Integer?
10:47:40 * balodja is at loss
10:47:48 <dolio> \x -> x is id
10:47:58 <dolio> \x -> x + 1 is succ or something like that.
10:48:14 <dolio> There can be more than one morphism Integer -> Integer.
10:48:18 <Cale> > (\x -> x + 1) 5
10:48:19 <lambdabot>  6
10:48:22 <Cale> See?
10:48:43 <Cale> It's certainly not the identity function :)
10:49:13 <balodja> That's good. And why (f . g) in the paper is idA?
10:49:14 <Cale> In general, there may be infinitely many morphisms between any pair of objects in a category
10:49:39 <Cale> balodja: where?
10:49:54 <Cale> balodja: It's possible to compose two functions to get the identity function
10:49:57 <Cale> for example
10:50:04 <Cale> (\x -> x + 1) . (\x -> x - 1)
10:50:13 <Cale> > (\x -> x + 1) . (\x -> x - 1) $ 5
10:50:13 <balodja> So which is the morphism f \circ g? The only option is idA.
10:50:14 <lambdabot>  5
10:50:29 <Cale> balodja: It's the composite f following g
10:50:45 <Cale> (I don't know what f and g you're referring to)
10:50:55 <balodja> http://en.wikibooks.org/wiki/Haskell/Category_theory
10:50:56 <lambdabot> Title: Haskell/Category theory - Wikibooks, collection of open-content textbooks
10:51:02 <Cale> I'm looking at that page...
10:51:15 <balodja> "Category laws"
10:51:18 <Cale> ah
10:51:32 <Cale> The diagram they give for that category has only one arrow from A to A
10:51:51 <Cale> That is, just the identity morphism.
10:52:15 <Cale> If there were any others, they f . g could be something else.
10:53:06 <Cale> Perhaps I should clarify the wikibook a little in that regard
10:53:09 <balodja> A-a-a-ah, ok-ok. Now I understand. The composition of (f . g) is the idA, because (A -> A) has the only morphism in category by defenition. Now I understand.
10:53:29 <balodja> Thanks.
10:53:39 <Cale> right
10:53:55 <Cale> oh, it's locked for emergency maintenance
10:54:02 <Cale> I'll edit it later :)
10:55:42 <dino-> < HolographicWikiDoctor> Please state the nature of the wiki emergency.
10:57:06 <eivuokko> dcoutts, I think --prog-arg= must change.  It now uses Prelude.words to parse the string, which breaks in case there's spaces in names.
10:57:28 <eivuokko> dcoutts, I suggest one arg per --prog-arg switch, order preserved.
10:57:46 <dcoutts> eivuokko: hmm
10:58:06 <dcoutts> aye I suppose so
10:58:43 <eivuokko> dcoutts, I am trying to reverse dependencies D.Setup has to D.Setup and D.Compiler
10:58:51 <eivuokko> Err, D.Compiler
10:58:55 <eivuokko> Yawn
10:59:00 <dcoutts> :-)
10:59:01 <eivuokko> Program...
11:00:04 <dcoutts> eivuokko: is that failure case that common though? --ghc-args="--foo=\"bar baz\""
11:00:29 <eivuokko> dcoutts, It will be, in Windows.  And it's fatal.
11:00:41 <dcoutts> ah yes, file paths
11:01:15 <dcoutts> eivuokko: perhaps we can allow the common case with words, eg --prog-args="..." and also allow --prog-arg=
11:02:17 <eivuokko> That should be easy, yeah.
11:02:42 <dcoutts> eivuokko: or we could use lex
11:02:53 <dcoutts> > lex "--foo=\"bar baz\""
11:02:55 <lambdabot>  [("--","foo=\"bar baz\"")]
11:03:04 <eivuokko> dcoutts, There is a slight catch, too, tho.  --prog-args currenly overrides all previous flags.
11:03:27 <eivuokko> dcoutts, Ehm.
11:03:28 <dcoutts> eivuokko: aye, it'd have to append
11:03:39 <eivuokko> Pain.
11:04:24 <eivuokko> dcoutts, lex is a possibility, yeah, a bit wierd, tho.
11:05:44 <sutats> Toxaris: I'm just curious, how would you expand your one-liner to include other lookups, like "remaining capacity" for example?
11:05:50 <EvilTerran> from what i recall, even the most recent CMD.exe (and hence anywhere else where a command, w/ parameters, is expressed as a single string under windows) doesn't really support command-line parameters with spaces in 'em.
11:06:24 <sutats> Toxaris: Or possibly a way to write the value from each lookup into a variable.
11:06:27 <EvilTerran> wait, nvm. ""s work. you just can't have parameters with "s in 'em, iirc.
11:07:41 <Tchakkazulu> Also not with \"?
11:08:08 <Tchakkazulu> Otherwise, I think you could use '\ ' for a non-breaking space.
11:08:32 <Tchakkazulu> Err... makes no sense with \ directory separators :-/
11:11:37 * allbery_b wonders if ^ works in xp
11:12:09 <dcoutts> > let parse [] = [([],"")]; parse s = [ (token:tokens,s'') | (token, s') <- lex s, (tokens, s'') <- parse s' ] in parse "--foo=\"bar baz\""
11:12:18 <lambdabot>  [(["--","foo","=","\"bar baz\""],"")]
11:13:45 <tuxplorer> when I do darcs get darcs.haskell.org:~lemmih/hsSDL/hssdl-mixer/, it asks for some passwd.. what should I enter? isn't there any anonymous access?
11:14:38 <bwwx> tuxplorer: try darcs get http://darcs.haskell.org/~lemmih/hsSDL/hssdl-mixer
11:14:39 <lambdabot> Title: Index of /~lemmih/hsSDL/hssdl-mixer
11:14:48 <dylan> tuxplorer: remove the colon, add http://
11:15:09 <tuxplorer> dylan: bwwx Thanks.. it works
11:15:18 <bwwx> @seen dcoutts
11:15:19 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #gentoo-haskell and #haskell. I last heard dcoutts speak 3m 9s ago.
11:15:32 <dcoutts> hia bwwx
11:15:46 <bwwx> hello dcoutts. I think I found a bug in gtk2hs
11:16:07 <dcoutts> bwwx: ok, what're the details?
11:17:57 <bwwx> the SourceMarker returned from sourceBufferCreateMarker seems to be garbage collected prematurely. the workaround is to keep a reference to all such markers for the lifetime of the program, but this creates a memory leak
11:18:36 <bwwx> if i understand things correctly, then haskell should never call the gtk function to finalize a SourceMarker, since it is owned by the SourceBuffer
11:19:05 <bwwx> i'm not sure if this is a bug specific to SourceBuffer, or if it also affects TextBuffer
11:20:14 <dcoutts> hmm
11:20:29 <tuxplorer> Prelude> :m Graphics.UI.SDL.Mixer
11:20:29 <tuxplorer> module main:Graphics.UI.SDL.Mixer is not loaded
11:20:29 <tuxplorer> Why does the above happen?
11:20:55 <EvilTerran> maybe :m + Graphics...
11:21:13 <dcoutts> tuxplorer: you're probably in a directory where Graphics/UI/SDL/Mixer exists
11:21:48 <tuxplorer> dcoutts: oops ya. Thanks
11:23:36 <tuxplorer> Lemmih: The darcs version works great!! Thanks for your great bindings!! :)
11:25:32 <dcoutts> bwwx: yes, that makes sense
11:25:39 <dcoutts> bwwx: http://gtksourceview.sourceforge.net/docs/GtkSourceBuffer.html#gtk-source-buffer-create-marker
11:25:42 <lambdabot> Title: GtkSourceBuffer, http://tinyurl.com/ywlg2e
11:25:51 <dcoutts> bwwx: it says: Returns : 	 a new GtkSourceMarker, owned by the buffer.
11:26:30 <dcoutts> bwwx: which means we should be refing the returned marker, so I'll switch it to use makeNewGObject rather than constructNewGObject which it uses now
11:26:30 <mrd> associated types really strike me as being ML functor-like
11:26:35 <tuxplorer> how do I get the list of all functions of type foo->bar ?
11:26:43 <mrd> @hoogle foo -> bar
11:26:44 <lambdabot> Did you mean: Foo -> Bar
11:26:44 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
11:26:44 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
11:27:54 <Cale> tuxplorer: Hoogle will do that, but it has some annoying bugs.
11:28:31 <tuxplorer> Cale: I want functions of Type IO Music -> Music.. but such specific libraries aren't indexed by hoogle it seems.. :(
11:28:49 <mauke> unsafePerformIO
11:28:50 <Cale> tuxplorer: IO Music -> Music ?
11:29:03 <Cale> tuxplorer: how is that supposed to work?
11:29:34 <mrd> you do not want a function of IO anything -> anything
11:29:35 <bwwx> dcoutts: ok cool awesome thanks!
11:29:56 * mrd performs Monad Mind Trick
11:29:58 <Cale> tuxplorer: What should that function do?
11:30:09 <tuxplorer> Cale: I tried to use loadMusic method to get a music file and play it using playMusic.. It complains that playMusic expects type Music as input but I'm su[pplying type IO Music
11:30:26 <Cale> right, because loadMusic produces an action
11:30:30 <Cale> You have to run that action
11:30:33 <sorear> tuxplorer: that's what >>= is for
11:30:37 <mauke> you're supposed to use >>=
11:30:43 <Cale> Or do-notation
11:30:55 <SamB_XP> loadMusic "foo.mid" >>= playMusic
11:30:57 <Cale> do m <- loadMusic ...; playMusic m
11:31:13 * SamB_XP is being presumtious of course
11:31:22 <SamB_XP> and spelling badly too
11:31:23 <tuxplorer> Cale: :) Thanks..
11:31:25 <dcoutts> bwwx: can you use the darcs version? I'll push the fix now...
11:32:17 <dolio> midi in this day and age?
11:32:37 <monochrom> what's wrong with midi?
11:32:46 <Cale> tuxplorer: If you're unfamiliar with IO in Haskell, you might want to read the quick note here: http://www.haskell.org/haskellwiki/Introduction_to_IO
11:32:48 <lambdabot> Title: Introduction to IO - HaskellWiki
11:32:52 <Toxaris> sutats: the basic idea would be to use  map Map.lookup ["key", "anotherKey"]  to build a list of lookup functions, and then apply each of this functions to the map using something like map ($). but it's getting too much for one line, so you should go for a second line :)
11:33:02 <dolio> Nothing, but you don't see it very often anymore.
11:33:07 <Cale> dolio: MIDI is still quite common
11:33:21 <monochrom> Only professionals use it.
11:33:47 <Cale> Yeah, it's not a common way to distribute music anymore.
11:34:25 <monochrom> In fact, only professionals use only it.
11:34:27 <Cale> But it's used by instruments to talk to computers and to each other.
11:34:58 <Toxaris> sutats: but Map.lookup works in every Monad you want, so we could use it in the IO monad and use join to collapse the various levels of error-handling
11:35:14 <monochrom> It records how hard you strike the keys. :)
11:35:53 <mrd> Toxaris: i'm not sure i'd want it calling 'fail'
11:35:54 <Cale> Indeed :)
11:35:57 <bwwx> dcoutts: yeah, it will take me a few hours to build and test it though. btw is there a release date for the next version of gtk2hs?
11:36:15 <dcoutts> bwwx: not at the moment
11:36:21 <eivuokko> dcoutts, This stuff requires hooks change -.-
11:36:39 <eivuokko> dcoutts, I guess we are too near ghc 6.8 to get all hooks changes in anymore.
11:37:01 <hpaste>  tuxplorer pasted "playMusic coredumps.. Floating point exception" at http://hpaste.org/2249
11:37:07 <Igloo> eivuokko: Hook changes now are still OK
11:37:30 <dcoutts> eivuokko: what hook changes does it need?
11:37:46 <eivuokko> dcoutts, confHook
11:38:39 <eivuokko> dcoutts, I have now bare minimum information on Setup.ConfigFlags to get information from commandline into order;  This needs to be combined with programs list.
11:39:23 <eivuokko> dcoutts, Before the list of programs went through in that same data structure....I guess I can put it in again, but it really doesn't belong there.
11:39:25 <dcoutts> eivuokko: so it's changing the fields in ConfigFlags? that's fine
11:39:41 <dcoutts> eivuokko: I'm changing the list of programs too
11:39:49 <eivuokko> dcoutts, Hmh
11:40:08 <dcoutts> eivuokko: I'd rather separate the list of programs from the extra args & optional location that's passed in on the command line
11:40:13 <dcoutts> would that suit you?
11:40:26 <eivuokko> ?
11:40:42 <eivuokko> That's what I've been thinking
11:40:47 <dcoutts> ok
11:40:51 <Toxaris> mrd: hmm ok. sutats wants that "nothing" happens in case of error, as he asked about replacing error handling with "return ()", so Maybe seems to be the approbiate error monad to use, not IO. but IO would be easier, since we are in IO anyway :)
11:41:15 <eivuokko> dcoutts, What did you change in program lists?
11:41:42 <dcoutts> eivuokko: adding or modifying fields in the structures that get passed to the conf hook funcitons isn't so disruptive as adding or removing args from the conf hook funcitons
11:42:08 <eivuokko> dcoutts, But confHook needs to combine the info back
11:42:16 <Lemmih> dcoutts: What's keeping gtk2hs from using Cabal? Lack of manpower?
11:42:28 <tuxplorer> Lemmih: I give the second arg as an Int only.. But I get a floating point exception as in http://hpaste.org/2249
11:42:28 <dcoutts> Lemmih: lack of cabal functionality
11:42:30 <eivuokko> dcoutts, Unless you rewrite practically all of Program again
11:42:36 <dcoutts> Lemmih: want to help? :-)
11:43:01 <dcoutts> eivuokko: I'm not done yet, so you can go ahead with your changes, but I'm trying to split the database of programs we know how to configure, from the db of configured program.
11:43:08 <sutats> Toxaris: I get the basic concept, but I'm having trouble converting it to code. Mind clarifying?
11:43:25 <dcoutts> eivuokko: I am basically rewriting all of Program
11:44:02 <eivuokko> dcoutts, Mhm.  Then you can fairly easily do what I was doing anyway ;)
11:44:07 <dcoutts> eivuokko: and I think it's also helpful to keep the user supplied info for configuring programs separate too
11:46:29 <Toxaris> > let handleEither = (const mzero ||| return) in map handleEither [Left "error message", Right 42] :: [Maybe Int] -- sutats first we convert the Either error encoding to a Maybe error encoding (throwing the error message away in the process)
11:46:32 <lambdabot>  [Nothing,Just 42]
11:46:36 <tuxplorer> Even if the user uses a function wrongly, core dumping is bad.. It should probably report error and let continue... :(
11:47:26 <Toxaris> sutats: handleEither <$> readConfig "..."  ::  IO (Maybe Config)
11:47:48 <monochrom> continuing is bad.
11:48:09 <Lemmih> tuxplorer: Works for me.
11:48:19 <Toxaris> sutats: so we can use (.) to add more functions to the left of handleEither wich should handle the "Just" case only (since Nothing case means we already are stuck because of an error)
11:48:48 <Toxaris> sutats: so we need another level of fmap to work for Just only.
11:49:17 <sutats> Toxaris: I'm still reading the first line, and I'm not getting the 42 part.
11:49:19 <tuxplorer> Lemmih: why does it give all the trouble for me only? is there a way to get the core dump and examine to may be get an idea of where it goes wrong?
11:49:27 <fuxxx> any clever way of getting take, drop, replicate etc to work on Integers instead of Ints? like a flag or "pragma" or something..
11:49:52 <Lemmih> tuxplorer: How did you open the audio?
11:50:05 <Toxaris> sutats: yeah it's, hmm, a bit advanced maybe :) I'll give another more basic variant of handleEither:
11:50:08 <bwwx> fuxxx: genericTake
11:50:27 <pr3d4t0r> ricky_clarkson: Ping...
11:50:51 <fuxxx> bwwx, ah, i see. thanks
11:51:01 <tuxplorer> Lemmih: I shot up ghci, and loaded the Graphics.UI.SDL.Mixer.Music module and typed in do m <- loadMUS "siv.ogg"; playMusic m 1
11:51:02 <monochrom> I mean for some non-amateur applications anyway. Bank transaction processing for example. If you detect an overflow for example, better abort and rollback than "continue" and enter knowingly wrong numbers into people's accounts.
11:51:05 <pr3d4t0r> ricky_clarkson: Ping...
11:51:11 <Toxaris> > let handleEither (Left _) = Nothing; handleEither (Right x) = Just x in map handleEither [Left "error message", Right 42] -- this is exactly the same as above, but less general
11:51:13 <lambdabot>  [Nothing,Just 42]
11:51:24 <Toxaris> sutats: you understand this one?
11:51:36 <bwwx> tuxplorer: don't you have to initialise SDL first?
11:51:45 <fuxxx> hmm, why aren't standard take/drop/etc like genericTake/Drop?
11:51:49 <pr3d4t0r> ricky_clarkson: Dude.  You're under a spam attack on my server.  Please look for me in ##java as soon as possible because I need to address that and I don't know what you're running from your account.
11:51:50 <Lemmih> tuxplorer: You should init the audio first.
11:52:05 <sutats> Toxaris: Yeah, this one makes sense. I guess I'm getting lost in the "const mzero ||| return" bit.
11:52:13 <Lemmih> tuxplorer: something like: openAudio defaultFrequency AudioU8 2 (4*1024)
11:52:28 <bwwx> fuxxx: i think because of historical reasons
11:52:29 <tuxplorer> Lemmih: is there a good tutorial on hssdl? so that I would get to know such sequence of things?
11:52:34 <eivuokko> dcoutts, I send *partial* work, maybe you could check quickly how badly it would conflict with your stuff - so that I know if I should continue now or later on.
11:53:01 <dcoutts> eivuokko: ok, but I'm happy to do any merging
11:53:09 <Toxaris> sutats: (|||) is like either, but again, more general. let's have a look at either first:
11:53:09 <Lemmih> tuxplorer: hsSDL is a one-to-one binding. You can use any C tutorial.
11:53:28 <Toxaris> > either (+ 1) (- 1) (Left 0)
11:53:29 <lambdabot>   add an instance declaration for (Num (b -> a))
11:53:39 <Toxaris> @type either
11:53:41 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:53:55 <tuxplorer> Lemmih: Thanks.. :) After initializing it works great.. will go thru some C SDL tut and then get on to hssdl :)
11:54:25 <eivuokko> dcoutts, I don't care about merging, mainly overlapping work and creating unneccesary data types.
11:54:32 <dcoutts> ok
11:54:45 <Toxaris> > either (+ 1) (subtract 1) (Left 0)
11:54:47 <lambdabot>  1
11:54:51 <Toxaris> > either (+ 1) (subtract 1) (Right 0)
11:54:53 <lambdabot>  -1
11:55:14 * Toxaris doesn't like unary minus at all
11:55:54 * DRMacIver still thinks it should be ~
11:56:08 * monochrom thinks negative numbers don't exist.
11:56:31 * monochrom is trolling :)
11:56:33 <Toxaris> sutats: so   either f g (Left x) = f x   and   either f g (Right x) = g x, ok?
11:56:47 <sutats> Toxaris: So far so good.
11:56:56 <Toxaris> sutats: for our purpose, we can assume (|||) == either :)
11:57:09 <sutats> Toxaris: That clears that bit up.
11:57:15 <Toxaris> mzero and return is clear?
11:57:23 <Cale> I think unary minus is just fine as it is :)
11:57:47 <DRMacIver> monochrom: I usually assume you are. ;)
11:57:50 <sutats> Toxaris: return I get, mzero, no.
11:57:58 <mauke> unary minus should be neg
11:58:30 <monochrom> Conventional math notation is very hard to parse.
11:58:36 <Toxaris> sutats: mzero is defined for monads wich are able to express failure, and it means generic failure, just as return means generic success (generic with respect to the actual Monad instance used)
11:59:22 <sutats> Toxaris: I think I get that line then. Basically Left is error all the way down, and Right is if it keeps working.
11:59:33 <sutats> Toxaris: Is that basically it?
12:00:13 <Toxaris> sutats: yes. my handleEither function takes an Either representing Failure by Left and Success by Right into *any* monad representing Failure by mzero and Success by return
12:00:45 <sutats> Toxaris: So far so good then.
12:01:08 <Toxaris> sutats: handleEither <$> readConfig "..."  ::  IO (Maybe Config)
12:01:23 <sutats> Toxaris: Is that a literal "..." or some kind of keyword?
12:01:27 <Toxaris> sutats: the <$> is able to "tunnel" our handleEither function into the IO monad
12:01:40 <Toxaris> sutats: it's a placeholder for the path to the file you are reading
12:01:54 <sutats> Ah, right, it's the argument for readConfig. Read too fast.
12:01:58 <wli> Hmm, integer points on the homogeneous quadric xy = z*(x+y)
12:02:12 <EvilTerran> (<$>) = fmap = liftM -- pretty much
12:02:49 <Toxaris> sutats: but not only the IO monad, of course, but every monad and even some structure wich are not monads, but functors... but how cares... for our purpose, it's enough to know that:
12:02:54 <Cale> = map = (.) -- for some value of '=' :)
12:03:48 <Toxaris> Cale: reminds me of question I failed to answer once in an exam, something like: in wich interpretations of HOL are there interpretations of = so that = = =
12:03:49 <monochrom> You have Unicode and you have many different = symbols at your disposal. :)
12:04:54 <Toxaris> sutats: do you see why we need that <$> operator?
12:05:08 <sutats> Toxaris: Yeah, I get the tunnel.
12:05:38 <sutats> Toxaris: Actually, why not simply $, I guess would be the question.
12:06:12 <Toxaris> sutats: because it's not the same for most Functors
12:06:29 <Toxaris> sutats: are you asking this question, or do you think I should have asked that question?
12:06:35 <sutats> Toxaris: And <$> is a general case?
12:06:42 <sutats> Toxaris: No, I'm asking it.
12:06:59 <Toxaris> sutats: ok, so let's look at <$>
12:07:16 <Toxaris> > (+ 1) <$> Just 3
12:07:17 <lambdabot>  Just 4
12:07:24 <Toxaris> (+ 1) <$> Nothing
12:07:30 <Toxaris> > (+ 1) <$> Nothing
12:07:32 <lambdabot>  Nothing
12:08:21 <Toxaris> sutats: this time we tunnel into the Maybe monad: if it's Nothing, our function has no work to do and we return another Nothing. But if it's Just, we apply our function and wrapping the result back in a Just constructor
12:08:43 <Toxaris> > (+ 1) $ Nothing -- not possible because Maybe is not a numeric type
12:08:44 <lambdabot>   add an instance declaration for (Num (Maybe a))
12:09:02 <Toxaris> sutats: but (+ 1) $ Nothing == Nothing
12:09:08 <Toxaris> sutats: but (+ 1) $ Nothing == Nothing + 1, wich is clearly nonsense
12:09:43 <Toxaris> sutats: so <$> has the special power of "knowing" how to handle the structure of every Functor (wich includes every Monad)
12:10:00 <Toxaris> (this power is not special at all, of course, it's just overloading)
12:10:17 <Toxaris> sutats: ok so far?
12:10:29 <sutats> Toxaris: Yeah, I'm grasping it, though slowly.
12:11:29 <Toxaris> so another example, what do you think should this do:
12:11:34 <Toxaris> (+ 1) <$> [1, 2, 3]
12:12:16 <sutats> [2, 3, 4]?
12:12:33 <Toxaris> > (+ 1) <$> [1, 2, 3] -- yes!
12:12:35 <lambdabot>  [2,3,4]
12:13:13 <sutats> Toxaris: What exactly is a tuple then at its lowest level? Just a primitive?
12:14:05 <Toxaris> sutats: "lowest level"?
12:14:26 <monochrom> a bunch of electrons trapped in a field.
12:14:40 <dino-> I thought that (,) in tuples is a constructor, yes?
12:14:51 <monochrom> future physics findings may find even lower levels :)
12:14:57 <dino-> But the , in [1, 2, 3] is not tuple.
12:14:57 <sutats> Toxaris: Haha, not as low as monochrom is suggesting.
12:15:24 <Toxaris> sutats: are you aware that there are no tuples in the code we are discussing?
12:15:53 <sutats> Toxaris: I meant lists.
12:16:20 <sutats> Toxaris: Basically the [1, 2, 3] bit.
12:16:28 <Toxaris> sutats: well, that's a list :)
12:16:41 <sutats> Toxaris: Haha, yeah, my bad.
12:16:45 <Toxaris> sutats: it's syntactic sugar for 1 : 2 : 3 : []
12:16:59 <Toxaris> do you know algebraic data types?
12:17:21 <sutats> Toxaris: What do you mean exactly?
12:17:28 <Toxaris> sutats: the "data" keyword
12:17:40 <Toxaris> sutats: not the theory about initial algebras
12:17:41 <sutats> Toxaris: Oh, yeah.
12:17:43 <Khoth> Hmm, lambdabot can get confused.
12:17:44 <Khoth> @type (,,,,,,,,)
12:17:46 <lambdabot> forall a b c d e f g h i. -> b -> c -> d -> e -> f -> g -> h -> i -> (a, b, c, d, e, f, g, h, i)
12:17:57 <monochrom> Answerers, try not to information-overwhelm.
12:18:47 <Toxaris> sutats: data [a] = [] | a : [a]  -- list could be defined like this, but it's not allowed syntax-wise
12:19:16 <byorgey> monochrom: but, that's #haskell's favorite vice! =P
12:19:23 <Toxaris> sutats, but this is a valid Haskell data definition wich defines lists without the syntactic sugar:  data List a = Empty | Cons a (List a)
12:20:09 <Toxaris> this datatype is called "cons list" in lisp and "single linked list" in imperative languages
12:21:03 <sutats> Toxaris: Do you mind clarifying the Cons part and how it interacts with List a?
12:21:06 <Toxaris> can I give temporary data definitions to lambdabot? if no, why not, would be cool.
12:21:35 <Toxaris> consider a list of integers first
12:21:46 <phobes> each user should have his own namespace
12:21:50 <Toxaris> data IntList = Empty | NonEmpty Int IntList
12:21:56 <phobes> with the ability to import other user's namespaces
12:22:44 <Toxaris> this means: an IntList is either Empty or it is NonEmpty. If it is NonEmpty, it contains a first element of type Int, and all other elements of type IntList
12:23:38 <Toxaris> so we could encode the empty list as Empty. the list containing only 1 as: NonEmpty 1 Empty
12:23:55 <Toxaris> and the list containing 1, 2 and 3 as: NonEmpty 1 (NonEmpty 2 (NonEmpty 3 Empty))
12:24:09 <sutats> Okay, that makes sense.
12:24:29 <Toxaris> now, we want to have DoubleList, CharList, StringList, CharListList, ... too
12:24:42 <Toxaris> so we abstract away the actual type of the elements to a type parameter:
12:25:04 <Toxaris> data List typeOfTheElements = Empty | NonEmpty typeOfTheElements (List typeOfTheElements)
12:25:24 <sutats> Still good here.
12:25:49 <Toxaris> we call typeOfTheElements a for brevity and NonEmpty Cons for historical reasons
12:25:54 <Toxaris> so we arrive at my earlier definition:
12:26:05 <Toxaris> data List a = Empty | Cons a (List a)
12:26:24 <sutats> Okay, I'm good then.
12:26:45 <Toxaris> (the historical reasons are: Empty and NonEmpty are called "data constructors", because they are able to construct data. the constructor for lists the most important constructor, so it is called CONStructor)
12:27:13 <sutats> Ah, okay.
12:28:09 <Toxaris> Haskell has some syntactical support for lists, like allowing [] instead of Empty, infix : instead of Cons and [1, 2, 3] instead of 1 : 2 : 3 : []
12:28:41 <Toxaris> but that's only syntax, semantically, lists are just data types like all other data types we have encountered so far (like Maybe and Either)
12:29:17 <sutats> Toxaris: Okay, that answers my question.
12:30:05 <Toxaris> shall we go for a nice solution for your problem you can actually understand, instead of a very short solution wich expects you to learn some more fancy stuff like <$>? I'm open for whatever you like...
12:30:32 <puusorsa> how do i tell ghc which one to use if somethign is found in multiple packages?
12:30:58 <Toxaris> puusorsa: in ghci or in a code file?
12:31:01 <sutats> Toxaris: If time permits, both. I find that learning why/how to use the fancy stuff is good too.
12:31:40 <Toxaris> sutats: for me, it's ok
12:32:13 <puusorsa> Could not find module `System.Locale': it was found in multiple packages: old-locale-1.0 base
12:32:19 <puusorsa> trying to compile hope
12:32:44 <puusorsa> or more precisely, all it's dependencies atm
12:33:04 <newsham> tox: infix colon constructors is not only a list exception though.
12:33:07 <Toxaris> puusorsa: oh searching "modules" in multiple "packages". I have no idea, then.
12:33:11 <newsham> its just a capital punctuation mark
12:33:35 <Toxaris> newsham: yes I know :)
12:34:17 <newsham> so wouldnt it be more correct to say that [1,2,3,4] is the only syntactic sugar for lists (and perhaps list comprehensions... and string constants...)
12:34:59 <Toxaris> newsham: if you count [] as a special case of [1, 2, 3, 4].
12:35:02 <newsham> (perhaps i'm picking at nits)
12:35:12 * allbery_b thinks "Explaining Monads" has jumped the shark
12:35:13 <desegnis> puusorsa, try -hide-package old-locale-1.0
12:35:20 <newsham> toxaris: I guess [] isn't a proper constructor for Nil.  *nod*
12:35:37 <Toxaris> sutats: ok where are we?
12:35:38 <desegnis> puusorsa, given that you invoke ghc yourself
12:35:51 <sjanssen> allbery_b: I stopped reading that thread days ago
12:36:14 <Toxaris> sutats: handleEither <$> readConfig "..."  ::  IO (Maybe Config)
12:36:49 <puusorsa> desegnis, i don
12:36:59 <puusorsa> t. using setup.lhs build
12:37:07 <Toxaris> to clarify again on the <$>: how would we write this without <$>? we would write something like  do config <- readConfig "..."; return (handleEither config)
12:37:39 <Toxaris> or, wich is equivalent: readConfig "..." >>= return . handleEither
12:38:02 <Toxaris> sutats: ok?
12:38:06 <dino-> puusorsa: There should be a <thisproject>.cabal file in the top-level dir near that Setup.lhs. Args for the compiler can go in there.
12:38:11 <desegnis> puusorsa, then try ghc-pkg hide old-locale
12:38:20 <sutats> Toxaris: So why did you choose <$> over bind?
12:38:24 <puusorsa> i did that, didnt help
12:38:30 <puusorsa> ghc-pkg hide that is
12:38:36 <mauke> saves a (return .)
12:38:41 <puusorsa> now trying to edit .cabal file and see if it does anything
12:39:04 <sutats> mauke: Ah, yes, I see that now.
12:39:16 <dino-> puusorsa: The property in the cabal file should be: ghc-options
12:39:35 <Toxaris> sutats: yeah, it's all about one-liners, here :)
12:39:58 <puusorsa> yeah it already had nhc98-options: i figured what i need is ghc-options
12:40:00 <puusorsa> thanks
12:40:01 <desegnis> puusorsa, strange. maybe in the cabal file of the package you're compiling there is an explicit dependency on old-locale or something?
12:40:05 <Toxaris> sutats: but <$> is "better" then >>= in my eyes because it is more general!
12:40:08 <ivant> good time of day, fellow haskellers!
12:40:16 <Toxaris> sutats: that is, it works for more types. but that doesn't matter here :)
12:40:20 <puusorsa> editing the .cabal worked
12:40:30 <sutats> Toxaris: Ah, okay.
12:40:47 <conal> Toxaris, sutats: same reason to prefer liftA2 over liftM2, etc.
12:40:48 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:41:16 <Toxaris> conal: yes! and declaring instance Functor for every Monad :)
12:42:11 <Toxaris> sutats: now we want to tunnel not only the handleEither function "into" the IO monad, but a bigger function wich does additional processing
12:42:13 <conal> Toxaris: right.  and Applicative as well.
12:42:32 <kolmodin> how do I get ghci not to echo every result ?
12:42:40 <sutats> Toxaris: And we do that by .?
12:42:51 <Toxaris> sutats: exactly!
12:43:14 <sutats> Toxaris: I think I'm getting the hang of this.
12:44:10 <Toxaris> so we want to do something like   (newStuff . handleEither) <$> readConfig "..."
12:44:31 <chadz> kolmodin: use let syntax?
12:44:43 <sutats> Toxaris: Okay, but what exactly does the newStuff have to nclude?
12:44:44 <kolmodin> chadz: IO monad...
12:44:49 <sutats> *include
12:45:05 <Toxaris> sutats: first question to ask when programming Haskell is: what type should it have.
12:45:21 <mauke> kolmodin: foo >> return ()
12:45:23 <Toxaris> sutats: clearly, it should be a functional type when it is used with the (.)-operator
12:45:32 <Toxaris> sutats: so we know newStuff :: a -> b
12:45:38 <chadz> kolmodin: why can't you use let within do syntax?
12:45:40 * monochrom practises Type-Oriented Programming
12:45:51 <sutats> Toxaris: Good so far.
12:45:51 <Toxaris> sutats: we know a already from the context. what is it?
12:45:57 <kolmodin> mauke: but I want the result. I just don't want to print it
12:46:17 <sutats> Maybe?
12:46:22 <mauke> kolmodin: x <- foo
12:46:38 <chadz> oh, i see what he wanted.. :)
12:46:41 <kolmodin> mauke: yes.... and that prints nearly 4mb of text :D
12:46:48 <chadz> then use let
12:46:54 <mauke> oh, I see
12:47:03 <kolmodin> chadz: I can't use let for the IO monad
12:47:04 <chadz> let x = putStrLn "hello world"
12:47:06 <mauke> that sucks
12:47:18 <monochrom> Some user or luser asked for "x <- foo" to print x, and thus it was added to ghci.
12:47:20 <chadz> > let x = putStrLn "hello world" in x
12:47:20 <kolmodin> chadz: that won't run the IO monad :)
12:47:25 <lambdabot>  <IO ()>
12:47:37 <chadz> heh
12:47:39 <chadz> not with in :)
12:47:39 <Toxaris> sutats: yes, a is something involving Maybe
12:47:58 <Botje> kolmodin: x <- foo; return ()?
12:48:14 <Botje> bah.
12:48:18 <sutats> Toxaris: I guess, according to your definition, it's Maybe Int.
12:48:24 <Botje> nevermind :)
12:48:24 <chadz> > do { let x = putStrLn "hi"; x }
12:48:25 <lambdabot>  Parse error
12:48:29 <kolmodin> Botje: nope
12:48:40 <mauke> kolmodin: x <- liftM const $ foo
12:48:56 <monochrom> lambdabot does not mimic ghci in this respect.
12:49:01 <Toxaris> sutats: hmm. you mean the definition involving 42?
12:49:13 <sutats> Toxaris: Yeah, according to that one.
12:49:27 * Toxaris answers the phone... 
12:49:35 <chadz> kolmodin: you can store IO results with let in ghci
12:49:51 <doserj> kolmodin: :set -fno-print-bind-result?
12:50:22 <kolmodin> doserj: thanks! that's it
12:50:31 <monochrom> I am sorry I didn't think of that.
12:50:51 <sutats> Toxaris: I actually have to get going right now. I'll be back in a few hours. I hope you don't mind if we continue then.
12:50:52 <chadz> ah, i see :)
12:51:06 * Toxaris will be away for half an hour or so, sorry sutats
12:51:08 <kolmodin> chadz: you're saving the IO operation, not the result
12:51:10 <Toxaris> hehe ok
12:51:21 <sutats> Toxaris: Haha, it all works out then. Thanks for all the help.
12:51:50 <chadz> kolmodin: yes, but doesn't that in turn accomplish what you need?
12:52:19 <kolmodin> chadz: no, I don't want to save an IO operation, I want the result of it
12:52:28 <kolmodin> -fno-print-bind-result did the trick
12:52:44 <chadz> kolmodin: if you're not displaying it, you might as well save the operation, right?
12:52:57 <mauke> no
12:53:08 <kolmodin> chadz: no, I need the result as a variable
12:53:32 <chadz> i'm just not understanding the purpose of your goal :)
12:55:47 <chadz> ...when you could just use sequence, fmap, liftM, etc.
12:56:04 <chadz> i suppose it's nice for ghci hackery
12:59:35 <monochrom> x <- System.Random.getStdGen
13:00:12 <monochrom> take 23 $ System.Random.randomRs (0,1) x
13:00:23 <monochrom> That is an example use case.
13:16:38 <mauke> @pl \f x y -> unzip $ zipWith f x y
13:16:38 <lambdabot> ((unzip .) .) . zipWith
13:17:31 <shapr> yargh
13:20:05 <mauke> hmm, foo x (tail x) is a very useful pattern
13:32:23 <Tchakkazulu> I see "zipWith f x (tail x)" every so often.
13:33:23 <Tchakkazulu> There doesn't happen to be a function of type "(a -> [b]) -> [a -> b]"?
13:33:39 <bluestorm> osfameron:
13:34:01 <Botje> why would it return a list of functions?
13:34:15 <bluestorm> osfameron: i was reading http://osfameron.vox.com/library/post/least-common-multiples---the-scenic-route.html
13:34:18 <lambdabot> http://tinyurl.com/yo4hz6
13:34:28 <Botje> and which b of the [b] would it return?
13:34:41 <bluestorm> actually, what you say to be a "sieve" isn't one, or at least it isn't the original Eratosthene Sieve, as it is quadratic
13:35:03 <nautican> anyone know whether there's a convenient way to get at an iotcl in haskell?
13:35:07 <bluestorm> you may be interested in that paper, that shows a real sieve implementation : http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
13:35:09 <Heffalump> @pl (\f -> repeat (head . f))
13:35:09 <lambdabot> repeat . (head .)
13:35:15 <Heffalump> @type repeat . (head .)
13:35:17 <lambdabot> forall a a1. (a1 -> [a]) -> [a1 -> a]
13:35:48 <Tchakkazulu> Hmm, okay :)
13:36:04 <Heffalump> not much use though
13:37:50 <Tchakkazulu> Heh, no, not really :P
13:40:34 <Toxaris> @type \g -> map (\n x -> g x !! n) [0..] -- Tchakkazulu, what about this one?
13:40:37 <lambdabot> forall t a. (t -> [a]) -> [t -> a]
13:41:17 <lament> @hoogle (a->[b]) -> [a->b]
13:41:17 <lambdabot> No matches, try a more general search
13:41:22 <lament> :)
13:41:25 <Heffalump> I thought of that, but it's an infinite list even if g always returns a finite list
13:41:41 <Heffalump> which is pretty ugly
13:41:47 <Tchakkazulu> Can't we solve that with some sort of zipWith hack?
13:42:08 <Tchakkazulu> zipWith const (that_thing x) x
13:42:57 <mauke> Program terminated with signal 4, Illegal instruction.
13:42:57 <mauke> #0  0x0807be62 in awaitEvent (wait=8) at posix/Select.c:176
13:42:57 <mauke> 176	      while ((numFound = select(maxfd+1, &rfd, &wfd, NULL, &tv)) < 0) {
13:43:06 <Toxaris> Heffalump: but how could it be otherwise?
13:43:11 <Heffalump> Toxaris: well, yeah
13:43:16 <mauke> yes, that's a Haskell program
13:43:31 <Heffalump> Tchakkazulu: only by picking a special element to detect the list length from
13:43:37 <Toxaris> Heffalump: at least it could be usefull for functions wich always return infinite lists
13:43:46 <Heffalump> Toxaris: true
13:44:06 <Heffalump> Tchakkazulu: because you can never know if the list returned by g for element n will have an element n of its own or not without trying it
13:44:16 <Heffalump> so you can never know where to stop the list
13:44:40 <Tchakkazulu> Hmm, true.
13:47:16 <Tchakkazulu> I was playing around with (solve x = map ($ solve x) x).
13:47:37 <Cale> > ap (zipWith (-)) tail [1,2,3,4,5]
13:47:38 <lambdabot>  [-1,-1,-1,-1]
13:48:38 <Tchakkazulu> > let solve x = map ($ solve x) x in [const 1, \l -> l !!0, \l -> (l !! 3) + 4, \l -> (l !! 1) * 4]
13:48:41 <lambdabot>  [<[Integer] -> Integer>,<[Integer] -> Integer>,<[Integer] -> Integer>,<[Inte...
13:48:51 <Tchakkazulu> Oh, wait.
13:48:56 <Tchakkazulu> > let solve x = map ($ solve x) x in solve [const 1, \l -> l !!0, \l -> (l !! 3) + 4, \l -> (l !! 1) * 4]
13:48:57 <lambdabot>  [1,1,8,4]
13:49:35 <Tchakkazulu> But I got lazy, and wanted to write solve' (\l -> [1, l!!0, (l!!3)+4, (l!!1)*4])
13:49:36 <chadz> monochrom: that example still can be done monadically :)
13:50:23 <Toxaris> @type \g -> map (\n x -> cycle (g x) !! n) [0..]
13:50:25 <lambdabot> forall t a. (t -> [a]) -> [t -> a]
13:51:02 <Cale> :t let solve x = map ($ solve x) x in solve
13:51:03 <lambdabot> forall b. [[b] -> b] -> [b]
13:51:15 <Cale> It's loeb
13:51:23 <Cale> > loeb :: Functor a => a (a x -> x) -> a x
13:51:23 <Cale> > loeb x = fmap (\a -> a (loeb x)) x
13:51:23 <lambdabot>  Parse error
13:51:23 <lambdabot>   Not in scope: `loeb'
13:51:37 <Tchakkazulu> Err... yes.
13:51:39 <Tchakkazulu> For lists.
13:53:55 <cjeris> Cale: that goes with leopold :: Functor a => a x -> a (a x -> x) ?
13:54:14 <byorgey> loeb? Is that named after someone?
13:54:16 * dcoutts reads eivuokko's cabal patches
13:55:17 <conal> does anyone use ghc.haddock?
13:55:27 <Tchakkazulu> http://en.wikipedia.org/wiki/Lisa_Loeb <- probably not her, though.
13:55:28 <lambdabot> Title: Lisa Loeb - Wikipedia, the free encyclopedia
13:56:06 <Cale> http://en.wikipedia.org/wiki/Martin_L%C3%B6b
13:56:08 <lambdabot> Title: Martin Lb - Wikipedia, the free encyclopedia
13:56:28 <Cale> http://en.wikipedia.org/wiki/L%C3%B6b%27s_theorem
13:56:29 <lambdabot> Title: Lb's theorem - Wikipedia, the free encyclopedia
13:56:55 <Tchakkazulu> Yes, that's it :)
13:57:29 <Cale> (consider the similarity of the first formula under the "Lb's theorem in provability logic" to the type of the function we're looking at :)
13:57:48 <byorgey> Cale: yes, I was just doing that
13:58:06 <Tchakkazulu> The cycle solution works brilliantly, though again it produces an infinite list.
13:58:13 <mauke> http://sigfpe.blogspot.com/2006/11/from-l-theorem-to-spreadsheet.html
13:58:15 <lambdabot> Title: A Neighborhood of Infinity: From L&ouml;b's Theorem to Spreadsheet Evaluation, http://tinyurl.com/22eoxu
13:58:35 <byorgey> Cale: hmm, how does "is provable" correspond to "arbitrary functor"?
14:00:45 * byorgey should just go through and read every single one of sigfpe's blog posts
14:01:08 <Tchakkazulu> I'm not sure how it corresponds to "arbitrary functor", but I can see how it corresponds to "a functor".
14:01:33 <Tchakkazulu> If a is provable (Provable a), and a implies b (a -> b), then b is provable (Provable b)
14:01:34 <Cale> Hmm... it is a little bit fun to use both Curry-Howard and the categorical stuff at the same time :) You might consider a functor F such that a value of type F A constitutes a proof of A.
14:01:36 <Tchakkazulu> And hey, there's fmap.
14:02:00 <Tchakkazulu> Well... flip fmap the way I worded it, but still.
14:02:06 <byorgey> Tchakkazulu: aha, right
14:02:19 <Tchakkazulu> (a -> b) -> Provable a -> Provable b
14:02:24 <byorgey> Cale: ok...
14:02:47 <byorgey> oh, I think I see
14:02:53 <Cale> Yeah, just like Tchakkazulu is doing :)
14:03:22 <byorgey> since the only restriction on functors is that fmap be defined, and the type of fmap corresponds to something which is valid for "Provable"...
14:03:31 <byorgey> right?
14:03:57 <Tchakkazulu> The theorem has a proof, and fmap is the C-H equivalent of the proof.
14:04:23 <byorgey> Tchakkazulu: right.  OK, cool. =)
14:04:55 <Tchakkazulu> I never really got how functors and such things fit in C-H, though.
14:05:00 <MarcWeber> Can someone tell me more about ObjectIO (GUI lib) ?
14:05:00 <lambdabot> MarcWeber: You have 1 new message. '/msg lambdabot @messages' to read it.
14:05:11 <Tchakkazulu> But perhaps you could see "f a" as a "statement saying something about a"
14:05:27 <Tchakkazulu> Where "f" corresponds to the actual statement being made.
14:05:50 <byorgey> Tchakkazulu: yes, that would make sense.
14:06:15 <Tchakkazulu> But it's tricky, because NotProvable doesn't work in that way.
14:06:35 <Tchakkazulu> If a -> b, and we have NotProvable a, then we can't derive NotProvable b.
14:06:53 <byorgey> Tchakkazulu: right, so NotProvable does not correspond to Functor.
14:06:53 <Toxaris> so NotProvable is not a functor?
14:07:10 <conal> how about a cofunctor
14:07:20 <Tchakkazulu> More like something contravariant.
14:07:28 <conal> exactly
14:07:33 <Toxaris> what is a cofunctor?
14:07:37 <Tchakkazulu> "Not a" can be seen as "a -> _|_"
14:07:44 <conal> cofmap :: (b -> a) -> f a -> f b
14:07:51 <Tchakkazulu> Yep, that works :)
14:08:01 <conal> sure does
14:08:05 <byorgey> aha! =)
14:08:32 <Toxaris> so if I "follow" the cofunctor, the arrows flip around?
14:09:04 <Tchakkazulu> Ooh, another cofunctor: (-> b)
14:09:09 <byorgey> Toxaris: right (I think)
14:09:39 <conal> Tchakkazulu: right. but haskell won't match that cofunctor
14:09:54 <conal> because of first-order pattern matching
14:10:06 <Tchakkazulu> I want type-lambdas :(
14:10:44 <lament> Tchakkazulu: will you have to type-check them? :)
14:10:49 <Tchakkazulu> That way you could write x :: (-> b) as x :: (\a -> (a -> b))
14:10:49 <tom_> hi all
14:11:11 <byorgey> hi tom_
14:11:11 <tom_> anyone know where the sleep function is? I want to pause for a second in the IO monad
14:11:12 <conal> Tchakkazulu: me, too!  meanwhile, see http://haskell.org/haskellwiki/TypeCompose for some cofunctor stuff, and a Flip to handle (-> b).
14:11:14 <lambdabot> Title: TypeCompose - HaskellWiki
14:11:24 <mrd> tom_: threadDelay
14:11:27 <mrd> in microseconds
14:11:35 <mrd> @hoogle threadDelay
14:11:37 <tom_> Excelent, knew it was there somwhere
14:11:39 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
14:11:40 <tom_> thanks
14:11:41 <Tchakkazulu> And instance (Functor f1, Functor f2) => Functor (\a -> f1 (f2 a)) where fmap = fmap . fmap
14:11:47 <sorear> Type SK-calculus is a pathetic excuse for type lambdas
14:11:54 <lament> @hoogle Float -> IO ()
14:11:55 <lambdabot> No matches, try a more general search
14:12:12 <conal> yep.  also handled in TypeCompose, via O
14:12:55 <moonlite__> what does "x :: (-> b)" mean? Is it legal Haskell?
14:13:05 <Tchakkazulu> Yes, I could write newtype Compose f1 f2 a = f1 (f2 a), and write an instance (Cxt) => Compose f1 f2
14:13:14 <Tchakkazulu> But it doesn't feel right to have to wrap and unwrap stuff.
14:13:15 <sorear> nothing, because higher kinds are uninhabited in all type systems I know of
14:13:32 <Tchakkazulu> No, not legal haskell.
14:13:52 <tom_> I don't suppose anyone here has got any experience with serial port IO? I'm having problems and of course all the examples are in C...
14:13:56 <moonlite__> ok :)
14:14:04 <Lemmih> dcoutts: Cabal lacks shipments?
14:14:05 <byorgey> moonlite__: (-> b) is not a type.  You need to apply it to another type to produce a type, like (-> b) a === (a -> b)
14:14:22 <byorgey> moonlite__: (actually I'm not even sure if that is legal Haskell either, but you get the idea hopefully)
14:14:37 <conal> Tchakkazulu: yes, it's a pain to wrap & unwrap.  i'm doing tons of it, and so made a new version of TypeCompose that greatly simplifies.  but it's haddock-unfriendly, so i'm trying to figure out how to use the new ghc-friendly haddock.
14:14:41 <byorgey> moonlite__: just like Maybe is not a type, but Maybe Int is.
14:14:41 <moonlite__> byorgey: yep get it. thx :)
14:15:13 <Toxaris> @type let x :: (-> Int) Int; x = x in x
14:15:15 <lambdabot> parse error on input `Int'
14:15:18 <conal> @kind Maybe
14:15:20 <lambdabot> * -> *
14:15:44 <Toxaris> @type let x :: (->) Int Int; x = x in x
14:15:46 <lambdabot> (->) Int Int; x = x in x :: Int -> Int
14:15:55 <Tchakkazulu> class Conjugate a b where {wrap :: a -> b; unwrap :: b -> a; conjugate :: (a -> a) -> b -> b; conjugate f = wrap . f . unwrap}
14:16:21 <Toxaris> lambdabots pretty printer is broken?
14:17:17 <byorgey> Toxaris: ?
14:17:28 <Toxaris> @type let x :: (->) Int Int; x = x in x -- byorgey
14:17:30 <lambdabot> (->) Int Int; x = x in x :: Int -> Int
14:17:49 <byorgey> it reprints the expression and then tells you the type :: Int -> Int
14:17:49 <Toxaris> byorgey: where's the "let x :: "?
14:18:08 <byorgey> oh, I see, that's odd
14:18:14 <byorgey> I didn't notice that before =)
14:18:18 <mauke> Toxaris: it drops until "::"
14:18:35 <mauke> @type "foo"
14:18:37 <lambdabot> [Char]
14:18:41 <Toxaris> haha :)
14:18:46 <byorgey> hm, it should drop until the last "::"...
14:18:57 <mauke> @type "foo::bar"
14:18:59 <Toxaris> byorgey: consider types wich include kind annotations
14:18:59 <lambdabot> [Char]
14:19:02 <mauke> hmm
14:19:07 <byorgey> Toxaris: ah, good point
14:19:42 <byorgey> @type fmap
14:19:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:20:16 <Tchakkazulu> conal: That TypeCompose stuff looks like the newtype and type wrappers I've been writing.
14:20:41 <Toxaris> Tchakkazulu: You could have invented TypeCompose!
14:21:12 <conal> Much of TypeCompose is taken from the Applicative Functor paper.
14:21:12 <Tchakkazulu> To be completely fair, it started with a "type Flip a b c = a c b" that I once saw in here.
14:22:07 <Tchakkazulu> Hmm.
14:22:09 <Toxaris> byorgey: it should do The Right Thing (tm), that is: not prettyprinting the expression in the first place. wich may or may not be possible with current ghc api or whatever lambdabot uses
14:22:32 <Tchakkazulu> I was wondering about Applicative Functors and their relation with Category Theory.
14:22:45 <Toxaris> producing too much information and using some RegExp to select the interesting part is not really the Haskell way, is it?
14:23:01 <Tchakkazulu> Functors and monads are Haskell equivalents of category theory functors and monads.
14:23:10 <conal> Tchakkazulu: i just added something like your Conjugate class, though directed at type constructors.  once i find a haddock solution, i'll re-release.
14:23:36 <Botje> O_O
14:23:41 <Botje> that's a cool hostname.
14:23:43 <Tchakkazulu> But now we have Functor > Applicative > Monad. Where's the category theory equivalent of those?
14:24:04 <Tchakkazulu> Err... of Applicative, I mean.
14:27:03 <vincent_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
14:27:05 <lambdabot> http://tinyurl.com/yyo64c
14:27:10 <vincent_> "Technically, a strong lax monoidal functor"
14:27:19 <vincent_> for what that's worth ;-)
14:30:16 <Tchakkazulu> A strong lax monoidal functor... Wow :P
14:32:38 <monochrom> Every word there has a rigorous definition. It is much more well-defined than "non-strict pure functional strong static typed programming language"
14:33:09 <monochrom> And above all, certainly much more well-defined than "it is about computations"
14:34:55 <Tchakkazulu> "sequencing side-effects"!
14:35:25 <vincent_> the abstract of the paper mentions: "We close by identifying the categorical structure of applicative functors [...]"
14:35:40 <vincent_> so if you're really interested, the info is certainly there:
14:35:45 <Toxaris> I think that most people would understand Monads without much problems, if they would understand (1) type constructors, (2) type (constructor) classes and (3) higher order functions first
14:35:46 <vincent_> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
14:35:48 <lambdabot> Title: Applicative Programming with Effects
14:36:15 <monochrom> Yes Toxaris. Those should be taught in every highschool.
14:36:26 <Toxaris> :)
14:36:32 <Tchakkazulu> I won't claim to understand what monads are.
14:36:34 <monochrom> (OK! I'm half serious and half trolling.)
14:36:47 <Toxaris> :)( or :() ?
14:36:56 <Tchakkazulu> I just understand the "hey! There's some serious often-occuring plumbing here, let's abstract!"-pattern :P
14:37:03 <conal> Applicative is simpler than Monad.  Start people there.
14:37:07 <monochrom> No one can even claim to understand what numbers are.
14:37:14 <vincent_> ;-)
14:37:28 <conal> and usually for me, Applicative is enough.
14:37:36 <Toxaris> monochrom: they should be thaught before monads in these monad tutorials
14:37:54 <Tchakkazulu> That gets you into philosophical questions of when something "is".
14:37:57 <monochrom> Yes. This is very good advice.
14:38:00 <conal> Applicative also allows static analysis/optimization that Monad precludes.
14:38:30 <Tchakkazulu> Anyway, /me goes to read the Applicative paper.
14:38:51 <Tchakkazulu> I wrote the wikibooks chapter by what I got from the library, let's see if it makes sense :P
14:39:06 <Tchakkazulu> "the library" being Control.Applicative, not some building with books.
14:41:33 <Toxaris> what is an example of an applicative functor wich is neither monad nor arrow?
14:42:30 <conal> Toxaris: Applicative & Arrow have different kinds
14:44:24 <Toxaris> what is an example of an applicative functor wich is neither monad nor partially applied WrappedArrow?
14:45:05 <dolio> You might be able to make an arrow out of all applicative functors...
14:45:18 <Heffalump> I thought applicative was a half-way house between Arrow and Monad
14:45:39 <Tchakkazulu> ZipList
14:45:40 <dolio> With a ~> b --> f (a -> b)
14:46:04 <dolio> ~> being the arrow type constructor.
14:46:09 <Tchakkazulu> Well, ZipList is not a monad, dunno about arrows.
14:47:38 <conal> another Applicative & non-monad example: GUI a, meaning guis that present changing values of type a.
14:48:38 <Toxaris> dolio: so Applicative and Arrow would be a different "interfaces" to the same abstraction?
14:49:55 <ski> Tchakkazulu : i'm not sure if ZipList is a monad .. probably 'Stream' is one though
14:50:23 <conal> Applicative & Arrow handle input very differently
14:51:02 <conal> for an example of Monad vs Arrow vs Applicative, see http://haskell.org/haskellwiki/Phooey
14:51:03 <lambdabot> Title: Phooey - HaskellWiki
14:53:18 <newsham> anyone know a good alternative to manually doing CPS in javascript?  are there any good alternatives that compile down to reasonably sized javascript?
14:53:30 <newsham> that let you hide things like timeouts and callbacks
14:53:56 <bwwx> I hear that YHC compiles haskell to javascript
14:55:09 <newsham> any idea how closely it maps to javascript?
14:55:19 <bwwx> what do you mean?
14:55:21 <newsham> i need something that generates code thats not too big
14:56:32 <littledan> newsham, there's a language called Factor (which has some similarities to Haskell) that has a compiler to CPS for a significant subset. As far as I know, the code generated isn't too big
14:56:32 <dons> ?users
14:56:32 <lambdabot> Maximum users seen in #haskell: 385, currently: 367 (95.3%), active: 17 (4.6%)
14:56:42 <hpaste>  dolio pasted "Applicative Arrow" at http://hpaste.org/2250
14:58:02 <conal> dolio: you can generalize from -> to another arrow.
14:59:47 <Toxaris> that means that Applicative f, Arrow a => f (a b c) is an Arrow?
14:59:47 <hpaste>  conal pasted "another applicative arrow" at http://hpaste.org/2251
15:00:25 <dolio> Ah, interesting.
15:00:41 <newsham> ldan: thanks.  I'll check it out
15:00:55 <conal> dolio: it's in the applicative paper.
15:01:15 <conal> i think
15:01:16 <dolio> Oh. I guess I should go read it again. :)
15:01:34 <newsham> (I remember seeing a microsoft research talk of some system they had that compiled something w/ better threading/timeouts down to javascript.. but I dont remember its name)
15:01:35 <conal> me, too.  more to mine there.
15:02:05 <dolio> Anyhow, the point is, you won't find an applicative functor that doesn't have a corresponding arrow, just like you won't find such a monad.
15:02:33 <newsham> anyone have experience with yhc->js?
15:03:01 <conal> dolio: yep.
15:03:10 <newsham> I just had to manually write about 2 pages of code in CPS btw.. :\
15:03:42 <conal> dolio: on the other hand, applicative is a sweet spot for me.  more general than Monad.  simpler than Monad and Arrow.
15:03:45 <littledan> newsham, you have my sympathy
15:03:52 <bwwx> newsham: what kind of javascript project are you working on?
15:04:13 <newsham> just some small tests (I do security testing for $$)
15:04:39 <newsham> ie. a portscanner in javascript using some custom APIs exposed by some product
15:05:02 <Toxaris> dolio, conal: so applicative functors are kind of an alternative for arrows? equally expressive in general, but more or less suited to the task at hand?
15:05:18 <ddarius> Toxaris: No.
15:05:31 * Toxaris doesn't understand anything :(
15:05:37 <dolio> conal: Yeah, they seem like they have potential.
15:06:12 <dolio> Maybe we'll get some nice GUI abstractions that actually take off (the arrows ones never seem to). :) You're working on that, right?
15:06:18 <ski> i believe arrows to be able to express more kinds of effects than applicatives
15:06:43 <ski> but, when they apply, i think applicatives can be quite nice
15:06:47 <bwwx> have they figured out how to add IO to arrow based guis?
15:07:08 <Toxaris> ddarius: why not? because I was plain wrong, or because talking about "expressivenes in general" is the wrong aproach to comparing them?
15:07:10 <ski> bwwx : are you thinking of Fudgets ?
15:07:18 <bwwx> i'm thinking of the fruit paper
15:07:28 <bwwx> there didn't seem to be any way to execute arbitrary IO actions
15:07:30 <conal> dolio: yep, that's what i'm working on.  i was going with arrows and then switched to applicative.
15:08:28 <ddarius> Toxaris: Arrow doesn't imply Applicative.
15:09:36 <popcount> Are there valid uses for IdentityT?
15:09:42 <conal> ddarius: different kinds.  if you partially apply the arrow, you get an applicative.  see p 10 in the applicative paper
15:09:59 <littledan> is the main applicative paper, "Applicative Programming with Effects"?
15:10:14 <Toxaris> ddarius: so what is the meaning of   instance Arrow a => Applicative (WrappedArrow a b) where ... ?
15:10:17 <pr3d4t0r> ricky_clarkson: Thanks brother.
15:10:27 <littledan> or am I looking at the wrong thing
15:10:28 <conal> littledan: yes, afaik
15:13:50 <ddarius> To show that Arrow and Applicative you need to show that every operation on one can be simulated with the operations on the other.
15:15:03 <gigamonkey> What book(s) do folks here recommend for learning Haskell, for someone who's already a competent programmer in other languages and has a rough idea of the ideas of functional programming?
15:15:27 <Excedrin> YAHT
15:15:50 <dons> ?where yaht
15:15:50 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
15:16:04 <dons> is the common recommendation for good programmers
15:16:08 <dons> ?where yaht-web
15:16:08 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
15:16:30 <ddarius> What's the common recommendation for bad programmers?
15:16:32 <popcount> gigamonkey, what's wrong with Common Lisp? ;)
15:16:53 <dons> ddarius: hmm, 'The Craft of FP' ? (i.e. start again :)
15:17:05 <Excedrin> Haskell for C Programmers
15:17:06 <jfredett> @src partition
15:17:06 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
15:17:06 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
15:17:06 <lambdabot>                               | otherwise = (ts, x:fs)
15:17:09 <gigamonkey> ddarius: I already know it. ;-)
15:17:10 <dons> popcount: not a functional language
15:17:20 <Excedrin> http://www.haskell.org/~pairwise/intro/intro.html
15:17:21 <lambdabot> Title: Haskell for C Programmers
15:17:37 <ddarius> gigamonkey: I think you meant to direct that to popcount (?)
15:17:41 <gigamonkey> Er, sorry, yeah.
15:17:42 <Excedrin> gigamonkey: maybe you can write a Haskell for CL Programmers
15:17:49 <littledan> dons, Haskell isn't a functional language; it has unsafePerformIO
15:18:02 <littledan> or, I retract that; no need for flaming
15:18:14 <lament> haskell for bash programmers
15:18:19 <jfredett> heh,
15:18:26 <popcount> Haskell for Trolls
15:18:31 <dolio> Are you using the qwe1234 definition of 'functional language'? :)
15:18:32 <lament> :D
15:18:33 <jfredett> Haskell for qwe1234
15:18:33 <dons> it doesn't have unsafePerformIO except for doing calls to C :)
15:18:35 <popcount> That would be a nice book :)
15:18:42 <ddarius> Haskell for Intercal Programmers
15:18:54 <monochrom> C is a functional language.
15:18:55 <lament> it's all dirty lies! haskell doesn't actually have unsafePerformIO :)
15:18:59 <jfredett> PLEASE GOTO Yaht
15:19:02 <thoughtpolice> haskell for APL programmers
15:19:08 <ddarius> lament: Sure it does.
15:19:09 <lament> jfredett: it's COME FROM
15:19:11 <bwwx> unsafePerformIO doesn't break referential transparency, since if it does then your program is no longer a valid haskell program
15:19:12 <jfredett> yah
15:19:14 <jfredett> I know
15:19:17 <popcount> C# is a functional programming language! Haskell isn't. C# functions in lots of business environments and Haskell is only used by academics!
15:19:19 <Excedrin> APL for VCR Programmers
15:19:22 <dons> > unsafePerformIO (readFile "/etc/passwd")
15:19:23 <lambdabot>   Not in scope: `unsafePerformIO'
15:19:30 <popcount> [/qwe1234]
15:19:37 <jfredett> APL for VCR programmers named Haskell
15:19:41 <lament> ddarius: see!
15:19:43 <littledan> haskell for APL programmers would actually be coherent, since APL is somewhat functional
15:19:45 <ddarius> @where ffi -- lament
15:19:46 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
15:19:53 <gigamonkey> Does anyone know, off the top of their head, whether I could get lulu to print YAHT--i.e. is it allowed by the GFDL?
15:19:53 <jfredett> APL is silly, I love it
15:19:53 <jfredett> :)
15:19:54 <popcount> Haskell for Human Beings!
15:20:13 <lament> ddarius: that's just a communist extension
15:20:16 <Excedrin> Haskell for Dummies
15:20:22 <thoughtpolice> what exactly is a practical use of something like unsafePerformIO? I've never really seen examples of any of the unsafe* functions
15:20:33 <lament> thoughtpolice: interfacing with other languages.
15:20:40 <littledan> popcount, qwe1234 is funny
15:20:52 <Toxaris> thoughtpolice: debugging
15:20:54 <popcount> thoughtpolice, something lacking design can use it.
15:21:01 <thoughtpolice> anybody got an article/example?
15:21:13 <gigamonkey> Are their language (or library) features supported by GHC that aren't part of the Haskell 98 report?
15:21:18 <ddarius> Haskell for Anna and Samuel Curry
15:21:31 <monochrom> System.Random.randomIO uses unsafePerformIO
15:21:37 <thoughtpolice> gigamonkey: yes, see the user manual on "extensions"
15:21:38 <littledan> thoughtpolice, I've heard claims that it ends up being common in large programs for error messages, but I"m not sure if that's true.
15:21:42 <bluestorm> thoughtpolice:
15:21:47 <popcount> gigamonkey, Template Haskell, I think
15:21:59 <popcount> gigamonkey, see the user guide
15:22:01 <thoughtpolice> bluestorm:
15:22:09 <phobes> I get the feeling that Haskell 98 is tiny compared to GHC
15:22:09 <popcount> gigamonkey, the extensions are documented
15:22:11 <Toxaris> thoughtpolice: unsafeInterleaveIO is used for lazy IO (like readFile) afaik
15:22:16 <bluestorm> when using extracting coq proof to haskell, you may get terms that are well typed in coq indexed types, but not typeable in haskell
15:22:18 <lament> gigamonkey: it seems a lot of very commonly used features are not in haskell 98.
15:22:19 <dons> littledan: unsafePerformIO isn't common at all -- its really for wrapping known-safe foreign library calls
15:22:25 <popcount> phobes, it is.
15:22:31 <littledan> dons, oh, thanks
15:22:32 <bluestorm> then, an unsafe function like unsafePerformIO is useful to shot down the haskell type system ^^
15:22:37 <popcount> phobes, and even H98 is a rather large language
15:22:42 <dons> or yeah, for extracting from theorem provers, which have type system proofs not available to ghc
15:22:43 <monochrom> haha bluestorm
15:22:45 <newsham> dons: doesnt FFI already have a way to specify pure foreign functions?
15:22:59 <littledan> how does unsafePerformIO break the type system?
15:23:02 <bluestorm> hm
15:23:09 <dons> you can, but there are still cases where you wrap an impure-but-local effect
15:23:17 <bluestorm> you can code a cast : a -> b with unsafePerformIO
15:23:24 <littledan> really?
15:23:30 <bluestorm> was in a Peyton-Jones paper about the History of Haskell
15:23:44 <popcount> dons, but according to the documentation you cannot expect anything of unsafePerformIO.
15:24:01 <popcount> dons, the effects might run once, they might run a million times...
15:24:03 <littledan> bluestorm: do you remember the title?
15:24:13 <bluestorm> http://research.microsoft.com/~simonpj/papers/history-of-haskell/history.pdf
15:24:16 <lambdabot> http://tinyurl.com/yotlvc
15:24:18 <bluestorm> the page number is 27
15:24:23 <newsham> pop: insiders might know a thing or two about what they want out of unsafe
15:24:24 <Excedrin> why is creating a comonad "unsafe" ?
15:24:27 <lament> if unsafePerformIO is just IO a -> a, it shouldn't break types...
15:24:44 <sjanssen> lament: you can get a polymorphic reference type out of it
15:25:02 <sjanssen> @type unsafePerformIO . newIORef
15:25:04 <lambdabot> Not in scope: `unsafePerformIO'
15:25:04 <lambdabot>  
15:25:04 <lambdabot> <interactive>:1:18: Not in scope: `newIORef'
15:25:11 <jfredett> only in haskell can Performing IO operations create such awesome sounding problems
15:25:11 <thoughtpolice> i think bluestorm means you can more arbitrarily go from any type a to any type b
15:25:17 <jfredett> like polymorphic reference types
15:25:20 <bluestorm> hm
15:25:31 <phobes> just put the value in a cell and then take it out
15:25:47 <bluestorm> what the haskell pastebin url ?
15:25:51 <jfredett> !paste
15:25:51 <hpaste> Haskell paste bin: http://hpaste.org/
15:25:57 <bluestorm> thanks
15:26:00 <jfredett> yep
15:26:02 <kpreid> @type Foreign.unsafePerformIO . IO.newIORef
15:26:04 <lambdabot> Not in scope: `IO.newIORef'
15:26:08 <ddarius> let unsafeCoerce a = unsafePerformI (writeIORef ref a >> readIORef ref) where ref = unsafePerformIO (newIORef a)
15:26:12 <kpreid> @type Foreign.unsafePerformIO . Data.IORef.newIORef
15:26:14 <lambdabot> forall a. a -> GHC.IOBase.IORef a
15:26:14 <ddarius> let unsafeCoerce a = unsafePerformI (writeIORef ref a >> readIORef ref) where ref = unsafePerformIO (newIORef undefined)
15:26:34 <hpaste>  SPJ pasted "unsafePerformIO breaks types" at http://hpaste.org/2252
15:26:39 <newsham> werent some of the early Java type vulnerabilities that lead to violations of the security monitor also based on very subtle type bugs?
15:26:50 <bluestorm> (not sure about indentation, copy/pasted from the paper)
15:27:03 <lament> in Java, you cast everything to Object all over the place
15:27:06 <newsham> I dont think "only in haskell..."  seems like type systems are fairly fragile to any impurities
15:27:09 <lament> so you can't talk about any kind of type safety
15:27:29 <bluestorm> hm
15:27:29 <newsham> lament: but that doesnt let you violate the type system.  castes are checked at runtime and an exception thrown on violation
15:27:45 <sjanssen> lament: Java checks those casts though, this unsafePerformIO hack is not checked at all
15:27:54 <bluestorm> newsham: i don't think this is seen as a "bug", but as a feature
15:28:00 <bluestorm> hm
15:28:13 <newsham> Java relies on the type enforcement to enforce security policy and without it applets can run arbitrary code in your browser.
15:28:23 <littledan> aren't ML type systems generally safe?
15:28:45 <sjanssen> littledan: our type system is safe, unsafePerformIO isn't
15:28:49 <newsham> if casting from Object was all that was needed to run code in your browser, I'd already be on your machine
15:29:06 <bluestorm> Ocaml provides an   a -> b function
15:29:12 <littledan> sjanssen: I'm aware. I'm sorry if I'm coming off trollish; it's not my intention
15:29:18 <ddarius> @index unsafeCoerce
15:29:18 <lambdabot> bzzt
15:29:19 <lament> newsham: i sure hope not, i'm not running any java :)
15:29:19 <bluestorm> (that is used in exactly the same situation for coq extraction)
15:29:21 <bwwx> can't you cause much more damage with unsafe array writes?
15:29:24 <ddarius> @hoogle unsafeCoerce
15:29:25 <lambdabot> No matches found
15:29:26 <bluestorm> hm
15:29:28 <newsham> lament: you win.
15:29:33 <lament> yay
15:29:41 <sjanssen> bwwx: you can probably cause about the same amount of trouble
15:30:00 <newsham> /dcc send lament prize.exe
15:30:09 <littledan> but ML has side effects, and newsham said "type systems are fairly fragile to any impurities", which I thought meant side effects
15:30:24 <ddarius> bwwx: You can't cause more trouble than you can with unsafeCoerce.
15:30:25 <bwwx> so what's the big deal then? haskell also has pointers even
15:30:26 <monochrom> Haskell for Sendmail programmers.
15:30:47 <sjanssen> littledan: I've read that ML has the "value restriction" to prevent polymorphic references in the style of the unsafePerformIO+IORef hack
15:30:51 <ddarius> littledan: And the ML type system accounts for them with the value restriction.
15:30:55 <lament> Haskell for Haskell programmers.
15:31:03 <lament> that would be a good book.
15:31:09 <popcount> Haskell for Oleg's
15:31:21 <littledan> what's the value restriction? That references have to be monomorphic?
15:31:33 <dolio> It's worse than that. :)
15:31:34 <dcoutts> Lemmih: right, cabal has no shipments and the design of anything like shipments needs to be very careful
15:31:44 <newsham> lament: isnt that what dons is writing?
15:32:05 <monochrom> Yes!
15:32:14 <dcoutts> Lemmih: what would you want for managing a collection of related packages?
15:39:42 <chessguy> hi
15:39:42 <lambdabot> chessguy: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:41:41 <chessguy> @type trace
15:41:42 <dcoutts> @seen eivuokko
15:41:43 <lambdabot> Not in scope: `trace'
15:41:43 <lambdabot> eivuokko is in #darcs, #ghc and #haskell. I last heard eivuokko speak 3h 47m 17s ago.
15:41:48 <Lemmih> xerox: ping.
15:41:52 <chessguy> @type debug.Trace
15:41:54 <lambdabot> Not in scope: `debug'
15:41:54 <lambdabot>  
15:41:54 <lambdabot> <interactive>:1:6: Not in scope: data constructor `Trace'
15:42:07 <chessguy> @type Debug.trace
15:42:09 <lambdabot> Couldn't find qualified module.
15:42:12 <dcoutts> Lemmih: any reason in particular you're wondering about shipments?
15:42:39 <chessguy> @type Debug.Trace.trace
15:42:41 <lambdabot> forall a. String -> a -> a
15:43:09 <Lemmih> dcoutts: I seem to recall that the lack of shipments were what kept gtk2hs away from Cabal.
15:43:25 <dcoutts> Lemmih: no, we don't need shipments for gtk2hs
15:43:44 <dcoutts> thing with shipments is nobody really knows what they are :-)
15:44:22 <popcount> Are there valid uses for IdentityT?
15:45:07 <ski> littledan : 'value restriction' is that only syntactic values (variable and lambda basically) can be given polymorphic types
15:45:08 <dcoutts> popcount: are there any valid uses for id :: a -> a  ? I expect IdentityT is for the equivalent cases
15:45:42 <littledan> ski, what's a non-syntactic value, then?
15:45:51 <ski> e.g. an application
15:46:04 <oerjan> popcount: if you have some code parametrized over a monad, you might want to use the trivial one occasionally
15:46:34 <popcount> oerjan, yes, I believe I found a valid use for that.
15:46:57 <popcount> oerjan, I was just wondering whether that situation could also be resolved in some other way.
15:47:40 <oerjan> oh wait
15:47:59 <oerjan> is IdentityT the trivial monad _transformer_ ?
15:48:16 <popcount> oerjan, yes
15:48:40 <oerjan> i thought you said Identity
15:48:46 <Cale> popcount: IdentityT is for when you have a monad transformer transformer and you want to get an ordinary monad transformer from it :)
15:49:35 <popcount> Cale, what is a monad transformer transformer?
15:49:56 <Cale> Presumably something which turns monad transformers into other monad transformers.
15:50:09 <Cale> (just as monad transformers turn monads into other monads)
15:50:10 <popcount> Cale, I used it to make sure the base monad needed an instance (t (ST s)) instead of (ST s)
15:50:43 <Cale> ah, yeah, that would be a saner application :)
15:50:58 <xerox> Lemmih: pong
15:51:23 <popcount> Cale, I was rather surprised by this application.
15:53:17 <Lemmih> xerox: When running Chart (it draws a graph using Cairo), Xorg takes 100% CPU while Chart stays at ~10%. Do you have any idea why? Are drawing areas not double buffered or something?
15:53:52 <Toxaris> would it be possible to express the feature of instantiating Functor as a monad transformer transformer? then this FunctorTT could be applied to a IdentityT to yield a FunctorT wich in turn would leave monads unchanaged, but instantiate an approbiate Functor instance
15:54:00 <popcount> It draws one pixel at a time?
15:54:20 <dcoutts> Lemmih: X is doing a lot of work, that'd be no better if it was using client side drawing
15:54:20 <ski> littledan : e.g. 'val empty_vector = Vector.tabulate (0,fn _ => raise Fail "not reached")' in SML won't get a polymorphic typing
15:54:34 <chessguy> @src zip
15:54:35 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
15:54:35 <lambdabot> zip _      _      = []
15:55:06 <Lemmih> dcoutts: But resizing other applications doesn't perform as badly.
15:55:31 <chessguy> @src repeat
15:55:31 <lambdabot> repeat x = xs where xs = x : xs
15:55:41 <phobes> Anyone know the rules in python for when you're allowed to "monkeypatch" an object?
15:55:58 <dcoutts> Lemmih: it's re-drawing every time the window resizes, if it's doing too much work then resizing is going to be slow
15:56:11 <phobes> When can you take an object obj with no field F and add x.F = 10, e.g.
15:56:42 <dcoutts> Lemmih: if the drawing is too slow to be usable interactively then you might want to use a caching scheme
15:57:10 <Lemmih> dcoutts: I tried to disable a large part of the drawing which cut the CPU usage in half (the usage of Chart, Xorg still used 100%). However, the framerate stayed exactly the same.
15:57:14 <dcoutts> Lemmih: but by default, cairo is an immediate mode drawing api, if you want to cache stuff you have to do that explicitly.
15:57:42 <lament> phobes: try #python
15:58:10 <dcoutts> Lemmih: for example, in the cairo clock demo in gtk2hs, the high quality drawing is too slow to redraw interactively
15:58:43 <lament> phobes: but in general, setting attributes is done through __setattr__, which can do anything
15:58:47 <dcoutts> Lemmih: so when resizing we switch to a lower quality drawing and then when it stops resizing we redraw in high quality
15:59:26 <dcoutts> Lemmih: and we cache the static parts of the scene in image surfaces
15:59:35 <chessguy> is that implementation of repeat supposed to be faster than repeat x = x : repeat x, or just cuter?
15:59:35 <lament> phobes: eg class Foo:\n  def __setattr__(self, a, v): print "Booyah"
15:59:42 <chessguy> @pl r x = x : r x
15:59:42 <lambdabot> r = fix (ap (:))
15:59:59 <monochrom> "x.F" with vector x and field F sounds like vector calculus to me :)
16:00:00 <dcoutts> Lemmih: and composite them to the window in the expose events. Take a look at that demo.
16:00:07 <mauke> chessguy: uses less memory
16:00:13 <chessguy> mauke, why?
16:00:20 <chessguy> @type ap
16:00:21 <Lemmih> dcoutts: There are no images. It's just lines.
16:00:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:00:29 <mauke> because it makes a circular list
16:00:34 <Lemmih> dcoutts: Just lines, not even any text.
16:00:41 <dcoutts> Lemmih: doesn't matter, whatever you're drawing it's apparently expensive.
16:00:43 <chessguy> > ap (:) 3
16:00:44 <lambdabot>   add an instance declaration for (Num (a -> [a]))
16:00:44 <mauke> not an ever expanding sequence of calls to repeat
16:01:04 <chessguy> > (ap (:)) 3
16:01:06 <lambdabot>   add an instance declaration for (Num (a -> [a]))
16:01:21 <Toxaris> chessguy: fix adds an argument!
16:01:39 <conal> mauke: isn't it a circular function, rather than one that makes a circular list?
16:01:48 <dcoutts> Lemmih: it's possible it's a performance bug in either cairo or X but it's always possible to make the drawing too slow to be used interactively by doing lots of expensive drawing operations.
16:01:56 <mauke> conal: what's a circular function?
16:02:31 <conal> mauke: i just meant the function is def'd self-referentially.
16:03:16 <dcoutts> Lemmih: so if the image is static and expensive to draw then it does make sense to cache it in an intermediate surface
16:03:25 <Toxaris> > ap (:) repeat 3
16:03:27 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
16:03:48 <Toxaris> > ap (:) (ap (:) repeat 3) 3
16:03:48 <lambdabot>  Couldn't match expected type `(->) a' against inferred type `[]'
16:04:11 <mauke> conal: no, repeat doesn't mention itself in its body
16:04:38 <byorgey> @type ap
16:04:38 <Tchakkazulu> Wow, that Applicative paper tells what (>>=) does without naming "sequencing side-effects"
16:04:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:05:02 <conal> mauke: i thought you meant @pl r x = x : r x
16:05:24 <Tchakkazulu> "It allows the value returned by one computation to influence the choice of another"
16:05:25 <Toxaris> Tchakkazulu: as expected, since >>= is not about sequencing side-effects... ;)
16:05:41 <puusorsa> http://www-swiss.ai.mit.edu/~boogles/Art/coleman4.jpg
16:05:46 <Tchakkazulu> There's still a "computation" there, though :(
16:06:17 <Lemmih> dcoutts: Is there an OpenGL backend?
16:06:25 <lament> puusorsa: looks like somebody took too much inspiration from frida kahlo
16:06:55 <conal> Tchakkazulu: btw, that influence is what Arrow & Applicative lack, which is why Arrow & Applicative can do static analysis and Monad cannot.
16:07:01 <dcoutts> Lemmih: not a very usable one yet. The plan of the X hackers is to make the X server use OpenGL to accelerate the XRender X11 calls that cairo uses.
16:07:27 <puusorsa> ...or charles manson
16:08:25 <Toxaris> Tchakkazulu: what's wrong with "computation"?
16:08:26 <Liskni_si> @src ap
16:08:26 <ddarius> Tchakkazulu: The paper that introduced monads for use in denotational semantics was called "Notions of Computation".
16:08:26 <lambdabot> ap = liftM2 id
16:08:39 <puusorsa> or amputation
16:08:56 <Tchakkazulu> I have nothing against the use of "computation", but it seems like another source of confusion on the lists.
16:09:36 <joelr1> good afternoon
16:09:41 <joelr1> any acm members?
16:09:54 <shapr> hiya joelr1
16:10:24 <conal> hi joelr1
16:10:30 <joelr1> shapr: yo! are you a member of the acm?
16:10:36 <joelr1> conal: howdy!
16:10:44 <joelr1> i'm looking for this paper: http://portal.acm.org/citation.cfm?doid=1238844.1238850
16:10:46 <lambdabot> Title: A history of Erlang
16:11:07 <joelr1> obligatory haskell content: i want to try re-implementing the erlang virtual machine
16:11:48 <Tchakkazulu> "whereas <*> keeps the structure of a computation fixed, just sequencing the effects" D'OH!
16:14:13 <conal> Tchakkazulu: that's why Applicative works for functional GUIs and Monad not as well.
16:14:32 <Tchakkazulu> Yes, I saw that Phooey page.
16:14:42 <Tchakkazulu> It has changed a lot since I looked at it about half a year ago.
16:14:55 <joelr1> ok, request for paper withdrawn /i already got it, thank you!/
16:16:19 <conal> Tchakkazulu: it'll change more.  i'm going to drop the Arrow & Monad interfaces, which have serious drawbacks, and just keep Applicative.
16:18:38 <Tchakkazulu> conal: I kinda liked the Arrow idea from Fudgets. What is their greatest drawback?
16:20:34 <Tchakkazulu> conal: Oh, wait, I think I'm getting there now :) "6) Applicative functors and Arrows"
16:22:11 <conal> Tchakkazulu: my main complaint with Arrow is that most of my GUI functions had source or dest type being (), ie either a pure consumer or a producer.
16:23:26 <byorgey> QuickCheck must be broken, it keeps finding counterexamples to my properties! grr... =P
16:24:41 <Tchakkazulu> conal: Hmm, not much use for >>> then.
16:25:07 <Tchakkazulu> conal: Also, I just read that if you fix the source, you get an Applicable; so that's the basis of your new interface?
16:27:27 <conal> Tchakkazulu: no.  the arrow version was more complicated and probably violated arrow laws.  i built the applicative version separately.  in fact, as a simple composition.  see http://haskell.org/haskellwiki/Applicative_data-driven_programming.
16:27:28 <lambdabot> Title: Applicative data-driven programming - HaskellWiki, http://tinyurl.com/2oujrg
16:28:01 <conal> it's the composition of an applicative & a monad.
16:28:25 <Tchakkazulu> toReadQueue.size++
16:29:19 <conal> oops: really the composition of a few monads.  (note that monads don't compose to make monads)
16:29:25 <ski> conal,Tchakkazulu : 'contravariant functor', not 'cofunctor' (also 'functor' is sometimes for emphasis named 'covariant functor')
16:29:30 <ski> Excedrin : "why is creating a comonad \"unsafe\" ?" ?
16:30:37 <conal> ski: 'cofunctor' /= 'contravariant functor'??
16:31:12 <shapr> Ya know, the Project Euler pages on the wiki should include solutions that don't work, and why they don't work.
16:31:21 <ski> (puusorsa : nice picture)
16:32:04 <ski> conal : i think, if 'cofunctor' means anything, it means something like 'morphism in Cat^op'
16:33:03 <ski> generally, 'co-X' in a category 'C' means 'X' in the category 'C^op'
16:34:26 <byorgey> @karma toReadQueue.size
16:34:27 <lambdabot> toReadQueue.size has a karma of 1
16:36:00 <Tchakkazulu> >_<
16:36:03 <ski> conal : drop Arrow & Monad interfaces for Pan ?
16:36:43 <conal> ski: no -- for phooey
16:37:04 <ski> @where phooey
16:37:04 <lambdabot> http://conal.net/phooey/
16:37:10 <ski> ty
16:37:31 <conal> ski: pan had a monad interface for GUIs, but only AF operations were really useable.
16:37:48 <ski> 'AF' ?
16:37:57 <ski> ah
16:38:05 <jfredett> applicative functor?
16:38:45 <conal> any other opinions on the name "cofunctor" and alternatives (for contravariant functor).  "cofunctor" does have some history in haskell.
16:39:00 <ski> shapr : where ?
16:39:28 <chessguy> interesting. going back and re-watching the SICP videos after playing with haskell for a year makes a big difference
16:39:38 <oerjan> right, all the top hits for "cofunctor" are haskell related
16:40:19 <ddarius> chessguy: I've been wanting to rewatch those.  Now that I have bandwidth and, with some effort, disk space, I should download them.
16:40:33 <conal> oerjan: although a lot of those are mine, so don't give them too much credit.
16:40:35 <chessguy> ddarius, they're definitely worthwhile
16:40:44 <ski> i used 'CoFunctor' first, until i noticed CT texts being careful not to use that term .. however, i don't know of a short nice term for 'contravariant functor'
16:41:03 <ddarius> There isn't one.
16:41:32 <oerjan> when adding -haskell i see some hits that seem to be category theory
16:41:34 <ddarius> Usually CT people just use F : C^op -> Set when they want it and thus avoid needing a compact term.
16:41:53 <ski> *nod*
16:42:05 <chessguy> ski, what is your specialty, anyway? every time i hear you talk, i can pretty much guarantee that it's going to be some abstract gobbledygook, and i'm not going to have a clue what you're talking about
16:42:09 <matthew-_> there's no easy way to call C++ from Haskell is there? I have to wrap the C++ in C don't I?
16:42:21 <popcount> conal, why do you want a short name?
16:42:27 <mauke> matthew-_: yeah, pretty much
16:42:34 <ski> chessguy : me, i'm just a C.S. undergrad
16:42:37 <mauke> matthew-_: or you could call the mangled names directly :-)
16:42:46 <chessguy> ski, where?
16:43:03 <ski> Gothenburg University / Chalmers
16:43:04 <matthew-_> mauke: are there any tutorials you know of to walk through wrapping C++ in C? I have sod all experience of doing such things...
16:43:26 * chessguy takes a mental note for his kids somedauy
16:43:31 <mauke> matthew-_: basically, you write a bunch of functions declared as extern "C"
16:43:59 <ddarius> chessguy: I don't know, but I suspect that that's much more a function of the person rather than the place.
16:44:04 <mauke> they behave like C functions as far as the linker is concerned
16:44:10 <chessguy> :)
16:44:17 <bwwx> matthew-_:  things get really fun when you have to deal with templates, smart pointers and exceptions
16:44:40 <chessguy> ddarius, but is it a covariant or contravariant function?
16:44:44 <matthew-_> bwwx: yeah, I think I'm going to have other fun with threads
16:44:44 * mrd shudders: C++ ABI
16:45:07 <matthew-_> basically, I want to call FTGL which looks like a decent C++ library for font rendering in OpenGL
16:45:26 <matthew-_> and I have a large haskell application doing lots of OpenGL stuff
16:45:30 <mrd> freetype?
16:45:35 <conal> popcount: short name for the type class name.  i guess we could use "class ContravariantFunctor f where ...".  or maybe "ContraFunctor"
16:45:42 <matthew-_> mrd: FTGL uses freetype
16:45:47 <mrd> hm
16:45:53 <bwwx> mrd: are there haskell freetype bindings?
16:45:55 <ski> (conal : yes, i've used the latter :)
16:45:57 <Smokey`_> matthew-_: extern "C" { /* C code here that calls your C++ functions */ }, use FFI to call your C wrapper around C++
16:46:16 <matthew-_> bwwx: there are not, sadly.
16:46:45 <ddarius> I started making a binding to Kyra a long long time ago and used an unholy amalgamation of SWIG and hackery.
16:46:47 <mrd> doesn't SDL also have font rendering stuff?
16:46:51 <popcount> conal, just pick ContravariantFunctor. If someone is annoyed by it, he/she can simply rename the class.
16:46:56 <matthew-_> mrd: not using SDL
16:47:06 <matthew-_> Smokey'_, mauke, mrd etc, thanks for your help. I'll give it a whirl tomorrow
16:47:06 <reffie> am i the only one for whom at least 95% of the time spent "programming" is actually for debugging the code that was written in the other 5%?
16:47:08 <bwwx> mrd: no, but there are addons for SDL
16:47:08 <Baughn> mrd: No, but a library going by the name of SDL_ttf does
16:47:14 <mrd> right, that
16:47:21 <mrd> i've used that in other languages
16:47:28 <Baughn> reffie: Yeah. It's really 98%.
16:47:33 <Smokey`_> matthew-_: the important part being the extern "C", which stops the linker from mangling the symbol names
16:47:41 <chessguy> reffie, in haskell? it's more like 90% planning, 5% coding, and 5% debugging, for me
16:47:42 <matthew-_> right.
16:47:50 <reffie> chessguy wow
16:48:07 <popcount> conal, class  (ContravariantFunctor f) => Shortname f where and instance (ContravariantFunctor f) => Shortname f where (a few lines)
16:48:10 <ddarius> Haskell gets rid of the time wasted debugging by not having a (traditional) debugger.
16:48:27 <Baughn> That's one way to do it.
16:48:38 <popcount> ddarius, that's non-sense.
16:48:40 <LoganCapaldo> debugging does suck. I've never used a debugger to sucessfully fix a bug
16:48:53 <popcount> ddarius, what is the most difficult algorithm you implemented in Haskell?
16:49:00 <mrd> leverage the type system, write SHORT specific functions, test them in the GHCi toplevel, and you will not need a debugger 95% of the time.
16:49:14 <LoganCapaldo> I've used debuggers to increase my understanding of some existing code, but I've never managed to get a debugger to actually debug something
16:49:20 <lament> ddarius: my language, -Haskell, gets rid of the time wasted running the program by not having an implementation
16:49:23 * EvilTerran thinks that a stepwise evaluator'd be nice, for educational purposes if not debugging ones
16:49:43 <mrd> then take your tests and devise unit tests / quickcheck tests
16:49:46 <mrd> ;)
16:49:52 <conal> popcount: what about functions from arbitrary contravariant functors?  they won't work on shortnames
16:49:52 <ddarius> popcount: Algorithms are unlikely to form a poset let alone a totally ordered one w.r.t. difficulty.
16:49:56 <lament> the nice thing about languages like C is that it's pretty obvious what a human-meaningful "step" is
16:50:31 <ski> conal : class-aliases (TM) would help here
16:50:35 * Toxaris used debugging with Java a lot. it really helps finding null pointer exceptions. of course, decent languages have no null pointer exceptions
16:50:41 <byorgey> EvilTerran: hmm, doesn't something like that already exist?
16:50:46 <byorgey> @where hat
16:50:46 <lambdabot> http://www.haskell.org/hat/
16:50:48 <mrd> I read the class alias proposal recently.  What do people think of that?
16:50:55 <popcount> ski, I just shown how class-aliases would work.
16:51:00 <ski> (<http://repetae.net/john/recent/out/classalias.html>)
16:51:05 <shapr> Speaking of SICP lectures, I have a bunch of Hamming lectures that are in .mov format, does anyone know of a player that handles Quicktime in fast start mode?
16:51:15 <conal> ski: exactly.  i think popcount's solution fails due to contravariance.
16:51:18 <Tchakkazulu> I like the class aliases. There's just a few things that make it tricky for the unaware user.
16:51:19 <EvilTerran> i wasn't aware of one, but i seem to perpetually have about a dozen possible things-to-research wrt haskell at any one time
16:51:25 <chessguy> shapr, are those lectures online somewhere?
16:51:28 <xerox> shapr: mplayer.
16:51:30 <EvilTerran> so the existence of one doesn't/wouldn't surprise me
16:51:33 <shapr> They were, not sure if they still are.
16:51:33 <lament> Toxaris: null pointer exception is just getting a Nothing when you use a fromJust
16:51:33 <bwwx> i heard that the next version of ghc will have a debugger. where can i find more information about this?
16:52:10 <Toxaris> lament: but in Haskell, I can avoid Nothing by avoiding Maybe
16:52:10 <shapr> xerox: Doesn't seem to work
16:52:14 <bwwx> lament: with null pointer exception you get a nice stack trace and source location. with fromJust you just get a cryptic exception message :'(
16:52:27 <xerox> shapr: maybe I'm not sure what you meant then
16:52:36 <lament> Toxaris: point.
16:52:49 <Baughn> bwwx: There's a way to get backtraces. It's buried in the profiling section.
16:52:51 <shapr> xerox: file says Hamming00.mov: Apple QuickTime movie (fast start)
16:52:53 <mrd> don't use fromJust =)
16:52:55 <mrd> but yea, +RTS -xc
16:53:08 <shapr> xerox: mplayer says MOV: missing data (mdat) chunk! Maybe broken file...
16:53:20 <chessguy> shapr, what's the title of the series?
16:53:34 <Toxaris> > fromMaybe (error "nothing exactly here") Nothing
16:53:36 <dolio> bwwx: Don't use fromJust. :)
16:53:36 <lambdabot>  Exception: nothing exactly here
16:53:44 <xerox> shapr: I wonder if QuickTime plays those.
16:53:53 <lament> > fromJust Nothing
16:53:55 <lambdabot>  Exception: Maybe.fromJust: Nothing
16:54:04 <Tchakkazulu> @type fromMaybe
16:54:05 <lament> the difference is slight :)
16:54:05 <lambdabot> forall a. a -> Maybe a -> a
16:54:07 <chessguy> bwwx, don't use "nice" to describe stack traces :)
16:54:21 <shapr> xerox: I don't know.
16:54:27 <Toxaris> lament: i can encode whatever (static) information I like in the error message
16:54:27 <lament> stack traces _are_ quite informative.
16:54:30 <popcount> ddarius, I don't think it's that difficult to rank algorithms by difficulty (where difficulty is defined by the implementor (i.e. you))
16:54:41 <xerox> shapr: is it big? If you send it to me I can try.
16:54:42 * ski sorta likes the way hugs report failed pattern-matches
16:54:46 <chessguy> i've never seen a nice stack trace
16:54:47 <Baughn> chessguy: Would you describe type errors as "nice"?
16:54:50 <popcount> ddarius, you were just dodging the question.
16:54:58 <chessguy> Baughn, not most of the time, no
16:55:00 <phobes> lament: thanks
16:55:11 <popcount> +not
16:55:17 <lament> what's that haskell-for-education that tries to have nice error messages?
16:55:19 <Baughn> chessguy: So compilers aren't nice. I can agree with that.
16:55:21 <popcount> s/+not//g
16:55:27 <ddarius> popcount: It'd be hard to judge, bet even giving it.  Difficulty is relative.  It's like utility in economics, what I find difficult and my relative ordering means nothing to you.
16:55:34 <EvilTerran> lament, some people prefer hugs' error messages...
16:55:43 <Baughn> chessguy: Could be worse. Could be a non-euclidian sewer grid.
16:55:59 <lament> EvilTerran: i think the two things are related... am i talking about Gopher?
16:56:17 <chessguy> @remember Baughn Could be worse. Could be a non-euclidian sewer grid.
16:56:17 <lambdabot> Done.
16:56:21 <EvilTerran> hugs = Haskell User's Gopher System, so, yes.
16:56:23 <lament> gofer, rather
16:56:24 <dolio> lament: Helium.
16:56:27 <ddarius> popcount: I have been programming in Haskell since 2002 though.
16:56:28 <lament> ohhh, helium
16:56:29 <lament> thanks
16:56:36 <popcount> ddarius, I don't think that's true considering that different algorithms have different invariants.
16:56:42 <lament> http://www.cs.uu.nl/helium/
16:56:44 <lambdabot> Title: [ The Helium Homepage - Home]
16:56:45 <Toxaris> writing Haskell is like 40% figuring out what type I want, 40% figuring out how to populate that type, 10% how to populate it with the right thing, 5% how to populate it in a nice way and 5% debugging by invoking functions in ghci (that's only the programming part, of course, after I know what I want algorithm-wise)
16:56:54 <popcount> ddarius, and more complicated invariants generally give rise to more complicated programs.
16:57:11 <ddarius> popcount: Which doesn't mean more difficult.
16:57:17 <lament> "Helium is a functional programming language and a compiler designed especially for learning Haskell." -- what other languages have languages written especially for learning them?
16:57:29 <ddarius> popcount: A "simple" algorithm I don't understand is more difficult than a "complex" one I do.
16:57:31 <chessguy> @where helium
16:57:31 <lambdabot> http://www.cs.uu.nl/research/projects/helium/
16:57:51 <Baughn> lambdabot: Scheme. DrScheme, rather.
16:57:58 <lament> but helium does seem nice
16:58:10 <lament> Baughn: drscheme is just a scheme implementation...
16:58:17 <Baughn> lament: Designed for learning, yes
16:58:30 <monochrom> drscheme is an IDE rather than a different language.
16:58:31 <lament> but here we have a _language_ for learning _another_ language
16:58:33 <popcount> ddarius, you know what, we drop the discussion, since you obviously have no intention of talking about a 1000+ line algorithm implementation you did and never longed for a debugger.
16:58:42 <Baughn> lament: There's also.. pascal. A /language/ designed for learning. According to my professors.
16:58:48 <ski> lament : DrScheme has several "language levels"
16:59:11 <Baughn> lament: My first functional programming class was taught using pascal
16:59:11 <lament> Baughn: that's not the point, lots of languages are designed for learning; but this one is for learning _Haskell_
16:59:17 <ddarius> popcount: I've definitely written multple 1000+ line programs in Haskell, but again that doesn't mean they were difficult.
16:59:30 <ski> (of which iirc the first is first-order and without mutation)
16:59:38 <lament> ski: yeah, good point
16:59:38 <ddarius> popcount: How about you give an objective definition of what you would consider difficult (or a range of examples).
16:59:55 <ddarius> Finally, I think you missed the humorous intent of my original statement.
16:59:57 <lament> ski: that was annoying, when stuff doesn't work because you forgot to set the language level :)
17:00:13 <popcount> ddarius, you mean on the posets?
17:00:16 <EvilTerran> ugh... pascal
17:00:19 <ChilliX> lament: Helium really is a subset of Haskell (not a separate language) - much like the different "levels" of DrScheme are subsets of scheme
17:00:32 <ddarius> popcount: I mean my original statement.
17:00:51 <popcount> ddarius, on the debugger?
17:00:53 * EvilTerran has been force-fed a pascal-derivative (oberon 2, specifically) at university **shudder**
17:01:13 <monochrom> what's wrong with oberon?
17:01:20 <ddarius> [18:47] <ddarius> Haskell gets rid of the time wasted debugging by not having a (traditional) debugger.
17:02:27 * oerjan did Modula-2 (after Pascal proper)
17:02:32 <EvilTerran> monochrom, keywords must be in UPPER CASE
17:02:42 <EvilTerran> the string syntax is so very, very broken
17:02:51 <popcount> ddarius, that statement has been said over and over, but that doesn't mean it's true. The logic is flawed too. It should be "Haskell eliminates the time spent in the debugger, because it doesn't have one."
17:03:15 <ddarius> popcount: Hence it being a -joke-
17:03:22 <popcount> ddarius, there's nothing funny about that, imho.
17:03:28 <lament> i think the current situation is quite funny, actually.
17:03:28 <monochrom> letter case is a red herring to me. what is its string syntax?
17:03:32 <EvilTerran> it needs const parameters as well as var parameters, for when you want to pass a large structure as a parameter to a function, but want to fix in the interface that you're not modifying it
17:03:33 <mauke> it's funny 'cause it's true
17:03:36 <ddarius> popcount: Okay, hence it being a -wry- -joke-
17:03:38 <EvilTerran> (minor point)
17:03:41 <mrd> I find it quite amusing
17:03:49 <lament> EvilTerran: Haskell has case restrictions too
17:03:58 <EvilTerran> monochrom, you can't include "s in a string
17:04:06 <lament> I think the joke itself is not as funny as popcount's reaction
17:04:17 <EvilTerran> a single-character double-quoted expression is a character. any other quoted expression is a string
17:04:18 <monochrom> const and var parameters are fine with me - I even consider it a must for imperative languages.
17:04:23 <EvilTerran> there are no escape characters
17:04:33 <ddarius> That said, to be honest, I've never really much jonesed for stepping debugger for debugging Haskell code (for other things, yes).
17:04:50 <dcoutts> EvilTerran: ah yes, we force oberon on the poor first years. If it's any consolation, it's not easy to teach either :-)
17:05:01 <oerjan> EvilTerran: just yesterday someone complained because Haskell has no raw string syntax (so it's awkward to include lots of \'s)
17:05:03 <monochrom> That " rule is interesting. I mean annoying.
17:05:25 <wli> What?
17:05:25 <popcount> I would like to have a 1000m^2 floor on which I can step through my program.
17:05:31 <EvilTerran> lament, yes, but allcaps is stupid
17:05:53 <EvilTerran> it impairs readability, not to mention wears out my shift or capslock
17:06:02 <EvilTerran> also, they're still using null-terminated strings. WTF?
17:06:05 <lament> wears out your shift or capslock????
17:06:07 <mrd> abbrevs can fix that
17:06:10 <lament> que horrible
17:06:14 <EvilTerran> ...
17:06:19 <EvilTerran> that was meant to be non-serious
17:06:21 <mauke> EvilTerran: Haskell still uses []-terminated strings
17:06:24 <monochrom> haha
17:06:32 <mrd> i wouldn't mind multi-line string literals in Haskell
17:06:35 <EvilTerran> the "impairing readability" bit's the important bit
17:06:36 <ddarius> mauke: They are on there way out.
17:06:37 <ski> '[]' is not a character
17:06:38 <EvilTerran> mauke, not by force
17:06:44 <dcoutts> and I can never rember the names of the standard oberon functions, like for printing strings, or converting numbers to strings
17:06:49 <glguy> we have "HEREDOC" style strings
17:06:51 <EvilTerran> and that's not what i meant, anyway.
17:07:03 <dcoutts> so I look clueless when students ask me questions about oberon :-)
17:07:06 <lament> dcoutts: switching to java soon?
17:07:06 <mrd> glguy: whaa?
17:07:10 <EvilTerran> null-terminated as in at implementation level. like in <string.h> sorto f thing
17:07:11 <ski> mrd : you mean string gaps ?
17:07:25 <mrd> i mean, we do have HEREDOCs?
17:07:26 <dcoutts> lament: we use java in the second year
17:07:34 <EvilTerran> mrd, "foo\<any whitespace you like>\bar" okay?
17:07:38 <mrd> ski: I mean " ... several lines later anything goes ... "
17:07:50 <ski> foo = "bar\
17:07:50 <ski>       \baz"
17:07:52 <EvilTerran> or do you mean being able to write newlines as literal newlines in a string?
17:07:57 <mrd> without needing backslashes
17:08:00 <mrd> what EvilTerran said
17:08:12 <EvilTerran> hugs has heredocs as an optional extension
17:08:18 <mrd> nobody uses hugs
17:08:27 <EvilTerran> heh, true
17:08:28 <popcount> mrd, that's not true
17:08:29 <dcoutts> ndm swears by it :-)
17:08:36 <ddarius> mrd: Don't hurt Neil's feelings.
17:08:37 <mrd> Neil is the only person I know who does =)
17:08:50 <mauke> that's not what heredocs are
17:09:04 <mrd> I know, I'll take anything
17:09:04 <popcount> I know
17:09:06 * Toxaris uses hugs sometimes because of WinHugs, but only as calculator
17:09:15 <popcount> mrd, you can implement heredocs with TH
17:09:19 * ski uses hugs and ghc
17:09:23 <EvilTerran> anyway. i'd rather write imperatively in haskell with IORefs than in Oberon.
17:09:27 <popcount> mrd, it has been done before, so you can also look it up.
17:09:29 <mrd> probably. I need to learn TH still.  good exercise I guess.
17:09:39 <glguy> mrd: I think they only exist in Hugs though
17:09:46 <EvilTerran> i can keep ranting about things wrong with it, but i've covered the major points, i think.
17:10:10 <Toxaris> EvilTerran: writing imperatively in haskell with IORefs is not so bad
17:10:11 <EvilTerran> (allcaps and utterly ridiculous string rules being the main ones)
17:10:14 <mauke> heredocs have weird effects on the lexer
17:10:16 <dcoutts> EvilTerran: so what imperitive language would you teach first?
17:10:30 <EvilTerran> er. python?
17:10:40 <dcoutts> I always thought pascal wasn't too bad as a first imperative language
17:10:44 <glguy> http://cvs.haskell.org/Hugs/pages/users_guide/here-documents.html
17:10:51 <Excedrin> JavaScript = best language
17:11:00 <mrd> yes, it's good for scaring people away from imperative languages
17:11:14 <chessguy> javascript is pretty freaking cool
17:11:17 <Excedrin> why isn't it more widespread? it should replace Python/Ruby/Perl etc
17:11:28 <ddarius> javascript could so easily be so much nicer
17:11:30 <mrd> crappy implementations? perception?
17:11:39 <mauke> that's just string interpolation
17:11:40 <mrd> I agree, it is neat.
17:12:06 <EvilTerran> depending on the focus of the course, pascal might be fine. but i got the impression the people in my year were left thinking that imperative programming is all about fighting with null-terminated strings
17:12:07 <mauke> here documents should use line-based quoting
17:12:08 <Excedrin> and with ecma4 static typing and type inference and stuff... and it's more widely available than anything
17:12:28 <ddarius> Add proper block structure (i.e. lexical scoping) and TCO and javascript would be dandy.
17:12:43 <ddarius> Excedrin: It has to be implemented widely for it to be available widely.
17:12:43 <Excedrin> wait, it doesn't have lexical scope?
17:12:54 <mauke> Excedrin: ...
17:12:59 <Excedrin> ddarius: I think it is implemented widely
17:13:05 <ddarius> 4?
17:13:06 * EvilTerran is utterly befuddled by JS's scoping rules
17:13:09 <chessguy> ddarius, TCO?
17:13:15 <ddarius> tail call optimization
17:13:17 <LoganCapaldo> tail call optimization
17:13:26 <Excedrin> at least, more widely than any other scheme-ish language
17:13:32 <chessguy> aha
17:13:33 <LoganCapaldo> ddarius's answer was more optimized than mine
17:13:37 <glguy> EvilTerran: its more complicated that if you use a "var" its local and if you don't its global?
17:13:55 <glguy> than*
17:13:56 <mrd> it has firstclass functions..
17:14:00 <mauke> javascript has no block scope
17:14:03 <EvilTerran> that's the impression i get. it might be a case of shoddy implementation.
17:14:14 <glguy> mauke: it doesn't?
17:14:16 <chessguy> yes, javascript's scoping is complicated
17:14:20 <glguy> mauke: you can have for-loop local vars
17:14:21 <ddarius> glguy: It explicitly states that.
17:14:24 <mauke> "local" really means bound to the current function
17:14:27 <ddarius> glguy: No you can't.
17:14:30 <mauke> glguy: since when?
17:14:31 <chessguy> glguy, wrong
17:14:45 <glguy> maybe firefox is broken? was broken
17:14:57 <EvilTerran> it's got function scope and global scope, iirc
17:15:03 <EvilTerran> but it's a mess.
17:15:07 <ChilliX> Random JS reference, but with a FP angle: http://research.microsoft.com/~crusso/ml2007/accepted/15.html
17:15:07 <lambdabot> Title: ML 2007 - Status Report: Specifying JavaScript with ML
17:15:22 <mauke> and that's why everyone should use Perl instead
17:15:29 <chessguy> ChilliX, JS is FP
17:15:49 <glguy> "Global means a variable can be referenced anywhere in the current document. Local means a variable can only be referenced within the function it is declared."
17:15:49 <ddarius> Excedrin: I don't like ECMA4's move to class based OO.
17:15:50 <ChilliX> chessguy: well, in some sense, yes
17:15:52 <glguy> is there more to it than that?
17:15:55 <LoganCapaldo> what about function a() { var x = 1; function() { var x = 2; }(); } isn't that good enough?
17:16:07 <LoganCapaldo> (or does that not work, I thought it did)
17:16:11 <ChilliX> chessguy: FP language for imperative programming ;)
17:16:45 <Excedrin> ddarius: why are they changing that?
17:16:46 <sorear> Why does everyone think all non-OO languages are automatically bad, and try to fix them?
17:17:16 <ChilliX> sorear: Very true
17:17:37 <wli> Oh, yeah, good luck processing strings with embedded '\NUL' in C, at least without writing your own library from scratch or fishing far and wide for a nonstandard library.
17:17:39 <EvilTerran> LoganCapaldo, i'm pretty sure that works, but so does switching to a language that has proper scoping rules.
17:17:48 <EvilTerran> ;]
17:17:49 <ddarius> http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Statements:block
17:17:51 <lambdabot> Title: Core JavaScript 1.5 Reference:Statements:block - MDC, http://tinyurl.com/2ego4q
17:17:51 <ChilliX> sorear: maybe because everyone spent years learning OO and doesn't want to see that effort wasted?
17:17:53 <mrd> sorear: huh?
17:17:54 <ddarius> Excedrin: I have no idea.
17:18:20 <mrd> sorear: this is a non-OO language channel
17:18:40 <ChilliX> mrd: this is why he could make that statement here and live!
17:18:48 <mauke> we have OO in a library
17:18:51 <mrd> (just in case you didn't notice :P )
17:19:05 <mrd> we do? kill it!
17:19:09 <ddarius> glguy: javascripts's scoping leads to really insane bugs when you start to do higher-order stuff.
17:19:11 <monochrom> Why do all type system people think OO languages automatically need a sound type system? :)
17:19:28 <ski> they don't ?
17:19:31 <ddarius> monochrom: Because they think all languages automatically need a sound type system.
17:19:38 <Excedrin> ddarius: any idea if they're fixing the scope stuff?
17:19:54 <ddarius> Excedrin: I think they are and the TCO aspect.
17:19:55 <mauke> why do java people think java has a good/useful static type system?
17:20:12 <mrd> because they are java people. q.e.d.
17:20:15 <ddarius> Excedrin: Except for the push back toward class-based OO, it looks like it will be a pretty nice language.
17:20:58 <EvilTerran> my instinctive feeling is that haskell's extended Hindley-Miller does a better job than OO does
17:21:07 <mrd> Milner!
17:21:12 <EvilTerran> as static type systems go
17:21:18 <EvilTerran> yes, milner, sorry. =/
17:21:19 <monochrom> Miller is the mayor of Toronto.
17:21:22 <mrd> and yes, I don't think there's anyone here who'd disagree
17:21:49 <EvilTerran> when using OO, i've always found the object/parameter distinction painfully arbitrary
17:22:01 <mrd> ah, check out multiple-dispatch then
17:22:30 <EvilTerran> especially in, say, ruby, where a lot of methods seem to be methods rather than vanilla functions purely for the purposes of namespacing and allowing left-to-right reading
17:23:00 <Excedrin> the Budweiser-Miller type inference algorithm; I'm drinking beer and inferring that it might be water
17:23:03 <mrd> yes, those kind of languages kludge all kinds of concepts into one
17:23:07 <ddarius> mrd: I always found that argument result distinction painfully arbitrary
17:23:14 <ddarius> Perhaps I should go back to Prolog.
17:23:20 <jfredett> Excedrin: ... brilliant?
17:23:22 <mrd> ddarius: hmm, continuations?
17:23:24 <wli> OO has always seemed rather useless to me.
17:23:50 <wli> ddarius: I was rather fond of Mercury.
17:24:17 * EvilTerran does have a certain fondness for prolog
17:24:19 <johnnowak> wli: i felt the same before using smalltalk and io a fair bit.
17:24:34 <ddarius> wli: Just looking at Mercury code was turning me off it.  That combined with Pseudonym's not especially positive report on it led to me never looking at it for real.
17:24:50 <EvilTerran> i get the same warm fuzzy feeling from doing arithmetic in haskell's type system, though, so that's okay =]
17:25:14 <ddarius> johnnowak: All Smalltalk did for me w.r.t. OO is make me hate deep inheritance heirarchies with a burning passion.
17:25:17 <glen_quagmire> haskell is so hard
17:25:36 <glen_quagmire> i'm a troll sorry
17:25:36 <johnnowak> ddarius: aye, prototype-based OO is the way to go
17:25:41 <wli> ddarius: I liked the Prolog + static typing bit.
17:25:41 <monochrom> I feel that "x.add(y.add(z))" is very wrong, both syntactically and conceptually. Amazingly, I met some OO bigot who felt it's superior.
17:25:51 <ddarius> johnnowark: Heck yeah.  That or lambda-based OO.
17:26:11 <oerjan> @remember Excedrin the Budweiser-Miller type inference algorithm; I'm drinking beer and inferring that it might be water
17:26:11 <lambdabot> Done.
17:26:13 <Excedrin> monochrom: wow, that's serious brainwashing
17:26:22 <ddarius> monochrom: You've met OO bigots who don't think it's superior?
17:26:24 <johnnowak> monochrom: it makes sense syntactically if you're dispatching on the "first" argument, no?
17:26:27 <EvilTerran> glen_quagmire, in time, the tough tools will come to serve you the best. :)
17:27:06 <Nafai> ddarius: What's lambda based OO?
17:27:12 <EvilTerran> dispatching on specific objects! ridiculous concept, i say! **adjusts his monocle**
17:27:16 <Toxaris> johnnowak: but dispatching on the first argument doesn't makes sense
17:27:52 <glguy> maybe it does if you want: int + float to equal int
17:27:55 <olliej> ddarius: OO is different, and better in some respects than damas-milner, but that goes both ways
17:27:58 <glguy> and float + int to be a float
17:28:01 <johnnowak> Toxaris: well that's another thing altogether... but if one is to do so, that sort of syntax makes sense
17:28:02 <oerjan> monochrom: in Scala x + y is syntactic sugar for x.+(y), i think
17:28:18 <monochrom> ddarius: not sure what you mean, but the OO bigot felt that "x.add(y.add(z))" is superior to x+y+z
17:28:25 <dolio> That's how it is in a lot of OO languages.
17:28:32 <olliej> smalltalk!
17:28:46 <EvilTerran> glguy, but do you ever actually want that to be the case?
17:28:53 <mrd> 1 + 2 * 3 -- does (1+2)*3 in smalltalk =)
17:29:05 <glguy> EvilTerran: I don't think so... which is why dispatch on the first argument doesn't make sense?
17:29:10 <johnnowak> Io> message(1 + 2 + 3)
17:29:10 <johnnowak> ==> 1 +(2) +(3)
17:29:18 <EvilTerran> whatever happened to commutativity of addition?
17:29:27 <ddarius> http://www.erights.org/elib/capability/ode/ode-objects.html
17:29:28 <lambdabot> Title: From Functions To Objects
17:29:45 <ddarius> olliej: What are you responding to?
17:29:53 <ortmage> EvilTerran: it was never more than an illusion in the case of floating point numbers :)
17:29:58 <EvilTerran> well, yes =/
17:30:21 <olliej> "ddarius: monochrom: You've met OO bigots who don't think it's superior?"
17:30:47 <byorgey> question: I'm trying to trace something in hat-explore but ghc has apparently transformed the code using various reductions/fusion rules/whatever so it no longer looks anything like the source.  Is there a way to tell ghc not to do that?
17:30:59 <monochrom> I think I now get what ddarius means. :)
17:31:01 <EvilTerran> I'm of the opinion that such things as "x.add(y.add(z))" fall into the category of overspecifying what you want to do
17:31:08 <ddarius> olliej: What does Damas-Milner have to do with it?
17:31:08 <ChilliX> byorgey: -Onot
17:31:14 <johnnowak> EvilTerran: no one writes that
17:31:27 <byorgey> ChilliX: I already tried that, it doesn't seem to work =(
17:31:29 <EvilTerran> and this is Bad for both optimisation and self-documentation of code
17:31:57 <popcount> Why doesn't Haskell use the expected type to reduce the number of import conflicts>
17:31:57 <popcount> ?
17:32:03 <sorear> ortmage: Floating-point addition *is* commutative.
17:32:09 <ddarius> Nafai: Incidentally that link to erights.org was intended for you if you didn't get that.
17:32:11 <Toxaris> what I like about OO is the expressivenes of subtyping and dynamic dispatch. what i don't like is the complexity to understand subtyping and dynamic dispatch. what I want is Haskell + subtyping with static guarantees :)
17:32:33 <EvilTerran> johnnowak, i imagine that's overstating things slightly, but OO does tend to force you to pick an object to dispatch on and pick a bracketing order, even when you're using a commutative operation
17:32:37 <mrd> subtyping in a static type system makes things wacky imo
17:32:39 <dolio> johnnowak: Java people do (except for the primitive types... and Strings).
17:32:41 <EvilTerran> *commutative, distributive
17:32:42 <Baughn> EvilTerran: This discussion reminds me of that language where there is no addition function, only an increment-by-N (mutating) method. What was the name again..?
17:32:49 <olliej> Toxaris: you can get there if you have a static class based type system that does not allow null or downcasting
17:32:51 <EvilTerran> Malbolge?
17:33:01 <mrd> EvilTerran: Java OO forces you to pick an object ... not all OO languages are retarded like that
17:33:12 <ddarius> mrd: All subtyping happens in a static type system.
17:33:14 <johnnowak> Toxaris: would something with the semantics of smalltalk then suit you, if you could guarantee statically you'd have no "does not respond to" errors and no type errors, but you'd lose the ability to ask for the type of a given method without supplying the types of the arguments?
17:33:15 <Baughn> EvilTerran: Noo.. you'd think, but this one sees serious use.
17:33:29 <sorear> Baughn: Assembly?
17:33:32 <mrd> ddarius: what I meant was, the typing judgements for subtyping are unintuitive
17:33:45 <glguy> ?quote conflata
17:33:45 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
17:33:46 <glguy> ?quote conflat
17:33:46 <lambdabot> No quotes match. Wrong!  You cheating scum!
17:33:58 <Baughn> sorear: Hmm. Nah. Looked like Java.
17:34:28 <oerjan> EvilTerran: malbolge has nothing as nice as increment by n
17:34:32 <Toxaris> johnnowak: maybe. I don't know the semantics of smalltalk good enough to answer this.
17:34:35 <mrd> ddarius: Java doesn't have function types, but, the way subtyping works for those is quite ... weird.  at least that's what I thought when I was first exposed to it.
17:34:37 <johnnowak> sometimes i feel dynamic advocated judge static languages by java, and functional advocates judge OO languages by java.
17:34:49 <johnnowak> advocates, even.
17:35:03 <monochrom> Haha. When I am not starting a flame war, I am adding fuel to a flame war. When I am not adding fuel to a flame war, I am reading a flame war. (Logic exercise: assume also that I do exactly one thing at a time, what am I doing?)
17:35:06 <EvilTerran> avocados?
17:35:16 <johnnowak> mmmmm.
17:35:16 <mrd> mmm guacamole
17:35:22 <ddarius> mrd: Subtyping rules make perfect sense.  Most of the difficulty with regards to subtyping comes from OO languages that don't follow subtyping rules.
17:35:52 <Baughn> monochrom: Adding fuel. Obviously.
17:36:02 <EvilTerran> monochrom, reading reddit?
17:36:09 <monochrom> haha
17:36:36 <mrd> ddarius: I don't have my Pierce with me, but the judgement for function types is basically:  if (S1 <: S2) and (T2 <: T1) then ((S1 -> T1) <: (S2 -> T2)).  I might have mixed that up.
17:36:41 <sorear> Are the subtyping rules documented anywhere besides TaPL?  I've never seen them on my sporadic attempts to google
17:36:50 <Cale> monochrom: Describing what you do all the time doesn't seem to fit into any of those categories.
17:36:57 <mrd> and I don't think that is at all intuitive.
17:36:59 <Cale> monochrom: Liar. ;)
17:37:01 <wli> sorear: There are different choices for them.
17:37:24 <wli> sorear: ISTR Wadler brewed up his own set (F-bounded polymorphism) for his proposal for Generic Java.
17:37:39 <monochrom> Cale: Ask me which path leads to Heaven. XD
17:37:47 <ddarius> mrd: You have it backwards.  All you really need to know is that the function type constructor is contravariant in it's argument.
17:38:02 <Toxaris> johnnowak: I want multi-dispatch (all parameters are born equal), pureness (side effects *are* evil), inferred structural typing (the typechecker should work for me, not the other way around), ...
17:38:35 <Toxaris> johnnowak: of course garbage-collection, usage of multi-cores, compilation to native machine code, ...
17:38:39 <johnnowak> Toxaris: I think a lot of people want that.
17:38:47 <ddarius> mrd: Oops, I misread.
17:38:57 <xerox> monochrom: which path leads to Heaven?
17:39:01 <ddarius> My latter statement stands though.
17:39:25 <EvilTerran> Toxaris, sounds like you want haskell...
17:39:34 <Toxaris> johnnowak: a rich, sensible and adoptable syntax, lazyness or strictness as needed by the task at hand, ...
17:39:41 <ddarius> mrd: If you think about what "being a subtype" means, it should be obvious why the function type constructor is contravariant in it's argument and covariant in it's result.
17:39:50 <mrd> also his system F_<: had undecidable type reconstruction
17:39:54 <mrd> I think
17:40:06 <EvilTerran> alternatively, you want a dozen research students in a box
17:40:25 <sorear> mrd: well, Fsub is the one I couldn't find information on...
17:40:28 <LoganCapaldo> MPTCs + -fallow-all-sorts-of-evil get you multi-dispatch pretty much right?
17:40:29 <EvilTerran> with some kind of telepathy device
17:40:32 <Toxaris> EvilTerran: yes, Haskell is pretty good...
17:40:53 <LoganCapaldo> but I don't see how to get structural subtyping from haskell
17:40:59 <ddarius> mrd: Alternatively, think of A <: B meaning there exists a coercion A -> B, then think how you would need to apply those coercions to a function type.
17:41:04 <mrd> ddarius: I suppose.  but then I start to think, why do I really need this?
17:41:17 <LoganCapaldo> stick in an inferred in my sentence
17:41:41 <wli> mrd: Variants are where it really comes in handy.
17:41:49 * EvilTerran recently had a minor insight wrt stateful monads, and thinking about the flow of execution as a path between binds
17:41:56 <EvilTerran> ...in other news ;p
17:42:02 <wli> But that's for structural subtyping... OO stuff is complete garbage.
17:42:14 <mrd> sorear: I wouldn't know offhand either. perhaps l-t-u
17:42:33 <ddarius> sorear: Read Cardelli's papers?
17:43:06 <wli> The usual example is actually records where one has more fields than the other. I don't find that particularly useful.
17:43:09 <monochrom> Cardelli has a TeX font mimicking Dijkstra's handwriting. :)
17:43:18 <ddarius> http://lucacardelli.name/Bibliography.htm
17:43:20 <lambdabot> Title: Publications
17:43:21 <Toxaris> EvilTerran: Haskell has everything except dynamic dispatch and (inferred structural or other) subtyping. OO has nothing except broken dynamic dispatch and broken subtyping. So the way to go is clearly to enhance Haskell even further, not to stick with broken languages of broken concepts
17:43:34 <ddarius> wli: Both cases are useful.
17:43:50 <johnnowak> Toxaris: can you clarify "broken dynamic dispatch"?
17:43:59 <ddarius> Toxaris: Not all OO languages have broken subtyping rules.
17:44:08 <wli> ddarius: I see the record case as less useful.
17:44:18 <shapr> Toxaris: Doesn't pattern matching fit into dynamic dispatch?
17:44:26 <EvilTerran> Toxaris, yeah, enhancing haskell sounds like a good plan... reminds me of something i thought up when i was at anglohaskell -- we should be trying to make haskell more like haskell than it is already
17:44:32 <shapr> Oh wait, *dynamic* means at runtime, right?
17:44:35 <wli> O'Haskell?
17:44:42 <shapr> In that case, what about typeclasses for dynamic dispatch?
17:44:46 <mrd> make haskell more like Haskell?
17:45:18 <shapr> Toxaris: Yeah, I think typeclasses do cover dynamic dispatch.
17:45:20 <Toxaris> johnnowak: single dispatch is broken in that it is not multi dispatch, and multi dispatch is broken in that it is not statically checked to make sense
17:45:36 <EvilTerran> mrd, yes. there's the current, imperfect language, and the unattainable "haskell spirit" to strive towards.
17:45:49 <mrd> EvilTerran: or Prof. Curry
17:45:52 <ddarius> Toxaris: You probably would've liked Needle.
17:46:03 * ddarius probably would have liked Needle. Freakin' Neelan.
17:46:11 <Toxaris> shapr: sure, pattern matching is dynamic dispatch, but i want statically typechecked dynamic dispatch.
17:46:28 <mrd> does that make sense?
17:46:42 <Toxaris> shapr: and I want it for subtyping, wich is available only statically via typeclasses in Haskell
17:47:03 <johnnowak> Toxaris: there are some issues with separating functions from their objects in prototype-based OO systems with multiple dispatch.
17:47:10 <EvilTerran> maybe think of it as the socratic form of haskell-like languages =]
17:47:17 <mrd> perhaps if we pool our collective milli-olegs together we can solve this
17:47:33 <ddarius> Toxaris: http://www.nongnu.org/needle/
17:47:35 <lambdabot> Title: Needle, An Object-Oriented Functional Language
17:48:07 <wli> ISTR Cardelli making an ML2000 proposal including structural subtyping.
17:49:38 <ski> Baughn : Linear Lisp ? (Baker)
17:50:02 * EvilTerran -> zzz
17:51:02 <Toxaris> ddarius: yes needle sounds not so bad, except for "last modified 2002"
17:51:10 <ski> Toxaris : what do you mean by 'dynamic dispatch' ?
17:51:36 <LoganCapaldo> Was needle the one that didn't actually have an impl.?
17:51:45 <LoganCapaldo> Or was that some other oo functional language
17:52:12 <LoganCapaldo> oh now I remember
17:52:19 <newsham> littledan, bmwx: came across "Narrative JavaScript" and "Strands" which basically do what I was asking about.
17:52:39 <newsham> looked at some of the yhc examples, looks interesting but realy large generated code
17:53:10 <Excedrin> there's a lot of them right? Scala and Nemerle come to mind; obviously CL, but I don't know if that counts
17:53:58 <johnnowak> is there any statically typed language where the type of a function is determinable only when its arguments are specified? there may still be a restriction such that, for any function and set of arguments, there can only be one possible return type. the return type would be conditional only on the types of the arguments, not their values. i mean something more than some function a -> b -> a or something like that. not
17:54:19 <wli> I'm not sure structural subtyping qualifies as OO, which is why I can stomach the thought of it.
17:54:46 <ski> johnnowak : mayhaps what you're thinking of is dependent types ?
17:54:53 <Toxaris> johnnowak: Haskell with MPTCs and FunDeps?
17:55:00 <ddarius> wli: Structural subtyping alone certainly does not (and typical OO languages use nominal subtyping, but there are certainly counter examples)
17:55:16 <glen_quagmire> do you really like haskell or are you just using it because other people do?
17:55:19 <ski> printf :: (s :: String) -> Printf s
17:55:23 <monochrom> johnnowak: Text.Printf sounds like an example of that.
17:55:26 <johnnowak> ski: would it still be considered a dependent type system even if the values of the arguments are not considered?
17:56:20 <ski> johnnowak : oh .. then maybe intersection types ?
17:56:24 <Toxaris> ski: by dynamic dispatch, I mean that instance selection depends on information only available at runtime. for example having two instance declarations for Either, and one is choose for Left, another for Right values
17:57:07 <wli> I forget what the results on type inference in the presence of structural subtyping are. I'm not a language designer/implementor, though, so I need not concern myself much with it.
17:57:28 <Toxaris> ski: now I could even decide to provide an instance declaration only for Right values (that would mean: this class is not available in case of error), and the type checkers would try to prove that there are no possible Left, so it could accept the use of that class
17:57:39 <Toxaris> ski: that is dependent typing, of course
17:57:45 <ski> glen_quagmire : yes, i really like haskell
17:58:22 <johnnowak> Toxaris: are you talking about printf or my question?
17:58:22 <glen_quagmire> alright
17:59:22 <ski> Toxaris : and what is 'instance' and 'instance selection' ?
17:59:52 <Toxaris> ski: 'instance' = dictionary and 'instance selection' = the decision wich dictionary to use
18:00:49 <Toxaris> ski: for single dispatch, that could be implemented by passing two different dictionaries along with each Either value, and at runtime, the Left or Right one is choosen. but for multi dispatch, it's obviously not that easy
18:01:43 <glen_quagmire> is there an IDE or texteditor that does auto completion?
18:01:45 <ski> Toxaris : how is the code structured ? i.e. do you define functions by cases in one place, but different functions separated ? .. or define functions by possibly uses of result in one place, but different functions separated ?  .. or something else ?
18:01:46 <Toxaris> johnnowak: i think i'm speaking about your question :) but i'm not even sure i can read your whole question. it ends with " something more than some function a -> b -> a or something like that. no". is that intentionally?
18:02:04 <newsham> the simon peyton-jones osscon video/slides discusses instance dispatch
18:02:06 <johnnowak> Toxaris: you missed "not sure that makes sense"
18:02:34 <ski> Toxaris : ok .. it sounds more like the latter, then
18:02:34 <johnnowak> Toxaris: essentially, i'm looking for a type system that closely approximates what one can do in something like smalltalk or other "message-based" language
18:02:57 <newsham> johnnowak: you mean duck typing?
18:03:20 <johnnowak> newsham: yes
18:03:45 <newsham> cant you use Dyn to do that kinda stuff?
18:03:51 <newsham> (<- hasnt tried)
18:04:08 <johnnowak> i'm not looking to approximate it in haskell
18:04:12 <Toxaris> ski: the best would be to specify functions in "pattern matching" style wherever I like, even in seperate modules, and the compiler sorts out wich function is to be called when
18:04:26 <newsham> ahh, i'm not sure what you want then (sorry for jumping in the middle)
18:05:01 <ski> johnnowak : 'minus :: (Int -> Int) /\ (Int -> Float) /\ (Float -> Float) /\ (Int * Int -> Int) /\ (Int * Int -> Float) /\ ...' ?
18:05:59 <newsham> ski: wouldnt it be easier to say that every message is a class and everyone who supports that message defines an instance?
18:06:10 <oerjan> johnnowak: have you looked at ocaml? it has a structurally typed object system, so anything which has the right methods with the right names can be used
18:06:25 <oerjan> *names and types
18:06:31 <johnnowak> oerjan: i haven't look at it too closely, no. i will do that.
18:06:48 <ski> newsham : what is a message ? what is a class ? .. mayhaps you wanted to ask Toxaris ?
18:07:59 <johnnowak> ski: I mean some function like (lambda (a) (if (boolean? a) "foo" 10)), where if you know the type of a, you can determine the type of the function
18:08:15 <ski> newsham : if by 'class' you mean 'record type', and by 'everyone who supports that message' mean a value of such a type, then maybe you want OCaml ?
18:08:51 <Toxaris> johnnowak: sounds like   class Foo a b c | a b -> c where foo :: a -> b -> c   for me. the result type  is calculated from the argument types, and the result value is calculated from the argument values.
18:09:14 * ski btw can't even guess at what 'every message is a class' could mean
18:10:15 <newsham> ski: a "message" is something like "minus" and making a new class for each method would mean that every object could pick and choose which methods it supported
18:10:15 <Toxaris> ski: maybe "every function is ad-hoc polymorphic using a type class"?
18:11:12 <newsham> so there would be a Minusable class that has the (-) operator
18:11:17 <newsham> and a Plusable class that has the (+) operator
18:11:30 <ski> (johnnowak : hmm ... that makes me think on "blind quantifiers" ..)
18:11:39 <newsham> and then you could make String + String by making String and instance of Plusable
18:11:48 <Toxaris> thinking about johnnowak ideas, and my ideas, I wonder if my ideas are actually expressible in Haskell using enough type hackery
18:11:55 <johnnowak> ski: blind quantifiers?
18:12:33 <johnnowak> Toxaris: Just to clarify, I'm not suggesting this as a good idea.
18:14:00 <Toxaris> johnnowak: hehe :) yeah I understand that you are talking about the existence of such a system, not about it's qualities
18:14:29 <Toxaris> johnnowak: but my feeling that you're speaking about Haskell made me feel that I may speak about Haskell too
18:14:30 <ski> johnnowak : if 'x' is blindly quantified in 'forall x : T. P x \/ Q x' then the proof must work without any knowledge of what 'x' is .. if you're interested, you can look up Japarize's(sp?) Computability Logic
18:14:45 <newsham> typecase x of  (xs :: List) -> head xs
18:14:58 <ortmage> i remember a thread about this, but what's the de facto way to do file IO in utf8?
18:15:22 <johnnowak> ski: ah, thank you
18:16:12 <Toxaris> johnnowak: so is Haskell with MPTCs, fundeps and one-class-per-function what you mean?
18:16:30 <ski> (johnnowak : what you said made me think of something like '(t : Type) -> forall x : t. Foo t' where 'forall' would be blind, but 'Foo t' can still use 't' to decide an appropriate return type)
18:17:33 <dolio> @type \b -> maybe (Left 10) (\(b :: Bool) -> Right "5") (cast b)
18:17:35 <lambdabot> forall t a. (Num t, Typeable a) => a -> Either t [Char]
18:17:40 <newsham> ski: dont we already have that?   Ord a => a -> M a ?
18:17:57 <johnnowak> Toxaris: i think would very closely approximate it, yes
18:18:06 <ski> newsham : sorry ?
18:18:36 <newsham> forall a st a is in Ord . a -> M a
18:18:46 <newsham> using "a" to decide an appropriate return type
18:18:51 <newsham> but otherwise quantified over, no?
18:19:54 <johnnowak> Toxaris: although would you need just a class for every function, or a class for every position in every function?
18:20:03 <ski> newsham : hm, i guess MPTC with FDs or ATs gives something a bit similar
18:20:21 <ski> (though type classes are open, not closed)
18:21:14 <Toxaris> johnnowak: I think that currying comes for free, so you would need a class per function symbol and an instance per argument type combination
18:21:39 <johnnowak> yes, that makes sense
18:21:44 <Toxaris> johnnowak: class-declarations would play to role of type declarations, and instance declarations would play the role of pattern matching
18:24:14 <ski> newsham : one could have 'minus' as a deconstructor/selector/method of any record whose type includes a 'minus' field ..
18:25:12 <Toxaris> johnnowak: the class declaration would declare the kind of the function symbol, each instance declaration would declare a possible type and many values (using pattern matching)
18:26:48 <ski> # fun obj -> obj # minus;;
18:26:49 <ski>  - : < minus : 'a;.. > -> 'a = <fun>
18:26:49 <dolio> > let f b -> maybe (Left 10) (\(b :: Bool) -> Right "foo") (cast b) in (f True, f 7)
18:26:49 <lambdabot>  Parse error
18:27:00 <dolio> > let f b = maybe (Left 10) (\(b :: Bool) -> Right "foo") (cast b) in (f True, f 7)
18:27:00 <lambdabot>  Parse error in pattern
18:27:08 <dolio> @yarr
18:27:08 <lambdabot> Well Ahoy! thar.
18:27:31 <ski> missing paren
18:27:33 <Toxaris> johnnowak: using "recursive instance constraints"  la printf, you could exploit currying and define multikinded functions, too.
18:27:54 <ski> Toxaris : multikinded ?
18:28:29 <ski> like 'Flip :: forall a b c :: *. (a -> b -> c) -> b -> a -> c' ?
18:28:52 <Toxaris> ski: the kind of the type of printf is * and * -> * and * -> * -> * and * -> * -> * -> * and ...
18:29:09 <Cale> Toxaris: no it isn't
18:29:10 <ski> i believe you not
18:29:16 <Toxaris> I talk nonsense just no
18:29:19 <sgillespie> hello
18:29:28 <Cale> Toxaris: I think you've confused what kinds are
18:29:30 <mrd> @arr
18:29:30 <lambdabot> Keelhaul the swabs!
18:29:39 <sgillespie> I am trying to find a hashtable-like structure (functional)
18:29:40 <ski> the kind of types of haskell values is '*'
18:29:45 <mrd> sgillespie: Data.Map
18:29:48 <Cale> sgillespie: Data.Map
18:29:50 <sgillespie> excellence
18:29:50 <oerjan> > \ (b :: Bool) -> b
18:29:51 <lambdabot>  Parse error in pattern
18:29:53 <sgillespie> thank you
18:30:00 <dolio> > let f b = maybe (Left 10) (\b -> Right "foo" `const` (b `asTypeOf` True)) (cast b) in (f True, f 7)
18:30:01 * mrd whispers "stereo"
18:30:01 <Toxaris> ski, Cale: yeah, kinds are about type constructors... it comes back to me :)
18:30:02 <lambdabot>  (Right "foo",Left 10)
18:30:18 <oerjan> it seems pattern type declarations are an extension
18:30:49 <Cale> yep
18:30:51 * ski ponders return-polymorphic data-constructors
18:31:26 <ddarius> :t (:)
18:31:28 <lambdabot> forall a. a -> [a] -> [a]
18:31:29 <Cale> heh, type-level printf
18:31:40 <wli> ski: GADT's?
18:33:06 <ski> @type maybe (Left 10) (\b -> Right "foo" `const` (b `asTypeOf` True)) . cast
18:33:08 <lambdabot> forall a a1. (Num a, Typeable a1) => a1 -> Either a [Char]
18:33:12 <oerjan> :t cast
18:33:16 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
18:33:22 <ski> wli : see the 'Flip' above
18:36:44 <ski> wli,(Toxaris) : err.. sorry, 'Flip :: forall a b c :: *2. (a -> b -> c) -> b -> a -> c' i meant
18:36:51 <wli> ski: I've no idea what Flip is supposed to be.
18:37:16 <ski> the corresponding thing to the 'flip' function, on the type level
18:37:19 <ski> @type flip
18:37:21 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:37:27 <ski> @src flip
18:37:27 <lambdabot> flip f x y = f y x
18:37:41 <ski> so if we say
18:38:07 <ski> newtype Flip f b a = MkFlip {unFlip :: f a b}
18:38:09 <ski> we get
18:38:19 <ski> Flip :: (* -> * -> *) -> * -> * -> *
18:39:01 <sgillespie> how can I import things in ghci?
18:39:10 <ski> MkFlip :: forall a b c :: *. f a b -> Flip f b a
18:39:17 <LoganCapaldo> sgillespie, :m +Module.Name
18:39:18 <ski> unFlip :: forall a b c :: *. Flip f b a -> f a b
18:39:21 <MarcWeber> ski: Is this used somewhere?
18:39:52 <ski> wli : now i want to make 'Flip' kind-polymorphic, instead of monomorphic in '*'
18:40:15 <wli> ski: AIUI such does not exist in Haskell.
18:40:15 <sgillespie> gotcha
18:40:16 <ski> MarcWeber : mayhaps in some libraries which also provide 'Comp', etc
18:40:18 <sgillespie> thanks
18:40:53 <LoganCapaldo> Wow, AIUI, haven't seen that one before
18:41:07 <wli> @vera AIUI
18:41:09 <lambdabot> *** "aiui" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
18:41:09 <lambdabot> AIUI
18:41:09 <lambdabot>      As I Understand It (telecommunication-slang, Usenet, IRC)
18:41:09 <lambdabot>  
18:41:10 <ski> wli : indeed .. however, i can't see any direct problem with allowing the argument kinds to be generalized ..
18:41:11 * LoganCapaldo puts AIUI in my back pocket for future use
18:41:35 <LoganCapaldo> well i figured it out
18:41:39 <ski> (wli : because 'Flip' only passes them on to 'f')
18:41:48 <LoganCapaldo> just never seen it abbreviated thusly
18:42:36 <ski> wli : currently, however, every datatype defined must have a result kind of '*' .. otherwise, how could we use the constructors (and deconstructors) on values (having types of kind '*', i remind) ?
18:43:44 * ski though have an idea for maybe solving this ..
18:45:01 <Toxaris> my computer just decided to reboot. maybe he is afraid of kind polymorphism?
18:45:59 * ski smiles
18:46:07 <mrd> you blew your computer's mind
18:46:46 <sgillespie> What structure could you all recommend for a symbol table?
18:47:08 <dmwit> Dunno, maybe Data.Map?
18:47:30 <sgillespie> I'm worried about the insert functions...they seem to update if the key already exists
18:47:56 <sgillespie> thus I would need to make a List to shadow names in different scopes
18:48:08 <ski> (if one were to start using higher-order types more, then lack of kind-polymorphism could prove quite annoying .. consider one version for 'Flip' for any combination of three kinds from '*','* -> *','* -> * -> *','(* -> *) -> *', ... !)
18:48:10 <sgillespie> I suppose thats good enough
18:48:58 * ski wonders whether one could make kind-polymorphic type classes, somehow ..
18:49:03 <dmwit> sgillespie: You could easily have a stack of Maps for the different namespaces.
18:49:21 <ski> (.. so i can have one 'Functor' class instead of one for every pair of kinds i find useful)
18:49:23 <dmwit> As for updating, I seem to remember functions of both types: updating and non-updating.
18:49:34 <sgillespie> i suppose that is the best option
18:49:54 <oerjan> sgillespie: use insertWith, which allows you to combine an already existing entry with the new one as you please
18:49:58 <dmwit> You could also use a trie, maybe?
18:50:26 <sgillespie> okay...this is getting interesting
18:50:42 <sgillespie> insertWith doesn't update if exists?
18:51:11 <Toxaris> sgillespie: you can provide your own function for combining the old and the new value
18:51:20 <Cale> sgillespie: It specifically uses the function you give it to combine the old and new value
18:51:29 <oerjan> sgillespie: use insertWith (flip const), i think
18:51:31 <Cale> er, Toxaris beat me to it :)
18:51:50 <oerjan> that ignores the new value if there is an old one
18:52:10 <oerjan> insert = insertWith const, which does the opposite
18:52:24 <Cale> insertWithKey f key value will insert (key, value) if it doesn't exist, and (key, f value oldValue) if it does
18:53:00 <sgillespie> i see
18:53:14 <Cale> er, f key value oldValue
18:53:31 <Cale> insertWith f key value will do what I originally said :)
18:53:53 <Cale> (the 'Key' means that it additionally passes the key in question to the combining function)
18:54:35 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html#5 :)
18:54:37 <lambdabot> http://tinyurl.com/uywvm
18:55:01 <sgillespie> I was actually looking at that
18:55:08 <sgillespie> good deal...
18:55:19 <sgillespie> the help is much appreciated
18:56:27 <sgillespie> i just realized that its not destructive, so I don't really care about updates
18:57:05 <desp> how would you best check if n consecutive elements of a list satisfy predicate p?
18:57:12 <Toxaris> I would use [Map Symbol [Entry]] instead of [Map Symbol Entry] to avoid searching for the same symbol in more then one Map
18:58:27 <Toxaris> hmm no nonsense, you can just copy the old map
18:58:36 <sgillespie> right
18:58:47 <Toxaris> no need to keep the shadowed definitions in two places
18:59:01 <sgillespie> awesome
18:59:29 <Toxaris> once again, nondestructive data structures win :)
19:00:37 <desp> *cough*
19:00:41 <desp> :)
19:01:11 <Cale> adjacents n xs = zipWith const (transpose . take n . tails $ xs) (drop (n-1) xs)
19:01:15 <Cale> anyRuns n p xs = any (all p) (adjacents n xs)
19:01:18 <Toxaris> desp: ?
19:01:33 <desp> ++Cale: did you just write that?
19:01:36 <Cale> yeah
19:01:42 <desp> unf
19:05:36 <dons> dcoutts: i note Igloo is moving to things depending on the bytestring package
19:05:38 <dons> is it ready ?
19:06:03 <dcoutts> dons: he's currently using the bytestring from the old base package
19:06:08 <oerjan> actually, that could be quite inefficient, since you could check each element for p n times
19:06:21 <dons> dcoutts: hmm? is that not darcs.haskell.org/bytestring ?
19:06:22 <Toxaris> > (\n p -> any ((>= n) . length) . group . map p) 2 even [1, 2, 3, 4, 5, 6]
19:06:24 <lambdabot>  False
19:06:34 <Toxaris> > (\n p -> any ((>= n) . length) . group . map p) 2 even [1, 2, 3, 1, 5, 6]
19:06:35 <lambdabot>  True
19:06:42 <dons> dcoutts: also, you wanted slides for the fusion talk? i've given one talk on it already, if you'd like those to start with
19:06:48 <dcoutts> dons: ie bytestring-0.8, so if we get bytestring-0.9 fixed up then we could move to that for ghc-6.8.0
19:06:55 <dcoutts> dons: ah, that'd be useful
19:07:07 <oerjan> Toxaris: that's better, but also detects runs of non-p's
19:07:07 <dons> so which package is bytestring-0.8 -- is that d.h.o/bytestring ?
19:07:22 <dcoutts> dons: no, that's d.h.o/packages/byestring
19:07:34 <Toxaris> oerjan: it actually does something for non-Boolean predicates too, wich may be good or not :)
19:07:37 <dons> ah so that's something else that's just been copied out of base?
19:07:42 <dcoutts> dons: yes
19:07:45 <dons> ok good
19:07:56 <dons> http://www/~dons/talks/streams-sapling-talk.ps.gz
19:08:01 <dons> www.cse.unsw.edu.au
19:08:08 <dcoutts> ta
19:08:10 <dons> now, the .tex is around here somewhere
19:08:19 <dons> you might want to look at beamer, rather than chaksem style, though
19:08:33 <dcoutts> dons: if you could email the .tex to me that'd be great
19:08:49 <dons> ok
19:09:13 <dcoutts> dons: oh wait
19:09:23 <dcoutts> dons: that's the bytestring talk
19:09:45 <dons> oh hmm. it is? ok. there's 2 others around here somewhere...
19:10:02 <dcoutts> dons: I've got the padl slides for that, I need up update them for list stream fusion for icfp
19:10:20 <dons> ah, www.cse.unsw.edu.au/~dons/talks/lists-streams-nothing-07.pdf
19:10:48 <dons> from Apr 19 07:13
19:10:55 <dcoutts> @arr that's the one
19:10:55 <lambdabot> I'll crush ye barnacles!
19:11:52 <oerjan> anyRuns n p = any ((==n).length) . map (take n) . filter head . group . map p
19:13:26 <Toxaris> oerjan: filter head is nice
19:13:31 <dons> dcoutts: sent the .tex
19:13:34 <ski> (s/forall a b c :: *./forall (f :: * -> * -> *) a b :: *./)
19:13:36 <Toxaris> oerjan: and map (take n) to be lazier?
19:14:06 <dcoutts> dons: thanks, those slides look pretty good, a great starting point for icfp.
19:14:35 <dons> yeah, should save some time anyway
19:14:42 <dcoutts> dons: I'll keep you posted with updates
19:14:53 <dons> ok. thanks.
19:15:08 <oerjan> yeah, except i just remembered any (not.null.drop(n-1))
19:15:19 <dcoutts> dons: I think I might include the proof of our fusion rule, it should fit on one slide
19:15:26 <dons> ah yes. that would be very nice.
19:15:31 <dons> so there's a couple of results like that since the paper
19:15:40 <oerjan> anyRuns n p = any (not.null.drop(n-1)) . filter head . group . map p
19:15:42 <dcoutts> dons: though of course credit to Jeremy
19:15:46 <dons> of course
19:15:57 <dcoutts> but it does make a nicer story
19:16:18 <dons> yeah.
19:16:32 <dcoutts> dons: the main thing to get our story straight on is the performance results for the tricky programs
19:16:45 <dons> right.
19:16:56 <dcoutts> dons: we need to be clear about why they fail, or at least what we know and what we do not know
19:17:05 <dons> so precise details abotu the concatMap nesting issue, and then degraded optimisations with multi-module compilation
19:17:14 <dons> rl likely knows more about this now too
19:17:18 <dcoutts> aye
19:20:35 <oerjan> @let anyRuns 0 _ = const True; anyRuns n p = any (not.null.drop(n-1)) . filter head . group . map p
19:20:38 <lambdabot> Defined.
19:21:37 <oerjan> > anyRuns 3 even [1,2,4,5,6,10]
19:21:39 <lambdabot>  False
19:21:53 <oerjan> > anyRuns 3 even [1,2,4,5,6,8,10]
19:21:54 <lambdabot>  True
19:25:47 <conal> @pl \ op a b c -> (a `op` b) `op` c
19:25:48 <lambdabot> (.) =<< (.)
19:25:54 <conal> pretty
19:26:06 <conal> @pl \ op a b c d -> ((a `op` b) `op` c) `op` d
19:26:06 <lambdabot> ap ((.) . (.) . (.)) ((.) =<< (.))
19:26:17 <conal> @pl \ op a b c d e -> (((a `op` b) `op` c) `op` d) `op` e
19:26:18 <lambdabot> ap ((.) . (.) . (.) . (.)) (ap ((.) . (.) . (.)) ((.) =<< (.)))
19:26:35 <conal> wow
19:27:01 <markluffel> is cabal-install usable?
19:28:19 <dons> i believe so, yes.
19:28:33 <dons> we've had only succesful reports so far, from a handful of people
19:29:49 <markluffel> dons: ok, thanks, i'm darcs get-ting it now, the dependency list of HAppS spooked me
19:30:34 <dons> yeah, if it works for happs, it should work for anything. to let us know how it goes
19:33:51 <shapr> cabal-install works for me, I use it lots.
19:35:20 <dcoutts> shapr: have you tried it with the latest cabal? if you do, send us patches! :-)
19:35:31 <dcoutts> shapr: we need more cabal-install cheerleading
19:35:39 <dcoutts> it needs more hackers polishing it
19:35:52 <shapr> I haven't tried it with the latest cabal version.
19:35:55 * shapr pulls
19:36:01 <sjanssen> dcoutts: do you know what it needs, specifically?
19:36:10 <sjanssen> I've had nothing but success using it
19:36:20 <dcoutts> sjanssen: oh, that's good to know
19:36:48 <dcoutts> sjanssen: there are half a dozen bugs open on it, perhaps they're fixed and the bug reports just need closing
19:37:11 <dcoutts> sjanssen: I recall things not working very smothly when installing as non-root
19:37:27 <dcoutts> and some of the paths where it installed stuff was a bit suspicious
19:37:28 <sjanssen> with the current trend towards small packages, I think we need a release of cabal-install
19:37:33 <sjanssen> with binaries!
19:37:55 <dcoutts> sjanssen: so are you the cabal-instal maintainer then? :-)
19:38:18 * dcoutts would be happy to anoint sjanssen as official cabal-instal maintainer
19:38:36 <sjanssen> ulll, I don't think I should do that :)
19:38:59 <dcoutts> ok, patch guard? release manager? :-)
19:39:16 <sjanssen> oh, I guess it does put things in slightly odd places.  $HOME/usr is the prefix
19:39:25 <dcoutts> and I think it might needs some adjustments now that configurations exist
19:40:07 <dcoutts> sjanssen: aye, I recall having some discussion a while ago with Igloo about putting everything under $HOME/.cabal/
19:40:26 <dcoutts> except for the bindir which should probably be $HOME/bin
19:40:35 <sjanssen> yeah, that sounds good
19:40:50 <dcoutts> and these configuration settings should probably be in a file in $HOME/.cabal/
19:41:44 <dcoutts> sjanssen: see the new InstallDirTemplates, that'd be a reasonable serialised format
19:43:00 <sjanssen> dcoutts: cabal-install might pick up some hackers if it had a public "not quite perfect" release
19:43:13 <dcoutts> sjanssen: go for it, make a release
19:43:54 <dcoutts> upload it to hackage and announce it on the libraries list
19:47:05 <balodja> What's the meaning of (>>=)-function in terms of category theory?
19:47:19 <newsham> hmm.. was there no video for peyton-jones' data parallelism talk at oscon2007?
19:47:54 <Binkley> newsham: apparently it's similar to the talk he gave at London HUG, which is online
19:47:57 <sioraiocht> @src (>>=)
19:47:57 <lambdabot> Source not found. My mind is going. I can feel it.
19:48:41 <pgavin> dcoutts: up late tonight?
19:48:52 <sioraiocht> hrm, i thought there was a general definition
19:48:56 <dcoutts> pgavin: erm yes :-)
19:49:00 <sioraiocht> is there a category theory version of bind?
19:49:03 <pgavin> lol :)
19:49:17 <dcoutts> pgavin: making Program work sanely
19:49:23 <pgavin> ah
19:49:44 <pgavin> I'm still trying to figure out how I'm going to get this make system working
19:49:46 <sioraiocht> balodja: I have no idea, and I guess neither does anyone else ;)
19:49:53 <pgavin> but its getting closer
19:50:00 <markluffel> "Non-empty library, but empty exposed modules list. Cabal may not build this library correctly"
19:50:01 <markluffel> when setup configure-ing cabal-install
19:50:07 <sioraiocht> @src (>>)
19:50:07 <lambdabot> m >> k      = m >>= \_ -> k
19:50:24 <markluffel> (cabal-install from head, ghc6.6)
19:50:26 <sioraiocht> @src (join)
19:50:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:50:31 <sioraiocht> @src id
19:50:32 <lambdabot> id x = x
19:51:03 <oerjan> x >>= f = join ( fmap f x )
19:51:07 <sioraiocht> yes
19:51:10 <sioraiocht> finally
19:51:27 <sioraiocht> I knew there was a way to define it in terms of join, lol
19:52:08 <balodja> and join x = x >>= id
19:52:27 <dcoutts> pgavin: good good :-)
19:52:29 <sioraiocht> @t (>>=)
19:52:29 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
19:52:37 <sioraiocht> @type (>>=)
19:52:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:53:01 <balodja> but that gives nothing to sense :(
19:53:12 <sioraiocht> balodja what do you mean?
19:53:25 <newsham> how come london gets a haskell users group?
19:53:28 <newsham> *hrumph*
19:53:49 <Binkley> newsham: nothing to stop you from starting one wherever you live :-)
19:53:55 <Binkley> Or if it's easier, move to London :-)
19:54:01 <pgavin> Binkley: I've been trying
19:54:03 <newsham> sure there is.  I'm lazy and impure.
19:54:09 <pjd> @let runlengths p = scanl (\c x -> if p x then c+1 else 0) 0; anyRuns n = elem n `dot` runlengths
19:54:09 <lambdabot> <local>:9:57:     Multiple declarations of `L.anyRuns'     Declared at: <loca...
19:54:10 <pgavin> Binkley: no one around here even knows what it is
19:54:12 <oerjan> balodja: return, join and fmap are the categorical notions for a monad
19:54:17 <Binkley> pgavin: where's that?
19:54:27 <pgavin> Binkley: Florida State University :/
19:54:28 <pjd> @let runlengths p = scanl (\c x -> if p x then c+1 else 0) 0; anyruns n = elem n `dot` runlengths
19:54:29 <balodja> sioraiocht: 'join' has a simple meaning. that's just natural transormation. but what about '>>='?
19:54:31 <lambdabot> Defined.
19:54:37 <oerjan> fmap is a functor, while return and join are natural transformation
19:54:39 <Binkley> pgavin: ah... well, you could teach Haskell to the alligators :-)
19:54:55 <pgavin> Binkley: actually, that's the other school... :)
19:54:56 <dcoutts> pgavin: aim to get something really small but testable working in an early phase, eg a simple case might be having only .hs files and knowing all the modules up front
19:54:57 <newsham> (also I dont know if there's another haskell user within 20 sq miles)
19:54:57 <sioraiocht> balodja: x >>= f = join (fmap f x)
19:55:01 <oerjan> >>= isn't used much in category theory i think, because one of its arguments is an _element_
19:55:11 <xtacy_> Hi ... what is the best place to start off with Monads? I tried looking at Wikipedia, but the first line took me off from: Monads -> Category Theory -> Groups! :(
19:55:14 <sioraiocht> where fmap is a concept of Functors
19:55:22 <Toxaris> > let anyRuns p n = any (== 0) . scanl f n where f m x = if p x then m - 1 else n in anyRuns even 3 [1, 3, 4, 2, 0, 5]
19:55:24 <lambdabot>  True
19:55:28 <sioraiocht> xtacy_: what's your background?
19:55:29 <dcoutts> pgavin: testing designs against reality early helps with getting a good design :-)
19:55:42 <Binkley> newsham: you could try walking around with a sandwich board that says "Monads Save, Ask Me How"
19:56:00 <pgavin> dcoutts: right...  I haven't written much code yet though
19:56:15 <balodja> oerjan: look this: (=<<) = flip (>>=); type of (=<<) is (a -> m b) -> (m a -> m b)
19:56:16 <xtacy_> sioraiocht, I am doing Computer Science and Engineering. with Theoretical background in Formal Languages, Automata. Not anything in Group theory
19:56:30 <sioraiocht> @where aam
19:56:31 <lambdabot> http://www.nomaware.com/monads/
19:56:39 <sioraiocht> xtacy_: start there
19:57:04 <newsham> I dont think they take kindly to side-effect ascetics around here
19:57:26 <dcoutts> pgavin: no problem, eg perhaps start with ndm's make code extended with the dynRequires idea, using actual .dep files and call ghc -M to generate them.
19:57:39 <oerjan> balodja: right - that could work, lessee
19:57:50 <sioraiocht> xtacy_: http://www.haskell.org/all_about_monads/html/
19:57:51 <lambdabot> Title: All About Monads
19:57:59 <xtacy_> sioraiocht: Thanks!
19:58:04 <shachaf> @where+ aam http://www.haskell.org/all_about_monads/
19:58:05 <lambdabot> Done.
19:58:27 <sioraiocht> xtacy_: it seems different ways of explaining it worked for me
19:58:29 <pgavin> dcoutts: every time I get 20 or 30 lines of code I end up not liking where it's going :/
19:58:29 <oerjan> (=<<) f = \x -> join (fmap f x)
19:58:54 <xtacy_> sioraiocht: The other website isnt responding now ...
19:59:10 <sioraiocht> xtacy_: the haskell.org one is what you want, anyway
19:59:42 <dcoutts> pgavin: I think the prototype idea that ndm and I cam up with is a good place to start, it reqires knowing all the modules up front, but that's a limitation that can be lifted later
19:59:53 <xtacy_> sioraiocht: That seems to be a good thing to read... So its monad time from now on :D
19:59:54 <oerjan> (=<<) f = join . fmap f
20:00:21 <dcoutts> pgavin: it looks like it ought to be not too hard to extend ndm's code to support dynRequires, and then the .dep scheme can be implemented on top of that
20:00:31 <sioraiocht> xtacy_: I didn't really understand monads until I had to write some of my own
20:00:43 <sioraiocht> and now I'm trying to understand arrows
20:00:53 <oerjan> balodja: that's a purely categorical definition
20:00:53 <njbartlett> newsham: London gets a Haskell user group because somebody thought "ooh why not start a user group"... sent out a couple of emails and boom, there's a user group. I believe the formula could work in other population centres ;-)
20:01:18 <newsham> still *hrumph*ing
20:01:28 <markluffel> shapr: how did you build cabal-install?
20:01:29 <Korollary> Just like SeaFunc where people who show up don't really know FP languages.
20:01:37 <MarcWeber> njbartlett: Not here in Pfaffenweiler :-)
20:01:47 <LoganCapaldo> SeaFunc?
20:02:00 <njbartlett> MarcWeber: Is Pfaffenweiler a population centre?? ;-)
20:02:19 <pgavin> dcoutts: I actually think I want to take a different approach, though
20:02:21 <Korollary> LoganCapaldo: http://tech.groups.yahoo.com/group/SeaFunc/
20:02:23 <lambdabot> Title: SeaFunc : SeaFunc
20:02:25 <LoganCapaldo> Haskell User Group has a friendly acronym
20:02:50 <LoganCapaldo> "At this week's HUG meeting we'll show you how to use hugs"
20:03:03 <Korollary> Heh. A search engine's nightmare.
20:03:07 <dcoutts> pgavin: you mean integrating the dep chasing and the build code or something else entirely?
20:03:15 <pgavin> dcoutts: yeah
20:03:32 * shachaf has considered going to SeaFunc.
20:03:39 <pgavin> dcoutts: but I've also got an idea for extending things and stuff as well
20:03:47 <njbartlett> You want a real search engine nightmare, try Wadler's "links" language
20:03:53 <dons> dcoutts: oh, benl wrote `new register allocator' for ghc's backend...!
20:04:15 <dcoutts> dons: I know! :-) you didn't make it to AngloHaskell (of course)
20:04:26 <Cale> xtacy_: I wrote a couple of tutorials you might like.
20:04:31 <pgavin> dons: nice, does that mean we get dynamic libs?
20:04:33 <LoganCapaldo> Use links to search for info about links while riding a lynx
20:04:34 <dcoutts> pgavin: feel free to jot your ideas down on the wiki page
20:04:39 <pgavin> dcoutts: ok
20:04:59 <dcoutts> pgavin: that's a different SoC project to do dynamic libs, the register allocator is for better performance
20:05:04 <dons> dcoutts: oh, is he over in the UK?
20:05:14 <dcoutts> dons: at MSR
20:05:16 <dons> ah!
20:05:17 <pgavin> dcoutts: oh, I figured that might be part of it
20:05:19 <dons> now it makes sense.
20:05:24 <dons> so he's abandoned Canberra.
20:05:25 <Korollary> njbartlett: yeah that's a bad name. It's their nightmare, imho.
20:05:29 <oerjan> balodja: another thing is to look at the kleisli category, whose composition is f >>> g = \b -> f b >>= g
20:05:32 <dons> that also explains why he'll be at the hackathon
20:05:57 <xtacy_> Cale: Could you paste the links here? I will try them out and give feedback
20:05:57 <dons> dcoutts: we need to get his effect inference pass into a standalone tool to infer purity of FFI code .
20:05:59 <Cale> xtacy_: http://www.haskell.org/haskellwiki/Monads_as_Containers http://www.haskell.org/haskellwiki/Monads_as_computation http://www.haskell.org/haskellwiki/Introduction_to_IO
20:06:01 <newsham> readFile >>> arr lines
20:06:01 <lambdabot> Title: Monads as containers - HaskellWiki
20:06:35 <Cale> xtacy_: The third is just a very short intro on how I/O works in Haskell, without any generality about monads. (But it's one example)
20:06:41 <dcoutts> dons: and the cmm CPS pass project just finished and the qc-- guy is also visiting MSR is going to pick that up and make it work properly and do some heavy data flow stuff
20:07:00 <dons> http://www.thenewsh.com/%7Enewsham/formal/reverse/ looks nice
20:07:01 <olliej> dcoutts: dons: either of you aware of any decent papers on the actual implementation of type inference?
20:07:02 <lambdabot> Title: Formal methods: Reverse
20:07:07 <Cale> The second gives a wide overwiew of what is perhaps the most commonly taken view on how monads are to be used in programming.
20:07:09 <dons> dcoutts: sweet. so backend stuff!
20:07:18 <dons> olliej: the 'typing haskell in haskell' paper is standard
20:07:27 <xtacy_> Cale: I haev three websites now :) I think I will start with the shorter ones
20:07:33 <dcoutts> dons: yeah, loads of action in that area now and in the medium term
20:07:33 <olliej> dons: cheers
20:07:46 <dcoutts> dons: infering purity of ffi? how can one do that? not looking in the C side I hope.
20:07:51 <olliej> dons: /me is planning on rewriting his compiler in a nicer language
20:07:51 <Cale> The first gives what I think is a pretty accessible approach. One which is a little offbeat, but often quite useful as well.
20:07:59 <olliej> dons: eg. not c#
20:08:17 <dcoutts> olliej: and there's a nice paper on generalising HM type inference
20:08:23 <dcoutts> @google generalising HM type inference
20:08:25 <lambdabot> http://www.cs.uu.nl/research/techreps/repo/CS-2002/2002-031.pdf
20:08:33 <olliej> dcoutts: cheers
20:08:42 <dons> dcoutts: just using the FFI primops, not actually foreign calls
20:08:49 <dons> (peek/poke as a unsafe ST monad)
20:08:59 * olliej has given up on ghc as a front end for his compiler
20:09:12 <timthelion> what is haskells equivalent of C's switch?
20:09:16 <dons> the effect inference stuff in benl's compiler can infer the effects, and give results for what effects leak out
20:09:19 <dons> timthelion: 'case'
20:09:23 <dons> http://programming.reddit.com/info/2fanz/comments
20:09:23 <wli> timthelion: case
20:09:24 <lambdabot> Title: Proving Haskell programs correct with QuickCheck and Isabelle/HOL (reddit.com)
20:09:27 <dcoutts> dons: ah ok, though presumably all the cases where we cannot use ST are due to indexing sublteties.
20:09:43 <dons> yeah, I think so
20:09:49 <Cale> Does anyone have any experience using convertfs?
20:10:06 <dons> we don't even attempt to use ST, though it probably works just fine for an awful lot of things
20:10:08 <dcoutts> dons: so automaic inference for that would be very hard I think
20:10:18 <glen_quagmire> is anyone working on Haskell QT ?
20:10:22 <dcoutts> dons: it's because of those damned ForeignPtrs
20:10:25 <glen_quagmire> QT as in gui library
20:10:31 <dons> so it woud be interesting to note down what superset of ST is needed
20:10:46 <dcoutts> dons: I think we could do all of ByteString in ST
20:10:56 <glen_quagmire> oh it seems to be soc 2007
20:10:59 <dcoutts> dons: for Binary we'd need some extensions
20:11:00 <dons> i suspect so, maybe with some of our own ops though
20:11:07 <shapr> markluffel: First I installed cabal, then I built cabal-install?
20:11:13 <timthelion> hmm, I don't want a switch statement though do I,
20:11:17 <newsham> uh oh, I got redditted.
20:11:30 <newsham> blah, I may need to mirror this somewhere
20:11:31 <dcoutts> dons: aye, and using non-pinned arrays
20:11:33 <shapr> markluffel: Are you having problems?
20:11:39 <dons> newsham: :)
20:11:42 <dons> great stuff.
20:11:47 <dons> i wish people wrote more about these topics
20:12:21 * timthelion is trying to do if n is 0 do x, if n is between o and p do y if n is p do z if n is between p+1 and f do zz if n is f do zzz
20:12:27 * shapr looks at newsham's post
20:12:31 <dcoutts> dons: we should have a survey of libraries@haskell.org people on the advantages of ForeignPtr vs non-pinned arrays
20:12:43 * xtacy_ goes off Monading
20:12:43 <shapr> oooh pretty!
20:12:53 <oerjan> timthelion: you may want guards
20:13:02 <dcoutts> dons: especially if we can demonstrate some good results for common cases of small strings
20:13:24 <dons> dcoutts: hmm. yes. i think we need stream fused bytestring 1.0 out first. but then we need to work out numbers for small strings v big strings, and so on
20:13:32 <dcoutts> dons: yes 1.0 first
20:13:47 <yetAnotherOne> i have two modules and i want to make a data construtor from the second one visible through the first
20:14:38 <timthelion> oerjan: gaurds is that | thing that I don't get yet?
20:14:39 <oerjan> case n of 0 -> x ; _ | n >= o && n <= p -> y | n == p -> z ...
20:15:05 <timthelion> ok
20:15:12 <oerjan> timthelion: you could also use if then else if that suits you better
20:15:38 <timthelion> oerjan: I find an if then else ifelse ifelse to be clunky
20:15:48 <timthelion> I mean elseif
20:16:04 <glguy> haskell doesn't have "elseif"
20:16:17 <glguy> if a then b else if c then d else e
20:16:25 <timthelion> glguy: but it has the structure
20:16:38 <ski> @help spell
20:16:38 <lambdabot> spell <word>. Show spelling of word
20:16:52 <ski> @spell guarranteed
20:17:00 <glguy> guaranteed ?
20:17:03 <oerjan> guards are less clunky than that, yes, but if you need to branch inside the "then" guards can become less nice
20:17:31 <ski> glguy : ty, wasn't sure whether 'spell' was broken, or just wouldn't respond in private
20:17:47 <glguy> @got
20:17:47 <lambdabot> Maybe you meant: ft ghc let vote yow
20:17:54 <glguy> @yow
20:17:54 <lambdabot> Isn't this my STOP?!
20:18:20 <Binkley> @quote
20:18:20 <lambdabot> tennin says: [very #haskell] anyone know of any good books/papers on the application of category theory to databases?
20:18:51 <newsham> dons: can you post that the page can be viewed at http://users.lava.net/~newsham/formal/reverse/ ?
20:18:58 <timthelion> so oerjan what is the ; _ | in your code?
20:19:02 <lambdabot> Title: Formal methods: Reverse
20:19:11 <newsham> I put in a small page that points to that page, but even that could tax my server if the hits get high enough
20:19:31 <markluffel> shapr: yeah, i'm having problems
20:19:34 <pgavin> dcoutts: I actually just had another idea...
20:19:36 <njbartlett> glen_quagmire: A QT binding would be interesting, but I think most of the focus in terms of GUI libs is going into Gtk and wxWidgets.
20:19:37 <oerjan> yetAnotherOne: you add Type (Constructor) to the first module's export list
20:19:46 <pgavin> dcoutts: doesn't cabal have some support for generating makefiles?
20:19:50 <yetAnotherOne> thanks
20:19:54 <shapr> markluffel: What problems?
20:19:59 <markluffel> shapr: message was: " Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly"
20:20:08 <markluffel> on Setup.hs configure
20:20:20 <dcoutts> pgavin: yes, though only for ghc and only for libraries that use ghc's makefile scheme
20:20:31 <oerjan> timthelion: guards need to be on a pattern but in this case the pattern can be a trivial _ which always matches
20:20:34 <dcoutts> pgavin: it's only there as a hack for the sake of ghc until cabal does it properly
20:20:55 <glen_quagmire> njbartlett: http://hackage.haskell.org/trac/summer-of-code/ticket/1116
20:20:58 <lambdabot> Title: #1116 (Haskell Qt binding generator) - Haskell.org Google Summer of Code - Trac
20:21:02 <dcoutts> pgavin: as soon as cabal does it itself we'll remove the ghc makefile code
20:21:13 <oerjan> since the case statement is used only for the guards (except the 0 case)
20:21:14 <pgavin> dcoutts: ah, ok, that's what I wanted to know
20:21:51 <njbartlett> glen_quagmire: Looks like that one wasn't accepted, so nobody's working on it?
20:21:58 <glen_quagmire> oh sorry
20:22:17 <glen_quagmire> !lart glen_quagmire
20:22:36 <shapr> markluffel: Did you build and install the latest cabal?
20:22:49 <dons> newsham: done.http://programming.reddit.com/info/2fanz/comments/c2farc?context=5
20:22:51 <lambdabot> Title: Proving Haskell programs correct with QuickCheck and Isabelle/HOL (reddit.com), http://tinyurl.com/23zwal
20:23:02 <markluffel> shapr: nope, but that i will do
20:23:26 <njbartlett> Choosing a GUI library to use with Haskell is really confusing... but it's the same with practically every other language out there (with the exception of things like C# where you use the library that MS tells you to use, or else)
20:23:46 <markluffel> shapr: latest meaning the head (or whatever darcs calls that) of the repository, or a specific release?
20:23:56 <newsham> danke
20:23:58 <glen_quagmire> maybe do things in haskell and gui in other language
20:24:07 <glen_quagmire> probably through socket
20:24:08 <dcoutts> no, guis in Haskell are nice
20:24:22 <dcoutts> aargh no! sockets is much much worse
20:24:36 <dcoutts> gtk2hs and wxhaskell have compartively nice apis
20:24:47 <njbartlett> dcoutts: Agreed, Phooey looks like a really nice abstraction
20:25:04 <dcoutts> right, and high level ones are even nicer
20:25:10 <Shimei> And to confuse things further I'm uploading yet another GUI library to Hackage right now. ;)
20:25:27 <dcoutts> Shimei: oh yes? what's that then?
20:25:52 <glen_quagmire> i bet tk binding
20:26:07 <Shimei> dcoutts: It's PropLang, ndm's pet library. The one that sits on top of Gtk.
20:26:14 <dcoutts> but even our existing mid level gui libs have ok apis compared to talking to another imperative gui lib on the other side of a socket
20:26:21 <dcoutts> Shimei: oh yes, cool
20:26:24 <Shimei> I did get the old tk binding working again though, as an aside.
20:26:30 <glen_quagmire> ah i see
20:26:45 <Shimei> But I haven't uploaded it anywhere. I was trying to contact the original maintainer.
20:26:53 <dcoutts> Shimei: are you ndm's SoC student?
20:26:59 <Shimei> dcoutts: Yes.
20:27:08 <dcoutts> cool, how's it going?
20:27:34 <njbartlett> Shimei: I'd like to try your tk binding...
20:27:39 <Shimei> It's going alright. I'm uploading stuff to Hackage so I can do a 0.1 release.
20:27:59 <dcoutts> great, release early release often :-)
20:28:28 <dcoutts> Shimei: so we'll see guihaskell on hackage in the not-too-distant future then? :-)
20:28:48 <Shimei> The SoC deadline is coming up soon though, and there are some things I'd like to implement which I haven't yet. I think I'll just keep working on those after the SoC for fun.
20:28:53 <njbartlett> Shimei: 
20:29:08 <Shimei> dcoutts: Yes, I should be sending an e-mail to that effect in... a bit now.
20:29:14 <dcoutts> cool
20:29:15 * glguy can see those japanese? characters
20:29:21 * Cale crosses his fingers. Running convertfs on his large, only-partially-backed-up disc.
20:29:21 <glguy> shame I can't *read* them
20:29:41 <Shimei> njbartlett: :)
20:29:48 <njbartlett> I'm asking Shimei if he's Japanese. At least I think I am ;-)
20:29:50 * sorear briefly wonders what a English question mark is doing after a Japanese sentence
20:30:06 <Binkley> magic computer, writes in any language
20:30:09 <glguy> sorear: that is a *double wide* question mark
20:30:16 <glguy> sorear: clearly a japanese character ;)
20:30:20 * oerjan never knows if people are speaking in another alphabet or just very confused
20:30:32 <njbartlett> Shimei: Cool, I'm in Japan at the moment... wondered if there were any other Haskellers around
20:30:34 <shapr> markluffel: yes
20:31:02 <sorear> !
20:31:15 * sorear types random characters in a random alphabet
20:31:15 <glguy> its all greek to me
20:31:31 <olliej> glguy: that was baaad :D
20:32:07 <njbartlett>  !
20:32:14 <njbartlett> :-)
20:32:20 <Cale> haha
20:32:52 <Shimei> njbartlett: Actually, I'm Japanese but I'm in the USA. Soon to be in Canada. :p
20:33:05 <shapr> How many Haskellers in the Southeast USA?
20:33:09 <shapr> er, #haskellers
20:33:31 * geezusfreeek is in huntsville, alabama
20:33:34 <Binkley> shapr: pgavin was just mentioning being in Florida
20:33:48 <pgavin> lol
20:33:50 <pgavin> at least 1
20:34:09 <Cale> -rw-------  1 root root 160039239680 2007-08-14 23:17 fsimage
20:34:26 <njbartlett> Shimei: I see! Then my search continues...
20:34:34 <shapr> Cale: Um, that's big
20:34:36 <pgavin> Cale: rm -f fsimage
20:34:45 <Cale> pgavin: noooooo...
20:34:48 <shapr> 160gb?
20:34:50 <Cale> yeah
20:34:51 <Korollary> Cale: Computing E8 polynomials?
20:35:05 <Cale> I'm fsconverting.
20:35:15 <wli> From what to what?
20:35:21 <shapr> For the moment I have about 500gb in this box.
20:35:23 <Cale> reiser4 back to ext3
20:35:31 <shapr> I like ext3
20:35:39 <wli> Cale: I'd recommend xfs, but anyway.
20:35:45 <Cale> It's just too much hassle to keep patching my kernel over and over.
20:35:49 <shapr> Why xfs?
20:35:55 <pgavin> oblig: if you use reiserfs... you're supporting murder!
20:35:56 * glguy really liked Rieser4 when he used gentoo
20:36:01 <glguy> portage *flies* on reiser4
20:36:21 <Cale> I'd rather just use the kernel images provided with my distribution.
20:36:25 <wli> shapr: I have a vague idea of how the data structures and algorithms work on ext3 vs. xfs and vastly prefer those for xfs.
20:36:25 <pgavin> reiser3 was too buggy, I quit using it & went back to ext3
20:36:31 <pgavin> lost some files to it :/
20:36:38 <Cale> reiser4 was very nice apart from that
20:36:55 * glguy wasn't worried about losing files because all that was on his reiser4 partition was portage
20:37:07 <shapr> wli: Hm, interesting
20:37:16 * sorear would have thought portage was gcc-bound
20:37:22 <geezusfreeek> i haven't heard much about the reiser murder case... has it developed/concluded?
20:37:26 <sorear> Cale: the -h option to ls is handy
20:37:42 <geezusfreeek> sorry, just googling
20:37:46 <glguy> sorear: that's only when you are actually building from source
20:37:48 <wli> shapr: ext3 is based on ancient block radix tree crap; xfs is B+ trees everywhere.
20:38:00 <glguy> sorear: updating your portage tree is speed up
20:38:20 <Binkley> geezusfreeek: I thought this was pretty much the last word on that - http://geekz.co.uk/lovesraymond/archive/so-i-married-a-kernel-programmer
20:38:22 <wli> shapr: B+ trees of extents, that is.
20:38:25 <ski> (oerjan,balodja : 'return' and '(=<<)' is another categorical formulation of a monad (called the 'Kleisli' one, iirc), yes)
20:38:28 <lambdabot> Title: Everybody loves Eric Raymond  So I married a Kernel Programmer, http://tinyurl.com/jlbjp
20:39:06 <sorear> wli: How is that better?  The radix trees used by ext3 are dense, so they are always optimally shallow, unlike B+-trees
20:39:13 <wli> shapr: IOW xfs is vaguely modern. ext3 is essentially a legacy design going back to the 1970's.
20:39:48 <glguy> xfs: I'd never heard that xfs was ideal for anything but HUGE files, have you found it to be generally faster? more stable?
20:40:03 <Cale> (of course, that 160GB image is a sparse file)
20:41:09 <Korollary> @seen xfs
20:41:11 <lambdabot> I haven't seen xfs.
20:42:13 <shapr> Looks like Hans will be tried for murder anyway.
20:43:06 <oerjan> @remember DerekElkins What people need to do is stop reading two page blog posts by someone who's "just got" monads and read the well-written peer-reviewed papers by the people who clearly know what they are talking about.
20:43:06 <lambdabot> Done.
20:43:19 <Binkley> but, but, papers are hard
20:43:21 <Binkley> let's go shopping
20:44:09 <ray> s/papers/monads/
20:44:20 <ray> and you've got a new haskell slogan
20:44:29 <Binkley> I think that writing about monad tutorials is the new writing monad tutorials.
20:44:38 <Cale> heh
20:45:03 <Cale> What we need are monad tutorial transformers.
20:45:05 <balodja> ski: where to read about category backgrounds of this formulation?
20:45:16 <Cale> So that we can compose the features of monad tutorials
20:45:40 <lament> ugh
20:45:47 <Korollary> Or monad anti-tutorials.
20:45:48 <oerjan> @remember Cale What we need are monad tutorial transformers. // So that we can compose the features of monad tutorials
20:45:48 <lambdabot> Done.
20:46:01 <ray> cotutorials?
20:46:09 <Binkley> the monad that can be explained is not the true monad
20:46:18 <ray> that, uh, help you forget about monads or something
20:46:19 <Korollary> There is no monad, Neo.
20:46:32 <dons> newsham: are you using Isabelle at work now?
20:46:46 <pjd> Cale: or monad tutorial tutorials
20:46:52 <balodja> Korollary: Follow the natural transformation? :)
20:47:01 <Cale> Yeah, "How to write a good monad tutorial"
20:47:03 <pjd> how to write a monad tutorial that doesn't suck
20:47:19 <dons> i think we need to encourage some comonad, arrow and applicative tutorials plz?
20:47:34 <pjd> dons: yes!
20:47:37 <geezusfreeek> yes yes yes
20:47:38 <ray> seconded on the comonad one at least
20:47:42 <dons> _noone_ has written on applicatives yet
20:47:48 <Cale> dons: Look through my reddit comments and copy & paste :)
20:47:52 <dons> and they're more widely used than comonads and arrows too i suspect
20:47:57 <geezusfreeek> yeah. i don't know anything about applicatives yet!
20:47:57 <ski> balodja : hrm, i dunno .. i proably saw it in some unspecified paper possibly related to haskell ..
20:47:58 <Cale> (at least on comonads)
20:48:04 <oerjan> also, functor tutorials
20:48:08 <Cale> I think I have almost a whole tutorial there somewhere :)
20:48:11 <oerjan> to complete the set
20:48:24 <geezusfreeek> or i might without realizing
20:48:26 <dons> dcoutts: you should start your blog with a big bang: the worlds first tutorials on applicative functors, using data.binary and rewrite rules :)
20:48:45 <sjanssen> dcoutts has a blog?!
20:48:49 <dcoutts> not yet
20:48:51 <dons> he should have one. :)
20:48:53 <Cale> geezusfreeek: They're just monads, but without bind, and with ap.
20:48:54 <dcoutts> :-)
20:48:55 <balodja> ski: anyway, great thanks for info
20:48:57 <pjd> geezusfreeek: if you know ap and fmap, you know applicative functors
20:48:59 <dons> since he has such interesting notions!
20:49:06 <geezusfreeek> oh, yay, i'm good then
20:49:10 <lament> i think the "how to write a good monad tutorial" suggestion arises so commonly that we should consider a "how to write a how to write a good monad tutorial tutorial"
20:49:10 <dons> and we're all fans of notions round here
20:49:16 <dcoutts> @arr!
20:49:16 <lambdabot> Yeh scurvy dog...
20:49:21 <Cale> geezusfreeek: Not every applicative is a monad though.
20:49:24 <encryptio> :T ap
20:49:27 <encryptio> :t ap
20:49:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:49:30 <Cale> (but every monad is an applicative functor)
20:49:34 <sjanssen> i can has dcoutts blag post nao plz?
20:49:37 <geezusfreeek> lament, ooh, that's very meta
20:49:51 <pjd> so applicative functors sit halfway between functors and monads
20:50:01 <ray> the thing about being meta is that once you start, there's nowhere to stop
20:50:15 <dons> even Igloo has a pseudo-blog. well, an article on the web.
20:50:27 <lament> ray: you caould arbitrarily choose to stop at meta meta meta meta meta.
20:50:29 <oerjan> indeed, what about omega^2 monad tutorials?
20:50:42 <geezusfreeek> ray, let's hope we never get into metatypes then
20:50:55 <ski> balodja : '(=<<)' (often pronounced 'extend', with '(f =<<)' sometimes written 'f^*' and 'f =<< m' sometimes written 'f * m') converting a morphism from 'A' to 'M B' into a morphism from 'M A' to 'M B', where 'M' is the monad functor
20:51:03 <oerjan> geezusfreeek: they're called kinds
20:51:06 <ray> you could meta-arbitrarily choose to stop when you feel it would be the most arbitrary-seeming
20:51:24 <encryptio> what seperates an applicative functor and a plain-ol' functor?
20:51:29 <geezusfreeek> oerjan, my understanding, though, is that you can't really meta over kinds in a useful way
20:51:42 <Cale> What about monad (Kleene's ordinal)-tutorials?
20:51:54 <balodja> ski: Kleisli star, yeah, I've just found about it.
20:51:55 <Cale> That's uncomputably meta
20:52:07 <pjd> encryptio: they additionally have pure/return
20:52:10 <oerjan> @src Applicative
20:52:11 <lambdabot> class Functor f => Applicative f where
20:52:11 <lambdabot>     pure  :: a -> f a
20:52:11 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
20:53:38 <ski> @kind []
20:53:40 <lambdabot> * -> *
20:54:04 <Cale> @kind RWST
20:54:06 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
20:54:26 <ski> we need more higher-order type constructors !
20:54:34 <encryptio> @kind StateT
20:54:36 <lambdabot> * -> (* -> *) -> * -> *
20:54:40 * pjd wonders why lolcats seems to be so popular with Haskellers
20:54:50 <ski> still only second-order
20:54:57 <Binkley> lolcats are popular with *everyone*
20:54:59 <Cale> pjd: All your base are belong to us.
20:55:04 <ski> pjd : pardon ?
20:55:14 <encryptio> i'm just trying to grok the kind
20:55:23 <ray> higher-order lolcats
20:55:45 <Cale> encryptio: the (* -> *) parameter is the monad it takes
20:56:03 <Cale> encryptio: the other parameters are supplementary types (the state type, for instance)
20:56:24 <Cale> oh, and the last one is the result type
20:56:27 <ski> 'StateT Int IO String' is the type of actions returning strings, possibly doing IO, and also possibly reading and writing a separate 'Int' state
20:56:39 <Cale> really, you should read the * -> * at the end as being the result
20:56:54 <Cale> StateT :: * -> (* -> *) -> (* -> *)
20:57:20 <ski> 'StateT Int [] String' is the type of actions that can read the state, and output zero or more alternative results, each with a string and a possibly updated state
20:58:07 * ski still wonders what a 'lolcat' might be
20:58:25 <oerjan> @go lolcat
20:58:27 <lambdabot> http://icanhascheezburger.com/
20:58:27 <lambdabot> Title: I CAN HAS CHEEZBURGER?
20:58:28 <ski> mayhaps a "lolli-category", i.e. a linear category ?
20:58:40 <shapr> I do love icanhascheezburger.
20:58:56 <shapr> Today's were particularly good.
20:59:57 <dons> ?go serious cat
20:59:58 <lambdabot> http://www.allposters.com/-sp/Serious-Cat-Posters_i1234643_.htm
20:59:58 <lambdabot> Title: Serious Cat Pre-Matted Print at AllPosters.com
21:00:03 <dons> hah
21:00:03 <pjd> <sjanssen> i can has dcoutts blag post nao plz?
21:00:12 <pjd> ski: lolcatese -^
21:00:23 <dons> that's not serious cat!
21:00:25 <dons> imposter!
21:00:25 <sjanssen> shapr: I really enjoyed bourgeoisie cat
21:00:36 <dons> ?go serious cat lolcat
21:00:38 <lambdabot> http://icanhascheezburger.com/2007/01/11/this-is-relevant-to-my-interests/
21:00:38 <lambdabot> Title: I CAN HAS CHEEZBURGER?  Blog Archive This is relevant to my interests 
21:00:48 <Cale> it iz monadurday yet?
21:00:58 <shapr> haha
21:01:00 * ski for some reason comes to think of 'Hello Cthulhu'
21:01:04 <shapr> sjanssen: I liked traffic cat.
21:01:14 <Binkley> traffic cat was eerie
21:01:37 <pgavin> @type filter
21:01:43 <lament> @quote lol
21:01:45 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:01:45 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
21:02:56 <shapr> Do want: http://www.pragmaticprogrammer.com/titles/ctelec/index.html
21:02:58 <lambdabot> Title: Essential Electronics for Software Folk
21:03:22 <Cale> http://icanhascheezburger.files.wordpress.com/2007/08/teh-new-impruved-cat-wih-reactive-armor-me-be-testing-reactive-armor-now.jpg
21:03:24 <lambdabot> http://tinyurl.com/2nzpyy
21:03:47 <dons> ok, weirdest spam subject line ever: `Please read the Epistle to the Implementors before implementing brainfuck'
21:03:52 <dons> ok.. sure.
21:04:13 <shapr> haha
21:04:15 <dons> i'll hold off a while on that brainfuck interpreter then.
21:04:31 <sorear> they've been using disociated-press for months now
21:04:44 <Binkley> hmm, I got spam with the subject line "The first argument type and second argument type must be the same.<font size="3">"</font>
21:04:57 <dons> interesting.
21:05:01 <shapr> I think they just steal blog text.
21:05:11 <shapr> @users
21:05:12 <lambdabot> Maximum users seen in #haskell: 385, currently: 331 (86.0%), active: 23 (6.9%)
21:05:13 <oerjan> dons: wow
21:05:33 <shapr> I also liked "Who brot dis into mah house?"
21:05:35 <sorear> Binkley: Haha, haskell sourcced I wonder?
21:05:59 <ski> sorear : disociated-press ?
21:06:02 <oerjan> http://esoteric.sange.fi/ENSI/bf-implementors-epistle.html
21:06:03 <lambdabot> Title: The Epistle to the Implementors.
21:06:46 <sorear> ski: the canonical member of a class of programs which generate text with similar lexical properties to an existing corpus
21:07:01 <shapr> dcoutts: Does the latest cabal break cabal-install?
21:07:09 <shapr> Sure looks like it.
21:07:23 <shapr> src/Network/Hackage/CabalInstall/Install.hs:29:7: \n Could not find module `Distribution.SetupWrapper':
21:07:42 <ski> sorear : i've heard of it somewhere before .. is there some common implementation (e.g. in emacs) of it ?
21:08:00 <oerjan> that must be the first time i actually got something that interested me from spam...
21:08:12 * shapr checks to see if he has all the latest patches...
21:08:17 <sorear> ski: yeah, it's in the standard image and bound to M-x dissociated-press or some spelling variation thereof
21:09:10 <shapr> Same error :-(
21:20:26 <encryptio> is it just me or is there absolutely no support for file locking?
21:20:44 <bos> hm?
21:21:32 <bos> depends on what kind of locking you have in mind.
21:21:33 <encryptio> a la flock(2)
21:21:50 <encryptio> or its equivalent via fcntl (on the systems without flock())
21:21:53 <bos> the standard requires single-writer semantics, at least within a single process.
21:21:55 <mrd> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-IO.html
21:21:57 <lambdabot> http://tinyurl.com/2yjzc2
21:22:16 <bos> and what mrd said, too.
21:22:52 <oerjan> it is recommended in the report that implementations lock automatically, but i recall ghc doesn't actually do it
21:23:01 <bos> it does.
21:23:03 <mrd> they do
21:23:13 <mrd> it comes up weirdly with lazy IO too
21:23:22 <oerjan> hm, where did i read the opposite?
21:23:24 <mrd> try using readFile then writeFile sometime
21:23:40 <oerjan> perhaps it was Hugs
21:25:27 <dons> encryptio: look in the unix package, in System/Posix/IO for a whole LockFile framework
21:25:47 <encryptio> got it (multiple times =p)
21:26:02 <dons> ah ok yes
21:26:51 <bos> do people ever use Data.List.lookup?
21:27:01 <sorear> Yes :(
21:27:14 <bos> bleurgh.
21:27:42 <sjanssen> come now, Data.List.lookup is a perfectly fine function
21:28:00 <dons> for list with < 10 items :)
21:28:28 <Korollary> nub is equally wonderful
21:28:30 <sjanssen> oh, I'd imagine it can go a bit higher than that
21:28:54 <oerjan> ah it was Hugs
21:29:16 <sjanssen> nub is pretty useless
21:29:47 <sjanssen> we could easily replace it Ord based thing without upsetting anyone, IMO
21:30:01 <sjanssen> s/replace it/replace it with an
21:34:16 <chessguy> @bot
21:34:16 <lambdabot> :)
21:34:17 <chessguy> anybody know if a generalized simplifier like the one talked about in the SICP video lectures has been done in haskell?
21:36:13 <samreid> Apparently not :)
21:36:29 <samreid> s/not/nobody knows/
21:37:15 <Korollary> What's a generalized simplifier?
21:37:57 <chessguy> it's a pattern-matching and template-instantiation engine
21:38:49 <bos> it's for simplifying algebraic expressions, which i think is what Korollary was asking.
21:39:03 <chessguy> it lets you define a set of rules like e.g., symbolic differentiation rules, or simplification of algebraic expressions
21:39:14 <chessguy> bos, it's not just for that though
21:39:42 <Korollary> symbolic differentiation was done. I think augustss blogged about it. and probably others did it.
21:39:50 <chessguy> bos, their simplifier lets you define pretty much whatever rules you want
21:39:56 <bos> yeah, i know.
21:40:11 <chessguy> Korollary, symbolic differentiation isn't the point
21:41:10 <chessguy> bos, i'm not even sure such a thing could be done in haskell
21:42:15 <bos> sure it could. it's just tree transformations.
21:43:00 <chessguy> i don't know how you could make it as general as theirs though
21:43:22 <chessguy> maybe i'm missing something
21:43:39 <chessguy> it seems like types would get in the way though
21:44:59 <bos> try writing one, perhaps?
21:45:17 <chessguy> i'd like to, but i don't know how
21:45:21 <dons> sjanssen, bos: List.lookup is slower around 10^4 elements or more
21:45:28 <dons> and infeasible by 10^7 elements
21:45:37 * dons wrote a script :)
21:45:40 <dons> i should do a graph
21:45:47 <bos> dons: slower than... Data.Map?
21:45:49 <sjanssen> that'd be nice
21:45:52 <dons> yeah. and IntMap
21:46:06 <bos> damn, Data.Map is slow then.
21:46:09 <chessguy> bos, i guess i could parameterize the type maybe?
21:46:28 <dons> bos, no, i don't think so. they're all on 0.00s
21:46:36 <dons> and Data.List is the first to hit 0.3s for 10^4
21:46:51 <dons> let me graph it...
21:47:35 <mrd> IntMaps are pretty nice
21:48:06 <bos> chessguy: why not keep it really simple to begin?  data Expr = Node Expr Expr | Leaf Double
21:48:31 <bos> chessguy: or data Expr = Node String Expr Expr | Leaf Double
21:48:43 <bos> where the String is the name of the kind of node, as if a Lisp symbol
21:49:26 <bos> that way, the type system won't get in your face until you decide to fancify your data representation
21:49:33 <chessguy> hmm. and then a Pattern is a tree as well, i guess
21:50:19 <bos> nah, just write patterns directly in haskell.
21:51:08 <chessguy> huh?
21:51:35 <bos> why do the heavy lifting of writing a pattern matching engine when you already have one?
21:51:44 <bos> they're quite annoying to write.
21:52:13 <bos> and it will look syntactically inelegant compared to writing plain haskell.
21:53:02 <chessguy> so you're saying just do something like derivative :: Expr -> Expr?
21:53:37 <magnus__> dans: Is that comparing Data.Map.lookup and Data.List.lookup?
21:53:58 <magnus__> aha, you're making a graph
21:55:26 <dons> yeah
21:55:58 <magnus__> I'm really surprised it takes so many elements for map to pay off
21:56:06 <chessguy> bos, but then you don't wind up with something which can take a list of rules to simplify/transform an epression
21:56:59 <mgsloa1> I'm not actually implementing anything at the moment, but I'm curious - with haskell it seems like representing a data structure with inner connections more complex than a tree seems impossible without hacky things like indices
21:57:22 <bos> chessguy: the something that takes a list of rules is your haskell compiler, in that case
21:57:41 <chessguy> bos, but you don't have a representation of the rules
21:58:57 <bos> chessguy: i suppose it depends on which part of the problem you want to solve.  if you want to write rules, just write haskell patterns.  if you want to write the complete engine, sure, you'll need to write your own pattern matcher etc.
21:59:27 <glguy> is there some common error that would cause the fonts in a gtk application to suddenly distort, almost as if they were being draw a few pixels to far to the right (but overlapping as if they were not)
21:59:32 <glguy> (usually happens on mouse overs or typing)
21:59:50 <magnus__> mgsloa1: that's my conclusion too, you need to explicitly represent graphs
22:00:09 <chessguy> yeah, i'd be interested in how the complete engine would turn out in haskell, but i'm a bit at a loss for how to start
22:00:33 <Cale> chessguy: Start with a datatype for expressions.
22:00:48 <mgsloa1> magnus__: yeah, anything that isn't a tree.  main place this will be a problem for me is state
22:01:04 <bos> @stereo
22:01:04 <lambdabot> Unknown command, try @list
22:01:08 <bos> @quote stereo
22:01:09 <lambdabot> stereo, says: "Welcome to #haskell, where all your questions are answered in glorious Stereo"
22:01:21 <Vq^> glguy: subpixel smoothing?
22:01:23 <magnus__> mgsloa1: what are you planning to build?
22:01:30 <bos> hmm, wasn't that originally Cale?
22:01:37 <Cale> yes
22:01:41 <glguy> Vq^: I'm not sure if I'm using that or not, but I could investigate
22:01:45 <chessguy> yeah it was, that's wierd
22:01:45 <mgsloa1> I'm planning on making a robot simulator :)
22:01:46 <Cale> my name was removed because it annoyed me
22:01:53 <oerjan> mgsloa1: you can do cyclic things too with the tying-the-knot method, but it breaks down when you actually need mutable identity
22:01:54 <glguy> I think that it might only happen in multiple window mode of x-win32
22:02:01 <glguy> and not in single window mode...
22:02:07 <glguy> but I'm not certain about that yet...
22:02:08 <mgsloa1> purely for recreational uses - messing with coding bots in haskell
22:02:15 <Cale> (my irc client highlights uses of my name so that I can tell when someone wants my attention)
22:02:37 <chessguy> Cale, but what if i'm not sure what type i want my expressions to have?
22:02:48 <mgsloa1> oerjan - yeah, the issue is mutable identity. I'd like something to be a member of multiple collections yet be mutable
22:02:52 <jfredett> mgsloa1: I've been toying with robot-haskell stuff in my head a bit
22:02:54 <Shimei> BTW: Out of curiosity, there's no anti-PGP policy of anything on the Haskell lists right? I've been on some lists that enforce that.
22:03:01 <Shimei> s/of/or/
22:03:09 <mgsloa1> jfredett: oh? real robot or a sim? we could team up.
22:03:10 <Cale> chessguy: Try something and play around a bit? It'll only start out around a few lines :)
22:03:13 <magnus__> mgsloa1: then it seems you need a layer of indirection
22:03:27 <Cale> chessguy: You can do a simple simplifier in something like 20 lines of Haskell code.
22:03:38 <magnus__> mgsloa1: or update all collections at once
22:03:42 <mgsloa1> magnus__: yeah, that's what'll probably happen.  I can't say I like it though
22:03:44 <mgsloa1> right
22:03:53 <jfredett> mgsloa1: well
22:04:03 <jfredett> mgsloa1: it's all thought experiments, as of late
22:04:04 <chessguy> Cale, i'm not worried about the number of lines of code, i just don't know what to write
22:04:06 <mgsloa1> main issue is that things like this may come up in the future, then everything has to be modified just to add one thing
22:05:13 <mgsloa1> jfredett: I've been rather inspired by xmonad.  I want to go for small core code which supports boundless extensions
22:05:13 <chessguy> @echo chessguy
22:05:13 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "chessguy!n=chessguy@ip68-100-166-128.dc.dc.cox.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo
22:05:13 <lambdabot> chessguy"]} rest:"chessguy"
22:05:13 <jfredett> I'm more interested in the AI bits, not so much making it work with the actual bots
22:05:13 <Cale> chessguy: Perhaps start with something simple like  data Expr = Const Integer | Var String | Plus Expr Expr | Times Expr Expr
22:05:13 <mgsloa1> jfredett: me too :)
22:05:17 <jfredett> heh
22:05:19 <jfredett> for instance
22:05:51 <jfredett> I've been toying with some ideas for autonomous mapping
22:05:52 <chessguy> Cale, by the way, if you go to Settings, preferences, Chatting, Alerts, you can ignore the nick highlighting just for lambdabot
22:10:06 <Cale> oh, that's interesting :)
22:10:06 <Vq^> what client is that?
22:10:06 <chessguy> xchat
22:10:06 <Vq^> ok
22:10:06 <oerjan> mgsloa1: of course you can also consider IORefs
22:10:06 <jfredett> some simple inertial positioning, really, but just how to structure those bits
22:10:06 <chessguy> Cale, then what would patterns look like?
22:10:06 <Cale> chessguy: Initially, you could just use pattern matching in Haskell.
22:10:06 <jfredett> mgsloa1: I've been particularly interested in the qwerk platform
22:10:06 <jfredett> @google qwerk
22:10:06 <mgsloa1> oerjan - right.  I'd rather the state be pure, but I guess I could avoid that
22:10:06 <lambdabot> http://www.charmedlabs.com/index.php?option=com_content&task=view&id=29
22:10:06 <lambdabot> Title: CharmedLabs - Qwerk
22:10:06 <Cale> Or, you could represent patterns in a similar way as they did in SICP
22:10:06 <mgsloa1> hmm, cool.  ARMs are fun
22:10:06 <chessguy> Cale, i'm interested in having a representation of the pattern/template rules
22:10:06 <sorear> Shimei: Screenshots?
22:10:06 <dons> ok. graphs time :)
22:10:06 <mgsloa1> jfredett: I'm likely going to have a minimal physics engine in the core
22:10:06 <dons> so who puts bets on which associative data structure in the base library allows the largest size to be built?
22:10:06 <chessguy> Cale, yeah, i want to do something similar to SICP, but i'm having trouble figuring out how it would translate
22:10:11 <jfredett> well, really, inertial positioning is all about the hardware,
22:10:11 <mgsloa1> might make simulations of inertial positioning a bit more 'fun' :)
22:10:21 <dons> sjanssen, bos: http://www.cse.unsw.edu.au/~dons/data/lookup.png
22:10:25 <hpaste>  dons pasted "Test script" at http://hpaste.org/2254
22:10:27 <jfredett> interpreting it is often a bit tough
22:10:41 <jfredett> the FIRST team at WPI has an "all in one" inertial positioner
22:10:49 <Shimei> sorear: Oh, I suppose that would be nice to have. I'll put some up once I get on my gnome box. An xmonad screenshot might not impress as much. ;)
22:10:55 <oerjan> dons: largest size? wouldn't that be lists, since they have least overhead
22:10:58 <jfredett> I played with it a bit
22:10:59 <sorear> dons: might wanna rescale ;)
22:11:10 <Shimei> jfredett: You're on the WPI FIRST team?
22:11:10 <jfredett> but it was all C, so my brain was fried on the nitty gritty bits
22:11:12 <mgsloa1> jfredett: cool.  sadly my high school has no FIRST
22:11:14 <dons> ah hmm
22:11:16 <jfredett> Shimei: notsomuch
22:11:24 <sorear> dons: Are IntMaps faster or slower than Maps, eg
22:11:25 <dons> oerjan: they need to force the whole list though
22:11:25 <bos> dons: heh, your scale doesn't even get far enough to make the tree-based collections look logarithmic :-)
22:11:28 <jfredett> Shimei: I like Robots, not glorified RC cars
22:11:28 <Shimei> jfredett: I was on 955 over in Oregon.
22:11:29 <jfredett> :P
22:11:37 <jfredett> FIRST is great
22:11:37 <Shimei> Ah. Heh.
22:11:45 <jfredett> not the kind of robots I want to play with
22:11:50 <mgsloa1> yeah, that's my perception as well
22:11:56 <mgsloa1> still would be fun though
22:11:58 <dons> bos, right. but Map and IntMap crash out at 4,194,304 elements on my machine
22:12:02 <dons> IntMap about twice as fast as Map
22:12:03 <jfredett> I want to build some super-interactive robots
22:12:10 <Shimei> I agree. One of the mentors on our team commented that FIRST would be more fun with full autonomy.
22:12:16 <jfredett> I've got an idea for a pair of robots
22:12:18 <dons> while finger trees keep on till somewhere > 16777216 elements
22:12:19 <bos> dons: just 4 million?  ouch!
22:12:31 <jfredett> that are designed soley to interact with large crowds
22:12:32 <Cale> chessguy: Well, I imagine that it'll look a lot like the Expr type, but you'll perhaps have an extra constructor for naming matched portions.
22:12:36 <jfredett> and do there own demos
22:12:37 <dons> bos, could be to do with building and throwing away successively larger trees
22:12:40 <jfredett> autonomously
22:12:40 <dons> stressing the GC a bit
22:12:53 <dons> bos, ah no. methodology issue
22:13:02 <mgsloa1> yeah.  I used to be more into robotics than I am now.  I've got a long-unfulfilled dream of writing a cool sim/game though.  I also wonder what kinds of things would come up with robots written in haskell.
22:13:03 <dons> likely the input list crashes out first
22:13:06 <mgsloa1> sounds fun
22:13:09 <dons> (maybe)
22:13:28 <mgsloa1> Do you know of SRS (seattle robotics society)?  They're local, I used to go to the meetings a lot
22:13:31 <dons> so one thing: up to any reasonable size, IntMap and Map and Sequence are effectively O(1) lookup
22:13:36 <dons> we should just act as if they are
22:13:46 <jfredett> I'm in Massachusetts. :)
22:13:48 <dons> IntMap is faster than Map, and Sequence seems to be cool
22:13:49 <sorear> why do people keep wanting hashtables?
22:13:57 <dons> sorear: no idea :)
22:14:00 <mgsloa1> jfredett: right, but SRS is a pretty major club :)
22:14:00 <dons> we can give them this I think
22:14:01 <sorear> :)
22:14:12 <jfredett> hmm
22:14:15 <mgsloa1> club is probably the wrong word
22:14:16 * jfredett googles
22:14:26 <dons> sorear: seems like a good result, doesn't it
22:14:26 <Cale> I keep telling people to ignore logarithmic factors, but they never listen :)
22:14:36 <chessguy> oh, so maybe something like data Pat = MConst Integer | MVar String | MPlus Pat Pat | MTimes Pat Pat | MatchAny String
22:14:38 <Shimei> mgsloa1: I saw a blog post about doing some simple robot programming with Haskell on a microcontroller earlier this year.
22:14:46 <jfredett> Shimei: me too
22:14:53 <mgsloa1> ah, sweet
22:14:54 <jfredett> It was on reddit, as i remember
22:14:57 <dons> i probably need a more efficient way to construct very big trees before we'd see the logarithmic costs
22:15:01 <dons> or more ram
22:15:01 <Cale> chessguy: yeah
22:15:06 <chessguy> except without the confusing MVar constructor
22:15:21 <Cale> chessguy: and maybe  Match String Pat
22:15:36 <Cale> for naming the result of a whole subexpression match
22:16:52 <chessguy> i'm not sure what you mean by that one
22:17:03 <chessguy> but i guess i'll figure it out when i get there
22:17:05 <Cale> Like  xs@(x:xs') does in Haskell
22:17:09 <Shimei> mgsloa1: Here it is: http://sigfpe.blogspot.com/2007/05/haskell-incarnate.html
22:17:11 <lambdabot> Title: A Neighborhood of Infinity: Haskell Incarnate
22:17:11 <chessguy> oh
22:17:15 <dons> so for 16M elements, the tree depth is only 24 or so ... no wonder acces looks like O(1)
22:17:24 <mgsloa1> Shimei - ah, thanks
22:18:08 <dons> so what's the use case for hashtables given fast lookup?
22:18:23 <Cale> Logarithmic factors are constants when you don't have arbitrarily large sums of money to buy memory.
22:18:48 <dons> right, and so we can recommend finger trees or just Map for pretty much every use case someone would ask about them in here
22:18:52 <monochrom> You need a much faster hash table to justify it.
22:18:55 <reltuk> what's a fingertree?
22:18:58 <Cale> right, and we do :)
22:19:00 <mgsloa1> looks to me like that DSL code, when run, generates the stuff that runs on the robot
22:19:02 <sorear> Besides, RAM is O(n ^ 1/3)
22:19:08 <dons> reltuk: the new Data.Sequence library
22:19:31 <chessguy> Cale, and then i guess the Skeleton would also have a similar structure
22:19:42 <Shimei> mgsloa1: Hmm, I think you're right, but that's basically compilation. So I think it still counts for something.
22:19:56 <mgsloa1> yeah, pretty cool idea, really
22:20:15 <Cale> chessguy: pretty much -- you might even be able to do something with parametrised types to allow for the different extensions of Expr which are needed
22:20:29 <Cale> chessguy: But for now, it's probably easiest just to have three different types.
22:20:34 <monochrom> Ordering is probably faster than hashing for large keys. You just look at part of two keys and you know one is smaller than the other.
22:21:07 <reltuk> dons: looks fun...it'll be in 6.8?
22:21:23 <Cale> reltuk: It's in 6.6
22:21:39 <mgsloa1> jfredett: at the moment I'm working on a bit of a SoC, but I'll hopefully be done in ~20 days, so then I can start work on Raskell
22:21:50 <Korollary> Raskell?
22:22:04 <jfredett> Robot Haskell
22:22:07 <jfredett> :)
22:22:09 <jfredett> I like it
22:22:10 <Boney> cool name.
22:22:16 <monochrom> Pascal : rascal :: Haskell : raskell ? :)
22:22:20 <reltuk> hah, it is
22:22:27 <magnus__> dons: You only look up the last element
22:22:43 <jfredett> mgsloa1: keep me posted, maybe I'll findtime to help
22:22:49 <Boney> monochrom: in odering you may look at one key multiple times, but in hashing you will only look at each once.  this may have an affect.
22:23:14 <chessguy> Cale, i'll have to come back to this tomorrow or something, but thanks
22:23:25 <Cale> chessguy: no problem
22:23:42 <magnus__> dons: perhaps you should look up something somewhere in the middle or a bunch of randomly selected indices?
22:23:42 <dons> magnus__: right, so its not comprehensive at all, and lists will suffer, since that strictifies them
22:23:44 <mgsloa1> jfredett: will do :)
22:23:48 <chessguy> and bos, too, sorry for my thick skull
22:23:54 <chessguy> 'night ya'all
22:23:56 <dons> magnus__: yes, if you have time, roll a better test please :)
22:24:07 <magnus__> dons: yeah yeah :)
22:24:21 <dons> i think i didn't realise how cheap lookup was till today though :)
22:24:23 <magnus__> finger trees are also optimized for accessing first/last elems I think?
22:24:29 <dons> yeah, you've got a finger on the end
22:24:53 <magnus__> though I guess building up the tree is the bulk of the cost?
22:24:56 <dons> we really could do with some more info about maximum sizes and performance data across standard data types
22:25:10 <Cale> It's O(1) to get at the elements at the end, but I wonder what the total cost of traversing the entire finger tree in that way is.
22:25:18 <dons> magnus__: though i don't time that (note the `force`) before hand
22:25:24 <Cale> (Using ViewL)
22:25:26 <magnus__> dons: aah
22:25:50 <sjanssen> Cale: O(n), I'd imagine
22:26:54 <lament> how come simple doubly-linked lists aren't more popular?
22:27:03 <dons> they're not simple?
22:27:11 <Cale> hmm, I should try to understand exactly how it keeps elements easily accessible at the ends without incurring extra cost for fiddling with the internal structure.
22:27:14 <magnus__> I think these maps/sets are still very slow if they only break even with lists at 10000 elements
22:27:18 <dons> list cursors could be more popular than they are
22:27:26 <dons> magnus__: hm?
22:27:41 <Cale> lament: They make terrible immutable structures.
22:27:48 <sorear> lament: Because their main advantages are only useful in an ephemeral setting, and Haskell strongly obfuscates code that uses ephemeral structures
22:28:08 <magnus__> perhaps I misunderstood  < dons> sjanssen, bos: List.lookup is slower around 10^4 elements or more
22:28:24 <lament> sorear: they don't seem to be very popular in other languages either
22:28:42 <dons> magnus__: yeah, that's because they're all 0.000s until 10^4, when list looks noticeably not O(1)
22:28:58 <lament> i suppose they're too general for a really efficient data structure and not general enough for common use (regular lists/arrays do that)
22:29:51 <magnus__> dons: I see. It'd be interesting to know where exactly the break-even point is
22:29:55 <encryptio> @pl \x y -> x*x+y*y>1
22:29:56 <lambdabot> flip flip 1 . ((>) .) . (. join (*)) . (+) . join (*)
22:30:13 <Cale> ahaha
22:30:16 <Cale> flip flip 1
22:30:44 <dons> magnus__: well, for very small things they're all indistinguishable
22:30:52 <Cale> \x y -> x^2 + y^2 > 1
22:31:12 <lament> @pl \x y -> x^2 + y^2 > 1
22:31:12 <lambdabot> flip flip 1 . ((>) .) . (. (^ 2)) . (+) . (^ 2)
22:31:16 <lament> MUCH better.
22:31:18 <dons> what would be good to know is the maximum sizes for a lot of these structures
22:31:23 <dons> when do you have to give up on Map?
22:31:24 <magnus__> dons: unless you run many of them...
22:31:32 <dons> when do you have to give up on Sequence?
22:31:38 <magnus__> yes
22:31:50 <dons> since people do come in here saying "I have 20M items i need to store: which data structure is best?"
22:32:08 <Korollary> berkeley db?
22:32:25 <Cale> also, what are the overheads really like (with constant factors included)
22:32:31 <jbauman> @pl \x y -> 1 < x^2 + y^2
22:32:31 <lambdabot> ((1 <) .) . (. (^ 2)) . (+) . (^ 2)
22:35:09 <Cale> down to 19GB of music left to move into the virtual filesystem
22:42:14 <Binkley> <font size="3">?quote</font>
22:43:12 <sjanssen> Binkley is using gaim ;)
22:44:19 <Binkley> yes
22:44:19 <sjanssen> <Binkley> <font size="3">?quote</font>
22:44:19 <Boney> I wonder..
22:44:19 <sjanssen> if you didn't know
22:44:19 <sorear> dons: You wish.  They seem much more closed-minded to me (unsafePerformIO isn't working ... Hoogle told me ... I needed IO a -> a for HashTable to work ... okay I'm exaggerating a little)
22:44:19 <Boney> Binkley: <blink>HEY YOU</blink>
22:44:27 <Binkley> hmm, is it still doing that?
22:44:30 <Binkley> that isn't supposed to happen
22:44:32 <sjanssen> Binkley: nope, gone now
22:44:49 <glguy> Illegal application of command "datatype" at top level ?
22:44:51 <Binkley> strange
22:45:04 <sorear> If they want Jabber (NB - XML IM) why don't they know where to get it?
22:45:05 <sjanssen> sorear: so when do we just reimplement Data.HashTable in terms of IntMap?
22:45:22 <glguy> OH, I'm not using HOL
22:45:47 <Cale> hehe
22:45:49 <sorear> sjanssen: When we convince Simon that it's faster :)  I think it's only used for the TypeRep cache
22:46:34 <Cale> The only real reason people use hashtables is because they're too lazy to implement good balancing algorithms.
22:46:47 <Cale> ;)
22:47:16 <sjanssen> Cale: also, many programmers are brainwashed to the extent that "hash" is the one and only term for a dictionary
22:48:58 <bos> implementing good balancing algorithms in imperative languages is a huge pain.
22:49:08 <Korollary> hash tables are easier to explain
22:49:24 <bos> compare balancing a red-black tree in haskell (4 lines of code) with C (4 pages, choose your own page size).
22:49:27 * monochrom resists bringing up a related flame war.
22:49:36 <sorear> Cale: even hashtables need good balancing... and the situation is far worse for them, I don't think anyone has ever proven a hash algorithm correct (except Proof by Knuth, which doesn't count)
22:50:01 <sjanssen> Korollary: I've always found hash tables more difficult
22:50:30 <OceanSpray> ok, I got a problem
22:50:43 <bos> what's interesting is auto-resizing hash tables that don't require a recomputation of the hashes of every existing element when you grow them.
22:50:46 <dons> sorear: i think hashtables shouldn't be in Haskell's base library.
22:50:55 <OceanSpray> data LispVal = Pair (IORef LispVal) (IORef LispVal)
22:50:57 <sorear> I have a 32 year old PL text which describes hashtables only
22:50:57 <bos> if that don't melt your brain, nothing will.
22:51:03 <sorear> of course it doesn't call them that
22:51:11 <sorear> hash coded symbol arrays!
22:51:16 <sjanssen> nice
22:51:34 <OceanSpray> now, I have show :: IORef LispVal -> String
22:51:52 <sorear> bos: what's so brainbending about spiral hashes?
22:52:09 <OceanSpray> how the hell do I get the LispVal out of the IORef without having to change the output to -> IO String ?
22:52:11 <bos> sorear: they're a pain to implement correctly
22:52:14 <Cale> OceanSpray: You don't.
22:52:21 <OceanSpray> ???
22:52:35 <Cale> OceanSpray: The contents of IORefs are only accessible by IO actions.
22:52:43 <OceanSpray> that's a downer.
22:52:49 <glguy> Any Isabelle users?
22:52:58 <Cale> Well, if you *could* access them, it would be a bigger downer.
22:53:06 <glguy> seems like anything I try to do in proofgeneral gives the error: "Wrong type argument: stringp, nil"
22:53:06 <Cale> It would break referential transparency.
22:53:29 <OceanSpray> ok, now I have to rewrite my whole recursive show (Pair car cdr) function
22:53:40 <bos> sorear: and spiral hashes require some rehashing. it's possible to build a hash table that requires none.
22:53:42 <OceanSpray> just because cons-cells are mutable.
22:53:44 <OceanSpray> orz
22:53:45 <kfish> OceanSpray, why are you using IORefs everywhere?
22:54:03 <Cale> OceanSpray: A function of type A -> B gives the same value of type B whenever it's given the same value of type A, always.
22:54:30 <Cale> So show would have to print the same thing whenever given the same cons-cell.
22:54:35 <OceanSpray> well, why NOT IORefs?
22:54:53 <OceanSpray> Cale, my Pair used to be LispVal LispVal
22:54:56 <Cale> OceanSpray: Because they're only usable within IO :)
22:54:57 <oerjan> kfish: he is implementing lisp.  lisp cons cells are mutable.
22:55:16 <sorear> obviously, he should implement Pure LISP
22:55:24 <OceanSpray> and what might that be?
22:55:33 <dobblego> Haskell of course
22:55:37 <OceanSpray> a purely functional lisp?
22:55:47 <Cale> OceanSpray: Just make them immutable internally, but have the evaluator replace them to simulate mutation.
22:55:52 <sorear> LISP restricted to CONS CAR CDR LAMBDA and a couple others (but *not* RPLACA or RPLACD)
22:56:13 <OceanSpray> guys, I'm implementing not just a random lisp,
22:56:21 <oerjan> Cale: lisp has shared data structures. it won't work.
22:56:23 <OceanSpray> but a planned out programming language.
22:56:33 <sorear> I was mostly kidding, sorry :)
22:56:40 <sjanssen> OceanSpray: what is your 'show' functions supposed to do?
22:56:44 <OceanSpray> Cale, that's impossible
22:56:53 <OceanSpray> show gives a string representation of a lisp value
22:56:56 <Cale> OceanSpray: why?
22:57:19 <Cale> You can always simulate mutation using pure representations.
22:57:27 <sjanssen> OceanSpray: okay, instead of using 'show' and the Show class, introduce your own function, with type LispVal -> IO String
22:57:38 <OceanSpray> see, if I do (begin (define a 5) (define p (cons a 6)) (set a 4) p)
22:58:00 <sjanssen> Cale: the semantics seem to require reference semantics
22:58:13 <Cale> sjanssen: referencing into what? A Data.Map?
22:58:15 <OceanSpray> note that my 'set' is quite different from scheme's 'set!' in that it alters the VALUE, not the binding
22:58:26 <OceanSpray> Cale, yes
22:58:29 <Cale> You don't *have* to use heap pointers for references.
22:58:41 <sjanssen> Cale: of course you can do that purely, but a global 'Map Int Val' isn't much different from using IORefs in this case
22:58:53 <Cale> You can use a Data.Map to store your heap.
22:58:55 <OceanSpray> I use (IORef (Map String (IORef LispVal))) for environment
22:59:04 <Cale> Which means that you don't end up turning everything into IO :)
22:59:06 <OceanSpray> which are first-class, by the way
22:59:10 <sjanssen> Cale: you're still going to have to push that Map through all of your functions (like show, for instance)
22:59:28 <Cale> That's true.
22:59:58 <sjanssen> and we end up with a ad-hoc and slow implementation of IORef ;)
23:00:14 <Cale> Without the danger of other side effects :)
23:00:19 <sjanssen> true
23:00:21 <OceanSpray> now, what about State?
23:00:28 <Binkley> every Haskell program contains an ad-hoc and slow implementation of C? :-)
23:00:51 <OceanSpray> from the "Write yourself a scheme in 48 hours" tutorial,
23:00:54 <mgsloa1> every sufficiently complex haskell program :P
23:01:15 <OceanSpray> I inferred that State is not 'complex' enough for lisp environment simulation
23:01:23 <jql> the C implementation is just there to bootstrap emacs
23:01:43 <sjanssen> OceanSpray: you can emulate IORef with a Data.Map and unique Int keys
23:02:05 <OceanSpray> but why emulate when you got the real thing?
23:02:07 <dons> interesting, http://programming.reddit.com/info/2fbtp/comments
23:02:08 <lambdabot> Title: "the way forward involves functional programming" (reddit.com)
23:03:06 <mgsloa1> OceanSpray: maybe you need to seperate your AST and your execution tree
23:03:17 <sjanssen> OceanSpray: with the State version, you can prove that your program doesn't have other side-effects (like IO, etc.)
23:03:30 <OceanSpray> hmm
23:03:55 <johnnowak> OceanSpray: you could just write it in scheme and get it done sometime this year... or week.
23:04:03 <OceanSpray> NO.
23:04:11 * johnnowak whistles
23:04:15 <OceanSpray> I'm not starting over
23:04:29 <johnnowak> i just wrote it in scheme. it's already done! twice actually.
23:04:48 <OceanSpray> ok, so you implemented fexpr-scheme?
23:04:58 <johnnowak> i'm just teasing.
23:05:04 <OceanSpray> oh
23:05:13 <OceanSpray> that would be mean, though
23:05:34 <sorear> you could probably do it just as easily in any language that doesn't have this fundamental mismatch
23:05:51 <sorear> ubiquitous mutability vs. tightly restrained
23:06:19 <sorear> even SML would probably not be too painful (you have ref cells but the system doesn't force monadic style to use them)
23:06:57 <OceanSpray> ok, let's try to address the problem rather than shying away from it
23:07:07 <OceanSpray> note that I'm also trying to LEARN HASKELL in the process.
23:07:19 <OceanSpray> switching to another language kind of misses the point.
23:07:27 <johnnowak> I know, I know.
23:08:01 <sjanssen> Haskell should be a reasonable choice -- the pugs guys seem to make do
23:08:06 * shapr cheers for OceanSpray 
23:08:20 <OceanSpray> so, now...
23:08:38 <dons> OceanSpray: and you've got the scheme in 48 hours tut as a guide?
23:08:40 <OceanSpray> write showVal :: IORef LispVal -> IO String, yes?
23:08:47 <sjanssen> OceanSpray: yeah
23:08:49 <OceanSpray> dons, sort of
23:09:13 <OceanSpray> I turn to it as a loose reference for when I get stumped on how to implement a feature
23:09:24 <OceanSpray> I'm not really implementing Scheme, you see
23:09:33 <OceanSpray> it's actually quite far from it.
23:09:34 <dons> yep
23:10:42 <OceanSpray> For example, I don't use Haskell lists to represent pairs, and my parsers use Parsec.Token rather than just Parsec
23:11:39 <oerjan> haskell lists would not be the right choice for scheme pairs either
23:12:41 <oerjan> hm... the Parsec use could be a problem too
23:13:14 <oerjan> because Parsec is a pure parser, so you would have trouble constructing IORefs in it
23:13:22 <OceanSpray> the Parser's done with
23:13:25 <Cale> oerjan: Is that really a problem?
23:13:26 <OceanSpray> no need to mess with it
23:13:43 <OceanSpray> I can always do newIORef <some parsed lispval>
23:13:56 <oerjan> Cale: it's a problem if the parser tries to generate a mutable structure
23:14:03 <OceanSpray> but it doesn't.
23:14:05 <Cale> Yeah, but it shouldn't do that
23:14:05 <OceanSpray> that's impossible.
23:14:13 <Cale> It just generates a parse tree
23:14:44 <qwr> you can later convert it to mutable conses
23:15:17 * Cale really really really hopes that this fsconvert goes smoothly
23:15:49 <oerjan> it's a bit awkward with lisp since you would normally like the parse tree to _be_ the final data structure
23:15:57 <OceanSpray> ok, so how do I use State?
23:16:15 <oerjan> otherwise you need to use different types.
23:16:19 <OceanSpray> the Haskell.org documentation doesn't make sense at all
23:16:31 <Cale> OceanSpray: actually, if your evaluator's going to do I/O while evaluating, you might not bother
23:16:45 <Cale> I/O might really be the monad you need
23:16:57 <glguy> what tool do you use in debian to view .ps?
23:17:07 <opqdonut> glguy: gv?
23:17:11 <OceanSpray> oh fine then
23:17:18 <OceanSpray> stick with IORefs I will
23:17:27 <oerjan> well you might still want to use StateT _ IO
23:17:38 <sorear> glguy: I use gv
23:17:46 * glguy was trying to find ghostview
23:17:51 <glguy> didn't know it was called gv
23:18:04 <opqdonut> :)
23:19:02 <qwr> of course, lisp syntax should be easily parseable without parsec too
23:19:02 <OceanSpray> hold on...
23:19:18 <dons> StateT Env IO would be the standard evaluator monad for real languages, I'd imagine
23:19:22 <dons> pugs is very similar to taht
23:19:29 <qwr> haskell pattern matching on [Char] is quite good ;)
23:19:30 <dons> for some Env that models your machine state
23:20:01 <glguy> also... what was the xmonad hotkey to reattached a floating window?
23:20:05 <glguy> meta t
23:20:15 <sjanssen> yes
23:20:25 <OceanSpray> so if I have a function foo :: a -> b -> c
23:21:03 <OceanSpray> foo _ x will yield a curried function a -> c ?
23:21:16 <sjanssen> no
23:21:17 <opqdonut> no
23:21:22 <OceanSpray> aww
23:21:24 <oerjan> OceanSpray: no such syntax
23:21:25 <opqdonut> flip foo x
23:21:30 <sjanssen> OceanSpray: _ is only available in pattern matching
23:21:42 <OceanSpray> dangit.
23:21:50 <sjanssen> OceanSpray: try (\a -> foo a x) or (flip foo x)
23:22:05 <oerjan> or (`foo` x)
23:22:30 <opqdonut> oerjan: that's a pretty J approach to it :)
23:31:53 <ramza3> is anybody writing a simple compiler/parser in haskell or writing one based on haskell or other functional language
23:32:10 <dons> sure :)
23:32:15 <dons> that's pretty much all we do :)
23:32:19 <dons> ;)
23:32:19 <ramza3> ah
23:32:20 <olliej> dons: heheh
23:32:29 <glguy> dons: don't lie to the new guy :-p
23:32:29 <Binkley> ?quote compiler
23:32:29 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler.  They've only written a monad tutorial.
23:32:33 <dons> ramza3: you want some examples?
23:32:38 <Binkley> ?quote Binkley compiler
23:32:39 <lambdabot> Binkley says: are there any Haskell users who haven't implemented a compiler?
23:32:41 <ramza3> dons: you have one,?
23:32:52 <dons> ramza3: look at the small languages section here, http://haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters
23:32:54 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2dt77g
23:33:04 <ramza3> dons: well this is my kind of place then
23:34:02 <glguy> ramza3: did you ever make any headway with liskell?
23:35:09 <ramza3> glguy, no, but looks interesting
23:37:14 <OceanSpray> hold on
23:37:38 <OceanSpray> in showVal :: IORef LispVal -> IO String
23:37:56 <OceanSpray> can I just do showVal (IORef val) = blah blah blah val ?
23:38:01 <glguy> no
23:38:04 <OceanSpray> aww.
23:38:13 <glguy> showVal ought to have type   LispVal -> String
23:38:20 <oerjan> OceanSpray: i would suggest making the type LispVal -> IO String
23:38:45 <OceanSpray> I get the feeling that you two didn't follow the convo above.
23:38:50 <glguy> oh, does LispVal contain IORefs
23:38:54 <OceanSpray> yes
23:39:01 <glguy> then oerjan is more right than i was
23:39:36 <glguy> or maybe the function is mislabeled
23:39:39 <OceanSpray> and if showVal <lisp pair> is going to be recursive, I was right in the first place.
23:39:54 <glguy> OceanSpray: no, there are better ways to compose functions
23:39:56 <oerjan> because then you the IORef version just becomes readIORef r >>= showVal
23:40:09 <oerjan> s/you//
23:40:19 <OceanSpray> wait, what?
23:40:20 <aleator> Stupid haskell style question. What am I doing wrong if it seems that all I'm doing is shuffling data from one structure to another?
23:40:43 <OceanSpray> for data Lispval = Pair (IORef LispVal) (IORef LispVal), you really got a better idea?
23:40:57 <glguy> what oerjan said
23:41:09 <oerjan> it is easier to get the version with IORef from the one without than the other way around
23:41:17 <dons> aleator: hmm, relying on laziness?
23:41:18 <glguy> no sense in not allowing someone to show a LispVal because it isn' tin an IORef
23:41:43 <oerjan> and then you can just start pattern matching on the LispVal straight away
23:41:44 <dons> aleator: or perhaps you need to ensure you're not converting between two different data structures, when a single one would do?
23:42:02 <glguy> perhaps you need to refactor one big data structure into a couple of them
23:42:23 <glguy> so you can pass meaningful groups of content?
23:43:25 <aleator> It goes like this I've got a training set which is list of pairs. Then I need the same with names.. So I've got a pair of string and training set. Afterwhich I've got a function that works only on trainingsets so I unpack.. and pack..
23:43:51 <aleator> Of course, the answer is "I'm silly" but :/
23:44:31 <dons> pairs sound wrong? perhaps you should be using Maps ?
23:44:41 <dons> or finger trees
23:44:50 <dons> ah no, since you don't have Int keys
23:45:31 <sorear> dons: with NNs the only operation you do is foldl', so lists are better than maps
23:45:51 <aleator> Well, they might be more efficient, but I still would get into that unpack-repack-operate-unpack-repack..
23:46:12 <aleator> wouldn't I?
23:46:13 <sjanssen> aleator: perhaps you want map functions for your different components?
23:46:59 <oerjan> aleator: what are the types of your two formats?
23:47:04 <mudge_> hello
23:47:14 <sjanssen> like, mapTrainingSet :: (TrainingSet -> TrainingSet) -> (String, TrainingSet) -> (String, TrainingSet) -- this happens to be fmap for ((,) a)
23:47:16 <dons> sorear: ah ,yes, he's doing NNs. but there's standard data structures for this stuff isn't there, aleator ?
23:47:30 <olliej> dons: dcoutts: the inference papers are quite a good read, thanks :D
23:47:36 <dons> a custom structure might make sense.
23:47:43 <mudge_> is anyone using haskell to build websites?
23:47:45 <dons> olliej: yeah, THiH as we call it, is very good :)
23:47:58 <dons> mudge_: yeah, there's a couple of commercial operations
23:47:59 <olliej> dons: :D
23:48:12 <mudge_> i mean,  in this chat room,  that wants to talk about it
23:48:16 <olliej> dons: my goal is to rewrite my compiler a) in haskell, and b) without a ghc front end
23:48:23 <sorear> dons: the NN itself is in a standard structure, but the training itself is just a loop, aka list *muahaha*
23:48:45 <dons> mudge_: oh, talk to the #happs guys perhaps? -- they're employed to work on haskell web dev :)
23:48:51 <dons> (they also hang out here)
23:49:15 <mudge_> oh, neat
23:49:36 <glguy> mudge_: hpaste is a haskell program whose devs are in channel
23:49:39 <glguy> !paste
23:49:39 <hpaste> Haskell paste bin: http://hpaste.org/
23:50:02 <aleator> oerjan: they go something like [Filepath] to  [(String,[Image])] to [([x],Bool)] from which I kinda need the filepath so..
23:50:08 <aleator> dons: Standard data structures?
23:50:13 <dons> yeah, so that's a happs-based smalls webapp. glguy is the guy to talk to.
23:50:54 <mudge_> what is the list http://hpaste.org/  about?
23:51:05 <dons> its a "paste bin" site
23:51:25 <glguy> its the hello world of web frameworks :)
23:51:30 <dons> you can just paste code fragments there, so they can be shared and discussed
23:51:35 <sorear> mudge_: Think "free hosting for stuff you want fixed"
23:51:41 <dons> very web 2.0 social network stuff :) you build the site, they provide the content
23:51:54 <dons> and lots of javascript ;)
23:51:57 <OceanSpray> huh
23:52:02 <OceanSpray> that was easier than I expected.
23:52:17 <mudge_> sorear: neat
23:52:26 <mudge_> sorear: thanks
23:53:17 <glguy> some stuff must have changed in the new version of xmonad I just built and installed
23:53:21 <glguy> the restart was *visible*
23:53:33 <dons> glguy: is hpaste's main repo still on http://www.scannedinavian.com/~eric/hpaste/ ?
23:53:41 <dons> glguy: oh?
23:53:46 <sorear> dons: no, -devel/
23:53:51 <dons> oh, you restarted between major versions or something?
23:53:58 <sorear> glguy: How far did you jump?
23:54:03 <dons> there's been 3 flag falls days, i think, since 0.2 came out
23:54:04 <glguy> 8 patches forward
23:54:18 <dons> in what sense was it visible?
23:54:20 <sorear> glguy: Layouts are always reset atm - that?
23:54:33 <glguy> yeah, I suppose...
23:54:38 <glguy> yeah, hta was it
23:54:44 <dons> yeah, if you're in the non-default layout state, it won't be serialised
23:54:48 <sorear> dons: that'll need to be fixed, debianites love talking about the fact that they have had system continuity for >10 years ;)
23:55:02 <dons> sorear: definitely. its an open ticket with a proposed solution
23:55:37 <sorear> dons: I mean "0 flag days" not "save layouts"
23:55:57 <glguy> sorear: system continuity includes reboots?
23:56:06 <dons> sorear: oh, well, that's something else.
23:56:11 <glguy> or do you just mean that they don't need to reinstall the os?
23:56:20 <sorear> glguy: that.
23:56:20 <dons> they're not trying to do lots of hot updates preserving state :)
23:56:35 <sjanssen> xmonad handles state breakage gracefully now
23:56:50 <sorear> well, apt/dpkg haven't exactly stayed the same since 1.1
23:56:53 <dons> yeah, its a flag day in that state wil just be flushed
23:56:53 <glguy> what is an xmonad flag day?
23:56:58 <dons> not that you can't restart :)
23:57:06 <Binkley> it's the day when everyone displays the xmonad flag outside their house
23:57:09 <sjanssen> all of your windows will get dumped into workspace 1, but that isn't so major
23:57:10 <mudge_> anyone want to share some insights about building web apps in haskell?
23:57:22 <sorear> dons: what does "state will be flushed" mean?
23:57:25 <dons> Binkley: yeah, that's the best day!a big black flag with a lambda and a monadic bind on it
23:57:30 <dons> happy xmonad flag day everyone!
23:57:41 <glguy> mudge_: that's a terribly vague question :-/
23:57:48 <sorear> dons: well, from transitivity I know it means "you lose all windows not on the current workspace (or has that been fixed?)"
23:57:49 <Binkley> and whenever xmonad crashes, you have to put the flag at half staff
23:57:59 <sjanssen> sorear: that's been fixed for a couple weeks
23:58:51 <sjanssen> you can even hot-restart between xmonad and metacity, it all works
23:59:38 <glguy> if I have two windows on a workspace
23:59:45 <glguy> and the mouse is in the right frame
23:59:50 <glguy> and I use Alt Enter
23:59:55 <glguy> the two frames switch
