00:00:06 <Olathe> Clark Kent can't fly ?!
00:00:42 <dblhelix> olathe: it was all done with strings ;-)
00:00:55 <roconnor> What about coytoes?
00:05:55 <ivant> dblhelix, were they CStrings or ordinary lists? or maybe ropes?
00:06:33 <dblhelix> ivant: heh
00:06:46 <Olathe> Whatever they were, I want to buy some so I can fly.
00:07:48 <ivant> Olathe, can sell you a bunch of CStrings. No guarantees about flying, however :-)
00:14:13 <monochrom> This is very sad. I'm using delimited continuations to do self-modifying code, and I'm using self-modifying code to implement mutable state.
00:14:20 <dblhelix> speaking of those, does anyone know about the status of the ropes implementation?
00:22:16 <ivant> dblhelix, which implementation?
00:22:46 <dblhelix> iirc, a bunch of people were working on crafting a ropes library for haskell
00:23:28 <ivant> dblhelix, I started to write an implementation myself, but I stopped at the point where I needed to do balancing (mostly, because I didn't have enough time to come up with the best way to do it)
00:24:00 <dblhelix> ivant, ah, okay, it could well be that you are the bunch I was referring to :-)
00:24:10 <ivant> dblhelix, no, I'm not :-)
00:24:24 <dblhelix> ivant: fair enough
00:24:42 <sebell> ddarius (sp?) was working on one such library
00:24:56 * psykotic feels dirty, having to resort to ST for a prime sieve.
00:25:17 * olsner resorted to C
00:25:17 <dblhelix> sebell: ah, thanks
00:26:14 <olsner> I tried to get to something like an Array of Bool, but figured I'd rather do it in C where it was a no-brainer
00:30:35 <osfameron> bluestorm: ta, downloaded paper on prime sieve
00:30:48 <psykotic> olsner: yeah, i just used an STArray
00:31:04 <psykotic> it wasn't any more difficult than it would have been in C
00:31:17 <bluestorm> i hope it will be interesting for you
00:32:14 <psykotic> @paste
00:32:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:32:42 <hpaste>  psykotic pasted "st-based prime sieve" at http://hpaste.org/2273
00:34:02 <psykotic> that also happens to highlight two annoyances about ST
00:34:25 <psykotic> the need to surround a do-block provided to runST by (...) rather than using the $ operator
00:34:40 <psykotic> and the fact that using the type class based newArray/readArray/writeArray you have to specify an explicit type signature
00:35:07 <sorear> the first is just a problem with GHC's type system
00:35:13 <psykotic> right
00:37:08 <psykotic> doesn't make it less annoying :)
00:38:45 <olsner> honestly, the corresponding C code is more readable though ;-)
00:38:59 <psykotic> also less likely to work on the first try (which this did)
00:40:12 <osfameron> bluestorm: golly, I think I even understood some of that, thanks, yes, good paper.
00:41:56 <olsner> the things I did wrong with mine before it worked would've been equally easy to get wrong in haskell, like using factors [1..] instead of [2..], setting every number to not-prime ;-)
00:48:59 <DRMacIver> Hm. I'm having to really aggressively delete stuff to keep on top of Haskell cafe.
00:50:00 <olsner> yeah, that list is a serious time-sink of you intend to read it
00:50:34 <DRMacIver> I used to try to read all of it, which ended up with a backlog of several hundred emails. :)
00:50:58 * DRMacIver has started just skimming the topics to see if there's anything which looks interesting, reading those that do and then deleting the entire contents of the folder.
00:51:07 <conal> does anyone know where there's a class that abstracts over IORefs?  it includes newRef, readRef, and writeRef.
00:51:16 <conal> i've seen it somewhere
00:51:51 <monochrom> You should always skim by topics.
00:52:31 <monochrom> The whole thread about the "(<- xxx)" notation can be elided. That is half the mailing list.
00:52:42 <arcatan> @src filterM
00:52:43 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:53:09 <shachaf> @source Control.Monad
00:53:09 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
00:54:27 <monochrom> Those "explaining monads" and "why monad tutorials don't work" are somewhat interesting but you can glance at them quickly, like cursorily sample a few sentences and done. That's one third of the mailing list.
00:54:46 <Itkovian> meuning
00:55:37 <olsner> the thing with monad tutorials seems to be that *writing* them teaches you about monads, not reading them
00:56:02 <monochrom> If you do not know enough to understand the threads on code optimization and performance, no point reading them either. That's one tenth of the mailing list.
00:56:26 <osfameron> a sieve for haskell-cafe!
00:56:26 <monochrom> After the above three filters, you basically have only 10 messages to read. :)
00:56:40 <DRMacIver> olsner: Yes, I think that's definitely true. :)
00:57:02 <olsner> so there really should be a monad tutorial tutorial
00:57:18 <johnnowak> olsner: Don't give them any ideas!
00:57:58 <DRMacIver> olsner: I'm tempted. :)
00:58:08 <olsner> johnnowak: too late...
00:58:48 * kfish wonders if writing a monad-tutorial-writing monad would help with understanding why people write monad tutorials
00:58:55 <johnnowak> At least it's just restricted to monads. There aren't too many horrible call/cc tutorials nowadays.
00:59:15 <DRMacIver> (Mostly as a parody though)
00:59:18 <monochrom> Pervertedly, more people writing monad tutorials means more reddit appearance. Gives them the illusion that Haskell is taking off and everyone should scramble to learn it. Then Haskell will take off. Same phenomenon as Windows dominating and Java dominating. Everyone thinks "everyone is doing it", and then it will fulfill itself.
00:59:19 <olsner> kfish: write a tutorial on writing such monads and you'll be fine
00:59:26 <johnnowak> "A continuation represents the future of your toxic waste dump."
00:59:56 * ivant feels that he understood monads enough for his purposes and started tackling arrows
01:00:09 <ivant> Is there something like "a path of a Haskell programmer"?
01:00:37 <monochrom> If you have not written self-modifying code using the delimited continuation monad, you have not understood much about monads.
01:00:42 <kfish> ivant: http://www.willamette.edu/~fruehr/haskell/evolution.html
01:00:44 <johnnowak> http://www.willamette.edu/~fruehr/haskell/evolution.html
01:00:46 <ivant> which has all steps one should make to become a guru?
01:00:46 <lambdabot> Title: The Evolution of a Haskell Programmer
01:00:46 <lambdabot> Title: The Evolution of a Haskell Programmer
01:00:54 <ivant> aha
01:00:54 <Cale> monochrom: heh
01:01:09 <Japsu> @quote out-smalltalk
01:01:10 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
01:01:12 <Japsu> :<
01:01:25 <shachaf> @where evolution
01:01:25 <lambdabot> I know nothing about evolution.
01:01:30 <johnnowak> @quote scheme
01:01:31 <lambdabot> EvilRanter says: I went off scheme, because the fundemental keywords of the language had stupid names
01:01:37 <shachaf> @where+ evolution http://www.willamette.edu/~fruehr/haskell/evolution.html
01:01:38 <lambdabot> Done.
01:02:04 <Japsu> @remember LoganCapaldo ruby isn't trying to out-python python, its trying to out-smalltalk perl :)
01:02:04 <lambdabot> Done.
01:02:10 <Japsu> had to dig that from the logs
01:02:35 <johnnowak> @quote quotable
01:02:35 <lambdabot> No quotes match. Are you on drugs?
01:03:28 <kfish> @quote drugs
01:03:28 <lambdabot> dylan says: pugs, darcs, and lambdabot: gateway drugs to haskell.
01:03:59 <hpaste>  olsner annotated "st-based prime sieve" with "C-food" at http://hpaste.org/2273#a1
01:04:11 <johnnowak> @quote objects
01:04:12 <lambdabot> mrd says: if it has functions, it's functional.  if it has objects, it's objectionable.
01:04:21 <olsner> hehe, I remember that one
01:04:34 <johnnowak> @quote dynamic
01:04:35 <lambdabot> vincenz says: why do you want to be dynamicalyll gendered? lexically gendered is cleaner
01:04:44 <johnnowak> oh my
01:04:52 <monochrom> I am statically gendered.
01:05:45 <osfameron> there was an interesting haskell-blog with some sugar for ST based code
01:06:58 <osfameron> mmm, http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
01:07:00 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2948p6
01:20:33 <augustss> :)
01:22:03 <ivant> oh, by evolution I meant something like a list monads => monad transformers => arrows => ...
01:22:25 <olsner> "Now there's a coincidence. Two days ago I was pondering whether or not I could extract enough content from that roundabout for a blog post about its algebraic topology."
01:35:06 <osfameron> Euler 14 is a really tricky one
01:35:33 <osfameron> the maths is simple enough, but getting something efficient enough that it runs quickly and doesn't toast my laptop's flakey CPU is a bit of a struggle
01:37:07 <drigz> osfameron: mine runs in 3.85 seconds, maybe you're not doing it right
01:37:24 <ivant> @where euler
01:37:24 <lambdabot> I know nothing about euler.
01:37:46 <ivant> @where+ euler http://projecteuler.net
01:37:46 <lambdabot> Done.
01:37:55 <osfameron> drigz: that's almost certainly the case :-)  (as that's kind of the point of the Euler questions)
01:37:58 <drigz> osfameron: post your code?
01:38:29 <osfameron> drigz: I put the haskell one to one side as I thought I should do caching and don't know how to do that in haskell so tried Perl...
01:38:51 <drigz> osfameron: yeah, i had a problem with working out how to cache it in haskell
01:39:00 <osfameron> I'll post what I started with though
01:39:37 <hpaste>  osfameron pasted "bits and bobs to (non functional) solution to Euler 14" at http://hpaste.org/2274
01:41:07 <osfameron> actually, those seem to be an attempt to start from 1 and look at all the possible solutions from there
01:41:27 <osfameron> but I did try just iterating every number towards end of range
01:42:07 <shachaf> @where projecteuler
01:42:08 <lambdabot> I know nothing about projecteuler.
01:42:10 <drigz> osfameron: interesting
01:42:15 <drigz> but not necessary, if that helps :p
01:42:25 <shachaf> @where+ projecteuler http://projecteuler.net/
01:42:25 <lambdabot> Done.
01:42:25 <osfameron> drigz: I don't really want a *solution* as such (at least not yet) but would be interesting if you had some hints
01:42:45 <drigz> osfameron: there's a wiki page with solutions to the easier problems if you ever need
01:43:15 <osfameron> as in: did you just brute force but with caching? or is there some maths that I could usefully read up on?
01:43:25 <drigz> my solution does it with map chainLen [1..1000000]
01:43:45 <roconnor> @where project euler
01:43:45 <lambdabot> I know nothing about project.
01:43:59 <drigz> osfameron: so yes, it's just brute force with a memo
01:44:43 <osfameron> drigz: oh!  I think I'll try again then when my laptop's just woken up (my acpi is buggered, so it tends to overheat and shut down whn I try to get it to calculate stuff too fast)
01:45:03 <osfameron> where do I learn about haskell memoization?
01:47:16 <ivant> @where memoization
01:47:17 <lambdabot> I know nothing about memoization.
01:47:30 <ivant> hmm, I thought I've seen somebody adding it
01:47:51 <osfameron> @where memo
01:47:51 <lambdabot> I know nothing about memo.
01:48:01 <dobblego> @where memoisation
01:48:02 <lambdabot> I know nothing about memoisation.
01:48:13 <shachaf> I think that part of the state got reset too.
01:48:33 <drigz> osfameron: i found a message on the mailing list which was actually about that problem exactly
01:48:48 <drigz> the general way is just to use a lazy data structure like this:
01:49:21 <drigz> memo = arrayList (0, 100) (map calc [0..100])
01:49:57 <drigz> calc n = (memo ! (n-1)) + (memo ! (n-2))
01:50:18 <drigz> or better
01:50:21 <drigz> fib n = memo ! n
01:50:37 <drigz> calc = fib' n = fib (n-1) + fib (n-2)
01:50:44 <osfameron> eeeeek!
01:51:10 <drigz> the way it works is that instead of calling the function which retrieves it from the memo if possible
01:51:24 <drigz> you use laziness, so that you retrieve it from the memo, and it calls the function if necessary
01:51:31 <osfameron> lazy recursive definitions are very cute but they make my head hurt
01:51:40 <drigz> hopefully that's a better explanation
01:51:43 <osfameron> where is arrayList ?
01:52:11 <drigz> sorry, listArray
01:52:18 <drigz> i always confuse the two
01:52:21 <osfameron> and where is that? ;-)
01:52:33 <osfameron> also, does calc still work if you go outside the bounds of memo?
01:52:38 <drigz> http://haskell.org/ghc/docs/latest/html/libraries/haskell98/Array.html#v%3AlistArray
01:52:40 <lambdabot> http://tinyurl.com/yooe9e
01:52:45 <shachaf> @index listArray
01:52:45 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
01:52:57 <drigz> osfameron: not in this one, it needs modification
01:53:39 <osfameron> drigz: which of course we need because the collatz sequence can go above 1M, though I suppose it doesn't go above 2M ?
01:54:19 <drigz> osfameron: i think it's inefficient to increase the size of the memo because the larger values are used so sparsely
01:54:35 <drigz> so my program just skipped the memo if it was too big
01:55:00 <osfameron> drigz: yeah, I was thinking that but wasn't sure it would be a problem so was wondering if I could just not bother :-)
01:55:45 <osfameron> ok - thanks for the pointers!  I'll look at this maybe out of work (though it's August in Italy, so I'm not exactly bombarded at the mo, I should probably at least *pretend* to do something...)
01:56:26 <drigz> osfameron: good luck
01:56:52 <osfameron> drigz: ta :-)
02:03:53 <dons> "Once, around the time of the discovery of fire, there was a large population of people that thought mastering fire would be too difficult so they didn't. The rest of us killed them, cooked them and ate them."
02:04:18 <dons> @remember bootslack Once, around the time of the discovery of fire, there was a large population of people that thought mastering fire would be too difficult so they didn't. The rest of us killed them, cooked them and ate them.
02:04:18 <lambdabot> Done.
02:05:10 <osfameron> where's that from?
02:08:42 <osfameron> dons:  I like the epilogue too ("And we are still hungry.")
02:15:44 <dons> :)
02:21:31 <psykotic> the asian financial markets are crashing. just as i was about to move some assets from korea to denmark. sigh.
02:21:37 <psykotic> awesome timing.
02:22:05 <psykotic> if adam smith had used haskell, this would never have happened! :)
02:27:59 <nominolo> @seen eivuokko
02:27:59 <lambdabot> eivuokko is in #haskell, #ghc and #darcs. I don't know when eivuokko last spoke.
02:28:13 <nominolo> @tell eivuokko  the tests in configuration are not yet arranged as a test suite
02:28:14 <lambdabot> Consider it noted.
02:30:32 <nominolo> @tell eivuokko the appendVersion thing should work, since the version field is in the top section.  It's af course still ugly.  The problem is, that the internal representation of .cabal files is cannot be printed easily
02:30:32 <lambdabot> Consider it noted.
02:31:00 <dons> psykotic: :)
02:31:12 <dons> yeah, .au markets went down yesterday, back up today
02:31:23 <eivuokko> nominolo, Thanks :)
02:31:23 <lambdabot> eivuokko: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:34:03 <astrolabe> I guess denmark is crashing too.
02:34:32 <wli> What is it, 1929 v2.0?
02:34:57 <JohnMeacham> hello.
02:34:59 <astrolabe> Nothing like yet
02:35:02 <astrolabe> hello
02:35:07 <psykotic> biggest dive since 9/11
02:35:42 <psykotic> i'm waiting for bush to blame iran. :)
02:55:06 <wli> How do you make a nondeterministic choice for every element of a list? e.g. [(2,2),(5,2)] form [[(2,0),(5,0)],[(2,1),(5,0)],[(2,0),(5,1)],[(2,2),(5,0)],[(2,1),(5,1)],[(2,0),(5,2)],...]
02:56:22 <opqdonut> huh?
02:57:01 <wli> opqdonut: making a nondeterministic choice from the range [0..k] where k is the second component of each tuple in the list
02:57:46 <opqdonut> ahh, i think i see now
03:00:17 <bartw> functions need to return the same for everycall, you might need a monad for the random
03:04:18 <DRMacIver> You can do pure random code by basically passing along a sequence that acts as a pseudo-random number generator
03:04:39 <DRMacIver> (I think that's how the stuff in the standard library is structured)
03:05:16 <opqdonut> i'm placing an order to amazon, what books do you recommend
03:07:20 <opqdonut> (any books, fiction, ptogramming, math, anything=
03:07:21 <opqdonut> *)
03:07:41 <roconnor> @djinn ((((a->b)->a)->a)->b)->b
03:07:41 <lambdabot> f a = a (\ b -> b (\ c -> a (\ _ -> c)))
03:12:40 <tonfa> yeah q156 from project euler solved :)
03:13:08 <opqdonut> ?. pl djinn ((((a->b)->a)->a)->b)->b
03:13:09 <lambdabot> f = ap id (flip id . (. const))
03:15:21 <wli> opqdonut: NATO's Secret Armies, Daniele Ganser
03:16:16 <opqdonut> woah, sounds heavy :)
03:16:47 <johnnowak> Perl for Dummies
03:17:06 <opqdonut> nah i already know perl
03:17:07 <opqdonut> :)
03:17:24 <opqdonut> something like sicp might be nice
03:17:24 <wli> opqdonut: It will tell you more about how the world works than any physics or economics book.
03:18:09 <osfameron> opqdonut: beh, if you wanted a Perl book (which you don't, but still) then get Dominus's Higher Order Perl
03:18:26 <opqdonut> is it good?
03:18:42 <opqdonut> i've only read "the camel book" and picked the rest up
03:18:56 <opqdonut> but i think i'll wait for perl6 before diving into that stuff again :)
03:19:35 <ricky_clarkson> I hope never to use Perl again.
03:20:00 <osfameron> opqdonut: he writes very well and there's lots of interesting stuff in it (possibly less interesting if you already do Functional I suppose)
03:20:09 <opqdonut> wli: okay, you persuaded me :)
03:20:11 <wli> opqdonut: FWIW Noam Chomsky gave Ganser guidance of some sort (acknowledged in the preface) while writing the book.
03:20:34 <opqdonut> anything else? bumped into any good metamathematical texts?
03:20:43 * osfameron considers TaPL
03:21:03 <opqdonut> TaPL?
03:21:19 <Saizan> Types and Programming Languages
03:21:43 <opqdonut> is principia mathematica worth owning?
03:22:06 <wli> opqdonut: Mitchell's "Foundations for Programming Languages" did quite a bit for me (I got TaPL after it, so it ended up being largely redundant apart from the parts I couldn't get through for conceptual difficulty reasons recapitulated there as well).
03:22:33 <opqdonut> is "Basic Category Theory for Computer Scientists" any good?
03:22:42 <opqdonut> or "The Haskell Road to Logic, Maths and Programming"
03:22:59 <opqdonut> wli: which one would you recommend then?
03:24:22 <opqdonut> oh yeah, gödel escher and bach
03:24:25 <astrolabe> opqdonut: You probably don't want principia mathematica
03:24:31 <opqdonut> i've been intending to buy it for ages
03:24:34 <wli> opqdonut: There are some areas Pierce's TaPL covers that Mitchell does not, though Mitchell is a substantially larger work overall. I'm not sure whether one should skip to Pierce's new Advanced Topics in lieu of TaPL if covered in tandem with Mitchell.
03:25:09 <osfameron> TaPL has a reputation for being more accessible doesn't it?
03:25:41 <opqdonut> astrolabe: well it's one of those things one should have
03:25:50 <opqdonut> like TAOCP or the bible :)
03:26:19 <wli> opqdonut: The elder texts like that are unenlightening because they're essentially dead ends in terms of ideas. Newer resources tend to give you all the essential ideas they had plus the ways forward without all the dead ends or mistakes (which are not necessarily factual errors, but perhaps "design errors" in a manner of speaking).
03:26:20 <astrolabe> opqdonut: I think it's only of historical interest now, and practically unreadable.
03:26:35 <opqdonut> astrolabe: true, true
03:26:56 <ricky_clarkson> Historial, the new academic.
03:27:02 <ricky_clarkson> +c
03:27:19 <wli> opqdonut: There's not all that much that's even possible to cite from it usefully. It was sadly singularly useless.
03:27:35 <opqdonut> yeah okay
03:27:54 <astrolabe> 'The road to reality' would keep you busy
03:28:10 <wli> opqdonut: If you want to really see what I'm talking about in action, try Johannes Kepler's original works.
03:28:50 <wli> opqdonut: You can actually find OCR scans of the stuff online if you look hard enough (well, maybe I had an inside connection).
03:28:54 <astrolabe> opqdonut: On the other hand, a translation of Newton's Principia might be interesting.
03:29:20 <opqdonut> i think i'll go with TaPL
03:29:45 <wli> astrolabe: I own such. It is not interesting or enlightening. It's a very, very tedious exercise in following 3-dimensional Euclidean geometrical arguments.
03:30:08 <opqdonut> and i'll look into the road to reality :)
03:30:09 <johnnowak> opqdonut: you can't go wrong with TaPL
03:30:16 <ricky_clarkson> Newton expanded pi manually - a lot.  I don't think he'd have been fun at parties.
03:30:17 <DRMacIver> I second that. (I dont own a copy, but I've looked through one)
03:30:41 <astrolabe> wli: Not the bits I've read.  Things like deduction of the shape of the earth.
03:31:17 <astrolabe> I'm prepared to believe there is a lot of tedius geometry though.
03:31:36 <opqdonut> anything else?
03:31:37 <opqdonut> :)
03:31:41 <opqdonut> this is building up nicely
03:31:54 <astrolabe> How about 'Proofs from the book'
03:31:55 <ricky_clarkson> I bought The Interpretation of Dreams by Freud yesterday. ;)
03:31:55 <wli> astrolabe: There are occasional conclusions that it's kind of interesting that he was able to carry out with the tools he was using (though apparently he used fluxions formally to derive results, then geometry later to re-justify them for publication).
03:32:36 <astrolabe> wli: I didn't just mean conclusions, I meant clever arguments.
03:32:47 * johnnowak is still sad amazon cancelled his lisp in small pieces order
03:33:10 <astrolabe> opqdonut: Do you have 'The little schemer'?
03:33:15 <opqdonut> now that we're on this subject, what do you guys think about wolfram's "a new kind of science"
03:33:30 <opqdonut> astrolabe: no, i skipped scheme and jumped straight to haskell :)
03:33:30 <johnnowak> opqdonut: I just sold my copy...
03:33:40 <wli> I found "The Little Schemer" to be relatively useless.
03:33:46 <opqdonut> i've read the sicp, tho
03:33:54 <johnnowak> The Little Schemer is my favorite programming book.
03:34:18 <arcatan> wli: me too, but I still like it
03:34:22 <astrolabe> I read ;the little lisper'  (the previous version) and thought it was really nice.
03:34:53 <astrolabe> I wouldn't describe it as 'useful' perhaps
03:35:10 <johnnowak> It's useful if you don't know Scheme yet
03:35:12 <opqdonut> is it like an introductory text to scheme or what?
03:35:19 <wli> opqdonut: For math relevant to algorithmic analysis, there is Concrete Mathematics and Generatingfunctionology.
03:35:20 <astrolabe> But I think it's good, even for someone who doesn't use scheme.
03:35:43 <johnnowak> There are more advanced versions as well
03:35:55 <wli> I'm not sure it's just for someone who doesn't know Scheme. It seemed almost targeted at someone who doesn't know how to program at all.
03:35:59 <ricky_clarkson> SICP got me to switch from CL to Scheme.
03:36:00 <astrolabe> opqdonut: It is in scheme, so you do get introduced to scheme, but it has more to it than that.
03:36:06 <johnnowak> wli: That's about right, yes
03:36:14 <opqdonut> ok
03:36:59 <johnnowak> juming scheme... tisk tisk
03:37:03 <johnnowak> *jumping
03:37:18 <wli> There's more math-type stuff I could point at. There's always Bulirisch & Stoer.
03:38:46 <astrolabe> Someone should do 'The little lisper' for haskell.  I've seen 'The little haskeller', but it isn't really the same thing, they just pinched the name.
03:38:47 <wli> If you don't even care whether it's technical, I found Kevyn Aucoin's "Making Faces" and "Face Forward" rather enlightening, though it's unclear to me how much interest you'd have in their topics.
03:39:22 <astrolabe> Stephen Pinker's 'The language instinct' is very good in my opinion.
03:39:25 <opqdonut> yeah i think i've got enough in my basket already :)
03:39:39 <opqdonut> astrolabe: oh yeah, i've heard good things about it
03:40:40 <wli> opqdonut: IA64 Linux Kernel is a shockingly good exposition of how both Linux and operating systems in general work via the concrete example of the IA64 port of the Linux kernel.
03:41:07 <opqdonut> is that torvald's?
03:41:16 <opqdonut> ah, no
03:41:18 <opqdonut> mistaking
03:41:25 <wli> opqdonut: No. David Mosberger-Tang and Stephane Eranian IIRC.
03:42:08 <wli> opqdonut: It singlehandedly outdoes numerous basic OS textbooks and various guides to Linux kernel programming.
03:44:48 <wli> opqdonut: IMHO it is to Linux architecture ports what SPJ's book on the implementation of functional programming languages was.
03:45:26 <wli> (to implementing FPL's that is)
03:46:33 <wli> Now I have a list like [[1,2,4],[1,5,25]] and need to form products where one element is chosen from each list in the list of list of numbers.
03:47:04 <xerox> > map product . sequence $ [[1,2,4],[1,5,25]]
03:47:09 <lambdabot>  [1,5,25,2,10,50,4,20,100]
03:47:20 <wli> xerox: Thanks.
03:47:27 <xerox> you're welcome.
03:48:15 <wli> Maybe this can be done a better way: do { (p, k) <- primePowerFactorsL (210^2) ; return $ do { t <- [0..k] ; return (p ^ t) } }
03:50:09 <Saizan> well do { t <- [0..k] ; return (p ^ t) } is just map (p^) [0..k]
03:50:16 <opqdonut> yeah
03:50:33 <opqdonut> wli: SPJ's book?
03:51:21 <xerox> ?pl \f amb -> amb >>= \x -> return (f x) -- wli, those are two fmaps
03:51:21 <lambdabot> fmap
03:52:32 <wli> Thus far I have:
03:52:33 <wli> map product $ sequence $ map (\(p, k) -> [p^t | t <- [0..k]]) $ primePowerFactorsL (30^(2::Int) :: Integer)
03:53:55 <xerox> Looks nice. You can also substitute (.) for ($) except the very last one.
03:54:06 <Saizan> ?src mapM
03:54:06 <lambdabot> mapM f as = sequence (map f as)
03:54:23 <xerox> Good catch :)
03:54:43 <wli> Now down to: map product $ mapM (\(p, k) -> [p^t | t <- [0..k]]) $ primePowerFactorsL (30^(2::Int) :: Integer)
04:08:40 * wli sees some funny patterns in the cyclotomic polynomials \Phi_{10^n}(z)
04:15:18 <byorgey> not surprising, there are lots of funny patterns in the cyclotomic polynomials =)
04:17:00 <wli> Well, this one matters for what I'm thinking about for the moment.
04:22:35 <byorgey> @pl \x -> [x,(x-1)..0]
04:22:35 <lambdabot> flip (ap enumFromThenTo (subtract 1)) 0
04:23:09 <wolverian> heh
04:23:12 <fasta> Is there any way to tell GHCi that it needs to use a maximum of 200MB of memory s.t. it recycles memory? GHCi currently keeps growing and growing and although there is this thing called virtual memory, I'd rather just have it use a maximum of 200MB regardless of how many there is.
04:24:00 <wli> There's a +RTS option for that IIRC.
04:28:55 <EvilTerran> byorgey, alternatively, reverse . enumFrom 0
04:29:15 <EvilTerran> it'd be less efficient, but more obvious in intent
04:29:18 <EvilTerran> *enumFromTo, rather
04:30:01 <byorgey> EvilTerran: yeah, that would work too, but efficiency is important in my application
04:30:21 <byorgey> I was just wondering if it already had a name
04:35:05 <fasta> wli: thanks, I don't know yet whether it recycles memory, but I will find out that soon enough.
04:37:54 <Lamperi> Mui. opqdonut arcatan
04:38:01 <opqdonut> Mui. Lamperi
04:38:06 <arcatan> Mui.
04:43:55 <EvilTerran> byorgey, what about takeWhile (0<=) . iterate pred?
04:44:54 <byorgey> EvilTerran: nice.  it's no shorter of course, but definitely more elegant.
04:45:11 <EvilTerran> :)
04:46:04 <tonfa> how do you get the number of seconds from a timeDiff ?
04:46:58 <byorgey> tonfa: tdSec ?
04:47:21 <tonfa> I'm a newbie, I can't figure out the syntax to do that
04:47:25 <byorgey> @type tdSec
04:47:27 <lambdabot> Not in scope: `tdSec'
04:47:37 <tonfa> @type Time.tdSec
04:47:39 <lambdabot> System.Time.TimeDiff -> Int
04:47:46 <tonfa> ok :)
04:47:54 <tonfa> thanks
04:49:10 <Shooshpanchick> Hi everyone. Can somebody please tell me (or point me to a tutorial) what is the difference between arrows and regular functions?
04:50:33 <roconnor> arrows are an abstract data type, so they may not be functions.
04:50:51 <EvilTerran> they're a generalisation
04:51:05 <roconnor> and if they are functions, an Arr a b may not be the same as a -> b.
04:51:33 <roconnor> A common class of arrorw instantiates Arr a b as a -> m b, where m is a monad.
04:52:00 <EvilTerran> also, comonads!
04:52:33 <opqdonut> yeah, m b -> a
04:52:51 <roconnor> opqdonut, w a -> b
04:52:55 <roconnor> ;)
04:53:00 <opqdonut> yeah okay :)
04:53:03 <Shooshpanchick> Thanks, but I still do not understand :( What are the cases where using arrows will simplify writing a program?
04:53:06 <EvilTerran> .... is that w 'cos it's an upside-down m?
04:53:11 <opqdonut> EvilTerran: yep
04:53:16 <opqdonut> terrible pun isn't it
04:53:19 <EvilTerran> o.Ã³
04:53:23 <Cale> Shooshpanchick: Do you know what a combinator library is?
04:53:51 <Shooshpanchick> No
04:53:51 * roconnor would like to know the answer to that question too.
04:54:54 <Cale> Basically, it's a library whose API is rich enough that programming with that is like using a domain-specific language. A typical combinator library will have some primitive 'computations' together with some way to glue them together into richer ones.
04:55:00 <olsner> why is maximum not strict?
04:55:22 <olsner> or rather, why does it stack overflow where foldl' max 0 doesn't?
04:55:30 <EvilTerran> @src maximum
04:55:30 <lambdabot> maximum [] = undefined
04:55:30 <lambdabot> maximum xs = foldl1 max xs
04:55:41 <Cale> For example, a combinator library for drawing would have various primitive drawings (single lines, for instance), and then some means of combining drawings into more complex ones (on top, beside, etc.)
04:56:53 <Cale> A parser combinator library would have various primitive parsers (for instance, a parser which eats a single character), and then ways to compose parsers into more complex ones (concatenation, selection between parsers, and such)
04:57:26 <Shooshpanchick> Cale, I think I understand, I've seen something like that (parse combinators) implemented in Scala.
04:57:41 <Cale> Monads and Arrows are both templates for combinator libraries that have a specific kind of interface -- a particular means of combination.
04:58:33 <Cale> In an Arrow library, your computations (primitive and otherwise), look sort of like "functions", but might actually be something more sophisticated.
04:59:00 <opqdonut> care to pop a few examples
04:59:18 <Cale> For example, you can define an arrow  data StreamTrans a b = ST ([a] -> [b])
04:59:34 <opqdonut> with a -> m b (>>>) would be bind no?
04:59:52 <Cale> yes
05:00:08 <|Jedai|> EvilTerran: Why is maximum not strict ? Can you imagine a case where it would bring any advantage ? (I can't)
05:00:15 <dolio> A combinator library is a library made of combinators, of course. :)
05:00:20 <dolio> @all-dicts combinator
05:00:21 <lambdabot> *** "combinator" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
05:00:22 <lambdabot> combinator
05:00:22 <lambdabot>  
05:00:22 <lambdabot>         <theory> A function with no {free variables}.  A term is
05:00:22 <lambdabot>         either a constant, a variable or of the form A B denoting the
05:00:24 <lambdabot> [28 @more lines]
05:00:26 <opqdonut> Cale: and with [a] -> [b] arr would be map?
05:00:35 <Cale> opqdonut: right
05:00:35 <EvilTerran> i don't know...
05:00:54 <opqdonut> okay, i think i've understood something, then
05:01:13 <Cale> You might wonder what would lead you to using an arrow-like interface over a monad-like one.
05:01:40 <Saizan> hxt?Ã¹
05:01:47 <Cale> Apart from the additional generality (there are things which are arrows which are not monads), the basic operations on arrows are fundamentally more convenient to do clever optimisations with.
05:02:05 <jedai> EvilTerran: It seems to me like a serious misfeature... There should be a reason, else I don't see how it could have survived until now ?
05:02:07 <roconnor> jedai: peano natural numbers :)
05:02:10 <Cale> With a monad, the right hand parameter to (>>=) is a Haskell function, and those are opaque.
05:02:33 <Cale> So bind can't actually look at the function it's given and decide to do something else.
05:02:37 <jedai> roconnor: Right, didn't think about that
05:02:52 <Cale> However, both parameters to (>>>) are values of the data type you have control over.
05:02:52 <psykotic> cale: re optimizations, in fact an arrow-based framework is very nice for doing fusion over streams.
05:02:53 <roconnor> @type maximum
05:02:58 <lambdabot> forall a. (Ord a) => [a] -> a
05:03:12 <EvilTerran> there should probably be maximum', sum', product', etc in the prelude or something...
05:03:13 <roconnor> jedai: not that I find it a terribly compelling example.
05:03:36 <Cale> So you can do things like have additional constructors which notify (>>>) about the kind of computation being performed and possibly open up more ways to optimise.
05:03:50 <roconnor> @src maximum
05:03:50 <lambdabot> maximum [] = undefined
05:03:50 <lambdabot> maximum xs = foldl1 max xs
05:03:57 <roconnor> @src max
05:03:58 <lambdabot> max x y = if x <= y then y else x
05:04:00 <opqdonut> Cale: okay, i see
05:04:03 <Saizan> in ghc there are rules to use a strict version for the standard numeric rypes
05:04:13 <jedai> roconnor: Not a practical one, but still it's an example where a lazy maximum could be better than a strict one (I won't use such a thing in a real program though...)
05:04:28 <roconnor> jedai: and with that implemenation of max, I'm not sure it would work well for peano numbers.
05:06:13 <jedai> Saizan: That seems like a good idea, but the first question was "Why maximum makes my stack explode ?", so I guess it wasn't with a standard numeric type or not with GHC
05:06:13 <Cale> Also, in things like the stream transformer case, you can do things like integrate the input stream, which is just not something which was available in, say, the list monad.
05:07:55 <Cale> Shooshpanchick: did all that make some level of sense? :)
05:08:23 <olsner> but it was a standard numeric type and it was GHC ;-) anyway, as soon as you need the result of maximum, you'll always need to evaluate every single number in the list to know which is the largest
05:08:33 <opqdonut> Cale: "integrate the input stream"?
05:08:40 <Shooshpanchick> Cale, thanks for explanation! Give me a minute please, I'm still trying to understand :)
05:09:57 <Cale> opqdonut: Well, thinking of the list as a signal or function
05:09:58 <olsner> I'm trying again with the non-strict maximum and compiling and optimizing to see if that does something (the stack overflows I got in ghci while testing stuff)
05:10:03 <Cale> Integrate in the mathematical sense :)
05:10:07 <opqdonut> ahhh
05:10:16 <opqdonut> i thought integrate into smth
05:10:26 <opqdonut> yeah that's the classical arrow example i guess?
05:10:27 <opqdonut> dsp
05:10:31 <Cale> yeah
05:10:41 <Cale> The robotics guys love it :)
05:10:52 <olsner> ah, okay, it worked with -O2
05:11:36 <olsner> but still, that's an optimization you shouldn't even need an optimizer for ;-)
05:12:17 <opqdonut> yeah ghc doesn't do strictness analysis by default
05:12:58 <Cale> olsner: Switching things to use foldl' is often a good tactic if you're having trouble with stack overflows. It's a bit of a shame that there aren't more primed functions around in the Prelude and Data.List.
05:13:09 <opqdonut> yep
05:13:25 <Cale> Collapsing operations like maximum, minimum, sum, product, are things you usually do want strictness for.
05:13:46 <opqdonut> yeah i can't see why the default sum for example is non-strict
05:13:54 <opqdonut> but i guess unneeded strictness can be stupid
05:14:02 <opqdonut> so we err on the side of laziness :)
05:14:06 <Cale> right
05:14:22 <Cale> That laziness could be useful if you have a fancy numeric representation.
05:14:33 <opqdonut> mhmm
05:14:38 <Cale> For the default number types it really is a bit silly though.
05:14:51 <opqdonut> take for example arbitary precision
05:15:01 <Cale> yeah
05:15:10 <opqdonut> :)
05:15:12 <Cale> Or things like power series
05:15:16 <opqdonut> yeh
05:16:13 <Cale> Speaking of functional reactive programming, the new Mathematica looks really cool.
05:18:06 <opqdonut> Cale: is it done in frp?
05:20:40 <Cale> It's very much like an frp system. There's a primitive called Dynamic, and if you wrap an expression in it, the kernel doesn't immediately evaluate it, but instead the frontend gets hold of the expression, passing it back to the kernel for evaluation. The zany bit is that if any of the variables inside that expression later change, the frontend will send it back to the kernel to be reevaluated and displayed dynamicall
05:20:40 <Cale> y.
05:20:52 <Cale> This also applies to things like plots.
05:21:05 <Shooshpanchick> Would it be correct to say that arrows are like functions that know how to compose themselves with other functions?
05:21:18 <opqdonut> Cale: mmh, nice
05:21:21 <ivant> Cale, what have they added there? I used to program in it like 3 years ago, and it was really hard because it didn't have any (usable) debugging facilities
05:21:22 <Cale> In addition to that, there are various expressions which evaluate directly to user interface controls that update values.
05:21:35 <opqdonut> Shooshpanchick: i'd say arrows are a generalization of functions
05:21:56 <opqdonut> and the offered functions are arr that makes an arrow out of a pure func and >>> which does composition
05:22:02 <Cale> To speed that process up, you can wrap things in Manipulate, which will produce a nice little gui for dynamically controlling values.
05:22:05 <Cale> For example,
05:22:31 <Cale> Manipulate[Plot[Sin[a x], {x,0,2 Pi}], {a,1,5,0.1}]
05:22:52 <Cale> Will evaluate to a small gui where you can manipulate the frequency of the plotted sine function in real time
05:22:56 <ivant> Cale, wow, that is really cool
05:23:12 <opqdonut> makes me want to buy a license :D
05:23:16 <hpaste>  kjdf pasted "state monad" at http://hpaste.org/2275
05:23:28 <kjdf> hi
05:23:36 <kjdf> will the above do what I want it to do? :)
05:23:40 <ivant> opqdonut, I considered buying it, but it barely works on linux
05:23:50 <kjdf> I want a stateful, infinite list filter
05:23:52 <ivant> I mean, the gui, not the kernel
05:23:52 <opqdonut> a shame
05:23:58 <kjdf> with state being a map
05:24:14 <Cale> Manipulate[Factor[x^n - 1], {n,1,50,1}] will produce a gui with a slider where you can factor different polynomials :)
05:24:18 <kjdf> I have doubts about "rest <- filt xs; return $ Cons ev rest" part
05:25:07 <Cale> and it scales to things like real time solution of differential equations where you can interactively drag around the initial conditions on the plot itself
05:25:07 <fasta> Cale: Wolfram, is that you?
05:25:18 <Cale> fasta: hehe
05:25:20 <Cale> nope :)
05:25:34 <opqdonut> wow, that sounds really cool
05:25:35 <xerox> kjdf: fmap (Cons ev) (filt xs)
05:25:36 <opqdonut> :)
05:26:21 <Cale> kjdf: have you tried it?
05:26:37 <EvilTerran>  > read "A New Notation for Arrows" :: LearningMaterial
05:26:43 <EvilTerran>  Exception: EvilTerran.read: no parse
05:26:51 <kjdf> Cale: no, I don't know how to check if it works for infinite inputs :)
05:28:09 <Cale> let testStream = Cons (Event KeyPress 'A') (Cons (Event KeyRelease 'A') testStream)
05:28:14 <Cale> something like that?
05:29:11 <Cale> Or even more evil,  testStream2 = Cons (Event KeyPress 'A') undefined
05:29:29 <Cale> and then see if you can observe the first element of the output
05:29:41 <kjdf> that sounds nice
05:29:42 <kjdf> thanks
05:33:23 <osfameron> > foldr (\x y -> case y of { Nothing -> Just x; y -> y }) Nothing "Hello"
05:33:25 <lambdabot>  Just 'o'
05:33:45 <osfameron> that's not quite in the spirit of "rewrite 'last' using 'foldr' is it?"
05:34:31 <opqdonut> > foldr const [1..10]
05:34:33 <lambdabot>  <[[Integer]] -> [Integer]>
05:34:46 <opqdonut> ah
05:34:54 <opqdonut> > foldr const 0 [1..10]
05:34:55 <lambdabot>  1
05:35:02 <opqdonut> > foldl const 0 [1..10]
05:35:03 <lambdabot>  0
05:35:07 <olsner> > foldr1 const [1..10]
05:35:08 <lambdabot>  1
05:35:10 <osfameron> annoying isn't it ?
05:35:13 <opqdonut> :)
05:35:17 <opqdonut> > foldl1 const [1..10]
05:35:19 <lambdabot>  1
05:35:28 <dolio> > foldl1 (flip const) [1..10]
05:35:29 <opqdonut> > foldr1 (flip const) [1..10]
05:35:30 <lambdabot>  10
05:35:31 <lambdabot>  10
05:35:32 <opqdonut> hehe
05:35:35 <opqdonut> yeah, trivial
05:35:39 <osfameron> ah
05:35:43 <osfameron> a flip
05:35:43 <Gwern-away> I am curious. I have a little module acting as a library, and I have an IO function defined taking a function and an argument to that function. the type sig disallows IO stuff. Is there any way, any way at all I can guarantee that the passed-in function will not use the unsafePerform functions to subvert it and perform IO anyway - without modifying the source of whomever is using the module?
05:35:58 <dolio> > foldr (\a f -> const . f a) const [1..10] undefined undefined
05:35:59 <lambdabot>  10
05:36:25 <mauke> Gwern-away: no
05:36:38 <osfameron> @unpl  foldr (\a f -> const . f a) const [1..10] undefined undefined
05:36:38 <lambdabot> foldr (\ a f g _ -> f a g) (\ c _ -> c) [1 .. 10] undefined undefined
05:36:38 <Gwern-away> (I was wondering if there was perhaps some GHC pragma that might do this, but the manual is far too long and complex for me to profitably search)
05:36:45 <EvilTerran> Gwern-away, you can't - that's the point of unsafe*
05:36:46 <osfameron> what's "undefined" ?
05:36:54 <opqdonut> > undefined
05:36:55 <lambdabot>  Undefined
05:36:56 <opqdonut> just that
05:36:59 <xerox> osfameron: it's the value that inhabits all types
05:37:05 <_frederik_> how do i find the adjoints corresponding to a monad? what are they for the probability monad?
05:37:16 <dolio> @src undefined
05:37:16 <lambdabot> undefined =  error "Prelude.undefined"
05:37:18 <osfameron> I thought haskell deliberately didn't have a magic undef type ?
05:37:21 <ricky_clarkson> > sqrt undefined
05:37:22 <lambdabot>  Undefined
05:37:28 <mauke> osfameron: type?!
05:37:38 <osfameron> er... "thingy" ? ;-)
05:37:40 <EvilTerran> Gwern-away, if your users are savvy enough to want to use unsafe, i think you should let them get on with it. ;]
05:37:42 <blackdog_> osfameron: it's not an undefined type, it's an undefined value :)
05:37:46 <opqdonut> :t undefined :: Int
05:37:48 <lambdabot> Int :: Int
05:37:54 <dolio> bottom inhabits all types.
05:37:54 <EvilTerran> > const undefined 3
05:37:56 <lambdabot>  Undefined
05:38:00 <opqdonut> :t undefined :: Maybe (Maybe Char)
05:38:02 <lambdabot> Maybe (Maybe Char) :: Maybe (Maybe Char)
05:38:11 <dolio> Well, except Int#, I suppose.
05:38:12 <EvilTerran> :t undefined
05:38:13 <lambdabot> forall a. a
05:38:14 <dolio> And things like it.
05:38:16 <Saizan> osfameron: you could write it as let x = x in x but it's nicer as an exception
05:38:18 <mauke> the undefined type is forall a. a :-)
05:38:18 <xerox> osfameron: it's here in the report http://haskell.org/onlinereport/exps.html chap. 3.1.
05:38:19 <lambdabot> Title: The Haskell 98 Report: Expressions
05:38:20 <samreid> osfameron: 'undefined' is an optimised infinite loop.
05:38:21 <blackdog_> isn't the canonical def "undefined = undefined" anyway?
05:38:24 <ricky_clarkson> osfameron: Haskell functions may be partial functions.
05:38:33 <Gwern-away> EvilTerran: the point was to have more secure code, not more reliable. heck, security is easy if everyone is going to cooperate!
05:38:36 <blackdog_> uh, what samreid said
05:39:19 <osfameron> heh, "optimised infinite loop"
05:39:30 <EvilTerran> Gwern-away, if you can control what modules they have access to, don't let them import anything unsafe, stop them using the FFI, etc, then.
05:40:13 <EvilTerran> Gwern-away, but trying to be secure while allowing _any_ IO on their part is probably well-nigh impossible
05:40:16 <ricky_clarkson> Gwern-away: My guess is that if you're after a sandbox it'd be worth seeing how lambdabot does it.
05:40:54 <Gwern-away> ricky_clarkson: I already know how lambdabot does it. it basically goes eval() on their code while having done a bunch of 'import unsafeStuff()'
05:41:09 <EvilTerran> Gwern-away, see lambdabot. it doesn't have any IO, which is what you'll need to do if you want security.
05:41:21 <Gwern-away> problem is, the eval stuff is seriously heavy-weight and kind of outdated - hsplugins requires like ghc 6.4
05:41:36 <EvilTerran> (that is, it doesn't have any available to the evaluated expressionS)
05:42:02 <Saizan> ?version
05:42:02 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
05:42:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:42:09 <osfameron> opqdonut: oh, of course - that's the equivalent of foldr1 (\x y -> y) "whatever", which I tried but with "foldr" and then I couldn't work out what type to make init
05:42:22 <opqdonut> :)
05:42:22 <Saizan> darcs hs-plugins works with 6.6
05:42:34 <jedai> foldl (\_ b -> b) undefined
05:42:47 <dons> hey, this looks really good, http://programming.reddit.com/info/2fp4r/comments
05:42:48 <lambdabot> Title: Making the transition from sequential to implicit parallel programming: How sequ ...
05:43:05 <dons> check out the authors, Arvind and Nikhil
05:43:21 <opqdonut> yes?
05:47:18 <Gwern-away> ah, well the darcs version perhaps. I'm on gentoo though and theirs still is like .9 or something
05:48:31 <blackdog_> what are you guys working on for hax day?
05:48:38 <blackdog_> oops, wrong window. sorry.
05:48:44 <blackdog_> what are you guys working on for hax day?
05:48:55 <blackdog_> jesus. i think it's time for me to go to bed.
05:48:56 <Vq^> blackdog_: wrong window again?
05:49:07 <blackdog_> too much excellent beer at the red oak cafe
05:49:16 <blackdog_> it's brewed by trappist monks and it's lethal :)
05:49:23 <Vq^> blackdog_: third times the charm :)
05:50:59 <psykotic> my favorite beard is brewed my blind bearded tibetan amputee nuns
05:51:02 <psykotic> err, beer
05:51:21 <EvilTerran> um.
05:52:58 <ricky_clarkson> On beer, see the hobgoblin brewery in England (they export).
05:59:12 <osfameron> can you pattern match on underined
05:59:14 <osfameron> ?
05:59:21 <osfameron> I get "Warning: Pattern match(es) are overlapped
05:59:25 <dolio> No.
05:59:43 <osfameron> so it's no good as a semipredicate undef
06:00:01 <dolio> How would that work, since undefined could be an infinite loop?
06:00:13 <dolio> If this is an infinite loop, use this branch. :)
06:00:18 <olsner> ... maybe you're looking for the Maybe type
06:00:27 <psykotic> it would be unsound too, in the semantics sense.
06:00:36 <osfameron> well, possibly, but given that undefined was mentioned above I was trying that out
06:00:50 <Cale> osfameron: evaluating undefined will cause your program to die in some fashion (unless it's explicitly caught in IO)
06:00:53 <EvilTerran> undefined is a lack of value, rather than a concrete non-value
06:00:55 <osfameron> I'm trying to do the "define 'init' using 'foldr'" counterpart to the above
06:00:55 <xerox> osfameron: the page I linked you explains how undefined works in Haskell exactly.
06:01:20 <Cale> osfameron: undefined is treated in a similar way to a nonterminating computation
06:01:29 <Vq^> ricky_clarkson: i like that one too
06:01:46 <Cale> (except that as defined in the prelude, it just throws an exception)
06:02:06 <xerox> ?type let undefined = undefined in undefined
06:02:08 <lambdabot> forall t. t
06:02:17 <osfameron> Cale: though only when used?
06:02:26 <EvilTerran> > const undefined 3
06:02:27 <lambdabot>  Undefined
06:02:28 <Cale> osfameron: right
06:02:38 <Cale> > let f x = 5 in f undefined
06:02:39 <lambdabot>  5
06:02:42 <roconnor> in haskell' can we rename head into unsafeHead :P
06:02:47 <EvilTerran> > if 0 == 1 then undefined else "foo"
06:02:48 <lambdabot>  "foo"
06:02:53 <Cale> > let f Nothing = 0; f (Just x) = 5 in f undefined
06:02:54 <lambdabot>  Undefined
06:02:56 <psykotic> roconnor, there's already something called that :)
06:02:59 <psykotic> @hoogle unsafeHead
06:02:59 <Cale> > let f Nothing = 0; f (Just x) = 5 in f (Just undefined)
06:02:59 <lambdabot> No matches found
06:03:00 <lambdabot>  5
06:03:07 <roconnor> psykotic: there is?
06:03:09 <psykotic> hmm. i thought there was.
06:03:09 <EvilTerran> > length [undefined, undefined, undefined]
06:03:11 <lambdabot>  3
06:03:19 <psykotic> i could swear i saw some in some of don's optimized code
06:03:21 <EvilTerran> > head (3 : undefined)
06:03:22 <lambdabot>  3
06:03:31 <roconnor> psykotic: unsafeHead is defined for bytestrings
06:03:36 <EvilTerran> > tail (undefined : [1..10])
06:03:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:03:46 <psykotic> roconnor, ah right, that's what i remembered.
06:03:54 <roconnor> psykotic: but does bytestrings have a head?
06:04:09 <psykotic> well, they have a first element :)
06:04:22 <roconnor> psykotic: even the trival bytestring?
06:04:27 <psykotic> no. hence the unsafe.
06:04:34 <roconnor> or maybe unsafeHead is even more unsafe than head.
06:04:45 <SamB_XP> quite
06:04:49 <psykotic> oh, you mean like sans bounds check?
06:04:51 <opqdonut> ?remember roconnor or maybe unsafeHead is even more unsafe than head.
06:04:52 <roconnor> maybe unsafeHead can dereference null pointers.
06:04:52 <lambdabot> Done.
06:04:58 <SamB_XP> psykotic: exactly
06:05:00 <opqdonut> ?quote Head
06:05:00 <lambdabot> ghc says: Malformed context in instance header
06:05:05 <opqdonut> bluh
06:05:25 <SamB_XP> ?quote head
06:05:26 <lambdabot> ghc says: Malformed context in instance header
06:05:29 <SamB_XP> ?quote head
06:05:29 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
06:06:59 <roconnor> ?quote roconnor
06:06:59 <lambdabot> roconnor says:  O(n) is slow when n=infinity
06:07:14 <opqdonut> :D
06:07:19 <opqdonut> ?quote roconnor
06:07:19 <lambdabot> roconnor says: If one wants to go swimming with sharks, or program in a non-pure langauge, I suppose that is one's choice
06:07:47 <osfameron> > foldr (\x y -> case y of { Nothing -> Just []; Just y' ->  Just (x:y')} ) Nothing  "Wibble"
06:07:49 <lambdabot>  Just "Wibbl"
06:08:02 <roconnor> ?quote forbid
06:08:03 <lambdabot> No quotes match. Just what do you think you're doing Dave?
06:08:20 <opqdonut> ?quote qwe1234
06:08:20 <lambdabot> qwe1234 says: the only reason for 'dispatching, polymorphism and parametrization' to exist at all is for enforcing safety.
06:08:39 <osfameron> I can't think of a way to do "init" without a proper predicate false like Nothing
06:09:48 <opqdonut> > let a = "Wibble" in zipWith const a (tail a)
06:09:50 <lambdabot>  "Wibbl"
06:09:52 <opqdonut> :
06:09:54 <opqdonut> )
06:10:13 <osfameron> cute :-)
06:10:40 <opqdonut> > init [1..]
06:10:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:10:55 <opqdonut> yeah the standard one works for infinite ones too
06:10:55 <osfameron> though I meant "'init' using 'foldr'"
06:10:58 <opqdonut> ?src init
06:10:59 <lambdabot> init [x]    = []
06:10:59 <lambdabot> init (x:xs) = x : init xs
06:10:59 <lambdabot> init []     = undefined
06:12:22 <EvilTerran> > (\xs -> foldr (\x e -> (++ e [x])) (const []) xs []) $ "abcdefg"
06:12:23 <lambdabot>  "abcdef"
06:12:35 <dons> http://augustss.blogspot.com/2007/08/what-about-arrays-after-doing-my-little.html
06:12:38 <lambdabot> Title: Things that amuse me, http://tinyurl.com/3y5m5z
06:12:40 <xerox> ap (++) return
06:14:54 <DRMacIver> augustss: That's the most awful syntax hack I've seen in quite a while.
06:14:58 <DRMacIver> augustss: I salute you for it. :)
06:15:49 <osfameron> EvilTerran: eeeek!
06:16:03 <EvilTerran> > tail . ($undefined) . foldr (\x e -> (:e x)) (const []) $ "abcdefg"  -- any better? :P
06:16:05 <lambdabot>  "abcdef"
06:16:31 <xerox> flip (:)
06:16:34 <osfameron> not in the slightest, thanks :-)
06:16:42 <EvilTerran> i'm still wondering if i can come up with a nicer version...
06:17:20 <mauke> :t ($ ?x) + ($ ?y)
06:17:22 <lambdabot> forall a b. (?x::a, ?y::a, Num ((a -> b) -> b)) => (a -> b) -> b
06:18:30 <xerox> mauke: summing continuations? (:
06:20:01 <gwern> just a  kind of randomq uestion - can anyone think of a way to approximat the effects of chroot without actually requiring escalated privileges?
06:20:05 <mauke> *Main> (\x y -> ($x) + ($y)) 1 2 id
06:20:05 <mauke> 3
06:20:13 <dons> gwern: use the type system to enforce no IO?
06:20:53 <dons> > readFile "/etc/passwd" -- like that -- a compile-time chroot :)
06:20:53 <lambdabot>  Unbalanced parenthesis
06:20:54 <mauke> the only problem is that I can't omit the parens
06:21:07 <dons> > readFile "/etc/passwd"
06:21:08 <lambdabot>  <IO [Char]>
06:21:12 <gwern> dons: haven't you ever heard of defense in depth :)
06:21:32 <dons> well, you asked for a solution that doesn't involve privs.
06:21:44 <gwern> dons: best to assume that  the tyupe system can be broken, thanks to the unsafe functions, I should think
06:21:45 <dons> :) static analysis to prevent attacks works for me :)
06:21:58 <dons> gwern: right, you must also provide only a trusted base of functions
06:22:10 <dons> you've seen the wiki page on the safe subset, and how to achieve it?
06:22:18 <gwern> dons: yeah, but your stuff is using hs-plugins to eval stuuff in a given conntext
06:22:23 <dons> yep.
06:23:26 <xerox> mauke: well, you can, if you define a flip ($) combinator
06:24:21 <augustss> DRMacIver: glad you (dis-)like my syntax hack :)
06:24:24 <gwern> and I was hoping for a bettter solution, honesstly. I find it hardd to believe that ther'es no way to tell ghc too avoid allowing in any functions tainted byy unsafe stuff - it just seems a bit one-sided to allow you to be confiddent in your own coed - you can go 'import unsafeWhatever()' and be sure - but not allowt hat to be a condition for other peoples's code
06:24:36 <mauke> xerox: but I want perl syntax
06:24:52 <dons> augustss: its pretty cool :)
06:25:04 <dons> a[0] -- evil too
06:25:43 <EvilTerran> gwern, if you don't want unsafe*, you don't let people import unsafe*. that's all there is to it. i honestly don't see the problem.
06:25:45 <DRMacIver> Yeah. :) I like it, it's just evil.
06:26:13 <shapr> @yow !
06:26:13 <lambdabot> Uh-oh!!  I forgot to submit to COMPULSORY URINALYSIS!
06:26:13 <gwern> EvilTerran: how would one do that (in the hypothetical solution that doesn't iinvolve eval)?
06:27:06 <augustss> dons: I'm always looking for new ways to abuse Haskell :)
06:27:38 <dons> hehe :D
06:27:45 <dons> we should run another iohcc
06:27:55 <dons> though i'm a bit scared to enter now ...
06:27:58 <EvilTerran> i don't know enough about your situation to be able to give a more detailed answer, TBH. if this is something like a CGI script, you could run with ghc -i -i/path/to/safe/modules/only, say.
06:27:59 <osfameron> iohcc?
06:28:08 <dons> obfuscated haskell code contest
06:28:14 <Tchakkazulu> > uncurry (foldr ((flip (:) .) . flip id) (const [])) . (tail &&& head) $ [1,2,3,4,5,6]
06:28:15 <dons> we had one in 93, then in 03 and 04
06:28:16 <lambdabot>  [1,2,3,4,5]
06:28:24 <osfameron> ah... I thought haskell code was obfuscated already...
06:28:37 <mrd> you haven't met pl then
06:29:15 <dons> augustss: a file that was valid C and Haskell would be cool :)
06:29:19 <gwern> EvilTerran: that's a thought, certainly. I was looking for a way to do it 'within haskell' so to speak, in the source files, and not outside with flags and such. but that might work for some situations and so is worth remembering
06:29:25 <ihope> Haskell is easy to obfuscate!
06:29:34 <dons> ?wiki Obfuscation
06:29:34 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
06:29:46 <dons> the iohcc links are down though.
06:29:53 <dons> need to get them from shapr's harddrive
06:29:58 <augustss> dons: that could prove difficult for anything non-trivial
06:30:05 <ihope> Just find obscure isomorphisms between unrelated parts of your code and use the same weird function for both.
06:30:21 <dons> augustss: i imagine so!
06:30:27 <EvilTerran> gwern, i know of no way of securing things in _any_ programming language beyond an eval-like sandbox or something outside the interpreter
06:31:06 <mauke> dons: easy if you use literate syntax :-)
06:31:20 <dons> that's cheating though :)
06:31:37 <gwern> eeviI can't bbelieve thjat, if only because you could do it were the unsafe functions removed fromm the haskell libraries and the ttype system actually enforced
06:31:38 <dons> there's a file somewhere that's valid sml, haskell and something else, that uses lots of comment tricks like this
06:31:52 <ihope> And then generalize inappropriate functions and use your general ones instead of the specific ones.
06:32:00 <thoughtpolice> anybody seen that file that's valid in like 10 languages, all with the same effect?
06:32:07 <gwern> (that was addressed to EvilTerran, that last. just my system is under heavy load now compiling ghc-darcs and so typing is getting hard)
06:32:13 <ihope> thoughtpolice: I think I have.
06:32:25 <mauke> I'll show it to you as soon as my dns updates
06:32:30 <ihope> It had a long comment at the beginning with really crazy comment markers :-)
06:32:44 <SamB_XP> ihope: I'd imagine
06:32:47 <thoughtpolice> it was pretty, uh, ridiculous to say the very least. :) all you had to do was give it a new extension and recompile
06:32:52 <mauke> dons: http://mauke.ath.cx/stuff/poly.poly
06:33:22 <ihope> That's not the one I saw.
06:33:29 <mauke> :(
06:33:52 <thoughtpolice> yeah the one I saw was pretty distinguisable.
06:34:09 <thoughtpolice> distinguisable in the sense it gave me a headache beyond all reason.
06:34:59 <mauke> anyway, my version does shell, ruby, perl, tcl, make, c, c++, haskell, brainfuck, python, perl6
06:35:02 <mauke> and broken html
06:35:04 * gwern cursess libHSBase. A load off 17 jjust for ar processing it?!
06:35:09 <ihope> > main :: IO () -- -- \
06:35:09 <lambdabot>   Not in scope: `main'
06:35:14 <ihope> Nice comment at the end, no?
06:35:22 <SamB_XP> C/C++ is nothing
06:35:32 <SamB_XP> people do that in *production* code *all the time*
06:35:37 <mauke> SamB_XP: but it detects the difference
06:36:01 <mauke> i.e. it prints different things depending on what you compile it as
06:36:23 <EvilTerran> > fromJust . foldr (\x -> Just . maybe [] (x:)) Nothing $ "Wibble"  -- osfameron, how about this? based on your version...
06:36:24 <lambdabot>  "Wibbl"
06:36:39 <DRMacIver> mauke: Dare I ask how it manages that?
06:36:44 <SamB_XP> mauke: even so
06:36:47 <thoughtpolice> black ninja magic.
06:37:00 <DRMacIver> thoughtpolice: As far as I'm concerned, all C++ is black ninja magic. :)
06:37:01 <EvilTerran> #ifdef CPLUSPLUS?
06:37:08 <fasta> How can I see what is importing IO?
06:37:09 <SamB_XP> mauke: the only reason people don't do that in production code is that they don't WANT to do that
06:37:19 <mauke> DRMacIver: char X; int main(void) { struct X { a[2]; }; ... check sizeof (X)
06:37:23 <thoughtpolice> DRMacIver: :)
06:37:39 <fasta> I already have import qualified Prelude hiding (IO)
06:37:49 <DRMacIver> mauke: Ew.
06:38:00 <osfameron> EvilTerran: gosh... I think I even understand howt hat works!
06:38:04 <mauke> what
06:38:07 <osfameron> > fromJust Nothing
06:38:08 <lambdabot>  Exception: Maybe.fromJust: Nothing
06:38:13 <SamB_XP> mauke: why don't you use the convenient cpp definition instead of that crazy shit?
06:38:14 <osfameron> > fromJust (Just 4)
06:38:15 <lambdabot>  4
06:38:29 <osfameron> :t maybe
06:38:30 <thoughtpolice> has anybody read "Purely Functional Data Structures" ('96 Okasaki)? I was going to read it but I was wondering if anybody had any comments on it...
06:38:31 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:38:33 <mauke> SamB_XP: because, strictly speaking, the macro is not reliable
06:38:43 <mauke> SamB_XP: nothing says a C compiler can't define __cplusplus
06:38:47 <ihope> fasta: hide IO everywhere else too?
06:39:05 <SamB_XP> mauke: my pitchfork says that
06:39:18 <fasta> @src IO
06:39:18 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
06:39:19 <ihope> import Data.List hiding (IO)
06:39:23 <osfameron> thoughtpolice: the first chapter is very readable, and the one on Red Black trees is decipherable.  I don't have the background to find much of the rest of it comprehensible though.
06:39:33 <mauke> @index IO
06:39:33 <lambdabot> System.IO, Prelude
06:39:39 <SamB_XP> same thing that says that Haskell implementations need to do TCO and GC ;-)
06:39:44 <ihope> Oh my, State# RealWorld.
06:40:04 <fasta> Oh, that's great. Long live the Haskell module system.. [/sarcasm]
06:40:17 <SamB_XP> they probably should rename RealWord to FakeWorld ;-P
06:40:19 <ihope> @src RealWorld
06:40:20 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:40:40 <fasta> If I hide IO from one module, why would it still import that _same_ IO from another module?
06:40:56 <thoughtpolice> osfameron: hm thanks.
06:40:58 <fasta> Is there some efficiency reason for that?
06:41:10 <ihope> Import everything qualified?
06:41:24 <SamB_XP> fasta: heck no
06:41:28 <fasta> It seems like the module system is designed to annoy the use.
06:41:30 <klein> thoughtpolice: it's a great book if you're a data-structure nut... but it's definitely pretty advanced stuff
06:41:32 <fasta> user*
06:41:57 <klein> thoughtpolice: there's a nice treat though, in that it's got full haskell source in the appendix
06:42:02 <SamB_XP> 'tis a secret plot to get someone to design a nicer one
06:42:08 <kowey> Cale: do you remember when you first wrote 'Monads as containers'?
06:42:16 * kowey is building a history of monad tutorials
06:42:16 <Cale> kowey: yeah
06:42:18 <Cale> oh
06:42:22 <Cale> hmm.. :)
06:42:42 <kowey> remember the date?
06:42:50 <SamB_XP> is there a tutorial on history monads too?
06:43:02 <Cale> Summer 2004
06:43:09 <fasta> SamB_XP: If that's the case, that's ok.
06:43:19 <Cale> So, perhaps July or August
06:43:27 <kowey> thanks! (unfortunately, it's mostly just a list of dates, no analysis)
06:43:42 <kowey> would be curious to know when YAHT first came out... 2002?
06:43:59 <SamB_XP> kowey: is it at least a list of dates and links?
06:43:59 <Tchakkazulu> A history monad sequences side-effects in reverse order *nod*
06:44:13 <thoughtpolice> klein: fun stuff. :) i'll give a shit and going through it, although I don't know how far I'll get.
06:44:17 <kowey> yeah, dates and links
06:44:20 <kowey> and blurbs
06:44:23 <evir> Doesn't GHC 6.6 have a native code generator on AMD64? Using "ghc -v -c" I always see it compiling .hc files using gcc, even when I use -fasm. This shouldn't be if code was generated directly, should it?
06:44:29 <thoughtpolice> s/shit/shot/ :x
06:44:55 <SamB_XP> evir: no, it should not be
06:45:27 <xerox> Tchakkazulu: I wonder if you could make a general transfomer out of that. BackwarsT m a.
06:45:38 <klein> thoughtpolice: hehe
06:46:14 <thoughtpolice> klein: can you recommend any other books on the subject? i'll say i'm not exactly savvy on 'advanced' math.
06:46:43 <evir> SamB_XP: Is there an easy way to find out if probably my GHC binary has been built without support for native code generation?
06:47:01 <SamB_XP> evir: not yet afaik
06:47:02 <Tchakkazulu> xerox: Would be nifty. And BackwardsT Backwards a ~= Identity, or something like that.
06:47:05 <kowey> would also appreciate a link to the paper that 'started it all' if possible
06:47:25 <Tchakkazulu> kowey: YAHT is indeed 2002, according to the pdf :)
06:47:48 <kowey> well, it could have been an updated version, but that's what hal has it down as
06:47:57 <Tchakkazulu> True.
06:49:08 <klein> thoughtpolice: well, a lot of the book has to do with first amortizing a data structure, then modifying the amortized data structure to become worst-case fast... are you familiar with amortization?
06:50:25 <fasta> klein: are you talking about Okasaki's book?
06:50:54 <klein> yep, okasaki's book
06:51:10 <fasta> I think Okasaki's proofs are trivial when compared to the more classic data structures.
06:51:45 <fasta> That's not surprising, since most of Okasaki's structures are less general.
06:52:10 <osfameron> @unpl fromJust $ foldr (\x -> Just . maybe [] (x:)) Nothing "Wibble"
06:52:10 <lambdabot> (fromJust (foldr (\ x f -> (Just) (maybe [] (\ a -> x : a) f)) Nothing "Wibble"))
06:52:45 <klein> hmm yeah i'll yield to you on that... i should have made the disclaimer that data structures make my brain hurt
06:53:20 <fasta> augustss: I liked you hack too, btw. I improved on your "Cond" type class you wrote some time ago, btw.
06:54:12 <klein> once i hit the part about using scheduling to eliminate amortization, i went from "learning how" mode to "learning that" mode
06:54:44 <kowey> http://koweycode.blogspot.com/2007/08/history-of-monad-tutorials.html <-- there... now maybe I can the evil voices in my head to shut up and get back to work
06:54:46 <lambdabot> Title: koweycode: a history of monad tutorials, http://tinyurl.com/33jqap
06:55:00 <fasta> Hmm, so much for interactive development....
06:55:10 <fasta> Loading a module takes > 30 seconds....
06:55:52 <thoughtpolice> klein: a little bit.
06:56:06 <augustss> fasta: how did you improve on Cond?
06:56:46 <fasta> augustss: you can give it a Bool or a m Bool, and it requires zero type annotations
06:56:56 <thoughtpolice> klein: at the very least, the definition. it's finding the running time of a series of operations which are all worst case, right?
06:57:07 <fasta> Heap exhausted;
06:57:07 <fasta> Current maximum heap size is 299999232 bytes (286 Mb);
06:57:14 <mrd> thoughtpolice: yes
06:57:18 <fasta> GHC is a resource hog.
06:57:28 <fasta> This is just while loading a module...
06:57:31 <evir> Hm it generates native code on i386 but compiles via C on amd64, strange.
06:57:42 <mrd> thoughtpolice: er, I have a copy. it's also in pdf.
06:57:48 <augustss> fasta: i found the tricky part to be when you need different kinds of booleans with different kinds of values
06:58:26 <klein> thoughtpolice: with just the experience of an intro. algorithms class under my belt, the stuff in the book seemed reachable
06:58:54 <thoughtpolice> klein: i can say i've had no such experiance (last year high school :x)
06:59:51 <klein> thoughtpolice: just to be clear, the entire sequence of operations is worst-case time, but not necessarily any one operation (could be up to O(n) higher)
07:00:09 <thoughtpolice> i've been trying to get through knuth's book (concrete mathematics) although I still feel a bit of it is out of my reach. perhaps i'm just reading into it too much and just need to give it a light first over
07:00:12 <fasta> augustss: I cannot find your Cond blog posting, now.
07:02:14 <thoughtpolice> klein: in the sense that one operation may perform 'okay,' but in the whole you're dealing with "worst case" since it'll all add up, right?
07:02:17 <klein> i just skimmed through the okasaki book again... the first 4 chapters ought to be a breeze for any haskeller... 5 and 6 introduce amortization, then 7 and beyond gets hairy
07:03:38 <klein> thoughtpolice: hmm.  imagine you're doing N operations, the first of which costs N+1, but all the others 1...
07:04:18 <klein> thoughtpolice: the overall cost of the whole sequence is 2N... so you can think of the operation as having an amortized cost of 2
07:04:38 <mrd> the amortization work is good to know
07:04:45 <klein> thoughtpolice: even though one operation took O(N) time, in the amortized sense it was constant
07:05:29 <mrd> Edison is an implementation of data structures based off of Okasaki
07:05:38 <mrd> you can grab that too
07:06:26 <thoughtpolice> klein: hm okay.
07:07:16 <thoughtpolice> klein: i'll give the book a go. :) at the very least I should get something out of it, hopefully.
07:07:26 <byorgey> thoughtpolice: Concrete Mathematics is (IMO) one of those books where you can't possibly get everything there is to get out of it in one reading.  So don't be afraid to just read over it, get what you can, and come back later for more.
07:07:52 <byorgey> thoughtpolice: I'm in chapter 8, been working through it off and on for the past 2 years =)
07:08:03 <klein> are there any obvious examples of amortization in haskell?  (++) ?
07:08:23 <thoughtpolice> byorgey: thanks. :) i really want to get better at math and I like knuth's stuff, so I decided to grab a copy of it. i also want to get a copy of is "Selected papers in computer science" as well...
07:08:42 <thoughtpolice> steve yegge had a good blog post over math for programmers so i've been aiming to get better at it.
07:09:40 <byorgey> thoughtpolice: a laudable goal.  math rocks. =)
07:09:59 <Tchakkazulu> > fix (foldr ((const .) . flip id) id xs) [1..5]
07:10:00 <lambdabot>   Not in scope: `xs'
07:10:15 <Tchakkazulu> > fix (\xs -> (foldr ((const .) . flip id) id xs)) [1..5]
07:10:16 <lambdabot>  Couldn't match expected type `[b]' against inferred type `b -> b'
07:10:26 <Tchakkazulu> -_-
07:11:23 <oerjan> @unpl (const .) . flip id
07:11:23 <lambdabot> (\ i l _ -> l i)
07:12:30 <mrd> anything involving re-balancing ... or an array-based structure where you double the size of the array whenever you run out of space
07:12:32 <oerjan> :t foldr ((const .) . flip id) id
07:12:34 <lambdabot> forall b. [b] -> b -> b
07:12:35 <Tchakkazulu> > fix . foldr ((const .) . flip id) id $ [1..5]
07:12:37 <lambdabot>  5
07:13:11 <byorgey> o.O
07:14:21 <dolio> Cute.
07:15:16 <dolio> I guess fix looks nicer than undefined? :)
07:15:30 <Tchakkazulu> Looks more "advanced" ;)
07:15:47 <Tchakkazulu> On an empty list it's still _|_, so why not.
07:15:56 <fasta> I do a computation in WriterT and call "tell", but before the computation completes, it calls error. When I put unsafePerformIO(putStrLn "test") below the tell line, "test" gets printed, but I can never read the partially created log value from the writer. It seems the writer is too strict.
07:16:22 <klein> ah, i see.  Data.Sequence is an interesting place to look for amortization in GHC
07:17:03 <dolio> In 6.7 there is C.M.Writer.Lazy and .Strict.
07:17:18 <fasta> dolio: and what is the default?
07:17:26 <dolio> Hmm, not sure.
07:17:34 <dolio> @source Control.Monad.Writer
07:17:35 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Writer.hs
07:17:40 <fasta> I suspect Lazy is default
07:17:49 <dolio> Yep.
07:18:23 <fasta> Maybe I should use a String, instead of a difference list?
07:18:33 <dolio> I don't know which the older version was, though, if that's what you're using.
07:18:42 <fasta> I use 6.7
07:18:47 <dolio> Ah, I see.
07:19:02 <dolio> Truth be told, I'm not sure I understand Writer that well.
07:19:10 <dolio> I don't use it much.
07:19:13 <fasta> I think the difference lists are the problem
07:34:10 <shapr> @yow !
07:34:10 <lambdabot> I'm totally DESPONDENT over the LIBYAN situation and the price of CHICKEN ...
07:34:12 <shapr> @users
07:34:13 <lambdabot> Maximum users seen in #haskell: 385, currently: 371 (96.4%), active: 11 (3.0%)
07:34:20 <shapr> So, what's everybody doing?
07:34:27 <shapr> It's a beautiful day for code!
07:38:44 <shapr> Has anyone thought about using http://okmij.org/ftp/Haskell/generics.html#unreal-traverse for QuickCheck?
07:38:45 <lambdabot> Title: Generic functions and Open data types
07:39:07 <shapr> Or maybe SmallCheck?
07:42:23 <shapr> Oh, I think that only does minBound and maxBound
07:42:30 <shapr> never mind...
07:44:06 <shapr> So, anyone writing any interesting code?
07:44:13 <fasta> Is there a way to get runWriter (do tell "hi"; return undefined) to return (**exception***", "hi")?
07:44:44 <fasta> Now, it returns (**exception***", <no output>)?
07:45:38 <int-e> fasta: uh you're printing (undefined, "hi")
07:45:42 <oerjan> > snd . runWriter $ do tell "hi"; return undefined
07:45:44 <lambdabot>  "hi"
07:45:56 <fasta> int-e: yes, I know that.
07:46:22 <oerjan> that actually works, please rephrase
07:46:55 <fasta> oerjan: what works?'
07:47:00 <int-e> fasta: so your problem has nothing to do with the writer monad at all.
07:47:08 <oerjan> i just demonstrated
07:47:22 <fasta> oerjan: FYI, I already wrote that code, before I asked.
07:48:01 <fasta> I am not sure, how exactly, but it stops working in larger programs.
07:48:27 <fasta> I only ask for the "log" and still I get an error value without a partial log.
07:48:39 <norpan> it doesn't _return_ (**exception***", <no output>), it _prints_ it
07:48:42 <int-e> fasta: you're looking at replacing the Show class really, presumably by something that has a show' :: a -> IO () and wraps eval up somehow.
07:49:44 <fasta> int-e: I know that's not how it currently works, but essentially ghci gives up too soon.
07:49:44 <oerjan> it will probably fail if an actual _action_ becomes undefined
07:49:48 <int-e> that Control.Exception.evaluate
07:50:01 <oerjan> > snd . runWriter $ do tell "hi"; undefined
07:50:01 <int-e> fasta: it doesn't. ghci prints a string that is the result of show
07:50:02 <lambdabot>  Undefined
07:50:16 <int-e> fasta: and that string is '(':_|_. there's nothing beyond that that ghci could print.
07:50:27 <fasta> int-e: right, ok, then show gives up too soon.
07:50:35 <oerjan> hm...
07:50:40 <int-e> fasta: I disagree strongly
07:50:44 <oerjan> > take 2 . snd . runWriter $ do tell "hi"; undefined
07:50:45 <lambdabot>  Undefined
07:50:57 <int-e> fasta: show does the best given it's limitations: a) the result is a string b) show is pure.
07:50:57 <fasta> oerjan: right, that's what I am seeing.
07:51:04 <int-e> s/it's/its
07:51:08 <ihope> putStr (undefined ++ "foo")
07:51:16 <oerjan> the last one _could_ have worked, i think
07:51:47 <fasta> oerjan: it does work here, btw
07:51:54 <fasta> oerjan: so, it must be something else.
07:52:21 <oerjan> ok so that was probably fixed by making Writer lazy
07:52:31 <ihope> What works there?
07:52:32 <fasta> oerjan: right
07:52:38 <oerjan> which lambdabot presumably doesn't use yet
07:52:43 <fasta> int-e: snd . runWriter $ do tell "hi"; undefined
07:52:47 <fasta> ihope: snd . runWriter $ do tell "hi"; undefined
07:52:49 <fasta> int-e: sorry
07:53:52 <oerjan> you would probably need take 2 . if lambdabot was lazy there, since it does checks on the returned string
07:54:32 <ihope> let assert True = return () in do assert reallyImportantThing; doSomethingDangerous
07:55:17 <ihope> If reallyImportantThing is false, assert gives an error, halting the program before it doesSomethingDangerous.
07:56:00 <fasta> Are difference lists lazy?
07:56:06 <int-e> oh was that fixed in ghc 6.6.1?
07:56:56 <dolio> > let (a,b) = undefined in (a,b) `seq` ()
07:56:57 <lambdabot>  ()
07:57:45 <int-e> > take 2 . snd . Control.Monad.Writer.runWriter $ do tell "hi"; undefined
07:57:47 <lambdabot>  Undefined
07:57:53 <int-e> that one is strange.
07:57:58 <ihope> Cool, it's the seq bug-inducer :-)
07:58:26 <Tchakkazulu> Indeed, that's not really what seq is supposed to do...
07:58:31 <ihope> No, it is.
07:58:40 <Tchakkazulu> It is?
07:58:44 <int-e> > (undefined, undefined) `seq` ()
07:58:45 <dolio> take 2 ("hi" ++ undefined)
07:58:46 <lambdabot>  ()
07:58:47 <ihope> That's essentially setting a to undefined and b to undefined.
07:58:48 <dolio> > take 2 ("hi" ++ undefined)
07:58:49 <lambdabot>  Undefined
07:59:00 <oerjan> whoops
07:59:04 <ihope> Therefore, it's (undefined, undefined) `seq` ().
07:59:08 <oerjan> ah...
07:59:10 <Tchakkazulu> Oooh.
07:59:14 <oerjan> ++ is not lazy enough?
07:59:21 <oerjan> > take 1 . snd . runWriter $ do tell "hi"; undefined
07:59:23 <lambdabot>  "h"
07:59:27 <ari> @src (++)
07:59:27 <lambdabot> (++) []     ys = ys
07:59:27 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
07:59:28 <ihope> > take 2 ("foo" ++ undefined)
07:59:29 <lambdabot>  "fo"
07:59:33 <ihope> > take 3 ("foo" ++ undefined)
07:59:34 <lambdabot>  Undefined
07:59:37 <oerjan> it was ++ that was in error...
07:59:48 <Tchakkazulu> Hmm...
07:59:52 <chessguy_work> would it be going to far to say that >>= has different semantics for each monad?
07:59:55 <ihope> > take 3 ('f' : 'o' : 'o' : undefined)
07:59:57 <lambdabot>  "foo"
07:59:59 <int-e> interesting, maybe this has something to do with dons' rewrite of the list fusion stuff.
08:00:19 <oerjan> chessguy_work: no
08:00:23 <byorgey> chessguy_work: sounds right to me.
08:00:26 <ihope> chessguy_work: nope. It does have different semantics for each monad.
08:00:48 <fasta> chessguy_work: it can do everything as long as it adheres to the laws.
08:00:50 <chessguy_work> ok, i just wasn't sure if semantics was the word i wanted
08:01:01 <fasta> chessguy_work: so, I would say "no".
08:01:11 <fasta> chessguy_work: I mean "yes"
08:01:25 <chessguy_work> ...
08:01:32 <chessguy_work> yes, it's going too far?
08:01:36 <dmead> HELLO FRIENDS
08:01:54 <chessguy_work> hi dmead
08:02:16 <dolio> Hmm...
08:02:17 <ihope> "foo" ++ undefined = 'f' : "oo" ++ undefined = 'f' : 'o' : "o" ++ undefined = 'f' : 'o' : 'o' : "" ++ undefined = 'f' : 'o' : 'o' : undefined
08:02:20 <balodja> What does the acronyms "lhs" and "rhs" in math-literature stand for?
08:02:29 <ihope> balodja: left hand side, right hand side.
08:02:36 <balodja> thanks
08:02:53 <chessguy_work> what do you think we are, mathemticians? :)
08:03:08 <chessguy_work> not writers, judging by my spelling today
08:03:11 <ihope> More likely that we're mathematicians.
08:03:19 <balodja> Hm-m-m, I think so.
08:03:25 <dolio> {-# RULES "++" [~1] forall xs ys. xs ++ ys = augment (\c n -> foldr c n xs) ys #-}
08:03:31 <fasta> chessguy_work: yes, it's going too far.
08:03:38 <oerjan> ihope: take 3 ("foo" ++ undefined) works in Hugs.  This is a ghc bug.
08:03:48 <ihope> It's evaluating too eagerly?
08:03:59 <oerjan> apparently
08:04:08 <fasta> oerjan: it works in 6.7
08:04:15 <opqdonut> ?src augment
08:04:15 <lambdabot> augment g xs = g (:) xs
08:04:16 <xerox> oerjan: it prints "foo" in 6.6.1
08:04:22 <ihope> We have 6.7 now?
08:04:28 <fasta> oerjan: and in 6.6.1
08:04:28 <chessguy_work> fasta, i don't get your argument
08:04:31 <byorgey> fasta: why is it going too far to say that >>= has different semantics for each monad instance?
08:04:44 <wli> It works here (6.6.1).
08:04:52 <ihope> @version
08:04:52 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
08:04:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:04:58 <chessguy_work> fasta, are you saying it's not potentially different in each monad? or that it's not the semantics that are different? or what?
08:05:00 <fasta> byorgey: imho, the semantics are the laws only and nothing else.
08:05:43 <chessguy_work> the laws aren't the semantics, they're just constraints on what the semantics can be
08:05:53 <byorgey> fasta: hm, that's not the way I use the word "semantics"
08:05:59 <ari> main = print . take 3 $ "foo" ++ undefined -- 6.6: works without optimisation and in ghci, fails with -O1 or -O2
08:06:08 <fasta> chessguy_work: by that definition the operational semantics at least can potentially be different.
08:06:11 <wli> Axiomatic, denotational, operational semantics.
08:06:23 <dolio> Must be due to foldr/build/annotate fusion.
08:06:34 <dolio> augment, even.
08:06:49 <chessguy_work> fasta, so what would you say is different for >>= in each monad?
08:06:49 <ricky_clarkson> thoughtpolice: Which blog post of steve yegge's were you talking about? (url?)
08:06:54 <ari> IOW, optimisation is overstrictifying it... should I get HEAD and see if this bug still exists?
08:07:01 <fasta> chessguy_work: the implementation?
08:07:04 <thoughtpolice> ricky_clarkson: the math one?
08:07:12 <thoughtpolice> ricky_clarkson: http://steve-yegge.blogspot.com/2006/03/math-for-programmers.html
08:07:18 <int-e> ari: funny. to add a few more data poiints, it works in 6.4.2, works in 6.6.1 and in recent 6.7
08:07:26 <fasta> chessguy_work: everything might be different as long as the laws hold
08:08:09 <dmead> anyone know about using haskell on embedded linux?
08:09:28 <roconnor> horray, Coq found me a logic bug.
08:09:50 <sjanssen> dmead: I've heard rumors of ghc on that little Nokia internet tablet thing
08:09:59 <oerjan> roconnor: a bug in logic? is mathematics coming crashing down? :)
08:10:31 <dmead> sjanssen, yea i also remember dons saying something about nhc being able to run code on bare metal
08:10:35 <roconnor> bug in my program.
08:10:44 <dmead> but nothing thats production quality
08:10:53 <roconnor> It said, ``cannot unify (-a) with a''.
08:10:59 <roconnor> I forgot a minus sign.
08:11:20 <njbartlett> dmead: I tried compiling GHC on my Zaurus. I failed abysmally. I think Philippa may have had more luck though. However, Hugs works okay.
08:11:31 <sjanssen> dmead: how much storage do you have?  GHC tends to make large executables
08:12:19 <dmead> not much
08:12:29 <dmead> i'm working for a company now that does embedded C
08:12:43 <dmead> it's like 64 meg embedded systems
08:13:15 <int-e> hmm how are executable sizes with nhc?
08:13:25 <thoughtpolice> i've always had thoughts of haskell on the psp, myself. :p
08:13:48 <thoughtpolice> i have one that i've been meaning to homebrew-ize for a while...
08:13:55 <gmh33> you could probably get haskell on a gp2x
08:14:59 <ricky_clarkson> Translate it to JS or something. ;)
08:15:12 <thoughtpolice> yhc would be a suitable compiler for such a goal. :)
08:15:16 <fasta> What's the point of running ghci on an embedded device? Type checking my code already takes >100MB...
08:16:02 <sjanssen> fasta: how many lines?
08:16:17 <fasta> sjanssen: <1200
08:16:25 <sjanssen> fasta: type class programming?
08:16:43 <roconnor> oerjan: for mathematics crashing down see: http://r6.ca/blog/20061211T203500Z.html
08:16:44 <lambdabot> Title: Full Disclosure
08:17:21 <fasta> sjanssen: I don't think so, I do have a Moo m => Moo (t m) lying around
08:17:49 <jfredett>  i'm not sure what that means, roconnor
08:17:57 <jfredett> but if that is saying that true->false
08:18:02 <jfredett> holy crap.
08:18:10 <roconnor> jfredett: it's a proof in a previous version of coq that True -> False.
08:18:25 <jfredett> lol
08:19:00 <jfredett> i had a sneaking suspicious that logic was-- err-- wrong.
08:19:05 <jfredett> was++ err++
08:19:37 * ricky_clarkson watches another deity disappear.
08:20:52 <oerjan> ricky_clarkson: in a puff of logic?
08:20:59 <ricky_clarkson> Quite.
08:21:19 <gmh33> his magic white smoke escaped
08:22:13 <Tchakkazulu> Curry's Paradox...
08:22:45 <shapr> @karma was
08:22:46 <lambdabot> was has a karma of 0
08:22:47 <ricky_clarkson> thoughtpolice: Thanks for that URL - thought he might mention category theory etc., too.
08:23:06 <oerjan> @karma err
08:23:06 <lambdabot> err has a karma of 0
08:23:32 <oerjan> @karma noone
08:23:33 <lambdabot> noone has a karma of 0
08:23:38 <oerjan> liar!
08:23:41 <roconnor> Tchakkazulu: could be
08:23:46 <norpan> @karma norpan
08:23:46 <lambdabot> You have a karma of -1
08:23:49 <norpan> weee
08:23:50 <shapr> @karma
08:23:50 <lambdabot> You have a karma of 37
08:23:55 <nominolo> @karma
08:23:56 <lambdabot> You have a karma of 0
08:24:03 <roconnor> Tchakkazulu: It really looks like that.
08:24:04 <dolio> @karma dons
08:24:04 <lambdabot> dons has a karma of 121
08:24:11 <dolio> Huh, so karma is back now?
08:24:14 <Tchakkazulu> Aye, with the fix thing and all.
08:24:26 <norpan> i wonder why i am in the red
08:25:20 <Botje> @karma+ norpan
08:25:20 <lambdabot> norpan's karma raised to 0.
08:25:23 <Botje> now you're neutral again!
08:26:04 * dolio shouldn't bother responding to people who post comments like 'how does static typing help me with catching plot(X,Y) versus plot(Y,X)'.
08:26:19 <wli> If I wanted to rebuild various debian packages with upstream and potentially some of my own updates (e.g. ghc, whatever's got the MTL, etc.), is there anything special I need to do?
08:26:23 <chessguy_work> anybody know where in the source i can find the Monad instance of Either?
08:26:39 <Botje> dolio: "well, if your domain is different from your codomain, ..."
08:26:46 <Tchakkazulu> chessguy_work: Control.Monad.Error perhaps?
08:26:46 <oerjan> chessguy_work: Control.Monad.Instances, perhaps
08:26:59 <Tchakkazulu> Wow, template sentences.
08:27:06 <int-e> @karma
08:27:06 <lambdabot> You have a karma of 29
08:27:17 <int-e> karma is back mostly, yes
08:27:23 <int-e> :P
08:27:33 <wli> What was wrong with karma in the first place?
08:27:35 <oerjan> oh, in Error
08:27:38 <dolio> Botje: I told him you make types XCoordinate and YCoordinate, but then he said "What if I put 300 in for the XCoordinate when I meant 200?"
08:27:52 <oerjan> it requires the first argument to be in the Error class
08:27:58 <int-e> dolio: he should use a vector as the input.
08:28:09 <thoughtpolice> ricky_clarkson: np. it's a good post and it's gave me a new way to look at learning math so, hopefully I'll give it a shot and be more math-capable sometime in the next 10 years. :p
08:28:13 <Botje> dolio: "Functional languages will support telepathy by 2010. no sooner."
08:28:17 <oerjan> (for messages)
08:28:36 <dolio> wli: It was all set back to 0 not too long ago.
08:29:43 <dolio> Botje: Yeah, I'm not even sure what his point is. Maybe it's "static typing can't catch all possible mistakes I can think of, therefore it's worthless." But I suppose I should give him the benefit of the doubt... :)
08:30:26 <Botje> nah
08:30:30 <chessguy_work> hmm, ControlMonad.Instances has an instance of Functor for Either a
08:30:31 <nominolo> @seen eivuokko
08:30:31 <lambdabot> eivuokko is in #haskell, #ghc and #darcs. I last heard eivuokko speak 3h 9m 24s ago.
08:30:36 <Botje> ask uw how he'd like that problem solved and we'll implement it :]
08:30:43 <Botje> *ask him
08:30:46 <roconnor> Tchakkazulu: If I wrote the proof in english I'd say ``Claim: True -> False.  Let's proceed by induction on True.  Assume True, by inductive hypothesis, False, therefore False.''
08:31:03 <eivuokko> nominolo, I'm here :)
08:31:39 <nominolo> eivuokko: just seen your patch
08:32:08 <ricky_clarkson> Botje: Your conversation reminds me of http://syntaxfree.wordpress.com/2006/12/24/static-vs-dynamic-typing-do-what-thou-wilt/
08:32:11 <nominolo> eivuokko: what's the advantage of having ConfFlag be a type of its own?
08:32:11 <lambdabot> Title: Static vs dynamic typing: do what thou wilt « Data.Syntaxfree, http://tinyurl.com/ykvay5
08:32:16 <Tchakkazulu> roconnor: Induction on booleans? Wow.
08:32:24 <nominolo> eivuokko: so far it seems isomorphic
08:33:04 <eivuokko> nominolo, the env function in resolveWithFlags has wrong type otherwise :)
08:33:18 <roconnor> Tchakkazulu: It's not a particularly sound argument.
08:33:34 <roconnor> Tchakkazulu: actually it isn't induction of bools.
08:33:49 <eivuokko> nominolo, ie it can't get system params (os, impl, arch) even if type says so.  But this is only my understand, I am not sure of it..
08:33:50 <roconnor> It's induction on the one element type.
08:33:55 <chessguy_work> would this be right for Either a? >>= :: Either a b -> (b -> Either a c) -> Either a c
08:34:25 <nominolo> eivuokko: you're right about the missing Impl case though
08:35:22 <Tchakkazulu> roconnor: Right. I was thinking along the lines of True ~ 1; False ~ 0; prop n -> prop (n+1); so prop False -> prop True.
08:35:26 <oerjan> :t (>>=) `asTypeOf` \x -> (x :: Either a b) `seq` undefined
08:35:28 <lambdabot>     Inferred type is less polymorphic than expected
08:35:28 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
08:35:33 <Tchakkazulu> roconnor: Which also makes no sense when you're doing typing.
08:35:42 <oerjan> :t (>>=) `asTypeOf` \x -> (x :: Either () Bool) `seq` undefined
08:35:44 <lambdabot>     No instance for (Error ())
08:35:44 <lambdabot>       arising from use of `>>=' at <interactive>:1:0-4
08:35:58 <oerjan> :t (>>=) `asTypeOf` \x -> (x :: Either String Bool) `seq` undefined
08:36:00 <lambdabot> forall b. Either String Bool -> (Bool -> Either String b) -> Either String b
08:36:33 <chessguy_work> oerjan, looks like a 'yes' to me
08:36:38 <oerjan> wait...
08:36:52 <oerjan> :t (>>=) `asTypeOf` \(Left _) -> undefined
08:36:53 <eivuokko> nominolo, So env type is right currently?  I thought simplifyWithSysParams would remove all but flags.
08:36:54 <lambdabot> forall a b t. (Monad (Either t)) => Either t a -> (a -> Either t b) -> Either t b
08:37:53 <nominolo> eivuokko: well it does.  it just doesn't give a guarantee.  expressing this in the type is of course a good idea
08:47:42 <nominolo> eivuokko: looks ok.  but why didn't that require any changes in PackageDescription.hs?
08:49:30 <hpaste>  chessguy pasted "I wonder if a table like this would help with explaining monads" at http://hpaste.org/2276
08:50:53 <eivuokko> nominolo, parsin of ConfVars is in Configuration.hs, and only source of ConfVars afaict
08:50:54 <oerjan> _I_ wonder if it would be a good idea to make hpaste expand tabs automatically.
08:51:47 <chessguy_work> that table could be extended with columns for the semantics of >>= and >>, too
08:51:56 <chessguy_work> and of course more monad instance
08:51:57 <chessguy_work> s
08:53:05 <nominolo> eivuokko: ok.  i'll apply them locally, test them, and if nothing goes wrong, i give the ok to dcoutts / Igloo to apply them
08:53:33 <dcoutts> nominolo: welcome back
08:53:45 <nominolo> dcoutts: thx
08:53:48 <eivuokko> nominolo, Thanks, let me know if there's something wierd goingg on :)
08:54:06 <dcoutts> nominolo: we've got lots of work for you to do :-) and I've been doing more refactoring
08:54:35 <nominolo> dcoutts: i'm catching up on my mail..
08:54:40 <dcoutts> @arr!
08:54:40 <lambdabot> Shiver me timbers!
08:55:46 <bluestorm> chessguy_work:
08:55:51 <eivuokko> dcoutts, Could you look into warning from S.D.GHCMakefile ?  you changed the script but didn't apply new version of the result or something.
08:56:07 <eivuokko> dcoutts, I think the script only needs to be run and result committed.
08:56:09 <nominolo> :t return . join . join . take 1 . map fst . filter (null . snd)
08:56:11 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => [([[a]], [a1])] -> m [a]
08:56:19 <eivuokko> dcoutts, (Asking you because you changed it last)
08:56:25 <bluestorm> isn't that essentially an explanation about "what operators with kind * -> * mean" ?
08:56:30 * eivuokko wants warning free builds
08:56:35 <dcoutts> eivuokko: right, I didn't update it, I didn't make any substancial change to the script, just made it add a type sig
08:56:49 <dcoutts> so when it's next updated there should be no warning
08:57:03 * eivuokko is impatient
08:57:05 <eivuokko> :-P
08:57:13 <chessguy_work> bluestorm, hmm. i guess Monads aren't the only things with kind * -> *, are they?
08:57:14 <dcoutts> eivuokko: regenerate it and push! :-)
08:57:19 <chessguy_work> err
08:57:28 <chessguy_work> s/with kind/with operators with kind/
08:57:34 <eivuokko> dcoutts, The problem was that I didn't understand why you didn't :)
08:57:40 <chessguy_work> err, whatever
08:57:42 <chessguy_work> @kind Monad
08:57:44 <lambdabot> Class `Monad' used as a type
08:57:52 <chessguy_work> @kind State s
08:57:55 <lambdabot> Not in scope: type variable `s'
08:57:58 <chessguy_work> @kind State
08:58:00 <lambdabot> * -> * -> *
08:58:08 <dcoutts> eivuokko: coz' I didn't make a functional change just a cleanup
08:58:17 <dcoutts> eivuokko: and because that code scares me :-)
08:58:22 <eivuokko> lol..
08:58:33 <chessguy_work> i guess what i should have said is that instances of Monad aren't the only things of kind * -> *, are they?
08:58:52 <chessguy_work> @kind Set
08:58:54 <lambdabot> Not in scope: type constructor or class `Set'
08:58:57 <eivuokko> Yes, it really is hackish.
08:58:57 <dcoutts> eivuokko: actually, as I recall, I diffed the output and it wasn't obviously the same excpet for my having added a type sig
08:59:02 <chessguy_work> @kind Data.Set
08:59:04 <lambdabot> Couldn't find qualified module.
08:59:05 <Saizan> chessguy_work: no, they aren't
08:59:09 <chessguy_work> @kind Data.Set.Set
08:59:10 <lambdabot> * -> *
08:59:13 <chessguy_work> there we go
08:59:16 <dcoutts> eivuokko: and since I don't know what the output should be I left it
08:59:59 <nominolo> dcoutts: whoa, what a huge patch
09:00:09 <chessguy_work> bluestorm, are you saying it's superfluous, or actually wrong?
09:00:12 <bluestorm> hm
09:00:33 <dcoutts> nominolo: oh the InstallDirs one? yeah, the next on is probably at least as big...
09:00:59 <bluestorm> i'm saying that from my point of view, it basically say "when you see (m a -> (a -> m b) -> m b), you have to expand it that way"
09:01:20 <oerjan> chessguy_work: everything that is a Functor or Applicative too
09:01:37 <bluestorm> i wouldn't say it's the real difficulty with monads
09:02:10 <dcoutts> eivuokko: if you're looking at cabal command line handling...
09:02:45 <oerjan> well it seems worth it to at least show that monads can have various numbers of extra type parameters
09:02:49 <chessguy_work> bluestorm, i'm not sure what you mean by 'expand it'
09:02:56 <dcoutts> eivuokko: now that we use the Program stuff better we get --with-<prg>= and --<prg>-args= flags for every program.
09:03:16 <dcoutts> eivuokko: that adds ~50 lines to the output of configure --help
09:03:21 <bluestorm> by replacing "m" with the real monad type
09:03:29 <eivuokko> dcoutts, Yes, it is silly.
09:03:32 <bluestorm> hm
09:03:33 <dcoutts> eivuokko: I'm wondering if we could make the help text show it generically
09:03:38 <chessguy_work> ah, instantiating the types you mean
09:03:38 <bluestorm> perhaps i missed something
09:03:53 <glen_quagmire> how do I compile with everything statically linked? so that people without gtk can run my program?
09:03:58 <dcoutts> eivuokko: and perhaps list compactly all the programs it applies to, so people still knows what's available
09:04:03 <chessguy_work> bluestorm, perhaps it will seem more useful once i've added the 2 columns i mentioned
09:04:12 <bluestorm> hm
09:04:23 <bluestorm> semantic ? i'm sure it will
09:04:46 <dcoutts> glen_quagmire: you generally don't do that, if you're on windows say, you just make an installer that includes all the gtk dlls, there's a demo of that available.
09:05:28 <eivuokko> dcoutts, I haven't been working on it much...  just wanted to add --snapshot and --version-tag to configure;  But I got interrupted and haven't got back into it.
09:05:32 <dcoutts> glen_quagmire: in fact I don't think you can even get static libs for gtk, it is always only built with dynamic libs, same is true for many other common libs.
09:05:34 <glen_quagmire> dcoutts: in gtk2hs installation?
09:05:39 <dcoutts> glen_quagmire: yes
09:05:44 <glen_quagmire> thank you
09:07:01 <dcoutts> glen_quagmire: oh, you mean the demo? that's here: -- oh, haskell.org is getting dosed
09:07:28 <balodja> One more question about category theory :) About sums and products of objects in category. What are the abbreviations "inr/inl" and "exr/exl"?
09:07:46 <glen_quagmire> dcoutts: i compiled a few demos from gtk2hs
09:07:58 * glen_quagmire searches in haskell.org
09:08:12 <dcoutts> glen_quagmire: I'm just fixing haskell.org ...
09:08:36 <SamB_XP> whoa
09:08:44 <glen_quagmire> i didn't break it
09:08:45 <SamB_XP> pascal's triangle is neat in mod 7...
09:08:57 <opqdonut> SamB_XP: trippyyy
09:09:50 <SamB_XP> hmm, I think it's neat in mod anything...
09:10:59 <opqdonut> nah, mod 2 is boring :)
09:11:18 <SamB_XP> you don't like sierpinski's gasket?
09:11:59 <samreid> mod 1 is boring
09:12:00 <glen_quagmire> w00t haskell.org down
09:12:01 <lament> EKG2?
09:12:14 <samreid> It's down?  Seems up to me.
09:12:17 <glguy> glen_quagmire: nope
09:12:32 <glen_quagmire> oh now it connects
09:12:32 <ricky_clarkson> Pornografia mathematica
09:12:38 <balodja> It's upper then other.
09:13:12 <glen_quagmire> what do I search for? to make a package written with  gtk2hs
09:13:24 <oerjan> balodja: i don't recall quite those names but my guess is that they are the categorical equivalents of Haskell's Left, Right, fst and snd
09:13:43 <dcoutts> glen_quagmire: http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe and http://haskell.org/gtk2hs/win32/
09:13:43 <mrd> inr and inl are common names for what haskell calls Right and Left
09:13:45 <SamB_XP> samreid: okay, true
09:14:00 <glen_quagmire> dcoutts: thanks a bunch!
09:14:03 <SamB_XP> but the trivial ring is usually rather boring
09:14:15 <dcoutts> glen_quagmire: that's a demo of an installer for an app that uses gtk2hs, and the other is all the files you need for your own installers in a .zip file
09:15:37 * glen_quagmire puts those to usb thumb drive
09:16:53 <oerjan> balodja: although if i recall the diagrams for sums and products correctly, those were usually called something with greek letter pi and iota.
09:17:02 <tuxplorer> seen Lemmih
09:17:07 <tuxplorer> @seen Lemmih
09:17:07 <lambdabot> I saw Lemmih leaving #haskell 1d 3h 33m 18s ago, and .
09:18:06 <balodja> oerjan: And what's the decoding of those abbreviations? "inner left/right"?
09:18:15 <oerjan> there are also the two functions that you combine into one using the universal property, maybe it refers to those.
09:18:31 <osfameron> how can I trace the progress of a function in haskell?
09:18:52 <oerjan> left and right, yes, and in and ex are latin for into and out of
09:19:02 <pjd> osfameron: strategic placements of trace ?
09:19:09 <pjd> (as in Debug.Trace)
09:19:15 <balodja> Ah. Thanks.
09:19:31 <osfameron> pjd: ah, ok, I had heard of "trace" but not what package it was in
09:22:37 <osfameron> pjd: as in:  let debug = trace "This is the output" 0   ?
09:22:55 <osfameron> that doesn't seem to do anything within a function call in ghci
09:23:46 <oerjan> osfameron: the string is only printed when the other argument to trace is actually used by the program
09:24:12 <nominolo> > 5 + trace "foo" 3
09:24:13 <lambdabot>   Not in scope: `trace'
09:24:21 <osfameron> oh right
09:24:22 <oerjan> because of lazy evaluation, you have to take care to make this happen
09:24:32 <osfameron> the documentation doesn't particularly bother mentioning that :-)
09:25:03 <oerjan> osfameron: it's sort of obvious from general haskell referential transparency
09:25:26 <pjd> osfameron: "When called, trace outputs the string in its first argument, before returning the second argument as its result."
09:25:44 <pjd> the implication that the second return only happens when needed
09:25:49 <pjd> being that, even
09:26:16 <osfameron> ok
09:26:41 <oerjan> (although trace is of course only referentially transparent in result, not effect)
09:27:15 <glguy> ?type trace -- is it in @type's scope?
09:27:17 <lambdabot> Not in scope: `trace'
09:27:18 <pjd> yay for unsafePerformIO
09:27:45 <pjd> glguy: trace :: String -> a -> a
09:27:55 <osfameron> yes, ok, that is "obvious" in that it's the only way that makes any sense... but I always prefer a nice example over actual thought :D
09:27:58 <oerjan> ?type Debug.Trace.trace
09:28:00 <lambdabot> forall a. String -> a -> a
09:28:13 <glguy> pjd: I know the type, i was wondering if it was in scope :-p
09:28:35 <oerjan> glguy: i thought you meant whether it was imported
09:28:47 <glguy> yeah
09:30:02 * osfameron defines trace' ns = trace (show ns) ns
09:30:52 <hpaste>  conal pasted "simple generalization of monadic 'when'" at http://hpaste.org/2278
09:32:09 <dcoutts> nominolo: so one thing several people hae brought up is the syntax of configurations, braces vs layout
09:32:39 <glguy> conal: Would the generalization of monadic when use Monoid over MonadPlus?
09:32:44 <nominolo> dcoutts: ah, i was wondering when this will come up :)
09:32:47 <dcoutts> nominolo: what several people have said is that's it's a bit odd having a syntax that requires both indentation and braces
09:32:50 <dcoutts> nominolo: heh :-)
09:32:57 <glguy> I suppose then it wouldn't be a generalization :)
09:33:04 <oerjan> glguy: Monoid "should" be a superclass of MonadPlus
09:33:26 <dcoutts> nominolo: so the question is, how hard would it be to allow indentation rather than braces for stanzas
09:33:29 <nominolo> dcoutts: i agree.  what were people leaning towards?
09:33:48 <dcoutts> nominolo: people don't mind allowing braces, it's requireing them that they don't like
09:33:49 <nominolo> dcoutts: shouldn't be hard
09:33:58 <Dybber> Can anyone suggest a simple (but still interesting) project in Haskell? I haven't really created anything in haskell yet, and I don't feel that the projects I can think of is very well suited for haskell.
09:34:28 <conal> glguy: yes, because (Monoid o, Monad m) => Monoid (m o)
09:34:33 <dcoutts> nominolo: of course people want everything :-) they want to be able to use braces instead of indentation, and they want to be able to use only indentation, and they want to be able to use mixtures of the two :-)
09:34:33 <nominolo> Dybber: there's a bottom-up compiler construction script, which uses scheme
09:34:46 <nominolo> Dybber: i did it in haskell once
09:34:48 <shapr> @users
09:34:48 <lambdabot> Maximum users seen in #haskell: 385, currently: 373 (96.9%), active: 23 (6.2%)
09:34:55 <glguy> @yow
09:34:55 <lambdabot> The SAME WAVE keeps coming in and COLLAPSING like a rayon MUU-MUU ...
09:34:59 <dcoutts> nominolo: but of course it depends on how hard it is as to what you choose to allow
09:35:14 <nominolo> dcoutts: i'd start with indentation
09:35:31 <nominolo> dcoutts: note that indentation was significant even in old files
09:35:35 <dcoutts> nominolo: that's the one most people would want
09:35:37 <mrd> Dybber: what do you do for a living? or hobby
09:35:38 <dcoutts> nominolo: yes
09:35:43 <Dybber> nominolo, I don't think I understand
09:35:45 * glguy needs to go to work, but his puppy is curled up against him, preventing him from moving
09:36:18 <Dybber> mrd - hmm playing music, studying computer science, reading..
09:36:19 <axm> Dybber, I for example did a soduku solver as hello world
09:36:50 <mrd> so as you study CS you probably come across some interesting algorithms, right?
09:37:13 <nominolo> Dybber: http://www.cs.indiana.edu/~aghuloum/compilers-tutorial-2006-09-16.pdf
09:37:16 <lambdabot> http://tinyurl.com/sh4no
09:37:21 <lament> @pl \x -> (fst x) /= 1
09:37:21 <lambdabot> (1 /=) . fst
09:37:28 <lament> oh, right.
09:38:14 <nominolo> dcoutts: i'll take a look
09:38:24 <dcoutts> nominolo: great
09:39:26 <Dybber> mrd, well yes, maybe I can find something in the algorithm book that can inspire me
09:40:15 <mrd> one of the first things I did was Bellman Ford.  and then I took some similar algorithms from work and did those.  and then I wrote quickcheck tests to compare the results from different implementations.
09:42:32 <ski> conal : did you have any use for 'whenG' in mind at the moment ?
09:43:37 <conal> ski:; yes.  for a functional Event module.
09:44:13 <ski> 'Event' as in CML ?
09:44:33 <conal> ski: sort of.  but more like events in Fran/FRP
09:44:43 <ski> hmhm
09:44:55 <ski> 'mempty' and 'mappend' being ?
09:45:07 <oerjan> @src Monoid
09:45:07 <lambdabot> class Monoid a where
09:45:07 <lambdabot>     mempty  :: a
09:45:07 <lambdabot>     mappend :: a -> a -> a
09:45:07 <lambdabot>     mconcat :: [a] -> a
09:45:14 <conal> mempty is the event that never occurs
09:45:29 <conal> mappend merges two events into one that occurs when either of the others occur
09:45:40 <ski> right
09:45:43 <conal> i've been using Event a = ((a -> IO ()) -> IO ()))
09:45:53 <nominolo> eivuokko: i can't apply the patch :/
09:45:58 <conal> but now ((a -> o) -> o), for Monad o
09:45:58 <ski> ContT IO () a
09:46:22 <ski> s/Monad/Monoid/ ?
09:46:50 <conal> ski: right.  monoid
09:46:52 <oerjan> Cont o a then
09:46:55 <Dybber> Well thanks, I think I will start with some dynamic programming and later do some graph-related. It shouldn't be that hard.
09:47:04 <conal> ski, oerjan: yes, Cont
09:47:25 <ski> so
09:47:39 <ski> mempty = const mempty
09:47:41 <ski> ?
09:47:46 <nominolo> eivuokko: can you try to put the patch into a file using -o filename?
09:49:18 * SamB_XP finds himself using a parametric datatype for triangles made of other triangles
09:49:35 <SamB_XP> or something like that
09:49:48 <ski> ?
09:50:17 <SamB_XP> kinda like sierpinski's gasket...
09:50:25 <conal> ski: monoid is already def'd for (a -> b) when Monoid b
09:50:27 * SamB_XP is using it on paper right now ;-)
09:50:35 <lament>  /\
09:50:36 <lament> /\/\
09:50:46 <ski> conal : i meant for 'Event a'
09:51:14 <eivuokko> nominolo, I did..
09:51:22 <conal> ski: yes.   and Event o a =  ((a -> o) -> o)
09:51:36 <SamB_XP> lament: like that, only with the bottoms on 'em, yes ;-)
09:51:42 <nominolo> eivuokko: oh. then it got scrambled by gmail
09:51:53 <lament> these are bottomless triangles
09:52:05 <opqdonut> ?instances Monoid
09:52:07 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
09:52:11 <ski> conal : ev0 `mappend` ev1 = \k -> ev0 k >> ev1 k  -- ?
09:52:27 <opqdonut> ?instances Dual
09:52:28 <lambdabot> Couldn't find class `Dual'. Try @instances-importing
09:52:30 <ski> (or s/>>/`mappend`)
09:52:39 <opqdonut> ?index Dual
09:52:39 <lambdabot> bzzt
09:52:44 <conal> ski: yes, or mappend = liftA2 mappend
09:52:55 <ski> *nod*
09:53:00 <conal> :)
09:53:06 <opqdonut> liftA?
09:53:12 <opqdonut> is that for applicative or arrow?
09:53:18 <oerjan> opqdonut: Dual reverses mappend order
09:53:19 <conal> applicative
09:53:21 * ski hadn't thought of seeing 'Cont o a' as 'Reader (a -> o) a'
09:54:04 <oerjan> > Dual "hi" `mappend` Dual "ho"
09:54:04 <lambdabot>   add an instance declaration for (Show (Dual [Char]))
09:54:24 <oerjan> @src Dual
09:54:25 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:54:25 * SamB_XP is trying to solve problem 148 on project euler
09:54:38 <opqdonut> oerjan: i know, hoogle can't find it either :/
09:54:39 <oerjan> > let Dual s = Dual "hi" `mappend` Dual "ho" in s
09:54:40 <lambdabot>  "hohi"
09:55:40 <conal> ski: Event is also a functor
09:55:48 <conal> which is very handy
09:55:59 <ski> of course
09:56:31 <conal> but it's not the one inherited from ((->) a)
09:56:48 <conal> it comes from the composition of contrafunctors
09:57:09 <conal> fmap = comap . cfmap
09:57:41 <conal> fmap = comap . cofmap
10:00:06 <ski> (er, correction above, s/Reader (a -> o) a/Reader (a -> o) o/)
10:00:15 <ddarius> Yep.  Related to the double power object monad.
10:00:41 <ski> conal : is this not just 'fmap' for 'Cont o' ?
10:01:41 <conal> ski: i don't know
10:02:38 <nominolo> @karma-- gmail
10:02:38 <nominolo> @karma- gmail
10:02:38 <lambdabot> gmail's karma lowered to 0.
10:02:38 <lambdabot> gmail's karma lowered to -1.
10:02:55 <ski> fmap f (Cont c) = Cont (\k -> c (\a -> k (f a)))  = Cont (\k -> c (k . f))  = Cont (c . (. f))
10:02:56 <conal> i define fmap = cofmapC . cofmapC where cofmapC = flip (.)
10:03:33 <oerjan> @pl fmap f c = c . (. f)
10:03:33 <lambdabot> fmap = flip (.) . flip (.)
10:03:42 <ski> (:
10:03:45 <conal> oerjan: thanks.  :)
10:04:14 <conal> each of those flip (.) is cofmap on (-> o)
10:05:04 <conal> which is a general way to make functors out of pairs of contrafunctors
10:07:01 <conal> i don't know why it makes sense to treat continuations as a monoid
10:07:21 <conal> nor to think of continuations & events interchangeably
10:08:01 <ski> conal : btw, your 'Event a' reminds me of Fudgets, in which they had something like 'Fudget a b = (b -> IO ()) -> (a -> IO ())'
10:08:46 <ski> conal : the monoid related to discarding and duplicating the current continuation
10:09:46 <ski> (s//is /)
10:11:50 <conal> ski: i'll noodle on that.  thanks.
10:12:51 <conal> ski: do you know of any Cont code that uses Monoid o -> Monoid (Cont o a)?
10:13:02 <conal> oops - i mean Monoid o => ...
10:13:04 * SamB wonders why Data.Sequence doesn't have a "concat" function
10:13:49 <ski> conal : hmm, i can imagine an "amb" framework in terms of continuations could use that
10:14:01 <conal> SamB: instance Monoid (Seq a)
10:14:47 <ski> (hm, or maybe i'm thinking of outputting items, not 'amb' ..))
10:15:37 <SamB> conal: is that efficient?
10:16:06 <oerjan> i suppose any use of ContT that lifts MonadPlus is nearly a case of that
10:16:13 <Nucleo> Is it possible to generalize  [ [x,y,z,w] | x <-[1..10], y <- takeWhile (\a -> x < n) someList, z <- takeWhile (\b -> x+y <n) someOtherList, w <- takeWhile (\c -> x+y+z < n)]    etc?
10:16:15 <oerjan> er, maybe not
10:16:35 <oerjan> appends in the wrong end
10:16:42 <conal> SamB: probably.  check out the reference: http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
10:16:43 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
10:16:58 <Nucleo> i.e. generalize that to list comprehensions containing arbitrary numbers of parallel comprehensions? I know I can sequence a list of lists, but no idea how to get the takeWhiles in there.
10:17:08 <oerjan> oh wait, no it works
10:17:35 <samreid> SamB: would it really be worth it for a specialized mconcat?
10:17:43 <ski> Nucleo : 'a','b','c' appears to be unused
10:18:00 <SamB> samreid: not sure
10:18:03 <oerjan> Nucleo: i actually did that in a program
10:18:22 <Nucleo> ski: ooops, I mean to basically takeWhile (sumofPreviousComprehensions < n)
10:18:26 <conal> SamB: oh -- now i understand your question.  mconcat vs mappend
10:18:33 <Nucleo> oerjan: do I need template haskell?
10:18:58 <dolio> What would the type of the specialized concat be?
10:19:25 <oerjan> Nucleo: no, use StateT Int []
10:19:35 <oerjan> where the state is the sum so far
10:19:36 <ski> Nucleo : did you mean 'n' to be the argument of the lambdas passed to 'takeWhile's ?
10:19:59 <oerjan> of course you must switch to do notation then
10:20:12 <SamB> dolio: either Seq (Seq a) -> Seq a or [Seq a] -> Seq a
10:20:15 <Nucleo> ski: n would be a constant for all practical purposes.
10:20:41 <dolio> Well, [Seq a] -> Seq a is the type of mconcat, and you can specify it during the Monoid instance.
10:20:47 <Nucleo> oerjan: would you mind putting up a small hpasted example? I'm not very good with state transformers
10:21:54 <ski> @type foldM
10:21:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:22:10 <dolio> Seq (Seq a) -> Seq a is 'join' from Monad, although that's not definable in a more efficient way.
10:22:25 <oerjan> Nucleo: let me find my program (for optimizing brainfuck constants, btw)
10:22:48 <SamB> dolio: well, even mconcat isn't defined efficiently in http://darcs.haskell.org/ghc-6.6/packages/base/Data/Sequence.hs
10:23:18 <doserj> is there a pitfall in the euler project problem 17, or am i simply not able to spell english?
10:23:57 <dolio> doserj: "forty" ?
10:24:09 <doserj> i tried both :)
10:24:13 <dolio> Oh.
10:24:28 <dolio> That's the one that got me the first time, I think. :)
10:24:38 <doserj> interestingly, the solution on the haskellwiki uses "fourty"...
10:24:38 <samreid> SamB: time-complexitywise I don't think you can get any better than the default mconcat.  (It seems.)
10:24:46 <SamB> really?
10:25:04 <byorgey> "ninety"?
10:25:16 <ski> Nucleo : something like 'reverse `liftM` foldM (\ns (sum,xs) -> [ (sum+x,x:xs) | x <- takeWhile (\? -> sum < n) ns ]) (0,[]) [[1..10],someList,someOtherList]', i think
10:25:28 <doserj> byorgey, how could you spell it different?
10:25:36 <byorgey> ninty, I don't know
10:25:45 <samreid> Remember that >< is log (min {n1,n2}).  So concatting K sequences of size N is going to be K log N.
10:25:56 <byorgey> grasping at straws here =)
10:26:12 <dolio> You spelled it "fourteen" right?
10:26:13 <ski> Nucleo : er, s/ns (sum,xs)/(sum,xs) ns/
10:26:34 <hpaste>  oerjan pasted "A program I wrote that uses StateT to select numbers while bounding their sum" at http://hpaste.org/2279
10:26:40 <doserj> dolio, yes
10:26:51 <Nucleo> thanks oerjan and ski
10:26:56 <ski> (also s/reverse/(reverse . snd)/)
10:26:59 <Nucleo> now I should try to understand what's going on
10:27:00 <dolio> I think I'm out of ideas, then.
10:27:56 <byorgey> doserj: what answer do you get? (I won't tell you the correct one or give hints unless you want, I'm just curious)
10:28:20 <doserj> 21148
10:28:36 <byorgey> doserj: would you like me to tell you if it is too small or too big?
10:29:25 <Nucleo> (one pitfall for problem 17 is that "and" is not used in words written out)
10:30:05 <byorgey> Nucleo: it is according to the example given...
10:30:18 <Nucleo> oh wait, the other way around.
10:30:26 <doserj> byorgey, the order of magnitude of the difference would be interesting
10:30:30 <byorgey> Nucleo: right. =)
10:30:31 <Nucleo> byorgey: no, you're right. When I first did it, I did it w/o "and"
10:30:54 <dcoutts> eivuokko, nominolo: what do you think about making configure less chatty? lemme paste what I mean...
10:30:56 <byorgey> doserj: you are off by less than 100.
10:30:56 <dcoutts> @hpaste
10:30:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:31:15 <doserj> more than 10?
10:31:26 <byorgey> doserj: yes
10:31:32 <samreid> SamB: the worst arrangement of the sizes of sequences goes in the order [2^(k-1)*n, ..., (2^0)*n] in which case you have O(K log N + K^2) -- but note that K is logarithmic w.r.t. 2^(K-1)*n -- so you've still got O(K log N) time where N is the largest sequence.
10:31:45 <doserj> hmm
10:32:11 <samreid> s/largest sequence/largest sequence size/
10:32:19 <kjdf> what is the use of ST monad?
10:32:26 <byorgey> Nucleo: yeah, it's not clear if there is a "correct" way to write out numbers, wrt. using "and" or not
10:32:44 <shapr> d00d
10:32:47 <Nucleo> byorgey: I'm told it's sometimes a British vs. American thing
10:33:13 <byorgey> Nucleo: perhaps, although I think even within the US there is variation
10:33:26 <hpaste>  dcoutts pasted "proposed verbosity levels for cabal configure" at http://hpaste.org/2280
10:33:36 <dcoutts> eivuokko, nominolo: ^^
10:33:38 <mauke> why does forkProcess suck so much
10:34:25 <ski> conal : i think i was thinking on something like 'instance Monoid o => MonadWriter o (Cont o) where tell :: Monoid o => o -> Cont o (); tell o = Cont (\k -> o `mappend` k ())'
10:36:44 <doserj> byorgey, I'm off by 24?
10:36:55 <nominolo> dcoutts: the warning is because we haven't fixed the working branch version, yet
10:37:00 <shapr> doserj: What's your projecteuler profile?
10:37:13 <byorgey> doserj: yup =)
10:37:47 <nominolo> dcoutts: the next version should be at least 1.2.  more likely 2.0, though, as we're about to break so much
10:37:53 <moonlite_> are there any definition that says how big an Int can be at maximum?
10:38:00 <moonlite_> um
10:38:11 <moonlite_> any defined "variable" that is
10:38:16 <mauke> > maxBound :: Int
10:38:21 <lambdabot>  2147483647
10:38:21 <nominolo> > maxBound :: Int
10:38:22 <lambdabot>  2147483647
10:38:24 <moonlite_> net thanks
10:38:28 <moonlite_> neat
10:38:49 <nominolo> @instances Bounded
10:38:50 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
10:39:10 <dcoutts> nominolo: I know why we get the warning, and yes 1.2 seems sensible
10:39:42 <doserj> byorgey, i special case 100, but not 200, 300, 400, etc...
10:39:50 <doserj> silly me ...
10:39:53 <byorgey> doserj: hehe
10:40:02 <nominolo> dcoutts: i'd be for a special case if packageName /= "Cabal" for that warning
10:40:19 <dcoutts> nominolo: I agree, a special case is ok there
10:41:18 <doserj> shapr, you can probably guess my project euler profile :)
10:43:08 <SamB> hmm. is it really not allowed to use qualified method names in instance declarations?
10:43:36 <shapr> heh
10:44:20 <xtacy[]> Hi, I have some trouble making Parsec parse a grammar...
10:44:31 <xtacy[]> *Parse a string ...
10:45:35 <doserj> shapr, oh, you cannot search for usernames on project euler?
10:46:15 <byorgey> doserj: no, I don't think you can
10:46:18 <doserj> http://projecteuler.net/index.php?section=profile&profile=15507
10:46:20 <lambdabot> Title: Project Euler
10:46:40 <samreid> xtacy[]: go on...
10:47:06 <xtacy[]> samreid: I have a grammar. For effective parsing using Parsec, I need to make it left factored, right?
10:48:12 <samreid> xtacy[]: that's recommended
10:48:40 <xtacy[]> samreid: yes, thats recommended, so as to reduce the amount of backtracking that Parsec has to do, right?
10:48:48 <samreid> xtacy[]: yes.
10:49:17 <xtacy[]> samreid: Now, I have a grammar... I tried all possible ways of inserting "try" statements, and still it doesnt recognize all words.
10:49:47 <xtacy[]> samreid: It backtracks, but sometimes, it doesn't. I will paste it, hold on ...
10:49:52 <samreid> ok
10:50:59 <hpaste>  xtacy[] pasted "parsec" at http://hpaste.org/2281
10:51:19 <xtacy[]> samreid: There it is ... I will also tell you what the Grammar is
10:52:17 <xtacy[]> samreid: S -> {L} | {}; L -> E | E,L | S; E-> { | } | ,
10:52:35 <jedai> @src fold
10:52:35 <lambdabot> Source not found. That's something I cannot allow to happen.
10:52:41 <jedai> @src foldl
10:52:42 <lambdabot> foldl f z xs = lgo z xs
10:52:42 <lambdabot>     where lgo z []     =  z
10:52:42 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
10:52:46 <xtacy[]> samreid: semicolon is for separating production rules :)
10:53:10 <oerjan> jedai: foldl' is usually recommended instead of foldl
10:53:19 <xtacy[]> samreid: S = set, L = list, E = expr in the code I pasted
10:54:00 <jedai> oerjan: I'm just checking how fold is implemented in the Prelude, I already know the different fold
10:54:53 <oerjan> jedai: note that sometimes lambdabot gives ghc's implementation instead, iirc
10:55:01 <jedai> @src foldl'
10:55:01 <lambdabot> foldl' f a []     = a
10:55:01 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
10:55:27 <ski> conal : also there's 'instance Monoid o => MonadPlus (ContT o (Cont r)) where mzero = ContT (\s -> Cont (\f -> f mempty)); ma0 `mplus` ma1 = ContT (\s -> Cont (\f -> ma0 `runContT` s `runCont` (\o0 -> ma1 `runContT` s `runCont` (\o1 -> f (o0 `mappend` o1)))))'
10:55:28 <jedai> oerjan: As I mainly use GHC, it's quite a good thing for me, but thanks for the warning
10:57:44 <desp> http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem
10:57:46 <lambdabot> Title: A type-based solution to the "strings problem": a fitting end to XSS and SQL-inj ..., http://tinyurl.com/uv94m
10:58:04 <desp> is there any Haskell web-package building on this?
10:59:10 <oerjan> Nucleo: btw i note that i do some strange things in that old program, such as using True <- return ... instead of guard ...
10:59:30 <sorear> .
10:59:31 <samreid> xtacy[]: shouldn't you have list include a "<|> try set" option?
10:59:39 <oerjan> (old? it's less than a year old. sheesh.)
10:59:48 <samreid> if you're translating from the grammar you've shown me
11:00:25 <SamB> desp: I thought the usual approach was to, er, use something other than strings in the first place?
11:00:48 <desp> SamB: ?
11:01:13 <SamB> i.e. using an EDSL for SQL queries...
11:01:33 <SamB> an XML library for building XML or HTML...
11:02:39 <SamB> well, I'm not sure you should use for URIs though
11:02:51 <samreid> xtacy[]: also, are you expecting the input "{{,,}" to successfully parse?
11:02:59 <SamB> Network.URI doesn't seem to have any decent support for adding things to the query string
11:03:32 <xtacy[]> samreid: Well, a "list" cannot go to a "set" according to the definition.
11:04:19 <samreid> xtacy[]: am I misreading S -> {L} | {}; L -> E | E,L | S; E-> { | } | ,?
11:04:31 <xtacy[]> samreid: Yes, I expect {{,,} to be successfully parsed.
11:04:47 <xtacy[]> samreid: Oh, i am really sorry.
11:04:55 <desp> SamB: soa re you aware of any Haskell packages for web development?
11:05:01 <xtacy[]> samreid: The production rules are:
11:05:02 <desp> s/a / a/
11:05:09 <xtacy[]> samreid: S -> {} | {L}
11:05:20 <xtacy[]> samreid: L -> E | E,L
11:05:32 <xtacy[]> samreid: E -> { | } | , | S
11:05:49 <xtacy[]> samreid: The set production comes in the "expr" and not "list" :)
11:05:54 <SamB> desp: well, I've heard of happs
11:06:10 <SamB> I've also heard of HaXml, HXT, and some other XML library...
11:06:19 <desp> yeah, that's just XML/HTML though
11:06:24 <desp> thanks, I see HAppS and hxweb
11:06:27 <SamB> I've heard of HSQL and HaskellDB, too
11:07:11 <SamB> anyway, you aren't likely to mix things up much if you use datatypes other than String for them...
11:08:03 <samreid> xtacy[]: ok.  What example does it not work properly on?
11:08:32 <oerjan> xtacy[]: {{},{}} is ambiguous afai can see
11:09:52 <xtacy[]> samreid: It doesnt accept {{}}
11:10:02 <xtacy[]> oerjan: Give me a minute, Let me work it out
11:10:54 <samreid> xtacy[]: yes it does
11:11:23 <xtacy[]> Hmm, one sec. I had one more string ...
11:12:44 <xtacy[]> oerjan: I dont see why the derivation of {{},{}} can be done in at least two different ways.
11:13:00 * glguy thinks that its cool that if you export an envvar in one urxvtc window, it is available in all of them
11:13:24 <xtacy[]> oerjan: The only way is: S -> {L} -> {E,L} -> {E,E} -> {S,S} -> {{},{}}
11:13:49 <glguy> (all of them that are created subsequently
11:14:01 <samreid> xtacy[]: S -> {L} -> {E} -> {S} -> {{L}} -> {{E,L}} -> {{E,E}} -> {{},{}}
11:14:07 <conal> ski: (i was out for a walk.)  thanks.
11:14:22 <ski> conal : yw
11:14:39 <xtacy[]> samreid: Uh oh :)
11:15:38 <oerjan> right
11:16:24 <xtacy[]> samreid: Alright, it doesnt accept {{} ... S->{L} -> {E} -> {{}
11:21:31 * thoughtpolice is now compiling xmonad since he unborked his gcc 4.2. :)
11:22:11 <dmead> where are the docs to make ghc spit out C code?
11:22:16 <dmead> @hoogle ghc
11:22:16 <lambdabot> Distribution.Setup.GHC :: CompilerFlavor
11:22:16 <lambdabot> Distribution.Simple.GHCPackageConfig :: module
11:22:16 <lambdabot> Distribution.Simple.GHCPackageConfig.GHCPackage :: String -> Bool -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -
11:22:16 <lambdabot> > [String] -> [String] -> GHCPackageConfig
11:22:27 <Botje> O_O
11:22:30 <dmead> @google ghc
11:22:33 <lambdabot> http://www.haskell.org/ghc/
11:22:33 <lambdabot> Title: The Glasgow Haskell Compiler
11:22:35 <Botje> dmead: the GHC user's manual tells you how.
11:22:37 <dmead> kk
11:22:58 <Botje> dmead: ah. it's the -C flag; apparently
11:23:39 <thoughtpolice> Botje: -keep-hc-file i think
11:24:50 <hpaste>  glen_quagmire pasted "one liner?" at http://hpaste.org/2282
11:26:29 <dmead> oh
11:26:37 <dmead> -keep-hc will let you have the C version of your code?
11:27:16 <dmead> the manual says it just uses gcc to compile
11:27:21 <dmead> not reeeally sure what that means
11:29:28 <glen_quagmire> :t (<-)
11:29:30 <lambdabot> parse error on input `<-'
11:29:32 <glguy>  /j #cups
11:29:35 <glguy> :-/
11:29:42 <xtacy[]> samreid: Any clues? Is it always possible to left factor out a Context Free Grammar?
11:29:46 <glen_quagmire> why I don't need let in num <- getLine ?
11:29:58 <glen_quagmire> but i need let blah = func n
11:30:15 <thoughtpolice> glen_quagmire: getline is in the IO monad
11:30:21 <mrd> you can convert it to chomsky normal form !
11:30:29 <samreid> xtacy[]: sorry, was afk
11:30:33 <dmead> glen_quagmire, <- is a monad thing
11:30:35 <thoughtpolice> so you need the <- to 'unsugar' it
11:30:42 <thoughtpolice> @type getLine
11:30:44 <lambdabot> IO String
11:30:48 <dmead> let x = y is normal lazyness
11:30:57 <thoughtpolice> glen_quagmire: think of the <- as taking the 'IO' out of 'IO String'
11:31:28 <glen_quagmire> how do I define type of   num  in :   num <- getLine ?
11:31:30 <hpaste>  oerjan annotated "one liner?" with "one way" at http://hpaste.org/2282#a1
11:31:32 <desegnis> glen_quagmire, <- is syntactic sugar and part of Â»doÂ« notation.
11:31:56 <xtacy[]> samreid: Okay :)
11:31:59 <byorgey> glen_quagmire: since getLine has type IO String, num has type String.
11:32:20 <glen_quagmire> i think i need to read more. my questions don't make sense
11:32:25 <shachaf> @src  when
11:32:25 <lambdabot> when p s = if p then s else return ()
11:32:30 <glguy> :t readLn
11:32:32 <lambdabot> forall a. (Read a) => IO a
11:32:37 <shachaf> oerjan: return () /= return []
11:32:50 <oerjan> argh!
11:33:20 * oerjan makes a note to get glasses
11:34:28 <hpaste>  Alan Falloon pasted "Defining last using foldr" at http://hpaste.org/2283
11:34:59 <Syzygy-> > return () :: [Int]
11:35:00 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
11:35:00 <samreid> xtacy[]: wait... how come set has (try expr) in it -- shouldn't that be (try list)?
11:36:12 <hpaste>  oerjan annotated "one liner?" with "one that might work" at http://hpaste.org/2282#a2
11:37:10 <roconnor> what ubuntu package has Graphics.Rendering.Chart.Gtk ?
11:37:17 <roconnor> err
11:37:19 <roconnor> oops
11:37:25 <roconnor> that's the haskell charting library
11:38:38 <xtacy[]> samreid: One sec...
11:39:59 <xtacy[]> samreid: Thats fine, but even If I change it to (try list), it doesnt accept: {}}
11:40:38 <samreid> xtacy[]: ok, but I'm looking at {{} right now
11:40:51 <roconnor> @where gtk
11:40:52 <lambdabot> I know nothing about gtk.
11:41:07 <shachaf> @where gtk2hs
11:41:07 <lambdabot> http://haskell.org/gtk2hs/
11:41:13 <roconnor> shouldn't the gtk bindings be in hackage?
11:41:27 <roconnor> oh, maybe cabal doesn't work with it
11:41:52 <samreid> xtacy[]: It doesn't work on "{{}" because it parses the opening '{', then in (try expr) (or (try list)) it parses "{}", and then expects "}".  But you're at the end of the input already.
11:42:30 <hpaste>  ski annotated "Defining last using foldr" with "no list destructuring but through 'foldr' " at http://hpaste.org/2283#a1
11:42:38 <samreid> xtacy[]: And on "{}}" it parses "{}" successfully and then eof fails.
11:42:57 <xtacy[]> samreid: Yes, I got that part. But since the string isnt accepted the string, shouldn't it backtrack?
11:43:14 <samreid> xtacy[]: no, not there
11:43:45 <oerjan> xtacy[]: it doesn't backtrack into something that has already succeeded
11:43:56 <xtacy[]> samreid: sorry for the horrible grammar of my previous sentence. s/the string,//
11:44:11 <xtacy[]> oerjan: But, I am enclosing every possible parse statement within a try block
11:44:18 <xtacy[]> oerjan: Shouldnt that help?
11:44:39 <samreid> p1 >> p2 means... "parse p1 [1], and then parse p2 with the remaining input".  Nowhere there is any notion of going back and trying again.
11:44:55 <xtacy[]> samreid: Alright. But, I am inserting the rule (try "{", list, "}") *first* before trying (string "{}")
11:45:00 <oerjan> xtacy[]: the problem is that if one subparser succeeds, even with try it will not do any more attempts with that subparser
11:45:01 <hpaste>  bos annotated "Defining last using foldr" with "golfing myLast" at http://hpaste.org/2283#a2
11:45:41 <glguy> isn't that mplus?
11:45:52 <glguy> or : flip mplus
11:46:00 <samreid> And at [1] the input that has been read is _gone_.  _gone_!  Unless some try block fails and restores it back to a previous state...
11:46:06 <dmead> aww
11:46:06 <ski> samreid : actually, if this is Parsec, you may allow backtracking with 'try p1 >> p2' iirc
11:46:16 <xtacy[]> oerjan: Ah :( Didnt know that. So, then, what could be the possible way out? I tried my best to rewrite the grammar in a "parsec friendly" way, couldnt succeed
11:46:16 <dmead> hello world via C is still 200k :<
11:46:22 <glguy> > let mylast xs = foldr (flip mplus . Just) Nothing xs in mylast [1,2,3]
11:46:30 <lambdabot>  Just 3
11:46:34 <glguy> > let mylast xs = foldr (flip mplus . Just) Nothing xs in mylast []
11:46:35 <lambdabot>  Nothing
11:46:46 <oerjan> ski: only if p1 fails.
11:47:00 <samreid> ski: if (try p1) succeeds it's exactly as if you had done (p1 >> p2)
11:47:03 <oerjan> if p1 succeeds but p2 fails then the whole parser fails
11:47:37 <xtacy[]> ski: Thats the problem here!
11:47:39 <hpaste>  sjanssen annotated "Defining last using foldr" with "do it with functions" at http://hpaste.org/2283#a3
11:47:58 <oerjan> xtacy[]: given how ambiguous your grammar is, you might try a parser with full backtracking.
11:48:05 <ski> oerjan,samreid : ok, i may indeed recall wrongly (i never liked the whole "disallow backtracking unless 'try'" thing in Parsec anyway)
11:48:26 <sjanssen> @pl foldr (\x xs _ -> xs x) id ys (error "myLast: empty list")
11:48:27 <lambdabot> foldr ((const .) . flip id) id ys (error "myLast: empty list")
11:48:50 <xtacy[]> oerjan: How do I specify full backtracking in Parsec?
11:49:09 <glen_quagmire> is there a way to specify type of let variable?    let num::Int = read line
11:49:29 <glguy> read line :: Int
11:49:30 <mauke> glen_quagmire: let num :: Int; num = read line
11:49:30 <sjanssen> glen_quagmire: let num :: Int; num = read line
11:49:31 <ski> sjanssen : nice .. now do 'zipWith' using 'foldr' :)
11:49:42 <sjanssen> ski: not possible, AFAIK
11:49:47 <glguy> glen_quagmire: if you are calling "read" on the result of a getLine, use readLn
11:49:55 <dolio> It is possible.
11:49:57 <oerjan> xtacy[]: you don't, you use something else.
11:49:59 <ski> sjanssen : then i have done the impossible
11:50:09 <oerjan> dolio: how?
11:50:15 <ski> @quote impossible
11:50:15 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
11:50:17 <sjanssen> ski: do you use 'head', 'tail', or 'null'?
11:50:17 <ski> @quote impossible
11:50:18 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
11:50:28 <ski> sjanssen : of course not !
11:50:29 <shapr> @ghc
11:50:29 <lambdabot> ghc says: A lazy (~) pattern connot bind existential type variables
11:50:31 <dolio> http://okmij.org/ftp/Algorithms.html#zip-folds
11:50:32 <lambdabot> Title: Algorithms and Data Structures
11:50:32 <sjanssen> ski: now I have to try this :)
11:50:33 <shapr> connot?
11:50:48 <olsner> @ghc
11:50:48 <lambdabot> ghc says: Interesting!  A join var that isn't let-no-escaped
11:50:50 <samreid> you should be able to add a backtracking version of (>>) to Parsec...
11:50:52 <ski> dolio : yes, i discovered that a few weeks after i did it myself
11:51:04 <glguy> @users
11:51:05 <lambdabot> Maximum users seen in #haskell: 385, currently: 380 (98.7%), active: 24 (6.3%)
11:51:05 <samreid> er, no, I'm being a moron.  Sorry.
11:51:33 <glen_quagmire> :t readLn
11:51:35 <lambdabot> forall a. (Read a) => IO a
11:51:53 <glguy> glen_quagmire: readLn = getLine >>= readIO
11:52:00 <tuxplorer> lemmih_:  http://hpaste.org/2277 mix_playMusic function plays only a small part of the music.. It plays something around a second or less than that.. Can you  please tell me what mistake am I making here?
11:52:02 <xtacy[]> oerjan: Hmm, now I am confused :) What else do I use? "Happy"?
11:52:18 <glen_quagmire> i'm just so noob reading chapter 3 of yaht
11:52:23 <tuxplorer> @seen lemmih_
11:52:23 <lambdabot> lemmih_ is in #haskell. I don't know when lemmih_ last spoke.
11:53:02 <ski> dolio,sjanssen : fyi, my version is at <http://www.mdstud.chalmers.se/~md9slj/code/FoldrZip.hs>
11:53:32 <dolio> ski: Oh yeah, I remember when you did this.
11:53:33 <samreid> xtacy[]: maybe ReadP?  I might be mistaken...
11:53:38 <ski> <lambdabot> shapr says: Academics are continually chewing pieces off of impossible and making them merely difficult.
11:53:46 <shapr> yay!
11:53:54 <ski> !
11:55:01 <xtacy[]> samreid: I didnt know about ReadP
11:55:07 <xtacy[]> @help ReadP
11:55:08 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:55:28 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadP.html
11:55:30 <lambdabot> http://tinyurl.com/uo5wd
11:55:39 <conal> is "deriving" separate from data/newtype defs in ghc head yet?  does anyone have a syntax pointer?
11:56:35 <lemmih_> tuxplorer: Try adding a delay after 'playMusic'.
11:56:59 <dolio> > let head' = foldr const (error "head': Empty list") ; tail' = snd . foldr (\a ~(l,_) -> (a:l, l)) ([], error "tail': Empty list.") in (head' [1..10], tail' [1..10])
11:57:01 <lambdabot>  (1,[2,3,4,5,6,7,8,9,10])
11:57:16 <xtacy[]> oerjan: Thanks, got that link ... I will experiment with ReadP and come back to you / samreid later ...
11:57:22 <dolio> If you define head and tail in terms of foldr, and then use those for zip, is it cheating? :)
11:57:32 <dolio> That's the easy way to do it. :)
11:58:05 <shapr> @quote ski
11:58:06 <lambdabot> ski says: please talk to your son or daughter about parametric polymorphism
11:58:31 <roconnor> @quote roconnor
11:58:31 <lambdabot> roconnor says: or maybe unsafeHead is even more unsafe than head.
11:58:39 <xtacy[]> oerjan: :( No tutorial on ReadP! Just the documentation
11:58:49 * sjanssen tries to decide whether he should look at ski's code or spend an hour trying to figure this out :)
11:59:10 <xtacy[]> oerjan: So its going to be some tough time for me :) I will try to figure it out ...
11:59:14 <ski> shapr : actually that quote comes from David Benjamin, on Usenet
11:59:14 <tuxplorer> lemmih_: That way, I need to know the exact length of the song to be able to play it fully right? Shouldn't SDL be able to detect that automatically? I understand that its not your decision, and that urs is a binding only.. But just a logical doubt..
11:59:19 * conal found http://haskell.org/haskellwiki/GHC/StandAloneDeriving
11:59:21 <lambdabot> Title: GHC/Stand-alone deriving declarations - HaskellWiki
11:59:39 <ski> dolio : yes, that's cheating :)
12:00:17 <dolio> What if you inline them? :)
12:00:17 <ski> sjanssen : try thinking about it first, i suggest :)
12:00:19 <lemmih_> tuxplorer: You just need to keep the program live for as long as you want the music to play.
12:00:22 <oerjan> xtacy[]: well, it is monadic like Parsec, so it should be somewhat similar.  Use +++ instead of <|>
12:00:41 <monochrom> tutorials are overrated
12:00:50 <ski> dolio : i'm not sure .. i want it to be "free-flowing" (i'm not sure i can explicate what i mean)
12:01:06 <ski> sjanssen : i can give you a hint, though, if you wish
12:01:09 <dolio> I suppose that still uses general recursion for zip.
12:01:12 <johnnowak> monochrom: do you have something against imparting vague half-understandings?
12:01:19 <dolio> Which is all nasty.
12:01:19 <sjanssen> ski: sure
12:01:29 <tuxplorer> lemmih_: is there something like getMusicLength or something through which I can determine the actual time length of a song file?
12:01:49 <xtacy[]> oerjan: Okay :) You will hang around in this channel, right? I will come back later if I desperately need any help :)
12:02:04 <lemmih_> tuxplorer: I don't know.
12:02:05 <oerjan> xtacy[]: i am not actually quite sure whether it does what you want.
12:02:18 <johnnowak> @quote tutorial
12:02:18 <lambdabot> monochrom says: The problem is that bad programmers will assess tutorials for good programmers as "ivory tower", and moreover bad programmers are the vocal majority.  It gets you bad press.
12:02:18 <oerjan> xtacy[]: unfortunately i am soon going to bed.
12:02:22 <ski> sjanssen : when i constructed my version, i thought of the two iterations through the two lists as two communicating coroutines (if you wish, you may consider the caller to be a third one)
12:02:33 <xtacy[]> oerjan: I will play around with it and see how I get along ...
12:02:37 <tuxplorer> lemmih_: Thanks :)
12:02:39 <lemmih_> tuxplorer: Using ghci is a easy fix.
12:02:41 <ski> dolio : right
12:02:59 <xtacy[]> oerjan: bed time for me too! But you should be around when you are awake, I suppose :D
12:03:42 <psykon> guys, i'm new to haskell and i was wondering, not supporting side-effects, why can't the compiler calculate everything at compile-time?
12:04:17 <sjanssen> psykon: Haskell has IO
12:04:27 <oerjan> xtacy[]: if it doesn't work, there are some parser libraries on hackage based on the _oldest_ monadic parser combinators, which i believe _were_ fully backtracking
12:04:36 <sjanssen> psykon: so we don't have all the needed information at compile time
12:04:51 <oerjan> (essentially monads for ReadS)
12:04:56 <ski> psykon : because your haskell program may construct an IO-action representing some effects to do, and then the run-time system will run that in the current world, thereby affecting it
12:05:23 <mauke> psykon: the compiler does calculate everything at compile time
12:05:27 <xtacy[]> psykon: Haskell also has Lazy Evaluation (eg: Infinite lists). You wouldnt want to evaluate that at compile time :) Input tells us how much we need of this list...
12:05:43 <xtacy[]> oerjan: Thanks, I will check them out ...
12:05:57 <xtacy[]> oerjan: Good night!
12:05:59 <oerjan> they were replaced because they were horribly inefficient when you didn't need full backtracking, i assume
12:06:09 <oerjan> good night!
12:06:21 <xtacy[]> oerjan: Oh,  :)
12:06:34 <ski> psykon : ignoring infinite (non-cyclic) IO-action, the compiler could compute the IO-action to run at compile-time, but it can't actually run it, since that requires access to the world to be affected when the program is run .. it can't access the future that way (at least i don't know any way to do this :)
12:07:15 * xtacy[] leaves to sleep
12:07:24 <mauke> all IO actions are finite
12:07:32 <mauke> or hmm
12:07:37 <tuxplorer> lemmih_: is there a library that provides ways to sample the amplitude frequency etc of a music file?
12:08:19 <mauke> wtf :: IO (); wtf = wtf >> return ()
12:08:29 <monochrom> all IO actions are blue.
12:08:35 <ski> mauke : even '(fix $ \loop n -> print n >> loop (n+1)) (0 :: Integer) :: IO a' ?
12:08:40 <psykon> sjanssen, i thought it was well isolated, that's what the introductions say, i haven't read about it yet
12:08:50 <mauke> ski: yes
12:09:04 <ski> mauke : that could still be represented in a cyclic way (though maybe mine can too, in some way i don't know)
12:09:12 <sjanssen> psykon: yes, pure code and IO code are separated by the type system
12:09:40 <mauke> ski: yours is just Bind (print 0) (someFunction)
12:09:47 <oerjan> mauke: all IO actions are finite in the same way as all Haskell data structures are finite
12:09:48 <mauke> i.e. a single-node action
12:10:01 <oerjan> i.e. they have a finite representation at any given time
12:10:01 <lemmih_> tuxplorer: I don't know.
12:10:12 <sjanssen> psykon: however, almost all programs go something like "main = do x <- getLine; print (f x)".  Even though 'f' is a pure function, we can't compute much at compile time because 'x' isn't known until run time
12:10:23 <tuxplorer> lemmih_: okay.
12:11:03 <mauke> oerjan: you can't make cycles in IO because >>= takes a function as its right hand arg
12:11:13 <mauke> a function is a finite value
12:11:27 <oerjan> ho hum
12:11:32 <ski> mauke : i was considering an implementation like 'data IO :: * -> * where Return :: a -> IO a; Bind :: IO a -> (a -> IO b) -> IO b; HPutChar :: Handle -> Char -> IO (); hGetChar :: Handle -> IO Char; ...'
12:11:43 <mauke> yep, me too
12:11:57 <oerjan> > let m = print "Ha!" >>= \_ -> m in m
12:11:58 <lambdabot>  Add a type signature
12:12:28 <oerjan> that's a cycle just as good as any cyclic list
12:12:31 <ski> mauke : but, yes, if the compiler manipulates the meta-representation, instead of actually running the code to compute the object-represention of 'IO Foo', it could of course handle such cycles as above
12:12:37 <mauke> oerjan: no, the cycle is in the evaluator
12:13:28 <oerjan> mauke: it contains a pointer to itself, just as l = 1:l does
12:13:35 <dolio> What if you include a constructor (:>>) :: IO a -> IO b -> IO b?
12:13:40 <ski> (mauke : any, anyway, my point is moot since 'Bind' has a function argument that can't be analysed in-language without calling it ..)
12:13:43 <mauke> oerjan: that's a bit like interpreting [Int] as a list of indices into itself, then saying [0] is a cyclic list
12:13:53 <dolio> Then forever m = m :>> forever m ...
12:14:45 <mauke> dolio: yeah, that would be an infinite value
12:16:05 <oerjan> mauke: what i am saying is that internally, _neither_ of m = print "Ha!" >> m  not l = 1:l have an infinite representation, even when fully evaluated
12:16:11 <oerjan> *nor
12:17:06 <oerjan> of course the former may be represented as something with a simple goto
12:17:50 <hpaste>  glen_quagmire pasted "how come main and printFactorial output differently?" at http://hpaste.org/2285
12:18:12 <monochrom> What is so infinite or finite about IO actions? I was trying to make a point by saying "IO actions are blue". You could say, the execution time of this IO action is infinite. You can say, the codeof this IO action is finite. The IO action itself, that's too abstract to be infinite or finite, blue or red.
12:18:56 <Botje> glen_quagmire: "let num = read line :: Int"
12:19:11 <Botje> that forces the number read (and thus the members of num) to be of type Int
12:19:24 <Botje> glen_quagmire: and Int only goes up to 2**32
12:19:28 <Botje> > 2**32 +1
12:19:29 <glen_quagmire> oh
12:19:30 <lambdabot>  4.294967297e9
12:19:34 <ski> oerjan : how about my example above ?
12:19:38 <Botje> .. or some other high number
12:19:44 <samreid> 2**31-1
12:19:49 <Botje> glen_quagmire: look at :t printFactorials
12:19:56 <glen_quagmire> is there a big integer?
12:20:04 <samreid> such as Integer?
12:20:07 <Botje> you'll see it's Num a => [a] -> IO ()
12:20:23 <glen_quagmire> yes
12:20:23 <ski> monochrom : yes, it depends on the representation
12:20:34 <glen_quagmire> And I can't do let nums = read line :: Num
12:20:47 <Botje> glen_quagmire: no, because num is a typeclass
12:20:48 <kjdf> glen_quagmire: Integer. It'd probably default to Integer if you omit ":: Int"
12:21:09 <oerjan> ski: which one?
12:21:09 <kjdf> glen_quagmire: if it doesn't, you can :: Integer
12:21:19 <ski> (fix $ \loop n -> print n >> loop (n+1)) (0 :: Integer) :: IO a
12:21:21 <Botje> "Num a =>" in a type says= "a is a type that behaves like a number"
12:21:25 <glen_quagmire> nice!
12:21:46 <mauke> > 2^100
12:21:47 <lambdabot>  1267650600228229401496703205376
12:22:15 <mauke> :t let x = 2^100 in x
12:22:17 <johnnowak> @quote giggidy
12:22:17 <lambdabot> forall t. (Num t) => t
12:22:17 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
12:22:25 <ski> (oerjan : note that my question is basically about what you consider to be part of the representation)
12:22:32 <oerjan> ski: that one won't be fully evaluated ever, i assume
12:23:09 <oerjan> well, ghc probably turns it into something imperative
12:23:27 <ski> oerjan : since, the compiler has a meta-representation of that that is surely finite .. while the object representation of it may or may not(?) be infinite
12:24:57 <oerjan> er, i guess.  although object representations are never actually infinite at any given time
12:25:02 <oerjan> in practice
12:25:19 <ski> i mean conceptually .. :)
12:25:24 <ski> anyway, gotta go
12:46:05 <sorear> @users
12:46:05 <lambdabot> Maximum users seen in #haskell: 385, currently: 366 (95.1%), active: 16 (4.4%)
12:48:32 <balodja> Activity of #haskell is extremely sharp :)
12:49:05 <dmead> allo sorear
12:49:39 <sorear> ello.
12:50:01 <glen_quagmire> halo2
12:54:35 <mnu> I'm trying to define an infinite set of prime numbers by sieving and recursion. Is it possible?
12:54:47 <mnu> I've got one function remMod (x:xs) = x:(xs \\ [2*x,3*x..(last xs)])
12:55:19 <wli> mnu: Prepare for a barrage of one-liners.
12:55:29 <EvilTerran> ooh, ooh, i've got one of those
12:55:30 <sjanssen> mnu: that will fail if 'xs' is infinite
12:55:40 <oerjan> hey, hey, i was trying to resist!
12:55:40 <mauke> > nubBy (((> 1) .) . gcd) [2 ..]
12:55:42 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:55:51 <sjanssen> mnu: use 'filter'
12:56:44 <wli> mnu: there's also primes = 2 : 3 : [p | p <- [5,7..], all (\q -> p `mod` q /= 0) (takeWhile (\q -> q^2 <= p) primes)
12:58:58 <EvilTerran> > let f (i:is) = i : f (filter (\j -> j `mod` i /= 0) is) in f [2..]
12:58:59 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:59:33 <oerjan> @src nubBy
12:59:33 <lambdabot> nubBy eq []             =  []
12:59:33 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:59:40 <glguy> mnu: it is possible
13:00:01 <oerjan> EvilTerran: as you see that's essentially nubBy you are using
13:00:11 <EvilTerran> so i see. ingenius.
13:01:22 <EvilTerran> ... mauke's is the same as nubBy relPrime [2..] where relPrime x y = gcd x y == 0, right?
13:01:36 <mauke> ... 0?
13:01:40 * EvilTerran still gets a little confused by (.)-sections
13:01:55 <mauke> @unpl (((> 1) .) . gcd)
13:01:56 <lambdabot> (\ e h -> (gcd e h) > 1)
13:01:58 <mnu> glguy: everyone else's approaches were so different (even if they were effectively sieves) than what I've been trying. I've got so much to learn...
13:02:05 <EvilTerran> sorry, s (==0) (/= 1)
13:02:19 <EvilTerran> brainfart.
13:02:23 <wli> gcd is inefficient, though; coprimality to a prime only needs one trial division.
13:03:41 <oerjan> wli: yeah, that one-liner is used only because it is the shortest
13:04:18 <wli> There's probably a way to extend the Sieve of Atkin to infinite lists.
13:04:20 <EvilTerran> is nubBy allowed to assume that eq is an equivalence relation?
13:05:04 <oerjan> EvilTerran: let's hope not
13:06:10 <EvilTerran> > nubBy (\i j -> j `mod` i == 0) [2..] -- if not, this should be safe
13:06:11 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:06:39 <EvilTerran> that is, if we're allowed to assume that all nubBy's will have exactly the same behaviour as the one in the report
13:07:34 <oerjan> > nubBy (>=) (map sin [1..])
13:07:38 <lambdabot> Terminated
13:08:09 <oerjan> > nubBy (<=) (map sin [1..])
13:08:13 <lambdabot> Terminated
13:08:33 <oerjan> > take 5 $ nubBy (>=) (map sin [1..])
13:08:34 <lambdabot>  [0.8414709848078965,0.9092974268256817,0.9893582466233818,0.9906073556948704...
13:08:49 <vincenz> the implications of that are disturbing
13:08:56 <vincenz> there's only a few unique values...
13:09:02 <vincenz> (less than the print-line-length)
13:09:43 <oerjan> no, but it takes longer and longer to get to the next larger one
13:09:52 <vincenz> oh right
13:09:53 * vincenz smacks himself
13:10:02 <vincenz> > nubBy eq (map sin [1..])
13:10:03 <lambdabot>   Not in scope: `eq'
13:10:08 <vincenz> > nubBy (==) (map sin [1..])
13:10:10 <lambdabot>  [0.8414709848078965,0.9092974268256817,0.1411200080598672,-0.756802495307928...
13:10:35 <oerjan> that one is rather unlikely to leave anything out in a long time
13:12:45 <vincenz> yeps
13:12:47 <vincenz> :)
13:13:06 <EvilTerran> nubBy (==) = nub...
13:16:30 <psykotic> oerjan, i think it's a standard exercise to show that sin(nx) is nonperiodic and, a fortiori, its image is dense in [-1,1]
13:16:44 <oerjan> psykotic: i know
13:32:47 <Runaro^BRS> ok, idle question
13:32:53 <Runaro^BRS> What is a monad?
13:33:01 <Mr_Awesome> magic
13:34:03 <mnu> An essential physical-plane experience.
13:34:16 <olsner> the official term is "warm fuzzy thing"
13:34:26 <Cale> Runaro^BRS: sure
13:34:32 <Mr_Awesome> i believe its also a species of south african monkey
13:34:33 <littledan> Runaro^BRS: there are about a million monad tutorials out there. You can google them. Basically, it's an abstraction over sequencing computation.
13:34:40 <EvilTerran> a type of functor!
13:35:19 <samreid> a device to break 16 minutes of silence!
13:35:24 <littledan> Runaro^BRS: they're trying to confuse you!
13:35:36 <Cale> Runaro^BRS: A monad is a particular kind of combinator library. A combinator library is a library with a rich enough API that programming using it is like programming with a small language embedded in the surrrounding one.
13:35:38 <Runaro^BRS> littledan: Right, I've seen a bunch of these tutorials, but none of them answers this question. What is a monad?
13:35:45 <mrd> a monad: the ties that bind
13:35:57 <mrd> types that bind
13:36:02 <Tchakkazulu> A monad is a thingy.
13:36:18 <Tchakkazulu> and a "Monad m => m a", is a thingy that has something to do with a.
13:36:25 <Cale> Runaro^BRS: That's a philosophical question. I could give you a mathematical answer to it which wouldn't be useful to you unless you have an degree in mathematics.
13:36:46 <Cale> I could give you a technical, but restricted to programming answer as well
13:36:47 <dolio> A monad is a triple (F, eta, *) :)
13:36:51 <Runaro^BRS> Cale: so a monad is an algebra?
13:36:52 <littledan> Runaro^BRS: a method of sequencing computations
13:37:04 <Tchakkazulu> And it has the magical property, that you can turn an 'a' into a thingy that has something to do with a.
13:37:21 <Tchakkazulu> And if you have a thingy that has something to do with thingies that have something to do with "a",
13:37:29 <dino-> That very recent post by Adam Turoff: "monads allow easy function composition that also ensures linear execution, much like you would expect from writing a series of statements within a function in C, a method in Java, or a block of Javascript. There are other interesting properties of monads, but this is the most fundamental."
13:37:31 <Cale> Runaro^BRS: How much mathematics do you know? Do you know what a natural transformation is?
13:37:38 <Tchakkazulu> then you can turn that into a just a thingy that has something to do with a.
13:37:41 <Tchakkazulu> ;)
13:37:51 <dolio> Oh, my bad, I guess it's mu, not *.
13:37:54 <monochrom> Warning: Too many chefs.
13:37:54 <olsner> I think we just went way, *way* past stereo
13:37:55 <Mr_Awesome> Tchakkazulu: youre not helping :P
13:38:06 <Olathe> Bork bork bork.
13:38:13 <Cale> http://planetmath.org/encyclopedia/Monad.html -- here's the technical definition
13:38:14 <Tchakkazulu> That's all a monad is without going into too much details :P
13:38:15 <lambdabot> Title: PlanetMath: monad
13:38:31 <monochrom> I suggest let's hear Cale.
13:38:55 <Cale> http://en.wikipedia.org/wiki/Monad_%28category_theory%29 -- you can also find discussion of the surrounding mathematics on wikipedia
13:38:57 <lambdabot> Title: Monad (category theory) - Wikipedia, the free encyclopedia
13:38:59 <dino-> I wonder if it wouldn't help to go through Adam Turoff's 3-part ONLAMP thing. Part 3 talks about monads. And none of it is very long.
13:39:11 <shachaf> Tchakkazulu: Don't you need fmap too?
13:39:31 <dino-> http://www.onlamp.com/pub/a/onlamp/2007/05/21/an-introduction-to-haskell---part-1-why-haskell.html
13:39:33 <lambdabot> Title: ONLamp.com -- An Introduction to Haskell, Part 1: Why Haskell, http://tinyurl.com/3cpyts
13:39:38 <Tchakkazulu> Oh, yes, true.
13:39:54 <Runaro^BRS> Cale: Thanks, that helps. I found Wikipedia not so helpful.
13:39:55 <Tchakkazulu> And if you have a thingy that has something to do with "a", and a method to turn "a" into "b",
13:39:59 <Cale> If you want a really glib and probably useless answer, a monad for the category C is a monoid object in the category of endofunctors on C.
13:40:05 <Tchakkazulu> then you can also get a thingy that has something to do with "b".
13:41:23 <mauke> what is "mu . (mu . T) = mu . (T . mu)" in haskell?
13:41:27 <Cale> Runaro^BRS: The mathematical perspective isn't really the one you normally take while programming though.
13:41:48 <Runaro^BRS> Cale: True. I am programming with monads without knowing what they are!
13:41:52 <oerjan> mauke: mu is join, T is fmap
13:42:05 <Tchakkazulu> Runaro^BRS: You could have invented them, even :)
13:42:07 <mauke> and what's eta?
13:42:11 <Runaro^BRS> My understanding of them is very much in the vain of Tchakkazulu's comments.
13:42:12 <oerjan> return
13:42:12 <Cale> mauke: return
13:42:16 <mauke> ah
13:42:20 <EvilTerran> join/liftM is an alternative axiomization to return/bind
13:42:37 <shachaf> EvilTerran: You mean join/liftM/return?
13:42:51 <EvilTerran> um... yes.
13:43:27 <Tchakkazulu> Also, if you have a thingy about "a", and a way to turn "a" into a thingy about "b", you can combine these two to make a thingy about "b" -_-
13:43:44 <Tchakkazulu> Heh, without going into details, that's _all_ a monad is, just fill in "thingy".
13:43:54 <oerjan> Tchakkazulu: you mean "warm fuzzy action", not "thingy" :D
13:44:09 <Tchakkazulu> Dammit, I knew I did something wrong.
13:44:13 <Cale> mu . T mu = mu . mu T translates to  join . join = join . fmap join
13:44:54 <monochrom> This community is too noisy.
13:44:56 <Cale> (we're a little more polymorphic than the original mathematics here :)
13:45:09 <Cale> the other laws are
13:45:16 <Cale> join . return = id
13:45:23 <Cale> join . fmap return = id
13:45:40 <mauke> but that's trivial!
13:45:55 <Cale> how is it trivial?
13:46:06 <Vq^> @type join . return
13:46:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
13:46:10 <mauke> (not entirely serious here)
13:47:00 <Runaro^BRS> @type fmap
13:47:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:47:04 <mauke> but return just adds a trivial monadic layer, and join removes it. so (join . return == id) is "intuitively obvious"
13:47:29 <olsner> @type fmap return
13:47:31 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
13:47:32 <Cale> Yeah, but that's exactly what the law says return does.
13:47:38 <olsner> @type return
13:47:40 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:47:42 <monochrom> axioms are supposed to be intuitively obvious. Like 0+x = x.
13:47:57 <mauke> fmap return is like return except it adds the layer on the inside
13:48:30 <monochrom> The fun only begins when you retract the axioms. "0+x=x may be false!"
13:48:37 <Cale> The typechecker automatically enforces that return and join are natural transformations. If it didn't, we'd also have the responsibility of proving that fmap f . return = return . f, and that fmap f . join = join . fmap (fmap f)
13:49:13 <EvilTerran> monochrom, sounds like floating point math ;]
13:49:15 <mauke> > let x = 0/0 in  0+x == x
13:49:16 <lambdabot>  False
13:49:59 <Cale> Also, there are laws which functors have to satisfy
13:49:59 <igel> btw: can someone tell me what the * in
13:50:02 <igel> @type fmap
13:50:03 <Cale> fmap id = id
13:50:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:50:06 <Runaro^BRS> ok, so in Haskell, T is fmap, mu is join. What's eta?
13:50:07 <igel> means?
13:50:08 <Runaro^BRS> return?
13:50:11 <Cale> fmap (f . g) = fmap f . fmap g
13:50:18 <Cale> Runaro^BRS: yep
13:50:19 <mauke> igel: it's a kind
13:50:21 <shachaf> igel: Its kind.
13:50:25 <shachaf> @kind Int
13:50:27 <lambdabot> *
13:50:29 <shachaf> @kind Maybe
13:50:31 <lambdabot> * -> *
13:50:33 <shachaf> @kind Maybe Int
13:50:34 <lambdabot> *
13:50:46 <igel> what is it for?
13:50:49 <shachaf> igel: Like types of types.
13:50:55 <EvilTerran> Runaro^BRS, something of kind * is just a type
13:51:07 <igel> ah
13:51:15 <EvilTerran> something of kind * -> * results in a type when given a single parameter
13:51:16 <igel> and * -> * is a type with parameter?
13:51:16 <shachaf> igel: It means that Functors are always a type constructor that gets one argument.
13:51:19 <mauke> igel: checking that you don't write stuff like 'Int Maybe -> Int -> Maybe' in type annotations
13:51:23 <EvilTerran> igel, sorry, not Runaro^BRS
13:51:51 <EvilTerran> in general, something of kind k1 -> k2 results in something of kind k2 when given something of kind k1
13:52:01 <shachaf> @kind (->)
13:52:03 <lambdabot> ?? -> ? -> *
13:52:21 <monochrom> pretend ?? and ? are * for the moment.
13:52:24 <EvilTerran> and values can only have types, nothing else type-level with a kind other than *
13:52:37 <igel> can you recommend me something to read about it?
13:52:40 <shachaf> @kind 1
13:52:42 <lambdabot> *
13:52:42 <shachaf> :-)
13:52:49 <mauke> igel: there's not really much to it
13:53:01 <Runaro^BRS> @kind return
13:53:02 <lambdabot> Not in scope: type variable `return'
13:53:12 <monochrom> http://haskell.org/onlinereport/decls.html#sect4.1.1  "Kinds"
13:53:13 <EvilTerran> ?kind StateT
13:53:13 <lambdabot> Title: The Haskell 98 Report: Declarations
13:53:13 <Runaro^BRS> ah well
13:53:15 <lambdabot> * -> (* -> *) -> * -> *
13:53:25 <monochrom> Students should not shy away from the reference manuals.
13:54:03 * pjd suddenly groks IO's join
13:54:29 <glen_quagmire> :t (foldl (:) [] [1::Int,2,3])
13:54:32 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
13:54:32 <lambdabot>       Expected type: a -> [a] -> a
13:54:33 <shachaf> pjd: What do you mean?
13:54:45 <Cale> :t return
13:54:45 <igel> ok, thank you all :)
13:54:46 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:54:48 <EvilTerran> @src flip -- glen_quagmire
13:54:48 <lambdabot> Source not found. stty: unknown mode: doofus
13:54:50 <monochrom> I don't think enlightenments are expressible over IRC.
13:54:53 <EvilTerran> @src flip
13:54:53 <lambdabot> flip f x y = f y x
13:55:08 <mauke> E/IRC
13:55:10 <glen_quagmire> :t (foldl (flip . :) [] [1::Int,2,3])
13:55:12 <lambdabot> parse error on input `:'
13:55:13 <mauke> new protocol extension
13:55:17 <Cale> > foldl (flip (:)) [] [1,2,3]
13:55:19 <lambdabot>  [3,2,1]
13:55:22 <monochrom> haha
13:55:35 <dino-> igel: Yet Another Haskell Tutorial has a section in Advanced Types about kinds: http://en.wikibooks.org/wiki/Haskell/YAHT/Type_advanced#Kinds
13:55:38 <glen_quagmire> hah
13:55:46 <EvilTerran> monochrom, sure, it might be necessary to re-express the enlightenment in haskell's type system first, though
13:55:52 <igel> great :O
13:55:57 <igel> s/O/)/
13:56:03 <Cale> #haskell is very high volume right now! :)
13:56:10 <pjd> shachaf: i mean, i get how to think about it in terms of only fmap+join, instead of bind
13:56:26 <Cale> Runaro^BRS: have you read any of my tutorials?
13:56:28 <monochrom> Wish we had that kind of technology. I'd just up my arrow stuff to your brain. To hell with tutorials.
13:56:35 <pjd> i don't know why the intuition eluded me before
13:56:44 <monochrom> s/up/upload/
13:56:51 <dino-> Yeah, this was reminding me of the containers thing.
13:56:58 <dino-> A personal favorite.
13:57:09 <shachaf> pjd: How is it different from other monads?
13:57:21 <pjd> it isn't :D
13:57:34 <Cale> Runaro^BRS: I wrote one recently which explains the most common general perspective of monads as kinds of computation, as well as one a while back about monads as container types.
13:57:56 <pjd> i also just realized that fmap on the IO monad is very much like .
13:57:58 <monochrom> Everyone is unique. Every monad is unique.
13:58:11 <pjd> just like fmap in the (->) monad
13:58:18 <Cale> Why is it that Google sucks at indexing the Haskell wiki?
13:58:27 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
13:58:28 <lambdabot> Title: Monads as computation - HaskellWiki
13:58:32 <shachaf> pjd: What do you mean?
13:58:34 <Cale> http://www.haskell.org/haskellwiki/Monads_as_containers
13:58:35 <lambdabot> Title: Monads as containers - HaskellWiki
13:58:36 <monochrom> the robot.txt file is problematic
13:58:37 <ari> Cale: Because of http://haskell.org/robots.txt maybe?
13:59:01 <Cale> Well, why do we have that?
13:59:19 <mauke> that shouldn't restrict access to content, right?
13:59:21 <dino-> Cale: Wow, thanks. I missed this yet somehow. Computations.
13:59:23 <monochrom> Perhaps robot.txt is a poor DSL.
13:59:35 <mauke> normal wiki urls don't contain ?
13:59:38 <shachaf> pjd: How is IO's fmap like (.)?
14:00:15 <oerjan> Cale: there were robots that logged every diff in the wiki history, bringing the server to its knees
14:00:23 <monochrom> One job of robot.txt is to prevent indexing past editions.
14:00:33 <Cale> shachaf: It's like the composition of the impure computation with the pure function, I suppose
14:00:48 <pjd> shachaf: like (*2) `fmap` (length `fmap` getLine)
14:01:59 <shachaf> pjd: That's how fmap behaves everywhere. :-)
14:02:18 <mauke> that just shows that (.) is a kind of map
14:02:21 <shachaf> (*2) `fmap` (length `fmap` [[1,2,3],[4,5,6]]
14:02:39 <oerjan> fmap (f . g) = fmap f . fmap g was mentioned above
14:03:25 <mauke> fmap (fmap f g) = fmap (fmap f) g braincramp
14:03:47 <dozer> appUnPickle in hxt is currently St -> (Maybe a, St) but I guess I want to re-write it to StateT St (MonadError String) a  instead?
14:03:59 <littledan> @src fmap
14:04:00 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:04:13 <mauke> littledan: fmap is a method in Functor
14:04:33 <oerjan> @src Functor
14:04:33 <lambdabot> class  Functor f  where
14:04:33 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:04:49 <Tchakkazulu> ?src ((->) t) fmap
14:04:49 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:04:52 <Tchakkazulu> :-/
14:04:57 <mauke> @src -> fmap
14:04:58 <lambdabot> Source not found. Wrong!  You cheating scum!
14:05:06 <EvilTerran> @src (->) fmap
14:05:06 <lambdabot> fmap = (.)
14:05:15 <littledan> @instances Functor
14:05:16 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:06:33 <pjd> shachaf: right, but the IO fmap is particularly like "plain" composition
14:07:04 <shachaf> (*2) `fmap` (length `fmap` Just "string")
14:07:09 <mauke> unlike, say, the Maybe fmap?
14:07:12 <pjd> it would be really nifty if you could write (*2) . length . getLine
14:07:17 <EvilTerran> @src (->) (>>=)
14:07:18 <lambdabot> f >>= k = \ r -> k (f r) r
14:07:26 <shachaf> pjd: Some people want (.) to be fmap.
14:07:33 <mauke> pjd: import Prelude hiding ((.)); a . b = fmap a b
14:07:39 <pjd> right :)
14:07:43 * shachaf remembers Cale had a good objection, but not what the good objection was.
14:07:52 <pjd> edwardk has a post about it
14:08:08 <Cale> I actually proposed using that notation :)
14:08:13 <Cale> But there is one problem
14:08:18 <shachaf> Cale: I know. :-)
14:08:27 <Cale> Normally, you can rely on f . (g . h) = (f . g) . h
14:08:31 <EvilTerran> it'd cause some rather newbie-unfriendly errors, and it'd need very good defaulting...
14:08:33 <pjd> mauke: Maybe/List are slighty different, in that you don't usually use . against a "value"
14:08:33 <Cale> but that's not true for fmap
14:08:35 <shachaf> Oh, right associativity.
14:08:40 <shachaf> s/t/t,/
14:08:58 <Cale> (because polymorphism screws things up :)
14:09:03 <oerjan> Cale: actually, isn't it?
14:09:15 <mauke> I don't see the problem
14:09:21 <Cale> Those two can both be well typed, but be different.
14:09:24 <EvilTerran> oerjan, mauke, the (.)s can be in different functors
14:09:25 <Runaro^BRS> let's take Maybe. What are the roles of fmap and join in Maybe?
14:09:37 <oerjan> oh right
14:09:38 <Cale> > fmap (*2) (Just 5)
14:09:40 <lambdabot>  Just 10
14:09:41 <pjd> that is, f `fmap` (g `fmap` Just 5) corresponds to f . g . 5, which isn't what you'd usually write
14:09:49 <Cale> > join (Just (Just 10))
14:09:50 <lambdabot>  Just 10
14:09:54 <Cale> > join (Just Nothing)
14:09:56 <lambdabot>  Nothing
14:10:02 <Cale> > join Nothing
14:10:04 <lambdabot>  Nothing
14:10:19 <oerjan> EvilTerran: er wait, no they cannot
14:10:19 <glen_quagmire> \x -> x x -- isn't this valid lambda calculus?
14:10:21 <Cale> > fmap (*2) Nothing :: Maybe Integer
14:10:22 <lambdabot>  Nothing
14:10:36 <shachaf> glen_quagmire: That's join.
14:10:39 <Cale> glen_quagmire: It's not valid simply typed lambda calculus
14:10:45 <Cale> shachaf: no it isn't
14:10:48 <EvilTerran> can't they? oh well. Cale seems to be up to something, ask him. =]
14:10:54 <shachaf> Oh, oops.
14:10:57 * shachaf feels silly.
14:11:02 <shachaf> Right.
14:11:07 <Cale> glen_quagmire: What type would x have?
14:11:08 <glen_quagmire> it's Y combinator?
14:11:22 <Cale> No, it's just part of the traditional Y combinator.
14:11:24 <EvilTerran> glen_quagmire, which is not expressible in the simply typed lambda calculus
14:11:25 <oerjan> :t \f g h -> f `fmap` (g `fmap` h)
14:11:27 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
14:11:31 <glen_quagmire> x :: (a -> b) -> (a -> b)
14:11:47 <oerjan> :t \f g h -> (f `fmap` g) `fmap` h
14:11:49 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
14:11:54 <glen_quagmire> hrm no i think x is infinite
14:12:03 <oerjan> they have the exact same type
14:12:10 <EvilTerran> and haskell's type system, without ADTs and classes, has the same expressibility
14:12:49 <oerjan> and _because_ fmap in (->) is ., their equality follows by the Functor law
14:13:42 <Runaro^BRS> >fmap (*2) (Maybe 5)
14:13:53 <shachaf> Runaro^BRS: Add a space.
14:13:54 <glen_quagmire> fmap is out of reach for me now
14:13:55 <Runaro^BRS> > fmap (*2) (Maybe 5)
14:13:56 <lambdabot>   Not in scope: data constructor `Maybe'
14:13:58 <shachaf> Runaro^BRS: And you want Just.
14:14:03 <shachaf> Runaro^BRS: Not Maybe.
14:14:23 <Runaro^BRS> oh, right. Maybe is a type.
14:14:58 <shapr> It's oh so quiet...
14:15:13 <dolio> @type ((\x -> x x) :: (forall a. a -> b) -> b)
14:15:14 <lambdabot> forall b. (forall a. a -> b) -> b
14:15:31 <Runaro^BRS> > fmap (*2) [1,2]
14:15:32 <lambdabot>  [2,4]
14:15:58 <Runaro^BRS> > join [[1,2],[3,4]]
14:16:00 <lambdabot>  [1,2,3,4]
14:16:06 <Runaro^BRS> > join [1,2]
14:16:07 <lambdabot>   add an instance declaration for (Num [a])
14:16:07 <lambdabot>     In the expression: 2
14:16:17 <Runaro^BRS> > join [[]]
14:16:19 <lambdabot>  []
14:16:25 <kilimanjaro> :t join
14:16:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:17:17 <Runaro^BRS> makes sense
14:18:50 <EvilTerran> @src join
14:18:51 <Cale> oerjan: Well, here's a case where one doesn't type but the other does. I forget the example where they both type and mean different things.
14:18:51 <lambdabot> join x =  x >>= id
14:18:58 <Cale> damn
14:19:13 <EvilTerran> join mx = do x <- mx; x
14:30:18 <Runaro^BRS> > join (fmap fmap)
14:30:26 <lambdabot>      Occurs check: cannot construct the infinite type:
14:30:26 <lambdabot>       f = (->) (f (a -...
14:30:36 <Runaro^BRS> @type join (fmap fmap)
14:30:38 <lambdabot>     Occurs check: cannot construct the infinite type:
14:30:38 <lambdabot>       f = (->) (f (a -> b))
14:30:47 <Runaro^BRS> uh oh
14:31:48 <EvilTerran> @type join (fmap . fmap) --?
14:31:50 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> a -> f (f a)
14:32:00 <Cale> @type join . fmap (fmap ?f)
14:32:01 <lambdabot> forall a b (f :: * -> *). (Monad f, ?f::a -> b, Functor f) => f (f a) -> f b
14:32:21 <Cale> that's probably the one you're looking for
14:32:55 <Cale> @type fmap ?f . join
14:32:56 <lambdabot> forall b (m :: * -> *) a. (?f::a -> b, Functor m, Monad m) => m (m a) -> m b
14:33:27 <Runaro^BRS> EvilTerran had the one I was looking for
14:33:50 <Runaro^BRS> forgot the dot
14:33:57 * EvilTerran is always getting his (.)s, ($)s, and vanilla applications mixed up ;]
14:34:13 <Runaro^BRS> @type map map
14:34:16 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
14:34:19 <Runaro^BRS> @type map . map
14:34:21 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
14:34:22 <hpaste>  dozer pasted "do these look similar to you?" at http://hpaste.org/2286
14:34:42 <dozer> does it look like I've monadised that code right?
14:34:57 <dozer> I'm new to combining Error and State
14:35:04 <EvilTerran> pickle?
14:35:05 <Runaro^BRS> @type map map . map map
14:35:07 <lambdabot> forall a b. [a -> b] -> [[[a]] -> [[b]]]
14:35:10 <Runaro^BRS> teehee
14:35:21 <EvilTerran> @type flip flip flip flip
14:35:23 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
14:35:27 <EvilTerran> >:]
14:35:40 <Runaro^BRS> sheesh
14:35:54 <Runaro^BRS> @type flip . flip . flip . flip
14:35:56 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
14:36:20 <EvilTerran> @type (flip .) (flip .) (flip .) (flip .)
14:36:22 <lambdabot> forall a c a1 a2 b c1 a3. (a1 -> a -> ((a3 -> a2 -> b -> c1) -> a3 -> b -> a2 -> c1) -> c) -> a1 -> a -> c
14:36:32 <Runaro^BRS> hahaha
14:36:42 <Runaro^BRS> I can't read that at all
14:36:56 <mauke> @. djinn type (flip .) (flip .) (flip .) (flip .)
14:36:58 <lambdabot> f a b c = a b c (\ d e f g -> d e g f)
14:37:09 <Runaro^BRS> ooh
14:37:50 <EvilTerran> @unpl (flip .) (flip .) (flip .) (flip .)
14:37:50 <lambdabot> (\ c g k -> c g k (\ p ab n o -> p ab o n))
14:38:26 <dolio> unpl makes interesting variable name choices.
14:38:28 <Runaro^BRS> @. djinn type flip flip flip flip
14:38:30 <lambdabot> f a b = a b (\ c d e -> c e d)
14:39:09 <EvilTerran> indeed. djinn.type seems to do a nicer job, in general
14:39:21 <EvilTerran> although is much less general, i imagine
14:39:40 <mauke> @. djinn type foldr  -- optimized!
14:39:42 <lambdabot> f _ a _ = a
14:40:00 <Tchakkazulu> >_<
14:42:20 <rubyruy> last night i couldn't sleep and came up with this: http://pastie.textmate.org/88398
14:42:21 <EvilTerran> ah, that too.
14:42:22 <lambdabot> Title: #88398 - Pastie
14:42:23 <newsham> hi
14:42:57 <EvilTerran> um. this is #haskell.
14:43:18 <lament> rubyruy: next time, try a sleeping pill.
14:43:32 <dolio> No non-alphanumeric symbols?
14:43:46 <rubyruy> i thought you guys might like the idea ...
14:43:57 <rubyruy> it's haskellian type inference for ruby :p
14:44:01 <rubyruy> (kind of)
14:44:20 <lament> does that just create a string of random alphanumeric characters?
14:44:29 <rubyruy> that's just a sample function
14:44:39 <mauke> . <- point  you -> .
14:44:41 <rubyruy> this line is the interesting part: Engine.infer( Tests, :generate_passwd ).to_s # => "Tests#generate_passwd(Fixnum length) -> String s"
14:45:14 <rubyruy> it is not 'compile time' strictly speaking but it does not need to execute the source - it simply analysises ruby's internal AST
14:45:17 <conal> rubyruy: do you have to side-effect password?  or can you express it in a single comprehension?
14:45:41 <lament> rubyruy: cute, now turn that into a JIT compiler
14:46:04 <conal> rubyruy: so close to being declarative.
14:46:20 <lament> in python, the password generation bit would be [random.choice(chars) for x in range(length)]
14:46:31 <rubyruy> conal: the function itself is just something i grabbed from a snippet site so it's not completely contrived
14:46:41 <rubyruy> don't mind it. at all.
14:46:52 <mauke> join '', map $chars[rand @chars], 1 .. $length  # perl
14:47:14 <conal> rubyruy: now i see the inference part.  neat.
14:47:15 <lament> oh crap, the python thing actually has ''.join() around it
14:47:42 <Cale> rubyruy: hmm
14:48:19 <rubyruy> i think if i were to teach it 'type classes' it could be made workable
14:48:44 <rubyruy> so you can have a return type like -> String | Fixnum | nil and so forth
14:50:06 <Cale> How are you currently accomplishing inference? Ruby lets you have the AST for the code?
14:51:44 <Cale> rubyruy: oh, sorry, I see you mentioned that above :)
14:52:26 <rubyruy> yeah there's a wonderful library that lets you work with the AST directly. It turns ruby into s-expressions. Kinda scary actually
14:53:55 <EvilTerran> lisby?
14:54:02 <EvilTerran> (like liskell, only ruby...)
14:54:04 <dolio> You don't actually need type classes for return types like 'Stirng | Fixnum' that's just a sum type.
14:54:07 <pjd> rubyruy: what kind of inference is that?
14:54:16 <Cale> rubyruy: Yeah, dealing with the potential for multiple return/parameter types could be tricky. From what I understand, subtype polymorphism makes type inference difficult :)
14:54:17 <rubyruy> yeeeep :p
14:54:59 <rubyruy> subtype polymorphism ?
14:55:02 <pjd> Hindley-Milner, abstract interpretation?
14:55:24 <rubyruy> um the ... Rubyruy-Caffeine Algorithm
14:55:58 <rubyruy> (sorry - i am most decidedly not hip with the terminology)
14:56:17 <Cale> rubyruy: like String is a subtype of String | Integer, or more commonly, a subclass gives a subtype of its superclass
14:56:47 <Cale> So Dog is a subtype of Animal
14:57:41 <rubyruy> well i would just write my own  is_suptype_of? checker
14:57:52 <ddarius> Cale: Prove it
14:57:54 <dibblego> what is the name of the logical fallacy, when you precede with a word like "obviously" or "clearly" as if supporting the proposition is unrequred?
14:58:13 <rubyruy> that could make that sort of judgement independent of ruby's own class system
14:58:18 <pjd> proof by assertion?
14:58:31 <monochrom> You need a name for that?
14:58:40 <dibblego> I don't think it's that
14:58:47 <dibblego> monochrom, it has a name; I just can't recall it
14:59:20 <monochrom> something about pretending to be authorative?
14:59:44 <dibblego> no, not appeal to authority
14:59:51 <Cale> invalid proof :)
14:59:53 <Runaro^BRS> @type (*).(*)
14:59:55 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
15:00:45 <monochrom> Sometimes it hurts my feeling that there is so much noise in the world that we need to classify and name various kinds of noise so as to expose them as noise.
15:01:31 <dibblego> monochrom, I find it helps to have a name so that if you make the mistake yourself, you can see it more easily
15:01:32 <SamB> "obviously" works okay when it means "there is a short proof that I could write here, but I think it would be boring so I won't"
15:01:32 <dozer> monochrom: but without names for the more obvious logical falacies, how could we color in arguments presented by creationists with one color per distinct falacy?
15:01:52 <SamB> dozer: heh
15:02:10 <monochrom> Whenever someone says, "look at that computer, it's so dumb, no? therefore it's dumb." you need to call it "circular argument!", otherwise people actually believe it.
15:02:23 <wli> Most are a veritable rainbow of fruit flavors.
15:02:27 <SamB> dozer: what makes you think any given word is necessarily only participating in a single fantasy
15:02:30 <SamB> er.
15:02:30 <shapr> After playing around with http://www.haskell.org/haskellwiki/Blow_your_mind for a few hours, I accidentally looked at some imperative code ... and it looks so ... clunky and ritualistic.
15:02:31 <lambdabot> Title: Blow your mind - HaskellWiki
15:02:31 <SamB> falacy
15:02:34 <shachaf> dibblego: http://www.bluemoon.net/~watson/proof.htm seems to call it "proof by obviousness".
15:02:35 <lambdabot> Title: 36 Methods of Mathematical Proof
15:02:40 <SamB> what a typo...
15:02:46 <shachaf> dibblego: Though that's probably not what you were looking for.
15:03:01 <dozer> lol - there's room for non-primary colors too, SamB
15:03:10 <dibblego> shachaf, no, I'll have to search through my books at home (or wherever I read it)
15:03:13 <SamB> dozer: what? you only have three falacies?
15:03:20 <dibblego> shachaf, thanks
15:03:24 <shapr> SamB: Now you're doing it on porpoise.
15:03:24 <Runaro^BRS> > (*).(*) 10
15:03:26 <lambdabot>  <Integer -> Integer -> Integer>
15:03:29 <Runaro^BRS> What does it mean?
15:03:39 <SamB> how about we also color the arguments of the athiests ;-)
15:03:55 <shachaf> Runaro^BRS: Look at the type of (*).(*) again.
15:03:57 <dibblego> SamB, Atheists
15:03:59 <shachaf> @ty (*).(*)
15:04:01 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
15:04:23 <SamB> dibblego: we could also color the arguments of the spellers
15:04:32 <shachaf> Runaro^BRS: First: Did you mean "(*).(*) 10" or "((*).(*)) 10"?
15:04:33 <dozer> SamB_XP: if they are also realist ontologists, you probably need a similar pallet
15:04:36 <mauke> > ( (*).(*) 10 ) 2 3
15:04:38 <lambdabot>  60
15:04:49 <SamB> dozer: whats?
15:05:00 <SamB> anyway, I meant dogmatic atheists
15:05:35 <dozer> I think it probably applies to dogmatic foos
15:05:40 <Runaro^BRS> @djinn (a -> (a -> a) -> a -> a) -> (a -> a)
15:05:40 <lambdabot> f a b = a b (\ c -> c) b
15:05:44 <monochrom> Another example. Whenever Cale says "look at metamath.org, those formal proofs there are so tedious, 0+0=0 takes 500 steps, no? Therefore all formal proof systems are tedious"  you have to raise "strawman attack!" or "overgeneralization", otherwise Cale continues to believe his little ignorant stance.
15:06:23 <Cale> monochrom: But they *are* all tedious. :)
15:06:32 <shapr> Are they tedious with a proof assistant?
15:07:02 <Cale> Perhaps not with a machine doing the work for you, but understanding what that machine has done is generally very tedious.
15:09:22 <Cale> (typically orders of magnitude more tedious than just proving the result for yourself)
15:10:06 <ddarius> So you don't verify the proof.  You verify the proof of the proof verifier.
15:10:40 <ddarius> Of course, developing the proof yourself is more effective at providing understanding.
15:10:44 <Cale> The result generally isn't the important part.
15:11:07 <Cale> The content of mathematics is in the proofs.
15:11:46 <Arnia> Unless you're an extreme Popper fan
15:11:51 <ddarius> Not exactly.  It's in the process of proving.
15:12:16 <monochrom> I do not understand why people must equate "formal" with "trace all the way back to axioms". It is not the case. Usually you just trace back to a few known theorems and be done.
15:12:44 <shapr> monochrom: Because proof assistant don't have cabal support yet. Otherwise they'd do just that.
15:12:47 <monochrom> I also do not understand how you go from "formal" to "understand what the machine does".
15:12:51 <Arnia> For me 'formal' means 'machine automatable'
15:13:17 <Arnia> (note, not necessarily 'automatED')
15:13:34 <bluestorm> hm
15:13:41 <Cale> Arnia: well, that I'm okay with
15:13:42 <shapr> Hiya bluestorm
15:13:54 <bluestorm> i recently read a quite interesting paper about this
15:13:55 <Tchakkazulu> Proof by lack of paper: "I have a truly marvelous proof of this proposition which this margin is too narrow to contain."
15:13:57 <monochrom> shapr: You're just joking?
15:14:02 <shapr> monochrom: No, actually I'm not.
15:14:03 <Cale> Rigourisable, rather than rigourous
15:14:23 <bluestorm> http://fresh.homeunix.net/~luke/misc/p271-de_millo.pdf
15:14:29 <dozer> Arnia: that's quite a narrow definition of formal - there are lots of things that people can prove that machines can't
15:14:34 <monochrom> OK. HOL is a proof assistant that doesn't trace all the way back to axioms.
15:14:39 <dozer> or atleast machines can't discover the proofs themselves
15:14:43 <shapr> monochrom: If most of the proofs being done now were available to Coq such that you could just download them, things would move a lot faster.
15:14:46 <Olathe> dozer: What are some of those proofs ?
15:15:10 <bluestorm> Â« It is argued that formal verifications of programs, no matter how obtained, will not play the same key role in the development of computer science and software engineering as proofs do in mathematics. Â»
15:15:35 <ddarius> Cale: There's a difference between rigourisable rather than rigourous and automatable rather than automated.
15:15:37 <SamB> who the heck was stupid enough to argue that?
15:15:46 <Cale> ddarius: of course
15:15:57 <SamB> computer science is a branch of mathematics, didn't they hear?
15:16:05 <bluestorm> shapr: http://helm.cs.unibo.it/ ?
15:16:07 <lambdabot> Title: HELM Home Page
15:16:15 <fuxxx> idiom question: i have a function fn (:: a->b->a) that i run through foldl' on a list [b] to get a value, but the function is such that at a certain point i know that the value a-value being passed won't change for none of the remaining b-values will change it so the last half of foldl' is redundant.. is there a standard lib function for "breaking out" early or something like that when a predicate occurs?
15:16:26 <bluestorm> SamB:
15:16:27 <Cale> For example, I can tell you: take two tori, remove a disc from each, and sew a cylinder in between them, without having to actually describe the equivalence relation I'm using -- I'm sure you can pick an actual representation of the torus and an appropriate equivalence relation for yourself.
15:16:29 <dozer> Olathe: it's realy easy to end up with a logic where some proofs can be constructed by hand, but deterministic searches fail for some cases
15:16:36 <bluestorm> i honestly think you should read the paper first
15:16:42 <bluestorm> it's a polemic one
15:16:43 <dibblego> SamB, actually, the reason I asked the earlier question was because someone wrote (paraphrased), "obviously practical software has nothing to do with mathematics"
15:16:44 <ari> fuxxx: Yes there is, it's called foldr ;)
15:16:49 <bluestorm> and i don't agree with everything
15:16:52 <ddarius> dozer: There really isn't a compelling argument for a "formal" system that's not automatable.
15:16:53 <bluestorm> but it's interesting
15:17:08 <ddarius> dozer: It's not the proof search that needs to be automatable.
15:17:13 <ari> @src or
15:17:13 <lambdabot> or    =  foldr (||) False
15:17:18 <Arnia> Proof check
15:17:20 <SamB> well, clearly the argument to be made is about whether practical software has much to do with computer science or not
15:17:25 <fuxxx> ari, i just get stack overflow with folr.. long lists.
15:17:29 <dozer> ddarius: there are systems where the proof can be validated automatically even if it can't be found automatically, and these still have utility
15:17:36 <fuxxx> hm
15:18:02 <ddarius> dozer: I just said it's not the proof search that needs to be automatable.
15:18:25 <dozer> ddarius: ah, ok - my bad for coding and typing at the same time
15:19:19 <ddarius> dozer: So the real question is are there systems that can reasonably be called "formal" where proof verification is not automatable.
15:20:24 <byorgey> fuxxx: paste an example?
15:20:32 <byorgey> @hpaste
15:20:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:20:57 <bluestorm> SamB : not only
15:21:23 <ari> Can anyone provide an example of (-) behaving in a surprising way? (i.e. being negate when you expect it to mean subtraction, or vice versa)
15:21:30 <bluestorm> in the http://fresh.homeunix.net/~luke/misc/p271-de_millo.pdf paper it's argued that what mathematicians call "proof" isn't a formal-machine-checkable process
15:21:35 <Saizan> fuxxx: you may want a foldM in the Either e monad
15:21:35 <bluestorm> but rather a "social" one
15:21:59 <dolio> > map (-5) [1..10]
15:22:04 <lambdabot>   add an instance declaration for (Num (a -> b))
15:22:08 <bluestorm> (social means something like "how, i'll show this to my co-workers, and then get it approved in some closed scientific review")
15:22:15 <mauke> > map (+5) [1..10]
15:22:16 <lambdabot>  [6,7,8,9,10,11,12,13,14,15]
15:22:17 <Arnia> bluestorm: that's a Popper-style approach
15:22:20 <ari> dolio: Hm... that was simpler than I thought :/
15:22:24 <ari> dolio++
15:22:32 <EvilTerran> > map (- 1) [1..10]
15:22:32 <lambdabot>   add an instance declaration for (Num (a -> b))
15:22:47 <littledan> > map ((-)1) [1..10]
15:22:48 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
15:23:02 <EvilTerran> whups, beaten ;]
15:23:03 <bluestorm> hm
15:23:13 <bluestorm> Arnia: you're right
15:23:22 <mauke> > map (subtract 1) [1..9]
15:23:23 <lambdabot>  [0,1,2,3,4,5,6,7,8]
15:23:26 <EvilTerran> > const -1
15:23:27 <lambdabot>   add an instance declaration for (Num (a -> b -> a))
15:23:27 <lambdabot>     In the expression: ...
15:23:29 <bluestorm> i didn't noticed that actually
15:23:34 <EvilTerran> ari, there's one the other way
15:24:01 <ari> EvilTerran: Thanks!
15:24:02 <bluestorm> i think this wasn't emphasized but their proofs are a bit like "experiments" to stress the actual solidity of the theory
15:24:03 <ari> EvilTerran++
15:24:07 <EvilTerran> :D
15:28:35 <hpaste>  fuxxx pasted "(no title)" at http://hpaste.org/2287
15:29:02 <shapr> bluestorm: Yeah, just like that!
15:29:05 <fuxxx> Saizan/ari, there you go..
15:29:50 <shapr> fuxxx: Wouldn't you want it to be lazy instead of strict?
15:30:20 <shapr> oh, tco
15:30:27 <fuxxx> not sure.. i'm pretty new to haskell. but i know that if i use foldl instead of foldl it stack overflows.
15:30:36 <fuxxx> foldl' even
15:30:46 <Cale> http://mizar.org/fm/2006-14/pdf14-1/matrixr1.pdf -- have a look at this. It's a decent attempt, but they're not even leaving the proofs in, and it's still pretty tedious. You can get lots more at: http://mizar.org/fm/
15:30:53 <shapr> The list comprehension solution is lazy.
15:31:11 <Cale> It's simply a list of mostly utterly boring results.
15:31:52 <Cale> But you need such results if you want to be completely formal.
15:31:55 <Arnia> Cale: yes, which you have in your head when understanding the key theorems
15:32:05 <shapr> I'm interested in program generation from Coq etc, I think this sort of library will be helpful.
15:32:21 <Arnia> It wouldn't be a valid proof if it wasn't rigourous
15:32:36 <Arnia> shapr: I'd like Coq more if it had a nice language like Isar
15:32:41 <shapr> It's pretty obvious that compiler optimizations are isomorphic to automated proofing.
15:32:54 <shapr> Er, compiler optimizations are isomorphic to proof search strategies...
15:33:17 <shapr> Arnia: I don't know Isar.
15:33:26 <Cale> Arnia: A valid proof is one which everyone in the room could make rigourous.
15:33:55 <Cale> (and people are allowed to ask questions)
15:33:58 <SamB> Cale: that means the validity of a proof is determined by the number of freshman in the room?
15:33:59 <Arnia> Cale: yes, and frequently presentation will elide the more trivial results
15:34:04 <Cale> SamB: yes
15:34:05 <Cale> :)
15:34:17 <Arnia> Cale: but that isn't the same as saying they aren't there
15:34:29 <Arnia> ('there' in the most general deitic sense possible)
15:34:37 <Cale> Yeah, I'm just saying that there's very little point in stating the obvious over and over again.
15:34:45 <bluestorm> hum
15:34:51 <Cale> People can deal with these kinds of details on their own.
15:35:07 <Arnia> Cale: so you're complaining about the presentation more than the actual formal nature?
15:35:17 <Cale> right
15:35:19 <bluestorm> couldn't a good proof assistant software infer those trivial results, the same as you do ?
15:35:26 <bluestorm> i mean
15:35:34 <Cale> It's actually more costly to communicate these things than to just let everyone do them for themselves.
15:35:46 <Arnia> bluestorm: well, maybe not necessarily infer but definitely check
15:35:50 <Cale> bluestorm: If it was smart enough, sure :)
15:35:55 <bluestorm> if you think they're trivial enough for everyone to implicitly understand, why couldn't a computer do that ?
15:35:56 <Cale> But not today :)
15:35:59 <bluestorm> hm
15:36:37 <SamB> maybe you should be able to write rules for it
15:37:11 <SamB> so that if you have one particular kind of obvious fact, you can tell the proof assistant how to prove them
15:37:12 <bluestorm> i don't know the proof assistant world yet, but from my novice point of view, i would say that coq tactics are a step in that direction
15:38:58 <Cale> Arnia: I generally insist that there be some kind of underlying formalism, but apart from some initial discussion, we shouldn't have to keep going back to it constantly in discussing mathematics. It should be something which we can do if we feel unsure about some point, but not necessary most of the time.
15:39:31 <Arnia> I find the formalism the most interesting thing about Maths though ;)
15:39:56 <Arnia> And I like the relevant logic pinned down
15:40:08 <Cale> Like, if you're actually studying mathematical logic, that's one thing.
15:40:30 <Arnia> Proof assistants necessarily need to work at a very low level, but high level abstractions as possible
15:40:45 <Arnia> Most work has been on making the assistants work at all though
15:41:21 <bluestorm> hm
15:41:46 <bluestorm> another thing that may turn interesting is the possible assymetry between the "writing" and the "reading" part
15:42:29 <bluestorm> you can use a tedious formal system to write the proof, and then have it nicely outputted, with the lemma proofs skipped, for example
15:42:45 <bluestorm> those kind of things may be easier to do in a computing environnement
15:43:12 <bluestorm> (of course with hand-written proofs you can already provide "proof sketch" and the like)
15:43:48 <Cale> I'd settle for using graduate students as proof assistants :) It would be nice if there was a place for papers to go, and then the bigger gaps filled in with calculations later by graduate students (with a hyperlinked reference).
15:43:54 <Runaro^BRS> Thanks for the help on monads. The definition is clear now.
15:44:00 <Cale> Runaro^BRS: cool :)
15:44:29 <Runaro^BRS> The PlanetMath site was right on the money.
15:44:35 <Runaro^BRS> ...right on the monad.
15:45:27 <Cale> Yeah, it is quite a decent idea.
15:45:30 <bluestorm> Cale: you would be "Chief Mathware Architect", then ? :p
15:45:48 <Cale> Except that it's more of an encyclopedia than a place for research papers to go.
15:46:13 <monochrom> This channel has much hope. You guys do not replay the "conventional wisdom". You guys actually suggest solutions and directions. :)
15:47:34 <Cale> We also have to get out from under this stupid system in which papers get locked away from the rest of the internet.
15:47:46 <ricky_clarkson> Agreed!
15:48:01 <Cale> You can already find a lot of them online anyway, if you look on the professors' websites.
15:48:12 <Cale> But it's all disorganised for no really good reason.
15:49:26 <Arnia> I still fancy my idea of 'web-conferences'; not as a substitute for real conferences but as an additional form of forum which doesn't require expensive travel, etc. Something especially to promote research in less developed countries
15:49:33 <ricky_clarkson> I find papers hard to read, not having enough of a mathematical background, but I know I can overcome that.
15:49:41 <Cale> You just have to know hundreds of pages like http://www.math.ucsd.edu/~garsia/recentpapers/
15:49:43 <lambdabot> Title: Recent Papers
15:49:54 <ricky_clarkson> ..it's just hard to know which papers are worth deciphering.
15:50:16 <monochrom> I think the conferences are scholars' way of going to vacation with public money.
15:50:16 <Cale> ricky_clarkson: yeah, and with the current way papers are written, that can be quite hard
15:50:42 <bluestorm> hm
15:50:42 <Cale> I get the impression that journals have put a lot of pressure on people to keep things short.
15:51:02 <Cale> So lots of context and supporting material just gets dropped on the floor.
15:51:17 <bluestorm> doesn't most scientific journals impose some copyright restriction ?
15:51:18 <Cale> Unless you have lots of time to sort out the big picture, it's pretty hard.
15:51:39 <ricky_clarkson> RFCs manage to be reasonably short but well-written.
15:51:39 <Arnia> The idea of a web-conference would be a free form discussion system with the ability to annotate the submitted papers and share these annotations
15:51:46 <bluestorm> the kind of "you can only upload this paper on your ugly HTML page"
15:52:09 <monochrom> They don't require "ugly".
15:52:25 <Arnia> Sort of like shapr's idea with Fermat's Last Theorem
15:52:32 <Cale> They don't like you submitting the same paper to other journals though.
15:53:24 <shapr> Arnia: Fermat's Last Margin?
15:53:33 <hpaste>  fxr pasted "happs JSON usage example" at http://hpaste.org/2288
15:53:35 <SamB> how about, uh, parsing the ACM portal and so on and finding the papers elsewhere?
15:53:49 <fxr> I wonder if there is an easier way
15:53:52 <Arnia> shapr: sorry, yes. Low blood sugar
15:53:54 <shapr> Arnia: Speaking of which, I've been hacking on it, porting it to HAppS, there should be an actual alpha release this weekend!
15:53:55 <fxr> any ideas?
15:54:04 <Arnia> shapr: whee :)
15:54:21 <Runaro^BRS> Now... I don't understand the Wikipedia article on monads at all.
15:54:46 <Runaro^BRS> "a monad is an endofunctor"
15:54:51 <shapr> fxr: I wonder if the syb-with-class xml deriving in the new HAppS repos could be extended to JSON?
15:55:17 <conal> fxr: pretty.  how about auto-generating the instances via Derive or something?
15:55:23 <Runaro^BRS> okay, Maybe is a functor from which category to itself?
15:55:35 <dolio> The category of Haskell types.
15:55:58 <fxr> [01:53] <shapr> fxr: I wonder if the syb-with-class xml deriving in the new HAppS repos could be extended to JSON?
15:55:58 <Runaro^BRS> ah
15:55:58 <fxr> [01:53] <conal> fxr: pretty.  how about auto-generating the instances via Derive or something?
15:56:01 <fxr> ops
15:56:09 <fxr> I'm sorry
15:56:12 <conal> :)
15:57:29 <fxr> conal: could you please give me an example?
15:58:26 <conal> fxr: sorry.  i haven't used such a tool.  just seen it mentioned.  others here probably have concrete info.
15:58:38 <fxr> conal: oh thanks by the way
15:59:21 <conal> fxr: np.  try http://www-users.cs.york.ac.uk/~ndm/derive/.  there's another system too, i think.
15:59:23 <lambdabot> Title: Neil Mitchell - Derive
16:00:03 <conal> fxr: that page mentions DrIFT.  and sorear, who's often on #haskell
16:03:10 <fxr> conal: oh I saw it before, thanks I'll check it out
16:04:50 <SamB> fxr: if you run into any suspicious behaviour in Derive, tell me. I seem to have been drafted as writer-of-tests...
16:05:39 <fxr> SamB: thank you :) I'm thinking about shapr's question now
16:11:02 <hpaste>  Saizan annotated "(no title)" with "for flux" at http://hpaste.org/2287#a1
16:14:13 <Saizan> i wonder why the instance is Error e => Monad (Either e), the Error class is not used at all in the instance, just to reduce the context on functions that use it?
16:14:36 <Saizan> fuxxx: actually, that paste is for you ^^
16:18:24 <glguy> Saizan: for a reasonable monad for either you'd need MonadLib
16:19:38 <Saizan> MonadLib?
16:19:56 <glguy> Saizan: kind of a super mtl
16:20:04 <glguy> http://darcs.haskell.org/packages/monadLib/
16:20:06 <lambdabot> Title: Index of /packages/monadLib
16:21:00 <glguy> runException :: Exception i a -> Either i a 	-- Defined in Monads
16:21:40 <glguy> where Exception is an instance of ExceptionM, which defines raise :: i -> m a
16:22:56 <Saizan> very nice, is it actually proposed as a replacement for mtl?
16:23:20 <glguy> its as old as the mtl
16:23:29 <glguy> I don't think it will ever really "replace" it
16:23:40 <glguy> we use it at work over the mtl
16:23:47 <glguy> at least on the project I'm on
16:24:01 <glguy> it helps that the maintainer of MonadLib is on the project though :)
16:24:02 <SamB> Saizan: doesn't "fail" use the Error class?
16:26:26 <glguy> Saizan: MonadLib lets you specify strict or lazy behavior
16:26:36 <glguy> by picking Id vs Lift as the base monad
16:27:05 <glguy> the monads in the Monads namespace are transformers applied to Id
16:27:15 <glguy> (Lift is the lazy one)
16:27:17 <glguy> err
16:27:19 <glguy> strict one :)
16:28:33 <Saizan> SamB: ah, right, but fail doens't count
16:28:59 <SamB> Saizan: fail is exactly what the Error class is for...
16:29:53 <SamB> well, that and mzero
16:31:22 <Runaro^BRS> One more monad question.
16:32:18 <Runaro^BRS> If every monad in Haskell is an endofunctor on the category of Haskell types, and every monad is a triple of (fmap, return, join), what distinguishes one monad from another?
16:32:40 <puusorsa> they do different things?
16:32:58 <glguy> Runaro^BRS: the specific implementation of the triple
16:33:30 <glguy> fmap isn't a implemntation, its a set of them
16:34:17 <Runaro^BRS> @type fmap
16:34:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:34:39 <Runaro^BRS> ah, * -> *
16:34:44 <Runaro^BRS> so it's a type constructor, not a type.
16:43:01 <Runaro^BRS> @src (==)
16:43:01 <lambdabot> x == y = not (x /= y)
16:43:05 <Runaro^BRS> @src (/=)
16:43:05 <lambdabot> x /= y = not (x == y)
16:43:08 <Runaro^BRS> grr
16:43:19 <lament> what did you expect? :)
16:43:53 <Runaro^BRS> A rip in the space-time continuum that could destroy the universe.
16:51:34 <SamB> Runaro^BRS: those are just the default implementations
16:51:48 <SamB> each instance of the Eq class must implement at least one of the two...
16:59:52 <byorgey> @src until
16:59:52 <lambdabot> until p f x | p x       = x
16:59:52 <lambdabot>             | otherwise = until p f (f x)
17:10:14 <byorgey> @src product
17:10:15 <lambdabot> product = foldl (*) 1
17:10:28 <byorgey> does product really use foldl and not foldl'?
17:10:59 <shachaf> byorgey: I think that gets optimized with -O2.
17:11:22 <byorgey> shachaf: really?  interesting.
17:11:27 <shachaf> > product [1..10000]
17:11:29 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
17:11:33 <shachaf> Try that in ghci?
17:11:58 <byorgey> works fine in ghci on my machine
17:12:08 <shachaf> Hmm.
17:12:12 <puusorsa> same here
17:12:16 <dibblego> same
17:12:26 <byorgey> the question isn't whether it works, but whether it uses O(n) or O(1) space.
17:12:35 <dibblego> did yours splode because it was so huge?
17:12:43 <dibblego> O(1) of course!
17:12:51 <dibblego> ?src product
17:12:52 <lambdabot> product = foldl (*) 1
17:13:20 <puusorsa> at least it's fast
17:13:35 <byorgey> theoretically, foldl (*) 1 builds up a huge thunk of the entire product before evaluating, so I was wondering if it gets optimized or not
17:13:59 <dibblego> byorgey, it does in this case for reasons that were once explained to me, but I forget
17:14:03 <byorgey> puusorsa: yes, but I'd rather be sure it's fast AND uses very little memory =)
17:14:40 <puusorsa> compile and run with something that displays the memory usage?
17:14:46 <shachaf> > sum [1..1000000]
17:14:48 <lambdabot>  500000500000
17:14:57 <shachaf> Gives a stack overflow in ghci.
17:15:24 <puusorsa> weird
17:15:27 <dibblego> dons, why does foldl (+) run in constant stack?
17:15:32 <monjaro> What is the best way to sleep for a certain amount of time in haskell?  I can't seem to find what I'm looking for with hoogle
17:15:37 <puusorsa> i thought ghci can calculate anything
17:16:02 <LoganCapaldo> @hoogle threadDelay
17:16:02 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
17:16:06 <dibblego> shachaf, run ghci with -02
17:16:29 <shachaf> dibblego: I don't think ghci works with -O2.
17:16:42 <dibblego> I wish I could remember why it does that
17:16:44 <LoganCapaldo> lambdabot is the ultimate concurrent development platform
17:16:46 <monjaro> LoganCapaldo: Thanks for the help
17:17:02 <byorgey> dibblego: remember why what does what?
17:17:06 <puusorsa> -O2 doesnt help, still stack overflow
17:17:19 <dibblego> byorgey, why foldl (+) runs in constant stack; something to do with types
17:17:29 <byorgey> dibblego: but it doesn't seem to.
17:17:33 <Excedrin> just use Data.List.fold' ?
17:17:45 <dibblego> byorgey, why not? it does for me
17:17:52 <dibblego> byorgey, and lambdabot
17:18:03 <Excedrin> lambdabot does use -O2
17:18:25 <lambdabot> I am beyond mere -O2.
17:18:29 <Excedrin> yea, see?
17:18:35 <byorgey> dibblego: hm, you're right, when I actually put main = print (sum [1..1000000]) in a file and compiled with -O2, it works fine
17:18:51 <shachaf> Hmm. Even compiling with -O2 it doesn't work.
17:19:19 <shachaf> That's odd.
17:19:29 <shachaf> foldl (+) 0 gives a stack overflow, sum doesn't.
17:19:33 <shachaf> @src sum
17:19:33 <lambdabot> sum = foldl (+) 0
17:19:37 <puusorsa> odd
17:19:47 <wli> Try foldl'
17:19:53 <puusorsa> sum gives stack overflow, Data.List.foldl' (+)  0 [1..1000000]
17:19:54 <puusorsa> 500000500000
17:20:04 <shachaf> With -O2.
17:20:07 <Excedrin> > foldl (+) 0 [1..1000000]
17:20:09 <lambdabot>  500000500000
17:20:15 <puusorsa> why doesnt sum use foldl' ?
17:20:21 <shachaf> Without -O2, sum gives a stack overflow.
17:20:26 <byorgey> puusorsa: that was my original question =)
17:20:32 <Pseudonym> puusorsa: Because the language standard says what sum should be.
17:20:33 <puusorsa> hooray!
17:20:58 <Pseudonym> There are rare occasions, with some num types, where foldl' wouldn't make sense.
17:21:00 <SamB> puusorsa: blame SPJ
17:21:11 <SamB> I think he chaired the commitee
17:21:20 <byorgey> Pseudonym: ok, I'll buy that.
17:21:27 <Pseudonym> You have to understand that the Prelude was standardised at a time when the question of whether or not seq and $! should be in the standard was controversial.
17:21:30 <puusorsa> Pseudonym, thanks. that second part is a answer, 'because the standard says so' isnt
17:21:41 <dolio> GHC doesn't use the sortBy from the language standard.
17:21:44 <Pseudonym> Actually, "the standard says so" is the only reasonable answer.
17:21:50 <Pseudonym> It just raises another question.
17:22:01 <SamB> puusorsa: you are expecting entirely too much from the standard if you are expecting a reasonable rationale!
17:22:06 <Pseudonym> dolio: It has to use one that's equivalent.
17:22:07 <puusorsa> thats what i mean, sorry for being a bit vague
17:22:19 <puusorsa> the standard says so -> why does it say so?
17:22:30 <Pseudonym> Using a more efficient algorithm is okay, but changing laziness behaviour is not.
17:22:37 <SamB> um. we've been asking ourselves those questions for a while now ;-)
17:23:00 <dolio> True.
17:23:00 <Pseudonym> I think that changing the definition of sum would be a perfectly okay thing to do for Haskell'.
17:23:36 <byorgey> so the take-away lesson is that if I want to be sure about strictness/memory usage of sum and product, I should define things like sum' = foldl' (+) 0.
17:24:23 <Excedrin> is there ever a time when you don't want sum to be as strict as possible? (which weird num types?)
17:24:35 <wli> If you're truly concerned about stack overflows, divide and conquer summation might help.
17:25:01 <shachaf> Excedrin: Sometimes you want it to be foldr.
17:25:14 <Excedrin> when/why would you want that?
17:25:22 <ChilliX> shachaf: -O2 has no impact on ghci
17:25:42 <shachaf> Excedrin: With data Nat = Z | S Nat, I think, foldr (+) Z (repeat (S Z)) will be equivalent to (fix S).
17:25:42 <ChilliX> when ghc compiles for bytecode, it only ever does light optimisations
17:25:48 <Pseudonym> Excedrin: It would have to be a num type which uses laziness somehow.
17:25:52 <shachaf> ChilliX: I know.
17:26:00 <shachaf> ChilliX: dibblego suggested it.
17:26:01 <Pseudonym> The thing is, very few, if any, such types exist.
17:26:03 <wli> zipWith' _ [] xs = xs ; zipWith' _ xs [] = xs ; zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys ; splitParity [] = ([], []) ; splitParity [x] = ([x], []) ; splitParity (x:y:zs) = let (xs, ys) = splitParity zs in (x:xs, y:ys) ; divConqSum []= 0 ; divConqSum [x] = x ; divConqSum xs@(_:_:_) = divConqSum $ uncurry (zipWith' (*)) $ splitParity xs
17:26:06 <Pseudonym> But that's not the point.
17:26:08 <ChilliX> ok, only because you guys discussed that above
17:26:11 <Pseudonym> It changes the behaviour of such types.
17:26:29 <Pseudonym> So you can't fix that without modifying the standard.
17:26:44 <wli> ergh, +
17:27:55 <sgillespie> hello
17:28:13 <sgillespie> I need a lesson in pattern matching
17:28:20 <sgillespie> lets say I have
17:28:24 <byorgey> wli: interesting
17:28:35 <byorgey> hi sgillespie
17:28:36 <SamB> Pseudonym: so are they fixing it for haskell'?
17:28:38 <sgillespie> MyData = Constr String Int
17:28:49 <Pseudonym> SamB: No idea.  Ask someone on the committee.
17:28:56 <byorgey> sgillespie: ok.
17:29:02 <Pseudonym> sgillespie: That's a data declaration, right?
17:29:04 <SamB> @where haskell;
17:29:04 <lambdabot> I know nothing about haskell;.
17:29:05 <SamB> @where haskell'
17:29:06 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
17:29:09 <sgillespie> sorry
17:29:17 <Pseudonym> That's OK, just checking.
17:29:22 <Pseudonym> Don't apologise, just keep talking.
17:29:23 <sgillespie> I meant Data = Constr String Int
17:29:23 <Pseudonym> :-)
17:29:43 <sgillespie> so I do... a = Constr String Int
17:29:59 <sgillespie> I want to bind x and y to the String & Int
17:30:04 <sgillespie> something like
17:30:14 <sgillespie> x y = a
17:30:17 <mauke> let Constr x y = a in ...
17:30:18 <sgillespie> in pseudocode
17:30:32 <sgillespie> let me try...
17:30:49 <Pseudonym> There are basically four places where you can do pattern matching.
17:31:06 <Pseudonym> 1. In the left hand side of an equals binding (toplevel, let or where expression).
17:31:12 <Pseudonym> 2. Function arguments.
17:31:17 <puusorsa> 032814  lambdabot> I know nothing about haskell;. <3
17:31:17 <Pseudonym> 3. Lambda expressions.
17:31:21 <Pseudonym> 4. Case expressions.
17:31:43 <Pseudonym> So this is a let expression.
17:32:22 <SamB> ChilliX, dons: are they fixing the strictnes of sum for Haskell'?
17:32:28 <sgillespie> is it possible to do Data declarations in ghci?
17:32:36 <mauke> sgillespie: no
17:32:43 <mauke> you need to put them in a file
17:32:44 <sgillespie> aw shucks
17:33:01 <SamB> JohnMeacham: or you ?
17:33:17 <Pseudonym> sgillespie: It helps to use the :edit command when fiddling with this, though.
17:34:00 <SamB> hmm. I think I found the membership list for the HSU
17:34:13 <SamB> http://hackage.haskell.org/trac/haskell-prime/wiki/FocusGroups#a3rdunnamedsubgroup
17:34:17 <lambdabot> Title: FocusGroups - Haskell Prime - Trac, http://tinyurl.com/24db4k
17:35:23 <sgillespie> sounds good, i think i have it
17:36:58 <SamB> it's kind of odd that we have the lead developer for the principle implementation of Perl 6 on the Haskell' committee...
17:37:19 <mauke> only good can come of it
17:37:31 <SamB> I merely said that it was kind of odd ;-)
17:37:35 <OceanSpray> hi everybody!
17:37:35 <SamB> not that it was somehow bad
17:37:40 <Mr_Awesome> hi!
17:38:31 <ChilliX> SamB: not sure, haven't kept up to date with library development
17:41:47 <shapr> SHAMAZ!
17:42:19 <dcoutts> It's... shapr! Huzza!
17:44:09 <shapr> yay!
17:44:12 <shapr> hiya dcoutts, how's code?
17:44:14 <byorgey> hmm... shapr appears to be shouting in Arabic or something.
17:44:26 <shapr> Nah, I was just spoonerizing SHAZAM!
17:44:31 <byorgey> =)
17:44:44 <shapr> I really want TAGS files that work across multiple projects :-(
17:44:56 <dcoutts> shapr: s'ver nice thanks :-)
17:45:11 <dcoutts> shapr: I'm refactoring cabal code atm
17:45:15 <shapr> Cool
17:45:28 <shapr> I had a cabal question recently, wish I could remember it...
17:45:36 <dcoutts> the Program and ProgramConfiguration abstractions, I'm rewriting those
17:45:55 <ChilliX> Maybe the Haskell answer to "How's code?" should be an emphatic "Beautiful!"
17:45:56 <dcoutts> and since a lot of what Cabal does is configure and run programs that has quite a few knck-on changes
17:46:31 <dcoutts> ChilliX: hmm, I'm not sure in the case of Cabal I could say that with a straight face ;-)
17:46:33 <Pseudonym> "Pure!"
17:46:36 <Pseudonym> "Elegant!"
17:46:38 <Pseudonym> "Bug-free!"
17:46:51 <dcoutts> nope, none of those apply either :-)
17:47:32 <OceanSpray> so...
17:47:34 <dcoutts> perhaps, "good for a refactoring case study" would be kindest
17:47:38 <ChilliX> dcoutts: hehehe
17:47:43 <Pseudonym> :-)
17:47:43 <OceanSpray> sjanssen, you still here?
17:48:18 <ChilliX> dcoutts: maybe the answer signals aspiration, rather than current fact
17:48:51 <dcoutts> ChilliX: yes, it could and should be beatuful, using all we know about structuring complex real world programs
17:48:55 <dcoutts> shapr: well if you remember the question do ask
17:48:59 <SamB> ChilliX: english lacks the means to say that
17:49:02 <SamB> I think
17:49:20 <byorgey> OceanSpray: do you have a general question, or something specific for sjanssen?
17:49:27 <sjanssen> OceanSpray: yes, I'm around
17:49:29 <OceanSpray> specific
17:49:58 <OceanSpray> how do I make it so that :: LispVal r -> IO String doesn't care what r is?
17:50:09 <shapr> Gah, I can't remember how Java classpaths work.
17:50:26 <byorgey> shapr: poorly
17:50:31 <dcoutts> shapr: I usually find that to a first aproximatin they don't work
17:50:45 <shapr> Yeah, I'm having that problem right now.
17:50:57 <sjanssen> OceanSpray: you probably need to introduce a type class that can unwrap an 'r'
17:50:59 <Cale> OceanSpray: by not using any values of type r in the definition of the function
17:51:16 <OceanSpray> so, just showVal :: LispVal -> IO String ?
17:51:21 <dcoutts> shapr: the main thing that always trips me up is that while an empty class path gives you a default, setting any classpath overrides the default so it then cannot find some standard libs
17:51:33 <ricky_clarkson> shapr: They're a list of top-level places.  If you have something in package x.y, and directory blah/x/y/ then your classpath needs to include blah.
17:51:45 <Cale> OceanSpray: well, if LispVal takes a type parameter, you have to give it one, even if just a variable like above
17:51:59 <shapr> ricky_clarkson: But I don't need to specify specific jar files, right?
17:52:13 <byorgey> OceanSpray: or maybe something like showVal :: (Show r) => LispVal r -> IO String?
17:52:13 <ricky_clarkson> shapr: Yes, you do.  (that might have changed VERY recently)
17:52:22 <dcoutts> shapr: and it doesn't look inside .jar files unless you list the .jar file in the classpath, it's not enough to specifiy a dir in which the jar file lives.
17:52:25 <Cale> showVal :: LispVal r -> IO String -- this function won't be able to observe any values of type r within the structure.
17:52:30 * shapr grumbles
17:52:37 <Cale> You might also have a new class:
17:52:48 <Cale> class ShowVal a where
17:52:53 <Cale>    showVal :: a -> IO String
17:52:55 <shapr> I remember fighting with classpaths for years. I finally wrote a Python program to add every jar file in turn in my .zshrc
17:53:11 <Cale> instance (ShowVal r) => ShowVal (LispVal r) where
17:53:19 <Cale>    showVal = ...
17:53:21 <shapr> I also wrote a Python program to search all jar files for a particular class. What a pain.
17:53:44 <ricky_clarkson> shapr: Sounds like a shell script one-liner.
17:53:47 <Cale> then write an instance of ShowVal for the particular types r which you need.
17:54:01 <OceanSpray> too much work.
17:54:05 <koala_man> shapr: export CLASSPATH="$CLASSPATH:`find ~ -name '*.jar' | tr '\n' :`"
17:54:15 <shapr> koala_man: Thanks
17:54:20 <Cale> OceanSpray: what does the type r in this case represent?
17:54:27 <ricky_clarkson> Actually use of CLASSPATH rather than -classpath is the biggest cause of problems.
17:54:28 <OceanSpray> either an IORef or Id
17:54:43 <Cale> and if it's an IORef, what needs to be done?
17:54:56 <Cale> er
17:54:59 <Cale> hmm
17:55:08 <Cale> Can I see the data declaration?
17:55:11 <OceanSpray> sure
17:55:13 <OceanSpray> hold on
17:55:37 <OceanSpray> hpaste, ?
17:55:40 <OceanSpray> hpaste, url?
17:55:41 <hpaste> Haskell paste bin: http://hpaste.org/
17:56:04 <ihope> Do you think there's a nice way of representing Haskell values as files?
17:56:06 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/2289
17:56:40 <Cale> ah, okay
17:57:00 <OceanSpray> unfinished
17:57:16 <Cale> so what you really need is...
17:57:19 <Cale> class Extract a where
17:57:40 <dmwit> ihope: What do you mean?
17:57:41 <Cale>    extract :: a t -> IO t
17:58:01 <Cale> So that you can generalise extracting from an IORef and extracting from Id
17:58:11 <OceanSpray> how about
17:58:31 <OceanSpray> no wait
17:58:32 <OceanSpray> nvm
17:58:32 <ihope> dmwit: I've been pondering a "Haskell-like" operating system sort of thing, sort of like a giant Haskell interpreter/interactive compiler.
17:58:33 <Cale> instance Extract IORef where
17:58:38 <Cale>    extract = readIORef
17:58:45 <Cale> instance Extract Id where
17:58:51 <ihope> One that's exactly like GHCi, perhaps :-)
17:58:54 <Cale>    extract (Id x) = return x
17:59:07 <dmwit> ihope: zfs, the Zipper File System, may be interesting to you.
17:59:18 <ihope> Sounds very interesting.
17:59:31 <dmwit> http://okmij.org/ftp/Computation/Continuations.html#zipper-fs
17:59:32 <lambdabot> Title: Continuations and delimited control
17:59:35 <SamB> ihope: you could just replace init with GHCi
17:59:38 * shapr kicks java
17:59:39 <SamB> or something
17:59:39 <Cale> OceanSpray: does that make sense?
17:59:51 <OceanSpray> not really
18:00:09 <OceanSpray> what does class and instance do?
18:00:23 <sjanssen> OceanSpray: http://hpaste.org/2289#a1
18:00:57 <dmwit> OceanSpray: Do you know any other languages?  Which ones?
18:01:07 <ihope> SamB: and then make GHCi dump its internal representations of things into files?
18:01:08 <Cale> Oh, hehe, given your code, I'd sort of assumed that you'd know. :)  The class introduces a new typeclass. You can think of a typeclass as a predicate on types where if the predicate is true, some interface of functionality is present.
18:01:14 <dmwit> class declares a set of types that have a uniform interface.
18:01:17 <Cale> show is an example
18:01:18 <OceanSpray> Scheme, C/C++, Java
18:01:26 <Cale> class Show a where
18:01:30 <Cale>    show :: a -> String
18:01:38 <Cale> (to oversimplify a bit)
18:01:42 <dmwit> instance declares that a particular type is in the set, and "proves" it by giving function definitions that satisfy the interface.
18:01:45 <Cale> instance Show Integer where
18:01:58 <Cale>    show n = ... code to turn an integer into a string ...
18:02:02 <OceanSpray> ah
18:02:09 <OceanSpray> that's simple enough
18:03:11 <ihope> ZFS looks like exactly what I had in mind, really.
18:03:33 <sjanssen> this vim/hpaste integration is really really handy
18:03:34 <Cale> OceanSpray: In this case, when you're writing showVal, you know that certain things are going to be contained in either IORefs or in Id, but you want the code to work with both cases.
18:03:57 <Cale> OceanSpray: So either you could write a class for showVal
18:04:01 <OceanSpray> and here I was trying to just pattern-match against those two
18:04:15 <Cale> Or you could just write a class for extracting values from either one of those things.
18:04:43 <Cale> class Extract r where
18:04:51 <Cale>    extract :: r a -> IO a
18:05:02 <Cale> instance Extract IORef where
18:05:11 <Cale>    extract ref = readIORef ref
18:05:16 <Cale> instance Extract Id where
18:05:24 <Cale>    extract (Id x) = return x
18:05:35 <OceanSpray> what does return do, again?
18:05:54 <Cale> Just builds an IO action that does nothing but return the given value
18:06:03 <OceanSpray> specifically, IO ?
18:06:11 <Excedrin> ihope: "looks" in what sense?
18:06:11 <Cale> Well, in any monad
18:06:18 <OceanSpray> oh ok
18:06:23 <Cale> But in this case, the monad is IO
18:06:27 <ihope> Excedrin: the description looks promising.
18:06:51 <Excedrin> oh, I like it, I wasn't sure if you meant code/layout on disk/user tools etc
18:06:53 <OceanSpray> so return just magically knows the type declaration of the function it's in?
18:07:06 <Cale> It's another typeclass function :)
18:07:13 <Cale> It's in the Monad class
18:07:19 <Cale> and has the type
18:07:21 <puusorsa> monads are magic
18:07:26 <Cale> (Monad m) => a -> m a
18:07:36 <Cale> So each monad definition includes a definition for return
18:07:42 <OceanSpray> oh
18:08:29 <ihope> Classes are a little bit silly.
18:08:36 <ihope> But only a little bit.
18:09:18 <ihope> Especially when existential qualification of types comes into play...
18:09:18 <SamB> ihope: you mean because we pun off OO terminology?
18:09:55 <ihope> I mean much of the semantics can be duplicated by having each function that needs a class member take it as an argument.
18:10:08 <SamB> oh, that
18:10:15 <Cale> They save you from passing around huge dictionaries of functions everywhere.
18:10:24 <ihope> Indeed.
18:10:25 <Cale> (of course, that's really what happens)
18:10:31 <ihope> Indeed.
18:10:34 <Cale> (in some implementations)
18:10:48 <ihope> Ind--I mean, um...
18:11:13 <LoganCapaldo> it would be *very* interesting if classes were to the explicit passing around of necessary functions as layout is to { } and semicolons
18:11:18 <LoganCapaldo> Or insane
18:11:34 <Cale> hehe
18:11:50 <OceanSpray> ???
18:11:51 <SamB> ihope: the other way to do it is just pass around the constrained variables
18:12:26 <ihope> Pass around the what?
18:12:35 <ihope> LoganCapaldo: interesting meaning... nice?
18:12:51 <SamB> well, I mean, pass in the values of the constrained variables
18:13:29 <LoganCapaldo> ihope, well yes, since you could have ad hoc classes if necessary without losing all the niceness of having type classes
18:13:52 * ihope nods
18:14:13 <ihope> "Could not find module `System.Posix'"
18:14:14 <ihope> No fair!
18:14:41 <LoganCapaldo> (and I think I mean ad hoc instances of classes, you can of course already have ad hoc classes)
18:15:18 <hpaste>  OceanSpray annotated "(no title)" with "(no title)" at http://hpaste.org/2289#a3
18:15:20 <ihope> Now, what's (..) mean in an import declaration?
18:15:28 <OceanSpray> this should be correct...
18:15:53 <OceanSpray> wait, no it is
18:15:56 <OceanSpray> n't
18:16:25 <OceanSpray> LispData.hs:36:8: Not in scope: data constructor `Id'
18:16:30 <OceanSpray> what the hell?
18:16:37 <Cale> newType
18:16:39 <ihope> @index Id
18:16:39 <lambdabot> bzzt
18:16:40 <Cale> newtype
18:16:46 <OceanSpray> oh whoops
18:18:20 <OceanSpray> oh goddamn
18:18:30 <OceanSpray> now LispErr has to be parametric too
18:19:00 <Cale> but at least you have a solid way to proceed
18:19:54 <Cale> showVals = mapM showVal
18:20:08 <OceanSpray> whoah, that works?
18:20:17 <OceanSpray> what does mapM do?
18:20:25 <LoganCapaldo> @src mapM
18:20:25 <lambdabot> mapM f as = sequence (map f as)
18:20:38 <ihope> INTEGRAL_TYPE(Fd,tyConFd,"Fd",CInt)
18:20:41 <Cale> where
18:20:42 <ihope> What a scary definition...
18:20:48 <ihope> Er, declaration.
18:20:49 <Cale> sequence [] = return []
18:21:07 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
18:21:20 <ihope> What does it mean?
18:21:59 <LoganCapaldo> I would guess it means Fd is an integral type, implement in terms of a C int
18:22:31 <LoganCapaldo> wild guess though :)
18:22:36 <Cale> OceanSpray: so mapM is essentially a foreach loop
18:22:47 <ihope> Hmm.
18:22:51 <Cale> OceanSpray: there's also forM, it takes the list parameter first
18:23:02 <ihope> @type (mapM, forM)
18:23:04 <lambdabot> forall a (m :: * -> *) b a1 (m1 :: * -> *) b1. (Monad m, Monad m1) => ((a -> m b) -> [a] -> m [b], [a1] -> (a1 -> m1 b1) -> m1 [b1])
18:23:16 <OceanSpray> how would I shorten getVals?
18:23:22 <OceanSpray> mapM unwrap?
18:23:44 <Cale> yeah, if that works
18:24:03 <Cale> Have you got an instance of unwrap for LispObj w ?
18:24:37 <Cale> what is a LispObj?
18:24:53 <OceanSpray> forget that
18:25:00 <OceanSpray> it was just an IORef LispVal
18:25:45 * LoganCapaldo renames IORef to IOVar
18:28:00 <pgavin> @seen dcoutts
18:28:00 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 35m 38s ago.
18:28:23 <pgavin> dcoutts, are you around?
18:28:27 <dcoutts> @yarr!
18:28:27 <lambdabot> Arrr!
18:28:30 <pgavin> lol
18:28:42 <pgavin> am I not allowed to use mtl in cabal?
18:28:47 <dcoutts> sorry :-(
18:28:50 <pgavin> doh!
18:28:52 <OceanSpray> I got type LispErrT r = ErrorT (LispErr r) IO
18:28:53 <dcoutts> dependencies
18:28:58 <pgavin> right
18:29:03 <dcoutts> pgavin: otherwise how would we build mtl :-)
18:29:06 <pgavin> lol
18:29:09 <pgavin> right
18:29:16 <OceanSpray> but I need to instance Error LispErr <wtf do I put here> where
18:29:20 <dcoutts> pgavin: yeah, it's a real pain
18:29:22 <OceanSpray> ???
18:29:36 <pgavin> dcoutts, well I think I got my algorithm about done
18:29:38 <Cale> instance Error (LispErr r) where
18:29:42 <dcoutts> pgavin: but actually there's another reason we can't use mtl, it itsn't H98
18:29:42 <pgavin> at least a basic one
18:29:48 <pgavin> ahh
18:29:50 <pgavin> kk
18:29:56 <OceanSpray> oh lol it's Plareplane
18:29:56 <pgavin> well, I'll rewrite it then
18:30:03 <dcoutts> pgavin: but we can certainly use mtl ideas, but we'd have to do it less generically to keep it H98
18:30:04 <Plareplane> :(
18:30:04 <pgavin> shouldn't be too too bad
18:30:06 <OceanSpray> wtf are you doing HERE?
18:30:08 <dcoutts> pgavin: ok
18:30:20 <Plareplane> i've been idling in #haskell and #math for a long while now
18:30:27 <OceanSpray> oh
18:30:41 <OceanSpray> small internet.
18:30:50 <Cale> noMsg = Unknown ""
18:31:03 <Cale> strMsg s = Unknown s
18:31:06 <Cale> probably :)
18:31:10 <pgavin> dcoutts: isn't StateT doable in H98?  I mean, could I just copy the source into a Compat module?
18:31:22 <OceanSpray> wait, I can just leave the (LispErr r) as (LispErr r) ?
18:31:29 <dcoutts> pgavin: yes, we do intend to introduce some monads and I think we'll use an mtl style of adding classes that extend Monad with various specific operations, eg for logging, configuring & running progs etc.
18:31:30 <OceanSpray> no need to specify a wrapper?
18:31:41 <Cale> In your instance of Error, yeah
18:31:47 <pgavin> dcoutts: ok, well I'll do that then
18:32:00 <Cale> because you're not going to package up new LispVals in response to the methods of Error
18:32:05 <dcoutts> pgavin: we just can't do it in quite as generic a way as in mtl since we cannot use multi-parameter type classes with functional dependencies
18:32:05 <mudge> what's new in the functional world?
18:32:22 <hpaste>  palomer pasted "AndAlso done right" at http://hpaste.org/2290
18:32:53 <pgavin> dcoutts: ok, then I'll just manually do what StateT does, but specifically for my monad
18:33:02 <dcoutts> pgavin: aye, that's fine.
18:33:07 <mudge> anyone have any suggestions on the best way to learn haskell?
18:33:13 <pgavin> gtg, bbl
18:33:50 <mudge> hi jedai
18:33:54 <hpaste>  palomer pasted "AndAlso done right, part 2" at http://hpaste.org/2291
18:33:56 <dcoutts> mudge: http://www.cs.nott.ac.uk/~gmh/book.html
18:33:57 <lambdabot> Title: Programming in Haskell
18:34:02 <Mr_Awesome> mudge: i liked the "gentle introduction to haskell"
18:34:23 <dcoutts> mudge: or if you want only online resources then there are several linked from haskell.org
18:34:27 <Mr_Awesome> though its not very in-depth
18:34:36 <mudge> thanks dcoutts,  I have that book,
18:35:05 <dcoutts> mudge: sounds like you're doing ok then :-)
18:35:19 <mudge> what about the book:
18:35:19 <mudge>  	
18:35:19 <mudge> 	
18:35:19 <mudge> The Haskell School of Expression: Learning Functional Programming through Multimedia
18:35:34 <mudge> yea, good to know I'm on the right track
18:35:51 <dons> how scary http://www.sdtimes.com/article/latestnews-20070815-04.html
18:35:54 <lambdabot> Title: SD Times - Java Becoming Solution for Safety-Critical Applications
18:35:54 <dcoutts> some people love the SOE book, some don't
18:36:00 <mudge> or the book:
18:36:00 <mudge>  	
18:36:00 <mudge> 	
18:36:00 <mudge> The Haskell School of Expression: Learning Functional Programming through Multimedia
18:36:05 <mudge>  	
18:36:05 <mudge> 	
18:36:05 <mudge> The Haskell School of Expression: Learning Functional Programming through Multimedia
18:36:12 <mudge> oops,  i didn't mean to do that
18:36:21 <dcoutts> mudge: careful with you cut'n'paste ;-)
18:36:28 <dcoutts> dons: I guess it's better than C
18:36:36 <mudge>  	
18:36:36 <mudge> 	
18:36:36 <mudge> The Haskell Road To Logic, Maths And Programming
18:36:46 <mudge> that book?  anyone checked out that one?
18:37:51 <mudge> yea, thanks dcoutts
18:41:26 <Korollary> dons: tough for Ada?
18:42:27 <ihope_> Mm. What package is Network.Socket in, and how do I get it with apt-get?
18:42:59 <OceanSpray> damn
18:43:00 <OceanSpray> LispData.hs:19:29:
18:43:00 <OceanSpray>     `LispEnv' is not applied to enough type arguments
18:43:14 <OceanSpray> | Environment LispEnv r
18:43:15 <sebell> ihope_: libghc6-network-dev
18:43:26 <ihope_> Thanks.
18:43:42 <OceanSpray> in the data LispData declaration
18:43:56 <OceanSpray> why doesn't it work?
18:44:10 <ihope_> Should that be Environment (LispEnv r)?
18:44:25 <OceanSpray> huh
18:45:14 <OceanSpray> oh yeah
18:45:16 <OceanSpray> lol
18:45:20 <OceanSpray> it compiles now
18:45:27 <OceanSpray> oookay...
18:45:40 <OceanSpray> I think LispData is done once and for all now.
18:46:55 <dons> Korollary: it explains why the entertainment systems on qantas planes crashes *every single time* i fly
18:47:37 <OceanSpray> Because of the revolutionary nature of our claim, not only to the world of science but to the world in general, Steorn issued a challenge to the scientific community in August 2006 to test our technology and report their findings. The process of validation that has resulted from this challenge is currently underway, with results expected by the end of 2007.
18:47:43 <OceanSpray> They'll get shot down.
18:47:44 <OceanSpray> Hard.
18:47:49 <OceanSpray> ...
18:47:54 <OceanSpray> whoops, wrong channel
18:49:39 <wli> Anybody taken a crack at projecteuler #133 yet?
18:56:13 <chessguy> @hoogle (a -> b -> c -> d) -> (b -> a -> c -> d)
18:56:14 <lambdabot> No matches, try a more general search
18:56:20 <chessguy> boo!
18:56:29 <Pseudonym> Bool!
18:56:45 <Binkley> @hoogle (a -> b -> c) -> (b -> a -> c)
18:56:45 <lambdabot> No matches, try a more general search
18:56:54 <chessguy> @type flip
18:56:56 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:57:00 <chessguy> ...
18:57:05 <Binkley> @hoogle (a -> b -> c) -> b -> a -> c
18:57:07 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
18:57:08 <Binkley> heh
18:57:12 <chessguy> well, that's dumb
18:57:20 <chessguy> @hoogle (a -> b -> c -> d) -> b -> a -> c -> d
18:57:21 <lambdabot> No matches, try a more general search
19:02:12 <chessguy> @src flip
19:02:12 <lambdabot> flip f x y = f y x
19:02:25 <chessguy> @type flip
19:02:27 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
19:03:19 <chessguy> @pl flip f x y z = f y x z
19:03:20 <lambdabot> flip = flip
19:03:26 <chessguy> ...
19:03:50 * chessguy nominates himself for moron of the year
19:04:12 <Korollary> too harsh
19:04:22 <Binkley> Yeah, just moron of the day ;-)
19:04:32 <Korollary> still too harsh
19:04:40 <Binkley> I was just joshing
19:05:11 <chessguy> i dunno, that's gotta net me at least a few weeks :)
19:05:37 <Korollary> it helps to learn to forgive yourself for small mistakes like this
19:05:41 <Binkley> "don't fuss because what's impossible for most people in the world is a bit tricky for you" :-)
19:06:01 <chessguy> thank you Dr. Laura
19:06:06 <Binkley> lol
19:06:10 <Binkley> I don't think Dr. Laura would say that
19:06:15 <Binkley> she'd probably just call you a moron
19:06:48 <chessguy> hehe
19:06:55 <Binkley> coming soon to a bookstore near you: "Ten Really Dumb Things Programmers Do to Mess Up Their Lives"
19:07:24 <chessguy> hmm, "impossible for most people in the world" seems a bit extreme
19:08:07 <Binkley> do most people understand higher-order functions?
19:08:33 <Pseudonym> More to the point: Would most people if they tried?
19:08:45 <Binkley> well, the answer is irrelevant because they don't try
19:08:54 <Binkley> anyway, Haskell is hard, I read a blog post that said so ;-)
19:08:56 <Pseudonym> Most people don't understand recursion, but most programmers get it after a month or sp./
19:08:58 <Pseudonym> so
19:09:26 <ricky_clarkson> Pseudonym: I have had great success explaining recursion and hofs to non-programmers.
19:09:35 <Pseudonym> There you go.
19:09:36 <ricky_clarkson> Though I wouldn't recommend either as pick-up lines.
19:10:06 <wli> heh
19:10:11 <Pseudonym> When you're married, as I am, you have no further need for pick-up lines, and hence can explain recursion and HOFs to your heart's content.
19:10:20 <Binkley> well, some married people, anyway
19:10:26 <ricky_clarkson> Pseudonym: Depends how happily.
19:10:28 <wli> The strangest pickup lines get uesd on me.
19:10:30 <Binkley> even happy ones
19:10:36 * ricky_clarkson refused a married woman recently.
19:10:49 <Pseudonym> True, there are also open relationships.
19:11:19 <Pseudonym> Which is cool if it floats your boat.
19:11:36 <Binkley> I guess I shouldn't talk about reading "Tackling the Awkward Squad" in bed to somebody (who wasn't a programmer)
19:11:37 <Binkley> but anyway
19:11:40 <Binkley> how about those local sports teams
19:11:56 <Pseudonym> My local sports teams are far superior to your local sports teams.
19:12:09 <Binkley> I beg to differ with that proposition, my good sir.
19:12:24 <Pseudonym> My local sports teams would clearly beat yours in the appropriate sporting contests.
19:12:43 <Binkley> I hazard a guess that my local sports teams would beat yours approximately 50 percent of the time
19:12:56 <ricky_clarkson> I disagree with both of you, and proffer a chair to you, albeit with great speed and airborne.
19:13:00 <wli> My home basketball team will get all kinds of touchdowns and home runs against your home basketball team.
19:13:05 <Binkley> lol
19:13:21 <chessguy> ahem. perhaps we should return to the topic at hand
19:13:26 <shapr> Haskell?
19:13:31 <chessguy> indeed
19:13:32 <wli> Project Euler?
19:13:38 <shapr> yeah!
19:13:44 <chessguy> @get-slap
19:13:44 <lambdabot> shapr!!
19:13:47 <Binkley> revolutionary scientific claims?
19:13:51 <chessguy> @yow
19:13:51 <lambdabot> YOU!!  Give me the CUTEST, PINKEST, most charming little VICTORIAN
19:13:51 <lambdabot> DOLLHOUSE you can find!!  An make it SNAPPY!!
19:14:04 <ricky_clarkson> Haskell is hard and that makes it not a good language.
19:14:10 <Binkley> yeah
19:14:10 <ricky_clarkson> (anyone else read that today?)
19:14:13 <Binkley> JavaScript is much better
19:14:15 <Binkley> yes, I saw that too
19:14:23 <chessguy> saw it where?
19:14:24 <Pseudonym> Where was this?
19:14:26 <wli> Thus far I've managed to cram more brute-forcing into less RAM with some cyclotomic polynomial crap for Project Euler #133
19:14:43 <Binkley> a comment here -- http://notes-on-haskell.blogspot.com/2007/08/haskell-more-than-just-hype.html
19:14:45 <lambdabot> Title: Notes on Haskell: Haskell: more than just hype?, http://tinyurl.com/2wuspy
19:14:51 <Binkley> "I think one of the biggest problems in Haskell, aside from it not being very easy (whats a monad?), is syntax. "
19:15:01 <ricky_clarkson> Binkley: That's not the one I meant.
19:15:05 <Pseudonym> Wadler's Law wins again!
19:15:05 <Binkley> oh?
19:15:15 <wli> What's Wadler's Law?
19:15:39 <Pseudonym> ?google wadler's laws of programming language design
19:15:41 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/
19:15:41 <lambdabot> Title: Philip Wadler's home page
19:15:45 <Pseudonym> Hmm.
19:15:52 <Korollary> as a vulgar minded immature person, I snicker at the claims that Haskell is hard. Heh heh. Hard. Heh heh.
19:16:09 <Pseudonym> Heh heh heh, you said vulga.
19:16:26 <ricky_clarkson> Binkley: http://unqualified-reservations.blogspot.com/2007/08/whats-wrong-with-cs-research.html
19:16:28 <lambdabot> Title: Unqualified Reservations: What's wrong with CS research, http://tinyurl.com/ypgj54
19:16:30 <njbartlett> Who let Beavis and Butthead ikn?
19:16:38 <Binkley> haha, just from the title I know this is going to be rich
19:16:44 <wli> Thus far it appears that I'm attempting to construct numbers so vast to do various sorts of brute-forcing with that I'm running out of RAM.
19:16:45 <Pseudonym> http://www.unixguide.net/freebsd/faq/16.19.shtml
19:16:46 <lambdabot> Title: Why should I care what color the bikeshed is?
19:16:51 <Pseudonym> Erm.
19:17:00 <Pseudonym> http://wadler.blogspot.com/2006/01/bikeshed-coloring.html
19:17:01 <Pseudonym> That's it.
19:17:01 <lambdabot> Title: Wadler's Blog: Bikeshed coloring
19:17:10 <Binkley> "There is no such thing as 'computer science'"
19:17:41 <ricky_clarkson> If you ignore the actual words he uses, and the way he uses them, he has some good points.
19:17:45 <chessguy> Binkley, thus said Abelman and Sussman
19:17:55 <Binkley> if you ignore everything he says, he has some good points
19:18:02 <Binkley> this guy reminds me too much of my ex-officemate
19:18:16 <chessguy> s/Abelman/Abelson/
19:18:34 <glen_quagmire> so monod is spacesuite full of nuclear waste?
19:18:47 <Binkley> "the horrific trainwreck that is PL research"
19:19:16 <wli> shapr: I've still not quite figured out a good criterion to determine whether a prime is a divisor of (10^(10^n)-1) `div` 9 for some n.
19:19:27 <Binkley> "strange, squiggly marks which for the average coder might as well be Sumerian cuneiform"
19:19:39 <Binkley> I'd almost think that qwe1234 learned to write without using 'stfu' as a comma
19:19:52 <glen_quagmire> i'm qwe1234 in reddit.com
19:20:24 <glen_quagmire> no, i'm linuxer
19:20:24 <Binkley> "I don't see why any language needs any non-ASCII notation."
19:20:42 <glen_quagmire> yah that was for R6R2 something
19:20:54 <ricky_clarkson> I disagree with that.
19:21:13 <ricky_clarkson> ASCII-based languages will be first against the wall when the revolution comes.
19:21:24 <glen_quagmire>  int <some chinese characters with mirroring character thrown in> = 0;
19:21:39 <Pseudonym> You mean IF the revolution comes.
19:21:42 <Binkley> currying is "bizarre obfuscation"
19:21:45 <Binkley> black is white! up is down!
19:21:51 <glen_quagmire> how would you define a variable in BNF ?
19:22:03 <Pseudonym> We have always been at war with Oceania.
19:22:05 <newsham> there are variables in BNF?
19:22:09 <glen_quagmire>  UTF16+ ?
19:22:09 <Binkley> "it's pretty easy to see why you don't need dynamic higher-order programming"
19:22:14 <ricky_clarkson> glen_quagmire: Don't define variables, point at them.
19:22:17 <glen_quagmire> varName := UTF16+
19:22:22 <wli> shapr: Thus far I'm stuck checking the various primes <= 10^5 to see if they divide some repunit and cutting off the checks at what fits in RAM.
19:22:26 <ricky_clarkson> ..er, don't define their names anyway.
19:22:46 <ricky_clarkson> Text doesn't lend itself to graph structures very well.
19:22:55 <wli> shapr: I've crammed more repunits into RAM by finding factorizations of them in terms of cyclotomic polynomials evaluated at 10.
19:23:09 <newsham> varname = [:alpha:][:alpha::digit:_]*
19:23:11 <Pseudonym> Only 10?
19:23:18 <wli> shapr: Not full factorizations, mind you.
19:23:29 <Binkley> I think I'm dumber as a result of having read that blog post
19:23:48 <wli> Pseudonym: Yes, 10. The repunits involve cyclotomics evaluated at 10.
19:25:14 <Tene> what blog post?
19:25:26 <wli> shapr: Oh, and factoring is slower than trial division even for all primes <= 10^5
19:25:36 <Binkley> Tene: http://unqualified-reservations.blogspot.com/2007/08/whats-wrong-with-cs-research.html
19:25:39 <lambdabot> Title: Unqualified Reservations: What's wrong with CS research, http://tinyurl.com/ypgj54
19:25:53 <johnnowak> "However, the slight advantage of removing imperative features does not even begin to make up for the Eigerlike learning curve of Haskell, whose incredible and utterly-unwarranted complexity manifests itself in more ways than I can even begin to describe.
19:25:53 <johnnowak> Let me describe one of these ways..."
19:26:26 <Binkley> first against the wall when the revolution comes, I'm tellin' ya
19:28:11 <Excedrin> what's "Eigerlike" ?
19:29:11 <wli> I've had a flash of inspiration.
19:29:15 <Korollary> "The Eiger is a mountain in the Alps of Switzerland"
19:29:23 <Korollary> thanks wikipedia
19:30:38 <wli> I think it's possible to test whether something divides a repunit without any of this crap.
19:30:52 <glguy> wli: what are you working on?
19:31:10 <glguy> was a repunit a number of all 1s or something similar?
19:31:14 <wli> glguy: Project Euler problem #133, because it seemed hard/interesting/etc.
19:31:18 <wli> glguy: Yeah, all 1's.
19:31:19 <Excedrin> Mencius Moldbug more like Dennis Miller
19:33:00 <wli> Well, a power-of-10 repunit.
19:33:33 <wli> glguy: The number of 1's must be a power of 10.
19:33:47 <wli> glguy: For this particular problem anyway.
19:33:52 <glguy> oh
19:36:01 <njbartlett> @seen Shimei
19:36:01 <lambdabot> Shimei is in #xmonad and #haskell. I don't know when Shimei last spoke.
19:37:27 <shapr> What monad instance is used in   (id >>= (+) >>= (+) >>= (+)) 3        -- (3+3)+(3+3) = 12 ?
19:37:45 <glguy> ((->) r)
19:39:29 <shapr> Binkley: Wow, I see what you mean.
19:41:22 <Shimei> njbartlett: 'lo
19:41:59 <njbartlett> Shimei: Hehe I love how pinging people like that gets their attention :-)
19:42:01 <Binkley> shapr: yeah, I don't really get all the vehemence towards PL research there
19:42:15 <Binkley> if you don't like it, don't read about it
19:42:21 <shapr> Binkley: I'm betting he wasn't accepted into grad school, and this is his bitterness showing through.
19:42:29 <Binkley> shapr: LOL
19:42:54 <Binkley> "well, I don't want to be in your treehouse anyway! It smells bad!"
19:42:56 <njbartlett> Shimei: You mentioned that you got the Tk binding working again. Have you made that available anywhere yet?
19:43:04 <shapr> Binkley: Yup
19:43:45 <Adamant> some people feel that PL research is a waste of tax money. I don't agree with this, but people don't like tax money being wasted.
19:44:10 <shapr> Well, PL research that ends up with papers that you must then buy is a waste, in my opinion.
19:44:19 <Shimei> njbartlett: Not yet. I was going to upload it to hackage once I contacted the old maintainer of the package.
19:44:27 <shapr> I refuse to read papers that are not freely accessible.
19:44:28 <Binkley> if you're going to criticize bad uses of tax money, it's not very efficient to start with PL research
19:44:31 <Shimei> I suppose I could put it up anyway (it's BSD3 software after all), but I wanted to be polite.
19:44:35 <OceanSpray> are there vectors in Haskell?
19:44:35 <Binkley> start wherre the big money is
19:44:38 <Adamant> Binkley, agreed
19:44:46 <shapr> Binkley: True that
19:45:36 <Shimei> njbartlett: I haven't gotten anything back for a few weeks though, so I might just go ahead. Before release I wanted to see if I could clean up the haddock output though.
19:46:07 <pgavin> dcoutts, are you still awake?
19:46:20 <dcoutts> @arr
19:46:20 <lambdabot> Yeh scurvy dog...
19:46:47 <pgavin> umm, cabal can't use Posix, can it?
19:46:56 <chessguy> ugh, not too many things make me feel icky when implementing them in haskell, but i think writing a chess engine's move generator does it well
19:47:07 <njbartlett> Shimei: Okay thanks
19:47:31 <dcoutts> pgavin: I expect not
19:47:52 <dcoutts> pgavin: we can't depend on anything that isn't a 'core' package
19:47:53 <pgavin> hmm... is there a portable way to read mtimes then?
19:48:00 <shapr> Binkley: I think this person also tried to learn Haskell, was unable, and is therefore convinced it's not worth learning.
19:48:18 <dcoutts> @hoogle modification
19:48:19 <lambdabot> Directory.getModificationTime :: FilePath -> IO ClockTime
19:48:28 <dcoutts> pgavin: yay ^^^
19:48:38 <pgavin> ah, cool
19:48:40 <Binkley> shapr: or didn't spend more than a week trying to learn it
19:48:43 <pgavin> thanks :)
19:48:52 <shapr> Um, dynamic higher order programming??
19:49:09 <Binkley> Yeah, that was a strange choice of words
19:49:16 <mudge> doutts  you there?
19:49:19 <shapr> Haskell doesn't really generate new functions at runtime.
19:49:24 <Binkley> well
19:49:28 <Binkley> it allocates new closures at runtime
19:49:44 <shapr> Yeah, but it doesn't "generate new functions at runtime"
19:49:52 <Binkley> except I don't think he knows what a closure is
19:49:58 <shapr> Yeah, I doubt it.
19:50:18 <Binkley> because it's much more elegant to use things like yacc than to use higher-order functions!!!111
19:50:20 * dolio didn't have the energy to read the whole thing.
19:50:28 <Binkley> dolio: yeah, save yourself the time, it's not worth it
19:50:30 <shapr> "However, there is only one problem - the function we build is the same every time." That's not true.
19:50:50 <shapr> He's saying that there's no point in Parsec having a dynamic grammar.
19:51:09 <shapr> But it is useful, like when parsing xml tags for a DTD you don't have.
19:51:39 <sjanssen> what's being discussed?
19:51:45 <shapr> This silly blog post : http://unqualified-reservations.blogspot.com/2007/08/whats-wrong-with-cs-research.html
19:51:47 <lambdabot> Title: Unqualified Reservations: What's wrong with CS research, http://tinyurl.com/ypgj54
19:51:52 <shapr> It's pretty much a train wreck of cluelessness.
19:51:55 <Binkley> yeah
19:52:17 <kpreid> one can say that new functions are generated at runtime, or that they aren't
19:52:30 <Korollary> that's why they invented downmodding
19:52:48 <kpreid> you can generate arbitrary *behavior* at runtime; compile-to-closures technique
19:53:14 <wli> Lamda lift etc.
19:53:16 <dolio> He should work with that Vorlath guy on System V to solve all the world's programming problems. :)
19:53:17 <kpreid> it's just a question of whether you're looking at the external behavior (yes, new functions), or the implementation (no, they're just closures)
19:53:34 <shapr> kpreid: Good pount
19:53:36 <shapr> point*
19:54:08 <Shimei> I find it sad that the CS field gets such harsh treatment from people inside and outside the community. :\
19:54:29 <Binkley> well, it's inevitable
19:54:43 <Binkley> people feel guilty about doing work that doesn't seem to directly lead to saving baby seals and puppies
19:54:46 <shapr> He does a bunch of ad hominen stuff." ... that they could represent any data structure as a function. While this is true, to describe it as perverse is an insult to perverts."
19:55:15 <kpreid> Bah. Data structures and functions are both objects.
19:55:21 * kpreid ducks.
19:55:28 <Binkley> pants-oriented clothing!
19:55:34 <kpreid> (or, if you like, values/types)
19:58:19 <wli> Code and data are the same in C, too. You can cast function pointers to arrays of bytes and look at them that way, or cast an array of bytes (like the canonical f00f test) to a function pointer and call it.
19:58:21 <shapr> " Haskell is designed to look very pretty and simple. In other words, it looks easy to learn and use. In practice, however, everyone who tries to learn it seems to find it extremely complex and challenging."
19:58:22 <shapr> Wow
19:58:52 <Binkley> Yeah, I don't even know where to begin with that one
19:59:08 <dolio> Well, I found it challenging. I don't think that's bad, though.
19:59:27 <Binkley> how does it "look" easy to learn, though?
19:59:33 <shapr> I had CS101 in 1992... they taught us GWBASIC from the ROMs of IBM XTs... but I can do Haskell.
19:59:34 <Binkley> how do you know if something is easy to learn until you learn it?
19:59:39 <dolio> It's pretty. :)
19:59:41 <shapr> I've had no other CS classes.
19:59:55 <chessguy> GW-BASIC ftw@
19:59:57 <wli> I found the "ML plus overloading minus modules" subset totally trivial. Monads took me 10 years, though.
19:59:57 <chessguy> ftw!
20:01:30 <Shimei> Hmm, I'm getting the feeling this guy's ranting about how programming is all about the denotation (ASCII) and not whatever is behind that. That seems a bit naive.
20:01:51 <shapr> Well, I don't think anyone here would accuse him of having a clue.
20:01:54 <wli> I'm not even looking at it.
20:02:00 <Binkley> Mmm, ASCII fetishization.
20:02:04 <shapr> wli: smart
20:02:48 <wli> I'm busy trying to figure out how to determine whether a given prime p divides a power-of-10 repunit (10^(10^n)-1) `div` 9 for some n.
20:02:59 <shapr> Much more useful and productive.
20:03:05 <Binkley> math is pretty hard, though
20:03:08 <Binkley> you might have to think
20:03:16 <Adamant> math is hard. let's go shopping
20:03:19 <wli> Binkley: I already went shopping.
20:03:20 <shapr> heh
20:03:21 <Binkley> hehe
20:03:35 <Korollary> let's shop for math books
20:03:53 <shapr> nooo
20:03:59 <Shimei> I have unfortunately heard people say "I'm really bad at math, that's why I'm taking CS".
20:04:03 <wli> I bought $200 worth of, well, best not said. Now it's time to goof off with project euler or whatever.
20:04:23 <Binkley> Shimei: and that explains a lot about the software industry
20:05:00 <wli> Shimei: CS should really be split in two, the pure half moved back to the math department, and the other half made into an engineering discipline with professional certification etc.
20:05:23 <wli> (IOW a new engineering department)
20:05:25 <Binkley> I'm not sure it benefits people to make theoreticians and practitioners in CS talk to each other even *less*
20:05:42 <Adamant> the problem with professional certification is that SE is not like any other engineering discipline
20:05:55 <shapr> Binkley: I don't think they talk to each other much as it is.
20:06:03 <Binkley> shapr: right
20:06:13 <Binkley> so I think *enforcing* separation between them would be counterproductive
20:06:19 <shapr> Yeah
20:06:35 <wli> Adamant: Professional certification isn't the issue with that. Lumping them in with the rest of the engineering departments might be iffy.
20:07:05 <wli> IMHO PE-like certs would be a very good idea.
20:07:29 <Shimei> wli: That would be unfortunate if you want to experience both though. I enjoy the mathematical aspects of CS, but I'd also love to tinker with embedded systems and robots. I suppose it'd work out if the departments inter-mingled curricula.
20:07:48 <wli> Shimei: Ideally they would.
20:08:22 <Adamant> wli, what would you certify people in? CS changes far too much to certify in anything but the immutables.
20:09:16 <wli> Adamant: The same argument could be made about various engineering disciplines.
20:09:53 <Korollary> nobody is hired without an interview. Certifications are not worth anything.
20:09:57 <wli> Adamant: You just have to regularly revise the material on the certification exam and so on.
20:10:05 <Korollary> I mean a technical interview
20:10:29 <Adamant> wli, I don't see the point. any such cert exam will never be revised often enough to be useful.
20:11:08 <Adamant> look at how effective private certifications are at determining talent, now we want the government or ACM to do it?
20:11:10 <dansa`> hi; has anyone read ``the haskell school of expression'' by paul hudak? i'm having some trouble with the very second chapter; for instance, i can't see any way to write the function in exercise 2.4 with the tools i already learned; i suppose that's lack of functional programming which I do; i was wondering if someone who has read the book is willing to discuss it a bit; i will describe the context
20:11:15 <wli> Adamant: It really boils down to weeding quack practitioners out of the field and standardizing the curriculum.
20:11:42 <chessguy> dansa`, i've read it
20:11:46 <Adamant> and I assume that if you don't agree with your theories on software development, you are a "quack practitioner"
20:12:00 <dansa`> chessguy: and you play chess; you're my kind of guy :)
20:12:08 <chessguy> heh
20:12:14 <chessguy> and i'm writing a chess engine in haskell :)
20:12:28 <dansa`> chessguy: did you write that function called convex :: Shape -> Bool to detect whether a shape is a convex polygon?
20:12:58 <chessguy> dansa`, ah, that stuff. i didn't actually work through the exercises, no
20:12:59 <bos> @pl \x xs _ -> xs x
20:12:59 <lambdabot> (const .) . flip id
20:13:11 <chessguy> hiya bos
20:13:16 <dansa`> chessguy: hm, i see;
20:13:49 <dansa`> chessguy: hey, you're writing a chess engine? :) that's kool! im writing a chess interface in... err, c++ :)
20:14:02 <chessguy> interface? as in GUI?
20:14:10 <dansa`> yeah
20:14:11 <dansa`> for FICS
20:14:17 <chessguy> err...why?
20:14:24 <OceanSpray> what does liftM do?
20:14:29 <wli> Adamant: Well, there are two issues. First, very little differentiates people on paper. Just anyone can say, "Oh, I'm a programmer!" with nothing like what doctors, lawyers, engineers, and other professionals do.
20:14:34 <dansa`> i'd like to write one :)
20:14:40 <chessguy> OceanSpray, it lifts an ordinary function into a monad
20:14:40 <johnnowak> fics needs a better non-windows gui
20:14:44 <chessguy> @hoogle liftM
20:14:44 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
20:14:44 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
20:14:44 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
20:14:46 <dansa`> why would you be writing an engine? :)
20:14:51 <chessguy> johnnowak, what's wrong with xboard?
20:15:05 <dansa`> you mean dansa?
20:15:07 <chessguy> dansa`, because i'm not satisfied with the ones that are out there
20:15:15 <dansa`> what's wrong with GNUchess?
20:15:17 <wli> Adamant: Second, bad code circulating has real consequences.
20:15:25 <chessguy> dansa`, heh. don't get me started :)
20:15:31 <dansa`> hehe you got a list? :)
20:15:33 <wli> Adamant: Viruses, trojans, etc. for example.
20:15:39 <Adamant> wli, with the exception of safety-critical fields in programming, less is riding on most programs than is riding on a doctor.
20:15:42 <dansa`> i love xboard, actually... and winboard
20:15:56 <dansa`> but i'd be proud of using my own software
20:16:02 <dansa`> i would be happy using my own
20:16:02 <chessguy> dansa`, and no, that question was in fact directed to johnnowak
20:16:03 <samreid> dansa`: take pairs of edges, treat them like vectors, and (say) scale them to length 1.  Then make sure each pair of edges turns in the same direction... using something like a cross product to get the sine of the angle between the vectors...
20:16:08 <dino-> Adamant: Tell that to a financial securities company. :D
20:16:24 <Adamant> dino-, fair enough, but that's financial safety critical. :)
20:16:25 <johnnowak> chessguy: i just don't particularly like it is all.
20:16:29 <dansa`> samreid: you're talking about the convex function?
20:16:43 <samreid> dansa`: I'm sure there's a cuter way.  Yes I'm talking about 2.4
20:16:43 <johnnowak> chessguy: i haven't a refined critique
20:16:52 <kpreid> virus & trojan problems can be much more effectively solved by limiting the damage vulnerable components can do than by trying to stamp out all bad code.
20:16:53 <dansa`> samreid: what you call edges are vertices?
20:17:10 <chessguy> dansa`, as for GNUchess, among others, i'll quote Noam Chomsky: "[Alpha-beta] about as interesting as the fact that a
20:17:10 <chessguy>  bulldozer can lift more than some weight lifter."
20:17:19 <wli> Adamant: But also when things crash or err there are economic consequences that add up to people losing their livelihoods, losing health insurance, etc. Maybe even people starving to death or dropping dead with lack of health insurance.
20:17:27 <samreid> dansa`: edges?  Er, sides of the polygon.  Treat them like vectors, pointing from one vertex to the next
20:18:16 <wli> kpreid: Obviously the point of diminishing returns is rather early on any strategy based on trying to prevent bad code from circulating. It doesn't mean that no attempt to do so should be made at all.
20:18:17 <dansa`> and what's to scale them to length 1?
20:18:22 <Adamant> wli, why not establish a voluntary certification from somewhere like the ACM and let employers determine if they want to use it?
20:18:24 <OceanSpray> is '(liftM foo) bar' the same as 'liftM foo bar'?
20:18:40 <hpaste>  pgavin pasted "cabal deps" at http://hpaste.org/2292
20:18:46 <pgavin> dcoutts: ^^^
20:18:52 <mnu> @src sum
20:18:52 <lambdabot> sum = foldl (+) 0
20:18:54 <samreid> dansa`: Well, that's not actually necessary, come to think of it.  But you'd calculate the length and then divide by the length
20:18:57 <chessguy> @type (liftM ?foo) ?bar
20:18:58 <lambdabot> forall a1 r (m :: * -> *). (?foo::a1 -> r, Monad m, ?bar::m a1) => m r
20:19:08 <chessguy> @type liftM ?foo ?bar
20:19:10 <lambdabot> forall a1 r (m :: * -> *). (?foo::a1 -> r, ?bar::m a1, Monad m) => m r
20:19:15 <OceanSpray> huh?
20:19:27 <dansa`> samreid: it seems to me that you've got some theory in your mind which i dont in mine :|
20:19:34 <Korollary> OceanSpray: Yes, application is left-associative
20:19:35 <wli> Adamant: I was never specific about the certification authority. I don't think it's important what the certification authority is so long as it's recognized as authoritative.
20:19:42 <OceanSpray> ok then.
20:19:58 <Adamant> wli, I don't have a problem with more certifications, I have a problem with mandatory certification.
20:20:00 <dansa`> BRB
20:20:31 <wli> Adamant: Well, mandatory certification is precisely what I'm on about. There needs to be *some* bar to pass, however low.
20:20:51 <dcoutts> pgavin: so what's the difference between getSources and getPrerequisites ?
20:21:18 <pgavin> dcoutts: getSources for a .chs -> .hs rule would be the .chs file
20:22:02 <pgavin> dcoutts: for a library it would be the .o files
20:22:02 <Adamant> wli, let's say some kid is building a web app for a small business. do you feel he should have to undergo mandatory certification, and if so, why do you feel this is any different than a 2000's era guild practice to keep out competing programmers?
20:22:11 <dansa> samreid: you know what? i'm really asking for help on the wrong exercise; recovering my notes here I see that i had trouble already in exercise 2.2; i have no understood enough of the syntax of haskell (or the way of FP) so far to allow me to clearly see how to write regularPolygon :: Int -> Side -> Shape
20:22:40 <pgavin> dcoutts: basically what you think of as source files
20:22:52 <Adamant> also, if you set the bar low enough, the exam is worthless
20:22:53 <wli> Adamant: No idea what you mean by a 2000's era guild practice.
20:22:53 <samreid> dansa: ok let me look
20:22:55 <pgavin> dcoutts: getDependencies is for imported modules, etc.
20:23:01 <dcoutts> pgavin: but why do we need to distinguish the static deps and the ones we discover later?
20:23:15 <dansa> I wrote some notes on an algorithm for that function; if you'd be kind to read it (it's brief), then perhaps you could sort of talk to me about how to put into haskell code
20:23:27 <pgavin> dcoutts: so that we can get from Module.o -> Module.hs -> Module.chs -> Module.chs.pp
20:23:34 <dcoutts> pgavin: I'm not saying it's bad, I'm wondering if it's necessary
20:23:48 <Adamant> wli, guilds restricted the people who could work in a field to maintain prices. Modern medicine does this now by requiring doctors for tasks like people like physician's assistants could easily handle.
20:24:11 <Adamant> *for task people like
20:24:15 <dcoutts> pgavin: suppose getSources was always [] and getPrerequisites did return of the ones getSources would have given us, would the system still work?
20:24:17 <pgavin> dcoutts: I couldn't think of any other way to determine what rules to use to build each target
20:24:25 <pgavin> dcoutts: no, I don't think so :)
20:24:31 <samreid> dansa: I see, you don't have much knowledge at that point
20:24:41 <pgavin> dcoutts: I haven't tested this yet (at all) I just got it to compile
20:24:44 <dino-> Adamant, wli: Perhaps a system should restrict what a person doing professional computer work can use for a title. Doesn't civil and EE work like this already?
20:24:59 <wli> dino-: I believe so.
20:25:08 <dansa> samreid: yeah; BTW, i happened to have written my ``algorithm'' in a foreign language; i'll translate it quickly here and show it to you
20:25:10 <Adamant> dino-, a private certification would accomplish the same thing without regulation.
20:25:13 <wli> dino-: I was suggesting following in their footsteps.
20:25:34 <dino-> Adamant: Yes, and I think that would be fine if like you guys said, everybody accepts this system.
20:25:34 <dcoutts> pgavin: and the other thing I wonder is, executeRule takes one target, how do we cope with rules that produce multiple targets?
20:26:06 <samreid> dansa: you don't need to
20:26:21 <dansa> samreid: what do you have in mind then?
20:26:22 <wli> Ah, the right-wing privatizing everything and anti-regulation crud. No point in attempting to communicate further. Communication with such is impossible.
20:26:39 <pgavin> dcoutts: well, executeRule "Module.chi" and executeRule "Module.hs" should have the same result; that is, both Module.chi and Module.hs get built
20:26:40 <samreid> dansa: you've basically got some for loop iterating an integer from 1 to n, or from 0 to (n-1), computing the location of the k'th point, right?
20:26:49 <dansa> right
20:26:56 <dansa> i would actually use recursion because i dont know how to loop :)
20:27:01 <samreid> dansa: so your problem is getting those values into a list
20:27:05 <dansa> the book hasn't shown any kind of loop yet
20:27:22 <samreid> right
20:27:24 <Adamant> wli, what you are basically saying is that everything about your plan could be accomplished except forcing people to use it, so it's worthless?
20:27:28 <dansa> right; i could build a list by recursion
20:27:34 <dino-> wli: I didn't mean to take some stance like that towards or against some kind of regulation. I was trying to agree that there should be something. Apologies if I stepped into the middle of something else entirely.
20:27:56 <dcoutts> pgavin: so it takes any of the concrete targets of the rule. So these are rule schema, like *.chs -> *.hs
20:27:58 <wli> dino-: It wasn't you.
20:28:08 <pgavin> dcoutts: exactly
20:28:20 <dino-> I think nothng at all, being able to put wild and bogus claims on a resume, say. Bad.
20:28:47 <wli> Adamant: There can be no conclusion to this debate apart from that our basic precepts differ.
20:29:26 <Adamant> wli, if you feel that way, fair enough.
20:29:29 <samreid> dansa: First, it might be easier if you start at N and count down to 0.  Let's say 'f :: Int -> (Float,Float)' is that function. (Maybe your implementation of f takes an extra argument, depending on whether you put it inside a 'let' construct or not, but that's the same idea...)
20:29:46 <Adamant> you should keep the "no rational debate" part to yourself though.
20:30:15 <wli> Plonk.
20:30:39 <Adamant> definitely a win for maturity.
20:30:56 <dansa> samreid: shall we discuss how to count down to 0? i'm a function; i take n; then i call myself with n - 1, and so on... but how do I detect then it's zero? I haven't seen any comparison operators yet
20:31:34 <dansa> so far my conditionals are all based on pattern-matching only
20:31:45 <samreid> dansa: you have a point
20:32:00 <dansa> so how i can pattern-match that n = 0 so that i can have a base case?  i'm puzzled. :)
20:32:15 <samreid> dansa: they haven't shown pattern matching on numbers...
20:32:57 <dansa> that makes me feel a little better; i've been thinking im missing something that should be fairly obvious
20:33:16 <dansa> but it does seem that we lack enough tools for these exercises
20:34:18 <wli> shapr: Okay, I think we end up with p | (10^(10^n)-1) or 10^(10^n) = 1 mod p for some n. Which boils down to 10^n = 0 mod (p-1).
20:34:30 <wli> shapr: For primes p > 3
20:34:34 <glguy> dansa: I'm late to the party, do you have a link to the exercise you are discussing?
20:35:11 <dansa> glguy: not a link; this is from paul hudak's book ``the haskell school of expression''; i only have it in print; i can write it for you, though, but you might lack context
20:35:22 <glguy> dansa: i have that book, pg #?
20:35:29 <wli> shapr: I'm not entirely sure what it takes to get 10^n = 0 mod (p-1)
20:35:33 <dansa> page 25, exercise 2.2
20:36:23 <samreid> dansa: Ha!  It mentions at the bottom of page 15 that you can look in Appendix B for a concise summary of the various kinds of patterns that are allowed!  :-/
20:36:33 <dansa> samreid: ha! :)
20:36:51 <dansa> that's true :)
20:36:57 <wli> shapr: I suspect 10|(p-1) or p = 1 mod 10
20:37:21 <bos> @pl \(k,_) _ m -> insert k m
20:37:22 <lambdabot> const . insert . fst
20:37:46 <samreid> dansa: let me give you an example of counting down to zero:   factorial 0 = 1 ; factorial n = n * factorial (n-1)
20:37:56 <dansa> i guess i ``should eventually become familiar with the various kinds'' :)
20:38:22 <dansa> hm, i can match it this way; i see
20:38:26 <dansa> factorial 0 = 1
20:38:37 <dansa> so that would be my base case for n getting down to zero
20:38:41 <samreid> yep
20:38:43 <dansa> got it
20:39:25 <dansa> alright; thank you very much for your help; i now should go put some ideas into code and practice appendix B before i move on
20:39:49 <dansa> BTW, do you guys read comp.lang.haskell? it's been so... slow
20:40:01 <Cale> dansa: Everyone uses the mailing lists
20:40:06 <dansa> Cale!
20:40:09 <Cale> hello
20:40:24 <dolio> > let fact = product . enumFromTo 1 in fact 6
20:40:26 <dansa> hi :) yeah, you're a haskell guy; i remember you writing some stuff :)
20:40:32 <lambdabot>  720
20:40:40 <Cale> :)
20:40:40 <dansa> cale, is that the haskell cafe for users?
20:40:54 <dansa> isnt there a list named something like that?
20:41:00 <Cale> Yeah, it's a mailing list you can subscribe to
20:41:06 <Cale> There's also just plain 'haskell
20:41:10 <Cale> '
20:41:20 <dansa> which one would be the best for a total newbie?
20:41:31 <wli> shapr: Okay, maybe not. :(
20:41:35 <Cale> Well, haskell-cafe is for questions
20:41:56 <Cale> Lots of interesting stuff goes on the Haskell mailing list too.
20:42:22 <dansa> interesting stuff that a very recent beginner would make some sense of? would you say so?
20:43:21 <Cale> hmm :)
20:43:29 <dansa> dont worry :)
20:43:33 <dansa> i'll check it out :P
20:43:33 <Cale> Perhaps, I don't know :)
20:43:35 <Cale> yeah
20:43:36 <zak> I'm trying to profile (with ghc) a program I'm writing... does anyone know how to add cost centres to non-top level functions?
20:43:52 <Cale> zak: {-# SCC "name" #-}
20:43:59 <dansa> well, have a good night you all
20:44:07 <Cale> zak: on the expression that you'd like to name
20:45:15 <zak> Cale: yeah, that's what I tried, but the function is recursive so I think it only counts the first call
20:45:26 <zak> which doesn't really make sense to me, but that's what it appears to be doing
20:45:30 <Cale> hmm
20:46:22 <zak> because all the time spent in the recursive calls should count towards the inherited statistics, right?
20:46:27 <Cale> zak: what kind of thing is the recursive function returning? Is it possible that the program never has to compute the recursive case?
20:47:06 <Cale> If it returns something like a list, and the tail of the list computed by the recursive case is never needed, then it won't get entered again.
20:48:03 <Cale> (Another way to check would be to use Debug.Trace.trace to print a message whenever that expression was evaluated)
20:48:29 <zak> no, I'm fairly sure the recursive call is computed
20:48:37 <Cale> hmm
20:49:03 <Cale> That's odd then :)
20:49:07 <shapr> @users
20:49:08 <lambdabot> Maximum users seen in #haskell: 385, currently: 340 (88.3%), active: 15 (4.4%)
20:52:42 <zak> heh... Actually where should I put the {-# SCC "foo" #-}?  I put it before the recursive call
20:53:14 <Cale> zak: on the whole expression
20:53:33 <Cale> foo x = {-# SCC "foo" #-} ...
20:54:48 <zak> hahaha... that makes sense... probably should have tried that
20:54:50 <zak> thanks
20:59:32 <mnu> @src last
20:59:32 <lambdabot> last [x]    = x
20:59:32 <lambdabot> last (_:xs) = last xs
20:59:32 <lambdabot> last []     = undefined
21:04:35 <dino-> Do any of the modules under Text.Regex do unicode?
21:05:54 <glguy> dino-: what do you want to do with unicode?
21:05:55 <zak> @src dropWhere
21:05:56 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:06:03 <glguy> oh, lol regex, eh?
21:06:31 <dino-> glguy: Not sure. But I have some XML I'm processing that has crazy characters in it. I need to get rid of them and replace with more ascii versions.
21:06:38 <zak> @src dropWhile
21:06:39 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:06:44 <Cale> last = foldr1 (flip const)
21:06:44 <dino-> Trying to use Text.Regex to subst these things and it's not finding them.
21:07:31 <glguy> dino-: Text.Regex does do unicode
21:07:35 <dino-> They just pass right on through with HXT and end up in the output no matter what I do in terms of trying to find chars like "\xe2" say
21:07:47 <Cale> dropWhile p [] = []; dropWhile p (x:xs) = if p x then dropWhile p xs else (x:xs)
21:08:07 <glguy> dino-: you might need to decode the utf-8 encoded unicode characters, however
21:08:27 <dino-> glguy: Ok. What does that mean?
21:08:35 <dino-> Something maybe in the XML parser?
21:10:15 <dino-> Hm. Maybe Text.XML.HXT.Arrow.ReadDocument.readDocument with a_encoding and some encoding specified..
21:11:01 <dons> http://programming.reddit.com/info/2fykg/comments
21:11:02 <lambdabot> Title: Bamse: Windows Installer (MSI) creator framework written in Haskell (reddit.com)
21:17:10 <dino-> It's very possible that I'm asking about the wrong things here. Let me explain what I'm observing.
21:17:23 <bos> hmm, @pl chokes on tuples larger than two in the patterns on the left.
21:17:29 <bos> @pl \(a,b,c)->a
21:17:30 <lambdabot> (line 1, column 6):
21:17:30 <lambdabot> unexpected ","
21:17:30 <lambdabot> expecting letter or digit, operator or ")"
21:17:30 <lambdabot> ambiguous use of a non associative operator
21:17:59 <dino-> In the original XML I see stuff like "Weâ~@~Yre"
21:18:21 <dino-> It should be "We're", probably they're specifying sexed single right quote.
21:18:45 <dino-> In a hex dump those 3 chars look like e2 80 99
21:19:04 <dino-> The 3 things between We and re
21:19:44 <dino-> Sadly, this document specifies no encoding.
21:21:20 <dino-> Working so far with Text.Regex to try to replace is not working. I've tried that literal â and \xe2\x80 type strings.
21:21:54 <glguy> â
21:22:08 <glguy> that character is "\x2019"
21:22:20 <dino-> The ' char?
21:22:28 <dino-> Or the sexed one?
21:22:43 <glguy> the one you specified
21:23:34 <glguy> the "sexed" one, e2 80 99 in UTF-8
21:23:51 <bos> the default encoding for XML documents is always UTF-8
21:24:11 <dino-> How did you get 2019 from e2 80 99 ?
21:24:28 <glguy> dino-: using my utf8 decoder
21:24:29 <dino-> There's actually a whole pile of other ones in this document. Not all the same.
21:24:33 <glguy> ?where utf8-string
21:24:34 <lambdabot> I know nothing about utf8-string.
21:24:38 <glguy> ?where utf8
21:24:39 <lambdabot> I know nothing about utf8.
21:24:42 <glguy> :-/
21:24:59 <dino-> Magic utf8 decoder ring!
21:25:01 <glguy> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.1
21:25:01 <hpaste>  bos pasted "collaborative filtering in haskell" at http://hpaste.org/2293
21:25:03 <lambdabot> http://tinyurl.com/3dzrdw
21:25:30 <dino-> bos: Ok, I didn't know that.
21:25:39 <dino-> utf8=default
21:25:50 <bos> yes, it's required by the xml standard.
21:28:32 <dino-> glguy: Thank you.
21:28:38 <glguy> :)
21:32:10 <dino-> Is that how you specify these things in Strings? \x2019 ?
21:32:25 <dino-> Still not working.
21:32:36 <glguy> "\x2019 \8217" both work
21:35:39 <OceanSpray> if I were to use continuations to represent lisp continuations in my interpreter,
21:36:01 <OceanSpray> how much modification would I have to do to existent functions?
21:36:42 <dino-> I wonder how it knows that's not \x20 followed by the chars 1 and 9
21:38:41 <dino-> Ah, I see "maximal munch" and you can use \& to separate. Interesting.
21:38:55 <pgavin> @hoogle extension
21:38:55 <lambdabot> Distribution.Extension :: module
21:38:55 <lambdabot> Distribution.Extension.Extension :: data Extension
21:38:55 <lambdabot> Distribution.Extension.extensionsToGHCFlag :: [Extension] -> ([Extension], [Opt])
21:39:05 <pgavin> @hoogle file
21:39:06 <lambdabot> System.Win32.File :: module
21:39:06 <lambdabot> System.Console.Readline.filenameCompletionFunction :: String -> IO [String]
21:39:06 <lambdabot> Distribution.Compat.FilePath :: module
21:39:23 <pgavin> @hoogle take
21:39:24 <lambdabot> Prelude.take :: Int -> [a] -> [a]
21:39:24 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
21:39:24 <lambdabot> Data.PackedString.takePS :: Int -> PackedString -> PackedString
21:44:34 <wli> bos: What's this collaborative filtering bit?
21:45:20 <bos> wli: it's an implementation of an algorithm called slope one
21:45:40 <wli> bos: What's it intended to predict?
21:47:08 <bos> wli: netflix-style "if you liked these, you'll probably like this" stuff
21:47:16 <wli> aa
21:47:56 <bos> it's much simpler than netflix's algorithms
21:48:07 <bos> unfortunately, that implementation isn't exactly easy to read
21:48:57 <bos> wli: less hairy-looking python code at http://www.serpentine.com/wordpress/wp-content/uploads/2006/12/slope_one.py.txt
21:48:59 <lambdabot> http://tinyurl.com/ysr92j
21:49:16 <wli> I don't grok Python.
21:50:16 <wli> I thought it was like travesty or something. Otherwise it didn't hurt me much.
21:53:28 <shapr> Where's sigbjorne moving?
21:59:35 <kjdf> oh I didn't know you were awake
21:59:47 <kjdf> I just  wanted to make an ekg window :)
22:00:06 <kjdf> oops.
22:01:22 <dibblego> ?where mapreduce
22:01:22 <lambdabot> I know nothing about mapreduce.
22:01:51 <shapr> @go mapreduce
22:01:53 <lambdabot> http://labs.google.com/papers/mapreduce.html
22:01:53 <lambdabot> Title: Google Research Publication: MapReduce
22:09:08 <tomppa> anybody know if the http://www.cin.ufpe.br/~haskell/haskelldotnet/ project is still alive?
22:09:12 <lambdabot> Title: The Haskell.NET Project
22:09:39 <shapr> olliej has a .NET compiler.
22:09:55 <shapr> I think he said it has some fragile bits.
22:10:29 <olliej> shapr: it has issues doing arity matching, and while technically able to deal with higher kinded types, it still screws up
22:10:52 <bdash> olliej: i thought you were fixing that? :)
22:11:09 <shapr> Anyway, it means that there's some recenty Haskell -> .NET stuff out there.
22:11:30 <olliej> bdash: what with all the time i have in between fixing damned input method bugs? yes of course :D
22:12:02 * shapr wants to punish XSLT and XPath
22:12:10 <tomppa> great, thanks
22:12:24 <shapr> tomppa: Are you looking for something specific?
22:13:07 <tomppa> not really, I was just curious about how viable a reasonably good haskell compiler for .net would be
22:13:19 <olliej> tomppa: that's basically my thesis
22:13:43 <olliej> tomppa: no one has actually implemented a real one though
22:14:20 <tomppa> are there any particular showstoppers?
22:14:42 <olliej> tomppa: it actually compiled core
22:14:57 <olliej> tomppa: which is the intermediate language of GHC
22:15:03 <olliej> but Core is too lowlevel
22:15:40 <olliej> tomppa: it really needs to be written from scratch
22:15:48 <olliej> tomppa: in a language other than C#
22:15:53 <olliej> :D
22:16:22 <tomppa> are there any papers available on the subject?
22:16:39 <olliej> tomppa: see my thesis, http://nerget.com
22:16:39 <lambdabot> Title: Oliver's Page of Random Ramblings
22:18:09 <tomppa> looks interesting :)
22:31:27 <olliej> tomppa: i'd hope so, i spent a long time writing it :D
22:32:09 <gigamonkey_> if you were writing a Go game in Haskell, would you likely have a function that takes a board and a move and returns a new board?
22:32:34 <olliej> gigamonkey_: that, or i suppose have a monad or some such
22:32:56 <olliej> gigamonkey_: sounds like moand territory, but in all honesty i've never actually used/played with monads :D
22:33:03 <vegai> or perhaps even arrow
22:33:19 <gigamonkey_> Sorry, what's arrow?
22:33:33 <vegai> like monad but crazier
22:33:37 <allbery_b> it's a generalization of monads
22:34:11 <gigamonkey_> great, crazier than monads. That's just what I need. ;-)
22:34:46 * glguy has never run into a situation where "what he needed" were arrows
22:35:28 <Cale> gigamonkey_: yes you would likely have something of that sort
22:35:58 <gigamonkey_> So in a case like a Go game, using monads is just a performance hack, right? Because we don't want to create a bunch of somewhat large data structures that differ very slightly, we instead think impure thoughts and modify state.
22:36:05 <Cale> no
22:36:16 <Cale> Using a monad won't really affect performance there
22:36:30 <gigamonkey_> So why would you use a monad?
22:36:30 <Cale> I suppose you could use a mutable array, but the difference would be tiny.
22:36:31 <shachaf> gigamonkey_: There's nothing impure about monads.
22:36:41 <Cale> gigamonkey_: You use monads to describe computations.
22:37:02 <Cale> For example, your AI might use a monad to nondeterministically try different paths of play.
22:37:05 <gigamonkey_> Eh. But if you're using IORef you've left the realm of pure functions, no?
22:37:29 <shachaf> gigamonkey_: Using a monad doesn't mean using IORef (or STRef, the "pure" version).
22:37:30 <Cale> The IO monad specifically describes impure computation
22:37:30 <Cale> s
22:37:41 <Cale> There are a lot of other monads out there :)
22:37:49 <gigamonkey_> Maybe. ;-)
22:38:00 <shachaf> gigamonkey_: That's one. :-)
22:38:04 <vegai> when creating Go AIs, performance, even in tiny doses, becomes important
22:38:29 <gigamonkey_> I'm actually not even talking about Go AIs. Just the mechanics of implementing the basic rules of the game.
22:38:38 <allbery_b> one possible monad for this is the list monad, which describes comp[utations with backtracking
22:38:43 <Cale> You could implement the rules entirely in pure functions.
22:38:44 <gigamonkey_> I.e. if you go here given this state of the board, this is what happens.
22:38:52 <Cale> There's nothing fundamentally imperative about them.
22:39:23 <gigamonkey_> Cale: yes. But it seems like computing a whole new board every time a stone is placed is somewhat inefficient. Or do I just have too much of the imperitive brain damage?
22:39:31 <tomppa> how does ghc actually handle the situation where you modify and pass a large state in every iteration
22:39:58 <Cale> gigamonkey_: Depends on how you're storing the board. Also, it's only a small array.
22:40:20 <Cale> (if it's an array at all)
22:40:52 <Cale> If you used, say, a Data.Map to store the board, you could share most of the structure with the previous board to construct the new one in O(log n) time.
22:41:02 <sjanssen> tomppa: what sort of state?
22:41:22 <Cale> (well, O(log n) at least in the case that you're not removing lots of stones from the board ;)
22:41:32 <tomppa> sjanssen: like the one used in a board game
22:42:17 <sjanssen> tomppa: ah, I think Cale is covering this one
22:42:31 <gigamonkey_> Cale: Okay. But O(log n) is still quite a bit worse than O(1) for a simple mutable structure.
22:42:37 <Cale> Not really.
22:42:45 <gigamonkey_> Now, as you say, it's not a huge array so maybe it doesn't matter.
22:42:56 <tomppa> for example, if you just map a large list of game objects to get the next state can ghc optimise it somehow.
22:42:59 <roconnor> ?quote O(n)
22:43:00 <lambdabot> syntaxfree says: one could use the euro symbol for left-associative $.
22:43:14 <shachaf> @quote O\(n\)
22:43:14 <lambdabot> roconnor says:  O(n) is slow when n=infinity
22:43:21 <glguy> > logBase 2 (17 ^ 2)
22:43:22 <Cale> gigamonkey_: O(log n) is constant time unless you have a lot of money to keep buying more memory.
22:43:24 <bluestorm> gigamonkey_: plus, you get persistence for free
22:43:27 <lambdabot>  8.17492568250068
22:44:08 <roconnor> basically O(log n) is the constant 32, (or 64 now-a-days)
22:44:29 <Cale> and here we have an even better bound on n
22:44:35 <Cale> > 19^2
22:44:35 <gigamonkey_> Cale: so your Data.Map notion is that you'd map from x,y coordinate to current value? Then make a new map with mostly the same key/value pairs?
22:44:37 <lambdabot>  361
22:44:46 <Cale> yeah
22:44:57 <Cale> gigamonkey_: That doesn't copy the whole map, obviously.
22:45:12 <gigamonkey_> Right.
22:45:12 <Cale> When you insert a value, most of the map is shared between the copies.
22:45:46 <gigamonkey_> Like a more complicated version of a list of cons cells?
22:45:52 <Cale> yeah
22:46:00 <Cale> It's actually a binary balanced tree
22:46:30 <shachaf> gigamonkey_: (Off-topic: Are you the author of Practical Common Lisp?)
22:46:33 <gigamonkey_> Hmmm. How does that work if I add a new entry for an existing key. I.e. same key, different value.
22:46:45 <gigamonkey_> shachaf: guilty.
22:46:50 <Cale> Depends on the insertion function you use
22:47:07 <gigamonkey_> Because that would be the normal case for a Go board.
22:47:19 <Cale> You can have it use the new value, the old value, or a function of the two.
22:47:47 <sjanssen> gigamonkey_: it's essentially the same as deleting the old key, then inserting the new one
22:47:56 <gigamonkey_> I mean, if you've got this tree with k -> v and then I want a new tree that's exactly the same except with k -> v' how does the structure get shared?
22:48:18 <sjanssen> gigamonkey_: everything but the path from root to node is shared
22:48:26 <sjanssen> (this is O(log n)
22:48:30 <gigamonkey_> i see.
22:48:44 <kjdf> ooi - is there something like Data.HashTable for ST monad?
22:48:51 <sjanssen> nodes, due to Data.Map's balancing guarantees)
22:48:56 <Cale> Data.HashTable is junk by the way
22:48:58 <gigamonkey_> So the path is copied and the new leaf added at the end of the new path.
22:49:19 <Cale> (as dons managed to figure out the other day)
22:49:32 <Cale> (he did a bunch of experiments, there was a graph somewhere)
22:49:33 <sjanssen> gigamonkey_: I'd say reconstructed rather than copied, but yes
22:49:56 <gigamonkey_> So I've got a new root with one net-new child (leading down the new path) and the rest of the children shared with the original map.
22:50:08 <sjanssen> correct
22:50:09 <Cale> yeah
22:51:07 <sjanssen> and if you toss away the old tree, the cost of these allocations and deallocations is essentially zero
22:51:25 <Cale> (in space)
22:51:30 <sjanssen> (assuming you've got a nice generational GC)
22:51:31 <gigamonkey_> because of generational garbage collection or some other reason?
22:51:35 <Cale> (and nearly so in time)
22:51:36 <gigamonkey_> there it is. ;-)
22:52:30 <glguy> gigamonkey_: what would the Lisp approach be to storing a Go board?
22:52:50 <gigamonkey_> Unfortunately this also means every access to a position of the board (to see what's there) is also O(log n)
22:53:02 <gigamonkey_> glguy: a 2d array probably.
22:53:05 <Cale> Yeah, but n is fixed
22:53:23 <sjanssen> gigamonkey_: O(log n) is O(1) for all practical purposes
22:53:30 <Cale> n is at most 361
22:53:44 <Cale> So log n is not very large :)
22:54:02 <gigamonkey_> Sure but 8 memory accesses is still 8 times slower than 1.
22:54:17 <bluestorm> n is fixed, so O(log n) and O(n^2) and O(n^n) are all constant time bound, see ? :-Â°
22:54:20 <Cale> meh ;)
22:54:38 <Cale> So what you really need to do is ask if it's fast enough
22:54:46 <glguy> gigamonkey_: If you wanted, you could use a mutable array in the ST monad or IO monad
22:54:47 <gigamonkey_> Cale: indeed.
22:54:48 <Cale> and I'm pretty sure you'll find that it is :)
22:54:55 <bluestorm> gigamonkey_: i suppose persistence can be very useful for you
22:55:25 <bluestorm> if you're doing go AI, you'll need to explore the possibilities
22:55:34 <Cale> Depending on what you're doing with the boards, you might not even GC the old ones, because you'll want undo anyway.
22:55:57 <bluestorm> and for that purpose, classical mutable array are very bad
22:56:01 <gigamonkey_> Yeah. But I'm not doing AI. I'm just letting a bunch of genetically programmed critters crawl around on the board.
22:56:16 <Cale> Another possibility, if you're really hard up for memory would be to use an pair of boolean unboxed arrays (mask/colour)
22:56:16 <bluestorm> won't they need persistence ?
22:56:40 <gigamonkey_> bluestorm: what for? They only care about the current state of the world.
22:56:49 <Cale> Boolean unboxed arrays store 8 entries per byte :)
22:56:52 <bluestorm> it's a shame :-Â°
22:57:23 <tomppa> what about something like a simple physics simulation, I have a number of bodies with position, velocity etc and in each step I want to calculate their new position and show the results.
22:57:30 <bluestorm> i thought they may want to say, play a little bit to see new possibilities
22:57:57 <Cale> Generally, I haven't found myself reaching for mutable arrays, they're there in ST and IO if you really want them.
22:57:58 <gigamonkey_> bluestorm: no, they're way to stupid to do that. They just crawl around looking for a "good" place to lay an egg.
22:58:07 <tomppa> naive approach of mapping a list of bodies to a new list sounds very slow
22:58:28 <gigamonkey_> Cale: yeah, I was just curious what folks would consider idiomatic.
22:58:41 <Cale> But immutable structures are just *so* much nicer that I'm willing to take a tiny performance hit for using them. Most of the time it's just unnoticeable, so I don't care :)
22:58:49 <glguy> tomppa: if you are going to traverse the list to update each element anyway, you might as well just use map
22:59:12 <tomppa> If I have the bodies as records wouldn't I need to allocate a new record for each body and in addition cons up a new list structure?
22:59:21 <gigamonkey_> Cale: I can see that. It does seem that you have to also learn to prefer data structures that can share structure.
22:59:57 <sjanssen> tomppa: yes
23:00:26 <Cale> The general view of most Haskell programmers is that premature optimisation is a really bad idea. :) Just watch out for using lists of pairs where you should be using Data.Map. :)
23:00:46 <gigamonkey_> lists of pairs being what we lispers call an alist?
23:00:50 <glguy> yeah
23:00:57 <tomppa> that is just something I would never do in lisp if I wanted good performance. Is there some compiler magic going on to help in this kind of situation?
23:01:04 <Cale> Yeah, an association list
23:01:25 <sjanssen> tomppa: laziness might help, depending on the program
23:01:31 <glguy> tomppa: so you tried mapping the list and it was too slow?
23:02:13 <sjanssen> tomppa: for example, if you're tossing away the old list at the same time you're generating the new one, you won't require extra memory
23:02:17 <tomppa> of course I haven't tried it in haskell :) But in lisp it is too slow...
23:03:06 <gigamonkey_> tompaa: think of it this way, if all your bodies fit in the nursery of your generational GC, and you're changing most of the fields in the bodies (i.e. x and y and velocity changes) then creating new records is about the same amount of work as modifying existing ones.
23:03:08 <tomppa> sjanssen: that's what I thought about.
23:03:26 <Cale> The only issue I'd have with storing physical bodies in a list would be that indexing into a list is slow, and so computing interactions might be costly.
23:03:44 <tomppa> gigamonkey: that also crossed my mind. It maybe not that expensive after all
23:03:49 <Cale> (but then again, maybe not)
23:04:05 <gigamonkey_> Are there immutable arrays?
23:04:08 <Cale> yes
23:04:09 <glguy> yes
23:04:14 <gigamonkey_> Cale wins.]!
23:04:17 <shachaf> But I heard they're quire slow.
23:04:20 <glguy> O(1) lookup, O(n) update
23:04:20 <Cale> There are both mutable and immutable, boxed and unboxed.
23:04:43 <gigamonkey_> O(n) update because you have to create a whole new array every time, right?
23:04:50 <Cale> right
23:04:54 <pgavin> @hoogle touch
23:04:55 <lambdabot> Foreign.ForeignPtr.touchForeignPtr :: ForeignPtr a -> IO ()
23:04:55 <lambdabot> Data.Array.Storable.touchStorableArray :: StorableArray i e -> IO ()
23:04:56 <Cale> There are also "immutable" arrays that provide theoretically O(1) update, when used in a linear fashion.
23:05:08 <glguy> DiffArray
23:05:21 <Cale> Accessing old versions of the array gets progressively slower.
23:05:52 <Cale> (there's some trickery going on behind the scenes to make that happen)
23:05:53 <gigamonkey_> Cale: was that a comment about DiffArrays or immutable arrays?
23:05:59 <Cale> DiffArrays
23:06:51 <gigamonkey_> Can someone give me a pointer to a sane discussion of the problem mixing laziness with tail-recursion? The link to some HaskellWiki that Google turned up was broken.
23:07:01 <Cale> oh, sure
23:07:07 <Cale> I can sanely discuss that :)
23:07:16 <Cale> Let's look at foldl
23:07:17 <gigamonkey_> Okay, so what's the problem?
23:07:22 <bluestorm> http://#Cale :-Â°
23:07:39 <glguy> bluestorm: your mouth seems to be broken a lot ... ;-)
23:07:41 <Cale> Lazy evaluation means outermost-first, with sharing.
23:07:54 <Cale> foldl f z [] = z
23:08:05 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
23:08:13 <Cale> So...
23:08:14 <shachaf> @wiki Stack overflow
23:08:15 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
23:08:19 <Cale> foldl (+) 0 [1,2,3]
23:08:24 <shachaf> gigamonkey_: Maybe that?
23:08:26 <Cale> = foldl (+) (0 + 1) [2,3]
23:08:31 <Cale> = foldl (+) ((0 + 1) + 2) [3]
23:08:32 <gigamonkey_> Is z just the initial value?
23:08:37 <Cale> = foldl (+) (((0 + 1) + 2) + 3) []
23:08:40 <Cale> yes
23:08:44 <shapr> I wish the old wiki were still available somewhere with a horrendous disclaimer.
23:08:46 <Cale> = (((0 + 1) + 2) + 3)
23:08:50 <Cale> = ((1 + 2) + 3)
23:08:53 <Cale> = (3 + 3)
23:08:55 <Cale> = 6
23:09:04 <Cale> that's the order in which lazy evaluation will evaluate that
23:09:24 <Cale> notice the size of the expression built is on the order of the length of the list
23:09:38 <Cale> and it only starts evaluating after the tail-recursive loop has finished
23:09:41 <gigamonkey_> okay.
23:09:49 <bluestorm> @source foldl
23:09:49 <lambdabot> foldl not available
23:09:56 <shachaf> @src foldl
23:09:57 <lambdabot> foldl f z xs = lgo z xs
23:09:57 <lambdabot>     where lgo z []     =  z
23:09:57 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
23:10:01 <Cale> So while that tail recursion really is a tight loop, it's a tight loop that just builds a big expression
23:10:03 <shachaf> @source Data.List
23:10:03 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
23:10:17 <Cale> Don't bother with that @src, it sucks :)
23:10:23 <bluestorm> hm
23:10:24 <glguy> Cale probably didn't use @src because he knew it would use the "optimized" version which doesn't lend itself to instruction as much
23:10:31 <Cale> right
23:10:45 <Cale> It's got a hack to make GHC compile it a little better
23:10:51 <shachaf> Why does lambdabot have that version?
23:10:53 <bluestorm> hm
23:10:58 <shachaf> I thought it usually had functions from the report.
23:11:05 <Cale> Because that's the version that was copied and pasted from the GHC source
23:11:11 <bluestorm> hm
23:11:18 <Cale> okay
23:11:23 <Cale> So, to fix this problem
23:11:30 <bluestorm> but doesn't GHC do lambda/let-floating by himself ?
23:11:38 <Cale> We can introduce a strictness annotation in foldl to get a strict left fold
23:11:47 <Cale> foldl' f z [] = z
23:12:10 <Cale> foldl' f z (x:xs) = let y = f z x in y `seq` foldl f y xs
23:12:52 <Cale> Where evaluating the expression (a `seq` b) will evaluate a, before returning b
23:13:26 <Cale> er, I missed a ' in that recursive call there :)
23:13:45 <Cale> (should be a foldl' instead of calling normal foldl)
23:13:47 <gigamonkey_> So in that case y is acting like the accumulator.
23:13:49 <Cale> yah
23:14:12 <gigamonkey_> Okay. So how, if I'm writing my own tail-recursive function do I figure out whether I've got this problem or not?
23:14:14 <tomppa> hmm, in common lisp(sbcl) destructively modifying a simple 2 element vector structure seem to be ~2 times faster than creating a fresh one
23:14:19 <Cale> and if we were to evaluate foldl (+) 0 [1,2,3], you'd see the addition get forced in each step
23:14:38 <glguy> '
23:14:39 <Cale> gigamonkey_: If you accumulate a value, you almost certainly have this problem.
23:14:59 <gigamonkey_> tomppa: consider, however, that even simple vectors in Lisp have a bunch of goo associated with them.
23:15:14 <Cale> One really good way to make sure you don't have it, is to try to make use of foldl'
23:15:27 <glguy> there are generally two folds
23:15:30 <glguy> foldl' and foldr
23:15:36 <Cale> foldr is usually the one you want, really.
23:16:03 <sjanssen> gigamonkey_: interestingly, there isn't much tail recursion in Haskell
23:16:05 <gigamonkey_> Okay, so if you can stand a bit of Lisp syntax take a look at http://paste.lisp.org/display/46263
23:16:19 <gigamonkey_> If that was written in Haskell would it be a problem?
23:16:29 <Cale> It's not tail recursive, but it has another very attractive property: it returns immediately the function applied to some parameters, and the recursive case is only used if the second parameter is needed by the function.
23:17:02 <sjanssen> gigamonkey_: yes, that's potentially a problem
23:17:14 <Cale> gigamonkey_: yeah, you'd be building up large numeric expressions
23:17:24 <Cale> well, actually...
23:17:28 <sjanssen> actually, you might not be
23:17:31 <sjanssen> what is 'aref'?
23:17:31 <glguy> if you case on the value
23:17:32 <gigamonkey_> Man, that's a bummer.
23:17:35 <glguy> it will force evaluation
23:17:39 <Cale> So long as you *use* pc regularly, you'll be okay
23:17:45 <gigamonkey_> aref = array reference
23:18:02 <glguy> gigamonkey_: since you are using pc often, then it won't build up huge expressions
23:18:05 <sebell> It will be used for each VM call
23:18:05 <Cale> There's a new notation which makes strictness annotations a little nicer.
23:18:21 <Cale> If you pass -fbang-patterns to GHC, you can use the notation
23:18:43 <Cale> foldl' f !z (x:xs) = foldl' f (f z x) xs
23:18:50 <sjanssen> gigamonkey_: GHC automatically catches most of this excess laziness and strictifies it.  IME, it isn't a major problem
23:18:51 <Cale> Well, that's not exactly equivalent, but it's close :)
23:19:25 <Cale> gigamonkey_: Oh, yeah, that's another good point, if you have optimisations turned on, most of the problems magically go away :)
23:19:40 <opqdonut> sjanssen: well it is a problem when an expression blows up in ghci but not when compiled with -O2 :)
23:19:46 <opqdonut> IMO
23:19:53 <sjanssen> meh
23:20:21 <Pseudonym> This is off-topic, but has anyone here worked with Kalman filters before?
23:20:25 <Cale> Still, it's a good thing to know about.
23:20:31 <Pseudonym> If so, please let me know on #haskell-blah.
23:20:41 <glguy> @users
23:20:41 <lambdabot> Maximum users seen in #haskell: 385, currently: 337 (87.5%), active: 16 (4.7%)
23:20:51 <Cale> It's certainly a good idea to actually lazily evaluate some expressions so that you get a feel for how it works.
23:21:26 <Cale> gigamonkey_: I should tell you my heuristic for when to use strict evaluation...
23:21:49 <glguy> big -> little vs little -> big ;)
23:21:53 <Cale> right :)
23:22:03 * glguy has a copy of Cale's script ;)
23:22:05 <gigamonkey_> eh?
23:22:33 <Cale> Basically the only time you want strictness is when you're taking a "big" piece of data (in the sense of many separately evaluable components), and reducing it to something "small" (in the sense that it has one or only a few separately evaluable parts)
23:22:54 <Cale> and you're doing it in a way which requires a dense portion of that "large" bunch of data
23:23:21 <gigamonkey_> "dense portion" meaning, "most of"?
23:23:24 <Cale> yeah
23:23:35 <Cale> If you're searching for something, for instance, you still want laziness
23:23:43 <glguy> like a bunch of addition -> one sum
23:24:03 <glguy> compared to: one number -> long list
23:24:07 <bluestorm> hm
23:24:15 <bluestorm> isn't that what fold* are about ?
23:24:19 <gigamonkey_> so in my case I'm using, presumably, most of the individual values in bytecodes in order to compute, in the end, a couple values left on stack
23:24:29 <gigamonkey_> So that's big -> little, right?
23:24:56 <Cale> yeah
23:25:00 <opqdonut> but aren't you only using few at a time for a "reduction step"?
23:25:06 <Cale> bluestorm: foldl' is about that
23:25:20 <Cale> bluestorm: folding doesn't always reduce the size of your data though
23:25:29 <glguy> ?src reverse
23:25:30 <lambdabot> reverse = foldl (flip (:)) []
23:25:34 <opqdonut> :)
23:25:45 <shachaf> @src concat
23:25:45 <lambdabot> concat = foldr (++) []
23:25:46 <Cale> Well, your input can be lazy
23:26:08 <newsham> ?seen dons
23:26:09 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 2h 15m 8s ago.
23:26:11 <bluestorm> hm
23:26:14 <Cale> In fact, you usually want the production of large values to be lazy whenever possible
23:26:39 <bluestorm> funny to see the difference with the reverse of lazy languages
23:26:51 <Cale> Things that you'll later recurse over somehow. It's just that if recursing over that data involves using it all to build something small, you want some strictness.
23:27:06 <bluestorm> hm
23:27:21 <Cale> (in the function which does that collapsing, and not before)
23:28:21 <gigamonkey_> Okay, folks, thanks for your help. I'll be picking up my printed copy of YAHT tomorrow and probably back with some more questions later.
23:28:33 <shapr> Yay!
23:28:50 <Cale> So essentially, there are four types of computation: small -> small (strict/lazy doesn't matter), large -> large (want lazy), small -> large (want lazy), and large -> small (want strict if summarizing, lazy if searching)
23:29:07 <Cale> This is why we like lazy to be the default.
23:29:07 <shapr> Hm, that's worth putting on the wiki.
23:29:59 <gigamonkey_> In the meantime, if anyone wants to help me out with my next book, feel free to visit http://www.codersatwork.com/coder/Simon%20Peyton%20Jones.html and fill in some info about Mr. Peyton Jones; I'm hoping to interview him and the more I know about him, the better such an interview will likely go.
23:30:01 <lambdabot> Title: Coders at Work - Simon Peyton Jones
23:30:27 <gigamonkey_> Or is it Mr. Jones?
23:30:34 <bluestorm> hm
23:30:44 <shachaf> gigamonkey_: Peyton-Jones, I think.
23:30:45 <shapr> Peyton-Jones
23:30:51 <bluestorm> you may be interested in the "History of Haskell" paper
23:30:53 <opqdonut> P-J
23:31:06 <shachaf> gigamonkey_: Speaking of which, you may want to watch "A Taste of Haskell", if you havne't already.
23:31:08 <bluestorm> he's one of the authors, it's really interesting and it talk a little about him
23:31:13 <gigamonkey_> Not on his home page:  http://research.microsoft.com/%7Esimonpj/
23:31:14 <lambdabot> Title: Simon Peyton Jones
23:31:17 <shapr> SPJ is an interesting person.
23:31:27 <shachaf> @wiki Video presentations
23:31:27 <lambdabot> http://www.haskell.org/haskellwiki/Video_presentations
23:31:30 <gigamonkey_> shachaf: watched the first part. Still planning to watch the second.
23:31:34 <newsham> book?
23:31:34 <shachaf> OK.
23:31:48 <gigamonkey_> newsham: http://www.codersatwork.com/
23:31:48 <bluestorm> ( http://research.microsoft.com/~simonpj/papers/history-of-haskell/history.pdf )
23:31:49 <lambdabot> Title: Coders at Work
23:31:50 <lambdabot> http://tinyurl.com/yotlvc
23:31:51 <shapr> @quote spj
23:31:51 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
23:31:53 <shapr> @quote spj
23:31:53 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
23:31:55 <shapr> hmm
23:31:58 <shachaf> @quote SPJ
23:31:59 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
23:32:03 <shachaf> @quote SPJ
23:32:03 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
23:32:04 <shachaf> @quote SPJ
23:32:04 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
23:32:05 <shapr> @quote simon
23:32:05 <lambdabot> ghc says: TELL SIMON: evalAbsence
23:32:19 <Cale> I love random number generators :)
23:32:27 <shachaf> @quote simonpj
23:32:28 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
23:32:32 <shachaf> @quote simonpj
23:32:32 <lambdabot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
23:33:19 <shapr> SPJ takes off his sweater and sandals and starts waving his arms when he gets excited about a subject.
23:33:28 <shapr> It's fun to watch.
23:33:32 <Pseudonym> But leaves the hair shirt on.
23:33:34 <shapr> heh
23:33:40 <shapr> But only in retrospect?
23:33:45 <Pseudonym> :-)
23:33:47 <newsham> why isnt ken thompson at the top of the list?
23:33:52 <Pseudonym> Lee Naish usually doesn't wear shoes.
23:33:58 <newsham> thompson == the programmer.
23:34:04 <Pseudonym> Even when unicycling.
23:34:10 <gigamonkey_> newsham: yeah, he's near the top of my list.
23:34:22 <newsham> there are 10 people above him
23:34:24 <newsham> i dont get it
23:34:43 <newsham> including ritchie and kernighan
23:34:45 <gigamonkey_> The "popular" list is based on how a couple hundred random people who found their way to my site sorted the list of ~300 names.
23:35:12 <gigamonkey_> There's no accounting for taste. But I'm definitely going to try to get him.
23:35:18 <newsham> also zawinski isnt even a working programmer
23:35:50 <shapr> Pseudonym: Naish unicycles?
23:36:05 <shapr> gigamonkey_: Want pix of SPJ on a unicycle?
23:36:10 <shapr> Specifically, on my unicycle?
23:36:12 <Pseudonym> shapr: Yes.
23:36:12 <newsham> van jacobson should be a lot higher too :)
23:36:17 <Pseudonym> And juggles while on unicycles.
23:36:21 <shapr> Pseudonym: That's cool, I didn't know that.
23:36:34 <gigamonkey_> shapr: sure, you can add a link on the page I listed above.
23:36:37 <shapr> There does seem to be a surprising percentage of programmers who unicycle and/or juggle.
23:36:42 <gigamonkey_> I'm off to bed.
23:36:43 <Pseudonym> http://www.cs.mu.oz.au/~lee/images/fbuni.jpg -- This is Lee Naish
23:36:56 <Pseudonym> I do note he's wearing shoes in that shot.  Must be outside.
23:36:56 * gigamonkey_ juggles and unicycles.
23:37:06 <shapr> gigamonkey_: What?? You too!?
23:37:17 <shapr> gigamonkey_: What kind of unicycle?
23:37:25 <gigamonkey_> Schwin 24"
23:37:31 <shapr> gigamonkey_: You need to upgrade ;-)
23:37:36 <gigamonkey_> No doubt.
23:37:42 <gigamonkey_> I don't ride it much.
23:37:43 <shapr> Try a Kris Holm 24" or 26
23:37:58 <Pseudonym> http://www.cs.mu.oz.au/~lee/images/uniabs.jpg -- Lee Naish unicycling up the outside of a 10 storye building.
23:38:02 <shapr> I have a 26" surly with a 3.7" tire
23:38:25 <shapr> Anyway, I should go to sleep too.
23:38:48 <gigamonkey_> I don't see a 26" but I like the look of a 29" wheel.
23:38:49 <shapr> gigamonkey_: If you're in the southeast USA, it'd be fun to meet and unicycle and talk about code.
23:39:23 <gigamonkey_> shapr: How about Virginia? I'll probably be going there to interview Bernie Cosell
23:39:41 <shapr> Hm, I'm in Birmingham.
23:39:43 <ivant> shapr, gigamonkey_, invite me, invite me! although I niether unicycle nor juggle. I'd even be silent :-)
23:39:56 <nornagon> @undo do { x <- [1..5] ; y <- [7..9] ; return (x,y) }
23:39:56 <shapr> ivant: You're in Florida, yeah?
23:39:56 <lambdabot> ([1 .. 5] >>= \ x -> [7 .. 9] >>= \ y -> return (x, y))
23:40:02 <shapr> gigamonkey_: Sounds like fun, when?
23:40:23 <ivant> shapr, no, but I might visit florida in january or february
23:40:23 <gigamonkey_> Dunno. I've got to sort out who all I'm interviewing and when and then make my travel plans.
23:40:35 <shapr> gigamonkey_: This is pretty much what I ride: http://www.surlybikes.com/blogimages/uni_frame24_2.jpg
23:40:53 <shapr> Except that doesn't have an Endomorph tire on it.
23:40:58 <gigamonkey_> What's the brake for? Going down steep hills?
23:41:02 <shapr> Yup
23:41:10 <gigamonkey_> When I was a kid ...
23:41:29 <shapr> I tried a particularly steep hill recently and tore a knee ligament :-(
23:41:37 <gigamonkey_> doh
23:41:42 <shapr> I really should get my brake put on...
23:42:17 <shapr> Anyway, a Kris Holm unicycle is like a Ferrari as a Schwinn is like ...
23:42:19 <shapr> painful
23:42:31 <gigamonkey_> Wow, 24 hour unicycle races. What a concept.
23:42:59 <shapr> All kinds of cool stuff on rec.sports.unicycling
23:44:06 <gigamonkey_> It's been a while since I was at all serious about it.
23:44:19 <gigamonkey_> I did get up on a 7-footer once.
23:44:22 <gigamonkey_> That was fun.
23:44:23 <shapr> Well, if I don't unicycle I tend to get plump.
23:44:32 <shapr> Wow, I've never done that.
23:44:47 <shapr> dcoutts is another unicyclist here, he has a Coker!
23:44:48 <elliottt> shapr: is riding a unicycle somewhat like a fixed gear with no gearing?
23:44:54 <elliottt> plus the balance, of course :)
23:45:01 <gigamonkey_> elliottt: yes.
23:45:07 <shapr> elliottt: Yeah, one gear, lots of balance.
23:45:13 <Pseudonym> BRB
23:45:30 <gigamonkey_> Alright. I must go to bed. Goodnight all. Thanks for the Haskell help.
23:45:33 <shapr> g'nite!
23:46:04 <shapr> Nice to meet another unicycling programmer :-)
23:46:07 * shapr &
23:48:59 <elliottt> shapr: do you use clipless pedals on the unicycle?
23:49:59 <DRMacIver> Morning
