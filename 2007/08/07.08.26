00:02:19 <dolio> Comonads and monads are both functors, yes.
00:02:40 <dolio> I don't know if there's some more specific type of functor that they both are, though.
00:03:06 <paolino> this comes from bind and cobind definition ?
00:03:07 <dolio> Endofunctors at least, I suppose.
00:04:04 <dolio> Well, in the category theory, I suspect you define a (co)monad as "a functor along with two operations..."
00:04:50 <dolio> Which would be return and bind/join.
00:04:52 <paolino> in terms of join and cojoin  cobind f = fmap f . cojoin, bind = join . fmap f
00:05:36 <paolino> so fmap should be defined
00:07:29 <dolio> Of course, in Haskell, all we have are endofunctors (if you're talking just about Hask), I suppose, so making that distinction isn't very interesting.
00:08:04 <paolino> is there a comonad for dummies like list for monads ?
00:08:40 <paolino> Ok, I don't know the difference between endofunctors and functors actually
00:08:57 <dolio> Well, in category theory, you have lots of categories.
00:09:31 <dolio> So you could have a functor that takes the category of sets to the category of... well, whatever.
00:10:05 <dolio> An endofunctor is a mapping between a category and (some subset of) itself
00:10:13 <dolio> Er, sub-category, perhaps.
00:10:43 <dolio> But in haskell, all functors are trivially from the category of haskell types, to a subcategory of haskell's types.
00:10:50 <dolio> So they're trivially endofunctors.
00:11:20 <paolino> we don't have categories in haskell ?
00:12:05 <paolino> only one : types ?
00:12:56 <dolio> Well, you can have sub-categories thereof.
00:13:17 <dolio> Like, the category of types of lists, or something.
00:13:28 <paolino> types with a signature
00:13:47 <dolio> With arrows like [a] -> [b] or something.
00:14:42 <dolio> Then [] is a functor from the haskell type system in general to the sub-category of list-types.
00:18:19 <paolino> then all functions are functors ?
00:18:59 <dolio> All type functions like [] and Maybe for which you can define fmap are functors.
00:20:39 <paolino> :T fmap
00:20:54 <paolino> :t fmap
00:20:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:21:11 <dolio> I suppose fmap has to follow some laws, too. :)
00:23:26 <paolino> a functor is a mapping , a mapping is a type ?
00:23:42 <dolio> Maybe is a mapping between types.
00:23:53 <dolio> @kind Maybe
00:23:55 <lambdabot> * -> *
00:24:21 <dolio> Maybe takes the type T to the type (Maybe T)
00:25:31 <paolino> @src Maybe.fmap
00:25:32 <lambdabot> Source not found. Maybe if you used more than just two fingers...
00:33:08 <pjd> @src Maybe fmap
00:33:09 <lambdabot> fmap _ Nothing       = Nothing
00:33:09 <lambdabot> fmap f (Just a)      = Just (f a)
00:36:00 <pjd> dolio: comonads might be applicative, i'm not sure
00:36:09 <pjd> (anyone know?)
00:36:20 <dolio> pjd: Yeah, I'm not quite sure, either.
00:38:58 <paolino> mmhh , how would you define pure ?
00:48:10 <fourbissime> hi there. I'm trying to communicate with a server through a socket. but I can send messages to it, but I don't manage to read its answers properly. here is some code : http://hpaste.org/2440
00:49:27 <fourbissime> what happens is that when I use "hGetContents handle", I can read the message, but I have to interrupt to get the shell back.
00:52:07 <slarba_> fourbissime: with hGetContents you are reading "too much". use line buffering and hGetLine or attach payload size into your message
00:52:58 <psykotic> a get reference example is don's simple irc bot
00:53:00 <psykotic> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
00:53:01 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
00:53:02 <psykotic> good, even
00:53:52 <fourbissime> ok, I'm changing a few things to see what happens.
00:56:01 <slarba_> is your server closing the connection after writing the answer?
00:56:40 <fourbissime> I think it is a persistent connection - that's how it behaves when I'm using netcat at least.
00:58:02 <slarba_> hGetContents gives you a lazy string, which means it's will not become "empty" until the connection is closed
00:58:52 <slarba_> otherwise you're blocking for more chars
00:59:19 <fourbissime> ok so that is the reason.
01:22:42 <pjd> Dan Piponi++
01:23:41 <fourbissime> http://hpaste.org/2440#a2 < here, I'm connecting to the server (which sends back one greeting line). what happens is pasted in the next anotation : the first hIsEOF returns False, because there is the greetings line. Then we read the greeting line. finally, we are supposed to be at the end, so I should get a "True". But rather, I got stuck, and I have to interrupt to get the shell back.
01:26:39 <Vq^> fourbissime: why do you think there is an EOF there?
01:27:34 <Botje> fourbissime: i don't think hIsEOF works on network streams. doos it?
01:28:13 <Vq^> Botje: well, it should be equivalent with read(2) returning 0 and that happens with network streams
01:28:40 <fourbissime> well, I'm not sure ... it's just that at the moment it is read, there is nothing more. but as it is not closed, I guess it is not considered as an EOF ... :-/
01:29:08 <Botje> fourbissime: waht happens if you leave out the second hiseof?
01:30:57 <fourbissime> Botje: the thing behave properly. but the problem is that the server answers may be composed of an arbitrary number of lines. So I have to keep reading until the end of the answer ...
01:33:37 <fourbissime> hm. now I think of it, the last line of every answer starts by OK or ACK ... that could be the solution for me.
01:44:05 <slarba_> fourbissime: there is a potential problem with that approach. what if the server never sends the last line? are you reading lines happily until you memory is exhausted? :)
01:44:22 <slarba_> s/you/your/
01:50:42 <fourbissime> slarba_: that's true, it's a problem. so, is there a way to be sure that I've read everything ?
01:54:47 <slarba_> fourbissime: put an upper limit of lines you're going to read. if reach that and no last line has been read, terminate connection
01:55:41 <desp> @hoogle CStringLen
01:55:45 <lambdabot> Foreign.C.String.CStringLen :: type CStringLen
01:55:45 <lambdabot> Foreign.C.String.newCStringLen :: String -> IO CStringLen
01:55:45 <lambdabot> Foreign.C.String.peekCStringLen :: CStringLen -> IO String
01:56:52 <slarba_> fourbissime: I think if you have read 500 lines, that's a good indication that someone is trying to do something malicious
01:57:01 <desp> @hoogle ByteString -> String
01:57:01 <lambdabot> No matches, try a more general search
01:57:29 <slarba_> probably you know a better limit
01:58:00 <fourbissime> slarba_: not sure. the server may send back *a lot* of lines. if you ask it for the complete list of mp3 files registered in its database, it can turn to be quite verbose...
01:58:28 <gleb> desp: you probably want 'unpack'
01:59:14 <desp> gleb: yeah
01:59:14 <slarba_> fourbissime: sounds like the protocol is well designed then :D
01:59:32 <desp> gleb: from the Char8 flavor.
01:59:45 <desp> I don't get it why the default flavor works on Word8
02:02:07 <fourbissime> slarba_: you bet :) the thing is quite oldschool.
02:02:26 <slarba_> fourbissime: maybe your client should still have an upper limit (that would be configurable)
02:04:11 <slarba_> rule #1 in protocol implementations: NEVER trust ANYTHING that comes out from a socket
02:08:19 <flux> slarba_, even if the connection doesn't have the evil bit set?-o
02:08:51 <desp> :)
02:09:25 <fourbissime> :)
02:09:54 <flux> I can imagine that approach killing many protocols..
02:11:06 <flux> sshd says: "hello, I'm ssh 2.0" ssh: "no you aren't! I am trying to access user flux account" sshd: "I bet you are! well here's the challenge" ssh: "hah, like I'd believe THAT!"
02:12:22 <slarba_> I'm just paranoid (and working at codenomicon) :D
02:12:31 <ohub> :P
02:14:59 <slarba_> programmers don't seem to consider too much what should happen when they receive unexpected input
02:30:20 <fourbissime> got to go. thanks for help !
02:33:19 <dhpeterson> hi .. haskell newb with a (hopefully) quick question
02:33:40 <dhpeterson> i am playing with the irc bot example by dons
02:34:11 <dhpeterson> i am trying to convert from an Int to a String in a function
02:34:21 <dhpeterson> is there a prelude method for this?
02:34:26 <Botje> show converts things to strings
02:34:28 <Botje> > show 12345
02:34:30 <lambdabot>  "12345"
02:34:35 <dhpeterson> ahh
02:34:40 <dhpeterson> thnx Botje
02:34:42 <Botje> (and read does the opposite)
02:34:58 <dhpeterson> aha
02:35:05 <dhpeterson> thankyou
02:35:09 <dhpeterson> (it compiles now :) )
02:35:23 <dhpeterson> :t show
02:35:24 <lambdabot> forall a. (Show a) => a -> String
02:35:29 <dhpeterson> :t read
02:35:32 <lambdabot> forall a. (Read a) => String -> a
02:35:36 <dhpeterson> aha
02:36:33 <JohnMeacham_> shapr sorear: there is a todo in the darcs repo that is horribly out of date, and there was a space on the old old haskell wiki for it. I have not set anything up on the new one for it. if someone wants to like the other compilers have, that would be cool.
03:13:21 <yaxu> bah, i need pseudorandom numbers in lots of different parts of my program
03:20:43 <opqdonut> yaxu: check out MonadRandom
03:31:50 <fasta> Why does the following complete program leak massive amounts of space? http://paste.debian.net/35441
03:41:18 <opqdonut> compiled with -O2?
03:41:26 <fasta> opqdonut: yes
03:54:17 <ivant> good morning, #haskell
04:09:23 <yaxu> can anyone recommend a tutorial for how to learn how to use monad transformers such as MonadRandom? (thanks btw opqdonut)
04:10:02 <opqdonut> nw
04:10:29 <yaxu> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html # this one looks good
04:10:33 <lambdabot> Title: Monad Transformers Step by Step
04:11:44 <takamura> hi
04:41:12 <TSC> fasta: That's weird, I can't figure out why it's leaking space
04:52:32 <fasta> TSC: why is it weird? Are you a Haskell guru?
04:53:29 <astrolabe> @type forever
04:53:34 <lambdabot> Not in scope: `forever'
04:54:16 <nornagon> ?let forever m = m >> forever m
04:54:20 <nornagon> @type forever
04:54:20 <lambdabot> Defined.
04:54:22 <lambdabot> Not in scope: `forever'
04:54:38 <nornagon> @type \m -> m >> forever m
04:54:40 <lambdabot> Not in scope: `forever'
04:54:46 <nornagon> oh, blah.
04:54:55 <astrolabe> :)
04:55:02 <nornagon> @type let forever m = m >> forever m in forever
04:55:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
04:55:24 <astrolabe> thankyou
04:57:53 <opqdonut> hmm, is there a monad for which that m b would ever be produced?
04:58:57 <desegnis> > forever Nothing
04:58:59 <lambdabot>  Nothing
04:59:52 <desegnis> That is, Nothing :: Maybe b
04:59:56 <opqdonut> ah yes of course
05:00:07 <opqdonut> > forever []
05:00:09 <lambdabot>  []
05:00:17 <opqdonut> > forever [1]
05:00:20 <lambdabot>  Exception: stack overflow
05:00:21 <TSC> fasta: It's not weird that I don't understand; by weird I mean "I don't get it"
05:00:23 <opqdonut> yup :)
05:00:46 <TSC> But it might be worth reading http://www.haskell.org/pipermail/haskell-cafe/2007-January/021284.html
05:00:48 <lambdabot> Title: [Haskell-cafe] Re: State monad strictness - how?, http://tinyurl.com/3dwf4j
05:02:48 <wli> Control.Monad.State.Strict, anyone?
05:04:28 <TSC> wli: http://paste.debian.net/35441
05:15:28 <fxr> do you get very poor performance with happs on 64 bit linux platform?
05:17:08 <fasta> fxr: nobody can answer that question, since it's too vague
05:20:03 <fxr> fasta: hmm yes it is. I was getting 1200 req/s with 32 bit linux (with a hello world example page), I wanted to try 64 bit performance and installed 64bit debian, now I'm getting 50 req/s with the same example.
05:28:53 <BobFunk> are there any good up to date tutorials on processing XML in Haskell?
05:29:30 <fasta> fxr: #happs is over there, btw
05:29:54 <fasta> fxr: I don't use HApps, so I can't help. But that's definitely, odd.
05:30:36 <fxr> sorry I forgot to look at modeline
05:30:45 <alar> @where HaXML
05:30:45 <lambdabot> http://haskell.org/HaXml
05:31:42 <mrd> @wiki HXT
05:31:43 <lambdabot> http://www.haskell.org/haskellwiki/HXT
05:31:46 <mrd> @wiki HXT/Practical
05:31:46 <lambdabot> http://www.haskell.org/haskellwiki/HXT/Practical
05:32:18 <mrd> HXT and HaXml are the two primary xml libraries
05:32:24 <alar> http://www.kuro5hin.org/story/2002/1/15/1562/95011
05:32:25 <lambdabot> Title: XSLT, Perl, Haskell, & a word on language design || kuro5hin.org
05:36:00 <BobFunk> thx - have been playing a bit around with haxml - will try hxt a bit as well - haxml really seems to lack some up to date guides and exampls for haskell newbie as me...
05:37:17 <TSC> fasta: I think your space leak problem is because the State monad isn't strict enough
05:37:36 <hpaste>  TSC pasted "stricter state" at http://hpaste.org/2443
05:41:13 <Liskni_si> haxml is actually quite nice because of the DtdToHaskell tool
05:41:27 <Liskni_si> you basically don't need any documentation at all then
05:41:47 <fasta> TSC: it would be more enlightening, if I could see the actual graph reduction showing how the space leak builds up
05:42:18 <fasta> TSC: you just distilled this from ap*mus his post. Thanks for your time.
05:45:29 <Sgeo> â€ªâ€«â€¬â€­â€®â€ªâ€«â€¬â€­â€®Ò‰hi all
05:45:31 <Sgeo> â€ªâ€«â€¬â€­â€®â€ªâ€«â€¬â€­â€®Ò‰
05:45:45 <TSC> fasta: Yeah, more or less
05:46:09 <TSC> It's the same as Control.Monad.State.Strict, except for the seq
05:46:20 <TSC> (in >>=)
05:46:21 <Sgeo> oO
05:46:23 <Sgeo> Wrong channel
05:46:31 <fasta> I think I will just grab pen and paper.
05:46:50 <fasta> Since all the software that is supposed to be able to show this is broken.
07:08:25 <EvilTerran> wow, it's dead in here.
07:08:35 <EvilTerran> so... how do we fix the record system? :D
07:09:16 <Igloo> Just propose an obviously-optimal replacement
07:09:54 <HairyDude> define 'obviously' ;)
07:10:16 <EvilTerran> there's gotta be some category-theory based thing that fits perfectly.
07:10:19 <Igloo> The relevant people say "Yes, that's obviously optimal!" when they read it
07:10:30 <EvilTerran> if there's anything i've learnt from haskell, it's that that's universally true.
07:10:47 <roconnor> relevant people ?= everyone named Simon?
07:12:05 <Igloo> Not just them
07:13:18 <pejo> Someone pointed out a paper by Leijen, how controversial is that?
07:14:06 <EvilTerran> @go leijen records
07:14:09 <lambdabot> http://bloggablea.wordpress.com/2007/04/24/haskell-records-considered-grungy/
07:14:09 <lambdabot> Title: Haskell Records Considered Grungy « :: (Bloggable a) => a -> IO ()
07:17:00 <tonfa> http://www.cs.uu.nl/~daan/download/papers/scopedlabels.pdf
07:17:10 <EvilTerran> http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/21num.pdf
07:17:49 <tonfa> it's probably the same paper
07:17:54 <EvilTerran> ... i prefer the formatting on my link. two columns on a computer screen => boo hiss
07:18:05 <EvilTerran> but the abstracts are identical, so i guess it's the same
07:24:02 <delYsid> shapr: hey, how are you doing these days?
07:26:09 <sylvan> Does it need to be "obviously optimal", if it's "obviously a vast improvement" combined with "the current system is obviously crap"?
07:27:11 <Igloo> Yes, because you don't want to go through the pain of rewriting everything twice
07:27:36 <Igloo> The problem is there are a lot of proposals, all of which are better, all of which haev different positive and negative points
07:28:32 <sylvan> Well if you get something which isn't optimal, but at least is good enough so that any improvements won't be massive then you can just stick with it. The problem is that currently we have something which is a steaming pile and it makes the language a LOT less usable IMO. I don't think sticking with a bad system just to avoid choosing between half a dozen "very good" system is difficult. Pick one and stick with it.
07:29:57 <sylvan> s/difficult/reasonable
07:30:11 <EvilTerran> is it possible to introspect a parsec parser?
07:33:52 * EvilTerran suspects not
07:34:15 <augustss> You mean to determine what the parser actually is when running the parser?  No
07:35:45 <EvilTerran> not when running it, but to take an assembled parser and modify its components somehow.
07:36:29 <samreid> EvilTerran: it sounds like you can do what you want
07:37:03 <samreid> EvilTerran: remember your parser can have an internal state -- you can have its parts behave based on that state
07:38:15 <EvilTerran> mm. i was thinking more like being able to modify, say, a parser that's written in another module. if you're doing it with state, the parser needs to be written with that in mind.
07:40:26 <EvilTerran> but AFAICT parsers are abstract and there's no selectors or suchlike.
07:41:06 <Saizan_> i think even with everything exported you couldn't go much far because of >>=
07:42:45 <EvilTerran> yeah, i suppose.
07:43:23 <samreid> EvilTerran: the Parsec parsers inside are functions mapping parser state to parser state + return val or error.  There's no datastructure to look at.
07:43:46 <Saizan_> being able to instrospect was a reason for arrow-based parsers
07:49:49 <EvilTerran> Saizan_, such as? i'll have a look at one.
07:54:16 <Saizan_> EvilTerran: here's where i've read about this -> http://en.wikibooks.org/wiki/Haskell/Understanding_arrows#Using_arrows
07:54:18 <lambdabot> http://tinyurl.com/yy9foz
07:55:59 <EvilTerran> ta
07:58:30 <sioraiocht>  this is the quietest I've ever seen #haskell
08:03:25 <EvilTerran> @users
08:03:25 <lambdabot> Maximum users seen in #haskell: 385, currently: 373 (96.9%), active: 7 (1.9%)
08:06:15 <wli> ivant: I canget this down to Grobner basis plug-and-chug, assuming Grobner in so many variables is feasible.
08:08:38 <hpaste>  bos annotated "(no title)" with "oops, != should be /=" at http://hpaste.org/2446#a1
08:09:31 <wli> ivant: It seems to boil down to parametrizing the n-sphere.
08:47:19 <LeCamarade> Comrades, libgmp is used for arbitrary precision arithmetic, no?
08:49:23 <Saizan_> LeCamarade: yes
08:50:22 <LeCamarade> And it is the only external dependency that a ggc -o wouldn't have, no?
08:50:30 <LeCamarade> s/ggc/gcc/gi
08:51:04 <LeCamarade> (ldd seems to claim thus ...)
08:52:51 * EvilTerran runs headfirst into the "negation can't be expressed in the typesystem" problem
08:55:13 * EvilTerran wonders if it'd be possible to neatly extens the type system to wedge something rather prolog-like into it
08:55:20 <sorear> LeCamarade: Correct, or you can us -optl-static
08:55:48 <LeCamarade> :o)
08:55:48 <sorear> EvilTerran: You can create negative versions of all your predicates, and use de Morgan's laws
08:57:23 <EvilTerran> class Pred a; class NotPred a; instance Inv Pred NotPred; -- this kinda thing?
08:57:46 <EvilTerran> except wait, you can't have classes as class parameters. but you get the idea.
08:59:52 <ihope> Just what is a Char?
09:01:23 <opqdonut> ?i Char
09:01:23 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . v
09:01:28 <opqdonut> :i Char
09:01:37 <opqdonut> pfft
09:02:07 <opqdonut> well, it's a type that's member of at least Ord, Bounded and Enum
09:02:52 <opqdonut> probably stored internally as an integer as the type supports unicode
09:02:57 <opqdonut> for a c-char you want Word8
09:02:59 <sioraiocht> ?instances Char
09:03:08 <lambdabot> Couldn't find class `Char'. Try @instances-importing
09:03:11 <sioraiocht> ?!
09:03:11 <lambdabot> Maybe you meant: . v
09:03:36 <ihope> > maxBound :: Char
09:03:38 <lambdabot>  '\1114111'
09:03:43 <opqdonut> yep
09:03:44 <sioraiocht> orly?
09:04:43 <sioraiocht> @instances-importing Char
09:04:44 <lambdabot> Couldn't find class `Char'. Try @instances-importing
09:04:49 <ihope> One for each code point, apparently.
09:05:45 <opqdonut> instances takes a class, not a type
09:05:59 <ihope> > head (filter (> 1114112) (map (2^) [0..]))
09:06:01 <lambdabot>  2097152
09:06:03 <sioraiocht> ?src showChar
09:06:03 <lambdabot> Source not found. Take a stress pill and think things over.
09:06:25 <fasta> data Char = C# Char#
09:06:29 <fasta> That's Char ;)
09:06:42 <fasta> In GHC, at least.
09:06:42 <sioraiocht> lol
09:06:48 <ihope> > 1114112 - last (filter (<= 1114112) (map (2^) [0..]))
09:06:50 <sioraiocht> what's the # for again?
09:06:56 <ihope> sioraiocht: unboxed type.
09:06:56 <fasta> sioraiocht: unboxed
09:06:56 <lambdabot> Terminated
09:07:19 <sioraiocht> is that just convention? or does it mean something to the compiler?
09:07:30 <ihope> > 1114112 - last (takeWhile (<= 1114112) (map (2^) [0..]))
09:07:32 <lambdabot>  65536
09:07:52 <Igloo> It's just convention
09:08:05 <ihope> > 1114112 - 65536
09:08:06 <lambdabot>  1048576
09:08:39 <sioraiocht> ps, after getting involved with other PL communities
09:08:42 <sioraiocht> haskell is super nice
09:08:44 <sioraiocht> comparatively
09:11:09 <fasta> Igloo: where is Char# defined?
09:12:09 <fasta> Never mind, I found it
09:12:43 <fasta> data Char#, but it seems an empty type.
09:13:16 <fasta> Heh, and I found the Any type.
09:13:33 <opqdonut> fasta: well i guess it's compiler magic
09:13:38 <EvilTerran> ?src IO
09:13:39 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
09:14:08 <fasta> opqdonut: It's probably in the code generator, yes
09:14:38 <fasta> opqdonut: that is where the primops are replaced with real things, trivially
09:15:11 <wli> let isqrt | n < 0 = error "isqrt of negative" | n <= 1 = (n, n) | otherwise = let { xs = iterate isqrt' $ approxSqrt n ; isqrt' (a, b) | a + 1 >= b = if b * b == n then (b, b) else (a, b) | otherwise = maximum *** minimum $ partition ((<n) . join (*)) $ filter (inRange (a, b)) $ nub $ [a, b, c, (c + (n `div` c)) `div` 2] ; c = (a + b) `div` 2 ; approxSqrt n = intervalize $ sqrt $ (fromIntegral n :: Double) ; intervalize rt = let diff = scaleFloat (1 - floatDigit
09:15:22 <wli> oh dear
09:15:26 <opqdonut> oh
09:15:38 <fasta> Nice one liner ;)
09:15:44 <EvilTerran> i think that deserves pasting
09:15:45 <wli> Well, it didn't fit.
09:15:56 <EvilTerran> it doesn't count as one line if it gets truncated ;]
09:16:30 <hpaste>  wli pasted "fancy isqrt" at http://hpaste.org/2448
09:16:59 <wli> I forget who gave me the approxSqrt bit but I didn't come up with it myself.
09:20:53 <fasta> Is there a version of mtl without space leaks?
09:21:37 <EvilTerran> eww...
09:22:01 <EvilTerran> whatever was used to format this PDF put a page break in the middle of a three-line code snippet
09:23:54 <samreid> EvilTerran: what PDF?
09:24:02 <EvilTerran> (not in the middle of the second line, between the first and second lines)
09:24:06 <EvilTerran> http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/21num.pdf
09:24:13 <EvilTerran> pages 7 & 8
09:24:25 <EvilTerran> i presume it's LaTeX
09:24:43 <Heffalump> fasta: have you concluded mtl is to blame, then?
09:24:54 <fasta> Heffalump: yes
09:25:09 <samreid> EvilTerran: oh, well, I don't care then :P
09:25:16 <xorAxAx> yes, its miktex
09:25:24 <fasta> Heffalump: I now wrote a replacement for StateT
09:25:34 <fasta> Heffalump: but I think WriterT has the same problem
09:25:56 <fasta> Heffalump: I only don't really see what would be creating unwanted thunks there.
09:25:56 <EvilTerran> samreid, what, were you just making sure it wasn't one of yours? ;]
09:26:05 <Heffalump> what does your replacement do?
09:26:12 <samreid> EvilTerran: yah
09:26:34 <monochrom> fasta: Control.Monad.State.Strict
09:26:42 <fasta> monochrom: I tried that already.
09:26:54 <fasta> monochrom: I pasted it some time ago.
09:27:02 <fasta> monochrom: you can scroll back and see the leak for yourself.
09:27:30 <fasta> Heffalump: it uses seq to strictify the state
09:27:45 <Heffalump> how is it different from State.Strict?
09:28:27 <fasta> Heffalump: State.Strict doesn't use seq?
09:28:35 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2449
09:28:39 <Heffalump> what's strict about it then?
09:28:44 <fasta> Heffalump: I have no idea.
09:28:51 <fasta> Heffalump: I didn't write it ;)
09:28:53 <Igloo> Its bind uses case rather than let
09:29:07 <monochrom> can't find it. <shrug>
09:29:10 <EvilTerran> isn't that much the same as using seq?
09:29:25 <Heffalump> no, it won't inspect the state
09:29:29 <Igloo> It's forcing the (State, a) tuple, not the state
09:29:49 <Heffalump> sounds like fasta has written Control.Monad.State.Stricter ;-)
09:30:07 <Heffalump> I thought you had problems with forcing error values when you tried that?
09:30:12 <sioraiocht> maybe Control.Monad.State.Strictest?
09:30:45 <fasta> Ap*mus takes all the credit
09:30:56 <Heffalump> sioraiocht: no, that'd do a deepSeq
09:31:26 <sioraiocht> lol
09:31:27 <fasta> Heffalump: you mean that I used (error "foobar")
09:31:30 <fasta> Heffalump: ?
09:31:34 <fasta> Heffalump: yes, I stopped doing that.
09:31:40 <Heffalump> fasta: ah, ok
09:31:49 <fasta> Heffalump: but I now still have the same problem with WriterT
09:32:00 <Heffalump> well, I guess it works roughly the same way
09:32:01 <monochrom> One can combine Control.Monad.State.Strict with the habit of "put $! newvalue".
09:32:13 <fasta> Heffalump: any advice how to strictify that further?
09:32:26 * Heffalump thinks the best approach would be to use a strict datatype as your state, rather than write a new monad. But the latter may be less hassle.
09:32:34 <Heffalump> I'll go and look at the source.
09:32:59 <Heffalump> but my first instinct would be to define your own Monoid instance for your writer data (using a newtype wrapper) that forces things
09:33:15 <fasta> Heffalump: I am already using a strict data type as state
09:33:22 <fasta> Heffalump: the paste I made also did that
09:34:31 <Lemmih> fasta: Did you paste the code on hpaste.org?
09:34:52 <fasta> Lemmih: no
09:35:12 <fasta> Lemmih: http://paste.debian.net/35441
09:35:25 <fasta> Lemmih: but that problem has already been solved.
09:36:17 <fasta> Lemmih: I now would like to know why WriterT when used as the inner monad of a strict state monad transfomer leaks memory
09:36:29 <Heffalump> ghc6-libsrc in Debian seems not to include mtl :-(
09:36:38 <Lemmih> fasta: Paste the code?
09:37:12 <evir> Heffalump: The source is in haskell-mtl.
09:37:13 <Igloo> I should arrange things so the source ends up in with the haddock docs and drop that package
09:37:15 <Heffalump> oh, right, yes, you still need a seq to avoid getting an unevaluated think
09:37:18 <monochrom> A better fix is provide modify'
09:37:46 <Heffalump> which forces the old state, or the new state?
09:37:56 <monochrom> new state.
09:38:11 <monochrom> modify' (\_ -> 0) should not force the old state :)
09:38:14 <Heffalump> evir: that's a source package
09:38:26 <evir> Heffalump: Yes. I was thinking you were searching for that, sorry. :-)
09:38:44 <Heffalump> no, just want the source to browse. Thanks though.
09:39:20 <Heffalump> Igloo: OOI, why is the next release going to be 6.8.1? Is it cos snapshots have been 6.7.largenum so you can't use 6.7 for RCs too?
09:39:47 <yax1> hm, threadDelay is behaving oddly, blocking apparently forever rather than the 1/4 second i'm asking for
09:39:53 <Igloo> Heffalump: We get 6.8.0.$date builds from the 6.8 branch before 6.8.1 is released
09:40:08 <Heffalump> ah, right
09:40:32 <wli> I'm looking forward to the next Debian update of ghc.
09:40:42 <monochrom> The irony is that modify isn't even a class method.
09:40:55 <yaxu> ah, works if i run it frmo the ghci prompt
09:41:05 <yaxu> i remember, it needs a commandline option to ghc...
09:44:16 <Igloo> Hmm, now there's an unhappy profile: http://urchin.earth.li/~ian/prof.png
09:44:56 <fasta> Igloo: when you have the memory, use it ;)
09:45:09 <Heffalump> Igloo has negative memory, it seems.
09:45:29 <fasta> Yes, but notice the 2,000M memory
09:46:33 <Igloo> YM 2400+. Of which 1G is physical RAM and slightly under 1G is swap...
09:48:04 * Heffalump gives up trying to get the source of WriterT installed on his machine
09:48:17 <fasta> Heffalump: just darcs get the source
09:48:31 <fasta> Heffalump: that's a lot easier.
09:48:42 <Heffalump> fair point. Can you tell me the URL to save me more digging?
09:49:31 <fasta>   $ darcs get --partial http://darcs.haskell.org/ghc
09:49:31 <fasta>   $ cd ghc
09:49:31 <fasta>   $ chmod +x darcs-all
09:49:32 <fasta>   $ ./darcs-all get
09:49:32 <lambdabot> Title: Index of /ghc
09:51:35 <Heffalump> oh, I don't want all of ghc, just the libraries
09:51:38 <Heffalump> I'll go find out
09:52:25 <wli> What I really want to figure out how to do is to allow data type definitions at the command line.
09:53:19 <Igloo> wli: YM data Foo = ... in ghci?
09:54:00 <wli> Igloo: Yeah. I found the parsing calls but am clueless how to plug them in or to make use of the results.
09:55:15 <ivant> @pl (a,b) -> zipWith (-) a b
09:55:15 <lambdabot> (line 1, column 7):
09:55:15 <lambdabot> unexpected ">" or "-"
09:55:15 <lambdabot> expecting variable, "(", operator or end of input
09:55:23 <ivant> @pl \(a,b) -> zipWith (-) a b
09:55:23 <lambdabot> uncurry (zipWith (-))
09:55:32 <ivant> @pl \(a,b) -> sum $ zipWith (-) a b
09:55:32 <lambdabot> uncurry ((sum .) . zipWith (-))
09:55:49 <Heffalump> fasta: is your base monad Writer or do you have WriterT on top of something else?
09:56:04 <fasta> monochrom: what definition for modify' did you have in mind? do s <- get; put $! (f s)?
09:56:21 <Heffalump> anyway, looks like you just need to change >>= to seq the new writer state, like with State
09:56:23 <fasta> Heffalump: the base monad is the strict state monad
09:56:33 <fasta> Heffalump: transformer
09:56:38 <ivant> @ty uncurry (zipWith (-))
09:56:40 <lambdabot> forall a. (Num a) => ([a], [a]) -> [a]
09:56:48 <ivant> @ty sum . uncurry (zipWith (-))
09:56:50 <lambdabot> forall a. (Num a) => ([a], [a]) -> a
09:57:01 <wli> Igloo: class and instance decls follow closely on their heels but I've a bit to learn about ghc and/or ghci internals yet before tackling them.
09:57:01 <fasta> Heffalump: the inner monad is the the writert and whatever is in writert can be everything, but mostly ST or Identity
09:57:06 <Heffalump> if you look at Control.Monad.Writer.Strict, it has this line:
09:57:08 <Heffalump>         return (b, w `mappend` w')
09:57:31 <Heffalump> I think if you change that to let w'' = w `mappend` w' in w'' `seq` (b, w'')
09:57:33 <fasta> Heffalump: yes
09:57:40 <Heffalump> and then make sure w'' is strict, it'll work
09:58:19 <ivant> @ty groupBy
09:58:20 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
09:59:12 <ivant> @pl \a b -> fst a == fst b
09:59:12 <lambdabot> (. fst) . (==) . fst
09:59:43 <opqdonut> (==) `on` fst
09:59:52 <ivant> @ty on
09:59:54 <lambdabot> Not in scope: `on'
10:00:11 <opqdonut> let (f `on` g) x y == g x `f` g y
10:00:13 <opqdonut> common idiom
10:00:31 <ivant> opqdonut, yeah, why it is not in libs then?
10:01:07 <Igloo> Hmm, that's annoying. So Writer really does have another axis of strictness
10:02:57 <ivant> @ty unzip >>> first head
10:02:59 <lambdabot> forall b a. [(a, b)] -> (a, [b])
10:04:02 <fasta> Heffalump: ok, I made the changes. Now, checking whether it indeed works.
10:04:46 <ivant> @ty unzip >>> head &&& (undefined :: [b] -> c)
10:04:48 <lambdabot>     Couldn't match expected type `([a], [b])'
10:04:48 <lambdabot>            against inferred type `[a1]'
10:05:08 <ivant> @ty unzip >>> head &&& (undefined)
10:05:10 <lambdabot>     Couldn't match expected type `([a], [b])'
10:05:10 <lambdabot>            against inferred type `[a1]'
10:05:19 <fasta> Heffalump: it did. Thank you very much.
10:05:19 <wli> @ty unzip >>> head *** undefined
10:05:21 <lambdabot> forall b a c'. [(a, b)] -> (a, c')
10:05:27 <ivant> thanks
10:05:43 <ivant> I always forget which one is what I want
10:07:20 <Altair^> what should one try as the first haskell project in order to learn the language adequately?
10:08:02 <sioraiocht> Altair^: there are a ton, what's your prior programming experience?
10:08:07 <fasta> Altair^: something that you care about ;)
10:08:32 <ivant> Altair^, write UM and DNAâ†’RNA converter (which does > 30000 iterations/sec)
10:08:51 <puusorsa> prime intellect
10:10:00 <fasta> It seems when one does nothing "stupid" GHC Haskell is pretty fast.
10:10:03 <ivant> wow, arrows are really a cool tool to simplify the program
10:10:22 <fasta> ivant: arrows and simple? That's new.
10:10:38 <ivant> map (unzip >>> head *** countVolume) . groupBy ((==) `on` fst)
10:10:45 <fasta> I know that simplify doesn't imply simple
10:10:55 <ivant> it has the following type  [(SignInfo, Box)] -> [(SignInfo, Double)]
10:11:17 <ivant> you can imagine what a mess it could be without arrows
10:11:44 <fasta> I think using some combinators is nice, but naming it occasionally is a good thing.
10:12:04 <fasta> Being too smart bites back.
10:12:28 <wli> It's not being smart. It's using API's.
10:13:26 <fasta> wli: I can read that code, and we had that discussion already.
10:13:36 <wli> Abstraction layers atop API's that don't introduce new functionality or otherwise abstract something nontrivial are obfuscation, not clarification.
10:15:19 <monochrom> I like naming combinators as "s", "k", and "i".
10:15:47 <fasta> monochrom: is that why ski is called ski?
10:16:22 <FMota> I can see why they'd be named S, K, and I
10:16:49 <FMota> although I'm probably wrong, this is how I see them
10:16:59 <monochrom> I think >>> is a good name. *** may be a less satisfactory name, but I blame the obsession with staying within ASCII.
10:17:12 <FMota> S for Split -- you can split any function application into two using S
10:17:33 <EvilTerran> K for Konstant and I for identity!
10:17:44 <monochrom> I.e., if programmers universally embrace Unicode source code, I'm sure we can find a better name for ***
10:17:45 <FMota> K for Konstant -- it allows you to ignore the argument
10:17:49 <FMota> and I for Identity
10:17:50 <FMota> :)
10:17:56 <SamB> I guess it's because SCI didn't sound so fun
10:17:59 <monochrom> But that is not going to happen for another ten years.
10:18:14 <SamB> also they couldn't use it as an excuse to go skiing if they had called it SCI calculus
10:18:20 <monochrom> Seeing that many programmers don't even embrace Unicode for their IRCing.
10:18:27 <Igloo> :-)
10:18:30 <samreid> ten programming language years, which is... 30, 40 years?
10:18:36 <Igloo> (IM â˜»)
10:18:36 <FMota> lol.
10:18:47 <SamB> hehe
10:18:48 <koala_man> â™¥
10:19:50 <ivant> monochrom, we can define something like âŠ— for ***, using standard syntax (as soon as the bug is fixed in ghc)
10:20:14 <monochrom> Yes.
10:20:14 <Igloo> Which bug?
10:20:37 * xerox spreads unicode l?ve
10:20:41 <ivant> it is impossible to define infix operators with unicode
10:20:47 <SamB> most of us are happy to turn on unicode, but not so happy to be expected to type it
10:20:58 <ivant> Igloo, in 6.6.1, I mean
10:21:15 <monochrom> It is the same problem as entering Chinese. It is already solved.
10:21:16 <SamB> mostly because it isn't easy to type unicode
10:21:22 <SamB> monochrom: not really
10:21:23 <ivant> I remember dons said that it's a different lexer rule, or something like that
10:21:30 <SamB> chinese characters are all related
10:21:37 <Igloo> ivant: works for me
10:22:01 <ivant> hmm, let me try again, I remember it didn't work for me couple of months ago
10:22:10 <SamB> or even if the same idea works... it hasn't been widely adopted for Unicode as a whole...
10:22:14 <Igloo> Well, works in 6.6 here
10:22:39 <monochrom> Yes really. Entering Chinese and Japanese and ... boils down to "input method". There is already an input method and its implementation for entering "\forall" and getting âˆ€.
10:22:48 <fasta> monochrom: the problem is how to input it
10:23:00 <xerox> Igloo: does it need something special besides writng an UTF-8 file?
10:23:12 <Igloo> No
10:23:28 <ivant> Igloo, oh, do you mean you can use "a âŠ— b" instead of "a (âŠ—) b"?
10:23:55 <Igloo> You have to do that, just like you can't use   a (+) b
10:24:24 <monochrom> I actually know some Chinese input methods. When you say "chinese characters are all related" you are speculating as to how to enter them.
10:25:38 <SamB> monochrom: could you please write an IM engine that doesn't suck?
10:25:58 <monochrom> SCIM doesn't suck. The TeX add-on is quite ok.
10:26:11 <SamB> it keeps disappearing on me
10:26:13 <ivant> @go scim
10:26:15 <lambdabot> http://www.scim-im.org/
10:26:36 <SamB> I want a more reliable, stable IM engine
10:26:49 <monochrom> It works here. For CDN$2000 plus shipping you can send me your computer and I can set it up for you.
10:27:01 <SamB> how about you tell me which version you use?
10:27:38 <evir> Does Emacs work with SCIM?
10:27:46 <monochrom> For CDN$4000 plus air ticket and food and accomodation I can fly over to your place instead.  I just use the one that comes with Ubuntu 6.06
10:27:55 <SamB> um
10:27:58 <ivant> does anyone else here use XCompose to enter such symbols, or am I not following the trends?
10:28:05 <SamB> I might have 6 bucks
10:28:09 <ivant> s/such symbols/unicode symbols/
10:28:38 <takamura> scim works on the console?
10:29:23 <monochrom> For CDN$10000 plus $10 per LOC I can fix your Haskell memory leaks.
10:29:41 <monochrom> SCIM assumes X Window, I believe.
10:29:57 <ivant> monochrom, can you also solve halting problem?
10:30:22 <SamB> ivant: yes, but only if you pay him by the reduction
10:30:30 <ivant> :-)
10:30:39 <ivant> @index groupBy
10:30:40 <lambdabot> Data.List
10:30:58 <monochrom> SCIM can work with Emacs, but Emacs is weird regarding internationalization. Its Unicode support is poor.
10:31:07 <SamB> monochrom: yeah :-(
10:31:16 <ivant> monochrom, what about vim?
10:31:23 <ivant> (console vim)
10:31:25 <ivant> in X
10:31:41 <monochrom> I can solve the halting problem for CDN$1 plus CDN$1 per second of time I take to solve it.
10:31:45 <takamura> i can use uim in X with vim
10:31:46 <r_rehashed> hi all
10:31:49 <SamB> emacs has had multi-encoding support for so long it doesn't support unicode correctly
10:31:53 <r_rehashed> >read "5"
10:32:08 <r_rehashed> > read "5"
10:32:10 <lambdabot>  5
10:32:21 <r_rehashed> hey this doesn't work in ghci
10:32:24 <r_rehashed> :P
10:32:32 <takamura> but dont know how to use uim or scim outside gnome :(
10:32:54 <fasta> monochrom: is that on no cure no pay basis?
10:32:59 <monochrom> Yes, vim is fine.
10:33:01 <Liskni_si> what does CDN mean?
10:33:04 <ddarius> I can solve the halting problem for free.
10:33:10 <xerox> r_rehashed: it is defaulting that makes it work. Check out :type read "5" in GHCi, lambdabot specializes it to Integer.
10:33:19 <monochrom> CDN = Canadian dollars
10:33:26 <ivant> ddarius, don't ruin monochrom's business!
10:33:28 <r_rehashed> ok
10:33:47 <monochrom> Heh, the halting problem is not my main revenue anyway.
10:33:57 <fasta> ddarius: you can, but you don't feel like it?
10:34:08 <ivant> monochrom, do you specialize on NP-complete problems instead?
10:34:08 <ddarius> fasta: It's quite easy.
10:34:16 <monochrom> No, not my talent.
10:34:20 <Mr_Awesome> fasta: magic :)
10:34:21 <xerox> ivant: looks like you need parens around a unicode sigil if used as top-level binding name without formal parameters.
10:34:41 <ivant> xerox, yep, that's what I was talking about
10:34:45 <xerox> Too bad my terminal doesn't work properly and I can't evaluate the definition in GHCi :-)
10:34:52 <fasta> ddarius: ok, tell us all.
10:34:54 <ivant> xerox, which kind of sucks for math operators
10:35:08 <opqdonut> yeh i can solve the halting problem too
10:35:13 <ddarius> For any program you write, the answer is, "Yes, it halts."
10:35:16 <opqdonut> ... for strongly typed lambda calculus
10:36:19 <Mr_Awesome> ddarius: not sure if thats the halting problem ;)
10:36:41 <SamB> ddarius: oh?
10:36:43 <fasta> ddarius: if you redefine the problem as you go, yes, the halting problem is easy
10:36:52 <SamB> ddarius: how much are you willing to bet on that?
10:36:56 <SamB> hmm.
10:36:58 <SamB> nevermind
10:37:05 <SamB> I'd never see the payoff ;-P
10:37:19 <ddarius> I guarantee that any program you start executing will eventually halt.
10:37:43 <monochrom> It's pretty unfalsifiable.
10:38:00 <Igloo> Depends what you mean by "halt"
10:38:01 <ddarius> Yes, but easy to make a good argument for.
10:38:04 <monochrom> I bet ddarius is betting his free service on that.
10:38:21 <monochrom> Damn, betting on betting. Meta-betting?!!
10:38:32 <fasta> This software never crashes, just don't run it!
10:38:34 <ivant>  xerox, hmm, âŠ— just worked for me in an expression "head âŠ— countVolume" with (âŠ—) = (***)
10:38:34 <SamB> I was going to buy an IBM mainframe, and bribe IBM to keep it going. but then I realized that I'd never see a cent of the bet money, so I decided that was a bad idea ;-)
10:39:24 <SamB> so he's right
10:39:30 <SamB> any program I start will eventually halt
10:39:53 <SamB> because I've got no incentive to go to all the expense of keeping them running forever
10:40:20 <xerox> ivant: right. It works in expression, but if you define e.g. (HEART) = expression, then you need parens in the definition.
10:41:08 <Saizan_> like any other operator, no?
10:42:13 <xerox> You don't need parenthesis around 'a' in a = 2.
10:43:01 <Igloo> That's not an operator, it's a function
10:43:10 <Igloo> You do in (+) = 2
10:43:40 <ddarius> > let (+) = 2 in (+)
10:43:41 <lambdabot>  2
10:45:01 <Tchakkazulu> The tricky part will be deciding when a certain combination of UTF-8 characters is a 'function' or an 'operator'.
10:45:15 <Igloo> unicode puts them into classes for us
10:45:34 <Tchakkazulu> Ooh, even better :)
10:47:02 <ivant> Igloo, ok, then I don't know which problem I had :-)
10:47:10 <xerox> Igloo: I see, thanks.
10:47:37 <ivant> Igloo, anyway, having nice operators is just what I need now
10:48:35 <monochrom> "Can programming be liberated from the Plain ASCII File?"
10:50:30 <Japsu> hmm
10:50:42 <Japsu> isn't the obvious next question "Why should ..." :)
10:50:51 <fasta> "Can article names be liberated from liberation?"
10:53:52 <hpaste>  mdmkolbe pasted "Context sensitive split at?" at http://hpaste.org/2450
10:54:20 <mdmkolbe3> Given a list of bools take the longest prefix that doesn't have [True, True] as part of it?  I've got a way to do that with http://hpaste.org/2450, but I wondered if there were any simpler ways.
10:56:51 <Heffalump> I'd zip with the tail, do a takeWhile, then map fst
10:57:10 <Heffalump> heh, which is what you've done too :-)
10:57:17 <mdmkolbe3> Heffalump: :-)
10:58:09 <xerox> > unfoldr (\(x:y:xs) -> if x && y then Nothing else Just (x,y:xs)) [True,False,True,False,False,True,True,False,True]
10:58:11 <lambdabot>  [True,False,True,False,False]
10:59:30 <xerox> You can improve sharing by naming the first tail as well.
11:00:14 <EvilTerran> mdmkolbe, do you need the appropriate tail as well?
11:00:23 <mdmkolbe> EvilTerran: yes
11:01:16 <mdmkolbe> EvilTerran: an technically the split should be *after* the [True, True] (which is anoying b/c splitAt and friends like to split *before*)
11:01:20 <mdmkolbe> s/an/and/
11:01:33 <ivant> talking about liberation from plain ASCII, have anyone looked at Fortress?
11:01:44 <EvilTerran> do you want the [True,True] on the end of the prefix list?
11:01:49 <EvilTerran> or does it not matter?
11:02:05 <mdmkolbe> I do want the [True, True] on the end of the prefix
11:02:07 <EvilTerran> (performance-wise, adding or removing it later would be a bit ugly)
11:02:50 <xerox> > join (splitAt . length . takeWhile not . ap (zipWith (&&)) tail) $ [True,False,True,False,False,True,True,False,True]
11:02:52 <lambdabot>  ([True,False,True,False,False],[True,True,False,True])
11:03:25 <mdmkolbe> @pl join (splitAt . length . takeWhile not . ap (zipWith (&&)) tail)
11:03:25 <lambdabot> splitAt =<< length . takeWhile not . ap (zipWith (&&)) tail
11:03:33 <mdmkolbe> @unpl join (splitAt . length . takeWhile not . ap (zipWith (&&)) tail)
11:03:33 <lambdabot> ((\ e -> splitAt (length (takeWhile not (((zipWith (&&)) >>= \ m -> tail >>= \ l -> return (m l)) e)))) >>= \ a -> a)
11:03:38 <xerox> That's nice mdmkolbe.
11:03:55 <mdmkolbe> ok, that's still making me go cross-eyed
11:04:27 <Tchakkazulu> ap (zipWith f) tail == \xs -> zipWith f xs (tail xs)
11:04:51 <mdmkolbe> join (splitAt . (+2) . length . takeWhile not . ap (zipWith (&&)) tail) $ [True,False,True,False,False,True,True,False,True]
11:04:58 <mdmkolbe> > join (splitAt . (+2) . length . takeWhile not . ap (zipWith (&&)) tail) $ [True,False,True,False,False,True,True,False,True]
11:05:00 <lambdabot>  ([True,False,True,False,False,True,True],[False,True])
11:05:01 <xerox> The =<< version is nicer.
11:05:41 <Tchakkazulu> @type splitAt
11:05:43 <lambdabot> forall a. Int -> [a] -> ([a], [a])
11:06:05 <Tchakkazulu> Okay, so for what monad does "join" work, there?
11:06:21 <mdmkolbe> Tchakkazulu: probably list
11:06:39 <Tchakkazulu> If splitAt (something) is a tuple?
11:06:48 <Tchakkazulu> Well.. splitAt (something) (another something)
11:06:50 <EvilTerran> looks like (a->) to me, given that join _ is a function
11:06:54 <twanvl> that join is for the ((->)e) monad
11:06:54 <Tchakkazulu> Oooh, maybe the function monad :)
11:07:08 <Tchakkazulu> join f a = f a a, then, right?
11:07:18 <EvilTerran> i think it's normally called the Reader monad, but yes.
11:07:31 * ddarius prefers the term "Environment monad"
11:07:56 <Tchakkazulu> Ah, yes, I think I understand.
11:08:09 <EvilTerran> @src (->) return
11:08:09 <lambdabot> return = const
11:08:12 <EvilTerran> @src (->) (>>=)
11:08:12 <lambdabot> f >>= k = \ r -> k (f r) r
11:08:22 <EvilTerran> @src join
11:08:23 <lambdabot> join x =  x >>= id
11:08:45 <xorAxAx> @src id
11:08:46 <lambdabot> id x = x
11:08:54 <Tchakkazulu> the splitAt wants an Int and a list, and the composed-function after that (length . takeWhile not . <etc>) is a function from list to Int
11:09:00 <EvilTerran> join f  =  f >>= id  =  \r -> id (f r) r  =  f r r
11:09:10 <EvilTerran> \r -> f r r, rather
11:09:22 <ddarius> @pl \r -> f r r
11:09:22 <lambdabot> join f
11:09:54 <Tchakkazulu> And the large composition to make the Int, and splitAt itself need the same list, so that's what join is used for.
11:10:00 <EvilTerran> filter (liftM2 (liftM2 (&&)) listToMaybe (listToMaybe . drop 1)) [False,True,True,False,True,False,True,True]
11:10:12 <EvilTerran> > filter (liftM2 (liftM2 (&&)) listToMaybe (listToMaybe . drop 1)) $ tails [False,True,True,False,True,False,True,True]
11:10:13 <lambdabot>  Couldn't match expected type `Bool' against inferred type `m Bool'
11:11:02 <EvilTerran> > filter (fromMaybe False . liftM2 (liftM2 (&&)) listToMaybe (listToMaybe . drop 1)) $ tails [False,True,True,False,True,False,True,True]
11:11:03 <lambdabot>  [[True,True,False,True,False,True,True],[True,True]]
11:11:27 * EvilTerran would never use that formation, but i found the use of liftM2 . liftM2 amusing.
11:13:53 <mdmkolbe> > groupBy (\x y -> not (x && y)) [False,True,True,False,True,False,True,True]
11:13:55 <lambdabot>  [[False,True,True,False,True,False,True,True]]
11:14:10 <mdmkolbe> > groupBy (\x y -> not (x && y)) [False,True,True,False,True,False,True,True, True, True]
11:14:12 <lambdabot>  [[False,True,True,False,True,False,True,True,True,True]]
11:14:47 <mdmkolbe> > groupBy (\x y -> not (x && y)) [False,True,True,False,True,False,True,True, False, False]
11:14:47 <ddarius> groupBy schefferStroke
11:14:48 <xorAxAx> what does the bot do on pl?
11:14:50 <lambdabot>  [[False,True,True,False,True,False,True,True,False,False]]
11:14:59 <mdmkolbe> @help pl
11:15:00 <lambdabot> pointless <expr>. Play with pointfree code.
11:15:13 <ddarius> xorAxAx: Compile your code to combinators with a few "optimizations"
11:15:33 <xorAxAx> and what does it return?
11:15:35 <littledan> @pl \x y -> not (x&&y)
11:15:35 <lambdabot> (not .) . (&&)
11:16:02 <Saizan_> if we only had takeUntil!
11:16:25 <ddarius> :t takeWhile . (not .)
11:16:26 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:16:31 <mdmkolbe> Saizan_: by that you mean "takeWhile" but with the split after instead of before?
11:16:58 <Saizan_> mdmkolbe: yeah, and (not .)
11:17:00 <littledan> ?faq does Haskell have takeUntil?
11:17:00 <lambdabot> The answer is: Yes! Haskell can do that.
11:17:22 <Saizan_> which was the link to the gofer prelude?
11:18:19 <mdmkolbe> @src groupBy
11:18:20 <lambdabot> groupBy _  []       =  []
11:18:20 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
11:18:20 <lambdabot>     where (ys,zs) = span (eq x) xs
11:19:52 <mdmkolbe> @src takeWhile
11:19:53 <lambdabot> takeWhile _ []                 =  []
11:19:53 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
11:19:53 <lambdabot>                    | otherwise =  []
11:20:58 <Saizan_> > let foo (True:True:xs) = ([True,True],xs); foo (x:xs) = first (x:) . foo $ xs; foo [] = ([],[]) in foo [False, True,  False, False, True, True, False, True, True] --direct recursion ftw
11:20:59 <lambdabot>  ([False,True,False,False,True,True],[False,True,True])
11:21:10 <xorAxAx> ?faq is lambdabot pure?
11:21:11 <lambdabot> The answer is: Yes! Haskell can do that.
11:21:59 <xorAxAx> @pl id
11:22:00 <lambdabot> id
11:22:20 <Saizan_> @unpl id
11:22:20 <lambdabot> (\ a -> a)
11:22:42 <Tchakkazulu> > (\ a -> a) 5
11:22:43 <lambdabot>  5
11:22:50 <Syzygy-> ?faq
11:22:50 <lambdabot> The answer is: Yes! Haskell can do that.
11:22:55 <Syzygy-> Hehe
11:23:06 <Tchakkazulu> Spaces between \ and the first pattern are allowed? Didn't know that :P
11:23:12 <xorAxAx> @unpl (\ a -> a)
11:23:12 <lambdabot> (\ a -> a)
11:23:16 <xorAxAx> boring :)
11:23:42 <mdmkolbe> @. pl src length
11:23:43 <lambdabot> (line 1, column 1):
11:23:43 <lambdabot> unexpected end of input
11:23:43 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
11:24:31 <Syzygy-> @unpl (.).(.)
11:24:32 <lambdabot> (\ i b c f -> i (b c f))
11:25:05 <Syzygy-> @unpl first
11:25:05 <lambdabot> first
11:25:38 <Tchakkazulu> @unpl fst
11:25:38 <lambdabot> fst
11:26:04 <Tchakkazulu> (\(a,_) -> a)... that's what I'd expect :P
11:26:09 <Syzygy-> @pl (\(a,b) -> a)
11:26:09 <lambdabot> fst
11:26:37 <ihope> @src fst
11:26:37 <lambdabot> fst (x,_) =  x
11:26:43 <ihope> Close enough.
11:26:52 <ihope> @. unpl src fst
11:26:52 <lambdabot> Plugin `compose' failed with: IRCRaised Lib/Pointful.hs:39:24-51: Non-exhaustive patterns in lambda
11:27:08 <ihope> @unpl fst (x,_) =  x
11:27:08 <lambdabot> fst (x, _) = x
11:27:33 <kolmodin> darcs.net offline?
11:28:09 <kolmodin> misery!
11:28:46 <Syzygy-> @pl \(_,_,_,x,_,_) -> x
11:28:46 <lambdabot> (line 1, column 6):
11:28:46 <lambdabot> unexpected ","
11:28:46 <lambdabot> expecting operator or ")"
11:28:46 <lambdabot> ambiguous use of a non associative operator
11:28:51 <mdmkolbe> @pl (\x y -> if x then y else 0)
11:28:51 <lambdabot> flip flip 0 . if'
11:28:58 <Syzygy-> @pl (\(_,_,_,x,_,_) -> x)
11:28:58 <lambdabot> (line 1, column 7):
11:28:58 <lambdabot> unexpected ","
11:28:58 <lambdabot> expecting operator or ")"
11:28:58 <lambdabot> ambiguous use of a non associative operator
11:29:10 <mdmkolbe> @unpl flip flip 0 . if'
11:29:11 <lambdabot> (\ i f -> if' i f 0)
11:29:11 <Syzygy-> Meh.
11:29:27 <Syzygy-> ?src if
11:29:27 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:29:33 <Syzygy-> ?src if'
11:29:33 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:29:41 <Tchakkazulu> \ i f ->
11:29:44 <Tchakkazulu> That's style :P
11:30:02 <Syzygy-> Yeah
11:33:12 <mdmkolbe> @djinn (a, a) -> Bool -> a
11:33:12 <lambdabot> f (a, b) c =
11:33:12 <lambdabot>     case c of
11:33:12 <lambdabot>     False -> b
11:33:12 <lambdabot>     True -> a
11:33:32 <mdmkolbe> @pl \(a, b) c -> if c then a else b
11:33:32 <lambdabot> uncurry (flip . flip if')
11:33:45 * mdmkolbe shakes fist at if'
11:33:52 <mdmkolbe> @index if'
11:33:52 <lambdabot> bzzt
11:35:24 <lokadin> hey is there a tutorial for how to write something that outputs :: StdGen
11:35:34 <lokadin> ?
11:35:38 <SamB> @hoogle a -> StdGen
11:35:39 <lambdabot> No matches, try a more general search
11:35:39 <Japsu> Hmm
11:35:43 <SamB> @hoogle a -> IO StdGen
11:35:44 <lambdabot> No matches, try a more general search
11:35:47 <SamB> @hoogle StdGen
11:35:47 * EvilTerran thinks bool :: a -> a -> Bool -> a might be more in the haskell style
11:35:47 <lambdabot> System.Random.StdGen :: data StdGen
11:35:48 <lambdabot> Random.getStdGen :: IO StdGen
11:35:48 <lambdabot> Random.mkStdGen :: Int -> StdGen
11:36:01 <Japsu> How do I generate instances with Template Haskell? All tutorials I've found just deal with lambdas >_<
11:36:02 <ivant> @src getStdGen
11:36:02 <lambdabot> Source not found. Where did you learn to type?
11:36:32 <filip__> @src Random.getStdGen
11:36:32 <lambdabot> Source not found. Take a stress pill and think things over.
11:36:46 <EvilTerran> @docs Language.Haskell.TH
11:36:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html
11:37:40 <filip__> anyone knows if lambdabot is written in haskell?
11:37:40 <Japsu> So hmm
11:37:45 <Japsu> filip__: yes, it is
11:37:46 <Japsu> @version
11:37:46 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
11:37:46 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:37:49 <EvilTerran> i think you want instanceD, Japsu.
11:38:06 <Japsu> EvilTerran: So I'll just write a function that generates an InstanceD, and then splice it into the source?
11:38:13 <Japsu> *its return value
11:38:31 <lokadin> guess i'll just make up my own StdGen
11:38:31 <EvilTerran> or perhaps $([d| instance Foo $type where...|]) or somesuch
11:38:59 <EvilTerran> but, yes, something of type InstanceD as a splice at top-level
11:39:14 <Japsu> For now, I'd like to make a Template Haskell function that would let me automatically generate Random instances for types that implement Enum and Bounded
11:40:01 <Japsu> using the Random instance template used in http://hpaste.org/2433
11:40:26 <SamB> EvilTerran: you can't splice there in the instance head can you?
11:40:30 <Japsu> hmm, I guess I can figure it out here
11:40:31 <Japsu> let's try
11:40:35 <EvilTerran> SamB, i don't know
11:40:59 <Igloo> You can't splice types anywhere
11:42:02 <EvilTerran> ah, yes. that's what it is. i knew splicing inside a [t|...|] was trouble, but couldn't remember why.
11:42:09 <oerjan> lokadin: StdGen is an abstract type, you cannot make it except with the provided functions.
11:42:23 <oerjan> :t random
11:42:28 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
11:42:36 <lokadin> well i only need the random numbers for a specific few functions
11:42:45 <lokadin> i have a symbol randomizer
11:43:12 <lokadin> and all my other random needs are based on it
11:43:13 <oerjan> lokadin: or maybe you are really asking how to _use_ a StdGen?
11:43:30 <lokadin> i already know
11:43:37 <kpreid> lokadin: to get a StdGen, use either mkStdGen (your seed) or newStdGen (automatic seed)
11:43:48 <kpreid> or use read
11:43:59 <oerjan> but if you want your own random number generator, what you want is your own instance of RandomGen
11:44:06 <lokadin> i just want an infinite amount of irrational random numbers, and i don't know how haskell does it
11:44:15 <oerjan> irrational?
11:44:21 <kpreid> > randoms (mkStdGen 992794)
11:44:23 <lambdabot>  [-727788600,1414123257,52230598,951196977,-1629899328,-2087057960,-528182850...
11:44:23 <lokadin> well truely random
11:44:56 <kpreid> if you want true random numbers, you'll have to ask the OS for them.
11:44:57 <Japsu> @index randoms
11:44:57 <lambdabot> System.Random
11:44:59 <Japsu> yay
11:45:08 <Japsu> @type randoms
11:45:10 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
11:45:11 <lokadin> :D
11:45:14 <Japsu> hmm
11:45:18 <kpreid> It would not be hard to write a RandomGen that read from /dev/random.
11:45:21 <kpreid> StdGen is a pseudorandom number generator.
11:45:25 <Japsu> @indes randomsIO
11:45:25 <lambdabot> bzzt
11:45:27 <Japsu> :<
11:45:28 <SamB> irrational isn't exactly the same as random, but it does sorta imly that you need /dev/urandom at least
11:45:30 <kpreid> But you probably don't want *true* random numbers.
11:45:44 <lokadin> so i'll make an irrational random number generator
11:45:53 <SamB> if you don't want solutions to equations
11:46:02 <kpreid> lokadin: how exactly do you propose to represent these irrational numbers?
11:46:09 <lokadin> binary
11:46:22 <kirby81> but irrational like "not in the rational set of numbers"?
11:46:23 <kpreid> can you be more specific?
11:46:26 <SamB> actually I have an irrational number for you
11:46:39 <lokadin> like the square root of any non-perfect square
11:46:49 <oerjan> Japsu: randomsIO would be newStdGen >>= randoms, i think
11:46:56 <oerjan> :t newStdGen >>= randoms
11:46:58 <lambdabot>     Couldn't match expected type `IO' against inferred type `[]'
11:46:58 <lambdabot>       Expected type: StdGen -> IO b
11:47:06 <SamB> > "0." ++ concatMap show [1..]
11:47:07 <lambdabot>  "0.1234567891011121314151617181920212223242526272829303132333435363738394041...
11:47:08 <kpreid> lokadin: you'll need an unusual Num type to represent that number.
11:47:29 <kirby81> lokadin, the standard haskell numeric hierarchy doesn't support "real" irrational numbers
11:47:35 <lokadin> how do i represent binary in haskell?
11:47:37 <Tchakkazulu> :t liftM randoms newStdGen
11:47:39 <lambdabot> forall a. (Random a) => IO [a]
11:47:50 <kpreid> lokadin: what do you mean by "binary"?
11:47:58 <lokadin> like 101010101111010101001
11:47:59 <SamB> lokadin: do you like my irrational number?
11:48:15 <kirby81> SamB :)
11:48:20 <kpreid> lokadin: well, you could store it as an Array, a Word16, or an Integer...
11:48:20 <Botje> [Either a b] -- look. binary numbers! *hides8
11:48:23 <SamB> lokadin: base-2^32 or so is better
11:48:23 <lokadin> SamB: its base 10
11:48:26 <oerjan> Japsu: Tchakkazulu corrected it
11:48:30 <SamB> than binary
11:48:39 <Botje> lokadin: do look at Data.Bits
11:48:40 <lokadin> i need binary
11:48:46 <lokadin> kk
11:49:12 <SamB> well, okay, binary then
11:49:24 <SamB> [Bool] -- ;-P
11:49:37 <lokadin> :D
11:49:49 <lokadin> that's pretty good
11:50:02 <SamB> you can do slightly better
11:50:11 <lokadin> faster?
11:50:18 <SamB> well, possibly
11:50:26 <lokadin> with what?
11:50:31 <kirby81> lokadin, unfortunately if you ask how to do something in Haskell to n people, you get O(n^2) answers
11:50:53 <kirby81> so... better be specific to make the number of answers at least linear ;)
11:50:55 <lokadin> not always
11:51:10 <filip__> kirby81: i don't think that's "unfortunately"
11:51:13 <filip__> ;-_
11:51:23 <lokadin> it's pretty helpful
11:51:39 <kirby81> filip__: eheh, it depends if you are searching for enlightenment or a simple solution ;)
11:51:47 <SamB> I don't know what your code will do, but "data BitList = O BitList | I BitList" might or might be better
11:52:03 <SamB> of course, if you do that you can say bye-bye to fusion
11:52:20 <lokadin> kirby81: i'm not sure many languages other than Haskell offer enlightenment
11:52:21 <oerjan> SamB: isn't this one of those "what do you really want to do" moments?
11:52:22 <SamB> but if you already said bye-bye to fusion it might help
11:52:23 <kirby81> lokadin: anyway, if you have to manipulate bit sequences, Data.Bits is a good solution, if you have to manipulate binary files you could use Data.Binary
11:52:44 <SamB> kirby81: he wants to manipulate irrational numbers
11:52:48 <lokadin> kk i'll check those out
11:52:49 <lokadin> thanks :)
11:53:17 <ivant> @src groupBy
11:53:18 <lambdabot> groupBy _  []       =  []
11:53:18 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
11:53:18 <lambdabot>     where (ys,zs) = span (eq x) xs
11:53:34 <kirby81> SamB: maybe it's just me, but I cannot see a clear connection between irrational numbers and bit sequences
11:53:46 <lokadin> SamB: an irrational number sequence is the output of a function
11:54:06 <lokadin> or could be
11:54:24 <SamB> an irrational number is just an infinite sequence of digits
11:54:29 <kpreid> kirby81: if the number is represented as a lazy sequence of the bits to the right of the decimal, er, binary point...
11:54:50 <oerjan> isn't there some haskell library implementing computable reals with continued fractions? i seem to recall something like that.
11:55:01 <xorAxAx> @src pl
11:55:01 <lambdabot> Source not found. My pet ferret can type better than you!
11:55:02 <Syzygy-> Yeah, I've seen something like that once. Kinda.
11:55:02 <SamB> which doesn't contain the same tail twice
11:55:06 <kirby81> kpreid: ah I see... so it's a "lazy precise irrational number"
11:55:17 <kpreid> kirby81: ...something like that
11:55:18 <kirby81> oerjan: I think it's NumericPrelude
11:55:40 <kirby81> kpreid: it's a bit strange using binaries for that instead of decimal numbers
11:55:52 <SamB> kirby81: not really
11:55:59 <lokadin> binaries can be converted into any base
11:56:04 <lokadin> easily
11:56:05 <SamB> decimal numbers are wierder
11:56:11 <lokadin> agreed
11:56:27 <oerjan> however, some other power of 2 _would_ be more compact
11:56:40 <lokadin> ?
11:56:41 * SamB wonders how you convert base-2 fractions to base-3 fractions
11:56:54 <kirby81> so... lokadin simply wants a lazy random sequence of booleans, and a number to place randomly a "binary point" somewhere
11:56:57 <EvilTerran> lazy list of Word8s would take up 1/8th of the size, approximately. in haskell, at least.
11:56:57 <SamB> lokadin: like [Word32]
11:57:12 <EvilTerran> or that.
11:57:24 <lokadin> 32 is just so finite
11:57:38 <oerjan> lokadin: you can choose any base you want, but binary is horribly bloated because each bit gets full additional list overhead
11:57:52 <SamB> and maybe the digital abstraction isn't the best one anyway?
11:57:56 <lokadin> meh, we have pretty fast computers
11:58:00 <kpreid> lokadin: you can still have an infinite list of Word32s
11:58:08 <kpreid> it's just grouping the bits!
11:58:17 <lokadin> yep
11:58:28 <lokadin> no list needed
11:58:34 <oerjan> lokadin: i am worrying more about memory if you really want to compute a lot of digits
11:58:48 <lokadin> well they will be flushed after use
11:58:56 <SamB> lokadin: so, um, what do you do with the irrational numbers anyway?
11:59:00 <SamB> clearly you can't print them!
11:59:01 <lokadin> or like just not stored
11:59:16 <lokadin> well you associate them with symbols you can understand
11:59:17 <ddarius> There are several computable reals libraries in Haskell.
11:59:18 <kpreid> take 10 $ show myIrrat
11:59:24 <lokadin> like words and sentances
11:59:41 <lokadin> then can have a random chat bot with large repositories of random information
11:59:58 <Japsu> OMIGOD IDIDDIT
12:00:24 <desegnis> Japsu: what, a monad tutorial?
12:00:37 <oerjan> lokadin: if you do things like multiplication then you will _have_ to store a lot of digits
12:00:40 <hpaste>  Japsu pasted "derive Random for types deriving Bounded, Enum" at http://hpaste.org/2451
12:00:47 <Japsu> desegnis: :D
12:00:48 <Japsu> no
12:00:54 <Japsu> that'll be next
12:00:55 <Japsu> ...not
12:00:58 <lokadin> random information = not known information = relatively unique input
12:01:32 <lokadin> if you believe in Hermeticisim "no such thing as coincidences" then the symbols will relate to you in some way and can help with makin descisions
12:01:38 <lokadin> about any random thing
12:02:04 <Japsu> hmm
12:02:07 <lokadin> i have some working chat bots already
12:02:08 <SamB> so it's a magic 8-ball?
12:02:12 <Japsu> Can I splice imports?
12:02:23 * oerjan prefers simpler divination methods
12:02:24 <lokadin> with more than the entire works of shakespear
12:02:56 <SamB> well maybe it works better than monkeys
12:03:14 <lokadin> definatly more familiar
12:03:14 <SamB> those typewriters wouldn't last long anyway, come to think of it
12:03:48 <kpreid> SamB: allocate some grease monkeys
12:03:53 <SamB> plus monkeys aren't random
12:04:05 <lokadin> or as random
12:04:07 * Cale prefers haruspication
12:04:15 <lokadin> what's that?
12:04:33 <Cale> Divination by inspection of the entrails of animals.
12:04:55 <lokadin> prett crude
12:05:05 <lokadin> pretty*
12:05:29 <lokadin> Zeus did it based on the rustling of Oak leaves
12:06:15 <lokadin> divination that is
12:06:37 <Cale> Heh, interestingly enough, it's the term which my combinatorics professor used for the sort of analysis where you add an additional variable to a generating series by inspection of its structure. (Which is a process that can be formalised using the tensor product of weights.)
12:06:43 <lokadin> micro-macro cosm concept, with interconnection to time -- age of tree and current world state (wind)
12:08:23 <lokadin> eh
12:08:24 <lokadin> it's all good
12:08:46 <lokadin> was thinking of making randomly generated music + real time video
12:09:03 <lokadin> on lojban to have support for all concievable expression
12:09:11 <lokadin> thus far anyways
12:09:21 <lokadin> root vocabulary only 1300 words or some such
12:11:30 <lokadin> could be like an ipod with music no one has ever heard before
12:11:50 <lokadin> for immortals me thinks
12:12:45 <oerjan> it was my understanding from hearsay that purely computer-generated (random or not) music generally sucks
12:12:47 <mdmkolbe> lokadin: how do you express the first concept to be discovered that can't be expressed in lojban?
12:13:15 <lokadin> all homo-sapien concepts can be expressed in lojban
12:13:16 <oerjan> basically randomness will never give you creativity
12:13:20 <lokadin> and much more
12:13:44 <lokadin> known(previously experienced) information != creative information
12:13:48 <kirby81> oerjan: the real problem is that computers have no sense of beauty :)
12:13:52 <mdmkolbe> lokadin: try an prove it, you'll fall afoul of Godel
12:14:02 <roconnor> oerjan: I read that randomness is just unlikely to give creativity.
12:14:02 <lokadin> improvised(random) information = "new" information
12:14:11 <SamB> I don't think immortals would be so picky about not having heard it before
12:14:15 <lokadin> all things are a subset of infinity
12:14:32 <lokadin> i actually have a whole religion to back me up http://tcana.info
12:14:32 <SamB> they'd probably rather hear good oldies than random crap
12:14:36 <lambdabot> Title: la.ma'aSELtcan.: The We with You Network
12:14:44 <oerjan> roconnor: where unlikely is in the infinite-monkey sense, i assume
12:15:17 <roconnor> oerjan: It was possibly more specific than that. I read it in an algorithmic information theory book.
12:15:50 <roconnor> oerjan: now that I think about it, I think it said that a random orcale attached to a turning machine was unlikely to be a more powerful computing device.
12:16:04 <roconnor> oerjan: so maybe I should withdraw my remark about creativity.
12:16:48 <Nafai> SamB: Happy birthday!
12:17:00 <SamB> Nafai: why thank you ;-)
12:17:05 <ivant> where could I have read about dividing elements of a list by its maximum (or something like that) in one pass?
12:17:07 <roconnor> well, I guess if it isn't a more powerfull computing device, then it isn't going to be more creative either?
12:17:11 <lokadin> SamB: happy birthday :-D
12:17:27 <oerjan> SamB: for real?  happy birthday!
12:17:37 <ivant> > let samB = samB + 1 in samB
12:17:38 <lambdabot>  Exception: <<loop>>
12:17:52 <kirby81> > putStrLn "Happy Birthday Sam!"
12:17:54 <lambdabot>  <IO ()>
12:17:58 <kirby81> mmm...
12:17:59 * mdmkolbe tries to find the "sing happy birthday" button on lambdabot
12:18:01 <Mr_Awesome> ivant: i think you just killed him...
12:18:10 <kirby81> no IO in Lambdabot ;)
12:18:11 <SamB> oerjan: would I lie on my facebook?
12:18:16 <kirby81> > "Happy Birthday Sam!"
12:18:18 <lambdabot>  "Happy Birthday Sam!"
12:18:19 <roconnor> ivant: http://haskell.org/haskellwiki/Circular_programming#Normalizing_vectors
12:18:21 <lambdabot> Title: Circular programming - HaskellWiki, http://tinyurl.com/23hckw
12:18:25 <oerjan> SamB: i'm sure some do :D
12:18:37 <ivant> roconnor, thanks
12:20:15 <ivant> @ty loop
12:20:17 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
12:21:07 <desegnis> Who writes things like â€œforall a b d câ€?
12:21:21 <ivant> @ty trace
12:21:23 <lambdabot> Not in scope: `trace'
12:21:40 <SamB> desegnis: you want to patch ghc to use idiomatic order?
12:22:01 <desegnis> only wondering
12:22:29 <SamB> well, it lists actors in order of first appearance apparantly ;-P
12:22:39 <desegnis> is the type signature written by a human, and the forall-clause by GHC?
12:22:46 <SamB> pretty much
12:22:58 <oerjan> > concatMap (("Happy birthday to "++).(++"! ")) ["you","you","Sam","you"]
12:22:59 <lambdabot>  "Happy birthday to you! Happy birthday to you! Happy birthday to Sam! Happy ...
12:23:28 <SamB> GHC did run type inference over the expression, but it kept the same type variable names
12:23:55 <desegnis> hm
12:24:01 <SamB> (from the ASCII point of view, anyway ;-)
12:25:06 <desegnis> alright
12:25:24 <ivant> @ty loop [a]
12:25:27 <lambdabot> Not in scope: `a'
12:25:32 <ivant> @ty loop [undefined]
12:25:33 <lambdabot> <command line>:
12:25:34 <lambdabot>     Could not find module `L':
12:29:22 <oerjan> :t loop [undefined]
12:29:24 <lambdabot> <command line>:
12:29:24 <lambdabot>     Could not find module `L':
12:29:30 <oerjan> :t loop
12:29:31 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
12:29:56 <oerjan> that's bizarre
12:30:04 <oerjan> :t [undefined]
12:30:06 <lambdabot> forall a. [a]
12:30:29 <FMota> :t undefined
12:30:31 <lambdabot> forall a. a
12:30:55 <monochrom> the list type is not an arrow type.
12:31:14 <oerjan> indeed, but the error message is still bizarre
12:31:40 <FMota> indeed
12:31:41 <monochrom> I have a theory, but unimportant.
12:31:42 <oerjan> @undefine
12:31:45 <lambdabot> Undefined.
12:31:49 <oerjan> :t loop [undefined]
12:31:51 <lambdabot> <command line>:
12:31:51 <lambdabot>     Could not find module `L':
12:32:09 <oerjan> yes?
12:32:10 <FMota> :t Arrow
12:32:12 <monochrom> @define monochrom = True
12:32:12 <lambdabot> Not in scope: data constructor `Arrow'
12:32:13 <lambdabot> Undefined.
12:32:21 <FMota> nvm
12:32:51 <oerjan> you mean @let, but that can't be the cause since the error persisted after @undefine
12:33:01 <monochrom> @let monochrom = True
12:33:03 <lambdabot> Defined.
12:33:15 <monochrom> :t loop [undefined]
12:33:17 <lambdabot> <command line>:
12:33:17 <lambdabot>     Could not find module `L':
12:33:26 <FMota> > monochrom
12:33:26 <monochrom> I have falsified my theory.
12:33:27 <lambdabot>  True
12:33:30 <oerjan> :t monochrom
12:33:31 <lambdabot> Not in scope: `monochrom'
12:33:37 <FMota> :o
12:33:45 <oerjan> the :t plugin doesn't even look at that L
12:34:00 <oerjan> which contains the lets
12:34:06 <oerjan> > L.monochrom
12:34:08 <lambdabot>  True
12:35:03 <oerjan> :t [undefined] *** undefined
12:35:05 <lambdabot> <command line>:
12:35:05 <lambdabot>     Could not find module `L':
12:35:23 <oerjan> :t [Bool] *** undefined
12:35:25 <lambdabot> Not in scope: data constructor `Bool'
12:35:34 <oerjan> er
12:35:39 <oerjan> :t [True] *** undefined
12:35:40 <lambdabot> <command line>:
12:35:41 <lambdabot>     Could not find module `L':
12:36:11 <ivant> @pl \(a,b) -> map (second (/b)) a
12:36:12 <lambdabot> uncurry (flip (map . second . flip (/)))
12:36:26 <ivant> @pl \(b,a) -> map (second (/b)) a
12:36:26 <lambdabot> uncurry (map . second . flip (/))
12:40:12 <xerox> > loop (\(x,xs) -> (xs, scanl (+) 0 (x:xs))) 1
12:40:13 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:40:48 <BobFunk> any good way to parse CDATA in haxml?
12:40:57 <ddarius> :t \x -> x
12:40:59 <BobFunk> there seem to be a constructor for it
12:40:59 <lambdabot> forall t. t -> t
12:41:39 <BobFunk> but when reading xml it seems like it's just handled as a string with the <![CDATA[ included
12:46:34 <ivant> there is a technique for summing a long list of Doubles by splitting the list into two parts (recursively) and summing the parts first, and then returning the sum of the computed subsums
12:47:04 <ivant> how do I implement it optimally (assuming I have [Double] in the beginning)?
12:47:07 <roconnor> ivant: lists :/
12:47:44 <psykotic> ivant: do you mean kahan summing?
12:47:57 <roconnor> ivant: are the numbers all positive?
12:47:59 <ivant> @go kahan summing
12:48:02 <lambdabot> http://en.wikipedia.org/wiki/Kahan_summation_algorithm
12:48:02 <lambdabot> Title: Kahan summation algorithm - Wikipedia, the free encyclopedia
12:48:02 <ivant> all positive
12:48:18 <byorgey> does that really give a speedup for summing lists of Doubles (aside from opportunities for parallelism)?
12:48:20 <xerox> ivant: how are the two lists chosen?
12:48:33 <ivant> split into equal parts
12:48:45 <ivant> (of equal length)
12:48:52 <psykotic> yeah, i don't get why you would split, unless you plan on parallellizing it
12:49:08 <byorgey> it can give speedups for integer multiplication, I think
12:49:54 <ivant> no, probably it's not kahan summing
12:50:26 <byorgey> ivant: just write a recursive method to put all the odd-index elements in one list, and all the even-index elts in another
12:50:28 <psykotic> right, i thought you were trying to reduce roundoff
12:50:58 <psykotic> byorgey, easiest way:
12:51:02 <ivant> psykotic, well, I want to minimize the summing error
12:51:19 <augustss> ivant: with the type [Double] there isn't much you can do to speed it up since the list doesn't permit random access.
12:51:54 <ivant> so, is it like O(n^2) (or O(n^3))?
12:51:55 <psykotic> > let split = partition (even . fst) . zip [0..] in split [1..]
12:52:04 <lambdabot>  ([(0,1),(2,3),(4,5),(6,7),(8,9),(10,11),(12,13),(14,15),(16,17),(18,19),(20,...
12:52:20 <psykotic> heh, forget to project away the index
12:52:41 <roconnor> let fsum [] = 0; fsum [x] = x; fsum (x:y:xs) = fsum (let (a,b) = partition ((x+y)<) xs in fsum (a++[x+y]++b) in fsum (sort [1.0,2.0.4.0,3.0])
12:52:42 <psykotic> > let split = (map snd *** map snd) . partition (even . fst) . zip [0..] in split [1..]
12:52:44 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
12:52:48 <roconnor> > let fsum [] = 0; fsum [x] = x; fsum (x:y:xs) = fsum (let (a,b) = partition ((x+y)<) xs in fsum (a++[x+y]++b) in fsum (sort [1.0,2.0.4.0,3.0])
12:52:49 <lambdabot>  Unbalanced parenthesis
12:52:50 <augustss> ivant: what is the problem you are trying to solve?
12:53:12 <augustss> minimizing the error?
12:53:14 <roconnor> let fsum [] = 0; fsum [x] = x; fsum (x:y:xs) = let (a,b) = partition ((x+y)<) xs in fsum (a++[x+y]++b) in fsum (sort [1.0,2.0.4.0,3.0])
12:53:16 <sorear> .
12:53:18 <augustss> maximizing the speed?
12:53:20 <roconnor> > let fsum [] = 0; fsum [x] = x; fsum (x:y:xs) = let (a,b) = partition ((x+y)<) xs in fsum (a++[x+y]++b) in fsum (sort [1.0,2.0.4.0,3.0])
12:53:21 <lambdabot>   add an instance declaration for (Fractional (a -> c))
12:53:22 <lambdabot>     In the expression...
12:53:31 <ivant> augustss, I have a very long list of [Doubles] of a very small magnitude. I need to compute their sum as precisely as possible
12:53:55 <sorear> floating point is just evil; I don't think we should be encouraging programmers to use it by providing Num instances
12:53:58 <augustss> What's wrong with Kahan summation?
12:54:04 <oerjan> @let bfold f [x] = x; bfold l = bfold f (pairBy f l); pairBy f (x:y:r) = f x y:pairBy f r; pairBy _ l = l
12:54:04 <lambdabot>  arity mismatch for 'bfold'
12:54:12 <ivant> nothing is, I didn't know about it
12:54:15 <oerjan> @let bfold f [x] = x; bfold f l = bfold f (pairBy f l); pairBy f (x:y:r) = f x y:pairBy f r; pairBy _ l = l
12:54:16 <augustss> ah
12:54:17 <lambdabot> Defined.
12:54:19 <ddarius> class NotNum a where ...; instance NotNum Float where ...
12:54:28 <oerjan> > bfold (+) [1..100]
12:54:30 <lambdabot>  5050
12:54:58 <roconnor> > let fsum [] = 0; fsum [x] = x; fsum (x:y:xs) = let (a,b) = partition ((x+y)<) xs in fsum (a++[x+y]++b) in fsum (sort [1.0,2.0,4.0,3.0])
12:55:00 <lambdabot>  10.0
12:55:06 <augustss> sorear: floating point is evil, but it's fast evil
12:55:08 <augustss> :)
12:55:37 <psykotic> > let split = (map snd *** map snd) . partition fst . zip (cycle False True) in split [1..]
12:55:37 <ivant> can I be sure that optimizer won't optimize away the kahan summing?
12:55:38 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
12:55:43 <oerjan> ivant: bfold should do something like what you want
12:55:46 <psykotic> > let split = (map snd *** map snd) . partition fst . zip (cycle [False True]) in split [1..]
12:55:46 <sorear> augustss: Was it fast EvilTerran *before* the microprocessor manufacturers sold out ;)
12:55:47 <lambdabot>  Couldn't match expected type `Bool -> a'
12:55:49 <psykotic> bah
12:56:02 * psykotic curses commas
12:56:08 <sorear> ivant: yes you can, if it does there is a BUG
12:56:36 <sorear> ivant: -O is intended to never ever ever change the results of your program
12:56:49 <ivant> so, is Kahan summation better than this bfold approach?
12:56:55 <ivant> sorear, even -O2?
12:57:03 <sorear> even -O2
12:57:15 <ivant> -optc-O3 -funfold....?
12:57:21 <sorear> -O2 just means "I'm willing to gamble with the chance of a huge slow program"
12:57:39 <roconnor> oh of course!
12:57:53 <sorear> GCC doesn't have the same quality standards we do, once you say -fvia-C you're on your own ;)
12:57:59 <sorear> roconnor: ?
12:58:03 <SamB> sorear: um
12:58:11 <SamB> you mean "ghc-asm is evil"
12:58:23 <roconnor> let perfectSum x = fromRational (sum (map toRational x)) in perfectSum [1.0,2.0,4.0,3.0]
12:58:28 <roconnor> > let perfectSum x = fromRational (sum (map toRational x)) in perfectSum [1.0,2.0,4.0,3.0]
12:58:30 <lambdabot>  10.0
12:58:37 <gleb>  sorear: when does -O2 really slow things down?
12:58:47 <EvilTerran> sorear, pardon?
12:58:54 <ivant> > let perfectSum x = fromRational (sum (map toRational x)) in perfectSum $ map recip [1.0,2.0,4.0,3.0]
12:58:55 <lambdabot>  2.0833333333333335
12:59:17 <sorear> EvilTerran: I fumbled and hit the TAB key while typing 'evil'
13:00:33 <roconnor> > sum $ map recip [1.0,2.0,4.0,3.0]
13:00:35 <lambdabot>  2.0833333333333335
13:01:15 <roconnor> > sum $ map (recip . fromInteger) [1..100]
13:01:16 <lambdabot>  5.187377517639621
13:01:29 <roconnor> > let perfectSum x = fromRational (sum (map toRational x)) in perfectSum  $ map (recip . fromInteger) [1..100]
13:01:31 <lambdabot>  5.187377517639621
13:01:39 <roconnor> > sum $ map (recip . fromInteger) [1..10000]
13:01:40 <lambdabot>  9.787606036044345
13:01:44 <roconnor> > let perfectSum x = fromRational (sum (map toRational x)) in perfectSum  $ map (recip . fromInteger) [1..10000]
13:01:45 <lambdabot>  9.787606036044382
13:02:38 <sorear> @tell fasta I think the problem you
13:02:38 <lambdabot> Consider it noted.
13:02:56 <sorear> argh.
13:07:41 <BobFunk> any tips on how to strip CDATA markup from txt content when transforming xml with HaXml
13:07:45 <BobFunk> ?
13:08:46 <swiert>  /msg lambdabot @messages
13:08:54 <swiert> ugh.
13:10:53 <Botje> BobFunk: what's wrong with CDATA sections?
13:11:06 <alexj> bobfunk: us the to/from haxml stuff in HAppS-Data
13:12:34 <alexj> bobfunk: HAppS.Data.Xml.HaXml
13:12:44 <FMota> Finally done with my blog post :o
13:12:58 <FMota> only took 19 hours to get it done
13:15:16 <banbh> in ghci if I :load a module is there any way to evaluate a function which it does not export?  (other than editing the source to export it)
13:15:24 <BobFunk> taking a look at that alexj :)
13:15:54 <SamB> banbh: rm the .o file
13:15:58 <alexj> bobfunk: the xml representation in HAppS-Data is a very very simplified one.
13:16:04 <SamB> then try :l again
13:16:09 <alexj> strips out all the entities too.
13:17:04 <BobFunk> hmm, the links to the documentation on the HAppS site seems broken :/
13:17:24 <alexj> bobfunk, yeah the website is in serious need of updating.
13:17:25 <banbh> SamB: but even if I rm the .o, if a function is not exported, then it will not be in scope, right?
13:17:33 <SamB> wrong!
13:17:34 <alexj> follow the link to the new code at the top of the webpage.
13:17:54 <nominolo> someone inquired at cabal-devel?
13:17:59 <SamB> of course, if the module is in a package it won't help
13:18:48 <sorear> @tell fasta I think the problem you're having with C.M.S.Strict is a documentation issue; the behavior you describe is deliberate, there is an explanation of the tradeoffs and decisions on the mailing list at the threads around http://www.haskell.org/pipermail/haskell-cafe/2007-January/021270.html
13:18:49 <lambdabot> Consider it noted.
13:19:21 <banbh> SamB: apologies.  tried it.  you are right.  thanks
13:19:37 <SamB> banbh: no need to apologize
13:19:55 <SamB> you'd no way of knowing that GHCi worked that way, except reading the documentation...
13:20:15 <banbh> SamB: fair enough!
13:20:21 <SamB> and it takes a lot of work to get to the documentation
13:20:30 <SamB> well, maybe not a whole lot
13:20:40 <SamB> but a largish number of navigation actions
13:21:40 <SamB> anyway, the "*" stands for "import everything, not just exports"
13:22:16 <EvilTerran> the *?
13:22:16 <Liskni_si> "*" typed in where?
13:22:18 <SamB> (it only works with GHCi, though)
13:22:34 <SamB> EvilTerran: you know how it says *Foo when you use :l to load a .hs file?
13:22:41 <EvilTerran> ah, yes.
13:22:50 <SamB> you can pass that to :m too
13:23:03 <EvilTerran> :m *Foo?
13:23:27 <SamB> unfortunately I haven't managed to load independant modules at the same time...
13:23:32 <monochrom> :m Foo
13:23:37 <monochrom> :m + Foo
13:23:50 <monochrom> For more information, :help module
13:24:17 <gleb> SamB: :m *Data.Maybe
13:24:17 <gleb> module 'Data.Maybe' is not interpreted
13:24:56 <EvilTerran> gleb, it needs to load the module from source to be able to export things not exported.
13:25:03 <monochrom> eh, ":help module" doesn't work.
13:25:32 <EvilTerran> in a compiled version, some unexported things may be inlined where they're used and compiled out of existence.
13:25:58 <monochrom> even some dead code is removed.
13:25:58 <gleb> EvilTerran: sounds reasonable. I just don't get what :m *Foo can be useful for
13:26:04 <EvilTerran> or other such weirdness - something could well render then inaccessible
13:26:05 <purplepenguins> yay
13:26:18 <EvilTerran> gleb, for debugging your own code, i gues
13:26:39 <purplepenguins> I just wrote my own haskell hello world
13:26:41 <banbh> so if it loads from source then it prefixes a "*" on the prompt to remind you that it's bringinging into scope unported stuff.  however if there is a .o around then you don't get this behavior
13:26:43 <sorear> simonf: Are you Simon (Vsevolod) Ilyushchenko - if so why do ask if anyone is in #haskell ?
13:27:09 <EvilTerran> purplepenguins, how many lines is it?
13:27:13 <purplepenguins> by figuring out how to do the euclidean algorithm
13:27:19 <sorear> banbh: right, GHC will load object code opaquely in preference to interpreted code
13:27:28 <sorear> @src gcd
13:27:28 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
13:27:28 <lambdabot> gcd x y = gcd' (abs x) (abs y)
13:27:28 <lambdabot>    where gcd' a 0  =  a
13:27:28 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
13:27:33 <purplepenguins> no, it's not a real hello world, but it's my first haskell thing
13:27:40 <EvilTerran> oh right, okay.
13:27:44 <purplepenguins> I used `mod`
13:28:04 <EvilTerran> they're the same for positive numbers, iirc
13:28:04 <sorear> same thing on positive numbers
13:28:06 <monochrom> not much difference
13:28:19 <purplepenguins> I didn't implement any tracking for integers vs. naturals
13:28:37 <monochrom> that's also ok. first exercise. :)
13:30:02 <mudge> hi people
13:31:02 <sorear> hello mudge :)
13:32:01 <mudge> hey sorear
13:32:33 <ryani> If I have a long-running computation that produces a stream [a], and I have a UI that I want to update every n ms with the results of the computation so far, what's the best way to do this?
13:33:09 <ryani> I tried forking the computation into another thread and using Control.Concurrent.Chan a, but performance was terrible (went from 40s to finish the computation to over 5 min)
13:34:42 <ryani> ideally i'd like an IO operation a -> IO (Maybe a) that can returns Just a if the passed in argument is evaluated and Nothing if not.
13:34:55 <Heffalump> what are you doing with the stream afterwards?
13:35:19 <Heffalump> I would have thought you could just drive the UI updates from the stream
13:35:34 <ryani> right now just "print" but I'm going to be updating a UI.  (the ICFP contest task)
13:35:42 <SamB> eh?
13:36:06 <Heffalump> is the list constructed by pure code or inside IO?
13:36:22 <sorear> ryani: feed the stream into mapM_ (writeIORef rf); then every 100ms have the UI do readIORef rf and display it
13:36:25 <ryani> with just print I do what you say and drive from the stream, but I thought it'd be neat to be able to update the UI while running
13:36:31 <sorear> ryani: that should be fast and effective
13:36:49 <SamB> sorear: I think he's got a stream of RNA
13:37:21 <SamB> ryani: did you do last year's task already?
13:37:24 <sorear> ryani: does your display process need the last computed element, or the whole computed prefix?
13:37:34 <ryani> SamB: the CMU one?
13:37:44 <SamB> @go cult bound variable
13:37:46 <lambdabot> http://www.boundvariable.org/task.shtml
13:37:46 <lambdabot> Title: ICFP Programming Contest, 2006 : Contest Materials and Task
13:37:53 <ryani> yeah, I did a bunch of work on that one
13:38:05 <SamB> it was a lot more rewarding than this one
13:38:14 <ryani> although I had to write my VM in C, sadly
13:38:27 <SamB> we mostly had to
13:38:53 <SamB> a time may be rapidly approaching when this is unneccessary
13:39:13 <SamB> I've recieved word that JHC is slimming down radically
13:39:28 <ryani> if ghc was just a bit better at handling bitwise operations, a haskell VM would be fine.
13:39:50 <SamB> it's the shifts that killed it
13:40:11 <ryani> even for this year, I had to implement Compose, Clip, & NewBitmap as FFI functions
13:40:28 <ryani> but my simulator runs about 40k iterations/sec with no FFI
13:40:29 <SamB> it doesn't seem to be able to understand that it can get a massive win by inlining the bitshifts
13:40:31 <sorear> you didn't use opengl?
13:41:00 <SamB> really, the treatment of unboxed things in the inliner needs work
13:41:02 * sorear thinks the graphics operations should be mappable to graphics hardware
13:41:34 <ryani> sorear: Possibly, but I'm just using IOUArray Int Word32.
13:41:42 <SamB> sorear: I wrote mine in C
13:41:57 <SamB> I'm not sure whether or not I had a decent graphics card at the time of the contest
13:42:23 <sorear> you don't need a decent graphics card, just a decent X server
13:42:31 <ryani> during the contest, our team of 4 wrote everything in C++, and came in the top 50.  But I wanted something to help learn how to write performant Haskell and this seemed like a good project.
13:42:46 <SamB> sorear: Mesa is really damn slow with no graphics card if you ask me
13:43:03 <sorear> did the X consortium *really* write their unaccelerated primitives so badly that an amateur can improve on them from scratch in three days?
13:43:59 <EvilTerran> wait, you thought X was *good*?!
13:44:28 <EvilTerran> don't mind me, i'm just a vicious cynic. of X as much as anything else.
13:45:01 <wli> X's big advantage is network transparency. It's not so great about much of anything else.
13:45:10 <SamB> sorear: you said OpenGL
13:45:42 <SamB> I don't think the X consortium actually implemented GL
13:45:46 <ddarius> You say that often EvilTerran.
13:46:02 <EvilTerran> what, that i'm viciously cynical?
13:46:14 <ryani> Anyways, the task description was pretty particular on the behavior of the bitmap operations, and making sure that whatever graphics lib I used did the right rounding, etc. would take more time than just writing it myself in C
13:46:52 <ddarius> EvilTerran: ANd about X too I think.  I don't remember what you were referring to last time.
13:47:26 <EvilTerran> meh. i like complaining.
13:47:40 * earthy mutters 'NeWS' under his breath
13:48:04 <EvilTerran> a while ago i set the /topic of my uni compsci channel to "Computer Science: Because all software is s***." ;)
13:48:53 <EvilTerran> this is worryingly close to my actual attitude, the difference being that has "and i think i can do better" on the end.
13:49:25 <ryani> so, is there any way to examine a thunk at runtime and find out if it's been evaluated or not?
13:50:45 <EvilTerran> if there is, it'll be in a GHC.* module. thunks are not part of the standard ;]
13:51:49 <sorear> ryani: It *can* be done.
13:53:55 <simonf> Stefan?
13:54:06 <sorear> simonf: Yes?
13:54:10 <simonf> cool
13:54:14 <sorear> simonf: /whois sorear
13:54:30 <sorear> simonf: /who *tefan*
13:55:51 <simonf> sorear: thanks - don't know all dramatis personae yet
13:56:23 <oerjan> but is it a comedy or tragedy?
13:56:46 <Heffalump> it's funnier when you fuck up and insert a space before the / so everyone knows you were whoising
13:56:49 <mudge> sorear: what projects are you working on these days?
13:57:02 <araujo> /whois Heffalump
13:57:10 <araujo> ggez
13:57:40 <sorear> mudge: I'm not going to work on any other major projects until Qhc is usable.
13:57:53 <Heffalump> how close is it?
13:57:57 <olsner> what's Qhc?
13:58:03 <araujo> sorear, Qhc?
13:58:08 <simonf> sorear: so when running ./setup register --user --inplace in the Cabal dir I'm still getting the complaint about non-existing ~/.ghc/i386-linux-6.4.2/package.conf
13:58:14 <olsner> @where qhc
13:58:14 <lambdabot> I know nothing about qhc.
13:58:16 <sorear> not at all...  the main effect of this has been to make me a nethack pro
13:58:19 <mudge> sorear: what's Qhc?
13:58:23 <mudge> a haskell compiler?
13:58:38 <SamB> sorear: webpage? logo?
13:58:41 <gwern> sorear: if you're a nehack pro - how can I change the hjkl directional keys to something not-insane?
13:58:47 <sorear> olsner, araujo, mudge: yes, my nyhc rewrite - a small fast haskell compiler
13:58:53 <SamB> darcs repo at least?
13:59:01 <araujo> wow
13:59:05 <araujo> sorear, link?
13:59:09 <sorear> gwern: O number_pad 1
13:59:26 <mudge> sorear:  rad,   so that's your current project?
13:59:29 <gwern> sorear: no, tried that. forget why it didn't work though
13:59:35 <sorear> does it really need one?  it doesn't have a parser and can only typecheck simple lambda calculus
13:59:40 <sorear> not even lets
13:59:50 <sorear> gwern: NumLock ?
14:00:11 <gwern> not even that
14:01:14 * araujo find / -name Qhc sorear_computer
14:02:20 <Heffalump> in what way is it a rewrite rather than a new compiler?
14:02:50 <sorear> Heffalump: generates Yhc Core and Yhc Bytecode
14:03:13 <sorear> well, will
14:04:08 <araujo> sorear, nothing online for us yet? :-P
14:05:08 <sorear> oh, fine.
14:05:14 <sorear> I'll put something up
14:05:26 <sorear> after I finish writing up my unsafe evil for ryani
14:05:45 <araujo> sorear, sorry, you know you just can't say the name of a haskell project here without being bothered for a link
14:05:47 <araujo> :-P
14:06:28 <ivant> yeah, so never say a name, only describe how cool it is :-)
14:06:54 <hpaste>  manu pasted "Norvig's Sudoku Solver in Haskell" at http://hpaste.org/2452
14:07:30 <araujo> ivant, ah.. actually that won't work either
14:09:58 <araujo> hola Tigge_
14:10:01 <araujo> hola tizoc
14:10:07 <araujo> ...
14:10:43 <EvilTerran> who's manu?
14:10:57 <tizoc> jaaj, hola araujo, tanto tiempo :P
14:11:21 <araujo> tizoc, :-))
14:11:39 * araujo pulls tizoc into the spanish channel
14:12:11 <EvilTerran> is there a #haskell-es?
14:12:48 * EvilTerran tries to think of something to do in Haskell & OpenGL
14:12:49 <ryani> awesome.  I love me some unsafe evil.
14:13:05 <EvilTerran> ryani, ??
14:13:56 <EvilTerran> oh, right, i see. nvm
14:14:37 <ryani> anything where I get to write code like "import Data.Array.IO.Internals" makes me happy
14:16:54 <reffie> http://helptheiraq.ytmnd.com/
14:16:55 <lambdabot> Title: YTMND - and that's why Americans can't locate the U.S.
14:17:10 <ivant> EvilTerran, oh, you know, I have an idea what I can do in Haskell & OpenGL
14:17:29 <ivant> EvilTerran, thanks for reminding me about the existence of bindings!
14:23:30 <EvilTerran> reffie, ##politics is -> over there
14:23:41 <reffie> ???
14:23:53 <EvilTerran> "2214 <reffie> http://helptheiraq.ytmnd.com/"
14:23:54 <lambdabot> Title: YTMND - and that's why Americans can't locate the U.S.
14:23:59 <reffie> did you watch it
14:24:04 <reffie> it has nothing to do ith politics
14:24:43 <EvilTerran> stereotypes about blondes and americans being stupid are closer to politics than haskell, is all
14:25:03 <reffie> feel free to ignore me
14:25:10 <EvilTerran> okay then.
14:25:26 <EvilTerran> ivant, what're you up to with bindings? i'm intrigued
14:25:43 <mudge> my gosh,   just hanging out in #debian,   it's funny there,  but they are really helpful
14:26:40 <ivant> EvilTerran, nothing extremely interesting, just an idea how to make an eyecandy for my future presentation of my thesis work
14:27:30 <ivant> EvilTerran, I'm thinking of making a nice 3d presentation of a solution of a polynomial system of inequalities
14:27:52 <EvilTerran> ah. maths. not my strong point. ;]
14:29:05 <sorear> mudge: they are?  last time I was there, they made smerdy look like shapr
14:32:01 <sorear> ryani: infoPtrType x = case unpackClosure# x of { (# ip, _, _ #) -> W# (indexWord16OffAddr# ip 2#) }
14:32:11 <gigamonkey_> How long do pastes to hpaste.org stick around?
14:32:14 <mudge> sorear: what do you mean "smerdy look like shapr" ?
14:32:17 <mudge> what do yo mean by that?
14:32:34 <sorear> ryani: http://darcs.haskell.org/ghc/includes/ClosureTypes.h
14:32:53 <Heffalump> Smerdyakov developed a reputation for being a bit aggressive, particularly to newbies, when he was here.
14:32:54 <mudge> gigamonkey: how many interviews for your book have you done?
14:33:05 <sorear> mudge: how long have you been here?  did I reference a legend you don't know yet?
14:33:13 <Heffalump> so shapr banned him
14:33:44 <simonf> sorear: After copying system package.conf to my home dir the next error I get for: ./setup register --user --inplace
14:33:52 <simonf> is ghc-pkg: cannot find libHSCabal-1.1.7.a on library path
14:33:53 <mudge> sorear:  I haven't been hear long enough,  but I will be hear long enought to be here long enought, which is my plan,    I know shapr has been with this IRC channel since like the beginning and I think he is really helpful
14:34:20 <sorear> ryani: not guaranteed to work except in GHC 6.7.20070712, and uses an internal interface created for the GHCi debugger
14:34:24 <mudge> I don't know smerdy though,  who is that guy?
14:34:36 <sorear> simonf: why did you copy the system packages.conf?
14:34:42 <mudge> Heffalump:  oh,  i see thank you
14:34:59 <simonf> See above - I was getting an error about missing  ~/.ghc/i386-linux-6.4.2/package.conf
14:35:46 <sorear> simonf: That's funny, it should be automatically created.  What are you trying to do?
14:37:04 <simonf> sorear: as Duncan recommended, run setup register --user --inplace
14:37:32 * sorear goes to his mail archive in search of context
14:38:20 <gigamonkey_> mudge: Just the one with Peter Norvig
14:38:32 <gigamonkey_> Which is the first of a few I'll do with him.
14:39:00 <sorear> simonf: ah, I see, you're trying to build cabal itself.
14:39:57 <mudge> gigamonkey: that's awesome, I read about it on your blog,   look forward to first time something is published on web or in print
14:40:13 <sorear> simonf: can't help you unfortunately for lack of knowledge
14:40:16 <sorear> @seen dcoutts
14:40:17 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 11m 39s ago.
14:40:26 <mudge> gigamonkey:  do you plan on making the coders book on the web like pcl?
14:41:04 <gigamonkey_> mudge: unfortunately no. For this kind of book it would probably cannibalize the dead-tree sales too much.
14:41:29 <gigamonkey_> I.e. we want to make you buy the book and get all 16 interviews, rather than just reading the one you really want online. ;-)
14:41:53 <mudge> gigamonkey:  okay that's cool
14:42:07 <mudge> gigamonkey: how do you know already that you want to do exactly 16 interviews?
14:42:45 <olsner> 32 would be too many? :P
14:43:05 <gigamonkey_> olsner: got it in one!
14:43:06 <SamB> uh
14:43:18 <SamB> they only had 4 bits?
14:43:35 <SamB> you can't buy much with 50 cents
14:46:30 <oerjan> > (2*let x=2 in 2-) 1
14:46:30 <lambdabot>  Parse error
14:47:07 <Mat^> my compiler translates 3 lines of code to 23 of assembly ;P
14:47:17 <Mat^> it's going to produce really slow assembly code ;>
14:48:48 <hpaste>  sfultong pasted "module import issue" at http://hpaste.org/2454
14:49:11 <oerjan> interesting - neither ghc nor hugs parse this?
14:49:41 <Botje> w 25
14:49:43 <Botje> argh :(
14:49:51 <opqdonut> lose
14:49:56 <Botje> very
14:51:27 <oerjan> oh, there is a further syntactic restriction on sections
14:52:01 <opqdonut> pray tell?
14:53:05 <oerjan> opqdonut: who, me?
14:54:19 <sfultong>  > (2*let x=2 in subtract 2) 1
14:54:48 <oerjan> nope, ill-typed
14:54:58 <sorear> gigamonkey_: Until I delete them.
14:55:06 <sfultong> lambdabot doesn't even want to respond to me
14:55:12 <sfultong> > (2*let x=2 in subtract 2) 1
14:55:13 <lambdabot>   add an instance declaration for (Num (t -> t))
14:55:13 <lambdabot>     In the expression: (2 * ...
14:55:22 <sfultong> ah, heh
14:55:25 <sfultong> silly spaces
14:55:32 <gigamonkey_> sorear: which happens when? never? every hour? something in between?
14:55:40 <oerjan> subtract is for (- ...) not (... -)
14:55:58 <sorear> gigamonkey_: When someone in #haskell tells me "hey sorear - spam at hpaste #xyzw"
14:56:00 <oerjan> anyway, "(op e) is legal if and only if (x op e) parses in the same way as (x op (e)); and similarly for (e op)."
14:56:01 <sfultong> > (2*let x=2 in flip subtract 2) 1
14:56:02 <lambdabot>   add an instance declaration for (Num (a -> a))
14:56:02 <lambdabot>     In the expression: (2 * ...
14:56:51 <gigamonkey_> But you just delete that one ... basically I'm wondering if someone pasted some code I want to look at later can I count on it being there?
14:56:58 <gigamonkey_> I guess I could have just asked that. ;-)
14:57:10 <EvilTerran> what are you trying to do, sfultong? flip subtract 2 :: Num a => a -> a, regardless of whether it's wrapped in an unrelated let
14:57:17 * gigamonkey_ remembers it's been a while since he cleaned out the spam on his comments page.
14:57:36 <sfultong> EvilTerran: just trying to make oerjan's thing work
14:58:02 <sorear> gigamonkey_: Yes; I was initially in favor of limited retention, but someone argued convincingly that we should retain pastes for the benefit of people who want to read IRC logs.
14:58:22 <oerjan> which makes sense to disallow such hard-to-parse things as that let, but also disallows things such as (0:1:) which might be useful
14:58:38 <sorear> (at the time, glguy ran hpaste, and I was arguing to him to limit retention, fwiw)
14:58:45 <oerjan> sfultong: i was just checking what were the rules for sections, anyway
14:58:49 <ddarius> Then we lost a couple thousand pastes.
14:59:00 <EvilTerran> sfultong, well, i don't understand it. it looks to me like he's trying to multiply a number by a function
14:59:26 <sorear> gigamonkey_: Oh yes, we also lose pastes in rare bug events.
14:59:30 <sfultong> EvilTerran: well, I wasn't really understanding it either, but I was trying to make it work anyway :-P
14:59:50 <gigamonkey_> sorear: okay. Thanks.
14:59:52 * ddarius liked the HaWiki solution.
14:59:59 * ddarius also liked the old QuotesPage.
15:00:29 <ddarius> hpaste is slicker though.
15:01:45 <oerjan> EvilTerran: _if_ (2*let x=2 in 2-) had been allowed, it would be a question if it was equivalent to (2*(let x=2 in 2)-) or to (\v -> 2*let x=2 in 2-v)
15:01:50 <sorear> ClassicalWiki is one of those things that almost everyone hates for some reason :(
15:02:05 <EvilTerran> ahh.
15:02:21 <ddarius> sorear: What are you talking about?
15:02:37 <EvilTerran> the first of those makes sense. the second would make sections rather... unhygenic.
15:03:02 <oerjan> the first would require extra lookahead in the parser, the second would require section versions of everything downward
15:03:03 <EvilTerran> sorear, as in WikiWikiWeb-esque CamelCaseLinks?
15:03:08 <sorear> EvilTerran: yes
15:03:15 <oerjan> if i am guessing correctly
15:04:24 <EvilTerran> the first would require either extra lookahead or backtracking to work out how to parenthesize, but the latter would significantly reshape the parse tree, and that would be _baaad_, IMO
15:04:53 <sorear> why does the new haskell wiki use MediaWiki?  MediaWikis always seem to attract many fewer contributors...
15:05:30 <EvilTerran> actually, it'd be rather nice if (EXP `op`) was like (\x -> (EXP) `op` x) rather than without the parens around the EXP
15:05:43 <EvilTerran> i don't really see how that could introduce ambiguity
15:06:45 <oerjan> EvilTerran: well reshaping the parse tree is what i would be after.  i think it would be nice if things like (0:1:), (*10+), (f . g .) and (:: Double) worked (according to the second \v -> exp op v type translation)
15:06:50 <EvilTerran> I suppose it might seem reasonable that (^2 + 1) x = (x^2 + 1), actually
15:07:21 <EvilTerran> the restriction's a good "preserve equational reasoning" kinda thing
15:07:48 <EvilTerran> and shuffling the parse tree seems like it'd be messy, and potentially ambiguous
15:08:12 <opqdonut> you mean the AST technically i guess
15:08:51 <EvilTerran> yes, i suppose i do.
15:09:08 <EvilTerran> i mean the placing of parentheses and whatnot.
15:09:25 <opqdonut> guh, should go to sleep already...
15:09:57 <oerjan> however iiuc all the compilers actually do precedence _after_ the normal parsing, there is even a haskell' proposal to make that standard.
15:10:27 <EvilTerran> i tend to think of the desugaring as (EXP ??) -> ((??) (EXP)) and (?? EXP) as (flip (??) (EXP)), so that version would make most sense to me
15:10:55 <opqdonut> yeah
15:11:00 <EvilTerran> but viewing the desugaring as (EXP ??) -> (\v -> EXP ?? v) and likewise for (?? EXP) means AST-rejigging would make more sense
15:11:38 <EvilTerran> so i guess disallowing the ambiguous case outright is a better idea, for newbie-friendliness at least
15:11:51 <oerjan> the current restriction is essentially that a section is only allowed if those two interpretations agree
15:11:53 <sciolizer> EvilTerran: could the (flip (??) (EXP)) lead to problems with higher order types? I remember having trouble trying to use ($) with SYB.
15:12:36 <EvilTerran> i have no idea. i don't quite grok higher-order types.
15:12:59 <sciolizer> EvilTerran: me neither, anytime after 6PM. :)
15:13:22 <EvilTerran> however, ($), flip, etc causing trouble seems to break the idea of equational reasoning
15:13:44 <oerjan> the translation listed uses a lambda, i see (i justed scrolled down to it)
15:13:58 <EvilTerran> (f $ x = ($) (f) (x) = id (f) (x) = (f) (x))
15:14:21 <opqdonut> and??
15:14:38 <oerjan> *just
15:15:43 <EvilTerran> opqdonut, what do you mean "and??"? equational reasoning's one of the best bits of pure functional programming
15:15:47 <sciolizer> EvilTerran: I believe that $ is a special case of id. So you can't call them equal, because ($) will unify against fewer things.
15:16:00 <EvilTerran> ?type ($)
15:16:02 <lambdabot> forall a b. (a -> b) -> a -> b
15:17:11 <oerjan> equational reasoning only applies after things typecheck
15:17:24 <EvilTerran> sciolizer, well, yes. i could've annotated id with a type there, but iwas being lazy.
15:17:38 <sciolizer> EvilTerran: ic
15:17:51 <EvilTerran> and i'm not sure how that should break higher-order types, short of a bug
15:18:31 <oerjan> well i understand it is only quite recently that runST $ do ... typechecks
15:18:35 <sciolizer> "everywhere $ mkT id" causes problems, I believe.
15:19:15 <EvilTerran> ?type runST
15:19:17 <lambdabot> Not in scope: `runST'
15:19:39 <oerjan> :t Control.Monad.ST.runST
15:19:41 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
15:20:42 <EvilTerran> Ambiguous type variable `b' in the constraint:
15:20:42 <EvilTerran>   `Typeable b' arising from use of `mkT' at <interactive>:1:12-17
15:20:42 <EvilTerran> Probable fix: add a type signature that fixes these type variable(s)
15:20:52 <oerjan> :t Control.Monad.ST.runST $ do return ()
15:20:53 <lambdabot>     Couldn't match expected type `forall s. GHC.ST.ST s a'
15:20:54 <lambdabot>            against inferred type `a1 b'
15:21:08 <EvilTerran> (from "ghci> :t everywhere (mkT id)")
15:21:10 <oerjan> lambdabot is not recent enough for it to work
15:21:15 <ddarius> The issue with ($) was lack of impredicativity
15:21:36 <EvilTerran> so it doesn't work for me *without* ($), either
15:21:48 <EvilTerran> impredicativity? i keep meaning to look that one up
15:22:31 <ddarius> impredicativity just means that if you have a type like forall a. a -> a you can instantiate it at a polymorphic type, i.e. you can say 'a' is forall b.b->b for example.
15:22:57 <ddarius> Getting (forall b.b -> b) -> (forall b.b -> b)
15:24:05 <sciolizer> :t Data.Generics.everywhere
15:24:07 <lambdabot> forall a. (Data.Generics.Basics.Data a) => (forall a1. (Data.Generics.Basics.Data a1) => a1 -> a1) -> a -> a
15:24:20 <augustss> The hack that made runST $ foo work is going away again.
15:24:29 <augustss> It's too much of a hack.
15:24:58 <sciolizer> ddarius: so the problem was that (a -> b) couldn't be reinterpreted as (forall a. a -> a) -> b -> b?
15:25:16 <sciolizer> ddarius: (in everywhere $ mkT something)
15:25:28 <sciolizer> ddarius: and is that fixed now, or is it a difficult problem?
15:25:45 <ddarius> It's not a problem, it's a decision.
15:25:57 <oerjan> augustss: :(
15:26:08 <sciolizer> ddarius: ok
15:26:36 <augustss> oerjan: If we start adding those kind of hacks to Haskell it'll turn into Perl
15:27:09 <oerjan> augustss: i didn't know it was a hack, i was assuming they had improved the typing system
15:27:24 <EvilTerran> what causes the problem, the ($)?
15:27:35 <augustss> oerjan: no, it was just using a left-to-right instantiation rule
15:27:36 <oerjan> :t ($)
15:27:38 <lambdabot> forall a b. (a -> b) -> a -> b
15:27:46 <glen_quagmire> z`> $ $ .
15:28:21 <augustss> oerjan: so it would work for $, but not if you defined it with the arguments swapped
15:28:29 <oerjan> if (a -> b) is some function requiring higher-order types, then a or b need to be instantiated impredicatively, i think
15:28:47 <oerjan> (such as runST or everywhere, i assume)
15:28:53 <augustss> oerjan: well, someone needs to figure out how to do it properly
15:29:03 <EvilTerran> is this a matter of the higher-order types implementation being incomplete, or a limitation as the system is defined on paper?
15:29:05 <augustss> I'm not sure if MLF can do it
15:29:43 <ddarius> EvilTerran: There are predicative type systems and impredicative type systems.
15:29:59 <ddarius> As I said to sciolizer, it is a decision.
15:30:06 <ddarius> However, http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#impredicative-polymorphism
15:30:08 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
15:30:55 <EvilTerran> ddarius, i wasn't sure if you meant the decision was "we don't want this hack" or "we don't want this functionality"
15:31:54 <augustss> We want the functionality, but there's research to be done to figure out how
15:32:10 <EvilTerran> okay
15:32:18 <augustss> We don't want a hack that works sometimes.
15:32:51 <EvilTerran> ah, that was the problem. the hack wasn't just ugly under-the-hood, but it was ugly to use, too?
15:33:16 <ddarius> Researchers need to start providing RSS feeds or something to their list of new publications.
15:33:16 <sorear> augustss: MLF *can* do it, Daan's paper on the subject uses it as the motivating example
15:33:42 <sorear> oleg does iirc
15:33:47 <augustss> sorear: OK.  then we just need to add all the other things that ghc has to MLF :)
15:34:26 <sorear> augustss: MLF already has qualified types; what else?
15:34:35 <augustss> GADTs
15:34:49 <sorear> yuck
15:35:02 <EvilTerran> @where MLF
15:35:02 <lambdabot> I know nothing about mlf.
15:35:05 <xorAxAx> @pl ((.)$(.))
15:35:06 <lambdabot> ((.) .)
15:35:11 <xorAxAx> @unpl ((.)$(.))
15:35:11 <lambdabot> (\ b c e f -> b c (e f))
15:35:25 <sorear> Qualified types are elegant.  MLF is elegant.  Wobbly types - no way.
15:35:30 <xorAxAx> @pl ((.) .)
15:35:30 <lambdabot> ((.) .)
15:35:33 <sorear> @go Extending ML to the power of System F
15:35:36 <lambdabot> http://gallium.inria.fr/~remy/work/mlf/icfp.pdf
15:35:42 <sorear> @go ML with qualified types
15:35:44 <lambdabot> http://citeseer.ist.psu.edu/jones94ml.html
15:35:45 <lambdabot> Title: ML typing, explicit polymorphism and qualified types (ResearchIndex)
15:35:45 <sorear> @go MLF with qualified types
15:35:47 <lambdabot> http://legacy.cs.uu.nl/daan/download/papers/qmlf.pdf
15:36:00 <augustss> sorear: GADTs are elegant.  But maybe not the wobbly types implementation
15:36:03 <sorear> EvilTerran: 1st and 3rd you need to read, 2nd is a typo
15:36:18 <sorear> augustss: Yeah, that's what I meant
15:36:47 <sorear> augustss: I'm just not a fan of writing match/as/returning/with or equivalent every 5 lines :)
15:36:50 <augustss> Haskell's type system is in need of an overhaul.  It's grown too many strange lumps
15:37:29 <sorear> augustss: Have you seen Morrow?
15:37:50 <augustss> sorear: I've not looked at it lately
15:38:07 <augustss> But it has some things I liked when I last looked
15:38:37 <mattam> What's that ?
15:39:02 <augustss> I want to see a design where the transition to dependent types is smooth.  That's where we're heading, even if it's slow.
15:39:12 <ddarius> You need to build it with GHC and have OCaml available to run it...
15:40:46 <augustss> mattam: Morrow is Daan Leijen's language based on MLF
15:42:14 <mattam> I'm seeing it now. More papers on the pile :)
15:42:22 <damg> Random.next Random.getStdGen < what am I doing wrong here?
15:42:49 <damg> ah, IO StdGen vs RandomGen?
15:44:10 * mattam doesn't highlight on impredicativity. It was just a coincidence...
15:45:41 <oerjan> :t (Random.next, getStdGen)
15:45:43 <lambdabot> forall g. (RandomGen g) => (g -> (Int, g), IO StdGen)
15:46:17 <EvilTerran> @instances RandomGen
15:46:18 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
15:46:24 <oerjan> :t liftM next getStdGen
15:46:26 <lambdabot> IO (Int, StdGen)
15:46:26 <EvilTerran> @instances-importing Random RandomGen
15:46:28 <lambdabot> StdGen
15:48:37 <oerjan> damg: right, the IO.  StdGen is an instance of RandomGen so that part is compatible.
15:50:02 <ddarius> mattam: If you want to avoid that you probably want to avoid Haskell and #haskell and Haskell-Cafe and LtU.
15:50:30 <mattam> I don't
15:50:42 <ddarius> mattam: Think about this carefully.
15:50:48 <mattam> LtU is my homepage
15:51:10 <mattam> and #haskell my preferred lurking channel.
15:51:16 <ddarius> Well then you're probably already too far gone.
15:51:25 <coffeemug> whoo hooo
15:51:37 <coffeemug> now I have full support for algebraic data types in CL :-D
15:51:41 <hpaste>  damg pasted "(no title)" at http://hpaste.org/2455
15:51:48 <coffeemug> now I need to introduce some lazyness into them
15:51:58 <coffeemug> and before I know it I'll be able to use monads :)
15:52:05 <damg> oerjan, look at this one please
15:52:10 <mattam> Yeah, and soon I'll start writing a thesis. I'm beyond rescue
15:52:11 <ddarius> You don't need ADTs or laziness to use monads.
15:52:27 <coffeemug> ddarius: yeah I know, but I want a maybe monad and a list monad
15:52:49 <ddarius> You don't really need it for the Maybe monad, for the list monad it would be useful.
15:52:56 <coffeemug> ddarius: I could do it without algebraic types still, but it's much nicer with a simple defalgebraic macro :)
15:53:14 <coffeemug> yeah, it's pretty simple to do it without ADT
15:53:22 <oerjan> damg: use x <- Random.getStdGen instead
15:53:24 <coffeemug> just define Just and Nothing
15:53:53 <coffeemug> but it's much cooler to say (defalgebraic maybe (just *) nothing)
15:53:54 <coffeemug> :)
15:54:05 <ddarius> How do you translate data T a b = Leaf a | Branch (b -> T a b) ?
15:54:06 <coffeemug> then to write the whole thing out
15:54:06 <damg> ah, damn
15:54:36 <damg> oerjan, thank you very much. i need a coffee :) dumb mistake
15:54:46 <coffeemug> I don't :)
15:54:55 <coffeemug> I don't do data T a b yet
15:55:18 <coffeemug> data types are not polymorphic
15:55:22 <coffeemug> though constructors can be :)
15:55:35 <ddarius> Okay, data T b = Leaf Int | Branch (b -> T b)
15:56:32 <coffeemug> one second, let me check what type specifiers look like for functions in lisp :)
15:56:50 <coffeemug> well
15:57:02 <coffeemug> in general it would be (defalgebraic T integer *)
15:57:15 <coffeemug> * accepts any type
15:57:26 <coffeemug> I'm not sure what a type specifier for b -> T b would look like
15:57:50 <coffeemug> I do runtime type checks when types are there
15:58:01 <coffeemug> and * matches anything
15:59:28 <jbalint> Hi
15:59:33 <purplepenguins> how would you make a function that, given a number, returns an infinite list of the positive integral powers of that number
15:59:44 <oerjan> there was a paper linked on ltu about runtime checking higher order types
15:59:48 <purplepenguins> given an Int, should say
16:00:08 <ddarius> purplepenguins: How do you think you would?
16:00:13 <coffeemug> pows n = [n ^ x| x <- [1..]]
16:00:22 <Saizan> > let foo n = iterate (*n) 1 in foo 3
16:00:24 <lambdabot>  [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,143...
16:00:38 <purplepenguins> okay
16:00:45 <purplepenguins> I was trying to do something with map and failing
16:00:58 <coffeemug> > let pows n = [n ^ x| x <- [1..]] in pows 3
16:00:59 <lambdabot>  [3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14348...
16:01:01 <Saizan> well coffeemug's solution is a map
16:01:11 <ddarius> > let p n = out where out = 1 : map (n*) out in p 3
16:01:12 <lambdabot>  [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,143...
16:01:32 <Saizan> > let pows n = map (n^) [1..] in pows 3
16:01:34 <lambdabot>  [3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14348...
16:01:39 <oerjan> > join (iterate . (*)) $ 3
16:01:41 <lambdabot>  [3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14348...
16:01:56 <purplepenguins> okay, so the <- is the same as saying that x is an element of that sex?
16:02:11 <coffeemug> means take x from that list
16:02:17 <purplepenguins> set*
16:02:22 <coffeemug> or rather, for every x from that list
16:03:20 <Saizan> purplepenguins: it's a syntactic sugar called list comprehension
16:03:49 <sfultong> what was the first language to have list comprehension/
16:03:57 <jbalint> hi, i'm trying to install a cabal package, but i'm getting this error, anybody have an idea why? (the file is there/accessible,etc) Setup.hs: error reading ./.setup-config; run "setup configure" command?
16:04:07 <Saizan> [f x| x <- list] ~= concatMap (\x -> f x) list
16:04:15 <ddarius> sfultong: I believe there were set comprehensions in some languages before there were list comprehensions.
16:04:54 <Saizan> no, i'm wrong
16:05:02 <oerjan> sfultong: wikipedia says NPL and SETL
16:05:28 <oerjan> http://en.wikipedia.org/wiki/List_comprehension#History
16:05:44 <Saizan> jbalint: you need root privileges to install a package unless you specify --user to configure
16:05:53 <oerjan> @bot
16:05:53 <lambdabot> :)
16:06:39 <jbalint> Saizan: ok.... i'm running sudo, but either way i dont see how that would cause this error
16:07:02 <Saizan> jbalint: if fact i've misread it, sorry
16:07:08 <Saizan> *in
16:07:16 * Saizan goes to slepp
16:07:23 <oerjan> @list undo
16:07:24 <lambdabot> undo provides: undo redo
16:07:33 <oerjan> @undo [f x | x <- list]
16:07:33 <lambdabot> ([f x | x <- list])
16:07:55 <ddarius> @undo do x <- list; return (f x)
16:07:55 <lambdabot> (list >>= \ x -> return (f x))
16:08:13 <sfultong> hey, can someone try to brainstorm with me on why my code isn't working? I know it's gotta be something really simple that I'm overlooking, but that doesn't help me not overlook it
16:08:21 <ddarius> @. pl undo do x <- list; return (f x)
16:08:21 <lambdabot> f `fmap` list
16:08:49 <sciolizer> @type undo
16:08:51 <lambdabot> Not in scope: `undo'
16:09:18 <oerjan> sciolizer: @. is lambdabot's command composer
16:09:21 <sciolizer> oh ok
16:09:27 <sciolizer> cool
16:10:41 <oerjan> !paste
16:10:41 <hpaste> Haskell paste bin: http://hpaste.org/
16:11:24 <oerjan> sfultong: you mean you want us to help you debug without us looking at the code?
16:11:57 <sfultong> oerjan: well, I could give you the whole code, but I think the relevant parts are on hpaste
16:12:33 <oerjan> sfultong: oh i couldn't see anything from you in the channel
16:13:03 <sfultong> I posted it a while back
16:13:51 <TSC> Could you remind us?
16:14:15 <oerjan> sfultong: er, are you using Graphics.HGL.RGB in your code, or just RGB?
16:14:24 <glen_quagmire> i could
16:14:38 <glen_quagmire> http://en.wikipedia.org/wiki/Image:Two_women_operating_ENIAC.gif TSC
16:14:39 <lambdabot> Title: Image:Two women operating ENIAC.gif - Wikipedia, the free encyclopedia
16:14:41 <glen_quagmire> ooops
16:14:45 <glen_quagmire> http://hpaste.org/2454
16:14:47 <sfultong> oerjan: I'm trying to use both Graphics.HGL.RGB and my own data constructor also called RGB
16:15:03 <sorear> jbalint: The problem is that you didn't run setup configure.
16:15:18 <oerjan> oh right...
16:15:32 <oerjan> to import a constructor you must import the type too
16:15:41 <oerjan> Type(Constructor)
16:15:48 <jbalint> sorear: of course i did
16:16:00 <sfultong> oerjan: I.E.?
16:16:32 <oerjan> import qualified Graphics.HGL (TypeName(RGB))
16:16:43 <sfultong> oh, thanks
16:17:14 <sorear> jbalint: Apologies; we have a long tradition of people not reading error messages.
16:17:33 <jbalint> sorear: ok :) i tihnk its this http://hackage.haskell.org/trac/hackage/ticket/120
16:17:35 <lambdabot> Title: #120 (misleading error message from cabal when versions differ) - Hackage - Trac
16:17:38 <sorear> jbalint: So you run ./Setup configure, then ./Setup build failed with the error?
16:17:50 <jbalint> no, install failed, build worked
16:18:07 <sorear> jbalint: Ah, I see.
16:18:28 <sfultong> oerjan++
16:18:40 <jbalint> sorry ive lacked some information in my description
16:18:43 <oerjan> @karma
16:18:44 <lambdabot> You have a karma of 1
16:18:52 <sfultong> hehe, yay
16:18:59 <sfultong> @karma
16:18:59 <lambdabot> You have a karma of 0
16:19:13 <oerjan> sfultong: i had some earlier but lambdabot got reset
16:19:35 <sfultong> oerjan: that's not fair... lambdabot should have a way to save state
16:19:53 <Runaro^BRS> is a -> b -> c exactly the same type as (a -> b) -> c ?
16:20:02 <oerjan> sfultong: it does, this was a big wipeout of some sort
16:20:20 <oerjan> something crashed badly i assume
16:20:22 <sciolizer> sfultong: it does, but lambda runs are atomic, and there's no commit implemented yet
16:20:47 <sorear> oerjan: yeah, massive power failure at UNSW iirc
16:20:56 <oerjan> Runaro^BRS: no, a -> (b -> c)
16:20:58 <sorear> whole CSE dept got zapped
16:21:14 <sfultong> so what does karma get you, anyway? are there any prizes involved? :-P
16:21:30 <Runaro^BRS> oerjan: Ok, thanks.
16:22:11 <oerjan> sfultong: you get to run over dogmas
16:23:31 <oerjan> i suppose you might get reborn as a Simon, or something
16:23:45 <sfultong> sweet!
16:24:00 <sfultong> but sadly,  Module `Graphics.HGL' does not export `TypeName(RGB)'
16:24:24 <oerjan> er, TypeName was to be replaced by the actual type name
16:24:34 <sfultong> oh, heh
16:25:18 <sfultong> ok, so it's the same syntax as module exports... like you can do TypeName(..)
16:25:46 <sciolizer> sfultong: do you mean Graphics.HGL.Draw.Text?
16:26:01 <sciolizer> sfultong: (don't know if that would make a difference)
16:26:22 <sfultong> sciolizer: nope, I've got it fixed now, thanks-
16:26:28 <sciolizer> sfultong: ok
16:26:53 <sfultong> now I get to deal with hopefully less-retarded errors
16:31:51 <sfultong> I wish GHC's "parse error on input" message could be made more verbose
16:38:48 <dcoutts> @seen dons
16:38:48 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 16h 46m 17s ago.
16:39:01 <shapr> Has anyone tried OpenBIOS on amd64?
16:39:33 <sfultong> shapr: have you tried OpenBIOS on any arch?
16:39:46 * sfultong 's curious about OpenBIOS
16:39:55 <shapr> sfultong: No, but I've read that it's much faster and saner than any other bios.
16:40:29 <xorAxAx> @seen xorAxAx
16:40:29 <lambdabot> You are in #haskell. I last heard you speak just now.
16:40:35 <shapr> @seen me
16:40:36 <lambdabot> I haven't seen me.
16:40:38 <shapr> @seen lambdabot
16:40:38 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #ghc and #darcs
16:44:44 <sfultong> @seen God
16:44:44 <lambdabot> I haven't seen God.
16:44:57 <sfultong> @seen the light
16:44:57 <lambdabot> I haven't seen the.
16:45:20 <sfultong> hmmm... lambdabot's on unicycling?
16:46:54 <sorear> augustss: GADTs can be encoded in System FÏ‰, so if a typelambda extension of MLF could be found, GADTs would follow naturally
16:47:50 <EvilTerran> sfultong, i imagine duncan had something to do with that
16:48:15 <sorear> augustss: also, I've given up on my quest for rank-2 types in djinn, since there exists a natural encoding of Prolog in the rank-2 inhabitation problem: forall <ATOMS>. (forall VARS. CLAUSE) -> (forall VARS. CLAUSE) -> ... -> GOAL
16:48:23 <dcoutts> EvilTerran: sfultong: actually that's probably shapr's fault :-)
16:48:35 <sorear> augustss: Prolog is turing complete, ergo rank-2 inhabitation is undecidable
16:48:51 <dons> morning all.
16:48:51 <sorear> augustss: +predicative
16:49:06 <dons> ?users
16:49:06 <lambdabot> Maximum users seen in #haskell: 390, currently: 364 (93.3%), active: 11 (3.0%)
16:49:10 <sorear> morning!
16:49:13 <dcoutts> hia dons
16:49:43 <dcoutts> dons: turns out our bytestring sort causes segfaults, probably because it writes out of bounds and messes up memory management structures
16:50:02 <dons> dcoutts: oh my.
16:50:07 <dons> strict sort? the bucket sort?
16:50:10 <dcoutts> dons: yep
16:50:16 <dons> sjanssen! ;)
16:50:30 <dons> did you get a bug report?
16:50:39 <dcoutts> I've not tracked down exactly where it's going wrong, but it's defiantly wrong
16:50:45 <dcoutts> dons: no, the testsuite
16:50:52 <dons> oh, cool.
16:50:53 <EvilTerran> dcoutts, oh, hi. sorry if i beeped you.
16:50:55 <sjanssen> hmm
16:50:55 <dcoutts> it segfaults on the sort test
16:51:11 <dons> it doesn't get used very often, so maybe that's why we didn't notice it
16:51:13 <sjanssen> dcoutts: where is this code?
16:51:19 <dcoutts> and it's easily reproducible in ghci if you run the same sort enough times
16:51:24 * dons is busy now though. removalists on their way.
16:51:25 <dons> bbl
16:51:25 <dcoutts> sjanssen: in bytestring-0.9
16:51:44 <dcoutts> sjanssen: darcs get darcs.haskell.org/bytestring/
16:52:44 <sjanssen> dcoutts: and which test is failing?
16:52:47 <dcoutts> sjanssen: eg take a bs like (P.pack [95..105]) replicate it 10 times and map sort it
16:54:09 <dcoutts> sjanssen: map P.sort (replicate 10 (P.pack [95..105]))
16:54:45 <dcoutts> sjanssen: note that it often only segfaults after returning to the ghci prompt, so it's probably segfaulting during GC
16:54:57 <dcoutts> so it's probably memory corruption
16:55:10 <dcoutts> we're almost certainly indexing out of bounds
16:55:47 <sjanssen> I'm not seeing any segfaults with base-2.1
16:56:31 <sorear> found it
16:56:33 <dcoutts> sjanssen: is that ghc-6.6 or 6.6.1 ?
16:56:38 <sjanssen> 6.6.1
16:56:56 <sorear> dcoutts: sort allocates 256 bytes and then procedes to use it as an array of 256 size_t
16:57:11 <dcoutts> sorear: ah yes :-)
16:57:19 <sorear> dcoutts: this will only fail if the array is near the end of a block... ;)
16:57:26 <sjanssen> the version in base-2.1 is correct
16:57:38 <sjanssen> sort (PS input s l) = unsafeCreate l $ \p -> allocaBytes 256 $ \arr -> do
16:57:39 <dcoutts> perhaps I broke it :-)
16:57:46 <sorear> sjanssen: that's wrong
16:57:50 <sjanssen> sort (PS input s l) = unsafeCreate l $ \p -> allocaArray 256 $ \arr -> do
16:58:03 <dcoutts> sjanssen: ah, yes allocaBytes vs allocaArray
16:58:11 <sjanssen> sorear: right, the first is in bytestring, the second is in base
16:58:12 <dcoutts> sjanssen: so allocaArray is in base 2.1 ?
16:58:19 <FMota> good evening
16:58:20 <dcoutts> right, so I did break it
16:59:14 * Igloo gets out the Giant Foam Finger Of Blame
16:59:27 <dcoutts> heh, darcs changes
16:59:35 * dcoutts bets he broke it accidentally
17:00:07 <dcoutts> @hoogle allocaArray
17:00:11 <lambdabot> Foreign.Marshal.Array.allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
17:00:11 <lambdabot> Foreign.Marshal.Array.allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
17:00:36 <sorear> also, why are we using alloca* at all?  it just uses the same MutableByteArray# foo as newArray/unsafeWrite
17:00:59 <sorear> not that that would be much prettier/safer... nvm
17:00:59 <sjanssen> dcoutts: yep, "* Use the (re|m)allocBytes rather than (re|m)allocArray functions" :)
17:01:21 <sjanssen> sorear: we use Ptrs there to take advantage of memset
17:02:54 <sorear> sjanssen: fair enough.
17:03:05 <Igloo> How is that code meant to infer that it is an array of CSize's?
17:03:06 * sorear would have hoped there was fast clearing for IOUArrays
17:03:32 <sorear> Igloo: a well hidden :: and HM lambda monomorphism
17:03:42 <Igloo> Ah, a later memset will do it, I think
17:03:52 <sjanssen> Igloo: it's a Ptr Int
17:04:05 <sjanssen> hmm, maybe not
17:04:11 <Igloo> sorear: The :: CSize in the memset won't do it
17:04:27 <FMota> So. I'm just going to tell you all what I've been working on, because of all the strange half-relevant questions I've been asking lately. And I think this is the right "audience" for this sort of thing (theoretical language syntax / type system, that is) anyway. Here: http://odi-sei-a.blogspot.com/2007/08/lowdown-on-sei.html
17:04:28 <lambdabot> Title: odiseia: The lowdown on sei.
17:04:28 <Igloo> It could benefit from an explicit type sig anyway, even though it is inferable
17:05:08 <FMota> Dont take it as shameless self-plugging -- i'm not actually selling anything.
17:06:27 <dcoutts> Igloo: could you do another run with bytestring-0.9 when I push this change, I think the only expected failure is the lines "\n\n" one which I'm sure we can fix in time... :-)
17:06:40 * dcoutts runs make prop-compiled
17:07:30 <Igloo> dcoutts: I'm about to go to bed; I can probably try tomorrow
17:07:34 <dcoutts> Igloo: ta
17:08:25 <EvilTerran> FMota, that looks interesting. i've been thinking about types-as-values and vice-versa recently, myself
17:08:29 <sorear> FMota: You seem to have mostly re-invented functional logic programming; all you're missing now is logic variables.  You might want to look at something like Mercury (never used it, but supposedly it's a modern functional logic language)
17:08:34 <EvilTerran> which is a bit relevant
17:08:40 <dcoutts> Igloo: it would be good to get bytestring-0.9 in, bugs we can fix later, but we do have some api changes that would otherwise have to wait for ages
17:08:47 <FMota> Thank you.
17:10:09 <sorear> FMota: Getting to the dependent types part - it looks pretty neat.
17:10:16 <Igloo> dcoutts: Sure
17:10:34 <sorear> FMota: But why is index vnil 0 erroneous?  It looks to me like it is a valid expression that evaluates to the empty set
17:10:49 <FMota> sec
17:11:27 <FMota> index isn't allowed to return an empty set unless you explicitly allow it to (by putting ? at the end of the type)
17:12:20 <FMota> dependent types is a consequence of making types-as-values
17:12:55 <FMota> the tricky part would be to implement the => operator
17:16:27 <FMota> mercury's an actual logic programming language...
17:16:34 <FMota> I don't see the connection :/
17:16:38 <Runaro^BRS> :type foldl foldl
17:16:45 <Runaro^BRS> !type foldl foldl
17:16:54 <Runaro^BRS> bah
17:16:59 <sjanssen> @type foldl
17:17:03 <dons> shapr: reminds me of #haskell 5 years ago, http://www.postneo.com/2007/08/26/there-is-an-erlang-community-its-just-smaller-than-youre-used-to
17:17:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:17:07 <lambdabot> Title: There is an Erlang community, it&#8217;s just smaller than you&#8217;re used to  ..., http://tinyurl.com/yqevvf
17:17:15 <FMota> oof. I have to go. ttyl :/
17:17:38 <Runaro^BRS> @type foldl foldl
17:17:39 <lambdabot>     Couldn't match expected type `b -> [b]' against inferred type `[b]'
17:17:40 <lambdabot>     In the first argument of `foldl', namely `foldl'
17:18:03 <Runaro^BRS> I'm not sure I understand where it's expecting b -> [b].
17:18:35 <shapr> dons: Yeh, I agree.
17:19:18 <shapr> dons: That post looks like it's ripped off of five years ago anti-rant posts on haskell-cafe or something.
17:22:29 <oerjan> Runaro^BRS: lessee, foldl foldl x [y] = foldl foldl (foldl x y) []
17:23:25 <oerjan> er...
17:23:31 <oerjan> @src foldl
17:23:31 <lambdabot> foldl f z xs = lgo z xs
17:23:31 <lambdabot>     where lgo z []     =  z
17:23:31 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:24:45 <oerjan> this means x and foldl x y have the same type
17:25:22 * EvilTerran smells an infinite type
17:25:52 <EvilTerran> x = a -> x, methinks
17:26:13 <Runaro^BRS> So...  x -> y -> x can't also be [y] -> x because x can't be y -> x.
17:26:45 <Runaro^BRS> Wow, I understood that while writing it.
17:26:53 <Runaro^BRS> ... but not anymore!
17:27:08 <oerjan> mixing notation for values and types is not recommended
17:27:30 * shapr grumbles at code
17:28:20 <Runaro^BRS> sorry, I switched to x y in foldl foldl because a b is taken in foldl.
17:28:22 <Runaro^BRS> :-)
17:29:09 <oerjan> next, x [z] has the same type as foldl x y [z]
17:30:03 <dhpeterson> dons: are you about? i have a couple of q's on your irc bot (tutbot)
17:30:16 <oerjan> which has the same type as x y z
17:30:30 <oerjan> actually == x y z
17:31:07 <dhpeterson> :t liftIO
17:31:10 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
17:31:53 <oerjan> if we set y = [z], then x [z] has the same type as x [z] [z], which is impossible
17:32:58 <oerjan> bah, too late for my brain
17:33:57 <Runaro^BRS> oerjan: I get why it's impossible. foldl foldl requires the type a to also be (b -> a).
17:34:27 <Runaro^BRS> But "expected type `b -> [b]' against inferred type `[b]'" is cryptic to me.
17:35:24 <Runaro^BRS> Bah. not important. I'll just read it as "hey, idiot, that makes no sense".
17:35:44 <EvilTerran> Runaro^BRS, the "expected type" of an expression is the type it must have, based on its surroundings and context
17:35:53 <EvilTerran> its "inferred type" is the type it actually has
17:36:09 <Saizan> Runaro^BRS: because it requires a to be both [b] and b -> a at the same time, and the latter is thus b -> [b]
17:36:27 <Runaro^BRS> ah!
17:36:39 <EvilTerran> if the inferred type is the same as, or a generalisation of, the expected type, all is good with the world
17:36:46 <Runaro^BRS> That's it. Thanks, Saizan.
17:37:01 <EvilTerran> otherwise, EXPLODEY!
17:38:49 <Runaro^BRS> That would unravel the very fabric of the space-time continuum and destroy the entire universe!
17:39:22 <Runaro^BRS> ... or you just pass out.
17:39:29 <EvilTerran> as far as your program can tell, either and both at once.
17:55:34 <blakkino> there is a way to have UArray for custom data-types?
17:55:49 <sorear> yes.
17:55:53 <blakkino> i'm trying to implement the IArray interface but have no idea how to implements bounds
17:55:59 <blakkino> :)
17:56:06 <blakkino> how? some links about that?
17:57:07 <sorear> you'll have to implement it in roughly the same way as the standard UArray does it, though you can cheat and use UArray rather than ByteArray#
17:57:11 <Mr_Awesome> sorear: your name is an enigma
17:57:26 <dhpeterson> ?seen dons
17:57:26 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 40m 23s ago.
17:57:44 <sorear> Mr_Awesome: /whois sorear    Once you see my real name, the derivation of my nick should be obvious
17:58:16 <Mr_Awesome> i almost wish i hadnt seen that... ;)
17:58:26 <Mr_Awesome> it was so much more fun when i didnt know
17:59:34 <sorear> blakkino: there is a better way on the horizon, though, with associated data types; it does remain to be seen whether the arrays lib will use them
18:17:15 <blakkino> sorear, i can't find it.. in http://darcs.haskell.org/ghc-6.6/packages/base/Data/Array/Base.hs there are some instance declarations but they seem to use internal stuff
18:18:17 <dons> dhpeterson: ?
18:19:33 <dhpeterson> dons: hi
18:19:50 <dhpeterson> dons: i am newb'ing out here with your tutbot demo
18:20:04 <dhpeterson> can i ask some dumb q's?
18:20:34 <dons> sure.
18:20:37 <dhpeterson> basically i'm an experienced imperative programmer trying to get a handle of FP and haskell in particular :)
18:20:45 <dhpeterson> ok .. 1st qn
18:21:01 <dhpeterson> io :: IO a -> Net a
18:21:01 <dhpeterson> io = liftIO
18:21:18 <dons> right, so that lifts an IO action into the Net monad
18:21:19 <dhpeterson> i worked thru the posting so i see how this gets rid of having to pass "h"
18:21:21 <dhpeterson> yes
18:21:33 * shapr grumbles more at code
18:21:36 <dons> yeah, we put the handle in the state monad
18:21:38 <dhpeterson> i want to understand what "lift" means
18:21:47 <dons> here is just changes the type, basically
18:21:50 <dhpeterson> i have come across lots of lift functions
18:21:50 <dhpeterson> ok
18:22:01 <dons> if you see the monad stack as IO on the bottom, and Net as a wrapper above
18:22:04 <dhpeterson> ok
18:22:12 <dhpeterson> a bit like class heirarchies in imperative programming?
18:22:15 <dons> then 'io' raises an action in IO into the Net monad above, it `lifts' it.
18:22:24 <dons> sort of. more like security layers perhaps?
18:22:28 <dhpeterson> ok
18:22:44 <dhpeterson> ok 2nd qn
18:23:02 <dhpeterson> i am trying to get my head around the algebraic types in haskell
18:23:15 <dhpeterson> but i am confused between "type" and "data" (and "class" and "instance" also)
18:23:17 <dhpeterson> and what to use where
18:23:17 <dons> ok.
18:23:20 <dhpeterson> so in your example
18:23:24 <sm> "An experimental breakout game in haskell+SDL".. written by me.. awesome. I had no recollection of this
18:23:31 <dhpeterson> type Net = ReaderT Bot IO
18:23:31 <dhpeterson> data Bot = Bot { socket :: Handle, starttime :: ClockTime }
18:23:43 <dhpeterson> Bot is an algebraic type yes?
18:23:43 <dons> ok, so 'type' is just a synonym
18:23:47 <dhpeterson> ok
18:23:49 <dons> it just gives a name to a more complex type
18:23:57 <dons> 'data' declares a new type, yep.
18:24:07 <dons> in this case, one with just 1 constructor, and 2 fields
18:24:19 <dons> ?src String
18:24:19 <lambdabot> type String = [Char]
18:24:20 <dhpeterson> so ReaderT is the constructor
18:24:24 * sm seeks other haskell SDL experiments
18:24:34 <chessguy> so Bot :: Handle -> ClockTime -> Bot
18:25:00 <chessguy> and socket :: Bot -> Handle and starttime :: Bot -> ClockTime
18:25:09 <dons> Bot is the constructor introduced here. it is a function that builds values of type `Bot' -- we use the convention of having the constructor and type names the same for Bot
18:25:16 <dhpeterson> what is the meaning of the "{" and "}" in the data declaration
18:25:19 <dhpeterson> ok
18:25:29 <jinjing> @bot
18:25:29 <lambdabot> :)
18:25:30 <dons> that introduces a named record syntax
18:25:42 <dons> rather than, say,  data B = B Handle ClockTime
18:25:49 <dhpeterson> ok
18:25:54 <dons> you can name individual fields, data C = C { foo :: Int, bar :: Char }
18:26:05 <dons> like a C structure, sort of
18:26:06 <dhpeterson> and the benefit of named record fields is .. ?
18:26:26 <dons> you can extract the field using the name
18:26:33 <dons> so,   foo x -- extracts field x
18:26:36 <dhpeterson> ok
18:26:38 <dhpeterson> :)
18:26:39 <dons> field 'foo' from 'x' i mean
18:26:41 <dhpeterson> last q'n
18:26:42 <dhpeterson> yep
18:26:46 <dons> like x.foo in other langs
18:26:49 <sorear> sm: that's nothing, bos can't remember writing the first version of Data.ByteString :)
18:26:53 <dhpeterson> i added my first function:
18:27:05 <dhpeterson> cputime :: Net String
18:27:06 <dhpeterson> cputime = do
18:27:06 <dhpeterson>     now  <- io getCPUTime
18:27:06 <dhpeterson>     return . show $ now
18:27:16 <dons> ok.
18:27:16 <dhpeterson> i remember reading that return does nothing to change the value
18:27:24 <dhpeterson> so is it possible to simplify the function
18:27:37 <dons> it wraps a value in a monadic container, basically. so your string becomes a Net String
18:27:41 <dhpeterson> yes
18:27:42 <EvilTerran> @src liftM
18:27:42 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:27:54 <sorear> cputime = show `fmap` io getCPUTime
18:27:56 <dons> return (show now) -- would also be ok
18:28:04 <dhpeterson> ok
18:28:21 <EvilTerran> cputime = liftM show $ io getCPUTime
18:28:26 <EvilTerran> or that. same thing.
18:28:42 <dhpeterson> yes that was what i was thinking .. something of that form
18:28:46 <dhpeterson> (liftM ...)
18:28:49 <sorear> now why can't fmap be called (.) ? :)
18:29:07 <EvilTerran> or show <$> io getCPUTime, if you're using Applicative
18:29:14 <Eelis> historical accident. but that doesn't stop me from defining (.) as fmap for all my programs :)
18:29:23 <dhpeterson> dons: what functions would you suggest i try to port next - for learning purposes
18:29:35 <dhpeterson> (i.e. from lambdabot to tutbot)
18:29:41 <dons> hmm. something that updates the state of the tutbot?
18:29:48 <dhpeterson> so i need to change ReaderT to?
18:29:49 <dhpeterson> StateT?
18:29:54 <dons> perhaps add a new field to the state, then add an operation to add and remove values from the state
18:29:55 <dhpeterson> and add some state
18:29:57 <dons> yeah
18:29:59 <dhpeterson> (extra state)
18:30:00 <dhpeterson> ok
18:30:05 <dons> StateT, then add say, a list of names or something
18:30:07 <dhpeterson> so maybe "botName" or something
18:30:09 <dons> ?where haskell
18:30:10 <lambdabot> http://haskell.org/
18:30:11 <dhpeterson> ok
18:30:13 <dons> yeah, botname would be ok.
18:30:18 <dons> more fun would be a Map String String
18:30:25 <dons> so you could add a lookup table, like the @where plugin
18:30:28 <dhpeterson> ok
18:30:32 <dons> to get and set key/values
18:30:34 <dhpeterson> i'll have a look at that
18:30:35 <dhpeterson> yep
18:30:41 <dhpeterson> thanks very much for your help
18:30:45 <dons> sure!
18:30:47 <dhpeterson> your blog / tute is very useful!
18:30:53 <dhpeterson> looking forward to the book
18:30:55 <dhpeterson> :)
18:31:00 <dons> cool. yes, the irc bot is quite a nice little tutorial
18:31:07 <dons> :)
18:31:10 <dhpeterson> (i hope the irc bot makes it into the book!0
18:31:23 <dons> there should be some network stuff, anyway
18:31:55 <dhpeterson> once you have done the basic haskell stuff e.g. in the Simon Thomson book - where do you go to learn more about the monadic stuff?
18:32:09 <dhpeterson> it kind of stops before "liftM" and all that jazz
18:32:11 <ray> looking forward to making it the second book in my new haskell book collection
18:32:44 <ray> maybe third, depending on who stocks my local bookstores
18:33:00 <dons> dhpeterson: yeah, that's the missing link. getting from beginner to real world programming
18:33:05 <dhpeterson> yep
18:33:08 <dhpeterson> i noticed :)
18:33:14 <dhpeterson> heh
18:33:28 <dhpeterson> it's a big leap from factorial to liftIO ;)
18:33:31 <dons> and using monads is the basic way to structure and control larger programs, so needs to be written about
18:33:37 <dhpeterson> agree
18:33:42 <dons> yeah
18:33:58 <dhpeterson> it's quite humbling to feel like a complete newb in a new language again :)
18:34:09 <dons> heh. lots of fun stuff to learn :)
18:34:12 <dhpeterson> yep!
18:34:43 <thoughtpolice> dhpeterson: I wrote a small tutorial on using the writer monad, but there was a good blog post a while back that really explained how the do-notation and whatnot worked,
18:34:51 <thoughtpolice> I can find the link if you'd like
18:34:58 <dhpeterson> dons: i gather you are finishing up your phd (congrats!) - can i ask how many ppl are still with chak's research group at UNSW?
18:35:10 <dhpeterson> thoughtpolice: that would be great thnx
18:35:25 <dhpeterson> it seems to be the hot-spot for FP research in .au
18:35:57 <dons> dhpeterson: there's about hmm, 8 of us or so
18:36:16 <dons> some undergrads coming up, 2 phds left. and 4 researchers
18:36:19 <dhpeterson> ok
18:36:20 <chessguy> @type Endo . flip ?f
18:36:21 <thoughtpolice> dhpeterson: here's the link, I read it after I wrote a little basic stuff and it explained it really well imo:
18:36:22 <lambdabot> forall a c. (?f::c -> a -> c) => a -> Endo c
18:36:25 <thoughtpolice> http://scienceblogs.com/goodmath/2007/01/haskell_a_first_step_into_mona_1.php
18:36:26 <dons> actually more than that. there's 4 or so undergrads
18:36:27 <lambdabot> Title: Good Math, Bad Math : Haskell: A First Step Into Monads, http://tinyurl.com/2bdder
18:36:31 <dhpeterson> thoughtpolice: ta!
18:36:37 <thoughtpolice> np.
18:36:58 <dons> hey thoughtpolice
18:36:58 <dhpeterson> any phd's working on the data parallel haskell stuff?
18:37:05 <chessguy> @type Dual .Endo . flip ?f
18:37:07 <lambdabot> forall a c. (?f::c -> a -> c) => a -> Dual (Endo c)
18:37:20 <dons> dhpeterson: yeah. we've got sean lee doing data parallel haskell for the gpu
18:37:26 <dhpeterson> cool
18:37:34 <dons> he's got some kick butt nvidia cards running zipWith in parallel fashion :)
18:37:38 <dhpeterson> heh
18:37:50 <dhpeterson> does it involve lots of mangling with the ghc code-gen backend?
18:37:53 <dons> hey, cool, transactional memory in hardware, http://www.theregister.com/2007/08/21/sun_transactional_memory_rock/
18:37:55 <lambdabot> http://tinyurl.com/3xx469
18:37:57 <dons> dhpeterson: a little
18:38:04 <judahj>   
18:38:09 <dons> basically you hack ghc to spit out cuda code, as well as haskell
18:38:14 <thoughtpolice> dhpeterson: also, I think you'll find monads are a bit easier to grasp and 'get' once you've experimented with ones like State or Writer (writer is kind of what clinched it for me, so I wrote a tut on it :))
18:38:15 <dhpeterson> k\
18:38:22 <dons> then link the normal haskell objects with nvidia ncc compiled gpu code
18:38:31 <dons> then to hack some array stuff you make an ffi call to the gpu
18:38:34 <dhpeterson> thoughtpolice: cool - goodness knows i need to grasp them soon! ;)
18:38:38 <dhpeterson> right
18:38:41 <dhpeterson> heh clever
18:38:53 <dhpeterson> to use the FFI
18:39:04 <Tac-Tics> thoughtpolice: I agree. As a beginner haskeller, I didn't understand what a monad was until I just started seeing examples of how they were used
18:39:06 <dons> yeah, makes it a lot easier
18:39:10 <SamB> dons: yeah, I just found out that GeForce 8 can run sequential code
18:39:22 <SamB> 96-core FTW
18:39:25 <thoughtpolice> Tac-Tics: :)
18:39:31 <SamB> now I want to know what the CPU is for
18:39:42 <dons> SamB: yeah, it just copies data back and forth from the gpu :)
18:40:00 <dhpeterson> dons: are there any FP user-group style meetups happening in Sydney ?
18:40:04 <dons> you can buy 8 card gpu servers now too, from nvidia
18:40:05 <thoughtpolice> I was going to experiment with nvidia's CUDA stuff but I don't have an nvidia card :( (onboard crap)
18:40:07 <dons> its pretty crazy stuff.
18:40:13 <dons> dhpeterson: yeah, there's the SAPLING group
18:40:16 <dons> meets twice a year
18:40:19 <dhpeterson> i have become quite involved in the ruby meetup down here in melb and it's great
18:40:22 <dhpeterson> cool
18:40:28 <dhpeterson> looking for something similar for FP
18:40:37 <SamB> whoohoo
18:40:38 <dhpeterson> (either here on in Syd, as I get around a bit)
18:40:43 <SamB> > 8*96
18:40:43 <dons> 1http://www.comp.mq.edu.au/~asloane/pmwiki.php/SAPLING/HomePage
18:40:44 <lambdabot> Title: &nbsp; : SAPLING - Home Page browse
18:40:45 <lambdabot>  768
18:40:47 <dhpeterson> ta
18:40:52 <SamB> 768 core FTW!!!
18:40:58 <dons> next meeting is in canberra
18:41:02 <dons> in nov, iirc
18:41:34 <SamB> nvidia is going to give intel a run for their money
18:41:43 <SamB> is that why intel is boning up on graphics now?
18:41:43 <dhpeterson> down here there is a monthly ruby meetup that pulls 50+ attendees and is very valuable
18:41:57 <dhpeterson> i wonder whether we couldn't get something similar happening for FP - haskell, erlang etc
18:42:09 <dons> yeah, i think it is doable
18:42:16 <dons> a user group, rather than the more academic-style sapling thing
18:42:24 <dhpeterson> i think you would be surprised at the number of "post-imperative" programmers becoming interested in fp
18:42:28 <dhpeterson> yep
18:42:31 <dhpeterson> like your book
18:42:32 <desp> hm
18:42:34 <SamB> (is that why AMD bought ATi?)
18:42:37 <dhpeterson> building practical systems with fp
18:42:41 <dhpeterson> in erl, hask etc
18:43:00 <lokadin_> like the end of  the end
18:43:07 <dhpeterson> i might email bernie pope at MU and see what he thinks
18:43:28 <dhpeterson> the prob is there would be lots of newbs and few experienced haskellers
18:43:36 <dhpeterson> (newbs like me btw!)
18:43:49 * thoughtpolice wishes he had a local-user-group for anything near by :(
18:43:49 <lokadin_> mortals! :P
18:43:57 <dhpeterson> i noticed there is a London HUG that looks to be doing well
18:44:02 <dhpeterson> thoughtpolice: :)
18:44:06 <SamB> we need a rent-an-SPJ service
18:44:09 <dons> dhpeterson: yeah, i think there surely would be enough in melbourne for a grouup
18:44:10 <dhpeterson> simon pj did the first talk
18:44:13 <dhpeterson> surely
18:44:21 <dons> esp. if was a general FP group, erlang, haskell, ocaml etc.
18:44:27 <dhpeterson> that was my thinking
18:44:35 <dhpeterson> and you get good "cross pollenation" :)
18:44:38 <dons> yeah
18:44:43 <SamB> the lispers can come to on the word of a shrink?
18:44:48 <thoughtpolice> FPUG!
18:44:49 <SamB> s/to/too/
18:44:52 <dhpeterson> dons: maybe we should have it tonight and fly you down before you leave the country! lol
18:45:02 <TSC> There are quite a few Mercury people at Melbourne Uni too
18:45:02 <dons> heh
18:45:12 <SamB> dhpeterson: hahaha
18:45:13 <dhpeterson> TSC: yes that's right
18:45:26 <SamB> you can't meet on such short notice
18:45:33 <dhpeterson> wanna bet?
18:45:36 <dhpeterson> half the attendees are in chan!
18:45:48 <SamB> how many are idling?
18:45:57 <dhpeterson> :)
18:46:05 <dons> yeah, i'm a bit busy though, waiting on removalists right now in fact.
18:46:14 <dons> sitting in an empty room with boxes and wifi :)
18:46:14 <dhpeterson> dons: lol i'll bet
18:46:15 <SamB> romovalists?
18:46:17 <Pseudonym> I disagree that there are "quite a few Mercury people".
18:46:22 <SamB> er. removalists?
18:46:28 <dhpeterson> TSC: you melb based?
18:46:31 <dons> Pseudonym: heh
18:46:37 <TSC> Yeah, Monash
18:46:41 <dhpeterson> aha
18:46:42 <Pseudonym> All the good ones have jumped ship.
18:46:45 <Pseudonym> Ah, well.
18:46:58 <Pseudonym> Perhaps we should make a SIGFP, perhaps under the umbrella of LUV.
18:47:03 <TSC> Maybe it's just the Melbourne people who I happen to meet (:
18:47:03 <dhpeterson> TSC: would you be interested in a melb FP group?
18:47:03 <SamB> Pseudonym: jumped which ship?
18:47:17 <TSC> I think I would, yes
18:47:22 <dhpeterson> heh ok that's 2 of us so far!
18:47:35 <Pseudonym> SamB: Almost all of the Mercury team are gone.
18:47:41 <SamB> gone where
18:47:44 <SamB> to other languages?
18:47:47 <TSC> I hear Mission Critical is poaching them
18:47:48 <dons> I bet Pseudonym would be into it too, dhpeterson
18:47:48 <Pseudonym> All sorts of places.
18:47:49 <SamB> to other cities?
18:48:00 <Pseudonym> Yeah, probably would, if the time was convenient.
18:48:04 <dons> well, Fergus went off to Galois, and now Google, iirc?
18:48:08 <Pseudonym> Yeah.
18:48:09 <dhpeterson> Pseudonym are you also melb ?
18:48:11 <SamB> both?
18:48:12 <dons> is bernie still at MSR?
18:48:12 <Pseudonym> Yup.
18:48:18 * Pseudonym is at RMIT
18:48:20 <dhpeterson> ok
18:49:08 <Pseudonym> The sadest case of a Mercury team member, though, is Tyson.
18:49:21 <dhpeterson> lol i know tyson :)
18:49:26 <dhpeterson> yes went to the dark side he did
18:49:29 <Pseudonym> He did.
18:49:32 <Pseudonym> He used to look like this:
18:49:41 * ddarius remembers this.
18:49:46 <Pseudonym> http://files.list.co.uk/images/2006/festival/billbailey-.jpg
18:50:10 <Pseudonym> He now looks like this:
18:50:12 <Pseudonym> http://radio.weblogs.com/0124955/images/2003/11/13/Tyson%20Dowd.jpg
18:50:14 <lambdabot> http://tinyurl.com/3ar2a2
18:50:20 <Pseudonym> That's really, really sad.
18:50:39 <dons> heh
18:50:55 <dons> what does he do now?
18:51:04 <dhpeterson> there was some overlap between mercury group and .NET right?
18:51:06 <Pseudonym> Developer evangelist at Microsoft.
18:51:09 <dons> ah
18:51:12 <dhpeterson> i don't know the full story
18:51:13 <Pseudonym> shpeterson: That's what killed it.
18:51:20 <dhpeterson> right
18:51:35 <dhpeterson> what was the idea - to get mercury to target the MS CLR?
18:51:47 <dhpeterson> and then the m$ cash flows in?
18:51:50 <Pseudonym> The idea was to get Microsoft money to help fund the project.
18:51:55 <dhpeterson> heh
18:51:58 <dhpeterson> i see
18:52:03 <Pseudonym> By targeting CLR, yes.
18:52:12 <Pseudonym> The effect was that it killed the research imperative.
18:52:21 <dhpeterson> and do i gather that certain of the researchers didn't like this direction too much?
18:52:24 <dons> ah, not hungry enough?
18:52:28 <Pseudonym> Correct.
18:52:28 <SamB> the research functional as well?
18:52:28 <sorear> but... Haskell is funded by Microsoft too?
18:52:34 <dhpeterson> :)
18:52:42 <Pseudonym> sorear: There's a difference between MSR and MS.
18:52:55 <dhpeterson> yes - and not very well understood by many (incl. me) i think
18:52:58 <Pseudonym> If they had opened a MSR campus in Melbourne, that would be different.
18:53:10 <dhpeterson> i was surprised to see simon pj to be running ubuntu in his recent OSCON demo
18:53:12 <dhpeterson> :)
18:53:20 <dons> Kai Engelhardt here has on his web page, "Overfunded research is like heroin:
18:53:20 <dons> It makes one addicted, weakens the mind and furthers prostitution."
18:53:21 <dhpeterson> clearly MSR is very independent
18:53:25 <SamB> xmonad is kinda lame on Windows
18:54:08 <dons> SamB: you've tried it?
18:54:25 * Pseudonym runs xmonad under QEmu
18:54:29 <SamB> it's an assumptian based on the fact that X is lamer on Windows
18:54:30 <Pseudonym> Which isn't nearly as lame
18:54:37 <dons> Pseudonym: cool.
18:54:48 <dons> screenshots or details would be nice for the xmonad faq.
18:55:06 <Pseudonym> Well it wasn't hard.
18:55:11 <ray> i bet xmonad would be great on windows
18:55:14 <Pseudonym> Install Linux under QEmu, compile xmonad. :-)
18:55:18 <Pseudonym> But I can show it running in a Window.
18:55:26 <dons> yeah, that might be a cute screenshot
18:55:43 <dons> i like to give people ideas for interesting uses of xmonad, on the web page
18:55:44 <SamB> I tried it under Xephyr
18:55:52 <ray> ah, i wish i had my craptop with me now
18:55:53 <dons> so there's some things like the OLPC machine, and such like
18:55:57 <SamB> it, um, did seem to work
18:56:42 <ray> it would be *really* cool if i could get native windows programs inside it, but that might be a bit harder
18:56:43 <Pseudonym> I can only imagine what running an emulated KDE would be like.
18:56:47 <Pseudonym> I wouldn't have any cycles left.
18:56:47 <SamB> though it seemed to have some issues, possibly caused by something having messed up the outer X server's keyboard config...
18:57:06 <SamB> ray: they'd not be native anymore
18:57:07 <Pseudonym> Dynamic translation helps a lot, mind you.
18:57:21 <SamB> I hear vmware is a good deal faster
18:57:36 <Pseudonym> Probably the thing that's faster with vmware is I/O.
18:57:47 <SamB> could be!
18:58:02 <Pseudonym> If you're just burning cycles, I'd suspect that QEmu is similarly quick.
18:58:25 <SamB> eh?
18:58:34 <Pseudonym> If you're just using the CPU.
18:58:39 <Pseudonym> e.g. compiling
18:58:39 <SamB> why?
18:58:53 <Pseudonym> Like vmware, QEmu runs native code as native code.
18:59:07 <SamB> yes, but not the same native code
18:59:17 <Pseudonym> If it's the same CPU, it's the same code.
18:59:19 <Pseudonym> Modulo I/O.
18:59:27 <SamB> maybe with kqemu
18:59:35 <Pseudonym> Yeah, did I fail to mention that?
18:59:38 <SamB> yes!
18:59:41 <Pseudonym> kqemu rocks.
18:59:49 <SamB> I probably should get that going again
18:59:55 <SamB> to boot ReactOS faster
19:04:55 <sorear> @go kqemu
19:04:57 <lambdabot> http://fabrice.bellard.free.fr/qemu/kqemu-doc.html
19:04:57 <lambdabot> Title: QEMU
19:05:24 * shapr hacks
19:06:00 <shapr> dons: xmonad on the Nokia 770 would be nifty.
19:07:00 <dons> mmm.
19:07:23 <dons> i'm planning to get a nice hackable nokia soon, so that might be fun to try
19:07:48 <araujo> mm..
19:07:52 <araujo> dons, which one?
19:09:04 * shapr hacks faster
19:09:24 <shapr> I like the Nokia Internet Tablets, but I think I'll get an OpenMoko next.
19:09:52 <Pseudonym> I like a phone that makes phone calls.
19:09:58 <thoughtpolice> I had plan 9 inside qemu with kqemu on my fedora box a while back. kqemu makes an awesome difference.
19:11:57 <araujo> shapr, yeah!
19:12:08 <araujo> shapr, openmoko looks nice
19:12:09 <dons> Pseudonym: in the smh today, `Poll: Are you sick of polls?'
19:12:22 <araujo> i think it'd be easy to get haskell stuff running there
19:15:59 <shapr> araujo: jhc would be nice on OpenMoko.
19:16:08 <araujo> shapr, yay!
19:16:09 <ddarius> -on- OpenMoko?
19:16:11 <shapr> JohnMeacham_: How close is JHC to general usage?
19:16:20 <araujo> shapr, openmoko is already available for developers right?
19:16:25 <shapr> ddarius: It'd be nice to run JHC generated C on OpenMoko :-)
19:16:38 <shapr> araujo: Yes, though I don't know if debian has a buildbox yet ;-)
19:16:48 <araujo> hah
19:18:04 <thoughtpolice> the trolltech phone would be an interesting target too
19:18:20 <thoughtpolice> only it's like, what, $600 or something?
19:18:26 <thoughtpolice> (last time I checked, anyway)
19:18:33 <Pseudonym> dons: :-)
19:18:44 <Pseudonym> dons: Let's hope that's not a phone-in poll.
19:18:49 <araujo> thoughtpolice, i have not heard of it
19:18:51 <Pseudonym> Talk about a self-selecting sample.
19:20:03 <thoughtpolice> araujo: http://trolltech.com/products/qtopia/greenphone
19:20:05 <lambdabot> Title: Qtopia Greenphone &mdash; Trolltech
19:20:33 <shapr> From what I've read, OpenMoko is more 'open' than the Greenphone.
19:21:30 <araujo> interesting
19:21:33 <araujo> well...
19:21:37 <dhpeterson> ?users
19:21:38 <lambdabot> Maximum users seen in #haskell: 390, currently: 365 (93.6%), active: 10 (2.7%)
19:21:45 <araujo> openmoko is intended to be as easy hackable as possible
19:22:35 <araujo> hell, they even sell a version with screwdriver for you to open it
19:23:24 <SamB> does it have an "I'm to stupid to purchase a screwdriver" paint job?
19:23:43 <dhpeterson> hey dons: where is the ?users command implemented in lambdabot?
19:25:02 <dhpeterson> Seen.hs
19:25:05 <dhpeterson> :)
19:25:14 <dhpeterson> found it
19:25:41 <shapr> SamB: Why would it have that?
19:26:40 <conal> @go openmoko
19:26:41 <araujo> thoughtpolice, that GP is already on sale?
19:26:42 <lambdabot> http://www.openmoko.org/
19:26:42 <lambdabot> Title: Openmoko.org Portal Site
19:27:15 <SamB> well, it was claimed to be a different version of the phone ;-P
19:27:37 <mdmkolbe> I'm not sure where to best ask this.  Has anyone seen algorithms for parsers where the current position in the stream can go both forwards and backwards?  (I don't mean back-tracking, I mean that there are "anti-literals" that cause the stream to go backwards instead of the usual advance by one.)
19:29:24 <Cale> I've seen a bit of that somewhere, but not a really good application.
19:30:05 <Cale> It's easy to do with the usual "function from strings to lists of pairs of strings and things" representation.
19:30:16 <Cale> That is, if I know what it is that you mean...
19:30:33 <samreid> mdmkolbe: You could implement that atop Parsec using GenParser [tok] tok (or is it GenParser tok [tok]?).  But... if you're walking through stuff you've already parsed, something immoral is happening
19:30:49 <shapr> heh
19:30:49 <mdmkolbe> Cale: I do not mean parsers that can push things back onto the front of the current position
19:30:57 <araujo> that GP is kind of expensive too
19:31:16 <mdmkolbe> Cale: I mean something more like an "unpeek" (i.e. push back whatever was there befor we pulled it off
19:31:22 <Cale> mdmkolbe: Oh, you mean holding on to the already parsed portion, and consuming that?
19:31:30 <Cale> oh
19:31:34 <Cale> okay
19:31:49 <JohnMeacham_> shapr: not sure, depends on your idea of general.
19:31:57 <shapr> JohnMeacham_: How close is jhc to self-hosting?
19:32:08 <JohnMeacham_> shapr; but that is a major push of my latest developments.
19:32:23 <JohnMeacham_> shapr: not very, it isn't a very important goal to me.
19:32:38 <shapr> JohnMeacham_: I guess general use means to me: 'handles haskell98'.
19:32:42 <JohnMeacham_> shapr: I mean, other than generally making it better and able to compile bigger programs.
19:33:04 <ddarius> Maybe JHC will run much better when compiled with JHC!
19:33:19 <mdmkolbe> I've been playing around with languages (such as this one) that more than context free and less than context sensitive (which is NP-complete), so finding related work would be usefull.
19:33:29 <shapr> JohnMeacham_: When will gc/region be added?
19:33:31 <mdmkolbe> samreid: I don't understand what you mean
19:33:58 <shapr> JohnMeacham_: And when will the new chages be available? :-)
19:34:06 <sorear> I don't think perfect compile time memory analysis is doable
19:34:14 <shapr> sorear: Why not?
19:34:48 <shapr> It seems doable if we limit the input to strongly normalizing languages, yeah?
19:35:03 <sorear> shapr: Because the halting problem can be reduced to accurate liveness computation in a GR language like Haskell.
19:35:24 <samreid> mdmkolbe: Parsec lets you keep a state variable with your parser, and you can use it to store the part of the stream you've already parsed, with a parser of type GenParserT tok [tok] a.
19:35:25 <SamB> it's true
19:35:25 <sorear> JEC might be able to do it, but it'll be slower than an intepreter probably.
19:35:32 <shapr> Also, region allocation in turing complete languages ends up with some amount of gc anyway.
19:35:55 <sorear> shapr: right, and John calls "no gc at all" a feature last I checked. :)
19:35:56 <samreid> mdmkolbe: but you'll need to put atop anything that walks forward something that pushes the parsed tokens onto the backwards looking list.
19:36:07 <shapr> Yeah, I think it'll require some gc anyway.
19:36:42 <JohnMeacham_> shapr: I mean, it is always being developed. I think when people start using it then it is ready. I don't think tehre will be an obvious turnover point.
19:37:02 <shapr> Yeah, that's a good point.
19:37:08 <JohnMeacham_> sorear: but that is in general why GC is impossible. that doesn't make it unuseful.
19:37:16 <mdmkolbe> samreid: I think I see.  Would such a thing be polynomial?  (I know it's possible with dynamic programming, but would that solution on parsec blow up exponentially?)
19:37:24 <sorear> How long until it's feasable to compile GHC with it? :)
19:37:25 <JohnMeacham_> sorear: those arguments don't apply particularly to compile time analysis.
19:38:14 <samreid> mdmkolbe: polynomial in what?  Parsing a single token still takes O(1) time and space, anyway.
19:38:41 <Pseudonym> GC isn't impossible, it's just conservative.
19:39:00 <Pseudonym> But that's true of most compilery things.
19:39:19 <Pseudonym> There's an obvious correct way to manage memory: Don't try to collect garbage.
19:39:32 <JohnMeacham_> indeed. as is region inference.
19:39:42 <Pseudonym> But sometimes you can conservatively discover that things are garbage.
19:39:58 <sorear> I suppose the question boils down to "Once you have a region manager that can recycle memory, will it still be any faster than a GC?"
19:40:02 <Pseudonym> Similarly, there's an obvious correct way to compile code: Don't try to change it.
19:40:07 <SamB> things that you weren't able to predict at compiletime because you couldn't look ahead
19:40:13 <Pseudonym> Any optimisations that you can discover must be conservative with respect to that.
19:40:21 <mdmkolbe> samreid: polynomial in the length of the string being parsed.  "S -> a S | (backwards a) S" has an infinite number of parses (representable as a cyclic graph and possible to parse in polynomial time) which I think would break if you tried to use Parsec on it.
19:40:40 <JohnMeacham_> well, region inference can reclaim things GCs can't. since they don't determine whether any references dynamically exist, but rather references will ever be dereferenced again.
19:40:43 <SamB> sorear: I think so, yes
19:41:39 <SamB> sorear: you wouldn't need to run the "GC" so often
19:41:51 <samreid> mdmkolbe: not that Parsec is the right tool for the job or anything... :-/
19:42:39 <dhpeterson> :t asks
19:42:45 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
19:45:33 <Nucleo> If I have a list l = map f [1..],  and I ask for l !! 1000000, do all the preceding elements also get calculated?
19:46:09 <EvilTerran> no, but the list cells will all be generated and freed
19:46:35 <Nucleo> EvilTerran: ahh, thanks.
19:50:01 <idnar> > map (+2) [1..] !! 1000000
19:50:04 <lambdabot>  Exception: stack overflow
19:50:39 <Nucleo> hm, that's no good
19:51:14 <Cale> > [1..] !! 1000000
19:51:15 <samreid> > map (2^) [10000,9999..1] !! 9999
19:51:17 <lambdabot>  Exception: stack overflow
19:51:18 <lambdabot>  2
19:52:21 <Nucleo> I'm not sure I understand why this would generate stack overflows
19:52:24 <Cale> [1..] !! 1000000 doesn't compute the elements of the list as it walks down
19:52:43 <Cale> and when it gets to the millionth one, it suddenly has a gigantic expression to evaluate
19:53:09 <Cale> (a tree which is a million nodes deep)
19:54:14 <Nucleo> if the elements of the list are indeed independent of one another, no previous elements need to be evaluated, right?
19:54:20 <Cale> right
19:54:29 <Nucleo> as long as the list hasn't been defined with corecursion or somesuch...
19:54:55 <Cale> > repeat 1 !! 1000000
19:54:56 <lambdabot>  1
19:55:05 <Nucleo> so what's needed is a strict version of !! ?
19:55:21 <Cale> One which forces the elements of the list as it goes along
19:55:34 <EvilTerran> @src (!!)
19:55:35 <lambdabot> xs     !! n | n < 0 = undefined
19:55:35 <lambdabot> []     !! _         = undefined
19:55:35 <lambdabot> (x:_)  !! 0         = x
19:55:35 <lambdabot> (_:xs) !! n         = xs !! (n-1)
19:56:09 <idnar> why doesn't the repeat version overflow?
19:56:27 <Cale> because it isn't building up a large expression
19:56:42 <EvilTerran> you effectively get the expression case as of (_:bs) -> case bs of (_:cs) -> case cs of ...
19:56:52 <EvilTerran> @src repeat
19:56:52 <lambdabot> repeat x = xs where xs = x : xs
19:56:53 <Cale> [1..] is really something like [1,1+1,1+1+1,1+1+1+1,...]
19:57:01 <idnar> Cale: ah, right
19:57:26 <EvilTerran> repeat only builds a single list node, it's just it's own tail
19:57:33 <EvilTerran> > [1,1..] !! 1000000
19:57:36 <lambdabot>  Exception: stack overflow
19:57:37 <Cale> you'd change that last line to  (x:xs) !! n = x `seq` xs !! (n-1) to strictify it
19:58:13 <Cale> Heh, that's [1,1+0,1+0+0,...]
19:58:24 <Nucleo> I think that answers my question then! A strict version of !! should do it.
19:58:47 <Cale> Nucleo: watch out for the answer to your original question though
19:58:54 <EvilTerran> > head . drop 1000000 $ [1..]
19:58:56 <lambdabot>  Exception: stack overflow
19:58:57 <dhpeterson> :t asks
19:58:59 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
19:59:01 <dhpeterson> :i asks
19:59:11 <dhpeterson> does anyone know where "asks" is defined?
19:59:14 <Cale> You don't want to apply the map first anymore, because then you'll have to evaluate f a million times
19:59:14 <dhpeterson> )
19:59:35 <Cale> dhpeterson: Control.Monad.Reader (.Class)
19:59:40 <dhpeterson> Cale: thanks
19:59:51 <dhpeterson> ahh in the .Class :)
20:00:03 <jbalint> what exactly does seq do?
20:00:33 <EvilTerran> @src seq
20:00:33 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:00:37 <Cale> jbalint: seq x y, when evaluated will ensure that x is evaluated before the result of evaluating y is returned
20:00:47 <samreid> > let { [] !!! _ = undefined ; (x:_) !!! 0 = x ; (x:xs) !!! n = x `seq` xs !!! (n-1) } in [1..] !!! 1000000
20:00:49 <lambdabot>  1000001
20:01:09 <Cale> In practical terms, this generally means that x is evaluated before y.
20:01:10 <jbalint> oh, thats it? the docs are kind of confusing, says it returns "bottom", but wasnt sure what the context was or how it determinted it
20:01:36 <Cale> seq undefined y = undefined
20:01:38 <EvilTerran> ... *ahem*. as I understand it, seq x y determines evaluates x until the outermost constructor is known before starting to evaluate y
20:01:46 <Cale> seq x y = y, otherwise
20:01:52 <EvilTerran> (delete "determines")
20:01:55 <jbalint> ok
20:02:04 <Cale> EvilTerran: that's not *quite* true, but it's true enough
20:02:07 <EvilTerran> > seq (undefined:undefined) 0
20:02:09 <lambdabot>  0
20:02:41 <Cale> Yeah, when I say "evaluated", I mean "to weak head normal form"
20:02:44 <EvilTerran> Cale, what's not quite true about it?
20:02:58 <EvilTerran> i thought WHNF == outermost constructor known
20:03:07 <Cale> EvilTerran: It could evaluate y first, then x, and only then result in y.
20:03:26 <Cale> (and this would comply with the standard)
20:03:47 <EvilTerran> by "evaluate y", do you mean take that to WHNF as well?
20:03:50 <Cale> yes
20:04:46 <Nucleo> does GHC -O strict-ify !! the way I'm told it does for things like maximum and sum?
20:04:54 <Cale> (But the implementations tend not to do that)
20:06:18 <Cale> Nucleo: not in a way which would help this case, as far as I can tell
20:06:22 <EvilTerran> Cale, given that y is going to be evaluated to at least WHNF, if not further, i figured my way made more sense. otherwise the choice of when to evaluate x in amoungst evaluating y might seem a little... arbitrary.
20:06:50 <Nucleo> Cale: ahh, okay
20:07:00 <SamB> EvilTerran: it is a bit arbitrary ;-P
20:07:13 <Cale> EvilTerran: The point is that the evaluation order is actually arbitrary -- seq x y doesn't *really* say that x is evaluated before y.
20:07:17 <idnar> @unpl \ (y, z) -> y + z
20:07:17 <lambdabot> \ (y, z) -> y + z
20:07:21 <idnar> @pl \ (y, z) -> y + z
20:07:21 <lambdabot> uncurry (+)
20:07:31 <Nucleo> @src enumFromTo
20:07:31 <lambdabot> Source not found. You speak an infinite deal of nothing
20:08:07 <Cale> EvilTerran: So for instance, it's not specified which error message   seq (error "A") (error "B")  will give.
20:08:26 <EvilTerran> hm. yes, i think i see.
20:08:31 <Cale> (though you can usually pretty safely bet on A)
20:09:53 <Cale> The standard doesn't say anything at all about evaluation order. It only talks about the semantics (and errors are all treated as bottom)
20:12:58 <thoughtpolice> whoopee. :)
20:13:11 <thoughtpolice> my latest foray in the ghc api:
20:13:12 <thoughtpolice> http://programming.reddit.com/info/2izu4/comments
20:13:13 <lambdabot> Title: Haskell for pluggable apps, with the GHC API (reddit.com)
20:13:51 <dhpeterson> cool
20:14:01 <dhpeterson> i'm stuck with the irc bot again :(
20:14:14 <thoughtpolice> dhpeterson: don't worry, i'm working on my own and i'm kind of stuck on it too.
20:14:16 <dhpeterson> trying to change ReaderT to StateT
20:14:28 <dhpeterson> so i can add some state
20:14:40 <thoughtpolice> mine is adopting the hot-swappable principles from the yi paper, which *work*
20:14:48 <dhpeterson> cool
20:14:56 <dhpeterson> do you understand the catch function?
20:15:03 <thoughtpolice> but the bot is threaded, so I need a good way to communicate inbetween threads and take other threads down when a reboot command is issued
20:15:06 <dhpeterson> loop st    = catch (runReaderT run st) (const $ return ())
20:15:14 <thoughtpolice> @type catch
20:15:16 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
20:15:34 <dhpeterson> have u seen dons tutbot code?
20:15:46 <dhpeterson> he uses a ReaderT for the Bot
20:15:48 <thoughtpolice> dhpeterson: yes, it was the inspiration for my bot :)
20:15:52 <dhpeterson> aha
20:16:07 <dhpeterson> i changed it to:
20:16:08 <dhpeterson> type Net = StateT Bot IO  -- DHP
20:16:15 * bos grumbles at gcc printing "undefined symbol" warnings when invoked by ghc
20:16:22 <dhpeterson> and i changed all instances of "asks" to "gets"
20:16:26 <thoughtpolice> dhpeterson: hpaste your code.
20:16:31 <dhpeterson> how do i do that?
20:16:32 <dhpeterson> :)
20:16:36 <thoughtpolice> http://hpaste.org :)
20:16:38 <dhpeterson> k
20:16:39 <dhpeterson> ta
20:17:13 <idnar> @src (|||)
20:17:13 <lambdabot> Source not found. Do you think like you type?
20:17:46 <hpaste>  dhpeterson pasted "StateT irc pain" at http://hpaste.org/2456
20:17:53 <dhpeterson> heh cool
20:18:00 <dhpeterson> i just pasted the top bit
20:18:13 <dhpeterson> i don't know how to change the catch line to work with stateT
20:18:19 <thoughtpolice> annotate it right quick with the full code
20:18:24 <dhpeterson> bot.hs:51:40:
20:18:24 <dhpeterson>     Couldn't match expected type `Bot'
20:18:24 <dhpeterson>            against inferred type `Handle -> ClockTime -> Bot'
20:18:24 <dhpeterson>       Expected type: Exception -> IO ((), Bot)
20:18:25 <dhpeterson>       Inferred type: Exception -> IO ((), Handle -> ClockTime -> Bot)
20:18:27 <dhpeterson>     In the second argument of `catch', namely
20:18:29 <dhpeterson>         `(const $ (return ((), Bot)))'
20:18:31 <dhpeterson>     In the expression:
20:18:33 <dhpeterson>         catch (runStateT run st) (const $ (return ((), Bot)))
20:18:39 <dhpeterson> sorry what do you mean by that?
20:18:55 <thoughtpolice> dhpeterson: go to this link: http://hpaste.org/2456
20:18:58 <dhpeterson> ok
20:19:01 <thoughtpolice> click 'annotate' at the top and paste the full code
20:19:05 <dhpeterson> ok
20:19:26 <hpaste>  (anonymous) annotated "StateT irc pain" with "(no title)" at http://hpaste.org/2456#a1
20:20:00 <thoughtpolice> you probably just need to change that runStateT to a execStateT
20:20:07 <dhpeterson> ahh :)
20:20:13 <thoughtpolice> let me try, however
20:20:16 <dhpeterson> ok
20:20:58 <thoughtpolice> ah no wait, it's because of the const. hold on.
20:22:02 <FMotAFK> oof. Trying to define the Primes type in Sei. Not easy. :/
20:22:08 <FMotAFK> Probably would be easier in Haskell
20:23:35 <sorear> bos: Are you using the FFI?
20:23:55 <bos> sorear: yep.
20:24:04 <thoughtpolice> dhpeterson: ah, fixed it
20:24:16 <dhpeterson> can u paste your change
20:24:16 <bos> sorear: hsc file compiles happily, but hs file that imports it is the one that pukes.
20:24:16 <dhpeterson> :)
20:24:17 <thoughtpolice> my bad, you needed evalStateT rather than run/execStateT
20:24:19 <idnar> @pl \x -> [x]
20:24:19 <thoughtpolice> dhpeterson: sure
20:24:19 <lambdabot> return
20:24:50 <EvilTerran> idnar, also known as (:[])
20:24:58 <sorear> bos: are you using the correct include files, as in foreign import ccall "math.h sin" sin :: CDouble -> CDouble ?
20:25:23 <bos> no, looks like whoever wrote the module didn't use the ffi right.
20:25:31 <hpaste>  thoughtpolice annotated "StateT irc pain" with "changed runStateT to evalStateT for fix" at http://hpaste.org/2456#a2
20:26:01 <thoughtpolice> dhpeterson: there. :)
20:26:02 <idnar> @l \[x] -> x
20:26:03 <lambdabot> Maybe you meant: learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban . pl v
20:26:05 <idnar> @pl \[x] -> x
20:26:05 <lambdabot> (line 1, column 2):
20:26:05 <lambdabot> unexpected "["
20:26:05 <lambdabot> expecting pattern
20:26:07 <dhpeterson> thnx
20:26:11 <dhpeterson> can you walk me thru: catch (evalStateT run st) (\_ -> return ())
20:26:26 <dhpeterson> how do i know whether to use evalStateT or the others?
20:26:34 <dhpeterson> man .. overload ;)
20:26:35 <thoughtpolice> the types.
20:26:41 <dhpeterson> ok
20:26:42 <thoughtpolice> @type execStateT
20:26:42 <idnar> eh, what am I doing wrong there?
20:26:50 <sorear> dhpeterson: which result do you want?  The actual result, the final state, or both
20:26:50 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
20:26:54 <thoughtpolice> @type evalStateT
20:26:56 <sorear> idnar: you're using pl
20:26:56 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
20:26:56 <bos> sorear: there's a lot of use of 'foreign import "wrapper"' for no obvious reason
20:27:09 <thoughtpolice> dhpeterson: for example, the bot is of type "StateT Bot IO ()"
20:27:15 <idnar> oh, hmm
20:27:18 <idnar> I think I need sleep ;)
20:27:21 <dhpeterson> yep
20:27:24 <thoughtpolice> using execStateT, you get back the state that results from the computation as you can see in the type
20:27:26 <sorear> idnar: @pl doesn't handle Haskell
20:27:32 <lokadin_> haskell could be considered the begining of salvation
20:27:33 <thoughtpolice> but with evalStateT, you get back the resulting 'action' which in this case,
20:27:35 <thoughtpolice> it would be ()
20:27:38 <idnar> sorear: right
20:27:39 <dhpeterson> ok
20:27:46 <dhpeterson> ->m s versus -> m a
20:27:49 <thoughtpolice> dhpeterson: and runStateT is just a combonation of the two
20:27:52 <thoughtpolice> @type runStateT
20:27:54 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
20:27:58 <thoughtpolice> see? :)
20:28:04 <dhpeterson> thoughtpolice: beginning to :)
20:28:15 <sorear> bos: uhm what do you mean unobvious uses of "wrapper"
20:28:16 <sorear> ?
20:28:25 <thoughtpolice> you won't see different functions like this for say, ReaderT
20:28:28 <dhpeterson> how do you find these matching types .. do you use ghci, or just read the haskell library html?
20:28:36 <thoughtpolice> because readerT just couples an immutable environment
20:28:37 <sorear> bos: it's a magic name, not actually a C function
20:28:42 <sorear> @docs Control.Monad.State
20:28:42 <dhpeterson> ok
20:28:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
20:28:43 <thoughtpolice> so the only important thing returned is really the action,
20:28:49 <bos> sorear: yeah, but there's no obvious reason to be using it
20:28:55 <thoughtpolice> dhpeterson: what sorear said :)
20:28:58 <bos> "wrapper" is for exporting haskell names to C, right?
20:28:59 <dhpeterson> yep
20:29:12 <dhpeterson> okay ... i need time to digest all this ... thanks so much for your help guys :)
20:29:13 <sorear> bos: haskell *closures*
20:29:26 <sorear> bos: trivial closures can use plain foreign export
20:29:26 <thoughtpolice> dhpeterson: np.
20:29:34 <thoughtpolice> just play around the bot and you can probably get some progress made :)
20:29:37 <dhpeterson> yep
20:29:39 <dhpeterson> that's the plan
20:29:52 <dhpeterson> as i was saying before to dons, it's a big jump from factorial to liftM :)
20:29:54 <jbauman> idnar, head; also tail
20:29:56 <sorear> ask for help frequently
20:30:07 <dhpeterson> heh - well i'm doing that :) thnx
20:30:59 * idnar tries to figure out arrows
20:31:05 <thoughtpolice> damn. i ran hscolour like,
20:31:12 <thoughtpolice> at least 35 times in the process of writing my blog post
20:31:29 <ddarius> thoughtpolice: Were you the one I referred to "A Concurrent Windowing System"?
20:31:42 <thoughtpolice> ddarius: quite. I have it on here but I've been busy reading books for school
20:32:22 <thoughtpolice> ddarius: I did get through probably half of it though, good read. :)
20:33:46 <thoughtpolice> hah.
20:33:59 <thoughtpolice> my code to load plugins using the GHC API is actually 20 lines shorter than the hs-plugins version. :)
20:34:25 <thoughtpolice> I'd say it's a bit more nasty, though.
20:34:38 <bos> wow, subtle.  i can use foreign import ccall unsafe "foo.h foo" foo, but that stops ghc from doing cross-module inlining.
20:34:55 <sorear> it shouldn't
20:34:59 <bos> so if i want ghc to do cross-module inlining, i have to add "include: foo.h" to the cabal file.
20:35:11 <sorear> really?
20:35:21 <bos> yeah, that's what the ghc manual says.
20:35:38 <bos> "include: foo.h" becomes "-#include \"foo.h\"" on the ghc command line.
20:35:44 <gvdm_other> -O2 might make it inline again....
20:36:02 <sorear> bos: just checking, do you know what unsafe means?
20:36:05 <bos> no, the issue is that it doesn't record the header file it included in the .hi file.
20:37:02 <bos> sorear: unsafe means calls that won't call back into haskell
20:38:09 <sorear> unfortunately, that's no longer the whole definition.
20:38:13 <bos> there's also some weird overloading to do with threds.
20:38:17 <bos> er, threads.
20:38:37 <sorear> yeah, you must not declare a blocking or long-running function 'unsafe'.
20:39:15 <sorear> -package X11 has a foreign import ccall unsafe "unistd.h select" select :: ....
20:39:37 <sorear> the anonymous author of that package gets a lot of ridicule in #xmonad
20:40:49 <bos> i'm giving Network.Pcap a bit of a spring cleaning, hence my consternation and confusion
20:45:10 <dons> thoughtpolice: great post.
20:47:43 * bos asks dom and nick if he can pwn the pcap package
20:50:19 <thoughtpolice> dons: thanks a lot. :)
20:52:18 <bos> thoughtpolice: url?
20:52:25 <thoughtpolice> bos: http://austin.youareinferior.net/?q=node/29
20:52:27 <lambdabot> Title: Haskell for pluggable apps, with the GHC API | totally insane
20:52:41 <thoughtpolice> dons: it's somewhat inspired me to work on a wrapper for the ghc api,
20:53:01 <conal> thoughtpolice: :) !
20:53:10 <thoughtpolice> although the compileExpr call looks like it'll need to be coerced which is what I'm pondering on right now. i keep thinking about Typeable, but I'm not too sure on how to work that in (never used it before)
20:53:16 <conal> thoughpolice: is your blog on haskell planet?
20:53:23 <dons> the unsafeCoerce# stuff should be doable with Dynamic, btw.
20:53:32 <dons> see the first hs-plugins paper
20:53:37 <thoughtpolice> dons: sweet stuff. :)
20:53:47 <thoughtpolice> conal: no, although the last couple posts on there have been about haskell.
20:54:14 <bos> thoughtpolice: oh, you wrote hsns, too!
20:54:26 <thoughtpolice> bos: you mean someone looked at it?!
20:54:29 <thoughtpolice> :)
20:54:40 <thoughtpolice> news to me.
20:54:47 <bos> yeah, when i was digging up the pcap code
20:55:06 <conal> thoughpolice: okay -- i just subscribed, until you do join haskell planet.
20:55:29 <thoughtpolice> bos: on that note, if you can get Network.Pcap to work with winpcap (the bug looks subtle) that'd be cool, since that's the only thing keeping it off win32.
20:55:46 <sorear> thoughtpolice: what you're stuck on right now is iirc the main problem in Don's thesis, don't expect it to be too trivial (but it's also solved)
20:55:58 <conal> i wonder if there's a way for haskell planet to use a filtered feed, say only those posts tagged "haskell"
20:56:17 <thoughtpolice> sorear: cool. I'll be sure to look at the hs-plugins paper as soon as I can.
20:56:25 <bos> thoughtpolice: will take a look if i have cycles
20:57:07 <dons> sorear: yeah, that's about right
20:57:29 <conal> thoughpolice: i'm making a brand new Eros implementation, much more nicely factored than before, and i'd love to have a hs-plugins replacement.  so i'm delighted to see your progress & notes.
20:57:37 <thoughtpolice> the main thing that suprised me was how much bigger the resulting executable got after using the api, although gzexe+strip works nice. :)
20:58:35 <dons> conal: ah yes, very timely.
20:58:46 <dons> thoughtpolice: right, 20M ghc-api lib
20:58:49 <dons> though a lot of dead code
20:59:01 <conal> dons: indeed!  i just got the new eros running yesterday.
20:59:22 <dons> cool
20:59:52 <thoughtpolice> in any case, I guess the api wrapper will be my next project. school starts tomorrow, so insanity will probably come knocking pretty quick if I don't have some way to occupy my time.
21:09:31 * shapr grumbles more
21:10:10 <ddarius> Hmm.  Another SICP lecture or sleep?
21:11:00 <ohub> sleep, then sicp!
21:12:21 <ddarius> Sleep then work.
21:13:31 * ddarius chooses option 3.
21:21:52 <thoughtpolice> sleep sounds good right now.
21:22:38 <|Steve|> I'd say that always beats SICP.
21:22:53 <ddarius> I've already seen the lectures anyway.
21:23:02 <|Steve|> Seen them? It's a book...
21:23:15 <ddarius> @google SICP lectures
21:23:17 <lambdabot> http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/
21:23:18 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures
21:23:22 <|Steve|> Oh wow.
21:23:36 <|Steve|> Ugh, I don't think I could sit through lectures about it. The book was dull enough.
21:23:42 <sorear> ddarius is always right, you should know that by now
21:23:43 <sorear> :)
21:23:50 <dhpeterson> i didn't think the book was dull! :)
21:24:17 <dhpeterson> you've at least gotta watch the metacircular evaluator bit - where hal abelson dresses up - that's quite funny
21:25:05 <|Steve|> dhpeterson: The book was an intro to programming. It's hard for that to not be dull.
21:25:13 <dhpeterson> fair enough
21:25:23 <ddarius> We need an SICP-like thing for Haskell with video lectures by Simon Peyton Jones.  Those'd be entertaining to watch even if you cared not an iota about the content.
21:25:32 <dhpeterson> it was my first introduction to fp so maybe that's why i found it more interesting
21:25:41 <dhpeterson> ddarius: agree
21:25:49 <dhpeterson> i have been watching his OSCON lectures
21:26:15 <|Steve|> dhpeterson: Ah, okay. I read it while TAing a class on scheme so it was dull and overly long, even if I did learn a lot about scheme as a result.
21:26:18 <dhpeterson> :)
21:26:30 * sorear wishes he knew, but not quite enough to be motivated to set up his sound system
21:26:34 <lament> but SICP isn't about scheme!
21:26:37 <dhpeterson> SICP is how i got here .. so i can't begrudge it
21:26:56 <ddarius> They do talk about Miranda in the lectures.
21:27:17 <sfultong> is miranda still around?
21:27:18 <sorear> Favorably?
21:27:27 <ddarius> Yes favorably.
21:27:32 <ddarius> sfultong: Kind of.
21:29:16 <sorear> Almost everyone has jumped ship to Haskell, though.
21:29:28 <lament> disgraceful!
21:29:59 <sorear> I mean, except for the module system you could almost convert code by search&replace...
21:30:00 <dibblego> rectangles b d x y
21:30:11 <dibblego> oops
21:30:12 <sorear> #haskell /= GHCi
21:30:24 <ddarius> [(a,b) / a <- as, b <- bs]
21:30:48 <lament> sorear: <interactive>:1:1: lexical error at character 'h'
21:31:20 <ddarius> sorear: Did you go to that IRP link?
21:31:23 <sorear> ddarius: well sure, and then there's the issue of tuple patterns being irrefutable (which is why I addded an almost at the last second)
21:31:31 <sfultong> yeah, I learned about miranda after haskell... and I was surprised at how similar the syntax was
21:31:36 <sorear> IRP?
21:32:22 <lament> Please don't follow the IRP link.
21:32:38 <sorear> lament: what's an IRP link?
21:32:44 <ddarius> http://esoteric.voxelperfect.net/wiki/IRP
21:32:45 <lambdabot> Title: IRP - Esolang
21:34:08 <sorear> haha
21:35:35 <desp> ugh
21:35:57 <sorear> ARGH
21:36:07 <desp> if I want to newtype Int for the sake of differentiating some Int-based types for fundeps
21:36:24 * sorear does. not. like. it. when. people. use. nondeterminstic. when. they. mean. probabilistic.
21:36:27 <desp> I have to make each newtype an instance of Integral by hand? and also Real, and Num...
21:36:51 <sorear> {-# LANGUAGE GeneralizedNewtypeDeriving #-}
21:36:58 <desp> ooh.
21:37:22 <sorear> newtype Foo = Foo Int deriving(Integral, Real, Num, Show, Read, Ord, Eq, Bounded, Ix)
21:37:28 <desp> sorear++
21:37:45 <|Steve|> How does data differ from newtype?
21:38:17 <desp> automatic unboxing?
21:38:37 <desp> I think.
21:39:08 <desp> |Steve|: a newtype is supposed to have the same underlying representation as its source type
21:39:35 <|Steve|> Okay, so you couldn't have something like: newtype Foo = Foo Int Int?
21:39:37 <desp> if I'm not mistaken.
21:39:53 <sorear> |Steve|: Newtypes must have one constructor with one field, must be strict, and are always matched irrefutably.
21:40:09 <|Steve|> sorear: Okay, thanks.
21:40:09 <sorear> aside from that, no difference
21:40:18 <|Steve|> Is that useful?
21:40:25 <sorear> Very.
21:40:29 <sorear> @src State
21:40:29 <lambdabot> Source not found. Where did you learn to type?
21:40:31 <sorear> @src IO
21:40:32 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
21:40:45 <sorear> newtype State s a = State (s -> (s, a))
21:40:56 <ddarius> |Steve|: A newtype is purely a figment of the typecheckers imagination.  The point is that it has no semantic weight.
21:41:32 <|Steve|> Ah, I see.
21:41:44 <sorear> For instance, if you mix up CInt and CLong, you get a static error.
21:41:49 <sorear> Even on a 32-bit system.
21:42:12 <sorear> They're both usually newtypes of Word on such systems.
21:42:35 <desp> sorear: did you miss Enum there?
21:42:40 <sorear> Yes.
21:42:53 <|Steve|> Oh, so the newtype doesn't match with the underlying type, correct?
22:01:41 <Alexy> hello
22:01:58 <desp> |Steve|: it's appears to the typechecker as a completely different type
22:02:03 <desp> s/it's/it/
22:02:23 <desp> hence the name, newtype
22:03:00 <|Steve|> desp: Makes perfect sense.
22:03:04 <pjd> "new type, same data"
22:03:20 <lament> sorear: what's wrong with nondeterministic?
22:03:32 <desp> sorear: huge thanks for that bit of help
22:03:38 <desp> it enabled me to greatly simplify some code
22:03:47 <desp> whew, almost done.
22:04:09 <sorear> lament: it's wrong?
22:04:40 <sorear> perhaps not WRT english, but definitely WRT established jargon
22:04:41 <lament> sorear: in the context of the esolang wiki?
22:04:54 <pjd> sorear: "differently deterministic"? :)
22:05:07 <lament> heh
22:05:26 <sorear> lament: yes.
22:06:25 <lament> sounds fine to me...
22:12:39 <dhpeterson> :t return
22:12:44 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:21:23 <dhpeterson> :t mapM
22:21:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
22:21:30 <dhpeterson> :t mapM_
22:21:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
22:22:30 <olsner> does a mapM get optimized to mapM_ if you don't use the result?
22:23:01 <dhpeterson> good qn
22:23:28 <dhpeterson> is there an easy way to see the implementation of mapM_ ?
22:23:33 <EvilTerran> @src mapM_
22:23:34 <lambdabot> mapM_ f as = sequence_ (map f as)
22:23:34 <dhpeterson> a lambdabot call etc
22:23:35 <dhpeterson> aha
22:23:36 <dhpeterson> :)
22:23:45 <dhpeterson> thanks mate
22:23:45 <olsner> @src sequence_
22:23:45 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
22:23:46 <EvilTerran> @src mapM
22:23:46 <lambdabot> mapM f as = sequence (map f as)
22:23:53 <olsner> @src sequence
22:23:53 <lambdabot> sequence ms = foldr k (return []) ms
22:23:53 <lambdabot>     where
22:23:53 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
22:24:14 <dhpeterson> clever
22:24:33 <EvilTerran> looks like sequence = foldr (liftM2 (:)) (return []) to me
22:24:51 <pjd> EvilTerran: yep
22:25:03 <EvilTerran> ...any particular reason @src doesn't say that?
22:25:07 <EvilTerran> @where prelude
22:25:07 <lambdabot> I know nothing about prelude.
22:25:13 <EvilTerran> @where report
22:25:13 <lambdabot> http://www.haskell.org/onlinereport/
22:26:22 <EvilTerran> ah, i see. sequence is in Prelude, but liftM2 is in Monad
22:26:22 <pjd> i think @src shows GHC's version
22:26:40 <EvilTerran> that might explain why it's done that way
22:26:59 <pjd> the Prelude version has k as mcons p q = p >>= \x -> q >>= \y -> return (x:y)
22:27:13 <pjd> (the report's Prelude version, i mean)
22:27:19 <EvilTerran> so i see
22:27:43 <glguy> lambdabot uses whatever version dons explicitly added to it
22:27:50 <olsner> that seems unnecessarily obtuse... is do-sugar not in the report?
22:28:09 <EvilTerran> i'm sure it is
22:29:17 <pjd> olsner: i think it comes down to personal preference
22:30:46 <olsner> guess it does
22:30:50 <pjd> hmm, with monadic subexpressions you would write that as return (<- p) : (<- q) ?
22:31:19 <sorear> liftM2 much nicer
22:31:25 <sorear> traverse nicer still
22:31:32 <pjd> @src traverse
22:31:32 <lambdabot> Source not found. I feel much better now.
22:31:37 <olsner> @type traverse
22:31:39 <lambdabot> Not in scope: `traverse'
22:32:02 <olsner> how's a compiler error nicer? :P
22:33:58 <pjd> oh, i think they still need a do
22:34:14 <pjd> do { return (<- p) : (<- q) }
22:38:20 <dblhelix> morning #haskell
22:39:38 <lament> time of day to you too :)
22:40:19 <olsner> dblhelix: indeed it is morning
22:44:29 <EvilTerran> ah, so it is. i should probably go to bed at some point.
22:44:57 <dblhelix> olsner: well. not everywhere, of course
22:47:57 <lament> i guarantee you it's not morning here
22:49:11 <josh_> Is there any further simplification for a function like foo x = (bar x, baz x)?
22:49:32 <dons> yeah
22:49:34 <josh_> Some way to just say (bar,baz)?
22:49:41 <dons> ?pl foo x = (bar x, baz x)
22:49:42 <lambdabot> foo = liftM2 (,) bar baz
22:49:50 <pjd> foo = (bar &&& baz) -- another way
22:49:53 <dons> which is also hmm, some arrow thing
22:49:59 <dons> that's it, without parens
22:50:01 <ryani> How "atomic" are IORefs?  If I have two threads, one of which is executing "readIORef r" every once in a while, and another of which is executing "writeIORef r v" every once in a while, is there any chance of an invalid or intermediate result getting read?
22:50:16 <dons> foo = bar &&& baz -- functional languages FTW!
22:50:31 <dons> ryani: you know about atomicModifyIORef?
22:50:51 <dons> josh_: what do you think about foo = bar &&& baz ? cute no?
22:51:01 <pjd> josh_: the liftM2 version uses the (r ->) monad, in case you're wondering
22:51:11 <josh_> dons, uh, I don't know what &&& is and it isn't in the prelude.
22:51:17 <dons> :t ?bar &&& ?baz
22:51:19 <lambdabot> forall (a :: * -> * -> *) b c c'. (?bar::a b c, ?baz::a b c', Arrow a) => a b (c, c')
22:51:20 <Japsu> josh_: it's in Control.Arrow
22:51:21 <dons> its in Control.Arrow
22:51:27 <ryani> I assume atomicModifyIORef just uses compare-and-swap, right?
22:51:29 <Japsu> @quote stereo
22:51:29 <lambdabot> No quotes match. I feel much better now.
22:51:32 <Japsu> !
22:51:36 <ryani> and re-runs the function until that works?
22:51:51 <Japsu> has the "majestical stereo" quote been erased? :<<<
22:52:03 <dons> its gluing two functions together into a stream, one input, a pair of outputs, with bar and baz applied to the input value
22:52:22 <dons> it's amazing &&& isn't more widely known in FP.
22:52:35 <dons> it seems like one of the first things you'd code up after (.) for function glue
22:52:55 <pjd> dons: you mean this instance of &&& ?
22:53:05 <dons> pjd: yeah, specifally.
22:53:10 * pjd still thinks arrows in general are scary
22:53:15 <dons> true :)
22:53:28 <pjd> also, first and second
22:54:54 <dons> yeah, true first class support for functions/tuples and streaming data around
22:55:15 <dons> josh_: did you find &&& in the Control.Arrow module?
22:55:40 <josh_> dons, yes, um... the description next to it is baffling.
22:55:58 <dons> well, they're very general -- generalising monads -- and we're just using one instance of Arrow here, for functions
22:57:22 <dons> with the type Arrow a => a b (c,c')
22:57:23 <josh_> er, hi ikegami--. Funny meeting you here.
22:57:25 <dons> replace 'a' with ->
22:57:33 <dons> and you get,  b -> (c,c')
22:57:34 <josh_> s/josh_/diotalevi/
22:57:39 <dons> which is your function of one input, two outputs
22:59:37 <sorear> ryani: read/writeIORef are as atomic as sig_atomic_t access in C
22:59:56 <sorear> ryani: if they weren't, the mutator would crash
23:00:22 <sorear> ryani: atomicModifyIORef is semantically CAS (it actually uses a process-global lock
23:00:47 <ryani> That's what I expected, but just thought I should confirm
23:38:19 <scodil> Is there a reason why Data.IntMap.fromAscList is just an alias for "fold insert"? Can you not build a trie from sorted input in linear time?
23:39:00 <sorear> You can most certainly do that.  I suspect it was 'lack of interest'
23:39:09 <sorear> Feel free to submit a patch
23:39:11 <dons> yeah
23:39:19 <dons> had to match the Map api, but ran out of time
23:39:44 <dons> while we also have,
23:39:45 <dons> -- | /O(n)/. Build a map from an ascending list in linear time.
23:39:45 <dons> -- /The precondition (input list is ascending) is not checked./
23:39:45 <dons> fromAscList :: Eq k => [(k,a)] -> Map k a
23:39:50 <sorear> Do we still need to subject people to the Library Submissions Process if the patch is semantically undetectable
23:39:53 <sorear> ?
23:40:02 <dons> yeah, since its going in base, and needs a QC
23:40:17 <dons> its to ensure quality too, not just stability
23:40:36 <dons> so while it wouldn't be contentions, the process ensures people take the time to at least do it right
23:41:06 <sorear> I don't think a faster fromAscList is worth a week of anyone's time...
23:41:26 <dons> you take that long to write QC properties?
23:41:41 <sorear> no, the page specifies to wait that long.
23:43:07 <scodil> that's a bummer becaue fromAscList is about as close to mapKeys as you can get, it seems
23:43:12 <dons> you can do other things during that time period
23:43:38 <scodil> er, mapKeysMonotonic
23:45:05 <glguy> " There are some who, in a sadly misguided attempt to verbally distinguish a trie from the more general tree and in contrast to typical English pronunciation (of which calorie, eerie, and reverie are examples, but die, lie, and pie are not), pronounce the name "try".
23:45:40 <sorear> reTRIEval is pronounced that way even...
23:46:09 <dons> its really hard sitting in lectures about trees and tries.
23:46:28 <scodil> i had a cs lecturer actually call a deque and "deek". I still sometimes regress to pronouncing it that way in my head. its a personal tragedy
23:46:29 <dons> my foundations of data structures lectures a few years ago were hmm, ambiguous
23:46:52 <dons> scodil: that's weird.
23:46:54 <Olathe> scodil: Heheh
23:46:57 <dons> i've not heard that one before
23:47:03 <glguy> I called it a "d-q" until I learned "deck" in college
23:47:20 <desp> "deek"
23:47:21 <scodil> yeah deck makes so much more sense
23:47:22 <dons> deque , cheque
23:47:27 * desp chuckles
23:47:42 <scodil> or at least d. e. queue
23:47:46 <glguy> dons: in September you'll have "checks"
23:47:50 <dons> is cheque 'check' in the US?
23:47:51 <scodil> but that's too many syllables
23:47:51 <dons> ah
23:47:59 <scodil> yes cheque is check
23:48:04 <dons> and no gaols?
23:48:09 <desp> English is highly irregular anyway
23:48:11 <glguy> gaols?
23:48:11 <desp> "choir"?
23:48:15 <scodil> its interchangable, though
23:48:15 <lament> no gaols, no.
23:48:20 <dons> glguy: were prisoners go.
23:48:27 <glguy> dons: oh, they go to the can
23:48:32 <glguy> ;)
23:48:36 <dons> heh
23:49:07 <lament> as i understand even in britain "jail" is the preferred spelling
23:49:08 <dons> I don't want to give up my British aspell dictionary!
23:49:23 <lament> so "gaol" is basically obsolete
23:49:30 <dons> lament: hmm, I think you'd still be marked wrong in .au if you used jail at school.
23:49:31 <glguy> its a: jail, penitentiary (sp), prison
23:49:37 <olsner> is 'gaol' pronounced 'jail'?
23:49:39 <glguy> depends on how big the region is that is running it
23:49:39 <dons> yeah
23:49:49 <glguy> (county vs city or state)
23:49:52 <lament> olsner: they're the same word, like cheque/check
23:50:04 <LeCamarade> Wait, someone still uses `gaol'?
23:50:07 <dons> ?web1913 gaol
23:50:08 <lambdabot> *** "gaol" web1913 "Webster's Revised Unabridged Dictionary (1913)"
23:50:08 <lambdabot> Jail \Jail\, n. [OE. jaile, gail, gayhol, OF. gaole, gaiole,
23:50:08 <lambdabot>    jaiole, F. ge[^o]le, LL. gabiola, dim. of gabia cage, for L.
23:50:08 <lambdabot>    cavea cavity, cage. See {Cage}.]
23:50:08 <lambdabot>    A kind of prison; a building for the confinement of persons
23:50:11 <lambdabot> [39 @more lines]
23:50:17 <lament> gayhol!
23:50:17 <LeCamarade> (Excluding the Irish, I think ...)
23:50:26 <scodil> hah lambdabot uses websters
23:50:27 <glguy> "detention center"
23:50:31 <dons> stupid lambdabot
23:50:48 <lament> stupid lambdabot, it uses websters in response to ?web1913 :)
23:50:51 <dons> i'm going to fix that. just need a copy of the oxford or maquarie. that'll learn 'em.
23:51:02 <dons> ?dict gaol
23:51:03 <lambdabot> Supported dictionary-lookup commands:
23:51:03 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
23:51:03 <lambdabot> Use "dict-help [cmd...]" for more.
23:51:06 <LeCamarade> Wow. 'Tis a big, big world.
23:51:46 <glguy> "Jails are most often run by sheriffs and/or local governments and are designed to hold individuals awaiting trial or a serving short sentences.
23:51:49 <glguy> Prisons are operated by state governments and the Federal Bureau of Prisons (BOP) and are designed to hold individuals convicted of crimes.
23:51:59 <LeCamarade> And I used to wonder why the Crocodile Hunter called his friends `mite'.
23:52:14 <glguy> LeCamarade: little friends
23:52:16 <dons> 'mite'? sounds like kiwi accent to my ears.
23:52:53 <LeCamarade> I think he meant `mate'. But ...
23:52:56 <lament> well, the letter "a" is pronounced "a", not "e" :)
23:53:10 <dons> yeah, looks like 'gaol' is still official, `The Long Bay Prison Complex has been the site of Sydney's major metropolitan gaol for ninety years.'
23:53:19 <scodil> maybe he was offering vegmite. "Anyone for a 'mite sammich?"
23:53:24 <LeCamarade> Australians: Repeat after me: may-t. May.T.
23:53:24 <scodil> vegemite, even
23:53:27 <scodil> or however you spell it
23:53:46 <dons> LeCamarade: that's how I hear it. 'may-t'. i think your ears are broken.
23:53:47 <glguy> LeCamarade: that's how the pirates say it
23:53:51 <pjd> marmite
23:54:03 <glguy> @yarr
23:54:03 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
23:54:06 <LeCamarade> Hehehe.
23:54:07 <glguy> may tee
23:54:08 <dons> 'day mate. --> day may-t
23:54:28 <LeCamarade> But you say My-T. Mite.
23:54:30 <lament> now i will never be able to take dons seriously again
23:54:34 <dons> LeCamarade: no!
23:54:41 <glguy> day mate? is that someone you share your day with
23:54:44 <glguy> like a room mate
23:54:49 <lament> i'll imagine aussie accent on everything he says
23:55:06 <LeCamarade> And considering I like Australian documentaries, I have trained myself to parse `snike' into `snake' and all such optimisations ...
23:55:08 <scodil> day mate is something you do with your SO on lunch break. In the US we call those "nooners"
23:55:24 <dons> heh
23:55:25 <profmakx> i like the aussie accent
23:55:38 <profmakx> but it took me weeks to understand people -.-
23:55:50 <Pseudonym> Sorry, Australians make documentaries?
23:55:53 <LeCamarade> `Oh-strile-ear' into `Oh-stray-liah'.
23:56:00 <profmakx> gnar
23:56:02 <profmakx> until
23:56:30 <dons> its actually pronounced 'stayah' ;)
23:56:39 <LeCamarade> :oD
23:56:46 <dons> strayah, missed the 'r'
23:56:48 <LeCamarade> `Stay here'
23:57:03 <LeCamarade> `Stray here'
23:57:17 <dons> 'stray-yah.
23:58:00 <glguy> foreigners are weird! ;)
23:59:01 <kfish> streuth
23:59:13 <dons> oath!
23:59:16 <TSC> You're the weird one, you galah
23:59:29 <glguy> galah?
23:59:34 <dons> yep.
23:59:40 <glguy> ok, explain that too :)
23:59:44 <Pseudonym> Galah == pink and grey parrot.
23:59:46 <dons> don't be a drongo!
23:59:51 <kfish> bloody big pink pigeon
23:59:54 <glguy> drunk dingo?
23:59:57 <TSC> And a flamin' galah, at that
