00:00:49 <mdmkolbe> desp: hmm, I'm not sure what happens in that case.  You might be ok if no other instances of MyEnum are independantly declared instances of Enum, but I don't know the rules well enough to be sure
00:01:55 <EvilTerran> i think that's right.
00:02:33 <desp> "not ok" would mean odd errors during compilation, right?
00:02:36 <EvilTerran> you should get errors (or at least warnings) if something actually ends up with two instances. that's what -fallow-overlapping-instances is for.
00:02:43 <desp> ah
00:02:45 <glguy> shuffle_list' = foldr (\r f xs -> let (x,xs') = extract r xs in x : f xs') (\    _  -> [])
00:03:12 <glguy> oops
00:03:31 <EvilTerran> this is not your emacs window ;]
00:03:41 <glguy> emacs?? surely you jest ;)
00:03:54 <wli> nvi here
00:04:04 <wli> Let the editor flamewars begin.
00:04:12 <desp> "#haskell: Not your grandfather's emacs window"
00:04:21 <glguy> wli: the editor flame wars were settled long ago, vim won ;)
00:04:32 <EvilTerran> well, i don't know what you use. i figured it was not significantly less likely than, say, vim, and worked fine for the purposes of the jest.
00:04:44 <mdmkolbe> glguy: this is #haskell, Yi won
00:05:05 <glguy> mdmkolbe: heh, Yi might win when it gets to the point that people can use it
00:05:10 <glguy> no telling
00:05:15 <EvilTerran> surely YI = I?
00:05:51 <EvilTerran> ...or anything else, actually. hm.
00:06:17 <samreid> maybe yim
00:06:26 <mdmkolbe> YI = omega, but in a lazy language we can live with that
00:08:29 <mdmkolbe> Does this function have a well known name? let f xs = let { n = length xs; a = take (n `div` 2) xs; b = drop (n `div` 2) xs } in if n < 2 then xs else f (zipWith (+) a b) ++ f (zipWith (-) a b) in f
00:09:22 <glguy> mdmkolbe: you'd be better off using splitAt
00:09:24 <glguy> than take and drop
00:09:40 <glguy> (a,b) = splitAt (n `div` 2) xs
00:09:56 <mdmkolbe> glguy: thx
00:13:17 <wli> It's slightly faster even though it is rather sucky.
00:13:33 <phr> anyone want to share some enlightenment about GADT's?  I'm wondering whether 1) why they generally won't accept "deriving Show"; 2) whether in general they're supposed to replace the old data declarations
00:20:57 <EvilTerran> hm. apparently my friend just tripped the circuit breaker switching his shiny new computer on. =/
00:21:10 <samreid> happens
00:21:16 <DRMacIver> Morning
00:21:19 <Syzygy-> Moin
00:22:30 <wli> Let's see if I can find those golden nuggets in a respectable amount of time.
00:25:30 <wli> There should actually be a way to walk betweeen integer points without this sort of garbage.
00:31:57 <mdmkolbe> Is there a "shuffle" or a "deal" function?
00:32:34 <TSC> To randomly permute a list, you mean?
00:32:55 <mdmkolbe> TSC: no, I mean to do a perfect riffle shuffle
00:32:56 <wli> > let z p q = 5*(p*p+4*p*q-q*q) ; x p q = -2*(6*p*p-p*q-q*q) ; y p q = 5*(5*p*p-2*p*q+q*q) ; f p q = (x p q `divMod` z p q, y p q `divMod` z p q) in mapM_ print $ take 5 [t | t@(_, _, ((t_x,r_x),(t_y,r_y))) <- [(p, q, f q p) | p <- [1..], q <- [2..p-1], gcd p q == 1], t_x > 0, t_y > 0, r_x == 0 && r_y == 0]
00:32:57 <lambdabot>  <IO ()>
00:33:01 <wli> gah
00:33:23 <wli> > let z p q = 5*(p*p+4*p*q-q*q) ; x p q = -2*(6*p*p-p*q-q*q) ; y p q = 5*(5*p*p-2*p*q+q*q) ; f p q = (x p q `divMod` z p q, y p q `divMod` z p q) in take 4 [t | t@(_, _, ((t_x,r_x),(t_y,r_y))) <- [(p, q, f q p) | p <- [1..], q <- [2..p-1], gcd p q == 1], t_x > 0, t_y > 0, r_x == 0 && r_y == 0]
00:33:25 <lambdabot>  [(11,3,((2,0),(5,0))),(29,7,((15,0),(34,0))),(38,9,((104,0),(233,0))),(199,4...
00:33:49 <TSC> I don't think there's a function in the standard libraries to shuffle
00:34:57 <wli> That should give you the gist of it, anyway.
00:36:35 <wli> That's after projecting y^2=5*x^2+2*x+1 onto the x axis through (2,5)
00:41:20 <EvilTerran> > let interleave ([],ys) = ys; interleave (x:xs,ys) = x : interleave (ys,xs); riffle xs = interleave $ splitAt (length xs `div` 2) xs in riffle ['a'..'z']
00:41:21 <lambdabot>  "anbocpdqerfsgthuivjwkxlymz"
00:45:30 <phr> shuffle :: [a] -> [a]
00:45:30 <phr> shuffle deck =
00:45:30 <phr>         let n = (length deck) `div` 2;
00:45:30 <phr>                 (x,y) = ((take n deck), (drop n deck)); in
00:45:30 <phr>              foldl1 (++) $ zipWith (\a b->[a,b]) x y
00:46:19 <phr> that's probably terrible but it got the same result as evilterran's
00:46:25 <hpaste>  wli annotated "newby advice" with "JFP-style Euclid sans PQ with wheel" at http://hpaste.org/2313#a5
00:46:38 <EvilTerran> if we had lambda-match, interleave would be unfoldr (|(x:xs,ys) -> Just (x,(ys,xs)))
00:47:21 <EvilTerran> actually, s/Just//, according to the proposal (http://hackage.haskell.org/trac/haskell-prime/ticket/114)
00:47:31 <lambdabot> Title: #114 (introduce lambda-match (explicit match failure and fall-through)) - Haskel ...
00:47:55 <mdmkolbe> If you want to up the challange you could try to make how many parts are in the shuffle into a parameter.  (i.e. a three way shuffle splits things into three decks then proceeds by taking one card from each deck)
00:48:13 <mdmkolbe> But I'm too tired for that at the moment so I'm going to sleep
00:49:19 <phr> mdmkolbe i might try that
00:49:28 <phr> does my function look halfway sane?
00:49:52 <EvilTerran> phr, i thought about using concat . zipWith (\x y -> [x,y]), but i personally think my interleave function looks quite elegant.
00:50:09 <EvilTerran> also, (take n xs, drop n xs) = splitAt n xs
00:50:20 <EvilTerran> but splitAt only traverses the list once
00:50:21 <phr> thanx
00:50:24 <phr> cool
00:50:38 * wli has discovered how convenient lazy pattern matching is for shutting up warnings about missing cases for functions defined only for infinite lists.
00:50:49 <phr> concat rather than foldl ++
00:50:51 <phr> hmm
00:50:57 <phr> different?
00:50:57 <EvilTerran> wli, i hear it's good for performance, too :D
00:51:02 <EvilTerran> @src concat
00:51:02 <lambdabot> concat = foldr (++) []
00:51:28 <EvilTerran> concat works for infinite lists, too, 'cos it's a foldr.
00:51:46 <EvilTerran> > foldr (++) [] (repeat [1,2,3])
00:51:47 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
00:51:51 <EvilTerran> > foldl (++) [] (repeat [1,2,3])
00:51:52 <phr> i must have foldl and foldr backwards then
00:51:54 <lambdabot> Terminated
00:52:02 <phr> foldl is left to right i thought
00:52:24 <EvilTerran> it's a little unintuitive, because of the outermost-expressions-are-evaluated-first thing
00:53:02 <EvilTerran> if you try to foldl an infinite list, the outermost expression involves the (nonexistant) last item, so it's unevaluatable
00:53:23 <phr> > foldl1 (++) [a | a<-['a'..'z']]
00:53:24 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
00:54:02 <phr> > foldl1 (++) (map (\a->[a]) ['a'..'z'])
00:54:03 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
00:54:24 <EvilTerran> also, when dealing with finite lists, the way foldl works makes it prone to building up a big unevaluated expression in the accumulator
00:54:28 <phr> > foldr (++) (map (\a->[a]) ['a'..'z'])
00:54:29 <lambdabot>  <[[[Char]]] -> [[Char]]>
00:54:35 <wli> How do those comment things with the compiler flags work again?
00:54:47 <wli> I'm using ghc -Wall -fglasgow-exts -O2 -funfolding-use-threshold=1000 -funfolding-creation-threshold=1000 -optc-O3
00:54:56 <phr> i thought it was foldr that made the big unevalled thing
00:54:56 <wli> Can all that be shoved into the comments?
00:54:57 <phr> hmm
00:54:59 <mdmkolbe> wli: {-# OPTIONS -fglasgow-exts #-}
00:55:18 <mdmkolbe> wli: is that the sort of thing you're after?
00:55:20 <EvilTerran> {-# OPTIONS_GHC whatever #-}
00:55:22 <phr> i better work through some examples later
00:55:29 <phr> > foldr (++) (map (\a->[a]) ['a'..'z'])
00:55:31 <lambdabot>  <[[[Char]]] -> [[Char]]>
00:55:39 <phr> what's that mean???
00:55:44 <EvilTerran> or {-# LANGUAGE UndecidableInstances #-} etc
00:55:47 <wli> So I do {-# OPTIONS -Wall -fglasgow-exts -O2 -funfolding-use-threshold=1000 -funfolding-creation
00:55:48 <wli> -threshold=1000 -optc-O3 #-}
00:56:02 <wli> and I get all that without even passing it on the cmdline?
00:56:24 <EvilTerran> phr, it means your expression is a function that hasn't received all its parameters
00:56:34 <EvilTerran> > foldr (++) [] (map (\a->[a]) ['a'..'z'])
00:56:35 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
00:56:40 <phr> ahh thanks
00:57:11 <mdmkolbe> wli: yeah, but you usually pass stuff like -Wall and -O2 on the command line anyway and only put stuff like -fglasgow-exts and other options that are *required* to even compile correctly in the file
00:57:35 <EvilTerran> anyway, i was saying about foldl... it's better to use foldl' rather than foldl in most cases, because it prevents the aforementioned big thunk buildup that i mentioned
00:57:38 <EvilTerran> ?type foldl'
00:57:39 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:57:46 <EvilTerran> ?src foldl'
00:57:46 <lambdabot> foldl' f a []     = a
00:57:46 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
00:58:01 <wli> So OPTIONS -fglasgow-exts is ultimately equivalent to LANGUAGE something?
00:58:26 <EvilTerran> wli, {-# LANGUAGE Quite, A, Lot, Of, Things #-}, iirc
00:58:36 <phr> right, also foldl1' except hugs doesn't seem to have it
00:59:02 <hpaste>  wli pasted "Nuggets (PE#137)" at http://hpaste.org/2316
00:59:10 <EvilTerran> @docs Language.Haskell.Extension
00:59:10 <lambdabot> Language.Haskell.Extension not available
00:59:17 <EvilTerran> ... http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html
00:59:18 <lambdabot> http://tinyurl.com/2c2g5y
01:00:20 <EvilTerran> phr, indeed. as a stylistic point, though, it's better to use, say, foldr rather than foldr1 in most cases, because it means your function works on empty lists too.
01:00:52 <EvilTerran> there are situations where it doesn't make sense (such as maximum, average, etc), but the majority (sum, concat, etc) do.
01:00:56 <wli> Except when there's no sensible default or it's an invariant that only nonempty lists will ever be passed.
01:01:32 <LeCamarade> Um ... how many passes does GHC do?
01:01:51 <wli> LeCamarade: Quite a few. ;)
01:02:09 <LeCamarade> :o)
01:02:13 <LeCamarade> Maybe ... 10? :-D
01:02:39 <phr> i see, yeah you can specify the initial value for something like sum
01:03:25 <lament> mathematical sum and product are defined for empty sequences, iirc
01:04:13 <EvilTerran> > product []
01:04:14 <lambdabot>  1
01:04:28 <phr> > foldr (+) 0 [1..5]
01:04:30 <lambdabot>  15
01:04:37 <phr> > foldl1 (+) 0 [1..5]
01:04:38 <lambdabot>   add an instance declaration for (Num [[t] -> a])
01:04:49 <phr> > foldl1' (+)  [1..5]
01:04:50 <lambdabot>  15
01:05:37 <phr> how can you write a sequence of divmods as a fold?  like to get the decimal digits of a number
01:06:03 <phr> digits n | n < 10 = [n]
01:06:51 <phr>      | otherwise = let (a,b) = divMod n 10 in (digits a) ++ (digits b)
01:06:54 <EvilTerran> that would probably be an unfold, rather than a fold
01:07:24 <phr> > :t unfold
01:07:25 <lambdabot>   parse error on input `:'
01:07:28 <phr> >:t unfold
01:07:34 <EvilTerran> ?type unfoldr
01:07:34 <lament> phr: you can write turning a list of digits into a number as a fold
01:07:35 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:08:35 <EvilTerran> > let getDigit 0 = Nothing; getDigit i = Just (i `divMod` 10) in unfoldr getDigit 256
01:08:37 <lambdabot>  [25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
01:08:39 <EvilTerran> hm.
01:08:42 <newsham> if only there was a shorter name for foldr (+) 0
01:08:55 <wli> e.g. sum
01:08:57 <EvilTerran> @src sum
01:08:57 <lambdabot> sum = foldl (+) 0
01:09:05 <newsham> phr: unfold?
01:09:06 <EvilTerran> wait, l?
01:09:19 <phr> ?t unfoldl
01:09:20 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
01:09:24 <phr> ?type unfoldl
01:09:26 <lambdabot> Not in scope: `unfoldl'
01:09:28 <EvilTerran> > let getDigit 0 = Nothing; getDigit i = Just (uncurry (flip (,)) $ i `divMod` 10) in unfoldr getDigit 256
01:09:29 <lambdabot>  [6,5,2]
01:09:40 <phr> ugh!!
01:09:56 <EvilTerran> @unpl uncurry (flip (,))
01:09:56 <lambdabot> uncurry (\ b c -> (,) c b)
01:10:02 <EvilTerran> ...
01:10:11 <newsham> slightly complicated because it needs to say when to stop unfolding
01:10:13 <EvilTerran> uncurry (flip (,)) = \(x,y) -> (y,x)
01:11:16 <EvilTerran> newsham, quite. that one wouldn't even benefit from lambda-match, AFAICT :(
01:12:00 * EvilTerran wonders if unfoldr (|i | i > 0 -> ...) would be allowed under that proposal...
01:12:59 * EvilTerran wants guards (well, an optional single guard) in lambdas, damnit!
01:13:46 <hpaste>  wli annotated "Nuggets (PE#137)" with "cleaned up nuggets" at http://hpaste.org/2316#a1
01:13:48 <phr> oh i think i saw something about that in haskell.org
01:14:18 <EvilTerran> about whatnow?
01:14:29 <phr> about lambdas with guards
01:14:57 <phr> i gotta go to bed
01:15:01 <phr> laterz everyone
01:15:02 <phr> thanks
01:15:05 <phr> nite
01:16:15 <EvilTerran> 'night
01:19:39 <Hunter_wow> it seems like I have forgot "read". Getting "unresolved overloading" by >read "1"
01:20:26 <Hunter_wow> how do I use "read"?.. read :: String -> a
01:20:35 <eivuokko> You must give it a type;  Compiler can't know what type thing you have in string unless it's told (either by context or type annotation)
01:20:47 <eivuokko> read "1"::Int
01:21:20 <Hunter_wow> aha, ok, thanks, seems to work bether =)
01:22:08 <wli> There is definitely some kind of lattice-walking algorithm that's eluding me.
01:30:25 <EvilTerran> hm... i'm thinking about the views proposal...
01:33:15 <EvilTerran> well, the variant that Dan Licata was talking about at anglohaskell. anyone about who knows what i'm talking about?
01:43:08 <EvilTerran> actually, what i'm thinking could be relevant for pattern guards, too, but i only thought of it 'cos of something Dan said...
01:44:37 <EvilTerran> he mentioned a (generally unpopular, i gather) proposal to allow implicit use of Maybe in views (foo (view => PAT) = ... instead of (view -> PAT), translating to foo | Just PAT <- vew = ..., instead of without the Just)
01:45:12 <EvilTerran> but i'm thinking, would it be possible to generalise such a thing to all monads, say?
01:46:29 <EvilTerran> so you could have a pattern guard foo l | x:xs <<- l = ..., say (picking an arbitrary "operator" for syntax, here). not entirely sure how it'd desugar, but it strikes me as an interesting idea.
01:46:58 <dons> ?users
01:46:58 <lambdabot> Maximum users seen in #haskell: 385, currently: 350 (90.9%), active: 6 (1.7%)
01:48:20 <EvilTerran> presumably it'd desugar to something like foo l = do x:xs <- l; ..., but i don't know how well that'd interact with the existing pattern guard desugaring.
01:48:27 <EvilTerran> any thoughts?
02:17:53 <kayess> I was just working on an introduction to Visual Haskell piece for my web site and wanted to check a couple of facts. Anybody know anything about it?
02:23:11 <Heffalump> kayess: I've used it a fair bit
02:23:25 <Heffalump> and built it from source, but without really reading the source
02:25:28 <kayess> I was really just finishing the piece with some stuff about using Haskell. It seems that Visual Haskell can only make EXEs and not DLLs (but I have heard something about COM)
02:27:49 <Heffalump> it must be able to make DLLs, since it can build itself
02:28:05 <cinimod> @seen dons
02:28:05 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 41m 7s ago.
02:28:09 <Heffalump> and it uses COM, yes
02:28:22 <kayess> ok cool
02:28:46 <kayess> I guess that the bindings are probably not all that easy to get your head around as a beginner though?
02:29:34 <Heffalump> I'm not sure, I've not used them myself. A colleague (augustss) has looked at them, I think.
02:30:48 <dons> cinimod: ?
02:31:50 <cinimod> dons: I was just wondering if getBits had yet been added to bytestreams
02:32:05 <kayess> I did take a look at the COM stuff and it didn't look a bit like any other IDL
02:33:06 <kayess> But if Visual Haskell is built from Haskell sources then that tells me what I needed to know - that it is possible to do
02:33:19 <cinimod> dons: I meant bytestrings
02:34:59 <olliej> dons: what's that monad tutorial called?
02:35:13 * olliej has given up and is actually going to try to learn how monads are meant to work :D
02:35:33 <cinimod> I'm reading in the whole bytestring and using a state monad to get the bits I want
02:36:07 <Cale> olliej: Have you read any of my tutorials?
02:36:11 <Heffalump> I'm fairly sure they were all Haskell. You could check from the darcs repo.
02:36:12 <olliej> Cale: nope
02:36:15 <olliej> Cale: url?
02:36:28 <Heffalump> http://darcs.haskell.org/vshaskell/
02:36:30 <lambdabot> Title: Index of /vshaskell
02:36:57 <Cale> http://www.haskell.org/haskellwiki/Monads_as_containers http://www.haskell.org/haskellwiki/Monads_as_computation http://www.haskell.org/haskellwiki/Introduction_to_IO
02:36:58 <lambdabot> Title: Monads as containers - HaskellWiki
02:37:28 <Cale> Introduction to IO is just about IO, if you'd like to get a sense of what that's like on its own
02:37:33 <Cale> (and it's really short)
02:37:34 <kayess> Heffalump, you read my mind :) I was just on the Visual Haskell homepage starting to look for the source
02:38:34 <Cale> Monads as Computation is a broad overview of what monads are about and what the point is, along with a description of what they are, but I think it could use more examples
02:39:33 <Cale> Monads as Containers looks at monads from the point of view of container types, which is often a good way to get started if you're having trouble with the computation perspective
02:41:07 <DRMacIver> Idle question. The other day I had to explain what made Haskell different from most other languages to someone who was reasonably technically able but not a programmer. What do you think the best way of going about this is?
02:42:19 <Cale> Explain imperative programming and the basics of Haskell? I suppose it depends on what you want to get across. You could explain about state and referential transparency...
02:43:13 <Cale> It's pretty hard to summarize. "It's a whole different approach to the problem of writing programs." would be one thing you could say, though I'm not sure it conveys much :)
02:43:42 <eivuokko> In such context I usually have to describe why I like haskell;  And I then refer to how type information helps me;  And how core language is good for reasoning.
02:43:56 <Randroid> I don't think I could explain Haskell to a non-programmer.
02:44:00 <Heffalump> kayess: it's not relaly properly advertised
02:44:13 <Randroid> Hell, I couldn't explain C# (my pay-the-bills language) to a non-programmer.
02:44:55 <DRMacIver> It didn't have to be a one sentence summary. :) What I basically did was a) Explain the difference between statically and dynamically typed languages, b) Explain how side effects normally work and then c) Explain how unlike most statically typed languages, Haskell's type system is used to constrain the sort of effects that happen and programs are built up by composing effects rather than a sequence of 'doing things'.
02:45:20 <eivuokko> kayess, you can build DLLs with ghc with --mk-dll switch.
02:45:22 <DRMacIver> Randroid: I suspect that C# is probably harder to explain than Haskell. :)
02:45:41 <DRMacIver> If nothing else, it has fewer distinguishing features.
02:45:45 * EvilTerran explains haskell as "it looks like maths. isn't that great?"
02:46:15 <DRMacIver> (That's not intended as a putdown. C# is nice, but it's very much just another language)
02:46:19 <eivuokko> kayess, Heffalump, building Visual Haskell is one thing;  You also need to register in correct directory structure (essentiall within a ghc distribution), so source alone is not all that convient.
02:46:27 <kayess> DRMacIver, I would just say that it's programming using algebra rather than a list of instructions (probably enough to get the conversation started on the right footing)
02:46:29 <EvilTerran> then i usually wow them with fibs=1:1:zipWith...
02:46:31 <Randroid> I've tried explaining Haskell to my programming co-workers, and even there it's a bit of a lost cause. When they hear of a language that isn't object-oriented, they immediately think it's somehow inferior, a throwback of some kind.
02:46:48 <johnnowak> perhaps you deserve a raise
02:47:04 <ttfh> Randroid: I can relate to that
02:47:09 <DRMacIver> EvilTerran: The intent was to explain rather than impress. :)
02:47:17 <EvilTerran> I'd tend to explain C# as "it's the language built to fit perfectly with the dotnet runtime".
02:47:37 <EvilTerran> DRMacIver, i figure that that one gives a good idea of a few of the bits of haskell that're great
02:47:45 <DRMacIver> Randroid: I think I might actually get somewhere if I tried to explain Haskell to my coworkers (I would have got that effect at my last job though)
02:47:57 <EvilTerran> ...and are peculiar to haskell and very few other langauges.
02:48:08 <Randroid> Well, C# is not a bad little language, and its chief architect, Anders Hejlsberg, is apparently a fan of Haskell. Haskell's algebraic types influenced C#'s generics.
02:48:18 <Randroid> But I'd rather write Haskell any day.
02:48:18 <EvilTerran> (laziness, and, by extension, infinite computations, recursive bindings, etc)
02:49:06 <Heffalump> C#'s generics were mostly designed by some ML people, AFAIK
02:49:12 <Heffalump> (Andrew Kennedy and Don Syme)
02:49:21 <DRMacIver> EvilTerran: Mm. I'm pretty sure you could do that in OCaml or F# (not with their list datatype, but with some sort of codata streams). Might work in Scala, not sure.
02:49:39 <DRMacIver> (I'm not sure if scala has a let rec)
02:49:50 <Randroid> Heffalump: That's interesting, because Hejlsberg talks about the Haskell influence in an interview he gave, but beyond that I know nothing about it.
02:50:08 <Heffalump> well, Eric Meijer is quite heavily involved in that world too
02:50:11 <DRMacIver> Presumably it can be done in some form or another with most functionalish languages.
02:50:14 <EvilTerran> at one point i ended up staying up 'til 3am talking to one of my friends who writes C# in the City for a living, explaining stuff like how the heck that line works :D
02:50:17 <DRMacIver> It's just that it wouldn't be quite so natural. :)
02:50:27 <Heffalump> but he's renounced his Haskell roots, or something :-)
02:50:45 <EvilTerran> DRMacIver, the great part is how succinct it is, though.
02:50:57 <Randroid> Heffalump: Heh. Well, I don't hate C#. I can think of a lot worse languages to have to write code in all day long for Corporate America.
02:51:35 <ttfh> My coworkers fall into two categories, the first, like Randroids coworkers, don't see the point. Then there's people with an academic background who touched on haskell briefly but not of their own free will. They dissmiss it as to difficult and odd, but at the same time there's a sense of wonder, this was me about 2 years ago. Then there's the third category, people who know haskell and like it, haven't met anyone like tha
02:51:47 <DRMacIver> EvilTerran: Mm. It wouldn't be much longer in ocaml, although somewhat uglier I'll grant. :)
02:52:05 <EvilTerran> (this 3am rant was when i got home from anglohaskell, so my mind was full of how great haskell is. and two pints of beer. that tends to make me ramble.)
02:52:36 <DRMacIver> (At least I think not. I'm not really very good at ocaml, but I've heard that its support for laziness is decent. Even if it weren't, you could definitely define your own stream datastructure and use let rec)
02:53:09 <Randroid> I hate to say it, but my coworkers just aren't smart enough. Most of them know only two language, and that not well. I can code circles around them even in C#. (Usually they know C# and VB, and perhaps some rudimentary SQL.) Like most of you, I probably know at least a dozen languages. I think 20 or so at last count. My coworkers think I'm weird.
02:53:16 <Randroid> *languages
02:53:53 <DRMacIver> I don't think I would claim to know more than a couple of languages for any useful flavour of 'know'.
02:54:01 <DRMacIver> I can write code in a fair few more, but that's not the same thing. :)
02:54:38 <Randroid> Some of the languages I know are not current. Others don't have large enough libraries to be useful for much, like Io.
02:55:05 <DRMacIver> I mean useful in the sense of "I can write them well" more than what I can achieve in them. :)
02:55:47 <Randroid> DRMacIver: Yeah, I've always had a knack for learning languages thoroughly and well. Haskell's the first one in a long time that's been a real challenge for me. That's why it's probably my all-time favorite. I still consider myself a Haskell noob.
02:56:04 <Randroid> There's a certain poetry to it.
02:56:37 <Randroid> Watching values bob in and out of monads ...
02:56:42 <Randroid> Alright, I'll shut up. :)
02:57:28 <DRMacIver> Hmm. Actually the only language I'd claim to know well is Java. Wish I didn't though. I know enough Haskell and ML to be dangerous in them, but it would take some work before I was actually able to produce useful results consistently. Other than that, I can write Javascript, C, PL/SQL, etc. well enough to get by when I have to. :)
02:57:55 <DRMacIver> (Plus Scala, C#, Ruby, etc. with a very strong accent. :) )
02:58:57 <DRMacIver> That's a rather depressing list. I think I need to upgrade Haskell to the "Know well" category. :)
02:59:52 <Randroid> DRMacIver: It's not depressing at all. You're well ahead of the pack.
03:00:47 <yaxu> morning
03:00:51 <DRMacIver> Yeah, but I think that the vast majority of the pack are idiots, so that's not really very comforting. ;)
03:01:09 <DRMacIver> Morning yaxu
03:01:24 <Randroid> DRMacIver: I agree with you 100%. Most people can't code. http://www.codinghorror.com/blog/archives/000781.html
03:01:25 <lambdabot> Title: Coding Horror: Why Can't Programmers.. Program?
03:01:34 <yaxu> i'm having problems working out an algorithm, is there some forum for help with algorithm design?
03:02:22 <Randroid> Good luck, yaxu. Nice talking to you, DRMacIver. I gotta get some sleep. It's 6:01am where I am and I should not be awake. Not that I have anything to do today.
03:02:41 <yaxu> thanks Randroid, sleep well
03:02:54 <roconnor> moring
03:04:29 <DRMacIver> Morning roconnor
03:05:51 <wli> @hoogle :%
03:05:52 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':%'
03:05:57 <wli> @hoogle (:%)
03:05:58 <lambdabot> Did you mean: (:%)
03:05:58 <lambdabot> Prelude.undefined :: a
03:05:58 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
03:06:14 <wli> Where is the constructor for rationals...
03:07:02 <|Jedai|> yaxu: You could always start by describing your trouble here, most Haskell people seems to be decent with algorithms... ^^ (not me though)
03:07:59 <olliej> Cale: what's the intro to monads tutorial called?
03:08:29 <roconnor> wli: Ratio
03:08:43 <olliej> Cale: /me is trying to avoid threading an AST manually through a parser
03:08:48 <roconnor> at least that is the H98 name
03:08:57 <roconnor> @hoogle Ratio
03:08:58 <lambdabot> Data.Ratio :: module
03:08:58 <lambdabot> Ratio :: module
03:08:58 <lambdabot> Data.Ratio.Ratio :: data Ratio a
03:09:07 <roconnor> I guess Data.Ratio now.
03:10:14 <yaxu> well i have strings like {foo bar, bar foo} where order of the word groups delimited by commas isn't important, so that {foo bar, bar foo} is the same as {bar foo, foo bar}
03:10:44 <xerox> olliej: All About Monads? Monads as Containers? Monads as Computations?
03:10:53 <yaxu> and i want to group these by repeating elements, so for example {foo bar, bar foo} is grouped with {beep bap, bap beep}
03:11:06 <olliej> xerox: i recall there being a very basic intro
03:11:15 <olliej> xerox: for people who are clueless :D
03:11:22 <xerox> olliej: the latter two are like that
03:11:31 <wli> roconnor: Ratio not in scope.
03:11:46 <wli> <interactive>:1:4: Not in scope: data constructor `Ratio'
03:11:46 <roconnor> wli: you have imported the module?
03:11:54 <wli> >> :m + Data.Ratio
03:11:54 <wli> >> let Ratio x y = 5/2 in (x, y)
03:11:56 <roconnor> wli: import Data.Ration
03:11:58 <roconnor> wli: import Data.Ratio
03:12:08 <yaxu> but because order isn't important, i want {foo bar, bar qux} to be grouped with {fred barney, ostrich fred}
03:12:10 <xerox> :t 5%2
03:12:12 <roconnor> oh
03:12:12 <lambdabot> forall t. (Integral t) => Ratio t
03:12:22 <roconnor> wli: the constructor is not exported
03:12:37 <roconnor> wli: you can use numerator and denominator functions
03:12:42 <yaxu> this is complicated because the structures can recurse, like {a b, {b, c d} e}
03:12:59 <wli> Irritating as all @#%$
03:13:16 <yaxu> so i guess my problem is trying to find a canonical way of representing repeating structure
03:13:57 <yaxu> well maybe my real problem is i don't know what area i should be reading in to understand this kind of problem better
03:14:05 <roconnor> wli: If you want to cheat you can import GHC.Real
03:14:13 <yaxu> is it category theory?
03:14:22 <roconnor> wli: I did that to get a fast rational power funciton.
03:14:35 <roconnor> well, to make a fast rational power function.
03:16:44 <yaxu> or maybe my underlying problem is Not Enough Coffee
03:17:02 <kayess> eivuokko: thanks
03:19:19 <jedai> yaxu: I'm not sure I understand properly, it seems that there is only two possibilities : one word common across comma or two words common across comma
03:20:21 <jedai> yaxu: Shouldn't you represent a group of words by a set, it will allow you to check easily how many words are common across comma, and will not differentiate them based on order
03:21:02 <wli> Bang projecteuler #137 dead
03:21:43 <gle1> @seen SamB
03:21:44 <lambdabot> SamB is in #perl6 and #haskell. I last heard SamB speak 11h 27m 42s ago.
03:21:52 <gle1> @seen SamB_XP
03:21:52 <lambdabot> SamB_XP is in #haskell-blah and #haskell. I don't know when SamB_XP last spoke.
03:22:40 <yaxu> jedai: well i've been enumerating them, for example {a b {c b d, e}, b e} as {1 2, {3 2 4, 5}, 2 5}
03:23:38 <jedai> yaxu: Ok, and you sort them to avoid order related problem I suppose ?
03:23:39 <yaxu> jedai: but the enumeration looks quite different for {b e, a b {c b d, e}}, even though they're equivalent strings in my system
03:24:38 <gle1> @wiki MonadCont done right
03:24:38 <jedai> yaxu: Ok, brute-force solution
03:24:38 <lambdabot> http://www.haskell.org/haskellwiki/MonadCont_done_right
03:24:56 <jedai> yaxu: You create a datatype Word
03:25:09 <yaxu> jedai: yes, i guess sort them in a way that ends up with the same enumeration no matter what order the parts are in
03:25:52 * yaxu nods
03:26:18 <jedai> yaxu: That can be Key String | Pair (Set Word) | List (Set Word)
03:26:30 <gle1> SamB: Could you please give me a clue about EmptyMonad magic at  http://www.haskell.org/haskellwiki/MonadCont_done_right
03:26:31 <lambdabot> Title: MonadCont done right - HaskellWiki
03:27:01 <jedai> yaxu: and deriving Eq (and Ord to make them easy to stock in Set)
03:27:51 * wli updates.
03:28:07 <xpika> how do i join the haskell cafe mailing list? nabble gets denied
03:28:12 <jedai> yaxu: If you do it like that, the (==) on Set will do the hard work of ignoring the order and you'll have parse {a b {c b d, e}, b e} == parse {b e, a b {c b d, e}}
03:28:29 <yaxu> oh wow
03:28:45 <yaxu> so it was a haskell question after all :)
03:29:27 <yaxu> that's really nice, so i should be reading the haskell docs for Set
03:29:31 <yaxu> jedai++
03:30:04 <jedai> yaxu: Wait a second before thanking me, I'm not too sure it will work in all your cases
03:30:49 <yaxu> ok :)
03:30:50 <jedai> yaxu: but I'm reasonably sure it's a sane base and you'll be able to get exactly what you want on it
03:31:29 <hpaste>  wli annotated "Nuggets (PE#137)" with "the nugget to end all nuggets" at http://hpaste.org/2316#a2
03:32:49 <yaxu> jedai: so is this set theory?
03:33:19 <wli> Heck yeah.
03:33:59 <jedai> yaxu: I wouldn't call it "theory", it's just that Set (the datatype) ignore order on comparisons like real sets in mathematic
03:34:34 <yaxu> i see
03:35:23 <wli> Forget the first 15 nuggets, I can find the first 1000 in 0.15s.
03:36:23 <jedai> yaxu: I think what you want for your binary relation is a recursive function on that datatype that checks your requirements, but you'll better formalise them better
03:36:48 * DRMacIver mutters
03:36:55 <jedai> yaxu: since I don't really understand how you're recursion will be proceding
03:36:57 <DRMacIver> I still find Haskell operator definitions very awkward. :-/
03:37:09 <wli> DRMacIver: Which in particular?
03:37:13 <DRMacIver> wli: Syntactically I mean.
03:37:55 <wli> DRMacIver: Parsing algorithms which handle "normal" operator precedences in conjunction with application by juxtaposition are unusably slow.
03:37:56 <jedai> DRMacIver: ? You specify infixity priority and you write their definition simply, what's awkward in that ?
03:38:28 <DRMacIver> jedai: Particular irritations include the character set restriction in general and the requirement that infix constructors begin with : in particular.
03:38:51 <wli> DRMacIver: Also, it takes what amounts to natural language parsing algorithms to handle normal mathematical operator behavior.
03:39:32 <jedai> DRMacIver: Ok in that sense, though some conventions help to avoid the most painful operator definition weirdness... ^^
03:39:35 <yaxu> but if {a b, b c} and {f h, e f} are enumerated as {1 2, 2 3} and {1 2, 3 1}, i'm still not sure how Set would help me see them as the same thing.  i guess i can just brute force to try to compare every possible arrangement (in this case there's only two)
03:39:59 <DRMacIver> wli: *shrug*. Having used ML's much less restrictive fixity declarations, I know that you can get usably fast and acceptably non-irritating operator definition. :)
03:40:23 <DRMacIver> Although I suppose it's possible that this is more due to a habit of declaring only a few operators as infix than anything else.
03:40:33 <wli> DRMacIver: Okay, if you're willing to tolerate ML's restrictiveness, then Haskell's are more restrictive.
03:40:40 <jedai> yaxu: For example you can have your function check how many member are common to the two part of your Pair
03:40:48 <wli> DRMacIver: It's also not true that they need to be prefixed by :
03:40:56 <DRMacIver> wli: Constructors do.
03:41:04 <wli> DRMacIver: Constructors yeah.
03:41:14 <DRMacIver> Which is what I said.
03:41:51 <jedai> yaxu: You just have to fold on one of the member of the Pair (which is a List (Set Word)) to get how many elements are common...
03:41:59 <DRMacIver> Anyway, I'm not saying that ML's infix operators are perfect either. I'd just like to be able to define some sensible operators without it looking like line noise. :)
03:42:11 <wli> sum_{k=0}^n C(n,k)^6 mod 7 hmm
03:42:17 <jedai> yaxu: Well it's harder to do but you can do it
03:43:10 <jedai> yaxu: My main problem is how do you deal exactly with the recursivity ?
03:46:12 <yaxu> well i have type Structure which can be Polymetry [Structure] | Cycle [Structure] | Atom String
03:46:16 <jedai> yaxu: I think you should really try to write formally what you want exatly and then you'll have your function easily (I think)
03:47:01 <yaxu> order matters in Cycle, but not in Polymetry
03:47:45 <jedai> yaxu: Ok, I think you'll want to change Polymetry [Structure] for Polymetry (Set Structure) then
03:47:56 <jedai> yaxu: And then ?
03:48:19 <yaxu> an Atom is a word, a Cycle is a list of Structures separated by spaces, and a Polymetry is a list of structures separated by commas and surrounded by braces
03:48:24 <yaxu> jedai: aha, interesting
03:49:35 <jedai> yaxu: That's not exactly what you said, in your examples, order didn't seem to matter in your Cycle, did I misunderstand ?
03:50:00 <yaxu> jedai: yes sorry, order does matter in Cycle
03:50:27 <yaxu> foo bar is not the same as bar foo, but {foo, bar} is the same as {bar, foo}
03:50:42 <jedai> yaxu: Ok
03:51:08 <jedai> yaxu: foo bar /= bar foo
03:51:14 <yaxu> jedai: and when i'm comparing, i don't want to compare based on String, but instead based on patterns of repetition
03:52:04 <jedai> yaxu: Hmmm, that's where it becomes fuzzy for me...
03:52:37 <jedai> yaxu: foo bar == a b ?
03:53:29 <yaxu> well enumerationOf("foo bar") == enumerationOf("a b")
03:54:17 <yaxu> and enumerationOf("{foo bar, bar qux}") == enumerationOf("{a d, d f}")
03:54:28 <yaxu> and because the order of Polymetry doesn't matter,
03:54:41 <yaxu> and enumerationOf("{foo bar, bar qux}") == enumerationOf("{d f, a d}")
03:55:16 <jedai> yaxu: There, the order of your cycle don't matter anymore ?
03:56:12 <yaxu> it does, the cycles there are "foo bar", "bar qux", "d f" and "a d"
03:56:29 <jedai> yaxu: Ok, I understand
03:56:54 <ndm> @messages
03:56:55 <lambdabot> You don't have any new messages.
03:57:30 <yaxu> but my problem is that enumerationOf on that last one makes  "{1 2, 2 3}" and "1 2, 3 1"
03:57:34 <yaxu> sorry,
03:57:38 <yaxu> but my problem is that enumerationOf on that last one makes  "{1 2, 2 3}" and "{1 2, 3 1}"
03:58:15 <yaxu> so i want "{1 2, 2 3}" == "{1 2, 3 1}"
03:59:04 <yaxu> because they're two representations of the same pattern
03:59:44 <yaxu> well that's clarified the problem a lot for me anyway, and using Set will likely help me elsewhere
03:59:55 <yaxu> i feel i'm spamming up the channel now tho :/
03:59:57 <cinimod> In the haddock for ByteString, drop :: Int -> ByteString -> ByteString
04:00:32 <jedai> yaxu: Ok, but for "{1 2 3, 1 4}" and "{1 2, 1 3}" ?
04:00:49 <cinimod> but :t B.drop give GHC.Int.Int64 -> B.ByteString -> B.ByteString
04:01:01 <jedai> yaxu: They's not equal ?
04:01:02 <xerox> cinimod: is B Data.ByteString.Base ?
04:01:10 <yaxu> jedai: that's right
04:01:13 <Syzygy-> yaxu: What you basically want is str1 == str2 iff there is a sigma in S_n, for n = length . nub . enumerationOf $ str1, such that enumerationOf str1 == sigma . enumerationOf $ str2, right?'
04:01:43 <xerox> cinimod: D.B.Base has got the Int64 version, Data.ByteString the Int one.
04:01:50 <cinimod> xerox: import qualified Data.ByteString.Lazy as B
04:01:55 <xerox> ah.
04:02:08 <xerox> cinimod: right.
04:02:19 <cinimod> Should I just import Data.ByteString?
04:02:49 <xerox> cinimod: maybe it's better to use fromInteger and use the .Lazy version.
04:03:22 <xerox> cinimod: you can peek at the implementation and see if they differ, they should I think.
04:03:59 <cinimod> xerox: the problem is I want to use a state monad and I need to declare StateMonad something m
04:04:23 <jedai> Syzygy-: Almost, but you can also change the order across the comma as you want
04:04:25 <cinimod> Now Int64 doesn't seem to be exported so ghci complains
04:04:32 <yaxu> Syzygy-: sorry i don't understand not having any math background, although i can say that we're just discussing the simplest case of the problem here
04:04:49 <xerox> cinimod: you can import Data.int
04:04:55 <xerox> ... Data.Int even.
04:06:06 <cinimod> xerox: thanks that's done it
04:06:10 <xerox> cinimod: or just use fromInteger. Maybe look up how the implementation deals with Int/Int64.
04:06:11 <gle1> @messages
04:06:11 <lambdabot> You don't have any new messages.
04:06:34 <xerox> Alright :-)
04:06:48 <jedai> yaxu: Can you have {a b, c d e, a c} for example ?
04:06:50 <Syzygy-> yaxu: Try each possible sorting of the 1,2,3,4... you can get on one side, and see if one of them matches up with what you actually have on the other side.
04:06:57 <yaxu> jedai: yes
04:07:18 <cinimod> xerox: I suppose but I'm nervous about what's going on under the covers - I'm using very large integers and int overflows silently :-(
04:07:32 <Syzygy-> yaxu: This is basically the standard way of handling commutativity in algebraic structures...
04:07:42 <yaxu> jedai: and {a b, e b {f g, h i k, g h} f}
04:07:43 <xerox> cinimod: ah, then Int64 seems a sane thing to use.
04:07:55 <cinimod> xerox: exactly my thinking
04:08:04 <yaxu> Syzygy-: ok so a straightforward combinatorial search?
04:08:12 <Syzygy-> Possibly, yeah.
04:08:24 <jedai> yaxu: Are the two level related ? Is the f the same on the two level ?
04:08:28 <cinimod> anyway back to gadt fun
04:08:32 <yaxu> in practice these structures are going to be quite simple so no problem with that
04:08:39 <yaxu> jedai: yes
04:08:54 <yaxu> they're musical rhythms
04:08:54 <Syzygy-> You can do it more intelligent than just a combinatorial search, by trying to build up the relevant permutation from what you observe in the two strings; and bail out if you reach a contradiction, and flag it as equal if you don't and have consumed all information.
04:10:31 <jedai> yaxu: How much numbers are you going to need at max ?
04:11:12 <yaxu> lets say 32
04:11:23 <yaxu> but likely a lot less
04:12:41 <jedai> yaxu: Does the speed really matter ? (Meaning the algorithm Syzygy described will likely take some minutes (maybe a lot...) on a structure with 32 numbers
04:13:55 <yaxu> it does, but i think the longer the structure the more quickly a match can be ruled out
04:14:03 <yaxu> http://www.dailymotion.com/yaxu/video/x2ps1d_ascii-rave-in-haskell_music
04:14:06 <lambdabot> Title: Video ASCII Rave in Haskell - ascii, rave - Dailymotion Share Your Videos, http://tinyurl.com/388rjl
04:14:19 <yaxu> that's might illustrate the problem
04:14:31 <jedai> yaxu: I think you should try : Just make an enumerationOf the two structures and then cycle the permutations on one of the structure until you have :
04:14:38 <yaxu> the algorithm is looking for rhythms with the same structure
04:14:55 <jedai> yaxu: sigma (enumOf struct1) == enumOf struct2
04:15:26 <yaxu> yes that sounds good
04:15:34 <jedai> yaxu: If you use the datatype described before (with Polymorphic (Set Structure)) it will works
04:15:37 <wli> We so desperately need an unsigned arbitrary-precision integer type it's preposterous.
04:16:46 <jedai> yaxu: If you have problem of speed, a preprocessing could check conditions like depth level, length, etc... to quickly rule out most mismatch
04:17:24 <jedai> yaxu: You still have problems with big match but not frequently from what you're saying
04:17:27 <yaxu> i see, so quickly find possible matches first
04:17:48 <wli> Hmm, Fetish Night at Berbati's this weekend. I think I might go.
04:18:02 <yaxu> jedai/Syzygy-: thanks a lot!
04:18:12 <jedai> yaxu: Now that I think of it
04:18:40 <Syzygy-> yaxu: You do notice that the code > sigma (enumOf struct1) == enumOf struct2 was EXACTLY what I mentioned to begin with? ;)
04:19:15 <jedai> yaxu: For preprocessing, just make a function that replace all numbers by one and check "fun (enumOf struct1) == fun (enumOf struct2)"
04:19:46 <jedai> yaxu: It'll check that you have exactly the same structure on both sides very quickly
04:20:11 <yaxu> oh nice hack :)
04:20:54 <yaxu> so here sigma means set of possible
04:21:33 <jedai> Syzygy-: Yep, I'm summing what we have said (and note that this proposition only works because I suggested using Set for Parametric in the first place)
04:22:36 <jedai> yaxu: No, I meant sigma as in permutation, you'll have to cycle through all the permutations until you get the sigma that give equality or you run out of permutations
04:23:08 <yaxu> ok
04:23:15 <yaxu> it was "Polymetric" btw :)
04:24:47 <yaxu> er, "Polymetry", no matter
04:24:56 <yaxu> anyway, i'll get hacking
04:28:59 <Syzygy-> yaxu: Note that there is code floating around the intarwebs for listing perms and for applying them to points.
04:39:37 <wli> I'm pretty sure there's an elementary closed form for this. feh.
04:40:18 <wli> I'm pretty happy with my "nugget to end all nuggets," though.
04:46:23 <wli> (The elementary closed form referred to another problem.)
05:01:06 <gle1> @messages
05:01:06 <lambdabot> You don't have any new messages.
05:13:19 <wli> The way to make the Sieve of Atkin work on infinite lists is to generate infinite lists of the lattice points where 3*x^2-y^2=n and 4*x^2+y^2=n in an appropriate order.
05:14:31 <wli> Oh, 3*x^2+y^2=n, too.
05:27:01 <yaxu> great, i think i got it
05:28:36 * yaxu has lunch to celebrate
05:32:54 <wli> argh grouping into lists of ascending subsequences
05:33:39 <wli> groupBy (\(x,_,_) (y,_,_) -> x <= y) doesn't work
05:34:39 <roconnor> It would be cool to be able to give type synonyms at the GHCi prompt.
05:34:56 <wli> roconnor: I tried and failed to implement that.
05:35:02 <roconnor> wli: :(
05:35:09 <roconnor> I guess it is harder than it looks then.
05:35:18 <wli> roconnor: No, I just suck.
05:36:14 <wli> groupBy (\(x,_,_) (y,_,_) -> x >= y) seems to work for grouping into descending subsequences
05:37:17 <Saizan> > groupBy (\(x,_,_) (y,_,_) -> x >= y) [16,3,15]
05:37:27 <lambdabot>   add an instance declaration for (Num (t, t1, t2))
05:37:27 <lambdabot>     In the expression: 15
05:37:31 <Saizan> > groupBy (\x y -> x >= y) [16,3,15]
05:37:33 <lambdabot>  [[16,3,15]]
05:38:01 <Saizan> ?src groupBy
05:38:01 <lambdabot> groupBy _  []       =  []
05:38:01 <wli> Maybe not.
05:38:02 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
05:38:02 <lambdabot>     where (ys,zs) = span (eq x) xs
05:39:38 <DRMacIver> The differentiating regular expressions trick is really cute.
05:40:08 <DRMacIver> I've just figured out how it works, and it's actually rather simple, but it looks like complete magic when you first see it. :)
05:40:33 <DRMacIver> (Or at least it did to me)
05:45:39 <wli> Nice.
05:51:02 <wli> > let chunk xs = let chunk' xs = let (ys, z:zs) = span (\((n,_,_),(n',_,_)) -> n <= n') xs in case ys of { [] -> let ~((z',_):zs') = zs in [fst z] : chunk' ((z',z'):zs') ; _:_ -> map fst (ys++[z]) : chunk' zs } in chunk' $ zip xs (tail xs) in take 4 $ chunk [(n,x,y) | (n,x,y) <- [(4*x*x+y*y,x,y) | (x, y) <- [let x = total - y in (x, y) | total <- [2..], y <- [1..total-1]]], n `mod` 4 == 1]
05:51:11 <lambdabot>  [[(5,1,1),(17,2,1),(37,3,1)],[(13,1,3),(65,4,1)],[(25,2,3),(101,5,1)],[(45,3...
05:55:18 <iguana_> hi
05:55:26 <iguana_> beware, I have a monadic question
05:55:55 <Saizan> is this a work for lambda-man?
05:56:39 <iguana_> I read a string which contains commands that manipulate a stack, using a state monad
05:56:58 <iguana_> use a type of (state -> (state, result))
05:57:11 <iguana_> but I can't figure out how to define `fail' meaningfully
05:57:26 <Saizan> ?src fail State
05:57:27 <lambdabot> Source not found. stty: unknown mode: doofus
05:57:45 <Saizan> well don't worry, fail is not meaningful in the state monad
05:58:06 <Saizan> > runState (fail "foo") 1 :: State Int Int
05:58:08 <lambdabot>  Couldn't match expected type `State Int Int'
05:58:21 <Saizan> > runState (fail "foo") 1 :: (Int, Int)
05:58:23 <lambdabot>  Exception: foo
05:58:25 <iguana_> hm, so how do I represent a failure?
05:58:36 <Saizan> see? it just throws an exception
05:59:10 <Saizan> if you want a representation of failur in your monad you should combine it with the Either or Maybe monad
05:59:19 <iguana_> ok
05:59:23 <eivuokko> The exception was raised by Prelude.error.
05:59:49 <wli> Given x+y=n and 1 <= x, y <= n-1, 4*x^2+y^2 has a minimum at 4*n^2/5 at (n/5, 4*n/5) and a maximum at 4*(n-1)^2+1 at (1,n-1)... but it may be possible to do better.
06:01:16 <iguana_> but how? :)
06:01:57 <Saizan> iguana_: with a type like (state -> (state,Either String result)), fail s = \s -> (s,Left s)
06:02:41 <iguana_> ok, let me try that
06:02:43 <Vq^> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
06:02:45 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
06:03:06 <Saizan> then you want fail x >>= f == fail x so you've to implement >>= accordingly
06:18:56 <UWBP> For this reason patterns in any one equation are not allowed
06:18:56 <UWBP> to have more than one occurrence of the same formal parameter (a property called linearity x3.17,
06:18:56 <UWBP> x3.3, x4.4.2)
06:19:14 <UWBP> can anyone explain me what that sentence mean with an example?
06:19:53 <UWBP> I read it from "A Gentle Introduction to Haskell 98" page 15
06:21:04 <Saizan> UWBP: that you can't have a definition like foo x x = ..
06:21:25 <Saizan> UWBP: instead you use guards, like foo x y | x == y = ...
06:21:59 <wli> ah, squarefree
06:22:14 <Saizan> UWBP: in foo x x = .. you've two occurrences of the formal parameter x
06:23:18 <UWBP> in this case x is not a type but a variable, right?
06:23:38 <wli> Is there an xor operator for bools?
06:23:52 <xerox> wli: (/=)
06:23:53 <Saizan> UWBP: right
06:24:12 <UWBP> Saizan: i c :) thanks
06:24:23 <wli> xerox: That'll do.
06:53:07 <wli> @pl \k _ -> k > limit
06:53:07 <lambdabot> const . (> limit)
06:57:34 <wli> Is there a better way to write maybe False id $ p `Map.lookup` table ?
06:58:36 <wli> Just True == p `Map.lookup` table I suppose.
06:59:32 <swiert> isJust (p `Map.lookup` table)
07:00:12 <wli> isJust only checks Nothing vs. Just _, not True/False in the contents of Just
07:00:51 <roconnor> @type fromMaybe
07:00:53 <lambdabot> forall a. a -> Maybe a -> a
07:01:10 <roconnor> fromMaybe False $  p `Map.lookup` table
07:01:30 <roconnor> @hoogle lookupWithDefault
07:01:31 <lambdabot> Data.FiniteMap.lookupWithDefaultFM :: Ord key => FiniteMap key elt -> elt -> key -> elt
07:01:57 <roconnor> @hoogle lookup
07:01:57 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
07:01:57 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
07:01:57 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
07:02:24 <roconnor> @hoogle Map key elt -> elt -> key -> elt
07:02:25 <lambdabot> Did you mean: Map Key Elt -> Elt -> Key -> Elt
07:02:25 <lambdabot> Data.Map.findWithDefault :: Ord k => a -> k -> Map k a -> a
07:02:29 <roconnor> there
07:02:43 <roconnor> wli: findWithDefault False p table
07:03:02 <roconnor> M.findWithDefault
07:03:04 <wli> roconnor: Got it.
07:03:08 <roconnor> Map.findWithDefault
07:03:09 <roconnor> whatever
07:12:52 <wli> Thus far modifying the Sieve of Atkin so it generates a lazy list of primes is going awkwardly at best.
07:14:15 <chessguy> ok, i'm having a hard time working this out.
07:14:30 <wli> chessguy: Which is that?
07:14:37 <chessguy> i have d :: Data, and funcs :: [String -> Data -> Data]
07:14:57 <chessguy> now i'm trying to write foo :: String -> Data
07:15:32 <chessguy> which needs to run each function in func against each word in the string
07:15:39 <chessguy> building up the data structure
07:16:14 <Botje> chessguy: so .. foldr?
07:16:34 <wli> He's got the foldr bit down, but is having trouble with the step function.
07:16:44 <Botje> oh :)
07:16:52 <chessguy> Botje, hmm. maybe a foldr plus a zip?
07:17:18 <Botje> chessguy: do you need to apply the functions to d? or incrementally?
07:17:32 <int-e> @type \x y -> [x,x] <*> words y
07:17:33 <lambdabot> forall b. (String -> b) -> String -> [b]
07:17:42 <wli> There must be someone out there desperately interested in faster primes. Last I checked there were tons of people ridiculously obsessed with primes.
07:18:16 <Botje> gah. I need to re-read the applicative paper a few more times.
07:18:19 <Botje> :t <*>
07:18:21 <lambdabot> parse error on input `<*>'
07:18:24 <Botje> :t (<*>)
07:18:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:18:29 <chessguy> int-e, what's b there?
07:18:44 <int-e> chessguy: Data -> Data I guess. and the [x,x] would be funcs
07:19:06 * wli will probably spend all day farting around writing number theory bullcrap.
07:19:06 <int-e> chessguy: but I'm not sure whether that is what you want to do. it's just an idea.
07:19:39 <int-e> chessguy: and it still needs a fold to turn d :: Data and the result list of type [Data -> Data] into the final Data.
07:20:00 * ndm is also working on faster primes
07:20:14 <ndm> although using the simple algorithm
07:21:00 <chessguy> ok, suppose funcs is [f1,f2,f3], and (words string) is [w1,w2,w3]. what i want to wind up with is something that does f3 w3 (f2 w2 (f1 w1 d))
07:21:35 <ndm> chessguy: should be easy enough with direct recursion
07:21:36 <int-e> @type zipWith ($)
07:21:39 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
07:22:10 <ndm> plus an accumulator of course
07:22:19 <ndm> f fs ws = g d fs ws
07:22:34 <wli> Step 1: The Sieve of Atkin as a lazy list. Step 2: AKS primality testing. Step 3: Elliptic curve factorization.
07:22:37 <ndm> g acc (f:fs) (w:ws) = g (f w acc) fs ws
07:22:38 <int-e> @type foldl (flip id)
07:22:40 <lambdabot> forall c. c -> [c -> c] -> c
07:22:44 <ndm> g acc [] [] = acc
07:23:09 <chessguy> what i want will have a type that's something like Data -> [String -> Data -> Data] -> String -> Data
07:23:17 <int-e> so something like  foldl (flip ($)) d (zipWith ($) funcs (words string))
07:23:26 <wli> (maybe I'll get bored with it and write something else)
07:23:27 <ndm> if you want to foldl it, just foldl ... d (zip fs ws)
07:23:49 <int-e> @type \d funcs string -> foldl (flip ($)) d (zipWith ($) funcs (words string))
07:23:50 <lambdabot> forall b. b -> [String -> b -> b] -> String -> b
07:23:56 <ndm> (\(f,w) d -> f w d)
07:24:14 <ndm> @pl (\(f,w) d -> f w d)
07:24:14 <lambdabot> ap fst snd
07:24:25 <int-e> @pl \d funcs string -> foldl (flip ($)) d (zipWith ($) funcs (words string))
07:24:25 <lambdabot> (. ((. words) . zipWith id)) . (.) . foldl (flip id)
07:24:30 <ndm> foldl (ap fst snd) d (zip fs ws)
07:24:34 <ndm> i recokon...
07:25:06 <chessguy> @type foldl (ap fst snd) ?d (zip ?fs ?ws)
07:25:07 <lambdabot>     Occurs check: cannot construct the infinite type:
07:25:08 <lambdabot>       a = a1 -> b1 -> (a, b)
07:25:29 <ndm> i may have got the foldl the wrong way round, i usually do
07:25:31 <ndm> @type foldl
07:25:33 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:25:51 <ndm> @pl (\d (f,w) -> f w d)
07:25:52 <lambdabot> (`ap` snd) . flip (flip . fst)
07:26:18 <chessguy> the type of the final function can be re-arranged. i don't care about that
07:26:22 <ndm> @type foldl (\d (f,w) -> f w d) ?d (zip ?fs ?ws)
07:26:24 <lambdabot> forall a b. (?d::a, ?fs::[b -> a -> a], ?ws::[b]) => a
07:26:40 <int-e> what's wrong with zipWith? ;)
07:26:48 <pgavin> @pl (:[])
07:26:48 <lambdabot> return
07:27:40 <chessguy> int-e, there's nothing "wrong" with it. i think this way is a bit more readable
07:28:30 <ndm> i would have done it wtih a plain recursive function, not even using a foldl
07:28:35 <ndm> i find that most readable
07:29:04 <waern> what interesting papers are you currently reading? I need a break from studying from an exam :)
07:30:09 <chessguy> waern, you could look for that suffix trees papers linked on -cafe the other day
07:30:24 <ndm> waern: read my Uniplate one yet? ;-)
07:30:30 <waern> ndm: yep!
07:30:41 <waern> chessguy: hmm... I will
07:31:15 <ndm> waern: the simple dependently typed lambda calculus interpretter?
07:31:32 <waern> ndm: ah, yeah that one would work
07:31:37 <taruti> Is it possible to create a shared library containing haskell code that could be called by C-programs? (ghc 6.6.1 + i386 linux)
07:31:39 <chessguy> ndm++
07:31:42 <chessguy> int-e++
07:31:43 <chessguy> thanks guys
07:32:01 <desp> is it possible to get a human-readable string describing the type of a variable?
07:32:12 <ndm> waern:   http://www.cs.nott.ac.uk/~wss/Publications/SimplyEasy.pdf
07:32:12 <desp> for the purposes of error messaging
07:32:26 <wli> The Sieve of Atkin is a little tricky to do with lazy lists.
07:32:37 <ndm> @type typeOf
07:32:39 <lambdabot> forall a. (Typeable a) => a -> TypeRep
07:32:48 <ndm> > typeOf "neil"
07:32:49 <lambdabot>  [Char]
07:33:02 <waern> ndm: thanks, got it already
07:33:03 <desp> ndm++
07:33:44 <chessguy> > typeOf (typeOf "neil")
07:33:46 <lambdabot>  TypeRep
07:33:51 <ndm> i must update the uniplate paper actually, one section got trouned by the referees so i rewrote it
07:33:59 <chessguy> > typeOf (typeOf (typeOf "neil"))
07:34:00 <lambdabot>  TypeRep
07:34:16 <Saizan> > fix typeOf
07:34:17 <lambdabot>  TypeRep
07:41:16 <shapr> whee!
07:41:42 <ndm> @boing
07:41:42 <lambdabot> Maybe you meant: join ring
07:41:49 <ndm> @ring
07:41:55 <iguana_> it works!
07:41:56 <lambdabot>   CSE	 : "Abdullah","Lili Marziana","PhD Student","ATP  Australian Technology Park","","lilia"
07:41:56 <lambdabot> CSE	 : "Ahmed","Nadeem","Research Fellow","K17 501E","56908","nahmed"
07:41:56 <lambdabot> CSE	 : "Ahmed","Shabbir","PhD Student","K17 501-19","55301","shabbira"
07:41:56 <lambdabot> CSE	 : "Akand","Elma Hussana","PhD Student","K17 401-02","56913","akande"
07:41:56 <lambdabot> CSE	 : "Al-Kilidar","Hiyam","PhD Student","ATP Australian Technology Park","","hiyama"
07:41:56 <ndm> @help ring
07:41:58 <lambdabot> [330 @more lines]
07:42:00 <lambdabot>  @ring <user>, CSE phonebook
07:42:17 <ndm> @ring dons
07:42:17 <lambdabot>   CSE	 : "Stewart","Donald","PhD Student","K17 501-16","57225","dons"
07:42:33 <ndm> anyone want to make some prank phone calls?
07:43:03 <kdit> pl \x -> length x * length x
07:43:51 <iguana_> thanks Saizan
07:44:25 <ndm> @hoogle ^
07:44:25 <lambdabot> Prelude.(^) :: (Num a, Integral b) => a -> b -> a
07:44:25 <lambdabot> Prelude.(^^) :: (Fractional a, Integral b) => a -> b -> a
07:44:25 <lambdabot> Control.Arrow.(^<<) :: Arrow a => (c -> d) -> a b c -> a b d
07:44:39 <ndm> > 1 ^^ 2
07:44:40 <lambdabot>  1.0
07:44:44 <ndm> > 1 ^ 2
07:44:45 <lambdabot>  1
07:44:57 <ndm> @pl \x -> length x ^ 2
07:44:57 <lambdabot> (^ 2) . length
07:45:37 <roconnor> ndm: is your refriderator running?
07:46:10 <ndm> roconnor: ?
07:46:34 <kdit> pl \x -> f x * g x
07:46:39 <roconnor> apparently prank calls don't work so well on IRC.
07:46:50 <ndm> kdit: you need to put @ first
07:47:05 <kdit> @pl \x -> f x * g x
07:47:05 <lambdabot> liftM2 (*) f g
07:47:05 <ndm> ah, i remember that one :)
07:47:18 <kdit> thanks, ndm
07:49:54 <cognominal> I try to install CGI using Cabal and I get the error :
07:49:57 <cognominal> Configuring cgi-3001.1.5...
07:49:57 <cognominal> Setup.hs: cannot satisfy dependency base>=2.0
07:50:09 <cognominal> what could be the problem?
07:51:14 <ndm> cognominal: what version of ghc do you have?
07:52:49 <cognominal> 6.4.2
07:53:17 <ndm> cognominal: upgrade, 6.6.1 is the latest version
07:53:23 <cognominal> ok, thx
07:53:45 <desp> hrm
07:54:47 <desp> I'm trying to create a typeclass MappedEnum which would make instances of itself also instances of Enum
07:55:26 <desp> I'm running into the overlapping instances error, and I don't understand why
07:55:38 <ndm> instance MonadEnum a => Enum a where ... ?
07:55:54 <ndm> now imagine you define MonadEnum on Int
07:56:03 <desp> Mapped :)
07:56:07 <ndm> we have Enum Int, and MonadEnum Int => Enum Int
07:56:15 <ndm> I alpha renamed your problem ;)
07:56:48 <desp> shouldn't the second instance only apply if Int was already MappedEnum Int?
07:57:41 <ndm> yes
07:57:45 <ndm> but it doesn't know that yet
07:57:57 <ndm> if you ever do C a => B a, then you must turn on overlapping instances
07:58:03 <desp> I see, thanks
07:58:09 <ndm> i need them for Uniplate, to pull of much the same kind of trick
07:58:12 <desp> is this good style?
07:58:17 <desp> I'm trying to avoid redundant code
07:58:19 <ndm> if its the right thing to do, yes
07:58:33 <ndm> I have (Data a, Typeable a) => Uniplate a
07:59:03 <ndm> which is overlapping, but you assume anyone importing this would just use the predefine instances, and you get no conflict
07:59:48 <desp> yay, it works.
08:00:52 <desp> I get a warning about orphan instances, though
08:01:13 <ndm> have you defined this class in teh same module as the instance?
08:02:02 <hpaste>  desp pasted "orphan" at http://hpaste.org/2317
08:02:56 <desp> Warning: orphan instances: instance [overlap ok] base:GHC.Enum.Enum [.] = $f1
08:03:15 <desp> can I somehow export the Enum instance?
08:03:33 <ndm> no
08:03:51 <ndm> hmm, perhaps, but i dno't think so
08:06:13 <sfultong> anyone have a good idea how ArrowLoop works?
08:06:34 <desp> ndm: hm, I don't see a way to fix this.
08:07:10 <sfultong> alternatively, how I could construct a function rightLoop lp rp = lp ||| rightLoop lp rp
08:07:20 <ndm> desp, i don't see either
08:07:34 <desp> ok, thanks
08:09:46 <Saizan> ?type let rightLoop lp rp = lp ||| rightLoop lp rp in rightloop
08:09:48 <lambdabot> Not in scope: `rightloop'
08:09:53 <Saizan> ?type let rightLoop lp rp = lp ||| rightLoop lp rp in rightLoop
08:09:54 <lambdabot>     Occurs check: cannot construct the infinite type: c = Either b c
08:09:55 <lambdabot>       Expected type: a c d
08:10:26 <Saizan> sfultong: loop it's the generalization of fix to arrows, do you know how fix works?
08:13:18 <sfultong> saizan: unfortunately, not
08:14:32 <Saizan> ?type fix
08:14:34 <lambdabot> forall a. (a -> a) -> a
08:14:59 <Saizan> you can define it like this: fix f = f (fix f)
08:15:21 <Saizan> fix takes a function and applies it to itself
08:15:46 <sfultong> ah, interesting
08:16:04 <Saizan> so if the function is strict in the first argument you'll end up with non-termination
08:16:09 <Saizan> > fix (+1)
08:16:11 <lambdabot>  Exception: <<loop>>
08:17:32 <Saizan> > fix (1:) -- cons doesn't inspect the list before returning the constructor
08:17:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:18:45 <Saizan> every recursive function can be rewritten non-recursively with fix
08:19:25 <Saizan> > let fac' f n = if n == 0 then 1 else n* f (n-1) in fix fac' 5
08:19:27 <lambdabot>  120
08:19:34 <Saizan> ?type loop
08:19:36 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
08:21:19 <Saizan> loop is very similar, you give it an arrow (b,d) ~> (c,d) and it feeds the outputted d as input
08:22:13 <sfultong> but the d is just fed through unchanged...
08:23:18 <Saizan> your arrow will produce it lazily, the trick is to not consume it "faster" than you produce it
08:23:45 <Saizan> like in the fibonacci example
08:24:03 <sfultong> yeah, I was looking at the arrow-based fibonacci solution
08:24:27 <Saizan> do you understand the simply recursive one?
08:24:31 <Saizan> > fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:24:32 <lambdabot>  Parse error
08:24:38 <Saizan> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
08:24:40 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:24:57 <sfultong> yeah, I understand that one
08:25:46 <Saizan> > fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)) -- which can be written like this
08:25:48 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:26:05 <gle1> hello, can anybody help me with rank-2 types?
08:26:15 <sfultong> I was just trying to figure out the "fix" version :)
08:27:52 <Saizan> so it's true that fibs here is unchanged, the interesting part is that you're using it to produce itself
08:28:11 <Saizan> gle1: do you have a specific question?
08:28:22 <hpaste>  gleb pasted "Problem with higher rank types" at http://hpaste.org/2318
08:29:05 <gle1> Saizan: yes, I've just pasted and example
08:29:15 <wli> Cale suggested fix ((0:) . scanl (+) 1)
08:29:43 <sfultong> wli: how are you coming with Arrows?
08:29:45 <gle1> Saizan: please scroll to main problem goes here
08:29:51 <wli> sfultong: Zero progress.
08:30:14 <sfultong> wli: well, I'm making slow progress, but I haven't really done anything with them in the past few days
08:31:00 <sfultong> why isn't fix a prelude function?
08:32:21 <Saizan> it's in Contol.Monad.Fix
08:32:46 <wli> It gets implicitly imported through various other Control.Monad.* things.
08:32:55 <byorgey> sfultong: lots of things aren't prelude functions.
08:32:55 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
08:33:14 <Saizan> gle1: mmh, i think you need scoped type variables to let the two r in callAction and body signatures unify
08:33:49 <gle1> Saizan: thanks for reading that rather long chunk
08:34:29 <gle1> Saizan: Why callFoo works, but callAction doesn't?
08:36:01 <shapr> @yow !
08:36:01 <lambdabot> SANTA CLAUS comes down a FIRE ESCAPE wearing bright blue LEG WARMERS
08:36:02 <lambdabot> ... He scrubs the POPE with a mild soap or detergent for 15 minutes,
08:36:02 <lambdabot> starring JANE FONDA!!
08:36:40 <shapr> mmm code!
08:36:50 <Saizan> gle1: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables
08:36:54 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
08:37:02 <byorgey> @arr !
08:37:03 <lambdabot> Arrr!
08:37:12 <sfultong> @arr !
08:37:12 <lambdabot> Har de har har!
08:37:21 * gle1 follows Saizan's link
08:37:45 <Saizan> gle1: because callFoo doesn't have an explicit typesign
08:38:33 <Saizan> gle1: in callAction the r in the toplevel typesign is parsed as a distinct type variable from the r in body's typesign
08:38:59 <byorgey> whatcha workin' on, shapr?
08:39:46 <gle1> Saizan: I didn't know that. I guess I must read about scoped type vars, as you suggested. Thanks
08:39:47 <shapr> Fermat's Last Margin
08:39:52 <gle1> Saizan++
08:40:11 <shapr> byorgey: Heard of it already?
08:40:19 <Saizan> :)
08:41:02 <byorgey> shapr: isn't that the proof in which he wrote, "I have a wonderful margin in which to put a proof, but this proof is too small to fit?"
08:41:17 <shapr> That's Fermat's Last Proof, isn't it?
08:41:28 <byorgey> shapr: oh, yeah, I always get them confused
08:41:33 <xerox> A wonderful margin? (:
08:41:33 <byorgey> =)
08:42:35 <shapr> What is it? A distributed decentralized wiki-based darcs-backed research paper annotation tool called Fermat's Last Margin.
08:42:46 <shapr> How does it work? In short, wget the pdf/ps, throw it into imagemagick, create wiki pages for the resulting page images, and save text annotations into the darcs repo. If your repo is http accessible, anyone can grab your per-page annotations, and you can grab theirs.
08:43:43 <shapr> byorgey: If you read a lot of research papers in pdf/ps, it's nice to be able to take notes that are associated to the page, can be grep'd, and can be automatically shared with others.
08:43:44 <byorgey> shapr: oh, I didn't realize you were serious! =)
08:43:57 <byorgey> shapr: yeah, that sounds cool
08:44:07 <shapr> byorgey: And the idea is just that, if Fermat had this margin, it'd be the last one he ever needed!
08:44:43 <byorgey> shapr: hmm... but wouldn't you need a tablet or something to be able to easily "write on" the pdfs in imagemagick?
08:45:12 <ricky_clarkson> shapr: Are you talking about some existing software?
08:45:16 <shapr> That would be nifty, but for the first hack I'm just going for a wiki page that embeds the page image, then you can just add text notes.
08:45:28 <byorgey> shapr: oh, okay.
08:45:30 <pgavin> shapr: shouldn't you just be able to extract the text out of the pdfs without resorting to OCR?
08:45:36 <shapr> ricky_clarkson: It's just sort of working, hopefully an alpha release by tomorrow.
08:45:53 <byorgey> shapr: does it use HAppS?
08:46:00 <shapr> pgavin: I'm not doing OCR, just turning it into one image per page.
08:46:04 <shapr> byorgey: How did you guess?
08:46:09 <byorgey> hehe
08:46:13 <ricky_clarkson> I'll be an annoying tester if you like, sounds like something I could use.
08:46:20 <shapr> Spiffy!
08:46:41 <shapr> The coolest part (in my opinion) is that each research paper has comments enabled, and you can share with everyone!
08:46:41 <pgavin> shapr: oh, ok, I thought you were putting the contents of the papers into the wiki, I misunderstood
08:46:59 <shapr> Nah, I specifically don't want to do that, research papers almost always say "for personal use only"
08:47:13 <pgavin> yeah, ok :)
08:47:31 <shapr> Because of that, I make sure that only annotations are saved into darcs, and pdf/ps must be downloaded and page images generated for each person who installs it.
08:48:08 <pgavin> ok, right :)
08:48:19 <shapr> Hopefully that will beat the copyright issues before they start.
08:48:20 <hpaste>  (anonymous) annotated "Problem with higher rank types" with "(no title)" at http://hpaste.org/2318#a1
08:48:25 <pgavin> sounds like a pretty cool idea
08:48:31 <shapr> Thanks
08:48:35 <byorgey> shapr: I like it!
08:48:40 <shapr> :-)
08:48:44 <gle1> Saizan++
08:48:47 <ricky_clarkson> shapr: Then you could allow links between comments on separate documents, and reinvent the WWW. ;)
08:48:56 <conal> shapr: how will annotations be associated with locations in the paper?
08:49:21 <shapr> conal: I thought about doing lots of sections per page, but a prototype showed that one wiki page per page image does just fine.
08:49:25 <pgavin> it'll definitely save time afa trying to find papers on specific topics and then having to grok them
08:49:39 <shapr> pgavin: And it'll make it easy to download cited papers as well if people add links to those citations.
08:49:55 <shapr> And you'll be able to see if your questions are already answered by others, or just add your question and try to answer others.
08:49:59 <pgavin> yeah, sounds really useful :)
08:50:12 <gle1> Saizan: Thanks a lot, with your help I managed to fix types. In fact, callAction and body shouldn't be polymorphic in 'r', since result type of the whole computation is fixed to Maybe a
08:50:14 <conal> shapr: oh.  the annotations themselves would further pinpoint what they refer to?
08:50:38 <gle1> Saizan: But it's 'a' that was not scoped
08:50:40 <conal> shapr: i love the weaving together of everyone's comments.
08:50:43 <shapr> conal: Yup, any annotation system that requires more work is definitely not for 0.1 :-)
08:51:07 <shapr> conal: I'd like to be able to filter to just one person's comments at some point.
08:51:35 <shapr> Anyway, I don't know if this will be popular, or useful to anyone other than me, but I'll definitely use it lots.
08:51:57 <gle1> Saizan: I must admit I'm very confused about usage of 'forall' in Haskell. This keyword is too overloaded IMHO
08:52:12 <conal> shapr: would filtering take you beyond the wiki interface?
08:53:06 <shapr> conal: Not in my vague ideas, no. You'd just filter the darcs repo by patch authors and then look at the resulting wiki.
08:53:16 <gle1> Saizan: And error message mentioning 'r1' type variable is very confusing
08:53:56 <shapr> Since wikis are often very spammy, I had an idea to beat that... only pull from people you know and trust, and wiki changes are only allowed from 127.0.0.1
08:54:03 <conal> shapr: oh!  i'm starting to get it.  the wiki page is not editted, but only synthesized from darcs repos.  ??
08:54:25 <shapr> Well, I'm not sure.
08:55:00 <conal> shapr: is your idea that the whole user experience is via a wiki page?
08:55:03 <shapr> I think the basic idea is sound, and that further refinement of the idea should be done by whoever uses this tool.
08:55:06 <shapr> conal: yeah
08:55:19 <conal> shapr: :)
08:55:47 <shapr> Anyway, it should be working today, and hopefully I'll have a release tomorrow.
08:56:10 <conal> shapr: i think your joking, but i don't know
08:56:20 <shapr> Er, joking how so?
08:56:51 <conal> working today.  -- you've been tinkering with FLM for years haven't you?
08:56:53 <Cale> morning
08:56:55 <shapr> Well, yes
08:57:06 <conal> Cale: hi
08:57:30 <shapr> I had it working before without HAppS, but HAppS makes things much easier, so I think I can port over the formerly working code without much trouble.
08:57:50 <conal> shapr: wonderful!
08:58:38 <shapr> HAppS is really nifty. I like this job!
08:58:41 <byorgey> morning Cale
09:00:03 <byorgey> shapr: OOC, do you know if HAppS is currently looking to hire?
09:00:06 <sfultong> > fix id
09:00:09 <lambdabot>  Exception: <<loop>>
09:01:01 <shapr> byorgey: It's entirely possible, have you written Haskell software you can show off?
09:01:30 <byorgey> shapr: nothing very substantive, but I learn fast =)
09:01:53 <shapr> Well, write some code :-)
09:02:17 <byorgey> shapr: working on it =)
09:02:56 <wli> shapr: What sorts of code does it take to show off?
09:05:58 <conal> i could have sworn Data.Monoid or Data.Maybe provided a Monoid instance for Maybe a, but apparently not.  anyone know why not?  is it elsewhere in base?
09:07:14 <shapr> wli: I don't think there's anything specific, more that you've written code that shows you'll be able to hack on HAppS.
09:08:01 <shapr> Standard stuff like, clue with monads, clue with network servers, clue with web based stuff, etc
09:08:06 <wli> Well, userbases are sort of hard to come by regardless of what you do.
09:08:24 <wli> Clue with databases, too, presumably.
09:08:43 <byorgey> wli: HAppS doesn't use a database =)
09:09:01 <shapr> hiya thundergirl, learning Haskell?
09:09:08 <wli> Most useful applications need them (even if they don't use them).
09:09:15 <thundergirl> han shapr?
09:09:22 <reltuk> happs is a company?
09:09:26 <shapr> Quoi?
09:09:32 <shapr> Talar du svenska?
09:09:37 <shapr> Puhutko suomea?
09:09:46 <shapr> Parlez vous francais?
09:09:47 <byorgey> reltuk: yup
09:09:52 <thundergirl> quoi
09:10:06 <shapr> thundergirl: Are you learning Haskell?
09:10:09 <reltuk> wow....that's entirely unexpected :-p
09:10:18 <thundergirl> shaper do you speak english?
09:10:32 <shapr> thundergirl: Yes, but "han shapr" doesn't sound like English to me.
09:10:40 <thundergirl> han
09:10:47 <shapr> What does han mean?
09:10:51 <byorgey> reltuk: I think alexj owns it, and it employs shapr
09:10:52 <thundergirl> moiiiiiiii
09:11:06 <shapr> byorgey: yup
09:11:14 <thundergirl> do you spak french?
09:11:23 <shapr> Not really
09:11:25 <shapr> un petit peu
09:11:34 <thundergirl> mon cherie
09:11:43 <shapr> no hable espanol
09:11:47 <shapr> um, habla
09:11:50 <thundergirl> si
09:11:51 <lament> hablo :)
09:11:54 <shapr> Nor do I speak Portuguese.
09:11:59 <gkr> Haha.
09:12:00 <thundergirl> yo hablo muchas lenguas
09:12:04 <shapr> thundergirl: Are you here to learn Haskell?
09:12:10 <gkr> thundergirl hablas Haskell?
09:12:11 <Cale> conal: Huh, that is a rather strange omission. There ought to be a lifting instance.
09:12:19 <thundergirl> shepr
09:12:24 <thundergirl> ashapr
09:12:28 <thundergirl> shapr
09:12:36 <thundergirl> yo no hablo haskell
09:12:49 <gkr> :-(
09:12:51 <thundergirl> shapr
09:12:54 <shapr> yes?
09:12:59 <thundergirl> gkr sorry
09:13:05 <LeCamarade> http://bash.org/?245718
09:13:06 <thundergirl> no shapr
09:13:07 <lambdabot> Title: QDB: Quote #245718
09:13:09 <LeCamarade> :oD
09:13:26 * lament wonders at what point does flood protection kick in
09:13:30 <thundergirl> shapr i do'nt speak haskell
09:13:47 <shapr> thundergirl: This channel is here to learn Haskell. It's a programming language. Would you like to learn it?
09:14:04 <thundergirl> shapr
09:14:07 <gkr> HAHA
09:14:11 <thundergirl> one question
09:14:18 <gkr> thundergirl are you a bot?
09:14:18 <lament> i think thundergirl only speaks Shapr.
09:14:19 <thundergirl> please
09:14:22 <sfultong> even if you aren't here to learn it, it'll burrow into your brain
09:14:30 <reltuk> on ne parle pas haskell; on le ecrit
09:14:42 <thundergirl> burpppppppp
09:14:50 <thundergirl> ecaaaaaaaaaaaaaaa
09:14:53 --- mode: ChanServ set +o Philippa
09:14:54 <thundergirl> hannnnnnnn
09:14:59 <reltuk> this is so bizarre....
09:15:02 <lament> not really
09:15:09 <shapr> thundergirl: Hey, you're spamming.
09:15:17 <LeCamarade> I smell a kick coming ...
09:15:20 <thundergirl> sahpr no
09:15:22 <shapr> thundergirl: If you continue pasting random stuff into the channel, you'll get removed from the channel.
09:15:28 <gkr> shapr
09:15:32 <Cale> haha
09:15:33 <lament> shapr
09:15:33 <thundergirl> gkr
09:15:34 <gkr> sha sha prrrrrr!
09:15:37 <popcount> shapr, you are too patient.
09:15:37 <shapr> :-(
09:15:50 <LeCamarade> shapr: You have a weird fan. :o)
09:15:52 --- mode: ChanServ set +o shapr
09:15:54 <thundergirl> bye bye
09:15:57 <shapr> bye thundergirl
09:15:58 <lament> popcount: it's just cause of the "girl" in their nick
09:15:59 <gkr> Adis thundergirl.
09:16:09 <LeCamarade> thundergirl: Type /quit
09:16:13 <popcount> lament, lol
09:16:13 <Cale> shapr: How do you pronounce your nick anyway? Is it 'shaper', or is the a short?
09:16:17 <thundergirl> gkr :(
09:16:21 <Philippa> lament: no, he's always this patient
09:16:21 <shapr> Cale: shay-per
09:16:29 <thundergirl> i'm sad
09:16:29 <Cale> cool
09:16:34 --- kick: thundergirl was kicked by shapr (Kicked by shapr)
09:16:35 <lament> shapr: you mean it's not "shapr"?
09:16:48 <Igloo> Cale: shapr pronounces it difficult to everyone else in the universe, we discovered at ICFP 03 or so  :-)
09:16:53 <shapr> lament: shapr is short for shaper, and spoken the same way.
09:16:59 <mrd> what I'm amazed is how shapr managed to figure out she was a troll within 3 seconds of her joining the channel.
09:17:02 <Igloo> s/difficult/differently/ # eh?
09:17:06 <lament> thundergirl leaves, oerjan enters, coincidence? i think not!
09:17:07 <shapr> mrd: I'm especially good at that.
09:17:11 <Philippa> mrd: practice
09:17:17 <shapr> thundergirl: If you're not here to learn Haskell, you will be permanently removed.
09:17:20 <Cale> thundergirl: #haskell is a channel about programming, it's supposed to be at least roughly on topic.
09:17:26 <LeCamarade> They are both in, with different IPs.
09:17:32 <lament> mrd: he did?
09:17:41 <Philippa> thundergirl: you know gkr?
09:17:45 <gkr> Wait.
09:17:48 <gkr> I don't know her.
09:17:48 <oerjan> lament: there are no coincidences.  however, apart from that, you are wrong.
09:17:51 * LeCamarade thinks a `thunderboy' would have been kickbanned already ... ;o)
09:17:52 <thundergirl> no
09:17:55 <wli> When I see "shapr" I think of the Persian shahs whose names are often transliterated identically.
09:17:59 <shapr> heh
09:18:05 <shapr> How do you say shapr in Persian?
09:18:12 <Philippa> LeCamarade: you've not seen how long it takes to get kickbanned in here usually then
09:18:18 <lament> I'm still gonna think "shapr" and not "shaper"
09:18:29 <lament> if it were "shaper", it would be spelt as such :)
09:18:37 <lament> shapr, one syllable
09:18:39 <wli> shapr: "Shah-pur"
09:18:40 <thundergirl> i'm very happy
09:18:49 <thundergirl> hi gkr
09:18:50 <LeCamarade> Philippa: Some guy whose kickban I enjoyed took a while, but came in spoectacular fashion. Igloo swooped like a hawk. From nowhere.
09:18:52 <reltuk> thundergirl: are you on drugs?
09:18:54 <sfultong> wli: that's how I pronounced it in my mind
09:18:56 <gkr> "Shah-prrrr.
09:18:57 * byorgey somehow always knew it was pronounced "shaper"...
09:19:01 <thundergirl> no retulk
09:19:03 <int-e> . o O ( "I got kickbanned on #haskell and all I got was this lousy T-shirt." )
09:19:05 <popcount> Just ban thundergirl
09:19:07 <shapr> bye bye thundergirl
09:19:11 <wli> shapr: "Shapur" is an alternate transliteration.
09:19:11 <thundergirl> no reltuk
09:19:23 <LeCamarade> ?time thundergirl
09:19:31 <thundergirl> why shapr
09:19:40 <gkr> I like "Jey pi" as well.
09:19:43 --- kick: thundergirl was kicked by shapr (Kicked by shapr)
09:19:46 <lament> wow... this is like the best channel to troll
09:20:01 <reltuk> lament: I somehow doubt that's true
09:20:03 <shapr> Except that removals are permanent.
09:20:07 --- mode: ChanServ set +b thundergirl!*@*
09:20:08 <LeCamarade> Yeah. Nobody kickbans here. :o)
09:20:12 <byorgey> lament: let's hope trolls don't figure that out en masse...
09:20:22 <mrd> @palomer
09:20:23 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
09:20:23 <popcount> Why do we have an identity function???!?!! It doesn't do anything!
09:20:31 * shapr hugs popcount 
09:20:35 <Cale> popcount: Are you trolling? :)
09:20:43 <Philippa> popcount: yeah, and sometimes that's the function you want to pass in to another function
09:20:43 <popcount> Cale, yeah
09:20:44 * araujo remembers when this was a quiet place with <100 users
09:20:46 <mrd> sounded an awful lot like palomer for a sec there
09:20:55 <shapr> heh
09:21:05 * shapr remembers when this was a quiet place with <2 users
09:21:08 --- mode: shapr set -o shapr
09:21:08 <lament> araujo: like #haskell.es these days? :)
09:21:30 <araujo> lament, yeah, exactly like day , golden days
09:21:32 <LeCamarade> Yeah, but with SPJ holding such concerts as the OSCON one ... we are headed the #ubuntu way.
09:21:41 <lament> all that happens on #haskell.es is some guy with "Fuck You" in the hostname repeatedly joining and parting.
09:21:42 <shapr> I'm happy about that.
09:21:49 <int-e> does anybody remember this guy? http://int-e.home.tlink.de/tmp/l33t
09:21:52 <wolverian> SPJ held a concert?!
09:21:59 <popcount> Cale, trolling is a form of art (mine was rather uncreative)
09:22:01 <shapr> I'm happy that #haskell is reaching towards #ubuntu in size.
09:22:01 <byorgey> wolverian: yeah, it was awesome!
09:22:08 <gravity> wolverian: He played the whiteboard
09:22:13 <byorgey> wolverian: pyrotechnics and everything
09:22:24 <wolverian> what a rocker
09:22:28 <shapr> int-e: Hah, that was funny!
09:22:37 <reltuk> ?quote l33t
09:22:38 <lambdabot> No quotes match. Where did you learn to type?
09:22:52 <araujo> lament, there has not been too much discussions lately .... but we even have a small wiki and some collaborators posting stuff sometimes :-)
09:22:55 <Cale> Heh, I've had that pulled on me in nearly in reverse. In #lisp I asked how to stop the compiler for shouting at me whenever I wrote a function which didn't use one of its parameters, and was faced with mass confusion over why I'd ever want to do that.
09:22:58 <mrd> I learned to type on IRC.  it explains a lot.
09:23:21 <araujo> Plus, #haskell.es is one of the bigger PL channel in spanish! *proud* haha
09:23:29 <lament> \o/
09:23:29 <shapr> int-e: That's totally quotable.
09:23:48 <Philippa> Cale: heh. "Because I know better than the compiler, why else would I use lisp?"? :-)
09:23:50 <shapr> Cale: What do you mena?
09:24:05 <Philippa> shapr: ever seen the church encoding of the booleans? That'd be an example
09:24:27 <Cale> shapr: The common lisp compiler I was using gave warnings every time you constructed a function which ignored one of its parameters.
09:24:49 <Cale> Obviously such functions come up all the time as parameters to higher order functions.
09:24:51 <shapr> Cale: weird!
09:24:56 <lament> imagine if haskell did that :)
09:25:06 <lament> Warning: You're not using all elements of an infinite list!
09:25:24 <conal> Cale: lifting instance?
09:25:28 <LeCamarade> Loving Lisp is a sign that one has not used an ML-based language yet.
09:25:36 <Cale> conal: (Monoid a) => Monoid (Maybe a)
09:25:42 <lament> LeCamarade: explain Liskell, then.
09:25:47 <Cale> conal: But it doesn't seem to be there
09:25:48 <conal> Cale: got it
09:25:58 <mrd> LeCamarade: nah, SML is not that great
09:26:01 <LeCamarade> Liskell, yeah ... but all those parens? :o)
09:26:11 <popcount> LeCamarade, those parens have a use
09:26:22 <mrd> Cale: like const?
09:26:28 <conal> Cale: that's not the instance i had in mind.  maybe that's why there isn't a std instance
09:26:28 <Cale> mrd: yeah
09:26:29 <LeCamarade> popcount: So does precedence and operators.
09:26:35 <mrd> Cale: but what else?
09:26:44 <reltuk> LeCamarade: hating the parens in lisp is a sign you haven't written much lisp yet
09:26:58 <mrd> you can turn off the warnings case-by-case, i'm not aware of a global flag
09:27:11 <LeCamarade> reltuk: It is a sign I hate writing abstract syntax tree. Compilers are for a reason.
09:27:11 <Philippa> reltuk: that, or that you have a shitty editor
09:27:13 <popcount> LeCamarade, right, but the  <-, = and ->  syntax in Haskell is rather arbitrary.
09:27:28 <Philippa> I don't like seeing the parens in lisp in my usual mailreader. No doubt someone'll tell me to use an emacs-based one
09:27:32 <reltuk> LeCamarade: in particular, it makes macros reasonable to be employed in the average program...just look at how obtuse ocaml p4 is
09:27:33 <mrd> anyhow, lisp is not really a language for higher order functional programming.  no static types.
09:27:55 <lament> what do static types have to do with higher order functional programming?
09:27:56 <byorgey> conal: what instance did you have in mind?  I'm curious
09:28:09 <popcount> Trolls have takes over the channel!
09:28:13 <popcount> taken*
09:28:16 <Cale> mrd: well, suppose you have some function that takes a function as a parameter to tell it how to do some local part of its computation -- some cases will need all the information the function can give them, and some won't -- I don't have a particular example on hand
09:28:20 <lament> popcount: i blame thundergirl
09:28:22 <mrd> CL has const already actually -- 'constantly'
09:28:33 <LeCamarade> I never really get to need macros, because the Haskell type system (and other similar veins) take(s) care of the need cases.
09:28:34 <lament> it's actually called constantly?
09:28:37 <mrd> yep
09:28:52 <lament> LeCamarade: of course you need macros. Consider "do", which earlier versions of haskell didn't have.
09:28:52 <popcount> mrd, that sounds very Schemy
09:28:57 <shapr> popcount: And yes, I'm always that patient. Some bright people still need to have the rules explained to them several times in different wayis.
09:28:58 <shapr> ways*
09:29:13 <Cale> mrd: But for example, Data.Map.insertWithKey takes a function of type (k -> a -> a -> a), which takes the key, the old and new value, and produces the value to be inserted into the new map
09:29:16 <hpaste>  conal pasted "two Maybe Monoid instances" at http://hpaste.org/2319
09:29:17 <LeCamarade> lament: No it does. :o)
09:29:24 <LeCamarade> s/No/Now/gi
09:29:26 <Cale> mrd: Sometimes, you might only have it depend on the key and the new value, say.
09:29:27 <Philippa> LeCamarade: if you never have a use for macros in haskell, you're not pushing it hard enough
09:29:37 <popcount> shapr, exponential base 10 kicking starting at 10 minutes seems to be good too.
09:29:42 <mrd> Cale: so, in CL, you make use of optional/key/rest parameters
09:30:07 <lament> LeCamarade: it does now, but at soon as somebody discovers something else that would benefit from syntax sugar... you're screwed
09:30:22 <LeCamarade> Philippa: When I do, I never say `I need macros ...'. Nope. It never even occurs to me before I use some snazzy currying or something. Never needed them over another possibility. Where have you needed them?
09:30:22 <mrd> like Arrow syntax
09:31:00 <Philippa> LeCamarade: doing what amounts to delegation in instances can get very tedious indeed, for example
09:31:06 <reltuk> LeCamarade: what about syb-with-class?
09:31:08 <LeCamarade> lament: Yeah, fixed syntax is the price we pay for not designing an abstract syntax tree in a forest of parents everytime we want to write anything beying hello.lsp
09:31:15 <Cale> mrd: You could, but that's no excuse for the compiler complaining when you don't. :) Functions which are constant in one or more of their parameters are perfectly good functions.
09:31:17 <hpaste>  mdmkolbe pasted "Any style optimization suggestions?" at http://hpaste.org/2320
09:31:32 <mrd> Cale: one of the reasons I came to Haskell is because I wanted a real functional language.  CL has some of the essentials, but it does not encourage the style.
09:31:37 <Cale> mrd: Right.
09:31:39 <shapr> popcount: :-)
09:31:40 <lament> LeCamarade: mind you, i'm a big fan of haskell syntax. But still, you can't say "haskell is cool enough that macros are unnecessary"
09:31:47 <Cale> mrd: I found it extremely frustrating to use.
09:32:01 <lament> LeCamarade: (and i think lisp is damn ugly :))
09:32:02 <byorgey> conal: I see.  yes, strange neither of those are in the libraries
09:32:06 <Cale> (I already knew haskell at the time)
09:32:15 <popcount> shapr, randomly kicking for effect is another suggestion
09:32:21 <popcount> shapr, :)
09:32:24 <mdmkolbe> lambdabot: TH is macros for Haskell
09:32:33 <Cale> I ended up using macros to get laziness, and something kind of similar to do-notation for the state monad.
09:32:35 * Philippa has also wanted syntax for something that's somewhere between let and mdo
09:32:47 <mrd> mdmkolbe: thank you for explaining that to her
09:32:47 <Philippa> (that is, I want to use my own set of functions to do binding with, but I don't want to have to supply a monad)
09:32:49 <shapr> I usually am patient until I am convinced that I have gotten my point across. If the person continues to be disruptive, they are removed. Permanently. The end.
09:32:57 <popcount> TH is not documented and is not a real alternative when compared to e.g. the PLT macro system.
09:33:10 <Cale> mdmkolbe: Normally 'where' goes at the start of a line
09:33:11 <shapr> Oh, and I'm willing to give someone another chance ten years after they've been banned.
09:33:13 <Philippa> graphs with identity on nodes would be an obvious use case for that
09:33:16 <popcount> It are always the people who haven't used TH who claim TH is perfect.
09:33:24 <lament> shapr: haha
09:33:25 <reltuk> I'm under the impression that syntax isn't really fixed...with things like TH and the likes; they're just obtuse enough to not be employed in the average program, whereas lisp macros are really right in your face and your more likely to employ them the first time it make sense within your application
09:33:27 <Cale> mdmkolbe: also, chained $'s are suboptimal stylistically.
09:33:28 <Philippa> shapr: someone'll hold you to that over smerdyakov sometime
09:33:32 <LeCamarade> lament: Syntax makes a language programmer-centric. I subscribe to that design philosophy. (Even though my next thing involves building a snazzy ... Scheme R6RS). :o)
09:33:37 <shapr> Philippa: Hm, maybe I shouldn't have said that.
09:33:47 <Philippa> reltuk: TH is a PITA
09:33:50 <lament> LeCamarade: cognitive dissonance? :)
09:33:50 <Philippa> sadly :-(
09:33:52 <mdmkolbe> popcount: heh, ok, yeah, I'm guilty of that
09:33:54 <Adamant> Liskell
09:34:12 <reltuk> Philippa: I haven't really looked at it much...but if it's anything like ocaml's p4, I believe ya :)
09:34:14 <LeCamarade> lament: Yep. Parens burn my eyes. :o)
09:34:25 <hpaste>  conal annotated "two Maybe Monoid instances" with "choosing between Monoid instances" at http://hpaste.org/2319#a1
09:34:28 <Philippa> reltuk: no, it's significantly different - closer to MetaOCaml
09:34:29 <conal> comments please?
09:34:31 <LeCamarade> I can never count beyond three parens in a row. I start to blur.
09:34:33 <mrd> LeCamarade: (((()))) -- attack of the killer parens!
09:35:00 <conal> oh, oops.  i didn't realize what annotate did =P
09:35:01 <mrd> really though, if you're counting parentheses, you're making a huge mistake
09:35:02 <lament> LeCamarade: can't there be an emacs mode that removes most of the parens from sight
09:35:02 <reltuk> Philippa: I'll have to spend some time with it; /me hopes he comes back with his sanity
09:35:14 <lament> LeCamarade: you only need those parens that are not otherwise obvious from the indentation
09:35:17 <sfultong> http://www.xkcd.com/297/ -- he needs to see Haskell
09:35:18 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
09:35:41 <LeCamarade> It is not the counting. It is their existence. In fact, when I write Lisp-family code, I put parens where I put C-family braces.
09:35:44 <LeCamarade> :o)
09:35:55 <mrd> LeCamarade: yes, we hate that style of code =)
09:36:00 <Philippa> you want I-Expressions, then?
09:36:30 <hpaste>  Cale annotated "Any style optimization suggestions?" with "how I might write it (very minor style changes)" at http://hpaste.org/2320#a1
09:36:38 <mdmkolbe> Philippa: I-Expressions?
09:36:44 <lament> Philippa: do they exist?
09:36:46 <LeCamarade> mrd: See? :o) So when I discovered ML, and it looked like a pretty, pretty Lisp (with a type system better than x86 assmebly's) I never ever looked back.
09:37:05 <LeCamarade> I actively fight Lispers when I don't have a bout of carpal tunnel syndrome like now.
09:37:07 <lament> A mixture of braces and significant indentation would probably be quite tolerable
09:37:15 <lament> and can be straightforwardly converted into sexprs
09:37:25 <DRMacIver> Ho hum. Suppose I have a "Set a" and an "a -> b" and I want to construct the obvious "Map a b". What's a good way of doing this? (A reasonable amount of laziness would be preferred)
09:37:56 <Philippa> lament: I don't know if they've been implemented, there've been proposals
09:37:57 <mrd> LeCamarade: haskell pulled it off much better
09:38:05 <DRMacIver> (I mean, I can obviously hack out ways of doing it. I'm just looking for a nice solution)
09:38:22 <mrd> (of course I say that, that's why I'm here and not #sml)
09:38:49 <Adamant> LeCamarade, I'm kind of the opposite. the more parens, the happier I am.
09:38:50 <shapr> LeCamarade: Get a kinesis contoured keyboard
09:38:53 <shapr> helps with RSI
09:38:57 <LeCamarade> mrd: Yep. I am an ML-family freak. :o) Ocaml for speed, Haskell for revelation and jargon.
09:39:03 <shapr> also, work from a couch so you can change positions often
09:39:06 <wli> DRMacIver: Map.fromList . (id &&& f) . Set.toList
09:39:21 <mrd> when I write CL I use paredit and all sorts of cool structure-editing goodness, so I don't really think about parens
09:39:23 <LeCamarade> shapr: Wow.
09:39:28 <int-e> DRMacIver: hmm. mapFromSet f = Map.fromDistinctAscList (\x -> (x, f x)) . Set.toAscList
09:39:42 <int-e> DRMacIver: but you won't get much laziness, it just isn't possible
09:39:53 * LeCamarade is designing a language that goes to great lengths to prevent parens.
09:39:54 <oerjan> Cale: hey, both of the complaints about mdmkolbe's style you corrected are identical to mine :(
09:39:59 <mrd> i miss the structure-editing in Haskell, but I'm not sure what to do about it
09:40:02 <DRMacIver> wli, int-e: Hm. Ok, thanks.
09:40:06 <wli> Well, it is, but you have to seriously dig into the innards of the structures.
09:40:11 <Cale> oerjan: isn't that a good thing for you? :)
09:40:23 <mrd> integrate Yi with a Haskell error-recovering parser?
09:40:38 <shapr> LeCamarade: I have lots of advice for RSI, since my left arm blew out for nine months.
09:40:39 <wli> DRMacIver: My proposal and int-e's are largely equivalent save that int-e's is somewhat more efficient. id &&& f == \x -> (x, f x)
09:41:07 <lament> LeCamarade: Forth? :)
09:41:13 <oerjan> i don't like starting blocks on the same line as where, since i use a fixed indentation width
09:41:15 <hpaste>  Cale annotated "Any style optimization suggestions?" with "or this..." at http://hpaste.org/2320#a2
09:41:16 <DRMacIver> wli: I know
09:41:26 <lament> ( forth uses parentheses only for comments, such as this line)
09:41:42 <oerjan> although using .'s is growing on me, i think
09:41:47 <psi> i've started using a trackball mouse at work. it seems to stop the pain for me.
09:42:17 <Cale> I suggested a while back that Set and Map become more integrated, and nobody's done it :)
09:42:40 <psi> shapr: do you use a mouse?
09:42:59 <LeCamarade> Not Forth, because post-fix doesn't cut it for me. :o) Very Haskellesque, but with something like the $ operator replaced with a bad whitespace rule to create invisible parens. I am still testing feasibility/
09:43:08 <hpaste>  byorgey annotated "Any style optimization suggestions?" with "groupAt using unfoldr" at http://hpaste.org/2320#a3
09:43:23 <oerjan> > takeWhile (not . null) . unfoldr (Just . splitAt 3) $ [1..]
09:43:24 <LeCamarade> shapr: And how about pain in the fingers?
09:43:26 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
09:43:39 <lament> invisible parens... now that's scary
09:44:03 <mdmkolbe> > takeWhile (not . null) . unfoldr (Just . splitAt 3) $ [1..5]
09:44:05 <lambdabot>  [[1,2,3],[4,5]]
09:44:06 <hpaste>  conal annotated "two Maybe Monoid instances" with "corrected second def: " at http://hpaste.org/2319#a2
09:44:29 <oerjan> mdmkolbe: i just had to try doing it higher-order style
09:45:04 <hpaste>  conal annotated "two Maybe Monoid instances" with "a third version: unMaybe" at http://hpaste.org/2319#a3
09:45:21 <mdmkolbe> oerjan: yeah.  that is quite a cool trick.  a bit hard on the eyes, but still cool
09:45:32 <xahlee> i just scanned darc's theory of patches, am quite pissed by the author.
09:45:43 <Nafai> Heh, funny: http://www.cs.caltech.edu/~mvanier/hacking/rants/cars.html
09:45:45 <lambdabot> Title: Mike Vanier: opinions
09:46:18 <Cale> conal: Given the present style of Data.Monoid, I'd kind of expect the lifting instance to be the default one. The other instance is pretty much the MonadPlus behaviour -- perhaps there should be a wrapper for MonadPlus.
09:46:18 <popcount> xahlee, you should be.
09:46:29 <popcount> xahlee, anything else?
09:47:02 <wli> I don't see how a theory of patches differs from a theory of string edits.
09:47:04 <Cale> xahlee: maybe #darcs?
09:47:09 <wli> But anyway.
09:47:11 <popcount> xahlee, have you written an article yet about why we should build a statue for you?
09:47:33 <hpaste>  byorgey annotated "two Maybe Monoid instances" with "don't you need Nothing `mappend` Nothing, too?" at http://hpaste.org/2319#a4
09:47:39 <popcount> already*
09:47:43 <conal> Cale: MonadPlus!  That's where i saw it.  thanks.
09:47:55 <Botje> xahlee: send a patch *hides*
09:48:23 <Cale> conal: yeah, but that doesn't give you an instance of Monoid, so it isn't useful for e.g. the Writer monad.
09:49:03 <conal> byorgey:  oops -- forgot that one.  makes a good argument for the unMaybe version.
09:49:12 <mrd> he's too busy crusading against Curry
09:49:54 <conal> Cale: yep.  which is also lovely with AFs, in which writer is just (,) o, for a monoid o
09:50:30 <mdmkolbe> There are flaws in the theory of patches, but I have yet to see a well written exposition of where those flaws are.  But from the best I can tell, darcs style patches underestimate the logical dependancies (e.g. sometimes it would be nice to have the history of what patches were applied when to a particular repository) while svn style patches overestimates those dependancies (i.e. all changes must
09:50:30 <mdmkolbe>  fit into a strait line (ignoring svn style branches of course)).
09:52:06 <wli> mdmkolbe: My thought on the subject is to try to integrate language semantics.
09:52:08 <lament> monadic patches :)
09:52:54 <wli> mdmkolbe: Starting with representing patches as AST edits vs. string edits.
09:53:01 <int-e> mdmkolbe: did you look at git? (I know it has no real notion of a patch but it supports branches and merges)
09:53:11 <wli> mdmkolbe: This is, of course, far beyond me to carry out.
09:53:15 <Nafai> wli: I think that would be ideal :)
09:53:21 <mdmkolbe> int-e: I haven't, is it worth looking at?
09:53:39 <lament> wli: that's crazy
09:53:42 <Nafai> wli: I'm assuming that's what some of the SCM for Smalltalk (like Monticello, I believe) do
09:53:42 <mdmkolbe> int-e: (besides the obvious fact that it is the standard for the linux kernel)
09:54:13 <int-e> mdmkolbe: I think it's worth looking at, yes. I've grown quite fond of it.
09:54:19 <hpaste>  Cale annotated "two Maybe Monoid instances" with "wrapper in the style of Data.Monoid" at http://hpaste.org/2319#a5
09:55:16 <mdmkolbe> wli: actually I think there are some rsync projects that are based on that idea.  They were called something like monotone, or harmony or symphoney
09:55:23 * mdmkolbe tries to find it
09:55:36 <int-e> monotone exists.
09:55:57 * araujo def length(n): len(n)
09:56:09 <araujo> it's been the most difficult for me while coding python :-)
09:56:22 <Adamant> unison
09:56:26 <Adamant> or not.
09:56:46 <mdmkolbe> Adamant: yeah, unison is what I was thinking of
09:58:03 <ddarius> harmony and unison woro made by Benjamin Pierce
09:59:21 <ddarius> araujo: There's an easy fix for that.
10:01:40 <araujo> ddarius, yeah?
10:02:30 <araujo> :-)
10:03:21 <reltuk> the guy who wrote tapl is working on home directory synchronization across boxes?
10:03:42 <reltuk> so my dotfiles don't diverge?
10:06:06 <ddarius> araujo: Don't use python.
10:06:25 <foones> Hi
10:06:43 <ddarius> reltuk: http://www.cis.upenn.edu/~bcpierce/
10:06:45 <lambdabot> Title: Benjamin C. Pierce
10:06:56 <ddarius> Stupid frames.
10:07:42 <ddarius> http://www.cis.upenn.edu/~bcpierce/papers/index.shtml
10:07:43 <lambdabot> Title: Benjamin Pierce's Publications
10:08:11 <foones> I intend to get the maximum of a list
10:08:15 <foones> respect to a certain function
10:08:27 <wli> foones: Data.List.maximumBy
10:08:35 <foones> :)
10:08:38 <foones> Thanks
10:12:51 <sfultong> > fix const $ 5
10:12:59 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
10:12:59 <lambdabot>     Probabl...
10:13:53 <wli> Try fix id
10:14:27 <Saizan> > fix (const 5)
10:14:28 <lambdabot>  5
10:17:07 <byorgey> @pl fix . const
10:17:07 <lambdabot> id
10:17:39 <sfultong> wow, it's smart
10:18:17 <Saizan> @. djinn type fix . const
10:18:19 <lambdabot> f a = a
10:18:41 <ddarius> :t fix . const
10:18:43 <lambdabot> forall a. a -> a
10:18:50 <reltuk> ?source fix
10:18:50 <lambdabot> fix not available
10:18:54 <ddarius> @src fix
10:18:55 <lambdabot> fix f = let x = f x in x
10:19:35 <Heffalump> @. djinn type \f x -> f (f x)
10:19:37 <lambdabot> f a = a
10:20:21 <wli> I guess I really need the lattice enumeration bits for 4*x^2+y^2, 3*x^2+y^2, and 3*x^2-y^2 first.
10:20:40 <oerjan> :t \f x -> f (f x)
10:20:42 <lambdabot> forall t. (t -> t) -> t -> t
10:21:18 <oerjan> @djinn g :: (t -> t) -> t -> t
10:21:18 <lambdabot> Cannot parse command
10:21:27 <oerjan> @djinn (t -> t) -> t -> t
10:21:27 <lambdabot> f a = a
10:21:42 <oerjan> oh right...
10:21:53 <oerjan> @free f :: (t -> t) -> t -> t
10:21:54 <lambdabot> g . h = k . g => g . f h = f k . g
10:21:59 <ddarius> djinn can return multiple solutions, lambdabot's just doesn't.
10:22:11 <oerjan> @free f :: (t -> t)
10:22:11 <lambdabot> g . f = f . g
10:22:25 <ivant> wli, do you need instance definition for Ix [a]?
10:22:49 <wli> ivant: Not usually.
10:22:59 <ddarius> binary built and installed
10:23:09 <ivant> wli, I mean, is that what you mean by lattice enumeration?
10:23:40 <ivant> wli, e.g. range ([0,0,0],[3,2,5])
10:23:48 <chessguy_> @pl parseBoard fen state = fst $ foldr place (state, 112) fen
10:23:48 <lambdabot> parseBoard = (fst .) . flip (foldr place . flip (,) 112)
10:24:23 <wli> ivant: It's rare and probably not efficient.
10:25:04 <ivant> wli, it's not very efficient, but it is the only solution I had come up with for the implementation of multivariate polynomials
10:31:21 <conal> yummm.  holly made eggs & sausage & pancakes for breakfast.
10:32:42 <Brian`> how can i terminate on ghci when i accidentally run into an infinite lists?
10:33:01 <chessguy_> ugh, what's the place where people can blog about haskell...i can't think of the name about it
10:33:29 <_roconnor> http://planet.haskell.org
10:33:31 <lambdabot> Title: Planet Haskell
10:33:34 <Cale> chessguy_: sequence.complete.org?
10:34:30 <chessguy_> ah, that's it Cale
10:35:52 <sfultong> Brian`: ctrl-c
10:36:04 <Brian`> sfultong : it doesn't seem to work
10:37:23 <byorgey> Brian`: try Ctrl-D also?
10:38:03 <Brian`> byorgey : no it doesn't work
10:38:34 <byorgey> Brian`: best just kill the process, I guess
10:38:45 <Brian`> byorgey : I guess so then lol
10:39:08 <roconnor> what's the difference between planet.haskell.org and sequence.complete.org?
10:40:01 <roconnor> oh are the blogs on sequence not syndicated from elsewhere?
10:40:52 <fasta> I get a syntax error with: import GHC.Prim (unsafeCoerce#) in Edison.
10:41:40 <fasta> The '#' is 'unexpected'.
10:42:11 <samreid> fasta: do you have -fglasgow-exts?
10:42:35 <fasta> samreid: I am just using the darcs version of Edison.
10:43:04 <samreid> sorry... url?
10:43:48 <fasta> samreid: google edison haskell library
10:53:19 <chessguy> @type apply
10:53:21 <lambdabot> Not in scope: `apply'
10:53:24 <chessguy> @hoogle apply
10:53:25 <lambdabot> Data.Graph.Inductive.Query.Monad.apply :: GT m g a -> m g -> m (a, g)
10:53:25 <lambdabot> Data.Graph.Inductive.Query.Monad.apply' :: Monad m => GT m g a -> g -> m (a, g)
10:53:25 <lambdabot> Data.Graph.Inductive.Query.Monad.applyWith :: Monad m => (a -> b) -> GT m g a -> m g -> m (b, g)
10:54:09 <byorgey> chessguy: what are you looking for?
10:54:32 <chessguy> byorgey, i'm making sure i won't run into anything else if i use the word apply :)
10:54:40 <byorgey> chessguy: ah =)
10:55:01 <chessguy> @pl apply s (f,f') = f f' s
10:55:01 <lambdabot> apply = (`ap` snd) . flip (flip . fst)
10:55:35 <chessguy> @pl apply (f,f') s = f f' s
10:55:36 <lambdabot> apply = ap fst snd
10:55:44 <chessguy> oooh
10:57:05 <oerjan> also, uncurry (.)
10:57:08 <oerjan> i think
10:57:19 <sfultong> @unpl uncurry (.)
10:57:19 <lambdabot> uncurry (\ a b c -> a (b c))
10:57:21 <chessguy> @unpl uncurry (.)
10:57:21 <lambdabot> uncurry (\ a b c -> a (b c))
10:57:26 <sfultong> beat you :)
10:57:33 <Botje> no, uncurry (.) is f (f' s)
10:57:35 <byorgey> no, (f . f') s /= f f' s
10:57:53 <Botje> but yeah, it's what i thought at first too :)
10:58:05 <oerjan> oh, right, uncurry ($)
10:58:29 <chessguy> oooh, sweet
10:58:29 <oerjan> or id, even
10:58:41 <chessguy> this is coming out really nicely :)
10:58:42 <oerjan> @pl uncurry id
10:58:43 <lambdabot> uncurry id
10:58:44 <chessguy> @quote melt
10:58:44 <lambdabot> dons says:  its like you can really see the guy's brain melting
10:58:50 <chessguy> @quote melt
10:58:50 <lambdabot> dons says:  its like you can really see the guy's brain melting
10:58:59 <chessguy> @quote glguy.melt
10:58:59 <lambdabot> No quotes match. I feel much better now.
10:59:01 <EvilTerran> evening all
10:59:04 <chessguy> bah
10:59:04 <byorgey> > uncurry id (map, (^2)) $ [1..5]
10:59:06 <lambdabot>  [1,4,9,16,25]
10:59:08 <wli> @unpl uncurry id
10:59:08 <lambdabot> uncurry (\ a -> a)
10:59:11 <chessguy> @quote typical
10:59:11 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
10:59:20 <byorgey> hey EvilTerran
10:59:32 <oerjan> it seems like @unpl doesn't know about uncurry
10:59:41 <chessguy> @quote melted
10:59:41 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
10:59:44 <chessguy> there we go
11:00:19 <Botje> @quote moo
11:00:20 <lambdabot> No quotes match. Do you think like you type?
11:00:23 <Botje> awwh
11:00:29 <wli> @djinn (b -> t -> t1) -> b -> t -> t1
11:00:29 <lambdabot> f a = a
11:01:13 <wli> :t (uncurry id) `asTypeOf` (\(f,f') s -> f f' s)
11:01:15 <lambdabot> forall b t t1. (b -> t1 -> t, b) -> t1 -> t
11:01:22 <wli> :t (\(f,f') s -> f f' s)
11:01:24 <lambdabot> forall t t1 t2. (t -> t1 -> t2, t) -> t1 -> t2
11:01:53 <wli> Ladies, gentlemen, and others, we have a winner.
11:01:59 * araujo was really expecting a 'do not use python' type of answer from ddarius 
11:02:07 <wli> araujo: ;)
11:02:38 <araujo> i wish lottery was that predictable
11:02:39 <araujo> :-P
11:03:55 * EvilTerran wants someone to ask newbie questions he can solve so he'll feel better about missing his train
11:04:06 <sfultong> how do I find out if a function is strict or not?
11:04:15 <chessguy> @type ap
11:04:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:04:31 <EvilTerran> sfultong, if it's in the standard libs, view the source?
11:04:40 <EvilTerran> (or if you otherwise have access to the source)
11:04:41 <sfultong> hmmph :)
11:04:56 <sfultong> why doesn't lambdabot do it for me?
11:05:15 <sfultong> @src (Either)
11:05:15 <lambdabot> Source not found. I feel much better now.
11:05:24 <sfultong> @src Either
11:05:24 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:05:42 <EvilTerran> if you want to do it at runtime, pass in a bottom as that parameter, force it, and see if the bottom gets forced.
11:05:50 <EvilTerran> (whee, hacky)
11:05:55 <sfultong> heh, yeah...
11:06:18 <EvilTerran> (using the ugly exception handling to catch it, or whatever)
11:07:06 <oerjan> > undefined + 1
11:07:08 <lambdabot>  Undefined
11:07:14 <oerjan> woo, strict
11:07:57 <EvilTerran> > True || undefined
11:07:59 <lambdabot>  True
11:08:03 <EvilTerran> hoorj, not strict
11:09:03 <sfultong> how do I get around constructing infinite types?
11:09:37 <oerjan> sfultong: add a newtype to break the loop
11:10:33 * EvilTerran wonders what happened to that stack of PDFs he was going to read
11:11:01 <oerjan> EvilTerran: you got a stack overflow?
11:11:17 <EvilTerran> @google types a la carte
11:11:19 <lambdabot> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
11:12:11 <EvilTerran> oerjan, heh... anyway, that's the one i was on. i'll finish that one off.
11:17:17 <fasta> Ok, another problem solved...
11:19:01 <chessguy> @type foldl
11:19:04 <chessguy> @type foldr
11:19:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:19:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:20:43 <ddarius> :t maxBound
11:20:44 <lambdabot> forall a. (Bounded a) => a
11:23:10 <ddarius> :t randoms
11:23:12 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
11:23:25 <ddarius> :t mkStdGen
11:23:27 <lambdabot> Int -> StdGen
11:24:13 <phobes> Is it fair to say that in strict languages, "if" or "cond" are not normal functions?
11:25:07 <ddarius> phobes: Yes.
11:25:15 <phobes> thanks
11:25:41 <ddarius> Well, some languages e.g. Smalltalk implement them with HOFs and that doesn't require laziness at all.
11:26:08 <phobes> true
11:26:15 <ddarius> > randoms (mkStdGen 1) :: [Double]
11:26:17 <lambdabot>  [0.35925462466181596,0.33062336659771935,0.13648524126887446,0.5386400148362...
11:30:44 <ddarius> @index randoms
11:30:44 <lambdabot> System.Random
11:33:25 <ddarius> Hmm... my Haskell Karplus-Strong implementation sounds a lot better than my C# one...
11:34:38 <yaxu> ddarius: ooh, how are you rendering it?
11:35:16 <yaxu> mine is here http://doc.gold.ac.uk/~ma503am/software/karplusStrong.tar.gz
11:35:25 <yaxu> with HS3
11:36:50 <shapr> yaxu: Is that using supercollider?
11:37:45 <yaxu> shapr: the haskell bindings for it, yes
11:37:45 <ddarius> yaxu: I'm just outputting a wav file.  The code is karplusStrong = (take 440 $ map (subtract 1 . (2*)) $ randoms (mkStdGen 1)) ++ zipWith (\a b -> (a+b)/2) karplusStrong (0:karplusStrong)
11:38:03 <yaxu> ddarius++
11:38:51 <ddarius> Then I use a quick wav output thing I made to turn the [Double] into a 3 second wav file at 22050Hz.
11:39:17 <ddarius> yaxu: I just did it to test the wav thing.
11:39:38 <ddarius> yaxu: I have a more involved model that I need to tweak and then see what it sounds like.
11:40:05 <yaxu> it's nice to see it in pure haskell
11:41:08 <yaxu> mine uses a c plugin although rohan drape pointed out it wasn't needed
11:41:46 <yaxu> for a random polarity switcher to make the sound percussive
11:42:58 <yaxu> @paste
11:42:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:43:41 <hpaste>  yaxu pasted "karplusStrong without the plugin" at http://hpaste.org/2321
11:43:54 <chessguy> http://sequence.complete.org/node/361
11:43:56 <lambdabot> Title: Revisiting board-building in chess | The Haskell Sequence
11:43:59 <chessguy> w00t!
11:44:14 <yaxu> you can continuously adjust the parameters with the mouse
11:45:36 <phobes> ddarius: even with HOF, the implementation of 'if' has to be a special non-function in a strict language, doesn't it?
11:45:49 <chessguy> i suspect something can be done to make the flipping even more elgeant. if anyone has any ideas, i'd love to hear it
11:46:20 <ddarius> phobes: No.
11:46:20 <Philippa> phobes: no, you just insist on the blocks being (something isomorphic to) zero-parm functions
11:46:46 <Philippa> () -> whatever, say
11:47:36 <phobes> Right, you pass in thunks... but something has to branch and then open the thunks, right?
11:47:54 <Philippa> yes, and that bit's trivial
11:48:05 <phobes> how do you do that?
11:48:10 <Philippa> church encode :-)
11:48:37 <ddarius> let true t f = t (); false t f = f ()
11:48:56 <phobes> ah, let pattern matching take care of it
11:48:57 <Philippa> true = \x y -> x (), false = \x y -> y (), if c t f = c t f
11:48:58 <ddarius> Alternatively (though pretty much equivalently) you can use dynamic dispatch.
11:49:06 <Philippa> no, pattern-matching isn't doing anything there
11:49:08 <phobes> ok thinking
11:49:09 <ddarius> phobes: There is no pattern matching.
11:49:30 <Philippa> true becomes a 2-parm function that runs its first argument, false becomes a 2-parm function that runs its second
11:49:38 <phobes> ya ok I get it - thanks
11:49:45 <Philippa> the other argument doesn't get run because it's stuck behind a lambda
11:52:29 <ddarius> The OO way looks identical, abstract class Bool<A> { A if(Func<A> t, Func<A> f); }; class True<A> : Bool<A> { A if(Func<A> t, Func<A> f) { return t(); }} and similarly for False
11:52:50 <dolio> For that, you have to write 'if b (\_ -> t) (\_ -> f)', though, so people will still want macros/special forms. :)
11:53:14 <ClaudiusMaximus> ddarius: is your [Double] -> wav file code public?  i'm currently writing to text files and converting to wav with Pd...
11:56:02 <ddarius> ClaudiusMaximus: I just wrote it half an hour ago.  It's very specialized but I was thinking about nevertheless packaging it.
12:06:21 <ivant> chessguy, why didn't you simply use read for the chess-board?
12:06:34 <chessguy> ivant, what do you mean?
12:06:53 <ivant> you could implement Read GameState
12:07:04 <chessguy> @src Read
12:07:04 <lambdabot> class Read a where
12:07:04 <lambdabot>   readsPrec    :: Int -> ReadS a
12:07:04 <lambdabot>   readList     :: ReadS [a]
12:07:04 <lambdabot>   readPrec     :: ReadPrec a
12:07:04 <lambdabot>   readListPrec :: ReadPrec [a]
12:07:14 <chessguy> err
12:07:18 <shapr> lament: Written any Haskell code lately?
12:07:36 <ivant> show . read = id, remember? :-)
12:07:57 <ddarius> Hell, it works!
12:08:03 <chessguy> ivant, yes, i know about read, but not Read
12:08:08 <chessguy> @hoogle Read
12:08:08 <lambdabot> Text.Read :: module
12:08:08 <lambdabot> Prelude.Read :: class Read a
12:08:08 <lambdabot> Prelude.read :: Read a => String -> a
12:09:21 <chessguy> ivant, what would be the advantage?
12:09:45 <ivant> I don't know, I thought you made an educated decision, so I wanted to know the details :-)
12:10:00 <chessguy> ha! i don't claim to be educated about haskell :)
12:10:31 <ivant> well, show GameState would be a nice way to serialize state back to the FEN notation
12:10:44 <chessguy> sure
12:10:49 <SamB> ivant: would it?
12:11:07 * SamB thinks he'd want to see something like a chessboard...
12:11:28 <chessguy> yeah, i'd almost want multiple instances of Show, somehow
12:11:50 <ddarius> parameterize your chessboard type with a phantom type variable representing output style.
12:11:56 <SamB> I'd use another name for the serialization to the standard format...
12:11:59 <ddarius> Or probably better use wrapper types in this case (or a combination)
12:12:24 <chessguy> anyway, the converting to and from notation isn't a major component
12:13:31 <ddarius> > 22050/440
12:13:32 <lambdabot>  50.11363636363637
12:17:17 * SamB wants to see Language.C and Language.Cmm libraries...
12:17:47 <ddarius> SamB: Write them.
12:17:54 <oerjan> shouldn't that last 7 be 6?
12:18:26 <ddarius> oerjan: You'd think.
12:18:35 <ddarius> Go go floating point!
12:18:40 <SamB> ddarius: I assume that for Language.C you mean "factor out of c2hs"
12:18:42 <SamB> not "write"
12:18:55 <ddarius> SamB: That'd probably be sensible for that one.
12:19:45 <sorear> .
12:20:14 <dolio> I thought someone was already doing that.
12:20:24 <dolio> Maybe it's just people talking about it, though.
12:20:32 <Saizan> i wonder if having a Languange.Java like Text.html will make coding in Java nicer
12:21:12 <SamB> is there a trac for libraries to be made?
12:22:37 <Saizan> http://www.haskell.org/haskellwiki/Wanted_libraries <-- nearest thing that i know of
12:22:38 <lambdabot> Title: Wanted libraries - HaskellWiki
12:23:49 <ddarius> My fractional delay filter seems to work.
12:27:33 <hpaste>  byteshack pasted "install error" at http://hpaste.org/2322
12:28:12 <ClaudiusMaximus> i blogged a bit about my experiments with Control.Arrow.Transformer.Reader for sample rate manipulation in audio/dsp context:  http://tinyurl.com/2h2vmc
12:28:15 <lambdabot> Title: ClaudiusMaximus' 2007-08-18
12:47:24 <chessguy> is Twan van Laarhoven a #haskeller?
12:48:08 <sjanssen> yes, as twanvl
12:48:15 <chessguy> aha
12:48:18 <chessguy> @seen twanvl
12:48:19 <lambdabot> twanvl is in #haskell. I last heard twanvl speak 41m 24s ago.
12:55:07 <gleb> @seen Saizan
12:55:07 <lambdabot> Saizan is in #happs, #haskell-overflow, #haskell-blah and #haskell. I last heard Saizan speak 32m 30s ago.
12:57:13 <cjay> what are the effective differences between "reentrant" and "referentially transparent"? is it only that reentrant functions may modify their arguments?
12:57:48 <cjay> the definitions on wikipedia are quite different, but is seems the two are similar
12:58:04 <mrd> anything referentially transparent is naturally re-entrant already
12:58:48 <Plareplane> but you can have something re-entrant without it ref transparent, right?
12:59:20 <mrd> yes, it could modify other state
12:59:24 <Botje> cjay: reentrant can't mutate global state; referentially transparent can't mutate _ANY_ state
12:59:40 <Botje> that's hwo i understand it
12:59:57 <mrd> "re-entrant" is a term used by C programmers to indicate a function that isn't written in a stupid fashion
13:00:05 <hpaste>  gleb annotated "Problem with higher rank types" with "higher rank types + scoped ty vars again" at http://hpaste.org/2318#a2
13:00:06 <glguy> a reentrant function need not be referentially transparent
13:00:12 <glguy> it just needs to not blow up other callers
13:00:36 <mrd> for example, a function to get the current time
13:00:41 <bartw> reentrant tends to mean recursion i didn't expect and breaks somethign because of mutable state of mutexes
13:00:42 <mrd> that is not referentially transparent
13:00:42 <cjay> so, is it true that a reentrant function may modify its arguments?
13:00:43 <chessguy> @where cale
13:00:43 <lambdabot> I know nothing about cale.
13:00:47 <chessguy> @where calewiki
13:00:47 <lambdabot> http://cale.yi.org/index.php/Main_Page
13:00:50 <Cale> hello
13:00:57 <Cale> ah
13:01:05 <chessguy> Cale, sorry, i wasn't looking for you, just your wiki :)
13:01:17 <glguy> cjay: I don't see why it couldn't
13:01:36 <chessguy> Cale, incidentally, though, any thoughts on my suggestion about folds?
13:01:43 <gleb> Saizan: I'm sorry, could you please help me with the new incarnation of my problem (http://hpaste.org/2318#a2)?
13:01:44 <cjay> ok thanks
13:04:50 <sfultong> @type loop (+1)
13:04:56 <lambdabot> forall b d. (Num (b, d)) => b -> b
13:05:22 <gleb> hello, is there anybody to help me with higher rank types + scoped type variables? I've pasted the code snippet in question above
13:05:26 <sfultong> Num (b, d)... my favorite Num instance
13:05:49 <glguy> cjay: similarly, a function can be referentially transparent without being reentrant
13:06:11 <oerjan> :t loop
13:06:13 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
13:06:14 <Cale> chessguy: one sec, let me find it :)
13:06:45 <cjay> glguy: how?
13:06:48 <Cale> chessguy: er, what's your suggestion? :)
13:06:53 <Cale> (I just got here)
13:06:59 <glguy> cjay: a C function tha performs some computation might use some static memory
13:07:15 <glguy> cjay: but it could always come to the same result for any given arguments
13:08:00 <cjay> I see, so referentially transparent doesn't really mean not modifying global state
13:08:27 <glguy> calling a referentially transparent function with some set of arguments always returns the same result
13:08:33 <sfultong> oerjan: doesn't the (,) forced class instance for loop make it fairly unusable?
13:08:35 <SamB> depends on what "global state" you mean
13:09:17 <glguy> cjay: in the static memory example, it could return the static memory to the original state before it returned
13:09:30 <oerjan> sfultong: i assume it is similar to mfix for monads?
13:09:31 <mrd> glguy: but it wouldn't come to the same result if used in a re-entrant fashion
13:09:35 <palgolak> Hi - anyone from cabal-devel here?
13:09:47 <glguy> mrd: right, reentrant and referentially transparent aren't really related
13:09:50 <glguy> is what I'm going for
13:09:57 <mrd> i wouldn't call that referentially transparent
13:10:14 <Cale> cjay: On a semantic level, it's equivalent to that
13:10:42 <cjay> I see
13:10:44 <oerjan> sfultong: it is value recursion, the snd of the input is taken from the snd of the output
13:11:12 <Cale> It's possible for the system to cleverly use state to implement referentially transparent semantics though, perhaps with improved efficiency.
13:11:29 <chessguy> Cale, sorry, was away for a minute
13:11:29 <mrd> ST ;)
13:11:36 <chessguy> Cale, i @tell'd you it
13:12:04 <chessguy> Cale, my suggestion was that it would be nice to also have some kind of flowchart for deciding which fold to use
13:12:14 <Cale> ah, right
13:12:22 <oerjan> > loop (const 1 *** (1:))
13:12:23 <lambdabot>  Add a type signature
13:12:40 <|Jedai|> @src length
13:12:41 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:12:54 <chessguy> like, right now, i know i have a fold pattern, but i'll be darned if i can figure out which fold i want
13:12:55 <|Jedai|> @src lenght
13:12:56 <lambdabot> Source not found. Do you think like you type?
13:12:59 <Cale> foldr is the sane default most of the time
13:13:16 * thoughtpolice thinks about some sort of program to hack on
13:13:17 <chessguy> Cale, yeah, but in this case it's backwards
13:13:33 <mrd> 80% of the time you want foldr, 20% of the time you want foldl', and the remaining % you use foldl is because you know what you're doing
13:13:38 <Cale> You typically use foldl' (strict left fold), if you're collapsing a list down to a small value which can't be partially evaluated.
13:13:58 <jedai> chessguy: There is a pretty flowchart for fold on the net, I'll just have to find it again...
13:14:20 <Cale> There's a chart of what the folds actually do on my wiki
13:14:23 <oerjan> > loop (const 'a' *** ('b':))
13:14:24 <lambdabot>  Add a type signature
13:14:26 <chessguy> @hoogle foldl'
13:14:27 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
13:14:28 <twanvl> chessguy: You called?
13:14:40 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
13:14:42 <lambdabot> Title: Fold Diagrams - CaleWiki
13:14:43 <oerjan> :t loop (const 1 *** (1:))
13:14:45 <lambdabot> forall t b. (Num t) => b -> t
13:14:47 <Cale> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
13:15:18 <chessguy> dang. neither foldr nor foldl' are working, which means i'm probably doing something wrong
13:15:26 <chessguy> twanvl, ah, i sent you an email, thanks
13:15:34 <gleb> I have function f :: (forall b . a -> m b) -> m a. In its body I supply appropriate 'a' to it, expecting to get polymorphic forall b. m b, but instead I get m b. What's wrong?
13:15:36 <sfultong> > loop (const 1 *** (1:)) 2
13:15:37 <lambdabot>  1
13:15:44 <sfultong> > first (const 1 *** (1:)) 2
13:15:45 <lambdabot>   add an instance declaration for (Num ((b, [t]), d))
13:15:48 <sfultong> > first (const 1 *** (1:)) $ 2
13:15:49 <lambdabot>   add an instance declaration for (Num ((b, [t]), d))
13:15:55 <Saizan> > loop (\(x,y) -> (map (+x) y,1:y)) 2
13:15:56 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
13:16:02 <chessguy> twanvl, i'm Andrew Wagner, you responded to my post about chessboard-building
13:16:09 <twanvl> ah
13:16:18 <chessguy> twanvl++
13:16:23 <chessguy> very nice solution, too
13:18:56 <Cale> chessguy: can I see?
13:18:57 <jedai> @src length
13:18:59 <lambdabot> Source not found. Do you think like you type?
13:19:05 <sfultong> loop seems only really useful for lists
13:19:07 <jedai> ?src length
13:19:08 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:19:12 <Cale> chessguy: what is it that you're trying to do, exactly?
13:19:19 <jedai> @source length
13:19:19 <lambdabot> length not available
13:19:26 <Cale> chessguy: and what do you mean by "not working"?
13:19:48 <ddarius> sfultong: loop is not really worth using for the (->) arrow.
13:19:59 <chessguy> i want fold f start [a,b,c,d] to give me f d (f c (f b (f a start)))
13:20:23 <Cale> reverse the list and use foldr
13:20:29 <sfultong> ddarius: I was hoping for some more general loop construct...
13:20:59 <Cale> Or, use foldl with flip f
13:21:09 <chessguy> foldl or foldl'
13:21:22 <Cale> Either one, depends on what you're building
13:21:23 <jedai> foldl (flip f) start
13:21:24 <Saizan> sfultong: do you mean something like a for-loop?
13:21:33 <Syzygy-> :t Pair
13:21:35 <lambdabot> Not in scope: data constructor `Pair'
13:21:38 <glen_quagmire> i installed yi according to Cabal installation instruction. http://hpaste.org/2323   i get this error when I run it
13:21:38 <Cale> Are you building something which you want to build somewhat lazily?
13:21:46 <Cale> Or is it something like an integer?
13:22:02 <Syzygy-> > (foldr (,)) . reverse $ [1,2,3,4]
13:22:03 <lambdabot>      Occurs check: cannot construct the infinite type: b = (a, b)
13:22:03 <lambdabot>       Expec...
13:22:24 <Syzygy-> Meh
13:22:49 <chessguy> ermm
13:22:57 <chessguy> neither?
13:23:05 <Saizan> > (foldr (,) ()) . reverse $ [1,2,3,4]
13:23:06 <lambdabot>      Occurs check: cannot construct the infinite type: b = (a, b)
13:23:06 <lambdabot>       Expec...
13:23:19 <Saizan> ah right.
13:23:23 <sfultong> saizan: well... maybe that's what I've been thinking of.... something analogous to until
13:23:31 <chessguy> it's composite, but it's a random-access object, so it can be evaluated strictly as part of the fold
13:23:57 <Saizan> sfultong: that's a very different kind of loop
13:24:52 <chessguy> foldl' (flip f) seems to work well
13:24:57 <Cale> chessguy: You most likely want foldl'
13:25:37 <Cale> foldl and foldl' both evaluate the same expression, they just do the evaluation in a different order
13:25:57 <Saizan> ?type until
13:25:58 <ddarius> sfultong: There is no more general loop construct than fix for pure values.
13:25:59 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
13:26:08 <Cale> if you're using foldl', you might want to make the data structure explicitly strict, so that the whole combining computation is performed when you combine values.
13:26:35 <Cale> (foldl' will cause the computation to occur up to the determination of the top level constructor before the recursion continues)
13:27:09 <Cale> If it's something like an unboxed array, there's no need to worry :)
13:27:19 <Cale> (those are already strict in all the elements)
13:27:29 <sfultong> ddarius: ah, thanks
13:29:37 * araujo wonders what sounds better ... 'launching application' or 'running application' ..... or 'executing application' .....
13:29:46 <chessguy> Cale, this is the actual data structure i'm building up: data GameState = GameState { board :: Map Int (Maybe Int),  pieces :: Map Int Piece, turn :: PieceColor }
13:30:04 <Cale> chessguy: yeah, you might want to make the fields strict
13:30:35 <chessguy> Cale, why?
13:30:44 <gkr> If I have an algebra (A, +), and I extend the operator to [A], like using (map +), how is called what I am doing?
13:30:56 <chessguy> (i'm sure you're right, i just want to understand)
13:30:57 <ddarius> makeFilter as bs input = output where inputs = tails input; outputs = tails (map (const 0) bs ++ output); output = zipWith (\input output -> sum (zipWith (*) as input) + sum (zipWith (*) bs output)) inputs outputs
13:30:59 <Cale> So that computations on the individual components aren't needlessly build up.
13:31:01 <araujo> gkr, sections
13:31:11 <araujo> oh sorry
13:31:17 <Cale> built*
13:31:20 <araujo> gkr, parcial application?
13:31:30 <allbery_b> I think I found a bug in @forget, or maybe in the quote module and uncovered by @forget
13:31:39 <gleb> is there any difference between (lift foo >>= bar) and do { x <- lift foo; bar x } ?
13:32:17 <Saizan> ?type let untilArr f pred = f >>> pred >>> (returnA ||| untilArr f pred) in untilArr  --- sfultong, did you want something like this?
13:32:19 <lambdabot> forall (a :: * -> * -> *) b c b1. (ArrowChoice a) => a b c -> a c (Either b1 b) -> a b b1
13:32:23 <gkr> araujo I mean, moving the operation + from A to [A].
13:32:26 <araujo> gleb, except of the syntax ... nothing else
13:32:46 <Cale> If your combining function looks something like f (GameState b p t) x = GameState (fb b x) (fp p x) (ft t x), then what will happen with foldl and foldl' will not be very different
13:32:59 <ddarius> gkr: Are you looking for homomorphism?
13:33:11 <gleb> araujo: I always thought so, but now I'm getting different error messages when I change former to latter
13:33:15 <chessguy> Cale, but making the fields strict will make a big difference?
13:33:27 <araujo> gleb, what error message?
13:33:37 <Cale> Well, it might save memory, and if the list is extremely long, will save you from stack overflows.
13:33:53 <gkr> ddarius yep. It's like [A] is the free monoid on A, how do I call when I move the operation + from A to [A]?
13:33:56 <Cale> > foldl (+) 0 [1..1000000]
13:33:59 <lambdabot>  500000500000
13:34:00 <gkr> (it's inda uniquely defined)
13:34:01 <Cale> > foldl (+) 0 [1..10000000]
13:34:05 <lambdabot> Terminated
13:34:07 <chessguy> oh, it's not more than 100 elements
13:34:25 <sorear> gkr: lifting?
13:34:33 <sfultong> saizan: yes
13:34:37 <gleb> araujo: http://hpaste.org/2318#a2
13:34:38 <Cale> (oh, right, lambdabot is smarter than that now :)
13:35:01 <sorear> gkr: amusingly, all free-structures are monads
13:35:09 <Cale> chessguy: probably not too big of a difference then, anyway
13:35:23 <gkr> sorear uhm, interesting.
13:35:27 <chessguy> ok
13:35:35 <Cale> chessguy: It may build up unevaluated expressions which are as large as the original list.
13:35:37 <gkr> I'll call it lifting then, thanks.
13:35:38 <gleb> araujo: this code doesn't typecheck, but error messages differ depending on syntax of (lift deflt >>= k) subexpression
13:36:05 <Cale> chessguy: Which is the only difference between using foldl and foldl' -- to eliminate those expressions.
13:36:37 <Cale> chessguy: Have you seen the foldl/foldl' (+) 0 [1..3] evaluation that I've done in this channel a bunch of times before?
13:36:53 <Plareplane> can you have an algebraic data type that's not freely generated by its constructors? in particular i'm curious about p.6 of http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf
13:36:55 <lambdabot> http://tinyurl.com/gf73z
13:37:13 <Cale> Plareplane: used to be possible
13:37:14 <sfultong> the apparent intended use of arrows and my intended use seem to diverge more than I thought :(
13:37:18 <chessguy> Cale, yes, i think so
13:37:20 <Cale> (directly, with pattern matching)
13:37:25 <chessguy> Cale, i get what you're saying, anyway
13:37:42 <Cale> Plareplane: For some reason, that feature was removed at some point from Haskell and Miranda.
13:38:19 <Cale> Perhaps it was decided that it made evaluation too complicated to understand in many cases.
13:38:23 <ddarius> gkr: I don't think you have a monoid homomorphism into [A] (but maybe that's not what you are going for).
13:39:47 <phobes> ddarius: why wouldn't you have a homomorphism?
13:39:50 <Cale> At one point, you could specify rules to normalise terms built up by constructors -- even to the point of having automatically-sorted lists where pattern matching a cons would give the least element and the rest.
13:42:36 <newsham> hi
13:42:43 <gleb> hi
13:43:33 <ddarius> phobes: zipWith (+) /= (++)
13:44:47 <phobes> huh?
13:45:07 <phobes> ddarius: Wouldn't the map be (+)  => zipWith (+)
13:45:50 <newsham> > zipWith (+) [1,2,3] [2,3,4]
13:45:51 <lambdabot>  [3,5,7]
13:45:52 <Plareplane> Cale, is there a common/canonical way of saying "adt which are freely generated by constructors" versus those that aren't? that is, what might i google for further info?
13:46:00 <newsham> > (++) [1,2,3] [2,3,4]
13:46:02 <lambdabot>  [1,2,3,2,3,4]
13:46:35 <Cale> Plareplane: you wouldn't happen to have access to an ACM subscription?
13:46:44 <Plareplane> until end of august i do :)
13:46:53 <Cale> http://portal.acm.org/ft_gateway.cfm?id=319839&type=pdf&dl=portal&dl=ACM
13:46:55 <phobes> ++ is concatenation... what does that have to do with lifting an operator on A (e.g. + on Int) to an operator on [A]  (in this case zipWith (+)) ?
13:46:57 <newsham> getting kicked out of the ivory tower?
13:46:58 <lambdabot> http://tinyurl.com/2st87c
13:47:18 <phobes> *confused*
13:47:21 <ddarius> phobes: It's not a homomorhism into the free monoid or even a monoid built on the free monoid.
13:47:26 <newsham> phobes: what it has to do with it is (/=)
13:47:45 <Plareplane> newsham, well it wasn't entirely involuntary!
13:48:05 <ddarius> The free monoid is not just [a], it's ([a],(++),[]) and the unit for the monoid we want is repeat 0 which is not an element of the (usual) free monoid.
13:48:10 <newsham> i wish the ivory tower would open up their libraries to us peasans
13:49:32 <newsham> peasants
13:49:32 <glguy> empty = repeat 0; a <|> b = zipWith (+) a b
13:50:08 <glguy> newsham: like any organization whose purpose for existing is to make money, you can buy your way in
13:50:33 <phobes> ddarius:  ok missed 'free monoid'  - thanks
13:50:34 <newsham> do I not pay taxes?
13:51:13 <cognominal> I am trying to compile lambdabot from the darcs version and I get
13:51:17 <glguy> newsham: good question, do you?
13:51:19 <cognominal> scripts/BotPP.hs:21:17:
13:51:19 <cognominal>     Could not find module `Data.ByteString.Char8':
13:51:19 <cognominal>       it was found in multiple packages: fps-0.7 base
13:51:29 <glguy> cognominal: what GHC are you using?
13:51:32 <cognominal> how do I resolve this ambiguity
13:51:35 <newsham> yes I do.  and my taxes pay for prisons and orphanages and phd students
13:51:59 <cognominal> 6.6.1
13:52:19 <newsham> cog: take "fps-0.7" out of lambdabot.cabal ?
13:54:15 <allbery_b> I would also deregister fps-0.7 from ghc6.6.1
13:54:31 <allbery_b> (ghc-pkg unregister fps-0.7)
13:54:51 <cognominal> allberry_b, that seems indde necessary
13:55:58 <glguy> > getZipList $ Control.Applicative.pure (+) <*> ZipList [1,2,3] <*> Control.Applicative.pure 5
13:55:59 <lambdabot>  [6,7,8]
13:57:26 <sfultong> >  fix (\(x:xs) -> x+1:x:xs)
13:57:28 <lambdabot>  Exception: <<loop>>
13:57:46 <glguy> sfultong: you need a base case
13:58:03 <ddarius> And an irrefutable pattern
13:58:16 <sfultong> why doesn't it complain when I do that?
13:58:23 <glguy> sfultong: it did
13:58:33 <sfultong> what is it doing when I type that into ghci, and it just sits there, looping on something...
13:58:33 <ddarius> sfultong: Because in general it's Turing-hard to see if there is a problem.
14:00:20 <sfultong> >  fix (\(x:xs) -> 1:x+1:x:xs)
14:00:22 <lambdabot>  Exception: <<loop>>
14:00:30 <glguy> 13:57 < ddarius> And an irrefutable pattern
14:00:37 <ddarius> > fix (\~(x:xs) -> 1:x+1:x:xs)
14:00:38 <lambdabot>  Parse error
14:00:44 <ddarius> > fix (\(~(x:xs)) -> 1:x+1:x:xs)
14:00:45 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
14:01:04 <sfultong> ah, interesting...
14:01:24 <sfultong> I've always wanted to know more about that tilde
14:02:48 <Cale> sfultong: It just makes the pattern always "match" immediately, and to do destructuring lazily (which means that if the pattern doesn't really match, you get an exception)
14:02:50 <sfultong> how is it evaluated if the pattern is refutable?
14:02:53 <ClaudiusMaximus> sfultong: it's useful when something fails/loops due to being too strict, at least that's how i understand it
14:03:25 <Cale> The exception happens when one of the bound variables is actually demanded
14:03:47 <Cale> > let f ~(x:xs) = 1 in f []
14:03:48 <lambdabot>  1
14:03:51 <Cale> > let f ~(x:xs) = x in f []
14:03:52 <lambdabot>   Irrefutable pattern failed for pattern (x : xs)
14:04:10 <sfultong> but what is ghci doing, when a variable is never demanded?  why doesn't it just ignore the whole thing, and give me another prompt?
14:04:35 <Cale> hm?
14:04:50 <Botje> sfultong: because the default behavior for ghci is to evaluate and print the last expression.
14:05:03 <sfultong> Botje: but what is it evaluating?
14:05:19 <Botje> stuff? :)
14:05:22 <sfultong> heheh
14:05:25 <Cale> sfultong: It's evaluating show of whatever you types
14:05:26 <Cale> d
14:05:35 <Cale> as part of print
14:05:55 <Cale> If the thing doesn't have an IO type, it attempts to print it
14:06:09 <Cale> and print = putStrLn . show
14:06:48 <Cale> In order to do its work, putStrLn demands characters of the string result of show, which in turn generates demand for the parts of the expression you typed.
14:07:09 <cognominal> I am reading that hugs is good for learning but one cannot even define new functions with hugs; one must edit and load.
14:07:23 <cognominal> so do you recommand ghci or hugs, for a beginner
14:07:28 <Cale> cognominal: Really, that's also what you want to do with ghci
14:07:42 <Saizan> if you're asking why fix (\(x:xs) -> 1:x+1:x:xs) doesn't terminate in ghci instead of showing  Exception: <<loop>>, it's because the loop check is performed only with compiled code
14:07:44 <cognominal> I am a beginner, I want to experiment and learn
14:07:46 <Cale> You typically keep both an editor window and ghci/hugs open at the same time
14:07:55 <Cale> typing :r will reload the file you have loaded
14:08:17 <Cale> So you make definitions in your editor, save the file, and reload it with :r
14:08:22 <Cale> then you can test out expressions
14:08:41 <ddarius> hugs sucks use GHCi which isn't much better in this regard, but is better in others.
14:08:53 <cognominal> I am at the stage where I type small functions so this extra-step is currently an hassle
14:09:04 <sfultong> saizan: is it just allocating new thunks that it never uses?
14:09:09 <cognominal> I understand it will soon be necessary
14:09:12 <xerox> cognominal: do you use Emacs?
14:09:38 <Cale> cognominal: Also, unless you have a very long scrollback, you can easily lose your definitions.
14:09:38 <cognominal> yes, I have installed the elisp files but I can't learn everything at once :)
14:09:47 <Cale> (printing something infinite, for example)
14:10:05 <xerox> Ah, cool. Then just C-x C-f /tmp/Foo.hs type your stuff, and C-c C-l to load it in GHCi.
14:10:22 <ednarofi> cognominal: you can easily use "let" in at least ghci to test small functions, for example: let f x = x + 1
14:10:28 <cognominal> xerox: thx for these incantations :)
14:10:56 <xerox> cognominal: you're welcome, if you've got haskell-mode-2.3 it has got many nice incantations :-)
14:11:14 <Saizan> sfultong: no allocation, just an infinite loop
14:11:17 <Cale> cognominal: You still won't be allowed to define new data types, classes, or instances at the ghci prompt though.
14:11:26 <timthelion> is there such thing as a multibyte font which would forincetance show the arrow symbol for the chars ->?
14:11:36 <cognominal> ednarofi: that's why I prefer ghci so far. but I read that hugs is friendly so I was curious
14:12:23 <ddarius> cognominal: hugs is not friendly.
14:13:09 <Cale> cognominal: If you're on windows, hugs is a bit friendlier since windows' terminal emulation generally kinda sucks. (Though the last windows version I spent any time with was '98.)
14:13:28 <cognominal> ddarius: thx for confirming my impression, I am either on linux or macosx
14:14:03 <gleb> Cale: windows terminal still sucks on XP and 2003
14:14:21 <Cale> gleb: I had a feeling that would be the case :)
14:14:27 <eivuokko> I don't see what Windows console window lacks for ghci
14:14:42 <Cale> Given that MS Paint is still the same as Paintbrush was on Windows 3.0
14:15:04 <ddarius> Cale: Why would they upgrade MS Paint?
14:15:10 <gleb> eivuokko: copy-paste, readline, etc
14:15:17 <timthelion> Cale: no it's not, it now saves to something like 50 file formats!
14:15:40 <Cale> ddarius: To help people do photo editing?
14:15:59 <Cale> It's pretty useless as a photo editing tool as it stands.
14:16:04 <cognominal> xerox: yes I got haskell-mode 2.3
14:16:09 <timthelion> Cale: but that would rais serios antitrust concerns.
14:16:22 <ddarius> Cale: That would take adding a hell of a lot more to it.  It would make more sense to sell a photo editing product.
14:16:36 <timthelion> ddarius: which they do sell
14:16:52 <Cale> ddarius: Don't they already have something like Paint.net, but it's not included?
14:17:10 <cognominal> I like TextMate but its current design makes it useless for Haskell
14:17:27 <Cale> er, ah, that's produced by a third party
14:17:43 <eivuokko> gleb, readline is a library, not really a lack of Windows console.  Copy & paste...there are few glitches sure, but I don't need copy & paste with ghci.  What would etc. refer to?
14:17:43 <timthelion> Cale: microsoft sponsored Paint.net development, which took place at University of Washington, however microsoft doesn't own the software, it is open source
14:17:45 <ddarius> I think the purpose of paint is and has always been to be a little toy drawing program not intended to be used for pretty much anything.
14:18:02 <Cale> timthelion: right, so why couldn't they include that? :)
14:18:05 <cognominal> if I understant what the TextMate author says, it will be useful in the 2.0 version
14:18:35 <Cale> ddarius: That's something where windows generally sucks relative to other operating systems -- it doesn't come with anything.
14:18:38 <xerox> cognominal: what does he say?
14:18:43 <timthelion> Cale: because of antitrust concerns, they are a monopoly, therefore they are not allowed to "unfairly favor a product"
14:18:59 <ddarius> Cale: You are supposed to buy the Microsoft Office Suite.
14:19:03 <Cale> ddarius: You have to purchase and/or download and install everything that's actually useful separately.
14:19:15 <ddarius> Cale: Of course!
14:19:19 <cognominal> currently there is no real parsing, just regexing the begin and end of statements
14:19:24 <gleb> eivuokko: well, lack of convenient copy-paste is my biggest complaint.
14:19:38 <cognominal> this works fine for many verbose language, but not for haskell
14:20:13 <cognominal> he says that the leopard version will have some real kind of parsing.
14:20:37 <timthelion> Cale: they used to sell a special oem version of windows that included office, and some other tools, but when they got declared a monopoly they had to stop, and they where fined some number of billions of dolars for having sold the two products as one in the first place
14:20:48 <Cale> timthelion: right
14:20:53 <Cale> Whereas if you install Ubuntu, you get photo editing software, an office suite, and lots of other generally useful apps in the default install.
14:20:58 <eivuokko> gleb, I thought you meant the no-line-wrapping issue.  Surely you have quick edit and insert mode on if you use mouse for it, and it's not that hard with keyboard either...
14:21:05 <timthelion> yes, but ubuntu isn't a monopoly
14:21:19 <timthelion> it really hurts microsoft I think, it makes it hard for them to compeat
14:21:27 <Cale> yep
14:21:45 <timthelion> do you think this is a good thing?
14:21:46 <Cale> I'm not saying that things aren't hard for microsoft, I'm just saying that windows sucks :)
14:22:12 <cognominal> ubuntu is a negligible player compare to microsoft... except on freenode :)
14:22:15 <sfultong> wasn't someone making a haskell OS at one point?
14:22:34 <allbery_b> @where house
14:22:35 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
14:22:40 <gleb> eivuokko: maybe i'm just ignorant, but having to use the window-menu to copy-paste really drives me crazy when I use ghci on windows
14:23:44 <timthelion> sfultong: well, lindows or whatever it's called these days, is having it's core utils rewritten in haskell, and they where trying to make a shell scripting language where pure strickt types where piped around.
14:23:49 <Cale> cognominal: People are just beginning to notice it though. I finally feel comfortable installing it on my dad's machine and he actually prefers it to windows for everything that he does other than the one or two apps for which there aren't yet free replacements.
14:24:08 <timthelion> Cale: which are?
14:24:42 <sfultong> allbery_b: yeah, that's the one
14:24:44 <Cale> timthelion: Cakewalk Sonar and Soundforge. (though there's a fairly good approximant to soundforge)
14:24:49 <sfultong> timthelion: interesting
14:25:10 <timthelion> sfultong: I think it's called linspire now?
14:25:12 <Philippa> yeah, music under linux is weird
14:25:37 <Cale> Yeah, most of the tools are either good at midi or good at pure audio mixing, but generally not both at the same time.
14:26:05 <sfultong> that's why you use the virtual midi device, and chain stuff together :)
14:26:14 * ddarius has never desired to fiddle with both at the same time.
14:26:16 * gleb wants to be able to play guitar through sound card on linux
14:26:30 <ddarius> gleb: Why can't you?
14:26:31 <Cale> sfultong: Do those typically support soundfonts?
14:26:56 <gleb> ddarius: is there something like Native Instruments Guitar Rig on Linux?
14:27:12 <ddarius> gleb: I have no idea what that is.
14:27:50 <cognominal> Cale: my father trusts mainstream magazines so even proposing magazine is not an option. I admire him to get involved with computer at his age so I don't meddle in his choices
14:27:58 <gleb> ddarius: It's very cool software Guitar FX processor
14:28:09 <cognominal> s/proposing magazine/proposing macosx/
14:28:23 <Philippa> gleb: basically you can expect linux to not have anywhere near as much in the way of well-produced effect and synth plugins
14:28:27 <Cale> If there was a nice integrated midi/multitrack audio tool, (rosegarden looks like it's getting close, but it's still a bit odd to actually use), he would probably switch entirely.
14:28:40 <Philippa> you get ones aimed at coders, and ones equivalent to the freeware stuff you can get
14:28:48 <Cale> He generally prefers the Gnome UI to that of XP.
14:29:03 <Philippa> I know at least someone's got VST(i)s running under linux though, because that's what the Receptor does
14:29:19 <timthelion> Cale: you havn't got him using xmonad and vim yet?
14:29:31 <gleb> ddarius: http://www.native-instruments.com/index.php?id=guitarrig2&ftu=eaae340320ddf9e&flash=9
14:29:32 <Cale> timthelion: I don't even use xmonad yet.
14:29:32 <cognominal> Cale: I think there is linux distribution specialized in music and audio
14:29:34 <lambdabot> Title: NATIVE INSTRUMENTS : Products : Guitar Line : Guitar Rig 2, http://tinyurl.com/2nrrqd
14:29:49 <timthelion> Cale: porque no?
14:30:04 <gleb> Philippa: Of course. Linux is perfect hacking platform, everything else is not that rosy
14:30:24 <Cale> timthelion: I just can't stand tiling window managers.
14:30:36 <timthelion> Cale: what do you not like about them?
14:31:09 * ddarius doesn't use the tiling feature of xmonad.
14:31:19 <Cale> I actually like overlapping my windows such that I can see status changes in one while giving the other most of the screen real-estate.
14:32:10 <timthelion> Cale: xmonad has layouts for that, like the one I'm using now, which does cascading.  you can also float windows and manage them overlaping
14:32:23 <ddarius> @users
14:32:24 <lambdabot> Maximum users seen in #haskell: 389, currently: 385 (99.0%), active: 19 (4.9%)
14:32:39 <Cale> How about borders for resizing?
14:32:39 <ddarius> About an order of magnitude.
14:33:01 <Cale> (or do you use the keyboard)
14:33:03 <Cale> ?
14:33:05 <araujo> Cale, hah, then i guess that wouldn't be a tiling wm :-)
14:33:11 <timthelion> Cale: you hold a modifier key
14:33:21 <Cale> ah, okay
14:33:47 <Cale> I just don't feel like I'd use it any differently than I'm currently using metacity.
14:33:57 <timthelion> Cale: mod+left to move mod+ right to resize
14:34:27 <timthelion> Cale: but you wouldn't have window borders taking up space, and you could use tiling.
14:34:37 <Cale> There's not much point in using a tiling wm when you're just going to float everything :)
14:34:55 <timthelion> Cale: trust me, you won't.
14:35:07 <timthelion> Cale: have you seen the screenshots?
14:35:10 <Cale> yes
14:36:08 <evir> gleb: I've always found playing guitar through a soundcard awful. But there are a number of free plugins simulating different amplifies and speaker cabinets.
14:36:16 <ddarius> > 220*2**(1/3)
14:36:18 <lambdabot>  277.1826309768721
14:36:22 <evir> gleb: Namely the LADSPA plugin suite CAPS.
14:36:27 <Cale> Also, I'd probably still run gnome-panel -- do you happen to know if that would work well with it?
14:36:30 <timthelion> Cale: http://xmonad.org/images/screen-tim-rolodex.png
14:36:40 <ddarius> > 220*2**(7/12)
14:36:41 <timthelion> Cale: isn't that what you want?
14:36:42 <lambdabot>  329.6275569128699
14:37:02 <Cale> Sort of, not quite.
14:37:26 <timthelion> Cale: gnome panel doesn't work, but you don't need it.
14:37:33 <Plareplane> why is that screenshots demonstrating some obscure window manager usually consists of a bunch of terminal windows?
14:37:35 * araujo still doesn't decide to get xmonad because of the 'floating' syndrome
14:37:40 <Cale> I want it for all the useful applets which run it.
14:37:41 <araujo> too*
14:37:42 <Cale> in it*
14:38:10 <evir> gleb: CAPS is "quite nice" and also offers some other effects.
14:38:39 <evir> gleb: And there are also a lot of other LADSPA plugins. Maybe you want to try "jack-rack", which lets you built an effect rack out of these plugins.
14:38:58 <gleb> evir: never heard of CAPS and LADSPA, thanks
14:39:21 <evir> gleb: jack-rack and CAPS are in Debian, ready for easy use. :-)
14:39:21 <gleb> evir: are they in Ubuntu repos?
14:39:30 <evir> So probably they are in Ubuntu as well.
14:39:54 <gleb> evir: that's good news
14:40:32 <evir> gleb: Amp IV and Cabinet II are quite impressive ... but unsatisfactory (to me) on the other hand. It's getting nowhere near a real tube amp and speaker. But nice for bedroom practise.
14:41:59 * ddarius has a LADSPA binding in Haskell that he will sooner or later finish cabalizing and upload to hackage.
14:42:00 <midfield> @seen dons
14:42:00 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 12h 11m 11s ago.
14:42:11 <gleb> evir: 'bedroom practice' is all i need really
14:42:23 <evir> Ok. :-)
14:42:40 <evir> Then you'll probably like these.
14:43:04 <gleb> evir: When I last searched I've only found 
14:43:08 <evir> Although I've always had a little latency in playing ... maybe you manage getting rid of it.
14:43:14 <gleb> evir: creox, sorry
14:43:39 * ddarius is going to have to get one of those USB jack things though.
14:43:58 <gleb> evir: I had little luck to make creox actually sound
14:44:13 <evir> gleb: Hmm, I just wondered about the strange pronunciation of ''. ;-)
14:44:29 <evir> gleb: Yup. I found creox horrible.
14:44:33 <ddarius> It needs fftw interesting.
14:45:03 <gleb> evir: :) that were cyrillic letters (you probably noticed already, my english sucks)
14:45:33 <gleb> evir: latency is a problem, under windoze with ASIO drivers there's almost no latency
14:45:50 <evir> gleb: I know, I've learnt russian at school. But I don't think I ever encountered a word containing '' in that order. ;-)
14:46:07 <evir> That'd be schtschtsch transliterated...
14:46:09 <evir> :-D
14:46:16 <gleb> evir: true :)
14:47:23 <glen_quagmire> (-'.
14:49:01 <evir> gleb: What kind of sound card are you using?
14:49:16 <gleb> evir: Audigy 2
14:50:56 <glen_quagmire> i have sblive!
14:52:48 <gleb> glen_quagmire: :)
14:53:06 <atsampson> if you're having latency problems with JACK, it's worth adjusting the "frames/period" setting; if you use qjackctl it'll even calculate the latency from the settings for you
14:53:31 <atsampson> you may need to turn on real-time mode and/or use an RT-patched kernel to get it to run reliably with a small f/p, though
14:53:36 <evir> It's also good to have realtime-lsm or something similar in the kernel.
14:55:38 <atsampson> there's a load of my jack-rack configs here: http://offog.org/stuff/racks/ -- I use ibanez-cleanish/ibanez-no-pedal for electric guitar
14:55:41 <atsampson> (I'm the jack-rack maintainer)
14:55:42 <lambdabot> Title: Index of /stuff/racks
14:56:39 <gleb> atsampson: thanks for the links. haskell community is amazing :)
14:57:48 * ddarius should see how his plugins show up in jack-rakc.
14:58:30 <evir> Quite a few audio enthusiasts here ...
15:03:57 <ddarius> Hmm, how do the plugins get categorized/categorize themselves for jack-rack?
15:22:39 <sfultong> Cale: re: your earlier question about soundfonts... isn't that a function of the playback device?  soundfonts aren't sent through midi as far as I know, and the virtual midi device just resends midi data from one program to another
15:25:50 <gleb> sfultong: some programs can play soundfonts through any sound card
15:26:17 <gleb> sfultong: e.g., FruityLoops has a plugin for that
15:26:50 <sfultong> so... isn't that just emulation?
15:27:10 <gleb> sfultong: well, yes, it is emulation
15:28:12 <timthelion> sfultong: emulation isn't nesesarily an evil
15:28:37 <monochrom> much of computing is simulation.
15:28:48 <sfultong> oh, I agree... it just means that a question of soundfonts isn't really relevant to the virtual midi device
15:28:59 <shapr> @yow !
15:28:59 <lambdabot> Once upon a time, four AMPHIBIOUS HOG CALLERS attacked a family of
15:28:59 <lambdabot> DEFENSELESS, SENSITIVE COIN COLLECTORS and brought DOWN their PROPERTY
15:28:59 <lambdabot> VALUES!!
15:29:30 <monochrom> lambdabot's jokes are perverted...
15:29:31 <gleb> monochrom: hello
15:29:36 <monochrom> hello
15:30:02 <gleb> monochrom: I found your yesterday link very helpful
15:30:08 <monochrom> nice.
15:30:23 <ddarius> monochrom: Those aren't lambdabot's.
15:30:24 <hpaste>  steven_ashley pasted "Lazy ByteStrings readFile/pack/unpack/hPut problem" at http://hpaste.org/2324
15:30:34 <shapr> Those are from Zippy the Pinhead.
15:30:50 <sfultong> ahh, zippy... you wonderful and strange strip
15:31:10 <gleb> monochrom: would you mind a question on code that uses you MonadCont2? I again cannot get types right
15:31:19 * monochrom chops up Pinhead into slices of delimited continuations. Now that's zippy. :)
15:31:52 <sfultong> it'd be great if it turns out zippy was generated by markov chains all these years
15:31:54 <int-e> steven_ashley: you need something reading the output of the command. another thread probably.
15:32:11 <gleb> your MonadCount
15:32:13 <monochrom> yuck, unfortunately I have to go out now.
15:32:49 <int-e> steven_ashley: otherwise the 'cat' gets blocked on writing its output to the output pipe, never consuming its whole input, leading to the effect that you see.
15:33:02 <gleb> monochrom: ok, sorry for bothering you
15:33:37 <monochrom> In short, the code for callCC2 is the same as callCC. Just different type. Type inference alone gets you rank-1 type. But if you hand-write a rank-2 type, the computer can still see the light and agree with it.
15:33:40 <steven_ashley> int-e: yeah, that makes sense. Cheers :)
15:35:18 <gleb> monochrom: yes, i added type annotations, and it even worked until i tried to put current continuation into ReaderT
15:36:02 <steven_ashley> int-e: I am actually using "aplay -f S16_LE -c1 -r44200" in place of "cat". It has no output but plays a sound. does this have the same effect?
15:36:22 <int-e> steven_ashley: forkIO $ B.hGet out >>= \output -> return $! B.length output   should do the trick.
15:36:30 <bwwx> anyone know of an example how to copy a file in haskell?
15:36:42 <shapr> @go cp in haskell
15:36:44 <lambdabot> http://www.mega-nerd.com/erikd/Blog/CodeHacking/size_of_cp.html
15:36:44 <lambdabot> Title: m3ga blog
15:36:45 <int-e> steven_ashley: hmm if no output is produced then it shouldn't block - at least not like I described.
15:36:46 <shapr> hmm
15:36:57 <steven_ashley> okay, thanks, ill look further into it
15:36:59 <shapr> bwwx: How's that?
15:37:58 <gleb> monochrom: I'm getting "Couldn't match expected type `forall b. ContT r m b' against inferred type `ContT r m b'", though explicit type signature has all necessary forall's. I'm halfway through SPJ's paper on scoped ty vars, but still have no clue about the problem
15:38:13 <bwwx> shapr: thanks, but doesn't that read the entire file into memory?
15:38:35 <shapr> bwwx: Yeah, it does.
15:38:54 <shapr> That's not the most efficient approach I've seen.
15:39:49 <gkr> What are DSLs?
15:39:53 <bwwx> i've looked at the source for GNU cp, and they claim to have found the optimal buffer size
15:39:54 <shapr> Domain Specific Languages
15:39:57 <gkr> Thanks.
15:40:13 <shapr> bwwx: You think a lazy copy could find a better buffer size?
15:40:49 <bwwx> shapr: no, i just want to write a haskell program that copies using the same buffer size
15:41:35 <shapr> Maybe try Data.ByteString?
15:42:00 <bwwx> yeah
15:42:38 <int-e> steven_ashley: adding forkIO $ B.hGetContents out >>= \output -> (return $! B.length output) >> return ()  works for the 'cat' case though.
15:43:55 <ClaudiusMaximus> @src maybe
15:43:56 <lambdabot> maybe n _ Nothing  = n
15:43:56 <lambdabot> maybe _ f (Just x) = f x
15:47:06 <int-e> steven_ashley: oh another thing - the RTS can free the handle associated with 'out' if it's unused. that'll send a sigpipe to the running process I think
15:50:19 <shapr> What's the free / open source equivalent of flash?
15:50:31 <Hirvinen> Gnash.
15:50:46 <shapr> Er, I mean like, is it SMIL and SVG, or what?
15:51:21 <Hirvinen> Oh. Don't know about that.
15:51:36 <shapr> I just want something that will work in Firefox without using Adobe software.
15:52:11 <SamB> shapr: I thought it was silverfish or whatever...
15:52:19 <SamB> that MS thing...
15:54:05 <atsampson> ddarius: there's a spec called LRDF that lets you describe LADSPA plugins using RDF; jack-rack gets the categories (and various other stuff) from the RDF files some plugins install
15:54:36 <atsampson> have a look in prefix/share/ladspa/rdf if you've got the CAPS/TAP plugins installed, for example
15:55:48 <int-e> steven_ashley: and strace shows exactly that happening. cat tries to write, gets killed by sigpipe, *then* the original haskell program tries to write another chunk of data to cat and gets killed by sigpipe itself (that's arguably a bug)
15:55:53 <ivant> are there DBus bindings for haskell?
15:58:09 <shapr> I think so
15:58:14 <shapr> @go dbus haskell binding
15:58:16 <int-e> steven_ashley: what this means for you is that you have to keep 'out' alive until after the program finishes - and reading its complete output assures that, even when the program doesn't actually produce any output.
15:58:18 <lambdabot> http://lists.freedesktop.org/archives/dbus/2006-July/005191.html
15:58:18 <lambdabot> Title: announce: hdbus 0.1 (haskell dbus bindings)
16:03:12 <ddarius> atsampson: Cool.  Thanks.
16:05:40 <midfield> @seen dons
16:05:40 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 13h 34m 51s ago.
16:12:05 <gleb> @argh
16:12:05 <lambdabot> Keelhaul the swabs!
16:14:37 <gleb> @users
16:14:37 <lambdabot> Maximum users seen in #haskell: 389, currently: 370 (95.1%), active: 15 (4.1%)
16:18:12 <gleb> section 7.4.8 of GHC manual says 'you cannot instantiate a type variable with a forall-type'
16:18:46 <gleb> section 7.4.9 says 'you can call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types'
16:18:52 <Cale> heh
16:18:54 <ivant> shapr, it seems they haven't change since last year, looks like the project died away
16:19:01 <gleb> contradiction, isn't it?
16:19:23 <ClaudiusMaximus> is there a standard combination of takeWhile and dropWhile that traverses the list just once?
16:19:45 <gleb> > :t split
16:19:46 <lambdabot>   parse error on input `:'
16:20:09 <gleb> @t split
16:20:10 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
16:20:22 <Cale> gleb: It's like the bible where contradictions are resolved by always picking the stuff which comes later ;)
16:20:37 <ivant> I was thinking that dbus support in xmonad could be cool. E.g., it could send dbus messages to some script which would pipe them to dzen
16:20:51 <gleb> Cale: :)
16:21:49 <gleb> Cale: these sections are so close, it made me think that i miss something
16:21:55 <Cale> gleb: I think the thing is that it's talking about different type system extensions.
16:22:16 <Cale> Impredicativity is an extension of higher-rank polymorphism
16:23:20 <gleb> ClaudiusMaximus: you want span. span p xs is equivalent to (takeWhile p xs, dropWhile p xs)
16:24:28 <gleb> Cale: BTW, why the name 'impredicativity'? is there some logic textbook with explanation of the term?
16:24:45 <ivant> @foldoc impredicativity
16:24:47 <lambdabot> No match for "impredicativity".
16:26:35 <Philippa> gleb: TaPL has an explanation. Roughly speaking, predicativity is actually a /limitation/
16:26:51 <Philippa> and it comes from viewing things as a logic rather than a type system
16:27:01 <mrd> impredicative is a term invented by Russell
16:27:08 <mrd> and he uses it to refer to naive Set Theory
16:27:28 <Philippa> right, with predicative being a property of the systems he's after
16:27:36 <mrd> unable to express the paradox
16:27:44 <mrd> yes, I've been puzzled by impredicative type systems too
16:27:53 <Cale> Predicative usually refers to a definition made without reference to the thing being defined
16:28:24 <Cale> (while impredicative means that the definition can depend on a number of things, one of which is the thing being defined)
16:28:45 <Cale> However, I'm not completely sure at the moment how this applies, plus I have to run
16:28:59 <mudge> hello
16:29:03 <gleb> Cale: I don't see a connection. How presense of quantifier makes type self-referent?
16:29:09 <gleb> hello
16:29:23 <gleb> Philippa, mrd: thanks
16:29:25 <mrd> consider "The Set of all Sets which do not contain themselves"
16:29:28 <Philippa> remind me sometime I'm more awake and I'll run through TaPL
16:29:39 <ClaudiusMaximus> gleb: thanks
16:29:40 <mudge> I just wrote a really short tutorial explaining what currying is for newbies,  is anyone interested in taking a quick look at it and telling me what they think?
16:30:13 <mrd> mudge: you should ask Xah Lee to review it ;)
16:30:18 <ClaudiusMaximus> actually i'm thinking a better data structure than a list would be better for implementing this:  http://tinyurl.com/2sr2p2
16:30:20 <lambdabot> Title: Google Code Search
16:30:41 <mudge> thanks mrd,   just curious,  why that guy?
16:31:40 <ClaudiusMaximus> it's a ramp generator, that responds to tuples of (startTimeRelativeToNow, valueToRampTo, timeToTakeToRamp)
16:31:48 <mrd> I'm just kidding.  what's the url?
16:32:03 <mrd> ClaudiusMaximus: No Content.
16:32:15 <mudge> oh,  http://www.nickmudge.info/?post=42
16:32:17 <lambdabot> Title: Explanation of Haskell Currying
16:32:23 <mudge> damn right lambdabot
16:32:51 <gleb> mrd: I've heard of Russell's paradox, I just miss a connection with Haskell's type system. Well, Russell's paradox is worded using universal quantifier, but the tricky part IMO is 'do not contain _themselves_'. I lack proper training in logic though
16:33:14 <mrd> gleb: the tricky part is quantification over all Sets
16:33:26 <mrd> which is what Russell attempted to eliminate ... in his Theory of Types.
16:33:47 <mudge> do you guys think it is pretty useful to be familiar with logic and reasoning  for programming in haskell?
16:34:06 <int-e> mudge: it helps with the type system
16:34:09 <mrd> mudge: looks good
16:34:27 <mrd> I think being familiar with reasoning is good for working with a computer =)
16:34:46 <mudge> thanks mrd
16:34:47 <mudge> lol
16:34:55 <mudge> yea, i didn't mean that kind of reasoning
16:35:08 <mudge> i mean, like logic
16:35:14 <mudge> formal logic stuff
16:35:35 <gleb> mudge: I lack math logic background, and that is why i spent all day figuring out why my code doesn't compile
16:35:35 <mudge> i wonder if I should study up on that if I want to be really good at and understand haskell really well
16:35:51 <Philippa> mudge: it's definitely useful
16:36:03 <mrd> well, if you don't understand formal logic, you might end up just stumbling through those ideas without any sense of awareness
16:36:34 <mudge> thanks guys
16:36:58 <mrd> it's not about some magical body of knowledge, the important thing is the discipline and rigor of thought
16:37:14 <mudge> oh,  i was thinking magic,
16:38:10 <mudge> yea,  i was looking at all the connections of functions of haskell,  one idea built on another built on another built on another,   a lot like a writing code in a functional style
16:39:59 <gleb> mrd: Are there any good docs about GHC type system extensions (besides GHC manual itself)?
16:40:18 <mrd> usually a type system extension has a body of research behind it
16:40:24 <mrd> that leaves a definite "paper" trail
16:41:56 <gleb> mrd: I see. I read SPJ's paper on higher-rank types, but it's more about type inference algorithm, it doesn't help understanding, how to use it in practice, what are gotcha's etc
16:42:08 <int-e> steven_ashley: In case you care, I've created a bug report about this. http://hackage.haskell.org/trac/ghc/ticket/1619
16:42:11 <lambdabot> Title: #1619 (The RTS chokes on SIGPIPE (happens with runInteractiveCommand)) - GHC - T ...
16:42:29 <mrd> gleb: did you check the wiki for any articles?
16:43:28 <gleb> mrd: yes
16:43:30 <bwwx> int-e: can you please explain this bug
16:44:40 <int-e> bwwx: can you ask a more concrete question? There's a description of what's going on in the report.
16:45:20 <mrd> http://www.ubka.uni-karlsruhe.de/vvv/1996/informatik/81/81.pdf.gz ?
16:46:09 <gleb> mrd: thanks, I'll check it out
16:47:00 <gleb> mrd++
16:48:43 <bwwx> int-e: why does the RTS closes the input end of the output pipe of the cat process?
16:49:00 <int-e> bwwx: because the garbage collector finds that it's no longer in use.
16:50:32 <syntaxfree> this is just brilliant.
16:50:34 <syntaxfree> http://www.cs.caltech.edu/~mvanier/hacking/rants/cars.html
16:50:35 <lambdabot> Title: Mike Vanier: opinions
16:50:47 <sorear> Philippa: you've got a stray op bit
16:51:11 <int-e> bwwx: and that's correct behavious I believe, although a bit inconvenient.
16:51:22 <int-e> s/ious/iour/
16:52:17 <bwwx> int-e: what does a core file do?
16:53:06 <glguy> @users
16:53:06 <lambdabot> Maximum users seen in #haskell: 389, currently: 372 (95.6%), active: 18 (4.8%)
16:53:25 <int-e> bwwx: it's just some big file. (core files are usually snapshots from crashing programs and often quite big, I happened to have one lying around when I tested this)
16:53:50 <int-e> bwwx: but any big file will do. I don't know how big 'big' is exactly.
16:55:24 <bwwx> int-e: does the hPutStr print none of the data, some of the data, or all of the data?
16:55:54 <int-e> bwwx: the hPutStr sends data to the 'cat' process. nothing of that is ever displayed.
16:56:19 --- mode: Philippa set -o Philippa
16:56:34 <Philippa> sorear: cheers, forgot to yank it after the relevant k/b
16:56:59 * glguy read the log about thundergirl when he joined an saw Philippa had the +o
17:05:40 <shapr> glguy: Was amusing, yeah?
17:05:52 <glguy> somewhat I suppose ;)
17:06:06 <glguy> the Internet brings out a weird breed
17:06:57 <mudge> hey, what do you guys use IRC for?
17:07:09 <mudge> how do you use the haskell channel?
17:07:15 <mudge> is there a FAQ?
17:07:41 <shachaf> mudge: Do you mean lambdabot?
17:07:48 <SamB> we, uh, use IRC for talking
17:07:55 <SamB> to eachother
17:08:21 <mudge> I mean what I say
17:08:32 <bwwx> Tux the penguin! http://www.tfh-berlin.de/~panitz/hopengl/images/Tux.epsf.gif
17:08:39 <shachaf> mudge: Well, SamB's answer looks right.
17:08:43 * shachaf talks to SamB.
17:08:59 * SamB thinks shachaf is just emoting
17:09:25 <SamB> or, well, whatever you call :
17:09:32 <shachaf> SamB: ":"?
17:09:38 <glguy> ??
17:09:47 * SamB refers to MUD/MOO conventions now...
17:09:48 <syntaxfree> Uh, where am I?
17:10:24 <mudge> hi syntaxfee
17:10:33 <mudge> what language is syntaxfree?
17:11:32 <gleb> mudge: lisp maybe
17:11:44 <SamB> mudge: well, why don't you see what kind of text he admits
17:12:12 <shachaf> gleb: Most LISPs have syntax.
17:12:17 <mudge> okay,   syntaxfree:   what text do you admit?
17:12:40 <mudge> he's not answering
17:12:48 <mudge> i guess he doesn't admin very much syntax
17:12:55 <shapr> mudge: I use IRC for socializing.. I don't have a life while my girlfriend live in another country.
17:13:10 <mudge> oh nice shapr
17:13:20 <mudge> i don't have a life or a girl friend in another country
17:13:26 <syntaxfree> shapr: I left a medium-distance relationship two weeks ago.
17:13:28 <shapr> My life is in Sweden.
17:13:34 <syntaxfree> She was about 300km from where I live.
17:13:36 <mudge> haha,  a medium distance
17:13:42 <shapr> mudge: I also use IRC for learning and teaching.
17:13:49 <shapr> And for my job too
17:13:55 <mudge> wow, cool
17:14:00 <mudge> what is your job shapr
17:14:20 <shapr> I have a full-time job writing Haskell, I hack on HAppS!
17:14:30 <mudge> that's awesome
17:14:36 <shapr> Yeah, it's nice getting paid to hack Haskell.
17:15:01 <mudge> i want to build a web framework in haskell too
17:15:10 <mudge> I guess I should learn haskell well
17:15:25 <mudge> is it pretty cool,   happs?
17:15:29 <shapr> Yeah, it's nice.
17:15:50 <shapr> It's pretty different, but worth it.
17:16:24 <mudge> how does happs make money?
17:16:58 <shapr> It doesn't yet :-)
17:17:23 <shapr> But the idea is that a far more efficient web framework will allow for much faster and saner prototyping and producing of web apps.
17:17:43 <shapr> Before this job I hacked Python in Zope/Plone for seven years, so I have a good idea of the problems.
17:17:58 <shapr> I've also done some webdev in ASP (ouch) and J2EE (double ouch).
17:18:08 <shapr> I did J2EE for two years or so.
17:19:13 <mudge> that's awesome,   and this "But the idea is that a far more efficient web framework will allow for much faster and saner prototyping and producing of web apps."  is exactly what I've been thinking,  and one of the reasons I'm really interested in haskell
17:19:42 <ivant> shapr, well, ASP qualifies for dozen ouches
17:19:46 <wolverian> I guess I should take a look at happs. is it maintained?
17:19:55 <shapr> HAppS just went through some major changes, and the new sources aren't released yet, but the release will happen soon.
17:20:16 <shapr> Yeah, it's maintained, but you should really wait for the new repo release, hopefully to happen in the next week.
17:20:30 <mudge> I'm going to check it out
17:21:55 <mudge> shapr  how does happs store data?
17:22:26 <wolverian> shapr, thanks :)
17:22:40 <shapr> Application data is kept in memory, and transactions are written to disk.
17:23:37 <mudge> rad,    it has it's own system for writing and getting data from disk,  like its own database system?
17:24:03 <shapr> Yeah, part of the idea behind HAppS is that concurrency should be handled in the framework, not pushed off to the database.
17:24:35 <shapr> Also, data should be in the native language, no marshalling back and forth from a db.
17:24:45 <mudge> nice
17:24:56 <mudge> for some reason I'm trying to get away from RDMS
17:26:52 <mudge> later
17:29:28 <bitwize> shapr, that's pretty pimp.
17:45:32 <dolio> Aww...
17:45:34 <dolio> @yarr
17:45:34 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
17:50:28 * SamB thought bung went defunct or something :-(
17:57:27 <glen_quagmire> ghc-6.6: internal error: evacuate: strange closure type 8    :: what is this?
17:59:20 <shachaf> glen_quagmire: An error message.
17:59:44 <glen_quagmire> whta's type 8 though? google hasn't any
17:59:47 <shachaf> glen_quagmire: How did you get it?
18:00:17 <glen_quagmire> i was compiling gtk2hs shachaf
18:00:31 <shachaf> Oh.
18:01:42 <shachaf> glen_quagmire: (Do you use x86-64?)
18:01:50 <Igloo> 8 isn't anything meaningful
18:02:38 <glen_quagmire> shachaf: no. man i forgot to copy entire error message
18:02:49 <glen_quagmire> it was like (x86_unknown_linux)
18:03:34 <glen_quagmire> compilation took over an hour then error. i'll probably retry it tomorrow
18:11:42 <pgavin> giggidy giggidy goo
18:16:09 <xpika> does anyone here know anything about concurrency?
18:17:35 <glguy> xpika: you are really better off just asking your questions
18:17:51 <dolio> I'd be willing to be that someone here knows something about it.
18:17:55 <mwotton> i know i can't get any spaghetti because this bastard Kant won't put his fork down.
18:17:55 <xpika> if I use writeTVar does that mean i can have another thread reading it at the same time
18:18:38 <glguy> xpika: with STM, you just use the TVar as if you were the only thread running
18:18:50 <glguy> and STM makes sure that all threads are shown a consistent view of the world
18:19:55 <xpika> consistency is not the problem i dont think
18:20:15 <OceanSpray> hpaste, url plz
18:20:15 <hpaste> Haskell paste bin: http://hpaste.org/
18:20:34 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2325
18:20:37 <xpika>  mapM_ (\x->atomically (writeTVar q (rotate x x_axis)) >> threadDelay 4) [1..10]
18:20:42 <OceanSpray> this is giving me a parse error
18:20:43 <pjd> OceanSpray: how's your Scheme coming along?
18:20:46 <OceanSpray> what am I doing wrong?
18:20:51 <xpika> sometimes when i run it its smooth
18:20:57 <OceanSpray> pjd, not so good.
18:21:00 <xpika> sometimes hangs in the middle
18:21:34 <xpika> i thought changing it from IORef to TVar the problem would be solved
18:21:46 <OceanSpray> disregard the typo at the beginning
18:21:53 <OceanSpray> that's a pasting error
18:21:54 <pjd> OceanSpray: you can't put rest <- unwrapArgs cdr in the body of a case, can you?
18:22:03 <OceanSpray> huh?
18:22:33 <shapr> glen_quagmire: What flavor of linux do you use?
18:22:43 <OceanSpray> ok, it compiles now
18:22:43 <OceanSpray> thanks
18:22:50 <shapr> glen_quagmire: There may be an existing compiled version of gtk2hs for your distro.
18:23:08 <pjd> OceanSpray: unless i'm mistaken
18:23:24 <glguy> <- is part of do-notation
18:23:28 <glen_quagmire> shapr: archlinux. yes we have. but it's 0.9.10. current version is 0.9.12
18:23:43 <pjd> you could, OTOH, say something like: rest <- case foo of ...
18:23:58 <OceanSpray> eh
18:24:02 <OceanSpray> it's already compiled.
18:24:19 <OceanSpray> now, to rewrite the primitives with less pain...
18:29:37 <Arnia> shapr: do you have a darcs repository for FLM? I'm interested in seeing a more complex HAppS application
18:36:43 <OceanSpray> Is there an easy way to pattern match against two values at once?
18:36:53 <OceanSpray> putting them in a tuple?
18:37:29 <OceanSpray> I've got a lot of 'case a of {b -> case c of {d -> ...etc.
18:37:54 <pjd> probably
18:38:17 <mrd> sure, you can tuple them
18:38:19 <pjd> case (a,c) of (b,d) -> ... ?
18:38:50 <mrd> laziness will save you -- in case you don't necessarily want the value of a particular element
18:45:00 <hpaste>  glen pasted "(no title)" at http://hpaste.org/2326
18:45:34 <glen_quagmire> oops. i thought I pressed Tab key instaed of Enter
18:45:44 <glen_quagmire> that's gtk2hs compilation error message
18:47:34 <dons> moin
18:49:08 <glguy> @users
18:49:09 <lambdabot> Maximum users seen in #haskell: 389, currently: 360 (92.5%), active: 12 (3.3%)
19:04:11 <timtheli1n> is yi a test/reasearch project or is it meant to be used seriosly?
19:04:30 <OceanSpray> I got a warning after using the tuple to pattern-match
19:04:55 <OceanSpray>     Warning: Pattern match(es) are overlapped
19:04:55 <OceanSpray>              In a case alternative: (_, Nothing) -> ...
19:05:19 <OceanSpray> it still compiled, though
19:06:25 <glen_quagmire> timtheli1n: yi is a serious business
19:06:45 <dons> heh, i think its alpha. but yi 0.1 (the curses version) is a farily serious vi
19:06:47 <timtheli1n> glen_quagmire: ok thanks!
19:06:48 <dons> seafoodX: hey
19:07:03 <dons> timtheli1n: its not research project
19:07:24 <timtheli1n> it looks perfect for my needs
19:08:10 <timtheli1n> how large is the user base?
19:08:20 <dons> tiny?
19:08:30 <timtheli1n> dons: are you part of it?
19:08:56 <dons> not any more. i wrote yi 0.1, but jyp now maintains yi -- and develops it
19:09:07 <timtheli1n> why not?
19:09:10 <dons> yi 0.1 is a console vi clone. the newer yi is more like emacs
19:09:14 <dons> oh, not enough time :)
19:09:28 <timtheli1n> oh, is it still in the "unstable" stage?
19:09:50 <dons> i'd think so, yes.
19:09:58 <timtheli1n> ok.
19:10:40 * timtheli1n Probably should start using stable software before school starts just beacuse he's so addicted to hacking
19:10:42 <shachaf> dons: Will yi be usable as a vi-style editor?
19:11:39 <dons> yi 0.1 sure is.
19:11:49 <dons> and has been for 3 years now :)
19:12:01 <dons> it implements 90% of vi
19:12:09 <timtheli1n> Setup.hs:17:7:
19:12:09 <timtheli1n>     Could not find module `System.FilePath':
19:12:10 <timtheli1n>       Use -v to see a list of the files searched for.
19:12:12 <timtheli1n> wow,
19:12:15 <jcreigh> what percentage of vim does it implement?
19:12:30 <timtheli1n> that's what I get for trying to configure with setup.lhs
19:12:38 <dons> jcreigh: unknown -- vim is big :)
19:12:44 <dons> timtheli1n: you need the filepath package
19:12:47 <timtheli1n> does it have spell checking and utf-8 support?
19:12:58 <conal> dons: what's the scoop on hs-plugins?  is it evolving?  being relaced?  did the windows bug get fixed?
19:12:59 <jcreigh> heh, yeah. vim is the emacs of vi clones.
19:13:22 <sjanssen> @yow
19:13:23 <lambdabot> Your CHEEKS sit like twin NECTARINES above a MOUTH that knows no BOUNDS --
19:13:26 <OceanSpray> what
19:13:44 <shachaf> @where filepath
19:13:44 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
19:13:49 <shachaf> timtheli1n: Try that.
19:13:58 <shachaf> timtheli1n: (Or GHC 6.6.1, I think.)
19:14:23 <timtheli1n> hmm
19:14:29 <timtheli1n> ok
19:15:00 <dons> conal: it is currently in statis. i'm unlikely to improve it further, but will probably keep it working on unix until ghc-api is rich enough
19:15:17 <dons> conal: i think the only way forward is to layer the hs-plugins api on top of ghc-api
19:15:17 * timtheli1n is using ghc6.6
19:15:39 <dons> since hs-plugins itself is low level enough that it break on every ghc upgrade
19:15:44 <OceanSpray> @yow
19:15:45 <lambdabot> I HAVE to buy a new "DODGE MISER" and two dozen JORDACHE JEANS because
19:15:45 <lambdabot> my viewscreen is "USER-FRIENDLY"!!
19:15:59 <dons> while ghc-api is guaranteed to continue to work for bytecode loading, compilationg and so on, and just needs the api described in the first hs-plugins paper
19:16:02 <OceanSpray> oh lambdabot, you CARD you.
19:16:11 <dolio> Man, the SICP reviews 'story' on reddit is pretty funny.
19:16:18 <OceanSpray> link pl0x
19:16:18 <conal> dons:  okay, thanks.  makes a lot of sense to me.  is anyone working on redoing hs-plugins adop ghc-api?
19:16:38 <timtheli1n> after installing ghc6-filepath-dev and the darcs of filepath...
19:16:39 <timtheli1n> e
19:16:42 <timtheli1n> Setup.hs:17:7:
19:16:42 <timtheli1n>     Could not find module `System.FilePath':
19:16:42 <dons> conal: not that i know of, but i suspect it couldn't take more than a week to implement most of the api
19:16:42 <timtheli1n>       it was found in multiple packages: filepath-1.0 FilePath-0.11
19:16:59 <dons> timtheli1n: you need to hide filepath-1.0 or else specify which version explicitly
19:17:31 <gwern> dolio: I like the reviews which say the stuff SICP talks about is useless
19:17:43 <timtheli1n> yay!
19:17:50 <conal> dons: okay, thanks.  i'm rebuilding eros, and hs-plugins was very handy for speed.
19:17:50 <OceanSpray> dolio, LINK PL0X!!1
19:18:13 <dons> conal: right. we that runtime-generated compiled code for a few different applications
19:18:15 <dolio> gwern: I'm quite partial to the one where they guy tried to port the algorithms to C, couldn't do it, and came to the conclusion that Scheme suck based on that.
19:18:41 <dons> conal: but i'm starting work at galois in 2 weeks, so probably can't really work on hs-plugins very much at all
19:18:43 <dolio> OceanSpray: http://programming.reddit.com/info/2gh5n/comments
19:18:44 <lambdabot> Title: SICP reviews in increasing order (reddit.com)
19:18:52 <OceanSpray> thanks
19:19:01 <gwern> dolio: it simultaneously reflects on his skills and knowledge, his understanding of the algorithms, *and* the quality of C as a language for algorithms!
19:19:07 <conal> dons: i hadn't heard that.  wow!  quite a move.
19:19:18 <gwern> conal: wait, eros? as in the capability OS?
19:19:42 <conal> @where eros
19:19:42 <lambdabot> I know nothing about eros.
19:19:42 <OceanSpray> Well...I was wrong!!! Or rather, the professor was wrong. This book, and the Scheme language especially, is just horrible. I was an experienced programmer, and I still found it a tough time trying to write programs based on this book.
19:19:42 <dons> conal: :) yeah. off to the states!
19:19:48 <OceanSpray> My God.
19:19:54 <OceanSpray> The people on reddit must be idiots.
19:20:09 <conal> @help where+
19:20:09 <lambdabot> where+ <key> <elem>. Define an association
19:20:10 <dolio> No, no. They're just quoting from the reviews on Amazon.
19:20:17 <conal> where+ eros http://conal.net/papers/Eros
19:20:19 <lambdabot> Title: Tangible Functional Programming
19:20:23 <conal> @where eros
19:20:23 <lambdabot> I know nothing about eros.
19:20:28 <conal> :(
19:20:37 <gwern> conal: oh. not EROS then. :(
19:20:45 <conal> gwern.  right.
19:20:46 <dons> ?where+ eros http://conal.net/papers/Eros
19:20:46 <lambdabot> Done.
19:20:49 <OceanSpray> oh wait
19:20:49 <dons> ?where eros
19:20:50 <lambdabot> http://conal.net/papers/Eros
19:20:55 <OceanSpray> that's a quote, lol
19:20:57 <timtheli1n> @where vty
19:20:57 <lambdabot> I know nothing about vty.
19:20:59 <OceanSpray> thought it was a post
19:21:00 <dons> conal: will you be at ICFP?
19:21:06 <conal> dons: what's with ? vs @ ??
19:21:08 <OceanSpray> SORRY, REDDIT-USERS
19:21:17 <dons> oh, they're synonyms
19:21:26 <dons> @slap OceanSpray
19:21:26 * lambdabot beats up OceanSpray
19:21:27 <dons> hehe ;)
19:21:32 <conal> hm.  why didn't my @where+ work?
19:21:33 <sorear> @where+ vty darcs get http://members.cox.net/stefanor/vty/
19:21:33 <lambdabot> Done.
19:21:42 <dons> conal: you missed the prefix?
19:21:43 <OceanSpray> :(
19:21:56 <conal> oh! missed the  @.  :P
19:21:59 <sorear> @flush
19:22:01 <conal> dons: thanks
19:22:21 <sorear> conal: ^^
19:22:38 <sorear> timtheli1n: I meant you
19:22:51 <timtheli1n> sorear: thankyou
19:22:57 <conal> I'm considering Hac II (http://www.haskell.org/haskellwiki/Hac_2007_II ).  Anyone here going?  Exciting projects to recommend?
19:22:59 <lambdabot> Title: Hac 2007 II - HaskellWiki
19:23:17 <conal> maybe a new hs-plugins
19:23:41 <dons> conal: yeah! I'm helping organise. please come along to the hackathon :)
19:24:01 <thetallguy> Conal: I'll be there for the first day, but that's it.
19:24:11 <thetallguy> maybe not the whole day, either
19:24:18 <dons> conal: the attendees list is here, http://www.haskell.org/haskellwiki/Hac_2007_II/Attendees
19:24:20 <lambdabot> Title: Hac 2007 II/Attendees - HaskellWiki
19:24:23 <OceanSpray> When will people learn that Computer Science != Computer Engineering?
19:24:49 <conal> dons: it sounds like fun.  i'll see if i can change my plane tickets.  i arranged them before i noticed Hac.
19:25:40 <dons> yeah. maybe you can delay it a day or two, and come along to some of the hackathon. that'd be great!1
19:26:14 <conal> i wonder if anyone would be interested in very fast haskell-native image synthesis.  after the Binary perf success, i've wondered if ghc could come close to Pan performance.
19:26:38 <dons> mm. that is interesting
19:26:59 <dons> conal: or using harpy for runtime assembly generation for really tight loops
19:27:02 <sorear> @go pan image synthesis
19:27:04 <dons> have you looked at harpy?
19:27:12 <fnord123> Does anyone know if the developers of wxHaskell use freenode?
19:27:18 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
19:27:20 <conal> dons: yeah.  a bit.
19:27:31 <dons> fnord123: the developers? :)
19:27:31 <conal> @where pan
19:27:31 <lambdabot> I know nothing about pan.
19:27:39 <conal> @where+ pan http://conal.net/Pan
19:27:39 <lambdabot> Done.
19:27:42 <conal> @where pan
19:27:42 <lambdabot> http://conal.net/Pan
19:27:44 <conal> :)
19:27:49 <sorear> fnord123: kosmikus is on that list
19:27:55 <dons> fnord123: probably you need to talk to Eric Kow (kowey) -- he's online i think
19:28:12 <conal> @where+ pajama http://conal.net/Pajama
19:28:13 <lambdabot> Done.
19:28:54 <sorear> dons: what about eric kow?  he's not listed on the wxhaskell dev page
19:29:43 <dons> sorear: i thought he was the maintainer now.
19:29:52 <dons> at least his blog articles have stated that
19:32:13 <OceanSpray> "Chapter 4, on interpreters is totally pointless. It shows you how to design a scheme interpreter, written in Scheme! How much dumber can you get?"
19:32:20 <fnord123> Jeremy O'Donoghue is the maintainer as of Jan 20
19:32:45 <fnord123> but there was a year and a half between him picking it up and the last news snippet on the wxhaskell site
19:32:50 <conal> eric asked me if i could help out with wxhaskell.  (i said no.)  i think he's too busy to maintain it.
19:33:24 <OceanSpray> oh noes
19:33:33 <fnord123> it seems to not be developed very aggressively. gtk2hs looks like it's in better shape, but id really like to target os x and linux
19:33:45 <dolio> OceanSpray: I suppose an interpreter is a bit pointless. They show how to make a compiler too, though, no? (It's been a while since I read).
19:33:54 <OceanSpray> I dunno
19:34:03 <OceanSpray> interpreter? pointless?
19:34:09 <OceanSpray> WHAT AM I DOING!?
19:34:24 <dolio> Well, it's not pointless as an exercise.
19:34:35 <OceanSpray> ok, there
19:34:46 <dolio> But, if you have a Scheme interpreter written in Scheme, you already need some other scheme implementation to run it.
19:34:55 <OceanSpray> but seriously, I don't think it's POSSIBLE to write a reasonable compiler for this language I'm implementing
19:34:56 <fnord123> OceanSpray: "I have been trying to port some algorithms in the book into C, oh boy, what a frustrating experience"
19:34:59 <shapr> Arnia: Not yet
19:35:05 <shapr> Arnia: Soon!
19:35:10 <OceanSpray> fnord123, yeah I saw that. LULZ
19:35:36 <fnord123> the conclusion? "This vision has left me a very bad impression on Scheme"
19:35:38 <OceanSpray> porting to C...
19:35:42 <OceanSpray> kids these days.
19:37:00 <dolio> Yeah, damn that Scheme and the fact that it makes writing some things easier than C. :)
19:37:13 <OceanSpray> You know what I noticed?
19:37:15 <Arnia> shapr: I'm trying to get my head around good abstraction principles for HAppS systems but a bit of me keeps screaming 'arrows!'
19:37:26 <OceanSpray> about 50% or more of these reviews were written by C programmers
19:37:38 <Arnia> shapr: I think because I can visualise them better than imperative-style monadic code ;)
19:38:22 <OceanSpray> Also, there's a strange lack of Java users.
19:38:25 <scook0> speaking of SICP, does anyone feel devious enough to post Wadler's "Why calculating is better than scheming" to that thread? (I don't have a reddit account myself)
19:38:56 <fnord123> I think it's written mostly by kids with exposure to C and think other pursuits are ugly. Like some kid in the midwest who grew up on baseball suddenly finding out that soccer is the most popular sport in the world.
19:39:01 <OceanSpray> you'd think that, with the AP curriculum and most University Intro CS courses what they are nowadays,
19:39:17 <OceanSpray> there'd be more Java guys screaming "WHERE'S THE CLASSES, LOL"
19:39:43 <fnord123> scook0: url?
19:39:59 <scook0> http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf
19:40:08 <scook0> [PDF ALERT!]
19:40:12 <scook0> :)
19:40:16 <dolio> Heh.
19:40:17 <fnord123> im on mac. :)
19:40:57 <Nafai> Hrm.
19:41:05 <Nafai> I've never heard of KRC
19:41:40 <dons> seafood: around?
19:41:57 <fnord123> done
19:42:13 <scook0> Wikipedia says KRC is a predecessor to Miranda
19:43:09 <mrd> anyone else having trouble accessing sequence.complete.org?
19:43:12 <fnord123> er. I assumed he meant K&R C aka Kernigan and Ritchie C...
19:43:24 <Nafai> The first Miranda example in that paper could be mistaken for Haskell :)
19:43:39 <fnord123> the paper makes more sense now, scook0 :P
19:44:06 <OceanSpray> Miranda looks like Haskell
19:44:22 <stepcut> OceanSpray: no, Haskell looks like Miranda
19:44:37 <dons> Miranda (TM) is a trademark of Research Software.
19:44:51 <scook0> dons: I was waiting for that :)
19:44:58 <shachaf> @quote Miranda
19:44:58 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
19:45:16 <OceanSpray> I thought 'looked like' was commutative.
19:45:46 <stepcut> OceanSpray: well, in that sentence, it has a temporal implication
19:45:47 <scook0> OceanSpray: strictly speaking yes, but it implies "based on"
19:46:13 <Arnia> "Chapter 4, on interpreters is totally pointless. It shows you how to design a scheme interpreter, written in Scheme! How much dumber can you get?"
19:46:29 * mrd feels a sense of deja vu
19:46:38 * OceanSpray
19:48:03 <OceanSpray> http://www.hiren.info/funstuff/funny-video-clips/lady-with-bike
19:48:05 <lambdabot> Title: Funny Videos  Lady with Bike - www.hiren.info
19:48:38 <shachaf> @go "chapter 4, on interpreters"
19:48:41 <lambdabot> http://cs.wellesley.edu/~cs251/spring00/courseInfo.pdf
19:49:11 <qwr> Arnia: it's very practical, if you're writing scheme compiler and especially, when it had been lisp instead of scheme (lisp macros) ;)
19:50:20 <Arnia> qwr: Indeed... I was just loving the lack of background knowledge to that statement. Of course one can't write an Epigram interpreter in Epigram, but that is worn as a badge of honour *ducks*
19:52:37 <dolio> Even Epigram 1 let you have general recursion if you asked for it specifically.
19:53:26 <sorear> Nafai: KRC is also one of Binkley's monikers (mostly on older systems, as those are no longer his initials)
19:53:49 <Arnia> I leave Epigram hacking to others in my department... *looks wary at it*
19:54:19 <sorear> Arnia: is this SICP?
19:54:57 <Arnia> sorear: yeah, I'm reading through the reader comments myself
19:55:07 <sorear> General recursion in epigram is not hard, or at least no harder than IO in Haskell
19:55:27 <sorear> it's pretty trivial to write up a GR monad, define laws, prove stuff
19:56:41 <Arnia> Fair enough... I was more commenting from ignorance to make a cheap joke ;)
19:57:29 * sorear doesn't know that much about it either (but is familiar with The Competition)
19:58:07 <Arnia> Paul Callaghan (in my dept) is smitten by it
19:58:29 <Arnia> At least I think so... he's very fond of dependent types, but not so fond of emacs
19:58:46 <dolio> Heh.
19:59:31 <dolio> Connor McBride promised that Epigram 2 wouldn't be tied to XEmacs, as I recall. :)
19:59:38 <sorear> I'm not too crazy about emacs either, I mean it has no static types at all!
19:59:56 <Arnia> dolio: yeah, Paul has been bugging him about that for a couple of years :)
20:00:02 <dolio> I suppose theoretically Epigram 1 wasn't either.
20:00:11 * sorear would like to play with epigram, but xemacs wedges (100% cpu and constant flickering) when he tries to set a reasonable font
20:00:20 <Arnia> Ever since Connor left the department for Nottingham I think...
20:00:21 * sorear does. not. do. black. on. white.
20:00:26 <dolio> But to use it with something else, you'd have to implement some other interface that sent all keypressed to Epigram and interpreted the elisp it sent back. :)
20:02:12 <sjanssen> sorear: is your window manager obeying size hints?
20:03:10 <mrd> I was thinking about finally installing xemacs today and getting epigram to work
20:03:19 <shachaf> sjanssen: sorear uses xmonad. :-)
20:03:31 <dolio> Epigram comes with its own copy of xemacs.
20:03:59 <sjanssen> shachaf: I know.  xmonad is so flexible that I still don't know if his WM is obeying size hints ;)
20:04:05 <shapr> @seen dcoutts
20:04:05 <lambdabot> I saw dcoutts leaving #gentoo-haskell, #haskell-overflow, #haskell and #ghc 1d 12h 44m 13s ago, and .
20:04:06 <Arnia> I'd actually quite like to see a programming language with proofs sort of like Isabelle/Isar
20:04:08 <shapr> @seen dcoutts_
20:04:08 <lambdabot> dcoutts_ is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I don't know when dcoutts_ last spoke.
20:04:15 <Arnia> A project for the future I suppose :)
20:04:23 <shapr> Epigram sure is nifty.
20:04:29 <shachaf> sjanssen: I think it uses one of the size-hint-obeying modules.
20:04:47 <shapr> But I've realized that Haskell is in a really important sweet spot with respect to terminating type checking, type inference, and general recursion.
20:05:06 <shapr> I think that anything 'past' Haskell (like Epigram) will have to find a new balance among those three.
20:05:28 <mrd> well they're trying that with epigram 2
20:05:54 <shapr> I hope they find a good balance.
20:06:37 <shapr> What else can I do to speed up compilation with GHC?
20:07:04 <Arnia> shapr: grid it? ;)
20:07:31 <shapr> I wish it could use both cores.
20:07:48 * Arnia sometimes has a horrible desire to submit a ton of infinite loops to Durham's grid
20:08:01 <sjanssen> shapr: ghc can dump out a Makefile (similar to --make's behavior)
20:08:05 <sjanssen> you can then use make -j
20:08:08 <shapr> Hm!
20:08:14 <shapr> How do I dump the Makefile?
20:08:17 <Arnia> Only because it would annoy the physicists, chemists and (most importantly) the biologists
20:08:21 <sjanssen> shapr: -M IIRC
20:08:27 * shapr tries that
20:08:35 <shapr> Oh wait, I build with cabal.. can it do that?
20:08:46 <shapr> Hiya SnailRacer, how's code?
20:09:27 <SnailRacer> OK I guess, just lurking
20:09:51 <shapr> sjanssen: Cool, that works.
20:09:55 <ClaudiusMaximus> i'm having big problems with excessive laziness/space leaks - any techniques i should be using to strictify things?  (i'm using arrows for DSP stuff)
20:10:24 <monochrom> recode some arrows to be more strict. add some "seq" and "$!"
20:10:41 <shapr> Any idea where the leak is happening?
20:11:00 <sjanssen> ClaudiusMaximus: strictness annotations in data declarations can help
20:11:00 <hpaste>  timthelion pasted "yi won't run" at http://hpaste.org/2327
20:11:09 <shapr> sjanssen: Btw, this speeds up cabal compiles: ghc-options: +RTS -H256M -RTS
20:11:48 <ClaudiusMaximus> sjanssen: ok.  does that mean i need to have "data StrictDouble = StrictDouble !Double" or so, and all the extra plumbing that entails?
20:11:54 <dons> hehe ` Andre Pang on concurrency and Erlang [VIDEO] '
20:12:01 <dons> ozone is a talking head!
20:12:12 <shapr> Cool!
20:12:15 <sjanssen> ClaudiusMaximus: that 'StrictDouble' declaration won't change anything
20:12:33 <timtheli1n> any hints as to how to make yi run?
20:12:33 <shapr> ClaudiusMaximus: Can hpaste your types?
20:12:49 <sjanssen> ClaudiusMaximus: strict data decls might not be useful in your case
20:12:56 <shapr> timtheli1n: You should try timethel10n, that reads as "tim the localization" :-)
20:13:08 <reltuk> those erlang people hate shared state
20:13:23 <shapr> Selfish independent erlang nodes!
20:13:27 <timtheli1n> shapr: huh?
20:13:55 <shapr> timtheli1n: I just realized that a h4xx0r version of your name, specifically timthel10n, would translate into 'tim the localization'
20:14:15 * shachaf also likes "timthei18n".
20:14:18 <shapr> hah
20:14:22 <shachaf> Though that might be too far from the original.
20:14:30 <shapr> @foldoc l10n
20:14:32 <lambdabot> *** "l10n" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
20:14:32 <lambdabot> l10n
20:14:32 <lambdabot>  
20:14:32 <lambdabot>         {localisation}
20:14:32 <lambdabot>  
20:14:38 <shapr> Too many blank lines!
20:14:43 <dolio> "The disadvantage is that pattern-matching, which is so useful, cannot be used with abstract data types. Solutions to this problem are on the horizon."
20:15:05 <dons> http://programming.reddit.com/info/2gjbz/comments
20:15:06 <kilimanjaro> dolio, 1957 was a good year :)
20:15:06 <lambdabot> Title: A parallel Sudoku solver in Haskell using transactional memory (reddit.com)
20:15:16 <scook0> dolio: also: cold fusion!
20:15:18 <shapr> dons: ooh!
20:16:45 <timtheli1n> shapr: mutations of my name will not help me with yi's buffer errors
20:18:28 <shapr> true
20:20:05 <sorear> dolio: yup, the horizon.  they've been on the horizon for decades (were in the original haskell plan of 87, and since haskell was supposed to have no interesting new features, are probably much older)
20:20:06 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
20:20:08 <desp> is IntMap.assocs the same thing as IntMap.toList?
20:20:10 <sorear> @messages
20:20:11 <lambdabot> allbery_b said 17m 44s ago: hm, false alarm? my lambdabot is periodically losing all its quotes until a restart, with a cleaned quote db. feh
20:20:13 <sorear> yeah
20:20:36 * shapr throws frustration lambdas at his code.
20:20:56 <allbery_b> it actually seems to be happening when I @remember something
20:21:08 <dolio> sorear: Well, Wadler cites views as '[Wadler 85a]', so they're at least that old.
20:21:44 <allbery_b> it actually gets remembered, in that it gets serialized to the state, but @quote raises "getRandItem: empty list" until restarted.
20:22:04 <allbery_b> also, the compose plugin is broken, so I suspect something is screwed up somewhere
20:22:11 <allbery_b> (ghc 6.6.1, x86)
20:22:33 <sorear> same here, but sorear-lambdabot doesn't have such troubles... :(
20:23:09 <desp> @src fmap
20:23:10 <lambdabot> Source not found. Do you think like you type?
20:23:13 <desp> :(
20:23:23 <allbery_b> fmap is a typeclass method
20:23:28 <allbery_b> @src [] fmap
20:23:28 <lambdabot> fmap = map
20:23:36 <scook0> @src Functor
20:23:37 <lambdabot> class  Functor f  where
20:23:37 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
20:23:38 <allbery_b> you have to specify the instance you want
20:23:43 <dons> mm. someone should write a post about time travel monads to destroy the idea of sequencing monads once and for all :)
20:23:45 <desp> oh
20:23:59 <desp> thanks
20:24:08 <shapr> Hirvinen: Check this out (with firefox): http://people.mozilla.com/~vladimir/demos/photos.svgA
20:26:01 <allbery_b> @src (->) fmap
20:26:01 <lambdabot> fmap = (.)
20:26:23 <shapr> I have a bunch of darcs repos with various dependencies, when I pull new changes I'd like to automatically rebuild all packages that depend on this one, is there some automated way to do that?
20:27:00 <glguy> isn't that what alexj's searchpath is about?
20:27:08 <dons> http://programming.reddit.com/info/2gjev/comments
20:27:09 <lambdabot> Title: Borrowing from the future with laziness: time travelling monads (reddit.com)
20:28:04 <shapr> glguy: Not exactly. Searchpath downloads source files into a cache and builds from that.
20:28:58 <shapr> I do wish that cabal-install could just be given a list of urls, and then update and rebuild when there are changes. Or I wish that Searchpath handled versioning as well as cabal does.
20:29:17 <shapr> Adding searchpath niftiness to cabal would be worthwhile.
20:32:01 <desp> does anyone know if there's a difference between assocs and toList in a Map/IntMap?
20:32:28 <desp> assocs appears to guarantee ordering, and toList doesn't -- right?
20:33:11 <glguy> in Data.Map, toList, toAscList, and assocs are the same
20:34:51 <glguy> ?source Data.Map
20:34:52 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
20:34:56 <glguy> where did that file move to?
20:35:48 <sjanssen> s/base/collections
20:35:52 <timtheli1n> pu
20:35:54 <timtheli1n> u
20:36:28 <timtheli1n> the problem with mousekeys ...
20:43:24 <timtheli1n> @where regex-base
20:43:24 <lambdabot> I know nothing about regex-base.
20:45:35 <desp> looks like layout doesn't like let foo = do\n
20:45:45 <desp> inside a do
20:46:16 <shapr> I've realized that my dual core isn't nearly as responsive as my NUMA system.
20:46:19 <desp> neither let foo =\ndo
20:46:28 * shapr wonders why
20:46:40 <desp> it has to be let foo = do bar\n
20:48:57 <timtheli1n> desp: that's because do is a function, whic returns a different result than without it
20:49:20 <hpaste>  ClaudiusMaximus pasted "memory leak with arrow circuits" at http://hpaste.org/2328
20:50:16 <ClaudiusMaximus> i don't know what it is about those particular circuits, but it leaks like crazy, and i've not had a problem with plenty of other circuits...
20:50:32 <glguy> shapr: I don't know much about "exotic" hardware... what is a NUMA system
20:50:41 <allbery_b> non-uniform memory access
20:50:44 <desp> timtheli1n: but in all other cases layout accepts do\n...
20:50:54 <allbery_b> in effect each CPU has memory that is "local" to it
20:51:12 <glguy> desp: you just need to make sure that the stuff in the nested do
20:51:13 <shapr> glguy: Yeah, my Athlon MP dual 1.5GHz with 512mb of ram is more responsive than my dual core 2.4GHz with 4GB of ram.
20:51:18 <glguy> is nested deeper than the stuff in the outer do
20:51:43 <shapr> On the other hand, I have only half the total ram installed, so maybe it's all being controlled by one CPU.
20:51:48 <allbery_b> whereas in a "standard" 2-core system each CPU has to acquire exclusive access to do any memory accesses, in NUMA you only need to do so to access memory that belongs to the other CPU(s)
20:51:52 <timtheli1n> allbery_b: you're using intell right?  the slowdown is due to there being the memory manager on the mobo and not on the cpu, so there is bassically an extended ping time for the memory
20:52:04 <sjanssen> shapr: might it be a software issue?
20:52:22 <hpaste>  desp pasted "don't" at http://hpaste.org/2329
20:52:29 <shapr> sjanssen: I don't know.. nor do I know how to investiage the problem.
20:52:36 <allbery_b> timtheli0n: it's shapr who's noting the issue, I'm just explaining NUMA
20:52:40 <allbery_b> vs. SMP
20:52:49 <timtheli1n> amd put the memory manager on the cpu, but that makes it harder for them to get everything on the one bit of silicon, so their clock is slower
20:53:16 <timtheli1n> or atleast that's what I was taught in computer class
20:53:19 <desp> glguy: huh. it works when the prints are aligned with the bar
20:53:48 <allbery_b> technically the thing with lines after do not needing to be indented past the do is a ghc extension to the layout rule, IIRC
20:53:51 <glguy> desp: you are referring to a specific paste?
20:54:05 <desp> glguy: yes, I just pasted one :)
20:54:33 <allbery_b> so presumabky that extension isnt operative in this case
20:54:44 <shapr> sjanssen: But I can say that when switching applications, screen refresh just takes a lot longer with my new system.
20:54:46 <desp> allbery_b: no, it is. the "let" is interfering.
20:55:12 <allbery_b> right, making the nonstandard layout behavior inoperative
20:55:12 <desp> it was telling the "do" that the block was empty, because I didn't indent the contents past the variable name
20:55:21 <desp> right :)
20:57:26 <timtheli1n> hmm, wtf, yi gives me all these errors ghc-6.6: unknown package: regex-base-0.72 on build, so I when't to hackagedb and there was no .72 only like .71 .80 and .90 so I installed .90 and it still gives me the error, but I don't know how to get 0.72
20:59:06 <glguy> timtheli1n: you need 6.6.1
20:59:13 <glguy> I think, it seems to come with 0.72
20:59:57 <timtheli1n> glguy: oh, debian etch doesn't have 6.6.1, I wonder whether upgrading debian, or compling ghc is easier
21:00:10 <timtheli1n> less disruptive
21:00:21 <glguy> not wanting to be behind on haskell stuff was why I installed lenny
21:00:38 <wli> Hmm, Atkin's algorithm 4.1 is not producing very many of the lattice points I'd consider valid.
21:00:43 <timtheli1n> lenny is a version of debian?
21:00:49 <glguy> testing
21:01:01 <timtheli1n> oh, is it stable?
21:01:28 <timtheli1n> how many times have you aptitude update..upgaded and had x stop working?
21:01:28 <glguy> etch is "stable", lenny is "testing", sid is always "unstable"
21:01:32 <glguy> none
21:01:46 <glguy> I use very little of debian, though
21:01:52 <glguy> virtually no X11 apps
21:01:56 <timtheli1n> how long have you been using it? that happened 5 times in the 2 years I used ubuntu
21:02:16 <glguy> I use debian for vim, irssi, and ghc
21:02:44 * timtheli1n uses lastfm, urxvtc , vim(hoping to move to yi), irssi, zsh, w3m, xmonad, and gv
21:02:59 <glguy> I suppose I use openssh a lot too :)
21:03:20 <glguy> lastfm?
21:03:23 <timtheli1n> I actually use quite a few cli programs that I didn't mention.
21:03:42 <timtheli1n> lastfm is a free customised online streaming music service
21:03:51 <ClaudiusMaximus> anyone have a clue about my arrowcircuit space leak issue?  how does one go about analysing exactly where a leak is?  http://hpaste.org/2328
21:03:58 <timtheli1n> so you make this custom stream and just kinda listen
21:04:29 <ClaudiusMaximus> i decided to quit lastfm because they kept asking me to pay to get my music played on their streams...
21:04:57 <scook0> ClaudiusMaximus: have you tried the heap profiler?
21:05:07 <timtheli1n> ClaudiusMaximus: really?
21:05:28 <ClaudiusMaximus> scook0: no, i don't know how :-/
21:06:41 <ClaudiusMaximus> timtheli1n: well, in more diplomatic language, but basically labels/artists can pay for extra plays on streams
21:06:54 <scook0> ClaudiusMaximus: first, compile your code with profiling (e.g. -prof -auto-all)
21:07:28 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/profiling.html
21:07:30 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/2z559y
21:07:40 <glguy> ClaudiusMaximus: isn't the point that they pay the artists, rather than the artists paying them?
21:07:49 <scook0> then run with one of the heap profiling options, like +RTS -hc
21:07:51 <desp> timtheli1n: are you in the Haskell group on last.fm? :)
21:08:13 <reltuk> what's +RTS stand for?
21:08:26 <desp> reltuk: here come options for the runtime system
21:08:26 <glguy> run time system
21:08:40 <scook0> then use the hp2ps to get a nice postscript visual breakdown of your allocations
21:09:08 <reltuk> desp: so on the command line you can also use -RTS to stop giving options for the runtime system?
21:09:12 <desp> yep
21:09:19 <reltuk> pretty cool
21:09:21 <scook0> (I had to do this a while back to find a space leak ... turned out it was an overly lazy writer monad in my case)
21:09:26 <timtheli1n> desp: I didn't know there was one
21:09:34 <desp> timtheli1n: http://www.last.fm/group/haskell/members
21:09:35 <lambdabot> Title: haskells Members &ndash; Groups at Last.fm
21:09:44 <dons> Did people see the $2k bounty to fix the exponential merge problem in darcs?
21:09:47 <ClaudiusMaximus> scook0: well, it seems i need to reinstall arrows-0.2:         Perhaps you haven't installed the profiling libraries for package arrows-0.2.1?
21:10:18 <reltuk> dons: hah!  wow...did someone with deep pockets end up hitting it a bit too often in an important repository or something?
21:10:18 <dons> Igloo: who would be able to fix it, given say , 4 weeks for $2k?
21:10:24 <dons> reltuk: yeah.
21:10:28 <scook0> ClaudiusMaximus: yeah, when using profiling, all your modules need to be compiled with profiling (I believe)
21:10:49 <shapr> dons: Whoa, that's cool.
21:10:55 <scook0> when I did it, I was only using built-in libraries, so I didn't have to worry too much about that
21:11:14 <shapr> dons: Where's that?
21:11:24 * glguy would like to see the "annotate doesn't work on large repos" problem fixed too :)
21:11:44 <dons> shapr: darcs list.
21:11:55 <timtheli1n> it's a race!
21:11:59 <dons> glguy: you want someone at galois  to take the contract to fix darcs? :)
21:12:44 <reltuk> "something on the order of a couple thousand dollars at a minimum"
21:12:46 <dons> Igloo: maybe you could do it? Take the 2k, and fix the darcs bug. Who else would be capable enough?
21:13:14 <shapr> Are patches already sorted?
21:13:24 <reltuk> http://lists.osuosl.org/pipermail/darcs-users/2007-August/011210.html
21:13:26 <dons> i want someone to offer money to fix bugs in xmonad
21:13:26 <lambdabot> Title: [darcs-users] Bounty on the conflict misery bug, http://tinyurl.com/25zmy6
21:13:38 <dons> if only there were some show stopping bugs! :}
21:13:40 <glguy> is there a solution to the problem that needs to be implemented?
21:13:44 * dons makes note to leave critical bugs in code
21:13:50 <glguy> or is figuring out how to fix it part of the bounty
21:14:03 <shapr> glguy: I don't know.
21:14:20 <shapr> Long ago I thought that merges could be faster if patches were sorted.
21:14:29 <shapr> But I no longer remember the details.
21:15:00 <shapr> Something about pre-filtering patches according to those that could not possibly conflict.
21:15:17 <reltuk> shapr: sorted on what?
21:15:25 <shapr> To begin with, patch type
21:15:57 <ClaudiusMaximus> @where hp2ps
21:15:57 <lambdabot> I know nothing about hp2ps.
21:16:09 <dons> ClaudiusMaximus: should come with ghc by default
21:17:13 <ClaudiusMaximus> dons: ah yes, i must have mistyped it
21:17:13 <scook0> http://www.haskell.org/ghc/docs/latest/html/users_guide/hp2ps.html
21:17:15 <lambdabot> Title: 5.6. hp2ps&#8211;&#8211;heap profile to PostScript, http://tinyurl.com/36ay6x
21:17:22 <shapr> reltuk: It'd be pretty easy to figure out which other patches will always commute with the patch under consideration. If you cache that info, things should be much faster.
21:17:59 <shapr> I haven't looked at darcs patch theory recently, so that could be total gezeik :-)
21:18:21 <timtheli1n> I hate mistery bugs, I won't be taking that one on
21:19:22 <reltuk> timtheli1n: the real problem might be that it's a "bug" in the patch theory, and not just in the implementation...
21:19:50 <timtheli1n> reltuk: a design flaw
21:22:36 <ClaudiusMaximus> hmm, the heap profiler graph doesn't really tell me anything i didn't know before :-/
21:22:45 <gmh33> seeing pictures of people from the cloud is always kinda funny
21:23:13 <gmh33> oops..
21:25:16 <ClaudiusMaximus> the heap profiler graph i got has 3 bands, two roughly constant and one zooming upwards linearly with time.
21:25:45 <glguy> darcs has other fundamental flaws too... since repositories can have any combination of known patches, it can be difficult to discuss any specific version of a repository with someone else without pushing and pulling between your repositories to be sure that htey agree
21:26:10 <glguy> I suppose you could use tags to get around that limitation in specific instances
21:27:56 <reltuk> glguy: usually we're talking about "HEAD" on a specific repository though, right?
21:28:37 <glguy> reltuk: right, it is important that we can both access a common repository at the same to time determine if we are talking about the same repository
21:28:57 <glguy> having a central repository isn't part of the darcs model
21:29:06 <glguy> its just a convenience to designate one
21:29:10 <glguy> so that people can download from it
21:29:35 <reltuk> glguy: yes...and releases can be cut...these sorts of things
21:30:27 <glguy> releases being cut doesn't require a central repo
21:30:35 <glguy> tag your local one and make a release
21:31:36 <glguy> I still use darcs in spite of these weaknesses, but I still know they exist
21:32:38 <reltuk> I use darcs for personal projects...but most of that is just for the UI and the likes; I'm very rarely reordering patches or even sharing them all that much
21:33:32 <reltuk> In a professional setting, I would imagine the accounting and release management benefits of a central, authoratative repository would be tempting
21:34:19 <Adamant_> that is the guaranteed market for SVN
21:34:27 <glguy> I think that darcs makes it easy for people to contribute to open source projects
21:34:42 <wli> Well, most of what you need for that is naming things.
21:34:50 <wli> Or naming branches etc.
21:34:53 <timtheli1n> glguy: yes, it is easier for me than contributing to a cvs
21:38:39 <Sgeo> Bye all!
21:39:22 <timtheli1n> will mv * home be recursive since home is part of *?
21:39:28 <wli> No.
21:41:30 <aFlag> one thing that I like about git that I don't see in darcs is that branch capability
21:42:13 <Lemmih> Isn't every darcs repo a branch?
21:43:17 <reltuk> I'm pretty impressed with git in general; the merging implementations, in particular, are quite good; and the very easy "branching to try something out" is nice as well
21:43:21 <glguy> Lemmih: yeah, an unnamed one
21:43:25 <aFlag> yeah, but you have to copy everything in another directory
21:43:28 <wli> Lemmih: Naming is the issue.
21:43:41 <glguy> aFlag: darcs does that for you, and uses hard links to reduce the waste
21:43:48 <ClaudiusMaximus> i think the problem is in 'change' in this paste according to the heap profiler, any clues how to stop it blowing up?  http://hpaste.org/2328
21:43:48 <phr-zzz> i've been using mercurial and multiple repos gets confusing as hell ;)
21:43:50 <timtheli1n> um, if I want to make a darcs repo of etc on an external hd, should I call initialize in /etc or in /mnt/hdb1/etc ?
21:44:06 <aFlag> glguy, really? which command?
21:44:11 <glguy> aFlag: get
21:44:18 <glguy> timtheli1n: you'll have two repos
21:44:22 <glguy> timtheli1n: so init in /etc
21:44:28 <glguy> and then "put" it on your second drive
21:44:35 <aFlag> oh, yeah, but get still takes a while on large project
21:44:43 <wli> One of the big messes is regressions.
21:45:02 <aFlag> specially if you have a lot of patches
21:45:24 <glguy> aFlag: not on the same hard drive
21:45:27 <glguy> aFlag: then its pretty fast
21:45:28 <wli> The attempts to delinearize defeat most/all attempts to implement regression searches.
21:45:29 <reltuk> aFlag: it's actually pretty quick for a full-repo get on a local box
21:45:47 <glguy> aFlag: or rather if it is on the same partition
21:46:26 <wli> git is actually somewhat unique in that it's successfully partially delinearized while also maintaining support for some manner of bisection search.
21:46:49 <timtheli1n> glguy: won't that make etc twice as large, storing the patches on the local machein?
21:47:25 <glguy> timtheli1n: darcs using gzip, but that's how darcs works
21:47:30 <reltuk> wli: I was under the impression that git was largely linearized...
21:47:33 <glguy> maybe you could do some symlink magic or something
21:47:51 * reltuk thinks timtheli1n must have a ton of config files...
21:47:55 <glguy> I really like how git makes it easy to create and switch between branches in one directory
21:48:00 <wli> reltuk: It's "partially delinearized." It's bothersome in some respects.
21:48:16 <timtheli1n> reltuk: no, I'm just very concerned with size, my hd is only 30 gigs
21:48:28 <ClaudiusMaximus> WOW, i think i fixed it, and it's bizarre - i just removed an unnecessary 'rec' keyword :-/
21:48:33 <reltuk> timtheli1n: my /etc is only 2 MB   ;)
21:48:46 <shapr> I just ordered a 500GB drive for this box...
21:48:55 <timtheli1n> shapr: laptop :)
21:48:58 <shapr> oh
21:49:14 * reltuk was suprised that the new imacs can come with up to 1 TB harddrives
21:49:41 <shapr> It's $105 for a 500gb SATA-3 drive at newegg.com
21:49:48 <wli> shapr: I'm skeptical of much of anything above 73GB. Mostly it seems they get mutual interference issues from too much data sitting on the same spindles.
21:50:05 <timtheli1n> my sister's the one who's really bad off. she got a $3000 tablet, and my dad refused to pay the extra $200 for the 120gig hd, she's trying to do cad work on windows xp with 60gigs!
21:50:17 <shapr> wli: Fortunately I already have a 250gb sata3 drive.
21:50:19 <wli> shapr: My strategy is multiple disks.
21:50:32 <reltuk> heh, cad work on a tablet might not be too pretty in general
21:50:45 <wli> shapr: So 15 73GB disks instead of 1 1TB disk.
21:50:46 <timtheli1n> reltuk: it's really fast.
21:50:52 <shapr> wli: That would be cool.
21:51:22 <shapr> I'll finally be able to fit *all* my music onto one drive now!
21:51:25 <wli> shapr: Well, I have 7 or 8 online right now. Mostly I've got PSU issues with getting the rest online.
21:51:48 <wli> Well, the PSU is here, I'm just too lazy to hook it up.
21:52:06 <shapr> Speaking of which, I was thinking about media purpose built for music/pix/etc, that is, write speed would be nearly unimportant, but read/seek speed would be very important.
21:52:09 <reltuk> 15 drives seems like MTTF nightmare
21:52:15 <reltuk> unless you're RAIDing them or something
21:52:39 <reltuk> also the possible noise/heat issue
21:52:45 <wli> reltuk: Far better than single-point-of-failure single disk setups.
21:53:08 <reltuk> wli: not really...unless you're replicating the data
21:53:24 <reltuk> wli: in the case when you're not replicating the data, you're just failing a disk 15 times as often
21:53:25 <wli> reltuk: There's always RAID, of course.
21:53:38 <timtheli1n> hmm, when I try to push to my external hd, it says no patches, without copying anything, the only on the hd is the empty shell _darcs
21:54:03 <glguy> timtheli1n: when you "put" or when you "push" ?
21:54:12 <reltuk> wli: admittedly, you fail less as a percentage of your total data, but true data loss upon disk failure is actually pretty rare, and 100% data loss across the whole drive would be even more rare
21:54:16 <timtheli1n> glguy: I've done both
21:54:27 <timtheli1n> one after the other, in the order you typed them now
21:54:43 <glguy> timtheli1n: you don't need to push after a put
21:54:51 <glguy> timtheli1n: but you do need to "add"
21:54:53 <glguy> all the files in /etc
21:54:57 <glguy> and then "record" that
21:54:58 <timtheli1n> well put only placed the empty _darcs
21:55:16 <timtheli1n> no changes
21:55:41 <glguy> have you added any patches to your repository yet?
21:55:48 <timtheli1n> no?
21:55:51 <glguy> so...
21:55:56 <glguy> you need to add files to a repository
21:56:13 <timtheli1n> I'm just trying to initialize a repository versioning backup of etc
21:56:14 <glguy> init doesn't add files
21:56:27 <glguy> you actually have to tell darcs which files to store
21:56:37 <timtheli1n> glguy: so darcs add *?
21:56:39 <ClaudiusMaximus> arrows question: anyone know why   rec foo <- bar -< quux   gobbles memory, if quux never uses foo?  (i fixed my memory leak by removing an unnecessary 'rec')
21:56:50 <wli> reltuk: It's not failing 15 times as often, silly. 1-(1-p)^15 < 15p
21:57:09 <glguy> timtheli1n: something like that
21:57:44 <dons> ?users
21:57:45 <lambdabot> Maximum users seen in #haskell: 389, currently: 347 (89.2%), active: 15 (4.3%)
21:58:07 <shapr> What does "cabal-setup: Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly" mean?
21:58:27 <reltuk> 15p is the probability that all drives fail at once
21:58:46 <glguy> hmmm... you sure?
21:58:52 <newsham> hmm... there was a site that had a fingerd (I think) written in literate haskell as a pdf file
21:58:58 <glguy> p^15 is
21:59:00 <newsham> I cant find it... anyone know what i'm talking about?
21:59:02 <shapr> cr.yp.to
21:59:14 <shapr> Oh wait, you want khjk.org
21:59:19 <reltuk> glguy: this is true
21:59:27 <newsham> yes, was khjk I think
21:59:33 <shapr> newsham: I may have a copy hanging around.
21:59:44 <newsham> is the site no longer serving it?
21:59:53 <newsham> shapr: do you have the src too?
21:59:58 <shapr> Doesn't seem so, and yes.
22:00:10 <newsham> yes please.  email or dcc?
22:00:16 <wli> The probability of a disk failing is p. The probability of none of the disks having failed is (1-p)^15. The probability of one of the disks failing is 1-(1-p)^15.
22:00:16 <newsham> or url
22:00:24 <shapr> I'll upload it.
22:00:27 <timtheli1n> it seems I need a recursive *
22:00:42 <timtheli1n> that I can tell to ignore file
22:00:43 <timtheli1n> s
22:00:56 <shapr> newsham: http://www.scannedinavian.com/~shae/khjk-*
22:01:36 * shapr is a member of the Karl Hans Johan Kollektiv
22:02:51 <newsham> thanks!
22:03:06 <shapr> newsham: btw, have you seen the sendmail clone written in Haskell?
22:03:16 <reltuk> in my calculations those numbers are equal...
22:03:18 <sioraiocht> shapr: how well does it work?
22:03:23 <reltuk> that's really cool actually
22:03:41 <shapr> sioraiocht: It works fine last I checked.
22:03:56 <sioraiocht> shapr: and it scales?
22:04:01 <shapr> It's called postmaster, and it has a rather different view of life...
22:04:09 <newsham> i have not.
22:04:12 <newsham> any good?
22:04:13 <shapr> sioraiocht: It's very likely the fastest smtpd that exists.
22:04:16 <reltuk> if MTTF = 600000 hours, then the probability you fail any given day is 4e-5
22:04:20 <sioraiocht> shapr: neat
22:04:37 <newsham> perhaps qmail would be a better target.  dan probably generated it from some functional language anyway ;-)
22:04:41 <shapr> Peter Simons wrote a whole block i/o layer using arrows to keep postmaster speedy.
22:04:41 <reltuk> of course, that's not true...
22:04:57 <newsham> blah permission denied on khjk-fingerd.lhs
22:04:57 <reltuk> but assuming you have some probability for a disk failing on a given day...
22:05:04 <shapr> newsham: oops, fixing...
22:05:08 <newsham> and the other too
22:05:22 <shapr> newsham: try again
22:05:23 <reltuk> but 15 * 4e-5 == 1 - (1 - 4e-5)^15
22:05:33 <newsham> better.  thanks
22:06:02 <shapr> sioraiocht: I never got around to using postmaster on ScannedInAvian.com because I depend on incoming email to get paid and stuff :-)
22:06:12 <newsham> its been a while since I did literate haskell.tex.  do you just latex the src to regen .dvi/.pdf?
22:06:14 <wli> > (15 * 4e-5) - (1 - (1 - 4e-5)^15)
22:06:15 <shapr> But now that I have a different job...
22:06:16 <lambdabot>  1.6797088293559105e-7
22:06:24 <shapr> newsham: I'd guess lhs2tex, but I'm not sure.
22:06:24 <wli> reltk: Come again?
22:06:44 <sioraiocht> shapr: neat =)
22:07:41 <timtheli1n> lol, skipping boring file, the verbosity of open source
22:08:03 <shapr> How do I fix "cabal-setup: Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly" ?
22:08:19 <shapr> I tried random frobbing... unsurprisingly, that didn't fix it.
22:12:26 <sjanssen> shapr: is exposed-modules empty in the .cabal file?
22:12:37 <shapr> It doesn't exist, I'm trying to build a binary.
22:12:49 <shapr> I'm trying to steal xmonad.cabal, but it's not working.
22:13:02 <timtheli1n> is there a way to turn echo off in unix?
22:13:19 <timtheli1n> shell script that is
22:15:26 <sjanssen> shapr: did you somehow lose the 'executable' field?
22:15:37 <phr-zzz> > (15 * 4e-5 + 105*16e-10) - (1 - (1 - 4e-5)^15)
22:15:44 <shapr> No, but adding exposed-modules: seems to have fixed it.
22:15:45 <lambdabot>  3.3597088293559107e-7
22:15:51 <reltuk> wli: remind me not to work with any numbers anytime soon ;)
22:16:19 <phr-zzz> > (15 * 4e-5 - 105*16e-10) - (1 - (1 - 4e-5)^15)
22:16:21 <lambdabot>  -2.911706440897496e-11
22:16:24 <sjanssen> shapr: hmm.  Is your 'executable' line in a separate stanza? (ie. there's a newline before it)
22:17:31 <newsham> Setup.hs: Error: Could not find location for program: pdflatex
22:17:32 <shapr> Yeah, I did that.
22:17:44 <reltuk> wli: how much difference in terms of minutes of operational time does that translate to?
22:17:45 <newsham> *sigh* this program doesnt seem to want to play nicely with cygwin/win32
22:18:24 <reltuk> I'm thinking, on the order of less than half an hour
22:18:33 <reltuk> s/on the order of//
22:18:41 <glguy> with one drive, you lose you data when it fails
22:18:51 <glguy> with 15 you don't, but might pay a little more in drive costs...
22:18:59 <shapr> newsham: The pdf with the same name should be the generated docs for the fingerd
22:19:05 <shapr> newsham: So you've already got that.
22:19:12 * shapr swears at this code
22:19:47 <timtheli1n> grr, is darcs record supposed to take *forever*?
22:19:52 <shapr> Don't think so.
22:20:08 <glguy> timtheli1n: yes, it is actually supposed to take forever
22:20:14 <glguy> thats the beauty of it
22:21:10 <timtheli1n> I'm recording /var/lib/dpkg which is 47 megs, and it's taken more than 4 minutes
22:21:19 <reltuk> glguy: in the case of replicated raid, I guess you don't lose data in the case of failure...I saw "15 73GB disks" adding up to 1TB and assumed there was no replicated
22:21:42 <glguy> 21:52 < wli> reltuk: There's always RAID, of course.
22:21:56 <newsham> shapr: yah, but i want to write some literate code of my own
22:22:13 <timtheli1n> no output
22:22:22 <timtheli1n> cpu gets hot though
22:22:35 <newsham> tim: sounds nearly functional
22:22:48 <glguy> timtheli1n: stuff in /var typically doesn't merit a darcs repo
22:23:06 <timtheli1n> glguy: ok.
22:23:20 <timtheli1n> so I should just use like unison for that?
22:24:15 <shapr> newsham: oh
22:24:15 <glguy> probably... darcs is for distributed revision control
22:24:20 <glguy> not raw backups
22:24:40 <timtheli1n> glguy: but I have yet to find a program that works for raw backups :(
22:24:48 <shapr> I do use darcs to backup config files in my home dir though.
22:24:53 <shapr> like ~/.zshrc
22:25:05 <shapr> But then, I want those config files everywhere.
22:25:12 <MarcWeber> Where can I find more information about how hugs manages libraries?
22:25:17 * reltuk wonders how many people use zsh over bash
22:25:24 * glguy knows of one
22:25:34 <shapr> me!
22:25:35 * timtheli1n uses zsh
22:25:38 <MarcWeber> The recent documentation just says: use cabal? Have I missed a page?
22:25:45 * wli uses zsh.
22:26:14 * glguy knows of two
22:26:15 <glguy> :)
22:26:24 <reltuk> bash seems really ubiquitos with the typical linux crowd, but the people I normally interact with use zsh, so it's hard for me to get a feel for it
22:26:29 * dolio uses zsh.
22:26:30 * timtheli1n uses zsh because the guy who got me using open source in the first place told me to
22:26:49 * glguy uses bash because it is the default and doesn't know anything about zsh :)
22:26:58 <wli> bash's command-line editing is very primitive compared to zsh's.
22:27:20 <glguy> wli: neat example?
22:27:21 <shapr> @poll-show WhatShell
22:27:21 <lambdabot> ["bash","zsh"]
22:27:26 <reltuk> and last time I used bash you had to install programable completions as an extra
22:27:30 <shapr> @vote WhatShell zsh
22:27:30 <lambdabot> voted on "zsh"
22:27:32 <dolio> I get lost when '/e/x/x<TAB>' doesn't turn into '/etc/X11/xorg.conf'
22:27:37 <reltuk> @vote WhatShell zsh
22:27:37 <shapr> @poll-result WhatShell
22:27:38 <lambdabot> voted on "zsh"
22:27:38 <lambdabot> Poll results for WhatShell (Open): bash=0, zsh=2
22:27:54 <wli> @vote WhatShell zsh
22:27:54 <lambdabot> voted on "zsh"
22:27:57 <dolio> @vote WhatShell zsh
22:27:57 <lambdabot> voted on "zsh"
22:27:58 <shapr> @choice-add WhatShell csh
22:27:59 <lambdabot> New candidate "csh", added to poll "WhatShell".
22:28:04 <shapr> Cute, eh?
22:28:23 <reltuk> heh, nice that it reads and understands your .zshrc as well ;)
22:28:25 <MarcWeber> dolio: I've implemented this as extra application.. I should have known zsh ? Using my tool you can even omit the / :-)
22:28:27 <shapr> @choice-add WhatShell /bin/false
22:28:27 <lambdabot> New candidate "/bin/false", added to poll "WhatShell".
22:28:29 <wli> Now add CSSD and CPO-STV.
22:28:34 <ChilliX> @vote WhatShell bash
22:28:34 <lambdabot> voted on "bash"
22:28:57 <sjanssen> @vote WhatShell zsh
22:28:57 <lambdabot> voted on "zsh"
22:28:59 <Eelis> @vote WhatShell zsh
22:28:59 <lambdabot> voted on "zsh"
22:29:26 <shapr> @poll-show WhatShell
22:29:26 <lambdabot> ["/bin/false","csh","bash","zsh"]
22:29:32 <shapr> @poll-result WhatShell
22:29:32 <lambdabot> Poll results for WhatShell (Open): /bin/false=0, csh=0, bash=1, zsh=6
22:29:38 <shapr> zsh seems popular.
22:29:53 <MarcWeber> @vote bash
22:29:54 <lambdabot> usage: @vote <poll> <choice>
22:30:01 <Eelis> the silent bash majority feels it doesn't need to assert itself
22:30:07 <MarcWeber> @vote WhatShell bash
22:30:07 <lambdabot> voted on "bash"
22:30:08 <MarcWeber> @vote WhatShell bash
22:30:08 <lambdabot> voted on "bash"
22:30:10 <ChilliX> zsh is overrated    <-- flame bait ;)
22:30:14 <shapr> hah
22:30:14 <stepcut> @choice-add WhatShell M-x eshell
22:30:15 <newsham> zsh is from the unholy csh lineage
22:30:15 <lambdabot> usage: @choice-add <poll> <choice>
22:30:24 <MarcWeber> @poll-result WhatShell
22:30:24 <lambdabot> Poll results for WhatShell (Open): /bin/false=0, csh=0, bash=3, zsh=6
22:30:25 <shapr> stepcut: Must be one word
22:30:31 <shapr> stepcut: Try eshell?
22:30:36 <stepcut> @choice-add WhatShell eshell
22:30:36 <lambdabot> New candidate "eshell", added to poll "WhatShell".
22:30:36 <newsham> nobody here using functional shells?
22:30:40 <MarcWeber> Ha! lambdabot should save the nicks along the counters.. :-)
22:30:46 <shapr> MarcWeber: Yeah, it should.
22:30:47 <stepcut> @vote WhatShell eshell
22:30:47 <lambdabot> voted on "eshell"
22:30:49 <newsham> esh schemesh
22:30:52 <dons> @vote WhatShell zsh
22:30:52 <lambdabot> voted on "zsh"
22:30:53 <reltuk> scsh?
22:30:54 <shapr> MarcWeber: Feel free to fix it :-)
22:31:04 <dons> @choice-add WhatShell ghci
22:31:05 <lambdabot> New candidate "ghci", added to poll "WhatShell".
22:31:08 <shapr> haha
22:31:10 <reltuk> hah!
22:31:36 <newsham> hey dons.  did your friend give the gadt proof talk?
22:31:47 <dons> newsham: yeah, let me see if there are slides..
22:32:00 * glguy takes zsh out for a spin
22:32:19 <reltuk> glguy: depending on your bash-foo, it could take some getting used ot
22:32:44 <dons> `Roman: Encoding proofs with GADTs and type families' no slides up yet
22:33:36 <newsham> thank you
22:33:59 <dons> newsham: i'll see if i can get hold of slides this week.
22:34:05 <dons> probably it will end up in a paper or something
22:34:34 <newsham> thanks.  no rush.  will take me longer than that to grok it anyway
22:35:07 <shapr> glguy: http://www.scannedinavian.com/~shae/zshrc is my ~/.zshrc
22:35:57 <shapr> glguy: But you probably want to remove "setopt dvorak                  # with spelling correction, assume dvorak kb" if you want to try it out.
22:36:35 * reltuk is entirely jealous of people who managed to convert to dvoak
22:36:47 <shapr> I converted in 1992.
22:37:00 * glguy found http://www.aperiodic.net/phil/prompt/prompt.txt
22:37:12 <reltuk> shapr: heh, that probably didn't make it any easier ;)
22:37:18 <glguy> *crazy* and *gratuitous* are the first two words that come to mind
22:37:34 <stepcut> aoeu
22:37:54 <wli> I use typeset -x PS1='$ '
22:38:02 <dolio> You don't need to see your battery status on every line?
22:38:08 <glguy> :)
22:38:23 <shapr> glguy: I'd show you my previous prompt, but I don't think it'll fit in one line of irc.
22:38:34 <reltuk> I use one of the presets from the themed prompts in zsh
22:38:43 <shapr> Nowadays I do too.
22:39:06 <wli> dolio: I hammer in things like nested loops with if/then/else in the middle and so on all the time, so I prefer to leave room to type.
22:39:33 <shapr> glguy: zsh does cool stuff like: ls -oSr **/*(#q.Lk+900)
22:40:17 <glguy> shapr: now explain what that "extendedglob" does
22:40:23 <dolio> wli: Mine isn't very complex, either. It's 'user@host %' on the left, and 'time pwd' on the right.
22:40:44 <shapr> glguy: http://zsh.dotsrc.org/Intro/intro_2.html
22:40:46 <lambdabot> Title: An Introduction to the Z Shell - Filename Generation
22:41:06 <shapr> I've used extendedglob for so long I no longer know how it's different.
22:41:41 <shapr> One example is that I use "hasktags **/*.hs~_darcs*" when making tags files.
22:42:24 <shapr> Er, I remove the dot so I get .lhs files too, but the ~_darcs* means it doesn't pick up *hs files in _darcs subdirs.
22:42:34 <wli> The implicit find in the ** is the point there.
22:43:11 <glguy> ** means "all directories"?
22:43:16 <shapr> All subdirs.
22:43:19 <glguy> oh
22:44:02 <shapr> It's especially cool that I can tabcomplete remote files over ssh with zsh.
22:44:14 <shapr> That requires ssh-agent of course.
22:44:19 <nornagon> PS1=$(print "%{\e[1;34m%}[%{\e[0m\e[34;1m%}%m%{\e[0m\e[31;1m%}:%{\e[0m%}%~%{\e[1;34m%}]%{\e[0m%} ") # aren't terminals lovely? :)
22:46:06 <shapr> @poll-result WhatShell
22:46:07 <lambdabot> Poll results for WhatShell (Open): ghci=0, eshell=1, /bin/false=0, csh=0, bash=3, zsh=7
22:46:37 <wli> Not many people use csh anymore; the closest are tcsh users.
22:46:54 <nornagon> @vote WhatShell zsh
22:46:55 <lambdabot> voted on "zsh"
22:47:03 <shapr> glguy: I originally started using zsh because bash didn't have a preexec hook, so I couldn't change the xterm titlebar to show when a process was running, and when it was finished.
22:47:15 <jeffz> @vote WhatShell eshell
22:47:16 <lambdabot> voted on "eshell"
22:47:45 <wli> I put hostnames in titlebars and don't want them screwed with.
22:49:27 <Cale> nornagon: You can use tput
22:50:45 <shapr> glguy: The try function in there is fun, Cale helped me with that code. Assuming you play something relaxing in fin, and something discodant in die, "try command" is quite useful.
22:50:52 <shapr> discordant*
22:51:22 <glguy> shapr: I'll have to give that a shot...
22:51:23 <dolio> shapr: You have a function specifically for playing 'monkey.wav' 3 times?
22:51:27 <glguy> shapr: you have a lot of stuff in here :-p
22:51:43 <shapr> dolio: Yeah sure, that's the "it worked!" sound.
22:51:56 <shapr> And the wav files come with xemacs, not sure if they're in gnu emacs.
22:51:57 <dolio> Ah, of course. :)
22:53:08 <shapr> try is nice because I want to be able to focus on something else while a a long running process like a ghc compile is happening, but I want to know immediately if the build dies.
22:54:08 <Cale> nornagon: In fact, it's probably much safer portability-wise, as well as more readable, to use tput to get all the control codes you need into environment variables.
22:54:49 * glguy goes off to add a sound card
22:54:50 <shapr> I have not yet figured out how to get zsh completion to work after try on the command line, but I would like to know how :-)
22:54:50 <nornagon> Cale: fwiw, this prompt is used on one (1) computer, and that is my laptop.
22:55:05 <Cale> nornagon: ah
22:55:13 <nornagon> and through putty, i guess. But it works okay there.
22:55:42 <nornagon> it even works on Terminal.app, come to think of it (but I never use that unless I have no other choice)
22:56:28 <Cale> Yeah, I suppose support for ansi escape codes is common enough :)
22:56:58 <Cale> Still, it's usually nice to give names to them and use ${bold} ${unbold}, etc.
22:57:10 <nornagon> I did try some sort of $red/$blue/etc. thing, but it turns out the variables become global instead of local to the .rc
22:57:32 <Cale> hmm, that's interesting :)
22:57:37 <Cale> which shell?
22:58:06 <nornagon> zsh
22:58:13 <nornagon> 1546.06 < nornagon> @vote WhatShell zsh
22:58:15 <nornagon> ^- :)
22:58:17 <Cale> oh, hehe
22:58:29 <dolio> zsh has preset color variables, doesn't it?
22:58:32 <glguy> shapr: can you add your wav files to your public_html dir?
22:58:39 <nornagon> dolio: Oh, it does?
22:58:46 <glguy> I want to here what you hear when things work
22:58:57 <glguy> hear*
22:58:57 <dolio> PS1="%{$fg_bold[green]%}%n%{$fg_bold[blue]%}@%{$fg_bold[yellow]%}%m %{$fg_bold[red]%}%# ...
22:59:00 <nornagon> dolio: what about bold/background stuff? (not that I have background colours in my prompt)
22:59:06 <nornagon> hmm
22:59:34 <nornagon> don't seem to exist here....
22:59:44 <dolio> Huh, weird.
22:59:56 <Cale> Man, zsh is even more insanely featureful now :)
23:00:08 <Cale> There's an FTP client built into it?
23:00:12 <glguy> huh?
23:00:15 <nornagon> hehe
23:00:21 <tech> jeffz: come back!
23:00:21 <tech> jeffz: come back!
23:00:21 <tech> jeffz: come back!
23:00:21 <tech> jeffz: come back!
23:00:23 <tech> jeffz: come back!
23:00:25 <glguy> what... it does completion on ftp:// stuff
23:00:25 <tech> jeffz: come back!
23:00:28 <glguy> ugh
23:00:31 <glguy> quit it dude
23:00:34 <Cale> tech: don't.
23:00:37 <tech> sorry
23:00:53 <tech> jeffz just needs to come back
23:00:55 <nornagon> zsh is unfortunately unUNIXy in that regard
23:00:57 <tech> we miss him
23:01:02 <Cale> tech: huh?
23:01:03 <nornagon> (also, /ignore is great)
23:01:15 <tech> Cale: yes
23:01:18 <Cale> tech: do you have a question about haskell?
23:01:28 <shapr> glguy: sure
23:01:31 <tech> Cale: yes, can haskell make jeffz come back?
23:01:38 --- mode: ChanServ set +o Cale
23:01:59 <Cale> Probably not, is my guess.
23:02:01 <tech> i didn't do anything wrong, that was a legitimate question
23:02:05 <shapr> glguy: done
23:02:11 <Cale> tech: Haskell is a programming language
23:02:26 <Cale> tech: (are you aware of which channel this is? :)
23:02:52 <tech> Cale: I've heard haskell can do a lot of magic
23:03:08 <nornagon> haskell in the fjords!
23:03:10 <shapr> mmm magic
23:03:24 <glguy> ?quote sanen
23:03:25 <lambdabot> #perl says: <tech> who needs saneness
23:03:28 --- mode: ChanServ set +o dons
23:03:30 <Cale> tech: I've heard you're asking for a kickban. What do you think about that?
23:03:38 --- mode: ChanServ set +o glguy
23:03:43 --- mode: glguy set +b %tech!*@*
23:03:45 <shapr> yow, lotsa +o !
23:03:45 <nornagon> heh
23:03:47 <glguy> fixed the glitch
23:03:55 <dons> thanks glguy
23:03:56 --- mode: ChanServ set -o dons
23:04:00 --- mode: Cale set -o Cale
23:04:02 <nornagon> :)
23:04:12 <dons> shapr: gotta  muscle up occasionally :)
23:04:16 <shapr> heh, yup
23:04:17 --- mode: glguy set +b *!*@193.216.160.2]
23:04:20 <Cale> I guess we'll just settle for a mute :)
23:04:35 <glguy> its a glguy cocktail
23:04:39 <glguy> you get muted
23:04:42 <glguy> and you can't come back in
23:04:49 <Cale> glguy: ]
23:05:15 <glguy> but you can hear us talk about you
23:05:27 --- mode: ChanServ set +o Cale
23:05:30 <dons> glguy: evil.
23:05:33 --- mode: Cale set -b *!*@193.216.160.2]
23:05:41 <glguy> :(
23:05:44 <nornagon> hmph, how can I nicely generate ELF executables from haskell? how does ghc do it?
23:05:47 --- mode: Cale set +b *!*@193.216.160.2
23:05:51 <dons> nornagon: it asks 'ld'
23:06:02 <glguy> oh, well played sir
23:06:02 --- mode: Cale set -oo Cale glguy
23:06:20 <nornagon> so what's the output of ghc? asm? C?
23:06:20 * dons sits in an empty house, post-garage sale
23:06:29 <nornagon> machine code?
23:06:31 <dons> with just a wireless net connection and a chair and a pile of books
23:06:39 <nornagon> dons: where're you moving to? :)
23:06:49 <cinimod> dons: are you in the US now?
23:06:50 <dons> nornagon: USA :)
23:06:53 <nornagon> woah!
23:06:58 <nornagon> big move
23:07:01 <shapr> yay!
23:07:08 <dons> nornagon: yeah, you missed the garage sale yesterday
23:07:16 <nornagon> rats :(
23:07:17 <dons> though i do have a m68k with netbsd on it available still...
23:07:21 <nornagon> heh
23:07:23 <nornagon> actually
23:07:26 <dons> as long as it doesn't get rained on too much
23:07:43 <nornagon> i'm looking for something to play with evolutionary programs on
23:07:43 <dons> 33Mhz of lambda crunking powers!
23:08:02 <nornagon> my DS is returning to me shortly, but the more the merrier
23:08:07 <glguy> shapr: what is the version number in the top right of my colorful prompt?
23:08:16 <glguy> OH, zsh's  version
23:08:16 <nornagon> and I can't really run random bytecode on a production machine :)
23:08:26 <dons> heh
23:08:39 <glguy> shapr: do you use that version number a lot? or did you just want more info to color? ;)
23:08:46 <dons> hey dolio
23:08:57 <dolio> Hi.
23:09:42 * nornagon apt-get source ghc6
23:09:42 <shapr> glguy: Heh, it's date, tty, kernel, and zsh version
23:09:56 --- mode: ChanServ set +o glguy
23:09:59 --- mode: glguy set -b %tech!*@*
23:10:06 --- mode: ChanServ set -o glguy
23:10:17 <glguy> that ban isn't doing anythign now
23:10:27 <shapr> glguy: Try prompt -<tab><tab> and then prompt -p <tab><tab>
23:11:02 <glguy> shapr: this is built in?
23:11:05 <glguy> shapr: or you added it
23:11:22 <shapr> Those prompts are built-in, but you can build your own prompt easily.
23:11:32 <ClaudiusMaximus> i find it odd that replacing  (fst . unzip)  with  (concatMap (\(a,b)->[a,b]))  fixes a space leak in my code
23:11:50 <glguy> shapr: yours is based on clint?
23:11:54 <shapr> I use clint
23:12:29 <shapr> I previously used something large and scary that Igloo wrote.
23:12:53 <nornagon> hm, i wonder if I could easily add tab-completion for svk
23:12:59 <nornagon> because zsh is missing it
23:13:00 <nornagon> :/
23:13:16 <cinimod> dons: I don't know if you saw my question yesterday or I missed the answer
23:13:24 <cinimod> dons: but any news on getBits?
23:14:03 <shapr> nornagon: Easy to write, look at /usr/share/doc/examples/zsh_completion* for some examples.
23:18:59 <dons> cinimod: oh, only ideas people have tried in Data.Binary
23:19:31 <cinimod> dons: is there somewhere I could look?
23:20:03 <cinimod> BTW if you recall NewBinary had a specail sort of handle that kept some state for this
23:21:02 <dons> yeah, it carried around an offset byte and some bits in a stateful fashion, wrapping a Handle
23:21:10 <dons> we'd do the same in Data.Binary with a transformer
23:21:17 <dons> and some new types and instances for sub-byte sizes
23:21:47 <cinimod> ok I'd probably need to understand what a transformer is
23:21:56 <wli> >> take 10 primes --> [1 + i,1 - i,3,2 + i,2 - i,7,11,3 + 2*i,3 - 2*i,4 + i]
23:22:00 <cinimod> I'm not at the point where I absolutely need it
23:22:28 <cinimod> I'm reading in the whole bytestring and then running a state monad to get the bits I need
23:22:45 <dons> that'd do.
23:23:14 <cinimod> for now but if I'm reading from the network it would be quite clumsy
23:23:32 <cinimod> it's ok for testing
23:24:38 <dons> right.
23:24:55 <cinimod> since I only get about 3 hours each weekend I have to focus so it's back to gadts and existential types for now
23:26:58 <nornagon> wow, there's still stuff in ghc that uses `bind`?
23:29:01 <nornagon> oh
23:29:12 <nornagon> bind f x = x $! f, apparently O_o
23:31:27 * glguy changes success to "tada.wav"
23:31:30 <glguy> from windows :)
23:33:17 <glguy> shapr: what is "most"
23:33:43 <shapr> It's an enhanced less/more clone.
23:33:55 <shapr> apt-cache show most
23:33:57 <glguy> what other dark ages cli tools might I still be using?
23:34:03 <shapr> I don't know :-)
23:34:33 * shapr cries at this persistent type error.
23:34:35 <glguy> whoa,my man pages are in color now
23:34:44 <mr_tenor> shapr: what a clever name
23:34:53 <shapr> Yeah, it's cute.
23:34:57 <glguy> :( most doesn't use vim up and down
23:35:03 <mr_tenor> :(
23:35:27 <glguy> X'(
23:35:44 <shapr> I use space and backspace to page up and down with most.
23:35:54 <shapr> and up and down arrows for one line at a time.
23:36:25 <shapr> Oh, I had this crazy idea today... we could make an OpenCroquet clone by mixing hs-plugins, lambdabot, and frag.
23:36:45 <hpaste>  shapr pasted "scary type error" at http://hpaste.org/2330
23:37:12 * glguy really needs to add a feature to hpaste: http://hpaste.org/latest
23:37:15 <glguy> for bookmarking
23:37:40 <shapr> I'm using {-# LANGUAGE FlexibleInstances, TemplateHaskell, UndecidableInstances #-} but that doesn't fix it. I tried adding IncoherentInstances, but that didn't help.
23:38:03 <shapr> Any clues?
23:44:32 <ChilliX> shapr: Hard to say without the source, but it seems as if that type variable "m" doesn't get sufficiently instantiated in the superclass predicates required by the instance where the error occurs
23:45:15 <wli> What are flexible instances?
23:45:28 <shapr> Heck if I know.
23:45:39 * shapr is cargo coding
23:45:48 <glguy> HAppS takes typeclasses to their bounds ;)
23:45:53 <shapr> And beyond
23:46:22 <glguy> which is where this error came from :)
23:46:33 <glguy> going beyond the bounds :)
23:46:37 <ChilliX> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#instance-rules
23:46:39 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
23:46:42 <shapr> HAppS mixes syb-with-class, fundeps, overlapping typeclass instances, and just about everything else you can think of...
23:46:51 <shapr> Extensions: UndecidableInstances, OverlappingInstances, Rank2Types, TemplateHaskell, FlexibleInstances
23:46:54 <shapr> From one of the cabal files.
23:47:50 <shapr> Surprisingly, mdo is only used in one module.
23:48:42 <shapr> ChilliX: Thanks
23:51:17 * glguy doesn't think that the mdo thread is particularly compelling for showing that monads are not about sequencing computation
23:51:30 <glguy> rather they are about including laziness in sequenced computation
23:56:22 <wli> Go to springschool95.ps for how monads are not about sequencing anything.
23:56:37 <wli> data Expr t = Var t | ...
23:56:46 <wli> Expr t is a monad.
23:57:06 <wli> Expr is a monad rather.
23:58:03 <slarba> huh
23:58:24 <slarba> I thought a monad requires bind and return in addition...
23:58:33 <wli> It has such.
23:58:37 <slarba> ah
23:58:38 <wli> return x = Var x
23:58:45 <wli> fmap is obvious
23:59:01 <wli> join :: Expr (Expr t) -> Expr t is obvious
23:59:02 <ChilliX> ?eval do {x <- [1..3]; y <- "abcd"; return (x, y)}
23:59:15 <ChilliX> > do {x <- [1..3]; y <- "abcd"; return (x, y)}
23:59:17 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(1,'d'),(2,'a'),(2,'b'),(2,'c'),(2,'d'),(3,'a'),(3,...
23:59:20 <wli> fmap and join give you bind
23:59:30 <ChilliX> Obviously nothing to do with "sequencing"
