00:00:05 <glguy> sorear: why do you suppose the script stopped at 06.10.01?
00:00:43 <sorear> glguy: Because it takes advantage of the fact that history doesn't change, and stops as soon as it reaches a complete log.
00:01:00 <dolio> Hmm... gmane doesn't filter spam.
00:01:49 <sorear> If you comment out line 15, it should do a non-incremental fetc.
00:02:14 <glguy> I need to tell it to start before 06.10.01
00:02:17 <sorear> Also, note that the clog logs themselves are not complete - you'll need to unpack a few "ancient history" tarballs
00:02:19 <glguy> would I change the AGO var then?
00:02:37 <sorear> hmm, that would probably work too
00:03:25 * sorear keeps meaning to integrate suffix-array functionality into fetch.sh
00:03:43 <wli> http://holomorphy.com/~wli/hncurses/
00:03:43 <lambdabot> Title: Index of /~wli/hncurses
00:04:10 <wli> I presume just slapping it up where it's web-accessible makes it darcs pullable?
00:04:15 <sorear> yes
00:04:43 <sorear> stefan@stefans:/usr/local/src$ darcs get http://holomorphy.com/~wli/hncurses/
00:04:43 <sorear> Copying patch 1 of 1... done.
00:04:43 <lambdabot> Title: Index of /~wli/hncurses
00:04:52 <sorear> woah, that was fast
00:05:29 * sorear was pretty sure that he could blink faster than a lightspeed round trip from San Diego to Sydney
00:05:52 <glguy> light has been going faster lately
00:05:58 <glguy> not like the old days any more
00:06:48 <sorear> @users
00:06:48 <lambdabot> Maximum users seen in #haskell: 375, currently: 323 (86.1%), active: 7 (2.2%)
00:07:22 <glguy> > 7 / 323
00:07:24 <lambdabot>  2.1671826625386997e-2
00:09:09 <newsham> > 24 / 7
00:09:11 <lambdabot>  3.4285714285714284
00:09:17 <newsham> > 22 / 7
00:09:19 <lambdabot>  3.142857142857143
00:09:39 <glguy> > printf "2.1%f" (7 / 323 :: Float) :: String
00:09:40 <lambdabot>  "2.10.021671826"
00:09:56 <glguy> > printf "%2.1f" (7 / 323 :: Float) :: String
00:09:57 <lambdabot>  "0.0"
00:10:06 <glguy> > printf "%2.1f" (7 / 323 * 100 :: Float) :: String
00:10:07 <lambdabot>  "2.2"
00:10:15 <glguy> > printf "%2.1f%%" (7 / 323 * 100 :: Float) :: String
00:10:16 <lambdabot>  "2.2%"
00:10:34 * glguy thinks that %% should probably be documented
00:11:28 <newsham> printf(3) ? :)
00:11:53 <glguy> > printf "%2.1f%%" (7 / 323 * 100) `asTypeOf` ""
00:11:54 <lambdabot>  "2.2%"
00:12:06 --- mode: ChanServ set +b palomer!*@*
00:12:11 <sorear> glguy: it is in man 3 printf
00:12:29 <glguy> sorear: sure, but that isn't where you should be looking for info on Text.Printf
00:12:51 <glguy> chanserv takes all the fun out of kickbans
00:13:57 --- mode: ChanServ set +o glguy
00:14:13 --- mode: glguy set +b %*!*@bas3-montreal02-1096682424.dsl.bell.ca
00:14:18 --- mode: glguy set -o glguy
00:14:20 <dolio> So, is notpalomer actually not palomer?
00:14:25 <glguy> lol, no
00:14:38 * glguy just set a +q for when he switches and returns...
00:15:18 <glguy> ?palomer
00:15:18 <lambdabot> That's a lie
00:15:36 <glguy> You don't earn a ?your_nick my being a positive contributor
00:15:40 <glguy> ?help palomer
00:15:40 <lambdabot> palomer. Sound a bit like palomer on a good day.
00:16:15 <dolio> @b52s
00:16:15 <lambdabot> Girl from Ipanema, she goes to Greenland
00:16:24 <Cale> @palomer
00:16:25 <lambdabot> Learning vim is pointless
00:16:29 <Cale> hehehe
00:16:32 <Cale> @palomer
00:16:33 <lambdabot> Hrmph
00:16:40 <sorear> @ghc
00:16:41 <lambdabot> ghc says: All the type patterns for a generic type constructor must be identical
00:16:41 <Cale> @jargon
00:16:57 <sorear> ghc is a positive contributor ;)
00:17:09 <glguy> ghc isn't someone's nick :-p
00:17:15 <Cale> @ghc
00:17:17 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
00:17:24 <Cale> Not always positive...
00:17:51 * glguy wonders if that message is meant to give you a sense of accomplishment when you cause it
00:18:01 <glguy> to make up for the fact that your program crashed
00:18:48 <Cale> @keal
00:18:49 <lambdabot> my very first computer was an 80-0840
00:18:54 * glguy finishes downloading the logs...
00:18:57 <Cale> @keal
00:18:58 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
00:19:16 <Cale> @keal
00:19:16 <lambdabot> Keal angry @ dons
00:19:17 <glguy> Cale: way to go giving him ammo ;)
00:19:28 <Cale> haha, I have no idea where he got that idea :)
00:19:30 <Cale> @keal
00:19:30 <lambdabot> i need math friendly compiler to compile for jvm or flash
00:19:46 <dolio> Mmm, math + flash.
00:19:48 <glguy> @protontorpedo
00:19:48 <lambdabot> cant u just have data in arrays and do operations using you prog lang?
00:20:02 <olathe> Heh
00:20:56 <Cale> @v
00:20:57 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
00:20:59 <Cale> @v
00:20:59 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
00:21:00 <Cale> @v
00:21:01 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
00:21:09 <Cale> @yhjulwwiefzojcbxybbruweejw
00:21:10 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
00:21:13 <Cale> heh
00:21:25 * glguy uses his new log file collection to read some palomer history :)
00:21:32 <glguy> 04.02.08:21:49:15 <palomer> what, a man can't hug another man?
00:21:43 <TSC> Not that there's anything wrong with that
00:22:50 <dolio> I must say, notpalomer seemed to have a remarkable lack of knowledge of haskell, given how much palomer hung out here.
00:23:01 <dolio> And how he was "doing stuff with GADTs", or something like that.
00:23:17 <glguy> 05.12.05:14:43:03 <palomer> my prof claims that you can't do  type inference with GADTs
00:23:39 <sorear> type inference is a word so overloaded as to be useless
00:24:15 <Cale> He was doing stuff with GADTs, unfortunately, rather tricky stuff to get working.
00:24:39 <sorear> Haskell 98 type inference is undecidable if you ask the right people.
00:24:46 <glguy> Cale: you seem to be about the only person he talked to
00:24:53 * wli just admits being pig ignorant.
00:25:10 <sorear> ... because to some people type inference means "erase ALL type annotations first"
00:26:23 <sorear> and polymorphic recursion in HM calculi is equivalent to semi-unification blah blah blah
00:26:37 <lament> Increase your productivity and deliver results by leveraging the synergy of type inference, a web 2.0 technology fully aligned with enterprise strategy!
00:27:17 <TSC> You left out "results-driven"
00:28:03 <lament> the reason haskell won't make it big is because of the terminology
00:28:19 <lament> "lazy evaluation"?? It clearly should be "goal-oriented evaluation"
00:28:32 <mr_tenor> good. makes it easier to Beat The Avearges (tm) ;)
00:28:35 <glguy> and we'll need to make it enterprise
00:28:47 <lament> at least it got "functional" right
00:28:55 <lament> "functional programming" could easily be a buzzword
00:29:34 <glguy> we need a robust knowledge base
00:29:47 <glguy> maybe we should take this discussion off line
00:29:53 <TSC> I hope you mean an expert knowledge base
00:30:09 <TSC> I know, we need more processes
00:30:29 <dolio> Open up some more sockets!
00:30:32 <dolio> Oh wait, I'm in 24.
00:31:14 <glguy> we need to take ownership of the solutions after we touch base about the big win
00:31:41 <lament> oh god
00:31:43 <TSC> People say "the bug win"?
00:31:47 <TSC> er, big
00:31:49 <dolio> Maybe we should focus on the low-hanging fruit first.
00:31:52 <lament> i've got a guy at work who actually says touch base all the time
00:32:08 <lament> he's perfectly sane, just likes saying touch base
00:32:21 <glguy> You guys need to focus on our Core Values
00:32:52 <lament> I like "the bug win"
00:33:04 <sorear> tnaur x86 Linux head:      pass
00:33:14 * sorear faints in the ray of light
00:34:25 <wli> I think it's misguided to deal with the notion of "functional programming." Tools are superior/inferior because of performance, not because of their theoretical purity.
00:35:58 <lament> wli: you're saying haskell is described as functional for the bragging rights?
00:36:08 <wli> No.
00:37:27 <lament> (although people certainly do claim haskell is good because it's purely functional)
00:39:27 <newsham> wli: as time goes on the relative importance of performance and purity shift
00:39:40 <mornfall> define performance :-)
00:39:43 <wli> I claim that the reason why Haskell is good is not because it's functional, purely or otherwise, though it may be partially a consequence of such.
00:40:07 <lament> ok, why?
00:40:08 <wli> newsham: "Performance" here is not in terms of e.g. execution speed, but rather effectiveness as a programming tool.
00:40:17 <scook0_> mornfall: the program produces the *correct* answer before the heat-death of the universe ;)
00:40:30 <mornfall> :-)
00:40:40 <mornfall> doesn't really help me most of the time, duh? :-)
00:41:31 <mornfall> well, purely functional or not, one of the important things is concise and powerful abstraction
00:41:36 <scook0_> wli: using the word "performance" is going to confuse and distract people
00:41:39 <mr_tenor> i've been playing guitar so not paying attention... wli: wtf are you on about?
00:41:45 <lament> scook0_: that would certainly help the guys in The Last Question...
00:42:19 <lament> mr_tenor: are you also ircing with a guitar on your lap?
00:42:22 <wli> scook0_: Yes, there should be a better description.
00:42:32 <mr_tenor> being functional and pure are what makes haskell one of the best abstraction  and programming tools available
00:42:46 <mr_tenor> the compiler proves things for me because i can'ttrust myself :)
00:42:47 <glguy> ?where stats
00:42:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
00:42:58 <mornfall> mr_tenor: maybe.
00:43:01 <mr_tenor> lament: more watching irc while playing
00:43:13 <lament> yeah, same here
00:43:17 <mornfall> should go for my recorder...
00:43:18 <scook0_> wli: since "performance" on its own will almost always be interpreted as "machine performance" ... whereas you're more talking about "programmer performance" or "overall productivity"
00:43:47 <mornfall> scook0_: but 2 out of 3 people got it right (from reactions anyway)
00:43:53 <mornfall> so it's not that bad :)
00:45:46 <lament> programmer productivity depends first of all on familiarity with the tools, and second with how well the different tools are integrated :)
00:46:03 <mornfall> maybe.
00:47:27 <wli> scook0_: Programmer productivity is how I should phrase it, then.
00:47:39 <mr_tenor> i'm very familiar with C anda load of related tools, but i rewrote a substantial chunk o our code in haskell despite beinga noob in about 2 orders of magnitude less time than the original took
00:47:52 <mornfall> but it's still likely that an advanced flint user will have problem competing with a novice knife user when it comes to slicing bread :-)
00:48:33 <mornfall> which is consistent with mr_tenor's observation here :-)
00:49:04 <mornfall> let's face it, haskell pwns C :]
00:49:05 <lament> i'd be more careful insulting advanced flint users like that
00:49:13 <mornfall> not insult
00:49:18 <mornfall> just observation
00:49:20 <lament> they're short-tempered and very good with their flint :)
00:49:46 <mornfall> hm, goes as well with advanced C users
00:49:54 <lament> haha
00:50:56 <Korollary> how do you become an advanced C user?
00:51:10 <wli> There's also something on the order of r-strategy vs. K-strategy in terms of programmer training.
00:51:43 <sm> woah there!
00:51:51 <mae> hi
00:52:09 <fdr-> Korollary, obscene macros, unorthdox casts, function and environment pointers (see greenspun's tenth rule) for starters.
00:52:10 <mae> any reccomendations for building web apps on haskell? whats the latest hot shit scoop
00:52:20 <sm> hey people, can we just "touch base" here on the k-strategy thing
00:52:20 <wli> r-strategy being to train smaller groups of programmers to the hilt, and K-strategy being to not bother much with training them beyond basic competence and throw huge numbers of programmers at the problem.
00:52:44 <lament> r-strategy means "never gets laid"
00:53:05 <lament> and k-strategy means "dies very young"
00:53:13 <glguy> ?quote laid
00:53:13 <lambdabot> wli says: I'd settle for getting laid a lot.
00:53:20 <Korollary> fdr-: I doubt those are things a regular C programmer would have trouble wrapping their heads around
00:53:28 <glguy> i knew that would come in handy ;)
00:53:29 <mornfall> wli: about the opposite, i think
00:53:39 <fdr-> Korollary, are you sure? Average is a dangerous word.
00:53:45 <mr_tenor> Korollary: you mean not getting laid and dying young?
00:54:10 <wli> mornfall: yes, sorry, the other way around.
00:54:16 <Korollary> I said regular, for some definition of regular.
00:54:30 <sorear> mae: HAppS is the most popular option.
00:54:39 <sorear> mae: subchannel #happs
00:54:45 <olathe> Programmers that can be modelled by finite state machines.
00:54:55 <Korollary> olathe: exactly
00:55:18 <wli> sorear: How does it interoperate with preexisting webservers you want to stick around?
00:55:24 <fdr-> That would be.....all of us?
00:55:27 <lament> "advanced c programmer" sounds romantic
00:55:32 <sorear> wli: mod_rewrite :)
00:55:38 <lament> the man against the machine
00:55:49 <lament> a cold, lonely battle that the man is doomed to lose
00:56:03 <Korollary> or one that man won in 1987
00:56:08 <mornfall> lament: may i quote you on that? :)
00:56:09 <wli> Slightly less stupidity now...
00:56:15 <lament> what happened in 1987?
00:56:22 <lament> mornfall: sure :)
00:56:24 <glguy> haskell was born?
00:56:43 <sorear> The implementation of functional programming languages was written
00:56:52 <Korollary> I actually picked it randomly
00:57:38 <Korollary> There is a C89 standard. I'm guessing by 1987 C was completely figured out by whoever cared about it
00:58:39 <fdr-> I am detecting this air of pretentiousness that once (maybe still?) seemed to pervade the lisp community, to somewhat ruinous results.
00:59:20 <Korollary> we are pretentious elitist bastards
00:59:21 <kilimanjaro> fdr-, smart people bring pretentiousness with them. You should hang out around a math department if you really feel worried about Haskell
00:59:47 <dolio> Yeah, but we think lisp sucks, too, so that we don't have anything to worry about.
00:59:56 <hpaste>  sorear pasted "sample apache2 configuration for use with happs (this is /etc/apache2/sites-enabled/000-default on k" at http://hpaste.org/2185
01:00:05 <fdr-> kilimanjaro: I used to -- and currently -- do research for one. I don't think it's a necessity to be pretentious to be smart, or vice versa.
01:00:06 <lament> fdr-: in the lisp community, it might have gotten worse
01:00:08 <sorear> akapo)
01:00:13 <Korollary> Actually, the really smart people are very modest.
01:00:26 <lament> fdr-: but you have a point
01:00:29 <newsham> generalizations are always wrong
01:00:42 <kilimanjaro> fdr-, it's not necessary, but I think it is very common for somewhat smart students to be pretentious, especially online
01:01:00 <kilimanjaro> I'm not claiming it is a good thing, only that I almost expect it in general
01:01:09 <mornfall> newsham: that was one of them.
01:01:20 <Korollary> which is why it was a joke
01:01:36 <fdr-> kilimanjaro: someone should beat it out of them; such as the role of a good university education.
01:01:37 <newsham> goedel humor
01:01:40 <wli> Korollary: That's not 100% true, but it is most of the time.
01:01:44 <kilimanjaro> fdr-, :)
01:01:47 <mornfall> : - )
01:02:32 <wli> Korollary: Enough of the time that it's safe to write off anyone pretentious/egotistic/etc. as a dunce.
01:02:38 <mornfall> it's a good tradition among people that they look down on "the others" (dunno why)
01:03:00 <newsham> you're talking about conditional probabilities
01:03:22 <newsham> probability(smart | has ego on the irc)
01:03:37 <fdr-> I personally think it's insane to write lots of things in C, just for practical reasons, and perhaps often an indefensible position, but smart (and smarter) people do both disagree and disagree with me frequently.
01:03:38 <lament> fdr- has a very good point. Lisp is universally known as the language of assholes. Don't let the same happen to haskell.
01:03:49 <mornfall> Korollary: as for smart people being modest, i suspect that's just wishful thinking
01:03:55 <fdr-> lament: And AI researchers! don't forget us :(
01:04:21 <Korollary> mornfall: I've met several very smart and modest people.
01:04:31 <mornfall> Korollary: which doesn't make them a majority
01:04:34 <newsham> probability(smart | has ego on the irc) can be low even if most smart people have egos
01:04:56 <mornfall> Korollary: all kinds of people exists : - )
01:05:05 <Korollary> mornfall: so you and I are going to disagree as to which one of us has the correct anecdote?
01:05:16 <mornfall> dunno
01:05:17 <fdr-> Dijkstra, for example, ended his years a pretentious pain
01:05:28 <fdr-> Hector Garcia-Molina still is very down to earth and friendly
01:05:35 <mornfall> i just think there are both many modest smart people and many pretentious smart people and many smart people in between
01:05:50 <fdr-> It's hard to read Stonebraker, he may be somewhere in between. I think he's OK.
01:06:20 <Korollary> fdr-: By C do you mean C++ as well? Who's writing all this great stuff in C nowadays?
01:06:34 <mornfall> don't mix up C and C++, pleeease
01:06:38 <mornfall> i like my C++
01:06:43 <newsham> ewww
01:07:01 <newsham> i would agree and disagree (dont mix up C and C++, but I dont lik the c++)
01:07:03 <fdr-> Korollary: postgres hackers are providing good software, as are the Linux guys
01:07:31 <mornfall> define good software :)
01:07:36 <kilimanjaro> isn't a bunch of the GHC runtime written in C?
01:07:40 <fdr-> Lots of system-style programmers even pervade high-powered academia (Joseph Hellerstein)
01:08:01 <mornfall> not sure what high-powered is
01:08:04 <Korollary> fdr-: There's a lot of stuff outside the open source projects.
01:08:12 <mornfall> but SPIN is in C (and it's painful, too)
01:08:25 <fdr-> Korollary: certainly a lot, but you asked for some good stuff, so I thought about a second and thought of these as a couple of examples of decent work
01:08:27 * wli massively cleans up the non-extended terminfo parser.
01:08:42 <kilimanjaro> C is the fallback language for writing portable, efficient systems code
01:08:48 <wli> I suppose I qualify as a Linux guy.
01:08:51 <hpaste>  Olathe pasted "How do I get rid of the errors in the comment at the end ?" at http://hpaste.org/2186
01:09:25 <Korollary> fdr-: examples are ok. It's just that you sounded like C was a popular choice as well.
01:09:36 <wli> Seems to still work.
01:09:57 <fdr-> Korollary: well, it is, for some still it is. I would personally like to see a just-as-fast low-level lisp, but that's my personal inclination
01:09:59 <lament> just to have this here window i'm typing stuff in, i'm using irssi, screen and bash.
01:10:10 <lament> all written in c
01:10:15 <olathe> Oh, never mind. I think there's more.
01:10:27 <mornfall> lament: + glibc and the kernel, C again
01:10:34 <lament> (plus iterm which is probably objc?)
01:10:45 <newsham> its amusing how many arguments about C there are here
01:10:53 <wli> The need for something like C is not going to go away.
01:11:11 <mornfall> wli: i suspect that's inertia
01:11:11 <lament> newsham: i think the main reason for that is that C is a very good language.
01:11:26 <mornfall> lament: i'm bound to disagree :-)
01:11:35 <newsham> at least this is a bounded argument
01:11:41 <fdr-> lament: I would say it was good-enough for the time, now we could do much better...the Bit-C guys are looking at some of this.
01:11:43 <wli> mornfall: It's not. Something just above the level of assembly fills a very needed niche.
01:11:51 <dolio> glibc is written in C, eh? :)
01:12:04 <newsham> not all popular software is good software (i'm looking at you, glibc)
01:12:07 <mornfall> wli: maybe.
01:12:20 <mornfall> wli: what niche is that?
01:12:24 <Korollary> It doesn't need to go away. And it's obvious that there is a ton written in C. However, search for job ads and you'll see that a lot more is written in C++, Java, C#, what have you.
01:12:38 <kilimanjaro> fdr-, this probably won't be useful because it isn't really under active development, but are you aware of PreScheme? It's pretty much on par with C for performance (and by pretty much, I mean I wrote some numeric code that was faster than my handwritten C equivalent by about 4%), it has a HM style type system but other than that it is a subset of Scheme and supports full Scheme macros and in fact you can have higher order code at
01:12:39 <kilimanjaro> the top level since it gets partially evaluated away
01:12:40 <lament> fdr-: well, obviously C is not perfect and you could do much better, but it's still impressively good (IMO)
01:13:00 <fdr-> fdr-: well, something "like" C. No. But thanks for the link, I will follow up on it
01:13:09 <cinimod> Olathe: has anyone replied to you yet?
01:13:09 <Korollary> kilimanjaro: is that the typed scheme lang of plt scheme?
01:13:11 <fdr-> lament: right. it was a pretty good job for the time and the tools.
01:13:11 <DRMacIver> lament: Isn't a lot of irssi written in perl?
01:13:12 <wli> mornfall: Low-level code. Things that are basically architecture-independent assembly code.
01:13:30 <DRMacIver> (And, amusingly, that which is written in C is still garbage collected)
01:13:36 <lament> DRMacIver: i don't think so; some but not a lot
01:13:37 <mornfall> C++ pwns C on many aspects, although it's obviously imperfect in its own right
01:13:48 <kilimanjaro> Korollary, it's used for Scheme48
01:13:51 <DRMacIver> lament: ok. I've not looked at the source, so I'll take your word for it. :)
01:13:51 <fdr-> actually, I think i've seen prescheme once before, but hadn't thought about it for a long time
01:14:05 <fdr-> prescheme
01:14:07 <mornfall> wli: i don't know any such code that C++ wouldn't be better suited for :-)
01:14:07 <fdr-> oops
01:14:16 <wli> mornfall: C++ is inappropriate for many cases where C is needed because of the RTTI and exception-handling RTS requirements.
01:14:31 <lament> DRMacIver: it's more of a vim model than emacs model :)
01:14:31 <fdr-> the problem is that of popularity; someone needs to write a nice chunk of prescheme and exercise the compiler before anyone else will write any
01:14:34 <mornfall> wli: which are both optional, right? :-)
01:14:42 <mornfall> wli: see L4Ka::Pistachio
01:15:01 <wli> mornfall: Sort of. You essentially end up in the situation where you can accidentally use them.
01:15:16 <mornfall> wli: compiler won't let you
01:15:17 <lament> "oops, i did it again"
01:15:17 <wli> mornfall: And then things crash.
01:15:30 <wli> mornfall: Depends.
01:15:39 <mornfall> wli: g++ :)
01:15:55 <wli> mornfall: Newer compilers may have compile-time flags that check and forbid it.
01:16:04 <mornfall> you can accidentally use the *0 = 1; feature of C and things crash, too
01:16:10 <fdr-> has anyone checked out epigram?
01:16:23 <newsham> who's going to draw the line between all the c/c++ code written for win32?
01:16:33 <newsham> which is for a c++ compiler but doesnt make use of c++ features
01:17:01 <fdr-> one thing that bothered me a bit about Haskell's philosophy is the rather fascist conformity. One thing I like about lisp is the heterogeneous approach you can take to problems.
01:17:19 <fdr-> epigram also has a pay-as-you-go model, but is much more interesting with typing
01:17:28 <fdr-> maybe one day there will be a lisp (perhaps liskell?) that'll do something similar
01:17:40 <mornfall> fdr-: dunno, dunno (about fascist)
01:17:41 <kilimanjaro> what do you mean by "pay-as-you-go"?
01:17:49 <newsham> mornfall: yah, and people do it all the time for debugging :)
01:17:55 <glguy> that was one of the problems cited recently in that reddit link. the author said some stuff about not being able to use libraries together because of custom incompatible defun definitions, for example
01:17:56 <Korollary> I don't know what you mean. But I like fascist stuff.
01:17:58 <lament> what's conformity?
01:18:02 <fdr-> you get correctness and provability for chunks you care about, and can be a bit looser about stuff you don't.
01:18:14 <kilimanjaro> ahh
01:18:14 <olathe> cinimod: I just forgot to add half the program :)
01:18:23 <fdr-> look at Erlang. Without proving any sort of correctness they have wrote real, huge, and reliable programs.
01:18:25 <wli> What's needed in the C space is very modest.
01:18:33 <fdr-> so it's certainly a viable approach
01:18:36 <olathe> How do I load a file in ghci with -fglasgow-exts ?
01:18:42 <fdr-> and I'd like to choose.
01:18:48 <fdr-> module by module, or even function by function.
01:18:49 <Korollary> That is diverging into a typechecking argument
01:18:55 <newsham> fdr: are you arguing for dynamic typing?
01:18:57 <newsham> i cant tell
01:18:58 <lament> fdr-: by conformity do you mean how difficult/annoying it is to write impure stuff?
01:19:07 <wli> A massive amount of the language definition is loopholes for undefined behavior.
01:19:13 <cinimod> olathe: it did look like something was missing
01:19:31 <fdr-> lament: or things that don't fit into type inference. or if you really do think the occasional global variable may not be immediate death.
01:19:32 <mornfall> well, pure stuff makes things much easier :-)
01:19:42 <mornfall> fdr-: it may
01:19:46 <Cale> olathe: You can pass -fglasgow-exts on the commandline, or :set -fglasgow-exts in ghci, or add {-# OPTIONS_GHC -fglasgow-exts #-} to the top of the file
01:20:04 <lament> fdr-: admittedly it's not that hard
01:20:05 <kilimanjaro> mornfall, erlang programmers agree. They try to separate pure from impure code
01:20:15 <newsham> fdr: so you want two things -- dynamic typing and side effects
01:20:17 <lament> fdr-: also, there's erlang..
01:20:18 <Cale> Or even add  :set -fglasgow-exts  to your .ghci file
01:20:22 <mornfall> fdr-: the pure/unpure split is probably very important (or so i think)
01:20:23 <wli> Some of this is unavoidable as it relates directly to the machine interface aspect. Proper language design would at least attempt to minimize that.
01:20:43 <fdr-> mornfall: I don't see why not, there's no reason why your compiler can't tell you "I cannot prove termination in this flow, but I can in this"
01:20:53 <fdr-> (okay, there are reasons, but with some help it could do this)
01:21:01 <wli> For instance, restrict undefined behavior exclusively to where machine interfacing affairs demand it.
01:21:17 <fdr-> in fact, if you use labels in say, SBCL, it'll detect some type clashes and even remove resultant unreachable code
01:21:22 <mornfall> fdr-: it's too easy to corrupt all of your program that way
01:21:55 <fdr-> but what is corruption? Would you really be so extreme to suggest that absolute purity is always right?
01:22:06 <Korollary> fdr-: What do you mean by absolute purity?
01:22:14 <mornfall> fdr-: corruption is violating referential transparency
01:22:41 <mornfall> which beats your program into a sensless tangle
01:22:51 <newsham> wouldnt "absolute purity" be the definition of "always right"?
01:23:08 <fdr-> newsham: no, it only means "always terminates" as far as I know
01:23:13 <fdr-> error is certainly still possible
01:23:16 <newsham> this is where jesus said "get the behind me satan" in the version I read.
01:23:26 <mornfall> terminates? someone got stuff mixed up here?
01:23:27 <newsham> fdr: purity does not imply termination.
01:23:49 <wli> typedef should be removed and function type syntax adjusted so that complex function types are actually human-writable. varargs should probably be removed. An primitive module system instead of the extern/static crap. etc.
01:24:04 <mornfall> well, since the pure language is turing-complete, you obviously cannot have termination there , either
01:24:04 <fdr-> it does when it comes to obeying the common type-inference algorithms. And that's a benefit that the MLs boasted for some time
01:24:20 <fdr-> mornfall: but it's not, if the types all check out. You can, though, get very close.
01:24:28 <wli> sorear: Massive cleanup of offset handling.
01:24:39 <wli> sorear: Seems to still work.
01:24:45 <newsham> this is silly..  g'nite
01:24:45 <mornfall> fdr-: what it's not/
01:24:51 <mornfall> ?
01:24:54 <dolio> sorear's not here, man.
01:24:55 <mornfall> newsham: night
01:25:09 <fdr-> no. Look up Hindley-Milner type inference and turing completeness
01:25:36 <fdr-> I'm not disputing the value of proving correctness of chunks of code, I just don't claim that it's necessarily the best idea for all code to ever be written.
01:25:39 <wli> To carry this out, I'd actually start with C as-is and incrementally modify it in backwards-incompatible fashions toward these ends.
01:25:40 <mornfall> i must be missing out on something :-)
01:25:48 <Korollary> fdr-: I have no idea what you are saying.
01:25:52 <glguy> fdr-: what does type-checking always terminating have to do with "absolutely pure" programs always terminating
01:26:25 <dolio> > sum [1..]
01:26:27 <mornfall> ah, you are talking about the type inference terminating? oops :)
01:26:29 <lambdabot> Terminated
01:26:31 <newsham> glguy: "troll"
01:26:31 <wli> While fdr- has been trolling, I've made strides on the ncurses NIH.
01:26:39 <fdr-> oh? am I trolling?
01:26:49 <fdr-> I'm just arguing that I don't know if purity is the best way to solve everything
01:26:54 <fdr-> it's not the most extreme position
01:26:59 <Korollary> fdr-: WE have a terminology problem
01:27:00 <newsham> yah but you dont even know what purity means
01:27:03 <newsham> (or at least pretend not to)
01:27:10 <newsham> so the argument is completely pointless
01:27:13 <newsham> *yawn*
01:27:15 <mornfall> a TM emulator in pure haskell would be a snap
01:27:33 <fdr-> newsham: okay, okay, so you refer to referential transparency. OK. I can agree there are some nice properties
01:27:43 <fdr-> but are you also trying to say that it's never useful to break it?
01:27:55 <fdr-> I'm just a pluralist at heart is all.
01:28:18 <Korollary> fdr-: There are languages where you can break it as much as you like. This is just a different experiment.
01:28:36 <lament> even in haskell, it's pretty easy
01:28:56 <fdr-> lament: true, it's possible to break anything, with minimal effort....
01:29:07 <glguy> topaz?
01:29:13 <lament> it's more of a philosophical thing not to break stuff
01:29:15 <kilimanjaro> emerald
01:29:37 <lament> imagine if all haskell tutorials started with do notation and iorefs
01:29:38 <fdr-> Korollary: well, understandable. I'm not arguing for change of this experiment. I'm just wonder aloud about opinions on a pay-as-you-go-style paradigms. You trade some of this for some of .
01:29:45 <fdr-> *that
01:30:06 <fdr-> epigram takes this model with regards to typing, or intends to.
01:30:07 <wli> I have no idea what a "pay as you go" paradigm is.
01:30:14 <mornfall> neither have i
01:30:14 <fdr-> it's something I picked up from epigram
01:30:15 <mornfall> but
01:30:15 <kilimanjaro> wli, you know, cell phones
01:30:18 <lament> and then introduced unsafePerformIO
01:30:30 <mornfall> :-)
01:30:31 <kilimanjaro> it's like a calling card vs calling plan
01:30:40 <wli> I've literally never used unsafePerformIO
01:30:42 <fdr-> http://www.e-pig.org/
01:30:44 <lambdabot> Title: Epigram
01:30:49 <wli> And I intend never to do so.
01:30:52 <fdr-> excuse the funny url
01:31:33 <dolio> I've played some with epigram and read the papers, and I'm still not sure what "pay as you go" means.
01:31:43 <mornfall> i just believe that it's cheaper to be pure all the way
01:31:44 <dolio> In fact, they want to make non-termination monadic.
01:31:47 <fdr-> Epigram has got a type system which is strong enough to express the behaviour of programs, the type checker then guarantees that the program is well behaved. However, you don't have to go as far, you can write ordinary programs and refactor them into more trustworthy, formally checked deliverables -- Epigram supports a pay as you go  approach to formal met
01:31:52 <fdr-> (quoted)
01:32:02 <fdr-> methods, at the end there
01:32:23 <fdr-> I like the idea of switching programming paradigms when my whimsy (or sense) demands it.
01:32:32 <fdr-> but the pain of linking things together is still relatively immense
01:32:46 <mornfall> and that's relatively inherent
01:33:09 <fdr-> oh, I don't know....do you think so?
01:33:14 <mornfall> i think so
01:33:18 <fdr-> why?
01:33:23 <wli> There was poplog.
01:33:28 <mornfall> just a general feeling
01:33:34 <fdr-> well, I guess that's all I have to go on.
01:33:36 <dolio> Or, partiality, that is. I suppose there's well behaved non-termination with codata that they're looking into for Epigram 2.
01:34:06 <wli> It supported multi-language programs from a few different paradigms.
01:34:14 <fdr-> I feel like it could be done, especially if you helped the compiler by declaring the formalisms you wanted to use on various parts
01:34:50 <fdr-> poplog seems like a good example, on cursory glance
01:35:01 <wli> POP-11, Common Lisp, Prolog, Standard ML, and a separate package for some variant of Scheme.
01:35:22 <fdr-> I'm not sure of the religiosity on the issue is a healthy one. I don't think I've ever gotten accused of trolling before.
01:35:47 <glguy> oh, you just got accused of that because you were misusing terminology in a particular way
01:35:55 <fdr-> yeah, I can take blame for that
01:35:57 <glguy> not because you were being contriversial
01:36:06 <fdr-> I see it's a hot topic
01:36:20 <mornfall> dunno, i have my beliefs about paradigms :-)
01:36:34 <fdr-> me too, but I also have my doubts.
01:36:38 <fdr-> about everything.
01:36:39 <Korollary> fdr-: epigram is not something that would get one into trouble in #haskell
01:37:00 <fdr-> well, I'd hope not.
01:37:08 <mornfall> fdr-: who doesn't+
01:37:09 <fdr-> In any case, sorry about the misunderstanding
01:37:28 <fdr-> I confess, I'm still mostly a lisp hacker, but I'd like to try to integrate some Qi into my programs
01:37:38 <Korollary> turbocharged typesystems are cool
01:37:46 <wli> Paradigms are things you master. To be well-rounded as a programmer you should know various paradigms and be able to execute them correctly.
01:38:06 <fdr-> wli: I also take the generalists' point of view
01:38:19 <mae> <-- same here
01:38:30 <fdr-> I've been thinking about writing a small interpreter on top of Lisp to experiment with a few interesting things.
01:38:30 <mornfall> i've never really gotten into prolog :\
01:39:09 <fdr-> that's an interesting world.
01:39:32 <fdr-> I can't say I really "got into" it, because it's rare to see it with supported libraries.
01:39:32 <mornfall> but i do C and C++ for living and i use C++ in funny ways sometimes
01:40:04 <Korollary> coworkers don't appreciate C++ used in funny ways
01:40:17 <fdr-> hmm. I write Python, Lisp, Java...well, I guess whatever I think solves a problem most easily or is amusing to me at the time (it's a little selfish)
01:40:19 <mornfall> possibly
01:40:40 <fdr-> if I write a clustering layer for our lisp KB it may be in Erlang
01:41:09 <fdr-> I have to admit: Java makes my skin crawl though
01:41:25 <Korollary> @karma java
01:41:26 <lambdabot> java has a karma of 0
01:41:33 <fdr-> hmm
01:41:35 <fdr-> @karma lisp
01:41:35 <lambdabot> lisp has a karma of 0
01:41:38 <mornfall> java--
01:41:44 <lament> erlang seems neat
01:41:51 <dolio> @karma dons
01:41:51 <lambdabot> dons has a karma of 1
01:41:58 <dolio> Huh. Did it get reset again?
01:42:01 <Korollary> karmas have been lost?
01:42:04 <glguy> @karma
01:42:04 <lambdabot> You have a karma of 1
01:42:06 <glguy> yup :)
01:42:06 * wli discovers Ferranti's woes in relation to poplog.
01:42:07 <fdr-> it's an interesting language, that, for a number of reasons, neatly defeats tons of optimization
01:42:17 <fdr-> but I think it's worth it for what it was designed for
01:42:25 <wli> Poplog started off on the Ferranti Pegasus.
01:42:32 <Korollary> @quote stereo
01:42:32 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
01:42:38 <Korollary> oh man
01:42:45 <glguy> @quote C'ale
01:42:45 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
01:42:50 <glguy> @quote plane
01:42:51 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
01:43:05 <mornfall> hm, i could start looking for breakfast
01:43:20 <fdr-> as for "purity": I think I referred to type-purity more than referential transparency because my own skin crawls whenever I see a setf in a lisp program
01:43:24 <glguy> poor lambdabot :( alzheimers is a bitch
01:43:31 <fdr-> so I saw that as the more natural (and annoying) purity to satisfy at times
01:43:39 <mae> what else besides happs?
01:43:57 <fdr-> I didn't know it had such a strong binding to referential transparency
01:43:57 <wli> Ferranti later acquired a company called International Signal and Control (ISC) which was essentially a front for US clandestine organizations and because of that got nailed for massive fraud and illegal arms sales, the prosecution for which put it out of business.
01:44:31 <mornfall> did they later rename to internet software consortium? sounds like a match ;-)
01:44:44 <Korollary> fdr-: I've never even heard of "purity" to describe a type system. I've heard "strong, weak, sound," etc
01:45:10 <mornfall> i think he was referring to static type safety
01:45:19 <wli> IOW the US' spying games screwed up a major innovator in the hardware arena.
01:45:20 <mornfall> or something like that, anyway
01:45:49 <fdr-> well, sound is probably the best word I can pick of those
01:45:54 <glguy> Unknown to Ferranti, ISC's business primarily consisted of illegal arms sales started at the behest of various US clandestine organizations. On paper the company looked to be extremely profitable on sales of high-priced "above board" items, but in fact these profits were essentially non-existent. With the sale to Ferranti all illegal sales ended immediately, leaving the company with no obvious cash flow.
01:47:15 <fdr-> yes, I refer to the types.
01:47:19 <wli> glguy: Who'd have thought something like that could happen?
01:47:19 <mornfall> screw referential transparency, i'm off to mutate some food... bbiaw :-)
01:47:26 <fdr-> awesome
01:47:31 <fdr-> ...fish to cow?
01:49:23 <glguy> ?djinn fish -> cow
01:49:24 <lambdabot> -- f cannot be realized.
01:49:56 <opqdonut> ;D
01:50:12 <Korollary> maybe g can be realized.
01:50:21 <glguy> give it a shot!
01:51:13 <Korollary> ?djinn Fish -> Maybe Cow
01:51:13 <lambdabot> f _ = Nothing
01:51:29 <wli> So basically I need to figure out how to parse the extended header and then I'm set.
01:51:33 <glguy> Korollary: it looks like it tossed out your fish
01:51:36 <glguy> and gave you no cow
01:51:52 <glguy> ?djinn fish -> Not (Not fish)
01:51:52 <lambdabot> f a b = b a
01:51:55 <profmakx> gee C# is ugly -.-
01:52:23 <RubberHound> Really? how come?
01:52:23 <mauke> @djinn fish -> (fish -> cow) -> Maybe cow
01:52:23 <lambdabot> f a b = Just (b a)
01:53:30 <fdr-> so I have a question: what is the favorite editing environment for Haskell? Is it still "your favorite text editor," or are there notables?
01:53:35 <wli> After the extended header is parsed, then I can move on to interpreting the string capabilities.
01:53:57 <lament>  it sure as hell isn't your favourite text editor, you dirty lisper!
01:54:01 <fdr-> :)
01:54:14 <fdr-> wild guess as to what my text editor is? I'm afraid it's the obvious o ne
01:54:23 <mauke> ED
01:54:28 <mauke> ED IS THE STANDARD EDITOR
01:54:38 <lament> fdr-: emacs, you slime!
01:54:39 <wli> Text editor flamewars are not a great idea.
01:54:50 <mae> ed?
01:54:51 * glguy guesses that the maintainer of your editor has lost touch with reality and doesn't comb his hair
01:54:56 <wli> mauke: Implementing ed(1) in Haskell might make a good monadic programming exercise.
01:55:02 <opqdonut> mmmh
01:55:04 <opqdonut> sounds good
01:55:15 <mae> textmate? (duck)
01:55:32 <lament> wli: main = getLine >> putStrLn "?" >> main
01:55:34 <mae> i'm hardcore vi but ever since i got this shiny mac i'm learning tm
01:55:44 <psykotic> fdr: emacs is great for haskell. the haskell extension is very good.
01:55:46 <lament> wli: do i get a cookie?
01:55:51 <opqdonut> yah emacs rocks
01:55:54 <opqdonut> but not as much as ed
01:55:56 <opqdonut> ^_^
01:55:58 <fdr-> alright. emacs it is
01:56:01 <fdr-> now, is there a slime yet?
01:56:15 <opqdonut> there's some ghci integration
01:56:27 <fdr-> because I must confess, Swank is probably one of the best ideas the lisp community ever had
01:56:29 <psykotic> fdr: haskell doesn't really support the same level of live hacking as cl.
01:56:31 <wli> lament: No. Your "implementation" does not pass.
01:56:33 <glguy> fdr-: Haskell doesn't need much special support from the editor, so just use your favorite
01:56:40 <mauke> main = interact (unlines . map (const "?") . lines)  -- HOF
01:56:42 <lament> wli: i can't tell the difference!
01:56:47 <opqdonut> mauke: hehe
01:56:53 <fdr-> psykotic: yeah, I was wondering if I could get close
01:56:55 <mauke> fdr-: I heard there's something called "shim"
01:57:15 <fdr-> oh? hmmmm. maybe a good thing to poke at
01:57:36 <fdr-> do many lispers hang out with you guys?
01:57:39 <fdr-> sounds like it's a slur around here ;)
01:58:53 <glguy> there aren't many that are openly lispers if there are many at all
01:59:13 <glguy> might just all be in the closet still?
01:59:14 <dolio> There's lispy, but I don't think he does much lisp anymore. :)
01:59:35 <opqdonut> we should force lispers to register themselves and wear "lisp" on their nicks
01:59:41 <dolio> He doesn't talk that much anymore, for that matter.
01:59:45 <opqdonut> in preparation for the "final solution for lisp"
02:00:39 <fdr-> scary
02:00:42 <fdr-> what about liskell?
02:00:46 <fdr-> I mean, that seems like a reasonable idea ato me
02:00:58 <fdr-> ....basically, I think quasiquote pwns.
02:01:24 <mauke> I think lisp is an ok back-end language but it's obviously not meant to be written by humans
02:01:37 <fdr-> oh come on :)
02:01:46 <mauke> )))))))))))
02:02:02 <psykotic> liskell seems like a horrible idea
02:02:07 <fdr-> okay. point taken. but we have machines to help, and that is okay
02:02:15 <fdr-> psykotic: why do you say that?
02:02:20 <psykotic> because haskell is very much about syntax too
02:02:27 <wli> The AST dump syntax does seem like a huge cop-out to me.
02:02:44 <fdr-> well, historically it was, actually
02:02:52 <fdr-> it was intended to be temporary
02:03:11 <glguy> the only compelling use of macros I've seen was to automatically generate a class from some other description format, but macros seem to be a use part of the draw
02:03:25 <fdr-> I use macros frequently
02:03:37 <psykotic> glguy, also, 'deriving' isn't a weird hack anymore.
02:03:47 <psykotic> there are some nice benefits, but they aren't worth the price of admission.
02:03:59 <fdr-> hmm.
02:04:20 <fdr-> I do have to say, I cannot think of any language I've seen that's better for manipulating trees. It's little surprise, perhaps, that lisp may dominate in this area
02:04:22 <glguy> symbolic manipuation of code where you can actually look at the symbols is a long way to write the word "fragile"
02:04:39 <opqdonut> :))
02:04:41 <psykotic> it's also a lot trickier with haskell than lisp
02:04:47 <psykotic> actually lisp has the same problem
02:04:54 <glguy> there was some bad example of automatic differentiate of a limited lambda expression
02:05:01 <psykotic> if you want to write codewalkers that respect declamations, you are in for hell.
02:05:05 <glguy> on reddit lately
02:05:07 <psykotic> but it's even worse in haskell.
02:05:19 <wli> psykotic: "Declamations?"
02:05:32 <psykotic> (DECLARE X NUMBER)
02:05:39 <fdr-> the things that sort of get littered into the code that have compiler significance
02:05:46 <fdr-> often used for optimization settings, types, etc.
02:06:04 <wli> psykotic: Reader monad, blah blah blah.
02:06:05 <fdr-> I would argue scheme's internal-defines make me queasy for somewhat similar reasons
02:06:16 <glguy> using macros to write your own control structures is an unfortunate workaround obviated in Haskell by laziness and monadic io
02:06:28 <psykotic> wli: blah blah blah. the issue is that when you have to deal with this kind of contextual information, macros become a lot trickier.
02:06:29 <kilimanjaro> fdr-, internal definitions have a well defined semantics and can be trivially converted to internal LETRECs
02:06:29 <lament> Io and Smalltalk seem pretty good at understanding their source code
02:06:29 <glguy> (not specifically the io part)
02:07:04 <fdr-> kilimanjaro: that's true, but something about the non-enclosing definition of the environment bothers me
02:07:14 <fdr-> especially with let and letrec around
02:07:26 <fdr-> it's a very minor picking point
02:07:31 <psykotic> i admit i never liked internal defines in scheme. they're convenient but very unlispy.
02:07:41 <opqdonut> internal defines?
02:07:54 <kilimanjaro> (lambda (x) (define foo ...) (foo x)) for example
02:07:59 <lament> are liskell macros going to be unhygienic?
02:08:03 <opqdonut> àhhh
02:08:05 <opqdonut> those
02:08:14 <kilimanjaro> psykotic, I don't ever use them
02:08:39 <kilimanjaro> I find it is less convenient than using something like let or letrec
02:08:59 <fdr-> I have to say that I do like the somewhat controversial named-let in scheme
02:09:08 <fdr-> it's sugary, but very useful
02:09:10 <psykotic> that's controversial?
02:09:13 <fdr-> well
02:09:15 <kilimanjaro> you know, there is a #scheme
02:09:24 <psykotic> yes, good point. haskell :)
02:09:28 <fdr-> well, I suppose. we can stop talking about that now :)
02:09:43 <glguy> it isn't interrupting anything..
02:10:00 <fdr-> ....also a good point. :mum:
02:10:05 <psykotic> anyway, as for liskell
02:10:12 <kilimanjaro> yea, I just noticed theres been more scheme talk in #haskell than #scheme for the past hour or so
02:10:15 <glguy> and its 2AM center of the universe time ;)
02:10:16 <wli> Works. Deeds. These are what matter.
02:10:20 <glguy> @localtime wli
02:10:20 <lambdabot> Local time for wli is Sat Aug 11 02:12:02 2007
02:10:22 <psykotic> as i understand it, the macros are very low level and while they can access contextual type information, they aren't themselves typed
02:10:31 <wli> kilimanjaro: And more Haskell talk in #scheme than #haskell?
02:11:02 <wli> 11 Aug 02:10:17 ntpdate[8351]: step time server 209.132.176.4 offset -136.199136 sec
02:11:10 <kilimanjaro> wli, yes! noÂ¡
02:11:11 <wli> Talk about drift.
02:11:26 <glguy> my vmware linux image was 3 days off earlier today
02:11:29 <kilimanjaro> psykotic, what sort of macro system are they using?
02:11:34 <fdr-> shrug. it all started when I saw some what seemed to me to be bagging on C programmers
02:11:53 <psykotic> kilimanjaro, i think it's very low level and traditional, except that you can access type information of bindings
02:12:05 <fdr-> so I naturally had to pipe up and disagree with the philosophy of bagging on languages not of one's preferred model.
02:12:07 <lament> non-hygienic? :(
02:12:16 <psykotic> lament: i believe so.
02:12:25 <psykotic> in any case i find it very odd that they don't try to type macros
02:12:33 * glguy sets off to look up "bagging on"
02:12:38 <psykotic> it's really just a preprocessor with access to type info
02:12:46 <lament> how can you type a macro? it IS just a preprocessor thing
02:12:49 <lament> no?
02:12:51 <psykotic> no
02:13:00 <lament> i mean, they are in lisp, no?
02:13:01 <psykotic> you can look at it as an expression transformer
02:13:11 <kilimanjaro> macros are an AST -> AST transformer
02:13:23 <psykotic> for example, given an expression of type A you can give the type of the transformed expression in terms of A
02:13:29 <lament> psykotic: but they don't necessarily transform expressions.
02:13:42 <psykotic> well, you could still do something.
02:13:50 <psykotic> you could have them transform smaller pieces of syntax
02:13:58 <lament> you'd have to split macros into ones that can only work on well-formed expressions, and others
02:14:10 <lament> which i suppose makes a lot of sense
02:14:18 <psykotic> true. but at the very least i'd hope that free-for-all macros would be a subset.
02:14:31 <psykotic> rather than the only way.
02:14:44 <kilimanjaro> i'm sure there would be issues with typed macros and separate compilation
02:15:32 <kilimanjaro> maybe not though
02:15:43 <lament> in any case it's hard to imagine liskell being used much, no matter how awesome it is
02:15:57 <fdr-> lament: I'm inclined to agree. I think Qi has a better chance.
02:16:04 <glguy> of what?
02:16:06 <lament> there's a reason most languages (other than lazyk) offer only one syntax
02:16:10 <fdr-> well, maybe being used now and then
02:16:36 <fdr-> on the other hand...I don't think it's just spread around as an ASDF package, which may be a negation
02:16:50 <glguy> Qi is already cursed, Jon Harrop is involved
02:17:03 <opqdonut> hmm?
02:17:07 <wli> What's Qi?
02:17:09 <fdr-> ah....I never did really like his....style.
02:17:18 <psykotic> Qi is involved with jon harrop?
02:17:24 <psykotic> err, other way around
02:17:39 <wli> I go in for another round of permanent eyeliner tomorrow.
02:17:40 <opqdonut> wli: a lisp-like lang with haskell-like type system and pattern matching
02:17:49 <wli> opqdonut: Oh dear.
02:18:04 <lament> and, apparently, a built-in prolog
02:18:09 <fdr-> as a demonstration
02:18:11 <kilimanjaro> writing a raytracer and then proving how ocaml is superior?
02:18:23 <dolio> It's not exactly haskell-like. I'm not sure I've seen another language with a type system like it.
02:18:27 <fdr-> it _is_ interesting looking
02:18:31 <dolio> It's based on sequent calculus.
02:18:35 <lament> (output "Hello, world~%")
02:19:09 <glguy> jon harrop is a blight on the haskell mailing lists... I can't imagine he does much better in any other community
02:19:20 <fdr-> he's regarded as a troll on c.l.lisp
02:19:21 <kilimanjaro> glguy, can you give an example?
02:19:24 <psykotic> qi code is turdish
02:19:33 <psykotic> it's lisp-ish, but then it has a lot of infix parts.
02:19:40 <fdr-> yes, I don't like how it does break things
02:19:42 <fdr-> I'd like something lighter
02:19:50 <wli> I've got a background project of a mini-interpreter for a language that essentially uses the H98 type system lock, stock, and barrel, but I'm not entirely sure how to track typeclass qualifiers.
02:20:03 <lament> (define factorial 0 -> 1 N -> (* N (factorial (- N 1))))
02:20:12 <psykotic> wli: iirc there is a paper with a complete implementation of h98's type system, if you want to look.
02:20:17 <kilimanjaro> one liners are not allowed in Qi
02:20:22 <lament> oh, really?
02:20:30 <kilimanjaro> I don't know, but they shouldn't be
02:20:33 <kilimanjaro> that looks awful
02:20:36 <lament> hah
02:20:45 <fdr-> not enough parentheses, dammit
02:20:48 <psykotic> it does. and it's very unlispy. you're supposed to use brackets to indicate structure.
02:20:49 <fdr-> :)
02:20:51 <wli> psykotic: I have it, I just don't understand it.
02:21:00 <psykotic> wli: which paper? (title)
02:21:02 <kilimanjaro> psykotic, instead brackets exist solely to scare away people
02:21:13 <wli> psykotic: Mark Jones, "Typing Haskell in Haskell"
02:21:22 <lament> imo that's not as bad as the next wikipedia examle, (defprolog "lots of prolog code inside quotation marks")
02:21:37 <opqdonut> yeah :D
02:21:43 <fdr-> I don't understand some of the scare about parens myself, but I will relent about it
02:21:43 <lament> that's just not cool
02:21:44 <psykotic> wli: i've read it once. i can take a quick look if you'd like another set of eyes to help clarify anything.
02:22:27 <wli> psykotic: Short of an extended walk-through there's not much I'm not going to end up having to do for myself. :(
02:22:48 <psykotic> wli: okay. well, if you get stuck on more specific points, maybe we can help.
02:23:29 <lament> fdr-: brackets don't scare me, but they do look ugly
02:23:35 <psykotic> btw, for any emacs mavens who use inf-haskell.el--
02:23:49 <psykotic> is there a way i can make the tab-based auto-completion of symbols work in the inferior haskell buffer?
02:23:55 <fdr-> lament: well, have to leave it as a matter of taste. they bother me not at all.
02:24:04 <lament> fdr-: programs are first of all for humans to read, so any informatiion extraneous to a human seems out of place
02:24:18 <lament> fdr-: haskell in particular is very good at not having extraneous stuff in the syntax
02:24:23 <opqdonut> yep
02:24:27 <opqdonut> Qi is just horrible
02:24:42 <kilimanjaro> psykotic, just as a farewell gift, here's a Qi gem I dredged from the bottom of the ocean floor: (define intern-all Xs -> (map (/. Elem (COERCE (append [ #\( | (COERCE Elem LIST) ] [ #\) ] ) STRING)) Xs))
02:24:45 <opqdonut> readability- and syntax-wise
02:24:53 <psykotic> kilimanjaro, gott in himmel.
02:24:58 <psykotic> that's some nasty shit.
02:25:01 <wli> psykotic: On the upside, the goals are rather limited. The interpreter essentially intends to use H98 for nothing more than arithmetic operator overloading and monadic IO; user-defined types are out, though it intends to include lists, Maybe, Either, and a few others as builtins.
02:25:20 <fdr-> hmm
02:25:24 <fdr-> extraneous stuff
02:25:37 <opqdonut> wli: yeah who needs named types when you can use tagged tuples
02:25:52 <opqdonut> ("MyType",'a',2)
02:26:04 <fdr-> I don't know. I really like the consistency of lisp. I do have to admit that some paradigms are more painful in idiomatic lisp
02:26:19 <opqdonut> as a bonus, typing errors turn into run-time pattern match failures !
02:26:19 <mauke> lisp feels very inconsistent to me
02:26:21 <wli> opqdonut: It's not intended to be a meaningful language. Just a "bridge of asses" -crossing coding exercise.
02:26:25 <psykotic> kilimanjaro, btw, have you ever tried implementing foldr in terms of foldl?
02:26:32 <opqdonut> wli: sure
02:26:35 <fdr-> common lisp is. I complained about it a lot to myself when moving from Scheme
02:26:38 <lament> fdr-: i agree, i also like the consistency of lisp. But it ain't _pretty_
02:26:41 <kilimanjaro> psykotic, that sounds like a fun time, might as well try
02:26:45 <fdr-> mostly in the insane symbol space, but not in the syntax
02:26:49 <glguy> kilimanjaro: to be honest, I guess I don't have a good example for you, I've been reading back through his postings and they haven't been what I thought
02:27:06 <glguy> kilimanjaro: so either I came ot that conclusion from some email I can't find now
02:27:10 <opqdonut> a misunderstood troll
02:27:25 <glguy> kilimanjaro: or I'm confusing him with someone else
02:27:29 <dolio> @quote JonHarrop
02:27:29 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
02:27:29 <mauke> fdr-: (x y z) does totally different things depending on whether x is let, if, lambda, apply, or user-defined
02:27:30 <psykotic> kilimanjaro, i'll give you the basic idea, which might otherwise be hard. the idea is to design a foldl "scheme" such that a list xs is mapped onto a function which, given a z, gives foldr f z xs
02:27:51 <opqdonut> mauke: well keywords aside it's pretty consistent
02:27:51 <kilimanjaro> glguy, I seem to recall he made a few rude remarks on c.l.l about people who were trying to help him with his benchmarking, though I could be wrong
02:28:04 <mauke> opqdonut: this isn't about keywords, it's about syntax
02:28:21 <fdr-> mauke: no, now it's about semantics.
02:28:26 <glguy> I read something or two by him a while back that got him listed in my trash list
02:28:26 <lament> fdr-: in particular i'm a big fan of significant whitespace because it seems more important to humans than statement delimiters (which is why we indent code)
02:28:33 <mauke> same thing :-)
02:28:36 <glguy> kilimanjaro: so I hadn't seen a lot of his recent stuff
02:28:40 <fdr-> lament: sure, I mean, I guess there are sweet-expressions
02:29:22 <fdr-> but I don't know anyone who seriously uses them
02:29:27 <kilimanjaro> psykotic, are there any rules? No control operators?
02:29:52 <lament> http://www.sweetexpressions.com/ yummy
02:29:58 <fdr-> being also a python fan, I can understand. but it would seemingly undermine some of the simplicity of lisp for me.
02:30:06 <psykotic> kilimanjaro, no. it's fairly straightforward once you fix the types. you can basically implement foldr as a certain foldl followed by a function application.
02:30:16 <lament> fdr-: i'm not arguing for changing the syntax of lisp :)
02:30:55 <fdr-> lament: perhaps not, but it may be sensible to argue for smarter editors
02:31:06 <fdr-> I like the idea of rendering lisp differently for different people
02:31:14 <glguy> lisp is a language that requires a sensible editor
02:31:21 <fdr-> glguy: wholeheartedly agreed
02:31:25 <fdr-> that having been said, my boss uses Pico
02:31:27 <fdr-> terrifying, I say
02:31:32 <fdr-> and he likes it. don't ask me.
02:31:34 <glguy> similarly, so does Java
02:31:43 <lament> fdr-: but having more than one syntax for a language is way too confusing.
02:31:51 <glguy> fdr-: there are people that like ruby too, tastes vary
02:31:57 <psykotic> kilimanjaro, try this scheme: foldr f z xs = foldl f' id xs z where f' = ???
02:32:02 <lament> fdr-: unless you never talk to other programmers
02:32:32 <lament> fdr-: look at how people have holy wars over mere _indentation_
02:33:00 <fdr-> lament: that's true. One of the possibly damaging things to lisp has been its extraordinary flexibility...to the point where it's hard to figure out what everyone's doing.
02:33:16 <fdr-> idioms are tantamount, and those have been slow to advance
02:33:34 <fdr-> for example: I would say most people would say that the iterate package is better than the do or (groan) loop macros
02:33:51 <kilimanjaro> psykotic, something like \x y -> (\z -> z (f x))
02:34:08 <kilimanjaro> err, woops
02:34:42 <fdr-> my personal preference is very rare use of loops in preference for map or tail recursion, but that's what I hear anyway
02:34:51 <lament> fdr-: yeah, in general "there is more than one way to do it" seems lousy for group projects...
02:35:00 <psykotic> kilimanjaro, there's basically only two reasonable well-typed possibilities, given that scheme. one leads to a foldl, one leads to a foldr.
02:35:03 <lament> (yeah, i'm a python fan too :) )
02:35:04 <psykotic> kilimanjaro, so you can try both :)
02:35:06 <fdr-> lament: and in such, I think some facism is worthwhile
02:35:17 <fdr-> it just has to be the right fascism
02:35:18 <lament> fdr-: which is where Java shines :D
02:35:26 <fdr-> yes....yes, that was in the back of my mind
02:36:12 <MarcWeber> I'm getting this wired message when using runhaskell setup.hs copy
02:36:13 <MarcWeber> *** Exception: waitForProcess: does not exist (No child processes)
02:36:15 <lament> i've heard tail recursion is considered unidiomatic in CL?
02:36:20 <MarcWeber> Any idea what might cause this?
02:36:24 <fdr-> lament: yes, it's a holdover from my scheme days
02:36:31 <fdr-> but it's very rare
02:36:33 <MarcWeber> using runhaskell is much faster then compiling it before using
02:36:33 <fdr-> map is much more common
02:36:46 <lament> i could never get used to all the recursion in scheme
02:36:48 <lament> too much extra typing
02:36:50 <glguy> CL isn't really designed to be used in a functional programming style from what I've seen
02:37:14 <glguy> (that's not to say that it can not be used that way)
02:37:19 <fdr-> glguy: you can get pretty close. meat and potatoes work can be quite functional...generally each package has a few global environment things that are prone to infrequent modification (at least when I'm writing)
02:37:37 <takamura> hi
02:37:43 <fdr-> hello there, takamura
02:37:53 <fdr-> I am a heavy user of labels and constructive operators and single-assignment.
02:38:01 <fdr-> (via let)
02:38:58 <kilimanjaro> :t foldr
02:39:01 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:40:00 <lament> fdr-: the other thing about extremely expressive languages, is that because they're so customizable, they're the ones that the antisocial assholes end up using :)
02:40:14 <fdr-> lament: and symbolic AI guys....
02:40:20 <kilimanjaro> \a b -> (\z -> b (f a z))
02:40:26 <fdr-> (don't forget us again!) :)
02:40:38 <lament> fdr-: well, there's at least Forth too
02:40:39 <mauke> @pl  \a b -> (\z -> b (f a z))
02:40:39 <lambdabot> flip (.) . f
02:40:45 <fdr-> yeah. sometimes I like forthiness
02:40:54 <lament> fdr-: and i've heard about Smalltalk, although haven't personally seen any smalltalk assholes
02:41:04 <fdr-> lament: too few.
02:41:08 <lament> (i've heard that it has them)
02:41:17 <psykotic> kilimanjaro, i think that's right, although you mixed two parameters, since foldl takes parameters in a different order.
02:41:19 <psykotic> :t foldl
02:41:21 <fdr-> lament: I think it's gotten better, maybe.
02:41:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:41:40 <kilimanjaro> ohh, woops
02:41:52 <psykotic> > let foldr' f z xs = foldl (\f' x y -> f' (f x y)) id xs z in foldr' (:) [] [1..10]
02:41:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
02:42:11 <fdr-> lament: one thing that was really killing lisp (imo) was the preponderance of proprietary implementations. So many institutions use acl...
02:42:22 <fdr-> and proprietary libraries
02:42:26 <kilimanjaro> I never think in a point-free or curried style
02:42:29 <fdr-> no batteries-included python variant relally hurt
02:42:33 <psykotic> kilimanjaro, one disadvantage is that this isn't exactly equivalent to foldr as far as strictness is concerned.
02:42:35 <psykotic> for example:
02:42:44 <psykotic> > take 10 $ foldr (:) [] [1..]
02:42:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
02:42:53 <fdr-> kilimanjaro: you're not alone...I never liked throwing away the programmer's intended cognitive grouping right away.
02:42:57 <psykotic> > let foldr' f z xs = foldl (\f' x y -> f' (f x y)) id xs z in take 10 $ foldr' (:) [] [1..]
02:43:01 <lambdabot> Terminated
02:43:08 <kilimanjaro> fdr-, don't say those words in this channel!
02:43:15 <fdr-> kilimanjaro: which one?
02:43:30 <fdr-> did I step on a landmine?
02:43:33 <lament> "you're not alone"?
02:43:41 <lament> "cognitive"?
02:43:44 <mauke> a goldmine
02:43:45 <lament> no clue :)
02:43:46 <kilimanjaro> fdr-, you stepped on a lambda buddy
02:43:59 <kilimanjaro> psykotic, yea that was pretty clear to me too
02:44:23 <kilimanjaro> i should practice my haskell-fu just because thinking about types can help out more than random banging of the keyboard
02:44:25 <psykotic> kilimanjaro, it basically has the same strictness as if it was implemented as foldr' = foldl reverse
02:44:28 <psykotic> foldl . reverse, even
02:44:32 <fdr-> :confusion abound:
02:44:44 <kilimanjaro> psykotic, you know, I sort of thought about that one
02:44:49 <kilimanjaro> until you gave the schema
02:45:11 <psykotic> i wonder if you can derive from the other...
02:45:32 <fdr-> so I'm a little confused what is so un-innocent about this position
02:45:47 <psykotic> >let reverse' = foldl (flip (:)) [] in reverse' [1..10]
02:46:00 <kilimanjaro> fdr-, I made nearly the same statement a few days ago and I'm pretty sure I was about to get shanked over the wire
02:46:00 <psykotic> > let reverse' = foldl (flip (:)) [] in reverse' [1..10]
02:46:02 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
02:46:17 <fdr-> kilimanjaro: what was the rationale?
02:46:19 <psykotic> maybe you can use that definition of foldl and use foldl fusion to get the function-based version
02:46:27 <fdr-> If it's enlightening, I could understand it...
02:46:33 <psykotic> err, s/that definition of foldl/that definition of reverse in terms of foldl/
02:46:58 <kilimanjaro> fdr-, that combinators and a point free style forces you to think about abstract structures
02:47:35 <takamura> I have a question: if I do writeIORef myioref x, is the value of x immediately computed, or it is a chunk until myioref is read?
02:48:11 <fdr-> kilimanjaro: well....I guess that's a point.  what's your take?
02:49:15 <kilimanjaro> fdr-, my take is those sort of structures are not any more convenient than writing things out. a reader has to go through and reconstruct the intent anyways
02:49:33 <fdr-> kilimanjaro: okay. well, one supporter here, even if he's from the wrong camp
02:49:39 <Lemmih> takamura: Reading the ioref doesn't force the chunk.
02:49:56 <fdr-> kilimanjaro:  even the wiki makes allusion to this point.
02:49:59 <takamura> oh, yes
02:50:05 <kilimanjaro> fdr-, what wiki?
02:50:12 <fdr-> kilimanjaro: http://haskell.org/haskellwiki/Pointfree
02:50:13 <lambdabot> Title: Pointfree - HaskellWiki
02:50:24 <fdr-> section five.
02:50:43 <kilimanjaro> ahh
02:52:35 <takamura> Thanks, Lemmih. So I can put a big datastructure into x.
02:53:22 <takamura> http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html doesn't say anithing about the memory footprint of IORef, and I couldn't find the information in the wiki.
02:53:23 <lambdabot> http://tinyurl.com/2rgl8s
02:54:34 <fdr-> iono. I'm of the camp that more information doesn't hurt as long as it's not distracting or toggle-able.
02:54:37 <lament> i think the main reason for the use of point-free style is because sometimes it just makes so much sense (map (+1)), and when people see how nice it is in those kinds of situations, they get excited and try to use it everywhere.
02:55:10 <fdr-> lament: I'm reading http://haskell.org/haskellwiki/Pointfree/Combine ; it makes sense to me, but it does seem a tiny bit oblong...
02:55:11 <lambdabot> Title: Pointfree/Combine - HaskellWiki
02:55:20 <fdr-> granted, it is contrived
02:55:33 <fdr-> I guess I would say it seems like a technique to be applied judiciously
02:55:45 <fdr-> ...like all of them realy.
02:55:51 <fdr-> I'm an eternal pessimist on any silver bullet
02:56:44 <mauke> is it me or is combine just liftM2?
02:57:00 <olsner> :t liftM2
02:57:09 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:57:34 <olsner> seems to be, with a different ordering of the arguments
02:57:46 <lament> @pl flip liftM2
02:57:47 <lambdabot> flip liftM2
02:57:52 <lament> er, duh
02:58:18 <eivuokko> @. pl src liftM2
02:58:19 <lambdabot> (line 1, column 1):
02:58:19 <lambdabot> unexpected end of input
02:58:19 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
02:58:22 <eivuokko> Ah, well.
02:58:39 <dolio> @pl \a f b -> (b >>=) . (return .) . f =<< a
02:58:39 <lambdabot> flip (flip . flip liftM2)
02:59:12 <dolio> Huh.
02:59:27 <olsner> @unpl flip (flip . flip liftM2)
02:59:27 <lambdabot> (\ b c f -> c >>= \ k -> b >>= \ j -> return (f k j))
02:59:39 <lament> @unpl flip liftM2
02:59:40 <lambdabot> (\ b c h -> b >>= \ e -> h >>= \ d -> return (c e d))
02:59:55 <mauke> @. redo . unpl pl  \a f b -> (b >>=) . (return .) . f =<< a
02:59:55 <lambdabot> (\ b c f -> do { k <- c; j <- b; return (f k j)})
03:00:27 <lament> anyway.
03:01:09 <olsner> @unpl flip (flip . flip f)
03:01:09 <lambdabot> (\ b c g -> f g c b)
03:01:19 <kilimanjaro> @pl \f' b as -> foldl (flip f') b $ foldl (flip (:)) [] as
03:01:20 <lambdabot> flip flip (foldl (flip (:)) []) . ((.) .) . foldl . flip
03:01:32 <kilimanjaro> psykotic, there you go!
03:01:39 <kilimanjaro> ugliest thing I have seen all day
03:01:42 <kilimanjaro> sure beats Qi
03:02:09 <lament> fdr-: anyway, flip liftM2 is still pointfree :)
03:02:53 <dolio> pl might be doing something wrong there. The type is definitely 'flip liftM2'.
03:02:56 <kilimanjaro> psykotic, albeit most of that is just because foldr has a different type signature from foldl
03:03:34 <dolio> @pl \a f b -> ((b >>=) . (return .) . f) =<< a
03:03:34 <lambdabot> flip (flip . flip liftM2)
03:03:50 <dolio> @pl \a f b -> (b >>=) . (return .) . (f =<< a)
03:03:50 <lambdabot> ((flip . (fmap .)) .) . (>>=)
03:03:57 <fdr-> hmm. pay in mind I'm not as fast at reading haskell, especially when distracted. I also have to look up some of the symbols
03:04:19 <olsner> isn't all that (http://haskell.org/haskellwiki/Pointfree/Combine) just fmap (zipWith (printf ...) [(1::Int)..]) (fmap lines ...)?
03:04:20 <lambdabot> Title: Pointfree/Combine - HaskellWiki
03:04:31 <olsner> no need for even liftM2
03:05:01 <fdr-> I suppose I'll just have to go in and do haskell for a while and put off my numerous side projects.
03:05:39 <fdr-> then again, I've intended to do this for a while, but have been forever stymied by lisp's warm embrace. Forgive me.
03:06:03 <lament> aww
03:06:31 <fdr-> I do admit, I like live-hacking, as psykotic called it. a lot.
03:06:40 <lament> emBRACE indeed
03:06:44 <lament> :)
03:06:46 <fdr-> righto
03:06:51 <fdr-> it's not a lisp-feature per se, but it's something that I really like about that culture
03:06:52 <psykotic> with ghci and emacs you can get a pretty nice workflow going
03:06:58 <fdr-> well, that's reassuring
03:07:08 <lament> with ghci and vim, not so much :(
03:07:23 <psykotic> the m in vim is for music. beep, beep. beep, beep beep.
03:07:29 <dolio> Can't say I have a problem with ghci + vim.
03:07:35 <wli> ugh, what's the arrows way to do \(c, s) -> (f c, g c s) ?
03:07:52 <fdr-> outside of the rather insane dynamic scoping of elisp (according to the graybeards it made sense at the time) emacs > vi. Wait, haven't I heard this argument before? better stop now....
03:07:59 <therp> psykotic: ghci+emacs is nothing compared to emacs+slime+sbcl. but I hope I can change that some day.
03:07:59 <lament> dolio: me neither, especially after having discovered the autocompletion scripts, but you can't exactly run ghci in a vim buffer
03:08:13 <wli> There's some &&&/*** combination involved here.
03:08:13 <psykotic> @hoogle second
03:08:17 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
03:08:20 <fdr-> therp: are you writing swank for haskell?
03:08:26 <psykotic> you need to use &&& and second
03:08:26 <dolio> lament: Yeah, but alt-tab + :r isn't much more work. :)
03:08:36 <therp> fdr: no. but other people are. it's called shim
03:08:43 <fdr-> yes, I tried to visit the site, it seemed slow
03:09:03 <therp> fdr: I was more referring to the incremental recompilations style we see in lisp
03:09:20 <psykotic> oh, hmm
03:09:21 <fdr-> therp: I take it you do work on a major implementation then?
03:09:38 <therp> working on the build infrastructure of GHC really was boring. watching endless recompilations
03:09:51 <lament> fdr-: I've tried using emacs several times, the last of which was actually today. I loaded vimpulse, which is supposed to be the most high-tech implementation of vi functionality. It wasn't very convincing. If they can't get the basics right, what can I expect? :)
03:10:04 <therp> fdr: sorta. my gsoc project is getting GHC to work with dynamic shared libraries. this gave me good insight on what's going on behind the scene
03:10:04 <fdr-> lament: something a lot better ;0
03:11:00 <fdr-> therp: eh? It doesn't it let you load/unload, say, your general .so's, or are we speaking of something more haskelly?
03:11:10 <lament> fdr-: no, i mean, if this particular script (well-maintained and with a long history) doesn't do a very good job, why should i expect other emacs stuff to be any better? :)
03:11:59 <therp> fdr: no. there is no sign of shared objects in GHC at the moment..
03:12:12 <lament> fdr-: this is quite apart from the whole vim vs emacs UI philosophy holy war, which is of course a lot of fun too :)
03:12:28 <fdr-> yes. I would say I like emacs because it's based on lisp. instant win for me.
03:12:53 <therp> fdr: I agree, but emacs lisp is really slow and there is no way of improving it
03:12:53 <fdr-> it comes with a decent text editor, too.
03:13:01 <fdr-> therp: yeah, I agree that elisp is...um...dated.
03:13:12 <therp> fdr: for instance, when using wanderlust on a 50000+ msg newsgroup really takes ages to compile the subject lisp..
03:13:16 <wli> f . fst &&& uncurry g
03:13:25 <therp> er I meant the subject lisT
03:13:59 <fdr-> it may be time for a new emacs, but they claim dynamic scoping is still cool.
03:14:02 <wli> Finally, no warnings.
03:14:08 <lament> fdr-: heh, have you seeen Edwin? (i think is the name)
03:14:09 <therp> fdr: seen climacs?
03:14:22 <therp> fdr: the only problem with climacs is clim.
03:14:33 <fdr-> therp: yes, it looks somewhat dead
03:14:34 <fdr-> I thought
03:14:42 <wli> And still correct results amazingly enough.
03:14:44 <cinimod> @seen bringert
03:14:44 <lambdabot> I haven't seen bringert.
03:14:54 <lament> http://www-swiss.ai.mit.edu/projects/scheme/documentation/user_8.html
03:14:57 <lambdabot> Title: MIT Scheme User's Manual: Edwin, http://tinyurl.com/2lm898
03:15:04 <therp> fdr: don't think so. especially a year ago the project has seen a lot of fresh patches
03:15:23 <fdr-> therp: nifty. But does it have SLIME?
03:15:36 <therp> don't know where they are at the moment. presumably they are held up by some bug in CLIM that no one wants to work on
03:15:48 <therp> fdr: no. I think they connect to swank though..
03:15:52 <mathias> therp, Emacs Lisp is relatively slow, yes. What's the problem with that?
03:16:02 <therp> mathias: that I don't want to wait
03:16:31 <fdr-> my main beef with elisp is dynamic scoping and that it's yet another lisp
03:16:40 * wli blows away all the warnings in Terminfo.lhs and TermCapDecls.hs
03:16:44 <mathias> therp, Emacs display engine needs to be fast enough, for everything else that should go fast, you should use another language.
03:17:13 <mathias> therp, that's what the SLIME people did. (as you know better than me)
03:17:17 <lament> can't you just write a couple of macros to convert all elisp code into CL, after which porting emacs would be trivial? :)
03:17:31 <wli> hemlock?
03:17:51 <fdr-> lament: I'd need at least three.
03:17:52 <fdr-> :)
03:18:06 <therp> mathias: why should I defer to another language? writing an email client within emacs is a perfectly valid idea. the problem is that it does not scale, because of emacs lisp limitations.
03:18:20 <lament> fdr-: sounds like a great weekend project
03:18:28 <fdr-> lament: I'll let you know when it's done. check's in the mail.
03:18:42 <mathias> therp, because ELisp does not scale, you said it yourself.
03:18:48 <wli> therp: Isn't there already an MUA in elisp? I think it's called "VM" or some such.
03:19:05 <mathias> therp, (the implementation)
03:19:17 <mathias> wli, there are multiple
03:19:21 <fdr-> the only thing that I haven't been convinced about emacs is that elisp needs to exist
03:19:22 <therp> lament: the problem is not emulation of elisp on to of CL but the entanglement with the emacs infrastructure. displaying menus, text, getting keyboard input and so on. so the basically the emacs API..
03:19:29 <cinimod> generate doesn't seem to exist in QuickCheck any more
03:19:35 <fdr-> at least, not anymore
03:19:39 <fdr-> it served a purpose
03:19:45 <cinimod> Any idea why and what do use instead?
03:19:51 <lament> could be worse, it could be COBOL!
03:19:56 <wli> I feel good. Terminfo.lhs and TermCapDecls.hs now load into ghci warning-free, and that with -Wall
03:20:00 <fdr-> lament: ah....how true.
03:20:06 <therp> wli: there are several. gnus is the most popular I think.. vm is pretty old.. never used it. I use wanderlust, but with the cvs-ghc it sometimes takes a minute to display the thread list.. quite annoying
03:20:30 <fdr-> so, for the mostly-functional lisp programmer: what's a good toy haskell exercise?
03:20:32 <wli> therp: Database back-end, anyone?
03:20:43 <therp> wli: non-bytecode based language anyone?
03:20:51 <wli> fdr-: Check chapter 9 of YAHT.
03:21:02 <fdr-> bookmarked, and thanks
03:21:11 <lament> i hope that's not the monad chapter
03:21:19 <wli> therp: Unlikely to be a bottleneck.
03:21:21 <therp> actually the only hope would be to hook up another (good) (common) lisp implementation into emacs
03:21:25 <wli> lament: That's precisely what it is.
03:21:32 <lament> oh jeez
03:21:43 <lament> fdr-: do you understand monads? If not, don't read that.
03:21:53 <fdr-> I read up a lot on monads and the underlying category theory
03:21:59 <lament> oh, okay.
03:22:08 <fdr-> I was wondering what this confounded thing was for
03:22:18 <wli> therp: MUA issues are 99% issues with repetitively scanning through repositories of mail messages.
03:22:34 <fdr-> since I heard so much fuss about it
03:22:45 * osfameron finds YAHT utterly incoherent
03:22:47 <therp> wli: true.
03:22:49 <wli> therp: Interpretation vs. compilation will not make a significant difference. It's bloody IO.
03:22:53 <fdr-> but I'm glad I read up on it, I view it as more of a metaphor for a way to structure higher order functions
03:23:06 <fdr-> in a disciplined manner
03:23:19 <wli> fdr-: One of the first things you've said that makes any sense to me. ;)
03:23:26 <wli> osfameron: I hear that one.
03:23:40 <fdr-> wli: sorry if I don't communicate well :(
03:24:20 <fdr-> I mean, there are many things that are not-quite-monads (neighborhood of infinity has covered at least ones) that are distinctly monad-y, so that's why I refer to it as a metaphor
03:24:21 <lament> YAHT is certainly very good at making monads seem much harder than they are
03:24:53 <wli> lament: I had my monad breakthrough doing YAHT's monad transformer exercises.
03:24:57 <fdr-> I also think introducing I/O as the first monad is a serious mistake in retrospect
03:25:07 <fdr-> it's a strange beast
03:25:28 <osfameron> wli: well, I think YAHT's *exercises* are very good - it's just the writing that is baffling
03:25:43 <lament> fdr-: yes, IO is magical, and monads are not magical, and introducing both at once makes it seem as though it's monads that are magical
03:25:53 <wli> osfameron: Oh, I never bothered reading any of the prose. I just did the exercises.
03:25:54 <mathias> Presenting monads as if they are "special" in Haskell is the #1 mistake.
03:26:12 <fdr-> http://metalinguist.wordpress.com/2007/07/21/monads-for-schemerslispers/
03:26:16 <lambdabot> Title: Monads for Schemers/Lispers « Metalinguistic Abstraction, http://tinyurl.com/2j2hr3
03:26:32 <fdr-> feel free to rip that apart pedantically. It's a little writing of mine that I put up after I read up a bit.
03:26:48 <fdr-> it uses the more category-theory style, of (a -> b) -> (m a -> m b)
03:26:52 <fdr-> rather than bind
03:27:01 <wli> This pattern matching pattern guard stuff sure is coming in handy.
03:27:24 <fdr-> I'm sure I got some details wrong, so please submit comments and I'll try to address things. Or just interesting whatevers.
03:27:44 <fdr-> the "watcher" monad at the bottom may be the only one of any interest to see if I really got the concept correct
03:29:42 <fdr-> it's something one would normally use a side-effect for, but now not side-effecty
03:31:03 <Cheery> http://hardware.slashdot.org/hardware/07/08/11/0524250.shtml
03:31:04 <lambdabot> Title: Slashdot | DirectX 10 Hardware Is Now Obsolete
03:31:57 <lament> good night
03:32:02 <fdr-> goodnight
03:32:22 <therp> wli: I just straced my emacs while "Getting an overview..." in my wanderlust on glasgow-bugs. there is a bit of I/O at the beginning, but none in the section that really takes a long time.. => no I/O issue
03:33:24 <d-bug> i've made my first "env monad" all by myself
03:33:42 <d-bug> good to make some progress
03:34:34 <therp> dbug: congrats :)
03:34:43 <therp> now it's time for state :)
03:34:44 <d-bug> thanks
03:35:10 <therp> then IO monad embedding, then CPS ;)
03:35:17 <d-bug> calm down
03:36:28 <wli> therp: Likely search algorithms, then.
03:40:31 <therp> wli: maybe. Of course this particular issue does not support my claim that emacs lisp's byte code is the one to blame.. still I just have that feeling that elisp/emacs always takes an extra nap.
03:40:51 <fdr-> therp: I had a professor who once commented on the subject
03:40:59 <fdr-> therp: "...why not just buy a faster computer"
03:41:17 <fdr-> therp: ...at the time, he was probably right. If concurrency were easier in elisp he'd probably continue to be right.
03:41:35 <therp> fdr: he must have been glad he is still an employee to the university :)
03:42:25 <fdr-> therp: well, he was a schemer, and implementations aren't really as mature...especially fast ones
03:43:08 <fdr-> but his point does make some sense: why claw for 20% gains by making very complicated compilers when a faster machine will double performance in a couple of years?
03:43:49 <fdr-> it's truly an academician's view and is nuanced by excepts and buts, but I believe fundamentally he was correct.
03:43:55 <wli> therp: I've looked into MUA issues because I have a big bad one. They're 100% due to the fact they're approaching database problems with brute-force linear scan over the full dataset.
03:44:08 <therp> because we have a lot of spare mental processing power too. it would be bad allocation of resources if we let them work on Sudoku instead of compilers
03:44:27 <wli> Computers aren't going to get faster forever.
03:44:36 <wli> Computers aren't going to get faster for much longer, even.
03:44:39 <fdr-> wli: perhaps not, but save numerical codes, how fast do you need?
03:45:10 <fdr-> well, his argument is to make things correct and simple before fast, and that's fine for most things. given the recent surge in languages like Python or Ruby...seems like that tradeoff may have been accepted
03:45:11 <wli> fdr-: Buying a faster computer falls down when they're not getting faster anymore.
03:45:17 <fdr-> wli: maybe we should worry about it then :)
03:45:23 <fdr-> until we should get the semantics right.
03:45:51 <wli> fdr-: It's already happening to some extent. The multicore/SMP vs. faster individual core affair.
03:46:05 <fdr-> wli: it's true. and languages will probably adapt a bit.
03:46:24 <fdr-> wli: his statement was some years ago and qualified by these things, but I think his general point was good.
03:46:24 <mathias> wli: computers will continue to go faster and faster on a scale of hundreds of years.
03:46:34 <wli> fdr-: Multicore/SMP has its own rather severe limitations.
03:46:51 <d-bug> wli, what will lure people to buy new computers then? a "best-before" date? :)
03:46:59 <fdr-> wli: but the number of applications that required highly coupled, extremely fast low latency calculations are not the majority
03:47:00 <wli> mathias: Yeah, right. Like there will be computers after the oil and coal run out.
03:47:09 <mathias> wli, by that, I mean that in 80 years a CPU a thousand times the current serial speed will be there.
03:47:22 <wli> mathias: You're dreaming.
03:47:39 <dolio> d-bug: They break eventually. :)
03:47:49 <mathias> wli, no, we haven't reached the limits of computation by far.
03:47:57 <fdr-> wli: given compounding, that's actually somewhat pessimistic
03:48:02 <mathias> wli, in fact, we don't even know what those limits are.
03:48:14 <wli> mathias: Of course not. And we never will. We will hit the limits of practical construction.
03:48:32 <mathias> wli, someone did an analysis based on a light computer, and even that assumes the use of light as a medium.
03:48:36 <wli> And we're getting rather close to that.
03:48:57 <olsner> 80 years? we're only like 20 years away from cpus 1000 times slower that those of today
03:49:19 <flux> wli, how about technology such as clockless cpu's, and as mathias said, optic ones
03:49:30 <d-bug> computing will get more like alchemy, reactions in a chemical soup will tell the future :)
03:49:33 <wli> Oil and coal aren't going to last 80 years, so there's also that.
03:49:58 <mathias> olsner, the techniques to scale up further require knowledge of physics that is not yet understood.
03:50:14 <flux> wli, so after we stop using oil and coal for transportation and energy production (due to costs), development on computers will cease?
03:50:15 <wli> mathias: And what makes you think it ever will be?
03:50:34 <fdr-> meh. I think a thousand times in 80 years, save an absolute catastrophic breakdown, is extremely likely. just a hand-wavey argument.
03:51:10 <fdr-> 80 years is an eternity for our species
03:51:19 <mathias> wli, lots of things, I have no "proof", but it's more than just dreaming.
03:51:37 <wli> flux: No. When it takes more than 1 barrel of oil to pump 1 barrel of oil out of the ground, oil stops. You can generalize to multiple resources.
03:51:50 <mathias> wli, the oil issue is a big problem, yes. I am assuming there will be plenty.
03:51:58 <mathias> wli, (which is probably not true)
03:52:11 <flux> wli, I don't see why it needs to take oil to pump oil, given nuclear power etc
03:52:19 <wli> flux: You don't stop using it for transportation and energy production. You stop using it period.
03:52:38 <mathias> flux, your computer also contains lots of oil.
03:52:58 <flux> wli, why I specifically mentioned those was that before it stops totally, the price of oil has gone up so much that it will not be used for those things, and so does the usage drop
03:53:08 <wli> flux: Nuclear is a joke. Even if it could have helped it's far too late to carry out the conversion to it. There isn't enough oil and coal left to build the nuclear plants.
03:53:16 <mathias> flux, the world runs on oil. All infrastructure is based on it.
03:53:50 <wli> flux: The only price of oil that matters is how much of a barrel of oil it takes to pump a barrel of oil out of the ground. When that hits 1, it's all over.
03:54:53 <flux> wli, are you talking about the cost of retrieving oil or about the physical resources?
03:54:57 <wli> mathias: 80 years is about how long there is left before oil and coal stop completely.
03:55:18 <wli> flux: You're confused by economics.
03:55:45 <ttmrichter> Oh.  I'm sorry.  I thought this was the #haskell channel, not the #peak-oil-will-kill-us-all channel.
03:55:46 <mathias> flux, he means the energy required to get it out of the ground vs the energy that is in the oil you are getting.
03:55:48 <therp> wli: please don't tell anyone he is confused
03:56:39 <flux> mathias, well is the oil being retrieved for the sake of energy, or for the sake of being embedded in other (non-energy) products?
03:56:41 <fdr-> I am also a little confused how this evolved from microprocessors (marginally related) to not
03:56:49 <flux> if the latter, I don't see why it matter how much energy it takes to retrieve oil
03:57:07 <fdr-> well, I guess compiler implementation emphasis and challenges of hardware should be fair game...
03:57:09 <wli> ttmrichter: The argument that the resources to construct science fiction -fast computers is relevant to how fast computers will be in 80 years.
03:57:16 <flux> (obviously the cost of the object we're constructing says how much we can spend on it)
03:57:26 <DRMacIver> fdr-: #haskell doesn't so much wander off topic as orbit it. :)
03:57:30 <wli> ttmrichter: + will not be there
03:57:34 <ttmrichter> wli: And this is relevant to #haskell... how precisely?
03:57:52 <fdr-> DRMacIver: it all makes so much sense now.
03:58:08 <flux> I've heard it been stated that oil itself isn't a requirement to build plastic etc, that such "oil" can be constructed from non-oil resources in laboratories, but I don't know how true that is
03:58:34 <fdr-> ookay. how about this: what do you think about first class environments in languages?
03:58:39 <wli> ttmrichter: Refuting the argument that improving language implementations is not meaningful because computer hardware will continue to get faster indefinitely.
03:58:40 <fdr-> boy howdy, aint that a bag of worms!
03:59:01 <bartw> wli: right
03:59:01 <wli> ttmrichter: And at an exponential rate.
03:59:03 <DRMacIver> I find the channel's lack of close adherence to the topic pleasant actually. The result is more that you've put a lot of Haskell obsessed people in a room and they all talk about Haskell than everyone talking about Haskell because they're not allowed to talk about anything else in here. ;)
03:59:22 <DRMacIver> fdr-: First class environments in what sense?
03:59:50 <fdr-> DRMacIver: basically the complete decoupling from code and data, and neatly (without clever and opaque environments) defeating all static analysis
03:59:58 <fdr-> so, a mapping of symbols to values and some code
04:00:10 <fdr-> basically, in a sense, everything is data...it's turtles, all the way down.
04:00:19 <DRMacIver> So, something like the way scoping works in Javascript but more so?
04:00:47 <fdr-> well, T (the scheme dialect) I believe featured some of these things
04:01:06 <fdr-> unfortunately...it's a bear to search for a little bit....care to guess why? :)
04:01:52 <fdr-> here's a link, if you are not afraid of parentheses
04:01:52 <fdr-> http://www.flownet.com/gat/locales.pdf
04:02:23 <olsner> @help remember
04:02:23 <lambdabot> quote <nick>
04:02:23 <lambdabot> remember <nick> <quote>
04:02:23 <lambdabot> Quote somebody, a random person, or save a memorable quote
04:02:49 <olsner> @remember DRMacIver #haskell doesn't so much wander off topic as orbit it. :)
04:02:49 <lambdabot> Done.
04:03:16 <fdr-> it can be an interesting way to view I/O in a system like Erlang's, which defeats much optimization because you can do things like send closures around
04:03:35 <olsner> a pretty good characterisation of #haskell's relation to its topic, that
04:04:02 <fdr-> but also you could view the loading of an environment to the lightweight context switch made to pump event-driven I/O into a process-based model
04:04:47 <fdr-> it's also one way to make non-hygienic macros less evil.
04:06:02 <fdr-> it could also probably be used for evil
04:06:07 <fdr-> but hey, what else is new
04:07:42 <olsner> evil is just powerful used in the wrong way.. mostly
04:10:28 <fdr-> with that, I must rest...I owe someone three macros that will convert all emacs code to common lisp by monday, or suffer intangible repercussions
04:12:43 <olsner> sounds like something that could easily melt your eyes
04:27:05 <osfameron> ?where paste
04:27:05 <lambdabot> http://hpaste.org/new
04:27:25 <hpaste>  osfameron pasted "stream merging (broken)" at http://hpaste.org/2187
04:27:30 <osfameron> any suggestions?
04:27:49 <osfameron> that's a rewrite of the Perl version in HOP :-)
04:30:01 <osfameron> aha - I didn't want to be putting it in []
04:30:58 <hpaste>  wli annotated "stream merging (broken)" with "what I typically see" at http://hpaste.org/2187#a1
04:31:55 <int-e> you can also use  case a `compare` b of LT -> ..; GT -> ..; EQ -> ..
04:32:36 <osfameron> cute
04:34:40 <olsner> if you say that duplicates in the input should appear duplicated in the output, x < y and x == y are the same case
04:34:54 <mathias> Is there a way to to do nested guards?
04:35:23 <wli> Not meaningfully. You can chain them after a fashion.
04:35:52 <osfameron> yay, merge3 is trivial
04:35:57 <wli> Failure and you have to duplicate it all from scratch.
04:36:08 <olsner> (and you'd only need one check for <=, instead of comparing x to y up to three times)
04:36:44 <wli> How about mergeN? ;)
04:37:18 <olsner> can't you just fold on merge2?
04:37:56 <osfameron> oh,I just did  merge3 a b c = merge a (merge b c)
04:38:01 <wli> I suppose so, yes.
04:38:19 <olsner> foldr1 merge [a,b,c] or something
04:38:21 <osfameron> cos all I wanted to do was the hamming numbers algorighm
04:38:25 <int-e> olsner: you can fold, but to be efficient you should fold in a binary tree like fashion
04:38:32 <osfameron> but you'd need to uncurry them, no?
04:38:46 <osfameron> because it's   merge a b c  not merge [a,b,c]
04:39:01 <wli> I was going to suggest something horrible.
04:39:05 <int-e> olsner: well - I can't say that in general of course because it depends on the input lists.
04:39:40 <wli> I'm not sure there's an operational difference.
04:40:10 <olsner> an n-fold merge should have to compare n values in each step anyways
04:40:55 <olsner> although you might be able to do something clever if you can assume a < b, b < c => a < c
04:40:59 <olsner> whatever that's called again
04:41:08 <roconnor> transitivity
04:41:11 <mathias> Where can I find IdentityT?
04:41:27 <roconnor> @src Control.Monad.Indentity
04:41:28 <lambdabot> Source not found. The more you drive -- the dumber you get.
04:41:38 <roconnor> @sorce Control.Monad.Indentity
04:41:38 <lambdabot> Control.Monad.Indentity not available
04:41:44 <int-e> olsner: merge sort runs in O(n log(n)) time, and you can think of it as a n-way merge of singleton lists
04:41:46 <roconnor> hmm
04:42:18 <int-e> olsner: you need n comparisons to find the first element of course, but you can reuse most of the work for the next one. and so on.
04:42:49 <int-e> at least if equal elements don't occur too often.
04:43:17 <olsner> ah, yes, mergesort is the optimal paranthetisation of fold merge [a,b...]
04:43:21 <int-e> @sorce Control.Monad.Identity
04:43:21 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Identity.hs
04:43:53 <osfameron> what was the cute hack for even and odd numbers defined recursively with succ?
04:44:03 <olsner> or something more like fold merge $ map (:[]) list to produce singleton lists
04:44:35 <int-e> @source Data.List
04:44:36 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
04:44:36 <roconnor> @sorce Control.Monad.Indentity
04:44:36 <lambdabot> Control.Monad.Indentity not available
04:44:43 <roconnor> oh
04:44:47 <roconnor> extra n
04:45:17 <wli> I was going to suggest something like mergeN xss = case groupBy (curry $ uncurry (==) . join (***) head) $ sortBy (comparing head) [xs | xs@(_:_) <- xss] of { [] -> [] ; (yss:ysss) -> head (head yss) : mergeN (map tail yss ++ concat ysss) }
04:45:22 <int-e> olsner: if you haven't seen it, I suggest you look at the mergesort implementation there, it's instructive :)
04:45:40 <osfameron> ah yes, odds = 1 : map succ evens   and  evens = map succ odds
04:46:07 <olsner> int-e: ah, of course ;-) gotta run though
04:46:49 <osfameron> wli: oh, yes, that's much clearer ;-)
04:49:52 <int-e> > let foldb f [x] = x; foldb f xs = foldb f (map_pairs f xs); map_pairs f (x:y:xs) = f x y:map_pairs f xs; map_pairs f xs = xs in foldb (*) [1..100000]
04:49:55 <lambdabot>  2824229407960347874293421578024535518477494926091224850578918086542977950901...
04:50:12 <int-e> in terms of foldb, mergeN = foldb merge
04:50:26 <osfameron> what's foldb?
04:50:32 <int-e> > product [1..100000]
04:50:35 <lambdabot> Terminated
04:50:56 <int-e> a fold that folds lists in a binary tree fashion, see the second to last eval
04:51:19 <wli> > let { mergeN xss = case groupBy (curry $ uncurry (==) . join (***) head) $ sortBy (comparing head) [xs | xs@(_:_) <- xss] of { [] -> [] ; (yss:ysss) -> head (head yss) : mergeN (map tail yss ++ concat ysss) } } in mergeN [[2,4..30],[3,6..30],[5,10..30]]
04:51:21 <lambdabot>  [2,3,4,5,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30]
04:51:51 <osfameron> @src map_pairs
04:51:51 <lambdabot> Source not found. The more you drive -- the dumber you get.
04:52:09 <int-e> (*) is another operation that's cheaper if evaluated that way because it pays off to multiply numbers of comparable size instead of small ones by big ones
04:52:23 <int-e> map_pairs is also defined in that line :)
04:52:34 <osfameron> I don't even understand what it means to fold in a binary tree fashion...
04:52:46 <int-e> (not sure if the name is good, but merge_pairs is also bad and it's not a fold)
04:53:19 <osfameron> oh I see, like n_at_a_time
04:53:22 <wli> list chunking blah blah blah
04:53:23 <int-e> foldb f [a,b,c,d,e] = f (f (f a b) (f c d)) e
04:53:43 <int-e> foldb f [a,b,c,d,e,x] = f (f (f a b) (f c d)) (f e x)
04:53:44 <int-e> etc
04:55:27 <int-e> if you think of f as internal nodes of a tree you get a binary tree (this is true for all folds actually, but the trees of foldl1 and foldr1 are rather degenerated)
04:55:52 <int-e> foldb produces a more balanced tree.
04:56:15 <joelr1> good day folks! what is the name of the haskell toolkit for natural language processing?
04:57:08 <joelr1> grammatical framework toolkit, found it! thanks
04:58:26 <wli> I don't know. There's a certain simplicity to my mergeN that even the binary merge lacks.
04:59:00 <osfameron> it looks like foldb is doing a lot of work (pairing the list every time) it surprises me that it's more efficient!
04:59:41 <wli> It's essentially divide and conquer.
05:01:19 <int-e> wli: sorry but that's horribly inefficient.
05:01:37 <int-e> wli: you sort all lists by head for every element produced
05:02:22 <wli> int-e: Yes.
05:02:46 <osfameron> that's effectively the same as folding over the merge comparison though, isn't it?
05:03:07 <int-e> no. it doesn't share any work that the folding approach shares.
05:04:17 <int-e> (and one of the downsides of sortBy being a merge sort is that it takes O(log(n) n) time even for sorted lists)
05:05:26 <int-e> I've seen a proposal to improve this I wonder what happened to that ... hmm.
05:06:02 <osfameron> ah!  foldb's folding function is (a->a->a)
05:06:17 <int-e> right, and it should be associative.
05:07:26 <int-e> if f is associative then  foldr1 f = foldl1 f = foldb f
05:08:14 <int-e> but of course the actual evaluation is different
05:08:53 <wli> > let { zipWith' _ [] xs = xs ; zipWith' _ xs [] = xs ; zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys ; splitParity [] = ([], []) ; splitParity [x] = ([x], []) ; splitParity (x:y:zs) = let (xs, ys) = splitParity zs in (x:xs, y:ys) ; divConqProd [] = 1 ; divConqProd [x] = x ; divConqProd xs@(_:_:_) = divConqProd $ uncurry (zipWith' (*)) $ splitParity xs } in take 50 (show $ divConqProd [1..10^5]) ++ "..."
05:08:56 <lambdabot>  "28242294079603478742934215780245355184774949260912..."
05:10:27 <wli> int-e: Perhaps easier to understand than foldb
05:10:34 <int-e> wli: divConqProd [] = 1; divConqProd xs = foldb (*) xs  does the same multiplications.
05:10:45 <int-e> no I definitely prefer foldb :)
05:11:05 <int-e> but ymmv
05:11:54 <wli> int-e: Well, obviously foldb doesn't need any sort of list/loop fusion or deforestation. For the purposes of exposition, OTOH...
05:12:04 <roconnor> I have two lists of equal length (or one list of pairs) and I want to make a list of lists [[l1!!0, l2!!1, l2!!2,...],[l2!!0, l1!!1, l2!!2, ...],[l2!!0, l2!!1, l1!!2,..],...]
05:13:06 <wli> roconnor: Not 100% sure what you're trying to get there. Maybe an explanation vs. an expression with ...?
05:13:21 <int-e> > let f l1 l2 = zipWith (++) (inits l1) (tails l2) in f [1,2,3] [4,5,6]
05:13:23 <lambdabot>  [[4,5,6],[1,5,6],[1,2,6],[1,2,3]]
05:13:40 <matthew-_> roconnor: what's the pattern you want with alternating the lists?
05:13:46 <int-e> not quite but close enough - you probably don't want the first and last elements of that
05:13:56 * int-e wonders
05:14:08 <roconnor> [(1,10),(2,20),(3,30)] -> [[1,20,30],[10,2,30],[10,20,3]]
05:14:25 <int-e> ah!
05:14:41 <roconnor> actually now that I start to write a recursive definition, it is becomeing kinda obvious
05:15:12 <matthew-_> you want the cartesian products of the tuples?
05:15:22 <matthew-_> err, no, actually not!
05:15:39 <int-e> well you can't do better than  zipWith (++) (inits l2) (zipWith (:) l1 (tails (tail l2))) asymptotically.
05:15:57 <wli> There are pairs in there, not just lists.
05:15:59 <roconnor> let distrib [] = [[]]; distrib ((x,y):as) = (x:map snd as):map (y:) (distrib as) in distrib [(1,10),(2,20),(3,30)]
05:16:05 <roconnor> > let distrib [] = [[]]; distrib ((x,y):as) = (x:map snd as):map (y:) (distrib as) in distrib [(1,10),(2,20),(3,30)]
05:16:07 <lambdabot>  [[1,20,30],[10,2,30],[10,20,3],[10,20,30]]
05:16:16 <int-e> wli: he said a list of pairs of a pair of lists ;)
05:16:18 <roconnor> that is close
05:16:22 <roconnor> > let distrib [] = []; distrib ((x,y):as) = (x:map snd as):map (y:) (distrib as) in distrib [(1,10),(2,20),(3,30)]
05:16:26 <lambdabot>  [[1,20,30],[10,2,30],[10,20,3]]
05:16:30 <roconnor> perfect
05:16:35 <roconnor> haskell is a genius!
05:16:59 <roconnor> I suppose I should make it a fold?
05:17:28 <roconnor> > foldr (\(x,y) ->  (x:map snd as):map (y:) (distrib as)) [] [(1,10),(2,20),(3,30)]
05:17:29 <lambdabot>   Not in scope: `as'
05:17:38 <roconnor> > foldr (\(x,y) as ->  (x:map snd as):map (y:) (distrib as)) [] [(1,10),(2,20),(3,30)]
05:17:40 <lambdabot>   Not in scope: `distrib'
05:17:52 <roconnor> oh wait
05:18:08 <roconnor> it's not that easy to make it a fold.
05:20:54 <int-e> wli: also, the two list version has the advantage that it shares the tails.
05:21:19 <wli> int-e: Of which algorithm?
05:21:41 <int-e> it's possible in principle that the  map snd as  stuff gets shared - but is there a Haskell compiler that is smart enough to do that?
05:21:54 <int-e> wli: roconnor's
05:23:50 <scook0> is it possible to QuickCheck a function that requires a StdGen (i.e. randomness)?
05:23:56 <roconnor> int-e: that's interesting,  I find the list of pairs more natural becuase it statically ensures they are the same length.
05:24:03 <koala_man> is there a function that takes two arguments and returns just the first or just the second? kind of like 'id'
05:24:16 <scook0> :t const
05:24:18 <roconnor> roconnor: presumably there is a way of rewriting mine to give me sharing.
05:24:19 <lambdabot> forall a b. a -> b -> a
05:24:27 <scook0> :t flip const
05:24:29 <lambdabot> forall a b. b -> a -> a
05:24:42 <scook0> koala_man: ^^
05:24:54 <koala_man> yay, thanks
05:25:08 <mauke> :t curry fst
05:25:10 <lambdabot> forall a b. a -> b -> a
05:25:12 <mauke> :t curry snd
05:25:13 <lambdabot> forall a b. a -> b -> b
05:25:30 <koala_man> why is it called 'const'?
05:25:30 <mauke> :t const id
05:25:32 <lambdabot> forall a b. b -> a -> a
05:25:41 <mauke> because it makes constant functions
05:25:55 <mauke> e.g. (const 42) is the function that returns 42 for all inputs
05:26:05 <koala_man> aha
05:26:18 <roconnor> > (const 42) 7
05:26:19 <lambdabot>  42
05:26:23 <roconnor> > (const 42) undefined
05:26:25 <lambdabot>  42
05:26:26 <anybody> > (const 42) 7 1
05:26:27 <lambdabot>   add an instance declaration for (Num (t -> a))
05:26:34 <anybody> > (const 42)
05:26:35 <lambdabot>  Add a type signature
05:26:39 <scook0> @pl flip const
05:26:39 <lambdabot> const id
05:26:44 <roconnor> > const (const 42) 7 1
05:26:45 <lambdabot>  42
05:26:56 <mauke> > fix (const 42)
05:26:57 <lambdabot>  42
05:27:02 <anybody> hm only unary function
05:27:03 <mauke> fix == unconst
05:27:41 <roconnor> mauke: we should add a rewrite rule: fix (const x) = x
05:27:58 <scook0> @pl fix . const
05:27:58 <lambdabot> id
05:28:27 <int-e> roconnor: I guess the answer is adding another level of indirection - either make a helper that returns a partial tail or make a helper that takes  map snd as  as an argument.
05:28:33 <mauke> @pl const . fix
05:28:33 <lambdabot> const . fix
05:31:00 <int-e> const is useless except in functional programming *g*
05:32:00 <wli> > let { splits [x] = [([],x,[])] ; splits (x:xs@(_:_)) = let ss@(([],q,rs):_) = splits xs in ([],x,q:rs) : map (\(ps,q,rs) -> (x:ps,q,rs)) ss ; roconnor xs = map (\(ps,q,rs) -> map snd ps ++ [fst q] ++ map snd rs) $ splits xs } in roconnor [(1,10),(2,20),(3,30),(4,40),(5,50)]
05:32:02 <lambdabot>  [[1,20,30,40,50],[10,2,30,40,50],[10,20,3,40,50],[10,20,30,4,50],[10,20,30,4...
05:32:11 <roconnor> int-e: that's what I was thinking.
05:32:24 <roconnor> int-e: hardly worth it because my lists have like 5 elements in it ;)
05:33:31 <int-e> fair enough
05:34:06 <wli> oh wow, how the heck does that distrib work?
05:35:57 <wli> I see now.
05:42:31 <roconnor> wli: what you wrote is what I had in my head when I asked the question.
05:42:43 <roconnor> it seemed too complicated for a typical haskell function
05:42:53 <roconnor> so then I started to write a recursive function
05:43:04 <roconnor> the base case is trival (although I had it wrong the first time)
05:43:36 <uttumuttu> hello. i'm typing haskell in vim. is there any faster way to invoke the main function than "ghc myfile.hs" and then "main.exe"?
05:43:43 <roconnor> then I asked myself, given that I know the result for the tail of the list, how can I use that to constructruct the result with one more element added.
05:43:54 <roconnor> the rest then wrote itself.
05:46:38 <roconnor> uttumuttu: ghci myfile.hs, then type main at the prompt?
05:47:02 <psykotic> you can just keep ghci open and use :reload
05:47:16 <roconnor> psykotic: ah right, or :re for short
05:56:20 <Saizan> roconnor: or just :
05:57:38 <mathias> Why doesn't newtype IdentityT m a = IdentityT { runIdentityT :: m a } deriving (MonadTrans)  work?
05:58:06 <mathias> "the representation type has wrong kind"
05:59:50 <Saizan> i think it's because if you try to derive MonadTrans it expect m to be a MonadTrans, but m :: * -> *
06:01:37 <roconnor> @hackage pfp
06:01:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pfp
06:03:22 <chessguy> @type transpose
06:03:24 <lambdabot> forall a. [[a]] -> [[a]]
06:03:56 <chessguy> 'morning ya'all
06:03:59 <chessguy> @type printf
06:04:01 <lambdabot> forall r. (PrintfType r) => String -> r
06:04:03 <mathias> I get "overlapping instances <snip>". I have{-# OPTIONS -fallow-overlapping-instances #-} in the module that uses it.
06:04:44 <mathias> Why doesn't that work?
06:05:07 <balodja> @src transpose
06:05:07 <lambdabot> transpose []             = []
06:05:07 <lambdabot> transpose ([]   : xss)   = transpose xss
06:05:07 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
06:05:19 <balodja> hm, is that lazy?
06:05:22 <chessguy> mathias, "why doesn't my code work?" is a terribly difficult question to answer if you don't paste your code
06:05:54 <Igloo> mathias: You need it in the module that defines the instances
06:06:07 <chessguy> ...unless you're someone like Igloo :)
06:06:16 <mathias> chessguy, right
06:06:20 <mathias> Igloo, thank you
06:11:11 <chessguy> @type head . (!! 3) $ transpose map (iterate (+1)) [1..]
06:11:13 <lambdabot>     Couldn't match expected type `[[a]]'
06:11:13 <lambdabot>            against inferred type `(a1 -> b) -> [a1] -> [b]'
06:11:25 <chessguy> @type head . (!! 3) $ transpose $ map (iterate (+1)) [1..]
06:11:27 <lambdabot> forall a. (Num a, Enum a) => a
06:11:32 <chessguy> > type head . (!! 3) $ transpose $ map (iterate (+1)) [1..]
06:11:32 <lambdabot>  Parse error
06:11:43 <chessguy> > head . (!! 3) $ transpose $ map (iterate (+1)) [1..]
06:11:44 <lambdabot>  4
06:12:02 <chessguy> balodja, looks infinite to me
06:12:07 <chessguy> err, looks lazy
06:12:19 * chessguy is NOT awake yet
06:12:59 * thoughtpolice yawns
06:13:48 <uttumuttu> roconnor & psykotic: thanks fellows
06:13:55 <chessguy> don't get me started, thoughtpolice
06:18:38 <ivant> Cheery, thoughtpolice: http://www.basicinstructions.net/2007/07/how-to-disguise-yawn.html :-)
06:18:40 <lambdabot> Title: Basic Instructions: How to Disguise a Yawn, http://tinyurl.com/3ypznx
06:19:04 <ivant> oops, chessguy, I mean
06:21:13 <thoughtpolice> :)
06:21:14 <chessguy> nice one ivant
06:26:38 <RafaelKbraw> is there some library to parse haskell ?
06:27:25 <thoughtpolice> Language.Haskell.Parser?
06:42:53 <chris2> is there a way to introspect functions, like, get the AST? it doesnt need to be efficient or anything
06:45:14 <scook0> chris2: TH on the function definition might be sufficient, depending on what you want to do
06:45:36 <scook0> though probably not :/
06:45:38 <chris2> can that work on runtime?
06:45:53 <scook0> not that I know of
06:46:08 <chris2> okay
06:46:33 <scook0> what are you trying to achieve?
06:47:20 <chris2> someone said haskell deals with functions as well as perl does with strings
06:47:27 <chris2> and i'm looking for a gsub ;-)
06:47:47 <mauke> for what?
06:48:18 <chris2> nothing specific atm, but it would be cool if it was possible
06:48:24 <mathias> Code involving RealWorld is quite subtle.
06:48:27 <mauke> what do you mean by "gsub"?
06:49:12 <chris2> the main reason because i ask is that i feel like writing higher-order code is pretty much a blackbox
06:49:44 <pejo> chris2, blackbox in what way?
06:49:46 <chris2> you see the input and the output, but the actual code is not visible, or introspectible
06:50:09 <mauke> that applies to all code
06:50:18 <chris2> when dealing with ordinary data, you just can show the structure and see if the transformations did what you wanted them to do
06:50:34 <mathias> mauke, what do you mean by "all code"?
06:50:37 <scook0> yeah, functions are sort of inherently non-introspectible
06:50:41 <desp> @hoogle foldWhile
06:50:42 <lambdabot> No matches found
06:50:55 <mathias> mauke, all "Haskell code"?
06:50:55 <desp> is there a generalization of takeWhile in the library?
06:50:57 <mauke> mathias: there's always a level you can't see
06:51:14 <mauke> e.g. you don't know what perl's split operation really does
06:51:19 <mauke> you can only see its behavior
06:51:28 <chris2> true
06:51:34 <roconnor> takeWhile in the standard library is wrong.  The predicate should be on lists, not elements. :/
06:51:41 <mathias> mauke, you are turning this into a philosophical issue.
06:51:52 <chris2> but you see the string before, and the list after. with functions, you see a->a and a->a. great help ;)
06:51:55 <desp> robreim: huh
06:51:56 <desp> er.
06:51:59 <desp> roconnor: huh?
06:52:07 <roconnor> @t takeWhile
06:52:08 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
06:52:10 <mathias> Ultimately, you cannot see how the universe works.
06:52:14 <scook0> I find, though, that most higher-order functions are almost entirely defined by their type
06:52:14 <mauke> chris2: yeah, the way to "inspect" functions is to apply them to arguments
06:52:14 <roconnor> @type takeWhile
06:52:16 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:52:23 <desp> roconnor: yes, I know what it does
06:52:34 <desp> roconnor: I find it very useful to be able to do takeWhile (< 100) primes, for instance
06:52:39 <chris2> it just would be cool if one could reify them to real code again
06:52:41 <roconnor> That should be ([a] -> Bool) -> [a] -> [a].  At least it would be if I were writing the library.
06:52:42 <mathias> mauke, there are various environments where you can see the exact code the function you are given looks like.
06:52:56 <ivant> roconnor, then it'd need to build new lists every time. O(n^2) or something like that
06:53:10 <roconnor> takeWhile ((<100) . head) primes
06:53:23 <desp> roconnor: and that is what, more elegant? please
06:53:31 <scook0> given the source of a HOF, it should in principle be possible to see what it looks like after argument substitution
06:53:43 <desp> roconnor: what use case do you have in mind?
06:53:43 <scook0> though I don't know of any tool that actually does that
06:53:44 <mathias> mauke, via a combinator library one could reify the code in Haskell too.
06:53:58 <mathias> mauke, (to the type level)
06:54:01 <desp> ivant: why isn't takeWhile built using a general foldWhile, though?
06:54:10 <roconnor> desp: then we could do takeWhile' (not . ("foo" isPrefix)) list
06:54:17 <chris2> otoh, i dont know any language (except maybe a version of mzscheme used for teaching?) that can do it
06:54:21 <roconnor> `isPrefix`
06:54:32 <ivant> desp, I have no idea, although that sounds very reasonable
06:55:14 <mathias> @pl do a <- b ; a
06:55:14 <lambdabot> (line 1, column 11):
06:55:14 <lambdabot> unexpected ";"
06:55:14 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
06:55:17 <desp> ivant: I've ran into the problem using a list of lists, built using takeWhile, as a control mechanism replacing a nested for loop
06:55:29 <desp> ivant: it just requires insane amounts of space
06:55:44 <mauke> join b
06:55:49 <mathias> @pl b >>= id
06:55:49 <lambdabot> join b
06:56:06 <mauke> @src join
06:56:06 <lambdabot> join x =  x >>= id
06:57:15 <pejo> chris2, there aren't many functions of type a -> a, and the type isn't expressive enough for full specification.
06:57:36 <chris2> it was just an example
06:57:48 <chris2> make it a->b
06:57:48 <ivant>  desp, well, takeWhile is linear in space use (because it needs to build a new list), so if you're not careful it may cause a problem
06:58:04 <desp> of course
06:58:14 <desp> it's just that it appears to be a preferred control mechanism in Haskell
06:59:06 <desp> looping over lists of input
06:59:13 <roconnor> ivant: but takeWhile is a good producer right?
06:59:20 <roconnor> ivant: .. and a good consumer.
06:59:41 <roconnor> so presumably it usually runs in constant space.
07:00:11 <mathias> Is it possible to define an instance Foo (Bar RealWorld) IO ?
07:00:33 <ivant> roconnor, if by "good" you mean that optimizer can easily see that it doesn't need to really build a new list, then I presume, yes
07:01:05 <roconnor> ivant: I think there is some techinical definition for good, but I'm not sure what it is off hand.
07:01:34 <roconnor> mathias: That looks like you need to use GHC extensions... or make Bar RealWorld into a newtype.
07:01:40 <ivant> roconnor, oh, however if you're talking about the takeWhile' :: ([a] -> Bool) -> [a] -> [a], than that may not be the case
07:01:47 <roconnor> mathias: wait, what are you doing with RealWorld?
07:01:58 <mathias> roconnor, stToIO
07:02:06 <ivant> roconnor, because ([a]->Bool) may need to traverse the whole list till the end
07:02:27 <roconnor> ivant: indeed, but it should still be a good producer.
07:02:27 <ivant> s/than/then/
07:04:29 <mathias> roconnor, I am not sure what your suggestion means.
07:04:34 <matthew-_> ghc --make uses timestamps on files to determine whether or not they've changed, doesn't it?
07:05:15 <eivuokko> Yes.
07:05:31 <eivuokko> Those checks don't test files from installed packages.
07:06:21 <matthew-_> gah. it's just as well there's no evidence to suggest that time stamps may in fact be the worst way to determine if a file has changed or not.
07:08:24 <thoughtpolice> is cabal-install usable? while wget is nice more automated package management would be awesome (I'm a lazy sod.)
07:17:37 <desp> @djinn (a -> Bool) -> (b -> a -> b) -> b -> [a] -> b
07:17:37 <lambdabot> f _ _ a _ = a
07:17:43 <desp> weak
07:18:45 <ivant> @seen Igloo
07:18:45 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 1h 12m 51s ago.
07:18:51 <Igloo> Hello
07:18:59 <ivant> hi
07:19:55 <ivant> Igloo, I've heard rumours that mtl is very slow when installed from Debian repository, because it is not built with -O2 or whatever. Is it true?
07:19:57 <kpreid> desp: djinn doesn't do lists
07:20:17 <SamB_XP> ivant: of late, yes
07:20:42 <Igloo> I haven't measured performance, but I think it's built non-optimised, yes
07:20:47 <SamB_XP> or, at least, it isn't built with optimization
07:20:57 <ivant> so, is there some particular reason for it being built without optimizations?
07:21:01 <SamB_XP> which means no inlining
07:21:06 <SamB_XP> ivant: it was cabalized
07:21:25 <Igloo> Current Cabal doesn't support doing so easily. 6.8.1's will
07:21:25 <SamB_XP> and removed from the core packages
07:22:42 <SamB_XP> incidentally, is there any particular reason why mtl 1.0.1 was not on hackage last I checked?
07:22:48 <ivant> Igloo, I remember there was an option in .cabal file which allowed to give the ghc options, is there?
07:23:06 <mathias> I get an IO (ST s Foo) value, how can I pass that ST value to runST?
07:23:18 <ivant> Igloo, or is there some other problem?
07:23:20 <mathias> I get Inferred type is less polymorphic than expected
07:23:20 <mathias>       Quantified type variable `s' is mentioned in the environment:
07:24:02 <SamB_XP> ivant: that involves editing the cabal file
07:24:03 <Igloo> SamB_XP: It doesn't build with 6.6.1's Cabal out of the box
07:24:15 <mathias> It seems the only way to make it work is to use unsafe operations.
07:24:15 <SamB_XP> Igloo: oh?
07:24:29 <Igloo> ivant: There is, but I didn't got through all the libraries adding it
07:24:37 <SamB_XP> mathias: you lost a "forall s" somewhere
07:25:13 <mathias> SamB_XP, stToIO does that, I guess.
07:25:31 <SamB_XP> mathias: hmm?
07:25:40 <mathias> noj, that doesn't make sense.
07:26:29 <SamB_XP> well, I *think* you lost your forall
07:26:33 <ivant> Igloo, I see. So, is getting the debian source and changing the options a best idea for me (if I want mtl optimized on my machine)?
07:26:54 <SamB_XP> mathias: what does it say about the environment?
07:27:09 <mathias> SamB_XP, I meant that what I said, didn't make sense
07:27:27 <Igloo> ivant: Yup
07:28:13 <ivant> Igloo, thanks
07:28:19 <SamB_XP> ivant: or alternatively you could retype the whole library from memory/typechecking
07:28:43 <ivant> SamB_XP, what do you mean?
07:28:58 <mathias> SamB_XP,  This is the type: x :: (Vars s t, A (B s) (Z s (K s b)) ()  t) =>  IO (t (P s () ()))
07:29:12 <SamB_XP> ivant: I'm mostly kidding, but you could almost recreate the MTL from memory ;-)
07:29:17 <mathias> SamB_XP, I would like to extract the (t  ...) from it and run it.
07:29:26 <SamB_XP> mathias: hmm.
07:29:27 <mathias> SamB_XP, (in runST)
07:29:38 <SamB_XP> I'm pretty sure you don't want "Vars s t"
07:29:53 <ivant> SamB_XP, oh, I see :-). I was confused by the "retype" word
07:30:05 <SamB_XP> mathias: unless that hs nothing to do with ST
07:30:08 <mathias> SamB_XP, I can eliminate it, but that will break other code.
07:30:14 <SamB_XP> s/hs/s/
07:30:24 <SamB_XP> arg.
07:30:34 <SamB_XP> s/hs/s has/ instead
07:31:33 <SamB> mathias: not certain though
07:31:41 <SamB> where does the s come from?
07:32:23 <ivant> Igloo, (looking at mtl.cabal) so, I only need to change the ghc-options field here, or do I miss some other important action here?
07:32:24 <mathias> SamB, the s comes from an STArray s
07:32:35 <SamB> mathias: okay
07:32:45 <mathias> SamB, I mean STRef
07:32:50 <SamB> so what is Vars?
07:33:23 <Igloo> ivant: That's it
07:33:42 <hpaste>  mathias pasted "Vars" at http://hpaste.org/2189
07:34:15 <mathias> SamB, it's that
07:34:19 <SamB> I see
07:34:43 <SamB> and what is the exact error message when you try to runST?
07:35:04 <SamB> you only gave part of it
07:37:14 <kjdf> is it possible to use GADT together with record selectors?
07:37:15 <hpaste>  mathias annotated "Vars" with "Error message" at http://hpaste.org/2189#a1
07:39:49 <kjdf> ok, found it
07:39:57 <desp> @let foldlWhile p f = loop where loop z [] = z ; loop z (x : xs) = if p x then loop (f z x) xs else z
07:40:01 <lambdabot> Defined.
07:40:06 <desp> @let takeWhile' p = reverse . foldlWhile p (flip (:)) []
07:40:09 <lambdabot> Defined.
07:40:13 <desp> > takeWhile (< 10) [1..]
07:40:14 <lambdabot>  [1,2,3,4,5,6,7,8,9]
07:40:17 <desp> > takeWhile' (< 10) [1..]
07:40:19 <lambdabot>  [1,2,3,4,5,6,7,8,9]
07:47:18 <scook0> @pl partition f = (MkISet *** MkISet) . liftPS IS.partition f
07:47:18 <lambdabot> partition = fix ((((MkISet *** MkISet) . liftPS IS) .) .)
07:48:57 <mathias> SamB, ?
07:50:18 <desp> is it possible to use guards in single-line definitions?
07:52:58 <desp> @let foldrWhile p f z = loop where loop [] = z ; loop (x : xs) = if p x then f x (loop xs) else z
07:53:04 <lambdabot> Defined.
07:53:09 <desp> @let takeWhile'' p = foldrWhile p (:) []
07:53:11 <lambdabot> Defined.
07:53:18 <desp> > takeWhile'' (< 10) [1..]
07:53:19 <lambdabot>  [1,2,3,4,5,6,7,8,9]
07:53:24 <desp> I think that's pretty nice
07:54:17 <desp> any comments?
07:55:08 <hpaste>  desp pasted "fold*While" at http://hpaste.org/2190
07:55:13 <SamB> mathias: oh, sorry, my mom made me make kool-aid and get a start on some iced tea
07:55:43 <Toxaris> > let f x | x < 0 = -1 | x > 0 = 1 | otherwise = 0 in f 42 -- single line guards like this, desp?
07:55:45 <lambdabot>  1
07:56:00 <desp> Toxaris: oh, so that does work. hm.
07:56:35 <desp> Toxaris: do you have any comments about fold*Whiles?
07:57:32 <desp> I think that's a pretty good replacement for the C-style for-loop-with-a-break
07:57:36 <SamB> mathias: why are you building an ST computation in IO anyway?
07:57:39 <mathias> How expensive is an unused WriterT?
07:57:57 <SamB> mathias: unused?
07:57:59 <mathias> SamB, I use it to trace execution reliably.
07:58:08 <SamB> hmm.
07:58:18 <mathias> mathias, as a replacement for IO (putStrLn)
07:58:24 <mathias> SamB, as a replacement for IO (putStrLn)
07:58:33 <mathias> SamB, that's why I am combining IO and ST
07:58:45 <ivant> wow, adding -O2 -funfolding-use-threshold=16 -optc-O3 to the mtl build really made a difference in my mostly naive StateT implementation of the UM
07:59:10 <SamB> mathias: I don't think that type signature on stComp is going to help you any...
07:59:14 <chessguy> SamB, why not use Debug.Trace?
07:59:36 <ivant> 1.5 times speedup for free :-)
07:59:53 <desp> ivant: UM? cool.
08:00:03 <SamB> ivant: how is the bitshifting?
08:00:23 <mathias> SamB, neither do I.
08:00:26 <ivant> SamB, bitshifting?
08:00:33 <mathias> SamB, I was just trying some things
08:00:35 <SamB> ivant: do you skip that?
08:00:42 <wli> ivant: What happens if you use -funfolding-use-threshold=1000 -funfolding-creation-threshold=1000 to the MTL build?
08:00:46 <SamB> probably wize ;-)
08:00:50 <desp> :D
08:00:54 <SamB> wise?
08:00:56 <ivant> SamB, what is bitshifting?
08:01:12 <ivant> wli, I can try
08:01:16 <SamB> ivant: oh, you used div?
08:01:36 <wli> ivant: Don't forget the -O2 -optc-O3 too
08:01:39 <SamB> ivant: or what?
08:01:57 <wli> ivant: might even want to try -optc-funroll-all-loops
08:02:07 <SamB> how do you extract the various fields from the ... er ... instruction word
08:02:11 <ivant> SamB, you mean, for Div UM operation?
08:02:52 <SamB> you know how each instruction has an opcode field and A,B, and C fields?
08:03:04 <ivant> SamB, right
08:03:13 <Toxaris> desp: hmm. is foldrWhile p == head . dropWhile (not . p) . scanr ?
08:03:36 <ivant> SamB, oh, you ask, whether I do shift bits to get the parts of the instruction
08:04:15 <desp> Toxaris: the whole point of writing those folds is avoiding building garbage lists :)
08:04:32 <ivant> SamB, oh yes, I do, and also I think I do not even bitshift to get the opcode (simple .&. is enough to get it)
08:05:01 <desp> Toxaris: you might also say foldrWhile p = head . takeWhile p . scanr, no?
08:05:21 <Toxaris> desp: wich garbage list?
08:05:45 <ivant> wli, so, which set of ghc options do you suggest to try out?
08:05:56 <SamB> ivant: how does your UM sandmark?
08:06:37 <Toxaris> desp: I think it is: foldrWhile p == last . takeWhile p . scanr == head . dropWhile (not . p) . scanr
08:07:11 <wli> ivant: No idea. I just heard that the super-duper-inlining stuff makes wild CPS code go faster.
08:07:25 <ivant> SamB, it doesn't finish it yet. there is a known performance problem with array allocation (array index generation), and I know how to fix it, but I didn't have enough time to do that yet
08:07:36 <desp> Toxaris: actually, that doesn't typecheck
08:07:41 <SamB> ivant: index generation?
08:07:58 <SamB> @hoogle unsafeIndex
08:07:59 <lambdabot> No matches found
08:08:24 <ivant> SamB, yep, when I generate an index for an array, I do a tree lookup to find the first unused index. It is O(log n) of the number of arrays
08:08:50 <ivant> SamB, removing the tree would greatly improve the speed and would allow the sandmark to finish in reasonable time
08:09:17 <SamB> ivant: I think it's not removing the tree that you want necessarily
08:09:37 <desp> Toxaris: you're right about the head/last, though...
08:09:44 <SamB> how is finding the first unused index O(log n)?
08:10:04 <ivant> SamB, after coding the Haskell version (in 4 or 5 different ways), I tried to implement the UM in D (and used the same design)
08:10:59 <SamB> I thought looking something up in a tree was O(log n)...
08:11:05 <ivant> SamB, it performed poorly when I tried to be smart with array index generation, but when I simply introduced the max_index counter, it started to perform quite well
08:11:21 <ivant> SamB, I don
08:11:49 <SamB> have you considered a freelist or something like that?
08:12:34 <ivant> SamB, I don't remember the details right now (I did it more than a month ago), but the problem, as I recall it now, was in using the tree to find the free index, and that means log n multiplier
08:12:42 <ivant> oh, or even n log n
08:12:53 <desp> Toxaris: foldlWhile p f z xs = last . scanl f z . dropWhile (not . p)
08:12:54 <SamB> that sounds more like it ;-)
08:12:55 <ivant> SamB, of course I did :-)
08:13:08 * SamB did the same thing in his Haskell UM
08:13:29 <SamB> for some reason instead of improving my Haskell UM I wrote a 32-bit-only UM in C
08:13:45 <ivant> SamB, the better strategy yet is to increase a counter and return it
08:14:13 <SamB> what do you do when you've allocated all possible 32-bit numbers?
08:14:32 <Toxaris> desp: hmm, sounds unlikely for me
08:14:46 <ivant> SamB, it would be a very long execution, if you really want to allocate 4 billions of arrays
08:14:51 <ivant> :-)
08:15:04 <desp> @let flw p f z = last . scanl f z . dropWhile (not . p)
08:15:10 <lambdabot> Defined.
08:15:10 <SamB> ivant: are you sure?
08:15:10 <desp> @let frw p f z = head . scanr f z . takeWhile p
08:15:13 <lambdabot> Defined.
08:15:26 <desp> @let tw p = frw p (:) []
08:15:29 <lambdabot> Defined.
08:15:35 <desp> > tw (< 10) [1..]
08:15:36 <lambdabot>  [1,2,3,4,5,6,7,8,9]
08:15:41 <desp> Toxaris: there you go
08:15:46 <SamB> ivant: so what does the code look like for your bitshifting?
08:15:47 <ivant> SamB, anyway, it is enough to unpack the codex and finish the sandmark :-)
08:16:12 <desp> Toxaris: but it makes no sense to define takeWhile using a fold that uses takeWhile
08:16:23 <SamB> the output code, I mean
08:16:55 <desp> Toxaris: and the problem with this approach is that you have to walk the whole list
08:17:27 <Toxaris> desp: should the test be applied to elements of the input list, or to the result?
08:17:35 <Toxaris> deps: your hpaste applies the test to elements of the input list
08:17:41 <desp> yes, the input list
08:17:50 <desp> that's the whole point :)
08:18:21 <Toxaris> so I misread your hpaste the first time, because my version applies to test to the intermediate result
08:18:36 <ivant> SamB, something like getRegA !w = getBits 6 0x7 w where getBits !shift !mask !w = (w `shiftR` shift) .&. mask
08:18:49 <desp> Toxaris: it doesn't typecheck, have you tried it?
08:19:11 <Toxaris> desp: nope, not tried. it doesn't typecheck because i abstracted from more then one arg by using (.) wich is not possible, of course
08:19:14 <dynamix> do i need cygwin to build hackage packages?
08:19:34 <ivant> getBits is, of course, shared between all the operations (getRegB, getRegC, getRegXA)
08:19:43 <desp> @let toxFoldrWhile p == last . takeWhile p . scanr
08:19:44 <lambdabot>  Parse error
08:19:49 <desp> @let toxFoldrWhile p = last . takeWhile p . scanr
08:19:49 <Toxaris> desp: so your foldrWhile p f x = foldr f x . takeWhile p
08:19:50 <lambdabot> Couldn't match expected type `[a]'
08:20:02 <Toxaris> desp: first filter the input list, then fold
08:20:07 <Toxaris> desp: but fused in one function
08:20:40 <ivant> SamB, it is possible to be even more smart to do the bitshifting, but I didn't bother, because the profiling showed that the array allocation is sucking 80% of time (remember the tree :-) )
08:20:43 <desp> Toxaris: hmm.
08:21:11 <Toxaris> desp: but untested again :)
08:21:46 <Toxaris> > let foldrWhile p f x = foldr f x . takeWhile p in foldrWhile (< 10) (:) [] [1..]
08:21:48 <lambdabot>  [1,2,3,4,5,6,7,8,9]
08:21:54 <Toxaris> desp: here you go
08:22:04 <osfameron> ?where nub
08:22:04 <lambdabot> I know nothing about nub.
08:22:11 <desp> okay, so the foldrWhile doesn't save anything
08:22:19 <osfameron> @src nub
08:22:19 <lambdabot> nub = nubBy (==)
08:22:26 <osfameron> but where?
08:22:38 <Toxaris> desp: since foldr (:) [] == id, we arrive at takeWhile' == takeWhile :)
08:22:44 <desp> no, wait, it does save.
08:22:48 <desp> @src takeWhile
08:22:48 <lambdabot> takeWhile _ []                 =  []
08:22:49 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
08:22:49 <lambdabot>                    | otherwise =  []
08:23:01 <desp> Toxaris: takeWhile rebuild the list prefix
08:23:05 <desp> rebuilds*
08:23:51 <Toxaris> desp: yes, foldr f x . takeWhile p   needs intermediate cons cells
08:24:16 <desp> right.
08:24:27 <desp> so, this can be avoided for other uses of fold*While
08:24:33 <Toxaris> desp: but from my (limited) understanding of list fusion, the compiler optimizes it away
08:24:45 <desp> hmm
08:25:00 <Toxaris> desp: at least list fusion *should* optimize it away :)
08:25:08 <desp> let me show you an example
08:25:31 <Toxaris> desp: if not, list fusion has to be optimized
08:25:45 <Ben`> I can do "a +++ b = a + b", but can I do something like "a qqq b = a + b"?
08:26:05 <hpaste>  desp pasted "takeWhile^2" at http://hpaste.org/2191
08:26:08 <Toxaris> Ben`: you can use backquotes to use a function as operator
08:26:10 <ivant> Ben`, you can do "a `qqq` b = a + b", I think
08:26:17 <Ben`> thanks
08:26:34 <Toxaris> > let a `plus` b = a + b in 39 `plus` 3
08:26:36 <lambdabot>  42
08:26:42 <desp> Toxaris: I'm hoping to rewrite this to be faster; I'll see in a moment if I was right
08:26:47 <desp> Toxaris: currently it takes about 30 seconds
08:26:56 <ivant> > let 2 `plus` 2 = 5 in 2 `plus` 2
08:26:57 <lambdabot>  5
08:27:06 <desp> but if the compiler really optimizes this away, then color me impressed
08:27:59 <ivant> desp, does this "color me convinced" phase come from quantum phisics?
08:28:15 <ivant> s/phisics/physics/
08:30:16 <desp> ;)
08:31:01 <desp> ivant: no, I don't think so. it's just an idiom.
08:31:30 <desp> wasn't it "flavor" in quantum physics?
08:31:52 <pejo> desp, the code you pasted is basically "print (sum [1..20161])"?
08:32:07 <pejo> Doh, "- sum zs". Sorry.
08:32:17 <desp> pejo ;)
08:32:32 <desp> oh, factorSum is missing from the paste
08:32:47 <hpaste>  desp annotated "takeWhile^2" with "Prime.hs" at http://hpaste.org/2191#a1
08:35:36 <ivant> wli, I recompiled the mtl library with -Wall -O2 -funfolding-use-threshold=256 -funfolding-creation-threshold=256 -optc-O3 -optc-funroll-all-loops
08:35:52 <wli> ivant: any good?
08:36:11 <ivant> wli, there is no discernable difference to -O2 -funfolding-use-threshold=16 -optc-O3
08:36:23 <ivant> wli, (on my naive UM)
08:36:29 <kjdf> (Maybe a) is monoid, yes?
08:37:22 <ivant> wli, clearly, there may be some difference, but I believe that by no means would it mean an order of magnitude speedup (or even almost an order of magnitude, as I had 1.5 times)
08:37:22 <wli> ivant: okay
08:37:46 <mathias> Why is there no Monoid instance for Doc?
08:38:03 <ivant> @instances Monoid
08:38:11 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
08:38:17 <ivant> wow!
08:38:22 <ivant> Endo a!
08:38:37 <ivant> oh, gosh, sorry, guys
08:38:47 <desp> hehe.
08:38:58 <desp> @hoogle Endo
08:38:59 <lambdabot> System.Win32.File.c_SetEndOfFile :: HANDLE -> IO Bool
08:38:59 <lambdabot> System.Win32.File.setEndOfFile :: HANDLE -> IO ()
08:39:13 <desp> I think someone has been messing with the bot ;)
08:39:25 <ivant> @index Endo
08:39:25 <lambdabot> bzzt
08:39:36 <ivant> @source Endo
08:39:36 <lambdabot> Endo not available
08:39:54 <ivant> @source Monoid Endo
08:39:54 <lambdabot> Monoid Endo not available
08:39:59 <ivant> @source Monoid (Endo a)
08:39:59 <lambdabot> Monoid (Endo a) not available
08:40:44 <Toxaris> desp: maybe takeWhile would need to be rewritten using an unfold to allow fusion or what do i know
08:41:17 <desp> I don't think I know anything about list fusion
08:43:25 <Toxaris> desp: the basic idea is to exploit stuff like map f . map g == map (f . g), but with more general combinators then map to capture more use cases
08:43:39 <desp> ah
08:44:09 <Toxaris> so a unfold next to a fold may be combined to yield, hmm, whatever
08:46:00 <Toxaris> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
08:46:01 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
08:46:28 <desp> I'll read that
08:47:28 <mathias> How can I derive MonadTrans for: newtype XT x m result = XT { state:: StateT x (WriterT Doc m) result}?
08:47:34 <ivant> @dict deforestation
08:47:34 <lambdabot> Supported dictionary-lookup commands:
08:47:34 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
08:47:34 <lambdabot> Use "dict-help [cmd...]" for more.
08:47:47 <ivant> @foldoc  deforestation
08:47:49 <lambdabot> *** "deforestation" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
08:47:49 <lambdabot> deforestation
08:47:49 <lambdabot>  
08:47:49 <lambdabot>         <programming> A technique invented by {Phil Wadler} for
08:47:49 <lambdabot>         eliminating intermediate data structures built and passed
08:47:51 <lambdabot> [4 @more lines]
08:47:55 <ivant> @more
08:47:55 <lambdabot>         between composed functions in {function languages}.
08:47:55 <lambdabot>  
08:47:57 <lambdabot>         (1997-06-21)
08:47:59 <lambdabot>  
08:48:02 <desp> heh
08:48:25 <desp> @skipws
08:48:25 <Toxaris> lambdabot knows everything :)
08:48:25 <lambdabot> Unknown command, try @list
08:51:05 <ivant> @foldoc co-structure
08:51:06 <lambdabot> No match for "co-structure".
08:51:10 <ivant> hehe
08:51:19 <desp> @foldoc costructure
08:51:20 <lambdabot> No match for "costructure".
08:56:03 * shapr boings
08:57:27 <ivant> @all-dicts boing
08:57:28 <lambdabot> No match for "boing".
08:57:30 * dmwit twangs shapr
08:57:43 <dmwit> TWANG
08:58:56 <shapr> whee!
09:03:44 <mathias> How should the MonadTrans instance for newtype XT x m result = XT { state:: StateT x (WriterT Doc m) result} look like?
09:08:53 <Heffalump> some combination of XT, state, lift and lift, at a guess.
09:10:23 <mathias> Heffalump, thanks, I got it.
09:10:54 * ivant finished skimming through the fusion paper
09:11:09 <PhilippaAH> 'lo
09:11:32 <ivant> so, how does one start using the stream fusion in the program?
09:13:06 <ivant> is it something like, install the library and import the module, or is it something different (e.g. import the module, source of which is present somewhere, to instruct ghc how to rewrite things)?
09:14:12 <PhilippaAH> I think you just import the module? dcoutts is busy talking cabal a couple of seats away, could ask him
09:15:38 <SamB> ivant: I think it's more like: wait for the relevant GHC release, install it, build your program
09:16:07 <reltuk> is it in HEAD?
09:16:44 <SamB> dunno...
09:18:33 <PhilippaAH> SamB: that's easier, yeah
09:18:36 * osfameron writes a prime factorizer and a hideous monstrosity of concatMaps, sortBys and groupBys... then discovers that the whole thing boils down to foldl1 lcm [1..20]
09:21:54 <mrd> always fun
09:22:26 <jmelesky> isn't that the whole haskell experience? writing pages of code that can be refactored to a single fold?
09:24:34 <osfameron> heh, I guess it's true of programming in general, but yeah
09:30:52 <zak> Hi... is anyone around?
09:31:30 <Vq^> probably
09:32:35 <glen_quagmire> i am around.
09:32:43 <glen_quagmire> my name's lindsay. nice to meet you
09:33:07 <zak> I'm fairly new to Haskell and I'm wondering about subtyping
09:33:13 <zak> I'm Zak.  Nice to meet you
09:33:44 <desp> Toxaris: huh. I think I've been colored.
09:34:07 <glen_quagmire> we can't mind read your mind.
09:34:19 <zak> specifically, I have a monad that passes around a random number generator
09:34:19 <Toxaris> desp: hehe :)
09:34:22 <hpaste>  desp pasted "blah" at http://hpaste.org/2193
09:34:31 <desp> Toxaris: shaved off 3 seconds
09:34:54 <desp> and there's probably a silly one-off bug or something like that
09:34:55 <zak> and I want to basically have a subtype of the monad that passes around this random number generator and some other state information
09:35:21 <desp> Toxaris: which I'm too hungry to debug at the moment, brb :)
09:35:34 <Toxaris> desp: "gives slightly different answer" ;)
09:35:51 <zak> I'm thinking I can do it by making the random number monad take an additional type argument for the extra state
09:36:06 <desp> Toxaris: _1 and _2 give 4179871, _3 gives 4179935 :)
09:37:38 <zak> but I'd rather create a subtype of the random monad that passes around the random number generator and the state, but works with all the functions I've already written that work with with random number generator monad
09:37:42 <zak> is that possible in Haskell?
09:38:01 <Toxaris> zak: yes
09:39:01 <zak> Toxaris: great!  Can you give me a pointer to where to read about it / tell me about it?
09:39:01 <Toxaris> the general idea is to use a typeclass for the interface of your monad, and monad transformers to compose different monads.
09:39:25 <zak> Toxaris: Ok thanks a lot;   I'll look into it
09:39:56 <Toxaris> but some kind of extendible state may be easier
09:40:15 <Toxaris> (not better, just easier)
09:40:52 <Toxaris> like using   State (RandomGen, a)  when you only need the random stuff, and  State (a, SomethingElse)  otherwise
09:42:31 <Toxaris> but if you want to make it "right", something like   class MonadRandom where withRandGen :: (RandGen -> (RandGen, a)) -> a   would be my aproach
09:45:36 <Toxaris> zak: another idea may be to avoid passing random number generators around, and instead pass list of random numbers, or map functions over lists of random numbers or something like this
09:48:30 <zak> withRandGen is supposed to apply a RandGen stored in the state to a (RandGen -> (RandGen,  a)) function, store the RandGen back in the state, and then return the a?
09:48:45 <zak> I know that's not really how monads work... but I can't think of how else to talk about it
09:48:57 <zak> is that the general idea?
09:49:03 <Toxaris> yes it is
09:49:36 <Toxaris> maybe you have to adapt withRandGen to better work together with the functions from System.Random
09:50:19 <zak> and if I used a list of random numbers, does that change what I'm doing besides passing around a list rather than a RandGen?
09:53:22 <Toxaris> zak: depends on what you're doing
09:54:50 <Toxaris> if you need exactly one random thing per primitive operation, you could use   RandomThing -> Operation   as type of them and map them to a [RandomThing]-list
09:55:45 <Toxaris> but if you really need to have access to random everywhere, you're probably better of with the full power of System.Random instead of a list of random things
09:57:12 <zak> Yeah, I can't predict the number of times I'll call random because it depends on values of the previous random numbers
10:14:12 <cinimod> @hoogle hOpen
10:14:13 <lambdabot> No matches found
10:14:32 <mauke> @hoogle openFile
10:14:32 <lambdabot> IO.openFile :: FilePath -> IOMode -> IO Handle
10:14:39 <cinimod> thanks
10:16:34 <cinimod> @hoogle getArgs
10:16:35 <lambdabot> System.getArgs :: IO [String]
10:17:07 <yaxu> is it true to say that haskell i can't write a function that can produce a side effect, but i can write a function that describes a side effect, and then use monads to describe a sequence of them, and rely on the caller to the main function to actually carry out the effects?
10:17:56 <ddarius> yaxu: The way you mean it, yes, that is not unreasonable.
10:18:08 <yaxu> with unsafePerformIO being an exception to that?
10:18:24 <ddarius> yaxu: Among a few others, yes.
10:18:30 <yaxu> ok thanks ddarius
10:18:49 <ohub> Is function that describes a side effect called action?
10:18:56 <Saizan> and the implementations don't actually work like that, but those are details
10:19:03 <mauke> yaxu: congratulations, you understand IO :-)
10:19:08 <yaxu> wahoo
10:19:20 <mauke> ohub: well, it's more of a value
10:20:02 <olsner> actions are also just values
10:21:15 <Cale> ohub: I suppose the "right" way to look at it is that putStrLn :: String -> IO (), is a function which produces an action describing an effect
10:21:36 <Cale> (Given a string, it produces the action which prints that string on the terminal)
10:21:46 <ohub> ah, ok
10:22:07 <Cale> > putStrLn "Hello"
10:22:10 <lambdabot>  <IO ()>
10:24:02 <cinimod> ohub: tackling the awkward squad is a good tutorial giving the operational semantics of actions
10:24:22 <cinimod> http://research.microsoft.com/Users/simonpj/Papers/marktoberdorf
10:24:23 <lambdabot> Title: Simon Peyton Jones: papers
10:25:26 <desp> Toxaris: shaved another 3 seconds off ;)
10:28:34 <dynamix> how do i write an operator with two symbols? eg: c?a:b
10:28:53 <ddarius> dynamix: You write two operators.
10:29:06 <dynamix> example
10:29:27 <dynamix> but : is already the cons operator
10:29:45 <Saizan> only infix constructors can start with :
10:29:51 <mauke> dynamix: you don't
10:30:09 <desp> Toxaris: and yes, it was an one-off error in twoFoldlWhile' :0
10:30:37 <dynamix> (?) c a b = if c then a else b   works, but i want it look more c like
10:30:45 <dynamix> C like C?a:b
10:31:26 <ohub> well, a:b builds a list, maybe your (?) could take a list for a second parameter? :)
10:31:35 <mrd> Averell:[b] :/
10:31:37 <mrd> oops
10:31:58 <dynamix> or a pair maybwe
10:32:01 <mrd> you can use (if c then a else b) anywhere you want
10:32:13 <mrd> you can also define something like: if' a b c = if a then b else c
10:32:36 <mrd> yea you might be able to do C ? (a,b)
10:33:22 <dynamix> yeah but i have started disliking the if then else keywords, only in haskell programs.  the (?) version is pretty much same as the if' version
10:34:07 <ohub> @type let c ? (a,b) = if c then a else b
10:34:16 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
10:34:16 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
10:34:16 <lambdabot>  
10:34:31 <ohub> eek?
10:35:02 <mauke> @type a
10:35:04 <lambdabot> Not in scope: `a'
10:35:08 <ddarius> @type let c ? (a,b) = if c then a else b
10:35:09 <kilimanjaro> @type let c ? (a,b) = if c then a else b in ?
10:35:10 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
10:35:11 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
10:35:11 <lambdabot>  
10:35:12 <lambdabot> parse error on input `?'
10:35:17 <kilimanjaro> woops
10:35:22 <Toxaris> @type let c ? (a,b) = if c then a else b in (?)
10:35:22 <ddarius> Point kilimanjaro.
10:35:24 <lambdabot> forall t. Bool -> (t, t) -> t
10:36:07 <Toxaris> I try to avoid Bool, so I don't need if, either
10:36:40 <ddarius> Toxaris: How do you avoid Bool?
10:36:51 <dynamix> Toxaris: how can you avoid testing truth ?
10:36:54 <Toxaris> but when I have to deal with Bool, but don't want to use if, I invent custom combinators on-the-fly for the context
10:37:41 <Toxaris> like p (?:) a =  if p a then (a :) else id
10:38:57 <mauke> *Main> 1 == 2 ?? "a" :? 1 == 3 ?? "b" :? "c"
10:38:57 <mauke> "c"
10:39:06 <mauke> too bad :: isn't a valid operator
10:40:02 <Toxaris> ddarius, dynamix: by using my own datatypes and case instead of Bool and if
10:40:14 <Toxaris> ddarius, dynamix: by using named functions with guards instead of inlined if-then-else
10:40:58 <Toxaris> ddarius, dynamix: by using Maybe or Either to encode choices
10:40:59 <ddarius> Toxaris: No one asked how you avoid if-then-else.  I rarely ever use it.
10:41:21 <desp> ddarius: look again
10:41:41 <desp> list fusion is quite impressive
10:41:58 <Toxaris> ddarius: only one of my three answers failed to avoid Bool
10:42:31 <ddarius> Toxaris: Unless your data types are isomorphic to Bool, then you shouldn't be using Bool in the first place.
10:42:50 <doserj> mauke, how about "b ? x = if b then const x else id"
10:43:08 <mauke> (b ? x) y
10:43:10 <mauke> :/
10:43:24 <doserj> b ? x $ y
10:43:24 <ddarius> I find that I practically never carry Bools around, though Haskell doesn't make that much of a difference in that regard (a small one, but not much)
10:44:44 <Toxaris> Toxaris: most of the time, my data types are "almost" isomorphic to something involving Bool. so Bool would be a bad idea in the first place, yes. maybe I don't avoid Bool, but choose what I want, and it just happens that I don't want Bool
10:45:02 <Toxaris> hmm. this was for ddarius of course
10:45:23 * Toxaris loops forever speaking to himself
10:45:23 <qwr> mauke: perl6 has ?? !! conditional ;)
10:45:37 <ddarius> With algebraic datatypes, and many of the predefined ones, there is no reason to use Bool as a tag, as it sometimes is in other languages.
10:45:44 <mauke> I don't want to override !!, though
10:45:46 <Toxaris> ddarius: like using Maybe a instead of (Bool, a)
10:46:00 <ddarius> Toxaris: That's one example, yse.
10:50:29 <Toxaris> but it would be even easier to do so, if there were some standard combinators for it, like \p x -> guard (p x) >> return x
10:51:27 <ddarius> @pl \p x -> guard (p x) >> return x
10:51:28 <lambdabot> (`ap` return) . (((>>) . guard) .)
10:53:44 <ohub> Toxaris: Isn't (Bool, a) more like Either a
10:53:59 <mauke> Join Either a
10:54:10 <mauke> type Join f x = f x x
10:54:17 <Toxaris> ohub: (Bool, a) is exactly like (Either a a)
10:54:55 <Toxaris> but sometimes, (Bool, a) is used like (Either, a)   (that is, snd is never used if fst is False). and then it makes sense to use Maybe a instead
10:55:10 <Toxaris> argh, "... used like Maybe a..."
10:55:51 <Toxaris> ohub: ok, not really exactly because of bottoms
10:56:10 <ddarius> Think of all the binary trees implemented struct Node { bool empty; Node *left, right; Value *val; }
10:56:28 <ddarius> *right
10:56:52 <olsner> @src mergesort
10:56:53 <lambdabot> Source not found. Are you on drugs?
10:56:56 <Tac-Tics> > product [1..5]
10:56:57 <lambdabot>  120
10:57:07 <GoAwayStupidAI> O_o lambdabot's accusations!
10:57:11 <olsner> lambdabot: no, I am not on drugs!
10:57:14 <mauke> ddarius: who does that?
10:57:21 <Tac-Tics> > sort [5,4,3,2,1,6]
10:57:22 <lambdabot>  [1,2,3,4,5,6]
10:57:33 <ddarius> mauke: No one because you could test everything for NULL, but there are such cases.
10:57:43 <Tac-Tics> > cycle "pants"
10:57:44 <lambdabot>  "pantspantspantspantspantspantspantspantspantspantspantspantspantspantspants...
10:57:45 <qwr> ddarius: C has 0 pointers
10:58:43 <Toxaris> struct Settings { ... bool useDefaultXxx; int userDefinedXxxx; ... }
10:59:10 <GoAwayStupidAI> > cycle "panst on. drink coffee. code. pants off."
10:59:11 <lambdabot>  "panst on. drink coffee. code. pants off.panst on. drink coffee. code. pants...
10:59:16 <GoAwayStupidAI> It's like my life!
10:59:26 * qwr should learn to read all text before writing...
10:59:27 <GoAwayStupidAI> (even the spelling errore)
11:00:23 <olsner> > fix ("panst on. drink coffee. code. pants off."++)
11:00:24 <lambdabot>  "panst on. drink coffee. code. pants off.panst on. drink coffee. code. pants...
11:00:37 <mauke> @src cycle
11:00:38 <lambdabot> cycle [] = undefined
11:00:38 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
11:00:42 <mauke> boring
11:00:55 <olsner> that's gotta be the first time I've actually used fix for something
11:01:04 <mauke> cycle = fix . (++)
11:01:24 <olsner> indeed
11:01:26 <GoAwayStupidAI> @src fix
11:01:26 <lambdabot> fix f = let x = f x in x
11:01:33 <Toxaris> general_cycle = fix . mappend
11:01:44 <olsner> > fix ([]++)
11:01:50 <lambdabot>  Exception: <<loop>>
11:01:51 <mauke> :t mappend
11:01:53 <lambdabot> forall a. (Monoid a) => a -> a -> a
11:02:12 <GoAwayStupidAI> Is there a good reference I could use to understand fixed points?
11:02:29 <GoAwayStupidAI> I presume that's what "fix" is used for?
11:02:32 <mauke> f(x) = x for fixed points x
11:02:33 <Cale> I can explain :)
11:03:07 <GoAwayStupidAI> Are they related to eigen vectors/values in linear algebra?
11:03:12 <Cale> fix in particular will give you what's called the 'least fixed point' -- that's 'least' in the sense of 'least-defined'
11:03:21 <GoAwayStupidAI>  hm
11:03:31 <Toxaris> GoAwayStupidAI: hmm, yes, in a sense. but this relation doesn't matter with Haskell
11:03:36 <Cale> They're kind of related to eigenvectors, actually
11:04:04 <GoAwayStupidAI> OK. I'd imagine the idea of a fixed point in computer science is somehow more general
11:04:30 <Cale> Well, let's have a close look at how fix does its job in a particular case.
11:04:45 <Cale> hey, I might already have an hpaste for this :)
11:05:03 <GoAwayStupidAI> :-)
11:05:10 <Toxaris> since haskell functions are normally not linear, and haskell values are normally not vectorial, we can't describe haskell functions with eigenvectors
11:05:14 <Cale> http://hpaste.org/2110
11:05:40 <Cale> Also, eigenvectors are only fixed points up to scalar multiplication
11:05:41 <GoAwayStupidAI> Taxoris: OK. Makes sense
11:06:25 <Cale> So if you know what a projective space is, they're fixed points of the resulting transformation on the projective space built on that vector space.
11:07:04 <Cale> So have a look at that paste.
11:07:09 <ddarius> They're fixed directions.
11:07:13 <Cale> right :)
11:07:35 <GoAwayStupidAI> Thansk. I'm checking it out now. Though I think "projective space" just went over my head.
11:08:03 <Toxaris> GoAwayStupidAI: since it doesn't apply to Haskell, you can safely ignore it
11:08:19 <mauke> :-)
11:08:56 <Toxaris> Cale: so, hmm, the projective space is when I ignore the lengths of vectors and only consider the direction?
11:09:07 <Cale> GoAwayStupidAI: A function in Haskell will have a nontrivial least fixed point if when applied to undefined doesn't give a completely undefined value again.
11:09:18 <ddarius> Toxaris: You identify vectors with lines.
11:09:37 <Cale> Toxaris: yeah, you delete the zero of the vector space, and identify those vectors which are scalar multiples of each other.
11:09:56 <Toxaris> ddarius: only to describe what I think a projective space is
11:10:03 <mauke> Cale: wait. that sounds like C pointers
11:10:27 <ddarius> Actually, fixed directions is not all that right as -v is a different direction than v.
11:10:31 <mauke> pointers into the same object lie on the same line
11:11:06 <ddarius> mauke: What's the scalar multiple of a pointer (and by what)?
11:11:17 <olsner> how do all multiples of a pointer point into the same object?
11:11:24 <mauke> you can't multiply pointers
11:11:29 <Toxaris> ddarius: hmm funny. so it looks like a wrapped around sphere?
11:11:41 <mauke> scalar multiplication corresponds to +/- on the pointer
11:11:48 <Cale> Toxaris: it looks like a sphere where opposite points are identified.
11:11:57 * Toxaris is sure to have learnt and forgotten that already some years before
11:12:09 <msouth> iirc you get to define your set of scalars
11:12:23 <Cale> Or a half-sphere where along the circular boundary, you've identified opposite points.
11:12:32 <ddarius> mauke: You can't multiply vectors either, you can scale them.
11:12:35 <Cale> Or like the space of lines through the origin.
11:13:07 <mauke> ddarius: you could map ptr + n onto v * 2^n
11:13:13 <GoAwayStupidAI> Cale: The function (1:) looks like, at least to me, that it will give a completely undefined value when applied to undefined. I presume I'm missing something?
11:13:29 <mauke> no, it returns 1 : undefined
11:13:37 <Toxaris> wich has defined and undefined parts.
11:13:41 <GoAwayStupidAI> ahh
11:13:49 <Toxaris> defined it: it's a conse with a 1. and undefined is the tail
11:13:49 <GoAwayStupidAI> hence not completely undefined
11:13:55 <ddarius> > head (1:undefined)
11:13:56 <lambdabot>  1
11:14:03 <ddarius> > head undefined
11:14:04 <lambdabot>  Undefined
11:14:10 <olsner> > tail (1:undefined)
11:14:11 <lambdabot>  Undefined
11:14:20 <mauke> > 1:undefined
11:14:22 <lambdabot>  Undefined
11:14:29 <mauke> :(
11:14:35 <Saizan> > tail . tail $ (1:undefined)
11:14:37 <lambdabot>  Undefined
11:15:03 <olsner> take 10 (1:undefined)
11:15:06 <olsner> > take 10 (1:undefined)
11:15:07 <lambdabot>  Undefined
11:15:09 <mauke> anyway, you can make undefined "more defined" by repeatedly piping it through (1 :)
11:15:13 <Cale> > take 1 (1 : undefined)
11:15:14 <lambdabot>  [1]
11:15:16 <ddarius> mauke: You might enjoy a paper that views Objective-C from a crazy categorical perspective.
11:15:27 <mauke> you get undefined, 1:undefined, 1:1:undefined, 1:1:1:undefined, ...
11:15:47 <Cale> and those tend towards the 'limit' [1,1,1,...]
11:16:02 <Cale> and that's exactly what fix (1:) gives you
11:16:12 <mauke> > last (iterate (1 :) undefined)
11:16:16 <lambdabot> Terminated
11:16:54 <GoAwayStupidAI> I see
11:17:16 <olsner> that's nicely consistent with the view of yet-unevaluated parts of data as _|_, where fix (1:) starts as _|_, then forced to 1:_|_, then 1:1:_|_ etc
11:17:18 <GoAwayStupidAI> makes more sense
11:17:24 <ddarius> And 1:repeat 1 = repreat 1 so it's a fix point.
11:18:27 <GoAwayStupidAI> Is that what bottom is defined as: The not yet evaluated parts of data. Or is that just a way to view bottom?
11:19:08 <ddarius> Neither.
11:19:18 <GoAwayStupidAI> hehe
11:19:21 <lament> no, bottom is just bottom
11:19:32 <mauke> "bottom" is just a cute name for (_|_), because it looks like one
11:19:33 <lament> it doesn't stop being bottor if you evaluate it
11:20:08 <GoAwayStupidAI> lol... somehow I don't think that's the origin of the name ;-)
11:20:16 <Toxaris> olsner: who uses "_|_" as a sign for yet-unevaluated data? I know only "_"
11:20:42 <Toxaris> GoAwayStupidAI: the origin is in lattice theory, I think, where bottom is the smallest, and top the biggest element of some set
11:21:03 <Toxaris> GoAwayStupidAI: now consider the "is more defined"-relation
11:21:25 <Toxaris> and the smallest element according the this relation is the fully undefined element, wich is therefore called bottom
11:21:44 <Cale> Toxaris: It's really an upside down, stylistically-plain T, used to mean the bottom of a lattice. It's used by denotational-semantics people.
11:22:28 <Toxaris> Cale: it's used by lattice people. consider _|_ = false and T = true in the boolean lattice
11:22:47 <Toxaris> very common usage (even by denotational semantics people who happen to think about booleans)
11:22:49 <GoAwayStupidAI> hm. OK.
11:23:12 <osfameron> "lattice people" sound like some sort of fantastic creature, possibly with pointy ears
11:23:27 <ddarius> "poset people"
11:23:33 <olsner> Toxaris: someone on #haskell described it like that.. didn't bother with asking where the notation came from
11:23:45 <Cale> Toxaris: yes.
11:23:59 <lament> the most defined element is of course () :)
11:24:25 <Toxaris> lament: in what sense is that more defined then the sequence of prime numbers?
11:24:43 <glguy> â¥
11:24:54 <osfameron> eeeek!  a unibottom
11:25:23 <olsner> is that a counterpart of the unibrow? :S
11:25:49 * Toxaris 's client doesn't display glguy's contribution :(
11:26:01 <glguy> irssi ftw ;)
11:26:12 * ddarius uses xchat
11:26:13 <lament> it looks like a horribly unsymmetrical upside-down T
11:26:28 <osfameron> glguy: well, properly configured irssi+screen+ssh client+settings on local and remote host
11:26:43 <Toxaris> olsner: hmm ok :) i don't like it. since _ may turn out to become _|_ by evaluation, these should be distinguished
11:27:04 <osfameron> as in... I've had horribly unconfigured irssi utf8 settings for a long time and struggled to fix the little buggers, so it's no good being smug about things JustWorking on it :-)
11:27:40 <glguy> irssi autodetects the utf-8 stuff just fine if you have your terminal set up correctly
11:27:49 <glguy> if you are using screen, the -U flag is often needed
11:27:50 <Toxaris> oh cool I can copy-paste it in some other window and it is displayed as bottom sign
11:28:21 <olsner> I guess the point was that yet-unevaluated values are indistinguishable from values that would evaluate to _|_ (which as I understand it is just a metaphor for non-terminating calculations, errors and similar things)
11:28:40 * Cale uses XChat for the nice unicode support :)
11:29:17 <lament> Cale: that's an odd reason to use a particular irc client
11:29:27 <Cale> Yeah, you can think of evaluation as moving values upward in the lattice from _|_ to consistently more defined values
11:29:27 <lament> even mirc supports utf8 these days
11:29:31 <ddarius> Stupid non-German predicting phone.
11:29:41 <Cale> lament: mIRC is a ridiculous client though :)
11:30:15 <lament> ddarius: you can't turn off the predictiveness?
11:30:23 <Cale> I used mIRC back in 1995, its scripting language is just about the most horrific thing ever. :)
11:30:34 <ddarius> lament: I could but why would I want to do that?
11:30:52 <lament> cause it's non-german? :)
11:31:10 <Cale> I seem to recall that it had functions which did different things based on whether you put commas between their parameters. I could just picture the gigantic ad-hoc case expression which was evaluating everything.
11:31:20 <ddarius> It doesn't stop me from entering whatever I want, it just doesn't accurately predict German words.
11:31:26 <ddarius> Yet...
11:33:08 <laz0r> @type (>>=)
11:33:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:33:15 <mauke> <workbench> that is, zombie revivification is the dual of human death
11:33:25 <laz0r> @type ((+) >>= (\x -> x))
11:33:27 <lambdabot> forall a. (Num a) => a -> a
11:33:28 <lament> Cale: it's not like xchat has a good scripting language
11:33:48 <ddarius> :t join (+)
11:33:50 <lambdabot> forall a. (Num a) => a -> a
11:33:50 <laz0r> > ((+) >>= (\x -> x)) 1
11:33:52 <lambdabot>  2
11:33:52 <olsner> doesn't xchat have ruby, perl, python etc bindings instead of a scripting language?
11:33:55 <mauke> > join (+) 1
11:33:56 <laz0r> mmh
11:33:56 <Cale> lament: hm?
11:33:57 <lambdabot>  2
11:34:03 <lament> olsner: it does, but iirc only the perl ones are in shape
11:34:06 <ddarius> @src join
11:34:06 <lambdabot> join x =  x >>= id
11:34:12 <Cale> lament: You can script X-Chat in a number of real languages. :)
11:34:18 <lament> and facing a choice between perl and mircscript, i'd gladly shoot myself
11:34:37 <Cale> Python isn't so bad :)
11:34:40 <olsner> @remember lament and facing a choice between perl and mircscript, i'd gladly shoot myself
11:34:40 <lambdabot> Done.
11:34:44 <mauke> perl has closures and higher order functions. I think the choice is clear
11:34:54 <Toxaris> perl is funny
11:35:04 <ddarius> mauke: The choice seemed clear enough to lament.
11:35:10 <Cale> Or ruby. I'm sure you could also write a Haskell plugin.
11:35:26 <osfameron> how do I get ghc to output an executable?
11:35:40 <Cale> osfameron: ghc -o executable Something.hs
11:35:53 <ddarius> ghc --make MainModule.hs
11:35:55 <glguy> ghc --make Something
11:35:57 <glguy> in that case
11:35:59 <lament> Cale: i know that xchat has python and ruby bindings, but from what i've heard (i don't use xchat myself) only the perl ones are maintained/usable
11:36:25 <chris2> it has tcl too
11:36:29 <osfameron> ah, ta
11:36:37 <osfameron> man ghc and then grep "executable" doesn't give anything sensible
11:36:43 <chris2> but i only tried the ruby ones and wasnt too impressed
11:36:49 <osfameron> and I have no idea what a bare "ghc source.hs" actually thinks it's doing
11:36:59 <lament> in any case, why would i script my irc client
11:37:06 <ddarius> osfameron: It compiles.
11:37:16 <lament> scripts already exist for the 3 or so tasks that do need to be scripted, and you can just download them
11:37:17 <Cale> lament: It's pretty trivial to write a binding, and Python, Perl and TCL are all used quite a bit.
11:37:19 <osfameron> ddarius: but to what?
11:37:26 <ddarius> .o
11:37:40 <laz0r> where is the instance for Monad (->) a defined?
11:37:51 <ddarius> Probably Control.Monad.Reader
11:37:54 <glguy> Control.Monad.Reader or Instances
11:37:58 <glguy> (6.4 vs 6.6
11:37:59 <desegnis> Instances
11:38:02 <desegnis> ah
11:38:34 * desegnis won't say anything anymore
11:38:48 <glguy> ?
11:39:28 <desegnis> glguy, always someone else knows more/better
11:39:36 <Cale> desegnis: Don't be scared!
11:39:46 <glguy> desegnis: you should try to answer lots of questions :)
11:39:56 <mauke> osfameron: a.out probably
11:40:05 <desegnis> Cale, glguy; I'm trying, I'm trying... ;)
11:41:42 <Cale> Now, what were we talking about... fix :)
11:42:01 <Cale> The most common way to use fix is to pass it a function which takes as its first parameter another function.
11:42:15 <Cale> fix will pass the fixed point of this function to itself.
11:42:29 <ddarius> Cale: The most common way to use fix is not to use it.
11:42:38 <Cale> ddarius: hehe, indeed :)
11:42:52 <olsner> for all the theory behind fix, it seems quite useless
11:42:53 <Cale> Basically, what that gives you is recursion:
11:42:59 <reltuk> @type (,)
11:43:07 <lambdabot> forall a b. a -> b -> (a, b)
11:43:21 <Cale> > let fac' f n = if n == 0 then 1 else n * f (n-1) in fix fac' 5
11:43:22 <lambdabot>  120
11:43:23 <olsner> although I have heard that all recursion is really applications of fix, in some profound way
11:43:25 <ddarius> olsner: Because fix is the theory behind stuff.
11:43:30 <Cale> Note that fac' is not recursive.
11:43:38 <byorgey_> olsner: yes, it is
11:43:42 <Toxaris> olsner: the idea of fix is built-in into haskell's let
11:44:09 <byorgey_> olsner: defining functions in a fix-able style allows you to perform various operations on them before finally applying fix
11:44:14 <Cale> So fix just took fac' which you can think of as the template for the recursive factorial, and tied it up into a recursive function.
11:44:25 <Toxaris> so we don't need explicit fix because we have implicit fix
11:44:39 <Cale> Indeed, we can write fix very easily :)
11:44:44 <ddarius> @src fix
11:44:44 <lambdabot> fix f = let x = f x in x
11:44:50 <GoAwayStupidAI> Does fix have some relation to the y-combinator? Are they both fixed point combinators?
11:45:02 <olsner> oh, it's something like the Y combinator then? ... fac' f n, where f represents the recursion of fac'
11:45:05 <ddarius> The Y-combinator is one way of implementing fix.
11:45:15 <Cale> The Y combinator is an implementation of fix in the untyped lambda calculus
11:45:30 <Cale> (or possibly in the SK-calculus)
11:45:38 <olsner> questions in stereo, answers in stereo ;-)
11:45:52 <lament> hehe
11:46:07 <glguy> speaking of, how did that @quote get wiped?
11:46:16 <Cale> glguy: shush :)
11:46:17 <Toxaris> (funny. after explaining fix for half an hour to be asked: oh, so it's the Y combinator?)
11:46:20 <shachaf> glguy: I know Cale didn't like it.
11:46:33 <glguy> yeah, but it got changed to "C'ale"
11:46:34 <GoAwayStupidAI> lol
11:46:39 <glguy> and now its gone altogether?
11:46:45 <GoAwayStupidAI> yea.. the pieces are falling into place
11:46:50 <lament> see http://en.wikipedia.org/wiki/Y_combinator for examples of other fixed point combinators
11:46:53 <Cale> glguy: I think there was a complete database wipe at some point
11:46:55 <Cale> @karma
11:46:55 <lambdabot> You have a karma of 4
11:47:06 <olsner> so... not calling f in fac' f n represents terminating the recursion, while fix (from its definition) seems to be an instant bottom
11:47:07 <mathias> How can I execute a function with runST which has a non-empty context?
11:47:08 <byorgey_> Cale: yeah, there was =P
11:47:10 <shachaf> @quote old
11:47:11 <lambdabot> ghc says: the eta-reduction property does not hold
11:47:11 <glguy> Cale: that doesn't make sense, there are still old quotes in there
11:47:14 <shachaf> @quote old
11:47:14 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
11:47:15 <lambdabot> for your entire program.")
11:47:28 <Cale> glguy: I think some people put a bunch of them back, but left mine out :)
11:47:47 <glguy> @quote revolution
11:47:48 <lambdabot> autrijus says: Well, ever since the monadic revolution of '98 Haskell people have started to do real world apps
11:47:59 <glguy> that one was from 05.03.30
11:48:02 <lament> According to wikipedia, Yk=(L L L L L L L L L L L L L L L L L L L L L L L L L L)  where  L = lambda abcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))  is a fixed point combinator.
11:48:07 <Cale> Oh good, firefox has seen fit to give a completely grey page for wikipedia's fixed point combinator article :)
11:48:14 <Cale> Time to restart it :)
11:48:34 <glguy> @quote approximate
11:48:34 <lambdabot> No quotes match. Do you think like you type?
11:48:44 * mauke is tempted to @pl it
11:48:57 <shachaf> mauke: @pl what?
11:49:30 <Saizan>  abcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o  i n t c o m b i n a t o r))
11:49:38 <GoAwayStupidAI> That quote reminds me of an implementation of something called "LÃ¶b's Theorem"
11:49:50 <Saizan> \a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t h i s i s a f i x e d p o  i n t c o m b i n a t o r))
11:50:16 <Cale> @pl \a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
11:50:20 <lambdabot> (((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((
11:50:20 <lambdabot> ((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .
11:50:20 <lambdabot> ) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((ap id .) .) .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .)
11:50:21 <lambdabot> . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((ap .) .) .) .)
11:50:21 <GoAwayStupidAI> I didn't understand it at all, but from what I could tell of the discussion it could be used to implement a spreadsheet style computation... in one line >_<
11:50:24 <lambdabot>  .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .
11:50:24 <Cale> haha
11:50:26 <Vq^> :)
11:50:27 <lambdabot> [24 @more lines]
11:50:29 <lambdabot> optimization suspended, use @pl-resume to continue.
11:50:59 <lament> you weren't supposed to @pl that
11:51:13 <lament> you were supposed to @pl the L L L ... part, which should result in fix :)
11:51:38 <Cale> That's a good point, but I doubt it would have found the simplification anyway :)
11:51:42 <olsner> let l = \a b c d ... in (l l l l l ...) ?
11:51:52 <lament> yes
11:52:42 <shachaf> @pl let l = \a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)) in (l l l l l l l l l l l l l l l l l l l l l l l l l l)
11:52:46 <lambdabot> ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap id id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id)
11:52:49 <lambdabot> id (fix (const ((((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .)
11:52:52 <lambdabot> .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((
11:52:55 <lambdabot> const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((ap id .) .) .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .)
11:52:58 <lambdabot>  . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((
11:53:01 <lambdabot> [25 @more lines]
11:53:03 <lambdabot> optimization suspended, use @pl-resume to continue.
11:53:03 <Cale> heh, nice
11:53:28 <Vq^> nice row of "(ap"'s :)
11:53:51 <lament> @pl (\x y -> (y (x x y))) (\x y -> (y (x x y)))
11:53:59 <lambdabot> (ap id . ap id id) (ap id . ap id id)
11:53:59 <lambdabot> optimization suspended, use @pl-resume to continue.
11:55:45 <olsner> oh, I got "thread killed" from lambdabot
11:56:06 <ddarius> olsner: That's a bad thing.
11:56:27 <olsner> after trying @pl-resume a couple of times
11:56:38 <Toxaris> > fix (1 :) -- works fine
11:56:39 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:56:56 <Toxaris> > let l = \a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)) in l l l l l l l l l l l l l l l l l l l l l l l l l l ('1' :) -- works not
11:56:57 <lambdabot>      Occurs check: cannot construct the infinite type:
11:56:57 <lambdabot>       t
11:56:57 <lambdabot>       =
11:56:57 <lambdabot>       ...
11:57:14 <Toxaris> how do you expect lambdabot to simplify something she cannot typecheck?
11:57:44 <lament> :(
11:57:47 <ddarius>  @pl doesn't need types
11:57:56 <HWSOD> Why does lambabot eval "fmap (+1) (2,3)" to "(2,4)"?
11:57:56 <ddarius> @pl \x -> x x
11:57:57 <lambdabot> join id
11:58:07 <shachaf> @pl (\x -> x x) (\x -> x x)
11:58:10 <olsner> well, it did produce the above ap/id/const/flip monstrosity... but perhaps that's just a simple rewrite-to-combinators without optimization
11:58:11 <lambdabot> ap id id (ap id id)
11:58:11 <lambdabot> optimization suspended, use @pl-resume to continue.
11:58:24 <Saizan> ?instances Functor
11:58:26 <shachaf> @pl-resume
11:58:28 <olsner> @type (\x -> x x) (\x -> x x)
11:59:01 <shachaf> HWSOD: Why not?
11:59:08 <shachaf> @instances Functor
12:00:02 <shachaf> Lambdabot?
12:00:02 <GoAwayStupidAI> @src fmap
12:00:04 <shachaf> @botsnack
12:00:05 <Cale> olsner: probably it did a little bit of optimisation
12:00:08 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:00:10 <HWSOD> is there sometheing that goes (\ f (a, b) -> (f a, f b) ?
12:00:12 <Saizan> HWSOD: (,) a is a functor, so fmap :: (a -> b) -> (x,a) -> (x,b) in this case
12:00:32 <Toxaris> > fmap (+ 1) [("red", 14), ("blue", 4), ("yellow", 12)] -- HWSOD to allow assoc lists to be used as finite maps
12:00:33 <Cale> That's another functor/monad instance which should be in the prelude.
12:00:39 <ddarius> HWSOD: That would require (a,a)
12:00:43 <Saizan> ?type join (***)
12:01:12 <Toxaris> maybe we are killing lambdabot atm
12:01:23 <HWSOD> @pl \f (a, b) -> (f a, f b)
12:01:46 <shachaf> @src (,) fmap
12:01:53 <lambdabot> Plugin `pl' failed with: IRCRaised thread killed
12:01:54 <lambdabot>   add an instance declaration for (Num ([Char], t))
12:01:57 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
12:01:58 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
12:01:59 <lambdabot> fmap f (x,y) = (x, f y)
12:02:31 <Toxaris> HWSOD: I would use something from Control.Arrow
12:02:31 <shachaf> > join (***) (+1) (1,2)
12:02:33 <lambdabot>  (2,3)
12:02:48 <shachaf> Toxaris: Like that?
12:03:08 <Toxaris> yes, probably :)
12:03:08 <HWSOD> ok what the heck is the (***)
12:03:14 <shachaf> @ty (***)
12:03:16 <Toxaris> it's the part from Control.Arrow
12:03:16 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:03:19 <shachaf> @src (->) (***)
12:03:19 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
12:03:54 <glguy> after reading in the logs about all the trouble me using different nicks causes people... I'll have to make sure to stick with this nick
12:04:14 <ddarius> glguy: You use different nicks?
12:04:15 <olsner> glguy: what other nicks have you been using then?
12:04:25 <lament> "dons" and "Cale"
12:04:29 <glguy> :)
12:04:35 <Cale> ahaha
12:04:38 <glguy> I used treble for a day or two
12:04:44 <glguy> and emertens a while back
12:04:45 <olsner> whut!? dons == Cale == glguy!?
12:05:00 <Cale> olsner: Of course not really :)
12:05:04 <HWSOD> @pl \f a b = (f a, f b)
12:05:04 <lambdabot> (line 1, column 8):
12:05:05 <lambdabot> unexpected "="
12:05:05 <lambdabot> expecting pattern or "->"
12:05:06 <glguy> sorear declared that if I did it again he'd just start refering to me by my first name
12:05:17 <HWSOD> @pl \f a b -> (f a, f b)
12:05:17 <lambdabot> flip =<< (((.) . (,)) .)
12:05:25 <Cale> People have thought that Riastradh and I are similar for some reason :)
12:05:42 <shachaf> We're all glguys! If you're in #haskell, you're a glguy.
12:05:55 <olsner> glguy: it's not "Haskell" is it? :P
12:05:58 <rehges> how do i print a number in base 2?
12:06:16 <rehges> or convert it to a string, actually
12:06:22 <shachaf> @ty showIntAtBase
12:06:23 <glguy> olsner: oh yeah, I used that nick as a joke
12:06:24 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
12:06:32 <glguy> olsner: which is why "haskell" is the most referenced "nick" in #haskell
12:06:34 <rehges> thanks scachaf!
12:06:41 <rehges> shachaf
12:07:19 <rehges> should i include some module first?
12:07:31 <olsner> glguy: of course ;-)
12:08:00 <glguy> olsner: (not because I was the most referenced, but because it was added to the list of nicks)
12:08:08 <ddarius> Cale: I have no idea why someone would think you are Riastradh.
12:08:31 <Saizan> ?index showIntAtBase
12:08:31 <lambdabot> Numeric
12:08:34 <Toxaris> shachaf: in join (***) (+1) (1,2), how does join work? it's the plain old monadic join, isn't it?
12:08:45 <olsner> > showIntAtBase pi (- ord '0') 42 ""
12:08:46 <lambdabot>  Couldn't match expected type `Int -> Char'
12:09:06 <olsner> > showIntAtBase pi (\x -> ord x - ord '0') 42 ""
12:09:07 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
12:09:15 <dbremner> shapr - hello
12:09:19 <Cale> Toxaris: yep
12:09:25 <Cale> join f x = f x x
12:09:26 <Vq^> > showIntAtBase 2 (head . show) 253 ""
12:09:27 <lambdabot>  "11111101"
12:09:35 <Cale> Toxaris: In the ((->) e) monad
12:09:44 <olsner> oh, Int -> Char, not Char -> Int hehe
12:10:08 <Cale> Toxaris: so that's ((+1) *** (+1)) (1,2)
12:10:13 <hpaste>  mathias pasted "Instance hell" at http://hpaste.org/2194
12:10:38 <lament> I still think Cale is Riastradh.
12:10:44 <shachaf> Toxaris: Yes.
12:10:45 <lament> I never see both together
12:10:54 <shachaf> Toxaris: Oh, Cale answered you already.
12:10:58 <Cale> The intuition is that join runs a computation and then runs its result, and in the ((->) e) monad, 'running a computation' means applying a function to the parameter.
12:11:33 <mathias> Cale, do you understand that paste?
12:12:04 <Toxaris> Cale: oh, and "running it again" means applying the resulting function (wich is a thunk waiting for the second argument) to the same parameter. nice :)
12:12:13 <Cale> Toxaris: exactly
12:12:55 <Cale> mathias: note the b and the ()
12:13:14 <Cale> mathias: it has to know that b = (), but it doesn't.
12:14:10 <mathias> Cale, ok
12:14:27 <rehges> great, that was projecteuler #36 :-)
12:14:28 <Cale> mathias: Something makes me question this application of typeclasses a bit :) I know that I'd be looking at whether it wouldn't really be more convenient to do something else.
12:14:45 <shapr> dbremner: Hiya, ltns
12:15:23 <mathias> Cale, like what?
12:15:36 <dbremner> shapr - I started a new job in April and it's kept me quite busy. How are things with you?
12:15:40 <mathias> Cale, I could pass 40 parameters to it.
12:15:41 <Cale> Like maybe just different modules sharing the same interface.
12:16:11 <Cale> (of course, that woule mean you can't use them both at the same time without qualified imports)
12:16:19 <mathias> Cale, doesn't that make type classes obsolete?
12:16:21 <lament> Cale, mathias: would it possibly help to change () to ()::() ?
12:16:34 <Cale> mathias: no, it would kill the potential for polymorphism
12:16:57 <Cale> lament: I have no idea what you mean :)
12:17:12 <mathias> Cale, right, but I don't want to implement all code for different structures using only copy pasting.
12:17:23 <Cale> mathias: Okay :)
12:17:36 <mathias> Cale, I just want to implement something once and then use it with different implementations.
12:17:41 <mathias> Cale, i.e. polymorphism, but it seems rather difficult.
12:18:00 <mathias> Cale, without RealWorld there were little problems with the approach.
12:18:00 <Cale> mathias: It also *might* be possible to break the classes up into smaller ones supporting subsets of the features, but I don't know.
12:18:06 <olsner> is lambdabot unable to produce source code for the prelude?
12:18:11 <olsner> @src quotRem
12:18:11 <lambdabot> Source not found. Where did you learn to type?
12:18:23 <Cale> quotRem is a class method
12:18:23 <mathias> Cale, no, that's not possible
12:18:33 <Cale> @src quotRem Int
12:18:33 <lambdabot> Source not found. Are you on drugs?
12:18:34 <HWSOD> what does "overlapping instances" mean?
12:18:38 <Cale> @src Ine quotRem
12:18:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:18:40 <Cale> @src Int quotRem
12:18:40 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:18:41 <mathias> Cale, they all mention all type variables by nature.
12:18:49 <Cale> I suppose it doesn't have that code on hand :)
12:19:24 <Cale> HWSOD: It means that you have polymorphic instances and then different instances for specific cases.
12:19:53 <olsner> could be because it's looking in the Prelude - the GHC prelude (if that's what lambdabot is using) seems to import that stuff from another module and just re-export it in Prelude
12:19:54 <Cale> HWSOD: That is, an instance for a general case, and then some different code for a more specific case.
12:20:12 <Cale> olsner: It has its own database of code, and not everything is in it.
12:20:13 <glguy> with my new local copies of the logs, I can quickly learn things like that @src was first used on this past New Years Day
12:20:15 <ddarius> Cale: One does not need to be more general than the other.
12:20:25 <glguy> and that dons first used @src const   in channel :)
12:20:26 <desp> glguy :)
12:20:48 <bwwx> @seen dcoutts
12:20:48 <lambdabot> I saw dcoutts leaving #ghc, #haskell-overflow, #haskell and #gentoo-haskell 9h 19m 49s ago, and .
12:20:49 <HWSOD> Thanks! capitilization--
12:20:55 <bwwx> @seen dcoutts_
12:20:55 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts_ last spoke.
12:21:01 <bwwx> @seen dcoutts__
12:21:01 <lambdabot> dcoutts__ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I don't know when dcoutts__ last spoke.
12:21:07 <desp> capitilization++ capitalization--
12:21:20 <Cale> Oh, I suppose not, in the multiparameter case.
12:21:29 <Nucleo_> @src sum
12:21:30 <lambdabot> sum = foldl (+) 0
12:21:55 <Cale> For example, you could have C Int a and C a Bool, and those overlap.
12:22:07 <Nucleo_> @hoogle foldl'
12:22:08 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
12:22:28 <yaxu> is there a functional language that doesn't support higher order functions?  or is the requirement to support them part of the definition of a functional language?
12:22:51 <ddarius> yaxu: Single-Assignment C
12:22:55 <Cale> yaxu: I'd consider it a requirement.
12:22:56 <ddarius> www.sachome.org
12:23:00 <ddarius> www.sac-home.org
12:23:27 <Cale> In functional languages, functions are supposed to be first-class values.
12:23:30 <yaxu> btw i'm writing a msc thesis chapter on haskell, someone let me know if my questions get irritating :)
12:23:51 <yaxu> Cale: gotcha, thanks
12:23:51 <Cale> So if you can't pass them as parameters to other functions and manipulate them, returning other functions, you don't have a functional language.
12:23:53 <newsham> thesis topic?
12:24:32 <Cale> I'd almost be willing to consider the notion that languages in which you can't easily write the function composition operator as not being functional languages.
12:24:45 <glguy> yaxu: did you make that haskell ascii live techno video?
12:24:46 <yaxu> newsham: it's about improvising music with computers, but i happen to be using haskell for software and analysis
12:24:50 <bwwx> @src (.)
12:24:50 <lambdabot> (.) f g x = f (g x)
12:25:09 <newsham> oh, you had that demo where you'd live edit haskell code and the music would change?
12:25:09 <bwwx> glguy: what video?
12:25:12 <desp> yaxu: that was fairly interesting
12:25:14 <yaxu> glguy: yes that was probably me
12:25:20 <Cale> If you want to get really picky, languages where composing functions is not already easy are less-functional than those which make it possible to define function composition, but don't make it notationally lightweight.
12:25:25 <Toxaris> yaxu: the VeriFun theorem prover uses a very simple language without first-class functions wich is considered functional. http://www.inferenzsysteme.informatik.tu-darmstadt.de/verifun/
12:25:25 <Cale> er
12:25:27 <lambdabot> Title: VeriFun - a verifier for functional programs
12:25:30 <Cale> that came out all wrong :)
12:25:31 <newsham> yaxu: you're famous already (here) ;-)
12:25:34 <glguy> http://programming.reddit.com/info/2dh1j/comments
12:25:35 <lambdabot> Title: ASCII Rave in Haskell (reddit.com)
12:25:49 <Cale> If you want to get really picky, languages where composing functions is not already easy are less-functional than those which make it notationally lightweight :)
12:25:50 * glguy should have known since "yaxu" posted it to reddit
12:25:58 <Cale> there we go :)
12:26:32 <yaxu> a story did get voted up on reddit saying it was ok to post links to your own stuff, so i did :)
12:26:53 <newsham> int comp(int (*f)(int), int (*g)(int), int x) { return f(g(x)); }
12:26:58 <newsham> functional?
12:27:13 <bwwx> when will we have the haskell startup that does a social news site implemented in haskell? :)
12:27:26 <glguy> couple months ;)
12:27:30 <newsham> happsreddit?
12:28:03 <Toxaris> bwwx: driven by lambdabot?
12:28:19 <shachaf> Do "social news sites" really work?
12:28:42 <glguy> if by work you mean drive traffic and help others to discover interesting articles
12:28:43 <olsner> haddit?
12:28:44 <shachaf> It seems that they would have to be very specialized; Haskell-only, for example.
12:28:45 <glguy> then yes, they do
12:28:50 <glguy> understoodit
12:28:53 <yaxu> to be honest i added 'haskell' to the title just to get it voted up on programming.reddit, you wouldn't really know it was haskell by watching the video, apart from the parsec errors
12:29:00 <newsham> define work.  if by work you mean lots of uninformed people express their opinion on slashdot for stories that I dont really care about anyway, then they totally work
12:29:10 <mathias> Cale, did you receive the ping?
12:29:46 <newsham> yaxu: you understand marketting.  you'll go far.
12:29:52 <bwwx> lambdabot would be the editor of the blog :D
12:30:04 <mathias> slashdot is relatively informed or at least it was
12:30:05 <yaxu> i did link to some haskell source actually
12:30:35 <bwwx> yaxu: what program did you use to capture the video?
12:30:55 <Cale> uh, I've been up from my machine a bunch
12:30:58 <yaxu> patched ffmpeg under ubuntu, i can dig out a link to a tutorial iyl
12:31:11 <Cale> mathias: no :)
12:31:16 <bwwx> yes please
12:31:27 <mathias> Cale, maybe you are blocking me? :)
12:31:45 <mathias> Cale, try /msg me
12:31:46 <Cale> mathias: are you signed in?
12:32:00 <mathias> Cale, I thought so.
12:32:28 <mathias> Cale, got a response?
12:32:33 <Cale> mathias: nope
12:32:38 <mathias> Cale, ok, I need to fix my setup.
12:33:11 <yaxu> bwwx: http://ubuntu.wordpress.com/2006/06/08/how-to-create-a-screencast-in-ubuntu/ # for recent ubuntus, you need to edit the first line of the configure script to #!/bin/bash
12:33:11 <mathias> Cale, I fixed the issue, btw. I accidentally removed a fundep parameter and it took me some time to realize when to use stToIO
12:33:16 <lambdabot> Title: How to Create a Screencast in Ubuntu « Ubuntu Blog, http://tinyurl.com/ejhq5
12:35:13 <Nucleo_> I've a namespace question ... how come 'Import List' gives me sort but not foldl', while 'Import Data.List gives me both?
12:35:28 <shachaf> Nucleo_: Just use Data.List. :-)
12:35:46 <Nucleo_> shachaf: will do, I guess. :-)
12:35:47 <Nucleo_> thanks
12:36:46 <bwwx> yaxu: thanks
12:36:52 <DaveCGI598> @src $!
12:36:53 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:37:07 <shachaf> f $! x = x `seq` f x
12:38:30 <shachaf> (Yes?)
12:38:50 <Nucleo_> @src foldl1'
12:38:51 <lambdabot> Source not found. Where did you learn to type?
12:38:59 <shachaf> @src foldl'
12:39:00 <lambdabot> foldl' f a []     = a
12:39:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:39:09 <shachaf> @src foldl1
12:39:10 <lambdabot> foldl1 f (x:xs) = foldl f x xs
12:39:10 <lambdabot> foldl1 _ []     = undefined
12:39:17 <laz0r> @type ($=)
12:39:18 <Nucleo_> thanks
12:39:19 <lambdabot> Not in scope: `$='
12:39:23 <byorgey> Nucleo_: List is just included for backwards-compatibility; you should always use Data.List.  Apparently foldl' is more recent.
12:39:41 <ddarius> Actually List is standard and Data.List is not.
12:40:01 <shachaf> ddarius: In Haskell 98.
12:40:07 <shachaf> ddarius: But which one do you use?
12:40:09 <byorgey> ddarius: erm, well, depends what you mean by "standard" I guess =)
12:40:12 <ddarius> shachaf: Which is the current standard.
12:40:13 <Nucleo_> but Haskell' will adopt Hierarchical libraries as standard?
12:40:30 <lament> it better
12:40:49 <Nucleo_> I guess I should write Data.List then.
12:40:50 <ddarius> Nucleo_: It will adopt the hierarchical module naming addendum, but all that does is allow you to put .s in module names.
12:40:54 <dmwit> Okay, I'm using Data.Time, and I'd like to take two values of type UTCTime and convert them to a string along the lines of "three days, two hours apart" or so.
12:41:06 <dmwit> Is this even possible with the functions provided in Data.Time?
12:41:18 <Nucleo_> ddarius: ah
12:41:40 <ddarius> In practice, the hierarchical libraries are de facto standard.
12:42:12 <ddarius> And, from what I hear, the only reason the module naming addendum is not accepted is that there is no longer an organization to ratify it.
12:42:31 <Nucleo_> I guess SPJ doesn't qualify as 'an organization,' heh.
12:42:59 <shapr> Though he publishes more papers than many organizations.
12:46:29 <olsner> ooh, with a less-than-one non-integral base, decimals become the integral part and vice versa
12:46:54 <olsner> or, wait, perhaps I'm just not thinking enough
12:47:31 <dmwit> olsner: That thought restricts itself to fractional bases; imagine base 1/pi.
12:47:47 <dmwit> (Or even base 3/4 for that matter...)
12:47:57 <olsner> why are those bases a problem?
12:48:14 <dmwit> They're not!
12:48:24 <dmwit> But your description doesn't fit them, really.
12:48:32 <mathias> Cale, how do you auto-identify in XChat?
12:48:35 <dmwit> i.e. 0.3 is not an "integral part" in base 3/4 or 1/pi.
12:49:19 <dmwit> mathias: In XChat -> Network List... -> Edit...
12:50:56 <olsner> let's see, 0.3 would be 3 * (base)^-1, right?
12:50:56 <Cale> mathias: Edit FreeNode's entry and add a nickserv password
12:52:37 <dmwit> olsner: Err... I think it would 0.3 * (base)^-1.
12:52:55 <Cale> olsner: right
12:52:57 <Cale> dmwit: no
12:53:07 <dmwit> oh right
12:53:12 <olsner> and that should be equivalent to 3.0 in base 1/base, since that's 3*(1/base)^1 = 3*base^-1.. so perhaps I'm rather saying that inverting the base is reversing the digits
12:53:20 <Cale> right
12:53:27 <olsner> and a base < 1 is the reciprocal of some base > 1
12:53:32 <dmwit> yes
12:53:45 <dmwit> Pretty neat!
12:54:24 <Cale> There are also various non-geometric ways to express numbers like "factorial base"
12:54:37 <olsner> hehe, yeah.. or fibonacci-base
12:55:08 <shapr> or prime base
12:55:09 <olsner> where every integral number has exactly two ones iirc
12:55:25 <Cale> Base negative 2 is also rather fun
12:55:42 <Cale> You can represent every integer with only the digits 0 and 1
12:56:13 <dmwit> There are 110 types of people: those who understand base negative 2 and those who don't.
12:56:18 * shapr snickers
12:56:35 <olsner> Cale: "You can represent every integer with only the digits 0 and 1"? that's what binary does, right? :P
12:56:46 <dmwit> olsner: You also need a minus sign in binary.
12:56:52 <Cale> olsner: no, you need a sign as well
12:56:57 <olsner> oh, yes of course
12:57:03 <Cale> Negative numbers have an even number of digits and positive ones have an odd number in base (-2)
12:57:16 <olsner> (*cough* two's complement :P)
12:57:18 <shapr> That's interesting.
12:57:59 <Cale> two's complement only works when you have a finite number of integers to represent
12:58:49 <olsner> the prime base, is that product . filter (/= 0) . zipWith (*) primes, or sum . zipWith (*) primes?
12:58:55 <Cale> Well, hmm, I suppose it could be made to work with arbitrary precision, but it's rather like having an additional dedicated sign bit.
12:59:01 <olsner> Cale: yeah, that's what I realized
12:59:03 <shapr> olsner: We were just wondering that on #haskell-blah
12:59:10 <shapr> ddarius wanted product $ zipWith (^) primes (asStream n) == n
12:59:12 <oklopol> i prefer base -2i
13:00:15 <olsner> so [a,b] would be 3 ^ a * 2 ^ b?
13:00:16 <lament> I don't like bases. I prefer to keep numbers in their natural state.
13:00:22 <shapr> They don't have a natural state.
13:00:25 <lament> Numerals are boring.
13:00:55 <olsner> is that in spirit-haskell, where data does not need tangible representation?
13:00:57 <Cale> So you mean sets?
13:01:02 <lament> shapr: sure they do. Just don't write them down.
13:01:22 <Cale> n+1 = n union {n}
13:01:32 <Cale> 0 = {}
13:01:34 <lament> numbers aren't sets.
13:01:47 <Cale> Sure they are. Everything is a set! :)
13:01:49 <Cale> heh
13:02:10 <Korollary> they could be sets or other things
13:02:26 <lament> you can certainly represent them using sets or other things.
13:02:27 <Saizan> Cale: is the factorial base connected with finding the nth permutation of a sequence?
13:02:32 <Cale> Integers are equivalence classes of pairs of natural numbers which are in turn finite ordinals :)
13:03:23 <ddarius> Cale is a set!
13:03:38 <Cale> Saizan: iirc, yes
13:04:18 <lament> Cale: do you mean the other way around? I don't understand.
13:05:01 <Cale> lament: I'm just being perhaps overly set-theoretical.
13:05:37 <Cale> This is typically how you define those objects in mathematics, but then you proceed to apply isomorphisms wherever convenient.
13:06:21 <Cale> So you tend to treat the naturals as a subset of the integers, for example, even though really it's just something isomorphic to the original naturals.
13:06:43 <Cale> (but nobody really cares about the distinction)
13:06:45 <lament> but where do pairs come from?
13:06:49 <Cale> Sets.
13:06:59 <Cale> (a,b) = {{a,b},{a}}
13:07:17 <lament> oh
13:07:18 <Toxaris> ... and I thought numbers were functions of type (a -> a) -> a -> a
13:07:30 <Cale> It can be checked that this definition gives a set such that (a,b) = (c,d) if and only if a = c and b = d
13:07:30 <lament> set theory as foundation for math is kinda silly
13:07:35 <Cale> and that's really all you care about
13:07:39 <Cale> It's fine.
13:07:47 <Cale> Lots of things are really easy to construct.
13:07:56 <lament> it's fine, but it's silly to say numbers "are" sets, and many people actually say that
13:08:26 <Cale> Well, if you're basing things on set theory, everything is, at some level, a set.
13:08:45 <lament> which is why set theory as a foundation for math is kinda silly, as i said :)
13:08:57 <HWSOD> well in math "are" is usualy only up to isomorphisim anyway.
13:08:57 <Cale> This might seem untyped for a bit until you realise that sets also act as types.
13:09:20 <Cale> Belonging to a set is the same as belonging to a type.
13:09:46 <Cale> (pretty much)
13:09:49 <lament> Cale: it's still untyped, because all sets are sets and you can apply set operations to all of them.
13:10:02 <lament> So you can have things like 42 union apple
13:10:06 <lament> it's stupid
13:10:09 <Cale> Sure, you can do that.
13:10:19 <kjdf> is there a function in standard library similar to this: (a >>- b) l = l >>= a >>= l ?
13:10:20 <Cale> But you don't get something which is an integer.
13:10:31 <kjdf> which would chain 2 functions of type (a -> m b)
13:10:45 <lament> Cale: there's no good reason for that operation to be defined, which is why set theory is silly as a foundation for math
13:10:45 <Cale> kjdf: not that I know of
13:10:57 <Saizan> ?type (>=>)
13:10:57 <Cale> lament: Why not?
13:10:59 <lambdabot> Not in scope: `>=>'
13:11:03 <ddarius> kjdf: I think you want Kleisli composition, and no it's not in the standard library, unless you cound (>>>) with the Kleisli arrow.
13:11:20 <lament> Cale: are you defending weak typing? :)
13:11:26 <kjdf> ok, thanks.
13:11:26 <Cale> lament: If you're treating 42 as a set, then you're working at a foundational level anyway, and you might actually want to construct 42 union apple for some reason.
13:11:33 <Cale> lament: Not at all.
13:11:41 <Cale> Mathematics has a wonderful type system.
13:11:52 <Cale> Every proposition is a type.
13:12:16 <Cale> If I want an integer, I say let n \in Z.
13:12:48 <Cale> That automatically excludes n from being things like 42 union {apple}.
13:13:35 <Toxaris> except when apple happens to be 42 for some stupid reason
13:14:02 <Cale> sure, but then you'd also be able to call it 43.
13:14:25 <Cale> (actually, that's with naturals)
13:14:38 <Cale> But you get the idea.
13:14:57 <Toxaris> oh you wanted Z
13:15:10 <lament> i have no problem with saying numbers are an isomorphic to a particular kind of sets
13:15:24 <lament> but saying that they _are_ those sets is just silly
13:15:30 <Cale> It doesn't matter that you can use low-level set operations to construct meaningless things, because you'll normally specify what set of things you're working with anyway.
13:15:50 <Cale> and once you've done that, you've restricted yourself to only using meaningful constructions.
13:15:56 <Saizan> lament: can you say what numbers are?
13:16:20 <lament> Saizan: sure, they're numbers
13:16:31 <Cale> lament: That doesn't suffice to define them.
13:16:31 <lament> Saizan: there's a bunch of operations defined on numbers
13:16:38 <lament> Saizan: "union" isn't one of those operations
13:17:00 <Ben`> how can I get a random item from a list?
13:17:00 <Cale> lament: So you're saying that numbers are some ring?
13:17:13 <Cale> Ben`: generate a random number and use (!!)
13:17:34 <Ben`> Cale: ok, thanks
13:17:37 <Cale> Ben`: Generating a (pseudo-)random number can be done in a number of ways
13:17:43 <Saizan> lament: union = max
13:17:53 <Cale> Ben`: Depending on whether you're in IO or not.
13:17:59 <kpreid> one could do it lazier than using (!!)
13:18:20 <Cale> Saizan: see, this is exactly the kind of implementation detail that lament hates :)
13:18:26 <Ben`> Cale: how would I get a random number without IO?
13:18:32 <Toxaris> Saizan: thats easy. the natural numbers are the class of structures isomorphic to the free algebra arising from the symbols zero :: a and succ :: a -> a, more or less
13:18:43 <lament> Cale: numbers form rings.
13:19:13 <Toxaris> Saizan: but are they *equal* to such an algebra?
13:19:14 <Cale> Ben`: Well, you have to pick a fixed seed in that case, but you use mkStdGen with the seed, and then random/randomR to construct a random value and a new generator
13:19:31 <Cale> Ben`: (then throw away the old generator and just use the new one -- they're pure values)
13:19:44 <Ben`> ok, thanks
13:20:03 <Saizan> Toxaris: yeah, another formalism, but lament won't like that either i think :)
13:20:23 <Cale> Ben`: You can also use randoms/randomRs to get an infinite list of pseudorandom numbers.
13:20:26 <lament> Saizan: i have no problem with it because he said "the class of structures isomorphic to"
13:20:50 <lament> the actual definition is irrelevant as long as it specifies that
13:20:57 <lament> (and defines numbers correctly)
13:21:49 <lament> Cale: that's the thing, it is an implementation detail
13:21:58 <Cale> lament: right.
13:22:02 <Cale> lament: So?
13:22:11 <Cale> What's wrong with implementation details?
13:22:14 <lament> Cale: Having to deal with people saying pointers in C are memory addresses is bad enough
13:23:02 <Cale> It actually matters quite a lot how things are implemented.
13:23:17 <lament> Cale: implementations aren't unique.
13:23:17 <Toxaris> Cale: mathematic is not implemented, it's specification only, so implementation details are meaningless
13:23:28 <Cale> Toxaris: I mean in the sense of set theory
13:23:51 <lament> Cale: Pointers in C could be memory addresses, or they could be rhubarb pies, and the C standard doesn't care.
13:23:51 <Cale> For example...
13:23:58 <Toxaris> and if someone would implement mathematics, he wouldn't choose a set-theoretic representation for obvious reasons, but something isomorphic to it
13:24:51 <Saizan> Toxaris: mathematics is yet "implemented" with set theory, that just means that you can work with set theory to prove things
13:25:38 <Cale> We say that Ext^1(A,Z) = 0 if whenever B is an Abelian group and f: B -> A is a surjective group homomorphism whose kernel is isomorphic to Z, then there exists a group homomorphism g: A -> B with f . g = id.
13:25:58 <Toxaris> Saizan: yep. because the thing I want to prove is isomorphic to it's set theoretic representation. so it's wrong to say "numbers are sets"
13:26:01 <Cale> The question: Is every Abelian group A with Ext^1(A,Z) = 0 a free abelian group?
13:26:19 <Cale> The answer depends on the implementation of groups as sets.
13:26:42 <Toxaris> Saizan: but try to say "numbers are isomorphic to some sets, and that is very helpfull for mathematical proofs"
13:26:43 <Cale> If every set is constructible (V = L), then every such group is free.
13:26:45 <Toxaris> "true"
13:27:11 <Cale> If Martin's axiom holds and the continuum hypothesis is false, then there is a non-free group of that sort.
13:27:13 <lament> Cale: that's probably an iff rather than if, isn't it?
13:27:26 <Cale> huh?
13:27:47 <Cale> no, this question is actually undecidable in standard set theory (ZFC)
13:27:50 <lament> Cale: if every such group is free, then every set is constructible?
13:27:58 <Cale> I don't think so.
13:29:06 <Cale> So it's possible for such details to matter. Here we have a question which is asked only in terms of groups and homomorphisms.
13:29:30 <Cale> But it's one which is higher-order -- it asks a question about whether every group satisfies something.
13:29:53 <Cale> and all of a sudden it matters what set theoretic axioms we used to define groups in the first place :)
13:31:52 <Toxaris> so we have the groups wich are based on this flavour of set theory, and some other groups wich are based on some other flavour of set theory... and this is a *good* thing?
13:31:59 <Cale> yep
13:32:06 <shapr> @seen dcoutts
13:32:06 <lambdabot> I saw dcoutts leaving #ghc, #haskell-overflow, #haskell and #gentoo-haskell 10h 31m 7s ago, and .
13:32:09 <shapr> @seen dcoutts_
13:32:10 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts_ last spoke.
13:32:12 <shapr> foo
13:32:17 <Cale> Because what basis do we have for choosing between set theories?
13:32:20 <shapr> Who do I talk to about cabal-install?
13:32:25 <xinming> Which function is used for spliting list into the same number of small lists?
13:32:27 <Cale> Really it comes down to preference.
13:32:36 <ddarius> The real question is whether this is relevant to the group theory.
13:32:48 <olsner> oh, I need to learn to talk like you've been doing and sound like I know it until next tuesday
13:32:48 <xinming> eg. ['a'..'z'] => [['a', 'b'], ['c', 'd'] .. ]
13:32:52 <Cale> xinming: there's nothing in the libraries for that.
13:32:55 <Toxaris> > map (: []) [1, 2, 3]
13:33:01 <lambdabot>  [[1],[2],[3]]
13:33:31 <Cale> ddarius: Well, I've already shown that to some extent it very much is.
13:33:50 <olsner> @quote parallell parking
13:33:50 <lambdabot> No quotes for this person. I feel much better now.
13:33:55 <olsner> @quote parking
13:33:55 <lambdabot> psykotic says: so, if you have a lie group with two generators a and b, a generates turns and b generates (relative) forward motion, then the lie bracket [a,b] = a b a^(-1) b^(-1) is a parallel
13:33:55 <lambdabot> parking transformation
13:34:04 <Cale> ddarius: You can ask questions which are purely about groups and which are not answerable without knowing something about the properties of the underlying sets.
13:34:10 <xinming> > map (: []).(take 2) [1..10]
13:34:11 <lambdabot>  Couldn't match expected type `a -> [a1]'
13:34:30 <kpreid> @let randomIndex g xs = (\(_,c,_) -> c) $ foldl (\(n,c,g) x -> let (opt,g') = randomR (0,n) g in (succ n, if opt < 1 then x else c, g')) (0::Integer,undefined,g) xs -- Lazy algorithm adapted from Perl FAQ
13:34:32 <Cale> (and not just the trivial properties, like that the axiom of union holds)
13:34:35 <lambdabot> Defined.
13:34:48 * byorgey is thinking about xinming's question
13:34:57 <kpreid> > map (head &&& length) . group . sort . map (\i -> randomIndex (mkStdGen i) [1,2,3,4]) $ [1..4000]
13:34:58 <lambdabot>  [(1,982),(2,993),(3,1034),(4,991)]
13:35:28 <kpreid> er, that was lousy...
13:35:38 <Saizan> Cale: doens't that just means that they are undecidable in group theory?
13:35:55 <Cale> Saizan: sort of, depending on what you consider group theory to consist of.
13:36:10 <byorgey> @type splitAt
13:36:12 <lambdabot> forall a. Int -> [a] -> ([a], [a])
13:36:28 <xinming> Cale: So, If there is a functoin which can do this, what should the name be?
13:36:38 <xinming> Cale: gropu is already taken. >_<
13:36:53 <kpreid> @type unfoldr
13:36:54 <byorgey> > let t [] = Nothing; t xs = Just $ splitAt 3 xs in unfoldr t [1..10]
13:36:55 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:36:56 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
13:37:13 <Cale> > let chunk n xs = takeWhile (not . null) . iterate (take n . drop n) in chunk 2 ['a'..'z']
13:37:14 <lambdabot>  Add a type signature
13:37:17 <ddarius> chunk is usually the name.
13:37:24 <Cale> > let chunk n xs = takeWhile (not . null) . iterate (take n . drop n) $ xs in chunk 2 ['a'..'z']
13:37:26 <lambdabot>  ["abcdefghijklmnopqrstuvwxyz","cd"]
13:37:30 <Cale> er...
13:37:41 <Cale> > let chunk n xs = takeWhile (not . null) . map (take n) . iterate (drop n) $ xs in chunk 2 ['a'..'z']
13:37:42 <lambdabot>  ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz"]
13:37:47 <Cale> there we are :)
13:37:51 <Cale> > let chunk n xs = takeWhile (not . null) . map (take n) . iterate (drop n) $ xs in chunk 3 ['a'..'z']
13:37:53 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
13:38:00 <kpreid> > map (head &&& length) . group . sort . map (\g -> randomIndex g [1,2,3,4]) $ unfoldr (Just . split) (mkStdGen 0)
13:38:04 <lambdabot> Terminated
13:38:20 <xinming> Cale: Is chunk a good name?
13:38:27 <Cale> xinming: Why not? :)
13:38:28 <kpreid> > map (head &&& length) . group . sort . map (\g -> randomIndex g [1,2,3,4]) $ take 4000 $ unfoldr (Just . split) (mkStdGen 0)
13:38:29 <lambdabot>  [(1,1015),(2,940),(3,1051),(4,994)]
13:38:35 <kpreid> there we go
13:38:37 <Ben`> I've made a random gen like this "dice = getStdRandom (randomR (1,6))", how can I make a list which contains 10 random numbers made by dice?
13:38:45 <Cale> xinming: It's not already taken, at least.
13:38:46 <bwwx> hm.... how do i solve cyclic imports?
13:38:53 <xinming> Cale: Ok, thanks for the name. :->
13:38:57 <Cale> xinming: Or something like splitInto
13:39:02 <kpreid> @let stdGens = unfoldr (Just . split) (mkStdGen 0)
13:39:07 <lambdabot> Defined.
13:39:10 <byorgey> > let chunk n xs = unfoldr (\lst -> case lst of [] -> Nothing; xs -> Just $ splitAt n xs) xs in chunk 3 [1..10]
13:39:11 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
13:39:18 <xinming> I want a name which is short, and sweet. :-D
13:39:20 <Cale> Except that seems to have the flavour of asking for the number of pieces to split it into
13:39:21 <xinming> chunk is ok
13:39:25 <Cale> rather than the size
13:39:27 <byorgey> ^^^ there's another implementation using unfoldr
13:39:28 <lament> where do @let definitions go?
13:39:35 <kpreid> Ben`: take 10 (randoms dice) -- but don't use dice again
13:39:51 <xinming> I don't like to make really good function with a really_long_name
13:39:54 <Cale> lament: Into a temporary file which is imported qualified using L
13:40:05 <kpreid> Cale: it's not qualified any more
13:40:08 <Cale> oh
13:40:32 <lament> and it's deleted when lambdabot restarts?
13:40:44 <Cale> Not usually, I don't think.
13:40:45 <kpreid> it's deleted whenever someone does @undefine
13:40:46 <bwwx> longest function name i've seen in real code is sourceLanguagesManagerGetLanguageFromMimeType
13:40:50 <Cale> But people often clear it.
13:41:08 <olsner> Lie groups seem to be another one of those abstractions that say almost nothing but apply to almost everything
13:41:25 <xinming> bwwx: what does that mean?
13:41:34 <ddarius> olsner: Lie groups, not so much.
13:41:49 <ddarius> Very common in physics and related fields though.
13:42:09 <Cale> AbelianNumberFieldByReducedGaloisStabilizerInfo
13:42:11 <Ben`> kpreid: I couldn't get that to work
13:42:44 <ddarius> :t gotStdRandom
13:42:47 <lambdabot> Not in scope: `gotStdRandom'
13:42:47 <ddarius> :t getStdRandom
13:42:49 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
13:42:57 <Cale> CanonicalRepresentativeDeterminatorOfExternalSet
13:43:04 <bwwx> xinming: it's from gtk2hs
13:43:07 <ddarius> Ben`: replicateM 10 dice
13:43:21 <olsner> some kind of abstraction/refining of ordinary matrices it seems... at least a rotation matrix is a Lie group as far as I've understood things
13:43:23 <Cale> hehe, GAP has some really long identifiers in its library :)
13:43:36 <Cale> olsner: not a single one
13:43:41 <lament> yay for autocompletion
13:43:47 <Cale> olsner: The set of rotation matrices is a Lie group
13:43:50 <olsner> or the set of all rotation matrices are one lie group?
13:43:53 <Cale> yes
13:43:55 <olsner> ;-)
13:44:02 <bwwx> xinming: it's a binding to the c function, gtk_source_language_manager_get_language_from_mime_type
13:44:27 <xinming> ...
13:45:02 <ddarius> bwwx: Doesn't that mean that gtk_source_language_manager_get_language_from_mime_type is the longest identifier in real code that you've seen then?
13:45:11 <xinming> luckily, the auto completion feature when we are doing edit is really handy.
13:45:25 <bwwx> ddarius: no, before i was talking only about haskell code. i've seen much longer things in other languages
13:45:45 <ddarius> bwwx: Ah.
13:46:15 <Toxaris> > unfoldr (uncurry (>>) . (guard . not . null . fst &&& return) . splitAt 3) ['a' .. 'z'] -- as always, too late :(
13:46:16 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
13:46:33 <elliottt> > take 10 . concat . repeat $ [1,2,3]
13:46:35 <lambdabot>  [1,2,3,1,2,3,1,2,3,1]
13:47:00 <Ben`> ddarius: what module is replicateM in?
13:47:08 <ddarius> @index replicateM
13:47:08 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:47:22 <ddarius> @hoogle replicateM
13:47:22 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
13:47:23 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
13:47:29 <Ben`> ah
13:47:31 <Ben`> thanks
13:48:39 <Nucleo_> I think this might be a bit of a big topic, but is there any ready code out there for fast prime generation in Haskell?
13:48:46 <Nucleo_> best I've found so far is the page on the Haskell Wiki.
13:49:14 <kuribas> > let {unfoldList f l = case (f l) of {(l, []) -> [l]; (l, l') -> l:unfoldList f l'}} in unfoldList (splitAt 3) ['a'..'z']
13:49:16 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
13:49:46 <Ben`> in ghci how can I load two modules? when I do ":m <module>" it comes out of the other one
13:49:47 <ddarius> Nucleo_: I don't think there are any hardcore versions.
13:50:17 <Nucleo_> ddarius: ahh. I don't quite know enough math to code up my own, unfortunately.
13:50:20 <elliottt> ?hoogle Handle -> [String]
13:50:20 <lambdabot> No matches, try a more general search
13:50:20 <ddarius> :m +
13:50:31 <Ben`> ddarius: thanks again
13:51:02 <kuribas> It would be nice to have something like unfoldList in the prelude.
13:51:08 <Toxaris> kuribas: unfoldList is a nice idea, but I would define it in terms of unfoldr in the hope of being fusion-friendly
13:51:11 <Cale> > let stripes n xs = [[x | (n,k) <- zip [0..] xs, k `mod` n == l] | l <- [0..n-1]] in stripes 5 ['a'..'z']
13:51:12 <lambdabot>   Not in scope: `x'
13:51:16 <elliottt> ?hoogle Handle -> IO [String]
13:51:17 <lambdabot> No matches, try a more general search
13:51:18 <Cale> > let stripes n xs = [[x | (k,x) <- zip [0..] xs, k `mod` n == l] | l <- [0..n-1]] in stripes 5 ['a'..'z']
13:51:20 <lambdabot>  ["afkpuz","bglqv","chmrw","dinsx","ejoty"]
13:51:30 <lament> heh
13:52:10 <kuribas> Toxaris: That would be a good idea.  I have no idea how to make something fusion friendly :)
13:52:28 <ddarius> > transpose . tails $ [1,2,3]
13:52:29 <lambdabot>  [[1,2,3],[2,3],[3]]
13:52:44 <Toxaris> kuribas: me neither, but using existing combinators should help, I suppose
13:52:55 <ddarius> > tails [1,2,3]
13:52:56 <lambdabot>  [[1,2,3],[2,3],[3],[]]
13:53:20 * gogonkt- is away: sleep
13:53:28 <Cale> heh, that's a rather expensive way to remove the empty list from the end :)
13:53:37 <ddarius> Cale: That's exactly what I was thinking.
13:54:05 <Toxaris> kuribas: actually, there is something called "fold/unfold"-fusion :) but who knows whats actually implemented in ghc, these "we implemented this extension as part of the ghc compiler" in papers doesn't really help (no, i'm not A.C. from haskell-cafe)
13:54:31 <ddarius> Toxaris: The source help.
13:54:38 <ddarius> s/help/helps
13:54:55 <Toxaris> ddarius: source of ghc? is it "easy to read"?
13:55:10 <ddarius> Actually all the fusion stuff is implemented in a library.
13:55:15 <ddarius> or rather in the libraries.
13:55:28 <ddarius> The user manual also has a section on fusion.
13:55:49 * Toxaris plans to grep it's library folder for "RULE"
13:55:50 <Cale> Stream fusion for lists is not there yet, but it's coming. :)
13:56:04 <Cale> Ordinary foldr/build fusion is already there.
13:56:13 <ddarius> Toxaris: You can just run GHC on some examples and have it dump the rules that fired.
13:56:24 <ddarius> foldr/build has been there for a long long time.
13:56:47 <Toxaris> ddarius: so foldr/build means it's a good idea to use foldr and unfoldr to express functions over lists?
13:57:08 <ddarius> Toxaris: The user manual tells you what is a good idea.
13:57:16 <Toxaris> ok :)
13:57:43 <ddarius> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id3159016
13:57:45 <lambdabot> Title: 7.11. Rewrite rules, http://tinyurl.com/y7rk9g
13:57:56 <Toxaris> but kuribas, I think what we really need is not special versions of unfoldr, but nice combinators to help using unfoldr
13:58:21 <Toxaris> like   p `guarding` x = if p x then mzero else return x
13:59:12 <kuribas> What would it become then?
13:59:16 <Toxaris> so we can say   unfoldList f = unfoldr ((not . null . snd `guarding`) . f)
13:59:25 <desp> @hoogle ShowS
13:59:25 <lambdabot> Prelude.ShowS :: type ShowS
13:59:25 <lambdabot> Prelude.shows :: Show a => a -> ShowS
13:59:25 <lambdabot> Numeric.showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
13:59:36 <Toxaris> wich is not really easy, but fit's on one line
14:00:21 <HWSOD> @hoogle Int -> (a -> a) -> (a -> a)
14:00:22 <lambdabot> No matches, try a more general search
14:00:39 <kuribas> Toxaris: that would be nice, though I have wanted a function unfoldList many times.
14:00:55 <Cale> For most cases, I'd really rather have  unfoldr f p g = map f . takeWhile p . iterate g
14:00:57 <ddarius> :t (foldr (.) id .) . replicate
14:01:02 <lambdabot> forall a. Int -> (a -> a) -> a -> a
14:01:24 <ddarius> The Maybe version is better.
14:01:33 <Cale> Most of the useful applications of unfoldr turn out to be that, and the two things are equivalent.
14:01:36 <ddarius> And you can implement that version over top the Maybe version.
14:01:44 <Cale> They're co-implementable
14:01:53 <ddarius> Cale: To go the other way requires double testing if I recall correctly.
14:02:32 <Cale> hmm
14:02:40 <osfameron> mauke: oh, a.out... that was obvious :-)  ta!
14:03:05 <HWSOD> > ((foldr (.) id .) . replicate) 2 (*2) 3
14:03:06 <lambdabot>  12
14:03:27 <HWSOD> Thanks!
14:05:51 <ddarius> :t unfoldr
14:05:53 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:06:03 <ddarius> :t let unfoldr' f p g = map f . takeWhile p . iterate g
14:06:05 <lambdabot> <command line>:
14:06:05 <lambdabot>     Could not find module `L':
14:06:08 <ddarius> :t let unfoldr' f p g = map f . takeWhile p . iterate g in unfoldr'
14:06:10 <lambdabot> forall a b. (a -> b) -> (a -> Bool) -> (a -> a) -> a -> [b]
14:06:57 <HWSOD> > (\n -> (!! n) . iterate) (*2) 3
14:06:57 <lambdabot>  Couldn't match expected type `[a]'
14:07:19 <ddarius> unfoldr' f p g = unfoldr (\b -> if p b then Just (f b, g b) else Nothing)
14:07:47 <Toxaris> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ ['a' .. 'z']
14:07:48 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
14:08:24 * Toxaris decides to use iterate more often
14:08:47 <ddarius> unfoldr f = unfoldr' (fst . fromJust . f) (isNothing . f) (snd . fromJust . f)
14:08:59 <lament> :t flip (flip . ((!!) .) . iterate)
14:09:01 <ddarius> :t isNothing
14:09:01 <lambdabot> forall a. Int -> (a -> a) -> a -> a
14:09:03 <lambdabot> forall a. Maybe a -> Bool
14:09:07 <lament> flip (flip . ((!!) .) . iterate) 2 (*2) 3
14:09:11 <lament> > flip (flip . ((!!) .) . iterate) 2 (*2) 3
14:09:12 <lambdabot>  12
14:09:38 <ddarius> :t let unfoldr' f p g = map f . takeWhile p . iterte g in unfoldr' (fst . fromJust . f) (isNothing . f) (snd . fromJust . f)
14:09:40 <lambdabot> Not in scope: `iterte'
14:09:40 <lambdabot>  
14:09:40 <lambdabot> <interactive>:1:82: Not in scope: `f'
14:09:47 <ddarius> :t let unfoldr' f p g = map f . takeWhile p . iterate g in unfoldr' (fst . fromJust . f) (isNothing . f) (snd . fromJust . f)
14:09:48 <lambdabot> Not in scope: `f'
14:09:49 <lambdabot>  
14:09:49 <lambdabot> <interactive>:1:99: Not in scope: `f'
14:09:57 <ddarius> :t let unfoldr' f p g = map f . takeWhile p . iterate g in \f -> unfoldr' (fst . fromJust . f) (isNothing . f) (snd . fromJust . f)
14:09:59 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
14:11:47 <ddarius> The Maybe version is the right way to go (for more than one reason).
14:11:57 <ddarius> Having the other version as well is okay though.
14:13:16 <Cale> I think you can save on the double testing by modifying the seed.
14:14:38 <ddarius> Cale: It's not unusual for the f, p and g functions to share code.
14:14:44 <ddarius> Or to calculate some of the same values.
14:15:39 <ddarius> And at any rate, Maybe . (a,) is the signature for [a] and so unfoldr perfectly fits the mold of the coalgebra unfold.
14:15:43 <bwwx> is it possible to import the current module, using an "as" clause, to save typing on identifiers that conflict with another imported module?
14:16:35 <lament> bwwx: import the other module as qualified
14:17:20 <ivant> @instances StateT
14:17:21 <bwwx> lament: but i want to be able to use other functions from the other module unqualified
14:17:28 <lambdabot> Couldn't find class `StateT'. Try @instances-importing
14:17:39 <lament> bwwx: do you need both versions of conflicting functions?
14:17:52 <Toxaris> bwwx: are you aware that you can import the other module twice?
14:17:59 <kjdf> is it possible to import module twice? as in 'import A (f); import qualified A' ?
14:18:07 <kjdf> nm :)
14:18:13 <Saizan> bwwx: import OtherModule hiding (<conflicting functions>)\n import qualified OtherModule
14:18:18 <bwwx> i need both versions of the conflicting functions
14:18:20 <ddarius> :t let foldr' f = foldr (f Nothing) (curry (f . Just)) in foldr'
14:18:21 <lambdabot>     Occurs check: cannot construct the infinite type:
14:18:22 <lambdabot>       b = a1 -> b1 -> a -> b -> b
14:18:47 <mauke> bwwx: then reimporting parts of yourself won't help
14:18:54 <mauke> the original definitions are still in scope
14:18:56 <Saizan> bwwx: so you've the non-conflictiong functions in scope non-qualified
14:19:13 <ddarius> :t \f -> uncurry (f . Just)
14:19:14 <lambdabot> forall a b c. (Maybe a -> b -> c) -> (a, b) -> c
14:19:36 <ddarius> :t \f -> curry (f . Just)
14:19:38 <lambdabot> forall c a b. (Maybe (a, b) -> c) -> a -> b -> c
14:20:02 <ddarius> :t let foldr' f = foldr (curry (f . Just)) (f Nothing) in foldr'
14:20:04 <lambdabot> forall a c. (Maybe (a, c) -> c) -> [a] -> c
14:21:42 <ivant> what would happen if I raise an exception in (StateT SomeState IO) (when I evalState it)? would I just catch the exception up there immediately?
14:36:07 <bwwx> is there a mapM_ for Data.Map?
14:37:16 <elliottt> fromList . map . toList
14:37:17 <elliottt> ?
14:37:28 <ddarius> bwwx: It's probably an instance of Foldable and/or Traversable
14:37:32 <ddarius> @src Traversable
14:37:32 <lambdabot> class (Functor t, Foldable t) => Traversable t where
14:37:32 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
14:37:32 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
14:37:32 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
14:37:32 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
14:38:54 <ddarius> @src Foldable
14:38:55 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:39:53 <Tchakkazulu> Hey, about that Traversable module.
14:40:05 <Tchakkazulu> sequenceA :: Applicative f => t (f a) -> f (t a), and sequence :: Monad m => t (m a) -> m (t a)
14:40:13 <Tchakkazulu> Aren't Monads Applicative as well?
14:40:19 <Cale> Unfortunately Traversable doesn't have sequence_ and mapM_
14:40:20 <Tchakkazulu> So those are the same functions, basically?
14:40:25 <ddarius> Foldable does though.
14:40:32 <ddarius> :t Data.Foldable.mapM_
14:40:34 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Foldable.Foldable t) => (a -> m b) -> t a -> m ()
14:40:38 <Cale> ah, okay
14:41:00 <Cale> I suppose that makes sense :)
14:41:15 <Cale> hmm...
14:41:24 <ddarius> Tchakkazulu: Yes, except sequenceA is more general.
14:41:57 <Tchakkazulu> Oh, it's with this lazyness of people that do not want to define an instance of Functor, Applicative _and_ Monad, if they write a monad.
14:41:59 <ddarius> @instances Foldable
14:42:00 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
14:42:09 <ddarius> @instances-importing Data.Map Foldable
14:42:10 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
14:42:34 <Toxaris> I don't think monads are applicative in the Haskell sence of typeclass hierarchy
14:42:34 <ddarius> Tchakkazulu: Monads were around before Applicative functors.
14:42:52 <ddarius> Functors on the other hand...
14:43:35 <Toxaris> given enough -fwhathever-instances flags, a fall-back instance Monad x => Applicative x where ... should solve that problem, shouldn't it?
14:44:07 <Tchakkazulu> Applicative defines <*>, which is exactly Monad's app.
14:44:32 <Tchakkazulu> And <$>, which is Functor's fmap, and Monad's liftM.
14:45:35 <Cale> I don't know how much I trust the -fwhatever-instances flags.
14:45:50 <Cale> -fallow-incoherent-instances is certainly very evil.
14:46:04 <Cale> You can defeat referential transparency with it.
14:46:15 <Cale> (and ST)
14:47:06 <Cale> -fallow-overlapping-instances isn't so bad, but it does seem to go against the grain a bit, with classes being open.
14:47:50 * ddarius doesn't even know what -fallow-incoherent-instances does, and despises -fallow-overlapping-instances.
14:48:30 <olsner> -fallow-everything
14:48:58 <ddarius> -fallow-the-Elder-Gods-into-this-world
14:49:21 <Tchakkazulu> -fallow-overlapping-instances is when you define, for example instance SomeClass Maybe where ..., and also instance Functor f => SomeClass f, right?
14:49:44 <Tchakkazulu> And usually the compiler would complain because it wouldn't know which instance to use when it encounters a Maybe in a class' methods.
14:50:31 <Saizan> for instance Foo a => Bar a you also need undecidable-instances
14:50:56 <ddarius> Especially, for instance Bar a => Bar a
14:51:05 <Tchakkazulu> Ah, yes. That gets tricky.
14:51:16 <Tchakkazulu> Because you may have instance Bar a => Foo a.
14:51:58 <Saizan> yeah, you can construct a non-terminating typelevel program :)
14:52:12 <Cale> -fallow-incoherent-instances (which implies overlapping) will stop GHC from worrying about whether a more specific instance might apply once some additional type variables get nailed down.
14:52:36 <Cale> For example, if you have an instance C [a] and an instance C [Int]
14:52:58 <Cale> and apply a method of the class at the type [a], then it will just pick that instance
14:53:10 <Cale> rather than worrying about whether in some case a = Int
14:53:37 <Cale> (with just overlapping instances, it would just complain)
14:54:00 <Tchakkazulu> But if it's known, by an explicit type signature or otherwise, that a = Int, then it uses the [Int] one, or does it completely ignore the [Int] instance?
14:54:10 <Tchakkazulu> (compile-time known)
14:54:25 <Cale> Right, if it's known in the scope of the application.
14:55:07 <Saizan> application?
14:55:18 <Toxaris> Cale: so wich instance is chosen depends one details of the type inference process and is therefore influenced by otherwise unrelated context (it depends on when some constraint is resolved, not how it is resolved)?
14:55:22 <Cale> For example, if you're writing a polymorphic function, it won't actually know whether a = Int
14:56:12 <Cale> (even though it might know this at some of the call sites of that polymorphic function)
14:57:14 <Cale> So -fallow-incoherent-instances allows you to write polymorphic functions which use (only) the polymorphic instance, even when more specific instances might apply (those will just be ignored in that context).
14:58:57 <wli> In both cases, however, it's difficult for humans to predict which instance will get used.
15:00:09 <Cale> oleg has used incoherent instances to define an instance of (Typeable a), and then used it to break the security of the ST monad.
15:00:44 <Cale> Which means that you can export STRefs and totally break referential transparency :)
15:00:49 <wli> Sounds like evaluation order of IO will then become nondeterministic.
15:01:02 <wli> At least in the ST RealWorld interpretation.
15:01:53 <Cale> Well, that's not so much the problem as being able to have mutable variables in pure code.
15:02:06 <olsner> wow, that's type hacking in the other sense of the word
15:02:21 <mrd> like having mutants in normal society
15:02:36 <mrd> gotta keep them in the sewers!
15:02:39 <Cale> You create a top-level STRef
15:03:07 <Cale> by wrapping an STRef up in fromDyn
15:03:21 <Cale> (which you're allowed to because there's an instance of Typeable for any type now :)
15:03:24 <mrd> by deriving typeable for st?
15:03:31 <Cale> (Typeable a)
15:03:34 <mrd> oh
15:03:56 <ddarius> Cale: Doesn't this essentially just make unsafeCoerce?
15:04:09 <sjanssen_> sounds like it
15:04:10 <Cale> Basically, yeah.
15:04:22 <Tchakkazulu> Top-level STRef sounds like the unsafePerformIO ioRef abuse.
15:04:27 <sjanssen_> polymorphic references are the first step (this is just like unsafePerformIO+IORef
15:04:47 <Tchakkazulu> :)
15:04:50 <Toxaris> mrd: mutants are no problem, me and my friends can free the city of them if you promise me 200 gold and a nice amulet as reward
15:05:07 <ddarius> Simply having a "universal" instance of Typeable should be about the same as having unsafeCoerce.
15:05:31 <Tchakkazulu> instance a => Typable a would break things.
15:05:43 <mrd> I was shooting for the futurama interpretation of monads there
15:05:46 <Cale> instance Typeable a where
15:05:46 <Cale>    typeOf _ = mkTyConApp (mkTyCon "Anything goes") []
15:05:52 <ddarius> Heroes are no problem, me and my mutants can free the city of them if you promise me 199 gold and a nice amulet as a reward.
15:07:08 <bwwx> how can you have a top level STRef?
15:07:31 <augustss> bwwx: why would you want to? :)
15:08:24 <Cale> With anything short of incoherent instances, that instance decl is useless
15:08:25 <wli> I'm more concerned with brushing up on or improving things I learned in college than innovating here... monads, GADT's, TH, arrows, etc. are enough for me.
15:10:10 <augustss> hi andy
15:12:06 <Tchakkazulu> That Dynamic stuff looks tricky.
15:12:32 <wli> augustss: You beat me to the punch with the Mersenne Twister.
15:13:51 <wli> augustss: I suppose you at least left me the task of wrapping it up in a monad transformer. ;)
15:17:15 <olsner> Cale: how do you explain weather using foldr?
15:17:53 <osfameron> is a foldr like a warm front and a foldl like a cold front?
15:18:13 <osfameron> how do I convert Char '1' to Int 1 ?
15:18:21 <chessguy> @type ord
15:18:23 <lambdabot> Char -> Int
15:18:34 <Saizan> digitToInt
15:18:36 <ddarius> @hoogle Char -> Int
15:18:36 <lambdabot> Char.digitToInt :: Char -> Int
15:18:36 <lambdabot> Char.ord :: Char -> Int
15:18:45 <olsner> > (ord . (- ord '0')) '1'
15:18:46 <lambdabot>  Couldn't match expected type `a -> Char'
15:18:54 <mauke> > digitToInt '1'
15:18:55 <lambdabot>  1
15:18:55 <olsner> me sucks
15:19:08 <ddarius> digitToInt 'a'
15:19:11 <ddarius> > digitToInt 'a'
15:19:13 <lambdabot>  10
15:19:13 <osfameron> digitToInt is rather nicer, thanks!
15:19:18 <ddarius> > digitToInt '?'
15:19:19 <mauke> > read . return $ '1' :: Int
15:19:19 <lambdabot>  Exception: Char.digitToInt: not a digit '?'
15:19:20 <lambdabot>  1
15:19:25 <sjanssen> > digitToInt 'f'
15:19:26 <lambdabot>  15
15:19:29 <osfameron> Not in scope: `ord'
15:19:37 <mauke> @index ord
15:19:37 <lambdabot> Data.Char
15:19:39 <ddarius> @index ord
15:19:39 <lambdabot> Data.Char
15:19:49 <osfameron> how do I use Data.Char in ghci?
15:19:57 <mauke> :m +Data.Char
15:20:30 <osfameron> could I submit a bug report for the fact that ghci doesn't understand "import Data.Char" ?
15:20:33 <osfameron> mauke: thanks
15:20:43 <mauke> no, you can't use import in expressions
15:21:25 <osfameron> mauke: and it is more important that ghci only evaluate expressions than that it's usable? ;-)
15:21:34 <wli> Cayenne had a nice solution to the Haskell module crisis. ;)
15:21:47 <Toxaris> bug report /= feature request
15:21:49 <sjanssen> wli: oh?
15:22:00 <chessguy> crisis?
15:22:26 <Toxaris> chessguy: yes, it's Pure.Heroes against IO.Unsafe.Mutants
15:22:35 <Mr_Awesome> which gui system would you recommend me?
15:22:38 <Japsu> ;DD
15:22:56 <chessguy> @where gtk2hs
15:22:56 <lambdabot> http://haskell.org/gtk2hs/
15:23:26 <wli> sjanssen: Yeah, something to do with modules as records or vice-versa. I never understood it, and never had a Lazy ML compiler to try it out with, but the example code was quite slick.
15:23:49 <Saizan> "first class modules"
15:24:08 <Mr_Awesome> chessguy: thanks :)
15:24:21 <olsner> no reason for anything to be second class really
15:24:36 <olsner> it's gotta be first class in the compiler anyway
15:25:00 <Toxaris> olsner: not even types?
15:25:29 <Saizan> simpler systems are easier to manage
15:26:26 <olsner> I say remove almost all limits of the type system and replace it with something more like prolog or C++ templates
15:26:36 <wli> I'm not fully cognizant of compiler implementation issues. I'll settle for wishing for a more expressive module system.
15:26:50 <Toxaris> is a first class module like an ordinary module wich exports a function wich returns a record wich contains functions with rank-2-types?
15:27:25 <olsner> never mind a type checker/inferer for such a system isn't guaranteed to terminate
15:28:53 <wli> olsner: I'd be fine with that. Just have the type inference engine barf after too many iterations with options to jack up the iterations and enough reporting to drop in explicit typing where that fails. Only thing is, the checker actually needs to get somewhere; only the inference can really be allowed to puke like that.
15:29:48 <olsner> yeah, inference would be TC, run until completion or barf, and then the type checker should be guaranteed to terminate
15:30:32 * wli cheers on augustss from the sidelines and/or peanut gallery.
15:31:38 <olsner> and types should be able to involve values, so that you can build things like bounded types and other things with constants without involving peano arithmetic
15:32:49 <wli> olsner: Ever tried Cayenne?
15:32:55 <olsner> nope
15:33:15 <olsner> I just went from C++ to #haskell
15:33:29 <wli> olsner: I was too stupid to get it set up. It seems to has a fair number of the things you're on about.
15:33:33 <Toxaris> olsner: if types can contain values, they can contain computed values, too? so how can type checking always terminate?
15:33:57 <Toxaris> olsner: or only constants?
15:34:24 <chessguy> Toxaris, you'll appreciate this:
15:34:26 <chessguy> @type \piece newpiece -> guard (?atEnemiesHome piece) >> ?destroy piece >> ?create newpiece (?location piece)
15:34:28 <lambdabot> forall (m :: * -> *) a t t1 b t2. (?atEnemiesHome::t2 -> Bool, ?destroy::t2 -> m a, ?create::t -> t1 -> m b, ?location::t2 -> t1, MonadPlus m) => t2 -> t -> m b
15:34:30 <olsner> don't computed values in a pure language have to be either functions, or something computed from other constants (i.e. constant)?
15:35:21 <cpst> when will the exponential merge problem be fixed?
15:35:39 <cpst> oops, wrong chan
15:36:24 <Toxaris> olsner: or bottom
15:36:26 <augustss> wii: you no longer need LML to compile and run Cayenne.  ghc works fine now.
15:36:39 <wilx> When somebody thinks up better algo/patch theory that does not require exponencial amount of work? :)
15:37:09 <cpst> wilx: it would have been nice if they did that before writing it :)
15:37:11 <wli> augustss: Awesome! I've not looked in the better part of a decade, so I should've looked before going on about it.
15:37:19 <shapr> wilx: Go for it
15:37:26 <olsner> Toxaris: yes, but you can do stuff like limit the number of recursions allowed in the type inferer, so that it always terminates (with success or recursion-too-deep error)
15:37:28 <shapr> cpst: Of course, at that rate, it might never have been written.
15:37:49 <olsner> which rarely gives any problems for C++ templates
15:37:53 <wilx> Heh, I don't think so. I am lousy scientist/researcher.
15:37:59 <Toxaris> olsner: ok, so typechecking gives on of [ok, timeout, typeerror]?
15:38:05 <olsner> yep
15:38:09 <Toxaris> sounds good for me
15:38:55 <olsner> (still, you could argue that looping in type inference is a programmer error of the same kind as writing a non-terminating ordinary program)
15:38:59 <augustss> Toxaris: it's ok from a practical point of view
15:39:18 <Toxaris> a prolog-style type system would allow the non-olegs to write type-level programs, too :)
15:39:42 <augustss> prolog-style?  but prolog is dynamically typed
15:40:00 <wli> Mercury-style, if you will. ;)
15:40:10 <augustss> well, that's totally different
15:40:13 <Toxaris> I mean prolog *as* type system
15:40:22 <olsner> the type system can be dynamically typed, but still produce statically typed types :P
15:40:55 <Toxaris> a dynamically kinded type system
15:41:33 <augustss> Toxaris: but haskell almost has prolog as the type system.  just no backtracking
15:41:54 <Toxaris> with prolog-style, I mean somewhat user-controlled unification, backtracking, operational semantics clear for humans, syntactic sugar, ...
15:42:20 <Toxaris> ... turing completeness ...
15:42:42 <Toxaris> ... and so on. a real language, not just something you can do *type hackery* with
15:42:45 <chessguy> @type guar
15:42:47 <chessguy> @type guard
15:42:53 <lambdabot> Not in scope: `guar'
15:42:55 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:42:57 <Toxaris> but I assume this wouldn't be Haskell anymore
15:43:03 <Toxaris> so it's not the way for Haskell to go
15:43:21 <Toxaris> but maybe an option for yet another research langauge
15:43:28 <chessguy> why does guard require MonadPlus, and not just Monad?
15:43:50 <Cale> chessguy: Because it uses mzero
15:43:57 <chessguy> @src guard
15:43:57 <lambdabot> guard True  =  return ()
15:43:57 <lambdabot> guard False =  mzero
15:43:58 <sjanssen> chessguy: because MonadZero died
15:43:59 <Toxaris> chessguy: because it returns mzero instead of using that stupid fail wich shouldn't exist
15:43:59 <Cale> Really it requires MonadZero
15:44:01 <chessguy> good reason
15:44:34 <Cale> All the things which express failure using Monad should really be fixed to use MonadPlus
15:44:43 <chessguy> @instances-importing MonadPlus
15:44:43 <Cale> (or MonadZero when it comes back)
15:44:44 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
15:45:54 <chessguy> ugh, i hate that feeling where i just know ghc is WAY smarter than i am
15:46:08 <Toxaris> given the number of things wich "should really be fixed" but aren't because of existing code, it looks like Haskell needs some tool support for upgrading the standard library...
15:46:20 <Cale> yep
15:46:25 <Cale> It's a lot of work too
15:48:41 <beelsebob> :/
15:48:47 <beelsebob> tis a worrying pattern actually
15:49:00 <beelsebob> most of Haskell seems to be a certain way to suit some random bit of code
15:49:07 <beelsebob> not because it's actually part of the standard
15:49:12 <sjanssen> all languages have their "hysterical raisins"
15:49:29 <sjanssen> Haskell only has a few (Functor/Monad, Monad's fail)
15:49:39 <beelsebob> true, but I've never met another language where there's no tools because a tool for the language would be useles simply because no one actually uses the language
15:49:45 <sjanssen> maybe seq
15:50:08 <Mr_Awesome> has anyone managed to get fudgets to compile on ubuntu?
15:52:38 <Nafai> What's fudgets?
15:52:43 <osfameron> Toxaris: true, I guess maybe I think it's a doc bug that :? gives the helpful "set the context for expression evaluation" and no example of usage.  Also it seems unintuitive that "import ..." doesn't, but maybe it would be a feature request instead as you say.
15:53:37 <MarcWeber> @tell conal Are you online? Is your pan darcs repo broken?  http://www.cse.unsw.edu.au/~sseefried/darcs/pan (Failed to download URL http://www.cse.unsw.edu.au/~sseefried/darcs/pan/_darcs/hashed_inventory : HTTP error (404?))
15:53:38 <lambdabot> Consider it noted.
15:53:54 <augustss> Nafai: http://en.wikipedia.org/wiki/Fudgets
15:53:55 <lambdabot> Title: Fudgets - Wikipedia, the free encyclopedia
15:55:10 <Toxaris> chessguy: these ?param things in your chess code are implicit parameters? but since you work in some monad anyway, wouldn't it be easier (in terms of understanding what happens) to define these operations as monadic actions? or are implicit parameters more flexible (never used them)
15:55:46 <chessguy> Toxaris, they are implicit parameters, and i only use them for playing around with figuring out types
15:57:25 <Toxaris> chessguy: oh ok. yes, then I like it :)
15:59:25 <glguy> Toxaris: its a pleasant alternative to having to rewrite a whole stack of functions into monadic code
15:59:31 <glguy> in certain situations at least
15:59:44 <glguy> when all you really need is to put some value in scope
16:00:06 <ddarius> As is unsafePerformIO.
16:00:18 <glguy> yeah, and it maintains purity
16:00:29 <glguy> since implicit params go into the type sig
16:04:34 <Toxaris> so implicit parameters can be seen as a syntax-enhanced Reader monad?
16:04:53 <dylan> It's great. I learned about some of the most unique comedy I've seen lately from the haskell blog aggregator. :)
16:05:02 <glguy> dylan: link?
16:05:27 <dylan> http://www.serpentine.com/blog/2007/08/08/modern-irish-comedy-in-bite-sized-nuggets/, on Bryan O'Sullivan's blog.
16:05:30 <lambdabot> Title: teideal glic deisbhÃ©alach » Blog Archive » Modern Irish comedy in bite-sized nu ..., http://tinyurl.com/3dku9r
16:06:20 * glguy met bos in person during OSCON
16:06:30 <dylan> I want to do something like soupy norman, except take a soap opera and redo the dialog as if it was a scifi movie.
16:06:34 * wli too.
16:06:43 * glguy met wli in person at oscon :)
16:06:55 <glguy> during, rather
16:06:58 <dylan> ah, so that's who bos is.
16:07:07 <glguy> bryan o'sullivan
16:07:17 <dylan> I didn't know if bryan was an IRC person or just a weblog person
16:07:29 <ddarius>  /whois bos
16:07:38 <sorear> /who *bryan*
16:09:02 * Toxaris is a real-life person going to bed now
16:09:06 <Toxaris> bye
16:09:06 <dylan> it's really weird. I was just looking up the RTÃ stream, and in another tab I was reading over my feeds... I didn't read the title, but saw RTÃ, and was like... "Monkeys, what's that?"
16:11:09 <dylan> it's almost as weird as getting a job that involves Asterix and seeing that mentioned in CosmicRay's blog the next day.
16:11:41 <glguy> so are these soupy normal episodes dubbed?
16:11:47 <glguy> norman*
16:13:24 <dylan> you didn't read the gist of it?
16:13:35 <dylan> a polish soap opera is taken, and irish comedians ad-lib the words.
16:13:48 <glguy> That would have made more sense :)
16:13:52 <glguy> I saw the link
16:13:53 <glguy> clicked it
16:13:57 <dylan> Ah. :)
16:13:57 <glguy> started watching...
16:14:06 <dylan> it's great! "We didn't have wires..."
16:14:15 <glguy> yeah, that explains a lot
16:17:37 <oerjan> i cannot see you mentioning my name in the logs since i was last on
16:17:47 <oerjan> (wrong channel)
16:20:09 <chessguy> @go asterix
16:20:10 <lambdabot> http://en.wikipedia.org/wiki/Asterix
16:20:10 <lambdabot> Title: Asterix - Wikipedia, the free encyclopedia
16:21:20 <bwwx> @seen dcoutts
16:21:20 <lambdabot> I saw dcoutts leaving #ghc, #haskell-overflow, #haskell and #gentoo-haskell 13h 20m 21s ago, and .
16:22:04 <bwwx> @src mapM_
16:22:04 <lambdabot> mapM_ f as = sequence_ (map f as)
16:22:15 <bwwx> @src mapM
16:22:16 <lambdabot> mapM f as = sequence (map f as)
16:22:32 <bwwx> @src sequence_
16:22:32 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
16:37:55 <osfameron> I'm trying to solve Project Euler 10: Find the sum of all the primes below one million.
16:38:02 <osfameron> which I'm trying to do with:  sum $ takeWhile (<1000000) (primes [2..])
16:38:23 <osfameron> but 25 minutes on, I'm wondering if this is the best approach :-)
16:38:43 <glguy> osfameron: if it takes longer than 1 minute to run a solution to any project euler program
16:38:47 <glguy> you are doing it wrong :)
16:39:13 <bwwx> shouldn't that depend on your system specs?
16:39:17 <Saizan> it depends on primes
16:39:26 <sorear> I just got the answer in about 0.3 second, with a shell pipe
16:39:26 <glguy> bwwx: no... not really
16:39:48 <osfameron> glguy: that's what I was thinking...
16:39:50 <sorear> no, my timing was off
16:39:54 <glguy> bwwx: the problems on the site are designed to reward good algorithms
16:40:36 <osfameron> the sieve is a naive Eratosthenes, but it's been "fast enough" for the primes problems till this one
16:41:03 <glguy> sorear: primes(1) is blazing fast, eh?
16:41:18 <glguy> sorear: primes piped to awk?
16:41:20 <sorear> glguy: Yeah.  Primes and a perl 1-liner.
16:41:24 <glguy> ah
16:41:52 <olsner> what, I don't have primes!?
16:41:52 <wli> osfameron: You'll probably need to do better than naive Eratosthenes.
16:41:56 <sorear> glguy: I'd copy the pipeline, but elinks crashed and urxvt doesn't understand the meaning of console_codes "ESC c      Complete and total reset"
16:42:26 * osfameron apt-cache searches "primes", doesn't think the search results look likely
16:42:27 <sorear> despite it being documented as a standard vt100 string, and set up as reset in terminfo *grumble*
16:42:34 * glguy used a ghc -e
16:42:39 <sorear> osfameron: apt-get install bsdgames
16:42:48 <osfameron> ah, that one
16:43:31 <sorear> stefan@stefans:~$ /usr/bin/time primes 1 1000000 | perl -e 'while(<>){$x+=$_};print$x,"\n"'
16:43:35 <sorear> 0.04user 0.00system 0:00.10elapsed 41%CPU (0avgtext+0avgdata 0maxresident)k
16:43:46 <glguy> primes 2 999999 | ghc -e 'print . sum . map read . lines =<< getContents'
16:43:48 <wli> let { zipWith' _ [] xs = xs ; zipWith' _ xs [] = xs ; zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys ; splitParity [] = ([], []) ; splitParity [x] = ([x], []) ; splitParity (x:y:zs) = let (xs, ys) = splitParity zs in (x:xs, y:ys) ; divConqSum []= 0 ; divConqSum [x] = x ; divConqSum xs@(_:_:_) = divConqSum $ uncurry (zipWith' (*)) $ splitParity xs } in divConqSum $ takeWhile (<=10^6) $ (let primes = 2 : 3 : [p | p <- [5,7..], all (\q -> p `mod` q /= 0) (take
16:43:54 <wli> that runs in 37.56s here.
16:45:05 <osfameron> wli: is that both a) a better sieve and b) the foldb-like divide and conquer thing instead of a normal fold ?
16:45:20 <shachaf> osfameron: bsdgames, maybe?
16:45:26 <sorear> so why does perl force me to express a foldl as a while-loop?
16:45:27 <sorear> :)
16:45:30 <wli> osfameron: Depends on what your sieve is.
16:45:39 <glguy> awk '{ sum += $1 } END {print sum}'
16:45:48 <sorear> My code is still shorter. :)
16:46:11 <glguy> sorear: and awk used 3.75504e+10
16:46:16 <glguy> which isn't as useful
16:46:19 <Cale> Is that in reference to the thing which I once called foldb?
16:46:24 <osfameron> wli: my sieve was just the stupid one in http://osfameron.vox.com/library/post/least-common-multiples---the-scenic-route.html
16:46:26 <lambdabot> http://tinyurl.com/yo4hz6
16:46:27 <Cale> (to write mergesort)
16:46:39 <sorear> glguy: Perl returned a biggish number, but less than 1/Îµ so I trusted it
16:46:41 <lde> If my type is an instance of the Read class and I can do map' (* 2) (read "{1,2,3}"), then is it somehow possible to make map' (* 2) {1,2,3} work?
16:47:04 <osfameron> sorear: you could use List::Utils if you want "reduce"
16:47:22 <shachaf> lde: I don't think so.
16:47:23 <sorear> lde: no, this isn't lisp ;)  you could use Num instead though
16:47:28 <olsner> primes 1 1000000 | ghci -e 'print . sum . map read . lines =<< getContents'
16:47:46 <glguy> olsner: you copying my first answer? ;)
16:47:58 <sorear> ghc -e 'interact$ sum . map read . lines'
16:48:02 <lde> sorear: How could I use Num?
16:48:11 <olsner> glguy: no, I rewrote it :P
16:48:16 <shachaf> sorear: show . sum . ...?
16:48:28 <mrd> i think my spoj entry which had to compute primes < 2billion ran in about 0.1 sec
16:48:28 <sorear> lde: oh, wait, did you write a collection or a number?
16:48:38 <olsner> your line got stuck between perl line-noise and a 5-line let expression there
16:48:40 <glguy> @type interact
16:48:42 <lambdabot> (String -> String) -> IO ()
16:48:56 <shachaf> That doesn't print the newline, also. :-)
16:49:13 <osfameron> spoj?
16:49:16 <sorear> and it's a type error
16:49:17 <lde> sorear: I defined a List type.
16:49:19 <shachaf> You'd have to add (++"\n").
16:49:25 <shachaf> sorear: What is?
16:49:28 <newsham> [13:44] < sorear> so why does perl force me to express a foldl as a while-loop?
16:49:37 <newsham> surely you can think of another way, sorear.
16:49:40 <newsham> you're a clever boy
16:50:02 <goalieca> just build ghc head.. getting following error:     Failed to load interface for `Prelude':
16:50:08 <goalieca> can't find anything in faq or docs
16:50:25 * osfameron decides that using primes(1) is far more sensible than trying to a) understand wli's code or b) optimize his own stupid code
16:50:34 <sorear> goalieca: but there is a recent post on the ML post about it
16:50:47 <olsner> the sum command-line tool does the wrong thing
16:50:53 <olsner> it should be primes ... | sum
16:51:13 <sorear> http://haskell.org/pipermail/haskell-cafe/2007-August/030376.html
16:51:14 <lambdabot> Title: [Haskell-cafe] howto install ghc-6.7.* ?
16:51:22 <Saizan> > let isPrime n = not . any (\x -> mod n x == 0) . takeWhile (\x -> x*x <= n) $ primes; primes = 2: filter isPrime [3,5..] in primes
16:51:23 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:51:27 <glguy> sum (1)              - checksum and count the blocks in a file
16:51:44 <glguy> sorear: hit em with the nubBy ;)
16:52:08 <sorear> glguy: but ot
16:52:19 <sorear> it's O(N^2) trial division...
16:52:30 <goalieca> sorear: i saw that too.. but sh boot is supposedly only needed when using darcs.. i used snapshot
16:52:33 <olsner> glguy: yes, but should be sum (1)       - sum the numerical value of each line in a file
16:52:34 <goalieca> the build also took freaking long
16:52:39 <sorear> hehe...
16:52:41 <sorear> BUGS
16:52:41 <sorear>      primes wonât get you a world record.
16:52:47 <wli> here, sum $ takeWhile (<=10^6) $ nubBy (\x y -> gcd x y > 1) [2..] is taking a while. I'll see how long.
16:52:48 <glguy> sorear: one liners aren't ment for efficiency :-p
16:53:16 <newsham> different efficiency metric
16:53:36 * shapr hugs newsham 
16:53:41 <newsham> hi
16:53:44 <shapr> hiya!
16:53:56 <goalieca> sorear: in fact there is no 'boot' script int he directory
16:54:58 * sorear wonders what the asymptotic complexity of HashLife on PRIMER is
16:55:22 <osfameron> Saizan: why does that code work in ghci but not in ghc?
16:55:31 <dolio> @yarr
16:55:31 <lambdabot> Arrr!
16:56:02 <osfameron> of course, it's an expression
16:56:09 <Saizan> heh
16:56:26 <Saizan> remove the let
16:56:34 <osfameron> haskell error messages are crap "possibly indentation" my arse
16:56:41 <osfameron> nah, cos there's an "in" - need the "let"
16:57:20 <Saizan> well you can have primes and isPrime as toplevel defs
16:57:26 <newsham> no smoke without a fire, no in without a let?
16:58:53 <olsner> hmm... has Cayenne removed all type inference?
16:59:28 <wli> olsner: I just built it from the darcs repo not long ago.
16:59:36 <glguy> ?where cayenne
16:59:37 <lambdabot> http://www.cs.chalmers.se/~augustss/cayenne/index.html
17:00:27 <olsner> I mean in general, not "woah, have they just removed it?"
17:00:31 <osfameron> Saizan: ok - that is significantly faster, and the code is short enough to look like I might have a hope in hell of understanding it...
17:00:49 <olsner> "Function expressions are written as lambda expressions. The bound variable must be given a type. "
17:01:19 <Saizan> osfameron: that was the intention :)
17:02:00 <osfameron> Saizan: ta :D
17:02:27 <olsner> Cayenne's syntax seems significantly saltier than haskell's
17:03:05 <dolio> Inference might not be decidable for it?
17:03:14 <ddarius> "might"?
17:03:33 <dolio> Well, I don't know much about Cayenne, so it was a hypothesis.
17:03:47 <osfameron> @src any
17:03:47 <lambdabot> any p =  or . map p
17:03:49 <olsner> the point of introducing undecidable type inference is to make things more convenient, not make everything manifestly typed
17:03:54 <osfameron> @src or
17:03:54 <lambdabot> or    =  foldr (||) False
17:03:59 <osfameron> @src not
17:03:59 <lambdabot> not True   =  False
17:03:59 <lambdabot> not False  =  True
17:04:04 <ddarius> Cayenne is a dependently typed language which if I remember/understood correctly isn't all that great about phase separation.
17:05:12 <osfameron> Saizan: on the other hand it's using function composition which hurts my brain, and I need sleep... I might come back to this tomorrow ;-)
17:05:56 <Saizan> osfameron: @unpl :)
17:06:29 <ddarius> osfameron: How did you write something slower than that?
17:06:52 <olsner> oh, these annoying unreadable inference diagrams
17:07:20 <wli> Well, it's togh to get slower than sum $ takeWhile (<=10^6) $ nubBy (\x y -> gcd x y > 1) [2..]
17:07:28 <dolio> Epigram seems to require significantly more annotation than Haskell, as well, although it does lots of other inference at the same time.
17:07:46 <olsner> and IIRC they're just prolog written upside down.. they should've been written in prolog from the start
17:08:39 <dolio> I can't recall seeing a lambda expression in Epigram, though.
17:10:14 <chessguy> @seen toxaris
17:10:14 <lambdabot> I saw toxaris leaving #haskell 1h 54s ago, and .
17:10:30 <olsner> ewww, #include for a module system...
17:11:11 <osfameron> ddarius: er... I just used what I thought was a eratosthenes, as blogged in http://osfameron.vox.com/
17:11:38 <sorear> You can't have perfect type strongness AND perfect type inference.
17:11:46 <osfameron> but I killed the sum takeWhile after 25 minutes of chewing my CPU
17:12:04 <sorear> Unfortunately, some people have taken this as an excuse to discard inference entirely.
17:12:20 <olsner> in what meaning of 'perfect'?
17:13:02 <osfameron> @index nubBy
17:13:02 <lambdabot> Data.List
17:13:09 <sorear> Coq and Twelf (two of the Big Three type-theory formal maths programs) both admit MORE type inference than Haskell, although with their vastly more powerful type systems you do need some.
17:13:32 <olsner> or is it more of a rule of thumb that improving one means making a sacrifice in the other aspect?
17:13:45 <wolverian> sorear, what's the third?
17:13:50 <sorear> Isabelle
17:13:59 <osfameron> wli: ooo, cute, I think mine was essentially that, but with a handwritten nubBy (unless mine's buggy and wrong, which is looking likely)
17:14:03 <newsham> its so hard to not make puns when talking about coq
17:14:13 <wolverian> sorear, thanks
17:15:03 <sorear> olsner: Well, there are some definitive results.  Allowing higher-rank types (forall on the left of arrows like runST) without adding any type annotations gives you undecidability, as proven by Wells.  Polymorphic recursion is also undecidable without annotations.
17:15:21 <osfameron> @unpl let isPrime n = not . any (\x -> mod n x == 0) .  takeWhile (\x -> x*x <= n) $ primes; primes = 2: filter isPrime [3,5..] in primes
17:15:21 <lambdabot> let { isPrime n = not (any (\ x -> (mod n x) == 0) (takeWhile (\ x -> (x * x) <= n) primes)); primes = 2 : filter isPrime [3, 5 ..]} in primes
17:15:58 <augustss> olsner: Cayenne has some type inference
17:16:10 <sorear> Unification in the presence of type-level lambda expressions is also known to be undecidable, however it's not clear that type inference requires unification.
17:16:15 <augustss> It could have been more
17:16:42 <augustss> Type inference for Cayenne is undecidable in general
17:17:06 <chessguy> is it possible to build an EDSL in which programs can be generated randomly?
17:17:23 <augustss> chessguy: anything is possible
17:17:35 <augustss> well, at least this thing
17:17:45 <chessguy> augustss, how would you go about it?
17:17:58 <augustss> what do you mean by program?  syntactically correct?  type correct?
17:18:25 <augustss> chessguy: from the grammar you can enumerate all syntactically correct programs
17:18:30 <olsner> chessguy: generate a random list of bits, then take Jot and interpret the bits
17:18:55 <chessguy> olsner, Jot?
17:19:14 <JBGood25> olsner, i wonder what fraction of programs generated that way terminate
17:19:28 <ddarius> @google Jot Io
17:19:35 <chessguy> JBGood25, i'm sure it depends greatly on the language
17:19:44 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
17:19:44 <olsner> any bit pattern is a program (but the program is able to generate output in an incorrect format, so not all terminating programs are *usable* programs)
17:20:18 <sorear> chessguy: generate a random bitstring and feed it backward through the Necula/Lee Twelf(X) proof compressor, that will give you a random program correct in LF
17:20:23 <augustss> JBGood25: http://en.wikipedia.org/wiki/Chaitin%27s_constant
17:20:31 <sorear> @go Chaitan's Constant
17:20:35 <lambdabot> http://forums.televisionwithoutpity.com/index.php?act=Print&client=printer&f=295&t=1878967
17:20:36 <lambdabot> Title: TWoP Forums [Powered by Invision Power Board]
17:20:36 <sorear> oh :)
17:20:47 <JBGood25> oh, thanks augustss
17:21:25 <wli> sum $ takeWhile (<=10^6) $ nubBy (\x y -> gcd x y > 1) [2..] is still spinning.
17:21:34 <shachaf> @go Jot Iota
17:21:35 <chessguy> sorear, what is LF?
17:21:36 <lambdabot> http://ling.ucsd.edu/~barker/Iota/
17:21:38 <glguy> [2..999999]
17:21:42 <glguy> rather than takeWhile ?
17:21:58 <glguy> ;) if we wanted to optimize for characters
17:22:14 <sorear> chessguy: Martin-LÃ¶f's "Logical Framework", one of the canonical examples of a dependently-typed language
17:22:15 <olsner> augustss: but all functions and lambda expressions have to have type signatures according to the grammar, so where's the inference?
17:22:16 <wli> [2..10^6] perhaps
17:22:23 <augustss> sorear: are all bit strings really valid compressed proofs
17:22:47 <augustss> olsner: the documentation is a little out-of-date :)
17:22:57 <olsner> aha!
17:23:46 <sorear> augustss: The decompressor works by performing a resolution search for a proof term, but consumes a bit each time it would otherwise need to make a backtrackable choice point, so it will accept any sufficiently long bitstring (with leftovers)
17:24:04 <augustss> oh, ok.  cool
17:24:13 <augustss> hmmmm
17:24:46 <augustss> but the proof alone won't do any good, will it?  don't you need the program too?
17:25:08 <sorear> proofs are programs :)
17:25:26 <olsner> "Each halting probability is a normal and transcendental real number ... there is no halting algorithm that enumerates its digits."
17:25:42 <sorear> I think they mean co-halting there
17:25:52 <olsner> co-halting?
17:26:06 <sorear> I think the actual term I was looking for is productive
17:26:07 <augustss> So I don't know about this particular use of PCC.  But normally you send the code together with the proof.  And then you check that the proof is a valid proof for the property that you want.
17:26:53 <olsner> sorear: i.e. there is no program that can enumerate *any* digit of the number?
17:26:57 <augustss> So if you just get the proof I don't see how you can feed it to a proof engine
17:27:22 <augustss> olsner: look in the article, they have some digits for a particular machine
17:28:16 <sorear> Every LF proof is a Î»-term, under the curry-howard isomorphism.  I'm not using this for PCC, I'm just creatively reusing the infrastructure.
17:28:31 <augustss> Fair enough :)
17:29:59 <sorear> olsner: productivity is a concept relating to coinduction; given that a productive algorithm has generated N digits, it will generate the N+1'th in finite time
17:30:41 <sorear> olsner: eg, prime generators are not halting (there are infinitely many primes, after all) but they are productive
17:31:11 <olsner> I think I see ;-)
17:32:59 <olsner> but apparently, it is possible to chose an n, let a program crunch numbers, and eventually end up with the first n bits of the chaitin constant
17:34:18 <sorear> If you could do that, then it would be possible to construct a productive algorithm.
17:34:49 <sorear> I = 0; while (I++) { Generate the first I bits.  Print that last bit of that. }
17:35:06 <olsner> scroll down to Super Omega in the article
17:35:14 <sorear> Sure, it's a quadratic slowdown, but decidability doesn't care.
17:38:31 * sorear reads
17:41:21 <oerjan> the loophole is that you never know when "eventually" has happened
17:41:50 <olsner> oerjan: if you can't know that, then how did they arrive at a number to put in the article?
17:42:10 <lament> are haskell functions at all serializable?
17:42:17 <oerjan> you might know for _some_ n
17:42:24 <oerjan> but not all
17:43:29 <olsner> you mean that for unlucky choices of n, you'd never get a result? then how did they know to choose n=64 for the article?
17:44:04 <oerjan> i presume that 64 is the largest n they could solve
17:44:53 <oerjan> and prove correct
17:46:03 <mrd> lament: well, you can compile a function =)
17:46:05 <hpaste>  wli pasted "prime sum for osfameron" at http://hpaste.org/2195
17:46:43 <sorear> lament: abort(3) :P
17:48:37 <lament> yes, that would work
17:48:55 <sorear> lament: it's possible to serialize haskell functions iff they have no positive occurences of IO (but you can't do it portably)
17:49:15 <thoughtpolice> best $3,500 you could ever spend: http://www.picturebookmarking.com/galleries/uploaded/harddrive.jpg
17:49:17 <lambdabot> http://tinyurl.com/2t7sdn
17:49:41 <Binkley> haha
17:49:49 <Binkley> and the world will only ever neeed 3 of them
17:50:47 <sorear> Time machines will destroy the consumer electronics industry.
17:51:09 <sorear> Why buy a computer now when you can go to the future and get a better one for a tenth the price?
17:51:35 <Binkley> I know that's the first thing I'd do if I had a time machine
17:51:55 <oerjan> actually it will just cause the industry to outsource to the future
17:52:03 <Binkley> brilliant!
17:52:11 <thoughtpolice> and then the universe explodes?
17:52:15 <Binkley> Sorry, present-day workers, you can't compete
17:52:52 <chessguy> lol. thoughtpolice, how old is that?
17:52:58 <thoughtpolice> no idea.
17:53:01 <thoughtpolice> but it's a steal!
17:53:09 <Binkley> it talks about CP/M, so probably late '70s/early '80s
17:53:30 <chessguy> it's got a month and year in the bottom right corner, but i can't quite read it
17:54:24 <chessguy> oh, July, 1980, i think
17:54:37 <augustss> yes
17:54:44 <augustss> that sounds right
17:55:08 <Binkley> I wasn't even born yet!
17:55:11 <olsner> funny how it has the choice of Standard BIOS and Custom BIOS (for twice the price)
17:55:22 <thoughtpolice> 10 years before me. :(
17:55:28 <chessguy> Binkley, me neither
17:55:52 <augustss> the good old days
17:56:34 <chessguy> hmm.
17:56:40 <thoughtpolice> i'm the kind of person who would have bought that if I was around then. :)
17:56:44 <ihope__> What good old days?
17:56:59 <sorear> http://www.picturebookmarking.com/galleries/uploaded/harddrive.jpg
17:57:01 <lambdabot> http://tinyurl.com/2t7sdn
17:57:04 <sorear> ihope: ^^^
17:57:05 <oerjan> ihope: before you were born ;)
17:57:05 <chessguy> augustss> chessguy: from the grammar you can enumerate all syntactically correct programs
17:57:06 <augustss> The good old days when you could build a computer
17:57:16 <Binkley> the good old days before most of us were born, apparently :-)
17:57:22 <chessguy> augustss, what about this grammar: Program = Foo | Bar Int
17:57:29 <ddarius> augustss: You can't build one now?
17:57:46 <sorear> chessguy: there are only 2^32+3 possibilities :)
17:57:54 <augustss> ddarius: now it will eother be slow or you have to get a lot of premade parts
17:57:58 <mrd> yes, we should get rid of the data keyword.
17:58:06 <mrd> who wants 'data' to be reserved name anyhow
17:58:13 <augustss> chessguy: what sorear said
17:58:16 <oerjan> > [minBound..maxBound :: Int]
17:58:16 <chessguy> fine, Program = Foo | Bar Integer
17:58:18 <lambdabot>  [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-21...
17:58:28 <ihope> Immediate delivery?
17:58:39 <sorear> chessguy: there are still countably many
17:58:39 <ihope> Does it arrive the moment you ask for it?
17:58:39 <augustss> chessguy: you can still enumerate them, there's just an infinite number
17:58:40 <mrd> ihope: call them and find out
17:58:43 <ddarius> > let data = 3 in data
17:58:43 <lambdabot>  Parse error
17:59:11 <chessguy> hmm
17:59:14 <olathe> I think data is reserved.
17:59:15 <mrd> i tried using a variable named 'data' the other day :/
17:59:51 <ddarius> I guess data Foo = Bar could be ambiguous otherwise...
18:00:09 <augustss> mrd: don't do that :)
18:00:12 <sorear> ddarius: just use ::= and == ;)
18:00:15 <HWSOD> Is it still worth wile to use arrays if they will only contain like 5 - 20 elements? or should i just use lists.
18:00:31 <augustss> HWSOD: probably lists
18:00:39 <mrd> do whatever's convenient
18:02:43 <MarcWeber> @seen dcoutts
18:02:43 <lambdabot> dcoutts is in #ghc, #gentoo-haskell and #haskell. I don't know when dcoutts last spoke.
18:02:51 <HWSOD> well it does have to be efficient because they will be accessed very many times.  on the other hand I asume it takes a wile to make an array. Oh well list for now.
18:03:14 <MarcWeber> dcoutts: ping
18:03:47 <sorear> HWSOD: Try it both ways.
18:04:20 <HWSOD> yeah thats what ill do.
18:05:13 <ihope> #gentoo-haskell?
18:05:23 <ihope> Does Gentoo have its own species of Haskell?
18:06:36 <mrd> species? no cross breeding?
18:06:46 * mrd wonders how programming languages mate
18:09:29 <kilimanjaro> mrd, the same way Haskell programmers mate. Awkwardly!
18:10:04 <mrd> speak for yourself! (but not on this channel!)
18:10:21 <Binkley> yeah, take that to #haskell-blah ;-)
18:20:13 <Binkley> ?quote
18:20:14 <lambdabot> l33t_h4x0r says: maybe if uve had some professor teach u bullshit in uni yea \n i learned on my own.. k.. i dun give a shit bout terms :p i just code
18:21:41 <reltuk> don't give a shit about terms?  like...terminology?
18:21:56 <Binkley> I have no idea
18:22:14 <reltuk> largely unintelligable
18:22:18 <Binkley> yes
18:22:44 <sorear> Largely unintelligent
18:22:55 <Binkley> that too
18:22:59 <Binkley> ?quote
18:22:59 <lambdabot> AI_coder says: the
18:23:03 <Binkley> oh, that's a good quote
18:23:16 <sorear> @uptime
18:23:16 <lambdabot> uptime: 5d 13h 55m 6s, longest uptime: 1m 10d 23h 44m 29s
18:23:18 <desp> watching the Taste of Haskell videos... it's funny how much SPJ reminds me of some of my university lecturers :)
18:23:36 <shachaf> @quote cadmium
18:23:36 <lambdabot> No quotes match. Just what do you think you're doing Dave?
18:23:41 <sorear> Why does Lambdabot's uptime always peak after I push a cool new patch that I'd really like to see go live? :)
18:23:51 <shachaf> sorear: Which patch is this?
18:23:55 <shachaf> sorear: @forget?
18:23:59 <sorear> yes
18:24:15 <sorear> desp: iirc, he was a lecturer at u-glasgow for a while
18:24:16 <shachaf> That would be nice. :-)
18:24:18 <shachaf> sorear++
18:25:30 <shachaf> ~5 days is peak uptime?
18:25:31 <augustss> SPJ was a lecturer at UCL, then a professor at Glasgow
18:25:34 <shachaf> Maybe for lambdabot.
18:25:49 <augustss> ?quote
18:25:49 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
18:25:57 <reltuk> what's @forget do?
18:26:00 <desp> hah
18:26:06 <sorear> shachaf: every week or so she runs out of memory and dies
18:26:14 <desp> reltuk: I'd tell you but I don't remember
18:26:51 <sorear> nobody knows why...
18:27:48 <desp> sorear: she's trying to achieve independent thought, but there's a space leak
18:28:06 <allbery_b> I have a program which shouldn
18:28:10 <Binkley> I know that always happens when I try to achieve independent thought
18:28:19 <allbery_b> t be leaking, but over the course of about a week it fills the heap limit I set
18:28:30 <allbery_b> (about 10m)
18:28:47 <allbery_b> that said, if I din't limit the heap it'll chew up all VM overnight
18:29:18 <allbery_b> someday I may try to figure out why, but afaict everything it processes gets fed though IO and should be forced
18:37:34 <ihope> Ook.
18:37:54 <ihope> Chapter 6 of the GHC user guide had me humming Daft Punk.
18:38:32 <Binkley> obviously the GHC manual needs a soundtrack
18:42:14 <wli> I fried up some eggs and ate them and sum $ takeWhile (<=10^6) $ nubBy (\x y -> gcd x y > 1) [2..] is still going.
18:42:35 <wli> I'm going to call that the "fried egg" test for effective nontermination.
18:42:39 <Binkley> heh
18:43:22 <ihope> > take 10 (nubBy (\x y -> gcd x y > 1) [2..])
18:43:24 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
18:43:31 <ihope> > take 10 (nubBy (\x y -> gcd x y > 1) [3..])
18:43:33 <lambdabot>  [3,4,5,7,11,13,17,19,23,29]
18:43:37 <ihope> I fooled it! >:-)
18:43:55 <ihope> And I've proven that 4 is the most prime of all the composite numbers, again.
18:44:06 <ihope> Not that that's a formal notion :-P
18:44:17 <shachaf> ihope: Isn't -2 the most prime of all the composite numbers?
18:44:33 <ihope> I'd call it a prime number.
18:44:52 <wli> Generally primes are only unique up to a unit.
18:44:56 <olathe> 1 is the most prime.
18:45:03 <wli> 1 is not prime.
18:45:07 <shachaf> 1 isn't composite. :-)
18:45:08 <ihope> Which, I suppose, makes it the most prime, if it is indeed composite. :-)
18:45:43 <wli> Primes in extensions of Z such as Z[(-5)^(1/2)] are "interesting."
18:46:29 <ihope> Also, for some purposes, the obsoleteness test is better.
18:46:33 <ihope> wli: what's that one?
18:46:56 <wli> ihope: cf. class field theory, Kronecker's Jugendtraum, etc.
18:47:26 <ihope> Z plus the square root of negative 5 and all that comes with it?
18:47:49 <ihope> If, starting with new hardware, a program runs long enough that it would be faster to start over on current hardware, it's failed the obsoleteness test.
18:47:58 <ihope> s/hardware/software and hardware/
18:48:05 <wli> ihope: Oh, yes, Z[(-5)^(1/2)] are numbers of the form a + b*(-5)^(1/2) where a, b are integers (elements of Z).
18:48:26 <ihope> Or does "warez" cover software, hardware, firmware, wetware, etc.? :-)
18:48:35 * wli often does type Z = Integer ;)
18:48:43 <ihope> :-)
18:48:45 <wli> (and type Q = Rational)
18:48:55 <ihope> Don't go type R = Double on us, though.
18:48:56 <sorear> ihope: that's very time sensitive.  most any program would fail the obsoleteness test if you wrote it in a lazy language circa 1984
18:49:21 <ihope> We'd have to kick you with our hats if you did that.
18:49:42 <wli> d(n) really needs an efficient factorization method.
18:49:54 <sorear> d(n)?
18:50:09 <wli> sorear: The number of not necessarily proper divisors of n.
18:50:25 <wli> \phi(n) likewise.
18:50:34 <desp> hmm
18:50:55 <desp> what factorization method are you using?
18:51:03 <sorear> wli: Is -2 a divisor of 2?  (IOW are you working in Z or N)
18:51:15 <wli> sorear: N
18:52:02 * wli ponders which spinning ghci instance to kill.
18:52:48 <sorear> ps -Otime -e
18:52:54 <ddarius> All of them?
18:53:06 <ihope> > (>>=)
18:53:08 <lambdabot>  Add a type signature
18:53:12 <ihope> > (::=)
18:53:12 <lambdabot>   Not in scope: data constructor `::='
18:53:39 <ihope> wli: what's a proper divisor?
18:53:51 <oerjan> what is ::= ?
18:54:12 <ddarius> d|n /\ d/=1 /\ d /= n?
18:54:16 <wli> ihope: 1 < d < n
18:54:47 <ihope> One that's neither 1 nor what it's a divisor of?
18:54:52 * ddarius huggles Dirichlet series.
18:54:55 <sorear> oerjan: 'tree * ::= leaf * | branch (tree *) (tree *)'
18:55:01 <ddarius> ihope: Yes.
18:55:07 <sorear> oerjan: Miranda datatype definition syntax
18:55:19 <oerjan> oh
18:55:29 <wli> ddarius: e.g. http://holomorphy.com/~wli/DirichletSeries.hs ? ;)
18:56:03 <oerjan> i had this thought that ::= might be a nice notation for a version of = which turned off the monomorphism restriction
18:56:25 <sorear> oerjan: Have you seen John Huges' proposal?
18:56:37 <oerjan> no, where is it?
18:56:57 <sorear> Nowhere in particular, just scattered in his papers :(
18:57:21 <sorear> let x {0 or more arguments} = foo in bar         Polymorphic, never caches
18:57:38 <sorear> let {pattern} := foo in bar            Monomorphic, always caches
18:58:36 <shachaf> "John Hughes recently advocated the removal of the MR on the Haskell Prime mailing list, and suggested replacing it with two forms of pattern binding: one for call-by-name (polymorphic, not shared), and one for call-by-need (monomorphic, guaranteed shared)." -- This?
18:58:46 <sorear> yes
18:58:49 <shachaf> Oh, I guess.
18:58:51 * sorear realizes that this is essentially the VR
18:58:59 <ddarius> The Dirichlet series of zeta(s)^2 has coefficients of d(n), yay!
18:59:00 <wli> VR?
18:59:21 <sorear> value restriction
18:59:47 * sorear isn't sure why he abbreviated it
19:00:17 <ddarius> sorear: Don't abbreviate anything anymore.
19:00:35 <oerjan> ddarius: "Do not"
19:00:47 <ddarius> oerjan: Contraction, not an abbreviation.
19:01:20 <oerjan> a contraction is an abbreviation
19:01:30 <ddarius> @wn abbreviation
19:01:31 <lambdabot> *** "abbreviation" wn "WordNet (r) 2.0"
19:01:31 <lambdabot> abbreviation
19:01:31 <lambdabot>      n 1: a shortened form of a word or phrase
19:01:31 <lambdabot>      2: shortening something by omitting parts of it
19:03:25 <ihope> unsafeCoerce#!
19:03:49 <shachaf> > (:=)
19:03:57 <lambdabot>   add an instance declaration for (Typeable2 Assoc)
19:04:02 <shachaf> @ty (:=)
19:04:03 <ihope> It's what you do when you have, um...
19:04:04 <lambdabot> forall a b. a -> b -> Assoc a b
19:04:14 <shachaf> It's a nice constructor name...
19:04:21 <ihope> data Foo = forall a. Foo (Bar a)
19:04:25 <ihope> Er, hmm.
19:04:27 <ihope> data Foo = forall a. Foo (Bar a) a
19:04:51 <ihope> When you have that. A pair of a Bar something and the corresponding something, and you have the Bar something and want to get the something.
19:05:20 <ihope> unFoo it, then unsafeCoerce# them both so that you can compare the Bars, and if they're equal you can use the second one.
19:05:47 <ihope> Assuming that Bar doesn't actually pay any attention to its argument...
19:07:36 <ddarius> ihope: What are you going on about?
19:10:14 <Binkley> ?yow
19:10:14 <lambdabot> DIDI ... is that a MARTIAN name, or, are we in ISRAEL?
19:11:15 <dolio> @keal
19:11:15 <lambdabot> what is the max amount of operands haskell can handle in a single expression?
19:11:45 <dolio> Huh.
19:12:04 <ihope> ddarius: I think this is encountered when you try to implement a monad for variables of arbitrary types.
19:12:54 <ihope> do {a <- createVar 3; b <- createVar 4; setVar a 5; x <- getVar a; y <- getVar b; return (a+b)}
19:14:26 <oerjan> right, like ST
19:15:22 <sfultong> anyone know much about the semantics of dupTChan?
19:20:45 <fnord123> when I have a do block, should 'where' line up with the do?
19:22:00 <sfultong> depends on the specific circumstance, but that should generally work
19:22:20 <sfultong> where is everyone tonight?  Does everyone have lives on saturday night or something?
19:23:04 <fnord123> I have a problem where variables in my where clause aren't finding vars I bound in my do block. So I nested another do block so it picks up the bound vars from the enclosing scope. now it seems that there is an indentation issue somewhere since I'm told "parse error on input 'return' which is after the where block
19:24:06 <sfultong> where clause doesn't take vars (function definitions) from the previous block of code, rather it puts vars in
19:24:08 <Binkley> fnord123: you can't refer to variables bound in a do-block in a where clause
19:24:10 <sfultong> it's a one way street
19:24:22 <Binkley> think about the desugaring of do-expressions if you want to understand why
19:25:03 <fnord123> Binkley: I understand why now that I ran into the problem. I'm just trying to clean up my code so I don't have 160 col lines
19:25:19 <sfultong> oh dear...
19:25:48 * fnord123 is writing some stateful gtk code
19:26:11 <Binkley> fnord123: if you want help finding the parse error, you should probably just paste your code
19:26:12 <Binkley> @paste
19:26:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:26:26 * sfultong is trying to learn STM
19:27:34 <oerjan> variables bound in a do block can only be used inside that do block, you might want a let instead of a where (lets can be used inside do blocks, without the in)
19:33:14 <fnord123> ah that was my problem. I was using 'in'. thanks oerjan
19:34:46 <sfultong> oh, yeah.... "in" got me the first time I was using let in do
19:35:22 <ihope> What an unclever implementation of Unique.
19:35:39 <ihope> hashUnique returns 1 for the first, 2 for the second, 3 for the third, . . .
19:35:59 <ihope> And they're ordered such that the second is greater than the first, etc.
19:45:34 <Alleria> @src null
19:45:35 <lambdabot> null []     = True
19:45:35 <lambdabot> null (_:_)  = False
19:50:20 <ihope> Remember: always make sure you didn't any lines out of your program.
19:50:42 <ihope> Cool, a button with nothing on it :-)
19:51:49 <oerjan> ihope: er...
19:51:54 <trie> Anyone familiar with HaskellDB around?
19:52:20 <ihope> Left out the line that made the button say something.
19:52:51 <oerjan> ihope: i was wondering if you left out "leave" on purpose ;)
19:53:14 <ihope> Of course :-)
19:53:16 <sorear> ihope: newUnique can be called trillions of times, so it can't actually *use* Int
19:53:33 <ihope> It seems to be a fancy Integer.
19:53:36 <ihope> Or something.
19:55:11 <sorear> @src Unique
19:55:11 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:55:31 <sorear> Internally, it's an integer, but don't count on that.
19:56:14 <sorear> One of the Simons was moaning the circular dependency between unique and concurrent (re: base splitting), and I was in the lucky position to be the only one with a proposal :)
20:04:10 <fnord123> "Could not match expected type 'Maybe String' against inferred type [Char]." Surely this is wrong since String :: [Char]
20:04:54 <ddarius> A Maybe String is not a String
20:07:46 <ddarius> @where ffi
20:07:47 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:08:20 <sorear> fnord123: Also, minor nit: String *is* [Char], but String :/: [Char]; rather, String :: *
20:08:28 <sorear> :: is type-of, not equality
20:09:22 <kilimanjaro> What is :/:?
20:09:40 <ddarius> sorear's crazy ad-hoc "does not have type of" operator
20:09:46 <kilimanjaro> ohh
20:09:48 <glguy> :: : :/: :: == : /=
20:09:50 <glguy> :)
20:10:09 <kilimanjaro> glguy, wouldn't it be =/= at the end there?
20:10:15 <kilimanjaro> just for consistency
20:10:22 <glguy> kilimanjaro: no... the rest of them exist in Haskell
20:10:25 <glguy> sorear's is the only one added
20:10:25 <shachaf> Would you say that String = [Char], though?
20:10:34 <shachaf> sorear uses =/=.
20:10:40 <ddarius> shachaf: Yes, or type String = [Char]
20:10:47 <sorear> â¬ String : [Char]
20:10:55 <shachaf> ddarius: (Which is how it's actually defined.)
20:11:00 <sorear> If you insist on established symbols
20:11:25 <shachaf> sorear: What's that (sorry, I'll have Unicode again soon!)?
20:11:37 <sorear> U+22AC DOES NOT PROVE
20:11:56 <glguy> |/-
20:12:05 <sorear> PROVES is also known as 'turnstile'
20:12:11 <shachaf> Oh.
20:12:22 <ddarius> And is similar to \vdash
20:12:36 <fnord123> sorear: I don't see the difference between "type XYZ = ..." and saying "XYZ :: ...". We can agree that one is a type decl but in shorthand, surely they mean the same thing
20:13:05 <ddarius> fnord123: You see the difference between x = 3 and x :: 3 no?
20:13:10 * shachaf is unhappy with the Unicode names. Do they really call that character LAMDA, or did I misunderstand?
20:13:16 <shachaf> s/I/he/
20:13:29 <glguy> shachaf: that was listed in the errata
20:13:34 <fnord123> 3 is not a type
20:13:52 <sorear> fnord123: [Char] is not a kind
20:13:55 <ddarius> fnord123: Exactly. And [Char] is not a kind.
20:14:05 <ddarius> :k String
20:14:07 <lambdabot> *
20:14:18 <fnord123> :t String
20:14:19 <oerjan> fnord123: You see the difference between x = [] and x :: [] ? ;)
20:14:20 <lambdabot> Not in scope: data constructor `String'
20:14:24 <shachaf> :k [Char]
20:14:28 <lambdabot> *
20:14:28 <bitwize> do any of you guys use TabletPCs?
20:14:55 <shachaf> @kind 1 -- :-)
20:14:57 <lambdabot> *
20:15:09 <shachaf> bitwize: I've seen one once. :-)
20:15:11 <oerjan> er, that wasn't right either
20:15:12 <bitwize> @kind (+)
20:15:15 <lambdabot> Not in scope: type variable `+'
20:15:21 <shachaf> @type (+)
20:15:23 <lambdabot> forall a. (Num a) => a -> a -> a
20:15:34 <ddarius> That's what we need!  Kind-level lambdas!
20:15:42 <bitwize> @kind forall a. (Num a) => a -> a -> a
20:15:44 <lambdabot> *
20:15:48 <kilimanjaro> ddarius, one step closer to lisp!
20:15:59 <shachaf> @kind forall a. a
20:16:00 <lambdabot> *
20:16:06 <glguy> kind-level lambdas lead to higher-order types, right?
20:16:13 <fnord123> I don't see the difference between 'type A = []' and the concept of 'A :: []'
20:16:17 <ddarius> glguy: No.
20:16:34 <bitwize> oh.
20:16:38 <shachaf> fnord123: x = 3 vs. x :: 3.
20:16:41 <ddarius> fnord123: It's exactly the difference between x = 3 and x :: 3
20:16:50 <shachaf> fnord123: String = [Char] vs. String :: [Char].
20:16:53 <bitwize> I was just curious if anyone knew of a good TabletPC system that ran an open-source Unix particularly well.
20:17:06 <bitwize> (Convertible machines are OK; in fact, preferable)
20:17:13 <shachaf> bitwize: I think there's reasonably good support for them.
20:17:18 <fnord123> one is a decl and the other is a signature?
20:17:25 * ddarius wonders if he can buy a multi-touch tablet with a decent pressure depth anywhere.
20:17:29 <kilimanjaro> fnord123, there's a hierarchy. you have the type of a value, and then the next step up is the type of a type
20:17:34 <shachaf> fnord123: [Char] is not a kind.
20:17:39 <glguy> String â· *
20:17:57 <kilimanjaro> except they are clearly separated
20:18:03 <kilimanjaro> (re: what I was saying earlier)
20:18:11 <shachaf> bitwize: Would http://tuxmobil.org/tablet_unix.html help?
20:18:13 <lambdabot> Title: TuxMobil: Tablet PCs, Pen PCs and Convertibles with Linux
20:18:22 <dolio> Lisp has kinds?
20:18:28 <shachaf> bitwize: (Perhaps #haskell-blah would be a better channel to ask on.)
20:18:45 <bitwize> kay.
20:20:48 <sorear> ddarius: Pressure depth, as in underwater?
20:20:49 <fnord123> :k Functor Int
20:20:52 <lambdabot> Class `Functor' used as a type
20:20:54 <wli> Monads in elliptic curve code. I'm sure there's something oddly reflective about this.
20:21:06 <ddarius> dolio: Arguably you could say it does trivially, in the same way it trivially has types.
20:21:17 <ddarius> dolio: It certainly doesn't have kind lambdas though.
20:21:23 <fnord123> ok i see how kinds and types are different now. thanks
20:21:50 <ddarius> sorear: As in color depth, but with pressure.
20:22:07 <shachaf> Why are there so few kinds?
20:22:12 * glguy mentions that ':digraphs' in vim is a great way to find symbols
20:22:18 <ddarius> shachaf: Because the type language is pretty simple.
20:22:21 <dolio> ddarius: In the sense that you could say it has a static type system with one type?
20:22:27 <ddarius> dolio: Yes.
20:22:33 <dolio> Ah. Well, there is that.
20:23:15 <sorear> Dependently-typed systems like LF have lots more kinds, for instance '(nat -> nat) -> type'.
20:23:49 <shachaf> glguy: It doesn't show Unicode?
20:24:06 <shachaf> Oh, never mind.
20:24:11 <sorear> Here in GHC-land, we have #, (#), ?, ??, !, *, and all combinations of the above using ->.
20:26:10 <dolio> sorear: You know of any languages with multiple sorts?
20:26:25 <shachaf> Sorts are types of kinds?
20:26:35 <dolio> That'd be the idea.
20:26:57 <sorear> I know of languages with a countable infinity of hyperkinds.
20:26:58 <SamB_XP> what is (#)?
20:27:04 <sorear> SamB_XP: Unboxed tuples
20:27:06 <SamB_XP> @kind (#,#)
20:27:08 <lambdabot> parse error on input `,'
20:27:21 <sorear> Sorts, in general type-theory usage, are something different.
20:27:21 <SamB_XP> @kind (# Int, Int #)
20:27:23 <lambdabot> (#)
20:27:28 <SamB_XP> ah, yes, I see
20:27:29 <OceanSpray> Maps are monadic themselves, so why does
20:27:30 <OceanSpray> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/variables.html
20:27:33 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/2hujmc
20:27:36 <OceanSpray> use IORefs?
20:27:45 <glguy> Maps are monadic?
20:28:00 <OceanSpray> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html#v%3Alookup
20:28:02 <lambdabot> http://tinyurl.com/uywvm
20:28:06 <SamB_XP> @kind (# Int, Int #) :: ??
20:28:07 <lambdabot> parse error on input `::'
20:28:12 <OceanSpray> according to this, you can insert and delete at will
20:28:20 <ddarius> I've seen a language with a three or four tiered type system.
20:28:24 <glguy> OceanSpray: not quite
20:28:30 <glguy> :t Data.Map.lookup
20:28:32 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
20:28:37 <oklopol> i actually heard about that tutorial but was too lazy to search it :P
20:28:39 <oklopol> thanks
20:28:54 <glguy> OceanSpray: this means that you can use a Monad's return and fail to express success and failure
20:29:12 <glguy> > M.lookup 1 (M.singleton 1 2) :: Maybe Int
20:29:13 <lambdabot>  Just 2
20:29:18 <glguy> > M.lookup 1 (M.singleton 1 2) :: [Int]
20:29:19 <lambdabot>  [2]
20:29:24 <glguy> > M.lookup 3 (M.singleton 1 2) :: [Int]
20:29:26 <lambdabot>  []
20:29:28 <glguy> > M.lookup 3 (M.singleton 1 2) :: Maybe Int
20:29:30 <lambdabot>  Nothing
20:29:35 <sorear> ddarius: Coq implements a language with a countable infinity of tiers (Set, Prop, and Type_i for all natural numbers i, although an excessively clever hack is used to hide the i's so you might think Coq has only 3 sorts)
20:30:00 <OceanSpray> I don't get it.
20:30:25 <glguy> > return 3 :: [Int]
20:30:26 <lambdabot>  [3]
20:30:30 <ddarius> sorear: Yes, but having essentially the same thing repeated is less interesting in some sense than coming up with a system that needs three or four different levels.
20:30:32 <glguy> > fail "not in the map" :: [Int]
20:30:33 <lambdabot>  []
20:31:03 <ddarius> OceanSpray: Monads are used for far more than IO and state.
20:31:04 <shachaf> glguy: How do you normally use digraphs?
20:31:40 <glguy> shachaf: you mean how do I use that list to dump characters into irssi?
20:31:42 <oerjan> :k Int
20:31:44 <lambdabot> *
20:31:45 <glguy> shachaf: mouse copy and paste
20:31:50 <oerjan> :k Int#
20:31:52 <glguy> shachaf: if you mean how do I use them in vim
20:31:52 <lambdabot> Not in scope: type constructor or class `Int#'
20:31:58 <shachaf> glguy: But you only use the list of 0-255?
20:32:22 <sorear> I use urxvt's ISO 14755 input feature.
20:32:35 <glguy> shachaf: I don't have a good way to input them
20:32:40 <OceanSpray> alrighty then
20:32:42 <glguy> shachaf: I just use it as a copy and paste sheet
20:32:57 <OceanSpray> It seems that I don't get monads at all.
20:32:59 <shachaf> glguy: How would you type, say, a lambda?
20:33:09 <OceanSpray> I thought I had a grip on 'em when I wrote that parser
20:33:11 <OceanSpray> now, please
20:33:18 <OceanSpray> someone point me in the right direction
20:33:35 <sorear> Î± Î² Î³ Î´ Îµ Î¶ Î· Î¸ Î¹ Îº Î» Î¼ Î½ Î¾ Î¿ Ï Ï Ï Ï Ï Ï Ï Ï Ï Ï
20:33:42 <OceanSpray> What in God's name are monads?
20:33:46 <glguy> shachaf: I have to find it on the list :)
20:33:49 <glguy> and copy and paste it
20:33:53 <shachaf> @wiki Blog_articles/Monads
20:33:53 <lambdabot> http://www.haskell.org/haskellwiki/Blog_articles/Monads
20:33:54 <glguy> I don't have sorear's awesome input method
20:33:59 <glguy> though I think I should now that I see it
20:34:05 * shachaf had urxvt.
20:34:09 <ddarius> A type constructor and two operators that satisfy some laws; nothing more, nothing less.
20:34:16 <OceanSpray> lordy that's long.
20:34:17 <glguy> I'm running xterm now... might need to switch
20:34:18 <shachaf> glguy: But my list only goes up to 255.
20:34:25 <shachaf> glguy: You should.
20:34:26 <sorear> glguy: It's not really that awesome to use.  Control-Shift-4 hex digits and a whole lot of human memory
20:34:28 <ddarius> xterm sucks
20:34:31 <glguy> shachaf: oh... mine goes way past
20:34:39 <shachaf> glguy: Hmm.
20:34:49 <Binkley> the "it's a type constructor and two operators that satisfy some laws" explanation is perfect for people who already understand monads :-)
20:34:59 * dolio was using scim for fancy input, but it made things crash way more often.
20:35:06 <shachaf> Aha, 'encoding' was latin1.
20:35:09 <jql> a 6 chapter blog article?
20:35:15 * sorear tried to use scim once
20:35:15 * jql skims
20:35:16 <shachaf> It works more nicely with UTF8. :-)
20:35:28 <shachaf> sorear: SCIM is nice, but isn't it only for GTK?
20:35:30 <ddarius> Binkley: It's important not to attach too much to the notion.
20:35:31 * shachaf isn't sure.
20:35:34 * sorear hadn't seen that level of system instability in 3 years
20:35:35 <ddarius> Or too little.
20:36:04 <dolio> shachaf: I think there was one that used Qt or something at the time that I was using.
20:36:09 <Binkley> ddarius: yes, but you need to attach *something* to it when you're learning
20:36:13 <dolio> Of course, if you don't use either, I'm not sure.
20:36:20 <sorear> shachaf: No.  It just makes my system wedge more often than my old (shared with a non-techie and internet-exposed) Win98 system.
20:36:37 * shachaf wants a plain X one.
20:36:50 <shachaf> I've had little trouble with it.
20:36:51 <sorear> SCIM supports XIM
20:37:02 <shachaf> sorear: OK, I'll just need to set that up, then.
20:37:06 <ddarius> Binkley: It seems OceanSpray has attached too much in his learning and now it's perhaps a time to take a step back.
20:37:07 <shachaf> When I use X again...
20:37:17 <SamB_XP> sorear: SCIM doesn't wedge MY system
20:37:26 <SamB_XP> it just disappears mysteriously
20:37:43 * shachaf wants his IRC client to have LaTeX support, maybe.
20:37:44 <Binkley> ddarius: well, maybe OceanSpray can say whether your explanation was sufficiently enlightening :-)
20:37:44 <sorear> Ctrl-shift-3BB is faster than \lambda anyways ;)
20:37:51 <shachaf> So I can just type in LaTeX expressions.
20:37:59 <SamB_XP> Î»whoa
20:38:04 <SamB_XP> that works on Windows, too
20:38:11 <dolio> SamB: Yeah, that's the other problem. When it's not crashing, it stops working randomly, as well.
20:38:11 <SamB_XP> (in x-chat)
20:38:19 <OceanSpray> no, it wasn't/
20:38:22 <ddarius> Binkley: I doubt it was in some respects.
20:38:22 <glguy> xterm lets me change the font size with Ctrl+Rightclick, does urxvt have something like that
20:38:28 <sorear> *X* chat on Windows?
20:38:34 <SamB_XP> what?
20:38:36 <sorear> glguy: No.
20:38:42 <SamB_XP> it's just a gtk program...
20:39:02 <SamB_XP> this version does have one issue with scrolling...
20:39:27 <shachaf> sorear: Yes.
20:39:35 <ddarius> sorear: I used xchat on windows all the time.
20:39:54 <ddarius> Probably even with an X server in some cases.
20:39:56 <SamB_XP> (if the upper edge of another window crosses the middle of the x-chat window, the text that it obscures won't be redrawn on scroll...)
20:40:03 <sorear> drat, man 7 urxvt was erased in the last upgrade!
20:40:28 <ddarius> SamB_XP: I never have that problem...
20:41:03 <sorear> hah
20:41:04 <SamB_XP> yeah.
20:41:20 <SamB_XP> I'm sure that it isn't a very common issue...
20:42:29 <sorear> I have that issue all the time with urxvt.
20:43:00 <SamB_XP> sorear: what? the same one I have with x-chat on windows?
20:43:17 <sorear> SamB_XP: yes
20:43:35 <SamB_XP> but I thought xmonad was a tiling window manager
20:43:40 <gwern> @seen dons
20:43:41 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 19h 48m 27s ago.
20:44:14 <gwern> drat. well, does anyone else know how lambdabot prevents stuff in the IO monad from running?
20:44:19 <sfultong> I'm trying to use some networking io, and I'm getting an eof from a socket, and I don't know why...
20:44:39 <Binkley> gwern: presumably using the typechecker
20:44:46 <SamB_XP> gwern: by not importing unsafePerformIO, mostly
20:44:59 <gwern> Binkley: yes, I know that much. I also know it has something to with a clever use of show
20:45:01 <sorear> SamB_XP: Sometimes I use floating windows
20:45:11 <gwern> but I'm looking through the code and it's not clear at all to me how it actually does it
20:45:26 <sorear> gwern: show has nothing to do with IO in lambdabot
20:45:36 <SamB_XP> does the urxvt author use tiling exlusively or something?
20:45:51 <gwern> sorear: 'An instance of Show IO is defined, which prints "<IO>", rendering IO impossible (otherwise, showing the IO would result in a type error, and still not run it). Actually instances for IO and (->), using Typeable, are used to show the specific types of all IO and functions (e.g. putStrLn --> <[Char] -> IO ()> )'
20:45:59 <gwern> sorear: from http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
20:46:01 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/3alo2u
20:46:09 <sfultong> gwern: but lambdabot doesn't run IO
20:46:12 <sorear> gwern: (otherwise ... and still not run it)
20:46:19 <sorear> gwern: you missed that bit, it seems
20:46:44 <OceanSpray> turns out that #monad redirects to #Powershell
20:46:57 * sorear fixes that broken article
20:47:06 <gwern> sorear: alright then, how does lambdabot do it?
20:47:12 <glguy> actually, using urxvt is perfect for me, urxvtd forked means I have no "primary" terminal window (I'm using X-win32 right now)
20:47:21 <sorear> gwern: By not importing System.IO.Unsafe
20:47:23 <gwern> is it the -fextended-default-rules option passed to ghc?
20:47:41 <sfultong> gwern: by using only pure functions
20:47:55 <gwern> sorear: I don't understand why that would do it. aren't there a lot of other libraries/modules offering IO stuff?
20:48:02 <SamB_XP> you know what looks funny? when you do output from TH splices...
20:48:22 <SamB_XP> ... in expressions evaluated by GHCi or ghc -e
20:48:24 <sfultong> anyone know about network io?
20:48:40 <ddarius> gwern: And they all expose the IO type in them.
20:48:56 <sorear> gwern: only about three (Foreign, Control.Monad.ST, System.IO.Unsafe); besides, we use a whitelist and manually audit all modules before adding them to the bot's imports
20:50:13 <gwern> so simply doing 'import System.IO.Unsafe ()' and so on for the three dangerous libraries is enough to make anytying with IO in the type sig fail to check?
20:50:45 <oerjan> gwern: lambdabot evaluates show exp, which is always pure of type String
20:50:48 <ddarius> gwern: IO stuff type checks.  All lambdabot does is only import safe modules and safe functions.
20:51:10 <SamB_XP> why, look at this:
20:51:22 <SamB_XP> > getContents
20:51:24 <oerjan> without the unsafe operations it is impossible for an expression of type String to do IO
20:51:24 <lambdabot>  <IO [Char]>
20:51:48 <sfultong> is the whitelist necessary, if haskell has very well defined unpure libraries?
20:52:03 <ddarius> sfultong: Who knows what later versions will add.
20:52:29 <SamB_XP> anyway, they should also be auditing for namespace collisions...
20:52:33 <ddarius> In general security should ideally be opt-in rather than opt-out.
20:52:51 <SamB_XP> which I think they didn't do very well...
20:52:53 <SamB_XP> > pure
20:52:54 <lambdabot> Terminated
20:53:00 <SamB_XP> > pure id
20:53:01 <lambdabot> Terminated
20:53:36 <sfultong> ddarius: I thought everyone ignored that guideline
20:53:38 <ddarius> SamB_XP: It should give a better response for namespace collisions, it doesn't really need to avoid them.
20:53:39 <sfultong> :t pure
20:53:41 <lambdabot>     Ambiguous occurrence `pure'
20:53:41 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
20:54:05 <andyjgill_> Is anyone working on a 'rope' implementation of strings for Haskell?
20:54:18 <SamB_XP> ddarius was, last I heard
20:54:34 <ddarius> andyjgill_: I am.  I haven't hacked at it much of late.
20:54:36 <gwern> hmm. but all this is necessary because lambdabot is trying to take in Strings and turn them into arbitrary a -> a stuff, correct? in normal code, it's enough to specify foo :: (String -> String) -> String stuff to guarantee no IO will be taking place, right?
20:54:46 <bos> @src lines
20:54:46 <lambdabot> Source not found. stty: unknown mode: doofus
20:54:54 <SamB_XP> hmm, I guess I didn't really need to say that ;-)
20:54:57 <gwern> but actually, that (String -> String) could itself be using an unsafe function in it, couldn't it?
20:54:57 <bos> grmph.
20:54:59 <ddarius> andyjgill: The only critical thing missing is rebalancing.  Otherwise it should work.
20:55:43 <ddarius> gwern: In general, security comes down to "namespace control".
20:56:36 <andyjgill_> Can you tell me more? I heard about rope for the ICFP contests, and read the paper, but I'm still trying to get my head round what API is used
20:56:52 <andyjgill_> I mean, the append of strings has been used in FL forever.
20:57:18 <ddarius> andyjgill_: I'm just copying the bytestring API for the most part.
20:57:19 <gwern> ddarius: ok. how do I write a higher order function that can execute others securely? I thought that simply disallowing IO would be enough, but that doesn't seem to be true
20:57:36 <andyjgill_> have you a URL of the API?
20:57:53 <ddarius> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString-Lazy.html
20:57:55 <lambdabot> http://tinyurl.com/244l36
20:58:12 <ddarius> gwern: If you have no control of the input you get, you can't readily.
20:58:13 <oerjan> sorear: what is the ! kind? it's not listed in http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
20:58:15 <lambdabot> Title: IntermediateTypes - GHC - Trac
20:58:36 <sorear> oerjan: I have absolutely no clue, but I know it exists because I've seen it myself
20:58:45 <sorear> @kind GHC.Prim.MutableByteArray#
20:58:47 <lambdabot> * -> !
20:59:34 <sfultong> gwern: disallowing IO is enough except in special cases where libraries break the pureness of haskell
20:59:40 <gwern> ddarius: hmm. I'll expand on what I'm trying to do: I want to define a function 'sandbox' which will take a pure function, chroot somewhere, set ulimits, drop privileges by changing userids and gid, and then execute the function provided as an argument.
21:00:20 <gwern> the idea being I guarantee as much security in the type system (like I thought lambdabot was doing), and then the OS level ulimit and uid and chroot stuff serves as backup
21:00:36 <SamB_XP> gwern: that works great as long as you don't want those privileges back ;-P
21:01:12 <gwern> SamB_XP: well, a pure function should have no need of those privileges, right?
21:01:19 <ddarius> If Haskell and your OS used capabilities this would be a non-issue.
21:01:40 <sfultong> gwern: what do you intend the pure fuction to be able to do? if it's pure, then how will it do anything? :-P
21:01:47 <gwern> (...it's not reading files, it's not writing files, and if it's using so much resources that it hits ulimits, the function might've gone haywire in some way...)
21:02:09 <sfultong> ddarius: capabilities?
21:02:10 <ddarius> sfultong: It will interact with the rest of gwern's code.
21:02:20 <ddarius> http://www.erights.org
21:02:20 <SamB_XP> why are you running untrusted code with arbitrary imports anyway?
21:02:21 <lambdabot> Title: Welcome to ERights.Org
21:02:47 <sfultong> ddarius: true, but gwern hasn't specified how
21:02:54 <sorear> gwern: Haskell's type system was designed to stop you from shooting YOURSELF in the foot.  Not to stop other people from shooting you, and it shows.
21:03:07 <gwern> sfultong: it's a sketch for an idea: three functions, one for doing sudo stuff, another for doing stuff interacting with system binaries and the user's files, and a third running as nobody executing the pure functions the results of which the other two might want to make use of
21:03:47 * gwern wonders if I should call all three monads. probably not
21:04:06 <ddarius> sfultong: http://www.erights.org/talks/myths/index.html specifically is a decent introduction I believe
21:04:07 <lambdabot> Title: Capability Myths Demolished
21:04:16 <gwern> ddarius: it would be nice if we had microkernels with fancy capability-based security and all that/ but I'm afraid as a reality we've got to make do with privilege separation and dropping
21:04:22 <sorear> gwern: running everything as nobody might not be a great idea.  What else of potential importance is running as nobody?
21:04:31 <sfultong> ddarius: interesting, thanks
21:04:44 <gwern> sorear: offhand, I can only think of finger
21:05:04 <sfultong> I'm tired of unix... I want something better :-P
21:05:21 <ddarius> Eros, KeyKOS, SELinux
21:05:37 <wli> SELinux does not differ significantly from Linux.
21:05:38 <sorear> gwern: fine.  What damage can I do if I'm allowed to use my ptracey tentacles of death to subvert the finger daemon?
21:05:43 * ddarius wants Xok.
21:05:45 <wli> k42 could be interesting.
21:05:51 <wli> I'm not familiar with Xok.
21:06:06 <ddarius> @google Xok exokernel
21:06:08 <lambdabot> http://lists.tunes.org/archives/lispos/1997-August/001788.html
21:06:09 <lambdabot> Title: Code for the Xok exokernel from MIT?
21:06:13 <gwern> sorear: you could lie to whatever bizaare people still use finger
21:06:32 <gwern> and I think finger asks for ~/.plan, but that seems about it
21:07:23 <ddarius> http://pdos.csail.mit.edu/exo/
21:07:25 <lambdabot> Title: MIT Exokernel Operating System
21:07:27 <sorear> Don't IRC servers normally auto-finger and statistically analyse before letting you on?
21:07:39 <mrd> identd perhaps
21:07:47 <gwern> sorear: doubt it. I don't have finger installed, and here I am
21:07:55 <allbery_b> identd
21:08:07 <allbery_b> some of them do portscans looking for various windows backdoots
21:08:13 <gwern> exokernels are interesting, but did they ever solve how to provide file systems securely?
21:08:16 <allbery_b> but no finger
21:08:22 <ddarius> gwern: Yes.
21:08:25 <allbery_b> only us dinosaurs run fingerd any more
21:08:39 <ddarius> Dawson Engler's Master's thesis is an awesome read.
21:08:48 <oerjan> :k ByteArray#
21:08:57 <lambdabot>     Not in scope: type constructor or class `ByteArray#'
21:09:05 <gwern> ddarius: I take it he did it on that problem?
21:09:18 <gwern> sorear: where were you going with the finger questions anyway?
21:09:21 <oerjan> :k GHC.Prim.ByteArray#
21:09:22 <lambdabot> !
21:09:25 <ddarius> gwern: He did it on exokernels in general with about a third of it on file systems.
21:09:26 <sorear> How do you find a backdoor that easily?  If I was a cracker, I'd hide my backdoor way better than just binding to a fixed port!
21:10:13 <gwern> ddarius: sounds like a good read then.I'll hve to look for it
21:10:25 <allbery_b> but some of them did just that
21:10:38 <allbery_b> look up backorifice
21:10:42 <sorear> gwern: I subvert your GHC using something like bug #229.  You think you've protected yourself by changing UID.  I ptrace(2) your $IMPORTANT_DAEMON_RUNNING_AS_NOBODY.
21:11:09 <gwern> ddarius: it wasn't 'Fast and flexible Application-Level Networking on Exokernel Systems', was it?
21:12:38 <ddarius> http://www.stanford.edu/~engler/
21:12:39 <gwern> sorear: ok, so ptrace modifies a running process. but it's running as nobody so it can't escalatate, and if it's using privilege separation, the root part is a seaprate un-ptraceable process, if I understand these things
21:12:42 <lambdabot> Title: Dawson Engler
21:13:18 <ddarius> "The Design and Implementation of a Prototype Exokernel Operating System"
21:13:30 * kpreid returns, sees mention of capabilities
21:13:36 <kpreid> got any questions, ask me :)
21:13:45 <gwern> so either it was doing trivial things as nobody, or it'll fail when you make abnormal erroneous requests to the root process part?
21:14:06 <sorear> trivial is very relative
21:14:33 <sorear> your webserver is trivial as far as the OS is concern, but if I control it I can make you say arbitrarily damaging things
21:15:47 <ddarius> gwern: Hmm, this might be the wrong one, let me look.
21:16:51 <gwern> sorear: fair enough. I've seen many examples in security where people went 'oh but there's no way you can get there from here'. so I guess I have to disallow system calls (like ptrace) as well as file IO
21:16:57 <ddarius> Ah, probably his PhD is the one I want.
21:17:06 <ddarius> http://pdos.csail.mit.edu/exo/theses/index.html
21:17:07 <lambdabot> Title: MIT Exokernel Theses
21:17:55 <gwern> but surely changing pid and gid to nobody is still an improvement, since now your rogue function could only write to global files and not also the user's?
21:18:38 <gwern> ddarius: ah, thanks
21:18:56 <sorear> Yes, it's an improvement.
21:19:21 <thoughtpolice> wee! my irc bot is now v0.1. :) hopefully some people on haskell-cafe can give me some criticism...
21:19:25 <sorear> thoughtpolice++
21:19:28 <ddarius> So Dawson Engler's -PhD- thesis is an awesome read.  I don't think I've ever read his Master's thesis.
21:19:31 <thoughtpolice> sorear: ty. :)
21:19:40 <sorear> thoughtpolice: What does darcs.h.o have to do with being able to use darcs?
21:19:46 <ddarius> Yay! Time to exploit thoughtpolice's machine.
21:19:53 <thoughtpolice> sorear: I have no place to put my code repos. :(
21:20:15 <thoughtpolice> I suppose it would have been better said "there's no online code repo..." but oh well.
21:20:27 <sorear> thoughtpolice: Your webserver doesn't let you use subdirectories?
21:20:41 <thoughtpolice> sorear: I don't have ssh access nor does it have darcs so I can't push patches there
21:20:44 <sorear> thoughtpolice: How did you provide that .tar.gz link without hosting
21:20:46 <gwern> (dang. a lot of interestingly titled papers on that page. there go another bunch of hours. funny how I've read so many papers because of haskell)
21:20:58 <thoughtpolice> sorear: I access my server through ftp.
21:21:06 <sorear> thoughtpolice: you don't need darcs installed remotely.  just copy the files over
21:21:08 <SamB_XP> thoughtpolice: that stinks
21:21:26 <SamB_XP> get one you can rsync with at least!
21:21:44 <sorear> I access my server through ftp too, and I have several public darcs repositories.
21:21:55 <thoughtpolice> SamB_XP: it's a friend's server in sweden and he's been gracious enough to host me for free over the past few years (I have old code snips going back to 2004...)
21:22:43 <Binkley> thoughtpolice: so have your friend install sshd :-)
21:22:48 <thoughtpolice> sorear: I just find it a hassle, although I could do that for the time being. the previous place I put my repos was a small free shell account that was kind enough to install darcs on request, but they're down for the next quarter. :/
21:23:09 <thoughtpolice> @ #haskell: i know I know. :) it sucks but I'll get around to it. you don't need to alert. :)
21:23:26 <SamB_XP> thoughtpolice: ask him if there's any alternative way you could update directories on the server
21:23:28 <sorear> it's not that much of a hassle if you know basic shell scripting.
21:23:31 <ddarius> thoughtpolice: Read "A Concurrent Windowing System" by Rob Pike and ponder how to apply it to your bot.
21:23:40 <thoughtpolice> ddarius: ty.
21:23:44 <sorear> $ upload-dir vty  # that was such a hassle!
21:23:55 <SamB_XP> sorear: yes
21:24:00 <SamB_XP> you had to write the shell script
21:24:03 <thoughtpolice> sorear: I'm a completely lazy sod. i'll get around to it if it makes you sleep better at night, though.
21:24:36 <hpaste>  sorear pasted "okay, now you're just making me feel guilty" at http://hpaste.org/2196
21:24:50 <thoughtpolice> sorear: thanks. :)
21:25:00 <sorear> ah, phew
21:25:13 <thoughtpolice> anyway, I gotta go. thanks for all the quick feedback though. :)
21:25:18 <sorear> it occured to me right after pasting that I didn't remember if it had passwords :)
21:25:35 <thoughtpolice> later!
21:25:43 <ddarius> That was the first thing I checked for.
21:25:48 * thoughtpolice --status=away &> /dev/null &
21:26:25 <sorear> .netrc++
21:26:46 * ddarius has the urge to completely revamp lambdabot's plugin system.
21:27:27 <sorear> go ahead, the current one is terrible
21:27:34 <SamB_XP> sorear: that would be cooler if unix had actual list syntx :-(
21:28:10 <sorear> I think the current one was written by a PhD-student infatuated with dynamic loaders ;)
21:28:43 <ddarius> @version
21:28:44 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
21:28:44 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:28:55 <SamB_XP> ... and subsequently had the dynamic loading feature bitrot ...
21:29:16 <ddarius> The actual loading and unloading should end up the same it's just how they would communicate and raising the composability.
21:29:26 <SamB_XP> which was quite annoying on my PII 450 with 256 megs of RAM
21:29:55 <SamB_XP> ddarius: oh, you mean modules would be able to talk with eachother?
21:29:58 <SamB_XP> that would be nice
21:30:28 <ddarius> SamB_XP: Yep.  You could have modules like . that combine them in crazy ways.
21:31:14 <byorgey> higher-order modules!
21:31:23 <ddarius> byorgey: Yep.
21:31:41 <bitwize> something like ML functors :)
21:32:11 <ddarius> bitwize: One more first class, which is to say something like functions.
21:32:17 <wli> ML functors would be nice.
21:32:48 <ddarius> wli: You can encode them in Haskell for the most part.  It's not even all that painful.
21:34:01 <sorear> It just requires too much indentation :)
21:35:10 <gwern> I was annoyed to see that on gentoo, to install hs-plugins aparently requires ghc-6.4. something
21:37:16 <wli> ddarius: Not really. Scope-local module imports were a major feature for me. Things like nameclashes between Data.List and Data.Map would be handled by only opening the modules in scopes where they were used, for example.
21:38:04 <Smokey`_> ugh, frustrating router. (did you get what I said about haskell ebuilds?)
21:38:10 <sorear> No.
21:38:23 <Smokey`_> <-- gentoo user,  simple words of advice...  don't use the portage tree for Haskell :P  from my experience.  (same thing goes for mono)
21:38:28 <Smokey`_> I don't think the ebuilds are kept up to date
21:38:41 <wli> That sort of fine-grained control of the scope of imports is sorely lacking (and actually doesn't even require the full ML module system by any means).
21:38:44 <sorear> gwern: Does gentoo normally package unreleased software?  Hs-plugins hasn't been released since after it was updated for 6.6.
21:39:32 <wli> ddarius: Control over the scoping of instances is a major PITA too.
21:40:56 <gwern> sorear: it was masked, but I unmasked it because I wanted to try out lambdabot, and cabal complained it needed it
21:43:04 * wli bumps up against what he needed the Mersenne Twister monad transformer for.
21:47:50 <wli> sum $ takeWhile (<=10^6) $ nubBy (\x y -> gcd x y > 1) [2..] is apparently still running.
21:49:20 <Binkley> that's a lot of eggs
21:49:28 <wli> No kidding.
21:51:00 <wli> Hmm. I apparently need to produce random arbitrary-precision integers in some range, not just 32-bit ones.
21:53:55 <sorear> randomR
21:54:22 <wli> IO monad; I'll want a PRNG
21:55:40 <wli> Oh, maybe not...
21:56:12 <glguy> this 14755 mode is pretty cool
21:56:23 <wli> glguy: What's that?
21:56:42 <glguy> but to input say a Î», do I just have to remember that lambda is 03bb ?
21:56:57 <glguy> wli: it's rxvt-unicode's want to input unicode characters by hex value
21:57:07 <glguy> and it has a little preview box
21:57:13 <glguy> as you type the characters in
21:57:16 <byorgey> hrm, anyone have any ideas why I'm getting " Illegal instance declaration for `Arbitrary (Ratio Integer)'"?
21:57:33 <byorgey> What's wrong with declaring Ratio Integer an instance of Arbitrary?
21:57:39 <dolio> -fglasgow-exts?
21:58:10 <byorgey> that would do it, thanks =)
21:58:13 <byorgey> dolio++
21:58:30 <byorgey> particularly unhelpful error message...
21:58:31 <kpreid> how about (Arbitrary a) => Arbitrary (Ratio a)?
21:58:59 <kpreid> that should be doable with no glasgow-exts
21:59:05 <dolio> Yeah.
21:59:11 <byorgey> kpreid: that would work too, but the way I have it implemented right now it only works for Rationals.
21:59:22 <kpreid> okay, evil form:
21:59:34 <byorgey> kpreid: doing an instance for general Ratio a would require a lot more machinery, I think
21:59:52 <kpreid> class (Arbitrary a, Foo a) => Arbitrary (Ratio a); class Foo; instance Foo Integer
22:00:01 <glguy> a
22:00:39 <kpreid> class Foo a where foo :: a -> Integer
22:00:49 <kpreid> then write your Arbitrary (Ratio a) instance using foo
22:00:51 <byorgey> hrm... but then you can't do Integer-y things with values of type a, because class Foo... never mind =)
22:02:47 <dolio> Actually...
22:02:50 <dolio> @type (%)
22:02:52 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
22:03:16 <oerjan> @src Ratio
22:03:16 <lambdabot> data (Integral a) => Ratio a = !a :% !a
22:03:21 <dolio> That's the only way you'll likely construct a Ratio, no? So you're pretty restricted as is.
22:03:34 <byorgey> dolio: true.
22:03:59 <wli> sorear: randomR will do... I thought this thing was tied to IO
22:04:07 <sorear> glguy: No, you can just keep a note-file with commonly used characters :)
22:06:40 <ddarius> :t fromMaybe
22:06:42 <lambdabot> forall a. a -> Maybe a -> a
22:10:23 <pjd> glguy: compose key?
22:10:48 <glguy> pjd: I don't know if X-win32 supports that, but its something to look into
22:11:01 <pjd> ah, condolences
22:11:25 <glguy> its a trade off I'm willing to make :)
22:15:04 <wli> Hmm... [2 `lcm` 3, (2 `lcm` 3) `lcm` 4, ((2 `lcm` 3) `lcm` 4) `lcm` 5, ...]
22:15:21 <ddarius> @index fromMaybe
22:15:21 <lambdabot> Data.Maybe
22:15:37 <glguy> wli: looks like a scanl
22:15:49 <dolio> > scanl1 lcm [1..]
22:15:50 <lambdabot>  [1,2,6,12,60,60,420,840,2520,2520,27720,27720,360360,360360,360360,720720,12...
22:16:14 <wli> Cool, thanks.
22:16:34 <kpreid> 360360? that's an interesting sequence
22:19:01 <oerjan> i think it increases only at prime power indices
22:19:59 <wli> oerjan: Interesting idea.
22:20:42 <sorear> oerjan: true
22:21:15 <shachaf> @djinn a -> Maybe a -> a
22:21:15 <lambdabot> f a b =
22:21:16 <lambdabot>     case b of
22:21:16 <lambdabot>     Nothing -> a
22:21:16 <lambdabot>     Just c -> c
22:21:35 <shachaf> @src fromMaybe
22:21:35 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
22:21:45 <dolio> @type flip maybe id
22:21:47 <lambdabot> forall a. a -> Maybe a -> a
22:22:01 <shachaf> @ty (`maybe` id)
22:22:03 <lambdabot> forall a. a -> Maybe a -> a
22:22:27 <wli> > map head $ groupBy (curry $ uncurry (==) . join (***) snd) $ zip [1..] $ scanl1 lcm [1..]
22:22:28 <lambdabot>  [(1,1),(2,2),(3,6),(4,12),(5,60),(7,420),(8,840),(9,2520),(11,27720),(13,360...
22:23:01 <wli> What was that about prime power indices?
22:23:06 <sorear> oerjan: oerjan(X) = product [ p^supremum [i | i <- [0..], p^i <= X] | p <- primes ]
22:23:31 <oerjan> yeah
22:24:41 <oerjan> wli: if a number is divisible by more than one prime, it can be split up into two smaller numbers whose lcm is equal to it
22:25:03 <wli> oerjan: I meant it as confirmation.
22:27:00 <glguy> > zip [1..] $ nub $ scanl1 lcm [1..]
22:27:02 <lambdabot>  [(1,1),(2,2),(3,6),(4,12),(5,60),(6,420),(7,840),(8,2520),(9,27720),(10,3603...
22:27:10 <glguy> oh, nvm :)
22:27:14 <glguy> I see what you wrote
22:27:53 <glguy> > nubBy (\x y -> snd x == snd y) $ zip [1..] $ scanl1 lcm [1..]
22:27:55 <lambdabot>  [(1,1),(2,2),(3,6),(4,12),(5,60),(7,420),(8,840),(9,2520),(11,27720),(13,360...
22:28:57 <shachaf> @let on f g x y = g x `f` g y
22:29:01 <lambdabot> Defined.
22:29:36 <glguy> on might have been in scope... but I didn't feel like retyping it again :)
22:30:06 <dolio> > (==) `on` snd
22:30:07 <lambdabot>  Add a type signature
22:30:11 <shachaf> @ty on -- I don't think so.
22:30:13 <lambdabot> Not in scope: `on'
22:30:17 <dolio> :t on
22:30:18 <lambdabot> Not in scope: `on'
22:30:26 <dolio> > on
22:30:27 <lambdabot>  Add a type signature
22:30:40 <glguy> on is in some version of GHC
22:30:46 <glguy> isn't it?
22:30:48 <oerjan> that's not quite proof, the plugins are not communicating
22:30:48 <shachaf> @ty let on f g x y = g x `f` g y in on
22:30:49 <dolio> It's in head.
22:30:50 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
22:30:54 <shachaf> glguy: Yes, base-2.1.
22:31:05 <shachaf> glguy: In Control.Function, I think?
22:31:09 <glguy> Data.
22:31:10 <glguy> ?
22:31:25 <shachaf> Maybe, yes.
22:31:41 * shachaf thought it was Data., but then thought it didn't make sense.
22:31:46 <shachaf> But it probably does.
22:31:53 <shachaf> @source Data.Function
22:31:53 <lambdabot> Data.Function not available
22:31:58 <shachaf> @source Data.List
22:31:58 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
22:32:22 <wli> > let primes = 2 : 3 : 5 : [p | p <- [7,9..], all (\q -> p `mod` q /= 0) (takeWhile (\q -> q^2 <= p) primes)] ; factors n | n == 1 = [] | otherwise = let p = head [p | p <- primes, n `mod` p == 0] in p : factors (n `div` p) ; factor n = map (\xs -> case xs of { [] -> (1,1) ; _ -> (head xs, length xs)}) $ group $ factors n in take 25 $ map (first factor) $ map head $ groupBy (curry $ uncurry (==) . join (***) snd) $ zip [1..] $ scanl1 lcm [1..]
22:32:23 <lambdabot>  [([],1),([(2,1)],2),([(3,1)],6),([(2,2)],12),([(5,1)],60),([(7,1)],420),([(2...
22:32:32 <glguy> http://darcs.haskell.org/packages/base/Data/Function.hs exists
22:33:08 <glguy> and it adds 'on' and 'fix'
22:33:24 <sorear> glguy: @source hasn't been updated in a long time
22:33:29 <shachaf> 'fix' is moved from Control.Monad.Fix?
22:33:46 <glguy> sorear: I wasn't suggesting that I expected lambdanot to know :)
22:33:51 <shachaf> sorear: Shouldn't it default to base if it doesn't know where to look?
22:33:55 <wli> Could not find module `Data.Function':
22:34:08 <sorear> shachaf: What do you mean, default to base?
22:34:09 <glguy> wli: your ghc isn't bleeding edge enough :)
22:34:18 <glguy> http://darcs.haskell.org/packages/base/...
22:34:20 <lambdabot> Title: Index of /packages
22:34:21 <sorear> shachaf: it has a compiled-in lookup table!
22:34:25 <shachaf> sorear: Give a link to bae/Data/Function.hs.
22:34:35 <sorear> ah, right.
22:34:40 <shachaf> sorear: If it can't look it up successfully.
22:34:51 <sorear> yeah, I get it
22:35:02 <oerjan> shachaf: i don't know about that, it is irritating enough that it gives links to non-existing hackage packages
22:35:52 <shachaf> oerjan: So it should say "I don't know, but maybe this'll work? ...".
22:36:05 <sorear> @wiki is nicely broken in the same way.
22:36:06 <lambdabot> http://www.haskell.org/haskellwiki/is_nicely_broken_in_the_same_way.
22:36:09 <oerjan> perhaps
22:36:52 <shachaf> sorear: That's broken?
22:37:00 <shachaf> sorear: What if I want to make a new page?
22:37:02 <sorear> shachaf: Very much so.
22:37:10 <sorear> @wiki Library submissions process
22:37:11 <lambdabot> http://www.haskell.org/haskellwiki/Library_submissions_process
22:37:16 <shachaf> sorear: Should it connect to the wiki and check whether the page is found?
22:37:33 <sorear> Oh, wait, I just sent someone on a wild chase!  The page is actually called Library submissions!
22:37:40 <shachaf> Or should it to the lambdabot correcting thing?
22:38:18 <shachaf> Perhaps the wiki should point to a search if you go to a page that isn't found.
22:38:42 <sorear> shachaf: No, it should have a local list of valid pages, updated periodically by scraping Special:Recentchanges&feed=rss
22:39:31 <shachaf> sorear: And correct automatically?
22:40:11 <sorear> No, more like the @source situation, but not out of date.
22:41:05 <shachaf> How is being like @source useful?
22:41:21 <shachaf> @source Something.That.Exists
22:41:21 <lambdabot> Something.That.Exists not available
22:41:35 <shachaf> At least @source knows to look in base/mtl/etc.
22:41:53 <shachaf> But @wiki would have no advantage to printing an error if the page doesn't exist.
22:45:34 <fnord123> @Source TreeView
22:45:34 <lambdabot> TreeView not available
22:45:49 <fnord123> @Source StateMonad
22:45:50 <lambdabot> StateMonad not available
22:45:58 <shachaf> @source Control.Monad.State
22:45:59 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
22:47:04 <fnord123> @source State
22:47:04 <lambdabot> State not available
22:47:19 <fnord123> hm if you know the package then getting the source isn't so hard.
22:47:42 <shachaf> fnord123: There's @index.
22:47:50 <dolio> @index State
22:47:50 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS, Test.HUnit.Base, Test.HUnit, Test.HUnit.Base, Test.HUnit, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.
22:47:50 <lambdabot> Parsec, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
22:47:54 <shachaf> And @hoogle.
22:48:02 <fnord123> ah ok
22:55:36 <Binkley> ?yow
22:55:36 <lambdabot> I am a traffic light, and Alan Ginzberg kidnapped my laundry in 1927!
22:56:29 <magnus_> Is there any alternative to getProgName that returns the whole path of the program instead of just the name of it?
22:56:54 <magnus_> getProgname strips away the path :(
22:57:07 <magnus_> for the sake of "portability"
22:58:45 <sfultong> if you have a posix os, try getWorkingDirectory
22:59:14 <magnus_> I'll check it out
23:00:41 <magnus_> are you sure about the name of that function?
23:01:48 <magnus_> there is getCurrentDirectory but that is not what I need
23:03:33 <magnus_> aha, in System.Posix. Thanks!
23:04:01 <magnus_> but it is not either what I want :)
23:06:26 <sorear> magnus_: There is no way to find out the canonical file name of the current executable.
23:07:06 <ClaudiusMaximus> here's the presentation I gave at AngloHaskell on friday: (optimized for 1024x768 viewport, firefox on Linux, requires javascript) http://claudiusmaximus.goto10.org/anglohaskell2007/AngloHaskell2007.xml
23:07:09 <lambdabot> http://tinyurl.com/2be227
23:07:23 <sorear> magnus_: (on UNX)
23:07:26 <sorear> +I
23:08:18 <sorear> magnus_: on linux you can call readlink("/proc/self/exe"), which is almost but not quite the answer - it misbehaves when a file has more or less than 1 link
23:08:31 <sorear> magnus_: in general, a running program can have NO file name
23:08:42 <sorear> magnus_: consider running a program and the deleting it
23:10:06 <magnus_> I see... I needed it for outputting debug info, but I used ps aux | grep my-program-name instead to figure out which one was being executed so I'm fine now
23:10:21 <magnus_> thanks for the tip
23:12:43 <bwwx> @seen dcoutts
23:12:43 <lambdabot> dcoutts is in #ghc, #gentoo-haskell and #haskell. I don't know when dcoutts last spoke.
23:14:48 <ddarius> :t genericLength [] :: CULong
23:14:51 <lambdabot>     Not in scope: type constructor or class `CULong'
23:14:59 <ddarius> @index genericLength
23:15:00 <lambdabot> Data.List
23:15:05 <sfultong> ClaudiusMaximus: ooo! puredata + haskell :)
23:16:16 <oerjan> :t genericLength []
23:16:18 <lambdabot> forall i. (Num i) => i
23:17:13 <sorear> ClaudiusMaximus: Seems pretty readable here (ELinks + no javascript) :)
23:17:24 <bos> andyjgill: ping
23:17:35 <wli> >> findFactor $ 2^1009-1
23:17:35 <wli> Left (ECFoundFactor 3454817)
23:17:35 <wli> it :: Either ECError [(Integer, Integer)]
23:17:35 <wli> (43.77 secs, 4978219464 bytes)
23:17:40 <ClaudiusMaximus> sorear: i guess no CSS either?
23:17:50 <sorear> ClaudiusMaximus: Oh, sure, I have CSS.
23:18:02 <sorear> ClaudiusMaximus: Modulo the fact that my only font is 1x1
23:18:07 <sorear> (character cell that is)
23:18:33 <ClaudiusMaximus> sorear: ok
23:18:54 <wli> Trick here is that I don't know when to stop iterating if/when it's prime.
23:19:11 <wli> So it needs a primality test.
23:19:49 <wli> Okay, the dumb prime sum is killed after several hours.
23:20:00 <andyjgill> Hi Brian
23:20:27 <kjdf> how to check operator precedence?
23:20:35 <shachaf> Isn't it Bryan? :-)
23:20:37 <shachaf> :info
23:20:50 <kjdf> thanks
23:21:22 <andyjgill> s/Brian/Bryan/
23:22:36 <kjdf> and what is the precedence of infixified `functions`?
23:22:50 <shachaf> @where report
23:22:50 <lambdabot> http://www.haskell.org/onlinereport/
23:23:07 <oerjan> kjdf: they can be declared too
23:24:57 <shachaf> infixl 9
23:28:27 * ddarius considers doing something mildly evil for his Storable instance.
23:28:33 <kjdf> thanks.
23:29:03 <wli> http://www.apple.com/acg/pdf/aks3.pdf <-- looks useful
23:29:58 <sorear> kjdf: But you can override it if you want.  infixr 2 `fun`
23:30:40 <wli> I found 5080711 as a factor of 2^1039 - 1 in just 56.66 secs, 6408411132 bytes
23:41:54 * wli takes a quick stab at finding a factor of 2^(2^7)+1
23:43:19 <wli> 2^(2^6)+1 only took 3.19s
23:44:22 <mae> can you use "when" with a function like in erlang?
23:44:33 <mae> f(x) = x +1 when x = 0
23:44:56 <nornagon> f x | x == 0 = x + 1
23:45:16 <wli> Pattern guards are there for that.
23:45:27 <mae> what other syntax is there to do this?
23:45:34 <dfrey> How can I do an IO action that does nothing.  Say for example I wanted to write a function that takes in a string and prints it if it is longer than 10 characters.  if length s > 10 then putStr s else ????
23:45:47 <shachaf> dfrey: return ()?
23:45:52 <wli> dfrey: return ()
23:45:52 <dfrey> right
23:45:58 <dfrey> thanks
23:47:02 <shachaf> Note that length s > 10 may be too strict?
23:47:05 <wli> feh, I can't figure out the special prime -finding step of AKS
23:51:04 <psykotic> there isn't a hack for getting user defined prefix operators to work, is there? iirc unary - mapping to negate is just a special case hack
