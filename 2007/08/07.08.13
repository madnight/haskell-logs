00:00:05 <shachaf> OceanSpray: No need to :k values, it's for types. :-)
00:00:13 <shachaf> @ty Data.IORef.readIORef
00:00:15 <lambdabot> forall a. GHC.IOBase.IORef a -> IO a
00:00:19 <OceanSpray> ah.
00:03:08 <OceanSpray> does foo <- bar mean let foo = return bar ?
00:03:22 <shachaf> OceanSpray: No.
00:03:33 <OceanSpray> aww.
00:03:40 <shachaf> @undo do foo <- bar
00:03:40 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
00:03:46 <shachaf> @undo do foo <- bar; x foo
00:03:46 <lambdabot> bar >>= \ foo -> x foo
00:04:26 <bitwize> I rarely use do.
00:04:43 <opqdonut> @. pl undo do foo <- bar; x foo
00:04:43 <lambdabot> x =<< bar
00:04:46 <bitwize> >>= and >> are your friends. When you begin to think of them like Unix pipes they're not bad at all.
00:04:46 <opqdonut> :)
00:04:46 <shachaf> bitwize: Do you write the (>>=)s out?
00:05:03 <bitwize> (Didn't Oleg write something about the correspondence between monads and Unix plumbing?)
00:05:55 <bitwize> shachaf: yes, and my parser to consume, check, and aggregate the relevant bits of a PNM file turned into one huge (>>=)-fest
00:13:27 <psykotic> bitwize, piping/etc forms a monad if that's what you mean.
00:13:49 <ivant> @hoogle String -> ByteString
00:13:49 <lambdabot> No matches, try a more general search
00:13:52 <psykotic> with cat as left and right unit of |
00:14:21 <ivant> @hoogle Show a => a->ByteString
00:14:21 <lambdabot> No matches, try a more general search
00:14:29 <sorear> pack . show
00:14:52 <ivant> @ty pack
00:14:54 <lambdabot> Not in scope: `pack'
00:15:01 <psykotic> @ty Data.ByteString.pack
00:15:03 <lambdabot> [Word8] -> Data.ByteString.Base.ByteString
00:15:25 <psykotic> @hoogle Char -> Word8
00:15:25 <lambdabot> No matches, try a more general search
00:15:41 <ivant> pack . map c2w
00:15:44 <ivant> thanks!
00:16:27 <dolio> @type Data.ByteString.Char8.pack
00:16:29 <lambdabot> String -> Data.ByteString.Base.ByteString
00:16:32 <sorear> better idea, use pack from one of the Char bytestrings
00:16:37 <psykotic> ah, nice
00:16:42 * psykotic forgot about that
00:16:42 <sorear> Char8 or (better, but not in lambdabot) UTF8
00:16:51 <shachaf> @ty Data.ByteString.Lazy.Char8.pack
00:16:52 <lambdabot> [Char] -> Data.ByteString.Lazy.ByteString
00:17:08 <OceanSpray> :t lift
00:17:10 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
00:17:24 <OceanSpray> huh
00:17:55 <psykotic> OceanSpray, example. IO a -> StateT IO a.
00:18:02 <psykotic> actually that's bad, because IO is special. heh.
00:18:17 <OceanSpray> I got a function that returns LispErrT (IORef LispVal), but I want to use a function that returns LispErrT () inside a do in there
00:18:23 <shachaf> psykotic: Also, StateT needs a state. :-)
00:18:27 <psykotic> and that
00:18:35 <OceanSpray> how do I 'replace' the () with a IORef LispVal?
00:19:30 <psykotic> you can pass around IORefs like anything else. i don't get the problem.
00:19:38 <OceanSpray> pass around yes,
00:19:46 <OceanSpray> gimme some code?
00:19:57 <doserj> return <your ioref>
00:20:33 <psykotic> the IORef is just a handle. you don't need to do anything with the IO monad to just pass them around. could you give more detail about what you're trying to do?
00:21:06 <OceanSpray> apply :: LispProc -> LispVal -> LispEnv -> LispErrT (IORef LispVal)
00:21:30 <OceanSpray> apply Define (Pair (Symbol str) (Pair expr Null)) env = ... envInsert str val env
00:21:54 <OceanSpray> envInsert :: String -> (IORef LispVal) -> LispEnv -> LispErrT ()
00:22:28 <psykotic> so you have some IO-monad code in the ... that actually creates the IORef and you want to lift it into the LispErrT monad...?
00:22:34 <OceanSpray> yes
00:22:38 <OceanSpray> wait
00:22:50 <OceanSpray> yeah
00:22:57 <psykotic> :t liftIO
00:22:59 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
00:23:38 <psykotic> that's what you need. but you need to make sure your LispErrT thing implements MonadIO, which means it has to wrap an IO monad somehow. btw, LispErrT is misnamed; it doesn't look like a transformer, just a monad.
00:24:02 <psykotic> what is LispErrT's actual definition?
00:24:20 <OceanSpray> type LispErrT = ErrorT LispErr IO
00:24:34 <psykotic> in that case you can just use liftIO, since ErrorT implements MonadIO.
00:24:47 <psykotic> @info liftIO
00:24:48 <lambdabot> liftIO
00:25:28 <OceanSpray> Couldn't match expected type `IO (IORef LispVal)'
00:25:28 <OceanSpray>            against inferred type `LispErrT ()'
00:25:41 <OceanSpray> In the first argument of `liftIO', namely `(envInsert str val env)'
00:26:10 <OceanSpray> maybe I'm doing this wrong...
00:26:12 <doserj> shouldn't just "envInsert str val env ; return val" work?
00:26:33 <psykotic> yes, if the only problem is that.
00:27:41 <OceanSpray> oh hey, the return thing works
00:28:06 <psykotic> why were you talking about lift then? i thought you meant the problem was in the '...' :)
00:28:31 <OceanSpray> and I thought every function called in a do statement had to be of the same type as the function containing the do
00:29:13 <psykotic> of course not. in an imperative function, can you only call functions from within another function whose return type matches the calling function's return type? :)
00:29:19 <psykotic> *in an imperative language
00:29:37 * ivant writes DNA→RNA converter in Haskell. Evil StateT monads generate other evil StateT monads which do all the parsing work later — cool!
00:30:21 <Baughn> OceanSpray: Only the last statement in a do chain needs to match the entire chain's type. Or sets it. Whatever.
00:30:33 <lament> OceanSpray: perhaps you should look at what the do notation desugars into.
00:30:48 <Baughn> @undo do foo <- bar; return foo
00:30:48 <lambdabot> bar >>= \ foo -> return foo
00:30:49 <lament> OceanSpray: it's something you have to understand anyway
00:31:11 <ray> ivant: you could get a doctorate in computational biology!
00:31:30 <ivant> ray, ... of alien lifeforms :-)
00:31:42 <ray> pff, it's all theory anyway
00:32:18 <ray> you can invent whatever life form makes your thesis easier to write
00:32:34 <Baughn> Just don't start breeding alien lifeforms /here/. It's all fun and games until the screaming starts.
00:32:44 <ivant> :-)
00:32:51 <lament> just don't try to interbreed.
00:33:04 <opqdonut> it's all fun and games until the headcrab jumps you
00:33:19 <glguy> then its all fun and games and you can't see
00:33:24 <ivant> oh, by the way, I have a question
00:33:34 <glguy> o rly?
00:33:34 <ivant> suppose I have the following types:
00:33:49 <ivant> type PatternReader a = StateT PatternReaderState DNARunner a
00:33:57 <lament> IvanT a IO ()
00:34:15 <ray> ivan transformer
00:34:31 <Baughn> Isn't he supposed to be unique?
00:34:33 <ivant> when I write type DNARunner a = StateT DNAPosition IO a, ghc says I use DNARunner without a mandatory arg
00:34:39 <arcatan> wg 21
00:34:41 <ivant> in PatternReader
00:34:43 <arcatan> sorry
00:35:04 <ivant> however it should be without an arg (kind * -> *)
00:35:07 <opqdonut> http://pbfcomics.com/?cid=0PBF19051BC-Cromax.jpg#20
00:35:11 <opqdonut> related :)
00:35:11 <lambdabot> Title: The Perry Bible Fellowship
00:36:02 <glguy> ivant: there are some rules about when you can write "DNAPosition" without its argument
00:36:07 <ivant> but when I write type DNARunner = StateT DNAPosition IO, it goes just fine
00:36:09 <glguy> ivant: sometimes you'll need to use a newtype
00:37:09 <ivant> the strange thing is that type PatternMatcher = StateT Int DNARunner () is ok with any of the DNARunner definitions
00:39:02 <glguy> Haskell 98 says: Type constructor symbols T introduced by type synonym declarations cannot be partially applied; it is a static error to use T without the full number of arguments.
00:39:19 <glguy> but with glasgow-exts on, ghc treats them slightly differently iirc
00:39:53 <ivant> glguy, that's what I though. However it doesn't make a lot of sense, because I have two contradicting examples
00:42:00 <glguy> Does anyone know a good chat protocol for providing encrypted chats and verifying identities (something like silc)
00:42:43 <ohub> what's wrong with silc?
00:43:01 <glguy> Nothing yet, I'm just looking for things to consider first :)
00:43:08 <ivant> glguy, I guess jabber can fit your definition, however you might consider it overbloated
00:43:16 <ohub> jabber also has encryption, but I don't know to what extend
00:43:18 <glguy> I'm considering jabber too
00:43:40 <glguy> jabber has the advantage of wide client support
00:43:45 <glguy> making adoption easier
00:44:21 <ivant> glguy, however all jabber clients on linux suck :-(
00:44:47 <ivant> s/all/all that I tried (and that's a lot)/
00:44:47 <glguy> ivant: what do you consider a good IM client?
00:44:58 <glguy> not being limited to Linux?
00:46:03 <DRMacIver> What's wrong with pidgin?
00:46:29 <DRMacIver> (Aside from lack of voice support)
00:47:01 <ray> and the name!
00:47:14 * ray is tempted to fork it and rename it back to gaim
00:47:15 <DRMacIver> Heh
00:47:24 <ivant> glguy, there is a long list of features, but basically it boils down to being usable without mouse, working correctly under ion3/xmonad, having a working unicode support (that cuts all console-based clients I tried), not using overbloated libraries like kdelibs or gnomelibs
00:47:31 <DRMacIver> ray: I suspect they own the name.
00:48:00 <ray> but haven't they implicitly given it up to AOL by changing their name?
00:48:15 <ray> given some of their statements at least
00:48:22 <sorear> ivant: So basically you want irssi for jabber. :P
00:48:34 <DRMacIver> sorear: That sounds ideal to me.
00:48:41 <ray> /connect im.bitlbee.org
00:48:44 <ray> i think they do jabber
00:48:44 <DRMacIver> (But fails the unicode support doesn't it?)
00:48:45 <eivuokko> I use bitlbee with irssi.
00:48:51 <enolan> glguy: Off the record? IIRC it's implemented in gaim/pidgin.
00:48:52 <ivant> sorear, well, sounds like this
00:49:13 <enolan> http://www.cypherpunks.ca/otr/
00:49:14 <lambdabot> Title: Off-the-Record Messaging
00:49:40 <ray> i wish i didn't use bitlbee with irssi, but i do :(
00:49:48 <mm_freak_> <sorear> ivant: So basically you want irssi for jabber. :P ⇐ bitlbee, but its jabber support isn't particularly exciting
00:49:56 <ray> (it's the irssi part i dislike, not the bitlbee part)
00:49:56 <glguy> enolan: that looks interesting too
00:50:00 <mm_freak_> just like it's not exciting at any IM system =)
00:50:03 <kjdf> I am going to write a decent IM in haskell "real soon now"
00:50:22 <sorear> kjdf: Have you seen JohnMeacham's hircules?
00:50:24 <mm_freak_> ray: what's wrong with bitlbee+irssi?
00:50:33 <ray> the irssi part
00:50:38 <mm_freak_> what specifically?
00:50:59 <ray> don't like it
00:51:03 <ivant> kjdf, I'd vote for a non-sucking email client first, and then for an IM :-)
00:51:07 <mm_freak_> ok =)
00:51:17 <kjdf> sorear: not closely, doesn't seem to be under development
00:51:20 <ray> it was neat years ago, but i'm sick of it now :)
00:51:37 <mm_freak_> yes, and bitlbee development goes slow as hell
00:51:37 <kjdf> but I will definitely mine it for code ;)
00:52:17 <mm_freak_> but i'm also refraining from contributing, because i hate writing interfaces =)
00:52:46 <ray> you could just write haskellbee
00:53:26 <mm_freak_> i've so far never written anything networkish in haskell yet
00:53:40 <mm_freak_> not even anything (serious) concurrentish
00:53:51 <ray> can't be that hard, right?
00:54:13 <ray> i don't know, i just write scripts in it
00:54:25 <ivant> mm_freak_, just find the right places to add `par` in your sources, and you are ok :-)
00:54:31 <mm_freak_> it isn't, and i'd love to work on a serious project, but i just have no ideas =/
00:54:59 <mm_freak_> ivant: concurrent in terms of haskell threads =)
00:55:09 <mm_freak_> i.e. forkIO
00:55:27 <ivant> mm_freak_, heh, it is usually the opposite situation: one has tons of ideas but no time to implement them
00:55:57 <ray> oh, i never have ideas *or* time
00:55:58 <mm_freak_> ivant: then gimme some…  preferably simple things =)
00:56:44 <ivant> mm_freak_, easy digital assets management with automatical categorization and tagging. Nice project to do in haskell
00:57:33 <ivant> mm_freak_, IM which does not suck, email client which does not suck, remote collaboration on a single document (in Yi!)
00:58:00 <dolio> Yeah. Write me a haskell program that will automatically organize all my pdf papers about Haskell. :)
00:59:37 <DRMacIver> dolio: Not a bad task, really. :)
01:00:03 <DRMacIver> Good for practicing with the FFI I imagine.
01:00:21 <earthy> why?
01:00:25 <DRMacIver> In order to process the pdfs if nothing else.
01:00:26 <dolio> Hmm, perhaps. I don't know if anyone's written bindings to a PDF lib yet.
01:00:36 <opqdonut> a pdf parser in haskell!
01:00:41 <opqdonut> a worthy task
01:00:45 <DRMacIver> opqdonut: Ugh, no.
01:00:50 <DRMacIver> Parsing pdfs is painful.
01:00:51 <ivant> DRMacIver, first of all, good for figuring out the requirements and the good ways of implementing the solution
01:00:56 <dolio> @hackage HPDF
01:00:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HPDF
01:01:04 <DRMacIver> Cool.
01:01:07 <earthy> that's for generating, right?
01:01:16 <DRMacIver> Ah
01:01:17 <ivant> DRMacIver, not so painful, PDFs are easy (at least they were, when they were 1.3)
01:02:36 <ivant> hey, but digital assests are not only the PDFs. Think about your photo-collection (with all the IPTC tags and captions and stuff)
01:02:54 <ivant> think about your projects scattered on your machine
01:03:09 <kilimanjaro> dolio, it would be cool to do something for pdf papers similar to what musicbrainz does for audio files: it has a database of metainfo (probably trolled from citeseer and other places) and then matches documents on the local machine to their metainfo, but rather than relying on something stupid that would prevent two identical articles in slightly different pdf formats from not being identified as a single entity
01:03:10 <earthy> ugh. don't remind me
01:03:22 <earthy> hthumb is coming along nicely, but it's slow going
01:03:46 <ivant> @where hthumb
01:03:47 <lambdabot> I know nothing about hthumb.
01:03:55 <ivant> @go hthumb
01:03:56 <earthy> it's not published yet
01:03:58 <lambdabot> http://www.openmash.org/lxr/ident?c=tk8.3;i=hThumb
01:03:58 <lambdabot> Title: tk8.3 identfier search "hThumb"
01:04:13 <earthy> but cthumb sucks in a few ways
01:04:20 <earthy> so I'm writing a replacement
01:04:27 <earthy> ?go cthumb
01:04:28 <lambdabot> http://cthumb.sourceforge.net/
01:04:28 <lambdabot> Title: cthumb homepage
01:04:34 <opqdonut> cthumb sounds like cthulhu
01:05:41 <ivant> cthumb sounds like a wrong project to me. I don't actually care about web picture albums, I care about making a good photo-archive, where I can find the photos easily years later
01:06:05 <mm_freak_> ivant: see `ledger' =)
01:06:11 <DRMacIver> ivant: My main experience with pdfs is from working on a project where people were trying to convert them into swfs in a way which doesn't fuck up the rendering. :)
01:06:15 <mm_freak_> ivant: http://www.newartisans.com/software.html
01:06:17 <lambdabot> Title: New Artisans LLC
01:06:22 <DRMacIver> ivant: The visual display aspect of pdfs is nasty.
01:06:34 <ivant> DRMacIver, that's true :-)
01:06:52 <DRMacIver> That's probably less of an issue here though
01:07:53 <ivant> mm_freak_, ugh, C++
01:08:19 <mm_freak_> ivant: yeah, but it works well
01:09:19 <ivant> mm_freak_, what if I need to improve it? I wish I never ever write in C++ any more
01:09:30 <ivant> :-)
01:09:47 <ivant> mm_freak_, but I'll try it, thanks
01:09:56 <mm_freak_> good point…  but i'm seeking for a simpler project to start with =)
01:10:04 <mm_freak_> probably a quadratic sieve or something
01:10:29 <dolio> Was there so much controversy when R5RS was in the works?
01:10:39 <ivant> mm_freak_, reinventing the square wheels (oh, no, quadratic sieves) :-)
01:10:56 <wli> dolio: Speaking of R6RS?
01:11:03 <dolio> wli: Right.
01:11:10 <mm_freak_> ivant: at least it would run slower than `qsieve' in C
01:11:23 <mm_freak_> it's the fastest implementation of the MPQS i know of
01:11:27 <wli> dolio: I think I might remember R5RS. About when was it?
01:11:34 <johnnowak> hopefully quick question: haskell provides a 'map' function in the prelude, data.intmap, data.intset, data.map, data.set, etc, all with very similar types. is there some way to have haskell infer the correct 'map' without doing qualified imports and essentiallly manually specifying for each use?
01:11:43 * sorear prefers n*π(n) sieves
01:11:48 <dolio> I don't actually know. It was before I knew what scheme was, I think. :)
01:11:54 <opqdonut> johnnowak: use fmap
01:11:55 <sorear> johnnowak: fmap
01:12:01 <opqdonut> ?instances Functor
01:12:02 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
01:12:09 <sorear> johnnowak: Once upon a time map was overloaded, but nooo...
01:12:19 <johnnowak> sorear: Why isn't map overloaded?
01:12:24 <mm_freak_> sorear: that is?
01:12:34 <opqdonut> ?instances-importing Data.Map Data.Set Functor
01:12:35 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Map k, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
01:12:39 <opqdonut> hrmm
01:12:40 <sorear> johnnowak: Ask Cale
01:12:41 <glguy> map became not overloaded in the great polymorphic scare of haskell 98
01:12:44 <wli> dolio: Well, I don't remember a big controvery wrt. Scheme between 1993 and now.
01:13:22 <johnnowak> hmmm.. thanks.
01:13:36 <wli> glguy: Brilliant. Downgrade relative to 1.4, I take it?
01:13:43 <sorear> wli: yep
01:13:44 <glguy> afaik
01:13:56 <sorear> @remember glguy map became not overloaded in the great polymorphic scare of haskell 98
01:13:56 <lambdabot> Done.
01:13:59 <wli> I actually started with 1.4 but never noticed.
01:15:32 <dolio> Lots of stuff.
01:15:37 <dolio> (++) used to be MonadPlus
01:15:53 <glguy> man... its like we are talking about the dark ages
01:15:57 <dolio> As was concat.
01:16:26 <glguy> when all the advances previous were lost to roving barbarian hordes
01:16:27 <wli> Why on earth did the downgrade ever happen?
01:16:37 <dolio> sequence_ was sequence, and sequence was accumulate.
01:16:38 <DRMacIver>  There really do seem to have been some dumb polymorphism related decisions in the standardisation for Haskell 98.
01:16:47 <glguy> so job-newb could learn it
01:16:49 <glguy> joe*
01:17:00 <DRMacIver> glguy: But isn't that the dumbest reason ever? :)
01:17:32 <DRMacIver> Of the many things which make Haskell difficult for joe-newb to learn, type classes and polymorphism are surely the least scary.
01:18:02 <dolio> DRMacIver: They're some of the primary culprits in making error messages bad.
01:18:10 <DRMacIver> Yes, I suppose that's true.
01:18:35 <glguy> DRMacIver: I only started using Haskell in '05
01:18:52 <glguy> so... I don't know if it was the *dumbest* I'm just going on what I heard :)
01:18:58 <DRMacIver> Heh.
01:20:16 <johnnowak> so is there no fundamental limitation of haskell that has resulted in the multitude of maps? it's simply (or largely) a historical matter?
01:20:39 <wli> johnnowak: Error reporting?
01:20:48 <enolan> >fmap id (+1) $ 1
01:21:09 <opqdonut> > fmap (*2) (+1) $ 1
01:21:17 <opqdonut> ?bot
01:21:17 <lambdabot> :)
01:21:18 <lambdabot>  4
01:21:23 <enolan> lambdabot: Wake up !
01:21:38 <ivant> isn't it night in Australia? :-)
01:21:41 <wli> glguy: Most of that seems to be in the std. libs. It doesn't seem terribly farfetched to brew up an alternative set.
01:21:56 <ivant> oh, evening maybe
01:22:15 <wli> glguy: Monad comprehensions being the huge exception.
01:22:23 <opqdonut> yep
01:22:29 <dolio> There's also a question of how far you want to take it. Not everyone agrees.
01:22:43 <dolio> Do you make (.) a general map?
01:22:45 <opqdonut> i think there might be a way to clean up typeclass and type inference -related errors too
01:22:49 <dolio> (+1) . [1..10] ?
01:22:50 <opqdonut> they're awfully verbose
01:23:09 <opqdonut> (+1) <$> [1..10]
01:23:10 * glguy determines that he first used Haskell Oct 15, 2005 by poking through the logs
01:23:13 <opqdonut> > (+1) <$> [1..10]
01:23:15 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
01:23:38 <wli> glguy: I sadly can't find out that way.
01:23:46 <wli> dolio: I would take it that far, and further. ;)
01:23:55 <glguy> wli: logs don't go back far enough, and you didn't use freenode back then
01:23:57 <opqdonut> wli: what's further in this case?
01:24:03 <glguy> wli: you were with monochrom? in efnet
01:24:09 <opqdonut> wli: function application is fmap?-)
01:24:18 <dolio> wli: Further? Anyhow, that can get confusing.
01:24:44 <opqdonut> imo even (.) = fmap might introduce unwanted errors
01:24:48 <wli> glguy: I was with monochrom on EfNet but I originally learned Haskell as one of a plethora of languages.
01:24:58 <dolio> foo . (bar .) . baz ...
01:24:59 <opqdonut> making every operation as general as possible is like having dynamic typing in a way
01:25:27 <glguy> wli: did you stick with any of the other languages you picked up around that time?
01:26:24 <wli> glguy: Yes. I stuck with Standard ML and ocaml until I got annoyed enough with various aspects of them (first dumping SML for ocaml) to move to Haskell despite the module system (or lack thereof).
01:26:50 <glguy> wli: could you elaborate about the lack of a module system? I haven't used ocaml
01:27:18 <opqdonut> parametric modules i think they're called
01:27:23 <wli> glguy: Oh dear. You can have nested modules and modules parametrized by other modules. Basically lambda calculus at the module level.
01:27:53 <augustss> yes, sometimes I miss proper modules a lot
01:27:57 <glguy> wli: do you have a simple example of something that this allows you to do that you can't do in Haskell as easily?
01:28:08 <opqdonut> they offer kind of like the same functionality as templates in c++
01:28:09 <opqdonut> in a way
01:28:20 <wli> glguy: Mostly scope control and switching between implementations of data structures.
01:28:57 <wli> glguy: So I could use a dumb implementation of e.g. priority queues until some van Emde Boas queue was fully debugged etc.
01:28:57 <augustss> just the fact that you can separate the interface from the implementation.  and have multiple implementations of the same interface
01:29:22 <glguy> sort of like what type classes provide?
01:29:43 <glguy> though clearly not the same since so many people seem to be missing them :)
01:29:46 <wli> glguy: I dealt with nameclashes by only importing modules with clashing names in the scopes they were used, for instance.
01:29:58 <augustss> sometimes you can use that.  but you can't, e.g., have types in type classess
01:29:58 <glguy> ah, cool
01:30:19 <glguy> augustss: is that something that associated types would address?
01:30:33 <dolio> If the type families guys get their way, that won't be true anymore, no? :)
01:30:44 <augustss> glguy: yes, with associated types you can do a little more what modules do
01:31:00 <wli> glguy: Parametrizing modules on anything and everything possible is/was called the "fully functorial style" and I was big on that.
01:31:04 <opqdonut> type families?
01:31:06 <glguy> I was under the impression that associated types gave you a subset of the functionality fundeps gave you
01:31:17 <opqdonut> associated types?
01:31:41 <wli> glguy: (There's obviously a "within reason" qualifier there.)
01:31:44 <augustss> but modules in a sense allows you to do what you could do in haskell if you could name dictionaries and have multiple of the same type
01:32:02 <glguy> that sounds interesting
01:32:14 <glguy> Is that missing from Haskell because of some conflict?
01:32:25 <glguy> or because it was decided that Haskell would not have such a module system
01:32:51 <wli> I got the impression typeclasses vs. modules was tricky somehow but have no idea of the specifics.
01:33:22 <augustss> the ML module system is quite complicated.  and it would overlap a lot with the class system if added to Haskell
01:33:26 <vincenz> what is the complexity of having scoped type-classes?
01:33:36 <glguy> it would be pretty wild if a data type had two different instances of one class
01:33:37 <vincenz> so that you can have similarly named typeclasses in different modules
01:33:40 <vincenz> and then you can do
01:33:42 <glguy> depending on which scope it was used in
01:33:49 <vincenz> instance QualifiedModuleName.TypeClassName AType where ...
01:33:55 <augustss> vincenz: i'd worry about coherence
01:34:04 <vincenz> augustss: just make sure that all typeclasses have absolute names
01:34:12 <vincenz> qualified by full module name
01:34:21 <vincenz> or is that not the point you intend?
01:34:51 <augustss> Hmmm, I'm not sure what you mean.  You mean type classes local in a scope?
01:34:55 <vincenz> yes
01:35:00 <vincenz> such that
01:35:03 <wli> vincenz: I've seen several proposals to resolve the issue but don't understand them. augustss, Philippa, and several others have some idea about it.
01:35:07 <vincenz> Foo.TypeClass != Bar.Typeclass
01:35:09 <augustss> Like 'let class C a where ...; x = 5; ... in ...'
01:35:15 <vincenz> oh no, just scoped by module
01:35:16 <glguy> bah, I have to go to work "early(ish)" tomorrow
01:35:20 <glguy> goodnight :)
01:35:22 <vincenz> then you do
01:35:27 <vincenz> import qualified Foo as F
01:35:30 <wli> rest easy, glguy
01:35:32 <vincenz> instance F.TypeClass MyType where ..
01:35:32 <augustss> But type classes are scoped by module already
01:35:36 <vincenz> oh
01:35:41 <vincenz> you can have overlapping names?
01:35:45 <augustss> yes
01:35:51 <vincenz> ok, never mind my question then, thanks :)
01:36:07 <augustss> but instances are weird, they scope over the whole program
01:36:10 <wli> vincenz: instances are the hard part.
01:36:39 <vincenz> augustss: that is fine,a s long as you can say whch scoped typeclass they instantiate
01:36:50 <augustss> and with local instances I'd worry about coherence, but it might work out somehow
01:36:55 <vincenz> Another proposal is scoped type-shortcuts for GADT
01:37:02 <vincenz> data Exp e where
01:37:05 <vincenz>   type Exp' = Exp e
01:37:14 <vincenz>   BinOp :: Op -> Exp' -> Exp' -> Exp'
01:37:23 <vincenz> (really handy when your GADT has a lot of type-parameters)
01:37:39 <doserj> augustss: what do you mean with coherence?
01:37:41 <augustss> yes
01:38:06 <vincenz> I do not think this should be so difficult, it's just creating aliases.
01:38:18 <augustss> doserj: if there are two, say, 'Eq Int' instances, how do you know what you'll get?
01:39:25 <doserj> would it be possible to put the instance into the type? i.e., there is only one in scope at every time. Or does this lose to much flexibility?
01:39:31 <augustss> vincenz: scoped shortcuts isn't a bad idea.  but it's messy to have a special case.  In Cayenne type synonyms were just like normal definitions, and of course you could make them wereever you liked
01:39:40 <wli> We have some of that already no?
01:40:00 <wli> Overlapping instances and all.
01:40:34 <vincenz> augustss: I will have to take a look at cayenne then.  Indeed, they create a special case.
01:40:39 <augustss> doserj: but you can imagine situations with partial application where some version of 'Eq Int' will be bound in one scope and another instance in another scope
01:40:55 <vincenz> A final proposal, though hareder to implement cause you have to make sure types don't escape is scoped data-declarations.  That'd be great for doing lambdabot-style stuff
01:41:02 <vincenz> (And the use is less hmm relevant)
01:41:32 <doserj> augustss: ideally, this wouldn't typecheck then :)
01:41:53 <augustss> vincenz: scoped data was a mess in ML, so they removed it.  works nicely in Cayenne though
01:42:02 <wli> vincenz: I think everything needs to be scoped for higher-order modules, but instances aren't scoped.
01:42:08 <augustss> and no restriction on not escaping
01:42:12 <vincenz> augustss: definitely another reason to look at Cayenne :) Thank you for the tip.
01:43:02 <augustss> wli: instances are really a bit too much magic for me
01:43:43 <augustss> perhaps the new stuff from Chakravarty,Dreier&Harper will be closer to the right thing
01:43:48 <wli> augustss: I'm willing to listen, but I am at something of a lower level of understanding with respect to all this.
01:44:03 <doserj> augustss: I mean, if you have something like Eq a => a -> a -> a, you require that both arguments have the *same* Eq instance
01:44:23 <wli> augustss: I saw their paper on getting higher-order modules to work with typeclasses but didn't understand much. Philippa pointed me at it.
01:44:42 <augustss> doserj: I don't mean that it will be type incorrect, just surprising results, perhaps
01:45:05 <augustss> wli: Derek has improved some of it.  I don't think that's on paper yet
01:48:45 <wli> So much to learn, so little time.
01:53:01 <augustss> wli: i know
01:53:47 <wli> This is all rather far removed from my primary field of study.
01:54:04 <wli> If it can be called that.
01:54:59 <takamura> hi
02:02:20 <Winterstream> I need a bit of help from anyone who has linked to foreign code with GHC. I'm using Cabal to compile my C file.
02:04:24 <Lemmih> Winterstream: Yes?
02:06:12 <Winterstream> Lemmih: I pasted the Cabal file, the Haskell file and the compiler output at http://hpaste.org/2139#a2. Basically, although it's compiling the C file, it doesn't seem to be able to find my C function when linking
02:07:40 <Lemmih> Winterstream: You have both a library and a program in that cabal file.
02:27:29 <ADEpt> @src scanl
02:27:30 <lambdabot> scanl f q ls = q : case ls of
02:27:30 <lambdabot>     []   -> []
02:27:30 <lambdabot>     x:xs -> scanl f (f q x) xs
02:28:04 <opqdonut> :t scnal
02:28:06 <lambdabot> Not in scope: `scnal'
02:28:06 <opqdonut> :t scanl
02:28:08 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
02:34:33 <mm_freak_> old version: "black <- mapRGB pf 0 0 0; fillRect sf Nothing black"
02:34:45 <mm_freak_> new version: "liftM (fillRect sf Nothing) (mapRGB pf 0 0 0)"
02:34:51 <mm_freak_> why does the new version not work?
02:34:57 <mm_freak_> the old version works well
02:35:50 <Lemmih> mm_freak_: fillRect sf Nothing =<< mapRGC pf 0 0 0
02:35:50 <mm_freak_> not a syntax issue…  it compiles well, but it does nothing
02:36:27 <mm_freak_> lemmih: ok, but _why_ doesn't my version work?
02:36:31 <Lemmih> mm_freak_: or: do x <- liftM (fillRect sf Nothing) (mapRGB pf 0 0 0); x
02:36:41 <Lemmih> mm_freak_: You're creating an (IO (IO ()))
02:36:48 <mm_freak_> ah ok
02:36:52 <mm_freak_> thank you
02:37:08 <enolan> @t liftM
02:37:09 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
02:37:19 <mm_freak_> :t liftM
02:37:22 <enolan> @type liftM
02:37:25 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:37:26 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:37:43 <enolan> lambdabot: quit repeating yerself!
02:39:19 <mm_freak_> ah…  liftM isn't even what i've been looking for
02:41:01 <mm_freak_> would it work when calling fillRect via unsafePerformIO?  i know it's stupid and i shouldn't do it…  just asking for clarification
02:41:25 <jbauman> only one way to find out...
02:42:49 <mm_freak_> it doesn't
02:44:48 <Cale> mm_freak_: usually if you have an IO (IO ()), you want to join it.
02:45:44 <Lemmih> But you don't usually want IO (IO ()).
02:45:45 <jbauman> :t join . liftM
02:45:51 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a1)
02:45:51 <lambdabot>     Probable cause: `liftM' is applied to too many arguments
02:45:56 <jbauman> :t join liftM
02:45:58 <lambdabot> forall a1. (a1 -> a1) -> a1 -> a1
02:46:09 <mm_freak_> yeah, that works, too
02:46:11 <mm_freak_> thanks, cale
02:46:13 <haskill> i: can has monand
02:46:22 <mm_freak_> join $ liftM (fillRect sf Nothing) (mapRGB pf 0 0 0)
02:46:44 <Cale> It is monadurday!
02:46:53 <jbauman> =<< is probably the better solution
02:47:00 <mm_freak_> jbauman: yes, it is
02:47:15 <mm_freak_> but understanding haskell means doing it the complicated way =)
02:47:30 <mm_freak_> is there any predefined (join . liftM) ?
02:47:34 <tuxplorer> are there libraries in haskell for mp3, ogg, wma, decoding and sampling?
02:47:49 <Cale> mapRGB pf 0 0 0 >>= fillRect sf Nothing
02:48:10 <jbauman> :t (>>=)
02:48:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:48:18 <Saizan> ?type join . liftM
02:48:19 <Cale> :t join . liftM
02:48:20 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a1)
02:48:20 <lambdabot>     Probable cause: `liftM' is applied to too many arguments
02:48:22 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a1)
02:48:22 <lambdabot>     Probable cause: `liftM' is applied to too many arguments
02:48:26 <dolio> @type (join .) . liftM
02:48:26 <Cale> heh :)
02:48:28 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
02:48:29 <jbauman> yeah, that doesn't seem to work
02:48:31 <Cale> yeah :)
02:48:35 <mm_freak_> uhm yeah
02:48:48 <Cale> It's just =<<
02:48:48 <xerox> kleisli composition
02:49:02 <Cale> nope, that's different :)
02:49:03 <mm_freak_> @pl \x y -> join $ liftM x y
02:49:03 <lambdabot> (=<<)
02:49:04 <xerox> ah, yes indeed
02:49:08 <mm_freak_> lol
02:54:31 <doserj> tuxplorer: there is a binding for SDL-mixer
02:55:42 <hpaste>  osfameron pasted "inefficient way of doing grid transposition" at http://hpaste.org/2222
02:56:06 <osfameron> that seems to work but it seems pretty dumb - how would I be best recommended to do that?
02:56:42 <Cale> osfameron: transpose
02:56:50 <Cale> > transpose [[1,2,3],[4,5,6]]
02:56:55 <lambdabot>  [[1,4],[2,5],[3,6]]
02:57:14 <osfameron> ah!
02:57:19 <osfameron> @src transpose
02:57:19 <lambdabot> transpose []             = []
02:57:19 <lambdabot> transpose ([]   : xss)   = transpose xss
02:57:19 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
02:57:33 <tuxplorer> doserj: Thanks..
02:57:44 <Cale> It's not too different from your version but handles the corner cases a little better perhaps
02:57:51 <osfameron> @where transpose
02:57:51 <lambdabot> I know nothing about transpose.
02:57:56 <Cale> Data.List
02:58:01 <osfameron> ok, ta
02:58:36 <osfameron> it also pattern the (h:t) whic is cuter ;-)
02:59:16 <Cale> It makes sure that you don't end up applying head to an empty list.
02:59:44 <opqdonut> yep
02:59:51 <opqdonut> pattern matching <3
03:00:16 <xahlee> hi Cale!
03:00:20 <Cale> hello
03:01:05 <osfameron> Cale: yeah, in my case I'm applying it to a rectangular grid, but good to know that it handles those cases
03:18:58 <hpaste>  tuxplorer pasted " When I try to build SDL, I get the following error. I use ubuntu feisty fawn.. How to compile it su" at http://hpaste.org/2224
03:27:35 <dcoutts> tuxplorer: you need to install the sdl development libraries
03:28:08 <dcoutts> ie including header files, probably called sdl-dev or something like that
03:30:38 <dcoutts> tuxplorer: on my system the package is libsdl1.2-dev, you might have a later version available for feisty fawn
03:31:13 <tuxplorer> dcoutts: Thanks.. Got it
03:33:39 <tuxplorer> dcoutts: even after installing sdl and sdl-mixer libraries, it still complains the same :(
03:35:04 <hpaste>  osfameron pasted "diagonal transposition" at http://hpaste.org/2225
03:35:18 <osfameron> is that approach vaguely sensible ?
03:35:56 <osfameron> given that transpose handles those cases, it seemed sensible to reuse it to get the diagonals
03:37:12 <dcoutts> tuxplorer: you need the -dev packages that include the development files
03:37:35 <dcoutts> tuxplorer: debian and ubuntu split many libaries into the runtime and development parts
03:38:07 <tuxplorer> dcoutts: yes. I installed the dev packages only..
03:38:52 <osfameron> @pl diag xs = map unjust $ transpose xs
03:38:52 <lambdabot> diag = map unjust . transpose
03:38:56 <tuxplorer> $ dpkg -l | grep sdl | grep dev ii  libsdl-image1.2-dev                        1.2.5-2                                development files for SDL 1.2 image loading libray ii  libsdl-mixer1.2-dev                        1.2.6-1.1build1                        development files for SDL1.2 mixer library ii  libsdl1.2-dev                              1.2.11-7ubuntu1                        Simple DirectMedia Layer development files
03:39:57 <dcoutts> tuxplorer: hmm, then perhaps you need to change the SDL.cabal file to set the right include directory so it can find SDL.h on your system
03:40:10 <dcoutts> tuxplorer: it might be /usr/include/sdl or something
03:40:29 <eivuokko> dcoutts, wouldn't using .buildinfo be better than modifying .cabal?
03:40:47 <tuxplorer>  locate sdl.h returns /usr/share/doc/diveintopython/html/soap_web_services/wsdl.html only.. :( No proper sdl.h is there..
03:40:57 <dcoutts> eivuokko: perhaps yes
03:41:20 <dcoutts> tuxplorer: locate will not files you only just installed, the locate db only gets updated occasionally
03:41:27 <eivuokko> dcoutts, I wonder why there isn't foo-config -> buildinfo tool, or is there?  (for unixes, not so useful in Windows -.-)
03:41:46 <dcoutts> eivuokko: I was thinking of adding support for pkg-config to cabal
03:42:08 <tuxplorer> dcoutts: I did a updatedb..
03:42:40 <dcoutts> tuxplorer: no /usr/include/SDL/SDL.h ?
03:42:48 <dcoutts> locate is case sensitive
03:43:10 <tuxplorer> dcoutts: ah! ok.. will do a locate -I and see
03:43:34 <tuxplorer> dcoutts: yes. its there
03:43:36 <tuxplorer> /usr/include/SDL/SDL.h
03:44:18 <dcoutts> Lemmih: can we make this situation any better? I had to hack the .cabal files for the gentoo haskell sdl packages too
03:46:26 <tuxplorer> dcoutts: Thanks.. It compiled successfully after modifying the cabal file
03:47:12 <tuxplorer> dcoutts : Now I get an error like
03:47:13 <tuxplorer> ghc-pkg: /usr/local/lib/ghc-6.4.1/include doesn't exist or isn't a directory (use --force to override)
03:47:24 <tuxplorer> when trying to install
03:47:51 <hpaste>  tuxplorer pasted "(no title)" at http://hpaste.org/2226
03:48:22 <tuxplorer> should I use --force? Is it safe?
03:48:31 <eivuokko> For this error, it is safe.
03:48:36 <eivuokko> But probably something is really wrong.
03:48:45 <tuxplorer> I actually use ghc 6.6.. I don't use 6.4
03:49:03 <dcoutts> that's pretty odd them
03:49:03 <eivuokko> On setup configure, what ghc did it say it uses?
03:50:03 <tuxplorer> it should be /usr/lib/ghc-6.6/include/   how do I set that?
03:50:22 <tuxplorer> configure: Compiler version: 6.6
03:51:49 <Saizan> have you installed other cabal packages successfully before this one?
03:52:31 <tuxplorer> Saizan: yes. I did install a few such as base-any etc to get HAppS running
03:53:01 <Saizan> base?
03:54:38 <tuxplorer> Saizan: sorry.. Binary
03:56:17 <osfameron> oh bejaysus:  diagonalsQuarter = transpose.zipWith drop [0..]
03:56:20 <Saizan> ah, ok, however i'd try passing -w ghc-6.6 to configure and then reinstall, just to try
03:56:23 <osfameron> @unpl diagonalsQuarter = transpose.zipWith drop [0..]
03:56:23 <lambdabot> diagonalsQuarter c = transpose (zipWith drop [0 ..] c)
03:57:16 <tuxplorer> Saizan: will try now
03:58:11 <osfameron> oh I see... that's cute
04:00:16 <tuxplorer> Saizan: It still tries to find that 6.4.1 dir only..
04:06:40 <hpaste>  kowey pasted "whitespace + pragmas (ghc)" at http://hpaste.org/2227
04:07:12 <tuxplorer> would it work if I paste the stuff inside the dist/build directory into the inclue folder of my ghc-6.6?
04:08:53 <ndm> @seen dcoutts
04:08:53 <lambdabot> dcoutts is in #ghc, #gentoo-haskell and #haskell. I last heard dcoutts speak 4m 38s ago.
04:09:07 <ndm> @seen evil dcoutts who keeps wanting more chaotic and conflicting features
04:09:07 <lambdabot> I haven't seen evil.
04:09:15 <dcoutts> hah hah
04:09:18 <dcoutts> hia ndm
04:09:21 <ndm> hi dcoutts
04:09:22 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
04:09:38 <ndm> @seen njd
04:09:38 <lambdabot> I saw njd leaving #haskell 16h 3m 14s ago, and .
04:10:05 <ndm> @tell njd no obvious hints, ideally send an email to ndmitchell -AT- gmail with whatever steps you took and the exact error messages
04:10:05 <lambdabot> Consider it noted.
04:10:11 <dcoutts> tuxplorer: you didn't accidentally uncomment the line in SDL.cabal did you that says: -- Include-Dirs: /usr/local/lib/ghc-6.4.1/include, /sw/include/SDL
04:10:28 <ndm> dcoutts, is this the paper you and SPJ mentioned: Lightweight Fusion by Fixed Point Promotion
04:11:03 <dcoutts> ndm: yes
04:11:06 <tuxplorer> dcoutts: oops! I uncommented it
04:11:41 <kowey> has anybody noticed that {-# INCLUDE ... #-} inside #ifdef gets ignored? i'm so far working around it by using -#include on the command line, but eww...
04:12:56 <xahlee> is graham hutton's book no longer free?
04:13:08 <tuxplorer> dcoutts: Now installed succesfully.. I had uncommented it to add the path of SDL.h.. Now  commented it and added the path to SDL.h in a separate line
04:13:24 <dcoutts> tuxplorer: good good
04:13:24 <tuxplorer> dcoutts: Saizan: Thanks a lot for the help :)
04:13:38 <yaxu> xahlee: it never was, a few chapters were available but not any more
04:14:20 <xahlee> yaxu: ah ok
04:14:51 <tuxplorer> But after installing, when I so a :m Graphics in ghci, it says module not found!!
04:14:54 <yaxu> imho it's worth the money if you have it
04:15:57 <osfameron> oh!  cute!  "map (take 4) $ tails xs"
04:16:27 <yaxu> > map (take 4) $ tails "hello world"
04:16:29 <lambdabot>  ["hell","ello","llo ","lo w","o wo"," wor","worl","orld","rld","ld","d",""]
04:17:58 <tuxplorer> import Graphics.UI.SDL.Mixer.Music results in a module not found error.. Does graphics module reside in some other module?
04:20:18 <osfameron> gah! points-free style for teh obfu
04:21:01 <b_jonas> ok, I'll get evil then
04:21:18 <b_jonas> ] <@:(4&{.)\.'hello world'
04:21:23 <b_jonas> evalj] <@:(4&{.)\.'hello world'
04:21:24 <evalj> b_jonas: +----+----+----+----+----+----+----+----+----+----+----+
04:21:24 <evalj> b_jonas: |hell|ello|llo |lo w|o wo| wor|worl|orld|rld |ld  |d   |
04:21:24 <evalj> b_jonas: +----+----+----+----+----+----+----+----+----+----+----+
04:21:31 <opqdonut> :D
04:21:33 <DRMacIver> osfameron: Point-free style is often much more readable. :)
04:21:38 <opqdonut> should probably learn j
04:21:42 <b_jonas> evalj] 4<\'hello world' NB. or just the exactly 4-long ones?
04:21:43 <evalj> b_jonas: +----+----+----+----+----+----+----+----+
04:21:43 <evalj> b_jonas: |hell|ello|llo |lo w|o wo| wor|worl|orld|
04:21:43 <evalj> b_jonas: +----+----+----+----+----+----+----+----+
04:22:25 <b_jonas> opqdonut: well, if you like point-free style and obfus you can
04:22:58 <osfameron> DRMacIver: it often looks very pretty... but it's not obvious what parameters functions take and when they get applied
04:23:09 <osfameron> evalj has very pretty output
04:23:20 <earthy> I'd call it verbose, rather :)
04:23:21 <b_jonas> osfameron: yeah, it results in write-only code often
04:23:53 <b_jonas> but wait, what I typed isn't equivalent to yours because take works differently in j -- it gives always 4 long strings even at the end
04:23:58 <b_jonas> I'll have to fix that somehow...
04:24:42 <osfameron> well, for the task I'm looking at that's fine anyway
04:26:02 <b_jonas> evalj] <@:({.~4:<.#)\.'hello world'
04:26:03 <evalj> b_jonas: +----+----+----+----+----+----+----+----+---+--+-+
04:26:03 <evalj> b_jonas: |hell|ello|llo |lo w|o wo| wor|worl|orld|rld|ld|d|
04:26:03 <evalj> b_jonas: +----+----+----+----+----+----+----+----+---+--+-+
04:26:12 <b_jonas> still no good, missing the empty string at the end
04:26:18 <DRMacIver> osfameron: Hm. Depends. For example a lot of very nice point-free code is just a sequence of piping things via .
04:26:21 <b_jonas> but we could add that one explicitly
04:26:29 <DRMacIver> osfameron: And I find that looks much more readable than most other ways of writing it.
04:26:33 <byorgey> we have a J evaluator now !?
04:27:05 <earthy> apparently. :)
04:27:06 <byorgey> evalj] +/ i.100
04:27:07 <evalj> byorgey: 4950
04:27:10 <byorgey> woah
04:27:12 <b_jonas> byorgey: we've had them for months but it doesn't normally run, I made it join explicitly
04:27:29 <byorgey> b_jonas: ah, ok
04:27:36 <b_jonas> there are two actually, a buubot plugin called jeval which sometimes works sometimes doesn't
04:27:36 <DRMacIver> osfameron: Granted it's also very possible to write incredibly elegant pointfree code which god^H oleg himself couldn't read. :)
04:27:53 <osfameron> DRMacIver: well, I suppose it gets better with experience.  I find function composition hard to read too
04:28:17 <b_jonas> and instances of my bot which isn't continuously running because noone has bothered to host such an insecure thing so I just casually start it when I need it
04:28:21 <DRMacIver> 'experience' is not an adjective I would use to describe me and haskell. :)
04:28:23 <b_jonas> the source of both is available
04:29:51 <wli> I think I may be too ill to think straight enough to write a CPO-STV voting web-app.
04:29:51 <DRMacIver> osfameron: I think it helps to think of things in terms of data flow.
04:29:56 <desp> huh
04:30:02 <desp> did you guys see the OpenGenera leak? :)
04:30:39 <opqdonut> yup
04:30:41 <dblhelix> DRMacIver: well, it's a noun, not an adjective, so... ;-)
04:30:54 <DRMacIver> Heh, true.
04:30:58 <wli> They had to leak it?
04:31:13 <DRMacIver> Braino
04:31:17 <wli> Must not have been very open.
04:31:28 <desp> wli :)
04:35:55 <osfameron> DRMacIver: well, I learnt FP from Perl, so I think of data flow from right to left in a pipeline of map, grep, and the odd reduce...
04:36:41 <osfameron> DRMacIver: function composition and points free confuse me because they seem to make data flow temporarily in different directions, as if eddied by invisible parameters
04:37:41 <Saizan> but it's right to left with (.) too
04:37:57 <xpika> is it possible to download the old lambdabot?
04:38:00 <crazy_coder> hello everyone
04:38:48 <xpika> crazy_coder: hi crazy
04:39:03 <DRMacIver> osfameron: You could use <<< instead? :)
04:39:06 <osfameron> Saizan: in that case I'm confused about someting else :-)
04:39:51 <osfameron> DRMacIver: I believe that has something to do with arrows, and I think I need to write some more haskell and learn monads before I tackle those
04:40:33 <Saizan> for the (->) arrow (<<<) = (.)
04:40:52 <b_jonas> lol -- that line looks fun
04:40:56 <moonlite_> say that you know what a List in programming is. Could you by just seeing the name colist understand what a colist is? Ie, does the prefix "co" have a single meaning? What does this "co" mean then?
04:41:39 <b_jonas> ouch. I hate the "co" prefix
04:41:48 <Saizan> moonlite_: it probably refers to the distinction between data and codata
04:42:25 <moonlite_> Saizan: ok. But what is codata then? :)
04:42:36 <wli> infinite data
04:42:44 <moonlite_> ok
04:42:50 <DRMacIver> Saizan: Oh, have I got it the wrong way round? Maybe I meant >>>
04:42:55 <Saizan> (in haskell we don't have this distinction)
04:42:59 <moonlite_> could i deduce that from knowing what data is and what "co" is?
04:43:04 <DRMacIver> osfameron: You don't need to understand arrows to use the combinators for functions. :)
04:43:17 <DRMacIver> I think someone might have written an article about that. ;)
04:43:56 <Saizan> moonlite_: "infinite data" is a bit reductive, however no, you couldn't
04:44:03 <moonlite_> ok
04:44:23 <osfameron> DRMacIver: well, if you think it would be useful... but it would be something else to learn, and my synapses are already exploding
04:44:37 <osfameron> @let triangle = zipWith (+) [1..] (0:triangle) in take 10 triangle
04:44:37 <lambdabot>  Parse error
04:44:59 <xerox> osfameron: while monadic bind always takes input by means of a function (see the second argument of >>=), arrows are more general, in that they are parametrized on the input as well as the output (see the type of >>>).
04:44:59 <Saizan> moonlite_: http://sigfpe.blogspot.com/2007/07/data-and-codata.html
04:45:01 <lambdabot> Title: A Neighborhood of Infinity: Data and Codata
04:45:14 <moonlite_> Saizan: thx for the link
04:45:37 <osfameron> xerox: thanks... but I don't understand monads so the comparison is lost on me
04:46:07 <xerox> osfameron: btw larsen was searching you on #haskell.it the other day :)
04:46:38 <mux> > (+1) <$> (2,3)
04:46:40 <lambdabot>  (2,4)
04:46:44 <osfameron> xerox: heh, found him :-)  I forgot to set irssi to rejoin it
04:46:47 <mux> bah.
04:46:51 <mux> I guess <$> is just fmap?
04:46:59 <mux> for Functors at least
04:46:59 <Saizan> yup
04:47:03 <xerox> mux: yup, and shorter :)
04:47:12 <mux> okay
04:47:22 <dolio> @src (<$>)
04:47:23 <lambdabot> f <$> a = fmap f a
04:47:33 <Saizan> every applicative functor is a functor
04:47:36 <Saizan> :)
04:47:46 <mux> I was excited because I thought this would have given me a way to elegantly map a function to all the components of an homogeneous tuple
04:47:54 <DRMacIver> osfameron: It wasn't a totally serious suggestion.
04:48:09 <b_jonas> I should learn haskell once so that I understand all these things
04:48:59 <dolio> newtype HTuple2 a = HTuple2 { getHTuple2 :: (a,a) } ...
04:49:38 <EvilTerran> newtype Pair a = Pair (a,a); instance Functor Pair where...
04:50:03 <EvilTerran> fmap = join (&&&), i think...
04:50:07 <desegnis> @type join (***)
04:50:09 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
04:50:13 <mux> yes, I already do that
04:50:15 <EvilTerran> @unpl join (&&&)
04:50:16 <lambdabot> ((&&&) >>= \ a -> a)
04:50:16 <mux> mapPair = join (***)
04:50:18 <mux> or something
04:50:24 <MyCatVerbs> Guten tag, #haskell.
04:50:27 <EvilTerran> @src (&&&)
04:50:27 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
04:50:40 <mux> I'm not so thrilled about creating my own newtype just for the sake of being able to define another fmap for pairs
04:50:40 <EvilTerran> @src (***)
04:50:40 <lambdabot> f *** g = first f >>> second g
04:50:57 <ADEpt> @src delete
04:50:57 <lambdabot> delete = deleteBy (==)
04:51:00 <hpaste>  tuxplorer pasted "Unable to load music files" at http://hpaste.org/2228
04:51:04 <ADEpt> @src deleteBy
04:51:04 <lambdabot> Source not found. Maybe if you used more than just two fingers...
04:51:28 <osfameron> dammit, "Which is the first triangle number to have over five-hundred divisors?" requires a little more thinking
04:51:38 <osfameron> as take 1 $ filter (\x -> (length $ factorize x) >= 500 ) triangle where triangle = zipWith (+) [1..] (0:triangle)
04:51:50 <osfameron> runs for way over a minute and makes my CPU toasty
04:52:11 <wli> osfameron: n and n+1 are relatively prime. d(m*n) = d(m)*d(n) when m `gcd` n == 1
04:52:12 <thoughtpolice> mmm... toast.
04:52:59 <osfameron> wli: what does "relatively prime" mean?
04:53:00 <wli> osfameron: Also d(p^k) = k + 1 when p is prime.
04:53:23 <wli> osfameron: m and n are relatively prime when m `gcd` n == 1
04:54:04 <osfameron> wli: ok - but I don't see how that helps me see how many divisors it has
04:54:31 <b_jonas> are you sure 'length $ factorize x' gives the number of divisors?
04:55:06 <wli> osfameron: d((n*(n+1)) `div` 2) | even n = d (n `div` 2) * d (n + 1) | otherwise = d n * d ((n + 1) `div` 2)
04:55:30 <wli> b_jonas: It does not give the number of divisors.
04:56:25 <osfameron> b_jonas: hmmm, maybe it doesn't
04:56:56 <tuxplorer> Lemmih: can you please help me out here? When I try to load a music file with tryLoadMUS, I get the error as in http://hpaste.org/2228
04:57:09 <popcount> Why is replacing do let a = b; something; f a not equal to do something; f b?
04:57:24 <popcount> The derived types are different!
04:57:59 <popcount> Is this an instance of monomorphic pattern bindings?
05:00:08 <popcount> According to http://hackage.haskell.org/trac/haskell-prime/wiki/MonomorphicPatternBindings it shouldn't be one.
05:00:11 <lambdabot> Title: MonomorphicPatternBindings - Haskell Prime - Trac, http://tinyurl.com/2nly6h
05:00:36 <osfameron> wli, b_jonas: ok, sorry, my factorize function gives the *prime* factors, not all divisors
05:00:40 <EvilTerran> it's got nothing to do with monomorphism. do{} and let{}in{} serve very different purposes.
05:01:31 <popcount> EvilTerran, ok, then what is it?
05:02:03 <popcount> EvilTerran, it destroys the property that replacing equals with equals is the same.
05:02:06 <b_jonas> wli is quite right: the relative primeness should help because the answer isn't very small
05:02:20 <aa_> hi everyone, anywhere I can find progrss of SoC projects in haskell?
05:02:51 <b_jonas> so because n and n+1 are relative primes, d(n*(n+1)) = d(n)*d(n+1) where d is the number of (positive) divisors
05:03:02 <EvilTerran> popcount, they're not equal.
05:03:19 <popcount> EvilTerran, because?
05:03:25 <EvilTerran> it's a laziness thing, i think.
05:03:34 <EvilTerran> @undo  do let a = b; something; f a
05:03:35 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 24}) "Parse error"
05:03:42 <osfameron> b_jonas: oh "d" is the number of divisors ?
05:03:53 <aa_> I am specifically interested in GuiHaskell, because the application mentions that they will investigate a piece of software I wrote, and I was wondering what the findings were
05:04:07 <EvilTerran> ah, sorry, i slightly misunderstood your original problem.
05:04:10 <EvilTerran> let me think...
05:04:32 <b_jonas> apparently the answer is near 6000^2 -- let me check that
05:04:38 <EvilTerran> ?type do let a = b; something; f a
05:04:44 <lambdabot> parse error on input `;'
05:05:08 <aa_> are Asuma Takikawa, or Neil David Mitchell here?
05:05:12 <osfameron> b_jonas: or rather, it's a function to calculate the number of divisors?
05:05:33 <wli> osfameron: let { primes = 2 : 3 : [p | p <- [5,7..], all (\q -> p `mod` q /= 0) (takeWhile (\q -> q^2 <= p) primes)] ; elim p n = let (q, r) = n `divMod` p in if r /= 0 then (n, 0) else let (n', k) = elim p q in (n', k + 1) ; factor' ps n = let { (_, p:ps') = break (\q -> n `mod` q == 0) ps ; (n', k) = elim p n } in if n == 1 then [] else (p, k) : factor' ps' n' ; factor = factor' primes ; d n = product [k + 1 | (_, k) <- factor n] } in [d n | n <- [1..10]]
05:05:38 <mux> aa_: neil mitchell is ndm
05:05:44 <mux> don't know for asuma takikawa
05:05:48 <b_jonas> osfameron: yes
05:06:01 <b_jonas> d(n) is the number of positive divisors of n
05:06:08 <b_jonas> here's the code:
05:06:23 <aa_> mux: cool thanks
05:06:33 <osfameron> ok, apparently there's a numDivisors in ArithmeticFunctions.hs  ('this function is usually called "d" in the literature')
05:06:37 <b_jonas> evalj:: numdivisors =: ([: */@:>: _&q:)"0 NB. number of divisors
05:06:38 <evalj> b_jonas: |ok
05:06:42 <aa_> ndm: pinda? do you mind if I ask you some questions about GuiHaskell SoC project?
05:06:52 <aa_> s/pinda/ping/
05:07:00 <EvilTerran> popcount, what types do the two expressions have?
05:07:10 <xerox> aa_: are you his mentoree?
05:07:20 <b_jonas> evalj:: >: 1 i.~ 500< 2*/\ numdivisors >:i. 10000 NB. using the remark above, it's enough to take the product of d(n) of adjacent n-s
05:07:21 <evalj> b_jonas: 5984
05:07:25 <b_jonas> that shows that
05:07:38 <b_jonas> evalj:: numdivisors 5984*5985
05:07:38 <evalj> b_jonas: 576
05:07:41 <aa_> xerox: no, I am just interested in the project. Week 5 said they would investigate an application I wrote
05:07:48 <b_jonas> is the first one over 500
05:07:54 <osfameron> b_jonas: sorry, I don't speak J
05:08:01 <b_jonas> unless you count 0 which is a triangle number and have lots of divisors
05:08:05 <popcount> EvilTerran, I will make an example that you can execute.
05:08:06 <aa_> offering my help if they have not already done it
05:08:24 <b_jonas> osfameron: well, I mostly showed it so we can check results but I could explain it if you want that
05:08:37 <xerox> aa_: ah I see. I talked with ndm just yesterday, it seems that they implemented a long list of things, but I don't know exactly which, I'm sure ndm will tell you as soon as he gets online :)
05:08:48 <b_jonas> wli: wow
05:08:52 <aa_> xerox: ok, thanks :)
05:09:08 <wli> let { dt n | even n = d (n `div` 2) * d (n + 1) | otherwise = d n * d ((n + 1) `div` 2) } in head [(n, (n * (n + 1)) `div` 2) | n <- [1..], dt n > 500]
05:09:14 <wli> b_jonas: What?
05:09:26 <b_jonas> that long statement for factoring you typed
05:10:35 <wli> b_jonas: It finds the first 10 with over 500 divisors in ca. 11.2s here.
05:11:08 <b_jonas> hmm. I'm quote sure it would be faster if you used this relative prime optimization
05:11:22 <wli> b_jonas: It already does.
05:11:49 <osfameron> b_jonas: I don't understand why you're looking at adjacent n-s
05:12:08 <wli> osfameron: (n * (n + 1)) `div` 2
05:12:12 <b_jonas> osfameron: because a triangle number is the product of two adjacent numbers
05:12:16 <b_jonas> that is, n*(n+1)
05:12:21 <osfameron> I haven't studied maths for 10 years and the last step that I understood was trying to brute force subsequent triangular numbers based on the stream that I vaguely remember from school...
05:12:51 <osfameron> ok
05:12:55 <b_jonas> evalj:: >:I. 500< 2*/\ numdivisors >:i. 50000 NB. look, this runs quite fast and it gives more than 10
05:12:57 <evalj> b_jonas: 5984 8855 9800 9855 10880 11024 11780 11934 12375 13299 14364 14399 15399 15840 16415 16575 17199 17424 17640 17765 18095 18360 18920 19095 19250 19304 19844 20124 20349 20384 20735 20999 21384 21504 21735 21824 21944 22400 22815 23000 23199 23408 23715 23919 24024 24255 24479 24794 24920 25024 25200 25479 25584 25599 25704 25839 25920 26144 26675 26999 27000 27104 27264 27335 2740...
05:13:25 <b_jonas> numdivisors uses the builtin (i.e. written in C) factoring verb though
05:14:02 <b_jonas> do you get the same results? because this could be wrong somewhere
05:14:15 <b_jonas> it gives the ns for which 500<:d(n*(n+1))
05:14:32 <b_jonas> for which 500<=d(n*(n+1)) I mean
05:14:53 <osfameron> `div` 2 _
05:20:08 <vincenz> whta's with the bot?
05:20:31 <b_jonas> > 1+1
05:20:36 <lambdabot>  2
05:20:42 <b_jonas> what?
05:20:44 <mauke> he's here to protect us from the terrible secret of space
05:20:47 <hpaste>  wli pasted "triangle numbers for osfameron" at http://hpaste.org/2229
05:20:48 <vincenz> 'evalj'
05:21:42 <b_jonas> vincenz: oh, it's just my J evaluator bot which I made join to show such things
05:21:48 <vincenz> okies :)
05:23:42 <psykotic> mauke: do not trust the pusher robot.
05:24:18 <b_jonas> it's not to be trusted, it's easy to cheat with it
05:24:24 <EvilTerran> But we are here to protect you!
05:24:34 <xahlee> when i tried to do ad1 = x + 1 it gives error. what was the problem?
05:24:38 <psykotic> Shoving is the answer.
05:24:52 <xahlee> “parser error on input =”
05:24:54 <psykotic> xahlee, at the ghci prompt?
05:25:14 <EvilTerran> let ad1 = x + 1
05:25:29 <doserj> let ad1 x = x + 1 -- :)
05:25:39 <EvilTerran> or that, indeed.
05:25:43 <EvilTerran> or let ad1 = (+1)
05:25:43 <psykotic> the -- :) is essential
05:26:06 <psykotic> you have to give a wink to GHC
05:26:08 <doserj> psykotic, of course
05:26:19 <psykotic> :wink :wink :nudge :nudge
05:26:45 <b_jonas> obviously. I can't program J either but evalj interprets the comments and the context on the channel right so it seems like
05:26:58 <b_jonas> and as no-one understands the J code anyway, it gives the right impression
05:27:13 <xahlee> thx. why do i need to say let though?
05:27:41 <doserj> you don't
05:28:06 <EvilTerran> because GHCi's prompt is like a do{...} block, and that's how those work. approximately.
05:29:01 <tonfa> if you have a list with an infinite number of increasing value, how do you get the sum of all the value less than a given number ?
05:29:11 <vincenz> tonfa: takeWhile
05:29:16 <tonfa> ok, thanks
05:29:36 <vincenz> that should be hint enough :)
05:29:48 <desegnis> xahlee, ghci compiles your module (loaded with :load) behind the scenes, but what you type in ghci are expressions, not module definitions. this can be a little annoying sometimes, but it's the best we have
05:29:55 <wli> osfameron: Does that help?
05:30:08 <xahlee> ic.
05:30:21 <tonfa> vincenz: yeah that's exaclty what I wanted
05:30:27 <MyCatVerbs> > (\y z-> takeWhile (\x-> x<y) z) 40 [1..]
05:30:27 <tonfa> ^t
05:30:35 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:30:44 <MyCatVerbs> > (\y z-> takeWhile (\x-> x<y) z) 15 [1..]
05:30:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14]
05:30:50 <MyCatVerbs> Ah, sehr gut.
05:30:58 <vincenz> @pl (\y z-> takeWhile (\x-> x<y) z)
05:30:59 <lambdabot> takeWhile . flip (<)
05:31:11 <MyCatVerbs> ...whaaaat.
05:31:33 <MyCatVerbs> Points-free programming hurts my head, like monads do, and then some.
05:31:56 <mauke> > (takeWhile . (>)) 15 [1 ..]
05:31:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14]
05:32:07 <psykotic> flip (<) is a funny way of saying > :)
05:32:09 <vincenz> mauke: the funny thing is, that fails with $
05:32:20 <mauke> > (takeWhile . (>)) 15 $ [1 ..]
05:32:22 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14]
05:32:29 <vincenz> I mean without ()
05:32:34 <shapr> Good morning #haskell!
05:32:38 <mauke> > takeWhile . (>) $ 15 $ [1 ..]
05:32:39 <lambdabot>   add an instance declaration for (Num ([t] -> b))
05:32:41 <vincenz> :D
05:32:51 <psykotic> @hoogle (a -> Bool) -> [a] -> Maybe a
05:32:52 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
05:32:53 <EvilTerran> hm. maybe @pl would benefit from some table of functions that're flip()s of each other or something.
05:32:59 <ivant> good morning, shapr
05:33:16 <vincenz> > flip id
05:33:17 <lambdabot>  Add a type signature
05:33:19 <vincenz> > flip id 1
05:33:20 <lambdabot>  Add a type signature
05:33:23 <vincenz> > flip id 1 2
05:33:24 <lambdabot>   add an instance declaration for (Num (b -> c))
05:33:44 <desegnis> > (takeWhile . (>) $ 15) $ [1 ..]
05:33:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14]
05:33:50 <shapr> privet ivant!
05:34:18 <psykotic> salve, shapr!
05:35:03 <shapr> psykotic: Ok, what's that one?
05:35:13 <b_jonas> mauke: but of course it fails, that tries to evaluate (takewhile . (>)) (15 [1 ..]) or something
05:35:23 <mauke> yes
05:35:27 <psykotic> shapr: just means hi.
05:35:45 <mauke> $ has the wrong associativity
05:35:51 <shapr> psykotic: Which language?
05:35:55 <psykotic> latin
05:36:07 <shapr> oh
05:36:08 <shapr> Cool!
05:36:13 <mauke> salvete
05:36:15 <earthy> 'salve... salve... salve regina...'
05:36:32 <vincenz> dove salve
05:36:35 <psykotic> mauke, that would be when addressing multiple people.
05:36:43 <psykotic> mauke, salve is the singular.
05:36:51 <mauke> yes, I'm saying hello to the channel
05:37:03 <psykotic> oh. :)
05:37:09 <psykotic> valete, i need some icecream.
05:37:13 <Japsu> @hoogle Handle -> ByteString -> IO ()
05:37:14 <lambdabot> No matches, try a more general search
05:37:24 <Japsu> @djinn Handle -> ByteString -> IO ()
05:37:24 <lambdabot> -- f cannot be realized.
05:37:27 <xerox> ...salve is Italian too :)
05:37:28 <dblhelix> chaire kai hygiaine
05:37:29 * ddarius has icecream.
05:37:32 <Japsu> Hmm
05:37:32 <ivant> Japsu: hPutStrLn in Data.ByteString
05:37:38 <Japsu> ivant: thanks
05:37:42 <Japsu> :)
05:37:52 <ivant> Japsu, just used it :-)
05:38:07 <vincenz> ciao xerox, come stai?
05:38:26 <xerox> bene grazie, ripassi l'italiano? (:
05:38:29 <shapr> co'o rodo
05:38:33 <osfameron> wli: I think so!  But I'm going to save and come back to it - I think I've reached brane-saturation right now
05:38:37 <vincenz> perche dovrei ripassarlo?
05:38:39 <shapr> dblhelix: What's that?
05:38:42 <ivant> coi do
05:38:44 * desegnis sentas sin perdita inter la lingvoj
05:38:48 <xerox> vincenz: oops :)
05:38:52 <Japsu> ivant: Hmm, what if I have a lazy bytestring?
05:38:58 <osfameron> wli: but one question as I've seen this in your and other implementation of primes: what is the (takeWhile (\q -> q^2 <= p)  clause for?
05:39:09 <b_jonas> lol -- all those languages
05:39:14 <xerox> osfameron: you just check for divisibility by primes less than the square root of n
05:39:17 <dblhelix> shapr: a transcription from ancient greek: be merry and healthy
05:39:22 <Japsu> ivant: namely, I want to send stuff given by Data.Binary.encode over the network
05:39:23 <ivant> Japsu, I have no idea, but I'd expect it to work just fine with it
05:39:26 <popcount> EvilTerran, http://hackage.haskell.org/trac/ghc/ticket/1613
05:39:27 <lambdabot> Title: #1613 (Derived types unequal with let binding) - GHC - Trac
05:39:31 <shapr> dblhelix: nifty
05:39:34 <Japsu> ivant: nope, the type checker doesn't like me
05:39:39 <Japsu>     Couldn't match expected type `ByteString'
05:39:40 <Japsu>            against inferred type `Data.ByteString.Lazy.ByteString'
05:39:54 <Japsu>     In the expression: (hPutStrLn undefined) . encode
05:40:12 <Japsu> Ah.
05:40:14 <Japsu> Stupid me.
05:40:17 <psykotic> xerox: no surprise. italian is just latin with the good grammar dropped :)
05:40:25 <Japsu> There must be another hPutStrLn in Data.ByteString.Lazy.
05:40:37 <psykotic> xerox: italian doesn't decline nouns and adjectives, right?
05:40:39 <earthy> χαιρε και υγαινε?
05:40:44 <xerox> psykotic: right
05:40:51 <Japsu> ...okay
05:40:53 <Japsu> there isn't
05:40:54 <ivant> Japsu, I see hPut in Data.BS.Lazy
05:40:58 <tuxplorer> When I try to load a music file with tryLoadMUS, I get the error as in http://hpaste.org/2228 Some SDL library linking error. Can someone help me figure out the reason and make it work properly
05:41:06 <ivant> Japsu, but no hPutStrLn
05:41:07 <psykotic> i think even during the time when classic italian was still in use, colloquial latin tended to drop inflections
05:41:21 <osfameron> wli, xerox: oh, I see, because it's not a series of wrapped filters, but you test for each prime
05:41:22 <Japsu> hmm
05:41:22 <earthy> or even χαιρε και 'υγαινε ?
05:41:59 <Japsu> hPut undefined . encode :: (Binary a) => a -> IO ()
05:42:01 <Japsu> ivant: thanks
05:42:03 <osfameron> yeah, probably in the Roman fora, street sellers were speaking a lot more like Italian dialect than high Latin...
05:42:03 <Japsu> that should work
05:42:26 <EvilTerran> popcount, i get them both to be :: do let a = b; something; f a
05:42:30 <EvilTerran> um.
05:42:34 <EvilTerran> :: (X l z b m, Show b, Show a, Monad m) => ((Int, Int, b) -> (Int, Int, b)) -> l a b -> m (l a b)
05:42:42 <hpaste>  wli annotated "triangle numbers for osfameron" with "cleaned up a bit" at http://hpaste.org/2229#a1
05:43:01 <popcount> EvilTerran, what compiler version?
05:43:10 <wli> osfameron: Is any of this helping
05:43:12 <shapr> So if you want to say hello in Haskell, is it "module Main where" ?
05:43:12 <ivant> shapr, do you know lojban? Is there some "gentle introduction to lojban for haskell programmers"?
05:43:21 <shapr> na go'i
05:43:30 <EvilTerran> 6.6.1
05:43:32 <psykotic> osfameron, yep. even though declension is a very neat approach, if you fix the word order it's not really needed. i'd say it's mainly great for poetry, where you can have unambiguous meaning with almost totally flexible word order.
05:43:41 <shapr> I can't say I really know lojban, but it is a lot easier to learn if you know Haskell.
05:43:43 <popcount> EvilTerran, it is reported against 6.7
05:44:00 <popcount> EvilTerran, but you can add 6.6.1 now, too, since that type is incorrect.
05:44:05 <MyCatVerbs> shapr: did anyone think to getting around to adding any cuss-words to lojban?
05:44:14 <MyCatVerbs> Or is it not yet actually a real, usable language.
05:44:15 <ivant> shapr, I'm trying to read the reference grammar, but it is kind of tough
05:44:20 <b_jonas> shapr: is it? why?
05:45:24 <osfameron> wli: yes definitely - it's instructive to read examples of haskell and see how your approach works
05:45:48 <osfameron> wli: I was a little overwhelmed earlier as I really hadn't thought about the maths involved and was just bruteforcing, and didn't see where you were coming from
05:45:51 <wli> osfameron: Any questions about how it works?
05:45:56 <EvilTerran> popcount, you're welcome to; i won't, as i'm insufficiently confident with the matter to be sure that i were reporting it correctly
05:46:17 <osfameron> wli: but I'm being called for cakes and coffee with my parents who I'm visiting, so I'm going to have to save and come back to it later...
05:46:49 <wli> I need to go grocery shopping anyway.
05:47:07 <osfameron> wli: actually, one quick question - is the "factor" function a prime factoring ?
05:47:25 <wli> osfameron: Yes. It finds the prime factors and their exponents.
05:47:53 <osfameron> wli: ok - so you can calculate d from factorize (which I already have, though probably less elegantly than you've coded it)
05:48:02 <osfameron> thanks!  that should set me up for now
05:48:20 <wli> osfameron: It's the product of 1 plus the exponents.
05:50:15 <wli> osfameron: Just the prime divisors is not quite right. They have to be collected into distinct prime divisors with multiplicities.
05:50:39 <shapr> MyCatVerbs: There are cuss words in lojban, sort of
05:51:13 <osfameron> wli: cool
05:51:15 <shapr> b_jonas: lojban words are like a bunch of functions that can be partially applied, and you have fst snd third, etc built in
05:51:43 <shapr> b_jonas: also, function composition (or maybe more like monad transformers) is how you build larger words.
05:51:57 <EvilTerran> ...
05:52:18 * EvilTerran is gonna have to learn lojban now. i'd heard of it, but not heard it compared to programming before.
05:52:54 <nopcode> EvilTerran: http://xkcd.com/191/
05:52:55 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
05:53:48 <b_jonas> It's sort of obvious to me that it's connected to programming, but I've never heared it compared to haskell in particular
05:54:07 <MarcWeber> dcoutts: I don't know the m4 language yet... It seems that I still have to add GLIB_LIBS to GTK_LIBS ? The path is still missing. Using a sed command I did get http://rafb.net/p/KeKem056.html now. Can you tell me which is the way to add two library sources ? (line 5) this way: (.. [] , [GLIB_LIBS (GTK_LIBS $STARTUP_CODE)] )
05:54:08 <lambdabot> Title: Nopaste - No description
05:54:18 <shapr> One reason I got into Haskell because I wanted to create a spoken programming language from lojban.
05:54:19 <opqdonut> yeah quite a few oldschool scifi books have computers that are "programmed" by talking to them in loglan/lojban
05:54:56 <shapr> opqdonut: The Moon is a Harsh Mistress
05:55:10 <ddarius> That's one of the few Heinlein books I haven't read.
05:55:32 <dionoea> hi. What complexity does List.nub have ? O(n**2) ?
05:55:35 <shapr> Loglan is only mentioned in passing in that book, but it is how the main character talks to a computer.
05:55:45 <ddarius> dionoea: Yes, as is obvious from it's interface.
05:55:45 <augustss> dionoea: yes
05:55:47 <EvilTerran> @src nub
05:55:47 <lambdabot> nub = nubBy (==)
05:55:51 <EvilTerran> @src nubBy
05:55:52 <lambdabot> nubBy eq []             =  []
05:55:52 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:56:02 <dionoea> ok, thanks.
05:56:07 <dcoutts> MarcWeber: hmm, I'm not sure I follow
05:56:10 <augustss> You can tell from its type
05:56:22 <ivant> shapr, so have you had any success in the creation of that programming language?
05:56:25 <augustss> it can only compare for equality
05:56:28 <ddarius> dionoea: You can make a faster one if you elements are ordered.
05:56:45 <dcoutts> MarcWeber: you're missing a $ there btw
05:56:49 <shapr> ivant: I came up with a bunch of ideas about spoken programming, but got distracted by the amazing power and niftiness of Haskell :-)
05:57:09 <EvilTerran> map fst . group
05:57:17 <ddarius> map fst . group . sort
05:57:22 <ivant> shapr, I expected exactly that answer :-)
05:57:22 <dcoutts> MarcWeber: try: GTKHS_PACKAGE_FILTER_LIBS([GTK_LIBS], [], [$GTK_LIBS $STARTUP_CODE])
05:57:24 <ddarius> If you don't care about stability.
05:57:24 <dionoea> ddarius: unfortunately they're not sorted.
05:57:32 <ivant> som is there any haskell library around, which does the lojban parsing?
05:57:48 <ivant> s/som/so/
05:57:48 <EvilTerran> if you do ddarius' solution there, you'll get nlogn rather than n^2
05:57:49 <shapr> ivant: Not that I've heard of, but there is a debian package with a lojban parser.
05:57:56 <dionoea> what complexity does List.sort have ? :)
05:57:58 <ddarius> dionoea: You can sort them if they're orderable.  If not, than nub is the best you can do.
05:58:01 <ddarius> n log n
05:58:08 <ddarius> It should be a mergesort.
05:58:29 <ddarius> You can make n log n version of nub (with Ord) that don't rearrange the elements.
05:58:45 <ddarius> s/map fst/map head
05:58:45 <ivant> shapr, yep, jbofihe. But it could be much easier to learn lojban by reading its parser
05:59:46 <shapr> ivant: Yeah, that's a point.
05:59:51 <shapr> But there's a good lojban tutorial online.
05:59:58 <ivant> shapr, which one?
06:00:19 <b_jonas> of coutse you can. if you belive in hash functions, you can even make a linear one.
06:00:20 <dozer> hi guys
06:00:28 <shapr> ivant: The one on www.lojban.org
06:00:54 <ivant> shapr, I tried "lojban for beginners" but I pretty much disliked the way it is written, so I switched to reading the "lojban reference grammar", which is a bit tough, but more conscise
06:01:27 * ddarius has no desire to learn an artificial "natural" language.
06:01:53 * dozer thinks that if you are going to learn one of those at all, it should be klingon - at least you get to spit on people
06:02:24 <SamB_XP> and make them bleed, eh?
06:02:28 <Lycurgus> you can do that with Nederlands
06:02:31 <shapr> heh
06:02:35 * earthy laughs
06:02:37 <earthy> no you can't
06:02:38 <shapr> graag gedann!
06:02:44 <earthy> at least, it's considered extremely impolite
06:02:45 <shapr> earthy: You can if you're from Nijmegen
06:02:53 <b_jonas> lol
06:02:54 <earthy> en ik kan 't weten, want ik ben er wel eens op aangesproken. :P
06:03:10 <earthy> 'praat eens met wat minder consumptie!'
06:03:14 <xahlee> what does the up-arrow mean in haskell?
06:03:33 <dozer> xahlee: paste the ascii?
06:04:07 <dblhelix> @type (^)
06:04:09 <almost> xahlee: you mean "^"? It means "to the power of"
06:04:13 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:04:13 <earthy> (yep, the dutch have a specific idiom for describing 'speaking with inadvertent expulsion of spit')
06:04:14 <xahlee> in graham's book. e.g. 2↑3*4
06:04:42 <desegnis> ivant, shapr; you might be interested in Esperanto, it kind of uses reverse hungarian notation for types  and makes heavy use of casts :)
06:04:49 <dblhelix> xahlee: in ascii it's ^
06:04:50 <xahlee> does haskell actually parse that up arrow char? or is it just a printing convention in the book?
06:05:01 <dblhelix> xahlee: just a convention
06:05:32 <xahlee> wow, it actually works!
06:05:41 <SamB_XP> xahlee: what?
06:05:45 <olsner> > 2↑3*4
06:05:46 <lambdabot>  Illegal character ''\134''
06:05:52 <b_jonas> ^ is really an up arrow and _ is a left arrow, they're just usually showed wrong because this new ascii standard requires that
06:05:54 <shapr> desegnis: I may check it out someday.
06:05:59 <xahlee> 2↑3 in ghci returns 32 here
06:06:18 <SamB_XP> b_jonas is a SmallTalker, eh?
06:06:18 <xahlee> it seems to mean power tower
06:06:21 <Lycurgus> merkin: "say it don't spray it"
06:06:37 <dozer> $$2^3*4$$ in latex binds the 3 to the 2 and multiplies the result by 4
06:06:54 <earthy> > 2^3 * 4
06:06:56 <lambdabot>  32
06:07:01 <SamB_XP> dozer: I thought it displayed an equation
06:07:03 <ddarius> dozer: As it should.
06:07:26 <dozer> yeah, just saying :) (and testing that the latex plugin for kopete actually works for me now)
06:07:27 <xahlee> a bit confused. 2↑2 returns 22
06:07:38 <desegnis> shapr, fijn
06:07:48 <dozer> >2^2
06:08:05 <ddarius> SamB_XP: Actually it just diddles some bits in memory and on your harddrive.
06:08:31 <SamB_XP> ddarius: not if you have xdvi open it doesn't
06:08:42 <SamB_XP> (to the right file)
06:08:55 <dozer> I'm lost in mutually recursive class context hell
06:08:58 <ddarius> But that's xdvi displaying the equation.
06:09:33 <SamB_XP> okay, so it TYPESETs an equation...
06:16:20 <Japsu> Errrrrr... How do I encode a [Char] into a Lazy ByteString?
06:16:53 <Saizan> Data.ByteString.Lazy.Char8.pack ?
06:16:57 <Cale> popcount: hello?
06:17:04 <Saizan> ?type Data.ByteString.Lazy.Char8.pack
06:17:06 <lambdabot> [Char] -> Data.ByteString.Lazy.ByteString
06:17:10 <Japsu> Hmm, thanks
06:17:15 <popcount> Cale, hello (you can ignore what I said)
06:17:28 <Japsu> Tried D.BS.L.pack, it was just [Word8] -> LBS
06:17:37 <Cale> popcount: In your GHC ticket, abc is pattern bound
06:17:53 <popcount> Cale, the GHC ticket is already closed
06:17:56 <Cale> ah, okay
06:18:06 <Cale> and you know why
06:18:12 <popcount> Cale, yes, I closed it.
06:18:29 <Cale> okay
06:18:32 * desegnis grumbles something about always having used pack . map (toEnum . fromEnum)
06:19:42 <Japsu> heh
06:20:25 <Saizan> @source Data.ByteString.Lazy.Char8
06:20:25 <lambdabot> Data.ByteString.Lazy.Char8 not available
06:21:03 <desegnis> @source Data.ByteString.Lazy.Char8.pack
06:21:03 <lambdabot> Data.ByteString.Lazy.Char8.pack not available
06:22:31 <desegnis> well, in GHC's libraries it is pack = L.pack. P.map c2w
06:23:20 <Saizan> c2w = fromIntegral . ord
06:23:53 <desegnis> so that's more efficient because it uses Int instead of Integer, right?
06:24:06 <Saizan> ?type fromEnum
06:24:07 <desegnis> wait, fromEnum uses Int, too
06:24:08 <lambdabot> forall a. (Enum a) => a -> Int
06:25:10 <Saizan> i think it's just that ghc optimizes it better
06:25:38 <desegnis> fine
06:26:19 <vincenz> @spell focused
06:28:15 <dionoea> if i do something like : nub $ take 100000 $ functiongeneratingalist, will it build the 100000 item long list first and then nub ? or is it going to nub on the fly ?
06:28:43 <mauke> > take 10 $ nub [1 ..]
06:28:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:28:50 <mauke> nub on the fly
06:29:04 <dionoea> ok :) thanks
06:29:26 <_roconnor> Horray, laziness
06:29:38 <yaxu> oh, i thought nub sorted first
06:29:54 <desegnis> @type nub
06:29:56 <lambdabot> forall a. (Eq a) => [a] -> [a]
06:29:57 <mauke> what was the line?
06:30:11 <Saizan> map head . group . sort?
06:30:12 <mauke> > nubBy (((>1) . ) . gcd) [2 ..]
06:30:13 <desegnis> yaxu, nub would need (Ord a) for sorting
06:30:14 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:30:59 <yaxu> i see
06:31:07 * dionoea 's still kind of lost with haskell
06:31:29 <dionoea> I'm trying to do something which sounds really sample ... but i can't do it in finite time :(
06:31:52 <MyCatVerbs> :t nub
06:31:54 <lambdabot> forall a. (Eq a) => [a] -> [a]
06:31:58 <MyCatVerbs> @src nub
06:31:58 <lambdabot> nub = nubBy (==)
06:32:05 <MyCatVerbs> @src nubBy
06:32:06 <lambdabot> nubBy eq []             =  []
06:32:06 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:32:14 <dionoea> basically it's building this list: [a+b|a<-c,b<-c,a+b<100000] where c is a list with about 7000 elements
06:32:25 <dionoea> + a nub right before that
06:32:31 <dionoea> and this takes for ever to run :/
06:32:37 <mauke> > 7000^2
06:32:39 <lambdabot>  49000000
06:33:03 <desegnis> dionoea, numbers are Ord, so you don't need to use nub
06:33:30 <dionoea> ? (I don't want duplicates in that list)
06:33:34 <desegnis> dionoea, as Saizan wrote, map head . group . sort
06:33:51 <Saizan> also (+) is commutative, so you don't have to try the whole cartesian product
06:33:56 <dionoea> well that also takes for ever to run :/ Unless I messed up somewhere else
06:34:16 <mauke> sorting c could lead to a better algorithm
06:34:17 <dionoea> Saizan: yeah, i remove some of the elements in the b<-c
06:34:24 <dionoea> and c is sorted
06:34:38 <mauke> then you don't need to brute force all over it
06:35:34 <MyCatVerbs> nub is for removing duplicate entries in a list?
06:35:41 <mauke> yes
06:35:53 <dionoea> [a+b|a<-c,b<-takeWhile (<100000-a)$dropWhile (<a) c] still takes for ever :/
06:36:04 <desegnis> maybe a <- c, b <- a? (haven't thought much about this)
06:36:10 <mm_freak_> cool…  my first SDL/OpenGL program in haskell is working =)
06:36:20 <Saizan> desegnis: a is not a list there
06:36:29 <olsner> was that a unicode ellipsis?
06:36:33 <desegnis> oh...  right, Saizan
06:36:36 <mm_freak_> olsner: yes
06:36:37 <MyCatVerbs> And, uh, takes forever to run? (That looks suspiciously like n^2 average case, n^1 best case (best case being the output of (take n $ repeat x) for some finite n and x).
06:36:56 <Nucleo_> How do I convert or coerce [Char] to a ByteString?
06:37:15 <MyCatVerbs> mm_freak_: awesome feeling, no?
06:37:18 <mux> Nucleo_: pack
06:37:29 <mux> :t pack
06:37:32 <lambdabot> Not in scope: `pack'
06:37:33 <desegnis> lambdabot needs an @faq, or has it?
06:37:36 <Nucleo_> @hoogle paq
06:37:36 <lambdabot> No matches found
06:37:38 <Nucleo_> @hoogle pack
06:37:39 <lambdabot> Data.PackedString.packString :: String -> PackedString
06:37:39 <lambdabot> Distribution.InstalledPackageInfo.package :: InstalledPackageInfo -> PackageIdentifier
06:37:39 <lambdabot> Distribution.PackageDescription.package :: PackageDescription -> PackageIdentifier
06:37:46 <desegnis> Nucleo_, Data.ByteString.Lazy.Char8.pack
06:37:53 <mux> hoogle only has the old Data.PackedString
06:37:53 <Nucleo_> ahh, thank you.
06:38:08 <mm_freak_> mycatverbs: yeah…  just didn't believe it would all just work as excepted
06:38:10 <mm_freak_> expected
06:38:43 <mux> @check \s -> unpack (pack s) == s :: Bool
06:38:44 <lambdabot>   Not in scope: `pack'
06:38:48 <mux> bleh
06:39:00 <mux> @check \s -> reverse (reverse s) == s :: String -> Bool
06:39:01 <lambdabot>  Couldn't match expected type `String -> Bool'
06:39:06 <mux> @check \s -> reverse (reverse s) == s :: Bool
06:39:06 <lambdabot>  Add a type signature
06:39:09 <dionoea> do you have a special paste service to use for this chan? or can I just use anything?
06:39:10 <mm_freak_> everytime i write something in haskell, it just works…  if it doesn't work, it won't compile in the first place
06:39:15 <mux> @check \s -> reverse (reverse s) == (s :: String)
06:39:16 <lambdabot>  OK, passed 500 tests.
06:39:25 <mm_freak_> dionoea: hpaste
06:39:27 <mauke> @paste
06:39:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:39:36 <mauke> it has size problems, though
06:40:44 <sorear> .
06:41:22 <sorear> glguy deliberately set a 5K limit
06:41:37 <sorear> he doesn't beleive you'll ever need more
06:41:54 <mauke> he's wrong
06:41:54 <olsner> "5k should be enough for anybody"
06:42:14 <hpaste>  dionoea pasted "(no title)" at http://hpaste.org/2231
06:42:22 <sorear> 07.03.29:21:29:04 <glguy> if you want to host >5K files, hpaste is the wrong place
06:42:42 <dionoea> if anyone can spot an obvious error / optimisation...
06:43:47 <MyCatVerbs> mm_freak_: XD
06:46:10 <Saizan> dionoea: i'd try with map head . group . sort $ [a+b|(a,bs)<-zip abundant (tails abundant),b<-bs]
06:46:38 <shapr> bok zvrba
06:46:49 <ndm> aa_: hi, i'm neil
06:46:59 <aa_> ndm: hi, sorry to bother you
06:47:24 <ndm> aa_: nope, feel free - what did you want to ask
06:47:26 <aa_> ndm: about GuiHaskell SoC project. Week 5 mentions "investigating PIDA". I am the author of PIDA and was wondering if I could od anything to help
06:47:57 <ndm> aa_: the schedule is quite a bit behind, we're certainly not near the PIDA stage
06:48:22 <ndm> aa_: but its good to know that you are around and able to help - are you usually on #haskell, or perhaps you have an email?
06:48:58 <aa_> ndm: nah, never on #haskell to be honest, but there is #pida, and my email address is aafshar@gmail.com, and the PIDA mailing list failing that
06:49:18 <aa_> anyway, good luck. The project looks interesting
06:49:37 <dblhelix> aa_: you know this channel is logged, don't you? prepare for spam etc.
06:49:42 <ndm> aa_: cool, i'll pass that all on to the student - i'm not sure we'll get to PIDA during the summer, but the student may stay around after
06:49:59 <aa_> dblhelix: 2K spam per day as it is :)
06:49:59 <ndm> dblhelix: if you post to a mailing list, you get hte spam anyway, and gmail is quite good about filtering it
06:50:10 <ndm> yeah, i get ~ 2k as well per day
06:50:20 <ndm> and only those written in japanese make it through the filter
06:50:28 <dionoea> Saizan: still takes more than 1 GB ram :/ (while It should only take 4*6965**2 bytes maximum :( )
06:50:37 <aa_> anyway, take care all
06:51:42 <ndm> thanks for your offer of help :)
06:52:28 <hpaste>  popcount pasted "Functional dependencies problem" at http://hpaste.org/2232
06:52:43 <popcount> Cale, you might want to help with that
06:53:43 <dolio> Wow.
06:54:03 <vincenz> popcount: you have an extra constraint, MonadTrans
06:54:25 <popcount> vincenz, no, that's not the problem, since a monadtransed monad is also a monad.
06:54:44 <vincenz> popcount: yes, but bar has more constraints than foo
06:54:44 <vincenz> namely
06:54:48 <vincenz> you want a MonadTrans t
06:54:49 <vincenz> such that
06:54:50 <vincenz> t m  ...
06:54:53 <vincenz> and not just a Monad m
06:54:56 <vincenz> as defined by the instance
06:55:06 <vincenz> erm
06:55:08 <vincenz> s/bar/foo/reverse
06:55:08 <popcount> vincenz, I didn't show you the instance context
06:55:13 <popcount> vincenz, I will add that
06:55:16 <mauke> what happened to darcs.net?
06:56:26 <hpaste>  (anonymous) annotated "Functional dependencies problem" with "(no title)" at http://hpaste.org/2232#a1
06:56:39 <popcount> vincenz, there you go
06:58:38 <vincenz> popcount: bar = lift foo?
06:59:38 <popcount> vincenz, that doesn't make sense
07:00:19 <vincenz> o.O?
07:00:20 <vincenz> yes it does
07:00:24 <vincenz> the relationship in X is regarding m
07:00:25 <shapr> @type lift
07:00:26 <vincenz> not the transformer
07:00:30 <vincenz> @type lift
07:00:30 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
07:00:32 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
07:00:32 <vincenz> oh right
07:00:34 <vincenz> you want unlift
07:00:34 <vincenz> :D
07:00:41 <vincenz> unlift typically means = no luck
07:01:30 <vincenz> but note how your X is defined in terms of 'm' not of (t m)
07:05:31 <thoughtpolice> grr... gcc seems broken. :(
07:05:40 <shapr> How so?
07:07:12 <b_jonas> (are you using old gcc?)
07:07:53 <thoughtpolice> http://rafb.net/p/alvWWH73.html
07:07:54 <lambdabot> Title: Nopaste - gcc err :(
07:07:56 <thoughtpolice> no
07:07:57 <thoughtpolice> 4.2.1 actually
07:08:20 <thoughtpolice> i'm considering pretty hardcore to just uninstall 4.2.1 and just ln -s /usr/bin/gcc-3.4 /usr/bin/gcc.
07:08:26 <popcount> vincenz, <the relationship in X is regarding m>, yes, I want that.
07:08:54 <vincenz> popcount: yet you are return 't m ...' in foo, while bar expects ar eturn in terms of 'm ..'
07:09:05 <vincenz> basically you're trying to unlift
07:09:11 <vincenz> which means, breaking out of the transformer
07:09:44 <popcount> vincenz, ok, I see.
07:11:10 <popcount> vincenz, then how can I make sure the "m" instance is being used for X and not (t m)?
07:12:08 <vincenz> I do not think this is possible
07:12:17 <vincenz> perhaps you could explain what you'r eactually trying to achieve
07:12:20 <vincenz> instead of the symptoms?
07:12:48 <popcount> vincenz, no, I don't understand.
07:12:54 <thoughtpolice> i'm trying to compile X11 and X11-extras for Xmonad, but noooo. :( damn bleeding-edge
07:13:29 <olsner> seems more like your binutils is too old
07:13:51 <popcount> vincenz, Ok, I see. I was mistaking my code with the thing I pasted.
07:14:02 <popcount> vincenz, ignore the context for bar and then same question
07:14:22 <vincenz> popcount: in short: not possible
07:14:27 <vincenz> please explain -what- you're trying to do
07:14:40 <popcount> vincenz, that would take an hour.
07:14:40 <vincenz> maybe then a solution can be found :)
07:14:49 <thoughtpolice> olsner: no, binutils is up to date. i might just restart (come to think of it this box hasn't been down for a few days and I did a pretty large upgrade yesterday...)
07:14:50 <vincenz> it's basically the same problem as
07:14:53 <vincenz> ContT State {
07:14:59 <vincenz> where the state holds continuation actions
07:15:11 <olsner> restarting is unlikely to make ld accept more options though ;-)
07:15:15 <vincenz> (that's just my gut reaction)
07:15:24 <thoughtpolice> no, but it has freakishly solved issues in the past
07:15:27 <thoughtpolice> why? i don't know.
07:15:49 <olsner> weird
07:16:04 <thoughtpolice> i guess my system just gets cranky or something. :( and I can't find anything related to that particular error (much less on archlinux, for gcc 4.2.1...)
07:16:20 <popcount> vincenz, all I am doing is lifting code running in some monad m to some monadtrans m
07:16:27 <popcount> vincenz, that's what I want to achieve.
07:18:14 <b_jonas> thoughtpolice: have you perhaps upgraded binutils after installing gcc?
07:18:23 <b_jonas> that is, could the binutils be too new?
07:18:55 <thoughtpolice> b_jonas: i normally upgrade once a week or so and do it en masse.
07:19:19 <b_jonas> oh, and if you want a solution, try asking on other channels, like ##workingset, #gcc, etc
07:19:24 <thoughtpolice> i don't know though, that might be it. :/ how frusterating.
07:19:38 <b_jonas> gcc doesn't really depend on anything though
07:19:45 <thoughtpolice> guess i'll just have to stick to my terminal and gcc 3.4 for now though.
07:19:59 <olsner> finally! my xterm can display APL ;-)
07:20:12 <b_jonas> olsner: ouch.
07:20:14 <hpaste>  vincenz annotated "Functional dependencies problem" with "hmm?" at http://hpaste.org/2232#a2
07:20:43 <b_jonas> I'm using 8859-1 xterms. I don't want to mess with unicode and multibytes and stuff.
07:21:06 <b_jonas> though of course I'm not using apl either.
07:21:13 <olsner> actually, I just wanted to try out 2↑3 in ghci
07:21:20 <b_jonas> s/8859-1/8859-2/ of course
07:21:20 <vincenz> popcount: like that?
07:21:22 <olsner> didn't work
07:22:08 <b_jonas> olsner: try it in apl?
07:22:33 <olsner> I don't have APL.. that was just a nifty side effect of getting unicode support set up
07:22:35 <popcount> vincenz, I already have that, AFAICT
07:23:20 <thoughtpolice> why use APL when you can use A+!
07:23:22 <thoughtpolice> http://www.aplusdev.org/
07:23:23 <lambdabot> Title: A+: a programming language for actual programmers
07:23:32 <b_jonas> so you can show the funny sort symbol or the botton with circle or things like that?
07:23:57 <thoughtpolice> easily one of the greatest programming languages ever conceived by man.
07:24:22 <b_jonas> and backslash with a tack and the symbols looking like upright phi and italic phi
07:24:45 <b_jonas> thoughtpolice: hmm, can I say things like that too here without getting lynched?
07:25:10 <hpaste>  (anonymous) annotated "Functional dependencies problem" with "(no title)" at http://hpaste.org/2232#a3
07:25:25 <popcount> vincenz, that's the error message I get
07:26:02 <psykotic> thoughtpolice, the c code is a treat. arthur's code is, uh, uniquely his. :)
07:26:21 <popcount> vincenz, the minor problem being that the type GHC derives _already_ contains that context!
07:27:01 <thoughtpolice> hm... perhaps I should write an A+ interpreter for my bot in haskell. that would show the author! :)
07:27:28 <b_jonas> that A+ looks completely like an apl
07:27:33 <thoughtpolice> b_jonas: note the 'one of.' personally I would put haskell as my 'greatest' :)
07:27:55 <thoughtpolice> i'm sure that too might get me lynched certain places though.
07:27:57 <thoughtpolice> (sadly)
07:28:28 <b_jonas> not more than apl I think
07:28:51 <wli> Haskell is good for its own problem domains. Other languages are better for others. Ultimately they're all just tools.
07:28:52 <thoughtpolice> i should invest some time to learn a language like J or something.
07:29:22 <thoughtpolice> of course. :) this is only the opinion of a mere mortal, although it's just a really really good hammer as far as I'm concerned
07:29:36 <b_jonas> if you want to, J should be easy to learn if you already know apl and haskell
07:29:39 <b_jonas> I think
07:29:45 <byorgey> b_jonas: agreed.
07:29:58 <thoughtpolice> no apl background. :/ J looks a bit nicer though.
07:30:07 <b_jonas> because you know apl's array handling stuff and the pointless style of haskell
07:30:58 <wli> If you want pointless, try squiggol.
07:31:50 <b_jonas> you don't have to program pointless in either haskell or J of course...
07:31:56 <b_jonas> it's just shorter
07:32:20 <wli> Try squiggol. ;)
07:32:43 <b_jonas> squiggol? what's that
07:33:02 <b_jonas> (if you want pointless, try unlambda which forces you to do that :)
07:33:27 <wli> Pointlessness is mandatory in squiggol, too, but it's not stupid like unlambda.
07:34:37 <wli> ISTR it being described somewhat in the "Functional Programming with Bananas, Lenses, Envelopes, and Barbed Wire" paper.
07:34:47 <b_jonas> oh, is that this http://en.wikipedia.org/wiki/FP_programming_language then?
07:34:48 <lambdabot> Title: FP (programming language) - Wikipedia, the free encyclopedia
07:35:14 <wli> b_jonas: No.
07:35:20 <tuxplorer> When I try to load a music file with tryLoadMUS, I get the error as in http://hpaste.org/2228 Some SDL library linking error. my SDL.h is in /usr/include/SDL/ directory.. Even while installing the SDL bindings, it wasn't able to locate the file. I had to edit the cabal file and add the path to Include Dirs.. Now after installation, its unable to locate the header file. How do I tell GHC to look into /usr/include/SDL/ ?
07:35:33 <dolio> Squiggol was much later than FP.
07:35:56 <b_jonas> wli: oh, I thought so because that's where pointless is mandatory
07:36:06 <sorear> @seen Lemmih
07:36:06 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 4h 50m 22s ago.
07:36:17 <Lemmih> sorear: Yo.
07:36:22 <MarcWeber> dcoutts: It's still not working, do I need to add [$GLIB_LIBS] (line 2) to line 5 somehow? http://rafb.net/p/Yv774O83.html
07:36:23 <lambdabot> Title: Nopaste - No description
07:36:24 <b_jonas> I'll have to read up on this bananas thing because I think I've heared that name before
07:36:33 <tuxplorer> Lemmih: please help with the SDL related problem above :)
07:36:37 <sorear> Lemmih: tuxplorer, hsSDL, ghci, link errror
07:37:26 <Lemmih> tuxplorer: Did you run autoreconf? Is configure executable?
07:37:38 <byorgey> b_jonas: it's a great paper, but sort of dense depending on your math/PL theory background
07:38:11 <tuxplorer> Lemmih: I did a configure, build and install alone.. where should I do autoreconf? after build or before build?
07:38:20 <tuxplorer> and after editing the cabal file..
07:38:23 <tuxplorer> ?
07:38:33 <Lemmih> tuxplorer: Before you run 'cabal-setup configure'.
07:38:48 <dcoutts> MarcWeber: I suggest adding debug echo lines before and after those lines to check the value of $GLIB_LIBS and also of $GTK_LIBS
07:39:16 <Lemmih> tuxplorer: And don't touch the cabal file. That voids the warranty.
07:39:52 <dcoutts> MarcWeber: $GTK_LIBS should initially contain all the necessary flags including all the glib ones. The GTKHS_PACKAGE_FILTER_LIBS is actually to *filter out* flags that appear in dependent modules. So all we're trying to do is disable that and pass them through unaltered.
07:39:54 <tuxplorer> Lemmih: I did a runhaskell Setup.lhs configure. I don't have cabal-setup installed.. Do I need that to be installed?
07:40:28 <Lemmih> tuxplorer: No, cabal-setup is just a bit faster.
07:41:07 <dcoutts> MarcWeber: in fact you might be able to get away with commenting out those lines completely, but do add the echo "GLIB_LIBS=$GLIB_LIBS";  echo "GTK_LIBS=$GTK_LIBS"; to that code to see what's really going on.
07:41:08 <tuxplorer> but runhaskell Setup.lsh suto-reconf says Setup.lhs: Unrecognised command: autoreconf (try --help)
07:41:28 <Lemmih> tuxplorer: autoreconf is not related to the Cabal tools.
07:42:28 <dolio> It might be hard to use squiggol, though. Unless you have a keyboard with pi-with-a-left/right-accent on it.
07:43:22 <hpaste>  tuxplorer pasted "Lemmih: " at http://hpaste.org/2233
07:43:49 <dolio> And superscript black dot.
07:46:04 <tuxplorer> Lemmih: autoreconf says that it requires configure.in or configure.ac file in the dir
07:51:10 <dalecooper> when I enter any instruction containing a = into ghci, I get the following error:
07:51:11 <dalecooper> <interactive>:1:9: parse error on input `='
07:51:13 <MarcWeber> dcoutts: I should have invoked autoreconf as well I guess. Sorry for not switching on my brain
07:51:31 <dalecooper> e.g. square x = x * x => <interactive>:1:9: parse error on input `='
07:51:47 <tuxplorer> dalecooper: use let a =
07:51:48 <shachaf> dalecooper: Use let.
07:51:49 <dalecooper> ghci 6.6.1 on a mac
07:52:04 <dalecooper> thanks
07:52:12 <dalecooper> sorry.
07:52:39 <dcoutts> MarcWeber: np :-)
07:53:35 <tuxplorer> MarcWeber: does your autoreconf look into the cabal file? it asks for a configure.in in my system..
07:55:39 <tuxplorer> MarcWeber: can you please tell me how I should run autoreconf?
07:57:30 <doserj> dcouts: when using "extensions: CPP" in cabal, should cabal use cpphs, or ghc -cpp? (and what does ghc -cpp actually use in the end?)
07:57:31 <tuxplorer> I get the error autoreconf: `configure.ac' or `configure.in' is required
07:57:42 <MarcWeber> tuxplorer: Sorry what is your trouble? I've missed your posts. I was talking to dcoutts because of adding gtk2hs to nix.. ?
07:57:59 <doserj> sorry, I meant dcoutts
07:58:09 <tuxplorer> MarcWeber: When I run autoreconf I get the error autoreconf: `configure.ac' or `configure.in' is required
07:58:24 <tuxplorer> as in Haskell packages there is no configure file..
07:58:32 <MarcWeber> Why do you want to run it at all?
07:58:45 <MarcWeber> give me 2 secs
07:59:18 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2234
07:59:26 <tuxplorer> MarcWeber: http://hpaste.org/2234
07:59:27 <MarcWeber> tuxplorer: Do you know how cabal works?
07:59:34 <wli> Preprocessing... ew. There should be some method of doing it in the language.
07:59:36 <tuxplorer> MarcWeber: no.
07:59:54 <MarcWeber> You should have a [Ss]etup.*hs file ( *hs = hs or = lhs)
08:00:14 <MarcWeber> This does configure, build and install your library/ exectuable by default.
08:00:45 <MarcWeber> Options can be given just try $setup configure --help; $setup build help; $setup install help
08:01:17 <tuxplorer> MarcWeber: yes. I have one.. I 've installed a package, which doesn't understand the path to the header files that it needs.. When I told Lemmih(owner of that package) abt it, he asked me to run autoreconf once for it to understand the path..
08:01:37 <tuxplorer> MarcWeber: I know how to install using cabal.. I just don't know the internals of it
08:01:40 <MarcWeber> $setup is either runhaskell [Ss]etup.*hs or you can compile a setup file using ghc --make [Ss]etup.*hs -o setup ..
08:01:52 <MarcWeber> tuxplorer: Which package?
08:02:04 <tuxplorer> SDL bindings..
08:02:18 <MarcWeber> tuxplorer: source?
08:02:54 <tuxplorer> MarcWeber: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL-0.4.0   http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL-mixer-0.4.0
08:02:56 <lambdabot> http://tinyurl.com/2l75w3
08:04:37 <dcoutts> doserj: cabal picks between cpphs and ghc -cpp depending on the presence of cpphs and if we're actually using ghc or another compiler
08:04:47 <tuxplorer> MarcWeber: Just to let you know the problem.. When I try to load a music file with tryLoadMUS, I get the error as in http://hpaste.org/2228 Some SDL library linking error. my SDL.h is in /usr/include/SDL/ directory.. Even while installing the SDL bindings, it wasn't able to locate the file. I had to edit the cabal file and add the path to Include Dirs.. Now after installation, its unable to locate the header file. How do I tell GHC to lo
08:04:53 <dcoutts> doserj: ghc -cpp ends up using gcc -E I think
08:06:25 <doserj> dcoutts: here, cabal calls ghc -cpp, although cpphs is installed
08:06:51 <MarcWeber> tuxplorer: Your text is truncated :-)
08:07:06 <MarcWeber> I don't know sdl yet. Why does it need the .h file after installation?
08:07:44 <dcoutts> doserj: I changed it in recent darcs Cabal-1.1.7 to use ghc -cpp if we're using ghc
08:08:05 <dcoutts> doserj: and to only use cpphs for non-ghc compilers
08:08:18 <MarcWeber> tuxplorer: Your error message is telling you that a symbol is missing
08:08:23 <doserj> ah
08:08:29 <tonfa> how do you bin multiples local variables with "where" ?
08:08:33 <dcoutts> doserj: why?
08:08:39 <tonfa> s/bin/bind/
08:08:41 <tuxplorer> MarcWeber: While linking it says that the symbol is missing.. What could the problem be? I assumed that it has difficulty finding the header file where the definition is
08:08:58 <doserj> dcoutts: I want to use cpp and string gaps in the same file :)
08:09:15 <doserj> that seems to require trailing whitespaces, however :(
08:09:18 <MarcWeber> tuxplorer: A missing symbol does mean the function is not included within the .o file.
08:09:25 <tonfa> http://www.haskell.org/haskellwiki/Keywords#where << it only mentions binding one variable
08:09:27 <lambdabot> Title: Keywords - HaskellWiki
08:09:34 <MarcWeber> So the .h files and the .c files do not match somehow.
08:09:36 <dcoutts> doserj: I know cpp is a bit picky on that issue
08:09:38 <tuxplorer> MarcWeber: oh! then what should I do to bring it into the .o file?
08:10:06 <dcoutts> doserj: you can force it to use cpphs I think if you use Foo.hs.cpphs
08:10:18 <tuxplorer> MarcWeber: is it an incompatibility between the version of SDL I use and the bindings available?
08:10:38 <doserj> dcoutts: what do you mean with "use"?
08:10:40 <dcoutts> doserj: though actually that may be borken at the moment, you might want to patch cabal so it always uses cpphs for .cpphs files
08:10:52 <dcoutts> doserj: change the file extension
08:11:00 <doserj> oh
08:11:08 <MarcWeber> let a = tryLoadMUS "siv.ogg" .. that's dynamic loading.. either using hsplugins or the ghc library I think..
08:11:44 <MarcWeber> But Mix_OpenAudio looks like a C function (missing haskell functions look much more ugly.. :-)
08:12:26 <tuxplorer> MarcWeber: ok. What would I need to do to convert the file to a Music object? Is there any work around?
08:12:52 <MarcWeber> tuxplorer: Do you know to which library this function belongs?
08:12:59 <doserj> dcoutts: "can't find source for ..."
08:13:29 <doserj> dcoutts: do you mean this with "patch cabal"? :)
08:13:57 <tuxplorer> it belongs to SDL only.. I did a grep -ARE of that function.. and the result was that it was found in SDL
08:14:06 <dcoutts> doserj: I mean if you want to help fix this bug for everyone then you can look into changing the cabal code
08:14:50 <dcoutts> doserj: you'd want to start by looking at the cabal PreProcessor module and how the "cpphs" extension handler picks the cpp to use
08:15:16 <tuxplorer> MarcWeber: sorry. SDL_mixer library
08:15:47 <MarcWeber> tuxplorer: It's listed in the .hsc files, yes. You should try installing different sdl verlsions/ get the source and see wether it's there..
08:16:29 <MarcWeber> tuxplorer: Or just use readelf or a tool like that to see that it's missing. Which os are you using?
08:16:50 <tuxplorer> MarcWeber: Linux- ubuntu feisty fawn
08:17:29 <MarcWeber> tuxplorer: I don't know apt that well. Is there a way to just grab the source of a package?
08:18:49 <MarcWeber> tuxplorer: There might be apt-get source <package> ?
08:19:03 <tuxplorer> MarcWeber: yes. I'll grab the source.. and then ..
08:19:22 <MarcWeber> Check wether it contains that function.
08:20:06 <tuxplorer> MarcWeber: ok. Thanks :) If it doesn't contain, what should I do? look for other versions?
08:22:39 <MarcWeber> tuxplorer: Yes. Perhaps you need to compile it yourself.. Goto to the sdl homepage and get the latest grep there , ask Lemmih to add some information which sdl version is required .. (you can use @tell Lemmih <message> to sent him messages if hi is offline)
08:23:51 <tuxplorer> MarcWeber: ok. Thanks a lot :) That was great help
08:25:04 <MarcWeber> tuxplorer: Tell me wether you had success
08:25:26 <tuxplorer> MarcWeber: sure. will do..
08:27:29 <tuxplorer> MarcWeber: Its time for me to leave.. So, will try it tomo and let you know. Thanks a lot..
08:36:06 <doserj> dcoutts: using .cpphs, it preprocesses using cpphs fine, but then it compiles again using -cpp
08:36:31 <doserj> which is fine for other modules, but not for the .cpphs one
08:36:45 <dcoutts> doserj: right, hmm.
08:37:27 <doserj> so the modules to be compiled should have to be split into separate compile commands?
08:37:37 <doserj> *would
08:37:46 <dcoutts> doserj: because -cpp breaks on the string gaps in the file cpphs generated?
08:37:58 <doserj> dcoutts: yes
08:38:10 <doserj> cpphs leaves them unchanged
08:38:13 <malcolmw> couldn't a suffix .cpphs, coupled with compiler ghc, translate into ghc -cmdPcpphs -optP-cpp
08:38:43 <dcoutts> malcolmw: I guess so, though it's not very orthogonal
08:39:12 <doserj> malcomw, btw why is the newest cpphs not on hackage? :)
08:39:30 <dcoutts> remember, if it's not on hackage it doesn't exist! :-)
08:40:06 <dcoutts> doserj: the slightly hacky approach is to take CPP out of the extensions and add it into just the files you need
08:40:14 <malcolmw> oh, hackage only has cpphs-1.3!  that's positively ancient
08:40:42 <dcoutts> malcolmw: it's the latest version in gentoo too, because we track the hackage uploads
08:41:14 <malcolmw> I guess I'm just used to other people packaging for distribution, when I prepare only tarballs.
08:42:22 <dcoutts> malcolmw: the nice thing about hackage from this pov is that we have tools that automate things for packages in hackage
08:42:56 <dcoutts> malcolmw: so for example we have a tool that tells us if there are any updates available on hackage for packages we include in gentoo
08:43:05 <dcoutts> and in one command we can update it :-)
08:43:26 * dcoutts repeats the hackage mantra
08:43:44 <doserj> dcoutts: that doesn#t work for files containing both CPP and string gaps
08:44:21 <dcoutts> doserj: for ones with string gaps, you use .cpphs and not put CPP in the language extensions for that file
08:44:31 <doserj> ah
08:44:44 <doserj> silly me
08:44:54 <dcoutts> malcolmw: have you got cabal-upload, that makes it easier to integrate into the release process
08:45:44 * malcolmw uploads cpphs-1.5 to hackage
08:46:33 * malcolmw must have done something wrong, because the hackage DB still lists 1.3
08:47:12 * malcolmw discovers which page he needs to refresh
08:47:53 <Saizan> ?hackage cpphs
08:47:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cpphs
08:48:17 * dcoutts does $ hackport update; hackport diff newer
08:48:18 <dcoutts> cpphs                    [1.5>1.3]
08:48:29 <dcoutts> malcolmw: yay for automation :-)
08:48:43 <malcolmw> cool
08:48:48 * dcoutts runs hackport merge cpphs-1.5
08:48:51 * Saizan wants apt-get hackage 
08:48:55 <eivuokko> I was trying to build such tool for cabal2wix, but only got to the state where I build packages (somewhat).
08:49:10 <malcolmw> next, I need to learn about the new syntax for Cabal files, which has completely broken my nhc98 build scripts :-)
08:50:51 <dcoutts> malcolmw: realy? it should be backwards compatible with the old syntax, what broke?
08:51:31 <malcolmw> dcoutts: field-names no longer start in column 0
08:52:28 <malcolmw> dcoutts: previously, any line starting with a whitespace indent was a continuation of the previous line
08:52:55 <dcoutts> malcolmw: that should still be the case, do you have any examples, we should run them by Thomas
08:53:12 <malcolmw> dcoutts: Cabal.cabal for instance :-)
08:53:48 <dcoutts> malcolmw: ah, you're not parsing it are you, you're grepping
08:54:10 <malcolmw> dcoutts: no, I am parsing it, but according to the old rules
08:54:32 <dcoutts> malcolmw: well you could use the Cabal parser, then it works :-) and it's reads old files too
08:54:52 <dcoutts> malcolmw: parsing the new configurations stuff is less trivial
08:55:24 <malcolmw> dcoutts: I have a two-level parser, which first divides the file into fields, then looks for a specific field, and parses that more carefully
08:56:01 <dcoutts> malcolmw: any reason you can't use the Cabal parser?
08:56:33 <malcolmw> dcoutts: it looked rather nasty the last time I had a peek, although it might have improved by now.
08:57:29 <malcolmw> dcoutts: I have to say that I'm not entirely convinced that the configurations stuff needs both indentation and braces - surely one or other would be sufficient?
08:58:18 <dcoutts> malcolmw: yeah other people have said that too, I'm not convinced either, blame Igloo :-) he wanted the { }'s. Feel free to bring it up on the list.
08:58:46 <dcoutts> malcolmw: and we'd have to ask Thomas to try parsing an alternative without {}'s while he's still doing the SoC project
08:58:46 <sjanssen> @keal
08:58:46 <lambdabot> it is very easy to go off topic
08:58:52 <eivuokko> Imo, currently the parser isn't properly exposed from Cabal - I think the only way is to use readPackageDescription - which also prints warnings out, I think.
08:59:06 <SamB_XP> eww
08:59:14 <dcoutts> yes, one has to use readPackageDescription but you can use 0 verbosity
08:59:24 <SamB_XP> it should use MonadWriter or something...
08:59:51 <dcoutts> SamB_XP: yes, we know, there are many bits that could help with some monadification, care to help?
09:00:04 <SamB_XP> hmm.
09:00:16 <SamB> interesting idea
09:00:57 <vincenz> SamB != SamB_XP ?
09:01:00 <dcoutts> SamB: the other obvious one is that there are many many places that take a PackageDescription and LocalBuildInfo that should go into a Reader
09:01:04 <malcolmw> monadification, hmm.  I was hoping for some demonadification
09:01:19 <dcoutts> malcolmw: you mean removal from IO
09:01:25 <vincenz> malcolmw: demonification?
09:01:34 <SamB> vincenz: I switched to my hacking computer. yes, I know I should be using irssi and screen or something...
09:01:42 <vincenz> I was just asking
09:01:49 <vincenz> Not making value comments
09:01:56 <malcolmw> dcoutts: yeah, removal of IO
09:02:03 <SamB> people are always telling me that though
09:02:48 <dcoutts> malcolmw: yes, I'd like to do that too, possibly even layering on top of some restricted IO-like monad for the bits that have to do things like writing files and running progs
09:03:31 <eivuokko> Copying files should be in Writer-type of monad so we can have copy --list-files ;)
09:03:39 <SamB> w
09:03:57 <SamB> malcolmw: what do you have against monads?
09:04:08 <SamB> it wouldn't have to be MonadWriter per se
09:04:49 <malcolmw> SamB: nothing, just a dislike that they seem to creep in everywhere, even when they are strictly not needed
09:04:55 <Japsu> I'm trying to write a cabal specification file for a package I want to release under GPLv3. However, neither "GPLv3" nor "GPL3" nor "GPL-3" are recognized as valid licenses. What should I put there? Does Cabal (using 1.1.6.2) even recognize GPL3?
09:05:06 <SamB> malcolmw: aren't they not ever really needed?
09:06:00 <eivuokko> Japsu, it doesn't.  Only GPL, without version.  (Or possibly OtherLicense)
09:06:17 <malcolmw> SamB: I mean people sometimes use monads when the equivalent pure code would be just as clear
09:06:53 <eivuokko> Japsu, please remember to add license-file field :)  Annoying for installers if it's missing.
09:06:56 <SamB> Japsu: Cabal, like most of the rest of us, is refusing to recognize the GPLv3's existance ;-P
09:07:01 <Japsu> hehe
09:07:14 <Japsu> Okay, using "GPL" for now. There is a license file.
09:07:26 <SamB> Japsu: why do you want to use the GPLv3?
09:07:42 <eivuokko> Cabal doesn't know in what file, though, if you don't tell it :)
09:08:34 <doserj> dcoutts: haddock doesn't parse the LANGUAGE CPP pragma, does it?
09:08:59 <malcolmw> GPLv3 offers superior protection for both the original developers and end-users
09:09:05 <dcoutts> doserj: no, it ignores pragmas, cabal has to do cpp on behalf of haddock
09:09:14 <mux> too bad there's no Ord instance for License ;-)
09:09:24 <doserj> and cabal does that only if i put extensions: CPP in the .cabal file ...
09:09:30 <mux> we could have BSD3 > GPL.
09:09:55 <dcoutts> doserj: hmm, yes.
09:09:56 <Japsu> SamB: I knew it would come to this :)
09:10:09 <SamB> malcolmw: protection from what?
09:10:16 <doserj> dcoutts: a clean solution seems to be difficult :)
09:10:37 <dcoutts> Japsu: Cabal doesn't care about the version of the license, just use GPL in that field, it's not specific to v2 or v3
09:10:40 <malcolmw> SamB: protection from patent lawsuits
09:10:44 <dcoutts> doserj: yes :-(
09:10:44 <Japsu> dcoutts: ok, thanks
09:10:59 <eivuokko> doserj, cpp takes over your project? -.-
09:11:01 <dcoutts> doserj: could you open a bug on this issue please so we don't forget
09:11:11 <Japsu> I'll probably change the license to LGPLv3 if my library becomes something actually usable
09:11:26 <Japsu> Hmm
09:11:39 <Japsu> what's the preferred way of building examples for a Haskell library?
09:11:56 <Japsu> I mean, how should I put them in the cabal file? just as Executable: sections?
09:12:16 <wli> I usually say "pick one of the following licenses."
09:13:04 <wli> Where the list includes BSD, GPL, Artistic, etc.
09:13:21 <wli> LGPL, too.
09:13:29 <Japsu> Well, if I offer LGPLv3, I don't see any reason to offer other licenses
09:13:57 <wli> "public domain where legally meaningful"
09:14:06 <eivuokko> heh
09:16:37 <sorear> @users
09:16:37 <lambdabot> Maximum users seen in #haskell: 375, currently: 375 (100.0%), active: 27 (7.2%)
09:17:35 <b_jonas> wli: GPL is redundant if you give LGPL as well
09:18:05 <wli> b_jonas: The users can choose GPL over LGPL if they wish.
09:18:43 <shachaf> sjanssen: If you do use idiom brackets, wouldn't [{ id f g }] work, for the join?
09:18:50 <Japsu> wli: yes, but LGPL also gives the user this choice
09:18:53 <shachaf> sjanssen: Instead of adding separate syntax?
09:19:02 <malcolmw> wli: if a user chooses GPL, then contributes a patch back to you, can you accept it?
09:19:08 <Japsu> wli: in LGPL, there is a clause saying "you can use GPL instead of LGPL for the licensed software"
09:19:18 <sjanssen> @type return id `ap` ?f `ap` g
09:19:20 <lambdabot> Not in scope: `g'
09:19:22 <sjanssen> @type return id `ap` ?f `ap` ?g
09:19:24 <lambdabot> forall a b (m :: * -> *). (?f::m (a -> b), ?g::m a, Monad m) => m b
09:19:49 <shachaf> > id <$> [(+1),(+2)] <*> [1,2,3]
09:19:51 <lambdabot>  [2,3,4,3,4,5]
09:20:15 <wli> malcolmw: Not sure. I guess I'd have to ask how they want to license the patch. I guess it does make receiving contributions harder.
09:20:18 <SamB> malcolmw: that's where you can bring the threat of bitrot to bear ;-P
09:20:23 <sjanssen> shachaf: that's not quite right
09:20:40 <sjanssen> shachaf: how do you make 'putStrLn' work?
09:22:49 <ndm> malcolmw: i just demand in hoogle that everyone who contributes a patch to me does so under BSD, then i license hoogle under gpl
09:23:05 <shachaf> sjanssen: Oh, hmm.
09:23:13 <shachaf> sjanssen: Never mind, then. :-(
09:23:43 <malcolmw> ndm: doesn`t that mean you have to add a long list of attributions "this product contains software written by ..."
09:23:57 <SamB> hmm. I have a conflict in doc/Cabal.xml :-(
09:23:58 <ndm> malcolmw: nope, or rather, i'm not going to :)
09:24:13 <ndm> malcolmw: i am happy to have a list of acknowledgements to anyone who includes a patch, of course, since thats polite
09:24:32 <sorear> ndm: he's referring to a defect in one of the old bsd licenses
09:24:37 <ndm> i consider a darcs repo listing all the authors sufficient acknowledgement for copyright purposes
09:24:47 <thoughtpolice> general question: is there any real secret or tip to making your code pure? I realize purity has a lot to do with things like consistant and well-defined testing, it just seems like there's some sort of 'trick' to it or something or, is it simply an acquired taste?
09:24:49 <ndm> sorear: i think even BSD3 requires you to acknowledge copyright holders
09:25:01 <ndm> i am aware of the BSD4 thingy, but no one uses that
09:25:02 <SamB> ndm: but not in all advertisements
09:25:21 <lament> thoughtpolice: write it in haskell
09:25:31 <lament> it is a pretty dirty trick
09:25:41 <ndm> yes, i consider my "copyright holder listing" to be darcs plus some shell script
09:26:31 <SamB> ndm: what if someone includes someone else's code?
09:26:40 <doserj> dcoutts: #146
09:26:43 <tonfa> is there a simple to get the first n items of a list ?
09:26:48 <dcoutts> doserj: thanks
09:26:52 <shachaf> > take 5 [1..]
09:26:54 <lambdabot>  [1,2,3,4,5]
09:27:03 <ndm> SamB, meh - they should have patched it at me on their own
09:27:12 <tonfa> shachaf: thanks
09:27:16 <ndm> legal stuff is only important if you intend to make money of these things
09:27:23 <shachaf> > drop 2 [1..10]
09:27:24 <lambdabot>  [3,4,5,6,7,8,9,10]
09:27:36 <doserj> dcoutts: thanks to you :)
09:27:42 <shachaf> @hoogle Int -> [a] -> [a]
09:27:43 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
09:27:43 <lambdabot> Prelude.take :: Int -> [a] -> [a]
09:27:43 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
09:27:46 <thoughtpolice> lament: I mean, any trick to keeping your code pure and composable, naturally it's easy to write code with side-effects etc, it just seems like there's something TO looking at your code and being able to pick out what does and does not need a side effect.
09:28:05 <tonfa> shachaf: thanks, I didn't know how to search like that
09:28:20 <shachaf> thoughtpolice: Avoid side effects unless they're absolutely necessary.
09:28:38 <jsnx> is the 'state' in a particular type of monad shared by all monads of that type?
09:28:51 <earthy> no
09:29:10 <jsnx> so, it's in the instance of the monad?
09:29:21 <earthy> if you want to think of it as an instance, yes
09:29:36 <jsnx> i'm thinking each 'do' is an instance
09:29:44 <shachaf> "Instance" is usually used for an instance of a type class.
09:29:53 <thoughtpolice> shachaf: so you're saying it's not about being able to look and say "this doesn't particularly need a side effect" as much as it is to just say "keep the hell away from side effects and minimize their use"
09:29:54 <jsnx> shachaf: yes, i know
09:29:56 <earthy> jsnx: you'd be thinking wrong
09:30:00 <shachaf> jsnx: A monad is just a value -- think of Maybe.
09:30:23 <jsnx> shachaf: the monad is what is returned by the do block, right?
09:30:28 <earthy> each monadic value that has a particular type carries its own particular state value along (if it happens to have state)
09:30:35 <earthy> jsnx: yes
09:30:47 <earthy> however, that monadic value can then be input to another do block
09:30:55 <jsnx> earthy: aha!
09:30:59 <shachaf> jsnx: Remember that do-notation is just syntax sugar.
09:31:51 <jsnx> earthy: so, how does this monadic system handle the case where, like with IO, all monads of that type must share the same state (or world)
09:32:03 <jsnx> what then?
09:32:15 <earthy> so   let f x = do y <- getsomeValue x; return (y + 3); in let g k = do let h <- getsomeValue k ; return h + 4; in return 5 >>= f >>= g
09:32:24 <earthy> err... that's typed wrongly
09:32:47 <earthy> so   let f x = do y <- getsomeValue x; return (y + 3); in let g k = do let h <- getsomeValue k ; return h + 4; in f (g ( return 5))
09:32:50 <earthy> that's better
09:33:04 <desegnis> jsnx, there is one top-level IO action called main :: IO (), so you cannot have independent actions acting on different worlds
09:33:14 <earthy> jsnx: in that case you simply make 1 value of that type
09:33:31 <earthy> e.g. with IO there is (at top level) exactly one value of type IO
09:33:42 <earthy> it may have been built from a number of IO values
09:33:43 <jsnx> so, there is just one IO monad
09:33:57 <earthy> no. :)
09:34:06 <jsnx> but, uhm...
09:34:11 <shachaf> jsnx: You may be confusing values with types.
09:34:24 <earthy> but, the toplevel of your program only has 1 IO value
09:34:35 <jsnx> what is the 'toplevel' ?
09:34:37 <earthy> that IO value has been constructed from a number of 'smaller' IO values
09:34:43 <earthy> jsnx: the 'main' function
09:34:53 <desegnis> well, actually there is exactly one monad called IO, so jsnx is right saying there is just one IO monad
09:34:53 <earthy> which really is just a value declaration
09:35:11 <jsnx> desegnis: can you explain?
09:35:23 <earthy> um... yeah, but there's also just 1 Maybe monad, and just 1 [] monad
09:35:34 <earthy> that doesn't help jsnx understand though ;)
09:35:46 <earthy> basically, jsnx, in Haskell you declare values
09:35:52 <jsnx> aye
09:36:04 <earthy> so, main :: IO ()   declares that the value of main is of type IO ()
09:36:15 <desegnis> jsnx, I wasn't entirely serious. I mean, there is only one type constructor called IO, there are not IO1, IO2  and IO2
09:36:19 <earthy> implicitly, this value is then executed
09:36:22 <desegnis> *and IO3
09:36:36 <earthy> it may have been constructed from many IO values
09:36:43 <jsnx> earthy: is the State monad different?
09:36:47 <earthy> e.g. putStrLn takes a string and returns an IO value
09:36:50 <earthy> jsnx: no
09:36:52 <jsnx> can I have many states?
09:37:03 <earthy> but for the fact that you can explicitly run the state
09:37:25 <jsnx> are all monads as you have described? there is but one 'top level' value of that monadic type?
09:37:28 <earthy> jsnx: you can have as many states as you have runState calls
09:37:29 <shachaf> jsnx: You can have many values of type IO a.
09:37:46 <jsnx> shachaf: but only one toplevel, right?
09:37:48 <shachaf> jsnx: And main :: IO () combines them.
09:38:07 <byorgey> jsnx: no, the IO monad is rather special.
09:38:11 <earthy> there is only one value that is actually calculated for each Haskell program, essential
09:38:17 <earthy> essentially
09:38:23 <jsnx> shachaf: so, how does the computer know that main :: IO () combines them?
09:38:23 <earthy> which is the value of 'main'
09:38:27 <dcoutts> ndm: eivuokko: can you help us sort out what the default install dirs should be for windows, I'm working on that code atm.
09:38:37 <earthy> jsnx: ah, you combine them, using >>=
09:38:56 <jsnx> earthy: okay, so that's how we do it with IO monads
09:39:03 <jsnx> to recapitualte:
09:39:05 <shachaf> jsnx: And with every monad.
09:39:12 <jsnx> hmmm
09:39:18 <shachaf> jsnx: main = getLine >>= \x -> putStrLn x
09:39:33 <jsnx> so, for every monad of a certain type, you may specify as many values of that type as you like...
09:39:35 <shachaf> add1ToState = get >>= \x -> put (x + 1)
09:39:39 <earthy> jsnx: exactly
09:39:44 <earthy> and then combine those values as you wish
09:39:58 <shachaf> jsnx: And one monadic value can use others.
09:40:00 <jsnx> yes, but in the end, there is only one value left
09:40:02 <desegnis> jsnx, the difference between the IO monad and other monads is that there is no function runIO (at least not if you program decently), so the only thing you can do with values in the IO monad is combining them, ending up with the top-level IO action main.
09:40:11 <earthy> jsnx: after combination, yes.
09:40:25 <shachaf> jsnx: For most monads (not IO), you can "run" the monad.
09:40:29 <shachaf> jsnx: E.g., runState.
09:40:37 <ddarius> @djinn IO a -> a
09:40:37 <lambdabot> -- f cannot be realized.
09:40:44 <earthy> @djinn State a -> a
09:40:45 <lambdabot> -- f cannot be realized.
09:40:46 <shachaf> @djinn State s a -> a
09:40:46 <lambdabot> -- f cannot be realized.
09:40:50 <shachaf> @djinn-env
09:40:51 <lambdabot> data () = ()
09:40:51 <lambdabot> data Either a b = Left a | Right b
09:40:51 <lambdabot> data Maybe a = Nothing | Just a
09:40:51 <lambdabot> data Bool = False | True
09:40:51 <lambdabot> data Void
09:40:51 <earthy> @hoogle State s a -> a
09:40:53 <lambdabot> type Not x = x -> Void
09:40:55 <lambdabot> class Eq a where (==) :: a -> a -> Bool
09:40:57 <lambdabot> Text.ParserCombinators.Parsec.Prim.stateUser :: State tok st -> st
09:40:59 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
09:40:59 <jsnx> so, no matter how you write your program, there is only one value of a particular monad
09:41:06 <earthy> no
09:41:08 <earthy> :)
09:41:19 <jsnx> hmm
09:41:21 <earthy> during evaluation many values may occur
09:41:30 <jsnx> during evaluation?
09:41:47 <earthy> 'during evaluation' =~ 'at runtime'
09:41:55 <jsnx> aye
09:42:02 <jsnx> thanks
09:42:36 <jsnx> so, we have a whole bunch of monads a, b, c, ... :: T for some T
09:42:41 <jsnx> and there are many of them
09:42:48 * earthy nods
09:43:09 <jsnx> when i combine them, using >>=, for example, what happens?
09:43:16 <jsnx> how many monads are left?
09:43:23 <earthy> more. :)
09:43:44 <jsnx> but, uhm, how many independent states are left?
09:43:48 <shachaf> @ty (>>=)
09:43:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:43:52 <jsnx> less, i hope
09:44:02 <earthy> so, suppose I have  [a,b] :: [T], then I can do  f xs = (xs, sequence xs)
09:44:12 <shachaf> @ty join -- You can think of it in terms of join and fmap, too.
09:44:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:44:41 <earthy> after applying f to  [a,b] I have 3 monads, where previously I had just 2
09:44:56 <earthy> s/monads/monadic values/
09:45:05 <earthy> however, having lots of monadic values usually isn't all that interesting
09:45:12 <jsnx> well, okay
09:45:20 <earthy> for the only things you can do with monads is combine them into new monads
09:45:46 <earthy> however, for many monads, e.g. State or Writer or Cont, you have a 'run' or 'eval' function
09:45:55 <jsnx> when you combine them, though, their states are no longer independent, right?
09:46:11 <desegnis> jsnx, if you write 4 + 5, you have three numbers: 4, 5, and 9. Similarly, if you combine two actions by means of (>>=), you then have three actions in your program
09:46:11 <earthy> jsnx: exactly. the states are threaded
09:46:31 <jsnx> desegnis: thanks!
09:46:56 <earthy> jsnx: however, what exactly happens is subject to the interpretation given to the monad by the 'run' or 'eval' function
09:47:15 <jsnx> let's return to the IO monad, for a second
09:47:17 <earthy> so evalState allows you to specify a monadic value and an initial state and 'evaluate' the monad in that state.
09:47:21 <b_jonas> (haskell is not a bloody language, garbage-collected values don't die, only retire)
09:47:25 <ndm> dcoutts, pick a #channel
09:47:39 <jsnx> afk
09:47:41 <ndm> (this one is a bit too crowded to discuss that while writing a paper in the background)
09:47:55 <dcoutts> ndm: #haskell-overflow
09:48:49 <jsnx> so, since IO does not have a 'run', the only monads that get run are
09:48:54 <jsnx> a) those that are in main
09:49:06 <jsnx> b) those that are in monads that are in main
09:49:09 <jsnx> c)
09:49:19 <shachaf> jsnx: IO has run, but only the compiler can use it, and it only uses it for main.
09:49:21 <jsnx>  those that are in monads that are in monads ...
09:49:24 <shachaf> jsnx: (In Haskell 98).
09:49:28 <jsnx> shachaf: right
09:49:29 <earthy> the only monad that gets run is the monad that is in 'main'
09:49:38 <desegnis> jsnx, note that you run an action/computation/monadic value (that's all the same), not a monad
09:49:42 <earthy> it may have been combined from any number of IO monadic values.
09:50:01 <earthy> so yea, I think you understand now
09:50:05 <jsnx> desegnis: what is the difference between a monad and a monadic value?
09:50:15 <shachaf> jsnx: A monad is a type.
09:50:16 <jsnx> earthy: right, that's what i mean
09:50:21 <shachaf> IO is a monad.
09:50:31 <jsnx> IO is a type?
09:50:31 <shachaf> A value :: IO a is a monadic value.
09:50:36 <desegnis> a monad is e. g. IO, State, ...; a monadic value is e. g. return 2; print "Hi!"; ...
09:50:39 <shachaf> @ki IO
09:50:42 <lambdabot> * -> *
09:50:53 <jsnx> shachaf: so a monad is type of types, right?
09:51:01 <shachaf> jsnx: No, just a type.
09:51:08 <paolino> anyone uses hxt and can help me opening NTree vaules ?
09:51:14 <shachaf> jsnx: (Which gets a type argument.)
09:51:15 <desegnis> jsnx, they call this a type constructor
09:51:18 <earthy> a type parameterized over other types
09:51:29 <desegnis> (or do they?)
09:51:43 <shachaf> jsnx: It's similar to Maybe.
09:51:46 <ski> they do
09:51:50 <shachaf> jsnx: x :: Maybe a; x :: IO a
09:51:55 <b_jonas> desegnis: they have some even more stupid name than that I think
09:52:52 <paolino> I tried loading the Hxt TypeDef module but it doesn't exports constructors ...
09:52:59 <desegnis> if it shall be scary, I propose higher-kinded type ;)
09:53:59 <shachaf> jsnx: Perhaps this will be easier if you work with other monads (e.g., Maybe, [], Reader, State) first.
09:57:45 <moonlite_> shachaf: i believe the Maybe, State and Reader monads are much easier to grasp than the List monad btw.
09:58:03 <shachaf> moonlite_: Why?
09:58:19 <shachaf> moonlite_: You have fmap, return, and join.
09:58:25 <shachaf> moonlite_: Those are all simple.
09:59:10 <Vq^> Maybe is probably the simplest
09:59:13 <byorgey> State is definitely harder to grasp if you actually want to understand the implementation.
09:59:16 <ddarius> Identity!
09:59:18 <shachaf> Vq^: How about Identity?
09:59:19 <moonlite_> shachaf: i always have to think hard to understand the semantics of a List-monad function.
09:59:47 <ddarius> What moonlite_ is saying is that he finds the "non-determinism" represented by the list monad harder to understand.
10:00:02 <moonlite_> ddarius: perhaps
10:00:09 <shachaf> Sure, you can do complex things with it.
10:00:13 * desegnis agrees with moonlite_. Do notation in the list monad is definitely harder then in the reader monad
10:00:28 <shachaf> But understanding the basic idea isn't that much of a problem.
10:00:38 <shachaf> desegnis: List comprehensions are a problem?
10:00:39 <ski> 'DelCont' ftw !
10:01:25 <moonlite_> shachaf: no the implementation is simple. However i always have to desugar the do-notation to concats etc to understand what the function does
10:01:28 <desegnis> shachaf, it's the sequencing. In a list comprehension you do not see any sequencing
10:01:46 <shachaf> desegnis: Sure you do.
10:01:54 <Vq^> shachaf: ok, that might be simpler :)
10:02:06 <lament> the do notation is such a perfect example of why lisp is good
10:02:06 <ski> > [(x,y) | x <- [0,3,6,9] , y <- [1,5,8] , x < y]
10:02:11 <lambdabot>  [(0,1),(0,5),(0,8),(3,5),(3,8),(6,8)]
10:02:25 <shachaf> > [(x,y) | x <- [1,2], y <- [3,4]]
10:02:26 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
10:02:27 <shachaf> > [(x,y) | y <- [3,4], x <- [1,2]]
10:02:27 <ski> > do x <- [0,3,6,9]; y <- [1,5,8]; guard (x < y); return (x,y)
10:02:30 <lambdabot>  [(1,3),(2,3),(1,4),(2,4)]
10:02:30 <lambdabot>  [(0,1),(0,5),(0,8),(3,5),(3,8),(6,8)]
10:02:36 <sjanssen> lament: huh? how so?
10:03:14 <ski> lament : do you refer to macros ?
10:03:35 <lament> yeah
10:04:11 <dolio> Eh.
10:04:30 <lament> do feels like a macro
10:04:47 <shachaf> LISP has sequencing too!
10:05:03 <desegnis> shachaf, right... well; they all talk about monads being good for sequencing, and it made me think about “do this, then do that”; while a list does not do anything. it's just a matter of using the same interface (do notation) for very different things, and the list monad has a “different” feel.
10:06:35 <dolio> desegnis: It's 'do { nondeterministically choose x from [0,3,6,9] ; nondeterministically choose y from [1,5,8] ; ... }'
10:06:39 <ddarius> lament: That's because it is.
10:07:06 <lament> ddarius: thought so :)
10:08:12 <jsnx> why is it 'nondetermnistically choose' -- doesn't it go in order?
10:08:35 <ddarius> jsnx: Conceptually.
10:08:49 <ddarius> Lists are actually a pretty crappy implementation of non-determinism.
10:09:08 <dolio> In practice it does a sort of backtracking search, returning a list of successes.
10:10:20 <jsnx> okay, so i now have another question about the monads
10:10:52 <ski> 'x <- xs' nondeterministically selects an element 'x' of 'xs' .. the whole total will be a list containing all the possible results, for all possible ways of the nondeterministic choices
10:10:53 <jsnx> previously, we saw that all the IO monadic values you specify are run by way of one top level value, main :: IO ()
10:11:07 <shachaf> desegnis: Do-notation for lists is almost like a loop.
10:11:17 <jsnx> so, far all intents and purposes, they share the same state
10:11:26 <jsnx> however, what about State monads?
10:11:44 <ddarius> do-notation for lists is almost exactly like list comprehensions.
10:11:51 <jsnx> I could have more than one of them and run them independent of one another
10:11:53 <ski> @type Control.Monad.State.runState
10:12:01 <lambdabot> forall s a. State s a -> s -> (a, s)
10:12:02 <shachaf> "For each element x of [1,2,3]: { For each element y of [4,5,6]: { Add (x,y) to the list of what we return }}
10:12:02 <Syzygy-> foreach f xs === do { x <- xs; return f x }
10:12:05 <ski> jsnx : indede
10:12:06 <shachaf> s/$/"/
10:12:14 <shachaf> ddarius: That's what I said, before.
10:12:20 <desegnis> shachaf, dolio; well, I understand the general behaviour of the list monad, which is enough for me, actually ;)
10:13:37 <desegnis> shachaf, ah, a loop in this sense
10:13:54 <jsnx> so, not all State monadic values share the same state; they only share state if i combine them
10:13:56 <shachaf> jsnx: A State value is just a function that gets some state and returns some type and a new state.
10:14:03 <shachaf> jsnx: s -> (a,s)
10:14:09 <jsnx> shachaf: right
10:14:29 <shachaf> jsnx: That's all it does.
10:14:40 <ndm> @tell cdsmith thanks for the paper changes, i've credited you at the bottom
10:14:40 <lambdabot> Consider it noted.
10:14:42 <ski> s/State value/State monad action/
10:14:57 <jsnx> State action == ok  ?
10:14:59 <shachaf> ski: OK.
10:15:03 <ddarius> ndm: Paper?
10:15:07 <ski> jsnx : yes
10:15:08 <Vq^> @src Maybe (>>=)
10:15:08 <lambdabot> (Just x) >>= k      = k x
10:15:08 <lambdabot> Nothing  >>= _      = Nothing
10:15:24 <mux> > execState (modify (+1)) 1
10:15:24 <ndm> ddarius: "deriving generic functions by example", which gets submitted in 5 hours time
10:15:25 <lambdabot>  2
10:15:58 <ski> > ()
10:16:00 <lambdabot>  ()
10:16:01 <ski> er
10:16:06 <jsnx> do 'compose' actions or 'combine' them?
10:16:14 <jsnx> > '()
10:16:14 <lambdabot>  Improperly terminated character constant
10:16:19 <jsnx> lolz
10:16:19 <mux> > execState (modify (+1) >> get >>= \x -> put (x * 2)) 1
10:16:20 <shachaf> jsnx: Either, I think.
10:16:20 <lambdabot>  4
10:16:25 <ndm> (he read it in the pub at anglohaskell)
10:16:28 <ski> jsnx : whichever
10:16:35 <shachaf> > join [[1,2],[3,4]] -- More "combine"?
10:16:36 <lambdabot>  [1,2,3,4]
10:16:57 <ddarius> Damn you and you people on the wrong side of the world.
10:17:22 <SamB> why does http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType have cheap pre-colored Haskell code in it?
10:17:25 <lambdabot> Title: Commentary/Compiler/CmmType - GHC - Trac, http://tinyurl.com/3xlar9
10:17:32 <ski> > do {modify (+1); x <- get; put (x * 2); return (x*x)} `runState` 1
10:17:33 <lambdabot>  (4,4)
10:17:36 <ndm> ddarius: he's from america, came over specially for anglohaskell
10:17:43 <Vq^> > join (Just Nothing)
10:17:45 <lambdabot>  Nothing
10:17:45 <ski> > do {modify (+1); x <- get; put (x * 2); return (x*x*x)} `runState` 1
10:17:46 <lambdabot>  (8,4)
10:17:47 <ddarius> Anyway, back to killing babies.
10:17:58 <jsnx> thanks everyone
10:18:18 <ski> ddarius : australian ones ?
10:18:32 <ndm> anyone can set up their own <Country>Haskell conference
10:18:35 <shachaf> jsnx: Try reimplementing some monads.
10:18:43 <shachaf> jsnx: E.g., State.
10:18:44 <ndm> AngloHaskell really wasn't as hard as i had thought it would be
10:18:54 <shachaf> jsnx: It might make more sense afterwards.
10:19:12 <b_jonas> <State>Haskell?
10:19:48 <ndm> we had people come from america and italy
10:19:56 <ndm> but yes, <State>Haskell might be more feasible
10:20:46 <mrd> StateT Haskell?
10:23:01 <lament> I'm writing a program that processes audio input in real time
10:23:17 <paolino> Anyone can help with hxt  ?
10:23:21 <lament> I have a C library that calls a callback function every very often with a fresh buffer of audio data
10:23:37 <lament> is it feasible to connect this to haskell in some fashion?
10:24:35 <Lemmih> lament: Yes.
10:24:39 <lament> The library says that the callback function has to be very fast and shouldn't even use things like printf.
10:24:42 <lament> and certainly not malloc.
10:24:57 <Lemmih> That might be more tricky.
10:25:10 <ClaudiusMaximus> lament: what happens if it is too slow?
10:25:18 <lament> i'm not sure
10:25:35 <lament> they just warn against it
10:26:07 <lament> they say that lots of different stuff could be done to speed up the callback on different platforms (the library runs on anything); eg it may or may not be running in a separate thread
10:26:17 <ClaudiusMaximus> lament: try it and see, i guess, the worst that could happen is locking up your machine with a 100% cpu usage realtime process, i'd guess
10:26:48 <lament> So what should I do, have that callback directly call a haskell function?
10:27:25 <lament> or is there no interface for that
10:27:55 <lament> oh, there is.
10:28:07 <ClaudiusMaximus> lament: yes, you can use "foreign export" or 'foreign import "wrapper"' to do that (i forget the syntax, check the FFI addendum)
10:28:26 <jsnx> shachaf: will do!
10:28:37 <lament> thanks
10:29:01 <lament> i bet in the end i'll just have to use c for everything
10:29:07 <lament> but one can dream :)
10:29:37 <paolino> is hxt not popular and I should switch to HaXml ?
10:29:46 <mrd> whats wrong with hxt
10:30:00 <ClaudiusMaximus> lament: which library is it, out of curiosity?  i might add DSP functionality to my Pure-data <-> Haskell bridge (if i don't get even more disillusioned with Pd before then...)
10:30:12 <mrd> paolino: what's the question? sorry, didn't see you ask earlier
10:30:14 <lament> ClaudiusMaximus: PortAudio
10:30:40 <paolino> mrd I get [XmlTree] out of a runX
10:30:58 <mrd> sure
10:31:02 <ClaudiusMaximus> lament: ah, i see - Pd uses PortAudio (optionally), but i've never used it myself
10:31:08 <lament> what's Pd?
10:31:14 <paolino> I know the exact structure, how I take that a part ?
10:31:19 <lament> iirc Audacity uses portaudio
10:31:31 <ClaudiusMaximus> lament: a visual programming environment primarily for audio processing ( http://puredata.info )
10:31:32 <lambdabot> Title: About Pure Data &mdash; PD Community Site
10:31:36 <lament> oh
10:31:49 <lament> portaudio is very simple and basic and easy to use
10:31:53 <mrd> paolino: inside the runX you take it apart and return something new
10:31:55 <lament> so that's nice
10:31:58 <mrd> paolino: if you want some examples ...
10:32:04 <mrd> @wiki HXT/Practical/
10:32:04 <lambdabot> http://www.haskell.org/haskellwiki/HXT/Practical/
10:32:20 <lament> i had a program printing out volume from the microphone in real time in like 10 minutes :)
10:33:46 <mrd> @wiki HXT/Practical
10:33:46 <lambdabot> http://www.haskell.org/haskellwiki/HXT/Practical
10:33:50 <mrd> sorry, no slash
10:33:59 <paolino> ok
10:34:45 <mrd> basically, you may have to use something like getText or getAttrValue to pull the strings out of the trees.  i don't know exactly what you're doing.
10:35:08 <paolino> mrd my last arrow is multi something
10:35:37 <mrd> yea so that's just going to give you matching XmlTrees
10:36:07 <mrd> then you need to do something to them
10:36:17 <paolino> after multi ?
10:36:24 <mrd> multi (isElem >>> hasName "title") >>> getChildren >>> getText  -- get title text
10:36:40 <mux> am I the only one who finds HXT messy?
10:36:58 <mrd> specifically?
10:38:02 <paolino> mrd , I see, I have big problems  in understanding arrows flow :/
10:38:39 <paolino> >>> is a concatMap ?
10:38:41 <mrd> no
10:39:41 <mux> mrd: API-wise
10:39:44 <mrd> just think of XML coming in one end, passing through your filters, and something transformed emerging out the other end
10:39:46 <mux> many many many arrows
10:39:57 <mrd> mux: so?
10:40:18 <mux> well I find the API a bit messy, too much different symbols to know/lookup/whatever
10:40:45 <mrd> it's a combinator library
10:40:57 <mrd> you're supposed to build up your own combinators
10:41:06 <mux> well yes it is, and I can think of much smaller combinator libraries
10:41:13 <mux> like Parsec
10:42:09 <mux> the HXT docs define a new arrow (ArrowIf, ArrowIO) every two lines
10:42:26 <mrd> I really don't pay any attention to those
10:42:32 <mrd> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/Text-XML-HXT-Arrow-XmlArrow.html
10:42:35 <lambdabot> http://tinyurl.com/2ouwnn
10:42:35 <mux> maybe I shouldn't as well
10:42:51 <mux> anyways, gotta leave now, bye
10:43:59 <lament> hm, i just noticed how ugly the word 'foreign' looks :)
10:44:10 <lament> it ends in eign!
10:47:22 <b_jonas> it's not the only English word that looks ugly
10:48:06 <astrolabe> It's not the only word that end in eign
10:48:29 <lament> it sometimes happens that i notice how some word i never paid much attention to is actually very odd.
10:48:52 <lament> if you look at it on a letter-by-letter level...
10:49:01 <astrolabe> Yeah.  That can happen with a lot (all?) words if you repeat them enough.
10:49:10 <lament> especially in English :)
10:49:18 <ed1t> word like astrolabe
10:49:23 <astrolabe> :)
10:50:38 <ski> it looks even weirder in $NATIVE_LANG
10:50:49 <shachaf> When I look at a word enough, I suddenly can't read it any more.
10:50:56 <SamB> hehe
10:50:57 <shachaf> Only see the sequence of letters.
10:51:30 <SamB> I sometimes have a verbal analogue of that...
10:51:31 <lament> shachaf: I suppose in Hebrew that would be common :)
10:51:52 <shachaf> lament: In English too.
10:52:18 <lament> yeah, since in both hebrew and english the word is written nothing like it's pronounced
10:52:22 <jsnx> lament: reign, as in "a king's reign"
10:52:38 <lament> in spanish this never happened to me, as spanish is mostly phonetic...
10:52:50 <jsnx> well, english has had a rough life.
10:52:56 <lament> jsnx: 'gn' just looks very odd
10:53:24 <lament> except in GNU and GNOME where you're supposed to pronounce both letters
10:53:30 <jsnx> lament: granted -- as does 'kn' in 'knight' (same principle)
10:53:45 <b_jonas> lament: exactly, languages with phonetic writings like french have much fewer weird-looking words
10:54:32 <jsnx> b_jonas: english has, i think 45 phonemese (sounds) and 1100 ways to spell them
10:54:34 <lament> b_jonas: as somebody who doesn't know any french, i must say that's completely untrue. All french words look weird. "chateau" for "shato"?? :)
10:54:54 <jsnx> lament: but french is consistent, whereas english is not
10:54:58 <lament> hehe
10:55:00 <lament> of coures
10:55:04 <lament> of course :)
10:55:13 <b_jonas> lament: sure, but if you don't know a language of course it looks stupid
10:55:19 <jsnx> english is the bastard child of german, latin and french
10:55:21 <b_jonas> for example, chinese text looks stupid to me
10:55:35 <jsnx> b_jonas: it's hard to spell. too!
10:55:48 <sfultong> I just got the idea of arrows, and now I don't know how I lived without them
10:56:07 <jsnx> actually, chinese and english are more alike than we give them credit for...
10:56:09 <lament> languages with regular pronunciation kick ass.
10:56:35 <jsnx> since the pronounciation is so irregular in english, you basically have to remember the words as sysmbols
10:56:59 <shachaf> lament: Hebrew is not as bad as English, in many cases.
10:57:16 <jsnx> sfultong: what's the idea with arrows?
10:57:18 <allbery_b> ...as long as you can memorize how the unwritten vowels work...
10:57:27 <lament> shachaf: ani yodea :)
10:57:36 <jsnx> allbery_b: in hebrew?
10:57:45 <allbery_b> yeh
10:57:48 <kowey> french has phonetic writing?
10:57:49 <cwoodall> I have 2 haskell questions. 1)what tutorial should i follow (I am using yaht atm). I know python, ruby, php, abit of java, some C a tad of lisp an
10:58:07 <lament> kowey: french has regular pronunciation rules. (Allegedly. I don't know french)
10:58:08 <allbery_b> isn't there a metatutorial on the wiki?
10:58:12 <jsnx> @google write yourself a scheme in 48 hours
10:58:14 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
10:58:14 <lambdabot> Title: Write Yourself a Scheme in 48 hours
10:58:20 <cwoodall> ok thanks
10:58:23 <allbery_b> @google haskell metatutorial
10:58:25 <lambdabot> http://www.haskell.org/haskellwiki/MetaTutorial
10:58:25 <lambdabot> Title: Meta-tutorial - HaskellWiki
10:58:32 <lament> cwoodall: YaHT is nice, until you get to monads, then ask for further instructions.
10:58:36 <b_jonas> kowey: yes, almost
10:58:39 <allbery_b> spanish is very regular
10:58:53 <jsnx> cwoodall: scheme in 48 is a very practice oriented tutorial
10:59:03 * kowey struggles with liasons (euh... in French)
10:59:13 <kowey> but I guess that's nothing to do with the writing
10:59:19 <cwoodall> lament: thanks
10:59:23 <cwoodall> jsnx: I might check it out
10:59:26 <shachaf> There's the wikibook.
10:59:31 <shachaf> Is that usable right now?
10:59:42 <allbery_b> up to a point
10:59:42 <jsnx> shachaf: for 'scheme in 48' ?
10:59:43 <lament> i think so, but some parts are unwritten
10:59:45 <cwoodall> idk ive just been using yet another haskell tutorial
10:59:58 <lament> following two tutorials at once is probably counterproductive
10:59:59 <shachaf> jsnx: For learning Haskell.
11:00:06 <lament> and yaht is recommended by a bunch of people
11:00:34 * shachaf thought the wikibook's explanation of monads was confusing.
11:00:40 <shachaf> And YAHT's, too.
11:00:42 <cwoodall> also any reason to use something like: factorial 1 = 1 instead of a if then else statement?
11:00:56 <kowey> shachaf: it's being completely rewritten
11:00:58 <shachaf> cwoodall: Isn't it easier to read?
11:01:00 <Khoth> It looks prettier
11:01:16 <thoughtpolice> shachaf: there're some parts missing from the wikibook,
11:01:20 <thoughtpolice> but you can still get a bit out of it
11:01:20 <shachaf> kowey: Yes, so I heard.
11:01:21 <cwoodall> shachaf: i guess. He i, kinda knew to functional programming
11:01:50 <lament> cwoodall: You can write the factorial function in a bunch of different ways of varying prettiness. All are mostly equivalent
11:01:51 <jsnx> cwoodall: pattern matching is faster than if-then-else
11:02:01 <shachaf> cwoodall: You're just saying: The factorial of 1 is 1.
11:02:04 <thoughtpolice> it's got stuff on category theory, zippers, GADTs, monads and a little on arrows. everything going from 'novice' to monads though is 'stock' stuff though
11:02:04 <jsnx> at least, in ML it is
11:02:35 <lament> cwoodall: and yeah, like shachaf said, the factorial of 1 is 1 -- this way, it's closer to the mathematical definition
11:02:49 <lament> math doesn't use "if/then/else" very much :)
11:02:59 <cwoodall> yeah i know waht the statement means I was able to figure it out. I was jsut wondering if it was a technical or synatic sugar
11:02:59 <jsnx> cwoodall: less indentation, too ;)
11:03:28 <popcount> lament, it uses "suppose"
11:03:49 <lament> popcount: not very often.
11:03:53 <cwoodall> lol
11:03:54 <oerjan> cwoodall: both factorial 1 = 1 and if then else are syntactic sugar for case
11:04:01 <popcount> lament, or assume
11:04:24 <cwoodall> oerjan: well so everythign is syntactic sugar for soemthign else (almost)
11:04:30 <phobes> jsnx:  why would factorial be slower in ML if written with an if-else?
11:04:37 <popcount> lament, if it contains neither of those it cannot be any interesting proof.
11:04:38 <lament> popcount: i don't remember seeing any assumes in the definitions of anything
11:04:45 <cwoodall> oerjan: I was jsut wondering if their wasanother reason
11:04:50 <lament> this is the _definition_ of factorial, not a proof :)
11:05:23 <phobes> surely any reasonable compiler produces the same result?
11:05:34 <popcount> lament, the mathematics you speak of is non-constructive.
11:06:11 <oerjan> cwoodall: haskell supports two different styles of definition, expression style (if-then-else, case, let) and declaration style (fact 1 = 1, guards, where)
11:06:50 <cwoodall> oerjan: ok I didnt get to far in yaht yet so I am really working at a basic level lol. Its been fun though
11:07:14 <shachaf> oerjan: let is different from where?
11:07:34 <liyang2> fact 1 = 1 pattern matching is different from case?
11:07:38 <oerjan> shachaf: where adds to a declaration, let to an expression
11:07:58 <shachaf> Hmm.
11:08:13 <oerjan> (where can also be used in case, and let in do)
11:09:08 <sfultong> I think I'm going to try and give up (if-then-else, case, let, pattern matching (ok, I could use that for convenience, but it would be fun to try going without it for a while), guards and where)
11:09:09 <oerjan> of course everything can be expressed in either style
11:10:23 <oerjan> liyang: fact 1 = 1 is syntactic sugar for fact n = case n of 1 -> 1
11:11:04 <oerjan> (if there is more than one equation you combine them into one case expression
11:11:13 <lament> it's probably counterproductive to think of patterns as sugar for case statements.
11:11:36 <sfultong> I wonder if haskell would be easier to learn if it were pared down... if a lot of the syntactic sugar was taken away
11:11:38 <shachaf> oerjan: case, with numbers, translates into (==), right?
11:11:59 <oerjan> shachaf: right
11:12:05 <thoughtpolice> sfultong: you mean like core? iirc there're only about 4 constructs in core.
11:12:19 <thoughtpolice> everything else is sugar
11:12:26 <sfultong> hmm... what are the 4 constructs?
11:12:30 <Khoth> None of the problems I've had learning can really be attributed to having lots of ways of defining things
11:12:40 <thoughtpolice> i can't quite remember, I know lambda is one of them
11:12:45 <thoughtpolice> sfultong: just a sec...
11:13:45 <sfultong> khoth: less tools sometimes make you more clever
11:14:05 <liyang> case is one of them (hence my earlier comment.)
11:14:33 <Khoth> Yeah, I feel cleverer every time I write foo >>= \x -> bar
11:15:19 <liyang> I imagine those four would be case, let, abstraction and application.
11:15:35 <thoughtpolice> sfultong: core has let, case, lambda and application
11:15:45 <thoughtpolice> damn. beat me to it. :(
11:15:45 <opqdonut> you won't feel uber-clever until you write: join $ fmap (\x -> bar) foo
11:15:49 <sfultong> hehe, thanks
11:16:03 <liyang> thoughtpolice: the trick is to speak without thinking. :)
11:16:09 <lament> what, uber-clever and pointful code in one sentence? :)
11:16:14 <oerjan> opqdonut: you mean join $ fmap $ const bar
11:16:31 <sfultong> there we are
11:16:33 <opqdonut> wel i thought that bar is an expression in x :)
11:16:34 <shachaf> oerjan: join . fmap (const bar) $ foo -- ?
11:16:35 <thoughtpolice> liyang: i'll keep it in mind. just remember: say what's on your mind and there can be no negative consequences whatsoever. :p
11:16:38 <oerjan> oh, missed a foo
11:17:08 <oerjan> opqdonut: true uber-cleverness requires pointless style
11:17:20 <opqdonut> yeah, that is true
11:17:23 <hkBst> can't let be implemented by lambda?
11:17:33 <shachaf> hkBst: For recursion?
11:17:37 <Khoth> @pl foo >>= \x -> bar
11:17:38 <lambdabot> foo >> bar
11:17:45 <opqdonut> hkBst: yeah not recursive let
11:17:51 <hkBst> shachaf: no, I meant for the core
11:17:53 <oerjan> hkBst: the typing rules are different
11:17:53 <Khoth> @pl join $ fmap (\x -> bar) foo
11:17:54 <lambdabot> foo >> bar
11:18:05 <shachaf> hkBst: You need let (or fix) for recursion.
11:18:10 * liyang waves at Khoth 
11:18:10 <oerjan> let is polymorphic, lambda is not
11:18:34 * Khoth waves back
11:18:42 <hkBst> oh right, hehe :)
11:19:10 <hkBst> oerjan: that I don't understand
11:20:16 <thoughtpolice> is there any place on the wiki (or trac) that outlines what'll be coming up in 6.8?
11:20:24 <hkBst> :t \
11:20:26 <lambdabot> parse error (possibly incorrect indentation)
11:20:35 <hkBst> :t let
11:20:37 <lambdabot> <command line>:
11:20:37 <lambdabot>     Could not find module `L':
11:20:38 <Botje> thoughtpolice: Magic Lambda Faeries.
11:20:52 <thoughtpolice> Botje: I thought those were universal in every release?
11:20:57 <thoughtpolice> at least that's what I assumed was powering ghc :)
11:21:53 <oerjan> hkBst: if lambdas can have arbitrary polymorphic arguments, type inference is undecidable.  this is solved by giving the polymorphic case a different syntax
11:22:14 <Botje> thoughtpolice: 20% more faeries then? :)
11:22:25 <sorear> @go Type Inference and Type Checking for System F are Equivalent and Undecidable
11:22:28 <lambdabot> http://citeseer.ist.psu.edu/wells98typability.html
11:22:28 <lambdabot> Title: Typability and Type Checking in System F Are Equivalent and Undecidable - Wells  ...
11:22:31 <Botje> << time to write a paper
11:22:41 <thoughtpolice> Botje: brilliant!
11:23:15 <sorear> @users
11:23:15 <lambdabot> Maximum users seen in #haskell: 382, currently: 381 (99.7%), active: 27 (7.1%)
11:31:18 <shapr> sorear: It's still growing!
11:31:49 <Nafai> Yay for growth!
11:34:17 <shapr> @users
11:34:17 <lambdabot> Maximum users seen in #haskell: 382, currently: 381 (99.7%), active: 20 (5.2%)
11:41:56 <Nafai> Hey shapr!
11:42:43 <shapr> hiya!
11:51:41 <Nucleo_> How can I convert a char into a Word8?
11:52:35 <monochrom> fromIntegral . fromEnum
11:54:09 <Nucleo_> thank you
11:56:58 <sorear> eek, there are realworlds in my fib function
11:57:07 <opqdonut> how come?
11:57:13 <sorear> no clue
11:57:24 * sorear greps for realWorldzh in the ghc-sources
12:00:59 <sorear> heh, there's a file "Simon-log" in ghc
12:02:17 <puusorsa> has anyone had any luck with hoc?
12:02:42 <byorgey> sorear: heh, what's in it?
12:02:51 <puusorsa> possibly i'm just compiling it wrong or something
12:03:33 <chessguy_work> is it the log of the Simons' discussions about how to take over the world using haskell?
12:04:16 <Botje> chessguy_work: we use Spears, surely?
12:04:29 <chessguy_work> Brittney?
12:04:49 <sorear> byorgey: Int arithmetic
12:04:57 <ski> Shake Spears !
12:05:11 <Botje> with enough antimatter, anyone can be a weapon!
12:05:18 <byorgey> sorear: !?
12:05:44 <sorear> gsfib' n | n == 0 = (0,1) | odd  n = case gsfib' (n-1)       of (a,b) -> (a+b, a) | even n = case gsfib' (n `div` 2) of (a,b) -> (a*(a+b+b), a*a + b*b)
12:06:14 <ski> realWorld# :: RealWorld#  -- sorear, iirc
12:06:22 <sorear> ski: I know
12:06:33 <sorear> ski: I want to know *why* though
12:06:41 <sorear> ski: I have no IO in my code
12:07:17 <ski> no 'main' ?
12:07:51 <byorgey> The nth Fibonacci number in O(lg n) time using only int arithmetic, hurrah! =)
12:08:46 <kaol> I wish there was such a thing as PL/Haskell. Using postgresql would be more fun with that. (So I should implement it...)
12:09:00 <hpaste>  Evir pasted "how is this supposed to work without -fglasgow-exts?" at http://hpaste.org/2237
12:09:38 <Evir_Drevo> Can anybody tell me? It's an example from YAHT.
12:10:21 <ski> PL/I
12:10:54 <monochrom> I do not believe in "stored procedures".
12:11:03 <chessguy_work> Evir_Drevo, not if you don't ask the question we can't
12:11:12 <opqdonut> Evir_Drevo: what part of it?
12:23:13 <opqdonut> looks totally 98 to me
12:23:13 <byorgey> chessguy_work: the question is the hpaste, I think
12:23:13 <Evir_Drevo> Right.
12:23:13 <chessguy_work> ah, i missed that
12:23:13 <byorgey> opqdonut: I think H98 doesn't support partially applied types as instances of type classes, or something like that
12:23:13 <opqdonut> ehh, i'd think it does
12:23:13 <byorgey> I'm not clear on the exact details, but I tried it and sure enough, it gives an error when I try loading it into ghci
12:23:13 <hpaste>  Evir annotated "how is this supposed to work without -fglasgow-exts?" with "(no title)" at http://hpaste.org/2237#a1
12:23:13 <opqdonut> but dunno
12:23:13 <chessguy_work> hmm, shouldn't Right x >>= f = Right (f x)?
12:23:13 <Evir_Drevo> I have attached the compiler error message.
12:23:13 <opqdonut> ah, how about "(Either String a)"
12:23:13 <byorgey> chessguy_work: no
12:23:13 <byorgey> chessguy_work: f should return a value of type (m a)
12:23:13 <Evir_Drevo> opqdonut: No, instances for Monad require Kind * -> *
12:23:13 <Evir_Drevo> Either String a is kind *
12:23:13 <opqdonut> oh okay
12:23:13 <monochrom> Change "String" to variable such as "s"
12:23:13 <byorgey> Evir_Drevo: you could probably do it with a newtype?
12:23:13 <Nucleo_> I'm getting a memory allocation failed (requested 2097152 bytes), when I know there's more ram available.
12:23:13 <ihope> I know Either String can be a monad.
12:23:13 <Nucleo_> top tells me that the executable crashes out after growing to ~2.4 gigs, when the system has 8 gigs of ram available....
12:23:13 <Evir_Drevo> byorgey: Just taking Either and String from the Prelude... :-/
12:23:13 <monochrom> OK, you want fail s = Left s? That's going to be tough.
12:23:13 <byorgey> Evir_Drevo: it's strange, I know.
12:23:13 <Evir_Drevo> YAHT should mention that you need -fglasgow-exts for this to work, then. :-)
12:23:13 <ski> A
12:23:13 <monochrom> H98 does not allow things like "instance XXX (Maybe Int)". At best you can have "instance XXX (Maybe a)".
12:23:13 <ski> @src Maybe (>>=)
12:23:13 <lambdabot> (Just x) >>= k      = k x
12:23:13 <lambdabot> Nothing  >>= _      = Nothing
12:23:13 <ski> @src Either (>>=)
12:23:13 <lambdabot> Left  l >>= _ = Left l
12:23:13 <lambdabot> Right r >>= k = k r
12:23:13 <Evir_Drevo> It actually says "Your instance declaration should begin: instance Monad (Either String) where", ...
12:23:13 <monochrom> Similarly you can have "instance Monad (Either s)" but not "instance Monad (Either Int)" or ...
12:23:13 <Evir_Drevo> Ok. But this won't work since "fail s = Left s". :-)
12:23:13 <Tchakkazulu> ?kind Either String
12:23:13 <lambdabot> * -> *
12:23:13 <monochrom> "Either String" has the desired kind. But H98 wants fewer constants.
12:23:13 <ski> Tchakkazulu : impressive nick
12:23:13 <Tchakkazulu> ski: Thanks, it's unique everywhere I go.
12:23:13 <ski> 'fail' ought to be in a subclass of 'Monad'
12:23:13 <Evir_Drevo> I am just subclassing it.
12:23:13 <ski> i think you are probably making an *instance* of it
12:23:13 <Evir_Drevo> Oh ok.
12:23:13 <Evir_Drevo> But well, it works fine with -fglasgow-exts...
12:23:13 <monochrom> Nucleo_: OSes put hard limits on virtual address space for technical reasons.
12:23:13 <Nucleo_> monochrom: I think with ghci I've managed to consume like 4 gigs of real memory before?
12:23:13 <Nucleo_> (this is under OS X, for what it's worth)
12:23:13 <Khoth> Try running with +RTS -M4G
12:23:15 <Nucleo_> Will do. Thanks Khoth
12:23:34 <phobes> monochrom: Do you know why GHC doesn't allow "instance Monad (Either Int)", etc.?   Or, is there a name for this restriction I could search on?
12:23:46 <monochrom> GHC does. Haskell 98 doesn't.
12:23:58 <phobes> ya sorry
12:24:00 <phobes> Why not?
12:26:11 <monochrom> http://haskell.org/onlinereport/decls.html#sect4.3.2 contains that rule. I will not defend or critique it.
12:26:11 <lambdabot> Title: The Haskell 98 Report: Declarations
12:30:00 <Evir_Drevo> byorgey: Wrapping "Either String" up in a newtype works without glasgow-exts, yup.
12:30:43 <phobes> monochrom - thanks
12:33:08 <byorgey> Evir_Drevo: that's what I figured.  Kinda stupid to have to do that, though.  That newtype is going to infect any code that uses that monad.
12:33:08 <sjanssen> you can also write: "class IsString a where toString :: a -> String; class IsChar a where toString' :: [a] -> String; instance IsChar a => IsString [a] where toString = toString'; instance IsChar Char where isString' = id; instance IsString a => Monad (Either a) where fail s = Left (toString s)"
12:33:11 <hpaste>  Evir annotated "how is this supposed to work without -fglasgow-exts?" with "wrapped up, works without -fglasgow-exts" at http://hpaste.org/2237#a2
12:34:11 <cwoodall> he Haskell is so fun and weird (no offence). Its kind of like Lisp where it takes a while to get your mind around it
12:35:22 <monochrom> Don't get your mind around it. Easier to let it go around your mind.
12:35:40 <monochrom> Let it complete surround and devour your mind.
12:36:12 <Evir_Drevo> sjanssen: Yours works too, thanks.
12:36:25 <int-e> phobes: the History of Haskell paper provides some insight into the reason - when Haskell was designed, type classes were a rather fresh idea so the adoption was rather minimalistic.
12:49:54 <byorgey> cwoodall: yup, that's probably why most people here like it -- you can't help but learn things when using Haskell!
12:49:54 <sjanssen> Evir_Drevo: I actually got it right?
12:49:54 * sjanssen is amazed
12:49:54 <Evir_Drevo> sjanssen: Not fully.
12:49:54 <Evir_Drevo> :-)
12:49:54 <paolino> mrd, can I use map on mkelem ?
12:49:54 <desp> "Audrey Tang spent a month learning Haskell, and jumped from there to Pierce’s book Types and Programming Languages. The book suggests implementing a toy language as an exercise, so Tang picked Perl 6."
12:49:54 <desp> *chortle*
12:49:54 <sieni> desp: ^_^
12:49:54 <cwoodall> byorgey: yeah its fun
12:49:54 <mrd> paolino: where abouts?
12:49:54 <byorgey> cwoodall: glad you're enjoying it =)
12:49:54 <cwoodall> byorgey: ha thanks. Is Haskell good for writing languages? I am just wondering about this, because one day I want to write a language for fun
12:49:54 <b_jonas> cwoodall: ask on #perl6
12:49:54 <byorgey> cwoodall: yes, most definitely
12:49:54 <mrd> paolino: the parameters to mkelem are lists, right? so map returns a list, it matches, its ok
12:49:54 <desegnis> cwoodall, the “write yourself a scheme in 48 hours” tutorial may inspire you
12:49:54 <Evir_Drevo> sjanssen: No, it still doesn't, since fail needs a real String, not something of your class isString. :->
12:49:54 <paolino> mrd so if I have a list of addresses I use map to make anchors to href ?
12:49:54 <sjanssen> Evir_Drevo: ah yes, I did it backwards
12:49:54 <byorgey> cwoodall: b_jonas's comment refers to the fact that Haskell is being used to create an implementation of Perl 6
12:49:54 <mrd> paolino: so long as the result matches [a n XmlTree]
12:49:54 <paolino> and mkelem takes care of pushing them in the xml
12:49:54 <mrd> it'll be part of your output, yep
12:49:54 <pjd> kaol: that sounds like a great idea!
12:49:54 <hpaste>  sjanssen pasted "the IsString instance hack" at http://hpaste.org/2239
12:49:54 <Philippa> cwoodall: I stood up in front of an audience on friday and said Haskell's a great metalanguage
12:49:54 <sjanssen> Evir_Drevo: http://hpaste.org/2239 actually works
12:49:54 <shapr> @users
12:49:54 <lambdabot> Maximum users seen in #haskell: 385, currently: 383 (99.5%), active: 32 (8.4%)
12:49:54 <cwoodall> Cool. I just want to do it for the experience of making a language
12:49:54 <shapr> Good idea
12:49:55 <obsethryl> interesting stats
12:49:56 <Evir_Drevo> sjanssen: Right.
12:50:06 <shapr> obsethryl: This channel is growing.
12:50:15 <obsethryl> shapr: i bet
12:50:27 <shapr> int-e: I like the history of Haskell paper because I get mentioned in there, TWICE!
12:50:33 * shapr pretends to be cool.
12:50:36 <obsethryl> unlike other channels there is no "lame"ness factor in here despite the growth
12:50:49 <shapr> obsethryl: The lameness factors comes and goes.
12:50:50 <b_jonas> oh, I can do against that
12:50:55 <mrd> for example, when I come and go
12:51:08 <shapr> mrd: Heh, not you!
12:51:20 <shapr> obsethryl: But seriously, lamers do arrive, but they don't stay too long.
12:51:26 <Evir_Drevo> sjanssen: It's really a hack. :-) But nice to know how it can be done without -fglasgow-exts
12:51:33 <obsethryl> shapr: so i noticed
12:51:46 <shapr> The ops here have little tolerance for lameness.
12:51:50 <Toxaris> cwoodall: Haskell has some nice features for implementing languages. pattern matching helps with traversing ASTs, laziness helps with multi-pass stuff, an interpreted language automatically reuses the runtime system, easy parsing with Parsec, monadic style helps with modularization of different features of the implemented language, ...
12:52:00 <obsethryl> shapr: i come and go in here, still learning ,but it is low on priority for the time being :( nice language though :D
12:52:04 <b_jonas> shapr: really? why have I not been kicked then?
12:52:14 <shapr> b_jonas: You haven't been lame that I've seen.
12:52:50 <shapr> @protontorpedo
12:52:50 <lambdabot> so can haskell do what perl does but simpler?
12:52:55 <SamB> b_jonas: you know, like a troll or a typical visitor to ##c or something
12:52:58 <mrd> lol, I was going to do that
12:53:02 <mrd> @palomer
12:53:02 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
12:53:27 <cwoodall> Toxaris: cool. I might move over to the write yourdelf a scheme tutorial
12:53:29 <goalieca> ha
12:53:36 <obsethryl> SamB: lol the ##* was a hit ....
12:54:16 <SamB> note that I said visitor
12:54:23 <b_jonas> yeah
12:54:31 <b_jonas> the regulars on ##c are very good
12:54:37 <b_jonas> they answer fast and accurately
12:54:46 <obsethryl> SamB: i know, i also implied about visitors
12:54:50 <shapr> @keal
12:54:50 <lambdabot> bot defective
12:54:51 <shapr> @keal
12:54:51 <b_jonas> only the channels of ##c++ are better than them
12:54:51 <lambdabot> nsa try kill me numerous times
12:54:54 <shapr> @keal
12:54:54 <lambdabot> i need math friendly compiler to compile for jvm or flash
12:54:57 <sjanssen> @girl19
12:54:57 <lambdabot> is this a help channel for hackers-beginners?
12:55:08 <sjanssen> @protontorpedo
12:55:08 <lambdabot> I read somewhere that large systms get confusing and haskell ends up a s a bunch of functions
12:55:34 <obsethryl> b_jonas: that depends on who is around there more than other channels, so i noticed
12:55:35 <shapr> sjanssen: That guy still posts to the HAppS google group.
12:55:44 <shapr> I swear, protontorpedo needs Ritalin more than I do!
12:55:58 <sjanssen> :)
12:56:00 <sorear> shapr: How recently has there been a post to the HAppS group?
12:56:00 <ihope> @help protontorpedo
12:56:00 <lambdabot> protontorpedo is silly
12:56:34 <sorear> shapr: I tried to subscribe about a week ago, but google hates my browser
12:56:51 <shapr> sorear: four days ago
12:57:06 <shapr> I can't seem to subscribe either, dunno why.
12:57:07 <Excedrin> oh wow, I just realized what Keal meant in the "math friendly" quote
12:57:14 <shapr> Excedrin: what what?
12:57:26 <shapr> sorear: But I can read the group on gmane, so...
12:57:47 <Excedrin> he wants something that takes math expressions and produces flash or java applets, Latex -> gif style I suppose
12:58:39 <shapr> For a long time I thought keal was a random sentence generator. Because of that, I admired the bizarrity of the coder instead of banning him.
12:58:42 <b_jonas> the funny thing about J and array program langauges is that the usual program style it suggests is even less lazy than strict functional languages
12:58:55 <monochrom> A programming language is also a math expression.
12:58:58 <SamB> b_jonas: less lazy?
12:59:07 <Excedrin> more strictish
12:59:13 <b_jonas> yep
12:59:14 <SamB> shapr: hahahaha
12:59:26 <monochrom> A compiler takes such math expressions and produce more math expressions.
12:59:32 <mrd> more better
12:59:40 <SamB> you know, I almost think we could replace PoppaVic with one
12:59:52 <Winterstream> Ugh. This is such a sordid affair. I'm trying to interface with foreign code. My cabal file is set up to compile a C file and my Haskell files. The C file gets compiled, but during linking, I get errors - in particular, the linker claims not to be able to find the symbol in my C object file which I reference in my Haskell code
12:59:56 <monochrom> In particular, the identity map takes javascript math expressions and produces javascript math expressions. :)
13:00:05 <b_jonas> in that to find the first number in [1..10] for which the predicate p is true, you usually first evaluate map p [1..10] then find the first true value in it
13:00:19 <SamB> the tricky part would be for it to get insulted ;-)
13:00:21 <Excedrin> shapr: yea, there's a guy with a journal on Live Journal who's paranoid/delusional/schizophrenic or something (I'm not a psychologist), his journal is very entertaining in small doses
13:00:23 <b_jonas> you do operations on whole arrays even if you don't need all the results
13:00:41 <b_jonas> and even more importantly, you keep lots of large arrays in memory you wouldn't actually need if you did for loops
13:01:13 <SamB> most of the other things that would be needed would be talking about how everything is interpreters and translators in a confusing way...
13:01:23 <b_jonas> because instead of doing map (f . g) a, you do map f $ map g a
13:01:34 <b_jonas> even if the result of g is large and f shrinks it
13:01:57 <puusorsa> http://edward.oconnor.cx/2005/04/rms
13:01:59 <lambdabot> Title: The Most Excellent and Lamentable Tragedy of Richard Stallman &#8212; Edward O&# ...
13:02:15 <SamB> hmm, is there a publicly accessible spec for J?
13:02:23 <shapr> Excedrin: Yeah, *very small* doses.
13:03:04 <earthy> b_jonas: that's what fusion should fix, right?
13:04:11 * SamB was just thinking a J -> PArray compiler would be cool
13:04:21 <b_jonas> fusion?
13:04:24 <b_jonas> not lazyness?
13:04:31 <b_jonas> SamB: yes, moment
13:04:43 <b_jonas> at least a reference
13:04:49 <earthy> fusion would fuse the map f and the map g into map (f . g)
13:04:49 <SamB> b_jonas: fusion would keep the nice aspects of this deal and take the edge off some of the not-so-nice aspects
13:05:47 <b_jonas> SamB: http://www.jsoftware.com/help/dictionary/contents.htm
13:05:48 <lambdabot> Title: Dictionary Contents
13:06:17 <Japsu> RRRGH BETRAYAL! Data.Binary.encode for Binary a => [a] is not lazy! :<
13:06:37 <b_jonas> that's the specs for the core language itself, and it's included with the J download
13:07:02 <sjanssen> Japsu: yeah, it encodes the length of the list first
13:07:07 <Japsu> sjanssen: yeah
13:07:12 <Japsu> just figured that out
13:07:30 <b_jonas> there's a User Manual that documents the interpreter, the ide, and the module system that's implemented in J and is used by most of the library
13:07:54 <b_jonas> SamB: what's PArray
13:07:56 <Japsu> sjanssen: it spoiled my nice idea for encoding on-the-fly a message stream implemented as a lazy list of messages
13:08:31 <Japsu> now I have to implement my own TLV scheme
13:08:38 <int-e> Japsu: you could implement your own list type
13:08:41 <sjanssen> Japsu: you might use a new datatype, 'data Stream a = SCons a (Stream a)'
13:08:56 <b_jonas> you can't compile J perfectly to any language though because the language has some nasty dynamic aspects, but some heuristics would probably work for most cases
13:08:57 <sjanssen> that's actually better, if your streams don't end
13:08:57 <Japsu> Hmm... I might.
13:09:04 <Japsu> Well, they might end
13:09:09 <Japsu> so just add | EOS
13:09:12 <shapr> Could you use lazy bytestrings?
13:09:23 <Japsu> shapr: Err well, that's what Data.Binary.encode makes
13:09:27 <Japsu> lazy bytestrings
13:09:32 <b_jonas> what's PArray really?
13:09:35 <SamB> b_jonas: what nasty dynamic aspects?
13:09:40 <sjanssen> shapr: the problem is that encode for [a] is strict on the input
13:09:40 <Japsu> which I then put into a socket
13:09:52 <shapr> sjanssen: Couldn't it write the chunks directly?
13:10:01 <int-e> shapr: the problem is that 'put' for lists does  put l  = put (length l) >> mapM_ put l
13:10:01 <sjanssen> shapr: it calculates the length of the list before serializing
13:10:31 <b_jonas> SamB: the parser is working in runtime, so the same line can do completely different things every time it's ran in theory, though in practice you don't write code like that
13:10:41 <shapr> Hm, I see
13:10:46 <shapr> Doesn't sound to hard to change though.
13:11:17 <int-e> it's not hard to implement your own list type with a different Binary instance and just use that for serialization.
13:11:56 <Japsu> Yeah
13:12:26 <Japsu> We'll see. I'll either try that or just send (Length, VariableLengthMessage) pairs
13:12:44 <Japsu> (err not pairs on the Data.Binary level but anyway)
13:12:58 <int-e> (and include a flush after each element)
13:13:02 <Japsu> yeah
13:13:41 <Japsu> If anyone's interested, what I'm working on can be found at http://pajukanta.fi/darcs/channel... It's called Network.Channel, a networking library inspired by Control.Concurrent.Chan
13:15:10 <Japsu> So I want to be able to do "send channel ArbitraryObjectOfMyFancyMessageType" and let the library (with Data.Binary) handle the serialization... I'm also going to use Data.Derive to produce the Data.Binary instances myself, though I don't see any reason one couldn't do the instances himself.
13:15:46 <Japsu> I already have a Show/Read based implementation (Network.Channel.ASCII) and now I'm working on the Data.Binary based one (Network.Channel.Binary)
13:16:53 <Japsu> In a discussion on #lisp.fi it was suggested that Control.Concurrent.Chan would actually be used as the user API, then just do the socket IO in another thread... That's an interesting idea I might also implement in the future.
13:17:46 <Japsu> Anyway, it's getting late, so the hacking shall continue tomorrow
13:18:51 <jfredett> bah, what to do. :/
13:21:36 <Liquinn> hmm
13:25:26 <sorear> @users
13:25:26 <lambdabot> Maximum users seen in #haskell: 385, currently: 383 (99.5%), active: 24 (6.3%)
13:27:11 <byorgey> jfredett: ?
13:28:19 <ErrantEgo> who in here is a channel operator?
13:28:37 <sorear> ErrantEgo: /msg chanserv access #haskell list
13:29:14 <ErrantEgo> sorear: well, the reason I ask...we have a user in #freenode who is apparently "muted" in this channel, and is trying to get the mute removed
13:29:30 <jfredett> byorgey: ?
13:29:33 <ErrantEgo> He's attempted to contact an op, but apparently has had no luck
13:29:46 <jfredett> I'm looking for something to do
13:29:48 <ErrantEgo> no sir, someone by the nick of palonotmer
13:29:52 <byorgey> jfredett: ah, I see
13:29:56 <byorgey> hmm...
13:29:57 <jfredett> I'm fiddling with rope-like datastructures now
13:30:24 <b_jonas> jfredett: hmm, ropes came in fashion in this icfp
13:30:26 <sjanssen> heh, he goes by "palonotmer" now?
13:30:32 <jfredett> b_jonas: yah
13:30:55 <ray> and "notpalomer" i think
13:30:55 <jfredett> I'm trying to see if I can improve the structure using some nifty Data-structure math
13:31:03 <b_jonas> even though I suspect that if you had lots of time, you could devise something more specific that's better for it
13:31:17 <b_jonas> but obviously ropes were enough for the three-day thing
13:31:18 <jfredett> just kindof toying with things
13:31:22 <sorear> 2007.08.11.00.13.39 -!- mode/#haskell [+b %*!*@bas3-montreal02-1096682424.dsl.bell.ca] by glguy
13:31:40 <byorgey> @palomer
13:31:41 <lambdabot> (_|_)
13:31:53 <b_jonas> obviously, rope isn't such a specific word so you could still call the result rope
13:33:37 <sorear> ErrantEgo: palomer was a famous troll around here... he came back a few weeks ago with a claim of legitimacy, and was banned on sight when glguy came back
13:34:10 <ErrantEgo> i am going to assume glguy is the channel owner?
13:34:16 <sorear> no
13:34:26 <ErrantEgo> ah, np
13:34:32 <sorear> I think it's shapr or dons
13:34:44 <Heffalump> it used to be shapr
13:34:45 <ErrantEgo> he is admitting to being a troll, for what its worth...
13:34:46 <sorear> shapr: the freenode high inquisitors are here
13:34:56 <ErrantEgo> 4:33 PM: palonotmer: to be fair, I was a troll; but it was a year ago!
13:35:01 <ski> @get-shapr
13:35:01 <lambdabot> shapr!!
13:35:26 <Heffalump> can't he just contact shapr et al himself?
13:35:51 <ErrantEgo> he claims to have already attempted to contact the channel operators, with no such luck
13:37:05 <jfredett> ooh, Thunderstorm!
13:37:10 <byorgey> sorear: did he do anything in particular to cause glguy to ban him again, or was it just because of the remembered history?
13:37:11 <jfredett> directly overhead
13:37:17 <DRMacIver> I wonder if that's the palomer from EFNet #math.
13:37:20 <sorear> byorgey: I didn't see context
13:37:27 <sorear> DRMacIver: gshuett@ ?
13:37:36 <DRMacIver> No idea.
13:37:38 <Heffalump> I don't remember him trolling, but I probably wasn't paying much attention
13:37:55 <DRMacIver> Not someone I know well, but I remember him as being generically tolerable if it's the same one.
13:38:04 <DRMacIver> (Which from me is high praise. ;) )
13:38:27 <Heffalump> DRMacIver: I hear you are organising the next LondonHUG?
13:38:53 <DRMacIver> Err. I am?
13:38:56 <DRMacIver> I suppose I am.
13:39:01 <DRMacIver> I should probably do something about that...
13:39:06 <DRMacIver> (But I think it's just a pub trip)
13:39:20 <DRMacIver> (Put it this way, if it's not just a pub trip I'm certainly not the one organising it. ;) )
13:39:52 <Heffalump> "just a pub trip" sounds eminently sensible, it just needs a date
13:40:05 <DRMacIver> Third wednesday of the month is the tradition isn't it?
13:40:24 <Heffalump> then it needs an announcement asap, that being 9 days away :-)
13:40:28 <DRMacIver> Yeah
13:40:36 <DRMacIver> I'll send an email now. :) Thanks for the reminder.
13:40:55 <Heffalump> can you post to the blog too? The mailing list doesn't have that many subscribers.
13:40:59 <shapr> sorear: oh?
13:41:06 <DRMacIver> Heffalump: I don't think I can actually...
13:41:21 * DRMacIver doesn't have an account there.
13:41:27 <Heffalump> oh well
13:41:46 <Heffalump> Neil can probably be prodded to do that
13:41:54 <DRMacIver> Yeah. I'll give him a poke when he's next on.
13:43:35 <byorgey> shapr: scroll up & look for ErrantEgo...
13:43:38 <shapr> Yeah, I see now.
13:47:08 <lament> what's the name for the operation of determining the probable frequencies after a fourier transform?
13:47:43 <vincenz> 'probable' ?
13:47:48 <vincenz> thresholding?
13:48:52 <lament> like, if there's a peak at 150 hz, and a peak at 160 hz, and 10 hz is my step size, then i can guess that the real peak is at 155 hz
13:49:00 <vincenz> averaging?
13:49:11 <vincenz> finding the mean?
13:49:19 <vincenz> weighted average?
13:49:19 <byorgey> interpolating?
13:49:46 <lament> interpolating and finding the maxima
13:49:49 <lament> i bet there's a name for it
13:50:00 <vincenz> weighted average :)
13:50:01 <b_jonas> finding the modus
13:50:12 <lament> vincenz: it's not weighted average, that's just a simple example
13:50:27 <vincenz> hmm, then I'm lacking context
13:50:38 <lament> it's weighted average when you know there's only one constituent frequency
13:50:55 <vincenz> (not fourier specfic, but the specific operation you're asking for, which does not seem to be fourier specific)
13:51:03 <vincenz> principle component analysis?
13:51:04 <lament> if you have a peak at 150, nothing at 160 and a peak at 170, that simply means you have two frequencies, 150 and 170
13:51:31 <lament> (or maybe that some weird aliasing happened)
13:51:43 <Toxaris> is there something like sequence for [m a], but for Maybe (m a)?
13:52:27 <vincenz> erm
13:52:28 <vincenz> lift?
13:52:35 <vincenz> wait, nm
13:52:48 <vincenz> @type maybe
13:52:52 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:52:58 <vincenz> maybe (return ())
13:52:59 <vincenz> :)
13:53:08 <vincenz> oh wait, that only works for m ()
13:53:17 <twanvl> maybe mzero return
13:53:26 <vincenz> twanvl: no need for return
13:53:30 <vincenz> the cation is already monadic
13:53:37 <vincenz> maybe mzero id
13:53:37 <sjanssen> Toxaris: Data.Foldable.sequence
13:54:13 <twanvl> ?type maybe (return Nothing) return
13:54:15 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe (Maybe a) -> m (Maybe a)
13:54:48 <mattam> @type sequence
13:54:49 <sjanssen> Toxaris: or Data.Traversable.sequence
13:54:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:54:58 <vincenz> @type maybe (return Nothing) (>>= (return . Just))
13:55:00 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe (m a) -> m (Maybe a)
13:55:02 <vincenz> there we go
13:55:51 <vincenz> 'sequence' for Maybe's
13:56:48 <twanvl> ?type maybe (return Nothing) (liftM return)
13:56:50 <lambdabot> forall a1 (m :: * -> *). (Monad m) => Maybe (m a1) -> m (Maybe a1)
13:58:01 <vincenz> @type liftM return
13:58:03 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 a1 -> m1 (m a1)
13:58:34 <vincenz> @type >>= (liftM return)
13:58:36 <lambdabot> parse error on input `>>='
13:58:47 <vincenz> > Just [1] >>= (liftM return) :: [Just Integer]
13:58:48 <lambdabot>   Not in scope: type constructor or class `Just'
13:58:52 <vincenz> > Just [1] >>= (liftM return) :: [Maybe Integer]
13:58:53 <lambdabot>  Couldn't match expected type `[a]'
13:58:57 <vincenz> doh
13:59:00 <vincenz> oh well
13:59:16 <Toxaris> sjanssen: Data.Traversable.sequence looks good. Given my intended application, I can even use Data.Traversable.mapM, I think. Since when is Data.Traversable around?
13:59:34 <vincenz> > maybe (return Nothing) (>>= (return . Just)) $ Just [1,2,3]
13:59:36 <lambdabot>  [Just 1,Just 2,Just 3]
14:00:31 <sjanssen> Toxaris: GHC 6.6, IIRC
14:01:36 * Toxaris should ask his boss wich ghc version he uses...
14:06:38 <Toxaris> is there some introduction to the relation of Applicative, Functor, Foldable, Traversable, Monad, Arrow. (are they all related?)?
14:07:14 <Toxaris> vincenz: yes that's what I want, but it's not exactly short :) but thank you anyway
14:08:02 <TSC> The paper on applicative functors talks about their relation to monads and arrows
14:08:06 <pjd> Toxaris: i know Monad < Applicative < Functor
14:09:53 <sjanssen> Toxaris: you might start with "Idioms: applicative programming with effects" by McBride and Paterson
14:26:51 <Khoth> :t lift
14:26:53 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
14:27:28 <b_jonas> these type specifications look really ugly
14:29:07 <Khoth> @src guard
14:29:07 <lambdabot> guard True  =  return ()
14:29:07 <lambdabot> guard False =  mzero
14:32:23 <Khoth> How do I make lambdabot tell me what module things are defined in?
14:33:03 <samreid> @hoogle guard
14:33:04 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
14:33:04 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
14:33:04 <lambdabot> Language.Haskell.TH.Guard :: data Guard
14:33:10 <Khoth> Thanks
14:33:16 <Khoth> @hoogle MonadPlus
14:33:17 <lambdabot> Control.Monad.MonadPlus :: class Monad m => MonadPlus m
14:33:55 <samreid> er, I meant /msg lambdabot @hoogle guard :-)
14:34:17 <Khoth> okay
14:35:02 <SamB> @index guard
14:35:03 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:56:29 <popcount> What does \Pi mean in \Pi i \in I. D_i?
14:56:44 <DRMacIver> Product.
14:57:09 <ibid> analoguous to \Sigma, but for product not sum, as DRMacIver says
14:57:13 <DRMacIver> Usually in the sense of the product type (i.e. tuples with indices in I)
14:57:23 <ibid> or in arithmetic :)
14:58:27 <DRMacIver> ibid: I think it's much more common as a set/type theoretic product than an arithmetic one. :)
14:58:41 <popcount> DRMacIver, can you be a bit more explicit?
14:59:01 <ibid> DRMacIver: well, i learned it first in an arithmetic (well, algebraic) context, years before i knew anything about types and sets :)
14:59:16 <DRMacIver> ibid: Sure, I'm not saying it's not used there. Just that it's not as common to care about those. :)
14:59:48 <ibid> DRMacIver: field bias, perhaps :)
15:00:07 <jfredett> Big Pi is used alot in number theory for infinite product, the call them Euler Products, ayup.
15:00:22 <DRMacIver> popcount: Well, for example, A_1 x A_2 x A_3, or tuples (a_1, a_2, a_3) could be regarded \Pi_{i in {1, 2, 3}} A_i
15:00:30 <DRMacIver> jfredett: Yeah, but who cares about number theory? ;)
15:00:36 <jfredett> Apparently, Euler did
15:00:45 <ddarius> cryptologists
15:00:48 <DRMacIver> ibid: Maybe. But it's field bias spread over a non-trivial number of fields. :)
15:00:49 <jfredett> I'm an abstract algebra guy, myself. :)
15:00:57 <DRMacIver> jfredett: Oh. Anyone important? ;)
15:01:00 <ibid> DRMacIver: fair enough :)
15:01:03 <popcount> DRMacIver, ok, that's easy.
15:01:04 <popcount> DRMacIver, thanks
15:01:24 <jfredett> DRMacIver: grr, Euler is my favorite mathematician, play nice
15:01:47 <hpaste>  fxr pasted "largest power of two whose ..." at http://hpaste.org/2240
15:01:52 <ddarius> Gauss is pretty impressive.
15:02:00 <jfredett> meh, Gauss was okay
15:02:07 <jfredett> Riemann was mediocre,
15:02:09 <jfredett> Euler...
15:02:13 <jfredett> He was a clever bastard
15:02:13 <fxr> any ideas or improvements?
15:02:13 <jfredett> :)
15:02:33 <ibid> my favourite mathematician... that's tough
15:02:38 <sorear> There are plenty of impressive mathematicians to go around.
15:02:48 <jfredett> sorear: agreed
15:02:54 <jfredett> but Euler is my favorite
15:02:55 <jfredett> :)
15:03:02 <jfredett> fxr, hmm
15:03:24 <phobes> With many mathematicians I look at what they did and think "I could have done that" - not with Euler though
15:03:34 <ibid> to pick just one, i'd probably say gödel
15:03:37 * sorear votes for Gödel
15:03:41 <vincenz> I pick the one that invented 0
15:03:45 <ibid> but that's not by a big margin
15:03:47 <jfredett> ooh, godel is good too
15:03:47 <ddarius> Bugger Goedel
15:03:54 <vincenz> goodel
15:04:01 <sorear> girdle
15:04:01 <jfredett> and Russel
15:04:02 * ibid is too much a logic guy
15:04:12 <jfredett> Godel is my favorite Logician
15:04:19 <jfredett> Russel is my favorite Type Theorist
15:04:20 <phobes> Godel... meh... I could have done that :)
15:04:22 <jfredett> problem solved
15:04:28 * ibid has some affinity toward frege's logic :)
15:04:29 <popcount> Paris Hilton ;)
15:04:35 <fxr> popcount: haha
15:04:36 <jfredett> phobes: yes, but you didn't do that
15:04:37 <jfredett> :P
15:04:37 <ddarius> It would have been really interesting to see what Galois what have become if his life wasn't so short.
15:05:12 <jfredett> fxr, hmm
15:05:23 <ibid> actually, i think my mathematical hero is tarski
15:05:45 <phobes> Logic is pretty cool
15:05:50 <fxr> jfredett: well I'm a beginner haskell programmer and I'm looking at a nicer proof instead of a brute force.
15:05:53 <ddarius> Logic is pretty boring.
15:06:15 <desp> popcount: could've done that too, eh? nudge, nudge? wink, wink?
15:06:19 <jfredett> so your looking for 2^k, hmm
15:06:49 <fxr> actually I'm looking for a predicate for the problem
15:06:51 <popcount> desp, ?
15:06:56 <jfredett> fxr
15:06:58 <jfredett> granted
15:07:02 <desp> Cantor
15:07:06 <jfredett> but I'm just thinking about how to solve it
15:07:10 <jfredett> w/o programming
15:07:10 <jfredett> :P
15:07:13 <ddarius> desp: Why?
15:07:24 <b_jonas> mine is Euler -- or is that too conventional?
15:07:35 <ddarius> Euler was a good mathematician.
15:07:40 <fxr> jfredett: I'm not programming :) I only describe my solution with haskell
15:07:45 <jfredett> b_jonas: mine's Euler too, so no, its not :P
15:07:53 <jfredett> fxr yah yah yah... :P
15:07:55 <b_jonas> :)
15:07:57 <phobes> my vote is for Euler too
15:08:05 <desp> ddarius: set theory? and he went mad in the end
15:08:07 <desp> :)
15:08:09 <jfredett> hmm
15:08:15 <ddarius> desp: They all go mad in the end.
15:08:54 <popcount> How can you decide what your favorite mathematician is? Doesn't that require you to have read at least a few books for every mathematician?
15:09:04 <ddarius> popcount: No
15:09:07 <phobes> Do you have a favorite movie?
15:09:19 <Nucleo> @hoogle cbrt
15:09:19 <lambdabot> No matches found
15:09:21 <jfredett> well, we're basically looking for a number 2^k which, mod 7^j, is not 0
15:09:23 <desp> that might not be exactly the best metaphor :)
15:09:38 <jfredett> where j is each power in the representation in base 7
15:09:39 <jfredett> errr
15:09:57 <jfredett> for which there aren't three j's in a row.
15:10:02 <jfredett> right? no
15:10:04 <jfredett> thats wrong
15:10:05 <jfredett> :/
15:10:19 <b_jonas> what do you think about Church then?
15:10:22 <jfredett> gcd? yah.
15:10:26 <jfredett> hmm
15:10:37 <jfredett> *grabs notebook*
15:10:43 <jfredett> thanks fxr, now you've got me hooked
15:10:59 <ddarius> Yeah, things always go down hill when you get a notebook.
15:11:02 <fxr> as you wish
15:11:18 <monochrom> People decide their favourite movie stars without watching every movie.
15:11:22 <vincenz> ddarius: you use it as a sled?
15:11:45 <phobes> monochrom:  desp doesn't like the movie analogy
15:11:52 <ddarius> vincenz: That might explain why mine is suffering from water damage.
15:11:52 <phobes> I don't know why :)
15:11:55 <monochrom> And people decide their marriage without dating everyone else.
15:12:05 <desp> "I wanted to have a water jet in my garden: Euler calculated the force of the wheels necessary to raise the water to a reservoir, from where it should fall back through channels, finally spurting out in Sanssouci. My mill was carried out geometrically and could not raise a mouthful of water closer than fifty paces to the reservoir. Vanity of vanities! Vanity of geometry!"
15:12:08 <popcount> I understand why functional dependencies are such a mess.
15:12:11 <desp> Euler--
15:12:14 <desp> ;)
15:13:03 <monochrom> You should, like, take general relativity into account, you know.
15:21:03 <jfredett> fxr, I think this will work:
15:21:03 <jfredett> gcd(7^j + 7^j+1 + 7^j+2, 2^k) = 1, where 1 <= j <= ceiling(logbase 7 2^k)
15:21:05 <jfredett> I think-
15:21:20 <jfredett> I'm still playing with it
15:23:33 <jfredett> although
15:23:39 <jfredett> doesn't 2^0 work?
15:23:50 <jfredett> since 2^0 = 7^0
15:23:55 <jfredett> theres only 1 0
15:24:05 <jfredett> in the whole representation
15:24:14 <jfredett> oh- largest power
15:24:16 <jfredett> hmm
15:24:23 <fxr> yup
15:24:28 <jfredett> that presumes there is a largest
15:24:32 <jfredett> or is that proven?
15:25:01 <fxr> I can't find any proof
15:25:12 <jfredett> where'd this problem come from, anyway?
15:25:20 <jfredett> I want more like it
15:25:20 <jfredett> :)
15:26:29 <fxr> jfredett: I got it via mail, I think it's written by Bram Cohen.
15:26:50 <jfredett> i see
15:27:06 <jfredett> it sounds like a putnam problem
15:27:11 <jfredett> (from the putnam exam)
15:28:51 <jfredett> I'm pretty sure thats a predicate for them though
15:29:17 <oerjan> if there is a largest, you can prove it
15:29:21 <jfredett> right
15:29:29 <jfredett> i'm just not sure how
15:29:30 <jfredett> hmm
15:29:37 <oerjan> well, probably
15:30:00 <jfredett> well, say there is a largest, call it K
15:30:17 <oerjan> you need first to find a number n of digits such that every large enough power of 2 contains 3 zeros in the last n base 7 digits
15:30:34 <jfredett> if K' has the propert and is larger than K... no
15:30:36 <jfredett> that wont do
15:30:42 <jfredett> oerjan: hmm?
15:30:53 <jfredett> ooh, idea
15:30:58 <jfredett> no
15:31:00 <jfredett> nvm
15:31:01 <jfredett> :/
15:31:05 <oerjan> then you enumerate all possible last n digit combinations for a power of 2
15:31:25 <chessguy> err, what are you guys talking about?
15:31:39 <jfredett> http://www.hpaste.org/2240
15:31:40 <oerjan> now, it is quite possible this is accidentally particularly simple in base 7
15:31:54 <desp> @let let swap a b xs | a == b = xs | a > b = swap b a xs | otherwise = let (ps1, p : ps2) = splitAt (a - 1) xs in let (qs1, q : qs2) = splitAt (b - a - 1) ps2 in ps1 ++ [q] ++ qs1 ++ [p] ++ qs2
15:31:54 <lambdabot>  Parse error
15:32:05 <desp> oops
15:32:16 <desp> @let swap a b xs | a == b = xs | a > b = swap b a xs | otherwise = let (ps1, p : ps2) = splitAt (a - 1) xs in let (qs1, q : qs2) = splitAt (b - a - 1) ps2 in ps1 ++ [q] ++ qs1 ++ [p] ++ qs2
15:32:19 <lambdabot> Defined.
15:32:28 <desp> > swap 2 4 "12345"
15:32:29 <lambdabot>  "14325"
15:32:45 <desp> any better ways?
15:32:53 <jfredett> well, if we enumerate all the base seven numbers with 3 consequtive 0's we just need to prove that all powers of 2 above some power k are contained in that set
15:33:00 <jfredett> or did oerjan just say to do that?
15:33:03 <jfredett> :/
15:33:20 <oerjan> i think i was a bit more specific
15:33:25 <b_jonas> hmm
15:34:00 <jfredett> *thinks*
15:35:00 <fxr> by the way my brute force solution eats all of my ram :(
15:35:16 <oerjan> fxr: it will never stop, of course
15:35:46 <fxr> :) sure
15:35:49 <oerjan> what is the largest exponent you've got so far?
15:36:36 <oerjan> if we assume that _is_ the largest, we can start the proof from the next one
15:36:51 * sorear starts trying to prove this
15:36:58 <fxr> I have to stop because of swap usage while "(take 1 . drop 2000) setC"
15:37:23 <oerjan> hm, let me see ... it should be possible to estimate the number of digits needed
15:37:32 <desp> > swap 1 3 "12"
15:37:34 <lambdabot>  Exception: <local>:3:109-148: Irrefutable pattern failed for pattern (qs1, q...
15:37:55 <jfredett> hmm
15:38:25 <Tchakkazulu> "Irrefutable pattern failed" has something odd about it.
15:38:34 <oerjan> in a random list of base 7 digits, how many do we need to be reasonably sure of having 3 zeros in a row?
15:38:40 <desp> a sense of impending apocalypse
15:38:58 <hpaste>  popcount pasted "Fun with fundeps!" at http://hpaste.org/2241
15:39:05 <monochrom> inescapable doom :)
15:39:10 <oerjan> > 7^3
15:39:11 <lambdabot>  343
15:39:26 <popcount> sorear, that was the fundep(aka square wheel) I needed.
15:39:30 <monochrom> Wow, that is indeed complex :)
15:39:59 <oerjan> if we assume 1000 digits are enough, we can use (mod 7^1000) arithmetic
15:40:06 <jfredett> right
15:40:13 <desp> EBM is actually a fun music genre.
15:41:17 <oerjan> hm, 2 is relatively prime to 7, so 2^n (mod 7^k) should eventually repeat from 1...
15:41:52 <jfredett> right
15:42:09 <jfredett> thats how my predicate works
15:42:30 <oerjan> otoh if we are unlucky it could take on the order of 7^k iterations :(
15:42:32 <sorear> It's a trick question
15:42:39 <sorear> ...0000000000000000000000000000000000000000004
15:42:47 * sorear qeds
15:42:53 <jfredett> sorear: well, we're assuming a non-pathological
15:43:03 <phobes> What's the origin of this problem?
15:43:15 <jfredett> fxr, mostly
15:43:39 <phobes> Is this a real problem?  A Challenge?  A homework problem?
15:43:39 <fxr> well I got it via mail
15:44:00 <fxr> and I saw the lisp implementation, thus tried to write haskell one
15:44:17 <oerjan> fxr: maybe it was intended as a trick question, or is there an actual answer?
15:44:36 <fxr> oerjan: I can't find any prove
15:45:27 <oerjan> it seems _likely_ that there is a largest one, but my proof sketch might not actually work
15:45:44 <oerjan> (even if there is)
15:46:10 <jfredett> hmm
15:46:18 <oerjan> since 2^n could be sort of too dense in 7^k, regardless of k
15:47:07 <desp> does anyone have a bit of code laying around to generate permutations in lexicographic order?
15:47:15 <sorear> Okay, the thread has gone on far too long.  Proof: ddarius said "You are wrong."
15:47:16 <jfredett> i did
15:47:20 <jfredett> its in scheme
15:47:23 <jfredett> I dont know where it is
15:47:28 <jfredett> its not hard to write
15:47:53 <desp> I think I've written it before a few times, but for some reason, it's confusing me now.
15:50:01 <jfredett> given a list, for each element of the list, catenate it to the list minus that element
15:50:12 <jfredett> err, the permutation of the list minus that element
15:50:17 <jfredett> something like:
15:51:02 <Saizan> fdigits (nb+1) (n+1) = mapAccumR ((swap .). divMod) n (take nb facts)
15:51:02 <Saizan> render (nb+1) (a,l) = concatMap show . snd $ mapAccumL fetchDel [0..nb] (reverse (a:l))
15:51:05 <Saizan> perm n = render n . fdigits n
15:51:13 <jfredett> > let perms [] = []; perms ls = map (\x -> [x] ++ (perms (ls \\ x))
15:51:13 <lambdabot>  Parse error
15:51:16 <jfredett> or something
15:51:19 <Saizan> perm numberofelements nth-permutation
15:51:19 <jfredett> I don't know
15:52:41 <Saizan> so you can map (perm n) [1..(fact n)] if you want
15:52:47 <desp> @hoogle fetchdel
15:52:48 <lambdabot> No matches found
15:52:54 <oerjan> er...
15:53:16 <Saizan> fetchDel ls i = let (l,a:r) = splitAt i ls in (l++r,a)
15:53:16 <Saizan> swap (x,y) = (y,x)
15:53:42 * Saizan would have pasted in the first place if he had realized there was more code 
15:53:52 <augustss> @src while
15:53:52 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:53:56 <oerjan> > let perms [] = []; perms ls = [x:r | x <- ls, r <- perms (delete x ls)] in perms [1,2,3]
15:53:57 <lambdabot>  []
15:54:27 <olsner> I think something is wrong in your code there
15:55:05 <jfredett> :t delete
15:55:06 <jfredett> err
15:55:07 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
15:55:11 <jfredett> oh, that worked
15:55:22 <jfredett> hmm
15:55:26 * oerjan scratches head
15:55:31 <jfredett> that should work
15:55:35 <oerjan> it compiles, but is still wrong?
15:55:39 <jfredett> delete 1 [1,2,3]
15:55:42 <jfredett> > delete 1 [1,2,3]
15:55:44 <lambdabot>  [2,3]
15:56:08 <jfredett> > delete 2 [1,2,3]
15:56:10 <lambdabot>  [1,3]
15:56:15 <oerjan> ah!
15:56:23 <oerjan> > let perms [] = [[]]; perms ls = [x:r | x <- ls, r <- perms (delete x ls)] in perms [1,2,3]
15:56:24 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
15:56:28 <Toxaris> > delete 2 [1, 2, 2, 3]
15:56:29 <lambdabot>  [1,2,3]
15:56:36 <jfredett> ahh
15:56:43 <jfredett> type are a bitch
15:56:45 <oerjan> i missed that the empty list actually has a permutation
15:56:49 <jfredett> types*
15:56:52 <jfredett> but i love them
15:56:53 <jfredett> :)
15:57:11 <desp> oerjan++
15:57:16 <Toxaris> > delete [1, 2, 3, 2] -- how to delete the second 2?
15:57:17 <lambdabot>  <[[Integer]] -> [[Integer]]>
15:57:28 <Toxaris> > delete 2 [1, 2, 3, 2] -- how to delete the second 2?
15:57:29 <lambdabot>  [1,3,2]
15:57:36 <jfredett> delete 2 (delete 2 [1,2,2,3])
15:57:42 <jfredett> > delete 2 (delete 2 [1,2,2,3])
15:57:43 <lambdabot>  [1,3]
15:57:46 <jfredett> :)
15:57:50 <oerjan> > filter (/= 2) [1,2,2,3]
15:57:52 <lambdabot>  [1,3]
15:57:55 <jfredett> that works too
15:57:56 <jfredett> :)
15:57:59 <mauke> > [1,2,3,2] \\ [2]
15:58:00 <lambdabot>  [1,3,2]
15:58:11 <Toxaris> but for perms, you want to sometimes delete the first, and sometimes the second
15:58:23 <desp> > tail . swap 1 4 $ [1, 2, 3, 2]
15:58:25 <lambdabot>  [2,3,1]
15:58:27 <oerjan> oh, if it has equal elements?
15:58:30 <phobes> > reverse . (delete 2) . reverse [1, 2, 3, 2]
15:58:31 <lambdabot>  Couldn't match expected type `a -> [t]'
15:58:38 <Toxaris> oerjan: yes
15:58:54 <jfredett> > > reverse . (delete 2) . reverse $ [1, 2, 3, 2]
15:58:54 <lambdabot>  Parse error
15:58:57 <jfredett> > reverse . (delete 2) . reverse $ [1, 2, 3, 2]
15:58:59 <lambdabot>  [1,2,3]
15:59:00 <oerjan> then we need to select by position instead
15:59:14 <Toxaris> I think for general perms we need   select :: [a] -> [(a, [a])]
15:59:34 <Toxaris> "we need" == "i would first define" maybe
16:00:04 <oerjan> something with zip (inits ls) (tails ls)
16:00:10 <oerjan> could also work
16:01:16 <jfredett> meh, enough thinking, time for nethack
16:01:27 <popcount> Is there a warning for type contexts that are overly restrictive?
16:01:41 <oerjan> > let perms [] = [[]]; perms ls = [x:r | (r1,x:r2) <- zip (inits ls) (tails ls), r <- perms (r1++r2)] in perms [1,2,3,2]
16:01:42 <lambdabot>  [[1,2,3,2],[1,2,2,3],[1,3,2,2],[1,3,2,2],[1,2,2,3],[1,2,3,2],[2,1,3,2],[2,1,...
16:01:53 <popcount> E.g. adding an Ord constraint where Eq would be enough?
16:03:25 <desp> > let perms [] = [[]]; perms ls = [x:r | (r1,x:r2) <- zip (inits ls) (tails ls), r <- perms (r1++r2)] in perms "aba" == sort (perms "aba")
16:03:26 <lambdabot>  False
16:04:15 <Toxaris> deps: lexically sorted with respect to the order in the input list, or with respect to some Ord context?
16:04:33 <desp> yeah, good question. disregard that.
16:05:31 <oerjan> popcount: i don't know, but often you can start by leaving out the typing and asking for the inferred one with :t
16:06:12 <popcount> oerjan, I mean in the context of an instance.
16:06:24 <popcount> oerjan, this can happen when you changed some things somewhere else.
16:06:59 <oerjan> popcount: in that case you might leave off the context and see what missing context it complains about?
16:07:18 <popcount> oerjan, you don't understand
16:07:45 <oerjan> well, i understand that it would be nice if it were automatic
16:07:56 <popcount> oerjan, I solved this particular problem, but there's no reason why it won't happen again.
16:08:21 <oerjan> popcount: yeah, you would have to know to check i suppose
16:09:03 <sorear> popcount: the two types you give for #1454 are equivalent
16:09:04 <popcount> None of the warning options seemed to do it, so I answered my own question with no.
16:11:13 <Toxaris> > let select [] = []; select (x:xs) = (x, xs) : (fmap . fmap) (x :) (select xs); perms [] = [[]]; perms xs = select xs >>= \(y, ys) -> perms ys >>= \zs -> return (y:zs) in perms "aba"
16:11:21 <lambdabot>  ["aba","aab","baa","baa","aab","aba"]
16:11:39 <oerjan> hm... you would want a warning for when the inferred type for something is more general than the declared one
16:12:33 <oerjan> fmap . fmap?
16:12:40 <Toxaris> sure :)
16:12:53 <mauke> why not go all the way and use fmap fmap fmap?
16:12:58 <oerjan> what's wrong with map?
16:14:13 <Toxaris> in this case   (fmap . fmap) == (map . second)   but how to decide what's better?
16:14:20 <olsner> hmm... fmap on tuples is the same as second, right?
16:14:21 <oerjan> anyway, there is a select hidden in my version too
16:14:33 <ddarius> fmap . fmap == (.) . (.)
16:15:03 <Saizan> ?type fmap . fmap
16:15:06 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:15:08 <oerjan> > let select ls = [x:(r1++r2) | (r1,x:r2) <- zip (inits ls) (tails ls)] in select [1,2,3]
16:15:09 <lambdabot>  [[1,2,3],[2,1,3],[3,1,2]]
16:15:12 <mauke> ?type fmap fmap fmap
16:15:14 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:15:15 <oerjan> er...
16:15:23 <oerjan> > let select ls = [(x,r1++r2) | (r1,x:r2) <- zip (inits ls) (tails ls)] in select [1,2,3]
16:15:25 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
16:15:26 <LoganCapaldo> @type fmap `fmap` fmap
16:15:28 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:15:35 <bitwize> Is my information correct in that Gentoo's distribution of GHC is somewhat naff?
16:15:46 <dmwit> naff?
16:15:54 <mauke> http://dict.leo.org/?search=naff
16:15:56 <lambdabot> Title: LEO D-E Ergebnisse fr "naff"
16:16:02 <chessguy> @jargon naff
16:16:03 <lambdabot> No match for "naff".
16:16:04 <olsner> @type fmap `on` fmap
16:16:06 <lambdabot> Not in scope: `on'
16:16:17 <bitwize> @google define:naff
16:16:18 <lambdabot> No Result Found.
16:16:22 <olsner> but it wouldn't have been right anyways...
16:17:10 <bitwize> Naff. Flawed. Roughly the opposite of _like butter_.
16:17:25 <dmwit> wikipedia has an entry
16:17:47 <Toxaris> oerjan: cool. Now that you showed me the hidden select, I understand your code :)
16:19:51 <fxr> bitwize: I'm using gentoo and had no problem with ghc
16:20:17 <oerjan> maybe there should be a splits l = zip (inits l) (tails l) in the libraries...
16:20:30 <bitwize> me neither.
16:23:46 <bitwize> I heard there were troubles installing libraries and that.
16:23:51 <bitwize> but maybe my info is bogus.
16:23:59 <Toxaris> oerjan: now that I've seen it, it seems to be quite obvious
16:29:49 <oerjan> @pl splits l = zip (inits l) (tails l)
16:29:49 <lambdabot> splits = liftM2 zip inits tails
16:31:12 <lament> @pl x y = y y y y y y y y y y y y y y y y
16:31:13 <lambdabot> x = join (join (join (join (join (join (join (join (join (join (join (join (join (join (join id))))))))))))))
16:31:29 <oerjan> O_O
16:31:43 <lament> clearly pointless, but certainly not bracketless
16:31:45 <LoganCapaldo> lament, you wins the prize!
16:31:57 <olsner> @unpl join (join (join (join (join (join (join (join (join (join (join (join (join (join (join id))))))))))))))
16:31:58 <lambdabot> ((((((((((((((((\ a -> a) >>= \ ad -> ad) >>= \ ab -> ab) >>= \ z -> z) >>= \ x -> x) >>= \ v -> v) >>= \ t -> t) >>= \ r -> r) >>= \ p -> p) >>= \ n -> n) >>= \ l -> l) >>= \ j -> j) >>= \ h -> h) >
16:31:58 <lambdabot> >= \ f -> f) >>= \ d -> d) >>= \ b -> b)
16:32:06 <lament> it does look like lisp, though
16:32:15 <oerjan> might need some $'s
16:32:24 <lament> what's with all hte >>= in that unpl?
16:32:32 <lament> :t join
16:32:33 <mauke> @src join
16:32:33 <lambdabot> join x =  x >>= id
16:32:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:32:38 <lament> oh
16:33:04 <oerjan> hm... of course it could never typecheck
16:33:16 <olsner> > let f '(' = "$ "; f ')' = []; f x = [x] in concatMap f "join (join (join (join (join (join (join (join (join (join (join (join (join (join (join id))))))))))))))"
16:33:17 <lambdabot>  "join $ join $ join $ join $ join $ join $ join $ join $ join $ join $ join ...
16:33:23 <lament> how does it know which monad to use
16:33:27 <lament> in that unpl'd version
16:33:47 <oerjan> lament: it doesn't, it uses >>=
16:33:55 <LoganCapaldo> lament, it uses any monad, no?
16:33:58 <olsner> @. pl unpl join (join id)
16:33:58 <lambdabot> join (join id)
16:34:14 <lament> sure, it uses any monad, but the original version uses no monad
16:34:29 <oerjan> lament: or to be precise, that (\a -> a) fixes the monad
16:34:29 <lament> so now the typechecker is at a loss
16:34:52 <oerjan> because it's at the left of >>=
16:35:09 <lament> oh, right
16:35:12 <olsner> :t (id >>=)
16:35:14 <lambdabot> forall a b. (a -> a -> b) -> a -> b
16:36:41 <oerjan> :t join (join id)
16:36:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a -> a1
16:36:43 <lambdabot>     Probable cause: `id' is applied to too many arguments
16:36:46 <oerjan> thought so
16:37:15 <oerjan> it gets through @pl and @unpl only because they ignore types
16:37:19 <lament> heh
16:37:44 <oerjan> :t join id
16:37:46 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
16:37:46 <lambdabot>     Probable cause: `id' is applied to too many arguments
16:38:09 <lament> @pl \x -> map map map map x
16:38:10 <lambdabot> map (map map)
16:38:24 <lament> now that's profound.
16:38:30 <oerjan> :D
16:38:38 <olsner> :t map (map map)
16:38:39 <lambdabot> forall a b. [[a -> b]] -> [[[a] -> [b]]]
16:39:00 <olsner> :t map map
16:39:02 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
16:39:35 <lament> wait, map (map map) is an actual function, isn't it?
16:39:45 <oerjan> yep
16:39:47 <lament> and \x -> map map map map x can't pass the type checker
16:39:53 <oerjan> :t map map map -- not this though
16:39:53 <lament> so they can't possibly be very equivalent
16:39:56 <lambdabot>     Couldn't match expected type `[a -> b]'
16:39:56 <lambdabot>            against inferred type `(a1 -> b1) -> [a1] -> [b1]'
16:40:18 <LoganCapaldo> @type \x -> map map map map x
16:40:20 <lambdabot>     Couldn't match expected type `[a -> b]'
16:40:20 <lambdabot>            against inferred type `(a1 -> b1) -> [a1] -> [b1]'
16:40:32 <LoganCapaldo> wow
16:40:40 <lament> i like the map (map map) function, and map (map (map map)) even more so
16:40:46 <oerjan> @pl map map map map
16:40:47 <lambdabot> map (map map)
16:40:51 <oerjan> hah!
16:40:59 <lament> that can't be right.
16:41:13 <LoganCapaldo> :t map (map map)
16:41:15 <lambdabot> forall a b. [[a -> b]] -> [[[a] -> [b]]]
16:41:21 <sorear>  @pl assumes your code is typo correct
16:41:34 <LoganCapaldo> pl isn't peeeeeerfect, oh sad day
16:41:56 <lament> :t map(map(map(map(map(map(map map))))))
16:41:58 <lambdabot> forall a b. [[[[[[[a -> b]]]]]]] -> [[[[[[[[a] -> [b]]]]]]]]
16:42:16 <olsner> :t foldl ($) $ take 5 $ repeat map
16:42:18 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
16:42:18 <lambdabot>     Probable cause: `$' is applied to too many arguments
16:42:32 <vincenz> > map chr [108,97,109,101,110,116,32,104,97,115,32,116,111,111,32,109,117,99,104,32,116,105,109,101]
16:42:33 <lambdabot>  "lament has too much time"
16:42:36 <olsner> :t foldr ($) $ take 5 $ repeat map
16:42:38 <lambdabot> forall a b. [[(a -> b) -> [a] -> [b]] -> [(a -> b) -> [a] -> [b]]] -> [(a -> b) -> [a] -> [b]]
16:42:43 <fasta> How can I get a pdf or dvi document from the GHC source?
16:42:50 <olsner> :t foldr (flip ($)) $ take 5 $ repeat map
16:42:52 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
16:42:52 <lambdabot>     Probable cause: `flip' is applied to too many arguments
16:46:39 <oerjan> :t fmap fmap fmap fmap
16:46:41 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
16:46:56 <oerjan> @pl fmap fmap fmap fmap
16:46:57 <lambdabot> fmap (fmap fmap)
16:46:59 * shapr boings cheerfully
16:47:22 <oerjan> :t fmap (fmap fmap)
16:47:24 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f2 (f1 (a -> b)) -> f2 (f1 (f a -> f b))
16:47:47 <olsner> why can't I foldr a list of maps to get map$map$map$map map?
16:47:59 <oerjan> so, @pl got the first result because it treats map as a case of fmap, for which the transformation is correct...
16:48:13 <MarcWeber> dcoutts: Mmmh any idea about this? http://rafb.net/p/cFZxwV54.html. This happens when running autoreconf (http://rafb.net/p/yGKB8w65.html when running autoconf)
16:48:14 <lambdabot> Title: Nopaste - No description
16:48:20 <Lemmih> olsner: The type system is too limited.
16:48:39 <mauke> @pl \x -> map a b x
16:48:39 <lambdabot> map a b
16:48:42 <chessguy> @type repeat map
16:48:44 <lambdabot> forall a b. [(a -> b) -> [a] -> [b]]
16:50:29 <oerjan> @pl fmap fmap fmap
16:50:30 <lambdabot> fmap fmap fmap
16:51:00 <oerjan> :t fmap fmap fmap
16:51:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:51:06 <oerjan> :t fmap.fmap
16:51:08 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:51:22 <lament> @pl foldr (flip ($)) $ repeat map
16:51:22 <lambdabot> foldr (flip id) (repeat map)
16:51:26 <lament> blah
16:54:57 <chessguy> wow, this is a very informative wiki page: http://haskell.org/haskellwiki/Type_functions
16:54:58 <lambdabot> Title: Type functions - HaskellWiki
16:55:56 <monochrom> haha
16:56:11 * oerjan sneaks up and pastes on a </sarcasm> tag
16:56:25 <chessguy> @quote sarcasm
16:56:25 <lambdabot> No quotes match. The more you drive -- the dumber you get.
16:57:03 <Toxaris> is there a name for flip maybe id?
16:57:12 <ChilliX> chessguy: wonder why anybody but that stub there
16:57:24 <mauke> @. hoogle type flip maybe id
16:57:26 <lambdabot> Did you mean: Forall A. a -> Maybe a -> a
16:57:26 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
16:57:26 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
16:57:30 <ChilliX> the right one is http://haskell.org/haskellwiki/GHC/Indexed_types
16:57:31 <lambdabot> Title: GHC/Indexed types - HaskellWiki
16:58:11 <olsner> looks like fromMaybe
16:58:28 <olsner> > flip maybe id 7 Nothing
16:58:30 <lambdabot>  7
16:58:37 <olsner> > flip maybe id 7 (Just 3)
16:58:38 <lambdabot>  3
16:58:46 <sorear> fasta: the two types on #1454 look the same to me
16:59:01 <LoganCapaldo> I always forget about fromMaybe
16:59:05 <Toxaris> oh fromMaybe has a default parameter?
16:59:23 <psykotic> Toxaris, yes. you're thinking of fromJust, which doesn't, and can fail at runtime.
17:00:07 <ddarius> LoganCapaldo: And use maybe?
17:00:21 <Toxaris> psykotic: yes, I am :)
17:00:26 <LoganCapaldo> ddarius, yes
17:00:35 <ddarius> maybe is prettier
17:00:50 <sjanssen> sorear: also, guest is setting states like 'high', 'major', and 'blocker'?
17:04:36 <chessguy> yet another fascinating wiki page: http://haskell.org/haskellwiki/Hsffig_Tutorial/common.css
17:04:37 <lambdabot> Title: Hsffig Tutorial/common.css - HaskellWiki
17:05:17 <fasta> sorear: What looks the same?
17:05:22 <monochrom> haha why are you looking for pathological cases?
17:06:22 <fasta> monochrom: me?
17:06:28 <monochrom> No.
17:06:45 <vincenz> fromJust === maybe undefined id
17:07:04 <sorear> fasta:  :t => gget :: (MonadState? (Bar a b) m) => m b and :i => gget :: (Zork a b m) => m b
17:08:08 <sorear> fasta: All the constraints in the first entail the constraints in the second, so they are equally general
17:08:30 <fasta> sorear: yes, that's true.
17:08:36 <sorear> fasta: Normally, we try to put constraint sets into a normal form; but with -fallow-undecidable-instances that would be a recipe for disaster
17:09:00 <sorear> it'd just keep rewriting back and forth forever
17:09:02 <Cale> Ahahaha, the index numbers on my reddit new page: 91,98,103,126,148,160,163,164,172,222,...
17:09:23 <fasta> sorear: ok, so this case doesn't occur without undecidable instances?
17:10:08 <dcoutts> MarcWeber: those are both perfectly standard macros, so I assume your autoconf can't find it's standard macros :-(
17:10:52 <wli> this context stuff sounds useful
17:11:17 <ddarius> head = foldr const undefined
17:12:00 <LoganCapaldo> last = foldl (flip const) undefined IIRC
17:12:20 <LoganCapaldo> > foldl (flip const) undefined [1,2,3]
17:12:21 <lambdabot>  3
17:12:32 <LoganCapaldo> I do RC!
17:14:57 <wli> foldl'?
17:15:18 <olsner> > foldr const undefined [1,2,3]
17:15:20 <lambdabot>  1
17:16:01 <LoganCapaldo> > foldl' (flip const) undefined [1,2,3] -- too strict??
17:16:02 <lambdabot>  3
17:16:05 <LoganCapaldo> nope
17:16:10 <oerjan> > foldr (const.const.const) undefined [1..]
17:16:11 <lambdabot>  Add a type signature
17:16:21 <ddarius> olsner: Now the exercise is to write tail using foldr.
17:16:24 <oerjan> bah
17:16:35 <ddarius> :t const . const . const
17:16:37 <lambdabot> forall b b1 a b2. a -> b -> b1 -> b2 -> a
17:16:58 <olsner> :t let f = flip const in f . f . f
17:17:00 <lambdabot> forall a a1. a1 -> a -> a
17:17:07 <olsner> :t let f = flip const in f . f . f . f
17:17:08 <lambdabot> forall a a1. a1 -> a -> a
17:17:30 <olsner> my haskell-fu is still weak
17:18:29 <LoganCapaldo> > foldr (\x (xs, p) -> if p then (x:xs, p) else (xs, not p)) ([], False) [1,2,3]
17:18:31 <lambdabot>  ([1,2],True)
17:18:43 <LoganCapaldo> that's not tail
17:18:50 <LoganCapaldo> it's init :(
17:19:20 <ddarius> LoganCapaldo: It's a pretty creative init.
17:21:10 <desp> @hoogle [a] -> [(a, a)]
17:21:10 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
17:21:38 <olsner> > (map snd . filter ((> 2) . fst) . zip [1..]) ['a','b','c']
17:21:41 <lambdabot>  "c"
17:21:56 <olsner> > (map snd . filter ((> 0) . fst) . zip [0..]) ['a','b','c']
17:21:56 <LoganCapaldo> @type map (join (,))
17:21:58 <lambdabot>  "bc"
17:21:59 <lambdabot> forall a. [a] -> [(a, a)]
17:22:19 <Toxaris> > (map snd . filter ((> 0) . fst) . zip [0..]) []
17:22:21 <lambdabot>  []
17:22:28 <Toxaris> > tail []
17:22:28 <LoganCapaldo> @type join zip
17:22:31 <lambdabot>  Exception: Prelude.tail: empty list
17:22:31 <lambdabot> forall a. [a] -> [(a, a)]
17:22:40 <olsner> > (map snd . filter fst . zip (False:repeat True)) ['a','b','c']
17:22:42 <lambdabot>  "bc"
17:22:47 <ddarius> > fst $ foldr (\x ((xs,ys),p) -> if p then ((x:xs,ys),not p) else ((xs,x:ys),not p)) ([],True) [1,2,3,4]
17:22:48 <lambdabot>  Couldn't match expected type `([a], [a])'
17:22:53 <desp> > zip xs (tail xs) where xs = "abcd"
17:22:54 <lambdabot>  Parse error
17:23:08 <desp> > let xs = "abcd" in zip xs (tail xs)
17:23:09 <lambdabot>  [('a','b'),('b','c'),('c','d')]
17:24:02 <desp> lambdabot doesn't like where?
17:24:03 <ddarius> @free join (,)
17:24:04 <lambdabot> Extra stuff at end of line
17:24:14 <ddarius> :t join (,)
17:24:15 <Toxaris> desp: no where in expressions
17:24:16 <lambdabot> forall a. a -> (a, a)
17:24:21 <LoganCapaldo> desp, I think it has to be in a let or similar
17:24:26 <desp> right
17:24:36 <LoganCapaldo> > let x = a + a where a = 3 in x
17:24:38 <lambdabot>  6
17:24:42 <ddarius> @free [a] -> [(a,a)]
17:24:43 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
17:24:49 <desp> it's funny
17:24:50 <ddarius> @free f :: [a] -> [(a,a)]
17:24:51 <lambdabot> $map ($map_Pair g g) . f = f . $map g
17:25:13 <desp> during the half year of coding in Haskell, I've progressed from disliking where clauses and (.)s to wholly embracing them
17:25:54 <ddarius> That would be the corrupting power of Haskell.
17:25:56 <desp> now I'm fubar
17:26:07 <LoganCapaldo> > foldl (\(xs, p) x -> if p then (x:xs, p) else (xs, not p)) ([], False) [1,2,3]
17:26:09 <lambdabot>  ([3,2],True)
17:26:13 <LoganCapaldo> heh
17:26:17 <LoganCapaldo> I'm on a roll
17:26:32 <ddarius> It is tail, it's just also reverse.
17:26:36 <LoganCapaldo> reverse . tail
17:26:55 <ddarius> = init . reverse
17:27:07 <LoganCapaldo> Oh the irony
17:27:14 <psykotic> > foldr (\x (xs, xs') -> case xs of x':_ -> (x:xs, x':xs') ; otherwise -> ([x], [])) ([], []) [1,2,3,4]
17:27:16 <lambdabot>  ([1,2,3,4],[2,3,4])
17:27:39 <ddarius> @scheck \xs -> tail (reverse xs) == reverse (init xs)
17:27:40 <lambdabot> Add a type signature
17:28:00 <ddarius> @scheck (\xs -> tail (reverse xs) == reverse (init xs)) :: [I] -> Bool
17:28:01 <lambdabot> Exception: Prelude.tail: empty list
17:28:09 <ddarius> Stupid thing.
17:28:17 <ddarius> @check (\xs -> tail (reverse xs) == reverse (init xs)) :: [I] -> Bool
17:28:18 <lambdabot>  Exception: Prelude.tail: empty list
17:28:23 <desp> let f xs = map (uncurry $ flip (-)) $ zip xs (tail xs) in f [1..10]
17:28:27 <desp> > let f xs = map (uncurry $ flip (-)) $ zip xs (tail xs) in f [1..10]
17:28:28 <lambdabot>  [1,1,1,1,1,1,1,1,1]
17:29:02 <ddarius> zipWith?
17:29:12 <Toxaris> > let tail = snd . foldr f ([], error "empty list") where f x (xs, _) = (x:xs, xs) in map tail [[1, 2, 3], []]
17:29:12 <LoganCapaldo> @scheck (\xs -> (not (null xs)) ==> tail (reverse xs) == reverse (init xs))) :: [I] -> Property
17:29:13 <lambdabot>  Parse error
17:29:13 <lambdabot>  Exception: empty list
17:29:26 <Toxaris> > let tail = snd . foldr f ([], error "empty list") where f x (xs, _) = (x:xs, xs) in tail [1, 2, 3]
17:29:29 <lambdabot>  [2,3]
17:29:32 <Toxaris> > let tail = snd . foldr f ([], error "empty list") where f x (xs, _) = (x:xs, xs) in tail []
17:29:32 <ddarius> > let xs = [1..10] in zipWith (-) xs (tail xs)
17:29:35 <lambdabot>  [-1,-1,-1,-1,-1,-1,-1,-1,-1]
17:29:35 <lambdabot>  Exception: empty list
17:29:40 <psykotic> > snd . foldr (\x (xs, xs') -> (x:xs, xs)) ([],[]) $ [1,2,3,4]
17:29:41 <lambdabot>  [2,3,4]
17:30:11 <ddarius> It still holds when null xs is true.
17:30:15 <desp> ddarius: doh
17:31:14 <ddarius> Toxaris: Now do it without using pairs.
17:32:13 <desp> hrm
17:32:29 <desp> I need to discover an arithmetic sequence in an ordered list
17:32:46 <desp> a non-contiguous one, though
17:33:15 <desp> ah, but just one sequence, not all possible ones, that simplifies things.
17:33:19 <desp> n/m.
17:33:20 <desp> :)
17:33:38 <Toxaris> > (!! 1) . scanr (:) [] $ [1, 2, 3] -- just without pairs, or without any intermediate structures?
17:33:40 <lambdabot>  [2,3]
17:34:11 <ddarius> I believe there is a higher order version.
17:35:55 <sfultong> > iterate (>>= return) (return 5) !! 100
17:35:55 <lambdabot>   add an instance declaration for (Show (m a))
17:36:03 <sfultong> > iterate (>>= Just) (return 5) !! 100
17:36:04 <lambdabot>  Just 5
17:38:05 <sfultong> > iterate (>>= return) (Just Nothing) !! 100
17:38:06 <lambdabot>  Just Nothing
17:38:12 <shapr> Silly question, how do I dump a value :: Xml from HaXml to text?
17:43:11 <monochrom> Does "show" work?
17:43:21 <shapr> Nah
17:43:28 <shapr> Seems I need to use render.
17:44:03 <psykotic> > let tail :: [a] -> [a] ; tail xs = foldr (\x f g -> f (\xs xs' -> g (x:xs) xs)) (\f -> f [] []) xs (\xs xs' -> xs') in tail [1,2,3,4]
17:44:05 <lambdabot>  [2,3,4]
17:44:23 <psykotic> ddarius, was that what you had in mind?
17:44:46 <psykotic> it's essentially just a church encoding of the pair version
17:45:18 <LoganCapaldo> psykotic gets clever points from me
17:45:22 <LoganCapaldo> psykotic++
17:45:39 <ddarius> psykotic: I was wondering if there was a different way, but I did realize the Church encoding way was always available.
17:45:57 <ddarius> I can't recall if the ones I saw years ago were just the Church encoded variant.
17:46:32 <ddarius> LoganCapaldo: Church encoding is pretty straightforward once you see it.
17:46:50 <ddarius> It's even easy to arrive at if you think CH.
17:47:03 <LoganCapaldo> CH?
17:47:15 <wli> Curry-Howard
17:47:20 <LoganCapaldo> ohah
17:48:42 <ddarius> Alternatively, it could be arrived at from the continuity properties of exponentials.
17:49:20 <oerjan> @remember ddarius Alternatively, it could be arrived at from the continuity properties of exponentials.
17:49:20 <lambdabot> Done.
17:52:19 <desp> @hoogle (a -> [a] -> b) -> [a] -> [b]
17:52:19 <lambdabot> No matches, try a more general search
17:52:40 <LoganCapaldo> @hoogle a
17:52:40 <lambdabot> Data.Graph.Inductive.Example.a :: Gr Char ()
17:52:40 <lambdabot> Array.accum :: Ix a => (b -> c -> b) -> Array a b -> [(a, c)] -> Array a b
17:52:40 <lambdabot> Array.accumArray :: Ix a => (b -> c -> b) -> b -> (a, a) -> [(a, c)] -> Array a b
17:52:50 <LoganCapaldo> General enough for you???
17:52:56 <desp> looking for something like map, but with the function operating on both the head and the tail
17:53:12 <tomppa> Quick question about hierarchical module names: I have a file Foo/Bar.hs and when I try to compile it with ghc --make Foo.Bar -main-is Foo.Bar -o test I get complaint that " no output will be generated because there is no Foo module."
17:53:35 <desp> probably  map2 (\x xs -> x : xs) == tails
17:54:01 <ddarius> Wow.  An exported top-level function named 'a'... I think they were right about us.
17:55:03 <sorear> desp: (map .) . tails
17:55:36 <desp> @type (map .) . tails
17:55:39 <lambdabot>     Couldn't match expected type `a1 -> a -> b'
17:55:40 <lambdabot>            against inferred type `[[a2]]'
17:56:05 <psykotic> @type \f -> snd . foldr (\x (xs, y) -> (x:xs, (f x xs):y)) ([], [])
17:56:07 <lambdabot> forall a a1. (a -> [a] -> a1) -> [a] -> [a1]
17:56:23 <oerjan> :t (. tails) . (map .)
17:56:25 <lambdabot> forall a a1 b. ([[a]] -> a1 -> b) -> [a] -> [a1] -> [b]
17:56:38 <Toxaris> > foldr (\x y f -> f (x : y const) (y const)) (\f -> f [] (error "empty list")) [1, 2, 3] (const id)
17:56:40 <lambdabot>  [2,3]
17:56:53 * Toxaris has found it, too :)
17:57:09 <oerjan> :t (. tails) . map
17:57:11 <lambdabot> forall a b. ([a] -> b) -> [a] -> [b]
17:57:29 <oerjan> that's it, i think
17:57:48 <desp> no, psykotic's one has the right type
17:58:05 <desp> but I'm stil trying to read it
17:59:10 <psykotic> desp: as your foldr "state" you have both the tail and the partial result for the tail. then you just update the state in your folding function, and take the "partial result" using the snd (which is now the complete result) at the end
18:01:04 <desp> psykotic++
18:03:07 <desp> > let map2 f = snd . foldr (\x (xs, ys) -> (x : xs, (f x xs) : ys)) ([], []) in map2 (:) [1, 2, 3]
18:03:08 <lambdabot>  [[1,2,3],[2,3],[3]]
18:03:17 <desp> > tails [1, 2, 3]
18:03:18 <lambdabot>  [[1,2,3],[2,3],[3],[]]
18:03:31 <psykotic> hmm
18:03:41 <desp> that's fine with me
18:04:05 <psykotic> here's another version
18:04:08 <olsner> > let map2 f = snd . foldr (\x (xs, ys) -> (x : xs, (f x xs) : ys)) ([], [[]]) in map2 (:) [1, 2, 3]
18:04:09 <lambdabot>  [[1,2,3],[2,3],[3],[]]
18:04:27 <desp> ;)
18:04:43 <psykotic> :t \f xs -> map (uncurry f) (zip xs (tails xs))
18:04:45 <lambdabot> forall c a. (a -> [a] -> c) -> [a] -> [c]
18:05:20 <desp> heh!
18:05:27 <olsner> that's almost readable!
18:05:41 <olsner> @pl \f xs -> map (uncurry f) (zip xs (tails xs))
18:05:41 <lambdabot> (. ap zip tails) . map . uncurry
18:05:58 <psykotic> :t \f -> map (uncurry f) . uncurry zip . id &&& tails
18:06:01 <lambdabot>     Couldn't match expected type `([a], [b])'
18:06:01 <lambdabot>            against inferred type `[a1]'
18:06:02 <olsner> @type (. ap zip tails) . map . uncurry
18:06:04 <lambdabot> forall a c. (a -> [a] -> c) -> [a] -> [c]
18:06:46 <psykotic> :t \f -> map (uncurry f) . uncurry zip . (id &&& tails)
18:06:48 <lambdabot> forall c a. (a -> [a] -> c) -> [a] -> [c]
18:07:01 <desp> no.
18:07:07 <desp> :)
18:07:11 <psykotic> hehe
18:07:17 * psykotic goes golfing
18:07:26 <desp> that was fun
18:07:59 <sorear> @users
18:07:59 <lambdabot> Maximum users seen in #haskell: 385, currently: 337 (87.5%), active: 17 (5.0%)
18:09:30 <chessguy> hm, this is really good stuff: http://video.google.com/videoplay?docid=-4167170843018186532
18:09:31 <lambdabot> Title: Faith, Evolution, and Programming Languages
18:10:22 <chessguy> what's the notation that he uses at the beginning? it looks useful
18:10:23 <Toxaris> > (\f -> map (\(x:xs) -> f x xs) . init . tails) (,) [1, 2, 3]
18:10:25 <lambdabot>  [(1,[2,3]),(2,[3]),(3,[])]
18:11:05 <jfredett> chessguy: you mean that notation for logic?
18:11:10 <chessguy> jfredett, yes
18:11:19 <ddarius> > transpose (tails [1,2,3]) -- desp
18:11:20 <lambdabot>  [[1,2,3],[2,3],[3]]
18:11:22 <jfredett> i dont know- but it is pretty handy
18:11:30 <desp> ddarius: huh?
18:11:50 <jfredett> it appears that its a given over derived ish thing, like the dependent type notation in Epigram
18:12:14 <desp> ddarius: what are you trying to tell me?
18:12:28 <sfultong> chessguy: already it seems more interesting than the bjarne stroustrop video I watched a bit of today
18:12:46 <jfredett> i still need to watch the other half of SPJ's OSCON vid
18:12:54 <oerjan> > transpose (inits [1,2,3])
18:12:55 <jfredett> it was entertaining watching him jump around
18:12:56 <lambdabot>  [[1,1,1],[2,2],[3]]
18:12:56 <jfredett> :)
18:13:04 <psykotic> chessguy, could you give a more concrete time in the video?
18:13:52 <sfultong> for some people you can just tell they are of good character by their mode of ambulation
18:13:58 <desp> jfredett: I rather enjoyed his reaction when someone asked a question reducible to the halting problem
18:14:01 <chessguy> psykotic,  07:14, for example
18:14:05 <jfredett> yah
18:14:26 <psykotic> chessguy, what part of the notation? the vertical line? it just stands for a "hypothesis/conclusion" relation
18:14:32 <jfredett> he's just.. so... chipper!
18:14:54 <chessguy> and then there's also the notation at 12:15, which i'm not sure if it's different or not
18:14:57 <geezusfreeek> yeah, spj is entertaining
18:15:16 <psykotic> chessguy: it's exactly the same
18:15:35 <psykotic> chessguy, the "vertical bar" can link any judgements. type judgements, proposition truth judgements, etc
18:15:40 <chessguy> well, then what's the |A|...B
18:15:48 <chessguy> or whatever
18:15:50 <psykotic> [x : A] stands for a discharged assumption
18:15:57 <psykotic> the ... stands for an elided proof from hypothesis x : A
18:16:39 <chessguy> discharged?
18:17:07 <psykotic> it essentially means that the elided proof can just it as an assumption but it's been "discharged" from the set of obligations from the proof at large
18:17:15 <psykotic> err, can just use it
18:17:28 <psykotic> it's a "scoped" assumption if you will
18:17:28 <Toxaris> "it's like 'what part of no can you not understand'" :)
18:17:36 <psykotic> it's equivalent to \x : A -> ... in lambda calculus
18:18:09 <chessguy> psykotic, so it's like "given x : A ..."?
18:18:18 <psykotic> right, but the "given" is scoped to the ...
18:19:43 <psykotic> just like in (\(x :: A) -> ...foo...) ...bar... you can only "use" that x has type A inside the ...foo...
18:19:48 <psykotic> in haskell terms
18:20:33 <olsner> sfultong: hehe, see what you mean there by mode of ambulation
18:20:44 <psykotic> the thing he's talking about there is the introduction rule for implications in propositional logic. the point is that to prove A => B, you prove B in a "proof environment" where A is assumed; in fact, you have an "anonymous proof" x of A.
18:21:14 <ddarius> Toxaris: That is why we love Wadler.
18:23:17 <psykotic> energetic mode of ambulation and lambda calculus go hand in hand
18:24:23 <olsner> writing all that C++ code has left its marks, it seems
18:25:58 <sfultong> I wonder how he sleeps at night :-P
18:26:07 <desp> actually, that's the right version:
18:26:15 <desp> > let map2 f xs -> map (uncurry f) (zip xs (tail $ tails xs)) in map2 (:) [1, 2, 3]
18:26:15 <lambdabot>  Parse error
18:26:23 <desp> > let map2 f xs = map (uncurry f) (zip xs (tail $ tails xs)) in map2 (:) [1, 2, 3]
18:26:25 <lambdabot>  [[1,2,3],[2,3],[3]]
18:28:39 <desp> or the other way around
18:37:52 <wli> What would be good programming exercises to learn how to use arrows?
18:40:18 <desp> haha! solved problem 49
18:40:27 <wli> desp: Problem 49 of what?
18:40:34 <desp> of projecteuler.net
18:44:14 <Toxaris> we need Math.Prime.primes :: [Int] for these projecteuler stuff
18:45:08 <desp> @hoogle qsort
18:45:08 <lambdabot> No matches found
18:45:30 <desp> hrm
18:45:42 <desp> there's an awfully short Haskell solution for p49 using qsort
18:45:59 <desp> but I don't really suppose this is quicksort
18:46:07 <desp> because that doesn't make sense...
18:46:12 <Toxaris> :)
18:46:34 <desp> is there a qsort function in the std lib?
18:46:35 <merus> I should really get around to doing Project Euler.
18:46:39 <desp> also qsortBy
18:46:47 <Toxaris> a short Haskell solution would use Prelude.sort, because it's built in?
18:46:47 <desp> @index qsort
18:46:48 <lambdabot> bzzt
18:46:55 <ddarius> @index sort
18:46:56 <lambdabot> Data.List
18:47:20 <SamB> there is also sortBy
18:47:56 <LoganCapaldo> sortBy theWay
18:49:02 * Toxaris decides to do p49 to have a look at the "awfully short Haskell solution"
18:49:24 <desp> well, the one in question doesn't seem to typecheck
18:50:09 <hpaste>  desp pasted "supposed solution (spoiler!)" at http://hpaste.org/2242
18:51:15 <ddarius> Big fan of the superfluous parens, eh?
18:52:13 <pgavin> isn't MaybeT in the standard library?
18:52:27 <LoganCapaldo> @index MaybeT
18:52:27 <lambdabot> bzzt
18:52:34 <pgavin> hrmm
18:52:46 <pgavin> but ListT definitely is
18:52:50 <pgavin> @index ListT
18:52:50 <lambdabot> Control.Monad.List, Control.Monad.List, Language.Haskell.TH.Syntax, Language.Haskell.TH
18:52:56 <LoganCapaldo> I still think Bzzt would be a hot name for a Haskell lib
18:53:09 <LoganCapaldo> import Bzzt ( MaybeT )
18:53:55 <pgavin> every other code example you see about monad transformers starts with MaybeT and works up from there
18:54:03 <LoganCapaldo> Whose with me?
18:54:09 <mrd> IceT perhaps
18:54:18 <LoganCapaldo> GreenT
18:54:26 <pgavin> MushroomT
18:54:27 <pgavin> oops
18:54:27 <ddarius> AkaiOcha
18:54:31 <hpaste>  desp pasted "my solution (spoiler!)" at http://hpaste.org/2243
18:54:44 <desp> comments?
18:54:57 <LoganCapaldo> There's a project Euler lib?
18:55:05 <LoganCapaldo> Somehow I'm not surprised
18:55:12 <desp> LoganCapaldo: it's mine.
18:55:22 <LoganCapaldo> ahar
18:55:33 <LoganCapaldo> it
18:55:39 <shapr> Does the Project Euler lib include solutions to the various problems?
18:55:47 <ddarius> map (uncurry f) . zip still equals zipWith f
18:56:03 <desp> err.
18:56:09 <Toxaris> import Contest.Euler.Prob49(solve)
18:56:10 <LoganCapaldo> when you're right, you're right
18:57:00 <LoganCapaldo> instance Num EulerSolution where ...
18:57:02 <desp> @pl mapHdAndTl f xs = zipWith f xs (tails $ tail xs))
18:57:02 <lambdabot> (line 1, column 49):
18:57:02 <lambdabot> unexpected ")"
18:57:02 <lambdabot> expecting variable, "(", operator or end of input
18:57:09 <LoganCapaldo> 49 :: EulerSolution
18:57:20 <desp> @pl mapHdAndTl f xs = zipWith f xs (tails $ tail xs)
18:57:20 <lambdabot> mapHdAndTl = (`ap` (tails . tail)) . zipWith
18:57:57 <desp> hmm. no.
18:58:26 <oerjan> desp: tail . tails
18:58:36 <LoganCapaldo> :t tail . tails
18:58:38 <lambdabot> forall a. [a] -> [[a]]
18:58:43 <desp> oerjan: why?
18:59:09 <ddarius> > tail . tails $ []
18:59:10 <lambdabot>  []
18:59:14 <ddarius> > tails . tail $ []
18:59:16 <lambdabot>  Exception: Prelude.tail: empty list
18:59:22 <oerjan> oh, maybe it's the same in this case
18:59:36 <desp> ah.
19:00:23 <oerjan> or not
19:02:15 <kpreid> I've heard that ap is the S combinator. This is only true for the monad (e ->), right?
19:02:22 <oerjan> right
19:04:09 <ddarius> :t liftM ($)
19:04:12 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m (a -> b)
19:06:25 <oerjan> @pl liftM ($)
19:06:26 <lambdabot> id
19:06:42 <ddarius> As well it should as fmap id should equal id
19:10:58 <gmh33> isp]
19:15:26 <ddarius> > transpose . transpose $ []
19:15:34 <lambdabot>  []
19:15:52 <ddarius> > transpose . transpose $ [[]]
19:15:53 <lambdabot>  []
19:21:57 <chessguy> @src liftM
19:21:58 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:23:06 <desp> @unpl ((==) =<< f)
19:23:07 <lambdabot> (f >>= (==))
19:23:13 <desp> hahar.
19:23:35 <desp> what the hell does this do?
19:23:36 <desp> :)
19:23:59 <oerjan> :t \f -> f >>= (==)
19:24:01 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
19:24:42 <desp> :t \f x -> f x == x
19:24:44 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
19:24:54 <desp> @pl \f x -> f x == x
19:24:54 <oerjan> that's probably it
19:24:54 <lambdabot> ((==) =<<)
19:25:06 * shapr decides to solve Project Euler problems...
19:25:09 <desp> hmm
19:25:25 <oerjan> ah, @pl knows
19:25:26 <Nucleo_> some of the later problems are bloody difficult
19:26:04 <desp> ahh.
19:26:07 <shapr> Nucleo_: Have you solved them all?
19:26:08 <desp> @pl \x -> f x == x
19:26:09 <lambdabot> (==) =<< f
19:26:15 <desp> gotcha
19:26:28 * desp resolves never to use @pl to encode code again
19:26:32 <psykotic> augustss, very nice hack in your latest blog entry
19:26:45 <Nucleo_> shapr: nowhere close. I'm ~60 percent.
19:27:14 <shapr> Nucleo_: How much time have you spent working on it?
19:27:26 <Nucleo_> Hm, about a month or so.
19:27:57 <Nucleo_> anyway, it's a good excuse to learn more number theory
19:28:04 <shapr> Yeah, I like number theory.
19:29:51 <ddarius> > let fixes = ((==) =<<) in join (*) `fixes` 1
19:29:53 <lambdabot>  True
19:29:53 <desp> it's a good excuse to learn more haskell!
19:29:56 <desp> :)
19:30:01 <desp> thanks, lambdabot
19:31:11 <Nucleo_> Oh, I'm learning Haskell exclusively by solving those problems.
19:31:58 * Toxaris solved problem 49, too
19:33:41 <oerjan> > map (elem =<< sum) [[1,2,3], [-1,0,1]]
19:33:43 <lambdabot>  [False,True]
19:33:50 * shapr has only solved three so far
19:34:11 * olsner is at five
19:34:25 * wli hasn't paid attention.
19:34:30 <olsner> of course, that's starting with the easy ones
19:34:35 <desp> 44
19:34:48 <desp> Toxaris: show me? :)
19:35:49 <shapr> Isn't there an iterateWhile or iterateUntil ?
19:36:12 <hpaste>  Toxaris annotated "my solution (spoiler!)" with "another solution (spoiler! again)" at http://hpaste.org/2243#a1
19:36:28 <oerjan> shapr: takeWhile p . iterate
19:36:38 <desp> gah
19:36:40 <Toxaris> shapr: takeWhile predicate . iterate ?
19:36:44 <shapr> Ah, thanks.
19:37:49 <ddarius> :t takeWhile ?p . iterate
19:37:54 <lambdabot>     Couldn't match expected type `[a]'
19:37:54 <lambdabot>            against inferred type `a1 -> [a1]'
19:38:15 <ddarius> (takeWhile ?p .) . iterate
19:38:19 <ddarius> :t (takeWhile ?p .) . iterate
19:38:21 <lambdabot> forall a. (?p::a -> Bool) => (a -> a) -> a -> [a]
19:38:25 <desp> Toxaris: wow.
19:38:36 <Toxaris> desp: we should combine your primes and my solve
19:39:08 <ddarius> Toxaris: Why not a list comprehension?
19:39:34 <oerjan> @pl \p f -> takeWhile p . iterate f
19:39:34 <lambdabot> (. iterate) . (.) . takeWhile
19:39:41 <oerjan> @pl \f p -> takeWhile p . iterate f
19:39:42 <lambdabot> flip ((.) . takeWhile) . iterate
19:40:13 <Toxaris> ddarius: can I use let in list comprehensions?
19:40:19 <ddarius> Toxaris: Yes.
19:40:39 <Toxaris> > [x | let y = 3, x <- [y .. 5]]
19:40:41 <lambdabot>  [3,4,5]
19:41:27 <Toxaris> ddarius: so list comprehensions are fully equivalent to do notation for the list monad?
19:41:29 <chessguy> wow, i can't believe Wadler just ripped open his shirt to show a lambda calculus t-shit
19:41:39 <chessguy> rofl
19:41:41 <shapr> When was that?
19:41:48 <chessguy> at the end of his lecture
19:41:52 <chessguy> http://video.google.com/videoplay?docid=-4167170843018186532
19:41:52 <lambdabot> Title: Faith, Evolution, and Programming Languages
19:42:23 <chessguy> that's awesome
19:42:26 <oerjan> Toxaris: essentially
19:42:37 <wli> That's awesome indeed.
19:43:02 <merus> chessguy: thanks for teh link.
19:43:31 <chessguy> merus, it's an awesome lecture, and that bit at the end is an awesome way to cap it off
19:43:37 <merus> I wish the resolution was better, but it's the internet, I suppose.
19:43:40 <merus> *were
19:44:07 <Toxaris> ddarius: i like list comprehensions for their "functional feal", but for the task at hand, the order of actions is important for performance (test as early as possible), so the step-for-step aproach of the do-notation seems approbiate. why do you think I should use a list comprehension here?
19:44:40 <Toxaris> "functional feel" of course
19:45:47 <Toxaris> (yes, list comprehensions are step-for-step, too, but they resemble set comprehensions, wich are not, so my mind is not switched to "step-for-step"-evaluation when looking at them, but to "all-at-once"-evaluation)
19:45:54 <desp> chessguy: rotfl
19:46:17 <chessguy> desp, isn't that freaking awesome?
19:46:22 <desp> indeed
19:47:14 <desp> I want a shirt like that
19:48:25 <wli> Most of the projecteuler problems' solutions I just hammer into ghci rapid-fire.
19:48:46 <olsner> so many problems are brute-forcable
19:48:47 <olsner> it seems
19:49:01 <wli> olsner: Basically yeah.
19:49:06 <desp> olsner: initially
19:49:15 <ddarius> Toxaris: List comprehensions would make those guards prettier and be a bit more tight.
19:49:30 <olsner> well, I started about 15-20 minutes ago, so I've only gotten to the simpler problems
19:49:36 <ddarius> That said, I'm not a big fan of list comprehensions and was more wondering whether you considered them.
19:51:02 <Toxaris> ddarius: yes, I had list comprehensions in at some previous version, but kicked them out when I realized that evaluation order is important for performance. the guard would look much better if I had defined or used a function digits :: Int -> [Int], i think
19:51:35 <desp> Toxaris: and I was so proud of my arithmetic sequence finder, too
19:51:38 <desp> :C
19:52:51 <Toxaris> I find list comprehensions most usefull to show non-Haskellers how nice this language is where you can just type what you mean. oh, and the uniplate paper has some very nice examples of list comprehensions, but i've not yet used uniplate, so they may prove sensefull outside of papers or not
19:53:24 * ddarius endeavors to use :C or :D as the command to exit any interactive console program he develops depending on how much he likes the program.
19:53:52 <olsner> digits = map digitToInt . show
19:54:00 <newsham> hi
19:54:29 <Nucleo_> Toxaris: and then one realizes that later on, it's all sugar for the list monad. ;)
19:54:32 <newsham> tox: that doesnt work as well for python coders
19:55:25 <newsham> http://www.thenewsh.com/%7Enewsham/formal/reverse/
19:55:27 <lambdabot> Title: Formal methods: Reverse
19:55:36 <Toxaris> newsham: I would show phyton coders the speed of an Haskell program compiled with ghc -O2
19:55:59 <newsham> hopefully for a program that doesnt use [Char] ;-)
19:56:20 <psykotic> haskell programs can easily be much slower than python ones if you have space leaks :)
19:56:38 <Toxaris> psykotic: why should I use a leaky program as showcase example?
19:56:44 <psykotic> i remember some (competent) attempts at implementing norvig's spell checker in haskell that were a thousand times slower than the python one
19:56:48 <psykotic> hehe :)
19:58:27 <Toxaris> but seriously, I never tried to convince FP folk to use Haskell, but tried with some non-FP folk, and there, expressivenes is the feature I can show in some minutes time
19:59:22 <newsham> and then they get all excited and start learning haskell and ask how to write a small network server, and their eyes glaze over as you start explaining IO monad
19:59:46 <ddarius> @google Webserver Haskell Peyton Jones
19:59:48 <lambdabot> http://research.microsoft.com/~simonpj/papers/marktoberdorf/
19:59:48 <lambdabot> Title: Simon Peyton Jones: papers
20:00:13 <Toxaris> I had a lecture about optimizing compilers last term, and we spent half of the time expressing pseudo code as Java code. With Haskell, we could have used the pseudo code as-is. But no, "I cannot use some fancy language if I want any students to attend my course, so go on and do your homework in Java".
20:00:16 <shapr> My girlfriend wasn't overly excited about Haskell, but she was horrified by Python.
20:00:49 <desp> 'night
20:01:00 <newsham> i think i could teach a non programmer basic python really easily
20:01:12 <desp> shapr: oh, this is interesting. why was she?
20:01:20 <Nafai> I can't even imagine trying to teach my wife programming in any language
20:01:25 <pjd> shapr: horrified?
20:01:26 <newsham> i could teach a math oriented non programmer non-monad haskell (ie. two-dozen short lessons) really easy too, I guess
20:01:42 <ddarius> newsham: For meaningful values of "basic", I doubt it.
20:01:50 <newsham> but I think most people who dont think about programs much would get a little beaten down learning real haskell as a first language
20:02:00 <merus> newsham: I disagree.
20:02:02 <newsham> ddarius: ok, we disagree.
20:02:13 <ddarius> newsham: I doubt it.
20:02:16 <chessguy> i disagree that you disagree
20:02:19 <newsham> merus: I feel beaten down all the time, and I've been programming all my life :)
20:02:26 <merus> teaching non-monad haskell seems to me more complicated than teaching monad haskell.
20:02:43 <Nafai> It would be a long time before I could teach Haskell to a non-programmer
20:02:47 <ddarius> newsham: You believe you can teach programming easily?
20:02:51 <Nafai> I would need to understand it a great deal more
20:03:01 <merus> Beginning programmers want to do I/O. There is a tutorial in Haskell that follows this line of thought.
20:03:08 <newsham> ddarius: yah.  i've taught my non-technical wife some simple python
20:03:12 <merus> *tutorial of Haskell is perhaps more accurate.
20:03:34 <newsham> anyway, this is starting to develop into an argument and I'm not really interested in arguing.
20:03:43 <ddarius> newsham: Can she use it for much more than a glorified calculator?
20:03:55 <Cale> Haskell is a nice first programming language because you can largely think of evaluation in the same way that you think about it in mathematics.
20:04:12 <newsham> cale: some people are horrified of math.
20:04:18 <chessguy> Cale, that is nice.....if you're a mathematician
20:04:23 <newsham> cale: for math-minded people I largely argree.
20:04:26 * littledan tried to learn to program from A Gentle Introduction to Haskell but failed miserably (but picked it up a but later)
20:04:26 <Adamant> the problem is that many people don't like to think of math
20:04:27 <wli> I was about to say.
20:04:27 <ddarius> newsham: some people are horrified or haskell
20:04:33 <Toxaris> merus: why do you think that beginners want to do IO?
20:04:34 <Cale> Well, everyone's done grade 9 algebra :)
20:04:35 <reltuk> anyone recommend a good introduction to space leaks in haskell?
20:04:46 <ddarius> Cale: No they haven't.
20:04:55 * wli remains baffled by arrows.
20:04:58 <xpika> it takes a while to learn to read forall a b. m a -> (a -> m b) -> m b
20:05:00 <Adamant> because you can do IO easily in most other languages
20:05:01 <Cale> ddarius: Well, perhaps the very young haven't :)
20:05:02 <merus> Toxaris: Ease of interaction.
20:05:18 <Cale> It's not like IO is hard in Haskell.
20:05:20 <newsham> cale: if i explain anything to my wife using anything that sounds like math terminology she will shut down and ignore everything I say
20:05:33 <wli> There's something very powerful there if I can only figure out how to use it.
20:05:35 <Adamant> it's not, but it takes a bit to understand
20:05:36 <merus> No need to learn a GUI API, etc.
20:05:36 <newsham> but if on the other hand I sneak it in by describing it in common sense terms she usually gets it
20:05:42 <xpika> type theory is the hard part
20:05:49 <wli> newsham: Most people are like that.
20:05:52 <ddarius> wli: I never use arrows.
20:05:58 <newsham> (ie. explaining expectation in poker...)
20:05:59 <merus> Damn fear of mathematics.
20:06:05 <newsham> wli: yah, thats what I'm trying to say :)
20:06:28 <wli> Most people aren't (and shouldn't be) programmers, though.
20:06:36 <Toxaris> if I were to teach programming to beginners, I would at least try Haskell
20:06:41 <merus> No, no, no.
20:06:44 <Cale> Well, computer science isn't for people who don't want anything to do with mathematics :)
20:06:47 <newsham> most people can benefit from a superficial understanding of what programming is
20:06:55 <Korollary> reltuk: see the performance section on the wiki
20:06:56 <newsham> even if they never write a program
20:06:58 <Adamant> definitely, Cale
20:07:04 <merus> Programming isn't a sacred art to be performed by the elite, and certainly mathematics isn't.
20:07:29 <ddarius> merus: What makes you think the elite perform either of those?
20:07:30 <wli> merus: That's scarcely what I'm on about.
20:07:45 <newsham> also computer science is filled with people who dont want anything to do with mathematics.
20:07:46 <Cale> merus: Sure, but if people are going to shun mathematics altogether, I don't imagine they'll have a good time programming.
20:07:46 <SamB_XP> so what is a suitable euphemism for "theorem"?
20:07:48 <merus> wli: It's the direction you're heading.
20:07:54 <newsham> and society needs them (despite their poor coding skills)
20:07:55 <merus> Cale: That's true enough.
20:07:59 <Toxaris> but I would try to find interesting examples wich can be done without too much IO. where the IO/pure frontier is easily seen even by beginners.
20:08:01 <ddarius> SamB_XP: Suitable for who? "result"?
20:08:18 <SamB_XP> ddarius: suitable for sneaking past mathophobes ;-P
20:08:19 <ddarius> merus: That's not how I'm reading him at all.
20:08:23 <wli> merus: Not at all. Heck, most people wouldn't want to be programmers.
20:08:39 <newsham> (also I know some good programmers who arent any good at math..  it happens)
20:08:48 <Cale> Then again, I like to tell people that what they saw in highschool isn't really very much like what mathematicians do at all.
20:08:58 <merus> Cale: Totally.
20:09:09 <Cale> I have the feeling that if they actually taught mathematics in school, far more people would enjoy it.
20:09:18 <SamB_XP> yes!
20:09:20 <wli> Cale: I tell them "it's a lot more like philosophy."
20:09:21 <newsham> cale: I think most people who took geometry in high school hated it more than their other math courses
20:09:26 <merus> Cale: The New Math movement kind of killed that chance.
20:09:33 <merus> newsham: I get the opposite response.
20:09:40 <SamB_XP> I want the Old Math movement
20:09:41 <merus> Cale: At least in the US.
20:09:53 <Toxaris> merus: what's that movement about?
20:09:56 <newsham> merus: meaning most people say it was their favorite?  or you say it was your favorite?
20:10:00 <ddarius> newsham: What's your point?
20:10:12 <merus> newsham: Meaning people tell me they liked geometry over algebra.
20:10:13 <wli> merus: The US is beyond hope anyway. It's all geared toward deliberate Thirdworldization anymore.
20:10:19 <newsham> ddarius: I'm responding to cale's remark about high school math
20:10:26 <ddarius> newsham: I know.
20:10:32 <newsham> so thats my point.
20:10:45 <newsham> merus: are these people who ended up in math?  or is this a pretty diverse sample?
20:10:47 <Cale> Uh, what is that supposed to indicate though?
20:10:59 <Cale> (newsham's remark about the geometry section)
20:11:02 <reltuk> Korollary: so a space leak is just when your program builds up giant thunks without evaluating anything, and it would have been much faster to be evaluating things along the way?
20:11:05 <merus> newsham: Usually because it felt like they were "doing something", which is mostly the same reason I think it's important to teach I/O in computer languages.
20:11:09 <ddarius> newsham: What you seem to be saying is that they didn't like geometry so they won't like "real" math.
20:11:24 <merus> newsham: they're people I graduated from secondary with. Most of them didn't go to college.
20:11:25 <newsham> cale: that if you're telling people who dont like math "oh, but math is really not like tha algebra stuff you took, its more like that geometry stuff you took" then they might dislike it more :)
20:11:35 <Cale> newsham: I never said that.
20:11:35 <chessguy> my brother tried to convince me the other month that algebra isn't "real math"
20:11:40 <ddarius> newsham: You're completely interpolating that last part.
20:11:44 <Cale> newsham: It's nothing like anything which they took.
20:11:52 <littledan> I like how Clean lets you write little toy programs where main :: Int (or something like that), which just outputs the integer, which is good for learning
20:11:53 <newsham> of course merus's experience contradicts mine
20:12:00 <ddarius> chessguy: Surely you set him straight.
20:12:04 <SamB_XP> chessguy: did you disprove this using Euclid?
20:12:05 <littledan> (but that's not really a language feature)
20:12:05 <Cale> Well, it's closer to music or classical art, if they took those.
20:12:12 <newsham> and my sample size is small..  so I guess I can toss that one out
20:12:29 <Korollary> reltuk: Right
20:12:34 <Toxaris> littledan: is that different from evaluating a function in an interpreter like ghci?
20:12:40 <newsham> heh, math is like music....
20:12:43 <newsham> sure it is.
20:12:53 <ddarius> Korollary, reltuk: That's only one kind of space leak.
20:12:59 <dolio> Toxaris: It was an unsuccessful attempt to teach set theory to grade schoolers.
20:13:36 <littledan> Toxaris: well, it's just you can compile and run a program where main :: Int (or the clean equivalent) without any real modification. But I guess it's equivalent to ghci, just more substantiative-looking
20:13:37 <sorear> Math is everything that can be checked but not automated mechanically ;)
20:13:43 <merus> Toxaris: Yes, sorry, I got lost. There are remains of the New Math movement in US schools still; they teach commutativity and associativity, but no one remembers that.
20:13:46 <SamB_XP> dolio: what was unsuccesful about it?
20:13:57 <ddarius> sorear: Define "checked".
20:14:14 <sorear> ddarius: Formalizable?
20:14:17 <Nafai> chessguy: Did he say it wasn't "real math" because it isn't arithmetic?
20:14:25 <merus> SamB_XP: It alienated a lot of students who were caught in transition. Test scores fell, and in response the political people nixed it.
20:14:28 <chessguy> Nafai, yeah, that was the gist of his point
20:14:28 <newsham> I think "checked" is pretty obvious :)
20:14:35 <chessguy> well, "point"
20:14:37 <wli> dolio: Those bits of it were people flying off the handle. The real math people involved disapproved of many of those efforts.
20:14:52 <SamB_XP> merus: obviously they suck at rollout!
20:15:00 <ddarius> newsham: There are plenty of definitions of "checked" which would lead to his statement being not blatantly true at least.
20:15:02 <merus> SamB_XP: hehe. Well, yes.
20:15:11 <Nafai> chessguy: Heh.  I constantly tell my friends and family that *I* don't know real math even though I have a basic grasp of calculus and linear algebra
20:15:13 <ddarius> For "formalizable" it seems to be almost tautological.
20:15:25 <Toxaris> merus: ok that I know
20:15:27 <wli> There's actually some friend of mine who's been researching what went on wrt. the "New Math."
20:15:35 <chessguy> Nafai, i feel the same way, especially when watching lectures like the Wadler one i just saw
20:15:36 <Nafai> chessguy: i.e., I don't understand the formal stuff
20:15:38 <wli> And telling me in gory detail all the BS that went on.
20:15:39 <yetAnotherOne> > type H = a -> a -> Result
20:15:39 <lambdabot>  Parse error
20:15:41 <SamB_XP> you clearly can't expect people to have magically learned different stuff when you change the curriculum, so you have to do it one grade at a time
20:15:49 <sorear> I was trying for a funny definition...
20:15:51 <newsham> chess: online video lectures?
20:16:02 <sorear> I think algebra was probably considered much more "real math
20:16:04 <newsham> sorear: i liked your definition
20:16:12 <sorear> " in the pre-Gauss-Jordan days
20:16:16 <chessguy> newsham,  http://video.google.com/videoplay?docid=-4167170843018186532
20:16:16 <lambdabot> Title: Faith, Evolution, and Programming Languages
20:16:18 <littledan> I'm so glad I don't have to deal with the new math anymore
20:16:29 <newsham> chess: just the one or are there whole collections?
20:16:47 * sorear doesn't quite get what people have against axiomatic deduction systems
20:16:52 <chessguy> newsham, oh, i'm just talking about lectures like that in general
20:16:54 <ddarius> wli: It doesnt' really matter.
20:17:11 <newsham> chess: and I'm interested in knowing where I can find more :)
20:17:23 <wli> ddarius: Yeah, it's not like there's a future.
20:17:35 <dolio> SamB_XP: I don't know the details. Although I imagine people were miffed that their kids were being taught a bunch of abstract nonsense, instead of real stuff like arithmetic and whatnot.
20:17:51 <dolio> SamB_XP: Although, maybe the kids didn't pick it up well, either.
20:17:52 <ddarius> wli: Perception is reality.
20:17:52 <Toxaris> SamB_XP: where to draw the line? people need some years to learn counting and basic arithmetics, should set theory be introduced before they are ready to decide if (2/3 > or < then 3/4)?
20:17:58 <SamB_XP> oh, but they weren't being taught abstract nonsense
20:18:16 <SamB_XP> that would have been Much Cooler
20:18:25 <chessguy> newsham, have you seen these?
20:18:26 <chessguy> http://haskell.org/haskellwiki/Video_presentations
20:18:27 <lambdabot> Title: Video presentations - HaskellWiki
20:18:36 <newsham> I have not. thank you
20:19:07 <oerjan> yetAnotherOne: > only takes an expression
20:19:19 <ddarius> Toxaris: Huh?  What SamB_XP seemed to be saying was simply start at the lowest grade and "follow" the students up while keeping the same curriculum at higher grades until those students show up.
20:19:20 <dolio> SamB_XP: Set theory is close enough to abstract nonsese for most people. :)
20:19:29 <sorear> So why do we force kids to sit around for hours crunching rational inequalities?
20:19:40 <Toxaris> at the other hand, we learned no set theory at all before uni, but used sets of course. that wasn't the right thing, either.
20:19:48 <dolio> SamB_XP: Besides, it doesn't help you figure out how much to tip your waiter. :)
20:19:48 <chessguy> newsham, there's also http://lambda-the-ultimate.org/node/1303 which is about haskell syntax and semantics. a little dry, but maybe worthwhile for some
20:19:49 <lambdabot> Title: Haskell video lectures online | Lambda the Ultimate
20:19:49 <Cale> Toxaris: Set theory is a little low level, but some naive treatment is probably a good idea early on. Most people can reason about at least small collections of things. You can get away with a little bit of handwaving for countably infinite sets and sets whose cardinality is the same as the reals.
20:19:51 <ddarius> sorear: Cuz they'll remember (well enough) that way.
20:20:19 <wli> ddarius: I daresay otherwise. In any event.
20:20:21 <ddarius> Cale: Isn't that normally how set theory is introduced?
20:20:22 <SamB_XP> ddarius: but it's cruel and unusual punishment
20:20:28 * sorear didn't have to do a hundred pages of exercises to learn basic topology...
20:20:30 <Cale> I think we'd be better off if highschool mathematics covered the first 100 pages or so of Spivak.
20:20:35 <chessguy> newsham, and then there's the classic http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
20:20:38 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
20:20:40 <Cale> (Spivak's "Calculus", specifically)
20:20:47 <ddarius> sorear: Did I say anything about learning?
20:20:49 <SamB_XP> Cale: he wrote other books?
20:20:56 <merus> SICP++
20:20:56 <sorear> Ouch.
20:20:56 <Cale> yeah, some really good ones
20:21:00 <newsham> sorear: school has many purposes other than teaching you the topic that is explicitely being taught
20:21:05 <SamB_XP> that could be consider to be before the Calculus one, anyway?
20:21:10 <newsham> keeping people busy, getting them used to tedium, etc..  are also goals
20:21:13 <Cale> not really :)
20:21:23 <ddarius> newsham: socialization
20:21:28 <Toxaris> Cale: I'm not actually sure what I was answering. maybe my comment would have made more sense if not directed at SamB_XP directly...
20:21:39 <wli> newsham: Obedience training.
20:21:43 <Cale> There's "Calculus on Manifolds", as well as a series on differential geometry
20:21:45 <chessguy> newsham, also critical thinking
20:21:50 <chessguy> (at least in theory)
20:21:51 <newsham> never underestimate babysitting as a goal
20:22:45 <Toxaris> Cale, ddarius: I seem to have mixed your comments up, too. Seems that I'm just not able to follow the discussion :(
20:23:02 <newsham> <idle>wadler video...
20:23:10 <Cale> Another thing which really annoys me about pre-university mathematics is that it is taught from a very platonist viewpoint.
20:23:22 <SamB_XP> Cale: you mean there isn't enough sex?
20:23:30 <merus> Cale: Because most of the professors are Platonist.
20:23:36 <merus> Give us a generation.
20:23:46 <littledan> platonist in the sense of forms?
20:23:52 <Cale> littledan: yeah
20:23:56 <SamB_XP> oh, that
20:23:56 <sorear> There are no professors in my part of the world's pre-unis.
20:24:00 <wli> In a generation mathematics will scarcely be taught at al in the US.
20:24:16 <merus> Oh, I missed the pre-
20:24:19 <Cale> Like that there are absolute truths in mathematics.
20:24:23 <ddarius> platonist in the sense that they tie up and blind fold the students while facing their backs to a cave opening.
20:24:39 <SamB_XP> that made no sense to me... then again I'm fairly certain I understood the reading for my philosophy class better than the teacher did...
20:24:47 <littledan> pre-university mathematics the way I see it is too algorithms-based (like teaching people to follow these steps) without actually teaching understanding
20:24:48 <SamB_XP> and we didn't do reading for that one
20:24:56 <chessguy> Toxaris, this is a hard one to follow, don't feel bad
20:24:59 <merus> It'll take three generations to filter down into math education. Perhaps more, given that math education has become politicized.
20:25:10 <Cale> http://en.wikipedia.org/wiki/Platonism
20:25:11 <lambdabot> Title: Platonic realism - Wikipedia, the free encyclopedia
20:25:14 <newsham> "what part of 'no' dont you understand" -wadler
20:25:17 <littledan> wli: you think so? More and more high schoolers in the US are taking calculus
20:25:32 <merus> taking != understanding, sadly.
20:25:38 <chessguy> newsham, the last 3 seconds of the video are the best part :)
20:25:41 * ddarius understood calculus.
20:25:42 <wli> littledan: I think so, yes.
20:26:11 <wli> littledan: Watch the content, not the course names.
20:26:16 <chessguy> newsham, no skipping ahead is allowed though
20:26:20 <SamB_XP> merus: well surely the very fact that they're taking it will raise interest in teaching math reasonably...
20:26:21 <ddarius> wli: Why do you believe mathematics won't be taught?
20:26:40 <merus> SamB_XP: Yeah, perhaps.
20:26:42 <wli> ddarius: Social, economic, and political trends.
20:27:03 <SamB_XP> wli: you mean like the trend of americans being idiots?
20:27:20 <wli> SamB_XP: Far more specific.
20:27:23 <ddarius> wli: I think there's a decent majority of the electorate that would not accept that.
20:27:41 <SamB_XP> 'specially those as vote
20:28:57 <wli> In the face of a severe and protracted economic decline that will not be very large a concern.
20:29:09 <SamB_XP> oh, that
20:29:24 <SamB_XP> wait, how won't that be a concern?
20:29:28 <Toxaris> in germany, math is not something you take or don't take, math is something you have to take every term. wich is better (everyone see's some math every other day) and worse (teachers never get to tell you about advanced stuff because everyone asks questions about the basic stuff). atm, math (like in "math for engineering") is becoming more and more important, we are told every other day that our economics needs more engineers &c
20:29:38 <SamB_XP> won't that be why the economy has declined?
20:30:07 <wli> SamB_XP: No.
20:30:10 <SamB_XP> Toxaris: they should let you take different math if you want or something
20:32:15 <wli> SamB_XP: Moving university-like structure into the lower echelons might have been appropriate. Pass one course, move onto the next available. Credit by exam, signing up for more advanced material, etc. allowed. Go as high as you want.
20:33:28 <SamB_XP> that sounds about right
20:33:51 <ddarius> And about how it is now except (to an extent) the credit by exam part.
20:34:23 <SamB_XP> but what about those hall nazis!
20:35:35 <Toxaris> but are pre-uni students able or willing to live up to that freedom? education should be for everyone, not for these few who like to learn, are able to learn a lot and end up in #haskell
20:35:47 <Toxaris> SamB_XP: "hall nazis"?
20:36:11 <dolio> I'm pretty sure my high school wasn't like that, but perhaps mine was out of the ordinary.
20:36:21 <ClaudiusMaximus> hmm, ghci arrow type errors are hurting my head.  what do i need to do to 'run' an arrow (like the circuits in the arrow notation paper) and get out something i can print?
20:36:26 <SamB_XP> Toxaris: I don't think education works if you just make people shut up and "learn"
20:36:39 <dolio> Lots of graded homework and participation and whatnot.
20:36:48 <ddarius> SamB_XP: Arguably it does.
20:36:51 <dolio> And mandatory attendance, of course. :)
20:37:07 <SamB_XP> ddarius: it definately doesn't work too well for ADD people...
20:37:29 <SamB_XP> ddarius: they'll just spend the rest of the class period mad that you wouldn't let them speak!
20:37:30 <ddarius> ADD people were being taught before there -was- ADD.
20:38:18 <newsham> cool, aliens know lambda calculus
20:38:42 <ddarius> newsham: A little known fact: Alonzo Church was an alien.
20:38:44 <dolio> I don't recall my college handing out demerits/detention for being late to class, either. :)
20:39:12 <newsham> but his phd student, turing, was just gay?
20:39:40 <SamB_XP> x
20:39:51 <SamB_XP> dolio: that's the kinda stuff I meant about hall nazis
20:39:56 <ddarius> newsham: No.  He was manic-depressive too.
20:40:12 <SamB_XP> dolio: only it's not the teachers' faults...
20:40:15 <newsham> i think i would be depressed if i was gay in early 20th century england, too
20:41:28 <newsham> (or an alien)
20:41:54 <sfultong> ooo! did I miss a discussion on the merits of school?
20:42:14 <jcreigh> so Turing really was gay?
20:42:21 <jcreigh> Stephenson wasn't just making it up?
20:42:45 <merus> *blink*
20:42:52 <merus> Turing was gay. This is well known.
20:43:09 <newsham> http://en.wikipedia.org/wiki/Alan_Turing#Prosecution_for_homosexual_acts_and_Turing.27s_death
20:43:12 <lambdabot> http://tinyurl.com/47kug
20:43:14 <sfultong> is it just me, or are there a disproportionate number of transgendered programmers?
20:43:20 <Cale> ClaudiusMaximus: It's different depending on the individual arrow in question.
20:43:26 <ddarius> sfultong: It's just you.
20:43:36 <Toxaris> I wonder how computer science should be thaught at pre-uni education? practical stuff (how to use and program a computer), theoretical stuff (what is information, what is an algorithm, what is computable), not at all? I decided *not* to take computer science at school because it was lame.
20:43:43 <jcreigh> newsham: heh, I had just gotten to that exact URL right before you posted that.
20:45:24 <ClaudiusMaximus> Cale: i realize that.  any examples/tutorials you could recommend?
20:46:38 <Cale> hmm... I don't actually recall exactly which papers I read while learning about arrows
20:46:58 <ddarius> There's only like five.
20:47:02 <sfultong> I just read the haskell wiki today on arrows, and I found it quite enlightening
20:47:18 <Cale> heh, if that's the case, then it should be easy to find them :)
20:47:34 <Toxaris> > (head &&& tail) >>> first (+) >>> second head >>> app $ [5 ..] -- for the (->)-arrow, it's especially easy, since runArrow = ($)
20:47:35 <lambdabot>  11
20:47:44 <sfultong> I think a language should be made, based on arrows
20:48:01 <Toxaris> no side effects or fancy stuff, of course :(
20:48:04 <wli> I think more arrows tutorials should be made. ;)
20:48:04 <Cale> http://www.haskell.org/arrows/biblio.html -- this lists some papers
20:48:05 <lambdabot> Title: Arrows: bibliography
20:48:12 <newsham> there's a arrow do-notation
20:48:17 <newsham> embedded in the haskell language
20:52:03 <wli> Doesn't help me much if I can't figure out how to use it. :(
20:52:11 <yetAnotherOne> I tried to compile "type H = a -> Maybe String" which resultet in Not in scope: type variable `a'
20:52:54 <Toxaris> yetAnotherOne: maybe you mean  type H a = a -> Maybe String  ?
20:53:03 <newsham> section 4 shows an examle with do-notation http://www.haskell.org/haskellwiki/Arrow_tutorial
20:53:04 <lambdabot> Title: Arrow tutorial - HaskellWiki
20:53:24 <Toxaris> yetAnotherOne: wich would mean that  (H Int) is an abbreviation for  (Int -> Maybe String)
20:53:39 <yetAnotherOne> Toxaris: thanks
20:55:15 <ClaudiusMaximus> hmm, i think page 35 of Generalizing Monads To Arrows seems to be starting to get somewhere useful to me
20:56:09 <sfultong> arrows make monads seem awkward to me
20:56:31 <ddarius> sfultong: Why?
20:56:34 <oerjan> wli: http://haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
20:56:35 <lambdabot> Title: 7.7. Arrow notation, http://tinyurl.com/3297xy
20:56:45 <wli> I can't make heads or tails of arrows.
20:56:51 <merus> Dangit, you're making me want to go dig out the computer that has GHC on it.
20:59:32 <wli> I've seen the arrow notation bits. I was not enlightened.
20:59:35 <glguy> ?seen dons
20:59:36 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 15h 40m 5s ago.
20:59:37 <ddarius> Does Haskell support trailing ,s in module export lists?
20:59:52 <ddarius> wli: That's because it's unenlightening.
20:59:57 <glguy> ?seen sorear
20:59:57 <lambdabot> sorear is in #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell. I last heard sorear speak 36m 1s ago.
20:59:57 <sfultong> ddarius: I believe it's mostly intuition, but I think it may have something to do with my discomfort at (>>=) using functions from pure land to monad land
21:00:02 <sorear> pong
21:00:04 <glguy> ?seen shapr
21:00:04 <lambdabot> shapr is in #haskell, #haskell-blah and #scannedinavian. I last heard shapr speak 59m 49s ago.
21:00:16 <sorear> !paste
21:00:16 <hpaste> Haskell paste bin: http://hpaste.org/
21:00:21 <glguy> sorear: I was just catching up and saw that ErrantEgo was asking about palomer
21:00:21 <lambdabot> glguy: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:00:41 <sorear> glguy: you know him?
21:00:45 <ddarius> sfultong: View a -> m b as a "monadic expression" with a free variable of type a.
21:01:02 <shapr> glguy: yes?
21:01:03 <glguy> sorear: I have no idea who ErrantEgo is
21:01:07 <sfultong> also, I think I was about to reinvent arrows myself (in some sort of inferior way) before I discovered them
21:01:41 <shapr> glguy: I talked to palomer a bit in privmsg
21:01:43 * ddarius could make a really slick binding to LADSPA.
21:01:45 <sfultong> ddarius: yes, but I feel more comfortable with functions that have the same codomain as the domain
21:01:52 <sfultong> what's the math term for that...
21:01:57 <shapr> glguy: In short, he wants to come back, and says he'll be nice.
21:01:59 <glguy> sorear: I saw your message, I'll probably leave it alone
21:02:04 <ddarius> sfultong: endofunctions and I doubt that's what you mean.
21:02:16 <glguy> shapr: if he's allowed to come back, someone needs to remove his autoban
21:02:31 <glguy> shapr: and if someone wants to do that they should consult with dons, who seems to be the one tha placed it
21:03:04 <shapr> Yeah, I agree.
21:03:09 <shapr> I'm going to talk to dons when I see him next.
21:03:30 <glguy> sorear: but there is always the opportunity to fork
21:03:31 <glguy> :)
21:04:09 <sorear> glguy: uhm, you really think #haskell-with-100%-more-gschuett will catch on?
21:04:25 <sfultong> ddarius: well... maybe not, since I really don't know much about category theory... but a -> m a ... is that not not an endofunction?
21:04:25 <glguy> ?
21:04:47 <sfultong> or... exofunction, if you like less redundancy, I suppose
21:05:05 <ddarius> sfultong: Endofunction is not a categorical term.  And a -> b is not an endofunction for all a /= b.
21:05:44 <sorear> glguy: You were talking about forking, I was talking about gschuett's ban.  Miscommunication?
21:06:11 <glguy> sorear: I meant forking to remove the size limit :)
21:06:18 <sfultong> ddarius: damn... I wanted to sound smart, but it's hard when there are more knowledgeable people around
21:06:41 <glguy> @tell dolio that is a wonderful ruby example. Thanks for the ammo ;)
21:06:41 <lambdabot> Consider it noted.
21:07:11 <dolio> You're welcome. :)
21:07:28 <oerjan> sfultong: i think a -> m a  is an endomorphism in the kleisli category
21:07:51 <oerjan> *the set of endomorphisms
21:07:58 <oerjan> *a
21:08:01 <ddarius> oerjan: It is.
21:08:01 <sfultong> are you people gonna force me to read and learn stuff so that I know what I'm talking about?
21:08:26 <ddarius> sfultong: No, we're not.
21:08:40 <sfultong> ah, that's good... ignorance is comfortable
21:12:06 <oerjan> @src Kleisli
21:12:06 <lambdabot> Source not found. stty: unknown mode: doofus
21:13:33 <oerjan> from Control.Arrow, newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
21:14:10 <oerjan> so Kleisli m a a == a -> m a
21:14:38 <sfultong> and (>>>) has to be endomorphic
21:15:55 <oerjan> you seem to want categories with only one object (a monoid)
21:16:10 <sfultong> yes...
21:16:21 <sfultong> couldn't haskell make do with only arrows and monoids?
21:16:44 <sfultong> kleisi arrows and monoids
21:16:54 <oerjan> arrows don't have to be between the same object
21:17:30 <sfultong> interesting... can you give me an example, please?
21:17:57 <yetAnotherOne> What does an exclamation mark before a type means? I've seen "data PasteState = PasteState { pastes :: !(Seq [Entry]) }" in the hpaste code.
21:18:11 <sfultong> a strict field
21:18:22 <psykotic> it means that field is "strict": when the PasteState constructor term is evaluated, so is that field.
21:18:43 <yetAnotherOne> thanks
21:19:25 <mrd> @where stats
21:19:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
21:19:36 <oerjan> Kleisli (return . head) :: Monad m => Kleisli m [a] a
21:19:50 <oerjan> any monad is an arrow
21:20:24 <oerjan> also, just head in the -> arrow
21:20:53 <oerjan> :t pure
21:20:59 <lambdabot>     Ambiguous occurrence `pure'
21:20:59 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
21:21:06 <oerjan> :t Control.Arrow.pure
21:21:08 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
21:21:30 <oerjan> or pure head in any arrow
21:21:58 <oerjan> head can of course be replaced by any function whose domain and codomain are different.
21:23:26 <sfultong> I see... I guess I was just thinking about arrows in the wrong way
21:23:28 <wli> So an arrow a has a way of lifting from (->) to a
21:23:29 <newsham> "blame" section of video was kinda ho hum
21:24:05 <sfultong> wli : yes, I think arr is the lifting function
21:24:24 <wli> arr == pure?
21:24:42 <ddarius> wli: Yes. They are intended to be identical, synonyms.
21:24:44 <newsham> arr is kinda like "return", no?
21:24:47 <newsham> > arr (+ 1)
21:24:48 <lambdabot>   add an instance declaration for (Show (a b b))
21:25:13 <sfultong> yes, I think so
21:25:30 <shachaf> > arr (+) 1 1
21:25:32 <lambdabot>  2
21:25:42 <ddarius> arr is the action on morphisms of the inclusion (functor) that is a Freyd-category.
21:26:11 * shapr is enjoying Project Euler
21:26:13 <ddarius> newsham: It serves the same purpose.
21:26:26 <oerjan> newsham: arr == (return .) for monads
21:26:28 <wli> I got everything until "inclusion" and "Freyd category."
21:26:29 <ClaudiusMaximus> @src ArrowLoop (->)
21:26:30 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:26:36 <sfultong> > (arr (+1)) >>> (*2) $ 3
21:26:38 <lambdabot>  8
21:28:08 <sfultong> ddarius: are you a mathematician by profession?
21:28:18 <ddarius> wli: inclusion, the functor that witnesses that a subcategory -is- a subcategory of another by showing.  It's the obvious generalization of an inclusion from set theory.
21:28:22 <ddarius> sfultong: Not even close.
21:28:24 <oerjan> @src (->) loop
21:28:25 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:28:46 <sfultong> ddarius: ok... a lion trainer?
21:28:58 <wli> ddarius: Hairdresser?
21:29:05 <oerjan> instance ArrowLoop (->) where loop f b = let (c,d) = f (b,d) in c
21:29:12 <ddarius> wli: A Freyd-category is an inclusion from a cartesian category into a premonoidal category that (if I remember correctly) takes the cartesian product to the "tensor product" of the pre-monoidal category.
21:29:18 <ddarius> sfultong: Airman.
21:29:32 <sfultong> huh, interesting
21:30:06 <newsham> > runKleisli ((returnA <+> (arr ("<" ++))) >>> (arr (++ ">"))) "foo"
21:30:06 <Korollary> Don't believe him. He's with the NSA.
21:30:07 <lambdabot> Terminated
21:30:19 <ddarius> The intuitive idea for Freyd categories is that they include the pure subset (the cartesian subcategory) into an impure whole.
21:30:50 <ddarius> Korollary: I can neither deny nor acknowledge that.
21:31:21 <wli> That's not the response NSA employees are told to give.
21:31:37 <Korollary> It's a deflection mechanism.
21:31:47 <wli> I've got friends who work for the NSA.
21:32:14 <reltuk> wli: if all NSA employees were told to give a uniform response, there could be no secret NSA employees after that response was leaked
21:32:16 <Korollary> wli: Your friends actually work for MOSSAD.
21:32:27 <wli> Or I did at one time (I've not heard from them in years).
21:32:44 <ddarius> wli: That's what they get for telling you they work for the NSA.
21:32:54 <sfultong> ooo! now I just have to analyze wli's background, and I can out me some NSA operatives
21:33:14 <ddarius> sfultong: Sounds like you're a little late for that.
21:33:21 <sfultong> yeah, I guess so :(
21:33:23 <newsham> i dont think most nsa employees ("operatives"?) would mind a whole lot
21:33:24 <reltuk> it probably isn't that hard to find NSA employees :-p
21:33:32 <wli> sfultong: They weren't operatives. They signed up to be math researchers.
21:33:52 <sfultong> operands, then
21:33:54 <newsham> its not like the numbers will find out and betray them
21:34:03 <wli> All sorts of interesting details about the interview process etc.
21:34:32 <ramza3> Bush's NSA?
21:34:51 <sfultong> I had a friend who interviewed for a government job... she didn't get it, sadly.  Probably because she gave me as a character reference :-P
21:34:54 <wli> The response they were supposed to give was actually on their website at the time all this is going on. ISTR it being something about working for the Justice Department.
21:35:32 <wli> It could have changed since, in theory.
21:36:02 <glguy> ?seen syntaxninja
21:36:02 <lambdabot> syntaxninja is in #haskell, #darcs, #haskell-blah and #haskell-soc. I don't know when syntaxninja last spoke.
21:36:21 <newsham> i've worked with a few people who used to work at nsa.
21:36:35 <newsham> bright people, who knows why they made that mistake ;-)
21:36:57 <sfultong> newsham: did they show you their chip implant scars?
21:37:16 <newsham> no.  but i heard they had to check in regularly even as non-employees
21:37:50 <sfultong> really...
21:38:08 <glguy> that's the case for anyone with a security clearance
21:38:25 <glguy> (well, maybe not *anyone*)
21:38:36 <ddarius> glguy: If you still have the clearance maybe.
21:38:38 <ClaudiusMaximus> i can't get my ArrowLoop instance to compile :'(  - i've pretty much used what oerjan pasted, and what is in the Arrow.hs source link from the web docs
21:38:41 <ClaudiusMaximus>     The equation(s) for `loop' have two arguments,
21:38:43 <ClaudiusMaximus>     but its type `F (b, d) (c, d) -> F b c' has only one
21:40:40 <wli> I heard some strange things, like they don't care if you're queer or at one time did drugs so long as you weren't blackmailable. Also not caring too much about political POV so long as you're not some sort of activist.
21:41:10 <oerjan> ClaudiusMaximus: you are defining it for your own arrow type F?
21:41:13 <sfultong> iterate (>>> (+1)) id !! 5 $ 0
21:41:16 <glguy> one of the criteria was how much debt you had
21:41:18 <newsham> I think 'blackmailable' can be interpretted broadly according to someone's tastes
21:41:18 <sfultong> > iterate (>>> (+1)) id !! 5 $ 0
21:41:27 <lambdabot>  5
21:41:40 <ClaudiusMaximus> oerjan: yes; which is newtype F b c = F { runF :: b -> c }
21:42:01 <ddarius> wli: Why -would- they care about any of those things if they don't make you more susceptible to blackmail?
21:42:06 <wli> glguy: Yeah, but they don't ask too directly about that.
21:42:22 <oerjan> ah...
21:42:22 <ddarius> wli: They just do credit checks and such.
21:42:26 <newsham> ddarius: because "they" are people, and people have all sorts of biases and motives
21:42:41 <wli> ddarius: General right-wingedness of these sorts of things.
21:42:42 <newsham> you may have heard that some people dont like black people or homosexuals.
21:43:05 <glguy> or ruby users...
21:43:14 <glguy> I heard that you can't get a clearance if you use ruby
21:43:14 <Korollary> ow
21:43:24 <glguy> maybe that's just a rumor...
21:43:27 <ddarius> newsham: So?  It's not systematic.
21:43:28 <oerjan> the one i pasted is for bare ->
21:43:28 <glguy> ... or maybe its true
21:43:33 <Korollary> rumor on rails
21:44:05 <newsham> glguy: what if you are a reformed former ruby user?
21:44:08 <oerjan> if you really want a constructor, you need to add and remove it with pattern matching
21:44:10 <ddarius> wli: These institutions last longer than presidential terms.
21:44:15 <newsham> and are not currently using any japanese programming languages
21:44:25 <Olathe> Korollary: Heheh
21:45:25 <glguy> newsham: can they be reformed?
21:45:34 <wli> ddarius: The bias has been going on for longer than this country has been in existence.
21:45:36 <glguy> newsham: I've used it, but never inhaled
21:46:07 <ClaudiusMaximus> oerjan: ah, this seems to work (i get an error elsewhere in the program..):    loop (F f) = F (loop f)
21:46:36 <sfultong> > iterate (>>> iterate (id) . head) tail !! 63 $ [1..]
21:46:38 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
21:46:48 <oerjan> ClaudiusMaximus: i think the second loop there is using the instance for bare ->
21:47:15 <newsham> why use arrows to do functions if all you want is pure functions?
21:47:26 <oerjan> you could probably get it automatically with newtype deriving
21:47:30 <sfultong> fun
21:47:53 <newsham> why not make fun with a kleisli?
21:48:09 <sfultong> I haven't worked up to that yet
21:48:23 <newsham> ?type arr (++ ">")
21:48:25 <lambdabot> forall (a :: * -> * -> *). (Arrow a) => a [Char] [Char]
21:49:10 <sfultong> alright... I'll try something with that
21:49:24 <newsham> ?type arr (\x -> ["<"++x, x++">"])
21:49:26 <lambdabot> forall (a :: * -> * -> *). (Arrow a) => a [Char] [[Char]]
21:50:33 <newsham> ?type runKleisli $ arr (\x -> ["<"++x, x++">"])
21:50:35 <lambdabot> forall (m :: * -> *). (Arrow (Kleisli m)) => [Char] -> m [[Char]]
21:51:22 <newsham> > runKleisli (arr (\x -> ["<"++x, x++">"]))) "test"
21:51:22 <lambdabot>  Parse error
21:51:34 <newsham> > runKleisli (arr (\x -> ["<"++x, x++">"])) "test"
21:51:34 <lambdabot>   add an instance declaration for (Show (m [[Char]]))
21:51:40 <ddarius> :t Kleisli $ \x -> ['<':x,x++">"]
21:51:42 <lambdabot> Kleisli [] [Char] [Char]
21:51:54 <newsham> blah i'm messing this up
21:52:04 <newsham> why not a [] kleisli?
21:52:09 <sfultong> well, I think it may be too much for my tiny brain
21:52:22 <newsham> yah so much for me simplifying this :)
21:52:54 <sfultong> still... I should start using arrows instead of (let/where)
21:52:58 <ddarius> newsham: The argument of arr is independent of the arrow, so using a list function is not going to induce the list monad in Kleisli []
21:53:08 <sfultong> then I'll be a proficient archer
21:54:23 <wli> I've not been able to follow any of this.
21:55:13 <ddarius> There wasn't much to follow.
21:55:32 <newsham> > runKleisli (Kleisli (\x -> ["<"++x, x++">"])) "test"
21:55:34 <lambdabot>  ["<test","test>"]
21:55:52 <wli> I don't want it to be 9 years to figure out arrows like it was for monads.
21:56:02 <newsham> > runKleisli (Kleisli (\x -> ["<"++x, x++">"]) >>> (arr (++'!')) "test"
21:56:02 <lambdabot>  Parse error
21:56:14 <newsham> > runKleisli (Kleisli (\x -> ["<"++x, x++">"]) >>> (arr (++'!'))) "test"
21:56:14 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
21:56:29 <newsham> oops i did it again
21:56:37 <ddarius> " not '
21:57:03 <newsham> > runKleisli (Kleisli (\x -> ["<"++x, x++">"]) >>> (arr (++"!")) "test"
21:57:03 <lambdabot>  Parse error
21:57:17 <newsham> > runKleisli (Kleisli (\x -> ["<"++x, x++">"]) >>> (arr (++"!"))) "test"
21:57:18 <lambdabot>  ["<test!","test>!"]
21:58:54 <sfultong> yes, that is pretty neat
21:58:57 <newsham> > runKleisli (Kleisli readFile >>> arr lines >>> arr words) "/etc/passwd"
21:58:58 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
21:59:21 <newsham> > runKleisli (Kleisli readFile >>> arr lines >>> arr (map words)) "/etc/passwd"
21:59:22 <lambdabot>  <IO [[[Char]]]>
21:59:28 <wli> I may also be just too plain dumb to ever learn any of this.
21:59:49 <ddarius> wli: That's unlikely.
22:00:32 <newsham> thats a big arrow that transforms a filename into a list of lines from the file
22:01:20 <wli> arr seems to be liftM there, and >>> seems to be >>=
22:01:53 <ddarius> wli: Nope.  That wouldn't match up type wise.
22:02:22 <wli> >=>
22:02:23 <newsham> ?type Kleisli readFile
22:02:25 <lambdabot> Kleisli IO FilePath String
22:02:55 <newsham> ?type Kleisli readFile >>> arr lines
22:02:56 <ddarius> f >>> g = \x -> f x >>= g
22:02:57 <lambdabot> Kleisli IO FilePath [String]
22:03:18 <sfultong> wli: if I can manage to get any good at arrows, I'll write a tutorial for you
22:03:23 <wli> Maybe I should cook up a ghc deb from scratch
22:03:30 <wli> sfultong: Please do, thanks.
22:03:50 <ddarius> What's wrong with the papers?
22:03:52 <newsham> ?src Kleisli (>>>)
22:03:52 <lambdabot> Source not found. You type like i drive.
22:04:09 <sfultong> lambdabot driving... how do you access that feature?
22:04:18 <wli> ddarius: I don't understand the ones I've read and/or am aware of.
22:04:27 <ddarius> sfultong: It's what @eval does
22:04:57 <newsham> wli: an arrow is something that takes an input and generates an output, possibly with hidden side effects.
22:05:18 <newsham> Kleisli arrows are arrows made out of monad functions
22:05:53 <wli> newsham: I appreciate the effort, though this kind of explanation failed me for something on the order of a decade for monads.
22:06:03 <oerjan> @help eval
22:06:03 <lambdabot> eval. Do nothing (perversely)
22:06:21 <oerjan> @list eval
22:06:22 <lambdabot> eval provides: run let undefine
22:06:49 <oerjan> @eval
22:07:26 <sfultong> I quite liked the machines (or robots) analogy for arrows on the wiki
22:07:54 <Olathe> @explode
22:07:54 <lambdabot> Unknown command, try @list
22:08:06 <newsham> trying to watch peyton-jones' "taste of haskell" talk video, but whoever filmed this decided they wouldnt film any of the slides :(
22:08:07 <oerjan> @even
22:08:07 <lambdabot> Maybe you meant: eval seen
22:08:17 <oerjan> @odd
22:08:17 <lambdabot> Maybe you meant: id todo
22:08:27 <ddarius> newsham: So open them in another window.
22:08:45 <newsham> i'm watching a video.
22:08:51 <newsham> i'm supposed to sit back and eat popcorn
22:08:54 <newsham> not synch slide decks
22:09:03 <newsham> are the slides online?
22:09:11 <shapr> yes
22:09:15 <ddarius> Yes, and he doesn't change slides that often.
22:09:17 <wli> I seem to do poorly with analogies. I do better with examples of internals of real instances and furthermore need some sort of programming problems/exercises to absorb them.
22:09:17 <shapr> Though I forget where
22:09:40 <newsham> wli: i was hoping readFile woulda been a good example
22:09:44 <ddarius> wli: I think the papers have all of that though probably not enough exercises.
22:10:03 <ddarius> @where realworldhaskell
22:10:03 <lambdabot> is http://www.realworldhaskell.org/blog/
22:10:56 <ddarius> http://conferences.oreillynet.com/presentations/os2007/os_peytonjones.pdf
22:10:58 <lambdabot> http://tinyurl.com/ysvquz
22:11:19 <wli> ddarius: Well, my monad breakthrough was basically a combination of the problems in YAHT's chapter 9 and rewriting springschool95.ps' substitution monad in modern Haskell.
22:11:43 <ddarius> wli: So you don't need an arrow tutorial, you need an arrow problem set.
22:11:52 <shachaf> @where+ realworldhaskell http://www.realworldhaskell.org/
22:11:53 <lambdabot> Done.
22:11:55 <wli> ddarius: Probably, yes.
22:12:17 <newsham> i think if you took any arrow examples and sat down with ghci, the examples, and the arrow definitions, you'd get it worked out in 15-30min
22:13:05 <newsham> but I dont know what it would be worth to you
22:13:16 <newsham> monads you use all the time.. arrows not so much
22:14:13 <dibblego> what's the rule of logic where you universally quantify a proposition across a free variable, then refute the proposition with a negation with existential quantification on the free variable?
22:14:52 <wli> newsham: Maybe I should work on TH or GADT's instead.
22:15:00 <mm_freak_> say i want to write a class for finite state automata with two functions "init :: s" (the initial state) and "next :: s -> i -> s" (the next state)
22:15:00 <sfultong> newsham: but why don't people use arrows much?
22:15:11 <ddarius> sfultong: Why should they?
22:15:21 <sfultong> because they're pretty
22:15:30 <mm_freak_> how do i need to write the class definition?  class …? where …
22:15:30 <newsham> sfult: because the two existing arrow types are pure functions and monad functions
22:15:34 <ddarius> sfultong: Not to use.
22:15:37 <newsham> which are both already done quite well without arrows
22:15:51 <Olathe> dibblego: DeMorgan's something or other ?
22:15:52 <newsham> so you could do it with arrows, but most people dont because historically they havent
22:16:13 <newsham> sfult: I think "." is prettier than ">>>"
22:16:17 <dibblego> Olathe, I don't think so
22:16:19 <ddarius> mm_freak_: Don't use a class.
22:16:24 <mm_freak_> i is the input type, but it shouldn't be polymorphic…  it should rather depend on s (the state type)
22:16:28 <mm_freak_> ddarius: huh?
22:16:28 <sfultong> but you could get even crazier pointless style with arrows
22:16:36 <dibblego> \forall x. p x can be refuted with \exists x. \not p x had a name I thought
22:16:55 <ddarius> data Automata s i = Automata { init :: s, next :: s -> i -> s }
22:16:55 <mm_freak_> ddarius: i was going to define automata as data-types
22:16:59 <reltuk> anyone know what dons' phd is on?
22:17:09 <sfultong> newsham: well, maybe I should write my own version of haskell where (.) is (>>>)
22:17:17 <mm_freak_> ddarius: ok, that makes sense, but isn't it possible with classes, too?
22:17:29 <wli> Am I basically hearing that the actually competent Haskell programmers have difficulty making effective use of arrows?
22:17:49 <newsham> sfult: you dont have ot, you can use >>> on pure functions
22:18:09 <ddarius> mm_freak_: classes don't fit that interface well.  Neither s nor i is the automata.
22:18:13 <newsham> > ((+ 1) >>> (* 2)) 5
22:18:15 <lambdabot>  12
22:18:28 <newsham> > (*2) . (+1) 5
22:18:29 <lambdabot>   add an instance declaration for (Num (a -> b))
22:18:34 <newsham> > ((*2) . (+1)) 5
22:18:35 <lambdabot>  12
22:19:01 <newsham> wli: arrows dont give you any expressiveness you dont already have.
22:19:09 <wli> > ((*2) <<< (+1)) 5
22:19:09 <newsham> they just give you a different way to write/think about it.
22:19:10 <lambdabot>  12
22:19:17 <ddarius> newsham: Sure they do.
22:19:27 <mm_freak_> ddarius: my idea was to require a type of kind * -> * -> * -> * (for state, input and output types)…  wouldn't that work?
22:19:46 <sfultong> yeah, I'm not sure that you're right about that, newsham
22:19:57 <newsham> > (\x -> ReadFile >>= lines) "/etc/passwd"
22:19:58 <lambdabot>   Not in scope: data constructor `ReadFile'
22:20:00 <oerjan> sfultong: import Prelude hiding ((.)); a . b = b >>> a
22:20:06 <newsham> > (\x -> readFile >>= lines) "/etc/passwd"
22:20:06 <lambdabot>  Couldn't match expected type `IO String'
22:20:15 <sfultong> oerjan : hmm, yeah
22:20:22 <newsham> > (\x -> readFile x >>= lines) "/etc/passwd"
22:20:23 <lambdabot>  Couldn't match expected type `IO' against inferred type `[]'
22:20:29 <newsham> blah, I am not doing this well :)
22:20:35 <ddarius> mm_freak_: Yes, but why do you want to put it in a class?
22:21:19 <mm_freak_> ddarius: i have the feel i didn't understand classes as well as i should…  just for learning
22:21:32 <jbauman> > (\x -> readFile x >>= (liftM lines)) "/etc/passwd"
22:21:32 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
22:21:34 <wli> newsham: liftM lines
22:21:49 <newsham> > (\x -> readFile x >>= liftM lines) "/etc/passwd"
22:21:49 <newsham> yes
22:21:49 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
22:22:17 <ddarius> (return .) lines
22:23:16 <wli> liftM lines $ readFile "/etc/passwd"
22:23:31 <mm_freak_> ddarius: should i require * -> * instead?  i think that would make more sense
22:23:35 <jbauman> oh, yeah
22:23:55 <ddarius> mm_freak_: I don't what you're going for now.
22:24:22 <newsham> > (\x -> readFile "/etc/passwd" >>= return.lines) "/etc/passwd"
22:24:24 <lambdabot>  <IO [[Char]]>
22:24:33 <wli> > liftM lines $ readFile "/etc/passwd"
22:24:34 <lambdabot>  <IO [[Char]]>
22:24:45 <newsham> > runKleisli (Kleisli readFile >>> lines) "/etc/passwd"
22:24:45 <lambdabot>  Couldn't match expected type `Kleisli IO String b'
22:25:18 <newsham> > runKleisli (Kleisli readFile >>> arr lines) "/etc/passwd"
22:25:20 <lambdabot>  <IO [[Char]]>
22:27:54 <mm_freak_> ddarius: i just thought that "each FSM has a start state, a state transformer and an output function", so it fits the usual pattern for type classes…  why shouldn't i do it that way in this case?
22:28:53 <ddarius> mm_freak_: Because those start states, and such are naturally runtime values.  There isn't a canonical start state or transition function for a given type.
22:29:42 <mm_freak_> ok, i understand
22:29:45 <mm_freak_> thank you
22:53:44 <mm_freak_> when the any of the state, input or output types is Integer, then the whole thing isn't (theoretically) a finite state machine, right?
22:55:08 <oerjan> sounds obvious
22:55:10 <newsham> EPARSE
22:55:48 <mm_freak_> just making sure i didn't miss anything =)
22:57:07 <ClaudiusMaximus> has anyone got the "resetable counter in arrow notation" example in A New Notation For Arrows to work?  i get "stack overflow" for any non-empty input.  i'm using [] for streams
22:58:33 <Korollary> ah, johnnowak
22:58:45 * Korollary retracts his snide comment at reddit
22:59:31 <johnnowak> Korollary: hm?
22:59:58 <Korollary> johnnowak: I was just making fun of how boring NYC must be if one needs a language dialect as an excuse to go out.
23:00:16 <johnnowak> ah, hehe
23:00:22 <johnnowak> It's not NYC that's boring, it's me.
23:00:53 <johnnowak> Was meant to be a bit of a joke of course... I do occasionally venture out for milk and bread.
23:01:16 <johnnowak> I am tiring of these milk sandwiches...
23:01:19 <Korollary> you have online groceries that deliver in NY. Those days are numbered.
23:01:32 <johnnowak> Aye.
23:03:06 <Korollary> If I was in NY, I'd go to the Daily Show or Colbert Report
23:03:19 <johnnowak> not a bad idea.
23:03:56 <Korollary> in fact it's on right now on the west coast here
23:06:44 <ClaudiusMaximus> ah, i think i know where i was going wrong:   data Seq a = Cons a (Seq a)  =/=  [a]
23:07:43 <olsner> surely you need some kind of Nil too
23:08:49 <ClaudiusMaximus> it states "infinite sequences may be modelled in Haskell by..."
23:08:59 <ClaudiusMaximus> which i somehow failed to spot before
23:11:46 <oerjan> olsner: not if he only wants infinite ones
23:14:06 <ClaudiusMaximus> i think i need to somehow define 'loop' better, or something
23:14:53 <olsner> ah! infinite sequences...
23:19:46 <ClaudiusMaximus> how would you define an instance for ArrowLoop for   newtype SF b c = SF { runSF :: [b] -> [c] }   ?
23:26:50 <OceanSpray> hiya everybody
23:27:37 <olsner> @unpl \f xs -> ap (xs >>= (:[]) . f)
23:27:37 <lambdabot> \ f xs g -> (xs >>= \ k -> (f k) : []) >>= \ c -> g >>= \ b -> return (c b)
23:27:37 <Korollary> d00d
23:27:42 <olsner> @pl \f xs -> ap (xs >>= (:[]) . f)
23:27:42 <lambdabot> liftM2
23:27:50 <olsner> woah
23:28:44 <olsner> @type \f xs -> ap (xs >>= (:[]) . f)
23:28:46 <lambdabot> forall a a1 b. (a -> a1 -> b) -> [a] -> [a1] -> [b]
23:30:09 <ClaudiusMaximus> hooray, page 17 of Programming With Arrows has the answer - using lazy pattern matches
23:33:31 <oerjan> olsner: an alternative definition of liftM is liftM f x = x >>= return . f
23:33:50 <OceanSpray> how many people here have implemented a programming language by themselves?
23:34:01 <OceanSpray> if you did it in haskell, how long did it take you?
23:35:08 <opqdonut> i've programmed a minimal lisp in a few weeks
23:35:09 <opqdonut> in C
23:35:20 <OceanSpray> a few weeks, eh?
23:35:36 <opqdonut> tho that was when i was learning programming :)
23:36:08 <opqdonut> probably could implement the same functionality in a day or so in C or haskell
23:36:49 <OceanSpray> :|
23:40:25 <christine_c> hello people
23:40:33 <sorear> hello
23:40:50 <christine_c> hi sorear....can i ask an opinion from you
23:40:56 <sorear> sure?
23:41:42 <christine_c> im looking for a thesis study, but still dont find anything...i come to a study, if this is possible something a scheduler
23:41:58 <christine_c> room, teacher, time scheduler using prolog
23:42:16 <christine_c> is this not a tough study, what do you think sorear
23:42:40 <sorear> I don't even know what thesis studies are.
23:42:52 <christine_c> i see
23:42:53 <christine_c> ok
23:42:58 * sorear is 16
23:43:01 <shachaf> Wouldn't #prolog make more sense to ask in?
23:43:11 <christine_c> ok, ill try there
23:43:13 <oerjan> O_O
23:43:35 <shachaf> (Unless your question is also about Haskell?)
