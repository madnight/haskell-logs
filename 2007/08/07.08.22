00:05:37 <slava> dons: thanks for posting factor propaganda to reddit
00:05:51 <slava> dons: i'm in austin hanging out with factor hackers
00:06:56 <opqdonut> what's factor all about?
00:07:06 <opqdonut> i know it's a fp language but not much more :)
00:08:04 <slava> its not an fp language, its closer to lisp in that it is an extensible language
00:08:34 <opqdonut> oh
00:08:54 <opqdonut> ahh, must be mistaking it for something else
00:09:01 <opqdonut> yeah, looks more like forth :)
00:11:59 <coffeemug> slava: is Factor funded yet or it's purely a spare time activity?
00:13:11 <pjd> opqdonut: it's approximably Lisp/Scheme in postfix
00:15:05 <opqdonut> pjd: yeah so it seems
00:15:10 <opqdonut> pretty interesting
00:15:14 <thoughtpolice> Pseudonym: cool little compiler. :)
00:15:20 <opqdonut> seems somehow cleaner than forth :)
00:15:46 <ari> http://cgi.ebay.com.au/ws/eBayISAPI.dll?ViewItem&item=130144061675
00:15:47 <pjd> opqdonut: well, different level than forth :)
00:15:48 <lambdabot> Title: LOT OF POKEMON CARDS THAT MY KIDS TRIED TO SNEAK BY ME - eBay Pokemon, Animation ..., http://tinyurl.com/25yrh2
00:15:52 <dons> slava: oh, nice. you're having a hackathon?
00:16:10 <ari> Sorry, wrong channel
00:16:13 <slava> dons: yeah! we're improving win32 and solaris platform support
00:16:30 <dons> cool. you should take some photos and blog about it :)
00:16:42 <slava> dons: solaris is a pain. i wish they'd just ship gnu userspace instead of their old-ass broken tar which can't do gzip, sh which can't do command history, etc :)
00:16:44 <slava> yeah, i will
00:16:56 <dons> we have the haskell hackathons up here, http://www.haskell.org/haskellwiki/Hac_2007_II
00:16:57 <lambdabot> Title: Hac 2007 II - HaskellWiki
00:17:05 <dons> (if you want ideas)
00:17:29 <glguy> slava: what is motivating your use of solaris?
00:17:48 <slava> nothing, its just one of the platforms we happen to support
00:17:56 <glguy> oh
00:18:38 <slava> eventually we'll have native threading and i want to support sun's bad-ass niagra servers
00:26:03 <slava> dons: looks like your hackathons are a lot more formal than ours. :)
00:36:13 <coffeemug> gn everyone
00:36:14 <DRMacIver> Suffix trees seem popular on reddit at the moment.
00:47:40 <wli> I've not used those recently enough to even remember what they are.
00:48:11 <wli> I actually like Solaris. ;)
00:49:49 <glguy> wli: Any reasons in particular?
00:50:08 <dons> slava: i guess since we do them during conferences, and people stay in hotels, so we need to be a little organised
00:50:16 <wli> Familiarity, I guess. I used it all through college.
00:52:11 <wli> Except for the very start, which predated Solaris.
00:52:38 <wli> (That involved its predecessor(s).)
00:57:04 <thoughtpolice> i'm running solaris 10 on a box in my room, although it's really for zfs and dtrace. :)
00:57:27 <thoughtpolice> i was quite shocked when I found gcc wasn't automatically in my path, however. :(
01:15:47 <reffie> http://news.bbc.co.uk/2/hi/asia-pacific/6954728.stm
01:15:49 <lambdabot> Title: BBC NEWS | Asia-Pacific | Pet camel kills Australian woman
01:24:30 <glguy> ?seen slava
01:24:30 <lambdabot> slava is in #haskell and #darcs. I last heard slava speak 58m 26s ago.
01:24:37 <glguy> slava: you about?
01:27:59 <reffie> DE GVSTIBVS NON EST DISPVTANTVM
01:36:55 <bparkis> does rounding error throw a little monkey wrench into compiler techniques that attempt to re-arrange an expression optimizing for speed, in the process changing its accuracy?
01:37:27 <bparkis> are there compiler techniques that attempt to optimize for numerical precision rather than speed?
01:37:54 <wli> No.
01:38:15 <bparkis> and why is that?
01:39:12 <wli> Because it doesn't make sense.
01:39:13 <bparkis> for example consider xy/(x+y) versus 1/(1/x + 1/y), their numerical precision is not the same and possibly a compiler could/should know the difference
01:39:31 <wli> And a compiler figures that out how?
01:39:55 <Cale> wli: The same way that a compiler figures out that map (f . g) = map f . map g
01:39:59 <Cale> You tell it :)
01:40:15 <glguy> rewrite rules are as good as you make them
01:42:30 <kayess> bparkis: they're not the same if either x or y is zero, or am I saying something stupid (again)
01:45:33 <kayess> Anyway, whilst I'm here, does anybody know about threading on Haskell under Windows?
01:46:09 <kayess> If I compile a DLL do I need to serialise calls to it, or is it re-entrant, or maybe sometimes re-entrant?
01:47:00 <therp> kayess: I'd say sometimes re-entrant. depends on the code that's in the lib
01:47:31 <desegnis> Gnaaah. Float types incorporating NaN and Infinity are simply stupid.
01:47:39 <Cale> kayess: that's true, they're not
01:47:53 <Cale> desegnis: why?
01:48:38 <kayess> therp: So it should be serialised then... Wonder if I can force each thread to run an isolated Haskell process...
01:48:55 <Cale> Whenever you use fixed-size representations of real numbers, you're going to have issues like that :)
01:48:57 <desegnis> Cale, probably because I haven't read the right papers yet. I do not understand why it is sensible for 1 / (5/0) to evaluate to 0
01:49:24 <glguy> > 1 / (5 / 0) :: Float
01:49:32 <lambdabot>  0.0
01:49:40 <Cale> > 1 / (5 / 0.00001) :: Float
01:49:41 <lambdabot>  2.0e-6
01:49:46 <Cale> That's why.
01:51:28 <desegnis> Hmm. So the implementation considers that there might have been rounding errors?
01:51:34 <Cale> yes
01:51:58 <Cale> For the same reason, the sign of 0 is preserved.
01:52:20 <desegnis> > 1 / (5 / negate 0) :: Float
01:52:22 <lambdabot>  -0.0
01:52:28 <desegnis> Ah.
01:52:50 <desegnis> But then:
01:52:56 <desegnis> > 1 + 0/0
01:52:58 <lambdabot>  NaN
01:53:08 <desegnis> Shouldn't this be 2 then?
01:53:16 <glguy> 0/0 is a different case than 1/0
01:53:31 <Cale> It can't guess that those two zeroes came from rounding the same thing
01:53:54 <Cale> > 0.000001/0.000002
01:53:56 <lambdabot>  0.5
01:55:17 <Syzygy-> desegnis: Another reason is that we prefer a/(b/c) == ac/b
01:55:20 <Cale> It's not perfect, but it's reasonably sensible given the limitations.
01:55:33 <Syzygy-> Or more specifically (a/b)/(c/d) == ad/bc
01:56:22 <desegni1> Sorry, my graphics froze.
01:56:53 <Cale> desegni1: what was the last line you saw?
01:57:50 <desegni1> Cale, you explained in one line why 1 + 0/0 is not 2, and it made sense to me
02:01:53 <Cale> So yeah, floating point numbers suck, but given that they're trying to do the impossible, they don't suck quite as much as they could.
02:01:55 <glguy> ?get-shapr
02:01:55 <lambdabot> shapr!!
02:02:22 <Saizan> isn't there an upper bound on the error?
02:02:42 <Cale> no, I don't think so.
02:02:57 <Royal_Son> hello there. I am doing an assignment so I would like to stress from the outset that I am not looking for a specific answer because I do want to actually learn rather than be spoon fed. I have a question which wants me to design a function using list comprehension to calculate the number of occurances in a list of tuples such that the second entry is the square of the first in each tuple...
02:03:13 <Cale> Royal_Son: okay
02:03:20 <Royal_Son> I have come up with this so far (please don't laugh, my haskell skills are very limited)...
02:03:25 <Royal_Son> length [[(x,y)]|(x,y)<-[(1,2),(4,7),(3,9),(5,12),(6,36),(4,25)],x*x == y]
02:03:36 <Cale> right
02:03:40 <Royal_Son> and this does return the correct number of occurances for that list...
02:03:40 <Cale> that seems sensible
02:03:59 <Royal_Son> however, I would like to now be able to turn this into a function which can receive parameters...
02:04:05 <Cale> you don't need the extra square brackets around the (x,y)
02:04:13 <Cale> okay
02:04:14 <Royal_Son> i.e. for an arbitrary list of tuples
02:04:18 <desegnis> Cale, I see now. Although, regarding (a/b)/(c/d), I still think that it's funny to apply divison laws on possibly-zeros.
02:04:25 <Cale> So the part which is going to change is that list
02:04:33 <Cale> desegnis: well, yeah, it is :)
02:04:48 <bparkis> a Haskell function whose type signature includes no recursive types is equivalent to a Turing machine
02:04:49 <desegnis> Cale, that's what I wanted to hear ;)
02:04:52 <bparkis> er, no
02:04:53 <glguy> Royal_Son: if you don't need the tuple, but just to count it, you can return () instead
02:04:57 <bparkis> is equivalent to a finite state machine
02:05:09 <glguy> > length [ () | x <- [1..3] ]
02:05:14 <bparkis> a Haskell function whose type signature includes no recursive types is equivalent to a FSM
02:05:17 <lambdabot>  3
02:05:26 <Royal_Son> oh
02:05:40 <Cale> You could also give 1, and then use sum
02:05:54 <Cale> There are lots of ways to do it, but that wasn't quite the question :)
02:06:00 <Cale> So you want a function...
02:06:02 <Royal_Son> i'll be back i'm going to try something...
02:06:03 <bparkis> a Haskell function whose type signature includes only one recursive type, such that the constructors for that type only refer back to the type once or zero times, is equivalent to a pushdown automaton
02:06:19 <Cale> numberOfSquares xs = ....
02:06:40 <Cale> okay
02:06:49 <bparkis> a Haskell function whose type signature includes two recursive types, or one recursive type such that some constructor for that type refers back to the type two or more times, is equivalent to a Turing machine
02:07:00 <osfameron> FSM?
02:07:08 <bparkis> finite state machine
02:07:19 <osfameron> ah!  I was worried it might be Flying Spaghetti Monster...
02:07:19 <flux> bparkis, so a haskell function with type signature including three recursive types must be better than a turing machine, right?
02:07:22 <flux> ;)
02:07:30 <bparkis> heh, no, after that it's all Turing
02:08:49 <bparkis> though you have to take into account mutually recursive types
02:08:50 <Saizan> bparkis: do you have conversion algorithms?
02:09:16 <bparkis> sure Saizan
02:09:32 <puusorsa> bless his noodly appendage
02:10:07 <bparkis> with no recursive types, there are a finite number of type signatures for pattern matching on each input
02:10:48 <bparkis> the function maps a type signature either recursively, calling itself with a different set of type signatures--moving to another state in the FSM
02:11:11 <bparkis> or it maps it literally, producing a final state with no outgoing edges
02:11:20 <kayess> I've been reading this stuff: http://www.haskell.org/ghc/docs/6.4/html/users_guide/win32-dlls.html
02:11:24 <lambdabot> Title: 11.5. Building and using Win32 DLLs, http://tinyurl.com/2vmuzf
02:11:27 <Saizan> type signatures? you mean patterns?
02:11:35 <Royal_Son> ok I've come up with this, but so far it only seems to work if i have 1 tuple :
02:11:35 <bparkis> yes
02:11:37 <Royal_Son> sqCount2::[(Int,Int)]->Int
02:11:37 <Royal_Son> sqCount2 [(a,b)]= length [()|(x,y)<-[(a,b)],x*x == y]
02:12:05 <glguy> :-/
02:12:14 <kayess> I think it's telling me that if I make a package I can use it as a DLL, and if I make a second (independent) package DLL I can use that too at the same time
02:12:32 <bparkis> to construct the states of the FSM, let's assume, first (an assumption which will be relaxed) that the function does not call any other functions
02:12:50 <glguy> Royal_Son: when used as a function parameter, [(a,b)] isn't a type, but a list containing a single element
02:13:20 <bparkis> so each line of the function definition is of the form f <pattern match> = f <new values>, or it is of the form f <pattern match> = <final value>
02:13:40 <Royal_Son> glguy : Should I use [(Int,Int)] instead ?
02:13:48 <Royal_Son> oops
02:13:53 <bparkis> it's clear that the state space in this case is the set of all lines of the function definition
02:14:00 <Royal_Son> i'm confusing myself here
02:14:17 <glguy> Royal_Son: you just want some list, you don't need to specify anything about it
02:14:51 <bparkis> which is a subset of the cross product of the total enumerated constructors of every type used by the function
02:15:34 <bparkis> and therefore finite--at each step, the function must always return to one state in that finite space, so it is a FSM
02:15:40 <Cale> Royal_Son: So it should look like: sqCount xs = length [() | (x,y) <- xs, x*x == y]
02:15:44 <bparkis> now let's relax the assertion that the function does not call any other functions
02:16:05 <bparkis> we can get around this by rewriting all the functions f does call as part of the definition of f
02:16:48 <Saizan> bparkis: yup, i see
02:16:49 <bparkis> extending f to take new arguments to encompass the arguments of every function f does call
02:16:56 <bparkis> ok
02:17:11 <glguy> @pl length . filter (\(a,b) -> a*a == y) -- and then we finish it all off like so ( ;-)
02:17:11 <lambdabot> length . filter ((y ==) . join (*) . fst)
02:17:19 <bparkis> and it goes similarly for if there's one recursive type, because it's just a FSM + a stack
02:18:04 <Royal_Son> ok that makes sense, thank you
02:18:07 * glguy noticed his typo...
02:18:10 <bparkis> and if there's 2 recursive types that's 2 stacks, or if there's 1 recursive type with a constructor where the type appears twice that's a single tape, plus the FSM for all the non-recursive types
02:18:17 <bparkis> so that's a Turing machine
02:18:33 <Royal_Son> i wish i coulda figured that out
02:19:02 <Royal_Son> I'm pretty slow when i comes to getting my head around haskell
02:19:09 * wli hits Project Euler again.
02:19:15 <glguy> what schools are teaching haskell this semester
02:19:35 <glguy> that we can expect to boost @users
02:19:39 * wli lets discrete log fester for a bit to go after a different problem.
02:20:21 <Royal_Son> massey university (Auckland, New Zealand)
02:21:42 <Cale> Royal_Son: Don't worry, most of us were there at some point. It was a good couple of months before I started feeling at all comfortable with Haskell, and a year or two before I really felt like I knew it.
02:22:04 <Cale> and I have a pretty strong background in mathematics :)
02:22:21 <ivant> good morning, #haskell
02:22:32 <glguy> @localtime ivant
02:22:33 <lambdabot> Local time for ivant is Wed Aug 22 13:21:39
02:23:11 <ivant> I had a long night trying to configure glassfish cluster :-)
02:23:12 <Saizan> Royal_Son: many are confused by the list syntactic sugar at first
02:23:54 <glguy> Royal_Son: and in case you weren't sure, #haskell welcomes questions at all levels
02:25:18 * earthy feels perfectly comfortable with Haskell
02:25:35 <earthy> the libraries however, are a different matter entirely. ;)
02:29:15 <glguy> I recognize that british pronounciation came first, but I can't help but smile when they say "shed-julled" on BBC World (radio)
02:30:22 <augustss> glguy: it's not at all clear that the current british pronunciation came first
02:31:02 <opqdonut> i spea a horrible amalgam of british and american pronounciation :/
02:31:06 <opqdonut> *speak
02:31:15 <opqdonut> but i guess that's what most non-native speakers do
02:31:16 <glguy> that very well may be, I suppose I have no idea which came first
02:31:35 <augustss> American English is akin to British English as spoken when the immigrants left
02:36:04 <glguy> so apparently you can eat too many brownies
02:39:05 <desegnis> glguy, is the American pronunciation “skedooled”?
02:40:11 <osfameron> I think UKian pronunciation accepts both
02:42:27 <glguy> desegnis: closer to : sked-julled
02:42:57 <glguy> another one I keep noticing tonight is mili-tree
02:43:03 * glguy needs to go to bed
02:43:14 <glguy> I'm not even listening to the stories at this point, just the words
02:44:25 * desegnis wonders that there's a j in the middle, but better says goodnight
02:46:39 <ivant> ?localtime dons
02:46:41 <lambdabot> Local time for dons is Wed Aug 22 19:45:46 2007
02:47:34 <ivant> @tell dons can you please restart lambdabot2? it appears to be hung
02:47:35 <lambdabot> Consider it noted.
02:47:53 <desegnis> glguy, ah, mili-tree and friends appeared in my textbooks. We even learnt “diction-ree” (or similar)
02:57:12 <arcatan^> hi
03:18:18 <roconnor> maybe my haskell code is always slow because I often repeat common subexpressions.
03:18:20 <wli> Hmm, this one can't be brute-forced at all.
03:20:18 <Olathe> Which one ?
03:20:26 <wli> Olathe: #152
03:21:58 <wli> The combinatorial explosion is pretty extreme.
03:22:13 <opqdonut> combinatorial explosion <3
03:22:55 <wli> After 10 iterations there are 282063 candidates with an average remaining list length of 12.47
03:23:09 <wli> Which thus far takes 437.46s to determine.
03:28:41 <wli> And that's just for [2..45]
03:29:25 <wli> After 6 iterations [2..80] gets 420 candidates with an average list length of 62.27
03:29:50 <wli> After 7 there are 3587 candidates with an average list length of 52.78
03:31:33 <wli> So I apparently have to find good ways to thin out the search space.
03:31:58 <wli> I suspect 2-adic representations of the inverse squares are involved.
03:34:20 <Olathe> wli: Are you using Pi^2/6 ?
03:34:59 <wli> Olathe: No. It's unclear how pi^2/6 factors into it.
03:35:31 <Olathe> The sum of 1/i^2 for i from 1 to infinity is Pi^2/6.
03:35:41 <wli> After 8 iterations [2..80] has 38410 candidates with an average list length of 42.33
03:36:07 <wli> Olathe: Yes, I know. How do you think that factors into this?
03:36:47 <Olathe> You know that you can't have 1, because that makes it exceed 1/2. You know that you must have 2, since Pi^2/6 - 1/1^2 - 1/2^2 < 1/2 shows that you can never make up the deficit.
03:37:37 <ivant> wli, ha, I'm working on project Euler problem right now too :-)
03:37:49 <wli> That's automatically inferred by the algorithm I'm using.
03:37:59 <Olathe> wli: Ahh.
03:38:37 <wli> Olathe: I check to see that the sum of the remaining possible integers in the candidate is sufficient.
03:39:14 <Olathe> How do you check ?
03:40:02 <Olathe> Oh, I see.
03:40:06 <Olathe> It's bounded.
03:40:14 <wli> Olathe: http://hpaste.org/2383
03:41:12 <wli> That's what I'm doing for the moment while I'm trying to think of better methods.
03:43:17 <wli> Duh, I flipped a comparison.
03:44:39 * osfameron was playing with binary search this morning (after seeing comment about it being a tricky and educational function to implement) but then realised it didn't make much sense for cons lists, so did it in Perl instead...
03:45:23 <opqdonut> :D
03:45:32 <xerox> osfameron: use ByteStrings :)
03:45:41 <Saizan> well you can implement a binary search tree
03:45:56 <ski> arrays
03:46:11 <wli> I do binary search all the time.
03:46:12 <yaxu> hm, my program typechecks, but doesn't do what i want, to who should i address my complaint?
03:46:27 <opqdonut> yaxu: the coder ;)
03:46:31 <wli> I use it as a fallback for Newton methods, for which I always use bounding intervals.
03:46:47 <wli> e.g. for isqrt
03:46:59 <yaxu> opqdonut: ok, postage is cheap at least :)
03:52:38 <wli> I wonder why lambdabot isn't showing hpaste announcements.
03:52:57 <Olathe> > foldl lcm 1 (map (\x -> x*x) [2..80])
03:52:59 <lambdabot>  1051955226159785296527938644268159905745060258708849004347541404160000
03:53:58 <wli> Meaningful divisibility conditions on the numerator and denominator are probably a bit more involved than that.
03:54:16 <MyCatVerbs> Olathe: why do you want the lowest common multiple of the first eighty square numbers...?
03:54:40 <MyCatVerbs> (And oughtn't it be equal to the lcm of the first eighty natural numbers anyway?)
03:54:52 <MyCatVerbs> > foldl lcm 1 [2..80]
03:54:53 <lambdabot>  32433859254793982911622772305630400
03:54:57 <sieni> MyCatVerbs: no
03:55:00 <wli> The square of their lcm.
03:55:04 <MyCatVerbs> Oh, no. Well, buggery.
03:55:10 <drigz> > foldl lcm 1 [2..80] ^ 2
03:55:11 <lambdabot>  1051955226159785296527938644268159905745060258708849004347541404160000
03:55:23 <MyCatVerbs> ...ah, right. My bad. Was thinking gcd. >>
03:55:38 <wli> It'd be the square of their gcd likewise.
03:55:53 <Olathe> > let denom = foldl lcm 1 (map (\x -> x*x) [2..80]) in map (\x -> div denom (x*x)) [2..5]
03:55:55 <lambdabot>  [262988806539946324131984661067039976436265064677212251086885351040000,11688...
03:56:08 <wli> > foldl1 gcd [k*k | k <- [2..80] - (foldl1 gcd [2..80])^2
03:56:09 <lambdabot>  Parse error
03:56:15 <wli> > foldl1 gcd [k*k | k <- [2..80]] - (foldl1 gcd [2..80])^2
03:56:17 <lambdabot>  0
03:56:28 <Olathe> Then, you only need to add Integers until you get hald the lcm.
03:56:28 <MyCatVerbs> > (foldl gcd 1 [2..80]) - (foldl gcd 1 $ map (\x->x*x) [2..80])
03:56:30 <lambdabot>  0
03:56:32 <Olathe> half
03:56:54 <MyCatVerbs> > (foldl gcd 1 [(2::Integer)..80]) - (foldl gcd 1 $ map (\x->x*x) [2..80])
03:56:55 <lambdabot>  0
03:57:10 <wli> Olathe: The integers are not necessarily consecutive.
03:57:14 <Olathe> Right.
03:57:19 <Olathe> It would be like subset sum.
03:57:34 <Olathe> Or however you're doing it.
03:57:35 <drigz> > (foldl gcd 1 [(2::Integer)..80])
03:57:36 <lambdabot>  1
03:57:46 <drigz> so it's not a particularly suprising result :p
03:57:57 <Tchakkazulu> :P
03:58:01 <Olathe> The main thing is that you're not using floats or rationals. You're using exact values.
03:58:04 <drigz> *surprising
03:58:14 <wli> Rationals are exact.
03:58:19 <Olathe> I know.
03:58:20 <EvilTerran> aren't rationals ex- i thought so.
03:58:24 <Olathe> I meant those are a bit slower.
03:58:28 <Olathe> Perhaps.
03:58:30 <Olathe> I don't know.
03:58:34 <wli> The arithmetic doesn't matter here.
03:58:40 <wli> Rationals are indeed exact.
03:58:45 <Olathe> I know.
03:59:10 <Olathe> No need to do reduction between steps.
03:59:30 <wli> Olathe: Except to keep the numbers manageably small.
04:02:06 <Olathe> I wonder if it all works out the same mod 2^32.
04:02:43 <Olathe> You could do it that way and check all candidates.
04:03:20 <Olathe> Never mind, that fails in some ways.
04:04:26 <MyCatVerbs> > (-)(fromIntegral $ foldl lcm 1 [(2::Int)..80]) $ foldl lcm 1 [(2::Integer)..80]
04:04:27 <lambdabot>  -32433859254793982911622771135808640
04:04:45 <MyCatVerbs> Nope, that blows the 32-bit bounds waaaaay out the water. :)
04:05:52 <Olathe> > let denom = foldl lcm 1 (map (\x -> x*x) [2..80]) in map (\x -> mod (div denom (x*x)) 2^32) [2..80]
04:05:54 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
04:05:58 <EvilTerran> > maxBound :: Int
04:05:59 <lambdabot>  2147483647
04:06:32 <ihope> Could Int be implemented as Integer?
04:07:14 <ihope> > [2147483645..]
04:07:15 <lambdabot>  [2147483645,2147483646,2147483647,2147483648,2147483649,2147483650,214748365...
04:07:22 <EvilTerran> something with the same semantics could be
04:07:23 <ihope> > [2147483645..] :: [Int]
04:07:24 <lambdabot>  [2147483645,2147483646,2147483647]
04:07:36 <ihope> So maxBound = last [0..]
04:07:41 <wli> I've no idea what you all are on about.
04:07:45 <ihope> It's just a horrible way to calculate it :-)
04:07:47 <EvilTerran> ...could be implemented on top of Integer, i mean
04:08:03 * EvilTerran rips out his return key
04:08:03 <ihope> Does the spec say that Int is finite?
04:08:13 <wli> No. Only Integer.
04:08:38 <ihope> ...Integer is infinite, isn't it?
04:09:03 <EvilTerran> "The finite-precision integer type Int covers at least the range [ - 229, 229 - 1]. As Int is an instance of the Bounded class, maxBound and minBound can be used to determine the exact Int range defined by an implementation."
04:09:05 <MyCatVerbs> ihope: yes, you confused wli.
04:09:26 <EvilTerran> *[-(2^29),(2^29)-1]
04:09:28 <MyCatVerbs> ihope: the spec says Int must be, I think, something like thirty bits of wider, and Integer must be for-all-practical-purposes infinite.
04:09:39 <MyCatVerbs> s/thirty bits of/thirty-ish bits or/
04:09:59 <EvilTerran> http://www.haskell.org/onlinereport/basic.html#sect6.4
04:10:01 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
04:10:01 <MyCatVerbs> It might even be something like twenty eight bits in the Haskell 98 standard.
04:10:55 <MyCatVerbs> Ah, yes, thirty bit two's complement.
04:11:01 <EvilTerran> MyCatVerbs, 30 bits, if i've worked it out right from that part of the report
04:11:15 <EvilTerran> > (-(2^29),(2^29)-1)
04:11:16 <lambdabot>  (-536870912,536870911)
04:12:26 <EvilTerran> > iterate (*2) 536870912
04:12:27 <lambdabot>  [536870912,1073741824,2147483648,4294967296,8589934592,17179869184,343597383...
04:12:42 <MyCatVerbs> EvilTerran: yes. Yes, you have it correct. I should damn well hope so, because you and I believe that the answer is the same. :)
04:13:06 * EvilTerran thinks... so lambdabot's using 32-bit two-complement, in that case.
04:13:07 <MyCatVerbs> > (iterate (*) (2^29)) :: [Integer]
04:13:08 <lambdabot>  Couldn't match expected type `Integer'
04:13:59 <MyCatVerbs> EvilTerran: yes, most actual implementations - ghc, for example, actually provide 32bit signed. The spec leaves wiggle room for people who want to add tag bits and stuff.
04:14:24 <opqdonut> > (iterate (*2) (2^29)) :: [Integer]
04:14:25 <lambdabot>  [536870912,1073741824,2147483648,4294967296,8589934592,17179869184,343597383...
04:14:33 <opqdonut> > (iterate (*2) (2^29)) :: [Int]
04:14:34 <lambdabot>  [536870912,1073741824,-2147483648,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
04:14:37 <opqdonut> :)
04:16:08 <MyCatVerbs> opqdonut: oh, blast. Thanks, I only just noticed that typo.
04:16:15 <opqdonut> nw
04:16:17 * MyCatVerbs ceases scratching his head.
04:16:25 <wli> There is a vague CRT-esque bit there.
04:16:29 <Choko> maybe it could be done with integers
04:16:56 <Choko> and take the inverse of both sides
04:16:57 <MyCatVerbs> wli: CRT?
04:17:11 <Choko> and find a integer which 2..80 divides
04:18:43 <Choko> if you still talk about #152 :)
04:18:47 <MyCatVerbs> wli: I am failing to infer any connection between the current topic of conversation and old monitors. Presumably there is some other expansion of that particular acronym which you it might please you to explain to me, pretty pretty please with sugar on top?
04:18:48 <wli> Chinese Remainder Theorem
04:19:08 <wli> There's also Euler's continued fraction formula.
04:19:48 <MyCatVerbs> I'm sure I've read of that somewhere, though I can't for the life of me remember what it is. *googles*
04:21:14 <Cale> MyCatVerbs: It essentially says that if m and n have no factors in common (their GCD is 1), that Z/m x Z/n is isomorphic to Z/(mn)
04:21:23 <Cale> Where Z/m is the ring of integers modulo m
04:21:46 <MyCatVerbs> Wow, kewl.
04:21:50 <wli> I usually see it stated for n ideals.
04:22:06 <MyCatVerbs> Cale: nope, no clue what the heck you're talking about. I need to read more mathematics, badly.
04:22:09 <Cale> well, yeah, there are vast generalisations too :)
04:22:41 <Cale> To put that more concretely, it gives a way to solve systems of simultaneous congruences.
04:23:00 <Cale> x = a_1 (mod n_1), x = a_2 (mod n_2), ..., x = a_k (mod n_k)
04:23:19 <Cale> where n_i and n_j are coprime for all i and j
04:24:55 <osfameron> xerox: er, yeah, but I haven't spent time learning the library yet - will get around to it eventually :-)
04:25:21 <wli> There may be something with n/d = sum p_k/q_k
04:25:36 <osfameron> though don't ByteStrings only contain Chars rather than arbitrary data?
04:25:53 <Saizan> Word8
04:25:55 <mux> thay conain Word8s
04:26:17 <wli> a subset of p_k/q_k sums to n/d iff some condition holds maybe
04:26:51 <osfameron> are Word8s arbitrary data?
04:27:04 <xerox> osfameron: import Data.ByteString.Char8
04:27:16 <xerox> likewise there is .Lazy.Char8
04:27:25 <Saizan> no, they are 8 bits
04:27:45 <osfameron> ok, so ByteString isn't a general array type
04:27:48 <MyCatVerbs> Cale: yes, that makes sense.
04:27:53 <ricky_clarkson> DRMacIver: I did wonder how correct my assertion about final was - but thought if it was wrong someone would correct me.  Using reflection to do it means that you are, at some point, not treating your object as a function.  I think it's better to get rid of the cyclic data.
04:28:18 <ricky_clarkson> DRMacIver: I can't see what channels you're in, so if you want to suggest a better place for this, feel free.
04:28:28 <MyCatVerbs> Cale: but I don't know what on Earth a ring is and what on earth you mean by "isomorphic to" and what in the blazing forests of weed congurent numbers are.
04:28:42 <MyCatVerbs> Cale: I'm pretty certain I've been taught at least half of it, but I forget.
04:28:52 <DRMacIver> ricky_clarkson: Well, ##java is the obvious channel. ;) Shall we move to #haskell-blah for somewhere more mutually acceptable?
04:28:55 <wli> n/d + p/q = (q*n + d*p)/(q*d), so d*(n/d + p/q) = q*n + d*p with p,q > 0.
04:29:23 <wli> ergh
04:29:31 <Cale> oh, two integers m and n are congruent modulo k if m - n is a multiple of k
04:29:48 <wli> d*q*(n/d + p/q) = n + d*p with p,q > 0.
04:29:57 <wli> one more time
04:30:00 <Cale> Or another way to put that is that they give the same remainder when divided by k.
04:30:04 <wli> d*q*(n/d + p/q) = n*q + d*p with p,q > 0.
04:30:35 <Cale> In Haskell terms, n is congruent to m modulo k if (n `mod` k) = (m `mod` k)
04:31:16 <MyCatVerbs> Cale: did I mention I fucking love this IRC channel? :)
04:31:23 <Cale> :)
04:31:26 <deadmoon> hi
04:31:26 <MyCatVerbs> Cale: (thanks, incidentally. ^_^)
04:31:37 <MyCatVerbs> deadmoon: hello there!
04:32:28 <deadmoon> was wondering if you could digg http://digg.com/design/Funniest_Restaurant_Signs_and_Menus_sometimes_people_need_to_proof_read if you think its worth digging! :P (sorry for spammy like message! only digg if you like it
04:32:43 <Cale> A ring is an algebraic structure that captures some of what we tend to mean when we say "number". It's a set of elements together with a way to add those elements and multiply them which follows some of the basic rules that we're familiar with.
04:32:51 <Cale> http://en.wikipedia.org/wiki/Ring_%28mathematics%29 -- you can get the full list here
04:32:52 <lambdabot> Title: Ring (mathematics) - Wikipedia, the free encyclopedia
04:33:55 <Cale> If you take the set of integers {0,...,n}, you can turn it into a ring called Z/n where the addition and multiplication are the same as that for the usual integers, followed by modding out by n.
04:33:55 <EvilTerran> it's a group theory thing, isn't it?
04:34:08 <Cale> EvilTerran: Well, Ring theory is its own subject :)
04:34:17 <wli> Trying to think of what happens when it goes wrong.
04:34:20 <Cale> But it's an abstract algebra thing anyway :)
04:37:08 <byorgey> Also, every ring is a group (under its "addition" operation)
04:37:15 <Cale> right, an abelian grou
04:37:16 <Cale> p
04:37:25 <byorgey> right.
04:37:29 <Cale> (which just means that a + b = b + a)
04:37:41 <Cale> It's also a monoid under multiplication
04:37:44 <doserj> Bourbaki would differ :)
04:37:46 <EvilTerran> what about fields?
04:38:06 <wli> Rings are not monoids under multiplication. Such rings are called unital.
04:38:26 <byorgey> a field is a ring which is a group (not just a monoid) under multiplication, i.e. there are inverses.
04:38:36 <wli> Left or right unital if the identity is only one-sided.
04:38:37 <Cale> wli: No, that's a Rng :)
04:38:44 <wli> Cale: ???
04:38:58 <Cale> wli: I'm from a school where rings are unital by default.
04:39:09 <doserj> you mean Rig?
04:39:09 <byorgey> e.g. the rational numbers are a field
04:39:13 <Cale> and if you want them not to be, you say so explicitly :)
04:39:29 <wli> Cale: Non-unital rings are rings.
04:39:36 <Cale> wli: Not where I'm from.
04:39:43 <wli> Whatever.
04:40:04 <Cale> Rings have few enough properties as it is :)
04:40:21 <roconnor> I may have asked this before, but isn't a Ring without an identity an ideal?
04:40:22 <wli> byorgey: A field is a ring which is an *Abelian* group under multiplication. Noncommutative division rings such as quaternions exist.
04:40:27 <Cale> roconnor: yes
04:40:36 <roconnor> so it already has a name :)
04:40:38 <byorgey> wli: ah, yes, thank you
04:40:46 <EvilTerran> roconnor, or a rng. 'cos there's no *i*dentity. iirc.
04:40:59 <Cale> Not quite
04:41:10 <wli> This "rng" business is preposterous. Non-unital rings are just rings.
04:41:23 <Cale> A field is a ring such that nonzero elements form an Abelian group.
04:41:55 * EvilTerran hasn't done much abstract algebra, TBH, so i should probably stfu&rtfm before i talk any more nonsense ;]
04:41:55 <Cale> wli: Nah, I'd prefer to call them ideals.
04:42:24 * roconnor tries to remember the constructive definition of a field.
04:42:26 <Cale> Or pseudo-rings, or rngs, or something. They're not as useful as real rings.
04:43:09 <wli> Cale: They're just rings. "Unital" is clearly understood in context, which is essentially almost always.
04:44:01 <Cale> wli: Oh, so you're proposing to just have an overlapping definition, and let people sort out which is being used?
04:44:02 <wli> There's no standard alternative name for them because the name is "ring." Unital is merely understood to be the case almost always.
04:44:24 <wli> Cale: There is never really any confusion.
04:44:40 <byorgey> and then of course there are ings, and rgs, and rins, and...
04:44:49 <Cale> byorgey: heh
04:44:53 <byorgey> =)
04:45:04 <Olathe> Quick, someone make a Haskell snippet to remove letters from "ring".
04:45:26 <byorgey> > filterM (const [True, False]) "ring"
04:45:35 <lambdabot>  ["ring","rin","rig","ri","rng","rn","rg","r","ing","in","ig","i","ng","n","g...
04:45:42 <Cale> Really though, even just plain rings are pretty useless. You almost always want more structure than that.
04:45:43 <MyCatVerbs> Cale: rings sound identical to modulo arithmetic.
04:45:50 <wli> rational subset sums are hard
04:45:51 <Cale> MyCatVerbs: No, that's just Z/n
04:46:20 <Cale> MyCatVerbs: For another example, consider the n by n matrices whose entries are real numbers.
04:46:34 <Cale> You can multiply matrices, and add them, and they satisfy all the ring properties.
04:46:49 <Cale> (with 0 being the zero matrix, and 1 being the identity matrix)
04:47:48 <MyCatVerbs> Rings are a... generalisation of modulo arithmetic?
04:48:02 <EvilTerran> modulo arithmetic is a specialisation of rings
04:48:02 <Cale> remove modulo from that, and it's right :)
04:48:13 <Cale> Well, it's also right with it there
04:48:21 <byorgey> MyCatVerbs: more like rings are a generalization of numbers.
04:48:21 <Cale> But it sounds strange like that
04:48:21 <MyCatVerbs> Cale: ah, right, I phrased that wrong.
04:48:39 <MyCatVerbs> Modulo arithmetic is a specific instance of rings.
04:48:50 <MyCatVerbs> byorgey: ooooh, fancy.
04:48:53 <Cale> A ring is a set of things which behave sort of like you expect numbers to behave.
04:49:04 <Cale> But multiplication need not commute
04:49:18 <Cale> and there might not be inverses with respect to multiplcation
04:49:40 <MyCatVerbs> The requirement that multiplication must distribute over addition sounds, uh, nontrivial to achieve for rings of things that aren't just boring old natural numbers.
04:49:42 <Cale> If multiplication commutes, that is, for all x and y in the ring, you have x * y = y * x, then the ring is called a commutative ring.
04:49:56 <Cale> Natural numbers aren't a ring
04:50:08 <MyCatVerbs> Rings have to be finite?
04:50:13 <sieni> MyCatVerbs: certainly not
04:50:14 <Cale> Because of the property that inverses with respect to addition must exist
04:50:15 <EvilTerran> integers are a ring
04:50:15 <DRMacIver> Cale: At least not under addition and multiplication.
04:50:19 <ivant> MyCatVerbs, no
04:50:35 <Cale> DRMacIver: at least not what?
04:50:38 <sieni> MyCatVerbs: integers, rationals, reals and complex numbers form a ring under addition
04:50:38 <ivant> MyCatVerbs, integers form a ring
04:50:38 <MyCatVerbs> Cale: ahhh, right.
04:50:43 <Cale> DRMacIver: ah, okay
04:50:53 <ivant> MyCatVerbs, even integers form a ring too
04:51:00 <DRMacIver> Cale: The natural numbers aren't a ring under addition and multiplication. They are under the bitwise operations (isomorphic to the boolean ring of finite sets of natural numbers). :)
04:51:07 <Cale> DRMacIver: yeah, you can use them as the base set for a ring, but that's silly
04:51:12 <sieni> MyCatVerbs: vector spaces form a ring under vector addition
04:51:19 <ivant> MyCatVerbs, even integers form an ideal in a ring of integers
04:51:23 <sieni> MyCatVerbs: or rather "a vector space"
04:51:32 <DRMacIver> Cale: Well, it is a natural set of operations on them. So not that silly.
04:51:33 <Cale> In that case, any countable set is equally likely to be a ring :)
04:51:48 <MyCatVerbs> Rings are a specialisation of fields?
04:51:56 <Cale> MyCatVerbs: generalisation
04:52:07 <MyCatVerbs> Whoopsy, right.
04:52:09 <DRMacIver> Cale: I mean 'natural' in the informal sense. :)
04:52:11 <ivant> fields simply allow "division"
04:52:16 <Cale> A field is a commutative ring for which every nonzero element has a multiplicative inverse.
04:52:29 <ivant> yep, and commutation of multiplication
04:52:34 <Cale> That is, for every x not equal to zero, there is some y for which x*y = 1
04:53:27 <Cale> Examples of fields include the rational numbers, the real numbers, the complex numbers, and the integers modulo a prime.
04:53:29 <MyCatVerbs> Cale: so arithmetic mod k for some prime k is always both a field and a ring, and for composite k just a ring?
04:53:37 <Cale> right
04:54:13 <MyCatVerbs> http://programming.reddit.com/info/2hhsb/comments <-- best quote I've ever heard.
04:54:14 <lambdabot> Title: Data.SuffixTree – lazy, efficient suffix trees in Haskell (reddit.com)
04:54:33 <MyCatVerbs> "The 70s called. They want their upper bound back." <-- can't stop giggling.
04:54:41 <Cale> If k is composite, so k = a * b for a and b not equal to 1, then in Z/k, we have a*b = k = 0
04:54:51 <augustss> MyCatVerbs: yes, that was funny
04:54:55 <Cale> That is, a and b are zero divisors.
04:55:08 <Cale> It turns out that no field can have zero divisors.
04:55:20 <Cale> Because zero divisors are never invertible.
04:55:53 <Cale> To see that, suppose that in some ring R, we have a and b, both not zero, but a*b = 0
04:56:14 <Cale> Suppose in addition that y*a = a*y = 1, so a is invertible.
04:56:50 <Cale> but then y*(a*b) = y*0 = 0, but also, (y*a)*b = 1*b = b
04:56:57 <Cale> So 0 = b
04:57:12 <Cale> But we assumed that both a and b were nonzero, so this is a contradiction.
04:57:13 <MyCatVerbs> Cale: sorry to keep bugging you, but what does the notation "Z/k" mean, please?
04:57:25 <Cale> Z/k is the ring of integers modulo k
04:57:29 <wli> There has to be some sort of divisibility constraint here.
04:57:58 <Cale> It's also often written with k as a subscript
04:58:04 <Cale> or as Z/kZ
04:58:27 <Cale> If you want, I can give a proper formal definition
04:58:39 <Cale> Do you know about equivalence relations?
04:59:59 <MyCatVerbs> Cale: relations that are both transitive and commutative? Can't remember if there was a third property that had to be satis... oh yeah, reflexitivity.
05:00:17 <Saizan> +reflexive
05:00:19 <Cale> You can basically regard Z/k as being the ring whose elements are {0,...,k}, and where the operations of addition and multiplication are performed by first adding or multiplying as integers, and then taking the remainder after division by k
05:00:40 <Cale> MyCatVerbs: reflexive, symmetric, transitive
05:01:06 <MyCatVerbs> Cale: right, so Z/k means the same thing as "arithmetic mod k", but isn't so bloody verbose or ambiguous.
05:01:15 <Cale> right
05:01:37 <Cale> Another way to define Z/k which is a little prettier is by defining an equivalence relation on Z
05:02:02 <Cale> n ~ m if and only if n - m is a multiple of k
05:02:22 <Cale> Oh, do you remember what an equivalence class was?
05:02:45 <Cale> We can take Z/k to be the set of equivalence classes of Z under this relation ~
05:04:31 <Cale> If ~ is any equivalence relation on a set S, then the equivalence class containing the element x is defined as the set of elements equivalent to x, that is {y : y in S, x ~ y}
05:05:54 <Cale> The equivalence classes partition the set S into disjoint subsets.
05:06:29 <MyCatVerbs> Cale: "disjoint subsets" is implied by "partition", if I'm remembering the definition of partition correctly, right?
05:06:33 <Cale> yes
05:06:54 <MyCatVerbs> I think I owe you a beer by now.
05:06:57 <Cale> I'm just being verbose :)
05:07:12 <Cale> So in the case k = 2, with our relation n ~ m iff n - m is a multiple of 2
05:07:23 <Cale> that is if and only if n - m is even
05:07:29 <Cale> What are the equivalence classes?
05:07:40 <MyCatVerbs> No, you're explaining things properly, which is to say that you're expanding things that might (aren't guaranteed to) need expanding later, in order to preempt more questions. :)
05:07:50 <Cale> We have the stuff which is equivalent to 0, that is {0,-2,2,-4,4,-6,6,...}
05:08:03 <Cale> right :)
05:08:25 <b_jonas> (lol, set infinite only to the right, that sounds like haskell)
05:08:34 <Cale> So all the even integers are in the equivalence class containing 0
05:08:55 <MyCatVerbs> Yarf, I just looked up equivalence classes when you mentioned them. Danke. :)
05:08:56 <Cale> and then we have all the stuff which is equivalent to 1
05:09:15 <Cale> {1,-1,3,-3,5,-5,...}
05:09:32 <sek> @users
05:09:33 <lambdabot> Maximum users seen in #haskell: 419, currently: 390 (93.1%), active: 19 (4.9%)
05:09:44 <sek> yikes
05:09:48 <Cale> For the time being, let's write [n] for the equivalence class containing n
05:10:10 <b_jonas> (though two-way infinity can be ugly when you say the left shift operation maps the sequence [..., x_{-2}, x_{-1}; x_0, x_1, ...] to [..., x_{-1}, x_0; x_1, x_2, ...])
05:10:20 <Cale> (later on, once we're more confident with the ideas, we tend to drop the brackets)
05:10:32 <MyCatVerbs> Cale: bloody Hell.
05:10:39 <MyCatVerbs> Cale: do you TA or lecture anywhere?
05:10:44 <Cale> MyCatVerbs: no
05:10:52 <Cale> MyCatVerbs: I'd like to at some point :)
05:10:58 <MyCatVerbs> Cale: why the Hell no... ah, okay.
05:11:10 <wli> I wonder if [2,3,4] is necessarily a subset.
05:11:26 <MyCatVerbs> I'd damn well like you to, too. The more people learning more mathematics, the merrier. ^_^
05:11:56 <Cale> We define operations on the equivalence classes mod k by defining [a] + [b] = [a+b] and [a] * [b] = [a * b] -- but we need to check that this is well-defined.
05:12:29 <Cale> That is, if [a] = [a'] and [b] = [b'], then does [a + b] = [a' + b']?
05:13:01 <Cale> Because if not, then that definition makes no sense.
05:13:38 <MyCatVerbs> Intuitively yes. I'd have to resort to proof by contradiction to prove it, and I'm lazy enough to want not to, but yes.
05:14:18 <Cale> So, suppose that [a] = [a'] and [b] = [b'], that means a ~ a' and b ~ b', and so a - a' = n * k and b - b' = m * k
05:15:23 * MyCatVerbs nods.
05:15:38 <MyCatVerbs> And all multiples of k are in the class [0].
05:15:38 <Cale> Then a + b = (a' - n * k) + (b' - m * k) = (a' + b') - (n*k + m*k) = a' + b' - (n+m)*k
05:15:51 <Cale> So a + b ~ a' + b'
05:15:58 <Cale> and [a + b] = [a' + b']
05:16:07 <Cale> The proof for multiplication is incredibly similar.
05:16:24 <MyCatVerbs> Damn that's sweet.
05:16:25 <b_jonas> basically, that's how you usually define rational numbers precisely if you already know about integers:
05:16:48 <Cale> Yeah, as a set of equivalence classes of pairs of integers.
05:17:08 <Cale> and the integers can be similarly defined as a set of equivalence classes of pairs of naturals
05:17:27 <b_jonas> you say that the pair (p, q) is equivalent to the pair (p', q') iff p*q' = p'*q
05:17:36 <Cale> yeah
05:18:12 <Cale> This thing which I just did for modular arithmetic is also generalisable to general rings.
05:18:14 <b_jonas> and then if you define addittion and multiplication like [(p, q)] + [(p', q')] = [(p*q' + p'*q, q*q'q)], you have to check that it's consistent
05:18:27 <b_jonas> same for multiplication
05:18:35 <Cale> However, you probably want to be a bit careful about what your equivalence relation is.
05:18:52 * MyCatVerbs nods.
05:19:14 <wli> Okay, I can see that either 3 or 4 or both are needed.
05:19:37 <b_jonas> this is, btw, described quite well in the book Élő Matematika (ed. Gábor Endréné, Tankönyvkiadó, Budapest, 1969)
05:19:54 <Cale> The way that it's done is by looking at the stuff which is going to be equivalent to 0
05:20:04 <Cale> In our case, it was the multiples of k
05:20:29 <Cale> and we ended up defining two things as equivalent if their difference was a multiple of k
05:20:51 <MyCatVerbs> b_jonas: that'd be helpful, except that I only speak three languages - Haskell, English and C. And neither my Haskell nor my English are much good right now :)
05:21:16 <Cale> So in the general case of rings, it would be nice to know which sets this construction will work for. (Perhaps not just the multiples of an element)
05:21:20 <b_jonas> (I'll go dining now so I'll read up on the following conversation about homomorphisms in abstract algebra and ideals in rings or whatever it turns out)
05:21:43 * MyCatVerbs ponders using (\x y->(length x) = (length y)) as ~ for giggles.
05:22:28 <b_jonas> (oh yeah, free semigroups as well)
05:22:33 <Cale> A subset I of a (commutative, for simplicity) ring R is called an ideal if it is:
05:22:34 <MyCatVerbs> (>>) for multiplication and (++) for addition?
05:22:47 <Cale> 1) Closed under addition: if a and b are in I, then so is a + b
05:23:07 <Cale> 2) Closed under multiplication from outside: if a is in I, and r is in R, then r * a is in I
05:23:38 <Cale> Notice the similarity of the second property to the idea that multiplying things by 0 gives 0
05:23:49 <kny> ideals...i like to think of it as some kind of black hole ;)
05:24:00 <scook0> MyCatVerbs: i.e. encoding the naturals as [a]?
05:24:02 <Cale> Here, multiplying things by ideal elements gives ideal elements.
05:24:02 <MyCatVerbs> Hang on, can I interrupt you with a quick question here, please? Addition and multiplication have to have these various properties - commutativity, distributivity and identity elements...
05:24:11 <Cale> MyCatVerbs: right
05:24:43 <MyCatVerbs> Do these relationships only have to hold under the particular function you're using for ~?
05:25:08 <Cale> Oh, right, we didn't actually prove that Z/k was a ring :)
05:25:14 <Cale> That's tedious, but doable.
05:25:29 <MyCatVerbs> Like, if I define ~ as (\x y->(length x) = (length y), * as (>>) and + as (++), for example...
05:25:51 <MyCatVerbs> Then I'll get different results for a+b and b+a, but they'll both be considered equivalent by the function ~.
05:25:58 <MyCatVerbs> Is that fine?
05:26:04 <Cale> Oh, that's not going to get you a ring, but it will get you something like the natural numbers.
05:27:01 <Cale> (the natural numbers aren't a ring, because rings are required to have the property that for every a in R, there is some b in R for which a + b = 0
05:27:01 <Cale> )
05:27:11 <Cale> That is, b = -a
05:27:19 <MyCatVerbs> Cale: supposing I use replacements for (>>) and (++) which recursively remove k elements from any list longer than k (where k is some big prime) from their results.
05:27:25 <Cale> oh
05:27:35 <MyCatVerbs> (Sorry, I should've thought of that first. Hmmm.)
05:27:44 <Cale> Then yeah, you'll end up with something isomorphic to the integers mod k.
05:28:00 <wli> It's a semiring.
05:28:20 <MyCatVerbs> So that the results you get will be entirely equivalent to Z/k, but the values being passed around would be completely silly and the whole thing'd be intolerably slow. :)
05:28:32 <wli> Lots of ring results hold for semirings.
05:28:35 <MyCatVerbs> (Er, the equivalences would be...)
05:28:56 <wli> (In fact the homomorphism theorems have equivalents in a universal algebra setting.)
05:29:03 <Cale> (\x y -> length x `mod` k == length y `mod` k)
05:29:14 <MyCatVerbs> Is that what isomorphic means? That the same expressions in two different systems give the same results under those systems' equality and inequality relations?
05:29:54 <MyCatVerbs> Cale: ah, that'd be quicker. :)
05:29:57 <wli> It's a bijection respecting the structure.
05:29:59 <Cale> MyCatVerbs: Well, it means that there's a pair of functions from one to the other which are inverses, and such that the operations are preserved by them.
05:30:27 <wli> Use @ and # for the operations. f(a @ b) = f(a) # f(b)
05:30:43 <wli> That's homomorphism.
05:30:52 <wli> Isomorphism means it's a bijection.
05:30:55 <Cale> Let R and S be rings
05:31:08 <Cale> A ring homomorphism is a function f: R -> S such that
05:31:23 <Cale> 1) f(0) = 0
05:31:33 <Cale> 2) f(a+b) = f(a) + f(b)
05:31:41 <Cale> 3) f(-a) = -f(a)
05:31:47 <Cale> 4) f(1) = 1
05:31:55 <Cale> 5) f(ab) = f(a)f(b)
05:32:02 <xerox> Isn't 1 just a theorem?
05:32:11 <Cale> You can cut that list down, certainly.
05:32:15 <xerox> Alright.
05:33:15 <MyCatVerbs> "f: R -> S", where does this notation come from, please? Just curious because I've seen it used to denote arrows in category theory.
05:33:17 <Cale> Note that (1) means that f is sending the zero of R to the zero of S -- those might be two different things.
05:33:33 <Cale> Yeah, it came originally from category theory.
05:33:41 <Cale> But it's spread throughout mathematics now.
05:34:11 <Cale> That means that f is a function whose domain is R and whose codomain is S.
05:34:37 <MyCatVerbs> I'm also curious as to whether mathematics is easier to comprehend while stoned. Having never tried it myself... :)
05:35:13 <scook0> it might be easier to convince yourself you've comprehended it ...
05:35:14 <Cale> I think it depends on what you're taking and which mathematics you're doing. I don't use drugs myself.
05:35:35 <MyCatVerbs> Codomain? *googles*
05:35:43 <Cale> Let's define 'function' :)
05:35:53 <fuxxx> @src sum
05:35:54 <lambdabot> sum = foldl (+) 0
05:35:55 <MyCatVerbs> Ahh...
05:36:03 * Cale sends all the damn constructivists out of the room now.
05:36:05 <MyCatVerbs> Can't *all* functions be given as having the codomain U?
05:36:12 <fuxxx> how come sum doesn't use foldl'? (just curious since i stack-overflowed with it right now, heh)
05:36:18 * ddarius would think f : A -> B preceded category theory.
05:36:23 <Cale> MyCatVerbs: We don't tend to have a universal set.
05:36:33 <Cale> ddarius: I thought that too, but apparently not.
05:37:00 <ddarius> fuxxx: Because the Report tends to have functions as lazy as possible and foldl' isn't even in the standard libraries.
05:37:02 <scook0> but the codomain chosen for your function is somewhat arbitrary
05:37:08 <ivant> fuxxx, I recall there was some good reason to make it use foldr
05:37:16 <Cale> If you look in books that are only 70 years old or so, you won't find it.
05:37:27 <xerox> > sum [13:36]
05:37:32 <xerox> oops.
05:37:33 <lambdabot>   add an instance declaration for (Num [t])
05:37:33 <lambdabot>     In the expression: sum [13 : ...
05:37:47 <MyCatVerbs> s/:/../
05:37:47 <ddarius> Cale: I'm not saying category theory didn't popularize it.
05:38:31 <MyCatVerbs> scook0, Cale: right, so there's no limitation on how "large" a codomain can be, so long as it's equal to or a superset of the function's range?
05:38:42 <ddarius> But then I guess Frege's crazy notation wasn't that long ago.  It's only been relatively recently that people started talking about functions between arbitrary things.
05:38:48 <Cale> MyCatVerbs: right
05:38:58 <scook0> MyCatVerbs: though if you relax a function's codomain, you might lose some properties
05:38:58 <Cale> ddarius: yeah
05:39:00 <xerox> > sum [1..1000000]
05:39:02 <lambdabot>  500000500000
05:39:04 <b_jonas> ddarius: isn't that since Euler?
05:39:19 <Cale> MyCatVerbs: and strictly speaking, it's not really the same function anymore
05:39:21 <MyCatVerbs> Sounds useful, for circumstances where it's easier to prove that a function has a given codomain than to prove its range, and knowledge of the codomain suffices for what you're doing.
05:40:07 <gleb> fuxxx: Lazy sum can make sense sometimes (e.g., for Peano numbers)
05:40:10 <b_jonas> anyway, for these extensions like the one from integers to rationals to be usable, there are two other important things in addittion to the operations being well-defined (consistent with the equiv relation)
05:40:12 <Cale> A function f: A -> B is a set of pairs (a,b) for a in A and b in B, such that for each a in A, there is exactly one b in B for which (a,b) is in f.
05:40:31 <Cale> When (a,b) is in f, we write f(a) = b
05:41:02 <MyCatVerbs> b_jonas: a) we need to buy really big computers to simulate them on and b) we demand more caffeine?
05:41:12 <b_jonas> namely that the older set (the integers) can be embedded to the newer one (the rationals) in such a way that the operations work the same way on them (an integer p is mapped to [(p, 1)] in this case)
05:41:13 <Cale> In order to specify a function in general, you need to specify A, B, and the set of pairs.
05:41:29 * therp wonders how to code functional in visual basic
05:41:42 <b_jonas> and that the operations have most of the nice properties they had on integers, e.g. the ring properties
05:41:51 <Cale> therp: I think they're adding lambdas to VB.net soon.
05:41:51 <xerox> therp: you target VB from an Haskell compiler :)
05:42:16 <therp> xerox: that's also an option :)
05:42:22 <therp> cale: higher order functions in VB? :)
05:42:25 <MyCatVerbs> therp: what xerox said, or just write an interpreter for a language that doesn't suck. Scheme interpreters are surprisingly easy to write if you don't care about them being fast.
05:42:36 <Cale> therp: yeah.
05:42:41 <fuxxx> gleb, hm, ok. i'll take your word for it. :)
05:42:49 <osfameron> therp: I wrote map and join for VBA/VBScript when I used it
05:42:58 <Cale> VB apparently sucks a lot less now than it used to
05:42:58 <MyCatVerbs> osfameron: *gags*
05:42:59 <osfameron> acutally, I also wrote a source filter that implemented anonymous functions...
05:43:06 <therp> osfameron: how did you do that?
05:43:13 <Cale> What with Haskell people working on it and all.
05:43:16 <osfameron> but yeah, I think new VB is apparently a pretty decent language
05:43:40 <osfameron> therp: the anonymous function is cute, because function references already existed in VBScript (they just weren't documented as such :-)
05:43:51 <ddarius> We've subtly infiltrated the mainstream.
05:43:58 <MyCatVerbs> therp: old BASICs are technically just as powerful as, say, Lisp, and not just in the Turing-completeness sense, either. You can use their (crap) file I/O to write out textfiles and there's a LOAD command. :)
05:44:29 <therp> mycatverbs: oh, I think I have to leave now :) .. but interesting
05:44:30 <MyCatVerbs> Hell, you could always read and parse your own source code, if you had nothing better to do.
05:44:39 <ddarius> MyCatVerbs: That requires all values to be serializable.
05:44:46 <b_jonas> MyCatVerbs: lol
05:44:58 <MyCatVerbs> ddarius: what part of "shitty, old BASIC" did I fail to explain? :)
05:45:05 <b_jonas> ddarius: not really, because basic has MERGE which is sort of like overlays
05:45:12 <ivant> is there "lambdabot" language of choice on project Euler? :-)
05:45:28 <b_jonas> it can load the lines of a program while still keeping some of the old ones
05:45:35 <ivant> oh, it's haskell
05:45:36 <Cale> ivant: heh
05:45:40 <b_jonas> but in traditional BASIC, all values are serializable
05:45:57 <wli> Marshallable.
05:46:00 <b_jonas> I mean, all you have is (arrays of) integers, singles, doubles, and strings
05:46:06 <b_jonas> what can you have there that's not serializable
05:46:49 <b_jonas> and by strings I mean strings of at most 255 bytes, not real strings
05:46:57 <b_jonas> (65535 in wordbasic)
05:46:58 <MyCatVerbs> b_jonas: you don't even need MERGE. Just read your own source, append the new stuff, then write out a new file and load that :)
05:47:36 <b_jonas> MyCatVerbs: yeah, but the more popular alternative is escaping to machine code
05:50:11 <MyCatVerbs> b_jonas: I thought we were discussing "FUBAR but technically possible" rather than "actually useful" here.
05:50:27 <b_jonas> sure
05:52:59 <MyCatVerbs> "Actually useful" to me is swiping the manufacturer's datasheets for your CPU and writing an assembler. At least, compared to BASIC, anyway. Euuuugh.
05:53:49 <b_jonas> as for obfus like that, I once wrote a preprocessor for a c program in shell script, sed, and ed
05:54:12 <b_jonas> the source could have embedded ed commands prefixed by some mark, and the preprocessor would execute those
05:54:29 <b_jonas> so you could copy parts of the source s///ubstituting some stuff in the copy
05:54:30 <MyCatVerbs> ...
05:54:37 <MyCatVerbs> Why do you hate people?
05:57:14 <b_jonas> (and I heared that someone used sed to generate sed instructions for a golf)
05:57:31 <b_jonas> (wait, that's ambiguous)
05:57:39 <b_jonas> (and I heared that someone (used sed to generate sed instructions) for a golf)
05:59:39 <MyCatVerbs> b_jonas: which makes me wonder if you can achieve a Turing-complete machine by some variation on "while [ `du y` -gt 1 ] ; do cat x | sed `cat x` > y; mv y x; done" in a Bourne shell.
06:00:17 <scook0> b_jonas: (hear I (for golf (to (generate sed instructions) (used sed))))?
06:00:32 <b_jonas> MyCatVerbs: you don't even need that, sed is turing complete in itself by far:
06:00:47 <b_jonas> the gnu sed distribution comes with an implementation of dc in sed
06:01:11 <MyCatVerbs> b_jonas: whaaaaaat?
06:01:24 <flux> I wrote a hex adder in sed
06:01:41 <b_jonas> it has some magical code that does an addittion in two substitutions per digit, I don't understand how it works and could only do it in 4 substitutions, and I didn't even try to understand multiplication
06:01:45 <xerox> IIRC dons is a sed hacker :)
06:01:59 <Cale> I love dc :)
06:01:59 <gleb> fuxxx: Ok, I've just experimented a bit and proved I had been wrong. Lazy sum could have sense if it was defined using foldr
06:02:10 <b_jonas> my sed adder is up on the net somewhere...
06:03:23 <b_jonas> I love dc too
06:03:31 <cognominal_> does anyone where one can find the slides of the Gossett's talks at Google about parametric polymorphism?
06:03:50 <cognominal_> s/anyone/anyone know/
06:03:54 <b_jonas> my adder in dc: http://www.perlmonks.com/?node_id=388399
06:03:57 <lambdabot> Title: Re^2: --- adding a column of integers
06:05:24 <b_jonas> adder in sed I mean
06:06:49 <wli> Looks like it's worth precomputing some of the combinations of the first several choices.
06:06:50 <cognominal_> b_jonas, I have a solver of polyominos in Perl that uses regexen :) I won the tpj contest in the creative category for that :)
06:07:02 <wli> In terms of pi^2/6 that is.
06:07:39 <b_jonas> now that sounds bad.
06:08:08 <b_jonas> I've heared of prime factoring with regexen, but polyominos...
06:08:24 <olsner> what's a polyomino?
06:08:41 <b_jonas> olsner: like a tetris piece but bigger
06:08:52 <SamB_XP> or smaller
06:09:05 <olsner> ah, tetris is the special case for n=4
06:09:16 <cognominal_> http://en.wikipedia.org/wiki/Polyomino
06:09:17 <lambdabot> Title: Polyomino - Wikipedia, the free encyclopedia
06:09:19 <wli> Maybe the way to go is the pi^2/6 bit to generate starting points for, say, the first 10.
06:09:26 * ddarius is going to start calling squares unominos.
06:09:34 <SamB_XP> heh
06:10:04 <osfameron> eeek! perl -lpe '$-+=$_}{$_=$-'
06:10:24 <EvilTerran> that's ingenious
06:11:02 <EvilTerran> i wouldn't've called the variable $-, but that aside...
06:11:22 <cognominal_> solving polyominos is a sort of hello wolrd for me. When I will have done it in haskell, I will be happy.
06:11:41 <b_jonas> as for dc hacking, I'm not really good in that (dc has an annoyingly bad instruction set). the best I could manage is http://www.perlmonks.com/?node_id=626801 but I've seen much better dc hacks by others.
06:11:44 <lambdabot> Title: Re: Fibo Golf challenge on 3 monkeys
06:11:50 <EvilTerran> perl -pe '...' is the same as perl -e 'LINE: while (<>) { ... ; print $_ }', iirc
06:11:54 <roconnor> @check \z d p n -> z * d <= n ==> z * p <= (n * p) `div` d
06:11:55 <lambdabot>  Add a type signature
06:12:06 <roconnor> @check \z d p n -> z * d <= n ==> z * p <= ((n * p) `div` d::Integer)
06:12:07 <lambdabot>  Exception: divide by zero
06:12:22 <roconnor> @check \z d p n -> 0 <= d && z * d <= n ==> z * p <= ((n * p) `div` d::Integer)
06:12:23 <lambdabot>  Exception: divide by zero
06:12:31 <EvilTerran> so that's the same as 'LINE: while (<>) { $- += $_ } { $_ = $- ; print }'
06:12:39 <roconnor> @check \z d p n -> 0 < d && z * d <= n ==> z * p <= ((n * p) `div` d::Integer)
06:12:40 <lambdabot>  Falsifiable, after 1 tests: -2, 3, -2, -3
06:12:40 <b_jonas> cognominal_: well, I can solve the 6x10 polyomino by hand but only in one way because I've learnt a solution
06:12:42 <yaxu> i'm trying to find the integers that an integer is divisible by, is there a less naive way than this: divs x = filter (\y -> 0 == (x `mod` y)) [1 .. (x `div` 2)]
06:13:04 <roconnor> @check \z d p n -> 0 < d && 0 < p && z * d <= n ==> z * p <= ((n * p) `div` d::Integer)
06:13:05 <lambdabot>  Arguments exhausted after 130 tests.
06:13:06 <b_jonas> (that pentomino pattern is on http://www.perlmonks.com/?node_id=295576)
06:13:08 <lambdabot> Title: ambrus
06:13:08 <tuomov_> Is there a bug in GHC 6.6 re: fundeps?
06:13:25 <tuomov_> or is being unable to have the same type at both ends a feature?
06:13:28 <EvilTerran> so much the same as 'while ($_ = <STDIN>) { $t += $_ }; print $t'
06:13:32 <cognominal_> b_jonas things get interesting when you givesthe thirs dimension  to polyominoes
06:13:50 <tuomov_> data Presentation a b | a -> b where ...
06:14:02 <tuomov_> instance Storable a => Presentation a a where ... GHC starts crying
06:14:16 <cognominal_> and solve the  3x4x5
06:14:23 <tuomov_> works fine if I do Presentation (Native a) a or so..
06:14:34 <ihope> > (((((10^2)^2)^2)^2)^2)^2
06:14:36 <lambdabot>  10000000000000000000000000000000000000000000000000000000000000000
06:14:44 <ddarius> tuomov_: That's similar to writing instance Monad a => Functor a where
06:14:45 <EvilTerran> tuomov_, what error do you get?
06:14:45 <cognominal_> what the name. Thas is not a cube because the lenght in each dimension is different
06:14:59 <EvilTerran> cuboid?
06:15:11 <ddarius> Rectangular prism
06:15:13 <wli> S is invalid if pi^2/6 - sum S < 1/2
06:15:27 <b_jonas> oh yeah, I can solve the 3x3x3 puzzle as well
06:15:30 <tuomov_>     Couldn't match expected type `b' (a rigid variable)
06:15:30 <tuomov_>            against inferred type `a' (a rigid variable)
06:15:42 <tuomov_>       Expected type: Ptr c -> IO b
06:15:42 <tuomov_>       Inferred type: Ptr c -> IO a
06:15:55 <tuomov_> etc.; that's probably the most essential part
06:16:08 <EvilTerran> thrice face-perpendicular paralleliped?
06:16:40 <cognominal_> EvilTerran: probably, good name for a difficult problem.
06:16:42 <ihope> Isn't it parallelepiped?
06:16:58 <tuomov_> it seems to confuse things, merging types to early or so
06:17:05 <EvilTerran> ihope, ah, yes, i thought that didn't have enough 'p's in it
06:17:10 <b_jonas> cuboid is ok  think
06:17:27 <cognominal_> in 3D, I can only find a solution by finding internal symetries in a existing one.
06:17:35 <ddarius> It's a rectangular prism
06:17:48 <ihope> I know "parallelepiped" has three times as many syllables as "cuboid".
06:17:58 <cognominal_> b_jonas : have you read the book by samuel Golomb
06:18:10 <b_jonas> no
06:18:21 <EvilTerran> tuomov_, might there be a fundep collision or something?
06:18:43 <sieni> EvilTerran: s/paralleliped/parallelepiped/
06:19:00 <EvilTerran> sieni, yes, we already discussed that, thanks
06:19:02 <ski> tuomov_ : fundeps on 'data' ? associated type ?
06:19:06 <tuomov_> I don't know what a collision is, but it seems like it thinks of the types as same too early
06:19:30 <sieni> EvilTerran: oops, didn't notice O:-)
06:19:48 <cognominal_> oops, that's Salomon : http://en.wikipedia.org/wiki/Solomon_W._Golomb
06:19:52 <EvilTerran> as in, do you have something else that's Storable that has a different instance of Presentation with it as the first parameter?
06:19:56 <tuomov_> data Native a = Native a; instance Storable a => Presentation (Native a) a where ... works
06:20:12 <tuomov_> but if I remove that Native-wrapper, it starts crying, and that seems like a bug to me
06:20:34 <tuomov_> the first parameter to Presentation is never actually used except as parameter to Ptr
06:21:00 <tuomov_> lets me code stuff like Word32LE (little endian) in the type system...
06:22:09 <doserj> tuomov_, i think you need to paste more code for people to be able to help you...
06:22:13 <doserj> @hpaste
06:22:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:24:11 <tuomov_> http://hpaste.org/2386
06:24:13 <gleb> There's something I don't quite understand about impredicativity. Can somebody enlighten me why code snippet (http://hpaste.org/2385) won't compile?
06:24:53 <gleb> I know a workaround (wrap A in newtype), but I'm just curious, where the current behaviour is documented
06:26:58 <opqdonut> err, how is "foo f id" going to typecheck with foo :: Foo a -> a -> Bool?
06:27:22 <opqdonut> that invocation would mean it's type is Foo a -> (a -> a) -> Bool
06:27:24 <opqdonut> or something
06:28:07 <mrd> Foo (a -> a) presumably
06:28:08 <gleb> no, f is Foo A, which should expand to Foo (forall a. a -> a)
06:28:20 <mrd> forall a. a->a in a type should be equivalent to just a->a
06:28:36 <mrd> i think that might be your problem
06:28:39 <EvilTerran> i'd leave out the forall, personally. it's asking for trouble.
06:30:44 <tuomov_> any ideas?
06:30:46 <gleb> mrd: forall a . a->a is equivalent to a->a, but Foo (forall a. a ->a) -> (forall a. a ->a) -> Bool is not equivalent to Foo (a->a) ->  (a->a) -> Bool
06:31:06 <mrd> gleb: right, if it's doing the substitution like that
06:31:52 <mrd> gleb: for example, if you eliminate boom and do :info A
06:31:56 <mrd> you get: type A = a -> a.
06:32:17 <Gwern-away> I am kind of curious; I thought that one could manipulate pure values as if they were monadic by using  'return' to sort of promote them into a monad; but when I try, for example, (return "google") ++ getSelection (where getSelection :: IO String), it still doesn't type check
06:32:32 <mrd> Gwern-away: ++ doesn't work on IO String
06:32:33 <EvilTerran> "type" types don't really work like that, i think. there's restrictions in where you can put foralls, and "type" types are expanded before those restrictions are checked
06:32:36 <yaxu> > [1 .. 4, 6]
06:32:36 <lambdabot>  Parse error
06:32:42 <mrd> Gwern-away: you'd need to lift ++ into the monad too
06:32:49 <mrd> :t liftM2
06:32:58 <yaxu> > [1 .. 4] ++ [6]
06:32:58 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:32:59 <lambdabot>  [1,2,3,4,6]
06:33:29 <Gwern-away> oh. so the function as well as all the arguments need to be lifted... hmm.
06:33:31 <mrd> of course you're probably better off doing (("google"++) `liftM` getSelection)
06:33:50 <EvilTerran> of course!
06:34:02 <mrd> that will be typed IO String
06:34:15 <gleb> mrd: GHC manual says that 1) type synonyms are type-level macros, can contain foralls 2) Impredicative polymorphism allows for instantiation of type variables with polymorphic types
06:34:33 <Gwern-away> mrd: so... that uses currying to turn google++ into a function, and then liftM applies the new function to the result of the second one...?
06:34:34 <gleb> mrd: I see no reason why it is rejected
06:35:21 <mrd> Gwern-away: basicall
06:35:41 <mrd> gleb: admittedly i'm not clear on it either, i'd have to read a bit.  i'm just pointing out that :info A => a -> a
06:35:49 <dons> ?users
06:35:50 <lambdabot> Maximum users seen in #haskell: 419, currently: 392 (93.6%), active: 22 (5.6%)
06:35:54 <mrd> this may be a bug, or it may just be the behavior of type synonyms
06:36:12 <dons> hey the haskell 400. what code is hot today?
06:36:15 <dons> suffix trees?
06:37:43 <Gwern-away> dons: well, I'm trying to replace all the uses of xclip in my Xmonad config. dunno about everyone else
06:37:50 <gleb> mrd: output of :info is ambiguous, because forall can be omitted in 'a->a'
06:38:07 <gleb> dons: Yeah, suffix trees are hot
06:38:37 <dons> :)
06:38:54 <dons> STM-based b-trees too, I hear
06:39:29 <tuomov_> hmm... on-disk implementation?
06:42:54 <gleb> I just need generalized suffix trees with labeled leaves and cannot see by now, if Bryan O'Sullivan's implementation could be used or extended for that.
06:42:58 <dons> tuomov_: yeah. there's a couple of different projects for that
06:43:11 * gleb is reading Giegerich's paper
06:43:15 <tuomov_> link?
06:43:16 <dons> one commercial, one guy on the mailing list
06:43:32 <tuomov_> I'm going to have to implement B-trees too..
06:43:37 <doserj> tuomov_, it infers "Presentation a a" because your instance declaration simply forces it to be so (there can not be another instance Presentation a b, because that would violate the fundep)
06:43:37 <dons> i'll see if i can find the thread
06:44:37 <Gwern-away> (bloody hell. so 'liftM spawn (("google"++) `liftM` getSelection) :: IO (X ())' will do what I want, but it has to be in a list of X (). dagnabit)
06:45:02 <dons> tuomov_: Tom Conway and Andrew Bromage (Pseudonym in here) have done a commercial one, but there's also a thread today about another, http://thread.gmane.org/gmane.comp.lang.haskell.cafe/27827/focus=27828
06:45:05 <lambdabot> Title: Gmane Loom, http://tinyurl.com/2pjne3
06:45:07 <tuomov_> doserj: but it seems it can't deal with abstract code, that could deal with a=b, and a/=b; it infers a=b early, and then gets confused when it finds code that could deal with both that and a/=b
06:46:35 <doserj> well, ldef cannot deal with a/=b, simply because Presentation a b cannot deal with a/=b
06:46:51 <doserj> ghc here triggers the type-error a bit early
06:47:07 <doserj> but any use of ldef with a/=b would fail anyway
06:47:57 <tuomov_> would?
06:48:26 <doserj> well, you could not have an instance of Presentation a b with a/=b
06:48:38 <tuomov_> why?
06:48:42 <doserj> so at some point, it has to trigger a type-check error
06:48:50 <tuomov_> Works fine for (Native a) a
06:48:59 <tuomov_> or Int32LE Int32
06:49:04 <tuomov_> etc.
06:49:17 <tuomov_> and there a/=b
06:49:38 <doserj> because your fundep says a -> b, and you have an instance a a already
06:49:49 <tuomov_> uh?
06:49:57 <doserj> that's with the instance Storable a => Presentation (Native a) a?
06:50:17 <tuomov_> yeah, that Native-dummy variant works
06:50:28 <tuomov_> or compiles anyway..
06:50:43 <doserj> ldef type-checks ok if you do Presentation a a, so where is the problem=
06:52:15 <ski> tuomov_ : 'class Presentation a b | a -> b' means that (forall 'a') whenever 'Presentation a b0' and 'Presentation 'a b1' then 'b0 = b1'
06:52:42 <tuomov_> yes, I know that
06:53:04 <tuomov_> so I have I have Storable a => Presentation a a says that "all Storable types present themselves"
06:53:14 <ski> so 'instance Presentation a a' and 'Presentation t0 t1' for any types 't0','t1' means that 't0' and 't1' must be equal
06:53:29 <tuomov_> but I can have Presentation Int32LE Int32, with Int32LE a dummy type, to force little-endian presentation
06:53:50 <tuomov_> this in no way conflicts with Int32 also having a native presentation
06:54:16 <doserj> it does, because then Int32 has two different presentations
06:54:18 <ski> and you don't intend 'Int32LE' to be in 'Storable' ?
06:54:50 <tuomov_> no (data Int32LE = Int32LE, and instance Presentation Int32LE Int32 where ... is all there is to it)
06:55:19 <ski> ok .. so i think the problem is that you can't state that 'Int32LE' will never be an instance of 'Storable'
06:55:20 <tuomov_> doserj: the fundep does not say it can't be so: it says Int32LE -> Int32, not the other way around
06:55:29 <doserj> but there is also Presentation Int32LE Int32LE (at least GHC cannot rule that out :)
06:55:59 <ski> and since ghc doesn't allow such negative instances, it just assumes that 'Int32LE' *could* (possibly later) be in 'Storable'
06:56:21 <EvilTerran> surely that's a -fallow-*-instances thing?
06:56:30 <ski> doserj : only if 'Storable Int32LE'
06:57:01 <ski> EvilTerran : i don't think there is an option for such
06:57:33 <ski> doserj : er .. sorry, that was rubbish
06:58:10 <tuomov_> I don't think that quite covers it..
06:58:23 <tuomov_> unless this is just GHC idiocy, (i.e. bug :)
06:58:26 <ski> ('that' being ?)
06:58:39 <tuomov_> that something could once be Storable
06:59:29 <tuomov_> and how does it figure out that there is no fundep conflict anyway? Locally within the imports of the module?
06:59:59 <ski> i'd assume so
07:00:35 <tuomov_> should be quite easy there to find out all the conflicting instance attempts
07:01:12 <tuomov_> (within that local context)
07:01:28 <SamB_XP> tuomov_: why doesn't it have, uh, any fields?
07:01:39 <ski> it's a dummy
07:01:44 <tuomov_> instance Storable a => Presentation a a should only say that 'Storable types can have no other presentation'
07:01:48 <SamB> well why's it called that?
07:01:54 <tuomov_> which is no big problem in that local context
07:02:11 <SamB> why not a wrapper that you can use on IntN/WordN ?
07:02:22 <tuomov_> SamB_XP: Int32LE? It's a dummy used to specify endianness within the type system
07:02:37 <tuomov_> only used as parameter to Ptr etc.
07:02:59 <tuomov_> for accessing on-disk data structures
07:03:03 <tuomov_> and specifying them
07:03:08 <SamB> like, uh, newtype AtEndian endianness type = AE type
07:03:16 <SamB> or something
07:03:47 <tuomov_> yes, you could have instance Presentation (LittleEndian Word32) Word32, but Word32LE gives a nice dummy constructor for ldef
07:04:02 <SamB> ldef?
07:04:13 <tuomov_> ldef 4 Word32LE instead of ldef 4 (undefined::(LittleEndian Word32))
07:04:21 <SamB> oh
07:04:22 <tuomov_> defines set/get accessors for structures
07:05:08 <taruti> ldef 4 word32le; word32le :: LittleEndian Word32; ...
07:05:34 <SamB> where do you actually use ldef anyway?
07:05:36 <tuomov_> yes, you can do that. you can do things many ways, after all
07:05:40 <ski> (hm .. i guess the question is whether the checking should be conservative (disallow if later instances can be nonsense) or permissive (disallow only when actually using bad instances) .. i'm actually not sure which ghc uses (i.e, is meant to use) in this case)
07:05:44 <tuomov_> in another module
07:06:12 <taruti> Just seems that little/big endian parametrized types would allow for more shared code than invidual types.
07:06:23 <tuomov_> probably the Native wrapper is better indeed, indicating native presentation, but it just seems odd that it starts crying without it
07:06:45 <SamB> taruti: possibly just less code
07:06:47 <tuomov_> taruti: you still need lots of specific code..
07:07:24 <tuomov_> can't have just everything in LittleEndian, just suitable other types
07:07:50 <tuomov_> and you need those dummy variables for convenient use of every type... it's not a big difference
07:08:16 <tuomov_> and not relvant to the issues GHC has with Presentation a a ...
07:08:47 <taruti> class EndianConv a b where endianConv :: Storable t => a t -> b t
07:08:54 <SamB> well I have issues with Presentation a a myself
07:09:09 <taruti> hmm, that is too general.
07:09:33 <tuomov_> I use Presentation for other things too
07:09:34 * SamB had a class once that matched Int- types with Word- types
07:09:43 <tuomov_> not just endian shit
07:09:51 <tuomov_> stuff that won't be Storable
07:10:03 <SamB> I was going to use it in an MMIX implementation
07:10:08 <tuomov_> because doing so would require specifying unnecessary data structures for the haskell side
07:10:15 <SamB> but I think I'd rather just implement ARM ;-)
07:11:10 <SamB> I really think he should have just used ARM actually
07:11:19 <SamB> ARM seems so damn pretty
07:11:47 <SamB> MMIX seems almost worse than x86
07:12:17 <ivant> SPARC, anyone? :-)
07:12:46 <olsner> what's wrong with SPARC?
07:13:26 <ivant> olsner, well, nothing is, actually people who use its assembler seem to like it
07:13:57 <olsner> most RISC:y architectures seem pretty nice to code assembly for
07:15:30 <ivant> ahh, UM
07:16:07 <SamB> olsner: well, I haven't SEEN sparc assembly
07:16:21 <SamB> probably because I've got no SPARC compiler
07:16:42 <olsner> we generated sparc assembly for our compilator construction course
07:16:55 <ivant> olsner, oh, cool
07:17:09 <olsner> which was just enough to get the hang of it superficially
07:17:23 <SamB> I think the first ARM assembly I saw was the result of running objdump on some code I compiled with this ARM gcc I installed
07:17:39 <SamB> (it was intended for targetting PalmOS 5 devices)
07:18:20 * Cale considers implementing seam resizing.
07:18:27 <SamB> which I had one of before I sold it to my baby sister
07:19:01 <olsner> and after seeing MIPS assembly in binary, I must say it's got a pretty sensible binary representation - not anything like x86's big-ball-of-crud ISA
07:19:23 <SamB> anyway, I still think MMIX is almost worse than x86
07:19:54 <SamB> at least x86 doesn't have any pretense of regularity ;-)
07:20:22 <psykotic> olsner, it's very nice, but MIPS is little used. i don't know any MIPS-based computers in very wide use except for the PS2.
07:20:29 <SamB> also x86 has got plenty of documentation...
07:20:38 <SamB> ... all free
07:20:47 <olsner> zomg, the list of special registers here: http://en.wikipedia.org/wiki/MMIX
07:20:48 <lambdabot> Title: MMIX - Wikipedia, the free encyclopedia
07:20:55 <SamB> (even in dead tree form)
07:20:57 <psykotic> olsner, i think ARM is a pretty good compromise.
07:21:31 <SamB> anyway, when I said he should have just used ARM I did not mean to imply that some other architecture wouldn't have done as well as that
07:21:39 <psykotic> olsner, x86 has a lot of equivalent to these things. instead of registers they're just stored in main memory.
07:21:50 <psykotic> olsner, like the GDT and so on.
07:21:58 <olsner> s'pose so
07:22:02 <SamB> only that ARM would be, in my opinion, a heck of a lot better than MMIX
07:22:11 <shapr> yarr
07:22:35 <SamB> oh, don't even get me started on MMIX's mmu...
07:22:43 <psykotic> also... MMIX splits out data in separate registers that would be stored as bitfields on most real processors.
07:22:55 <psykotic> like, x86's EFLAGS register has a crapload of data packed into it, probably at least 14 fields
07:22:58 <ivant> good morning, shapr
07:23:07 <SamB> psykotic: I think it does the converse too :-(
07:23:39 <permanente> hm
07:24:22 <b_jonas> psykotic: what's your problem with EFLAGS? would you instead want to save 14 different registers in any sub that uses an arithmetic ops instead of just one?
07:24:39 <SamB> b_jonas: he didn't mention a problem
07:24:44 <psykotic> b_jonas, no, i am trying to shed some light on MMIX's proliferation of registers.
07:24:58 <b_jonas> SamB: "crapload" sounded like that to me
07:25:09 <SamB> b_jonas: that just means a lot
07:25:40 <b_jonas> I'm reading an amd64 architecture programming manual just now btw
07:25:54 <SamB> anyway... I wasn't even thinking about MMIX's crazy special registers when I mentioned how I'd prefer ARM
07:26:04 <psykotic> ARM is great.
07:26:12 <psykotic> even for hand assembly hacking.
07:26:15 <SamB> I was just thinking of the ill-defined semantics of exceptions -- I don't just mean imprecise, mind!
07:26:23 <SamB> and things like that
07:26:30 <psykotic> i had to do some MIPS assembly hacking by hand one time and it's a most unpleasant experience
07:26:41 <SamB> Knuth doesn't even give MMIX any peripherals!
07:26:43 <psykotic> whereas ARM, despite its relative RISCiness, is a pleasure
07:26:50 <SamB> how anyone is supposed to write NNIX is beyond me
07:27:03 <jbalint> what is NNIX
07:27:12 <psykotic> heh. i think it's funny that knuth designed MMIX as a way to make MIX "relevant" again.
07:27:24 <b_jonas> SamB: I think you should write NNIX as an OS-emulation thing like the linux emulation under freebsd
07:27:24 <psykotic> as if it ever was.
07:27:34 <SamB> heck, *MIX* is nicer than MMIX
07:27:37 <b_jonas> with a user-mode library and kernel-mode help
07:28:01 <b_jonas> yep, MIX is nice but I like the bitwise ops of MMIX
07:28:28 <SamB> does ARM have any free opcodes?
07:29:15 <b_jonas> no idea
07:29:27 <b_jonas> but z80 didn't have any free one-byte opcode anyway
07:29:53 <b_jonas> and x86 is close to that too
07:31:30 <psykotic> x86 already has some very exceptional opcode encodings
07:31:38 <psykotic> like, one i remember is the SSE addition instruction
07:31:38 <b_jonas> yep
07:32:07 <|Steve|> psadd or something?
07:32:23 <b_jonas> the problem with x86 is backwards compatibility
07:32:57 <psykotic> steve: not necessarily the packed scalar one. well, i can't remember which one.
07:33:04 <psykotic> i think all the add-family sse instructions
07:33:28 <|Steve|> Is that what ps stands for?
07:33:52 <|Steve|> I always wondered. I've written a tiny bit of altivec and sse. It was kind of fun.
07:34:07 <psykotic> the prefixes are mnemonical, yes
07:34:14 <psykotic> and unlike the MMX ones they are relatively memorable
07:34:26 <psykotic> the mmx mnemonics are insane
07:34:41 <psykotic> zsdhfkjasfhdkjzhsadd
07:34:44 <psykotic> or something like that :)
07:34:49 <|Steve|> I like how instead of mmx registers, they have xmm.
07:35:10 <psykotic> mmx is a pain in the ass. the xmm registers overload the fp register stack.
07:35:21 <|Steve|> The mmx registers do.
07:35:23 <psykotic> you can't interleave fp and mmx instructions. you have to do use a "context switch" to switch between fp and mmx.
07:35:25 <|Steve|> xmm are separate.
07:35:29 <psykotic> err, yeah
07:35:51 <|Steve|> I've never written mmx.
07:35:52 <psykotic> xmm is sse, brainfart
07:36:10 <psykotic> mmx is still useful for doing image manipulation
07:36:21 <|Steve|> They're only 64 bits wide, correct?
07:36:54 <psykotic> yes. but that's enough for 4x8 bits with no overflow-loss for multiplies
07:37:08 <psykotic> i.e. rgba8888
07:37:26 <psykotic> that's pretty much what MMX was designed for and it still works very well for that
07:37:31 <|Steve|> I see.
07:38:21 <|Steve|> Er, I just realized that we're off topic. I thought I was in #haskell-blah. Sorry all.
07:38:31 <psykotic> :)
07:38:37 <b_jonas> let's move there then
07:38:46 <ivant> oh, there is #haskell-blah?!
07:39:12 <shapr> Good morning ivant!
07:39:55 <dcoutts> @yarr!
07:39:55 <lambdabot> Where d' all t' pirates come from?
07:39:56 <lambdabot> Great Yarrmouth!
07:44:14 <shapr> hiya dcoutts!
07:44:31 <dcoutts> hia shapr
07:44:31 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
07:45:05 <dcoutts> hia conal
07:46:15 * |Steve| never gets any messages from lambdabot.
07:47:26 <shapr> dcoutts: Oh I found out the solution to my cabal problem, it's user error on my part.
07:47:49 <dcoutts> shapr: what was it? does it actually look in hs-src-dirs for Main?
07:49:26 <conal> dcoutts: hi
07:49:49 <dcoutts> conal: you were trying to use gtk2hs with ghc-6.7 on windows I believe
07:49:57 <shapr> dcoutts: Yeah, as long as you add hs-source-dirs to the executable stanza.
07:50:21 <byorgey> @tell |Steve| look, your very own message from lambdabot! =)
07:50:21 <lambdabot> Consider it noted.
07:50:34 <dcoutts> conal: that's a tad tricky for me to do for you, since I'd have to build with exactly the same ghc snapshot as you wanted to use, it might be easier for you to do, I've got scripts to do builds.
07:50:34 <|Steve|> Heh. Thanks!
07:50:34 <lambdabot> |Steve|: You have 1 new message. '/msg lambdabot @messages' to read it.
07:50:47 <dcoutts> shapr: ah yes, ok.
07:50:47 <conal> dcoutts: i didn't try very hard.  got stuck for a bit with wxhaskell and looked to see if there was a ghc2hs windows binary install for ghc-6.7
07:51:18 <dcoutts> conal: ghc's binary compatibility checks means that the version has to be exactly the same
07:51:39 <dcoutts> conal: since it includes the snapshot date into the .hi file version
07:52:07 <dcoutts> conal: so there'd be no point in anyone providing binaries for ghc 6.7 since they'd always be out of date, you'll have to build from source
07:52:44 <conal> dcoutts: wow -- i didn't realize it had to be an exact date.
07:52:48 <dcoutts> conal: but it is easier than it used to be, you just need the latest released tarball and the scripts that you can get from the gtk2hs darcs repo / website
07:53:15 <conal> dcoutts: oh, great.  even for windows?
07:53:28 <dcoutts> conal: yes
07:54:35 <dcoutts> conal: you need a gtk+-dev zip from here: http://haskell.org/gtk2hs/win32/ and I build using use the scripts from here: http://darcs.haskell.org/gtk2hs/tools/win32/
07:54:36 <lambdabot> Title: Index of /gtk2hs/win32
07:55:01 <dcoutts> conal: in that latter dir you want the files win32-build*
07:55:10 <conal> dcoutts: super.  i'm getting together new versions of Phooey etc, and Eros.  still using wxhaskell. if someone with gtk2hs experience wanted to work with me, i'd be interested in having a gtk2hs version and then adding cairo-based and opengl-based graphics.
07:55:19 <dcoutts> conal: the build requires mingw
07:55:30 <dcoutts> and MSYS, mingw's shell
07:55:41 <conal> dcoutts: thanks for the pointers.  i have mingw & msys.
07:55:54 <dcoutts> conal: and those scripts have some hard-coded paths you'll want to alter to fit your system
07:56:18 <conal> dcoutts: ok
07:56:35 <dcoutts> conal: you might not need the scripts actually, I just use them for automation, it basically does configure; make; make install
07:58:21 <Nucleo2> @src minimum
07:58:21 <lambdabot> minimum [] = undefined
07:58:21 <lambdabot> minimum xs = foldl1 min xs
07:58:49 <dcoutts> conal: hmm, one tricky aspect is that I build relocatable install images to use with an installer, so the package registration files have a variable or two in them that I substitute for at install time. I'm not quite sure what happens normally. You might need to edit those registration files by hand.
08:00:30 <Nucleo2> actually, a basic question. Why does minimum *not* use the strict foldl1' ?
08:00:46 <mauke> because it's stupid
08:01:28 <Nucleo2> I was wondering if there were any cases where laziness would save work, but I can't think of any.
08:01:36 <SamB> for some reason I have this urge to forward all queries about this to SPJ
08:02:07 <fuxxx> Nucleo2, i asked myself the same thing about sum (using foldl instead of foldl') a while ago today :)
08:02:44 <xerox> Anybody with an ieee subscription?
08:02:49 <Nucleo2> Guessing these things will all be changed in haskell' ?
08:03:23 <SamB> we hope so
08:03:29 <mauke> yes, haskell' appends a ' to all identifiers
08:03:34 <ivant> xerox, I can try to ask friends if they can get what you need, but it may take several days
08:03:45 <Nucleo2> ha
08:04:06 <xerox> ivant: let's see :-|
08:04:11 <conal> dcoutts: thanks for all the tips.  off now to work outside while it's still cool.
08:04:13 <sjanssen> is the maximum issue really bad in practice?  Strictness analysis should help there
08:04:13 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
08:04:20 <dcoutts> hia ndm
08:04:32 <osfameron> what's the benefit of a lazy foldl?
08:04:37 <Nucleo2> well, mainly one runs in constant space and the other causes stack overflows
08:04:57 <sjanssen> Nucleo2: does the stack overflow in the presence of GHC -O?
08:05:01 <|Steve|> xerox: No, but my school does and I can proxy in. What do you need?
08:05:02 <ndm> hi dcoutts
08:05:04 <ndm> dcoutts, i am 4 times faster than GHC in one benchmark :)
08:05:08 <dcoutts> woo!
08:05:40 <Nucleo2> sjanssen: yes.
08:05:44 <ndm> i loose on a few too, for reasons i don't entirely understand
08:05:50 <xerox> |Steve|: see the message?
08:05:56 <Nucleo2> (even with -O2)
08:06:00 <|Steve|> yes
08:06:15 <xerox> Thanks.
08:06:55 <sjanssen> Nucleo2: what type are you comparing?
08:07:09 <EvilTerran> osfameron, maybe if your function isn't strict in its first parameter?
08:07:37 <Nucleo2> sjanssen: integers, usually lists with several hundred thousand to several billion elements.
08:08:03 <osfameron> EvilTerran: ah, I was maybe thinking of the final result..
08:08:12 <EvilTerran> > foldl (flip (&&)) True [undefined, False]
08:08:13 <lambdabot>  False
08:08:16 <EvilTerran> > foldl' (flip (&&)) True [undefined, False]
08:08:18 <lambdabot>  Undefined
08:08:51 <ndm> dcoutts, what does dons do for the benchmarks that produce lots of output? i.e. digits-of-e2?
08:09:05 <dcoutts> ndm: no idea, ask him
08:09:46 <EvilTerran> so you need a non-associative function that isn't strict in its first parameter for lazy foldl to be useful
08:09:54 <sjanssen> Nucleo2: maximum on Int, Integer, and wrappers of both run in constant space on my machine
08:10:28 <ndm> i'd also love an account on his benchmarking machine :)
08:10:40 <Nucleo2> sjanssen: strange. I'm using ghc 6.6.1, even.
08:15:59 <shapr> benomatic: Nice hostname
08:27:43 <dmead> > liftM2 (,) [1..10] [-10..1]
08:27:45 <lambdabot>  [(1,-10),(1,-9),(1,-8),(1,-7),(1,-6),(1,-5),(1,-4),(1,-3),(1,-2),(1,-1),(1,0...
08:28:22 <Japsu> rrrr
08:28:30 <dmead> > [(x,y) | x<- [1..10] , y <- [-10..1]
08:28:30 <lambdabot>  Parse error
08:28:34 <dmead> > [(x,y) | x<- [1..10] , y <- [-10..1]]
08:28:35 <lambdabot>  [(1,-10),(1,-9),(1,-8),(1,-7),(1,-6),(1,-5),(1,-4),(1,-3),(1,-2),(1,-1),(1,0...
08:28:58 <Japsu> > sequence [[1..4], [-4..-1]]
08:28:59 <lambdabot>   Not in scope: `..-'
08:29:05 <Japsu> > sequence [[1..4], [(-4)..(-1)]]
08:29:06 <lambdabot>  [[1,-4],[1,-3],[1,-2],[1,-1],[2,-4],[2,-3],[2,-2],[2,-1],[3,-4],[3,-3],[3,-2...
08:29:16 <dmead> > [(x,y) | zip(x<- [1..10] , y <- [-10..1])]
08:29:16 <lambdabot>  Parse error
08:29:19 <dmead> xD
08:30:12 <xerox> dmead: just without the zip :)
08:30:56 <dmead> > [(x,y) | (x,y) < -zip [1..10] [-10..1]]
08:30:57 <lambdabot>   Not in scope: `y'
08:31:07 <dmead> boo
08:31:14 <dmead> > [a | a < -zip [1..10] [-10..1]]
08:31:15 <lambdabot>   Not in scope: `a'
08:31:17 <dmead> wtf
08:31:18 <dmead> xD
08:31:34 <dmead> > zip [1..10] [-10..1]
08:31:35 <lambdabot>  [(1,-10),(2,-9),(3,-8),(4,-7),(5,-6),(6,-5),(7,-4),(8,-3),(9,-2),(10,-1)]
08:31:36 <Botje> dmead: "a < -zip"
08:31:45 <dmead> ah
08:31:48 <Botje> try <- kthx
08:31:51 <dmead> > [a | a < zip [1..10] [-10..1]]
08:31:51 <lambdabot>   Not in scope: `a'
08:31:56 <dmead> > [a | a <- zip [1..10] [-10..1]]
08:31:57 <mauke> ...
08:31:57 <lambdabot>  [(1,-10),(2,-9),(3,-8),(4,-7),(5,-6),(6,-5),(7,-4),(8,-3),(9,-2),(10,-1)]
08:31:59 <dmead> hehe
08:32:04 <Botje> dmead: you need to get a better keyboard.
08:32:09 <dmead> yea ido
08:32:11 <dmead> it's an ms
08:32:15 <dmead> totally doesn't fit my hands
08:32:36 <mauke> "I have linux hands"
08:33:14 <dmead> lol
08:34:15 <shapr> Is Linux Hands like Jazz Hands?
08:36:52 <ndm> @src sum
08:36:52 <lambdabot> sum = foldl (+) 0
08:37:19 <drigz> is there a builtin function which iterates until a fixed point is found?
08:37:25 <sorear> no
08:37:31 <drigz> sorear: thanks
08:37:38 <sorear> we have a magic function which reaches a fixed point in one step
08:38:06 <sorear> but it does fixed points on extended domains, which isn't always as useful
08:38:17 <sorear> > fix (*2)
08:38:18 <lambdabot>  Exception: <<loop>>
08:38:31 <drigz> > fix (`div` 2)
08:38:33 <lambdabot>  Exception: <<loop>>
08:38:42 <sorear> aka ⊥, which is a fixed point of (*2) and strictly smaller than 0
08:39:10 <Royal_Son> Could someone please tell me what command i'd use to display the longest list e.g. in this case :  [[1,2],[3,2,7,8],[2]]  will display [3,2,7,8]
08:39:30 <drigz> maximumBy (compare `on` length)
08:39:30 <sorear> maximumBy (comparing length)
08:39:34 <drigz> although that's inefficient
08:39:41 <Royal_Son> wow that was quick
08:39:58 <psykotic> i think on is only available in 6.7
08:40:01 <psykotic> @hoogle on
08:40:02 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
08:40:02 <lambdabot> System.Console.Readline.onNewLine :: IO ()
08:40:02 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
08:40:24 <drigz> although we both used functions that your ghc probably won't have
08:40:50 <drigz> in fact, it's not inefficient for maximum, sorry
08:41:03 <drigz> in fact it is
08:41:07 <drigz> i should start thinking more often
08:41:47 <drigz> fst . maximumBy (comparing snd) . map (\xs -> (xs, length xs)) will be faster
08:42:00 <Japsu> !
08:42:03 <Japsu> @type comparing
08:42:06 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
08:42:15 <Japsu> ninjitsu
08:43:10 <mauke> @instances Monoid
08:43:11 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
08:43:41 <mauke> GT `mappend` LT
08:43:43 <mauke> > GT `mappend` LT
08:43:45 <lambdabot>  GT
08:43:47 <osfameron> @index comparing
08:43:47 <lambdabot> bzzt
08:43:52 <osfameron> @where comparing
08:43:52 <lambdabot> I know nothing about comparing.
08:44:03 <Japsu> hmm
08:44:05 <drigz> really going further than in necessary, none of the functions above will work if the list contains [1..]
08:44:07 <Japsu> @index maximumBy
08:44:07 <lambdabot> Data.List
08:44:09 <yaxu> @hoogle comparing
08:44:09 <lambdabot> No matches found
08:44:11 <Japsu> perhaps there?
08:44:33 <gleb> drigz: I wonder: wouldn't it be better if standard maximumBy f was defined as fst . maximumBy' (comparing snd) . map (\x -> (x, f x) ?
08:44:48 <osfameron> not in Data.List either, at least on 6.6.1
08:45:18 <drigz> gleb: but then you can't define your own fast compareLengths which works with one infinite list, and use that
08:45:23 <Japsu> @version
08:45:23 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
08:45:23 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:46:00 <drigz> gleb: and i think people don't like having two when one suffices?
08:46:04 <osfameron> Data.Ord
08:46:25 <osfameron> but that doesn't contain `on`
08:46:39 <drigz> osfameron: it's in 6.7 i think
08:47:15 <osfameron> ok ta
08:47:50 <gleb> drigz: i don't understand your comment about infinite list
08:48:04 <drigz> > length [1..]
08:48:09 <lambdabot> Terminated
08:48:22 <drigz> yet it is easy to determine that [1..] is longer than [1..4]
08:48:29 <osfameron> oh, latest stable is 6.6.1
08:48:45 <drigz> so you can write a function which compare lengths while only reaching the bottom of the shorter list
08:49:06 <gleb> drigz: I see (though I think Claus Reinke has showed how to workaround that with genericLength and Peano naturals)
08:50:04 <psykotic> @type let on p f x y = p (f x) (f y) in p
08:50:06 <lambdabot> Not in scope: `p'
08:50:06 <psykotic> @type let on p f x y = p (f x) (f y) in on
08:50:08 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
08:51:09 <psykotic> @type let on p f x y = p (f x) (f y) in (==) `on` snd
08:51:10 <lambdabot> forall a b. (Eq b) => (a, b) -> (a, b) -> Bool
08:51:15 <mauke> @. djinn type let on p f x y = p (f x) (f y) in on
08:51:17 <lambdabot> f a b c _ = a (b c) (b c)
08:51:41 <osfameron> what does djinn do?
08:51:59 <psykotic> it's just a simple theorem prover for propositional logic. the problem is that it doesn't use relevant logic.
08:52:04 <psykotic> i should say, the "problem", here.
08:52:06 <mauke> takes type signature, writes code
08:52:08 <drigz> osfameron: you give it a type signature and it gives you a function that has that type signature
08:52:20 <mauke> @djinn a -> (a -> b) -> b
08:52:21 <lambdabot> f a b = b a
08:52:33 <gleb> drigz: something like data Nat = Z | S Nat; instance Num Nat where ...; n = genericLength [1..] :: Nat; b = n > 0 -- yields True
08:52:36 <psykotic> relevant logic being a logic in which a proof from a given set of hypotheses has to invoke all hypotheses in an essential way. in this case, it would force it to use the last parameter.
08:52:37 <osfameron> oh, cute
08:52:57 * wli tends to do type Z = Integer
08:53:26 <mauke> @djinn b -> (a -> b) -> Maybe a -> b
08:53:26 <lambdabot> f a b c =
08:53:26 <lambdabot>     case c of
08:53:26 <lambdabot>     Nothing -> a
08:53:26 <lambdabot>     Just d -> b d
08:54:25 <b_jonas> nice
08:54:45 <ihope_> @free b -> (a -> b) -> Maybe a -> b
08:54:46 <lambdabot> Extra stuff at end of line
08:54:51 <ihope_> Bah.
08:54:59 <mauke> @free maybe :: b -> (a -> b) -> Maybe a -> b
08:54:59 <lambdabot> f . h = k . g => f . maybe x h = maybe (f x) k . $map_Maybe g
08:55:05 <ihope_> Oh.
08:55:23 <ihope_> Just what is @map_Maybe?
08:55:26 <ihope_> s/@$
08:55:34 <ihope_> Er, you get what I mean.
08:55:50 <mauke> probably fmap for Maybe
08:55:57 <mauke> I think the $ means "constant"
08:55:58 <|Steve|> ihope_: You're missing 2 slashes in that substitution.
08:56:00 <psykotic> the obvious thing, most likely. mapMaybe f Nothing = Nothing, mapMaybe f (Just x) = Just (f x)
08:56:23 <psykotic> @hoogle mapMaybe
08:56:23 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
08:56:24 <ihope_> |Steve|: indeed.
08:56:43 <psykotic> hm, that's a different one.
08:56:44 <osfameron> @djinn (a -> Maybe b) -> [a] -> [b]
08:56:44 <lambdabot> -- f cannot be realized.
08:56:45 <ihope_> @free f :: Maybe a
08:56:45 <lambdabot> $map_Maybe g f = f
08:56:47 <Mat^> hi :>
08:56:55 <ihope_> Mat^: elllo.
08:57:09 <psykotic> @djinn (a -> b) -> Maybe a -> Maybe b
08:57:09 <lambdabot> f a b =
08:57:09 <lambdabot>     case b of
08:57:09 <lambdabot>     Nothing -> Nothing
08:57:09 <lambdabot>     Just c -> Just (a c)
08:57:17 <ihope_> So does this mean that $map_Maybe g Nothing = Nothing?
08:57:23 <ihope_> @free f :: a
08:57:23 <lambdabot> g f = f
08:57:26 <mauke> yes
08:57:56 <mauke> hmm, doesn't this assume that g is strict?
08:58:14 <ihope_> Indeed, it does.
08:58:19 <ihope_> Either that, or that f is not bottom.
08:58:30 <ihope_> @free mapMaybe :: (a -> b) -> Just a -> Just b
08:58:30 <lambdabot> g . h = k . f => $map_Just g . mapMaybe h = mapMaybe k . $map_Just f
08:58:55 <ihope_> Now we have $map_Just as well...
08:59:19 <osfameron> is the $ part of the name or a section ?
08:59:28 <mauke> part of the name
08:59:40 <ihope_> Syntactically invalid name. :-)
08:59:43 <osfameron> what's the convention with that?
08:59:50 <mauke> @free map_Just :: (a -> b) -> Just a -> Just b
08:59:50 <lambdabot> g . h = k . f => $map_Just g . map_Just h = map_Just k . $map_Just f
09:00:08 <ihope_> Wait, Just instead of Maybe.
09:00:22 <ihope_> @free cat :: Lol a
09:00:23 <lambdabot> $map_Lol f cat = cat
09:00:30 <ihope_> I don't think $map_Lol is a builtin.
09:00:37 <mauke> $ indicates predefined functions
09:01:00 <kpreid> osfameron: it uses $ to refer to things that it's assuming definitions of as opposed to those occurring in your program
09:01:22 <ihope_> So what do these functions do?
09:01:24 <psykotic> > let $foo = 42 in $foo
09:01:25 <lambdabot>  Parse error
09:01:27 <osfameron> ah.  ok... actually I don't really understand what @free is doing
09:01:31 <psykotic> right. so basically it isn't valid lexical syntax.
09:01:49 <psykotic> i think. you can use it to generate symbols guaranteed not to clash with user definitions.
09:02:31 <ihope_> @free $map_Foo :: Foo a
09:02:31 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
09:02:35 <ihope_> Indeed.
09:03:18 <mauke> osfameron: free takes a variable and generates a theorem from its type
09:03:21 <ihope_> @free f :: ((a -> Cont r b) -> Cont r a) -> Cont r a
09:03:22 <lambdabot> Plugin `free' failed with: IRCRaised Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
09:03:28 <gleb> wli: what 'type Z=Integer' is useful for?
09:03:34 <ihope_> @free f :: ((a -> Contr b) -> Contr a) -> Contr a
09:03:34 <lambdabot> (forall q f1. $map_Contr h . q = f1 . g              =>               $map_Contr g (k q) = p f1) => $map_Contr g (f k) = f p
09:03:48 <psykotic> gleb: shorthand that recalls traditional mathematical notation.
09:04:40 <osfameron> mauke: it seems to be taking a function rather than a variable?  Or is a function just a variable?
09:04:55 <gleb> psykotic: ah, i thought it's somehow related to what i said about Peano numerals and genericLength
09:05:36 <mauke> osfameron: the latter
09:05:51 <LeCamarade> Okay ... I am building xmonad. I don't enjoy this, naturally. :o( Now ...
09:06:14 <mauke> a function is just a value of type x -> y for some x, y
09:06:25 <wli> gleb: It's shorter than Integer and is conventional in mathematics (it abbreviates the German "Zahlen").
09:06:33 <osfameron> @free i :: Integer
09:06:34 <lambdabot> i = i
09:06:38 <osfameron> nice theorem
09:06:42 <psykotic> ich liebe zahlenlehre
09:07:05 <|Steve|> @ba de en ich liebe zahlenlehre
09:07:05 <gleb> wli:  I see, thanks
09:07:06 <lambdabot>   I love pay-teach
09:07:09 <psykotic> osfameron, with which hegel would have disagreed. the law of identity denies change, man!
09:07:15 <mauke> @free plus :: Int -> Int -> Int
09:07:15 <lambdabot> plus = plus
09:07:18 <|Steve|> pay-teach?
09:07:22 <mauke> haha
09:07:35 <mauke> number-teachings
09:07:55 <osfameron> ba?  oh, the 'fish
09:07:56 <mauke> numbers = Zahlen; to pay = zahlen
09:07:57 <|Steve|> Yeah, I was pretty sure that zahlen is number or numbers.
09:08:18 <|Steve|> Ugh, that's horrible. You don't have different endings for verbs?
09:08:31 <mauke> no, why?
09:08:51 <mauke> oh, and to count = zählen
09:08:57 <|Steve|> Makes the language simpler to parse.
09:09:06 <mauke> for computers maybe
09:09:10 <|Steve|> I assume that ä is pronounced differently from a.
09:09:12 <psykotic> even latin has ambiguities
09:09:15 <mauke> yes
09:09:36 <mauke> the dots are not just decoration
09:09:36 <osfameron> even Haskell
09:10:00 <psykotic> you can generally tell the difference in writing by capitalization, steve
09:10:01 <mauke> which is why things like "motörhead" look silly :-)
09:10:05 <psykotic> nouns are capitalized
09:10:23 <osfameron> and even more importantly by context
09:10:29 <psykotic> yep, of course
09:10:31 <|Steve|> psykotic: I know I spend a lot of time on the internet, but not all of my communication is written. It's hard to speak capitalization.
09:11:08 <psykotic> i wonder how old this capitalization convention is. i suspect it didn't arise until the advent of printing.
09:11:47 <psykotic> just like most marks of punctuation. if you read old latin texts you'll see all caps letters with no punctuation at all. it takes "wall of text" to a whole new level.
09:11:50 <lament> even later, iirc
09:12:07 <wli> psykotic: Also numerous abbreviations.
09:12:17 <wli> google perligata
09:12:30 <Ben`> would Haskell be a good choice to make a web application in?
09:12:44 <mauke> http://search.cpan.org/~dconway/Lingua-Romana-Perligata-0.50/lib/Lingua/Romana/Perligata.pm
09:12:46 <lambdabot> Title: The CPAN Search Site - search.cpan.org, http://tinyurl.com/33tb6
09:13:03 <lament> "The terms upper case and lower case originated in the early days of the printing press used with movable type in letterpress printing. The individual type blocks used in hand typesetting are stored in shallow wooden or metal drawers, known as cases"
09:13:20 <drigz> psykotic: do you mean capitalisation of a specific purpose, or in general
09:13:29 <psykotic> in general
09:13:34 <drigz> wikipedia (or the gospel) says 1300 in europe
09:13:41 <|Steve|> Ha.
09:13:43 <psykotic> (also specific)
09:14:20 <wli> The miniscule vs. majuscle bit is comparatively recent, yes.
09:14:28 <|Steve|> Ugh. I managed to back up my ghc build's object files.
09:14:31 <gattocarlo> Ben`: after reading this I came to this conclusion: Yes! http://www.defmacro.org/ramblings/haskell-web.html
09:14:32 <lambdabot> Title: Haskell and Web Applications
09:14:59 <Ben`> gattocarlo, ok thanks: I'll give it a read :)
09:15:49 <osfameron> @index fields
09:15:49 <lambdabot> bzzt
09:16:48 <LeCamarade> What difference will there be if I don't have Xinerama and I go build Xmonad without them?
09:17:18 <r_rehashed> hi everybody
09:17:22 <r_rehashed> :)
09:17:35 <mauke> LeCamarade: do you have more than one monitor?
09:17:35 <byorgey> hi r_rehashed
09:17:40 <LeCamarade> Hi! :o)
09:17:47 <LeCamarade> mauke: No, only one.
09:17:52 <desegnis> LeCamarade, xmonad has no problems with xinerama not being present
09:17:58 <mauke> then you don't need xinerama
09:18:41 <r_rehashed> shapr: Hi
09:18:43 <LeCamarade> Okay ... (but I've apt-got the headers, just in case I abandon the Great People's Party sometime in the future).
09:19:56 <LeCamarade> Merde.
09:20:05 <desegnis> Are any gtk2hs insiders reading now?
09:20:13 <osfameron> Ben`, gattocarlo: that article looks very cool, but writing an actual web app would be more about libraries that exist and can be used now, than about cool techniques that could be developed to make templating funky.
09:20:32 <r_rehashed> is a new version of Haskell coming?
09:20:39 <LeCamarade> It seems I can't build either X11-extras or X11-1.2.2 ...
09:21:18 <r_rehashed> Haskell 2 or something?
09:21:34 <mauke> haskell'
09:22:07 <desegnis> mauke, I suppose they will rename it once it is official?
09:22:24 <mauke> probably
09:22:26 <desegnis> otherwise, we will end up with Haskell'' afterwards
09:22:27 <LeCamarade> desegnis: Don't be too sure. The name rocks, already. It may hold.
09:22:27 <psykotic> i think the terminus of the haskell' timeline is rather far in the future?
09:22:36 <Ben`> osfameron: are there any good libraries for making web apps?
09:22:56 <desegnis> LeCamarade, ;)
09:23:07 <psykotic> it involves backwards incompatible changes, right?
09:23:49 <Philippa> it's not supposed to involve many
09:24:04 <LeCamarade> But the prime name rocks hard. I find I no longer say `2.0'. For example, the next web is Web'. But the joke is never picked. :o(
09:24:09 <byorgey> Ben`: try HAppS, http://happs.org
09:24:11 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8.8 )
09:24:22 <Philippa> the idea was to put together the 'obvious' extensions that everyone uses. The process got rather stalled
09:24:26 <Ben`> ok, thanks
09:24:44 <LeCamarade> Ben`: Try, also, WASH. That is even apt-gettable.
09:24:47 <osfameron> why is the ' suffix "prime" ?
09:24:53 <LeCamarade> ?go wash haskell web
09:25:00 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
09:25:00 <lambdabot> Title: Web Authoring System Haskell (WASH)
09:25:10 <LeCamarade> osfameron: Blame Italy, I think. Or Greece.
09:25:31 * wli hopes Haskell' undoes various of the 1.4->98 regressions.
09:26:00 <r_rehashed> what are the regressions?
09:26:02 * desegnis would say, Haskell Strich
09:26:23 <wli> r_rehashed: oh, things like the removal of monad comprehensions
09:26:27 <r_rehashed> oh well, i should continue reading the tutorial :)
09:26:39 <mauke> Haskell made me understand the name "Metroid Prime"!
09:26:44 <mauke> thank you, haskell
09:26:58 * byorgey never thought of that... !
09:27:04 <Igloo> osfameron: prime, or prime mark, is a name for '
09:27:19 <SamB> well not really
09:27:23 <SamB> but we write it ' in ascii
09:27:44 <byorgey> Igloo: yes, but why?
09:28:09 <SamB> why?
09:28:17 <byorgey> ah: The name "prime" is something of a misnomer. Through the early part of the 20th century, the notation x′ was read as "x prime" not because it was an x followed by a "prime symbol", but because it was the first in the series that continued with x″ ("x second") and x‴ ("x third")
09:28:33 <byorgey> from http://en.wikipedia.org/wiki/Prime_%28symbol%29
09:28:34 <SamB> why is "I" a first-person singular pronoun?
09:28:35 <gattocarlo> osfameron: I was thinking about HAppS... then comes the cool generic approach
09:28:35 <lambdabot> Title: Prime (symbol) - Wikipedia, the free encyclopedia
09:28:51 <LeCamarade> Okay ... can't build Xmonad (even after bulding the X11-* right outta darcs) ... I'm afraid I'm too green on the exact procedure - any body care to give me a [Procedure (xmonad, build)]?
09:28:59 <SamB> byorgey: hmm, that is a bit of a misnomer
09:29:07 <r_rehashed> if i say, a:: Int, i am saying a returns an Integer, right?
09:29:22 <desegnis> LeCamarade, last time I tried, there was nothing to it (darcs version)
09:29:24 <Cale> r_rehashed: You're saying that a is an Int
09:29:30 <Igloo> r_rehashed: No, you are saying a is an Int
09:29:30 <LeCamarade> As in, a list of procedures? I have tried the usual runhaskell Setup.lhs configure|build and I die there.
09:29:47 <Cale> r_rehashed: (also note that Int and Integer are not the same type)
09:30:00 <r_rehashed> ok
09:30:08 <LeCamarade> desegnis: I am sure I am just getting some basic thing wrong. Like ... I try to build X11-extras, and it won't build with an error of ... (/me goes off to remake it)...
09:30:13 <Cale> > 2^100 :: Int
09:30:15 <lambdabot>  0
09:30:18 <Cale> > 2^100 :: Integer
09:30:19 <lambdabot>  1267650600228229401496703205376
09:30:19 <Saizan> LeCamarade: darcs xmonad goes with darcs X11*
09:30:30 <gattocarlo> LeCamarade: what's the problem with xmonad
09:30:36 <r_rehashed> oh range of the type is different
09:30:37 <dylan> poop! No instance for (Read ClockTime)
09:30:48 <Cale> Yeah, Integers can be as large as you have memory
09:30:49 <osfameron> byorgey: oh, ta, that's interesting
09:31:09 <LeCamarade> Oh! It's working ...
09:31:11 <r_rehashed> ok.. how i understood a = 5 was, a is a function that returns 5
09:31:16 <LeCamarade> Wait, please, wait...
09:31:37 <Cale> r_rehashed: a function of no parameters, if you really want
09:31:48 <r_rehashed> that's right
09:31:55 <Cale> r_rehashed: It's just a little strange to call things functions when they have no parameters though.
09:32:05 <r_rehashed> yeah
09:32:05 <byorgey> r_rehashed: right, Int only goes to +/- 2^29 (or so), whereas Integers can be arbitrarily large.
09:32:24 <Cale> Well, that's all that the standard guarantees
09:32:37 <Cale> The implementations tend to use machine integers for Int
09:32:42 <r_rehashed> but calling it a variable sounds strange as i cannot write a = 5 and a = 6 in the same module
09:32:42 <Cale> (so 32 or 64 bits)
09:32:44 <desegnis> I'll ask my gtk2hs question anyway: Is it possible to render cells in a TreeView by means of Haskell code? I don't see how I could get a CellRenderer-compatible thing
09:32:56 <Cale> r_rehashed: well, it's a constant.
09:33:04 <wli> minBound and maxBound are the proper ways to deal with the integer boundaries.
09:33:16 <byorgey> Cale: yeah, I was intentionally oversimplifying.  In practice I've never really needed to know what the actual limits are =)
09:33:17 <wli> Machine integer boundaries, that is.
09:33:17 <Cale> r_rehashed: or a bound variable, if you'd like.
09:33:28 <Cale> > minBound :: Int
09:33:30 <lambdabot>  -2147483648
09:33:33 <Cale> > maxBound :: Int
09:33:34 <lambdabot>  2147483647
09:33:48 <byorgey> > 2^31
09:33:49 <lambdabot>  2147483648
09:34:20 * wli almost never uses Int, preferring Integer in essentially all cases.
09:34:44 <Cale> r_rehashed: The same way that x is a variable in the equation x - 5 = 7
09:34:44 <byorgey> r_rehashed: 'variable' is sort of an unfortunate name (IMO), used for historical reasons.
09:34:51 <dylan> @hoogle CalendarTime
09:34:51 <lambdabot> System.Time.CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
09:34:51 <lambdabot> System.Time.CalendarTime :: data CalendarTime
09:34:51 <lambdabot> Time.calendarTimeToString :: CalendarTime -> String
09:34:56 <Cale> (in mathematics)
09:35:08 * mauke invites LeCamarade to #xmonad
09:35:16 <r_rehashed> ah..
09:35:27 <r_rehashed> so i am making a a constant
09:35:31 <Cale> yep
09:35:34 <r_rehashed> or a bound variable
09:35:43 <kiome> FMOD gives out hobbyist licenses for only 100$.
09:36:02 <kiome> That's great, I don't need to struggle with OpenAL at all.
09:36:09 <Cale> For an example of a variable which varies a bit more, consider x in the definition  f x = x^2
09:36:11 <r_rehashed> so basically this is a maths equation. heck how many times will i have to remind myself about that! :P
09:36:29 <r_rehashed> right
09:36:44 <Cale> Yeah, = is not assignment in Haskell, you're actually declaring that things really are equal.
09:36:51 <Cale> x = x + 1 is an infinite loop :)
09:37:02 <byorgey> r_rehashed: right! Haskell IS math. (For some appropriate definition of IS)
09:37:05 <r_rehashed> oh right
09:37:11 <Cale> > let xs = 1 : xs in xs
09:37:13 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:37:17 <ddarius> And Haskell and math.
09:37:19 <shapr> r_rehashed: hiya!
09:37:26 <byorgey> > let x = x + 1 in x
09:37:28 <lambdabot>  Exception: <<loop>>
09:37:39 <evir> Is there somewhere a summarized log of changes between 6.6.1 and the current 6.7 branch? (not the verbose darcs changelog)
09:37:41 <kiome> Wrong channel, sorry.
09:37:56 <byorgey> kiome: np =)
09:38:06 <Saizan> > let x = 1/2*x +1 in x -- too bad it can't solve this
09:38:06 <desegnis> Hey, how does lambdabot figure out to write <<loop>>?
09:38:07 <lambdabot>  Exception: <<loop>>
09:38:26 <Cale> desegnis: While evaluating x, the code for x gets reentered
09:38:54 <Cale> desegnis: However, what it does when it starts evaluating x is to overwrite the pointer to that code with a pointer to a 'black hole' which throws an exception.
09:38:54 <mauke> desegnis: it doesn't
09:39:23 <Cale> (just before it starts to run the code)
09:39:41 <mauke> > let f x = f x in f ()
09:39:45 <lambdabot> Terminated
09:40:00 <Cale> This method clearly doesn't detect all loops :)
09:40:35 <Cale> However, lambdabot only gives you a few seconds of computation anyway :)
09:40:42 <desegnis> Interpreter mystery :)
09:40:50 <ihope_> "Terminated" is a nice way of telling you it'll loop.
09:41:01 <desegnis> (to me only of course)
09:41:01 <ihope_> > last [1..1000000000000]
09:41:06 <lambdabot> Terminated
09:41:10 <ihope_> That it might loop, that is.
09:41:25 <glguy> ?help run
09:41:25 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
09:41:34 <glguy> its also a nice way of saying "you only get 3 seconds
09:41:38 <mauke> desegnis: basically, a value that directly refers to itself throws a "loop" exception
09:41:38 <Cale> > print "Hello"
09:41:39 <lambdabot>  <IO ()>
09:41:45 <byorgey> now if only we could write a meta-program which can first decide whether it's going to loop of not...  =)
09:41:51 <byorgey> *or
09:42:01 <mauke> should be possible
09:42:09 <mauke> the number of one-line programs is finite
09:42:19 <desegnis> mauke: Does it throw the Exception after 3 seconds, or right away?
09:42:29 <mauke> desegnis: right away
09:42:29 <glguy> because IRC has a line length limit?
09:42:33 <byorgey> mauke: surely that's not even true =)
09:42:37 <mauke> glguy: yes
09:42:41 <ihope_> main = putStrLn "I am not going to loop."
09:42:50 <byorgey> ah, hehe
09:43:03 <ihope_> (Forever, that is.)
09:43:45 <LeCamarade> Is there a Plan 9 port of GHC?
09:43:56 <Cale> LeCamarade: no
09:44:23 <LeCamarade> :-o I was hoping ...
09:44:54 <ddarius> > let f 1 = 1; f x | even x = x `div` 2 | otherwise = 3*x+1 in f 527
09:44:56 <lambdabot>  1582
09:45:13 <ddarius> > let f 1 = 1; f x | even x = f (x `div` 2) | otherwise = f (3*x+1) in f 527
09:45:15 <lambdabot>  1
09:45:52 <ddarius> > let f 1 = 1; f x | even x = f (x `div` 2) | otherwise = f (3*x+1) in map f [1..1000000]
09:45:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:46:11 <mauke> > let f 1 = (); f x | even x = f (x `div` 2) | otherwise = f (3*x+1) in f 992
09:46:12 <lambdabot>  ()
09:46:17 <Cale> heh, gotta love laziness :)
09:46:22 <b_jonas> yeah, and the number of twin primes as well
09:46:24 <gleb> ddarius: playing with project Euler?
09:46:29 <ddarius> gleb: No.
09:46:41 <b_jonas> and other unsolved problems
09:46:51 <b_jonas> try 3*x-1 as well
09:47:30 <gleb> > let f 1 = 1; f x | even x = f (x `div` 2) | otherwise = f (3*x+1) in all (==1) $ map f [1..1000000]
09:47:35 <lambdabot> Terminated
09:48:10 <DRMacIver> Reminder for anyone in London: London HUG is imminent. :)
09:48:23 <mauke> GROUP HUG
09:49:16 <mauke> http://www.whitewashweb.com/omnom5.jpg
09:50:01 <DRMacIver> Indeed...
09:50:41 <ddarius> gleb: They are clearly all equal to 1 -if- they terminate.
09:51:33 * shapr yawns
09:51:33 <gleb> ddarius: sure, you're right
09:51:35 <shapr> mmm code!
09:53:27 <r_rehashed> be back later
10:02:49 <blakkino> hello
10:03:04 <gleb> hello
10:03:10 <sorear> hello!
10:03:23 <mauke> ｈｅｌｌｏ
10:03:24 <blakkino> i have an ugly question.. how to make java code looks like haskell one ? that is.. i want to make it clear where stuff come from.. no side-effects.. :)
10:04:05 <Lemmih> blakkino: Say again?
10:05:00 <glguy> blakkino: Java's typesystem isn't expressive enough to give you that
10:05:39 <blakkino> glguy, probably yes.. but i'm asking about a convention one can follow
10:05:40 <sjanssen> blakkino: the solution is to use Haskell instead of Java
10:06:02 <blakkino> :)
10:06:06 <blakkino> i have no choice
10:06:12 <Cale> blakkino: Never reassign variables, define everything as constant.
10:06:17 <xerox> hello blakkino :-)
10:06:23 <wli> Isn't there or wasn't there a back-end for some Haskell compiler targeting the JVM?
10:06:25 <blakkino> ciao xerox :)
10:06:27 <mauke> since when can you define stuff as const in java?
10:06:45 <xerox> Passa anche da haskell.it :-)
10:06:52 <blakkino> Cale, i don't necessarely need to have the convention enforced by the type system
10:07:04 <blakkino> i just need it to be easy to remember and not very boring
10:07:10 <Cale> mauke: Well, static final.
10:07:18 <mauke> :/
10:07:21 <blakkino> i have tried avoiding assignements and return new objects..
10:07:22 <ddarius> And don't use any 3rd party libraries
10:07:36 <blakkino> but this become quickly very boring
10:07:54 <Cale> blakkino: You could possibly use Scala.
10:07:56 <xerox> Target an Haskell compiler to java bytecode :P
10:08:20 <Cale> blakkino: It's compatible with Java, but designed by someone who knows what they're doing :)
10:08:49 * ddarius remembers the original annoucements for Scala.
10:09:04 <Cale> http://www.scala-lang.org/
10:09:06 <lambdabot> Title: The Scala Programming Language
10:09:29 <blakkino> ehm.. i can't switch programming language for this work
10:10:15 <pejo> Cale, I think you're not giving proper credit to the Java designers here.
10:10:28 <dylan> @hoogle Int -> a -> [a] -> [a]
10:10:29 <lambdabot> No matches, try a more general search
10:10:40 <ddarius> :t splitAt
10:10:42 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:10:54 <dylan> hrm, nope. that that either.
10:11:18 <ddarius> dylan: I know, you can make what I think you want from that (not very efficient though)
10:11:36 <dylan> I need to update an element of a list using an index,
10:11:47 <dylan> I'm re-rewriting devtodo in haskell. :)
10:12:30 <mauke> let (a, _ : z) = splitAt n xs in a ++ (x : z)
10:12:33 <ddarius> :t \n x xs -> case splitAt n xs of (ys,_:ys') -> ys++x:ys'
10:12:35 <lambdabot> forall a. Int -> a -> [a] -> [a]
10:12:57 <dylan> Actuaally, something like...
10:13:37 <dylan> mapi :: (Int -> a -> a) -> [a] -> [a] would work
10:14:06 <ddarius> :t \f -> zipWith [0..]
10:14:08 <lambdabot>     Couldn't match expected type `a -> b -> c'
10:14:08 <lambdabot>            against inferred type `[a1]'
10:14:14 <ddarius> :t \f -> zipWith f [0..]
10:14:16 <lambdabot> forall a b c. (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
10:14:34 <blakkino> pejo, you have any idea about my question?
10:14:49 <dylan> hrm
10:14:50 <blakkino> i'm asking about convention one can explain to others and that are not boring to follow
10:14:58 <pejo> blakkino, not beyond what Cale says, sorry.
10:15:00 <dylan> I wonder if I should use an array.
10:15:11 <conal> @type \ n xs -> let (a, b : z) = splitAt n xs in a ++ (f b : z)
10:15:12 <lambdabot> Not in scope: `f'
10:15:16 <wli> dylan: Also consider Data.Map
10:15:20 <ddarius> blakkino: It should not be something that is boring or not.  It's merely different.
10:15:22 <dylan> wli: order is important.
10:15:36 <conal> @type \ f n xs -> let (a, b : z) = splitAt n xs in a ++ (f b : z)
10:15:37 <lambdabot> forall a. (a -> a) -> Int -> [a] -> [a]
10:15:39 <glguy> dylan: then use a Sequence
10:15:57 <glguy> dylan: and Data.Map can maintain order if you order the keys
10:15:57 <wli> Deformative: Probably either Solaris or AIX.
10:16:00 <dylan> also, since devtodo's lifecycle is: start, read file, perform pure function on list (or array), write file... a map seems like a lot more work
10:16:26 <ddarius> dylan: ?
10:16:59 <conal> dylan: from your mapi type, you want to replace all elements?
10:17:11 <dylan> conal: only one that matches a particular index.
10:17:15 <dylan> it's to implement:
10:17:24 <ddarius> f 3 _ = 10; f _ x = x
10:17:26 <wli> dylan: You might consider a priority queue from Edison or Data.Sequence, though Map will be ordered in like fashion.
10:17:31 <dylan> possibly more, actually.
10:17:50 <conal> dylan: then don't you want mapi :: Int -> (a -> a) -> [a] -> [a]   ?
10:18:25 <dylan> mapi (\i x -> if i `elem` doneIds then x { done = True } else x) ....
10:19:13 <dylan> I very frequently type 'yodo --done 1 5 20 7 ...'
10:19:24 <conal> dylan: sure.  replace some of them.  or replace all but some with what was there already.
10:20:12 <conal> @type \ f xs -> zipWith f [0..] xs
10:20:15 <lambdabot> forall a b c. (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
10:20:30 <conal> dylan: how about that one?
10:20:50 <dylan> yeah, that's what I have. I'm pondering using an array, though.
10:20:54 <conal> @pl \ f xs -> zipWith f [0..] xs
10:20:54 <lambdabot> flip zipWith [0..]
10:20:57 <conal> :)
10:21:07 <conal> dylan: how's that?
10:21:24 <dylan> well, very many operations involve indexing.
10:22:23 <conal> dylan: what's warpedgames.com?
10:22:40 <dylan> conal: donno. someone's server.
10:23:29 <conal> dylan: oh.  i thought it was your co
10:25:02 <conal> dylan: array -- are you doing random access?
10:26:31 <dylan> very frequently. Most frequent operation is listing, but done and remove require random access
10:26:51 <dylan> (done marks a todo item as completed, remove deletes it from the list)
10:29:05 <conal> dylan: is there anything inherently linear about your keys/indices?  i.e. do they have to be contiguous ints?  ordered?
10:29:27 <dylan> they have an order, which is the order they were added
10:29:41 <SamB> hmm, you could do it like ticket numbers...
10:29:50 <dylan> there are various options for sorting, of course
10:30:05 <sjanssen> @users
10:30:05 <lambdabot> Maximum users seen in #haskell: 419, currently: 394 (94.0%), active: 20 (5.1%)
10:30:21 <wli> dylan: For a FIFO use Data.Sequence
10:31:00 <dylan> actually, my current haskell implementation is always sorted by priority
10:31:21 <dylan> add t l = sort (t : l)
10:31:30 <wli> dylan: For a priority queue edison has data structures for you (in fact numerous of them).
10:31:48 <dylan> wli: is that in base? if not, probably won't use it
10:32:14 <wli> dylan: It is not in base.
10:32:25 <wli> dylan: It's in Edison.
10:32:26 <dylan> this wee script has to run on boxes where I'm lucky that haskell is even installed.
10:34:18 <wli> dylan: Data.Map is sorted by key; using priority as a key there and another structure on the side such as Data.Sequence ought to emulate a priority queue.
10:35:44 <dylan> it's not a strict queue, of course
10:36:22 <Eelis> xerox: i ran into a very similar spurious error parsec problem using getInput: http://hpaste.org/2389
10:37:21 <dylan> hrm, it's looking like going back to writing a calculator in sed is more fun than trying to write my devtodo clone in haskell.
10:39:10 <oerjan> Eelis: i don't think getInput actually consumes anything, it is more a complete lookahead i think
10:39:57 <xerox> getInput doesn't consume anything.
10:40:09 <Eelis> oerjan: oh, i see. ok, false alarm then :)
10:40:09 <Mat^> ok, how long might take to write C subset compiler -> assembly? ;S
10:40:11 <Mat^> in haskell? ;P
10:40:30 <mauke> ; is a subset of C
10:41:16 <Mat^> well, turing-complete ;>
10:41:26 <Mat^> 80% of C
10:41:31 <oerjan> Eelis: if you want to see if a parser has actually consumed everything, add an eof
10:41:47 <Eelis> oerjan: just did exactly that to confirm what you said, and you're right
10:44:19 <desp> Mat^: why would you want to do that?
10:45:40 <Mat^> desp: ask my 'programmig' teacher ;>
10:46:10 <Mat^> it's my coursework
10:46:17 <lament> sounds like a pretty cool assignment
10:46:41 <lament> Mat^: if you don't optimize stuff, it should be fairly straightforward
10:46:51 <Mat^> lament: of course I don't ;>
10:46:59 <Mat^> I know how to write compiler
10:47:04 <Mat^> the problem is, I don't know haskell
10:47:10 <Mat^> and it looks really weird ;>
10:47:23 <lament> yeah, many people get that first impression :)
10:47:23 <SamB> Mat^: you could factor that Language.C library we've been wanting out of c2hs
10:47:26 <LeCamarade> Mat^: I am also going to be working on a modified-C -> x86 soon. :o)
10:47:34 <desp> Mat^: ah, that's nice.
10:47:57 <desp> @where wikibook
10:47:58 <lambdabot> http://en.wikibooks.org/wiki/Haskell
10:48:05 <desp> @where 10min
10:48:05 <lambdabot> I know nothing about 10min.
10:48:09 <lament> haskell might be weird, but it has Parsec :)
10:48:09 <desp> @where 10minute
10:48:09 <lambdabot> I know nothing about 10minute.
10:48:12 <SamB> Mat^: what kind of AST are you looking at?
10:48:16 <Mat^> SamB: well, we are allowed to use Parsec ;>
10:48:29 <Mat^> SamB: AST?
10:48:29 <desp> @where+ 10min http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
10:48:30 <lambdabot> Done.
10:48:39 <Japsu> @where howto
10:48:39 <lambdabot> I know nothing about howto.
10:48:41 <desp> Mat^: I recommend those two links :)
10:48:46 <Mat^> desp: thanks
10:48:50 <Japsu> @where+ howto http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
10:48:51 <lambdabot> Done.
10:48:55 <Japsu> ^^
10:48:59 <Mat^> I have already read something about haskell
10:49:06 <desp> Mat^: czesc, btw ;)
10:49:11 <wli> If you're not optimizing, then you might as well just translate to an RTL and then dump the RTL in macro-assembler fashion.
10:49:12 <Mat^> desp: ;>
10:49:24 <SamB> I think maybe "learn Haskell in 10 minutes" should be "learn Haskell in under an hour"
10:49:51 <lament> learn haskell in one painful injection
10:49:55 <Mat^> wli: RTL?
10:50:07 <desp> Mat^: what university? :)
10:50:12 <Mat^> desp: of Wroclaw
10:50:13 <Mat^> ;>
10:50:13 <SamB> Mat^: AST means Abstract Syntax Tree
10:50:17 <desp> Mat^: :D
10:50:19 <SamB> you know, the output of the parser
10:50:31 <Mat^> SamB: yes
10:50:44 <SamB> so what sort of tree do you have?
10:50:56 <Mat^> *confused*
10:50:57 <Mat^> ;>
10:51:06 <SamB> okay, want
10:51:12 <mauke> Réseau de Transport de Longueuil
10:51:21 <SamB> i.e. what is the abstract syntax of your C subset
10:51:23 <wli> RTL = Register Transfer Language (basically an assembly-like IR).
10:52:06 <Mat^> SamB: you mean does it has one propper tree, or more etc?
10:52:21 <SamB> I was more wondering what types of nodes you could have
10:52:49 <Mat^> sorry dude, I completely don't understand :S
10:53:05 <SamB> well, okay, what constructs doesn't your subset have?
10:53:22 <Mat^> it lacks pointers
10:53:26 <SamB> !
10:53:35 <mauke> that means no arrays either
10:53:35 <Mat^> (well, it has arrays)
10:53:36 <SamB> that's not much of a language then
10:53:45 <mauke> uh, arrays without pointers are useless
10:53:49 <SamB> should have chucked arrays and unions instead
10:54:07 <Mat^> there is one integer type, one floating point, one bool
10:54:15 <mauke> there is no bool in C
10:54:15 <lament> i give you an hour to implement the compiler :)
10:54:20 <Mat^> basic like for
10:54:20 <Mat^> ;P
10:54:37 <mauke> do you have to write a preprocessor?
10:54:40 <Mat^> mauke: ok, so it's subset + something
10:54:41 <Mat^> mauke: no
10:54:46 <mauke> good :-)
10:54:54 <SamB> mauke: if he did, it would be easy
10:54:56 <lament> man, c without pointers would be... a very interesting language
10:54:58 <mauke> getting the preprocessor right is at least 50%
10:55:07 <SamB> because clearly they wouldn't do anything like the real CPP
10:55:21 <SamB> that's far too complicated for an undergraduate course ;-P
10:55:22 <Mat^> lament: it doesn't have pointers, but there are arrays, which works pretty like pointers
10:55:29 <Mat^> (you might use one-size array)
10:55:42 <mauke> does that mean you have array values?
10:55:49 <lament> Mat^: does it have the & operator?
10:55:53 <SamB> has it memcpy?
10:55:59 <lament> i suppose it can't...
10:56:05 <lament> hm
10:56:09 <Mat^> lament: no
10:56:11 <lament> if it doesn't have pointers, how does it work with strings?
10:56:15 <SamB> what happens if I do a+x
10:56:18 <mauke> arrays
10:56:30 <SamB> where a names an array
10:56:33 <mauke> SamB: type error, you can't add arrays and numbers
10:56:40 <mauke> (just guessing)
10:56:40 <lament> What does fgets return?
10:56:48 <mauke> an int, IIRC
10:56:57 <mauke> oh, no
10:57:08 <Mat^> like I said, it doesn't have pointers literally, but it has arrays
10:57:08 <lament> char *fgets(char *s, int size, FILE *stream);  // how do you implement this without pointers?
10:57:18 <SamB> can you write "Hello, World!" in it
10:57:21 <SamB> ?
10:57:24 <lament> SamB: i was wondering :)
10:57:36 <SamB> next question:
10:57:38 <glen_quagmire> how can I write a lambda that doesn't take a parameter?
10:57:44 <mauke> lament: char fgets(FILE stream)[999]
10:57:48 <glen_quagmire> :t bracket
10:57:49 <SamB> can you write GNU Hello in it?
10:57:51 <lambdabot> Not in scope: `bracket'
10:57:59 <SamB> glen_quagmire: there's no need
10:58:02 <lament> glen_quagmire: that's simply an expression
10:58:06 <mauke> glen_quagmire: huh? a lambda with no parameter is a value
10:58:13 <lament> glen_quagmire: don't forget Haskell is lazy...
10:58:15 <oerjan> glen_quagmire: in haskell that is equivalent to the content of the lambda
10:58:27 <SamB> glen_quagmire: those are our infamous invisible lambdas
10:58:30 <oerjan> > \ -> 3 -- testing
10:58:31 <lambdabot>  Parse error
10:58:35 <glen_quagmire> bracket (openFile filename ReadMode) ....      when is (openFile filename ReadMode) evaluated?
10:58:47 <lament> :t openFile
10:58:49 <lambdabot> Not in scope: `openFile'
10:58:54 <glen_quagmire> it is evaulated inside bracket? or before passed to bracket?
10:59:01 <mauke> glen_quagmire: doesn't matter
10:59:03 <pejo> mauke, C99 has bool afaik.
10:59:06 <mauke> remember, no side effects
10:59:10 <mauke> pejo: well, _Bool :-)
10:59:13 <SamB> glen_quagmire: sometime after the compiler knows it's safe to evaluate
10:59:27 <glen_quagmire> oh it's lazy
10:59:32 <SamB> and no later than necessary
10:59:36 <oerjan> :t bracket
10:59:38 <lambdabot> Not in scope: `bracket'
10:59:43 <glen_quagmire> :t IO.bracket
10:59:44 <mauke> @index bracket
10:59:44 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
10:59:45 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:59:58 <SamB> that is, not too late
11:00:30 <SamB> glen_quagmire: anyway -- it's not when it's evaluated that matters
11:00:44 <lament> so i'm thinking, wouldn't it be much easier to implement C with pointers than without pointers?
11:00:49 <SamB> it's where it is sequenced that matters
11:01:14 <SamB> lament: dunno
11:01:14 <oerjan> glen_quagmire: they are trying to confuse you with the distinction between evaluating and performing an IO action
11:01:15 <Mat^> lament: I guess, that it would be very the same
11:01:29 <SamB> Mat^: you could leave out those arrays if you had pointers
11:01:32 <Mat^> lament: if there are arrays, you have to use pointers anyway
11:01:32 <lament> Mat^: I still don't understand how functions dealing wiht strings are supposed to work
11:01:35 <SamB> in fact, I dare you to do it anyway
11:01:52 <glen_quagmire> evaulation returns a value and performing an action has side effect?
11:01:53 <Mat^> lament: I didn't create this language
11:01:54 <lament> Mat^: in those, you typically pass a pointer to the string. You can't pass an array because you don't know how long the string is.
11:02:14 <Mat^> lament: in C pointers are pretty much like arrays
11:02:20 <lament> Mat^: I know C.
11:02:30 <glen_quagmire> do someActionThatTakesTwoHours  -- this will return immediately with proper type right?
11:02:34 <mauke> Mat^: not really
11:02:42 <desp> you guys have to understand that this language is custom-made by a teaching assistant in order to torment first-year students through writing a compiler
11:02:46 <desp> :)
11:02:52 <Mat^> ;P
11:02:55 <SamB> desp: oh, a TA you say?
11:03:08 <SamB> we should plot a revenge or something
11:03:10 <lament> Mat^: so if you can't pass a poiter to a string, does that mean you have to pass an array of length [999] or something, and all your strings have to be limited by that length?
11:03:18 <mauke> Mat^: huhu, you should write a C/C++ compiler
11:03:26 <SamB> mauke: yeah right
11:03:29 <lament> mauke: badum-ts
11:03:33 <Botje> lament: you could store an index into a global array of string slots.
11:03:34 <SamB> mauke: all the users are idiots
11:03:36 <b_jonas> what does it compile to?
11:03:45 <SamB> nobody knows what C/C++ *is*
11:03:48 <mauke> SamB: I do
11:03:52 <mauke> let me find the url
11:03:55 <lament> "Warning: This code is not valid C/C++"
11:04:00 <glen_quagmire> C/C++ = 1 always
11:04:03 <lament> great compiler error messages :)
11:04:07 <lament> glen_quagmire: wrong
11:04:08 <Mat^> lament: I don't get it, you don't have to know array size to use it right?
11:04:14 <lament> Mat^: you do
11:04:14 <ibid> C/C++ is a handy way of spotting the people who don't know if they're talking about C or C++ :)
11:04:14 <glen_quagmire> int C = 1000;   C/C++; //1
11:04:19 <Botje> glen_quagmire: unless C == 0 :]
11:04:20 <SamB> glen_quagmire: what if C starts out as 0?
11:04:24 <mauke> glen_quagmire: wrong
11:04:32 <lament> glen_quagmire: wrong, c/c++ is undefined
11:04:56 <Botje> lament: is it? the ++ only happens after the sequence point, ie after the /
11:04:57 <SamB> lament: undefined, or possibly 0, possibly 1?
11:05:02 <mauke> Botje: wrong
11:05:13 <Botje> oh?
11:05:17 <glen_quagmire> hrm / isn't a sequence point
11:05:18 <mauke> SamB: completely undefined
11:05:19 <lament> SamB: "undefined or possibly 0"? :)
11:05:22 * Botje goes to study the c.l.c faq some more
11:05:27 <ibid> Botje: / is not a sequence point
11:05:36 <Botje> so the ++ should happen after the /, right?
11:05:38 <magnus_> I'm with Botje but I only have practical experience
11:05:42 <SamB> so how does / not being a sequence point make it undefined
11:05:49 <mauke> Botje: no
11:06:01 <lament> SamB: because C is brain-damaged
11:06:02 <mauke> Botje: ++ can happen at any time between its surrounding sequence points
11:06:02 <glen_quagmire> SamB: compiler can do anything
11:06:34 <SamB> mauke: so why does that make it undefined instead of just a bit wierd?
11:06:43 <b_jonas> it's actually worse than that, but it's undefined
11:06:47 <magnus_> I beleive C/++C; is 0 and C/C++; is 1
11:06:51 <lament> SamB: because the actual time when ++ does its job is undefined.
11:06:53 <glen_quagmire> undefined means standard doesnt' define the behavior.
11:06:54 <ibid> mauke: it is only undefined if there are more than one modification between the sequence points
11:06:56 <mauke> magnus_: you're wrong
11:06:58 <mauke> ibid: wrong
11:07:02 <mauke> ARGH
11:07:03 <SamB> oh. is it because it might take multiple instructions to do ++ or / or both?
11:07:08 <ibid> mauke: what's wrong?
11:07:22 <mauke> SamB: it's because the standard says you can't both read and write an object without an intervening sequence point
11:07:29 <SamB> mauke: ah
11:07:38 <mauke> think locks
11:07:41 * ibid goes check the standard
11:07:45 <glen_quagmire> int C = 1;    C/C++ can be 1/2  2/2 1/1 2/1
11:07:47 <johnnowak> mauke is right
11:07:56 <mauke> glen_quagmire: it can be anything, including "butter"
11:08:18 <SamB> mauke: except if you do it with one of those @= thingies or ++ or --?
11:08:19 <glen_quagmire> mauke: even when C = 1; ?
11:08:19 <Mat^> lament: ok, I guess I get it - in this custom language arrays works pretty much the same in C - they are not passed by value
11:08:26 <mauke> glen_quagmire: yes
11:08:39 <ibid> here
11:08:44 <ibid> 's what C99 says:
11:08:45 <ibid> Between the previous and next sequence point an object shall have its stored value
11:08:49 <ibid> modified at most once by the evaluation of an expression. Furthermore, the prior value
11:08:51 <TuringTest> I have a question about the upcoming GHC 6.8 release -- where would I submit a request that they upgrade to the latest regex-base package?
11:08:52 <ibid> shall be read only to determine the value to be stored.
11:08:57 <ibid> and so, yes, C/C++ is undefined
11:08:59 <mauke> SamB: there's an exception: you can read an object if you use it to compute a new value
11:09:09 <SamB> mauke: ah.
11:09:13 <Mat^> lament: so *in fact* there are pointers, I just can't do int *ptr = &some_int; or smth, but I can int arr[1]; scanf("%i", arr);
11:09:28 <ibid> mauke, SamB: see the rule i just quoted :)
11:09:48 <SamB> ibid: yes I saw
11:10:07 <lament> Mat^: ah.
11:10:09 <ibid> ok
11:10:54 <Mat^> I really don't know reason why this language doesn't have pointers but has arrays
11:10:54 <glen_quagmire> another lesson why destructive update is hard
11:11:21 <mauke> I think C# completely specifies evaluation order to avoid this problem
11:11:22 <johnnowak> glen_quagmire: is it?
11:11:31 <lament> yeah... imagine the semantics of ++ in Haskell. Where're the sequence points? :)
11:11:48 <lament> mauke: sounds like a good idea in general...
11:11:52 <mauke> C++ makes it more fun, with operator overloading
11:11:58 <ibid> lament: >>= :)
11:11:58 <glen_quagmire> c++ can mean anything if c is shared among many threads
11:12:29 <mauke> overloaded &&/||/, aren't sequence points anymore
11:12:30 <lament> that's just a problem with threads, not with ++
11:12:48 <johnnowak> c++ can mean anything if c isn't initialized as well
11:12:50 <mauke> on the other hand, there's a (dynamic) sequence point just before a function call, and this also applies to overloaded operators
11:12:50 <SamB> glen_quagmire: that's why you don't share variables among threads without locks on them
11:13:08 <johnnowak> you just make sure to initialize it.
11:13:20 <glen_quagmire> i think you can safely share variables among threads if destructive update is impossible
11:13:20 <SamB> of course for some reason Haskell is the only langauge I've seen that actually associates the lock with the variable...
11:13:29 <SamB> glen_quagmire: those aren't variables ;-P
11:13:47 <lament> "Variables don't"
11:14:02 <Botje> "variables shouldn't; constants aren't"
11:14:14 <SamB> it might also be safe if you only change the variable from a particular thread and the variable is only one byte
11:14:45 <lament> or if you're programming in erlang
11:15:05 <SamB> lament: well erlang does it totally differently doesn't it/
11:15:14 <glen_quagmire> what's the difference between object oriented and concurrency oriented?  in OO, everything is an Object and you can only send message to it. in CO, everything is an Actor and you can only send message to it
11:15:16 <lament> i think it enforces locks or something
11:15:18 <desp> lament: change a variable in erlang?
11:15:21 <SamB> you aren't looking at bytes and pointers
11:15:40 <desp> lament: I'm afraid you can't do that, Hal
11:16:41 <lament> desp: i remember hearing about "something" being always an atomic operation, just can't remember what the something was
11:17:01 <desp> lament: Erlang also has one-assignment-only variables
11:18:18 <SamB> desp: ah
11:18:20 <SamB> handy
11:18:25 <johnnowak> glen_quagmire: wrt messaging, message passing in OO languages is typically synchronous for one
11:19:58 <SamB> johnnowak: "message passing"?
11:20:18 <johnnowak> yes, in the smalltalk sense of the word
11:20:29 <johnnowak> er, term.
11:20:43 <SamB> doesn't that happen within a thread?
11:20:48 <SamB> (if you even have threads)
11:20:49 <johnnowak> yes
11:21:01 <SamB> does it change something?
11:21:33 <johnnowak> there may be a change as a result, yes
11:21:56 <SamB> oh I got what you mean now...
11:22:13 <SamB> you mean you wait for the return value...
11:22:33 <johnnowak> right
11:23:33 * SamB thinks you need something approaching purity to do it any other way...
11:24:11 <SamB> well, or you could write explicitly asynchronous code like in Twisted...
11:24:47 <lament> hm
11:24:51 <johnnowak> you can have mutation and asynchronous messaging
11:24:59 <tuomov> Ummm.. is it really not possible to use type variables in the signature for a function, within that function?
11:25:03 <johnnowak> although it would be uselss within a single thread
11:25:06 <lament> SamB: have you looked at io?
11:25:15 <tuomov> that's what GHC's error messages seem to indicate, that any type variables there with the same name, are new variables
11:25:16 <lament> any message in io can be made asynchronous
11:25:18 <johnnowak> except unless explicitly introduces, as in Io
11:25:24 <johnnowak> lament: aye
11:25:31 <sorear> SamB: On most processors a one-word value is atomic, further this is guaranteed by ANSI C - look up sig_atomic_t
11:25:43 <sorear> tuomov: it's a design bug in the H98 spec
11:25:44 <SamB> sorear: ah. nice.
11:25:49 <SamB> how big is that I wonder
11:25:50 <tuomov> just fscking great
11:25:56 <lament> johnnowak: io seems like a cute lang
11:25:59 <tuomov> any option to fix it?
11:26:02 <sorear> tuomov: GHC has a fix, but because it breaks old code it has to be enabled
11:26:15 <tuomov> what would it be called?
11:26:26 <johnnowak> lament: it's one of my favorites... very fun to play with
11:26:28 <SamB> scoped type variables
11:26:40 <lament> johnnowak: yeah, too bad it's little more than a toy at the moment
11:26:45 <johnnowak> lament: few modern languages give you so many interesting ways to blow your arms off
11:26:55 <tuomov> Enable  lexically-scoped  type  variables.  Implied  by  -fglasgow-exts
11:26:55 <sorear> tuomov: enable the 'scoped type variables' flag (included in -fglasgow-exts, or ScopedTypeVariables in a language pragma) and use the 'forall' noise word like foo :: forall a. a -> a
11:26:56 <johnnowak> lament: the implementation could use some work, yes
11:26:59 <tuomov> ^^ doesn't seem to be
11:27:00 <SamB> johnnowak: yes, C++'
11:27:08 <lament> johnnowak: well, anything you can do in io you can probably do in python or ruby as well
11:27:13 <SamB> s ways to blow your extremeties off are so boring
11:27:21 <johnnowak> SamB: modern and contemporary aren't the same
11:27:27 <SamB> whatever
11:27:30 <SamB> they're still boring!
11:27:47 <sorear> tuomov: type signatures only bind variables if you use 'forall', just to break compatibility
11:27:55 <johnnowak> lament: Io is a pass-by-expression language which lets you do a lot you can't do in ruby or python
11:27:56 <SamB> most of them
11:28:04 <johnnowak> if those things are worth doing is another question
11:28:18 <SamB> and since you're always blowing things off the boring way, you rarely get to have much fun
11:28:39 <johnnowak> SamB: aye, most. it's not hard to design a language where you can lose limbs. Io is rare in that you can lose them so spectacularly.
11:28:40 <lament> johnnowak: pass-by-expression just means it has very convenient syntax for passing blocks
11:28:53 <lament> johnnowak: which you can still do in python/ruby
11:28:58 <johnnowak> lament: no, that's not true
11:29:15 <johnnowak> you can manipulate the expression however you like an evaluate it in arbitrary contexts
11:29:29 <lament> johnnowak: sure, you can do that in python
11:29:32 <TuringTest> tuomov: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables has the details
11:29:35 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
11:29:36 * shapr yarghs at this code!
11:29:38 <johnnowak> lament: how's that?
11:29:45 <shapr> Hiya ChrisK
11:30:02 <shapr> Haven't seen you around much lately, how's code?
11:30:04 <TuringTest> shapr: Hi.  What code?
11:30:06 <johnnowak> lament: how do you implement QUOTE in python?
11:30:10 <tuomov> doesn't seem to work with type classes..
11:30:13 <lament> johnnowak: well, for one, there's eval()
11:30:31 <TuringTest> shapr: Mostly real work and not code... I did help make the Boyer Moore module for searching Bytestrings.
11:30:36 <lament> johnnowak: which gets passed an environment as an argument
11:30:41 <shapr> Oh, the new HAppS has this crazy cool stuff that automatically derives XML and forms for a datatype, but I'm having problems with it.
11:30:51 <shapr> What do you do for work?
11:31:04 <johnnowak> lament: a lot of things have eval. that doesn't mean you have access to unevaluated arguments. this is the reason python needs special forms and Io does not.
11:31:14 <TuringTest> shapr: I am a postdoc working in experimental quantum optical physics.
11:31:17 <shapr> The XML deriving part works beautifully, but I can't figure out how to get the autoderived forms actually produced.
11:31:34 <shapr> TuringTest: Cool, so you get to work with negative index of refraction and all that?
11:31:40 <lament> johnnowak: as far as i can tell, that's just special syntax for passing blocks
11:31:51 <lament> johnnowak: which you do in smalltalk and ruby all the time
11:31:58 <johnnowak> lament: It's not. You're passing the ast, not a block.
11:31:59 <shapr> Oh HEY! Maybe you can help me with a very odd question about photorefractive materials!
11:32:15 <tuomov> Ah, if you forall one variable, you have to forall them all... sigh these sigs are getting long
11:32:26 <lament> johnnowak: what's the difference? The environment?
11:33:02 <johnnowak> lament: One is an opaque block, the other is a manipulatable abstract syntax tree.
11:33:17 <oerjan> :t map
11:33:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:33:24 <lament> johnnowak: are they actually opaque in ruby? i doubt that
11:33:38 <jsnx> i'd like to write a program in haskell that digs around in a bunch of directories, compares the names of all the files and does checksums on the files to compare them to one another.
11:33:48 <oerjan> tuomov: as you see, you don't need to repeat the forall keyword
11:33:50 <lament> johnnowak: both python and ruby have pretty powerful introspection
11:33:51 <jsnx> what set of libraries should i use?
11:34:19 <xerox> jsnx: the standard libraries (System.Directory for one) and crypt for hashing.
11:34:30 <jsnx> xerox: thank you
11:34:31 <tuomov> oerjan: yeah, figured that out, but still.. these sigs are getting complicated
11:34:41 <johnnowak> lament: one moment, i'll give you an example
11:34:51 <jsnx> lament: blocks are opaque in ruby
11:35:10 <SamB> jsnx: in name or in truth?
11:35:25 <jsnx> SamB: in truth
11:35:26 <oerjan> @quote interesting.*fun
11:35:26 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
11:35:39 <SamB> in Python, lambdas are supposedly opaque but you can always poke at their bytecode if you want to do something stupid
11:35:39 <oerjan> @quote interesting
11:35:39 <lambdabot> ghc says: Interesting!  A join var that isn't let-no-escaped
11:35:48 <oerjan> @quote interesting
11:35:48 <lambdabot> ghc says: Interesting!  A join var that isn't let-no-escaped
11:35:49 <SamB> well, CPython anyway
11:35:58 <jsnx> SamB: opaque means 'hard to see through'
11:36:04 <johnnowak> lament:
11:36:04 <johnnowak> Io> foo := method(call message arguments reverse); foo(1, 2, 3)
11:36:04 <johnnowak> ==> list(3, 2, 1)
11:36:10 <jsnx> SamB: that is opaque!
11:36:25 <oerjan> tuomov: someone said that the more interesting your types are, the less fun it is to write them down
11:36:26 <johnnowak> foo is a method that manipulates its arguments as a list without any evaluation
11:36:32 <SamB> I call it opaque if you can't tell that there's even something to see, personally...
11:36:37 <johnnowak> Io> foo(a, b, c)
11:36:38 <johnnowak> ==> list(c, b, a
11:36:49 <johnnowak> you can't do that in python or ruby
11:37:03 <Eelis> if i have a   Monad m => m Int   , i know i can instantiate it to get a   Maybe Int  . but what if i want to get the "fail"-message in case of failure? can i get something like a   Either String Int  ?
11:37:08 <jsnx> SamB: just because there's some way to do it, that doesn't mean it's a good way
11:37:28 <johnnowak> lament: Io essentially has first-class macros
11:37:39 <jsnx> anyway, i hope you understand what i was getting at -- ruby's builtin introspection does not extend to blocks
11:37:58 <SamB> what kind of introspection does it do on most things?
11:38:01 <jsnx> Io> 1 + 2
11:38:13 <johnnowak> jsnx: I was pasting. :)
11:38:13 <jsnx> doesn't do anything...
11:38:18 <jsnx> lolz!
11:38:20 <oerjan> Eelis: i think that should work, yes
11:38:30 <Eelis> oerjan: i get  "No instance for (Monad (Either String))"
11:38:31 <johnnowak> jsnx: there is a bot in #io however.
11:38:35 <SamB> anyway I suspect that lament shares my understanding of the term "opaque"
11:38:36 <oerjan> @src Either fail
11:38:36 <lambdabot> fail msg      = Left (strMsg msg)
11:38:49 <oerjan> Eelis: import Control.Monad.Error
11:38:56 * johnnowak wonders if lament has run off
11:39:04 <lament> i'm here
11:39:06 <Eelis> oerjan: brilliant, works like a charm :) thanks
11:39:08 <SamB> since he said the same thing about Python ;-)
11:39:08 <jsnx> SamB: in Ruby, if you want to know what is in a something foo, you say foo.instance_variables and similar things
11:39:27 <tuomov> oerjan: the big problem I have is writing all the class stuff down for every function, although the compiler should be able to figure it out
11:39:31 <SamB> jsnx: big deal, so you can tell if something is an instance variable or not
11:39:33 <jsnx> SamB: the implementors provide methods for you...
11:39:42 <jsnx> SamB: no, that's not what i mean
11:39:50 <johnnowak> SamB: it's just typical smalltalk-style object reflection
11:40:08 <jsnx> foo.instance_variables gives you a list of all the instance variables, and there are similar tools for methods
11:40:25 <tuomov> data Foo a => Bar a = ...    ok, you know that, so do not ask me write Foo a => down in every function, please, compiler?
11:40:40 <SamB> jsnx: methods don't generally have many instance variables
11:40:57 <lament> johnnowak: you can pretty much do this in python by passing everything as a lambda (ie block)
11:41:14 <johnnowak> lament: no you can't. if you could, you could write QUOTE in python.
11:41:19 <lament> johnnowak: it just will be very, very ugly because python introspection isn't anywhere as nice
11:41:21 <johnnowak> and you wouldn't need any special forms
11:41:43 <lament> >>> a = lambda: foo(bar(baz))
11:41:43 <lament> >>> a.func_code.co_names
11:41:43 <lament> ('foo', 'bar', 'baz')
11:41:44 <johnnowak> it's not about introspection being nice, it's a fundamentally different evaluation mechanism
11:41:46 <jsnx> SamB: methods are objects in Ruby, so they also have instance variables
11:42:01 <jsnx> to get the methods for a foo, you type foo.methods
11:42:16 <SamB> in Python it's not so easy to tell the methods from the instance variables or class variables...
11:42:19 <lament> (func_code has a whole bunch of other arguments)
11:42:19 <johnnowak> lament: that's getting the code for a method, not letting a method access its passed expression
11:42:37 <jsnx> SamB: well, in Ruby it is, since they are different classes
11:42:52 <SamB> jsnx: classes?
11:43:17 <jsnx> a method is of class Method, an instance_variable is anything else
11:43:22 <SamB> ah.
11:43:30 <johnnowak> class-based OO is so 1980s...
11:43:40 <lament> ok i'll stop arguing then
11:43:53 <jsnx> johnnowak: oo is so 1980s...
11:44:08 <johnnowak> lament: #io is friendly if you're interested
11:44:10 <lament> and i can easily write quote in python: "foo" quotes foo ;)
11:44:12 <SamB> Python has at least three different "classes" a method might be in
11:44:28 <jsnx> SamB: well, we all know Python teh suck
11:44:42 <jsnx> i've never worked with it
11:44:57 <lament> yay, let's have a python vs ruby flamewar in #haskell
11:45:05 <SamB> yeah, it does let too much show through ;-)
11:45:13 <ihope_> lament: is Perl going to win?
11:45:15 <shapr> bleah
11:45:16 <jsnx> honestly, i'm sick of ruby...
11:45:18 <shapr> I'd rather CODE!
11:45:20 <SamB> 'tis almost as bad as x86!
11:45:29 <shapr> C'mon, somebody explain mdo :-)
11:45:43 <oerjan> tuomov: yeah contexts on data don't work as one might expect.  (iirc from a discussion here, they only show up on the constructor functions' types.)  perhaps the best you can achieve is to turn off the monomorphism restriction so you can avoid explicit types on some functions
11:45:46 <SamB> shapr: it lets you use variables before you bind them
11:45:46 <shapr> Or tell me how functional dependencies work?
11:45:49 <jsnx> as soon as wrap my head around file operations and regexen in haskell, i'll never use ruby again
11:45:49 <wli> Python, Ruby, and Perl suck. I use Haskell where others use such things.
11:46:00 <SamB> shapr: as a consequence, you need a time machine
11:46:03 <jsnx> wli: indeed, that is my goal
11:46:06 <sjanssen> shapr: I'm not sure that anyone *really* knows how fundeps work
11:46:07 <shapr> SamB: Good thing I have one!
11:46:10 <SamB> shapr: the time machine is called mfix
11:46:17 <b_jonas> wli: most people agree that at least one of those suck
11:46:22 <shapr> sjanssen: What's the new replacement that SPJ is advocating for fundeps?
11:46:29 <SamB> a NEW one?
11:46:34 <jsnx> wli: how do i do webcrawling in haskell? is there a mechanize out there?
11:46:35 <sjanssen> shapr: associated types
11:46:40 <shapr> Yeah, it's much easier to understand, and much easier to debug.
11:46:41 <lament> b_jonas: i think most people agree that at least two of those suck :)
11:46:51 <wli> jsnx: Ask shapr.
11:46:51 <shapr> ATs will do fundep stuff??
11:46:58 <SamB> oh, that's not a new one
11:47:04 <SamB> that's the old one
11:47:17 <SamB> well, I mean, I don't remember any that were supposed to come before
11:47:25 <sjanssen> shapr: yes, there's a way to translate fundpes into a set of classes with associated types
11:47:25 <shapr> jsnx: Webcrawling is best handled with HTTP-3000 imho, you should check out the Browser module if you need full webpage scraping.
11:47:32 <shapr> sjanssen: Wow, I didn't know that.
11:47:36 <SamB> shapr: they are functional instead of being relational
11:47:51 <shapr> jsnx: Can you give me more detail on what you want to do?
11:48:06 <sjanssen> shapr: yes, it surprised me too.  I didn't believe it until I got ChilliX to show me an example :)
11:48:18 <shapr> sjanssen: Where's the example?!
11:48:23 <jsnx> shapr: go to my blog, login, upload a new CSS file, submit it, exit
11:48:26 <shapr> This I gotta see!
11:48:36 <oerjan> shapr: someone mentioned ghc internally already does something like that to implement fundeps
11:48:53 <shapr> jsnx: Oh, that's not what I'd call webcrawling. In that case, modify the blog demo code in HAppS-Begin when it's released in the next few days.
11:49:15 <ihope_> Fundeps. Is that like "class (Monad m) => MonadReader r m | m -> r"?
11:49:19 <jsnx> shapr: it is pretty invasive web crawling ;)
11:49:19 <shapr> ihope_: yeah
11:49:38 <shapr> I've been hacking on the blog demo code, it's pretty cool.
11:50:03 <shapr> HAppS is really powerful now, and that comes with some slightly complicated bits, and some beautifully simple bits.
11:50:10 <TuringTest> The new variant on System F that GHC 6.8 will use supports GADTs and FunDeps and AT's in a more consistent way.
11:50:14 <TuringTest> ihope_: yes
11:50:43 <shapr> One of the crazy cool things now is that state changing functions are automatically turned into ADT values.
11:51:06 <shapr> so getPage pagename = (return . getOne . (@=PName pagename) . pages) =<< ask \n $(expose ['getPage ] ) produces GetPage(..)
11:51:19 <sjanssen> shapr: there was an example on GHC's trac, but I can't find it now
11:51:27 <shapr> sjanssen: Too bad, I'd like to see that.
11:51:41 * wli wishes for ghc-cvs updates to 6.7.x in Debian.
11:51:46 <shapr> Philippa tells me out-of-band that SPJ's AngloHaskell slides have examples.
11:51:58 <TuringTest> shapr: the Haskell' mailing list may have much more on AT
11:52:09 <shapr> TuringTest: Yeah, I should really read that more.
11:52:55 <shapr> jsnx: I thought we were going to release yesterday, but we found a problem or two. The new HAppS code will be out really soon, I promise!
11:53:17 <tuomov> oerjan: I don't know what I should expect, but I find it inconvenient writing the class-requirements down for a zillion type variables
11:53:48 <shapr> I really wish for some way to pull a build order out of a list of darcs repos with cabal files in them.
11:54:10 <shapr> I'm hacking on some code that automatically rebuilds and restarts a server when the code changes.
11:54:15 <jtokle> so i'm taking my first steps with the FFI, and i have a style question
11:54:22 <jtokle> i'm playing with the alsa sequencer api
11:54:26 <shapr> jtokle: cool!
11:54:35 * shapr wants to see code
11:54:51 <jtokle> the function to open a connection has type: int snd_seq_open(snd_seq_t**, options...)
11:54:55 <jtokle> there really isn't much to show yet!
11:55:37 <jtokle> my proof of concept plays the middle c at one second intervals for eternity
11:55:42 <xerox> tuomov: data (Cxt a) => Foo a = Bar | Baz a gives Bar :: forall a. Foo a and Baz :: forall a. (Cxt a) => a -> Foo a
11:55:54 <jtokle> anyway, there is no function that returns a snd_seq_t**
11:56:16 <jtokle> so in my code, i use mallocBytes #{size snd_seq_t**}
11:56:18 <xerox> tuomov: that's how it is defined in the report, the context Cxt has no other effect whatsoever.
11:56:18 <sjanssen> @users
11:56:18 <lambdabot> Maximum users seen in #haskell: 419, currently: 404 (96.4%), active: 25 (6.2%)
11:56:36 <jtokle> and i was wondering if there was a better way to call such a function from haskell
11:56:54 <jtokle> part of the problem is, i've never written a useful c program in my life
11:57:01 <sjanssen> tuomov: you can get the behavior you want with a recent GHC and GADT syntax
11:57:06 <jtokle> so i have a phobia about *allocs
11:57:23 <Philippa> was there ever a second edition of Okasaki's Purely Functional Data Structures?
11:57:35 <tuomov> sjanssen: writing everything as constructors?-)
11:57:47 <xerox> sjanssen: example?
11:58:24 <sjanssen> tuomov: "data Bar :: * -> * where Bar :: Foo a => a -> Bar a"
11:58:29 <shapr> Philippa: Looks like he wrote a chapter in a 2004 book recently: http://www.eecs.usma.edu/webs/people/okasaki/pubs.html
11:58:31 <lambdabot> Title: Chris Okasaki's Publications
11:59:34 <sjanssen> jtokle: that looks okay.  Ptrs should always be the same size, so you can probably skip the bytes/size stuf
11:59:37 <tuomov> sjanssen: so that will make functions with 'Bar b' "inherit" the Foo a requirement?
12:00:24 <tuomov> or Foo b
12:00:24 <jtokle> i just pasted up some code
12:00:32 <sjanssen> jtokle: also, you have to be careful about those memory allocations -- you don't want to leak!  alloca, or something with ForeignPtr might be appropriate
12:00:51 <jtokle> basically, i wonder if it's the right right way to get a haskell function of type Some -> Options -> Sequencer
12:00:55 <oerjan> tuomov: i think it is slightly different, you need to pattern match on Bar x in a case
12:01:09 <oerjan> but once you do that, you get the context in the case
12:01:26 <sjanssen> tuomov: the 'Eq' dictionary will be stored inside the Bar constructor, so you won't have to write the context so long as you pattern match on the value
12:01:28 <oerjan> *inside
12:01:49 <jtokle> sjanssen: thanks.  so presumably, the library function expects the pointer and handles allocations from there
12:01:56 <tuomov> sjanssen: but it still has to be written in the signature if I don't pattern match?
12:01:59 <tuomov> What a hack...
12:02:11 <jtokle> again, i'm just ignorant of how things work in the c world
12:32:23 <jsnx> how do i list a directory?
12:33:13 <oerjan> jsnx: getDirectoryContents?
12:33:49 <jsnx> oerjan: i honestly couldn't find that one...
12:34:02 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Directory.html
12:34:04 <jsnx> just a sec
12:34:42 <jsnx> thanks
12:45:29 <sjanssen> @botsnack
12:45:45 <opqdonut> no luck
12:46:33 <Japsu> :<
12:46:45 <Japsu> what have they done to lambdabot
12:48:59 <ihope_> I ate her for lunch. Sorry.
12:51:24 <arcatan> what are you going to eat for dinner, by the way?
12:52:08 <sorear> @botsnack
12:52:22 <arcatan> :)
12:52:24 <sorear> @quit
12:52:49 <Ben`> @users
12:54:50 <oerjan> i didn't get an answer when i pinged her recently, though for all i know my ping could be what killed her...
12:54:54 <shapr> @botsnack
12:54:57 <shapr> aww
12:55:29 <Lemmih> Lambdabot should use HAppS and run on EC2.
12:55:29 <oerjan> (it was so quiet here i wondered if i was lagged out completely)
12:55:42 <sjanssen> lambdabot2: @botsnack
12:55:42 <lambdabot2> :)
12:55:59 <oerjan> > 1+1
12:56:01 <lambdabot2>  2
12:56:39 <oerjan> i guess lambdabot doesn't respond to pings
12:57:10 <oerjan> ( lambdabot2 didn't answer either, and didn't die )
12:57:39 <sieni> > foldl (flip const) 0 [1..5]
12:57:40 <lambdabot2>  5
12:57:53 <b_jonas> oerjan: it has to answer server pings I think
12:57:59 <Ben`> @version
12:57:59 <lambdabot2> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
12:58:00 <lambdabot2> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:58:02 <b_jonas> otherwise the server kicks it
12:58:25 <oerjan> b_jonas: yes but user pings are CTCP which is technically completely different
12:58:35 <b_jonas> oerjan: exactly
12:58:37 <shapr> Lemmih: yes!
12:58:41 <wli> If it doesn't answer server pings the server will disconnect it. User pings are indeed completely different.
12:58:55 * wli knows the protocol.
12:59:48 <b_jonas> my bot doesn't answer ctcp pings either (because no-one has requested that feature) but it answers a specific ping command (that has no use except it was one of the first commands I've added)
13:00:33 <b_jonas> actually, the server seems to disconnect you only if you don't send any comman, it doesn't matter if it's a pong or not, but it pings you periodically
13:01:17 <oerjan> well lambdabot has @bot for that, but the client doesn't give any automatic timing on that
13:03:39 <drigz> > 10
13:03:41 <lambdabot2>  10
13:04:19 <drigz> > ln 10
13:04:20 <lambdabot2>   Not in scope: `ln'
13:04:23 <drigz> > log 10
13:04:24 <lambdabot2>  2.302585092994046
13:04:33 <drigz> > 10000 / log 10000
13:04:34 <lambdabot2>  1085.7362047581294
13:09:23 <oerjan> > join(.)(join(.)(join(.))(join(.)))(+1)0
13:09:25 <lambdabot2>  256
13:10:10 <roconnor> > busyBeaver 6
13:10:11 <lambdabot2>   Not in scope: `busyBeaver'
13:10:36 <cjay> @unpl join(.)(join(.)(join(.))(join(.)))(+1)
13:10:36 <lambdabot2> ((\ a b c -> a (b c)) >>= \ n -> n) (((\ d e f -> d (e f)) >>= \ p -> p) ((\ g h i -> g (h i)) >>= \ r -> r) ((\ j k l -> j (k l)) >>= \ t -> t)) (\ m -> m + 1)
13:10:41 <xerox> oerjan: hideous :)
13:10:46 <cjay> uhm.
13:11:14 <oerjan> thank you
13:12:00 <desp> @bot
13:12:00 <lambdabot2> :)
13:12:02 <oerjan> > join(.)join(.)(join(.))(join(.))(+1)0
13:12:03 <lambdabot2>      Occurs check: cannot construct the infinite type: t = t1 -> t
13:12:03 <lambdabot2>     Probab...
13:12:17 <oerjan> > join(.)(join(.))(join(.))(join(.))(+1)0
13:12:18 <lambdabot2>  65536
13:12:19 <desp> @hoogle sleep
13:12:20 <lambdabot2> System.Win32.Process.sleep :: DWORD -> IO ()
13:12:28 <xerox> haha, this is crazy.
13:12:47 <desp> hm. sleep(3) isn't exposed?
13:13:24 <sjanssen> desp: threadDelay
13:14:05 <desp> ah, thanks
13:14:18 <elliottt> desp: System.Posix.Unistd.sleep
13:14:36 <sorear> desp: it is exposed, but it's a bad idea to use it
13:14:36 <lambdabot2> sorear: You have 1 new message. '/msg lambdabot2 @messages' to read it.
13:14:41 <sorear> @messages
13:14:42 <lambdabot2> igli said 25d 2h 20m 44s ago: Thanks mate :-) See you about soon hopefully.. #f-z is still the hideout ;p
13:15:24 <desp> sorear: it stops all haskell threads?
13:15:43 <desp> right.
13:15:43 <sjanssen> desp: yes, unless you're using ghc -threaded
13:15:49 <sorear> desp: no, it creates a brand new OS thread, calls sleep in it, and waits :)
13:15:58 <desp> hmm
13:16:09 <desp> I sense a conflict
13:16:15 <desp> the doc offers a third opinion: http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Unistd.html
13:16:17 <lambdabot2> http://tinyurl.com/2m28rp
13:16:35 <sjanssen> sorear's explanation holds for the threaded runtime only
13:16:44 <desp> I see.
13:16:57 <sorear> desp: I explained the threaded case, sjanssen explained the unthreaded case.  The docs explain both.
13:17:26 <desp> I am enlightened. thank you.
13:19:01 <glguy> hpaste, url
13:20:16 <oerjan> @hpaste
13:20:16 <lambdabot2> Haskell pastebin: http://hpaste.org/new
13:20:37 <glguy> oerjan: yeah... I know the url :-p
13:20:43 <dcoutts> @seen desegnis
13:20:43 <lambdabot2> I saw desegnis leaving #haskell.de 4d 55m 16s ago, and .
13:20:47 <glguy> @seen hpaste
13:20:47 <lambdabot2> I haven't seen hpaste.
13:20:54 <oerjan> glguy: your request was a bit ambiguous :)
13:21:11 <glguy> oerjan: the relevant parties would know what that should have done
13:22:10 <xerox> > (join(.)>>=(.))(+1)0
13:22:12 <lambdabot2>  3
13:22:24 <xerox> > (((.)=<<join(.))>>=(.))(+1)0
13:22:26 <lambdabot2>  4
13:22:27 <oerjan> i saw hpaste connect and promptly disconnect yesterday
13:22:39 <xerox> > (((.)=<<(join(.)>>=(.)))>>=(.))(+1)0
13:22:40 <lambdabot2>  5
13:22:49 <xerox> > (((.)=<<(((.)=<<join(.))>>=(.)))>>=(.))(+1)0
13:22:51 <lambdabot2>  6
13:22:54 <Botje> xerox: HEAD HURTAGE. PLZ TO STOP NOW
13:22:56 <xerox> scales :D
13:22:58 <Japsu> :D
13:23:18 <oerjan> monadic church numerals :)
13:23:34 * xerox high-fives oerjan 
13:24:12 <byorgey> > let fermat n = (foldl (flip id) (join (.)) (replicate n (join (.)))) (+1) 0 in fermat 3
13:24:13 <lambdabot2>  256
13:24:47 <byorgey> worst way in the world to calculate Fermat numbers =)
13:25:01 <oerjan> @unpl ((.)=<<)
13:25:01 <lambdabot2> (\ d -> d >>= \ a b c -> a (b c))
13:25:10 <Japsu> errrrgh
13:25:16 <phobes> Is there an FRP system for haskell that can do UIs and is ready for prime-time?
13:25:17 <ivant> @unpl (foldl (flip id) (join (.)) (replicate n (join (.)))) (+1)
13:25:17 <Japsu> what's the monad in  23:21   xerox : > (join(.)>>=(.))(+1)0
13:25:18 <lambdabot2> foldl (\ b c -> c b) ((\ e f g -> e (f g)) >>= \ l -> l) (replicate n ((\ h i j -> h (i j)) >>= \ o -> o)) (\ k -> k + 1)
13:25:24 <Japsu> list?
13:25:40 <xerox> Japsu: ((->) e), the Reader monad.
13:25:46 <Japsu> @type (join(.)>>=(.))(+1)
13:25:48 <lambdabot2> forall b. (Num b) => b -> b
13:25:55 <Japsu> xerox: ...right
13:26:04 <Japsu> now how evil is that
13:27:15 <xerox> pretty patterns :)
13:34:04 <Cale> heh
13:35:08 <Cale> > (do x <- (.); y <- x; (.) y) (+ 1) 0
13:35:09 <lambdabot2>  3
13:36:09 <Botje> "y <- x" seems so .. deceptive.
13:36:13 <elliottt> @type join (.) >>= (.)
13:36:15 <lambdabot2> forall b. (b -> b) -> b -> b
13:38:40 <Cale> It's not so bad, if you know what the monad is doing in this case
13:39:37 <Cale> (.) is run to produce x, so x = (.) (+1), and then x is run to produce y, so y = x (+1) = (.) (+1) (+1) = (+2) (essentially)
13:40:00 <Botje> yeah, but it's still confusing :)
13:40:11 <Cale> then (.) y = (.) (+2) is run, giving (.) (+2) (+1) = (+3)
13:40:51 <phobes> Does anyone know if there is an FRP system for haskell that can do UIs and is ready for use?
13:41:07 <Cale> phobes: hmm...
13:41:11 <xerox> ?where Phooey
13:41:11 <lambdabot2> http://conal.net/phooey/
13:41:15 <xerox> Maybe that one?
13:42:01 <Cale> Is Phooey more than a rather cool toy yet? It seems to have dialog boxes down. :)
13:42:28 <xerox> Mathematica 6.0 then? (:
13:42:37 <Cale> heh, that's not for Haskell.
13:42:42 <xerox> Too bad.
13:42:46 <oerjan> anyway if there is another obfuscated haskell contest, i think it should be numbered join(.)
13:43:11 <Cale> heh
13:43:15 <phobes> xerox:  thanks for the link
13:43:21 <xerox> "The join(.)succ Obfuscated Haskell Contest"
13:43:42 <oerjan> xerox: no succ, join(.) is a perfectly good church numeral
13:43:54 <xerox> Right.
13:43:58 <phobes> where the object is to "succ" the most?
13:49:48 <byorgey> clearly the object would be to "pred" the most.
13:51:07 <dylan> @hoogle ([a], (a, [a])) -> ([a], a, [a])
13:51:08 <lambdabot2> No matches, try a more general search
13:55:14 <oerjan> :t flip (uncurry (,,))
13:55:16 <lambdabot2> forall a b c. c -> (a, b) -> (a, b, c)
13:55:44 <oerjan> :t curry (flip (uncurry (,,)))
13:55:46 <lambdabot2> forall a b a1 b1. a1 -> b1 -> (a, b) -> (a, b, (a1, b1))
13:56:04 <oerjan> :t uncurry (flip (uncurry (,,)))
13:56:06 <lambdabot2> forall a b c. (c, (a, b)) -> (a, b, c)
13:56:25 <kpreid> @pl \(a, (b, c)) -> Mk3 a b c
13:56:26 <lambdabot2> uncurry ((`ap` snd) . (. fst) . Mk3)
13:56:39 <conal> ?wiki Phooey
13:56:39 <lambdabot2> http://www.haskell.org/haskellwiki/Phooey
13:56:54 <conal> ?where+ phooey http://www.haskell.org/haskellwiki/Phooey
13:56:54 <lambdabot2> Done.
13:57:16 <conal> what's with "lambdabot2"?
13:58:06 <ivant> wow! "Hoping to improve the state of server software, Sun Microsystems has confirmed that it will include support for transactional memory with the first generation of its Rock processors due out in the second half of next year."
13:58:20 <ivant> http://www.theregister.co.uk/2007/08/21/sun_transactional_memory_rock/
13:58:22 <lambdabot2> http://tinyurl.com/24m5e7
13:59:10 <mrd> yea i read that. it's hardware/hybrid TM
14:02:10 <ivant> I wonder if it makes sense to use this technology in the implementation of STM
14:07:30 <shapr> ivant: I was wondering that myself.
14:10:13 <mdmkolbe|work> I have two lists and I want to devide the second list into parts of lengths determined by the first list.  (e.g. [2, 4, 3] and "abcdefghi" should produce ["ab", "cdef", "ghi"]).  Any short way to do that?
14:11:02 <ivant> shapr, I'll keep an eye on this technology, and probably would be able to find out the details at some point
14:11:12 <mrd> :t unfoldr
14:11:21 <lambdabot2> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:14:16 <oerjan> > runState (mapM (State . splitAt) [2,4,3]) "abcdefghi"
14:14:18 <lambdabot2>  (["ab","cdef","ghi"],"")
14:14:52 <lament> cute
14:16:16 <ivant> have you guys read the “Programming with Arrows”? Some of the examples (with streams/lists) are really bizarre there, I can't make head or tail out of them
14:17:21 * desp giggles
14:19:06 <conal> @go “Programming with Arrows”
14:19:08 <lambdabot2> http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf
14:19:21 * oerjan wonders if ivant's pun was deliberate
14:20:13 <ivant> oerjan, it was, partially :-)
14:22:51 <conal> ivant: the url that @go found is missing many figures (at least my download is).  do you know of a copy with figures?
14:23:10 <ivant> conal, alas, I don't :-(
14:23:42 <ivant> conal, probably ps version had them, but they were lost during ps2pdf conversion
14:25:38 <shapr> Only three pdfs show here - http://scholar.google.com/scholar?num=100&hl=en&lr=&safe=off&cluster=4853552215687694491
14:25:40 <lambdabot2> Title: - Google Scholar, http://tinyurl.com/2zksd5
14:26:12 <ihope_> Hmm. Couldn't the example be written as "print . length . filter (==w) . words =<< readFile" or maybe "(print . length . filter (==w) . words) =<< readFile"
14:27:06 <ivant> ihope_, I guess, that was not very useful for the purposes of arrows exposition
14:27:18 <ihope_> Indeed.
14:31:40 <byorgey> @smack byorgey's job
14:31:40 <lambdabot2> Unknown command, try @list
14:31:59 <byorgey> @slap byorgey's job
14:32:00 * lambdabot2 smacks byorgey's job about with a large trout
14:32:02 <Botje> is there a reason http://www.haskell.org/haskellwiki/Haskell_in_industry lists "erlang training and consulting, ltd" ?
14:32:03 <lambdabot2> Title: Haskell in industry - HaskellWiki
14:32:19 <byorgey> @botsnack
14:32:20 <lambdabot2> :)
14:33:17 <Botje> hmm, nevermind. it's been there since the beginning of that page's history apparently
14:35:03 <slava> glguy: yes?
14:37:13 <glguy> slava: it was a factor question I ended up figuring out on my own last night
14:42:05 <marcotmarcot> Hello, I'm trying some different forms of getting primes, but I don't get why some of them which I expect to have better results are having worse.
14:43:26 <oerjan> marcotmarcot: could you paste?
14:43:34 <marcotmarcot> http://hpaste.org/2391
14:43:35 <marcotmarcot> I pasted.
14:43:46 <marcotmarcot> I didn't notticed it hasn't announced.
14:44:11 <marcotmarcot> I thought primos would be the slower, but it's the faster.
14:44:22 <oerjan> yeah, the hpaste bot is apparently ill
14:44:31 <marcotmarcot> And I thought crivo2 would be faster than crivo, but crivo is faster.
14:44:43 <marcotmarcot> In time consuming primos < crivo < crivo2, just the oposite I thought.
14:48:05 <marcotmarcot> oerjan: any idea about the algorithms?
14:49:31 <oerjan> well, it may be that the use of lists in primo is optimized away and turned into loops
14:51:24 <oerjan> for crivo_, filtering means you traverse the list once per prime
14:52:14 <marcotmarcot> oerjan: and why it's not optimized in crivo2?
14:52:23 <oerjan> and since you are using a linked list rather than a mutable array, you don't get to skip the intermediate values
14:52:57 <oerjan> i don't understand crivo2 yet
14:53:14 <marcotmarcot> hum...
14:54:02 <thruspa> It seems that crivo2 builds an intermediate list when calling filter in the guard (?).
14:54:07 <marcotmarcot> crivo2 is like primos, but it searches in the list of the primes that have already been found, instead of the list of all integers..
14:54:08 <oerjan> hm, one thing i see: the filter in crivo2_ is inefficient
14:54:27 <marcotmarcot> Why?
14:54:48 <oerjan> it doesn't stop once the condition fails
14:55:26 <marcotmarcot> This is true for crivo_
14:55:32 <marcotmarcot> also.
14:55:38 <yax1> http://hpaste.org/2392
14:55:46 <oerjan> no
14:55:58 <oerjan> i mean the <= ceiling ... condition
14:56:15 <oerjan> however the lista is probably in the wrong order to stop
14:56:19 <yax1> Is the (english) language I'm using to describe types in that paste reasonable?
14:56:31 <marcotmarcot> oerjan: it's in the wrong order..
14:56:35 <marcotmarcot> but this could be fixed.
14:56:50 <marcotmarcot> But you give me a good idea, I'll try to do this in crivo
14:57:06 <marcotmarcot> in crivo_ (x : xs) = x : crivo_ (filter ((/= 0) . flip mod x) xs)
14:58:52 <thruspa> A silly question: in crivo2_, when you find a prime, its multiples are not automatically discarded?
14:59:34 <oerjan> thruspa: that's what all (ndivide x) does
14:59:42 <marcotmarcot> thruspa: no, they're not on the list yet, only the primes are included in the list.
14:59:58 <cognominal_> hoogle, does that stands for higher order ogling?
15:00:05 <marcotmarcot> all (ndivide x) don't let a number that is multiple of a prime get in the list.
15:00:08 <cognominal_> :)
15:00:42 <thruspa> But ndivide is called at the left of the guard.
15:00:59 <thruspa> The output list is not filtered against multiples of the prime.
15:01:14 <thruspa> So x=2, x=4, x=6, etc. happen.
15:01:26 <thruspa> Not in crivo.
15:02:12 <drigz_> i'm having trouble using STArray: http://hpaste.org/2393
15:02:17 <drigz_> can anyone help?
15:03:16 <oerjan> anyway i think crivo and crivo2 may be up against the inefficiencies of having to use intermediate lists
15:04:33 <dolio> drigz_: "a' <- unsafeFreeze a ; return a"
15:04:48 <dolio> Shouldn't that be "return a'"?
15:05:00 <ddarius> Or just drop the return and the a' <-
15:05:06 <dolio> That too.
15:05:12 <drigz_> dolio: you're right, thanks
15:05:22 <drigz_> big error message for a little apostrophe...
15:05:34 * SamB wonders what a good algorithm for log2 on Integer is
15:05:56 <Lemmih> drigz_: Use runSTArray and drop the typesig after 'newArray'.
15:05:57 <marcotmarcot> Thanks guys, bye.
15:06:03 <thruspa> Yes, the multiples are not filtered. If you add  | x == 4 = error "oops"  at the start of the guard, you can see it.
15:06:14 <monochrom> SamB: do you need a high precision for the answer?
15:06:24 <thruspa> So I think that crivo is more efficient since it removes the multiples of each detected prime.
15:06:36 <SamB> monochrom: well, I expect the Integers to be fairly small
15:06:50 <SamB> and actually they might be one of the Int family
15:07:03 <monochrom> If they're small, convert to Double and log there.
15:07:18 <SamB> yes, they're certain to fit in Double...
15:08:11 <SamB> though, um, some might not be without loss of precision
15:08:18 <SamB> :-(
15:08:31 <monochrom> It depends on how much precision you want.
15:08:38 <oerjan> yax1: looks reasonable to me (a non-native speaker), except "a n-ary" should be "an n-ary"
15:08:47 <mauke> http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious
15:08:49 <lambdabot2> Title: Bit Twiddling Hacks, http://tinyurl.com/3j7nq
15:08:58 <glguy> > let rough x = elemIndex 0 $ iterate (`div` 2) x in rough 23512781
15:08:59 <lambdabot2>  Just 25
15:09:13 * SamB bookmarks page
15:09:16 <drigz_> Lemmih: it doesn't build if i do that...
15:09:41 <SamB> I have this feeling that I've been here before, you see, and am under the delusion that a bookmark might cause me to remember that it exists...
15:09:49 <Lemmih> drigz_: How so?
15:11:01 <drigz_> Lemmih: i don't know
15:11:05 <drigz_> Lemmih: helpful, huh?
15:11:17 <drigz_> Lemmih: i guess i should get rid of the freeze if i do that
15:11:19 <SamB> well, suppose I have the fractional part of a quad-precision number...
15:11:24 <drigz_> so i changed it to just have a on the last line
15:11:31 <drigz_> and it gets things about s not being Int
15:11:33 <Lemmih> drigz_: Does your computer explode? Does GHC complain? Does it vanish in a blackhole?
15:11:33 <SamB> (see http://en.wikipedia.org/wiki/Quad_precision )
15:11:47 <drigz_> Lemmih: i shall post the new code and error
15:11:53 <nornagon> drigz_: does the blue smoke leak out?
15:12:21 <SamB> a *denormalized* quad-precision number
15:12:40 <drigz_> Lemmih: http://hpaste.org/2393#a1
15:13:17 <SamB> which is, um, 112 bits
15:13:36 <Lemmih> drigz_: return a.
15:14:23 <drigz_> Lemmih: thanks
15:14:53 <drigz_> my first expedition beyond very simple monad use is rocky
15:16:00 <drigz_> Lemmih: what should I do to switch to STUArray? I tried changing runSTArray to runSTUArray, but i got (another) big error message. want to see it?
15:16:06 <SamB> monochrom: no wait, it's probably not denormalized but, I'm converting it to a smaller representation
15:16:14 <glguy> we need a STFUArray
15:16:21 <monochrom> haha
15:16:21 <SamB> so anyway I need to know exactly where that first 1 is
15:16:24 <Lemmih> drigz_: Sure.
15:16:26 <glguy> finite unboxed or something
15:16:39 <glguy> we could recommend it to disruptive people
15:16:44 <SamB> I think it's called IOUArray
15:17:12 <mauke> EIEIOArray
15:17:23 <drigz_> Lemmih: oh wait, i forgot to change the top type sig
15:18:41 <ddarius> As opposed to normal infinite unboxed arrays...
15:19:05 <yax1> oerjan: thanks!
15:19:10 <drigz_> everything I do to try to make it faster makes it slower :(
15:19:31 <mauke> try to make it slower
15:19:35 <glguy> that's great, that means you should do nothing at all
15:19:42 <drigz_> @hoogle sleep
15:19:46 <lambdabot2> System.Win32.Process.sleep :: DWORD -> IO ()
15:19:52 <mauke> @hoogle threadDelay
15:19:52 <drigz_> glguy: i'm pretty sure it means i need to keep practising
15:19:52 <lambdabot2> Control.Concurrent.threadDelay :: Int -> IO ()
15:19:52 <glguy> ?hoogle threadWait
15:19:53 <lambdabot2> Control.Concurrent.threadWaitRead :: Fd -> IO ()
15:19:53 <lambdabot2> Control.Concurrent.threadWaitWrite :: Fd -> IO ()
15:20:24 <SamB> monochrom: if only I could convert to Double with a specific rounding mode...
15:20:41 <mauke> sleep = threadDelay . round . (1e6 *)
15:23:14 <ddarius> drigz_: That's the secret of Haskell.
15:25:41 <Nucleo2> @define \\
15:25:45 <lambdabot2> Undefined.
15:25:47 <Nucleo2> @src \\
15:25:48 <lambdabot2> (\\) = foldl (flip delete)
15:28:35 <newsham> is haskell five star software?
15:28:36 <newsham> http://successfulsoftware.net/2007/08/16/the-software-awards-scam/
15:28:39 <lambdabot2> Title: The software awards scam  Successful Software, http://tinyurl.com/223mcd
15:30:12 <drigz_> @src divMod
15:30:12 <lambdabot2> Source not found. I can't hear you -- I'm using the scrambler.
15:30:18 <drigz_> @src quotRem
15:30:18 <lambdabot2> Source not found. And you call yourself a Rocket Scientist!
15:30:27 <oerjan> @src Integral
15:30:28 <lambdabot2> class  (Real a, Enum a) => Integral a  where
15:30:28 <lambdabot2>     quot, rem, div, mod :: a -> a -> a
15:30:28 <lambdabot2>     quotRem, divMod     :: a -> a -> (a,a)
15:30:28 <lambdabot2>     toInteger           :: a -> Integer
15:30:39 <newsham> ?src Int divMod
15:30:39 <lambdabot2> Source not found. You type like i drive.
15:30:45 <drigz_> is there any difference?
15:31:04 <mauke> > divMod 2 (-3)
15:31:06 <lambdabot2>  (-1,-1)
15:31:08 <mauke> > quotRem 2 (-3)
15:31:10 <lambdabot2>  (0,2)
15:32:47 <drigz_> wow, quotRem is a lot faster
15:34:00 <b_jonas> drigz_: on Ints or Integers?
15:34:09 <drigz_> Ints
15:34:15 <b_jonas> because on Ints I think it would depend on which one is built in the cpu
15:34:22 <drigz_> yes, that's what i guessed
15:35:13 <bos> @pl \v (_, t) -> v + countLeaves t
15:35:13 <lambdabot2> (`ap` snd) . (. fst) . const . (. countLeaves) . (+)
15:35:48 <drigz_> @pl \(_, t) -> v + countLeaves t
15:35:49 <lambdabot2> (v +) . countLeaves . snd
15:36:19 <ddarius> @src Ind divMod
15:36:20 <lambdabot2> Source not found. My pet ferret can type better than you!
15:37:06 <oerjan> @pl \v t -> v + cLsnd t
15:37:06 <lambdabot2> (. cLsnd) . (+)
15:37:30 <mauke> @src Int quotRem
15:37:31 <lambdabot2> Source not found. And you call yourself a Rocket Scientist!
15:37:42 <oerjan> @unpl (. countLeaves . snd) . (+)
15:37:43 <lambdabot2> (\ d j -> d + (countLeaves (snd j)))
15:39:59 <gle1> @awww
15:40:00 <lambdabot2> Unknown command, try @list
15:40:34 <drigz_> wow, pl let us down
15:40:55 <ddarius> The real lambdabot is sulking.
15:41:03 <oerjan> @arrr
15:41:03 <lambdabot2> Ahoy mateys
15:41:59 <oerjan> drigz_: it's not terribly good with pairs i think
15:42:19 <drigz_> yeah, it does seem that way
15:42:36 <drigz_> i rely on it so much though :p
15:44:02 <oerjan> i am not sure any expression that needs @pl to make it pointfree should be...
15:44:51 <gle1> oerjan: that could make a nice quote
15:44:55 <drigz_> oerjan: it's more that it teaches me ways of simplifying things
15:45:05 <drigz_> rather than actually using it to make things pointfree
15:45:23 <oerjan> gle1: just my luck i made it when lambdabot was down :D
15:45:31 <drigz_> for example, it taught me that you can cut 2 characters out by using join instead of concat :p
15:45:41 <sorear> drigz_: Intel's 8086 processor line provides one (core) combined division/modulus instruction for signed numbers IDIV with the semantics of quotRem and one division-only instruction also called IDIV and also with the semantics of quot.
15:45:44 <ddarius> @help tell
15:45:44 <lambdabot2> tell <nick> <message>. When <nick> shows activity, tell them <message>.
15:46:23 <drigz_> sorear: is quot faster than div on x86?
15:46:47 <sorear> drigz_: Probably not, but it should be
15:53:48 <drigz_> i hate trying to recover the computer when you accidentally run an infinite loop
15:55:53 <ddarius> It shouldn't be hard.
15:58:55 <drigz_> ddarius: it just takes a long time
15:59:12 <drigz_> open process viewer, wait 2 minutes, click entry, wait 1 minute, click kill, wait 1 minute...
16:00:33 <sjanssen> drigz_: what about ctrl-c?
16:01:16 <gle1> sjanssen: I doesn't work In Emacs on Windows, for example
16:04:09 <drigz_> sjanssen: i found that some ^Cs appeared on the terminal. i managed to kill it with the process monitor before they took effect
16:04:27 <mrd> you need to run the ghci.sh thing
16:05:47 <drigz_> i'm on mac os x, and it was a compiled program
16:06:55 <sorear> drigz_: killall -9 doesn't work?
16:07:10 <kpreid> how about killall without -9?
16:10:34 <drigz_> sorear: would have had to open another terminal, and given that terminal was too hard pressed to process a ctrl-c, i figured it couldn't handle opening a new window and running a command
16:10:51 <drigz_> the RAM was full, rather than the CPU
16:17:12 <gle1> @users
16:17:12 <lambdabot2> Maximum users seen in #haskell: 411, currently: 374 (91.0%), active: 7 (1.9%)
16:26:47 <ege1> do people use records very much?  i noticed (at least in ghc) that you can't have two record types with overlapping field names...
16:27:12 <lament> yes, that part's really annoying, isn't it
16:27:20 <stepcut> ege1: people write new record proposals a lot
16:30:06 <Liskni_si> at least you won't run into a problem like the change of open to macro in recent glibc :)
16:30:57 <byorgey> slightly OT, but in formal mathematics writing, would you use "nonnegative" or "non-negative"?
16:31:13 <ddarius> Liskni_si: You can use CPP with Haskell if you'd like...
16:31:35 <Heffalump> byorgey: the latter
16:31:38 <byorgey> it's not actually OT since I'm writing an article for TMR =)
16:31:43 <byorgey> Heffalump: ok, thanks
16:32:39 <ddarius> byorgey: I'd probably use the latter, but I think both are acceptable.
16:33:06 <kaol> @hoogle Bool -> Maybe a
16:33:06 <lambdabot2> No matches, try a more general search
16:33:46 <byorgey> ddarius: yeah, I think I've seen both, so I was wondering whether people would consider one or the other more correct
16:33:47 <lament> kaol: that's a .. rather strange signature
16:34:00 <byorgey> I was leaning towards the latter as well, so that settles it =)
16:34:10 <kaol> I was hoping to see a function like fun that does fun False = Nothing; fun True = Just ()
16:34:14 <ddarius> @djinn Bool -> Maybe a
16:34:15 <lambdabot2> f _ = Nothing
16:34:32 <twanvl> byorgey: http://www.googlefight.com/index.php?lang=en_GB&word1=nonnegative&word2=non-negative
16:34:36 <kaol> but it's guard that I was thinking of, really
16:34:36 <lambdabot2> Title: Google Fight : Make this fight with googleFight nonnegative VS non-negative, http://tinyurl.com/ytyldl
16:34:49 <ddarius> kaol: yep
16:35:11 <byorgey> twanvl: hehe.  they come out pretty much the same...
16:39:11 <Paczesiowa> hi, noob question: I use executeFile (wget) in main and ghci quits after firing up wget, what should I do to make ghci execute the remaining functions?
16:39:45 <glen_quagmire> :t executeFile
16:39:48 <lambdabot2> Not in scope: `executeFile'
16:39:56 <glen_quagmire> @index executeFile
16:39:56 <lambdabot2> System.Posix.Process, System.Posix
16:40:40 <xerox> Paczesiowa: you might try with runProcess, and waitFor or waitPid or waitThread or whatever it was called :)
16:40:46 <glen_quagmire> Paczesiowa: it will execute remaining functions i think
16:40:52 <glen_quagmire> oh i se
16:43:54 <Paczesiowa> :t runProcess
16:43:56 <lambdabot2> Not in scope: `runProcess'
16:44:27 <Paczesiowa> need some help with that runProcess :P
16:45:13 <Paczesiowa> @index runProcess
16:45:13 <lambdabot2> System.Process
16:46:22 <xerox> ?docs System.Process
16:46:22 <lambdabot2> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
16:46:32 <xerox> Take a look there as well
16:48:35 <Paczesiowa> System.Process is much more interesting than System.Posix.Process, I always google some worthless piece of poo
16:49:00 <Paczesiowa> xerox: tx
16:49:42 <ddarius> Paczesiowa: Start at the heirarchical libraries then go to hackage then go to google or the libraries and applications page.
16:50:28 <Paczesiowa> ddarius: tx for hints
16:59:40 <drigz_> project euler would be much easier if computers used base 10 internally...
16:59:55 <drigz_> almost everything involves digit compositions
17:01:36 <ddarius> Binary is the right choice.
17:04:54 <glguy> the person that wrote the "most" utility must have lived in a vacuum
17:06:33 <Cale> glguy: any particular reason?
17:06:42 <glguy> Cale: the keybindings are insane
17:06:46 <Cale> heh
17:07:24 <glguy> everyone knows that 'j' means down a line
17:07:38 <glguy> 'T' and 'B' are not "top and bottom"
17:07:49 <Cale> how about / for searching?
17:08:08 <glguy> that works
17:08:15 <dolio> It's also difficult to google.
17:08:41 <glguy> R or ^R is redraw screen??
17:08:43 <glguy> ^L?
17:08:58 <Olathe> > let digits' [] 0 = [0]; digits' ds 0 = ds; digits' ds n = digits' ((mod n 10) : ds) (div n 10) in let digits = digits' [] in digits 2093
17:09:00 <lambdabot2>  [2,0,9,3]
17:09:17 <Cale> dolio: <most pager> worked.
17:09:35 <glguy> > map digitToInt $ show 2093
17:09:36 <lambdabot2>  [2,0,9,3]
17:09:42 <dolio> Ah, I should have tried that.
17:09:42 <Olathe> Neat.
17:10:43 <Cale> > let digits = reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) in digits 2093
17:10:44 <lambdabot2>  [2,0,9,3]
17:11:13 <Olathe> :)
17:12:59 <dolio> > let f p g x = if p x then Nothing else Just (f x) in unfoldr ((==0) `f` divMod) 2039
17:13:00 <lambdabot2>      Occurs check: cannot construct the infinite type: t = t -> Bool
17:13:00 <lambdabot2>     Prob...
17:13:49 <dolio> > let f p g x = if p x then Nothing else Just (f x) in unfoldr ((==0) `f` flip divMod 10) 2039
17:13:50 <lambdabot2>      Occurs check: cannot construct the infinite type: t = t -> Bool
17:13:50 <lambdabot2>     Prob...
17:13:53 <dolio> Bah.
17:14:17 <dolio> Oh, of course.
17:14:24 <ddarius> g
17:14:28 <dolio> Yeah.
17:14:52 <dolio> It's still not right because divMod is backwards, I think.
17:15:08 <dolio> From an unfoldr perspective.
17:15:12 <Cale> yeah
17:15:18 <Cale> > reverse . unfoldr (\x -> let (u,v) = x `divMod` 10 in if x == 0 then Nothing else Just (v,u)) $ 2093
17:15:20 <lambdabot2>  [2,0,9,3]
17:15:56 <Cale> > reverse . unfoldr (\x -> let (u,v) = x `divMod` 10 in guard (x /= 0) >> return (v,u)) $ 2093
17:15:57 <lambdabot2>  [2,0,9,3]
17:16:25 <ddarius> (snd&&&fst .) . divMod
17:16:28 <ddarius> :t (snd&&&fst .) . divMod
17:16:29 <lambdabot2>     The operator `.' [infixr 9] of a section
17:16:29 <lambdabot2>         must have lower precedence than the operand `(&&&)' [infixr 3]
17:16:36 <ddarius> :t ((snd&&&fst) .) . divMod
17:16:38 <lambdabot2> forall a. (Integral a) => a -> a -> (a, a)
17:16:45 <Cale> > let swap (x,y) = (y,x) in reverse . unfoldr (\x -> guard (x /= 0) >> return (swap (x `divMod` 10))) $ 2093
17:16:46 <lambdabot2>  [2,0,9,3]
17:17:29 <dolio> Is swap anywhere? Seems like it'd be in Control.Arrow, but maybe they just define it in where clauses.
17:17:46 <Cale> It's not anywhere I know of.
17:18:17 <dolio> Yeah, it's in a where clause for the default implementation of second.
17:18:20 <sjanssen> @type uncurry (flip (,))
17:18:22 <lambdabot2> forall b a. (a, b) -> (b, a)
17:19:28 <desp> is it possible to cast a Ptr () to a CInt in Haskell?
17:19:48 <ddarius> @index IntPtr
17:19:48 <lambdabot2> bzzt
17:19:52 <ddarius> @hoogle IntPtr
17:19:52 <lambdabot2> No matches found
17:20:43 <desp> got it, thanks
17:29:52 <MarcWeber> How does haxml compare to xmltoolbox?
17:35:30 <shapr> Can a running Haskell program get its own pid?
17:35:46 <shapr> Ah, getProcessID
17:37:28 <sorear> Would someone please explain why it's not called getpid?
17:37:38 <ddarius> sorear: Because this isn't C.
17:38:52 <LoganCapaldo> aint that a fact
17:39:21 <LoganCapaldo> It could be worse
17:39:53 <LoganCapaldo> it could be like System.Process.ProcessTable.Retrieve.Id.GetProcessIdForCurrentProcess
17:40:15 <shapr> Is /var/run used for pids on all unixy systems? (bsd, osx, linux, etc)
17:42:43 <desp> LoganCapaldo: get the procedd id of the current process of the process table of the system
17:42:50 <desp> s/procedd/process/
17:42:55 <desp> HyperTalk FTW
17:50:27 <SamB> sorear: because some idiot decided unix names weren't good enough
17:50:44 <SamB> not even in the posix package
17:50:52 <SamB> unix, whatever
17:51:52 <eivuokko> Unix names suck imo, but I don't care about unix package ;)
17:53:07 <SamB> well it sucks less than using completely different names in a package specifically to make unix calls available to Haskell programs...
17:53:30 <SamB> especially if we aren't going to do it in any kind of consistant way
17:53:33 <dons> ?users
17:53:33 <lambdabot2> Maximum users seen in #haskell: 411, currently: 369 (89.8%), active: 9 (2.4%)
17:54:10 <dons> sorear: all the recent lambdaboproblems have been due to the url module failing, url module failed in contextual handler: IRCRaised thread killed
17:54:34 <dons> lambdabot2: @part #haskell
17:54:39 <dons> ?users
17:54:44 <lambdabot> Maximum users seen in #haskell: 385, currently: 368 (95.6%), active: 1 (0.3%)
17:55:32 <eivuokko> SamB, from my very limited experience with unix-package, it seems it doesn't try to bring unix/posix calls available to Haskell, but rather the functionality.
17:55:46 <dhpeterson> dons: hi ... question for you ...
17:55:52 <dons> dhpeterson: yeah?
17:56:00 <dhpeterson> dons: do you know of any FP research groups in melbourne (oz)
17:56:08 <dhpeterson> i've recently moved down here from sydney
17:56:20 <SamB> eivuokko: well. if it's going to use new names, it should use good, somewhat consistant ones...
17:56:32 <dons> dhpeterson: yeah, there's the FP group at Melbourne Uni.
17:56:43 <dons> dhpeterson: let me find a link
17:56:49 <dhpeterson> k thnx
17:57:01 <dhpeterson> do they do much in haskell or erlang?
17:57:05 <dhpeterson> (if you know)
17:59:16 <dons> dhpeterson: Peter Stuckey, http://www.cs.mu.oz.au/~pjs/, Zoltan Somogyi, Bernie Pope, http://www.cs.mu.oz.au/~bjpop/ ,
17:59:16 <lambdabot> Title: Stuckey's home page
17:59:24 <dhpeterson> right
17:59:29 <dons> type system guys, haskell hackers, mercury hackers
17:59:31 <dhpeterson> what about monash anything happening?
17:59:55 <dons> hmm, i can't think of anything. Pseudonym might know (he's in Melbourne, formerly from mu.oz.au)
18:00:01 <xpika> how do you reply to a mailing list thread?
18:00:03 <dons> oh, but he's not here today.
18:00:09 <SamB> xpika: where?
18:00:13 <xpika> haskell-cafe
18:00:24 <SamB> I mean, where are you reading it
18:00:35 <dhpeterson> great
18:00:38 <xpika> yahoo mail
18:00:39 <dhpeterson> thanks very much for your help
18:00:47 <SamB> xpika: reply to all or something
18:00:47 <dons> sure!
18:01:28 <SamB> I'm just glad you weren't reading it off pipermail ;-)
18:01:43 <xpika> SamB: thanx
18:02:04 <xpika> SamB: i tried nabble but that didnt work
18:02:22 <SamB> gmane works usually
18:02:45 <SamB> though if you aren't subscribed it might take a while for the moderator to get to it
18:02:52 <SamB> (especially on weekends)
18:14:49 <Kaboem> someone knows what hugs means with : Haskell 98 does not support tag classes ?
18:15:02 <sorear> nope
18:15:18 <Kaboem> intersting :p
18:15:42 <sorear> Kaboem: You tried to define a class with 0 parameters.
18:17:30 <Kaboem> nope I tried to define a class Sequence a where
18:17:30 <Kaboem> prev :: a -> a
18:17:30 <Kaboem> next:: a->a
18:17:30 <Kaboem> and then later
18:17:30 <Kaboem> instance Int where
18:17:31 <Kaboem> prev = pred
18:17:33 <Kaboem> next = pred
18:17:53 <desp> did you mean instance Sequence Int?
18:18:04 <Kaboem> yes sorry
18:18:18 <Kaboem> it's there where it goes wrong
18:18:45 <desp> @where hpaste
18:18:45 <lambdabot> I know nothing about hpaste.
18:18:49 <desp> @hpaste
18:18:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:18:50 <sorear> @paste
18:18:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:19:33 <sorear> Kaboem: instance Sequence Int where
18:21:24 <int-e> @where derive
18:21:25 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
18:24:57 <shapr> @yow !
18:24:57 <lambdabot> Once upon a time, four AMPHIBIOUS HOG CALLERS attacked a family of
18:24:57 <lambdabot> DEFENSELESS, SENSITIVE COIN COLLECTORS and brought DOWN their PROPERTY
18:24:57 <lambdabot> VALUES!!
18:24:59 <shapr> Excitement!
18:25:31 <Saizan> SENSITIVE COIN COLLECTORS?
18:27:09 <Olathe> Not only that, but DEFENSELESS, too.
18:40:28 <mudge> I love that bot
18:40:49 <mudge>  @yow!
18:40:55 <mudge> @yow!
18:40:55 <lambdabot> Here we are in America ... when do we collect unemployment?
18:42:00 <mudge> hey what if we wrote an IRC bot that we coudl write code with, and then we wrote code in this IRC channel together via the bot which was the interpreter or something
18:42:22 <shapr> mudge: That would be very cool.
18:42:24 <mudge> and I don't mean just little one-liner programs, but real programs
18:42:34 <shapr> I've been thinking about something like that, but I wanted to do it with Frag.
18:43:14 <shapr> mudge: How would it work?
18:43:26 <zmike> can't you do that with lambdabot?  It remembers definitions, right?
18:44:13 <sjanssen> @let foo = 14
18:44:14 <mudge> i don't know,  could we do that?
18:44:16 <sjanssen> > foo
18:44:22 <lambdabot> Defined.
18:44:22 <lambdabot>  14
18:44:28 <byorgey> zmike: sort of, but you can't go back and edit, or easily see what others have written
18:44:44 <Igloo> You really don't want IRC for that
18:45:02 <shapr> One thing close to that I thought of was having a lambdabot > prompt embedded in hpaste pages.
18:45:09 <shapr> With the hpaste'd file loaded.
18:45:11 <byorgey> IRC would be a strange interface.  it'd have to be like a line-editing program. =P
18:45:25 <johnnowak> LAMBDABOT! LAMBDABOT IS THE STANDARD!
18:45:31 <byorgey> shapr: that would be really nifty
18:46:00 <shapr> One big problem would be how to combine safety with usability. How do you develop IO-using code without letting someone crack the server?
18:46:02 <mudge> sharp:  that sounds like a really good idea
18:46:09 <Saizan> hslime?
18:46:24 <zmike> sandbox?
18:47:09 <shapr> zmike: user-mode linux with instances that go away at the end of the session? And code stored in a repo somewhere?
18:47:19 <shapr> Hm, that might really work.
18:47:42 <zmike> chroot and firewalls is probably strong enough
18:48:27 <shapr> Heh, I have an irc log of ddarius interacting with dons first version of eval...  probably isn't enough :-)
18:49:02 <shapr> ddarius got lambdabot to spit out ~/.bashrc iirc, and /etc/passwd was left as an exercise :-)
18:49:03 <zmike> you couldn't prevent somebody from turning your bot into an IRC spam bot or something though
18:50:08 <shapr> One big obstacle is that collaborative editing is only really supported by SubEthaEdit.
18:50:23 <shapr> I'd want to be able to edit all the files in emacs...
18:50:41 <shapr> Hm, tramp would let me edit via ssh/scp.
18:50:57 <shapr> Or the shared environment could have darcs repo you could push to.
18:50:58 <zmike> you could have some protocol to be able to send/recv individual declarations
18:51:15 <zmike> yeah, I guess at that point it's equivalent to just doing that
18:51:24 <shapr> libobby
18:51:34 <shapr> @go gobby collaborative
18:51:39 <lambdabot> http://gobby.0x539.de/
18:51:39 <lambdabot> Title: obby - Trac
18:51:40 <Adamant> my understanding is that SubEthaEdit pretty much punts all security issues by saying the local subnet must be trusted
18:53:15 <shapr> For the hpaste extension, we could embed lambdabot's 'ghci' with http://a-i-studio.com/cmd/
18:54:03 <shapr> Still, full collaborative editing on a UML instance would be the most fun.
18:54:12 <shapr> hiya slava
18:55:54 <shapr> mudge: For the Haskell in Quake3 idea, I was thinking of trying to hack Frag into OpenCroquet: http://www.opencroquet.org/index.php/Screenshots
18:55:56 <lambdabot> Title: Screenshots - Croquet Consortium
19:11:45 <dylan> hmm, my gtk2hs/glade hello world doesn't work
19:12:44 <dylan> e.g. following the tutorial on the gtk2hs website results in an executable that does nothing interesting.
19:26:40 <int-e> dylan: hmm. I tried and it works for me.
19:28:57 <int-e> dylan: does the program do anything? print an error message maybe?
19:30:19 <shapr> Ya know, it's confusing to have a new Haskell guy named Ian Duncan, since I immediately think he's both Igloo and dcoutts.
19:30:53 <Igloo> :-)
19:31:49 <ddarius> shapr: I thought that too.
19:32:27 <lament> and he isn't?
19:33:32 <mudge> shapr: cool
19:34:33 <mudge> you know what I"m tired of hearing  "everything is an object"
19:34:44 <mudge> I want a language where "everything is not an object"
19:35:25 <int-e> try pure lambda calculus
19:35:31 <DukeDave> Hm, I suppose you could say Haskell, where everything is a program
19:36:45 <shapr> mudge: heh
19:38:15 <mudge> shapr: how did you get into programming?
19:38:34 <johnnowak> mudge: what about a purely functional language with objects? although instead of writing foo.bar() or [foo bar], we'll write bar foo. and instead of methods, we'll have something called, oh, maybe type classes.
19:39:27 <joed> Heh
19:40:19 <Saizan> where's subtyping eh?
19:40:27 <johnnowak> we won't have that.
19:40:41 <mudge> sounds a lot better, as long as I don't hear and read "everythings an object"
19:41:25 <johnnowak> i'm glad you're evaluating things on their technical merits rather than how annoying their proponents are
19:41:25 <SamB> no, we'll conveniently replace that term with "value"
19:41:44 <DukeDave> Before I embark on what I'm about to can I request a sanity check on some code I'm working on..
19:42:03 <shapr> mudge: First time programming was on a Sinclair Spetrum when I was eleven years old or so. But I never meant to do it professionally, that was an accident.
19:42:08 <shapr> mudge: What about you?
19:42:25 <shapr> I actually meant to be a visual artist.
19:42:39 <SamB> was your art pleasing?
19:42:43 <ddarius> shapr: Luckily you dodged that trap.
19:42:46 <DukeDave> I have a robot controller which works by reading in lines off a pipe computing a new motion vector & sending it back down another pipe to the robot
19:42:48 <shapr> For better or for worse, I'm really quite bad at visual art, no matter how much time I spent trying.
19:43:06 <SamB> ah. yes. that does tend to make it difficult to get work ;-)
19:43:18 <ddarius> shapr: What media were you interested in?
19:43:25 <shapr> The best thing anyone ever said about my art was "schizophrenic".
19:43:33 <DukeDave> I also have some HOpenGL code for visualising what's going on and I'd like to put them together
19:43:35 <SamB> that sounds pretty bad
19:43:47 <DukeDave> Am I likely to need Control.Concurrent ?
19:43:47 <ddarius> SamB: Not if that's what you're going for.
19:43:47 <mudge> shapr: When I was younger I saw the big kids doing stuff on the computer a lot,  and then I started getting into computers,     I was supposed to be a fiction writer though
19:43:56 <shapr> SamB: And that was my art teacher, who liked me...
19:44:24 <shapr> mudge: When was that? What computer(s)?
19:44:29 <SamB> mudge: would you believe that you still could be?
19:44:54 <ddarius> Heinlein became an author by accident.
19:44:56 <shapr> I did BASIC on that Sinclair Spectrum 25 years ago :-)
19:44:56 <SamB> apparantly a fair amount of geek types do SF/fantasy writing too
19:45:06 <SamB> I mean people in geek-type jobs
19:45:17 <shapr> I do enjoy writing SF, but I'm not very good at that either.
19:45:22 <SamB> you know, like science, engineering, programming, video game making...
19:46:11 <mudge> shapr:  I don't remember,  I was like 12 or 13 or 11 or something,   on computers that only ran DOS and Windows 3.1    I learned programming from Qbasic
19:46:33 <mudge> SamB: yea, I do. I plan to write some fiction books once I get rich writing software
19:46:58 <SamB> mudge: rich?
19:48:32 <dylan> int-e: hrm, no. Restarting X seemed to fix it.
19:48:43 <int-e> oh weird
19:49:04 * dylan wonders if xmonad is to blame.
19:49:11 <dylan> oh well, it's not reproducible.
19:49:58 <mudge> Samb: yea, rich
19:50:29 <mudge> SamB: I"m not programming for the money though,  I love programming and follow a programming path,   but I decided I'm still going to get rich with software too
19:50:55 <lament> "follow a programming path"?
19:51:34 <johnnowak> he's assigned types to his kitchen applicances
19:51:47 <ddarius_> shapr: I saw that story start you(/we) started a long long time ago in your scannedinavian directory.
19:51:48 <SamB> man that sounds HARD
19:53:24 <shapr> ddarius: Yeah, but it needs serious work.
19:54:16 * glguy decides that he ought to get rich too
19:54:22 <glguy> who's with me?
19:54:39 * ddarius could easily be happy without being rich.
19:54:45 <ddarius> I would like to be well-off though.
19:54:58 <SamB> I believe that being rich would be a bad idea for me
19:55:12 <lament> SamB: give me all your money.
19:55:18 <johnnowak> The good thing about being rich is that it's rather easy to solve that problem.
19:55:41 <mudge> lament: let's split SamB's money
19:55:52 <mudge> yea, I need money to live on while I write books that might never sell
19:55:54 <SamB> that would work great if I had money
19:55:56 <lament> mudge: okay. Seems we're the only two people in the channel who want to get rich :)
19:56:09 <monochrom> I could use some money too :)
19:57:33 <SamB> I also feel that getting rich would likely involve a lot of things that would not be fun. more than usual.
19:57:37 <mudge> lament,  monochrom,  hmm.... seems like we should do something about that
19:57:56 <mudge> haskell money group
19:58:09 <ddarius> Haskell Pyramid Scheme
19:58:13 <SamB> I would love to have some money
19:58:13 <mudge> haha
19:58:14 <mudge> yea
19:58:27 <SamB> ddarius: no way
19:58:32 <SamB> it'll get OOM killed
19:59:18 <mudge> who's OOM?
19:59:32 <int-e> out of memory
19:59:32 <monochrom> I teach you monads and you give me money.
19:59:39 <mudge> reminds me,  I have a website where the money currency is called "lambda money"
20:00:06 <lament> monochrom: OR ELSE.
20:00:15 <monochrom> You can then teach monads to other people and earn more money.
20:00:19 <mudge> http://www.nickmudge.info/?post=35
20:00:23 <lambdabot> Title: Lambda Money
20:00:33 <lament> learn monads >>= teach monads
20:00:49 <lament> >> (???) >> profit
20:01:06 <mudge> what the heck does the sequencing operator >>==   do?
20:01:10 <mudge> i don't understand it
20:01:14 <lament> :t (???)
20:01:16 <lambdabot> Not in scope: `???'
20:01:28 <lament> :t (>>==)
20:01:29 <lambdabot> Not in scope: `>>=='
20:01:33 <shapr> mudge: Depends on the definition of the monad, have you seen http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html ?
20:01:36 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
20:01:41 <lament> mudge: do you mean >>= ?
20:01:56 <desp> @pl setOptBool h_ o_ = setOptLong h_ o_ . fromBool
20:01:56 <lambdabot> setOptBool = flip flip fromBool . ((.) .) . setOptLong
20:02:01 <desp> flip flop
20:02:23 <monochrom> What is that saying again? Give your friend money, and you feed him for a day. Teach your friend monads, and you feed him for life. :)
20:02:45 <desp> monochrom: Set the man on fire, and you will keep him warm for the rest of his life.
20:03:07 <mudge> lament: I've seen it but I havent' read it
20:03:14 <mudge> I guess I should check it out
20:03:18 <monochrom> Teach your friend Java, and you feed him for a day. Teach him Haskell, and you starve him for life. XD
20:03:19 <lament> Teach your friend monads, and he'll spend the rest of his life locked up in an asylum
20:03:33 <mudge> lament: why?
20:03:42 <mudge> are monads crazy?
20:03:47 <lament> mudge: oh, just wait till you learn what >>= does, it will all become clear
20:03:55 <mudge> oh, thanks that's helpful
20:04:04 <monochrom> haha
20:04:10 <mudge> I'm sure I will learn and understand in the not too distant future
20:04:33 <lament> it's prudent to put on a straightjacket _before_ reading the tutorials.
20:05:04 <shapr> I think monads let me out of the imperative asylum.
20:05:41 <mudge> oh good,  I want to get out of imperativity
20:05:57 <mudge> imperativitiness
20:06:02 <lament> imperativism?
20:06:06 <sorear> If insanity was good enough for Gödel, it's good enough for me!
20:06:08 <lament> empire?
20:06:35 <lament> sorear: godel, cantor, van gogh, shapr... all the great people were lunatics
20:06:45 <mudge> later gators
20:07:59 <monochrom> You forgot Boltzmann and Oppenheimer there.
20:08:39 <desp> Pauling?
20:08:40 <DukeDave> Lol, I wonder if people will look back, the age of the 'handle', where all the great issue were resolved not in the forums of great academies, but in 'channels' on 'IRC' :)
20:09:14 <DukeDave> The shaprians of #haskell..
20:09:20 <samreid> by people wearing red capes...
20:09:57 <allbery_b> _True Names_?
20:11:56 <desp> allbery_b: great story.
20:13:12 <shapr> wah?
20:13:31 <desp> shapr: Vernor Vinge
20:13:52 <shapr> Yeah, I'm just trying to think of myself as an brilliantly insane history affecting person.
20:14:07 <shapr> I have a copy of the Vernor Vinge book.
20:14:10 <allbery_b> you're a haskell hacker, no?
20:14:12 <desp> didn't you found this channel?
20:14:16 <shapr> Yeah
20:14:24 <desp> there you go ;)
20:14:35 <shapr> Heh, ok
20:15:11 <SamB> yeah, I'm sure it's really helped the community a lot
20:17:14 <DukeDave> I'd have been a lot less likely to stick with it were it not for people in here & cafe
20:17:25 <DukeDave> Just wish I could give back!
20:18:13 <ricky_clarkson> I remember shapr being a #java regular. ;)
20:18:34 <shapr> That's been a few years.
20:18:49 <ricky_clarkson> Over a year since I've been too.
20:44:24 * ddarius has found a decent distorted rack.
20:44:46 <Olathe> yow on lambdabot has some things in German for some reason.
20:48:02 * shapr throws frustration lambdas
20:49:20 * stepcut ducks
20:49:28 <stepcut> watch it, bubby!
20:50:02 <shapr> Man, I really want cabal-install to be able to rebuild/reinstall packages from darcs repos when their deps have changed.
20:50:04 * shapr grumbles
20:50:41 * shapr throws more frustration lambas (but carefully not in the direction of stepcut)
20:51:18 <stepcut> shapr: for Debian ?
20:51:45 <shapr> Nah, just cabal packages.
20:52:16 <shapr> It would especially nice if I could hand cabal-install a list of directories, and it would pull out all the package deps.
20:52:45 <stepcut> shapr: hrm, I see
20:53:19 <mudge> in programming,  what does ffi mean?
20:53:20 <shapr> HAppS got cut into a bunch of different repos, with various deps among them. When new changes are pulled, I'd like for cabal-install to rebuild all packages that depend on those changes.
20:53:25 <shapr> foreign function interface
20:53:35 <mudge> what the heck is that?
20:53:46 <shapr> mudge: It's how Haskell interfaces with C
20:54:20 <mudge> oh,  so that's how xmonad interfaces with X11 for example
20:54:26 <stepcut> mudge: yes
20:54:29 <Nafai> shapr: Can cabal download/compile/install all dependencies for a given project?
20:54:39 <Nafai> shapr: Specific versions at that?
20:54:46 <shapr> Nafai: Yup
20:54:46 <mudge> if a haskell program is going to interact with other C programs it will use a ffi
20:54:49 <mudge> cool, thanks
20:54:50 <stepcut> mudge: in theory, the FFI can bind to lots of different languages, but C is the only one that is really supported right now
20:54:57 <alexj> shapr: someone could also patch darcs to check all the subdirectories of the current directory and pull in all the directories that have _darcs in them.
20:55:08 <mudge> ok, thank
20:55:09 <mudge> s
20:55:22 <shapr> alexj: Yeah, subrepos have been discussed a few times, but I don't know if anything ever resulted.
20:55:25 <stepcut> mudge: you can also use the FFI to export Haskell functions that can be called from C programs
20:55:47 <Nafai> shapr: After using maven at work (a pain in and of itself) I'm very taken with the idea that you should be able to run one command and do a full build, including grabbing any external dependencies
20:56:09 <mudge> stepcut: oh cool thanks
20:56:17 <mudge> is ffi something specific to haskell?
20:56:51 <Nafai> mudge: It's a general concept, Common Lisp implementations, for example, have FFIs
20:57:08 <mudge> Nafai: ah, okay,  makes sense
21:04:23 <bos> @pl \f (a,b) -> (f a, f b)
21:04:24 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
21:04:31 <bos> ew
21:04:55 <ddarius> Hoping for join (***)
21:04:58 <ddarius> :t join (***)
21:04:59 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
21:05:30 <bos> > join (***) (1+) (2,3)
21:05:31 <lambdabot>  (3,4)
21:05:52 <bos> yes, i knew there was some line noise in Control.Arrow that would do the trick, if only I could remember which
21:06:20 <jbauman> :t (***)
21:06:22 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
21:08:03 <conal> ?ty uncurry (***)
21:08:05 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
21:09:10 <conal> ?let (***#) = uncurry (***)
21:09:11 <lambdabot> <local>:2:17:     Ambiguous type variable `a' in the constraint:       `Arrow...
21:09:36 <slava_> ?ty (+)
21:09:39 <lambdabot> forall a. (Num a) => a -> a -> a
21:09:46 <ddarius> :t uncurry (&&&)
21:09:49 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => (a b c, a b c') -> a b (c, c')
21:10:23 <ddarius> One way of the isomorphism of representation of the product functor.
21:10:32 <Royal_Son> Hello, I'm tryng to display multiple lines from a file. So far I can only display the first: http://hpaste.org/2394
21:12:22 <Royal_Son> the only way it works atm is if i type listAll (head listDVD)
21:13:40 <conal> Royal_Son: listAll doesn't use its argument
21:14:29 <Royal_Son> yeah cos I've tried to use it's argument in the past but i got loaded with errors
21:16:25 <conal> Royal_Son: http://hpaste.org/2394#a1  (hpaste bot not working??)
21:16:34 <ddarius> !hpaste
21:16:42 <ddarius> @seen hpaste
21:16:43 <lambdabot> Last time I saw hpaste was when I left ##logic, #darcs, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #oasis, #parrot, #perl6, #scala, #
21:16:43 <lambdabot> scannedinavian, #unicycling and #xmonad 6d 23h 18m 44s ago, and .
21:20:07 <Royal_Son> conal : ERROR - Type error in application
21:20:08 <Royal_Son> *** Expression     : listAll2 listDVD
21:20:08 <Royal_Son> *** Term           : listDVD
21:20:08 <Royal_Son> *** Type           : [DVD]
21:20:08 <Royal_Son> *** Does not match : ([Char],[Char],[Char],Integer)
21:21:43 <conal> Royal_Son: listAll2?  Please paste the new program version.  looks like you're using [DVD] where a DVD is expected
21:22:30 <conal> ?ty mapM_
21:22:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
21:22:46 <sorear> !paste
21:22:59 <conal> Royal_Son: you can do something like mapM_ listAll listDVD
21:23:28 <sorear> @seen shapr
21:23:28 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 28m 6s ago.
21:23:45 <ddarius> @seen glguy
21:23:45 <lambdabot> glguy is in #haskell. I last heard glguy speak 1h 29m 23s ago.
21:24:17 <sorear> ddarius: I'm running hpaste (the process) now, even though glguy still maintains hpaste (the program)
21:24:31 <DukeDave> Royal_Son: See if this helps http://hpaste.org/2394#a2
21:25:00 <ddarius> sorear: What do you know about signal processing?
21:25:51 <Royal_Son> thanks DukeDave !
21:26:01 <sorear> ddarius: Oh, sorry.  Thought that was for the hpaste issue.
21:26:35 <shapr> sorear: You called?
21:27:08 <sorear> shapr: The authenticity of host 'kakapo.scannedinavian.com (65.254.53.221)' can't be established.
21:27:50 <shapr> Did the ssh key change?
21:28:25 <sorear> I don't know, I didn't memorize it the first time :)
21:28:43 <DukeDave> Royal_Son: No problem, give me a shout if you need any other help
21:29:20 <conal> ?karma+ DukeDave
21:29:20 <lambdabot> DukeDave's karma raised to 1.
21:29:39 <DukeDave> Coo, my first karma point :D
21:29:45 <conal> :)
21:29:51 * DukeDave hugs conal
21:30:05 * conal wriggles with glee
21:32:47 <DukeDave> Would anyone like to help me diagnose a problem I'm getting with forkIO, my binary is bailing out with  LOCK SET!
21:33:51 <shapr> sorear: I didn't get that, and I haven't changed my known-hosts, so ... I dunno.
21:34:06 <sorear> shapr: the lines in my known_hosts look like they've been uuencoded or something, how do I know whether it changed?
21:34:10 <DukeDave> Gr, all this IO troubles me
21:35:19 <shapr> sorear: Try ssh -v and see if that gives any more info?
21:37:27 <sorear> shapr: hmm.  it shows not being able to find the key.  when I ssh scannedinavian.com, it succeeds - but goes to keyboard-interactive, and I know I don't have a password
21:38:14 <dons> ?yow
21:38:14 <lambdabot> Oh my GOD -- the SUN just fell into YANKEE STADIUM!!
21:39:41 <Royal_Son> DukeDave : It seems that haskell doesn't like it when i use :   show (someInt * someFloat)
21:39:59 <sorear> shapr: oh, haha, nevermind
21:40:04 <SamB> Royal_Son: try adding fromIntegral in front of someInt
21:40:06 <SamB> i.e.
21:40:13 <sorear> stefan@stefans:/usr/src/hugs98-98.200503.08$ ssh scannedinavian.com <- doesn't work
21:40:16 <SamB> show (fromIntegral someInt * someFloat)
21:40:25 <sorear> stefan@stefans:/usr/src/hugs98-98.200503.08$ ssh sorear@scannedinavian.com <- works
21:40:33 <Royal_Son> oh
21:40:33 <shapr> sorear: That makes sense :-)
21:40:44 <Royal_Son> thanks :)
21:40:55 <Royal_Son> wow, haskell is such a totally different world for me
21:41:16 <sorear> anyways, back to work...
21:41:59 <OceanSpray> OMGWTFBBQ YANKEE STDIUM?
21:42:50 * shapr seens OceanSpray channeling the spirit of Zippy the Pinhead
21:43:48 <sorear> !paste
21:43:48 <hpaste> Haskell paste bin: http://hpaste.org/
21:44:43 <DukeDave> Royal_Son: How long have you been going so far?
21:58:28 <hpaste> test
22:00:59 <desp> hpaste, url
22:00:59 <hpaste> Haskell paste bin: http://hpaste.org/
22:03:51 <OceanSpray> is hpaste going under maintenance or something?
22:05:16 <iratsu> what is a good source to learn haskell?
22:05:55 <sorear> yaht is often recommended
22:05:56 <dons> iratsu: the book "Programming in Haskell" is pretty good. as are the online tutorials at the wikibook
22:05:59 <dons> ?where yaht-web
22:05:59 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
22:06:23 <iratsu> thanks
22:06:34 <dons> lots of tutorials are on haskell.org too
22:06:57 <monochrom> http://en.wikibooks.org/wiki/Haskell
22:06:59 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
22:09:44 <glguy> !say OceanSpray: no, it just got disconnected from IRC
22:09:44 <hpaste> OceanSpray: no, it just got disconnected from IRC
22:10:34 <mlh_> iratsu: www.realworldhaskell.org should be good
22:10:39 <mlh_> not here yet though
22:15:07 <shapr> dons: How long till you reach this continent?
22:15:20 <dons> 7 days
22:15:22 <dons> :D
22:15:22 <shapr> w00!
22:15:25 <shapr> Excitement!
22:15:28 <dons> time zone happiness!
22:15:30 <midfield> question: is it possible to profile STM programs?
22:15:50 <dons> midfield: you mean, with the threaded runtime?
22:16:05 <dons> sorear: do you recall if there was some issue with the rts _prof _threaded way?
22:16:09 <shapr> dons: Yeah, you'll be in the same timezone, but probably too busy for #haskell for awhile :-)
22:16:30 <dons> shapr: yeah, we'll see I guess. i note syntaxninja , andygill et al are mostly online at night
22:16:34 <dons> so likely that'll be the situation
22:16:38 <shapr> Yeah
22:16:42 <midfield> dons: actually i don't care which runtime, single-threaded is enough for now.
22:16:48 <sorear> dons: don't recall, I think there was
22:16:50 <sjanssen> midfield: yes, STM should work fine with profiling
22:16:52 <dons> midfield: then go for it. should be fine.
22:17:00 <sorear> no
22:17:01 <sorear> is
22:17:03 <sorear> ghc-6.7.20070712: combination not supported: Threaded/Profiling
22:17:08 <dons> ah , in the head?
22:17:19 <dons> since it works fine in 6.6.x
22:17:22 <dons> (e.g. hmp3)
22:17:23 <sorear> ghc-6.6.1: combination not supported: Threaded/Profiling
22:17:37 <dons> oh, just missing the rts built that way?
22:17:41 <dons> or not at all?
22:18:17 <dons> oh, i note a cheap version of "programming in haskell" available as an ebook now
22:18:26 <dons> http://www.cs.nott.ac.uk/~gmh/book.html ~$36 or so?
22:18:28 <sorear> amusingly, 6.4.2 allows it
22:18:29 <lambdabot> Title: Programming in Haskell
22:18:36 <dons> sorear: ah. so it was broken
22:18:52 <midfield> ok, now for a more simple question: what's the recommended way to profile a library?  other than adding a "main" to the code...
22:18:58 <sjanssen> sorear: 6.4's threaded runtime isn't quite the same IIRC
22:19:07 <dons> midfield: compile the library using cabal's profiling settings
22:19:10 <glguy> Graham Hutton (the author of that book) has been sitting next to me at work for the last few weeks
22:19:12 <midfield> whoops i see, just operate inside the module
22:19:13 <dons> runhaskell Setup.lhs configure -p
22:19:13 <joed> dons the paperback.
22:19:26 <sjanssen> 6.6 was the first release to actually execute Haskell in parallel
22:19:30 <glguy> I have a copy of that book on my desk too :)
22:20:04 <dons> ?users
22:20:05 <lambdabot> Maximum users seen in #haskell: 385, currently: 354 (91.9%), active: 14 (4.0%)
22:20:05 <sorear> sjanssen: oh, so 6.4.x just gave you working safe calls?
22:20:18 <dons> sorear: he's talking about the smp rts, I think.
22:20:35 <dons> so it was the first to do haskell threads on multiple cores
22:20:43 <dons> other than researchy stuff from last decade
22:21:00 <sjanssen> sorear: I can't remember what -threaded meant in 6.4
22:21:04 <dons> shapr: want to get one of these $400 64 core chips that were mentioned earlier this week?
22:21:09 <dons> "tilerara" or something?
22:21:15 <sorear> tilera
22:21:23 <sjanssen> $400 . . . only available in 1,000 lots :)
22:21:27 <desp> is it possible to make a record an instance of Storable?
22:21:27 <dons> heh
22:21:32 <dons> desp: sure.
22:21:42 <dons> desp: define a C struct to pack it to
22:21:44 <sorear> sjanssen: I think that's still less than what serenity cost ;)
22:21:51 <dons> just a bit.
22:21:56 <dons> but its a bit faster, i suspect
22:22:56 <sjanssen> ghc 6.8 really really needs to come out
22:23:07 <sjanssen> I want to play with ndp and associated types very badly
22:23:26 <dons> i think it should be done before icfp. that's usually the aim
22:23:29 <glguy> sjanssen: its supposed to come out next month, no?
22:23:36 <sjanssen> glguy: yeah, something like that
22:25:12 <dons> shapr: any theories why 40 people appeared over the weekend in the channel? (up to nearly 420 from 380)
22:25:42 <dons> or anyone else with a theory?
22:25:46 <dons> delayed oscon effect?
22:25:49 <sorear> dons: how many impressionable people read news.ycombinator.com?
22:25:54 <dons> hmm.
22:26:02 <sorear> as opposed to hardened lispheads
22:26:02 <glguy> classes just started/
22:26:36 <glguy> ?sars
22:26:36 <lambdabot> Maybe you meant: arr part src users yarr
22:26:40 <glguy> ?sers
22:26:40 <lambdabot> Maximum users seen in #haskell: 385, currently: 354 (91.9%), active: 13 (3.7%)
22:27:03 <glguy> ?arr
22:27:03 <lambdabot> Shiver me timbers!
22:27:09 <glguy> ?yow
22:27:09 <lambdabot> Here we are in America ... when do we collect unemployment?
22:27:23 * stepcut is hoping associated types will be useful for making HaskellDB better
22:27:25 <midfield> ah ok, here's my real question: i have enabled profiling in the library (--enable-library-profiling) and profiling on the test (--enable-library + executable profiling) but the output only gives costs internal to the Main module.  how do i get reporting inside the library i wrote?
22:27:44 <dons> midfield: ah, you might need to add -prof -auto-all to the library .cabal file
22:27:55 <dons> ghc-prof-options:   -prof -auto-all
22:28:05 <dons> in the .cabal file for the library before you build it with profiling
22:28:42 <midfield> ah ok will try
22:37:47 <dibblego> is there an approximation of the subset sum problem that runs in P?
22:41:02 <shapr> dons: I'm guessing network effects.
22:41:19 <shapr> dons: And yeah, ghc-smp on a $400 64-core would be very much fun.
22:41:34 <midfield> dons: thanks.
22:42:13 <profmakx> dibblego, there should be, yes
22:42:15 <midfield> it looks like the STM code is working properly, but is just slow.  incrementing a TVar Int is slow!  120,000 increments takes 12 seconds!
22:42:22 <midfield> unless i'm doing something wrong...
22:42:32 <shapr> @seen dcoutts
22:42:32 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts last spoke.
22:42:33 <dibblego> profmakx, I have to go now, but I'd love to find it!
22:42:54 <dons> midfield: hmm, sounds a bit off. using -O2 ?
22:43:02 <dons> sometimes people forget to turn on optimisations
22:43:13 <midfield> dons: yes, in both ghc-options and ghc-prof-options
22:43:18 <liyang> Where would one hypothetically get access to a 64-core machine with a working copy of GHC?
22:43:33 * liyang has been writing a sudoku solver. This is so sad. :(
22:43:35 <dons> TVars should be around 1-2x the speed of MVar updates. you might need to strictify it though
22:43:57 <dons> midfield: see for an MVar example, http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=ghc&id=0
22:43:58 <shapr> liyang: Probably we'd form a #haskell consortium, contribute our spare cash, and buy one of those Tilera PCI cards.
22:43:58 <profmakx> liyang, university perhaps?
22:44:00 <lambdabot> Title: chameneos Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comput ..., http://tinyurl.com/28po6l
22:44:09 <dons> midfield: this kind of thing, putMVar wakerv $! colour
22:44:14 <dons> you might need strict updates.
22:44:22 <shapr> liyang: And we'd ship it to dons so he could install it in community.haskell.org
22:44:33 <liyang> shapr: <grin>
22:44:35 <dons> midfield: also, try comparing a microbenchmark against MVar and IORef and Ptr writes
22:44:40 <dons> that should give you an idea
22:44:57 <liyang> profmakx: I'm in the foundations of programming group. Our `hardware' consists of whiteboard and markers. :-/
22:45:11 * sorear wonders how long it will be before this kind of chip can be obtained in bulk from microcontroller foundries
22:45:13 <dons> liyang: hmm. the largest machines i know of running ghc are a 16 core box, and a 40 cpu sun server.
22:45:14 <profmakx> hehm liyang, we got TFT-Panels yesterday!
22:45:19 <dons> but its possible some large uni has them?
22:45:20 <shapr> Though that brings me to a question... how does the GHC RTS call out to something like nvidia cuda?
22:45:32 <dons> shapr: you can do ffi calls into cuda, yeah
22:45:32 <profmakx> we are the computational group theory department
22:45:41 <profmakx> working on machines that are 10 years old -.-
22:45:41 <dons> shapr: just call a cude .o file procedure
22:46:02 <liyang> dons: I was wondering how efficient launching a thread for each cell in a sudoku grid would be...
22:46:13 <profmakx> liyang: our university has a high performance computing department where i can get my hands on multicore-computers
22:46:17 <shapr> I downloaded CUDA recently, and discovered that you have to start X to get the nvidia kernel module, but you must also exit X because computations that take more than five seconds timeout.
22:46:21 <liyang> (it works so far for simple non-backtracking puzzles.)
22:46:24 <dons> liyang: each cell sounds feasible. threads are super-light
22:46:26 <midfield> dons:i have strictness anotations on the datatype, do i need it on the functions to?  (i'm trying to create a concurrent Map, liberally borrowing the code from Data.Map.)
22:46:44 <dons> midfield: oh, you've seen the various threads about STM-based, TVar-based trees and maps then?
22:46:59 <midfield> dons: ah fark well i guess i should look better!
22:46:59 <dons> midfield: i was thinking you'd need to force the write, putTVar x $! foo, or whatever the operation is
22:47:22 <dons> midfield: there was a thread just this week from ChrisK and Tom Conway on haskell-cafe@
22:49:02 <midfield> dons: yes i was the originator of that thread :P
22:50:06 <dons> ah good!
22:56:47 <Royal_Son> Can someone please tell me if there's a haskell command like getElementAt 4 which would return ["23"] if I have a list ["1","15,"2","24","24","8"]
22:57:05 <dons> > ["1","15,"2","24","24","8"] !! 4
22:57:05 <lambdabot>  Improperly terminated string
22:57:08 <Royal_Son> oops i meant ["24"] not ["23"]
22:57:18 <dons> > "haskell" !! 4
22:57:20 <lambdabot>  'e'
22:57:24 <Royal_Son> aha
22:57:28 <Royal_Son> thankyou dons
22:57:28 <shapr> > ["1","15","2","24","24","8"] !! 4
22:57:29 <lambdabot>  "24"
22:57:30 <dons> > ["haskell","is","fun"] !! 2
22:57:31 <lambdabot>  "fun"
22:57:35 <dons> :t (!!)
22:57:37 <lambdabot> forall a. [a] -> Int -> a
22:57:41 <shapr> :t (??)
22:57:42 <dons> ?hoogle [a] -> Int -> a
22:57:43 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
22:57:44 <lambdabot> Not in scope: `??'
22:58:09 <dons> Royal_Son: yeah, you got the behaviour. the trick is to work out the type for the function, then query hoogle for it
22:58:32 <dons> so "getElementAt 4 would return ["23"] if I have a list" == the type :: Int -> [a] -> a
22:58:38 <dons> ?hoogle Int -> [a] -> a
22:58:39 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
22:58:41 <dons> finds it
22:58:48 <Royal_Son> thankyou
22:59:03 <dons> lesson 1 in "thinking in types" :)
22:59:32 * dons home. bbl
23:00:16 <Royal_Son> wow this is cool
23:02:22 <profmakx> welcome to haskell world, Royal_Son
23:07:42 <Royal_Son> hehe thanks :)
23:11:54 <dolio> So, it would appear that two types of OO advocates believe it's good due to fundamental weaknesses in strongly-type functional programming. :)
23:12:33 <dolio> Or, something like that.
23:15:08 <hpaste>  Royal_Son pasted "Ordering a list of tuples by comparing first element in each tuple" at http://hpaste.org/2395
23:17:19 <glguy> Royal_Son: are you supposed to implement the sort yourself?
23:17:54 <Royal_Son> glguy : Yeah I was trying to do that.
23:18:20 <glguy> Royal_Son: compareList xs  rather than compareList [(a,b,c,d)]
23:18:27 <slava> glguy: you pinged me the other day?
23:18:29 <glguy> (for starters)
23:18:35 <Royal_Son> only ordering the occurances of tuples (not the values within them) according to which tuples have the lowest 'a' value
23:18:41 <glguy> slava: yeah, I had a Factor question that I ended up solving myself
23:18:54 <midfield> dons: ok i'm confused.  in the microbenchmark, incTInt x 120,000 takes 0.10 seconds.  120,000 calls to it in the library code takes 12 seconds.
23:19:20 <Royal_Son> glguy : I used a,b,c,d cos i wanna refer to the first element 'a' in each tuple to perform the comparison
23:19:48 <glguy> Royal_Son: f [(a,b)] = ... mean, f only works on lists of a single element
23:19:52 <glguy> means*
23:20:42 <Royal_Son> ok now i'm confused
23:20:48 <Royal_Son> %S
23:21:24 <glguy> > let f [x] = "single element" ; f xs = "otherwise" in f [6]
23:21:25 <lambdabot>  "single element"
23:21:28 <glguy> > let f [x] = "single element" ; f xs = "otherwise" in f [2,3]
23:21:29 <lambdabot>  "otherwise"
23:21:34 <glguy> does that help?
23:22:20 <dolio> > 120000 / 10 / 1000
23:22:21 <lambdabot>  12.0
23:22:27 <Royal_Son> umm to be honest, no. I am not used to doing it that way. but I think my brain is getting a bit fried at the moment so it's probably a good idea for me to take a break..
23:22:31 <dolio> midfield: You sure it isn't 0.10 milliseconds?
23:23:50 <midfield> dolio: well it's just a microbenchmarks so maybe startup time is a factor, but it says 0.10 sec
23:25:52 <glguy> Royal_Son: You sure you want to take a break? we can work through this
23:27:16 <Royal_Son> glguy: ok but is it possible if we could perhaps approach it in the way i'm trying cos otherwise i'll really be losT
23:27:52 <glguy> Royal_Son: Ok, do you know what this means? compareList ( (a,b,c,d) : rest ) = ...
23:28:37 <glguy> and to be clear, your goal is to take a list of 4-tuples, and sort them by the first element of the tuple?
23:28:37 <Royal_Son> well it seems like you have a tuple of 4 elements (the header i imagine) being compared with a tail
23:28:46 <glguy> Royal_Son: right
23:28:49 <Royal_Son> yes
23:29:25 <glguy> ok, so is what I just showed you an acceptable approach?
23:29:35 <glguy> so far at leawst
23:29:37 <glguy> least*
23:29:56 <glguy> what I want to do is use that as the pivot
23:29:58 <Royal_Son> it doesn't look too bad, but is compareList an inbuilt function or do i provide the implementation for that?
23:30:05 <Royal_Son> ok
23:30:10 <glguy> there is a built in function to do this sort of thing
23:30:15 <Royal_Son> I see
23:30:17 <glguy> but lets work it out like you started
23:30:20 <Royal_Son> ok
23:30:29 <glguy> so we'll use the first element of the list as the pivot
23:30:38 <Royal_Son> (a,b,c,d)
23:30:43 <Royal_Son> a
23:30:48 <Royal_Son> oops
23:30:49 <glguy> and we'll want to do:   list_of_less_thans ++ [ pivot ] ++ list_of_greater_thans
23:30:53 <Royal_Son> i'm confusing myself
23:31:03 <Royal_Son> ok that makes sense
23:31:22 <Royal_Son> so u generate two lists and merge them together at the end ?
23:31:27 <glguy> yes
23:31:30 <Royal_Son> ok
23:31:34 <glguy> and I know you know how  to filter a list
23:31:39 <glguy> because you did it yesterday
23:31:42 <glguy> using list comprehensions
23:32:22 <Royal_Son> [x|x<-(a,b,c,d),x<someNumber]
23:32:26 <Royal_Son> ?
23:32:26 <glguy> right
23:32:30 <Royal_Son> ok
23:32:31 <glguy> err
23:32:32 <glguy> well
23:32:52 <glguy> [ (a,b,c,d) | (a,b,c,d) <- rest , a < pivot_a ]
23:33:00 <glguy> the right side of the <- needs to be a list
23:33:08 <Royal_Son> ok
23:33:37 <shapr> The linux kernel really needs a decent typesystem. "... a driver which has indicated that batching is acceptable for dev may find its hard_start_xmit() method called with skb set to NULL. The NULL value is an indication that there is a batch of packets to transmit..."
23:34:33 <glguy> Royal_Son: do you feel like you could annotate your paste with a few improvements?
23:34:53 <Royal_Son> i'll give it a shot...
23:42:30 <glguy> if you are trying to run it before you paste, don't forget that you need to handle the empty list case
23:47:17 <glguy> Royal_Son: you alive?
23:49:37 <mudge> hi
23:51:35 <shapr> yarr!
23:52:03 <shapr> @arr
23:52:03 <lambdabot> Aye
23:52:41 <shapr> hoi plaeremans
23:55:38 <EvilTerran> shapr, sounds like an opportunity for porting to haskell ;]
23:55:49 <shapr> EvilTerran: Truly
