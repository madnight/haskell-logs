00:00:39 <sorear> dons: I'm the current hpaste operator, if that's what matters
00:01:05 <SamB_XP_> sorear: do you switch off by time of day/night?
00:01:18 <Tac-Tics> w00t it works
00:01:27 <Tac-Tics> I have invented 88 line brainfuck
00:01:30 <Tac-Tics> again....
00:01:37 <SamB_XP_> hmm.
00:01:44 * SamB_XP_ wonders how long his is/was
00:02:09 <wli> sorear: http://holomorphy.com/~wli/Ramanujan.lhs <-- has potentially useless driver code in it that may serve well in lieu of head -1000
00:02:24 <goalieca> heh. it was mem being stupid. i modified code and forgot to remove a show
00:02:49 <dons> sorear: no, just pondering about why we haven't announced all the video material on -cafe@
00:02:50 * sorear profiles
00:03:40 <SamB_XP_> @go video site:Haskell.org
00:03:42 <lambdabot> http://haskell.org/haskellwiki/Video_presentations
00:03:42 <lambdabot> Title: Video presentations - HaskellWiki
00:03:54 <SamB_XP_> dons: that's hopefully got everything
00:04:02 <SamB_XP_> in case you didn't remember
00:04:11 <dons> yes, it does. so we should tell the 2k list members about the slides+tutorial video
00:04:15 <Tac-Tics> Now to learn about Reader and Writer monads?
00:04:16 <dons> which is really rather a coup for us :)
00:04:17 <Tac-Tics> or sleep?
00:04:31 <wli> dons: How's it a coup for us?
00:04:43 <SamB_XP_> Tac-Tics: Sleep monad.
00:04:50 <dons> wli, a 3hr tutorial by SPJ? you seen one of those for erlang recently? :)
00:04:53 <Tac-Tics> hehe
00:04:55 <SamB_XP_> instance Monad Sleep
00:05:06 <SamB_XP_> sleep :: Sleep a
00:05:15 <Tac-Tics> return = wakeUp
00:05:27 <Tac-Tics> (>>=) = hitSnooze
00:05:28 <SamB_XP_> it's actually a pretty silly monad.
00:05:37 <SamB_XP_> because it doesn't allow you to wake up ;-)
00:05:37 <wli> sorear: +RTS -p says the integer cube root is hurting me the most.
00:06:04 <SamB_XP_> (there is no return from sleep ;-P)
00:06:15 <Tac-Tics> return = return
00:06:17 <SamB_XP_> (unless you implement it like Maybe, I guess)
00:06:37 <SamB_XP_> anyway, I must sleep now.
00:06:38 <SamB_XP_> or sooner.
00:06:43 <dblhelix> SamB_XP_: well, does it obey the monad laws then?
00:06:44 <SamB_XP_> so bye people!
00:06:51 <Tac-Tics> Just GoodBye SamB_XP_
00:06:55 <SamB_XP_> hehe
00:06:56 <sorear> wli: I'm not suprised.  a*a*a is *much* faster than a^3 (we need more RULES!); also I'm doing all the heavy math in Int and then using Integer only to filter out false quadruples
00:06:59 <dblhelix> ah, goodnight, SamB_XP_
00:07:01 <sorear> @kick SamB_XP_
00:07:01 <lambdabot> Maybe you meant: dice dict kind
00:07:12 <SamB_XP_> Tac-Tics: you messed up the arity of Just ;-P
00:07:25 <Tac-Tics> shit, I forgot parenthesis!
00:07:30 <Tac-Tics> and a function
00:07:37 <Tac-Tics> oh well
00:07:40 <nornagon> Hm, what's a good data structure to use for a 2D representation of a bunch of cells?
00:07:40 <SamB_XP_> hehe
00:07:42 <Tac-Tics> I think I fought syntax hard enough today
00:07:44 <nornagon> like, a rectangle
00:08:12 <dons> nornagon: Array (Int,Int) Item ?
00:08:18 <Tac-Tics> does anyone have any suggestions on how I can run my brainfuck machine without knowing all the Input in advance?
00:08:24 <dons> [[a]]
00:08:28 <Tac-Tics> some fancy way that avoids IO
00:08:29 <sorear> Interact?
00:08:34 <sorear> Tac-Tics: interact
00:08:34 <nornagon> dons: ah, I don't know about arrays... i guess I'll go read up :)
00:08:47 <sorear> :t interact
00:08:49 <lambdabot> (String -> String) -> IO ()
00:09:04 <sorear> so, just write your program as a string transformer
00:09:09 <Tac-Tics> How do I impart IO into the state after I begin to run it?
00:09:11 <sorear> then main = interact runBF
00:09:18 <Tac-Tics> I've seen interact and it looks cool
00:09:29 <sorear> Tac-Tics: why?  BF doens't do general IO, just input and output
00:09:32 <sorear> (haha)
00:09:44 <Tac-Tics> I guess
00:09:48 <Tac-Tics> hmm
00:09:52 <Tac-Tics> I might have to mess with my design
00:10:05 <Tac-Tics> right now I have runBF as a loop
00:10:38 <Tac-Tics> So would I have something like String -> State BFState String?
00:10:58 <sorear> Yeah.
00:11:02 <Tac-Tics> cool
00:11:07 <Tac-Tics> well, technically, I'm using Int arrays
00:11:10 <Tac-Tics> but yeah
00:11:15 <Tac-Tics> I can do a show/read dealy
00:11:26 <Tac-Tics> probably in a single line
00:11:30 <sorear> wli: 1000 validated quads in 6.4s *hpastes*
00:11:37 <Tac-Tics> Haskell is crazy with its one liners
00:12:00 <Tac-Tics> hmm
00:12:04 <hpaste>  sorear pasted "fast raman" at http://hpaste.org/2039
00:12:15 <Tac-Tics> what do I do then when the program doesn't take input?
00:12:43 <Tac-Tics> like "+++."
00:13:14 <Tac-Tics> I need threading or something for that or something
00:13:32 <Tac-Tics> I need a way to just magically dump input into some sort of hole
00:13:42 <Tac-Tics> and then at the other end of that hole is runBF
00:13:59 <Tac-Tics> I need a socket T____T
00:14:08 <nornagon> um
00:14:14 <nornagon> interact ought to be fine with no input
00:14:25 <wli> sorear: I got all sorts of nasty overflows when I tried to convert everything to Int
00:14:36 <nornagon> > interact (const "Hi there!\n")
00:14:38 <lambdabot>  <IO ()>
00:15:20 <nornagon> @bf ++++[>+++<-].
00:15:21 <lambdabot>  fd:22: hClose: resource vanished (Broken pipe)
00:15:25 <nornagon> poo.
00:15:27 <Tac-Tics> >______<
00:15:27 <dons> i think bf isn't installed
00:15:31 <Japsu> lol
00:15:33 <Tac-Tics> heh
00:15:54 <sorear> wli: Because the natural mapping from Z to Z_2^32 is a ring homomorphism, every real quadruple is an Int-quadruple; so I can use Int math to narrow the search space (dramatically!) then finish off with an Integer validator
00:16:16 <wli> sorear: ah
00:16:50 <Tac-Tics> changing runBF from State BFState [Int] to [Int] -> State BFState [Int] doesn't seem like it would work
00:17:46 <hpaste>  Tac-Tics annotated "(no title)" with "(no title)" at http://hpaste.org/2038#a2
00:19:26 * glguy adopts the phrase "value oriented programming"
00:19:31 <glguy> thanks SPJ
00:20:20 <nornagon> @pl \a x y -> a ! (x,y)
00:20:21 <lambdabot> (. (,)) . (.) . (!)
00:20:25 <nornagon> !
00:20:51 <glguy> ?
00:21:07 <nornagon> ‽
00:21:21 <glguy> Do you understand why that is the case?
00:21:24 <sorear> ∀
00:21:30 <glguy> ?yow
00:21:30 <lambdabot> I HAVE to buy a new "DODGE MISER" and two dozen JORDACHE JEANS because
00:21:30 <lambdabot> my viewscreen is "USER-FRIENDLY"!!
00:21:57 <sorear> λ!
00:22:00 <nornagon> glguy: why what is the case?
00:22:26 <nornagon> sorear: :)
00:22:50 <Tac-Tics> Why is it whenever I try to do something cool, with interact, I get
00:22:50 <Tac-Tics> *** Exception: <stdin>: hGetContents: illegal operation (handle is closed)
00:23:06 <nornagon> :o
00:23:07 <sorear> Tac-Tics: You're using GHCi?
00:23:21 <Tac-Tics> yes
00:23:44 <glguy> \a x y -> (!) a (x,y)    \a x y -> (!) a ( (,) x y)
00:24:20 <nornagon> glguy: *nod*
00:24:26 <glguy> \a x y -> (  ((!) a .) . (,) ) x y      \a -> ( ((!) a .) . (,)
00:24:38 <nornagon> it just looks horrid :) *sticks with the pointful version*
00:24:56 <glguy> oh, sure. there's no reason to actually *do* that :)
00:25:17 <sorear> Huh.  I was so sure this was in the ghc faq
00:25:18 <Tac-Tics> ugg, it annoys me that ghc's default for stdout is linebuffered
00:25:48 <sorear> Ah, I was just looking at the wrong FAQ.
00:25:50 <sorear> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-faq.html
00:25:52 <lambdabot> Title: 3.9. FAQ and Things To Watch Out For, http://tinyurl.com/377cw9
00:26:05 <sorear> Your problem is #5.
00:26:44 <Tac-Tics> ah
00:27:35 <dancor> best way to remove from x :: Set (a, b) anything with corresponding a in y :: Set a
00:27:54 <sorear> filter
00:28:19 <dancor> converting to lists is where it's at?
00:28:25 <sorear> S.filter
00:29:55 <dancor> actually my a's in (a,b) never repeat, i'm going to use Map a b there
00:34:30 <magnus__> Please comment on my first draft of Data.DisjointSet: http://magnus.smartelectronix.com/temp/DisjointSet.hs
00:39:24 <magnus__> it is rather small but if there is interest I could cabalize it
00:40:10 <dancor> do you think it can be "ok" to have "" mean something like "do not show this datum" for a String datum that can never be "" when actually present, or should i piously use Maybe String
00:40:41 <Saizan> ?google interesting monads
00:40:42 <lambdabot> http://www.haskell.org/haskellwiki/Monad
00:40:42 <lambdabot> Title: Monad - HaskellWiki
00:40:52 <magnus__> using Maybe will force you to take care of special cases in your code
00:41:13 <glguy> encourage, rather ;)
00:41:26 <magnus__> yeah :)
00:41:33 <dancor> ok
00:43:57 <wli> sorear: Weird, I don't have the foggiest idea why this would be faster.
00:44:18 <sorear> magnus__: Those efficiency bounds are only proven if you use DisjointSets single-threadedly
00:44:50 <sorear> wli: I'm iterating over pairs.  You're iterating over quadruples.  Quadratic time vs. quartic time.
00:45:20 <sorear> meh, I have a doubly lazy BF interpreter and I can't find a nice way to exploit it
00:45:35 <nornagon> I'm writing a little fractal map generator (using the diamond-square algorithm), and i'm having some trouble working out how to do the actual generation without resorting to lifting everything into the IO monad
00:46:03 <wli> sorear: Um, I only iterate over pairs of pairs, of which there are at most 2 until the third taxicab number.
00:46:25 <nornagon> i have contrived a way to get a list of random numbers into the pure part of the generation algorithm, but I can't work out how to "pop" numbers off the list when I need them
00:47:09 <magnus__> sorear: I will add a notice, thanks
00:47:37 <magnus__> sorear: it is enough to say that they are amortized right?
00:48:13 <wli> sorear: Pairs of validated pairs, that is.
00:49:10 <sorear> magnus__: Not quite; Okasaki has done persistent amortized structures by exploiting the side effects intrinsic in laziness (are we sure he's human?).
00:49:53 <magnus__> sorear: okay, I have updated the link
00:50:07 <nornagon> maybe I want a random number monad
00:50:21 <nornagon> >.>
00:52:04 <nornagon> oh.
00:52:07 <nornagon> http://groups.google.com/group/fa.haskell/browse_thread/thread/1079b5e001d442df/aeb738cb6987180e
00:52:09 <lambdabot> Title: Zippers, Random Numbers &amp; Terrain - fa.haskell | Google Groups, http://tinyurl.com/2p35nc
00:54:07 <sorear> Okay, I've written a BF compiler/interpreter which is lazy in the program - if you pass it a 100GB text file it will only read as much as it has executed...  How to exploit this, since I only have one stdin?
00:54:10 <wli> sorear: AFAICT I spend all of my time computing integer cube roots.
00:54:50 <Tac-Tics> add another stdin?
00:55:15 <Tac-Tics> it sounds like you're leading up to that answer.... and I'm sure there's some Monad that adds another stdin
00:55:15 <nornagon> wli: you need to get out more
00:55:34 <wli> nornagon: This is a program profile, not me personally.
00:55:40 <nornagon> ;)
00:56:27 <sorear> Tac-Tics: uhm...
00:56:57 <Tac-Tics> oh god, ghci just froze the crap out of my computer
00:57:15 <Tac-Tics> I think I'm almost done being n00b for the night
01:02:22 <sorear> jyp++ I see you've taken over the incremental synhl task :)
01:02:43 <sorear> Tac-Tics: froze shouldn't be possible under a modern multitasking OS
01:04:31 <jyp> sorear: Well I tried to contribute some :)
01:04:38 <wli> integer cube roots are getting pounded like wild monkeys.
01:05:28 <sorear> wli: cube *roots*?
01:05:36 <wli> yeah
01:05:54 <sorear> my code doesn't cube root at all
01:06:13 <wli> Yeah, I'm looking at the profiles for mine.
01:06:40 <jyp> sorear: If you have comments/ideas, they are very welcome
01:07:05 <sorear> jyp: sure, *notes in todo*
01:13:20 <cpoucet> re
01:13:46 <wli> I just don't get it. What I wrote should be going over a much smaller search space.
01:16:28 <nornagon> hmph, i'm all pure functionalled out today :(
01:16:38 <nornagon> that zipper terrain generation post broke my head
01:17:24 <cpoucet> nornagon: where?
01:17:44 <nornagon> http://tinyurl.com/2p35nc
01:17:46 <lambdabot> Title: Zippers, Random Numbers &amp; Terrain - fa.haskell | Google Groups
01:17:54 <sorear> night all.
01:17:59 <nornagon> night sorear
01:21:35 <roconnor> > let f x y = (x + y)/(1-x*y) in f (1/2) (1/3)
01:21:37 <lambdabot>  0.9999999999999999
01:21:43 <roconnor> > let f x y = (x + y)/(1-x*y) in f (1/2) (1/3) :: Rational
01:21:44 <lambdabot>  1%1
01:25:47 <roconnor> > let f x y = (x + y)/(1-x*y) in foldl' f 1 [(1/2),(1/3)] :: Rational
01:25:49 <lambdabot>  Exception: Ratio.%: zero denominator
01:26:10 <roconnor> > let f x y = (x + y)/(1-x*y) in foldl' f 0 [(1/2),(1/3)] :: Rational
01:26:11 <lambdabot>  1%1
01:28:08 <roconnor> > let f x y = (x + y)/(1-x*y) in foldl' f 0 (concatMap (uncurry replicateM) [(48,(1/38)),(80,(1/57)),(28,(1/239)),(96,(1/268))]) :: Rational
01:28:09 <lambdabot>  Couldn't match expected type `Rational' against inferred type `[a]'
01:28:23 <roconnor> @type (concatMap (uncurry replicateM) [(48,(1/38)),(80,(1/57)),(28,(1/239)),(96,(1/268))])
01:28:26 <lambdabot> forall a. (Fractional [a]) => [[a]]
01:29:29 <reffie> i hate X.
01:29:49 <roconnor> @type (concatMap (uncurry replicate) [(48,(1/38)),(80,(1/57)),(28,(1/239)),(96,(1/268))])
01:29:51 <lambdabot> forall a. (Fractional a) => [a]
01:29:55 <roconnor> ah better
01:30:01 <roconnor> > let f x y = (x + y)/(1-x*y) in foldl' f 0 (concatMap (uncurry replicate) [(48,(1/38)),(80,(1/57)),(28,(1/239)),(96,(1/268))]) :: Rational
01:30:02 <lambdabot>  0%1
01:30:42 <roconnor> hmm
01:30:56 <roconnor> that's not 1.
01:31:30 <roconnor> oh wait
01:31:59 <roconnor> > let f x y = (x + y)/(1-x*y) in foldl' f 0 (concatMap (uncurry replicate) [(12,(1/38)),(20,(1/57)),(7,(1/239)),(24,(1/268))]) :: Rational
01:32:01 <lambdabot>  1%1
01:32:06 <roconnor> ah, much better
01:32:17 <opqdonut> what are you up to?
01:33:18 <roconnor> opqdonut: figuring out how to prove that pi/4 = 12*arctan(1/38) + 20*arctan(1/57) + 7*arctan(1/239) + 24*arctan (1/268)
01:33:26 <roconnor> proving it is very easy.
01:33:40 <roconnor> the hard part is coming up with the formula.
01:33:50 <roconnor> fortunately that has already been done.
01:34:37 <sieni> roconnor: using the Stetson-Harrison method
01:34:58 <opqdonut> ah, Stetson-Harrison :)
01:35:21 <sieni> roconnor: i.e. you pull numbers out from a hat (Stetson). The name Harrison is there just to make it sound more convincing.
01:35:23 <roconnor> http://aemes.mae.ufl.edu/~uhk/PI.html
01:35:24 <lambdabot> Title: PI
01:35:26 <opqdonut> personally i prefer Sleeve's version of the methodology
01:35:34 <opqdonut> Stetson-Sleeve-Harrison
01:37:19 <roconnor> sieni: :)
01:37:52 <roconnor> > 4*(12*arctan(1/38) + 20*arctan(1/57) + 7*arctan(1/239) + 24*arctan (1/268))
01:37:53 <lambdabot>   Not in scope: `arctan'
01:38:00 <roconnor> :type atan
01:38:02 <roconnor> @type atan
01:38:04 <lambdabot> forall a. (Floating a) => a -> a
01:38:04 <magnus__> Hmm, quickcheck chooses () for Ord a instances :(
01:38:17 <roconnor> > 4*(12*atan(1/38) + 20*atan(1/57) + 7*atan(1/239) + 24*atan (1/268))
01:38:18 <lambdabot>  3.141592653589793
01:38:54 <opqdonut> that isn't accurate
01:39:07 <opqdonut> but hey, it's floating point
01:39:54 <roconnor> opqdonut: It will be more accurate on with my exact real arithmetic.
01:40:24 <opqdonut> :)
01:51:55 <vincenz> s
01:52:36 <wli> Various generalized continued fractions have the nice property of the odd and even convergents being successively closer upper and lower bounds.
01:54:57 <wli> (I'm not sure that it holds for generalized continued fractions in general, though I know it holds for the ordinary continued fractions.)
01:57:38 <wli> Borwein & Borwein's methods have vastly faster convergence, though.
01:58:06 <wli> wikipedia lists a 9th-order convergent method, even.
01:59:52 <wli> (Between successive steps, if the error of step n is e_n, then e_{n+1} is O(e_n^9), to be specific; obviously 0 < e_n < 1 here.)
02:01:47 * wli wonders why people bother with BF interpreters.
02:03:57 * osfameron wonders who would really need the speed of compiled Brainfuck
02:05:54 <wli> There is that, too.
02:08:24 <osfameron> SPJ++ # accessible
02:11:10 * integral is watching the 'A Taste of Haskell' videos :)
02:11:21 <reffie> url?
02:11:25 <reffie> nevermind
02:11:50 <integral> blip.tv
02:11:56 <integral> oh, yes, nevermind
02:12:51 <reffie> hm, is there a downloadable version?
02:13:05 <integral> yes, look in the right hand column, nearer the bottom
02:13:06 <xerox> http://haskell.org/haskellwiki/Video_presentations
02:13:07 <lambdabot> Title: Video presentations - HaskellWiki
02:13:20 <reffie> thanks
02:16:41 <osfameron> the quality of the video is excellent but it's not mixed with screen-grabs
02:17:14 <integral> the wiki page should really link to the presentation pdf
02:17:21 <integral> oh, darn, it does
02:21:45 <reffie> i should rewrite my dns server in haskell
02:23:27 <psykotic> weirdness
02:23:38 * wli tries to figure out how to make a fresh monad transformer.
02:24:46 <psykotic> why doesn't runST $ do ... work? it seems to want runST (do ...), which is unlike other cases i remember dealing with
02:24:59 <psykotic> is it do with type inference being weird with rank 2 types or something?
02:25:11 <xerox> Don't use ($)
02:25:16 <wli> psykotic: No, you probably need flip
02:25:35 <psykotic> xerox, yes, but why?:)
02:25:50 <xerox> Not polymorphic enough.
02:25:52 <vincenz> @type runST
02:25:53 <psykotic> i assume it's because the "indirection" of using $ ... right
02:25:54 <lambdabot> Not in scope: `runST'
02:25:58 <vincenz> @hoogle runST
02:25:59 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
02:25:59 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
02:25:59 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
02:26:19 <vincenz> > runST $ (do {return ()})
02:26:20 <lambdabot>   Not in scope: `runST'
02:26:26 <vincenz> @type runST $ (do {return ()})
02:26:28 <lambdabot> Not in scope: `runST'
02:26:32 <vincenz> @type control.Monad.ST.runST $ (do {return ()})
02:26:34 <lambdabot> Couldn't find qualified module.
02:26:40 <vincenz> @type Control.Monad.ST.runST $ (do {return ()})
02:26:42 <lambdabot>     Couldn't match expected type `forall s. GHC.ST.ST s a'
02:26:42 <lambdabot>            against inferred type `a1 b'
02:27:59 <vincenz> oddd
02:28:03 <psykotic> no, it makes sense...
02:28:09 <psykotic> but it's a pain in the ass
02:28:22 <vincenz> how does it make sense?
02:28:35 <vincenz> @type ($)
02:28:37 <lambdabot> forall a b. (a -> b) -> a -> b
02:30:44 <roconnor> vincenz: are we talking about the polymorphic problems with ($) again?
02:31:12 <vincenz> 'again'?
02:31:29 <roconnor> ($) is polymorphic, but so long as the type variables are not themselves polymorphic (ie containing foralls).
02:32:48 <roconnor> (runST $) always trips everyone up.
02:33:14 <roconnor> @type (Control.Monad.ST.runST $)
02:33:16 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
02:33:35 <roconnor> hmm, I wasn't execting that to work.
02:33:36 * vincenz isn't quite sure why
02:33:51 <int-e> @version
02:33:52 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
02:33:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:34:00 <psykotic> i thought it was a type inference thing but guess not
02:34:04 <roconnor> oh right, it is the second parameter that has the forall in it.
02:34:09 <psykotic> like, it would infer a too specialized type
02:34:19 <roconnor> @type (Control.Monad.ST.runST $) (return ())
02:34:21 <lambdabot> ()
02:34:35 <roconnor> @type (Control.Monad.ST.runST $) (do return ())
02:34:37 <lambdabot> ()
02:34:43 <roconnor> > (Control.Monad.ST.runST $) (do return ())
02:34:44 <lambdabot>   Not in scope: `Control.Monad.ST.runST'
02:34:58 <roconnor> okay, now I'm confused too.
02:35:08 <int-e> @type Control.Monad.ST.runST $ return ()
02:35:10 <lambdabot>     Couldn't match expected type `forall s. GHC.ST.ST s a'
02:35:10 <lambdabot>            against inferred type `m ()'
02:35:22 <roconnor> @type ($) Control.Monad.ST.runST (do return ())
02:35:24 <lambdabot>     Couldn't match expected type `forall s. GHC.ST.ST s a'
02:35:24 <lambdabot>            against inferred type `a1 b'
02:35:27 <swiert> dons: Do you know how to get a password reminder for Hackage?
02:36:02 <xerox> Both work in GHC 6.7.
02:37:02 <dons> swiert: hmm. I think I can override a passwd, but I don't know about sending a reminder
02:37:20 <swiert> dons: Could you override my passwd?
02:37:35 <dons> sure, i'll mail it to you. email address please?
02:37:54 <swiert> dons: wss at cs.nott.ac.uk
02:37:57 <swiert> Thanks.
02:38:05 <dons> ah got it.
02:39:02 <int-e> @type (($) Control.Monad.ST.runST) (return ())
02:39:04 <lambdabot> ()
02:39:05 <psykotic> xerox: works in 6.7? nice
02:39:11 <xerox> Yup.
02:39:12 <int-e> huh. (a b) c  !=  a b c
02:39:15 <psykotic> xerox: it's nasty to have to put brackets around a multi-line do block
02:39:42 <psykotic> of course you could do runST m where m = do ...
02:40:34 <roconnor> int-e: (a b) c != a b c when implicit type parameters are being passed around in that little whitespace.
02:41:04 <roconnor> int-e: It's pretty horrible when it happens Coq.
02:41:22 <roconnor> I always get complains ``cannot unify (expression) with (same expression)''.
02:41:44 <int-e> roconnor: but why is it that the first one typechecks and the second doesn't?
02:41:45 <dons> swiert: done. check your inbox
02:42:15 <int-e> roconnor: (for a = ($), b = runST, c = return ())
02:42:30 <roconnor> int-e: presumably becuase the system isn't automatically filling in the type parameters in correctly.
02:42:42 <roconnor> runST has a funky type.
02:42:46 <swiert> dons: Ok. Let me check. Thanks again!
02:42:55 <int-e> I know. But this effect is confusing me :)
02:43:13 <Saizan> ?type ($)
02:43:15 <lambdabot> forall a b. (a -> b) -> a -> b
02:43:23 <roconnor> int-e: I haven't actually worked it out, so I could be wrong on this.
02:43:38 <Saizan> "a" ranges only on ground types
02:43:57 <roconnor> Saizan: not entirely true.
02:44:13 <roconnor> @type (Control.Monad.ST.runST $)
02:44:15 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
02:44:46 <roconnor> @type ($) Control.Monad.ST.runST
02:44:48 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
02:45:02 <int-e> roconnor: my intuition says that if (a b) c typechecks, then so should a b c. obviously the intuition is wrong :)
02:45:33 <roconnor> int-e: Oh I agree it should.
02:45:49 <roconnor> int-e: at least assuming that it is always possible and feasable.
02:47:23 <roconnor> *sigh* presumably a monotone function's inverse is monotone.
02:47:31 <roconnor> (strictly monotone)
02:51:23 <int-e> roconnor: ah. ghc-6.4.2 behaves as expected: both (a b) c and a b c fail to type-check. ("Inferred type is less polymorphic than expected"). And in 6.7 both work as has already been said.
02:51:46 <roconnor> int-e: ah, what's up with lambdabot?
02:52:59 <dons> haha, linuxer is now submitting Coq articles to reddit
02:53:03 <int-e> it uses 6.6. I don't know what the type checker is doing.
02:53:56 <int-e> 6.6 implements the boxy types paper ideas, right?
03:19:57 <Baughn> @seen dons
03:19:57 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 26m 58s ago.
03:23:26 <xerox> Do you know if there exist some ready-made tool to ask a question with an X11 window and get back the answer?
03:23:41 <wolverian> xerox, yes
03:24:01 <xerox> How is it called?
03:24:32 <wolverian> zenity
03:24:58 <xerox> thank you!
03:25:09 <wolverian> you're welcome
03:26:45 <osfameron> SPJ++ # not dissing imperative programming
03:28:31 <matthew-_> converting from a float to a double and then back to a float will be identity right?
03:30:09 <sieni> sounds like it
03:30:40 <profmakx> should be sounds more like it
03:31:07 <EvilTerran> not sure is representable as float => representable as double is garunteed anywhere.
03:31:12 <EvilTerran> *if
03:31:31 <EvilTerran> but it'd be a bit silly if it didn't hold...
03:31:34 <Baughn> EvilTerran: IEEE floating-point standards, if anywhere. IIRC it is.
03:32:18 <matthew-_> Baughn: yeah, but does haskell really do IEEE floating point ?
03:32:24 <matthew-_> I presume it must do...
03:33:01 <matthew-_> oh well, these are large numbers anyway, so minor differences won't matter!
03:33:02 <Baughn> matthew-_: It does whatever the underlying CPU does. Now, whether x86 does IEEE FP... I'm pretty sure it attempts to, at least.
03:33:25 <Baughn> If you're coding with floats and depending on exactness, you're doing something wrong, yes. ^_^;
03:33:31 <matthew-_> Baughn: yeah quite, but, eg excess-precision puts it into 80-bit native on the CPU etc etc
03:34:04 <matthew-_> Baughn: I'm tempted to start a campaign to get floating point number support removed from CPUs
03:34:08 <Baughn> matthew-_: Right, which can make calculations.. excessively precise?
03:34:15 <matthew-_> or just wrong
03:34:25 <Baughn> Only if you're depending on exactness
03:34:33 <int-e> matthew-_: well except for NaNs - and Infinity causes trouble in the other direction
03:34:33 <matthew-_> equality springs to mind
03:34:46 <Baughn> I'm tempted to remove floating-point from Eq
03:35:15 <int-e> > realToFrac (1/0 :: Float) :: Double
03:35:17 <lambdabot>  Infinity
03:35:37 <int-e> hah and ghc even misoptimizes this one ;-)
03:35:55 <EvilTerran> hm?
03:35:56 <matthew-_> there's some issue which I once read about where if you do, in C, "int z = x + y; if (x + y == z) { ... }", with excess precision, sometimes the z will be sent back to RAM and thus truncated to 64 bits, thus the == will fail
03:36:02 <int-e> (in ghci it gives 3.402823669209385e38)
03:36:15 <EvilTerran> O.o
03:36:42 <Baughn> matthew-_: You're overflowing a signed integer, so strictly speaking that's undefined behaviour anyway
03:36:58 <matthew-_> crap, they should have been floats, not ints, sorry
03:37:13 <EvilTerran> int-e, indeed it does... hehe.
03:37:14 <int-e> Baughn: Eq for floating point numbers is occasionally useful.
03:37:24 <int-e> @src realToFrac
03:37:24 <lambdabot> realToFrac = fromRational . toRational
03:37:33 <matthew-_> the point is that the 80-bit floating representation can only exist in the CPU and so causes problems vs values fetched from RAM
03:37:36 <Baughn> matthew-_: I can believe it for ints, too. In any case, there's a gcc flag to take care of the problem.
03:37:43 <matthew-_> ahh, ok
03:37:54 <Baughn> -fno-excess-precision, IIRC: It slows things down though.
03:37:56 <int-e> EvilTerran: as you can see this converts to Rational and back; and Rational can't represent infinities :)
03:38:31 <matthew-_> ugh. The number classes in Haskell are really quite broken.
03:38:54 <wli> Yeah, we need Haskell' and bad.
03:39:21 * wli seems to have finished grinding out the CounterT monad transformer.
03:39:28 <matthew-_> I think Haskell' and the needed rewrite of numbers in the Prelude are separate issues
03:39:48 <Baughn> int-e: Why is that? Considering 1/0, you'd think rational should be able to do that
03:40:43 <wli> matthew-: I think the responsible parties are holding out for Haskell' to do it given the sort of talk going around.
03:41:46 <wli> I'm not sure what you get with nested state transformers, but the nameclashes for the MonadState methods create quite a bit of confusion.
03:42:08 <wli> hence banging out the CounterT state transformer.
03:42:51 <int-e> Baughn: it could be represented, yes. but then Rational wouldn't be a field anymore.
03:43:17 <Baughn> int-e: There is no Field typeclass. What does its being one buy us?
03:43:31 <int-e> Baughn: I'd question the choice of Rational as a universal representation of 'real' numbers.
03:43:43 <matthew-_> I guess at some point I should try to understand what the various differences and similarities are between fields, rings, groups and hoola-hoops are
03:44:05 <ddarius> matthew-: It's straightforward.
03:44:18 <matthew-_> well that's that then
03:45:09 <int-e> Baughn: well, the field thing is a red herring, what I really mean is that rational numbers have a clear definition in math and there's no good reason why the Rational type should represent something different.
03:45:13 <Baughn> matthew-_: Read wikipedia. The descriptions are, well, five lines or so
03:45:24 <Baughn> Consequences are a different matter. ;)
03:45:51 <wli> The real nastiness is that rings are semigroups in two different ways.
03:45:58 <Baughn> int-e: There is the "being able to approximate floats" reason, but tbh I don't use infinity much. Or at all.
03:46:28 <ndm> @seen nominolo
03:46:28 <lambdabot> nominolo is in #ghc, #haskell-soc and #haskell. I last heard nominolo speak 9h 13m 32s ago.
03:46:42 <xerox> ?hoogle unsafePerformIO#
03:46:42 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
03:46:42 <nominolo> hi ndm
03:46:44 <xerox> ?hoogle unsafePerformIO
03:46:45 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
03:47:06 <int-e> @type toRational -- this function is the real atrocity in my opinion.
03:47:09 <lambdabot> forall a. (Real a) => a -> Rational
03:47:09 <ndm> nominolo: there is a rational reason for foo/./bar => foo/bar, i guess . => "" is just a logical extension of that
03:47:24 <ndm> nominolo: but if you think its silly, and others agree, i will happily change it
03:47:55 <nominolo> except that, eg, openDirectory (normalize ".") doesn't work
03:47:55 <ndm> its certainly an "edge" case either way, but if it breaks cabal that suggests the edge came down strongly
03:48:07 <ndm> true
03:48:15 <wli> You can't parametrize over the names of typeclass operators.
03:48:36 <matthew-_> ndm: is the argument for or against converting foo/./bar to foo/bar ?
03:48:49 <wli> I think you'd have to do that in the instance head somehow.
03:48:51 <ndm> nominolo: i'm happy to change it, should probably check with Igloo first though
03:48:58 <nominolo> and in cabal, when someone specifies include dir "." it will be normalized to "" and the compiler option will be "-I" => error
03:49:06 <int-e> > toRational (0/0)
03:49:08 <lambdabot>  (-26965397022934738615939577861835371004269654684134598591014512173659901370...
03:49:11 <ndm> matthew-_: normalise is meant to make equal filepaths "more equal"
03:49:27 <int-e> and that one isn't even funny.
03:49:27 <ndm> matthew-_: i.e. if two paths represent the same string, normalise should make them closer to the same
03:49:40 <nominolo`> stupid client
03:50:12 <matthew-_> ndm: I'm almost tempted to say that you could never be 100% confident on the meaning of two strings, so normalize shouldn't exist
03:50:48 <nominolo`> I tried to find a posix standard for that, but it was rather hopeless
03:50:51 <Baughn> int-e: Since it ends with ..., you could make the argument that lamby is simply trying to print an infinite number..
03:51:17 <matthew-_> ndm: but I'm quite certain you'll have spent much longer trying to deal with such issues.
03:51:26 <ndm> matthew-_: thats like saying you can never use floating point numbers precisely, so you should just remove them
03:51:42 <matthew-_> ndm: an idea that's indeed close to my heart
03:51:48 <wli> I have no idea how this could work.
03:52:01 <ndm> matthew-_: the other thing is that if you don't give people these things, which i spent time trying to make as reliable as possible, they will write a really bad version (map toUpper x == map toUpper y), and things will be even worse
03:52:21 <ndm> matthew-_: mine too, i think floating point numbers are massively overused
03:52:53 <wli> I think a lot of people don't really know how to use floating point numbers.
03:52:58 <matthew-_> ndm: yeah, I guess that's a point. Though catering for naivity is a depression issue for API design!
03:53:10 <int-e> > toRational (0/0) == -3*2^1023
03:53:12 <lambdabot>  True
03:53:14 <wli> And, for that matter, limited-precision integral types.
03:53:40 <int-e> Baughn: you were saying?
03:54:06 <nominolo`> ndm: yes, please check with Igloo, but i think it is a reasonable border case
03:54:12 <ndm> matthew-_: yep, but really filepaths are broken...
03:54:23 <nominolo`> what is the invariant on normalise anyways?
03:54:24 <Baughn> int-e: Just give me a minute, and I'll prove that -3*2^1024 is infinite.
03:54:28 <ndm> nominolo`: i think its fair to say that an invariant on filepath is that it should never be blank
03:54:34 <int-e> > 3*2.0^1023
03:54:36 <lambdabot>  Infinity
03:54:38 <ndm> nominolo`: "try hard", i don't think there is one
03:54:40 <matthew-_> ndm: filesystems are broken. Filesystems should be databases
03:54:40 <nominolo`> ndm: :)
03:55:12 <Baughn> Ah. You've already done it.
03:55:52 <wli> They already are databases, just very limited ones.
03:56:09 <flux> without transactions..
03:56:14 <wli> Yes.
03:56:16 <nominolo`> ndm: i googled, and from what i found, most other implementations normalize to an absolute path
03:56:21 <wli> Most people don't understand the limitations.
03:56:34 <flux> anyway, even if filesystems did have all the cool stuff, no applications would know how to use them
03:56:37 <ndm> nominolo`: you can do that, its in System.Directory
03:56:54 <int-e> Baughn: but note that we started with NaN, so NaN = -Infinity. Hmm weird :)
03:57:05 <wli> flux: Most should be directed toward databases.
03:57:14 <flux> it would be fun to see stuff like mv device_1/* device_2/* to have all the files disappear and reappear in an atomic fashion
03:57:41 <flux> infact, it could just do that immediately, and continue the IO in the background
03:58:08 <flux> too bad however if you lose electricity, the transaction would be rolled back..
03:58:17 <profmakx> i surely hope you guys are not thinking relational databases
03:58:30 <Baughn> profmakx: That'd be nice. Do you know of any?
03:58:45 <profmakx> no
03:58:48 <wli> There's always Oracle. ;)
03:59:03 <profmakx> and I think, that relational databases dont fit the directory concept all too well
03:59:28 <wli> profmakx: How's that?
03:59:43 <klugez> MAXMAXMAXMAXMAXMAXMAX
03:59:50 <klugez> Oops, sorry.
03:59:57 <profmakx> o.O
04:00:23 <xerox> dons: do you have a script handy to run xmonad in XNest?
04:00:28 <Baughn> profmakx: This is true. However, the directory concept doesn't fit what I want to do with a filesystem very well either.
04:00:39 <Saizan> deriving Read on a newtype will use the standard automatic deriving or the newtype one?
04:01:02 <profmakx> so
04:01:11 <xerox> Saizan: what's the difference?
04:01:12 <profmakx> what do you want to do with your filesystem, Baughn
04:01:26 <Baughn> flux: Such a move could take hours, and by that time there would be plenty of further transactions depending on it. Instead of rolling it back, using a journal so it can be continued later would be nice.
04:01:38 <Baughn> profmakx: Ad-hoc relations
04:02:07 <Baughn> profmakx: SQL fails at ad-hoc, and directories fail at relations. Neither really fits.
04:02:17 <profmakx> right
04:02:42 <wli> SQL sucks anyway.
04:03:00 <Saizan> xerox: the presence of the newtype's contructor or not
04:03:22 <wli> Some full-blown logic language would be far nicer than SQL.
04:03:27 <doserj> Saizan: Read and Show is explicitely excluded from newtype deriving
04:03:54 <Saizan> doserj: feared so :\
04:03:55 <profmakx> wli and probably quite a bite mor complicated to handle
04:04:31 <wli> profmakx: Absolutely. Shove all that complexity into the database instead of the hapless apps trying to figure out how to form queries.
04:04:38 <dons> xerox: no, but there's some in the xmonad mailing list recently
04:04:47 <xerox> ah, lookin up.
04:04:58 <doserj> Saizan: why "feared"?
04:05:06 <profmakx> then the apps figure out how to build up logic fomulae. hows that better?
04:05:20 <hpaste>  calvins pasted "Error message is Greek to me" at http://hpaste.org/2040
04:05:46 <calvins> hey all, I've not used haskell for quite a while, and my brain has turned to mush...
04:06:07 <calvins> I can't figure out why I can do
04:06:09 <wli> profmakx: It's vastly more expressive, so it requires far less work to figure out how to do a query.
04:06:16 <calvins> euclid_steps a b = length $ euclid_ a b
04:06:23 <calvins>  but not (what I think of as equivalent):
04:06:31 <calvins> euclid_steps' = length . euclid_
04:06:51 <int-e> calvins: euclid_steps' = length . euclid_ is equivalent to  euclid_steps' a = length (euclid_ a) -- the error message says that  euclid_ a  is a function, not a list.
04:06:53 <wolverian> calvins, look at .'s type, and euclid_'s
04:06:54 <xerox> dons: aha, it's exactly SPJ asking for that script, the one he uses in A Taste of Haskell:)(
04:07:32 <Saizan> doserj: because now i need to write those instances myself so that they are the same as the ones of the old type
04:07:56 <wli> calvins: http://hpaste.org/1933#a7
04:08:12 <int-e> calvins: so no these two are not equivalent
04:08:34 <doserj> Saizan: you actually *want* the newtype deriving behaviour, and not the normal one?
04:08:36 <int-e> calvins: euclid_steps a = length . euclid_ a  would work (but looks weird)
04:09:35 <int-e> calvins: euclid_steps = (length .) . euclid_  would also work but is hard to read.
04:10:11 <Saizan> doserj: yeah, i don't want to break serialization
04:11:54 <doserj> Saizan: but how do you know how to deserialize a string, if it could have been any newtype?
04:13:53 <xerox> ?hoogle forkIO
04:13:57 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
04:14:09 <Saizan> doserj: i don't follow, when you use read you ask for a specific type and that tells you if the string match
04:14:24 <Japsu> @quote lisp
04:14:25 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
04:14:31 <Japsu> meh
04:14:32 <Japsu> @quote lisp
04:14:32 <lambdabot> adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
04:14:37 <Japsu> <3
04:15:00 <kuribas> Is there a good reason for having arrows, e.g. something that cannot be expressed clearly without them?
04:15:05 <fasta> @quote ruby
04:15:05 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
04:15:10 <fasta> @quote ruby
04:15:11 <lambdabot> adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
04:15:25 <kaol> @quote lisp
04:15:25 <lambdabot> qwe1234 says: i'm still waiting for the list of differences between lisp and php that matter.
04:15:32 <kaol> @quote php
04:15:32 <lambdabot> sieni says: python, like php, is just training wheels without the bike
04:15:40 <kaol> @quote python
04:15:40 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
04:15:40 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
04:15:46 <kaol> @quote perl
04:15:47 <lambdabot> cjeris says: i have a little perl script that aliases gcc -freduced-suckage to ghc
04:15:54 <kaol> @quote ghc
04:15:54 <lambdabot> ghc says: You can get a PhD for explaining the True Meaning of this last construct
04:16:03 <arcatan> meep
04:16:09 <doserj> Saizan: but you can't tell if it *shouldn't* match
04:16:10 <fasta> Meh, another CPP bug.
04:16:50 <fasta> It adds a ')' too much.
04:17:02 <kaol> I don't think that I can follow this chain any further. Even ghc was a bit stretch, as it's hardly a language.
04:17:16 <Saizan> kuribas: they reify functions permitting more static analisys
04:18:55 <kuribas> Saizan: uhm, can you give a link to a practical example?
04:19:15 <Saizan> doserj: well i don't pretend a String to carry so much type information inside it, read "100" can be Int, Integer, Double etc..
04:20:19 <calvins> {int-e, wolverian, wli}: thanks for the help
04:20:46 <doserj> Saizan: true, but no reason to make it worse :)
04:21:02 <EvilTerran> > read "100 :: Int" :: Int
04:21:03 <lambdabot>  Exception: Prelude.read: no parse
04:21:05 <EvilTerran> bah
04:21:54 <Saizan> kuribas: i think the best is to read the papers where arrows were introduced http://www.haskell.org/arrows/biblio.html
04:21:55 <lambdabot> Title: Arrows: bibliography
04:22:06 * wli ponders an Environment monad transformer.
04:22:24 <doserj> for numeric literals, this ambiguity is actually specified in the syntax of the language
04:23:12 <doserj> probably with the thought that the same number in a different type still represents the "same thing"
04:23:24 <wli> Try with -fno-implicit-prelude and you'll get some GHC.*.* business for numeric literals.
04:24:00 <EvilTerran> but you _could_ instance Read Foo where { read "0" = Foo; read "1" = Bar; read "1.5" = ... }
04:24:07 <wli> So it's not quite as ambiguous as specified.
04:24:46 <int-e> > read ('"':repeat ' ') :: Int
04:24:50 <lambdabot> Terminated
04:25:04 <EvilTerran> and how it works in the language isn't necessarily the same as how it reads/shows
04:25:24 <doserj> 100 is specified to mean "fromInteger 100", and -fno-implicit-prelude complies with that
04:25:56 <wli> doserj: Maybe in more recent of ghc than ships in Debian.
04:26:05 <int-e> and -100 is different from  fromInteger (-100)
04:26:44 <doserj> the only thing is, the language specifies it as "Prelude.fromInteger 100", and -fno-implicit-prelude does not :)
04:26:46 <EvilTerran> i'm guessing when you say "fromInteger 100" you mean "fromInteger applied to the compiled representation of 100 as an integer"...
04:27:04 <doserj> EvilTerran: yes
04:27:20 <int-e> > let 100 = fromInteger 100 in 100 -- ;-)
04:27:22 <lambdabot>  100
04:27:30 <EvilTerran> otherwise we'd get an INFINITE LOOP OF HATE
04:27:39 <EvilTerran> er. or not. O.o
04:28:00 <wli> People who have done Prelude rework sorts of things have banged their head against the subtle difference.
04:29:31 <doserj> > let 200 = fromInteger 100 in 200 -- :)
04:29:32 <lambdabot>  200
04:30:14 <Saizan>  > let a@200 = fromInteger 100 in a
04:30:15 <Saizan> > let a@200 = fromInteger 100 in a
04:30:17 <lambdabot>   Irrefutable pattern failed for pattern (a@200)
04:32:18 <adamc> how do i compile an executable? i tried ghc --make but it only makes an object file
04:32:42 <kaol> is there a cabal file?
04:33:01 <adamc> no
04:33:44 <wolverian> adamc, that worksforme
04:33:50 <wolverian> adamc, (ghc --make -O foo.hs)
04:35:00 <doserj> adamc: do you have a main function?
04:35:40 <adamc> i do. i'll try compiling an example program instead of my one
04:37:33 <wli> I'm not sure where my old code went.
04:37:47 <wolverian> adamc, you need module Main too, I think
04:37:58 <wolverian> adamc, module Foo where main = ... -- isn't sufficient
04:38:11 <wolverian> I'm sure this is all documented in the ghc manual, or even the haskell report :)
04:38:40 <adamc> wolverian, i didn't have a Main module, that fixed it
04:38:45 <adamc> thanks!
04:40:00 <RyanT5000> JaffaCake: so now i've read that whole paper "weak" by spj, sm, and some other dude; i'm pretty sure the only time they actually explained why finalizers aren't roots was when they said "this example would break"
04:40:20 <wli> http://holomorphy.com/~wli/Algebra.hs looks familiar but I think it's a bit more recent than what I'm remembering.
04:41:19 <JaffaCake> RyanT5000: which example was that?
04:49:07 <wli> http://holomorphy.com/~wli/Algebra.hs was a sort of attempt of mine to fix up the Prelude class hierarchies.
04:56:27 <wolverian> http://thread.gmane.org/gmane.comp.lang.haskell.prime/2152 -- id is deep magic
04:56:29 <lambdabot> Title: Gmane Loom
05:03:26 <wli> There are probably more intelligent derivations here.
05:04:27 <EvilTerran> hm. gmane's suddenly stopped loading for me. it was working 'til i got about half-way downyhat thread...
05:06:06 <int-e> gmane just hickuped for me but is back
05:06:28 <EvilTerran> ah, yeah, same here. someone must've tripped over a cable or something ;]
05:11:18 <wli> Dylan Thurston's does everything that does and more.
05:14:16 <wli> Oh wow, I've apparently an unwitting contributor to it.
05:16:45 <Cress> I'm having trouble with the ST monad. Anyone know why this won't compile?: display _ _ (w,h) = runSTArray $ newArray ((1,1),(w,h)) defaultNode >>= return
05:18:16 <Alleria> @src sum
05:18:16 <lambdabot> sum = foldl (+) 0
05:19:13 <xerox> Cress: what is the error? Might be worth a try using parenthesis instead of ($).
05:20:51 <Cress> Seems to work with parenthesis. Thanks.
05:21:17 <xerox> You're welcome. With GHC 6.7 you can use ($).
05:28:40 <wli> 1 :: (GHC.Num.Num t) => t
05:28:59 <wli> WhatI get with Thurston et al's numeric Prelude.
05:35:43 <ndm> @seen Igloo
05:35:43 <lambdabot> Igloo is in #gentoo-haskell, #darcs, #ghc and #haskell. I last heard Igloo speak 11h 26m 7s ago.
05:36:59 <ndm> @gently-prod Igloo
05:36:59 <lambdabot> Unknown command, try @list
05:41:26 * wli should just use Thurston & Thielemann's numeric prelude.
05:42:57 <hpaste>  Gwern pasted "(no title)" at http://hpaste.org/2042
05:43:29 <gwern> I'm having trouble using == in an IO monad
05:43:50 <gwern> ex, 'height = if any (== term) ["linux","dumb","console"] then 29 else 50' is giving me conniptions
05:44:06 <gwern> I just can't seem to compare those strigns with term, and liftM and co aren't helping
05:44:41 <aleator> return 29?
05:44:59 <Baughn> @src Eq
05:44:59 <lambdabot> class  Eq a  where
05:44:59 <lambdabot>     (==), (/=)   :: a -> a -> Bool
05:45:02 <ndm> gwern: you are missing let
05:45:14 <mux> gwern: why not just any (flip isInfixOf file) [...]?
05:45:26 <mux> the map part is useless AFAICT
05:45:37 <gwern> ndm: eh? what does let have to do with it? it's just another form of where, I understood
05:45:48 * gwern thinks where is more understandable so that's what I use
05:45:55 <Igloo> ndm: I agree re normalising "." should give "."
05:46:04 <ndm> Igloo: library proposal, or just make a bug fix?
05:46:21 <ndm> gwern: i am then entirely misunderstanding you, if you hpaste hte whole fragment
05:46:33 <Igloo> Dunno
05:46:41 <mux> also, term is IO String
05:46:44 <gwern> ndm: that's the whole program there
05:47:03 <gwern> (well, with the exception of lengthF which I wrote elsewhere)
05:47:11 <ndm> case Igloo's best guess of
05:47:20 * ndm strictly evaluates Igloo's opinion
05:48:00 <roconnor> > fix opinion
05:48:02 <lambdabot>   Not in scope: `opinion'
05:48:04 * wli tries to find his continued fraction module (which built on others', but is/was more complete).
05:48:12 <Saizan> gwern: you can't compare IO String with String, you've to write height = liftM (\term' -> if any (== term') ["linux","dumb","console"] then 29 else 50) term
05:48:51 <hpaste>  mux annotated "(no title)" with "better?" at http://hpaste.org/2042#a1
05:49:09 <mux> I've hopefully simplified compressed too
05:49:23 <gwern> Saizan: so instead of trying to promote the list of strings, write a function which compares the two and promote it instead?
05:49:27 <gwern> hmm.
05:49:49 <Saizan> mux, term is not in scope in the where clause
05:50:08 * wli quietly ponders whether Igloo found his DEFLATE compression code.
05:50:15 <mux> gah, the where should be indented more I guess, or he should use fmap or liftM
05:50:58 <gwern> right
05:51:19 <mux> and there is both a l <- lengthF file, and a where binding l = lengthF file
05:51:24 <mux> this is probably not what you want
05:51:37 * roconnor can't figure out how to use maple 11
05:51:52 <Saizan> gwern: i'd try to factor the pure bits out the IO monad in standalone functions
05:52:59 <gwern> guess I'll try that. maybe if the monadic part is simpler, it'll be easier to figure out how to work it. monads really complicate things :(
05:53:33 <wli> I so wish that error were catchable from non-IO monads.
05:54:55 <kjdf> is there a way to catch exceptions not in IO monad - for example to make a function that wraps around a function with non-exhaustive pattern?
05:55:25 <ndm> nominolo`: the concensus is yes, the question is whether we need to go through the libraries submission process?
05:55:38 <ndm> and if so, perhaps we need a fast-track libraries submission process?
05:55:40 <hpaste>  Cress pasted "More ST trouble" at http://hpaste.org/2043
05:56:20 <wli> kjdf: Not an obvious way. :(
06:04:05 <hpaste>  int-e annotated "More ST trouble" with "try this" at http://hpaste.org/2043#a1
06:05:57 <quicksilver> kjdf: no. You shouldn't use exceptions for that
06:06:03 <quicksilver> kjdf: you should use Maybe or Either
06:06:27 <quicksilver> kjdf: 'Either' is very much like exceptions, just visible in the type
06:06:54 <wli> Well, I'd prefer it if the "usual" exceptions required monads to throw.
06:06:57 <kjdf> but calling a function with argument that doesn't match the pattern raises an exception
06:07:22 <sieni> so don't do that ;-)
06:07:43 <quicksilver> kjdf: it's not hard to put in a _ -> fail "Doesn't match" case
06:07:56 <quicksilver> kjdf: and that's what I'd recommend
06:08:12 <quicksilver> although you can use monadic pattern bindings to get that to happen automatically for some simple cases
06:10:25 <quicksilver> wli: that requires a rather different infrastructure than the one we have now, though
06:10:36 <wli> quicksilver: yeah :(
06:10:47 <quicksilver> and monads aren't about failure anyway
06:11:11 <wli> They are more general, but include such.
06:11:32 <wli> I'd say polymorphic in MonadError
06:11:53 <wli> For the return types of things that throw exceptions, that is.
06:16:56 <Baughn> Can you think of a more elegant way to say "and (zipWith (\a b -> toUpper a == toUpper b) name name2)"?
06:17:27 <hpaste>  Cress annotated "More ST trouble" with "(no title)" at http://hpaste.org/2043#a2
06:18:30 <psykotic> Baughn, zipWith (comparing toUpper) name1 name2?
06:19:14 <Cress> int-e: Thanks for the help.
06:19:16 <Baughn> psykotic: That's the function I was looking for, I think
06:19:23 <int-e> Cress: np
06:19:32 <doserj> but you cannot use and on the result :)
06:19:50 <hpaste>  Gwern annotated "(no title)" with "Refactored. Still not working though, problem with 'IO Bool'" at http://hpaste.org/2042#a2
06:20:06 <Baughn> psykotic: But where is it defined?
06:20:10 <wli> Baughn: There's also zipWith (curry (uncurry (==) . join (***) toUpper))
06:20:19 <wli> Baughn: Data.Ord
06:20:20 <Baughn> wli: No thanks.
06:20:20 <psykotic> you can use foldr (&&) True or something... but if that's the overall effect you want, maybe you'd looking for 'all'?
06:20:35 <Syzygy-> :t zipWith (curry (uncurry (==) . join (***) toUpper)
06:20:37 <lambdabot> parse error (possibly incorrect indentation)
06:20:41 <doserj> there is alo 'on' in newer ghc
06:20:42 <Syzygy-> :t zipWith (curry (uncurry (==) . join (***) toUpper))
06:20:44 <doserj> *also
06:20:45 <lambdabot> [Char] -> [Char] -> [Bool]
06:21:06 <doserj> zipWith ((==) `on` toUpper)
06:21:08 <gwern> > :info on
06:21:08 <lambdabot>  Parse error
06:21:20 <wli> Where's `on` defined?
06:21:35 <doserj> I think Data.Function in ghc HEAD ?
06:21:47 <int-e> doserj: right
06:22:28 <doserj> on f g x y = f (g x) (g y)
06:22:29 <nominolo`> ndm: hm, i'd say a submission process is good.  not sure what good criteria for a faster process would be
06:23:13 <int-e> Baughn: would ((==) `on` map toUpper) do the trick? or do you need the truncating behaviour of zip?
06:23:21 <ndm> nominolo`: bug fix or obvious generalisation, no addition/removal of exports
06:23:40 <Baughn> int-e: Actually, I forgot about the truncating behaviour. Having it is a very bad thing.
06:23:47 <ndm> i.e. changing the type signature in the Generics thing should have got the fast treatment, although in reality it just got put in directly
06:24:29 <nominolo`> ndm: hm, what's the regular deadline, and what should be a speed up deadline?
06:24:55 <Baughn> int-e: I'm also stuck on 6.6.1. But foldr (&&) should do the trick, I think.
06:25:05 <ndm> nominolo`: perhaps 1 week instead of 2, and no requirement to give a formal patch before you start
06:25:13 <int-e> Baughn: you can just define  on  yourself
06:25:15 <ndm> i.e. just a description of proposed changes
06:25:54 <Baughn> int-e: I'll only be using it once
06:26:48 <int-e> Baughn: ok, map toUpper name1 == map toUpper name2  then
06:27:24 <Baughn> int-e: ..I guess I was being excessively clever, trying to avoid even the hint of duplication
06:27:39 <Baughn> When the duplication-avoidance takes more space than the direct approach, it's time to give up
06:28:26 <quicksilver> Baughn: I would define on even if I only used it once
06:28:37 <quicksilver> Baughn: the definition is one extremely short line
06:28:46 <quicksilver> Baughn: it's a useful idiom and makes your code easy to read
06:28:50 <quicksilver> (and you might end up using it again!)
06:29:01 <Baughn> quicksilver: This way is probably easier to read. If I did that, I'd have to walk through lambdabot to see where I could use it, too.
06:30:08 <nominolo`> ndm: ok.  but lets keep things in order anyways: let's have a this fix be proposed with the normal 2 week deadline, and at the same time propose this fast submission process for future occasions
06:30:16 <quicksilver> Baughn: what do you mean? what's lambdabot got to do with it?
06:30:32 <Baughn> quicksilver: Oh, right. This was to fix a bug in lambdabot.
06:30:36 <quicksilver> ah :)
06:30:48 <nominolo`> ndm: since cabal-1.2 won't be released within the next two weeks, that'd be fine with me
06:30:49 <Baughn> quicksilver: It considers lambda and Lambda to be different nicks. Which is an issue for Baughnie.
06:30:49 <quicksilver> well I don't see how I local definition hurts anyone
06:30:57 <quicksilver> but it's your call :)
06:31:04 <ndm> nominolo`: cool, i'll submit it
06:31:58 <swiert> nominolo`: Will you be writing something about your SoC for the Monad.Reader?
06:32:38 * Igloo notes that the last time I fast tracked a proposal that I was confident wouldn't be opposed, ndm complained
06:33:01 <Igloo> (and didn't oppose)
06:33:02 <ndm> Igloo: only as i was on holiday :)
06:33:22 <Igloo> Ah, I see, so "ndm is not on holiday at the time" will be one of the rules for fasttracking?  :-)
06:33:30 <nominolo`> swiert: i don't think i can write much useful there.  all the intersting things to say can be found in the Cabal manual.
06:33:34 <ndm> Igloo: the most important one :)
06:34:25 <swiert> nominolo`: Sure - but I'm pretty certain there are plenty of TMR readers who aren't familiar with what cabal is and what the plan is for the Haskell libraries.
06:34:41 <swiert> Just look at the recent discussion on the definition of the standard haskell library @cafe.
06:35:29 <Tac-Tics> I think I had nightmares about Haskell last night
06:36:00 <swiert> Even if it's just a page or two about "this is what Cabal does" and this is where its going.
06:36:03 <nominolo`> swiert: hm, okay, let me think about it.  I certainly wouldn't want to do it alone though.  At least dcoutts_ or Igloo would need to help me with that.
06:36:26 <Arnar> hi there..
06:36:26 <nominolo`> swiert: or advise me while doing so
06:36:33 <dcoutts> nominolo`: we can review / comment
06:36:39 <swiert> Sure. No pressure - but it would be a good opportunity to expose your work.
06:36:51 <swiert> I'd be happy to read drafts.
06:36:57 <dcoutts> nominolo`: writing for TMR is a Good Thing(tm)
06:37:13 <Arnar> I want to play with arrows stuff like &&& and >>> in ghci.. what do I have to do to bring them into scope (tried ghci -farrows so far)
06:37:24 <quicksilver> :m Control.Arrow
06:37:30 <Arnar> quicksilver: thanks..
06:37:47 <dcoutts> nominolo`: my refactoring continues apace..
06:37:49 * wli wishes for a newer ghc in Debian.
06:37:51 <nominolo`> dcoutts: i know.  but it has certain standards (or expectations) :)
06:37:56 <dcoutts> nominolo`: true
06:38:03 <dcoutts> it takes time
06:38:08 <wli> dcoutts: What are you refactoring?
06:38:12 <dcoutts> wli: cabal
06:38:13 <xerox> wli: build your own, is fun :-)
06:38:35 <swiert> nominolo`: Sure. But the SoC special is specifically about a short "report from the trenches" explaining what you've been working on.
06:38:49 <wli> xerox: I've done that enough times... it screws with the auto-upgrades.
06:38:51 <swiert> Even if it seems insignificant to you, I'm sure there are plenty of people who might be interested.
06:39:02 <dcoutts> swiert: ah so you're expecting more shorter articles this time?
06:39:05 <nominolo`> swiert: i see
06:39:10 <xerox> wli, do you install from sources or build a new .deb?
06:39:38 <dcoutts> wli: you could always switch to gentoo, we've got ghc-6.6.1 and >150 libs
06:39:43 <dcoutts> :-)
06:39:45 <wli> xerox: Usually debs, but even that hurts.
06:39:51 <Igloo> wli: DYM a newer ghc-cvs?
06:39:52 <swiert> dcoutts: I e-mailed all the SoC-ers requesting a short submission about their project.
06:40:00 <dcoutts> swiert: great
06:40:07 <xerox> wli: build from sources live very peacefully in my ubuntu installation, even wrt updates.
06:40:08 <wli> dcoutts: I'm not destroying my installation for anything.
06:40:11 <swiert> I'd like to put together a special issue towards the end of the summer.
06:40:23 <wli> Igloo: That would do.
06:40:24 <dcoutts> swiert: aye, that sounds like a great idea
06:40:36 <Igloo> wli: Well 6.6.1 is already in testing+unstable
06:41:06 <wli> Igloo: Yeah, I'm there already.
06:41:35 * Igloo doesn't understand what you want, then, if it's not a newer ghc-cvs
06:41:45 <wli> I'm just hitting crud like (>=>) and (`on`)
06:42:01 <wli> Igloo: I guess newer ghc-cvs, then.
06:42:40 <phoniq> 2/
06:42:48 <nominolo`> swiert: i didn't get any mail from you, yet (i think)
06:43:28 <nominolo`> swiert: ah, bcc
06:43:50 <nominolo`> swiert: i only take mail adressed directly to me seriously
06:44:02 <swiert> Yes - I wasn't sure if everyone wanted to share their e-mail addresses.
06:44:29 <nominolo`> we're just 9 -- you could have sent personally
06:44:33 <swiert> Some people can be a bit picky about privacy.
06:46:20 <nominolo`> yes, i meant, you could have sent the mail 9 x .  Anyways, now I've seen it
06:46:47 <swiert> Good. I'll send out a reminder to everyone individually in a few weeks.
06:47:57 <nominolo`> swiert: do you have a prepared latex stylesheet?
06:48:16 <nominolo`> ah, i guess it's on the wiki
06:48:25 <swiert> http://www.haskell.org/sitewiki/images/9/9f/TMR.zip
06:48:48 <desegnis> @hoogle Handle -> IO (Maybe FilePath)
06:48:49 <lambdabot> No matches, try a more general search
06:48:57 * desegnis is disappointed
06:49:01 <balodja> hi, how do haskell compilers resolve functional dependency in instances of "class D a b | a -> b where"? just make sure of consistency?
06:51:34 <balodja> so, the best to specify "class D" precisely is to declare one instance?
06:53:03 <desegnis> balodja, I suppose they just make sure that you do not declare conflicting instances
06:53:24 <desegnis> what else to do?
06:55:18 <quicksilver> for each instance they check that they can generate type variables in the one from the other
06:55:23 <quicksilver> and that none of the instances overlap
06:56:18 <quicksilver> there is some info at http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies
06:56:21 <lambdabot> Title: FunctionalDependencies - Haskell Prime - Trac, http://tinyurl.com/32qu3g
06:58:09 <balodja> I have read http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#functional-dependencies, and there is a question about the example, mentioned there
06:58:10 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
06:58:21 <balodja>  instance D Bool Int where ...
06:58:23 <balodja>   instance D Bool Char where ...
06:59:23 <balodja> if I declare "instance D Bool Int" another should be "instance D Char Int", for example?
06:59:34 <wli> Are there any circumstances under which it's not valid to move class qualifiers outside the type? Like some type variable embedded in a type expression unified with one having a qualifier?
07:00:01 <quicksilver> Boney: that would be permitted; a -> b but not b->a
07:00:23 <fasta> What's the most probable cause of error when I miss the instance MonadState (Int,  String) m?
07:00:53 <balodja> ok, thanks
07:01:35 <fasta> This code gets run in a newtyped StateT monad already: i.e. runFooT (where FooT calls runStateT)
07:01:53 <Saizan> fasta: result of get used with the wrong type?
07:10:29 <jamesnvc> hello
07:11:02 <jamesnvc> I'm wondering if anyone would be able to give me a hand with building haskell-src
07:12:10 <Saizan> jamesnvc: what's the problem? where did you get the sources from?
07:14:03 <jamesnvc> I've downloaded the source via darcs from darcs.haskell.org
07:14:36 <jamesnvc> The problem is that, when I do runghc Setup.hs build, I get the message: "Could not find module `Text.PrettyPrint':
07:14:36 <jamesnvc>       it was found in multiple packages: pretty-1.0 base"
07:14:36 <jamesnvc>  
07:15:18 <jamesnvc> If I try to unregister/hide pretty-1.0, then it complains during configuration that it couldn't satisfy the dependency for pretty-any
07:15:36 <jamesnvc> And if I try to unregister base, then obviously nothing works
07:16:25 <dcoutts> jamesnvc: use a released tarball not the development version
07:16:29 <dcoutts> get it from hackage
07:16:36 <dcoutts> @hackage haskell-src
07:16:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src
07:16:52 <jamesnvc> Thank you
07:17:13 <dcoutts> you're welcome :-)
07:17:43 <fasta> dcoutts: When I add remove a lift, the type of the function does not change, but my program goes into an infinite loop. When I add the lift, the program works. Isn't that a rather weird feature?
07:18:04 <dcoutts> fasta: beware of automatic lifting ;-)
07:18:25 <fasta> dcoutts: yes, you mean, that I asked for this hell.
07:18:46 <dcoutts> fasta: I guess so, though I don't mean it in a sadistic way :-)
07:19:09 <fasta> dcoutts: AFAIK, this is StateT behaviour.
07:19:20 <fasta> dcoutts: I am not 100% positive, though.
07:19:42 <dcoutts> fasta: check with someone who uses/understands StateT better than me
07:19:58 <Saizan> do you have more than one possible "real" monadstate in your stack?
07:20:05 <fasta> dcoutts: Nah, never mind. It would take longer to explain than to solve it.
07:20:10 <fasta> Saizan: no
07:50:44 <sehute> Hi, I'm playing with Hugs and it's been a while since last I tried Haskell. If I type in "do { n <- readLn ; print (n^2) }" it works fine for numbers, but not strings, why?
07:50:48 <sehute> oh
07:50:49 <sehute> nvm
07:51:08 <sehute> but why does this not work: do { n <- readLn ; print (n^2) }
07:51:11 <sehute>  do { x <- 5 ; print (readLn) }
07:51:18 <sehute> the one with readLn
07:51:21 <sehute> I mis-pasted
07:51:25 <Cale> 5 isn't something which you can run
07:51:30 <Cale> do { n <- readLn ; print (n^2) } ?
07:51:34 <RyanT5000> and readLn isn't something you can print
07:51:55 <sehute> I understand that the first one fails, since ^2 can only apply to numbers
07:51:59 <Cale> do { n <- readLn ; print (n^2) } -- this should work
07:52:10 <Cale> (in fact, it does)
07:52:27 <sehute> ok, thanks
07:52:35 <sehute> but the second one, the one with readLn, why does that one fail?
07:52:45 <Cale>  do { x <- 5 ; print (readLn) } -- this one?
07:52:49 <sehute> yes :)
07:52:56 <Cale> Okay, two reasons
07:53:05 <desp> sehute: because readLn returns a value in the IO monad, and print doesn't want to take a value of that type
07:53:08 <Cale> 5 isn't an action, so it can't occur on the right side of <-
07:53:21 <desp> @type readLn
07:53:23 <lambdabot> forall a. (Read a) => IO a
07:53:23 <Cale> and secondly, print wants something which can be displayed to the user
07:53:40 <sehute> okay
07:53:43 <Cale> but there's no default way to turn  readLn, which is an action, into a string
07:54:06 <Cale> readLn is not a string, it's an action which if run will produce a string
07:54:24 <sehute> okay, so how can I say that I want to run the action first?
07:54:31 <sehute> put it earlier on in the do-block?
07:54:35 <Cale> yeah
07:54:40 <sehute> great
07:54:51 <Cale> or by using a function which makes the appropriate combination
07:54:56 <sehute> do { n <- readLn ; print (n) }
07:55:01 <sehute> but this one doesn't work either, how come?
07:55:10 <Cale> uh, it does
07:55:22 <sehute> Program error: user error (PreludeIO.readIO: no parse)
07:55:23 <Cale> What error are you getting?
07:55:25 <Cale> oh
07:55:30 <Cale> what are you typing?
07:55:37 <sehute> "a"
07:55:40 <Cale> readLn is probably defaulting to reading a number
07:55:41 <sehute> without the quotes
07:55:53 <sehute> okay?
07:56:09 <RyanT5000> sehute: if you want to get a string from the console, use getLine
07:56:13 <Cale> The trouble is that these functions are generic
07:56:36 <RyanT5000> sehute: then, to print it without putting quotes around it (and other such stuff) use putStr or putStrLn
07:56:40 <sehute> okay, so readLn isn't the type of readline I'm used to from other languages, but getLine might be?
07:56:55 <Cale> yes
07:57:05 <sehute> that was a bit confusing
07:57:10 <Cale> readLn will read any sort of data structure that's in the Read class
07:57:10 <sehute> okay, I'll try getLine
07:57:23 <Cale> (but only if it knows what kind you want)
07:57:24 <doserj> Cale: the defaulting happens in ghci. ghc fails to compile, as it should
07:57:32 <Cale> doserj: Or hugs
07:57:46 <sehute> ah, getLine and putStrLn works perfectly well toghether, thanks
07:57:47 <doserj> yep
07:57:56 <sehute> I'm using hugs now, yes
07:58:24 <sehute> Cale: so, how can I tell readLn to read strings?
07:58:36 <Cale> If the hugs prompt can't figure out what type you want to make something because there's not enough context, it'll usually try defaulting to Integer
07:59:06 <Cale> By either giving a type signature, or ensuring that the thing you get is really used as a string
07:59:18 <Cale> But if you use it to read strings, they'll have to be quoted strings.
07:59:39 <Cale> Because the read/show instances for strings expect/add quotes.
08:00:16 <sehute> I tried typing "a", but I guess that wasn't what you meant with quoted strings?
08:00:28 <Cale> Hugs.Base> do { xs <- readLn; print (map (*2) xs) }
08:00:28 <Cale> [1,2,3,4]
08:00:28 <Cale> [2,4,6,8]
08:00:44 <sehute> nice one :)
08:00:52 <sehute> but "a" is a no-no
08:00:53 <Cale> Hugs.Base> do { xs <- readLn; putStrLn xs }
08:00:54 <Cale> "Hello"
08:00:54 <Cale> Hello
08:01:07 <Cale> It's all about which type is expected.
08:01:24 <sehute> but, why does the combination of readLn and print fail when typing in "a"?
08:01:27 <Cale> It will choose which parser to use based on how its result is used.
08:01:35 <geezusfreeek> sehute: for do { n <- readLn; print (n::String) }, you should enter "hello" and it will output "hello" (including the quotes in both the input and the output)
08:01:43 <Cale> Oh, because print doesn't fully determine which type to print
08:01:57 <Cale> So there's actually a lack of information about which type is being used there at all.
08:02:17 <Cale> (read could read any number of things, print could print any number of them)
08:02:17 <sehute> so, putStrLn is "smarter" than print?
08:02:23 <RyanT5000> Cale: wouldn't this be a good time to use soft typing?
08:02:32 <tonfa> do you have a pointer for reading binary data in haskell (with conversion from network order to cpu order) ?
08:02:40 <matthew-_> sehute: no, less smart. putStrLn demands a String
08:02:41 <Cale> print is being too smart for its own good... yeah, let's look at the actual types of these things :)
08:02:48 <RyanT5000> tonfa: yes, but i'm not sure about the network order thing
08:02:59 <geezusfreeek> print :: (Show a) => a -> IO ()
08:03:00 <Cale> readLn :: (Read a) => IO a
08:03:06 <geezusfreeek> putStrLn :: String -> IO ()
08:03:09 <tonfa> RyanT5000: tell me anymay
08:03:16 <RyanT5000> tonfa: Foreign.Ptr, Data.Binary, Data.ByteString, Foreign.Marshal
08:03:20 <RyanT5000> tonfa: those are good places to look
08:03:28 <Cale> getLine :: IO String
08:03:32 <tonfa> RyanT5000: thanks
08:03:50 <sehute> okay, so print takes an a "tagged with" Show and returns something IO ?
08:04:02 <RyanT5000> tonfa: foreign is for memory (for C interop, etc.), the other two are more for files - although of course you can make good use of any of them in various contexts
08:04:15 <tonfa> ok
08:04:25 <sehute> I haven't completely wrapped my brain around the concept of monads yet
08:04:32 <Cale> print, for all types a, if a is a Showable type, produces an action to display a value of type a on the screen.
08:04:52 <Cale> It's not really the monad which is the worry here.
08:04:55 <sehute> the IO/do/-> thing seems okay, and thinking of "tagging" and "tainting" seems fine too, but the spacesuit-pipes-stuff just gets too much
08:05:13 <Cale> I'll point you at some better monad tutorials in a moment :)
08:05:24 <Cale> But this is really about typeclasses.
08:05:36 * fasta can't see the word "monad tutorial" anymore
08:05:39 <Cale> Let's forget about IO for a moment :)
08:05:46 <matthew-_> sehute: think of it this way: you could have defined an instance of Read for which "a" means something specific. Thus, to convert the String "\"a\"" to any value for print needs to work out which instance of Read to call. Sure, it could be String, but it could equally be something else.
08:05:48 <Cale> and look at 'read' and 'show'
08:05:59 * fasta needs to program his IRC client and automatically ignore all that stuff
08:06:12 <Cale> :t read
08:06:17 <Cale> :t show
08:06:18 <sehute> matthew_: sorry, but I need it more dumbed-down right now :)
08:06:18 <lambdabot> forall a. (Read a) => String -> a
08:06:20 <lambdabot> forall a. (Show a) => a -> String
08:06:38 <Cale> read takes a string and produces a readable value
08:06:54 <Cale> show takes a showable value and produces a String
08:06:59 <sehute> okay, I'm doing :t read and :t show in hugs
08:07:10 <Cale> okay
08:07:17 <Cale> So try   read "52"
08:07:20 <sehute> okay, same things as lambdabot
08:07:25 <RyanT5000> sehute: basically, any time you use a read* function, it has to be able to figure out exactly what type the thing is going to be
08:07:38 <Cale> oh, for some reason hugs likes to complain about that one :)
08:07:39 <RyanT5000> Cale: this is why i hate defaulting on Int and stuff like that
08:07:49 <Cale> > read "52"
08:07:53 <lambdabot>  52
08:07:53 <sehute> ERROR - Unresolved overloading
08:07:55 <desp> monomorphic restriction?
08:07:56 <Cale> right
08:08:11 <Cale> desp: not necessarily :)
08:08:11 <sehute> now, why is hugs so bitchy compared to ghc? :)
08:08:12 <RyanT5000> Cale: read "52" shouldn't work; why is it a good idea?
08:08:37 <RyanT5000> sehute: do you know about overloading in C++?
08:08:38 <desp> RyanT5000: everyone loves Integers!
08:08:40 <sehute> okay, so read "52 doesn't work and I'm more confused than before ;)
08:08:53 <Cale> sehute: Hugs is really actually right about this one :)
08:09:01 <sehute> RyanT5000: just barely, I'm more familiar with the __str__ conventions in Python
08:09:15 <Cale> sehute: GHCi is actually more permissive than it should be -- it guesses that you want to read an integer if it doesn't know.
08:09:22 <sehute> okay
08:09:28 <Cale> (In a compiled GHC program it won't guess)
08:09:38 <doserj> > show (read "52") -- :)
08:09:39 <lambdabot>  "52"
08:09:59 <sehute> okay, so how do I whip hugs until it does the read-show dance? :)
08:10:15 <Cale> show (read "52" :: Int)
08:10:27 <Cale> show (read "[1,2,3]" :: [Int])
08:10:28 <Saizan> matthew-_: i've seen yesterday on the channel that you've a Control.Monad.Session, has it anything to do/could be used for webservers?
08:10:42 <sehute> hey, it worked, brilliant :)
08:10:45 <Cale> add type signatures :)
08:10:54 <sehute> but "52" :: Int does not work
08:11:02 <Botje> because that's a string, not an int
08:11:04 <sehute> so the :: Int is directed at the read-function somehow
08:11:07 <Cale> yes
08:11:14 <Botje> :t read "52"
08:11:16 <lambdabot> forall a. (Read a) => a
08:11:21 <Cale> it applies to  read "52"  as a whole
08:11:23 <desp> sehute: the type signature defines the type of the value that you're expecting read to return
08:11:25 <sehute> how does haskell know that :: Int is meant for read and not for 52?
08:11:29 <Botje> haskell determines what type to read via the return value
08:11:32 <sehute> okay
08:11:37 <Cale> It's meant for the entire expression before it
08:11:43 <sehute> great, thanks
08:11:46 <desp> sehute: simple, :: has a lower precedence than function applicatoin
08:11:52 <resiak> What's the most straightforward way to run an external command (noninteractively) and get its output?
08:12:02 <Cale> :: has a lower precedence than anything, really
08:12:13 <sehute> so this is how it's grouped: show(read("52") :: Int)
08:12:31 <desp> sehute: actually, (show ((read "52) :: Int))
08:12:38 <Cale> yeah, only the parens around "52" there are spurious :)
08:12:45 <desp> (show ((read "52") :: Int))
08:12:49 <Baughn> resiak: runInteractiveProcess
08:12:52 <RyanT5000> sehute: function calls in haskell don't use parentheses like python
08:13:10 <RyanT5000> sehute: so where you'd have f(x) in python, you have (f x) in haskell, or just f x
08:13:32 <sehute> RyanT5000: thanks, I know
08:13:37 <Cale> Function application is so important to us that we use space for it :)
08:13:46 <RyanT5000> sehute: k :)
08:14:04 <sehute> okay, so why is there an extra paranthesis around the whole expression?
08:14:16 <Cale> that's not necessary either :)
08:14:22 <sehute> okay
08:14:26 <desp> I just put that to make the grouping more explicit :)
08:14:31 <sehute> okay, great
08:14:39 <RyanT5000> sometimes if i'm talking in chat i put parentheses around it to set it off from the english
08:14:49 <matthew-_> and to remind us of LISP
08:14:56 <Cale> Okay, so back in the I/O example, it should be clearer what's going on...
08:14:59 <sehute> now, why doesn't this work: putStrLn(read("52") :: Double)
08:15:08 * SamB_XP_ wonders what "totally and permanently disabled" means in the context of student loans
08:15:11 <resiak> Baughn: oh, duh, I misread its signature as requiring handles to be passed as parameters.  Thanks.  :-)
08:15:13 <Cale> readLn = do x <- getLine; return (read x)
08:15:18 <Botje> SamB_XP_: "dead"?
08:15:31 <fasta> matthew-_: You are referring to the 50 year old language?
08:15:34 <Lemmih> sehute: putStrLn takes a String, not a Double.
08:15:35 <Cale> sehute: putStrLn wants a string, not a Double
08:15:39 <SamB_XP_> "If you become totally and permanently disabled or you die, your loan obligation will be canceled."
08:15:41 <desp> @quote stereo
08:15:42 <lambdabot> No quotes match. You type like i drive.
08:15:46 <desp> !
08:15:52 <Cale> Mwahahaha
08:16:05 <Cale> sehute: try print :)
08:16:15 * SamB_XP_ was frankly getting sick of @quote stereo too
08:16:16 <sehute> ok :)
08:16:17 <Cale> print = putStrLn . show
08:16:35 <Cale> readLn = do x <- getLine; return (read x)
08:16:38 <Cale> or
08:16:47 <Cale> readLn = fmap read getLine
08:16:58 <sehute> tlf, brb
08:17:46 <matthew-_> SamB_XP_: it should just be the topic
08:18:20 <fasta> Monadifying code is a pain, btw.
08:18:48 <SamB_XP_> matthew-_: you want to replace "The Haskell programming language: got types?" with that?
08:21:35 <matthew-_> SamB_XP_: ok, maybe the solution to the ICFP prog.contest 2007 then...
08:21:56 <SamB_XP_> huh?
08:22:07 <Baughn> > fmap read ["12","13"] :: [Int]
08:22:15 <SamB_XP_> the solution to the ICFP 2007 contest wonn't fit the topic
08:22:15 <lambdabot>  [12,13]
08:22:21 <matthew-_> really?
08:22:49 <SamB_XP_> unless it's really tiny!
08:23:01 <fasta> SamB_XP_: I think it uses the word "Haskell" a bit too much now
08:23:36 <Cale> (\x -> ...x...x... ) Haskell
08:24:08 <mrd> :t Haskell
08:24:10 <lambdabot> Not in scope: data constructor `Haskell'
08:28:18 <SamB> hmm.
08:28:40 <SamB> cabal-devel rejected my patch automatically :-(
08:29:57 <SamB> oh, uh, stack lambdabot today: http://www.ohloh.net/projects/7054
08:29:59 <lambdabot> Title: lambdabot - Ohloh
08:30:03 <Baughn> @quote xkcd
08:30:03 <lambdabot> No quotes match. That's something I cannot allow to happen.
08:37:13 <sehute> if I were to make a game in Haskell, and needed a while-loop, would it be natural to use recursion instead?
08:37:35 <RubberHound> Hi, I've recently started to get interested in haskell and I like what I've seen so far. I also tried "selling" it to a friend from work, and I couldn't quite expain to him the benefits of knowing haskell (or functional programming as a whole). Can any of you think of some sort of "marketing" sentence for haskell?
08:37:37 <sehute> even though the recursion would last for the entire game?
08:37:48 <integral> @type forever
08:37:50 <lambdabot> Not in scope: `forever'
08:38:08 <Lemmih> sehute: Well, you don't really have a choice in Haskell.
08:38:14 <AHTOH> Hi All, i have a following problem running ghc-661 -O2 compiled program: haskell binary has 100% load, while bash running it also has 100% load (on secod core), can anyone give a fresh idea. googling/haskell.org reading gave no help///
08:38:17 <integral> @type keepdoingit m = do { m; keepdoingit m }
08:38:19 <lambdabot> parse error on input `='
08:38:46 <sehute> the tail-recursiveness will optimize the loop so that it doesn't use more and more memory, of course?
08:39:19 <Vulpyne> RubberHound: One nice thing about it is it makes you solve problems in a completely different way.
08:39:21 <sehute> RubberHound: it teaches you a new, and more powerful, way to think about programming
08:39:30 <Vulpyne> Hmm. Where's that stereo quote? :)
08:39:41 <Lemmih> AHTOH: Looking for performance tips?
08:39:57 <sehute> RubberHound: it's well thought-out
08:40:12 <AHTOH> Lemmih: already read preformance tips page, nothing about it :(
08:40:21 <RubberHound> I've tried those, I didn't seem to make any impression on him, he asked me how it will improve him as a programmer.
08:40:23 <RubberHound> I'
08:40:48 <RubberHound> I'm asking you because I couldn't come up with answers, and i think it's because of my lack of experience with the language
08:41:30 <AHTOH> RubberHound: the programs are 100 times shorter any 1000 times more easy to write
08:41:42 <Lemmih> AHTOH: I didn't understand your initial question. Are you looking for help optimizing your program?
08:42:07 <DeeJay> RubberHound: what languages does your friend normal use as a programmer?
08:42:22 <DeeJay> *normally
08:42:26 <RubberHound> well, the usual C++
08:42:33 <RubberHound> most common language
08:42:35 <cjeris> did you show him the haskell quicksort?
08:42:36 <AHTOH> Lemmih: just a hint: why can be a bash load so hi, while running a haskell programm? is that issue of my code?
08:42:43 <RubberHound> I will
08:43:19 <earthy> ask him if he understands the implications of the fact that C++ templates are turing capable
08:43:26 <RubberHound> Heh, the quicksort was actually what got me interested in first place :)
08:43:32 <sehute> RubberHound: yes, haskell quicksort is a nice example
08:43:38 * DRMacIver shrugs
08:43:38 <lambdabot> DRMacIver: You have 1 new message. '/msg lambdabot @messages' to read it.
08:43:45 <DRMacIver> I find the Haskell quicksort example both dishonest and uncompelling. :)
08:44:06 <sehute> RubberHound: if you write a program, you get the feeling that it's rock solid, compared to C or C++ that often has the feeling that anything may go wrong
08:44:37 <DRMacIver> In that it's not a very good implementation and doesn't really convey why Haskell is nice.
08:44:46 <sehute> RubberHound: hence the obsessive return-value checking
08:44:49 <DRMacIver> Not that I have a better example. :)
08:45:08 <sehute> RubberHound: "in Haskell you can't forget to check a return-value", that's an argument for you
08:45:15 <earthy> I think the runlength encoding thing is sweet
08:45:15 <gkr> DRMacIver but it sells.
08:45:17 <Baughn> For one-liners, the fibonnaci generator seems elegant
08:45:43 <Baughn> sehute: You can, though
08:45:48 <cjeris> DRMacIver: It's less an example of algorithmic efficiency than an example of the mental habit of saying what you mean.  That's the crucial advantage of functional programming: you can say what you mean.
08:45:49 <earthy> oh, and building a complete directory tree in about 5 lines of code is sure to get a C++ programmer's attention
08:45:50 <sehute> Baughn: details ;)
08:46:13 <Tac-Work> > take 10 fibs where fibs = 0 : 1 : [x + y | (x, y) <- zip fibs (tail fibs)]
08:46:13 <lambdabot>  Parse error
08:46:19 <Tac-Work> damn you lambda bot
08:46:22 <sehute> Baughn: Can you, btw? I'm too n00b at Haskell to know. An example? :)
08:46:37 <Cale> DRMacIver: I don't think I properly understood quicksort in any language until I saw the quicksort in Haskell :)
08:46:37 <moonlite_> DRMacIver: i think it is a good example. It states that a Haskell function can be more like an equation than a normal imperative function
08:46:41 <DeeJay> RubberHound: maybe show him a Haskell solution to a small problem that he usually solves with C++ at work - it is more than likely to be a wholly different approach to solving the problem
08:46:52 <moonlite_> Cale: same :)
08:47:16 <sehute> Cale&moonlite: re
08:47:56 <Cale> hello
08:48:14 <Baughn> sehute: Anything in a monad, basically
08:48:16 <RubberHound> Thanks for all the help guys
08:48:22 <Baughn> sehute: Or pattern-matching with _
08:48:33 <Tac-Work> 'where' is a little weird when used on one line
08:48:35 <sehute> Baughn: ah, okay. You're right :)
08:49:00 <RyanT5000> Tac-Work: fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
08:49:11 <cjeris> Haskell offers eternal freedom from the leaden shackles of non-recursion, the menacing spiked ceiling of non-first-class functions, and the sucking mud bog of mutation.
08:49:17 <RyanT5000> zipWith is cleaner than a list comprehension
08:50:24 <RyanT5000> cjeris: and replaces it with the slightly higher, slightly less menacing of non-first-class types, and the slightly calmer, slightly dryer bog of a crap module system
08:50:55 <RyanT5000> :P
08:50:56 <cjeris> RyanT5000: shh, we're trying to do marketing here.
08:51:48 <RyanT5000> well, it's not like there are any languages that do much better :)
08:52:17 <cjeris> there's Coq, if you can live with totality and the most annoying extensible-syntax-thing ever :D
08:53:09 <DRMacIver> RyanT5000: Well, I think there are a number of better module systems out there. :)
08:53:18 <moonlite_> nominolo: hi there. How's the SoC going?
08:53:22 <RyanT5000> DRMacIver: i won't argue with that :P
08:53:34 <moonlite_> nominolo: Mattias from Chalmers here btw...
08:53:59 <RyanT5000> i meant the language as a whole
08:55:42 <cjeris> where could I look for information on recent developments in improving haskell's module system?
08:56:07 <sehute> if I try out this line in hugs: interact f where f x = "hi " ++ x
08:56:17 <sehute> why does it first say "hi", then wait for input, then echo the input?
08:56:33 <sehute> why doesn't it first ask for input, then echo "hi " plus the input?
08:56:34 <Baughn> sehute: Semantic of stream I/O
08:56:51 <SamB> cjeris: I don't think the module system itself has changed in ages, really
08:56:58 <Baughn> sehute: The program is driven by output
08:57:06 <sehute> Baughn: then how can interact be used for anything useful?
08:57:18 <SamB> cjay: or are you looking for papers about ideas for improving it?
08:57:18 <sjanssen> sehute: buffering, probably
08:57:21 <SamB> er.
08:57:26 <SamB> s/cjay/cjeris/
08:57:26 <sehute> oh, okay
08:57:37 <sjanssen> sehute: try hSetBuffering stdin NoBuffering
08:57:45 <sehute> sjanssen: how is the unicode-thing going, btw? :)
08:57:58 <sehute> sjanssen: thanks, I will
08:57:59 <cjeris> SamB: yes, exactly.
08:58:09 <Baughn> sehute: By making output dependent on input
08:58:09 <cjay> o_O
08:58:15 <SamB> lets see
08:58:23 <SamB> people have been mentioning one a fair bit...
08:58:34 <Baughn> sehute: It might make more sense if you look at the source of interact
08:58:36 <Baughn> @src interact
08:58:36 <lambdabot> interact f = do s <- getContents; putStr (f s)
08:58:41 <SamB> @go modular typeclasses
08:58:45 <lambdabot> http://freshmeat.net/projects/streams/
08:58:46 <lambdabot> Title: freshmeat.net: Project details for Streams
08:58:50 <SamB> hmm./
08:58:51 <sehute> Baughn: cool lambdabot-command :)
08:59:05 <sjanssen> sehute: I haven't been working on that lately
08:59:10 <sehute> Baughn: ah, that does make sense, thanks :)
08:59:15 <sjanssen> sehute: you're referring to last year's SoC, right?
08:59:17 <Baughn> sehute: Point is, getContents (and thus interact's input) is lazy; it reads no more input than you actually use
08:59:17 <sehute> sjanssen: yes :)
08:59:33 <SamB> http://www.cse.unsw.edu.au/~chak/papers/DHC07.html
08:59:34 <lambdabot> Title: Research Papers of Manuel Chakravarty
08:59:36 <Baughn> sehute: Whenever you /do/ use the input, it blocks on stdin
08:59:39 <sehute> Baughn: I see. But getLine would act differently?
08:59:48 <SamB> cjeris: I think that's the one there
08:59:57 <Baughn> sehute: I'm pretty sure it does, yes
09:00:31 <Baughn> sehute: If lazy i/o becomes hard to reason about, use strict monadic i/o instead.
09:00:45 <Baughn> (Or if you want to handle errors)
09:01:07 <sehute> Baughn: actually I think I got it after you showed me the source, but I agree that monadic IO might be easier to reason about until I get used to the lazyness
09:02:05 <Baughn> sehute: Your example isn't the epitome of complexity, though. Try an interact-like function where the i/o essentially reimplements tcp/ip sometime..
09:02:14 <geezusfreeek> sehute: i think the general idea with haskell is to try to keep things easier to reason about whenever possible, even if you are an expert
09:02:35 <cjeris> SamB: excellen kthxbbq
09:02:43 <Baughn> sehute: Well, that's where abstraction helps, and stream i/o was actually the easier choice there
09:03:44 <sehute> great, thanks, I'm learning a lot from you bunch
09:03:50 <SamB> geezusfreeek: yes but once you get comfy with nonstrict/pure functional programming, you're likely to have an easier time reasoning about interact a lot of the time
09:04:16 <sehute> :)
09:05:40 <SamB> of course, interact is only applicable when you are writing a filter from stdin to stdout...
09:06:06 <SamB> and hGetContents is a good bit trickier to reason about than interact
09:06:08 <sehute> SamB: so, interact is perfect if you're writing some sort of grep?
09:06:25 <Baughn> sehute: interact is best if your program doesn't actually interact
09:06:25 <SamB> sehute: probably
09:06:37 <sehute> Baughn: that's intuitive :D
09:06:40 <sehute> I see
09:06:41 <SamB> yeah. it's a poor name ;-)
09:06:58 <Baughn> sehute: Output is normally dependent on input. If input also becomes dependent on output, you start having to /think/.
09:07:03 <sehute> I would suggest "iofilter" or something, but I guess the names are all carved in stone by now
09:07:23 <SamB> (and *probably* not use interact ;-)
09:07:32 <SamB> sehute: you might be surprised.
09:08:01 <Cale> I'll be eternally disappointed if Haskell doesn't have a major Prelude revision at some point.
09:08:22 <sehute> Baughn: true, it gets second order all over the place
09:08:33 <SamB> here's to Haskell 2
09:08:45 <sehute> SamB: is there a place where one can make suggestions for Haskell 2?
09:08:45 <chessguy> howdy
09:08:47 <Cale> You can write properly interactive programs with interact, it's just confusing to do so.
09:08:57 <chessguy> @where haskell'
09:08:57 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
09:09:06 <SamB> haskell' isn't going to be Haskell 2
09:09:15 <Cale> haskell' is just Haskell 1.6 :)
09:09:24 <Baughn> haskell '09, maybe
09:09:28 <SamB> sehute: I guess we could carve out a corner of the wiki
09:09:30 <chessguy> presumably haskell' is what he was referring to
09:09:32 <SamB> Baughn: that's too damn confusing
09:09:51 <Baughn> SamB: We've got haskell'98 now, though
09:09:53 <SamB> Baughn: I really want to go back to 1.x ;-)
09:09:55 <Cale> There used to be a wiki article, but I think the only way to really make things happen is unfortunately just to do them :)
09:10:21 <chessguy> that's why i say haskell's slogan should be "patches welcome!"
09:10:22 <Cale> I've been toying with the idea of forking fptools :)
09:10:33 <SamB> Cale: how do you do radical changes incrementally?
09:10:46 <SamB> chessguy: I thought it was
09:10:52 <Cale> By making radical changes. :)
09:10:54 <SamB> that's what we use darcs for
09:11:21 <chessguy> SamB, at the moment, it seems to be "got types?"
09:11:25 <lament> "the only way to really make things happen is just to do them"
09:11:29 <chessguy> @topic- #haskell
09:11:29 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell dice dict docs join source time todo type
09:11:29 <lament> :)
09:11:35 <chessguy> @topic-tell #haskell
09:11:35 <lambdabot> ["A Taste of Haskell: http://blip.tv/file/324976 http://www.blip.tv/file/325646/","The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://
09:11:35 <lambdabot> tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]
09:11:39 <SamB> Cale: so are you going to make a base2 package?
09:12:30 <Cale> SamB: :)
09:12:34 * SamB hopes really internal stuff is moving into a more core package
09:12:42 <Cale> It's an interesting idea anyway.
09:12:49 <SamB> Cale: you should try it.
09:13:20 <chessguy> hm
09:13:21 <Cale> I'm not certain about my ability to work up the momentum to start on something like that :)
09:13:31 <SamB> and when it doesn't work, you should make them restructure the implementation so as to allow multiple base packages to actually work
09:13:52 <Cale> Yeah, that's what we really need
09:13:53 <chessguy> so foo :: Parser Char is really foo Either Error Char?
09:14:01 <chessguy> modulo any  missing ::'s
09:14:06 <Cale> Also, there needs to be some changes in the compiler itself I'm afraid.
09:14:14 <SamB> and then we can get monad comprehensions back
09:14:16 <Cale> chessguy: not really
09:14:23 <SamB> Cale: I know ;-)
09:14:30 <Cale> chessguy: Though in my little tutorial, I didn't make the difference clear
09:14:39 <SamB> Cale: that's why I said "and when it doesn't work"
09:14:47 <Cale> SamB: Also, do-notation :)
09:15:02 <chessguy> Cale, err, i'm not looking at your tutorial at the moment
09:15:04 <SamB> Cale: we already have do notation
09:15:06 <Cale> chessguy: oh :)
09:15:11 <fasta> Is there an array type that can 1) contain any kind of value, 2) is not initialized with an error "value" (i.e. getting such a value is a constant time operation)?
09:15:14 <Cale> SamB: Yeah, but the translation is wrong.
09:15:21 <SamB> Cale: ah.
09:15:35 <Cale> SamB: I want to abolish 'fail'
09:15:38 <fasta> There is STUArray, but that is only for one dimensional arrays
09:15:45 <SamB> Cale: please no abolish
09:15:53 <chessguy> Cale, whatever it is under the hood, though, it can be treaded as type Parser = Either Error, right?
09:15:53 <SamB> put it in MonadZero or something?
09:15:55 <Cale> and put the translation of do-notation back to what it was in Haskell 1.4
09:16:03 <Cale> Oh, sure, that'd be fine.
09:16:18 <fasta> (and can only hold primitive types)
09:16:19 <SamB> of course, then we need to fix the laws up a bit
09:16:22 <Cale> However, it would *still* involve changes I think.
09:16:29 <SamB> oh, of course ;-)
09:16:46 <SamB> I never said it wouldn't
09:17:01 <Cale> Because we'd have to do a different translation of p <- x based on whether the pattern was irrefutable or not.
09:17:10 <SamB> first, we should change the typechecking of do notation to work as Haskell 98 describes it:
09:17:22 <SamB> only based on the types of >>= and >>
09:17:50 <SamB> Cale: hmm?
09:18:02 <SamB> and fail
09:18:07 <Cale> Doing something like do { (x:xs) <- foo ; ... } should create a MonadZero constraint.
09:18:12 <SamB> yes.
09:18:17 <SamB> oh, right.
09:18:21 <Cale> But do { x <- foo; ... } wouldn't.
09:18:24 <SamB> I gotcha now
09:18:35 <SamB> and ~(x:xs) shouldn't either
09:18:38 <Cale> right
09:19:08 <SamB> so basically it would typecheck do as if it were the desugaring
09:19:17 <SamB> that would make edwardk happy, too
09:19:26 <basti_> what is so complicated about putting 7 trees in one?
09:19:56 <sehute> SamB: there, I submittet a ticket for renaming "interact", do you think that will do?
09:20:01 <SamB> and it would be able to cope with possibility that >>= and >> and fail not come from "base"
09:20:13 <SamB> sehute: dunno
09:20:24 <SamB> they'll probably tell you if you need to do more...
09:20:31 <SamB> or if you are crazy
09:23:49 <SamB> Cale: the trickiest aspect of this would be how GHC is supposed to know that we want to use another base package, I guess
09:25:12 <SamB> (and putting the really core GHC stuff in another package... and getting the Monad class out of GHC.* ;-)
09:25:23 <Cale> hmmm
09:25:47 <SamB> or actually I suppose that last part isn't necessarily necessary
09:25:55 <SamB> if we can tell it not to use that Monad class
09:27:23 <Cale> basti_: The set of trees satisfies the functional equation T = T^2 + 1, where + is treated as disjoint union and 1 is a single element set (the single vertex)
09:27:45 <Cale> basti_: One can check using this equation that T^7 = T
09:28:09 <Cale> basti_: But it's not clear that there's an obvious algorithm to show the bijection.
09:28:15 <basti_> ah ok.
09:28:41 <basti_> i was thinking along the lines: why dont you just do (1,(2,(3,(4,(5,(6,7)))))
09:28:58 <Cale> Oh, because that would only be an injection :)
09:29:06 <basti_> ah ok
09:29:21 <basti_> i see
09:29:28 <Cale> There's a way to take any seven-tuple of trees and get a unique tree, and to take any tree and get a unique seven tuple of trees :)
09:29:29 <_Nucleo> Would anyone be kind enough to advise me on what Haskell-related books to buy?
09:29:49 <DRMacIver> Cale: ...such that the two ways are inverse.
09:29:51 <basti_> yea i guess i just missed that part.
09:29:57 <basti_> ^^
09:30:04 <Cale> DRMacIver: right
09:33:45 <Cale> SamB: Changing the base package will also have far-reaching effects on what other packages are usable at all -- is the machinery that's in place there already sufficient to deal with that?
09:33:59 <Cale> _Nucleo: hmm
09:34:08 <Cale> _Nucleo: You're just starting out?
09:34:51 <_Nucleo> Cale: I have Haskell SOE, the Road to Logic book, and Thompson's book...
09:35:05 <savanni> I just got and started reading haskell soe
09:35:21 <SamB> Cale: hmm. don't think so.
09:35:21 <savanni> Been derailed temporarily by the need to get a GUI toolkit installed on my system, though.
09:35:21 <_Nucleo> Cale: but I have no CS background, and want something that's gentle but goes into depth on lambda calculus.
09:35:40 <_Nucleo> Preferably with code examples in Haskell.
09:35:41 <SamB> Cale: perhaps we'd need to add re-exports to Cabal?
09:36:27 <Cale> http://www.cs.nott.ac.uk/~gmh/book.html -- apparently this book is quite a good introduction to Haskell, but I don't know how much it treats the lambda calculus.
09:36:28 <lambdabot> Title: Programming in Haskell
09:36:50 <lament> oh wow, a book about _programming_ in haskell!
09:37:00 <Cale> Most of the stuff on lambda calculus isn't really practical programming stuff
09:37:24 <lament> isn't lambda calculus learned in 20 minutes?
09:37:30 <lament> it's not exactly big or complicated...
09:37:30 <_Nucleo> Cale: yeah, I think I understand the basics. These days it's trying to really grok the various monads.
09:37:44 <Cale> Yeah, that's a different book :)
09:37:52 <Cale> lament: Depends ;)
09:38:06 <Cale> lament: You can get a respectable intro in that time frame :)
09:38:31 <_Nucleo> yeah, but  not really enough to really understand say, the Y combinator
09:38:33 <Cale> Reading Barendregt's tome... maybe takes a little longer.
09:39:36 <Cale> Understanding the basic aspects of what Y is about might be another 20 minutes :)
09:40:20 <_Nucleo> yep
09:40:23 <Cale> Basically, you pass it a function whose first parameter is a function and it passes that function to itself. :)
09:40:28 <_Nucleo> e.g. is Hankin's "Introduction To Lambda Calculi For Computer Scientists"  any good?
09:40:39 <Cale> (or rather, it passes Y of that function to itself)
09:40:50 <Cale> I don't know.
09:40:50 <geezusfreeek> that long to understand the Y-combinator?
09:41:02 <geezusfreeek> i personally thought that learning lambda calculus was pretty easy reading
09:41:11 <xerox> Char> parse (do { d <- many digit; char 'x'; return (read d) } :: CharParser Data.ByteString.Lazy.Char8.ByteString () Int) "" "123x"
09:41:15 <xerox> Right 123
09:41:17 <xerox> yay :-D
09:41:30 <Cale> http://en.wikipedia.org/wiki/Lambda_calculus -- probably if you just read this, you'll be okay :)
09:41:32 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
09:41:32 <_Nucleo> I mean the basic premise of lambda calculus takes about 10 minutes.
09:41:41 <_Nucleo> The actual implications are kinda deep ;)
09:41:55 <_Nucleo> and I'm looking for a book that goes into some of those implications.
09:42:06 <Cale> chessguy: damn, I'm sorry, I meant to tell you about what a parsing monad was and forgot :)
09:42:11 <geezusfreeek> well, i'm also only talking about untyped lambda calculus
09:42:19 <sorear> (hello)
09:42:21 <chessguy> hm?
09:42:25 <geezusfreeek> i still haven't learned too much about typed lambda calculus
09:42:30 <Cale> chessguy: A parser for things is a function from strings to lists of pairs of strings and things :)
09:42:43 <Cale> Parser a = String -> [(String, a)]
09:43:03 <sorear> what's so complicated about typedLC?  you know haskell!
09:43:10 <Cale> that is, it consumes the input string, and returns a list of pairs of possible parses, together with the remainder of the input string for each
09:43:11 <chessguy> Cale, hmm, i'm specifically looking at Parsec
09:43:12 <_Nucleo> geezusfreeek: even with untyped, I don't really understand how to *really* use say, the S and K combinators.
09:43:21 <lament> geezusfreeek: typed lambda calculus is called haskell
09:43:36 <_Nucleo> lament: I thought it was system F?
09:43:38 <xerox> > ap const const 1
09:43:39 <lambdabot>  1
09:43:40 <xerox> ;-)
09:43:40 <Cale> chessguy: hmm, Parsec is a little stranger, since it tries to be more efficient, and introduces nondeterminism more explicitly
09:44:26 <chessguy> Cale, tries? i take it you're not terribly fond of parsec?
09:44:35 <geezusfreeek> lament: well, i mean a more formal study of typed lambda calculus itself, not just how it applies generally to programming
09:45:05 <Cale> chessguy: Nah, I like parsec well enough. It is more efficient, at the cost of being a little less convenient than it could be.
09:45:28 <chessguy> fair enough
09:45:34 <geezusfreeek> *sigh* … as much as i already know about this stuff, i'm only just now about to finally register as a computer science undergrad student… i'm getting in the academic game late
09:45:39 * Saizan loves ReadP
09:45:46 <Cale> ReadP manages to maintain the convenience and most of the speed, but lacks a bit of the additional polish with regard to error reporting and such.
09:45:49 <chessguy> xerox, hows your ParsecT coming along, since we're on the topic?
09:45:56 <geezusfreeek> and it's at a university that's enslaved by java :(
09:46:05 <xerox> chessguy: look
09:46:09 <lament> geezusfreeek: prepare to soon hate the entire thing :)
09:46:10 <Cale> geezusfreeek: which uni?
09:46:28 <geezusfreeek> university of alabama in huntsville
09:46:35 <geezusfreeek> i was originally here for computer engineering
09:46:39 <geezusfreeek> i am switching now
09:46:44 <xerox> chessguy: hang on, I'm making up a test just right now...
09:46:57 <sfultong> I got my undergrad semi late
09:47:04 <mrd> all are enslaved by java
09:47:09 <geezusfreeek> good engineering school, bad comp sci school
09:47:11 <chessguy> xerox, ah, ok, don't mind me then
09:47:25 <lament> so you're switching from good to bad?
09:47:44 <geezusfreeek> well, i would prefer to switch to another school to take comp sci, but it is infeasible at this point
09:48:11 <geezusfreeek> anyway, i gotta go to my appointment now… gbye
09:49:59 <magnus__> how can you see the functions that quickcheck generates?
09:50:45 <mrd> looking at the qc src code will help you understand real fast
09:57:39 <magnus__> mrd: My version of QuickCheck doesn't seem to have Test.QuickCheck.Function
10:00:52 <mrd> quickcheck is a small 1 file of source code
10:01:18 <glguy> Test.QuickCheck        Test.QuickCheck.Poly
10:01:18 <glguy> Test.QuickCheck.Batch  Test.QuickCheck.Utils
10:01:26 <glguy> I have those modules in my 6.6.1 install
10:01:36 <meren> I have GHC and i want to write a shell script with haskell.. what should be the first line of the script? do I need to have Hugs or it is doable with GHC as well?
10:02:08 <glguy> meren: if you want to run it like:  ./script.hs    #! env runhaskell
10:02:10 <glguy> should do it
10:02:20 <meren> hmm
10:02:24 <meren> thank you glguy.
10:03:04 <glguy> oops:
10:03:07 <magnus__> And the darcs repository seems to have even more modules
10:03:08 <glguy> #! /usr/bin/env
10:03:45 <meren> I addressed the binary directly with "which runhaskell"
10:04:17 <glguy> you used which on the #! line?
10:05:07 <glguy> env makes the script portable across computers that have runhaskell installed to different prefixes
10:05:55 <sorear> glguy: but what if env is moved?
10:06:40 <meren> glguy: i used "#!/usr/bin/runhaskell" for the first line.. i don't need compatibility at this point, but yes, using env is a better way..
10:06:48 <meren> sorear: it's so unlikely :)
10:08:54 <mrd> don't you need to write in .lhs ?
10:09:13 <sehute> what does "Cannot infer instance" mean?
10:10:46 <magnus__> sorear: if you are interested, I uploaded a new version of DisjointSet: http://magnus.smartelectronix.com/temp/DisjointSet.hs
10:11:17 <magnus__> anyone feel welcome to comment on it
10:11:44 <sorear> sehute: IIRC, you wrote a type signature and left out one or more class constraints
10:11:48 <mrd> glguy: would you consider PasteBot.hs to be a simple IRC bot library on its own? maybe with some modification
10:12:14 <sehute> sorear: thanks. What is a class constraint?
10:12:26 <sorear> sehute: like Ord a =>
10:13:16 <sehute> sorear: I typed gcd 15 20 :: Double, but I didn't understand the error-message, even though I understand that gcd can only return an integer, so :: Double makes no sense. But the error-message makes no sense to me
10:13:39 <sehute> sorear: does Ord a instanciate a class?
10:13:54 <sehute> sorear: how come it's a constraint?
10:14:04 <sehute> sorear: I'm really trying to understand this
10:14:12 <roconnor> @who Rubrication
10:14:12 <lambdabot> Maybe you meant: echo ghc show thx what wn
10:14:16 <sorear> I think I misremembered
10:14:26 <sorear> > gcd 15 20 :: Double
10:14:27 <lambdabot>   add an instance declaration for (Integral Double)
10:14:27 <lambdabot>     In the expression: gc...
10:15:06 <sorear> I think "cannot infer instance" is probably hugs for "There is no way to build an instance for this type"
10:15:23 <sehute> Okay, but what is a class constraint and what is it to infer an instance?
10:15:32 <sehute> And what does building an instance for a type mean?
10:15:47 <sehute> I think I know what instanciating a class means
10:15:51 <sehute> Or defining a type
10:16:06 <sehute> Or constraining a value
10:16:31 <SamB> Cale: see http://hackage.haskell.org/trac/ghc/ticket/1580 and http://hackage.haskell.org/trac/ghc/wiki/BaseSplit
10:16:34 <lambdabot> Title: #1580 (Get GHC happy with alternate base packages (split base)) - GHC - Trac
10:17:14 <roconnor> sorear: do you know who runs the Rubrication blog?
10:17:26 <sorear> No.
10:17:29 <roconnor> on the off chance it is you.
10:17:32 <roconnor> ok
10:22:37 <desp> @src product
10:22:37 <lambdabot> product = foldl (*) 1
10:22:53 <desp> '
10:25:39 <SamB> sorear: perhaps you, too, would like to take a look
10:26:03 <sorear> At BaseSplit?  Already open. ;)
10:27:10 <Cale> SamB: neat :)
10:27:23 <SamB> edwardk would most likely have some things to say as well
10:28:38 <SamB> I guess it's kinda silly to bother saying this, but if there's anything you have to add, in terms of comments or in terms of elaboration, go right ahaead ;-)
10:30:12 <SamB> Cale: it's a heck of a lot easier to say what might need doing than to go ahead and do it...
10:30:30 <Cale> SamB: I noticed :)
10:30:42 <sehute> But what is the constraining of a class?
10:30:42 <sehute> It makes no sense to me, any explanations are highly appreciated :)
10:30:56 <SamB> however, it's also a heck of a lot easier to do something when you can remember what you need to do ;-)
10:31:10 <Cale> sehute: Normally when you have a type variable, it means *any type whatsoever*
10:31:30 <Cale> sehute: for example if we have,  length :: [a] -> Integer
10:31:37 <sehute> Cale: ok
10:31:49 <Cale> That means that length doesn't look at the elements of the list at all, so they can have any type
10:31:59 <Cale> But what about things like  sort?
10:32:13 <Cale> It can't have the type  sort :: [a] -> [a]
10:32:14 <sehute> Cale: the types need to be able to be compared
10:32:20 <Cale> Right
10:32:31 <SamB> @tell edwardk you might want to look at http://hackage.haskell.org/trac/ghc/ticket/1580 and http://hackage.haskell.org/trac/ghc/wiki/BaseSplit
10:32:31 <lambdabot> Consider it noted.
10:32:36 <Cale> Only a's for which there's a notion of ordering would work
10:32:49 <SamB> @tell note that this is all at the pie-in-the-sky stage
10:32:49 <lambdabot> Consider it noted.
10:32:51 <SamB> er.
10:32:53 <Cale> So typeclasses let us restrict which types the type variables refer to
10:32:56 <SamB> @tell edwardk note that this is all at the pie-in-the-sky stage
10:32:56 <lambdabot> Consider it noted.
10:33:01 <Cale> sort :: Ord a => [a] -> [a]
10:33:02 <SamB> poor note
10:33:10 <meren> yet another silly question, this one works: http://rafb.net/p/yl2IJo52.html but this one doesn't: http://rafb.net/p/1mcuVR25.html what is the difference? What should be the type of main function?
10:33:11 <lambdabot> Title: Nopaste - No description
10:33:17 <note> @messages?
10:33:17 <lambdabot> note: You have 1 new message. '/msg lambdabot @messages' to read it.
10:33:22 <note> @clear-messages
10:33:22 <lambdabot> Messages cleared.
10:34:20 <sorear> meren: it's just a precedence thing
10:34:27 <sorear> meren: associativity, rather
10:34:33 <sorear>  (\x -> putStrLn x) head args
10:34:40 <sorear> parses as
10:34:45 <sehute> Cale: great, so Ord "tags" values that they have an order and Num "tags" them that they are numbers
10:34:56 <sorear> ((\x -> putStrLn x) head) args
10:35:02 <meren> should be like this: (\x -> putStrLn x) (head args)
10:35:03 <meren> ?
10:35:06 <sorear> yeah
10:35:16 <Cale> sehute: right
10:35:22 <sehute> Cale: but, what's wrong with this? iterate f [1..] where f x = x * 2
10:35:38 <Cale> sehute: [1..] * 2 doesn't make sense
10:35:45 <sehute> Cale: aaah, I see
10:35:47 <meren> sorear: but it still says "against inferred type `String -> IO ()'"
10:36:54 <sehute> Cale: Why doesn't this one stop after 5? take 5 $ iterate f [1..] where f x = x ++ [1]
10:37:04 <sehute> Cale: (hope you don't mind my inqusitiveness)
10:37:20 <sorear> sehute: it does stop after 5
10:37:30 <sorear> sehute: it prints five infinite lists
10:37:38 <sehute> sorear: aaah
10:37:41 <sehute> sorear: thanks
10:37:59 <Cale> sehute: you're probably looking for  iterate f [] or something
10:38:12 <Cale> iterate f x = x : iterate f (f x)
10:38:22 <sehute> I'm just playing with prelude-functions, trying to learn more Haskell
10:38:24 <Cale> So
10:38:31 <Cale> iterate (*2) 1
10:38:38 <Cale> = 1 : iterate (*2) (1*2)
10:38:51 <Cale> = 1 : (1*2) : iterate (*2) (1*2*2)
10:38:59 <Cale> = 1 : (1*2) : (1*2*2) iterate (*2) (1*2*2*2)
10:39:01 <Cale> and so on
10:39:11 <sehute> I see, thanks
10:39:14 <Cale> er, missed a : in that last one, but you get the idea
10:39:30 <sehute> yes, nice example, thanks
10:40:28 <Cale> > iterate (*2) 1
10:40:29 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
10:41:30 <sehute> Can a function use putStrLn and still return True ?
10:41:30 <meren> silly question revised: http://rafb.net/p/4u3rgG51.html
10:41:31 <lambdabot> Title: Nopaste - No description
10:41:47 <Cale> sehute: depends on what you mean by that :)
10:41:56 <meren> what's the problem with the type of main function there?
10:42:05 <Cale> sehute: Something which uses putStrLn is not of type Bool
10:42:20 <sehute> Cale: this one for instance, fails: takeWhile main [1..] where main x = do {putStrLn "hi"; True}
10:42:21 <Cale> sehute: (because the only values of type Bool are  True, False, and undefined)
10:42:46 <sehute> Cale: So, if you wish to use any sort of IO, you need to return something IO?
10:42:59 <Cale> yeah
10:43:08 <sehute> Cale: ok
10:43:14 <Cale> Really, you're building an IO action, and the only IO action which ever gets run is main.
10:43:35 <Cale> meren: (\x -> putStrLn x)
10:44:05 <Cale> meren: unless you really wanted it to ignore its argument :)
10:44:07 <sehute> Cale: Can I "wrap" True with IO?
10:44:30 <femol> a stupid question, but i could not find an answer: is there a way to convert an integer (:: Integer) to a list of digits? like each digit in this integer takes a position in the integer list?
10:44:32 <Cale> sehute: You can construct an IO Bool, but it's not the same thing as a Bool at all
10:44:56 <sehute> Cale: so, for takeWhile to recognize IO Bool there should be a takeWhileIO or something?
10:45:10 <meren> Cale: do you mean that anon function is another function and since it's not main I can't use any IO in it?
10:45:11 <Cale> sehute: A value of type (IO Bool) is the concrete representation of an action which if it was performed, would produce a Bool
10:45:39 <Cale> Yeah, what you're looking for is likely not takeWhile, but some control structure for IO.
10:45:41 <sehute> Cale: good explanation, thanks
10:46:14 <sehute> Cale: so, a function that asks a user a yes/no question should return (IO Bool)?
10:46:15 <Cale> When you use do-blocks, you glue IO actions (and other kinds of monadic computations) together.
10:46:24 <Cale> sehute: yeah
10:46:43 <Cale> sehute: That is, it would literally build an action which if performed, would ask the user a question.
10:46:56 <sehute> okay, I see
10:47:24 <magnus__> How can I put up my DisjointSet library at http://darcs.hasell.org?
10:47:32 <Cale> It might seem a bit strange to treat actions as values, but it's really nice once you're used to it.
10:47:59 <magnus__> or some other place that allows collaboration
10:48:26 <Cale> hmm, good question, I don't know how to get things hosted there :)
10:49:04 <RyanT5000> why isn't (a \b -> c) legal syntax?
10:49:09 <Cale> magnus__: you could upload it to HackageDB
10:49:19 <sehute> how do I "untag" the result of this function, so that I get 'A' and not "Just 'A'"? lookup 'a' (zip ['a'..'z'] ['A'..'Z'])
10:49:29 <RyanT5000> (meaning: apply function a to a function taking b and returning c)
10:49:36 <Cale> sehute: The simplest way is to use 'case'
10:49:43 <Cale> case lookup 'a' (...) of
10:49:46 <Cale>   Nothing -> ...
10:49:46 <RyanT5000> i don't get why i have to throw in a $
10:49:50 <Cale>   Just x -> ...
10:50:10 <sehute> Cale: ah, a kind of exception-handling using monads?
10:50:11 <Cale> RyanT5000: I don't know, I'm just used to typing the parens :)
10:50:31 <oerjan> RyanT5000: there was someone proposing to change that recently
10:50:32 <Cale> sehute: Well, the maybe monad, but there's nothing so monadic going on there
10:50:40 <RyanT5000> Cale: it's nice to use it to open blocks
10:50:40 <magnus__> Cale: checking it out...
10:50:50 <Cale> sehute: If you wanted to use the Maybe type monadically, you could do:
10:51:14 <Cale> do { x <- lookup ... ; return (f x) }
10:51:17 <RyanT5000> flip mapM [a, b, c] $ \x -> do blah
10:51:19 <oerjan> btw i submitted a bug report for it once before i found out it was supposed to be that way :)
10:51:24 <RyanT5000> oerjan: :P
10:51:27 <Cale> RyanT5000: yeah
10:51:34 <fourbissime> hi there. little question about nested data types. here is a paste : http://hpaste.org/2045
10:51:59 <sehute> Cale: thanks, the case worked
10:52:05 <sehute> > case lookup 'a' (zip ['a'..'z'] ['A'..'Z']) of Nothing -> '!'; Just x -> x
10:52:06 <Cale> sehute: cool
10:52:13 <lambdabot>  'A'
10:52:14 <fourbissime> I have a type that has default values. I apreciate a lot the possibility to do thing{pouet=nevalue}
10:52:40 <fourbissime> but I'm wondering if it is possible to do so in a structure that is nested, like in the example I pasted
10:53:03 <RyanT5000> fourbissime: not particularly cleanly
10:53:07 <sehute> Cale: ah, so putting things in do-blocks makes it "the monadic way"?
10:53:15 <SamB> fourbissime: we haven't got a nice record system yet
10:53:30 <Cale> fourbissime: well, you can write something like  foo2 = foo { foo_one = bar { bar_one = 7 }}
10:53:31 <SamB> that is one of the things we'd like to see in one
10:53:44 <Cale> sehute: Or using the monad operations
10:53:52 <SamB> Cale: that does not qualify as nice :-(
10:53:54 <Cale> sehute: Maybe is just a plain old data type though
10:54:15 <Cale> sehute: data Maybe a = Nothing | Just a
10:54:20 <RyanT5000> Cale: i ran into a problem the other day
10:54:28 <Cale> and case just does pattern matching
10:54:29 <RyanT5000> Cale: i wanted to use a backwards Maybe monad
10:54:34 <sehute> Cale: I see, so it's the do, -> or return that makes it monatic?
10:54:37 <sehute> *monadic
10:54:43 <RyanT5000> Cale: i.e.: where Nothing is success and Just is the fail condition
10:54:47 <Cale> or >>=, or anything in Control.Monad :)
10:54:59 <sehute> Cale: I'll check it out
10:55:03 <Cale> RyanT5000: yeah, that's not going to be a monad
10:55:05 <fourbissime> ok, so it's a bit of mess ...
10:55:11 <RyanT5000> Cale: oh, right
10:55:39 <Cale> RyanT5000: perhaps you want Either
10:55:45 <Cale> instance Monad (Either e) where
10:55:46 <RyanT5000> Cale: yeah that's what i ended up using :)
10:55:53 <Cale>   return = Right
10:56:02 <Cale>   (Left x) >>= f = Left x
10:56:04 <RyanT5000> incidentally, i still hate fail
10:56:08 <Cale>   (Right x) >>= f = f x
10:56:10 <RyanT5000> what business does fail have taking a string?
10:56:13 <RyanT5000> or, e.g., existing
10:56:19 <SamB> RyanT5000: it's handy
10:56:19 <xerox> What do you do when you have just one function, and that function is allocating memory linarly with time, as seen from the profiling report?
10:56:25 <RyanT5000> (i know, i know, it works with the syntax, etc.)
10:56:34 <Cale> RyanT5000: It's only for the translation of the do-syntax.
10:56:42 * shachaf also doesn't like fail.
10:56:42 <sehute> where is <- defined?
10:56:47 <RyanT5000> yeah i've heard the argument before
10:56:48 <SamB> RyanT5000: if you can think of a better way to encode informatioon...
10:56:48 <shachaf> sehute: It's sugar for >>=.
10:56:57 <Cale> sehute: <- is part of the syntax, it's not an operator
10:57:06 <shachaf> sehute: (Approximately.)
10:57:07 <fourbissime> ok. so, I have my answer. thanks :)
10:57:07 <SamB> like, you could use [Meme]
10:57:12 <SamB> or something
10:57:12 <Cale> sehute: and it's not just one part of the syntax :)
10:57:22 <RyanT5000> SamB: data DoSyntaxError; class Monad m => DoMonad m where ...
10:57:34 <SamB> RyanT5000: what I want is to see it in MonadZero
10:57:47 <RyanT5000> String is the worst conceivable way to encode an error anyway
10:57:48 <sehute> xerox: is it tail-recursive?
10:57:49 <RyanT5000> next to ()
10:57:51 <shachaf> SamB: To see fail?
10:58:03 <xerox> sehute: hmm, it's recursive indeed
10:58:03 <SamB> shachaf: yeah
10:58:05 <shachaf> SamB: Or to see mzero in do-translation?
10:58:09 <shachaf> SamB: Hmm, why?
10:58:35 <sehute> xerox: does it call itself not as the last thing it does?
10:58:40 <Cale> I'd just go for mzero in do-translation, but putting fail into MonadZero would be a decent halfway :)
10:58:47 <xerox> sehute: yeah it does.
10:59:13 <sehute> xerox: then, as far as I know, that should be an adequate explanation of why the memory use goes up
10:59:27 <sehute> xerox: if it calls itself as the last thing it does, I think it should be optimized properly
10:59:36 <Cale> However, this is a lazy language.
10:59:38 <SamB> shachaf: it's damn useful, and it behaves a lot like mzero does in any sensible monad...
10:59:40 <shachaf> sehute: You don't always want tail recursion in Haskell.
10:59:45 <Saizan> Cale: source location for failed pattern matches is nice
10:59:58 <shachaf> SamB: I agree that it should be in MonadZero if it should exist at all.
10:59:58 <Cale> sehute: Remember that expressions are evaluated outermost first
10:59:59 <SamB> so I want to see that legislated
11:00:11 <Cale> sehute: Still, I think you might have nailed it :)
11:00:21 <sehute> xerox: listen to the others :)
11:00:33 <Cale> If you do something like:
11:00:38 <Cale> foldl (+) 0 [1,2,3]
11:00:48 <Cale> It will evaluate as:
11:00:54 <Cale> foldl (+) (0 + 1) [2,3]
11:01:00 <Cale> foldl (+) ((0 + 1) + 2) [3]
11:01:06 <Cale> foldl (+) (((0 + 1) + 2) + 3) []
11:01:10 <sehute> xerox: I've had some computer science, but I'm no haskell-wizard
11:01:11 <Cale> ((0 + 1) + 2) + 3
11:01:16 <Cale> (1 + 2) + 3
11:01:18 <Cale> 3 + 3
11:01:19 <Cale> 6
11:01:25 <xerox> Hmm
11:01:36 <xerox> I'd like the profiling to show library functions calls, how does one do that...
11:01:41 <Cale> You can see the linear growth in expression size there, as the list is consumed.
11:02:15 <sehute> Cale: true
11:02:46 <shachaf> @wiki Stack overflow
11:02:46 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
11:03:08 <Cale> So in order to combat that particular problem, you use foldl' when you want to reduce a list to a small thing.
11:03:26 <sehute> good to know
11:03:31 <Cale> (foldr is better in general though, because it's lazy)
11:03:45 <Cale> foldr f z [] = z
11:03:54 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
11:04:04 <Cale> If f doesn't need its second parameter to produce a little output
11:04:11 <Cale> then the foldr won't continue
11:04:30 <Cale> (until perhaps that second parameter is demanded)
11:04:49 <Cale> So you can write things like
11:05:06 <Cale> > foldr (\x ys -> x : x : ys) [] [1..]
11:05:11 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
11:05:33 <sehute> why doesn't this work: do { x >>= getLine; putStrLn x }
11:05:48 <xerox> It's <- not >>=
11:05:48 <shachaf> sehute: getLine >>= (\x -> putStrLn x)
11:05:48 <Cale> sehute: because that's not how the do-notation is translated :)
11:05:57 <Cale> do { x } = x
11:06:12 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
11:06:19 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
11:06:33 <glguy> ghci (as a bug it seems) supports: do { getLine -> x; putStrLn x }
11:06:39 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
11:06:46 <sehute> xerox: thanks, I was told that <- was approximately syntactic sugar for >>=
11:06:48 <Cale> That's not a bug.
11:06:57 <glguy> Cale: oh?
11:06:58 <shachaf> sehute: Sorry.
11:07:07 <Cale> I think it comes from supporting arrow syntax.
11:07:12 <shachaf> sehute: I did mean "approximately". :-)
11:07:16 <sehute> shachaf: I see :-)
11:07:20 <Cale> (that is, I think it's intentional)
11:07:25 <glguy> Cale: then it is a bug because it works without -farrows?
11:07:30 <Cale> oh, possibly :)
11:07:44 <Cale> I see no reason that it shouldn't support it :)
11:07:44 <Saizan> i've never seen -> in arrow syntax
11:07:44 <shachaf> sehute: If you'
11:07:46 <EvilTerran> do { <patt> <- x ; <stmts> }  =  x >>= \v -> case v of { <patt> -> do { <stmts> }; _ -> fail }
11:07:48 <glguy> ghci without flags should be haskell 98?
11:07:55 <waern> Cale: I think they have removed it in ghc 6.7 though
11:07:56 <shachaf> sorear: I take it back. :-)
11:08:05 <Cale> Saizan: some people like to write their arrows the other way :)
11:08:11 <shachaf> sehute: If you're just learning about monads, you should probably not be looking at IO.
11:08:20 <sorear> shachaf: huh?
11:08:29 <sehute> Cale: why does this fail:  x >> do { getLine }
11:08:31 <shachaf> sorear: I just hit enter after '\''.
11:08:36 <Cale> sehute: is x an action?
11:08:39 <EvilTerran> (everyone loves the "fail" special case)
11:08:47 <sorear> oh, hehe
11:08:48 <sehute> shachaf: what should I be looking at? I've been trying to read documentation and some tutorials. Any tips?
11:08:54 <shachaf> @instances Monad
11:08:56 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:09:03 <Cale> sehute: if x and y are actions, then x >> y is the action which performs x, then performs y, returning the result of y
11:09:07 <shachaf> Look at Maybe/Identity, then [], probably.
11:09:15 <sehute> shachaf: okay, thanks
11:09:20 <EvilTerran> @type (>>)
11:09:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
11:09:34 <Cale> sehute: so, for instance,  putStrLn "Hello" >> putStrLn "world"
11:09:41 <shachaf> sehute: Then Reader (or (r ->)), State, Writer, I think.
11:09:47 <Cale> will print "Hello" and "world" on separate lines
11:10:10 <Cale> I/O can be an okay place to start sometimes :)
11:10:23 <Cale> If you're not having too much trouble with it
11:10:38 <Cale> But just remember that other monads are potentially very very different
11:10:51 <shachaf> Cale: Sure, but you can't really reimplement it yourself.
11:10:56 <Cale> Right.
11:11:02 <shachaf> Cale: And it's a good idea to look at others anyway.
11:11:09 * shachaf thinks Identity is simpler than IO. :-)
11:11:12 <sehute> so, what have I misunderstood here: putStrLn >>= \v -> do { getLine }
11:11:15 <Cale> For learning about monads in general, the list monad is excellent :)
11:11:24 <shachaf> sehute: No, that's reversed.
11:11:34 <shachaf> sehute: You don't care put putStrLn's "return" value.
11:11:39 <Cale> getLine >>= \v -> putStrLn v
11:11:43 <Cale> or just
11:11:44 <shachaf> sehute: You want getLine >>= \v -> putStrLn v
11:11:47 <Cale> getLine >>= putStrLn
11:12:14 <sehute> Thanks! This worked: getLine >>= \v -> do { putStrLn v }
11:12:20 <Cale> sure
11:12:26 <shachaf> sehute: No need for the do.
11:12:35 <Cale> the bit of do-notation you have there is pointless though, since there's only one action
11:12:45 <shachaf> sehute: You can get rid of any do with only one "statement" inside ito.
11:12:46 <Cale> do is used to glue multiple actions together
11:13:08 <sehute> okay, so "do" is for grouping actions and "<-" is for assigning values for the scope of the do?
11:13:34 <shachaf> sehute: Not exactly assigning, but yes.
11:13:41 <sehute> and >>= pipes monadic values forward, in a way?
11:13:44 <glguy> <- lets you pretend to extract the result of a Monadic action
11:13:48 * shachaf thinks "assigning" can be a confusing word here.
11:14:07 <shachaf> sehute: Do-notation just uses >>=.
11:14:19 <shachaf> sehute: So yes.
11:14:35 <sehute> So, "<-" gives name to a value for the scope of a do-block?
11:14:38 <glguy> m >>= f    runs m, and then extracts the result and applies it to f
11:15:10 <oerjan> YM applies f to it
11:15:12 <desegnis> sehute, for the scope of what follows in the do block
11:15:30 <Cale> do { x <- getLine; putStrLn x }
11:15:44 <Cale> = getLine >>= \x -> do { putStrLn x }
11:15:44 <glguy> "applies it to f" in the sense that f needed an argument and it gives f that argument
11:15:49 <Cale> = getLine >>= \x -> putStrLn x
11:16:03 <glguy> so I suppose that confuses the standard use of function application
11:16:04 <Cale> So it's really just a lambda in disguise.
11:16:22 <sehute> okay, I'm writing this down. So: "<-" gives a name to a value for the scope of the rest of a do-block
11:16:27 <oerjan> you might use "feeds"
11:16:31 <shachaf> sehute: It's important not to think that do-blocks are just for IO, though. For example, the <- in list comprehensions is really the same as the <- in do-notation.
11:16:39 <Cale> sehute: yeah, it gives a name to the result of that action
11:16:52 <Cale> shachaf: sort of
11:16:59 <Cale> shachaf: Not if you follow H98 though
11:17:00 <sehute> so "<-" can only be used in connection with giving the result of an action a name?
11:17:03 <ari> Cale: Since someone pointed this out to me the last time I called something a hidden lambda, I feel compelled to do this: What *isn't* a lambda in disguise? ;)
11:17:07 <Cale> In H1.4 they were the same :)
11:17:10 <shachaf> Cale: OK, fine, but you can think of it that way. :-)
11:17:32 <sehute> hehy, this actually worked: getLine >>= f where f x = putStrLn x
11:17:32 <sfultong> how come list comprehension is part of haskell, when it could be almost as easily done in a do block?
11:17:40 <Baughn> ari: Integers, unless you implement them as such
11:17:49 <glguy> sfultong: convenience
11:17:51 <Cale> sfultong: because sometimes the result is more important :)
11:17:52 <shachaf> sfultong: Well, do blocks require the extra return and guard.
11:18:04 <Cale> and yeah, guards are more awkward in do-notation
11:18:06 <shachaf> sfultong: List comprehension notation is handy.
11:18:18 <oerjan> also, list comprehensions are probably older?
11:18:25 <Cale> Indeed
11:18:28 <sfultong> yeah, I thought so
11:18:39 <EvilTerran> monad comprehensions! :D
11:18:43 <Baughn> It would be even more handy to use comprehension-notation for other monads than list
11:18:52 <Cale> We'd really like to have monad comprehensions back :)
11:19:03 <sfultong> so ... why don't we?
11:19:03 <shachaf> Cale: So Haskell 1.4 had monad comprehensions?
11:19:07 <EvilTerran> but that got nixed for producing horrible error messages, from what i hear
11:19:10 <Cale> shachaf: yeah
11:19:11 <Baughn> Cale: What happened to it?
11:19:11 <sfultong> ah
11:19:26 <glguy> We don't have them because no one who wants them knows how to add them back in
11:19:27 <Cale> Baughn: people thought the error messages sucked for beginners
11:19:34 <EvilTerran> scaring the newbies with talk of monads when they were just trying to iterate over a list
11:20:02 * glguy wishes ghc just had an --im-new
11:20:02 <sfultong> haskell in general isn't good with error messages that newbies can understand
11:20:13 <Cale> Removing monad comprehensions was really *the* mistake of Haskell 98. All the other downhill-from-1.4 stuff happened in a sort of avalanche starting from that.
11:20:13 <glguy> that would have turned monad comprehensions off
11:20:32 <lament> Cale: things just aren't what they used to be? :)
11:20:50 <Baughn> Cale: So it's all been a decline from a previous golden age?
11:20:58 <sehute> so, >>= feeds the result to a function that uses the same monadic type as the result
11:21:02 <Cale> Baughn: well, not *all*
11:21:07 <Baughn> I second the switch, only it needs to be --advanced ;)
11:21:07 <shachaf> lament: How come Cale can lament, but lament can't Cale?
11:21:12 <Cale> Baughn: but lots of things in 98 are worse than 1.4
11:21:28 <sfultong> shachaf: I was thinking something similar
11:21:29 <EvilTerran> > let f (n:ns) = n : f (filter ((0/=).(`mod`n)) ns) in f [2..]
11:21:30 <Cale> I highly recommend reading the 1.4 prelude :)
11:21:30 <Baughn> Cale: Haskell' is addressing that, I presume
11:21:34 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
11:21:46 <Cale> Baughn: I'd like to think so, but I'm not sure.
11:22:07 <Baughn> "Sometime before the Haskell 98 standard the list comprehension syntax was first generalized to monad comprehension but then specialized back as it caused type ambiguity: ['c'] wouldn't mean a list of one element, the character c, but the result of return 'c' in any monad."
11:22:10 <Cale> Baughn: It seems more aimed at writing down what contemporary Haskell looks like
11:22:11 <SamB> Baughn: We'll make sure it's taken care of by Haskell 2, at least
11:22:19 <xerox> Yay to allocating Gb of tuples.
11:22:25 <SamB> Baughn: hmm.
11:22:32 * xerox curses Control.Arrow
11:22:38 <shachaf> What about using a different character for comprehensions?
11:22:45 * EvilTerran likes that you can express the Sieve of Eratothenes fairly directly in Haskell
11:22:49 <Baughn> Such as <, yes.
11:22:53 <Baughn> It's free
11:22:58 <Cale> Baughn: A decent defaulting mechanism would have fixed the problem better.
11:23:05 <shachaf> Baughn: Well, there is Ord.
11:23:19 <sfultong> > let f (n:ns) = n : f (filter ((0/=) . (`mod`n)) ns) in drop 100 $ f [2..]
11:23:21 <lambdabot>  [547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653...
11:23:26 <sfultong> > let f (n:ns) = n : f (filter ((0/=) . (`mod`n)) ns) in drop 1000 $ f [2..]
11:23:28 <lambdabot>  [7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,...
11:23:28 <Cale> You just say that whenever the type is ambiguous, it's a list.
11:23:33 <shachaf> Cale: So with monad comprehensions, [] would have been sugar for return, also?
11:23:38 <shachaf> Cale: (With defaulting to list?)
11:23:40 <EvilTerran> sfultong, stress testing?
11:23:40 <Baughn> Cale: There's too much ambiguity in the syntax as it is. Using a different character would help... mind you, apparently *not* <. :/
11:23:41 <Cale> yeah
11:23:49 <lament> Haskell 2, is that the same as Perl 6?
11:23:50 <sfultong> evilterran: maybe :)
11:23:54 * shachaf likes that, actually.
11:24:04 <EvilTerran> isn't the norm to put something inside []s for other brackety things?
11:24:05 <Baughn> Cale: It annoys me that I can say Foo a b in some patterns and have to use (Foo a  b) in others
11:24:20 <Cale> Which ones?
11:24:26 <EvilTerran> [| |] for templates, [: :] for data parallel arrays, etc
11:24:27 * SamB wonders if it shouldn't count as a comprehension unless there's a |
11:24:37 <sehute> does "let" only define names from the place the definitions are, like scheme?
11:24:49 <oerjan> sehute: no
11:24:52 <Cale> Baughn: You obviously have to parenthesize some things...
11:24:58 <sehute> oerjan: thanks
11:25:01 <EvilTerran> [< >], maybe?
11:25:02 <shachaf> sehute: In do-notation or in general?
11:25:05 <nominolo> @yow
11:25:05 <lambdabot> BARRY ... That was the most HEART-WARMING rendition of "I DID IT MY
11:25:05 <lambdabot> WAY" I've ever heard!!
11:25:08 <oerjan> it's like letrec
11:25:18 <sehute> oerjan: I see, thanks
11:25:20 <sfultong> sehute: I had that same misperception for a long time
11:25:21 <sehute> shachaf: in genera
11:25:22 <Baughn> Cale: Right, but there are a lot of near-collisions in the syntax. I
11:25:24 <sehute> *general
11:25:44 <SamB> lament: Haskell 2 is not the same as Perl 6
11:25:46 <Baughn> Cale: I'd *prefer* something lisp-like, if for no other reason that it'd make a proper emacs mode possible. (Yes, I know about liskell)
11:25:47 <shachaf> sehute: Oh, it's indeed like letrec, if that's what you meant.
11:25:50 <EvilTerran> sfultong, i haven't studied that for complexity in any great detail, but it looks to me like it shouldne fairly snappy.
11:25:54 <sehute> shachaf: yes :)
11:25:57 <EvilTerran> *should be
11:26:08 <SamB> lament: we aren't scrapping everything and adding unicode willy-nilly
11:26:28 <SamB> (is unicode is already allowed according to the report?)
11:26:33 <Cale> Baughn: hehe, a proper emacs mode must be possible, you just need to do enough work to parse things :)
11:26:51 <oerjan> SamB: yes
11:26:54 <Cale> I admit we've made it rather hard on the text editor people :)
11:26:58 <dylan> make ghc output a syntax tree as a sexo.
11:27:05 <dylan> sexpr, even
11:27:13 * xerox breathes, finally.
11:27:17 <EvilTerran> at least we've got a syntax that's defined in exactly one document
11:27:22 <SamB> dylan: Baughn wants something that works on invalid code, too
11:27:26 <xerox> LazyByteStringParsec is finally running in constant space as wanted.
11:27:28 <Cale> Personally I don't really give a damn about the features of my text editor as long as it has marginally-correct syntax highlighting.
11:27:28 <Baughn> Cale: Haskell *barely* parses if it's *valid* code
11:27:29 <SamB> EvilTerran: yeah right!
11:27:32 <oerjan> a final breath? oh dear.
11:27:37 <EvilTerran> unlike, say, XML, which is defined in a million documents. or perl, which is defined in none.
11:27:50 <SamB> EvilTerran: there are three documents
11:27:52 <sehute> why does this fail? do { x <- "hi"; putStrLn x }
11:28:02 <Cale> sehute: "hi" is not an IO action
11:28:04 <xerox> btw endo dna has got respectively many I C F P: 2521652 2659179 643443 1698786
11:28:05 <xerox> ;-)
11:28:05 <sehute> is it because "hi" is not an action?
11:28:06 <shachaf> "Only perl can parse Perl". :-)
11:28:10 <Baughn> sehute: <- extracts a value from a monad. "hi" is not a monad.
11:28:13 <Cale> sehute: (and putStrLn x is not a list)
11:28:18 <EvilTerran> SamB, the report, and...?
11:28:20 <Baughn> sehute: Well, it is, but it's a different one..
11:28:21 <monochrom> Cale is evil :)
11:28:21 <SamB> http://haskell.org/definition
11:28:23 <lambdabot> Title: Language and library specification - HaskellWiki
11:28:32 <shachaf> sehute: Use do { let x = "hi"; putStrLn x }.
11:28:33 <SamB> EvilTerran: note the two addendums
11:28:36 <sehute> I see. So the right side of <- must both be an action and a monad, or just wrapped in a monad?
11:28:44 <Baughn> sehute: An action is a kind of monad
11:28:49 <SamB> Baughn: eh.
11:28:50 <shachaf> sehute: Note that as Cale and Baughn, "hi" is a monad, just not IO.
11:28:52 <EvilTerran> i see 1+1/2 attendums
11:28:55 <Cale> sehute: Baughn misspoke, an action is a value of a monadic type
11:29:02 <monochrom> Oh, not this again. :)
11:29:06 <Cale> A monad is a type constructor
11:29:10 <Cale> It is not a value.
11:29:12 <SamB> sehute, Baughn, sehute: what Cale said ;-)
11:29:15 <SamB> er.
11:29:16 <shachaf> Cale: Sorry.
11:29:20 <sorear> Cale: Sure it is... {-# OPTIONS_GHC -foverloaded-strings #-}
11:29:25 <SamB> s/sehute/shachaf/
11:29:28 <monochrom> But yeah, "monad" refer to types like "IO". "action" refers to values/functions.
11:29:31 <Baughn> I was trying to simplify, but cale's perfectly right
11:29:31 <EvilTerran> > do { x <- "hi"; return [x,x] }
11:29:33 <lambdabot>  ["hh","ii"]
11:29:41 <shachaf> sehute, SamB, Baughn: What Cale said. :-)
11:29:49 <Cale> > do { x <- "hi"; [x,x] }
11:29:50 <lambdabot>  "hhii"
11:30:05 <Cale> > do { x <- [1,2,3]; [x,x*10] }
11:30:06 <lambdabot>  [1,10,2,20,3,30]
11:30:07 <sehute> so, a monad is a type constructor and an action is a value constructed by a monad?
11:30:09 * oerjan the other day used "monade" for monad in norwegian and wonders if that is a bad translation.
11:30:11 <monochrom> Please be careful to avoid brain explosions.
11:30:18 * EvilTerran notes that his prime sieve is starting to slow down noticably around 250_000
11:30:27 <Baughn> > do x <- [1..4]; return (x,x*10)
11:30:29 <lambdabot>  [(1,10),(2,20),(3,30),(4,40)]
11:30:31 <sehute> oerjan: I think it sounds more like a dessert ;)
11:30:34 <SamB> oerjan: why did you try to translate it?
11:30:35 <Cale> sehute: an action in general is a value of type (m a) where m is some monad, and a is some type
11:30:35 <SamB> anyway...
11:30:39 <monochrom> "value constructed by a monad" sounds confused. humans, not monads, construct anything.
11:30:47 <SamB> I don't think that [x] should be a monad comprehension
11:30:52 <xerox> > do { [1..10]; "AAH!" }
11:30:53 <lambdabot>  "AAH!AAH!AAH!AAH!AAH!AAH!AAH!AAH!AAH!AAH!"
11:30:57 <EvilTerran> SamB, a standard w/ two attenda is still vastly smaller than, say, XML, Java, ercerc.
11:30:59 <SamB> I think that only [x | x <- xs] should be one
11:30:59 <EvilTerran> *etcetc
11:31:02 <SamB> etc.
11:31:02 <xerox> (Brain Explosion.)
11:31:11 <sehute> oerjan: call it a monade-innpakning or something ;)
11:31:13 <oerjan> SamB: well, i just tried to give it a pronunciation
11:31:15 <SamB> EvilTerran: quite so
11:31:23 <SamB> oerjan: oh, that's not too bad I guess
11:31:29 <oerjan> i was explaining haskell over a beer
11:31:31 <shachaf> monochrom: A alue constructed with a monad.
11:31:37 <shachaf> s/a/va/
11:31:38 <Saizan> oerjan: "monade" is how you say it in italian :) (e.g. Leibniz's ones)
11:31:47 <Baughn> sehute: This happens a lot. Hopefully you got the point, though. ;)
11:31:53 <SamB> does monade rhym with kool-aid?
11:32:06 <xerox> mnade
11:32:06 <monochrom> Screw all this English.
11:32:07 <oerjan> Saizan: yeah that's what i thought but then afterward i remembered that monad = monoid + triad
11:32:19 <sehute> monochrom: well, if a monad is a type constructor, it should be abel to construct things?
11:32:21 <EvilTerran> does it rhyme with caddy?
11:32:23 <oerjan> hm... i guess it would be triade, so that fits too.
11:32:26 <nominolo> :t (+++)
11:32:27 <shachaf> SamB: Why shouldn't [x] be a monad comprehension too, with good defaulting rules, like Cale said?
11:32:27 <gkr> oerjan "monad" is Swedish for "monad".
11:32:28 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
11:32:40 <monochrom> A type constructor constructs.... types...
11:32:55 <SamB> shachaf: or we could just blow the MR out of the water with good optimizers like supero...
11:33:22 <sehute> Cale: so, an action is a kind of a tagged type? (monad + type)
11:33:23 * shachaf wonders what monad is in Hebrew.
11:33:23 <Cale> sehute: So for example, Maybe is a type constructor. When applied to Integer, it gives the type Maybe Integer
11:33:36 <monochrom> OK, "f :: IO ()".  IO is a monad.  f is an action.  You can read "::" as "has type" or "in" or whatever you want. I don't care about English.
11:33:38 <shachaf> Hmm, "monada", according to Wikipedia.
11:33:43 <sehute> Cale: but is a Maby Integer an action?
11:33:50 <Baughn> sehute: A monad is a type constructor that constructs a monadic type. FOr all intents of purposes, you can think of the monadic type as being a type that contains the type you handed to the monad.
11:33:51 <EvilTerran> Just is a value contructor. when applied to 0, it gives the value Just 0
11:33:58 <oerjan> gkr: well swedish -"ad" norwegian -"ade" is pretty regular correspondence
11:34:00 <Cale> sehute: In the Maybe monad, yeah, that would be our terminology
11:34:14 <EvilTerran> sehute, yes. a Maybe action, though, not an IO action.
11:34:32 <Baughn> sehute: So IO Int is a monadic type (of the IO monad) that contains an Int. Since it's IO Int, that makes it an action that you can extract an Int from.
11:34:52 <Cale> sehute: Or for example, IO is a type constructor (and one which is a monad), and so IO String is a type, and getLine is an action.
11:34:56 <Baughn> sehute: The action of extraction is likely to run some code. Such as code that reads an Int from stdin.
11:35:43 <EvilTerran> note that IO has no value contructors. it's an abstract type.
11:35:55 <shachaf> @src IO
11:35:56 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
11:36:03 <gkr> :-O
11:36:11 <Cale> heh
11:36:15 <Baughn> sehute: getLine has type IO String, which is one value, and it's the /same/ value each time. But by extracting the String, you quite likely get a different string. The value in question is a real-world action.
11:36:27 <Cale> Stupid @src :)
11:36:37 <meren> I'm gonna cut myself. what would be the type of this function: p num c = ((num `mod` (product (take c [10,10..]))) - c) / (product (take c [10,10..])) ?? what should I do when I'm thinking about the type of a function to find the right match?
11:36:39 <Cale> It should say  data IO a -- wired into compiler
11:36:45 <magnus__> roconnor: How is the rope implementation going?
11:36:56 <roconnor> magnus__: not so good.
11:37:04 <monochrom> except it's newtype IO a -- wired into compiler
11:37:25 <Cale> meren: It would be a type error?
11:37:25 * shachaf wonders why @src isn't either the "real" implementation or the H98 implementation.
11:37:25 <Baughn> @type ((num `mod` (product (take c [10,10..]))) - c) / (product (take c [10,10..]))
11:37:28 <lambdabot> Not in scope: `num'
11:37:28 <lambdabot>  
11:37:28 <lambdabot> <interactive>:1:27: Not in scope: `c'
11:37:36 <AHTOH> Hi All, i have a following problem running ghc-661 -O2 compiled program: haskell binary has 100% load, while bash running it also has 100% load (on secod core), can anyone give a fresh idea. googling/haskell.org reading gave no help....
11:37:42 <SamB> monochrom: the data/newtype distinction is only relevant for opaque types when it comes to FFI...
11:37:44 <meren> Cale: why is that? because of the '/' operation?
11:37:48 <Cale> meren: yeah
11:37:54 <meren> Cale: :(
11:37:56 <roconnor> magnus__: ghc sucks when it comes to using generic libraries.
11:38:00 <SamB> monochrom: and then only sometimes
11:38:01 <meren> Cale: so what should I do?
11:38:06 <Cale> meren: You maybe want div?
11:38:07 <monochrom> True
11:38:09 <Baughn> AHTOH: Is it doing anything to bash?
11:38:09 <geezusfreeek> meren: No instance for (Fractional Int) arising from use of `/'
11:38:19 <Cale> meren: or do you want to convert to another numeric type?
11:38:41 <meren> Cale: should i use div function instead of using '/' operator?
11:38:41 <Cale> fromIntegral will convert from any integer-like type to any other kind of number.
11:38:47 <AHTOH> Baughn: no ,just printing 1 line per 10s.
11:38:50 <shachaf> meren: For Integrals, yes.
11:38:52 <Cale> meren: div is integer division though
11:38:57 <meren> jeez.
11:39:30 <Baughn> AHTOH: Is the code short? Can we see it?
11:39:52 <Baughn> AHTOH: Since you mentioned -O2, does it behave differently without that flag?
11:39:59 <Cale> meren: take c [10,10..] = replicate c 10
11:39:59 <meren> let me work on it.. can we say "type matching for a function is harder than to write function itself"
11:40:09 <meren> Cale: thanks :)
11:40:18 <Cale> and product (replicate c 10) = 10^c
11:40:19 <AHTOH> Baughn: hmm havent tried it :)
11:40:22 <roconnor> replicate 10 c
11:40:33 <Cale> er, yeah
11:40:35 <AHTOH> replicate 10 'c'
11:40:48 <sehute> So, a monad is a "tag"/"container" and a type constructor that constructs a monadic type, that for all intents and purposes can be thought of as being a type that "wraps" the type I handed to a monad?
11:40:58 <Cale> no, it's really replicate c 10 :)
11:40:59 <sehute> Just to conclude it :)
11:41:01 <roconnor> Cale: sorry, you were right.
11:41:03 <Cale> > replicate 5 10
11:41:04 <lambdabot>  [10,10,10,10,10]
11:41:11 <Cale> > product (replicate 5 10)
11:41:12 <lambdabot>  100000
11:41:12 <meren> eheh
11:41:14 <Cale> > 10^5
11:41:16 <lambdabot>  100000
11:41:19 <meren> cool.
11:41:32 <meren> i hate not to know simple things.
11:41:45 <shachaf> @ty replicate
11:41:47 <lambdabot> forall a. Int -> a -> [a]
11:42:03 <shachaf> meren: GHCi/lambdabot is your friend. :-)
11:42:38 <AHTOH> Baughn: yes without any flags the same behavior
11:43:00 <magnus__> roconnor: oh, what is the problem?
11:43:03 <meren> shachaf: since I can't interpret "forall a. Int -> a -> [a]" kind of outputs yet nobody is my friend here :(
11:43:20 <roconnor> magnus__: it's hard to get GHC to specialize fingertrees.
11:43:25 <shachaf> meren: Ignore the forall a. bit.
11:43:53 <sehute> Thanks so much for the brilliant answers so far, btw :-)
11:44:09 <shachaf> meren: So "Int -> a -> [a]" means that for any a (forall!), replicate gets an Int and returns a function that gets an a and returns a list of as.
11:44:19 <monochrom> "Omit needless words."  - Strunk & White, "The Elements of Style"
11:44:25 <shachaf> meren: (Or that replicate gets an Int and an a and returns a list of as.)
11:44:37 <sehute> I've learned a ton and I'll try to make a tutorial for beginners that favors practical purposes some day :)
11:44:47 <shachaf> meren: Those are equivalent, if you know about currying?
11:44:59 <Baughn> AHTOH: So, do we get to see the misbehaving code?
11:45:05 <meren> shachaf: no
11:45:20 <meren> shachaf: I've read about it, but it's not complete in my mind I guess.
11:45:31 <shachaf> meren: Well, what do you know about it?
11:45:56 <magnus__> roconnor: aha, it is generating too slow code?
11:46:00 <meren> shachaf: nothing that can translate from brain language to english if you know what i mean
11:46:29 <meren> (nothing that can translate -> nothing that can be translated)
11:46:57 <AHTOH> Baughn: hmm its 44k in size () :(
11:47:09 <magnus__> roconnor: maybe it would be worthwhile to check out the ocaml ropes package that someone made a few days ago and see how they did it
11:47:40 <Baughn> AHTOH: Scratch that, then. What did you change to make it break?
11:48:24 <roconnor> magnus__: Lemmih was doing most of the optimization.  He will know how fast it is now.
11:48:36 <roconnor> Lemmih: yt?
11:48:37 <shachaf> meren: Well, how do you write a function that gets two arguments?
11:48:51 <meren> shachaf: f x y
11:48:55 <shachaf> meren: One way is to write a function that gets one argument, which is a tuple.
11:49:01 <shachaf> meren: So f (x,y).
11:49:02 <meren> f (x, y)?
11:49:04 <meren> hmm
11:49:07 <shachaf> meren: Yes.
11:49:19 <shachaf> meren: And that's a valid way, similar to how most languages do it.
11:49:41 <sehute> @ty FilePath
11:49:45 <shachaf> meren: Let's say our function is add: add x y = x + y
11:49:50 <lambdabot> Not in scope: data constructor `FilePath'
11:49:53 <shachaf> meren: (Also add = (+), but never mind that.)
11:50:12 <shachaf> meren: We can write add (x,y) = x + y, and it would get a tuple.
11:50:16 <ddarius> :k FilePath
11:50:18 <lambdabot> *
11:50:25 <sehute> @src FilePath
11:50:26 <lambdabot> type FilePath = String
11:50:29 <shachaf> meren: You know that that's equivalent to add = \(x,y) -> x + y ?
11:50:31 <meren> shachaf: okey
11:50:33 <meren> yes
11:50:34 <AHTOH> Baughn: i havent broken it : just noticed that behavior. Except bash load, all is ok. This is a program for ICFPC -- im trying to get a good result with haskell, it is interesting if there is possible to get speed better then C program.
11:50:50 <sehute> What does it mean that type FilePath = String? Is it a monad? What is it good for?
11:50:56 <shachaf> meren: So, another way we can write this is add = \x -> (\y -> x + y) .
11:51:03 <shachaf> sehute: A type alias.
11:51:04 <meren> correct
11:51:09 <sehute> shachaf: ok, thanks
11:51:34 <shachaf> meren: Which means that add is a function that gets an x, and returns a function that gets a y and returns x + y.
11:51:34 <Baughn> AHTOH: That it causes load on bash is surprising in the first place. I gather the haskell program is supposed to run at 100%?
11:51:56 <meren> shachaf: hmm.
11:52:17 <AHTOH> Baughn: they both run 100% ( i have two cores)
11:52:31 <shachaf> meren: This is similar to (C-ish syntax): if (x && y) { z; } being equivalent to: if (x) { if (y) { z; } }
11:52:32 <Baughn> sehute: It's handy for documentation, say if you see a function xmlParse :: String -> FilePath -> XML
11:52:46 <sehute> Baughn: ah, I see. For clarity, great :)
11:52:46 <Baughn> AHTOH: Right, but only one is /supposed/ to
11:53:05 <AHTOH> Baughn: and top says that 50% user(seems to be haskell) and 49% is system load
11:53:06 <roconnor> @type readFile
11:53:08 <lambdabot> FilePath -> IO String
11:53:12 <fxr> meren: nice to see you here :)
11:53:14 <SamB> Baughn: what's String for?
11:53:16 <meren> shachaf: so transforming a function into that form is currying?
11:53:17 <SamB> er.
11:53:19 <shachaf> sehute: However, that can get lost.
11:53:19 <meren> is that correct?
11:53:20 <shachaf> meren: Yes.
11:53:22 <shachaf> @ty curry
11:53:23 <Baughn> SamB: The raw XML. ;)
11:53:23 <SamB> what's *that* String for?
11:53:25 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
11:53:28 <meren> fxr: yo!
11:53:39 <SamB> Baughn: ah.
11:53:46 <shachaf> meren: So curry is a function that gets a function of the form add (x,y) and returns a function of the form add x y.
11:53:47 <fxr> meren: howdy?
11:54:14 <Baughn> AHTOH: What is the program supposed to be doing? Anything that does that much I/O?
11:54:16 <meren> shachaf: hmm.
11:54:21 <meren> fxr: ;)
11:54:28 <Baughn> AHTOH: Except that, with bash overloaded as well, there almost has to be something wrong going on there
11:54:42 <Baughn> AHTOH: YOu might want to do a binary search on your repository until you isolate the change that caused it
11:55:00 <ddarius> :t uncurry
11:55:02 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
11:55:05 <ddarius> :t uncurry . curry
11:55:07 <lambdabot> forall a b c. ((a, b) -> c) -> (a, b) -> c
11:55:59 <shachaf> meren: All the forall means is forall. :-)
11:56:05 <AHTOH> Baughn: thats a dna->rna convertor i tried to write after ICFP on a haskell, so it has some rare IO, but not such extensive for extreme bash loads..
11:56:09 <meren> shachaf: okey i get that :)
11:56:13 <shachaf> meren: So it's saying that it would work for any a you throw at it.
11:56:31 <shachaf> @ty replicate -- So can you read this now?
11:56:33 <lambdabot> forall a. Int -> a -> [a]
11:56:45 <shachaf> meren: Remember the implicit parentheses.
11:56:49 <AHTOH> Baughn: strange, but everything is fine, just a bash problem :(
11:56:52 <shachaf> meren: forall a. Int -> (a -> [a])
11:57:02 <meren> yes i can read i guess..
11:57:17 <Baughn> AHTOH: No, I'm pretty sure it's not bash's fault. Normally you wouldn't be talking to it at all..
11:57:21 <Cale> AHTOH: What happens if you exec your program instead?
11:57:25 <SamB> AHTOH: what in the world did you DO to get bash to use all that CPU?
11:58:18 <Baughn> AHTOH: And what are you doing to make your program spend half its time in the kernel (as opposed to, say, waiting for I/O)? Polling?
11:58:26 <meren> shachaf: it makes more sense now. I'll think about it more and I'll be okey about this.. thanks very much for your effort..
11:59:57 <fxr> one can find currying, if he/she tries to program only using functions with one argument
12:00:16 <shachaf> fxr: Or tuples.
12:00:40 <Cale> shachaf: wouldn't that be the opposite of currying?
12:00:49 <shachaf> Cale: Yes.
12:00:55 <AHTOH> SamB: you will laugh but that seems not to be a haskell problem
12:01:02 <shachaf> < fxr> one can find currying, if he/she tries to program only using functions with one argument
12:01:08 <SamB> AHTOH: I kind of figured that
12:01:10 <shachaf> Cale: (One can also find tuples.)
12:01:10 <ddarius> fxr: All Haskell programs are functions of one argument...
12:01:17 <Cale> shachaf: Aren't tuples what functions of multiple arguments normally take?
12:01:53 <ddarius> Cale: Not really...
12:01:53 <SamB> ddarius: what about those which aren't functions but rather values of some other kind of type??
12:01:56 <shachaf> Cale: Well, a tuple is a single argument.
12:02:00 <AHTOH> SamB: i just noticed, that without haskell there is a problem with a bash.... But last week i runned top only when i run haskell program, so made a wrong coclusian that it was haskell-related
12:02:11 <SamB> ah.
12:02:22 <sorear> @users
12:02:22 <lambdabot> Maximum users seen in #haskell: 382, currently: 353 (92.4%), active: 27 (7.6%)
12:02:32 <meren> shachaf: so in Haskell all function calls are considered curried, is that a correct statement?
12:02:36 <ddarius> SamB: Yeah, I didn't use the best word.
12:02:37 <Cale> I mean, in mathematics, a function of two parameters is a function from the Cartesian product of two sets
12:02:52 <Cale> Which is the set of pairs of elements on those sets.
12:02:53 <Baughn> AHTOH: You've had a bash process eating half your cpu for a week?
12:02:55 * SamB noticse that gkrellm's fishtank is pink....
12:03:02 <ddarius> Cale: In C, a C function is not taking a tuple (or C# or Java or etc...)
12:03:16 * SamB thinks this a bad sign
12:03:16 <Cale> They simulate it with their syntax though.
12:03:18 <shachaf> meren: Most multiple-argument functions.
12:03:25 <Cale> Even if they don't have an explicit tuple type.
12:03:37 <shachaf> meren: Single-argument functions are not curried, of course. :-)
12:03:40 <sorear> meren: there isn't really a notion of function calls being curried or not.. in most languages, f x y means f(x,y), in Haskell it means (f x) y
12:03:58 <meren> i see.
12:04:01 <ddarius> Cale: Well we embed them in a premonoidal category and they are taking things like int(x)char
12:04:09 <sorear> meren: also, Haskell implementations have special hackery to make the latter form efficient
12:04:10 <shachaf> sorear: Most languages don't use space-separated arguments, but use commas.
12:04:13 <shachaf> sorear: (I think.)
12:04:26 <AHTOH> Baughn: i think that's for couple of monthes :) maybe an xserver i had forgotten on a server :(
12:04:30 <ddarius> currying is part of an isomorphism
12:04:40 <SamB> sorear: I thought ML had curried functions, called the same way as in Haskell...
12:04:42 <lament> i can think of only one language with space-separated arguments
12:04:43 <sehute> if I have a function that reads from a file, then wish to convert it to a string temporarily, manipulate it a bit and return an IO String, how do I temporarily remove the IO?
12:04:48 <sorear> shachaf: I know, I'm assuming that everyone uses Haskell syntax because having a common concrete syntax makes comparisons much easier
12:04:49 <ddarius> SamB: It does.
12:04:58 <lament> and that language has too many parentheses :)
12:05:00 <Cale> sehute: you use a do-block
12:05:03 <Baughn> AHTOH: This sort of thing is why I've configured mine to mail me whenever a process passes one day of cpu-time. :P
12:05:16 <shachaf> sorear: What non-currying languages other than Haskell use that syntax? I can only think of sh and friends.
12:05:19 <SamB> i.e. for some reason they just write their functions f (x, y) explicitly even though they don't have to
12:05:35 <SamB> and could have them curried?
12:05:37 <sorear> shachaf: Not related to my point.
12:05:47 <Cale> sehute: just run your action in a do-block and you'll get the result. You can then do some stuff with it before returning it.
12:05:47 <shachaf> sorear: I know. :-)
12:05:51 <sehute> Cale: I already do, but this doesn't seem to work:
12:05:57 <sorear> :)
12:05:59 <sehute> logdata <- readFile logfile
12:06:04 <ddarius> SamB: I think that comes from their ridiculous data type definitions and (now) the fact that passing tuples is highly optimized.
12:06:04 <sehute> putStrLn manage $ logdata
12:06:14 <Cale> putStrLn (manage logdata)
12:06:16 <SamB> sorear: so basically you are saying that most languages implicitly translate f (x, y) to f (x, y) ?
12:06:19 <sehute> Cale: where manage is the function that should handle strings only
12:06:20 <shachaf> sehute: putStrLn $ manage logdata
12:06:25 <Cale> Or  putStrLn $ manage logdata
12:06:34 <shachaf> sehute: putStrLn manage is a function of no arguments.
12:06:46 <sorear> SamB: Your statement is meaningless without a concrete syntax.
12:06:50 <SamB> ddarius: or maybe it's also habbit?
12:06:58 <SamB> sorear: yours was downright silly ;-P
12:07:25 <sehute> shachaf&Cale: thanks, but it still says it doesn't match String
12:07:28 <AHTOH> Baughn: yeah i found -- that's was probably dead bash from some ssh session
12:07:32 <ddarius> SamB: Now it's habit and consistency.  In the beginning, I doubt it was.
12:07:35 <shachaf> sehute: What's the type of manage?
12:07:50 <SamB> ddarius: well obviously they didn't start out with habbits
12:08:01 <sehute> shachaf: aha, that's where my bug is :) it was just String, not String -> String :)
12:08:03 <sehute> shachaf: thanks
12:08:11 <ddarius> SamB: They could have habits from other languages.
12:08:14 <sorear> SamB: Even the great SPJ says that having common notation is a good thing.
12:08:15 <sorear> We explain precisely what the two models are, in a common
12:08:15 <sorear> notational framework (Section 4). Surprisingly, this has not
12:08:58 <msouth> http://www.onlamp.com/pub/a/onlamp/2007/08/02/introduction-to-haskell-pure-functions.html?CMP=OTC-6YE827253101&ATT=Introduction+to+Haskell+Part+3+Monads
12:09:00 <lambdabot> Title: ONLamp.com -- Introduction to Haskell, Part 3: Monads, http://tinyurl.com/2jotbh
12:09:15 <AHTOH> Baughn: 11300 minutes cpu time. killed it :) now time back to haskell. I really wonder how to write _efficient_ programs using haskell. thats something more complicated than ordinary functional programming, as i see
12:09:17 <msouth> not sure if that's been in here or not, sorry if it's a repeat
12:09:29 <SamB> sorear: I think it would have made more sense if you used a C-based syntax, and talked about how that was basically tupling the arguments...
12:10:08 <monochrom> Writing efficient programs is always hard.
12:10:09 <SamB> our syntax doesn't make a great deal of sense if you don't have currying, you know
12:10:11 <shachaf> AHTOH: Efficient programs are harder in any language.
12:10:11 <ddarius> AHTOH: Ideally it is not, and things like ByteStrings demonstrate that that can be the case.
12:11:02 <AHTOH> ddarius: im just using bytestring.char8, but unfortunately i miss some references and arrays as we have im SML
12:11:05 <SamB> but efficient programs that do easy things are always easier to write than those that do hard things
12:11:21 <AHTOH> ddarius: really need something mutable :)
12:11:49 <ddarius> Mutable doesn't mean efficient.
12:11:59 <SamB> AHTOH: how slow is yours?
12:12:06 <AHTOH> shachaf: you are right, but i have several years experience writing them in C. And haskell/sml/... was just fun for me.
12:12:10 <monochrom> Is efficient programming in C easier? Probably not, it likely takes you five years of learning and experience to achieve that.
12:12:21 <dcoutts> mutable means you can't share, which is a very important optimisation in ByteString
12:12:24 <AHTOH> SamB: mine what you mean?
12:12:31 <SamB> monochrom: plus five years to write your program
12:12:37 <SamB> AHTOH: your dna2rna?
12:13:11 <dcoutts> AHTOH: if we could not share, we could not do O(1) substring, which is kind of important, imagine if tail was O(n)
12:13:12 <sorear> monochrom: Efficient programming in C is harder that inefficient programming, witness the effectiveness of the "Forget about small efficiencies" programme
12:13:26 <AHTOH> SamB: 6minutes yet. but i think thats because of bad data structure -- i dont allocate new bytestrings for new data. just one sorce bytestrings
12:13:49 <SamB> AHTOH: that sounds about on par with the one I'm using. (which I didn't write)
12:13:55 <monochrom> Therefore it is confused to say "after five months of encountering Haskell I find it so hard to write an efficient program". Five months. You didn't even learn to walk in five months.
12:14:10 <SamB> except maybe one of your CPU's cores is faster than mine...
12:14:29 <dcoutts> and we can construct ByteStrings without having the mutability explicit in the api, it can still be pure
12:15:42 <ddarius> dcoutts: Where do you use mutability in the ByteString implementation (ignoring Haskell boundaries)?
12:15:48 <SamB> after five months of programming in Python, your idea of "efficient" would be a lot slower than after five months of Haskell, I think...
12:15:48 <AHTOH> SamB: data Dna = MChunk (Int,Int,Int) | Str String and a type EndoDna = B.ByteString, so my dna state is always (EndoDna,[Dna]) ,where first bytestring is forever unchanged
12:16:26 <dcoutts> ddarius: we construct ByteStrings in a mutable style internally, by allocating a chunk of memory and then writing into it
12:16:28 <dinoMI> A co-worker told me there's an "Introduction to Haskell, Part 3" at O'R's ONLamp site, but I can't find it yet on front page or search. Anybody seen this?
12:16:55 <dcoutts> ddarius: but perhaps you mean the ByteString Builder which gives O(1) append for constructing ByteStrings
12:17:22 <shachaf> dinoMI: It was just lined here a moment ago.
12:17:27 <Cale> dinoMI: yes, it's on reddit
12:17:28 <dinoMI> :o
12:17:28 <SamB> dcoutts: you were the one who mentioned implicit mutability!
12:17:30 <shachaf> http://www.onlamp.com/pub/a/onlamp/2007/08/02/introduction-to-haskell-pure-functions.html?CMP=OTC-6YE827253101&ATT=Introduction+to+Haskell+Part+3+Monads
12:17:31 <lambdabot> Title: ONLamp.com -- Introduction to Haskell, Part 3: Monads, http://tinyurl.com/2jotbh
12:17:36 <AHTOH> SamB: i ve heard c versions are faster than 1 minute
12:17:55 <dinoMI> Fabulous. Thank you.
12:18:01 <dcoutts> SamB: which is much better, if it's actually pure but internally uses mutable stuff then fine.
12:18:18 <Cale> It's not too spectacular, there are better tutorials on monads out there :)
12:18:20 <dcoutts> SamB: it's explicit mutable arrays I was railing against :-)
12:18:22 <SamB> AHTOH: but have you heard what the implementors' shrinks had to say about the implementors?
12:18:27 <SamB> dcoutts: yes I know.
12:18:39 <ddarius> Well the first case you mention seems more like a necessity (i.e. a missing "primitive"), how else could you do it?
12:18:40 <AHTOH> no
12:19:07 <sehute> is there a version of "take" that takes values from the right side of a list instead of the left?
12:19:10 <SamB> dcoutts: but why would it be ddarius who would "mean the ByteString Builder"?
12:19:19 <AHTOH> SamB: so what do you mean?
12:19:22 <ddarius> sehute: \n -> take n . reverse
12:19:29 <sehute> or should I: right n s = drop ((length s) - n) s
12:19:36 <dcoutts> SamB: because I mentioned two things, he could have been referring to either
12:19:47 <SamB> AHTOH: or have you heard how many aspirins they had to go through to write those interpreters?
12:20:02 <ddarius> dcoutts: I was just asking in general.
12:20:22 <desegnis> ddarius, \n -> reverse . take n . reverse
12:20:55 <DRMacIver> Cale had a really nice solution for taking from the end.
12:20:58 <dcoutts> ddarius: the key point is that once ByteStrings are constructed they're immutable, before they've been handed to the user it's ok to use mutation though.
12:21:06 <ddarius> sehute: At any rate, this is not a function you should be using.
12:21:08 <SamB> in Python, to get something like the ByteString builder, you need a really involved JIT...
12:21:14 <AHTOH> SamB: and how many? my objective is to see what best can haskell do with this task
12:21:25 <ddarius> dcoutts: I understand that.  I was just wondering what part of the interface actually needs mutability.
12:21:30 <dcoutts> SamB: why is that?
12:21:38 <dcoutts> ddarius: no part of the interface needs it.
12:21:39 <SamB> dcoutts: it has immutable strings!
12:21:55 <ddarius> dcoutts: Needs it to be implemented reasonably.
12:22:01 <DRMacIver> \x -> zipWith const (drop n x) (tails x) I think.
12:22:11 <DRMacIver> err. Other way around.
12:22:15 <dcoutts> SamB: right, so Builder is a separate type, like Java's StringBuilder
12:22:19 <dcoutts> ddarius: sure
12:22:32 <SamB> dcoutts: well, I mean, the typical way to write code to build a string is like this:
12:22:41 <DRMacIver> Damn. I've forgotten how this works now. :) One second.
12:22:41 <EvilTerran> if something running in GHCi pauses every few seconds, it's probably running GC, right?
12:22:42 <AHTOH> apropos, why do you think that mutable objects cannot be shared? the reference will be shared. ref in SML is just the thing that sits in my head.
12:22:54 <dcoutts> SamB: with O(n^2) repeated append you mean?
12:23:05 <EvilTerran> i think you want "\xs -> zipWith const xs (drop n xs)"
12:23:05 <SamB> dcoutts: er, yeah, that
12:23:09 <ddarius> EvilTerran: You can have it give GC stats I believe.
12:23:13 <sehute> ddarius: I am creating a general string-library for the sake of learning, why should I not include it?
12:24:07 <dcoutts> SamB: yeah, that's exactly what Java's StringBuilder is for (or was it StringBuffer) it provides a way of building a string in a mutable way before freezing it into an ordinary string. And that's exactly what we do, but the Builder api is also pure.
12:24:09 <EvilTerran> wait, that'd be (reverse . drop n . reverse). hm.
12:24:11 <ddarius> sehute: It's a fine function for strings, but not for lists.  You should use a different representation if you are going to expose such a function (there's a reason it isn't provided by Haskell albeit init is).
12:24:34 <ddarius> StringBuffer I'm pretty sure.
12:24:39 * roconnor hates gnu-make
12:24:48 <sehute> ddarius: what kind of representation is better?
12:24:55 <SamB> dcoutts: well, the Java way is too ugly to be Pythonic...
12:24:57 <ddarius> Data.Sequence would be one possibility.
12:25:04 <sehute> ddarius: I see, thanks
12:25:07 <EvilTerran> wow. i think i just seriously hemmoraged memory in ghci.
12:25:09 <SamB> not that nobody ends up doing it...
12:25:59 <SamB> though a more likely thing is that they'll just build a list of strings and ''.join() it
12:26:21 <DRMacIver> > (\n xs -> last $ zipWith const (tails xs) (drop n xs)) 3 [1..10]
12:26:23 <lambdabot>  [7,8,9,10]
12:26:34 <DRMacIver> Hm. Off by one error. :)
12:26:53 <EvilTerran> "last"? i don't like the look of that...
12:27:01 <sehute> how can I find out which one is faster of "right n = reverse . take n . reverse" and "right n s = drop ((length s) - n) s"? (roughly)
12:27:08 <DRMacIver> EvilTerran: Why not?
12:27:13 <sehute> is there a built-in function for testing it?
12:27:27 <EvilTerran> actually, i guess everything'll be O(n) for this. never mind me.
12:27:40 <sehute> EvilTerran: yes, but still :)
12:27:49 <Saizan> sehute: the first is O(n^2), the second O(n)
12:28:01 <DRMacIver> Saizan: Huh?
12:28:13 <Saizan> DRMacIver's solution is the best because it's lazy
12:28:25 <EvilTerran> sehute, have two instances of GHCi open, set to do the same task in ever-increasing sizes, one each way. start them as close together as possible, go have lunch, and see which one's ahead when you get back ;]
12:28:35 <Botje> sehute: i'd go for right n s = filter (\l -> length l == n) $ tails s
12:28:56 <sehute> EvilTerran: so there's no built in function for profiling with randomized input or anything?
12:28:58 <AHTOH> sehute: you can use a ghc profiler
12:29:03 <Baughn> sehute: The first one scans the list five times, the second one two
12:29:04 <DRMacIver> Saizan: It's a) Cale's solution really and b) Isn't lazy. Its advantage is that it allows the head to be garbage collected while it evaluates. It still needs to process the whole thing to get anywhere.
12:29:06 <Botje> EvilTerran: you could probably cannibalize QuickCheck's Arbitrary generation.
12:29:14 * EvilTerran uses sequence_ [print $ ... | i <- [1..]] for this process
12:29:20 <dcoutts> sehute: in ghci turn timing on with :set +s  then try some really big examples
12:29:47 <EvilTerran> Saizan, i think they're both O(n)
12:29:48 <Saizan> DRMacIver: more lazy then :)
12:30:01 <Saizan> yeah, they're O(n)
12:30:13 <Cale> DRMacIver: what's my solution?
12:30:25 <DRMacIver> Cale: The above thing with tails for getting the last n elements of a list.
12:30:50 <Cale> ah
12:31:21 <Botje> it's O(n²) actually
12:31:31 <Botje> since it computes the length of every element of tails
12:31:46 <Botje> if you know the length in advance you can just tails !! (n-s)
12:31:46 <DRMacIver> What?
12:31:47 <Saizan> eh?
12:31:52 <sehute> okay, I'll time it and give you the results :)
12:32:10 <Botje> DRMacIver: at least mine is, don't know if that's what you meant
12:32:11 <DRMacIver> It doesn't compute any lengths at all. That's the point. :)
12:32:14 <DRMacIver> Ah
12:32:21 <Botje> (since it used tails too)
12:32:37 <DRMacIver> I didn't actually notice yours. :)
12:32:42 <Saizan> > (\n xs -> last $ zipWith const (tails xs) (drop n xs)) 3 [1..10]
12:32:44 <lambdabot>  [7,8,9,10]
12:32:53 <Botje> oh, that
12:32:57 <Botje> too much magic for me :)
12:33:01 <DRMacIver> Except with the off by one error fixed. :)
12:33:07 <DRMacIver> Botje: The magic is there for a useful reason though.
12:33:27 <monochrom> There is no magic.
12:33:57 <DRMacIver> Botje: All the others will prevent the list from being garbage collected.
12:34:02 <Botje> yeah.
12:34:07 <EvilTerran> hm... tails is a very lightweight operation, isn't it?
12:34:07 <Botje> I see it now
12:34:09 <Botje> clever :)
12:34:12 <Cale> EvilTerran: yeah
12:34:28 <EvilTerran> (compared to, say, inits)
12:34:48 <EvilTerran> because it can wholly re-use list cells
12:34:49 <meren> is it possible to define functions in Haskell with optional parameters? I mean, for example in python it is possible to define a function like this: def f(x, y = 0): ... and then it's possible to call it either like f(x) or f(x, y) (I need to define something like this now but I guess I'll be happy if Haskell doesn't have it).
12:34:57 <Cale> EvilTerran: exactly
12:35:22 <oerjan> meren: fits very badly with currying
12:35:29 <Cale> meren: no, but you could do something with a datatype to handle something like it
12:35:34 <DRMacIver> meren: Not without some really unpleasant hacks. :)
12:35:40 <meren> :)
12:35:45 <meren> cool.
12:35:49 <Cale> Oh, there's the typeclass hack too :)
12:35:51 <EvilTerran> meren, the closest we've got is Maybe parameters.
12:35:57 <EvilTerran> without nasty hacks
12:36:02 <monochrom> How important are optional parameters?
12:36:14 <meren> not important at all, in my opinion..
12:36:16 <DRMacIver> monochrom: Moderately, I'd have said.
12:36:44 <gkr> After an expression is reduced, Hugs uses show on it?
12:36:47 <DRMacIver> I find them very useful when they're available and rarely miss them when they're not.
12:37:00 <monochrom> yes gkr
12:37:05 <meren> DRMacIver: excatly same here.
12:37:15 <EvilTerran> @type fromMaybe
12:37:17 <lambdabot> forall a. a -> Maybe a -> a
12:37:27 <roconnor> @type maybe
12:37:30 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:37:32 <gkr> And what about (return 4 :: IO Int) ?
12:37:39 <gkr> Why it doesn't try to show it?
12:37:45 <dolio> > minBound :: Word
12:37:47 <lambdabot>  0
12:37:52 <monochrom> no show for IO a
12:37:56 <EvilTerran> f x maybeY = let y = fromMaybe defaultY maybeY in {...}
12:38:07 <gkr> monochrom but it shouldn't say that show isn't overloaded on IO Int?
12:38:29 <EvilTerran> > show (return 4 :: IO Int)
12:38:30 <lambdabot>  "<IO Int>"
12:38:37 <monochrom> show isn't overloaded on IO Int or IO a. That is a correct statement.
12:38:55 <EvilTerran> ...then you can say (f 4 Nothing) or (f 4 (Just 5)) or whatever
12:38:59 * EvilTerran goes away for a bit
12:39:28 <gkr> If I do "return 4:: IO Int", it says nothing, it gives me back the prompt. If I do "show (return 4::IO Int)" there it says that show isn't overloaded on IO Int
12:39:39 <monochrom> If you can't parse that statement, here is an equivalent one.  IO Int or IO a is not an instance of Show.
12:39:41 <EvilTerran> gkr, i suspect it may run an IO action if you type one at the command line
12:39:48 <gkr> Shouldn't "return 4::IO Int" say that show isn't overloaded as well?
12:39:56 <shachaf> gkr: THat's because it's in GHCi.
12:40:02 <shachaf> gkr: Which is like do-notation.
12:40:05 <gkr> I am using Hugs.
12:40:06 <monochrom> I thought it was hugs.
12:40:07 <shachaf> gkr: In IO.
12:40:09 <sehute> >  right 5 ['A'..'z'] where right n s = filter (\l -> length l == n) $ tail s
12:40:09 <lambdabot>  Parse error
12:40:13 <shachaf> gkr: Oh.
12:40:13 <EvilTerran> but if you type something that isn't an IO action, it implicitly wraps it in print (...)
12:40:24 <EvilTerran> @src print
12:40:24 <lambdabot> print x = putStrLn (show x)
12:40:27 <shachaf> gkr: Well, ghci runs IO actions, at least.
12:40:36 <monochrom> I don't know why you can get it to be silent.
12:40:36 <sehute> Botje: it didn't work for me
12:40:39 <shachaf> gkr: Rather than showing them directly.
12:40:50 <gkr> But I don't understand why hugs tries to show most of the types, but no IO a
12:41:06 <EvilTerran> actually, Hugs has an option to not use show instances, and use something builtin instead
12:41:11 <shachaf> gkr: What happens if you type in "getLine"?
12:41:28 <Botje> > let right n s = head $ filter (\l -> length l == n) $ tails s in right 5 ['A'..'z']
12:41:30 <lambdabot>  "vwxyz"
12:41:41 <EvilTerran> they're mostly like the default Show instances, but they generate valid haskell even if your show instance does something else
12:41:48 <gkr> shachaf I input a line, and after that I get back the prompt.
12:41:48 <Botje> sehute: but use the zipWith const one, it's faster.
12:42:03 <shachaf> gkr: Hmm, so it's a bit different from GHCi.
12:42:33 <shachaf> gkr: Anyway, would you (for example) want show errors every time you putStrLn a string?
12:43:01 <gkr> Yep.
12:43:03 <shachaf> gkr: You can see (since you needed to input a line) that it runs the action.
12:43:07 <gkr> At least is consistent.
12:43:20 <sehute> > last $ zipWith const (tail xs) (drop n xs)) 5 ['A'..'z']
12:43:20 <lambdabot>  Parse error
12:43:29 <shachaf> gkr: GHCi would also print the result.
12:43:31 <EvilTerran> gkr, check the option i mentioned
12:43:32 <sehute> Botje: that one?
12:43:47 <gkr> Let's say, if I have data BABA = MAMAMA, and then I write "MAMAMA", it says that show :: BABA -> String isn't defined. But... with IO a, it says nothing.
12:43:49 <gkr> That's odd.
12:44:12 <gkr> EvilTerran let me see.
12:44:40 <oerjan> gkr: well IO is run, everything else is shown.
12:44:52 <Cale> gkr: that's just how the REPL works
12:44:53 <Botje> > let right n s = last $ zipWith const (tail xs) (drop n xs) in right 5 ['A'..'z'] -- sehute
12:44:53 <lambdabot>   Not in scope: `xs'
12:44:57 <Botje> argh
12:45:03 <Botje> > let right n xs = last $ zipWith const (tails xs) (drop n xs) in right 5 ['A'..'z'] -- sehute
12:45:04 <lambdabot>  "uvwxyz"
12:45:08 <Botje> sehute: also note how it's tails, not tail.
12:45:09 <oerjan> it could hardly be otherwise.
12:45:49 <shachaf> gkr: The REPL is like do-notation in IO.
12:46:00 <oerjan> shachaf: not in Hugs
12:46:04 <Cale> Only it sticks 'print' in front of non-IO expressiosn
12:46:06 <sehute> Botje: hugs doesn't have "tails"
12:46:07 <gkr> Wait, what REPL is?
12:46:09 <shachaf> oerjan: Oh.
12:46:15 <Cale> gkr: GHCi
12:46:16 <shachaf> gkr: Sorry, ignore me.
12:46:26 * shachaf makes silly baseless assumptions.
12:46:36 <sehute> Botje: but thanks, I'll keep the line that worked still
12:46:52 <Botje> sehute: you need to import the Data.List module
12:47:03 <Botje> (or List, depends on how your system calls it)
12:47:09 <shachaf> Hmm, what are the main reasons for using Hugs?
12:47:13 <gkr> Cale and what it does with IO expressions? What command would it execute?
12:47:16 <Botje> http://haskell.org/hoogle/?q=tails -- hoogle says it's in List
12:47:17 <lambdabot> Title: tails - Hoogle
12:47:27 <shachaf> I've heard that it's smaller and that it's more Windows-friendly. Is there anything else?
12:47:29 <Cale> gkr: It'll just run the IO things you give it
12:47:34 <sehute> Botje: okay, thanks, I'll time that one as well :)
12:47:39 <shachaf> @hoogle tails
12:47:39 <lambdabot> List.tails :: [a] -> [[a]]
12:47:40 <lambdabot> Text.PrettyPrint.HughesPJ.TextDetails :: data TextDetails
12:47:41 <shachaf> @index tails
12:47:41 <lambdabot> Data.List
12:48:23 <gkr> Ooook.
12:48:49 <DRMacIver> Oops. Wrong server. :)
12:48:59 <shachaf> Does Hugs have any specfic features GHC doesn't?
12:49:15 <gkr> Is there any other type which Hugs treats it different?
12:49:19 <shachaf> I may have heard something about existential types...
12:49:23 <Cale> gkr: For example, if you type  putStrLn "Hello"  at the GHCi prompt, it'll run and print Hello on your terminal
12:49:56 <gkr> Hugs does the same.
12:50:15 <Cale> gkr: If you type "Hello", it will turn that into  print "Hello", and you'll see a quoted "Hello" printed back at you
12:50:31 <Cale> print = putStrLn . show
12:50:45 <Cale> > show "Hello"
12:50:47 <lambdabot>  "\"Hello\""
12:51:01 <shachaf> > fix show
12:51:02 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
12:51:30 <sfultong> >take 80 $ iterate show ("")
12:51:46 <sfultong> > take 80 $ iterate show ("")
12:51:47 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
12:52:04 <gkr> Cale is there any other type that works different?
12:52:10 <shachaf> > concat $ iterate show ""
12:52:13 <Cale> gkr: Nope.
12:52:16 <lambdabot>  "\"\"\"\\\"\\\"\"\"\\\"\\\\\\\"\\\\\\\"\\\"\"\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\...
12:52:28 <gkr> Cale where is it specified?
12:52:29 <meren> someone asked how to convert numbers into list of digits 1 hour ago (like converting 12345 into [1, 2, 3, 4, 5]).. I wrote something for it and this is the first thing I wrote in Haskell after 2 days of reading :) that's here: http://rafb.net/p/m7MS2j42.html it took 1 hour from me :/
12:52:30 <lambdabot> Title: Nopaste - convert a number into list of digits..
12:52:32 <shachaf> > iterate show "" !! 80
12:52:33 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
12:52:44 <Cale> gkr: Inside hugs/ghci's source code/manuals?
12:52:57 <shachaf> > map digitToInt (show 12345) -- :-)
12:52:58 <lambdabot>  [1,2,3,4,5]
12:53:03 <Cale> It's not part of the Haskell spec.
12:53:07 <meren> shoot.
12:53:09 <shachaf> Cheating, of course.
12:53:17 <gkr> Uhm, ok.
12:53:21 <shachaf> meren: Look at unfoldr, though.
12:53:26 <ddarius> It's an easy unfoldr
12:53:32 <gkr> Thank you people.
12:53:35 <shachaf> @ty unfoldr
12:53:37 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:53:58 <meren> :/
12:54:09 <Botje> meren: it's not bad for a first haskell script :)
12:54:14 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/ch03s04.html
12:54:21 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/2c2oeu
12:54:26 <Cale> there's where the GHCi manual discusses it
12:54:50 <meren> Botje: eheh thanks
12:55:05 <SamB> I think GHCi first tries to typecheck "it >>= print", then just "it >> return ()", then finally "print it"
12:55:05 <Cale> http://cvs.haskell.org/Hugs/pages/users_guide/using-hugs.html#BASIC-COMMANDS -- and there it is for hugs
12:55:07 <lambdabot> http://tinyurl.com/yty6s5
12:55:15 * gkr hugs Cale
12:55:19 <as> quit
12:55:21 <Cale> :)
12:55:22 <sehute> > zipWith const (tails xs) (drop n xs) where n = 100; xs = ['A'..'z']
12:55:22 <lambdabot>  Parse error
12:55:43 <SamB> well. it'll skip it >>= print depending on a flag
12:56:10 <oerjan> sehute: i see you've found another difference between ghci and hugs
12:56:11 <Cale> sehute: 'where' is part of declaration syntax, inside an expression, you need to use 'let'
12:56:14 <ddarius> cdsmith: I wrote a TH thing a long long time ago that would turn f (! x) (! y) into do x' <- x; y' <- y; f x y  Unfortunately, I don't think I still have the code.
12:56:28 <Botje> meren: you could use divMod to prettify getList a bit
12:56:59 <sehute> > let f xs n = zipWith const (tails xs) (drop n xs) where n = 100; xs = ['A'..'z']
12:56:59 <lambdabot>  Parse error
12:57:04 <Botje> > 12345`divMod`10000
12:57:05 <lambdabot>  (1,2345)
12:57:11 <meren> aha
12:57:20 <cdsmith> ddarius: That's interesting: I hadn't thought of doing such a thing with TH.
12:57:21 <meren> great
12:58:04 <oerjan> sehute: f ... where ... becomes let ... in f ...
12:58:13 <meren> by the way, what is the main difference between hugs and ghci (except the fully qualified function names thing and the fact that ghc is written by peyton-jones)?
12:58:26 <sehute> oerjan: thanks, I'm becoming tired :)
12:58:33 <sorear> meren: ghci is written mostly in Haskell
12:58:39 <cdsmith> meren: hugs is only an interpreter, for one.
12:58:42 <dinoMI> meren: hugs can't compile to binary, is that still true?
12:58:57 <sehute> > f ['A'..'z'] 100 where f xs n = zipWith const (tails xs) (drop n xs)
12:58:57 <lambdabot>  Parse error
12:59:06 <DRMacIver> Fully qualified function names thing?
12:59:07 <meren> so as an interactive shell whay would i prefer hugs over ghci?
12:59:20 <SamB> well hugs seems to have a faster parser
12:59:33 <sorear> hugs is much faster
12:59:34 <SamB> or at least :l seems faster
12:59:57 <ddarius> cdsmith: Oh cool.  I do still have it.  Probably bitrotted to hell though.
13:00:00 <oerjan> > let f xs n = zipWith const (tails xs) (drop n xs) in f ['A'..'z'] 100
13:00:01 <lambdabot>  []
13:00:07 <meren> DRMacIver: I read something about that you can call a function like "func" in hugs but you should call it like "Data.List.func" in ghci..
13:00:09 <SamB> so if you are writing nearly-98 code and spending a lot of time loading code
13:00:15 <SamB> try hugs
13:00:18 <shachaf> meren: :m + Data.List
13:00:20 <sehute> oerjan: what was wrong with my last attempt?
13:00:42 <meren> shachaf: thanks :)
13:00:44 <sehute> oerjan: the missing "let"?
13:00:46 <oerjan> sehute: you cannot use where in the repl
13:01:08 <oerjan> the syntax of where and let are completely reversed
13:02:25 <oerjan> (well, you can use where but only more deeply nested)
13:02:29 <gkr> Why do you use GHCi and not Hugs?
13:02:44 <sehute> oerjan: the strange thing is that that variant of right gives this error while testing: Program error: pattern match failure: last []
13:02:53 <sehute> oerjan: the others doesn't
13:02:55 <meren> gkr: because I saw GHCi first..
13:03:04 <cdsmith> gkr: (a) more language features implemented, and (b) consistent with the ghc compiler
13:03:09 <sfultong> > 3333333333343453 > (maxBound::Int)
13:03:10 <lambdabot>  False
13:03:34 <oerjan> what variant?
13:03:52 <sehute> oerjan: right n xs = last $ zipWith const (tails xs) (drop n xs)
13:03:54 <shachaf> > 3333333333343453 > fromIntegral (maxBound::Int)
13:03:55 <lambdabot>  True
13:04:06 <sehute> oerjan: with this type: right :: Int -> String -> String
13:04:33 <sehute> oerjan: via this function: testright f n = f n ['A'..'z']
13:04:47 <sehute> oerjan: with this type: testright :: (Int -> String -> String) -> Int -> String
13:04:51 <sfultong> > 3333333333343453 > toInteger (maxBound::Int)
13:04:53 <lambdabot>  True
13:05:00 <oerjan> oh. because the inner part is empty.
13:05:01 <sehute> oerjan: called from main like this: putStrLn $ testright right 100
13:05:23 <sehute> oerjan: which inner part?
13:05:31 <oerjan> the part after last
13:05:47 <sehute> oerjan: (drop n xs) ?
13:05:52 <oerjan> when you use an integer bigger than the list length
13:05:53 <sfultong> I think 3333333333343453 > fromIntegral (maxBound::Int) should at least give a compiler warning... does it?
13:06:46 <oerjan> yes, i guess that's the culprit
13:07:21 <sehute> oerjan: so that variant of the "right" function has to check if n is bigger than the length of the list first?
13:07:24 <meren> bye everyone and thanks for the help.
13:07:36 <sehute> Botje: does it have to?
13:08:05 <oerjan> i think it is more efficient to make a variant of last that checks if its argument is empty
13:08:16 <shachaf> ddarius: http://www.cs.nott.ac.uk/~ctm/IdiomLite.pdf seems to define something similar to your f (! x) (! y) TH, I think.
13:08:25 <shachaf> ddarius: Or at least talk about it.
13:09:07 <sehute> oerjan: I have no idea what that would look like :)
13:09:52 <oerjan> or a case statement: case zipWith ... of f:l -> f ; [] -> []
13:10:56 <oerjan> oh wait
13:11:07 <oerjan> i'm speaking nonsense
13:11:57 <oerjan> a simpler solution, use last $ [] : zipWith ...
13:12:13 <oerjan> then if it is empty, the [] gets used
13:13:00 <oerjan> er, that's wrong too.
13:13:12 <oerjan> should be the whole list.
13:13:58 <shachaf> @wiki Idiom brackets
13:13:58 <lambdabot> http://www.haskell.org/haskellwiki/Idiom_brackets
13:14:56 <sehute> "right n s = drop ((length s) - n) s" was marginally quicker than "right n = reverse . take n . reverse"
13:15:03 <oerjan> last $ xs : zipWith ...
13:15:34 <sehute> oerjan: how would the whole line be? :)
13:15:55 <sehute> if this was to be modified: right n xs = last $ zipWith const (tails xs) (drop n xs)
13:16:24 <shachaf> > fromMaybe [] (listToMaybe [])
13:16:26 <lambdabot>  []
13:16:27 <shachaf> > fromMaybe [] (listToMaybe [1])
13:16:28 <lambdabot>   add an instance declaration for (Num [a])
13:16:28 <lambdabot>     In the expression: 1
13:16:31 <DRMacIver> I think it should actually drop (n - 1)
13:16:38 <shachaf> > fromMaybe [] (listToMaybe [[1]])
13:16:39 <lambdabot>  [1]
13:19:00 <reffie> anyone not in academia/microsoft getting paid to write haskell code?
13:19:10 <xerox> reffie: galois.com
13:19:22 <Botje> reffie: there's a page on the wiki about industrial usage
13:19:23 <xerox> reffie: and also a bunch of people at creditsuisse
13:19:35 <dylan> shapr is, I think.
13:19:43 <dinoMI> reffie: As it happens, we're somehow talked our company into experimenting with it.
13:19:49 <dinoMI> s/we're/we've/
13:19:50 <xerox> Ah right, HAppS!
13:19:51 <sehute> in my eyes "drop ((length s) - n) s" was the winner. It was O(n), quick enough, not redundant and didn't produce any errors at any times, even when n was bigger than the list :)
13:19:56 <Botje> reffie: the linspire distro uses haskell for its package management
13:20:09 <xerox> dinoMI: .it?
13:20:12 <SamB> reffie: aren't the academics paid to write *papers*?
13:20:19 <reffie> SamB not sure
13:20:26 <dinoMI> xerox: Haskell. Specifically we built a REST service with HAppS.
13:20:32 <reffie> anyway, i have to go to work :)
13:20:40 <dinoMI> Thanks to the very helpful people here and on #happs.
13:20:40 <Heffalump> write some Haskell :-)
13:20:41 <xerox> dinoMI: yeah, I wonder if it's an italian company :)
13:21:02 <dinoMI> xerox: No, US, NC, Raleigh
13:21:05 <dinoMI> :)
13:21:10 <xerox> Alright :-)
13:23:41 <sfultong> how come Data.Map has findMin, but Data.IntMap doesn't?
13:24:33 <DRMacIver> sehute: The main issue with it is that it doesn't stream properly. If this isn't a problem, it is indeed probably the best solution.
13:25:13 <DRMacIver> (length should probably be considered an unsafe function due to Haskell's bad habit of not distinguishing between finite and infinite data structures at the type level...)
13:25:23 <sfultong> Data.Graph.Inductive.Internal.FiniteMap may be deprecated, but at least it had splitMinFM
13:25:56 <sehute> DRMacIver: okay, I'm convinced, but how should this function be modified in order to handle the other cases as well?  right n xs = last $ zipWith const (tails xs) (drop n xs)
13:26:41 <DRMacIver> Well, n should be replaced with n - 1. What are the other cases it doesn't handle?
13:30:15 <rubyruy> i'm reading the gentle intro ... having trouble understanding "list comperhension" - is it just building a list using map (aka collect) ?
13:31:03 <rubyruy> i.e. is [ f x | x <- xs ]  roughly equivalent to ruby xs.collect(&f) ?
13:31:28 <oerjan> DRMacIver: n > length, which last $ xs : ... should take care of
13:34:02 <xerox> rubyruy: possibly, yes, it applies f to each element of the list xs, but list comprehension can do more
13:35:15 <oerjan> rubyruy: doesn't ruby have for comprehensions like python?
13:35:39 <shachaf> oerjan: No.
13:35:58 <shachaf> rubyruy: Yes, it's equivalent, but as xerox said, it can do more.
13:36:07 <rubyruy> okdokee
13:36:25 <shachaf> > [(x,y) | x <- [1..10], y <- [1..10]]]
13:36:25 <lambdabot>  Parse error
13:36:28 <shachaf> > [(x,y) | x <- [1..10], y <- [1..10]]
13:36:32 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(2...
13:36:34 <xerox> Cartesian product!
13:36:40 <shachaf> > [(x,y) | x <- [1..10], y <- [1..10], x * y == 8]
13:36:41 <lambdabot>  [(1,8),(2,4),(4,2),(8,1)]
13:37:30 <shachaf> rubyruy: You can read read "|" as "such that".
13:37:48 <shachaf> rubyruy: And some people read "<-" as "is taken from", I think.
13:38:04 <balodja> xerox: why not descartes?
13:38:18 <shachaf> Descartesian product?
13:38:58 <xerox> Then there's -fparr that does [: ... | ... :] parallell array comprehension.
13:39:16 <glguy> xerox: do you know what version of GHC that is in?
13:39:33 <xerox> glguy: it works in my GHC 6.7.
13:39:38 <shachaf> xerox: For someone "reading the gentle intro"? :-)
13:40:01 <xerox> shachaf: it reallu just amounts to learning a new datastructure, which is quite simple, as lists are :)
13:40:32 <shachaf> > [(x,y) | x <- [1..10] | y <- [1..10]]
13:40:32 <lambdabot>  Parse error
13:40:43 <shachaf> Hmm. How does that work?
13:41:03 <DRMacIver> > [(x, y) | x <- [1..10], y <- [1..10]]
13:41:05 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(2...
13:41:15 <xerox> shachaf: it needs extensions
13:41:25 <shachaf> DRMacIver: I meant the zipping syntax.
13:41:32 <shachaf> Not in lambdabot, apparently. :-(
13:41:32 <oerjan> shachaf: same as zip [1..10] [1..10] i think
13:41:59 <geezusfreeek> > zip [1..10] [1..10]
13:42:00 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
13:42:05 <xerox> shachaf: nope, but it should be allowed :)
13:42:36 <DRMacIver> Oh. It works like that, but it requires some GHC extension.
13:42:47 <DRMacIver> Ah, which is what was being discussed
13:42:48 <DRMacIver> Sorry. :)
13:42:59 <shachaf> I thought lambdabot ran with -fglasgow-exts.
13:43:01 <sjanssen> "Any suggestions for a perfect example that uniquely demonstrates the benefits of the Haskell language compared to other languages?"
13:43:05 <sjanssen> that's asking a bit much ;)
13:43:44 <oerjan> shachaf: on the contrary, i remember reading lambdabot has only a few extensions enabled
13:43:45 <zbrown> DRMacIver: the fibonacci series? as follows: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
13:43:59 <shachaf> oerjan: Apparently, yes.
13:44:17 <geezusfreeek> sjanssen: well, xmonad seems to be a popular program to peek at the source for demonstrating haskell lately
13:44:48 <geezusfreeek> although it is probably not as trivial as you wanted
13:45:25 <DRMacIver> zbrown: Hm? I'm not sure what that was in response to.
13:45:25 <shachaf> sjanssen: Compared to which other languages?
13:45:29 <sjanssen> geezusfreeek: someone else is looking for the "perfect example", I'm quoting a message on the mailing list
13:45:36 <sjanssen> shachaf: I dunno, ask Jon Harrop
13:45:37 <shachaf> DRMacIver: Maybe to sjanssen?
13:45:49 <shachaf> Oh, Jon Harrop.
13:45:58 <sjanssen> (OCaml for one, I imagine)
13:46:07 <zbrown> DRMacIver: oh an example of haskell's power?
13:46:14 <zbrown> DRMacIver: I thought you asked, my apologies.
13:46:22 <geezusfreeek> sjanssen: oops, i got that, i just said "you" by accident
13:46:29 <DRMacIver> zbrown: No worries. :)
13:46:56 <zbrown> I wish I had more time to devote towards haskell lol
13:48:02 <shachaf> > let fibs = 1 : 1 : [x + y | x <- fibs | y <- tail fibs]
13:48:02 <lambdabot>  Parse error
13:48:06 <shachaf> Oh, lambdabot again.
13:48:23 <glguy> shachaf: you need an in ...
13:48:30 <shachaf> Well, it seems to work, though the zipWith version is shorter (and seems more readable?)
13:48:37 <shachaf> glguy: I do, but it won't work anyway.
13:48:41 <shachaf> > let fibs = 1 : 1 : [x + y | x <- fibs | y <- tail fibs] in fibs
13:48:41 <lambdabot>  Parse error
13:48:45 <glguy> oh, right
13:49:06 <msouth> > [ (x,y) | x <- [1..10], y <-[ x .. 10 ] ]
13:49:11 <shachaf> > fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs))
13:49:14 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,2),(2,3),(2...
13:49:15 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:50:17 <glguy> > fix ((0 :). scanl1 (+) . (1:))
13:50:19 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:50:47 <glguy> > fix ((0 :). scanl1 (+) 1)
13:50:48 <lambdabot>  Couldn't match expected type `a -> [t]'
13:50:51 <glguy> oops
13:50:55 <glguy> > fix ((0 :). scanl (+) 1)
13:50:56 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:51:08 <DukeDave> Aha, glguy! I've been waiting for you :)
13:51:17 <glguy> oh dear
13:51:18 <glguy> :)
13:51:22 <shachaf> glguy: I knew that one would come up after I used fix. :-)
13:51:41 <msouth> @src scanl
13:51:41 <lambdabot> scanl f q ls = q : case ls of
13:51:41 <lambdabot>     []   -> []
13:51:41 <lambdabot>     x:xs -> scanl f (f q x) xs
13:51:53 <DukeDave> Nothing important now, but for future reference - are you the sort of person I'm likely to bombard with all the HOpenGL questions I'm going to be having in the next few days?
13:52:00 <glguy> lol, nope
13:52:10 <glguy> "glguy" has nothing to do with "openGL"
13:52:22 <DukeDave> Gah, you're lucky I don't get trading standards in ;)
13:52:48 <DukeDave> Then again I suppose I should be 'NotActuallyADukeDave'
13:53:15 <rubyruy> this is not really haskell specific, but why exactly is referential transparency so important to functional programming? is it simply to achieve performance through memoization, or is there more to it?
13:53:45 <oerjan> DukeDave: you mean you are not the head of the secret brotherhood of Daves?
13:54:39 <DRMacIver> rubyruy: It's more about guarantees the code can make. Immutable data tends to have fewer bugs and can easily enforce stronger invariants.
13:55:06 <lament> do invariants matter if the language doesn't let you describe them?
13:55:21 <rubyruy> so it's more of a philosophical choice? could somebody (for whatever reason) create an FP language that does not care about referential transparency?
13:55:28 <DRMacIver> rubyruy: Memoization is actually relatively uncommon in Haskell.
13:55:33 <lament> -- This function always returns an even number. Trust me I checked.
13:55:38 <rubyruy> (and if so why is it that such thing doens't seem to exist ?)
13:56:04 <DRMacIver> rubyruy: Although many other optimisations which wouldn't work in its absence do get performed.
13:56:18 <DRMacIver> rubyruy: Plenty of such do exist. ML, Scheme, etc.
13:56:21 <desp> "As a rule you should use foldr on lists that might be infinite or where the fold is building up a data structure, and foldl' if the list is known to be finite and comes down to a single value. foldl (without the tick) should rarely be used at all."
13:56:29 <rubyruy> oh really? my bad then
13:56:31 <desp> straight out of the Haskell wikibook
13:56:35 <desp> and yet,
13:56:37 <lament> rubyruy: any lisp
13:56:38 <desp> @src maximum
13:56:38 <lambdabot> maximum [] = undefined
13:56:39 <lambdabot> maximum xs = foldl1 max xs
13:56:44 <geezusfreeek> rubyruy: even haskell can be used in a non-referentially-transparent way
13:56:50 <lament> rubyruy: even perhaps Ruby :D
13:57:08 <SamB> desp: so the comittee didn't follow the wikibook!
13:57:15 <SamB> desp: your point being?
13:57:23 <rubyruy> hm - for some reason I thought that all FP languages are always ref-transparent... i wonder where i picked up the idea :p
13:57:34 <xerox> > let triangular = 0 : 1 : zipWith (\n2 n1 -> 2*n1 - n2 + 1) triangular (tail triangular) in triangular
13:57:35 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
13:57:45 <desp> SamB: meh
13:57:48 <rubyruy> so in that case, is there any particular reason Ruby can't be thought of as a an FP language?
13:57:51 <DRMacIver> rubyruy: Some people (wrongly, in my opinion) include referential transparency as part of the definition of "functional programming language"
13:57:53 <rubyruy> or for that matter JavaScript
13:57:55 <lament> rubyruy: there's a term "functional language", indiscriminately applied to lots of random stuff including Lisp, and there's "purely functional"
13:57:56 <koala_man> what could be the problem if my app works fine in ghci, but fails "(.text+0x36): undefined reference to `regexzmposixzm0zi71_TextziRegexziPosixziWrap_zez7eUz7eU_closure'" when trying to compile with ghc? both version 6.6.1
13:57:59 <geezusfreeek> unsafePerformIO allows you to do anything you want in a function whose type would otherwise indicate that it is pure
13:58:14 <desp> > let tris = snd (mapAccumL (\a x -> (x + a, x + a)) 0 [1..]) in tris
13:58:16 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
13:58:17 <rubyruy> or any language that supports functions as types?
13:58:22 <lament> rubyruy: haskell is purely functional, that is referentially transparent
13:58:32 <pejo> lament, calling Lisp a "functional language" is hardly a stretch imho.
13:58:38 <lament> rubyruy: lisp is functional, that is you use functions a lot :)
13:58:52 <SamB> pejo: have you actually used Common Lisp?
13:59:02 <DRMacIver> rubyruy: I'd probably only call a language functional if that was the dominant paradigm. Certainly both javascript and Ruby have good support for functional programming.
13:59:04 <desp> xerox: :)
13:59:15 <geezusfreeek> my own definition of a functional language is one that runs programs through reduction instead of iteration
13:59:27 <lament> ruby's support for higher-order functions is rather ugly :(
13:59:31 <xerox> desp: ^_^
13:59:35 <Cale> When I used common lisp, I felt like I had to fight with it to do things in a functional way.
13:59:41 <DRMacIver> rubyruy: It's just a matter of definition splicing though. The ideas are more important than the names. :)
13:59:42 <Cale> Scheme is better.
13:59:51 <rubyruy> yeah i actually think JS is nicer for FP-style stuff (albeit a little verbose)
13:59:56 <SamB> Cale: hence my question to pejo
14:00:24 <pejo> SamB, not a great deal, no.
14:00:55 <lament> in general modern languages tend to support multiple paradigms without much trouble, so describing things as "functional" or "imperative" is not very useful. "Purely functional", on the other hand, is a pretty clear term (not a matter of opinion)
14:00:58 * shachaf learned (a small subset of) Scheme from The Little Schemer, which is very functional. 
14:01:15 <lament> s/modern//
14:01:19 <shachaf> (I also read at least portions of Reasoned and Seasoned.)
14:01:28 <DRMacIver> Scheme is definitely a functional language.
14:01:30 <sorear> koala_man: you need to pass --make to ghc
14:01:40 <rubyruy> hmm - so in that case, does the   "purely functional" label require a language to be referentally transparent ?
14:01:56 <shachaf> rubyruy: It's used in different ways.
14:02:06 <SamB> rubyruy: yeah
14:02:19 <shachaf> @unlambda ```sii``sii
14:02:19 <lambdabot>  fd:24: hClose: resource vanished (Broken pipe)
14:02:23 <koala_man> sorear: excellent, thanks
14:02:26 <rubyruy> so why is that - what's so special about ref-transparency ?
14:02:28 <msouth> backing up to an earlier question--is it not the case that referential transparency allows for optimization at the compiler level?
14:02:36 <geezusfreeek> i could argue that the term "referentially transparent" shouldn't apply to a language overall in the first place
14:02:40 <pjd> rubyruy: algebraic reasoning
14:02:44 <Cale> rubyruy: It lets you use equational reasoning
14:02:50 <DRMacIver> msouth: It's certainly the case that referential transparency allows a lot of optimisations.
14:03:06 <DRMacIver> msouth: It's just that memoisation (and, in lazy languages, CSE) is not one of them. :)
14:03:08 <shachaf> Does lambdabot have an unlambda interpreter, or is that getting corrected into something else?
14:03:16 <shachaf> @unlambda .a
14:03:16 <lambdabot>  fd:22: hClose: resource vanished (Broken pipe)
14:03:21 <Cale> To determine the meaning of a program, you just do substitution over and over until you can't anymore (or else it doesn't terminate)
14:03:22 <msouth> DRMacIver: thanks, that's the disctinction i wanted to understand
14:03:34 <pejo> rubyruy, there's a great article by Amr Sabry, "what is a purely functional language?".
14:03:45 <rubyruy> so why is this algebraic reasoning useful then?
14:03:50 <pjd> rubyruy: have you read "why functional programming matters"?
14:03:51 <Cale> But also, you can show that two definitions are equivalent.
14:04:09 <SamB> rubyruy: at least you know where you stand, as SPJ said
14:04:10 <rubyruy> pjd, no but it was on my reading list :p
14:04:14 <Cale> It makes proving properties about your programs easier, and even if you never do that, it makes thinking about them easier.
14:04:22 <pjd> i think it should answer that question :)
14:04:33 <oerjan> rubyruy: a pure function can be non-referentially transparent if it has parts that don't terminate
14:04:53 <Cale> oerjan: hm?
14:05:04 <lament> Cale: or so people say :)
14:05:31 <geezusfreeek> oerjan: so the halting problem means that we can't prove in general that any function is referentially transparent?
14:05:45 <oerjan> geezusfreeek: heh, i guess so.
14:05:46 <Cale> Well, it's obvious, or at least it should be to anyone who's had to debug a program in a language with side effects
14:06:24 <sjanssen> oerjan: why does _|_ (which is the value of non-terminating values) break referential transparency?
14:06:25 <Cale> Having to recreate complex state in order to test a program is hard to do.
14:06:35 <rubyruy> Cale: those advantages are hard to imagine for someone who isn't used to FP, since i never had to debug a non-FP program ;)
14:06:51 <shachaf> rubyruy: You've never debugged your Ruby?
14:06:54 <oerjan> sjanssen: in a language with strict evaluation.
14:07:02 <rubyruy> er sorry i meant never had to debug a FP program
14:07:08 <SamB> heh
14:07:23 <DRMacIver> Debug a FP program? What madness is this? You just compile and it works. Obviously. ;)
14:07:25 <Cale> rubyruy: Well, it should still be obvious how the state of things makes that difficult.
14:07:32 <sjanssen> oerjan: oh, I think I get it "const x y = x" is a problem in that setting, yeah?
14:07:33 <msouth> rubyruy: I just went to MJD's "Higher Order Perl" talk, where he defines a bunch of things using perl that are very FP-like.  At one point he asserted that multiple calls to thing X with arg Y didn't change Y.  And I started tracing through the code to figure out if that was really true.  Then the light went on in my head.
14:07:38 <oerjan> right
14:07:43 <msouth> If it was in haskell, I wouldn't even have to ask.
14:08:15 <lament> what was that evil thing called, call-by-reference
14:08:34 <lament> in C++
14:08:38 <Cale> rubyruy: You end up having to resort to debuggers which stop your program at some random point so you can see what's happening, rather than just being able to deal with each component in isolation.
14:08:52 <rubyruy> ah i see
14:09:17 <msouth> to me a lot of the "big deal" is that all the noise in my head about whether someone might do something awful with this structure or whatever just goes away.
14:09:22 <msouth> not that I've been in it long.
14:09:23 <lament> foo(bar); // you have no idea whether bar remains the same, even if it's something like an integer :(
14:09:37 <rubyruy> although - i mean even haskell has to interact with the (not referentially transparent) outside world eventually - and at that point, do i not need a debugger anyway?
14:09:41 * sm wishes he could stop his haskell program at some random point so he could see what's happening
14:09:53 <shachaf> sm: Doesn't GHC 6.7 let you do that?
14:09:56 <SamB> lament: or any of the other values in your program!
14:10:00 <geezusfreeek> lament, like ( void foo(&param) { param = newSomething; } )?
14:10:03 <sm> I hear so.. I'm really looking forward to it
14:10:04 <SamB> (almost)
14:10:05 <glguy> lament: or even if foo remains the same ;)
14:10:05 <lament> geezusfreeek: yeah, that thing
14:10:11 <Cale> rubyruy: Well, possibly, but usually you keep the IO simple, and do all the real work using pure functions.
14:10:11 <lament> geezusfreeek: that just scares me
14:10:14 <geezusfreeek> that would be pass-by-reference
14:10:23 <pjd> rubyruy: right, but Haskell can do that in a referentially transparent way
14:10:46 <lament> geezusfreeek: not that it happens, but that it's invisible to the user of the function that it happens..
14:10:50 <geezusfreeek> lament: it's the way that most OO languages work _by default_
14:11:12 <geezusfreeek> well, sort of, i guess
14:11:19 <lament> geezusfreeek: there's a difference
14:11:22 <SamB> rubyruy: someone seems to have made some kind of debugger using GHCi... no idea how to use it yet though
14:11:38 <lament> geezusfreeek: python and scheme do this, but in python and scheme, lots of things are immutable
14:11:39 <Cale> rubyruy: If you want to take a model-view-controller picture of things, your 'model' is typically a pure function, while the 'view' and 'controller' bits might be in IO.
14:11:51 <geezusfreeek> well, i mean, in ruby, for example, assignment is not a method, but if it was it would have the same effect
14:11:55 <lament> geezusfreeek: foo(1) will not change 1 in Python :)
14:12:22 <shachaf> lament: Nor will it in C++. :-)
14:12:25 <rubyruy> ... nor ruby
14:12:31 <Cale> (and even significant parts of those might be pure)
14:12:35 <shachaf> lament: foo(x) might, though.
14:12:37 * SamB steals exarkun's evil to make foo(1) actually change 1 to be 2
14:12:38 <rubyruy> any sane language would treat ints as immutable i should hope :p
14:12:38 <pjd> geezusfreeek: C++ call by reference is a whole other thing than the "call-by-object" that most OO languages do
14:12:43 <mauke> pfft, lame. you can make it change 1 in Perl :-)
14:12:45 <lament> shachaf: not when x is 1 :)
14:12:59 <geezusfreeek> pjd, yeah you're right, i was typing before i was thinking
14:13:07 <SamB> (of course, then many of the OTHER 1s will *also* be 2...)
14:13:14 <lament> rubyruy: right, but in C++ you can do int x=1; foo(x); // now x could be anything
14:13:14 <DRMacIver> ints aren't immutable in ruby are they? In that you can (if you're feeling malevolent) expand the int class.
14:13:14 <shachaf> lament: foo(x) can change x, but foo(1) can't change 1.
14:13:35 <mauke> sub foo { &Internals::SvREADONLY(\$_[0], 0); $_[0] = 2 }  foo(1)  # 2
14:13:36 <SamB> mauke: what happens if you change 1?
14:13:46 <rubyruy> lament: ... i never tried - but that's a pretty eveil idea :p
14:13:47 <mauke> nothing much
14:13:56 <reffie> DRMacIver i thought they were
14:14:02 <SamB> if I wrote 1 on the next line, would it be 2?
14:14:15 <mauke> no, that would probably use a different scalar
14:14:19 <lament> shachaf: foo(1) can't change 1 because 1 is immutable. In C++ effectively nothing is immutable. Hopefully this is some sort of an argument for why immutable things are nice :)
14:14:23 <SamB> mauke: wierd.
14:14:37 <DRMacIver> reffie: *shrug* I don't know ruby yet, so maybe I'm wrong. :) But it seems like ruby's open classes should let you add mutability to an otherwise immutable class.
14:14:38 <mauke> SamB: perl -wle 'sub foo { &Internals::SvREADONLY(\$_[0], 0); $_[0] += 1 }  print foo(0) for 1 .. 10'
14:15:10 <reffie> DRMacIver admittedly, i haven't done any ruby in ~3 years
14:15:27 <geezusfreeek> DRMacIver: i think the data of the immutable classes itself is stored as a C variable, not directly accessible from Ruby
14:15:28 <SamB> mauke: if I stole exarkun's "become:"-like-thing, I'd render at least all literal 1s 2s!
14:15:36 <rubyruy> i mean ruby's rule is everything is a reference except "value types"
14:15:48 <gh_> hi
14:15:49 <rubyruy> the mechanism is not terribly clear
14:15:52 <geezusfreeek> but other, mutable data might still be added to an "immutable" object
14:15:56 <gh_> is the StateT monad strict ?
14:16:06 <DRMacIver> geezusfreeek: Yeah, that's what I meant, not that you could say change 1 to 2.
14:16:17 <rubyruy> but unless you hack the Fixnum class x = 1; foo(x) x is definitely going to still be 1 at the end
14:16:30 <SamB> mauke: of course, that's written in C ;-)
14:16:39 <rubyruy> i guess the "Fix" part of "Fixnum" kind of implies immutability :p
14:16:51 <SamB> rubyruy: no, it implies fixed size
14:16:55 <gh_> i have a minmax-like program which uses the StateT monad, and it explores the whole search space, while it isn't needed
14:16:59 <SamB> contrast with bignum
14:17:03 <rubyruy> oh right
14:17:21 <elliottt> what's everyone's recommendation for web programming with haskell?
14:17:55 <sjanssen> elliottt: HAppS seems popular lately
14:18:07 <geezusfreeek> elliottt: there hasn't been a lot of web dev with haskell yet, but HAppS is the most well-known
14:18:11 <Heffalump> I just use a CGI library
14:18:16 <bos> there should be a new release of HAppS RSN
14:18:20 <oerjan> http://esoteric.voxelperfect.net/wiki/Forte
14:18:22 <lambdabot> Title: Forte - Esolang
14:18:45 <elliottt> i've done some work with HAppS, but i had a load of trouble getting the docs to make sense with the version i had
14:18:46 <lament> oerjan: ahhh, i was trying to remember the name of that, thanks
14:18:47 <thecrypto> I just started messing around with web application stuff in Haskell...after learning it last night from the Taste of Haskell video
14:19:05 <thecrypto> I'm currently looking at making something similar to the WSGI standard in Python
14:19:17 <Saizan> elliottt: you can build the docs from your sources using runghc Setup haddock
14:19:28 <elliottt> yeah, i did that :)
14:19:37 <elliottt> i was originally following the tutorial
14:19:48 <Saizan> which one?
14:19:56 <elliottt> linked off of happs.org
14:20:29 <elliottt> http://www.haskell.org/haskellwiki/HAppS_tutorial
14:20:30 <lambdabot> Title: HAppS tutorial - HaskellWiki
14:20:37 <Saizan> ah, ok
14:20:43 <pjd> thecrypto: that sounds really cool
14:21:01 <lament> "HAppS is a framework for developing Internet services quickly, deploying them easily, scaling them massively, and managing them effortlessly."
14:21:08 <lament> i'm sold!!! where do i buy this???
14:21:13 <elliottt> hehehe
14:21:17 <Saizan> :D
14:21:39 <desp> hehe
14:21:41 <thecrypto> http://pastebin.ca/642746 This is my first implementation bits of it, making a mini webserver as well, it's barely begun and all my types aren't yet defined, but I'm getting there
14:22:02 <elliottt> i really like the sound of happs, and the examples reflect what i'd like to be doing, but i couldn't get it to let me store state that involved strings
14:22:04 <thecrypto> Any comments on ways to improve the code or better ways to go about any bit of it would be GREATLY appreciated
14:22:12 <Saizan> considering that hpaste is 1000loc i think there's still some work to be done to reach that goals
14:22:18 <pejo> fg
14:22:27 <pejo> Wrong window, sorry.
14:23:01 <Saizan> elliottt: a bit strange, i've strings everywhere in my state
14:23:49 <elliottt> Saizan: yes, it seemed odd ot me too :)
14:24:25 <thecrypto> And for those wondering what the WSGI standard is, it's a simple function definition that Python defines as being "a web application" that most of the web frameworks now use. http://www.python.org/dev/peps/pep-0333/
14:24:26 <lambdabot> Title: PEP 333 -- Python Web Server Gateway Interface v1.0
14:24:30 <elliottt> Saizan: i'll have to try again, it's been a few months since i last attempted to do something with it
14:24:55 <Saizan> elliottt: try to come on #happs with a paste if you get stuck again :)
14:25:29 <elliottt> Saizan: thanks, i'll do that :)
14:25:47 <elliottt> Saizan: i'd really love to port my website over, given that i think it would be a fantastic learning experience
14:26:27 <pjd> WSGI ~ "composable web resources"
14:26:49 <pjd> imagine what you could do in Haskell instead
14:27:22 <bos> now, imagine a beowulf cluster of those!
14:27:43 <Saizan> elliottt: yeah, even if without a bit of experience on typeclasses it can hurt
14:28:30 <elliottt> Saizan: it really helped as a learning process :)
14:29:06 <thecrypto> pjd: That's exactly why I though it'd be a good match, since composition is a good part of haskell, you could build nested "applications" easily, and only the ones that you'd need would A) be evaluated and B) there wouldn't be any sideefeffects once you go down one more level since you'd just take in the environ and return status headers and response
14:29:41 <lament> why does everything sound so easy in theory :(
14:30:20 <DRMacIver> oerjan: I've just gotten around to reading Forte. That's brilliant. :)
14:30:25 <rubyruy> OH! i just realized, isn't referential transparency a requirement for lazy evaluation?
14:30:37 <DRMacIver> rubyruy: It's not a requirement, but it certainly helps.
14:30:58 <SamB> lament: how about solving the halting problem?
14:30:59 <DRMacIver> rubyruy: Side effects in the presence of lazy evaluation can produce fairly bizarre results.
14:31:04 <arcatan> ?src nub
14:31:04 <lambdabot> nub = nubBy (==)
14:31:07 <arcatan> ?src nubBy
14:31:07 <lambdabot> nubBy eq []             =  []
14:31:07 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:31:11 <pjd> rubyruy: no, but lazy evaluation without referential transparency is very hard to reason about
14:31:30 <pjd> imagine having side effects, and not being able to say for sure when they happen
14:31:49 <pjd> (or if!)
14:32:07 <shachaf> pjd: You'd use seq a lot, wouldn't you? :-)
14:32:11 <lament> SamB: i bet it's trivial with a specially designed framework :)
14:32:31 <rubyruy> right right
14:32:33 <lament> SamB: and it might be tricky in haskell, but try it in a more appropriate language, like Coq :)
14:33:04 <rubyruy> you'd have no (easy) way of knowing what state an argument to a function is in when it's being evaluated
14:33:04 <pastorn> i'm thinking of abandoning haskell
14:33:08 <SamB> lament: good one, wise guy!
14:33:14 <pastorn> picking up lolcode instead
14:33:24 <SamB> you want me to solve the halting problem for a non-turing-complete language, don't you?
14:33:25 <pastorn> go for broke!!
14:33:30 <lament> SamB: :D
14:33:58 <pjd> rubyruy: the problem is more more like saying "print 1; print 2", but getting "21"
14:33:59 <SamB> that isn't "the halting problem"
14:34:07 <SamB> that's some simpler halting problem
14:34:58 <pjd> hmm, here's analogy;  you know how tricky multithreaded code is?
14:35:09 <pjd> imagine every expression ran in a thread of its own
14:36:06 <oerjan> pjd: that's lenient evaluation, isn't it?
14:36:20 <lament> there's >>= a >>= cure >>= for >>= that :)
14:36:29 <thecrypto> So any further suggestions on my current haskell code, I'll be working on it again later tonight trying to make the API that someone actually implements is just a pure function
14:36:38 <pjd> oerjan: i was only very loosely speaking :)
14:37:40 <SamB> oerjan: that sounds like HUNGRY evaluation to me
14:37:47 <oerjan> anyway, once you have referential transparency, running each expression in a thread of its own _is_ an option, which i think some languages have tried
14:37:59 <_Nucleo> @pl \x -> length x == 1
14:38:00 <lambdabot> (1 ==) . length
14:38:00 <SamB> (because it eats all your RAM)
14:38:04 <oerjan> SamB: what's the difference?
14:38:18 * DRMacIver imagines an evaluation strategy stomping around shouting "GIVE ME FOOD!"...
14:38:27 <oerjan> oh, i thought that was a technical term :D
14:38:29 <SamB> DRMacIver: s/FOOD/RAM/
14:38:40 <DRMacIver> Mine is funnier. :)
14:38:44 <lament> oerjan: isn't there always only one expression? :)
14:39:07 <pastorn> http://lolcode.com/examples/count-1
14:39:08 <lambdabot> Title: examples:count-1 · LOLCODE
14:39:09 <SamB> lament: there are subexpressions
14:47:38 <ivant> does any one know how to travel to Freiburg (assuming that I'd need to take a flight to someplace close)?
14:48:42 <mauke> potentially relevant: http://freiburg.de/servlet/PB/menu/1147222_l2/index.html
14:48:45 <lambdabot> Title: Stadt Freiburg im Breisgau: Transport
14:49:29 <pejo> ivant, http://proglang.informatik.uni-freiburg.de/ICFP2007/travel-information.shtml
14:49:31 <lambdabot> Title: ICFP 2007: Travel Information, http://tinyurl.com/2xxjkt
14:49:42 <ivant> thanks!
14:49:48 <mauke> http://freiburg.de/servlet/PB/show/1146644/flughaefen_350x458.gif
15:05:39 <fasta> How can policies (C++ jargon) be made to work in Haskell?
15:06:11 <fasta> Oh, and by that, I mean "Right now", not some X time in the future.
15:06:13 <SamB> say. someone ought to write a terminal emulator in Haskell
15:06:30 <jfredett> go for it, SamB
15:06:32 <Excedrin> what is a policy in C++
15:06:34 <jfredett> i'll use it
15:06:37 <Binkley> SamB: as in the kind you use to dial up a terminal server?
15:06:55 * xerox sings Happy Birthday to himself (-:
15:07:04 <dcoutts> xerox: Happy Birthday!
15:07:05 <SamB> Binkley: as in a replacement for xterm
15:07:06 <RyanT5000> SamB: is there a browser in Haskell?
15:07:13 * xerox hugs dcoutts 
15:07:13 <RyanT5000> really that question was to anyone
15:07:13 <Binkley> oh, that kind of terminal emulator
15:07:19 <Binkley> Yeah, that would be fun
15:07:24 <xerox> dcoutts: it was really a fun birthday last year's one :)
15:07:29 <dcoutts> :-)
15:07:46 <SamB> I was thinking more of the fact that it would probably be stable ;-)
15:07:46 <dcoutts> xerox: btw, coming to HW or the hackathon? it's not that far away from you
15:07:56 <Binkley> can't it be both? :-)
15:08:01 <RyanT5000> dcoutts: where is it?
15:08:12 <dcoutts> RyanT5000: Freiburg
15:08:13 <xerox> dcoutts: I'm coming to both! And even AH!
15:08:23 <dcoutts> xerox: oh, excellent!
15:08:38 <xerox> How long is the Freiburg business in days?
15:08:45 <dcoutts> xerox: many
15:08:51 <SamB_XP_> ... I say just before xterm crashes
15:09:00 <xerox> Mumble, maybe I will not make for everything, but I will try.
15:09:02 <SamB_XP_> (though I think it got OOM killed)
15:09:04 <dcoutts> xerox: from 30th to 8th or something, check the wiki
15:09:12 <xerox> I saw you're presenting something, IIRC.
15:09:16 <RyanT5000> oooh, here's a good question: what university should i go to for a Ph.D. in programming languages, if I could have my choice? (if it matters, i'll be applying in a year and a half)
15:09:18 <SamB_XP_> (or at least had a failed allocation)
15:09:25 <SamB_XP_> er.
15:09:29 <SamB_XP_> I meant x-chat
15:09:33 <SamB_XP_> x-chat crashed
15:09:37 <dcoutts> xerox: yeah :-). Problem is that HW is before ICFP and the hackathon is after, so a long time with a big gap.
15:09:39 <Binkley> RyanT5000: depends if you're interested in functional programming in particular, or some other area of PL
15:09:44 <Binkley> it also depends what country you want to be in
15:10:07 <RyanT5000> Binkley: functional programming; particularly dependent types.  also, software engineering and HCI as applied to programming languages.
15:10:23 <xerox> dcoutts: mumble mumble.... we need something like an idea.
15:10:23 <RyanT5000> pretend i don't care what country
15:10:33 <ivant> is it possible to change the topic of Ph.D. research from vibrational stabilization to something Haskell-related?
15:10:36 <ivant> :-)
15:10:45 <dcoutts> xerox: 287 km apparently, Torino <-> Freiburg
15:10:50 <dozer> ivant: there's always algorithm implementation choice :)
15:11:02 <Binkley> RyanT5000: well, we have a lot of people interested in functional programming and type theory here at Portland State :-)
15:11:03 <xerox> dcoutts: doesn't seem terrible in train, does it?
15:11:10 <Binkley> There's also CMU, Penn, Yale...
15:11:14 <jfredett> ivant, just relate it to category theory, and then say, "and theres this wonderful bit of programming goodness called haskell based on CT and...
15:11:16 <dcoutts> xerox: right, I'm going by train
15:11:17 <ivant> dozer, doing right this. It's boring and I don't like where it goes
15:11:30 <xerox> dcoutts: and how long is yours?
15:11:41 <dozer> ivant: how long left? what country?
15:11:42 <Binkley> in the UK, Nottingham seems to be a good place for those interests, and lots of other places
15:11:53 <dcoutts> xerox: dunno yet
15:12:06 <RyanT5000> Binkley: yeah, i know it doesn't matter *too* much where you are
15:12:19 <RyanT5000> does glasgow actually do anything interesting, or is GHC just the name?
15:12:20 * wli chose the job partly due to the proximity to OGI (which at the time appeared to be the place to go).
15:12:25 <xerox> dcoutts: I might have some friends hosting me there, but I'm not sure.
15:12:26 <ivant> dozer, little more than a year, but I'd be ready to do work on Ph.D for some more years if I have a chance
15:12:27 <Binkley> RyanT5000: well, it matters more whether you've identified people you'd like to work with than anything else
15:12:34 <Binkley> All the FP people left Glasgow long ago
15:12:44 <Binkley> it was the place to be at one time, hence the name GHC
15:12:45 <ivant> dozer, I'm in Russia, but I'm very willing to move somewhere
15:12:46 <xerox> dcoutts: well, there's time to plan stuff anyway
15:12:52 <dcoutts> xerox: yes
15:12:54 <RyanT5000> Binkley: yeah; the problem is, i'm in boston right now, so MIT would be convenient... but they seem to have like 3 people in prog lang
15:12:56 <Binkley> wli: all the OGI people are at PSU now :-)
15:13:02 <Binkley> RyanT5000: yeah, don't go to MIT
15:13:12 <Binkley> not if you're interested in FP, anyway
15:13:26 <Binkley> Northeastern would be better, or even BU
15:13:26 <fasta> ivant: doesn't every Russian want to move somewhere?
15:13:31 <dozer> we do some formal methods stuff in Newcastle CS dept, but they focuss more on proofs than on languages/code
15:13:58 <liyang> Notts, Oxfnord, York are the places to go these days.
15:13:59 <RyanT5000> Binkley: yeah; the project i have in mind is pretty much writing a functional language, so any place without good FP stuff is pretty much out of the question
15:14:09 <Binkley> Oxfnord? :-)
15:14:16 <liyang> *nod*
15:14:19 <liyang> Oxfnord.
15:14:24 <RyanT5000> "I have seen the oxfnords!"
15:14:24 <Binkley> Okay.
15:14:32 <ivant> fasta, no, most of them don't realize how they change the reality they are in (or just don't have a chance)
15:14:42 <jfredett> Hail Eris?
15:14:50 <RyanT5000> lol
15:14:57 <liyang> \o/
15:15:07 * wli has since realized that his talents and abilities are far too limited to do anything in the way of research.
15:15:08 <ivant> fasta, s/change/can change/
15:15:24 <dozer> manchester may have some openings for FP modelling of web service workflows - probably with dependent types thrown in
15:15:28 <Binkley> wli, research is more a matter of being willing to bang your head against a wall repeatedly than anything else :-)
15:15:35 <fasta> ivant: well, it would be kind of hard to change anything, AFAIK.
15:15:36 <Binkley> you need talent, but that's the easy part
15:15:58 <wli> Binkley: That is one of the limitations that ruins it all.
15:15:59 <fasta> ivant: you need millions of people
15:16:06 <fasta> ivant: all coordinates at the same time
15:16:12 <Philippa> liyang: you not going to make it to Cambridge this year?
15:16:21 <liyang> Philippa: ?
15:16:26 <Philippa> we're doing AngloHaskell again
15:16:27 <fasta> ivant: there should be so many people, that the army doesn't have enough bullets to shoot them all.
15:16:28 <RyanT5000> dozer: that sounds somewhat interesting; the specific problem that's been the one i've centered my thoughts on is serialization/deserialization of arbitrary closures
15:16:32 <liyang> I've been away in Ningbo, China for the last semester.
15:16:36 <ivant> fasta, agreed
15:16:41 <fasta> ivant: that's not an easy task
15:16:53 <dozer> Binkley: yeah - talent is easy, still being talented when nothing has worked for 3 years and your supervisor thinks you are a waste of space and you've got to write up next week while doing an entire PhD worth of work is a different matter :)
15:16:59 <fasta> ivant: add to that that every small demonstration is squashed.
15:17:01 <Philippa> ah. Are you still away, or just got back?
15:17:19 <Binkley> dozer: sounds painful
15:17:29 <Philippa> I'm not angling for a lift btw, I'm staying the night before as well this time :-)
15:17:35 <sieni> RyanT5000: it's certainly possible with Haskell, since there's no mutable state.
15:17:37 <ivant> fasta, so I'm planning to change the things around me by moving somewhere where I like 'em
15:17:46 <dozer> Binkley: it's a year or too behind me now - I'm not scared, honest
15:17:48 * dozer twitches
15:17:50 <fasta> ivant: good luck
15:17:59 <sieni> RyanT5000: you just pack the functions and the values an that's it
15:18:19 <liyang> Philippa: not sure I'll be going. Not unless other FoPpers are and need a lift.
15:18:28 <RyanT5000> sieni: yeah, although doing it efficiently is difficult, and so is doing it safely
15:18:40 <fasta> What's a smart strategy to do instance selection deep inside some code.
15:18:42 <fasta> ?
15:18:56 <fasta> I have a few ideas, but I would like to hear it from you first.
15:19:01 <RyanT5000> sieni: i don't want to send my entire standard library to someone over the network, nor do i want them to send me a virus :P
15:19:18 <fasta> That's essentially the problem that policy classes solve in C++ and SmallTalk.
15:19:22 <Philippa> liyang: fair enough
15:19:33 <dozer> RyanT5000: yeah, sounds familiar - we have similar 'concerns' with our grid platform
15:20:03 <RyanT5000> dozer: yeah; i think it would be vastly useful in many different applications
15:20:46 <sieni> RyanT5000: yes, sending the code is difficult, I agree. You probably would have to negotiate stuff like standard or other libraries using some digital signatures and all that
15:21:04 <ivant> dozer, nothing has worked for almost 2 years now in my case: I was trying to solve the problem which has only O(e^(a*e^(b*c))) solution
15:21:05 <RyanT5000> sieni: yeah; and if you want to make it version-robust it becomes even trickier
15:21:27 <RyanT5000> ivant: what problem is that?
15:21:50 <sieni> RyanT5000: and anyway if you want to make things robust, you really can't trust anything that you receive from the opposite end
15:21:52 <liyang> Philippa: I'm still in Belfast right now! Wanna get started with work again &c &c and not sure I'll have enough energy. :-/
15:22:10 <RyanT5000> sieni: right :) that doesn't mean you can't run their code, though
15:22:16 <RyanT5000> (provided you recompile it)
15:22:18 <RyanT5000> (and type check it)
15:22:21 <sieni> RyanT5000: but I think that otherwise it's doable with versioning and stuff
15:22:23 <Philippa> liyang: ouch, yeah. Know the energy thing
15:22:25 <RyanT5000> yeah
15:22:35 <RyanT5000> sieni: why hasn't anyone done it?
15:22:40 <ivant> RyanT5000, having N inequalities (each of which is p(x) > 0 where p(x) is multivariate polynomial of M vars) find out which do not put additional constraints in this system of inequalities
15:23:24 <wli> Binkley: I used to think I might make a good codemonkey for researchy things but have since realized I can't really do that, either.
15:23:31 <sieni> RyanT5000: I think it's rather difficult and requires lots of stuff that needs to work across versions
15:23:34 <RyanT5000> ivant: what's it for? anything involving rigid body dynamics?
15:24:13 <Binkley> wli: I think those codemonkey jobs tend to lead to bitterness
15:24:19 <wli> ivant: Presumably this is purely symbolic/analytic.
15:24:20 <Binkley> or perhaps it's just that I knew bitter people who had them :-)
15:24:59 <ivant> RyanT5000, it is for construction of Lyapunov functions, which prove the possibility of stabilization/destabilization of the zero solution of system of differential equations
15:25:03 <wli> Binkley: Doesn't matter. I'm not good enough at it for such things.
15:25:24 <sieni> RyanT5000: I'd say that the thing you want is something that nobody is willing to do unless they want to provve that it's possible
15:25:44 <RyanT5000> ivant: interesting; i understood half of that, and half-understood the other half :P
15:25:45 <ivant> wli, yep, it was for quite a long time while I tried to come up with a good math expression simplification
15:25:50 <Binkley> wli: well, if you're interested in learning Haskell for its own sake, I'd say that puts you above quite a lot of people
15:26:03 <RyanT5000> sieni: why wouldn't they want it? it seems super-convenient; you'd never have to write another half-assed query language
15:27:04 <wli> Binkley: I've figured out that above average isn't the same thing as really far up there.
15:27:29 <ivant> RyanT5000, basically, I need to find the minimal set of inequalities which define a set of parameters of the dynamical system (defined by diff. equations) such that it is possible to find a stabilizing control functions which are periodical with zero mean
15:27:35 <Binkley> wli: true... you don't have to be really far up there with what you're doing in order to enjoy it, though.
15:28:44 <sieni> RyanT5000: if you read me carefully, i didn't claim that people don't want i.
15:28:59 <wli> Binkley: It's a sort of anti- Peter Principle affair. Instead of moving up to the level where I'm incompetent, I'd rather stick to what I can do.
15:29:00 <RyanT5000> sieni: ah, ok
15:29:11 <sieni> it
15:29:14 <Binkley> wli: fair enough
15:29:26 <aii> hello
15:29:36 <hpaste>  mux pasted "problem with layout rules and where" at http://hpaste.org/2046
15:29:56 <matthew-_> will ghc optimise out tiny lists?
15:30:06 <ivant> @ft Int -> (a -> a) -> [a] -> [a]
15:30:07 <Binkley> matthew-_: what do you mean by "optimise out"?
15:30:09 <lambdabot>  There was an error in the type: (line 1, column 7):
15:30:09 <lambdabot>  unexpected "e"
15:30:09 <lambdabot>  expecting "->" or end of input
15:30:13 <mux> any way to write this in a similar way, but with correct scoping?
15:30:34 <matthew-_> like, if it's know at compile time that the list is only 2 elems long, as is immediately decomposed, will it ever create it?
15:30:50 <matthew-_> I should be using tuples, but I want map and so forth, so lists are nicer
15:31:11 <matthew-_> eg [a,b] <- mapM wibble [x,y]
15:31:15 <Binkley> matthew_: you can't assume it always will be
15:31:37 <matthew-_> ok, but does GHC actually try to do that sort of optimisation?
15:31:39 <Binkley> yes
15:31:59 <Binkley> AFAIK, that should happen as part of deforestation in general; I don't know that there are any special cases for constant lists
15:32:17 <mauke> mux: you could let-bind distfactor inside the lambda function
15:32:26 <Binkley> But the only way to know whether it'll happen in your code is to look at the Core
15:32:32 <matthew-_> spr.
15:32:36 <matthew-_> wrong row!
15:32:37 <matthew-_> sure
15:32:59 <Binkley> mux: basically, you want to indent the part beginning with "where" more than the line beginning with "round" is indented
15:33:19 <Binkley> because you want to associate the where-clause with the body of your anonymous lambda, not with the RHS of flightTime
15:33:30 <mauke> Binkley: you can do that?!
15:33:59 <Philippa> Binkley: I think constant lists tend not to get deforested because it does bad things with string literals that slow the compiler down
15:34:24 <Binkley> Philippa: sounds plausible
15:34:39 <Binkley> mauke: by "that" do you mean indenting, or looking at the Core? :-)
15:35:06 <mauke> Binkley: I mean attaching where clauses to expressions
15:35:11 <mux> Binkley: that doesn't work
15:35:32 <Binkley> mauke: well, I thought so, but maybe I'm on crack
15:35:35 <ddarius> Argh, so much haskell-cafe traffic.
15:35:38 <mux> mauke: I know it works with let; so, no way to do this with where?
15:36:21 <mauke> mux: not unless you write another function and pass it dg/ds/dp as arguments
15:36:30 <Gwern-aw1y> hslogger provides 'System.Log.Logger', right?
15:36:54 <mux> mauke: ok, thanks
15:40:53 <xerox> Anybody knows off-hand the syntax of the new Extension pragma?
15:42:24 * Gwern-aw1y is confused. So hslogger provides System.Log.Logger, and I can go into ghci and do :m + System.Log.Logger and it will load. but if I try to compile a program importing that, I get 'ghc-6.6.1: unknown package: hslogger-1.0.1', even though ghc-pkg -l shows hslogger-1.0.2 to be installed, which being a newer version everything should be fine!
15:42:56 <bos> {-# LANGUAGE UndecidableInstances #-}
15:43:09 <xerox> Gwern-aw1y: do you pass -package hslogger to ghc?  Or --make?
15:43:13 <xerox> bos: thanks.
15:43:39 <Gwern-aw1y> xerox: --make, but the compile errors regardless of whether I pass it
15:43:39 <bos> xerox: with names taken from here: http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html
15:43:41 <lambdabot> http://tinyurl.com/2c2g5y
15:43:56 <Gwern-aw1y> (--make just makes the message more comprehensible)
15:44:14 <xerox> bos, I found the names myself, but I can't find where {-# LANGUAGE ... #-} is discussed.
15:44:52 <bos> http://hackage.haskell.org/trac/haskell-prime/wiki/NewPragmas
15:44:54 <lambdabot> Title: NewPragmas - Haskell Prime - Trac
15:45:48 <ivant> @pl \(p,s) -> let (p1, p2) = f p in ((p1,s),(p2,s))
15:45:48 <lambdabot> (line 1, column 15):
15:45:48 <lambdabot> unexpected "("
15:45:48 <lambdabot> expecting natural, identifier or "in"
15:45:58 <xerox> thank you again :)
15:46:10 <ivant> hmm
15:46:39 <ddarius> ivant: Apparently, @pl doesn't support pattern matching in lets
15:47:08 <ddarius> @pl \(p,s) -> (\(p1,p2) -> ((p1,s),(p2,s))) (f p)
15:47:09 <lambdabot> uncurry (flip ((`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . flip (,)) (flip (,))) . f)
15:47:19 <ivant> oh
15:47:22 <magnus__> another beutiful expression
15:47:27 <ivant> I'd better stick with pointy version
15:48:04 <ivant> who said that lisp has too many parenthesis? :-)
15:48:16 <ddarius> :t join (***) (flip (,) ?s)
15:48:18 <lambdabot> forall b b1. (?s::b1) => (b, b) -> ((b, b1), (b, b1))
15:48:31 <ddarius> Stupid type system.
15:49:25 <rubyruy> I'm having a bit of trouble (well, not really "trouble"... just an feeling of unfamiliarity) wrapping my head around the type system. I've never really worked with things that weren't object oriented. So for starters, haskell types aren't really objects - just data structures ... i.e. a container for one or several other data structures. They are unlike objects in the sense that they don't "have" methods.
15:49:29 <rubyruy> so far so good?
15:49:56 <magnus__> yes
15:50:22 <aii> more importantly, they don't have state
15:50:30 <rubyruy> but then i see that functions can be defined for a specific type - which means those methods are, in effect, owned by a type
15:50:36 <lament> objects in object-oriented languages don't necessarily have methods either; not having a state is more important
15:50:44 <Binkley> rubyruy: just forget the words "method" and "own" and you'll do ok :-)
15:51:18 <fasta> lament: uhm, what can you do with an object that doesn't have a method?
15:51:25 <fasta> lament: I know one thing.
15:51:49 <lament> fasta: which object "owns" the method in a multiple-dispatch language?
15:52:15 <fasta> lament: that's not "object oriented"
15:52:30 <fasta> lament: for "object oriented" see Alan Kay
15:52:43 <mauke> if it responds to messages, it's an object
15:52:44 <RyanT5000> fasta: but, it *is* _totally awesome_
15:52:47 <mauke> it doesn't have to own anything
15:52:47 <RyanT5000> fasta: :P
15:52:59 <lament> CLOS has multiple dispatch
15:53:06 <lament> do people often argue CLOS isn't object oriented?
15:53:33 <dibblego> rubyruy, follow Binkley's advice
15:53:35 * fasta looks at channel. Yep, this is #haskell
15:53:51 <rubyruy> what actually transpires when i say ((==) 1 2) ? how does it know which (==) to use?
15:54:00 <rubyruy> haskell has no notion of 'recievers' right?
15:54:03 <Binkley> rubyruy: ah, that's a more interesting question
15:54:03 <mauke> rubyruy: it looks at the type of 1 and 2
15:54:19 <Gwern-aw1y> (bleh. now filepath is broken. at least I figured out that it was an stale version of HSH that was causing the hslogger problem)
15:54:21 <rubyruy> does it just pattern match between all available implementations of == ?
15:54:24 <DRMacIver> Multiple dispatch is indeed totally awesome. :)
15:54:52 <rubyruy> and what happens if i say (==) a b = something whacky
15:54:54 <monochrom> What is an object? What is a monad?
15:54:57 <Binkley> rubyruy: no, because there's a notion of "default" for numeric literals
15:55:05 <dozer> rubyruy: it looks at the types of 1 and 2, then it looks up the class that provides the == method, then it looks up a table of implementing pairs of types and picks the one that matches
15:55:24 <Binkley> in general, 1 and 2 have the type "Num a" for some unknown a, but when there are no other constraints to tell you otherwise, the default numeric type is Integer
15:55:31 <mauke> rubyruy: then your (==) will override (shadow) the existing (==)
15:55:36 <fasta> What can CLOS do (besides the MOP) what MPTCs, can't?
15:55:56 <monochrom> CLOS is also very dynamic.
15:56:04 <mauke> rubyruy: you can't just define new variants of existing functions. Haskell doesn't do freewheeling overloading
15:56:16 <Philippa> fasta: it's mutable as all hell
15:56:26 <dozer> rubyruy: haskell classes are more like meta-classes - they are specifications of signatures that must be provided
15:56:29 <RyanT5000> rubyruy: one important thing is that the version of (==) to use is determined statically (i.e.: at compile time)
15:56:30 <fasta> Philippa: right, but that was a bad thing, right?
15:56:35 <Philippa> not necessarily
15:57:07 <dibblego> what does MOP stand for?
15:57:16 * fasta notes meta-classes already have estabilished meaning in the Smalltalk world
15:57:23 <LoganCapaldo> metaobject protocol
15:57:33 <fasta> established*
15:57:59 * dozer intended the modelling version of the modifier meta-, rather than the operational semantics one
15:58:28 <rubyruy> well i do get that when you say object a is of type Eq you mean "a is an object that implements the Eq 'protocol', which in turns means, any object that implements (==) and (/=)) - this is very very similar to ruby's duck typing philosphy, except it's a lot less explicit
15:58:43 <LoganCapaldo> Eq isn't a type
15:58:46 <LoganCapaldo> it's a type class
15:58:52 <rubyruy> for instance - we have the Comparable module which works with objects that implement the 3 comparison operators
15:58:56 <rubyruy> sorry - type class
15:59:00 <LoganCapaldo> a doesn't have type Eq
15:59:15 <dibblego> rubyruy, Scala's structural typing is more like Ruby's duck typing (but with compile-time failure)
15:59:20 <LoganCapaldo> a is a type that is a member of the set of types that are instances of Eq
15:59:30 <RyanT5000> Eq a is a statement saying "objects of type a can be compared to each other for equality"
15:59:37 <rubyruy> right
15:59:38 <mauke> rubyruy: Haskell's version of that is called Ord
15:59:50 <rubyruy> right right
15:59:58 <dozer> rubyruy: it's a similar idea, but rather than just providing a == method, you bind it into an explicit instance declaration, which makes things more explicit
16:00:46 <pastorn> ?type (&&&)
16:00:53 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:00:57 <rubyruy> what feels odd to me is where one defines the  (==) function but i can't quite put my finger on why
16:01:09 <Gwern-aw1y> I've never quite understood. why does something like 'module Pager (main, pager) where' cause an compilation error?
16:01:22 <mauke> Gwern-aw1y: what's the error?
16:01:23 <rubyruy> you declare it in the same place that says "this type implements the Eq protocol (aka typeclass)"
16:01:34 <Gwern-aw1y> mauke: 'Main.main not exported; not linking.'
16:01:40 <rubyruy> ... err no i guess that makes sense .. hm
16:01:43 <thecrypto> http://hpaste.org/2047 New version of my WSGIish haskell webserver thing. Have support for paths and soon I'll be making the first middleware to handle dispatching of URLs
16:01:44 <dozer> rubyruy: so if I just write a function "(==) a::X b::X = ..." this defines a different (==) to saying "instance Eq X where (==) a b = ..."
16:01:52 <mauke> Gwern-aw1y: that doesn't look like an error
16:02:10 <sjanssen> Gwern-aw1y: you might want to use the -main-is flag
16:02:14 <LoganCapaldo> Gwern-aw1y, main as in the main that is the entry point to your program has to be in the module Main
16:02:17 <mauke> Gwern-aw1y: you just won't get a program out of it because you have no Main.main function
16:02:31 <Gwern-aw1y> sjanssen: what does -main-is do?
16:02:49 <LoganCapaldo> Gwern-aw1y, makes my statement false ;)
16:02:58 <rubyruy> why the separation between declaring a type and declaring what protocols that type supports then?
16:03:05 <Saizan> Gwern-aw1y: changes the module where the main function is searched
16:03:10 <rubyruy>  (forgive the use of the term 'implements protocol' instead of 'type class' - it's just more familiar to me for now - but they are mostly  interchangeable ideas, yes?)
16:03:15 <sjanssen> Gwern-aw1y: as others have mentioned, GHC expects main to be in Main, -main-is Foo looks for main in Foo instead
16:03:18 * Gwern-aw1y nods. maybe the problem is I'm trying to make the same file serve as a library and an executable
16:03:24 <RyanT5000> rubyruy: because if you create a new protocol, you can make already-existing types support it
16:03:28 <LoganCapaldo> rubyruy, so I can add new type classes after the fact, and provide instances for them for existing types
16:03:38 <SamB_XP_> rubyruy: why the open classes?
16:03:49 <RyanT5000> rubyruy: for example, Data.Binary.Binary is a typeclass that has instances for Integer, String, and a whole bunch of other types that existed before it
16:03:53 <aii> why is there System.Environment.getEnv, but no System.Environment.setEnv?
16:03:53 <dozer> rubyruy: all without injecting code into the module that the type is defined in, or didling it's method table or whatever
16:04:12 <LoganCapaldo> @hoogle putenv
16:04:12 <lambdabot> No matches found
16:04:32 <aii> also no unsetenv
16:05:05 <SamB_XP_> dozer: we types don't HAVE method tables in any implementation I've heard of
16:05:11 <SamB_XP_> s/we //
16:05:22 <mauke> SamB_XP is a type!
16:05:27 <SamB_XP_> heh
16:05:36 <LoganCapaldo> I knew it!
16:05:39 <sjanssen> but mauke is a mere type variable
16:05:46 <SamB_XP_> no I'm just a person who accidentally leaves things in sentences sometimes
16:05:50 <dozer> SamB_XP_ no :) that's one of the reasons we don't end up diddling them :D
16:05:54 <mauke> I'm not a number; I'm a free variable!
16:06:02 <LoganCapaldo> grooooooooooooan
16:06:08 <SamB_XP_> just be glad I'm not a surgeon -- I'd leave all manner of sharp objects in people
16:06:24 <Saizan> even shapr?
16:06:30 <rubyruy> ah wait i think i get it
16:06:32 <dozer> mauke: go forth and range
16:08:03 <rubyruy> so in haskell functions like == whose only purpose is to implement the Eq protocol/typeclass are kept in their own neat declaration block specific to, say String-being-Comparable, instead of just being aggregated inside the String class
16:08:22 <sjanssen> rubyruy: there is no "String class"
16:08:25 <shachaf> rubyruy: Strinjg isn't a class.
16:08:38 <shachaf> rubyruy: Nor is String.
16:08:41 <rubyruy> type - shessh - you know what i mean :p
16:08:52 <mauke> types don't aggregate methods
16:08:55 <LoganCapaldo> although if we are lucky IsString will be a class
16:08:58 <LoganCapaldo> bwahahaha
16:09:06 <LoganCapaldo> Hooray for ByteString literals
16:09:06 <sjanssen> rubyruy: these are important distinctions!
16:09:13 <rubyruy> yes that is true
16:09:20 <ddarius> LoganCapaldo: And great evil will come of it.
16:09:34 * LoganCapaldo cackles maniacally
16:09:43 <arjanb> rubyruy: another important difference is that lookup happens only at compile time
16:09:55 <hpaste>  Gwern annotated "(no title)" with "pager now compiles and runsp" at http://hpaste.org/2042#a3
16:10:27 <rubyruy> alright so types don't aggregate functions, but realistically one would USUALLY want to keep functions that are used with a given type together somehow, no?
16:10:34 <LoganCapaldo> arjanb, lookup of what though? Some lookups happen at runtime no?
16:10:40 <dozer> give rubyruy a break - he's translating between two programming languages and also two naming conventions
16:10:43 <Saizan> arjanb: that depends on the implementation, GHC uses dictionaries when it doesn't specialize
16:10:57 <LoganCapaldo> arjanb, what Saizan said was really what I was getting at
16:11:01 <ddarius> rubyruy: Yes and no.
16:11:04 <rubyruy> hm actually -  i guess what i'm asking is, how would one organize related functions together in haskell
16:11:09 <ddarius> rubyruy: Modules are used for that.
16:11:11 <LoganCapaldo> in a mondule
16:11:15 <rubyruy> let me think of a silly example
16:11:15 <LoganCapaldo> s/n//
16:11:40 <Gwern-aw1y> whew! that pager program was a lot more difficult to write than I thought it'd be! glad it's done
16:11:45 <ddarius> A mondule is what you stick in a ring.
16:12:02 <pastorn> Gwern-aw1y: what does it do?
16:12:13 <LoganCapaldo> did I use a real word by accident?
16:12:22 <ddarius> LoganCapaldo: No.
16:12:23 <Philippa> rubyruy: modules're actually better for organisation than classes - ever create a "utility" class that was just a bundle of methods for working with objects of two other classes?
16:13:00 <rubyruy> Philippa: no because I'd use a ruby module for that ;)
16:13:08 <rubyruy> although i have a feeling they are vastly different things
16:13:13 <ddarius> Philippa: That's the benefit of not being tied to "Everything is in a class" dogma.
16:13:17 <rubyruy> (i mean ruby modules vs haskell ones)
16:13:31 <ddarius> rubyruy: I'd think that at a basic level they are precisely the same.
16:13:36 <RyanT5000> rubyruy: haskell's module system is basically terrible; it's about as good as C's
16:13:41 <rubyruy> oh hell - let's just go with String - so how would one put together functions that do things to strings
16:13:42 <dozer> rubyruy: a haskell module is just a place to dump symbols - functions, classes, instances, data types, constants
16:13:53 <ddarius> RyanT5000: C doesn't have one.
16:13:57 <dozer> rubyruy: like a perl module without all that @ISA crap
16:14:01 <shachaf> rubyruy: A String is just a list of characters.
16:14:05 <sjanssen> RyanT5000: that's not fair at all, Haskell's is far superior
16:14:13 <LoganCapaldo> Depending on how you use a ruby module decides how like a haskell module it is
16:14:13 <shachaf> rubyruy: So you might want to ask about lists in general.
16:14:20 <rubyruy> right so first i make a new type String that is just [ Char ]
16:14:24 <sjanssen> RyanT5000: C++'s module system is much more comparable
16:14:27 <mauke> dozer: heh. people still use @ISA? :-)
16:14:33 <shachaf> @ISA
16:14:33 <lambdabot> Unknown command, try @list
16:14:55 <dozer> mauke: I'll have you know, I was one of the primary developers of BioPerl and we used @ISA a hell of a lot
16:14:57 <rubyruy> instance Eq String where  and implement ==, /= for strings
16:15:06 <rubyruy> er - i would do that ^^^ next
16:15:16 <shachaf> rubyruy: Actually, it's instance (Eq a) => Eq [a] where ...
16:15:16 <rubyruy> where would i put very string -specific functions?
16:15:23 <rubyruy> right woops
16:15:29 <shachaf> rubyruy: That is, if a has ==, so does [a].
16:15:36 <sjanssen> rubyruy: probably in the module that you've defined String in
16:15:40 <LoganCapaldo> @docs Data.String
16:15:41 <lambdabot> Data.String not available
16:15:43 <mauke> Data.List or Text.*
16:15:44 <sjanssen> rubyruy: Data.String, perhaps
16:15:54 <Saizan> rubyruy: there's little benefit on defining a different type String implemented with [Char], you mostly just use functions that work on [a], you can find them in Data.List :)
16:15:58 <LoganCapaldo> Did I make up an imaginary module?
16:16:06 <ddarius> rubyruy: Wherever you like.  For your own types, usually you put them in modules that do define the type.
16:16:06 <mauke> LoganCapaldo: yes
16:16:08 <LoganCapaldo> oh doh Data.String is just Data.List
16:16:12 <rubyruy> there are some string-specific functions, like capitalize
16:16:19 <rubyruy> which only make sense in Strings
16:16:24 <shachaf> rubyruy: map toUpper?
16:16:31 <shachaf> rubyruy: There is Data.Char.
16:16:38 <rubyruy> ok fine - pluralize()
16:16:49 <rubyruy> where do i put that function ?
16:16:55 <ddarius> rubyruy: You can put it wherever you like.
16:17:00 <mauke> somewhere in Text.* probably
16:17:02 <rubyruy> where should i put that function ?
16:17:10 <Saizan> rubyruy: Text.English ?:)
16:17:17 <dozer> rubyruy: probably in somewhere like Text.English
16:17:29 <ddarius> That pluralize not pluralise, Text.American!
16:17:33 <rubyruy> so Text.English is just a collection of definitions ?
16:17:45 <rubyruy> i assume there's something like ruby's include ModuleName  ?
16:17:46 <ddarius> rubyruy: Yes.  That's all a module is.
16:17:50 <ddarius> import
16:17:53 <dozer> ddarius: damn that hokey US spelling
16:18:08 <Saizan> rubyruy: the point is that you group functions by functionality rather than by type
16:18:09 <rubyruy> i see i see i see
16:18:18 <rubyruy> iiinteresting
16:18:20 <SamB_XP_> rubyruy: pluralize?
16:18:31 <SamB_XP_> rubyruy: I guarentee that that function won't work
16:18:51 <shachaf> rubyruy: import is more like require.
16:18:53 <DRMacIver> It clearly needs to have type Noun -> Noun. :)
16:18:54 <dozer> hehe, it's amazing how much semantic import you need to pluralise words correctly
16:18:59 <LoganCapaldo> SamB_XP_, it's not a function
16:19:08 <shachaf> rubyruy: include is a bit like instance in Haskell. :-)
16:19:08 <ddarius> SamB_XP_: No one is saying one needs to write working functions.
16:19:14 <LoganCapaldo> theres a big stateful mutable table of special cases ;)
16:19:32 <rubyruy> SamB_XP . dozer - Ruby on Railsers rely on that method every day :p
16:19:52 <rubyruy> it is, by design, not foolproof but it is easy to teach it about new and special forms
16:19:55 <rubyruy> anyway
16:20:12 <DRMacIver> (Among the things I considered to be serious misfeatures when I looked at rails)
16:20:22 <fasta> Shouldn't :info <Class> show all the available instances?
16:20:22 <rubyruy> so  these functions, once imported, are not tied to Strings in any way - it would be the same as if i had copy-pasted the code in all imported modules in the same file, right ?
16:20:23 <shachaf> DRMacIver: Absolutely.
16:20:35 <ddarius> rubyruy: More or less yes.
16:20:37 <shachaf> It doesn't help in the least except to make the code read a little more like "English".
16:20:38 <dozer> DRMacIver: defining Noun will be even harder and require even more semantic import :) He jumps 10 times. I did 10 jumps.
16:20:50 <fasta> I loaded a module and I am looking a an instance, but GHC doesn't report it.
16:20:59 <LoganCapaldo> Noun as a zipper into a sentence?
16:21:06 <LoganCapaldo> A type level zipper maybe?
16:21:06 <rubyruy> and namespace collisions are unlikely because of type signatures
16:21:07 <LoganCapaldo> lol
16:21:09 <rubyruy> right ?
16:21:20 <shachaf> rubyruy: What do you mean?
16:21:22 <LoganCapaldo> namespace collisions are handled by modules
16:21:26 <DRMacIver> dozer: True. :)
16:21:27 <ddarius> rubyruy: No. Modules are namespaces.
16:21:30 <dozer> rubyruy: yeah, other than they remember their fully qualified name (even if this is hidden from you by the import statement - like Java imports do for you)
16:21:36 <LoganCapaldo> @type Prelude.lookup
16:21:38 <shachaf> rubyruy: Haskell modules are not like Ruby modules.
16:21:39 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
16:21:43 <LoganCapaldo> @type Data.Map.lookup
16:21:45 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
16:21:57 <shachaf> rubyruy: Haskell import of modules is like Ruby require, approximately.
16:22:05 <sjanssen> rubyruy: have you tried any structured Haskell learning?
16:22:18 <rubyruy> i'm working through the gentle intro as i'm bothering you guys :p
16:22:28 <mauke> heh, "gentle"
16:22:31 <rubyruy> indeed
16:22:40 <monochrom> the gentle intro is ok. I learned from it.
16:22:55 <rubyruy> first time around i gave up and used the wikibook instead, which is far too gentle and provides insufficient depth :p
16:23:01 <chris2> it's either gentle, or an intro :-)
16:23:02 <dozer> No instance for (Reasoner OS.Ontology OS.Description OS.DataPropertyExpression OS.DataRange OS.Individual OS.Constant)
16:23:02 <DRMacIver> (I do agree incidentally that Haskell's module system is a little weak. First class modules would be nice.)
16:23:02 <shachaf> rubyruy: Forget all your Ruby vocabulary -- too many conflicts.
16:23:07 <sjanssen> rubyruy: the "gentle" intro is actually the least gentle.  You might try YAHT or the wikibook if it's too dense
16:23:13 <dozer> guess what I've got left to code before my program runs boys and girls
16:23:24 <sjanssen> rubyruy: ah, you know about those
16:23:52 <rubyruy> is qualifying funciton names always required?
16:24:11 <rubyruy> i.e. i'd alwasy have to specify Text.English.pluralize ?
16:24:13 <mauke> no
16:24:27 <mauke> import dumps imported functions into your namespace by default
16:24:29 <dnox> anyone here using hs-plugins in win?
16:24:35 <rubyruy> rightoh
16:24:37 <mauke> you can override that with "import qualified"
16:24:38 <shachaf> rubyruy: You can import Text.English, which is like require 'text/english' in Ruby.
16:24:56 <shachaf> rubyruy: You can import qualified Text.English as TE if you want (conflicts, for example).
16:25:41 <rubyruy> shachaf: it really is  more like include Text::English with auto-require running if it also dumps all of Text::English's methods into your namespace
16:25:54 <shachaf> rubyruy: Why?
16:26:01 <rubyruy> because that is exactly what include does
16:26:06 <shachaf> rubyruy: If I require 'pp', I can call pp immediately.
16:26:21 <shachaf> rubyruy: Right?
16:26:22 <rubyruy> that's because pp is defined inside Kernel
16:26:31 <shachaf> rubyruy: Yes, but remember this is Haskell.
16:26:34 <mauke> 'import Foo' is like use Foo qw(:all); in Perl
16:26:38 <LoganCapaldo> this comparision is not going to work
16:26:40 <rubyruy> and then calls PrettyPrinter.pretty_print or whathaveyou
16:26:44 <mauke> 'import qualified Foo' is like use Foo (); in Perl
16:26:51 <LoganCapaldo> import and require really don't work the same
16:26:54 <rubyruy> whereas you can just do include PrettyPrinter and then pretty_print becomes available to you
16:26:57 <rubyruy> (more or less)
16:27:02 <shachaf> rubyruy: Just remember that Ruby analogies can help, but they can also make alot of trouble.
16:27:02 <dozer> mauke: without the possibility of it trampling all over your local namespace :)
16:27:04 <LoganCapaldo> require is pretty much #include
16:27:19 <shachaf> rubyruy: You're not "in a class".
16:27:40 <fasta> How can I show all the instances defined in a module? I am almost positive GHC is wrong.
16:27:40 <DRMacIver> Except possibly "Introduction to Functional Programming" :)
16:27:43 <shachaf> rubyruy: I'd compare include to type class instance.
16:27:49 <rubyruy> yes i know - i was just explaining why ruby's include is closer to haskell's import from what you peeps are telling me
16:27:56 <fasta> Currently, I am using :info <name of class>
16:28:05 <fasta> sjanssen: ?
16:28:08 <shachaf> rubyruy: For example, you can define instance Eq and instance Ord, and then all the Ord and Eq functions will work on your type.
16:28:12 <xerox> Anybody knows what this does mean? "mismatched interface file ways: expected , found p"
16:28:21 <RyanT5000> functions wrapped with foreign import ccall "wrapper" are *not* GC roots, right?
16:28:22 <shachaf> rubyruy: Just like "comparable" (is that the name?) in Ruby.
16:28:31 <rubyruy> exactly like that yes
16:28:51 <shachaf> rubyruy: That's different from importing functions.
16:29:21 <shachaf> rubyruy: Try not to think in OO. :-)
16:30:15 <rubyruy> anyway - my original concern was that when all you do is import modules in your local namespace, in ruby this is dangerous since the chance of method collision is quite high. But since haskell is smart enough to know to call (crapy example:) List.reverse when you say simply reverse [1,2,3] and String.reverse when you say "abc" this isn't as much of a problem
16:30:17 <sjanssen> fasta: I don't know any situation that :info would lie
16:30:33 <xerox> Found the answer in the channel logs, nice :)
16:30:36 <sjanssen> rubyruy: actually, Haskell isn't that smart
16:30:37 <shachaf> rubyruy: No, Haskell can't do that.
16:30:41 <rubyruy> it ain't ?
16:30:45 <shachaf> rubyruy: String is a list of Chars.
16:30:45 <Binkley> rubyruy: actually, list reverse and string reverse are the same thing
16:31:01 <rubyruy> (pretend String and List actually needed separate implementations for reverse, whcih they don't)
16:31:05 <Binkley> and if you consider an example like lookup, which is in Data.List and Data.Map...
16:31:06 <sjanssen> rubyruy: *but* Haskell is smart enough to konw that "reverse" is ambiguous if you've imported two different reverses
16:31:14 <shachaf> rubyruy: You can't define two different functions of type Int -> Int, Char -> Char with the same name.
16:31:21 <Binkley> you can't import both of them, unless you use the "import qualified" syntax
16:31:28 <shachaf> Binkley: You can.
16:31:32 <LoganCapaldo> rubyruy, Haskel is only smart enough to do that if reverse :: (Reversable a) => a -> a
16:31:41 <sjanssen> rubyruy: what does Ruby do if you import two reverses?
16:31:51 <shachaf> Reversible, no? :-)
16:31:56 <LoganCapaldo> sorry
16:31:58 <LoganCapaldo> I can't spell
16:31:59 <Binkley> shachaf: well, you can import both, you just can't use both, unless you use import qualified
16:32:02 <Binkley> or is there a way I don't know about?
16:32:05 <shachaf> Binkley: You can.
16:32:15 <Binkley> how?
16:32:16 <rubyruy> sjanssen: silently over-writes it :(
16:32:18 <shachaf> import Data.Map; import Prelude; Data.Map.map; Prelude.map
16:32:21 <Saizan> Binkley: you just need to qualify them at use
16:32:35 <rubyruy> (the mechanism is useful in many other cases - but otherwise dangerous)
16:32:40 <sjanssen> rubyruy: okay, Haskell is not stupid like that :)
16:32:52 <Binkley> saizan: oh, right
16:32:57 <rubyruy> but it's not much smarter either if it won't let me do it at all
16:32:58 <Binkley> Yeah, no one should listen to me today
16:33:04 <sjanssen> rubyruy: this is one advantage to the more static approach Haskell takes
16:33:20 <shachaf> rubyruy: By not allowing two different functions with the same type, Haskell can infer types.
16:33:32 <rubyruy> because in ruby i can have a module check if reverse is already avilable when it's included, and then rename the old reverse function and call it inside my new one - giving me a lot of interesting options
16:33:33 <shachaf> rubyruy: So if you say reverse, it automatically knows that you're talking about a list.
16:33:47 <shachaf> rubyruy: Otherwise you would have to type types out a lot more, probably.
16:33:52 <Saizan> rubyruy: you usually hide one of them at the import declaration, like import String hiding (reverse); import List
16:34:06 <sjanssen> rubyruy: it's pretty straightforward.  The compiler will say "There are two reverses, which one do you mean", and then you can type Data.List.reverse or Data.String.reverse to resolve it
16:34:30 <rubyruy> so I can't have a function f :: Foo -> Whatever and another function f :: Bar -> Whatever at the same time ?
16:34:31 <shachaf> rubyruy: An interesting thing in Haskell is that imports have no "order".
16:34:41 <shachaf> rubyruy: For example, two modules can import each other.
16:34:48 <LoganCapaldo> rubyruy, you can as long as they are in different modules
16:34:58 <DRMacIver> Or different scopes within the same module.
16:35:01 <sjanssen> rubyruy: you can have them, but it's a pain if you import them to the same scope
16:35:16 <rubyruy> sjanssen: but will it let me? it will just need more type declarations ?
16:35:17 <LoganCapaldo> or if f :: (Class a) => a -> Whatever and Foo and Bar are instances of Class
16:35:18 <shachaf> rubyruy: This is what you would use a type class for, sometimes.
16:35:27 <mauke> rubyruy: no, you can't have them
16:35:31 <rubyruy> i see
16:35:34 <sjanssen> rubyruy: what you're referring to is called ad-hoc polymorphism -- Haskell does not support this
16:35:41 <mauke> they need different names
16:35:47 <rubyruy> reasonable enough
16:35:56 <sjanssen> rubyruy: if you want to have functions that work on several types, put them in a type class
16:36:04 <rubyruy> yep - i understand
16:36:11 <DRMacIver> I find that something of a shame. Intersection types aren't hard to implement or anything. :)
16:36:26 <Gwern-aw1y> pastorn: running on a list of file names, it runs on each one: 'less', if the suffix indicates it is compressed or it is longer than the terminal window, or cat if it is not compressed and shorter than the terminal window
16:36:38 <DRMacIver> (And I'm sure the type signatures and error messages would be totally non-confusing)
16:37:09 <Saizan> DRMacIver: it makes type inference harder
16:37:37 <LoganCapaldo> rubyruy, another option is data Baz = F Foo | B Bar; f :: Baz -> Whatever
16:37:43 <ddarius> Requiring you to put something in a type class is not very limiting.
16:37:46 <DRMacIver> Saizan: I'm being somewhat sarcastic. :)
16:37:57 <RyanT5000> wow, making a wrapped finalizer that deallocates itself is pretty tough
16:37:59 <shachaf> rubyruy: Yes, you can make a function accept Either Char Integer, for example.
16:38:25 <ihope> RyanT5000: comparable to trying to discard a value in a reversible language?
16:38:26 <sjanssen> ddarius: until you want to go *really* ad-hoc -- with different arities, radically different arguments, etc.
16:38:27 <fasta> sjanssen: I can reproduce it
16:38:44 <sjanssen> fasta: is it small enough to paste?
16:38:48 <fasta> sjanssen: yes
16:39:06 <LoganCapaldo> > printf "%s is %d x Awesome" "printf" 3 :: String
16:39:07 <RyanT5000> ihope: isn't that supposed to be impossible?
16:39:07 <lambdabot>  "printf is 3 x Awesome"
16:39:16 <ihope> RyanT5000: yes, it is impossible.
16:40:04 <RyanT5000> ihope: by "pretty tough" i meant "annoyingly difficult when you're used to nice GC" :P
16:40:20 <RyanT5000> ihope: are there any reversible languages worth using for anything?
16:40:30 <RyanT5000> well, not for *anything*
16:40:35 <RyanT5000> but for something interesting?
16:40:37 <fasta> sjanssen: no, I can't reproduce it. I was in another module.
16:41:30 <ihope> RyanT5000: well, it's only feasible to discard data at a certain rate.
16:41:33 <DRMacIver> What's a reversible language?
16:41:52 <ihope> DRMacIver: a language that can be run backwards from any state, I guess.
16:41:55 <DRMacIver> Ah
16:42:02 <pastorn> Gwern-aw1y: care to share?
16:42:48 <ihope> RyanT5000: that is, discarding data creates heat, I think.
16:43:09 <shachaf> rubyruy: How far into the gentle introduction are you?
16:43:15 <ihope> That takes energy, and heat can mess things up.
16:43:45 <xerox> Anybody knows off-hand how to do something in make that depends on the existence or non-existence of one file in the current directory?
16:43:45 <rubyruy> shachaf: classes chapter
16:43:58 <RyanT5000> ihope: yeah, i was reading something about reversible processors at some point
16:44:21 * shachaf hasn't actually read thee gentle introduction.
16:44:29 <fasta> I find GHC _very_ buggy. Are all language implementation so bad?
16:44:29 <shachaf> I never really looked at it.
16:44:36 <fasta> implementations*
16:44:42 <glguy> fasta: yeah, they all are
16:44:56 <RyanT5000> fasta: it's a whole lot less buggy than MSVC or, in my experience, GCC
16:45:04 <sjanssen> fasta: what sort of bugs do you hit?
16:45:06 <fasta> glguy: maybe I should get into compilers ;)
16:45:18 <fasta> sjanssen: I have hit at least 6 type inference bugs.
16:45:22 <sjanssen> fasta: your instance issue was actually a phantom, right?
16:45:26 <aii> msvc crashes all the time with c++ template code
16:45:32 <fasta> sjanssen: AFAIK, no.
16:45:34 <RyanT5000> aii: yep
16:45:34 <Binkley> fasta: I hope you're filing reports for these bugs, otherwise it'll stay that way :-)
16:45:46 <fasta> Binkley: yes, most of it is fixed already.
16:46:00 <sjanssen> fasta: "no, I can't reproduce it. I was in another module."?
16:46:02 <fasta> Binkley: if _you_ would do the same, it would go twice as fast.
16:46:23 <fasta> sjanssen: I can probably reproduce it in 10 minutes or so
16:46:28 <fasta> sjanssen: I am working on that now
16:46:36 * ddarius (almost?) never has type inference bugs and certainly doesn't cuddle the type system.
16:46:57 <Binkley> fasta: I don't know, the bugs I report tend to get marked as WONTFIX :-)
16:46:57 <fasta> ddarius: They were verified type inference bugs (by SPJ)
16:47:10 <xerox> I know make isn't quite a nice tool, but anybody care to share some make-fu? Execution dependent on existence of files, any clue?
16:47:17 <ddarius> fasta: Yes, but you're using bleeding edge stuff, yes?
16:47:46 <fasta> ddarius: are fundeps + MPTCs bleeding edge?
16:47:54 <fasta> ddarius: they have existed for years
16:47:56 <sjanssen> xerox: isn't conditional execution on file existence the core of make?
16:48:01 <ddarius> fasta: No.
16:48:05 <ddarius> What are you doing?
16:48:12 <xerox> sjanssen: I think I see what you mean.
16:48:38 <fasta> ddarius: check Trac if you are interested in GHC failures.
16:48:52 <ddarius> fasta: I'm interested in what you are doing.
16:49:14 <fasta> ddarius: well, if you stop talking to me, you can see in 10 minutes a module system failure
16:49:27 <whoppix> hey all. im new to haskell and i would like to know your personal IDE preference, or, in case there exist a list of Haskell IDEs somewhere, i'd like to know the link.
16:49:31 <xerox> sjanssen: yeah, it works. Thanks for the answer.
16:49:34 <Gwern-aw1y> pastorn: it's on hpaste
16:49:36 <shachaf> whoppix: Vim!
16:49:41 <ddarius> fasta: Again, that's not what I was asking.  I was asking exactly what I said.
16:49:43 <Gwern-aw1y> whoppix: I use the emacs mode gentoo provides
16:49:48 <pastorn> Gwern-aw1y: linky plz
16:49:52 <shachaf> @wiki IDEs
16:49:52 <lambdabot> http://www.haskell.org/haskellwiki/IDEs
16:49:56 <whoppix> thanks a lot.
16:50:16 <fasta> ddarius: how do you mean "what I am doing"?
16:50:21 <sjanssen> whoppix: most use vim, emacs, or their favorite editor.  There's also Haskell integration available for Eclipse and Visual Studio
16:50:22 <shachaf> @iki Applications and libraries/Program development#Editor_support
16:50:22 <lambdabot> http://www.haskell.org/haskellwiki/Applications_and_libraries/Program_development#Editor_support
16:50:29 <shachaf> whoppix: I still recommend vim. :-)
16:50:30 <fasta> ddarius: I am not using type level computations or anything like that
16:50:52 <ddarius> fasta: What code are you writing and what's it supposed to do, and yes, what are you doing with the type system.
16:50:56 <whoppix> sjanssen: ic. im about to install the eclipse extension (im using eclipse most the time.)
16:51:20 <fasta> ddarius: As, I said, check Trac for my reports, if you care.
16:51:24 <hpaste>  Gwern annotated "(no title)" with "Modularized version of pager.hs" at http://hpaste.org/2042#a5
16:51:42 <ddarius> fasta: You have your entire projects in the Trac reports?
16:52:05 <fasta> ddarius: no, but I have no interest in talking about my projects now.
16:52:13 <ddarius> fasta: Then just say that.
16:52:21 <whoppix> i'm just wondering if eclipse can automatically convert my tabs to the right whitespace count. Well, going to find out.
16:52:54 <shachaf> whoppix: Vim can do that.
16:53:22 <whoppix> shachaf: has vim SVN integration? code folding? and can it create code outlines?
16:53:40 <shachaf> whoppix: Vim has everything you need, I'm sure. :-)
16:53:55 <mauke> code folding yes
16:54:00 <mauke> I don't know about the rest
16:54:00 <shachaf> whoppix: Do you use SVN with Haskell anyway?
16:54:11 <whoppix> shachaf: not yet. im just about to explore haskell.
16:54:19 <whoppix> but ill have a closer look at vim.
16:54:29 <shachaf> whoppix: The standard one is darcs, for Haskell, I think.
16:54:39 <whoppix> standard IDE?
16:55:37 <shachaf> whoppix: "David's Advanced Revision Control System"
16:55:37 <whoppix> oh, neat, theres even a tutorial how to configure vim for haskell.
16:55:50 <shachaf> whoppix: Sure, but vim takes some learning separately.
16:55:54 <whoppix> shachaf: oh. never heard about it.
16:56:09 <shachaf> whoppix: If you haven't used vi, it's probably different from anything you have used.
16:56:46 <whoppix> i haven't, back then when i was starting with linux and unix it seemed to complicated to me, and i used pico/nano or X11 editors, and i never had a look at it again
16:57:41 <shachaf> whoppix: Try "vimtutor" for a basic tutorial.
16:57:50 <shachaf> whoppix: Otherwise you just need practice.
16:57:57 <RyanT5000> is there a way to guarantee that a call will be a tail call? i'm trying to make a function that deallocates itself when run (it's wrapped as a FunPtr)
16:57:58 * shachaf definitely needs a lot of practice.
16:58:39 <SamB> RyanT5000: that sounds kinda crazy
16:59:08 <dibblego> RyanT5000, you mean annotating a function with "the compiler will treat this as a tail call - can you please verify this statement?"
16:59:22 <SamB> RyanT5000: actually, wait.
16:59:24 <whoppix> thanks again, im gonna dig through it (though, i got kinda used to eclipse - but its sometimes annoying too (buggy and slow as hell))
16:59:24 <RyanT5000> SamB: but necessary; i need to make closures into finalizers
16:59:27 <RyanT5000> dibblego: yeah
16:59:34 <dozer> ah, I knew it had to happen
16:59:50 <dozer> I've just written the safe update of (a,b) into a map of sets
16:59:51 <SamB> RyanT5000: it's not that complicated, the GC will make sure the function doesn't go away while it's running
17:00:02 <dozer> the one function I seem to implement in every language I've ever used
17:00:08 <RyanT5000> SamB: not this time :P
17:00:34 <RyanT5000> SamB: the only reason the function is reachable is because it has a StablePtr to itself (StablePtrs are GC roots)
17:00:34 <fasta> Ok, this is more complicated than I thought...
17:00:37 <SamB> RyanT5000: are you getting a horrible crash right now?
17:00:51 <RyanT5000> SamB: no; i haven't written it yet; but i refuse to write code with race conditions
17:00:56 <SamB> RyanT5000: I imagine the other reason is because it is RUNNING?
17:01:15 <SamB> the stack, too, has roots!
17:01:26 <RyanT5000> SamB: it's running *as a finalizer*; it's effectively a C function
17:01:36 <SamB> RyanT5000: um.
17:01:44 <RyanT5000> SamB: i don't want to rely on the fact that the GC is probably not going to get run while finalizers are running
17:02:00 <SamB> okay so why is there a FunPtr to your finalizer then?
17:02:04 <RyanT5000> SamB: because that isn't in the spec anywhere, and it's easy to conceive of someone making a multithreaded GC that wouldn't obey that rule
17:02:17 <RyanT5000> SamB: ForeignPtrs take FunPtrs as their finalizers
17:02:37 <SamB> could you please explain in precise detail exactly who has called your function and what it has in scope?
17:04:36 <RyanT5000> the GC has called the function after the ForeignPtr has died; it has in scope (1) the Ptr from the ForeignPtr (2) a StablePtr to a MVar that contains a StablePtr to itself
17:05:28 <SamB> the second StablePtr points to *what*?
17:05:38 <RyanT5000> the haskell representation of itself
17:05:53 <SamB> ... um.
17:06:02 <SamB> well, don't you need the FunPtr too?
17:06:06 <RyanT5000> oh, i'm sorry, the MVar actually contains its own FunPtr
17:06:07 <RyanT5000> yeah
17:06:12 <SamB> ah.
17:06:41 <SamB> okay. I'm positive that you won't be pulling the carpet out from under yourself if you deallocate the FunPtr
17:07:00 <RyanT5000> why?
17:07:01 <SamB> you don't need it anymore, the finalizer has already been invoked
17:07:31 <SamB> the GC will not discard whatever it still might need
17:07:45 <RyanT5000> but it doesn't know that it's a Haskell function at all!
17:07:52 <SamB> of course it does
17:07:57 <SamB> how wouldn't it?
17:08:04 <RyanT5000> because it's being invoked via FunPtr
17:08:13 <RyanT5000> which means it might as well be a C function
17:08:26 <SamB> so you think the GC goes on vacation when you invoke a Haskell function through a FunPtr?
17:08:50 <RyanT5000> no, i think it has no idea what the GC-children of that function are, though
17:09:06 <SamB> it has all the roots it needs, okay?
17:09:31 <RyanT5000> what?
17:10:28 <SamB> I have no idea how it works, but I know that it just wouldn't work to ignore the stack frames of functions invoked through FunPtrs.
17:10:32 <rubyruy> anyone recomend a fairly simplistic piece of haskell source code i could look at just to get a feel for day to day programming ?
17:10:44 <rubyruy> nothing too fancy / academic - the more mundane the better :p
17:10:48 <rubyruy> a ticket system or something
17:11:08 <RyanT5000> SamB: why not? FunPtrs are supposed to be to C functions
17:11:18 <Philippa> rubyruy: if you want horribly mundane, try http://www.flippac.org/projects/SigGen.hs
17:11:20 <mauke> rubyruy: xmonad?
17:11:33 <RyanT5000> i'll take a look at the code of freeHaskellFunPtr or whatever it is
17:11:38 <EvilTerran> i'd suggest xmonad. that's meant to be easily modifiable.
17:11:44 <rubyruy> Philippa:  what it do ?
17:11:56 <Philippa> it reads in a simple config file, picks a (pseudo-)random .sig file from the current dir and chucks a completed .sig out on stdout
17:11:56 <shachaf> rubyruy: You might want to look at the videos in the /topic.
17:12:08 <SamB> RyanT5000: the, um, foreign import wrapper stubs do whatever needs to be done to let the GC know to trace that part of the stack
17:12:25 <shachaf> rubyruy: They are videos of a recent introduction to Haskell using xmonad.
17:12:34 <Philippa> the Config type + deriving Read and Show on it defines the config file format, btw
17:13:16 <SamB> RyanT5000: anyway, stop worrying about it so much
17:13:31 <rubyruy> here i was hoping non-example code is a little easier to read :p
17:13:38 <RyanT5000> SamB: why would i not worry about a potential segfault?
17:13:54 <SamB> worry about whether you have a FunPtr or a Ptr that you might try to use
17:14:14 <SamB> if you haven't, the GC has your back
17:14:20 <Philippa> rubyruy: start with main and then look at the other bits if you need to in order to understand?
17:14:23 <SamB> (well. you, or some random C library)
17:14:34 <Philippa> also, syntax highlighting helps a lot
17:15:16 <RyanT5000> SamB: actually there's a much less subtle bug i just remembered: i need to call freeHaskellFunPtr on the function itself
17:15:20 <rubyruy> yah i pasted it in textmate- but it's haskell support is not quite stellar
17:15:34 <RyanT5000> SamB: which is totally OK if it's a tail-call
17:16:06 <RyanT5000> which brings me back to my original question: is there a way to guarantee something is a tail call?
17:17:55 <SamB> RyanT5000: that's a bug?
17:17:57 <SamB> how is that a bug?
17:18:07 <SamB> it won't free the things it needs!
17:18:12 <SamB> just repeat after me:
17:18:23 <RyanT5000> SamB: it needs to free itself *immediately after it's done running*
17:18:24 <SamB> the GC is NOT an idiot (though it can't understand C code)
17:18:41 <RyanT5000> i'm fairly certain what i'm describing isn't impossible
17:18:59 <RyanT5000> it would be like having a function that adjusts its stack appropriate and then jumps directly into free()
17:19:06 <RyanT5000> *appropriately
17:19:19 <SamB> RyanT5000: well, it will free the stub immediately, and that will take away the associated GC root
17:19:35 <zarvok> Anyone know a lot about parsec's expression parsers?  I'm interested in how to use buildExpressionParser with a grammar that has expressions which aren't nicely prefix, postfix or infix constructions, like "if exp then exp else exp"
17:19:39 <RyanT5000> SamB: right, which is why i need to be *out* of that function before it actually gets freed
17:19:44 <RyanT5000> hence the tail call *requirement*
17:19:46 <SamB> but, I repeat, the carpet WILL NOT be pulled out from under you
17:19:59 <RyanT5000> alright
17:20:20 <SamB> (unless your carpet is made of Ptr and FunPtrs ;-P)
17:20:50 <RyanT5000> so basically you're saying that the GC knows you're in a haskell function even though it's called through a FunPtr?
17:20:57 <SamB> yes!
17:21:22 <RyanT5000> SamB: well that's pretty awesome; how does it know?
17:21:37 <SamB> RyanT5000: implementation detail
17:21:51 <SamB> i.e. I'm not quite sure
17:22:02 <RyanT5000> SamB: alright :P
17:22:15 <RyanT5000> i'll write a test that makes sure that's true
17:22:27 <RyanT5000> and add it to my unit tests
17:22:43 <RyanT5000> which i *suppose* is almost as good as there being a spec for it :P
17:22:48 <SamB> not really.
17:22:55 <RyanT5000> yeah, i know
17:23:06 <RyanT5000> but i can write a pretty good test using performGC
17:23:11 <RyanT5000> or whatever it's called
17:23:43 <SamB> remember, the Haskell 98 report never says anywhere that the GC won't reclaim non-garbage... but then again it never mentions garbage collection either, does it?
17:24:07 <rubyruy> what does the "$" mean in "return $ ((read cfgfile)::Config)" ?
17:24:12 <RyanT5000> SamB: well i think it's conclusively implied by the semantic description of the language :P
17:24:20 <ddarius> @src ($)
17:24:20 <lambdabot> f $ x = f x
17:24:46 <ddarius> Though in that case it's completely unnecessary unless some more context is missing.
17:24:58 <Philippa> yeah, I should've shed the outermost set of parens
17:25:05 <shachaf> rubyruy: It's used to eliminate parentheses.
17:25:09 <zarvok> rubyruy: pretend there is a left paren insead of the $ and a right paren as far right as you can put it
17:25:17 <shachaf> rubyruy: f $ g x = f (g x)
17:25:19 <ddarius> Philippa: No you shouldn't've.
17:25:30 <Philippa> you'll tell me to drop the $, right?
17:25:31 <ddarius> The innermost ones sure.
17:25:38 <ddarius> Philippa: That too.
17:25:49 <ddarius> Unless you're one of -those- crazies.
17:25:55 <SamB> RyanT5000: I'm fairly certain that the FFI Addendum makes all of this clear by what it does not say
17:26:01 <Philippa> ...you've known me how long? Of course I am
17:26:08 <thecrypto> As far right as you can go so what happens with f $ g $ h x?
17:26:17 <monochrom> Heh, the Haskell report never mentioned that computers were digital. :)
17:26:20 <RyanT5000> SamB: alright
17:26:20 <thecrypto> f (g (h x))?
17:26:21 <dozer> my code compiles, I can sleep soundly now
17:26:22 <shachaf> thecrypto: $ is infixr.
17:26:25 <dozer> o/
17:26:25 <dibblego> thecrypto, correct
17:26:28 <shachaf> thecrypto: So yes.
17:26:32 <rubyruy> shachaf:  i thought f . g is f(g()) ?
17:26:34 <shachaf> thecrypto: Some say it should be infixl, thoguh.
17:26:35 <rubyruy> what's the diff ?
17:26:37 <ddarius> monochrom: Who cares if they are?
17:26:39 <rubyruy> fixity ?
17:26:49 <thecrypto> Awesome, that'll clarify some code of mine that I'm working on
17:26:53 <shachaf> rubyruy: (f . g) x = f (g x)
17:26:56 <eivuokko> RyanT5000, SamB, freeHaskellFunPtr frees the marshalling code, which is never tracked by GC.  Calling freeHaskellFunPtr inside the callback for itself is not safe.
17:27:01 <shachaf> rubyruy: f $ x = f x
17:27:10 <shachaf> rubyruy: (.) composes functions, ($) is just id.
17:27:22 <shachaf> rubyruy: It's only syntactic.
17:27:27 <rubyruy> i see i see
17:27:30 <eivuokko> RyanT5000, SamB, at least in theory, iirc GHC had some wierd trick that made it work on most platforms anyway.
17:27:31 <rubyruy> eesh
17:27:47 <RyanT5000> eivuokko: alright; well i'm trying to make it safe; can i make a guaranteed tail call out of the function?
17:27:50 <shachaf> > ((+1) . (*2)) 5
17:27:52 <lambdabot>  11
17:27:57 <rubyruy> i take it haskell is liable to idioms ?
17:27:59 <shachaf> > (+1) $ (*2) 5
17:28:01 <lambdabot>  11
17:28:07 <SamB> eivuokko: what the heck?
17:28:15 <SamB> are you sure that's not supposed to work?
17:28:31 <eivuokko> SamB, I am not sure how it is supposed to work, just that it's been problem before.
17:28:45 <SamB> hmm.
17:28:52 <eivuokko> SamB, I recall ffi spec is vague, as you say, it's not mentioned.
17:28:53 <SamB> actually now I think I understand.
17:28:58 <SamB> RyanT5000: oops.
17:29:05 <RyanT5000> SamB: no problem :)
17:29:14 <SamB> RyanT5000: I forgot that the gets returned through
17:29:18 <SamB> or might
17:29:45 <RyanT5000> eivuokko: so, there's no guaranteed safe way to do it?
17:29:47 <fasta> Can I put multiple modules in one file?
17:29:50 <SamB> I'll have to remember this for JHC...
17:29:57 <eivuokko> RyanT5000, I don't know how exactly to make it safe.  I think people use some global registration and manual GCish operation.
17:30:14 <dmwit> rubyruy: There are certainly Haskell idioms, but I doubt their as unpleasant as the word "liable" suggests they might be. ;-)
17:30:18 <SamB> eivuokko: hmm.
17:30:19 <RyanT5000> eivuokko: i suppose i could make a thread that just consumes a queue of finalizers needing deletion - although that strikes me as somewhat retarded
17:30:23 <dmwit> s/their/they're/
17:30:28 <zarvok> fasta: iirc, it's officially allowed but ghc and hugs don't support it?
17:30:46 <fasta> Well, then I will just zip the report up
17:30:47 <eivuokko> RyanT5000, You need to be really careful the thread never calls freeHaskellFunPtr too early
17:30:50 <SamB> probably this would work better if ForeignPtr allowed you to pass Haskell functions as finalizers?
17:30:55 <fasta> I mangaged to reproduce it though.
17:30:58 <fasta> managed*
17:31:04 <RyanT5000> eivuokko: yeah, actually i guess that that's the same problem
17:31:07 <eivuokko> SamB, Yes, ffi spec if really annoying in that regard.
17:31:09 <fasta> This is going to be a tough one, I guess.
17:31:20 <RyanT5000> eivuokko: so, about the tail call idea; could that work?
17:31:22 <fasta> It depends on lots of stuff
17:32:11 <RyanT5000> is there any way to get a compile-time assertion that a function is using a "real" tail call anyway?
17:32:25 <RyanT5000> and, are haskell tail calls implemented as jumps or calls?
17:32:40 <eivuokko> RyanT5000, jumps in most implementations (maybe al?)
17:32:54 <SamB> RyanT5000: try newForeignPtrEnv?
17:33:05 <RyanT5000> eivuokko: so can i get a static guarantee of one?
17:33:22 <SamB> hmm.
17:33:23 <eivuokko> RyanT5000, But it doesn't matter really, it's the marshalling code that is problem - which is outside haskell and gc.
17:33:28 * SamB guesses that won't work either
17:33:37 <RyanT5000> eivuokko: hm
17:34:36 <SamB> this FFI spec is inadequate.
17:34:56 <eivuokko> And annoying if you don't hav underlying C runtime. ;)
17:35:01 <SamB> hmm?
17:35:07 <eivuokko> Should have series of FFI specs, imo :)
17:35:13 <rubyruy> i have to say - although i'm definitely getting around to appreciating haskell's way-of-doing-things vs ruby, the actual code just looks butt ugly to me :p
17:35:23 <SamB> oh. that.
17:35:36 <rubyruy> it's far syntax is just so math oriented
17:35:46 <rubyruy> s/it's far//
17:35:48 <SamB> rubyruy: you ... don't like math?
17:35:56 <eivuokko> FFI + concurrency is anyway vague topic.  GHC's concurrent finalizers are great idea.
17:36:10 <RyanT5000> eivuokko: so, what is the "right" way for me to do this?
17:36:18 <ddarius> rubyruy: Instead it should be... what oriented?  And what would ruby's syntax being "oriented" toward?
17:36:32 <RyanT5000> eivuokko: given that i pretty much *have* to have finalizers that get rid of themselves (or get garbage collected)
17:37:03 <shachaf> rubyruy: I love Haskell's syntax, as compared to Ruby's.
17:37:13 <SamB> RyanT5000: there doesn't seem to be a right way :-(
17:37:33 <rubyruy> well i mean OOP in general is message passing oriented which translates easily to reading code like a natural language. Object nouns and message verbs etc.
17:37:57 <shachaf> rubyruy: Haskell has verbs too!
17:38:02 <rubyruy> it sure does!
17:38:24 <shachaf> rubyruy: So what's the problem?
17:38:33 * shachaf likes verbs.
17:38:36 <rubyruy> but it also has a fairly daunting proclivity for special punctuation and curt names
17:38:42 <rubyruy> (see also poorly written perl)
17:38:55 <shachaf> rubyruy: Huh? Haskell has too much punctuation?
17:38:59 <shachaf> rubyruy: Where?
17:39:08 <fasta>  http://hackage.haskell.org/trac/ghc/ticket/1581 <- there you go
17:39:09 <lambdabot> Title: #1581 (:info doesn't show all instances) - GHC - Trac
17:39:21 <Philippa> there're a handful of really common operators, and then the rest're fairly domain specific
17:39:21 <rubyruy> happs tutorial code: ",h ["getPost"] [GET,POST] $ ok $ val "either GET or POST will result in this response""
17:39:21 <RyanT5000> rubyruy: it's a lot better than many languages - and certainly the happy medium is somewhere between perl and java
17:39:23 <rubyruy> EEESH!
17:39:26 <eivuokko> RyanT5000, Yes, ForeignPtr finalizers and freeHaskellFunPtr never can work alone, you need some tricky registration/freeing service.
17:39:40 <Philippa> that's not that much worse than natural language, especially if you allow parentheticals in online conversation
17:39:44 <fasta> Philippa: do you think the code in that bug report is that uncommon?
17:39:56 <shachaf> rubyruy: That's not a lot of punctuation.
17:40:04 <shachaf> rubyruy: (For one, that's HAppS, not Haskell.)
17:40:15 <aii> anyone know who Vadim is?
17:40:19 <shachaf> rubyruy: The only bit of punctuation there that Ruby doesn't have is $.
17:40:19 <ddarius> rubyruh: ruby has less punctuation?
17:40:20 <RyanT5000> eivuokko: would it be better to use System.Weak to establish a haskell finalizer for a haskell object?
17:40:21 <conal> shachaf: Haskell has verbs?
17:40:43 <eivuokko> RyanT5000, My solution up to now has been a more generic callback, instantiated once in a program, which handles other haskell values through stable ptrs.  I leak that one callback.
17:40:43 <shachaf> conal: It depends on what you mean by verb.
17:40:44 <RyanT5000> conal: a `shift` 5
17:40:47 <fasta> ddarius: if you want to see the kind of code I produce, check that bug report.
17:40:50 <shachaf> conal: Possibly not.
17:41:05 <Philippa> conal: function names're effectively verbs, yeah. Ones with slightly odd grammar 'cos it's not about the side-effects, but still
17:41:16 <rubyruy> ok but look at the whole block here: http://www.haskell.org/haskellwiki/HAppS_tutorial#Methods_and_paths
17:41:19 <conal> maybe Haskell has gerunds!
17:41:19 <lambdabot> Title: HAppS tutorial - HaskellWiki, http://tinyurl.com/2d9fra
17:41:25 <Philippa> we often use actual verbs or verb phrases for function names, too
17:41:28 <conal> rather than verbs
17:41:35 <rubyruy> it has almost no meaning to me
17:41:37 <shachaf> rubyruy: Ignore HAppS. :-)
17:41:43 <conal> Philippa: eg?
17:41:58 <Philippa> "screw", "screwWith" etc etc. That being an artificial example, but still
17:42:04 <rubyruy> so what would be a better representative of haskell code ?
17:42:10 <ddarius> sort, nub, split, read, show
17:42:16 <shachaf> rubyruy: Well, someone suggested xmonad.
17:42:25 <Philippa> approximately half the prelude!
17:42:39 <RyanT5000> eivuokko: i would do that, except that my function needs to have access to at least one thing other than the Ptr passed to it
17:42:44 <shachaf> rubyruy: Indeed, as Philippa says, the Prelude is fun. :-)
17:42:58 <conal> i agree.  we do have a lot of verb names.  they're misleading, though, aren't they?
17:42:59 <Philippa> I actually meant that for verbs, but still :-)
17:43:14 <Philippa> they describe the result of applying that verb to something, no?
17:43:16 <RyanT5000> eivuokko: oh! maybe the environment pointer will work!
17:43:20 <shachaf> Philippa: Oh. :-)
17:43:27 <shachaf> Philippa: Still accurate.
17:43:46 <rubyruy> i should probably mention that i saw absolutely nothing in haskel's core syntax that REQUIRES this style of coding - so my complaint really is more with the established style of coding then the language itself
17:43:48 <Philippa> rubyruy: that piece of mine isn't unrepresentative for IO-heavy code
17:43:52 <conal> i mean i don't care what action is behind coming up with a sorted list.
17:44:07 <conal> so maybe "sorted" would be more fitting than "sort"
17:44:12 <Philippa> rubyruy: I'm not convinced your problem's with much more than $. You get used to it fast, especially if your editor highlights it differently
17:44:18 <rubyruy> Philippa: your code is fairly easy to read, but it's also mostly imperative :p
17:44:23 <shachaf> rubyruy: Is HAppS the established style of coding?
17:44:34 <rubyruy> i'm looking at xmonad now
17:44:42 <Philippa> rubyruy: yeah, but non-imperative code can look similar but with a lot of let and case bindings in place of the do
17:44:44 <shachaf> rubyruy: And as Philippa says (really, this time), $ seems to be the only odd bit of puncutation there.
17:44:53 <shachaf> rubyruy: You'll find everything else in Ruby.
17:45:13 <Philippa> conal: "sorted" is the past case of "sort" though. I'd tend to do let sorted = sort ...
17:45:40 <Philippa> really that's "the sorted thing", but still. Using sorted for the function would feel like the wrong tense to me
17:45:41 <RyanT5000> eivuokko: yeah, that does it; i can shove as much Haskell crap as i want in the environment pointer
17:46:09 <conal> Philippa: i was looking for an adjective.  maybe "ordered" (though ambiguous as a past-tense verb), or "inOrder".
17:46:15 <eivuokko> RyanT5000, env pointer as in ffi or terminology of the api you use?
17:46:27 <rubyruy> ok xmonad isn't nearly as evil ;)
17:46:28 <RyanT5000> eivuokko: using newForeignPtrEnv
17:46:48 <shachaf> rubyruy: Did you look at those videos?
17:46:52 <shachaf> @wiki Video presentations
17:46:53 <lambdabot> http://www.haskell.org/haskellwiki/Video_presentations
17:47:07 <Philippa> conal: I think that's too limited. inOrder from what, by what means? What if I've got more than one way of getting something inOrder?
17:47:13 <rubyruy> ok i'll look at them now
17:47:32 <conal> Philippa: denotationally equivalent or not?
17:47:44 <Philippa> the result would be, the function may not be
17:47:56 <RyanT5000> eivuokko: so what i can do is have the environment be a StablePtr to a Haskell function (Ptr a -> IO ()), and get rid of the StablePtr once i've run it
17:47:58 <conal> Philippa: ??
17:48:34 <conal> Philippa: do you mean different algorithms or (denotationally) different functions?
17:48:44 <eivuokko> RyanT5000, Not sure how exactly that helps.
17:48:46 <Philippa> denotationally different functions
17:48:58 <RyanT5000> eivuokko: i'll paste the code once i've written it
17:49:04 <eivuokko> RyanT5000, But I gotta get some sleep anyway, good luck :)
17:49:22 <RyanT5000> eivuokko: alright; it'll be on hpaste.org tomorrow :)
17:49:42 <Philippa> which okay, generally suggests a more precise typing can be had and a typeclass introduced if you really /want/ to
17:49:51 <Philippa> but I'm not sure I do
17:49:59 <conal> Philippa: okay, thanks.  what i'm going for is the name of a function, rather than an action.  Maybe like "sum" is to "add".
17:50:26 <Philippa> I'm not sure I see the difference - "to sum" is still a legit phrase
17:50:48 <conal> Philippa: yes it is, and it's a verb, while I mean the noun "sum".
17:51:03 <conal> as in "the sum of a and b"
17:51:55 <Philippa> mmm. I might use that conjugation if I were talking about code, I'm not sure I'd want it written in code
17:52:26 <conal> perhaps we're missing good nouns for computable functions when those functions arose from programming rather than math.
17:52:45 <Philippa> mostly because I'd prefer to have those free to bind results to
17:53:09 <Philippa> I'd like to be able to talk about "the sum [of a and b]" in my code, I can't do that if I've already got sum bound to the operation
17:53:30 <conal> Philippa: neither would I.  I'd write "a + b" and say "the sum of a and b".  I certainly wouldn't say "add a and b".  Consider nesting.
17:54:29 <rubyruy> ok the cameraman in the taste of haskell videos REALLY needs to show the damn slides
17:54:31 <Philippa> I might say "the addition of a and b" - at least in the general case, I'm prone to just reading out the operator name (plus here)
17:55:47 <conal> urk.  "the addition" is yet another thing.  a noun naming an action.  why not simply "the sum of".
17:56:08 <conal> perhaps most importantly, if i use action words for functions and then i form nested expressions, i end up saying "then".  imperative.
17:56:47 <conal> for instance "add 3 and 5.  then multiply by 7"  vs "the product of (the sum of 3 and 5) and 7".
17:57:28 <ddarius> rubyruy: The slides are available separately.
17:57:42 <RyanT5000> conal: you're right, typically I try to use verbs for monadic functions, or at least functions that do stateful-looking things (setThingInRecord)
17:57:48 <conal> the latter maps directly to or from "(3+5)*7", while the former is some kind of sequential composition.
17:57:51 <shachaf> rubyruy: You can get the slides.
17:57:55 <rubyruy> ah i see them now
17:58:05 <shachaf> @wiki Video presentations
17:58:05 <lambdabot> http://www.haskell.org/haskellwiki/Video_presentations
17:58:06 <SamB> rubyruy: I wish he'd have shown the live interaction better :-(
17:58:51 <conal> RyanT5000.  i think using verbs is *especially* confusing for IO (and other action-describing types).
17:58:58 <Philippa> conal: sure, I'm just saying that I can conjugate as I speak. I wouldn't say "the addition of..." for actual addition because there's a nicer word for it, my point is more that we can do that for any verb
17:59:26 <conal> RyanT5000: because of the easy-to-miss difference between the *being* and *doing* of a computation.
18:00:03 <Philippa> that's actually why I prefer the most basic form of a verb
18:00:26 <RyanT5000> conal: do you mean because you can say (replicateM_ 10 $ putStrLn "Hello")?
18:00:35 <conal> Philippa: i guess i'm confused about "the addition of".  why would you want to describe a process (addition) rather than a result (sum)?
18:00:41 <RyanT5000> therefore it should be called (puttingOfStrLn) instead?
18:00:42 <Philippa> RyanT5000: because that expression doesn't do anything else
18:01:04 <Philippa> conal: because as soon as there's more than one process, it matters which I picked
18:01:13 <conal> RyanT5000: exactly!  a gerund.
18:01:20 <conal> similarly "replicationM_"
18:02:01 <conal> or we just make sure that we really get it that "replicateM_" means "replicationM_", etc.
18:02:01 <Philippa> conal: do printing "Hello World!"? I'm more likely to read that as the "doing" than the "being" at first glance
18:02:23 <conal> Philippa:  that's why "do" is also fundamentally misleading.
18:02:30 <RyanT5000> conal: yeah, ok, but what if i hand you a card in the real world that says "Go over here" and then i say "Do this in 10 minutes"
18:02:58 <Philippa> "to $newOperation, do this; that; other;" - I don't see that as fundamentally confusing
18:03:06 <RyanT5000> conal: you can think of a monadic computation as a quoted command
18:03:25 <RyanT5000> conal: clearly, it will only get unquoted when it's "run" (i.e.: makes it out of Main)
18:03:36 <RyanT5000> conal: but we still express quoted commands in the real world using verbs
18:03:56 <RyanT5000> conal: i suppose your method would obviate the logical quotation
18:04:38 <conal> RyanT5000: i'm afraid that the description "quoted" blurs the difference between syntax & semantics..
18:05:05 <Philippa> well duh, it came from lisp
18:05:08 <RyanT5000> conal: perhaps; i don't pretend to fully understand that difference
18:05:21 <conal> Philippa: exactly.
18:05:54 <ddarius> Conal's just a logic programmer in (poor) disguise
18:05:57 <Philippa> however, the analogy to natural language holds
18:06:18 <Philippa> people do read it "as if quoted"
18:06:24 <RyanT5000> Philippa: i didn't really steal that from lisp; i stole it from the real world.  There's a big difference between saying something in quotes and not.
18:06:27 <conal> RyanT5000: how about simply syntax is an external rep (say ascii text in a file), and semantics is an internal rep.  that division gets to the point i wanted to make.
18:06:48 <Philippa> RyanT5000: yeah, the equivalent notion in CS is indeed a lisp thing though
18:07:10 <RyanT5000> Philippa: yeah, i know, but i don't care about lisp particularly much for the purposes of this argument :P
18:07:23 <Philippa> but to make the semantic distinction you still need a syntactic equivalent to indicate it
18:07:39 <RyanT5000> conal: sure, then you can't interpret monadic things as quoted
18:08:04 <SamB> conal: english teachers will have your head!
18:08:19 <Philippa> however, we /have/ the syntactic distinctions - otherwise the typechecker wouldn't be able to tell the difference
18:08:22 <conal> so maybe quoting isn't the point.  more generally, any two types with an interpretation function that relates them.
18:09:07 <Philippa> yes, and quotes are normally used to delineate the uninterpreted version in natural language
18:09:08 <conal> SamB: why?
18:09:15 <Philippa> when I use "this phrase"...
18:09:27 <SamB> "replicationM_"?
18:09:28 <conal> Philippa: as a special case, but not the general case.
18:09:44 <Philippa> show me a common example where that's not happening?
18:09:59 <Philippa> you might then go on to interpret it anyway, sure
18:10:05 <conal> the execution of an IO value
18:10:14 <conal> (that was for Philippa)
18:10:16 * wli wonders what the best way to define a specialized instance of StateT intended to nest with other uses of StateT and other, similar specialized instances of StateT is. (Separation of concerns problem here.) I want to avoid having the MonadState methods visible for the outer monad, but instead define my own class combinators in terms of them.
18:10:28 <wli> Also, what's the deal with cyclic module imports?
18:10:35 <Philippa> conal: not natural language
18:10:52 <conal> Phillipa: i wasn't talking about natural language
18:10:53 <Philippa> wli: hard work to implement efficiently. I like having them
18:11:03 <wli> ghci is barfing on cyclic module imports
18:11:04 <Philippa> conal: but my statement /was/ about natural language
18:11:18 <conal> Philippa: oops.  i'll re-read context
18:11:37 <sjanssen> wli: they're not supported that well by ghc
18:11:54 <conal> Philippa: i'm confused about what you're asking.  what about natural language?
18:12:02 <sjanssen> wli: you have to write an "hs-boot" that has a few stubs to help GHC along
18:13:38 <Philippa> conal: you appeared (but it seems there's been a misunderstanding) to say that quotes being used in natural language to denote "uninterpreted" text is a special rather than the general case
18:13:43 <sorear> hugs doesn't support them at all.  jhc supports them by default, but requires vastly more memory/time the more modules depend on each other (the jhc Prelude is in a group of 13, and takes days)
18:13:55 <Philippa> I asked for examples where they're not used that way
18:14:05 <sorear> dunno about hbc, yalehaskell
18:14:52 <sorear> nyhc supports them in much the same way as GHC, except that instead of writing a pseudo-haskell hsboot file, you have to write it in the undocumented .yhi interface file format
18:14:57 <conal> Philippa: oh!  thanks.  i meant that quoting and meaning-extraction  is a special case of "interpretation".
18:15:25 <sm> wli: to avoid them you can try to layer your app so they aren't needed, or move the types to a single module which everyone imports
18:15:27 <SamB> sorear: so why is that better?
18:15:52 <sjanssen> sorear: undocumented, binary format, isn't it?
18:15:53 <SamB> sorear: also how the hell does it take days?
18:15:58 <sorear> SamB: I was trying to imply just the opposite
18:16:00 <SamB> (JHC)
18:16:03 <SamB> sorear: hmm.
18:16:03 <conal> Philippa: and IO-value interpretation (World -> (a,World)) is different example.
18:16:10 <Philippa> I think meaning-extraction is exactly what interpretation is about, myself
18:16:13 <sorear> SamB: exponentially increasing memory use + 384MB core
18:16:28 <SamB> sorear: it didn't take days here
18:16:34 <Philippa> (World -> (a,World)) is only one possible implementation of the IO monad
18:16:38 <sorear> sjanssen: nyhc uses text interface files... they keep meaning to fix that
18:16:39 <conal> Philippa: sure, you could say that.   my point is that not all interpretations start out with quoted text.
18:16:42 <SamB> you only have 384 megs though?
18:16:47 <SamB> sorear: get some more megs!
18:16:58 <conal> Philippa: I mean the IO comment as semantic.
18:16:58 <Binkley> 384 megs is all anyone will ever need
18:17:13 <monochrom> I had 640 megs
18:17:20 <conal> another example is turning an image into text (eyes+brain, or scanner+OCR program)
18:17:23 <Philippa> there is another that essentially corresponds to a source program which can be run by an external interpreter (such as the GHC RTS)
18:17:26 <sorear> yeah.  if it weren't for JHC I could get by with 16
18:17:55 <conal> Philippa: great.  still more examples of interpretation that has nothing to do with quotes
18:18:01 * sm has 768M and can barely browse the web
18:18:26 <Philippa> however, it is reasonable at that point to informally describe the IO actions as "quoted" code that is later run
18:18:31 <wli> For some reason these specialized state monad transformers aren't interoperating well.
18:19:17 <sjanssen> sm: yikes, what sort of software are you running?
18:19:21 <Excedrin> talking about reimplementing code from other languages in Haskell, I'd really like to see OSBF-Lua (C and Lua) in Haskell, it's a very useful piece of code
18:19:23 <conal> Philippa: except that doing so encourages syntax/semantics confusions.  and i mean specifically PL syntax & semantics
18:19:41 <ddarius> Excedrin: Go ahead.
18:19:43 <sm> firefox, thunderbird, pidgin, and emacs, basically
18:19:54 <conal> Philippa: like refering to function values as "lambdas"
18:19:57 <Philippa> conal: effectively what you're challenging there is whether it's reasonable to describe anything informally
18:20:17 <Excedrin> ddarius: I have no reason to, it works well already :)
18:20:38 <Philippa> "lambdas" tends to be shorthand for "lambda abstractions", which is a name for a grammatical construct
18:20:42 <conal> Philippa: I don't have a meaning for "reasonable", so i couldn't say yes or no.
18:20:59 <conal> Philippa: (lambdas) exactly!  while functions are semantic.
18:21:47 <Philippa> and it's not unreasonable to locate code by its syntax, or to treat the syntax as corresponding to a specific set of semantics in an appropriate context (such as when it's agreed to be haskell code)
18:22:03 <wli> http://holomorphy.com/~wli/AllMonads.hs.txt
18:22:17 <sm> so, I dream of all these lean, mean, next-generation functional web browser, chat, mail progs of the future!
18:22:25 <conal> Philippa: (continuing on "reasonable").  rather, i'd say that some explanations ("lambdas" for functions or "programs" or "quotations" for IO valuse) exacerbate existing confusions.
18:22:30 <wli> For some reason those Monad transformers aren't doing the right things.
18:22:31 <RyanT5000> Philippa: that's only true when the difference doesn't matter
18:22:31 <newsham> will ghc run on freebsd/amd64?
18:23:24 <ddarius> sm: I blame it on emacs and/or pidgin.
18:23:31 <Philippa> conal: I think programs is entirely reasonable for IO values given that in a meaningful sense main /is/ the program
18:23:34 <RyanT5000> conal: you may find that the distinctions here can be made arbitrarily fine; compiler-implementers will certainly care about semantics vs. syntax; users may not, because, for them, semantics and syntax are largely equivalent
18:24:16 <Philippa> similarly, in manipulating the syntax of a program I also manipulate its semantics
18:24:23 <conal> Philippa: "program" is already taken, for the syntax fed into the compiler.
18:24:27 <Philippa> (I'd hope so, otherwise I could never write meaningful code!)
18:24:46 <Philippa> conal: sez you! Me, I say you feed modules in
18:25:08 <Philippa> nor would I tell someone off for talking about having embedded a program in the source of another
18:25:21 <conal> Philippa: do you mean the meaning of "main" or the syntactic definition?
18:25:27 <wli> Why aren't my monad transformers nesting properly?
18:25:40 <sm> they're wrong wli, wrong I tell you
18:25:49 <LoganCapaldo> wli, did you tip them? Maybe they're disgruntled
18:25:52 <Philippa> if I have the string "10 PRINT \"HELLO WORLD\"\n20 GOTO 10" in a haskell program, it's perfectly correct to say that I have a BASIC hello world program in the haskell program
18:26:06 <LoganCapaldo> heh
18:26:13 <LoganCapaldo> a BASIC hello world program
18:26:13 <sm> and anyway it's too late in the year
18:26:20 <LoganCapaldo> a basic hello world program
18:26:29 <Philippa> a particularly *verbose* hello world program :-)
18:26:35 <conal> Philippa: and i'd figure out what you really mean.  no problem.
18:27:01 <LoganCapaldo> basic BASIC
18:27:02 <conal> Philippa: so in that case, the informality worked out fine.
18:27:15 <LoganCapaldo> Roger, Roger. What's out vector, victor?
18:27:19 <Philippa> it's not informal at all. The one object is present in the other
18:27:51 <Philippa> you've already insisted that source is a program, so you can't complain that I should say "the source for a BASIC program"
18:28:42 <wli> http://holomorphy.com/~wli/AllMonads.hs.txt <-- the monad transformers I'm trying to get to work
18:29:27 <conal> Philippa: yes, i agree. and i wouldn't confuse the BASIC source code and the Haskell source code.
18:29:33 <Philippa> the same applies if I embed a language's syntax as an algebraic datatype
18:29:44 <Philippa> or rather, as one that wasn't isomorphic to a string of characters
18:30:47 <SamB> Philippa: I contend that that is actually a funny "yes" program
18:30:56 <conal> Philippa: agreed.  and i'm fine with calling IO values "VN programs" or something, to distinguish them from Haskell programs.
18:31:18 <Philippa> so your problem isn't informality at all, it's overloading
18:31:28 <SamB> conal: so what makes them different from Haskell programs?
18:31:42 * SamB though a Haskell program was just a value of type IO ()
18:32:15 <conal> SamB: no, a Haskell program is a piece of syntax that maps to a value of type IO ().
18:32:33 <conal> SamB: imagine IO as a GADT and Haskel as a GADT.  they're very different data types (languages)
18:32:39 <Philippa> no. Per the Haskell 98 Report, a Haskell program is a set of modules
18:32:50 <SamB> well.
18:33:17 <wli> newtype EnvironT key value monad result = EnvironT { runEnvironT :: StateT (Map.Map key value) monad result } deriving ( Functor, Monad, MonadPlus, MonadFix, MonadTrans, MonadIO, MonadCounter, MonadCont, MonadError e, MonadReader r, MonadWriter w)
18:33:21 <Philippa> it also says "The value of the program is the value of the identifier main in module Main"
18:33:39 <SamB> aha!
18:33:47 <conal> Philippa: okay.  then a haskell program is a collection of pieces of syntax.  Or multi-part  syntax.
18:33:58 <Philippa> "When the program is executed, the computation main is performed, and its result (of type t) is discarded"
18:34:06 <SamB> oh.
18:34:10 <conal> Philippa: eactly: the *value* of program.  not the program itself.
18:34:10 <wli> newtype CounterT m t = CounterT { runCounterT :: StateT Integer m t } deriving ( Functor, Monad, MonadPlus, MonadFix, MonadTrans, MonadIO, , MonadEnviron key value, MonadError e, MonadReader r, MonadWriter w)
18:34:24 <SamB> so it's a value of some type IO a?
18:34:34 <Philippa> however, the value of the haskell program can reasonably be described as a program itself
18:34:34 <SamB> er.
18:34:45 <conal> SamB: yes.
18:34:51 <wli> Plus handwritten instances of MonadState to get things to nest.
18:34:59 <conal> Philippa: in a different language.
18:35:25 <Philippa> sure. But so long as you don't see people calling IO programs "haskell programs" you've not really got grounds for complaint
18:35:43 <wli> testExpr1 = evalCounterT $ evalEnvironT $ do { tick ; tick ; n <- tick ; envInsertWith (+) "x" n ; return n }
18:35:55 <lament> Io is quite a different language from Haskell :)
18:35:56 <hpaste>  RyanT5000 pasted "newForeignPtrHaskell - Haskell native functions as finalizers, without the memory leaks" at http://hpaste.org/2048
18:35:59 <wli> That can't be instantiated with any concrete types for some reason.
18:36:02 <SamB> I don't get this expression/value distinction...
18:36:04 <Philippa> lament: note capitalisation!
18:36:18 <RyanT5000> SamB: wanna look at that thing i just pasted?
18:36:19 <conal> Philippa: I've seen lots of confusions, especially when graphs or lazy evaluation is involved.  that's where my concern comes from.
18:36:19 <wli> nor can testExpr2 = evalEnvironT $ evalCounterT $ do { tick ; tick ; n <- tick ; envInsertWith (+) "x" n ; return n }
18:36:24 <wli> So what hit me?
18:36:26 <Philippa> SamB: the glyph "1" is not the same as the number
18:36:31 <conal> lament: very different.
18:36:48 <SamB> Philippa: hey
18:36:52 <wli> Numerals I think they're usually called (or so Mitchell calls them).
18:36:53 <SamB> you can't send glyphs over IRC
18:36:56 <SamB> only bytes!
18:37:06 <LoganCapaldo> SamB, is it useful to make a distinction between 2 * 3 and 10 - 4 ?
18:37:06 <SamB> the first 128 of which correspond with characters
18:37:13 <Philippa> SamB: sure. I'm 99% sure that a glyph appeared on your screen though
18:37:19 <SamB> which might or might not be mapped to glyphs
18:37:30 * wli is baffled by this monad transformer problem.
18:37:39 <SamB> but I'm 100% positive that you had no real way of knowing WHAT glyph it would be mapped to
18:37:46 <conal> SamB: "3+4" /= "7", but 3+4 == 7, ie meaning ("3+4") == meaning ("7").  does that help at all?
18:37:57 <SamB> (except that the glyph would probably be a representation of a '1' character)
18:38:04 <Philippa> SamB: sure, just a very good guess. Same as I had for what the string of bytes would mean
18:38:27 <Philippa> conal: you're being sent up
18:38:32 <Philippa> wli: what's up?
18:38:37 <RyanT5000> SamB: http://hpaste.org/2048 -- an implementation of the function i've been talking about
18:38:39 <Philippa> (not that I can stay around to answer, I need to go to bed)
18:38:46 <conal> Philippa: "sent up"??
18:39:12 <SamB> RyanT5000: ah, that's a good way to do it I guess
18:39:27 <conal> (i quoted because i'm asking about the words.  what does "sent up" mean?)
18:39:34 <SamB> RyanT5000: you should submit it to the libraries process
18:39:39 <RyanT5000> SamB: i'm pretty sure it can't ever crash or leak
18:39:41 <Philippa> conal: parodied
18:39:42 <RyanT5000> SamB: how do i do that?
18:40:24 <RyanT5000> SamB: i have another module to submit, as well, System.Random.MersenneTwister.MT19937
18:40:29 <conal> Philippa: by SamB?
18:40:55 <RyanT5000> (which is a packaging of augustss's excellent implementation)
18:41:07 <conal> Philippa: thanks for the chat.  happy sleeping.
18:41:11 <SamB> RyanT5000: http://www.haskell.org/haskellwiki/Library_submissions
18:41:12 <lambdabot> Title: Library submissions - HaskellWiki
18:41:34 <SamB> RyanT5000: well, the thing you've just made really probably ought to be in the standard library
18:41:43 <RyanT5000> SamB: alright
18:42:15 <aii> @seen Lemmih
18:42:16 <lambdabot> Lemmih is in #ghc and #haskell. I last heard Lemmih speak 7h 8m 34s ago.
18:42:28 <mdmkolbe> (This really belongs in #ghc, but they're asleep)  Is there a -ddump flag or equivalent to get the result of a cmm file after it goes though CPP but before it goes to the Cmm parser?  (I have a strange parse error, emboiled with some macros)
18:42:44 <wli> Philippa: I'm trying to wrap StateT in things with specific state that hide the MonadState methods and provide their own access methods.
18:42:52 <Binkley> mdmkolbe: -v5 will dump out everything you could want :-)
18:42:55 <Binkley> (and a lot more)
18:43:04 <SamB> Binkley: probably it dumps lots of things he doesn't want
18:43:13 <Binkley> yes
18:43:15 <SamB> but that doesn't mean it dumps all the things he wants
18:43:20 <wli> Philippa: This is essentially so they can be nested in an orderly fashion.
18:43:35 * mdmkolbe tries it
18:43:37 <mdmkolbe> Binkley: it didn't dump the source after it went thought CPP
18:43:41 <Binkley> hmm
18:43:55 <wli> Philippa: What goes wrong is that the transformers won't typecheck.
18:44:00 <aii> anyone familiar with hIDE? I've managed to compile it, but i can't figure out how to run it.
18:44:01 <aii> It says: Usage: hIDE [MAIN PLUGIN]
18:44:06 <aii> but i don't know what to type for [MAIN PLUGIN]
18:44:08 <SamB> RyanT5000: your twister, though, you could just cabalize and stick on hackage
18:44:28 <wli> Philippa: The source is at http://holomorphy.com/~wli/AllMonads.hs.txt
18:44:53 <RyanT5000> SamB: alright, i'll do that asap
18:45:14 <RyanT5000> SamB: the library submission looks a little involved, so it'll take me slightly longer to get around to it
18:45:18 <RyanT5000> (also, i should test it first)
18:46:24 <wli> No instance for (MonadEnviron [Char] Integer (StateT Integer (EnvironT key value (Either String))))
18:46:39 <SamB> RyanT5000: yeah. it does seem rather involved.
18:47:04 <Binkley> mdmkolbe: if you pass in -keep-tmp-files as well, it should save any temporary files it creates, as well as printing out their names
18:47:08 <SamB> RyanT5000: however, I don't think you'll run into too much bikeshedding on this one, somehow
18:47:13 <Binkley> so if it's running cpp, it should tell you what the name of the file is that it's passing to cpp
18:47:44 <RyanT5000> SamB: bikeshedding?
18:48:05 <Binkley> @go bikeshed coloring
18:48:07 <lambdabot> http://www.unixguide.net/freebsd/faq/16.19.shtml
18:48:07 <lambdabot> Title: Why should I care what color the bikeshed is?
18:48:07 <SamB> RyanT5000: if you want to build a nuclear power plant, it's like "okay! sure!"
18:48:32 <Lemmih> aii: HIDE has bitrotted.
18:48:35 <SamB> but if you want to build a bikeshed, people have a tendancy to argue about what color to paint it
18:48:46 <RyanT5000> SamB: ah, ok
18:48:58 <dons> http://bikeshed.org
18:49:00 <lambdabot> Title: Why Should I Care What Color the Bikeshed Is?
18:49:11 <SamB> but I think your bikeshed is nearly free of surfaces to paint, and I think it might be a nuclear bikeshed anyway ;-)
18:49:16 <ddarius> wli: Why do you think that you have an instance of that type?
18:49:37 <RyanT5000> SamB: sounds like fun :)
18:49:38 <aii> Lemmih: I've managed to compile it though.... I think the problem is that it's looking for a missing file "package.conf"
18:50:06 <lament> Bright green with yellow dots!
18:50:22 <mdmkolbe> Binkley: I pulled the CPP what command from -v5 and just ran it manually.  thx for the help
18:50:34 <Binkley> mdmkolbe: np
18:51:00 <SamB> RyanT5000: and it looks like a pretty solid implementation, too
18:51:02 <RyanT5000> SamB: that's an excellent metaphor (bikeshedding), which i will propagate extensively :)
18:51:07 <wli> ddarius: Well, I gave instance decls. There's a weird StateT showing up where I don't expect it, among other things.
18:51:11 <RyanT5000> SamB: thanks for reviewing it
18:51:16 <Lemmih> aii: Try using the gtk plugin.
18:51:35 <campusblo> i was just doing a google search on haskell for mobile systems and didnt get much info, anyone know about this?
18:51:56 <aii> Lemmih: what is the command line for that?
18:52:24 <ddarius> wli: Ok, I was not completely sure that that wasn't what you wanted.
18:52:27 <ddarius> wli: Give me a sec to look again.
18:53:24 <Lemmih> aii: Sorry, tech support for hide is no longer available. You're on your own on this one.
18:53:51 <bsmntbombdood> I'm not new to functional programming, what haskell book/tutorial should i read?
18:54:27 <aii> ok but could you please just tell me, what the syntax is for specifying the gtk plugin? ./bin/hIDE packages/gtkBase/??????
18:54:58 <RyanT5000> bsmntbombdood: i was relatively new to FP, and i read Yet Another Haskell tutorial, and it was OK; i don't think it wastes too much of your time
18:55:12 <Lemmih> aii: I really can't remember.
18:55:26 <lament> "a gentle introduction to rape"
18:55:29 <lament> err
18:55:40 <aii> Lemmih: ok thanks anyway, i'll try to figure it out
18:55:47 <RyanT5000> bsmntbombdood: i had taken a senior-level class in programming languages though, so i had used scheme and prolog and ML and such
18:56:05 <SamB> bsmntbombdood: maybe A Taste of Haskell? http://haskell.org/haskellwiki/Video_presentations#Introductions_to_FP_and_Haskell
18:56:07 <lambdabot> Title: Video presentations - HaskellWiki, http://tinyurl.com/3bgybs
18:56:21 <ddarius> I'm going to have to actually download and compile this.
18:56:26 <SamB> bsmntbombdood: or did you want something more textual?
18:56:37 <bsmntbombdood> SamB: textual
18:56:44 <pgavin> bsmntbombdood: check out the haskell wikibook: http://en.wikibooks.org/wiki/Haskell
18:56:45 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
18:57:09 * SamB is watching it because SPJ is so much fun to watch/listen to ;-)
18:57:26 <SamB> bsmntbombdood: you can find more things in Category:Tutorials
18:57:36 <dibblego> SamB, I wonder what would happen if you put some coffee into him beforehand :)
18:57:44 <ddarius> wli: When I load that into GHCi I get different type errors.
18:57:50 <SamB> dibblego: hmm. big explosion, probably!
18:57:59 <ddarius> SamB: SPJ is fun to watch.
18:58:04 <wli> ddarius: I'm using zillions of extensions, of course.
18:58:05 <Binkley> dibblego: it doesn't make much difference :-)
18:59:12 <ddarius> wli: What command line options, besides -fglasgow-exts?  (You're going to say -foverlapping-instances and I'm going to be upset.)
18:59:15 <wli> ddarius: -fallow-undecidable-instances is apparently it.
18:59:28 <ddarius> Ok.  That's less evil (to me).
19:00:03 <bsmntbombdood> ah, Yet Another Haskell Tutorial says A Gentle Introduction to Haskell is better for those already familiar with FP
19:00:21 <wli> ddarius: Looks like it centers around the MonadState instances (I basically want to bypass the internal StateT and shunt get/put to the inner monad).
19:00:48 <ddarius> The MonadState instances shouldn't be putting that constraint into it.
19:00:59 <campusblo> Haskell: The Craft of Functional Programming
19:01:15 <SamB> wli: so, uh, don't derive that
19:02:15 <wli> SamB: I didn't derive MonadState
19:02:31 <wli> SamB: I wrote it by hand, and that much appears to pass the typechecker.
19:02:38 <SamB> wli: what did you write?
19:02:41 <SamB> at the top?
19:03:03 <wli> SamB: Rephrase.
19:03:39 <ddarius> wli: I think the issue is deriving MonadEnviron
19:03:43 <wli> ddarius: Which constraint?
19:04:39 <wli> Well, I have non-derived instances I commented out.
19:04:50 * SamB_XP_ accidentally right-clicks on a flash window :-(
19:05:08 <SamB> oh good. it's recovered.
19:05:30 <ddarius> wli: What do you mean which constraint?  I believe that deriving the MonadEnviron leads to it needing an instance of MonadEnviron on the enclosed StateT.
19:05:42 <ddarius> I'm seeing what your other instances do.
19:06:26 <wli> ddarius: Okay, I nuked the derivings and am using the open-coded ones.
19:07:39 <shachaf> @quote SPJ
19:07:39 <lambdabot> SPJ says: I'm sitting there, under the cover, doing side effects like crazy. But I'm making it so beautiful for you so that you can think of pure folds, and I would do the dirty things for you.
19:08:02 <ddarius> wli: It does seem better without them.
19:08:07 <ddarius> (not fixed yet, mind you)
19:08:36 <RyanT5000> why doesn't modifyMVar_ return the new value of the MVar?
19:09:42 <ddarius> wli: You need something to lift MonadEnviron through an EnvironT
19:10:00 <SamB> RyanT5000: I'm guessing it has something to do with the _?
19:10:31 <ddarius> wli: Actually, let me think at it a second more.
19:10:33 <RyanT5000> SamB: yeah, but modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
19:10:35 <wli> ddarius: Not sure what you mean.
19:10:45 <SamB> @hoogle modifyMVar
19:10:46 <lambdabot> Control.Concurrent.MVar.modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
19:10:46 <lambdabot> Control.Concurrent.MVar.modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
19:11:01 <geezusfreeek> anybody got any good links on types of types (kinds, i guess)? i'm looking for answers to questions like "why is there only one type of types?" and "why are they important?"
19:11:11 <ddarius> wli: Actually, I think some fundeps will do it.
19:11:16 <SamB> RyanT5000: so compose your modification function with (id &&& id)
19:11:34 <RyanT5000> SamB: yeah, that's what i'm doing, but i don't see the point i not lazily returning a value
19:11:45 <geezusfreeek> anything like * -> * still confuses me right now
19:12:27 <SamB> geezusfreeek: that's the kind of all Monads...
19:12:53 <mauke> geezusfreeek: don't worry about it. you don't really need kinds as long as you understand how to use types
19:13:11 <geezusfreeek> mauke: but… i want to learn about kinds!
19:13:18 <LoganCapaldo> I've always wondered about the difference between * and ?
19:13:23 <LoganCapaldo> @kind (->)
19:13:29 <lambdabot> ?? -> ? -> *
19:13:38 <LoganCapaldo> (not to mention ??)
19:13:40 <geezusfreeek> woah, i didn't even know ? existed
19:13:44 <mauke> it doesn't
19:13:48 <SamB> geezusfreeek: don't worry!
19:13:52 <SamB> geezusfreeek: it's not standard
19:14:12 <SamB> geezusfreeek: just, um, take the blue (?) pill
19:14:23 <geezusfreeek> :\
19:14:33 <SamB> LoganCapaldo: well
19:14:34 <monochrom> haha
19:14:48 <geezusfreeek> what does it mean to say that the kind of a Monad is * -> * ?
19:14:55 <ddarius> wli: Adding to the MonadEnviron class declaration, '... monad | monad -> key value' seems to resolve that issue.
19:14:58 <geezusfreeek> yeah, i'm not taking the blue pill
19:15:01 <SamB> LoganCapaldo: ?? includes unboxed types as well as boxed
19:15:04 <monochrom> *->* is type constructor taking one parameter
19:15:06 <mauke> geezusfreeek: let's get more concrete and use Maybe as an example
19:15:06 <SamB> ? includes even unboxed tuples
19:15:15 <geezusfreeek> mmkay
19:15:18 <LoganCapaldo> SamB, that's not very exciting
19:15:24 <wli> ddarius: phew
19:15:30 <mauke> geezusfreeek: Maybe is a type constructor. Maybe Int is a type. Int Maybe is an error.
19:15:52 <LoganCapaldo> id is function. id () is a value. () id is an error
19:15:56 <wli> ddarius: Thanks a zillion
19:16:03 <ddarius> wli: The code still doesn't type check, but I think the error is more reasonable.
19:16:03 <SamB> in ML for some reason you'd HAVE to write int maybe
19:16:11 <geezusfreeek> hmm, so what would be the kind of Maybe?
19:16:13 <mauke> Maybe :: * -> * and Int :: *, therefore Maybe Int :: *
19:16:18 <geezusfreeek> ah
19:16:18 <monochrom> Int, Double, String, ... have kind *.  IO, Maybe, Data.Set.Set have kind * -> *.  Control.Monad.State.State has kind * -> * -> * (e.g., State Int a)
19:16:23 <wli> ddarius: It's coming through here.
19:16:25 <geezusfreeek> okay, that doesn't seem complicated
19:16:30 <SamB> ML is a bit of a backwards language
19:16:31 <ddarius> Okay.
19:16:32 <mauke> it's rather simple
19:16:48 <ddarius> int option
19:17:08 <SamB> ddarius: oh, they have one predefined?
19:17:18 <wli> ddarius: -fglasgow-exts -fno-monomorphism-restriction -fallow-undecidable-instances
19:17:19 <chessguy> * is to types as 'a' is to values, maybe?
19:17:20 <ddarius> geezusfreeek: If you understand types, then you understand kinds.  They are simpler than types.
19:17:28 <LoganCapaldo> SOME of 'a | NONE
19:17:31 <chessguy> ('a' in a type signature, that is'
19:17:31 <LoganCapaldo> IIRC
19:17:50 <monochrom> @kind Control.Monad.State.StateT
19:17:52 <wli> ddarius: It flies here with that.
19:17:52 <lambdabot> * -> (* -> *) -> * -> *
19:17:54 <ddarius> wli: GHCi didn't like my :s -fno-monomorphism-restriction then.
19:17:59 <geezusfreeek> can there ever really be a type signature that has kinds and other types mixed in it?
19:18:07 <wli> ddarius: What ghci version?
19:18:21 <wli> ddarius: I've got 6.6.1 here.
19:18:36 <mauke> you can't really mix kinds and types, just like you can't mix types and values (i.e. 2 + Int is an error)
19:18:36 <ddarius> wli: I think it's because I used :re or something.  The type error I got was still suggesting add -fno-monomorphism-restriction
19:18:43 * ddarius doesn't actually use GHCi that much.
19:19:47 <ddarius> chessguy: * : Int :: Int : 3
19:20:08 <geezusfreeek> one more question before i'm satisfied: would something *1 -> *2 -> *1 ever make any sense? like a kind system specifying some higher form of type calculation?
19:20:10 <LoganCapaldo> I seem to recal seeing synatx that looked like (m :: * -> *) => m a -> m a or something like that
19:20:17 <chessguy> ddarius, yeah, that's the kind (pardon the pun) of thing i had in mind
19:20:28 <wli> ddarius: Is what I'm doing a useful idiom in general or is it more conventional to accomplish the same effect some other way?
19:20:30 <geezusfreeek> LoganCapaldo: well, that would make some sense to me though
19:20:38 <ddarius> chessguy: * is not a variable but a concrete kind.
19:20:53 <ddarius> wli: What part of it?
19:21:21 <wli> ddarius: Specializing StateT (and/or other transformers) for the purposes of nesting the transformers.
19:21:29 <geezusfreeek> the way i understand it, (m :: * -> *) just means that m is a constructor and (a) has to be a type
19:21:49 <mauke> yes
19:21:50 <monochrom> yes
19:22:02 <LoganCapaldo> well m is a type constructor
19:22:10 <mauke> does H98 have syntax for kinds?
19:22:13 <geezusfreeek> yes
19:22:24 <geezusfreeek> (in response to LoganCapaldo)
19:22:45 <LoganCapaldo> -fpedant ;)
19:22:53 <monochrom> No. The report explains kinds, but just as a concept and not written in code.
19:22:59 <ddarius> wli: I'm not exactly sure what you mean by "specializing" but you should be able to nest them without having to wrap them.  It is common to at least wrap a "top level" monad (transformer) for clarity.
19:23:03 <chessguy> ddarius, yeah, i didn't word the comparison very well
19:23:55 <ddarius> constructor is consistent with type constructor no?
19:24:24 <monochrom> I suppose
19:25:40 <wli> ddarius: I'm not sure how that goes. Is the state all aggregated, or StateT s transformers nested for varying types s, or what?
19:26:12 <ddarius> wli: Usually you can, and might as well, aggregate the state.
19:27:22 <wli> ddarius: Okay, I specifically wanted to avoid that.
19:29:03 <wli> (mostly because I'm so confused already as to what's what that keeping things very very separate helps me)
19:29:55 <wli> I have no idea how/why the fundep bits work but I'm going to write it off as magic for the time being until I'm more ready to approach it.
19:30:20 <wli> Plain old monads are giving me enough trouble as things stand.
19:31:03 <sorear> mauke_: It has documented concrete syntax for kinds, but it doesn't have any kind-related productions in the grammar.  http://haskell.org/onlinereport/decls.html#sect4.1.1
19:31:04 <lambdabot> Title: The Haskell 98 Report: Declarations
19:32:26 <dons> ?users
19:32:26 <lambdabot> Maximum users seen in #haskell: 382, currently: 324 (84.8%), active: 15 (4.6%)
19:32:48 <ddarius> 382?
19:32:53 <ddarius> When are all these people on?
19:33:19 <monochrom> That is magic.
19:33:27 <shapr> Yeah, when did 382 happen?
19:33:34 <dons> 2 nights ago
19:33:41 <dons> it was 10 up on the 372 the night before
19:34:00 <sorear> Do we even need kinds?
19:34:12 <dons> we need /more/ kinds!1
19:34:35 <monochrom> The GHC manual explains why we need kinds.
19:34:40 <allbery_b>  @kind #haskell
19:34:57 <Pseudonym> We also need unkinds.
19:35:12 <mauke_> gcc -malign-double
19:35:15 <ddarius> Yes! We need many many more unkinds.
19:35:19 <dons> aka `meanies'
19:35:25 <Pseudonym> mauke: Good point!
19:35:31 <Pseudonym> Doubly malign.
19:35:40 <monochrom> We need to be unkind and say RTFM.
19:35:43 <geezusfreeek> we need kind algebra, obviously
19:39:38 <LoganCapaldo> you got to be cruel to be kind
19:40:20 <Pseudonym> In the right measure.
19:43:40 <wli> Ugh, I need to re-export instances somehow.
19:44:04 <sorear> wli: It's very easy.  Indeed, there is no way to not do it
19:44:13 <wli> Okay...
19:45:35 <wli> I'm still losing on this mutual module recursion front.
19:46:22 <sorear> yeah, GHC supports it badly
19:46:42 <sorear> badly enough that I'm not suprised you have to tell it about instances
19:47:02 <sorear> @go ghc trac mkWWcpr
19:47:04 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/445
19:47:04 <lambdabot> Title: #445 (panic! mkWWcpr: not a product) - GHC - Trac
19:47:48 <sorear> years-old reproducable 'impossible' bugs.  usually a good sign that the feature in question is poorly supported :)
19:49:35 <sorear> I seem to have actually wanted http://hackage.haskell.org/trac/ghc/ticket/930
19:49:36 <lambdabot> Title: #930 (ghc-6.6: panic! (the 'impossible' happened) mkWWcpr: not a product GHC-Bri ...
19:53:14 <tyoc> Hi there, each time I try to enter an example that has type or data in hugs or ghci I get an error, Im reading the following: http://www.haskell.org/tutorial/goodies.html
19:53:15 <wli> Okay, that's the trick. Break off the actual class defs into their own separate modules, the mutually-recursive instances into another, then the real modules just re-export the stuff from the class def modules and the mutually-recursive instance module.
19:53:15 <lambdabot> Title: A Gentle Introduction to Haskell: Values and Types
19:53:44 <dcoutts> jfredett: you realise you has too login to code.haskell.org via ssh to init the darcs repo right?
19:53:58 <wli> And the mutally-recursive instance module imports the private class def modules.
19:54:30 <dcoutts> jfredett: and thereafter you can push and pull via jfredett@code.haskell.org:/srv/code/HFA/
19:54:33 <ddarius> tyoc: You can't enter them into the interpreter.  You must put them in a file and load the file.
19:55:00 <wli> That should really be fixed up at some point... not that I'm competent to do so.
19:55:08 <tyoc> I see, then, to what extend I can use directly the interpreter?
19:56:13 <ddarius> tyoc: You can evaluate expressions.  In GHCi at least, you can also bind values/functions locally as if the code you were entering was in a do-block.
19:56:50 <tyoc> mmm, I see, then interpreters != load from file
19:56:54 <ddarius> e.g. you can do stuff like 's <- readFile "foo" <Enter> let ls = lines s <Enter> mapM_ print ls
19:57:20 <chessguy> so, in using parsec, i can do something like this:
19:57:22 <chessguy> simple :: Parser Char
19:57:22 <chessguy> simple  = letter
19:57:30 <mm_freak> let f be of type (Int -> Int), then why is "f 3 4" of infinite type?
19:57:47 <ddarius> You can load files in either with :l File.hs, you just can't "interactively" enter data, type, class, instance declarations.
19:57:54 <mauke> > let f :: Int -> Int; f = undefined in f 3 4
19:57:55 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Int'
19:58:05 <chessguy> and if i run that parser on a string, it will try to match the first character of the string as a letter, consume it, and return it?
19:58:09 <tyoc> ddarius: OK, I will take the note
19:58:25 <mm_freak>     Occurs check: cannot construct the infinite type: a = a -> a
19:58:25 <mm_freak>     Probable cause: `fac' is applied to too many arguments
19:58:48 <tyoc> ddarius: those are the only "restrictions" of the interactive interpreter?, or they are more that I should be aware?
19:58:55 <mauke> > let f :: (Num a) => a -> a; f = undefined in f 3 4
19:58:56 <lambdabot>   add an instance declaration for (Num (t -> a))
19:58:56 <lambdabot>     In the expression:
19:58:56 <lambdabot>      ...
19:59:25 <ddarius> tyoc: There are no doubt more.  Basically it's easiest to say that you can only enter expressions, no declarations of any kind.
19:59:38 <tyoc> ddarius: thx again
19:59:39 <mm_freak> mauke: that's not my question
19:59:50 <mm_freak> what is an "infinite type"?
19:59:50 <ddarius> :t let f x = f 3 5 in f
19:59:52 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
19:59:52 <lambdabot>     Probable cause: `f' is applied to too many arguments
20:00:01 <ddarius> mm_freak: Exactly what it says.
20:00:34 <ddarius> E.g. in your example if a = a -> a then a = a -> a = (a -> a) -> (a -> a) = ...
20:00:49 <mm_freak> ah ok, that makes sense
20:00:54 <mm_freak> thank you
20:04:37 <jfredett> dcoutts I tried ssh'ing, but hmm, i dont think i had the part after the : right
20:04:43 <jfredett> let me try it now
20:06:38 <jfredett> dcoutts: right, so I must be doing something stupid (I'm just a lowly mathematician, all this ssh stuff is confusing) here's what I'm doing:
20:06:38 <jfredett> ssh jfredett@code.haskell.org:/srv/code/HFA
20:06:49 <jfredett> and it says "name or service not known"
20:07:23 <jfredett> obviously I can't ssh into code.haskell.org directly, but it does find the server when i try (it asks for a password
20:08:00 <dons> you can't ssh with a path, afaik.
20:08:19 <aii> dons: were you involved with hIDE?
20:08:24 <dons> yep
20:08:25 <monochrom> scp ?
20:08:30 <jfredett> thats what I thought, but i'm not good at all this storage stuff, my revision control system is a pencil and a notebook
20:08:37 <aii> dons: i've got it to compile, and almost to run
20:08:48 <dons> nice, aii. what were you thinking of doing with it?
20:09:11 <ddarius> Speaking of which, I have exercises to do.
20:09:14 <dons> its abandoned, I guess you know, in favour of shim/yi
20:09:25 <aii> dons: first i want to see it in action :)
20:10:22 <SamB> aii: I had it running once
20:10:26 <monochrom> if you are trying to interact with a remote revision control system, you don't use ssh directly. you use the revision control software. (it will call ssh.)
20:10:44 <SamB> but it wasn't much more impressive than something I could have made in glade!
20:10:57 <SamB> (or VB anyway)
20:11:11 <SamB> (with very little code)
20:11:24 <jfredett> monochrom: hmm *tries*
20:11:52 <jfredett> nope, darcs doesn't seem to like that much
20:13:19 <monochrom> too many factors
20:13:24 <jfredett> hmm
20:13:33 <SamB> jfredett: darcs push doesnt work?
20:13:38 <monochrom> sherlock holmes would figure it out, by pure deduction
20:13:44 <jfredett> SamB, the repo isn't init'd
20:13:50 <SamB> darcs put!
20:13:52 <jfredett> Oleg would figure it out, in the Type system
20:14:01 <jfredett> SamB: tried that
20:14:41 <jfredett> "can't put to a url" maybe if i try it w/ ...
20:14:55 <SamB> you should read the documentation
20:14:57 <jfredett> heeey
20:15:01 <jfredett> i think--
20:15:02 <SamB> to find out how to write SSH paths
20:15:04 <jfredett> think++
20:15:07 <jfredett> Damnit!
20:15:11 <jfredett> it wants a passwor
20:15:11 <jfredett> d
20:15:16 <jfredett> i dont _have_ a password
20:15:17 <jfredett> :/
20:15:27 <SamB> um. did you leave out the username?
20:15:32 <jfredett> oh!
20:15:35 <jfredett> i'm an idiot
20:16:00 <jfredett> its cranking :
20:16:01 <jfredett> :/*
20:16:08 <jfredett> nope, still wants a password
20:16:36 <SamB> huh
20:16:43 <SamB> so did you use the usual domain names?
20:16:47 <SamB> er. name
20:17:15 <jfredett> no- it fails w/ http stuff, I used "jfredett@code.haskell.org:/srv/code/HFA"
20:17:21 <jfredett> well, darcs put to that
20:17:34 <jfredett> err (darcs put) $ that, anyway
20:17:57 * wli moves along with type inference.
20:19:20 <jfredett> i must just be missing something simple
20:19:44 <SamB> and ssh jfredett@code.haskell.org works?
20:20:11 <jfredett> in the sense that it doesnt spit an error at me
20:20:24 <jfredett> i cant _do_ anything w/ it
20:20:32 <jfredett> it asks for a password
20:20:59 <jfredett> but i can look at the nice "Password: <blinking cursor>" bit
20:21:35 <Tac-Tics> someone needs to make a Lambda coffee mug.
20:21:42 <jfredett> maybe the password is just blank, i dont think i've tried that yet. :/
20:21:47 <jfredett> nope
20:22:06 <LoganCapaldo> just cause the password prompt is there doesn't mean its a real user either
20:22:28 <LoganCapaldo> just saying
20:22:43 <LoganCapaldo> maybe its jfredet or something
20:22:50 <jfredett> maybe
20:23:25 <Korollary> I'm sure there have been lambda coffee mugs
20:23:28 <ddarius> Tac-Tics: I would be surprised if someone hasn't.
20:23:35 <jfredett> nope, good idea though, LoganCapaldo
20:23:40 <jfredett> ?seen dcoutts
20:23:40 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 29m 10s ago.
20:24:59 <wli> I seem to need some analogue of local
20:28:32 <Tac-Tics> If only Haskell sold coffee mugs in their store
20:28:39 <Tac-Tics> the monad t-shirts are kinda neat
20:28:51 <Tac-Tics> but nothing say 'nerd' like a lowercase lambda
20:29:12 <jfredett> nothing says "haskell nerd" like a \ ...
20:30:04 <Tac-Tics> heh
20:30:13 <jfredett> :)
20:32:06 <jfredett> can you have a lambda function of no arguments? or does that violate some rule I'm unaware of
20:32:14 <jfredett> eg (\ -> "bot")
20:32:16 <jfredett> or something
20:32:27 <ddarius> jfredett: No, you can't.  There's no reason to at the Haskell level.
20:32:34 <jfredett> i suppose you could just write \x -> "bot"
20:32:39 <jfredett> hm
20:32:49 <bsmntbombdood> just use the value instead
20:32:51 <ddarius> jfredett: \ -> "bot" would be just "bot"
20:32:55 <jfredett> ddarius: granted, but i was curious if it were possible somewhere
20:32:57 <ddarius> \x -> "bot" is something else.
20:33:04 <jfredett> thats true
20:33:22 <jfredett> i guess i was asking a more general question about lambda calculus
20:33:30 <cdsmith> jfredett: there is no difference between a function of 0 args and a value.
20:33:36 <jfredett> right-
20:33:42 <ddarius> jfredett: For the lambda calculus there is only single argument lambdas.
20:33:48 <cdsmith> jfredett: in lambda calculus as well, there is no such thing as a 0-arg function
20:33:53 <jfredett> hmm
20:33:55 <ddarius> For other languages, e.g. Scheme, there are nullary lambdas.
20:34:19 <jfredett> right- because of side effects
20:34:19 <jfredett> (lambda () (set! x 4))
20:34:22 <jfredett> or something like that
20:34:29 <Tac-Tics> \() -> x
20:34:32 <jfredett> it's been a while since I've used scheme
20:34:32 <Tac-Tics> nullary!
20:34:38 <bsmntbombdood> scheme wins
20:34:42 <cdsmith> jfredett: It's useful for Scheme because of applicative order evaluation.  No need in Haskell
20:35:02 <jfredett> cool
20:35:30 <ddarius> Also, you could view Scheme as taking "tuples" in which case the nullary case does become something like \() -> ...
20:36:03 <jfredett> yeh
20:36:07 <Tac-Tics> Haskell doesn't really make a distinction between values and functions anyway
20:36:13 <Tac-Tics> it doesn't need nullary functions
20:36:19 <Tac-Tics> well
20:36:20 <jfredett> true that
20:36:23 <Tac-Tics> no one needs nullary functions
20:36:28 <Tac-Tics> a pure nullary is a constant
20:36:35 <LoganCapaldo> nullary functions what's your function?
20:36:40 <bsmntbombdood> the syntax doesn't allow calling a nullary function
20:36:49 <jfredett> lol
20:36:50 <Tac-Tics> LoganCapaldo: .....
20:36:51 <Tac-Tics> haha
20:36:58 <cdsmith> Tac-Tics: unless, of course, you've got eager evaluation, in which case nullary function affect evaluation order.
20:37:00 <jfredett> *hums the rest of the tune*
20:37:02 <LoganCapaldo> having no inputs and producing an output
20:37:05 <ddarius> Impressive rhyme.
20:37:20 <LoganCapaldo> isn't it not a rhyme if its the same word?
20:37:30 <LoganCapaldo> I thought the same word broke the rules of rhyming
20:37:39 <jfredett> you can't rhyme function with function
20:37:40 <ddarius> Impressive observation skills as well.
20:37:43 <cdsmith> LoganCapaldo: yeah, that's what they told me in Kindergarten anyway
20:37:49 <Tac-Tics> LoganCapaldo: in the same way 1 is a divisor of all numbers... that doesn't make it prime ;-)
20:38:18 <jfredett> 1 is totally prime, and x/0 is nullity, and therefore math is all bad evilness by communist nazis
20:38:22 <jfredett> hail the time cube
20:38:23 <LoganCapaldo> I'm sensing some sarcasm
20:38:27 <jfredett> ...
20:39:29 <Tac-Tics> Math, my dear boy, is merely the Lesbian sister of biology
20:39:41 <cdsmith> ?
20:39:45 <jfredett> ...
20:39:51 <Tac-Tics> sorry, FG is on right now
20:39:55 <mauke> "Nicht alles, was hinkt, ist ein Vergleich."
20:40:17 <LoganCapaldo> @translate "Nicht alles, was hinkt, ist ein Vergleich."
20:40:17 <lambdabot> Unknown command, try @list
20:40:20 <LoganCapaldo> ah well
20:40:31 <LoganCapaldo> @go translate:"Nicht alles, was hinkt, ist ein Vergleich."
20:40:32 <lambdabot> No Result Found.
20:40:35 <cdsmith> Hey, that'd be cool.  Who wants to write a lambdabot plugin?
20:40:59 <Tac-Tics> @go translate:ハスケル
20:41:06 <jfredett> that would be cool, but not me, i've got enough problems. :/
20:41:08 <lambdabot> http://www.fastwave.gr.jp/diarysrv/arino/200205c.html
20:41:15 <jfredett> dumb old darcs doesnt want to work
20:41:15 <jfredett> :/
20:42:01 <LoganCapaldo> I;m thinking it loses something in (mechanical) translation
20:42:10 <LoganCapaldo> Everything that limps, is not a comparison.
20:42:30 <ddarius> cdsmith: There is a lambdabot plugin.
20:42:45 <cdsmith> ddarius: for translation?
20:42:49 <ddarius> Yes.
20:42:55 <monochrom> You can rhyme function with junction.
20:42:58 <cdsmith> Oh, nice!
20:43:04 <ddarius> monochrom: Indeed you can.
20:43:28 <LoganCapaldo> what about function and truncheon ?
20:43:34 <monochrom> This bipolar junction / runs my Haskell function
20:43:39 <jfredett> function and luncheon?
20:44:01 <cdsmith> monochrom: Yes, when I was a kid, I'd watch this show on public television with the song lyrics "conjunction junction, what's your function?  Puttin' words together at my every unction.", or something like that.
20:44:15 * jfredett sings: "while I eat my food, yah eat my luncheon..."
20:44:16 <LoganCapaldo> My function is to muncheon food during the luncheon
20:44:25 <ddarius> cdsmith: You and every other child from about the seventies on.
20:44:42 <cdsmith> ddarius: Ah, so you know the song?
20:44:44 <jfredett> bipolar junction (come on!) whats your function!
20:44:56 <jfredett> you run this haskell function!
20:45:08 <monochrom> Look what I started.
20:45:09 <ddarius> @google "School House Rock"
20:45:11 <lambdabot> http://www.school-house-rock.com/
20:45:11 <lambdabot> Title: Schoolhouse Rock Site -The School House Rock Site
20:45:37 <jfredett> and eighties, i watch SHR too
20:45:38 <jfredett> :)
20:45:41 <jfredett> watched*
20:45:45 <jfredett> i'd still watch it though
20:45:48 <jfredett> it was awesome
20:46:26 <cdsmith> I just know it's hard to explain to people at bars why I'm humming that tune.
20:46:27 <jfredett> http://www.schoolhouserock.tv/ -- lyrics
20:46:29 <lambdabot> Title: Schoolhouse Rock Lyrics
20:46:31 <LoganCapaldo> 80s is "on" from th seventies
20:46:35 <jfredett> lol
20:47:01 <cdsmith> And now I'll be humming it again for the next three months or so.
20:47:02 <ddarius> cdsmith: I don't think I could find someone in person who hasn't seen that.
20:47:26 <ddarius> Maybe if they are 50+
20:47:26 <LoganCapaldo> But who's seen Donald Duck in mathamagic land?
20:47:27 <jfredett> > let onfrom x y = x > y in 80 `onfrom` 70
20:47:33 <lambdabot>  True
20:47:34 <ddarius> LoganCapaldo: I have.
20:47:46 <jfredett> yep, haskell confirms, 80's is on from the 70's
20:47:53 <LoganCapaldo> best disney cartoon ever :-p
20:47:59 <Tac-Tics> LoganCapaldo: I've seen it
20:48:05 <jfredett> lol, i dont think i have
20:48:38 <monochrom> I hope it doesn't cover category theory.
20:48:47 <jfredett> http://www.schoolhouserock.tv/Conjunction.html
20:48:49 <lambdabot> Title: SchoolhouseRock - Conjunction Junction
20:48:54 <LoganCapaldo> square roots
20:48:56 <LoganCapaldo> tee hee
20:49:08 <jfredett> "Donald! This is a closed cartesian category! and this is an Endofunctor"
20:49:16 * jfredett in donald voice: "Whaaa?"
20:49:34 <ddarius> monochrom: That would have been interesting.
20:49:43 <LoganCapaldo> http://youtube.com/watch?v=CNFOvOJZoWw
20:49:52 <Pseudonym> http://www.youtube.com/watch?v=53FpPUZLXGg
20:50:01 <monochrom> God help us!
20:50:41 <Tac-Tics> tictactoe!
20:50:57 <Tac-Tics> Math is the coolest useless subject evar
20:51:17 <jfredett> Math is _not_ useless.
20:51:22 * jfredett glares.
20:51:22 <Tac-Tics> not all of it
20:51:25 <Tac-Tics> ^^
20:51:28 <Pseudonym> Only the best bits.
20:51:36 <monochrom> Homo sapiens is the most useless species ever.
20:51:38 <jfredett> all of it is useful, its just underappreciated
20:51:43 * jfredett hugs his math
20:52:45 <sfultong> without eggheads, there would be no music
20:52:57 <Tac-Tics> http://en.wikipedia.org/wiki/Hairy_ball_theorem
20:52:57 <lambdabot> Title: Hairy ball theorem - Wikipedia, the free encyclopedia
20:53:02 <Tac-Tics> best theorem ever
20:53:12 <jfredett> and without dipshits pretending to be eggheads, we wouldn't have pop music. :/
20:53:45 <jfredett> How old are you, Tac-Tics, 13? ... that said, it is pretty funny...
20:53:53 <Tac-Tics> I'm 22
20:53:54 <cdsmith> I think that spirit talking to Donald Duck is claiming that the natural frequency of a string depends only on its length.  Nonsense.
20:54:00 <jfredett> same thing
20:54:00 <jfredett> :P
20:54:12 <jfredett> cdsmith: its frakking disney
20:54:18 <jfredett> not MIT.
20:54:22 <jfredett> its okay
20:54:24 <jfredett> lol
20:54:25 <sfultong> man... I was hoping jfredett's visualization of this video was real :(
20:54:32 <jfredett> lol
20:54:36 <jfredett> it would be awesome
20:54:40 <cdsmith> Oh, so lying to children is okay.  </sarcasm>
20:54:40 <sfultong> yeah, it would
20:54:45 <Pseudonym> BTW, there's a 3D analogue to the hairy ball theorem, that every storm in a teacup has an eye.
20:54:46 <jfredett> cdsmith: absolutely
20:54:54 <Pseudonym> (Assuming the teacup handle isn't hollow.)
20:54:58 <jfredett> which is why we must teach Creationis- i mean ID in schools
20:55:36 <jfredett> because lying to kids from an early age prepares them for the real world
20:55:41 <jfredett> will they will be lied to all the time
20:55:42 <cdsmith> good point
20:55:48 <Pseudonym> We lie to kids all the time.
20:55:51 <wli> Christianity is just immoral.
20:56:01 <Pseudonym> My high-school physics teacher taught me about... Newtonian mechanics!
20:56:05 <Pseudonym> It's all lies, I tell you!
20:56:09 <Tac-Tics> Anyone who believes in ID doesn't realize how cool the world is
20:56:23 <jfredett> teach kids not to take bullshit when there young, by forcefeeding it to them while there young
20:56:29 <Tac-Tics> loL
20:56:32 <Pseudonym> wli: Even if that were true, it's a non sequitur.  Most of Christianity thinks ID is crap.
20:56:32 <wli> Pseudonym: My high school physics teacher taught me about matrix exponentiation and generalized eigenvectors.
20:56:43 <Pseudonym> wli: You had a cool teacher, clearly.
20:56:44 <sfultong> yeah... all the science you learn in school... you later realize is just special cases of much more interesting things
20:56:51 <sfultong> and math, too
20:56:56 <cdsmith> I liked when the Catholic Church made a statement that was basically: we won't comment on the science, but ID is bad theology.
20:56:57 <jfredett> i was homeschooled, so i just kindof read stuff
20:57:01 <mauke> http://www.youtube.com/watch?v=g-9Tho7a4TI
20:57:21 <sfultong> nice! I was homeschooled for a while, but then my parents thought I wasn't being productive enough, so I went back to school :(
20:57:25 <Pseudonym> In "The Science of Discworld", they point this out.  They refer to "lies to kids, or as you know it better, education".
20:57:27 <dibblego> jfredett, were you ever taught where to use there, their or they're?
20:57:36 <sfultong> public education should be abolished
20:57:42 * wli is baffled by his analogue of local.
20:57:51 <jfredett> dibblego: yes, i know the difference between them, i just dont care
20:57:57 <Pseudonym> American public education shoudl be abolished.
20:58:02 <wli> sfultong: There is no future anyway, so I don't concern myself with such things.
20:58:03 <Pseudonym> Everywhere else in the developed world, it's fine.
20:58:06 <jfredett> whatever my fingers type is what ends up in IRC
20:58:16 <sfultong> wli: I like your outlook
20:58:30 <dibblego> that's funny; transferring responsibility to your fingers
20:58:33 <Pseudonym> Apart from some places in the UK.
20:58:37 <dibblego> Christians do that :)
20:58:37 <sfultong> english is a silly language anyway
20:58:44 <jfredett> when i write papers, they're fully correct in their use of there, their, and they're
20:58:54 * sfultong wishes he knew a better language than english
20:58:57 <LoganCapaldo> later the spirit of dventure teaches donald to play pool
20:59:01 <Pseudonym> dibblego: Catholics don't transfer ANY responsibility to their hands.
20:59:05 <jfredett> sfultong: I speak ishkabobel fluently
20:59:10 <Pseudonym> And shame on you for suggesting it.
20:59:15 <Tac-Tics> 英語はかっこよくない言語だな
20:59:41 <dibblego> Pseudonym, "it wasn't me, it was my penis who did it! honest!"?
20:59:58 * wli tries to come up with a definition of envLocal that isn't obviously looping.
21:00:04 <Pseudonym> dibblego: I have NO idea what you're referring to.
21:00:10 <Pseudonym> Maybe it's because I'm not Catholic.
21:00:15 * jfredett notes that wli is the only one who's even mildly on topic
21:00:18 <dibblego> Pseudonym, never mind
21:00:22 <cdsmith> Hmmm.  The quality of conversation seems to be going downhill.  I apologize for my part in it.
21:00:25 <jfredett> so how 'bout them mo-nads?
21:00:28 <Pseudonym> Me too.
21:00:32 <dibblego> I retract
21:00:38 <Pseudonym> We can continue this on #haskell-blah
21:00:41 <Pseudonym> Or just drop it.
21:00:45 <Pseudonym> I vote for the latter.
21:00:48 <Pseudonym> So yeah, how about that Haskell.
21:00:54 <Pseudonym> Lambda calculus, cool stuff.
21:00:55 <Tac-Tics> Poll: What is your favorite monad?
21:01:02 <jfredett> I say we all talk about kittens.
21:01:07 <cdsmith> Tac-Tics: definitely STM
21:01:08 <jfredett> the little demons.
21:01:09 <Tac-Tics> Kitten Monad?
21:01:11 <Pseudonym> I vote for NondetT
21:01:11 <jfredett> yes
21:01:27 <jfredett> I like Maybe, but I'm nuts like that
21:01:31 <Tac-Tics> what is STM monad?
21:01:39 <wli> Well, the trouble with the Abrahamic religions and morality is essentially that it's impossible for them to be moral for its own sake with the carrot/stick system of Heaven and Hell involved.
21:01:40 <cdsmith> software transactional memory
21:01:44 <wli> woops
21:01:48 <wli> meant for #haskell-blah
21:02:00 <jfredett> oh- that hurt.
21:02:11 <dolio> I like CC, lately.
21:02:13 <wli> Anyway, the monad transformer affair is too long even for hpaste.
21:02:18 <Tac-Tics> Poll: What is your favorite binding operator? forall, thereexists, or lambda?
21:02:18 <jfredett> note to self, chair higher up from floor than previously assumed.
21:02:25 <wli> How's Oleg's LogicT coming along?
21:02:33 <jfredett> I like lambda, ayup
21:03:27 <dolio> I haven't done anything with it in a while.
21:03:33 <cdsmith> Tac-Tics: I like mu, as in minimization from partial recursive functions.
21:03:37 * ddarius takes \Pi.
21:03:44 <Tac-Tics> oh, mu eh? never heard of it
21:04:06 <Tac-Tics> *wikis*
21:04:24 <cdsmith> \mu x . x + 5 > 3 == minimum value of x such that x + 5 > 3
21:04:32 <ddarius> cdsmith: That mu is not that interesting.
21:04:43 <Tac-Tics> what is there is no solution?
21:04:49 <cdsmith> ddarius: oh?  And you want what, least fixed point?
21:04:54 <jfredett> I like Mu, as in the unasking of a question, but thats not really a binding operator
21:04:57 <Tac-Tics> what is \mu x . x < 0 for x in N?
21:05:36 <cdsmith> Tic-Tacs: undefined.  In fact, mu is how recursive functions get to be partial.  If there's no mu, the function is total.  If there is, it can be partial.
21:05:40 <ddarius> cdsmith: That is related to something that subsumes the other, so might as well.
21:06:06 <jfredett> so in \mu x . x + 5 > 3 == -2 + eps?
21:06:15 <jfredett> eps = epsilon
21:06:35 <cdsmith> Oh yeah, I guess that was a bad example, huh?  It's undefined, too.
21:06:39 <ddarius> jfredett: They're all on N.
21:06:43 <jfredett> ah
21:06:59 <jfredett> so \mu x . x + 2 < 4 == 1
21:07:09 <jfredett> or 0
21:07:14 <jfredett> i suppose that'd do too
21:07:14 <jfredett> :/
21:07:15 <cdsmith> Depends on your definition of N
21:07:28 <jfredett> lets say N = N union {0}
21:07:30 <Tac-Tics> Poll: 0-based N or 1-based?
21:07:48 <jfredett> I like 0 based, but I'm no math maj -- wait- yes i am. :)
21:07:56 <Tac-Tics> I like 0 better
21:08:01 <jfredett> they're equivalent though, right?
21:08:12 <Tac-Tics> sometimes things are good enough to have nonzero discrete quantity
21:08:19 <jfredett> I mean- lacking the additive identity is a bitch, sure- but they work out to be the same bits
21:08:26 <cdsmith> I like 0 better, but I'm reading an analysis book now that uses 1 and pounds it into you a lot, so I'm adjusting. :(
21:08:37 <wli> http://holomorphy.com/~wli/MonadCounter.lhs.txt
21:08:45 <wli> http://holomorphy.com/~wli/MonadEnviron.lhs.txt
21:08:48 <Tac-Tics> jfredett: they are isomorphic. not exactly equivalent, but you can make your recursive function definitions work with either
21:08:51 <wli> http://holomorphy.com/~wli/Instances.hs.txt
21:09:02 <wli> Those 3 have the things going on.
21:09:07 <jfredett> I just got TaPL the other day for my birthday, :)
21:09:17 <wli> envLocal in Instances.hs is where I'm having trouble now.
21:09:19 <cdsmith> jfredett: cool!  Have fun.
21:09:25 <jfredett> it looks interesting
21:09:31 <jfredett> i got a bunch of other Haskell books too
21:09:48 <jfredett> and Principia Mathematica (russel and whitehead, not newton)
21:10:02 <Tac-Tics> heh
21:10:08 <Tac-Tics> I want a copy of Principia
21:10:10 <Tac-Tics> oh
21:10:12 <jfredett> the abridged version, anyway
21:10:17 <cdsmith> jfredett: Last time I tried to buy a copy of Principia, Amazon wanted $600 for it!
21:10:27 <Tac-Tics> Poll: is Principia pronounced "prin-sip-ea" or "prin-kip-ea"?
21:10:35 * Pseudonym has a copy of Newton's Principia
21:10:36 <jfredett> my girlfriend promised to get me a copy of the full version when I get my PhD, :)
21:10:42 <wli> There are better books to get, basically because it's not all that relevant to anything happening nowadays.
21:10:43 <cdsmith> It's not pronounced.  Geeks only type.
21:10:44 <Tac-Tics> wtf cdsmith? it should be like 20$ softcover X-D
21:10:45 <jfredett> Principia, methinks
21:10:52 <hpaste>  thecrypto pasted "WSGIish Haskell Webserver" at http://hpaste.org/2049
21:11:02 <jfredett> Tac-Tics: thats the abridged version
21:11:06 <jfredett> which is PM to the 56
21:11:14 <jfredett> and wli, maybe its irrelevent now
21:11:19 <jfredett> but it was an important bit of work
21:11:23 <Tac-Tics> orly?
21:11:29 <Tac-Tics> hehe
21:11:49 <Tac-Tics> Principia is overrated anyway. It can't even prove its own consistency!
21:11:50 <wli> I seem to have the wrong monad involved somewow.
21:12:28 <jfredett> Tac-Tics: neither can anything else, but thats besides the point
21:12:29 <jfredett> :/
21:12:31 <cdsmith> http://www.amazon.com/Principia-Mathematica-Russell-Bertrand-Whitehead/dp/B000J2O2E4/  $500 now
21:12:34 <lambdabot> http://tinyurl.com/22rfj5
21:12:50 <jfredett> yeh, thats because PM is like-- 3 volumes
21:12:56 <jfredett> at 1k pages a peice, or something
21:12:58 <cdsmith> Tac-Tics: yeah! :)
21:13:05 <jfredett> they sell it as one big book now
21:13:09 <Tac-Tics> hah, that's where you guys are wrong
21:13:14 <Tac-Tics> Goedel can stop arithmetic
21:13:17 <Tac-Tics> but not..... ID!!!!
21:13:20 <jfredett> ...
21:13:25 <jfredett> not this again
21:13:33 <jfredett> :/ I'm sorry i started the whole ID bit.
21:14:00 <wli> The outer monad should be EnvironT so I don't see why lift isn't working.
21:14:07 <Tac-Tics> Goedel showed to do math, you need to have faith in it
21:14:28 <ddarius> Goedel is dead.
21:14:41 <monochrom> haha
21:14:45 <Tac-Tics> yes, most people are
21:15:08 <lament> "When Mozart was my age, he was long dead, so clearly i'm doing much better"
21:15:16 <Tac-Tics> hehe
21:15:18 <monochrom> ubermathematician
21:15:35 <Tac-Tics> Most people are dead in the same way most reals are undefinable
21:15:36 <monochrom> but I digress
21:16:10 <monochrom> most programs diverge in the same way most people are dead
21:16:32 <bos> in the long run, we all reduce to _|_
21:16:41 <monochrom> hehe
21:16:48 <Tac-Tics> _|_ is the purgatory of values
21:16:53 <cdsmith> I'm missing the point here.  Are we saying most people are dead, but the important ones aren't?  That doesn't sound right.
21:17:06 <Tac-Tics> it's better to go to hell...... undefined
21:17:29 <Tac-Tics> cdsmith: no, just most people, at least half of all people who ever lived are dead
21:17:55 <monochrom> cdsmith: nah. In the sense of density. Pick a "random" person or real number or program...
21:18:01 <cdsmith> Oh, I was just thrown by the "in the same way" comments
21:18:12 <Tac-Tics> I was still in math mode, sry
21:18:20 <cdsmith> i.e., most reals are not definable, but I only care about the ones that are.
21:18:54 <Tac-Tics> If you can't count it, most CS majors don't care about it
21:19:09 <monochrom> Oh. That may also be true. You probably pay most attention to your family and friends, who are still alive. :)
21:19:30 <Tac-Tics> and if you can't count it in under 20 seconds, a developer doesn't care about it
21:19:59 <ddarius> if you can't count it in under 3 seconds, lambdabot doesn't care about it
21:20:07 <monochrom> Hahahaha
21:20:09 <cdsmith> ddarius++
21:20:33 <monochrom> We are creating lambdabot jokes. :)
21:21:33 <bos> @seen dons
21:21:34 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 1h 12m 20s ago.
21:22:37 <wli> Instances.hs:17:4: Couldn't match expected type `monad' (a rigid variable) against inferred type `CounterT monad' `monad' is bound by the instance declaration at Instances.hs:11:0 Expected type: CounterT monad t Inferred type: CounterT (CounterT monad) t In the expression: lift $ (envLocal assocs action) In the definition of `envLocal': envLocal assocs action = lift $ (envLocal assocs action)
21:23:24 <ski> paste ?
21:23:41 <wli> ski: too long
21:23:54 <wli> ski: http://holomorphy.com/~wli/Instances.hs.txt
21:23:59 <ski> is it in a class member ?
21:24:02 <wli> ski: http://holomorphy.com/~wli/MonadCounter.lhs.txt
21:24:10 <wli> ski: http://holomorphy.com/~wli/MonadEnviron.lhs.txt
21:24:50 <wli> ski: http://holomorphy.com/~wli/MonadCounterClass.lhs.txt
21:24:54 <wli> ski: http://holomorphy.com/~wli/MonadEnvironClass.lhs.txt
21:25:20 <wli> ski: It is a class member.
21:31:06 <dons> bos?
21:31:12 <dons> i'm on my way out the door...
21:31:12 <wli> I'm completely baffled by whatever's going on with this monad transformer method.
21:31:38 <wli> ski: Are you looking?
21:32:20 <ski> which instance for 'MonadTrans' is derived for 'CounterT' ?
21:33:01 <bos> dons: no worries
21:33:17 <ski> hm, ought to be
21:33:19 <ski>   instance MonadTrans CounterT
21:34:06 <wli> ski: It derives MonadTrans in its newtype decl.
21:35:05 <ski> i see
21:35:08 <wli> ski: I am not entirely sure how its MonadTrans instance is derived apart from that it mysteriously typechecks, barring this hassle.
21:35:30 <wli> ski: http://holomorphy.com/~wli/MonadCounterClass.lhs.txt has the MonadTrans derivation.
21:35:39 <Tac-Tics> Does anyone have any cool ideas for something to hack in Haskell tonight?
21:35:44 <Tac-Tics> I did Brainfuck yesterday
21:35:56 <SamB> wli: it is derived by magic
21:36:06 <SamB> wli: it is entirely possible that it does something bogus
21:36:17 <wli> Tac-Tics: Try Prolog as a database query shell.
21:36:17 <SamB> sorear can tell you more about that ;-)
21:36:19 <ski> (btw, 'flip evalStateT 0 $ runCounterT c' can be written 'runCounterT c `evalStateT` 0')
21:36:51 <ski> deductive databases ftw !
21:36:59 <SamB> he implemented unsafeCoerce :: (a :: *) -> (b :: *) using that on my request ;-)
21:37:12 <SamB> (also some other extensions, though)
21:37:16 <Tac-Tics> wli: 1) what? 2) no seriously =-)
21:37:54 <SamB> Tac-Tics: maybe you're supposed to implement Prolog?
21:39:03 <ddarius> Tac-Tics: That actually would not be that hard.
21:39:11 <Tac-Tics> Prolog scares me, because I know to do perfectly what it sounds like it does requires exponential time
21:39:22 <wli> But it would be enlightening.
21:39:24 <SamB> Tac-Tics: so?
21:39:33 <Tac-Tics> ddarrus: you just use the List monad right?
21:39:35 <SamB> also... does it?
21:39:40 <wli> Tac-Tics: Add in breadth-first search vs. the usual depth-first strategy.
21:39:40 <ski> wli : if you remove the 'envLocal' member from the instance, does it complain about other members ?
21:39:45 <wli> ski: No.
21:39:52 <ddarius> Tac-Tics: As a query shell, you wouldn't even need to bother.
21:39:54 <wli> ski: envLocal is the only problem.
21:39:57 <Tac-Tics> actually, I only barely know how Prolog works at all
21:40:11 <Pseudonym> That's easy.  It doesn't.
21:40:18 <SamB> Pseudonym: it does something
21:40:22 <ski> you need unification, too
21:40:24 <Tac-Tics> surely, it does something
21:40:26 <Pseudonym> SamB: fail.
21:40:27 <SamB> mozilla used it for RDF stuff at one point
21:40:32 <Tac-Tics> obscure, weird things are usually good for something
21:40:34 <ddarius> SamB: no.
21:40:38 <Tac-Tics> it's the popular weird things that aren't
21:40:40 <Pseudonym> OK, let's be fair.
21:40:47 <Pseudonym> Prolog does exponential backtracking search.
21:40:50 <Pseudonym> That's about it.
21:40:55 <SamB> ah, see.
21:41:00 <SamB> that's definately something!
21:41:17 <wli> Tacs-Tics: Do the backtracking search breadth-first instead of depth-first.
21:41:20 <Tac-Tics> I should seriously sit down and learn prolog some time
21:41:28 <ddarius> Tac-Tics: Yes you should.
21:41:43 <wli> I liked Mercury. Shame there are no more recent debs.
21:41:47 <ski> (beware of cuts !)
21:42:36 <Tac-Tics> http://en.wikipedia.org/wiki/Dedekind_cut cuts?
21:42:36 <lambdabot> Title: Dedekind cut - Wikipedia, the free encyclopedia
21:42:39 <wli> Anyway, there is something mysterious about envLocal confusing me.
21:42:48 <Pseudonym> wli: All the good people left the Mercury team.
21:42:54 <Tac-Tics> maybe I'll just write a lisp in haskell
21:42:55 <Tac-Tics> hmm
21:43:03 <Tac-Tics> or sleep. tomorrow's going to be a rough day for me
21:43:21 <Pseudonym> Hell, Tom and Fergus both ended up as Haskellers.  Fergus more briefly than Tom.
21:43:31 <Pseudonym> Fergus worked for Galois for a while.
21:43:39 <Pseudonym> And Tom has been spamming haskell-cafe lately.
21:44:13 <ddarius> Tom who?
21:44:19 <Pseudonym> Conway
21:44:22 <SamB> hey. I guess I uploaded two of the hundred-odd packages SPJ mentioned in part two of A Taste of Haskell
21:44:23 <ddarius> I remember Fergus Henderson.
21:44:31 <ddarius> Pseudonym: Okay.
21:44:32 <Pseudonym> Fergus is hard to forget.
21:44:41 <SamB> I should package that ordninal field access stuff up
21:44:46 <wli> How so?
21:45:00 <SamB> and send niel the deriving
21:45:21 <SamB> and, oh, get instances for the tuple types...
21:46:13 <ski> wli : no, i can't think of anything .. strange issue
21:47:43 <ski> (it shouldn't be a monomorphisc '($)' issue, since 'lift' doesn't take polymorphic argument)
21:48:51 <SamB> ski: doesn't it?
21:49:02 <SamB> :t lift (return 1)
21:49:05 <lambdabot> forall t (m :: * -> *) (t1 :: (* -> *) -> * -> *). (Num t, MonadTrans t1, Monad m) => t1 m t
21:49:12 <SamB> it sure looks like it does
21:50:39 <Tac-Tics> :t lift
21:50:41 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:51:54 <wli> lift $ envLocal assocs $ evalCounterT action
21:51:58 <wli> that typechecks
21:52:31 <ski> SamB : no rank-(n+2) polymorphism
21:52:55 <wli> The inner monad is confusing me.
21:53:19 <ski> argh, of course
21:54:37 <ski> envLocal (assocs :: [(key,value)]) (action :: CounterT monad t) :: CounterT monad t
21:55:16 <ski> lift (envLocal assocs (... :: monad t) :: monad t) :: CounterT monad t
21:55:41 <ski> 'action' doesn't fit into '...'
21:56:40 <dons> hey, HW paper list is up, http://www.cse.unsw.edu.au/~keller/haskellws/AcceptedPapers.html
21:56:40 <lambdabot> Title: Haskell Workshop 2007 - List of Accepted Papers
21:57:58 <ski> i wonder if 'tmap' would be appropriate for this
21:58:46 <RyanT5000> is there a way i can import Control.Monad.Error without importing the class Error or any of its instances?
21:58:59 <ski> wli : you get an arbitrary argument action in 'CounterT monad', but can only pass a 'monad'-action to the inner 'envLocal'
21:59:35 <ski> RyanT5000 : no, instances always get imported from an imported module (transitively, too, iirc)
21:59:38 <wli> ski: I don't understand.
21:59:54 <ski> you have
22:00:17 <ski> envLocal :: forall t. [(key,value)] -> CounterT monad t -> CounterT monad t
22:00:21 <ski> to define
22:00:38 <ski> envLocal assocs action = ...
22:00:49 <ski> assocs :: [(key,value)]
22:00:58 <ski> action :: CounterT monad t
22:01:09 <wli> ski: I don't understand why it cares what the inner monad is?
22:01:09 <ski> you want something like
22:01:37 <ski>   lift (...) :: CounterT monad t
22:01:37 <RyanT5000> ski: lame; i really, really don't want the instance Error e => MonadError e (Either e)
22:01:43 <ski> in the body, i.e.
22:01:52 <ski>   lift (... :: monad t)
22:02:22 <ski>   lift (envLocal (... :: [(key,value)]) (... :: monad t) :: monad t)
22:02:23 <RyanT5000> ski: well, maybe it won't be such a problem
22:02:32 <ski>   lift (envLocal assocs (... :: monad t) :: monad t)
22:02:36 <ski> but
22:02:41 <ski> action :: CounterT monad t
22:02:44 <wli> no scoped type variables
22:03:05 <ski> in the outer monad, so it doesn't fit into that last '...', which expects an action in the inner 'monad'-monad
22:03:25 <ski> (wli : just reasoning about the types of the subexpressions)
22:03:28 <dons> http://programming.reddit.com/info/2bx3d/comments:)
22:03:36 <dons> ` Unfolding abstract datatypes: proofs for stream fusion (pdf)'
22:03:48 <wli> I can't make heads or tails of this.
22:04:01 <ski> RyanT5000 : the best workaround i've done is to wrap 'Either' .. lame, yes
22:04:17 <ddarius> dons: Is this a new paper by Jeremy Gibbons?
22:04:43 <ski> wli : 'action' may be an action that calls your 'tick', i.e. updates the hidden 'Integer' state
22:04:55 <wli> ski: As intended.
22:05:28 <ski> wli : but the called 'envLocal' in your body doesn't allow that, it only allows actions in the underlying monad
22:05:44 <wli> ski: Crap.
22:06:00 <ski> there's a workaround
22:06:21 <dons> ddarius: yeah
22:06:23 <wli> local :: (MonadReader r m) => (r -> r) -> m a -> m a
22:06:26 <ski> hm, actually
22:06:32 <ski> the 'lift' must go
22:06:34 <ddarius> dons: Cool.
22:06:39 <wli> envLocal :: (MonadEnviron key value monad) => [(key, value)] -> monad t -> monad t
22:06:51 * SamB likes the way spj says you can go ahead and spam the front page of haskell.org if you like ;-)
22:06:53 <wli> ski: That definition just loops anyway.
22:07:14 * ddarius goes and spams the front page with links to haskell.org.
22:07:18 <bos> http://www.realworldhaskell.org/blog/2007/08/03/a-brief-haskell-at-oscon-trip-report/
22:07:19 <ski> 'lift' promises that the effects of the outer monadic layer (here 'CounterT') are trivial (i.e. no 'tick's), but 'action' might want to do 'tick's
22:07:20 <wli> ski: envLocal is defined the same damn way as local.
22:07:20 <lambdabot> Title: Real World Haskell  Blog Archive  A brief Haskell-at-OSCON trip report, http://tinyurl.com/2bk6m9
22:07:39 <wli> ski: Okay, so I need to do something hard.
22:07:56 <ski> @source Control.Monad.Reader
22:07:56 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
22:08:27 <ski> (wli : or something .. interesting :)
22:09:21 * SamB doesn't think SPJ actually knows much about pulling up nettles
22:09:29 * kfish considers patching lambdabot to just paste directly to reddit instead of tinyurl ;-)
22:09:39 <SamB> hahahaha
22:09:52 <geezusfreeek> ha
22:10:58 <dons> `Simon Peyton-Jones, my new programming hero' heh
22:11:01 <ski> @source Control.Monad.Lazy.State
22:11:01 <lambdabot> Control.Monad.Lazy.State not available
22:11:02 <dons> good work, bos!
22:11:48 <ski> @source Control.Monad.State.Lazy
22:11:48 <lambdabot> Control.Monad.State.Lazy not available
22:11:50 <SamB> last few years? last few months!
22:11:59 <ski> http://darcs.haskell.org/packages/mtl/Control/Monad/State/Lazy.hs
22:12:01 <ski> instance (MonadReader r m) => MonadReader r (StateT s m) where
22:12:02 <ski>     ask       = lift ask
22:12:02 <ski>     local f m = StateT $ \s -> local f (runStateT m s)
22:12:19 <ski> wli : there's basically your 'envLocal'
22:13:19 <ski> though that breaks the encapsulation
22:13:26 <ski> mayhaps something alike
22:13:31 <ski> mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
22:13:31 <ski> mapStateT f m = StateT $ f . runStateT m
22:13:39 <ski> would be nice ?
22:13:42 <SamB> hey, I use that strategy of "1) change datatype 2) type make" too ;-)
22:13:48 <ski> or perhaps even
22:13:55 <wli> ski: I'm desperate at this point.
22:14:05 <ski> class FunctorFunctor t
22:14:07 <ski>   where
22:14:34 <ski>   tmap :: (Functor f,Functor g) => (forall x. f x -> g x) -> t f a -> t g a
22:15:35 <ski> (maybe s/FunctorFunctor/MonadFunctor/ and s/Functor f,Functor g/Monad f,Monad g/ s/f/m/ s/g/n/ .. not sure if needed/wanted)
22:16:05 <SamB> hmm. nobody seems to have touched http://hackage.haskell.org/trac/ghc/ticket/1552 yet
22:16:06 <lambdabot> Title: #1552 (GHCi thinks large list literals impossible?) - GHC - Trac
22:16:13 <ski> wli : but do you see the basic problem, and the idea for solution (possibly ignoring the higher abstractions galore)
22:16:16 <ski> ?
22:16:40 <wli> ski: I'm mostly confused.
22:17:04 <ski> the basic point is that 'lift' is the wrong tool, here
22:17:29 <wli> I don't get it.
22:17:33 <ski> 'return x :: m a' returns an action that performs no actual 'm'-effects
22:18:09 <ski> 'lift (act :: m a) :: t m a' returns an action that may have 'm'-effects, but no actual 't'-effects
22:18:54 <ski> in your case, you want to run 'action :: CounterT monad t', which may have 'CounterT'-effects (i.e. running 'tick' some times)
22:19:08 <tyoc> is there a linux IDE?
22:19:21 <SamB> tyoc: what's an IDE?
22:19:39 <ski> if you wrap your whole body in 'lift', you promise that in this case you won't actually have any 'CounterT'-effects .. which means that you then can't run 'action', which you want
22:19:43 <tyoc> Integrated development environment
22:19:57 <tyoc> a editor + runn and test + debug?
22:20:09 <tyoc> save/load or manage "projects"
22:20:11 <wli> Hmm. It looks like CounterT is the outer monad here.
22:20:23 <ski> Isonitrile Divagate Extramorainal
22:20:39 <ski> wli : .. yes
22:21:32 <geezusfreeek> tyoc, emacs?
22:21:35 <tyoc> I see that there is a plugin for eclipse, but I only whant to see if there is another option (I have slow-bad experiences with C/C++ plugin for eclipse, thus I dont trust this environment)
22:21:58 <ski> wli : the whole problem stems from that 'envLocal' doesn't just return an action, but also take an action, i.e. it is a higher-order function / combinator
22:22:00 <tyoc> Im more used to "graphic" environments click and go, not type and go :)
22:22:52 <ski> .. and wanting to lift this requires you to, so to speak "lower" the argument, (without loosing its effects), (lowering because argument positions in function types are contravariant)
22:23:17 <wli> Well, I can't figure it out.
22:23:42 <ski> wli : so, the simplest version is to bite the bullet and directly use the 'CounterT' data constructor (and the 'runCounterT' deconstructor)
22:24:13 <wli> That's fine by me.
22:24:16 <ski> wli : look at the 'instance (MonadReader r m) => MonadReader r (StateT s m)' above .. 'local' there is basically the same as your situation
22:25:37 <wli> CounterT $ StateT $ \s -> envLocal assocs (runStateT (runCounterT action) s)
22:25:52 <ski> you need to grab the current state, pass it to your action so you get an underlying action returning result plus state, then pass *that* underlying action to the underlying 'envLocal', afterwards wrapping things up again
22:26:31 <ski> you can either do it explicitly by opening the constructors .. or maybe by using 'get','put'
22:26:54 <wli> ski: I'm fine with this.
22:26:58 <ski> wli : yes, that looks ok, i think
22:27:19 <ski> the down-side is that you need to expose 'CounterT' to do this
22:27:31 <wli> ski: No big deal to me.
22:28:17 <ski> .. my musings above about 'mapStateT' and 'tmap' was a possible way to do a more general operation, abstractly, that i think you then can do what you want without exposing innards (except to the general operation, of course)
22:28:22 <ski> ok
22:28:23 <wli> ski: I think the big problem was that I was confused about what the inner and outer monads were.
22:28:31 <ski> -m-
22:29:16 * ski 's seen this issue, with small variations, come up before here on #haskell
22:29:17 <wli> ski: This is going toward http://holomorphy.com/~wli/Easy.lhs.txt
22:29:30 <wli> ski: Also at http://holomorphy.com/~wli/Easy.lhs
22:29:32 <wli> ski: Also at http://holomorphy.com/~wli/Easy.pdf
22:30:26 <wli> Well, my brain has pretty much been pounded into mush for tonight. How about something Project Euler -ish? ;)
22:31:27 <wli> ski: If I ever get through this I'll finally have crossed the monadic interpreter bridge of asses.
22:33:14 <wli> ski: I needed the analogue of local for the Lambda case.
22:33:19 <ski> wli : 'instance Monad TypeExpr' is interesting .. do you use this ?
22:33:35 <wli> ski: Yeah, in the unification algorithm.
22:33:55 <wli> ski: unifyExpr uses it.
22:34:08 <ski>         = return return
22:34:12 <ski> i like that :)
22:34:49 <wli> ski: unify in turn uses the Monad instance on Type
22:35:36 <ski> 'TypeExpr' itym
22:35:41 <wli> ski: Basically in type variables these things have fmap, join, and return, so it's over.
22:35:56 <ski> if you s/fmap/liftM', you may remove the 'Functor' constraint
22:35:58 <wli> ski: Hmm, did I accidentally avoid using the Monad instance on Type?
22:36:35 <wli> ski: I don't care to remove the Functor constraint because the way I understand Monads is via fmap, join, and return.
22:36:58 <wli> ski: x >>= f = join $ fmap f x
22:37:47 <wli> ski: Basically there's an fmap, a canonical injection, and an isomorphism from monad (monad t) -> monad t
22:38:05 <ski> ('Monad' ought to subclass 'Functor' as we all know)
22:38:21 <ski> well
22:38:32 <ski> not iso
22:38:54 <wli> Okay, injective homomorphism, sorry.
22:38:56 <mauke> except the fmap is called liftM
22:38:57 <ski> eta : id -> monad
22:39:00 <SamB> ski: yeah. the other month I found that Language.Haskell.TH.Q lacked a Functor instance!
22:39:04 <ski> mu  : monad . monad -> monad
22:39:16 <mauke> x >>= f = join $ liftM f x
22:39:26 <SamB> so like the only point of not having Functor as a superclasss is to allow you to forget the instance
22:39:41 <SamB> so I don't see the point of that at all
22:39:49 <wli> liftM I only understand as fmap.
22:39:50 <ski> point of what ?
22:40:00 <SamB> not having it as a superclass
22:40:22 <ski> i think it has to do with problems with the default member system
22:40:32 <SamB> that's rubbish
22:40:40 <sjanssen> SamB: I agree
22:40:46 <SamB> not having Functor as a superclass doesn't make it any easier to implement!
22:40:48 <ski> we'd like 'Monad' to have a default definition for 'fmap' in superclass 'Functor', no ?
22:40:54 <SamB> yes!
22:41:01 <SamB> but we can't have a default method this way either
22:41:06 <SamB> so it's really rather a wash
22:41:08 <ski> true
22:41:10 <sjanssen> ski: it might be handy, but definitely not necessary
22:41:25 <SamB> so we should just demand the superclass
22:41:35 <SamB> any code that breaks needs fixing anyway, right?
22:41:41 <ski> i was surmising that noone has wanted to change it until one knows how to do it properly .. or something like that
22:41:45 <sjanssen> IMO, this is one reason why the "class Functor m => Monad m" movement doesn't have more support
22:42:04 <sjanssen> every time we bring it up, we get side tracked with class alias proposals and other nonsense
22:42:10 <ski> (:
22:42:45 <sjanssen> a Functor instance is not burdensome: simply two lines of boilerplate
22:42:56 <SamB> sjanssen: put up the "bikeshed-free-zone" sign next time?
22:43:10 <SamB> or maybe just "paint-free-zone"
22:43:20 <SamB> or "nuclear-reactor-free-zone"
22:43:29 <sjanssen> SamB: this isn't quite a paint situation
22:43:34 <olsner> just sneak it in the next ghc release and see what breaks
22:43:41 <mauke> I don't like it
22:43:46 <sjanssen> you might liken the Monad/Functor proposal as "hey, let's build a shed"
22:43:48 <SamB> mauke: what?
22:43:58 <mauke> the class Functor m => Monad m constraint
22:44:03 <SamB> why not?
22:44:06 <mauke> you don't need to be a Functor to be a Monad
22:44:20 <mauke> it's the other way around: if you're a Monad, you can automatically derive a Functor instance
22:44:20 <sjanssen> the class alias proposals are "but we need to make the path to the shed area better first!"
22:44:27 <sjanssen> fairly orthogonal IMO
22:44:29 <SamB> mauke: you're confused in the head
22:44:43 <ski> every (non-broken) monad is a functor
22:44:45 <mauke> so I want something like instance (Monad m) => Functor m where fmap = liftM
22:44:59 <sjanssen> mauke: all monads are functors, that's exactly what the "Functor m =>" means
22:45:06 <dibblego> > fix mauke -- please
22:45:07 <lambdabot>   Not in scope: `mauke'
22:45:07 <SamB> mauke: um. that isn't even close to Haskell 98
22:45:14 <ski> i think it's fair to require 'Functor' for 'Monad'
22:45:15 <mauke> SamB: yes, which is the problem
22:45:35 <SamB> mauke: how about we just do it a sensible way, hmm?
22:45:36 <sjanssen> mauke: at that point, we need a nice system for overlapping instances (which doesn't exist)
22:45:47 <mauke> SamB: that is the sensible way
22:45:58 <sjanssen> mauke: why is that so sensible?
22:46:02 <mauke> class Functor m => Monad m is just half-assed
22:46:05 <SamB> mauke: the cliffs of insanity are not sensible!
22:46:14 <sjanssen> mauke: what about types where fmap/join are easier to express than >>=?
22:46:21 <SamB> mauke: later we'll get those class aliases and it will be nice
22:46:32 <SamB> mauke: mkay?
22:46:43 <mauke> sjanssen: that's a completely different issue. for that you'd have to make liftM/join methods of Monad
22:46:46 <sjanssen> mauke: you're exactly the problem I was describing earlier :)
22:47:23 <SamB> mauke: the cliffs of insanity, by the way, are also terrible for biking
22:47:27 <sjanssen> mauke: all Integral are Num, so why don't we write "instance Integral a => Num a"?
22:51:44 <wli> sjanssen: For me, fmap and join are sort of innately easier to understand.
22:51:44 <mauke> sjanssen: what would you put in the where clause?
22:51:44 <sjanssen> mauke: yeah, that is a point.  Integral doesn't quite give you all the ops
22:51:44 <mauke> exactly
22:51:44 <SamB> sjanssen: not a very good example
22:51:44 <mauke> fmap is composable from >>= and return
22:51:44 <SamB> mauke: you'll never get your idea past libraries@, anyways
22:51:44 <mauke> so I don't see why I have to implement fmap first and then >>=/return
22:51:44 <sjanssen> mauke: Haskell has a language to express hierarchy of classes
22:51:44 <wli> mauke: (>>=) is composable from join and fmap
22:51:44 <mauke> wli: yes, but join is not in Functor
22:51:44 * wli fires up "make ghci" in the numeric prelude dir.
22:51:44 <sjanssen> mauke: our theoretical basis says that Monad is a subclass of Functor
22:51:44 <SamB> mauke: that's not the point
22:51:44 * ski wonders what he's started ..
22:51:44 <mauke> sjanssen: I don't care about your theoretical basis :-)
22:51:44 <SamB> ski: it's not your fault
22:51:44 <sjanssen> mauke: therefore the class declarations should clearly mirror the theory
22:51:44 <SamB> mauke: my practical basis gets annoyed when Monads don't have Functor instances
22:51:44 <wli> ski: Hmm, join isn' treally injective.
22:51:44 <mauke> class (Functor m) => Monad m where return :: a -> m a; join :: m (m a) -> m a  -- would this work?
22:51:44 <dolio> In other words, (>>=) should be removed from Monad, and replaced by join and (Functor m) =>. :)
22:51:44 <mauke> m >>= f = join (fmap f m)
22:51:44 <ski> mauke : yes
22:51:44 <wli> ski: Call it a canonical homomorphism or some such.
22:51:44 <mauke> that I can live with
22:51:44 <SamB> why do we need to remove >>= to do that?
22:51:44 <ski> or closure
22:51:44 <ski> SamB : we don't
22:51:44 <wli> ski: What was this eta stuff?
22:51:46 <wli> ski: eta = return, mu = join?
22:51:53 <ski> wli : 'eta' is just the common CT name for 'return' (also called 'unit')
22:51:55 <ski> indeed
22:51:57 <sjanssen> mauke: IMO, adding join to Monad and making Functor a superclass are totally orthogonal
22:52:03 <wli> ski: What's fmap in the category theory?
22:52:15 <ski> ('unit' is from adjunction situation, i think)
22:52:19 <dolio> SamB: Because then people can't complain (>>=) can be used to define fmap, because it it's only defined in terms of fmap. :)
22:52:22 <ski> wli : functor map ! :)
22:52:31 * wli has no idea what an adjunction is.
22:52:37 <ski> wli : (usually written the same as
22:52:49 <ski> the "type constructor" itself)
22:53:00 <SamB> but think of all the code that we'd break in ways that are considerably less trivial to fix
22:53:08 <SamB> if we took out >>=
22:53:09 <sorear> so why don't we use μ and η ? it would be so much more concise!
22:53:29 <sjanssen> if people are really afraid of the single line of Functor boilerplate required, we can provide fmapViaBind in the libraries somewhere
22:53:34 <SamB> sorear: well, my scim panel had disappeared
22:53:42 <Cale> wli: It's usually denoted Tf, where T is the functor in question.
22:53:44 <SamB> though I see now that I've had to restart X I can get it back
22:53:44 <sjanssen> then you've got "instance Functor T where fmap = fmapViaBind"
22:53:47 <ski> wli : e.g. 'fmap (f :: a -> b) :: Maybe a -> Maybe b)' would be 'Maybe (f : a >--> b) : Maybe a >--> Maybe b'
22:53:52 <wli> sjanssen: And bindViaFmap?
22:54:02 <sorear> CTRL-SHIFT-3BC CTRL-SHIFT-3B7
22:54:06 <wli> ski: What's >-->?
22:54:07 <sjanssen> wli: well, you need join too
22:54:09 <Cale> If we were to do this in Haskell, you could write  Maybe (+1) (Just 5) == Just 6
22:54:11 <ski> wli : each adjunction determines a monad (and a comonad as well)
22:54:26 <ski> wli : morphism arrow .. think "function type constuctor", roughly
22:54:26 <SamB> sorear: what was that first one?
22:54:32 <wli> ski: Wait, I don't understand adjunctions.
22:54:35 <sorear> μ η
22:54:36 <Cale> That would work out rather strangely for functors having a constructor of the same name as the type constructor though.
22:54:41 <SamB> η I have
22:54:45 <ski> Cale :)
22:54:48 <sorear> SamB: Mu.
22:54:53 <SamB> oh
22:54:55 <SamB> capital?
22:55:02 <Cale> Lowercase
22:55:05 <SamB> oh.
22:55:08 <SamB> Iget µ
22:59:15 <Cale> μ η
22:59:15 <Cale> mu, eta
22:59:15 <SamB> why does my mu look different
22:59:15 <mauke> U+00B5 (0xc2 0xb5): MICRO SIGN [µ]; U+03BC (0xce 0xbc): GREEK SMALL LETTER MU [μ]
22:59:15 <SamB> mauke: eww
22:59:15 <SamB> so how do I fix scim's bindings
22:59:15 <ski> wli : adjunctions are a bit hard to understand (i can't say i've understood them so well :)
22:59:15 <ski> (wli : mayhaps if we made more applications of them in haskell, it'd be easier !)
22:59:15 * ski seems to recall esap did some with them ..
22:59:15 <Cale> To say that F and G are adjoint functors is to say that in some sense, a morphism from F X to Y is "the same as" a morphism from X to G Y.
22:59:15 <SamB> so if we add join to Monad, do you think we can get away with the superclass then?
22:59:15 <ski> 'get away' meaning ?
22:59:15 <dolio> Actually, if you're going to do a superclass, it should be Applicative m => Monad m.
22:59:15 * ski smiles
22:59:15 <SamB> dolio: um.
22:59:15 <SamB> Applicative is not established!
22:59:15 <Cale> That exposes a more general problem with Haskell's typeclass system.
22:59:15 <ski> SamB : it ought to be !
22:59:19 <Cale> We really need something like class aliases.
22:59:23 <wli> hah
22:59:24 <dolio> Since pure = return and <*> = ap.
22:59:32 <SamB> exactly how long has applicative been OUT?
22:59:41 <ski> Cale : yes .. one should be able to add things "above" classes, (and in between, possibly), not always below
22:59:48 <Cale> SamB: 6.4? 6.6 maybe?
22:59:50 <sorear> @google citeseer applicative programming with effects
22:59:53 <lambdabot> http://citeseer.ist.psu.edu/232159.html
22:59:53 <lambdabot> Title: Inferring Effect Types in an Applicative Language with Asynchronous Concurrency  ...
22:59:56 <SamB> sorear: not the paper
22:59:58 <wli> Categories for the Working Mathematician was buried underneath my hardcover copy of Kevyn Aucoin's "Face Forward."
23:00:10 <sorear> aww, I was hoping for patersonXYapplicative.html
23:00:11 <SamB> the module in GHC's libraries
23:00:14 <sorear> which would tell us
23:00:41 <RyanT5000> is there any way to hook into GHC's GC, e.g. in the mark phase, to integrate it into another GC?
23:00:46 <SamB> @google citeseer applicative programming with effects paterson
23:00:49 <lambdabot> http://www.e-pig.org/darcs/epigram/src/EpiTome.bib
23:00:53 <SamB> hmm.
23:00:59 <sjanssen> SamB: I think they were new in 6.6
23:01:11 <ski> wasn't the McBride & someone paper on 'Idioms' the first ?
23:01:27 <SamB> sjanssen: which was released when?
23:01:32 <glguy> ugh... some guy got an article into "beautiful code" writing about using ruby to take 13 lines to do: egrep -o <his_regex> | sort | uniq -c | sort -rn | head -10
23:01:50 <sjanssen> Copyright   :  Conor McBride and Ross Paterson 2005
23:02:10 <sjanssen> SamB: 6.6 was last fall, IIRC
23:02:15 <wli> Adjoints seem to be something like pairs of inverse functors plus something I don't understand.
23:02:21 <RyanT5000> glguy: i love how *every* programmer thinks he/she is an expert on code "beauty"
23:02:29 <RyanT5000> glguy: especially me
23:02:30 <ski> wli : not quite inverse
23:02:31 <Cale> Let me give a helpful example of adjoint functors
23:02:35 <mauke> sjanssen, SamB: I'm ok with making Functor a superclass now. I still find it weird that you can have mutually recursive instances, sort of
23:02:38 <ski> (less than inverse)
23:02:39 <SamB> dolio: um. You're talking about something that's really only been around for use since last fall!
23:02:43 <Cale> Does everyone know what a group is?
23:02:54 <SamB> dolio: have some patience!
23:02:57 <wli> I know what a group is.
23:03:00 <Cale> okay
23:03:00 <SamB> it may be accepted in time
23:03:06 <SamB> Cale: I ought to
23:03:07 <dolio> SamB: So? What's your timeframe for changing the class hierarchy? 6.8?
23:03:11 <Cale> How about the free group generated by a set?
23:03:22 <ski> free vector spaces !
23:03:24 <wli> Cale: I know that, too.
23:03:26 <SamB> dolio: I don't even know what Applicative actually is yet
23:03:32 <Cale> okay
23:03:35 <dolio> :)
23:03:41 * glguy wonders who started the "ruby code is /elegant/" myth
23:03:48 <ski> SamB : basically 'return' + 'ap'
23:03:50 <sjanssen> dolio: changing the class hierarchy is a compatibility making change -- so it should only be done by Haskell'
23:03:54 <glguy> or whatever word it is they seem to keep using
23:03:55 <Cale> So there's a functor F from Set to Grp which sends a set to the free group on those elements.
23:04:09 <sjanssen> glguy: 'tis a bit annoying
23:04:09 <wli> SamB: Presumably it's something that represents a function somehow, e.g. an association list or Data.Map.Map
23:04:11 <Cale> If we have a map, say f: FX -> Y
23:04:12 <SamB> JohnMeachem's assertion that it was only fit for use with Monads hasn't helped my already bursting enthusiasm
23:04:28 <Cale> That is, from our free group on the set X, to some other group Y
23:04:38 <Cale> What does it take to specify that map?
23:04:49 <dolio> sjanssen: Yeah. And who knows the time frame for that anymore? :)
23:04:55 <SamB> dolio: it still has frisby to contend with, I think
23:05:00 <Cale> All we really need to know is where the generators of the free group are sent in Y.
23:05:02 <dolio> glguy: Ruby looks elegant coming from Java.
23:05:04 <wli> Cale: From a free group to another group? I'm not sure it's definable.
23:05:16 <Cale> wli: That is, a homomorphism
23:05:38 <olsner> I guess ruby coders come from the C/C++ and Java camps where just about anything else is elegant
23:05:43 <Cale> If you want to be really concrete, we could take X = {a,b}
23:05:47 <glguy> dolio: so it is simple ignorance of the programming language landscape? tunnel vision from too much /enterprise/?
23:05:51 <wli> Cale: Okay, a homomorphism works. I guess as long as there are enough generators in the free group.
23:05:57 <Cale> and so FX is the free group with generators {a,b}
23:05:59 <SamB> okay I'm going to bed now
23:06:02 <Cale> and Y is some other group
23:06:13 <SamB> good night, and happy bikeshedding
23:06:22 <RyanT5000> lol goodnight
23:06:26 <Cale> Maybe Y is, oh, the integers.
23:06:36 <Cale> (under addition)
23:06:38 <dolio> glguy: That'd be my guess. I did ruby directly after doing mostly Java, and thought it was quite nice. Haskell is nicer, of course.
23:07:05 <Cale> So if we have a hom from FX to Y, all we need to know about that hom to know everything about it is to know where a and b get sent in Z
23:07:11 <sjanssen> glguy: I was particularly disturbed at a recent blog "The syntax seems reasonable, but everything looks verbose to me after Ruby." (referring to some simple Haskell code from SPJ's presentation)
23:07:16 <Cale> Er, heh, Y = Z :)
23:07:45 <Cale> wli: Makes sense?
23:07:54 <glguy> sjanssen: that's a long way of saying "I didn't understand all of the things that I just saw, but I trust that it would be shorter in ruby"
23:08:07 <glguy> I guess its a short way of saying that ;)
23:08:07 <olsner> glguy: have you got a link to that article?
23:08:09 <sjanssen> glguy: the code was some really short, elegant code that couldn't possibly have been written more clearly
23:08:09 <Cale> This is because if we have some element of the free group, say, aba^2ba, say
23:08:16 <sjanssen> or more concisely
23:08:18 <glguy> olsner: to the beautiful code book?
23:08:22 <shachaf> sjanssen: Yes, I saw that.
23:08:28 <Cale> f(aba^2ba) = f(a) f(b) f(a) f(a) f(b) f(a)
23:08:34 <shachaf> sjanssen: It's the reverse for me; I don't like Ruby syntax anymore...
23:08:48 <Cale> So if we know f(a) and f(b), we know f for anything in the whole free group.
23:08:48 <olsner> oh, was it a book? never mind then :P
23:08:48 <shachaf> sjanssen: Compared to Haskell, which looks so much nicer.
23:08:55 <wli> Cale: Of course.
23:08:58 <Cale> wli: Okay
23:09:19 <Cale> So there's another functor, G: Grp -> Set, which sends a group to the underlying set.
23:09:31 <glguy> I really want to like Ruby, I spend time in #ruby-lang to try to "get it"
23:09:34 <wli> That one is particularly easy.
23:09:37 <Cale> right
23:09:50 <Cale> So to know a map FX -> Y
23:09:53 <wli> Cale: The forgetful functor.
23:09:57 <Cale> yes
23:10:03 <Cale> we can instead record a map X -> GY
23:10:15 <Cale> (this is a function, in Set)
23:10:25 <Cale> That is what I just said
23:10:43 <Cale> So the maps FX -> Y are "the same as" maps X -> GY
23:11:17 <wli> But in the opposite direction?
23:11:22 <Cale> That too...
23:11:39 * ski murmurs "galois"
23:11:40 <Cale> If we have a function X -> GY, it uniquely determines a homomorphism FX -> Y
23:11:54 <wli> ski: Yes, it smells of a Galois connection.
23:11:55 <Cale> That is, we can send the generators anywhere, and get a homomorphism
23:11:58 <dolio> glguy: Ruby does do some things nicely, if my memory serves. I haven't used it in a while, though.
23:12:10 <dolio> glguy: For instance, it encourages lots of programming with higher order functions with its blocks.
23:12:14 <ski> galois connections are special cases of adjunctions
23:12:18 <glguy> dolio: thre are neat ideas, but the implementation of them is so poor
23:12:25 <glguy> you can tell they just made it up as they went along
23:12:27 <sjanssen> how would one write "swap (w1 : w2 : ws) = w2 : w1 : ws; swap ws             = ws" in Ruby, anyway?
23:12:34 <Cale> Whenever the maps from FX -> Y are "the same as" the maps X -> GY for all objects X and Y, we say that F is left adjoint to G.
23:12:38 <Adamant> Ruby was heavily influenced by Scheme and Smalltalk.
23:12:54 <dolio> And having open classes can be fun.
23:12:58 <Adamant> both are pretty nice.
23:13:32 <glguy> Adamant: I haven't seen why someone would want to use it over either of those two thigns though, regarding the things that those two influenced
23:13:34 <dolio> glguy: As I said, I haven't used it in a while, so perhaps I'm looking back with rose colored glasses.
23:13:54 <wli> Cale: It's sort of an isomorphism between the morphisms.
23:14:00 <mauke> sjanssen: sub swap { @_[1, 0, 2 .. $#_] }  # perl
23:14:01 <Cale> yes, that's exactly what it is
23:14:06 <Adamant> glguy, a practical reason would be that Ruby's libraries beat the crap out of both of those languages combined.
23:14:15 <dolio> And, strictly speaking, it's probably inferior to several of the languages that it borrows ideas from.
23:14:28 <Cale> But it says something interesting about the pair of functors (F,G)
23:14:30 <dolio> But, more people have heard of/used Ruby than those other languages these days. :)
23:14:31 <sjanssen> mauke: that handles the length < 2 case correctly?
23:14:42 <mauke> yes, slicing an empty list returns an empty list
23:14:56 <glguy> Adamant: agreed, but that just makes me sad to know that maybe people would have written libraries for those other languages instead of them now being tied to ruby
23:15:00 <Cale> How much topology do you know?
23:15:10 <mauke> sjanssen: oops, not quite
23:15:13 <Adamant> glguy, both of those languages have made some mistakes in marketing, etc.
23:15:15 <wli> I've always detested the ad hoc languages like perl, python, ruby, etc.; I use Haskell where others would use them.
23:15:31 <wli> Cale: Minimal. I remember Heine-Borel from real analyis etc.
23:15:33 <sjanssen> also, we've got "swap ws = reverse (take 2 ws) ++ drop 2 ws" too
23:15:39 <ski> (wli : rather isomorphism between the morphism *classse* .. (otherwise, it'd be a 2-isomorphism))
23:15:42 <mauke> sjanssen: my tests were flawed. this function fails for short lists :(
23:15:54 <Cale> wli: Do you recall what a topological space and a continuous map is?
23:15:59 <wli> ski: Save that thought for later.
23:16:05 <wli> Cale: I remember that much.
23:16:32 <Cale> Okay, so we can pull a similar trick to that group thing in topological spaces...
23:16:35 <mauke> sub swap { @_ < 2 ? @_ : @_[1, 0, 2 .. $#_] }
23:17:00 <wli> It's been 8 years since and I "partied" all through college anyway.
23:17:27 <glguy> a day or two ago, people in #ruby were dreaming of an editor that could infer types of ruby objects and auto complete methods for those objects
23:17:29 <mauke> BEGIN{*swap=sub{@_<2?@_:@_[1,0,2..$#_]}}  # dewhitespaced
23:17:40 <glguy> I didn't bother telling them that what they want is a statically inferred typed language
23:17:44 <wli> glguy: omfg that's lame
23:18:04 <glguy> wli: I'm not sure if you are being sarcastic or not :)
23:18:17 <Cale> If we have a set, we can form the discrete topology on that set, and that's a functor F: Set -> Top
23:18:38 <wli> glguy: Not at all. Dreaming of where we started at from the get-go is just plain lame.
23:18:57 <wli> Cale: And the forgetful functor in reverse?
23:19:02 <Cale> yeah
23:19:04 <dolio> glguy: Oh, that's another thing. I don't think most Ruby people have seen type systems like ML and Haskell.
23:19:17 <glguy> they actually argued with me that variables in ruby don't have types
23:19:19 <dolio> glguy: So there's plenty of "dynamic typing is so much better than Java." :)
23:19:33 <dolio> Or C++, or C.
23:19:34 <glguy> or rather they argued that they do
23:19:44 <Cale> If G is the forgetful functor then we can look at a map F X -> Y -- that is, a continuous map from the discrete space on the set X to the topological space Y
23:19:52 <Cale> as a function from X to G Y
23:19:54 <olsner> > let swap = uncurry ((++) . reverse) . (take 2 &&& drop 2) in swap [1,2,3,4]
23:19:56 <lambdabot>  [2,1,3,4]
23:20:03 <Cale> Because any function will do
23:20:30 <Cale> (continuity is trivial when each point is a neighbourhood on its own)
23:20:32 <dolio> "Ask Reddit: What is Haskell good for?"
23:20:34 <glguy> olsner: splitAt 2
23:20:36 <wli> glguy: I just hope something like Cyclone takes off in the C/C++ space.
23:20:44 <Cale> Alternately, we can go the other way
23:20:48 <mauke> > let swap = liftM2(++)(reverse.take(2))(drop(2)) in  in swap [1,2,3,4]
23:20:48 <lambdabot>  Parse error
23:20:59 <mauke> > let swap = liftM2(++)(reverse.take(2))(drop(2)) in swap [1,2,3,4]
23:21:01 <lambdabot>  [2,1,3,4]
23:21:11 <glguy> mauke: splitAt 2
23:21:18 <Cale> With a set X, we can form the trivial topology (where only the empty set and the whole set are open)
23:21:24 <Adamant> wli, nonstarter due to performance.
23:21:27 <Cale> That's another functor K: Set -> Top
23:21:52 <mauke> glguy: then what?
23:21:58 <wli> Adamant: Depends on precisely how much of Cyclone it borrows.
23:22:17 <glguy> mauke: rather than using arrows or reader monad to duplicate the x into take and drop
23:22:28 <wli> Adamant: There are other points but I'll spare them.
23:22:37 <Cale> If we have a map f: G X -> Y, that is, from the underlying set of X to the set Y
23:22:47 <mauke> glguy: but how do I take the pair apart in a pointless way?
23:22:58 <mauke> er, wait
23:22:58 <sorear> fst&snd?
23:23:02 <glguy> uncurry? curry?
23:23:05 <mauke> right
23:23:06 <wli> Cale: But you can get from the underlying set to the maps appropriately.
23:23:08 <Cale> we can consider that as the same as a map X -> K Y, from the space X to the trivial topology on Y
23:23:10 <Adamant> wli, you can msg me with them
23:23:35 <Adamant> I'd like to hear them
23:23:39 <mauke> :t uncurry((++).reverse).splitAt(2)
23:23:42 <lambdabot> forall a. [a] -> [a]
23:24:19 <Cale> wli: does that make sense? I'm not sure how familiar you are with these spaces
23:24:21 <glguy> :t uncurry ((++).reverse).splitAt 2
23:24:23 <lambdabot> forall a. [a] -> [a]
23:24:29 <Cale> Any map to the trivial topology is continuous.
23:24:40 <Cale> Any map from the discrete topology is continuous.
23:24:42 <wli> Cale: I'm straining on the topological front. I did better with the group example.
23:24:46 <Cale> Okay
23:25:47 <Cale> Anyway, the big picture of this example is that we have F is left adjoint to G which is left adjoint to K, where F is "form the discrete topology", G is "take the underlying set", and K is "form the trivial topology"
23:26:16 <ski> F --| G --| K
23:26:31 <ski> http://haskell.org/pipermail/haskell/2004-June/014134.html
23:26:32 <lambdabot> Title: [Haskell] topology in Haskell
23:26:54 <ski> (Martic Escardo "Synthetic topology of data types and classical spaces")
23:27:23 <ski> Cale : so 'K' is called 'cofree', yes ?
23:27:43 <Cale> hmm, I suppose that would be appropriate :)
23:27:50 <olsner> glguy: the ruby chapter is the sample chapter, so it was available on the oreilly webpage
23:28:00 <glguy> eww
23:28:10 <olsner> http://www.oreilly.com/catalog/9780596510046/chapter/index.html
23:28:11 <lambdabot> Title: O'Reilly Media -- Bookstore: Beautiful Code
23:28:15 <glguy> I'm surprised that they would make that their example
23:28:28 <Cale> From every one of these adjunctions, we can build both a monad, and a comonad.
23:28:57 <glguy> that chapter has a full page on "my ruby code is slow, and I tried to make it faster but I couldn't and it really isn't a big deal to be slow anyway"
23:29:40 <Cale> glguy: hehe
23:29:41 <olsner> they spend a page to explain, and 5 lines in ruby to write a one-line grep | sed, grep | cut or awk
23:29:49 <ski> > let swap = liftM2(++)(reverse.take(2))(drop(2)) in swap [0..3]
23:29:51 <lambdabot>  [1,0,2,3]
23:29:52 <ski> > (uncurry ((++).reverse).splitAt 2) [0..3]
23:29:53 <lambdabot>  [1,0,2,3]
23:30:10 <wli> olsner: Well, let Ruby stand on its own merits vs. the other affairs there.
23:30:22 <glguy> I used : egrep, sort, uniq, head to do it
23:30:33 <glguy> I don't know awk and sed well enough to rattle off their usage
23:30:40 <olsner> it's probably a one-liner in perl too, or a 20-char perlgolf, if you were so inclined
23:30:46 <olsner> tools for the job, and all that
23:30:59 <glguy> olsner: but fortunately the point is beauty
23:31:20 <olsner> terseness can also be beauty ;-)
23:31:27 <glguy> shhh
23:31:30 <glguy> don't tell
23:31:50 <Cale> If F is left adjoint to G, then GF is a monad.
23:32:01 <glguy> stop
23:32:04 <glguy> first explain that line
23:32:13 <Cale> me?
23:32:15 <glguy> does it stand on its own?
23:32:23 <Cale> No, it doesn't :)
23:32:26 <glguy> damn
23:32:31 <glguy> ok... carry on
23:32:49 <Cale> Were you following the adjoint functors discussion?
23:33:03 <glguy> I'm totally out of my depth
23:33:05 <glguy> I was trying
23:33:08 <Cale> okay
23:33:12 <ski> unit :: id -> G . F
23:34:11 <glguy> unit is the math term for "return"?
23:34:17 <ski> yes
23:34:23 <ski> you start with
23:34:34 <Cale> So how might we get such a map? Well, there's an identity map which goes from FX -> FX
23:34:38 <ski> id_{F a} :: F a -> F a
23:34:39 <Cale> (for any X)
23:34:57 <ski> then, from 'F X -> Y' we can get to 'X -> G Y'
23:34:58 <Cale> and we can then apply the adjunction to turn that into a map X -> GFX
23:35:25 <ski> so, if we call that "right_adjunct", we have
23:35:41 <Cale> So, in the groups case, where F is the free group, and G is the underlying set
23:35:43 <ski> right_adjunct id_{F a} :: a -> G (F a)
23:36:07 <Cale> this will be the function which takes a set to the underlying set of the free group on that set
23:36:13 <ski> this works for any 'a' (uniformly/parametrically), so we actaully have
23:36:25 <ski> right_adjunct id_F :: forall a. a -> G (F a)
23:36:27 <kolmodin> is that beautiful code book all about ruby?
23:36:34 <glguy> kolmodin: no
23:36:43 <ski> which is what 'unit' was saying
23:36:49 <Cale> Or, really, an element of a set, to the underlying element of the free group.
23:37:07 <Cale> (depends on what you're looking at)
23:37:54 <Cale> join is just a little trickier
23:38:02 <sjanssen> kolmodin: SPJ has a chapter IIRC
23:38:31 <Cale> You can use the identity map GY -> GY, and apply the adjunction in reverse, to get a map FGY -> Y
23:38:46 <wli> Cale: Going over it.
23:38:48 <ski> which is 'extract', in the comonad 'F . G'
23:38:49 <kolmodin> sjanssen: oh yes, I see, about concurrency
23:39:00 <kolmodin> neat
23:39:07 <Cale> Right, but we also use it to build the join for the monad :)
23:39:12 <kolmodin> so is it worth buying? any recommendations?
23:39:37 <Cale> Really, it's a natural transformation FG -> 1
23:39:37 <wli> There isn't a Haskell book written for people like me.
23:39:42 <wli> They're mostly for Freshmen.
23:40:05 <glguy> ski: I think what you are saying generally makes sense, but I am also pretty sure that I could just as easily be making connections where there are none
23:41:21 <ski> Cale : hm you left-compose with 'G' and right-compose with 'F', yes ?
23:41:26 <Cale> yeah
23:41:28 <ski> glguy : re adjunctions ?
23:41:28 <Cale> join :: GF GF X -> GF X
23:41:35 <kolmodin> wli: aye, I feel the same way. I end up reading papers and code in other hackers projects
23:41:37 <Cale> and you have a map FG -> 1
23:41:46 <Cale> so you're applying that to the "middle" FG
23:41:50 <Cale> in a sense :)
23:42:00 <wli> oic...
23:42:47 <kolmodin> I'm very much looking forward dons et al.'s book :D
23:42:51 <ski> join  =  G . (extract : F . G -> id) . F  : G . F . G . F -> G . id . F
23:43:10 <ski> (using '.' as a difunctor ;)
23:44:01 <glguy> a functor is a mapping between categories, and a difunctor is a mapping from two categories to one?
23:44:08 <Cale> I'm sure that if I understood it better, I could explain it better ;)
23:44:39 <ski> a difunctor is a mapping from 'C^Op * D' to 'E', where 'C','D','E' are categories
23:44:51 <ski> s/mapping/functor/
23:45:02 <ski> a bifunctor is a functor from 'C * D' to 'E', where 'C','D','E' are categories
23:45:09 <Cale> But the basic idea is that you have these adjoint functors, and the compositions, from one category to the other and then back again, leave you with a monad and a comonad.
23:45:40 <ski> 'di-' just expresses that the left argument is to be regarded as contravariant .. like the type constructor '->' is
23:45:56 <wli> Cale: Which is the monad and which is the comonad?
23:46:05 <wli> Cale: In terms of left/right adjoints?
23:46:11 <Cale> If F is left adjoint to G, then GF is the monad
23:46:18 <Cale> and FG is the comonad
23:46:21 <wli> Okay.
23:46:25 <ski> wli : 'G . F' is the monad, 'F . G' is the comonad, in the adjunction situation 'F --| G'
23:46:36 <ski> dimap :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1))
23:46:55 <ski> bimap :: (a0 -> a1) -> (b0 -> b1) -> ((a0,b0) -> (a1,b1))  -- instance BiFunctor (,)
23:46:58 <wli> What do F and G break down to for some types we can see in Haskell?
23:47:02 <glguy> (to give you a sense of where I am) Is it correct that a functor is a mapping on the objects and morphisms in one category to objects and morphisms in another (possibly same) category
23:47:10 <ski> bimap :: (a0 -> a1) -> (b0 -> b1) -> (Either a0 b0 -> Either a1 b1)  -- instance BiFunctor Either
23:47:15 <glguy> (possibly same being an endofunctor, which is what Haskell's Functor is)
23:47:29 <Cale> glguy: yes
23:47:33 <glguy> and where the data constructor is the mapping on types
23:47:38 <Cale> right
23:47:39 <glguy> and fmap is the mapping on functions or morphisms
23:47:45 <ski> wli : in the state monad 's -> (s,a)', 'G' is '(s ->)', and 'F' is '(s,)'
23:48:24 <wli> kolmodin: What it comes down to is that there are people who are beyond basic syntax, laziness, and the concept of an algebraic data type, and need help with leveraging advanced things like monads, GADT's, fundeps (or associated types or whatever), Template Haskell, and so on.
23:48:32 <ski> 'F . G' then gives the "state-in-context" comonad
23:48:44 <glguy> in some weird sense, would a language translator be a functor between the categories of two programming language...?
23:48:48 <glguy> or is that too far?
23:49:03 <Cale> glguy: It might work :)
23:49:16 <wli> kolmodin: And that it's more of an issue of making effective practical use than just eking out code that involves it.
23:49:19 <Cale> If it was a really good one :)
23:49:20 <ski> (wli : in this case 'F','G' are endofunctors .. that's not generally the case .. which makes it harder to express in haskell)
23:49:49 <wli> ski: I'm not sure I understand an endofunctor if that's the case.
23:49:58 <Cale> So for every type X in programming language C, you could assign a type TX in programming language D
23:50:15 <kolmodin> wli: ah yes. luckily there was a course at my univ..
23:50:24 <Cale> and for every function X -> Y in programming language C, you could get a function Tf: TX -> TY
23:50:26 <glguy> Cale: Haskell is a Category because composition (.) is associated and because we have an identity function on objects?
23:50:34 <ski> wli : '(s ->) :: * -> *', '(s,) :: * -> *' .. domain = codomain = the category '*', here
23:50:34 <glguy> associative*
23:50:43 <Cale> glguy: yeah
23:50:48 <wli> kolmodin: It covered monads, GADT's, fundeps, Template Haskell, et al?
23:50:50 <Cale> and it would have to respect composition as well
23:50:57 <Cale> so T(f.g) = Tf . Tg
23:51:15 <Cale> and T(id_X) = id_(TX)
23:51:29 <wli> Oh, existential types, arrows, zippers, CPS, et al, too.
23:51:43 <ski> wli : generally you can't expect them to be the same category (e.g. if 'G . F : * -> *', then 'F . G : C -> C','F : * -> C','G : C -> *' for some other category 'C')
23:51:46 <kolmodin> wli: not really. no
23:51:50 <glguy> Cale: associative (.) is made possible though purity?
23:51:54 <glguy> or are those unrelated?
23:52:09 * glguy tries to think of a counter example
23:52:26 <kolmodin> wli: basic monads and some more advanced monad stuff. no GADT's nor fundeps, TH... :-/
23:52:35 <Cale> Somewhat unrelated. I think you'd still be okay in a language with effects.
23:52:49 <kolmodin> wli: although, once you are that far you can read the papers
23:52:51 <Cale> Your arrows would involve more complicated things than plain functions.
23:52:52 <wli> I'm actually trying to do type inference for a typesystem that's basically H98.
23:53:11 <wli> I'm not sure if I'm handling the type qualifiers properly...
23:53:24 <ski> Cale,(glguy) : yes .. consider the kleisli category over any haskell monad, e.g.
23:53:34 <Cale> As an example, you can construct a category whose objects are of the form IO X for X any Haskell type
23:53:43 <kolmodin> wli: that's a good way to learn a language :)
23:53:46 <wli> kolmodin: Papers kind of suck for this; they're pretty disorganized.
23:53:51 <Cale> and take the arrows to be ordinary Haskell functions X -> IO Y
23:54:22 <kolmodin> wli: I'd much prefer a book, naturally
23:54:24 <wli> kolmodin: Well, all I really want is monadic IO and overloading of arithmetic operators, so it's not quite as ambitious as it sounds.
23:54:39 <Cale> I'm sure you can write a function  compose :: (b -> IO c) -> (a -> IO b) -> (a -> IO c)
23:54:50 <Cale> and id is just return :)
23:54:56 <kolmodin> wli: ah, ok
23:54:56 <wli> Cale: (>=>) in ghc6.7
23:55:02 <Cale> wli: nice :)
23:55:28 <wli> Cale: Except that I have to wait ages for Debian to see it. :(
23:55:30 <ski> "the craft .." defines '(>@>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)'
23:56:20 <glguy> Cale: is there a special term for such a "subcategory"?
23:56:24 <Saizan> so you've both X and IO X in this category?
23:56:31 <wli> I'm not sure what dons' book is supposed to cover.
23:56:41 <ski> the objects are 'X','Y', etc ..
23:56:42 <Cale> glguy: the Kleisli category for IO
23:56:50 <glguy> Cale: but more generally...
23:56:54 <wli> kolmodin: We need an "Advanced Programming in the Haskell Environment" ;)
23:57:04 <ski> a morphism from 'X' to 'Y' in this categoy is implemented as a function from 'X' to 'IO Y' in haskell
23:57:05 <kolmodin> ?google real world haskell book
23:57:07 <lambdabot> http://www.realworldhaskell.org/blog/
23:57:07 <lambdabot> Title: Real World Haskell
23:57:17 <kolmodin> wli: have you had a look at the TOC?
23:57:17 <Syzygy-> :t join
23:57:18 <Cale> glguy: without regard for the sense that it's monad that's involved?
23:57:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:57:39 <wli> kolmodin: Not yet.
23:57:48 <Cale> actually, I think that if you can form such a category, you must have a monad...
23:58:00 <Cale> You certainly have return, and Kleisli composition
23:58:13 <kolmodin> wli: the book's title pretty much covers it. it's on topics that you need to know in the 'real world'
23:58:14 <Syzygy-> :t \g f -> join . fmap g . f
23:58:14 <ski> so e.g. the identity over 'X', which goes from 'X' to 'X' in this 'Kleislo IO' category, is implemented by a function from 'X' to 'IO X' in haskell (namely 'return')
23:58:16 <lambdabot> forall a a1 (f :: * -> *) a2. (Monad f, Functor f) => (a1 -> f a) -> (a2 -> f a1) -> a2 -> f a
23:58:16 <kolmodin> :)
23:58:22 <glguy> Cale: is that category and "haskell" related?
23:58:27 <wli> kolmodin: A search for "contents" seems to turn up nothing on the front page.
23:58:40 <Cale> glguy: I'm mixing terms, but yeah.
23:58:41 <glguy> or are they just two categories using things from one large set of objets
23:58:47 <Cale> hmm...
23:58:55 <Syzygy-> glguy: Do you mean set, or do you mean class?
23:58:58 <glguy> does that statement even make sense?
23:59:03 <glguy> class
23:59:14 <kolmodin> wli: http://www.realworldhaskell.org/blog/2007/05/23/real-world-haskell-its-time/
23:59:16 <lambdabot> Title: Real World Haskell  Blog Archive  Real-world Haskell: it&#8217;s time!, http://tinyurl.com/2ddm5b
23:59:24 <wli> kolmodin: It sounds like it's got things I want.
23:59:25 <Saizan> ski: ah, so i've a functor F : Kleisli IO -> Haskell with F (X -> Y) = X -> IO Y ?
23:59:37 <ski> glguy : yes .. this kleisli category is the one you're living in and thinking in, when you think of functions returning 'IO'-actions as "returning values, *and* having a side-effect" (imperative programming in the 'IO'-monad, i.e.)
23:59:39 <Cale> Saizan: yeah
23:59:48 <kolmodin> wli: oh yes. it'll be a joy to read
23:59:53 <Cale> Saizan: furthermore, it's trivial in nature :)
