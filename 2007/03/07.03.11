00:00:48 <narain> i just tell myself "magic" and move on
00:01:09 <narain> later sometime i plan to learn magic
00:01:10 <dmwit> I put it on my "todo" list and move on.
00:01:28 <narain> so it's the asme thing :)
00:01:35 <dmwit> Right. =)
00:02:20 <dmwit> But you should see my todo list......
00:02:55 <narain> of course, magic is a large subject.
00:03:08 <narain> :)
00:03:42 <dmwit> Yes, and that doesn't even touch "deep magic".
00:04:02 <dmwit> I want to learn everything!
00:04:06 <dmwit> Sometimes this overwhelms me.
00:05:15 <narain> i know how you feel
00:05:25 <narain> one thing at a time though...
00:05:40 <narain> can't learn everything in one shot
00:09:52 <dmwit> :t foldM
00:09:55 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
00:10:13 <dmwit> :t mapM
00:10:16 <lambdabot>     Ambiguous occurrence `mapM'
00:10:16 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
00:10:27 <dmwit> :t Control.Monad.State.mapM
00:10:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
00:11:08 <narain> ?src mapM
00:11:09 <lambdabot> mapM f as = sequence (map f as)
00:11:17 <dmwit> Back to magic. =)
00:12:04 <narain> well i can partially understand this as getting a list of monads and then "sequencing" them somehow
00:12:11 <narain> :t sequence
00:12:14 <lambdabot>     Ambiguous occurrence `sequence'
00:12:14 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
00:12:19 <narain> :t Control.Monad.sequence
00:12:21 <dmwit> Yah.
00:12:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:13:08 <dmwit> Ooo, it compiles!
00:13:14 <narain> what does?
00:13:25 <narain> also, congratulations
00:13:31 <dmwit> I'm trying to understand the State monad.
00:13:34 <dmwit> ...by using it.
00:14:09 <dmwit> So I'm writing a simple program to print the Nth prime using a map to memoize the first few, and an association list to update the map as necessary.
00:14:58 <narain> it's pretty neat the way  (>>=)  does just what you want it to do in this context
00:15:17 <narain> can you hpaste your code?
00:15:49 <hpaste>  dmwit pasted "primes" at http://hpaste.org/926
00:16:08 <dmwit> It isn't prettified, but...
00:16:42 <dmwit> In particular, the input and output are interleaved in a very entertaining way.
00:17:16 <dmwit> By the way, do you know what the key that signifies EOF is for ghci?
00:17:40 <narain> dmwit: i'd guess it's platform-dependent
00:17:50 <dmwit> Mmm, yeah.
00:17:55 <narain> EOF is always Ctrl+D on *nix
00:18:00 <dmwit> Not in ghci.
00:18:07 <dmwit> (Surprise!)
00:18:16 <narain> ^D quits my ghci
00:18:23 <dmwit> C-D will quit, but it won't end getContents.
00:18:31 <narain> that's funny
00:18:57 <dmwit> Whoa!
00:19:04 <dmwit> ghc won't even touch this code.
00:19:07 <dmwit> Why?
00:19:33 <narain> what's it say?
00:19:45 <hpaste>  dmwit annotated "primes" with "GHC errors" at http://hpaste.org/926#a1
00:19:53 <newsham> hugs doesnt support top-level let right?
00:19:58 <newsham> ie "let foo = 5"
00:20:38 <narain> dmwit: hmm, do you have to link with Control.Monad.State somehow?
00:20:54 <dmwit> Time to look at the man pages.
00:21:05 <narain> ?t State.withState
00:21:05 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
00:21:10 <narain> :t State.withState
00:21:12 <lambdabot> Couldn't find qualified module.
00:21:19 <narain> :t Control.Monad.State.withState
00:21:24 <lambdabot> forall s a. (s -> s) -> State s a -> State s a
00:21:42 <narain> hey, i need to use that
00:23:06 <newsham> > runState (withState (+ 1) (do { x <- get; put (x*2); return (2*x)})) 5
00:23:08 <lambdabot>  (12,12)
00:23:25 <newsham> > runState (withState (+ 1) (do { x <- get; put (x*2); return (x*x)})) 5
00:23:27 <lambdabot>  (36,12)
00:24:44 <dmwit> Would the State monad be in a package?
00:24:54 <dmwit> (I'm really lost about how to compile this...)
00:25:38 <narain> ghci says "Loading package mtl-1.0" when trying to use State
00:25:47 <narain> maybe you could try that?
00:25:59 * narain is as clueless as dmwit though
00:26:11 <dmwit> Yep, that did it.
00:26:14 <dmwit> Nice catch.
00:26:38 <narain> i wonder if this is documented somewhere
00:27:09 <dmwit> ?hoogle map
00:27:10 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
00:27:10 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
00:27:10 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
00:27:15 <dmwit> What.
00:27:15 <sorear> night.
00:27:34 <dmwit> Is Hoogle down for anybody else?
00:28:09 <dmwit> s/Hoogle/haskell.org/
00:28:20 <sorear> dmwit: please, use --make
00:28:29 <dmwit> Ah, okay.
00:28:29 <sorear> it will save a lot of frustration
00:28:38 <dmwit> Thanks, sorear.
00:29:13 <narain> thanks sorear, i often forget that too
00:29:39 <narain> dmwit: yeah, haskell.org isn't loading for me either
00:30:39 <dmwit> Rats.
00:30:43 <dons> dmwit: you're missing the mtl package? or --make ?
00:31:05 <dmwit> dons: Both -package mtl-1.0 and --make solve the problem.
00:35:05 <narain> ?index (&&&)
00:35:05 <lambdabot> Control.Arrow
00:35:24 <dmwit> :t (&&&)
00:35:27 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:35:56 <narain> dmwit: i just use it for applying functions on tuples
00:35:57 <dmwit> I suppose (->) is an instance of Arrow?
00:36:06 <narain> yes
00:36:32 <narain> > ((+42) &&& (++"foo")) (10,"hello")
00:36:33 <lambdabot>  Couldn't match expected type `[Char]'
00:36:42 <narain> uh.
00:36:58 <narain> > ((+42) &&& (+10)) 10
00:36:59 <lambdabot>  (52,20)
00:37:10 <narain> > ((+42) *** (++"foo")) (10,"hello")
00:37:11 <lambdabot>  (52,"hellofoo")
00:37:11 <dmwit> > (show &&& (+10)) 10
00:37:13 <lambdabot>  ("10",20)
00:37:43 <dmwit> :t (***)
00:37:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
00:38:11 <dmwit> ?in (***)
00:38:12 <lambdabot> Maybe you meant: index instances instances-importing id wn
00:38:18 <dmwit> ?ind (***)
00:38:18 <lambdabot> Control.Arrow
00:38:29 <dmwit> ?hoogle Control.Arrow
00:38:29 <lambdabot> No matches, try a more general search
00:38:42 <dmwit> ?hoogle Arrow
00:38:43 <lambdabot> Control.Arrow :: module
00:38:43 <lambdabot> Control.Arrow.Arrow :: class Arrow a
00:38:43 <lambdabot> Control.Arrow.ArrowMonad :: a () b -> ArrowMonad a b
00:38:59 <dmwit> ?more
00:39:22 <narain> ?hoogle+
00:39:22 <lambdabot> Control.Arrow.ArrowApply :: class Arrow a => ArrowApply a
00:39:23 <lambdabot> Control.Arrow.ArrowChoice :: class Arrow a => ArrowChoice a
00:39:23 <lambdabot> Control.Arrow.ArrowLoop :: class Arrow a => ArrowLoop a
00:39:52 <dmwit> Bah, give me back the online docs.
00:40:05 <narain> ?docs Control.Arrow
00:40:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
00:40:08 <dmwit> Oh, hey, they're back.
00:41:26 <dmwit> > (show >>> read) 3
00:41:28 <lambdabot>  3
00:41:42 <dmwit> Huh.
00:41:47 <narain> (>>>) isn't very interesting on functions
00:41:59 <narain> it's just (.)
00:42:03 <dmwit> Well, it could be a nice replacement for (.) in some places.
00:42:04 <narain> :t (>>>)
00:42:06 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
00:42:13 <dmwit> I think it's flip (.), no?
00:42:24 <narain> oh that's true
00:42:59 <narain> do we have a  flip $ ?
00:44:10 <dmwit> Haha, look at all those punctuations...
00:44:22 <dmwit> (^>>) (>>^) (<<<) (<<^) (^<<) ...
00:44:55 <dmwit> Wait, these are all the same thing...
00:45:30 <narain> ?src (^>>)
00:45:31 <lambdabot> f ^>> a = arr f >>> a
00:45:51 <DRMacIver> Sigh. Parsers are hard. :)
00:45:53 <dmwit> f ^>> a === a . f
00:45:59 <DRMacIver> (Or rather, I'm being an idiot)
00:46:17 <dmwit> Well, I guess that's only true for functions f.
00:46:20 <narain> dmwit: iff the arrow in question is (->)
00:46:25 <dmwit> Yeah.
00:46:35 <dmwit> What other arrows are there?
00:46:45 <narain> ?instances Arrow
00:46:46 <lambdabot> (->), Kleisli m
00:46:59 <dmwit> So, just monads and functions.
00:47:08 <narain> supposedly there are others: http://www.haskell.org/arrows/
00:47:09 <lambdabot> Title: Arrows: A General Interface to Computation
00:47:52 <narain> "hyperfunctions" are arrows :D
00:48:28 <dmwit> Okay, I'm going to stick to monads for now.
00:48:39 <narain> anything prefixed with "hyper" is amusing... like the person in charge of naming got overenthusiastic
00:48:56 <dmwit> narain: Have you seen the "Clarkkkson" page?
00:49:05 <narain> no
00:49:06 <dmwit> ...and ensuing discussion on the xkcd forums?
00:49:17 <narain> never heard of it
00:49:19 <narain> link?
00:49:29 <dmwit> There's quite a bit of debate there about the hyperfactorial...
00:49:34 <narain> @go clarkkkson
00:49:36 <lambdabot> http://www.lab6.com/old/school/yearbook/clarkkkkson.html
00:49:36 <lambdabot> Title: Further Lynz Explanation and the Clarkkkkson
00:50:10 <dmwit> http://blag.xkcd.com/2007/01/11/the-clarkkkkson-vs-the-xkcd-number/
00:50:12 <lambdabot> Title: xkcd » Blog Archive » The Clarkkkkson vs. the xkcd Number, http://tinyurl.com/35384p
00:51:08 <narain> yeesh. this looks like a job for scott aaronson
00:51:27 <dmwit> The ramblings of Clarkson are pretty amusing.
00:52:19 <narain> i'm reading the clarkkkkson page right now
00:52:36 <dancor> i would like to build an hsql app for mac os x intel core duo on my linux machine.  1) i couldn't find target platform flags in ghc doc "4.17 flag reference"   2) can i link statically or some such so that the end user doesn't need to have installed hsql?
00:53:39 <dons> yeah
00:53:45 <dons> by default the app will be linked statically, afaik
00:53:52 <dons> otherwise -static -optc-static
00:54:05 <narain> hmm, n! is roughly O(n^n) right?
00:54:18 <dons> > 100!
00:54:19 <lambdabot>  Parse error
00:54:21 <narain> i had tried to work it out once but i couldn't quite get it right
00:54:26 <dons> > 100 ^ 100
00:54:27 <dmwit> Yes, n! is O(n^n), but it isn't tight.
00:54:28 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
00:54:37 <dons> > product [1..100]
00:54:38 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
00:54:47 <dons> > length $ show $ product [1..100]
00:54:49 <lambdabot>  158
00:54:51 <dancor> dons: i think actually looking now   -static  -optc -static   but ok cool
00:54:52 <dmwit> > 100 * log 100
00:54:54 <lambdabot>  460.51701859880916
00:54:59 <dons> > length $ show $ 100 ^ 100
00:55:01 <lambdabot>  201
00:55:04 <dmwit> > log $ product [1..100]
00:55:05 <lambdabot>  363.73937555556347
00:55:25 <dmwit> Oh, wrong log, huh?
00:55:27 <dmwit> > log 10
00:55:29 <lambdabot>  2.302585092994046
00:55:37 <narain> i know log n! = O(n log n) but i believe that doesn't imply n! = O(n^n)
00:55:49 <dons> > logBase 2 10
00:55:51 <lambdabot>  3.3219280948873626
00:55:58 <dmwit> > logBase 2.718281828 10
00:55:59 <lambdabot>  2.3025850933828913
00:56:15 <narain> > logBase 10 $ product [1..100]
00:56:16 <dons> > exp 1
00:56:16 <lambdabot>  157.97000365471575
00:56:18 <lambdabot>  2.718281828459045
00:56:24 <narain> > logBase 10 $ product [1..200]
00:56:25 <lambdabot>  Infinity
00:56:30 <dmwit> =D
00:56:32 <augustss_> > 10^10 * exp (-10) * sqrt (2*pi*10)
00:56:33 <lambdabot>  3598695.6187410364
00:56:47 <augustss_> > product [1..10]
00:56:49 <lambdabot>  3628800
00:57:20 <dmwit> Wow, you have the approximation memorized?
00:57:25 <augustss_> of course
00:57:35 <augustss_> :)
00:57:39 <dmwit> augustss_++
00:58:40 <DRMacIver> Hm. GHC can generate some really unhelpful error messages once you get past the trivially wrong bits. :)
00:58:41 <narain> dmwit: are you sure n! = O(n^n)?
00:58:59 <dmwit> narain: n! < n^n, therefore it is O(n^n).
00:59:10 <dmwit> But like I said, that doesn't mean that n^n is a tight bound.
00:59:11 <ivanm> narain: there is an approximation, stirlings I believe
00:59:13 <augustss> narain, yes, since O doesn't mean that it's tight
00:59:16 <ivanm> @google stirling approximation
00:59:19 <lambdabot> http://mathworld.wolfram.com/StirlingsApproximation.html
00:59:19 <lambdabot> Title: Stirling's Approximation -- from Wolfram MathWorld
00:59:37 <narain> dmwit: oh right, that's stupidly obvious, damn
00:59:48 <dmwit> ivanm: That was what augustss typed above... O_o
00:59:51 <narain> yeah, an upper bound is what i meant
01:00:58 <augustss> n! = theta(n^n*exp(-n)*sqrt(2*pi*n))
01:01:09 <ivanm> dmwit: whoops, camein late to the conversation
01:01:33 <dmwit> But yeah, Stirling's is pretty darn neat.
01:02:03 <augustss> except if you try to use the correction factors beyond that expression
01:02:27 <ivanm> lol
01:02:33 <augustss> then it starts getting nasty because they have very bad convergence properties
01:02:42 * ivanm had to use stirlings a lot for statistical mechanics
01:04:09 <narain> it's amusing how the clarkkkkson page keeps trying to drive home the fact that infinity is indeed very very large, larger than any finite number in fact
01:04:18 <narain> well of course it is silly
01:04:37 <narain> "a final, unbelievable fact is that when compared to infinity, The Clarkkkkson is tiny."
01:04:41 <narain> ha
01:05:18 <dmwit> I thought it was pretty funny that he had to resort to so many different techniques to make a big number.
01:06:15 <narain> so was any consensus achieved regarding the clarkkkkson vs the xkcd number?
01:06:30 <dmwit> I've seen arguments on both sides, but I don't have enough math to judge which is right.
01:06:36 * ivanm couldn't be bothered reading all of it
01:06:51 <dmwit> Specifically, I don't really understand up-arrow notation and its relationship to the hyper operator.
01:07:41 <narain> ok...
01:10:36 <narain> i love the fact that graham's number is the best known upper bound to something whose best lower bound was, for a long time, six
01:11:00 <dmwit> Wasn't there some kind of "worst bound ever" prize for that?
01:11:00 <ivanm> @google grahams number
01:11:03 <lambdabot> http://www-users.cs.york.ac.uk/susan/cyc/g/graham.htm
01:11:03 <lambdabot> Title: factoids > Graham's number
01:11:11 <rahikkala> narain: For very large values of "best"
01:11:27 <narain> for more than 30 years, in fact, mathematicians knew that 6 <= N* <= g_64
01:12:09 <narain> that page is outdated, btw
01:12:20 <narain> the best known lower bound now is 11
01:12:35 <narain> and evidence suggests that it is larger
01:12:36 <narain> http://mathworld.wolfram.com/GrahamsNumber.html
01:12:37 <lambdabot> Title: Graham's Number -- from Wolfram MathWorld
01:13:08 <dmwit> Is the upper bound still g_64?
01:13:13 <narain> yes
01:13:37 <narain> in the words of graham and rothschild, "clearly there is room for improvement here"
01:13:45 <dmwit> lol
01:14:08 <dmwit> It could take a long time to find the answer at this rate.
01:14:26 <narain> if the plan is to narrow down the range then yes :D
01:14:46 <ivanm> how can you have an upper bound on infinity? :s
01:14:53 <ivanm> can't you just have g_64+1?
01:14:55 <dmwit> aleph_1?
01:15:07 <ivanm> is a countable infinity
01:15:15 <ivanm> whoops, that's aleph_0
01:15:43 <dmwit> Right, so aleph_1 is an upper bound on aleph_0...
01:15:49 <dmwit> It's a little nonsensical, I guess.
01:16:01 <dmwit> Where did that question come from, by the way?
01:16:03 <dancor> aleph_0 is also an upper bound on aleph_0 :)
01:16:12 <narain> is it known whether the cardinality of the reals, |R|, equals aleph_1?
01:16:20 <dmwit> omega+1 is, too.
01:16:21 <dancor> aleph_0 is not a quantity that needs further quantification :)
01:16:29 <narain> i recall it was an unsolved problem
01:16:45 <dmwit> aleph_1=2^{aleph_0}?
01:16:54 <narain> i think so
01:17:03 <dancor> narain: |R| = 2^{aleph_0}
01:17:13 <dmwit> I think the open problem is:
01:17:21 <sieni> dancor: yes, a definition of a limit ordinal actually is that it is the least upper bound of itself (typically ordinals are defined so that they are equal to the set of limit ordinals smaller than itself)
01:17:25 <dmwit> does there exist some cardinality between aleph_0 and aleph_1?
01:17:32 <narain> well... i remember aleph_1 being defined as the smallest cardinality larger than aleph_0
01:17:34 <augustss> narain: the contiuum hypothesis has been resolved
01:17:35 <sieni> dmwit: no
01:17:35 <dancor> what is "unsolved" is if there are "infinities in between".  it turns out to be consistent either way
01:18:39 <dmwit> sieni: err... which statement are you replying "no" to?
01:18:48 <augustss> @seen dons
01:18:48 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 22m 32s ago.
01:18:56 <dancor> i think ppl usually decide the interim infinities away
01:19:07 <sieni> dmwit: that if there exists a cardinality between aleph_0 and aleph_1
01:19:38 <sieni> dmwit: aleph_1 is by definition the successor cardinal of aleph_0, i.e. the smallest cardinal larger than aleph_0
01:20:00 <dmwit> siene: Maybe I should have said, "Does there exist a cardinal between aleph_0 and 2^{aleph_0}?" instead.
01:20:23 <sieni> dmwit: ok.
01:21:38 <edwardk> dmwit: as i recall, there isn't a good way to evaluate the relative sizes of the power set of the naturals and of the real numbers, so the use of aleph 1 for either is a convention
01:22:26 <edwardk> so you have to step outside of the system and adopt another axiom to decide if you can put them into correspondence
01:23:22 <sieni> edwardk: on the contrary, it's rather easy to prove that there is a bijection between P(N) and R
01:23:43 <dancor> decimal expansion!
01:23:48 <sieni> edwardk: and aleph_1 is never used to denote their cardinality unless one assumes the continuum hypothesis
01:23:48 <edwardk> ok, maybe i'm an idiot then, just remembered tripping over that at one point
01:24:16 <sieni> usually the cardinality of the reals is denoted with c or 2^{\aleph_0}
01:24:24 <dancor> ugh logic always ruins math :)
01:24:37 <edwardk> fair enough
01:26:28 <edwardk> heh, anyways the extra 'axiom' i was remembering WAS the continuum hypothesis =)
01:27:25 <dmwit> I vote we argue about the axiom of choice next.
01:27:33 <edwardk> haha
01:27:40 <narain> the axiom of choice is obviously true
01:27:43 <edwardk> i'll pass on that one =)
01:27:46 <dancor> we didn't even get to hilbert's second problem
01:27:55 <dmwit> Nah, how can you make infinitely many choices at once?
01:27:56 <dancor> edwardk: that's your choice
01:28:26 <narain> the axiom of choice is obviously true, the well-ordering principle is obviously false, and who can tell about zorn's lemma?
01:28:28 <edwardk> dancor: heh, while you reserve the right to make an infinite number of other ones.. i understand ;)
01:28:41 <Cheery> aww. why communication is always kept in safe limits?
01:28:48 <dmwit> Hey, what's yellow, sour, and equivalent to the axiom of choice?
01:28:57 <dmwit> Zorn's Lemon!
01:28:57 <narain> zorn's lemon?
01:29:03 <edwardk> *groan*
01:29:19 <narain> what's the contour integral around western europe?
01:29:20 <dmwit> Hey, at least we aren't doing the abelian grape series...
01:29:37 <dmwit> Oh god, there better not be Poles involved.
01:29:44 <narain> damn
01:29:56 <dmwit> Better tell the punch line, now, narain.
01:30:07 <dancor> sum of poles
01:30:12 <narain> zero, because all the poles are in eastern europe
01:30:15 <narain> !
01:30:24 <narain> bah
01:30:25 <dancor> whew!
01:30:31 <dmwit> Damn.
01:30:42 <dmwit> I'm laughing right now, but I hate to admit it.
01:30:55 <dancor> so cross compiling with ghc would involve just passing a bunch of args to gcc underneath?
01:31:02 <edwardk> haha
01:31:06 <dancor> or something more or less
01:31:13 <narain> mathworld has a whole mathematical humour category
01:31:40 <dmwit> > nub "humour"
01:31:41 <lambdabot>  "humor"
01:31:50 <dmwit> Much better. =)
01:31:52 <narain> >:(
01:32:00 <narain> good one, though
01:34:09 <dmwit> > assert False "hi!"
01:34:10 <lambdabot>   Not in scope: `assert'
01:36:25 <narain> ?pl \lists -> tail (head lists) : tail lists
01:36:26 <lambdabot> ap ((:) . tail . head) tail
01:36:39 <augustss> dancor: no, it's not that easy.  ghc knows too much about gcc and what it generates
01:36:41 <narain> :t ap
01:36:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:36:56 <narain> ?src ap
01:36:56 <lambdabot> ap = liftM2 id
01:37:12 <dmwit> :t \ls -> tail (head ls) : tail ls
01:37:14 <lambdabot> forall a. [[a]] -> [[a]]
01:37:19 <augustss> :t liftM2 ($)
01:37:22 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
01:37:30 <dmwit> Oh, I see.
01:47:54 <dancor> augustss: so is it basically too hard for mortals
01:49:18 <augustss> dancor: I've never tried.  The non register version of the C code should be fairly portable.  But you have to have your cross toolchain set up just right to get linkers and stuff.
01:49:39 <augustss> I think thc ghc wiki contains information on cross compiling.
01:55:33 <xpika> whats haskell library can capture the keyboard easily?
01:56:49 <dmwit> xpika: What are you looking for?
01:57:03 <dmwit> The standard library has things like getChar and so forth...
01:57:07 <xpika> mouse captures and keyboard
01:57:19 <xpika> for use with x11
01:57:35 <dmwit> Have a look at gtk2hs.
01:57:42 <MarcWebe1> xpika: You might want to have a look at xev, but that is not haskell.
01:57:56 <xpika> MarcWebe1: ok
01:58:36 <norpan> are you looking to capture ALL keyboard and mouse events?
01:58:39 <dmwit> Also, maybe wxHaskell.
01:59:50 <norpan> if so (not just for your applicatino window), then you probably have to use the XTEST extension of the X11 server
03:31:58 <dons> sjanssen: ah, so I sorted out my firefox issue too! :-)
03:32:10 <dons> it just hppens that we can't deal at all with some race conditions in X
03:32:15 <dons> so we ignore those events entirely
03:32:19 <dons> (xSetError*)
03:32:24 <dons> and away our problems go
03:33:30 <dons> sjanssen: you'll need to update X11-extras (the XError stuff is hairy,  int (*XSetErrorHandler(int (*handler) (Display *, XErrorEvent *)))(), so I just wrote it in C, rather than trying to work out the FunPtr issues
03:33:53 <dons> or, as Sven says in the X11 src, "This really sucks."
03:34:35 <dons> the nice result is that we can kill and remove windows with impunity now
03:34:44 <dons> without worrying about race conditions on the xevents
03:35:20 <dons> so.. xmonad is now officially 'usable', imo (for laptops)
03:40:17 --- mode: ChanServ set +o dons
03:40:25 --- topic: set to '["The Haskell programming language: wow, the code just works!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
03:40:30 --- mode: ChanServ set -o dons
03:49:27 <fuzan> is there a way to mix record-like syntax with more complicated algebraic types?
03:49:54 <fuzan> i'm trying to instantiate an object type which is either a ship, projectile, or asteroid (for now)
03:50:20 <nornagon> sounds like you want a typeclass
03:50:35 <fuzan> i can do something like, data Object = Ship { .. } | Projectile { .. } | Asteroid { .. }
03:50:49 <fuzan> hmm
03:51:06 <dons> sure, go nuts
03:51:31 <fuzan> however, ASteroid for example is no longer a type
03:51:37 <xerox> data Ship = S ...; data Projectile = P ...; data Asteroid = ...; class ThingInSpace t where ...; instance ThingInSpace Ship where ...; etc.
03:52:03 <syntaxfree> strategy A:
03:52:14 <fuzan> but still, one couldn't make a list of objects
03:52:44 <xerox> You can make an union type and make lists of that type.
03:53:08 <fuzan> i've been trying to union them via the abstract types. I'm unsucessful tho :)
03:53:21 <syntaxfree> worddistro = Data.Map.fromList . map (\x->(x, length . filter (==x))) . words
03:53:28 <nornagon> data Object = ObjShip Ship | ObjProj Projectile | ObjAsteroid Asteroid
03:53:37 <syntaxfree> strategy B: starting from an empty of singleton map and build recursively (explicitly)
03:53:45 <syntaxfree> is there a significant gain from using strategy B?
03:53:48 <fuzan> yah, i had something like that, yet .. it's ugly :\
03:57:55 <Heffalump> I don't suppose anyone has any utility code to read PDB files (Palm databases)?
04:24:26 <malcolmw> dons, dcoutts, anyone else interested in google summer of code
04:25:22 <malcolmw> I'm trying to come up with a template for student proposals, based on what apache are asking for
04:26:05 <ArthurClemens> Can I search the #haskell archives someplace?
04:26:17 <dons> malcolmw: right?
04:26:30 <dcoutts> ArthurClemens, see the url in the topic
04:26:39 <dons> malcolmw: I seem to recall discussoins about what kind of guidance we were giong to offer last year
04:26:45 <dons> ?logs
04:26:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
04:26:56 <dons> ArthurClemens: they're also available via darcs (500M download)
04:26:59 <dons> ?where darcs-logs
04:26:59 <lambdabot> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/irc-logs
04:27:00 <ArthurClemens> Yes, but I don't see a search interface
04:27:14 <malcolmw> dons: any idea how far back I should look in the logs?
04:27:16 <dcoutts> malcolmw,  yes, there should be lots of info in the archives of our SoC mailing list from last year
04:27:17 <ArthurClemens> 500M, phew
04:27:38 <dcoutts> ArthurClemens, google is a pretty good search interface for it
04:27:39 <malcolmw> dons: archives?
04:27:47 <ArthurClemens> ok
04:27:49 <dons> malcolmw: it was on the mailing list. or in the mail I sent after SF Google Summit?
04:27:58 <dons> dcoutts: did you get my mail re. maps and so on?
04:29:02 <malcolmw> dons: will have a look at my own mail archive of soc-mentors, but I only joined the list after it was all decided
04:29:04 <yuesefa> hi. im confused about one stuff. since i can print a sentence on my screen. why do we call haskell a pure functional language?
04:29:21 <eulero> do you know of any efficient prime numbers library?
04:29:30 <dons> malcolmw: hmm, reading my report it doesn't mention the discussion about how we'd like to emphasise more strongly the need to work on libs and tools
04:29:33 <dons> not games and so on
04:30:05 <ArthurClemens> perhaps the answer to my question is simple... I am replacing a couple of tokens from a template text. Now this code is pretty ugly: I shouldn't need those temporary variables:
04:30:07 <ArthurClemens> let r0 = templateText
04:30:07 <ArthurClemens>   let r1 = replace "#USERNAME#" wikiName r0
04:30:08 <ArthurClemens>   let r2 = replace "#FIRSTNAME#" firstName r1
04:30:08 <ArthurClemens>   let r3 = replace "#LASTNAME#" lastName r2
04:30:12 <dons> yuesefa: side effects are encapsulalted in monadic code, the core of the language is pure.
04:30:42 <malcolmw> dons: here are the four questions I have so far, based on apache's guidelines (which perhaps seem overly prescriptive)
04:30:52 <malcolmw> Describe the project you propose to do.
04:31:02 <malcolmw> How much relevant experience do you have?  e.g. Have you coded anything
04:31:02 <malcolmw> in Haskell?  Have you contributed to any other open source software?
04:31:14 <eulero> any good library for prime numbers in Haskell?
04:31:19 <malcolmw> Why do you think you would be the best person to tackle this project?
04:31:23 <yuesefa> dons: the core of the language doesn't include the monadic code?
04:31:25 <dons> malcolmw: ok. yes.
04:31:28 <malcolmw> What deliverables do you think are reasonable targets to achieve?
04:31:28 <malcolmw> Can you outline an approximate schedule of milestones?
04:31:37 <dons> yuesefa: if it doesn't have IO in its type, its pure :-)
04:31:40 <ArthurClemens> If I write let result = replace "#USERNAME#" wikiName result I get a stack overflow
04:31:58 <yuesefa> dons: got it.
04:32:06 <dons> eulero: I don't know of one. there's many many ways to write prime sieves though
04:32:10 <dons> eulero: here, http://www.cse.unsw.edu.au/~dons/code/nobench/spectral/primes/
04:32:11 <lambdabot> Title: Index of /~dons/code/nobench/spectral/primes
04:32:21 <eulero> also, http://www.cafepress.com/haskell seems to be a 404 page
04:32:33 <dons> oh, was that linked from haskell.org ?
04:32:48 <dons> (feel free to edit/remove dead links on the wiki f you find them)
04:33:33 <eulero> dons: it's an entire page linking to a non existing page: http://www.haskell.org/haskellwiki/Merchandise
04:33:34 <lambdabot> Title: Merchandise - HaskellWiki
04:35:04 <eulero> dons: which implementation was the faster? http://www.cse.unsw.edu.au/~dons/code/nobench/spectral/primes/
04:35:05 <lambdabot> Title: Index of /~dons/code/nobench/spectral/primes
04:35:25 <dons> I can't recall :-) grab the code and check for yourself
04:35:36 <dons> I think ONeillPrimes.hs  was pretty good
04:37:25 <ArthurClemens> So my question is actually: can I concatenate those "replace" function calls while passing the result?
04:38:18 <dons> sounds like a fold
04:40:56 <malcolmw> dons: found your forward of the NetBSD organisation of SoC, it seems to have some useful material about its student application template
04:41:54 <dons> ArthurClemens: something like:
04:41:57 <dons> foldl (\r (s,f) = replace s f r) templateText $
04:41:58 <dons>     [("#USERNAME#", wikiName),("#FIRSTNAME#",firstName),("#LASTNAME#",lastName)]
04:42:15 <dons> malcolmw: yeah, the NetBsd guys are pretty organised.
04:43:58 <ArthurClemens> dons: thanks, I will dive into this direction
04:46:04 * dons wonders what ArthurClemens is up to?
04:46:08 <dons> hacking up a wiki?
04:46:42 <ArthurClemens> um no, couldn't envision that yet
04:47:16 <ArthurClemens> I am hacking up a small program to create wiki user pages from a csv file
04:47:47 <ArthurClemens> got it running, but I want to make it more haskell like
04:48:00 <ArthurClemens> its a way to learn the language
04:49:51 <ArthurClemens> the fold works great. '=' should be '->'
04:50:07 <dons> ah oops, yes
04:58:36 <benja_> @where cabal
04:58:36 <lambdabot> http://www.haskell.org/cabal
04:59:50 <adamjones> newbie question: does the emacs haskell-mode have any kind of send-function-definition-to-REPL facility a la common lisp and slime? I don't see anything but want to be sure.
05:01:33 <vincenz> dons: tried the context thing mentioned in my blog?
05:01:34 <vincenz> dons: it's great
05:01:43 <dons> oh?
05:01:46 <dons> 'context'?
05:01:51 <vincenz> dons: I save my context in vim
05:02:01 <vincenz> that way when I do CTRL+s when I launch vim, I have all my tabs  back
05:04:32 <Saizan> adamjones: you can't load a single definition at a time, but you can load the whole file in ghci using C-c C-l
05:05:20 <dons> I don't think I wrote about vim did I??
05:05:35 <vincenz> dons: erm you use vim, no?
05:05:48 <dons> i do
05:06:02 <vincenz> well I thought you might like the context-saving :)
05:06:03 <vincenz> http://notvincenz.blogspot.com/2007/03/vim-sessions.html
05:06:05 <lambdabot> Title: lambda.oasis: Vim Sessions
05:06:06 <xbagz> hi guys, i cant recall reading something about ghc printing out prettified haskell code from its input. anyone know this flag?
05:06:49 <dons> xbagz: -ddump-parsed, iirc
05:06:50 <adamjones> Saizan: thanks, that is what I needed.
05:06:55 <dons> ?wiki Indent
05:06:55 <lambdabot> http://www.haskell.org/haskellwiki/Indent
05:06:59 <dons> xbagz: covers the topci 6^
05:07:44 <malcolmw> here's what I have so far: http://hackage.haskell.org/trac/summer-of-code/wiki/StudApply
05:07:45 <xbagz> dons, thanks! this will fix my messsed up identations =D
05:07:48 <lambdabot> Title: StudApply - Haskell.org Google Summer of Code - Trac
05:07:59 <dons> looking...
05:08:53 <dons> malcolmw: ok. that's good.
05:09:31 <dons> do we state anywhere for the students our preferences for libraries and tools?
05:09:32 <malcolmw> dons: the netBSD people ask for a lot more detail, e.g. what kernel APIs will you be using
05:09:53 <malcolmw> dons: oh. good point  I could put that at the top of the page
05:10:45 <dons> i.e. they're highly unlikely to be accepted unless they're working on infrastructure, really.
05:10:59 <dons> on libs, packages, compilers.
05:13:49 <malcolmw> "For this year's Google Summer of Code, Haskell.org is particularly keen to see proposals for work on libraries, compilers, and tools, that is, infrastructure to support the growth of the language, rather than (say) applications that merely use Haskell."
05:14:13 <dcoutts> malcolmw, sounds right
05:14:41 <dons> sounds good to me.
05:15:03 <dons> as we found last year, any hints we give are very influential
05:15:21 <dons> we could even piont to the list of accepted projects last year
05:16:17 <dons> malcolmw: here, http://code.google.com/soc/2006/haskell/about.html
05:16:19 <lambdabot> Title: Google Code - Summer of Code - Organization Information
05:16:54 <malcolmw> dons: those are only the successful ones
05:17:42 <dons> yes, i see. still, just seeing those, and the technical depth we preferred, might be useful ?
05:19:42 <malcolmw> dons: oh right, yes I didn't think to click on the projects themselves, which do indeed give a good model for applications.  will make this more explicit
05:24:04 <malcolmw> OK, I think I'm ready to fill in the application form for Google now.  We can apply up to 5 times, if anyone thinks of something new to add before tomorrow.
05:29:19 <dons> go for it!
05:31:11 <montpelier> can someone help me out with understanding some points free stuff?
05:31:44 <montpelier> i fed lambdabot this: pl \x g y -> (x, g y)
05:32:00 <montpelier> and it gives me (.) . (,)
05:32:29 <montpelier> which is very cute, but i can't quite get my head around how it works
05:33:12 <montpelier> example: ((.) . (,)) 5 (+1) 3 => (5,4)
05:33:18 <vincenz> montpelier: ok
05:33:36 <vincenz> ((.) . (,)) x == (.) (x,)
05:33:50 <vincenz> (.) (x,) == \f -> (x,) . f
05:33:55 <vincenz> so when applied to g we get
05:33:58 <vincenz> (x,) . g
05:34:02 <vincenz> when we apply this to y
05:34:11 <vincenz> we get ((x,) . g) y == (x, g y)
05:34:31 <dons> ?src (.)
05:34:32 <lambdabot> (.) f g x = f (g x)
05:35:14 <montpelier> fantastic ... thanks ... it was the first equation i was missing (i think)
05:41:54 <dons> here, with missing steps, just eta expand, beta reduce and inline till you're done:
05:41:58 <dons> (.) . (,)
05:42:00 <dons> (.) (.) (,)
05:42:03 <dons> (\f g x -> f (g x)) (.) (,)
05:42:05 <dons> (\g x -> (.) (g x)) (,)
05:42:08 <dons> \x -> (\f g y -> f (g y)) ((,) x)
05:42:11 <dons> \x -> (\g y -> ((,) x) (g y))
05:42:13 <dons> \x g y -> ((,) x) (g y))
05:42:15 <dons> \x g y -> (x,) (g y)
05:42:18 <dons> \x g y -> (x,g y)
05:42:37 <dons> using (.) f g x = f (g x)
05:42:50 <dons> == (.) = \f g x -> f (g x)
05:43:32 <dons> purity rocks :-)
05:43:35 <montpelier> thanks dons
05:45:17 <dons> oh, I did two things on line 5, not showing the reduction, to, (\x -> (.) ((,) x))
05:46:13 <dcoutts> there must be some kind of equational reasoning assistant around somewhere
05:46:29 <dcoutts> where you can interactively do transformations
05:46:34 <dcoutts> make new rules etc
05:46:49 <dons> yeah. so there's some connection to refactoring
05:46:59 <vincenz> dcoutts: I bet t would be doable with plt-redex
05:47:02 <vincenz> s/t/it
05:47:14 <dcoutts> apply strategies, like simplify = beta-reduce*
05:47:51 <dons> night all!
05:47:58 <vincenz> nigt dons
05:48:00 <dons> see you in sydney duncan...! :-)
05:48:23 <dcoutts> dons, yay :-)
05:48:35 <vincenz> dcoutts: ooh nice
05:48:37 <dcoutts> not long now...
05:48:43 <dcoutts> (only 2 days travel)
05:49:09 <dons> :-) hey i do it 3 or 4 times a year, its not so bad :-) (ok, it is.)
05:49:28 * dons `ap` sleep
05:49:39 <malcolmw> hmm, I'm getting confused by the Google mentor application form
05:50:03 <malcolmw> After pressing 'submit', I seem to get the same page again
05:50:28 <malcolmw> complete with 'you have 5 applications left' at the top (which surely ought to have decreased to 4)
05:50:56 <adamjones> probably a badly done "oops, you forgot to fill in X"
05:51:47 <adamjones> that or they added a "break your way out of a recursive loop" test as step 0.5
05:51:54 <malcolmw> adamjones: right first time
05:52:18 <malcolmw> there was an "invalid email" flag in a tiny font, not even red
05:52:26 <adamjones> nice
05:52:35 <merus> Is there a better way to get "apply f to x, n times" than (iterate f x) !! (n-1)?
05:52:41 <vincenz> anyone know jethr0's email?
05:53:12 <adamjones> malcolmw: darn, I liked my second answer better.
05:53:17 <malcolmw> yay! submission form complete and accepted
05:55:37 <adamjones> ok, this is literally my first hour with Haskell, but I already like how lists are handled. None of Python's "lets pack everything+kitchen sink into a list and access by offset when we have perfectly useful dictionaries/object attributes"
05:55:54 <adamjones> just thought I'd share that.
05:59:55 <emu> > iterate (+1) 1 !! 0
05:59:57 <lambdabot>  1
06:04:01 <kolmodin> Igloo: some of the ghc-extralibs libraries seems to be inconsistant of which versions they are. fgl's cabal file says it's 5.3 while the Makefile says 5.2
06:05:52 <dcoutts> kolmodin, there's lots of inconsistency between the two build methods sadly
06:05:52 <Igloo> kolmodin: OK; hopefully the Makefile versions will disappear RSN from the HEAD anyway
06:06:30 <dcoutts> kolmodin, in that case, I'd take the .cabal version as the true one
06:06:40 <dcoutts> just because it's the later version
06:06:52 <dcoutts> the later version number
06:07:10 <dcoutts> so it probably indicates that someone updated the .cabal file and not the Makefile
06:07:31 <Igloo> dcoutts: Well, if you want to depend on fgl >= x then you want 5.2
06:07:40 <dcoutts> so use the later one for the ebuild version number
06:07:41 <dcoutts> hmm
06:08:10 <kolmodin> I figured. sadly it means that if you install the packages along with ghc 6.6 using the makefiles you get the wrong version number
06:08:23 <dcoutts> kolmodin, right.
06:08:43 <kolmodin> ie, more or less all ghc 6.6 installations out there has got it wrong
06:08:55 <kolmodin> except for the gentoo ones. yay
06:18:34 <malcolmw> does anyone know if the Cabal file format permits comments (e.g. with a leading # character)
06:19:28 <kolmodin> malcolmw: yes, leading --
06:19:45 <malcolmw> kolmodin: ah, great, thank you
06:20:11 <kolmodin> np
06:29:36 <emk_> dons: I posted a followup message to the libraries list, re: error-reporting conventions.
06:30:24 <emk_> I don't know if it will make it through gmane.
06:30:48 <Eelis> if you're eric kidd, it has
06:30:53 <emk_> Cool!
06:36:37 <Shurique> how do you get the nth element of a list?
06:37:10 <Eelis> > [2,3,1,5,6,3,2] !! 3
06:37:11 <lambdabot>  5
06:37:32 <Shurique> thanks :)
06:40:10 <merus> > liftM2 (:) [1,2,3] [[1],[2],[3]]
06:40:12 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
06:44:40 <Botje> > replicateM 2 [1,2,3]
06:44:41 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
06:45:46 <merus> I'm not well versed in the ways of Control.Monad, heh.
06:46:42 <tom_> Hi all
06:46:51 <uccus> I was wondering if among the error reporting conventions any encompasses all the advantages of the others
06:47:27 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/927
06:48:33 <tom_> I've got a pretty beginerish question, I've created a combined state and writer monad using StateT and i'm trying to make it an instance of MonadWriter so I don't have to use lifts all over my code
06:48:35 <DRMacIver> Hm. I used to think ghci was a bit rubbish, but it's actually extremely helpful for testing code even if it doesn't work as a proper repl.
06:48:51 <tom_> This is what i have so far: http://hpaste.org/927 but I'm getting a type checker error
06:49:00 <tom_> Kind error: Expecting kind `* -> *', but `ProbsAndLog a' has kind `*'
06:49:43 <tom_> anyone got any ideas?
06:49:56 <arjanb> remove the 'a'
06:50:19 <Herald> could someone help me debug an algorithm to reorder a list of lists?
06:50:21 <Herald> http://hpaste.org/928
06:50:30 <Herald> sorta works but the recursion doesnt terminate
06:51:10 <tom_> from the type, the instance, or from both?
06:51:28 <vincenz> Herald: your reorderList is wrong
06:51:30 <merus> Botje: Thanks, knowing replicateM was exactly what I needed.
06:51:37 <arjanb> from the instance
06:51:42 <vincenz> Herald: when you map tails, eventually you end up with a [[],[],[],[],[]] not a []
06:51:49 <vincenz> Herald: you need a case to detect that
06:52:03 <Herald> ok
06:52:23 <tom_> ok, that fixes that error but now it says "Type synonym `ProbsAndLog' should have 1 argument, but has been given 0"
06:52:35 <tom_> thanks for the help by the way
06:52:38 <Herald> how do i get a case to recognise an unknown length list of empty lists
06:53:00 <vincenz> > all empty [[],[],[])
06:53:01 <lambdabot>  Parse error
06:53:01 <vincenz> > all empty [[],[],[]]
06:53:06 <vincenz> @type all
06:53:07 <Saizan> tom_: you don't have to define that instance yourself
06:53:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:53:12 <vincenz> @type empty
06:53:14 <Saizan> ?instances MonadWriter
06:53:15 <lambdabot>     Ambiguous occurrence `empty'
06:53:15 <lambdabot>     It could refer to either `empty', imported from Text.PrettyPrint.HughesPJ
06:53:16 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
06:53:19 <vincenz> > all null [[],[],[]]
06:53:20 <lambdabot>  True
06:53:25 <Herald> ahhh
06:53:27 <Herald> ok thanks
06:53:49 <tom_> ah, cool
06:54:16 <hpaste>  vincenz annotated "(no title)" with "something like this" at http://hpaste.org/928#a1
06:54:46 <tom_> any idea what I'm doing wrong with my manual instance anyway? I'm sure i'll need to know this some time..
06:55:33 <Herald> vincenz - thanks very much
06:55:40 <vincenz> np
06:56:42 <Saizan> tom_: 1) type synonim must be full applied so you can't say ProbsAndLog instead of (ProbsAndLog a) but the latter has the wrong kind, 2) unless you want overlapping instances you should use a newtype instead of a type synonim
06:57:44 <tom_> oh, I see, I'm not really declaring a new type with "type" just giving an existing type a new name thefore I can't define it as an instance of a monad?
07:00:04 <Saizan> using type ProbsAndLog a = StateT [[Double]] (Writer String) a you just declare a shorthand for "StateT [[Double]] (Writer String) a", every type you use "ProbsAndLog a"  it gets replaced with the right side of the equation
07:00:46 <tom_> ok, that makes moe sense, thanks
07:01:01 <Saizan> s/type/time/
07:01:30 <Saizan> tom_: do you know what a kind is?
07:01:30 <Botje> > sequence [[1,2],[3,4,5]]
07:01:43 <tom_> no, I don't think so...
07:01:48 <Saizan> ok
07:01:52 * Botje pokes \bot
07:01:54 <Botje> is she lagged?
07:02:23 <Botje> ?src sequence
07:02:23 <lambdabot> sequence ms = foldr k (return []) ms
07:02:24 <lambdabot>     where
07:02:24 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
07:02:34 <uccus> > sequence [[1,2],[3,4,5]]
07:02:35 <Saizan> a kind is like a type of types, so for example Integer has kind *
07:02:55 <uccus> I was hoping she is just unmindful...
07:03:08 <uccus> for the moment
07:03:22 <Saizan> instead [] has kind * -> * because you apply [] to another type to build a type
07:03:24 <tom_> so * -> * indicated that it was a "uncurried" (not sure of the word) type?
07:03:36 <Botje> it works just fine locally :/
07:03:36 <Saizan> ?kind []
07:03:39 <lambdabot> * -> *
07:03:45 <Saizan> ?kind ([]) Int
07:03:47 <lambdabot> *
07:03:57 <Botje> > replicateM 2 [1,2,3]
07:03:59 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
07:04:04 <Botje> that works ..
07:04:10 <Botje> so why is sequence b0rking?
07:04:14 <tom_> nice, I had wondered about those * -> * things
07:04:19 <Saizan> tom_: a Monad is defined as something of kind * -> *
07:04:23 <Botje> > sequence_ [[1,2],[3,4,5]]
07:04:24 <lambdabot>  [(),(),(),(),(),()]
07:04:42 <merus> > map sum $ filter (\x -> x == nub x) $ replicateM 2 [1..4]
07:04:44 <lambdabot>  [3,4,5,3,5,6,4,5,7,5,6,7]
07:05:24 <tuukkah> perhaps "unapplied", as "uncurried" means (a,b) -> c as opposed to a -> b -> c
07:05:47 <Saizan> tom_: because a Monad is like a container, and it is applied to other types, in fact for example getLine :: IO String, if IO wasn't of kind * -> * you couldn't apply it to String
07:06:09 <Botje> ?kind Arrow
07:06:11 <lambdabot> Class `Arrow' used as a type
07:06:18 <Botje> ?kind ar
07:06:19 <Botje> ?kind arr
07:06:20 <lambdabot> Not in scope: type variable `ar'
07:06:21 <Botje> grr :)
07:06:23 <lambdabot> Not in scope: type variable `arr'
07:06:27 <Botje> boo.
07:06:30 <merus> :(
07:06:51 <Herald> is there a prelude function that takes (x,y) and outputs (y,x) ?
07:07:08 <Saizan> tom_: in your instance you were trying to use (ProbsAndLog a) which is of kind * as a Monad, and ghc complained
07:07:14 <Botje> @pl \(x,y) -> (y,x)
07:07:15 <lambdabot> uncurry (flip (,))
07:07:34 <Saizan> ?kind (->)
07:07:37 <lambdabot> ?? -> ? -> *
07:08:42 <tom_> if I define ProbsAndLog as "type ProbsAndLog  = StateT [[Double]] (Writer [String])" is it then of kind *->*?
07:09:02 <Saizan> yes
07:09:52 <Botje> > sequence [Just 5, Nothing, Just 3, Nothing, Nothing, Just 9]
07:10:04 <Botje> \bot _REALLY_ hates sequence, i guess
07:11:15 <vincenz> @bot
07:11:15 <lambdabot> :)
07:11:18 <vincenz> > 1
07:11:20 <lambdabot>  1
07:11:44 <tuukkah> @type sequence
07:11:46 <lambdabot>     Ambiguous occurrence `sequence'
07:11:47 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
07:11:58 <Botje> > Control.Monad.sequence [[1,2],[3,4,5]]
07:11:59 <lambdabot>  [[1,3],[1,4],[1,5],[2,3],[2,4],[2,5]]
07:12:02 <Botje> oh.
07:12:07 <Botje> why didn't you tell me then, silly \bot
07:13:53 <hpaste>  tom annotated "(no title)" with "(no title)" at http://hpaste.org/927#a1
07:15:12 <tom_> I've defined ProbsAndLog like that and now I get a different error. Looking at the source for the MonadWriter class I see it's defined as "class (Monoid w, Monad m) => MonadWriter w m | m -> w where " but I have no idea what the | and the bits after it mean...
07:17:55 <Saizan> ok, first, are you using -fglasgow-exts?
07:18:21 <tom_> no, should i be?
07:18:40 <Saizan> yes, because MonadWriter is a multi-parameter typeclass
07:19:00 <Saizan> and it's not haskell98
07:19:36 <tom_> ah, ok, that makes sense
07:20:07 <tom_> there's a pragma to turn on glassgow extensions without using the command line paramter isn't there?
07:20:19 <tom_> never mind, got it
07:24:33 <hpaste>  DRMacIver pasted "(no title)" at http://hpaste.org/929
07:24:52 <DRMacIver> I'm attempting to write a simple parser and ghc is producing some really exciting errors on the main method.
07:25:04 <DRMacIver> The rest appears to work fine when run via ghci
07:25:10 <tom_> ah, now I'm getting an overlapping instance error, I assume that means I did it right and that it's just that there is already an instance for that type
07:25:28 <DRMacIver> Current presumption is just that I don't what I'm doing in defining 'main' :)
07:25:54 <Saizan> tom_: yeah :)
07:26:06 <DRMacIver> (Please don't laugh at the parser proper. It's my first serious attempt at writing Haskell)
07:26:08 <tom_> excelent! thanks for the help
07:28:51 <Saizan> DRMacIver: what's the error?
07:28:51 <xerox> DRMacIver: btw print x = putStrLn (show x)
07:29:41 <hpaste>  DRMacIver pasted "(no title)" at http://hpaste.org/930
07:29:50 <DRMacIver> Oops, sorry. Meant to do a follow up paste of the error and then didn't. :)
07:29:54 <DRMacIver> xerox: Whoops. Thanks.
07:30:13 <DRMacIver> (You can probably see why I'm a bit bewildered by this error. :) )
07:30:27 <Saizan> ah, have you use --make to compile it?
07:30:45 <Saizan> s/use/used/
07:30:59 <DRMacIver> Ah.
07:31:01 <DRMacIver> That would be it then. :)
07:31:03 <DRMacIver> Thanks
07:31:40 <DRMacIver> Marvelous. Works now.
07:31:58 <Saizan> :)
07:32:01 <DRMacIver> (Hurray. First non-trivial Haskell program and first non-trivial parser now completed. :) )
07:32:17 <Saizan> (Yay!)
07:32:41 <DRMacIver> Oh, not quite on the former. Need to figure out how to get it to accept command line arguments. Ho hum.
07:32:42 <dmhouse> (What's with all the parentheses, this isn't #lisp!)
07:32:50 <dmhouse> ?docs System.Environment
07:32:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
07:32:54 <dmhouse> ?hoogle getArgs
07:32:55 <lambdabot> System.getArgs :: IO [String]
07:32:57 <DRMacIver> I'm a very parenthetical person. :)
07:33:03 <dmhouse> DRMacIver: try those two.
07:33:11 <dmhouse> DRMacIver: if you need flags and the like,
07:33:16 <dmhouse> ?docs System.Console.GetOpt
07:33:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
07:33:22 <DRMacIver> Thanks. I was going to google. :)
07:33:28 <Saizan> well, you could just remove those parentheses and it would just work the same :)
07:33:34 <dmhouse> You should Hoogle. http://haskell.org/hoogle
07:33:35 <lambdabot> Title: Hoogle
07:33:59 <dmhouse> It searches for Haskell functions and modules given their name (or part thereof) or type (or part thereof).
07:34:25 <dmhouse> ?localtime done
07:34:27 <dmhouse> ?localtime dons
07:34:29 <lambdabot> Local time for dons is Mon Mar 12 01:33:43 2007
07:34:35 <dmhouse> dons, still awake?
07:34:46 <vincenz> dmhouse: he left a while ago
07:34:49 <dmhouse> Okay.
07:35:43 <dmhouse> ?ask dons why, on the nobench results page, there are multiple compilers for each row that have a green background; I figured that meant 'the best result for this benchmark'.
07:35:43 <lambdabot> Consider it noted.
07:37:10 <Saizan> ?whre nobench
07:37:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench.html
07:39:35 <Saizan> well all of the green results are so close that get (1.0)
07:40:18 <dmhouse> Doesn't mean they're all the best ;)
07:40:20 <Heffalump> why is nobench distinct from nofib?
07:40:58 <ArthurClemens> is there a way to download a file from a url? FilePath doc is not clear on this...
07:41:00 <dcoutts_> Heffalump, it's a newer thing with some extra tests, more compilers and nicer output & scripts eing run by dons.
07:41:27 <Heffalump> but why not add those things to nofib?
07:41:34 <dmhouse> ArthurClemens: FilePath is only for manipulating file paths, not for actually doing anything with them.
07:41:53 <dmhouse> ArthurClemens: I'd expect you need to investigate the Network module(s).
07:42:03 <ArthurClemens> aha
07:42:36 <dcoutts_> Heffalump, it's not clear that the shootout benchmarks are that great general haskell benchmarks, and many are ghc-specific
07:42:44 <dcoutts_> Heffalump, otherwise, ask dons
07:45:14 <Heffalump> fair enough
07:54:23 <DRMacIver> Isn't FilePath just a type alias for String?
07:54:37 <DRMacIver> Or do I not understand why 'type Foo = Bar' means? :)
07:54:39 <xerox> ?src FilePath
07:54:39 <lambdabot> type FilePath = String
07:54:44 <dmhouse> DRMacIver: no, you're right.
07:54:47 <xerox> yeah
07:55:46 <dmhouse> DRMacIver: that's for historical purposes. It'd be nice to have an actual datatype for it, but certain functions (readFile, writeFile etc.) expect it to be a String.
07:56:07 <DRMacIver> Ah
07:56:25 <Heffalump> and a lot of people's code does, I bet
07:56:28 <DRMacIver> I quite like Scala's views as a solution to problems like that.
07:56:36 <DRMacIver> But they probably wouldn't fit in with Haskell. :)
07:56:39 <dmhouse> Yeah, views are being discussed.
07:56:43 <DRMacIver> Oh, cool.
07:57:02 <dmhouse> They may make it into Haskell-prime, but they're a hard thing to pin down, everyone has different ideas about how they should work.
07:59:33 <DRMacIver> Yeah, I can believe that.
08:03:18 <yts> @help
08:03:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:03:30 <yts> @version
08:03:31 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
08:03:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:30:20 <kbral> hi, any suggestions about Haskell nice IDE's with usefull debugging ?
08:34:43 <tuukkah> there are bits and pieces in ghci, emacs, eclipse, visual haskell
08:54:11 <jberg> i have a list of Maybe (Int, String) is there a sort function where i can supply a function how i would like to sort that list of Maybes?
08:55:17 <sieni> @t sortBy
08:55:18 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
08:55:26 <Saizan> i suppose you want to sort only the Just something values
08:55:29 <twanvl> :t sortBy
08:55:31 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
08:55:32 <sieni> oops
08:55:44 <Saizan> :t compare
08:55:46 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
08:56:27 <jberg> hmm ok thanks
08:56:37 <sieni> jberg: you can use sortBy and then if you want to drop the Nothings you can make the ordering such that the Nothings are in the front and then just drop them
08:57:10 <sieni> jberg: i.e. using dropWhile
08:57:31 <sieni> > dropWhile (!= Nothing) [Nothing, Nothing, Just 7, Just 5]
08:57:33 <lambdabot>   Not in scope: `!='
08:57:38 <sieni> oops
08:57:44 <sieni> > dropWhile (/= Nothing) [Nothing, Nothing, Just 7, Just 5]
08:57:46 <lambdabot>  [Nothing,Nothing,Just 7,Just 5]
08:57:57 <jberg> thanks
08:58:06 <sieni> > dropWhile (== Nothing) [Nothing, Nothing, Just 7, Just 5]
08:58:07 <lambdabot>  [Just 7,Just 5]
08:58:09 <_roconnor> > catMaybes [Nothing, Nothing, Just 7, Just 5]
08:58:09 <sieni> oops again :-)
08:58:10 <lambdabot>  [7,5]
08:58:30 <Saizan> > let f `on` g = \x y -> f x `g` f y in sortBy (compare `on` fst) . catMaybes $ [Just (3,"a"),Nothing,Just(1,"b")]
08:58:31 <lambdabot>  Couldn't match expected type `a -> Ordering'
08:59:05 <sieni> catMaybes is cool, didn't know about that
08:59:46 <Saizan> > let g `on` f  = \x y -> f x `g` f y in sortBy (compare `on` fst) . catMaybes $ [Just (3,"a"),Nothing,Just(1,"b")]
08:59:48 <lambdabot>  [(1,"b"),(3,"a")]
09:01:14 <tuukkah> > sort $ catMaybes [Just (3,"a"),Nothing,Just(1,"b")]
09:01:16 <lambdabot>  [(1,"b"),(3,"a")]
09:01:26 <kbral_> hi, any suggestions about Haskell nice IDE's with usefull debugging ?
09:30:08 <Pastorn> ?where Text.Regex
09:30:09 <lambdabot> I know nothing about text.regex.
09:30:23 <Pastorn> @instances Regex
09:30:24 <lambdabot> Couldn't find class `Regex'. Try @instances-importing
09:34:21 <Pastorn> mutanton?
09:34:29 <Pastorn> vad gÃ¶r du hÃ¤r?
09:34:44 <sorear> hi.
09:41:37 <allbery_b> @hoogle Regex
09:41:37 <lambdabot> Text.Regex :: module
09:41:38 <lambdabot> Text.Regex.Regex :: data Regex
09:41:38 <lambdabot> Text.Regex.Posix.regExtended :: Int
09:42:16 <Pastorn> i want the source... :/
09:42:39 <allbery_b> @source Text.Regex
09:42:39 <lambdabot> http://darcs.haskell.org/packages/base/Text/Regex.hs
09:46:31 <pitecus> does lambdabot have a command which does the opposite of ?pl ?
09:47:06 <allbery_b> @help unpl
09:47:07 <lambdabot> pointful <expr>. Make code pointier.
09:47:18 <pitecus> cool
09:48:14 <fasta> Can I disable the printing of Un-kinded tyvar state{tv ahkJ} in a ghc HEAD version?
09:50:04 <sorear> that's an internal consistency warning, afaik you can't even disable it in 6.6
09:50:49 <fasta> Hmm, they should release something newer.
09:50:56 <sorear> -dcore-lint say anything?
09:50:59 <sorear> fasta: ?
09:51:14 <sorear> @goo Un-kinded tyvar state
09:51:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/irc-logs/07.02.13
09:51:52 <fasta> sorear: There's a bug fixed in HEAD that my programs depend on.
09:52:27 <sorear> is it also fixed in the 6.6 branch?
09:52:50 <fasta> sorear: It's fixed in 6.6.1
09:52:53 <fasta> sorear: how do I get that?
09:53:02 <sorear> it's released?!
09:53:15 <Pastorn> allbery_b: thanks, but 404
09:53:24 <allbery_b> uhhhh
09:53:25 <sorear> not on the ghc news thingie
09:53:55 <allbery_b>  @source is broken?  or the web site?
09:53:58 <fasta> sorear: How do I know what 6.6 I have?
09:54:06 <fasta> sorear: The Glorious Glasgow Haskell Compilation System, version 6.6
09:54:14 <fasta> sorear: that's what --version gives me
09:56:08 <Pastorn> @source Language.Hasell.Parser -- gives me 404 as well
09:56:09 <lambdabot> Language.Hasell.Parser -- gives me 404 as well not available
09:56:20 <Pastorn> @source Language.Hasell.Parser
09:56:20 <lambdabot> Language.Hasell.Parser not available
09:56:27 <Pastorn> @source Language.Haskell.Parser
09:56:28 <lambdabot> http://darcs.haskell.org/packages/haskell-src/Language/Haskell/Parser.hs
09:56:28 <allbery_b> "Haskell"
09:57:04 <allbery_b> sounds like darcs.haskell.org is having problems
09:57:50 <fasta> Maybe it wasn't fixed in 6.6.1, after all.
09:58:04 <allbery_b> afaik 6.6.1 is nt released
09:58:23 <fasta> allbery_b: that's what I thought.
09:59:14 <Eelis> not being able to find documentation for System.Win32, i resorted to peeking in the .hsc files. in http://darcs.haskell.org/packages/Win32/System/Win32/Info.hsc i find the following line: "-- %fun GetUserName :: IO String" . is this %fun business intended to be processed by some preprocessor into a meaningful function definition or something?
10:00:00 <allbery_b> @source ffi
10:00:01 <lambdabot> ffi not available
10:00:04 <allbery_b> whoops
10:00:07 <allbery_b> @where ffi
10:00:08 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
10:00:12 <allbery_b> nope.  feh
10:00:39 <allbery_b> anyway, it's a haskell foreign function interface thing.  except it's commented out
10:01:45 <Eelis> i see. so is there no GetUserName or equivalent function in System.Win32, or does this comment imply that there is one elsewhere (and under a name that doesn't start with a capital) ?
10:01:59 <sorear> hello beschmi!
10:02:16 <beschmi> hi sorear. hi #haskell
10:04:48 * dcoutts -> Australia
10:05:12 <Heffalump> exciting
10:05:31 <dcoutts> @yarr!
10:05:31 <lambdabot> Yo ho ho, and a bottle of rum!
10:05:32 <sorear> beschmi: I'm working on a C haskell frontend intended only for rapid validation, no codegen.  Hopefully faster than hugs, will have pretyped libs, and (most importantly) FFI-able api.  I expect it will be useful in the shim project.
10:06:00 <thief_grr> i'm reading Hutton's book on haskell, i'm at quite the beginning.  It says that tuples of length 1, are not permitted because they would conflict with the use of parentheses to make the evaluation order explicit, such as in (1+2)*3
10:06:23 <sorear> (1,2,3) -- 3-tuple
10:06:28 <sorear> (1,2) -- 2-tuple
10:06:35 <sorear> (1) -- "1-tuple"
10:06:46 <vincenz> sorear: 1-tuples don't exist
10:06:58 <sorear> (1+2)  -- would this be 3 or a one-tuple?
10:07:01 <thief_grr> that explanation is quite silly
10:07:14 <sorear> vincenz: hence the ""
10:07:17 <vincenz> ah
10:07:17 <thief_grr> sorear: so far as i understand it's a 3, and one-tuples arent anything..
10:07:18 <vincenz> :)
10:07:41 <Botje> afaik there's no use for a one-tuple
10:07:45 <DRMacIver> I remember having an argument with one of my supervisors in the first year at uni to the effect that (3) and 3 were not the same object. :)
10:07:45 <thief_grr> i get that
10:07:56 <thief_grr> DRMacIver: what was the conclusion?
10:07:58 <DRMacIver> With the former being a 1x1 matrix.
10:08:01 <sorear> thief_grr: oh.  appearantly I misread your message as also saying "I'm not following"
10:08:31 <DRMacIver> thief_grr: The conclusion was that I was right but my supervisor belittled my entirely valid point with a "Yeah, but they're *effectively* the same thing." :)
10:08:36 <beschmi> sorear: cool, i think the eclipse-plugin people would be really happy about a FFI-able api
10:08:38 <sorear> Botje: there is a difference between tyvar and OneTuple tyvar, because all tuples in haskell are lifted
10:08:52 <thief_grr> sorear: the ambiquity is not a reason to NOT allow 1-tuples, we could just have a different notation other than (), i'm just wandering about the normal explanation behind this
10:08:57 <thief_grr> because the one in that book is a bit lame ;)
10:09:10 <DRMacIver> 'effectively the same thing' being a euphemism for 'not the same thing' :)
10:09:24 <DRMacIver> (In the same way that 'approximately equals' means 'not equals')
10:09:37 <thief_grr> DRMacIver: i seem to think of tuples in similar way with you
10:09:37 <sorear> thief_grr: haskell, for the most part, was specced before it was implemented, and there are a few odd warts because of this.
10:09:39 <DRMacIver> err. s/equals/equal/
10:09:56 <thief_grr> sorear: i did not get the "lifted"
10:10:18 <thief_grr> maybe i should just accept that n-tuples start from n=2,3.. for now and come back to it later?
10:10:25 <sorear> thief_grr: technical term... you understand laziness, _|_ ?
10:10:34 <DRMacIver> sorear: Well, it's got no excuse for this one. :) It's been a problem in all sorts of other languages prior to Haskell.
10:10:49 <sorear> thief_grr: they start from 2, much as we hate it.
10:10:52 <thief_grr> sorear: i understand laziness (i think) and if _|_ is bottom, i understand it from recursive theory courses..
10:10:58 <DRMacIver> thief_grr: Well in this particular case we were arguing about matrices and vectors. But it's much the same thing.
10:11:14 <sorear> thief_grr: ooh, recursive theory! cool
10:11:35 <sorear> thief_grr: Liftedness means that (_|_, _|_) is NOT the same as _|_
10:11:47 <sorear> thief_grr: in e.g Miranda they were the same
10:12:06 <sorear> > undefined `seq` 2
10:12:06 <DRMacIver> Hm. I hadn't thought of that.
10:12:07 <lambdabot>  Undefined
10:12:14 <sorear> > (undefined, undefined) `seq` 2
10:12:16 <lambdabot>  2
10:12:40 <DRMacIver> What does seq do?
10:12:50 <sorear> seq _|_ _ = _|_
10:12:54 <sorear> seq _ x = x
10:13:13 <thief_grr> sorear: hmm i'm sorry, but what does (_|_, _|_) not being equal to _|_ have to do with the inexistance of 1-tuples
10:13:20 <roconnor> seq is that itch on the roof of your mouth that just won't go away
10:13:36 <roconnor> @slap seq
10:13:36 <lambdabot> why on earth would I slap seq
10:13:39 <sorear> operationally, it evaluates both arguments to whnf even though the first isn't actually used - it violates laziness
10:13:51 <sorear> @remeber roconnor seq is that itch on the roof of your mouth that just won't go away
10:13:51 <lambdabot> Done.
10:14:04 <DRMacIver> Ah
10:14:15 <halassocracy> you can just accept that a number like 5 is a one-tuple
10:14:33 <sorear> thief_grr: well, because all the other tuples are lifted, (_|_,) (using python syntax) is not the same as _|_
10:14:51 <sorear> thief_grr: so Bool == { _|_, False, True }
10:15:08 <sorear> thief_grr: so (Bool,) == { _|_, (_|_,), (False,), (True,) }
10:15:31 <sorear> thief_grr: by cardinality they are unequal, and the argument "one-tuples are useless" fails
10:16:11 <sorear> @users
10:16:12 <lambdabot> Maximum users seen in #haskell: 339, currently: 312 (92.0%), active: 39 (12.5%)
10:16:33 <thief_grr> sorear: ok, i get that
10:16:45 <sorear> that was all.
10:17:05 <roconnor> I think this argument is all wrong.  It is 3-tuples that are useless ;)
10:17:10 <halassocracy> an n-tuple of elements of a set A can be defined as a function from a set of n elements into A and an element of A can be defined as a function from a one element set into A; with this perpective there is no difference between a one tuple and a single element
10:17:11 <thief_grr> sorear: but this whole thing seems to point that 1-tuples are something worth having around, or at least not banning, no?
10:17:51 <thief_grr> halassocracy: that's neat
10:18:31 <sorear> thief_grr: yes
10:18:38 <sorear> halassocracy: wrong!
10:18:40 <DRMacIver> halassocracy: What? With that perspective there's a very big difference between a one tuple and a single element.
10:18:41 <thief_grr> halassocracy: but still, say a tuple is a function mapping {1,2} into our set
10:18:55 <thief_grr> halassocracy: but the number should be a function mapping {} into our set, not {1}
10:18:57 <sorear> halassocracy: remember functions are lifted
10:19:03 <DRMacIver> halassocracy: A 'a one-tuple has type {1} -> 'a
10:19:17 <halassocracy> i'm just talking mathematically, without regard to haskell
10:19:26 <DRMacIver> So am I...
10:19:38 <DRMacIver> A constant function into A is not the same as an element of A. :)
10:19:55 <halassocracy> why not?
10:21:03 <sorear> well, not the same but very similar
10:21:16 <halassocracy> you can just define it to be so
10:21:18 <sorear> if A is a group, A and () -> A are isomorphic
10:21:34 <sorear> if A is a topological space, A and () -> A are homeomorphic
10:21:35 <sieni> halassocracy: what if the set A also consists of functions?
10:21:47 <DRMacIver> halassocracy: You can't just define it to be so, because all your terms are things which have already been defined.
10:22:01 <DRMacIver> sorear: Sure. But isomorphism is not identity. :)
10:22:40 <halassocracy> you can say that an element of an object A is an arrow from a terminal object into A, this is done in category theory
10:22:40 <sorear> DRMacIver: identity is a beast best allowed to lie
10:25:33 <DRMacIver> sorear: Nonetheless, treating isomorphism as a relation which means 'there is no difference between' is just a bad idea. At best it means "can be regarded as the same thing in this particular context" and all that has been done is shunt the argument over to whether that is the appropriate context.
10:27:17 <thief_grr> ok.. i disagree with halassocracy because of the arities of the functions, and sorear's arguement seems to encourage my view of 1-tuples being different things
10:27:37 <DRMacIver> halassocracy: I dislike defining elements as morphisms. It muddies the water without adding much benefit. In particular it creates an infinite regress, as 'A' and 'the elements of A' are two distinct objects (even if they are isomorphic).
10:27:39 <thief_grr> i think i should just accept that haskell doesnt have 1-tuples for some magic fairy-tale reason and move on.. later i'll get back to it
10:27:47 <DRMacIver> thief_grr: That's probably for the best. :)
10:28:31 <thief_grr> but, seriously, that Hutton's explanation that we don't have 1-tuples because we use parentheses do denote them, sucks
10:28:39 <halassocracy> A is an object and the elements of A are arrows
10:28:58 <merus> I think MacLane put it best when he said "...up to isomorphism (and what more could you possibly want?)"
10:29:41 <allbery_b> hm, last night's ghc-6.7 seems a bit broken :/
10:29:51 <merus> I thought Haskell didn't have one-tuples because (,) was a binary operator?
10:30:02 <DRMacIver> halassocracy: I'd rather have first class arrows than be able to pretend 1-tuples of A are the same as elements of A. :)
10:30:21 <thief_grr> go DRMacIver! ;)
10:30:49 <DRMacIver> Anyway, I'm bored of this argument and far too half asleep to carry on with it. :)
10:33:30 <thief_grr> sorear: thanks for that wiki link on laziness, rocks!
10:34:01 <sorear> thief_grr: ?
10:34:10 <sorear> thief_grr: what link, my memory fails
10:34:22 <thief_grr> sorear: http://en.wikibooks.org/wiki/Haskell/Laziness
10:34:34 <thief_grr> sorear: oh sorry, it wasnt from you?
10:34:36 <thief_grr> heh nevermind ;)
10:34:40 <matthew-_> @hoogle ShowS -> String
10:34:41 <lambdabot> No matches, try a more general search
10:34:45 <sorear> i don't think I've every refered anyone to the wikibook
10:34:51 <thief_grr> yes yes sorry
10:36:52 <Herald> whats your haskell text book of choice then ?
10:37:41 <matthew-_> help!     Couldn't match expected type `[Char]' against inferred type `ShowS'
10:37:42 <matthew-_>     In the expression: id $ (uriToString (id) v)
10:41:17 <sorear> id $ x == x
10:41:24 <thief_grr> Herald: i just started with hutton's seems not bad at all...
10:41:33 <matthew-_> ok, I was completely confused by the use of ShowS
10:41:35 <sorear> but ShowS means you need to add a ""
10:41:43 <matthew-_> yeah, exactly
10:41:49 <matthew-_> what is ShowS used for?
10:41:50 <sorear> like uriToString v ""
10:41:56 <sorear> matthew-_: fast catenation
10:42:00 <matthew-_> ahh, thanks
10:42:22 <sorear> > foldl (++) [] (replicate 1000 "x")
10:42:24 <lambdabot>  "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
10:42:27 <sorear> > foldl (++) [] (replicate 10000 "x")
10:42:31 <lambdabot>  "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
10:42:35 <sorear> > foldl (++) [] (replicate 100000 "x")
10:42:39 <lambdabot> Terminated
10:43:03 <sorear> > foldl (.) id (showChar (replicate 100000 "x")) $ ""
10:43:04 <lambdabot>  Couldn't match expected type `Char'
10:43:11 <sorear> > foldl (.) id (showString (replicate 100000 "x")) $ ""
10:43:12 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
10:43:26 <sorear> > foldl (.) id (map showString (replicate 100000 "x")) $ ""
10:43:28 <lambdabot>  "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
10:43:34 <sorear> much dfaster
10:44:35 <matthew-_> my my. indeed it is. Well that's my #haskell-based learning for Sunday ;-)
10:47:36 <Herald> i think my lecturer knows graham hutton actually
10:47:50 <roconnor> :type lookup
10:47:54 <roconnor> @type lookup
10:47:56 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:48:01 <Herald> my course uses the simon thompson craft of functional programming book tho
10:49:48 <roconnor> @type maybe
10:49:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:54:49 <nostrademons> > product []
10:54:51 <lambdabot>  1
10:55:42 <chessguy> hi haskellers
10:58:07 <glguy_> I'm going over a set of slides on category theory. Regarding functors they say Given two categories, C and D, a functor F:C->D maps each morphism of C onto a morphism of D... is that to say that fmap takes an (a->b) to (c->d) where c and d are elements of category D and a and b are elements in C?
10:58:58 <glguy_> and C and D are categories where the objects are types and the morphisms are functions?
11:00:28 <Pastorn> unrelated unix question: is there any way to restore a file just deleted by rm?
11:01:19 <Pastorn> i
11:01:27 <Pastorn> i'm using ext3
11:01:57 <glguy_> seems like the first thing to do would be to remount the drive ro so you don't blow the file away by making changes to the drive while you ask :)
11:02:12 <chessguy> Pastorn: try ##linux
11:03:07 <Pastorn> chessguy: trying #ubuntu
11:03:27 <chessguy> ok, just ignore me then
11:03:31 <allbery_b> in general the answer is no.  if there has been *no* filesystem activity you can sometimes get it back, especially if some process is holding it open
11:03:51 <allbery_b> unfortunately installing a tool to do the recovery will probably nuke the file's blocks :>
11:04:00 * glguy_ wonders if "IO" relates in some way to terminal objects
11:04:16 <glguy_> if you wanted to restore the file, you'd be using a CD to boot from already
11:04:25 * Pastorn wants to cry
11:04:51 <Pastorn> allbery_b: it was 700 MB on a disk with 11 GB free
11:04:51 <EvilTerran> backups!
11:04:59 <Pastorn> there MIGHT be a chance!
11:05:02 <merus> Pastorn: Your dissertation?
11:05:11 <glguy_> he's favorite game?
11:05:13 <glguy_> movie?
11:05:15 <merus> Or just your pr0n folder?
11:05:15 <allbery_b> pastorn: but generally a removed file's blocks end up at the top of the free list and are therefore the first to be reused
11:05:41 * merus plans on having about ten backups of his dissertation
11:05:48 <allbery_b> (this does depend on the filesystem and *some* filesystems do try to do the reverse.  I don't know if that includes ext3.  I also don't know how the journal complicates things.)
11:06:21 * Pastorn cries even more
11:06:23 <glguy_> Are "natural transformations" expressed in Haskell?
11:06:52 <merus> They'd be something like Arrow transformers, wouldn't they?
11:07:06 <glguy_> I'm not sure, I'm pretty much brand new to category theory
11:07:13 <glguy_> I'm just reading about it and trying to relate it to what I know
11:08:11 <allbery_b> "rm is forever"
11:08:22 <chessguy> oh, i came up with another new "monad-as-x" analogy in the middle of my interview for a haskell job yesterday
11:08:30 <merus> chessguy: oh?
11:08:44 <Pastorn> allbery_b: the fifth post: http://www.linuxquestions.org/questions/showthread.php?t=441914
11:08:45 <merus> I've always been a big fan of the monad-as-monad analogy.
11:09:24 <chessguy> when i first got there, there were several chess and go boards out, and we started talking about go, and how there were very few rules, but a lot of implications
11:09:52 <chessguy> so in the interview, i mentioned that i thought that was true of monads as well. just a few rules, fairly simple, but with a lot of implications
11:09:59 <chessguy> so, monad-as-go !
11:10:07 <merus> Oh dear.
11:10:16 <glguy_> and they said, ok, interview over!
11:10:17 <glguy_> ?
11:10:19 <glguy_> ;)
11:10:31 <chessguy> nope!
11:10:48 <chessguy> i wish! it was like a 6-hour interview
11:10:56 <FZ> 6 hour interview!
11:11:01 <glguy_> yeah, I did one of those recently
11:11:20 <chessguy> not fun
11:11:26 <glguy_> :(
11:11:27 <glguy_> I loved it
11:11:34 <chessguy> well, it was actually not that bad
11:11:36 <FZ> isn't that a little bit too long?
11:11:37 <Pastorn> something more related: anyone know of any haskell project involving calendars?
11:11:39 <chessguy> they're incredible smart
11:11:57 <chessguy> so a lot of times, they'd ask me an interesting question, i'd answer, and we'd just talk about it
11:12:01 <FZ> chessguy: which company, if you don't mind
11:12:09 <chessguy> www.aetion.com
11:13:14 <Pastorn> like iCal or anything
11:14:47 <chessguy> they do phenomenally cool work
11:15:25 <FZ> chessguy: Does Haskell take the biggest part in their software development?
11:15:33 <chessguy> including AI for analyzing video footage of insurgents in iraq, to track their movement
11:15:59 <chessguy> haskell isn't the only thing they use, but yes, i think it's the biggest part
11:17:38 <FZ> cool
11:20:20 <matthew-_> @type fmap (1,2)
11:20:22 <lambdabot>     Couldn't match expected type `a -> b'
11:20:22 <lambdabot>            against inferred type `(a1, b1)'
11:20:44 <chessguy> ?hoogle fmap
11:20:45 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
11:20:45 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
11:20:45 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
11:21:46 <matthew-_> yeah, I'm having a slow day...
11:21:48 <arvid> I read somewhere that haskell can do "function-caching" so when you call f 10^10 twice the computation is only done once. is that true?
11:23:24 <chessguy> arvid: which computation there are you talking about? applying f, or applying ^
11:24:04 <arvid> f :) (the 10^10 was only to illustrate a very heavy call)
11:24:28 <chessguy> well you can do something like this
11:24:40 <chessguy> > let x = 10^10 in x + x
11:24:42 <lambdabot>  20000000000
11:24:48 <glguy_> if you had f (g 1) (g 1) haskell can do CSE
11:24:54 <glguy_> common subexpression elimination
11:25:21 <chessguy> arvid: in the example i gave, 10^10 is only actually calculated once
11:26:39 <chessguy> ?losers
11:26:39 <lambdabot> Maximum users seen in #haskell: 339, currently: 310 (91.4%), active: 36 (11.6%)
11:28:18 <arvid> okey - i just read (somewhere) about this "caching". and then I thought about why naiv-stuff like: fib (n+2) = fib (n+1) + fib n woudn't work well
11:28:49 <chessguy> fibonacci isn't usually written that way
11:28:56 <arvid> but I have no idea if it's true or how it works
11:29:19 <chessguy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
11:29:21 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:30:00 <arvid> chessguy: but that's not very naiv?
11:30:13 <chessguy> no, it's not
11:30:39 <DRMacIver> It does seem a shame that the compiler can't cleverly optimise the naive implementation of fib.
11:30:50 <DRMacIver> As there's an 'obvious' optimisation to be done.
11:30:57 <EvilTerran> arvid, if you create a data structure that can map inputs to oputputs, and work your function thru that, that works
11:31:20 <glguy_> it would suck if the compiler memoized every function call
11:31:48 <arvid> glguy_: it would indeed cost some memory
11:31:57 <EvilTerran> >let fib = (fibs !!); fibs = 1 : 1 : [fib (i-1) + fib (i-2) | i <- [2..]] in ...
11:32:38 <DRMacIver> Well, obviously the compiler should only do it when it would be a good idea. The MindReader monad is probably useful here. :)
11:32:49 <EvilTerran> or whatever. won't be as efficient as the other version because of all those list lookups, but won't be as bad as /sans/-memos
11:33:26 <EvilTerran> (fib n) would be polynomial time in n, rather than exponential
11:33:28 <pejo> DRMacIver, what are the obvious optimizations?
11:34:20 <glguy_> > let { tabulate bounds f = array bounds [(i,f i) | i <- range bounds]; dp bounds f = (memo!) where memo = tabulate bounds (f (memo!)); fib n = dp (1,n) f n where {f g 1 = 1; f g 2 = 1; f g i = g (i-2) + g (i-1)}} in fib 10
11:34:21 <lambdabot>   Not in scope: `fib'
11:34:34 <dr_strangelove> is it possible to define the (+) operator for two different types? (with num instance)
11:34:40 <glguy_> > let { tabulate bounds f = array bounds [(i,f i) | i <- range bounds]; dp bounds f = (memo!) where {memo = tabulate bounds (f (memo!))}; fib n = dp (1,n) f n where {f g 1 = 1; f g 2 = 1; f g i = g (i-2) + g (i-1)}} in fib 10
11:34:41 <lambdabot>  55
11:34:46 <Pastorn> I am thinking of making a module for handling a certain, yet undefined, datastructure (having to create that as well). What do I have to think about before starting? There must be someone at some time who's written some good guidelines? Any haskell standards that needs to be followed? Stuff like that.
11:35:23 <kc5tja> @pl runTest name      = "  __CUT__"++name++"();\n"
11:35:24 <lambdabot> runTest = ("  __CUT__" ++) . (++ "();\n")
11:35:35 <kc5tja> Interesting.
11:35:47 <DRMacIver> pejo: Well the implementation of "fib n = fib (n - 1) + fib (n - 2)" recomputes fib for the same values many times. It doesn't seem too unreasonable to expect the compiler to be able to spot this and roll up the recursion e.g. with an accumulator.
11:35:55 <DRMacIver> pejo: I am of course misusing the term "obvious". :)
11:36:50 * glguy_ prefers to have to explicitly memoize over having unexpected memory ballooning behavior
11:37:13 * DRMacIver doesn't really think this is a good idea.
11:37:14 <pejo> glguy, space leaks is the reason ghc is so conservative with CSE.
11:37:27 <DRMacIver> I'm just wildly speculating. :)
11:37:52 <pejo> Shrug, I'm not against optimizations - but automatic dynamic programming isn't "obvious" in my book.
11:38:16 <arvid> uh - btw. another question :) I'm not a huge performance-freak, but how does Haskell compare to (let say) C or FORTRAN?
11:39:03 <DRMacIver> Not at all badly.
11:39:20 <DRMacIver> Although everyone and their dog takes a different spin on the validity of benchmarks. :)
11:39:24 <pejo> arvid, sometimes lazy evaluation helps you an awful lot. Sometimes it doesn't.
11:39:43 <Pastorn> ?where XML
11:39:43 <lambdabot> I know nothing about xml.
11:39:50 <DRMacIver> As it should be. :)
11:40:03 <Codex_> for low level things like pixel manipulation, it's way too slow. (at least mapM :)
11:40:13 <cjay> unfortunately trying to make haskell code faster can make it very ugly
11:40:16 <Pastorn> i know there's a module
11:41:25 <arvid> Codex_: I'm not doing pixel manipulation :) but I'll need to solve some wierd PDE's
11:42:18 <arvid> And i have a half-finished program in FORTRAN
11:42:28 <arvid> (which I didn't write)
11:43:28 <arvid> and now I considering rewriteing the whole thing - but the FORTRAN-version already takes about 20 minutes.
11:44:43 <abz> :t fmap
11:44:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:45:23 <glguy_> fmap (*2) (+3) 4
11:45:26 <glguy_> > fmap (*2) (+3) 4
11:45:28 <lambdabot>  14
11:45:50 <Eelis> how come there's no "uninstall" cabal command?
11:45:50 <dr_strangelove> is it possible to define a function (*) :: Int -> Interval -> Interval  by deriving from Num?
11:46:26 <glguy_> :t (*)
11:46:28 <lambdabot> forall a. (Num a) => a -> a -> a
11:46:31 <glguy_> nope, but
11:46:36 <kc5tja> @hoogle [[a]] -> [a]
11:46:37 <lambdabot> Prelude.concat :: [[a]] -> [a]
11:46:41 <glguy_> ?src Num
11:46:41 <DRMacIver> Hm.
11:46:41 <lambdabot> class  (Eq a, Show a) => Num a  where
11:46:41 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:46:41 <lambdabot>     negate, abs, signum     :: a -> a
11:46:41 <lambdabot>     fromInteger             :: Integer -> a
11:46:56 <glguy_> fromInteger x * y
11:47:05 <glguy_> would work if you had a concept of multiplication of intervals
11:47:07 <kc5tja> > concat ["Hello","World"]
11:47:08 <lambdabot>  "HelloWorld"
11:47:11 <kc5tja> perfect.
11:47:35 <dr_strangelove> glguy_, ok
11:47:46 <EvilTerran> >unwords ["Hello","World"]
11:47:49 <kc5tja> @hoogle map
11:47:50 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
11:47:50 <EvilTerran> > unwords ["Hello","World"]
11:47:50 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
11:47:50 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
11:47:52 <lambdabot>  "Hello World"
11:47:55 <Lemmih> Eelis: Technical difficulties.
11:48:09 <Eelis> Lemmih: i see. does that mean it's a planned feature?
11:51:34 <Lemmih> Eelis: I think so. I'm in no way sure, though.
11:52:57 <Eelis> Lemmih: ok, thanks. i found some mailing list messages that seem to confirm that
11:53:46 <tuukkah> you'd think install becomes uninstall when you change (\src dst -> mv src dst) to (\src dst -> rm dst)
12:01:57 <kc5tja> @src foldr
12:01:57 <lambdabot> foldr k z xs = go xs
12:01:57 <lambdabot>     where go []     = z
12:01:57 <lambdabot>           go (y:ys) = y `k` go ys
12:06:30 <fyx> hi
12:07:05 <fyx> see when you do last (map ..)
12:07:17 <fyx> it doesnt actually call the function for anything other than the last item does it?
12:08:41 <DRMacIver> Ouch. hsjava makes my head hurt. :)
12:08:42 <fyx> (it seems to for me)
12:08:44 <xerox> fyx: right
12:08:47 <DRMacIver> Still, probably better than writing my own...
12:09:02 <fyx> some way I can make it apply the func to every item in the list?
12:09:20 <fyx> its just the return type of my function has the be a, not [a] so I cant just use map alone :|
12:09:30 <xerox> fyx: which function do you want to map?
12:09:48 <xerox> I mean, what type does it have?
12:10:03 <fyx> its of type Statement -> IO ()
12:10:06 <xerox> perfect.
12:10:09 <fyx> :D
12:10:44 <fyx> ive just been looking through Prelude
12:10:48 <xerox> ?type let f = undefined :: () -> IO () in sequence . mapM_ f
12:10:50 <lambdabot>     Ambiguous occurrence `sequence'
12:10:50 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
12:10:54 <xerox> dang.
12:11:10 <fyx> :O
12:11:23 <fyx> lambdabot: or where else?
12:11:31 <glguy_> ?seen dons
12:11:32 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 6h 22m 2s ago.
12:11:38 <mauke> fyx: do you want to run all the IO actions in sequence?
12:11:42 <fyx> yeah
12:11:44 <xerox> ?type let f = undefined :: () -> IO () in (last `fmap`) . Control.Monad.mapM f
12:11:46 <lambdabot> () -> IO () in (last `fmap`) . Control.Monad.mapM f :: [()] -> IO ()
12:12:01 <xerox> this will extract the last result after running all the actions
12:12:07 <fyx> hm
12:12:08 <xerox> ?type sequence
12:12:10 <fyx> Ok thanks a lot
12:12:11 <lambdabot>     Ambiguous occurrence `sequence'
12:12:11 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
12:12:15 <xerox> this will collect all the results
12:12:18 <fyx> reading about it on haskell.org
12:12:19 <xerox> ?type Control.Monad.sequence
12:12:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:12:39 <mauke> @type \f list -> liftM last (mapM f list)
12:12:41 <lambdabot>     Ambiguous occurrence `mapM'
12:12:42 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
12:12:47 <Pastorn> what does (<+>) do?
12:12:47 <mauke> @type \f list -> liftM last (Control.Monad.mapM f list)
12:12:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m b
12:12:58 <xerox> Pastorn: what is its type?
12:13:15 <Pastorn> no clue... lb refuses to cooperate
12:13:17 <glguy_> Pastorn: <+> from Control.Arrow is for ArrowPlus
12:13:36 <Pastorn> glguy: Arrows? What are they pointing at?
12:13:58 <glguy_> categories
12:14:11 <Pastorn> oh! THOSE arrows
12:14:27 <Pastorn> thought it was maybe memory handling or whatever
12:14:56 <Pastorn> i shoulde really read more in my book "Introduction to category theory for computer scientists"
12:15:16 <Pastorn> so far i've gotten to page 3
12:16:22 <hpaste>  cybercobra pasted "ERROR "Neko.hs":5 - Undefined type constructor "Bytes"" at http://hpaste.org/931
12:16:48 <xerox> ç«ãHS
12:16:50 <xerox> hehe
12:17:37 <Pastorn> ?seen winming
12:17:37 <lambdabot> I haven't seen winming.
12:17:47 <Pastorn> ?seen xinming
12:17:47 <lambdabot> xinming is in #haskell and #perl6. I don't know when xinming last spoke.
12:18:19 <cybercobra> anyone know why i'm getting ""ERROR "file.hs":5 - Undefined type constructor "Bytes" on http://hpaste.org/931 ?
12:18:41 <cybercobra> i'm a newbie to haskell, so it's probably something simple
12:19:06 <xerox> cybercobra: you've got the constructor |FieldHash Bytes :: Expr| but Bytes is not a defined type
12:19:08 <sorear> .
12:19:13 <xerox> hi sorear
12:19:54 <fyx> urk
12:19:54 <fyx> Control.Monad.liftM last (mapM print ["hello","world"])
12:19:57 <fyx> that works..
12:20:15 <fyx> but when I try the same thing in my actual program it says Map.find: element not in the map
12:20:22 <fyx> i never call Find :S
12:20:28 <cybercobra> xerox: ahh.
12:20:43 <mauke> btw, you don't need the Control.Monad.
12:20:52 <fyx> that was just so it ran in ghci
12:20:52 <xerox> cybercobra: that is, the writing data Expr = ... | FieldHash Bytes | ... means that you define a data constructor FieldHash :: Bytes -> Expr. But Bytes is not a defined type. It is a data constructor Bytes :: String -> Expr of Expr.
12:20:59 <fyx> I dont have that in my actual program
12:21:29 <fyx> I dont know where find is coming from though
12:22:01 <mauke> maybe one of the libraries you're using uses Map.find
12:22:20 <cybercobra> xerox: okay, changed Bytes to Expr in that, now i have another error
12:22:40 <cybercobra> xerox: ERROR "file.hs":128 - "code" multiply defined
12:23:00 <xerox> what is in line 128?
12:23:15 <xerox> hang on, hpaste can number lines
12:23:56 <xerox> cybercobra: what type does StmtExpr have?
12:24:44 <cybercobra> xerox: data Statement = other_constructors... | StmtExpr Expr
12:25:19 <xerox> cybercobra: that means that code :: Statement -> .. but all the other lines unify to code :: Expr -> ..
12:25:57 <fyx> mauke: yaeh you were right, that was the problme
12:26:09 <fyx> got it all working now, thanks a lot for the help everyone
12:26:31 <Lemmih> cybercobra: You have to define 'code' in one block. You can not intersperse its definition with type synonyms or other functions.
12:27:20 <cybercobra> Lemmih: so, rename that version of 'code' ?
12:29:46 <Lemmih> cybercobra: Move 'Suite' and 'hashCmp' out of the 'code' definition.
12:32:06 <cybercobra> Lemmih: okay, so all the 'code's need to be in one contiguous chunk?
12:32:51 <quicksilver> Anyone smart about SIGPIPEs and sockets?
12:33:02 <Lemmih> cybercobra: Yeps.
12:33:22 <cybercobra> Lemmih: that makes sense. thanks!
12:33:23 <quicksilver> I'm writing a TCP forwarder and if the remote end closes the connection, the next write causes a SIGPIPE
12:33:31 <quicksilver> which kills the whole process, not what I want :(
12:34:10 <mauke> quicksilver: ignore SIGPIPE
12:34:13 <Lemmih> quicksilver: Conjure deals with that by ignoring sigPIPE: installHandler sigPIPE Ignore Nothing
12:34:38 <quicksilver> how will I then find out that that socket is now dead?
12:34:50 <mauke> write/send will fail
12:35:19 <quicksilver> ah, good
12:35:23 <quicksilver> as an exception?
12:35:56 <mauke> I don't know how haskell maps the unix api
12:36:08 <mauke> at the C level it returns -1 and sets errno to EPIPE :-)
12:36:16 <quicksilver> Lemmih: on the subject of signals, does this look right:
12:36:26 <quicksilver> installHandler sigINT (Catch (throwTo mainthread (ErrorCall "sigint"))) Nothing
12:36:36 <quicksilver> bah. he's gone :)
12:37:53 <quicksilver> mauke: ah yes, I get an exception, good
12:37:56 <cybercobra> how do i go about fixing mutual recursion between 2 data"s
12:38:09 <quicksilver> mauke: <socket: 6>: hPutBuf: resource vanished (Broken pipe)
12:39:23 <mauke> cybercobra: what's the problem?
12:40:11 <cybercobra> mauke: basically  data Foo = ... | Bar Baz;  data Baz = ... | Qux Foo
12:40:27 <mauke> yes, how is that a problem?
12:41:43 <cybercobra> mauke: hm. wait, nm. i think it's something different
12:42:43 <cybercobra> is   data Foo = Bar Whatever | Baz Bar   legal?
12:43:10 <quicksilver> well, Bar can be a constructor and a type simultaneously
12:43:25 <quicksilver> but it's very confusing for that constructor not to be in that type
12:43:30 <quicksilver> which is what your example appears to suggest
12:43:45 <cybercobra> quicksilver: so, no?
12:44:18 <quicksilver> cybercobra: what are you trying to do?
12:44:25 <quicksilver> cybercobra: I suspect your example doesn't make sense
12:44:26 <xerox> cybercobra: do you want [Bar] ?
12:44:48 <quicksilver> xerox: he's declaring Bar as a constructor and then using it as a type, I doubt that's what he means
12:45:06 <xerox> quicksilver: it resembles data List a = Cons a (List a) | Nil
12:45:50 <cybercobra> data Statement = Suite [Statement] |  If [(Expr, Suite)] Suite | ...
12:46:10 <cybercobra> so, i'm guessing s/Suite/[Statement] will fix it?
12:46:14 <xerox> cybercobra: yes.
12:46:28 <xerox> actually you can just have
12:46:46 <xerox> data Statement = Suite [Statement] | If [(Expr, Statement)] Statement | ...
12:50:46 <Lemmih> quicksilver: I didn't get anything after "does this look right:"
12:51:02 <cybercobra> all definitions of a function need the same type signature, correct?
12:51:18 <quicksilver> Lemmih: installHandler sigINT (Catch (throwTo mainthread (ErrorCall "sigint"))) Nothing
12:51:32 <Lemmih> cybercobra: Yes. A function can only have a single type.
12:51:35 <quicksilver> (to try to ensure my finalisers can run if I ctrl-C it)
12:52:43 <Lemmih> quicksilver: I don't know, sorry.
12:53:40 <vincenz> Lemmih: hiho
12:53:55 <fasta> module Foo.Bar' exports `forever' imported from Foo.Bar at /home/fasta/Foo/Bar.hs:55:0-27 <- This shouldn't be possible, right?
12:55:27 <Cale> cybercobra: unless it is a method of a class, in which case it still has one general type, but that type is able to specialise in potentially many ways
12:55:55 <Cale> for example, read :: (Read a) => String -> a
12:56:14 <Cale> a can then become any type with a suitable instance of Read
13:04:22 <tuukkah> hmm, how would i write a file in utf-8 without regard to the system locale charset settings?
13:06:15 <tuukkah> i've now tried newUTFString s >>= readCString >>= writeFile path
13:13:23 <cybercobra> on http://hpaste.org/932?lines=true  I'm getting 'ERROR "file":127 - Instance of Num [Char] required for definition of codeStmt'
13:13:50 <cybercobra> anyone know why?
13:14:25 <cybercobra> sorry, line 127 = line 82 in the paste
13:17:18 <fasta> + ";" <- there is the bug
13:17:25 <fasta> You cannot just add strings in Haskell
13:17:42 <fasta> (well, you can, but that requires an instance)
13:18:20 <cybercobra> fasta: darn typos. sorry to bother you.
13:19:31 <fasta> cybercobra: you might want to try ghci
13:19:45 <fasta> cybercobra: I think it gives better error messages.
13:20:28 <cybercobra> fasta: i'll do that. and yay, your fix made my module compile finally!
13:21:43 <cybercobra> i love haskell. an AST compiler in only 148 lines. take that C#!
13:22:00 <fasta> cybercobra: what are you building?
13:22:23 <fasta> cybercobra: I mean "the ultimate goal".
13:22:35 <fasta> cybercobra: (not just what I see in your code)
13:22:45 <dolio> ?pl \s -> getRandom >>= return . flip rotate s
13:22:45 <lambdabot> (`fmap` getRandom) . flip rotate
13:23:17 <cybercobra> fasta: compiler for my own language. my lang -> AST -> Neko AST (the paste) -> Neko code -> executable
13:23:34 <fyx> whats AST?
13:23:36 <fasta> cybercobra: I think your compiler will be very slow for large inputs.
13:23:38 <fyx> oh..
13:23:41 <cybercobra> abstract syntax tree
13:23:44 <fyx> yeah sorry
13:23:49 <fyx> whats Neko?
13:24:01 <cybercobra> http://www.nekovm.org
13:24:04 <lambdabot> Title: index [NekoVM]
13:24:08 <fasta> cybercobra: and why are you building your own language?
13:24:09 <fyx> cool :D
13:24:29 <fyx> ooooh this is interesting
13:24:35 <cybercobra> fasta: always wanted to. and i have some spare time
13:25:15 <cybercobra> fyx: yeah, instead of compiling to some kind of bytecode, you compile to a simple dynamically-typed language
13:26:14 <fyx> cybercobra: Ive been reading up and stuff thinking about writing a VM
13:26:25 <fyx> *maybe* I will be able to skip that stage :D
13:26:56 <cybercobra> fyx: my thoughts precisely :0)
13:30:18 <ventonegro> hah, the neko guy must be a lua fan
13:30:30 <ventonegro> __add, and concat etc.
13:32:09 <tuukkah> my bad, the line i've been testing seems to be working :-) i forgot that latex has tricky support for unicode
13:32:25 <cybercobra> ventonegro: i like how neko actually has integers. it irks me that lua uses just floats
13:32:40 <ventonegro> cybercobra, never been a problem to me
13:32:56 <ventonegro> cybercobra, but YMMV
13:35:21 <cybercobra> ventonegro: anyway, neko and lua pretty similar
13:35:28 <cybercobra> *are
13:37:02 <ventonegro> cybercobra, the devil is in the details
13:37:14 <cybercobra> ventonegro: truely. :)
13:59:09 <dmwit> ?quo
13:59:10 <lambdabot> nilsi says: #haskell is better than google
13:59:16 <dmwit> ?qu
13:59:16 <lambdabot> Maybe you meant: quit quote . bf bug ft id pl rc run v wn
13:59:23 <dmwit> ?quo
13:59:23 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
13:59:24 <lambdabot> of insight hits and it all makes sense.
14:01:27 <fyx> :(
14:01:52 <fyx> I never tipped over a vending machine
14:02:17 <Botje> go do it now.
14:02:25 <Botje> make sure there's somebody under it, first
14:02:38 <fyx> ghehe
14:05:51 <fyx> isnt "liftM last $ mapM" a very common thing to do?
14:07:22 <fyx> > [1:"two"]
14:07:23 <lambdabot>   add an instance declaration for (Num Char)
14:07:30 <fyx> > [1,"two"]
14:07:31 <lambdabot>   add an instance declaration for (Num [Char])
14:07:31 <lambdabot>     In the expression: 1
14:07:31 <lambdabot>     I...
14:08:13 <Heffalump> fyx: you think it should be a very common thing to do?
14:09:40 <fyx> well it seems useful, Ive got it twice in my code already
14:09:46 <chessguy> @type (:)
14:09:49 <lambdabot> forall a. a -> [a] -> [a]
14:09:53 <fyx> I dont really want to type anything 3 times..
14:10:14 <chessguy> fyx: so abstract it out, call it something, and be done
14:10:24 <fyx> I would do...
14:10:57 <chessguy> @type liftM last $ mapM
14:11:00 <lambdabot>     Ambiguous occurrence `mapM'
14:11:00 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
14:11:07 <chessguy> @type liftM last $ Prelude.mapM
14:11:09 <lambdabot>     Couldn't match expected type `[a]'
14:11:09 <lambdabot>            against inferred type `[a1] -> m [b]'
14:11:39 <chessguy> @type \xs -> liftM last $ Prelude.mapM xs
14:11:42 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
14:17:51 <fyx> :(
14:17:56 <fyx> Non-exhaustive patterns in function
14:18:05 <fyx> cant I just do it anyway..
14:18:15 <fyx> why crash at runtime :S
14:18:43 <Cale> fyx: huh?
14:18:45 <fyx> oh wait I see my problem
14:18:46 <dmwit> fyx: It means you're passing parameters it doesn't know how to deal with, so no, you can't just do it anyway... =P
14:18:56 <fyx> yes I just realised that, t
14:19:05 <resiak> You can make ghc warn you about non-exhaustive patterns, can't you?
14:19:11 <Cale> yeah
14:19:14 <fyx> I forgot to make my parser read in the right number of arg
14:19:30 <ndm> resiak: yes, but it gets it wrong all the time
14:19:37 <ndm> resiak: what you really want is Catch
14:19:39 <ndm> @where Catch
14:19:40 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
14:19:48 <chessguy> Cale: you should be proud of me
14:19:50 <ndm> that proves the absence of patter match errors
14:19:56 <Cale> chessguy: oh? :)
14:20:05 <ndm> (not pubically available yet, but i am trying to put together a release soon)
14:20:09 <resiak> ndm: heh!
14:20:11 <chessguy> Cale: i invented a new monad analogy for my interview yesterday - monads as...go!
14:20:17 <Cale> hehe :)
14:20:33 <chessguy> just a few simple rules, but LOTS of implications!
14:20:45 <Cale> yeah, I suppose in that sense :)
14:21:23 <chessguy> well, i walked in to the interview, and there were several chess and go sets sitting out prominently. i felt right at home :)
14:22:33 <mightybyte> What kind of interview?
14:22:45 <chessguy> for a haskell job
14:23:12 <mightybyte> Cool.  Who hires haskell programmers?
14:23:26 <chessguy> i interviewed at www.aetion.com
14:23:31 <Heffalump> Aetion, Galois, Credit Suisse spring to mind
14:30:51 <ndm> Bluespec
14:33:35 <fyx> parse error on input `->' :(
14:33:48 <fyx> cant I get more detailed errors..
14:33:52 <ndm> Heffalump: i noticed you're on the HW2007 program committee, does that mean you'll be at ICFP as well?
14:34:58 <fyx> augh it was indentation :/
14:35:11 <ventonegro> fyx, happens a lot
14:36:21 <ventonegro> any gtk2hs users here? i need to know how to make a column sizable
14:36:25 <fyx> indentation as syntax is bad D:
14:36:49 <DRMacIver> fyx: You know you don't have to use that, right...
14:36:49 <ndm> fyx: i disagree, it means people can't write poorly indented code
14:36:52 <chessguy> fyx: so use explicit layout and quit whining
14:36:53 <dmwit> So use explicit {};, it's there just for you.
14:37:15 <ventonegro> fyx, i agree, but it's the lesser evil
14:37:23 <chessguy> ndm: well, they *can*, but it's harder
14:37:25 <fyx> lesser evil of what?
14:37:47 <ventonegro> fyx, use indentation or {};
14:37:53 <fyx> oh right
14:38:15 <fyx> ill write another program in haskell using {}; sometime and see whats better and worse
14:39:08 <Heffalump> ndm: hopefully, but not 100% guaranteed
14:39:28 <Heffalump> ndm: it may not be possible for both Lennart and me to be away for a week at the same time
14:40:33 <ndm> Heffalump: ok, i'm hoping to go to (if my paper gets accepted)
14:40:41 <Heffalump> cool
14:40:48 <Heffalump> paper for ICFP or HW?
14:41:10 <sorear> @botsnack
14:41:11 <lambdabot> :)
14:43:49 <Igloo> ndm: PC members seem to be generally absent from conferences IME, for some reason. Maybe they've already had to read all the interesting papers  :-)
14:44:06 <ndm> Heffalump: both, one for each
14:44:12 <Heffalump> I think my attendance rate is 50% so far.
14:44:24 <ndm> Igloo: yeah, i guess if you are on the PC you can't submit a paper, and if you can't submit a paper its harder to get funding to go
14:44:39 <Heffalump> HW PC members can submit papers IIRC
14:44:52 <Heffalump> not that I intend to
14:45:25 <Heffalump> PC members are also generally not PhD students, and generally people with actual academic jobs have some travel money
14:45:28 <ndm> its generally not encouraged though?
14:45:40 <Heffalump> if it's allowed it's not discouraged
14:45:45 <Heffalump> but you might be held to a higher standard
14:45:50 <ndm> i.e. you have to be a bit more careful if you end up reviewing your own paper ;)
14:45:53 <ndm> yeah
14:46:05 <Heffalump> the PC chair makes sure you don't even find out who reviewed your paper
14:46:39 <Heffalump> I think that happens in the case of conflicts of interest too (e.g. paper submitted by a recent co-author)
14:46:52 <Heffalump> certainly you don't review such papers
14:48:37 <cod3po37> I'm trying to compile HAppS 0.8.8 and I get the following error at the very end: Setup.hs: Error: Could not find module: HAppS with any suffix: ["hi"] Has anyone seen this before? I found a reference to something similar in the #haskell logs for 06.08.25 for someone compiling ghc but I can't find out if it was resolved.
14:51:24 <ndm> yeah, they are careful about conflicts of interest from what i've heard
14:51:36 <ndm> but this year ICFP is double blind, not even the chair knows the actual author
14:51:48 <ndm> could make for some fun reviews :)
14:52:00 <Heffalump> yeah, they did that with PLDI last year
14:52:17 <Heffalump> presumably it must have worked reasonably well or ICFP wouldn't have adopted it
14:52:38 <Heffalump> s/PLDI last year/the upcoming PLDI/
14:55:13 <vincenz> heh
14:55:21 <vincenz> double blind has been defacto for quite a while in our community
14:56:02 <Heffalump> does it work well?
14:56:06 <vincenz> yep
14:56:17 <vincenz> why wouldn't it?
14:56:31 <vincenz> Not sure if it's that big of a diff really
14:56:32 <pejo> Anyone remotely familiar with a field will be able to pin down the authors of a paper, unless it's a totally new author in the field.
14:56:42 <vincenz> the only diff is, you can't put your paper online in draft mode
14:56:45 <vincenz> or you sort of defeat the purpose
14:56:50 <vincenz> pejo: not really
14:57:01 <vincenz> pejo: often you make guesses, but you're overclaiming
14:57:02 <pejo> Or the paper is written conciously being as anonymous as possible.
14:57:08 <vincenz> pejo: or not everyone is famous?
14:57:14 <desp> hmm
14:57:25 <desp> is it possible to do pattern matching in an anonymous function?
14:57:33 <vincenz> Heffalump: anyways, yeah, can't put drafts online
14:57:53 <Heffalump> I think that's a significant loss
14:57:55 <dmwit> desp: (\x y -> case (x, y) of ...)
14:57:59 <vincenz> Heffalump: why?
14:58:11 <dmwit> But you should seriously consider naming a function that needs pattern matching.
14:58:16 <Heffalump> well, you can't send other people drafts either in case they were asked to review it
14:58:21 <desp> dmwit: of course, thanks.
14:58:36 <vincenz> Heffalump: oh, well that's really not an issue for me, I can't do that anyways due to company policy
14:58:40 <vincenz> possible patents and all that
14:58:49 <allbery_b> > (\ (x:xs) -> x : ':' : xs) "hello"
14:58:51 <lambdabot>  "h:ello"
14:59:27 <dmwit> allbery_b: But suppose there are two patterns...
14:59:43 <allbery_b> in that case you need to manually translate
14:59:48 <vincenz> Heffalump: want to hear a funny story?
14:59:52 <dmwit> Right.
14:59:53 <ndm> vincenz: for me, making my paper anonomous is virtually impossible
14:59:56 <allbery_b> (pattern matches are really case statements, see the report)
15:00:09 <vincenz> ndm: no it's not, you remove your name from the title and you blind all your references
15:00:22 <vincenz> :)
15:00:23 <ndm> vincenz: its in an area where i am the single person, using the Yhc compiler, an extension of a tool i wrote
15:00:37 <allbery_b> \x -> case x of { [] -> something; (x:xs) -> somethingelse }
15:00:46 <vincenz> ndm: then you have lost nothing with blind review..
15:00:56 <dmwit> allbery_b: Right, which is also what I suggested. ;-)
15:01:09 <ndm> vincenz: this paper is based substantially on Neil's work, we stole his method, did everything he specified in his future work section, improved it, and used the same name for our tool
15:01:56 <vincenz> Anyways, I probably already told this story.  While looking up related work for a journal, a colleague of mine found a paper on IEEE which had a violation notice.  Looking further, the authors had another paper with the same violation notice.  They had submitted (And gotten accepteD) the same paper at two different conferences (tho yes, the confs fell at more or less the same time).  But that is not the scandalous part.
15:02:06 <vincenz> ndm: :)
15:02:15 <vincenz> ndm: why does the name of the tool matter?
15:02:45 * vincenz peers around ominously
15:02:49 <Heffalump> vincenz: go on then, what's the scandalous part? :-)
15:03:00 <ndm> vincenz: it doesn't overly, but i have to throughout my paper compare it to "Neil's old program" - its hard to suggest i'm not Neil
15:03:09 <vincenz> Both papers got a violation notice cause they had ripped stuff from other papers VERBATIM, without citing
15:03:20 <vincenz> And when I say ripped stuff, I mean like whole paragraphs
15:03:42 <pejo> vincenz, self plagiarism isn't that uncommon. (Not saying that it is right).
15:03:45 <ndm> thats the other thing, i've ripped off my introduction from the last paper - i can't do that unless i am me
15:03:49 <vincenz> pejo: No, not from themselves!
15:04:14 <vincenz> they had basically ripped and mashed together content from 3 other papers that were not theirs
15:04:20 <vincenz> copying paragraphs verbatim
15:04:43 <vincenz> and then submitted it twice to 2 different conferences and gotten in
15:04:54 <ndm> i once saw a paper on regular expression simplification
15:04:57 <vincenz> cause they were on IEEE, well then probably with the violation notice add postfactuum
15:05:05 <vincenz> s/add/added
15:05:14 <ndm> the authors didn't present their simplification process, or anything like that
15:05:18 <ndm> they did present 25 examples
15:05:26 <ndm> 21 were trivial, 4 were complex
15:05:43 <ndm> 1 of the trivial ones was wrong, 3 of the complex ones were wrong, the remaining complex one was not as simplea s it could be
15:06:17 <ndm> http://portal.acm.org/citation.cfm?id=281276.281299
15:06:18 <lambdabot> Title: Regular expression simplification
15:06:26 <vincenz> ndm: well it's a technique
15:06:30 <ndm> thats the reference, in case anyone wants a laugh, and to wonder if peer reviewing is dead
15:06:33 <vincenz> just cause a technique isn't optimal doesn't mean it can't be published
15:06:45 <vincenz> a solution is better than no solution
15:06:47 <ndm> vincenz: yes, but it was just plain old wrong
15:06:55 <vincenz> ndm: there' no pdf
15:07:22 <ndm> vincenz: i think when i read it (about 3 years ago), i had to go get a paper copy
15:07:30 <vincenz> blegh
15:07:31 <ndm> not overly shocked that they didn't put it online
15:07:34 <vincenz> paper copies is the bane of research
15:07:39 <ndm> but it was published at two reviewed conferences
15:07:40 <vincenz> I think all papers should be available online
15:07:44 <ndm> i agree
15:07:46 <ndm> all mine are
15:07:47 <vincenz> preferably in one place, easily index and searchable
15:08:00 <ndm> and the darcs repos for all my papers are publically available
15:08:01 <vincenz> how else are we supposed to do SoA reviewing?
15:08:33 <ndm> SoA?
15:08:36 <vincenz> state of art
15:08:50 <cybercobra> anyone have an estimate on how long it takes ghc to compile?
15:09:00 <fyx> if I have data Parameter = Expr | Block
15:09:11 <fyx> why would I get Couldn't match `Parameter' against `Expr' ?
15:09:13 <ndm> cybercobra: a while, 8 - 24 hours
15:09:20 <pejo> ndm, I feel darcs repo is slightly overkill/not necessary.
15:09:21 <vincenz> fyx: it's a Block?
15:09:29 <kc5tja> cybercobra: On my machine, it takes close to 7 hours.  It's pretty old though.  800MHz Althon with 100MHz FSB or so.
15:09:32 <ndm> pejo: for my own convenience, more than anything
15:09:34 <fyx> vincenz: what?
15:09:36 <vincenz> ndm: I meant a more centralized solution , however, FOR EVERYTHING
15:09:44 <vincenz> fyx: @paste
15:09:45 <vincenz> @paste
15:09:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:09:46 <ndm> vincenz: yes, would be nice....
15:09:56 <cybercobra> ndm: okay, that's more encouraging
15:10:00 <ndm> vincenz: although google scholar makes it less of an issue now
15:10:04 <vincenz> ndm: like IEEE meets google scholar meets citeseer meets ACM meets all the other stuff that is available only on paper
15:10:19 <vincenz> especially the latte rpart
15:10:29 <ndm> since the start of my phd i've only read one "paper only" paper, and that was by my supervisor
15:10:43 <ndm> have successfully avoided the library so far
15:10:55 <vincenz> ndm: but seriously, paper only stuff, unless you happen accross it, is dead as far as current research is concenred
15:11:09 <DRMacIver> How can you avoid the library? It's full of books. Books are awesome.
15:11:09 <ndm> vincenz: i know
15:11:18 <vincenz> ndm: so we're bound to reinvent paper wheels
15:11:22 <ndm> DRMacIver: its full of english/arts students, they scare me
15:11:39 <DRMacIver> ndm: That's ok. They're more afraid of you than you are of them... :)
15:11:41 <TSC> Don't you have a separate library for science/engineering stuff?
15:11:43 <DRMacIver> Or maybe that's snakes. I get confused.
15:11:54 <vincenz> DRMacIver: not on a plae
15:11:56 <vincenz> plane
15:12:17 <dmwit> ?quote+ ndm [on the library] its full of english/arts students, they scare me
15:12:18 <lambdabot> No quotes match. Take a stress pill and think things over.
15:12:30 <ndm> ?remember ndm [on the library] its full of english/arts students, they scare me
15:12:30 <lambdabot> Done.
15:12:41 <dmwit> Thanks.
15:12:45 <dmwit> =)
15:14:25 <vincenz> ndm: doing icpfc again?
15:14:46 <ndm> vincenz: never done it before, no idea about this year - what date is it?
15:14:50 <vincenz> oh
15:14:55 <vincenz> 20-23 j
15:14:59 <vincenz> uly
15:15:39 <vincenz> we could always use a 5th
15:15:40 <vincenz> :)
15:16:51 * vincenz wants to go for teh win this year
15:20:17 <dons> moin.
15:20:18 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
15:20:36 <Heffalump> morning
15:23:52 <earthy> damn, monday already?
15:23:57 <mjjm> so why is it that if i've got a function that returns Char for instance and i say "data Junk = Char" and redeclare my function as returning type Junk, it fails to match the type Junk against Char?
15:23:57 <ndm> vincenz: i'll see nearer the time, would be best to create a York team if we could - but unlikely to happen
15:24:14 <ndm> mjjm: type Junk = Char
15:24:22 <ndm> mjjm: data and type are different keywords
15:27:13 <mjjm> well, that fixes the problem alright
15:27:16 <Heffalump> data Junk = Char defines Junk to be a datatype with a single nullary constructor named Char
15:27:32 <mjjm> oh right
15:27:35 <Heffalump> and since values (like constructors) and types are in different namespaces, nothing complains
15:27:57 <mjjm> so like if i'd called it a constructor with a Char in it it would've been alright too
15:28:19 <Heffalump> no, because a constructor with a Char as a parameter is not the same as a Char
15:28:33 <Heffalump> although obviously it's trivial to get from one to the other, you have to do so explicitly
15:28:47 <qwr> type Junk = Char Char
15:28:56 <TSC> Using data makes a new type, so it's not automatically compatible with another type
15:29:00 <qwr> data i meant
15:29:08 <qwr> data Junk = Char Char
15:30:22 <Heffalump> qwr: right, the point is that Junk is then not interchangeable with Char
15:30:32 <Heffalump> you can change your code trivially to turn it into a Char and back
15:32:43 <qwr> (and the two following Char's are in different namespaces, since only second is type)
15:35:33 <hpaste>  Adam annotated "WASH attribute problem. Whats happening here?" with "(no title)" at http://hpaste.org/915#a1
15:43:53 <fyx> makeFunctionBinding values bind:[ings] (ParamE par):[ams]
15:44:02 <fyx> this seems like an illegal pattern..
15:44:13 <fyx> do I just have to use a case inside the function instead?
15:44:47 <mauke> makeFunctionBinding values (bind : [ings]) (ParamE par : [ams])
15:45:04 <Igloo> You probably mean makeFunctionBinding values (bind : ings) (ParamE par : ams)
15:45:19 <mauke> that too
15:45:23 <Igloo> bind : [ings] matches 2-element lists only
15:45:46 <fyx> oh
15:46:06 <Igloo> As [ings] matches only 1-element lists
15:46:32 <fyx> ohh ok thanks
15:49:27 <acro> trying to figure out how to so something recursively where the number of recursive operations is passed in as an argument .. so if i passed in 3, then i'd get f(1 + f(1 + f(1 + x))) for example
15:49:41 <dmwit> :t iterate
15:49:43 <lambdabot> forall a. (a -> a) -> a -> [a]
15:49:54 <lesshaste> can someone remind how to read
15:50:02 <dmwit> > read "3"
15:50:03 <lambdabot>  3
15:50:22 <lesshaste> data Show t => Stack t = EmptyStack | StackC t (Stack t)
15:50:41 <mauke>  deriving (Show, Read)
15:51:19 <lesshaste> I read this "For any type in the Show class, construct a type Stack of items of type t which is either EmptyStack or ...
15:51:31 <mauke> acro: foo 0 f x = x; foo n f x = foo (n - 1) f (f x)
15:51:56 <lesshaste> is that right and how do you finish the sentence?
15:52:33 <TSC> I'd say "For a showable t, a stack of t is either an empty stack or a t on top of a stack of t"
15:52:37 <TSC> ... which makes it a list
15:52:45 <dmwit> > let doNTimes f n i = (iterate f i) !! n in doNTimes (+1) 17 3
15:52:47 <lambdabot>  20
15:52:47 <lesshaste> TSC: thanks so much
15:52:58 <lesshaste> you get a better quality of answer in #haskell :)
15:53:22 <TSC> The "on top of" is only because I know what a stack is; it's not really implicit in the declaration
15:53:33 <dmwit> > let doNTimes f n i = (iterate f i) !! n in doNTimes (*2) 3 5
15:53:35 <lambdabot>  40
15:56:03 <lesshaste> TSC: ah right
15:56:51 <DRMacIver> Hm. I don't think I'd twigged to the fact that read's only type paramater was in its return type. Neat.
15:57:08 <fyx> :D
15:57:08 <fyx> http://img89.imageshack.us/img89/8873/spiralco1.gif
15:57:12 <fyx> my program is coming along
15:57:42 <DRMacIver> Writing a logo interpreter? :)
15:57:43 <dmwit> Is dat sum Beryl?
15:57:51 <fyx> yeah
15:57:54 <fyx> Whats beryl?
15:58:12 <fyx> hm no I dont use beryl
15:59:22 <dmwit> Shadows on your windows?
15:59:30 <fyx> they all have shadows
15:59:33 <fyx> (mac os x)
15:59:38 <dmwit> Oh, k.
16:00:05 <fyx> I use telnet right now though
16:00:07 <kc5tja> Curious -- is there an HTML rendering widget for Haskell?  Preferably as part of wxHaskell?
16:00:10 <fyx> to give commands to the turtle
16:02:39 <kc5tja> @hoogle html
16:02:40 <lambdabot> Text.Html :: module
16:02:40 <lambdabot> Text.Html.Html :: [HtmlElement] -> Html
16:02:40 <lambdabot> Text.Html.HTML :: class HTML a
16:04:35 <hpaste>  fax pasted "evalStatement" at http://hpaste.org/934
16:05:19 <fyx> URK
16:05:25 <fyx> I didntmaen to annonce that sorry
16:06:29 <tuukkah> kc5tja, for some simple user interfaces in gtk2hs, this may do: http://haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.10/Graphics-UI-Gtk-MozEmbed.html
16:06:31 <lambdabot> http://tinyurl.com/263tgx
16:07:51 <sorear> yay!!!
16:07:55 <kc5tja> tuukkah: Actually, preferably NOT using Mozilla.  ;D
16:08:04 <sorear> my layout rule processor seems to work now ...
16:08:30 <stepcut> yay!
16:08:44 <DRMacIver> kc5tja: What's wrong with Mozilla? :)
16:08:53 <kc5tja> DRMacIver: ... everything?  :)
16:09:00 <DRMacIver> No, seriously.
16:09:06 <fyx> > upcas "sdflasdf"
16:09:07 <lambdabot>   Not in scope: `upcas'
16:09:07 <kc5tja> DRMacIver: It's slow (remember when it was fast?).  It leaks memory voraciously.
16:09:10 <fyx> > upcase "sdflasdf"
16:09:11 <lambdabot>   Not in scope: `upcase'
16:09:13 <tuukkah> kc5tja, perhaps you'll want to bind some version of gtkhtml yourself then ;-)
16:09:16 <fyx> > capitolise "sdflasdf"
16:09:17 <lambdabot>   Not in scope: `capitolise'
16:09:35 <dmwit> > let upcase = map toUpper in upcase "asdfds"
16:09:36 <lambdabot>  "ASDFDS"
16:09:42 <DRMacIver> kc5tja: The former, true enough. It doesn't leak memory. Particularly if all you're embedding is the rendering engine.
16:09:44 <fyx> :D
16:09:45 <fyx> thenkas
16:09:46 <fyx> thanks
16:10:06 <dmwit> ?hoogle String -> String
16:10:07 <lambdabot> Network.URI.normalizeCase :: String -> String
16:10:07 <lambdabot> Network.URI.normalizeEscape :: String -> String
16:10:07 <lambdabot> Network.URI.normalizePathSegments :: String -> String
16:10:09 <kc5tja> tuukkah: We were looking at KHTML in a C++ project, but I might be convincing the others in the project to use Haskell.
16:10:56 <kc5tja> DRMacIver: I disagree.  Leaving Firefox 1.x or 2.x running on my box for extended periods of time results in substantial delays as "something" garbage collects.  In some cases, it's actually crashed X11 to the point where I had to reboot the system (SSH didn't work).
16:13:44 <dmwit> kc5tja: There's a lot more to Firefox than its rendering engine...
16:14:20 <dibblego> is there such a thing as revision controlled lazy lists?
16:15:05 <tuukkah> as we're talking about mozembed, i need to acknowledge it uses large parts of mozilla/firefox/xulrunner
16:15:06 <Eelis> "It doesn't leak memory. Particularly if all you're embedding is the rendering engine."  hahaha, this sounds like:  "honey, i've never cheated on you! especially not on weekdays!"
16:16:24 <tuukkah> at one point i was planning to switch from python to javascript so i'd at least get a decent html widget =)
16:16:39 <araujo> hello
16:16:41 <DRMacIver> Eelis: The main browser has a number of 'features' which use a large amount of memory. Most of these are unrelated to the rendering engine.
16:17:13 <ndm> DRMacIver: but getting the HTML widget to space leak, esp with javascript, is trivial
16:17:23 <Eelis> simply using large amounts of memory does not necessarily constitute leaking
16:17:24 <tuukkah> DRMacIver, do you have a plan for embedding plain gecko? would you need to start with xpcom for haskell?
16:17:41 <ndm> Eelis: it properly leaks
16:17:55 <ndm> Yhc Javascript has various work arounds for some of the memory leaks
16:18:02 <ndm> some of the things leak on IE, and not on Firefox
16:18:07 <ndm> some vice versa
16:18:11 <DRMacIver> tuukkah: I don't have any intention of doing it, so I've not thought about it. :)
16:18:25 <ndm> although IE7 is a load better than IE6 for leaks
16:18:45 <DRMacIver> Anyway, I'm off to bed,
16:19:34 <acro> mauke: could you join foo_acro?
16:22:15 <fyx> > toUpper 'x'
16:22:17 <lambdabot>  'X'
16:22:21 <fyx> @doc toUpper
16:22:21 <lambdabot> toUpper not available
16:22:26 <fyx> @hoogle toUpper
16:22:27 <lambdabot> Char.toUpper :: Char -> Char
16:22:33 <fyx> where is toUpport from?
16:22:46 <ndm> fyx: Char, or Data.Char
16:23:04 <fyx> ok thank you
16:23:06 <ndm> fyx: Hoogle told you, Char.toUpper -- Char is the module name
16:25:39 <sorear> wow, we have 30% of the haskell workshop committee here
16:26:26 <mbishop> sorear: kick out the other 70% and now 100% are here :)
16:40:24 <sjanssen> dons: re: error handling.  xlib really sucks
16:44:40 <fyx> how many datatypes do you make?
16:44:48 <fyx> in smaller programs.. is it a lot?
16:45:57 <ndm> heffalump, lennart - who else?
16:46:09 <ndm> fyx: usually not many, in bigger programs often quite a few
16:46:19 <dmwit> fyx: I find myself using library ones more than own-defined ones.
16:46:40 <sorear> ndm: ccshan, (and lennart is augustss here)
16:46:48 <sorear> @seen ccshan
16:46:48 <lambdabot> I haven't seen ccshan.
16:46:55 <sorear> bad lambdabot!
16:46:59 <dmwit> Sometimes some type-synonyms are helpful, though.
16:47:02 <ndm> i've never seen ccshan
16:47:43 <dons> sjanssen: right. so the patches i pushed fix things entirely on my machine
16:48:08 <dons> sjanssen: is it even possible to register a Haskell function as the error handler?
16:48:14 <fyx> hm
16:48:17 <dons> for XSetErrroHandler ?
16:48:21 <fyx> http://hpaste.org/936
16:48:27 <fyx> to many data types?
16:48:47 <fyx> I have types for parsing, for AST, for other stuff probably..
16:49:36 <dons> sjanssen: to do this we need a #enum for XErrorEvent, and for the opcodes, and then a way to wrap  haskell function and register it as the error handler
16:49:46 <dons> if you look in X11-extras/cbits you'll see what I currently do ...
16:50:18 <ndm> fyx: no, looks sensible
16:50:37 <sorear> from my local logs:
16:50:37 <sorear> 05.11.24:14:20:27 <ski> ccshan : Chung-Chieh Shan ?
16:50:37 <sorear> 05.11.24-14:20:47 <Philippa_> palomer: the simply-typed lambda calculus
16:50:37 <sorear> 05.11.24-14:20:58 <Philippa_> (and especially not without an environment
16:50:40 <sorear> 05.11.24:14:21:09 <ccshan> pediddle: http://www.brics.dk/RS/05/13/index.
16:50:43 <sorear> 05.11.24:14:21:21 <ccshan> ski: yes, hi
16:50:46 <sorear>  
16:51:30 <ndm> sorear: never seen him before
16:51:55 <ndm> (assuming its a he)
16:52:10 <dons> ndm... yes, Chung-Chieh Shan's been here before a couple of times
16:52:22 <dons> ndm, e.g. co-author of half of Oleg's papers
16:53:07 <dons> looks like credit suisse is taking over the HW :-)
16:53:21 <ndm> :)
16:53:30 <ndm> didn't galois have a similar number last year?
16:53:49 <dons> i'm sure they have in the past
16:54:51 <sorear> ndm: ccshan is here rarely and speaks *very* rarely (indeed, I've never seen the latter).  if your client hides joins/parts it would not be at all suprising you never noticed him.
16:56:55 <dons> sjanssen: so what are your thoughts re. tiling?
16:57:05 <dons> should we just attempt to implement tiled mode without tags?
16:59:32 <dons> sjanssen: since i imagine on anything larger than 1024x768 we'd want tiled windows
17:00:24 <ndm> is this the haskell window manager?
17:00:40 <dons> yeah.
17:00:50 <dons> which i'm using right now
17:00:54 <cjay> 4 terms work well on my 1024x768 laptop
17:01:02 <dons> maybe with tiny fonts :-)
17:01:11 <ndm> impressive
17:01:19 <dons> ?where xmonad
17:01:19 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
17:01:28 <cjay> yes, fontsize 8, but works good :)
17:01:32 <mwc> When using STM for concurrency, create a thread using forkIO and then run the STM computation using atomically?
17:01:33 <dons> ndm, they're pretty easy to write. we're going to turn it into a howto article in fact
17:01:52 <mwc> dons, howto write a monad?
17:01:55 <ndm> i was thinking of doing an article on combintor design
17:02:02 <ndm> perhaps for the monad reader
17:02:12 <dons> mwc, you missed the first part ;)
17:02:15 <dons> how to write a window manager
17:02:24 <mwc> dons, cool
17:02:51 <ndm> am trying to decide whether it belongs as a blog post, or as a monad reader thing
17:03:13 <mwc> Next we'll have to go finish the HURD project using Haskell :)
17:03:15 <fyx> whats combinator design?
17:03:24 <ndm> fyx: have you used parsec?
17:03:26 <mwc> Those guys never get anything done
17:03:28 <fyx> yes
17:03:35 <merus> Finish HURD using Haskell++
17:04:02 <ndm> fyx: its a combinator library, you design a small library
17:04:13 <dons> the nice thing is that we have a good replacement for my old window manager, in 1/8th the lines of code, in 4 days
17:04:20 <dons> with no segfaults in between.
17:04:27 <dons> haskell works nicely as glue code :-)
17:06:01 <mwc> dons, if it supports ICCCM then that's pretty amazing
17:06:22 <araujo> merus, interesting you mentioned ; there has been some post about using Haskell n the hurd mailing list.
17:06:42 <dons> well, it binds to Xlib, and seems to wor (gimp, firefox all survive) so i'm happy
17:06:46 <ndm> yeah, but by a guy who doens't seem to have a clue
17:06:52 <ndm> he posted on haskell, yhc, ghc etc
17:06:57 <dons> ah that guy...
17:07:02 <ndm> trying to round up a bunch of people, but not with any concrete ideas
17:07:14 <ndm> i think he pissed off all the hurd developers quite quickly
17:07:54 <araujo> ndm, the thing is not many people is willing to give it a try to such a idea :-)
17:07:58 <araujo> But i like it
17:08:20 <ndm> araujo: and its been done at least twice, but i think people were more objecting to the way he approached it, rather than the idea itself
17:08:35 <araujo> ndm, i am talking about the idea
17:08:53 <ndm> araujo: i like the idea too
17:08:55 <dons> there are 3 kernels i know of, and one kernel prototype
17:09:07 <dons> ah, 4 actually
17:09:17 <dons> so the use of haskell for this kind of thing is pretty well established
17:09:40 <araujo> dons, which 4?
17:09:45 <araujo> i only know house
17:10:14 <resiak> Hrm.  lambdabot experts: do line numbers produced after BotPP has done its dirty work match those in the source file?
17:10:29 <dons> hop, house, the l4/isabelle kernel, and galois' kernel (based on house i guess)
17:10:55 <fyx> >:t
17:10:56 <araujo> right, so there is a l4 based kernel.
17:10:57 <ndm> is galois's kernel public knowledge?
17:11:15 <dons> its been mentioned a few times, but i don't think the code is public
17:11:50 <cjay> isn't house based on hop?
17:12:08 <ndm> yes, based on the knowledge gained in hop
17:13:39 <dons> there's a couple of other haskell kernel fragments of l4 here at unsw too
17:13:48 <dons> page table designs and so on
17:15:50 * araujo would really like to use a haskell OS
17:17:19 <mwc> dons, do you mean that parts of the L4 microkernel are implemented in haskell, or servers on top of L4?
17:17:22 <stepcut> house could really use a prettier widget set
17:17:46 <araujo> mwc, L$ is just a specification
17:17:48 <araujo> L4*
17:17:58 <cjay> does house rely on language based memory safety?
17:18:37 <cjay> I mean, running everything in privileged mode like inferno does
17:20:03 <mwc> araujo, right, I was asking if they were writing part of the microkernel implementing that speficication in haskell
17:20:24 <mwc> araujo, L4 kernels tend to get called l4,,, l4ka for instance
17:20:58 <araujo> mwc, yes, there are many L4 based kernels ... i guess the one dons mentioned is partly written on haskell
17:21:32 <mwc> wow, that's pretty ambitious. I thought that in the microkernel itself you'd want to keep it absolutely spartan.
17:21:53 <mwc> There's a haskell heap inside the kernel address space?
17:22:03 <sorear> resiak: no, the line numbers are bogus after botpp
17:24:57 <resiak> sorear: damn!
17:25:13 * resiak was wondering why he had a "possibly incorrect indentation" error at a blank line :o)
17:26:29 <sjanssen> dons: yes, I'd like to get tiling done
17:26:51 * resiak comments out stuff with extreme prejudice until plain ghci can parse the file!
17:27:09 <sjanssen> I think doing tags at the same time makes sense, because we're going to have to overhaul the StackSet code anyway
17:27:11 <cod3po37> Has anyone else had trouble compiling the latest version of HAppS 0.8.8? Somehow when all is said and done, it's not getting done. Neither the configure nor build stage show an error but only 69 of 72 steps are completing then it starts linking...:(
17:27:42 <Eelis> what's next after tiling? tabbing?
17:28:02 <sjanssen> Eelis: floating
17:28:15 <Eelis> i see
17:28:18 <sjanssen> I'm not sure I see a need for tabbing
17:28:37 <mbishop> tabbing only works well with floating
17:28:40 <Eelis> for me it is the opposite: tabbing is vital, and floating i've never had a use for
17:28:59 <zanar> I'm trying to build darcs on Ubuntu. I get the following error when I do 'make': Lcs.lhs:433:8: Not in scope: type constructor or class `HasBounds'. Any ideas?
17:29:14 <sjanssen> floating is necessary for apps like Gimp and "transient" popups
17:29:59 <sjanssen> zanar: are you using ghc 6.6?
17:30:16 <zanar> sjanssen: yes, ghc built from source.
17:30:26 <zanar> sjanssen: 6.6
17:30:33 <sjanssen> zanar: I think you'll need a darcs version of darcs
17:30:43 <sjanssen> (which might be a chicken and egg problem for you)
17:30:53 <TSC> Yes, I had that problem too
17:31:04 <TSC> I succumbed and got a binary version of darcs
17:31:34 <zanar> I'm a little confused. So should I obtain a binary version of darcs for ubuntu, and then update to the latest version by building from source?
17:31:56 <sjanssen> zanar: yes, that is probably what you should do
17:31:59 <TSC> Sure, use the binary darcs to checkout the darcs version
17:32:20 <sjanssen> you might not need the latest version, I think there's a pre-release that will build with 6.6
17:32:38 <zanar> sjanssen, TSC: many thanks then :)
17:33:06 <zanar> by the way what's the option get --partial in darcs?
17:33:15 <sjanssen> zanar: try darcs-1.0.9rc2, there's a tarball for it
17:33:25 <Pastorn> what's with the datatype declaration here?
17:33:27 <Pastorn> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
17:33:29 <lambdabot> Title: 7.5. Generalised Algebraic Data Types (GADTs)
17:33:35 <kc5tja> I'm not aiming to start a flame war with my following question; but, is there any literature that compares Haskell's type system features (and best practices on how to use them) versus object oriented software design?  Thanks.
17:33:43 <Pastorn> isn'n it supposed to be
17:33:45 <sjanssen> Pastorn: it is a GADT
17:33:48 <sorear> Pastorn: huh?  it's generalized!
17:33:50 <TSC> zanar: It gets a partial copy of a repository, so it has only recent history (but apparently is a bit buggy)
17:33:56 <Pastorn> data Type = Constructor a b
17:33:57 <kc5tja> (e.g., in OO we typically do this.  Here's how to do the same basic thing in Haskell.)
17:33:59 <dons> kc5tja: this gets discussed a fair bit on the mailing list
17:34:00 <zanar> I've installed the binary for darcs. What's the command to update it. is it darcs update?
17:34:08 <zanar> TSC: I see :)
17:34:18 <kc5tja> dons: But, nothing concise, searchable, ?
17:34:48 <dons> kc5tja: no, but you could read the OOHaskell papers
17:34:51 <TSC> zanar: The darcs webpage should have instructions on how to get the source via darcs
17:34:52 <dons> i'm sure they discuss the background
17:35:00 <Pastorn> my problem is that they're using "where" when declaring a data type... and never any |'s
17:35:04 <QtPlatypus> kc5tja: Sounds like your looking for a cookbook of some sort?
17:35:20 <sorear> Pastorn: that's not astandard datatype
17:35:26 <dons> kc5tja: in general, we use typeclasses, polymorphsm, modules and existential types to do object-oriented resuse/encapsulatoin stuff
17:35:32 <kc5tja> QtPlatypus: Kind of; I'm just looking for more examples of how to "think in Haskell" when doing Haskell coding.
17:35:43 <dons> ah, the Zen of Haskell
17:36:04 <dons> you must become one with the lambda
17:36:11 <sorear> Pastorn: why would  an extension to datatype syntax use the standard syntax?  wouldn't that just defeat the purpose?
17:36:14 <dons> ?quote reduce
17:36:14 <lambdabot> ClaudiusMaximus says: compiling with -O2 reduced the time taken by my program's execution from 28mins to 17secs
17:36:15 <Pastorn> btw, speaking of datatypes, need a name:
17:36:35 <Pastorn> data Type = What | Do | I | Call | These?
17:36:38 <dons> ?quote reduced
17:36:39 <lambdabot> ClaudiusMaximus says: compiling with -O2 reduced the time taken by my program's execution from 28mins to 17secs
17:36:45 <sjanssen> Pastorn: data constructors
17:36:47 <dons> ?quote is.reduced
17:36:48 <lambdabot> bd_ says: If a graph is reduced in a forest, and no one is around to pattern match the resulting WHNF, does it cause a space leak?
17:37:02 <Pastorn> sorear: true...
17:37:19 <sorear> ?quote 2.lines.each
17:37:20 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
17:37:30 <kc5tja> dons: I do not have problems with lambdas as such.
17:37:30 <sorear> that your target?
17:37:35 <Pastorn> so in th example is Lit, Succ, IsZero... constructors?
17:37:48 <sjanssen> Pastorn: yes
17:38:10 <Pastorn> but why do they have types?
17:38:22 <sjanssen> Pastorn: because they're generalized
17:38:25 <Pastorn> are they functions as well?
17:38:31 <kc5tja> Well, although I grok lambdas, I still prefer named functions for the most part.  Most of my function definitions are about 5 lines, mostly do to where-clauses.
17:38:42 <sjanssen> Pastorn: http://haskell.org/haskellwiki/GADT
17:38:44 <lambdabot> Title: Generalised algebraic datatype - HaskellWiki
17:39:12 <dolio> Regular data constructors have types, too.
17:39:20 <dolio> ?type Just
17:39:22 <Pastorn> sjanssen: thanks :D
17:39:23 <lambdabot> forall a. a -> Maybe a
17:39:24 <sjanssen> Pastorn: all data constructors are also functions
17:39:28 <waern> Pastorn, didn't you buy the Haskell course book? :)
17:39:44 <Pastorn> waern: no, i still have yours :p
17:40:06 <waern> Pastorn, uhm right. Forgot about that :D you should read it sometime
17:40:11 <waern> ;)
17:41:17 <Pastorn> hehe... HEY! It covers this!!
17:41:21 <Pastorn> cool
17:44:03 <narain> > "foo" ++ "bar" : []
17:44:04 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
17:44:23 <narain> > ("foo" ++ "bar") : []
17:44:25 <lambdabot>  ["foobar"]
17:48:00 <sm> can I pattern match on the number of items in a list argument ?
17:48:21 <fyx> fn [a,b,c,d,e,f] kind of thing?
17:48:24 <sm> yes
17:48:31 <dons> >  let f [a,b,c] = 3 ; f _ = fail "foo" in f [1,2,3]
17:48:32 <lambdabot>   add an instance declaration for (Num (m a))
17:48:32 <lambdabot>     In the expression:
17:48:32 <lambdabot>         ...
17:48:45 <dons> >  let f [a,b,c] = 3 ; f _ = error "foo" in f [1,2,3]
17:48:46 <lambdabot>  3
17:49:06 <sm> thank you.. hmm
17:50:09 <tuukkah> can i somehow import modules in ghc command line for -e ?
17:51:55 <sorear> afaik no.  the non-orthogonal handling of top level directives, expressions, and declarations is IMO the area where haskell loses most to lisps.
17:52:44 <dons> it would be easy to add support
17:52:48 <tuukkah> now i'm losing because i have a bug that i can't reproduce in ghci
17:53:04 <dons> ghc -e just runs ghci, iirc. so you can just use qualified names
17:53:16 <dons> it'd be a 2 lines patch to add support for a module list argthat just calls +m before running 'main'
17:53:23 <sm> >  let f [a] = "one" ; f ts = "many" in f [1,2,3]
17:53:25 <lambdabot>  "many"
17:53:32 <sm> >  let f [a] = "one" ; f ts = "many" in f [1]
17:53:34 <lambdabot>  "one"
17:54:05 <mjjm> "map (\x -> 4) $ array (1,2) [(1,1),(1,2)]" is failing.. and i can see why since it wants a list, but the Array module documentation says you're supposed to be able to use map on arrays somehow.. what am i missing here?
17:54:17 <tuukkah> dons, using qualified names gives me this: "home-package module `Irc2RDF' is mentioned, but does not appear in the dependencies of the interface"
17:54:50 <dons> ghc -e is a bit of a hack though, why don't you just use runhaskell or compile the code?
17:55:36 <tuukkah> right, this was just one road to take in catching the bug
17:56:09 <mjjm> let's pretend i said array (1,2) [(1,1),(2,3)] i guess too
17:56:46 <sorear> mjjm: map is not very polymorphic :( there's a more general version, try 'fmap'
17:57:21 <mjjm> that does it
17:57:22 <mjjm> thanks
17:58:05 <tuukkah> trying to compile, now ghc complains that i'm not using UTF-8. i thought ghc doesn't support utf-8 and definitely my locale isn't utf-8
18:01:04 <tuukkah> less automated but reading the 8-bit characters with getLine solves that for now
18:02:02 <sorear> tuukkah: GHC, as of 6.6, always uses utf8 regardless of locale
18:02:21 <tuukkah> and ghci never uses?
18:02:35 <sorear> ghci too
18:02:47 <sorear> note that that's only for Haskell
18:02:57 <sorear> IO is always done in ISO-8859-1
18:03:04 <tuukkah> don't see that here in string literals
18:03:16 <sorear> string literals need to be in utf8
18:03:24 <sorear> since they are part of source code
18:03:32 <tuukkah> here in ghc yes but in ghci no
18:03:37 <sorear> input to your program must be in iso8859-1
18:04:21 <tuukkah> the io part is why i'm debugging these fromUTF and toUTF hacks
18:04:54 <hpaste>  jberg pasted "compilation problem" at http://hpaste.org/937
18:05:12 <dons> oh, I was just getting all worked up about the 'academics don't publish code' article, then I see that oh, hey, the haskell guys actually do :-)
18:05:20 <desp> <3
18:05:30 <FearOfThePointer> m about to port GHC on QNX6 this month
18:05:55 <dons> ok. cool. have you ported ghc before?
18:06:06 <narain> ?src lines
18:06:06 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:06:14 <FearOfThePointer> nope, also doing the same with Factor
18:07:09 <jberg> someone have a hint for my paste?
18:08:06 <FearOfThePointer> where should i post the binary/source package
18:08:43 <sorear> can't you just darcs send your changes back to the mainline?
18:09:11 <dons> FearOfThePointer: once you patch the code, darcs send the patches bcak to glasgow-haskell-users@ for merging into the main tree
18:09:19 <allbery_b> jberg: you want [(...)] not just (...)
18:09:26 <dons> if you produce a binary, you can ask on glasgow-haskell-users@ for it to be linked from the GHC home page
18:09:28 <allbery_b> a tuple is not a list of tuples
18:09:42 <FearOfThePointer> dons: oks 10x
18:09:54 <sorear> FearOfThePointer: of course it would be best to start with the HEAD version
18:09:59 <sorear> FearOfThePointer: "oks 10x"?
18:10:11 <hpaste>  allbery_b annotated "compilation problem" with "a tuple is not a list of tuple" at http://hpaste.org/937#a1
18:10:54 <jberg> allbery_b: right.. but then i get a double list of triplets
18:11:46 <allbery_b> maybe you want concatMap instead of Map, then?
18:11:59 <FearOfThePointer> c ya
18:12:12 <allbery_b> alternately return Nothing vs. Just (...) and use catMaybes on the resulting list
18:12:25 <allbery_b> er, insteafd of map
18:12:36 <jberg> yes i think concatMap will work, thanks
18:12:46 <sorear> allbery_b: mapMaybe!
18:12:52 <desp> is it possible to do something like "let var = val" in hugs?
18:12:57 <desp> ghci allows it...
18:12:59 <sorear> not afaik
18:13:04 <desp> odd
18:13:16 <sorear> haskell interpreters aren't supposed to exist :)
18:13:30 <desp> hmm? :)
18:13:46 <desp> too hard to reason about code one line at a time?
18:13:50 <dons> desp: you can't do that in hugs.
18:14:13 <dons> mututal recursion makes let bindings tricky
18:14:20 <dons> anyway, hugs is dead. long live ghci
18:14:26 <desp> aw
18:14:37 <dons> let f = g
18:14:40 <dons> -- oops
18:14:41 <dons> let g = 1
18:14:55 <dons> valid haskell, but not line by line typed into a interpreter
18:14:58 <desp> well
18:15:15 <dibblego> can you specify a URL that uses SSH somehow with darcs push/pull?
18:15:25 <sorear> let { f = g; g = 1}  -- :)
18:15:36 <dons> dibblego: you can just pass an ssh url, yes
18:15:40 <desp> :)
18:15:46 <tuukkah> what would make this not catch the exception in some cases: fromUTF s = unsafePerformIO $ newCString s >>= \cstr -> Control.Exception.catch (readUTFString cstr >>= Control.Exception.evaluate) (\_e -> return s)
18:15:46 <dibblego> dons, as in ssh://blah ?
18:15:48 <dons> darcs get user@host:/home/path/to/repo
18:15:52 <dibblego> ah thanks
18:16:00 <dons> you'll want ssh keys set up to avoid passwords
18:16:08 <dons> (or control master/slave connectoins)
18:16:11 <dibblego> yep got that
18:16:26 <dons> tuukkah: if evaluate didn't force the value fully
18:16:30 <desp> sigh
18:16:37 <desp> I wish I knew Haskell for last years ICFP
18:16:39 <dons> e.g. it only went to WHNF, but there was an exception further down the structure
18:16:58 <tuukkah> argh :-)
18:16:59 <dons> tuukkah: e.g. if it is a list, you'll want to length xs `seq` ... just to force the spine
18:17:15 <tuukkah> that must be it
18:17:19 <dons> and then you might even want to think about using DeepSeq to force the structure fully
18:17:39 <dons> > [1,undefined] `seq` 2 -- WHNF
18:17:41 <lambdabot>  2
18:17:47 <dons> > length [1,undefined] `seq` 2 -- force the spine
18:17:49 <lambdabot>  2
18:18:08 <dons> > length (map (\x -> seq x x) [1,undefined]) `seq` 2 -- force the spine, and the elems
18:18:10 <lambdabot>  2
18:18:15 <dons> oh, maybe not :-)
18:18:38 <kc5tja> yikes.  To process a 7MB source file, my Haskell implementation of CUT took 220MB and 11 minutes.
18:18:45 <stepcut> yay!
18:18:46 <dons> kc5tja: use Data.ByteString
18:19:09 <kc5tja> Yeah, but, 220MB!!  Good lord, where does the RAM go?  :)
18:19:10 <dons> and be sure to compile with -O2
18:19:17 <kc5tja> Oh, I didn't do that.
18:19:24 <dons> kc5tja: a lazy [Char] uses too much space
18:19:25 * kc5tja tries that, but w/out ByteString, just to compare.
18:19:35 <dons> no no, bytestring needs -O2
18:19:43 <dons> probably won't do much at all to [Char]
18:21:10 <kc5tja> Meh, worth the comparison anyway.  :)  Collecting data = good.  :)
18:21:39 <kc5tja> Well, its working set sure shot up to 128MB faster than it did before.  :D
18:21:48 <dons> there's a specific optimisation with -O2 that bytestring likes.
18:22:10 <QtPlatypus> dons: Part of the deforestation?  Or something elese?
18:22:15 <dons> dons rule: once it reaches 500k, use bytestring
18:22:25 <dons> QtPlatypus: the SpecConstr optimisation
18:22:36 <dons> it helps unwrap constructors in a way that really helps out bytestring
18:22:48 <dons> removing all the intermediate values in the Stream data type we use for fusion
18:22:57 <kc5tja> dons: Is it terribly difficult to write C modules that don't sit in the IO monad?  E.g., to create new intrinsic types for Haskell?
18:23:18 <dons> if the C code is pure, you can just use it, yes.
18:23:23 <dons> e.g. 'sin' or other math ops
18:23:34 <dons> by intrinsic types do you mean primitives?
18:29:12 <dons> ?where+ network6 darcs get --partial http://darcs.serpentine.com/network6
18:29:13 <lambdabot> Done.
18:32:26 <sjanssen> dons: on second thought, it might be better to extend StackSet for now
18:33:03 <sjanssen> a workspace becomes two [a] -- one for focus and one for layout
18:34:20 <kc5tja> dons: Hey, not bad -- it finished in only 8 minutes instead of 11.  :D
18:34:27 <adamjones> I'd like to commend the Haskell community on making learning easy. Finding resources to learn Haskell is a breeze compared to what I went through with Common Lisp.
18:34:28 <sorear> dons: so, is xmonad going to be extensible with hsplugins?
18:34:36 * kc5tja will research ByteString in just a bit.  Gotta do some errands.
18:34:51 <adamjones> The wikibook especially has been neat.
18:35:07 <sjanssen> sorear: it's going to be compile time configuration for now
18:35:58 <sjanssen> sorear: and I don't think such heavy weight run time configuration is necessary
18:40:38 <dons> adamjones: wow. great. I'm so pleased.
18:40:46 <dons> sorear: nope.
18:42:36 <adamjones> dons: Just thought I would start saying thank yous now. Granted, it only barely makes sense, but that isn't due to the quality of the explanations.
18:45:40 <tuukkah> > foldr seq 0 [1,undefined] `seq` 2
18:45:42 <lambdabot>  Undefined
18:46:00 <tuukkah> that should do it but i'm still seeing some weird memory corruption or something
18:51:27 <sorear> > rnf [1,undefined] `seq` 2
18:51:29 <lambdabot>  Undefined
18:53:01 <resiak> @src rnf
18:53:02 <lambdabot> Source not found. I feel much better now.
18:53:11 <sorear> @src NFData
18:53:12 <lambdabot> Source not found. Take a stress pill and think things over.
18:53:15 <sorear> bah.
18:53:28 <sorear> @source Control.Parallel.Strategies
18:53:29 <lambdabot> http://darcs.haskell.org/packages/base/Control/Parallel/Strategies.hs
18:56:55 <sorear> instance NFData a => NFData [a] where
18:56:55 <sorear>   rnf [] = ()
18:56:55 <sorear>   rnf (x:xs) = rnf x `seq` rnf xs
18:57:46 <dibblego> sorear, what does that do exactly besides strictify?
18:58:05 <tuukkah> evaluate to () ?-)
18:58:10 <sorear> that's the whole point
18:58:13 <sorear> strictify
18:58:32 <sorear> *r*educe to *n*ormal *f*orm
18:58:38 <dibblego> ah
18:58:46 <kc5tja> Hahah, now it's MY turn to explain monads to someone, and blow THEIR brains for a change.
19:02:26 <fyx> :D
19:02:50 <fyx> I read about monads last night...
19:03:02 <fyx> my brain didnt blow.. can you recommened better material?
19:03:22 <desp> ahh...
19:03:24 <desp> deriving Show
19:03:28 <desp> that's handy
19:03:37 <cpfr> i think dons has a good explanation
19:03:42 <cpfr> in his hacking example
19:03:59 <desp> fyx: have you gone through All About Monads, Of monads and spacesuits, You Could Have Invented Monads!
19:04:06 <fyx> yes
19:04:16 <rahikkala> @quote spacesuite
19:04:17 <cpfr> i hated All About Monads
19:04:17 <lambdabot> dons says: think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples.  now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
19:04:17 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
19:04:39 <fyx> LOL
19:04:47 <desp> :D
19:04:54 <desp> rotfl
19:05:04 <sorear> grr.
19:05:12 <cpfr> actually
19:05:14 <sorear> I wish C had ADTs :)
19:05:19 <cpfr> the best one i found
19:05:26 <cpfr> is tackling the awkward squid
19:05:35 <sorear> who needs monad tutorials? :)
19:05:37 <desp> sorear: you can get pretty close with an enum and void* ;p
19:05:42 <Pastorn> cpfr: dons example? where?
19:05:46 <cpfr> read that one and wikibooks example
19:05:59 <fyx> "tackling the awkward squid" ?
19:06:05 <desp> s/squid/squad/
19:06:05 <cpfr> yep
19:06:10 <kc5tja> fyx: I was thinking of taking Eric Kowey's advice and writing my own interpretation on monads, which both cements the concept in my own head, plus helps others to understand them.
19:06:11 <fyx> ok cheers
19:06:11 <stepcut> sorear: C? isn't that some low-level language that compilers output to ?
19:06:11 <Pastorn> sorear: yeah, it's all very intuitive
19:06:13 <jcreigh> I hate those awkward squids. :)
19:06:21 <fyx> kc5tja: yes please D:
19:06:22 <desp> :D
19:06:22 <kc5tja> But that will take some time.
19:06:27 <cpfr> www.cse.unsw.edu.au/~dons/blog
19:06:36 <fyx> everyone will write about monads and the best explanation will live!
19:06:44 <sorear> kc5tja: FTR his surname is just Kow
19:06:59 <desp> so the movement to rename them Soft Fuzzy Things haven't gained much traction?
19:07:04 <sorear> @remember stepcut C? isn't that some low-level language that compilers output to?
19:07:05 <lambdabot> Done.
19:07:05 <kc5tja> sorear: Oh.  Didn't know.  Thanks.
19:07:10 <fyx> cpfr: ill read that as well, thnks
19:07:59 <cpfr> "If you recall from the dozens of other monad tutorials out there, a monad gives us a programmable ';' (the semicolon statement terminator from the imperative world). With a custom monad we can specify precisely what happens at the end of each statement in our code."
19:08:06 <cpfr> that part is what got me
19:08:24 <kc5tja> I have a lot of instances of String in my code; I'd like to replace them with ByteString.  Is it sufficient for me to say import Data.ByteString and type String = Data.ByteString ?
19:08:42 <kc5tja> I remember reading something about qualified imports, but they don't appear to do what I am looking to do.
19:08:43 <cpfr> i think you need to hide
19:09:14 <sorear> kc5tja: in case you didn't know - /whois user almost always gives the user's name.  (technically it is a freeform string the client supplies on connection, but almost everybody deliberately or otherwise gives a full legal name)
19:09:14 <stepcut> kc5tja: not quite -- because Data.ByteString includes a lot of functions like head/tail/take, etc that are already in the Data.List module
19:09:40 <sorear> kc5tja: import qualified Prelude
19:09:42 <kc5tja> sorear: I'm well aware of /whois; however, in 90% of the people I hang with on IRC, it *doesn't* give their real names.  :)
19:10:32 <desp> probably because they're really FBI agents
19:10:35 <desp> ;)
19:10:37 <sorear> kc5tja: the number seems more like 30% here :)
19:10:46 <stepcut> kc5tja: many people do 'import Data.ByteString.Char8 as B', so they can do B.head, B.tail to indicate they want the ByteString version
19:10:46 <sorear> I guess people are more trusting, or something
19:11:37 <stepcut> kc5tja: also, you probably want to import Data.ByteString.Char8, because Data.ByteString is for Word8
19:12:20 <kc5tja> Loading package base-1.0 ... linking ... done.
19:12:20 <kc5tja> Could not find module `Data.ByteString': use -v to see a list of the files searched for (imported from ./CutParse.hs)
19:12:21 <stepcut> kc5tja: they are mostly the same, except Char8 has a few helper functions that recognize you are working with strings (for example, lines/unlines)
19:12:22 <sorear> kc5tja: remember, if you import the prelude explicitly it isn't imported implicitly.  so if you do import Prelude hiding(head, tail, null, ...) it will work
19:12:23 <kc5tja> Prelude> Leaving GHCi.
19:12:34 <stepcut> kc5tja: what version of ghc ?
19:12:35 <jcreigh> or maybe we just don't how paranoid we should be.
19:12:40 <kc5tja> ghci 6.4.1
19:12:42 <sorear> kc5tja: *gulp* install 'fps' or ghc 6.6
19:12:46 <sorear> @where fps
19:12:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:12:51 <sorear> it's in base for 6.6
19:12:59 <sorear> actually an obsolete version is
19:13:06 <stepcut> :p
19:13:17 <kc5tja> So, either way, I need to download and install fps.
19:13:22 <sorear> the standalone fps has fusiony goodness
19:14:01 <stepcut> kc5tja: yeah -- though, the version in 6.6 is quite usuable, just not as good as standalone
19:14:48 <kc5tja> Oh no.
19:14:51 <kc5tja> There are .c modules in the code.
19:14:54 <kc5tja> Do I have to recompile GHC?
19:15:03 <kc5tja> No Makefile that I can see.
19:15:49 <stepcut> no
19:16:05 <stepcut> runhaskell Setup.hs configure ; runhaskell Setup.hs build ; runhaskell Setup.hs install
19:16:13 <stepcut> well, s/;/&&/
19:17:18 <kc5tja> Building now.
19:17:31 <stepcut> kc5tja: things never installed out of the box back when we used Makefiles. With cabal it almost always 'just works'
19:18:04 <stepcut> where we = the haskell community ; it = all the cabalized packages
19:18:22 <fyx> can you make new monads to do somthing like
19:18:30 <fyx> store the values of all variables inside a function
19:18:43 <dibblego> fyx, state monad?
19:18:44 <dmwit_> ?index State
19:18:45 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS, Test.HUnit.Base, Test.HUnit, Test.HUnit.Base, Test.HUnit, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.
19:18:45 <lambdabot> Parsec, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
19:18:47 <fyx> woo :D
19:18:51 <fyx> dont even have to wriet it
19:21:05 <stepcut> fyx: it seems to me like almost all the useful monads and monad transformers have been writen already. Typically a 'new' monad for an application can be made by using 'newtype' and 'deriving Monad' to specialize an existing monad instance to do whatever you need...
19:21:16 <kc5tja> I'm getting ambiguous references to foldr errors; it's confused over whether it should pick the one in Prelude or in ByteString.  That is rather sucky.  :(
19:21:24 <tuukkah> this doesn't crash although i'll have to add more heuristics: fromUTF s = unsafePerformIO $ Control.Exception.catch (withCString s $ \cstr -> peekUTFString cstr >>= \s' -> foldr seq () s' `seq` return s') (\_e -> return s)
19:21:48 <tuukkah> dons and sorear, thank you for your help!
19:22:00 <dmwit_> kc5tja: Maybe use hiding (foldr) ?
19:22:01 <stepcut> kc5tja: yeah, do 'import qualified Data.ByteString.Char8 as B', and then do foldr or B.foldr to pick the one you want
19:22:36 <stepcut> kc5tja: or, import Prelude hiding (foldr), if you don't use the version from Data.List at all
19:22:42 <kc5tja> dmwit_: What is hiding?
19:22:45 <sorear> kc5tja: or even 'import Data.ByteString.Char8; import qualified Prelude as P', and then do foldr or P.foldr to pick the one you want
19:23:01 <dmwit_> At the end of your import line, you can put "hiding (a, b, c)" and it won't import those variables.
19:23:23 <dmwit_> So, import Data.ByteString.Char8 hiding (foldr) would do the trick, maybe.
19:23:23 <kc5tja> Ahhh.
19:24:07 <stepcut> kc5tja: and, if you think that foldr and friends should all be part of a class 'Stringable' that has instances for String and ByteString -- you wouldn't be alone
19:24:30 <sorear> actually, it already exists
19:24:34 <sorear> Data.Traversable
19:24:40 <sorear> er, Foldable
19:24:43 <stepcut> true
19:24:43 <sorear> @src Foldable
19:24:44 <lambdabot> Source not found. Are you on drugs?
19:24:59 <merus> I love it when \bot questions someone's sanity
19:25:14 <kc5tja> stepcut: I use foldr and so forth on normal Haskell lists, not on strings.  But I can see the applicability.
19:25:26 <jcreigh> kc5tja: strings are normal haskell lists. :)
19:25:34 <kc5tja> That being said, now it's complaining about String vs ByteString, but nowhere in my code do I see where it could conceivably think a String is appropriate.  :(
19:25:51 <sorear> kc5tja: you have any string literals?
19:25:51 <kc5tja> jcreigh: You know what I mean.
19:25:55 <kc5tja> sorear: No.
19:25:59 <sorear> any uses of ++?
19:25:59 <jcreigh> kc5tja: yeah
19:26:15 <kc5tja> parseLine :: ByteString -> [CutNode] -> [CutNode]
19:26:15 <kc5tja> parseLine line nodes | isJust (testName line)     = Test (fromJust $ testName line):nodes | isJust (takedownName line) = Takedown (fromJust $ takedownName line):nodes
19:26:18 <kc5tja> ..
19:26:18 <sorear> any :? any map? and concat?
19:26:56 <sorear> testName, takedownName use BS?
19:27:01 <kc5tja> Yes.
19:27:22 <kc5tja> I did s/String/ByteString/g in VI, so *every* occurance of String has been replaced.
19:27:58 <sorear> uh, that won't work, you need a : at the front   :)
19:28:20 <kc5tja> OH, I know what it is.
19:28:28 <kc5tja> testName requires a String, because of matchRegex.
19:28:31 <jcreigh> kc5tja: do all your functions have type signatures? (Sometimes you get more useful errors messages if you add missing type sigs)
19:28:51 <jcreigh> oh, you found it.
19:29:00 <kc5tja> jcreigh: Most of them do, but not all.
19:31:53 <kc5tja> I see no functions at all to convert String -> ByteString or vice versa.
19:31:59 <kc5tja> @hoogle String -> ByteString
19:32:00 <lambdabot> No matches, try a more general search
19:32:05 <kc5tja> @hoogle String -> Data.ByteString
19:32:06 <lambdabot> No matches, try a more general search
19:32:20 <sorear> kc5tja: pack, unpack
19:32:28 <humasect> @hoogle [a] -> ByteString
19:32:28 <kc5tja> @src Word8
19:32:29 <lambdabot> No matches, try a more general search
19:32:29 <sorear> @ty Data.ByteString.Char8.pack
19:32:29 <lambdabot> Source not found. My pet ferret can type better than you!
19:32:32 <lambdabot> String -> Data.ByteString.Base.ByteString
19:32:34 <sorear> @ty Data.ByteString.Char8.unpack
19:32:38 <lambdabot> Data.ByteString.Base.ByteString -> [Char]
19:32:58 <sorear> and data Word8 = Word8 Word#, btw
19:33:08 <sorear> so a Word8 takes 8 bytes
19:33:41 <sorear> ghc has no unboxed types smaller than a word, sigh
19:38:01 * shachaf has just run across Yi.
19:38:13 <shachaf> How's its status, right now? Is it usable at all?
19:38:39 <stepcut> shachaf: it is usable, but does not do much fancy stuff
19:39:56 <stepcut> shachaf: also, I think hs-plugins does not work with ghc 6.6, so you won't be able to dynamically update the editor will it is running
19:39:57 <sorear> dons is the maint atm, jyp does all the coding
19:44:19 <kc5tja> Note to self: using ByteString involves virtually *rewriting* any string-heavy application from scratch.
19:54:48 <dons> http://programming.reddit.com/info/19kg3/comments
19:54:49 <lambdabot> Title: Haskell Weekly News: Haskell workshop, Google Summer of Code and type-level bina ...
19:59:25 <kc5tja> Hmm...time to refactor my code.
19:59:34 <kc5tja> Maybe that'll make adoption of ByteString easier.
20:00:08 <fyx> woah
20:00:08 <fyx> what
20:00:11 <narain> ?ty readList
20:00:14 <lambdabot> forall a. (Read a) => String -> [([a], String)]
20:00:14 <fyx> someone rewrote quake3 in haskell?!
20:00:22 <fyx> thats freaking crazy
20:02:25 <dmwit_> fyx: Link?
20:02:30 <fyx> http://www.haskell.org/haskellwiki/Frag
20:02:32 <lambdabot> Title: Frag - HaskellWiki
20:02:42 <_dolio> kc5tja: Did you use lots of pattern matching of lists or something?
20:03:16 <_dolio> Forcing yourself to think more in terms of maps and folds and such should make bytestring easier.
20:08:32 <hpaste>  sm pasted "getopt trouble" at http://hpaste.org/938
20:09:16 <sm> I can handle -ffile, but not -f file with getopt.. would anyone know how to do that ?
20:09:35 <sorear> require the argument
20:09:50 <narain> ?ty replicateM
20:09:52 <sorear> OptArg means -ffile
20:09:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
20:10:00 <sorear> ReqArg means -ffile or -f file
20:10:17 <sm> really ? if it's optional, the space is no longer allowed ?
20:10:24 <sorear> right.
20:10:25 <sm> that's weird
20:10:35 <sm> isn't it ?
20:11:47 <sorear> "-f" "file" : (a) -f with no arg, and file as an argument  (b) -f with arg file
20:11:52 <sorear> pick one.
20:12:44 <sm> oh I see.. filename is required by -f, though the whole (-f filename) is optional
20:13:25 <sorear> no, the whole option is always optional
20:13:39 <sorear> the question is can you have just the option but no argument?
20:13:45 <sm> right.. I thought I needed OptArg to make the option optional :)
20:13:58 <sm> Req is what I want alright
20:14:17 <narain> ?hoogle getcontents
20:14:18 <lambdabot> Prelude.getContents :: IO String
20:14:18 <lambdabot> IO.hGetContents :: Handle -> IO String
20:15:06 <sm> thanks sorear
20:19:34 <kc5tja> _jcrigby: I use pattern matching for virtually everything.  It just makes for *incredibly* readable code.
20:26:25 * sm looks for a compact way to filter a list of data values based on the constructor used
20:26:47 <araujo> fmap?
20:27:06 <ddarius> isFoo (Foo {}) = True;isFoo _ = False filter isFoo
20:27:24 <encryptio> question... is there a way to make multiple pattern matches in a lambda expression?
20:27:41 <encryptio> without case
20:28:38 <sm> that's pretty much what I'm doing.. I'll check out fmap
20:29:17 <encryptio> > (\1 -> 2; x -> x-1) 2
20:29:17 <lambdabot>  Parse error
20:29:30 <encryptio> > (\1 = 2; x = x-1) 2
20:29:31 <lambdabot>  Parse error
20:29:34 <encryptio> or something
20:29:45 <sm> araujo: could you explain fmap a little more ?
20:29:49 <narain> encryptio: only with a case expression
20:30:02 * sm stares at  (a -> b) -> f a -> f b
20:30:26 <jcreigh> sm: fmap works on Functors
20:30:37 <jcreigh> sm: a functor is basically something you can map a function over
20:30:56 <jcreigh> I think the identity is fmap f . fmap g = fmap (f . g)
20:30:56 <narain> sm: fmap is a generalization of map
20:31:18 <narain> > fmap (+1) [1,2,3]
20:31:20 <lambdabot>  [2,3,4]
20:31:25 <narain> > fmap (+1) (Just 42)
20:31:27 <lambdabot>  Just 43
20:31:35 <encryptio> > fmap (+1) Nothing
20:31:36 <lambdabot>  Nothing
20:31:41 <encryptio> cool...
20:31:41 <sm> cool
20:31:47 <TSC> Nothing + 1, surely! (:
20:31:56 <sm> and what does fmap on an IO look like ?
20:32:22 <encryptio> @src fmap
20:32:23 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:32:33 <narain> ?ty \(io :: IO Int) -> fmap show io
20:32:35 <lambdabot> IO Int -> IO String
20:32:49 <encryptio> @where fmap
20:32:50 <lambdabot> I know nothing about fmap.
20:32:50 <narain> maps the function on the result of the io
20:32:55 <encryptio> @hoogle fmap
20:32:55 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
20:32:55 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
20:32:55 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
20:32:57 <sm> ah
20:33:21 <encryptio> what's the command for a link to the ghc base library docs on a function?
20:33:32 <dibblego> ?docs
20:33:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:33:40 <encryptio> on a specific function
20:33:45 <dibblego> ?docs map
20:33:45 <narain> ?docs fmap
20:33:45 <lambdabot> map not available
20:33:45 <lambdabot> fmap not available
20:33:50 <narain> :(
20:33:53 <jcreigh> ?docs Data.Map
20:33:54 <dibblego> dunno
20:33:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
20:33:58 <narain> ?docs Data.List
20:33:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
20:34:11 <narain> ?. docs index fmap
20:34:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:34:15 <narain> bah
20:34:21 <ndm> much easier to hoogle from the website
20:34:23 <ndm> @hoogle
20:34:24 <lambdabot> HOOGLE - Haskell API Search
20:34:24 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
20:34:24 <lambdabot>  
20:34:30 <ndm> @where hoogle
20:34:31 <lambdabot> http://www.haskell.org/hoogle
20:34:40 <narain> i was trying to chain ?index and ?docs together
20:34:40 <ndm> then you get a hyperlink to the docs easily
20:35:01 <encryptio> ndm: only if you're not already here and without a mouse or cli browser
20:35:10 <encryptio> *with either
20:35:27 <ndm> encryptio: hoogle was tested with lynx :)
20:35:27 <narain> because ?docs expects a module, right? if you could do (docs . index) you could look up docs on a function
20:35:37 <lispy> kc5tja: there really seems to be a lack of research that soundly compares programming languages and paradigms.  Most of what is out there is just people arguing (hopefully) logically but not really empircally
20:35:38 <encryptio> ndm: so? i don't have lynx.
20:35:50 <ndm> encryptio: but it is a command line browser
20:35:55 <encryptio> i know it is.
20:35:57 <encryptio> i don't have it.
20:36:01 <encryptio> that's the point.
20:36:18 <lispy> oh man...i was looking at the scroll back...
20:36:24 <ndm> well hoogle 4 lets you do "hoogle map -man"
20:36:24 <kc5tja> lispy: I'm sorry; to what are you referring to?
20:36:41 <ndm> which shows you the documentation for map on the command line - so i guess is perfect for what you are after :)
20:36:47 <ndm> sadly its not released yet
20:36:48 <lispy> kc5tja: something you asked much easier about comparisons of OO and ADTs
20:36:54 <encryptio> i don't want it on the command line!
20:37:06 * encryptio grumbles.
20:37:11 <sorear> I want hoogle4.el
20:37:13 <lispy> kc5tja: i'm not yet used to irssi and didn't realize i was reading the scroll back from  many hours ago
20:37:34 <kc5tja> lispy: Oh; in that case, I might be able to provide analogies between the OO world and Haskell world, and maybe fill a niche then.
20:37:42 <ndm> i guess once hoogle 4 command line has it, lambdabot will get it too
20:37:54 * kc5tja hasn't published a semi-formal document in some time.  It'd be nice to get my credentials boosted again.  :)
20:39:32 <lispy> kc5tja: i think what is really lacking is studies performed on professional programmers and large projects wrt to programming languages used
20:39:52 <lispy> kc5tja: what research is out there seems to point at humans being the biggest variable in the equation
20:46:36 <kc5tja> Well, if you want a study, Mythical Man Month is it.  :)
20:47:09 <kc5tja> The problem is, in order to perform a large-scale study, you need a commercial-scale project, complete with product life-cycle evolution (e.g., product must be marketed, adopted, supported, etc.)
20:47:48 <kc5tja> Since Haskell (and, indeed, other languages) represents a fairly large risk to corporations (as you say, there are no studies to back its productivity claims), a corporation will not be willing to invest in the language or training its employees.
20:47:55 <kc5tja> Thus, the studies never get done.
20:47:59 <kc5tja> It's a catch-22.
20:50:39 <sm> here is one nasty/tricky function: http://hpaste.org/940
20:50:52 <sm> for me, that is. I'd love to hear any refactoring tips
20:51:21 <sm> I feel I'm tiptoeing around various monads
20:52:35 <hpaste>  sm annotated "nasty function" with "with tildeExpand" at http://hpaste.org/940#a1
20:53:52 <ddarius> sm: Isn't the first case of tildeExpand covered by the second?
20:54:11 <sm> the first case doesn't expand the env var
20:54:25 <encryptio> ddarius: nope, the first is a single element list
20:54:36 <sm> but I still need it, or the monads will beat me severely
20:55:47 <ddarius> encrytio: I meant intent-wise not pattern match wise.
20:56:12 <ddarius> [x]++xs = x:xs
20:56:26 <bos_> does anyone have a good reference for the optimisations that ghc is currently capable of performing?
20:56:37 <hpaste>  kc5tja annotated "nasty function" with "(no title)" at http://hpaste.org/940#a2
20:58:29 <sorear> /usr/local/src/ghcfull/ghc/compiler/simplCore/*.lhs.. but I doubt it's readable enough :)
20:58:46 <bos_> sorear: heh.
20:59:06 <bos_> dominic's question about sha-1 on -cafe was interesting.
20:59:22 <sorear> ok, I need a yacc parser for Haskell 98 - would haskell-src or the hugs parser make a better starting point?
20:59:26 <kc5tja> sm: Ahh, I see why you did tildeExpand twice.  I would have used let blocks to avoid having to use it twice, but it doesn't matter for code that's run once or twice in the whole program.
20:59:42 <bos_> i suspect that his code his hopelessly non-amenable to optimisation, but my knowledge of what ghc can do is 14 years out of date.
20:59:52 <sm> yes.. sorry, I wanted to describe that more clearly, but couldn't
20:59:52 <sorear> the hugs parser has more actions to understand and delete, but it's properly yacc
20:59:58 <sorear> haskell-src is happy
21:00:07 <sm> but, I see now, it's not that hard.. here's progress
21:00:39 <hpaste>  dolio annotated "nasty function" with "not any better" at http://hpaste.org/940#a3
21:01:05 <dons> ?yow!
21:01:06 <lambdabot> I'm continually AMAZED at th'breathtaking effects of WIND EROSION!!
21:01:24 <hpaste>  sm annotated "nasty function" with "file arg processing" at http://hpaste.org/940#a4
21:04:42 <kc5tja> sm: I like that last one.  In fact, I think I can use code like that in my current project.
21:04:51 <sm> cool.. but I need to expand the -f option too of course..
21:05:32 <sm> the getEnv .. catch I got from darcs, the tildeExpand from someone on this channel
21:06:10 <dolio> ?pl foo >>= return . f
21:06:10 <lambdabot> f `fmap` foo
21:08:46 <zbrown> Are there any good built-in graphing libraries for haskell?
21:08:53 <zbrown> things like 2d and 3d ones?
21:09:31 <Lemmih> There's SDL and OpenGL.
21:09:40 <encryptio> i don't understand when to use type and when to use newtype. ideas, links?
21:09:46 <Cale> hahaha thread blotttchhhkrrreeeedaaa dddinbbbdllleooofcccikkkneeeidddt eiiilnnnydddeeefffiiinnniiittteeelllyyy
21:10:18 <dolio> Is Cale's mischevious younger brother using his computer?
21:10:33 <Cale> I'm reading the Haskell Weekly News
21:11:32 <Cale> That was an error message generated apparently in GHCi. I believe it's several copies of "thread blocked indefinitely" mashed together.
21:11:41 <sm> woo!
21:11:42 <dolio> Wow. :)
21:11:55 <zbrown> Lemmih: hmmm anything a little lower scale maybe?
21:11:57 * sm does magic with mapM again
21:11:58 <sorear> > sort "blotttchhhkrrreeeedaaa dddinbbbdllleooofcccikkkneeeidddt eiiilnnnydddeeefffiiinnniiittteeelllyyy"
21:11:59 <lambdabot>  "  aaabbbbccccdddddddddddeeeeeeeeeeeeeeeffffhhhiiiiiiiiiiiikkkkllllllllnnnnn...
21:12:11 <sorear> > sort "threadblockedindefinitely"
21:12:12 <lambdabot>  "abcdddeeeefhiiikllnnortty"
21:12:24 <hpaste>  dolio annotated "nasty function" with "golf" at http://hpaste.org/940#a5
21:12:26 <kc5tja> > nub . sort "threadblockedindefinitely"
21:12:27 <lambdabot>  Couldn't match expected type `a -> [a1]'
21:12:32 <kc5tja> DOH!
21:12:43 <Cale> > nub . sort $ "threadblockedindefinitely"
21:12:44 <kc5tja> :t nub
21:12:45 <sorear> Cale: impressive
21:12:45 <lambdabot>  "abcdefhiklnorty"
21:12:47 <lambdabot> forall a. (Eq a) => [a] -> [a]
21:13:00 <kc5tja> Cale: I would have gotten there eventually.  :)
21:13:07 <Cale> > nub . sort $ "blotttchhhkrrreeeedaaadddinbbbdllleooofcccikkkneeeidddteiiilnnnydddeeefffiiinnniiittteeelllyyy"
21:13:08 <sorear> > nub . sort $ "blotttchhhkrrreeeedaaa dddinbbbdllleooofcccikkkneeeidddt eiiilnnnydddeeefffiiinnniiittteeelllyyy"
21:13:09 <lambdabot>  "abcdefhiklnorty"
21:13:10 <lambdabot>  " abcdefhiklnorty"
21:13:19 <kc5tja> hiklnorty!!
21:14:30 <zbrown> :t Data.Graph
21:14:32 <lambdabot> Couldn't find qualified module.
21:14:34 <zbrown> oops
21:14:35 <zbrown> hmm
21:14:49 <mauke> encryptio: don't worry about newtype; do you understand the difference between data and type?
21:15:36 <encryptio> mauke: mostly. data is for new aggregate/choice data types. type is for aliases. no?
21:15:54 <mauke> yes
21:15:54 <dibblego> encryptio, consider newtype to be a special case of data
21:16:12 <mauke> newtype is like data except it only supports a single constructor
21:16:26 <dibblego> ...with a single argument
21:16:45 <dolio> The sexy prime sieve someone posted a day or two ago didn't make it in.
21:16:48 <fyx> > nub $ [1..] >>= (\x -> [x,x])
21:16:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:16:54 <fyx> :O
21:16:55 <dolio> Or was that lifted from somewhere in the mailing list?
21:16:58 <fyx> > nub $ [1..] >>= (\x -> [x,x+1])
21:17:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:17:06 <encryptio> o.O
21:17:30 <bos_> newtype has always struck me as kind of useless.
21:17:53 <Cale> bos_: It's useful when you combine it with newtype deriving.
21:18:13 <encryptio> i don't get newtype at all...
21:18:19 <dolio> It's at the very least useful if a particular datatype can implement a typeclass in more than one way.
21:18:20 <bos_> Cale: but that's only good for stuff ghc can already derive, right?
21:18:23 <Cale> You can derive (almost) any class the original datatype supported through the newtype.
21:18:25 <Cale> no
21:18:26 <dibblego> encryptio, if you get data, then getting newtype is almost implied
21:18:28 <Cale> That's the point.
21:18:31 <bos_> ah.
21:18:46 <Cale> For example, you can derive Functor and Monad
21:18:56 <bos_> well, then. newtype is teh kewlzor.
21:18:58 <Cale> which is very very handy indeed
21:19:21 <kpts> is there a Haskell driver for MySQL? And for DB2?
21:19:56 <bos_> hdbc will work with any odbc driver.
21:20:17 <bos_> there's also hsql, which has mysql bindings.
21:20:45 <kpts> bos_: really? That's great. Do you know where can I find examples for HDBC?
21:21:12 <Cale> HDBC's website is so ghetto. It's a gopher index :)
21:21:32 <bos_> kpts: you probably want hsql instead.
21:21:38 <Cale> oh, there's a wiki
21:21:41 <Cale> http://software.complete.org/hdbc
21:21:42 <bos_> hsql has odbc bindings too.
21:21:43 <lambdabot> Title: Haskell Database Connectivity
21:22:09 <Cale> @where hdbc
21:22:09 <lambdabot> http://quux.org/devel/hdbc
21:22:14 <bos_> and if you want "interesting" bindings, takusen would be a good bet, but you'd need to write your own mysql bindings.
21:22:17 <Cale> @where+ hdbc http://software.complete.org/hdbc
21:22:18 <lambdabot> Done.
21:22:21 <Cale> @where hdbc
21:22:22 <lambdabot> http://software.complete.org/hdbc
21:22:25 <Cale> okay :)
21:22:26 <bos_> @where hsql
21:22:27 <lambdabot> http://htoolkit.sourceforge.net
21:22:32 <bos_> @where takusen
21:22:33 <lambdabot> I know nothing about takusen.
21:23:16 <bos_> sod. oleg posted a pointer to a new version recently.
21:23:38 <fyx> :t nub
21:23:41 <lambdabot> forall a. (Eq a) => [a] -> [a]
21:24:01 <kpts> thanks
21:24:07 <fyx> :t nubBy
21:24:10 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
21:24:15 <dolio> > let divides a b = b `mod` a == 0 in nubBy divides [2..]
21:24:17 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:24:43 <fyx> > nubBy (mod) [2..]
21:24:44 <lambdabot>   add an instance declaration for (Integral Bool)
21:24:48 <fyx> >:(
21:24:56 <fyx> > nubBy ((== 0) . mod) [2..]
21:24:57 <lambdabot>  Couldn't match expected type `a -> Bool'
21:25:08 <Cale> > nubBy (((== 0).) . mod) [2..]
21:25:09 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
21:25:13 <fyx> ooh
21:25:15 <hpaste>  sm annotated "nasty function" with "file arg processing - better" at http://hpaste.org/940#a6
21:25:16 <Cale> > nubBy (((== 0).) . flip mod) [2..]
21:25:18 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:25:21 <Cale> there we go
21:25:27 <bos_> @where+ takusen http://darcs.haskell.org/takusen
21:25:27 <lambdabot> Done.
21:25:48 <fyx> > last (nubBy (((== 0).) . flip mod) [2..])
21:25:52 <lambdabot> Terminated
21:25:53 <fyx> what is the biggest prim number :D
21:25:55 <Cale> Flip mod squad.
21:26:04 <bos_> it's a shame there isn't a "nubbly" in the prelude.
21:26:13 <Cale> nubbly?
21:26:31 <Cale> > nubbly xs = xs == nub xs ?
21:26:32 <lambdabot>  Parse error
21:26:35 <zbrown> Anyone have a good epxlanation for what the Functional Graph Library does?
21:26:51 <Cale> zbrown: Represents and manipulates graphs.
21:26:53 <bos_> nubbly is just a good name begging to be used for, well, something.
21:27:07 <Cale> (in the combinatorial sense of the word 'graph')
21:27:07 <mauke> ah, the reindeer effect
21:27:18 <Cale> http://en.wikipedia.org/wiki/Graph_theory
21:27:18 <lambdabot> Title: Graph theory - Wikipedia, the free encyclopedia
21:27:22 <dolio> nubbly sounds dirty.
21:27:53 <ddarius> @wn nubbly
21:27:55 <lambdabot> *** "nubbly" wn "WordNet (r) 2.0"
21:27:55 <lambdabot> nubbly
21:27:55 <lambdabot>      adj : of textiles; having a rough surface; "a sweater knitted of
21:27:55 <lambdabot>            nubbly homespun yarns" [syn: {homespun(p)}, {nubby}, {slubbed},
21:27:55 <lambdabot>             {tweedy}]
21:28:11 <bos_> mauke: precisely.
21:28:36 <bos_> we could then say "the nubbly catamorphism".
21:28:46 <zbrown> Cale: oh hmmm, i need a library for doing x,y,z graphs, any suggestions or are sdl or opengl my best bets?
21:28:48 <bos_> which might get haskell mentioned on cute overload.
21:29:08 <bos_> zbrown: you want a scene graph library, then?
21:29:13 <Cale> zbrown: I think someone's created a chart library using Cairo
21:29:31 <Cale> which might be something like what you need, though I'm not certain it handles 3d graphs
21:29:43 <zbrown> Cale: ah hmm
21:29:52 <Cale> http://dockerz.net/twd/HaskellCharts -- ah, yeah, it's 2D
21:29:53 <lambdabot> Title: HaskellCharts - twd
21:30:08 <zbrown> hmmm
21:30:10 <Cale> The output is beautiful though ;)
21:30:15 <zbrown> ya it is nice output
21:30:27 <sm> kc5tja: did you see that last paste ? it's almost generic, but not sure how to nicely abstract the  option constructor
21:30:38 <sm> anyway.. good progress
21:31:09 <zbrown> Cale: im looking more for a way to create graphs like this one
21:31:11 <zbrown> http://www.elroyjetson.org/wp-content/uploads/2006/02/3dgraph.jpg
21:31:38 <bos_> ah, it's a chart you want, not a graph in the usual haskell sense!
21:31:52 <zbrown> bos_: err so it would seem
21:32:00 <fyx> why not just output the data..
21:32:04 <fyx> then anyone can graph it
21:32:16 <Cale> yeah, I'm not sure if that's been done, but I'd imagine that if you know the relevant perspective formulas, the 2D library would be a good starting off point. Alternately, using gnuplot or some such is possible.
21:33:10 <zbrown> fyx: We're talking graphing something like 10000-100000 elements at a time, most people working on this project aren't programmers, they just want to see the data in a pciture form :)
21:33:29 <Cale> http://darcs.haskell.org/htam/ -- here's a simple gnuplot binding.
21:33:31 <lambdabot> Title: Index of /htam
21:33:43 <fyx> zbrown: have you seen the R project?
21:33:53 <zbrown> fyx: I work on a research project thats modeling vector-borne disease, my area at hte moment is malaria, so a bank of data means nothing to them unless i do something with it
21:33:54 <Cale> er, looks like lots of other stuff too
21:34:00 <Cale> src/GNUPlot.hs
21:34:00 <zbrown> fyx: ya that was my original thought
21:34:01 <fyx> wow
21:34:35 <zbrown> Or rather the data isn't representative of the trends etc. and they don't have the know-how necessarily to do it, or the ones that do are just too lazy ;)
21:34:37 <bos_> zbrown: i would recommend looking at a library in a different language, then.
21:34:50 <bos_> python has some awesome charting libraries.
21:34:52 <Cale> It's by Henning Thielemann though, so you can expect some zany conventions :)
21:35:09 <zbrown> bos_: ok, just wanted to make sure I wasn't skipping over something in Haskell
21:35:22 <zbrown> I'll probably have to work in R to get this stuff to be decently displayed
21:35:44 <Cale> I'd probably go with generating numerical output which another program could turn into proper plots, or if I had more time, I'd extend the 2D charting library :)
21:36:04 <zbrown> Cale: ya, well I've got 4-8 years ;)
21:36:25 <bos_> zbrown: matplotlib and pyx are both very good python libraries.
21:36:25 <zbrown> though extending the 2d charting library would be a bit over me at this point i suspect
21:36:44 <zbrown> bos_: hmmm python, i like, worked in it a lot, ill put those down on my list
21:37:20 <bos_> they can both produce gorgeous graphics from lots of data.
21:37:23 <Cale> Can't be all that bad, I don't think. The trickiest bit would probably getting a nice looking environment map so that you can tell which direction the faces are pointing in. :)
21:37:38 <bos_> eigenfaces!
21:37:50 <zbrown> Cale: well its my lack of knowledge of haskell that would hinder me ;)
21:37:55 <kc5tja> sm: Sorry, I'm busy trying to find a BitTorrent client that *actually works*.
21:38:05 <kc5tja> (and which doesn't require bizarre dependencies)
21:38:25 <Cale> kc5tja: I use Azureus, it's not bad, but eats quite a chunk of memory.
21:38:25 <dolio> What qualifies as bizarre?
21:38:34 <bos_> zbrown: matplotlib is a good tool if you're working with people who are familiar with matlab.
21:38:45 <sm> np
21:38:55 <Cale> There's also a fairly decent bittorrent client in gnome, as long as you're not a control freak :)
21:39:21 <encryptio> i have a problem finding a bittorrent client that can handle 250+ torrents
21:39:26 * sm tries passing in the option constructor, but can't use it in pattern matching
21:39:36 <zbrown> bos_: hmm most of them are
21:39:44 <Cale> I tend not to remain on more than a handful of torrents at any one time.
21:40:00 <Cale> Usually, I restrict it to 1, unless there's things I absolutely need to seed.
21:40:12 <encryptio> i tend not to remain on more than a handful of *active* torrents at any one time
21:40:25 <kc5tja> dolio: A large number of clients I've found on Freshmeat rely on libraries that I haven't ever heard the names of.
21:40:29 <encryptio> unfortunately that means i need to have over 200 in the list, ready to go
21:40:30 <hpaste>  sm pasted "file arg processing - no good" at http://hpaste.org/941
21:40:36 <bos_> zbrown: http://matplotlib.sourceforge.net/screenshots.html
21:40:37 <lambdabot> Title: Matplotlib / pylab - matlab style python plotting (plots, graphs, charts)
21:40:37 <kc5tja> It's not that I wouldn't be happy to install them, but being lazy, I'd rather not to.  :)
21:40:39 <Cale> Oh, if it goes inactive, I'll just kill it :)
21:41:01 <zbrown> bos_: does x,y,z plotting right?
21:41:01 <Cale> Or if my ratio's okay, but there are way more seeds than peers.
21:41:14 <dolio> kc5tja: Well, I mean, I use and like ktorrent, but that has a dependency on KDE, which would probably be out of the question for someone not using it.
21:41:51 <Cale> kc5tja: apt-get?
21:41:56 <bos_> zbrown: for 3d, you'll need PyX instead
21:41:59 <encryptio> rtorrent is the best client i've found so far, but it doesn't run on my favorite OS. so i use bittornado.
21:42:02 <zbrown> bos_: ok
21:42:13 <bos_> zbrown: http://pyx.sourceforge.net/
21:42:14 <lambdabot> Title: PyX - Python graphics package
21:42:43 <zbrown> well ill have to keep PyX in mind, and also look into R
21:43:37 <Cale> R is kind of cool, I used it a bit in the mandatory stats class that I took.
21:45:26 <zbrown> at this point it seems one of the best options since the Applied Mathematician that i work for knows it, so could be useful
21:45:26 <kc5tja> dolio: I've got the qt libs on my box, but they're kind of old.  I'd rather not want to upgrade them.
21:45:30 <kc5tja> Cale: Slackware.
21:46:01 <Cale> kc5tja: This is why I don't run slackware :)
21:46:28 <Cale> Slackware is good when you don't care how much effort you spend administering your machine.
21:47:23 <Cale> Over time though, I've found myself less and less tolerant of configuring things by hand. I ran Debian for about 5 years, and recently switched to Ubuntu.
21:47:45 <kc5tja> Cale: I think my next box is going to be Gentoo.
21:47:48 <zbrown> Cale: hehe sounds like me
21:48:00 <zbrown> though I run mandriva
21:48:00 <Cale> Gentoo is all right if you don't mind waste heat.
21:48:17 <kc5tja> I have a laptop with a failing OS distribution on it (Mandriva -- iick!), I'm planning on updating that one first.
21:48:19 <zbrown> Gentoo is a hobby, not an OS. (tm) ;)
21:48:23 <kc5tja> Cale: My box is on 24/7 anyway.
21:48:27 <jcreigh> most of the time, Debian Just Works.
21:48:41 <Cale> Try Ubuntu, it's really quite nice to install.
21:48:52 <dibblego> 6.06.1 is far batter than 6.10
21:48:52 <Cale> In fact, it's generally easier to install than Windows.
21:48:54 <kc5tja> I use Ubuntu at work.  Not sure if I like it or not.
21:49:02 <dibblego> *better too
21:49:18 <Cale> dibblego: There's been a dist-upgrade to 6.10 since the initial release, and things are getting pretty solid now.
21:49:27 <dibblego> Cale, 6.10.1?
21:50:01 <Cale> The packages are labelled with -edgy2
21:50:22 <kc5tja> Ubuntu has the problem of, "If we don't have the package, you're $#(*&$ed!"
21:50:28 <dibblego> I just moved my mother-in-law over to ubuntu
21:50:35 <zbrown> kc5tja: how's that
21:50:35 <zbrown> ?
21:50:46 <bd_> kc5tja: you can always install stuff manually, or use an external repo, or roll a package yourself
21:50:46 <liyang> Ubuntu? Sorry, I'm not really into Pokemon.
21:50:47 <dibblego> I've even written up a "Weaning off Windows" document
21:50:57 <kc5tja> zbrown: A friend of mine has tried installing a few system-level packages on his Ubuntu box (a laptop), and he couldn't find the packages pre-made.
21:51:01 <glguy> liyang: xkcd.com ftw ;)
21:51:05 <Cale> kc5tja: not really -- there are alternate repositories you can add, and you can also still install things from tarballs if you really want to.
21:51:15 <dibblego> I got so sick of fixing everybody's screwed up windows installations
21:51:18 <zbrown> kc5tja: define system-level?
21:51:26 <kc5tja> So, he downloaded the sources, compiled, and ran into no end of problems trying to track down dependencies, even for packages which were supposedly already installed.
21:51:33 <kc5tja> zbrown: sysadmin-level tools.
21:51:34 <Cale> kc5tja: kernel-level?
21:51:35 <zbrown> When I think system-level I think glibc... so I'm not sure I follow.
21:51:43 <zbrown> oic
21:51:55 <zbrown> kc5tja: well then why not build from source?
21:51:57 <Cale> The worst I had to do is to compile a kernel module for Reiser 4.
21:52:05 <Cale> But that went reasonably smoothly.
21:52:07 <kc5tja> zbrown: He *DID*, and that caused the system to go all whacky.
21:52:18 <zbrown> heh odd
21:52:18 <bd_> kc5tja: ubuntu doesn't install development headers by default, to save space. Was that the issue?
21:52:29 * encryptio uses freebsd for his servers, mac os x + fink for his desktops. no serious issues.
21:52:34 <kc5tja> bd_: Partly, but that wouldn't case destabilization of the OS.
21:52:47 <kc5tja> He's running BSD on his laptop now, so it's no longer an issue.  :)
21:52:49 <bd_> kc5tja: ... destabilisation? Did you overwrite something?
21:52:52 <zbrown> encryptio: i'll be on that route soon enough, trading in the current lappy to the parents and buying a Macbook
21:52:59 <Cale> I don't see how installing a user-level program would destabilise the OS anyway.
21:53:00 <kc5tja> bd_: *I* didn't do anything.  I don't run Ubuntu.
21:53:12 <Cale> What did this tool do?
21:53:18 <kc5tja> But if installing an app from source did cause an overwrite of a file which, on any other system wouldn't cause an issue, that's a point against Ubuntu.
21:53:20 <encryptio> weird thing about fink though: the "ghc" package actually doesn't contain ghc(1) ... just ghci(1)
21:53:26 <Cale> kc5tja: no, it wouldn't
21:53:37 <Cale> kc5tja: because if you're smart, you'd install it in /usr/local
21:53:48 <kc5tja> Cale: That's where things are placed by ./configure by default.
21:53:52 <Cale> right
21:54:03 <kc5tja> ./configure && make && make install should never destabilize the system.
21:54:05 <Cale> So it shouldn't affect anything too seriously.
21:54:08 <kc5tja> But it did exactly that on his laptop.
21:54:11 <Cale> huh
21:54:13 <encryptio> well, it contains ghc(1) but it doesn't work until you install ghc-dev
21:54:23 <Cale> I've never run across that sort of problem.
21:54:45 <Cale> (and I've installed more than a few things from source)
21:55:04 <kc5tja> I may put Ubuntu on MY laptop (to distinguish it from my friend's :) ), since i don't do too much hardcore work with it.
21:55:12 <dibblego> same (as Cale)
21:55:25 <dibblego> kc5tja, I have a funny story about that
21:55:27 <glguy> linux, that's the BSD clone?
21:55:28 <Cale> Yeah, check it out. I was fairly impressed overall.
21:55:47 <Cale> 6.10 had a few issues in the beginning, but it's pretty good now.
21:55:52 <kc5tja> glguy: No; if you install KDE or Gnome, it's the WinXP clone.
21:56:05 <kc5tja> And if you don't, it's the Minix clone.
21:56:05 <glguy> ew
21:56:13 <Cale> I still wish that it had the old startup screen.
21:56:18 <kc5tja> Cale: Yeah, he was using 6.10
21:56:44 <Cale> The new one doesn't tell you what the heck is going on during system startup, which I find annoying.
21:56:56 <encryptio> linux's startup annoys me anyway
21:57:08 <ray> mac os is the bsd clone
21:57:14 <glguy> Cale: isn't the the general theme?
21:57:16 <dibblego> Cale, there's a way of changing that, but I forget what it is (I read it somewhere on a wiki I think)
21:57:22 * kc5tja wants AmigaOS + memory protection.  Is that too hard to ask for?
21:57:23 <ray> linux is the third-rate unix clone!
21:57:24 <encryptio> ray: a bsd derivative, rather
21:57:25 <Cale> Well, the old ubuntu startup was nice. It was just the right level of abstraction over actual events.
21:57:25 <glguy> Cale: Leave all this complicated behind the scene stuff to us?
21:57:33 <kc5tja> (yes, I used to work for Amiga.)
21:58:01 <Cale> glguy: Sort of -- except that I'd like to know what servers are started -- I don't need their exact messages, but a general idea of what's going on is nice.
21:58:17 <Cale> It's also good in the rare case that something goes wrong.
21:58:32 <glguy> Cale: oh, I agree on seeing what's going on
21:59:46 <Cale> I only restart my machine when some program puts my graphics hardware in a bad state or there's a power outage anyway, but still. :)
22:00:10 <glguy> avoiding the config wizards, startup screens, GUI tools is one of the reasons I don't like a lot of what I see in the modern distros
22:00:18 <glguy> I fully understand *why* they are going that direction
22:00:19 <Cale> We have enough power outages here that it's annoying :)
22:00:24 <glguy> I just don't like it myself
22:00:52 <Cale> I think there's potential for getting a good mix there. I actually rather like Gnome, surprisingly.
22:01:13 <Cale> Despite the fact that I was an enlightenment + terminal person for years.
22:01:23 <Adamant> GNOME is nice.
22:01:45 <Cale> Most of the defaults are exactly how I want things, which is good, because otherwise I'd be really frustrated :)
22:01:48 <glguy> when I need a desktop environment, I will pick gnome
22:01:59 <glguy> have in the past
22:02:10 <Adamant> I'd rather have Cocoa, but I can't afford it. :)
22:02:16 <kc5tja> YAY -- Azereus is working fine.  This is very cool.
22:02:24 * kc5tja can now download ISOs for several distros.
22:02:29 <Cale> Actually, Apple's desktop environment didn't impress me all that much.
22:02:38 <glguy> I like my Powerbook, but it just serves a different purpose
22:02:57 <Adamant> Cale, it did for me.
22:03:10 <glguy> any of the linux de's I've tried have felt more patched together than windows or os x
22:03:12 <Cale> There were things about it which I could never figure out -- like forcing a default file handler for all files of a given type, regardless of the program which created them.
22:03:20 <Adamant> UI wise though, GNOME is probably better than Windows.
22:03:21 <glguy> which always manages to eventually get under my skin
22:03:22 <Cale> Or how to get focus-follows-mouse.
22:03:29 <Cale> Oh, I'd agree with that.
22:03:54 <glguy> when I'm on a windows box, the gui *feels* like the bottom layer
22:03:58 <Adamant> which is amazing. there is a lot of stuff that still needs to be worked on for the total desktop experience, but it is pretty impressive.
22:04:11 <glguy> on a gnome installation, gnome feels like a layer on top of another
22:04:30 <Cale> Actually, I like that there's another layer underneath.
22:04:37 <kc5tja> Cale: First thing I install whenever I get a Windows box is TweakUI, so that I can enable focus-follows-mouse.  :)
22:04:42 <glguy> I'd like it if it was more seemlessly connected
22:05:00 <Adamant> hardcore Unix-style program tweakers tend to like KDE more though
22:05:00 <Cale> yeah, there's some stuff which gnome is doing which ought to be in the kernel actually.
22:05:06 <Cale> Like the filesystem stuff.
22:05:31 <Cale> (well, ideally, I'd like to see a microkernel approach)
22:05:31 <Adamant> Cale, I'd rather it be out of the kernel if it's written in C
22:05:39 * kc5tja thinks more filesystem stuff ought to reside in user-space, personally.  :)
22:05:44 * kc5tja is a fan of microkernels.
22:05:55 * glguy likes Haskell
22:05:56 <glguy> ;)
22:06:14 <Adamant> I wouldn't mind a ML or Haskell-level typing language implimentation in the kernel
22:06:14 <Cale> glguy: Well, maybe you can run that L4 kernel in Haskell.
22:06:32 <Adamant> but with C, I want as much out of the kernel as practical
22:06:48 <Cale> Indeed, that's a good point.
22:07:14 <Cale> Still, the fact that KDE and Gnome have different filesystem extensions not properly accessible from the shell is distressing.
22:07:20 <Adamant> Haskell addicts will be glad to know Haskell is making some inroads in security thinking
22:07:25 <kc5tja> or Haskell if it dynamically loads code at run-time.
22:07:48 <Adamant> I'm reading The Art of Software Security Assessment
22:08:01 <Adamant> which is basically the new bible for finding vulnerabilties
22:08:09 <Adamant> and the authors have a distinct Haskell influence
22:08:10 <Cale> I'd really like to see a truly expressive filesystem in which programs could expose their underlying functionality.
22:08:22 <Cale> (s/filesystem/system namespace/)
22:08:31 <Adamant> they explain a lot of things in Haskell terms, like ADT's
22:08:42 <Cale> cool :)
22:08:54 <Cale> Haskell is definitely the language for security right now :)
22:09:22 * kc5tja remembers Oberon, which ran entirely in privileged mode on whatever systems it was compiled natively for.  Oberon's type safety was very rock solid too.
22:09:58 <kc5tja> Haskell's is more flexible (vastly more polymorphic), but the type system ensured a remarkable degree of stability of even relatively untrusted code.
22:10:09 <Adamant> yeah. my newbie opinion is that I am not sure typing is the cure for all bugs, but typing and proper design is nice for stopping security bugs.
22:10:31 <kc5tja> Yeah, you could still crash Oberon by explicitly written code to do so.
22:10:50 <Adamant> oh yeah, you will never kill the fork bomb or equivalent.
22:10:51 <kc5tja> Ditto for Haskell I'm sure (unsafeBlahBlah IO functions, most likely)
22:10:54 <araujo> Adamant, i doubt anybody would claim is the cure for _all_ problems ; but i think it is for most of the common problems.
22:10:58 <Cale> Well, you can't get rid of the *really* stupid bugs -- the ones where the programmer is just doing the wrong thing altogether.
22:11:14 <Adamant> logic/design errors, yeah.
22:11:15 <kc5tja> Adamant: Actually, BSD does a remarkably good job at keeping forkbombs at bay.  :)
22:11:27 <Adamant> kc5tja, well there is resource limits, etc.
22:11:32 <Cale> But you can get rid of most of the stupid bugs and help the programmer design things so that they're used in the expected fashion.
22:11:35 <Adamant> I'm looking at is as a language issue
22:11:57 <Adamant> *at it
22:12:24 <mwc> Good morning, all.
22:13:38 <Cale> I'm tired of programming.reddit articles about the development process.
22:13:50 <araujo> hah
22:14:12 <Cale> I'm not interested in the development process. I'm interested in programming. :)
22:14:19 <araujo> :-)
22:15:33 <Randroid> OK, I know how to do things like system "ls" to execute a shell command. But I don't watch just IO ExitCode back. I want to grab the command's stdout and get the return bytes/string/whatever. Can anyone point me in the right direction?
22:15:35 <kc5tja> I would like to see more research into capability-secure OSes.
22:15:35 <kc5tja> I like Plan-9's "filesystem per process" approach, because you can restrict untrusted processes big-time.
22:15:35 <kc5tja> Almost eliminates the need for ACLs all-together.
22:15:35 <kc5tja> brb -- laundry
22:15:36 <Adamant> what work have Haskellers done on shared-nothing concurrency as opposed to the STM stuff?
22:15:39 <Adamant> STM seems to be getting pushed a lot, or just getting a lot of work now, but I am interested in something more like the Erlang approach.
22:15:42 <Randroid> *I don't want
22:16:06 <Cale> Randroid: there's a library called HSH which makes what you want easy
22:16:11 <Cale> @where hsh
22:16:11 <lambdabot> I know nothing about hsh.
22:16:16 <Cale> bah, let me find it
22:16:23 <Randroid> Thanks, Cale!
22:16:32 <Cale> http://software.complete.org/hsh
22:16:34 <lambdabot> Title: HSH
22:16:38 <Cale> @where+ hsh http://software.complete.org/hsh
22:16:38 <lambdabot> Done.
22:17:17 <bos_> Adamant: for shared-nothing concurrency, there's nothing.
22:17:18 <desp> _mtlzm1zi0_ControlziMonadziError_ZCDError_static_info
22:17:19 <desp> _mtlzm1zi0_ControlziMonadziError_zdf16_closure
22:17:22 <Cale> It's got some pretty impressive polymorphism magic.
22:17:25 <Randroid> Cale, I can't thank you enough.
22:17:43 * Randroid is off to shove HSH into his brain.
22:17:45 <dolio> You can do Erlang-alike stuff with Chan and TChan, no?
22:17:59 <dolio> Although the typing makes it more sticky.
22:18:02 <desp> these are some pretty mangled up names
22:18:06 <Lemmih> desp: -package mtl   or   --make.
22:18:09 <Cale> So that if you ask for a string, you'll get stdout, and if you ask for a ProcessStatus, you'll get exit information
22:18:12 <bos_> Adamant: more precisely, there's local message passing available, but not remote.
22:18:14 <desp> Lemmih: thanks
22:18:18 <Adamant> ah.
22:18:29 <Adamant> well, local is a good start.
22:18:35 <Cale> http://software.complete.org/hsh/static/doc/HSH-Command.html -- see the comment under "class RunResult a where" for more info.
22:18:36 <bos_> i'm working on a remote messaging library at the moment.
22:19:15 <bos_> there have been a number of attempts to do distributed programming in haskell, but none of them ever went anywhere.
22:19:22 <dolio> Oh, yeah. I suppose Haskell isn't particularly close to having seamless distributed systems.
22:19:36 <bos_> seamless distributed systems are a terrible idea, anyway.
22:20:10 <mwc> bos_: dunno, having thread-level migration capability so you can move off a dying server is pretty damn useful for 100% uptime software
22:20:15 <bos_> wanting a seamless distributed system is like wanting a brick house in san francisco. you *know* there's going to be a big quake, and you *know* it's going to collapse.
22:21:14 <bos_> mwc: but that's not seamless at all.
22:22:03 <glguy> mwc: seems like it'd be better to use something like VMWare and just move the virtual machine to new hardware
22:22:13 <glguy> mwc: rather than having to rewrite that functionality into every application
22:22:31 <mwc> glguy: well, ideally it's written into the functionality of the runtime system
22:22:50 <sjanssen> s/every application/every runtime system
22:23:23 <glguy> sjanssen++
22:23:46 <mwc> well isn't that the point of something like Erlang's RTS?
22:24:02 <bos_> but erlang's RTS migrates stuff around explicitly.
22:24:09 <mwc> Ah
22:24:16 <bos_> and everyone builds in the full knowledge that individual threads had better have very little state.
22:24:36 <mwc> I was thinking of a system that would cluster highly communicative threads together on given cluster nodes
22:24:52 <bos_> for example, mnesia does no recovery of its own if an instance needs to be migrated and reconstituted. it says, "here, this is your problem".
22:32:13 <glguy> in Ruby, do operators take precedence to function application? puts gets.to_i+gets.to_i
22:34:32 <dolio> irb(main):002:0> puts "1".to_i + "2".to_i # => 3
22:34:47 <kc5tja> Heheheh, in J that'd be equal to puts(gets.(to_i+(gets.to_i)))  :)
22:35:16 <glguy> in J, reading from the stdin is a foreign function, no?
22:35:38 <dons> > read "1" + read "2"
22:35:40 <lambdabot>  3
22:36:02 <narain> ?index (<$>)
22:36:03 <lambdabot> bzzt
22:36:03 <glguy> 1!:1 1
22:36:20 <narain> ?hoogle (<$>)
22:36:21 <lambdabot> Did you mean: (<$>)
22:36:21 <lambdabot> Prelude.undefined :: a
22:36:21 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
22:36:40 <glguy> Â1!:1<1
22:36:52 <glguy> J for, read a line from stdin :)
22:38:02 <narain> ah, the docs mean ($) where they say (<$>) in Data.Traversable
22:38:33 <narain> no, perhaps they don't
22:38:44 <glguy> (0".1!:1<1)+0".(1!:1<1)
22:38:51 <glguy> J for read two numbers and add  them
22:39:01 <Cale> <$> is a synonym for fmap
22:39:05 <Cale> yes, another one
22:39:27 <Cale> See Control.Applicative
22:39:29 <kc5tja> glguy: What is the ". verb?
22:39:40 <narain> Cale: yes, i found it there
22:39:42 <glguy> Do - Numbers
22:39:48 <narain> Cale: couldn't find it through hoogle though
22:39:55 <kc5tja> Ahh.
22:39:58 <glguy> 0".'3'   returns the number 3
22:40:04 <glguy> 0".'hi'    returns 0
22:40:06 <Cale> Hoogle isn't perfectly up to date
22:40:11 <kc5tja> That's a bit of a security hole, no?  :)
22:40:13 <Cale> and contains some errors, iirc.
22:40:30 <glguy> kc5tja: no?
22:40:31 <narain> Cale: ok
22:40:46 <glguy> x".y converts character array y into numbers.
22:41:24 <kc5tja> Oh, so it won't directly execute the code as a J expression then.
22:41:39 <glguy> ".y executes the sentence y .
22:41:45 <glguy> not as a monad
22:41:54 <glguy> err
22:41:56 <glguy> not as a dyad
22:42:00 <glguy> asa monad it would
22:42:06 <kc5tja> Gotcha.
22:47:25 <saddev> When I first started studying Ruby, I learnt the essentials within 4 days. On the Friday of that week, I was already writing my own library that simplified the access to a database. Think of it as something similar to an ORM. Now I'm trying to learn Haskell... I spent 2 weeks studying it and I feel that I still don't know how to parse a file (for example). This makes me very sad, because I get the potentiality of
22:47:25 <saddev> the language and I'd love to use it :(
22:47:46 <glguy> ?all-dicts potentiality
22:47:47 <lambdabot> *** "Potentiality" gcide "The Collaborative International Dictionary of English v.0.48"
22:47:48 <lambdabot> Potentiality \Po*ten`ti*al"i*ty\, n.
22:47:48 <lambdabot>    The quality or state of being potential; possibility, not
22:47:48 <lambdabot>    actuality; inherent capability or disposition, not actually
22:47:48 <lambdabot>    exhibited.
22:47:49 <lambdabot> [31 @more lines]
22:48:25 <mwc> saddev: it's a different way of thinking that you need to be kind of zen about
22:48:53 * glguy doesn't know if mwc in particular knows anything about zen, but there sure seem to be a lot that seem to think tha they do ;)
22:49:05 <saddev> mwc: but I get the feeling it will take me months before I'd be able to do anything useful
22:49:30 <mwc> glguy: actually, I'm more of a taoist
22:49:32 <encryptio> it took me three months to fully understand a "Hello, <name>!" program.
22:50:08 <saddev> the lack of good documentation doesn't help either. I mean, of course there are many tutorials, but the actual libraries are rarely well documented.
22:50:35 <glguy> Ruby strikes me as a great one-off language
22:51:07 <mwc> saddev: the docs are pretty good. there are a few places where they aren't yet written (STM for example0
22:51:34 <mwc> for finding the bits in the lib you need, hoogling for the type is helpful.
22:51:41 <saddev> mwc: even just prelude... I don't see examples in the documentation. I see inferred type declarations and that's it
22:51:48 <mwc> @hoogle (a -> Bool) -> [a] -> [a]
22:51:49 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
22:51:49 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
22:51:49 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
22:51:52 <mwc> for instance.
22:52:28 <saddev> is there a way to get productive in Haskell in a resonable amount of time?
22:52:29 <bos_> the docs really are only so-so. they're often fine if you already know what you're doing, but little more.
22:52:41 <glguy> encryptio: and did you end up at: putStrLn . ("Hello, " ++) =<< getLine -- ? ;)
22:52:48 <bos_> saddev: spend less time reading stuff, more time writing code.
22:53:07 <kc5tja> saddev: Define "reasonable?"
22:53:07 <mwc> saddev: jump in with both feet. I did a computational physics course in Haskell a year or so ago.
22:53:15 <bos_> i.e. try to solve a problem of some kind, then try to find docs that tell you how to do that. don't just dive in with nothing in mind.
22:53:29 <saddev> bos_: that was my approach a few years ago with Ruby, but it doesn't seem to work with Haskell
22:53:37 <saddev> kc5tja: 3 weeks.
22:53:44 <kc5tja> I've been coding actively for only 3 days total, and I'm very nearly finished translating my unit testing framework from Python to Haskell.
22:53:47 <bos_> saddev: worked for me, i must say.
22:54:03 <kc5tja> I'd say 2.5 days were spent exploring the language itself and asking for help.  :)
22:54:09 <glguy> saddev: what did you know befor ruby?
22:54:11 <saddev> kc5tja: you must be smarter than I am
22:54:35 <saddev> glguy: C, C#, Pascal, Ada, C++
22:54:59 <kc5tja> Some think I'm a genius because I work for Google.  Those who sit in #Haskell know otherwise.  :-)
22:55:03 <glguy> saddev: that would explain why it wasn't much of a leap from that to Ruby
22:55:35 <saddev> kc5tja: what tutorial did you study?
22:56:07 <saddev> glguy: true, but I know Scheme already, which should help somewhat.
22:56:13 <kc5tja> saddev: Hah -- ALL of them that I could find, including days worth of hackling folks here.
22:56:40 <mwc> I went through Yaht, and read that All About Monads tutorial about 15 times until it made sense
22:56:42 <glguy> hackling is a form of heckling best practiced by programmers
22:57:08 <mwc> Get off the stage, you monomorphic hack!
22:57:13 <kc5tja> glguy: You say potato, I say potato...  ;)
22:57:24 <saddev> ?all-dicts heckling
22:57:26 <lambdabot> *** "heckling" gcide "The Collaborative International Dictionary of English v.0.48"
22:57:26 <lambdabot> heckling \heckling\ n. [vb. n. from {heckle}[2].]
22:57:26 <lambdabot>    Shouting in order to interrupt a speech with which the
22:57:26 <lambdabot>    shouter disagrees.
22:57:26 <lambdabot>  
22:57:28 <lambdabot> [7 @more lines]
22:57:49 <kc5tja> ?all-dicts hackling
22:57:51 <lambdabot> *** "Hackling" gcide "The Collaborative International Dictionary of English v.0.48"
22:57:51 <lambdabot> Hackle \Hac"kle\, v. t. [imp. & p. p. {Hackled} (h[a^]k"k'ld);
22:57:51 <lambdabot>    p. pr. & vb. n. {Hackling} (h[a^]k"kl[i^]ng).]
22:57:51 <lambdabot>    1. To separate, as the coarse part of flax or hemp from the
22:57:51 <lambdabot>       fine, by drawing it through the teeth of a hackle or
22:57:53 <lambdabot> [9 @more lines]
22:58:15 <kc5tja> Dude, J code is easier to read than that dictionary annotation.  :)
22:59:06 <glguy> J is a write-only language :)
22:59:09 <kc5tja> OK, I need to get back to figuring out this ByteString stuff.
22:59:19 <kc5tja> glguy: If you code it in write-only style, sure.
22:59:28 <kc5tja> But like Forth, you can make readable code.
22:59:43 <glguy> kc5tja: no thanks to the language :)
23:00:01 * glguy hasn't written anything of substance in J, but enjoys playing with it
23:00:04 <kc5tja> As a Forth coder, I rather instinctively took to writing readable code.  :)
23:00:24 <kc5tja> Yeah; I downloaded it to read through the Calculus book by Iverson.
23:01:40 <Cale> If you want a really good Calculus text, you have to get Spivak's "Calculus"
23:02:12 <Cale> Apostol also seems good, but it's not something that I'd also recommend to beginners in mathematics.
23:02:27 <encryptio> there was a nice set of pdfs that taught calculus by infentesimals... i forget anything else about it
23:02:39 <glguy> Cale: do you have any recommendations on an introduction to formal methods?
23:02:49 <Cale> How formal? :)
23:03:23 <glguy> How many choices do I have :)
23:03:30 <kc5tja> Cale: The nice thing about Iverson's book is that limits are never used to arrive at derivatives.  It's all done through polynomials.
23:03:53 <kc5tja> So it's nice and easy; this extends even to his treatment of differintegrals.
23:04:06 <Cale> Spivak's book is good if you're new to mathematics and want to learn how to prove things, but it doesn't go right down to the syntax/formal logic level.
23:04:09 <narain> ?src traverse
23:04:10 <lambdabot> Source not found. Wrong!  You cheating scum!
23:04:18 <narain> ?source Data.Traversable.traverse
23:04:18 <lambdabot> Data.Traversable.traverse not available
23:04:34 <Cale> If you're talking about mathematical logic, I know where to get some PDFs.
23:04:44 <Cale> Like, model theory and such.
23:04:51 <glguy> Cale: I'd appreciate links, I don't know enough yet to know what to ask for
23:04:53 * kc5tja does want to find a good book on discrete math some day.  I downloaded an open-sourced book on linear algebra.  But it's 448 pages long.  Eesh!
23:05:10 <Cale> http://www.cs.man.ac.uk/~hsimmons/BOOKS/books.html
23:05:11 <lambdabot> Title: Books
23:05:50 <narain> kc5tja: discrete math /= linear algebra
23:05:57 <Cale> Model theory in particular might be what you're looking for -- it depends on whether you want to understand the formalities in usage, or whether you want to study the formalities themselves.
23:06:17 <Cale> Model theory is about applying mathematics to the syntax of mathematics.
23:06:36 <narain> are there any articles about Data.Traversable?
23:06:55 <glguy> Cale: At this point I want to find out what there is to know, I'm interested in looking at logic more formally, being able to effectively prove things
23:06:57 <Cale> kc5tja: Linear algebra is not really discrete mathematics. :)
23:07:04 <Cale> glguy: oh, okay
23:07:34 <Cale> glguy: I'd get Spivak, even though you won't see the formalities at the syntax level, they're there, and there's lots of stuff regarding proof.
23:07:34 <glguy> I've had at least one into course to "logic"
23:07:45 <glguy> Cale: I'll give that a look
23:07:54 <Cale> You also get to see lots and lots of examples of real proofs. :)
23:08:06 <Cale> The exercises range from easy to fairly brutal.
23:08:21 <glguy> Cale: is there an order to the pdfs on this site?
23:08:25 <Cale> no
23:08:29 <glguy> ok
23:08:52 <Cale> also, given what you've told me, I'm not sure it's really appropriate, but perhaps check it out anyway :)
23:08:57 <saddev> you understand a thing or two about a community when the getting started section of the wiki has reference to research papers :-P
23:09:35 <Cale> http://www.math-atlas.org/ -- if you'd like an overview of mathematics as a whole
23:09:35 <kc5tja> Cale, no, but it's used *everywhere*, so it's good to know/have it.  :)
23:09:37 <lambdabot> Title: Mathematical Atlas: A gateway to Mathematics
23:09:51 <narain> anyone: what's Data.Traversable useful for?
23:09:59 <glguy> Cale: what was (a/b)/(c/d)=(a/c)/(b/d)
23:10:06 <Cale> narain: Monadically traversing datastructures.
23:10:20 <Cale> narain: It's a generalisation of mapM/sequence.
23:10:26 <glguy> Cale: we didn't touch on the / operator
23:10:44 <narain> Cale: over arbitrary data structures? looks useful
23:10:53 <Cale> glguy: that's division :)
23:10:59 <Cale> glguy: it was an analogy
23:11:10 <glguy> oh :(
23:11:21 <glguy> but I've seen the / used as a logic operator
23:11:34 <Cale> Well, it's like proportion.
23:11:52 <Cale> "a is to b as c is to d" is rather like a/b = c/d
23:12:41 <narain> Cale: are there any articles or examples on the use of Traversable or Applicative?
23:12:55 <Cale> there are articles on applicative
23:12:55 <narain> they look useful but i can't quite grasp them just by reading the defs
23:13:15 <Cale> I think people are sort of expected to understand Traversable by generalisation of the stuff in Control.Monad
23:14:03 <Cale> The idea behind applicative is that it's a generalisation/weakening of the idea of a monad.
23:14:16 <Cale> Which happens to capture some useful functors.
23:14:20 <glguy> Cale: of the Rules of Natural Deduction, the exists introduction rule states from a proof of  beta (x_i / t)  we can conclude exists x_i beta
23:14:28 <Cale> glguy: ah, that /
23:14:31 <Cale> that's replacement
23:14:46 <glguy> ok, x_i / t means all occourances of x_i
23:14:52 <glguy> are to be substitutded by t
23:14:58 <glguy> substituted :)
23:15:15 <Cale> That's the opposite of what I'd expect, but it's probably context dependent.
23:16:01 <glguy> I'm presently working through a book called "Formal Methods in Computing" Edited by Ferenczi, Pataricza, Ronyai
23:16:12 <glguy> so, I was in the mind set to view / that way :)
23:16:58 <Cale> narain: The idea for Traversable is perhaps best captured by sequence, even though that's not completely general (sequenceA/traverse work not just with monads but applicative functors)
23:17:20 <Cale> narain: sequence :: (Monad m, Traversable t) => t (m a) -> m (t a)
23:17:54 <Cale> that is, it turns a traversable structure of computations, into a computation computing that kind of structure of results.
23:18:07 <Cale> So if t was some kind of Tree datatype, for instance
23:18:35 <Cale> it would iterate somehow over the nodes of the tree, executing the actions it found, and constructing a tree of the results at each node.
23:18:52 <narain> Cale: thanks, that's very helpful
23:18:57 <mwc> Hey Cale what does a math major with a nocturnal lifestyle do for bank?
23:19:12 <Cale> Nothing yet :/
23:19:36 <Cale> I'm looking for jobs though, if you know of any opportunities in Ontario.
23:20:13 <mwc> hahaha, I was trying to make a list and all I had was caped crimefighter and 7-11 clerk, and both have way too much gunplay for me
23:20:22 <Cale> haha
23:20:38 <narain> ?t (<$>)
23:20:38 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
23:20:40 <Cale> One guy I know was a bouncer at a strip club.
23:20:45 <narain> ?ty (<$>)
23:20:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:20:52 <Cale> (and a CS/Pure math double major)
23:21:01 <mwc> Cale: hahaha. Roadhouse Lives!
23:21:39 <Cale> I really should go back to academia, but I'd wanted to pay down my student loans.
23:21:44 <Cale> and do some travelling
23:22:01 <Cale> but Phaze One of my plan hasn't made much headway.
23:22:51 <Cale> Getting a computer related job in Brantford seems next to impossible. I've started looking outside the city now, having decided that I have to move, but I'm not yet sure where.
23:22:54 <mwc> Well I've managed to get my H.B.Sc with only $1000 in debt
23:23:06 <Cale> That's *really* good.
23:23:10 <mwc> Yeah, only child.
23:23:43 <mwc> I'd love to get a summer position in Waterloo doing something interesting appl. math or comp wise, but don't hold out much hope
23:26:11 <bos_> Cale: what kind of work are you looking for?
23:26:32 <Cale> bos: application development would be nice
23:27:24 <Cale> Programming, basically.
23:27:24 <bos_> there are jobs raining from the sky in silicon valley at the moment.
23:27:42 <Cale> Too bad that's in the US.
23:28:17 <bos_> it's not too hard for canadians to get here. my boss is from ontario.
23:29:06 <bos_> i ended up here, and i'm neither american nor canadian.
23:31:01 <kc5tja> @pl testName n     = maybeHead $ matchRegex testRegEx $ B.unpack n
23:31:01 <lambdabot> testName = maybeHead . matchRegex testRegEx . (B .) . unpack
23:31:36 <kc5tja> umm...  I *DID* have that code, but the compiler still gives a type error.
23:31:56 <kc5tja> (with B.unpack un parenthesized, since B=Data.ByteString)
23:32:00 <bos_> monomorphism restriction?
23:32:20 <kc5tja> bos_: Sounds painful; no thanks.
23:32:40 <bos_> are you trying to get the compiler to infer the type of that function?
23:32:41 <Cale> kc5tja: yeah, @pl doesn't know about packaged
23:32:46 <Cale> packages
23:32:50 <kc5tja> @pl testName n     = maybeHead $ matchRegex testRegEx $ unpack n
23:32:50 <lambdabot> testName = maybeHead . matchRegex testRegEx . unpack
23:33:05 <kc5tja> bos_: No, I'm setting the type explicitly.
23:33:44 <bos_> still looks like the monomorphism restriction biting you.
23:36:16 <Korollary> Actually Patrick Swayze's character in Road House had a degree in philosophy iirc.
23:37:30 <bos_> kc5tja: what's biting you, i think, is the use of matchRegex in the middle of the expression.
23:38:01 <bos_> it's polymorphic in its return type, and perhaps maybeHead is polymorphic, too.
23:38:40 <bos_> in which case the typechecker throws up its hands in despair. this is a common feature of languages that use hindley-milner type inference.
23:40:24 <kc5tja> bos_: Yeah, I eventually figured it out.
23:40:34 <mwc> Korollary: yeah, it's still just as unlikely as compsci :)
23:40:40 <kc5tja> This mixing of regular strings and ByteStrings really sucks.  :(
23:40:44 <bos_> actually, i misspoke. the monomorphism restriction is specific to haskell.
23:41:02 <mwc> well, there's no need for the monomorphism restriction in HM type systems or Haskell
23:41:11 <mwc> it's just there to keep expressions from being evaluated twice
23:41:28 <kc5tja> Oops -- laundry again.  brb
23:41:30 <bos_> right.
23:41:41 <mwc> see if -fno-monomorphism-restriction removes the error
23:42:03 <bos_> but don't use -fno-monomorphism-restriction, even if it does remove the error :-)
23:42:08 * Cale is still having trouble coming to terms with the idea that there won't be another episode of Heroes until April 23.
23:42:17 <mwc> and if that's an invalid flag, check grep the ghc manual because there is such a flag, however it's hyphenated or abbreviated
23:42:42 <mwc> I'm dreading the season finale of Battlestar Galactica in two more episodes
23:42:55 <Korollary> What's wrong with you people
23:43:10 <mwc> bos_: yeah, it's evil but it does help you dianose if the MR is being evil
23:43:15 <Cale> Korollary: haha
23:43:40 <Cale> mwc: The next episode of SG-1 will be the last.
23:44:03 <mwc> Korollary: as of tonight, I have attention deficit hyperactivity disorder (impulsive-hyperactive subtype) and I think I have delayed sleep phase syndrome
23:44:07 <bos_> the monomorphism restriction is most likely to bite you if you're trying to be clever with point-free use of polymorphic functions.
23:44:32 <Korollary> mwc: as of "tonight"? Have you just been diagnosed by a professional?
23:44:43 <mwc> Not for the latter, yet.
23:44:50 <Cale> bos_: why? -fno-monomorphism-restriction is great!
23:44:55 <Cale> It should be the default, actually.
23:45:00 <Pastorn> ?where GADT
23:45:00 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
23:45:02 <Adamant> turn off your computer at 10PM and you'll get over it.
23:45:19 <Adamant> note that I don't follow my own advice.
23:45:21 <mwc> I'd be happy iff the monomorphism restriction went from error to warning
23:45:34 <Pastorn> is there a GADT module?
23:45:42 <Cale> Yeah, it ought to just be a warning anyway.
23:45:44 <Pastorn> or is this standard?
23:45:44 <Korollary> Pastorn: No, that's a language feature
23:45:48 <Pastorn> cool
23:45:50 <Korollary> GHC extension
23:45:57 <mwc> Adamant: I prefer to blame chemistry for my problems
23:46:21 <mwc> that and I keep the same schedule when camping for a week.
23:46:40 <Adamant> ah. in that case it might really be chemistry.
23:47:15 <Cale> Unless otherwise regulated, I end up staying awake as if the day had 32 hours.
23:47:42 <Cale> So my sleep schedule just sort of cycles around.
23:47:53 <dolio> I sort of fall into that as well.
23:48:03 <mwc> If I stay up for 48 hours, I can fall alseep at 10 and get up at 6. If I break that schedule by 10 minutes, then I go straight back to 0500-1300
23:48:25 <mwc> Clearly, 0500h is a stable attractor while 2200h is merely an unstable node.
23:48:34 <Korollary> I cant fall asleep at 10. Otherwise, I can get 7-8 hours of sleep regularly.
23:49:09 <Adamant> I would be straight if the medication I have to take didn't fool with sleep.
23:49:41 <Cale> I'm okay with taking 3 hour naps after having been up for 20 hours, if I'm trying to reset my clock.
23:50:35 <Cale> Going to university sort of broke various parts of my brain regarding sleep and stress though. :)
23:51:06 <mwc> Cale: story of my life: http://picayune.uclick.com/comics/ch/1995/ch950103.gif
23:51:25 <Cale> Melbourne for me :)
23:52:10 <Cale> (at least, at the moment)
23:52:23 <dolio> Anybody have some papers lying around on functional image processing with images represented as functions?
23:52:33 <dolio> I thought I had some, but the only one I can find is fairly detail-free.
23:54:19 <dons> dolio: look up Pan and its children
23:54:24 <dons> and the works of Conal Elliot
23:54:36 <dons> there's links from the haskell.org research wiki
23:56:07 <mwc> dolio: how would you do that? Surely not with rasters... vector images?
23:56:08 <dolio> Ah. Thanks.
23:56:12 <mwc> CSG?
23:56:30 <dolio> Well, the idea would be that an image is (Point -> Color)
23:57:08 <bos_> @where pancito
23:57:09 <lambdabot> http://www.acooke.org/jara/pancito/
23:57:21 <mwc> oh, so with rasters
23:57:25 <dolio> And as I recall, you can tweak things so that combining operations on the image is just function composition.
23:57:43 <dolio> Or something like that.
23:57:55 <mwc> Ah, I was thinking that you could do it with rasters by just composing maps over the array.
23:58:13 <mwc> same thing I supose since you probably back the (Point -> Color) function with an array
23:58:23 <dolio> Yeah, eventually.
23:58:40 <bos_> but how do you represent matrix operations then?
23:59:12 <bos_> it's preferable not to use arrays at all until the very end.
23:59:45 <bos_> otherwise anything that involves moving pixels around accumulates errors very quickly.
23:59:48 <encryptio> i actually did a functional image program in haskell, using exactly that - type Image = (Point -> Color)
