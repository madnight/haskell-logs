00:00:25 <nmessenger> the various functions require a random number source as a parameter, extract the next value from it, and return the value and the updated source.
00:00:36 <nmessenger> @type randomR
00:00:38 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
00:00:45 <nmessenger> @instances RandomGen
00:00:46 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
00:00:54 <nmessenger> @instances-importing System.Random RandomGen
00:00:55 <lambdabot> StdGen
00:01:23 <lokam>  let brid' = brilis' !! randomR (0::Int, length brilis' - 1)
00:01:25 <nmessenger> @hoogle StdGen
00:01:26 <lambdabot> System.Random.StdGen :: data StdGen
00:01:26 <lambdabot> Random.getStdGen :: IO StdGen
00:01:26 <lambdabot> Random.mkStdGen :: Int -> StdGen
00:01:32 <nmessenger> @hoogle+
00:01:32 <lambdabot> Random.newStdGen :: IO StdGen
00:01:32 <lambdabot> Random.setStdGen :: StdGen -> IO ()
00:02:11 <nmessenger> let (brid', gen1) = brilis' !! randomR (0::Int, length brilis' - 1) gen0
00:02:48 <nmessenger> then pass gen1 to the next place you need to get a random number
00:03:01 <Cale> fmap (brilis') (randomRIO (0,length brilis' - 1))
00:03:15 <Cale> If you're in IO anyway and don't care :)
00:03:24 <Cale> er
00:03:28 <Cale> fmap (brilis' !!) (randomRIO (0,length brilis' - 1))
00:03:28 <nmessenger> (brilis'!!)
00:03:32 <Cale> yes
00:03:39 <Cale> I meant to type that :)
00:03:45 <nmessenger> yes of course :D
00:04:01 <nmessenger> brain-to-keyboard disconnect.  common problem
00:04:07 <lokam> says gen0 not in scope
00:04:25 <lokam> hmm
00:04:31 <nmessenger> you need to get a gen0 from somewhere, probably passed in as a function parameter.
00:04:49 <nmessenger> if you want random numbers, they have to have a source.
00:05:18 <lokam> .ie(agreement)
00:05:37 <nmessenger> heh, iie is japanese for no :)
00:05:51 <encryptio> newbie monad transformer q: i have a (StateT a IO ()) and i want to run an IO operation and get the result. how do i do this?
00:06:01 <Cale> liftIO
00:06:07 <Cale> @type liftIO
00:06:09 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
00:06:14 <nmessenger> liftIO yourIOAction :: StateT a IO ()
00:06:58 <Cale> Or just lift, in this case, since IO is only one layer down.
00:07:46 <nmessenger> lokam: then when you call the function, you can generate a StdGen with mkStdGen and a specific seed, or you can get one in IO with getStdGen or newStdGen and pass it to your pure code.
00:08:23 <nmessenger> do {gen <- newStdGen; print (yourPureFunction blah blah gen)} -- for example
00:08:29 <encryptio> kewl. related question: how do i put a StateT transformation into an infinite loop?
00:08:46 <nmessenger> forever?
00:08:49 <nmessenger> @src forever
00:08:50 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
00:09:00 <nmessenger> forever x = x >> forever x
00:09:18 <encryptio> well, keeping state as it goes
00:09:28 <lokam> hmmm, well the function is [String] -> IO [String]
00:09:51 <nmessenger> lokam: if you're in IO already, you should probably use randomRIO
00:10:28 <lokam> it's giving me strange complaints with Cale's example maybe I'm not implementing it properly
00:10:32 <lokam> i'll paste one sec
00:12:15 <quicksilver> encryptio: foo = do { some ; stuff ; here ; foo }
00:12:29 <quicksilver> encryptio: that's an infinite loop for any monad, including your stateT
00:12:39 <lokam> http://hpaste.org/973
00:14:46 <nmessenger> heh, if you want to randomly pick a path, you might do { path <- randomRIO (0,2); case path of 0 -> ...; 1 -> ...; 2 -> ...
00:15:00 <encryptio> oh... brain fart.
00:16:01 <lokam> That's a paste of a simple turing complete intelligence, that will compile as soon as them random functions are figured out.
00:16:08 <nmessenger> @type randomRIO
00:16:10 <lambdabot> forall a. (Random a) => (a, a) -> IO a
00:16:14 <nmessenger> needs a range
00:16:27 <lokam> I gave it a range
00:16:43 <nmessenger> also produces an IO Thing, so you need to draw it out with '<-' before you can use it.
00:16:50 <lokam> o
00:16:56 <lokam> cool thanks :)
00:18:11 <nmessenger> I'm talking about the line that reads "if randomRIO > randomRIO".  It doesn't type.
00:19:26 <eulero> @seen dons
00:19:26 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1h 14m 46s ago.
00:19:37 <eulero> @seen Cale
00:19:37 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 12m 38s ago.
00:19:48 <dmwit> ?users
00:19:49 <lambdabot> Maximum users seen in #haskell: 336, currently: 292 (86.9%), active: 37 (12.7%)
00:22:44 <nmessenger> this typechecks: http://hpaste.org/973#a1
00:23:16 * lokam hugs nmessenger
00:23:18 <lokam> :D
00:23:22 <lokam> It compiled!
00:23:41 * nmessenger ghci lokam
00:24:12 <ivanm> lol
00:24:14 <eulero> nmessenger: we'll saw that coming :)
00:24:19 <nmessenger> that joke never gets old
00:24:33 <eulero> we all... not we'll :)
00:24:44 <mornfall> what?
00:24:49 <encryptio> wow. haskell rocks more every time i use it.
00:24:57 <ivanm> mornfall: eulero's previous message
00:25:22 <eulero> encryptio: it does
00:25:38 <nmessenger> encryptio: what incredible epiphanies have you recently had?
00:25:40 <mornfall> nono, someone's highlighted me last night, i was just wondering :-)
00:25:47 <encryptio> and ghc's messages get more cryptic every time i learn something
00:25:52 <mornfall> probably a mis-tabbing
00:26:05 <ivanm> mornfall: k, sorry
00:26:11 <mornfall> no worries
00:26:37 <encryptio> nmessenger: the wonderful StateT - i noticed i had coded state in manually and decided to rewrite into a StateT. it's half the size and much easier to read.
00:26:59 <nmessenger> encryptio: I did precisely the same thing a couple weeks ago!
00:27:31 <encryptio> also refactored some imperative-style code for socket reading into liftM lines (hGetContents sock)
00:27:39 <nmessenger> moved an interpreter I'd written in terms of SomeState -> IO SomeState to StateT SomeState IO ()
00:28:24 <nmessenger> tcidu cmen = fmap lines (readFile cmen) -- this is simpler, lokam
00:28:27 <encryptio> and writing stuff like showPeople = liftM (concat . (intersperse ", ") . sort . map fst) get -- makes me think i'm understanding point-free notation much better
00:28:33 <nmessenger> fmap = liftM
00:28:55 <nmessenger> liftM f get = gets f -- I believe
00:28:59 <nmessenger> @src gets
00:28:59 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
00:29:26 <encryptio> seems to be
00:30:16 <encryptio> yep, works
00:30:24 <dmwit> :t gets
00:30:26 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
00:38:54 <encryptio> @pl \x -> snd x /= y
00:38:54 <lambdabot> (y /=) . snd
00:44:04 <narain> hmm, why does the hpaste front page use javascript onclick actions rather than regular links?
00:44:22 <bdash> narain: ajax baby.
00:44:40 <nmessenger> the view links are ordinary, IIRC, onclick just extends them to the whole row.
00:45:33 <nmessenger> and ajax baby is not an acceptable explanation :P
00:45:40 <narain> ah yes, i see
00:45:46 <encryptio> are nested where clauses considered bad style?
00:45:47 <bdash> nmessenger: is "web 2.0" acceptable?
00:45:57 <nmessenger> *gag*
00:46:12 <narain> sorta annoying if you want to open in a new tab or see the url on mouseover and stuff
00:46:46 <nmessenger> encryptio: I don't see why.  Restricting scope tends to be a good thing.
00:47:20 <narain> my position is that javascript is great when used well, but bad when a plain html solution would work
00:47:28 <narain> declarative beats imperative :)
00:49:07 <nmessenger> javascript does allow you to do useful things, but yeah, doing them to the exclusion of non-javascript functionality I feel is bad form.
00:51:23 <narain> the hpaste page is good since the "view" links are plain links
00:52:11 <narain> i got a little peeved when the whole row pretended to be a link but wouldnt show the url on mouseover and ctrl+click wouldn't open in a new tab :)
00:52:18 <narain> i hadn't noticed the view links at the time
01:01:09 <rahikkala> @type (fix (\c x -> x >> c x) id)
01:01:11 <lambdabot> forall a b. a -> b
01:02:33 <nmessenger> fix (\c x -> x >> c x) = (let c = x >> c x in c)
01:03:00 <nmessenger> er, forgot a (\x -> ...)
01:03:19 <nmessenger> c = forever
01:04:02 <nmessenger> @type forever id
01:04:04 <lambdabot> Not in scope: `forever'
01:04:09 <nmessenger> darnit
01:05:24 <nmessenger> anyway, I'm pretty sure that function eats anything and produces _|_
01:08:52 <dolio> ?type repeatM
01:08:53 <lambdabot> Not in scope: `repeatM'
01:09:03 <dolio> ?type replicateM
01:09:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
01:09:10 <DRMacIver> Is there a nice way to create functions which don't recalculate each time? i.e. calculating this function is fairly time consuming but because of referential transparency only needs doing once, so having been calculated the value should be remembered.
01:09:47 <DRMacIver> It seems like the sort of thing having huge quantities of referential transparency would be great for, but I can't see an obvious way to implement it without some sort of fake remembering of state. :)
01:10:41 <narain> DRMacIver: might it be easier to do the memoization outside of the function?
01:11:06 <dolio> Depends what you want exactly. Is it something like 'f (g a) (g a)' where g is expensive and you only want it called once per invocation of f, or once for the whole program?
01:12:11 <dolio> If the former, do: 'f ga ga where ga = g a'
01:12:42 <DRMacIver> Well the example I had in mind was from the regexp discussion yesterday. Say I have some data type that corresponds to a regexp and want to compile these to e.g. finite state machines for matching. I don't really want to recompile every time I match against a specific regexp.
01:12:55 <DRMacIver> (I'm not implementing anything at the moment. I'm just curious.)
01:14:01 <quicksilver> DRMacIver: if it is, for example, a top-level definition then it will only be executed once
01:14:25 <quicksilver> DRMacIver: compiledver = myRECompiler re
01:14:41 <DRMacIver> Sure. But clearly it's sometimes useful to create and compile a regexp as part of a function definition. :)
01:15:01 <quicksilver> DRMacIver: top-level defintions without paramteres (known as CAFs) are evaluated on-demand but at most once
01:15:17 <DRMacIver> ok. That's nice to know, but it doesn't answer my question.
01:15:28 <DRMacIver> This shouldn't be a hard problem.
01:15:36 <quicksilver> DRMacIver: I think the same holds of 'let' definitions inside function definitions but I'm not 100% sure
01:15:36 <dmwit> State monad?
01:15:42 <dmwit> Or just pass it around manually?
01:15:42 <narain> sounds like you could use a monad to do it
01:16:29 <DRMacIver> Yeah, this could certainly be achieved by faking state. But then in order to use what really is a pure function you'd have to do everything inside the state monad.
01:16:45 <DRMacIver> Which is... unpleasant at best.
01:17:01 <quicksilver> DRMacIver: state monad is stilla pure function, btw :)
01:17:10 <DRMacIver> quicksilver: No, it's a monad. :)
01:17:20 <dolio> ?src State
01:17:20 <lambdabot> Source not found. The more you drive -- the dumber you get.
01:17:22 <quicksilver> DRMacIver: the state monad happens to be a function, though
01:17:31 <DRMacIver> Oh, ok.
01:17:37 <quicksilver> DRMacIver: State s a = s -> (s,a), roughly
01:17:46 <nmessenger> newtype State s a = State { runState :: s -> (a, s) }
01:17:47 <DRMacIver> Yeah, I figured it was something like that.
01:18:10 <DRMacIver> (As you can probably tell, I'm still rather weak on monads)
01:18:18 <quicksilver> but all monads are pure, in fact :)
01:18:28 <DRMacIver> I meant 'pure' as opposed to 'mixed' rather than 'impure'
01:18:39 <nmessenger> just that IO doesn't have a referentially transparent runIO
01:19:05 <dmwit> Probably the easiest thing is to compile in where statement, then pass the compiled version down to all the other functions that need it.
01:19:05 <narain> but yeah, any function that tried to use the memoized State-ified function would also have to be State-ful
01:19:06 <quicksilver> memoisation is often acheived by an array or map from params to value
01:19:24 <quicksilver> so you could have a map from String :-> CompiledRE
01:19:44 <quicksilver> because of lazy evaluation it's only evaluated on demand anyway, but once evaluated it's only done once
01:19:53 <rahikkala> I don't like operators that look suspiciously like smilies
01:20:12 <nmessenger> and your memoized function will be (memoMap !)
01:20:13 <quicksilver> that wasn't really an operator, it was just supposed to be the mathematical mapping symbol
01:20:24 <narain> |-->
01:20:43 * quicksilver nods that might have been better
01:21:05 <narain> well -> makes sense too
01:21:12 <DRMacIver> This is all a bit unsatisfactory.
01:21:35 <nmessenger> oh?
01:21:40 <quicksilver> narain: -> would have looked like a haskell function, which I was trying to avoid
01:22:14 <narain> but it is, isn't it? ...almost. well, ok
01:22:17 <DRMacIver> It's something that is entirely referentially transparent and is attempting to actually take advantage of this to do useful work, and it's failing because of Haskell's restrictions on mutable state.
01:22:49 <quicksilver> DRMacIver: this has got nothiing to with mutable state
01:22:53 * encryptio makes an :-) operator
01:22:54 <narain> C++ has the  mutable  keyword for just such a purpose :)
01:23:06 <quicksilver> DRMacIver: nor anything to with so-called 'haskell restrictions'
01:23:10 <DRMacIver> quicksilver: Of course it does. This would be utterly trivial if mutable state was available, so it's got everything to do with mutable state.
01:23:12 <nmessenger> encryptio: syntax error :(  parens are reserved.
01:23:21 <encryptio> =(
01:23:30 * encryptio makes an :-D operator instead
01:23:43 <quicksilver> DRMacIver: and mutable state is available in various ways in haskell and you can use any of them :)
01:23:44 <nmessenger> two names, (:-) and D
01:23:46 <dmwit> It will have to be an infix constructor...
01:23:49 <encryptio> aww.
01:23:50 <dolio> That probably won't work, either. D isn't a symbol.
01:24:13 <encryptio> :> ?
01:24:14 <quicksilver> however, the deeper problem is 'referentially transparent languages ought to be able to automatically memoise'
01:24:19 <nmessenger> that works!
01:24:22 <encryptio> yay!
01:24:36 <narain> data Kiss = Person :-* Person
01:24:36 <quicksilver> which is true
01:24:51 <quicksilver> but it's a hard rpoblem to right a compiler which can automatically work out which bits to memoise :)
01:24:56 <quicksilver> s/right/write/
01:25:01 <dmwit> Decorators!
01:25:08 <dolio> ghc might automatically rewrite things for some sharing.
01:25:10 <dmwit> Humans know which bits should be memoized... ;-)
01:25:11 <nmessenger> pragmas?
01:25:13 <DRMacIver> Well, automatically memoising would be nice, but isn't really the problem here. The problem is that it's so hard to *manually* memoise. :)
01:25:27 <quicksilver> DRMacIver: I don't think it is hard to manually memoise
01:25:27 <dolio> But there are examples of spots where memoizing causes worse performance.
01:25:39 <quicksilver> we've discussed half a dozen ways of doing it in the last 5 minutes :)
01:25:53 <dolio> It's not hard to manually memoize, either.
01:26:05 <dolio> http://haskell.org/haskellwiki/Haskell_Quiz/Happy_Numbers/Solution_Dolio
01:26:07 <lambdabot> Title: Haskell Quiz/Happy Numbers/Solution Dolio - HaskellWiki, http://tinyurl.com/yqwvr3
01:26:14 <DRMacIver> Yes. And they all involve some flavour of either breaking module encapsulation or wrapping everything in a state monad. :)
01:26:20 <dolio> The stuff at the bottom is based on stuff on the older wiki.
01:26:37 <nmessenger> f = ...; ftable range = map (id &&& f) range; fmemo = (ftable !)
01:26:38 <quicksilver> top level defeinitions, shared 'where' clauses, arrays, hashes, state monads...
01:27:04 <narain> DRMacIver: how about  f x = let memo = fmap f domain in lookup x memo  -- pseudocode
01:27:30 <narain> that should be  f'  (the pure function) in the  fmap
01:27:38 <DRMacIver> I guess the where clauses are relatively inoffensive.
01:27:48 <DRMacIver> Assuming they really do get only calculated once.
01:28:42 <dolio> That is how laziness works.
01:28:51 <dolio> As opposed to call by name.
01:29:13 <DRMacIver> Except when it doesn't.
01:29:39 <narain> hmm, i like the solution i just wrote... seems pretty general too, and you can use it as a regular function. are there any disadvantages?
01:30:03 <dolio> When would it not?
01:30:48 <dolio> Isn't the definition of laziness that a term is left unevaluated until it's needed, and then is memoized (in case it's used multiple times)?
01:32:12 <beelsebob> nope
01:32:15 <DRMacIver> No. It's only the first half.
01:32:50 <beelsebob> all it is is left-most-outer-most evaluation
01:32:52 <narain> ?src Array fmap
01:32:52 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
01:33:04 <nmessenger> beelsebob: plus sharing
01:33:16 <beelsebob> nmessenger: yes, indeed
01:33:20 <dolio> beelsebob: That's the definition of non-strict, is it not?
01:33:22 <dolio> Not lazy.
01:33:31 <beelsebob> one-and the same
01:33:35 <dolio> Or, a definition of non-strict.
01:33:41 <nmessenger> indeed, lazy = normal order + sharing
01:33:50 <dolio> No, call-by-name is also non-strict.
01:34:16 <dolio> And it differs from laziness by not memoizing/sharing.
01:34:17 <narain> > let fibs' 0 = 0; fibs' 1 = 1; fibs' n = fibs (n-1) + fibs (n-2); fibs n = let memo = fmap fibs' [0..] in memo !! n in fibs 10
01:34:19 <lambdabot>  55
01:34:26 <narain> > let fibs' 0 = 0; fibs' 1 = 1; fibs' n = fibs (n-1) + fibs (n-2); fibs n = let memo = fmap fibs' [0..] in memo !! n in fibs 100
01:34:27 <lambdabot>  354224848179261915075
01:34:30 <beelsebob> dolio: call-by-name differs not at all
01:34:30 <narain> > let fibs' 0 = 0; fibs' 1 = 1; fibs' n = fibs (n-1) + fibs (n-2); fibs n = let memo = fmap fibs' [0..] in memo !! n in fibs' 100
01:34:32 <lambdabot>  354224848179261915075
01:34:50 <beelsebob> dolio: there's no memorisation in Lazy evaluation
01:35:11 <dolio> Then haskell isn't lazy.
01:35:16 <beelsebob> yes it is
01:35:25 <beelsebob> there's no memorization in Haskell either
01:35:43 <beelsebob> you can easily convince yourself of that by using Hat to trace something
01:35:54 <beelsebob> and noting that the same expression is often evaluated many times
01:36:21 <dolio> 'let x = product [1..1000] in x + x' will only evaluate 'product [1..1000]' once.
01:36:32 <beelsebob> yes
01:36:34 <beelsebob> that's sharing
01:36:37 <beelsebob> not memorisation
01:36:56 <beelsebob> that *only* applies to constants
01:37:08 <beelsebob> and it only applies when they appear in the same evaluation step
01:38:06 <beelsebob> map (let x = product [1..1000] in (x *)) [1..5] -- I evaluate x 5 times
01:39:59 <dolio> Then what's call by need?
01:40:08 <beelsebob> same thing
01:40:19 <beelsebob> seriously - lots of names for the same thing
01:40:29 <beelsebob> sometimes with/without sharing
01:40:32 <dolio> But call by name and call by need are not the same thing.
01:40:42 <dolio> Call by name has no sharing.
01:41:19 <dolio> Which was the point originally in question, was it not?
01:41:24 <beelsebob> no
01:41:31 <beelsebob> you said memorization
01:41:37 <beelsebob> which is not the same as sharing
01:41:47 <beelsebob> there is no big hash table of results
01:41:50 <dolio> Whether 'f g g where g = h x -- expensive' only evaluates 'h x' once.
01:42:20 <beelsebob> f (h x) (h x) -- expensive, evaluates h x twice
01:42:22 <nmessenger> my understanding is nonStrict = { callByName=normalOrder, callByNeed=lazy=(normalOrder+sharing) }
01:42:30 <beelsebob> indeed
01:42:42 <nmessenger> plus other members in nonStrict that I don't know about
01:42:56 <beelsebob> probably including something fun that does memorization
01:42:59 <beelsebob> but none of these do
01:43:27 <beelsebob> I guess the question is when is a hash table lookup more efficient than evaluation
01:43:35 <sieni> memorization?
01:43:40 <nmessenger> nope
01:43:57 <beelsebob> sieni: with memorization, every time you evaluate something you make a note of it
01:44:18 <nmessenger> @foldoc memoization
01:44:18 <beelsebob> so in evaluating g (h x) (h x) you would (possibly) evaluate h x, then note it down
01:44:19 <lambdabot> *** "memoization" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
01:44:19 <lambdabot> memoization
01:44:19 <lambdabot>  
01:44:19 <lambdabot>         {memo function}
01:44:19 <lambdabot>  
01:44:23 <DRMacIver> Memorization as the default is such a bad idea I can't imagine any language implementing it. :)
01:44:31 <beelsebob> when you then came back to evaluate h x again, you just look it up in a table
01:44:39 <beelsebob> this results in big dables
01:44:40 <nmessenger> @foldoc memo function
01:44:41 <beelsebob> tables*
01:44:42 <lambdabot> No match for "memo".
01:44:42 <lambdabot>  
01:44:42 <lambdabot> *** "function" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
01:44:42 <lambdabot> function
01:44:42 <lambdabot>  
01:44:44 <lambdabot> [27 @more lines]
01:44:44 <DRMacIver> Or at least permanent memorisation.
01:44:48 <nmessenger> bleh
01:47:43 <UUStudent> hello hello hello
01:47:50 <UUStudent> got a question got a question got a question
01:47:53 <UUStudent> :)
01:47:57 <UUStudent> anyone alive?
01:48:06 <dmwit> Nope!
01:48:06 <nmessenger> ask away ask away ask away
01:48:14 <dmwit> All dead in here. =)
01:48:20 <nmessenger> oh yeah
01:48:23 <UUStudent> well for this assignment we got this data definition:
01:48:25 <nmessenger> XP
01:48:28 <Syzygy-> don't ask to ask don't ask to ask don't ask to ask
01:48:39 <UUStudent> data Datum = Datum {jaar :: Int, maand :: Int, dag :: Int} deriving (Eq, Ord)
01:48:47 <UUStudent> im curious, what does the { and the } do?
01:48:56 <nmessenger> special record syntax
01:49:12 <dmwit> It's a bit like wrapping it in a struct in C.
01:49:21 <nmessenger> equivalent to data Datum = Datum Int Int Int, and defines three functions for getting each Int
01:49:31 <UUStudent> aha ok
01:49:43 <nmessenger> jaar (Datum x _ _) = x; maand (Datum _ x _) = x;  etc.
01:49:51 <UUStudent> so if i define something with the data type Datum
01:49:57 <UUStudent> i do it like: datum :: Datum
01:50:05 <UUStudent> datum = Datum 2007 04 05
01:50:13 <UUStudent> for example?
01:50:22 <__xs__> they are special too. Datum {jaar = 1, maand = 2, dag = 3}
01:50:26 <nmessenger> that'd work
01:50:44 <UUStudent> allright
01:50:56 <nmessenger> also Datum {jaar = 2007, maand = 04, daj = 05} is special syntax
01:51:05 <nmessenger> for the same thing
01:51:34 <UUStudent> ok
01:51:39 <nornagon> also if you have some d :: Datum, you can write d { jaar = 2008 } to get the same Datum but with the jaar set to 2008.
01:52:07 <UUStudent> so what if Datum was part of another data type? How do i define THAT data type with Datum in it? Still with data Datum = Datum {jaar :: Int, maand :: Int, dag :: Int} deriving (Eq, Ord) ?
01:52:08 <nmessenger> pattern-matching, too
01:52:31 <UUStudent> pattern matching, ok
01:52:34 <nmessenger> er, data OtherType = Cons1 Datum?
01:52:44 <quicksilver> in g (h x) (h x), lazy evaluation certainly doesn't *guarantee* that h is evaluated only once. But it doesn't guarantee it's evaluated twice, either. Your evaluator is at liberty to perform some CSE if it wishes, and still call itself lazy.
01:53:06 <UUStudent> yea something like that
01:53:24 <UUStudent> data Saldoregel = Saldoregel Datum String Bedrag
01:53:42 <UUStudent> say i would like to have a variable called saldroreg
01:53:45 <UUStudent> i would do:
01:53:52 <UUStudent> saldoreg :: Saldoregel
01:53:52 <nmessenger> then Saldoregel (Datum 2007 04 05) "blah" (...) :: Saldoregel
01:53:59 <UUStudent> ok
01:54:00 <quicksilver> yes, that's right
01:54:05 <quicksilver> ah, that was nmessenger :)
01:54:18 * nmessenger pokes quicksilver
01:54:29 <UUStudent> so everytime i have a data type that is inside another data type i just put it between () and use the constructor function
01:54:53 <nmessenger> well, *every* type is pretty much a datatype, so yes :)
01:55:07 <UUStudent> ok
01:55:13 <quicksilver> UUStudent: it doesn't have to be constructors, of course
01:55:24 <nmessenger> ...when you get down to the constituent values (I should be careful not to fling unqualified statements)
01:55:35 <UUStudent> oh well the thing that makes it belong to a certain datatype :P
01:55:57 <quicksilver> UUStudent: Saldoregel (e) "blah" (blah)
01:55:59 <nmessenger> 0 is a nullary constructor in the Integer type :D
01:56:07 <quicksilver> UUStudent: 'e' can be *any expression* of type 'Datum'
01:56:17 <quicksilver> UUStudent: it might be a constructor, as in Datum 2007 04 05
01:56:21 <UUStudent> yea i figured that out myself yes
01:56:26 <quicksilver> UUStudent: but it might be a function which returns a Datum or...
01:56:34 <DRMacIver> nmessenger: It's not really implemented like that under the covers is it? :)
01:56:34 <UUStudent> it comes in handy if your defenitions grow longer and longer :P
01:56:48 <quicksilver> DRMacIver: In a sense, it is
01:56:51 <nmessenger> DRMacIver: who cares about implementation detail :P
01:56:55 <quicksilver> DRMacIver: and in another sense, it isn't :)
01:56:57 <UUStudent> but hey im gonna try this stuff out
01:56:59 <DRMacIver> ok. :)
01:56:59 <UUStudent> thanks a lot guys
01:57:00 <quicksilver> DRMacIver: and it depends on your compiler too :)
01:57:18 <UUStudent> you'll probably see me again someday, although it might be another uustudent ^^^
01:57:23 <UUStudent> cya. thanks for the help
01:57:47 <DRMacIver> (I do care about implementation details though. Not for anything mundane like performance reasons. They're just interesting. :) )
01:58:07 <quicksilver> DRMacIver: I do agree with the general vibe (and maybe this what you were getting at about memoization) 'I've been sold this referential transparency because the compiler can do all kinds of clever stuff, and yet... the compiler doesn't seem to'
01:58:30 <DRMacIver> To a certain extent.
01:59:12 <DRMacIver> I mean, I like referential transparency. Even in impure languages I try to keep the majority of my code referentially transparent. But if it's not possible to take advantage of this fact properly it's a bit irritating. :)
01:59:25 <quicksilver> A particular hobby horse of mine, though, is the way some people feel monads are somehow 'dirty', almost as if they were impure
01:59:33 <quicksilver> monads are a perfectly pure programming style
01:59:38 <DRMacIver> Sure. I know that.
01:59:44 <quicksilver> all they are is someone's rather clever idea of how you can hide plumbing
01:59:51 <quicksilver> and while they aren't perfect, they're damn handy
02:00:06 <DRMacIver> I'm starting to get that. :) I still don't entirely understand them though.
02:00:08 <DRMacIver> Anyway, got to go.
02:00:10 <DRMacIver> Bye
02:00:15 <nmessenger> later
02:00:17 <quicksilver> later
02:00:27 <nmessenger> alligator
02:01:18 <narain> for future reference, all Strings in haskell are cons-lists, right? if i want something implemented as a char*, that's ByteString?
02:01:40 <dcoutts__> narain: right
02:01:59 <narain> ok, thanks
02:01:59 <nmessenger> type String = [Char], yes, but I don't know much about the ByteString implementation
02:02:05 <quicksilver> narain: or you could use an unboxed array or a foreignptr
02:02:11 <quicksilver> narain: but bytestring is better for most purposes :)
02:02:22 <dcoutts__> narain: or the lazy ByteString which is a nice balance of char* and lists
02:02:43 <narain> lazy ByteString? the concept is intriguing
02:02:44 <dcoutts__> narain: ie nearly as fast but allowing constant space streaming operations
02:02:56 <narain> ?hoogle ByteString
02:02:56 <lambdabot> No matches found
02:03:09 <narain> bluh
02:03:15 <nmessenger> @wehre bytestring
02:03:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
02:03:24 <dcoutts__> the hoogle db hasn't been updated
02:03:29 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString-Lazy.html
02:03:32 <lambdabot> http://tinyurl.com/2eq6bt
02:04:37 <narain> wow, the implementation of that must be impressive
02:05:32 <quicksilver> the clever bit is the stream fusion they built in to it :)
02:07:11 <narain> ?src Data.ByteString.Lazy
02:07:11 <lambdabot> Source not found. Are you on drugs?
02:07:39 <dcoutts__> lambdabot: don't be so rude!
02:07:41 <nmessenger> @quote meanie
02:07:41 <lambdabot> LoganCapaldo says: <LoganCapaldo> @src fixIO <lambdabot> Source not found. Are you on drugs? <LoganCapaldo> No <LoganCapaldo> Meanie
02:07:45 <dcoutts__> @slap lambdabot
02:07:45 * lambdabot beats up lambdabot
02:08:01 <narain> man, it's like fight club
02:08:51 <nmessenger> * lambdabot beats up herself, * lambdabot starts cult, * lambdabot goes completely and destructively insane.
02:08:59 <narain> Data.ByteString.Lazy is an awesome idea
02:10:29 <narain> haskell hackers ++
02:10:41 <dcoutts__> narain: yeah, I did feel pretty pleased with myself when I thought of it :-)
02:10:52 <dcoutts__> narain: though it retrospect it's pretty obvious
02:10:55 <narain> dcoutts++
02:11:15 <nmessenger> @karma dcoutts
02:11:16 <lambdabot> dcoutts has a karma of 42
02:11:17 <nmessenger> @karma dcoutts_
02:11:18 <lambdabot> dcoutts_ has a karma of 1
02:11:20 <nmessenger> @karma dcoutts__
02:11:20 <lambdabot> dcoutts__ has a karma of 0
02:11:25 <nmessenger> 42!
02:11:37 <dcoutts__> woo!
02:11:40 <narain> congratulations!
02:12:04 <nmessenger> A winner is you!
02:12:09 <acangiano> nmessenger: 1405006117752879898543142606244511569936384000000000 :-P
02:13:23 <nmessenger> heheh
02:14:50 <acangiano> nmessenger: I'm glad his karma isn't higher, or I'd have used hpaste :)
02:16:39 <rahikkala> > show . show . show . show . show $ "hi"
02:16:41 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hi\\\\\\\\\\\...
02:16:54 <nornagon> > fix show "hi"
02:16:55 <lambdabot>  Couldn't match expected type `[Char] -> t'
02:16:57 <nornagon> doh.
02:16:59 <nornagon> :t fix
02:17:01 <nmessenger> > fix show
02:17:01 <lambdabot> forall a. (a -> a) -> a
02:17:02 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
02:17:20 <nornagon> @karma+ nmessenger
02:17:20 <lambdabot> nmessenger's karma raised to 7.
02:17:30 <nmessenger> > foldr (.) id (replicate 4 show) $ "hi"
02:17:31 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
02:18:49 <narain> > concatMap ((++"\"") . flip repeat '\\' . (2**)) [0..]
02:18:50 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[b1]'
02:19:15 <nmessenger> flip replicate?
02:19:21 <narain> > concatMap ((++"\"") . flip replicate '\\' . (2**)) [0..]
02:19:22 <lambdabot>   add an instance declaration for (Floating Int)
02:19:31 <narain> :(
02:19:40 <nmessenger> (2^)?
02:19:45 <narain> :t (^)
02:19:47 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
02:19:52 <narain> > concatMap ((++"\"") . flip replicate '\\' . (2^)) [0..]
02:19:53 <lambdabot>  "\\\"\\\\\"\\\\\\\\\"\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\...
02:20:36 <narain> bah, extra escaping
02:23:37 <narain> > let s1 = fix show; s2 = concatMap ((++"\"") . flip replicate '\\' . (subtract 1) (2^)) [0..] in concatMap (show . fromEnum) $ zipWith (==) s1 s2
02:23:46 <nmessenger> > concatMap ((++"\"") . flip replicate '\\') (scanl1 (+) [0..])]
02:23:47 <lambdabot>   add an instance declaration for (Num (a -> Int))
02:23:49 <lambdabot>  Parse error
02:24:07 <nmessenger> > concatMap ((++"\"") . flip replicate '\\') (scanl1 (+) [0..])
02:24:08 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\...
02:24:26 <narain> > let s1 = fix show; s2 = concatMap ((++"\"") . flip replicate '\\' . (subtract 1) (2^)) [0..] in s2
02:24:27 <lambdabot>   add an instance declaration for (Num (a -> Int))
02:24:34 <narain> > let s1 = fix show; s2 = concatMap ((++"\"") . flip replicate '\\' . (subtract 1) . (2^)) [0..] in s2
02:24:35 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
02:24:46 <narain> > let s1 = fix show; s2 = concatMap ((++"\"") . flip replicate '\\' . (subtract 1) . (2^)) [0..] in zipWith (==) s1 s2
02:24:47 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
02:24:52 <nmessenger> > let x = concatMap ((++"\"") . flip replicate '\\') (scanl1 (+) [0..]); y = fix show in take 1000 x == take 1000 y
02:24:54 <lambdabot>  False
02:24:54 <narain> aha
02:25:04 <narain> huh?
02:25:22 <nmessenger> > let x = concatMap ((++"\"") . flip replicate '\\') (scanl1 (+) [0..]); y = fix show in take 10 x == take 10 y
02:25:23 <lambdabot>  True
02:25:58 <narain> > let s1 = fix show; s2 = concatMap ((++"\"") . flip replicate '\\' . (subtract 1) . (2^)) [0..] in and $ take 1000 $ zipWith (==) s1 s2
02:25:59 <lambdabot>  True
02:26:55 <narain> > scanl1 (+) [0..] -- doesn't grow fast enough?
02:26:56 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
02:27:31 <nmessenger> > map ((subtract 1) . (2^)) [0..]
02:27:32 <lambdabot>  [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,2...
02:30:50 <nmessenger> > map length . unfoldr (\(x:y:ys) -> y:ys) . group $ fix show
02:30:50 <lambdabot>  Couldn't match expected type `Maybe (a, [t])'
02:31:15 <nmessenger> > map length . unfoldr (\(x:y:ys) -> Just (y,ys)) . group $ fix show
02:31:19 <lambdabot> Terminated
02:31:38 <narain> > group $ fix show
02:31:39 <lambdabot>  ["\"","\\","\"","\\\\\\","\"","\\\\\\\\\\\\\\","\"","\\\\\\\\\\\\\\\\\\\\\\\...
02:31:48 <narain> > map length . group $ fix show
02:31:52 <lambdabot> Terminated
02:32:02 <narain> > map length . take 100 . group $ fix show
02:32:06 <lambdabot> Terminated
02:32:09 <narain> > map length . take 10 . group $ fix show
02:32:10 <lambdabot>  [1,1,1,3,1,7,1,15,1,31]
02:32:13 <nmessenger> > map length . take 10 . filter (/="\"") . group $ fix show
02:32:15 <lambdabot>  [1,3,7,15,31,63,127,255,511,1023]
02:32:22 <quicksilver> that was odd
02:32:25 <narain> what was the unfoldr for?
02:32:33 <quicksilver> why wasn't that working lazily enough?
02:32:36 <nmessenger> dropping every other element
02:33:06 <narain> is that what it does?
02:33:18 <narain> ah yes, i see
02:34:59 <narain> is there no neater way to do that?
02:35:24 <nmessenger> quicksilver: I'd guess that if it doesn't terminate, @run doesn't print what's evaluated so far.
02:36:42 <quicksilver> nmessenger: you mean, if it reaches the timeout before it reaches the '80 char limit'
02:36:55 <nmessenger> I suppose.  Not really sure.
02:36:58 <ski> > let (x:xs) /\/ ys = x:(ys /\/ xs) in fix (\foo -> '\"' : repeat '\\' /\/ foo)
02:36:59 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
02:37:26 <nmessenger> heh (/\/) is an awesome operator. :)
02:37:59 <acangiano> hi everyone, I wrote a Haskell article in my blog and I'd love to receive feedback from you: http://antoniocangiano.com/articles/2007/03/13/haskell-eye-for-the-ruby-guy
02:38:01 <lambdabot> Title: Haskell Eye for the Ruby Guy, http://tinyurl.com/ys68gt
02:38:15 <ski> > let (x:xs) /\/ ys = x:(ys /\/ xs) in and . take 100 . uncurry (zipWith (==)) $ (fix (\foo -> '\"' : repeat '\\' /\/ foo),fix show)
02:38:16 <lambdabot>  True
02:38:30 <narain> awesome operator, and awesome way to use it too
02:38:36 <Pastorn> ski: ever thought about scan?
02:38:49 <Pastorn> and repeat or iterate
02:38:56 <narain> > let (x:xs) /\/ ys = x:(ys /\/ xs) in [1..10] /\/ [100..110]
02:38:57 <lambdabot>   Non-exhaustive patterns in function /\/
02:39:03 <ski> Pastorn : for generating the above ?
02:39:07 <narain> > let (x:xs) /\/ ys = x:(ys /\/ xs) in [1..] /\/ [100..]
02:39:08 <lambdabot>  [1,100,2,101,3,102,4,103,5,104,6,105,7,106,8,107,9,108,10,109,11,110,12,111,...
02:39:09 <Pastorn> yeoah
02:39:17 <beelsebob> @yow
02:39:18 <lambdabot> Yow!  I want my nose in lights!
02:39:20 <Pastorn> or maybe not...
02:40:51 <ski> > let (x:xs) /\/ ys = x:(ys /\/ xs) in map (chr . (ord 'a' +)) $ fix (\foo -> repeat 0 /\/ map (1+) foo)
02:40:53 <lambdabot>  "abacabadabacabaeabacabadabacabafabacabadabacabaeabacabadabacabagabacabadaba...
02:41:18 * ski smiles
02:42:05 <dons> re.
02:42:06 <narain> > let (x:xs) /\/ ys = x:(ys /\/ xs) in fix (\x -> x /\/ map not x)
02:42:08 <lambdabot>  Exception: <<loop>>
02:42:19 <narain> > let (x:xs) /\/ ys = x:(ys /\/ xs) in fix (\x -> 0:x /\/ map not x)
02:42:20 <lambdabot>   add an instance declaration for (Num Bool)
02:42:26 <narain> > let (x:xs) /\/ ys = x:(ys /\/ xs) in fix (\x -> False:x /\/ map not x)
02:42:27 <ski> > let (x:xs) /\/ ys = x:(ys /\/ xs) in fix (\foo -> repeat 0 /\/ map (1+) foo)  -- this is the number of '2' factors in natural numbers
02:42:27 <lambdabot>  [False,False,True,False,True,True,False,False,True,True,False,True,False,Fal...
02:42:28 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
02:43:07 <narain> > let (x:xs) /\/ ys = x:(ys /\/ xs) in fix (\x -> 0:x /\/ map (1-) x)
02:43:08 <lambdabot>  [0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0...
02:43:32 <ski> for these kind of things i've found 'force x0 ~(_:xs) = x0:xs' to be handy, at times
02:43:43 <quicksilver> :t iterate
02:43:45 <lambdabot> forall a. (a -> a) -> a -> [a]
02:44:27 <narain> > let (x:xs) /\/ ys = x:(ys /\/ xs); force x0 ~(_:xs) = x0:xs in fix (\x -> force 0 x /\/ map (1-) x)
02:44:28 <lambdabot>  [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1...
02:44:44 <ski> > let (x:xs) /\/ ys = x:(ys /\/ xs) in fix (\foo -> cycle [1,-1] /\/ foo)  -- iirc this is a part of a number-theoretic function
02:44:45 <lambdabot>  [1,1,-1,1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-...
02:45:35 <narain> that's definitely more interesting than what i got
02:45:51 <narain> > let (x:xs) /\/ ys = x:(ys /\/ xs) in fix (\foo -> cycle [a,b] /\/ foo)
02:45:57 <lambdabot>   Not in scope: `b'
02:45:58 <narain> > let (x:xs) /\/ ys = x:(ys /\/ xs) in fix (\foo -> cycle ['a','b'] /\/ foo)
02:45:59 <lambdabot>  "aabaabbaaabbabbaaabaabbbaabbabbaaabaabbaaabbabbbaabaabbbaabbabbaaabaabbaaab...
02:46:05 <ski> (re 'force' .. i believe i have an example of generating the list of primes, and the list of compisites from each other, and using 'force' and '(/\/)' ..)
02:46:31 <quicksilver> > map head . iterate (tail.tail) $ [1..]
02:46:33 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
02:46:57 <quicksilver> narain: you wanted a non-unfoldr way to drop every other element :)
02:47:03 <nmessenger> awesome!
02:47:14 <narain> quicksilver: cool
02:47:23 <quicksilver> doesn't work on finite lists at all though
02:47:34 <narain> uncool :)
02:47:37 <nmessenger> takeWhile (not . null)?
02:47:38 <Pastorn> which is faster? uning == or casing against True?
02:47:49 <quicksilver> for finite lists you need something which knows when to stop, which means you need maybe, which to be honest means you need unfoldr
02:47:52 <quicksilver> Pastorn: casing
02:47:59 <Pastorn> thanks
02:48:02 <quicksilver> Pastorn: always use case, never use == :)
02:48:07 <Pastorn> hehe
02:48:08 <quicksilver> Pastorn: unless you really want == :)
02:48:24 <Pastorn> == makes the code easier to read
02:48:42 <Pastorn> (one could argue)
02:48:43 <quicksilver> I use == almost exclusively in sections
02:48:46 <ski> (roughly something like 'primes = [0..] \\ composites; composites = sort (do p <- primes; n <- [2..]; return p*n)' .. but more elaborate to make it work)
02:48:50 <quicksilver> :t (=='q')
02:48:52 <lambdabot> Char -> Bool
02:48:57 <quicksilver> that sort of thing I find handy
02:49:43 <nornagon> acangiano: "explicit" is not a verb :)
02:49:44 <quicksilver> nmessenger: takeWhile (not.null) would work with the version of tail which returns [] on [] instead of error, yes
02:49:56 <narain> ski: that would be pretty cool, but i can see why you'd have to make it more elaborate
02:49:56 <nmessenger> drop 2 then
02:50:03 <quicksilver> drop 2 []
02:50:05 <quicksilver> > drop 2 []
02:50:07 <lambdabot>  []
02:50:11 <quicksilver> oh, handy :)
02:50:24 <quicksilver> > map head . iterate (drop 2) $ [1..]
02:50:25 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
02:50:29 <narain> > map head . iterate (drop 2) $ [1..10]
02:50:30 <lambdabot>  Exception: Prelude.head: empty list
02:50:40 <narain> > map head . takeWhile (not . null) . iterate (drop 2) $ [1..10]
02:50:41 <lambdabot>  [1,3,5,7,9]
02:50:44 <rahikkala> > (((last . take 10) .) . flip iterate) [undefined] (\c -> 0 : 1 : zipWith (+) c (tail c))
02:50:45 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
02:52:01 <narain> @unpl (((last . take 10) .) . flip iterate)
02:52:01 <lambdabot> (\ g m -> last (take 10 (iterate m g)))
02:53:16 <Pastorn> @type flip . map
02:53:19 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[b1]'
02:53:19 <lambdabot>     In the second argument of `(.)', namely `map'
02:53:27 <Pastorn> @type map . flip
02:53:30 <lambdabot> forall a b c. (a -> b -> c) -> [b] -> [a -> c]
02:53:41 <Pastorn> @type map
02:53:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:53:50 <Pastorn> that's weird
02:54:13 <Pastorn> @type map . flip [1..]
02:54:15 <lambdabot>     Couldn't match expected type `a1 -> a -> c'
02:54:15 <lambdabot>            against inferred type `[a2]'
02:54:16 <quicksilver> map . flip means flip the first argument, then map
02:54:23 <quicksilver> the first agument of map is the function
02:54:31 <quicksilver> so map . flip means map with a flipped function
02:54:44 <acangiano> nornagon: that's what happen when they feed you spaghetti for 26 ys. I've fixed it. Thanks. :-)
02:54:48 <Pastorn> hmm... that's nat exactly what i wanted...
02:54:55 <quicksilver> what did you want?
02:55:07 <nornagon> acangiano: :p
02:55:21 <nornagon> acangiano: other than that, interesting entry! I look forward to subsequent tutorials. :)
02:55:28 <Pastorn> quicksilver: well, actually i'm not exactly sure...
02:55:35 <nornagon> @where planet
02:55:35 <lambdabot> I know nothing about planet.
02:55:41 <nornagon> @where planet_haskell
02:55:41 <lambdabot> I know nothing about planet_haskell.
02:55:49 <quicksilver> @google planet haskell
02:55:51 <lambdabot> http://planet.haskell.org/
02:55:51 <lambdabot> Title: Planet Haskell
02:55:54 <nornagon> so, who maintains planet haskell?
02:56:16 <acangiano> nornagon: cool. thanks :)
02:58:17 <quicksilver> what's the lowdown on using IORefs in ghc threads? is it actualy unsafe, in the sense that something might deadlock or give bad results? or is it just non-deterministic?
02:59:54 <ski> @let x = 42
02:59:54 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
02:59:57 <ski> bah
03:00:12 <ski> > let merge xs[]=xs;merge[]ys=ys;merge xs0@(x:xs)ys0@(y:ys)=case x`compare`y of{LT->x:merge xs ys0;EQ->x:merge xs ys;GT->y:merge xs0 ys};diff[]_=[];diff xs[]=xs;diff xs0@(x:xs)ys0@(y:ys)=case x`compare`y of{LT->x:diff xs ys0;EQ->diff xs ys0;GT->diff xs0 ys};primes=2:[3..]`diff`foldr(\p cs->2*p:([3*p,4*p..]`merge`cs))undefined primes in take 25 primes
03:00:14 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
03:00:34 <ski> narain : there you go .. somewhat compresses to make it not be cut off at the end :/
03:01:12 <narain> whoa
03:01:13 <ski> (this was written in June 2006)
03:01:58 <ski> 'merge' and 'diff' are variants of '(++)' and '(\\)' for sorted, possibly infinite lists
03:02:12 <narain> i see that...
03:02:50 <ski> (and the 'undefined' is never hit, because i fold over an infinite list)
03:03:19 <kolmodin> quicksilver: it's similar to sharing data without locks in any other language
03:03:36 <quicksilver> kolmodin: so it's not unsafe in the crashing sense
03:03:44 <narain> ski: why 2:[3..] instead of [2..]?
03:03:44 <quicksilver> kolmodin: just dangerous in a data integrity sense?
03:04:01 <kolmodin> quicksilver: it won't crash, but you never know which result you get
03:04:01 <quicksilver> narain: because it's 2:([3..]`merge`cs)
03:04:05 <quicksilver> kolmodin: *nod*
03:04:16 <ski> narain : oh .. just for symmetry with the case inside the 'foldr' i guess :)
03:04:20 <quicksilver> kolmodin: no danger of a reading a 'partial write' though
03:04:29 <narain> ah.
03:04:30 <Pastorn> quicksilver: trying to solve "What is the smallest number that is evenly divisible by all of the numbers from 1 to 20?"
03:04:31 <kolmodin> quicksilver: true
03:04:41 <Pastorn> @paste
03:04:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:04:48 <narain> couldn't you have [2*p,3*p..] inside as well?
03:04:48 <ski> or .. maybe what quicksilver said ..
03:05:05 <kolmodin> quicksilver: but saying: incVar var = do x <- readIORef var ; writeIORef var (x+1) -- bad idea
03:05:19 <quicksilver> kolmodin: yes, right, gotcha
03:05:33 <quicksilver> kolmodin: just making sure I understand
03:05:50 <narain> wait, is  2 : [3..] `diff` foo  parsed as  (2 : [3..]) `diff` foo  or as  2 : ([3..] `diff` foo) ?
03:06:04 <ski> narain : yes .. the latter (i had forgotten about that)
03:06:35 <Pastorn> http://hpaste.org/976 author: ME!! title: i need speed
03:06:38 <narain> nice way of defining the primes
03:06:56 <kolmodin> I'm not sure if you can get partial results, as the values are probably box. in that case you'd read half new/half old pointer into the heap. that would lead to a crash. don't know what they guarantie
03:07:05 <narain> i like the approach, ski :)
03:07:08 <ski> narain : if i have '[2*p,3*p..]' i hit myself, and get a bottom kick, iirc
03:07:22 <Pastorn> @tell dons "fix LBs hpaste announces"
03:07:22 <lambdabot> Consider it noted.
03:07:29 <kolmodin> quicksilver: ^^
03:07:33 <Pastorn> @tell dons "please"
03:07:34 <lambdabot> Consider it noted.
03:09:07 <Pastorn> maybe i can remove some more numbers from ls
03:09:42 <quicksilver> Pastorn: I believe this is what you want
03:09:44 <quicksilver> > List.find (\x -> all (==0) . map ((x `mod`)) $ [2..20]) [1..]
03:09:48 <lambdabot> Terminated
03:10:17 <quicksilver> > List.find (\x -> all (==0) . map ((x `mod`)) $ [2..12]) [1..]
03:10:19 <lambdabot>  Just 27720
03:10:19 <ivanm> Pastorn: well, you could do it the hard way and work out all the prime factors of 1 to 20 and then remove duplicates ;-)
03:10:21 <ski> narain : one can replace '2*p:([3*p,4*p..]`merge`cs)' by 'force (2*p) ([2*p,3*p..]`merge`cs)' i think, though
03:10:38 <Pastorn> 15 could probably go; can i divide evenly by 20, then i can divide by 5 and if i can divide by 18 then i can divide by 3
03:10:54 <narain> just the primes from 2 to 19?
03:11:03 <narain> no
03:11:14 <quicksilver> Pastorn: are you trying to make that algorithm fast, or trying to find a fast algorithm?
03:11:33 <quicksilver> Pastorn: the fast algorithm is to take prime factors of all numbers 2..20 and pick the largest of each
03:11:38 <Pastorn> i thought mine was somewhat nice
03:12:01 <Pastorn> yeah, [11,13,14,16,17,18,19,20] is probably the best i can do
03:13:06 <Pastorn> ?src Data.List.find
03:13:06 <lambdabot> Source not found. That's something I cannot allow to happen.
03:13:10 <Pastorn> ?src List.find
03:13:10 <lambdabot> Source not found. I've seen penguins that can type better than that.
03:13:16 <Pastorn> ?src find
03:13:16 <lambdabot> find p          = listToMaybe . filter p
03:14:17 <Pastorn> why is my algoritm slow?
03:14:36 <Pastorn> that's what i really want to know
03:14:38 <narain> 232792560
03:14:41 <rahikkala> I want a language where fix = last . flip iterate undefined
03:15:09 <narain> is that the answer?
03:15:45 <Pastorn> narain: http://projecteuler.net <-- try it yourself, problem 5
03:15:51 <lambdabot> Title: Project Euler
03:15:59 <narain> i just used http://wims.unice.fr/wims/wims.cgi?module=tool/popup.en&search=lcm :)
03:16:05 <lambdabot> Title: Popup calculator forms, http://tinyurl.com/yqp2bn
03:17:10 <narain> Pastorn: maybe iterating over all the numbers from 1 to 232792560 is inherently slow
03:17:33 <narain> assuming that's the right answer
03:17:48 <Pastorn> what should i do instead?
03:18:03 <narain> use the prime factorizations
03:18:19 <Pastorn> ???
03:18:54 <ivanm> find all the prime factors and simplify
03:18:57 <narain> 6 = 2*3, 20 = 2*2*5, lcm(6,20) = 2*2*3*5 = 60
03:19:07 <ivanm> which is what I mentioned before...
03:20:45 <Pastorn> so lcm ([11,13,14,16,17,18,19,20]) then?
03:21:24 <ivanm> Pastorn: *nod*
03:21:33 <ivanm> which is what you want, isn't it?
03:21:34 <narain> assuming you've done the right thing so that it equals lcm([2..20]), yes
03:22:13 <narain> how did you get those values, though?
03:22:13 <Pastorn> yeah, all nubers removed are prime factors of numbers in that list
03:22:23 <narain> even 12?
03:22:41 <Pastorn> 16 = 4*4, 18 = 6*3
03:22:54 <Pastorn> so 3 and 4 are already represented
03:23:06 <ivanm> Pastorn: not as general then...
03:23:22 <Pastorn> since i have to be able to divide by all numbers in the list at the same time...
03:23:40 <Pastorn> ivanm: ???
03:24:07 <narain> hmm, right
03:24:42 <ivanm> Pastorn: if you want the lcm of 1 to 20, then simplifying that to the lcm of 11 to 20 removes generality
03:25:05 <quicksilver> > let pwr x p = head . filter (\n -> (x `mod` round (p^^n)) == 0 && (x `mod` round (p^^(n+1))) /= 0) $ [0..]; primes = [2,3,5,7,11,13,17,19]; fctrs = map (\x -> map (pwr x) primes) [2..20] in product $ zipWith (*)  (map maximum $ transpose fctrs) (map round primes)
03:25:07 <lambdabot>  77597520
03:25:11 <quicksilver> I think that might be right
03:25:20 <quicksilver> that calculates the prime factors and takes the maximum
03:25:22 <narain> why do i have to register to try my answers?
03:25:48 <narain> silly projecteuler.net
03:25:56 <Pastorn> > foldr1 lcm [1..20]
03:25:58 <lambdabot>  232792560
03:26:07 <narain> :t lcm
03:26:09 <lambdabot> forall a. (Integral a) => a -> a -> a
03:26:16 <narain> cool, i didn't know it existed
03:26:17 <quicksilver> apparently not
03:26:22 <quicksilver> I wonder where I went wrong :)
03:26:27 <Pastorn> that should be what i want, right?
03:26:44 <Pastorn> and that should be the answer maybe?
03:26:51 <narain> ?t (^^)
03:26:51 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
03:26:55 <narain> :t (^^)
03:26:57 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
03:27:06 <Pastorn> heh, that IS the correct answer
03:27:46 <quicksilver> > let pwr x p = head . filter (\n -> (x `mod` round (p^^n)) == 0 && (x `mod` round (p^^(n+1))) /= 0) $ [0..]; primes = [2,3,5,7,11,13,17,19]; fctrs = map (\x -> map (pwr x) primes) [2..20] in fctrs
03:27:48 <lambdabot>  [[1,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[2,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[1,...
03:28:03 <Pastorn> narain: register; it's fun
03:28:13 <Pastorn> ?src lcm
03:28:13 <lambdabot> lcm _ 0     =  0
03:28:13 <lambdabot> lcm 0 _     =  0
03:28:13 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
03:28:26 <Pastorn> ?src quot
03:28:26 <quicksilver> > let pwr x p = head . filter (\n -> (x `mod` round (p^^n)) == 0 && (x `mod` round (p^^(n+1))) /= 0) $ [0..]; primes = [2,3,5,7,11,13,17,19]; fctrs = map (\x -> map (pwr x) primes) [2..20] in map (zipWith (*) (round primes)) fctrs
03:28:26 <lambdabot> Source not found. It can only be attributed to human error.
03:28:27 <lambdabot>        add an instance declaration for (Integral [a1], RealFrac [a])
03:28:33 <narain> i waste enough of my time on other pointless diversions already :)
03:28:42 <Pastorn> now that is silly LB
03:29:13 <quicksilver> > let pwr x p = head . filter (\n -> (x `mod` round (p^^n)) == 0 && (x `mod` round (p^^(n+1))) /= 0) $ [0..]; primes = [2,3,5,7,11,13,17,19]; fctrs = map (\x -> map (pwr x) primes) [2..20] in map (zipWith (*) (map round primes)) fctrs
03:29:15 <lambdabot>  [[2,0,0,0,0,0,0,0],[0,3,0,0,0,0,0,0],[4,0,0,0,0,0,0,0],[0,0,5,0,0,0,0,0],[2,...
03:29:27 <quicksilver> > let pwr x p = head . filter (\n -> (x `mod` round (p^^n)) == 0 && (x `mod` round (p^^(n+1))) /= 0) $ [0..]; primes = [2,3,5,7,11,13,17,19]; fctrs = map (\x -> map (pwr x) primes) [2..20] in map (product . zipWith (*) (map round primes)) fctrs
03:29:28 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
03:29:40 <quicksilver> > let pwr x p = head . filter (\n -> (x `mod` round (p^^n)) == 0 && (x `mod` round (p^^(n+1))) /= 0) $ [0..]; primes = [2,3,5,7,11,13,17,19]; fctrs = map (\x -> map (pwr x) primes) [2..20] in map (product . zipWith (^^) (primes)) fctrs
03:29:42 <lambdabot>  [2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18....
03:29:47 <quicksilver> doh
03:29:59 <quicksilver> > let pwr x p = head . filter (\n -> (x `mod` round (p^^n)) == 0 && (x `mod` round (p^^(n+1))) /= 0) $ [0..]; primes = [2,3,5,7,11,13,17,19]; fctrs = map (\x -> map (pwr x) primes) [2..20] in product $ zipWith (^^)  (map maximum $ transpose fctrs) (map round primes)
03:29:59 <lambdabot>  Add a type signature
03:30:05 <quicksilver> > let pwr x p = head . filter (\n -> (x `mod` round (p^^n)) == 0 && (x `mod` round (p^^(n+1))) /= 0) $ [0..]; primes = [2,3,5,7,11,13,17,19]; fctrs = map (\x -> map (pwr x) primes) [2..20] in product $ zipWith (^^)  (map maximum $ transpose fctrs) (primes)
03:30:06 <lambdabot>  Add a type signature
03:30:18 <quicksilver> > let pwr x p = head . filter (\n -> (x `mod` round (p^^n)) == 0 && (x `mod` round (p^^(n+1))) /= 0) $ [0..]; primes = [2,3,5,7,11,13,17,19]; fctrs = map (\x -> map (pwr x) primes) [2..20] in product $ zipWith (^^)  (map maximum $ transpose fctrs) (primes) :: Int
03:30:19 <lambdabot>   add an instance declaration for (Fractional Int)
03:30:22 <quicksilver> > let pwr x p = head . filter (\n -> (x `mod` round (p^^n)) == 0 && (x `mod` round (p^^(n+1))) /= 0) $ [0..]; primes = [2,3,5,7,11,13,17,19]; fctrs = map (\x -> map (pwr x) primes) [2..20] in product $ zipWith (^^)  (map maximum $ transpose fctrs) (primes) :: Float
03:30:23 <Pastorn> quicksilver: /query lambdabot ?
03:30:23 <lambdabot>   add an instance declaration for (Integral Float)
03:30:27 <narain> (^)
03:30:28 <quicksilver> Pastorn: sorry, you're right
03:30:43 <Pastorn> heh, i've done the same:
03:30:56 <narain> quicksilver: use (^) instead?
03:30:59 <narain> :t (^)
03:31:01 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
03:31:12 <dmwit> :t (**)
03:31:15 <lambdabot> forall a. (Floating a) => a -> a -> a
03:31:24 <dmwit> Huh.
03:32:02 <narain> > 42**42
03:32:03 <lambdabot>  1.5013093754529659e68
03:32:08 <narain> > 42^42
03:32:08 <quicksilver> > let pwr x p = head . filter (\n -> (x `mod` (p^n)) == 0 && (x `mod` (p^(n+1))) /= 0) $ [0..]; primes = [2,3,5,7,11,13,17,19]; fctrs = map (\x -> map (pwr x) primes) [2..20] in product $ zipWith (^) primes (map maximum $ transpose fctrs)
03:32:10 <lambdabot>  150130937545296572356771972164254457814047970568738777235893533016064
03:32:10 <lambdabot>  232792560
03:32:18 <quicksilver> narain: yup, fixed :)
03:32:23 <Pastorn> @pl (\(a,b) (c,d) -> (min (a,c), min(b,d))
03:32:23 <lambdabot> (line 1, column 39):
03:32:23 <lambdabot> unexpected end of input
03:32:23 <lambdabot> expecting variable, "(", operator or ")"
03:32:29 <Pastorn> @pl (\(a,b) (c,d) -> (min (a,c), min(b,d)))
03:32:30 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. ((min .) . (,))) . flip . (((.) . (,) . min) .) . (,))
03:32:39 <dmwit> =(
03:32:42 <quicksilver> main problem was using zipwith (*) instead of zipWith (^), d'oh
03:32:45 <narain> quicksilver: cool, your very own lcm function :)
03:33:03 <Pastorn> quicksilver: that, but then do another tuple at the end with the max values and lb goes haywire
03:33:17 <quicksilver> Pastorn: max values?
03:33:27 <quicksilver> ah, yes
03:33:30 * quicksilver nods
03:33:56 <quicksilver> narain: except it hard-codes a list of primes up to 20
03:34:08 <quicksilver> narain: the euler lcm/gcd algorithm much more elegant to be honest :)
03:34:33 <quicksilver> narain: but I wonder if for N-ary lcm, very large N, factorisation might be faster
03:34:36 <quicksilver> I rather doubt it.
03:34:38 <narain> quicksilver: heh. you could replace that with [1..n] and it'd still work, right?
03:35:13 <dmwit> quicksilver: Maybe something like the binary product that was shown earlier tonight, but with lcm in place of (*).
03:35:25 <Pastorn> @pl (\(a,b) (c,d) -> (     (min (a,c), min(b,d) ) ,  (max (a,c), max (b,d)) ))
03:35:28 <lambdabot> ap (flip flip snd . (ap .) . flip flip fst . ((.) .) . ap (ap . ((ap . ((ap . ((,) .)) .)) .) . (. ((min .) . (,))) . flip . (((.) . (,) . min) .) . (,)) ((. ((max .) . (,))) . flip . (((.) . (,)) .)
03:35:29 <lambdabot>  . (max .) . (,)) . fst) snd
03:35:29 <lambdabot> optimization suspended, use @pl-resume to continue.
03:35:33 <beelsebob> lol
03:35:44 <Pastorn> quicksilver: you don't want to see what he does....
03:35:56 <dmwit> @pl-resume
03:36:00 <Pastorn> hehe
03:36:01 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . ap (ap . (liftM2 (liftM2 (,)) .) . (. ((min .) . (,))) . flip . (((.) . (,) . min) .) . (,)) ((. ((max .) . (,))) . flip . (((.) . (,) .
03:36:01 <lambdabot> max) .) . (,)))
03:36:21 <dmwit> Pastorn: she ;-)
03:36:24 <beelsebob> so is pointelss optimisation not guarenteed to terminate then?
03:36:34 <beelsebob> @vixen asl
03:36:34 <lambdabot> <undefined>
03:36:36 <beelsebob> o.O
03:36:44 <beelsebob> she's mid way through the sex change?
03:36:50 <beelsebob> :D
03:36:53 <dmwit> =)
03:36:56 <Pastorn> oh... maybe this wasn't enough... i think i had.... ehm... 4 coordinates when i originall did it, so it was like min (min1, min2)
03:37:10 <Pastorn> dmwit: sorry, didn't know
03:37:27 <Pastorn> okay, actually i did, I've seen her photo
03:37:30 <Pastorn> ?where lb
03:37:31 <lambdabot> I know nothing about lb.
03:37:36 <Pastorn> ?where lambdabot
03:37:37 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
03:37:57 <quicksilver> narain: no, it would need to be 'primes [1..n]'
03:38:05 <dmwit> Aw, I'm sure she's prettier than that.
03:38:33 <narain> quicksilver: isn't lcm [1..n] == lcm (primes [1..n])?
03:38:49 <quicksilver> narain: no
03:38:50 <dmwit> narain: I don't think so.
03:38:58 <dmwit> Imagine lcm [1..4], for example.
03:39:06 <quicksilver> narain: but I'm using that list of primes for factorisation
03:39:09 <narain> ah, right
03:39:14 <quicksilver> narain: if you factor by non-primes too, that trick doesn't work :)
03:40:02 <narain> ah, i was confusing the numbers we're taking the lcm of and the numbers we're factorizing by
03:40:19 <quicksilver> narain: nod :)
03:40:19 <Pastorn> @pl (x -> x^2)
03:40:20 <lambdabot> (line 1, column 4):
03:40:20 <lambdabot> unexpected ">"
03:40:20 <lambdabot> expecting variable, "(", operator or ")"
03:40:25 <Pastorn> @pl (\x -> x^2)
03:40:25 <lambdabot> (^ 2)
03:40:31 <Pastorn> well then
03:42:47 <quicksilver> narain: although the algorithm could, in principle, lazily construct 'enough' primes as it goes
03:44:54 <narain> well, sure
03:45:23 <Pastorn> @hoogle Int -> [a] -> a
03:45:24 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
03:45:27 <Pastorn> heh
03:46:50 <quicksilver> :t flip (!!)
03:46:52 <lambdabot> forall a. Int -> [a] -> a
03:47:07 <Pastorn> let sieve (p:xs) = p : sieve [ x | x <- xs, x `mod` p /= 0] in (sieve [1..]) !! 10001
03:47:16 <Pastorn> > let sieve (p:xs) = p : sieve [ x | x <- xs, x `mod` p /= 0] in (sieve [1..]) !! 10001
03:47:20 <lambdabot> Terminated
03:47:24 <Pastorn> darn
03:48:46 <quicksilver> I have a constant-time algorithm to construct the nth prime, but unfortunately the margin of this IRC channel is too small to contain it.
03:52:08 <Thunde1> quicksilver: Famous last words.
03:54:01 <ivanm> quicksilver: lol
03:56:39 <Pastorn> what can i do to speed up sieve?
03:57:25 <ivanm> faster computer would help ;-)
03:57:28 * ivanm ducks
03:57:31 <Pastorn> heh...
03:57:45 * Pastorn has an AMD 800 with 512MB RAM
03:57:54 <Pastorn> and i'm using gnome
03:58:01 <Pastorn> mainly cause i'm lazy
03:58:40 <Pastorn> i SHOULD have chosen xubuntu instead of normal ubuntu... I'm thinking of swithing OS maybe solaris or freeBSD
03:58:56 <bits64> If you are looking for a faster way to find primes, see calculateprimes.com
03:59:16 <Pastorn> has anyone tried solaris? how's it's package system?
03:59:57 <bits64> I recommend OpenBSD. It has a GREAT package system.
04:00:50 <benja_> hm, is readsPrec supposed to return whitespace from the end of a successful parse?
04:01:27 <JohnMeacham> brup. brup brup.
04:04:05 <campusblo> hello
04:04:19 <campusblo> i have a question from class
04:04:21 <Vq^> hello
04:04:30 <Vq^> shoot
04:04:44 <campusblo> its about base cases with fold function
04:04:50 <campusblo> it was a multiple choice
04:05:08 <campusblo> i thought that the base case would always be []
04:05:16 <campusblo> well i got the question wrong
04:05:29 <campusblo> but how is this possible if fold is a function which works on lists?
04:06:22 <Pastorn> > (foldr (+) 0 [1..222]) == (sum [1..222])
04:06:23 <lambdabot>  True
04:06:36 <campusblo> oh
04:06:39 <campusblo> hmmmm
04:06:39 <Vq^> thats a good example
04:06:44 <Vq^> 0 is the base case for sum
04:06:52 <Pastorn> > (foldr (*) 0 [1..222]) == (product [1..222])
04:06:53 <lambdabot>  False
04:06:58 <Pastorn> > (foldr (*) 1 [1..222]) == (product [1..222])
04:06:59 <lambdabot>  True
04:06:59 <Vq^> like 1 is the base case for product
04:07:15 <Pastorn> Vq^: remembered that ;)
04:07:20 <campusblo> ok
04:07:25 <Vq^> Pastorn: no you didn't :P
04:07:29 <Pastorn> campusblo: get it?
04:07:53 <campusblo> yeh
04:07:55 <campusblo> maxMin (x:xs) = foldl f e xs
04:08:10 <Pastorn> campusblo: scan works sorta like fold but it gives you a list and rememberes what you've done
04:08:27 <Pastorn> > scanl (+) 0 [1..10]
04:08:28 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
04:08:51 <campusblo> and the difference between fold and fold 1 is?
04:08:52 <Pastorn> > sum [1..10]
04:08:53 <lambdabot>  55
04:09:15 <Vq^> campusblo: that fold 1 uses the first element as a base case
04:09:27 <Pastorn> no, you have: foldr/foldl and foldl1/foldr1
04:09:27 <Vq^> campusblo: thats why those functions doesn't work on empty lists
04:10:00 <Pastorn> > foldl (+) 1 []
04:10:01 <lambdabot>  1
04:10:08 <Pastorn> > foldl1 (+) []
04:10:09 <lambdabot>  Exception: Prelude.foldl1: empty list
04:10:20 <campusblo> ok im not sure what that means but i think i can look that up
04:10:28 <campusblo> so my function
04:10:28 <campusblo> maxMin (x:xs) = foldl f e xs
04:10:41 <Pastorn> what's f? e?
04:10:46 <Vq^> what is it supposed to do?
04:10:48 <campusblo> The following fold function is used to return the maximum and minimum values of an integer list as a tuple.
04:11:04 <Pastorn> @type maximum
04:11:06 <lambdabot> forall a. (Ord a) => [a] -> a
04:11:09 <Pastorn> @type minimum
04:11:09 <campusblo>    f (x,y) l
04:11:10 <campusblo>                | l < x = (l,y)
04:11:10 <campusblo>                | l > y = (x,l)
04:11:10 <campusblo>                | otherwise = (x,y)
04:11:10 <campusblo>  
04:11:11 <lambdabot> forall a. (Ord a) => [a] -> a
04:11:24 <Pastorn> check out those :p
04:11:40 <Vq^> Pastorn: that probably wont help here
04:11:53 <Pastorn> campusblo: you know what a lambda function is?
04:12:06 <campusblo> What should be the correct value of e ?
04:12:07 <campusblo> Choose one answer.
04:12:07 <campusblo>             a. (x,x)
04:12:07 <campusblo>             b. [ ]
04:12:07 <campusblo>             c. 0
04:12:07 <campusblo>             d. (0,0)
04:12:22 <campusblo> no i dont know what a lamda function is
04:12:31 <Vq^> campusblo: this is homework right?
04:12:35 <campusblo> thats the entire question
04:12:42 <Pastorn> this is a lambda function (\x -> x+1)
04:12:48 <campusblo> no its a multiple choice question that i got wrong
04:12:52 <campusblo> i chose empty list
04:12:57 <Vq^> @type foldl
04:12:59 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:13:02 <Pastorn> > map (\x -> x+1) [1..10]
04:13:03 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
04:13:24 <Vq^> campusblo: with foldl the basecase needs to have the same type (structure) as the result
04:13:28 <Pastorn> zipWith (\ x y ->
04:13:56 <Pastorn> > zipWith (\x y -> (x,y) ) [1..] ['a'..]
04:13:57 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h'),(9,'i'),(10...
04:14:04 <Vq^> campusblo: so if it should return a tuple option (c) is right out
04:14:18 <campusblo> so its got to be (xx) right
04:14:20 <campusblo> c?
04:14:59 <norpan> it has to be (x,x) because otherwise you lose x, simple method of deduction
04:15:25 <norpan> (given that the correct answer is among the choices)
04:15:35 <campusblo> ok so the answer is a?
04:16:25 <Pastorn> @hoogle Int -> Int
04:16:26 <lambdabot> Test.QuickCheck.configSize :: Config -> Int -> Int
04:16:36 <Pastorn> is there a countDigits?
04:16:44 <campusblo> or d?
04:16:50 <norpan> Pastorn: length . show
04:16:54 <Pastorn> or am i stuck with length . show
04:16:59 <Pastorn> yeah
04:17:02 <Vq^> campusblo: d would be possible, but is 0 a good default value?
04:17:02 <norpan> stuck?
04:17:08 <dmwit> Pastorn: log?
04:17:15 <dmwit> > log 3000 / log 10
04:17:16 <Pastorn> @type log
04:17:18 <lambdabot>  3.4771212547196617
04:17:18 <Vq^> campusblo: and why patternmatch the argument with (x:xs) in that case? :)
04:17:18 <lambdabot> forall a. (Floating a) => a -> a
04:17:32 <dmwit> > floor (log 3000 / log 10)
04:17:32 <Pastorn> dmwit: using integers here
04:17:33 <lambdabot>  3
04:17:43 <dmwit> > ceiling (log 3000 / log 10)
04:17:44 <lambdabot>  4
04:17:49 <dmwit> > ceiling (log 1000 / log 10)
04:17:50 <lambdabot>  3
04:17:55 <norpan> sorry :)
04:17:58 <dmwit> Hmmm... it isn't perfect.
04:18:01 <dmwit> =P
04:18:22 <norpan> i don't understand why you think length.show is being "stuck" with something
04:20:40 <Pastorn> i wish there was some way to truncate and handle words better in haskell
04:20:42 <dmwit> > logBase 10 1000
04:20:43 <lambdabot>  2.9999999999999996
04:20:59 <dmwit> Pastorn: What do you mean?
04:21:03 <campusblo> ok ive basically copied and am off to read. im getting it in flashes
04:21:25 <campusblo> i think the problem is i dont quite understand why you need a base case in a fold
04:21:46 <Pastorn> handling Ints as if they were strings
04:22:14 <campusblo> anyway thanks a lot guys at least i have some examples to work with now
04:22:17 <campusblo> bye for now
04:22:27 <dmwit> campusblo: Same reason you need a base case in most inductions.
04:22:35 <Pastorn> though i could make my instances of take and drop and all that
04:22:36 <dmwit> Woop, missed 'im. =P
04:23:12 <dmwit> Wait, you mean like, take :: Int -> Int -> Int?
04:23:16 <dmwit> What would that even mean?
04:23:21 <Pastorn> @hoogle Char -> Int
04:23:22 <lambdabot> Char.digitToInt :: Char -> Int
04:23:22 <lambdabot> Char.ord :: Char -> Int
04:24:13 <campusblo> ok last question
04:24:30 <Pastorn> hehe
04:24:37 <campusblo> could somebody please give me an example of a fold function where [] is the base case?
04:24:38 <Vq^> ask already :)
04:24:55 <quicksilver> > foldr (:) [] [1,2,3,4,5,6]
04:24:56 <lambdabot>  [1,2,3,4,5,6]
04:25:06 <campusblo> ah right
04:25:07 <quicksilver> foldr (:) [] is very handy :)
04:25:23 <campusblo> so for cons its always []
04:25:24 <dmwit> > foldr (++) [] ["Hello, ", "world!"]
04:25:25 <lambdabot>  "Hello, world!"
04:25:33 <campusblo> and in most other cases it will be 0 or 1 ?
04:25:46 <Pastorn> > foldl (concat . (+)) [] [[1,2,3] [4,5,6]]
04:25:46 <lambdabot>  Couldn't match expected type `[[a]]'
04:25:50 <Pastorn> whoops
04:25:51 <quicksilver> foldr ((:).(+1)) [] [1,2,3,4,5,6]
04:25:52 <Vq^> campusblo: no, it can really be anything
04:25:54 <quicksilver> > foldr ((:).(+1)) [] [1,2,3,4,5,6]
04:25:55 <campusblo> or (0,0)
04:25:55 <lambdabot>  [2,3,4,5,6,7]
04:26:11 <quicksilver> campusblo: foldr ((:).f) [] is more commonly known as 'map'
04:26:19 <Vq^> campusblo: fold is very widely applicable
04:26:26 <Pastorn> campusblo: the base case is what [] should be interpreted as
04:26:30 <dmwit> campusblo: It can be used with pretty much any base case, depending on what you want to do.
04:26:51 <Pastorn> not the other way around =)
04:26:56 <dmwit> campusblo: For example, the base case might be the result of some previous partial computation, and the list is the instructions for doing the rest of the computation.
04:26:58 <quicksilver> if you want to draw an analogy with an imperative loop, the base case is something like 'initial setup' and the function is 'one step'
04:27:26 <ToRA> campusblo: [jumping back a bit] shouldn't the answer to you a,b,c,d question be none of a,b,c,d and instead (maxBound, minBound) ?
04:27:44 <dmwit> > foldr (*) 24 [5, 6, 7] -- 7 factorial
04:27:45 <lambdabot>  5040
04:27:51 <ToRA> >  foldr (liftM2 (***) min max) (maxBound, minBound) [2,7,4,2,1,5,9] :: (Int, Int)
04:27:52 <lambdabot>  (1,9)
04:28:22 <quicksilver> ToRA: cute :)
04:28:30 <kuribas> campusblo: do you know foldr1 and foldl1 ?
04:28:41 <dmwit> > (maximum *** minimum) [2,7,4,2,1,5,9]
04:28:42 <campusblo> so basically you do everything then you do the base case
04:28:42 <lambdabot>  Couldn't match expected type `([a], [a1])'
04:28:50 <dmwit> :t (***)
04:28:52 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:28:56 <campusblo> yes i know foldr1 well kinda
04:28:59 <Pastorn> ?src foldl
04:28:59 <lambdabot> foldl f z xs = lgo z xs
04:29:00 <lambdabot>     where lgo z []     =  z
04:29:00 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
04:29:02 <Pastorn> ?src foldl1
04:29:02 <lambdabot> foldl1 f (x:xs) = foldl f x xs
04:29:03 <lambdabot> foldl1 _ []     = undefined
04:29:12 <dmwit> :t (&&&)
04:29:14 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:29:17 <Pastorn> campusblo: don't look at that
04:29:27 <dmwit> > (maximum &&& minimum) [2,7,4,2,1,5,9]
04:29:28 <lambdabot>  (9,1)
04:29:36 <ToRA> dmwit: cuter
04:29:48 <quicksilver> oh, I'm not sure
04:29:54 <quicksilver> I think ToRA's was cuter
04:29:59 <quicksilver> dmwit's is neater...
04:30:05 <dmwit> I sure like ToRA's original.
04:30:13 * quicksilver draws a 2D graph, axes labelled 'cute' and 'neat'
04:30:21 <dmwit> Lifting an arrow operator into the list monad?
04:30:29 <dmwit> Pretty cute.
04:30:38 <kuribas> campusblo: you don't need a base case for foldl1, which might be appropriate when there is no valid value for the empty list.
04:30:53 <quicksilver> :t liftM2 (***) min max
04:30:55 <lambdabot> forall a. (Ord a) => a -> (a, a) -> (a, a)
04:30:57 <campusblo> so back to my question (X,X) would compare your values to the list?
04:31:16 <campusblo> maxMin (x:xs) = foldl f e xs
04:31:16 <campusblo>        where
04:31:16 <campusblo>              f (x,y) l
04:31:16 <campusblo>                | l < x = (l,y)
04:31:16 <campusblo>                | l > y = (x,l)
04:31:16 <campusblo>                | otherwise = (x,y)
04:31:21 <ToRA> dmwit: i think you're attributing understanding to a knowledge of @pl ;)
04:31:31 <dmwit> =P
04:31:50 <quicksilver> dmwit: no, the lift is into the arrow monad
04:31:52 <dmwit> quicksilver: Of course, it's possible to be cute without lifting into the list monad...
04:31:55 <dmwit> Yeah.
04:32:33 <matthew_-> kittens manage it
04:32:47 <campusblo> so l is the value coming from the list in the case of the function above right?
04:32:53 <glauber_sp> Hi guys. Does anyone use CASL out there?
04:32:58 <dmwit> campusblo: Exactly!
04:33:24 <campusblo> ok now i think i got it
04:33:31 <campusblo> thanks folks
04:33:33 <Pastorn> > let calcFive (x:xs) = product $ map digitToInt (take 5 (x:xs)) in calcFive "73167176531"
04:33:34 <lambdabot>  882
04:33:42 <campusblo> gone. got an exam on this later
04:33:46 <dmwit> Cool, good to see you campusblo!
04:34:01 <Pastorn> > let calcFive (x:xs) = product $ map digitToInt (take 5 (x:xs)) : calcFive xs in calcFive "73167176531"
04:34:02 <lambdabot>  Couldn't match expected type `[Int]' against inferred type `Int'
04:34:22 <Pastorn> it's just basic recursion!
04:34:35 * Pastorn slaps lambdabot 
04:34:49 <Pastorn> !!
04:35:06 <dmwit> Mmmm, I think you've got a bit of a type error there.
04:35:07 <Pastorn> oh... base case could be nice
04:35:27 <dmwit> > let calcFive xs = product $ map digitToInt (take 5 xs) in calcFive "73167176531"
04:35:29 <lambdabot>  882
04:35:47 <dmwit> > let calcFive xs = product . map digitToInt . take 5 in calcFive "731671376534"
04:35:49 <lambdabot>  <[Char] -> Int>
04:35:50 <ToRA> quicksilver: that liftM2 is actually confusing me, is it a lift into Arrow or (->)?
04:35:58 <dmwit> > let calcFive = product . map digitToInt . take 5 in calcFive "731671376534"
04:35:59 <lambdabot>  882
04:35:59 <ToRA> i'm assuming it's (->)?
04:36:55 <dmwit> :t liftM2 (***) min max
04:36:57 <lambdabot> forall a. (Ord a) => a -> (a, a) -> (a, a)
04:37:13 <dmwit> :unmtl (Arrow a) => a b c
04:37:26 <quicksilver> ToRA: (->), which is commonly called 'the arrow monad'
04:37:34 <quicksilver> quicksilver: just to confuse you :)
04:37:47 <dmwit> ?unmtl (Arrow m) => b -> m a a
04:37:47 <lambdabot> err: Parse error
04:37:50 <quicksilver> quicksilver: stop talking to yourself
04:38:01 <ToRA> quicksilver: and confusing me ;)
04:38:06 <Pastorn> dmwit: i don't get it! why can't i do it with a recursion?
04:38:17 <dmwit> Pastorn: take 5 *is* your recursion
04:38:23 <Pastorn> calcFive (_:_:_:_:[]) = 0
04:39:12 <Pastorn> @type product $ map digitToInt (take 5 "123456") : calcFive "23456"
04:39:14 <lambdabot> Not in scope: `calcFive'
04:39:54 <dmwit> :type product $ map digitToInt (take 5 "123456")
04:39:59 <dmwit> :t product $ map digitToInt (take 5 "123456")
04:40:01 <Pastorn> @type calcFive where calcFive (x:xs) = product $ map digitToInt (take 5 (x:xs)) : calcFive xs
04:40:01 <lambdabot> Int
04:40:03 <lambdabot> parse error on input `where'
04:40:33 <dmwit> Pastorn: You have something like calcFive :: (Int : Int)
04:40:38 <dmwit> But that doesn't really exist.
04:40:57 <Pastorn> i want calcFive :: String -> [Int]
04:41:07 <dmwit> Pastorn: Oh, it's the ($) guy.
04:41:18 <dmwit> He lets the (:) guy go first, because he's so polite.
04:41:21 <Pastorn> huh? why?
04:41:34 <dmwit> ($) has the lowest precedence of any operator.
04:41:36 <Pastorn> fucking infix shit
04:42:05 <beelsebob> bored now
04:42:28 <dmwit> > let calcFive (x:xs) = (product . map digitToInt $ take 5 (x:xs)) : calcFive xs in calcFive "157372934959"
04:42:29 <lambdabot>   Non-exhaustive patterns in function calcFive
04:42:30 <beelsebob> Pastorn: why is that shit?
04:42:40 * ToRA contemplates the irony of the location of infix in that exasperated cry by Pastorn
04:42:41 <beelsebob> you would be a bit pissed off if you had to bracket 5 + 6 * 7
04:42:44 <dmwit> > let calcFive [] = 0, calcFive (x:xs) = (product . map digitToInt $ take 5 (x:xs)) : calcFive xs in calcFive "157372934959"
04:42:44 <lambdabot>  Parse error
04:42:51 <Pastorn> let calcFive (_:_:_:_:[]) = 0; calcFive (x:xs) = product (map digitToInt (take 5 (x:xs))) : calcFive xs in calcFive "731671765313306249192251196744265747423553491949349698352031277450632623957831801698480186947885184385861560789112949495459501737958331952853208805511125406987471"
04:42:57 <quicksilver> dmwit: ; not , between clauses, surely
04:43:00 <Pastorn> > let calcFive (_:_:_:_:[]) = 0; calcFive (x:xs) = product (map digitToInt (take 5 (x:xs))) : calcFive xs in calcFive "731671765313306249192251196744265747423553491949349698352031277450632623957831801698480186947885184385861560789112949495459501737958331952853208805511125406987471"
04:43:00 <lambdabot>   add an instance declaration for (Num [Int])
04:43:01 <lambdabot>     In the expression: 0
04:43:01 <lambdabot>     In...
04:43:21 <dmwit> > let calcFive [] = 0; calcFive (x:xs) = (product . map digitToInt $ take 5 (x:xs)) : calcFive xs in calcFive "157372934959"
04:43:22 <lambdabot>   add an instance declaration for (Num [Int])
04:43:22 <lambdabot>     In the expression: 0
04:43:22 <lambdabot>     In...
04:43:29 <dmwit> > let calcFive [] = 0; calcFive (x:xs) = (product . map digitToInt $ take 5 (x:xs)) : calcFive xs in calcFive "157372934959" :: Int
04:43:29 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Int]'
04:43:36 <dmwit> > let calcFive [] = 0; calcFive (x:xs) = (product . map digitToInt $ take 5 (x:xs)) : calcFive xs in calcFive "157372934959" :: [Int]
04:43:37 <lambdabot>   add an instance declaration for (Num [Int])
04:43:37 <lambdabot>     In the expression: 0
04:43:37 <lambdabot>     In...
04:44:04 <dmwit> > let calcFive [] = []; calcFive (x:xs) = (product . map digitToInt $ take 5 (x:xs)) : calcFive xs in calcFive "157372934959" :: [Int]
04:44:05 <lambdabot>  [735,1470,2646,1134,1512,1944,4860,4860,1620,405,45,9]
04:44:09 <dmwit> Winning!
04:44:32 <dmwit> quicksilver: Thanks.
04:44:36 <Pastorn> YAY!! Instance of Num [Int] required for definition of calcFive
04:44:52 <dmwit> Pastorn: Check your base case.
04:44:58 <dmwit> You probably have 0 instead of [] there. ;-)
04:45:11 <Pastorn> oh!
05:00:50 <dmwit> > map (product . map digitToInt . take 5) (tails "165634235643")
05:00:51 <lambdabot>  [540,2160,720,432,360,720,720,1080,360,72,12,3,1]
05:02:39 <dmwit> ?localtime Pastorn
05:02:40 <lambdabot> Local time for Pastorn is Wed Mar 14 13:01:41
05:03:08 <Pastorn> dmwit: just what are you up to?
05:03:31 <dmwit> About 5'10". ;-)
05:04:09 <dmwit> No, actually, I just keep forgetting that people could possibly be in a different time zone, and I was wondering what a sane person like you was doing up so late.
05:04:22 <dmwit> s/time zone/country/
05:08:42 <Pastorn> <-- Gothenburg, Sweden
05:08:47 <Pastorn> +@
05:08:56 <dmwit> Aha.
05:15:56 * dmwit yawns
05:16:04 <dmwit> See you tomorrow, #haskell.
05:16:30 * earthy grins
05:16:39 <earthy> g'night australia. :)
05:17:05 <dmwit> Err... g'night California. ;-)
05:18:37 <earthy> ?localtime dmwit
05:18:37 <lambdabot> Local time for dmwit is Wed Mar 14 05:17:42
05:18:50 <earthy> hm. that's almost wake up time. :)
05:19:07 <earthy> ?localtime dcoutts____
05:19:25 <earthy> ?localtime dons
05:19:27 <lambdabot> Local time for dons is Wed Mar 14 23:18:29 2007
05:23:26 <syntaxfree> sometimes I ponder on the wisdom of publicizing minor flaws in Haskell and Haskell projects.
05:23:41 <syntaxfree> (Looking at the knee-jerk reactions to the darcs discussion on reddit)
05:24:13 <dons> its a bit silly, yes.
05:24:13 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
05:24:26 <dons> we didn't publicise it. but public mailing lists are well, public
05:24:43 <syntaxfree> well, yes. but then there are articles like "Haskell has 8 error management APIs!"
05:24:57 <syntaxfree> and suddenly it's like GHC was J2EE or something.
05:25:23 <syntaxfree> I mean, of course, I'm risking sounding like someone who would sweep the dirt under the rug or something. I don't think that's wise.
05:25:25 <dons> don't worry, its just the media cycle. stories come and go
05:25:40 <huschi> is there a way to add finalizes beside using weak pointers?
05:25:52 <dons> huschi: you can also add finalisers to ForeignPtrs
05:25:58 <syntaxfree> There's apparently an entire community eager to find things to smear on Haskell about.
05:26:05 <dons> syntaxfree: really?
05:26:18 <dons> i've seen maybe 5 negative articles in 5 months
05:26:21 <syntaxfree> the comments on reddit are scary.
05:26:25 <dons> and around 200 positives ones.
05:26:26 <syntaxfree> well, yes.
05:26:38 <huschi> dons: but i have no foreign objects. so there is no other way?
05:26:41 <dons> oh, on the darcs issue. well, that's a bit weird, but no one of import
05:27:06 <dons> huschi: hmm. that's the only two ways i can think of
05:27:15 <dons> try asking on haskell-cafe@, its an interesting questoin
05:27:25 <syntaxfree> but then $WellIntentionedHaskeller posts some commentary on something negative publicly and the reddit people go "See? THIS is why Haskell is SUCH A BAD IDEA!"
05:27:26 <huschi> dons: i also found no other way :)
05:27:37 <dons> syntaxfree: i really wouldn't worry.
05:27:51 <syntaxfree> well, I don't really *worry*.
05:28:07 <syntaxfree> I'm not wanting to implement the thought police or anything.
05:28:09 <dons> content wins in the end. and we have an abundance of that
05:28:47 <syntaxfree> content does not always win in the end in path-dependent markets.
05:28:52 <Pastorn> does it work like this? [ x | criteria_executed_first x, criteria_executed_second x ]
05:29:02 <syntaxfree> not that it's really critical that Haskell "wins" or anything.
05:29:09 <yip> alright, the haskell server code is done! w00t
05:29:24 <yip> it's a horrible ugly mess but i think it should work :)
05:29:24 <syntaxfree> But remember there's always passive adoption inertia in the absence of bad news.
05:29:32 <syntaxfree> People don't, um, like to learn new stuff.
05:29:48 <dons> yip, woo!
05:29:58 <yip> now just to finish the clientside javascript code :(
05:30:22 <syntaxfree> http://syntaxfree.wordpress.com/2007/02/09/for-whom-the-bell-tolls/
05:30:24 <syntaxfree> (old post)
05:30:25 <lambdabot> Title: for Whom The Bell Tolls  Data.Syntaxfree, http://tinyurl.com/yodbk3
05:30:27 <Pastorn> dons, ma man! look at my list comprehension above please :) (i'm trying to speed it up)
05:30:43 <dons> hmm. don't use a list comprehension?
05:30:46 <syntaxfree> Pastorn: there isn't really a sequencing behaviour to list comprehensions.
05:30:53 <syntaxfree> try to desugar it into map and filter.
05:30:59 <dons> right.
05:31:05 <dons> and then fuse the code by hand
05:31:18 <dons> and profile, to make sure you're looking at the right code
05:31:30 <syntaxfree> dons: would && instead of ,  speed it up?
05:31:57 <dons> i'd just start over at this point. trying to optimise in the presense of the desugaring is too hard
05:32:17 <dons> you need more fine control the resulting Core code than a list comprehension gives you
05:32:52 <ClaudiusMaximus> > [ x | x <- [0..100], x > 10, 25 `mod` x == 3 ] -- will this try to do 25 `mod` 0 at all?
05:32:52 <narain> ?quote
05:32:53 <lambdabot> RunarJordahl says: Haskell has quite the following among the alpha geeks
05:32:53 <lambdabot>  [11,22]
05:33:09 <dons> alpha geeks rock
05:33:46 <narain> alpha geeks never die, they just go into beta
05:33:49 <ClaudiusMaximus> > 25 `mod` 0
05:33:50 <lambdabot>  Exception: divide by zero
05:34:15 <ClaudiusMaximus> so, is that just coincidence?
05:34:36 <narain> ClaudiusMaximus: could be implementation-dependent?
05:34:45 <syntaxfree> @quote alpha
05:34:46 <lambdabot> RunarJordahl says: Haskell has quite the following among the alpha geeks
05:34:51 <dons> > [ x | x <- [0..100], 25 `mod` x == 3, x > 10]
05:34:53 <lambdabot>  Exception: divide by zero
05:34:53 <syntaxfree> @quote geeks
05:34:54 <lambdabot> RunarJordahl says: Haskell has quite the following among the alpha geeks
05:35:03 <syntaxfree> @quote dons
05:35:04 <lambdabot> dons says: Java's type system is unsuitable for young children, the elderly or infirm of constitution
05:37:46 <yip> @yow
05:37:47 <lambdabot> Sometime in 1993 NANCY SINATRA will lead a BLOODLESS COUP on GUAM!!
05:40:12 <syntaxfree> @quote Haskell
05:40:12 <lambdabot> desrt says: man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
05:40:33 <narain> i'd like to see the context of that quote :)
05:41:47 <dons> here you go then:
05:41:48 <dons> 01:03:26 <desrt> mallocForeignPtrBytes
05:41:48 <dons> 01:03:30 <desrt> man.  i love this.
05:41:49 <dons> 01:03:45 <dons> oh. boo hoo. :)
05:41:50 <dons> 01:03:53 <desrt> no.  seriously.  it's hot.
05:41:52 <dons> 01:04:00 <dons> one of the main goals is to be fast. really fast.
05:41:55 <dons> 01:04:07 <desrt> is this garbage collected?
05:41:57 <dons> 01:04:15 <dons> no one should go around saying "look haskell is slow"
05:42:00 <dons> 01:04:42 <dons> withForeignPtr
05:42:02 <dons> 01:05:53 <desrt> man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
05:42:05 <dons> haskell/05.04.04
05:42:29 <dons> so um. the Data.ByteString source was the context :/
05:42:48 <dons> that's kind of funny actually
05:43:04 <narain> :)
05:43:48 <quicksilver> I'm pretty sure that conditions in list comprehensions are sequenced
05:43:59 <dons> i'd expect so.
05:44:05 <quicksilver> that's the semantics of the list monad, essentially
05:44:12 <quicksilver> once you hit one fail ([]) it all collapses
05:44:25 <quicksilver> then lazy evaluation tells you that the other stuff won't be evaluated
05:45:27 <quicksilver> I know that the list monad is "essentially commutative" but I'm pretty sure that GHC doesn't
05:46:03 <ski> bag (and set) monad is commutative
05:46:48 <ski> list monad is only commutative "upto ordering", i.e. if you throw away the order .. in which case you get a bag :)
05:47:18 <quicksilver> ski: and you can observe the ordering with _|_, i.e. infinite lists
05:47:31 <quicksilver> ski: concatMap doesn't enumerate infinite lists
05:47:43 <quicksilver> ski: although it isn't particularly hard to imagine a way to write it that would
05:48:05 <ski> not while getting lexicographic ordering
05:48:06 <quicksilver> ski: but, in any case, [] is strictly commutative :)
05:48:23 <quicksilver> ski: [] >> x == x >> [] == [] :)
05:50:10 <ClaudiusMaximus> how does ghc's RTS' garbage collector work?  just been asked "Will you use Haskell to write signal processing externals? Wouldn't you be concerned about bumping into a major GC?"  and i haven't a clue how to answer..
05:50:21 <ski> (quicksilver : that is basically 'left zero' and 'right zero' laws)
05:50:27 <quicksilver> ski: I know
05:50:36 <ski> hmm
05:50:40 <quicksilver> ski: but it is also a proof that [] is in the center of the monad
05:50:53 <quicksilver> ski: which is the context of commutative which I needed above :)
05:50:59 <ski> yes .. i was just wondering about that ;)
05:51:06 <ski> (i.e. the center)
05:51:09 <quicksilver> >> is too strict, too
05:51:13 <quicksilver> > [1..] >> []
05:51:17 <lambdabot> Terminated
05:51:43 <quicksilver> because it's building [[],[],[],[],....]
05:51:48 <quicksilver> and trying to concat that
05:52:25 <ski> hm .. could that be fixed somehow ..
05:52:53 <quicksilver> ski: I doubt many uses of the list monad care about the lexico ordering, by the way
05:53:15 <quicksilver> ski: I for one would prefer to have fair-on-infinite than lexico ordering
05:53:44 <ski> but could you get that, for '(>>=)' ?
05:53:49 <quicksilver> yes
05:53:53 <quicksilver> I wrote it, once
05:54:10 <ski> ok
05:54:59 <quicksilver> ski: http://hpaste.org/680
05:55:12 <ski> but did it handle the '[0..] >> []' case, as well ?
05:55:18 <ski> (ty)
05:56:33 <quicksilver> no, it didn't
05:56:49 <quicksilver> that's like sum [0,0...]
05:57:26 <ski> (so, we still need a 'mpar :: MonadPar a => m a -> m b -> m (a,b)' ..)
05:58:57 <pejo> ClaudiusMaximus, Marlow has a paper from 2004 on the gc. It's a generational copying gc afaik, not sure if it is incremental or not.
05:59:48 <ClaudiusMaximus> pejo: ok, you have an URL handy?
06:01:45 <Pastorn> is this the same as guarding? filterAbort p (x:xs) = if p x then x : filterAbort p xs else []
06:04:32 <ClaudiusMaximus> @src takeWhile
06:04:32 <lambdabot> takeWhile _ []                 =  []
06:04:32 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
06:04:32 <lambdabot>                    | otherwise =  []
06:05:57 <quicksilver> Pastorn: sort of
06:06:49 <DRMacIver> Hm. I'm reading the paper about the dynamic plugin approach lambdabot uses. It seems very cool.
06:06:54 <JohnnyL> where can I find simple code for non scientific applications in haskell?
06:06:55 * DRMacIver should take a look at the source at some point.
06:08:22 <quicksilver> JohnnyL: there's quite a bit on the wiki
06:08:47 <quicksilver> JohnnyL: and someone recently started a cookbook. a bit incomplete still
06:09:10 <JohnnyL> ok
06:09:13 <JohnnyL> thanks
06:11:22 * ClaudiusMaximus reads "Exploring the Barrier to Entry - Incremental Garbage Collection for Haskell"
06:11:54 <yts> @src foldr
06:11:54 <lambdabot> foldr k z xs = go xs
06:11:55 <lambdabot>     where go []     = z
06:11:55 <lambdabot>           go (y:ys) = y `k` go ys
06:12:19 <JohnnyL> it's be really nice if there was database related code samples.'./
06:15:43 <pejo> ClaudiusMaximus, www.haskell.org/~simonmar
06:21:38 <ClaudiusMaximus> @karma+ pejo
06:21:38 <lambdabot> pejo's karma raised to 1.
06:33:32 <chessguy> 'morning haskellers
06:38:51 <chessguy> wow, i'm watching SICP again, and learning even more the second time around
06:40:53 <JohnnyL> DOES HASKELL SUFFER FROM THE WHITESPACE-PERFECT SYNDROM LIKE PYTHON?
06:40:55 <JohnnyL> orry caps
06:41:28 <Philippa_> no, it benefits from it
06:41:30 <Gu1> chessguy:  is the hosting fast for those video's?  they are fairly large
06:41:33 <araujo> Not suffer
06:41:40 <araujo> It has the 'privilege'
06:41:46 <matthew_-> @hoogle Either a b -> Either b a
06:41:47 <lambdabot> No matches, try a more general search
06:41:51 <chessguy> Gu1, it's not bad if you have a good connection
06:42:07 <JohnnyL> araujo, how about honor.. is there any honor in whitespace perfection?
06:42:13 <Gu1> ya i have a fast connection
06:42:18 <araujo> Though Haskell code looks cleaner than python imho
06:42:26 <kuribas> Indentation sensitive syntax annoys me.
06:42:34 <JohnnyL> python reminds me of Forth.
06:42:36 <araujo> JohnnyL, yes
06:42:44 <araujo> JohnnyL, easy to read and write code?
06:43:02 <JohnnyL> araujo, no, just non intuitive. unlike haskell.
06:43:12 <JohnnyL> haskell needs a database wiki.
06:43:13 <JohnnyL> i thinks
06:43:41 <chessguy> you don't have to give semantic meaning to whitespace in haskell, but you can. it's up to you
06:43:46 <Philippa_> bolting a DB back end onto an existing wiki isn't hard
06:43:46 <araujo> JohnnyL, So it is more 'intuitive' , a bunch of ';' and '.' ?
06:44:17 <araujo> That is not intuitive syntax, that's syntax 'noise'
06:44:37 <JohnnyL> araujo, no i mean like un neccesarry variables, it makes computation expensive programs easier to read than syntactic sugar that python exhumes.
06:45:30 <araujo> unecessary variables?
06:45:47 <ToRA> @type either Right Left
06:45:49 <lambdabot> forall a b. Either a b -> Either b a
06:46:03 <kuribas> chessguy: yes, but when you don't write with layout, you have to use ugly C like syntax.
06:46:22 <chessguy> kuribas, yes, but you still have the choice
06:47:00 <JohnnyL> araujo, yup, intermittent and temporary variables that purely functional languages like haskell doesn't need.
06:47:13 <araujo> Right.
06:48:01 <quicksilver> matthew_-: "either Right Left"
06:48:07 <quicksilver> :t either Right Left
06:48:09 <lambdabot> forall a b. Either a b -> Either b a
06:48:29 <quicksilver> matthew_-: polymorphism is awesome sometimes :)
06:48:32 <ToRA> quicksilver: beatcha to it ;)
06:48:41 <quicksilver> ToRA: ah, didn't spot it
06:48:54 <JohnnyL> what does the $= Nothing stand for in :   case cl of	  True -> do		cullFace		    $= Nothing?
06:49:07 <ToRA> @type Right ||| Left
06:49:10 <lambdabot> forall b a. Either b a -> Either a b
06:49:38 <quicksilver> JohnnyL: $= is some functoin provided by that module or one it imports; it's not a standard function
06:49:47 <quicksilver> @where (|||)
06:49:47 <lambdabot> I know nothing about (|||).
06:49:52 <quicksilver> ToRA: where's that from?
06:50:00 <ToRA> quicksilver: arrows
06:50:09 <ToRA> JohnnyL that's opengl stuff yeah?
06:50:21 <ToRA> the $= is a function defined over settable attributes
06:50:24 <JohnnyL> ToRA, yeah frag.
06:50:35 <quicksilver> ah yes, I remember
06:50:59 <ToRA> JohnnyL: http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html#v%3A%24%3D
06:51:01 <lambdabot> http://tinyurl.com/2fcodm
06:51:05 <ToRA> settable statevars
06:51:07 <ClaudiusMaximus> hmm, Marlow's paper says "we can, in theory, provide hard bounds on the pause time [of garbage collection]" -- does anyone know how far 'theory' been translated into 'practice'?  i didn't see a +RTS option to specify the max pause time, and it would be very nice to have...
06:51:39 <ToRA> that little snippet basically means turn of the cullFacing operations
06:51:43 <JohnnyL> ToRA, oh cool, thanks.
06:51:53 <ToRA> np
06:52:50 <JohnnyL> @src ($=)
06:52:51 <lambdabot> Source not found. You speak an infinite deal of nothing
06:52:59 <JohnnyL> @type ($=)
06:53:01 <lambdabot> Not in scope: `$='
06:53:08 <ToRA> JohnnyL: it's part of a typeclass
06:53:21 <Pastorn> ?src fmap
06:53:22 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:53:27 <Pastorn> ?src fmap readFile
06:53:27 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
06:53:37 <Pastorn> @type fmap
06:53:39 <JohnnyL> a bit silly? like the hal 9000? <snickers>
06:53:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:54:26 <JohnnyL> what does the asterisk stand for in *->* ?
06:54:35 <quicksilver> "type"
06:54:39 <JohnnyL> oh ok
06:55:04 <quicksilver> Pastorn: fmap in any monad is liftM
06:55:24 <Pastorn> @type liftM
06:55:26 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:55:41 <quicksilver> @src liftM
06:55:41 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:55:47 <JohnnyL> thanks
06:55:55 <Pastorn> > liftM (+10) [1,2,3]
06:55:56 <lambdabot>  [11,12,13]
06:56:21 <quicksilver> you apply the function to the result of the monadic computation
06:56:29 <quicksilver> so you might liftM toUpper getChar
06:56:47 <Pastorn> quicksilver: show me how you should apply fmap to... say IO
06:56:47 <quicksilver> to get a character and upppercase it
06:57:14 <quicksilver> :t liftM toUpper getChar
06:57:16 <lambdabot> IO Char
06:57:20 <quicksilver> Pastorn: like that
06:57:32 <shapr> When do I get dropM ?
06:57:34 <quicksilver> do { x <- liftM toUpper getChar; do_somethign_with x }
06:57:38 <Pastorn> :t fmap toUpper getChar
06:57:40 <lambdabot> IO Char
06:57:52 <Pastorn> > fmap toUpper getChar
06:57:53 <lambdabot>  <IO Char>
06:57:54 <Pastorn> > a
06:57:55 <lambdabot>   Not in scope: `a'
06:58:00 <Pastorn> awwww
06:58:02 <quicksilver> lambdabot doesn't do IO :)
06:59:08 <Pastorn> > putStrLn "I luuuuuuuuuuuuuv U"
06:59:10 <lambdabot>  <IO ()>
07:00:07 <quicksilver> it lets you manipulate IO, though
07:00:28 <quicksilver> > map putStrLn . words $ ["the quick brown fox"]
07:00:29 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
07:01:15 <quicksilver> > map putStrLn . words $ "the quick brown fox"
07:01:16 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>]
07:01:17 <quicksilver> better :)
07:01:22 <Pastorn> haha
07:01:41 <Pastorn> > sequence_ $ map putStrLn . words $ "the quick brown fox"
07:01:42 <lambdabot>  <IO ()>
07:01:46 <Pastorn> yay
07:01:51 <quicksilver> it makes the point rather well that the IO monad is pure
07:02:01 <quicksilver> it lets you do anything with it, except actually perform the IO :)
07:02:17 <benja_> @tell dons I asked earlier, but if you saw it and replied, I missed it (sorry) -- would you have any comments on http://hackage.haskell.org/trac/summer-of-code/ticket/1114 ?
07:02:17 <lambdabot> Consider it noted.
07:02:19 <flux-> next in the to-do-list, an io-emulator?-)
07:02:23 <benja_> anyone else, too =)
07:02:28 <Pastorn> heh, but how can the IO Monad be pure?
07:02:37 <quicksilver> Pastorn: haskell is a pure language
07:02:58 <Pastorn> if you preform readFile fp now and that gives a certain result
07:02:58 <quicksilver> Pastorn: the only impure things are the 'unsafe' ones, which are not technically haskell
07:03:05 <Pastorn> then edit the file
07:03:08 <Pastorn> and do it agan
07:03:21 <benja_> Pastorn: because its semantics don't require that *evaluating* anything in Haskell has a side effect
07:03:22 <Pastorn> and you get a different result
07:03:25 <quicksilver> haskell doesn't allow you to 'perform readFile'
07:03:32 <quicksilver> it just allows you to specify an IO action
07:03:40 <quicksilver> and the effect of that action might be to read a file
07:03:41 <benja_> so *evaluating* (putStrLn "foo") doesn't do anything
07:03:47 <quicksilver> but that part happens 'outside of haskell'
07:03:55 <quicksilver> the RTS executes the actions
07:03:57 <benja_> (conceptually.) -- it just returns an action that can be performed
07:04:06 <quicksilver> what benja_ said, yes
07:04:38 <Pastorn> oh, so the actual performing is done outside the haskell environment
07:05:11 <quicksilver> yes
07:05:20 <Pastorn> nice =)
07:05:35 <quicksilver> haskell is a pure language which enables you to do things such as specifying a very complex IO action
07:05:39 <benja_> re my question above: ...or is there a way in Haskell already to execute untrusted code (through hs-plugins, I suppose) without it being able to call unsafeXYZ? (what does lambdabot do?)
07:05:49 <quicksilver> benja_: yes, I believe so
07:05:57 <quicksilver> benja_: you can control its import list with precision
07:06:07 <quicksilver> benja_: you can choose not to give it System.IO
07:06:07 <benja_> hmm
07:06:15 <quicksilver> benja_: you can choose not to give it anythign at all, if you like :)
07:06:43 <Pastorn> has anyone tried yhc with ffi?
07:06:57 <Pastorn> or any ffi for that matter
07:06:59 <shapr> malcolmw: Is continuity really important?
07:07:08 <quicksilver> benja_: I think actually haskell has one of the best untrusted code setups you could want
07:07:20 <shapr> malcolmw: Why not just move it from Yale to somewhere else? Does Yale want to hang onto it or something?
07:07:28 <quicksilver> benja_: although I think it has weaknesses in terms of controlling time and space
07:07:33 <malcolmw> shapr: only in the sense that there may be a short time before the machine is taken offline
07:08:13 <shapr> Ohh, you mean if we don't pay that bill, it might disappear in a matter of hours?
07:08:15 <malcolmw> shapr: and we don't know enough about the possible alternative ways of providing the same service
07:08:34 <malcolmw> shapr: hours, no.  weeks, probably
07:08:38 <benja_> the hs-plugins paper just said that it doesn't do anything about unsafeXYZ -- but I suppose limiting the import list handles that sensibly =)
07:09:02 <shapr> Ah, that would give is time to slurp off the data. I still wouldn't leave Hudak footing the bill if he can't.
07:09:52 <malcolmw> shapr: there are issues to consider like whether Yale is providing essentially unlimited data transfer at the moment (quite likely)
07:09:54 <shapr> malcolmw: Does anyone have bandwidth stats on the server? My first suggestion is to switch to bittorrent for file downloads.
07:10:31 <malcolmw> shapr: I've asked Paul for a summary
07:11:11 <malcolmw> Maybe JaffaCake or some other haskell.org admin might be able to find out more quickly though
07:11:13 <shapr> I think SyntaxNinja said that ghc cvs downloads used up nearly all of galois' bandwidth.
07:11:41 <shapr> I think I'm a haskell.org admin, I could probably grab the apache logs and analyze them.
07:11:43 <malcolmw> shapr: darcs does encourage frequent re-checkouts
07:11:47 <JaffaCake> and we don't even *use* CVS :)
07:12:09 <shapr> I think he meant darcs :-)
07:12:43 <benja_> now I'm wondering whether addressing the time/space issue with untrusted code would still be worth a SOC proposal...
07:13:24 <benja_> tuukkah suggested a while ago to adress the issue by running a separate OS process and using OS tools to limit time & space
07:13:57 <shapr> malcolmw: Well, if someone finds out how much bandwidth is used by haskell.org without file downloads, we can calculate how much it'll cost to run a commercially hosted server.
07:14:27 <benja_> I suppose Data.Binary serialization could make it relatively cheap and transparent
07:14:31 <malcolmw> shapr: why without downloads?
07:14:34 <tuukkah> benja_, did i ?-)
07:14:42 <shapr> Because bittorrent will remove most of the need for file downloads.
07:14:44 <benja_> tuukkah: yep :)
07:15:14 <shapr> Now if only we can figure out how to serve darcs repos with bittorrent...
07:15:23 <shapr> Hm, shouldn't be hard.
07:15:36 <Thunde1> shapr: Oh, I think you will find a sponsor very easily. (I'd sponsor it at your own location)
07:15:39 <tuukkah> are you thinking of a different discussion than the one about building this in to the ghc scheduler?
07:15:40 <malcolmw> shapr: if that means i can't just click on a file in my web browser and get it, then I would be disappointed
07:15:57 <CosmicRay> shapr: do you have any interest in hosting the sequence?
07:16:18 <shapr> malcolmw: You will be able to click on a file and just get it, but your download speed will depend on the number of other people downloading.
07:16:26 <CosmicRay> shapr: several have offered machine to host it, but nobody has offered to admin the drupal installation yet (though dons has offered to admin the content)
07:17:12 <benja_> tuukkah: yes, I am :)
07:17:22 <benja_> some longer time ago
07:17:27 <shapr> CosmicRay: If I used sequence regularly right now... but I don't.
07:17:36 <CosmicRay> ok, fair enough
07:18:15 <tuukkah> benja_, wouldn't that be how lambdabot currently works?
07:18:48 <shapr> Is haskell.org a non-profit already? Could we accept donations?
07:19:39 <shapr> CosmicRay: Plus I'd be far more interested in admin'ing something written in Haskell :-) I know that's selfish...
07:20:12 <Thunde1> what's so complicate to administr drupal systems?
07:20:19 <quicksilver> benja_: that's what lambdabot does
07:20:22 <CosmicRay> nothing especially complicated
07:20:28 <quicksilver> benja_: forks a process and uses rlimit
07:20:35 <CosmicRay> it's just that I don't have time for Yet Another Site anymore
07:20:44 <benja_> ok =)
07:20:46 <Thunde1> I see
07:20:47 <benja_> thanks
07:21:05 <shapr> Yeah, nothing complicated really, I just don't really want to maintain a PHP site, and I haven't used sequence much latey. It seems popular though.
07:21:05 <CosmicRay> Thunde1: are you interested?
07:21:06 <benja_> @tell dons ...nevermind :)
07:21:06 <lambdabot> Consider it noted.
07:21:28 <quicksilver> benja_: I think it's interesting to discuss whether it could be moved into the runtime
07:21:42 <quicksilver> benja_: since hs-plugins is already 'quite good' for untrusted code and this would make it 'excellent'
07:21:54 <benja_> right
07:21:57 <quicksilver> benja_: I don't know enough runtime details to know how stupid/infeasible that might be
07:21:57 <Thunde1> Cosmic: Depends on the hosting system, mainly: yes.
07:22:13 <Pastorn> anyone here know how to write MS Excel functions?
07:22:16 <benja_> but probably somebody with more of a clue about the runtime than me would be a better person to tackle it :)
07:22:26 <malcolmw> shapr: haskell.org is not a legal entity at the moment
07:22:42 <Pastorn> (a friend is calling and asking)
07:22:42 <quicksilver> benja_: for example, is it sensible to implement a scripting language by compiling it into haskell (with a custom import list) and loading it with hs-plugins?
07:22:48 <CosmicRay> Thunde1: could you drop me an email at jgoerzen @ complete . org about that?  I may have some people willing to host if you are willing to manage
07:22:50 <shapr> Is there any sort of Haskell foundation?
07:22:56 <CosmicRay> shapr: afaik no
07:23:08 <CosmicRay> shapr: but I believe there was some talk about joining SPI
07:23:14 <tuukkah> some company could pay the hosting bill even if haskell.org isn't a legal entity
07:23:33 <quicksilver> but they couldn't claim tax relief on it
07:23:41 <quicksilver> unless haskell.org can be shown to be a legal charity
07:23:42 <quicksilver> AIUI
07:24:23 <quicksilver> (or, haskell.org could be shown to be a project of SPI, which is)
07:24:24 <tuukkah> who cares about tax relief?-) it's just some percentage
07:24:43 <shapr> As a business owner for seven years, tax relief makes a BIG DIFFERENCE.
07:25:27 <benja_> quicksilver: it would probably make sense to try that =)
07:25:27 <tuukkah> afaik not all countries have something like that for donations anyway
07:25:58 <quicksilver> tuukkah: there is a strong intersection between {people who care about tax relief} and {people who run companies big enough to donate hosting to haskell}
07:26:19 <Gu1> neophyte question:  from what i understand Haskell and other FL's handle parallelism and multiple threads better then some languages.  is that right?
07:26:34 <benja_> did pugs have a compile-to-haskell mode?
07:26:44 <tuukkah> quicksilver, if they can care enough they aren't big enough =)
07:26:56 <shapr> If haskell.org were a legal charitable organization, some companies could make a tax profit by donating money and services to haskell.org. That would be good for us :-)
07:27:20 <shapr> tuukkah: Well, IBM and others are donating to The Apache Foundation and others.
07:27:35 <shapr> benja_: I'm pretty sure pugs could compile to Haskell source at one point.
07:27:39 <CosmicRay> Gu1: I think Haskell is uniquely suited for some nice thread stuff, since it is pure.  I think I recall that recent GHCs can automatically parallelize some algorithms.
07:27:50 <CosmicRay> Gu1: it also has high-performing regular threads
07:28:01 <tuukkah> shapr, because of some tax relief or because they want to contribute to the work the foundation is doing?
07:28:13 <CosmicRay> Gu1: however it does not have the same degree of fine-grained thread control that Java or C does
07:28:21 <malcolmw> how long until haskell.org could afford to employ compiler hackers? :-)
07:28:27 <CosmicRay> Gu1: on the other hand, it has nicer concurrency primitives than java or python
07:28:27 <quicksilver> CosmicRay: you think? what kind of thing?
07:28:28 <shapr> tuukkah: Both, when those sorts of things align, they are more likely to happen.
07:28:31 <benja_> quicksilver: I'm planning to write a web server that executes untrusted code -- I guess at some point I should look into how much work it would be to run perl6 the way you suggested =)
07:28:40 <CosmicRay> quicksilver: which comment were you replying to?
07:28:41 <Igloo> shapr: I would be better to get SPI or someone to be the charitable org that collects the money on our behalf, I think
07:28:42 <shapr> malcolmw: Yeah, look at The Python Foundation.
07:28:50 <quicksilver> CosmicRay: not have same degree of fine control
07:28:57 <quicksilver> CosmicRay: I was wondering which threading primitives haskell lacks
07:28:58 <Gu1> CosmicRay: nod
07:29:03 <shapr> Igloo: Yeah, now if only we knew someone with connections to SPI ;-)
07:29:16 <Igloo> shapr: I exchanged a couple of mails with them about it a while ago, but then they stopped replying
07:29:19 <quicksilver> I strongly suspect this room has a few :)
07:29:27 <quicksilver> I'm a member of SPI technically, I suspect
07:29:28 <CosmicRay> quicksilver: oh.  ability to start/stop/pause arbitrary threads, ability to figure out why arbitrary threads died without wrapper code, etc
07:29:34 <quicksilver> and I suspect CosmicRay is too :)
07:29:36 <shapr> quicksilver: Really? How so?
07:29:42 <quicksilver> I'm a debian developer
07:29:46 <shapr> Yeah, I strongly suspect CosmicRay is a member of SPI.
07:29:49 <CosmicRay> I think threads on ghc can kill an arbitrary thread
07:29:50 <CosmicRay> heh
07:29:51 <quicksilver> all debian developers at point X where SPI members
07:30:02 * Igloo tried to become a member, but their mail server sent me a bounce instead
07:30:02 <quicksilver> CosmicRay: you can kill arbitrary threads
07:30:17 <quicksilver> CosmicRay: pausing arbitrary threads is known to be broken and java deprecated that :)
07:30:18 <CosmicRay> quicksilver: with GHC only, right?
07:30:23 <Igloo> quicksilver: You do actually have to apply for SPI membership, I believe
07:30:32 <CosmicRay> yes, igloo's right
07:30:36 <quicksilver> CosmicRay: Control.Concurrent.throwTo
07:30:39 <quicksilver> CosmicRay: is that GHC only?
07:30:41 <CosmicRay> Igloo: when was this?
07:30:45 <CosmicRay> quicksilver: I believe it is
07:30:58 <quicksilver> CosmicRay: ah. then I'm not sure what threads are, outside of GHC :)
07:31:01 <CosmicRay> which may or may not matter
07:31:05 <huschi> dons: i found another way for finalizers: MVars have them too.
07:31:22 <Igloo> CosmicRay: Fri, 19 Jan 2007 20:29:51 +0000 (UTC)
07:31:47 <CosmicRay> SPI is picking up a number of high-profile projects these days.  I think at last month's board meeting there was talk of openoffice.org joining
07:31:58 <CosmicRay> Igloo: I'd suggest hop into #spi on OFTC and ask there
07:32:01 <Igloo> I told Bdale who said he'd forwarded it to the techies, and heard nothing further. It broke again when I tried it some time later
07:33:29 <shapr> CosmicRay: Does SPI already have infrastructure for donations, site hosting, etc aimed toward sub-projects?
07:34:02 <CosmicRay> shapr: for donations only
07:34:29 <CosmicRay> shapr: afaik all of the SPI member projects manage their own hosting arrangements
07:34:44 <shapr> Ok
07:35:04 <Igloo> Even if they did offer site hosting, it wouldn't be anything suitable for the community server, if that's what you're thinking
07:35:09 <shapr> What would be needed to create a Haskell Foundation or haskell.org or some sort of sub-org of SPI for Haskell?
07:35:11 <sjanssen> is there a problem with haskell.org's current hosting?
07:35:14 <shapr> sjanssen: Yup
07:35:33 <shapr> sjanssen: In short, it's been funded by Paul Hudak's grants forever, and he's running out of money.
07:35:47 <CosmicRay> shapr: I think that somebody needs to decide just what "the haskell project" is, and then contact the SPI board
07:36:15 <CosmicRay> shapr: I thought galois was donating that now?
07:36:15 <xerox__> What is SPI? (BTW, hi all)
07:36:17 <malcolmw> SPI's list of projects says: "If your project is interested in becoming an Associated Project supported by SPI, please see the Associated Project HOWTO"
07:36:28 <shapr> Oh that's good, a HOWTO!
07:36:37 <malcolmw> but there is no link to any HOWTO that I can find on the site :-(
07:36:43 <JohnnyL> anyone have any postgres or mysql examples of a simple database application?
07:37:01 <CosmicRay> xerox__: see www.spi-inc.org, but basically, it started as Debian's legal parent organization.  it provides a legal umbrella for free software projects
07:37:07 <CosmicRay> malcolmw: it may not exist yet
07:37:29 <Igloo> malcolmw: There's a draft somewherewhich I've been told is what to use for now
07:37:59 <malcolmw> I see, so SPI is a legal disorganisation :-)
07:38:11 <zbrown> Errr, how would I install the regex-compat module, in the tar file i downloaded, i see "regex-compat.cabal" "Setup.hs" then a couple other files I'm pretty sure aren't relevant?
07:38:31 <shapr> zbrown: runghc Setup.hs configure && runghc Setup.hs build
07:38:39 <zbrown> shapr: thanks
07:38:43 <shapr> zbrown: Then sudo or what have you and runghc Setup.hs install
07:40:56 <Pastorn> @hoogle Char -> Int
07:40:57 <lambdabot> Char.digitToInt :: Char -> Int
07:40:57 <lambdabot> Char.ord :: Char -> Int
07:42:02 <mauke> > fromEnum '@'
07:42:11 <lambdabot>  64
07:42:37 <Pastorn> @hoogle a -> [a] -> [a]
07:42:37 <lambdabot> List.intersperse :: a -> [a] -> [a]
07:42:37 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
07:42:37 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
07:43:48 <cjeris> > fromEnum ''
07:43:48 <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
07:43:57 <glguy> "Cybersquatting is a growing problem for brands around the world and we hope to educate other brand holders and encourage them to take action," said Aaron Kornblum, senior attorney on Microsoft's **internet safety enforcement team**."
07:44:00 <cjeris> > Char.ord ''
07:44:00 <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
07:44:06 <Pastorn> :t div . flip
07:44:09 <lambdabot> forall a b c. (Integral (b -> a -> c)) => (a -> b -> c) -> (b -> a -> c) -> b -> a -> c
07:44:20 <Pastorn> hmmm
07:44:21 <mauke> > ord ''
07:44:21 <lambdabot>  Improperly terminated character constant
07:44:28 <quicksilver> glguy: you wrote hpaste?
07:44:32 <mauke> > length ""
07:44:33 <lambdabot>  1
07:44:34 <Pastorn> :t (div . flip) 4
07:44:36 <glguy> quicksilver: yeah is it down?
07:44:36 <lambdabot> forall a b c. (Integral (b -> a -> c), Num (a -> b -> c)) => (b -> a -> c) -> b -> a -> c
07:44:39 <quicksilver> glguy: no :)
07:44:45 <zbrown> Question, does the base 2.0 package come default in ghc 6.6? If that even makes sense to ask...
07:44:46 <Pastorn> :t (div . flip) 4 5
07:44:46 <glguy> hurray!
07:44:48 <quicksilver> glguy: could I request search-by-poster?
07:44:48 <lambdabot> forall a b c. (Num (a -> b -> c), Integral (b -> a -> c)) => b -> a -> c
07:44:57 <quicksilver> glguy: I wanted to find some code I pasted weeks ago
07:44:58 <cjeris> > Char.ord (hd "")
07:44:59 <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
07:45:06 <shapr> glguy: You're famous! It was down some hours last night.
07:45:24 <Pastorn> @pl (\x y -> div y x)
07:45:24 <lambdabot> flip div
07:45:27 <glguy> shapr: did you kill it for the resources?
07:45:35 <Pastorn> @type flip div
07:45:37 <lambdabot> forall a. (Integral a) => a -> a -> a
07:45:43 <Pastorn> @type flip div 15
07:45:46 <lambdabot> forall a. (Integral a) => a -> a
07:45:47 <shapr> glguy: Routing problem, thinks Cale
07:45:53 <Pastorn> i like this a whole lot better
07:46:02 <glguy> quicksilver: eventually maybe
07:46:04 <shapr> glguy: Nah, I nearly killed it when upgrading the system, but everything worked out.
07:46:22 <narain> ?t (`div` 15) -- Pastorn
07:46:22 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
07:46:24 <shapr> I got the next six month bill for kakapo, and there were no extra bandwidth charges.
07:46:31 <narain> :t (`div` 15) -- Pastorn
07:46:33 <lambdabot> forall a. (Integral a) => a -> a
07:46:42 <shapr> So hpaste isn't *too* popular yet :-)
07:46:49 <Pastorn> narain: I want to be able to map it
07:47:00 <Pastorn> but i'll work on that later...
07:47:07 <narain> that'll work
07:47:21 <narain> what you did and what i did both
07:47:40 <Pastorn> a friend wanted me to help him out with MS Excel stuff, so i told him to install winhugs and I'll be over there later :)
07:47:55 <narain> > map (`div` 15) [1..30]
07:47:57 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
07:48:13 <Pastorn> cool
07:48:29 <narain> > map (flip div 15) [1..30]
07:48:30 <Pastorn> > map (`div` 15.0) [1..30]
07:48:31 <lambdabot>  Add a type signature
07:48:31 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
07:48:40 <narain> same thing
07:48:44 <Pastorn> > map (`div` 15.0) [1.0..30.0]
07:48:45 <lambdabot>  Add a type signature
07:48:52 <Pastorn> > map (`div` 15.0) [1.0..30.0] :: [Double]
07:48:53 <lambdabot>   add an instance declaration for (Integral Double)
07:48:58 <mauke> > map (/ 15) [1 .. 30]
07:48:59 <Pastorn> oh, right
07:49:00 <lambdabot>  [6.666666666666667e-2,0.13333333333333333,0.2,0.26666666666666666,0.33333333...
07:49:47 <quicksilver> 'all' sections are is a neat syntax for flip and partial application
07:49:55 <quicksilver> but it is a *very* neat syntax
07:49:56 <Pastorn> is it true that Excel has been banned for being... well, Excel?
07:50:09 <quicksilver> the kind that frees your mind and enables you to think of things you wouldn't have thought of befor
07:50:18 <Pastorn> :t all
07:50:21 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:51:41 <quicksilver> Pastorn: that's not the all I was talking about :)
07:51:48 <quicksilver> Pastorn: I was just using the english word all :P
07:52:28 <Pastorn> hehe... well, I usually avoid it, since it's too strong
07:54:49 <Pastorn> and always comment when people use it, which annoys them and gives me great satisfaction
08:02:38 <ToRA> does anyone have any good tutorial or anecdotal example they can give of when arrows are useful? (other than as tuple or Either combinators)?
08:03:08 <ToRA> or even code patterns that could be done better with an arrow?
08:03:31 * ToRA has read up on them, but is lacking intuition as to when to use them
08:05:22 <shapr> Have you looked at the arrow-styel interpreters? Or the arrow-style parsers?
08:05:26 <Spark> robin hood found them quite useeful
08:05:51 <shapr> Have you read about Hughes' motivation for arrows in "Generalizing Monads to Arrows" ?
08:06:15 <ToRA> shapr: yeah a while ago
08:06:34 <shapr> Do you understand why lifting a normal function into an arrow loses the spiffy shortcut ability of arrows?
08:06:43 <shapr> Anyway, I gotta go cycle and burn off some energy, bbl.
08:07:03 <quicksilver> ToRA: I think the key motivation is the non-monad parsers
08:07:24 <ToRA> quicksilver: that's the impression i was left with
08:07:57 <quicksilver> ToRA: which is not to say that other people might not think of other motivations in future :)
08:08:10 <ToRA> yeah
08:08:11 <quicksilver> ToRA: but I haven't seen such a rich set of examples for arrows as there was, for example, in Moggi's monad paper
08:08:48 <ToRA> quicksilver: mmm, may not have read that one
08:09:16 <ToRA> quicksilver: got an url / title / where to find it?
08:09:41 <quicksilver> http://scholar.google.com/scholar?hl=en&lr=&cluster=8828873263716674332
08:09:43 <lambdabot> Title: - Google Scholar, http://tinyurl.com/25p47d
08:10:00 <Spark> ToRA: did doc do something funny with nfs last night?
08:10:05 <quicksilver> that's odd. title of that page should be 'Moggi: Notations of Computation and Monads'. Silly lambdabot.
08:10:09 <Spark> or have you not bothered mounting your home directory
08:10:31 <ToRA> Spark: not looked at it yet, will check 1 sec
08:10:39 <ToRA> quicksilver: yeah, just found it on haskellwiki, cheers
08:10:58 <Igloo> quicksilver: That title is set with JavaScript
08:11:00 <ToRA> Spark: works fine
08:11:06 <Spark> mm ok thanks
08:12:05 <quicksilver> Igloo: bah. google--
08:14:35 <sjanssen> @karma google
08:14:35 <lambdabot> google has a karma of 1
08:14:39 <Spark> tora: mount: peregrine.doc.ic.ac.uk.:/export2/users/d/dc04 failed, reason given by server: Input/output error
08:14:41 <yip> ToRA: have you looked at functional reactive programming, fruit and yampa?
08:14:43 <Spark> oh dear :)
08:15:48 <ToRA> yip: Not really; (not needed to)
08:16:13 <ToRA> yip: I'm just trying to work out if there are some patterns of code i'm writing that could be more cleanly expressed with arrows
08:16:41 <ToRA> e.g. the ability to use monads to thread state around instead of passing it as an argument was a lightbulb turning on
08:17:02 <ToRA> i'm looking for the arrow "equivalent" if such a thing exists
08:17:23 <yip> if you are interested in stateful programs, like simulations and such, then functional reactive programming should interest you
08:17:50 <yip> i have some ideas for an arrow based web framework even
08:18:56 <ToRA> yip: oh?
08:22:06 <yip> the web server would have a state that is the collection of documents, each with an associated url. a GET request would return the matching document. a POST request would fire a yampa event that would potentially alter the state
08:22:28 <zeeeee> hi all, the gph authors say (nf2 `par` (nf1 `seq` (nf1+nf2+1))). couldn't they have also said (nf2 `par` (nf1+nf2+1))?
08:22:35 <zeeeee> whoops, no url:
08:22:57 <zeeeee> http://www.macs.hw.ac.uk/~dsg/gph/docs/Gentle-GPH/sec-gph.html
08:23:14 <zeeeee> (this is in the 3rd code snippet box)
08:23:28 <sjanssen> zeeeee: it depends on the strictness of (+)
08:24:19 <zeeeee> sjanssen: i don't follow...won't (+), if evaluated, evaluate its first operand?
08:24:46 <sjanssen> a compiler might choose to evaluate either x or y first in x+y, the seq makes it more clear to the compiler
08:25:12 <yip> > True || undefined
08:25:13 <lambdabot>  True
08:25:17 <yip> > undefined || True
08:25:18 <lambdabot>  Undefined
08:25:24 <ndm> @src (||)
08:25:24 <lambdabot> True  || _ =  True
08:25:24 <lambdabot> False || x =  x
08:25:26 <zeeeee> sjanssen: ahhh, i see...you're saying the rts may block on y before evaluating x, which would be bad
08:25:35 <ndm> yip: the source code makes it explicit
08:25:36 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
08:25:42 <sjanssen> ndm: not exactly
08:25:55 <ndm> sjanssen: with (||) it does
08:26:02 <sjanssen> seq doesn't strictly imply order
08:26:12 <ndm> ah, i meant for (||), not seq :)
08:26:17 <sjanssen> ndm: ah
08:26:23 <ndm> seq means virtually nothing....
08:26:33 <ndm> _|_ `seq` x = _|_
08:26:37 <ndm> x `seq` y = y
08:26:45 <ndm> thats the semantic definition of seq
08:26:46 <yip> ndm: how do i write (||) so that it will work in all cases?
08:27:02 <ndm> yip: you can't, if you could you would be able to tell if something was bottom or not
08:27:05 <sjanssen> yip: not possible
08:27:13 <ndm> yip: or write it in the IO monad and catch errors, but thats just evil
08:27:29 <sjanssen> yip: note that telling if something is not bottom is equivalent to solving the halting problem
08:28:05 <sjanssen> I suppose you could fork two threads to evaluate each component
08:28:13 <yip> what's a good math book that will teach me all this stuff?
08:29:16 <ndm> yip: read a haskell book, _|_ is a haskell concept, not a maths concept
08:29:34 <ndm> (or rather maths tends not to crash, so doesn't treat _|_ in the same way)
08:29:46 <yip> but it's probably an idea inspired from some math?
08:30:00 <ibid> yes
08:30:42 <ndm> yip: yes, lattice theory, but it won't make it clearer if you know lattice theory
08:30:58 <ibid> yip: the mathematical background is order theory (lattices et cetera); its connection to programming can be seen from the theory of denotational semantics
08:31:23 <ibid> yip: but as ndm says, this won't help with programming :)
08:31:50 <yip> will it help with designing my own programming languages? :o
08:31:54 <ndm> a book on denotational semantics and equational reasoning would be good
08:32:05 <ndm> yip: lattice theory, no, denotational semantics - yes
08:32:14 <ndm> i don't know of a good such book though
08:32:27 <yip> online video tutorials?
08:32:37 <ndm> the semantics books tend to be imperative orientated, none have equational reasoning
08:33:34 <quicksilver> there is at least one decent-ish book on domain semantics for functional languages
08:33:44 <quicksilver> I fear it's out of print and I can't remember the name of the author anyway
08:34:01 <yip> what's the name of the book?
08:34:25 <quicksilver> something really dull like 'the semantics of programming languages'
08:34:28 <ndm> i think the starship project had a book on equational reasoning
08:34:35 <ndm> but that was years ago
08:34:41 <Gu1> there are some books on amazon.com to are are oriented towards haskell and math
08:34:48 <quicksilver> ah!
08:34:49 <Gu1> http://www.amazon.com/Haskell-Road-Logic-Maths-Programming/dp/0954300696/ref=pd_sim_b_2/002-4957099-2143200    being one
08:34:51 <quicksilver> Winskel!
08:34:53 <lambdabot> http://tinyurl.com/26njas
08:34:59 <quicksilver> it's Winksel's book I was referring to
08:35:18 <quicksilver> ref at the bottom of http://en.wikipedia.org/wiki/Formal_semantics_of_programming_languages
08:35:21 <lambdabot> Title: Formal semantics of programming languages - Wikipedia, the free encyclopedia, http://tinyurl.com/22o9c7
08:35:44 <quicksilver> I suspect Reynold's book might be good, simply on the grounds that he is a jolly clever chap, but I haven't read it.
08:36:12 <ClaudiusMaximus> > typeOf ((map (+1)) :: [Int]->[Int])
08:36:14 <lambdabot>  [Int] -> [Int]
08:36:30 <ClaudiusMaximus> > show . typeOf ((map (+1)) :: [Int]->[Int])
08:36:31 <lambdabot>  Couldn't match expected type `a -> b'
08:36:38 <pejo> The Winskel book is good, but I'd say it's mainly focusing on an imperative language. Probably hard to read on your own, unless you have some background.
08:36:44 <ClaudiusMaximus> > show $ typeOf ((map (+1)) :: [Int]->[Int])
08:36:45 <lambdabot>  "[Int] -> [Int]"
08:37:05 <ibid> quicksilver: theories of programming languages? it's good, but it's imperative and it uses operational semantics for most stuff
08:37:13 <quicksilver> ibid: ah, ok
08:37:53 <yip> so should i read the winskel book?
08:38:04 <pejo> (There's nothing wrong with operational semantics imho, the Winskel book covers that too, somewhat)
08:39:49 <quicksilver> yip: if you hav e access to a library copy, definitely check it out
08:39:57 <quicksilver> yip: I'm not going to pretend it's a page-turner, though :)
08:40:30 <yip> well google has the preface and chapter 2 online :)
08:44:54 <lordrat_> [6~
08:50:23 <zbrown> On average how long does ghc 6.6 take to compile/build?
08:50:44 <Igloo> That depends how fast a machine you have
08:51:08 <sjanssen> ghc+extralibs takes a bit less than an hour on my core duo
08:51:18 <Igloo> A standard build will take aroudn an hour on a reasonably modern machine with enough RAM
08:52:48 <quicksilver> I seem to recall the darwinports bootstrap taking around 4 hours on my humble iBook 800Mhz
08:52:51 <zbrown> sjanssen: ok so about less than an hour for mee too
08:52:58 <quicksilver> that's roughly the time I *really* went off source-based packaging systems :)
08:53:02 * zbrown has a Core Duo 2 ghz
08:58:03 <zbrown> Igloo: enough ram being a gig?
08:58:28 <quicksilver> 1 gig is never enough for MacOS :P
08:58:37 <quicksilver> shouuld be fine for linux, though
08:58:52 <sjanssen> quicksilver: yeah, what's the deal with that?
08:59:10 <sjanssen> it was really painful running OS X with 512mb
08:59:20 <quicksilver> sjanssen: not entirely sure, although I suspect their graphics layer eats up the memory a bit
08:59:39 <quicksilver> sjanssen: I do wonder if they don't share mapped library images, I must admit
09:00:05 <pejo> I'm running OSX fine on 1 gig.
09:00:47 * earthy runs OSX just fine on 640M
09:00:52 <Igloo> zbrown: 1G should be fine
09:00:59 <earthy> 384 was annoying though
09:01:22 <earthy> then again... I've run linux in as little as 1M
09:01:27 <earthy> so who am I to complain
09:02:03 <earthy> oh, and yeah, the graphics do eat memory
09:02:04 <zbrown> hmmm
09:02:17 <earthy> but what counts more is the rather agressive caching
09:02:26 <earthy> and the not-quite-ideal vm system
09:02:36 <earthy> which leads to rather expensive paging behaviour
09:02:47 <sjanssen> earthy: yes, the vm really seems to suck
09:03:01 <earthy> (the vm pages out to *files* on disk... these files, from what I've seen, need not be contiguous)
09:03:10 <pejo> Could it be that the VM isn't optimized for interactive performance, but throughput rather?
09:03:11 <sjanssen> I've never seen a machine thrash as hard as my mac
09:03:25 <kc5tja> At first, I read that as, "I run MacOS X just fine on 640K"
09:03:26 <kc5tja> ;)
09:03:28 <matthew_-> there's also some horrid wrapping around mach threads which makes multithreaded performance on OSX really really sucky
09:03:53 <earthy> plus, having fat binaries doesn't help one bit. ;)
09:04:12 <pejo> earthy, thinking of the universal binaries?
09:04:44 * earthy nods
09:04:53 <lordrat_> [A
09:04:57 <earthy> but mostly universal libs
09:05:25 <earthy> and ofcourse, mach-o isn't the most memory-friendly linking architecture to start with
09:05:47 <zbrown> Ya... we're using OSX server on a cluster and im not so hot about the performance hit we'll probably take...
09:06:14 <earthy> zbrown: if you're on a cluster that is partitioned correctly: virtually none
09:06:14 <matthew_-> zbrown: you can always chuck linux or even solaris on them ;-)
09:06:34 <pejo> earthy, isn't the universal binaries basically two concatenated binaries, one for each arch? And shouldn't the pager just read the one for your current arch?
09:06:41 <earthy> ah, no
09:06:58 <earthy> it's a mach-o linker object with multiple sections
09:07:03 <earthy> it gets *mapped* into memory completely
09:07:04 <ski> (ndm : 'parallel or' is computable)
09:07:13 <earthy> the pager then only pages in those sections it needs
09:07:20 <earthy> (it == the dynamic linker)
09:07:51 <pejo> earthy, hm. So what is the problem with that, except a couple of extra megs mapped memory?
09:08:08 <earthy> no more locality of reference where the pager can help by prefetching
09:08:17 <earthy> you're jumping around more
09:08:18 <mwc> @seen dons
09:08:18 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3h 24m 18s ago.
09:08:24 <zbrown> earthy: hrm I've read some articles discussing the performance of xnu... we'll have to see though
09:08:48 <earthy> oh, xnu isn't as highly optimised as linux for a lot of applications
09:08:49 <mwc> damn, I had to come and give him a hard time about OpenBSD doubling it's number of remote holes in one press release.
09:09:08 <mwc> Xnu is really painfully bad at lots of things
09:09:13 <earthy> however, if you're cpu-bound, which you're bound to be on a cluster, those overheads shouldn't matter too much
09:09:38 <mwc> there was an infamous set of benchmarks where they ran MySQL on OS X and Linux on a PowerMac Dual G5.
09:09:52 <mwc> Linux was significantly better
09:09:56 <earthy> oh yeah
09:10:03 <earthy> but MySQL is I/O bound. :)
09:10:10 <zbrown> hrm
09:10:19 <zbrown> stupid sparc box won't give me an openboot console
09:10:30 <mwc> Well, iirc, IPC under XNU is Mach-based, and also kind of crummy
09:10:52 * earthy ndos
09:10:53 <earthy> nods even
09:10:59 <earthy> mach is somewhat... bloated.
09:11:16 <earthy> which really is why linux exists in the first place
09:11:27 <earthy> GNU had already chosen to go with Mach...
09:11:28 <pejo> earthy, so the sections aren't continuous?
09:11:51 <earthy> pejo: the sections themselves are, but a program need not be in 1 single section...
09:12:11 <mwc> hahaha, the Hurd?
09:12:24 <earthy> mwc: you've heard about it! :)
09:12:50 <mwc> They switch kernels so often they don't even have basic OS services done
09:12:57 <mwc> Mach, L4, then Coyotos now
09:13:08 <therp> a new kernel again for hurd?
09:13:21 <pejo> mwc, is Coyotos another microkernel?
09:13:27 <mwc> Yeah
09:13:51 <earthy> this reminds me of 'why vim won': Bram Moolenaar just kept on working on it
09:13:58 <mwc> the author of it was a little more receptive to working with the Hurd folks to bend it to their whims. L4 is pretty much a mature standard now.
09:14:27 <therp> I have a strong dislike for the hurd developer attitude.
09:14:33 <mwc> Coyotos is kinda neat because it's written in BitC
09:14:39 <quicksilver> nice quote from steve downer on -cafe
09:14:41 <quicksilver> "if the code isn't published, it's advertising, not research. "
09:14:44 <therp> they totally failed to attract skillful people (in contrast to linus obviously)
09:15:00 <mwc> it's supposed to support formally verified code in the kernel
09:15:02 <mwc> which is kinda neayt
09:15:16 <mwc> well, away for me
09:15:18 <therp> you better go for a dependent type kernel :)
09:15:58 <kc5tja> earthy: I'm still confused; how is that possible, if the pager *never* pages in pages from other architectures?
09:16:12 <kc5tja> You still get locality of reference from what I can see.
09:16:22 <therp> earthy: "vim won"? with respect to what? vi?
09:16:27 <quicksilver> kc5tja: because the code fragments aren't on page boundaries
09:16:31 <quicksilver> kc5tja: (I assume that's the point)
09:16:31 <earthy> therp: elvis stevie nvi
09:16:42 * earthy nods
09:16:43 <Gu1> since haskell is a high level langauge in comparison to asm/c/c++, it generally wouldn't be a good choice for kernal/os development right?
09:16:47 <kc5tja> That wouldn't affect anything.
09:16:52 <bd_> Gu1: It's been done :)
09:16:54 <bd_> ?where house
09:16:54 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
09:16:58 <bd_> ^^^ Haskell OS :)
09:17:04 <earthy> bd: no it isn't
09:17:07 <quicksilver> kc5tja: suppose your 8k page has 4k of 'other architecture code'
09:17:07 <bd_> There's /some/ asm/C of course
09:17:15 <bd_> in the RTS
09:17:19 <bd_> but drivers etc are Haskell
09:17:19 <quicksilver> kc5tja: then you've wasted 4k, and lost some locality
09:17:22 <kc5tja> quicksilver: The code chunks are independent, by his own admission.
09:17:31 <quicksilver> kc5tja: if that story is consistent across all your pages..
09:17:35 <Gu1> fascinating
09:17:39 <narain> can you boot into house?
09:17:40 <Gu1> thanks =p
09:17:47 <earthy> norain: you can.
09:17:56 <earthy> but it doesn't have aprogram loader yet, IIRC.
09:18:41 <narain> earthy: how do you run things without a loader? everything that runs has to be built-in?
09:18:55 <Gu1> the only downfall to writing an OS from scratch is lack of drivers..
09:19:01 <pejo> narain, Hallgren only had the icfp presentation slides (05?) in House, not in Linux.
09:19:11 <earthy> narain: or loaded by grub or by tftp. :)
09:19:36 <earthy> the latter would suggest they do have a modicum of program loading working
09:20:41 <lordrat_> set text_color_nicks ON
09:20:41 <earthy> but, basically, yeah, programs are loaded externally from the kernel and then jumped to, afaict
09:21:42 <earthy> http://os.inf.tu-dresden.de/L4/l3elan.html
09:21:43 <lambdabot> Title: The L3 operating system - ELAN
09:21:48 <earthy> *whee* that's a blast from the past
09:21:56 * earthy learned to program in ELAN. :)
09:22:10 <earthy> well, formally, at the university
09:23:31 <lordrat_> stamp_text_format set to: %H%M>
09:26:08 <shapr> lordrat_: What are you doing?
09:36:50 <chessguy> another nice Quantum computing blog by sigfpe
09:37:44 <chessguy> sigfpe++
09:39:37 <desp> is it possible to define an unary symbolic operator?
09:41:25 <quicksilver> yes, but you'll have to use it in brackets
09:41:29 <quicksilver> or postfix :)
09:42:18 <roconnor> > let (<>) x = x+1 in (<>) 5
09:42:19 <lambdabot>  6
09:42:39 <narain> > let (^_^) = 1 in (^_^)
09:42:39 <lambdabot>  Parse error
09:42:55 <desp> I was hoping for a less verbose not
09:42:55 <quicksilver> > let (^^) = 1 in (^^)
09:42:57 <lambdabot>  1
09:43:03 <roconnor> > let (x<>) = x+1 in 5<>
09:43:03 <lambdabot>  Parse error in pattern
09:43:16 <roconnor> > let (<>)x = x+1 in 5<>
09:43:16 <lambdabot>  Parse error
09:43:18 <quicksilver> roconnor: post fix only works on function-types :)
09:43:49 <quicksilver> let (<>) = id in (+1) <> 5
09:43:55 <quicksilver> > let (<>) = id in (+1) <> 5
09:43:56 <lambdabot>  6
09:44:09 <quicksilver> desp: not is only three characters :)
09:44:16 <narain> > let (!) = not in !True
09:44:16 <lambdabot>  Parse error
09:44:26 <quicksilver> let (!) = not in (!)True
09:44:30 <quicksilver> > let (!) = not in (!)True
09:44:31 <lambdabot>  False
09:44:42 <narain> how come <> worked without parens?
09:45:00 <quicksilver> narain: I used it infix
09:45:06 <narain> oh
09:45:14 <quicksilver> narain: but it only works at function types, I think
09:46:07 <desp> quicksilver: this isn't really serious, but
09:46:08 <desp> http://pastie.textmate.org/46865
09:46:10 <lambdabot> Title: #46865 - Pastie
09:46:25 <desp> oops, forgot to turn on soft wrapping
09:46:27 <desp> one sec
09:46:48 <narain> quicksilver: you mean you have to return a function, right?
09:46:53 <desp> http://pastie.textmate.org/46866
09:46:54 <lambdabot> Title: #46866 - Pastie
09:46:55 <lordrat_> /whois quicksilver
09:47:06 <quicksilver> narain: yeah
09:47:16 <desp> this would looks so much better with a ~
09:47:18 <desp> ;)
09:47:41 <quicksilver> desp: let n = not ?
09:48:38 <narain> well, if you had a symbolic op you could omit a space as well
09:48:44 <desp> yep
09:49:32 <narain> stupid idea: define a &&~ operator :)
09:49:41 <desp> haha!
09:49:42 <desp> I like it
09:50:16 <narain> asymmetry in the  not a &&~ b  case though
09:50:56 <narain> ?t (==>)
09:50:56 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:51:02 <narain> :t (==>)
09:51:04 <lambdabot> forall a. (Testable a) => Bool -> a -> Property
09:51:46 <quicksilver> I suspect desp defined his own ==>
09:51:55 <desp> yep, it's in the pastie
09:52:22 <quicksilver> desp: if you want to get realy hardcore, embed a minilanguage in strings
09:52:23 <narain> i didn't see that
09:52:49 <desp> quicksilver: :)
09:53:06 <narain> or build an AST out of constructors
09:53:40 * shapr hugs conal
09:53:47 <glguy> (not a && b && not c && not d == True) is (not a && b && not c && not d) is not (or [a,b,c,d])
09:54:08 * conal winks at shapr & blushes
09:54:32 <glguy> == True is always unnecessary
09:55:02 <glguy> (a && not b && not c && not d == True) || (not a && b && not c && not d == True) -- is -- not (or [b,c,d])
09:55:22 <narain> glguy: the second equality isn't
09:55:27 <shapr> I want to die peacefully in my sleep like my father, instead of screaming in terror like his passengers.
09:55:50 <desp> glguy: you're right, I was in a hurry
09:56:12 <shapr> I like that joke.
09:56:40 <syntaxfree> hey, there's a free version of LispWorks.
09:57:07 <narain> die, my dear doctor? that's the last thing i shall do!
09:57:40 <syntaxfree> hmm. you can't save an image.
09:58:33 <glguy> narain: ah, I see what the pattern is: let n = length (filter id [a,b,c,d]) in n == 1 || n == 4
09:59:19 <syntaxfree> YIKES!
09:59:25 <syntaxfree> the full version costs US$1,300.
09:59:43 <syntaxfree> Jesii. A pretty IDE isn't worth $1000!
09:59:49 <narain> glguy: hey, nice going
09:59:59 <glguy> :-p
10:00:14 <narain> n == 0 also
10:00:24 <glguy> oh, I didn't see that
10:00:37 <glguy> so then: n /= 1 && n /= 2 would be better :)
10:00:43 <glguy> errr
10:00:47 <glguy> nope, that didn't cover 3
10:00:54 <glguy> same number either way
10:02:24 <narain> elem n [0,1,4]?
10:03:43 <quicksilver> n `elem` [0,1,4]
10:05:00 <narain> also, sum . map fromEnum $ [a,b,c,d]
10:06:35 <quicksilver> meh. depending on the precise values of fromEnum is nasty.
10:06:43 <narain> true
10:06:55 <narain> rather hacky
10:08:07 <quicksilver> if there was an eliminator for bool
10:08:18 <narain> what's an eliminator?
10:08:19 <quicksilver> so you could write (cond 0 1) instead of fromEnum, I might like it more
10:08:47 <quicksilver> narain: either is the eliminator for Either, maybe for Maybe, foldr for [a]
10:09:08 <narain> ?t either
10:09:08 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
10:09:12 <narain> :t either
10:09:14 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
10:09:33 <narain> ah, i see why it's called an eliminator
10:09:34 <quicksilver> narain: generic eliminators have one paramter per constructor
10:09:46 <quicksilver> narain: they 'eliminate' any value of that type uniformly
10:09:54 <narain> right
10:09:59 <quicksilver> narain: ever studied symbolic logic?
10:10:03 <ski> fold
10:10:08 <narain> yes
10:10:15 <quicksilver> narain: 'either' is 'or-elimination'
10:10:16 <narain> i see the connection
10:10:40 <narain> hey, that's curry-howard isomorphism right there
10:10:46 * quicksilver nods
10:10:46 <narain> cool
10:11:03 <ski> @djinn (a -> c) -> (b -> c) -> Either a b -> c
10:11:03 <lambdabot> f a b c =
10:11:04 <lambdabot>     case c of
10:11:04 <lambdabot>     Left d -> a d
10:11:04 <lambdabot>     Right e -> b e
10:11:33 <narain> ?hoogle a -> a -> Bool -> a
10:11:34 <lambdabot> No matches, try a more general search
10:12:02 <quicksilver> in a manner of speaking , it's "if"
10:12:06 <narain> i've often wanted that sort of thing for Bools
10:12:10 <quicksilver> but if has non-standard syntax
10:12:12 <glguy> > sum . map fromEnum $ [True,False,True]
10:12:13 <lambdabot>  2
10:12:15 <narain> yes i end up doing if instead
10:12:16 <quicksilver> (useful, but nonstandard)
10:12:47 <quicksilver> @type let cond x y b = if b then y else x in cond
10:12:49 <lambdabot> forall t. t -> t -> Bool -> t
10:13:21 <quicksilver> @djinn a -> a -> Bool -> a
10:13:22 <lambdabot> f a b c =
10:13:22 <lambdabot>     case c of
10:13:22 <lambdabot>     False -> b
10:13:22 <lambdabot>     True -> a
10:13:26 <quicksilver> :)
10:13:41 <kuribas> > length $ filter id [True, False, True]
10:13:42 <lambdabot>  2
10:13:45 <narain> huh. i didn't expect djinn to come up with that
10:13:56 <glguy> kuribas: I already used that in the scrollback :-p
10:13:58 <quicksilver> it's a bit weird really
10:14:08 <quicksilver> not sure why djinn didn't just say f a b c = a
10:14:12 <narain> i thought it would just ignore one argument, that's be easier
10:14:16 <quicksilver> that's what I would have said, in theorem proving mode :)
10:14:21 <narain> :)
10:14:36 <glguy> ?djinn a -> a -> a -> Bool -> a
10:14:36 <lambdabot> f _ a b c =
10:14:36 <lambdabot>     case c of
10:14:36 <lambdabot>     False -> b
10:14:36 <lambdabot>     True -> a
10:14:41 <quicksilver> make djinn is a relevance theorem prover, or something
10:14:45 <narain> ?djinn (a -> a) -> Integer -> a -> a
10:14:45 <lambdabot> f a _ b = a b
10:15:04 <narain> instead of, say, repeating the function n times
10:15:08 <ski> quicksilver : augustss_ tried to make it as relevant as possible (or at least a bit relevant), iirc
10:15:15 <quicksilver> ski: *nod*
10:15:31 <narain> cool
10:15:33 <quicksilver> ski: it would appear to be search for 'maximally relevant' over some relevance criterion
10:15:41 <narain> i haven't the slightest idea how it really works
10:15:55 <ski> something like Prolog, i assume
10:16:14 <ski> (with some more complications)
10:17:26 <syntaxfree> jesii. Lispers are such snobs.
10:17:43 <merus> Not all lispers are snobs :'(
10:17:59 <syntaxfree> I mean, you should see what just happened at #lisp
10:18:22 <syntaxfree> I went and asked if there was a commercial Lisp environment for less money than LispWorks.
10:18:41 <merus> What's a jesii?
10:19:12 <syntaxfree> http://uncyclopedia.org/wiki/Jesii
10:19:12 <lambdabot> Title: Jesii - Uncyclopedia, the content-free encyclopedia
10:19:44 <merus> Oh.
10:20:21 <syntaxfree> I mean, it's not like they had strong typing or anything ; )
10:20:37 <merus> Heh.
10:20:56 * therp is definately a Lisper, and definately a snob :)
10:21:25 <therp> but the channel operators of #lisp are plain idiots. I used to hang out there, until I found #haskell.
10:23:05 <syntaxfree> I mean, I'm a snob, but I don't bite.
10:24:37 <zbrown> hrm, how would i use darcs to get the source for cabal-install
10:25:39 <zarvok> @where cabal-install
10:25:39 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
10:26:38 <syntaxfree> to add insult to injury, the free crippled version of lispworks won't mount on OS X.
10:26:41 <zarvok> looks like:  darcs get http://darcs.haskell.org/packages/Cabal/
10:26:44 <lambdabot> Title: Index of /packages/Cabal
10:26:50 <syntaxfree> GHC really needs a pretty IDE.
10:27:05 <glguy> visual studio 2k5? :)
10:27:19 <zarvok> emacs isn't a pretty IDE?
10:27:28 <syntaxfree> glguy: I'm on a Mac.
10:27:34 <zbrown> Emacs isn't an editor, its an OS ;).
10:27:35 <syntaxfree> and EclipseFP doesn't  work!
10:27:38 <glguy> syntaxfree: there is an xcode plugin
10:27:45 <syntaxfree> I never understood xcode.
10:28:04 <syntaxfree> eclipse looked kinda like VB4 without the dialog box editor, but xcode just confuses the heck out of me.
10:30:00 <quicksilver> emacs is certainly the best bet for now
10:30:13 <quicksilver> the problem with good IDEs is that they are really really terribly bad editors
10:30:33 <Saizan> is unsafePerformIO (readFile "foo") safe if noone writes on foo?
10:30:41 <LoganCapaldo> I see no reason why you couldn't stick a good editor in a good ide
10:30:46 <syntaxfree> ah, emacs is just ugly.
10:30:53 <LoganCapaldo> if that is indeed the problem
10:30:54 <Eelis> i wish emacs had proper word-wrapping
10:31:20 <vim_for_life> proper word-wrapping in vim is trivial.
10:31:34 <Eelis> i don't think vim has proper word wrapping either (for my definition of "proper")
10:31:42 <yip> what about shim?
10:31:42 <Eelis> (which is http://www.xs4all.nl/~weegen/eelis/word-wrap.png)
10:32:02 <merus> 404
10:32:11 <merus> oh, wait nvm
10:32:20 <LoganCapaldo> word wrapping is only a concern for people with small monitors or people who want print outs ;) As far as printouts go, feed it thru latex or something
10:32:23 <LoganCapaldo> :)
10:32:27 <vim_for_life> what is this xs4all.nl domain that so many websites use?
10:32:35 <Eelis> just some dutch provider
10:33:10 <quicksilver> LoganCapaldo: I don't know why, but they don't ;)
10:33:25 <yip> EIGEN SERVER
10:33:50 * merus 's monitor is 800x600 :( :(
10:33:52 <vim_for_life> Eelis: free?
10:34:00 <Eelis> vim_for_life: no
10:34:03 <kc5tja> Eigen makes anything sound like a bad-@$$ metal rock band.
10:35:18 <Eelis> LoganCapaldo: one man's "small monitor" is another man's "big monitor", so that attitude doesn't scale
10:35:21 <quicksilver> Eelis: http://www.emacswiki.org/cgi-bin/wiki/LongLines
10:35:23 <lambdabot> Title: EmacsWiki: LongLines
10:35:48 <LoganCapaldo> Eelis: Of course it doesn't scale. :)
10:35:51 <Eelis> quicksilver: i think i tried that one. if i remember correctly it doesn't preserve indentation
10:36:13 <vim_for_life> gah. I hate how badly QA-ed community projects are.
10:36:25 <vim_for_life> Haskell mode for Xcode promises that there's a .xcode file inside you can build.
10:36:28 <vim_for_life> But.. there isn't!
10:36:37 <vim_for_life> Just like the FP plugin for Eclipse won't build.
10:36:38 <vim_for_life> Grrrr.
10:37:18 <dcnstrct> Haskell mode for TextMate aint too shabby
10:37:32 <vim_for_life> Help!
10:37:37 <vim_for_life> who uses Xcode here?
10:37:49 <LoganCapaldo> All the things I like about editors are mostly useless with haskell
10:37:50 <yip> best is to try to keep all lines in your code less then 80 chars, then you don't need word wrap
10:38:00 <LoganCapaldo> Its not like you can auto indent haskell code :)
10:38:05 <vim_for_life> yip: what if you're writing paragraphs?
10:38:12 <glguy> LoganCapaldo: except that you can
10:38:16 <glguy> LoganCapaldo: but other than that ;)
10:38:17 <yip> vim_for_life: then use a word processor :)
10:38:23 <Eelis> yip: why compromise if simple technology can solve the problem entirely?
10:38:41 <LoganCapaldo> glguy: How? Where is this psychic editor you are using, and how come I don't have a copy? :)
10:38:47 <vim_for_life> yip: but I want to write latex and I want version control.
10:38:48 <yip> Eelis: long code lines are bad style. they are very hard to read and digest
10:38:50 <glguy> LoganCapaldo: you haven't installed emacs yet?
10:39:01 <Eelis> yip: there's more than just code in source files :) (think comments)
10:39:39 <yip> Eelis: this is why i don't write a lot of comments :P
10:39:54 <yip> vim_for_life: i imagine that vim works pretty well for that
10:39:55 <LoganCapaldo> glguy: Lemem rephrase. How does it know when to stop indenting? :)
10:39:56 <Eelis> yip: i'd rather not use an editor that discourages me from writing comments ;)
10:40:02 <quicksilver> yip: actually, to be fair, long code lines would not be hard to read at all if editors could wrap sensibly :)
10:40:13 <vim_for_life> @tell humasect hey, did you write the Haskell xcode plugin?
10:40:13 <lambdabot> Consider it noted.
10:40:26 <vim_for_life> yip: well, yeah. But you were arguing word-wrap is useless. It isn't.
10:40:30 <glguy> LoganCapaldo: in Haskell-mode, when you press tab, it cycles through the levels of identation that it thinks are meaningful
10:40:33 <quicksilver> Eelis: I don't find writing commands to a hard-column width particularly hard. my editor will (hard-)wrap them for me happily enough.
10:40:42 <LoganCapaldo> Oh ok
10:40:43 <yip> vim_for_life: i'm saying for code it's not that important
10:40:50 <LoganCapaldo> that's not what I meant then :)
10:40:51 <vim_for_life> you code-centrist.
10:41:13 <Eelis> quicksilver: i consider that a complete conformist and needless compromise
10:41:16 <vim_for_life> @tell humasect there's no .Xcode file in the zip I downloaded! How should I build it?
10:41:16 <lambdabot> Consider it noted.
10:41:24 <vim_for_life> @seen humasect
10:41:24 <lambdabot> I saw humasect leaving #haskell 11d 8h 23m 59s ago, and .
10:41:32 <vim_for_life> bad, bad karma.
10:41:50 <glguy> LoganCapaldo: you'd rather signal the end of an indentation level with your ; and } key?
10:41:56 <glguy> LoganCapaldo: instead of your tab key?
10:42:15 <glguy> LoganCapaldo: or maybe in the case of Lisp with you ) key?
10:42:15 <LoganCapaldo> I wouldn't rather lets say
10:42:23 <glguy> your*
10:42:46 <LoganCapaldo> I tend to use auto indenting type features when I have a mess of poorly formatted code
10:42:58 <LoganCapaldo> since poorly formatted code won't compile its sort of a moot point
10:43:19 <glguy> LoganCapaldo: I disagree with that statemtn to a certain degree
10:43:20 * vim_for_life cries in desperation
10:43:26 <glguy> I've seen some pretty poorly formatted code
10:43:29 <glguy> that still compiled :)
10:43:30 <ptolomy> >pl \x -> (head x, length x)
10:43:46 <merus> Making whitespace relevant is the way to go :)
10:43:56 <glguy> ptolomy: liftM2 (,) head length
10:44:06 <glguy> and you want ?pl
10:44:07 <ptolomy> :)
10:44:10 <ptolomy> thanks.
10:44:12 <glguy> or
10:44:15 <glguy> head &&& length
10:44:28 <merus> ?type (&&&)
10:44:30 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:44:35 <glguy> :t head &&& length
10:44:38 <lambdabot> forall a. [a] -> (a, Int)
10:44:39 <ptolomy> ahh... that's what I was looking for.
10:44:56 * ptolomy knew it was something Arrow-ey.
10:45:07 <zbrown> hmmm anyone had issues with ghci-6.6 and using ctrl->D to get back to console?
10:45:18 <glguy> in windows?
10:45:19 <zbrown> when I use ctrl->D it just does a ^D
10:45:23 <zbrown> glguy: no, linux
10:46:44 <vim_for_life> I have ugly issues with ghci-6.6
10:46:50 <vim_for_life> backspace doesn't work.
10:46:52 <vim_for_life> let alone ctrl-d.
10:46:57 <zbrown> vim_for_life: same for me
10:47:01 <zbrown> i dont understand why
10:47:26 <glguy> it sounds more like your terminal emulator is broken if neither backspace nor ^D work
10:47:58 <LoganCapaldo> Is there a common thread?
10:48:04 <zbrown> glguy: would that dependent in build?
10:48:10 <vim_for_life> no problems with other programs.
10:48:10 <LoganCapaldo> Do they both use the same terminal emulator?
10:48:12 <zbrown> ghci-6.4.2 works
10:48:21 <zbrown> but ghci 6.6 doesn't
10:48:21 <vim_for_life> python has problems with arrow keys, but rlwrap fixes it.
10:48:24 <vim_for_life> zbrown: yes, same here.
10:48:32 <zbrown> vim_for_life: what terminal you using?
10:49:40 <vim_for_life> I'm on OS X.
10:50:27 <vim_for_life> so, um, both the standard Terminal.app *and* iTerm.
10:50:58 <glguy> how did you install ghc, it works fine on my powerbook
10:51:16 <vim_for_life> I compiled it. The standard binary was Tiger-only.
10:51:39 <glguy> zbrown: your os is outdated too?
10:51:57 <glguy> oh
10:51:58 <glguy> no
10:52:02 <glguy> you don't use os x
10:52:10 * glguy is bothered to scroll up
10:52:11 <zbrown> glguy: heh no, I use Mandriva 2007
10:52:13 <glguy> just*
10:52:40 <glguy> did you install it manually?
10:52:41 <zbrown> i compiled it with the typical way you would on linux
10:52:51 <zbrown> i did "./configure && make && sudo make install"
10:53:17 <zbrown> err well autoreconf first
10:53:28 <glguy> oh, so from darcs then?
10:53:36 <zbrown> umm no
10:53:48 <glguy> oh, I didn't remember needing that from the source tarball
10:53:50 <zbrown> well maybe?
10:54:17 <zbrown> http://haskell.org/ghc/download_ghc_66.html <-- under source distribution
10:54:18 <lambdabot> Title: GHC: Download version 6.6
10:54:25 <zbrown> that was what I used
10:56:58 <[dlh]> The "libreadline" included with Mac OS X is actually libedit. You need to install GNU readline and link against that.
10:57:36 <glguy> [dlh]: I imagine that macports does that step for you?
10:57:45 * glguy is aware that that wasn't a real questions
10:57:50 <glguy> question* :-/
10:58:18 <pejo> glguy, my ghci is installed from macports and uses readline atleast. But I had readline already for other reasons.
10:58:48 <glguy> I used macports and haven't had any issues, so I figured that that was related
10:58:50 <[dlh]> glguy: Yes, it appears the Portfile depends on port:readline
10:59:18 * glguy would have checked but doesn't have is laptop handy
11:00:13 <glguy> his! ... I'm not doing so hot at this "keyboard" thing.
11:01:39 <zbrown> How on earth do I get base-2.0 for hackage...?
11:02:00 <glguy> install ghc-6.6
11:02:05 <zbrown> ah hmmm
11:03:17 <zbrown> that didnt work... phooey
11:03:52 <zbrown> tried using the /usr/local/bin/runghc (should be 6.6) with regex-base-0.91 and it still complains about base 2.0
11:04:13 <JohnnyL> has haskell been used as a web language yet?
11:04:21 <glguy> !paste
11:04:21 <hpaste> Haskell paste bin: http://hpaste.org/
11:04:35 <quicksilver> JohnnyL: there are certain haskell things on the web...
11:04:45 <quicksilver> JohnnyL: HAppS is a framework
11:06:24 <ClaudiusMaximus> > show $ typeOf map -- wondering if typeOf can handle polymorphism
11:06:25 <lambdabot>  Add a type signature
11:06:54 <LoganCapaldo> I guess that answers that question
11:06:54 <zbrown> Bah!
11:07:03 <ClaudiusMaximus> yeah :|
11:07:23 <zbrown> ther's no 'make uninstall' for ghc 6.6
11:07:34 <JohnnyL> quicksilver, thanks.
11:07:40 <LoganCapaldo> > typeOf id
11:07:41 <lambdabot>  Add a type signature
11:07:56 <LoganCapaldo> > typeOf (id :: () -> ())
11:07:57 <lambdabot>  () -> ()
11:08:04 <xerox> > id :: () -> ()
11:08:05 <lambdabot>  <() -> ()>
11:08:18 <LoganCapaldo> where do I get that anyway?
11:08:20 <ski> > typeOf (id :: forall a. a -> a)
11:08:21 <lambdabot>  Parse error
11:08:29 <ClaudiusMaximus> @docs Data.Typeable
11:08:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
11:08:44 <LoganCapaldo> I hate ghci bugging out on me comlaining about functions not being instances of show
11:08:58 <LoganCapaldo> s/comlaining/complaining/g
11:10:04 <zbrown> bah!
11:10:12 <zbrown> i guess i just can't use missingh
11:11:11 <zbrown> seeing as all the regex-* needs base 2.0
11:17:27 <ClaudiusMaximus> does this work in the "not breaking horribly" way?   let x = "blah" in do { a <- newStablePtr x ; b <- newStablePtr x ; someMoreIOStuff ;  freeStablePtr a; freeStablePtr b }
11:18:12 <allbery_b> gtk2hs vs. ghci question:  is there a way to reset things such that I don;t have to exit and restart ghci to re-run a program?
11:18:35 <araujo> allbery_b, what do you mean?
11:19:23 <therp> allbery: I think GTK is broken with respect to this
11:19:25 <allbery_b> on linux, if I load a gtk2hs program into ghc and type :main, it runs
11:19:32 <araujo> ClaudiusMaximus, i can't see anything wrong .. though you might want to have the x declaration inside the do ?
11:19:38 <allbery_b> if I then type :main again I get a GThread reinitialized error and a coredump
11:20:10 <araujo> Interesting.
11:20:35 <araujo> allbery_b, i have always go with the usual compile way
11:21:09 <allbery_b> yes, but I'm prototyping something currently, switching between glade and xemacs and ghci
11:22:32 <yip> allbery_b: a while ago i ran gtk2hs programs through ghci with :main several times with no problem. maybe things have chanced since then in gtk2hs/ghc
11:22:33 <allbery_b> ghci seems ideal for this kind of prototyping, except that the GThread error means I have to keep exiting and restarting instead of merely reloading (if I changed the haskell source) and re-running
11:23:04 <allbery_b> and of course runhaskell doesn't currently work with this (known issue I recall dcoutts discussing here shortly after the new gtk2hs release)
11:23:49 <ClaudiusMaximus> araujo: thanks, the question was really me being n00bly confused by the wording on the FFI reference StablePtr section ;)
11:24:11 <yip> allbery_b: there was even a post about this kind of development at the gtk2hs website:
11:24:11 <yip> http://haskell.org/gtk2hs/archives/2005/11/10/getting-started-with-cairo/
11:24:13 <lambdabot> Title: Gtk2Hs  Blog Archive  Getting started with Cairo, http://tinyurl.com/s9sfo
11:24:22 <araujo> ClaudiusMaximus, welcome
11:26:03 <allbery_b> far as I can see that only works with cairo
11:26:21 <allbery_b> oh well, will probably bite the bullet and make it runhaskell-friendly
11:26:34 <allbery_b> witht he sekrit initialization option
11:31:09 <JohnnyL> @users
11:31:10 <lambdabot> Maximum users seen in #haskell: 336, currently: 318 (94.6%), active: 48 (15.1%)
11:33:47 <glguy> lies!
11:34:13 <glguy> ?quote lie
11:34:13 <lambdabot> mwc says: I can only believe that Java is a conspiracy perpetrated by keyboard manufacturers
11:34:49 <glguy> ?quote tru
11:34:49 <lambdabot> lambdabot says: Occurs check: cannot construct the infinite type: a
11:34:58 <glguy> ?quote truth
11:34:59 <lambdabot> Masklinn says: truth is that lambdabot and dons recursively coded each other
11:36:10 <ray> hehe
11:36:23 <LoganCapaldo> So that's a _real_ use for mutual recursive modules ;)
11:36:37 <LoganCapaldo> s/mutual/mutually/
11:38:03 <icarroll> http://www.worldofescher.com/gallery/jpgs/P22.jpg
11:41:10 <vim_for_life> sigfpe should really be a measure of talent.
11:41:17 <vim_for_life> one milisigfpe.
11:42:45 <icarroll> Units based on physical artifacts are problematic. We need to find a fundamental process which produces a reproducible amount of talen, and base the sigfpe on that.
11:42:54 <icarroll> ^talent
11:44:27 <vim_for_life> sigfpe is already real I'm afraid.
11:45:01 <icarroll> That's ok. We'll just redefine him in terms of the new process.
11:46:41 <vim_for_life> sigfpe is like the itary.
11:46:45 <vim_for_life> you do know the itary, right?
11:47:32 <vim_for_life> one Itary is one ceiling measure of intelligence. God, if there's one, clocks at one itary.
11:47:47 <vim_for_life> The great prophets and geniuses clock at maybe one decitary.
11:47:54 <ski> what if there's two ?
11:48:03 <vim_for_life> The ordinary people are usually at centitary.
11:48:14 <vim_for_life> The really really stupid people are military.
11:48:27 <psi> :)
11:48:28 <icarroll> :)
11:56:25 <ed1t> is there any IDE for haskell or an plugin for eclipse?
11:57:06 <CosmicRay> ed1t: I believe there is haskell support in eclipse, vim, emacs, and ms visual studio
11:57:07 <bos31337> yes.
11:57:14 <dcnstrct> and TextMate
11:57:26 <dcnstrct> Jedit
11:57:36 <bos31337> @where eclipsefp
11:57:37 <lambdabot> I know nothing about eclipsefp.
11:57:48 <bos31337> @where+ eclipsefp http://eclipsefp.sourceforge.net/
11:57:49 <lambdabot> Done.
11:58:48 * CosmicRay brings the sequence back up
11:58:54 <CosmicRay> with its spiffy new drupal version
11:59:36 <bos> CosmicRay: sequence is great. thanks for running it.
12:00:00 <CosmicRay> thanks bos, and also thanks to dons for managing a lot of it these days
12:00:21 <bos> nice to see you contributing to mercurial, btw.
12:01:06 <CosmicRay> bos: thanks.  I tend to work on anything that I think would be useful.  are you a hg developer?
12:02:01 <bos> i was. alas, some mean people lawyered at me, and i am not right now.
12:02:08 <CosmicRay> ugh.
12:02:15 <CosmicRay> corporate anti-open-source policy?
12:02:28 <bos> no, a revision control vendor.
12:02:39 <CosmicRay> oh.  larry?
12:02:51 <bos> funny how you came to that conclusion.
12:02:57 <CosmicRay> hehe
12:03:43 * CosmicRay knows several people that have had run-ins with him
12:04:12 <glguy> people that used bitkeeper?
12:04:18 <mbishop> happy pi-day!
12:04:38 <shapr> mbishop: Is it 1:59 ?
12:04:42 <bos> still, at least the legal beagles gave me a reason to come up for air and start haskell hacking again.
12:04:49 <glguy> > iterate (ap (+) sin) 3
12:04:50 <lambdabot>  [3.0,3.1411200080598674,3.1415926535721956,3.141592653589793,3.1415926535897...
12:05:21 <mbishop> shapr: nope, it's already 2:04pm :[
12:05:22 <icarroll> @hoogle ap
12:05:23 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
12:05:23 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
12:05:23 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
12:05:28 <shapr> mbishop: You missed it!
12:05:31 * mbishop nods
12:05:45 <shapr> Luckily, there's a pi day each year!
12:05:48 <Botje> :t ap (+) sin
12:05:50 <lambdabot> forall a. (Floating a) => a -> a
12:05:55 <mbishop> but I've got my pi shirt on so it
12:05:58 <mbishop> it's ok
12:05:59 <mbishop> :P
12:06:21 <ski> "mm, pie"
12:07:04 <shapr> ski: Trivs du med Weebl och Bob?
12:07:06 <glguy> ?unpl ap (+) sin
12:07:06 <lambdabot> ((+) >>= \ b -> sin >>= \ a -> return (b a))
12:07:09 <shapr> mbishop: That is good!
12:07:30 <ski> shapr : nej .. men min bror har terroriserat mig med dem ..
12:07:48 <glguy> terrorist!?
12:08:25 <ski> one might say so
12:08:38 <dmwit> > sin 3
12:08:39 <lambdabot>  0.1411200080598672
12:08:56 <glguy> > sin pi
12:08:57 <lambdabot>  1.2246063538223773e-16
12:09:15 <dmwit> So the terms go to zero as the input goes to pi... cute. =P
12:10:53 <UUStudent> hello all
12:11:04 <UUStudent> anyone in the mood for a question and hopefully an answer
12:11:12 <bos> just ask away.
12:11:18 <UUStudent> well im getting this error
12:11:28 <UUStudent> non-exhaustive errors in function calc
12:11:37 <UUStudent> eh
12:11:40 <UUStudent> errors = patterns
12:11:44 <bos> non-exhaustive patterns.
12:11:44 <UUStudent> non-exhaustive patterns
12:11:46 <UUStudent> yes
12:11:58 <UUStudent> but i dont know whats wrong with my function
12:12:00 <glguy> > until ((==pi).snd) (succ *** ap (+) sin) (0,1)
12:12:01 <lambdabot>  (5,3.141592653589793)
12:12:07 <Botje> #haskell.dut would've liked to help you, if you stayed there longer than 60 seconds
12:12:10 <encryptio> that means that your patterns aren't enough - a call to the function is "falling through" all of them
12:12:19 <UUStudent> ehm
12:12:29 <UUStudent> wait maybe i forgot to define it when it has an empty list...
12:12:30 <encryptio> or they're too specific.
12:12:31 <bos> UUStudent: the compiler is telling you that you have maybe 3 branches in your datatype, but your function only pattern pmatches against 2 of them. i.e. not all of them.
12:12:43 <ClaudiusMaximus> > let f [] = [] in f "abc"
12:12:44 <lambdabot>   Non-exhaustive patterns in function f
12:13:10 <UUStudent> ah that did the trick
12:13:16 <UUStudent> i just didnt define it for []
12:13:21 <UUStudent> i just started working with ghci
12:13:31 <UUStudent> didnt know what the error meant
12:13:33 <UUStudent> now i do
12:13:35 <UUStudent> thanks a bunch
12:13:39 <bos> ghci doesn't give very good error messages.
12:13:44 <glguy> *lies*
12:13:51 <bos> hugs is much better, but less usable for real programs.
12:14:13 <ClaudiusMaximus> i need -fglasgow-exts to compile one module in my project, are there any potential issues if i compile the others without -fglasgow-exts ?  relatedly, is there a more specific flag than that that lets me "deriving ( Typeable )" ?
12:14:23 <bos> all the folklore about "haskell produces huge error messages" is due to ghc giving you enormous wads of useless context.
12:14:49 <tuukkah> hugs says: Program error: pattern match failure: v1562 "abc"
12:15:17 <Igloo> bos: If you have concrete example of what you think is a bad error, then send them to glasgow-haskell-users@
12:15:37 <pejo> bos, more needs to be done on type error reporting. Tim Sweeney had the message from Hugs in his slides for the POPL'06 presentation. :-)
12:15:46 <bos> Igloo: just the sheer amount of output that gets printed, where a line number would most often be enough.
12:16:48 <bos> Igloo: i don't see any point in reporting this as a problem, since it's the same behaviour ghc has had for about 15 years :-)
12:16:55 <astrolabe> bos: is that really a problem?
12:17:24 <bos> astrolabe: yes, it makes it hard to find the problem in the torrent of output.
12:17:26 <Igloo> bos: Well, if you don't report it it'll be like that for another 15 years
12:17:36 <bos> Igloo: true.
12:17:39 <encryptio> bos: it's usually at the very top, first 5 or 10 lines
12:17:52 <Igloo> Of course, people might disagree in which case it'll never be "fixed", but you don't know until you try  :-)
12:17:59 <encryptio> nearly all the time, the rest is too much
12:18:08 <bos> i know where it is, but it's still hard to find, and scary to newbies.
12:18:33 <astrolabe> are there flags to control the amount produced?
12:18:42 <bos> and if you have two errors instead of one, you have to look through the output to see where one error ends and the next begins. etc.
12:19:24 <bos> it's by no means a fatal problem; it's just not terribly helpful.
12:20:00 <encryptio> i had a time once where there was a problem with "different numbers of arguments" - the types checked, everything was fine, but ghc wouldn't take it. f 0 = f 1 ; f x y z = ...
12:20:26 <bos> yeah, each case as to have the same arity.
12:20:38 <encryptio> that seems like a stupid limitation to me
12:21:13 <bos> i'd take that limitation over big redundant error messages :-)
12:21:55 <tuukkah> is that a haskell limitation or ghc limitation?
12:23:06 <bos> it's required by the language.
12:23:26 <bos> see section 4.4.3.1 of the report.
12:23:31 <Igloo> I believe it's because of things like   f x = undefined; f y z = 'a'
12:23:44 <encryptio> ah.
12:23:57 <Igloo> If you translate that to f x w = undefined; f y z = 'a' when it is different to what was originally written
12:24:15 <astrolabe>  > let {f 1 = id;f 2 a = a - 1} in f 1 2
12:24:19 <Igloo> e.g. f 'a' `seq` 1   is _|_ as written, but not as translated
12:24:54 <tuukkah> > let { f 0 = f 1 ; f x = \y z -> x+y+z } in f 0 4 5
12:24:55 <lambdabot>  10
12:25:11 <astrolabe> > let {f 1 = id;f 2 a = a - 1} in f 1 2
12:25:11 <lambdabot>  arity mismatch for 'f'
12:25:54 <tuukkah> > let { f 0 y z = f 1 y z; f x y z= x+y+z } in f 0 4 5
12:25:55 <lambdabot>  10
12:26:17 <encryptio> ^ that's what i did to work around it. seems clunky.
12:27:21 <bos> let f x y z | x `elt` [0,1] = blah | otherwise = bleable
12:27:41 <encryptio> :t elt
12:27:43 <lambdabot> Not in scope: `elt'
12:27:58 <tuukkah> :t elem
12:28:00 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:28:03 <bos> er, elem.
12:28:24 <tuukkah> @hoogle a -> [a] -> Bool
12:28:24 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
12:28:25 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
12:28:28 <encryptio> but that imposes an Eq constraint, which in that case would be a pain
12:28:36 <encryptio> my case
12:29:35 <tuukkah> could you somehow combine f' and f of different arities nicely
12:29:37 <glguy> :t elemBy
12:29:39 <lambdabot> Not in scope: `elemBy'
12:30:24 <glguy> encryptio: without the Eq constraint , how would you propose that it know which Bool to return?
12:30:36 <glguy> :t any
12:30:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:30:39 <encryptio> it wouldn't at all
12:30:55 <glguy> :t any . (==)
12:30:58 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:31:19 <tuukkah> you you pattern match on literals the literals always need to be in Eq, right?
12:31:35 <tuukkah> if you =)
12:31:42 <glguy> Strings are Eq and Num is Eq
12:32:07 <glguy> You can pattern match on a constructor without Eq
12:32:18 <encryptio> see, i was matching against a type constructor with a function as an argument
12:32:22 <encryptio> which is the problem
12:32:29 <glguy> encryptio: so you'd need any
12:32:40 <ClaudiusMaximus> > let elemBy p l = (dropWhile (not . p) l) /= [] in elemBy (== 4) [1..5]
12:32:41 <lambdabot>  True
12:32:41 <encryptio> but how do you define if two functions are the same?
12:32:54 <glguy> ClaudiusMaximus: elemBy = any
12:33:26 <glguy> ?src any
12:33:26 <lambdabot> any p =  or . map p
12:33:40 <ClaudiusMaximus> glguy: ok
12:33:50 <LoganCapaldo> > any == (or . map)
12:33:51 <lambdabot>  Couldn't match expected type `[Bool]'
12:34:00 <tuukkah> elemBy sounds like it should return a list or a maybe
12:34:03 <glguy> encryptio: let p This = True ; p That = False ; p TheOther = True in any p
12:34:04 <LoganCapaldo> > (any) == (or . map)
12:34:04 <lambdabot>  Couldn't match expected type `[Bool]'
12:34:14 <glguy> tuukkah: you mean filter?
12:34:19 <glguy> tuukkah: or find?
12:34:19 <LoganCapaldo> > (==) any (or . map)
12:34:20 <lambdabot>  Couldn't match expected type `[Bool]'
12:34:35 <encryptio> glguy: that looks messier than the "use extra useless arguments" solution
12:34:35 <tuukkah> :t find
12:34:37 <LoganCapaldo> > ((==) any) (or . map)
12:34:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:34:38 <lambdabot>  Couldn't match expected type `[Bool]'
12:34:55 <tuukkah> glguy, find :-)
12:34:55 <LoganCapaldo> I'm not happy with this type error
12:35:06 <Codex_> you cannot really compare functions.
12:35:07 <LoganCapaldo> I want a different type error dagnabbit
12:35:13 <ClaudiusMaximus> @scheck any == or . map
12:35:14 <lambdabot> Couldn't match expected type `[Bool]'
12:35:38 <glguy> any = (or . ) . map
12:36:10 <ClaudiusMaximus> @scheck any == (or . ) . map
12:36:11 <lambdabot>       add an instance declaration for (Eq ((a -> Bool) -> [a] -> Bool))
12:36:11 <lambdabot>     I...
12:36:15 <LoganCapaldo> yay
12:36:22 <LoganCapaldo> thats the type error I wanted
12:36:23 <glguy> ClaudiusMaximus: what are you *doing* :)
12:37:07 <glguy> ?check (\p xs -> any p xs == or (map p xs)) :: (Int -> Bool) -> [Int] -> Bool
12:37:09 <lambdabot>  OK, passed 500 tests.
12:37:14 <ClaudiusMaximus> glguy: waiting until my caffeine buzz settles down and i can code on my projects to any degree of proficiency ;)
12:37:58 <opqdonut> 8)
12:38:00 <glguy> ?check (\p -> liftM2 (==) (any p) (or . map p)) :: (Int -> Bool) -> [Int] -> Bool
12:38:01 <lambdabot>  OK, passed 500 tests.
12:38:22 <bringert> Lemmih: is this your most up-to-date version of the fastcgi package: http://darcs.haskell.org/~lemmih/ghc6.6/haskell-fastcgi/ ?
12:38:23 <lambdabot> Title: Index of /~lemmih/ghc6.6/haskell-fastcgi
12:38:43 <glguy> ?check (liftM2 (liftM2 (==)) any ((.) or . map)) :: (Int -> Bool) -> [Int] -> Bool
12:38:44 <lambdabot>  OK, passed 500 tests.
12:43:51 <Lemmih> bringert: Yes, I believe so.
12:44:28 <bringert> Lemmih: ok, thanks. I'm merging it into the main repo, to make runFastCGIConcurrent available to everyone
12:44:40 <bringert> it still won't work on Apache, but at least it will be there
12:51:20 <Lemmih> bringert: Great.
12:51:56 <bringert> Lemmih: I should move the repo to darcs.haskell.org, so that you can push to it too
12:52:33 <glguy> ?type \f g -> (. g) . f . g
12:52:35 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:52:38 <bringert> Lemmih: would it be ok if I removed the max number of threads parameter to funFastCGIConcurrent? runFastCGIConcurrent' would still have it.
12:53:01 <bringert> I just want to present as simple as possible an API to the new user
12:54:12 <Lemmih> bringert: Hm, okay.
12:54:41 <bringert> what shoudl the default value be? also, should there be a way to say "no limit"?
12:56:11 <glguy> ?type \f -> ap ((.).flip(.))(f.)
12:56:14 <lambdabot> forall c a b. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:56:30 <glguy> ?type ap ((.).flip(.)).(.)
12:56:33 <lambdabot> forall c a b. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:57:20 <glguy> ?pl \f g x y = g x `f` g y -- what does lambdabot come up with?
12:57:20 <lambdabot> (line 1, column 10):
12:57:21 <lambdabot> unexpected "="
12:57:21 <lambdabot> expecting pattern or "->"
12:57:28 <glguy> ?pl \f g x y -> g x `f` g y -- what does lambdabot come up with?
12:57:28 <lambdabot> join . ((flip . ((.) .)) .) . (.)
12:58:04 <glguy> > length "join . ((flip . ((.) .)) .) . (.)"
12:58:05 <lambdabot>  33
12:58:07 <Lemmih> bringert: There probably should. I used the repository for performance testing so it's somewhat messy.
12:58:22 <glguy> > length "ap ((.) . flip (.)) (f .)"
12:58:23 <lambdabot>  25
12:58:25 <Lemmih> bringert: I'm using fastcgi quite a lot so I wouldn't mind cleaning it up.
12:58:30 * glguy wins by 8 chars
12:58:36 <Botje> ?pl g f x y -> g x `f` g y
12:58:36 <lambdabot> (line 1, column 9):
12:58:36 <lambdabot> unexpected ">" or "-"
12:58:36 <lambdabot> expecting variable, "(", operator or end of input
12:58:37 <glguy> oops!
12:58:41 <Botje> ?pl \g f x y -> g x `f` g y
12:58:42 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
12:58:43 <glguy> > length "ap ((.) . flip (.)) . (.)"
12:58:44 <lambdabot>  25
12:58:52 * shapr sings loudly
12:59:13 <glguy> manually pl'ing that makes for a pretty whiteboard
12:59:51 <glguy> no one here knows haskell, so it just looks like I'm hard at work ;)
13:01:26 <bringert> Lemmih: ok, great. I'll put my merged version on darcs.haskell.org, and write you as maintainer in the cabal file
13:04:42 <glguy> ?type \f g -> (.)((.f)(.g))g
13:04:44 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:13:53 <shapr> Hey, lemmih and I were just talking about how to distribute a darcs repo over bittorrent.
13:14:57 <shapr> It sounds like a good approach to me, because the list of patches that make up a tag or checkpoint do not change.
13:15:21 <bos> but darcs repos tend to be very small.
13:15:30 <bos> and bittorrent is terrible for small files.
13:16:00 <glguy> ?seen k5
13:16:01 <lambdabot> I haven't seen k5.
13:16:04 <glguy> ?seen kc5tja
13:16:05 <lambdabot> kc5tja is in #darcs and #haskell. I last heard kc5tja speak 2h 42m ago.
13:16:16 <sjanssen> you could certainly make a .tar.bz2 of the full ghc tree (with _darcs and all that), and encourage users to use that rather than darcs get
13:16:23 <bos> my complete ghc tree is 155M, and that's on the small side for bittorrent. and it's not a single repo.
13:17:46 <shapr> bos: Well, depends on the chunksize.
13:18:45 <bos> also, bittorrent is bad at files that aren't popular.
13:19:06 <bos> if you have a one-person swarm, it's much slower than a straight download.
13:20:14 <sjanssen> there are also users on networks that block/heavily traffic shape bittorrent
13:21:13 * SamB thinks darcs ought to support automating the tarball approach
13:21:58 <sjanssen> SamB: yeah, it'd be nice to have something like darcs tag/optimize on steroids
13:22:20 <sjanssen> so darcs get --partial automatically grabs the huge tarball when possible
13:22:29 <SamB> sjanssen: it wouldn't be "something like"
13:22:34 <SamB> it would *be* that
13:22:53 <sjanssen> darcs optimize --on-steroids
13:24:18 <sjanssen> it isn't even --partial specific, I guess
13:25:00 <shapr> Well...
13:25:05 <SamB> not really.
13:25:38 <shapr> One thing we just discussed was that each darcs repo tag would have all the patches since the last tag, and a torrent for the previous tag.
13:25:57 <SamB> I suppose you could have tarballs of the sourcefiles at checkpoints, and tarballs of the patches before checkpoints...
13:25:58 <sjanssen> I recall sorear claiming he managed to get the entire ghc history to 20mb or so
13:32:37 <shapr> Ok, what were the collected possible problems with serving darcs across bittorrent?
13:32:47 <shapr> bt is fine with small files if you decrease the chunk size.
13:33:31 <shapr> one person swarm is a good point, but I'm mostly thinking about ways to decrease bandwidth load on darcs.haskell.org and www.haskell.org, so I'd be okay with that.
13:34:06 <shapr> Is there currently any way to turn a --partial repo into a full repo?
13:34:17 <sjanssen> shapr: I don't think so
13:35:00 <sjanssen> shapr: does Galois have trouble with the bandwidth on d.h.o?
13:35:11 <sjanssen> I'm curious what sort of bandwidth it takes
13:35:22 <Guest25023> it was half-down yesterday
13:35:43 <shapr> From the rumors I've heard, darcs uses significantly more than 50% of Galois' total bandwidth.
13:35:49 <bos> wow.
13:36:02 <shapr> I may be misremembering though...
13:36:06 <sjanssen> it'd be very interesting to see some hard numbers
13:36:16 <shapr> But darcs does encourage checking out repos again when one repo gets weird.
13:36:33 <shapr> At least, that's how I've been fixing it since darcs 0.6 or so.
13:36:49 <sjanssen> shapr: yeah, I'm guilty of that
13:37:14 <shapr> And in cases like that, you would be able to pull most of the patches from your broken repo.
13:37:26 <shapr> The patch files won't change.
13:38:00 * zbrown beats ghci-6.6
13:38:31 <sjanssen> I've been using darcs get on local repositories quite often while hacking on xmonad
13:39:05 <sjanssen> I've heard that you can save disk space too, because darcs uses hard links instead of copying the data
13:39:07 <shapr> Anyway, I think it's worthwhile. Especially when I think forward to Fermat's Last Margin :-)
13:39:15 <shapr> Yeah, hard links are in there.
13:39:27 <shapr> You only need to specify the directory to hard link to.
13:40:30 <shapr> I think the downside of hardlinks is that if you delete one hardlinked file, you also delete anything else that's hardlinked there.
13:40:58 <doserj> shapr: ?
13:41:05 <sjanssen> shapr: you're thinking of symbolic links, I think
13:41:12 <Saizan> aren't hardlink like strong pointers? if there's one you keep the file
13:41:17 <shapr> Oh, maybe so.
13:41:32 <mauke> hardlinks are filenames
13:41:34 <doserj> deleting a hardlink just decreases the refcount
13:41:44 <thedward> shapr: you can't have hardlinked directories (or, rather the tools try very hard not to let you)
13:41:57 <mauke> yeah, that creates reference loops in the filesystem
13:42:20 <thedward> cp -lr will create new directories, but hardlinks for all the files
13:42:24 <sjanssen> we need a real garbage collector in the filesystem!
13:42:48 <mauke> ls -R .  # infinite loop
13:43:08 <sethk> mauke, circular symlink?
13:44:23 <kuribas> Which is the most hackable or understandable haskell compiler?
13:44:59 <sjanssen> kuribas: probably yhc
13:45:07 <shapr> kuribas: GHC is really easy to understand if you don't stare at the typechecking code too much.
13:45:28 <chessguy> @quote squit
13:45:28 <lambdabot> No quotes match. Where did you learn to type?
13:45:30 <chessguy> @quote squint
13:45:31 <lambdabot> No quotes match. That's something I cannot allow to happen.
13:45:34 <bringert> Lemmih: http://darcs.haskell.org/fastcgi/
13:45:36 <lambdabot> Title: Index of /fastcgi
13:45:38 <bringert> Lemmih: go nuts
13:45:53 <shapr> @quote squ
13:45:54 <lambdabot> edwinb says: I've just walked past a poster advertising a gig by a band called "The Awkward Squad". I assume this means they provide output, play concurrently, and people take exception to them.
13:45:56 <sethk> kuribas, I haven't really been inside any of them (other than ghc)
13:46:37 <bringert> Lemmih: I didn't change the runFastCGIConcurrent interface, but I think that it would be nice to do it
13:47:18 <kuribas> shapr: I see :)
13:47:54 <Batterseapower> hi.. would anyone be as kind to point out what I'm doing wrong at http://hpaste.org/977 ?
13:49:10 <kuribas> Oh, there is Language.Haskell.Parser, etc...
13:49:20 <bringert> Batterseapower: have you tried doing what the error message suggests?
13:50:08 <Batterseapower> i'm a bit confused about what it actually means, tbh
13:50:29 <Batterseapower> my eyes glaze over at "instance declaration superclass context"
13:50:46 <sjanssen> Batterseapower: you wrote "class (Monad m) => MonadTI m", the (Monad m) part is the superclass context
13:51:36 <Batterseapower> i see
13:51:43 <sjanssen> Batterseapower: you need to tell that (mt m) is an instance of Monad in your troublesome instance
13:52:16 <Batterseapower> thanks, that makes sense
13:52:29 <Batterseapower> now i have something about undecidable instances :)
13:52:34 <chessguy> glad it made sense to someone...
13:52:37 <bringert> -fallow-undecidable-instances
13:52:41 <sjanssen> Batterseapower: what you've written is known as an "overlapping instance"
13:52:47 <chessguy> it makes my head hurt
13:53:01 <Batterseapower> i see, why is it considered overlapping?
13:53:02 <chessguy> @quote explode
13:53:03 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
13:53:26 <chessguy> @quote lap
13:53:26 <lambdabot> xerox says: * xerox gets sucked in a vortex of -fdisallow-overlapping-explanations
13:53:27 <Batterseapower> it dosent obviously conflict with the MonadTI TI instance
13:54:01 <SamB> is MonadTI for a calculator emulator?
13:54:05 <sjanssen> Batterseapower: it is potentially overlapping
13:54:23 <Batterseapower> samB : :P TI = type inference, in this case
13:54:48 <Batterseapower> sjanssen: if i added a further instance, do you mean?
13:54:57 <sjanssen> Batterseapower: correct
13:55:24 <Batterseapower> huh, interesting.. it still warns me despite the fact that it can statically deterimine there are no such instances?
13:55:33 <Batterseapower> or is that because of seperate compilation
13:55:36 <SamB> Batterseapower: it can't!
13:55:58 <SamB> I almost wish there were "not instance" declarations
13:56:06 <Batterseapower> samb: really? i only wrote 2 in this file though :)
13:56:23 <sjanssen> Batterseapower: it is related to separate compiliation.  If you offer this code as a library, any old user could come in and write an overlapping instance
13:56:32 <Batterseapower> right, i see
13:56:39 <Batterseapower> so if i dont export TI this error will vanish
13:56:46 <Batterseapower> MonadTI*
13:56:52 <sjanssen> Batterseapower: no, the error will stick around
13:57:05 <sjanssen> ghc isn't that clever
13:57:05 <Batterseapower> doh, why is that?
13:57:08 <SamB> yeah, I was going to say, the compiler is not supposed to be that smart
13:57:30 <Batterseapower> actually I just looked and i hadn't exported it anyway
13:57:32 <Batterseapower> hum
13:57:42 <Batterseapower> is there a reason why it should limit cleverness?
13:58:04 <sjanssen> and in reality, you wouldn't want a compiler to do that.  Do you want your program to stop compiling because you add a class to the export list?
13:58:41 <Batterseapower> i agree it could be confusing :-)
13:59:05 <Batterseapower> ok, thanks a lot guys! that really helped..
13:59:08 <sjanssen> and there might even be times that the overlap checking would be undecidable -- which is a very nasty thing for a typechecker
13:59:59 <Batterseapower> ouch, ok..
14:00:06 <Batterseapower> i'll just slap this flag in for now then
14:00:40 <sjanssen> your other option is to write out instances of MonadTI for each transformer you plan to use
14:00:57 <Batterseapower> i saw that that was what MTL had done..
14:01:21 <Batterseapower> now i know why, i guess :(
14:01:26 <sjanssen> it kinda sucks, because you have to write O(n^2) instances
14:01:33 <Cale> Hmm, reddit should assign separate scores to things by subreddit, even when they're crossposted. Completely inane things can end up with good scores on the programming subreddit just because they were crossposted to the main page.
14:02:29 <Batterseapower> out of interest, what happens if i write an instance which actually overlaps somewhere else?
14:02:41 <Batterseapower> do i get an error message or do Bad Things just start to happen?
14:04:11 <sjanssen> Batterseapower: ghc has some heuristic to chose the right one
14:04:50 <Batterseapower> ah, interesting
14:04:52 <sjanssen> in short: a Bad Thing may or may not happen
14:04:55 <Batterseapower> thanks again for your help :-)
14:06:47 <glguy> It makes me smile that a single remote hole to an oft unused portion of OpenBSD became headline news
14:07:13 <SamB> doesn't it usually make you -fenable-incoherent-instances if you do that?
14:07:44 <SamB> glguy: are you an OpenBSD user, then?
14:07:48 <glguy> yeah :-D
14:07:48 <sjanssen> glguy: at least the headline doesn't say "OpenBSD is dying" :)
14:08:14 <glguy> yeah, the posters are too concerned with jokes like "Vista sucks"
14:08:21 <SamB> yes, it certainly speaks volumes about OpenBSD security ;-)
14:13:19 <glguy> I'm just surprised that the average digg user knows what OpenBSD is
14:13:48 <glguy> I'd bet a bunch of them had to look up what the common troll statements were before they could post
14:14:50 <Saizan> like there's a database for trolls' comments sorted by category?
14:14:54 <Saizan> troll.google.com?
14:15:00 <resiak> wikipedia.com, surely
14:15:31 <Cale> Actually, it was the thing about ESR that I was more annoyed with.
14:15:48 <glguy> he wrote fetchmail?
14:16:18 <Cale> His newsgroup post about Paul Graham is #2 on programming reddit.
14:16:31 <kc5tja> back
14:16:45 <glguy> why do people know who he is?
14:17:04 <Cale> Because he's a blow-hard.
14:17:08 <dmwit> Because he destroyed the jargon file?
14:18:31 <dmead> eric raymond?
14:18:35 <dmead> he lives in my town
14:18:48 <dmead> and yes
14:18:52 <dmead> a blow hard
14:19:00 <glguy> so he's just a well known asshole?
14:19:08 <dmead> well he has written some good philosophy
14:19:13 <merus> I dunno if blowhards are isomorphic to assholes.
14:19:16 <dmead> other than that he seems to be a bit of a wackjob
14:19:18 <bos31337> good philosophy?
14:19:22 <kc5tja> I enjoyed reading Cathedral and Bazaar.
14:19:23 <dmead> yea
14:19:26 <merus> I dunno if I'd call what he writes philosophy
14:19:31 <dmead> the cathedral and the bazaar
14:19:36 <araujo> any mad can write good philosophy nowadays
14:19:39 <mbishop> GUNS ARE GOOD LOL
14:19:40 <dmead> well i haven't read it
14:19:41 <bos> that essay is a load of poo.
14:19:44 <dmead> haha yea
14:19:46 <kc5tja> But, his written work isn't necessarily equivalent to his personal behavior, since he'll have had time to refine it and polish it.
14:19:46 <araujo> Cale, what's the link?
14:20:01 * chessguy tentatively adds programming.reddit.com to his google RSS module, hoping it doesn't completely fill to overflowing within 2 seconds
14:20:10 <Cale> araujo: http://programming.reddit.com/info/1a5pk/comments
14:20:11 <lambdabot> Title: Eric S Raymond on Paul Graham: Yo. Don&#39;t you be dissin&#39; my homeboy Paul. ...
14:20:16 <kc5tja> bos: I'm not so sure about that; the whole FOSS industry is based on it.
14:20:20 <Eelis> what's a "blow hard" ?
14:20:21 <araujo> Thanks Cale
14:20:23 <bos> kc5tja: no it isn't.
14:20:31 <dmead> bos: he has alot of followers from that
14:20:40 <sjanssen> chessguy: it's generally reasonable, just be prepared to scroll quickly through the stupid ones
14:20:42 <dmead> but then he started spouting shit like he's written part of the linux kernel
14:20:45 <bos> sure, george bush has a lot of followers too.
14:20:48 <dmead> and other asssorted nutty things
14:20:54 <SamB> dmead: when did he say that?
14:21:04 <dmead> SamB: like 2002 or 2003
14:21:08 <dmead> it was on slashdot alot
14:21:18 * glguy frowns at what he started
14:21:21 <dmead> hah
14:21:30 <bos> meanwhile, bunnies and lazy evaluation are nice.
14:21:35 <kc5tja> bos: Until I see evidence to the contrary, I won't believe it.
14:21:40 <merus> lazy evaluation is nice.
14:21:46 <dmead> yea he lives 5 blocks from my computer science building
14:21:49 * ddarius doesn't bother with things where he needs to skip the "stupid parts"
14:21:49 <Cale> http://geekz.co.uk/lovesraymond/archive/show-them-the-code -- this is a good summary for those people unfamiliar with ESR.
14:21:51 <lambdabot> Title: Everybody loves Eric Raymond  Show them the code
14:21:58 <dmead> and to my knowledge he's never participated in anything
14:22:11 <resiak> he participated in fetchmail!
14:22:15 <dmead> haha
14:22:36 <resiak> he also wrote fetchmailconf!
14:22:43 <dmead> woopdy doo
14:23:15 <araujo> "Ruby developers write that allowing calls without parenthese might after all be not so good idea and maybe later versions will require them... That stinks a bit"
14:23:24 <araujo> mmm,, didn't know that
14:24:05 <glguy> Ruby's syntax makes me smile, the kind of smile where you are just happy you don't have to deal with something
14:24:49 <nornagon> that parenthesis-lack is what makes ruby's funcall syntax nice
14:24:51 <dmead> isn't it just like python?
14:25:15 <bos> just like smalltalk.
14:25:26 <kc5tja> Ruby is nothing like Python syntax-wise.  Don't let those "def" blocks fool you.  :)
14:25:44 <araujo> Parentheses are over-rated
14:25:45 <kc5tja> I heard Ruby was pretty nice, but I'm still not a fan of its syntax.
14:25:47 <araujo> :-)
14:25:59 <mbishop> I like non-required parens idea like in ocaml/haskell, it's better than the forced parens idea, since you don't always need them, it seems a better default to NOT have them, and be able to use them if needed
14:26:10 * kc5tja wonders, if languages are becoming more and more and more like Smalltalk, why not just go back to Smalltalk?
14:26:12 <Nafai> I don't "get" Ruby.  People keep ranting about how "elegant" it is, but I don't see it.
14:26:17 <kc5tja> The language != the environment -- they CAN be split.
14:26:25 <bos> the problem with lack of parens is that you rapidly forget to use them in languages that require them :-)
14:26:35 <glguy> ruby just looks sloppy to me
14:26:40 <glguy> like they added a little as they went
14:26:41 <mbishop> bos: easier to just forget those languages :P
14:26:42 <bos> @users
14:26:42 <lambdabot> Maximum users seen in #haskell: 336, currently: 324 (96.4%), active: 60 (18.5%)
14:26:48 <glguy> without worrying bout consistency
14:27:28 <glguy> "what\nthe\nhell\n".to_a returns an array of the lines? how arbitrary is that?
14:27:43 <glguy> when you join that, it adds the \n back in??
14:27:50 <kc5tja> What is to_a?
14:27:59 <glguy> kc5tja: "to array"
14:28:01 <glguy> I guess
14:28:01 <sjanssen> glguy: you're composing a string with a function called to_a?
14:28:04 <kc5tja> (Obviously, I can google, but that shows you the sheer power of poorly named methods)
14:28:05 <mbishop> I think they took too much from perl and not enough lisp :)
14:28:12 <glguy> sjanssen: :)
14:28:14 <dmead> i've spent the last week back with java
14:28:18 <dmead> and it's already driving me mad
14:28:36 <dmead> \/
14:28:40 <dmead> =/
14:28:59 <kc5tja> dmead: Since I got hired, I've had to deal with Java.  :~(
14:29:12 <Nafai> Welcome to my world.
14:29:17 <merus> Java--
14:29:18 <dmead> : - <
14:29:20 * kc5tja hasn't even coded in Haskell for more than a man-week.  And, yet, I need Haskell swag.
14:29:23 <Nafai> Java + J2EE = not that much fun
14:29:25 <glguy> the tutorial webapplication itself is quite cool
14:29:32 <dmead> yea
14:29:35 <glguy> but actually working through the tutorial just gave me a list of things to hate
14:29:39 <dmead> i tried asking for help in #java
14:29:40 <dmead> and their like
14:29:46 <dmead> please write a 50 line test cast
14:29:49 <dmead> =/
14:30:05 <glguy> would be cool to have for haskell:
14:30:11 <glguy> http://tryruby.hobix.com/
14:30:13 <lambdabot> Title: try ruby! (in your browser)
14:30:22 <glguy> I know that there is a web interface to lambdabot
14:30:29 <glguy> this just goes one step further
14:30:32 <dmead> ahh
14:30:34 <kc5tja> dmead: Well, it's a reasonable request, and it's actually in your best interest to do so.  If it's in code, it 100% eliminates the "You're a n00b13!  /BAN!" problem that is all-too-prevalent on IRC help channels.
14:30:35 <dmead> yea i saw that
14:30:43 * kc5tja had that happen twice in #Debian a few years ago.  >:(
14:30:50 <dmead> =/
14:30:55 <dmead> hmm
14:30:57 <kc5tja> Haven't used Debian since.
14:31:02 <dmead> maybe you know my answer
14:31:18 <dmead> ever have to fish an object back out of a tabbed pane?
14:31:46 <kc5tja> dmead: Don't know what you're referring to, sorry.  THe Java code I deal with is all back-end server stuff.  No GUIs.  :(
14:31:52 <dmead> ahh
14:32:03 <kc5tja> However, can you be more precise in your problem?
14:32:08 <dmead> yea i'm writting a configuration tool for my co-ops application
14:32:10 <kc5tja> What do you mean by "fish out"?
14:32:26 <dmead> i've got a bunch of objects that extend jpanel
14:32:33 <dmead> and their added into a tabbed pane
14:32:49 <dmead> and at some point i've got to address their member functions
14:32:54 <dmead> but doing stuff like
14:33:06 <dmead> tabbedpane.getCompontentatIndex(int x)
14:33:18 <dmead> isn't working too well
14:33:44 <zbrown> well the only thing I got ruby to do in that interactive console was to print 'poop tits'
14:33:47 <zbrown> stupid thing
14:33:48 <Batterseapower> dmead: maybe you could keep references to the panels in the tab as member vars on the containing panel
14:34:18 <dmead> Batterseapower: yea i think so
14:34:37 <dmead> i also thought of adding a refrence to the ancestor when it's added in
14:34:46 <dmead> hehe
14:35:10 <kc5tja> dmead: At first glance, I'd have to agree with dmead too.  Make your dialog class so that it includes references to the objects of interest, so that you have ready and easy access to them.
14:35:27 <kc5tja> I don't know too much about the end-goal though.  :)
14:35:35 <dmead> ahh it's an xml editor
14:35:46 * kc5tja was thinking of writing a few Unix administration tools in Haskell, like a console-based user management system, and so forth.
14:36:02 <dmead> did you see dons examples?
14:36:13 <dmead> he wrote up a bunch of tools in haskell
14:36:17 <dmead> like cat and so forth
14:36:38 <kc5tja> dmead: I haven't seen those, no.
14:36:40 <glguy> dmead: I think you should use ""s around cat
14:36:58 <dmead> hehe
14:38:13 <dmead> ah
14:38:14 <dmead> here we go
14:38:15 <dmead> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/20
14:38:16 <lambdabot> Title: Haskell hacking
14:38:46 <dmead> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/18#ph-3
14:38:46 <lambdabot> Title: Haskell hacking
14:38:48 <dmead> that actually
14:39:46 <dmead> anyway
14:39:47 <dmead> break time
14:39:48 <dmead> bll!
14:39:59 * dmead is away: food
14:43:47 <fasta> Suppose I call a function foo from n locations in my program. Suppose the trace of the exception shows that foo indeed causes it. Now, how can I narrow those n locations to 1 (without writing a tool that does this myself)?
14:44:26 <dmwit> ?hoogle trace
14:44:26 <lambdabot> Debug.Trace.trace :: String -> a -> a
14:44:27 <lambdabot> Debug.Trace :: module
14:44:27 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
14:44:46 <fasta> dmwit: was that for me?
14:44:51 <dmwit> Dunno, never used it myself, but I've heard that can be useful.
14:44:58 <fasta> dmwit: It's irrelevant.
14:45:09 <fasta> dmwit: (Of course I am using trace. )
14:45:26 <dmwit> Can't you use a call to trace in front of every call to foo?
14:45:46 <fasta> dmwit: yes, and that amounts to finding all n locations in the program.
14:45:52 <fasta> dmwit: i.e. the tool I described.
14:45:53 <dmwit> Aha, I see.
14:46:39 <fasta> I think this problem only occurs with lazy programming languages.
14:47:09 <fasta> The essential problem is that you don't know what happened "last".
14:47:40 <dmwit> Yeah, no backtrace command. =(
14:48:20 <Cale> -sc
14:48:24 <Cale> -xc rather
14:48:45 <Cale> Compile with -prof -auto-all and run the program with +RTS -xc -RTS
14:48:57 <fasta> Cale: yes, and that only gives a list of things that got called last.
14:49:02 <fasta> Cale: names, no locations.
14:49:16 <fasta> Cale: unless there's a switch that does give locations....
14:49:33 <Cale> Don't you know where those functions are located in your code?
14:49:43 <bos> fasta: someone wrote a hacked version of trace that prints a backtrace. but i can't find a reference.
14:49:46 <Cale> I suppose you could use hasktags or something to find the,
14:49:48 <Cale> m*
14:49:48 <bos> it might have been dons who wrote it.
14:50:45 <fasta> Cale: actually, the problem is that a name is only unique when that function is only called once.
14:50:45 <Cale> or grep
14:50:55 <mbishop> Someone should develop a DrScheme clone for Haskell...or maybe just a haskell language file and stuff for DrScheme
14:50:58 <fasta> Cale: so, hasktags would return _multiple_ results.
14:51:07 <fasta> mbishop: does DrScheme do these things?
14:51:14 <mbishop> do what things?
14:51:37 * mbishop wasn't following the conversation
14:51:39 <fasta> mbishop: Given an exception draw a nice trace through the source code?
14:51:54 <fasta> mbishop: (for example)
14:52:03 <glguy> a trace through the source code doesn't really make sense in haskell... does it?
14:52:14 <mbishop> oh, yeah DrScheme will draw traces through the source, highlight the code block, etc
14:52:38 <mbishop> although I don't believe scheme has exceptions (at least, not in the standard)
14:52:53 <mbishop> (and not yet, apparently R6RS has some condition system)
14:53:27 <fasta> mbishop: Right, in DrScheme errors are more like calling car on a number.
14:53:31 <roconnor> @where DrHaskell
14:53:31 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
14:53:49 <mbishop> roconnor: not the same :(
14:53:54 <fasta> I believe that does something completely different
14:54:10 <fasta> The name is very inconveniently chosen.
14:54:46 <mbishop> fasta: well it's nice in DrScheme when you have to break (infinite loop, something just taking way too long), it shows you where it broke, what code it was executing, that kind of stuff
14:54:52 <mbishop> with neat little arrows and points
14:55:04 <fasta> mbishop: also for R5RS code?
14:55:14 <SamB> mbishop: what? the scheme people have heard of features now?
14:55:17 <mbishop> er, for any code?
14:55:23 <mbishop> SamB: shush troll :P
14:55:32 <fasta> mbishop: Lots of the tools worked only on teaching languages, IIRC
14:55:49 <mbishop> fasta: ah, well works fine for me, and I typically use "Really Big"
14:56:07 <fasta> mbishop: oh, ok. Cool.
14:56:17 <fasta> mbishop: do a screencast :)
14:56:26 <mbishop> I think there is already one heh
14:56:45 <fasta> I only saw a screencast of the DivaScheme thingie
15:05:10 <ray> hmm, i hate eric raymond
15:05:36 <ray> partly because he's stupid, but mostly because i have a hilight on 'raymond' (as it's my name) and people mentioning him set it off
15:07:25 <yip> does anyone respect esr nowadays?
15:08:07 <yip> i don't think he was ever very likeable, but from the slashdot vibes these days *nobody* seems to like the man
15:08:10 <Cale> *crickets chirping*
15:08:11 <glguy> when I asked earlier I got the impression that no one did, and everyone but me knew who he was :)
15:08:34 <emk> Is esr flaming someone again?
15:08:50 <glguy> that post pulled the macro lovers and haters *out of the woodwork*
15:09:14 <glguy> it was like watching two ant colonies battle it out
15:09:23 <emk> The old ESR in defense of Graham post?
15:11:35 <glguy> I should do an Ask Reddit: Are macros what you get when your language isn't powerful enough to express the ideas you want directly
15:11:41 <glguy> or something terribly inflamitory
15:11:44 <glguy> and see if it can compete
15:11:48 <glguy> with the esr reddit post
15:12:47 <kc5tja> Hahah :)
15:13:21 * kc5tja has realized a long time ago that macros are very much like normal subroutines insofar as using them.  Therefore, "subroutines ought to be enough for anyone."
15:13:37 <glguy> see, you could kick it off with the first comment
15:13:38 <glguy> !
15:13:43 <merus> hahahah
15:13:47 <merus> This is too much.
15:13:51 <kc5tja> Hehehe :)
15:13:51 <emk> glguy: Macros are terribly useful things, in my experience. But they're mostly good for implementing things you already understand well. Haskell's a bit different, because it tends to push you off in directions that you don't understand at all, but which might provide serious insight.
15:13:55 <merus> I'm going to burst my appendix laughing.
15:14:00 <glguy> whoa whoa whoa!
15:14:01 <sorear> hello.
15:14:05 <emk> merus: Pleased to be of service.
15:14:07 <emk> :-)
15:14:13 <kscaldef_> kc5tja: macros in what language?
15:14:14 <glguy> if you want to pursue this, please create a reddit post!
15:14:28 <kc5tja> Macros are just definitions, a means of extending the compiler itself with idiomatic expressions.
15:14:32 <kc5tja> kscaldef_: Does it matter?  :)
15:14:39 <sorear> wow, mg takes simplicity a bit too far...
15:14:56 * kc5tja neither likes nor dislikes macros; like subroutines, they're tools.  Use them wisely, and they kick butt.  Abuse them, and they'll suck eggs.
15:14:57 * emk wishes he understood Template Haskell better.
15:15:08 <kscaldef_> well, macros in C can be made almost like subroutines.  Just close enough to really phenomenally mess thing up when they aren't
15:15:19 <glguy> ...having kicked that off, glguy heads home
15:15:21 <bos> macros are like space suits, floating in a sea of nuclear waste?
15:15:22 <kc5tja> After all, Forth has "compiler" words which fundamentally extends the compiler proper.  I use them all the time. :)
15:15:22 * glguy &
15:16:00 <kc5tja> kscaldef_: I *NEVER* use macros in C like subroutines, at least not in code I write (I can't help other people's software).
15:17:53 <tuukkah> @pl \xs -> let (r, rs) = span (/= ' ') xs in (r, tail rs)
15:17:53 <lambdabot> (line 1, column 12):
15:17:54 <lambdabot> unexpected "("
15:17:54 <lambdabot> expecting natural, identifier or "in"
15:18:11 <emk> glguy: I have an unposted blog entry titled "When Monads are Better Than Lisp Macros", which should heat the discussion up a bit.
15:18:14 <ailndx> how do i make one sourcefile use another one, is it just import file?
15:18:41 <emk> ailndx: 'import' should usually do what you want.
15:19:06 <emk> But I think the file you're importing needs to have 'module Name (export1,...) where' at the top.
15:19:33 <kc5tja> You can omit the export list if you just want to export everything.
15:20:07 <kc5tja> That is often convenient when the code is changing too fast to keep the list of exports synchronized.
15:20:10 <ailndx> export1...? i thought it only needed to have like: "module Name where"?
15:21:11 <fasta> ailndx: the export list is optional
15:23:45 <ailndx> http://hpaste.org/978 i should be able to do it something like this?
15:24:04 <ailndx> ok, i dont even know what an export list is so
15:25:21 <ailndx> but if i do as in that paste do i have to compile file1 first as a lib or something?
15:26:19 <jfoutz> ailndx: have you tried ghc --make ?
15:26:44 <jfoutz> if everything's good in ghci, ghc --make might help
15:26:49 <ailndx> havent tried much at all, im beginner at this
15:27:24 <jfoutz> ahh, i see.
15:27:57 <ailndx> Prelude> ghc --make  ....... <interactive>:1:0: Not in scope 'ghc'
15:28:38 <sorear> that's a shell command :)
15:28:47 <ailndx> well im in win
15:28:54 <dons> moring all
15:28:55 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
15:29:02 <sorear> moring.
15:29:14 <shapr> Goood morning dons!
15:29:39 <dons> so ... how are we going to change the world today??
15:29:45 <dons> ah, I know, with coffee!!
15:29:46 <shapr> I have some ideas...
15:30:00 <jfoutz> ailndx: sorry. sometimes, if you're at a bash prompt, and you have some code to compile, you can compile it with ghc
15:30:18 <dons> ?users
15:30:18 <lambdabot> Maximum users seen in #haskell: 336, currently: 317 (94.3%), active: 56 (17.7%)
15:30:20 <shapr> @where c2hs
15:30:21 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
15:30:26 <jfoutz> ailndx: giving ghc the argument of --make tells ghc to figure out dependencies automatically.
15:30:39 <ailndx> ah ok
15:31:08 <shapr> Does anyone know if there are c2hs packages for Intel Mac OS X?
15:31:11 <dons> morning dcoutts
15:31:19 <dons> dcoutts: you're in early!
15:31:41 <jfoutz> ailndx: i had trouble with the Network library. all my stuff worked in ghci, but when i tried to compile i got these weird linker errors. ghc --make solved that.
15:32:12 <dcoutts> dons, aye, work up at 6:30, got here 7:15ish
15:32:19 <dons> crikey
15:32:23 <dcoutts> dons, still no network on my laptop, sigh.
15:32:27 <dons> argh
15:32:48 <dcoutts> but it's early yet, the systems support probably arn't in yet
15:33:09 <dcoutts> dons, where was it you though I could find/buy a blank writable CD?
15:33:25 <dons> at the newsagents across in the quadrangle
15:33:31 * dcoutts is getting annoied with the old ubuntu install (esp since I don't have root)
15:33:37 <ailndx> so when i want to include a module, do i have to compile the module first or can it include the .hs file directly?
15:33:39 <sorear> I find it interesting how you fly ten thousand miles to dons' uni, then do your greeting via IRC.
15:33:41 <dcoutts> dons, right'o
15:33:50 <dons> sorear: i just can't get in to uni at 9am..
15:33:53 <dcoutts> sorear, yeah :-)
15:34:17 <dcoutts> I'm normally not an early riser, but I'm still adjusting to the time zone
15:34:30 <dcoutts> I'll be on dons time soon
15:35:42 <jfoutz> ailndx, if you're using ghci, ghci will just use the source. if you're using ghc, it will compile whatever dependancies you have -- i know it is somewhat clever about recompiling edited files... check the manual for sure. it does pretty much what you'd expect.
15:35:43 <shapr> sorear: haha
15:36:12 <jfoutz> ailndx: so no. you don't have to name each source file for a compile.
15:37:09 <ailndx> ok, gonna try it
15:37:34 <dons> dcoutts: also at the bookshop they should have some
15:38:34 <dons> as seen on haskell-cafe: "You guys are awesome!  I post this not 12 hours ago and I already have a
15:38:38 <dons> complete treatise on the subject."
15:41:56 <ddarius> Damn it.  I was about to say screw it about the weeks worth of Haskell-Cafe traffic I've yet to catch up with.
15:42:12 <Botje> ddarius: i'm facing a month's worth.
15:42:23 <Botje> that "mark all read" option is looking mighty tempting
15:45:27 <sorear> parsing haskell 98 is very disheartening
15:46:28 <Botje> would you rather parse perl?
15:47:11 <sorear> Is there such a thing as parse- or type-incorrect perl?
15:47:34 <sorear> if not, then my parsing job is easy.  { return 1; }
15:47:41 <Botje> :)
15:48:48 <bos> i hate programming in c.
15:49:17 <Botje> program in haskell and compile to c
15:49:44 <bos> heh, this is linux kernel source :-)
15:49:46 <sorear> even yacc isn't that bad...
15:50:29 <Botje> bos: rewrite it in haskell first :p
15:50:57 <kpreid> sorear: here's a perl syntax error: (if)
15:51:09 <Pseudonym> yacc isn't bad at all until you want to do anything odd.
15:51:11 <Pseudonym> Like error recovery.
15:51:20 <fasta> If you need a && b && c, do you write and[a,b,c]?
15:51:31 <kpreid> sorear: here's a perl type error: bless 0, 1
15:51:32 <Pseudonym> fasta: Either works.
15:51:37 <Pseudonym> > True && True && True
15:51:39 <lambdabot>  True
15:51:42 <fasta> Pseudonym: of course
15:51:44 <Pseudonym> > and [True,True,True]
15:51:44 <Botje> fasta: i'd write the first
15:51:45 <lambdabot>  True
15:51:49 <Pseudonym> I'd write the first too.
15:51:59 <Pseudonym> But it'd depend, I guess.
15:52:04 <fasta> Pseudonym: It was a style question.
15:52:09 <Botje> (is ghc clever enough to rewrite the second into the first?)
15:52:14 <Pseudonym> I can envisage situations where the latter is more readable.
15:52:15 * fasta 's code looks like Scheme
15:52:22 <sorear> Botje: it can, but it doesn't
15:52:42 <Pseudonym> Botje: But you never know with lazy evaluation.
15:52:44 <fasta> I am even using cond.
15:52:48 <Botje> care to explain why? or point me to a paper called "AND CONSIDERED HARMFUL" ?
15:52:55 <Pseudonym> At high optimisation levels, it likely expands that only once.
15:52:55 <sorear> Botje: there's a comment in the source to the effect "This rule is commented out because it can result in MASSIVE CODE BLOAT"
15:53:07 <Botje> ah.
15:54:16 <dons> ?src and
15:54:16 <lambdabot> and   =  foldr (&&) True
15:54:48 <Botje> that much was obvious
15:55:23 <Botje> i'm guessing the overhead caused by creating the list and foldr'ing over it is irrelevant, then.
15:55:28 <Botje> which is nice :)
15:57:09 <dcoutts> dons, do you have root access on shodan? I'm trying to burn a cd but I'm not in the cdrom group.
15:57:52 <dcoutts> Botje, it's not irrelevant, but fusion solves it
15:58:51 <Igloo> Botje: x && y && z will be faster than and [x, y, z] if that's what you mean
16:04:50 <sorear> dcoutts: it won't fuse.  GHC.{Base,List}, grep "foldr?/(ap|cons)"
16:04:59 <Lemmih> dcoutts: So, you've mastered list and stream fusion. How about taking on cold fusion?
16:05:33 <sorear> *egrep
16:05:49 <dcoutts> Lemmih, heh
16:06:00 <sorear> ooh
16:06:06 <norpan> and [x,y,z] could easily inline to x && y && z though
16:06:06 <dons> dcoutts: indeed I do
16:06:16 <kc5tja> For cold fusion, all you need is milk and sugar.  Dissolve sugar in milk to saturation.  Paint a layer of the solution onto the surfaces to be fused.  Allow to dry.  Instant cold fusion.  :)
16:07:05 <fasta> You can also wait for it to happen. There's a chance that it works.
16:07:07 <dcoutts> sorear, yes, right, it doesn't do it at the moment, that's not to say it's impossible
16:07:21 <dcoutts> dons, yay
16:07:30 <fasta> In GHC impossible things happen more than once.
16:07:35 <sorear> beh, mega reado... *** agilman (n=root@fyodor.hcoop.net) has left channel #haskell: "haskell sucks"  something in that triggered a "Smerdyakov" decode
16:08:27 <dons> dcoutts: cdrom should work, and you have sudo access (I think)(
16:11:03 <sorear> how h98-compliant is Language.Haskell?
16:11:37 * zbrown bludgeons ghc-6.6
16:11:59 <dons> sorear: missing a few things
16:12:15 <dcoutts> dons, ta
16:12:33 <sorear> it's soo temptingly shorter than the Hugs parser.y
16:12:40 <zbrown> any clues as to why ghci-6.4.2 works fine but when i compiled ghc-6.6, ghci-6.6's ctrl+D and backspace don't work?
16:13:09 <sorear> where'd you get ghc 6.4.2?
16:13:14 <sorear> you compile it too?
16:13:36 <zbrown> sorear: no, didnt compile it
16:13:44 <sorear> you might need to install libreadline5-dev and recompile ghc-6.6
16:13:46 <zbrown> used the package provided w/ the OS
16:14:10 <zbrown> hmmm ok
16:14:24 <dcoutts> dons, done, now to reboot & install
16:14:28 * zbrown goes to do that
16:16:59 <dmead> boo
16:17:18 <Uncountable> what does ghcii.sh do? can i do the same thing by giving ghci some argument?
16:17:35 <dons> ghcii.sh?
16:18:08 <Uncountable> i want to start a new instance of ghci from cygwin. if i do cygstart ghci, ghci recommends me to use ghcii.sh instead, because there are problems with ctrl+c else
16:18:21 <Uncountable> it contains this:
16:18:22 <Uncountable> exec "$0"/../ghc --interactive ${1+"$@"}
16:18:32 <Uncountable> i don't know bash so i don't know what it does
16:20:00 <QtPlatypus> exec searches the path and executes the argument given.
16:20:05 <Igloo> That's the same as running ghc --interactive
16:20:29 <Uncountable> is there any difference between ghci and ghc --interactive?
16:21:19 <Igloo> Not on Linux - I'm not sure what ghci is on Windows OTTOMH
16:27:59 <zbrown> Anyone know of any databases that provide support for storing tuples as numbers instead of storing as a string? Preferrably in one column, rather than storing each element of the tuple in a column.
16:28:29 <jcreigh> I think postgresql has an "array" type
16:28:55 <jcreigh> yup: http://www.postgresql.org/docs/8.0/interactive/arrays.html
16:28:56 <lambdabot> Title: PostgreSQL: Documentation: Manuals: PostgreSQL 8.0: Arrays
16:29:04 <jcreigh> ah, lambdabot is so handy.
16:29:06 <jcreigh> lambdabot++
16:29:10 <zbrown> hmmm
16:29:20 <jcreigh> not really "tuples" per se
16:29:36 <zbrown> jcreigh: yah
16:29:46 <zbrown> i wonder if there's any performance hit...
16:30:02 <zbrown> probly not enough of a performance hit to matter for a 32 core Apple XServe cluster
16:30:05 <zbrown> lol
16:31:23 <sorear> Uncountable: I've heard ghci only works properly on win when run from a shell script.  So, no, no combination of options will work.
16:32:25 <zbrown> lol
16:33:05 <Uncountable> sorear: okay, how should i run it then?
16:33:14 <Uncountable> cygstart seems to expect an executable, which ghcii.sh isn't
16:33:26 <Pastorn> > map (read :: Int) $ map words . lines $ "08 09 01 54 67\n45 98 11"
16:33:27 <lambdabot>  Couldn't match expected type `Int'
16:33:36 <Pastorn> why can't i map read?
16:33:38 <lemao> hi there. quick noob question: is a type class the same as a metaclass in clos, for instance?
16:33:46 <Pastorn> > read "12"
16:33:48 <lambdabot>  12
16:34:12 <fasta> lemao: AFAIK, they are completely unrelated.
16:34:37 <kc5tja> > map words . lines $ "08 09 01 54 67\n45 98 11"
16:34:38 <lambdabot>  [["08","09","01","54","67"],["45","98","11"]]
16:34:45 <dons> lemao: not related.
16:34:45 <fasta> lemao: they are comparable with C++ Concepts
16:34:50 <kc5tja> That's why -- it's producing a list of lists, rather than a flat list.  :)
16:35:08 <zbrown> Anyoone had trouble with hdbc-postgresql ?
16:35:12 <dons> kc5tja: so have you been able to run that code I sent you? ;)
16:35:24 <augustss_> yo!
16:35:24 <lemao> This is what I am reading now: "Thus, we associate this function == with a type class, which we call
16:35:24 <lemao> Eq. If a specific type  belongs to a certain type class (that is, all functions associated
16:35:24 <zbrown> !paste
16:35:25 <lemao> with that class are implemented for ), we say that  is an instance of that class."
16:35:25 <hpaste> Haskell paste bin: http://hpaste.org/
16:35:42 <roconnor> > map (read :: Int) $ words =<< lines $ "08 09 01 54 67\n45 98 11"
16:35:43 <lambdabot>  Couldn't match expected type `Int'
16:35:44 <dons> yo augustss_ !
16:36:09 <procyon_> I have to make a plug.  "Types and Programming Languages" is a good book.  Like, real good.  Like SICP good.  I just got my copy yesterday.
16:36:10 <roconnor> > words =<< lines $ "08 09 01 54 67\n45 98 11"
16:36:11 <lambdabot>  Couldn't match expected type `a -> b'
16:36:12 * zbrown flogs lambdabot for his/her insolence in not announcing
16:36:23 <kc5tja> dons: Not yet.  Sorry.  I still need to get a working OS on my box at home.
16:36:33 <zbrown> http://hpaste.org/979 <-- Thats the error I get from trying to install hdbc-postgresql
16:36:43 <jcreigh> procyon_: is that the "TAPL" that I keep hearing about in-channel?
16:36:57 <procyon_> jcreigh: yes
16:37:20 <lambdabot> zbrown: it's not my fault - go find an announce message and tell me the nick!
16:37:54 <lemao> fasta: is it some sort of mixin, then?
16:38:14 <fasta> lemao: why don't you just try for yourself?
16:38:25 <sorear> @users
16:38:25 <lambdabot> Maximum users seen in #haskell: 336, currently: 309 (92.0%), active: 50 (16.2%)
16:38:32 <sorear> 33*6*?
16:38:34 <sorear> @uptime
16:38:35 <lambdabot> uptime: 20h 9m 10s, longest uptime: 5d 3h 40m 45s
16:38:37 <lemao> fasta: thanks.
16:38:47 <sorear> @let x = 2
16:38:50 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
16:38:54 <sorear> :(
16:38:59 <sorear> @farber
16:38:59 <lambdabot> Unknown command, try @list
16:39:17 <procyon_> jcreigh: Unless your name is Oleg, get it ;)
16:39:52 * jcreigh examines his birth certificate
16:39:58 <jcreigh> oh, okay. :)
16:44:42 <fasta> module Foo where
16:44:43 <fasta>  
16:44:43 <fasta> bar =
16:44:43 <fasta>  let bar =
16:44:43 <fasta>      let bar = 4
16:44:43 <fasta>      in bar
16:44:45 <fasta>  in bar
16:44:48 <fasta> What's wrong with that?
16:45:06 <shapr> shazam!
16:45:13 <fasta> TestModule.hs:5:5: parse error (possibly incorrect indentation)
16:45:24 <roconnor> > let bar = let bar = 4 in bar in bar
16:45:25 <lambdabot>  4
16:45:30 <Uncountable> why does ghci always freeze when i do something like entering [1..] and quickly pressing ctrl+c?
16:45:30 <fasta> Oh, I see it already
16:45:31 <yip> fasta: indent the inner most let
16:45:35 <Uncountable> i don't think it used to to that before
16:45:37 <fasta> yip: yes
16:45:47 <shapr> Today while unicycling I met a guy from Bulgaria, and another guy from Italy. A few weeks back I met a woman from the Netherlands. But I've only met one American in six months.
16:46:11 <procyon_> shapr: I'm an american, and it's nice to meet you.
16:46:21 <Igloo> shapr: Did you get lost on your way out of Europe?
16:46:45 <fasta> Any way to get warnings for shadowed bindings?
16:47:00 <fasta> -fwarn-name-shadowing
16:47:02 <fasta> Never mind
16:47:09 <shapr> Igloo: I really am in Birmingham, Alabama.. I just checked!
16:47:30 <shapr> fasta: -Wall for much fun.
16:48:21 * narain adds TAPL on list of books to check out from library
16:48:21 <procyon_> shapr: oh. In that case... weird.  Alabama's got a European invasion going on or something.
16:48:33 <shapr> narain: Yeah, TaPL is great fun.
16:48:58 <narain> that's going to be next after i'm done with Structure and Interpretation of Classical Mechanics
16:48:58 <shapr> procyon_: I think it may have to do with more Europeans than Americans exercising. Or maybe all the Americans are in gyms or something? I don't know.
16:49:02 <fasta> is TAPL better than its successor?
16:49:14 <shapr> fasta: ATTaPL is a sequenc.
16:49:17 <shapr> sequel*
16:49:19 <shapr> Not a successor.
16:49:26 <kc5tja> shapr: That's because Americans know better than to go near unicyclists.  ;)
16:49:30 <narain> ?google attapl
16:49:33 <lambdabot> http://www.cis.upenn.edu/~bcpierce/attapl/
16:49:33 <lambdabot> Title: Types and Programming Languages
16:49:42 <fasta> shapr: what's the difference?
16:49:42 <shapr> ATTaPL covers things like region allocation, and you'd probably want to have read and understood TaPL first.
16:49:47 <shapr> kc5tja: Could be
16:49:56 <fasta> shapr: ok, ok.
16:50:00 <kc5tja> shapr: "Honey, don't go near him.  He has a unicycle!"
16:50:01 <shapr> fasta: TaPL is an explanation of type theory from untype lambda calculus on up.
16:50:06 <fasta> shapr: successor means that it "replaces it"
16:50:13 <procyon_> fasta: successor: replaces older version.  sequel: adds to other book
16:50:14 <fasta> shapr: Yes, I know it doesn't replace it.
16:50:31 <shapr> Ok
16:50:47 <pejo> fasta, attapl is just edited by Pierce, whereas he wrote tapl. But attapl is still well worth its money.
16:50:56 <Uncountable> should i be able to run ghci in windows and pressing ctrl+c without it freezing?
16:51:09 <shapr> Yup. I've only read the ToC for ATTaPL, I haven't read it yet.
16:51:12 <Uncountable> it freezes no matter how i started it - double clicking on the exe, starting it from cmd or starting it from cygwin
16:51:44 <Pseudonym> ATTaPL /= Succ TaPL
16:52:53 * sorear reads backlog... "unicycle lambda calculus"
16:53:08 <shapr> sorear: :-)
16:53:45 <shapr> It's like that time CosmicRay fed four years of #haskell into a hidden markov model that generated random text... it kept trying to talk to me about unicycles.
16:54:06 * emk stares at list of cool papers to read in terror
16:54:15 <shapr> emk: Bah, it's just sweet sweet candy for the mind.
16:54:30 <kc5tja> Region allocation -- wasn't that the kind of memory management where, using static analysis, a compiler could emit code that puts dynamically allocated chunks into "pre-aged" (in the sense of a generational GC system) pools of memory?
16:54:44 <kc5tja> E.g., where the GC doesn't bother with individual objects, but only with entire regions?
16:54:47 <dons> yeah, like stack allocation for the heap
16:54:48 <shapr> kc5tja: Yup
16:54:57 <emk> The number of things I really, really want to read is growing faster than I'll ever be able to read it. :-(
16:54:59 <Uncountable> so everyone in here uses unix? if not, does ghci freeze for you too?
16:55:04 <kc5tja> Yeah, I remember reading that YEARS ago.
16:55:14 <kc5tja> Does Haskell use that at all?  I remember some ML variants exploring its use.
16:55:14 <shapr> Uncountable: If I used windows I'd try to offer advice, but haven't used win32 since 1999.
16:55:16 <dons> Uncountable: nope. i suspect its the issue with ^C on windows
16:55:18 <kc5tja> Not sure if it went anywhere.
16:55:21 <Pseudonym> I use GHCI under Windows at all, and it hasn't frozen yet.
16:55:27 <Pseudonym> Except when I program infinite loops.
16:55:38 <procyon__> Uncountable:  I have a toy vista machine here.. lemmee see.
16:55:40 <dons> Uncountable: a lot of people seem to use 'rlwrap' to clean up their ^C stuff on windows
16:55:44 <wchogg> emk:  That sounds bad, but would you ever really want to be done with everything you thought was cool?
16:55:53 <emk> wchogg: Fair enough.
16:55:55 <sorear> kc5tja: it's a (stalled?) subproject of JHC.  It almost certainly doesn't happen with ghc.
16:55:55 <Uncountable> dons: what's rlwrap?
16:55:58 <jfoutz> it's probably a race condition. mostly works, but every once in a while locks your console.
16:56:03 <dons> Uncountable: http://www.haskell.org/haskellwiki/Windows#Special_tips_and_tricks_for_Windows
16:56:05 <lambdabot> Title: Windows - HaskellWiki, http://tinyurl.com/2honj3
16:56:09 <emk> You know, that forthcoming Erlang book from the Pragmatic Press is really nice.
16:56:16 <wchogg> emk:  You've read the beta?
16:56:17 <dons> GHCi on cygwin: When running GHC under a Cygwin shell on Windows, Ctrl-C sometimes doesn't work. A workaround is to use the rlwrap program to invoke ghci
16:56:19 <emk> We need to get ourselves one of those for Haskell.
16:56:20 <shapr> I like the Pragmatic Programmers.
16:56:32 <shapr> I reviewed a coupla their books.
16:56:35 <emk> wchogg: Yup. Nicely presented, and I can't wait for the OTP chapters.
16:56:36 <dons> emk, indeed. or two or three.
16:56:48 <Uncountable> dons: but it freezes on ctrl+c no matter if i start it from cygwin or not
16:56:50 <kc5tja> lulu.com looks like a nice publish on demand service.  I haven't used it, but was going to when I finished my ROM firmware walkthrough book for the Kestrel.
16:56:58 <dons> Uncountable: what version of windows?
16:57:01 <Uncountable> xp sp2
16:57:01 <dons> which ghc versoin?
16:57:03 <procyon__> Uncountable: ghci 6.6 on Windows Vista 64.  Entered [1..] at prompt.  Enter key.  Immediate C-c.  It froze tight.
16:57:03 <Uncountable> 6.6
16:57:13 <dons> ah very interesting!
16:57:33 <sorear> procyon__: System reset required?
16:57:36 <dons> there were some changes to thre threaded runtime, and SimonM said they were tricky, involving ^C and getting things to halt properly on windows
16:57:44 <kc5tja> IIRC, Windows systems check for CTRL-C only when performing I/O with the console window.  Might need to periodically interject (null) I/O with the console.
16:57:49 <procyon__> sorear: No.  But no getting the console window back.
16:57:55 <emk> dons: Someday, I dream of writing a book about metaprogramming ("programs that write programs"). But what's the audience for a book that abuses everything from Lisp macros to SmallTalk metaclasses to Haskell monads? ;-)
16:58:12 <wchogg> emk:  I'd be in that audience for sure.
16:58:13 <shapr> emk: Larger than you might think.
16:58:24 <shapr> emk: #haskell keeps getting larger.
16:58:33 <kc5tja> emk: Don't forget Forth's immediate words too!  :)
16:58:41 <shapr> And some people only show up on #haskell once or twice a year.
16:58:52 <emk> kc5tja: Fair enough!
16:58:53 <wchogg> emk:  Also, why do you count monads under metaprogramming?
16:59:07 <shapr> emk: I think you should call it Gdel, Escher, Church
16:59:14 <kc5tja> : only-if-zero:   postpone 0= postpone if ; immediate
16:59:24 <shapr> wchogg: I think laziness is all about self modifying programs.
16:59:29 <procyon__> Oh, and on the GHCi freeze: was running natively, not under cygwin.
16:59:29 <kc5tja> : foo blah @ only-if-zero: do something here then ;
16:59:30 <kc5tja> ;)
17:00:06 <emk> wchogg: Well, a value of type "IO a" is basically a program, and monads allow you compute over values of type "IO a". It's a strange perspective, but not a bad one...
17:00:12 <Uncountable> yeah, it freezes also if you try ctrl+break
17:00:18 <sorear> emk: don't forget TH
17:00:26 <wchogg> shapr:  Not sure if I see where you're going with that idea.
17:00:37 <procyon__> emk: You might get a wider audience with "Church is not just for Hoare's"
17:00:45 * emk groans
17:00:55 <shapr> procyon__: yargh
17:01:19 <wchogg> Amidst the groaning, I'd like to say that was really good.
17:01:20 <emk> sorear: And MetaML is fascinating in an entirely different way...
17:01:26 <shapr> @remember procyon emk: You might get a wider audience with "Church is not just for Hoare's"
17:01:26 <lambdabot> Done.
17:01:31 <Uncountable> ghci 6.4 doesn't freeze, btw.
17:01:32 <procyon__> I'll be here all week.  Tip your bot.
17:01:48 <shapr> emk: Mostly because it totally disallows illegal constructions, iirc
17:01:49 <kc5tja> procyon__: Dude -- that just was WRONG.  :)
17:02:02 <shapr> Whereas TH instead allows you to construct anything, but then typechecks it.
17:02:12 <Uncountable> are there very compelling reasons for me to use 6.6 rather than 6.4?
17:02:31 <shapr> Yes.
17:02:31 <emk> shapr: It's almost a really principled version of Microsoft's System.Reflection.Emit (which allows you to emit bytecodes at runtime).
17:03:03 <shapr> I like the TH approach myself.
17:03:15 <emk> Of course! It's very useful.
17:03:36 <emk> But TH is a compile-time approach, and MetaML gives you strongly-typed runtime code generation. Very different beasts.
17:03:36 <dons> Uncountable: so perhaps you and procyon__ can construct a useful test case and report it as a bug ?
17:03:36 <Igloo> Uncountable: Newer cabal might be on, although you might be able to update 6.4's cabal
17:03:38 <shapr> arjanoosting: Hey, did you have to something crazy to get c2hs-14.5 to work in debian? Setup.hs seems to have a type error in the tarball.
17:03:38 <kc5tja> I wonder: one of Oberon's project developers wrote CLR, and explains why CLR is very much like the Oberon RT.  Now there is Simon PJ working for MS, and one must wonder how much Haskell has influenced the .NET platform.  Most interesting.
17:03:59 <shapr> kc5tja: Actually, Meijer has had influence on .NET and VB.
17:04:04 <shapr> And Lmmel
17:06:22 * emk knows of way to many metaprogramming APIs
17:06:22 <wchogg> Speaking of metaprogramming, has anyone actually tried Liskell?
17:06:22 <dons> wchogg: it has the wrong syntax ;-)
17:06:22 <shapr> Hm, Setup.hs in the latest tgz of c2hs is broken.
17:06:22 <dons> shapr: maybe grab the darcs repo?
17:06:22 <shapr> Oh, right
17:06:22 <kc5tja> Meijer is?
17:06:22 <shapr> Erik Meijer
17:06:22 <Igloo> shapr: What typo? There's nothing obvious in teh Debian diff
17:06:22 <Igloo> s/typo/type error/
17:06:22 <kc5tja> shapr: Sorry, I don't know that name.
17:06:22 <wchogg> dons:  Well, I don't really mind lisp but also I was intrigued by his claims that Liskell parse tree transformers were strictly stronger than CL macros.
17:06:22 <shapr> Igloo: Maybe it's just the directions. ./Setup.hs is given on the webpage as the way to go, but gives a type error when attempted.
17:06:24 <kc5tja> Did he work on Oberon in the past?
17:06:28 <shapr> kc5tja: Ask Google.
17:06:37 <Igloo> shapr: Oh, no, I tell a lie, I think
17:06:44 <shapr> kc5tja: I'm getting paid to hack on Haskell =)
17:06:59 * kc5tja doesn't see how that's relavent, but ... ok ...
17:07:16 <Igloo> shapr: There's a (nested) patch in http://ftp.debian.org/debian/pool/main/c/c2hs/c2hs_0.14.5-7.diff.gz which talks about 6.4.2 but might well be applied regardless
17:07:18 <lambdabot> http://tinyurl.com/29rxoq
17:07:41 * emk starts with the short, math-free papers in his backlog
17:07:51 <dibblego> shapr, hack on Haskell with HAppS?
17:07:54 <shapr> kc5tja: Just means that you can answer your own question easily, and I'd rather do productive Haskell work than answer it for you.
17:08:09 <shapr> dibblego: Yup, hacking on Haskell for HAppS right now.
17:08:30 <shapr> At the moment, the question is, what's wrong with c2hs?
17:08:47 <shapr> Man, HAppS has some awesomely cool stuff coming up in the future. I can barely wait.
17:09:19 <dibblego> speaking of that, fix the web page! please :)
17:09:29 <shapr> Oh, what's wrong with it?
17:09:35 <ailndx> module Main where.. should where be one a newline or not?
17:09:37 <shapr> You mean the lack of formatting? Or what?
17:09:55 <dibblego> oh it's fixed
17:10:04 <shapr> ailndx: Most people put newlines after that part. "module Main where\n\nimport Data.Map"
17:10:13 <dibblego> no, the "current" link went ot a version before "stable" for example
17:10:17 <shapr> dibblego: We just released 0.8.8, it has a bunch of good stuff.
17:10:23 <jfoutz> HApps is pretty opaqe
17:10:28 <kc5tja> shapr: But it took you more time to type the response you did than the answer you already know.  :)
17:10:34 <shapr> jfoutz: Got any questions? I am your clarifier!
17:10:49 <ailndx> shapr: i meant "module Main where\n.." or "module Main\nwhere\n.."?
17:10:54 <kc5tja> And, it turns out it was a red herring; he's not even close to the guy I'm thinking of, and as it happens, you collectively wasted BOTH our times.  :)
17:10:58 <shapr> kc5tja: Nah, it's like trying to describe what SPJ has done, it's easier to search google than give his entire resume.
17:11:12 <kc5tja> Yeah, but I wasn't talking about him!
17:11:17 <jfoutz> not off the top of my head. i remember having a real hard time with the comments that the examples don't work and i should look in the http protocol source for an example of the server.
17:11:21 <kc5tja> I was talking about the original architect of CLR.  :)
17:11:29 <shapr> kc5tja: No, you asked about influence from Haskell into Microsoft, specifically .NET. Meijer and Lmmel are the right places to look for that.
17:11:50 <kc5tja> No, I asked specifically in reference to .NET; I could care less about the rest of Microsoft.  :)
17:11:54 <shapr> jfoutz: Hm, I can only hope that's changed. If it hasn't I'll fix it as soon as possible. Can you remember any specifics?
17:11:57 <Cale> I wish Meijer would be more positive when he talks about Haskell.
17:11:59 <shapr> kc5tja: Well, ok..
17:12:06 <jfoutz> shapr: i will take another look at it soon. and pester you incessantly.
17:12:15 <shapr> jfoutz: I would appreciate it!
17:12:18 <kc5tja> VB just plain doesn't interest me in the least.  List comprehensions or not.
17:12:41 <kc5tja> YAY, waste another 45 minutes debugging a stupid shell script.  *sighs*
17:12:42 <Cale> LINQ is more than plain list comprehensions, but I don't blame you
17:13:31 <shapr> jfoutz: Part of my job is to make sure the HAppS tutorial and docs are understandable.
17:14:31 <shapr> Cale: Well, #haskell is positive enough to offset a large number of Meijers :-)
17:14:31 <dibblego> there was a time recently when one of the examples wouldn't compile with 0.8.4
17:14:41 <jfoutz> shapr: ok, cool. last time i took a look at it was the 8.6 branch httpsomething was being replaced with httpsomething2 and it was confusing
17:14:43 <shapr> dibblego: Hopefully that's been fixed?
17:14:48 * kc5tja wishes he could be as smart as some of these other folks.  Publish or perish?  Sheesh, I'd be dead instantly.  :(
17:14:50 <dibblego> shapr, I'll try again soon
17:14:54 <ailndx> how was it i compile with ghc, "ghc --make -o -O xor.hs xor" or something?
17:14:55 <shapr> jfoutz: Oh yeah, that was confusing to me too.
17:15:11 <shapr> ailndx: ghc --make xor.hs -o xor
17:15:14 * emk finishes the easiest papers, and checks the queue.
17:15:17 <kc5tja> s/he/I
17:15:24 <jfoutz> shapr: show stopper confusing if you're not getting paid for it :)
17:15:24 <ailndx> no -O?
17:15:26 * kc5tja just realized first-vs-third person type error.  :)
17:15:38 <sorear> shapr: Is it my client's fault: "Meijer and Lmml" <-- no a:
17:15:39 <shapr> ailndx: But most people name the module filename to match. So, it's usually Xor.hs
17:15:49 <shapr> sorear: UTF-8!
17:16:02 <shapr> jfoutz: Yeah, I understand. I'd also like to hear any feedback.
17:16:11 <Cale> shapr: yeah, but he could do a lot for Haskell from his position if he pushed a little harder, I think.
17:16:19 <shapr> Cale: True that.
17:16:28 <Cale> I sometimes wonder if he's contractually obligated to downplay Haskell.
17:16:29 <shapr> ailndx: You can use -O2 to get speedy code.
17:16:47 <shapr> Cale: That has occurred to me also. But I try to say positive things about people as much as possible.
17:17:38 <shapr> ailndx: And you can use -O0 to get unoptimized code.
17:17:51 <shapr> ailndx: Both settings have their advantages.
17:18:12 <shapr> I usually just skip the optimization argument unless I have a specific reason to do otherwise.
17:18:25 <ailndx> hmm is -o2 speedier than -O?
17:18:27 <shapr> hej fons, god morgon!
17:18:38 <shapr> ailndx: For the most part, yes.
17:18:46 <ailndx> ok
17:18:47 <fons> hej shapr hur r det
17:18:47 <shapr> Though I don't know if lowercase o will work.
17:18:50 <procyon__> ailndx: Yes, but compilations can get very slow.
17:18:55 <shapr> fons: Det gr bra, och dig?
17:19:02 <Cale> sorear: "" is an a with diaeresis.
17:19:18 <shapr> Man, I had diaeresis once..
17:19:22 <sorear> Cale: I see "".  What encoding are you using?
17:19:24 <shapr> Then I took the mickey mouse hat off...
17:19:27 <Cale> sorear: UTF-8
17:19:46 <Cale> I put the letter between two double quotes
17:19:53 <Cale> so your client is just deleting it.
17:19:57 * shapr hears the solid tone of a very dead joke.
17:20:10 <sorear> erc-server-coding-system is utf-8 ... any erc experts here?
17:20:15 <Cale> shapr: heh
17:20:15 <kc5tja> UTF-8 is for wimps.
17:20:18 <kc5tja> UTF-2 ftw!
17:20:19 <fasta> sorear: rcirc works fine ;)
17:20:27 <shapr> sorear: Go to your irc process buffer, then hit C-c C-m p and type in utf-8
17:20:34 <Cale> I use X-Chat.
17:20:34 <fons> fons, bara bra, jag skiver den frsta capitel av min exjobb (I should really improve my swedish)
17:20:35 <sorear> which is 'better'?  I have both.
17:20:39 <shapr> sorear: Hit enter, then utf-8 again and hit enter.
17:20:40 <fons> shapr I meant
17:20:44 <fons> hehe
17:20:50 <sorear> shapr: I can't put key sequences in my .emacs :)
17:20:53 <shapr> fons: Du r inte svensk?
17:21:10 <fons> nej, jag bara studera har
17:21:15 <fasta> shapr: You are confusing rcirc now. I got \344
17:21:22 <sorear> shapr: in buffer chat.freenote... C-c C-m --> unbound
17:21:29 <shapr> sorear: Yes, but you can type those into your irc process buffer to see what happens, and then do C-h k C-c C-m p in that buffer to figure out what function you should call.
17:21:45 <sorear> what would by irc process buffer be called?
17:21:52 <shapr> fons: Varifrn kommer du? Jag kommer frn Alabama...
17:22:01 <shapr> sorear: Should be right, things may have changed in gnumacs.
17:22:04 <shapr> I use xemacs.
17:22:05 <shapr> I'm using ERC Version 4.0 $Revision: 1.693 $ with XEmacs 21.4 (patch 19) "Constant Variable" XEmacs Lucid (i486-linux-gnu, built 2006-11-03)!
17:22:20 <shapr> You'll also find my name in the ERC credits :-)
17:22:30 <ailndx> ":! ghc --make -O "bin/dhs/file.hs" -o file" results in "Chasing modules from: bin/dhs/file.hs...."
17:22:32 <jfoutz> shapr: the README should include a runhaskell Setup.hs or some such...
17:22:42 <shapr> jfoutz: Hm, good point.
17:22:48 <sorear> shapr: C-c C-m --> C-c RET is undefined
17:23:19 <fons> II have a question for the fp experts, can anyone give me a example of a functional language which, unlike Haskell, provides support for heterogenous lists?
17:23:20 <shapr> sorear: Weirdness. Ask on #emacs? I use C-c C-m p to set the character encoding for the process in this buffer.
17:23:35 <shapr> fons: Haskell does provide support for heterogenous lists, seen HList?
17:23:37 <Igloo> fons: lisp
17:23:47 <sorear> shapr: what is my irc server process buffer called?
17:23:49 <fons> shapr, Jag kommer ifrn spanien
17:23:56 <shapr> fons: Ah, intressant
17:24:00 <fons> shapr, I mean, directly
17:24:03 <sorear> shapr: M-: (buffer-list) shows nothing promising
17:24:11 <sorear> (and that lists space-buffers)
17:24:43 <shapr> sorear: Hold on, I told you the wrong key combo... I'm trying to persuade my fingers to go slowly so I can watch :-(
17:24:51 <fons> Igloo, I should have specified pure, I know about Hope, but is not a well-known one
17:25:20 <ailndx> ":! ghc --make -O "bin/dhs/file.hs" -o file" results in "Chasing modules from: bin/dhs/file.hs...." Why doesnt this work?
17:25:28 <shapr> sorear: Ok, I got it. It's C-x C-m p, and the function is set-buffer-process-coding-system
17:25:31 <shapr> sorear: Sorry for misleading you.
17:25:49 <sorear> shapr: in what buffer?
17:25:55 <shapr> In the irc.freenode...
17:26:03 <wchogg> shapr:  While we're near the subject of HAppS, I noticed that when I try to build it requires HList but it doesn't mention this on the wiki tutorial.
17:26:07 <shapr> Mine is anthony.OPN at the moment.
17:26:13 <sorear> ok, done
17:26:21 <sorear> can someone say something utf-8
17:26:22 <sorear> ?
17:26:23 <shapr> sorear: Nu frstr du svenska?
17:26:49 <sorear> I see two high charactors.  good?
17:26:55 <ailndx> nej det gor han inte
17:26:55 <sorear> 366 and 345 fwiw
17:27:02 <ClaudiusMaximus>    << this is utf-8
17:27:04 <jfoutz> shapr: i don't see a link to HList, but it's required. (i happen to have it, but you should add it.)
17:27:08 <shapr> wchogg: Well, I'm going to clean that up tomorrow or the next day. I honestly don't know if it requires HList or not. I'll update the tutorial as soon as I know.
17:27:10 <sorear> bye...  thanks
17:27:25 <Nanar> is it possible to multiline string in haskell source code ? I mean something like: foo = "begin<newline>end"
17:27:44 <Nanar> or should I do "being\n" ++ "end" ?
17:28:03 <shapr> wchogg, jfoutz: Einar Karttunen wrote the HList code, and then got sick before there was any docs, so I'm coming in behind him to clean it up.
17:28:24 <fasta> Nanar: google knows
17:28:44 <shapr> Nanar: I don't think there's anything like python or perl multiline string literals in Haskell.
17:28:46 <jfoutz> shapr: uh, i think you can get hlist from google... it's not a HAppS specific thing is it?
17:28:52 <dons> hey, after a suggestion from dcoutts, I found an obvious 10-20% faster tweak to the shootout sum-col benchmark :-)
17:28:57 <jfoutz> that's how i got it anyway
17:28:59 <shapr> jfoutz: The cabal package is..
17:29:00 <fasta> shapr: there are
17:29:13 <Nanar> shapr: ok seems logical, thanks
17:29:21 <procyon__> dons: rock on!
17:29:36 <shapr> fasta: With single start and stop sigs? I thought it was only with the funny something like "\\" line endings?
17:29:40 <wchogg> shapr:  Cool, thanks for the info.
17:29:48 <fasta> shapr: no
17:29:59 <shapr> fasta: Tell me more? How does it work?
17:30:02 <fasta> shapr: but they are multi-line
17:30:06 <jfoutz> shapr: i just mean part 1 of the tutorial, installing, "To install HAppS the following packages are needed..." HList isn't in the list.
17:30:18 <fasta> shapr: google multi-line strings haskell
17:30:25 <shapr> jfoutz: Ah, good point. I'll fix that tomorrow or the next day, once I find out whether it really is necessary or not.
17:30:29 <jfoutz> ok
17:30:32 <shapr> fasta: ok
17:31:26 <shapr> Yup, it's the trailing backslash thingy.
17:31:58 <shapr> Maybe I misunderstood the question. I thought Nanar was asking for something like Perl's BEGIN and END multiline literal tags.
17:32:19 <Nanar> yes
17:32:41 <shapr> I asked SPJ about that sort of thing once, he said that GHC used to have it, but they took that and a bunch of other non-standard features out because they didn't want to stray from the Haskell spec.
17:33:03 <Nanar> a way to push long string + newline into var/function
17:33:33 <Nanar> like a any text file part
17:33:35 <fasta> shapr: I believe the functionality is what he asked for
17:33:43 <fasta> Oh, no, that not
17:33:54 <fasta> Nanar: well, it depends.
17:34:04 <allbery_b> not per se
17:34:18 <allbery_b> you can use \ \ magc though
17:34:21 <Nanar> I just want to avoid s = "a\n" ++ "b\n" ...
17:34:32 <shapr> Nanar: http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem shows the only multi-line string literal syntax that I'm aware of.
17:34:40 <lambdabot> Title: A type-based solution to the "strings problem": a fitting end to XSS and SQL-inj ..., http://tinyurl.com/uv94m
17:34:47 <wchogg> Okay, now I know this has been asked before but what was the main rationale for not having monad comprehensions?  Was the overloaded syntax considered unclear?
17:34:47 <shapr> It looks like:
17:34:54 <shapr> "foo
17:34:56 <shapr> er
17:34:59 <shapr> "foo \
17:35:01 <shapr> bar "
17:35:08 <shapr> wchogg: Confusion of newbies
17:35:41 <shapr> From what I've heard, monad comps allow what might appear to be simple code to give scary errors.
17:35:52 <fasta> shapr: that's what I meant, yes.
17:36:04 <shapr> fasta: ok
17:36:05 <ailndx> can someone help me to compile a hello world?
17:36:06 <allbery_b> hm, hpaste?
17:36:07 <wchogg> shapr:  Yeah, and I suppose they're not that necessary if you have do syntax.
17:36:09 <shapr> ailndx: Yes!
17:36:20 <allbery_b> http://hpaste.org/980 is an example
17:36:37 <shapr> ailndx: Can you paste the source on hpaste.org ?
17:36:38 <allbery_b> (of long strings using the \ \ magic)
17:36:39 <ailndx> it just says Chasing modules from: .... and cant find file
17:36:52 <shapr> ailndx: And can you paste the error as well?
17:36:55 <allbery_b> !hello?
17:37:00 <shapr> allbery_b: hiya!
17:37:11 <allbery_b> hpaste bot is wedged I guess
17:37:13 <jfoutz> shapr: in the hello world example, there's a "Notice in this example that any request other than GET / will produce an error!" -- i don't think that's true.
17:37:22 <allbery_b> (hpaste itself is fine...)
17:37:38 <allbery_b> hpaste: url
17:37:38 <hpaste> Haskell paste bin: http://hpaste.org/
17:37:45 <allbery_b> oh.  maybe I forgot announce
17:38:06 <shapr> I can probably restart hpaste, dunno if I can restart the bot.
17:38:40 <shapr> jfoutz: Hm, you're right. stdHTTP now has error handlers built in.
17:38:44 * shapr fixes
17:38:55 <ailndx> http://hpaste.org/981
17:39:02 <Nanar> notice from http://hpaste.org/980 \ at end of line is not a '\n'
17:39:26 <jfoutz> shapr: you're awesome
17:39:33 <shapr> ailndx: I'd suggest trying it from the shell prompt.
17:39:39 <shapr> jfoutz: thanks!
17:39:41 <Nanar> thanks all !
17:39:54 <Nanar> cognominal: you here !
17:40:04 <shapr> ailndx: If you're using ghc --make you don't need to do that from inside ghci
17:40:21 <cognominal> :)
17:40:35 <shapr> ailndx: But, if you really want to do it that way, you can figure out the current directory of ghci with :!pwd I think
17:41:20 <cognominal> Nanar, back from a monger heretic meeting
17:41:55 <allbery_b> Nanar: correct, all whitespace between pairs of \ is ignored, so \(newline)
17:41:57 <allbery_b> er
17:42:03 <shapr> allbery_b: That's a good multiline string example.
17:42:06 <allbery_b> \(newline)\ is ignored
17:42:46 <allbery_b> here documents are unlikely to happen in Haskell unless some of the current haskell-scripting activity gives someone in the haskell' effprt weird ideas
17:42:56 <allbery_b> (and I'm not at all sure I want to see that happen)
17:43:10 <Nanar> cognominal: ho yes, I was to far of paris
17:43:38 <shapr> Nanar: franais?
17:43:46 <Nanar> shapr: yup
17:43:51 <shapr> Cool
17:44:21 <shapr> Je suis Americain, but I'm sure that's obvious :-)
17:44:36 <Nanar> shapr: and I do plan to fill the haskell wiki in the french part with some newbies proof documentation and examples
17:44:45 <shapr> Whoa, extraspiffy!
17:44:55 <shapr> Speaking of which, I could train up my Swedish by doing the same.
17:45:21 <shapr> Although any native Swede may find the result amusing.
17:45:30 <shapr> ailndx: Did that help?
17:45:34 <shapr> Speaking of Swedes...
17:45:57 <Nanar> haskell is hard at the beggining because there few example of code for basic action like reading a file, interactif with system, etc...
17:46:06 * allbery_b can just imagine what would happen if he tried to write Hebrew documentation... since he's mostly biblical / mishnaic hebrew
17:46:19 <Nanar> that's sad, because otherwise it is very easy to write any tools
17:46:27 <ailndx> shapr: compiling from the prompt yes
17:46:37 <shapr> ailndx: Cool, got any other problems we can help with?
17:46:51 <ailndx> making one now
17:46:59 <dons> Nanar: do you know of a good tutorial on say, files and the like, in another language that we could port?
17:46:59 <shapr> A problem? :-)
17:47:04 <allbery_b> nanar: you might want to look at some of dons' stuff about reimplementing common shell utilities in haskell
17:47:08 <ailndx> yeah :/
17:47:24 <shapr> ailndx: Luckily, you have the helpful resources of the mighty #haskell!
17:47:36 <Nanar> but in france haskell suffer of concurency of ocaml :)
17:47:44 * shapr persuades lambdabot to flex
17:47:56 <shapr> Nanar: Well, OCaml is all about INRIA, so...
17:47:59 <dons> but ocaml suffers from a lack of concurrency ;-)
17:48:04 <shapr> dons: ahaha
17:48:13 <allbery_b> @wiki Unix_tools
17:48:13 <lambdabot> http://www.haskell.org/haskellwiki/Unix_tools
17:48:23 <Nanar> allbery_b: I probably already had a look
17:48:23 <dons> ?go simple unix tools
17:48:34 <lambdabot> http://haskell.org/haskellwiki/Simple_unix_tools
17:48:34 <lambdabot> Title: Simple unix tools - HaskellWiki
17:49:00 <Pseudonym> shapr: Have you ever looked at the source code of flex?
17:49:08 * allbery_b shudders
17:49:13 <shapr> Pseudonym: No, is it scary?
17:49:19 <Pseudonym> It's beyond scary.
17:49:22 * dons `throwTo` uni
17:49:31 <Pseudonym> It's the most poorly-engineered piece of GNU code ever, I think.
17:49:53 <shapr> That sounds painful.
17:49:55 <Pseudonym> GNU usually insists on fairly high coding standards.
17:50:00 <ftegularius> that's a dubious accomplishment
17:50:17 <Pseudonym> If I ever write a lexer generator, BTW, I'm going to call it exlex.
17:50:22 <shapr> hah
17:50:23 <Pseudonym> Because your expressions should be regular.
17:50:30 <dmead> lol
17:50:35 <shapr> That's better than Paskalle
17:50:41 <Nanar> dons: not saying your doc is bad idea, but when I had a look I was thinking to find tools doing _exactly_ same things than real one, so it didn't find what I was looking for
17:51:23 <jfoutz> dons, i think one strangeness of haskell documentation is, lots of smart people put up "i learned X" today pages. they vary in quality and readability... perl had the camel book so for better or worse, you learn from that. haskell has tons of internet resources, but (at least me) people have a problem balancing searching for documentation and using the documentation. esp with conflicting or vague docs.
17:51:43 <ailndx> http://hpaste.org/982 here is the new problem
17:51:44 <Nanar> dons: but now I start to understand how to read hadock documentation, things start to be easy in fact
17:52:20 <shapr> ailndx: Each module must be in its own file.
17:52:43 <ailndx> umm.. and it isnt?
17:52:54 <Nanar> haskell need a good cookbook ! it is impossible to find a book about haskell to begin
17:52:56 <shapr> ailndx: Er, it doesn't look that way from the paste. Am I misreading?
17:53:08 <ailndx> shapr: ah i misspasted, fixing
17:53:24 <shapr> ailndx: If those are in separate files, try adding -idhs2 to the command line
17:53:27 <ailndx> shachaf: http://hpaste.org/983
17:53:35 <shapr> That'll look for modules in the dhs2/ subdir
17:53:42 <ailndx> ok
17:53:48 <TSC> Import should be import ?
17:53:56 <shapr> TSC: Oh, good point
17:54:28 <TSC> And you don't need \n if you use putStrLn (:
17:54:30 <procyon__> Nanar: Haskell: The Craft of Functional Programming
17:54:39 <shapr> ailndx: Names starting with a capital letter are one part of a type. Names starting with small letters are functions or keywords.
17:55:15 <ailndx> shapr: umm did i use any of those wrong?
17:55:21 <Nanar> procyon__: thanks !
17:55:24 <QtPlatypus> shapr: Is that a convention, or something that compiler depends on?
17:55:36 <TSC> QtPlatypus: It's part of the language
17:55:40 <shapr> ailndx: you have "Import Multiplefilelib" where it should be "import Multiplefilelib"
17:55:56 <procyon__> Nanar: Are you new to functional programming?  If not, that book might be *too* elementary.
17:56:04 <jfoutz> procyon__: it's a good book, but it's not a 'get stuff done' book. ml for the working programmer was further along in that direction
17:56:17 <shapr> QtPlatypus: Yup, it's part of the language. Confused me lots when I first got into Haskell directly from years of Python.
17:56:28 <Nanar> procyon__: I am new in functionnal programming, starting by haskell :)
17:56:34 <shapr> tres bien!
17:56:51 <shapr> Vive les langues fonctionelle!
17:56:56 <shapr> :-)
17:57:03 <Botje> whois shapr
17:57:07 <Botje> argh!
17:57:09 <Nanar> procyon__: often question I have is "I know how to do that in C/perl, what is best way in haskell"
17:57:10 <shapr> I'm just that guy, ya know...
17:57:14 * Botje glowers at his keyboard.
17:57:19 <procyon__> Nanar: That's probably a great book then.  Like jfoutz said, it's not a "get stuff done" book, but your likely to need the fundamentals before diving into "getting stuff done"
17:57:22 <shapr> hoi Botje, hoe gaat het?
17:57:36 <Botje> slecht :P
17:57:51 <shapr> Botje: My name is Shae Erisson, I started the #haskell irc channel, I was formerly maintainer of the HaWiki, and I started The Monad.Reader.
17:57:58 <Pseudonym> Nanar: And the good thing is, you're asking the right question.
17:58:05 <shapr> I was half disorganizer of EuroHaskell and AngloHaskell among other things.
17:58:08 <ailndx> ah that works, thanks
17:58:16 <procyon__> Nanar: Often, when asked "I know how to do this in c++, how do I do it in Haskell" The only real answer is "You don't" ;)  Hence, the need for fundamentals
17:58:18 <shapr> Botje: I've probably done some other stuff too, but nothing comes to mind.
17:58:21 <Pseudonym> Too many people think the question is "how do I implement this idiom from Perl in Haskell".
17:58:35 <Pseudonym> The right question is: I have a problem, how do I solve it?
17:58:44 <Pseudonym> Like you say: What is the best way?:
17:58:50 <Pseudonym> (Or "a good way", anyway.)
17:58:52 <shapr> Botje: But you can find lots of info about me on Google. My name is not shared by other humans that I can find.
17:58:59 <Botje> :)
17:59:09 <Botje> (\bot could use a whois feature, actually
17:59:14 <jfoutz> Pseudonym: but even the ansi C book said, this is how you implement a hashtable. I don't thing there's a good book that says, this is how you backtrack in haskell
17:59:23 <jfoutz> Pseudonym: where is the book of idioms?
17:59:31 <allbery_b> whereas if you look for me you're rather more likely t find my cousin :)
17:59:52 <ailndx> hmm when i look at some source files, some of them dont even start with: "module Main where" isnt this needed?
17:59:56 <Nanar> procyon__: yup that's the problem, but the question are general like "parsing a file" or "extracting 10th to 15th elements of an array"
18:00:15 <shapr> Botje: Oh, I thought of some other stuff. I'm on the committee for Commercial Users of Functional Programming 2007, and my full time job is writing BSD3 licensed Haskell.
18:00:42 <Botje> :)
18:00:42 <procyon__> Nanar: And for those questions, there really isn't a good "how to" cookbook, like jfoutz said, unfortunately.
18:00:46 <Nanar> procyon__: a good start is to look into existing modules :)
18:00:54 <shapr> Botje: So, who are you?
18:00:58 <dibblego> let length = length' 0 where length' n [] = n; length' n (_:xs) = length' (n + 1) xs in length [1..10000000] -- can I use seq somehow to make this execute in constant space?
18:00:58 <wchogg> Pseudonym:  When someone asks about implementing an idiom, tell them to import Control.Applicative.
18:01:00 <Botje> i'm just a poor tired student with a broken keyboard
18:01:07 <shapr> Botje: I'd guess you're from .nl or .be?
18:01:20 <Botje> .be
18:01:24 <shapr> I'm from Alabama, USA.
18:01:30 <TSC> dibblego: Use a bang pattern for "n"
18:01:33 <shapr> But spent the last seven years in Finland and Sweden.
18:01:38 <procyon__> VisitorPattern.hs
18:01:45 <procyon__> :D
18:01:55 <dibblego> TSC, is that a GHC thing?
18:02:03 <TSC> I think so
18:02:05 <Botje> procyon__: that's called "fmap"
18:02:13 <TSC> Or you can use seq by hand
18:02:15 <dibblego> TSC, actually, I might just use foldl'
18:02:35 <shapr> Botje: Want to know anything else about me? :-)
18:02:38 <Nanar> shapr: btw: "vive les langage fonctionel", "langue" is for english, french, etc..., "langage" for computer language
18:02:42 <Pseudonym> jfoutz: We don't have a book of idioms, but there's a section on the wiki.
18:02:50 <Botje> shapr: not right now, thanks :)
18:03:02 <shapr> Nanar: Oh, I didn't know that. My French skills aren't particularly impressive.
18:03:08 <Botje> maybe i should go to bed early
18:03:14 <shapr> nej!
18:03:17 <Botje> might even wake up before noon tomorrow :p
18:03:24 <Nanar> shapr: "vive les langages fonctionels" (+s +s), my french is not so good even it is first language ;)
18:03:31 <shapr> Nanar: haha
18:03:39 <shapr> My American is passible...
18:03:59 <procyon__> My french skills end at the knowledge that you're not supposed to pronounce those letters that are written past the middle of the word.. they are there for decoration.
18:04:06 <shapr> But I still can't remember all that stuff about lorries, tubes, etc, so my English is terrible.
18:04:19 <shapr> ouch, passable*
18:04:33 <Nanar> my english is horrible :)
18:04:36 <dmead> nah, passible
18:04:42 <dmead> american is spelled the way it sounds =)
18:04:42 <shapr> c'est franais, passible...?
18:04:49 <Nanar> shapr: yes
18:04:53 <shapr> I thought so...
18:05:08 <Nanar> shapr: hum, no "passable"
18:05:08 <shapr> That happens to me sometimes, I was trying to speak Swedish to this Italian guy I met today.
18:05:11 <shapr> doh
18:05:45 <shapr> Ya know, I went to see my grandmother recently, and I realized that she considers me a world traveller kind of person. That was a weird realization.
18:05:56 <Nanar> shapr: "passible" is when are under the risk of, for example "passible" of death condamnation
18:06:06 <shapr> oh
18:06:15 <procyon__> in umerikan u r alowed to spel theengs neway u want, az long az peepl git ur point.
18:06:32 <shapr> procyon__: Hey, I can read that after playing World of Warcraft for a few weeks!
18:06:35 <jfoutz> Pseudonym: 'idiom' is actually a pretty interesting search on haskell.org
18:06:37 <procyon__> hehe
18:06:39 <Nanar> shapr: french is a strange language ;)
18:07:04 <shapr> Nanar: Yeah, most languages are... Finnish is extremely regular, and spoken just like it is spelled. But it's strange in other ways.
18:07:23 <wchogg> shapr:  HAppS question, but how commutative is the list of handlers that you pass to stdHTTP?  Does the order matter at all?  I can't tell yet.
18:07:27 <fantasma> @where thunk
18:07:28 <lambdabot> thunk is now known as xmonad
18:07:34 <fantasma> what...
18:07:41 <fantasma> thunk is such a better name
18:07:53 <fantasma> @where xmonad   :(
18:07:53 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
18:07:56 <shapr> Ohjelmointia is Finnish for programming...
18:08:09 <shapr> wchogg: Yup, order matters.
18:08:20 <shapr> wchogg: The list is tried from top to bottom, first to last.
18:08:31 <shapr> In fact, that's used for authenticated handlers and the like.
18:08:59 <shapr> The idea is that each item in the list can either handle the request, or bail out, thus passing the request to the next item.
18:09:23 <wchogg> shapr:  Okay, cool.  Is there a way to dispatch on multiple handlers at once for a single request?
18:09:30 <shapr> The only exception is that you can also modify the request value and then pass it to the next case, but that's worth ignoring until you know HAppS better.
18:09:37 <kc5tja> :(
18:09:41 <kc5tja> Coworker's last day is tomorrow.
18:09:44 * kc5tja will miss him.
18:10:23 <zbrown> ahhhhh crap
18:10:27 <shapr> wchogg: Yeah, there's some simple way to do that... but it doesn't come to mind at the moment.
18:10:38 <zbrown> hit ^c in my ghc-6.6 make terminal
18:11:07 <shapr> wchogg: Anyway, I'll add that to my list of examples to add to the tutorial.
18:11:24 <fantasma> @seen
18:11:40 <fantasma> @seen dons
18:11:41 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 22m 19s ago.
18:12:16 <wchogg> shapr:  Thanks.  HAppS seems like a fully fledged version of some ideas I was kicking around for implementing a mud server, so I'm eager to dig into it.
18:13:12 <MarcWeber> Which type parameter to use wiht MathText ?
18:13:16 <shapr> Ok, I asked alexj ( the man behind HAppS ) and he says you can get the request, do stuff, and then use pass to let it go on down the list.
18:13:23 <MarcWeber> /sMath/Match/
18:13:49 <wchogg> Awesome.
18:13:50 <MarcWeber> shapr: Thats on of the first 5 examples on the tutorial page ;)
18:14:17 * shapr looks...
18:14:29 <shapr> wchogg: Most HAppS conversation happens on #happs
18:14:29 <fasta> About all the scientific algorithms papers I studied extensively contain errors. Do you have that too?
18:14:47 <shapr> fasta: See you should try to extensively study the ones that don't have errors ;-)
18:15:26 <fasta> shapr: This is peer-reviewed stuff. One would expect it to contain only "true statements".
18:15:45 <fasta> That's the idea of peer-reviewed published stuff.
18:16:19 <shapr> I think the academic publishing system has some major problems.
18:17:27 <shapr> but there's nothing better in the wings to replace it, so...
18:17:43 <fasta> shapr: it's a money problem
18:17:46 <shapr> Yup
18:18:43 <fasta> shapr: Most papers only get published once. As if everything they write down the first time is correct...
18:18:49 <shapr> Yup
18:18:56 <shapr> But I have an idea to improve on that...
18:19:03 <TSC> Publish twice!
18:19:05 <shapr> Have you heard about Fermat's Last Margin?
18:19:07 <TSC> Twice the impact!
18:20:13 <fasta> shapr: Faxen wrote a paper on a part of the formal semantics of Haskell. It too was loaded with bugs. The point of formal semantics is that they should be correct.
18:20:35 <shapr> I could never really get a handle  on that paper.
18:20:47 <shapr> But I did like Faxn
18:20:50 <shapr> He's a cool guy.
18:20:59 <fasta> shapr: You met him?
18:21:04 <procyon__> I think I'll publish a paper completely correct, but written completely in Text-messaging speak.
18:21:10 <shapr> Sure, he was the main hosting guy for ICFP2003 in Uppsala.
18:21:43 <sorear> .
18:21:43 <shapr> He was the guy to call if you got lost, couldn't find your hotel, etc
18:21:45 <fasta> I know people make mistakes, but the publishing system seems to assume they don't.
18:22:11 <shapr> But also, there's no system in place to publish revisions, fixes, comments, or anything of the sort.
18:22:37 <sorear> Pseudonym: you are aware flex isn't GNU?
18:24:35 <allbery_b> mrf.  something mangles &lt; and &gt; in sigfpe's latest screed
18:25:53 <fantasma> @seen sjanssen
18:25:53 <lambdabot> sjanssen is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 3h 57m 51s ago.
18:26:22 <sorear> @seen goltrpoat
18:26:23 <lambdabot> I saw goltrpoat leaving #haskell 11d 12h 49m 59s ago, and .
18:28:10 <allbery_b> looks like the original is right, it's either netnewswire or their aggregation service.  feh
18:34:02 <dmwit> ?yow
18:34:03 <lambdabot> Hey, waiter!  I want a NEW SHIRT and a PONY TAIL with lemon sauce!
18:34:09 <fantasma> ?arr
18:34:10 <lambdabot> Smartly me lass
18:34:22 <dmwit> ?quote arr
18:34:23 <lambdabot> ghc says: DsExpr.dsExpr: Infinite parallel array!
18:34:32 <fantasma> ?quote
18:34:33 <lambdabot> chessguy says: mejor cansado que casado!
18:34:47 <dmwit> Casado == married?
18:34:50 <fantasma> yah
18:34:59 <dmwit> That's an odd one. =P
18:34:59 <fantasma> and cansado = tired
18:35:26 <dmwit> Oh, mejor means "better", not "more".
18:35:36 <dmwit> =D
18:35:38 <fantasma> yeah
18:35:42 <dmwit> ?quote
18:35:42 <lambdabot> recuerden says: que erg0t tienen varios kms arriba
18:35:43 <sorear> que =~ than?
18:35:47 <fantasma> better tired than married
18:36:08 <MarcWeber> fantasma: You can say that in general ? ;)
18:36:20 <fantasma> :D
18:36:21 <dmwit> ?quo general
18:36:21 <lambdabot> bos says: algorithm analysis is generally questionable. most of the people who write analyses are analysing the compexity of their own algorithms, and have an axe to grind.
18:36:51 <fantasma> ?quote thunk
18:36:51 <lambdabot> sjanssen says: your mom has a thunk for a tail
18:38:06 <fantasma> @poll-show lambdabot
18:38:06 <lambdabot> ["</3","<3"]
18:38:44 <sorear> ?quote [-]
18:38:44 <lambdabot> br1 says: <br1>	<br1>	yo uso SMB, no svn :p <br1>	me confund * br1 has quit ("muhaha") <Samus_>	<:o)
18:38:58 <Pseudonym> ?quote lemming
18:38:58 <lambdabot> No quotes match. stty: unknown mode: doofus
18:39:26 <Pseudonym> Quick, somebody, make a witty quote about lemmings!
18:39:39 <pbx> Have the busted tab navs on sequence.complete.org been reported to whoever needs to know (jgoerzen)?
18:40:21 <sorear> @seen CosmicRay -- jgoerzen's nick
18:40:21 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 3h 33m 52s ago, and .
18:40:31 <pbx> Ah.
18:40:32 <sorear> just missed him I see
18:42:07 <pbx> I added a comment to this effect on his "Haskell Sequence Software Update" post. I'm sure other people will pester him too, it's kind of a hard thing to miss.
18:52:45 <pbx> Thanks sorear
18:57:13 <zbrown> From a haskell point of view, would it be better to run an operation everytime something happens, or run a function on the list?
18:58:50 <narain> ?src transpose
18:58:50 <lambdabot> transpose []             = []
18:58:50 <lambdabot> transpose ([]   : xss)   = transpose xss
18:58:50 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
18:59:11 <zbrown> rather run a function on a list of all the data as opposed to run the function each time the data is produced and added to the list?
18:59:41 <narain> zbrown: it's neater to map over the list, isn't it?
18:59:54 <zbrown> narain: thats what i was thinking, just making sure
19:00:01 <narain> the function will be evaluated as data comes in
19:00:41 <narain> i'm just a few weeks into haskell but i find this a big win for lazy evaluation
19:01:01 <zbrown> narain: same, im just having a harder time letting go of my imperative learnings lol
19:01:26 <zbrown> 6 yrs of C hardcoded into my brain is a hard thing to break
19:02:01 <zbrown> well 6 yrs of C/Java/Fortran
19:02:05 * kc5tja has been coding in C for over 15 years now.  Yikes
19:03:22 <narain> heh. in imperative languages you program by asking "what do i want to do?", and then "how can i do it?" ...in functional languages you ask the first question, and suddenly find that you're done
19:03:43 <dibblego> @remember narain in imperative languages you program by asking "what do i want to do?", and then "how can i do it?" ...in functional languages you ask the first question, and suddenly find that you're done
19:03:43 <lambdabot> Done.
19:04:09 <narain> woo!
19:04:28 <kc5tja> There was a time I thought I could come up with a cool quote.  But, then, I woke up.
19:08:41 <fantasma> @remember kc5tja There was a time I thought I could come up with a cool quote.  But, then, I woke up.
19:08:41 <lambdabot> Done.
19:10:00 <fantasma> @seen
19:10:11 <kc5tja> Hahahaha :)
19:10:20 * kc5tja hangs head in shame -- my track record is broken!
19:10:28 <sorear> I was quoted my first week...
19:10:31 <fantasma> hahaha
19:10:32 <sorear> @quote sorear C
19:10:32 <lambdabot> sorear says: StefanO'Rear says: ...the semantics are what give people named Simon the courage to implement counterintuitive optimizations without losing sleep.
19:10:40 <sorear> what gives?
19:10:49 <kc5tja> Hahaha :)
19:10:50 <sorear> case insensitivity sucks!
19:10:58 <fantasma> @quote sorear
19:10:58 <lambdabot> sorear says: for dealing with large numbers of people, euthenasia beats haskell in every way
19:11:06 <fantasma> @quote sorear
19:11:06 <lambdabot> sorear says: Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease*
19:11:06 <lambdabot> in LOC, and helped man #haskell all at the same time. This'd take me a week in C, no doubt.
19:11:10 <zbrown> @quote zbrown
19:11:10 <lambdabot> zbrown says: C was proposed for its speed, but that wasn't suitable either since I didn't want to have to incorporate 2.4 million libraries just to get the mathematical expression correct
19:11:14 <narain> ?quote sorear " c "
19:11:14 <lambdabot> No quotes match. I feel much better now.
19:11:33 <zbrown> heh w00t, i didn't realize i'd been quoted
19:11:53 <fantasma> @quote fantasma
19:11:54 <lambdabot> fantasma says: does haskell curry ever stop by here?
19:12:07 <zbrown> @quote lambdabot
19:12:07 <lambdabot> lambdabot says: test
19:12:13 <zbrown> @quote lambdabot
19:12:13 <lambdabot> lambdabot says: Beer, it's so much more than just a breakfast drink!
19:12:18 <narain> haskell curry, 1900-82
19:12:27 <procyon__> @quote procyon
19:12:27 <lambdabot> procyon says: Just to be different I wrote fizzbuzz in windows batch file.  It took me 10 minutes because I had to stretch my brain expressing my fold in terms of goto ;)
19:12:33 <shapr> I wrote the @quote plugin, I win!!
19:12:35 * shapr cackles evilly
19:12:41 <narain> ?quote shapr
19:12:41 <lambdabot> shapr says: I have hugged binkley on two different continents, no chat bot there.
19:12:42 <shapr> Ok, just being evil for a moment :-)
19:12:50 <fantasma> @version
19:12:50 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
19:12:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:13:10 <shapr> Seriously though, the @quote plugin has been a source of great mirth for me, it kicks ass.
19:13:15 <zbrown> there any performance gain w/ ghc 6.6 vs 6.4.2?
19:13:25 <shapr> Er wait, I wonder if dons wrote the quote plugin?
19:13:32 * shapr doesn't remember...
19:13:38 <shapr> Quick, get me a cane and I can pretend to be old.
19:13:47 <shapr> I'm too creaky to get one myself!
19:13:48 <fantasma> @author
19:13:48 <lambdabot> Unknown command, try @list
19:14:37 <shapr> Oh yeah, I wrote Yow.hs and then Fortune.hs and then refactored them into Quote.hs
19:14:44 <shapr> I think dons or somebody added @remember later on.
19:15:13 <shapr> I'm so glad dons took over lambdabot, I wasn't doing a great job of being project admin.
19:15:29 <fantasma> I agree
19:15:36 <fantasma> ?yow
19:15:37 <lambdabot> Th' MIND is the Pizza Palace of th' SOUL
19:15:46 <fantasma> ?fourtune
19:15:46 <lambdabot> Pain is a thing of the mind.  The mind can be controlled.
19:15:46 <lambdabot> 		-- Spock, "Operation -- Annihilate!" stardate 3287.2
19:16:00 <fantasma> ?admin
19:16:00 <lambdabot> Not enough privileges
19:16:03 <shapr> ?admin
19:16:03 <lambdabot> Plugin `system' failed with: IRCRaised user error (@admin: invalid usage)
19:16:06 <shapr> yipes
19:16:20 <shapr> @help admin
19:16:21 <lambdabot> admin [+|-] nick. change a user's admin status.
19:16:21 <sorear> ?admin + fantasma
19:16:23 <shapr> ohh
19:16:25 <sorear> ?admin - fantasma
19:16:35 <sorear> relatively new
19:16:38 <shapr> Cool
19:16:52 <fantasma> ?admin - lambdabot
19:16:52 <lambdabot> Not enough privileges
19:17:09 <sorear> lambdabot isn't an admin to begin with :0
19:17:12 <sorear> s/0/)/
19:18:40 <fantasma> @. elite run ['a'..'z']
19:18:42 <lambdabot> "4BCdEFGHijx|/\/\noPQrstu\/wXys"
19:18:49 <fantasma> @. elite run ['a'..'z']
19:18:51 <lambdabot> "4bcD3FGhiJKL/\/\NOpQr$TuVwxYz"
19:18:51 <LoganCapaldo> !hpaste
19:18:59 <sorear> @. elite paste
19:18:59 <lambdabot> |-|4zKEl1 pasteBIn: httP://|-|PaztE.ORG/NEW
19:18:59 <shapr> hpaste:
19:19:07 <sorear> @seen hpaste
19:19:07 <lambdabot> hpaste is in #haskell. I last heard hpaste speak 1h 41m 28s ago.
19:19:15 <shapr> Hm, I think it died.
19:19:40 <fantasma> @. elite run repeat 'a'
19:19:42 <lambdabot> "a4Aa444Aa4aaAA4Aa4AAaAAAAa444AAaaAaaA4444aAA4aaaa444aA44Aa4aaAAAaA4Aa4A4aa4...
19:19:59 <zbrown> @. elite
19:19:59 <lambdabot> Not enough arguments to @.
19:20:02 <zbrown> @. elite 'zbrown'
19:20:03 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "'zbrown'"
19:20:05 <zbrown> hmmm
19:20:21 <zbrown> @. elite ['zbrown']
19:20:22 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "['zbrown']"
19:20:25 <narain> ?elite narain
19:20:25 <lambdabot> nARain
19:20:25 <zbrown> oh well
19:20:30 <fantasma> lol
19:20:33 <zbrown> ?elite zbrown
19:20:33 <MarcWeber> http://hpaste.org/984
19:20:33 <lambdabot> sbr0\/\/n
19:20:36 <narain> that wasn't much
19:20:37 <zbrown> w00t
19:20:40 <narain> ?elite narain
19:20:40 <lambdabot> NarAiN
19:20:46 <narain> boo
19:20:53 <fantasma> there should be a second parameter "level of leetness"
19:20:59 <narain> ?help elite
19:20:59 <lambdabot> elite <phrase>. Translate English to elitespeak
19:21:02 <MarcWeber> I've got a parsec problem.
19:21:20 <narain> ?. elite elite elite elite narain
19:21:21 <lambdabot> 31I+E 31iT3 NarAIN
19:21:22 <LoganCapaldo> Anounces his own paste: http://hpaste.org/985, a type problem I don't understand
19:22:05 <fantasma> @. elite run fix show
19:22:06 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:22:18 <MarcWeber> LoganCapaldo: The problem is
19:22:19 <sorear> LoganCapaldo: points often help :)
19:22:24 <sorear> @. elite v
19:22:25 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
19:22:25 <MarcWeber> >:t return
19:22:51 <narain> :t (=<<) (return . (+1))
19:22:53 <lambdabot> forall (m :: * -> *) a. (Num a, Monad m) => m a -> m a
19:22:55 <MarcWeber> LoganCapaldo: return can return either IO, Maybe, List, Either, ... (and many more)
19:23:11 <LoganCapaldo> see why did lambdabot have no problem with typing that?
19:23:14 <narain> ?unpl (=<<) (return . (+1))
19:23:15 <lambdabot> (\ d -> d >>= \ g -> return (g + 1))
19:23:20 <Lemmih> LoganCapaldo: :set -fno-monomorphism-restriction
19:23:22 <sorear> LoganCapaldo: :set -fno-monomorphism-restriction j
19:23:29 <LoganCapaldo> ah
19:24:06 <fantasma> ?docs please
19:24:06 <lambdabot> please not available
19:24:10 <fantasma> ?docs
19:24:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:24:24 <syntaxfree> this isn't INTERCALBOT.
19:25:08 <LoganCapaldo> MarcWeber: do lines <- many $ ... many <anything> will accept the empty string I'm pretty sure
19:27:03 <zbrown> Hmmm whats the best way to map between two lists of same length?
19:27:18 <narain> zip
19:27:24 <zbrown> narain: thanks
19:27:29 <narain> also see zipWith
19:28:28 <zbrown> i think zipWith is what i'm looking for
19:28:35 <mauke> > zipWith (*) [1,2,3,4] [0,-2,10,3]
19:28:37 <lambdabot>  [0,-4,30,12]
19:28:42 <zbrown> hrm
19:29:16 <LoganCapaldo> MarcWeber: let parser = many $ string "q" in parse parser "" "" ---> Right []
19:29:36 <narain> zipWith f l1 l2 = map (uncurry f) $ zip l1 l2
19:29:42 <narain> ?src zipWith
19:29:42 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
19:29:42 <lambdabot> zipWith _ _      _      = []
19:29:57 <narain> zip = zipWith (,)
19:32:16 <zbrown> Hmmm does zipWith work with tuples
19:32:16 <zbrown> ?
19:32:38 <narain> zip and zipWith only work with lists
19:32:54 <zbrown> well its a list of tuples
19:33:06 <zbrown> thats my concern
19:33:25 <narain> well then sure, your function will be expected to take tuples as arguments
19:33:34 <zbrown> yup
19:34:01 <narain> > zipWith (\(a,b) (c,d) -> (a+c,b+d)) [(1,2),(3,4)] [(10,20),(30,40)]
19:34:03 <lambdabot>  [(11,22),(33,44)]
19:34:39 <zbrown> narain: ok, thats what i needed to know :)
19:35:12 <narain> also, you can use them on functions of unequal length and the extra elements will be discarded
19:35:21 <MarcWeber> LoganCapaldo many (satisfy (not . (`elem` "\n\r"))) >> newline was wrong
19:35:29 <zbrown> narain: that wouldn't be an issue :)
19:35:33 <MarcWeber> many $  (satisfy (not . (`elem` "\n\r"))) >> newline is correct
19:35:40 <dons> ?yow!
19:35:41 <lambdabot> Pardon me, but do you know what it means to be TRULY ONE with your
19:35:41 <lambdabot> BOOTH!
19:35:43 <narain> zbrown: sure, just pointing out that this comes in very handy sometimes
19:35:50 <zbrown> narain: yup
19:36:00 <zbrown> narain: you using any books to learn?
19:36:16 <LoganCapaldo> ya ok
19:36:45 <narain> zbrown: the wikibook, lots of monad tutorials, the standard library docs, and #haskell :)
19:36:54 <zbrown> hmmm
19:38:58 <zbrown> narain: alright, lets see. This is the goal of the function, it'll count all the places in two lists that at that index, both tuples are of equal value
19:40:18 <narain> zbrown: ok, what have you got so far?
19:41:59 <fantasma> how can I? [1,2,3,4,5] --> [12345]
19:42:58 <Cale> > foldl (\x y -> 10*x + y) 0 [1,2,3,4,5]
19:42:58 <narain> fantasma: fold
19:42:59 <lambdabot>  12345
19:43:06 <zbrown> well nothing. I have the function to create the two lists, but I'm not sure how to create the function to compare elements at index 'n'
19:43:28 <narain> zbrown: use zipWith
19:43:42 <narain> :t zipWith
19:43:45 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
19:43:50 <zbrown> narain: well the issue is i want to output a list of integers, not a list of tuples
19:43:51 <Cale> > zipWith (==) [1,2,3,4] [4,2,3,1]
19:43:52 <lambdabot>  [False,True,True,False]
19:44:23 <narain> zbrown: integers? or booleans?
19:44:29 <Cale> > length . filter id $ zipWith (==) [1,2,3,4] [4,2,3,1]
19:44:31 <lambdabot>  2
19:44:32 <narain> zbrown: what Cale said
19:44:52 <Cale> > findIndices id $ zipWith (==) [1,2,3,4] [4,2,3,1]
19:44:53 <lambdabot>  [1,2]
19:45:09 <Cale> > findIndices id $ zipWith (==) [1,2,3,4] [1,2,3,4]
19:45:10 <lambdabot>  [0,1,2,3]
19:45:17 <jfoutz> cale is a freaking genius.
19:45:37 <Cale> heh
19:45:41 <jfoutz> or he answers questions like this all day every day in chat.
19:45:45 <jfoutz> :)
19:46:14 <narain> zbrown: are those what you want?
19:46:17 <zbrown> yessir
19:46:19 <Cale> It all comes down to knowing the prelude and list library really well.
19:46:20 <zbrown> thanks Cale & narain
19:46:40 <syntaxfree> :t ap
19:46:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:47:03 <Cale> > map (ap (,) (^2)) [0..10]
19:47:04 <narain> zbrown: well Cale gave you all the answers before i could begin to open my mouth :)
19:47:04 <lambdabot>  [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
19:47:14 <zbrown> narain: well for before was my concern :)
19:47:23 <Cale> Yeah, I probably shouldn't give it away too quickly :)
19:47:51 <narain> right, let the person think for a bit first! :)
19:48:27 <syntaxfree> I don't understand the type of ap.
19:48:28 <Cale> > let fibs = 0 : 1 : ap (zipWith (+)) tail fibs in fibs
19:48:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:48:34 <syntaxfree> What's with the explictly-kinded constraint?
19:48:40 <Cale> syntaxfree: ignore that
19:48:52 <Cale> It's just saying that m is a type constructor
19:48:54 <syntaxfree> I know I can ignore that, but I want to know what it's doing there!
19:49:02 <syntaxfree> * -> * is a type constructor?
19:49:04 <syntaxfree> hmm.
19:49:04 <narain> don't all types involving monads have explicitly-kinded constraints?
19:49:06 <Cale> It's there because -fglasgow-exts is on
19:49:07 <syntaxfree> @kind (+1)
19:49:09 <lambdabot> parse error on input `1'
19:49:16 <syntaxfree> ah, stupid me.
19:49:18 <narain> :t (>>=)
19:49:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:49:21 <syntaxfree> functions don't have kinds :)
19:49:23 <Cale> @kind Maybe
19:49:26 <lambdabot> * -> *
19:49:29 <syntaxfree> @kind Int
19:49:32 <lambdabot> *
19:49:33 <Cale> @kind []
19:49:35 <syntaxfree> @kind []
19:49:36 <lambdabot> * -> *
19:49:38 <lambdabot> * -> *
19:49:41 <Cale> @kind IO
19:49:43 <syntaxfree> @king Either
19:49:43 <lambdabot> Maybe you meant: kind ring
19:49:43 <lambdabot> * -> *
19:49:48 <syntaxfree> @kind Either
19:49:50 <lambdabot> * -> * -> *
19:49:53 <syntaxfree> yay!
19:49:55 <syntaxfree> I get kinds :)
19:50:00 <Cale> @kind RWST
19:50:03 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
19:50:08 <narain> :O
19:50:17 <syntaxfree> @kind StateT
19:50:19 <lambdabot> * -> (* -> *) -> * -> *
19:50:21 <narain> ?index RWST
19:50:21 <lambdabot> Control.Monad.RWS, Control.Monad.RWS
19:50:36 <syntaxfree> @help ring
19:50:36 <lambdabot>  @ring <user>, CSE phonebook
19:50:42 <syntaxfree> CSE?
19:50:50 <Cale> common subexpression elimination?
19:51:06 <narain> ?ring dons
19:51:14 <dons> http;//www.cse.unsw.edu.au
19:51:18 <dons> that's actually disabled :-)
19:51:23 <syntaxfree> @get-shapr
19:51:23 <lambdabot> shapr!!
19:51:25 <narain> heh, sorry
19:51:32 <dons> @temp
19:51:32 <lambdabot>   now 26.6, min 17.2, max 27.5, rain 0.0mm, wind 28km/h NE
19:51:41 <dons> mm. nice autumn day in lambdabot land
19:51:52 <narain> where is that? unsw?
19:52:10 <syntaxfree> nort south west.
19:52:32 <narain> up/north/south/west
19:52:32 <narain> screw east.
19:52:36 <syntaxfree> university of north south wales.
19:52:38 <dgoldsmith> Quick question: if I want to parse a structured line -- the sort of thing I would use scanf for in C -- what is the best library function to use in Haskell? parsec? Or is there something less elaborate?
19:52:43 <syntaxfree> north . south = id, evidently.
19:52:51 <narain> *new* south wales
19:52:56 <dons> dgoldsmith: list operations anre 'read' are usable for that
19:53:00 <syntaxfree> **north** south wales
19:53:09 <dons> http://www.unsw.edu.au
19:53:10 <lambdabot> Title: UNSW: The University of New South Wales - Sydney Australia - Home page
19:53:11 <narain> university of wales then?
19:53:15 <encryptio> > [False..True]
19:53:15 <dgoldsmith> dons: I need to skip over non-significant constant strings
19:53:15 <lambdabot>  Parse error
19:53:27 <dons> dgoldsmith: dropWhile notSignificant ?
19:53:43 <Pseudonym> Up North South West.  We live in 3-space, after all.
19:53:43 <dons> at some point the complexity is such that you'd use parsec
19:53:56 <dgoldsmith> dons: yes, it's fixed-width, so I could do drop. Thanks!
19:53:57 <Cale> parsec isn't *that* heavy to use
19:54:08 <syntaxfree> Parsec is fun.
19:54:10 <narain> dgoldsmith: if it's simple and whitespace-separated, you could use  words  and read the right ones
19:54:18 <Cale> but yeah, if it's a fixed string, you can just drop them
19:54:22 <dons> dgoldsmith: also, we have a lot of parsec tutorials on
19:54:25 <dgoldsmith> narain: that's an idea too.
19:54:26 <dons> ?wiki Blog_articles
19:54:26 <lambdabot> http://www.haskell.org/haskellwiki/Blog_articles
19:54:28 <syntaxfree> Sometimes I stare at it trying to think how I can make a startup out of tiny DSLs.
19:54:37 <syntaxfree> ?wiki wiki
19:54:37 <lambdabot> http://www.haskell.org/haskellwiki/wiki
19:54:44 <syntaxfree> @. wiki yow
19:54:44 <lambdabot> http://www.haskell.org/haskellwiki/How's it going in those MODULAR LOVE UNITS??
19:54:50 <Cale> I'd recommend the Parsec user's guide, which is basically a tutorial.
19:55:00 <Cale> haha
19:55:07 <syntaxfree> @. google yow
19:55:09 <lambdabot> http://users.rsise.anu.edu.au/~daa/coffee/pin.html
19:55:13 <dgoldsmith> dons: It's not free-form enough to make parsec worthwhile. The scanf format string would look like "foo %d bar %d blah..."
19:55:28 <Cale> @. google vixen
19:55:30 <lambdabot> http://en.wikipedia.org/wiki/Undefined
19:55:30 <lambdabot> Title: Defined and undefined - Wikipedia, the free encyclopedia
19:55:38 <encryptio> @vixen
19:55:38 <lambdabot> <undefined>
19:55:41 <dgoldsmith> I went through a parsec tutorial at one point (as part of YAHT, I think) but haven't used it since -- I'd have to relearn it.
19:55:41 <syntaxfree> @. google quote
19:55:44 <lambdabot> http://tunes.org/~nef/logs/haskell/05.12.23
19:56:43 <lispy> syntaxfree: awesome
19:56:52 <dons> nice
19:56:52 <syntaxfree> @. quote yow
19:56:52 <lambdabot> No quotes for this person. stty: unknown mode: doofus
19:57:10 <dons> @. google quote yow
19:57:13 <lambdabot> http://tunes.org/~nef/logs/haskell/07.01.16
19:57:14 <dons> @. google quote dons
19:57:16 <lambdabot> http://www.idblog.org/archives/2003_12.html
19:57:17 <lambdabot> Title: IDblog: December 2003 Archives
19:57:24 <dons> @. google quote oleg
19:57:26 <lambdabot> http://tunes.org/~nef/logs/haskell/06.12.06
19:57:29 <dons> heh
19:57:32 <narain> ?quote oleg
19:57:32 <lambdabot> emu says: olegarithmic
19:57:40 <lispy> ?. google quote lispy
19:57:43 <lambdabot> http://sequence.complete.org/node?from=10
19:57:43 <lambdabot> Title: The Haskell Sequence | News about Haskell
19:57:49 <dons> ha
19:58:03 <syntaxfree> @. google . quote yow
19:58:04 <lambdabot> http://imdb.com/title/tt0071853/quotes
19:58:05 <lambdabot> Title: Monty Python and the Holy Grail (1975) - Memorable quotes
19:58:05 <lispy> google search is  pretty amazing
19:58:07 <narain> ?pl \list -> map (list !!) indices
19:58:07 <lambdabot> flip map indices . (!!)
19:58:12 <syntaxfree> yay!
19:58:22 <lispy> haha
19:58:39 <lispy> syntaxfree: did you serious get it to bring up imdb for holy grail?
19:58:42 <lispy> that's amazing
19:58:50 <narain> Monty Python quoted Zippy??
19:59:06 <dons> zippy quoted monty python?
19:59:26 <lispy> mony quote zippy python?
20:00:11 <narain> ?go monty python quote zippy
20:00:13 <lambdabot> http://wc3.worldcrossing.com/webx?14@@.1ddedb82/120
20:00:13 <lambdabot> Title: dave barry for president - Favorite Dave Quotes
20:00:26 <dmwit> > zip "python" "quote"
20:00:28 <lambdabot>  [('p','q'),('y','u'),('t','o'),('h','t'),('o','e')]
20:00:55 <fantasma> what is up with this pattern on fibonacci
20:00:57 <fantasma> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)); foo [] = []; foo xs = take 3 xs : foo (drop 3 xs) in  map chr . filter (\x -> (x > 64 && x < 91) || (x > 96 && x < 123)) . map read . foo . show . foldl (\x y -> 10*x + y) 0 $ take 1000 fiblist
20:00:59 <lambdabot>  "peYpeYpeYpeYpeYpeYfdUnYY"
20:01:08 <dmwit> You say tomato, I say quotohtoe.
20:03:13 <dmwit> fantasma: There are as many "peY"'s as there are single-digit Fibonacci numbers.  Coincidence?
20:03:38 <fantasma> dmwit, yes, try it with take 39483
20:03:46 <fantasma> or any random number
20:03:51 <dmwit> No, I think not.  I think it is a CONSPIRACY at the HIGHEST LEVELS.
20:04:02 <narain> ?quote conspiracy
20:04:02 <lambdabot> mwc says: I can only believe that Java is a conspiracy perpetrated by keyboard manufacturers
20:04:04 <dons> ?yow!
20:04:04 <lambdabot> I need to discuss BUY-BACK PROVISIONS with at least six studio
20:04:04 <lambdabot> SLEAZEBALLS!!
20:04:15 <fantasma> wtf is peY
20:04:29 <sorear> take 3 peyton, *duh*
20:04:29 <dmwit> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)); foo [] = []; foo xs = take 3 xs : foo (drop 3 xs) in  map chr . filter (\x -> (x > 64 && x < 91) || (x > 96 && x < 123)) . map read . foo . show . foldl (\x y -> 10*x + y) 0 $ take 39483 fiblist
20:04:32 <lambdabot>  "peYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeYpeY...
20:04:54 <narain> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)); foo [] = []; foo xs = take 3 xs : foo (drop 3 xs) in  map chr . filter (\x -> (x > 64 && x < 91) || (x > 96 && x < 123)) . map read . foo . show . foldl (\x y -> 10*x + y) 0 $ take 1 fiblist
20:04:55 <lambdabot>  ""
20:04:59 <narain> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)); foo [] = []; foo xs = take 3 xs : foo (drop 3 xs) in  map chr . filter (\x -> (x > 64 && x < 91) || (x > 96 && x < 123)) . map read . foo . show . foldl (\x y -> 10*x + y) 0 $ take 2 fiblist
20:05:00 <lambdabot>  ""
20:05:08 <narain> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)); foo [] = []; foo xs = take 3 xs : foo (drop 3 xs) in  map chr . filter (\x -> (x > 64 && x < 91) || (x > 96 && x < 123)) . map read . foo . show . foldl (\x y -> 10*x + y) 0 $ take 3 fiblist
20:05:08 <lambdabot>  ""
20:05:11 <narain> what the heck?
20:05:17 <dmwit> It's the filter, man.
20:05:25 <dmwit> You've got to make them big enough.
20:05:27 <fantasma> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)) in take 10 fiblist
20:05:28 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
20:05:32 <narain> bah
20:05:35 <narain> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)); foo [] = []; foo xs = take 3 xs : foo (drop 3 xs) in  map chr . filter (\x -> (x > 64 && x < 91) || (x > 96 && x < 123)) . map read . foo . show . foldl (\x y -> 10*x + y) 0 $ take 10 fiblist
20:05:37 <lambdabot>  "p"
20:05:46 <narain> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)); foo [] = []; foo xs = take 3 xs : foo (drop 3 xs) in  map chr . filter (\x -> (x > 64 && x < 91) || (x > 96 && x < 123)) . map read . foo . show . foldl (\x y -> 10*x + y) 0 $ take 1024 fiblist
20:05:47 <lambdabot>  "peYpeYpeYpeYpeYpeYpEov"
20:06:00 <narain> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)); foo [] = []; foo xs = take 3 xs : foo (drop 3 xs) in  map chr . filter (\x -> (x > 64 && x < 91) || (x > 96 && x < 123)) . map read . foo . show . foldl (\x y -> 10*x + y) 0 $ take 1024 [1..]
20:06:02 <lambdabot>  ""
20:06:10 <fantasma> ...
20:06:17 <fantasma> why did that happen
20:06:28 <narain> well i tried not using the fiblist ;)
20:06:30 <zbrown> @source findIndices
20:06:30 <lambdabot> findIndices not available
20:06:37 <fantasma> it should have worked
20:06:37 <zbrown> :t findIndices
20:06:40 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
20:06:53 <jfoutz> > map ord "peY"
20:06:54 <lambdabot>  [112,101,89]
20:06:57 <zbrown> Hmmm what command tells me what class findIndices is in?
20:07:04 <dmwit> ?index findIndices
20:07:04 <lambdabot> Data.List
20:07:05 <dons> class?
20:07:10 <dons> ?hoogle find
20:07:10 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
20:07:10 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
20:07:10 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
20:07:15 <zbrown> dons: sorry couldn't think of the word
20:07:18 <narain> zbrown: module
20:07:20 <zbrown> module
20:07:21 <zbrown> thats it
20:07:29 <dons> @instances Monad
20:07:30 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:07:31 <zbrown> i hate those words, i know what im thinking, just cant get it out
20:07:36 <dons> that tells you want instances a class has :-)
20:07:57 <narain> dons: is there a converse of @instances?
20:08:07 <narain> @classes maybe?
20:08:07 <lambdabot> Unknown command, try @list
20:08:22 <dons> given a type, find out what classes it has?
20:08:25 <narain> yes
20:08:31 <dons> :info Int -- in ghci
20:09:12 <narain> not on lb?
20:09:31 <fantasma> what's another random sequence besides fib
20:09:46 <dmwit> fantasma: primes
20:09:54 <fantasma> good
20:09:54 <fantasma> thanks
20:10:00 <narain> fantasma: [1..] ? :)
20:10:08 <fantasma> that's not random lol
20:10:18 <narain> NOTHING is RANDOM
20:10:35 <fantasma> entropy = 0
20:11:12 <narain> primes is less succinct that fibs though
20:11:19 <narain> s/that/than/
20:11:30 <dmwit> Wow, ?wiki Blog_articles is definitely now firmly on my README list.
20:12:33 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
20:12:35 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:12:49 <Cale> > fix ((0:) . scanl (+) 1)
20:12:50 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
20:12:53 <narain> ah yes. right
20:13:02 <narain> i keep forgetting that one
20:13:13 <dmwit> narain: But beware, it's slow.
20:13:17 <lispy> ?pl nubBy (\x y -> y `mod` x == 0) [2..]
20:13:17 <lambdabot> nubBy (flip flip 0 . ((==) .) . flip mod) [2..]
20:13:26 <encryptio> > nubBy ((==0).flip mod) [2..]
20:13:27 <lambdabot>  Couldn't match expected type `a -> Bool'
20:13:32 <fantasma> what is that set?
20:13:42 <dmwit> ?pl \x y -> y `mod` x == 0
20:13:43 <lambdabot> flip flip 0 . ((==) .) . flip mod
20:14:06 <Cale> haha
20:14:08 <Cale> flip flip 0
20:14:11 <encryptio> > nubBy (((==0).).flip mod) [2..]
20:14:13 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:14:25 <fantasma> yummy primes
20:14:32 <Cale> yeah, clearly @pl could do better there
20:14:52 <fantasma> ?pl \x -> nubBy (((==0).).flip mod) x
20:14:52 <narain> pl doesn't use sections, does it?
20:14:52 <lambdabot> nubBy (((0 ==) .) . flip mod)
20:14:59 <narain> hm.
20:15:41 <narain> it knows (==0) is (0==)?
20:15:48 <sorear> yes
20:16:01 <sorear> @src nubBy
20:16:01 <lambdabot> nubBy eq []             =  []
20:16:01 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
20:16:12 <fantasma> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)); foo [] = []; foo xs = take 3 xs : foo (drop 3 xs) in  map chr . filter (\x -> (x > 64 && x < 91) || (x > 96 && x < 123)) . map read . foo . show . foldl (\x y -> 10*x + y) 0 $ take 1000 (nubBy (((==0).).flip mod) [2..])
20:16:14 <Igloo> It assumes it, at any rate  :-)
20:16:14 <lambdabot>  "vat"
20:16:19 <narain> does @pl do sections in general?
20:16:32 <sorear> correct.
20:16:43 <fantasma> the first 1000 primes = vat
20:16:49 <narain> fantasma: what is that function, anyway?
20:17:34 <fantasma> takes set on nums makes it one big num splits it ever 3 digits and returns chr value if in ascii range
20:17:38 <jfoutz> map ord "vat"
20:17:44 <jfoutz> > map ord "vat"
20:17:45 <lambdabot>  [118,97,116]
20:17:48 <fantasma> s/set on/set of
20:17:57 <narain> huh.
20:18:13 <fantasma> s/ever/every/
20:18:29 <Cale> that foldl (\x y -> 10*x + y) 0 will lose information if elements of the list are larger than 9
20:18:45 <fantasma> lol
20:18:48 <narain> which they certainly are
20:19:07 <fantasma> > foldl (\x y -> 10*x + y) 0 [10..100]
20:19:08 <lambdabot>  1123456790123456790123456790123456790123456790123456790123456790123456790123...
20:19:25 <narain> what we need is a bijection from N^N to N
20:19:35 <narain> bah, that doesn't exist
20:19:36 <dmwit> Not going to happen...
20:19:47 <sorear> > let lagfib = [0::Int ..607] ++ zipWith (+) (drop 607 lagfib) (drop 203 lagfib) -- could you use a real world pseudo random number generator?
20:19:48 <fantasma> what if
20:19:48 <lambdabot>  Parse error
20:20:06 <sorear> > let lagfib = [0::Int ..607] ++ zipWith (+) (drop 607 lagfib) (drop 203 lagfib) in drop 100000 lagfib -- could you use a real world pseudo random number generator?
20:20:06 <fantasma> > foldl (++) 0 [10..100]
20:20:08 <lambdabot>   add an instance declaration for (Num [a])
20:20:08 <lambdabot>     In the expression: 100
20:20:08 <lambdabot>  [-265464964,1805511198,-1353008095,-1493408342,-1686934079,1527019703,-15668...
20:20:12 <lispy> i bet i could use that bijection to solve the halting problem
20:20:23 <jaredj> wuah you folks are impossible to follow
20:20:33 <jaredj> whole screenful in like 30 sec
20:20:34 <fantasma> > foldl (++) 0 (show [10..100])
20:20:35 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
20:20:46 <fantasma> > foldl (++) '0' (show [10..100])
20:20:47 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
20:20:51 <jaredj> heh
20:20:56 <narain> jaredj: time for a bigger screen?
20:20:57 <sorear> > let lagfib = [0::Word ..607] ++ zipWith (+) (drop 607 lagfib) (drop 203 lagfib) in map (intToDigit . (`div` (maxBound `div` 10))) (drop 100000 lagfib) -- could you use a real world pseudo random number generator?
20:20:57 <lambdabot>  Couldn't match expected type `Int' against inferred type `Word'
20:20:59 <jaredj> >foldl (++) "0" (show [10..100])
20:21:17 <fantasma> > foldl (++) '0' (map show [10..100])
20:21:17 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
20:21:23 <fantasma> > foldl (++) "0" (map show [10..100])
20:21:24 <lispy> narain: i'm going to tell my boss i need a bigger monitor because #haskell scrolls too fast ;)
20:21:24 <lambdabot>  "010111213141516171819202122232425262728293031323334353637383940414243444546...
20:21:25 <glguy> > concatMap show [10..100]
20:21:25 <jaredj> narain: 1600x1200, the window is about 1100 pixels tall, ~8x16 font
20:21:26 <lambdabot>  "101112131415161718192021222324252627282930313233343536373839404142434445464...
20:21:28 <sorear> > let lagfib = [0::Word ..607] ++ zipWith (+) (drop 607 lagfib) (drop 203 lagfib) in map (intToDigit . fromIntegral . (`div` (maxBound `div` 10))) (drop 100000 lagfib) -- could you use a real world pseudo random number generator?
20:21:30 <lambdabot>  "946663660517767294737398996920478939316468061901884611169562471751825183107...
20:21:30 <jaredj> :P
20:21:39 <sorear> there.  Real prng.
20:21:50 <glguy> > show =<< [10..100]
20:21:51 <lambdabot>  "101112131415161718192021222324252627282930313233343536373839404142434445464...
20:21:57 <mauke> Real pron?!?!?!
20:22:08 <sorear> http://boost.org/libs/random/random-generators.html#lagged_fibonacci_spec
20:22:08 <fantasma> lol, glguy :(
20:22:10 <lambdabot> Title: Boost Random Number Library Generators, http://tinyurl.com/yt48eg
20:22:20 <sorear> period ~ 2^32000
20:23:02 <dmwit> sorear: I dare you to implement the Mersenne twister rng in Haskell. ;-)
20:23:06 <lispy> oh, maybe our universe is a prng and it resets when we exceed the period
20:23:20 <sorear> I just love the way a standard C++ random number generator can be expressed in 1 line of haskell :)
20:23:32 <dmwit> =)
20:23:37 * sorear accepts dmwit's challenge
20:23:55 <lispy> sorear: and yet, i couldn't describe some of our C++ bugs in 10 lines of haskell :)
20:24:47 <dmwit> sorear: It has ugly things, like "y ^= (y >> 11);" in it. =(
20:24:58 <fantasma> yes, primes
20:25:00 <fantasma> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)); foo [] = []; foo xs = take 3 xs : foo (drop 3 xs) in  map chr . filter (\x -> (x > 64 && x < 91) || (x > 96 && x < 123)) . map read . foo . foldl (++) "0" . map show $ take 1000 (nubBy (((==0).).flip mod) [2..])
20:25:02 <lambdabot>  "qGpIqLabvOwegnhjWmnanupsvoxpzqqqrrosstvxQYpqyyzqCYyIIIOcrsQewKOeLguMM"
20:25:23 <fantasma> don't need fiblist there though
20:26:05 <narain> "mnanupsvoxpzqqqrrosstv" ... this bit is almost readable
20:26:19 <lispy> rosstv!
20:26:26 <lispy> omg, i saw it on ross tV!
20:26:53 <jaredj> i heard it on manupsvox!
20:26:55 <glguy> ?quote nbbbd
20:26:55 <lambdabot> shapr says: Today's nifty error message: *Main> thread blotttchhhkrrreeeedaaa dddi   nbbbdllleooofcccikkkneeeidddt   eiiilnnnydddeeefffiiinnniiittteeelllyyy
20:27:14 <jaredj> yeah i didn't understand that last time either.
20:27:33 <jaredj> oh! is that like six threads talking at once?
20:27:33 <narain> that's an awesome error
20:27:33 <sorear> jaredj: three "thread blocked indefinitely"
20:27:34 <dmwit> "thread blocked indefinitely", but from four threads.
20:27:41 <dmwit> s/four/three/
20:27:44 <jaredj> ahhhh
20:27:48 <sorear> Cale++ I doubt you are human
20:27:49 <narain> four!
20:27:54 <jaredj> understanding dawns
20:28:03 <Cale> sorear: huh?
20:28:14 <fantasma> that would be a cool problem..finding the longest english word made from primes
20:28:18 <sorear> Cale: No human could have figured that out :)
20:28:22 <jaredj> you heard him, he's challenging you to a turing duel!
20:29:02 <dmwit> sorear: The losing information from 10x + y thing?
20:29:12 <lispy> what did Cale just do?
20:29:13 <Cale> oh, the error message :)
20:29:27 <lispy> heh, yeah that is crazy to figure out
20:29:42 <lispy> but i can see the definitely
20:29:55 <dmwit> I contend it is figure-out-able.
20:30:03 * narain nods towards dmwit
20:33:08 <dmwit> Errr... not to look down on Cale's achievements.  He's a definitely a Very Smart Guy.
20:33:33 * narain nods again
20:33:47 <Cale> hehe, I hadn't really considered it one of my better achievements anyhow.
20:34:30 <Cale> I knew what it said automatically when I looked at it, because I'd seen "thread blocked indefinitely" before.
20:40:29 <narain> ?quote
20:40:29 <lambdabot> Kahdloc says: why's it called filter and not grep? :/
20:40:29 <sorear> bah, mersenne twister is *so simple*
20:40:29 <dmwit> Oh, really?
20:41:37 <dmwit> I never took the time to figure it out after I saw ^= symbols...
20:41:37 <jaredj> yeah i think that one's the best ride in the park
20:41:37 <sorear> almost all the ugliness is just a simulation of laziness
20:41:37 <dmwit> Huh.
20:43:01 <Pseudonym> The MT is  just a feedback shift register.
20:43:18 <Pseudonym> With extra stuff to make it extra random.
20:44:58 <fantasma> happy pi day
20:45:13 <Pseudonym> It's not Pi day here any more.
20:45:28 <Pseudonym> So I'll give you the traditional greeting for 15 March instead.
20:45:28 <Cale> Still  day here for another 20 minutes.
20:45:31 <Pseudonym> Beware!
20:46:06 <Pseudonym> (Because if you can't make a literary joke here, where can you make it?)
20:46:36 <glguy> Pseudonym: I give up, where could you make it?
20:46:39 <fantasma> lol
20:46:39 <dmwit> Ide tell you, but then Ide have to kill you.
20:46:50 <jcreigh> who's Ide?
20:46:51 <fantasma> Ides of Marc
20:46:53 <Pseudonym> glguy: Err... I dunno.
20:46:54 <fantasma> March
20:46:58 <Pseudonym> #shakespeare, perhaps?
20:47:09 <jaredj> Pseudonym: haha
20:47:09 <dmwit> (Of course there had to be at least two of them, you see.)
20:47:10 <glguy> hmm, I haven't used that language
20:47:18 <jaredj> dmwit: omigosh
20:47:21 * jaredj stabs dmwit
20:47:33 * dmwit falls, flailing, to the floor
20:47:47 <jaredj> yes, fine, say your line
20:48:07 <dmwit> Nah, I think I'll leave you all in suspense. =)
20:48:08 <Pseudonym> Friends, Haskellers, lend me your eyes!
20:48:29 * Pseudonym gives up
20:48:38 <narain> Friends, Haskellers, languagemen!
20:49:59 * jaredj fthup fthup
20:50:18 * jaredj ploikh ploikh
20:50:21 <jaredj> there ya go
20:50:36 <dmwit> Is that some kind of Simlish?
20:51:43 <dmwit> Is there a "Most useful <blink> tag" award?
20:51:49 <dmwit> Because I'm pretty sure I found the winner.
20:52:14 <Pseudonym> dmwit: There hasn't been a nominee yet.
20:52:20 <Pseudonym> But by all means do enter.
20:52:22 <dmwit> http://alangloria.blogspot.com/2006/11/edit-graphs-im-currently-hacking.html
20:52:24 <lambdabot> Title: As L approaches Hack-Level, http://tinyurl.com/yrkn89
20:52:35 <dmwit> About 2/3 of the way down.
20:53:05 <Pseudonym> Oh, subtle!
20:53:10 <jcreigh> dmwit: wow...that's...not evil.
20:53:19 <dmwit> Pretty good, huh?
20:53:26 <dmwit> I like it a lot!
20:53:41 <jaredj> ah, cool, not bad
20:53:47 <dmwit> Okay, fair enough.
20:53:49 <encryptio> i don't see any blinking
20:53:59 <narain> encryptio: browser?
20:54:10 <encryptio> safari/webkit
20:54:11 <dmwit> encryptio: To the right of the edit graphs.
20:54:14 <narain> nice find, dmwit
20:54:15 <jcreigh> encryptio: it's being used to simulate a cursor...it doesn't really stand out.
20:54:39 <encryptio> ah, the pipe is supposed to be blinking, no?
20:54:41 <narain> not all browsers support <blink>, afaik
20:54:42 <Pseudonym> And it doesn't intrude on the example, either.
20:54:44 <narain> yes
20:54:47 <encryptio> kewl
21:22:16 <syntaxfree> I'm suddenly inclined to write a neural net.
21:22:27 <syntaxfree> Backprop stuff.
21:22:39 <syntaxfree> Should I go full ape declarative or use a matrix-based approach?
21:22:51 <glguy> has anyone been able to use ghc with vista?
21:23:01 <araujo> matrix-based
21:24:01 <syntaxfree> speccing matrix-based backprop is boring.
21:24:11 <syntaxfree> will the performance gain over using a monadic approach be hyge?
21:24:16 <syntaxfree> s/hyge/huge.
21:24:29 <jaredj> > 0 :: Vista -> Cool
21:24:30 <lambdabot>   Not in scope: type constructor or class `Cool'
21:24:33 <syntaxfree> forget monadic, I mean, passing over functions as arguments to functions and folding till stuff happens.
21:24:43 <jaredj> meh that didn't work
21:24:51 <syntaxfree> I once wrote a backprop net in GNU Octave.
21:24:54 <syntaxfree> Zzzzzz.
21:25:12 <jaredj> zz?
21:30:23 <encryptio> i learn so much from watching this channel
21:31:17 <jaredj> *crickets chirp*
21:31:26 <jaredj> :)
21:32:10 <encryptio> usually
21:32:43 <Pseudonym> Cardinal Richelieu died in 1642.
21:33:57 <jaredj> lol
21:34:22 <jaredj> i mean, uh, my condolences
21:34:27 <rashakil__> That's almost 1645!
21:34:31 <jaredj> my... belated condolences?
21:34:58 <Pseudonym> I didn't know the guy, personally.
21:35:45 <jaredj> heh
21:36:08 <jaredj> cardinal richelieu... was played by tim... uh...
21:36:39 <jaredj> whashisname. the rocky horror dude. once.
21:36:49 * jaredj imdbs
21:37:00 <nmessenger1> rashakil__: I'm reminded of a bash.org quote :3
21:37:02 <jaredj> tim curry
21:37:20 <rashakil__> :)
21:37:36 <Pseudonym> I love it how he's known as "The Rocky Horror Dude".
21:38:06 <jaredj> i didn't know him as that until i saw it
21:38:09 <jaredj> in college
21:38:12 <jaredj> it scarred me
21:38:34 <jaredj> i thought he was a great actor, i just didn't know he was so.... versatile
21:40:47 <Pseudonym> He's had a very varied career, that's for sure.
21:40:48 <encryptio> "The NewBinary package: An older binary serialization library ..."
21:41:17 <jaredj> ah, ha
21:41:21 <jaredj> http://www.bash.org/?2999
21:41:22 <lambdabot> Title: QDB: Quote #2999
21:41:33 <nmessenger1> :D
21:41:34 <jaredj> oh noes, now i'll browse bash.org for two hours
21:42:43 <encryptio> jaredj: nice coincidence that "that quote number is almost 3000!"
21:42:50 <jaredj> hehehe
21:43:22 <Pseudonym> Which is almost 3002!
21:43:39 <Pseudonym> Wow, what are the odds?
21:43:44 <jaredj> urrhh
21:43:51 <encryptio> sdf=====
21:44:02 <jaredj> > lart Pseudonym
21:44:03 <lambdabot>   Not in scope: data constructor `Pseudonym'
21:44:07 <encryptio> interesting typo. i missed the backspace key.
21:44:13 <Pseudonym> I think you want ?slap.
21:44:28 <jaredj> ?fish Pseudonym
21:44:29 <lambdabot> Maybe you meant: flush list
21:44:32 <jaredj> bagh
21:44:43 * Pseudonym has never been fished before
21:44:47 <jaredj> needs more projectiles
21:44:52 <Pseudonym> ?slap jaredj
21:44:52 * lambdabot slaps jaredj
21:44:56 <Pseudonym> There.
21:45:02 <encryptio> ?anvil Pseudonym
21:45:02 <lambdabot> Unknown command, try @list
21:45:17 <jaredj> what? it's irc. 80% of what makes irc irc is "* Foo slaps Bar around with a large trout."
21:45:22 <nmessenger> @adorablekitten encryptio
21:45:22 <lambdabot> Unknown command, try @list
21:45:33 <encryptio> awwww.
21:45:40 <Pseudonym> Oh, that's lovely.
21:45:46 <Pseudonym> http://cuteoverload.com/
21:45:47 <lambdabot> Title: Cute Overload! :)
21:46:10 <Pseudonym> I think the smiley in the title really does the trick there.
21:46:14 <jaredj> http://livejournal.com/community/splodefromcute/
21:46:32 <nmessenger> LOL INTARNETS!  *ahem*
21:49:33 * nmessenger endeavors to use ROFLCL sometime in the future.
22:02:47 <glguy> ?djinn (a -> b -> c) -> (a -> b) -> c
22:02:47 <lambdabot> -- f cannot be realized.
22:02:54 <glguy> ?djinn (a -> b -> c) -> (a -> b) -> a -> c
22:02:54 <lambdabot> f a b c = a c (b c)
22:03:16 <Pseudonym> i.e. the S combinator.
22:04:30 * glguy is working through the Coq tutorial
22:04:47 <ddarius> syntaxfree: I have (had?) some useless backprop code that used a backward state monad.
22:07:06 <jcreigh> "backward" state monad?
22:07:11 <jaredj> i'm in a backward state
22:07:24 <jcreigh> that can't possibly do what I think it does, right?
22:08:46 <ddarius> @google The Essence of Functional Programming
22:08:56 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps
22:14:41 <jcreigh> hmm...you know, there's a rough correlation between the extension of a document and the intelligence of the intended reader. compare/contrast .ps/.pdf vs. .html vs. .doc :)
22:16:38 <ddarius> Wadler papers tend to be very readable and entertaining.
22:19:29 <jcreigh> yes, I've gotten past the first page without getting lost, so it looks hopeful.
22:19:42 <jcreigh> ah, unitM == return
22:24:00 <dons> .ps.gz forever!
22:24:19 <dibblego> a new IQ test
22:25:58 <jcreigh> do you write your grocery lists on
22:26:04 <jcreigh> a: scrap paper
22:26:06 <jcreigh> b: text editor
22:26:10 <jcreigh> c: WYSIWYG editor
22:26:12 <jcreigh> d: TeX
22:26:24 <kc5tja> DUHH, (d) of course.  ;)
22:26:58 <dons> e:  literate (LaTeX) haskell
22:27:05 <emu> who writes grocery lists?
22:27:15 <pstickne> e: in my head (and then I forget when I actually get to the store)
22:27:55 <sorear> f: on the inside of my eyelids (jkoc)
22:28:31 <sjanssen> g: in blood
22:28:36 <ddarius> jcreigh: The paper is very old.
22:28:50 <nornagon> @where thunk
22:28:50 <lambdabot> thunk is now known as xmonad
22:28:54 <nornagon> @where xmonad
22:28:54 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
22:29:33 <sorear> yay typoes: Unable to retrieve http://planet.haskerl.org/:
22:29:46 <sorear> there should be a haskerl.org
22:29:55 <dmwit> Haskell + Erlang?
22:30:04 <sorear> @where haskerl
22:30:04 <lambdabot> I know nothing about haskerl.
22:30:07 <jcreigh> Haskell + Perl?
22:30:11 <sorear> dmwit: Perl, and AFJ
22:30:50 <sjanssen> so, Google has posted only six mentoring organizations for summer of code?
22:31:16 <fons> "1 mlOleg of brain" I wonder how to ever get that ;)
22:31:18 <fons> hehe
22:31:30 <sorear> @where tmr
22:31:30 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
22:32:39 <jcreigh> sjanssen: WRT to tiling in xmonad: Why would you need two stacks? Couldn't you just have one stack with the window layout order and an index into that which is the currently focused window?
22:32:56 <sorear> so, no tmr since oct2005?
22:33:05 <sorear> where's the xmonad artical then?
22:33:38 <allbery_b> haskerl should redirect to dev.pugs.org :)
22:33:42 <sjanssen> sorear: that wiki is outdated
22:33:52 <sorear> sjanssen: @where+!
22:33:59 <sjanssen> jcreigh: hmm, I had figured this out at one point
22:34:13 <zbrown> @where beer
22:34:13 <lambdabot> I know nothing about beer.
22:34:16 <zbrown> lies
22:34:26 <zbrown> where are you hiding it?!
22:34:28 <jcreigh> s/WRT to/WRT/ # grr..."PIN number" goof strikes again.
22:34:32 <kc5tja> @where girls
22:34:32 <lambdabot> I know nothing about girls.
22:34:42 <zbrown> @where sex
22:34:42 <lambdabot> I know nothing about sex.
22:34:43 <sorear> sjanssen: the google #1 for the monad reader points there :)
22:34:46 <kc5tja> There are lies, and there are DAMNED lies.  :)
22:34:54 <dons> jcreigh: i suppose we could use the tiling order as the stack order too, yes.
22:34:55 <sjanssen> sorear: yes, I'm having trouble finding the correct link
22:34:56 <zbrown> kc5tja: yes indeed
22:35:22 <zbrown> lambdabot: all your beer are belong to me!
22:35:45 * zbrown curses aurora linux for not having ghc
22:36:00 <sjanssen> jcreigh: yes, an index is sufficient for xmonad's current state
22:36:03 <sjanssen> nice catch!
22:36:24 <allbery_b> @wiki The_Monad.Reader
22:36:25 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
22:36:50 <dmwit> Does this mean xmonad has a workable tiling mode now?
22:36:50 <kc5tja> Ewww....those punctuation characters could never be remembered by me.
22:36:50 <allbery_b> yay mail archives
22:36:56 <sjanssen> dmwit: no
22:37:10 <kc5tja> dons: I'm slowly working up towards testing your code.  Stand by.  :)
22:37:15 <dmwit> Ah, not yet.  Okay.
22:37:16 <kc5tja> Maybe I won't blow away my partition this time.
22:37:39 <sjanssen> dons blew away your partition?
22:37:49 <dons> hope not.
22:38:16 <kc5tja> Oh, did he ever.  You should have seen it.  It was spectacular.  Lots of colored lights after the partition got up to altitude -- some people reported seeing UFOs -- it was a total fiasco.
22:38:32 <kc5tja> ;)
22:39:03 <jcreigh> the boot loader said "error reading area^Wsector 51"
22:39:19 <zbrown> hmmmm in a 20x30 room out of 5 million steps in time, two organisms only crossed paths 7339 times
22:39:20 <dons> heh
22:40:14 <zbrown> hmmm to go to bed... or work more on this code... or putz around with the sparc server... so many choices, so little time
22:40:22 <jcreigh> zbrown: organisms? Is this a random walk?
22:40:39 <sorear> dons is writing a haskell os?
22:40:39 <ddarius> zbrown: That's why the go to bed option is often omitted
22:40:52 <dons> why not?
22:41:04 * fons is going to bed, gnight
22:41:06 <zbrown> jcreigh: its a very crude model of a mosquito flying around a room and a human walking around a room
22:41:23 <zbrown> jcreigh: essentially if the human and mosquito are at the same place at the same time, the mosquito is 'biting' the human
22:41:47 <jcreigh> there's House...but I imagine when a Haskell OS really takes off, you'll boot it up, the hardware detection messages will fly by, and the prompt will say: "lambdabot> " :)
22:41:56 <nornagon> :D
22:41:57 <nornagon> @where X11
22:41:57 <lambdabot> I know nothing about x11.
22:42:02 <nornagon> :(
22:42:13 <jcreigh> nornagon: are you looking for the X11-Extras package?
22:42:17 <zbrown> eventually i'll write in some diffusion methods, basically if the mosquito is in a "circular" radius of 2 squares, then it will fly straight to the human then randomly fly off and not bite for a while
22:42:20 <dmwit> jcreigh: And it will only detect hardware as you need to use it.
22:42:40 <nornagon> oh: libghc6-x11-dev - Haskell X11 binding for GHC
22:42:40 <sjanssen> @hackage x11
22:42:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/x11
22:42:50 <sjanssen> @where x11-extras
22:42:50 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/X11-extras
22:43:00 <sorear> @hackage typo-detection-p
22:43:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/typo-detection-p
22:43:04 <sorear> :(
22:43:07 <sorear> night.
22:43:40 <jcreigh> dmwit: yes...to some, a powered-down computer is "off". To others, it's an unevaluated thunk.
22:44:02 <nornagon> oh, i need the x11-extras too :<
22:45:22 <jcreigh> what's the story behind x11-extras anyway? Does the x11 bindings just not have everything you need for a WM?
22:45:42 <zbrown> thats nifty... etch installer just froze my sun blade 100...
22:45:45 <jcreigh> (obviously so, since x11-extras exists. I guess this is probably the first Haskell WM)
22:45:46 <sjanssen> jcreigh: yeah, the x11 package is incomplete
22:46:22 <sjanssen> jcreigh: in the long term, I'll take all the stuff from x11-extras and submit it for inclusion in x11
22:47:11 <nornagon> sjanssen: bug!
22:47:13 <sjanssen> but seeing as every few tasks in xmonad require writing some new C bindings, it's just better to have this extra little package
22:47:14 <nornagon> in the README:
22:47:15 <nornagon>     If the aim of dwm is to fit in under 2000 lines of C, the aim of
22:47:15 <nornagon>     thunk is to fit in under 400 lines of Haskell with similar functionality.
22:47:27 <nornagon> shouldn't that be xmonad? :)
22:47:47 <glguy> any Coq users?
22:48:02 <sjanssen> nornagon: darcs pull :)
22:48:14 <nornagon> :)
22:48:23 * zarvok keeps meaning to learn coq
22:50:16 <nornagon> hm...
22:50:51 <nornagon> my .Xdefaults don't seem to have been loaded
22:51:14 <sjanssen> I don't think that's a window manager's job
22:51:29 <nornagon> well, something weird's going on
22:51:29 <dons> right.
22:51:36 <nornagon> because ion3 does it fine
22:51:44 <dons> what do your defaults do?
22:52:30 <nornagon> change colors in my xterm.
22:52:53 <sjanssen> nornagon: and to launch xmonad, what did you change?
22:53:15 <nornagon> in my .xinitrc, i changed ion3 to /home/nornagon/src/xmonad/dist/build/xmonad/xmonad
22:53:37 <Uncountable> > putStrLn "."
22:53:39 <lambdabot>  <IO ()>
22:53:55 <sjanssen> ion3 in your distro is probably a wrapper script that does this extra loading
22:54:25 <nornagon> hrm, i tried doing xrdb -merge ~/.Xdefaults
22:54:31 <nornagon> but it didn't work
22:56:09 <dons> nornagon: the second line of my .xsession file is xrdb -merge .Xresources
22:56:19 <dons> and the last line is: exec /home/dons/bin/xmonad
22:56:26 <dons> if that helps :-)
22:56:35 <nornagon> hmmm.
22:56:46 <nornagon> i'm putting this stuff in my .xinitrc, is there a difference?
22:57:13 <sjanssen> nornagon: there shouldn't be
22:57:17 <encryptio> i had a problem with the x11 bindings - wouldn't compile because it couldn't find the headers. they're in /usr/X11R6/include.
22:57:20 <nornagon> i tried putting that line before the exec
22:57:24 <nornagon> and restarting
22:57:30 <nornagon> but it's same as it ever was :(
22:58:06 <nornagon> ... ooooohhh
22:58:12 * nornagon changes 'xterm' to 'uxterm'
22:58:36 <encryptio> rather...
22:58:41 <encryptio> /usr/bin/ld: can't locate file for: -lX11
22:58:50 <nornagon> fixed!
22:58:52 <nornagon> hooray.
22:59:02 <nornagon> is it possible yet to have multiple windows on the same screen?
22:59:11 <nornagon> is the status bar implemented?
22:59:13 <dons> both visible?
22:59:16 <sjanssen> nornagon: fullscreen only at the moment
22:59:25 <dons> a) fullscreen only, b) no.
22:59:33 <nornagon> i see
22:59:42 <nornagon> not much use to me then, but nifty that it works :D
22:59:54 <dons> get a smaller monitor ;)
23:00:07 <nornagon> heh
23:00:11 <encryptio> how's the Xinerama support? =p
23:00:17 <sjanssen> dons: I've come to like not having a status bar
23:00:21 <dons> @slap encryptio
23:00:21 * lambdabot slaps encryptio
23:00:23 <nornagon> i couldn't live without ion3-style scratchpad stuff
23:00:28 <nornagon> statusbar is less important
23:00:28 <sjanssen> encryptio: nonexistent
23:00:28 * encryptio giggles.
23:00:30 <dons> sjanssen: yeah. i agree.
23:00:38 <nornagon> but it's nice to see what windows i have open
23:00:39 <dons> sjanssen: i'm thinking a more dmenu-style popup statusbar
23:00:49 <dons> since i only rarely want to check the time or battery status
23:00:58 <sjanssen> dons: exactly!  I was thinking the same thing earlier today
23:01:00 <dons> so i could hit mod-s or something, and it would display the statusbar
23:01:08 <encryptio> a statusbar is less useful if all you have running is a bunch of urxvts
23:01:23 <nornagon> mm
23:01:37 <nornagon> i'd rather just hold down meta and get my statusbar showing
23:01:41 <nornagon> or something
23:01:57 <nornagon> then use various keys to activate shiny and switch between my windows and stuff
23:02:07 <nornagon> eventually i'll end up writing my own window manager, probably
23:02:29 <sjanssen> nornagon: you're too cool for xmonad, eh?
23:02:31 <sjanssen> :)
23:02:43 <nornagon> :)
23:02:47 <dons> xmonad is too cool for nornagon
23:02:50 <nornagon> i'm not good enough at haskell yet
23:02:54 <nornagon> to make it do what i want
23:02:58 <encryptio> any ideas on how to solve my linking problem? (mac os x.4 ppc)
23:04:09 <encryptio> it can't find /usr/X11R6/lib/libX11.*
23:04:30 <zbrown> ahhh crap this is gonna suck
23:05:27 * zbrown is not excited to build an rpm of ghc for sparc linux
23:06:26 <zbrown> maybe it won't suck too hardcore...
23:09:28 <sjanssen> dons: we need to think about user configuration before 0.1
23:10:40 <sjanssen> we probably just need to move things around so user configuration is in one self contained area (ideally one source file)
23:12:02 <dons> yeah, Config.hs
23:12:11 <dons> that'd be enough.
23:12:39 <sjanssen> I'll write this in the TODO
23:13:24 <dons> cheers
23:16:05 <zeeeee> what's good introductory literature (incl. books) on how to design/implement a lazy functional compiler like ghc? (someone here referred me to 'spineless tagless g-machine' but i feel i need something that assumes less background)
23:17:17 <zeeeee> argh...windows nagging me to reboot...will be back in 20 minutes...thanks in advance for any replies (via lambdabot)
23:21:13 <dons> @tell zeeeee "Implementing functional languages: a tutorial"
23:21:13 <lambdabot> Consider it noted.
23:29:37 <dons> http://www.cse.unsw.edu.au/~dons/code/streams/
23:29:37 <lambdabot> Title: Index of /~dons/code/streams
23:29:44 <dons> is what dcoutts__ and I are up to :-)
23:31:45 <dcoutts__> @yarr!
23:31:45 <lambdabot> Get out o' me way, yeh landlubber
23:33:13 <zbrown> aww shit
23:41:01 <encryptio> dons: forgive my ignorance... what is it?
23:41:52 <dons> ah right. its a new Data.List
23:41:58 <dons> faster, cuter, more fusible
23:43:12 <newsham> cuter?
23:43:23 <dons> sure, why not? :-)
23:43:43 <newsham> we need to start a dons-gets-out fund
23:45:19 <nmessenger> "intercalate" :D
23:45:34 <dons> oh, we should try to fuse intercalate. that'd be fun fun
23:47:57 <glguy> instead of "genericLength"
23:48:09 <glguy> wouldn't "length" with a RULES for Int length be better?
23:48:23 <glguy> similar to what I see for minimum and maximum?
23:49:08 * encryptio still doesn't get it. why?
23:49:19 <glguy> you dont get what?
23:49:38 <glguy> why we have a specialize and generic length function named differently
23:49:41 <dons> glguy: with SPECIALIZE for Int, yes.
23:49:42 <encryptio> the point of the stream
23:49:45 <glguy> ah
23:49:47 <dons> but we still have t support H98
23:49:57 <dons> hysterical raisins
23:49:58 <glguy> bleh :)
23:50:05 <dons> ther was no SPECIALISE or RULES 9 years ago
23:50:13 <dons> and its bad when people's code breaks :-)
23:50:29 <dons> (we don't bother with manually specialise stuff in modern libs)
23:50:56 <dons> ?where streams
23:50:56 <lambdabot> http://haskell.org/haskellwiki/Library/Streams
23:51:04 <dons> oh, that streams lib
23:51:06 <dons> die die!
23:51:13 <dons> ?where+ list-streams http://www.cse.unsw.edu.au/~dons/streams.html
23:51:13 <lambdabot> Done.
23:51:15 <glguy> import Prelude (); import NotBrokenPrelude
23:51:17 <nmessenger> I don't find these hysterical raisins to be very funny :/
23:52:14 <dons> everyone loves hysterical raisin cake!
23:53:17 <glguy> :t zipWith7
23:53:19 <lambdabot> forall a b c d e f g h. (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
23:53:42 <nmessenger> so @src defines USE_REPORT_PRELUDE?
23:55:32 <kc5tja> @hoogle HasBounds
23:55:33 <lambdabot> Data.Array.IArray.HasBounds :: class HasBounds a
23:55:52 <glguy> > join (join (join (join (join (join (zipWith7 (,,,,,,))))))) [1..]
23:55:53 <lambdabot>  [(1,1,1,1,1,1,1),(2,2,2,2,2,2,2),(3,3,3,3,3,3,3),(4,4,4,4,4,4,4),(5,5,5,5,5,...
23:57:45 <kc5tja> Huh, Data.Array.IArray apparently no longer has a class called HasBounds.
23:57:55 <kc5tja> Trying to compile Darcs 1.0.8 with GHC 6.6, and it's failing.
23:57:58 <nmessenger> zipWithN f x1 x2 ... xn = map f x1 `zap` x2 `zap` ... `zap` xn where zap = zipWith ($)
23:58:06 <kc5tja> Lcs.lhs is claiming HasBounds doesn't exist.
23:58:45 <sjanssen> kc5tja: grab the development version tarball
23:58:46 <kc5tja> I executed strings on the Data/Array/IArray.hi file, and likewise didn't find the name "HasBounds" in it.
23:58:50 <sjanssen> 1.0.9rc2 or something
23:59:12 <kc5tja> Ahh, OK, so there is definitely a change in module interfaces then.
23:59:17 <sjanssen> yes
23:59:25 <kc5tja> Coo -- I was just wondering if I was going insane.  :)
23:59:27 <kc5tja> Heheh :)
