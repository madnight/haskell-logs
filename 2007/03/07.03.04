00:00:08 * wkh joins to get in on the internet drama
00:00:24 <cpfr> ditto
00:00:31 <sorear> not I.
00:00:33 * sjanssen is tempted to join, but doesn't want to look suspicious
00:00:49 <dons> nah.
00:00:51 <dons> i'm done.
00:00:58 * nmessenger cares not for looking suspicious
00:01:07 <dons> he gave up without a fight ;)
00:01:16 <nmessenger> :(
00:01:24 * nmessenger missed the action :'(
00:01:29 <dons> 18:48  triplah_> dons: i'm not about to fight you about h.
00:01:29 <dons> 18:49  triplah_> dons: since i know you'll beat me into the ground...
00:01:37 <dons> if that's not a white flag, ...
00:01:42 <ivanm> lol
00:01:57 <dons> dear oh dear, ivanm. its kinda evil to invite #haskell into a little channel
00:02:16 <ivanm> lol, we could do with the numbers for a change ;)
00:02:20 <ivanm> liven things up a bit
00:04:14 <sorear> dons: did you notice before that streams were codata?  was that the inspiration?
00:04:43 <dons> hmm. its been discussed a bit , yes.
00:04:47 <dons> I think rl knows this
00:05:03 <wkh> what are comonads and do i need to care about them for practical stuff?
00:05:42 <sorear> the dual structure to monads, and not yet.
00:05:55 <tessier> Not yet? Will we someday?
00:06:00 <sorear> perhaps.
00:06:04 <wkh> when would you need to care about them
00:06:18 <dons> never, at the moment
00:06:28 <sorear> rl = Roman uncopyable-last-name, coauthor of your icfp paper?
00:06:33 <dons> there's lots of abstractions in the universe, not all are in practice yet
00:06:33 <mwc> The OI comonad is kinda cool
00:06:38 <dons> sorear: right.
00:07:02 <nmessenger> as much as I know: monads package up environments, comonads describe values drawn from contexts
00:07:26 <mwc> what's the main function look like in the OI comonad again?
00:07:29 * nmessenger is extremely hand-wavy
00:07:59 <mwc> putStrLn :: OI String -> () seems like a scary way to write programs.
00:08:33 <mwc> if just becaue any value in your program will eventually be injected into the OI monad,
00:08:37 <mwc> this is true of the IO monad I suppose
00:09:13 <mwc> but what i mean is that if you have a pure functional part of your code, you can take values and the inject them into IO without harming the purity of the "backend."
00:09:37 <mwc>  but it seems off hand that if you have a comonad, every value is eventually drawn from this context, so all your backend would be in the OI monad.
00:09:52 <mwc> of course, that seems wrong but I can't put my finger on the problem
00:11:04 <rag3> I'm reading the wikibook. So far is the best I've seen.
00:12:28 <mwc> The arrows tutorial on the wikibook is pretty good
00:12:42 <mwc> I can definitely use one, I'm just not sure when I need to make something an arrow
00:13:25 <mwc> I have a good intuitive grasp on when I need a monad, I just don't have a clue when a sitatuation calls for an arrow
00:13:27 <mwc> any advice?
00:13:50 <Zeroth404> > let foo = "bar"
00:13:50 <lambdabot>  Parse error
00:14:13 <sorear> @let foo = "bar"
00:14:14 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
00:14:18 <nmessenger> > let foo = "bar" in foo ++ "baz"
00:14:19 <lambdabot>  "barbaz"
00:14:37 <Zeroth404> ...
00:14:52 <Zeroth404> > let foo = "bar" in foo
00:14:53 <mwc> dons doesn't want us cluttering up the environment with tons of bindings
00:14:53 <lambdabot>  "bar"
00:15:14 <mwc> Could you imagine the space that would chew up!
00:15:22 <nmessenger> mwc: er, @undef?
00:15:23 <Zeroth404> I didn't think it kept vars
00:15:33 <Zeroth404> > putStrLn (foo)
00:15:34 <lambdabot>   Not in scope: `foo'
00:15:37 <mwc> nmessenger, yeah, because I'd remember to do that :)
00:16:03 <mwc> I suppose we could appoint nmessenger as the official lambdabot binding clean-upper
00:16:08 <nmessenger> Zeroth404: it doesn't, but the LB command @let used to
00:16:38 <sorear> @ask ndm portability-wise, would it be acceptable to use Applicative in Mop?  support MonadTrans?  use an #ifdef?
00:16:38 <lambdabot> Consider it noted.
00:16:45 <nmessenger> joerandomuser: "@let x = foo", microseconds later: nmessenger: "@undef bitch!"
00:17:13 <mwc> rotflol
00:17:37 <nmessenger> don't you DARE pollute MY namespace, vermin!
00:17:54 <sorear> actually, lambdabot is already buggy enough this is unneeded
00:18:03 <sorear> it forgets anything it can
00:18:05 <sorear> @karma
00:18:05 <lambdabot> You have a karma of 24
00:18:12 <mwc> you could have a little war were you deleted people's bindings in the midst of their examples
00:18:15 <mwc> @karma
00:18:15 <lambdabot> You have a karma of -1
00:18:19 <mwc> Nope, forgets nothing :)
00:18:23 <sorear> ^^^ I have logs to prove I've received at least 40 karma in the past
00:18:46 <Zeroth404> > let nums = [4,4] in nums; foldl (+) 0 (nums)
00:18:47 <lambdabot>  Parse error
00:18:56 <rag3> @karma
00:18:56 <lambdabot> You have a karma of 0
00:19:05 <sorear> @karma audreyt
00:19:06 <lambdabot> audreyt has a karma of 212
00:19:11 <nmessenger> > let nums = [4,4] in foldl (+) 0 (nums)
00:19:12 <rag3> @karma dons
00:19:13 <lambdabot>  8
00:19:13 <lambdabot> dons has a karma of 125
00:19:20 <rag3> @karma lambdabot
00:19:21 <lambdabot> lambdabot has a karma of 41
00:19:24 <sorear> @topic-tell #perl6
00:19:24 <lambdabot> svn switch --relocate http://svn.openfoundry.org/pugs http://svn.pugscode.org/pugs/ | run.pugscode.org | spec.pugscode.org | paste: http://sial.org/pbot/perl6 | pugs.blogs.com | http://dev.pugscode.
00:19:25 <lambdabot> org/
00:19:32 <rag3> @karma -1 lambdabot
00:19:32 <lambdabot> -1 has a karma of 0
00:19:41 <Zeroth404> @karma
00:19:41 <lambdabot> You have a karma of 0
00:19:44 <Zeroth404> ?
00:19:49 <rag3> @karma-- lambdabot
00:19:50 <lambdabot> lambdabot's karma lowered to 40.
00:19:50 <sorear> Zeroth404--
00:19:54 <sorear> @karma Zeroth404
00:19:55 <lambdabot> Zeroth404 has a karma of -1
00:19:58 <sorear> Zeroth404++
00:20:01 <sorear> @karma Zeroth404
00:20:01 <lambdabot> Zeroth404 has a karma of 0
00:20:08 <rag3> I love this C++ syntax sugar
00:20:22 <nmessenger> @karma C
00:20:22 <lambdabot> C has a karma of 2
00:20:30 <Zeroth404> @karma haskell
00:20:30 <lambdabot> haskell has a karma of 20
00:20:31 <rag3> @karma xerox
00:20:31 <mwc> sorear, go grep for karma-- now :) You'll be pleasently suprised
00:20:32 <lambdabot> xerox has a karma of 26
00:20:39 <rag3> @karma hp
00:20:39 <lambdabot> hp has a karma of 0
00:20:40 <Zeroth404> @karma tcl
00:20:41 <lambdabot> tcl has a karma of 0
00:20:41 <rag3> :-)
00:20:45 <mwc> how does audreyt have a higher karma than dons?
00:20:48 <rag3> @karma ruby
00:20:48 <lambdabot> ruby has a karma of 0
00:20:53 <nmessenger> @karma java
00:20:53 <lambdabot> java has a karma of -16
00:20:58 <mwc> @seen audreyt
00:20:58 <lambdabot> audreyt is in #perl6 and #haskell. I last heard audreyt speak 1h 31m 40s ago.
00:20:59 <nmessenger> :)
00:21:03 * wkh suggests a richer set of metrics inspired by AD&D 3rd edition
00:21:05 <rag3> @karma++ Ruby
00:21:05 <lambdabot> Ruby's karma raised to 1.
00:21:08 <rag3> @karma++ Ruby
00:21:09 <lambdabot> Ruby's karma raised to 2.
00:21:13 <mwc> Huh, she actually speaks...
00:21:15 <sorear> stefan@stefans:~$ grep -r sorear-- /var/cache/stefan-downloads/irclogs/www.cse.unsw.edu.au/
00:21:16 <sorear> stefan@stefans:~$
00:21:25 <sorear> mwc: ^^
00:21:41 <mwc> I was kidding...
00:21:54 <mwc> I didn't expect you to actually download and grep
00:22:10 <sorear> mwc: just grep, the download is a couple weeks old
00:22:18 <sorear> mwc: (but newer than my karma loss)
00:22:36 <wkh> the topic of karma has stopped the usual flow of cute haskell one-liners
00:22:39 <nmessenger> @karma /me
00:22:39 * lambdabot has a karma of 0
00:22:41 <sjanssen> sorear: it'd be nice to run all the logs through lambdabot
00:22:50 <nmessenger> :D
00:22:55 <ivanm> nmessenger: lol
00:23:16 <sorear> sjanssen: unfortunately I seem to have been karma+'d in PM
00:23:16 <nmessenger> . /me-- /me--
00:23:28 <sorear> @karma /me
00:23:28 * lambdabot has a karma of -2
00:23:34 <sjanssen> I'm sure there are plenty of @remembered that are missing
00:23:36 <norpan> hey
00:23:43 <norpan> what if you do @karma /quit
00:23:54 <sorear> norpan: nothing
00:23:54 <dons> @flush
00:23:59 * nmessenger doesn't want to tempt fate
00:24:08 <wkh> @karma /quit
00:24:08 <lambdabot> /quit has a karma of 0
00:24:08 <mwc> nmessenger, how do you think I lost my karma point :)
00:24:11 <nmessenger> @help flush
00:24:11 <lambdabot> flush. flush state to disk
00:24:12 <sorear> norpan: irc servers don't pay attention to that kind of stuff
00:24:12 <dons> @karma /quit who cares? not me!
00:24:13 <lambdabot> /quit has a karma of 0
00:24:18 <norpan> sorear: i see
00:24:34 <sorear> norpan: /me is special lambdabot-internal magic
00:24:49 <sorear> @where+ echo PING 102093934
00:24:49 <lambdabot> Done.
00:24:56 <sorear> @where echo
00:25:03 <sorear> even easier.
00:25:11 <dons> yeah, so why don't I have a patch for that yet, sorear?
00:25:51 <wkh> dons,
00:25:52 <wkh> for (0, (< 10), (+1)) (
00:25:53 <wkh>             print "hello"
00:25:53 <wkh>        )
00:26:02 <wkh> in that example from a while ago, why does it matter that the body is lazily evaluated?
00:26:30 <sorear> wkh: it doesn't.  IO is not haskell usualness.
00:26:44 <sorear> wkh: in this case  laziness == tail recursion
00:26:54 <mwc> wkh, because if it were evaluated before entering the for, it would print once and then call for with () or unit
00:26:54 <sorear> wkh: schemishs would do as well
00:27:17 <wkh> mwc: well. then you could just make it like a thunk, a function with no parameters
00:27:41 <mwc> wkh, I think you mean a function with a don't-care parameter? f _ = ...
00:28:11 <mwc> that's a little wart that crops up in the MLs
00:28:46 <sorear> in Haskell, () -> x is always equivalent to Lift x
00:29:03 <nmessenger> @index Lift
00:29:03 <lambdabot> Language.Haskell.TH.Syntax
00:29:12 <sorear> where Lift x == x if you remember to use ~'s
00:29:14 <nmessenger> ooooooooo...
00:29:16 <sorear> and avoid seq
00:29:40 <sorear> if you avoid seq, () -> x == x
00:29:44 <Zeroth404> http://pastebin.ca/380752 -- whats wrong with my putStrLn call? (something to do withthe 'nums' var
00:30:42 <sorear> Zeroth404: what makes pastebin.ca better than hpaste?
00:30:47 <mwc> Zeroth404, show to convert a number to a string.
00:30:51 <Zeroth404> what's hpaste?
00:30:53 <sorear> we need to know so we can fix hpaste!
00:30:55 <sorear> @paste
00:30:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:31:04 <mwc> better yet, shows "This is a var: " $ show var
00:31:18 <Zeroth404> mwc what?
00:31:34 <mwc> Zeroth404, you're trying to append a number to a string
00:31:46 <mwc> what you want to do is first turn the number into a string, then concatenate them
00:31:53 <nmessenger> mwc: s/shows/showString/
00:32:10 <mwc> indeed
00:32:21 <dons> wkh, yes,you'd have to thunkify it to simulate laziness in a strict language
00:32:38 <Zeroth404> I dont follow
00:32:39 <dons> hence its more natural in haskell to write this kind of things: the user of the DSL doesn't have to know the host language is strict
00:32:49 <Zeroth404> I'm not using any strings...
00:32:50 * wkh meditates on what dons said
00:33:13 <Zeroth404> ah
00:33:28 <Zeroth404> I see
00:33:49 <nmessenger> Zeroth404: also I don't think line 18 needs the "read rest"
00:33:54 <nmessenger> just "rest"
00:34:08 <Zeroth404> probably right
00:35:07 <Zeroth404> got it
00:35:13 <Zeroth404> just took a "show" functoin
00:35:45 <nornagon> how good are haskell's SDL bindings?
00:35:56 <nornagon> @where hssdl
00:35:56 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL
00:36:22 <nornagon> @where sdl
00:36:23 <lambdabot> I know nothing about sdl.
00:36:27 * Zeroth404 says hello to YAHT chapter 4
00:36:32 <dons> cool
00:36:36 <dons> go Zeroth404 go!
00:37:02 <wkh> dons, how do you ever get any work done when you're on irc engaging in mentally taxing discussions?
00:37:26 <nornagon> @where hsdl
00:37:26 <lambdabot> I know nothing about hsdl.
00:38:11 <dons> wkh, i use a non-blocking concurrent runtime
00:38:30 <dons> and schedule irc jobs when other work threads are busy with computations
00:38:49 <dons> and its sunday, anyway, so i'm not doing much work.
00:38:58 <dons> actually, i'm pondering a quick blog article.
00:39:03 <wkh> i encourage that
00:39:26 <dons> who votes for "writing concurrent curses aps in haskell" or for "the programmable ; -- a monad introduction for the practical programmer" ?/
00:39:46 <wkh> can you run curses apps on windows? :(
00:39:50 <mwc> I'd like to read the latter
00:39:58 <dons> the third option is one on embedded imperative languages
00:40:05 <dons> e.g. like:
00:40:07 <dons> main = do {
00:40:07 * wkh votes for embedded imperative languages
00:40:07 <dons>     for (0, (< 10), (+1)) (
00:40:07 <dons>             print "hello"
00:40:07 <dons>     );
00:40:09 <dons>     for (0, (< 10), (+1)) (
00:40:12 <dons>             print "good bye"
00:40:15 <dons>     )
00:40:17 <dons> }
00:40:36 <nornagon> dons: would prefer another monad tutorial! :P
00:40:47 <dons> i've not written one, i realise...
00:40:50 <dons> which is a bit shocking.
00:41:15 <wkh> i was just about to say that yet another monad tutorial wouldn't be especially helpful to people like me struggling to figure them out most likely, if they're something you just have to tough out
00:41:15 <dons> so that's 2 for "The Programmable ;" ?
00:41:52 <wkh> imagine if two wolves and a sheep vote on what to have for dinner
00:41:54 <dons> so the exapmles i'd use are probably: error handling, network state, logging ,to disk, and maybe a symbol table
00:42:03 <dons> implemented monadically, and thus making the code simpler
00:42:24 <wkh> didn't wadler write something like that for his famous 92 paper "the essence of functional programming"?
00:42:45 <dons> i don't recall the examples. hmm. should check that.
00:43:00 <wkh> i was shocked to discover how approachable his papers are
00:43:18 <wkh> like an oasis in the desert
00:43:21 <dons> they're famously well written
00:43:32 <nornagon> link?
00:43:47 <Zeroth404> is YAHT actively maintained?
00:44:00 * Zeroth404 found a typo
00:44:12 <dons> it is, the wikibook version
00:44:19 <Zeroth404> I'm reading hte pdf
00:44:29 <nmessenger> @google yaht wikibook
00:44:32 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
00:47:06 <wkh> dons: if you write about wicked embedded bidnis, i'll be  your friend
00:47:07 <wkh> plz
00:47:37 <Zeroth404> hah
00:47:42 <Zeroth404> the typo exists in the wikibook as well
00:48:05 * Zeroth404 edits "Here, we can see that the number 5 can be instantiated as either an Int our a Double. What if we don't specify the type?"
00:48:09 <Zeroth404> s/our/or
00:49:17 <mwc> dons, btw, you're right, bang patterns are phenomenal
00:49:39 <dons> they really make strictness a lot esaier
00:49:56 <mwc> I have access to a 128-way Itanium2 SMP machine
00:50:45 <mwc> and a tech consultant with the cluster who's a huge geek for concurrent comp sci.... I think he'd endorse some benches on it if you can think of a good way to try it out.
00:51:04 <dons> wow. hmm!
00:51:06 <mwc> I would have already done it but I don't want to try getting ghc built on a weird Itanium bux.
00:51:07 <mwc> *box
00:51:09 <dons> i think we could really make use of thta.
00:51:22 <nornagon> neat
00:51:26 <dons> well, ghc does bootstrap on itanium.
00:51:31 <dons> and we even have binaries of old ghc's
00:52:15 <mwc> nornagon, that's a baby. You should see the rest of the cluster
00:52:32 <nornagon> :D
00:52:52 <mwc> http://www.sharcnet.ca/Performance/cur_perf.php
00:52:55 <lambdabot> Title: SHARCNET: Current Performance
00:54:59 <sorear> oh my
00:55:16 <sorear> any of those individually on the top500 list :)
00:55:22 <mwc> you know, I'd really like to see an Itanium code gen for GHC. I bet it would have a much better performance relative to C than on IA-32 or x86_64
00:55:28 <mwc> sorear, at some point in their career
00:56:22 <sorear> mwc: the #1, Blue Gene/L, iirc has 65536 commodity PowerPC64 procs.  so all else equal, requin is only 40x slower.
00:57:03 <mwc> Hmmm, I bet I think you missed a decimal place
00:57:23 <mwc> oh 40x
00:57:25 <mwc> I read 40%
00:58:58 <dons> mwc, hmm, so access to one of these machines?
00:59:14 <mwc> I have access to all of them
00:59:19 <dons> we're in the process of benchmarking the parallel array work this week
00:59:23 <mwc> but spinner and typhon are the SMP machines
00:59:40 <dons> and gathering scalability numbers on as many smp machiens as possible is the goal
00:59:48 <dons> with 16 or greater cores being of most use
00:59:50 <mwc> Does it matter if they're NUMA?
01:00:07 <mwc> because the 128 core one is NUMA, the non-numa one is only 16
01:00:17 <dons> i'm not sure. they need to run ghc's runtime, but i'm not sure what the requirements are for it
01:00:44 <mwc> Well, iirc, each proc can see the entire memory space, but parts of it are faster than others.
01:00:58 <dons> ah right. not sure that matters
01:01:05 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/790#a1
01:01:09 <dons> how would we go about getting access?
01:01:53 <hpaste>  Thomas` pasted "(no title)" at http://hpaste.org/791
01:02:17 <mwc> Officially, only members of the instituions in there should be doing research on it. I know a tech there who's quite a fan of concurrent programming and would probably let me run a quick job on the side
01:02:17 <thartman> how do I do "make this a list" as infix. Eg, I don't just want to put it in [].
01:02:49 <mwc> Or I could run a test job for "debugging purposes"
01:02:54 <dons> oh ok. the ghc smp benchmarks are pretty short, but they are fiddly, and require getting ghc built
01:03:08 <therp> thartman: [1,2,3] -> 1:2:3:[] ?
01:03:21 <dons> > 1:2:3:[]
01:03:22 <lambdabot>  [1,2,3]
01:03:29 <thartman> find -maxdepth 1 -type f | xargs du |  ghc -e 'interact $ show . sum . map ( ( read :: String -> Integer ) . head . words ) . lines '
01:03:44 <thartman> this works, only I want to print it with a linebreak after.
01:03:45 <dons> oh, that's cute.
01:03:57 <rag3> > find -maxdepth 1 -type f | xargs du |  ghc -e 'interact $ show . sum . map ( ( read :: String -> Integer ) . head . words ) . lines '
01:03:57 <lambdabot>  Parse error
01:04:08 <dons> (++"\n") . show . sum .
01:04:15 <thartman> I mean, it works as a bash one liner :)
01:04:18 <mwc> wow, I didn't know ghc came with a -e option
01:04:21 <sorear> @ty liftM2 fmap
01:04:21 <dons> sure.
01:04:24 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a) -> m (f b)
01:04:36 <mwc> my shell scripts may never be the same
01:05:04 <sorear> @ty ap . liftM liftM
01:05:06 <lambdabot> forall a1 r (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 (a1 -> r) -> m1 (m a1) -> m1 (m r)
01:05:23 <sorear> @ty ap ap
01:05:24 <hpaste>  Thomas` pasted "(no title)" at http://hpaste.org/792
01:05:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m (a -> b) -> m a) -> m (a -> b) -> m b
01:06:11 <thartman> yeah, dons, I guess that's a better way to do it.
01:06:17 <sorear> hm.  where are all these xhtml things coming from?
01:07:01 <sorear> bd_: http://hpaste.org/790 <- ?
01:07:20 <sorear> @seen bd_
01:07:20 <bd_> sorear: I was demonstrating some haskell stuff on another channel, and the people there didn't listen to me when I said not to check announce :)
01:07:20 <lambdabot> bd_ is in #haskell. I last heard bd_ speak 2h 39m 42s ago.
01:07:30 <sorear> ok.
01:07:36 <sorear> I'll relax then.
01:08:00 <sorear> won't worry about speed deleting em :)
01:08:03 <bd_> heh
01:08:22 <bd_> they also ignored the bit about 'click annotate, not new post' >.>;
01:09:10 <dons> i suspect we'll have to make the announce bit registered nicks only
01:09:18 <dons> as the use grows
01:09:46 <bd_> I'd have used another pastebin, but all the others I know take about three minutes to post anything :/
01:11:51 <sorear> dons: monochrom, etc
01:12:14 <cpfr> hey what is a good haskell library for displaying images
01:12:43 <rag3> can someone explain to me what the return keyword is used for when working with actions?
01:12:45 <sorear> none really
01:13:03 <mauke> rag3: "return" wraps a value in an action
01:13:08 <mauke> rag3: and it's not a keyword
01:13:22 <sorear> cpfr: you can use Gtk2Hs etc for a full gui.
01:13:51 <rag3> mauke: I'm confused. what does it mean that it wraps a value, isn't the same as passing a parameter to an action?
01:13:51 <sorear> rag3: speak up now! dons is threatening to make hpaste only announce for registered nicks. :)
01:14:05 <rag3> I agree
01:14:15 <mauke> rag3: do you know what an action is?
01:14:36 <rag3> mauke: I think so... do putStrLn "something"
01:14:42 <mwc> actually, dons, reading up on that machine, it's still running a 2.4 kernel. 2.5 was when they added NUMA-aware scheduling and memory management. Right now it seems that it's meant for *small* smp jobs, where small means that you stay within the CPU and memory of a given node.
01:15:15 <rag3> sorear: I agree with the announce limitation for registered users only. less prone to abuse I think.
01:15:32 <mauke> rag3: an "action" is a data structure that describes some I/O
01:16:02 <mauke> e.g. putStrLn takes a string and gives you an action that (when executed) outputs a string
01:16:09 <sorear> rag3: my irc client says: <*rag3> where * is the freenode-specific flag for "unregistered user"
01:16:27 <rag3> ok mauke, I understand the IO () thing
01:16:33 <rag3> sorear: I'm not registred
01:16:34 <cpfr> so sorear gtk2hs or none really
01:16:44 <rag3> sorear: but I would register if this would be enforced
01:16:49 <sorear> rag3: hence why you would speak up, as opposed to anyone else :)
01:16:55 <mauke> rag3: and (return x) gives you an action that doesn't do any I/O but returns x
01:17:05 <sorear> cpfr: PBM is also a good choice. man 5 pbm
01:17:36 <rag3> sorear: I've been asked, and I've answered. Also, I do not vote in favour of something because it gives me the best gain. I vote for something because it's right.
01:17:48 <rag3> :)
01:18:04 <rag3> mauke: thanks
01:18:23 <mauke> actually, "return" isn't specific to IO
01:18:39 <cpfr> sorear, these are photos
01:19:26 <sorear> cpfr: ppm then, if you can stand the lack of compression :(
01:20:49 <cpfr> ok ..
01:22:08 <dons> sorear: i didn't mean 'identified to freenode' users
01:22:14 <dons> i meant, registered with us on a list in this channel
01:22:26 <dons> ie. something like @i-am-real
01:22:30 <rag3> I'm reading the Haskell wikibook. It's really well done. Often it states the obvious, but overall is a good way to learn the essentials of Haskell without forgetting anything too important. Do you agree?
01:22:34 <dons> adds nick/ip to ist, hpaste uses that list
01:22:50 <dons> yeah, its a good resource, rag3
01:23:01 <rag3> thanks dons
01:23:58 <sorear> dons: We need to make hpaste worldwide usable.  I notice #darcs, #perl6, have private pastebins now.
01:24:21 <sorear> everyone should be able to usefully use hpaste!
01:25:07 <rag3> sorear: I think hpaste has good usage even outside of IRC
01:25:48 <rag3> sorear: imagine, you want to post nice haskell code in your blog... it would be cool if there was an option to obtain embedded html and css
01:26:33 <sorear> actually the coloring engine hpaste uses is a separate third-party program, usable as a lib or a filter
01:26:37 <sorear> @where hscolour
01:26:38 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
01:26:57 <rag3> but now that you make me thing about it, maybe the registration is not too much of a brilliant idea. Many people who needs help are newbies
01:27:16 <rag3> and very likely not to be registered with @i-am-real
01:27:30 <norpan> @i-am-real
01:27:31 <lambdabot> Unknown command, try @list
01:28:06 <sorear> maybe have lb auto add on join?
01:33:12 <_roconnor> what ever happened to the haskell revolution tshirts?
01:33:24 <_roconnor> or maybe lambda revolution
01:33:45 <wkh> i'm going to a local technology event and i will angrily ask why there are stickers for the php, java, ruby etc people but none for any in the ML/lisp families
01:34:15 <_roconnor> http://www.cafepress.com/l_revolution.96543210
01:36:07 <|Lupin|> Hello #haskell
01:36:14 <wkh> hi
01:36:25 <|Lupin|> Please, what doesthe =<< operator mean ?
01:36:42 <wkh> it flips around monad binding, yeah?
01:36:46 <mauke> =<< is flip (>>=)
01:36:52 <wkh> yay i got something right!
01:37:42 * |Lupin| is really a newbie in haskell. not even that actually.
01:38:03 <|Lupin|> let insert x [] = [[x]] ; insert x (y:ys) = (x:y:ys) : map (y:)
01:38:03 <|Lupin|> (insert x ys) ; permute [] = [[]] ; permute (x:xs) = insert x =<<
01:38:03 <|Lupin|> permute xs
01:38:16 <|Lupin|> Not sure about themeaning of theoperator in this example...
01:38:17 <mauke> holy
01:38:39 <wkh> what were you trying to do?
01:39:10 <|Lupin|> this example was given to me here yesterday. It computesThe permutations of a list of elemens.
01:39:17 <mauke> |Lupin|: =<< is just concatMap here
01:39:17 <|Lupin|> I tr to translate it into OCaml
01:39:58 <|Lupin|> mauke: Okay. Is concatMap similar to fold for instance ?
01:40:36 <mauke> depends on your definition of "similar"
01:40:46 <mauke> it does stuff with lists
01:41:17 <|Lupin|> k
01:41:39 <mauke> let concat_map f xs = List.concat (List.map f xs);;
01:42:31 <wkh> have you guys looked at CAL from business objects?
01:44:36 <|Lupin|> mauke: I'Asurprised that List.concat takes only one argument. I thought it would take two liste and return their concatenation.
01:45:17 <|Lupin|> oh no I see: concat takes a list of lists and concatenates all ofthem. Hight ?
01:45:31 <mauke> right
01:45:37 <|Lupin|> great
01:45:40 <|Lupin|> thanks a lot all !
01:45:49 <|Lupin|> This is called flatten in Caml :-)
01:46:04 <mauke> or concat
01:46:11 <mauke> both List.concat and List.flatten exist
01:46:52 <nornagon> Graphics/UI/SDL/Rotozoomer.hs:15:7: Could not find module `Foreign.C':
01:46:53 <nornagon> :/
01:47:00 <|Lupin|> didn't know about List.concat...
01:49:34 <nornagon> "it is a member of package base, which is hidden"
01:49:36 <nornagon> wtf?
01:49:46 <Korollary> using cabal?
01:49:48 <nornagon> is this hssdl thing supposed to work? >_>
01:49:54 <nornagon> i don't believe so
01:50:13 <wkh> why does the haskell webpage link to "research papers" under the "getting started" section?
01:50:21 <nornagon> oh wait
01:50:22 <nornagon> yes
01:50:25 <nornagon> it is using cabal
01:50:48 <wkh> do they think people learn programming languages by reading research papers that assume you already understand the language?
01:50:58 <Korollary> inspect the build-depends section of the cabal file. It may be missing base.
01:51:07 <sorear> @remember wkh why does the haskell webpage link to "research papers" under the "getting started" section?
01:51:07 <lambdabot> Done.
01:51:35 <mauke> wkh: yes :-)
01:51:39 <sorear> wkh: haskell in isolation is very simple and boring.
01:51:49 <wkh> simple?!
01:51:55 <nornagon> Korollary: base isn't there, only SDL
01:52:01 <nornagon> but i tried adding base and same
01:52:05 <mauke> @keal
01:52:05 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
01:52:16 <sorear> wkh: but you can only Do Stuff with the library features (e.g Monads), and those are described mainly in papers
01:52:16 <Korollary> wkh: Unfortunately some of the stuff is still in research paper form. However, many of those papers are written almost for a beginner.
01:52:16 <mauke> wrong quote :(
01:52:28 <wkh> oh
01:52:40 <wkh> well yeah i've seen quite a few papers that i could follow parts of
01:53:50 <Korollary> nornagon: did you do config step again?
01:54:18 <nornagon> ... nope :D
01:54:20 <nornagon> it works now
01:54:22 <nornagon> thanks!
01:54:25 <nornagon> oh wait
01:54:25 <nornagon> gr
01:54:49 * nornagon fiddles
01:55:21 <nornagon> yay
01:57:44 <|Lupin|> bye everybody. Thanks a lot for your assistance.
02:06:22 <mwc> Cripes, what a night mare
02:06:39 <mwc> took me 4 hours to find where I'd put the wrong two parameters into a function
02:12:14 <sorear> night.
02:13:06 <roconnor> anyone have an implementation of newton's root finding method lying around?
02:14:48 <mwc> roconnor, actually... yes
02:15:17 <mwc> you'll need:
02:15:18 <mwc> iter_fp _ x0 _ 0 = (x0,0)
02:15:18 <mwc> iter_fp f x0 tol n = let x' = f x0 in if tol >= abs (x0 - x') then (x',n)
02:15:18 <mwc>     else iter_fp f x' tol (n - 1)
02:15:30 <mwc> and g u = u - (f u)/(f' u)
02:16:01 <mwc> then newtons method is just iter_fp g x0 tol maxN
02:16:47 <roconnor> shouldn't there be a deriviative in there somewhere?
02:17:03 <mwc> yeah, in g... f is the function you're finding roots of, f' is its derivative
02:17:46 <roconnor> oh
02:18:03 <roconnor> you really just need this function g?
02:18:06 <roconnor> cool
02:18:42 <mwc> nope. iter_fp is a general thing that finds the fixed point of a function f proceeding by iterating from x0 until the tolerance is reached or a given number of iterations is exceeded
02:18:57 <mwc> newton's method is just finding the fixed points of g.
02:19:11 <roconnor> yep, I get it
02:19:38 <roconnor> I'm gonna try it out
02:20:23 <mwc> it it breaks, let me know, because there's a Finnish prof who's probably laughing his ass off at me behind my back...
02:20:28 <nornagon> whee, got hssdl doing a hello world-ish thing
02:20:37 <nornagon> just the basic black screen, quit on Q
02:21:10 <nornagon> i wish i knew how to use Reader properly, i'm passing the video surface around everywhere
02:21:33 <mwc> Reader is pretty easy to use
02:21:56 <mwc> in the monad, do video <- ask to grab the video surface
02:22:23 <mwc> then in when you call the entire computation, do: myComputation `runReader` videoSurface
02:22:34 <mwc> where myComputation has type Reader Video a
02:22:44 <nornagon> how does that interact with IO?
02:23:01 <mwc> what you'll want then is ReaderT Video IO a
02:23:09 <mwc> and you'll still use ask to grab the video stuff
02:23:10 <nornagon> I see.
02:23:23 <mwc> but for IO actions, you'll need to do lift $ ioActoin
02:23:52 <mwc> or lift ioAction if it's a value, but more than likely it'll be lift $ ioAction foo bar
02:24:01 <nornagon> so, something like type ScreenR = ReaderT Surface IO a
02:24:11 <mwc> yep
02:24:51 <mwc> so to get an IO a action out of a value of type ScreenR, you'll do: screenAct `runReaderT` surface
02:25:07 <nornagon> then myComputation has type ScreenR -> what?
02:25:32 <mauke> type ScreenR a =ReaderT Surface IO a
02:25:41 <mauke> myComputation :: a -> ScreenR b
02:25:47 <mauke> or just ScreenR b
02:25:53 <mwc> Well, your functions that are in that monad should have types like foo :: Bar -> Baz -> ScreenR Quo
02:26:06 <nornagon> ah, okay.
02:26:53 <nornagon> @index ReaderT
02:26:54 <lambdabot> Control.Monad.Reader, Control.Monad.RWS, Control.Monad.Reader, Control.Monad.RWS
02:27:50 <audreyt> is there a better way to do a series of try-typecasts?
02:28:06 <audreyt> fromTypeable x f1 f2 ... | Just x' <- Typeable.cast x = f1 x' | Just x' <- Typeable.cast x = f2 x' | ...etc etc...
02:28:10 <audreyt> er, soryr.
02:28:28 <nornagon> er, import Control.Monad.Reader doesn't work :|
02:28:36 <mauke> how does it not work?
02:28:42 <nornagon> Could not find module `Control.Monad.Reader':
02:28:47 <mwc> nornagon, chances are you're compiling it strangely
02:28:56 <mwc> you need to add mtl
02:29:04 <nornagon> Prelude> :m +Control.Monad.Reader
02:29:04 <mwc> so -package mtl on oyur ghc command line
02:29:07 <nornagon> i see.
02:29:11 <mwc> unless you're using --make
02:29:18 <nornagon> i'm not.
02:29:28 <mwc> nornagon, use --make :)
02:29:29 <roconnor> mwc: works on a simple example
02:29:36 <roconnor> boy, I didn't remember it was so easy
02:29:49 <nornagon> mwc: i'm using runhaskell atm :P
02:29:54 <nornagon> but installing mtl worked
02:29:54 <mwc> works too
02:30:43 <mwc> audreyt, are those pattern guards?
02:30:48 <audreyt> mwc: those are
02:30:51 <nornagon> yay, it works
02:30:52 <nornagon> thanks :)
02:31:00 <audreyt> the idea is that I have several functions that each take one specific monotype
02:31:09 <audreyt> I want to try them on a single Typeable something
02:31:14 <audreyt> and see if any one matches
02:31:45 <audreyt> I'd like to make this variadic, or in any case somehow pack f1/f2/f3 etc into one list
02:31:48 <audreyt> without going through TH
02:32:11 <mwc> Let me read up on pattern guards, but off hand, maybe the Maybe monad and foldM could do the trick?
02:32:33 <audreyt> maybe...
02:34:13 <nornagon> hm, SDL_gfx hasn't been bound into hsSDL :(
02:35:08 <mwc> audreyt, hmm, I get it now.
02:36:57 <mwc> audreyt, http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html#v%3AfunResultTy looks kinda promising
02:36:59 <lambdabot> http://tinyurl.com/ylclo5
02:38:02 <audreyt> I see.
02:38:04 <audreyt> mwc++
02:38:54 * audreyt pines for easy-to-use dependent types
02:40:50 * matthew-_ wonders whether that's a contradiction-in-terms
02:43:13 <nornagon> what's a .hsc?
02:44:42 <mwc> audreyt, yuck. I was playing around with it myself. mkFunTy is about as much fun as a porcupine on speed.
02:44:59 <mwc> nornagon, iirc, it's used to bind C to Haskell.
02:46:19 <zenpro> nornagon: http://haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
02:46:20 <lambdabot> Title: 10.3. Writing Haskell interfaces to C code: hsc2hs
02:47:20 <mwc> zenpro, beat me!
02:47:40 <zenpro> mwc : :)
02:48:41 <audreyt> matthew-_: that depends :)
02:53:33 <zenpro> An interesting small article by Tim O'Reilly: http://radar.oreilly.com/archives/2007/03/concurrent_prog_1.html
02:53:34 <lambdabot> Title: O'Reilly Radar > Concurrent Programming: Erlang, Haskell...and XSLT
03:03:22 * mwc finishes writing a FEM solver entirely in Haskell
03:04:29 <mwc> Next up... lambdaBLAS :)
03:04:35 <opqdonut> FEM?
03:04:43 <mwc> Finite Element Method
03:04:47 <opqdonut> kk
03:05:31 <mwc> unless you're an engineer or an applied mathematician, the details are interesting in the same way as the minutiae of exactly what your spleen does.
03:06:06 <opqdonut> hehe
03:06:31 <nornagon> ooh, yay!
03:06:38 <Stinger> ooh I wouldnt mind learning how to do some FEM
03:06:39 <nornagon> my first foreign function interface :)
03:06:49 <nornagon> figgered it by peering at other sdl stuff
03:09:52 <nornagon> Lemmih: I may have patches for you at some point in the not-so-far-away future
03:11:45 <mwc> @seen Lemmih
03:11:45 <lambdabot> Lemmih is in #oasis and #haskell. I don't know when Lemmih last spoke.
03:11:55 <mwc> nornagon, you sould probably @tell him
03:12:07 <mwc> @tell nornagon like this
03:12:08 <lambdabot> Consider it noted.
03:12:15 <nornagon> yeah, i know how @tell works :)
03:12:15 <lambdabot> nornagon: You have 1 new message. '/msg lambdabot @messages' to read it.
03:12:47 <nornagon> @tell Lemmih I'm in the process of writing bindings for SDL_gfx, expect patches (I hope!)
03:12:48 <lambdabot> Consider it noted.
03:14:38 <thartman> I'm trying to install hsplugins and find myself chasing dependencies, eg multiple darcs get and builds. is there some way to get this to happen automatically?
03:15:45 <thartman> (I'm trying to make it easier to tweak haskell to be a mean bashscripting one-liner machine.)
03:16:09 <mwc> thartman, wait for cabal's packaging system?
03:16:15 <mwc> cabal-install
03:16:20 <mwc> coming real soon now, they promise!
03:16:36 <thartman> but not currently available? so till then, keep apt-getting ?
03:16:42 <mwc> yep
03:16:43 <thartman> I mean, darcs getting?
03:16:46 <thartman> ok
03:17:08 <thartman> I hope they get that packaging system right. would be awesome.
03:18:30 <mwc> Uhm... I kinda dread using it with my packaging system
03:18:54 <mwc> I don't have anything installed outside my home dir that's not tracked and monitored by the package manager
03:21:36 <kuribas> Why isn't it possible to do "let (a%b) = (1%2) in a"?
03:21:44 <mauke> because % is not a constructor
03:21:58 <JohnMeacham> I wrote a nice set of algorithms. I want to make them part of haskell. but Algorithms.* seems a bit presumptuous. they consist of a cleverish class+GADT system to specify problems, and a variety of optimization and root finding algorithms. I hope to add some constraint solving ones too. they are pretty neat IMHO. how many easy problems can be trivillay expressed as an optimazion problem? many. but in other languages, aac
03:21:58 <JohnMeacham> tually doing it is hard. but in haskell. just knowing it is an optimization problem is more than enough to just do it. this language is nice this way. yay.
03:22:01 <mauke> (constructor names start with an uppercase letter or :)
03:22:23 <thartman> how do I get around this? Setup.lhs: cannot satisfy dependency haskell-src-any
03:22:46 <thartman> I'm using ghc 6.6, compiled from source.
03:23:08 <nornagon> so, am I missing something, or is hsSDL the place to be for SDL bindings?
03:23:08 <kuribas> mauke: Oh, I see.  What is the constructor for a Ratio?
03:23:21 <mauke> kuribas: it's not public
03:23:24 <JohnMeacham> perhaps I should post to libraries@.. but right now, I am thinking Algorithms.Optimize Algorithms.RootFinding. and   Algorithms.Constraint with examples being Algorithm.Optimize.BruteForce Algorithms.Optimize.Linear Algorithms.Optimize.HillCliming etc...
03:23:36 <mauke> you have to use functions to extract the components
03:23:42 <thartman> that was installing dons's hs-plugins...
03:23:46 <JohnMeacham> hrm.
03:24:01 <kuribas> mauke: hm, they are very verbose.  (numerator, denominator).
03:24:26 <mauke> you could make shorter aliases
03:24:54 <mauke> parts r = (numerator r, denominator r)
03:25:03 <mauke> let (a,b) = parts (1%2)
03:25:47 <kuribas> mauke: yes, good idea!
03:26:25 <nornagon> are there other SDL bindings for haskell than hsSDL?
03:30:48 <mwc> JohnMeacham, maybe a Numerics.*
03:31:00 <mwc> I'm thinking it's about time to start work on lambdaBLAS
03:31:27 <opqdonut> :)
03:36:48 <mwc> @hoogle a -> [a]
03:36:49 <lambdabot> Prelude.repeat :: a -> [a]
03:36:50 <lambdabot> List.intersperse :: a -> [a] -> [a]
03:36:50 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
03:45:18 <Igloo> dons: Linker.c should only be needed for GHCi
03:51:36 <JohnMeacham> mwc: but a lot of them are about combinatorical optimization. And. .well. on another note. these are pretty advanced algorithms. haskell has the power to make them trivila to use. even a students first program can use a first-rate graph layout algorithm in haskell.. I'd like the usage to expand well beyond numerics. that these tools have been regelated to that field is a weakness haskell can pounce on.
04:01:43 <Saizan> ?docs
04:01:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
04:02:32 <Saizan> John, do you have a repo?
04:06:05 <TSC> If I have a simple type like "data Pixel = Pixel Word16 Word16 Word16", is it hard to make an unboxed array of such pixels?
04:06:55 <nornagon> @index Int16
04:06:55 <lambdabot> Data.Int, Foreign
04:08:26 <nornagon> :t withArrayLen
04:08:28 <lambdabot> Not in scope: `withArrayLen'
04:08:33 <nornagon> @index withArrayLen
04:08:33 <lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
04:08:40 <nornagon> :t Foreign.withArrayLen
04:08:42 <lambdabot> forall a b. (Foreign.Storable.Storable a) => [a] -> (Int -> GHC.Ptr.Ptr a -> IO b) -> IO b
04:09:39 <Igloo> TSC: No
04:12:01 <TSC> That's good to hear; can you point me in the direction of instructions to do it?
04:28:09 <thartman> is there a way to specify a module to use from the bash shell, along with ghc -e 'stuff' ?
04:28:26 <thartman> analogous to perl -MPath::To::Module -e 'stuff' ?
04:29:20 <thartman> that would be great for one-liners.
04:29:52 <thartman> ah, I just found http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
04:29:54 <lambdabot> Title: 4.17. Flag reference, http://tinyurl.com/ydk2e6
04:32:48 <thartman> Enh, I guess I can just specify what to import from within ghc -e .
04:42:01 <nornagon> excellent, SDL_gfxPrimitives complete.
04:42:13 <nornagon> that's enough for one night
04:42:16 * nornagon zzz
04:54:28 * nornagon darcs send.
04:54:39 <nornagon> oh, bah
04:54:42 <nornagon> where to.
04:54:55 <nornagon> @ask Lemmih where to send my patches.
04:54:56 <lambdabot> Consider it noted.
04:55:41 <Lemmih> @tell nornagon lemmih@gmail.com
04:55:42 <lambdabot> Consider it noted.
04:56:01 <nornagon> ah. :)
04:56:02 <lambdabot> nornagon: You have 1 new message. '/msg lambdabot @messages' to read it.
04:57:06 <nornagon> hm, it turns out i don't have sendmail installed and stuf
04:57:12 <nornagon> how do i get darcs to spew out a changeset?
04:57:22 <Lemmih> darcs send -o file.dpatch
04:57:23 <lambdabot> Lemmih: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:59:05 <nornagon> sent.
05:09:29 <russo> Dmitry Nedospasov (russo) - In the mix with some sunday deep house to chill out (on #clanteam.radio) http://radio.clanteam.info
05:09:31 <lambdabot> Title: #clanteam ::: the ultimate clan management system
05:09:32 <russo> :P
05:24:57 <therp> Ah, sunday and I can code Haskell. This is so satisfying. Girls always give me a strange look when I tell them what I do for fun.
05:25:59 <therp> russo: radio.clanteam.info sends the wrong mime type for listen.pls
05:26:20 <therp> also mpg123 fails to connect.
05:34:46 <russo> therp: :/ not my site... it works for me in itunes and winamp though :/
05:34:52 <russo> try the wmp link
05:35:04 <russo> oh man i love the track playing atm :P
05:35:26 <therp> mplayer works.
05:35:59 <therp> hmm, sounds a bit undersampled. no high frequencies
05:36:06 <therp> but probably that's intentional
05:46:40 <russo> therp: its deep house thanks for listening btw
05:46:51 <russo> the technics mk2s thank you aswell :P
05:47:58 <therp> I guess I have a few docents of deep house vinyl in the drawers behind me, but my technics are collecting dust.
05:48:32 <therp> in fact, I want to sell them, but ebay implies proper shipping and packaging.. practically I'm too lazy..
05:50:00 <cddar> does ghc 6.6 prof include HUnit?
05:55:56 <kuribas> hmm, combinations = sequence
05:57:08 <kuribas> There are many treasures in the standard library :)
05:58:29 <russo> therp: if you want we can discuss this :P if you have mk2s i may be interested
05:58:53 <russo> i live in berlin and in moscow during the summer and i don't have decks in moscow :/
05:59:19 <therp> russo: SL-1200MK2 http://images.google.com/images?q=SL-1200MK2
05:59:20 <lambdabot> Title: SL-1200MK2 - Google Image Search
05:59:42 <russo> :)
05:59:45 <russo> i know what those are
05:59:48 <russo> how old are they
05:59:57 <russo> you in the uk??
06:00:28 <therp> russo: no, austria. they are like 6 years old. no club/smoke exposure.
06:00:48 <russo> hey alter dann wirds doch viel belliger :P
06:01:13 <ikaros> =)
06:01:19 <russo> und guter zustand?
06:01:25 <russo> ich hoffe :P
06:01:43 <therp> klar man. verkauf doch keinen crap :) .. and I think we should not bother the rest of the channel
06:02:04 <russo> hmm
06:41:05 <nominolo> hm, is there a neat trick to iterate over the instances of a class?
06:41:33 <nominolo> or, put differently, i think oleg wrote something about this. anyone remember where?
06:42:05 <dons> hmm. almost everything he writes is on his web site
06:42:22 <dons> but its sometimes hard to think of a realistic program that would need those techniques
06:42:25 <dons> :-)
06:42:34 <nominolo> not for me
06:42:36 <nominolo> ;)
06:42:41 <opqdonut> :)
06:42:46 <nominolo> but it seems like overkill
06:43:38 <nominolo> i'm coming from lisp, so i'm used to be able to follow the once-and-only-once pronciple quite strictly
06:44:04 <nominolo> however, things get a lot more complicated when you have static typic
06:44:20 <dons> pronciples are all well and good, but what kind of code could really require iterating over class dictionaries?
06:45:06 <Philippa> presumably something decorating them?
06:45:19 <dons> yeah, some kind of code gen i suppose?
06:45:19 <Philippa> or state-dumping a system with dynamic loading
06:45:21 <nominolo> hm, i'll try to formulate and paste
06:45:33 <Saizan> if TH could reify the instances of a certain class, or the classes a type instances it could be a pragmatic way do it
06:45:33 <nominolo> it's a bit complicated and not yet thought through
06:45:45 <Saizan> s/do/to do/
06:45:57 <nominolo> yes, but i see TH only as an emergency solution
06:46:36 <Philippa> oh, or I might iterate over dictionaries as part of a generalised delegation mechanism I guess
06:46:57 <nominolo> Philippa: yes, more like this.
06:47:47 <Saizan> so you want to use a class as a set of workers?
06:51:45 <pejo> Heh. I now have a 400 line interpreter that barely handles fac 3.
06:52:50 <Philippa> yeah? Is it based on the code I showed you? :-)
06:53:14 <pejo> Heh, not at all. Sorry. :-)
06:53:28 <Philippa> (for which I'd guess 10 more lines to add int literals, and it took me maybe twenty to add the core of monadic IO later)
06:54:00 <pejo> Hm. Yeah. The thing that sucks up most of the space is the code for handling open expressions.
06:55:06 <Philippa> there was also a minor refactor in the evaluator though - evaluating the application of values as opposed to terms became a separate function
06:56:41 <pejo> Was it cbv or cbn? I don't see how special casing applications of values would make the code clearer/better
06:56:48 <Philippa> CBV
06:57:02 <Philippa> the code for executing actions needs to do it too
06:57:10 <Philippa> and values aren't terms
06:57:48 <pejo> So \x.x isn't a term?
06:58:40 <Philippa> it is, but it can also be evaluated into a closure in this implementation
07:00:52 <Philippa> the closure retains the lambda at the head, of course
07:02:40 <pejo> Does that mean that some values are terms, and some aren't?
07:02:47 <Philippa> no values are terms, but some contain terms
07:05:15 <Philippa> it's an interpreter rather than a lambda calculus reducer :-)
07:11:30 <pejo> Philippa, is there an obvious difference between the two?
07:11:54 <Philippa> aims and objectives
07:12:08 <Philippa> I think I've still got the mechanisms for letting free variables propagate in place, but they don't need to be
07:12:19 <Philippa> whereas for a lambda calculus reducer that's arguably the entire point
07:18:44 <pejo> Not sure I follow here, but most interpreters prefer closed expressions - where would the free variables come from?
07:23:36 <Philippa> pejo: they're only closed at top-level. By the time you're evaluating just a given lambda expression, the variables that're bound at top-level're free - you've shaved away the context
07:23:52 <ADEpt> dcoutts: here?
07:24:13 <pejo> Philippa, yeah, but if you're inside a lambda expression, there must have been an application, otherwise you'd be stuck?
07:24:28 <pejo> Philippa, (and that application ought to give the variables a value)
07:24:30 <Philippa> no. You can return functions
07:24:54 <pejo> Philippa, but functions are values, and the interpreter is done when reaching a value?
07:25:08 <Philippa> or rather, you're right in that I don't evaluate /inside/ lambdas when I build the closure
07:25:14 <pejo> Reaching a value in the empty context, is probably more correctly worded.
07:25:42 <Philippa> right, but you reach a lot more values from a non-empty context
07:26:25 <Philippa> you need closures or something related in order to support HOFs, because a function's use site's away from the original context it appeared in
07:27:04 <nortonkondomman> is there a darcs+cabal-install integration yet?
07:31:20 <orbitz> does anyone else feel a raw sense of power thent hey write haskell and know it's much better htan writing C++
07:31:23 <orbitz> i know i do
07:31:26 <orbitz> makes me feel like a man
07:31:28 <orbitz> or a omwan
07:31:30 <orbitz> whichever
07:32:06 <opqdonut> nice typo btw
07:32:08 <opqdonut> gz
07:32:15 <ADEpt> dcoutts: nevemind :)
07:33:11 <Philippa> Haskell doesn't make me "feel like a woman" - the IO monad doesn't do it for me that way
07:33:34 <Philippa> I know what you're getting at though, you can get impressive stuff done quickly and it both lets you write what you're thinking and improves what you're able to think
07:34:14 <orbitz> Philippa: would it make you feel more like a man if monads were called gonads?
07:35:30 <orbitz> anyone see that conversation online about het Fizzbuzz problem and how, apparently, a lot of peopel interviewing for programmer jobs have a lot fo turboe solving it
07:35:32 <Philippa> hah. I think you'll find the term "gonads" refers to both testes and ovaries...
07:37:12 <orbitz> it really blew my mind nd maeks me think two things, either CS is sooo saturated  that we just have a lot of  people unable to think in it, or CS education is sooo terrible nobody is learning how to think
07:38:15 <greenrd> I think it's the latter
07:38:31 <Philippa> I saw both when I started my course, but it was the last year of signups before the dot com bubble burst
07:38:54 <Philippa> those of us who could think already were picking stuff up, sure
07:39:38 <orbitz> well one thing is, most people i see programming fo ra living think of it not as a hobby they now do to make money but simply as a job and want nothing to do with computers elsewhere.  Are there enough programmers who really love it to sustain a job market? Or do we have to hire eople that just have no interested in doing thigns well and getting better?
07:40:06 <greenrd> think incentives
07:40:16 <yip> how can i convert a NominalDiffTime to an Int number of milliseconds?
07:40:17 <lambdabot> yip: You have 1 new message. '/msg lambdabot @messages' to read it.
07:40:29 <greenrd> incent people to do things well
07:40:53 <yip> @seen sorear
07:40:54 <lambdabot> I saw sorear leaving #darcs, #ghc, #haskell-overflow and #haskell 5h 24m 8s ago, and .
07:41:19 <Philippa> orbitz: you don't have to be a hobbyist to be sufficiently professional
07:43:07 <_sussi> @seen Philippa
07:43:07 <lambdabot> Philippa is in #scannedinavian, #oasis, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa speak 1m 48s ago.
07:54:21 <Saizan> is there a way to get an output like writeDocumentToString without being in IOStateArrow and so putting me in IO?
07:56:21 <nominolo> ok, I think I now have a small enough example of problem:
07:56:42 <nominolo> how can i create a lookup-map that is defined by instantiating a class?
07:56:55 <nominolo> ie. each instance extends the defined values in the lookup map
07:57:36 <fantasma> @index (digitToInt)
07:57:37 <lambdabot> Data.Char
07:58:27 <fantasma> @type digitToInt
07:58:36 <lambdabot> Char -> Int
07:58:43 <nominolo> any ideas?
07:58:56 <orbitz> i don't really undrstand the question so i cant help
07:59:22 <nominolo> @where paste
07:59:22 <lambdabot> http://kakapo.scannedinavian.com:8000
07:59:48 <ndm> @paste
07:59:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:59:55 <ndm> nominolo: use that new one
07:59:55 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
08:00:04 <ndm> @where+ paste http://hpaste.org/new
08:00:04 <lambdabot> Done.
08:00:33 <narain> @where hpaste
08:00:33 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
08:00:52 <ndm> @where+ hpaste http://hpaste.org/new
08:00:52 <lambdabot> Done.
08:01:36 <ndm> @tell sorear I think we have Data.Applicative, and we will get state monad etc, but not monad transformers
08:01:37 <lambdabot> Consider it noted.
08:01:47 <fantasma> @hoogle factorial
08:01:48 <lambdabot> No matches found
08:01:52 <fantasma> @hoogle fac
08:01:53 <lambdabot> Text.Html.face :: String -> HtmlAttr
08:01:53 <lambdabot> Distribution.Extension.ForeignFunctionInterface :: Extension
08:01:53 <lambdabot> Distribution.InstalledPackageInfo.haddockInterfaces :: InstalledPackageInfo -> [FilePath]
08:08:24 <fantasma> someone tell me if I'm approaching this wrong but don't write the code for me :: I have an infinite list of the fibonacci sequence and I want to know which is the first term to have 1000 digits -- i was thinking to do takeWhile (digits < 1000) on the list and then take the length of the new list
08:08:50 <fantasma> does that seem reasonable?
08:08:51 <allbery_b> sounds sensible to me
08:09:11 <erider> good morning
08:09:23 <fantasma> good, because I've been doing that for most problems and I don't want to be developing bad habbits
08:12:35 <narain> :t (>>=)
08:12:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:12:41 <narain> :t (=<<)
08:12:43 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
08:13:13 <narain> (=<<)  is  flip (>>=)  ?
08:15:05 <narain> guh, obviously. the docs say so
08:15:09 <fantasma> > digitToInt "12467"
08:15:10 <narain> :(
08:15:11 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
08:15:30 <narain> fantasma: use read?
08:15:43 <fantasma> i need a list
08:15:57 <narain> use map?
08:15:58 <fantasma> > digitToInt $ show 12395
08:15:58 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
08:16:06 <psnl> dcoutts: ping?
08:16:08 <fantasma> yes, I always forget that
08:16:12 <fantasma> thanks narain
08:16:29 <fantasma> > map digitToInt (show 105983)
08:16:31 <lambdabot>  [1,0,5,9,8,3]
08:16:37 <Nicu_> > map digitToInt "12345"
08:16:38 <lambdabot>  [1,2,3,4,5]
08:18:04 <shachaf> fantasma: Couldn't you just take logBase 10 and logBase phi to get the length and the index?
08:18:28 <fantasma> shachaf, yes, I guess I could but I suck at math
08:18:34 <psnl> anyone used sourceview, glade and gtk2hs all at the same time?
08:18:55 <narain> > takeWhile (> 0) $ unfoldr (\n -> (n `mod` 10, n `div` 10)) 1024
08:18:56 <lambdabot>  Couldn't match expected type `Maybe (a, b)'
08:19:01 <narain> > takeWhile (> 0) $ unfoldr (\n -> Just (n `mod` 10, n `div` 10)) 1024
08:19:03 <lambdabot>  [4,2]
08:19:30 <narain> > reverse $ unfoldr (\n -> if n > 0 then Nothing else Just (n `mod` 10, n `div` 10)) 1024
08:19:31 <lambdabot>  []
08:19:39 <narain> > reverse $ unfoldr (\n -> if n <= 0 then Nothing else Just (n `mod` 10, n `div` 10)) 1024
08:19:41 <lambdabot>  [1,0,2,4]
08:19:46 <narain> \o/
08:20:13 <fantasma> > 28433 * 2^7830457 + 1
08:20:16 <shachaf> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in (+1) $ floor $ logBase phi $ fromIntegral $ fibs !! 25
08:20:17 <lambdabot>   Not in scope: `phi'
08:20:18 <lambdabot> Terminated
08:20:39 <narain> > (1 + sqrt(5))/2
08:20:40 <lambdabot>  1.618033988749895
08:20:42 <shachaf> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in (+1) $ floor $ logBase (((sqrt 5) + 1) / 2) $ fromIntegral $ fibs !! 25
08:20:44 <lambdabot>  25
08:21:13 <narain> shachaf: impressive
08:21:20 <fantasma> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in length $ takeWhile(\x -> (length . map digitToInt . show)  x /= 1000) fiblist
08:21:22 <lambdabot>  4782
08:21:26 <fantasma> ;)
08:21:53 <emu> > scanl (+) 1 [1..]
08:21:54 <lambdabot>  [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,2...
08:22:05 <emu> > scanl (+) 1 [0..]
08:22:07 <lambdabot>  [1,1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254...
08:22:31 <fantasma> isnt that slower
08:23:03 <narain> that's not fibonacci
08:23:17 <fantasma> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in fiblist !! 1000
08:23:18 <lambdabot>  4346655768693745643568852767504062580256466051737178040248172908953655541794...
08:23:21 <emu> that's random crud
08:23:33 <fantasma> > let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist) in fiblist
08:23:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:23:57 <narain> > map (\n -> n*(n-1)*(2*n-1)/6) [1..]
08:23:58 <lambdabot>  [0.0,1.0,5.0,14.0,30.0,55.0,91.0,140.0,204.0,285.0,385.0,506.0,650.0,819.0,1...
08:24:30 <tfc> how can I implement a function that outputs the smallest number from a list using a selection sort?
08:24:44 <narain> > map (\n -> floor $ n*(n-1)/2) [1..]
08:24:45 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
08:25:02 <narain> emu: i'm close? :)
08:25:30 <narain> tfc: do you just want the minimum of a list? you don't need to sort for that
08:26:44 <narain> > map (\n -> (1+) . floor $ n*(n-1)/2) [1..]
08:26:45 <emu> that's f(n) = f(n-1) + n + 1
08:26:45 <lambdabot>  [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,2...
08:26:49 <fantasma> > minium [1..]
08:26:50 <lambdabot>   Not in scope: `minium'
08:26:54 <fantasma> > minimum [1..]
08:26:58 <lambdabot> Terminated
08:27:03 <narain> hey i got your first one
08:27:06 <Jaak> doesnt selection sort already work by taking minimum/maximum on each iteration?
08:27:10 <emu> fantasma: it doesn't know that list is ordered
08:27:22 <fantasma> @src sort
08:27:22 <lambdabot> sort = sortBy compare
08:27:29 <narain> @src sortBy
08:27:29 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
08:27:40 <fantasma> > sort [1,5,3,2,8]
08:27:41 <lambdabot>  [1,2,3,5,8]
08:27:51 <fantasma> > minimum . sort $ [1..]
08:27:51 <narain> looks like insertion sort to me
08:27:55 <lambdabot> Terminated
08:28:00 <emu> yea ghc doesn't really use that
08:28:08 <emu> that's from the Report
08:28:18 <emu> neat definition though
08:28:22 <narain> ah...
08:28:57 <narain> what does ghc use?
08:29:00 <fantasma> > map (\x -> x^x) [1,2,3,4,5]
08:29:02 <lambdabot>  [1,4,27,256,3125]
08:29:12 <narain> > 0^0
08:29:13 <emu> merge sort probably
08:29:14 <lambdabot>  1
08:29:22 <narain> !
08:29:29 <fantasma> > sum $ map (\x -> x^x) [1..1000]
08:29:31 <lambdabot>  1000368199144695177095375011227646795567793680622934654583760988100234910747...
08:29:48 <fantasma> how can I do "last 10 digits of list"
08:29:58 <Jaak> > last 10 [1..100]
08:29:59 <lambdabot>   add an instance declaration for (Num [[t] -> a])
08:30:03 <Jaak> ohm
08:30:23 <allbery_b> take 10 $ reverse list
08:30:27 <fantasma> nice!
08:30:33 <fantasma> thanks haha
08:31:14 <narain> i wouldn't have thought of that
08:31:27 <fantasma> > take 10 . reverse . map digitToInt . show . sum . map (\x -> x^x) [1..1000]
08:31:28 <lambdabot>  Couldn't match expected type `a -> [a1]'
08:31:47 <narain> > take 10 . reverse . map digitToInt . show . sum . map (\x -> x^x) $ [1..1000]
08:31:49 <lambdabot>  [0,0,7,6,4,8,0,1,1,9]
08:32:07 <fantasma> stupid $ sign
08:32:11 <fantasma> > take 10 . reverse . map digitToInt . show . sum . map (\x -> x^x) $ [1..1000]
08:32:13 <lambdabot>  [0,0,7,6,4,8,0,1,1,9]
08:33:05 <fantasma> uh oh...incorrect
08:33:24 <Jaak> > (\n xs -> fst $ foldr (\y ~(ys, m) -> if m == 0 then (ys, m) else (y : ys, m - 1)) ([], n) xs) 10 [1..100]
08:33:25 <fantasma> > reverse . take 10 . reverse . map digitToInt . show . sum . map (\x -> x^x) $ [1..1000]
08:33:26 <lambdabot>  [91,92,93,94,95,96,97,98,99,100]
08:33:26 <lambdabot>  [9,1,1,0,8,4,6,7,0,0]
08:33:27 <ndm> gah, the trac bug tracker is pathetic! Google code is soooo much better
08:33:51 <Jaak> slow. but it uses foldr! :P
08:34:29 <narain> Jaak: what's ~(ys, m) mean?
08:34:36 * fantasma is now 12% genius (http://projecteuler.net/)
08:34:39 <lambdabot> Title: Project Euler
08:34:43 <Jaak> lazy pattern matching
08:35:46 <Jaak> > fst $ foldr (\x (xs, ()) -> (x : xs, ()) [1..]
08:35:46 <lambdabot>  Parse error
08:36:03 <Jaak> > fst $ foldr (\x (xs, ()) -> (x : xs, ())) [1..]
08:36:04 <lambdabot>  Couldn't match expected type `([a], ())'
08:36:08 <Jaak> bah
08:36:45 <Jaak> > fst $ foldr (\x (xs, ()) -> (x : xs, ())) ([], ()) [1..]
08:36:47 <lambdabot>  Exception: stack overflow
08:36:48 <Cale> Does anyone know why half of all my requests to the reddit webserver are coming back 500's?
08:36:50 <Jaak> > fst $ foldr (\x ~(xs, ()) -> (x : xs, ())) ([], ()) [1..]
08:36:52 <yip> is System.Random.getStdRandom thread safe?
08:36:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:36:55 <Jaak> there
08:37:05 <narain> that's interesting
08:37:27 <fantasma> Jaak, what's that do?
08:37:33 <narain> why does that happen?
08:38:24 <Jaak> http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching
08:38:27 <lambdabot> http://tinyurl.com/ykch9p
08:38:36 <fantasma> @where reddit
08:38:36 <lambdabot> I know nothing about reddit.
08:38:46 <fantasma> @where rededit
08:38:46 <lambdabot> I know nothing about rededit.
08:39:38 <fantasma> reddit =? digg clone?
08:40:40 <narain> fantasma: with a more intelligent userbase
08:41:07 <narain> Jaak: so does it always make sense to match tuple arguments lazily?
08:41:17 <narain> Jaak: ps. thanks for the link
08:41:17 <Cale> tfc: head . selectionSort
08:41:18 <yip> Cale: i'm also experiencing it :(
08:41:18 <fantasma> i think anything has a more intelligent userbase than digg ;D
08:41:59 <narain> reddit has links to articles on haskell, lisp, forth often in the programming section
08:42:29 <fantasma> can you do {man grep >> grep.txt} on nix
08:42:45 <Jaak> sometimes. i think it doesnt matter in my last 10 function
08:42:57 <Jaak> as it doesnt make much sense on inf. lists anyways
08:43:09 <Cale> Basically, the Haskell community has been hammering the reddit community with Haskell praise and mindsets, and some of them are starting to get it :)
08:43:26 <narain> Jaak: but it doesn't hurt does it? for tuples?
08:43:28 <fantasma> haskell is #2 on reddit programming
08:43:59 <Cale> This is programming.reddit, that's important to say, since main reddit is not terribly intelligent most of the time.
08:44:01 <narain> fantasma: i don't see why not (to your previous question)
08:44:40 <fantasma> narain, well I just read off an article at reddit that there was a special command {col} that did that -- maybe someone can verify
08:44:49 <Jaak> > let f ~([], x) = 1; f ~(xs, x) = 2 in f ([1],()) -- it can
08:44:50 <lambdabot>      Warning: Pattern match(es) are overlapped
08:44:50 <lambdabot>              In the definition...
08:44:51 <narain> hmm you may be right, let me check
08:45:22 <narain> well it worked for me
08:45:35 <fantasma> using {>>} ?
08:45:37 <Jaak> but "incorrectly"
08:45:45 <Jaak> > let f ([], x) = 1; f (xs, x) = 2 in f ([1],()) -- it can
08:45:47 <lambdabot>  2
08:45:49 <narain> i tried >
08:45:57 <fantasma> ah yea
08:46:08 <fantasma> "col - filter reverse line feeds from input"
08:46:33 <allbery_b> what are you trying to do?
08:46:41 <narain> >> worked fine too -- i now have a file containing two copies of the grep man page
08:46:49 <emu> something's wrong with reddit today
08:47:17 <fantasma> hmmmm 40% of reddit links are haskell :D
08:47:18 <DynWind> yeah, getting 500's
08:47:20 <narain> though the file created has executable permissions for some reason
08:47:21 <emu> Jaak: ~ pattern match never fails, so it doesn't make sense to have 2
08:47:36 <fantasma> narain, that's quite odd
08:48:32 <narain> emu,Jaak: thanks, that makes sense now
08:49:22 <fantasma> interesting...http client written in bash
08:49:24 <Jaak> yeah, i think wiki explains that
08:49:44 <narain> yeah that it does
08:52:00 <fantasma> what's more effective for writing code, a widescreen monitor or a non-widescreen monitor
08:52:43 <ndm> fantasma: depends whether you use more than 80 characters or not
08:52:49 <narain> i often wish i had a *tall* monitor
08:53:09 <fantasma> ndm, i use more than 80 characters
08:53:29 <ndm> fantasma: don't tell Igloo
08:53:48 <fantasma> ndm, why? what's going on?
08:54:01 <ndm> fantasma: he doesn't like > 80 line characters ;)
08:54:18 <ndm> bigger monitor == better, usually
08:54:20 * Igloo feels his left little finger starting to twitch
08:54:55 <Igloo> I still have a widescreen monitor, though - Having xterms side by side is more comfortable than having them up and down
08:54:56 <fantasma> the reason I ask is because I cant decide between a 20" normal or a 20" widescreen monitor :(
08:55:25 <ndm> get a widescreen for DVD watching
08:55:55 <yip> hm... psuedo random numbers attack again :/
08:56:12 <fantasma> i wont be doing any "watching" with the monitor, only coding
08:56:53 <shachaf> fantasma: Like Igloo says, widescreen is nicer for having two terminals side by side (from what I hear, at least).
08:57:19 <yip> Igloo: do you happen to know if System.Random.getStdRandom is thread safe?
08:57:26 <fantasma> widescreen it is!
08:57:34 <Igloo> yip: I don't
08:57:40 <shachaf> fantasma: What window manager do you use?
08:57:55 <fantasma> shachaf, fluxbox and e17
08:58:12 <Igloo> yip: It doesn't look like it is, though
08:58:44 <Igloo> yip: But it could easily be made so, at the expense of performance, by changing from an IORef to an MVar
08:58:52 <shachaf> fantasma: Hmm... What is the status of E17 anyway? I haven't looked into it in a while.
08:59:17 <fantasma> shachaf, haha I have no idea which is why I just joined #e (but I'm affraid to ask)
08:59:30 <fantasma> i havent used in maybe a year
08:59:34 <yip> Igloo: sounds like a good idea
09:00:00 <shachaf> fantasma: Oh. So you use Fluxbox?
09:00:26 <fantasma> shachaf, yah but I might try e17 again (since I'll be getting a new comp that will handle it nicer)
09:01:24 <shachaf> fantasma: You may want to try a tiling window manager.
09:02:14 <fantasma> like ratpoison?
09:02:21 <shachaf> fantasma: I used to run WMII and then Ion3.
09:02:23 <matthew-_> that's what I use.
09:02:28 <matthew-_> ion is quite good too
09:02:34 <fantasma> i love wmii
09:02:46 <fantasma> might use that actually
09:02:55 <narain> i'd like to try these new window managers, but i'm reluctant to get out of my comfort zone
09:02:55 <kc5tja> shachaf: At work, most people have two widescreen monitors in portrait mode, since longer, narrower windows makes more sense for coding in Java.
09:03:04 <shachaf> fantasma: I know one person who uses DWM with GNOME...
09:03:24 <narain> someone paint me a picture of their awesome advantages so i can convince myself please?
09:03:26 <narain> :)
09:03:36 * kc5tja likes Ion :)  I tried ratpoison -- a bit TOO mouseless for my liking.  
09:03:48 <fantasma> narain, wmii
09:03:50 <fantasma> narain, http://upload.wikimedia.org/wikipedia/en/9/97/Wmii-3_screenshot.png
09:03:53 <lambdabot> http://tinyurl.com/25cn5p
09:03:54 <cjay> shachaf: that works? doesn't it screw the bars etc?
09:03:55 <yip> i'm running wmii 3
09:04:13 * shachaf has to admit that since he reinstalled Ubuntu, he's been using Metacity out of laziness.
09:04:16 <matthew-_> narain: basically, you never have to bother dragging windows around
09:04:21 <shachaf> cjay: He has only one panel at the bottom.
09:04:31 <yip> only problem with wmii is that each new version removes features instead of adding more :(
09:04:32 <cjay> hm
09:04:33 <shachaf> cjay: He patched the code to leave room for it.
09:04:40 <cjay> hehe
09:04:52 <shachaf> cjay: He also added antialiasing and some other features.
09:04:53 <narain> yes, the automatic tiling is tempting
09:04:59 <fantasma> yah
09:05:08 <fantasma> who invented the concept of dragging around windows
09:05:13 <fantasma> it doesnt make sense
09:05:20 <sorear> I don't use ANY window manager.  Infact I don't use ANY window system.
09:05:20 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
09:05:25 <sorear> engelbart.
09:05:27 <sorear> ?
09:05:34 <sorear> s/./?
09:05:41 <fantasma> sorear, no x windows?
09:05:57 <yip> i'm still using wmii 3. i'm afraid to upgrade to 3.5 because i worry that it will be missing some crucial feature that i rely on :\
09:06:26 <sorear> fantasma: I use x windows about twice a week, and only for gv.
09:06:32 <narain> what happens if i want to change the size of my windows?
09:06:42 <fantasma> narain, you can
09:06:52 <shachaf> sorear: Do you at least use screen?
09:07:32 <kc5tja> Engelbart invented the mouse, but didn't invent windowing.  He DID invent drag and drop though.  I think the framers of Smalltalk invented movable, resizable windows.
09:07:32 <sorear> shachaf: no.  does screen do anything better than Emacs+Linux?
09:07:51 <shachaf> sorear: Well, emacs is a window manager in its own right. :-)
09:07:52 <matthew-_> narain: typically, after a while, you just have each workspace set up as you want it and from then on you don't need to worry about changing window sizes
09:07:52 <narain> so tiled windows is the killer feature? or is there also something else?
09:08:02 <narain> hmm.
09:08:08 <yip> "Because dwm is customized through editing its source code, it's pointless to make binary packages of it. This keeps its userbase small and elitist. No novices asking stupid questions."
09:08:18 <yip> ^^ similar philosophy to haskell :P
09:08:26 <matthew-_> narain: it's just faster. you never reach for the mouse. make yourself use it for a week.
09:08:41 <narain> i certainly am quite intrigued now
09:09:01 <mauke> this wmii thing - is there something like it for kde?
09:09:15 * sorear uses ion3, on the rare occasions when any X is needed
09:09:15 <shachaf> mauke: You can run KDE programs under it.
09:09:20 <matthew-_> ratpoison has good documentation but isn't the most featureful or powerful. I would recommend you start with ion
09:09:23 <pejo> narain, http://www.csee.ltu.se/~pj/pictures/pj-screen.png -- definitely doesn't make you go blind from all the colours.
09:09:36 <shachaf> mauke: You could probably add room for the panel if you wanted to.
09:10:00 <narain> ok, i'll give it a shot! which one? wmii? ion? dwm?
09:10:01 <mauke> what's a panel?
09:10:06 <fantasma> haha "dwm : pr0n for code fetishists"
09:10:18 <shachaf> mauke: The kicker.
09:10:51 <yip> fantasma: that's the slogan for the entire suckless software suite, not just dwm
09:10:52 <fantasma> dwm has tagging!?!?!
09:11:03 <yip> sure
09:11:08 <yip> but it's not as powerful as wmii
09:11:21 <narain> pejo: that doesn't look like a tiling wm
09:11:52 <narain> pejo: plus i like a bit of colour on my screen :)
09:12:19 * narain goes shopping for window managers
09:12:40 <fantasma> wmii > ion yes?
09:12:58 * cjay prefers ion
09:13:00 <yip> fantasma: depends
09:13:01 <shachaf> fantasma: Not feature-wise.
09:13:15 <pejo> narain, nah. That restriction must have been scrolled out of my irc window. :-)
09:14:19 <sorear> @users
09:14:19 <lambdabot> Maximum users seen in #haskell: 336, currently: 314 (93.5%), active: 35 (11.1%)
09:14:25 <fantasma> can these window managers work with in conjunction with screen (such as take a screen session and seperate it to individual windows?)
09:14:49 <sorear> nah, they replace screen entirely
09:14:56 <sorear> similar interface even
09:15:00 <yip> sorear: hey
09:15:03 <shachaf> sorear: Not the detachment.
09:15:19 <shachaf> sorear: Which is really the only reason I use screen.
09:15:27 <dmhouse> Wow, WM discussion in a channel other than #emacs.
09:15:34 <fantasma> but screen works through ssh
09:15:52 <narain> yees. wmii, ion etc are so far from what i'm used to that i can't choose or even compare them rationally
09:15:56 <sorear> fantasma: so dooes ion
09:16:00 <narain> i meant *yeesh
09:16:07 <sorear> X11Forwarding++
09:16:32 <narain> i'm like a Java programmer trying to pick which of Lisp, ML or Haskell to learn next
09:16:44 <kc5tja> sorear: How does Ion work through SSH?
09:17:00 <shachaf> narain: WMII is scriptable in the filesystem (normally shell scripts, but language of your choice), Ion is scriptable in Lua.
09:17:06 <sorear> kc5tja: first define 'work through'
09:17:16 <kc5tja> 09:13 < fantasma> but screen works through ssh
09:17:19 <kc5tja> 09:14 < sorear> fantasma: so dooes ion
09:17:39 <sorear> kc5tja: I can run any graphical progam, even a window manager, under my ssh.
09:17:40 <kc5tja> I don't know -- I think I was asking you that question first.
09:17:45 <shachaf> narain: Ion lets you cusomize your layout a lot more than the WMII I used, though that was a while ago.
09:18:07 <dmhouse> narain: you'll pick up similar skills from all of them, but from a point of view of learning a different language from the others, the purity of Haskell makes it more different from things like Java.
09:18:48 <narain> dmhouse: i know, it was a just a rhetorical comparison :)
09:18:49 <kc5tja> But I don't think that's what fantasma was talking about.  Because screen runs in its own process, self-contained, exclusively via SSH (e.g., it doesn't grok CORBA or the like), there's no way to break out the sessions running under it.
09:19:02 <narain> shachaf: thanks. which one has a shallower learning curve?
09:19:12 <matthew-_> ion, using lua to script it, means you'll get used to lua, which then means you'll feel right at home with monotone too!
09:19:13 <fantasma> narain, if you dont have any basis for your decision choose the one that has the "best" userbase
09:19:30 <dmhouse> narain: right, sorry, I hadn'tbeen following along.
09:19:31 <matthew-_> narain: they're all pretty simple and have shallow learning curves.
09:19:43 <sorear> narain: ion has this cool feature where when you start it it automatically loads a (good) tutorial
09:20:03 <sorear> narain: (never tried the others, the probably have something similar)
09:20:20 <yip> wmii also has such a tutorial
09:20:25 <yip> sorear: you are the main developer of ion, right?
09:20:25 <fantasma> wmii had something similar if i remember correctly
09:20:33 <sorear> yip: no, tuomov
09:20:38 <shachaf> narain: Whichever one you pick, I recommend you map either Caps or Win to their mod-key.
09:20:38 <yip> oh yeah that's him
09:20:48 <matthew-_> ratpoison has an info page and keybindings on C-T ?
09:21:09 <narain> cool, thanks all
09:21:16 <matthew-_> just go play! ;-)
09:21:45 <sorear> yip: he hasn't been here in years (according to @seen), but tuomov was at one point a #haskeller.  he also wrote much of yi.
09:21:58 <yip> sorear: yeah i remember he was here a few times
09:22:24 <narain> matthew-_: i will! :)
09:22:39 <pafcu> What's an easy way to count the number of times an elment occures in a list? e.g "abbcd" How does one count the number of 'b':s in the string?
09:22:50 <sorear> length+filter
09:22:50 <mauke> pafcu: length . filter
09:23:06 <sorear> > length (filter (=='l') "Hello, World")
09:23:07 <lambdabot>  3
09:23:09 <mauke> > length (filter ('b' ==) "abbcd")
09:23:10 <lambdabot>  2
09:23:22 <sorear> pafcu: there's also a cute trick with list comprehensions
09:23:38 <yip> sorear: what is nobench?
09:23:40 <matthew-_> length . filter would result in 2 list traversals right?
09:23:41 <sorear> > sum [ 1 | 'l' <- "Hello, World" ]
09:23:43 <lambdabot>  3
09:23:54 <sorear> @where nobench-results
09:23:54 <lambdabot> I know nothing about nobench-results.
09:23:59 <sorear> gah.
09:24:03 <dmhouse> mathrick: hopefully not, because of fusion.
09:24:03 <sorear> @karma- lambdabot
09:24:04 <lambdabot> lambdabot's karma lowered to 39.
09:24:16 <matthew-_> dmhouse: it's not that advanced yet is it?
09:24:32 <pafcu> I thought about list comprehension but it just seemed "wrong" to abuse lists like that :-)
09:24:42 <sorear> dmhouse, mathrick: besides, after filter length only looks at matching elements.
09:24:46 <matthew-_> > foldr (\sum x -> if x == 'l' then sum+1 else sum) 0 "hello world"
09:24:47 <lambdabot>   add an instance declaration for (Num Char)
09:24:49 <dmhouse> Hrm, maybe not in this instance.
09:24:51 <matthew-_> > foldl' (\sum x -> if x == 'l' then sum+1 else sum) 0 "hello world"
09:24:52 <lambdabot>  3
09:24:54 <pafcu> But length.filter seems perfect
09:25:06 <mathrick> dmhouse, sorear: s/mathrick/matthew-_/ please
09:25:10 <dmhouse> mathrick: yeah, that's what I was going to mention. The second traversal only covers the elements that matched.
09:25:13 <sorear> @where+ nobench-results http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
09:25:14 <lambdabot> Done.
09:25:17 <sorear> yip: ^
09:25:33 <dmhouse> matthew-_: yeah, that kind of fold was what I was thinking of :)
09:26:25 <matthew-_> in fact, dons said to me the other day, that if you really want it to go fast, it's often better to not use higher-order
09:26:33 <dmhouse> Actually, if sum and filter are both defined as folds, I don't see why fusion wouldn't cover this.
09:27:02 <dmhouse> ?source Data.List
09:27:03 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
09:27:06 <matthew-_> filter isn't
09:27:07 <sorear> dmhouse: because sum is a foldl' and ghc's current fusion system only does foldr.
09:27:08 <matthew-_> sum is
09:27:25 <matthew-_> sum is foldl, not foldl'
09:27:28 <matthew-_> @src sum
09:27:29 <lambdabot> sum = foldl (+) 0
09:28:38 <sorear> sum     l       = sum' l 0
09:28:38 <sorear>   where
09:28:38 <sorear>     sum' []     a = a
09:28:38 <sorear>     sum' (x:xs) a = sum' xs (a+x)
09:28:54 <sorear> don't trust @src to tell you about the real implementation
09:29:08 <matthew-_> oh. happy happy joy joy ;-)
09:29:27 <mauke> that's still lazy, isn't it?
09:30:06 <sorear> matthew-_: src is mostly for expository purposes.  can you imagine if everytime someone used @src to find out what sum did, it spit out that four line monstrosity?
09:30:59 <ndm> sorear: isn't that just a foldl?
09:31:08 <sorear> yeah :/
09:31:16 <ndm> sorear: with the arguments reversed and + frozen in...
09:31:21 <ndm> so why have they done that?
09:31:38 <rufius> glguy: you around?
09:31:39 <ndm> (Yhc -O will transform the foldl version into the sum' version :) )
09:32:29 <sorear> ndm: -O1 or -O11?  I know HILL will.
09:32:48 <ndm> -O11, whats HILL?
09:32:55 <sorear> ghc's inability to inline recursive functions --
09:32:58 <ndm> (or is that my HILL?)
09:33:06 <sorear> ndm: Haskell Intermediate Little Language IIRC
09:33:19 <ndm> yes, i don't remember ever publishing/sliding anything using HILL...
09:33:43 <sorear> ndm: it was described in one of the catch papers
09:34:06 <ndm> hmm, didn't realise i called it that, i thought it got edited to Core language before then
09:34:11 <ndm> maybe the original paper still had it in
09:34:30 <fantasma> anyone using the "ii" irc client
09:36:09 <rufius> [(r,s) | r <- [-10,10], s <- [-10,10], r*33 + s*44 == 11]
09:36:17 <rufius> oops
09:36:20 <rufius> [(r,s) | r <- [-10,10], s <- [-10,10], r*33 + s*44 == 11]
09:36:23 <rufius> > [(r,s) | r <- [-10,10], s <- [-10,10], r*33 + s*44 == 11]
09:36:25 <lambdabot>  []
09:36:25 <rufius> there we go
09:36:29 <rufius> hrm
09:36:42 <Jaak> > [-10, 10]
09:36:44 <lambdabot>  [-10,10]
09:36:55 <rufius> ah i see
09:37:01 <Jaak> > [-10,-9..10]
09:37:02 <lambdabot>  [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10]
09:37:22 <rufius> > [(r,s) | r <- [-10..10], s <- [-10..10], r*33 + s*44 == 11]
09:37:24 <lambdabot>  [(-9,7),(-5,4),(-1,1),(3,-2),(7,-5)]
09:37:29 <rufius> that's what I was lookin for ;)
09:37:33 <yip> sorear: hm... i'm not sure that my gameboy program will work on anything other then ghc
09:37:48 <rufius> thanks Jaak
09:37:52 <Jaak> you dont need the -9 tho'. i have no idea why i put it there
09:37:56 <Jaak> > [-10..10]
09:37:57 <lambdabot>  [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10]
09:38:01 <rufius> thanks much
09:38:09 <Jaak> np
09:39:03 <ndm> yip: what GHC specific features do you use>?
09:39:03 <sorear> yip: if it's not portable, nevermind then.
09:39:19 <yip> i use GADT
09:39:31 <sorear> ffi abuse is actually more portable than arrays!
09:39:40 <sorear> oh GADT ...
09:39:49 <ndm> one day, but not before an entire front end rewrite
09:40:18 <sorear> ndm: will the new frontend stil be called yhc? :)
09:40:39 <yip> i also use gtk2hs which seems to only work with ghc. but gtk2hs is optional
09:40:46 <ndm> sorear: probably, we want to keep the back end and Yhc.Core, and the infrastructure - its just the front end that needs killing
09:40:49 <kc5tja> clear
09:40:51 <kc5tja> gahh!
09:41:16 <ndm> sorear: and the current front end is the nhc one, this will be the real Yhc one
09:42:44 <sorear> @botsnack
09:42:45 <lambdabot> :)
09:42:53 <Saizan> is there a way to load a library in ghci before Setup install? (i've also a previous build registered in ghc-pkg)
09:43:11 <sorear> nah
09:43:31 <sorear> several people (myself included) are clamoring for ./Setup ghci
09:43:38 <sorear> but it still doesn't exist
09:44:12 <sorear> cabal needs a good way for any 3p programs to access hooks and stuff
09:45:06 <ndm> 3p>
09:45:08 <ndm> ?
09:45:15 <ndm> oh, 3rd party
09:45:23 <Saizan> i'll install then, i could maybe make a "test" user in unix with a separate .installed-pkg-config to handle this
09:47:24 <shachaf> Are there any window managers written in Haskell?
09:47:58 <fantasma> someone will make one soon enough
09:48:05 <sjanssen> Saizan: you could use Setup register --inplace
09:48:24 <sjanssen> Saizan: and then use ghc-pkg to unregister the package later
09:48:39 <sjanssen> shachaf: I'm working on a Haskell window manager
09:48:58 <Saizan> sjassen: then i have to reregister the old build, right?
09:48:58 <sjanssen> shachaf: I've also seen another wm in Haskell
09:49:50 <sjanssen> Saizan: yeah, you'd want to unregister it and then actually install it
09:50:21 <shachaf> sjanssen: Hmm, I looked but couldn't really find anything.
09:50:41 <sjanssen> shachaf: neither are officially released
09:50:57 <sjanssen> I'm planning on releasing mine when I'm a bit closer to completion
09:51:56 <shachaf> sjanssen: What's the status right now?
09:52:35 <shachaf> sjanssen: What sort of WM do you have in mind? Is it tiling?
09:52:47 <sjanssen> shachaf: it's a dwm clone for now
09:52:57 <sjanssen> so yes, mostly tiling
09:53:25 <sjanssen> it will need a float mode eventually, for the goofy applications
09:53:34 <sorear> whoa.  I'm doing h98 stuff in ghci, and suddenly it's complaining     No instance for (Show GHC.Prim.Any)
09:54:15 <shachaf> sjanssen: So it'll have tagging?
09:54:24 <sjanssen> shachaf: I haven't decided yet
09:54:28 <sjanssen> I don't really like tagging
09:55:15 <shachaf> sjanssen: Yes, it's nice in theory, but I never really used it in practice (when I used WMII).
10:09:44 <therp> It always give me a warm cozy feeling when compiling GHC. Especially on my back in winter, when I'm walking on the street with my laptop backpack.
10:11:20 <therp> (I wanted to demonstrate the Liskell GHC branch on my notebook, and then I noticed it was outdated.. So compile while walking.)
10:12:29 <arcatan> hah
10:12:34 <Vq^> :)
10:29:30 <Japsu> heh
10:29:40 <Japsu> it might be unwise to compile stuff with the laptop lid closed
10:29:56 <Japsu> though if it's -20 C outside, that might compensate
10:37:34 <Gwern> another question, I'm afraid. I've almost got it working though! I have two lists, say, ["FB","Fb","fB","fb"] and ["oo","ar"]. I want to somehow produce [["Foo", "Bar], ["Foo", "bar"], ["foo", "Bar"], ["foo", "bar"]]. I've come up with "map (zipWith (++) (replicate (length a) (head b))) (replicate (length a) a)" but that yields [["FBoo","FBar"],["FBoo","FBar"]]. the type signatures are getting way to gnarly for me to progress any further, so...
10:38:59 <sorear> > liftM2 (++) ["FB","Fb","fB","fb"] ["oo","ar"]
10:39:01 <lambdabot>  ["FBoo","FBar","Fboo","Fbar","fBoo","fBar","fboo","fbar"]
10:40:26 <sorear> > (\a b -> map (zipWith (flip (:)) b) a) ["FB","Fb","fB","fb"] ["oo","ar"]
10:40:28 <lambdabot>  [["Foo","Bar"],["Foo","bar"],["foo","Bar"],["foo","bar"]]
10:41:09 <Gwern> I am chagrined. that is nowhere near what I was thinking
10:42:32 <sorear> > (\a b -> zipWith (zipWith (++)) (map (map (:[])) a) (repeat b)) ["FB","Fb","fB","fb"] ["oo","ar"]
10:42:33 <lambdabot>  [["Foo","Bar"],["Foo","bar"],["foo","Bar"],["foo","bar"]]
10:47:20 <Gwern> > map (map (++)) ((\a b -> zipWith (zipWith (++)) (map (map (:[])) a) (repeat b)) ["FB","Fb","fB","fb"] ["oo","ar"])
10:47:22 <lambdabot>  [[<[Char] -> [Char]>,<[Char] -> [Char]>],[<[Char] -> [Char]>,<[Char] -> [Cha...
10:48:14 <Gwern> > map (unwords) c
10:48:15 <lambdabot>   Not in scope: `c'
10:48:28 <Gwern> > map (unwords) ((\a b -> zipWith (zipWith (++)) (map (map (:[])) a) (repeat b)) ["FB","Fb","fB","fb"] ["oo","ar"])
10:48:30 <lambdabot>  ["Foo Bar","Foo bar","foo Bar","foo bar"]
10:50:46 <Botje> > do { a <- "Ff"; b <- "Bb"; return a:"oo "++(b:"ar") }
10:50:47 <lambdabot>  Couldn't match expected type `m Char' against inferred type `Char'
10:51:07 <Botje> > do { a <- "Ff"; b <- "Bb"; return $ a:"oo "++(b:"ar") }
10:51:08 <lambdabot>  ["Foo Bar","Foo bar","foo Bar","foo bar"]
10:51:11 <Botje> :]
10:51:59 <shachaf> > (\a b -> map (\a' -> (zipWith (:) a' b)) a) ["FB", "Fb", "fB", "fb"] ["oo", "ar"]
10:52:00 <lambdabot>  [["Foo","Bar"],["Foo","bar"],["foo","Bar"],["foo","bar"]]
10:52:14 <Gwern> ok, now you guys are just showing off and making me feel bad :(
10:52:19 <Japsu> lol
10:52:24 <Botje> > do { a <- "Ff"; b <- "Bb"; return $ concat [[a],"oo ",[b]:"ar") }
10:52:25 <lambdabot>  Parse error
10:52:36 <Botje> > do { a <- "Ff"; b <- "Bb"; return $ concat [[a],"oo ",[b]:,"ar] }
10:52:36 <lambdabot>  Parse error
10:52:37 <Japsu> hmm, I never thought one could use do like that
10:52:42 <Botje> oh bugger.
10:52:44 <Japsu> but a list is a monad, so..
10:52:49 <Botje> > do { a <- "Ff"; b <- "Bb"; return $ concat [[a],"oo ",[b],"ar"] }
10:52:50 <lambdabot>  ["Foo Bar","Foo bar","foo Bar","foo bar"]
10:52:52 <Botje> damn keyboard.
10:53:15 <Saizan> Japsu: is just like list comprehension
10:53:18 <Botje> in the list monad, <- roughly means "take one of these now and come back later for the rest"
10:53:25 <Japsu> yeah
10:54:48 <Saizan> > [[a:"oo",b:"ar"] | a <- "Ff", b <- "Bb"]
10:54:49 <lambdabot>  [["Foo","Bar"],["Foo","bar"],["foo","Bar"],["foo","bar"]]
10:55:38 <Botje> ah yes, the venerable list comprehension.
11:01:35 <fantasma> is there any information on getting syntax highlighting
11:01:54 <allbery_b> @where hscolour
11:01:54 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
11:02:02 <fantasma> thanks
11:02:49 <fantasma> is that how hpaste does it's coloring?
11:03:42 <allbery_b> not sure, but I think so
11:03:48 <allbery_b> derived from it, at least
11:03:54 <shachaf> fantasma: Yes.
11:08:47 <sorear> fantasma: hscolour is a simple filter OR a library.  use it in the command line or a program.  Are you talking about syntax highlighting for an editor?
11:09:00 <sorear> fantasma: vim comes with a 'haskell' filetype mode
11:09:11 <fantasma> sorear, im talking about HTML output
11:09:29 <sorear> fantasma: k. that'll be VERY easy
11:09:47 <fantasma> can it be done "on the fly"?
11:09:54 <sorear> fantasma: HsColor -html < myfile.hs > myfile.html
11:10:03 <sorear> fantasma: does apache support filters?
11:10:13 <fantasma> yeah
11:10:38 <sorear> fantasma: well, shouldn't be too hard then :)
11:10:57 <sorear> fantasma: might be worth posting a howto on the wiki
11:11:00 <sorear> hello augustss
11:11:19 <fantasma> my guess is that hpaste uses perl to call hscolor
11:11:36 <sorear> why perl?
11:11:45 <tibbe> I need to get a stable version of the Hoogle source
11:11:55 <fantasma> it's widely supported apache filter (mod_perl)
11:11:58 <tibbe> is it possible to ask darcs for defined tasks?
11:12:02 <allbery_b> hpaste isn't apache
11:12:05 <allbery_b> it's HAppS
11:12:11 <sorear> hpaste is (1) a command line filter (2) a library that haskell programs can use
11:12:21 <sorear> hpaste is a haskell program :)
11:12:21 <fantasma> oh
11:12:32 <allbery_b> the redirector at hpaste.org is apache, but all it does is forward to another port
11:12:34 <sorear> actually it doesn't use any external server
11:12:38 <allbery_b> where HAppS runs
11:12:53 <sorear> http://hpaste.org:8000/
11:13:31 <sorear> Server: HAppS/0.8.4
11:13:48 <fantasma> can HAppS work with CGI scripts?
11:13:55 <sorear> which is a lie, hpaste uses the unstable version (currently known as 0.9.0)
11:14:22 <sorear> fantasma: how do you mean?  like use happs to write a cgiscript?  or have a happs program run cgiscripts?
11:14:44 <fantasma> run cgi scripts
11:18:28 <psnl> anyone here used gtk sourceview?
11:18:43 <rufius> Can a 'liftM read getLine' retrieve a tuple?
11:19:18 <rycee> Hey, quick newbie question. Given "do { a <- stuff; b <- takesLongTime; return $ Node a b }" in the IO monad, can I make b evaluate lazily somehow?
11:19:24 <resiak> > (read "(1,'c')") :: (a,b)
11:19:24 <sorear> rufius: it could, but you should use the standard fun instead.
11:19:25 <lambdabot>        add (Read a, Read b) to the expected type of an expression
11:19:26 <lambdabot>     In the ...
11:19:30 <resiak> whoops :(
11:19:31 <sorear> @type readLn
11:19:33 <lambdabot> forall a. (Read a) => IO a
11:20:02 <sorear> rycee: yes...  does takesLongTime do any IO?
11:20:06 <rufius> Ya... I'm trying to read a tuple from the cli... looking for a good way to do it
11:20:37 <rycee> sorear: Potentially.  But usually not :-)
11:21:13 <rycee> sorear: It could do IO, but if the computation isn't needed then I wouldn't want the IO anyway...
11:22:24 <sorear> rycee: there is a way to make it run lazily, but it's one of the unsafe functions, because the IO will happen never, or at a hard-to-predict time
11:22:30 <sorear> rycee: better avoided in most cases (but sometimes it is needed, eg to implement getContents the recursive call must be lazy and must be IO)
11:22:39 <Lemmih> rycee: Is the function idempotent?
11:23:00 <sorear> rycee: System.IO.Unsafe.unsafeInterleaveIO, and don't tell anyone who told you.
11:23:26 <rycee> Right, I thought about usafeInterleaveIO but wasn't sure whether that would do it.
11:23:34 <rycee> Lemmih: Yeah.
11:24:01 <rycee> Basically, the IO is done within a module and only a "safe" interface is provided to the outside.
11:24:14 <Lemmih> rycee: I'd use 'unsafePerformIO', then.
11:24:38 <Lemmih> (given refactoring is out of the question)
11:24:57 <rycee> Aye.  I consider myself warned :-)
11:25:00 <rycee> Many thanks.
11:34:47 <Gwern> can I have multiple modules in the same file?
11:35:14 <sorear> I think so ...
11:35:18 <sorear> @where report
11:35:19 <lambdabot> http://www.haskell.org/onlinereport/
11:35:45 <mauke> I don't think so
11:36:20 <sjanssen> huh, why doesn't Maybe instance Monoid?
11:36:21 <Igloo> You can't
11:36:40 <SamB> you can't?
11:36:56 <Igloo> Although the report won't tell you that, as it doesn't deal with such low level things as files
11:37:00 <Gwern> well, I ask since the haskell wikibook says "one module per file"
11:37:03 <SamB> oh.
11:37:11 <Gwern> (and that seemed a bit restrictive to me
11:37:19 <SamB> Gwern: I haven't seen any compiler that can do it otherwise
11:37:42 <SamB> you may of course write one if you like
11:38:28 <sorear> @instances Monoid
11:38:29 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
11:38:36 <Gwern> SamB: hah! and once I do that, I'll bang out a universe simulator which uses to lazy evaluation to only simulate universes simular to ours
11:39:07 <Gwern> (and all that completed, I'll have dinner and tell my significant other about all the programming I did today)
11:40:31 <sorear> + ByteString, LPS, IntSet, (a,b,c,d), (a,b,c,d,e), IntMap, Seq, Set, Map
11:41:15 <sorear> @users
11:41:15 <lambdabot> Maximum users seen in #haskell: 336, currently: 314 (93.5%), active: 42 (13.4%)
11:42:14 <psnl> question: are the hIDE screenshots faked?
11:42:25 <Lemmih> Nope.
11:42:28 <sjanssen> sorear: doesn't that seem strange?
11:42:30 <SamB> define faked
11:42:44 <hpaste>  zbrown pasted "Whats up with this?" at http://hpaste.org/793
11:42:51 <tibbe> what's neil mitchel's nick?
11:42:56 <rufius> Someone wanna take a look at that for me?
11:42:57 <sjanssen> tibbe: ndm
11:43:28 <sorear> @seen zbrown
11:43:29 <lambdabot> zbrown has changed nick to rufius.
11:43:29 <lambdabot> rufius is in #haskell. I last heard rufius speak 32s ago.
11:43:33 <hpaste>  sjanssen annotated "Whats up with this?" with "operator precedence" at http://hpaste.org/793#a1
11:44:01 <rufius> sorear: oops sorry
11:44:14 <psnl> Lemmih: cool, thanks
11:44:26 <sorear> zbrown: np.  lambdabot nick tracking exists for this.
11:44:32 <zbrown> :-D
11:44:32 <hpaste>  sjanssen annotated "Whats up with this?" with "more fixes" at http://hpaste.org/793#a2
11:44:39 <zbrown> thanks sjanssen
11:44:39 <sorear> @seen rufius
11:44:40 <lambdabot> rufius has changed nick to zbrown.
11:44:40 <lambdabot> zbrown is in #haskell. I last heard zbrown speak just now.
11:44:53 <tibbe> @seen ndm
11:44:53 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 1h 16m 38s ago, and .
11:44:55 <sjanssen> zbrown: are you using the gcd function from the Prelude?
11:45:00 <zbrown> yes
11:45:04 <sorear> bah.
11:45:09 <Lemmih> psnl: Note that hIDE is currently completely broken and will probably remain so forever.
11:45:18 <psnl> SamB: um, thrown together in photoshop. I'm really interested in how they got the little wiggly red lines under bits of source...
11:45:23 <sorear> starting to write in a shell script "case $TY of ..."
11:45:27 <tibbe> anyone managed to build hoogle recently?
11:45:29 <sjanssen> zbrown: then you should call "gcd arg1 arg2" instead of "gcd (arg1, arg2)"
11:45:49 <zbrown> sjanssen: oh right, sorry
11:46:05 <zbrown> sjanssen: im switching between Mathematical and Haskell notations ;)
11:46:15 <zbrown> writing a program to solve a problme instead of doing it by hadn lol
11:46:20 <psnl> Lemmih: yeah, I'm just trying to figure out how they did a bit of the ui
11:46:25 <SamB> psnl: probably the same way as things with spellcheckers do it?
11:46:36 <SamB> I'm sure they weren't photoshopped
11:47:09 <Lemmih> psnl: GHC can give precise error spans.
11:47:28 <SamB> it probably didn't actually do the things that it would look like it would do, but I'm pretty sure it was at least able to look like that
11:48:08 <sorear> psnl: shim can highlight errors right now
11:48:11 <psnl> its less: "how did they know what bit was busted?" as "how do you do a little red line in sourceview?"
11:48:23 <psnl> sorear: ooh, link?
11:48:29 <sorear> @where shim
11:48:30 <lambdabot> http://shim.haskellco.de/trac/shim
11:48:39 <sorear> you'll need emacs however
11:48:48 <sorear> also prepare to unrecord
11:49:09 <sorear> about a week ago beschmi broke shim, pushed, and disappeared of the face of the eart
11:49:24 <psnl> sorear: the link there is a 404
11:50:18 <sorear> http://shim.haskellco.de/trac/
11:50:20 <lambdabot> Title: shim - Trac
11:50:25 <sorear> @where+ shim http://shim.haskellco.de/trac/
11:50:26 <lambdabot> Done.
11:51:30 <sorear> if no new patches arrive by next week I think I'll fix it myself, optimisticly send, and host a (hopefully temporary) fork
11:51:37 <zbrown> If I add returns and such to my code so that it neatly fits on a letter-size page, will that mess up strings etc?
11:52:01 <sorear> zbrown: yes, but that can be worked around
11:52:05 <zbrown> sorear: how so?
11:52:21 <mauke> sweet
11:52:23 <mauke> wmii works
11:52:24 <zbrown> ++'s?
11:52:29 <sorear> zbrown: wait, I had you confused with fantasma.  what are you trying to do?
11:52:53 <mauke> the only problem is that the keybindings clash with amarok
11:52:58 <fantasma> ;)
11:53:03 <sorear> "this is a long str\
11:53:03 <sorear>     \ing broken in the middle"
11:53:14 <zbrown> ok thats what I needed
11:53:15 <zbrown> thanks
11:53:16 <zbrown> :)
11:53:35 <sorear> zbrown: you also trying to do on-the-fly web formatting of haskell?
11:53:54 <sorear> zbrown: remember to wrap comments properly
11:54:03 <wkh> sorear, when i went to bed about 10 hours ago you were talking in here
11:54:10 <zbrown> sorear: no :) just trying to print something neatly and preserve the code.
11:54:13 <wkh> have you been typing in #haskell the entire time?
11:54:38 <monochrom> perhaps sorear just sleeps 6 hours
11:54:51 <sorear> wkh: nah.  I went to bed about 10 hours ago, and woke up about 3 ago
11:55:10 <sorear> I really do sleep!
11:56:02 <dcoutts> psnl, yep, I've used sourceview & glade at the same time.
11:56:10 <monochrom> Hey, I got very close!
11:56:12 <zbrown> I like the fact that generally the longest part of my code is the IO :)
11:56:21 * zbrown likes Haskell a lot for this reason
11:57:02 <dcoutts> psnl, yes, glade doesn't know about sourceview, so you'll have to leave a 'hole' in the ui when you design it in glade, and then add the sourceveiw widget in code at runtime.
11:57:18 <shachaf> mauke: You're using WMII?
11:57:34 <monochrom> Eh, wouldn't you prefer a more imperative language for that, zbrown?
11:57:56 <shachaf> mauke: I recommend binding either Win (Mod4) or Caps (you'll have to edit .xmodmap for that) to your modkey.
11:58:14 <psnl> dcoutts: thanks, got it working after a while
11:58:32 <mauke> shachaf: I did
11:58:42 <dcoutts> psnl, cool, what are you hacking?
11:58:49 <mauke> shachaf: my global amarok keybindings use Win, too
11:58:53 <shachaf> mauke: Oh, Amarok uses Win?
11:58:54 <zbrown> monochrom: more imperative language for what?
11:59:04 <shachaf> mauke: In that case, use Caps (unless you're using it somewhere else).
11:59:32 <monochrom> for a program that has long IO parts
11:59:46 <zbrown> mmm not particularly
11:59:55 <zbrown> at least not for this
12:00:10 <monochrom> You like the do-notation?
12:00:10 <zbrown> this is only a 30 line program
12:00:30 <zbrown> 20 of which are IO
12:00:31 <zbrown> or so
12:01:01 <Philippa> monochrom: it's not been an issue for me
12:01:16 <zbrown> monochrom: Solving the problem was harder in C than solving in Haskell, overall LOC length is shorter in Haskell than in C so Haskell is the better choice
12:01:32 <zbrown> Not to mention when I start writing my simulation model, I'll do the IO in C probably and import Haskell functions directly to C
12:01:36 <monochrom> nice
12:01:46 <zbrown> i plan on writing most of my libraries in haskell then using C for the IO portion
12:01:59 <zbrown> haskell makes solving the math easeir which is the goal
12:03:15 <sjanssen> zbrown: why do you want to do the IO in C
12:04:48 <zbrown> sjanssen: Well there may be some integration with the Swarm framework which is in C/ObjC so some components will incorporate Swarm others will incorporate Haskell
12:05:03 <zbrown> I'm using Haskell for the math, Swarm for the agent-based modeling, and then it all gets tied together in a neat package with C
12:05:54 <sjanssen> ah
12:06:12 <zbrown> its more out of convenience than anything
12:06:38 <zbrown> I'd rather not figure out how to tie Haskell into Swarm, so its easier to tie it in to C, pass it to Swarm, take whatever from Swarm and put it back in C and do the IO there
12:07:09 <zbrown> If that makes any sense
12:12:22 <chr1s__> hey guys
12:12:32 <Vq^> hey chr1s__
12:12:34 <zbrown> hi chr1s__
12:13:07 <chr1s__> quick question: if I generate a lot of functions using template haskell, but don't use them, will they be compiled in the final program too?
12:13:40 <chr1s__> as in: will the unnecessary functions be stripped out?
12:13:46 <Lemmih> The dead code analyzer will probably get them.
12:13:46 <heatsink> If they're not exported from the module, they will be removed when the file is compiled.
12:14:16 <heatsink> Does it find dead code at link time?
12:15:18 <LoganCapaldo> More importantly, will the dead code ananlyzer print something to the screen to the effect of "Hey, you! Programmer! Yu wrote a function you never used!"
12:15:23 <LoganCapaldo> ?
12:16:09 <heatsink> Why did you make me go through all that work to compile a function if you weren't gonna use it?
12:16:12 <Lemmih> LoganCapaldo: With -fwarn-unused-binds, yes.
12:16:48 <LoganCapaldo> sweet
12:16:58 <chr1s__> heatsink: I was just wondering from a theoretical viewpoint ;)
12:17:08 * LoganCapaldo needs to start a collection of "ghc command line options that are useful"
12:17:22 <LoganCapaldo> Hmmm
12:17:48 <sorear> --interactive is by far my favorite.
12:17:56 <LoganCapaldo> Is the Haskell wiki publically editable? And would that be a good place for such a thing?
12:18:02 <chr1s__> LoganCapaldo: yes!
12:18:06 <sorear> yes, and yes
12:18:12 * LoganCapaldo begins
12:19:14 <chr1s__> so what I want to do is write a small web framework, just for fun.
12:19:34 <chr1s__> of course my language of choice is going to be haskell, and my reference implementation is going to be rails
12:21:05 * heatsink wonders why web frameworks are so popular as practice projects
12:22:11 <chr1s__> heatsink: I think a lot of young programmers start with building websites
12:22:32 <chr1s__> you start with HTML (really easy), then add some CSS, semantic markup, javascript
12:22:37 <wkh> the supply of reasons for software not to be web-based is gradually disappearing over time
12:22:38 <chr1s__> maybe you'll start in PHP
12:23:05 <heatsink> Hmm, that makes sense.
12:23:12 <chr1s__> and there is a *lot* of room for improvement, there's even extremely good programmers working on websites
12:23:26 <chr1s__> for me, it's a problem I'm familiar with
12:23:37 <wkh> yes, this "internet" thing has kind of caught on
12:24:02 <chr1s__> yeah, the interweb rulezzz!!!11one
12:24:07 <zbrown> Hmmm I tend to dislike 'web-based programming'
12:24:26 <chr1s__> zbrown: any good reasons for that?
12:24:27 <zbrown> Not that its trivial or not important, but I find it boring and mundane.
12:24:39 * allbery_b occasionally thinks the intertubes are overdue for sulfuric acid treatment :)
12:24:54 <zbrown> chr1s__: Essentially everyone is creating a different version of the same thing(s).
12:25:10 <TomMD> chr1s__: Wouldn't it be better to show a reason for web-based apps thanks ask for reasons against it?
12:25:17 <wkh> the interesting thing about web apps is the unbelievable amount of duplicated functionality and work
12:25:33 <chr1s__> for me it is really easy: I'm having fun doing it.
12:25:34 <wkh> even in frameworks considered to be among the best, like ruby on rails
12:25:57 <wkh> they are also extremely averse to abstraction
12:26:00 <zbrown> chr1s__: Granted, this comes from someone who primarily writes his programs for numeric/scientific applications so therefore I prefer an academic challange :)
12:26:00 <chr1s__> but ruby on rails is written in a loosely-typed language
12:26:07 <zbrown> s/challange/challenge
12:26:08 <wkh> they never want to move above the metal.
12:26:15 <wkh> they don't want to ignore the details of http, cookies, and the like
12:26:37 <chr1s__> zbrown: I'm currently writing a big Java web-framework at work, and there's lots of interesting challenges there.
12:26:44 <wkh> so in many ways among the only innovative efforts wrt web programming is things like Seaside
12:26:59 <chr1s__> wkh: is that the XSLT-based thing?
12:27:08 <wkh> are you thinking of Cocoon?
12:27:11 <wkh> Seaside = Smalltalk
12:27:17 <chr1s__> ah ok, nice.
12:27:19 <zbrown> chr1s__: ah see, but do they deal with big numbers and diffusion distributions lol? Thats my problem, I like the math and science behind a problem.
12:27:36 <Philippa> so look at the /structures/ in a web framework. You'll find plenty of ways to drag stuff out from there
12:27:43 <wkh> web programmres don't care about what you have to say if it isn't about databases and http.
12:27:53 <Philippa> there's lots of info flow to facilitate, lots of interesting properties to maintain...
12:27:55 <wkh> i gave a talk about evolutionary computation at a ruby users group
12:28:01 <wkh> they looked at me like i grew a second head
12:28:04 <wkh> their jaws literally dropped
12:28:13 <chr1s__> zbrown: of course not ;)
12:28:17 <zbrown> chr1s__: I do what you do at work. I'm writing a java-based interface to an IBM Mainframe program called RDS which is a digital library of all my University's documents, its boring work to me, but my research works with vector-borne disease modeling ;)
12:28:21 <Philippa> well yeah, it's not something ruby's well-fitted to
12:28:33 <wkh> for certain things it would be just fine
12:28:35 <zbrown> chr1s__: the work is boring to me but I understand tha tothers find it entertaining. Just not my thing :-D
12:28:52 <zbrown> wkh: this is true. I did a some projects using python for something like that
12:28:57 <Philippa> zbrown: I suspect what you're talking about I'd find boring-but-doable
12:29:00 <chr1s__> zbrown: I agree. But I can still get fun out of webbased programming in lesser languages
12:29:11 <zbrown> Philippa: yup, its just a preference issue
12:29:23 <zbrown> chr1s__: ^^ that applies to you too :-D
12:29:24 <Philippa> the fun's largely in doing as good a job of it as you can, IME
12:29:34 <wkh> zbrown: if it's interactive, then the fitness function, which is always the bottleneck in optimization metaheuristics, spends its time waiting for human feedback and it doesn't matter so much whether you're in C or Ruby
12:29:34 <zbrown> I'm not belittling web-based programming, just saying its not for me :-D
12:29:35 <Philippa> and finding ways to show up all those junior coders who think they know it all
12:29:56 <zbrown> Philippa: yup
12:30:06 <chr1s__> but there must be a reason for me programming Haskell at night and in the weekends ;)
12:30:14 <zbrown> hehe
12:30:22 <wkh> haskell is innovative
12:30:27 <nmessenger> write a compiler!  It's the popular thing to do :)
12:30:28 <zbrown> chr1s__: im going to be using haskell in my project so its sensible for me to use it :-d
12:30:39 <chr1s__> nmessenger: I already wrote a javascript-compiler ;)
12:31:05 <chr1s__> zbrown: I'm writing a Java-framework, so I don't think I'd be allowed to use haskell for work-purposes ;)
12:31:11 <zbrown> heh
12:31:18 <zbrown> chr1s__: I'm doing similar
12:31:30 <zbrown> at work I work in VB.NET C# and Java
12:31:49 <pejo> nmessenger, better suggest they hack on an existing one - like ghc!
12:31:52 <chr1s__> I really like to show some of my coworkers the type-inference and stuff like that
12:31:52 <zbrown> but at my research job, i work in C and Haskell :-
12:31:53 <zbrown> :-D
12:32:03 <nmessenger> pejo: ;)
12:32:14 <chr1s__> for example, when I show them (map (\x->x*x) [1..]) they really like it
12:32:22 <LoganCapaldo> Haskell is gradually killing that whole "make my own PL" desire in me
12:32:29 <chr1s__> but they'll say: well, it's very cool, but you can't get there with loose typing.
12:32:32 <LoganCapaldo> which kind of makes me sad actually
12:32:44 <allbery_b> java framework... yhc has a jvm backend, doesn't it? :)
12:32:47 <chr1s__> and they'll say: "Java has a way better type-system"
12:32:53 <nmessenger> LoganCapaldo: why killing it?  'Cause it provides more and more of your ideal?  :)
12:33:05 <chr1s__> and it's funny to tell them that Haskell is actually better typed than Java
12:33:13 <LoganCapaldo> nmessenger: More like, my ideal wasn't all that good to begin with :)
12:33:14 <Philippa> and how much better so :-)
12:33:40 <LoganCapaldo> The bar is too high now :)
12:34:15 <pejo> Yeah, nobody sane designs a new language that is better than Haskell.
12:34:17 <largos> LoganCapaldo: on a similar vein... my desire to build my haskell knowledge is an exponential funciton of the time I have to spend working with c#...
12:34:28 <pejo> Wish there was more insane people, who underestimated how much work it is.
12:34:51 <chr1s__> pejo: I think that these guys in Nottingham are building some cool language
12:35:07 <pejo> chris, which one of them?
12:35:32 <chr1s__> pejo: Epigram is supposed to be really cool
12:35:42 <chr1s__> but probably not ready for use in practice yet
12:36:10 <wkh> the proper enterprisey term is
12:36:11 <wkh> "
12:36:14 <wkh> not ready for primetime"
12:36:28 <chr1s__> wkh: hehe
12:36:32 <wkh> a language is going on 20-30 years old, compilers are lightning fast and rock-solid
12:36:43 <wkh> "not ready for primetime [because anything that's different scares us]"
12:36:45 <pejo> Could anyone comment how much in Epigram that is new, from McBrides dissertation?
12:37:07 <chr1s__> pejo: I wouldn't know. But there are some really smart people working on it ;)
12:37:29 <SamB> one nice feature of epigram is that it is impossible to write a webserver in it
12:38:05 <LoganCapaldo> SamB: I feel like you actually have a proof for that too :)
12:38:32 <SamB> well, I've heard that it is impossible to write nonterminating programs in epigram
12:38:43 <SamB> a webserver is nonterminating
12:38:44 <SamB> so...
12:38:49 <LoganCapaldo> QED
12:39:03 <Philippa> SamB: currently, yes
12:39:04 <paolino> where can I learn the basics to use  readsPrec ?
12:39:37 <yip> SamB: i'm not sure that's entirely correct
12:39:55 <chr1s__> I don't think there are nonterminating programs.
12:40:21 <LoganCapaldo> Now, I'm just pulling this out of my random skimming, but  thought the point wasn't to write only terminating programs, but rather to know for certain whether a program was non-terminating or not?
12:40:40 <pejo> chris, is that a philosophical statement?
12:40:43 <LoganCapaldo> Or is that not the goal?
12:40:45 <chr1s__> yes :p
12:41:08 <nmessenger> paolino: I'm not sure if there's any tutorial material.  Do you understand the docs well enough?
12:41:11 <SamB> yip: what, you've heard of webservers that crash?
12:41:39 <LoganCapaldo> ideal webserver on ideal internet :)
12:43:09 <yip> SamB: i'd imagine that epigram will have some sort of IO system similar to haskell, and there is a difference between a non terminating program, and an IO action that never ends
12:43:31 <SamB> yip: hmm.
12:43:53 <SamB> does epigram support infinitely long lists?
12:44:20 <yip> i don't know much about epigram
12:45:31 <paolino> nmessenger: I don't have any idea of the parsing model
12:46:12 <paolino> I see lexP around with other functions
12:46:51 <Philippa> SamB: not currently
12:46:58 <malsyned_> Parsec is my favorite library ever.  I've twice chosen Haskell for projects solely on the basis of its availability.
12:47:19 <Philippa> yip: don't assume non-termination and IO'll necessarily go together though!
12:48:10 <yip> Philippa: what do you mean?
12:49:14 <paolino> nmessenger: the docs are not explaining what's behind those signatures
12:51:22 <nmessenger> paolino: I've no experience with them either, did you want to implement your own readsPrec?
12:51:48 <paolino> yes for String
12:52:05 <paolino> newtpe Lev  = Lev String
12:52:42 <augustss> SamB: I don't think Epigram supports codata yet.
12:53:06 <SamB> how about cocode?
12:53:16 <paolino> I want it to parse "Lev paolino" instead of "Lev \"paolino\""
12:57:31 <nmessenger> I would probably start with the example readsPrec and change it to fit my needs.
12:58:22 <paolino> mhm, my problem is how to push the " in the input
12:58:30 <paolino> if that is the way to go
13:01:02 <user317> is there a better way to get randoms through a recursion?  because right now i am calling ranomdR and passing the returned generator down my recursion, but i need a bunch of randoms, so i am calling (r1, g1) = randomR 0 1 g0; (r2, g2) = randomR 0 2 g1;...
13:01:04 <sorear> augustss: type List a = forall r. (forall s. s -> (s -> (forall k. k -> (a -> s -> k) -> k)) -> r) -> r
13:01:14 <sorear> that's valid System F
13:01:27 <sorear> Epigram supports rankN polymorphism?
13:01:41 <sorear> church encoding of codata!
13:02:03 <mattam> i guess so sorear, it has Type: Type anyway
13:02:37 <david_> Someone feels like looking at a small thing I made and tell me where it's bad Haskell code ? ( it must be, I'm a beginner )
13:02:54 <sorear> sure, hpaste it
13:02:56 <sorear> @paste
13:02:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:03:29 <sorear> or give a url if it's biggish (>150 lines) and online
13:03:31 <hpaste>  david_ pasted "decode base64 strings" at http://hpaste.org/794
13:03:43 <david_> there
13:04:12 <david_> it's a funtion to decode a list of string encoded in base64
13:04:18 <Philippa> sorear: you'll never be able to build an infinite list in Epigram though
13:04:41 <Philippa> or even attempt it
13:04:45 <Botje> user317: you can use unfoldr together with randomR
13:04:55 <sorear> Philippa: sure I will.  I don't know epigram, but I can define an infinite list in System F using that type, which is strongly normalizing too
13:05:15 <sorear> Philippa: that type supports infinite lists in strongly normalizing languages
13:05:18 <user317> Botje, what do you mean?
13:05:25 <sorear> Philippa: the catch is you can't define foldr
13:05:34 <nmessenger> david_: small word of warning for the future, if you put an if/then/else in a do block, you *must* indent the else further than the if or they'll be parsed as seperate (invalid) statements.
13:05:50 <Botje> > unfoldr (\g -> Just $ randomR 0 1 g) 42
13:05:51 <lambdabot>  Couldn't match expected type `b -> a'
13:05:55 <Philippa> sorear: which rather stops you /building/ anything
13:05:56 <psnl> dcoutts: currently, a mess
13:06:04 <david_> nmessenger: oh ok !
13:06:10 <david_> didn't know that.
13:06:33 <user317> Botje, that just gives me a list between 0 and 1, what i need to do is get a few randoms with different ranges
13:06:35 <Philippa> the best you can actually do is taking n from it. Big deal
13:06:49 <sorear> david_: foldl (++) [] is 'concat'
13:06:51 <Botje> user317: oh. different ranges? yeah. you're screwed.
13:07:05 <Botje> user317: you could use state to store the generator
13:07:17 <nornagon> sorear: why not foldl1 (++)?
13:07:20 <sorear> david_: don't use foldl 95% of the time - foldr plays much nicer with haskell's evaluation strategy
13:07:28 <sorear> > concat []
13:07:29 <lambdabot>  []
13:07:33 <nornagon> ah.
13:07:35 <sorear> > foldl1 (++) []
13:07:36 <lambdabot>  Exception: Prelude.foldl1: empty list
13:07:45 <user317> Botje, hmm, it seems like something a monad should be able to do, keep track of the generators and make sure there is new one when i get the next random, but monads still confuse me
13:08:01 <Botje> user317: the state monad isn't too hard
13:08:20 <david_> sorear: you mean with the lazyness ?
13:08:34 <narain> david_: i would use  map  rather than the  [chr a1,...]  and  i* = conv64 c*  stuff
13:08:59 <david_> narain : how would you do it ?
13:09:22 <sorear> david_: yes
13:09:23 <narain> is = map conv64 [c1,c2,c3,c4]
13:09:28 <user317> Botje, ah i found a good example that does just that
13:09:35 <fantasma> > let foo = sum $ filter (\x -> x == (sum . factors . sum . factors) x) [1..10000] in foo
13:09:36 <lambdabot>   Not in scope: `factors'
13:09:50 <narain> it's nicer if you had [c1,...] already as a list
13:09:58 <Botje> yeah, I had an example too, but it uses StateT as opposed to State
13:10:02 <fantasma> > let factors n = filter (\x -> n `mod` x == 0 ) [1..(n-1)]; foo = sum $ filter (\x -> x == (sum . factors . sum . factors) x) [1..10000] in foo
13:10:06 <lambdabot> Terminated
13:10:15 <fantasma> @karma- lambdabot
13:10:15 <lambdabot> lambdabot's karma lowered to 38.
13:10:39 <heatsink> david_: i = sum $ zipWith shiftL is [18,12..0]
13:10:52 <hpaste>  nmessenger pasted "paolino, something like this?" at http://hpaste.org/795
13:11:06 <david_> narain : I guess I can change decode64'' to take a list instead of tuples
13:12:03 <fantasma> anyone here know what amicable pairs are?
13:12:16 <narain> david_: you could also replace decode64' with a generic function to split a list into chunks of given size
13:12:24 <nmessenger> amicable = friendly, so I've no idea
13:12:31 <narain> and map decode64'' on the result
13:12:56 <fantasma> nmessenger, haha that's true, hadn't realized that
13:13:09 <narain> @google amicable pairs
13:13:09 <paolino> nmessanger thanks, how do I read the list comprehension ?
13:13:11 <lambdabot> http://mathworld.wolfram.com/AmicablePair.html
13:13:11 <lambdabot> Title: Amicable Pair -- from Wolfram MathWorld
13:13:23 <david_> heatsink : ok I get it.
13:13:35 <narain> fantasma: i see what they are, but not why they would be interesting
13:13:56 <fantasma> narain, well tell me if this implementation of finding amicable pairs makes sense to you
13:14:14 <nmessenger> paolino: lex returns a list of (lexeme, remainder) pairs, we just want those pairs that start with "Lev"
13:14:48 <fantasma> > let factors n = filter (\x -> n `mod` x == 0 ) [1..(n-1)]; foo x = x == (sum . factors . sum . factors) x in foo 220
13:14:49 <lambdabot>  True
13:15:10 <fantasma> (220 is an amicable pair)
13:15:24 <fantasma> > let factors n = filter (\x -> n `mod` x == 0 ) [1..(n-1)]; foo x = x == (sum . factors . sum . factors) x in foo 284
13:15:26 <lambdabot>  True
13:15:32 <narain> fantasma: how is 220 a pair?
13:15:38 <psnl> dcoutts: do you have any idea how to do the underlining in sourceview?
13:15:46 <david_> ok I'll try to rewrite it with all the advices.
13:15:50 <nmessenger> paolino: for those, we result in the pair (Lev remainder, ""), since type ReadS Lev = String -> [(Lev, String)]
13:15:52 <fantasma> narain, it's a pair with 284
13:16:22 <fantasma> narain, it would be better if i say if True then there's an amicable pair for the given integer
13:16:41 <fantasma> > let factors n = filter (\x -> n `mod` x == 0 ) [1..(n-1)]; foo x = x == (sum . factors . sum . factors) x in foo 6
13:16:43 <lambdabot>  True
13:16:46 <fantasma> > let factors n = filter (\x -> n `mod` x == 0 ) [1..(n-1)]; foo x = x == (sum . factors . sum . factors) x in foo 7
13:16:48 <lambdabot>  False
13:16:50 <nmessenger> david_: do you need a "split into chunks" function?  They're a popular thing to write here.
13:17:17 <narain> nmessenger: heh, i asked that a couple of days ago :)
13:17:38 <david_> well I guess I was going to write :
13:17:38 <david_>     decode64' :: String -> [String]
13:17:38 <david_>     decode64' (c1:c2:c3:c4:r) = [ c1,c2,c3,c3 ] ++ decode64' r
13:17:38 <david_>     decode64' (c1:c2:c3:[])   = [ c1,c2,c3,' ' ]
13:17:38 <david_>     decode64' (c1:c2:[])      = [ c1,c2,' ',' ']
13:17:38 <david_>     decode64' (c1:[])         = [ c1,' ',' ',' ']
13:17:40 <fantasma> me too I believe ;)
13:17:43 <narain> > let factors n = filter (\x -> n `mod` x == 0 ) [1..(n-1)]; foo x = (sum . factors) x in foo 220
13:17:44 <lambdabot>  284
13:17:50 <narain> ah i see now
13:17:52 <fantasma> narain, exactly
13:18:06 <nmessenger> @type chunks n = Data.List.unfoldr (let f [] = Nothing; f xs = Just (splitAt n xs) in f)
13:18:08 <lambdabot> parse error on input `='
13:18:13 <paolino> nmessenger: the entire 's' is not stripped from spaces
13:18:14 <fantasma> so I found all the amicable pairs for 1..10000
13:18:19 <nmessenger> @type \n -> Data.List.unfoldr (let f [] = Nothing; f xs = Just (splitAt n xs) in f)
13:18:22 <lambdabot> forall t. Int -> [t] -> [[t]]
13:18:28 <fantasma> but projecteuler.net says im wrong ;(
13:18:46 <nmessenger> paolino: you wanted that?
13:19:17 <paolino> I want a good parser possibly
13:19:35 <david_> nmessenger : well yours is definately shorter :)
13:19:41 <narain> fantasma: does it tell you anything other than that you are wrong?
13:20:02 <fantasma> narain, nope
13:20:16 <fantasma> narain, I'm asking in #math...let's see what they think
13:20:16 <narain> bah :)
13:20:20 <paolino> is lex able to parse a non quoted string ?
13:20:28 <narain> maybe the oeis has something
13:21:22 <narain> fantasma, check out the first four at http://www.research.att.com/~njas/sequences/Sindx_Am.html
13:21:23 <lambdabot> Title: Index to OEIS (Section Am)
13:22:01 <fantasma> narain, woah nice!
13:22:14 <fantasma> i had no idea such thing existed
13:22:37 <mauke> is there a channel for WMII?
13:22:48 <narain> i happened to see a link to the oeis on #haskell itself in the recent past :)
13:23:09 <nmessenger> paolino: read the docs or use the repl!
13:23:13 <shachaf> mauke: Yes, but not on Freenode.
13:23:37 <mauke> where?
13:23:38 <narain> fantasma, any idea why amicable pairs are interesting, apart from being a mathematical curiosity and a problem on project euler?
13:23:43 <fantasma> mauke, it's on irc.oftc.net
13:23:44 <chr1s__> I think I saw something like `"hi" . replicate 5 . map (toUpper)` a while ago (without the backticks).
13:23:46 <shachaf> mauke: It's on irc.oftc.net .
13:24:02 <fantasma> narain, no idea haha
13:24:14 <yip> man i'm getting the weirdest ghc error:
13:24:14 <chr1s__> they were using the . syntax as in object-oriented languages
13:24:14 <yip> /tmp/ghc19709_0/ghc19709_0.hc:7:20:
13:24:14 <yip>      error: HsTime.h: No such file or directory
13:24:21 <narain> by the way the problem may be that your function returns true for 6
13:24:34 <fantasma> narain, yah and everything up to 220
13:24:41 <mauke> shachaf: thanks
13:24:48 <narain> i guess a number paired with itself doesn't count
13:24:56 <fantasma> >let factors n = filter (\x -> n `mod` x == 0 ) [1..(n-1)]; foo x = (sum . factors) x in foo 6
13:25:01 <fantasma> > let factors n = filter (\x -> n `mod` x == 0 ) [1..(n-1)]; foo x = (sum . factors) x in foo 6
13:25:02 <lambdabot>  6
13:25:15 <fantasma> hmmm, guess that's why
13:25:18 <nmessenger> chr1s__: that was probably PLEAC.  It's an abomination, purge it from your mind!
13:25:24 <chr1s__> nmessenger: ok.
13:25:43 <fantasma> > let factors n = filter (\x -> n `mod` x == 0 ) [1..(n-1)]; foo x = (sum . factors) x in foo 8128
13:25:45 <lambdabot>  8128
13:26:42 <narain> fantasma, you probably just need to throw in a  x /= sum . factors $ x  check in there
13:27:07 <shachaf> fantasma: Are you sure perfect numbers aren't amicable pairs with themselves?
13:27:07 <narain> fantasma: let me know if you get the ostensibly correct answer :)
13:28:04 <narain> shachaf: according to mathworld perfect numbers don't count: "The smallest amicable pair is (220, 284)"
13:29:00 <fantasma> alright, calculating now
13:29:39 <fantasma> might take a few minutes =(
13:30:09 <shachaf> narain: Yes, and according to the Wikipedia "A pair of amicable numbers constitutes an aliquot sequence of period 2."
13:30:41 <narain> so somebody decided that if two numbers' factors add up to each other we'll call them "amicable" and mathematicians have been looking for such pairs ever since with no idea whether they're good for anything or not?
13:30:50 <narain> heh. mathematicians.
13:31:11 <fantasma> haha
13:31:23 <narain> shachaf: that's an interesting generalization
13:31:45 <LoganCapaldo> So it's sum(factors(a)) = b and sum(factors(b)) = a ?
13:32:06 <LoganCapaldo> weird
13:32:10 <narain> LoganCapaldo: yes
13:32:12 <SamB> do mathematicians also look for "love triangles"?
13:32:29 <fantasma> answer I got was 31626 ...lets check!
13:32:30 <narain> SamB: "A sociable number has a repeating aliquot sequence of period 3 or greater."
13:32:36 <user317> i wish the examples showed every argument, its hard to follow how functions combine for a begginer
13:32:45 <fantasma> correct!!!
13:32:50 <narain> hooray!
13:32:58 <nmessenger> hootay!
13:33:16 <malsyned_> user317: you can use an interactive interpreter like hugs or ghci to get the type signature for a function.
13:33:19 <shachaf> narain: And then there are "aspiring numbers", like 95.
13:33:20 <LoganCapaldo> Is every number a member of some amicable pair I wonder?
13:33:24 <malsyned_> with the :type command
13:33:29 <SamB> I guess perfect numbers form aliquout sequences of period one?
13:33:30 <narain> shachaf: what are those?
13:33:34 <narain> SamB: yes
13:33:36 <user317> malsyned_, yea, thats what i end up doing
13:33:44 <shachaf> narain: 95, 25, 6.
13:33:48 <david_> @ype .&. . shiftR
13:33:51 <lambdabot> parse error on input `.&.'
13:34:09 <david_> @ype (.&.) . shiftR
13:34:09 <narain> shachaf: oh, it's right there on the wikipedia page
13:34:10 <lambdabot> forall a. (Bits (Int -> a), Bits a) => a -> (Int -> a) -> Int -> a
13:34:16 <shachaf> narain: http://en.wikipedia.org/wiki/Aliquot_sequence
13:34:20 <shachaf> narain: Yes.
13:34:32 <malsyned_> I sympathize, but defining functions by composition is so common in Haskell that you're really better off just getting used to reading those definitions.
13:34:53 <nmessenger> david_: what function are you looking for?
13:34:58 <fantasma> mauke!!!
13:35:09 <mauke> fantasma???
13:35:27 <fantasma> mauke, did you start using wmii just today?
13:35:28 <david_> I'm trying to compose the and and shift right in my decode funtion, but ghc gives me an error
13:35:34 <mauke> fantasma: yes
13:35:42 <heatsink> mauke, fantasma: Are you an amicable pair?
13:35:49 <fantasma> hahaha
13:35:51 <narain> heatsink: hahaha
13:36:05 <narain> david_: and takes two args, what's the other one?
13:36:10 <nmessenger> @pl \s x y -> x .&. shiftR y s
13:36:10 <lambdabot> flip ((.) . (.&.)) . flip shiftR
13:36:18 <narain> david_: you can do (.&. 255) . shiftR
13:36:41 <nmessenger> (.&. 255) . (`shiftR` 8) ?
13:36:51 <narain> oh wait, so does shiftR
13:37:27 <narain> :t (.&. 255) . (`shiftR` 8)
13:37:30 <lambdabot> forall a. (Bits a) => a -> a
13:37:35 <david_> narain,nmessenger : thanks !  that's (.&. 255) .shiftR that I'm looking for
13:38:14 <nmessenger> @pl \x -> shiftR x 8 .&. 255
13:38:14 <lambdabot> (.&. 255) . flip shiftR 8
13:38:20 <nmessenger> ask @pl!
13:38:42 <david_> narain,nmessenger : I want to do something like [ a1,a2,a3 ] = map  ((.&. 255) .shiftR) [16,8,0]
13:38:54 <narain> @pl \s x -> shiftR x s .&. 255
13:38:55 <lambdabot> flip flip 255 . ((.&.) .) . flip shiftR
13:38:59 <narain> eek
13:39:06 <narain> @pl \x s -> shiftR x s .&. 255
13:39:06 <lambdabot> flip flip 255 . ((.&.) .) . shiftR
13:39:17 <nmessenger> @type ((255 .&.) .) . shiftR
13:39:18 <yip> @seen kolmodin
13:39:19 <lambdabot> forall a. (Bits a) => a -> Int -> a
13:39:20 <lambdabot> kolmodin is in #darcs, #gentoo-haskell, #haskell.hac07 and #haskell. I last heard kolmodin speak 6m 14s ago.
13:39:25 <nmessenger> @type ((255 .&.) .) . flip shiftR
13:39:27 <narain> @pl \s x -> 255 .&. shiftR x s
13:39:28 <lambdabot> forall a. (Bits a) => Int -> a -> a
13:39:28 <lambdabot> ((255 .&.) .) . flip shiftR
13:39:41 <narain> @pl \x s -> 255 .&. shiftR x s
13:39:41 <lambdabot> ((255 .&.) .) . shiftR
13:40:08 <nmessenger> you could define (f .: g) x y = f (g x y) and do (255 .&.) .: shiftR
13:40:59 <nmessenger> (binary precomposition should be in the libs :/)
13:41:01 <narain> > liftM2 shiftR [1,2,3,4] [1,2,3,4]
13:41:02 <lambdabot>  Add a type signature
13:41:12 <narain> > liftM2 shiftR [1,2,3,4] [1,2,3,4] :: Int
13:41:12 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a1]'
13:41:15 <narain> > liftM2 shiftR [1,2,3,4] [1,2,3,4] :: [Int]
13:41:17 <lambdabot>  [0,0,0,0,1,0,0,0,1,0,0,0,2,1,0,0]
13:41:29 <nmessenger> zipWith
13:41:39 <narain> > zipWith shiftR [1,2,3,4] [1,2,3,4] :: [Int]
13:41:40 <lambdabot>  [0,0,0,0]
13:41:49 <narain> :facepalm:
13:41:52 <narain> > zipWith shiftL [1,2,3,4] [1,2,3,4] :: [Int]
13:41:53 <lambdabot>  [2,8,24,64]
13:42:05 <david_> *Main> let [a1,a2,a3] = (map ((.&. 255) . shiftR) [16,8,0]) 123456
13:42:09 <david_> <interactive>:1:18:
13:42:09 <david_>     Couldn't match expected type `t1 -> [t]'
13:42:09 <david_>            against inferred type `[Int -> a]'
13:42:09 <david_>     In the expression: (map (((.&. 255)) . shiftR) [16, 8, 0]) 123456
13:42:09 <david_>     In a pattern binding:
13:42:09 <david_>         [a1, a2, a3] = (map (((.&. 255)) . shiftR) [16, 8, 0]) 123456
13:42:24 <david_> mhhhhh...
13:42:28 <nmessenger> missed a (.)
13:42:41 <nmessenger> ((.&. 255) .) . flip shiftR
13:43:17 <narain> > :t
13:43:18 <narain> nmessenger:
13:43:18 <lambdabot>  Parse error
13:43:20 <narain> oops
13:43:22 <roconnor> @hoogle assert
13:43:22 <lambdabot> Control.Exception.assert :: Bool -> a -> a
13:43:23 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
13:43:23 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
13:43:26 <narain> :t ((.&. 255) .) . flip shiftR
13:43:29 <lambdabot> forall a. (Bits a) => Int -> a -> a
13:43:40 <narain> can't map that, can you?
13:44:08 <nmessenger> map it over [16, 8, 0] and you'll have a Bits a => [a -> a]
13:44:28 <narain> > let [a1,a2,a3] = (map (((.&. 255) .) . shiftR $ 123456) [16,8,0])
13:44:29 <lambdabot>  Parse error
13:44:54 <narain> > let [a1,a2,a3] = map (((.&. 255) .) . shiftR $ 123456) [16,8,0]
13:44:55 <lambdabot>  Parse error
13:45:03 <narain> this is too messy
13:45:36 <david_> narain : I'm trying to find a way to simplify this :
13:45:36 <david_>         a1 =  (i `shiftR` 16) .&. 255
13:45:36 <david_>         a2 =  (i `shiftR` 8 ) .&. 255
13:45:36 <david_>         a3 =   i .&. 255
13:45:47 <nmessenger> map (.&. 255) $ zipWith shiftR [a1, a2, a3] [16, 8, 0]
13:46:04 <narain> a good solution probably involves repeat, zipWith, and map
13:46:18 <narain> :t repeat
13:46:20 <lambdabot> forall a. a -> [a]
13:46:23 <nmessenger> @type \xs ys -> map (.&. 255) $ zipWith shiftR xs ys
13:46:25 <lambdabot> forall a. (Bits a) => [a] -> [Int] -> [a]
13:46:31 <nmessenger> there you are
13:46:50 <narain> @type \x ys -> map (.&. 255) $ zipWith shiftR (repeat x) ys
13:46:52 <lambdabot> forall a. (Bits a) => a -> [Int] -> [a]
13:47:03 <nmessenger> why would you want to repeat?
13:47:09 <narain> because i is fixed
13:47:14 <nmessenger> oh, right
13:47:20 <david_> yes, I'm shifting the same value 3 times
13:47:33 <user317> i just really confused myself.  in let foo a = (do return a); which makes foo a type of: foo :: forall t (t1 :: * -> *). (Monad t1) => t -> t1 t; why isn't it just type a -> a?
13:47:59 <nmessenger> user317: because foo = return and return :: Monad m => a -> m a
13:48:09 <narain> user317: return constructs a monad
13:48:44 <user317> oh, ok
13:49:05 <narain> > return 5 :: Maybe Int
13:49:06 <lambdabot>  Just 5
13:49:13 <narain> > return 5 :: [Int]
13:49:15 <lambdabot>  [5]
13:49:27 <narain> see?
13:49:28 <user317> aaaah
13:49:37 <user317> hmm, thats pretty cool
13:49:52 <nmessenger> > return 5 :: IO Int
13:49:53 <lambdabot>  <IO Int>
13:50:06 <nmessenger> return is a Monad method
13:50:25 <david_> nmessenger,narain : YAY it works and you guys rock.
13:50:40 * nmessenger high-fives narain
13:50:54 <nmessenger> cool
13:50:57 * narain high-fives nmessenger back
13:51:11 <david_> Let me hpaste the updated version.
13:51:18 <nmessenger> annotate!
13:51:57 <hpaste>  david_ annotated "decode base64 strings" with "updated decode64" at http://hpaste.org/794#a1
13:53:01 <david_> I'm not happy with the if then else part though.
13:54:33 <hpaste>  nmessenger annotated "decode base64 strings" with "little tricks you pick up :D" at http://hpaste.org/794#a2
13:55:38 <QtPlatypus> What is the diffrence between or and || ?
13:55:46 <nmessenger> @type or
13:55:49 <lambdabot> [Bool] -> Bool
13:55:50 <nmessenger> @type (||)
13:55:52 <lambdabot> Bool -> Bool -> Bool
13:55:59 <nmessenger> @src or
13:55:59 <lambdabot> or    =  foldr (||) False
13:56:08 <david_> nmessenger : I had no idea that this syntax was possible :o
13:56:10 <QtPlatypus> Arh
13:56:20 <david_> I mean the case ()
13:56:26 <narain> nmessenger: that's bizarre :D
13:56:28 <nmessenger> @type ()
13:56:31 <lambdabot> ()
13:56:47 <nmessenger> david_: also I'm not sure about the otherwise under conv64, if the data's bad I'd rather it fail than silently corrupt.
13:57:11 <narain> david_: how about map chr (takeWhile (/= 0) as)
13:57:34 <nmessenger> @src concat
13:57:34 <lambdabot> concat = foldr (++) []
13:57:48 <narain> david_: where as = [a1,a2,a3]
13:57:49 <nmessenger> david_: use concat instead of foldl (++) ""
13:58:18 <nmessenger> david_: in fact, the concat should be done outside decode64, which should have type String -> String
13:58:51 <david_> nmessenger : true but I don't know yet, a did a try that returned nothing ( and the other cases would return Just ... ) but I didn't where to go from here.
13:59:12 <nmessenger> david_: just drop the otherwise and it'll throw an error.
13:59:24 * narain goes afk looking for a bite to eat
13:59:55 <david_> narain : I like your suggestion. ( map chr... )
14:00:24 <nmessenger> ah, of course, 'tis indeed better
14:02:45 <user317> @hpaste
14:02:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:03:09 <sorear> david_: why do you ignore the last char of the input?
14:03:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/796
14:04:05 <user317> can someone help me figure out why this doesnt work, i am trying to generate a list of randoms using the state monad, http://hpaste.org/796
14:04:48 <david_> sorear : because in my (stupid) test case the input ends with "=" which means the end of the stream, but I end the conversion at the end of the string.
14:05:22 <david_> the test string is from wikipedia/base64 by the way.
14:06:49 <zbrown> Any ppl versed in discrete math wanna look at this problem and see if they can 'push' me in the right direction?
14:07:01 <zbrown> thief_grr: it gave me a hint saying i need to use two cases, one for even numbers and one for odd.
14:07:02 <augustss> user317: that looks very convoluted
14:07:05 <zbrown> oops
14:07:13 <zbrown> Got a question: "Use strong induction to show that every positive integer n can be written as a sum of distinct powers of two, that is, as a sum of a subste of the integers 2^0=1, 2^1=2, 2^2=4, and so on." I'm not sure how to proceed with the inductive step.
14:07:23 <Azmodan> I installed the haskell-mode for emacs (via apt-get, on Kubuntu) and C-c C-z doesn't work, it gives : "Symbol's function definition is void: switch-to-haskell".  How do I define it?
14:07:24 <hpaste>  david_ annotated "decode base64 strings" with "(no title)" at http://hpaste.org/794#a3
14:07:27 <fantasma> lol you asked this in #math 10 minutes ago zbrown
14:07:36 <sorear> Azmodan: find inf-haskell.el and load it.
14:07:37 <zbrown> fantasma: i know
14:07:46 <sorear> Azmodan: autoload is b0rked for haskell-mode
14:07:47 <Azmodan> sorear: Thanks
14:08:10 <user317> augustss, to me monads are convoluted :)
14:08:13 <zbrown> fantasma: didn't get a finsihed answer ;) i've asked in here before and gotten some help so ifigured it doesnt hurt to cover the basis
14:08:26 <zbrown> bases*
14:08:39 <fantasma> zbrown, I hear ya, #haskell is generally very good with math
14:08:48 <zbrown> yup
14:08:58 <sorear> david_: concat (map f l) == concatMap f l == (if you like terseness) f =<< l
14:10:01 <wkh> i must be misunderstanding the probelem, because if you assume n = 2^a_1 + ... + 2^a_k, natural a_i for all i, don't you just need to show that n+1 is also a sum, i.e. that n+1-n=1 is a sum of powers of 2? it seems trivial as 2^0 = 1, done
14:10:17 <wkh> non-negative a_i, rather, i guess
14:10:36 <yip> how can i check if a list has at least n elements?
14:10:46 <zbrown> wkh: well they're suggesting that i seperate cases of even 'n' and odd 'n'
14:10:48 <hpaste>  sorear annotated "decode base64 strings" with "use induction" at http://hpaste.org/794#a4
14:10:56 <david_> sorear : the type of (=<<) is (=<<) :: (Monad m) => (a -> m b) -> m a -> m b, how does it fit here ?
14:10:56 <shachaf> wkh: Only one occurence of each power of two.
14:11:07 <sorear> david_: [] is a monad.
14:11:14 <hpaste>  augustss annotated "(no title)" with "Working version" at http://hpaste.org/796#a1
14:11:18 <sorear> so let m = [], m a = [a]
14:11:24 * allbery_b used darcs diff to track down his ghci problem (overzealous cleanup merging the proper fix for the OSX bug with the temporary one I'd applied locally and submitted as a patch) and is now building
14:11:29 <augustss> user317: there
14:11:33 <zbrown> wkh: ill type up what ive written on paper and you can be the judge
14:11:42 <shachaf> wkh: "distinct powers of two"
14:11:50 * wkh shrugs
14:11:56 <syntax> wkh: distinct factors, though.
14:12:02 <wkh> yes i see that now
14:12:08 <syntax> wkh: so if you already used up 2^0, you're screwed.
14:12:17 <augustss> yip: depends on if the list can be very long (infinite)
14:12:19 <david_> sorear : yet another thing I learn tonight.... thanks :)
14:12:37 <david_> sorear : what's induction ?
14:12:53 <yip> augustss: it can
14:13:23 <augustss> yip: you can do 'length (take n l) == n', but there are more efficient ways
14:13:29 <sorear> david_: define a function using one case for each constructor, recursing on the unhandeled bit
14:13:40 <Saizan> (not . null) . drop (n-1) ?
14:13:47 <sorear> augustss: not (null (drop n))
14:13:57 <augustss> yes, that's better :)
14:14:09 <yip> augustss: won't that go through the initial sublist twice?
14:14:15 <syntax> > (not . null . drop 9) [1..5]
14:14:16 <lambdabot>  False
14:14:28 <syntax> > (not . null . drop 9) [1..18]
14:14:28 <augustss> mine does, but not the drop one
14:14:29 <lambdabot>  True
14:14:33 <user317> augustss, i want to use the do notation in genRandoms, because at level in the recursin the bounds are different
14:14:50 <augustss> user317: ok, one moment
14:14:50 <sorear> @ty readIntAtBase
14:14:53 <lambdabot> Not in scope: `readIntAtBase'
14:14:58 <paolino> nmessanger, can I use parsec to make readPrec ?
14:15:09 <nominolo> hm, how does one simulate union-types in haskell?
14:15:25 <syntax> Either?
14:15:31 <zbrown> wkh: http://rafb.net/p/kPmVqy65.html
14:15:33 <lambdabot> Title: Nopaste - Strong induction of a proof
14:15:33 <syntax> data Either a b = Left a | Right b
14:15:43 <david_> sorear : can you be more specific ? I'm really a beginner
14:15:43 <nominolo> er ..
14:15:56 <syntax> zbrown: maybe www.mathbin.net was more adequate for that.
14:15:58 <nominolo> d'oh .. hm .. let's see if that's what i need
14:16:04 <hpaste>  augustss annotated "(no title)" with "With do" at http://hpaste.org/796#a2
14:16:14 <zbrown> syntax: maybe, its text though, not much in the way numbers?
14:16:15 <allbery_b> more generally, data T = TA a | TB b | ...
14:16:41 <syntax> Either Int (Either Int (Either Int Int)))
14:16:57 <syntax> make Either a a an instance of functor, etc. etc.
14:17:28 <syntax>  :P
14:17:43 <hpaste>  nmessenger annotated "decode base64 strings" with "moved map chr to top, added inRange" at http://hpaste.org/794#a5
14:18:15 <augustss> paolino: you could use readp.  it's in many ways nicer than parsec
14:18:23 <nominolo> @hpaste
14:18:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:19:16 <hpaste>  nominolo pasted "What to put at ??" at http://hpaste.org/797
14:19:54 <nominolo> any ideas on this one?
14:20:06 <zbrown> wkh: any hints?
14:20:20 <paolino> augustss I cannot parse an unquoted string  with readP
14:20:45 <LoganCapaldo> You can't?
14:20:48 <augustss> paolino: huh? why not?
14:20:49 * LoganCapaldo confused
14:21:01 <nominolo> i.e. I want a lookup function for C that is defined by the instances of A, B, etc
14:21:39 * LoganCapaldo doesn't know how to pick the "right" answer from ReadP's results, so prefers Parsec for his small brain
14:21:57 <LoganCapaldo> But I still think you can parse unqupoted strings
14:22:15 <nominolo> or, how can i enforce that the lookup function is defined for the parts that A, B, .. require
14:22:17 <nominolo> ?
14:22:19 <hpaste>  Korollary annotated "Is this how cabal test works?" with "(no title)" at http://hpaste.org/789#a1
14:22:24 <augustss> LoganCapaldo: they are all right.  it's just that with parsec you only get the first(?) one
14:22:34 <paolino> augustss: ok, then I'm not enough clever for that  :)
14:22:46 <LoganCapaldo> augustss: well at first I thought you got the "last" one
14:22:57 <LoganCapaldo> but that turned out not to be right either
14:23:03 <augustss> LoganCapaldo: I don't think the order is totally deterministic
14:23:06 <LoganCapaldo> where right = what I want
14:23:27 <augustss> LoganCapaldo: then you have an ambiguous grammar
14:23:33 <paolino> lexP should do ?
14:23:47 <augustss> LoganCapaldo: if it's not ambiguous, you only get one result
14:23:51 <hpaste>  nmessenger annotated "(no title)" with "also getOne is rather redundant" at http://hpaste.org/796#a3
14:23:56 <LoganCapaldo> augustss: Yeah
14:24:09 <LoganCapaldo> I'm just not sure what I am doing wrong :)
14:24:18 <LoganCapaldo> and Parsec fufills POLS for me
14:24:38 <augustss> LoganCapaldo: with readp you'd need to use <++
14:24:47 <user317> augustss, thanks a lot for your help, but i am still getting an error: Couldn't match expected type `Int -> State StdGen t'rn           against inferred type `State StdGen a'
14:25:01 <augustss> user317: it compiles for me
14:25:09 <syntax_> I'm curious, what does the lone "data Parts c" mean?
14:25:13 <paolino> augustss: there is no Lexeme for an unquoted string
14:25:36 <nominolo> syntax_: associated types
14:25:48 <augustss> paolino: you just have to consume the characters yourself with readP
14:25:58 <nominolo> @google "assicated types" haskell
14:25:59 <lambdabot> No Result Found.
14:26:26 <hpaste>  sorear annotated "decode base64 strings" with "recursion + fun with elemIndex" at http://hpaste.org/794#a6
14:26:30 <LoganCapaldo> paolino: thats just many (satisfy (not . isSpace)) or whatever the equiv. ReadP is though
14:27:00 <augustss> LoganCapaldo: that's it, i think
14:27:21 <nominolo> syntax_: it basically means that you can specify your own type for this one when you instantiate the class
14:27:30 <paolino> uhm , there are no such functions there
14:27:31 <user317> augustss, thanks you are right, i had a typo.  this is way simpler then what i concocted
14:28:11 <hpaste>  sorear annotated "decode base64 strings" with "inline decode64'" at http://hpaste.org/794#a7
14:28:14 <syntax_> @google "dessecated types" haskell
14:28:15 <lambdabot> No Result Found.
14:28:34 <allbery_b> @go desiccated types
14:28:36 <lambdabot> http://www.springerlink.com/index/P54T104103070631.pdf
14:28:37 <lambdabot> Title: SpringerLink Home - Main
14:28:38 <paolino> ah , there are , sorry
14:29:02 <allbery_b> @go "dessicated types"
14:29:04 <lambdabot> http://www.chowhound.com/topics/341172
14:29:09 * allbery_b should be able to spell, darn it
14:29:15 <allbery_b> @spell desiccated
14:29:16 <lambdabot> desiccated
14:29:17 <nmessenger> fromJust is evil!  at least (\(Just x) -> x) will give you a source location.
14:29:21 <syntax_> Hmmm.
14:29:21 <syntax_> Associated types look interesting.
14:29:21 <syntax_> I've been using fundeps for things like
14:29:26 <allbery_b> @go "desiccated types"
14:29:28 <lambdabot> http://muse.jhu.edu/journals/philosophy_and_literature/v019/19.1br_santayana.html
14:29:28 <lambdabot> Title: George Santayana - Book Review: The Last Puritan: A Memoir in the Form of a Nove ...
14:29:44 <augustss> fromJust is evil, head is evil
14:29:54 <sorear> nmessenger: base64 error is just as usesless as fromJust error.
14:29:55 <LoganCapaldo> nmessenger: that's not fromJust's fault really though is it? (no source loc.)
14:30:05 <sorear> nmessenger, augustss: +RTS -xc is the One True Way
14:30:25 <david_> isn't it long to use elemIndex on a list ?
14:30:41 <augustss> sorear: the One True Way is total functions.  But I'll settle for -xc for now :)
14:31:06 * LoganCapaldo wonders perversely how to write a GHC app with +RTS as a command line option
14:32:03 <nominolo> ok, so no ideas on my problem?  i guess, then it's a case for haskell-cafe
14:32:17 <nmessenger> sorear: I'd rather chunk and map than use the recursion, but elemIndex was a great idea.
14:33:04 <matthew-_> augustss: from that I'd almost expect you to imply non-dependently-typed languages are evil ;-)
14:33:26 <david_> nmessenger, sorear : elemIndex isn't slow on lists ?
14:33:38 <augustss> matthew-_: They are! ;)
14:33:56 <sorear> david_: I'm sorry, I didn't notice when you specified a demand for performance ;)
14:34:20 <matthew-_> mmm. now we just need a reason why dependently-typed languages are also evil, and we're done for the night!
14:34:24 <nmessenger> david_: worry not, grasshopper, for performance.  Wise indeed, The Compiler is.
14:34:42 <syntax_> LoganCapaldo: well, isn't GHC written in GHC, these days? :)
14:34:44 <allbery_b> LoganCapaldo:  --RTS turns off all RTS option processing following it
14:34:49 <allbery_b> so --RTS +RTS
14:35:01 <matthew-_> nmessenger: and when it is not, there are plenty of ways of beating it with a big hammer until it goes fast...
14:35:02 <LoganCapaldo> syntax: touch
14:35:07 * jcreigh wonders perversely how to write a GHC app with --RTS as a command line option
14:35:23 <allbery_b> --RTS --RTS :)
14:35:33 <jcreigh> heh
14:35:39 <david_> sorear : I'm not demanding anything, I'm just trying to get less dumb which is a hard enough task :)
14:35:47 <SamB> the RTS handles +RTS -RTS and --RTS
14:35:53 <SamB> of course
14:36:12 <SamB> the compiler has nothing to do with *that*, really
14:36:21 <SamB> (except it takes them too)
14:36:30 <hpaste>  sorear annotated "decode base64 strings" with "make it faster" at http://hpaste.org/794#a8
14:36:32 <pejo> matthew, isn't the halting problem a good enough reason for the evilness of dependent types?
14:36:50 <SamB> pejo: evilness?
14:36:53 <paolino> thanks LoganCapaldo , got it working
14:37:01 <LoganCapaldo> paolino: No problem
14:37:09 <syntaxfree> yay! new type system extensions!
14:37:09 <syntaxfree> more stuff for me to feel dumb about!
14:37:13 * syntaxfree can't grok existential types yet :(
14:37:13 <Philippa> pejo: nope
14:37:20 * LoganCapaldo does "helped someone in #haskell" for the first time dance
14:37:25 <syntaxfree> http://www.haskell.org/haskellwiki/GHC/Indexed_types
14:37:27 <lambdabot> Title: GHC/Indexed types - HaskellWiki
14:37:30 <matthew-_> pejo: I only know one dependently typed language which suffers from that, Cayenne. Epigram and Omega both only allow recursion on the structure of terms which means the compilation will terminate
14:37:59 <david_> sorear : that last version lost me :) It will take me some minutes to get it.
14:38:32 <sorear> matthew-_: O(ackerman(n)) is still terminating.  Can you write a epigram program whose compilation terminates that slowly?
14:38:42 <nmessenger> david_: it puts the table in an array and uses (Array.!) to lookup
14:38:53 <Philippa> sorear: I believe so
14:38:59 <matthew-_> sorear: I've certainly left Epigram running overnight ;-)
14:39:16 <sorear> what makes nonterminating compiles worse than arbitrarily slow ones?
14:39:36 <david_> nmessenger : it's the way the array is made that makes my neuron burn.
14:39:40 * sorear pragmatically equates "forever" with "until the heat death of the universe"
14:39:55 <david_> notice how I put neuron at the singular :D
14:39:56 <augustss> syntaxfree: give me 10 minutes in front of a whiteboard and you'll grok existential types
14:40:01 <nmessenger> array bounds (zip indeces elemnents)
14:40:05 <SamB> sorear: I'd say that arbitrarily slow ones are worse when you believe that nonterminating ones are possible
14:40:09 <matthew-_> yeah, but you just have this feeling that if you leave it running for 1 more minute it'll termiate
14:40:19 <Philippa> that slips from "fast enough" to "never" are more common than slips from "fast enough" to "hello Ackerman!"
14:40:45 <SamB> (because you'd tend to think you had a nonterminating one)
14:41:16 <matthew-_> mmm. maybe non-terminating is better because if it's still running after a day you might give up and rework the problem from a different angle
14:41:31 <matthew-_> with terminating, you're likely to sit there stubbornly until it terminates
14:41:39 <SamB> hmm.
14:41:45 <augustss> non-termination is detectable :)
14:41:57 <yip> this is what progress bars are for =)
14:41:58 <SamB> well, actually, I'd probably do it anyway in case I was maybe using an exponential algorithm
14:42:13 <matthew-_> augustss: in finite memory, sure. Or more generally?
14:42:23 <SamB> yip: progress bars require analyses of how the algorithm progresses
14:42:31 <augustss> matthew-_: in finite memory.  do you have more than that?
14:42:32 <sorear> maybe epigram should be modified to non-optionally abort compilation after 10 minutes :)
14:42:43 <matthew-_> SamB: not on Windows they don't!
14:42:59 <matthew-_> sorear: I suspect you can do that with alarm
14:43:04 * allbery_b just saw something about how progress bars are evil because they rarely model what actually takes what amount of time
14:43:05 <SamB> matthew-_: now, you could do one of those "still kicking" bars
14:43:07 <matthew-_> augustss: yes, I have 3 times that much! ;-)
14:43:17 <Korollary> progress bars are useless.
14:43:24 <SamB> but of course a nonterminating algorithm could be kicking too
14:43:29 <augustss> matthew-_: then it'll just take slightly longer to detect
14:43:33 <allbery_b> (case in point:  install jdk with documentation on osx :)
14:44:01 <matthew-_> augustss: where "slightly" is some exponential function, I'd guess?
14:44:05 <sorear> @quote matthew-_ <augustss> matthew-_: in finite memory. do you have more than that? <*matthew-_> augustss: yes, I have 3 times that much! ;-)
14:44:05 <sorear>  
14:44:06 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
14:44:13 <sorear> @remember matthew-_ <augustss> matthew-_: in finite memory. do you have more than that? <*matthew-_> augustss: yes, I have 3 times that much! ;-)
14:44:13 <lambdabot> Done.
14:44:14 <augustss> matthew-_: yes
14:44:47 <matthew-_> cheers sorear ;-)
14:45:27 * SamB wonders if Lemmih's GDB is buggy
14:45:52 <augustss> SamB: why would Lemmih's GDB be different than other GDB's?
14:46:24 <Lemmih> SamB: It is.
14:46:36 * augustss has had GDB core dump more than once...
14:46:47 <Lemmih> Oh wait, GDB?
14:47:27 <chr1s__> is there some kind of priority queue in haskell?
14:47:30 <tiglionabbit> ?src liftM
14:47:30 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:47:32 <narain> have any games been written using haskell
14:47:33 <narain> ?
14:47:51 <chr1s__> narain: there is a FPS written using haskell
14:47:51 <augustss> narain: yes
14:48:04 <matthew-_> narain: I'm working on one right now
14:48:16 <chr1s__> narain: http://haskell.org/haskellwiki/Frag
14:48:17 <lambdabot> Title: Frag - HaskellWiki
14:48:22 * sorear finds it interesting the way people equate "games" with "fps"
14:48:25 <siti> matthew-_: what type of game is it?
14:48:27 <narain> cool
14:48:30 <nmessenger> @wiki Games
14:48:31 <lambdabot> http://www.haskell.org/haskellwiki/Games
14:48:32 <matthew-_> siti: tron clone
14:48:37 <siti> sweet :)
14:48:40 <david_> sorear: I don't understand why the bounds are ('+','z')
14:48:45 <matthew-_> siti: with deforming spring-mesh board.
14:48:46 <SamB> Lemmih: what, is your GCC buggy too?
14:48:46 <tiglionabbit> :t liftM
14:48:49 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:48:53 <siti> ok
14:49:02 <tiglionabbit> ...
14:49:06 <siti> using open GL I presume...?
14:49:10 <matthew-_> yep
14:49:22 <tiglionabbit> I don't understand this liftM
14:49:38 <narain> matthew-_: sounds cool
14:49:42 <mauke> tiglionabbit: why not?
14:49:55 <matthew-_> narain: cheers, it will be released at some point, once we have a game!
14:49:55 <augustss> :t liftM
14:49:58 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:50:20 * matthew-_ celebrates ghc 6.7 compilation stopping. without error.
14:50:27 <SamB> augustss: are you arguing that yes, Lemmih's GDB is buggy, or no, it is not buggy?
14:50:29 <augustss> tiglionabbit: the type says it all
14:50:34 <tiglionabbit> ...
14:50:45 <augustss> SamB: i'm arguing that every GDB is buggy
14:50:50 <SamB> good
14:50:51 <SamB> ;-)
14:50:59 * Lemmih is lost.
14:51:02 <narain> matthew-_: good luck, what's the status?
14:51:04 <tiglionabbit> it takes a function and a monad, does the monad, then returns a function of the function?
14:51:10 <tiglionabbit> or a monad...
14:51:12 <tiglionabbit> eep
14:51:29 <mauke> tiglionabbit: it applies a function to the value in the monad
14:51:34 <chr1s__> (sorry to ask again): is there a standard priority queue available for haskell?
14:51:37 <mauke> i.e. map
14:51:42 <tiglionabbit> mauke: it does that where?
14:51:55 <mauke> what do you mean by "where"?
14:51:57 <sorear> david_: why not?
14:52:00 <tiglionabbit> oh whoops, that's a <-, not a ->
14:52:00 <matthew-_> narain: um, well there's quite a lot in place in terms of the main game model, but multiplayer and all the bits actually needed to make it a game are missing
14:52:03 <SamB> Lemmih: I have a JIT that I am trying to debug. I'm writing it in C++. (I'm using catenova because I don't think I have enough room to build LLVM myself, and also because LLVM takes a horrendous amount of time to link.)
14:52:05 <tiglionabbit> sorry
14:52:21 <mauke> > liftM (+ 2) [1,2,3]
14:52:22 <lambdabot>  [3,4,5]
14:52:43 <augustss> chr1s__: I don't think there's a PQ included in the libraries that come with ghc
14:52:54 <Lemmih> SamB: You're using catenova?
14:53:12 <narain> matthew-_: i'm slowly writing a breakout clone
14:53:14 <narain> with physics
14:53:19 <chr1s__> augustss: do you know of any good implementations?
14:53:21 <SamB> Lemmih: isn't that yours?
14:53:23 <sorear> chr1s__: you can fake one using Data.Map.findMin - asyptotically optimal, but bad constant factor
14:53:38 <tiglionabbit> what's the equivalent to (a . b) without using a .?
14:53:46 <sorear> (.) a b :p
14:53:53 <SamB> @unpl (a . b)
14:53:53 <lambdabot> (\ e -> a (b e))
14:53:55 <sorear> \x -> a (b x)
14:53:56 <chr1s__> sorear: ok, thanks
14:54:15 <tiglionabbit> ah
14:54:16 <Lemmih> SamB: It is but I have no idea what you're doing.
14:54:22 <mauke> tiglionabbit: liftM a b
14:54:23 <mauke> :-)
14:54:27 <david_> sorear : I've tried reading the doc about array and my first reaction was to think the bounds were ('A','/') but it's obvious that I totally don't understand what are the bounds.
14:54:28 <tiglionabbit> lol
14:54:31 <SamB> Lemmih: yeah.
14:54:44 <siti> matthew-_: I am making a game of draughts (checkers), it needs about 2 more weeks but it's quite playable atm :)
14:54:55 <augustss> > liftM (+1) (*2) 10
14:54:56 <lambdabot>  21
14:55:08 <SamB> oh, actually GDB isn't being buggy
14:55:08 <nominolo> heh, and it happened again -- i start writing a problem to haskell-cafe, and while i write it i solve it myself ...
14:55:11 <matthew-_> narain: that's a nice idea. I find the physics quite hard to make go fast.
14:55:23 <SamB> my program segfaulted :-(
14:55:30 <matthew-_> siti: cool. I guess that sits quite nicely in haskell
14:55:31 <SamB> so there really *IS* no process
14:55:41 <dibblego> does anyone recall a recent publication from Oleg about proposed array syntax for Haskell?
14:55:51 <yip> narain: what's your overall application architecture?
14:56:01 <augustss> dibblego: syntax?
14:56:08 <siti> matthew-_: yeah, the backend can be done very easily in haskell compared to other languages :)
14:56:08 <dibblego> was it syntax or something else?
14:56:15 <hpaste>  sorear annotated "decode base64 strings" with "another approach" at http://hpaste.org/794#a9
14:56:21 <dibblego> something to do with arrays (very vague in my head)
14:56:36 <david_> sorear : I've also tried with (0,63)....
14:56:45 <narain> yip: very little at this point :)
14:56:54 <sorear> david_: the bounds can't be ('A','/') because:
14:57:00 <sorear> > '+' < 'A'
14:57:01 <lambdabot>  True
14:57:09 <yip> narain: ok, but what graphics library are you using?
14:57:36 <sorear> > sort (['A'..'Z'] ++ ['0'..'9'] ++ ['a'..'z'] ++ "+/")
14:57:37 <lambdabot>  "+/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
14:57:40 <narain> yip: hopengl
14:57:45 <matthew-_> well whatever you gurus have done to ghc6.7, I thank you. I have about a 10% performance improvement on x86
14:58:02 <narain> it seems to have outdated docs, but i'm making do as i can
14:58:14 <yip> narain: nice, what about input, hsSDL?
14:58:18 <dons> matthew-_: that's about right.
14:58:24 <dons> i see similar numbers on amd64 too
14:58:34 <david_> sorear : got it. question follows : why do array need such bounds then ? ( I think I know the reply : to know how many "cells" there will be in the array ? )
14:58:40 <hpaste>  nmessenger annotated "decode base64 strings" with "MUST MAKE MORE PASTES!!" at http://hpaste.org/794#a10
14:58:48 <sorear> dons: I had to restore @where nobench-results
14:58:53 <narain> yip: oops, i haven't thought about that at all
14:58:54 <sorear> david_: exactly.
14:59:05 <narain> yip: i usually use glut when using C
14:59:07 <yip> narain: well what are you already using to create the window, glut?
14:59:25 <yip> narain: ah. ok. the glut haskell bindings seem to be ok. i personally prefer SDL, but i guess it doesn't really matter
14:59:42 <narain> yip: oh wait, am i using glut? i *am* opening a window
15:00:03 <narain> yip: i guess i must have been using glut and forgot about it
15:00:41 <narain> yip: i'm pretty comfortable with glut so i'm going to stick with that
15:00:42 <yip> :) if only hopengl would get support for opengl 2.0 already :|
15:00:50 <siti> yeah
15:00:56 <SamB> Lemmih: I think my debug build of LLVM just doesn't work
15:01:38 <matthew-_> narain: there's the gtk2hs stuff and there seems to be an opengl canvas in there. I've not used it myself though
15:01:57 <Lemmih> SamB: How's LLVM related to catenova?
15:02:20 <SamB> Lemmih: oh, I'm just using the machine.
15:02:41 <matthew-_> dons: morning. how long do you expect until 6.8 is released - is there a plan of what's more to go in?
15:02:43 <Lemmih> Ah! You're using the catenova server, not the catenova source.
15:02:54 <narain> matthew-_: i've never used opengl canvases
15:03:08 <SamB> yes!
15:03:11 <yip> gtk2hs is great if you need some kind of 3d editor, but for a game it might be overkill
15:03:14 <dons> i think towards the end of the year?
15:03:23 <dons> just speculating. the parallel GC has to go in.
15:03:33 <narain> yip: what's new in opengl 2.0? just GLSL?
15:03:34 <dons> stream fusible bytestrings and lists
15:03:44 * sorear goes back to his super-powerful command line lib
15:04:54 <yip> narain: compared to 1.4? GLSL and shaders are the big thing. VBO is another big thing. also some render-to-texture stuff and 3d texture features
15:05:53 <Saizan> btw, can HOpengl be used to make a video from a sequence of images?
15:06:16 <narain> Saizan: you can display a sequence of images to look like a video
15:06:25 <narain> using hopengl
15:06:28 <sjanssen> dons: you think 6.8 will come out so soon?
15:06:33 <narain> but to write out a video you'll need something else
15:06:34 <dons> probably not.
15:06:40 <dons> ?users
15:06:41 <lambdabot> Maximum users seen in #haskell: 336, currently: 317 (94.3%), active: 53 (16.7%)
15:07:02 <Saizan> narain: with a reasonably short refresh rate?
15:07:17 <sjanssen> I'd like to see IO encoding to be fixed for 6.8
15:07:19 <narain> yip: do you know if current hopengl docs are available anywhere?
15:07:28 <narain> Saizan: sure
15:07:42 <narain> unless your image reading library is the bottleneck
15:08:00 <Saizan> ah, it doesn't do it?
15:08:02 <matthew-_> Saizan: I capture screen with xvidcap and then use mencoder
15:08:15 <yip> narain: http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL.html
15:08:17 <lambdabot> http://tinyurl.com/2ddovl
15:08:45 <yip> Saizan: opengl has no file i/o whatsoever
15:08:49 <narain> yip: thanks!
15:08:49 <sorear> sjanssen: oh? someone AGREES with me?
15:09:31 <narain> yip: my god all the nested modules :O
15:09:57 <sjanssen> sorear: I'm sure plenty of people want to see this issue fixed
15:10:08 <sjanssen> it is a bit tricky though . . .
15:10:48 <sorear> sjanssen: just utf8-encode all the Char apis and leave the Word8 apis alone
15:10:48 <sjanssen> depending on how it is implemented, tons of legacy programs that assume Char == Word8 will break
15:10:58 <sjanssen> sorear: utf8 is insufficient
15:11:15 <sorear> how!?
15:11:29 <sjanssen> well, UTF-8 would sure be a nice step
15:11:29 * sorear wants to see all coding systems but one ABOLISHED
15:11:43 <SamB> I thought the problem was that we didn't have any Char APIs
15:11:49 <SamB> er.
15:11:52 <SamB> s/Char/Word8/
15:11:54 <sjanssen> by why add one encoding, but none of the others?
15:12:00 <sjanssen> s/by/but
15:12:00 <sorear> SamB: hPutBuf
15:12:08 <sorear> sjanssen: see "plan 9"
15:12:21 <sorear> sjanssen: EVERYTHING is utf8 there.  other codings don't exist.
15:12:22 <sjanssen> sorear: hPutBuf wasn't invented until somewhat recently
15:12:38 <sjanssen> sorear: and are you running plan9 right now?
15:12:51 <sorear> no, only heard rumors.
15:12:51 <narain> sorear: that's not fair, they invented utf8, of course they'll use it
15:13:13 <sorear> but I thought the point of haskell was that it didn't have a history to drag behind it
15:13:15 <monochrom> plan9 and haskell point out the future
15:13:17 <sorear> C is too old to fix
15:13:26 <monochrom> of course both are unused "now"
15:13:34 <sjanssen> sorear: UTF-16 is being used now
15:13:39 <sjanssen> it isn't a legacy issue
15:14:12 <matthew-_> lots of systems use dcs internally rather than utf8
15:14:18 <matthew-_> 'tis much simpler
15:15:00 <siti> does java use utf16?
15:15:10 <sjanssen> matthew-_: dcs?
15:15:23 <sorear> siti: no
15:15:28 <sorear> siti: java uses Unicode
15:15:31 <siti> ok
15:15:42 <matthew-_> sjanssen: I may have got the name wrong. was just trying to google... double byte - 2 bytes per char
15:15:43 <sorear> siti: java chars are characters, not sequences of bytes
15:15:45 <sjanssen> sorear: Java uses UTF-16
15:15:58 <sorear> sjanssen: Sun JVM /= Java ?
15:16:11 <sorear> sjanssen: that's an implementation issue, right?
15:16:22 <matthew-_> don't get confused. utf-8, utf-9, utf-16, whatever are all just encodings of unicode charpoints
15:16:26 <sjanssen> matthew-_: UCS-2 (which is deprecated because it can't represent the entire Unicode character set)
15:16:38 <sjanssen> sorear: no, I think it is part of the Java spec
15:17:02 <Korollary> Does the spec spell out utf16(le/be) specifically or does it allow any encoding?
15:17:04 <sorear> sjanssen: what java spec?  I know the classfile spec uses a slightly modified UTF-8
15:17:13 <yip> matthew-_: how many total characters are there in unicode(including all future characters), 2^32?
15:17:19 <matthew-_> sjanssen: that's the one! ahh. how things change.
15:17:20 <sorear> 1114111 iirc
15:17:53 <matthew-_> mmm. that'll be why ucs-2 is deprecated then. My obviously out of date info is taken from http://www.joelonsoftware.com/articles/Unicode.html
15:17:54 <Korollary> I think unicode doesn't have a max iirc.
15:17:54 <lambdabot> Title: The Absolute Minimum Every Software Developer Absolutely, Positively Must Know A ...
15:17:55 <sorear> yip: the unicode consortium has promised never to use characters higher than about a milion
15:18:14 <siti> http://java.sun.com/javase/technologies/core/basic/intl/faq.jsp#text-representation
15:18:16 <lambdabot> http://tinyurl.com/2oezsz
15:18:58 <yip> sorear: that's it? you're sure?
15:19:17 <SamB> Lemmih: it turned out that I wasn't linking with enough libraries...
15:19:23 <SamB> llvm is a bit crazy...
15:19:31 <nmessenger> > 0x10FFFF
15:19:33 <lambdabot>  1114111
15:19:47 <resiak> sjanssen: can't all chars be represented in UCS-16 via surrogate pairs?
15:19:47 <monochrom> I trust that everyone participating in this thread knows that "how characters are stored inside" and "how characters are communicated outside" are decoupled from each other.
15:20:02 <mbishop> > 0xFFFF
15:20:04 <lambdabot>  65535
15:20:14 <sjanssen> resiak: yes, but UCS-2 doesn't have surrogat pairs
15:20:21 <nmessenger> > maxBound :: Char
15:20:22 <lambdabot>  '\1114111'
15:20:52 <sjanssen> sorear: from String's javadoc: "A String represents a string in the UTF-16 format  in which supplementary characters are represented by surrogate  pairs (see the section Unicode  Character Representations in the Character class for  more information).  Index values refer to char code units, so a supplementary  character uses two positions in a String."
15:21:30 <sorear> monochrom: how charactes are stored inside is completely irrelevant.  this thread is about fixing the IO encoding, which idiotically uses ISO-8859-1 without overflow checks.  satisfied I know?
15:21:44 <monochrom> Yes.
15:21:53 <sjanssen> sorear: so an implementation is practically tied to using UTF-16 for String
15:22:26 <fantasma> how is nforce 680 support in linux?
15:23:03 <matthew-_> right. I'm off to bed. nn #haskell
15:23:28 <nmessenger> 'night
15:23:36 <sjanssen> sorear: and many other platforms use UTF-16.  Qt and OS X prefer UTF-16 strings
15:23:36 <resiak> sjanssen: oh, of course, UCS-2 /= UTF-16
15:23:46 <narain> matthew-_: g'night
15:24:24 * sorear would also like to see the world standardize on a single language and alphabet.
15:24:35 <Saizan> what's the benefit of utf-16?
15:24:38 <dufflebunk> sorear: isn't that UTF-32 ? ;)
15:24:39 <siti> sorear: most people are to lazy :p
15:24:44 <nmessenger> nuspeek for everywun!
15:24:46 * sorear thinks this is about as likely as fixing the encoding mess.
15:24:50 * monochrom would like to see all informal ambiguous languages abandoned.
15:25:01 <narain> lojban ftw?
15:25:06 <Korollary> I think windows uses utf16 strings (maybe ucs-2?)
15:25:32 * monochrom would like to see the simply-typed lambda calculus as the standard language among humans.
15:25:36 <sjanssen> Korollary: I think it's UTF-16 with some legacy bits that are still UCS-2
15:25:45 <siti> hah, you are crazy monochrom :p
15:26:00 <chr1s__> monochrom: a map and fold would be even handier for humans
15:26:02 <Korollary> XML for human standard language!
15:26:11 * nmessenger is horrified
15:26:14 <Korollary> we'll be a lot chattier
15:26:23 <chr1s__> map who_wants_to_have_dinner friends
15:26:31 <nmessenger> True!
15:26:37 <monochrom> Oleg would be much happier :)
15:27:22 <narain> > all (map mortal men)
15:27:23 <lambdabot>   Not in scope: `men'
15:27:36 <fantasma> > dropWhile (love < 0) humanity
15:27:37 <lambdabot>   Not in scope: `humanity'
15:27:44 <nmessenger> > all mortal men -- type error
15:27:45 <lambdabot>   Not in scope: `men'
15:28:08 <narain> fantasma: that won't drop all
15:28:15 <nmessenger> filter!
15:28:20 <narain> yes
15:28:38 <nmessenger> filter ((<0) . love) humanity
15:28:46 <fantasma> filter (love > 1) humanity
15:28:55 <chr1s__> I like this one better:
15:29:03 <chr1s__> filter ((<3) . love) humanity
15:29:03 <narain> let love = (<3)
15:29:10 <fantasma> haha
15:29:10 <nmessenger> <3
15:29:12 <chr1s__> hehe
15:29:45 <nmessenger> map hug (filter ((<3) . love) humanity)
15:29:57 <narain> > let love = (<3) in map love [0,1,2] -- proof by incomplete induction
15:29:59 <lambdabot>  [True,True,True]
15:30:45 <nmessenger> map hug #haskell
15:31:03 <monochrom> Ideally I would like to see getChar and putChar use utf-8.
15:31:13 <triplah_w> dons: you about?
15:31:46 <fantasma> head (filter (love > 10000) humanity)
15:31:47 <twanvl> Ideally, a Handle would know what encoding to use.
15:31:53 <yip> monochrom: this would mean that the getChar would eat up an unpredicatble amount of bytes
15:32:07 <SamB> yip: not really
15:32:14 <monochrom> Pragmatically I would like to see getChar and putChar look at a certain new global variable to find out which encoding to use.  The variable is runtime changeable.  A lot of encodings are supported.
15:32:21 <triplah_w> actually, i guess anyone can answer this
15:32:22 <yip> i've been using UTF8.lhs with great success... i don't really see what the problem is :|
15:32:41 <triplah_w> are there many scientific libs for hs? like matrix operations, svd etc?
15:32:46 <narain> @src liftM2
15:32:46 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:33:05 <dons> triplah_w: yeah?
15:33:08 <Saizan> global and runtime changeable is evil, what if half of your program is using a different encoding?
15:33:16 <sjanssen> monochrom: I'd prefer that encoding is a property of the handle
15:33:25 <monochrom> All good ideas.
15:34:03 <triplah_w> dons: our convo yesterday has got me thinking, paricularly the concurrent fib you did. are there and sci* libs for hs? like matrix stuff?
15:34:12 <triplah_w> particularly*
15:34:14 <triplah_w> any*
15:34:15 <triplah_w> sigh :(
15:34:23 <triplah_w> i should be awake by now
15:34:41 <monochrom> I am influenced by Java on this.  There is a global encoding, and there are also per-stream encodings.
15:35:25 <monochrom> I am also fine with omitting the global encoding.
15:35:25 <sjanssen> monochrom: what does the global encoding do?
15:35:46 <monochrom> It serves as the default for stdin/out and all new streams.
15:36:11 <Zeroth404> YAHY is less than 200 pages.... is it a *complete* tutorial?
15:36:12 <sjanssen> yeah, I support something like that
15:36:22 <dons> there's some things, the new parallel arrays lib for example.
15:36:35 <dons> there's some matrix stuff out there, but i've not looked at it very hard
15:36:37 <monochrom> I personally don't like global variables either.  I'm just thinking some newbies like it.
15:36:42 <Shurique> hi, I've just started learning haskell and I'm doing the classic "greet" program that reads a name from stdin (main = do putStr "Name? "; name <- getLine; greet name), but the "Name? " string isn't output before I type in something and press return. Why might this be?
15:36:53 <twanvl> What would make even more sense is if there were two Handle types, one for binary io, and a CharHandle = (Handle, Encoding) for character io
15:36:56 <Zeroth404> monochrom: global vars isn't about liking, its about using appropriately
15:36:57 <narain> Shurique: try putStrLn
15:37:14 <triplah_w> dons: ok, thanks
15:37:23 <dons> Shurique: line buffering is getting in the way. try putstrLn or hSetBuffering stdout NoBuffering
15:37:27 <Shurique> narain: I did, and that seemed to work, but I'd rather use putStr if possible
15:37:33 <dons> ?docs System.IO
15:37:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
15:37:40 <yip> twanvl: no, you might want to change the state of a handle after it's created to binary/char
15:37:43 <dons> Shurique: look up hSetBuffering ^^
15:37:50 <Shurique> dons: okay, thanks
15:37:54 <narain> dons: is there a flush operation?
15:37:55 <nmessenger> would hFlush stdout also help?
15:38:06 <dons> or hFlush stdout explicitly
15:38:16 <twanvl> yip: You mean you want to combine binary and char io, why?
15:38:33 <yip> twanvl: webserver that sends http headers and then a binary image
15:39:44 <narain> how come the standard greet program works in other languages without explicit flushing?
15:40:00 <twanvl> If CharHandle is a wrapper around Handle you could switch, you could even switch to a different encoding
15:40:16 <sjanssen> narain: some languages send a flush to stdout everytime you read from stdin
15:40:29 <allbery_b> narain: C's stdio, which is the basis for most other languages' stdio, has an evil hack added some 15 years ago to autoflush stdout befre reading from stdin
15:40:29 <monochrom> standard greet program = hello world?
15:40:55 <yip> twanvl: i suppose
15:40:56 <narain> sjanssen,allbery_b: i see. what's evil about that?
15:41:08 <yip> > "Hello, World!"
15:41:10 <lambdabot>  "Hello, World!"
15:41:25 <narain> monochrom: what Shurique posted above
15:41:29 <monochrom> C++ calls it "tying", "tie".  I am somewhat against it.
15:41:32 <allbery_b> arguably there is no guarantee that stdout s related to stdin
15:41:34 <fantasma> > maximum "Hello World"
15:41:35 <lambdabot>  'r'
15:41:37 <dcoutts> psnl, for underlining in a TextBuffer you have to apply a TextTag to a span of text. You create the TextTag and play with its properties to set things like underlining.
15:42:01 <fantasma> > chr 98
15:42:03 <lambdabot>  'b'
15:42:17 <allbery_b> normally they are, but there are exceptions and the autoflush behavior, while it probably won';t break anything, may not flush the *real* output channel if the program has redirected stuff
15:42:24 <monochrom> I claim that tying is ever only useful for newbies writing toy programs.
15:42:25 <fantasma> > map chr [97..150]
15:42:26 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
15:42:58 <psnl> dcoutts: yeah, I'm slowly figuring it out.
15:43:48 <dcoutts> psnl, you could look at the hIDE code that does the Haskell syntax highlighting and squiggly underlining.
15:44:19 <psnl> dcoutts: did that, and it helped
15:44:28 <dcoutts> good good
15:45:24 <nominolo> there is hIDE code?
15:45:46 <syntaxfree> this is it. I have to learn type theory.
15:45:48 <psnl> dcoutts: I'm also looking at all sorts of other gtk tutorials, which is helping.
15:46:08 <yip> psnl: what project are you working on?
15:46:30 <nominolo> syntaxfree: start with TAPL
15:46:34 <nominolo> @where TAPL
15:46:34 <lambdabot> http://tinyurl.com/282m6x
15:46:45 <syntaxfree> TAPL?
15:46:55 <nominolo> types and programming languages
15:47:02 <nominolo> by benjamin pierce
15:47:07 * yip has been trying to get past page 1 in that book for 2 years now
15:47:11 <psnl> yip: right now, its a mess. ideally I'ld like to be a nice source viewer for haskell, with some sort of context aware right click menu.
15:47:28 <yip> psnl: cool, why not directly continue hIDE?
15:47:51 * QtPlatypus just started writing in Haskell this weekend and is already liking it alot.  Esp type inference.
15:48:09 <psnl> couple of reasons, but hIDE is bit big for what I want to do
15:48:35 <nominolo> QtPlatypus: you'll soon long for dependent types ;)
15:48:57 <nominolo> (well, not really, depends on what you want to do)
15:49:50 <ndm> nominolo: if you like type inference, you'll hate dependent types!
15:50:11 <nominolo> yup, true
15:50:29 * psnl is simply gobsmacked at how cool the ghc developers are
15:50:42 <ndm> psnl: what in particular?
15:50:58 <dons> QtPlatypus: great! welcome!
15:51:14 <syntaxfree> pet peeve: people who use "isomorphism" for "it's somewhat like".
15:51:16 * nominolo met simonpj in person, must agree, still wonders with ndm
15:51:40 <psnl> ndm: not merely do they provide their parser as a nice little library, the result of the parse has line and column numbers in it.
15:51:56 <ndm> psnl: even Yhc does that ;)
15:51:57 <syntaxfree> cookies are isomorphic to little cakes. grrrr.
15:52:06 <ndm> psnl: well actually nhc
15:52:16 <psnl> this may seem like nothing, but I have had a day of everything not being easy
15:53:19 <nominolo> psnl: well, yes, lot's of things in the haskell world are surprisingly well-designed
15:53:47 <nominolo> (maybe that's also due to restrictions the language gives you)
15:54:01 <narain> syntaxfree: :)
15:54:03 * ndm thinks nominolo hasn't looked through enough code, i recommend Yhc's type checker for an example of some horrible Haskell c ode
15:55:03 <narain> syntaxfree: is it possible to use the word "isomorphism" without knowing category theory?
15:55:06 * nominolo is pretty sure there was no "forall haskell-code . " quantifier in his previous statement ;)
15:55:22 <nmessenger> I read a blog post about some guy brought into a project, the guy before didn't want to fill his code with "impure" Monads, so he used TVars for everything :O
15:55:23 <monochrom> Yes, it is possible, narain.
15:55:26 <nominolo> i know it from algebra
15:55:33 <narain> i ask because i don't know category theory but i'd like to say "isomorphism"
15:55:48 <dons> nominolo: also, a lot of things were designed by academmics writing papers, which means you aren't so much under time pressure to get things done, and more able to make it beautiful
15:56:14 <monochrom> Already with linear algebra you already have to say "these two vector spaces are isomorphic".
15:56:24 <nominolo> dons: heh, true.  i am currently working on an project of the exact opposite kind
15:56:26 <QtPlatypus> On that note is there a recomened haskell mode for emacs?
15:56:40 <nominolo> QtPlatypus: there's only one
15:56:45 <dons> QtPlatypus: yeah, its called 'haskell-mode'
15:56:46 <narain> monochrom: i've never said that
15:56:52 <narain> do you mean that they have the same dimension?
15:56:53 <dons> i'm not sure if it comes with emacs std distributions?
15:57:17 * QtPlatypus nods "Ok thats the one I have"
15:57:18 <monochrom> Yes.
15:57:25 <allbery_b> a very old version comes with emacs
15:57:36 <allbery_b> @where haskell-mode
15:57:36 <monochrom> No.
15:57:37 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
15:57:37 <nominolo> dons: everything lives in the IO monad--it's a hell to clean up.  and i'm kind of under time-pressure
15:57:47 <dons> fair eough. then you just hack!
15:58:19 <ndm> dons: academics often produce nice theory results but no tools/ipmlementations - the GHC developers are an exception
15:58:20 <narain> monochrom: "yes" or "no"?
15:58:31 <nominolo> yep, all day :)
15:58:54 <monochrom> C^2 and R^2 both have dimension 2, but they aren't isomorphic.
15:59:02 <narain> oh
15:59:09 <dons> why reddit is nice:  haskell seems to me to make both scheme and lisp in general rather obsolete.
15:59:24 <syntaxfree> hmm. how quaint.
15:59:25 * narain only groks finite-dimensional real vector spaces
15:59:28 <dons> ndm,as you know, there's a few out there who write code too ;)
15:59:42 <syntaxfree> APL and J have only second-order functions.
16:05:22 <syntaxfree> there are verbs, which are functions over values, and adverbs, which are combinators over functions.
16:05:22 <syntaxfree> no adadverbs, though.
16:05:22 <nmessenger> syntaxfree: bizzare.
16:05:22 <ndm> dons: i do know, and i do try to join you ;)
16:05:22 <nominolo> J = crazy
16:05:22 <monochrom> Yes, if you put in more restrictions, you can ensure isomorphic=same-dimension.  But that's cheating. :)
16:05:22 <narain> syntaxfree: the terminology's cute
16:05:22 <syntaxfree> so, um, they do sum = (reduction addition) and maximum = (reduction ceiling)
16:05:22 <nominolo> but perl6 is better, it has way more weird operators
16:05:22 <syntaxfree> but no composition.
16:05:22 <syntaxfree> or anything else really.
16:05:22 <triplah_w> apart from vim and emacs, are there any other cool editors for hs? i always used vim
16:05:22 <triplah_w> ones that use ghc
16:05:22 <nmessenger> reduction = foldl/r1?
16:05:22 <triplah_w> so no hugs
16:05:22 <mux> @where yi
16:05:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
16:05:22 <triplah_w> ah yi
16:05:22 <narain> syntaxfree: wait a minute, reduction isn't an adverb!
16:05:22 <syntaxfree> yes, it is.
16:05:22 <narain> "reducedly"?
16:05:22 <syntaxfree> ah, yes, yes.
16:05:22 <narain> in english, i mean.
16:05:22 <syntaxfree> you're right :)
16:05:22 <nmessenger> "elementwise"?
16:05:22 <narain> > let reducedly = foldr; add = (+) in reducedly add [1,2,3]
16:05:22 <lambdabot>   add an instance declaration for (Num [t])
16:05:22 <lambdabot>     In the expression: (+)
16:05:22 <lambdabot>     In...
16:05:22 <narain> > let reducedly = foldr; add = (+) in reducedly add [1,2,3] :: Int
16:05:22 <lambdabot>  Couldn't match expected type `Int'
16:05:22 <nmessenger> foldr1
16:05:22 <narain> oh
16:05:22 <narain> > let reducedly = foldr1; add = (+) in reducedly add [1,2,3] :: Int
16:05:22 <lambdabot>  6
16:05:22 <narain> heh, i like how it reads
16:05:22 * nmessenger votes for all order-2 functions to be renamed to adverbial forms!
16:05:22 <narain> mappedly
16:05:22 * narain seconds the motion
16:05:33 <nmessenger> all opposed?
16:05:45 <LoganCapaldo> > let byReducing f xs = foldr1 f xs; add = (+) in add `byReducing` [1,2,3]
16:05:46 <lambdabot>  6
16:06:18 <LoganCapaldo> I love Haskell
16:06:32 <monochrom> reluctantly = unsafeInterleaveIO
16:06:40 <nmessenger> lol!
16:06:45 <LoganCapaldo> Although I'm pretty sure mine is grammatically incorrect :)
16:07:48 <kc5tja> LoganCapaldo: I like Haskell too, when it works for me.  :)
16:08:03 <narain> > let repeatedly = unfoldr in repeatedly (\x -> Just (x, x)) 1
16:08:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:08:31 <monochrom> concurrently = forkIO
16:08:45 <nmessenger> (\x -> Just (x,x)) = Just . join (,)
16:08:54 <monochrom> Example.  concurrently (reluctantly (atomically (... some stm code here ...)))
16:09:05 <ndm> evily = unsafeCoerce
16:09:20 <monochrom> The brilliant part is that "atomically" is already available!
16:09:21 <kc5tja> Is there a connivingly?  :)
16:09:35 <LoganCapaldo> par = concurrentlyWith , eg: f  `concurrentlyWith` g
16:09:36 <LoganCapaldo> \
16:09:39 <LoganCapaldo> eek
16:09:50 <LoganCapaldo> Sorry, I dropped a backslash
16:10:17 <monochrom> I'm thinking of a name for unsafePerformIO
16:10:32 <kc5tja> forcefully?
16:10:40 <LoganCapaldo> dangerously ?
16:10:41 <syntaxfree> evilly.
16:10:48 <syntaxfree> rapingly.
16:10:53 <syntaxfree> soul-sellingly.
16:10:57 <narain> egads
16:10:57 <kc5tja> carelessly
16:11:03 <ndm> pragmatically
16:11:12 <LoganCapaldo> breakingOutOfJailLikely
16:11:14 <kc5tja> embarrassingly
16:11:30 <nmessenger> sillily!
16:11:34 <psnl> failToPerformIO
16:11:43 * beelsebob points at the channel and giggles
16:12:11 <LoganCapaldo> sideeffectingly
16:12:12 <kc5tja> ashamedly
16:12:25 <narain> stubbornly
16:12:30 <rahikkala> n_times
16:12:37 <Botje> eatBabiesAnd ..
16:12:38 <LoganCapaldo> impurely
16:12:42 <monochrom> backhandedly
16:12:54 <kc5tja> Monads should go through a nomenclature change too.  The IO Monad, for example, should be renamed to Sideeffectification.
16:13:14 <LoganCapaldo> referentiallyuntransparent
16:13:18 <nmessenger> no!  WorldT
16:13:26 <narain> wait, first we have to decide what part of speech monads should be assigned
16:13:33 <nmessenger> LoganCapaldo: -ly :)
16:13:39 <Botje> the verbal kind.
16:13:44 <LoganCapaldo> there was an ly in there
16:13:51 <LoganCapaldo> it was just in the middle :)
16:13:52 <dpiponi> I tried to build haddock using source downloaded with darcs and got "Setup.lhs: src/HaddockLex.x: no alex preprocessor available". What's 'alex' and where do I get it?
16:13:57 <nrb23> anyone care to help me with Cabal?
16:14:06 <LoganCapaldo> Ooo!
16:14:12 <kc5tja> LoganCapaldo: But that doesn't count; the -ly as to be at the end to form an adverb.
16:14:13 <psnl> dpiponi: www.haskell.org/alex
16:14:17 <rahikkala> @karma+ @karma
16:14:17 <lambdabot>  @karma's karma raised to 2.
16:14:18 <LoganCapaldo> magically = unsafePerformIO
16:14:35 <mux> is it possible to get a call stack for when some code dies with an exception?
16:14:38 <monochrom> magically is quite good
16:14:39 <kc5tja> OK, magically trumps all.
16:14:57 <narain> types are common nouns, so type classes should be adjectives?
16:15:00 <psnl> mux: with hat, yes. otherwise no.
16:15:09 <rahikkala> @karma unsafePerformIO
16:15:09 <lambdabot> unsafePerformIO has a karma of 0
16:15:10 <mux> @where hat
16:15:11 <lambdabot> http://www.haskell.org/hat/
16:15:17 <tiglionabbit> can I use generic data constructors in a pattern?
16:15:26 <narain> [a] = Several a
16:15:34 <nmessenger> narain: Bounded, Ord(ered), etc.
16:15:46 <dpiponi> OK. Getting alex gives "darcs failed:  Error applying hunk to file ./examples/makefile".
16:15:46 <narain> nmessenger: aha!
16:15:47 <nmessenger> Num(eric)
16:16:10 <nmessenger> Integral, Real
16:16:17 <narain> wait, i was thinking of parametrized types instead
16:16:20 <tiglionabbit> I mean, can I say something like:  sameContainer = one@(A _) two@(A _) = True ?
16:16:30 <psnl> dpiponi: what are you building on?
16:16:30 <tiglionabbit> oops
16:16:34 <tiglionabbit> get rid of the first = there
16:16:36 <narain> anyway, joke's over i guess
16:16:50 <dpiponi> psnl: MacosX
16:16:50 <tiglionabbit> sameContainer one@(A _) two@(A _) = True
16:16:56 <LoganCapaldo> [a] = a*, Maybe a = a?
16:17:08 <psnl> dpiponi: two mins, I'll tell you where my alex came from
16:17:10 <syntaxfree> http://ed-thelen.org/comp-hist/APL-hist.html
16:17:15 <syntaxfree> that is a sweet, sweet read.
16:17:19 <LoganCapaldo> or [a] = { a }, Maybe a = [ a ] if you prefer :)
16:17:48 <psnl> dpiponi: dang, its the latest stable build
16:17:53 <LoganCapaldo> (a, b, c) is already a b c practically :)
16:19:05 <nmessenger> tiglionabbit: not sure what you're asking for, but sameContainer is fine, yes.
16:19:18 <dpiponi> psnl: Assume I'm really stupid. Does an obvious mistake I could have made come to mind? I just typed "darcs get http://darcs.haskell.org/alex"
16:19:20 <lambdabot> Title: Index of /alex
16:19:26 <tiglionabbit> nmessenger: well, the compiler doesn't accept that :P
16:19:47 <tiglionabbit> it says "Not in scope: data contstructor A"
16:20:18 <nmessenger> tiglionabbit: you want something generic?  There might be an extension of some kind.
16:20:26 <tiglionabbit> hm?
16:21:21 <narain> what would the type of sameContainer be then?
16:21:41 <nmessenger> sameConstructer :: a -> a -> Bool -- I'd wager
16:21:43 <sorear> my command line parser design is ... very powerful at runtime ... but how to make help is not clear ...
16:21:49 <nmessenger> s/ter/tor/
16:23:09 <shachaf> dpiponi: "darcs get http://darcs.haskell.org/alex" works for me.
16:23:09 <lambdabot> Title: Index of /alex
16:23:17 <nmessenger> you might have a class ConsEq and use TH to autoderive instances
16:23:19 <psnl> dpiponi: http://www.haskell.org/alex/dist/2.1.0/alex-2.1.0.tar.gz is maybe where I started
16:23:30 <tiglionabbit> nmessenger: yep.  But I don't know if this is possible to do using a pattern...
16:23:41 <psnl> dpiponi: you might need a autoreconf if you are getting sources from darcs
16:24:00 <nmessenger> tiglionabbit: nope, constructors in a pattern must belong to some concrete datatype
16:24:02 <dpiponi> psnl: Building from the tar file gave "mk/boilerplate.mk:15: ../mk/boilerplate.mk: No such file or directory"
16:24:14 <psnl> dpiponi: did you run autoreconf?
16:24:24 <psnl> ignore that
16:24:35 <dpiponi> psnl: no. And now I'm ignoring that.
16:24:40 <tiglionabbit> nmessenger: then is there a way to just ask something which constructor it's using?
16:24:43 <psnl> dpiponi: sorry, I have no idea
16:24:52 <tiglionabbit> without having to write clauses for each one
16:25:25 <psnl> dpiponi: root@shiny:~/tmp/gtk2hs-0.9.11# port list | grep alex
16:25:26 <psnl> alex                           @2.0.1          devel/alex
16:25:33 <psnl> the lazy choice!
16:25:52 <nmessenger> tiglionabbit: not without introducing a runtime type representation, maybe Data.Typeable?
16:26:05 <sorear> dpiponi: ../mk sounds like a fptools path.  you might need to unpack the tarball inside a GHC build tree.  or just use the darcs version.
16:26:14 <nmessenger> tiglionabbit: it doesn't seem very useful anyway
16:28:17 <narain> tiglionabbit: what do you need it for?
16:28:22 <tiglionabbit> it's useful because then I don't have to say sameType _@(TypeOne _) _@(TypeOne _) = True; sameType _@(TypeTwo _) _@(TypeTwo _) = True...  etc
16:28:34 <dpiponi> sorear: Well I tried again to pull the darcs version of alex and got the same error. (Is that what you meant by "darcs version"?)
16:29:26 <narain> out of curiosity, where would sameType (or sameConstructor rather) be used?
16:29:42 <dpiponi> sorear: Aha. The error message was from the partly installed darcs version. Maybe the tarball will work after all
16:29:44 <tiglionabbit> ...   in a typechecker
16:29:44 <SamB> maybe it is like samegame
16:30:21 <chr1s__> is there a function with type a -> b -> (a,b)
16:30:25 <narain> ah
16:30:28 <chr1s__> I searched hoogle for it
16:30:31 <sorear> chr1s__: (,)
16:30:31 <narain> chr1s__: (,)
16:30:33 <nmessenger> chr1s__: (,)
16:30:35 <sorear> @type (,)
16:30:36 <chr1s__> nice :D
16:30:37 <lambdabot> forall a b. a -> b -> (a, b)
16:30:44 <chr1s__> thanks!
16:30:45 <jcreigh> @quote stereo
16:30:45 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
16:30:46 <narain> chr1s__: three for the price of one!
16:30:56 * notsmack doesn't understand the FizzBuzz buzz
16:31:08 <tiglionabbit> I think he got surround sound that time
16:31:09 <nmessenger> notsmack: do you understand the fizz?
16:31:12 <nmessenger> :P
16:31:28 <narain> dang, i was going to say that
16:31:31 * tiglionabbit is waiting for 5.1
16:31:34 <jcreigh> notsmack: it's like a sign that says "do not walk on the grass". Coders can't resist it.
16:31:43 <SamB> jcreigh: that isn not stereo ;-)
16:31:57 <SamB> what is fizzbuzz?
16:32:19 <notsmack> SamB: nothing, essentially.
16:32:28 <nmessenger> @go fizzbuzz programmer
16:32:29 <lambdabot> http://tickletux.wordpress.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/
16:32:29 <lambdabot> Title: Using FizzBuzz to Find Developers who Grok Coding  Imran On Tech
16:32:43 <dons> please no!
16:32:52 <nmessenger> oh noes!  Sorry!
16:33:00 <kc5tja> syntaxfree: This is a very interesting paper.  I'm enjoying it a lot.  It's no accident that my future Forth environment for the Kestrel will borrow heavily from J as much as I know how.  :)
16:33:08 <dons> "Using fibonacci to find developers who haven't had lobotomies"
16:34:14 <dpiponi> Hey dons. I'm finally trying to learn haddock and haddockise some code like you suggested. Taking longer than I expected to build haddock though...
16:34:20 <syntaxfree> J looks silly to me. No third-order functions?
16:34:43 <syntaxfree> dpiponi: hey. interesting post on the algebraic structure of probability monads, etc.
16:35:08 <dons> dpiponi: oh?
16:35:09 <SamB> hmm. doesn't look too hard...
16:35:21 <dpiponi> syntaxfree: You talking about the first post or the second one on that subject (note new blog location).
16:35:34 <syntaxfree> new blog location?
16:35:35 <kc5tja> syntaxfree: J is just an ASCII-ified version of APL.
16:35:45 <syntaxfree> kc5tja: I know.
16:35:46 <kc5tja> syntaxfree: What is your opinion of K?  K also looks interesting.
16:36:15 <dpiponi> dons: Well darcs needed alex but I couldn't darcs alex without some error about applying a hunk. Built alex from a tarball. Now get same darcs error with happy, another dependency.
16:37:47 <syntaxfree> dpiponi: I once actually tried to write something like PFP, but got sidetracked into implementing full measure-based probability theory and never got anything runnable done.
16:38:02 <dpiponi> syntaxfree: http://sigfpe.wordpress.com
16:38:03 <lambdabot> Title: A Neighbourhood of Infinity
16:38:16 <syntaxfree> dpiponi: yay! Were you prompted by the latexy goodness?
16:38:36 <dpiponi> syntaxfree: How did I live before LaTex?
16:38:53 <syntaxfree> dpiponi: I used to use heavy &Sum; x<sub>i</sub> code on my old blog.
16:38:59 <syntaxfree> The new blog never discusses any maths, though.
16:39:08 <syntaxfree> (the new blog isn't the haskell blog either, haha)
16:39:17 <dpiponi> syntaxfree: Yeah, the HTML was driving me crazy
16:41:23 <syntaxfree> dpiponi: let me show you an example of that..
16:41:41 <syntaxfree> ah, rather not.
16:41:48 <syntaxfree> It's all offline. Sorry :)
16:42:16 <syntaxfree> anyway, I'm somewhat concerned about PFP development being too tightly coupled to P(X=x) probability representations.
16:42:46 <syntaxfree> for most real-world usage you want to represent distributions as P(X<=x)
16:43:07 <dpiponi> syntaxfree: That's assuming a total ordering on your space
16:43:18 <syntaxfree> dpiponi: that is true.
16:43:36 <dpiponi> syntaxfree: and a general measure would be way too hard
16:43:56 <syntaxfree> anyway, what I mean is that it should be easier to couple in such a query.
16:44:20 <syntaxfree> s/couple in/plug in
16:44:43 <dpiponi> syntaxfree: Incidentally, here's where you can go with monadic probability: http://golem.ph.utexas.edu/category/2007/02/category_theoretic_probability_1.html
16:44:45 <lambdabot> Title: Category Theoretic Probability Theory II | The n-Category Caf&#xE9;, http://tinyurl.com/28ttpb
16:44:54 <dpiponi> syntaxfree (But that's a little further than we need.)
16:44:56 <syntaxfree> as it stands now, PFP is of little use for most statistic analysis.
16:45:16 <syntaxfree> yeah. I keep wondering if I can change my dissertation topic to PFP somehow.
16:45:23 <dpiponi> syntaxfree: Yes. PFP is a nice toy for illustrative examples
16:45:40 <syntaxfree> (I'm  working on insurance contracts, but could switch to econometrics)
16:45:59 <dpiponi> syntaxfree: I was wondering about monte carlo integration for ray-tracing. Can we do that with a probability monad?
16:46:15 <triplah_w> anyone know of a good guide to writing concurrent code with haskell?
16:46:28 <syntaxfree> dpiponi: the thing is, I've wanted to work with distributions forever. I must have spent hundreds of hours writing boring R code, even with higher-order functions and the like.
16:47:01 <syntaxfree> dpiponi: hmm. to the extent you discretize your space, yes.
16:47:15 <syntaxfree> at least it feels so to me.
16:48:05 <dpiponi> syntaxfree: Not sure you want to discretise.
16:48:50 <dpiponi> dpiponi: Well, you can discretise. But it'd be nice to have a description of what's going on that looks nice and continuous
16:48:54 <syntaxfree> (a lot of applied computer econometrics nowadays involves bootstrapping parameter distributions.
16:49:23 <syntaxfree> monte carlo methods could be considered a special case of that)
16:49:43 <dpiponi> syntaxfree: There's a lot of crossover between rendering, economics and, as Eric Kidd has pointed out to me now, locating robots(!)
16:49:58 <syntaxfree> I'm not sure of the crossover with economics proper.
16:50:20 <syntaxfree> That's why I've been wanting to switch to econometrics somehow for my dissertation, because I'm so freaking bored with economics, all I wanna read up on is FP.
16:50:35 <dpiponi> syntaxfree: Oh, you're a proper economist
16:50:50 <syntaxfree> yes, I'm in graduate school
16:51:29 <dpiponi> syntaxfree: Hmmm...I can see why you might have a problem applying FP
16:51:45 <syntaxfree> I keep on thinking I'll title my dissertation something like "Comonadic cellular automata evaluation and the development of insurance institutions in the third world: a nonsense approach"
16:52:21 <dpiponi> syntaxfree: The only difference between that and a real thesis title is the word 'nonsense' :-)
16:52:45 <syntaxfree> Chapter 1, Comonads. Chapter 2, Financial Insitutions. Chapter 3, Sorry I'm pretending this is a dissertation.
16:53:29 <dpiponi> syntaxfree: You know all about http://lambda-the-ultimate.org/node/1283 I suppose. Not quite economics but a nice non-trivial application to finance outside of number crunching.
16:53:30 <lambdabot> Title: Combinators for contracts | Lambda the Ultimate
16:55:22 <triplah_w> can anyone tell me if there is lightweight threads/processes implemented for hs at all? (like erlang's spawn?)
16:55:39 <yip> triplah_w: yes
16:55:45 <yip> triplah_w: forkIO
16:55:50 <dons> triplah_w: all haskell threads are lightweight
16:55:52 <yip> @type forkIO
16:55:55 <lambdabot> Not in scope: `forkIO'
16:55:58 <triplah_w> yip: ah, i was looking at that, thanks
16:56:04 <dons> ?docs Control.Concurrent
16:56:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
16:56:12 <nmessenger> @hoogle forkIO
16:56:12 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
16:56:20 <triplah_w> i'm just wondering how i can make my app massivly concurrent
16:56:31 <yip> triplah_w: use haskell
16:56:34 <Korollary> triplah_w: seen http://haskell.org/haskellwiki/Libraries_and_tools/Concurrency_and_parallelism ?
16:56:37 <lambdabot> Title: Libraries and tools/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/wvlsw
16:56:38 <dons> in fact, they might almost put erlang out of business, http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all  ;-)
16:56:39 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/lrhoa
16:56:48 <triplah_w> Korollary: nope, thanks
16:57:01 <triplah_w> dons: ehe :D
16:57:03 <dons> so for say, up to 10k threads, forkIO is great. for 10M threads, the unified events/threads lib would be a better (but more experimental) optoin
16:57:05 <syntaxfree> dpiponi: ah, yes.
16:57:09 <syntaxfree> I've seen it, yes :)
16:57:22 <ndm> dons: Erlang has much more intertia for it, something a lot more important than performance of capability
16:57:31 <triplah_w> well these threads would be really lightweight
16:57:34 <dons> sure.
16:57:53 <yip> triplah_w: also take a look at the STM module, it's a really great method for thread communication
16:58:05 <dons> i'm not literally saying "put erlang out of business" , more that "haskell threads are pretty damn good" :-)
16:58:11 <triplah_w> i've just got tasks that are taking too long to process iterativly, if im going to the effort of making them highly concurrent with threads, i certainly can't use python because its threads suck
16:58:21 <dpiponi> Finally built haddock!
16:58:27 <syntaxfree> Python is soup-in-a-cup.
16:58:36 <yip> triplah_w: do you have a multi-cpu machine?
16:58:40 <syntaxfree> Haskell/GHC does make building things a pain sometimes.
16:58:51 <triplah_w> yip: yep, that's why i want to do this
16:58:57 <dons> triplah_w: so smp ghc + STM locking + forkIO should be fairly sweet
16:58:59 <yip> triplah_w: how many cpus do you got? :)
16:59:00 <fantasma> is there a list of apps made to work with HApps
16:59:04 <triplah_w> yip: at the moment i'm using multiple processes
16:59:14 <triplah_w> yip: 2 here, but production deployment may be on 8
16:59:27 <fantasma> @where happs
16:59:28 <yip> triplah_w: sweet, yeah STM with thousands of threads should be good
16:59:28 <lambdabot> http://happs.org
16:59:32 <syntaxfree> If I was to replicate that "5 things I hate about Python" article, I think the only thing I'd mention is "Automatic dependency resolution of the love of Charles Mingus whose swingin'soul is by our lord's side".
16:59:49 <yip> triplah_w: the ghc runtime will distribute them over your available cpus
16:59:54 <triplah_w> yip, dons : thanks for your help
16:59:56 <triplah_w> yip: great
17:00:17 <triplah_w> are there any benches done on this?
17:00:17 <Saizan> is there a STM vs message-passing comparison somewhere?
17:00:32 <triplah_w> ie when is the overhead of spawning microthreads too great for the task at hand?
17:00:39 <fantasma> anyone?
17:00:40 <yip> Saizan: i think Cale proved that you can implement message-passing on top of STM
17:00:42 <triplah_w> ie, context switching starts bogging down the app
17:00:47 <fantasma> (list of HAppS applications)
17:01:12 <dons> or just use chans for message passing
17:01:17 <yip> triplah_w: see the links dons pasted earlier
17:01:20 <dons> being a message passing abstraction , and al that.
17:01:21 <sorear> fantasma: ["Pass.net", "hpaste"]
17:01:26 <sorear> maybe othersj
17:01:28 <Saizan> yip: well, i was thinking of something as easyness of use
17:01:39 <fantasma> sorear, ah alright, wasn't sure if there were any others
17:01:46 <triplah_w> yip: great, getting there :)
17:02:39 <sorear> fantasma: you might try asking on #happs, it'll stay on-screen longer :)
17:02:49 <fantasma> haha alright
17:03:14 <syntaxfree> Pass.net is not a bad idea, but it's inadequately explained.
17:03:19 <psnl> dcoutts: ooh, what did you do to  textView / textBuffer in gtk2hs 9.11?
17:03:26 <syntaxfree> Also it sounds like the .NET version of Microsoft Passport.
17:03:45 <dcoutts> psnl, nothing? why, does something not work?
17:03:47 <fantasma> i dont even understand what pass.net does
17:04:02 <syntaxfree> it's clever, it's very clever.
17:04:23 <fantasma> syntaxfree, care to explain? :)
17:04:24 <syntaxfree> speaking of web frameworks, that kpax video sure is sexy.
17:04:27 <psnl> dcoutts: you seem to have lost makeEmptyTextIter
17:04:52 <psnl> which isn't a problem, really
17:04:59 <syntaxfree> fantasma: many sites use email for id confirmation.
17:05:07 <syntaxfree> So you get the email and have to reply since you're a human.
17:05:14 <fantasma> syntaxfree, of course
17:05:16 <syntaxfree> with the Pass.net service, there's automatic email verification.
17:05:27 <syntaxfree> I mean, the website owner uses Pass.net
17:05:44 <fantasma> hmmm
17:05:54 <fantasma> don't see what's so great about that
17:06:06 <fantasma> you can just trace an email and if the trace succeeds then it's valid
17:06:26 <syntaxfree> trace an email?
17:07:28 <dcoutts> psnl, makeEmptyTextIter still exists, it may not be exported by default but if you need it you can import it from the Graphics.UI.Gtk.Multiline.Types
17:07:35 <fantasma> it's like ping, but for email
17:08:20 <psnl> dcoutts: I'm having complete brain death and have forgotten how to make a TextIter properly
17:08:32 <dcoutts> psnl, what do you need it for? I was under the impression that we didn't need that exported.
17:09:40 <fantasma> syntaxfree, actually an email trace only tests delivery to server and not the email itself
17:09:53 <fantasma> so I guess pass.net is useful
17:10:08 <syntaxfree> fantasma: oh. tou mean traceroute the domain?
17:10:12 <syntaxfree> s/tou/you.
17:10:21 <psnl> dcoutts: All i want to do is write to the end of a textbuffer. /me goes to look  for the correct solution...
17:10:33 <syntaxfree> Pass.net does not just authenticate than an email is real. It authenticates the user as owning that email addy.
17:11:10 <fantasma> that's a whole different story ;)
17:11:31 <dcoutts> psnl, textBufferGetEndIter and textBufferInsert I reckon.
17:11:31 <fantasma> this is only conceptual though, correct?
17:11:47 <syntaxfree> nah, you can install that on your website Today.
17:11:54 <syntaxfree> And you don't need Haskell or anything.
17:11:57 <syntaxfree> It's a web service.
17:14:49 <fax> hi
17:15:04 <fax> anyone using this  http://hoc.sourceforge.net/index.html to write programs with?
17:15:05 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
17:16:11 <triplah_w> yip: most of the apps in that shootout are using co-routines (or simulating it) would they get spread over multiple cpu's with hs?
17:16:29 <triplah_w> i know with python they dont
17:16:46 <yip> depends on exactly what they are doing. if they use forkIO then yes
17:17:05 <triplah_w> import Control.Concurrent
17:17:05 <triplah_w> import System
17:17:10 <triplah_w> doesnt look like it
17:17:20 <triplah_w> actually they do
17:17:27 <psnl> dcoutts: ta.
17:17:45 <dons> triplah_w: anything using forkIO or `par` can be run over multiple real processors
17:17:48 <tiglionabbit> is there an and operator that doesn't require a list?
17:17:57 <yip> triplah_w: there are also other ways to utilize multiple cpus, using parallel strategies, but that is more complex and still being actively researched
17:18:00 <dons> :t (&&)
17:18:00 <allbery_b> :t (&&)
17:18:04 <lambdabot> Bool -> Bool -> Bool
17:18:04 <lambdabot> Bool -> Bool -> Bool
17:18:07 <tiglionabbit> thanks
17:18:09 <dons> :t and
17:18:09 <allbery_b> @quote stereo
17:18:10 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
17:18:12 <lambdabot> [Bool] -> Bool
17:18:14 <dons> ?src and
17:18:14 <lambdabot> and   =  foldr (&&) True
17:18:17 <dons> :-)
17:18:54 <dons> sjanssen: I want hwm to hack on! :-)
17:18:54 <triplah_w> yip: ah ok, thanks
17:19:48 <fax> there is no intel binary distributions of GHC?
17:20:57 <psnl> fax: for os X?
17:21:01 <dons> i believe there is, but on the Mac page.
17:21:02 <fax> yeah
17:21:11 <dons> or somewehre else. its out there somewhere!
17:22:11 <psnl> fax: it builds really quickly on my mac
17:22:33 <psnl> fax: I really couldn't belive it
17:22:37 <fax> ill try to build it then
17:22:51 <psnl> a couple of hours instead of a couple of days...
17:22:57 <fax> oh
17:22:58 <fax> lol
17:23:01 <narain> fax: it looks like there is one on the download page, or am i missing something?
17:23:12 <narain> http://www.haskell.org/ghc/download_ghc_66.html#macosxintel
17:23:13 <lambdabot> Title: GHC: Download version 6.6
17:23:23 <fax> wow..
17:23:27 <fax> ok I missed that somehow
17:23:28 <fax> thanks
17:24:51 <JohnMeacham> there really needs to be a standard type-level number library in base.
17:24:59 <sorear> agreed.
17:25:04 <sorear> but which one? :)
17:25:17 <sorear> so many reps
17:25:19 <ndm> I am amazed no one has put together a proper Type heirarchy
17:25:38 <ndm> Type.Number.Peano, Type.Number.Binary - have all flavours
17:25:51 <ndm> although perhaps it shouldn't be in base, but in a type package
17:26:15 <ndm> most people either want to do type level arithmetic or not, there isn't so much middle ground
17:26:46 <fax> hmmm http://www.matthewmorgan.net/blog/archives/2005/11/28/choosing-haskell-was-a-mistake
17:26:49 <lambdabot> Title: A Trifle Absurd  Choosing Haskell Was a Mistake, http://tinyurl.com/yurbgj
17:27:14 <fax> I doubt what he is saying is true..
17:27:26 <sorear> ndm: I've got a primitive `interleave` that can very easily express all sorts of fun command line parsing functions, like "At most one @foo option, defaulting to @default".  My main problem at this point is mapping the BNF+interleave onto the normal help-text format, which is proving difficult.
17:27:49 <ndm> fax: i agree with him in that post, he is probably right
17:27:57 <fax> augh :[
17:28:11 <ndm> fax: when you are spending all your time marshalling to another language, just use the other language and live happy
17:28:17 <sorear> the main problem is interleave can express things like <one option must precede another> that have no concise description in the helpformat.
17:28:34 <ndm> fax: i.e. if you are going to be 90% talking to other languages, its much easier to be in that language
17:29:11 <ndm> sorear: if thats your biggest problem, choosing a user interface for help options, i think you've cracked the problem :)
17:29:23 <dancor> doClient h = doClientIO h `catchJust ioErrors` putStrLn "IO Error" `finally` hClose h
17:29:24 <fax> gr :[
17:29:37 <dancor> is this the proper way to wrap a fcn that might throw io errors
17:29:45 <fax> I guess ill just not learn from his mistake in the hope that he might be wrong
17:30:02 <dancor> not that doClientIO calls doClient at the end and is intended to serve a socket connection until it dies
17:30:05 <dancor> notE
17:30:25 <ndm> sorear: although i'd say interleave should be the standard haskell interleaving function on lists, even if it doesn't exist - so perhaps another name for the combinator - i hear $!^%! isn't taken yet
17:30:48 <allbery_b> he's right; if you're doing Cocoa dev, you're really better off in ObjC.  maybe if there are mature Haskell bindings to Cocoa at some point... but in their absence, and if he's not in a position to shave that yak himself, then ObjC's really the only sensible choice
17:30:48 <sorear> ndm: I'm actually using |+| at the moment :)
17:31:14 <ndm> sorear: why not |~|, haven't you been using that in this channel a lot ;)
17:31:23 <ndm> although |+| is perfectly sensible
17:31:31 <allbery_b> it doesn't help that ObjC's way of doing business is not the best fit with Haskell (or much of anything except maybe Smalltalk or Ruby)
17:33:11 <ndm> i'm still not convinced that writing a GUI in Haskell is better than C#
17:33:57 <ndm> if it wasn't for dcoutts i still would be GUI'ing in C#
17:34:36 * dancor has not written a haskell gui yet
17:34:47 <fax> :(
17:34:54 <sorear> dcoutts as the provider of gtk2hs?
17:35:11 * narain hasn't either but phooey appeared interesting
17:36:50 <ndm> sorear: indeed
17:37:24 <ndm> i want to release PropLang at some point, maybe turn that into a full GUI, since i think it makes the functional programming approach with GUI's stronger, rather than being just an IO monad playground
17:37:25 <sorear> @users
17:37:25 <lambdabot> Maximum users seen in #haskell: 336, currently: 312 (92.9%), active: 51 (16.3%)
17:37:42 <sorear> @wheer proplang
17:37:42 <lambdabot> Maybe you meant: where where+
17:37:47 <sorear> @where proplang
17:37:48 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/proplang
17:38:01 <ndm> i've spotted a crappy conference, which i might try and submit something on PropLang to - i'm pretty sure they'd accept anything ;)
17:38:09 <yip> ndm: what about yampa/fruit?
17:38:28 <ndm> yip: PropLang is something a bit different, but with some similarities in approach to those things
17:39:05 <yip> ndm: i've had lots of fun drawing up fun fruit guis on paper :)
17:39:26 <ndm> yip: have you seen the proplang demo? its quite convincing
17:39:29 <yip> no
17:39:33 <dpiponi> I'm just starting with haddock. Anyone know what I need to do to get it to recognise Functor from the Prelude. "the following names could not be resolved: Functor"
17:39:50 <ndm> sb!text =< (\x -> "Word count: " ++ show (length $ words x)) =$$= txt!text
17:40:01 <yip> ndm: but i've done a fair shair of c# gui programming, and gtk2hs. gtk2hs is a worthy competitor
17:40:09 <ndm> thats my favourite line - the status bar displays the word count - one line and thats it
17:40:19 <yip> hm...
17:40:24 <ndm> dpiponi: ignore it, its not worth it
17:40:34 <yip> ndm: well in fruit it would be similar
17:40:39 <ndm> yip: i.e. no responding to events etc, it all just works, with one line of initialisation
17:40:58 <ndm> fruit isn't based on Gtk2hs is it? i remember Tk, for some reason
17:41:05 <yip> ndm: same with fruit, just a single arrow connecting your text through the worldLength function to the statusbar widget
17:41:25 <yip> ndm: no, it's a purely functional gui, built from scratch
17:41:35 <yip> ndm: implemented using some weird java shit though
17:41:46 <dpiponi> ndm: OK, it seems to work fine otherwise. Thanks.
17:41:53 <sorear> last I heard fruit used wxwidgets
17:41:55 <ndm> being built on Gtk2Hs is a big win, i feel, as it allows you to jump out of properties easily
17:42:00 <sorear> @where fruit
17:42:00 <lambdabot> http://haskell.org/fruit/
17:42:02 <yip> sorear: no, there was a wxFruit though
17:42:12 <sorear> Oh right fruit
17:42:21 <sorear> bah, I was thinking phoey
17:43:22 <yip> fruit is a huge paradigm shift for gui programming. this is problematic since you can't fit it in to existing gui toolkits. but people have tried with various results
17:44:37 <ndm> PropLang fits perfectly with Gtk2Hs, allowing you to operate using the Gtk functions, or the PropLang ones
17:44:47 <ndm> yet still do cool property based stuff
17:45:12 <yip> interesting
17:45:27 <ndm> you set properties within the IO monad, which i guess is different to fruit
17:45:44 <ndm> but thats usually at initialisation, so you just list them, and the IO monad is a good thing (nice one per line layout)
17:47:16 <yip> yeah, with fruit you never touch the IO monad. but this sounds like an interesting approach for "real world" stuff
17:47:29 <syntaxfree> fruit?
17:47:51 <yip> functional reactive user interface library
17:48:47 <ndm> yeah, but alas its completely a million miles away from my PhD, so i don't have time for it
17:49:19 <ndm> but i have been writing GuiHaskell with it, and its really easy to use
17:49:44 <yip> have you looked at flapjax?
17:50:01 <ndm> thats way cool :)
17:50:11 <ndm> i saw Phil Wadler give a demo of it
17:50:40 <ndm> i'm not convinced a streams interface is that useful for general work-style GUI's, i.e. non-game/interactive style ones
17:52:55 <yip> i think the only problems are performance, and the missing research that shows how to integrate file/network IO
17:53:02 <sorear> ndm: is guihaskell a "current" project?
17:53:24 <sorear> as in, I thought you were only doing catch/yhc stuff nowadays
17:53:32 <sorear> and the others were semidead
17:53:47 <ndm> sorear: it got put on the back burner because GHC and Gtk didn't like threads, now its still there, but its a proof that it would work - just needs the polish
17:53:58 <ndm> i am pretty much Catch for the next month
17:54:05 <ndm> then Play for the month after that
17:55:38 <ndm> PropLang is unfortunately comatose for the moment
17:55:47 <ndm> Yhc -O11 gets a look in after Play
17:56:16 <dons> -O11 is the codename for the yhc optimiser?
17:56:25 * sorear is bigging to wonder how many doctorates ndm is trying for
17:56:27 <dons> or the inlining/rules idea?
17:56:35 <sorear> dons: two of em.
17:56:51 <sorear> dons: yhc -O1 = generate bytecode, but with a ghc-style simplifier
17:57:00 <ndm> dons: the yhc super optimiser, the inlining/simplifying is -O
17:57:19 <sorear> dons: yhc -O11 = catch forward type analysis, second system jhc
17:57:26 <dons> ah right.
17:57:37 <dons> let me know when anything's working and testable on nobench :-)
17:57:42 <ndm> -O11 is certainly super optimisations at the Core level, perhaps a super C back end as well (i have a prototype)
17:57:57 <ndm> dons: it will be flakey as anything, Yhc really wasn't designed for these tricks...
17:58:12 <dons> for core->core transformations?
17:58:18 <ndm> nobench will probably be all it does, but not for theory reasons, just because the implementation is building on a layer of quicksand
17:58:29 <ndm> dons: yes, core -> core
17:58:37 <dons> maybe it'd be more profitable adding it as a ghc pass?
17:58:42 <dons> then people could use it on real code?
17:58:59 <ndm> it will be much easier to add it as a yhc pass, since Yhc.Core is much better designed and librarfied
17:59:26 <dons> just harder to produce numbers, since you can't compare against other optimiations done by yhc
17:59:26 <ndm> if it turns out to work, then i'd expect a student project could add it to GHC, or a SoC project or something
17:59:33 <dons> fair enough.
17:59:58 <ndm> yeah, the comparison is harder, but GHC is too big to hack, too hard to build
18:00:13 <ndm> having a 7 second recompilation on your optimiser helps you develop it faster ;)
18:00:50 <dons> I think core->core stuff is pretty easy to add though.
18:00:54 <dons> ther's a tutorial in the commentary
18:00:55 <ndm> plus GHC doesn't have a first order transformation, or whole program analysis - both things that would take a while to add, and are prerequisites
18:01:50 <fax> I just got ghc
18:02:26 <dons> fax, great!
18:02:34 <fax> can I do anything cool with it
18:02:37 <dons> that's step 1 on the path to world domination
18:02:41 <dons> fire up ghci
18:03:24 <dons> check that it works:
18:03:25 <dons> Prelude> let fib = 1 : 1 : zipWith (+) fib (tail fib)
18:03:26 <dons> Prelude> take 100 fib
18:03:27 <dons> :-)
18:03:30 <monochrom> There is a deep reason why the ghc internal datatype RealWorld# is called ReadWorld#.
18:03:53 <fax> nice it works :D
18:04:17 <sorear> the yhc one is just called World
18:04:29 <sorear> jhc has RealWorld__
18:04:45 <monochrom> Heh
18:05:09 <fax> sick :|
18:05:35 <fax> if you have "import EPController" in a file
18:05:37 <ndm> thats because yhc isn't for use in the RealWorld yet, once we hit 1.0 we'll rename the IO Monad ;)
18:05:49 <fax> ghc -i . thatfile.hs
18:05:56 <fax> but it still says Failed to load interface for `EPController':
18:05:59 <monochrom> I will call mine Universe#
18:06:36 * ndm thinks GHC didn't really need to steal that extra # character
18:06:43 <monochrom> I will also have: newtype IO a = MasterOfTheUniverse (Universe# -> (a, #Universe))
18:06:49 <dons> fax, ghc --make -O thatfile.hs
18:06:56 <sorear> fax: ghc needs to find precompiled versions of other modules
18:07:12 <fax> heh that did somthing :D
18:07:15 <dons> fax, --make is used to compile multiple modules, and -O is just a good idea if you want fast code
18:07:15 <sorear> fax: or you can use --make, which says "compile any missing modules"
18:07:21 <monochrom> However, I'm thinking I'm more like Skeletor than Master of The Universe. :)
18:07:44 <dons> ndm, the # is a bit odd, but since its a strict *kind* it makes sense to keep it special
18:08:29 <ndm> dons: the kind is #, but the functions with # at the end are not restricted to being of kind # - you can have foo that works on unboxed values and foo# on boxed ones
18:08:58 <ndm> we have kind * and 1*2, we can have kind # and still use the # operator
18:09:17 <dons> oh, i see what you mean. you mean # in identifiers versus # in varsyms?
18:09:23 <ndm> yep
18:09:24 <dons> yea, a bit evil.
18:09:44 <fax> has anyone used http://hoc.sourceforge.net/index.html on mac os x intel?
18:09:44 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
18:10:07 <dons> fax, i think its vaguely unmaintained, but ozone is the author, if he's around
18:10:07 <fax> (just wondering if they had issues with libffi)
18:10:09 <dons> @seen ozone
18:10:10 <lambdabot> ozone is in #haskell. I don't know when ozone last spoke.
18:10:14 <dons> ozone, ping!
18:10:26 <dons> they use libffi??
18:10:31 <fax> yes
18:10:52 <dons> oh, didn't know that. that's interesting, for a ghc binding.
18:11:33 <fax> how come?
18:11:51 <dons> we don't use libffi in ghc normally, since ghc has its own ffi lib in the rts
18:11:59 <dons> written before there was a libffi
18:12:05 <fax> oh hm
18:13:37 <fax> gah annoying
18:13:41 <TomMD> Does anyone here have experience with Agda, Isabelle or others used for proving Haskell programs?
18:13:49 <sorear> @goo libffi
18:13:51 <lambdabot> http://sourceware.org/libffi/
18:13:51 <lambdabot> Title: libffi
18:13:53 <dons> i've looked a little at it, TomMD
18:13:59 <dons> i can point you to some research, if you'd like?
18:14:22 <TomMD> That would be great.
18:14:52 <dons> e.g on verifying the L4 kernel prototype in haskell, using isabelle. amongst other things, http://haskell.org/haskellwiki/Research_papers/Testing_and_correctness#Verifying_Haskell_programs
18:14:55 <lambdabot> Title: Research papers/Testing and correctness - HaskellWiki, http://tinyurl.com/27sq72
18:14:56 <TomMD> Any initial opinions would be welcome as well (although not taken as gospel, no matter how much you are on #haskell ;) )
18:15:17 <sorear> hm.  should I use libffi in ayhi?  currently I'm just generating machine-code wrapper stubs for each imported function.
18:15:27 <dons> Isabelle is used in commerical settings (Galois) to verify haskell programs
18:15:30 <dons> that's probably the cutting edge
18:16:16 <ndm> sorear: do what you think is best, if you are at the ASM level then you have more flexibility
18:16:18 <dons> sorear: libffi is probably a saner choice
18:16:35 <dons> in terms of leaving it up to someone else to get the callign conventions right
18:17:06 <ndm> TomMD: we had a project at York to do some verification of code with HOL Lite, i'll try and find a link
18:17:59 <ndm> TomMD: http://www.cs.york.ac.uk/plasma/misc/Guanhua_He_MSc_thesis.pdf
18:18:20 <ndm> i haven't actually read it yet, but it is on my pile to read
18:19:29 <TomMD> Thank you both.  It looks like I'm going to be making hard copies given the quantity.
18:19:35 <fax> :(
18:19:55 <fax> ive tried lisp scheme SML ocaml and haskell now
18:20:30 <fax> no luck with getting cocoa for any
18:20:30 <TomMD> fax: and what are your thoughts?
18:20:40 <fax> fantastic programming languages
18:20:56 <fax> but its clear why people still use things like C and write buggy programs which crash
18:21:25 <TomMD> Do enlighten me, I wrote buggy 'C' programs but I avoid doing so ever since I learned Haskell.
18:21:29 <ihope> Writing an OS kernel in Haskell would be fun, no?
18:21:58 <ihope> The only problem is getting GHC to output something which is easy to turn into a Multiboot-compliant kernel.
18:22:15 <sorear> @where house
18:22:15 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
18:22:20 <sorear> they did that
18:22:24 <ndm> @where hop
18:22:25 <lambdabot> http://www.macs.hw.ac.uk/~sebc/hOp/
18:22:26 <TomMD> ihope: Have you looked at the Osker, House, hOp projects?  I gather that people enjoy such efforts.
18:22:28 <ndm> twice :)
18:22:34 <ihope> Indeed, I could learn from those.
18:22:35 <fax> TomMD: well its tough to get setup for things like GUIs etc or threading or a multitude of things
18:22:48 <fax> (im not talking about just haskell)
18:22:48 <sorear> @where osker
18:22:49 <lambdabot> I know nothing about osker.
18:22:53 <sorear> @goog osker
18:22:55 <lambdabot> http://en.wikipedia.org/wiki/Osker
18:23:09 <mbishop> Those crazy Oregoners have to spend their time doing something, since it's always raining out :P
18:23:14 <sorear> suprisingly unhelpful.
18:23:50 <TomMD> The only 'OSKer' in wikipedia is mentioned in L4 which I, completely unaffiliated with any of that, put in.
18:24:21 <mbishop> fax: Ocaml can do those things, (at least GTK/Tk), but threading is great, etc, same for haskell as far as I know
18:27:14 <mbishop> Although from what I can see, Cocoa bindings are indeed few and far between, in almost any language
18:27:19 <mbishop> but I blame Apple :P
18:27:29 <fax> *sigh*
18:27:45 <fax> I dont blame anyone, I think its amazing how much free stuffs around
18:27:49 <fax> still dissapointed though
18:28:16 <ihope> Well, is there any nice and easy way to get GHC to output raw assembly that I can stick a Multiboot header onto?
18:28:22 <fax> so hard to quit C
18:28:29 <ihope> Or any other Haskell compiler, for that matter.
18:28:44 <dons> ihope, no. you should look into House for how to run the ghc runtime on bare metal
18:28:56 <dons> it boots just like a normal OS via grub, iirc
18:30:19 <SamB> for some value of normal, yes
18:30:51 <SamB> (I think it wants you to load "modules" with it. Most GRUB-loaded OSes do not want this, afaik.)
18:33:34 <hpaste>  sciolizer pasted "Functional dependencies in multi-parameter type classes" at http://hpaste.org/799
18:34:00 <sciolizer> Help please (@ paste bin)?
18:35:20 <sorear> sciolizer: suppose I write (negative False)
18:35:40 <sorear> sciolizer: suppose instances of Sliding exist at {Int, Bool} and {Double, Bool}
18:35:52 <sorear> sciolizer: your fundep still allows these to co-exist
18:36:03 <sorear> sciolizer: both provide negative :: Bool -> Bool
18:36:11 <sorear> sciolizer: so which one should be chosen?
18:36:43 <sorear> sciolizer: so Sliding is an affine space?
18:37:13 <hpaste>  sorear annotated "Functional dependencies in multi-parameter type classes" with "add another fundep" at http://hpaste.org/799#a1
18:37:16 <sciolizer> sorear: Thanks for your help. Your explanation makes sense. However, I don't know what an affine space is.
18:37:31 <sorear> @google affine space
18:37:33 <lambdabot> http://en.wikipedia.org/wiki/Affine_space
18:37:36 <sciolizer> lol
18:37:44 * sorear checks for helpfulness...
18:38:16 <sorear> second sentence looks descriptive enough
18:38:25 <sciolizer> vector space that's forgot it's origin. Makes sense.
18:38:40 <narain> sorear: an affine space would have  subtract :: a -> a -> b,  right?
18:38:50 <narain> if a's are points and b's are vectors
18:39:18 <narain> would *also* have
18:39:26 <dancor> narain: looks right to me
18:39:34 <dancor> "In an affine space, one can subtract points to get vectors"
18:39:36 <sorear> narain: right.
18:39:49 <sciolizer> sorear, narain: So there are TWO subtract operations in an affine space?
18:39:50 <sorear> narain: didn't notice that on first look
18:40:11 <fax> what does (a -> b) -> fa -> fb mean?
18:40:32 <dibblego> fax, Functor.fmap?
18:40:38 <narain> sciolizer: you can subtract two points to get the displacement vector between them, or you can subtract a vector from a point which is nothing but adding the negative of the vector
18:40:43 <sorear> sciolizer: yeah.  also affine spaces have a Real -> b -> b
18:41:04 <sciolizer> sorear: Well, my "Sliding" space is discrete.
18:41:28 <sorear> fax: not much. fa and fb are unrelated to a and b (I presume you meant to add spaces?)
18:41:38 <fax> hm probably
18:41:45 <dancor> fax: (a -> b) -> f a -> f b  where f is some typeclass means that you take a fcn from a to b and make a fcn from f a to f b..
18:42:20 <fax> whats the meaning of f a ?
18:42:34 * sorear is looking at bitc now ... interesting language, like liskell with a heavy dose of C
18:42:47 <mbishop> sorear: yeah I've seen it a few times
18:43:04 <mbishop> good for systems programming I guess, if you're into that kind of dirty stuff :P
18:43:09 <monochrom> "Maybe a" is a special case of "f a"
18:43:19 <monochrom> Another special case is "[a]"
18:43:32 <sciolizer> Basically, I'm creating a CalendarDay class (like CalendarTime, only with all of the time information removed).
18:43:40 <monochrom> IOW f can be certain polymorphic types.
18:44:19 <narain> sciolizer: so b is lengths of time and a is concrete dates?
18:44:20 <sciolizer> I could create addToCalendarDay methods like the Time module does, but I'm wondering if I should abstract the add/subtract operations to something else. (like Sliding or an Affine space)
18:44:28 <sciolizer> narain: yes
18:44:51 <narain> sciolizer: then it does make sense to subtract two dates to get the interval between them, yes?
18:45:01 <sciolizer> narain: yes, it does. :)
18:45:19 <sorear> sciolizer: does it make sense to multiply an interval by a dimensionless real number?
18:45:30 * dancor thinks so
18:45:54 <sciolizer> sorear: ah yes. I was thinking the real was multiplied by the concrete date, but that didn't make sense.
18:45:54 <narain> sorear: "this conference is two and a half times as long as the last one"
18:46:19 <sciolizer> So, is there anything like an affine space already in the haskell (or ghc) libs?
18:46:33 <sciolizer> Or might I as well go ahead and make it myself?
18:47:31 <dancor> sciolizer: i can't find anything
18:47:43 <sciolizer> dancor: ok
18:49:52 <dons> mm. CEFP looks nice, in the "former capital of Transylvania". beautful city.
18:50:01 <dons> http://cs.ubbcluj.ro/cefp2007/
18:50:01 <narain> sciolizer: it might be somewhere in here: http://cvs.haskell.org/darcs/numericprelude/docs/html/
18:50:05 <lambdabot> Title: Central European Functional Programming School, CEFP2007
18:51:43 <dancor> i'm converting some extremely oo library to haskell.  it has an interface for being a data-transfer object but i think Handle already does that and so i shouldn't make my own MyHandlesque typeclass.  is that correct?
18:52:00 <dancor> or are there other non-handle things i haven't thought of
18:52:12 <sorear> @where streams
18:52:13 <lambdabot> I know nothing about streams.
18:52:18 <sorear> @where bz
18:52:18 <lambdabot> I know nothing about bz.
18:52:31 <dons> dancor: right, it would be unlikely you'd need to make your own handles
18:52:39 <sorear> http://haskell.org/haskellwiki/Library/Streams
18:52:40 <lambdabot> Title: Library/Streams - HaskellWiki
18:52:50 <sorear> @where+ streams http://haskell.org/haskellwiki/Library/Streams
18:52:50 <lambdabot> Done.
18:54:20 <dons> sorear, btw, have you ever used the streams lib?
18:54:32 <dons> we've not had much success: too many segfaults.
18:55:02 <dancor> sorear: does this mean i should use stream instead of handle, or something that they both implement
18:55:16 <dons> dancor, you should almost certainly just use handles
18:55:21 <dancor> ok
18:55:30 <dons> now, is the issue thta you want to write values of many types directly to the handle?
18:55:33 <dons> i.e. serialise them?
18:55:45 <dancor> no that's another layer up
18:55:53 <dons> ok. handles is all you need then.
18:56:04 <dancor> there are many layers (and base classes :) to this library
18:56:52 <sorear> dons: also much of streams' raison d'etre has evaporated
18:57:14 <sorear> dons: nowadays people mostly just use lazy bytestrings and let GHC worry about fusion :)
18:57:16 <dons> yeah.
18:57:42 <dons> it is just too radically different to the haskell culture to ever be adopted, imo,.
18:57:43 <sorear> like Binary
18:57:57 <narain> for future reference, is it possible to do the neat stream transformers thing with just handles?
18:58:01 <narain> <font size="3">like  </font>h <- openRawFD "test" WriteMode >>= bufferBlockStream >>= withEncoding utf8 >>= withLocking :: WithLocking (WithEncoding (BufferedBlockStream FD))
18:58:04 <dons> and we've actively tried to create the bytestring stuff as a more haskell-onic alternative
18:58:15 <sorear> -onic?
18:58:24 <dons> is that neat, narain ? :-)
18:58:32 <dons> yeah, you'd use pure lazy bytestring transformers
18:58:53 <dons> writeFile h (compress . munge . encode $ s)
18:58:53 <monochrom> OH! withEncoding utf8!  I haven't thought of that!
18:59:11 <SamB> what are streams, if not a tool to implement cold fusion?
18:59:12 <narain> dons: well it looked like a modular way to do it :/
18:59:25 <narain> dons: oh
18:59:29 <dons> using function composition is a lot nicer
18:59:43 <dons> and you stay pure,, rather than going down the C++ route.
19:00:02 <narain> dons: buffering and locking and stuff?
19:00:14 <fantasma> are rc scripts parsed with runscript?
19:00:29 <sorear> buffering and locking can be handled well in the deep runtime
19:00:54 <narain> i see
19:01:17 <narain> wait, no i don't. "deep runtime"?
19:02:01 <narain> you mean the programmer should leave it up to the runtime?
19:02:23 <monochrom> in some sense, library internal implementation is part of the runtime
19:03:36 <narain> so you're saying, i shouldn't specify whether to buffer or lock the io myself?
19:03:43 <sorear> right
19:03:58 <narain> hmm
19:04:30 <monochrom> If the library is good, you will not need to.
19:05:32 <monochrom> It is not wrong to want to control these things yourself, but eventually you will have better things to do than worrying about details.
19:05:46 <sorear> jyp++
19:05:52 <sorear> @seen beschmi
19:05:53 <lambdabot> I saw beschmi leaving #haskell, #darcs, #haskell-blah and #ghc 5d 12h 11m 15s ago, and .
19:05:59 <narain> well ok, i can't come up with any counterexamples at the moment so i'll believe you :)
19:06:23 <monochrom> "good library" is very hard. :)
19:06:27 <sorear> y'know, if beschmi stays vanished much longer, I might be tempted to fix yi :)
19:06:53 <dancor> how is yi going to keep up with all the crazy things that vim can do
19:07:08 <monochrom> But look at history.  You will find that the only way to advance is to leave behind more and more details.
19:07:39 <wkh> AN Whitehead
19:07:53 <sorear> dancor: vimProgrammers / yiProgrammers < expressivenessOfHaskell / expressivenessOfC
19:08:10 <wkh> Civilization advances by extending the number of important operations which we can perform without thinking about them.
19:08:16 <sorear> and before you comment about vim scripts
19:08:34 <sorear> that's a fallacious argument because yi can reproduce a vim runtime
19:08:56 <monochrom> Somehow I feel that I thought this up before Whitehead, even though it should be the other way round. :)
19:09:10 <Korollary> Civilizations advance?
19:09:26 <wkh> Korollary: technologically, in certain ways, yes
19:09:31 <monochrom> They do.  Among other things.
19:09:37 <sorear> Korollary: no, civilizations don't. civilization as a whole does.
19:09:46 <Korollary> People take me too seriously
19:09:58 <monochrom> Sorry.  Hahahahahahahaha
19:10:07 * wkh doesn't mean to derail the conversation from cool haskell one-liners and worrying about lambdabot karma
19:10:52 <Korollary> More applications. Fewer one-liners.
19:11:11 <wkh> endusers are so banal.
19:11:32 <sorear> @Let is it fixed yet?
19:11:33 <lambdabot>  Parse error
19:11:38 <sorear> oo!
19:11:41 <sorear> @let is it fixed yet?
19:11:42 <lambdabot>  Parse error
19:11:46 <sorear> @let x = 2
19:11:47 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
19:11:54 * sorear weeps
19:12:20 <SamB> what is cool is when your one-liners are actually not that much different from code that works nicely in apps
19:16:11 <cge> Does anyone know of any library implementing non-linear least squares fitting?
19:16:39 <sorear> hm.
19:16:57 * sorear starts typing: > ...
19:16:57 <cge> I've been using Matlab for data analysis recently, and can't stand it.
19:17:57 <dons> might be an idea to check on haskell-cafe@haskell.org
19:18:02 <dons> that's where the math guys often hang out
19:18:57 <cge> thanks
19:21:31 <sorear> @ty let minimize f = do { gn <- replicateM 100 (State random) ; foldM (flip . const $ ?evolve) gn [1..100] ; return (minimumBy (comparing f) gn) } in minimize
19:21:33 <lambdabot> forall a a1 s. (Random a, RandomGen s, ?evolve::[a] -> State s [a], Ord a1) => (a -> a1) -> State s a
19:22:39 <TSC> Can anyone tell me how to make an unboxed array of a user-defined type?
19:22:49 <sorear> you don't, sadly
19:23:39 <fantasma> what unix command do you use to display what architecture you're on
19:23:51 <monochrom> uname -a
19:24:05 <sorear> arch also works
19:24:22 <monochrom> uname -a  probably says too much
19:24:34 <fantasma> yes, yes it does
19:24:57 <fantasma> do you think it's feasible to try and find gcc binaries so that I can compile something on my webhost?
19:25:10 <monochrom> Yes.
19:25:13 <fantasma> k
19:25:16 <fantasma> lol
19:25:29 <monochrom> maybe trivial or maybe hard
19:25:35 <sorear> @ty let evolve f st = (let pool = take 50 $ sortBy (comparing f) st in replicateM 100 (do a <- State (randomR (0,49)) ; b <- State (randomR (0,49)) ; return (((pool!!a) + (pool!!b))/2))) ; minimize f = do { gn <- replicateM 100 (State random) ; foldM (flip . const $ evolve f) gn [1..100] ; return (minimumBy (comparing f) gn) } in minimize
19:25:37 <lambdabot> forall a a1 s. (Random a, Fractional a, RandomGen s, Ord a1) => (a -> a1) -> State s a
19:25:40 <SamB> a lot more feasable than compiling GCC yourself ;-)
19:25:52 <fantasma> i dont have access to gcc on the system
19:26:11 <SamB> yeah, that was kinda my point
19:26:29 <dons> $ uname -m
19:26:30 <fantasma> if I find binaries w/ the same arch then it might work
19:26:31 <dons> i386
19:27:03 <sorear> > let evolve f st = (let pool = take 50 $ sortBy (comparing f) st in replicateM 100 (do a <- State (randomR (0,49)) ; b <- State (randomR (0,49)) ; return (((pool!!a) + (pool!!b))/2))) ; minimize f = do { gn <- replicateM 100 (State random) ; foldM (flip . const $ evolve f) gn [1..100] ; return (minimumBy (comparing f) gn) } in evalState (minimize (\x -> (x - cos x) ^ 2)) (mkStdGen 42)
19:27:05 <lambdabot>  0.7680036230636769
19:27:08 <fantasma> i should just install a new unix while I'm at it
19:27:18 <sorear> cos 0.7680036
19:27:24 <sorear> > cos 0.7680036
19:27:26 <lambdabot>  0.7192990024216027
19:27:57 <sorear> > let evolve f st = (let pool = take 50 $ sortBy (comparing f) st in replicateM 100 (do a <- State (randomR (0,49)) ; b <- State (randomR (0,49)) ; return (((pool!!a) + (pool!!b))/2))) ; minimize f = do { gn <- replicateM 100 (State random) ; foldM (flip . const $ evolve f) gn [1..100] ; return (minimumBy (comparing f) gn) } in evalState (minimize (\x -> (x - cos x) ^ 2)) (mkStdGen 43)
19:27:59 <lambdabot>  0.7428079993098061
19:28:20 <fantasma> any way to find out which version of gcc I have installed on my system
19:28:21 <dons> Cale, we should get the New monads into a darcs repo and onto hackage
19:28:24 <dons> so people can use them.
19:28:27 <fantasma> without access to gcc
19:28:30 <dons> i'd be prepared to work on this.
19:28:35 <jcreigh> fantasma: err, what?
19:28:35 <dons> Cale, any thoughts?
19:28:53 <jcreigh> fantasma: oh, it's installed, but your used doesn't have access to it?
19:28:58 <dons> fantasma: um?/ so not using gcc --version ?
19:29:00 <dons> scary
19:29:08 <fantasma> yeah ;(
19:29:26 <fantasma> no access to /usr/bin
19:29:38 <fantasma> well, not gcc at least
19:29:41 <syntaxfree> sorear: is that a GA?
19:29:54 <sorear> dpkg -s gcc :)
19:29:58 <sorear> syntaxfree: yes :)
19:30:04 <fantasma> not on debian
19:30:10 <fantasma> i am on centos =\
19:30:34 <dons> Igloo, so we're pushing forward with the build slave stuff?
19:30:45 <dons> igloo, I could probably swing the use of the 16 core box as a build slave overight
19:30:49 <dons> overnight/ or weekly
19:30:51 <syntaxfree> sorear: yay.
19:30:56 <Cale> dons: yeah, that would be good.
19:31:24 <dons> Cale, is the src of all that's good only on the wiki now?
19:32:20 <Cale> Pretty much. There was another approach to the MonadRandom stuff on the mailing lists a while back, but the code that's on the wiki is fine, I think.
19:33:19 <allbery_b> rpm -q gcc
19:33:26 <allbery_b> (fantasma)
19:33:31 <dons> ok. Monadrandom and there's a few other monads up there too?
19:34:03 <fantasma> allbery_b, godly, thanks!
19:34:47 <ndm> dons: how come you are't a Yhc build slave?
19:34:48 <yip> man this shit is turning out to be much more difficult than i had expected :\
19:34:49 <Cale> yeah
19:35:15 <ndm> dons: if you did that you could just get nobench to copy over the prebuilt binaries, and they'd always be up to date, and if the code stops compiling we'll remotely debug it
19:35:29 <Cale> MonadSupply, MonadUndo, MonadNondet.
19:35:30 <ndm> dons: plus it will take 1/16th of your CPU power for under 10 mins ;)
19:35:43 <Cale> There's MonadUnique, I'm not sure if that's worth much time. :)
19:35:51 <monochrom> Monad.Net
19:35:54 <Cale> (it's more intended as an example)
19:36:02 <dons> ndm, ah yes. i meant to get back to looking at that.
19:36:08 <dons> thanks for reminding me, ndm
19:36:10 <Cale> Then there's a bunch of stuff there which I didn't write.
19:36:19 <dons> ok
19:36:21 <Cale> (I didn't write Nondet, but I use it a lot)
19:36:54 <dons> oh. if you use it a lot it really should be in a cabalised library then
19:37:06 <dons> since we tend not to allow:   import Wiki.NonDet
19:37:07 <dons> syntax
19:37:19 <ndm> for bibtex is the "Bell System Technical Journal" a journal or a techreport?
19:37:41 <fantasma> does someone want to do me a favor compile something for me?
19:38:44 <sorear> platform, program?
19:38:44 * fantasma isn't getting his hopes up
19:38:58 <ndm> fantasma: if you can't, what makes you think we can?
19:39:01 <fantasma> sorear, i686, its plan9port (very small)
19:39:25 <allbery_b> he said earlier he can't get to gcc
19:39:55 <allbery_b> however it occurs to me that if gcc is off limite to him that suggests whoever admins his machine doesn't want random stuff built
19:40:17 <Cale> Hmm, 60 seeds, 4011 peers. :)
19:40:22 <dancor> download gcc?
19:40:36 <fantasma> dancor, can't find binaries =\
19:40:43 <fantasma> Cale, what are you torrenting?
19:40:50 <dons> you can't just type   PATH=/usr/bin:$PATH  ?
19:40:56 <Cale> Latest episode of Heroes.
19:41:05 <sorear> fantasma: how much of it do you want?
19:41:07 <fantasma> Cale, you mean tomorrows?
19:41:12 <Cale> Indeed.
19:41:16 <fantasma> sorear, all of it (if possible)
19:41:26 <Cale> Today's, here.
19:41:27 <sorear>  awk, basename, bc, cat, cleanname, date, dc, echo, grep, mk, rc, sed, seq,
19:41:27 <sorear>  sleep, sort, tee, test, touch, tr, uniq, and yacc.
19:41:28 <fantasma> Cale, the was fast pre
19:41:31 <sorear> enough?
19:41:37 <fantasma> sorear, lol, yes
19:41:43 <Cale> It plays a day early in some parts of Canada.
19:41:43 * yip curses javascript
19:41:48 <SamB> sorear: funny
19:41:56 <SamB> most of those come with most Unix systems
19:42:04 <SamB> not mk and rc, certainly
19:42:12 <fantasma> I only really need mk and rc
19:42:14 <SamB> and I expect yacc is a bit different
19:42:36 <fantasma> but it will only take a minute to compile everything (I expect)
19:42:39 <sorear> fantasma: you have access to ar and tar?
19:42:45 <fantasma> sorear, yes, I do
19:42:47 <narain> yip: web development blues?
19:42:48 <sorear> http://ftp.us.debian.org/debian/pool/main/9/9base/9base_2-5_i386.deb
19:42:50 <lambdabot> http://tinyurl.com/yvydn3
19:42:56 <yip> narain: yeah
19:42:59 <greentea> Hi all.
19:43:03 <SamB> fantasma: thats an ar
19:43:18 <SamB> with a tarball in it
19:43:22 <allbery_b> debian and centos libs are unlikely to be compatible :/
19:43:26 <fantasma> hmmm did not know that
19:43:39 <SamB> allbery_b: what is centos?
19:43:40 <allbery_b> but if he can find an rpm, rpm2cpio will generate a cpio archive
19:43:53 <allbery_b> centor is more or less a free reimplementation of Red Hat Enterprise Linux
19:44:03 <allbery_b> minus the restricted/commercial bits
19:44:05 <SamB> allbery_b: as I said, that is an ar with a tarball in it
19:44:26 <allbery_b> suere.  do they use a compatible libc.so?
19:44:54 <sorear> allbery_b: define compatible.  i386 linux linking works using names, and the calling conventions are fixed.
19:45:22 <sorear> also, they're big on binary compatibility
19:45:23 <SamB> sorear: I think they actually broke binary compatability between libc5 and glibc
19:45:39 <sorear> who uses libc5?
19:45:44 <allbery_b> sure, but (a) libc5/glibc won't be an issue
19:45:45 <fantasma> hmm, the .deb had two tarballs "data" and "control"
19:45:52 <sorear> you want data
19:46:03 <allbery_b> but I've had diferent versions of glibc decide to be internally incompatible (see:  stat() problems)
19:46:06 <sorear> control contains all the funny metadata stuff dpkg like
19:46:07 <fantasma> i assume control is what dpkg uses?
19:46:10 <ndm> @spell optimisation
19:46:10 <lambdabot> optimization optimizations optimization's intimidation atomization
19:46:23 <allbery_b> you see a variant of that with the stat bug that's open in ghc
19:46:25 * ndm can never remember which is UK, which is US, and which I should be using!
19:46:34 <allbery_b> US has z
19:46:45 <sorear>  @spell should traceroute the user and use the correct spelling:)
19:47:20 <ndm> allbery_b: for bonus points, which does a UK person submitting to an international conference use?
19:47:26 <sorear> so, what do the [Australians, Indians, etc] use?
19:47:32 <allbery_b> from what I've seen they use their native idiom
19:47:33 <dancor> do i have to worry about weirdness using ByteString's in threaded apps
19:47:48 <sorear> no
19:47:56 <allbery_b> commonwealth countries all use the -s- spelling
19:47:56 <dancor> like will forkIO give me real threading
19:48:10 <sorear> yes, if you link with -threaded
19:48:21 <sorear> and run with +RTS -N<greaterthanone>
19:48:22 <greentea> sorear: using 'z' is semi-accepted, though.
19:48:46 <allbery_b> basically, international conferences are used to local differences, use your native pelling and they'll deal
19:48:54 <dancor> sorear: run with +RTS?
19:49:04 <sorear> dancor: yea
19:49:07 <fantasma> wow sorear thank you so much
19:49:20 <triplah_w> sorear: "s" in aus
19:49:20 <ndm> my native spelling is defined by the spell checker :)
19:49:28 <dancor> sorear: like ./MyBinary +RTS  ???
19:49:38 <sorear> ./MyBinary +RTS -N2
19:49:49 <sorear> where 2 is the number of processors you want to use
19:49:53 <dancor> so my app can't actually take +RTS as an arg?
19:50:05 <sorear> to a first approximation yes
19:50:05 <dancor> doesn't that make it impossible to write ghc in haskell for example..
19:50:13 <sorear> dancor: ?
19:50:14 <monochrom> There is a way to get +RTS to your getArgs
19:50:22 <bd_> dancor: The RTS is written in C ... :)
19:50:22 <allbery_b> ghc doesn't take +RTS, the runtime takes it.  even in ghc
19:50:29 <dancor> sorear: unescapery + meta = death
19:50:31 <bd_> Well, C and Cmm
19:50:35 <allbery_b> but if you pass --RTS then the RTS passes everything else on, including +RTS and --RT
19:50:39 <allbery_b> er, --RTS
19:50:39 <dons> +RTS ... -RTS -- magic flags to the runtime
19:51:35 <dancor> hm that seems very worng to me
19:51:55 <jcreigh> so does GHC generally compile to C first then use gcc to finish the job? (I know it can do both: What's the default?)
19:52:01 <allbery_b> it's odd, but given --RTS it's acceptable IMO
19:52:27 <sorear> dancor: ghc is written in haskell!
19:52:34 <sorear> bah.
19:52:37 <sorear> lag
19:53:08 <sorear> jcreigh: the default is direct native code generation
19:53:29 <sorear> jcreigh: if you have an ancient (pre-6.7) ghc, -O implies -fvia-C
19:53:46 <jcreigh> 6.6 is "ancient"?
19:53:52 * sorear thinks so
19:54:28 <sorear> it's missing tons of bugs and a few features
19:54:37 <dancor> missing bugs
19:54:47 <dons> 6.6 is the stable branch
19:54:55 <dons> its good for real use.
19:56:48 <yip> except for the bugs
19:56:51 <allbery_b> ghci 6.7 has a debugger.  need any more be said?
19:57:38 <jcreigh> allbery_b: oh, you can single step through type inference to see where the error is? :)
19:58:02 <allbery_b> heh.  don't think so although you're welcome to suggest it to the simons :)
19:59:34 <dancor> when is 6.8 coming out, or is haskell' next
20:00:03 <allbery_b> I think H' and ghc are disjoint
20:00:11 <jcreigh> but seriously, a debugger sounds cool. I can't quite picture how you'd present the (nearly) endless repeating unwrapping of thunks in any reasonable manner...
20:00:18 <allbery_b> (except insofar as much of H' simply ratifies ghc...)
20:04:25 <sorear> > let evolve f st = (let pool = take 50 $ sortBy (comparing f) st in replicateM 100 (do a <- State (randomR (0,49)) ; b <- State (randomR (0,49)) ; return (((pool!!a) + (pool!!b))/2))) ; minimize f = do { gn <- replicateM 100 (State random) ; foldM (flip . const $ evolve f) gn [1..100] ; return (minimumBy (comparing f) gn) } in evalState (minimize (\x -> (x - cos x) ^ 2)) (mkStdGen 42)
20:04:27 <lambdabot>  0.7680036230636769
20:04:31 <sorear> > let evolve f st = (let pool = take 50 $ sortBy (comparing f) st in replicateM 100 (do a <- State (randomR (0,49)) ; b <- State (randomR (0,49)) ; return (((pool!!a) + (pool!!b))/2))) ; minimize f = do { gn <- replicateM 100 (State random) ; foldM (flip . const $ evolve f) gn [1..100] ; return (maximumBy (comparing f) gn) } in evalState (minimize (\x -> (x - cos x) ^ 2)) (mkStdGen 42)
20:04:32 <lambdabot>  1.111927198039353e-2
20:06:02 <sorear> > let evolve f st = (fmap (sortBy (comparing f)) $ replicateM 100 (do a <- State (randomR (0,49)) ; b <- State (randomR (0,49)) ; return (((st!!a) + (st!!b))/2))) ; minimize f = do { gn <- replicateM 100 (State random) ; foldM (flip . const $ evolve f) gn [1..100] ; return (maximumBy (comparing f) gn) } in evalState (minimize (\x -> (x - cos x) ^ 2)) (mkStdGen 42)
20:06:07 <lambdabot>  1.111927198039353e-2
20:06:25 <sorear> > let evolve f st = (fmap (sortBy (comparing f)) $ replicateM 100 (do a <- State (randomR (0,49)) ; b <- State (randomR (0,49)) ; return (((st!!a) + (st!!b))/2))) ; minimize f = do { gn <- replicateM 100 (State random) ; foldM (flip . const $ evolve f) gn [1..100] ; return (gn!!0, gn!!99) } in evalState (minimize (\x -> (x - cos x) ^ 2)) (mkStdGen 42)
20:06:27 <lambdabot>  (0.11040701265689151,0.8744269547458801)
20:06:29 <dancor> does something like     Data.ByteString.hGet >>= Data.Binary.decode :: Int   magically block just until enough data to make an int has come in?
20:06:45 <sorear> > let evolve f st = (fmap (sortBy (comparing f)) $ replicateM 100 (do a <- State (randomR (0,49)) ; b <- State (randomR (0,49)) ; return (((st!!a) + (st!!b))/2))) ; minimize f = do { gn <- replicateM 100 (State random) ; foldM (flip . const $ evolve f) gn [1..30] ; return (gn!!0, gn!!99) } in evalState (minimize (\x -> (x - cos x) ^ 2)) (mkStdGen 42)
20:06:47 <lambdabot>  (0.11040701265689151,0.8744269547458801)
20:06:48 <sorear> dancor: no
20:07:17 <dancor> sorear: what is the best way to achieve that
20:07:40 <sorear> actually...
20:07:51 <sorear> dancor: what kind of handle are you using? socket? file?
20:08:02 <dancor> socket
20:08:09 <sorear> it should work then
20:08:40 <sorear> it does large block reads, but in the case of sockets the reads always return when data is recieved
20:08:47 <chessguy> hi haskellers
20:08:57 <chessguy> sorear, what's this evolve function you're writing?
20:09:00 <sorear> files OTOH will probably block until the whole block is read
20:09:01 <jcreigh> hi chessguy
20:09:11 <dancor> sorear: what if you wanted it to work with any Handle
20:09:48 <sorear> dancor: then you'd have to fudge it to read 4 bytes at a time rather than 16384
20:10:10 <sorear> dancor: but files etc don't block indefinitely unless your drive has crashed
20:10:14 <dancor> sorear: ok, so even with files it would still work, just waiting on the normal file read
20:10:20 <sorear> yeah
20:10:28 <dancor> sorear: and if an integer spanned two blocks
20:10:39 <dancor> sorear: it would do the second one without death?
20:11:34 <sorear> dancor: then the Binary code would immediately try to access the next chunk in the lazy bytestring, thus causing more of the hGet to be evaluated, thus reading another block of data.  laziness++
20:11:42 <dancor> yay
20:11:52 <dancor> it's delicious
20:12:10 <narain> i remember seeing a new prelude-like module people had written and/or were discussing, and i can't find it now
20:12:24 <sorear> @wiki The_other_prelude
20:12:25 <lambdabot> http://www.haskell.org/haskellwiki/The_other_prelude
20:12:25 <sorear> ?
20:12:44 <narain> that sounds about right but that's an empty page
20:13:16 <sorear> narain: nah, it's a nonexistant page.  mediawiki and lambdabot are very fragile in connection :(
20:13:28 <narain> @wiki The_Other_Prelude
20:13:28 <lambdabot> http://www.haskell.org/haskellwiki/The_Other_Prelude
20:13:35 <narain> found it
20:13:39 <narain> :) thanks sorear
20:13:40 <dancor> lb should lazily block until the page is written :)
20:13:53 <chessguy> sorear?
20:14:14 <sorear> a genetic algorithm based minimizer.
20:14:21 <sorear> obviously a very bad one
20:14:25 <chessguy> for minimizing what?
20:14:38 <sorear> since from generation 30 to 100, the estimate got WORSE
20:14:49 <sorear> (x - cos x) ^ 2, but that's just a sample
20:16:07 <chessguy> sorear, for any particular purpose?
20:17:11 <sorear> <SamB> what is cool is when your one-liners are actually not that much different
20:17:11 <sorear>        from code that works nicely in apps
20:17:11 <sorear> <cge> Does anyone know of any library implementing non-linear least squares
20:17:11 <sorear>       fitting?                                                            [19:13]
20:17:36 <sorear> the juxtaposition was irresistable
20:17:48 <chessguy> ah
20:17:57 <Balakirev> You mean, a matrix library? ^^
20:18:14 <SamB> sorear: I don't think that counts as a one liner
20:18:28 <dancor> one-blocker
20:18:37 <sorear> SamB: one line is 510 characters here :)
20:18:54 <sorear> my 600 char thm prover doesn't count
20:18:57 <SamB> sorear: I thought you said you didn't have a screen
20:19:09 <cge> Balakirev: I know that the GSL can do it, so the GSL bindings might be able to.
20:20:07 <emk> sigfpe++: His post on quantum monads is up! http://programming.reddit.com/goto?id=17x6t
20:20:09 <lambdabot> Title: Monads, Vector Spaces and Quantum Mechanics pt. II  A Neighbourhood of Infinity
20:20:17 <sorear> SamB: linux fbcon, 128ch wide.  but IRC specifies 510 char lines.
20:20:32 <LoganCapaldo> sigfpe is crazy
20:20:45 <SamB> sorear: cheater
20:20:49 <fantasmaa> you know how at the top of CGI scripts you put #!path_to_executable
20:20:57 <chessguy> emk, yeah, looked like good stuff. not that i comprehended it beyond about line 4
20:21:02 <SamB> fantasmaa: yes?
20:21:17 <LoganCapaldo> every blog post is like "How can I relate X to monads? Aha! <long insightful article that I barely understand follows>"
20:21:19 <fantasmaa> can you put arguements after it?
20:21:34 <SamB> you may put *one* argument after it
20:21:35 <dancor> LoganCapaldo: he's just in a (Crazy, Sane) mixed quantum state, you observed him unluckily
20:21:37 <jcreigh> fantasmaa: kind of. everything you put after the executable will end up as argv[1]
20:21:41 <SamB> you *might* be allowed two
20:21:59 <fantasmaa> what if i put it in quotes
20:22:01 <emk> chessguy: I found this very helpful: http://www.scottaaronson.com/democritus/lec9.html
20:22:01 <cge> dancor: But do the Crazy and Sane operators commute?
20:22:02 <lambdabot> Title: PHYS771 Lecture 9: Quantum
20:22:03 <chessguy> dancor, you gotta admit, implementing monads in C is nuts
20:22:09 <cge> dancor: Otherwise he's completely out of luck
20:22:14 <jcreigh> fantasmaa: no, that won't work, the shell doesn't touch that.
20:22:21 <chessguy> emk, i'll check it out, thanks
20:22:42 <fantasmaa> jcreigh, can I make some kind of link that includes the argument and the original executable?
20:22:48 <sorear> fantasmaa: you want somethink like
20:22:55 <emk> Basically, the quantum bits are just a slightly generalized notion of probability.
20:22:58 <fantasmaa> i tried using an alian but that didnt work
20:23:03 <fantasmaa> alias*
20:23:22 <sorear> #! /bin/sh
20:23:22 <sorear> exec runghc "$0"
20:23:22 <sorear> \begin{code}
20:23:22 <sorear> ...
20:23:32 <fantasmaa> yah
20:23:58 <fantasmaa> but I need an argument after #! /bin/executable -m blah
20:24:08 <fantasmaa> like that
20:24:19 <SamB> fantasmaa: on Linux you can use an interpreter that is a script, I'm pretty sure...
20:24:48 <fantasmaa> SamB, ah, that would work
20:24:56 <sorear> I seem to recall reading the opposite in the kernel source.
20:24:56 <cge> Hmm... that post has some problems.  It is certainly not the case that the states need to be normalized
20:25:04 <fantasmaa> SamB, would input be figured out automatically?
20:25:41 <SamB> fantasmaa: what are you actually doing though?
20:26:12 <fantasmaa> SamB, i have a script that runs with /bin/rc but I need it to run with /bin/rc -m blah
20:26:15 <sorear> SamB: I just tested it.  ENOEXEC
20:26:36 <SamB> sorear: hmm.
20:26:48 <sorear> actually -ENOEXEC :)
20:26:52 <SamB> fantasmaa: try -mblah?
20:27:03 <fantasmaa> what?
20:27:04 <fantasmaa> lol
20:27:12 <fantasmaa> you mean without a space?
20:27:39 <SamB> yeas
20:27:40 <SamB> er.
20:27:41 <SamB> yes.
20:27:54 * SamB doesn't see any -m flag in his rc(1) manpage
20:27:58 <SamB> damn clones
20:28:14 <fantasmaa> well for mine it's to specify a different location for rcmain
20:29:07 <SamB> well, mine is, as I've implied, only a clone
20:29:12 <SamB> you are using an authentic port
20:30:11 <fantasmaa> no space doesnt work
20:31:42 <fantasmaa> i will try the script method
20:32:00 <narain> sigfpe's curly quotes look asymmetrical
20:32:10 <SamB> hey, you could do #!/bin/sh foo.sh
20:33:17 <fantasmaa> will try that
20:34:58 <fantasmaa> did not work
20:36:18 <SamB> oh, duh.
20:36:20 * SamB silly
20:36:47 <SamB> I haven't really got any idea how you can do this without having about you a GCC targetting i386 or i686 or whatever
20:37:12 <sorear> who needs C :)
20:37:18 <fantasmaa> well maybe I can fix the error itself
20:37:45 <fantasmaa> /usr/lib/9base/etc/rcmain: rc (/home/dl/etc/plan9/bin/rc): .: can't open: No such file or directory
20:37:54 <triplah_w> anyone know of bindings to use python libs in hs?
20:38:09 <fantasmaa> it wants rcmain but rcmain is located ../etc/rcmain (relative to rc)
20:38:21 <SamB> fantasmaa: does it search based on an env var?
20:38:38 <fantasmaa> SamB, not sure, I'm looking through the source now and I cant find anything
20:39:03 <sorear> fantasmaa: what do you want execed?
20:39:18 <SamB> doesn't it have a beautifully manicured manpage?
20:39:35 <fantasmaa> sorear, a script named show.rc
20:41:20 <fantasmaa> I have a question: if there is a script and it looks for executable 'abc' does it check in the script's own directory first before going to $path?
20:41:21 <sorear> fantasmaa: where is it? and will it hurt if it gets an empty environment?
20:42:04 <LoganCapaldo> it shouldn't, unless $path containes .
20:42:18 <fantasmaa> I see
20:44:02 <fantasmaa> great, I can't even set $PATH
20:44:10 <fantasmaa> ...stupid webhost
20:44:30 <SamB> ???
20:44:36 <LoganCapaldo> Your web host is running plan 9?
20:44:43 * LoganCapaldo boggles
20:44:48 <fantasmaa> LoganCapaldo, no, I installed it thanks to sorear
20:44:57 <LoganCapaldo> oh
20:45:01 <LoganCapaldo> heh
20:45:16 <SamB> just rc(1) and mk(1) from plan9 ports
20:45:23 <SamB> not the OS or anything
20:45:41 <fantasmaa> yah lol
20:46:40 * LoganCapaldo kind of wishes he had a reason to boggle
20:46:42 <sorear> fantasmaa: what is the name of the shell script bouncer you want to run?  I need a full pathname.
20:46:50 <sorear> NOT the rc script
20:47:15 <fantasmaa> sorear, /home/dl/etc/foo.sh
20:47:31 <SamB> sorear: you could just use the second argument for that purpose...
20:48:10 <LoganCapaldo> @rc /home/dl/etc/foo.sh
20:48:10 <lambdabot> Not enough privileges
20:48:20 <LoganCapaldo> LOL
20:48:28 <LoganCapaldo> well now I guess we know why
20:48:31 <SamB> hehehe
20:48:53 <LoganCapaldo> @help rc
20:48:53 <lambdabot> rc name. Read a file of commands (asynchonously). FIXME: better name.
20:49:24 <fantasmaa> haha..better name
20:50:54 <fantasmaa> i think there is a way to solve my problem using bind
20:51:04 <LoganCapaldo> @rc cola
20:51:05 <lambdabot> Not enough privileges
20:52:07 <sjanssen> LoganCapaldo: you need to put a quarter into the machine first
20:52:44 <LoganCapaldo> ah thanks
20:53:22 <LoganCapaldo> wait
20:53:27 <LoganCapaldo> only a quater?
20:53:34 <LoganCapaldo> *quarter?
20:54:07 <LoganCapaldo> where are these mystical vending machines you have access to sjanssen?
20:55:10 <sjanssen> :)
20:55:11 <fantasmaa> sorear, you trying something out?
20:55:34 <dons> http://www.davidb.org/darcs/harchive/
20:55:46 <dons> data backup client/server in haskell
20:56:04 <sjanssen> dons: 404
20:56:18 <LoganCapaldo> the system is down
20:56:36 <LoganCapaldo> does not bold well for its powers of backupery
20:56:45 <LoganCapaldo> s/bold/bode/
20:56:48 <dons> bah, the author said something about "behind a very small network connection"
20:56:53 <dons> "The connection isn't all that fast, so if it gets too busy, I'll move
20:56:53 <dons> it somewhere else.
20:56:53 <dons> "
20:56:59 <dons> maybe that's what happened
20:57:45 <sorear> fantasmaa: yea
20:58:23 <fantasmaa> sorear, thanks for spending your time helping me =\
20:58:40 <triplah_w> soo, what interfaces does HS have to the outside worl?
20:58:47 <triplah_w> d*
20:58:58 <triplah_w> as in, bindings to other languages?
20:59:08 <LoganCapaldo> Haskell doesn't have interfaces to the outside world
20:59:18 <LoganCapaldo> it carries the world around inside it :
20:59:20 <triplah_w> got some python libs i'd like to use with it
20:59:22 <LoganCapaldo> :)
20:59:22 <triplah_w> haha
20:59:24 <triplah_w> :P
20:59:34 <sjanssen> triplah_w: Haskell's C interface is pretty nice
20:59:38 <sjanssen> @where missingpy
20:59:39 <lambdabot> http://quux.org:70/devel/missingpy
20:59:48 <sjanssen> triplah_w: you should check that out
20:59:51 <dons> triplah_w: ah, you want the FFI or the python FFI?
20:59:53 <triplah_w> sjanssen: great thanks
20:59:54 <sorear> from /bin/echo --version: Written by FIXME unknown.
21:00:01 <triplah_w> dons: FFI?
21:00:06 <triplah_w> dons: oh right
21:00:07 <dons> foreign function interface
21:00:07 <triplah_w> yeah the HS one
21:00:48 <triplah_w> i have written some python stuff that i'd like to use in hs
21:00:56 <triplah_w> i could reimpl, but that'd have to be in my own time
21:01:12 <triplah_w> i know i cant justify that to the company i work for just yet
21:01:53 <dons> you may as well just call the python stuff directly then
21:02:20 <triplah_w> missingpy looks like what i want
21:02:59 <triplah_w> Low-level interface to Python for extending your own Haskell code
21:03:13 <triplah_w> im guessing it embeds the python interpreter
21:04:14 <dons> yeah, you can double check with John later, he's usually around
21:04:44 <sorear> fantasmaa:
21:04:44 <sorear> /bin/echo -e '\0177\0105\0114\0106\0001\0001\0001\0000\0000\0000\0000\0000\0000\0000\0000\0000\0002\0000\0003\0000\0001\0000\0000\0000\0124\0020\0000\0000\0064\0000\0000\0000\0000\0000\0000\0000\0000\0000\0000\0000\0064\0000\0040\0000\0001\0000\0000\0000\0000\0000\0000\0000\0001\0000\0000\0000\0000' > filename
21:04:44 <sorear> /bin/echo -e '\0000\0000\0000\0000\0020\0000\0000\0000\0020\0000\0000\0232\0000\0000\0000\0232\0000\0001\0000\0007\0000\0000\0000\0000\0020\0000\0000\0131\0111\0211\0346\0255\0277\0232\0020\0000\0000\0363\0245\0255\0211\0364\0211\0342\0271\0222\0020\0000\0000\0273\0166\0020\0000\0000\0270\0013\0000' >> filename
21:04:45 <sorear> /bin/echo -e '\0000\0000\0315\0200\0057\0142\0151\0156\0057\0163\0150\0000\0057\0150\0157\0155\0145\0057\0144\0154\0057\0145\0164\0143\0057\0146\0157\0157\0056\0163\0150\0000\0166\0020\0000\0000\0176\0020\0000\0000' >> filename
21:04:48 <sorear> chmod +x filename # asm coding ++
21:05:04 <LoganCapaldo> yow
21:05:16 <fantasmaa> hmm
21:05:21 <LoganCapaldo> mmmmmmmpressive
21:05:22 <sorear> ./filename foo bar  -->  /bin/sh /home/dl/etc/foo.sh foo bar
21:05:46 <fantasmaa> are all of those numbers ascii values?
21:05:48 <dons> hehe
21:06:02 <fantasmaa> i am scared
21:06:19 <sorear> no, most are 0
21:06:38 <fantasmaa> but some are ascii values?
21:06:47 <sorear> yeah
21:07:10 <hpaste>  sorear pasted "what's in that file" at http://hpaste.org/800
21:07:53 <fantasmaa> sorear, what did you use to compile it?
21:08:25 <sorear> stefan@stefans:/tmp$ nasm -f bin -l baz.lst baz.asm ; chmod +x baz
21:08:40 <narain> bah sorear, i was just going to try to map (chr . read) on it
21:08:45 <sorear> then od -b and M-x replace-string
21:09:11 <narain> though that wouldnt have worked very well :)
21:10:09 <allbery_b> woo, latest ghc6.7 is passing its testsuite nicely :)
21:15:45 <dons> http://www.davidb.org/darcs/harchive/
21:15:46 <lambdabot> Title: Index of /darcs/harchive/
21:15:47 <dons> all good now
21:19:02 <sorear> 154 --> 136 bytes
21:19:43 <allbery_b> it's funny, I actually started to work on such a thing (but for freebsd and osx) and concluded I'd be happier with something I could reliably run from a boot cd
21:20:06 <dons> what are the problems with a boot cd?
21:20:10 <allbery_b> so dump on fbsd, and superduper (which creates bootable fw drives I can restore from) on osx
21:20:43 <allbery_b> manly having to add an executable and any support foo to it and hoping the result still fits
21:21:21 <allbery_b> I'm still not sure what I'd need to carry around to run a gthc binary tandalone (libgmp.so?)
21:21:51 <allbery_b> (or .dylib on osx)
21:22:28 <dons> you'd just statically link the executable
21:22:30 <dons> and then strip it
21:22:36 <dons> ghc -O --make -static Foo.hs
21:22:38 <dons> strip Foo
21:23:07 <dons> like the freespire haskell pkg tools
21:26:22 <allbery_b> *shrug* in any case I have backup foo now.  I may still poke at that, if only to see what it would take to make it work on freebsd (which I think alo has uuids somewhere)
21:34:02 <zbrown> do I need to import anything to use 'sort'?
21:34:37 <sorear> no
21:34:41 <zbrown> hrm
21:34:47 <sorear> sortBy needs Data.List
21:34:55 <sorear> > Prelude.sort [1,2]
21:34:55 <lambdabot>   Not in scope: `Prelude.sort'
21:35:07 <nmessenger> @index sort
21:35:08 <lambdabot> Data.List
21:35:09 <sorear> ok, regular sort needs [Data.]List too
21:35:12 <nmessenger> oopsies
21:35:16 <zbrown> ook :)
21:35:46 <LoganCapaldo> @index lookup
21:35:46 <lambdabot> Data.HashTable, Data.IntMap, Data.Map, Data.List, Prelude
21:35:57 <zbrown> hrm
21:36:17 <LoganCapaldo> @type Prelude.lookup
21:36:19 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
21:36:59 <LoganCapaldo> @type Data.List.lookup
21:37:02 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
21:37:37 <LoganCapaldo> 1) why? and 2) why not sort as well?
21:38:44 <LoganCapaldo> Is it because sort needs Ord? Is that it? Some Haskell prejudice against Ord but not Eq?
21:43:10 <allbery_b> I suspect just because they decided they had too much namespace pollution in Prelude as it was
21:43:40 <allbery_b> consider the things LB trips over because they're in both Prelude and e.g. Control.Monad
21:46:20 <LoganCapaldo> so lookup got in before the "this namespace pollution is ridiculous" and sort afterwards?
21:47:10 <LoganCapaldo> > lookup "a" [("a",1), ("b",2)]
21:47:12 <lambdabot>  Just 1
21:47:48 <narain> > lookup "a" [("a",1),("a",2)]
21:47:49 <lambdabot>  Just 1
21:48:34 <zbrown> > lookup "a" [("a","a",1),("b","a",2)]
21:48:35 <lambdabot>  Couldn't match expected type `([Char], b)'
21:48:37 <LoganCapaldo> > Data.List.lookup [("a",1), ("b",2)]
21:48:38 <lambdabot>  Add a type signature
21:49:07 <LoganCapaldo> > Data.List.lookup "a" [("a",1), ("b",2)]
21:49:09 <lambdabot>  Just 1
21:49:26 <zbrown> > Data.List.lookup "a" [("a",1), ("a",2)]
21:49:28 <lambdabot>  Just 1
21:49:30 <zbrown> interesting
21:49:47 <LoganCapaldo> interesting? not really :)
21:50:03 <LoganCapaldo> it just grabs the first one it finds
21:50:06 <zbrown> hrm
21:50:18 <zbrown> so why's it say 'just 1' instead of just saying '1'
21:50:18 <zbrown> ?
21:50:32 <narain> > lookup "a" [("b",2)]
21:50:34 <lambdabot>  Nothing
21:50:35 <narain> that's why
21:50:43 <LoganCapaldo> > lookup "a" [("b",1), ("c",2)]
21:50:44 <lambdabot>  Nothing
21:50:53 <LoganCapaldo> @src Maybe
21:50:53 <lambdabot> data Maybe a = Nothing | Just a
21:50:58 <zbrown> hrm
21:51:01 <narain> i'm tempted to do @quote stereo again
21:51:37 <nmessenger> case lookup foo blah of { Nothing -> handleNotFound; Just x -> doSomethingWith x }
21:51:46 <LoganCapaldo> Maybe is (one way of) modelling computations that might fail
21:52:00 <zbrown> How would I apply two diff conditions to a list of tuples thats growing: ie - (0,0) is in set S, if (a,b) is in set S then (a+2,b+3) is in set S and (a+3,b+2) is in set S
21:52:05 <LoganCapaldo> So "a", might not be in the list
21:52:58 <kolmodin> ?seen yip
21:52:59 <lambdabot> I saw yip leaving #haskell 1h 52m 21s ago, and .
21:53:16 <narain> ", and ." ??
21:53:41 <allbery_b> longstanding somehting-or-other
21:53:49 <kolmodin> and that's that, perhaps. 'nuff said
21:54:52 <zbrown> Is there a function to remove duplicates in a list
21:54:52 <zbrown> ?
21:55:01 <narain> zbrown: nub
21:55:14 <zbrown> thanks
21:55:16 <narain> > nub [1,2,1,5,3,2,4,3]
21:55:17 <lambdabot>  [1,2,5,3,4]
21:55:19 <LoganCapaldo> > let s = (0,0) : [ (a+2, b+3) | (a, b) <- s ] in s
21:55:20 <lambdabot>  [(0,0),(2,3),(4,6),(6,9),(8,12),(10,15),(12,18),(14,21),(16,24),(18,27),(20,...
21:55:48 <zbrown> LoganCapaldo: and then i need a+3, b+2
21:56:02 <LoganCapaldo> So add them
21:56:10 <zbrown> not to mention a+3,b+2 applied to list 1, and a+2,b+3 applied to list 2
21:56:11 <zbrown> hmmm
21:56:14 <zbrown> lets see
21:57:24 <narain> zbrown: interesting problem that should have an impressively elegant haskell solution, only i don't know what it is
21:57:35 <zbrown> narain: ya im trying to find an elegant solution
21:59:07 <narain> > let s = (0,0) : concatMap (\(a,b) -> [(a+2,b+3),(a+3,(b+2)]) s in s
21:59:08 <lambdabot>  Parse error
21:59:19 <narain> > let s = (0,0) : concatMap (\(a,b) -> [(a+2,b+3),(a+3,b+2)]) s in s
21:59:21 <lambdabot>  [(0,0),(2,3),(3,2),(4,6),(5,5),(5,5),(6,4),(6,9),(7,8),(7,8),(8,7),(7,8),(8,...
21:59:28 <zbrown> oooh
21:59:28 <narain> \o/
21:59:30 <zbrown> that is nice
21:59:38 <zbrown> now to remove duplicates and be on with my day :-D
21:59:42 <LoganCapaldo> > let s1 = (0,0) : [ (a+2, b+3) | (a, b) <- s ]; s2 = (0,0) : [ (a+3, b+2) | (a, b) <- s2 ] in merge s1 s2 where merge xs [] = xs; merge [] xs = xs; merge (x:xs) (y:ys) = if x < y then x:(merge xs (y:ys)) else y:(merge (x:xs) ys)
21:59:42 <lambdabot>  Parse error
21:59:44 <zbrown> thanks narain
21:59:53 <narain> no problem that was fun
22:00:28 <zbrown> narain: its discrete math hw, but i refuse to write out 5 iterations of the problem, so i instead turn in programs and output from those programs
22:00:28 <dons> HWN is out, http://sequence.complete.org/hwn/20070305
22:00:30 <lambdabot> Title: Haskell Weekly News: March 05, 2007 | The Haskell Sequence
22:00:41 <zbrown> narain: been trying to get that one working for a bit
22:00:59 <narain> im also learning haskell so it's fun for me to try writing these little programs
22:01:08 <narain> but i didn't plan on doing your homework for you :p
22:01:23 <LoganCapaldo> > let s1 = (0,0) : [ (a+2, b+3) | (a, b) <- s ]; s2 = (0,0) : [ (a+3, b+2) | (a, b) <- s2 ] ; merge xs [] = xs; merge [] xs = xs; merge (x:xs) (y:ys) = if x < y then x:(merge xs (y:ys)) else y:(merge (x:xs) ys) in merge s1 s2
22:01:24 <lambdabot>   Not in scope: `s'
22:01:48 <LoganCapaldo> > let s1 = (0,0) : [ (a+2, b+3) | (a, b) <- s1 ]; s2 = (0,0) : [ (a+3, b+2) | (a, b) <- s2 ] ; merge xs [] = xs; merge [] xs = xs; merge (x:xs) (y:ys) = if x < y then x:(merge xs (y:ys)) else y:(merge (x:xs) ys) in merge s1 s2
22:01:50 <lambdabot>  [(0,0),(0,0),(2,3),(3,2),(4,6),(6,4),(6,9),(8,12),(9,6),(10,15),(12,8),(12,1...
22:02:08 <sjanssen> dons++
22:02:18 <zbrown> LoganCapaldo: still missing some
22:02:20 <zbrown> but close
22:02:32 <LoganCapaldo> I know its missing some ;)
22:02:34 <narain> zbrown: by the way what was the exact homework problem that you're writing a program to get around?
22:02:48 <dons> and on reddi,t http://programming.reddit.com/info/17xoc/details
22:02:49 <lambdabot> Title: Haskell Weekly News: "Programming in Haskell", gtk2hs, XML, databases ... (reddi ...
22:02:50 <zbrown> narain: yup
22:02:56 <zbrown> narain: they wanted 5 iterations
22:03:05 <zbrown> i was too lazy to write 5 iterations out ;)
22:03:06 <LoganCapaldo> hint: you can make as many sequences as you want and merge them all
22:03:47 <narain> zbrown: but now how do you know when the 5th iteration ends? :)
22:04:19 <zbrown> narain: its the 15th
22:04:44 <zbrown> when you remove duplicates, the pattern is 1,3,6,10,15
22:05:24 <zbrown> 0+1 = 1, 1+2 = 3, 3+3 = 6, 6+4 = 10, 10+5 = 15
22:05:25 <zbrown> :)
22:05:42 <narain> aha yes
22:05:52 <narain> i realized it when i saw it
22:06:11 <LoganCapaldo> > let s1 = (0,0) : [ (a+2, b+3) | (a, b) <- s1 ]; s2 = (0,0) : [ (a+3, b+2) | (a, b) <- s2 ] ; merge xs [] = xs; merge [] xs = xs; merge (x:xs) (y:ys) = if x < y then x:(merge xs (y:ys)) else y:(merge (x:xs) ys) in map . head $ group merge s1 s2
22:06:12 <lambdabot>  Couldn't match expected type `[a]'
22:06:42 <LoganCapaldo> > let s1 = (0,0) : [ (a+2, b+3) | (a, b) <- s1 ]; s2 = (0,0) : [ (a+3, b+2) | (a, b) <- s2 ] ; merge xs [] = xs; merge [] xs = xs; merge (x:xs) (y:ys) = if x < y then x:(merge xs (y:ys)) else y:(merge (x:xs) ys) in map . head . group $ merge s1 s2
22:06:43 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
22:06:51 <narain> i love hwn's quotes of the week
22:06:54 <LoganCapaldo> @type group
22:06:56 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
22:07:03 <narain> "Cale: It ought to be called simonPerformIO, and only used if your first name is Simon"
22:07:23 <LoganCapaldo> > let s1 = (0,0) : [ (a+2, b+3) | (a, b) <- s1 ]; s2 = (0,0) : [ (a+3, b+2) | (a, b) <- s2 ] ; merge xs [] = xs; merge [] xs = xs; merge (x:xs) (y:ys) = if x < y then x:(merge xs (y:ys)) else y:(merge (x:xs) ys) in map head . group $ merge s1 s2
22:07:25 <lambdabot>  [(0,0),(2,3),(3,2),(4,6),(6,4),(6,9),(8,12),(9,6),(10,15),(12,8),(12,18),(14...
22:08:20 * LoganCapaldo has got to stop thinking of . as parens deleter
22:08:28 <narain> LoganCapaldo: i'm not sure your approach will cover (0,0) + (2,3) + (2,3) + (3,2) = (7,8)
22:08:54 <LoganCapaldo> So?
22:09:07 <narain> ...isn't that undesirable?
22:09:08 <LoganCapaldo> heh
22:09:15 <narain> heh
22:10:15 <LoganCapaldo> it'll get really long if I add those ;)
22:10:18 <triplah_w> http://www.cs.nott.ac.uk/~gmh/book.html , this book doesnt seem to have a section on monads?
22:10:20 <lambdabot> Title: Programming in Haskell
22:11:01 <dons> its for beginer programmers, so that's possible
22:11:05 <dons> comp1A people
22:11:34 --- mode: ChanServ set +o dons
22:11:40 --- topic: set to '["The Haskell programming language: we have teleportation devices!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
22:11:44 --- mode: ChanServ set -o dons
22:11:46 <triplah_w> dons: any good books for someone who can car and cadr , but is a bit rusty, and spends too much time in bed with imperative languages? :P
22:12:05 <sjanssen> triplah_w: it looks like Programming in Haskell introduces monads at some point
22:12:25 <triplah_w> sjanssen: it must given some of the topics there
22:12:27 <dons> hmm. we don't yet have an 'advanced haskell' book. the wikibook and various online tutes are a better bet for now.
22:12:37 <sjanssen> triplah_w: the "Functional parsing library" code sample has "instance Monad ..."
22:13:02 <bos> o'reilly is in a tizzy over the erlang book :-)
22:13:12 <dons> good tizzy or bad tizzy? :-)
22:13:13 <triplah_w> sjanssen: ahh yep, i see. thanks
22:13:30 <bos> we'll see.
22:14:01 <dons> "Parallel programming in Haskell (with transaction memory, mvars and parallel arrays)" would be nice
22:14:15 <bos> practical haskell, isagn.
22:14:16 <triplah_w> indeed
22:14:20 <dons> right.
22:14:33 <dons> practical haskell: from IO to SMP and back
22:14:50 <triplah_w> i've realised that linking to my python libs is futile, since i want to use forkIO for massive concurrency
22:14:57 <triplah_w> i might have to re impl my libs
22:15:00 <triplah_w> which are heavily OO
22:15:01 <triplah_w> :\
22:15:05 <bos> RealWorld# Haskell
22:15:28 <triplah_w> still, that'll be good learning :)
22:15:33 <triplah_w> and will run faster too
22:27:35 <glguy_> ?seen shapr
22:27:35 <lambdabot> I saw shapr leaving #ghc, #happs and #haskell 1d 6h 45m 4s ago, and .
22:27:58 <glguy_> !say alive?
22:28:04 <glguy_> !paste
22:28:04 <hpaste> Haskell paste bin: http://hpaste.org/
22:45:10 <JohnMeacham_> anyone have an implementation of downhill simplex in haskell?
22:50:23 <nornagon> @index Int16
22:50:23 <lambdabot> Data.Int, Foreign
22:58:34 <nornagon> @index RWS
22:58:34 <lambdabot> Control.Monad.RWS, Control.Monad.RWS
23:00:27 <nornagon> can someone give me a ten-second guide to using RWST? :)
23:02:39 <sjanssen> do you know how to use Reader, Writer and State?
23:02:58 <nornagon> I know how to use Reader, and I'm (very) peripherally aware of how to use the other two.
23:03:36 <LoganCapaldo> State is easy
23:03:46 <sjanssen> then the ten second guide is "RWST is each of those monads rolled into one" :)
23:03:56 * LoganCapaldo doesn't know how to use Reader or Writer
23:04:06 <nornagon> sjanssen: heh
23:04:18 <sjanssen> LoganCapaldo: Reader is even simpler than State
23:04:21 <nornagon> I'm still not properly up on my monad-fu, but I'm getting there (slowly.)
23:05:12 <LoganCapaldo> State w/o put?
23:05:20 <sjanssen> exactly
23:05:49 <nornagon> how does one use Writer?
23:06:10 <LoganCapaldo> So I guess writer is state without get, and is used for "logging" kinds of actions
23:06:12 <lispy> nornagon: it's like logging
23:06:16 <LoganCapaldo> ?
23:06:31 <sjanssen> LoganCapaldo: correct
23:06:37 <lispy> nornagon: i used it in a compiler (i can show you the code if you like) to emit assembly language instructions
23:06:52 <nornagon> lispy: sounds neat, but i'd be more after a really really dead simple example
23:06:58 <Cale> RWS has some strange properties with regard to long loops and memory.
23:07:07 <nornagon> without extra stuff as a barrier to understanding what i'm trying to understand
23:07:11 <lispy> Cale: what was the recent paper about monad transformers
23:07:15 <Cale> (at least, the way that it's implemented)
23:07:22 <Cale> hmm
23:07:25 <Cale> I don't know
23:07:33 <Cale> Recent?
23:07:39 <lispy> nornagon: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
23:07:40 <nornagon> Cale: oh? I'd be using it in the main loop of an SDL app, so I'd be interested to know if that's Bad
23:07:41 <lambdabot> Title: Monad Transformers Step by Step
23:07:48 <nornagon> lispy: cool, i'll peruse that
23:07:55 <lispy> nornagon: i highly recommend it :)
23:07:59 <nornagon> :)
23:08:10 <lispy> nornagon: it could be bad yeah
23:08:29 <lispy> nornagon: Writer can be very slow with some monoids when they get big (for example strings)
23:08:31 <Cale> nornagon: You can try it and see if it leaks space. If it does, talk to me, and I'll implement you something equivalent which is cheaper. I can't recall who else had this problem, possibly fasta.
23:08:33 <sjanssen> nornagon: are you sure that you need reading, writing and state?
23:09:34 <nornagon> sjanssen: The things I need to do are: store an SDL.Surface (which doesn't change). Read and write to and from a list [(Int16,Int16)]. That's all so far.
23:10:08 <Cale> Essentially, there's an issue whereby the transformers interact in a bad way, and the writer ends up building long chains of mempty `mappend` (...) which never get evaluated.
23:11:03 <Cale> It doesn't happen with plain writer, but I think it does if you state transform writer. I can't recall exactly.
23:11:06 <sjanssen> nornagon: sounds like you want a ReaderT Surface (StateT [(Int16, Int16)] m a) instead
23:12:04 <nornagon> sjanssen: Ah, okay then :)
23:12:17 <nornagon> thanks.
23:12:38 <nornagon> oh, it also needs to be in the IO monad -- i assume that means m == IO+
23:12:46 <nornagon> s/\+$/?/
23:12:58 <sjanssen> nornagon: correct
23:13:11 <narain> > iterate (\l -> [1] ++ zipWith (+) l (tail l) ++ [1]) [1]
23:13:13 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
23:13:22 <nornagon> narain: neat :)
23:13:37 <narain> nornagon: thanks :)
23:17:29 <narain> @pl iterate
23:17:30 <lambdabot> iterate
23:17:49 <narain> @src iterate
23:17:49 <lambdabot> iterate f x =  x : iterate f (f x)
23:18:49 <sjanssen> @unmtl ReaderT Display (StateT [(Int16, Int16)] IO) a
23:18:49 <narain> @pl \f x -> let iterate f x = x : iterate f (f x) in iterate f x
23:18:50 <lambdabot> Display -> [(Int16, Int16)] -> IO (a, [(Int16, Int16)])
23:18:50 <lambdabot> flip flip (fix (const . ap (:) . (`ap` join id))) . flip . flip id
23:19:50 <narain> @pl let iterate f x = x : iterate f (f x) in \f x -> iterate f x
23:19:50 <lambdabot> fix ((ap (:) .) . ((.) =<<))
23:20:19 <narain> @src fix
23:20:19 <lambdabot> fix f = let x = f x in x
23:22:16 <Cale> > fix ((0:) . scanl (+) 1)
23:22:17 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:22:32 <Cale> > ((0:) . scanl (+) 1) undefined
23:22:34 <lambdabot>  Undefined
23:22:37 <Cale> > take 1 $ ((0:) . scanl (+) 1) undefined
23:22:39 <lambdabot>  [0]
23:22:57 <Cale> > take 1 . ((0:) . scanl (+) 1) . ((0:) . scanl (+) 1) $ undefined
23:22:59 <lambdabot>  [0]
23:23:02 <Cale> > take 2 . ((0:) . scanl (+) 1) . ((0:) . scanl (+) 1) $ undefined
23:23:04 <lambdabot>  [0,1]
23:23:06 <Cale> > take 3 . ((0:) . scanl (+) 1) . ((0:) . scanl (+) 1) $ undefined
23:23:08 <lambdabot>  [0,1,1]
23:23:12 <Cale> right :)
23:23:21 <narain> fix bends my brain...
23:23:28 <Cale> > take 10 . iterate ((0:) . scanl (+) 1) !! 10  $ undefined
23:23:29 <lambdabot>      precedence parsing error
23:23:29 <lambdabot>         cannot mix `(.)' [infixr 9] and `(!!)' ...
23:23:35 <Cale> > take 10 . (iterate ((0:) . scanl (+) 1) !! 10) $ undefined
23:23:36 <lambdabot>  Couldn't match expected type `[a]'
23:23:49 <Cale> oh, right
23:23:57 <Cale> > take 10 . (iterate ((0:) . scanl (+) 1) undefined !! 10)
23:23:58 <lambdabot>  Couldn't match expected type `a -> [a1]'
23:24:12 <Cale> > take 10  (iterate ((0:) . scanl (+) 1) undefined !! 10)
23:24:14 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
23:24:26 <Cale> I'm obviously tired
23:24:31 <narain> > iterate ((0:) . scanl (+) 1)
23:24:33 <lambdabot>  <[Integer] -> [[Integer]]>
23:25:02 <narain> hmm
23:25:13 * narain feels clueless
23:25:19 <Cale> When applied to undefined, it produces a list of better and better approximations to fibs.
23:25:31 <dolio> > iterate ((0:) . scanl (+) 1) []
23:25:32 <Cale> :t iterate ((0:) . scanl (+) 1) undefined
23:25:34 <lambdabot>  [[],[0,1],[0,1,1,2],[0,1,1,2,3,5],[0,1,1,2,3,5,8,13],[0,1,1,2,3,5,8,13,21,34...
23:25:35 <lambdabot> forall a. (Num a) => [[a]]
23:25:46 <Cale> Or the empty list for that matter :)
23:26:05 <narain> > iterate ((0:) . scanl (+) 1) [42]
23:26:07 <lambdabot>  [[42],[0,1,43],[0,1,1,2,45],[0,1,1,2,3,5,50],[0,1,1,2,3,5,8,13,63],[0,1,1,2,...
23:26:15 <narain> haha
23:26:43 <narain> ah so your previous snippet using fix computed the fixed point of this
23:26:49 <narain> which is what it is tending towards
23:26:50 <Cale> right
23:27:06 <Cale> yeah
23:27:23 <narain> it still throws me how fix works
23:27:34 <narain> but i guess i need to grok lambda calculus for that
23:27:42 <Cale> Best thing for that is to evaluate some stuff by hand
23:27:54 <narain> good suggestion, i should try that
23:28:10 <Cale> Fix actually can't be defined in the lambda calculus way in Haskell, since none of the lambda fixed-point combinators will type.
23:28:35 <Cale> You can implement it using recursive types, but that's cheating :)
23:31:10 <narain> recursive types? guh, i would have been learning what those are if it weren't two in the morning over here ;)
23:31:27 <narain> *would have wanted to learn
23:31:41 <Cale> yeah 2am here too
23:32:16 <Cale> I'm torn between sleeping and waiting for this episode of Heroes to finish and then watching it.
23:33:11 <narain> you may not be able to enjoy it as much if you're half asleep when it's done
23:35:22 <sjanssen> Cale: you mean the episode of Heroes that doesn't even air in my region until Monday evening?
23:35:27 <Cale> right
23:35:29 <Cale> that one
23:35:57 <Cale> Episode 18
23:47:42 * mwc waits on Battlestar Galactica
23:47:55 <mwc> Cale, what time does the math dept at Mac start business?
23:48:11 <Cale> I don't know
23:48:24 <mwc> friggen 8:30 nazis at UWO :(
23:49:03 <mwc> Sometimes I wish I'd gone into astronomy, at least those get to come into work at noon.
23:49:07 <Cale> At Waterloo, profs are around at strange hours.
23:49:20 <mwc> Yeah, I've applied there for my MMath next year
23:49:35 <mwc> this is good to hear :)
23:49:55 <Cale> You can come to the math building in the middle of the night, and some of the office lights will still be on, and there will probably be students around, unless it's a weekend.
23:50:07 <mwc> I thought you were at Mac
23:50:17 <Cale> That was for some summer research
23:50:27 <mwc> M or Ph.D?
23:50:47 <Cale> It was just a job. I got my BMath from Waterloo.
23:51:35 <ski> dons : teleportation ?
23:52:04 <Cale> teleportation?
23:54:59 <nmessenger> ski, Cale: see quotes of the week: http://sequence.complete.org/hwn/20070305
23:55:00 <lambdabot> Title: Haskell Weekly News: March 05, 2007 | The Haskell Sequence
23:59:17 <Cale> haha: 'If you ever find yourself writing code like that, I want you to follow my Three Step Plan for Success: 1. Carefully and quietly, "Select All".   2. Delete.   3. Hope nobody was looking.'
