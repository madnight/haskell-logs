00:00:02 <acang> ivanm: sorry, I'm not a native speaker and occasionally I use the inopportune word
00:00:08 <wkh> "In our last paper, we show algorithm approximate NP-complete problem 'Travelling Salemen' Problem, show very good, fast."
00:01:06 <dons> wkh. hmm. not really appropriate.
00:01:07 <dons> be hepful
00:01:14 <dons> helpful. grr
00:01:17 <ivanm> acang: OK, just threw me for a bit
00:01:32 <ivanm> triplah_w: well, I plan on doing something to do with computational science
00:01:38 <dons> acang: one thing you can do is just dive in and write some sections.
00:01:43 <dons> so free free.
00:01:43 <kzm> Be hepful for make benefit glorious nation of Haskellistan?
00:01:44 <kzm> :-)
00:01:53 <dons> heh
00:01:57 <ivanm> dons: feel free you mean?
00:02:06 <dons> too tired.
00:02:16 <acang> dons: I've not enough experience for the advanced section
00:02:19 <ivanm> ?localtime dons
00:02:22 <lambdabot> Local time for dons is Wed Mar  7 18:59:57 2007
00:02:30 <ivanm> so how can you be that tired? ;0
00:02:36 <triplah_w> ivanm: ah ok, yeah my research is more into information sciences, but being a programmer means i'm going to code as much as possible in my masters :P
00:02:37 --- mode: ChanServ set +o dons
00:02:48 --- topic: set to '["The Haskell programming language: welcome to Haskellistan!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
00:02:52 --- mode: ChanServ set -o dons
00:02:58 <dons> too much hacking
00:03:03 <ivanm> triplah_w: yeah, that's one thing that's strange to me
00:03:04 <triplah_w> haskellitan ? i wonder if that name as been used yet
00:03:18 <triplah_w> haskelliton
00:03:18 <ivanm> I just did a summer project in maths, and I was one of the few people to do original work
00:03:20 <triplah_w> heh
00:03:30 <ivanm> just about everyone else just summarized books and papers ;)
00:03:35 <triplah_w> ivanm: well there are shades of originality
00:03:46 <ivanm> true
00:03:52 <triplah_w> ahh yeah, well in most postgrad you thesis = nothing if you dont do the appropriate research
00:03:53 <lispy> dons: do you have a link handy to the rules about SoC projects?
00:04:04 <dons> rules?
00:04:16 <dons> hmm. code.google.com/soc should have everything
00:04:17 <kzm> rule number one: don't talk about SoC.
00:04:23 <kzm> Oh, wait, that was something else.
00:04:26 <dons> right.
00:05:39 <lispy> dons: thanks
00:19:33 <wkh> @hoogle Name
00:19:33 <lambdabot> Language.Haskell.TH.Name :: data Name
00:19:34 <lambdabot> Language.Haskell.TH.Syntax.Name :: OccName -> NameFlavour -> Name
00:19:34 <lambdabot> Text.Html.name :: String -> HtmlAttr
00:20:26 <wkh> @hoogle gensym
00:20:27 <lambdabot> No matches found
00:31:37 <kc5tja> Provided my submission for the Programming performance study.
00:46:15 <kc5tja> bedtime.
01:02:28 <kzm> Hm.  Parsec thing: I want to parse some keyword: value pairs.  The problem is that the approach I used (manyTill ... (try keywords)) consumes the next keyword as well.  What's the canonical approach to this?
01:03:36 <kzm> (The 'value' part has little structure, so there's really no other way to terminate one item without checking for the next keyword)
01:04:58 <kzm> I guess I can build a (sorta) state machine, where each keyword-specific parser calls the correct next parser based on the terminating keyword... cumbersome, though.
01:08:01 <wkh> metaprogramming in haskell is really hard compared to lisp.
01:08:31 <quicksilver> well lisp is homoiconic and haskell isn't, so that's not surprising
01:08:51 <quicksilver> however most of the constructions which require metaprogramming in other languages don't require it in haskell
01:09:00 <quicksilver> first-class functions and actions take care of that
01:09:28 <quicksilver> kzm: you shouldn't have to do that, no. parsec is a context-sensitive parser
01:09:46 <quicksilver> kzm: I haven't used it myself though so I can't solve your specific problem but it shouldn'e be all that hard
01:11:29 <kzm> I need either a manyTill where the termination condition doesn't consume anything.  Perhaps notFollowedBy is appropriate?
01:19:35 <malcolmw> kzm: isn't there a manyTill combinator that actually returns the following item in addition to the list?
01:20:26 <kzm> I want the opposite: manyTill that leaves unconsumed the terminating string.
01:21:16 <kzm> I tried do { c <- anyChar; notFollowedBy (string "keyword:"); return c } but notFollowedBy seems - for some reason - not to accept a string parser.
01:21:19 <malcolmw> kzm: I'm not sure that is possible
01:22:16 <malcolmw> fundamentally, the parser needs to look at the next item to tell whether it has reached the end of the list or not
01:22:58 <kzm> okay?  But 'try' rewinds on failure - isn't that similar?
01:23:08 <kzm> I just want to rewind on success :-)
01:23:12 <malcolmw> exactly
01:23:44 <kzm> Not with you - it's similar, and therefore impossible? :-)
01:24:11 <malcolmw> manyFinally :: Parser a -> Parser z -> Parser ([a],z)  is the signature you really want I think
01:24:36 <malcolmw> "exactly" = you want to rewind on success
01:24:47 <malcolmw> ... which is not possible
01:24:47 <anonfunc> Is there an option in ghci to suppress the printing of infinite lists?
01:25:03 <vegai> are the HList guys gonna make a ghc-6.6 compatible release soon?
01:25:21 <quicksilver> anonfunc: how would you expect ghci to know which list was infinite? :)
01:25:23 <malcolmw> anonfunc: how soon would you like it to stop?  after a million elements?
01:25:24 <kzm> anonfunc: how do you want ghci to know if a list is infinite?
01:25:25 <dmwit> anonfunc: How do we tell what is infinite?
01:25:30 <quicksilver> @quote stereo
01:25:30 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
01:25:41 <kzm> Okay, I guess that point is nailed :-)
01:25:46 <anonfunc> :-D  How about a size limit, then?
01:25:54 <quicksilver> (take 50) works for me
01:26:27 <quicksilver> yeah, it wouldn't be stupid to ask ghci to put a size limit on its 'show', but personally I just shove (take n) in front of such things
01:26:32 <kzm> malcolmw, so I basically need to go the state machine route - consume the next keyword as terminator, and call the correct parser for the following value.
01:27:00 <anonfunc> quicksilver: It's when i forget and have to wait for the inferior haskell mode to see my interrupt that bugs me.  Thanks, though
01:27:14 <malcolmw> kzm: well, if you already have a parser for the "terminating keyword + following stuff", just use that!
01:27:32 <quicksilver> kzm: I would do it like this
01:27:41 <kzm> anonfunc, note that you can suppress automatic output of monadic assignments (typically xs <- readFile "large_test_file")
01:27:52 <quicksilver> kzm: parser recognises a list of KeyWordOrValue
01:27:59 <kzm> malcolmw, right.
01:28:05 <quicksilver> kzm: [Either Keyword Value], say
01:28:18 <quicksilver> kzm: then a function converts that into the right structure afterword
01:28:35 <quicksilver> kzm: the parser for KeywordOrValue recognises keyword with higher priority than value
01:29:03 <malcolmw> kzm: there is no need to split up the keyword from the value following it, if you don't want to
01:29:06 <quicksilver> kzm: that, to me, seems the model the grammer you've described
01:31:15 <kzm> Hmm.. let me chew and hack on that for a minute.
01:33:03 <prb> I got a question from a commenter (http://mult.ifario.us/articles/2007/03/04/stm-and-io) about use of unsafeIOToSTM that made me think for a second.
01:33:16 <prb> Is there any other (ideally more elegant way) to sandwich some IO between STM actions?
01:33:50 <quicksilver> prb: surely the 'elegant' way is make the outer action an IO action, and run the STM bits inside it?
01:34:28 <prb> quicksilver: Hmmm.
01:35:14 <prb> quicksilver: The sandwich is like so: STM, IO, STM.
01:35:16 <quicksilver> @index unsafeIOtoSTM
01:35:16 <lambdabot> bzzt
01:35:24 <prb> quicksilver: Capital T
01:35:35 <prb> quicksilver: If the IO fails, I want to roll-back the first STM.
01:35:49 <prb> @index insafeIOToSTM
01:35:49 <lambdabot> bzzt
01:35:56 <prb> Ha.
01:35:58 <prb> I can't type, either.
01:36:17 <prb> (Which is especially bad for someone learning Haskell! [sic])
01:36:25 <prb> @index unsafeIOToSTM
01:36:25 <lambdabot> GHC.Conc
01:36:36 <quicksilver> thanks, found it
01:37:11 <quicksilver> sorry, my brain is too full to solve your problem. I can only give you a gut reaction
01:37:19 <quicksilver> the 'correct' layering is to have STM inside IO
01:37:31 <quicksilver> (noting that 'atomically' is really safeSTMtoIO)
01:37:55 <quicksilver> if you have to layer IO inside STM then one way of doing that is to have an STM action which returns an IO action
01:38:00 <quicksilver> as your commentor observed
01:38:26 <quicksilver> I *think* the kind of nesting you're talking about is exactly the kind of the thing the warning in unsafeIOtoSTM is supposed to warn you of :)
01:38:39 <quicksilver> sorry, the warning inside atomically, I mean
01:38:43 <prb> No runtime error, but maybe you're right.
01:38:50 <quicksilver> "You cannot use atomically inside an unsafePerformIO or unsafeInterleaveIO. Any attempt to do so will result in a runtime error. (Reason: allowing this would effectively allow a transaction inside a transaction, depending on exactly when the thunk is evaluated.)"
01:39:09 <quicksilver> the 'unsafe' constructs don't generate runtime errors. They give you enough rope to hang yourself. Hence the name.
01:39:31 <prb> Heh.
01:39:40 <quicksilver> I'm not sure what the correct invariant is for unsafeIOtoSTM to be safe
01:39:49 <prb> In any case, it seems to be a worthwhile thought experiment.
01:40:01 <quicksilver> it's something like "the embedded IO must not have any side-effects which might influence the outer IO"
01:40:11 <prb> They're orthogonal.
01:40:20 <quicksilver> ('outer' being the one 'outside the atomically')
01:40:40 <quicksilver> SPJ is a bad man for not explaining the contract in the haddock
01:40:57 <prb> I believe that the exclusion locking would ensure that there is no contention on disk, so that would hold.
01:41:48 <quicksilver> prb: if I get this real work done this mornign I'll read your blog properly and think about it again. Hoepfully someone else smarter/less busy than me will be along in the mean time
01:42:15 <prb> quicksilver: Thanks!
01:42:58 <audreyt> anyone versed with [:a:] here?
01:43:24 <audreyt> I'm looking for the definition of
01:43:25 <audreyt> mapMP :: Monad m => [:a:] -> (a -> m b) -> [:b:]
01:43:30 <audreyt> can't seem to find it
01:43:52 <quicksilver> surely that should be m [:b:]
01:43:58 <audreyt> yeah
01:43:59 <quicksilver> although that doesn't mean I can answer your question :(
01:45:39 <quicksilver> is that scrap-your-boilerplate stuff?
01:45:47 <audreyt> no
01:45:50 <audreyt> it's parallel-array stuff
01:49:58 <quicksilver> audreyt: that seems that it would have to sequentialise, to me
01:50:06 <quicksilver> audreyt: since we don't have a CommutativeMonad class
01:50:26 <audreyt> yeah.
01:51:23 <audreyt> but why not?
01:51:31 <audreyt> in the realm of parallelism they are everywhere...
01:51:39 <quicksilver> it's probably just, more or less [: b | b <- fromList (mapM f (toList ar)) :]
01:52:02 <audreyt> uh
01:52:05 <audreyt> fromList?
01:52:13 <audreyt> that gets you [: m b :]
01:52:16 <audreyt> not m [: b :]
01:52:24 <quicksilver> (fmap fromList)
01:52:26 <goltrpoat> i didn't quite realize until now just how utterly weird haskell is from a parsing standpoint
01:52:33 <audreyt> and yes you can liftM that
01:52:38 <audreyt> but then it oversequentialize
01:52:42 * quicksilver nods
01:52:47 <audreyt> I was trying to find a way to avoid sequentialization
01:52:49 <hpaste>  goltrpoat pasted "weirdness example" at http://hpaste.org/839
01:52:49 <quicksilver> right, well that's inevitable I think
01:52:52 <audreyt> if not Monad, then in something else
01:52:55 <audreyt> but it's not
01:53:00 <audreyt> I mean, even the IO monad has forkIO
01:53:02 <quicksilver> inevitable in Monad
01:53:12 <audreyt> yes, but we can instance IO into something else
01:53:17 <quicksilver> not inevitable if you write a commutative Monad
01:53:20 <audreyt> as you said, CommutativeMonad
01:53:22 <goltrpoat> is it just me, or does that require type inference in the frontend
01:53:22 <quicksilver> (IO isn't commutative)
01:53:34 <audreyt> (we we pretend it is if it's only output)
01:53:41 <audreyt> which is the case here for pugs
01:53:47 * quicksilver nods
01:53:51 <quicksilver> that's like an IO submonad, yes
01:53:57 <quicksilver> the centre of IO, if you like :)
01:54:00 <audreyt> let's call it O
01:54:01 <audreyt> :)
01:54:10 <audreyt> "Conad"
01:54:21 <quicksilver> goltrpoat: why do you think that requires type inference in the parser?
01:54:38 <goltrpoat> quicksilver:  because the fixity depends the particular instance of C
01:54:55 <audreyt> ok, so I guess my question is, if somebody has written it before :)
01:55:06 <audreyt> <- not really of the NIH type, but can code if forced to
01:56:19 <goltrpoat> quicksilver:  in other words, what does the AST for 'test' look like
01:57:00 <wkh> pugscode.org seems to be down for me
01:57:18 <audreyt> worksforme
01:57:19 <Cale> goltrpoat: uh, that's not valid code, since fixity declarations aren't allowed in instance bodies.
01:57:24 <goltrpoat> cale:  they are.
01:57:35 <Cale> Since when?
01:57:41 <goltrpoat> http://www.haskell.org/onlinereport/decls.html#fixity
01:57:42 <lambdabot> Title: The Haskell 98 Report: Declarations
01:57:43 <goltrpoat> since 98
01:57:49 <goltrpoat> :)
01:58:25 <goltrpoat> wait.  i think i misread that, it says in the class declaration
01:58:25 <Cale> Where does it say there that fixity declarations can occur in instances?
01:58:38 <goltrpoat> but.. ghc compiles and runs it, and it's doing what you'd expect
01:58:42 <quicksilver> goltrpoat: no
01:58:53 <Cale> If you look at the syntax, in '98 at least, it's a syntax error.
01:58:56 <quicksilver> goltrpoat: true --> false --> false comes out true
01:59:02 <quicksilver> goltrpoat: whichever way you bracket it
01:59:07 <quicksilver> goltrpoat: your test is flawed :)
01:59:14 <Cale> If GHC is accepting that, I think it's a bug.
01:59:47 <goltrpoat> ugh.
01:59:50 <goltrpoat> sec
02:00:14 <quicksilver> come to that, Just 1 --> Nothing --> Nothing comes out Nothing in either bracketing, too :)
02:00:48 <goltrpoat> i was playing with a bunch of tests, and pasted the wrong one, looks like
02:00:52 <Cale> I'm amazed it isn't choking on the fixity decls there.
02:01:01 <quicksilver> my guess would be that the last fixity decl takes priority
02:01:07 <quicksilver> or
02:01:10 <quicksilver> that both are ignored
02:01:18 <quicksilver> it may be that GHC permits 'local fixities'
02:01:30 <quicksilver> and the scope of those fixities is in fact only the instance body in both cases
02:01:55 <goltrpoat> False --> True --> False is the associativity test, and it looks like it evaluates to the same thing for both instances
02:02:57 <goltrpoat> false alarm.  sorry about that :)
02:03:53 <Cale> (-->) is being defined infixl 9
02:04:00 <goltrpoat> -nod-
02:04:29 <quicksilver> easy to get confused about this stuff :)
02:04:31 <Cale> (which is the default)
02:04:48 <Cale> GHC really should be giving a syntax error there.
02:05:28 <quicksilver> Cale: I think it might be localising the fixities to the declaration they occur within
02:05:33 <quicksilver> Cale: that would be my guess, anyway
02:05:38 <Cale> If it really does support local fixity declarations, there's nothing in the documentation which says it should.
02:05:41 * quicksilver nods
02:07:05 <goltrpoat> doesn't look like it's even doing that
02:08:18 <goltrpoat> (moved test into the class declaration and copied it into both instances.. same result for test False True False as for test Nothing (Just 1) Nothing)
02:08:28 <goltrpoat> odd.
02:08:55 <quicksilver> ignoring completely then, perhaps
02:09:34 <quicksilver> any idea if a construct like 'mapM hClose [a,b,c]' actually bothers to create and dispose a list, as compiled by GHC, or if GHC can build a simple loop for that?
02:09:47 <quicksilver> mapM_, even
02:11:00 <Cale> yeah, I just did a test with trees, and it's ignoring the fixity declaration in the instance completely.
02:11:19 <asdasd> In this SICP lesson the lecturer looks like doesn't know the notion of monad? What am I missing? http://www.youtube.com/watch?v=YyuBG-TDBcw&NR
02:11:50 <malcolmw> quicksilver: it certainly can be deforested, but I don't know whether ghc actually does or not in this case - you could try -ddump-simpl and examine the core to verify
02:11:53 <Cale> asdasd: yes, that's because it's before the use of monads in CS existed.
02:12:22 <asdasd> Cale: basically Monads came in the 90s?
02:12:38 <Cale> That lecture is from http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ and is over 20 years old.
02:12:41 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
02:12:53 <Cale> yeah
02:13:17 <asdasd> Cale: I'm familiar with the SICP lessons, but I wasn't aware that Monads where such a new concept
02:13:24 <asdasd> who came up with them in CS?
02:13:35 <Cale> Monads are a new concept in mathematics in general, only about 50 years old or so.
02:13:36 <wkh> moggi and wadler, i think
02:13:45 <Syzygy-> Coined by Peter May.
02:13:50 <Syzygy-> No wait.
02:13:55 <Syzygy-> That's operads.
02:14:09 <quicksilver> moggi wrote the really nice paper on it
02:14:21 <quicksilver> I don't think he'd claim the whole idea belonged to him, though
02:14:23 <Cale> I think it's MacLane who's originally responsible.
02:14:35 <quicksilver> Cale: ah, I meant computational monads :)
02:14:45 <Cale> Moggi is who perhaps brought them to CS.
02:14:46 <asdasd> that's interesting. So can we say that Haskell is pretty much cutting edge as far as programming languages go?
02:14:51 <quicksilver> or, rather, the use of monads to give semantics to computational effects
02:14:55 <Cale> asdasd: certainly, yes
02:15:00 <quicksilver> asdasd: *a* cutting edge, at least :)
02:15:06 <Cale> right
02:15:10 <quicksilver> programming langauges is a many-edged sword
02:15:16 <Cale> There are things like Epigram, which are newer
02:15:23 <wkh> there's lots of experimental stuff that comes standard with GHC, but there's also a stable core. that was part of the original idea for Haskell. suitable both for teaching and for research.
02:15:35 <asdasd> I see
02:15:39 <osfameron> given that 99% of programmers probably haven't heard of monads, and 99% of those that do don't understand them, I'd say it's relatively cutting edge
02:15:52 <osfameron> (feel free to invent more correct figures :-)
02:15:54 <Cale> The interesting thing about Haskell is that it's a research language which is actually getting quite practical for everyday use.
02:15:58 <wkh> from a noob's perspective, it means there's lots of cool-looking stuff that i can't figure out how to use
02:16:08 <Cale> wkh: hehe
02:16:24 <Cale> someone with a youtube account should comment on that video.
02:16:44 <Cale> It appears the original poster had an agenda without a clue :)
02:17:08 <asdasd> Cale: exactly
02:17:22 <Cale> I don't even think Abelson and Sussman would agree with the sentiment that assignment is the solution.
02:17:37 <asdasd> Cale: assignments... brrrr
02:17:57 <quicksilver> hmph, seems like ghc doesn't deforest my simple 3-elt list
02:18:03 <Cale> In fact, in another lecture, they mention that it's a powerful abstraction for certain situations which should be treated with extreme care.
02:18:17 <Cale> (and warn against using it liberally)
02:18:57 <wkh> youtube is in many ways broken and useless.
02:19:28 <Cale> I actually saw something reasonably interesting on Youtube today.
02:19:58 <Cale> http://www.youtube.com/watch?v=5SaFTm2bcac
02:20:37 <Cale> At least, it's relatively coherent. :)
02:22:27 <wkh> yes. and then for every piece of quality content that's searchable there's a 10 second fake video that consists of nonsense along with a small thumbnail image of a scantily clad girl with 50,000 keywords, all of which is designed to game the youtube searching system, game youtube users, and get as many hits as possible without actually providing any real content
02:22:56 <apfelmus> where did my time go?
02:23:11 <goltrpoat> that's about clyde stubblefield isn't it
02:24:19 <quicksilver> wkh: community driven, traffic driven websites are intrinsically targets for 'gaming' as you are calling it. It doesn't meant that they can't surmount that and acheive useful content.
02:24:56 <Cale> The trick to it is making sure that the only useful ways of "gaming" the system only serve to improve it.
02:25:12 <apfelmus> argl, i have a profile where a function takes 22% of the time but doesn't really do anything
02:26:16 <wkh> quicksilver: their inability to control it means that sorting a search by views is generally useless as the first 5 pages will have nothing but crap. the top viewed page consists mostly of such nonsense videos, naruto/other anime episodes, other japanese language clips (mainly clips from zany japanese shows), and videos in various eastern european languages.
02:26:39 <quicksilver> wkh: give it time. I suspect it will evolve.
02:26:48 <wkh> filtering by language makes it select english videos of the top viewed ones rather than the most viewed videos that are in english. that only slightly increases the signal-noise ratio.
02:26:54 <quicksilver> wkh: in the mean time, try community filters like iwatchthis.com
02:26:55 <wkh> it used to be much better if i remember correctly
02:27:02 <Cale> It's owned by google now, after all, hopefully they have some good engineers working on it :)
02:27:46 <wkh> i'm sure they will find some way to make youtube part of their clickfraud empire
02:33:58 <Cale> wkh: hmm, isn't click fraud essentially a problem for Google, in that it would cause advertisers to lose confidence in Google's ad placements, and thus not purchase them any longer?
02:34:36 <ivanm> yep
02:34:56 <Cale> (Despite the fact that it temporarily would increase Google's revenue, it doesn't seem like burning customers for that is worth it.)
02:35:24 <quicksilver> I think wkh was just suffering a suffusion of negativity ;)
02:37:33 <wkh> of course. they're google, they can do no wrong
02:38:05 <ivanm> and don't forget, naughty /= google ;)
02:38:09 <Cale> I'm not talking about right or wrong here (whatever those might be), but about what makes good business sense for them.
02:38:12 <ivanm> s/google/evil
02:38:52 <quicksilver> it is amusing, in a geek-culture sense, to watch google's pathway from ultimately-cool-tech-company to evil-empire-worse-than-MS
02:39:22 <hpaste>  apfelmus pasted "cunning cost centers" at http://hpaste.org/840
02:39:39 <apfelmus> ^^ has anybody a clue what's going on?
02:40:27 <apfelmus> the problem is: a certain function (changeBooks) get attributed a huge amount of time
02:40:44 <apfelmus> but it basically delegates it's work to helper functions
02:40:54 <apfelmus> that have their own cost centers
02:41:20 <apfelmus> now what?
02:43:17 <Cale> What's add?
02:43:21 <Cale> oh
02:43:24 <Cale> locally bound
02:43:47 <Cale> So perhaps it's in the construction and deconstruction of tuples?
02:44:12 <apfelmus> 22%? i'd rather not :)
02:44:33 <apfelmus> but wait, i forgot something crucial
02:45:08 <Cale> Maybe the fact that it forces the evaluation of side, and its first parameter?
02:45:35 <Cale> Does that cost get attributed there?
02:46:31 <Cale> oh look
02:46:34 <apfelmus> according to the only paper i found about profiling, the cost of evaluating parameters should not be attributed to the function
02:46:41 <Cale> ah, okay
02:47:09 <Cale> But look at the profile. Apparently it's doing 14% of the allocation (individually)
02:47:33 <Cale> and 23% including inherited stuff
02:47:44 <apfelmus> you mean 34%
02:47:55 <Cale> allocation
02:48:07 <apfelmus> ah, ok
02:48:29 <Cale> So it must build a ton of those pairs :)
02:49:23 <quicksilver> well it's called 100,000 times
02:49:28 <Cale> indeed
02:49:38 <Cale> So that's actually pretty significant.
02:49:48 <hpaste>  apfelmus annotated "cunning cost centers" with "forgot cost center "changeBooks"" at http://hpaste.org/840#a1
02:50:03 <quicksilver> although it feels like those tuples ought to be 'deforestable' somehow
02:51:18 <Cale> Out of curiosity, what is measureOrder?
02:51:36 <apfelmus> i forgot to mention how the cost center "changeBooks" is defined. it's not annotated at the function but at the (only) caller
02:51:46 <apfelmus> Cale: measureOrder is for the 2-3-finger-tree
02:52:40 <Cale> I wonder if it'd be worthwhile for changeBooks to be written in CPS.
02:52:57 <apfelmus> the task mentioned on the website can be implemented with 2-3-finger-trees to achieve O(log n) add and remove
02:54:06 <Cale> oh, I missed that comment :)
02:54:47 <apfelmus> mh, about the pairs, i don't know. remember that the running times are in %. the rest of the program arguably con- and deconstructs much more pairs and constructors than changeBooks
02:56:12 <apfelmus> delete and insert each do something like a FingerTree.split and a Map.lookup which ought to be more expensive than simple pairs
02:56:13 <Cale> getFoldrWhile is the only thing in the program which does more allocation
02:56:37 <Cale> er
02:56:45 <Cale> not quite
02:57:04 <Cale> getFoldl'While is pretty big too
02:57:25 <apfelmus> yeah. uh, IO times are horrible. i tried to come up with a hand-written parser based on Data.Binary.Get but it still eats most of the processing time
02:57:44 <Cale> what are those functions?
02:57:59 <Cale> the parser?
02:58:11 <apfelmus> i'll paste. there are basically higher order for parsing integers and lists
02:58:25 <apfelmus> s/there/they
03:00:51 <Cale> Heh, coefficiency.
03:00:54 <hpaste>  apfelmus annotated "cunning cost centers" with "getFoldrWhile and applications" at http://hpaste.org/840#a2
03:01:16 <apfelmus> here it is
03:01:37 <Cale> hmm
03:02:49 <apfelmus> uh why does getList have a (Show a) requirement? mh, i think i used it for debugging
03:03:40 <apfelmus> the idea was to use a deterministic Stream -> (a, Stream) ~ Get a parser for speed but it went totally wrong
03:04:27 <Cale> @t \f x -> return f `ap` x
03:04:27 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
03:04:32 <Cale> :t \f x -> return f `ap` x
03:04:34 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
03:04:39 <Cale> that's fmap
03:04:41 <goltrpoat> could it be that changeBooks is spending time in the pattern match?  i.e. what happens if you add strictness annotations to the LogCommand constructors
03:05:50 <apfelmus> Cale: ah, yes. well return (+) `ap` [1,2] `ap` [3,4]  works for several arguments, too
03:06:06 <goltrpoat> i guess to put it differently, where does the TS t command come from
03:06:17 <Cale> For reasonable numbers, liftMn is available :)
03:06:20 <nornagon> dons: hey, how's dwm-in-haskell coming? :)
03:06:43 <wkh> i wish someone could find a way to make ajax not suck
03:06:55 <Cale> wkh: what do you think of flapjax?
03:07:17 <wkh> cale: i think it would be very cool if i could figure out what it is or how to use it
03:07:41 <apfelmus> goltrpoat: TS :: TimeStamp -> a -> TimeStamped a
03:07:46 <Cale> http://www.flapjax-lang.org/
03:07:47 <lambdabot> Title: Flapjax
03:08:27 <goltrpoat> apfelmus:  i meant, where is the second argument to processEntry coming from?
03:09:18 <robreim> > Network.Socket.PortNum 80
03:09:19 <lambdabot>   Not in scope: data constructor `Network.Socket.PortNum'
03:09:23 <apfelmus> goltrpoat: it's being parsed (which eats a lot of time). but according to spec, cost centers don't count costs for evaluating arguments. at least in theory, that's the puzzle
03:09:39 <goltrpoat> the theory being that it doesn't look like 'command' really needs to be evaluated until it gets to the pattern matches in changeBooks, which could account for the extra 30%
03:09:48 <goltrpoat> ah ok
03:09:51 <robreim> PortNum's changing the endianness of its argument incorrectly for me.
03:10:11 <quicksilver> :t \f -> (f $)
03:10:13 <lambdabot> forall a b. (a -> b) -> a -> b
03:10:31 <quicksilver> apfelmus: is (TS t $) somehow different from (TS t) ?
03:11:12 <apfelmus> goltrpoat: but it may well be that the count for evaluating 'command' is "accidentally" attributed to changeBooks. i mean, something murky is going on here.
03:11:21 <goltrpoat> -nod-
03:11:30 <apfelmus> quicksilver: the first has a superflous $ :)
03:11:44 <apfelmus> @spell superflous
03:11:46 <lambdabot> superfluous superfluously supercilious superfluity superclass
03:11:59 <robreim> If I start a tcp server using Network.Socket and use PortNum 80, the server starts up on port 20480. Can anyone else verify whether they get the same thing (linux x386 ghc6.6)?
03:13:08 <quicksilver> robreim: perhaps you're not running as root?
03:13:13 <quicksilver> robreim: port 80 is privileged
03:13:34 <robreim> Well, even if I use it to connect as a client
03:14:18 <quicksilver> > 20480 == 80 * 256
03:14:20 <lambdabot>  True
03:14:26 <quicksilver> looks like it could be a byte-order error
03:14:53 <robreim> Yeah, it's a byte order error...
03:15:23 <robreim> hmm... I wasn't getting this error with HAppS...
03:15:28 <Cale> wkh: checking it out?
03:16:08 <Cheery> does haskell support memoization?
03:16:41 <ivanm> Cheery: to an extent
03:16:55 <apfelmus> Cheery: lazy evaluation is your friend
03:17:50 <quicksilver> Cheery: yes
03:18:19 <Cale> If you're really interested, you can use low-level stuff to construct lots of variants of memo :: (Eq a) => (a -> b) -> (a -> b)
03:18:21 <wkh> cale: not really. i can't figure it out. it's a program that compiles its little language to javascript, and the ugly generated code is what gets run?
03:18:33 <wkh> when i downloaded it, all i saw were actionscript and javascript files.
03:18:36 <wkh> no binaries.
03:19:14 <Cale> There's a compiler, and a plain javascript library.
03:19:53 <Cale> The compiler just gives you nicer syntax, basically.
03:20:22 <Cale> http://www.flapjax-lang.org/compiler/
03:20:23 <lambdabot> Title: Flapjax Online Compiler
03:21:00 <apfelmus> @tell kolmodin that Data.Binary.Get.S = S .. !Int64  is probably a bad idea for 32 bit platforms like the ppc
03:21:01 <lambdabot> Consider it noted.
03:21:27 <Cale> (there's a commandline version downloadable there in python)
03:22:52 <Cale> wkh: Try changing mouseTop_b(document) to delay_b(mouseTop_b(document), 500), clicking Compile and Run a second time, and watch what happens. :)
03:22:59 <sebell> Python? I wonder if there's one for PLT Scheme...
03:23:13 <Cale> sebell: yeah, surprising isn't it? :)
03:23:26 <dons> nornagon: hey, i'm using dwm-in-haskell right now.
03:23:33 <dons> needs some more work though
03:23:37 <wkh> implementing compilers in python doesn't scale
03:23:46 <Cale> It's not a very big program.
03:24:03 <nornagon> dons: :D
03:24:07 <wkh> python is for hacking up pr0n site spidering scripts when wget won't do the trick
03:24:25 <nornagon> dons: i'd like to write my own wm someday
03:24:52 <nornagon> to satisfy my needs for pretty at the same time as satisfying my needs for tiled windows and screen usage optimisation
03:25:17 <goltrpoat> i read that as 'tilted windows' at first
03:25:20 <dons> well, 'thunk' is only 150 lines of code. they're not too hard
03:25:25 <goltrpoat> which didn't seem to mesh with screen usage optimization
03:25:26 <Cale> oh
03:25:45 <Cale> maybe that's all it's doing after all :)
03:26:07 <Cale> (passing the code off to a webserver somewhere)
03:26:08 <dons> dwm feels bloated after a day spent in thunk.
03:26:26 <ivanm> thunk?
03:26:30 <ivanm> @google thunk
03:26:32 <lambdabot> http://www.thunk.com/
03:26:33 <lambdabot> Title: thunk.com - secret messages for kids only! Plus jokes games spy trivia email lea ...
03:26:40 <dons> thta's the secret code name for our dwm replacement
03:26:43 <ivanm> I don't think that's it...
03:26:48 <dons> ?where thunk
03:26:48 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/thunk/
03:26:59 <ivanm> who's secret code?
03:27:03 <sebell> ivanm: Dons is of the old school, code _before_ project page :)
03:27:08 <ivanm> lol
03:27:18 <Cale> ah, okay
03:27:23 <ivanm> is that why none of his projects have a decent project page? ;)
03:27:29 <quicksilver> dons: are you aware of anyone who's written a haskell file-sorter? One that can cope with abitrarily large files?
03:27:30 <ivanm> because he never finishes them? ;)
03:27:31 <Cale> the script they provide there is just passing the thing off to a real compiler
03:27:35 <Cale> which you can also download
03:27:45 <Cale> It appears the real compiler is written in Haskell.
03:28:36 <nornagon> dons: thunk is haskell-dwm?
03:29:20 <Cale> It's odd that they would do that.
03:29:47 <Cale> Perhaps they don't want to expose people to the horrifying truth that it's implemented in Haskell :)
03:29:50 <Cale> hehe
03:31:15 <Cale> just under 2000 lines of haskell code, if sloccount can be trusted.
03:31:32 * resiak idly wonders if Thunk actually works
03:32:17 <Cale> awesome, why haven't I heard that this is in Haskell before?
03:33:20 <Cale> It's not on our list of compilers implemented in Haskell.
03:34:57 <nornagon> compiler for what?
03:36:03 <apfelmus> JaffaCake: ping
03:36:18 <JaffaCake> pong
03:36:46 <apfelmus> JaffaCake: hi! i have a profiling problem. can you clarify the mysteries?
03:36:46 <goltrpoat> where does the haskell X11 package live?
03:36:54 <JaffaCake> I can try...
03:37:12 <Cale> nornagon: Flapjax
03:37:25 <apfelmus> JaffaCake: would be great. here it is: http://hpaste.org/840
03:38:00 <nornagon> Cale: i see
03:38:15 <JaffaCake> apfelmus: ok, what's the problem?
03:38:16 <goltrpoat> nm found it
03:38:53 <apfelmus> JaffaCake: changeBooks miraculously eats 22% individually but doesn't much else than delegating the work to insert and delete
03:39:02 <apfelmus> *doesn't do
03:39:57 <apfelmus> at least when assuming that argument evaluation is not attributed to a cost center.
03:40:34 <apfelmus> not that the cost center for changeBooks isn't the top level function but it's annotated by hand (see annotations to the paste)
03:40:38 <apfelmus> *note
03:40:38 <JaffaCake> apfelmus: according to the profile, changeBooks also calls adjustAssetInfo, is that true?
03:40:43 <Cale> I wish I'd known that sooner. :)
03:41:31 <dons> goltrpoat: on hackage.
03:41:39 <dons> ?where hackage
03:41:39 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
03:41:42 <goltrpoat> yah
03:41:44 <JaffaCake> apfelmus: there are known bugs in the profiler, see http://hackage.haskell.org/trac/ghc/ticket/948
03:41:45 <goltrpoat> just found it there
03:41:46 <apfelmus> JaffaCake: oh. ah. actually, it shouldn't be true. insert and delete call adjustAssetInfo.
03:41:47 <lambdabot> Title: #948 (Incorrect Core transformations with cost centres) - GHC - Trac
03:42:13 <JaffaCake> you might be falling foul of that bug
03:42:14 <dons> resiak: yeah, thunk works. its been running on my laptop all day. its very very minimal though. you get one workspace and as many windows as you can stack. that's it.
03:43:17 <Cale> dons: did you know about this?
03:43:25 <dons> hmm?
03:43:26 <resiak> dons: hrm!
03:43:36 <Cale> (The flapjax compiler is written in Haskell)
03:43:49 <dons> hmm, I thought it was ocaml?
03:44:06 <apfelmus> JaffaCake: ah, that's most likely the case. so i'd better eschew local SCCs and go with -auto?
03:44:08 <Cale> Apparently not. I have the source right here.
03:44:18 <Cale> http://www.flapjax-lang.org/download/flapjax-source.tar.gz
03:44:30 <JaffaCake> apfelmus: probably, but I can't be sure that -auto won't have problems too
03:44:44 <dons> wow. that's pretty nice.
03:45:45 <Cale> I wish I'd known sooner, that would have been the simplest way to set aside any doubt that Shriram was being sarcastic in his jabs at Haskell in the flapjax video :)
03:46:05 <sebell> Haha
03:46:08 <kolmodin> apfelmus: hia
03:46:21 <sebell> Cale: It sounded like the audience didn't catch on either.
03:46:30 <Cale> yeah :)
03:46:56 <apfelmus> JaffaCake: uh, oh. mh, unfortunately, that means that profiling becomes drastically less useful. how much would leaving out -O distort the results?
03:47:24 <dons> $ cd flapjax/compiler
03:47:24 <dons> $ ls
03:47:24 <dons> CHANGELOG  Flapjax    Javascript Makefile   Samples    Test
03:47:24 <dons> Fjc.hs     Html       LICENSE    Misc.hs    TODO
03:47:26 <dons> :-)
03:47:47 <dons> ok. so there's a full javascript system in there?
03:47:57 <JaffaCake> apfelmus: in my experience it works most of the time
03:48:23 <Cale> there's a parser at least
03:48:32 <Cale> and a prettyprinter
03:48:37 <apfelmus> JaffaCake: ok, i just have to try. thanks a lot :)
03:48:37 <JaffaCake> apfelmus: sorry can't be more helpful, hopefully we'll look into this before 6.8
03:48:43 <triplah_> flapjax looks like a more js'ish e
03:49:06 <triplah_> actually, its a bit more buzzword compliant
03:49:45 <triplah_> i take that back
03:49:46 <Cale> It's a declarative language for functional reactive programming disguised to look like javascript :)
03:49:49 <triplah_> it's nothing like e
03:49:49 <dons> oh, i see someone already noticed this, http://haskell.org/haskellwiki/Libraries_and_tools/Compilers_and_interpreters#Flapjax
03:49:50 <triplah_> :D
03:49:52 <lambdabot> Title: Libraries and tools/Compilers and interpreters - HaskellWiki, http://tinyurl.com/ye98mq
03:49:56 <dons> "    Flapjax is a language for functional reactive programming of AJAX web applications, whose
03:50:00 <dons>     compiler (source) is written in Haskell."
03:50:01 <apfelmus> JaffaCake: it's probably difficult for it's unclear whether every code transformation even can preserve cost centers.
03:50:01 <Cale> dons: that was me, a couple minutes ago
03:50:06 <dons> heh
03:50:07 <triplah_> haha
03:51:01 <JaffaCake> apfelmus: we're lacking an actual semantics for cost-center stacks at the moment, so we don't know what the valid transformations should be
03:51:41 <apfelmus> JaffaCake: that's even worse :)
03:52:06 <apfelmus> kolmodin: hia! i'm trying to get a fast (=> deterministic) parser by (ab)using Data.Binary.Get. but it didn't work out. maybe Int64 throws an additional spanner in the works, at least on ppc (32 bit)
03:53:10 <kolmodin> apfelmus: we use Int64 as it is what lazy bytestrings use. haskell98 only guaranties 29 bits, ie 512mb, which most people don't think is enough
03:53:55 <dons> I eat 512 mb for breakfast
03:54:02 <apfelmus> hehe
03:54:05 <kolmodin> see ^^ :D
03:54:08 <dons> Cale, http://programming.reddit.com/info/18gws/comments
03:54:09 <lambdabot> Title: Flapjax: functional reactive Ajax -- with a compiler written in Haskell (reddit. ...
03:54:19 <kolmodin> apfelmus: that's why we have to use Int64
03:54:23 <Cale> :)
03:55:20 <wkh> functional reactive yadda-yadda...
03:55:27 <wkh> would you use arrows to implement a compiler for that, then?
03:55:53 <dons> probably not. maybe in an interpreter for it though. you'd just embed it in yampa
03:56:20 <dons> they don't use cabal so I can't easily tell
03:56:37 <wkh> what would an interpreter be in this case be like when the target environment is a web browser
03:56:56 <dons> a poor one, run from the command line?
03:58:07 <goltrpoat> unless you execute the interpreter clientside?
03:58:08 <goltrpoat> hehe
03:58:43 <sebell> One of the problems with JavaScript is that it's not expressive enough as a high-level language, and not ideal as an intermediate-language/vm
03:58:51 <goltrpoat> 1. compile the interpreter to javascript  2. embed the flapjax code in the interpreter.  3. ...  4. profit!
03:58:58 <ski> apfelmus : deterministic ?
03:59:08 <sebell> goltrpoat: That would be nice and slow ;)
03:59:16 <goltrpoat> never stopped anyone before :)
03:59:23 <apfelmus> ski: String -> (a, String)
03:59:41 <ski> and what do you do on failure ?
03:59:50 <wkh> it looks like they're just using parsec
04:00:03 <apfelmus> ski: jump behind a train?
04:00:13 <ski> haha
04:01:02 <apfelmus> kolmodin: ok. well, the Int64 is probably not the problem. say, are there any decent parser combinators for ByteString out there? i'm missing something like scanf
04:01:28 <ski> apfelmus : so you are parsing data that is already assumed to be in a certain form, then ?
04:01:39 <dons> ?where bytestringparsec
04:01:40 <lambdabot> I know nothing about bytestringparsec.
04:01:51 <ski> (i.e. not much choices)
04:02:14 <dons> ?where bytestringparser
04:02:15 <lambdabot> http://hackage.haskell.org/~paolo/darcs/ByteStringParser
04:02:15 <apfelmus> ski: yes, indeed :) it's more like a CSV file where scanf is entirely sufficient
04:02:25 <ski> 'CSV' ?
04:02:35 <dons> there's that, there's some int stuff in bytestring, and you can just ffi call to scanf anyway :-)
04:02:48 <apfelmus> ski: comma separated value
04:02:59 <ski> ok
04:03:18 <goltrpoat> ski:  what's wrong with failure?  data Parser a = Parser { runParser :: String -> (a, String) };  type CompileResult = Either Program Failure;  parseProgram :: Parser CompileResult ?
04:04:35 <ski> ('many0' is an example of a deterministic parser (when taking a semideterministic parser as argument) ..)
04:04:57 <ski> goltrpoat : oh, you're approaching it that way .. hmm
04:05:16 <apfelmus> dons: thanks. but i won't make a Fully Fraudulent Impurity call :)
04:06:56 <Cale> apfelmus: is this for some sort of job application?
04:07:03 <quicksilver> ski: it enables you to be precise about which parts can fail
04:07:24 <quicksilver> ski: that may or may not just work out as more book-keeping
04:07:43 <goltrpoat> that's more or less exactly what hutton and meijer did, no?
04:07:54 <goltrpoat> at least as far as the String -> (a, String) bit is concerned
04:08:05 <ski> quicksilver : yes (which is a good thing) .. but i'm not sure it's the Right Way(TM) to do it ..
04:08:20 <ski> and i need to think about how this fits together, i think
04:08:22 <apfelmus> Cale: me? it's for fun :) some guy named Jeff Bone @ this company asked if it can be done in Haskell. the most interesting part is to get everything tun in O(log n).
04:08:36 <goltrpoat> Parser was then turned into State a of sorts, iirc
04:08:55 <ski> goltrpoat : are you referring to some paper ?
04:09:02 <goltrpoat> yeah, monadic parser combinators
04:09:18 <ski> (apfelmus : 'it' being ?)
04:09:27 <apfelmus> Cale: he told me that the python version takes 1-3 minutes and i want to beat that
04:09:49 <apfelmus> ski: http://hpaste.org/840, http://www2.rgmadvisors.com/public/problems/orderbook/
04:10:00 <Cale> that ought not to be too hard, theoretically
04:10:34 <apfelmus> yeah, the easiest part was to get a theoretical O(log n) :)
04:10:34 <Cale> (Unless the python somehow manages to do lots of the work in library calls written in C)
04:11:42 <Cale> I'd expect the constant factor on typical python programs to be higher than typical GHC programs.
04:12:43 <apfelmus> me too. but my first (unoptimized) haskell version took 8 minutes and now, it got even worse :)
04:13:38 <apfelmus> the program spends most time in IO
04:15:36 <Cale> How was the parser written originally?
04:16:03 <goltrpoat> how big is the file?
04:17:07 <apfelmus> goltrpoat: pricer.in from the problem page is 27MB. but running times depend on target_size as well
04:17:55 <apfelmus> Cale: map (read . words) . lines -- something like that :)
04:18:20 <apfelmus> (map read) of course
04:18:25 <Cale> did you try the trivial translation to Data.ByteString operations?
04:18:29 <goltrpoat> what happens if you switch to block buffering mode with a relatively large block size, a few hundred k or so?  just curious, i don't really know anything about optimizing IO
04:18:45 <dons> what kind of dta is in the file?
04:18:50 <goltrpoat> csv
04:19:07 <Cale> ssv?
04:19:13 <apfelmus> yeah, ssv :)
04:19:18 <goltrpoat> hehe
04:19:27 <apfelmus> but you can look it up under http://www2.rgmadvisors.com/public/problems/orderbook/
04:19:28 <dons> 27MB suggests a lazy bytestring. then use a custom parse to grok the contents. for C speed you'd pop the head off each chunk and parse that (like the sum-col code on the shootout)
04:19:29 <lambdabot> Title: Order Book Programming Problem
04:19:52 <dcoutts> SpecConstr!
04:19:59 <dons> SpecConstr!
04:20:04 <dons> yes, perform a manual specConstr
04:20:10 <dons> e.g. http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=2
04:20:12 <lambdabot> Title: sum-file Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/2pxuqt
04:20:20 <dons> that's easily outperforms C on say, 100M files.
04:20:25 <apfelmus> ??
04:20:51 <dons> (and optimisation in GHC that we hope will do utomagically what I've done manually above)
04:21:51 <dons> apfelmus: see the sum-col code. a lazy stream of chunks,  you align each chunk end on line boundries, then process them as strict bytestrngs. ghc can generate rather good code for tight strict bytestring loops
04:22:21 <dons> that's how I'd do it, for a speed contest, anyway
04:22:50 <dons> ?users
04:22:50 <lambdabot> Maximum users seen in #haskell: 339, currently: 301 (88.8%), active: 32 (10.6%)
04:23:26 <Cale> The use of the word "now" in that comment there is interesting :)
04:23:47 <apfelmus> well, i'm too lazy to write hand-coded loops myself. some parser combinators faster than (map read . words) would be nice.
04:24:21 <Cale> words :: ByteString -> [ByteString]
04:25:08 <Cale> there are also specialised readInt and readInteger functions here
04:25:14 <Cale> (for ByteStrings)
04:25:40 <quicksilver> dons: how do you get the chunks to end on line boundaries?
04:25:45 <apfelmus> oh, i missed them. but they're no combinators for them, are there?
04:25:59 <dons> quicksilver: see the alignment code at the top
04:26:00 <apfelmus> i'll try dons' link
04:26:07 <roconnor> > iterate (\z -> z^2+1/4) 0
04:26:09 <lambdabot>  [0.0,0.25,0.3125,0.34765625,0.3708648681640625,0.38754075043834746,0.4001878...
04:26:15 <Cale> uh, what is cycle doing in Data.ByteString.Lazy.Char8 ?
04:26:30 <dons> oh, yes, you mean, the wrong cycle, Cale?
04:26:34 <Cale> cycle :: [a] -> [a]
04:26:34 <Cale> cycle ties a finite list into a circular one, or equivalently, the infinite repetition of the original list. It is the identity on infinite lists.
04:26:39 <Cale> that one :)
04:26:41 <dons> that's fixed in the darcs branch
04:26:43 <Cale> ah
04:26:45 <roconnor> > iterate (\z -> z^2+1/4) (0::Rational)
04:26:47 <lambdabot>  [0%1,1%4,5%16,89%256,24305%65536,1664474849%4294967296,7382162541380960705%1...
04:26:49 <dons> its a missing 'hidding'
04:26:55 <Cale> ah, okay
04:27:07 <dcoutts> dons, btw, is that fix in base for the ghc-6.6 branch?
04:27:13 <dcoutts> so it'll get into 6.6.1
04:27:40 <Cale> So it's been imported and reexported from there?
04:28:48 <roconnor> > (iterate (\z -> z^2+1/4) 0)!!100
04:28:50 <lambdabot>  0.4906042201293854
04:30:24 <dons> dcoutts: not yet. hmm.
04:30:35 <dons> so there are a few stable branch patches like that.
04:30:45 <dcoutts> dons, though technically that one is an api change
04:30:48 <dons> but we've not really kept fps-stable as a proper stable branch
04:31:02 <dons> its accumulated other api changes too (the CString changes)
04:31:08 <dcoutts> s'ok
04:31:18 <dons> i'd be inclined to just merge fps-stable into stream unstable, fix that when you're here, then put that in for 6.8
04:31:20 <dcoutts> we can move over just the few that are not api changes
04:31:28 <Cale> > let fac n = product [1..n]; dfac n = product [n, n-2 .. 1] in 2 * sum [ fac n / dfac (2*n + 1) | n <- [0..100]]
04:31:29 <dons> and try to kick ghc 6.8 along a bit earlier ;)
04:31:29 <lambdabot>  3.1415926535897922
04:31:35 <dons> yeah. we can do that
04:32:12 <dcoutts> dons, but yes, we should also merge the fixes (like CString changes) into the fps-unsable branch
04:32:28 <quicksilver> fps-unusable branch? :P
04:32:54 <dcoutts> dons, btw, do you or rl have any streams code lying about that I need to merge into the streams code I'm working on?
04:32:55 <dons> so there's changes from -stable to move into the stream branch, a few.
04:32:57 <dons> like nhc98 support
04:33:14 <dons> i don't think so. though rl might have some good stuff in the ndp array lib
04:33:31 <dons> he's busy benchmarking on the new box this week
04:34:21 <fasta> lifting impossible? at http://pastebin.ca/384893
04:34:47 <Cale> > 2 * sum [ product [1..n] / product [3,5..2*n+1] | n <- [0..100]]
04:34:48 <lambdabot>  3.1415926535897922
04:34:58 <nornagon> cute
04:35:01 <dons> that's nice.
04:36:04 <quicksilver> dons: ah, had to read that 4 times before I understood you had interleaved the chunk-breaking code with the actualy work-doing code
04:36:17 <quicksilver> dons: is that necessary? it would look cleaner with the chunk-breaker as a separate bit
04:36:46 <Cale> I've been up too long to reason about ContT, sorry :)
04:36:59 <apfelmus> quicksilver: harhar, the power of raw speed is everything but not clean
04:37:25 <quicksilver> apfelmus: well, fps is pretty clean, (in use)
04:37:35 <quicksilver> the goal of fps is to make idiomatic programs fast, I thought
04:37:40 <Cale> yeah, it is
04:37:59 <dons> this is shootout code. we don't just want to be 2x slower and idiomatic
04:38:04 <quicksilver> dons: *nod*
04:38:05 <dons> we want to be 2x faster and ruthless
04:38:14 <apfelmus> quicksilver: sure, enough. but for the shootout, "fast" is not the same "raw power of speed" :)
04:38:23 <quicksilver> dons: so the answer is that if you break out that use of 'add' you slow it down?
04:38:25 <dcoutts> the research work is on making those shootout programs idiomatic
04:38:46 <dons> quicksilver: well, maybe. i just hand optimised the code till the asm looked right.
04:39:02 <dons> it may be perfectly possible to tweak the aligning code a bit
04:39:09 <dcoutts> or equivalently, making the idiomatic programs as fast as the hand written shootout ones
04:39:12 <dons> the main thing is that 'fast path' stuff
04:40:48 <dons> ?wiki Shootout
04:40:48 <lambdabot> http://www.haskell.org/haskellwiki/Shootout
04:41:02 <dons> has a variety of solutions for every problem
04:41:35 <Cale> fasta: why are you trying to lift (return False)?
04:42:01 <fasta> Cale: The result must be of type ContT
04:42:19 <fasta> Cale: Otherwise it's of type MyMonad
04:42:40 <Cale> Uh, which means the whole computation has to be in ContT, which means that the type of return will be inferred to be ContT anyway.
04:43:10 <Cale> If zork v :: MyMonad a, then you want to lift that, not the return.
04:43:30 <ejt> hi
04:43:34 <Cale> hello
04:43:40 <fasta> Cale: of course, you are right, thanks
04:44:07 <Cale> no problem
04:44:28 <ejt> I see that Wadlers pretty print library isn't part of the standard library, do people tend to stick with the Hughes one then ?
04:44:30 <fasta> Cale: well, in my test here, it appears that I do need to lift that value
04:44:43 <Cale> ejt: I have no idea why that is, it really should be.
04:44:47 <fasta> Cale: but you were right about adding a lift to zork
04:45:04 <dons> ejt, only by default. but i wouldn't even know where to get Wadler's code
04:45:16 <dons> there's also the utrecht pretty printer combinators. again hidden away somewhere
04:45:17 <ejt> dons: googling now
04:45:20 <Cale> I have a copy which I transcribed by hand from the paper.
04:45:25 <dons> they should all be cabalised and on hackage
04:45:27 <fasta> Cale: the lift is needed (I verified)
04:45:35 <Cale> fasta: on return?!
04:45:37 <dons> if the code's not on hackage.haskell.org, its second class
04:45:51 <ivanm> dons: or else you don't know about it?
04:45:57 <fasta> Cale: hmm, probably not.
04:46:02 <quicksilver> dons: is the append used to "attach the rest of the line" to the end of the chunk causing a copy of the whole chunk?
04:46:03 <Cale> fasta: You should never have to apply lift to something that's polymorphic in the monad anyway.
04:46:12 <fasta> Cale: my example I am using is more complex.
04:46:17 <fasta> Cale: you are most likely right
04:46:35 <Cale> Maybe if the last line isn't a return, but instead some computation in MyMonad, then you'd have to lift it.
04:46:53 <ejt> can't see it on hackage, I'll just type it in thx
04:46:55 <fasta> Cale: yep, you are
04:47:07 <Cale> ejt: I'll find it and put it on hpaste
04:47:33 <ejt> thx, that would be a big help
04:47:39 <dons> quicksilver: right. costs us a bit , but chunks aren't too big
04:48:10 <Cale> !paste
04:48:10 <hpaste> Haskell paste bin: http://hpaste.org/
04:48:15 <dons> i have a nice (strict) version, its faster and cleaner
04:48:36 <quicksilver> dons: seems like a lazy-append would be nice, there
04:48:46 <hpaste>  Cale pasted "Wadler" at http://hpaste.org/841
04:48:48 <quicksilver> dons: or would that just add an extra indirection to everything and break it?
04:49:14 <dons> quicksilver: compare and contrast with http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=6
04:49:16 <lambdabot> Title: sum-file Haskell GHC #6 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/ys3ony
04:49:27 <dons> yeah, the extra indirection means using a proper lazy bytestring
04:49:27 <Cale> I added that "control" mechanism at some point.
04:49:32 <dons> and ghc doesn't quite optimise those nicely enough for us
04:50:12 <quicksilver> dons: ah right. That version doesn't bother to chunk explicitly at all.
04:50:30 <dons> no. but it reads the entire file strictly
04:50:46 <dons> so uses O(n) space. the spec asks for O(1) space, so we need lazy bytestring io
04:50:49 <Cale> I find it amazing that we can crush C at sum-file.
04:51:06 <dons> but the optimiser needs a strict bytestring to loop on, to generate this nice 10 instruction loop
04:51:21 <dons> Cale, I find it lovely that the C guys rewrote the code based on the Haskell version, and its still slower
04:51:26 <Cale> haha
04:51:34 <quicksilver> dons: what part of that version makes it strict?
04:51:47 <dons> oh hmm. sorry. wrong link.
04:51:56 <dons> that's the much slower fully lazy version
04:52:05 <dons> here's the strict one, http://haskell.org/haskellwiki/Shootout/SumFile#Very_very_fast_but_illegal
04:52:07 <lambdabot> Title: Shootout/SumFile - HaskellWiki, http://tinyurl.com/yv3nd9
04:52:13 <dons> only changes the import, iirc.
04:52:42 <dons> so the open research problem that dcoutts was talking about was to get the lazy version to run as fast as the append/aligned lazy+strict version
04:53:05 <Cale> The Clean code is very competitive and looks nice.
04:53:10 <dons> yeah
04:53:15 <dons> that's what we want to do
04:53:18 <hartman> how can I tell what repo my last darcs get pulled from? eg, command analogous to svn info, which gives you a repo url?
04:53:56 <dons> note the clean code has some nice readIO on file descripts
04:54:09 <quicksilver> dons: changes import and uses unsafe{Head,Tail}
04:54:11 <dons> hartman: cat _darcs/prefs/repo
04:54:36 <quicksilver> so the strict ByteString.getContents is actually a strict read, in contrast to tradition?
04:54:39 <dons> yeah. the unsafeHead is a single readAddrOff# primop too, so that's crucial
04:54:42 <dons> yes.
04:54:49 <fasta> Cale: is that because of the existence of MonadTrans?
04:55:06 <dons> so you can implement a strict [Char] read as:   liftM unpack (Strict.ByteString.readFile f)
04:55:17 * quicksilver nods
04:55:29 <dcoutts_> quicksilver, for the strict ByteString represnetation there's no other way to do it (except lazyness at the OS level ie mmap)
04:55:34 <Cale> fasta: that's just because  lift (return x) = return x, at least, if the thing is actually a monad transformer.
04:55:58 <Cale> (note that the return on the left is not the same one as the return on the right)
04:56:05 <quicksilver> dcoutts_: right. just confirming I understood.
04:56:19 <hartman> dons: thanks. dumb question actually, darcs pull tells you this as well.
04:58:25 <fasta> Cale: the one of the left is the MyMonad return, and on the right the (ContT r MyMonad)?
04:58:35 <Cale> yeah
05:02:06 <quicksilver> Has anyone discussed allowing typeclasses to be annotated with (some of) their equations? A compiler could then have a special mode where it instruments code with appropriate assertions
05:04:12 <kolmodin> dons, dcoutts: any progress on making LPS [B.ByteString] into LPS !B.ByteString [B.ByteString] ?
05:04:25 <kzm> I'm using 'splitWhen p = groupBy (\x -> not . const p x)' quite a bit -- is this anywhere in the standard libs?
05:04:35 <dcoutts_> kolmodin, some, but I'm currently QC'ing list & stream code
05:04:53 <kzm> kolmodin & co: what's the advantage?
05:05:52 <kolmodin> kzm: very much faster head-function
05:06:11 <kolmodin> kzm: which is used in most parsing, etc.
05:06:23 <kzm> good point.
05:06:41 <kolmodin> kzm: in the binary-library we implemented it that way
05:07:02 <kzm> any performance numbers?
05:07:04 <kolmodin> so the state isn't a [ByteString], but rather !Bytestring [ByteString]
05:07:37 <kolmodin> kzm: I rewrote the Get-monad this way, it got from 3x to 15x faster
05:07:41 <dcoutts_> kzm, we think it can get you as much as a 10x factor
05:08:05 * kzm rubs his hands in anticipation.
05:08:10 <kolmodin> yep, depends on what you do, but it sure is conciderably much faster
05:10:06 <ttmrichter> Thanks for the help, dons.
05:11:11 <quicksilver> kolmodin: what's "LPS" in this context?
05:11:55 <kzm> quicksilver, lazy bs constructor?
05:12:20 <quicksilver> ah nods
05:13:08 <quicksilver> so a lazy bytestring is a list of strict bytestrings but, in fact, we know it's a list of at least one element always?
05:13:42 <dcoutts_> quicksilver, no, it could be empty
05:14:22 <quicksilver> dcoutts_: but 'empty' is a list containing one bytestring of length 0?
05:14:42 <quicksilver> dcoutts_: or otherwise how can you perform the translation kolmodin is talking about?
05:15:26 <SamB> hmm, how do you write a subtitle in LaTeX?
05:15:39 <ibid> depends on the document class
05:15:52 <SamB> how about article?
05:16:10 <ibid> \title{Main title\\Subtitle} is what i use
05:16:24 <ibid> sometimes with some font stuff included
05:16:42 <dcoutts_> quicksilver, ok, for a special purpose you could use a 0-length bytestring, but that's generally not what we do, we generally disallow 0-length chunks.
05:17:04 <dcoutts_> quicksilver, currently the LPS data invariant is that there are no 0-length chunks
05:17:31 <quicksilver> dcoutts_: ah ok. But then you can't make the constructor LPS !B.ByteString [B.ByteString], as kolmodin requests, can you?
05:18:18 <dcoutts_> quicksilver, I was going to do something like: data LazyByteString = End | Chunk !ByteString LazyByteString
05:18:27 <kolmodin> hmm
05:18:34 <dcoutts_> quicksilver, but you could do: data LazyByteString = Chunk !ByteString LazyByteStrin
05:18:43 * quicksilver nods
05:18:49 <dcoutts_> and then represent the end by a 0-length chunk
05:18:55 <kolmodin> hmm? how would that string end
05:19:00 <kolmodin> ah
05:19:13 <dcoutts_> empty = Chunk B.empty undefined
05:19:16 <kolmodin> aye
05:19:24 <quicksilver> well I meant Chunk B.empty []
05:19:26 <dcoutts_> note the _|_ at the end there :-)
05:19:35 <kolmodin> yeah :)
05:19:47 <quicksilver> I'm not too keen on using undefined to represent stuff but maybe that's irrational
05:19:51 <kolmodin> which makes QC extra important
05:20:08 <SamB> ibid: thanks, that works pretty nicely
05:20:17 <kolmodin> I don't care as long it's correct and lightning fast
05:20:18 <kolmodin> :D
05:20:26 <dcoutts_> @yarr!
05:20:26 <lambdabot> Prepare to be boarded!
05:24:45 <dcoutts_> kolmodin, the point about the data LazyByteString = End | Chunk !ByteString LazyByteString is that we'd need SpecConstr to help us
05:25:09 <dcoutts_> functions on that type should be specialised on the Chunk case
05:25:27 <dcoutts_> and the unknown case should just do the case analysis and call the specialised chunk case
05:26:29 <kzm> dcoutts, does that (specconstr) get rid of the multiple constructor overhead?
05:26:42 * kzm should just look it up, I guess.
05:26:47 <dcoutts_> kzm, not exactly
05:27:09 <dcoutts_> it's about making versions of functions specialised on various shapes of a data value
05:27:17 <dcoutts_> eg End | Chunk
05:27:45 <dcoutts_> if you statically know the shape of the data when you call the function then you can call the specialised version
05:27:59 <kolmodin> dcoutts_: yeah, I figured
05:28:37 <Saizan> (wow, i get a 33% speedup on Binary/UArray code using 6.7.20070129 instead of 6.6)
05:28:41 <nornagon> heh
05:28:43 <nornagon> http://en.wikipedia.org/wiki/Unix_beard
05:28:49 <kzm> Saizan, GC overhead?
05:29:08 <Saizan> yeah, from 10% to 5%
05:29:15 <kolmodin> dcoutts_: that would be excellent. is it hard to implement?
05:29:42 <dcoutts_> kolmodin, it's already implemented
05:29:42 <Saizan> it uses -33% memory too
05:30:24 <kolmodin> dcoutts_: it's in head?
05:30:30 <dcoutts_> kolmodin, yup
05:30:46 <dcoutts_> there's some limited SpecConstr in 6.6 too
05:31:16 <kolmodin> very cool
05:31:33 <dcoutts_> dons, you know how SpecConstr is only enabled at -O2 currently, and it's not clear if it's a win everywhere hence not on at -O. I was thinking it might be useful to have a pragma like UNPACK to say, for this data type, specialise on these constructors
05:32:30 <dcoutts_> dons, eg data L.ByteString = End | {-# SPECIALISE #-} Chunk {-# UNPACK #-} !B.ByteString L.ByteString
05:32:46 <dcoutts_> dons, ie only spec on the Chunk constructor there
05:33:21 <dcoutts_> so you'd always just have two versions, the general version and the chunk version, the general version would call the chunk version so you'd get almost no code duplication
05:33:34 <dcoutts_> it's almost like a function with multiple entry points
05:33:47 <dcoutts_> or an extended wrapper/worker transformation
05:34:30 <dcoutts_> dons, the point being that then we could annotate the Stream state types and get specialisation where we know we need it, without making everyone use -O2 everywhere.
05:40:35 <SamB> not much point in having -O2 if you always have to use it, is there?
05:41:26 <chessguy> salutations and other such pleasantries
05:42:47 <chessguy> ?losers
05:42:47 <lambdabot> Maximum users seen in #haskell: 339, currently: 310 (91.4%), active: 33 (10.6%)
05:45:45 <CosmicRay> dons: hey, did all my hackage uploads look good?
05:46:03 <chessguy> so, i tried to set up haskell-mode on my emacs this morning. but the installation instructions said to modify ~/.emacs   ....which doesn't exist.
05:46:06 <chessguy> do i just create it?
05:46:47 <ejt> y
05:47:06 <CosmicRay> is there a haskell mode for vim?
05:48:17 <SamB> chessguy: have you .emacs.el?
05:48:26 <SamB> if not, yeah, just create one of the two...
05:48:33 <chessguy> no, i have neither
05:48:51 <chessguy> there was a directory, something like .emacs.ed i think
05:49:20 <chessguy> but all it had in it was an empty subdir
05:59:31 <ski> @hoogle newArray
05:59:32 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
05:59:32 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
05:59:32 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
05:59:41 <ski> why is there duplicate entries ?
06:00:15 <chessguy> good question
06:18:35 <Igloo> Hmm, isn't "hugs -Fcpp" supposed to work?
06:22:02 <DynWind> @seen bschemi
06:22:02 <lambdabot> I haven't seen bschemi.
06:27:52 <allbery_b> @seen beschmi
06:27:52 <lambdabot> I saw beschmi leaving #haskell and #darcs 16h 38m 59s ago, and .
06:28:29 <DynWind> ah, thanks
06:30:42 <kolmodin> CosmicRay: you posted a blog entry about living on the country side, with sunsets, etc. right? look at this.. http://picasaweb.google.com/kolmodin/VariousSunsets
06:30:44 <lambdabot> Title: Picasa Web Albums - Lennart Kolmodin - Various Sunsets
06:44:53 <norpan> gothenburg has nice pollution
06:45:20 <hpaste>  mm annotated "Parsec Trouble" with "Where's `integer from?" at http://hpaste.org/836#a2
06:45:43 <CloudiDust> Hi all, I am playing with the Santa Claus Implementation in Beautiful Concurrency, but there seems to be something wrong with threadDelay that it does NOT delay at all and some outputs are interleaved. How can I correct them?
06:46:45 <Cale> CloudiDust: hmm, it doesn't?
06:47:07 <CloudiDust> It seems so.
06:47:46 <Cale> Open ghci, type :m + Control.Concurrent to load that module, and then  threadDelay (10^7)
06:47:54 <Cale> and see what happens
06:49:11 <Cale> (should be a 10 second pause)
06:50:13 <Cale> If you want, paste the code that you're running, and I'll try it out, and have a look
06:50:16 <Cale> !paste
06:50:16 <hpaste> Haskell paste bin: http://hpaste.org/
06:50:24 <CloudiDust> Oh, it works, I suppose it's unit is ms and used 10000 in this case....
06:50:34 <Cale> Yeah.
06:50:47 <Cale> 10000 is a very short delay
06:51:41 <Cale> It's in microseconds actually.
06:52:09 <CloudiDust> Thank you. And could you tell me how I can deal with the output challenge?
06:52:28 <Cale> er, what seems to be the problem?
06:53:40 <Cale> which program from the paper are you running?
06:54:09 <CloudiDust> When I use putStrLn in 10 threads (each prints a line), the strings are printed one by one without newlines.
06:54:39 <DynWind> gtk/Graphics/UI/Gtk/Abstract/Container.chs:202:7:
06:54:45 <DynWind>     Could not find module ystem.Glib.GList':
06:54:58 <DynWind> trying to build gtk2hs. What's wrong?
06:54:58 <CloudiDust> Then followed by ten newlines....
06:55:26 <dcoutts_> DynWind, latest version, darcs, tarball, os, ghc version?
06:55:53 <pitecus> how do i pick a random element from a list?
06:55:55 <Cale> Uh, can I see your code?
06:55:59 <Igloo> CloudiDust: If you want non-interleaved output then you'll have to send messages to a single thread to print out
06:56:00 <Cale> I don't get that behaviour.
06:56:02 <dcoutts_> DynWind, I mean are you using the latest version of Gtk2Hs, are you using the release tarball or the darcs version?
06:56:22 <dcoutts_> DynWind, and what version of GHC are you using and what OS are you on?
06:56:27 <DynWind> gtk2hs-0.9.11 tarball, Slackware 11, ghc-6.6
06:56:29 <Cale> but yeah, probably the smart thing to do is what dcoutts said
06:56:42 <Cale> er, no
06:56:45 <Cale> Igloo :)
06:56:56 * uccus wonders how frequently Haskellers run into this... mess...
06:57:04 <Cale> uccus: mess?
06:57:07 <dcoutts_> DynWind, you're not doing make -j2 are you?
06:57:11 <DynWind> nope
06:57:27 <uccus> which version... which platform... which build... or which machine...
06:57:28 <pitecus> something like random.choice in python??
06:57:36 <Cale> pitecus: generate a random number from 0 to length xs - 1, and use !!
06:57:42 <chessguy> uccus: that's standard for open source
06:57:49 <dcoutts_> DynWind, so if you hit make again, it gets stuck in exactly the same place?
06:57:59 <uccus> chessguy: sad
06:58:00 <DynWind> hmm, I did do make -j2 first, then killed it before it completed
06:58:07 <DynWind> dcoutts_: yes, same place
06:58:11 <chessguy> oh pitecus, i have that exact code if you want it
06:58:13 <DynWind> let me do a fresh build
06:58:14 <Cale> uccus: How is that not an issue for every piece of software ever?
06:58:24 <pitecus> Cale, thanks
06:58:25 <dcoutts_> DynWind, hmm, yeah, try from clean without -j2
06:58:35 <pitecus> chessguy, yes please
06:58:55 <Cale> pitecus: (If you need more detail in that description, just ask :)
06:58:57 <uccus> Cale: well... isn't abstraction the weapon against mass wrinkles?
06:59:13 <chessguy> !paste
06:59:14 <hpaste> Haskell paste bin: http://hpaste.org/
06:59:26 <CloudiDust> Cale: deliverToys id = putStrLn ("Reindeer " ++ show id ++ " is now delivering toys!") and then each elf has its own thread to call this function simultaneously.
06:59:31 <Cale> uccus: No matter how abstract you make your code, if you do more than one release of it, versions are going to be an issue.
07:00:15 <hpaste>  chessguy pasted "Choose a random item in a list" at http://hpaste.org/842
07:00:35 <chessguy> pitecus: ^^
07:00:46 <pitecus> cool thanks chessguy
07:01:38 <Cale> chessguy: er, that's a pretty awkward way to do that
07:02:43 <Cale> If you're going to use a monad to carry around a random number generator, I have a nice module which does it cleanly.
07:03:21 <chessguy> well, in my code, i plan on "carrying around" more than just the RNG
07:03:29 <Cale> ah, okay :)
07:03:32 <chessguy> anyway, this was just an example
07:04:52 <hpaste>  Cale annotated "Choose a random item in a list" with "simpler" at http://hpaste.org/842#a1
07:05:08 <Cale> er, missed a paren when pasting.
07:05:16 <chessguy> ewww, impure
07:05:42 <chessguy> and hides what's really going on
07:05:44 <Cale> Well, the operation is impure. Doesn't necessarily mean it has to be in IO, but this is the easiest way for the common case.
07:06:07 <Cale> However, I didn't write MonadRandom for nothing :)
07:06:30 <chessguy> how would you use MonadRandom for this?
07:07:24 <hpaste>  Cale annotated "Choose a random item in a list" with "MonadRandom" at http://hpaste.org/842#a2
07:08:00 <Cale> almost the same deal
07:08:34 <Cale> you could even give it a more polymorphic type if you want
07:09:05 <hpaste>  Cale annotated "Choose a random item in a list" with "extra polymorphism" at http://hpaste.org/842#a3
07:10:01 <Cale> Then it would work in any monad that had been RandT transformed, or otherwise had an instance of MonadRandom.
07:11:27 <chessguy> so in my example, i would want to do instance GlobalState MonadRandom where... ?
07:11:44 <chessguy> err, other way around
07:14:08 <Cale> yeah
07:15:03 <Cale> Hopefully some version of MonadRandom will end up in the standard libs at some point.
07:15:18 <chessguy> or could i use this somehow: nstance (MonadState s m, RandomGen g) => MonadState s (RandT g m) where
07:16:17 <Cale> wha?
07:16:21 <Cale> oh
07:16:22 <Cale> yeah
07:16:53 <Cale> If you RandT transformed your monad.
07:17:23 <chessguy> oh, by stacking it on an instance of RandomGen
07:18:34 <CosmicRay> kolmodin: NICE!
07:18:48 <kolmodin> :)
07:19:01 <chessguy> man, no matter how many times i hear this stuff, it always blows my mind
07:19:50 <kc5tja> morning.
07:20:16 <Cale> dons: I just updated some of the "extra" code on the MonadRandom page -- I seem to recall you mentioned you were cabalising it?
07:20:36 <Cale> The lifting instances were incomplete.
07:21:06 <Cale> (and the instance for IO)
07:21:22 <Cale> I think the reason that code hadn't gotten updated is that I didn't write it :)
07:34:04 <Saizan> if you were going to split a "-----------------------------204422229725955"  separated string (the real separator is known only at runtime), and then fetch some fields from each chunk, what would you use? something with tails and isPrefixOf? parsec?
07:35:25 <Cale> Those sound like decent options.
07:36:53 <Cale> If the separator is not a single token, it's probably best to use something like Parsec.
07:37:05 <Cale> (and don't forget about try)
07:37:31 <Saizan> (right)
07:37:39 <Cale> There are decent regex libraries too, now.
07:38:49 <Philippa> well, modulo the oxymoron factor
07:39:00 <Saizan> uhm, i feel a bit unsecure using regexes
07:39:03 <kzm> Saizan: I just did something similar.  Started out with Parsec, but it was overkill for this, and ended up just using groupBy ...$ lines input
07:39:21 <Saizan> i fear that a corner case is there waiting for me
07:39:41 <kzm> Saizan, if you're doing MIME, it's all going to be exact matches anyway, no?
07:39:54 <Cale> Yeah, regexes are scary.
07:40:00 <Saizan> kzm: parsing a multipart/form-data?
07:40:42 <Cale> Other than the fact that regexes are an awful way to specify grammars, the libraries themselves are not bad ;)
07:41:03 <kzm> let splitWhen p = groupBy (\_ y -> null y || not (p y)) in splitWhen (isPrefixOf ">") ["foo",">bar","zot",">brof","gnoph"]
07:41:10 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-Context.html -- there's some pretty cool capacity for context-dependent results.
07:41:11 <kzm> > let splitWhen p = groupBy (\_ y -> null y || not (p y)) in splitWhen (isPrefixOf ">") ["foo",">bar","zot",">brof","gnoph"]
07:41:12 <lambdabot> http://tinyurl.com/yovda9
07:41:12 <lambdabot>  [["foo"],[">bar","zot"],[">brof","gnoph"]]
07:41:38 <kzm> @pl (\_ y -> null y || not (p y))
07:41:38 <lambdabot> const (liftM2 (||) null (not . p))
07:41:43 <kzm> If you prefer.
07:42:00 <kzm> @pl groupBy (\_ y -> null y || not (p y))
07:42:01 <lambdabot> groupBy (const (liftM2 (||) null (not . p)))
07:42:06 <kzm> :-)
07:43:37 <kzm> Saizan, did that make sense?
07:43:51 <Saizan> kzm: yes
07:44:11 <kuribas> What's the purpose of the (->) Monad?
07:44:29 <Cale> kuribas: supplying parameters to things implicitly
07:44:48 <Cale> > sequence [(+1), (*2), (^2)] 5
07:44:54 <Cale> > Control.Monad.sequence [(+1), (*2), (^2)] 5
07:44:55 <lambdabot>  [6,10,25]
07:45:03 <Cale> > join (*) 5
07:45:05 <lambdabot>  25
07:45:10 <Cale> join (,) 5
07:45:12 <Cale> > join (,) 5
07:45:14 <lambdabot>  (5,5)
07:45:22 <Cale> > ap (+1) 5
07:45:23 <lambdabot>   add an instance declaration for (Num ((a -> b) -> a))
07:45:27 <Cale> > ap (,) (+1) 5
07:45:29 <lambdabot>  (5,6)
07:45:53 <Cale> > ap (zipWith (+)) tail [1,2,3,4]
07:45:54 <lambdabot>  [3,5,7]
07:46:19 <kuribas> It's like the reader Monad?
07:46:33 <Cale> It is the Reader monad, just without the newtyping.
07:46:35 <nominolo> @karma Cale
07:46:36 <lambdabot> Cale has a karma of 43
07:46:42 <mux> @karma
07:46:43 <lambdabot> You have a karma of 2
07:46:49 <mux> could be worse
07:47:25 <Cale> It's nice for situations where the Reader monad would be appropriate, only it's too syntactically heavy.
07:47:49 <Cale> Lots of the Control.Monad functions specialise to really useful operations in the ((->) e) monad.
07:47:53 <roconnor> @hoogle (a,m b) -> m(a,b)
07:47:55 <lambdabot> Prelude.snd :: (a, b) -> b
07:47:55 <lambdabot> Prelude.fst :: (a, b) -> a
07:47:55 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
07:48:19 <quicksilver> roconnor: that's liftM ((,) a)
07:48:36 <Cale> If it were in the libraries, it'd be called strength
07:48:37 <quicksilver> well that's one way of looking at it, at least
07:49:06 <Saizan> strength?
07:49:13 <Cale> http://en.wikipedia.org/wiki/Strong_monad
07:49:47 <Cale> Every Haskell monad is strong.
07:50:43 <kuribas> I have a question about the list Monad.
07:50:48 <Cale> go for it :)
07:50:51 <roconnor> I'm trying to understand the relation between that definition and the the fact that there is an arrow from (b^a) to (m b)^(m a) (where b^a means a -> b)
07:51:02 <kuribas> >  do Left x <- [Left 1, Right 2, Left 3]; return x
07:51:03 <lambdabot>  [1,3]
07:51:21 <kuribas> > [Left 1, Right 2, Left 3] >>= \(Left x) -> return x
07:51:23 <lambdabot>   Non-exhaustive patterns in lambda
07:51:35 <kuribas> Why does the first work, but the second not?
07:51:48 <Cale> because the do-syntax isn't *really* defined like that
07:51:49 * mux hangs his head in his hands and makes a mental note never to open a link given by Cale again
07:51:59 <Cale> mux: haha
07:52:46 <Saizan> when a pattern match in a do fails the "fail" method is called, and for the List monad fail _ = [], right?
07:52:46 <kuribas> Cale: So the first is a special case of do syntax, that happens to work?
07:52:56 <mux> Saizan: yes
07:53:12 <quicksilver> kuribas: do (pattern) <- foo; is translated into (foo >>= \x -> case x of (pattern) -> ... | _ -> fail)
07:53:20 <cjeris> Cale: article lacks enough arrows
07:53:21 <quicksilver> kuribas: roughly
07:53:29 <Cale> kuribas: do { pat <- expr; stmts } = let ok pat = do {stmts}; ok _ = fail "..." in expr >>= ok
07:53:58 <Cale> The use of fail is unfortunate.
07:54:14 <Cale> There was a better translation of do-notation in Haskell 1.4.
07:54:53 <kuribas> Oh, that's why it works :)
07:54:53 <Saizan> mzero?
07:55:46 <kuribas> Cale: What's wrong with this translation?  I imagine it can be useful...
07:55:56 <kc5tja> cale: I can't understand the strong monad chart, but there is a symmetry to it with some of the monadic properties/laws documented elsewhere, it seems.  Am I correct in assuming that the (X) (what I traditionally knew as the XOR symbol) symbol stands for "any function?"  Or, does it refer to a monadic function specifically?  (E.g., >>=)
07:56:03 <Cale> :t let strength (x,m) = fmap ((,) x) m in strength
07:56:06 <lambdabot> forall t (f :: * -> *) a. (Functor f) => (t, f a) -> f (t, a)
07:57:07 <Cale> kc5tja: In Haskell, it's (,)
07:57:42 <Cale> kc5tja: It's the operation on objects which makes your category monoidal -- usually a "Cartesian product" like operation.
07:58:00 <kc5tja> OK, I don't know what (,) does in particular.  I'll stop while I'm ahead.
07:58:08 <Cale> Oh
07:58:26 <Cale> (,) is the type constructor (and data constructor, but not here), for pairs
07:58:46 <Cale> So, (5,"Hello") :: (Integer, String)
07:58:54 <Cale> which is sugar for (,) Integer String
07:59:15 <kc5tja> Oh, I never thought of , as a function.  :)
07:59:49 <Cale> > (,) 5 "Hello"
07:59:51 <lambdabot>  (5,"Hello")
08:00:14 <Cale> It works on the value level too :)
08:00:22 <norpan> > (,,,) 5 "Hello" True (Left 1)
08:00:24 <lambdabot>  (5,"Hello",True,Left 1)
08:00:41 <Cale> Caterpillars
08:01:17 <kc5tja> Now, the above is equivalent to: ((,),(,)) ... right?
08:01:39 <sieni> nope
08:01:39 <Cale> Basically, those diagrams just express various equations combining the monad operations with this "strength" function
08:02:24 <Cale> In Haskell, what that page calls t_A,B has type (Monad m) => (a, m b) => m (a,b)
08:02:58 <Cale> kc5tja: tuples of different lengths are entirely separate types
08:03:35 <Cale> and are not related. Partly for this reason, it's uncommon to see tuples larger than pairs in Haskell.
08:04:23 <Saizan> ndm: have you used GLUT on windows?
08:04:43 <ndm> Saizan: never gone near any 3D style thing at all
08:04:55 <kc5tja> sieni: So it's (,(,(,))) then?
08:05:04 <sieni> for example (undefined,5) is of type ((Integer,Integer),Integer), but you can't easily map that to any element of (Integer,Integer,Integer)
08:05:07 <Saizan> k.thanks
08:05:26 <Saizan> kc5tja: no, it's (,,,)
08:05:51 <roconnor> hmm
08:05:57 <Cale> The first diagram says  fmap snd . strength = snd
08:06:28 <kc5tja> OK, that just doesn't make logical sense to me.  But, I have to get to work, so I'm going to abort this thread of thought.  :)
08:06:34 <sieni> > let ((x,y),z) = (undefined,4) in z
08:06:35 <lambdabot>  Undefined
08:06:46 <sieni> whatever
08:07:03 <roconnor> I claim that a monad is strong (in a CCC) when map : b^a -> (m b)^(m a) is a morphism.
08:07:12 <roconnor> but now I can't find where I read that
08:07:16 <Cale> > let (~(x,y),z) = (undefined,4) in z
08:07:17 <lambdabot>  4
08:07:28 <kc5tja> sieni: whatever?  Well, I'm sorry, but work doesn't allow me the liesure time to spend on contemplating these things.  I'm sorry to disappoint.
08:07:53 <Cale> roconnor: I think you're probably right, modulo actually checking all the axioms work out in the general case.
08:08:03 <sieni> kc5tja: I said "whatever" to the lambdabot output :-)
08:08:14 <Cale> :t let strength (x,m) = fmap ((,) x) m in strength
08:08:16 <lambdabot> forall t (f :: * -> *) a. (Functor f) => (t, f a) -> f (t, a)
08:08:20 <glguy> lol, if you work doesn't give you the time to think about what you are doing it before you do it... lazy pattern matches are the least of your worries
08:09:14 <Cale> roconnor: I think it's basically that you translate that definition back into mathematics :)
08:09:18 <roconnor> Cale: if I am going to claim this fact in my thesis, I had better find someone to cite :)
08:09:30 <Cale> Aw, just sit down and prove it :)
08:09:41 <roconnor> I don't know catagory theory.
08:09:52 <fasta> Wil constant be evaluated at most once? in
08:09:52 <fasta> let constant = array <> <>
08:09:52 <fasta>     function a = some_loop using constant within the loop
08:09:52 <fasta> in some_value_eventually calling function foo once.
08:09:54 <roconnor> the cross product doesn't even appear in my definition :P
08:10:23 <dino-> Is it fair to say that everything (or nearly so) in Haskell is a function? Like (,) (->) etc..
08:10:43 <ski> fasta : is 'constant' overloaded ?
08:10:59 <Cale> roconnor: It generalises to the monoidal operation
08:11:07 <fasta> ski: No
08:11:10 <Cale> (whatever that might be in your category)
08:11:12 <Cale> So, hmm
08:11:26 <kc5tja> sieni: Oh -- my bad.  :)
08:11:29 <Cale> Maybe that also has to be the Cartesian product of your category.
08:11:33 <fasta> ski: (it creates a diffarray)
08:11:44 <Cale> If not, I don't see how to prove the result.
08:11:48 <roconnor> Cale: yeah, I'm pretty sure the exponential is related to the product somehow
08:12:09 <roconnor> I mean a^(b*c) must be isomorphic to (a^b)^c
08:12:21 <Cale> oh, absolutely
08:12:25 <Cale> er
08:12:39 <quicksilver> yes, the exponential is the closure of the product
08:12:44 <quicksilver> or the adjoint
08:12:48 <Cale> Is * the product, or the monoidal operation?
08:12:55 <quicksilver> or any of a number of such terms
08:13:01 <quicksilver> dino-: 'yes'
08:13:20 <Cale> a^(b x c) = (a^b)^c is true in any CCC
08:13:23 <chessguy> dino-: as long as you put the word 'nearly' in there, sure
08:13:35 <Cale> as are lots of other reasonable things
08:13:38 <dino-> Using ghci, I see some things that don't seem to have types: = => |
08:13:48 <quicksilver> dino-: right
08:13:51 <quicksilver> dino-: they're syntax
08:13:56 <Cale> dino-: that would be because those aren't values :)
08:14:00 <quicksilver> dino-: there is a little bit of syntax, but not too much
08:14:02 <chessguy> though, even then...type classes, data constructors, etc.
08:14:26 <dino-> But it seems like a whole lot more or what my imperative mind wants to see as syntax is, in fact, not so in H.
08:14:31 <dino-> s/or/of/
08:14:32 <quicksilver> yes
08:14:36 <Cale> Not *everything* is a function, but about as much as it makes sense, it is.
08:14:49 <chessguy> ?hoogle if
08:14:50 <lambdabot> Prelude.if :: keyword
08:14:50 <lambdabot> Foreign.C.Error.throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
08:14:50 <lambdabot> Foreign.Marshal.Error.throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
08:14:53 <chessguy> e.g.
08:14:56 <Cale> There are also things like if, which could be functions, but aren't, but that's the whole point of them.
08:15:13 <quicksilver> dino-: in fact, in [1,2,3], the commas are technically syntax but they're only a thin wrapper around a function
08:15:19 <chessguy> what do you mean "that's the whole point of them?
08:15:28 <quicksilver> dino-: so there are a few edge cases where a bit of sugar has been added
08:15:33 <CosmicRay> does hoogle automatically see uploads to hackage?
08:15:40 <chessguy> CosmicRay: no
08:15:47 <Cale> chessguy: to structure the code in a visible way
08:15:53 <roconnor> Cale isn't the product and the monodial operation the same?
08:16:02 <roconnor> or maybe it is just the same in my case
08:16:08 <Cale> roconnor: not necessarily, but it would be nice :)
08:16:19 <quicksilver> roconnor: in a CCC, yes the monoidal operation under discussion is a product
08:16:23 <chessguy> Cale: surely "if pred thenCase elseCase" would be visible
08:16:27 <chessguy> like bracket
08:16:28 <dino-> When we do a case statement, the lines like 'foo -> bar', those are just calls to the (->) function as well?
08:16:36 <quicksilver> dino-: no, that's a bit more syntax
08:16:42 <quicksilver> dino-: 'foo' there is a pattern, not a value
08:16:43 <Cale> chessguy: The "then" and "else" help to visually pick out the parts of the if.
08:16:48 <roconnor> I'm in a CCC
08:16:56 <roconnor> ... actually I'm not it a CCC, but I'm very close
08:16:59 <dino-> hm. I was hopeful. I mean, they seem to represent 'this -> that' transformation
08:17:00 <roconnor> hmm
08:17:01 <quicksilver> roconnor: of course a CCC might have more than one monoidal :)
08:17:11 <quicksilver> roconnor: but the monoidal which is closed, in the defn, is the product one
08:17:16 <Cale> quicksilver: right, that's my concern :)
08:17:17 <dino-> But, I see, yeah. Pattern
08:17:27 <chessguy> Cale: seems redundant to me, but whatever
08:17:42 <Cale> chessguy: It's for the reader's eyes more than anything.
08:17:46 <quicksilver> well it is redundant, technically, in that lisp does without
08:17:51 <quicksilver> but on the other hand, it's handy
08:18:11 <Cale> Read enough scheme/lisp code and you'll wish you had 'then' and 'else' back :) (or maybe not)
08:18:54 <quicksilver> roconnor: for example, in the haskell category, disjunction (Either) is monoidal too, and it's definitely not closed
08:18:57 <chessguy> ?me ?remembers Cale Read scheme/lisp code
08:18:57 <lambdabot> Maybe you meant: messages messages? . bf ft id let map more msg pl rc time v wn
08:19:14 <chessguy> oops :)
08:19:15 <roconnor> Ah ha, Kock 72 apparently discusses this issue
08:19:27 * quicksilver can't remember if all CCCs necessarily contain disjunction
08:19:49 <Cale> roconnor: another tie you might be interested in: Hom(X x Y, Z) = Hom(X, Z^Y)
08:20:09 <ski> fasta : yes
08:20:17 <quicksilver> that's cheating, that's isomorphic to the one he had before
08:20:17 <Cale> There's always a bijection between those Hom sets -- that's currying.
08:20:51 <ski> what monoidal structure are you talking about ?
08:21:14 <Cale> ski: an arbitrary one (monoidal category)
08:21:43 <ski> (and related monoidal closed category, i assume ..)
08:22:11 <Cale> Ah, that's the term we're probably looking for.
08:22:22 <ski> (Cale : well .. in a sense that bijection is lambda :)
08:22:25 <Cale> monoidal closed = monoidal + CCC with x = (x) ?
08:22:33 <ski> no
08:22:34 <quicksilver> no
08:22:43 <Cale> okay
08:22:44 <quicksilver> monoidal closed is just monoidal + exponent
08:22:49 <Cale> ah, okay
08:22:49 <quicksilver> CCC is an example of monoidal closed
08:22:56 <quicksilver> where the monoid structure happens to be product
08:22:59 <ski> monoidal closed = CCC except the monoidal doesn't havr to be cat. product
08:23:01 <Cale> ah, alright.
08:23:23 <quicksilver> BI for example has a non-cartesian closed monoid in it
08:23:33 <ski> BI ?
08:23:34 <quicksilver> 'separating conjunction'
08:23:39 <ski> (Bunched Implications ?)
08:23:42 <quicksilver> Separation logic, some people call it
08:23:43 <quicksilver> yes
08:23:54 * ski should read about that
08:24:36 <ski> substructural logics often have monoidal closed models
08:25:03 <quicksilver> right. BI is just a particular example.
08:25:10 <Cale> That makes sense.
08:25:18 <quicksilver> It's possible to argue that it's more computationally interesting though
08:25:23 <quicksilver> so closer to being on-topic here
08:25:24 <Saizan> are there more definitions in cat. theory than in the rest of the math?:D
08:25:31 <Cale> Saizan: no
08:25:44 <quicksilver> Saizan: all definitions in category theory turn out to be generalisations of a definition elsewhere
08:25:48 <quicksilver> Saizan: that'st he point, really
08:26:04 <mux> doesn't cat. theory consists of *ony* definitions? :)
08:26:20 <Cale> Category theory seems to have a high definition:theorem ratio at the moment though.
08:26:22 <mux> only even :=
08:26:29 <Cale> There are theorems.
08:26:36 <quicksilver> no, but the theorems are often ahrd to understand.
08:26:46 <Cale> The Yoneda lemma is cool.
08:26:48 <quicksilver> Adjoint Functor Theorems generalise 'Free' construction
08:26:48 <ski> like : products are unique up to isomorphism
08:26:54 <quicksilver> the Yoneda Lemma breaks your brain
08:27:05 <quicksilver> (well, it broke mine)
08:27:18 <norpan> you need some Lemma to patch your brain together again
08:27:30 <norpan> Daniel Lemma perhaps
08:27:37 <Cale> Maybe Gauss' lemma :)
08:28:01 <ski> sigfpe had an interesting post on yoneda
08:28:15 <quicksilver> one of the smart category theory guys I know told me that the Yoneda cannot be explained, understanding it has to be earnt
08:28:19 <Saizan> ehat is it about?
08:28:32 <Cale> Well, that's number theory, so it'll probably just put your brain back together all wrong, and you'll be insane for the rest of your life.
08:29:11 <Cale> Saizan: Gauss' lemma?
08:29:20 <norpan> Gauss's
08:29:38 <Cale> It's a condition for an integer to be a quadratic residue.
08:29:45 <Saizan> yoneda
08:30:54 <Saizan> (i yet "hate" Gauss from my numerical calculus class)
08:31:17 <norpan> let's degauss the lemma
08:31:21 <ski> Cale :D
08:31:21 <Cale> Let F be an arbitrary functor C -> Set. Then for each object A of C, the natural transformations from Hom(A,-) to F are in one-to-one correspondence with elements of FA
08:31:36 <roconnor> damn it, my category isn't CCC
08:31:56 <ski> roconnor : what category is it, btw ?
08:32:16 <roconnor> ski: metric spaces with uniformly continuous functions between them
08:32:31 <roconnor> I have function spaces
08:32:46 <roconnor> but the evaluation map isn't neccesarily uniformly continuous
08:33:06 <ski> hm .. is that a construct over Top ?
08:33:08 <roconnor> but sometimes evaluation is.
08:33:34 <Cale> hmm
08:34:21 <roconnor> but the proof that goes from map being a morphism to the fact that the monad is strong uses eval in a particularly nice case (I think)
08:34:36 <roconnor> a case where I do have a uniformly continuous eval function
08:34:46 <roconnor> so I think the proof still works for me
08:35:14 <Cale> Which monad are you discussing?
08:35:29 <roconnor> ah
08:35:37 <roconnor> The completion monad
08:35:44 <Cale> ah, thought it might be :)
08:36:03 <ski> what is it ?
08:36:05 <Cale> and you want that it's a strong monad?
08:36:35 <roconnor> er not really
08:36:52 <roconnor> I just need that map is uniformly continuous
08:37:04 <roconnor> but when I say that I feel I ought to bring in a discussion about strong monads
08:37:13 <Cale> ski: completion of the metric space -- essentially, take equivalence classes of Cauchy sequences of points in the original space, and you can get a complete metric on that.
08:37:58 <Cale> You need A x MB -> M(A x B) is uniformly continuous?
08:38:29 <roconnor> I think that is the obvious injection
08:38:38 <Cale> Yes.
08:38:55 <roconnor> and it has a modulus of continuity of id presumably
08:39:00 <Cale> (well, that would be the obvious thing anyway)
08:39:15 <ski> Cale : hm, so for Q you get R, then ?
08:39:19 <Cale> ski: yep
08:39:26 <ski> interesting
08:39:35 <Cale> It's kind of a silly monad
08:39:44 <Cale> because T^2 is isomorphic to T
08:39:55 <Cale> So join is not terribly interesting.
08:40:02 <ski> m, right
08:40:33 * ski wonders if there's useful idempotent computational monads
08:41:07 <roconnor> Cale: I never looked at it that way
08:47:32 <Cale> I think the proof that A x CB -> C(AxB) is uniformly continuous ought to be reasonably easy, depending on what you already know.
08:47:43 <Cale> (C is completion)
08:47:55 <Cale> If you know C is an isometry, it's trivial.
08:48:23 <Cale> pick delta = epsilon.
08:49:17 <Cale> er
08:49:45 <Cale> sorry, there's a little more hammering out of definitions than I originally thought, because I haven't slept :)
08:50:38 <chessguy> so what's new?
08:51:23 <Cale> (but still, delta = epsilon should be the trick)
08:52:48 <Cale> er, hmm
08:53:14 <Cale> yes, I'm sticking with it :)
08:56:03 <Cale> Staying up for long periods of time is the evil cousin of lucid dreaming. :)
08:56:48 <quicksilver> Cale: http://xkcd.com/c203.html
08:56:49 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
08:56:50 <mbishop> I slept for a while, felt sick last night :(
08:56:54 <mbishop> still kinda do heh
08:57:22 <Cale> quicksilver: yeah, that's a great one
08:57:34 * mbishop vomits on Cale 
08:57:38 <Cale> heh
08:57:57 <chessguy> umm, mbishop that's generally frowned upon
08:58:14 <mbishop> chessguy: I couldn't help it, it was your cheese smell making me sick
08:58:14 <mbishop> :P
08:58:58 <chessguy> mbishop: you need to read today's xkcd :)
08:59:17 <Cale> Two of the world's most beloved abstract board games, cheese and goo.
08:59:31 <mux> cheese!
09:00:30 <Cale> Hehe, anyone want to have a 9x9 game of go or two?
09:02:43 <roconnor> I hate writing a thesis
09:08:58 <Cale> Heh, I should start a religion to capitalise on the tendency for people to experience deja vu when sleep deprived. The core of the religion will be the postulate that information flows backwards in time from periods where one was most exhausted, to the best dream states earlier in one's life.
09:10:26 <xerox__> Cale, I thought you had founded the naive religion, or what was that called. That one in which you just believed the statement "Believing this statement will make you happy."
09:10:37 <Cale> That too, they will be competitors.
09:11:54 <ski> hm, loeb ?
09:11:54 <Cale> (though I think the simple terminal-object religion will win :)
09:12:18 <Cale> loeb?
09:12:20 <psi`> Cale: I haven't played go in ages, so I probably suck, but sure :)
09:12:21 <xerox__> ski - Please do not loeb Cale's religions, or we will have serious problems.
09:12:34 <xerox__> Oh, Go! who plays go?
09:12:41 <ski> loeb :: Belief (Belief a -> a) -> a
09:12:43 <ski> or something
09:12:58 <Cale> I play go. I'm extraordinarily tired at the moment too, so I don't know how I'll do.
09:13:05 <psi`> I don't have a user anywhere, though.
09:13:07 <ski> well, maybe it was s/Belief/Provable/, but what the heck :)
09:13:10 <emu> what service?
09:13:11 <xerox__> Oh, I probably can't login on KGS from this university computer.
09:13:15 <Cale> I play on KGS.
09:13:20 <Cale> (when I play online)
09:13:42 <xerox__> I try.
09:13:45 <ski> (and it was s/) -> a/) -> Provable a/ too, actually)
09:14:12 <xerox__> Cool, it does work!
09:14:24 <fax> Hi
09:14:30 <emu> my version of CGoban is 2 years old
09:14:31 <xerox__> Cale, playing now?
09:14:45 <Cale> xerox: nope
09:14:55 <Cale> xerox: want a game?
09:14:58 <Cale> 9x9?
09:15:00 <xerox__> Yeah.
09:15:12 <xerox__> I open it.
09:15:30 <ski> (the qouestion would be whether believing that statement would actually make you happy .. or for that matter whether believing it would make you believe you were happy)
09:15:55 <xerox__> Open.
09:16:18 <emu> i prefer the statement: "Not believing in this statement will make you happy."
09:17:12 <ski> hm, is belief a functor ?
09:17:48 <emu> there's a modal logic for it
09:17:49 * psi` managed to get onto kgs as well.
09:18:05 <psi`> i wouldn't mind playing one of you guys (a short 9x9 game)
09:18:10 <fax> what can I use for simple TCP networking in haskell?
09:18:23 <mux> :t connect
09:18:26 <lambdabot> Not in scope: `connect'
09:18:31 <mux> :t Network.connect
09:18:33 <lambdabot> Not in scope: `Network.connect'
09:18:37 <mux> shit :)
09:18:39 <ski> @hoogle connect
09:18:40 <lambdabot> Network.Socket.connect :: Socket -> SockAddr -> IO ()
09:18:40 <lambdabot> Network.connectTo :: HostName -> PortID -> IO Handle
09:18:40 <lambdabot> Network.CGI.connectToCGIScript :: String -> PortID -> IO ()
09:18:41 <fax> I really want to listen though
09:18:44 <mux> yeah, here.
09:18:48 <mux> @hoogle listen
09:18:49 <emu> @hoogle listen
09:18:49 <lambdabot> Network.Socket.listen :: Socket -> Int -> IO ()
09:18:49 <lambdabot> Control.Monad.Writer.listen :: MonadWriter w m => m a -> m (a, w)
09:18:49 <lambdabot> Network.listenOn :: PortID -> IO Socket
09:18:49 <lambdabot> Network.Socket.listen :: Socket -> Int -> IO ()
09:18:49 <lambdabot> Control.Monad.Writer.listen :: MonadWriter w m => m a -> m (a, w)
09:18:51 <lambdabot> Network.listenOn :: PortID -> IO Socket
09:18:53 <fax> cool cheers :D
09:19:04 <emu> @doc Network
09:19:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
09:19:14 <emu> Network by itself is the "easy" module interface
09:19:24 <emu> Network.Socket is more directly to the  BSD API
09:19:28 <fax> ok
09:20:00 <chessguy> quick, someone ask cale a complicated monad transformer question :)
09:20:17 <emu> i think i will have to reinstall java to play on KGS.  someone write a client in haskell.
09:21:25 <ski> Cale : is the Layer monad transformer a monad functor ?
09:21:31 <quicksilver> :t bracket
09:21:33 <lambdabot> Not in scope: `bracket'
09:21:37 <quicksilver> @hoogle bracket
09:21:37 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:21:38 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
09:21:38 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
09:21:52 <ski> @hoogle+
09:21:54 <lambdabot> Text.PrettyPrint.HughesPJ.brackets :: Doc -> Doc
09:21:54 <lambdabot> Text.ParserCombinators.Parsec.Token.brackets :: TokenParser st -> CharParser st a -> CharParser st a
09:22:41 <quicksilver> IO.bracket?
09:22:47 <quicksilver> does that means it's old-style libs only?
09:23:39 <quicksilver> ah, no, it's Control.Exception.bracket
09:23:45 <quicksilver> and hoogle failed to find it
09:24:14 <Cale> chessguy: heh, I'm playing poorly enough as it is :)
09:24:19 <chessguy> :)
09:24:27 <Cale> ski: Layer?
09:24:34 <chessguy> ?hoogle Layer
09:24:35 <lambdabot> No matches found
09:24:50 <Cale> chessguy: If you want to grab KGS, I can go over the rules and so on though :)
09:24:59 <ski> hehe .. it's a monad transformer i dreamed up some while ago .. which combines two monads into a new monad
09:25:07 <psi`> chessguy was in there watching
09:25:09 <Cale> xerox is too close to my level and awake :)
09:25:11 <chessguy> i'm on it. hang on, let me go nuke my lunch
09:25:17 <Cale> oh, right
09:25:19 <ski> (i abstracted it out from a particular application)
09:25:25 <chessguy> brb
09:25:50 <fax> is there some place
09:25:57 <fax> with a bunch of really well written haskell code
09:25:58 <fax> :D
09:26:05 <psi`> Cale: what's your rank?
09:26:07 <fax> or even really badly written, as long as it works
09:26:33 <ski> @hoogle PLEAC haskell
09:26:34 <lambdabot> Did you mean: PLEAC Haskell
09:26:42 <ski> @google PLEAC haskell
09:26:44 <lambdabot> http://pleac.sourceforge.net/pleac_haskell/index.html
09:26:57 <fax> oh thank you :D
09:27:09 <ski> (i believe that is considered 'badly written', or at least 'bad style')
09:27:23 <Cale> psi`: Not completely sure, probably somewhere in the single digit kyus. Right now though, I'm probably a few ranks worse than normal :)
09:27:42 <psi`> okay, cool
09:28:02 <Cale> When I last played a rated game, I beat a 1d reasonably easily with 6 stones.
09:28:25 <quicksilver> hmph. the "IO and lazyness" thread sure makes the point about hGetContents being harmful
09:28:48 <Cale> quicksilver: kind of harmful, kind of not.
09:28:53 <ski> absence of copy-on-write semantics of files ?
09:28:58 <Cale> quicksilver: you certainly have to watch out for it.
09:29:10 <quicksilver> Cale: harmful in the sense that it confused this newbie
09:29:14 <Cale> ah
09:29:18 <quicksilver> Cale: the guy who posted the question
09:29:33 <quicksilver> I think he had good reason to be confused
09:29:44 <quicksilver> it should at least be renamed
09:29:45 <Cale> 1st rule of hGetContents, never call hClose on a handle which has been hGetContents'd.
09:29:53 <fax> this is my entire program: "import Network \n main = do print "hello""
09:29:59 <quicksilver> getDANGERWILLROBINSONAREYOUSUREContents
09:30:13 <fax> any idea why runhaskell that.hs is giving me file name does not match module name `Main'
09:30:21 <fax> its not finding Network module for some reason I think :|
09:30:37 <Cale> fax: module Main where
09:30:42 <Igloo> fax: Does ./Network.*hs exist?
09:30:50 <fax> Igloo: no
09:30:51 <Cale> What's the name of your file?
09:30:56 <fax> er
09:30:58 <fax> network.hs :S
09:30:59 <Igloo> fax: What version of ghc?
09:31:01 <fax> ok I see the error
09:31:06 <chessguy> Cale: ok, where do you want me to go
09:31:26 <Cale> uh, for simplicity, join the Mathematics Room
09:31:49 <Cale> Rooms -> Room List -> Social -> Mathematics
09:32:15 <fax> hm now I changed the file to net.hs and it still says <no location info>: can't find file: network.hs
09:32:23 <Cale> okay
09:32:34 <chessguy> ok
09:32:41 <fax> oh never mind I got it
09:33:07 <Cale> click the game that's appeared with your name on it
09:43:13 <syntaxfree> this is rather off-topic, so I'll ask and request that if there are answers they're give in in #haskell-blah
09:43:27 <syntaxfree> is there a way to run a NNTP server in your own machine and have it sync with the Usenet somehow?
09:44:09 <psnl> you need a feed
09:44:16 <psnl> talk to your isp?
09:44:24 <syntaxfree> aren't there backbone servers or something?
09:44:33 <syntaxfree> I pretty much don't have a ISP :)
09:44:55 <psnl> syntaxfree: yeah, find one and talk to him
09:45:19 <syntaxfree> hmm.
09:45:32 <syntaxfree> propagation of usenet news should be easier.
09:45:51 <syntaxfree> there should be just servers-that-serve-to-servers somewhere on an email-signup basis.
09:46:26 <psnl> remember that usenet dates back to the days when mem were men and computers on good internet connections were outside most people's price range
09:47:19 <syntaxfree> yeah, I guess.
09:47:52 <syntaxfree> It just feels weird that there's this perfectly good network / protocol suite around, and we're jerry-rigging a weird discussion system with blogs and trackbacks and and and.
09:48:01 <syntaxfree> mailing lists are already jerry-rigged.
09:48:27 <psnl> syntaxfree: true
09:49:27 <syntaxfree> blogs are often in walled communities that don't discover each other.
09:51:02 <syntaxfree> I'm reading and posting a lot in an usenet newsgroup over google groups lately, and I've been wanting more features. killfiles, etc.
09:52:00 <chessguy> hey syntaxfree, did you and emk start up any email discussions on statistics yet?
09:52:32 <syntaxfree> nah, it mostly has been going on here or on -blah
09:52:38 <chessguy> ok
09:54:06 <syntaxfree> http://en.wikipedia.org/wiki/Usenet_II
09:59:39 <dpiponi> Is there a canonical paper or book chapter on the subject of linear types?
10:00:50 <bos31337> henry baker's stuff, and phil wadler's.
10:00:55 <dpiponi> I know this paper: http://citeseer.ist.psu.edu/wadler90linear.html but it seems to be more of a particular application. I've not heard of Henry Baker so I'll check that out.
10:00:58 <lambdabot> Title: Linear Types Can Change the World! - Wadler (ResearchIndex)
10:01:14 <bos31337> henry baker is an old-time lisper.
10:01:25 <bos31337> again, it's an application of linear logic to linear types.
10:02:00 <bos31337> if you want the ultimate source of this, see girard's papers on linear logic: http://iml.univ-mrs.fr/~girard/Articles.html
10:02:02 <lambdabot> Title: Articles Jean-Yves Girard
10:02:06 <bos31337> (hope your french is good.)
10:03:04 <dpiponi> I'm just polishing off references to a short paper and I wanted to mention linear types in passing. But it's for an audience who know graphics, not type theory.
10:03:33 <dpiponi> Henry Baker seems to have a great collection of publications!
10:04:01 <bos31337> yeah.
10:04:14 <bos31337> he's a wadler analogue for the lisp world.
10:04:36 <dpiponi> I've seen the thermodynamics of GC one before. I must read it some time.
10:04:49 <shapr> Yeah, hbaker is awesome.
10:11:05 <fax> if I have 'data blah' can I write newBlah :: blah
10:11:12 <fax> to say that newBlah is a function which returns a blah
10:11:25 <emu> data Blah and newBlah :: Blah but yea
10:11:35 <emu> except that newBlah isn't really a function then
10:11:40 <fax> its not?
10:11:46 <dmhouse> emu: well, that's a bit of blurry distinction.
10:11:46 <emu> maybe you mean newBlah :: Int -> Blah?
10:11:46 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
10:11:53 <emu> yea it is blurry
10:11:58 <fax> I dont want to take an int as a parameter
10:12:03 <emu> just an example
10:12:05 <fax> () -> Blah didnt work either
10:12:05 <dmhouse> In some languages (lisp comes to mind), there's a definite distinction between functions and params.
10:12:11 <dmhouse> *functions and values.
10:12:20 <dmhouse> I'd say newBlah :: Blah is a function that returns a blah.
10:12:28 <fax> can I do like
10:12:35 <dmhouse> In Haskell, there is no such distinction.
10:12:38 <fax> newBlah = do ... return Blah { .. } ?
10:12:47 <dmhouse> Well, then it'd be monadic.
10:12:50 <emu> use parens
10:12:57 <fax> where?
10:13:01 <emu> return (Blah { })
10:13:05 <dmhouse> But you can make the right-hand-side of newBlah as complicated as you like.
10:13:09 <emu> then you'd be dealing with some monad m, m Blah
10:13:22 <dmhouse> fax: be careful: return doesn't do what it does in every other programming language.
10:13:23 <emu> @type return
10:13:25 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:13:26 <dmhouse> return throws a value into a monad.
10:13:32 <emu> a -> m a
10:13:41 <emu> substitue Blah for a
10:13:48 <emu> return :: Blah -> m Blah
10:14:26 <fax> well I just want to take no parameters and return a new Blah
10:14:33 <fax> I have to use monads
10:14:33 <fax> ?
10:14:35 <emu> well then you can only return one blah
10:14:36 <dmhouse> No.
10:14:45 <dmhouse> It has to be the same Blah every time, though.
10:14:48 <doserj> fax: what do you mean with "new"?
10:14:59 <emu> the return value of functions is entirely dependent on the parameters
10:15:02 <fax> well its created based on other stuff (a network connection)
10:15:09 <emu> then you'll need to be in IO
10:15:13 <fax> ho
10:15:14 <dmhouse> Then it'd need to be newBlah :: IO Blah
10:15:19 <dmhouse> Then to use it, you'd go:
10:15:35 <dmhouse> do stuff; b <- newBlah; stuff etc.
10:15:56 <fax> cool!
10:15:58 <fax> thanks a lot
10:16:14 <shapr> I hate having a cold, I can't think straight then :-(
10:16:30 <mkfx> I have a problem with a haskell assignment for school: I have written a function (test2Param) that tests functions of 2 parameters. It accepts the function to be tested (a->a->a), the inputs to be tested [(a,a)] and the expected results [a]. I now need to use the function to test a function-- dotProduct :: [Int] -> [Int] -> Int. How can my test2Param accept the dotProduct function.. ie, i need it to be able to accept any function to test
10:16:33 <mbishop> yeah I think I have a cold too :\
10:16:40 <mkfx> not just (a->a->a) functions
10:17:18 <resiak> test2param f xs = map f xs -- ?
10:17:40 <resiak> uhm, map (uncurry f) xs, I guess in this case
10:18:12 * mbishop sneezes on shapr 
10:18:25 * shapr sneezes back
10:18:50 <emu> are you supposed to turn [(a,a)] into ([a],[a])?
10:19:13 <mkfx> yeah and vice versa
10:19:28 <roconnor> I wonder what the strong monad laws are when extpressed in terms of st :  B^A -> (MB)^(MA)
10:19:28 <emu> @type zip
10:19:31 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
10:19:41 <fax> I have like an IO Blah now
10:19:48 <fax> but I raelly want an IORef Blah
10:19:51 <emu> @type unzip
10:19:54 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
10:19:59 <mkfx> word. zip looks good.
10:20:00 <fax> is there a conversion?
10:20:08 <fax> or do I have to create it differently?
10:21:03 <emu> @type uncurry zip
10:21:06 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
10:21:27 <emu> fax: you'd need to create an IORef
10:21:30 <emu> @type newIORef
10:21:33 <lambdabot> Not in scope: `newIORef'
10:21:37 <emu> @hoogle IORef
10:21:37 <lambdabot> Data.IORef :: module
10:21:37 <lambdabot> Data.IORef.IORef :: data IORef a
10:21:37 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
10:21:52 <emu> are you sure you really want IORefs though? starting to really get into imperative coding here
10:21:59 <fax> I know :[
10:22:03 <emu> @doc Data.IORef
10:22:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
10:22:14 <fax> I have to pass modifiable state around to multiple functions
10:22:16 <emu> anyway that would end up being IO (IORef Blah)
10:22:24 <fax> aha
10:22:25 <emu> perhaps you should use StateT IO
10:24:14 <hpaste>  glguy pasted "Binary Fold" at http://hpaste.org/844
10:24:21 <glguy> is that a common idiom?
10:24:26 <glguy> is it defined somewhere already?
10:25:11 <hpaste>  glguy annotated "Binary Fold" with "minimum example" at http://hpaste.org/844#a1
10:25:14 <ejt> glguy: looks to me like you could do that with an ordinary foldr
10:25:27 <glguy> ejt: less efficiently though
10:25:53 <ejt> I'd do that by splitting into pairs
10:25:55 <ejt> then folding
10:26:03 <glguy> over and over and over
10:26:03 <glguy> ?
10:26:29 <ejt> I guess I don't need to do it often
10:26:31 <ejt> (ever)
10:26:39 <glguy> I'm not sure you understand what that function is doing
10:28:09 <ejt> treefold is ?
10:28:16 <doserj> glguy: do you mean binaryFold f xs = binaryFold f $ aux xs?
10:28:20 <glguy> yeah
10:28:23 <hpaste>  mkfx pasted "dotProduct test" at http://hpaste.org/845
10:28:25 <glguy> I changed the name
10:28:32 <glguy> I'm not sure that it actually changes the complexity now
10:28:34 <mkfx> if anyone could take a look, still stuck.
10:28:38 <glguy> but I wanted to play with it
10:29:06 <glguy> I guess the number of nodes in the tree generated are on the same order as the number of leaf nodes
10:30:14 <doserj> sum_{i=0}^n 2^i = 2^{n+1}-1, if you mean that
10:30:24 <glguy> yeah, this doesn't buy anything
10:30:26 <glguy> nevermind :)
10:30:50 <emu> \a b c -> [a] `dotProduct` [b]
10:30:54 <emu> er
10:30:57 <emu> \a b -> [a] `dotProduct` [b]
10:31:11 <ejt> glguy: read it again, yes it did misunderstand
10:31:23 <glguy> ejt: it didn't help that I had a typo
10:32:10 <fax> > ! 1
10:32:10 <lambdabot>  Parse error
10:32:17 <fax> :S
10:32:26 <glguy> I reduced the number of calls to "f" by 1 at the expensive of all the intermediate trees
10:32:46 <ejt> y
10:32:56 <glguy> intermediate lists that is
10:32:57 <emu> glguy: annotation should display the original paste while performing the entry?
10:33:14 <glguy> emu: it does if you click that link
10:33:35 <emu> oh i clicked the one above it
10:33:44 <glguy> the top link is for a fresh annotation
10:34:53 <doserj> glguy: the number of calls is the same, not even reduced by 1
10:35:04 <glguy> oh, right
10:35:07 <DynWind> hmm, the darcs version of yi does not build
10:35:08 <glguy> because foldr1
10:35:29 <doserj> yep
10:37:59 <hpaste>  fax pasted "(no title)" at http://hpaste.org/846
10:38:17 <glguy> http://hpaste.org/826 to answer Pastorn's question, I'd guess that the 2nd version was faster because it didn't use a temporary list structure, but that it was probably trivially faster
10:38:23 <fax> ok I just started out but its a red teapot and you telnet in and type somthing to turn it blue.. it does work,
10:38:41 <glguy> please use titles
10:38:41 <fax> but I was wondering if I do anything silly or just style things or whatever I might have wrong
10:38:47 <fax> ok I will
10:38:59 <chessguy> Cale: have you studied any of the mathematics involved in Go?
10:39:19 <Cale> chessguy: not deeply
10:39:33 <Cale> chessguy: There's a very interesting treatment of the endgame.
10:39:35 <chessguy> seems like it would be interesting
10:39:43 <Cale> But other than that, people don't know much.
10:39:50 <hpaste>  emu annotated "dotProduct test" with "probably not helping" at http://hpaste.org/845#a1
10:40:38 <Cale> You can ask a pro why they wouldn't play one move over another, and often the best answer they can give you is that the one they played feels a bit better. :)
10:40:48 <chessguy> i would think it would be easier to talk formally about go than about chess
10:40:53 <Cale> (at least, when the two moves are similarly good)
10:40:55 <emu> endgame can be exhaustively analyzed in some ways
10:40:59 <edwinb> someone who was teaching me once said "That's a bad move. I don't know why, it just is."
10:41:03 <edwinb> er, thanks
10:41:04 <emu> i recall Korean pros who would actually do that in their head
10:41:07 <Cale> edwinb: hehe
10:41:07 <chessguy> sure, you get the same thing from chess
10:41:18 <edwinb> Cale: I do that myself now ;)
10:41:26 <edwinb> much as I try not to...
10:41:57 <Cale> It's good to try to explore the continuations
10:42:22 <emu> whoops
10:42:23 <Cale> but sometimes that's hard
10:42:32 <Cale> and sometimes the move is just pointless ;)
10:42:34 <edwinb> continuation passing style go?
10:42:38 <Cale> hehe
10:42:48 <hpaste>  emu annotated "dotProduct test" with "whoops" at http://hpaste.org/845#a2
10:43:02 <chessguy> it really reminds me a lot of complexity theory
10:43:47 <mkfx> *** Term           : dotProduct
10:43:47 <mkfx> *** Type           : [Int] -> [Int] -> Int
10:43:47 <mkfx> *** Does not match : [a] -> [a] -> [a]
10:44:19 <mkfx> i told my TA that this was going to be a problem and i got laughed at.. i better not be right about this haha
10:44:49 <emu> mkfx: your type annotation is overly restrictive
10:44:52 <emu> can you omit it?
10:45:00 <emu> ask the compiler for what it thinks
10:46:30 <Cale> chessguy: oh, also, in case you're unfamiliar, the board we were playing on is 9x9, but the conventional board for non-beginners is 19x19 :)
10:46:39 <chessguy> yeah
10:46:43 <hpaste>  emu annotated "dotProduct test" with "what ghc tells me" at http://hpaste.org/845#a3
10:46:47 <chessguy> i think i'd like to start on 5x5
10:46:51 <Cale> :)
10:47:01 <Cale> 7x7 maybe
10:47:07 <Cale> 5x5 is a little silly :)
10:47:07 <doserj> smaller boards are actually more complicated...
10:47:09 <chessguy> what's wrong with 5x5?
10:47:22 <resiak> Meh, 9x9 seems large enough to have a reasonable game, but small enough that you don't go blind when starting off
10:47:27 <mkfx> thanks emu i'll check that
10:47:31 <Cale> With 5x5 you easily get into strange ko-situations
10:47:40 <emu> mkfx: i lifted the restriction that all the types had to be the same.
10:47:44 <chessguy> ko = no-repeate?
10:47:47 <Cale> yeah
10:47:50 <chessguy> s/te/t/
10:48:00 <emu> mkfx: instead i merely asserted that the types had to be Showable.  and that's only because you use them in error msgs.
10:48:06 <Cale> also, it's too small
10:48:09 <glguy> does reddit have css for anyone else
10:48:17 <Cale> The first move is overwhelmingly important
10:48:22 <emu> mkfx: and that the result type has to be something comparable with ==
10:49:10 <Cale> See, with 5x5, the centre point is also the 3,3 point, which is guaranteed life on an ordinary sized board.
10:50:04 <doserj> and the second move starts a whole-board life-and-death problem...
10:50:05 <Cale> I dunno, kind of odd :)
10:50:09 <Cale> yeah
10:50:35 <emu> so it reduces Go to tic-tac-toe?
10:50:47 <Cale> Well, not quite that bad
10:50:55 <emu> or else you give a 10 point handicap
10:50:55 <Cale> but it's nothing like the ordinary game anymore
10:51:03 <Cale> 2-by-n boards are odd.
10:51:24 <Cale> (or 1-by-n, but eventually, you sort that out)
10:52:24 <emu> mkfx: you know how to query hugs/ghci for type information right?
10:52:41 <therp> hmm, gnugo is still stronger than me. probably even stronger in more recent versions. I only bet it once (like 20 points)
10:52:54 <Cale> but basically, small boards start getting into strange technicalities which don't tend to matter at all in the large game
10:53:11 <edwinb> 2x2 boards can be fun for rules freaks
10:53:11 <Cale> I can crush gnugo badly.
10:53:17 <Cale> hehe, yeah
10:53:19 <mkfx> uhhhmmm :type?
10:53:20 <therp> you already told cale :)
10:53:27 <emu> ok=)
10:53:30 <Cale> oh, I don't know who I told :)
10:53:31 * fax is scared of Cale 
10:53:55 <Cale> I should try giving it stones, and see where it starts getting hard.
10:54:01 <therp> my only chance to master Go is to write code that can play it better than me.
10:54:11 <edwinb> I gave it 5 and won once, but I think it's got better since
10:54:12 <Cale> nah, just play lots of games
10:54:18 <edwinb> there is a trick to it...
10:54:36 <Cale> You'll get better faster than you can write a decent go AI.
10:54:39 <therp> cale: well, my local Go club isn't particularly attractive
10:54:43 <Cale> ah
10:55:02 <therp> also they are all heavy smokers. I hate smoked filled cafes.
10:55:02 <Cale> KGS isn't terrible, from what I recall, but I only played much online a few years back
10:55:03 <newsham> hi
10:55:11 <xerox> therp: no chicks at the go club?
10:55:11 <Cale> So if the community's gone to hell, I wouldn't know :)
10:55:13 <edwinb> I still want to write a haskell go AI but it'd take about 150% of my time... ;)
10:55:21 <therp> cale: I prefer to play IRL
10:55:25 <Cale> me too
10:55:31 <therp> xerox: not a single one, iirc
10:55:45 <emu> i have a board, but hour-half long games get to me
10:55:48 <therp> in fact, I never played a serious game with a female opponent. too bad.
10:55:51 <Cale> It's interesting what's still conveyed online though.
10:56:41 <chessguy> what are usual time controls for go tournaments?
10:56:41 <xerox> Cale, thanks for the game, they were pressing me to exit :-)
10:56:52 <edwinb> chessguy: depends, one hour each is usually the most in the uk
10:56:59 <chessguy> xerox: i let him beat me after he played you, to make him feel better
10:57:10 <Cale> xerox: sorry that I sucked so much there :)
10:57:19 <Cale> xerox: I'll have you some games when I'm awake :)
10:57:34 <Cale> hehe
10:57:37 <chessguy> edwinb: that's short by chess standards :)
10:58:00 <Cale> chessguy: The proverb is to lose your first 50 games as quickly as possible :)
10:58:09 <chessguy> Cale: haha
10:58:10 <therp> 50? :)
10:58:16 <Cale> Maybe more :)
10:58:16 <therp> 500 would be more appropriate.
10:58:21 <Cale> 50 is optimistic :)
10:58:23 <chessguy> give or take a few magnitudes
10:58:44 <Cale> I played against a 4 dan for a long time as a beginner.
10:58:50 <psi`> chessguy: the championship games last several days :)
10:58:54 <xerox> Cale, I can crush gnugo with 6 stones I think.
10:59:07 <Cale> So it was just hopeless, I would never win.
10:59:19 <xerox> Cale - And yes, let's have some games when we're both awake (-:
10:59:26 <Cale> He beat a friend of mine with some ridiculous handicaps.
10:59:42 <Cale> I think 15 stones :)
10:59:48 <xerox> hehe, that's fun
10:59:49 <chessguy> how do the ratings work in go?
11:00:01 <Cale> and they had a 26 stone game, and he lost, but it was close
11:00:14 <emu> games take a long time at my level, because we both suck, and end up staring at the board forever
11:00:19 <Cale> chessguy: the normal handicaps max out at 9
11:00:32 <Cale> chessguy: difference in rank is the number of stones you have to give
11:00:39 <chessguy> Cale: i mean rating how good a player is
11:00:46 <chessguy> like the dans
11:00:48 <Cale> chessguy: this is the system :)
11:00:49 <Cale> yes
11:01:07 <Cale> For example, a 5 kyu would take 2 handicap stones from a 3kyu.
11:01:13 <emu> well, systems like IGS and KGS have some crazy formula to figure it out
11:01:15 <xerox> 30 kyu < ... < 1 kyu < 1 dan < ... < 9 dan
11:01:21 <therp> chessguy: your ranking is set by (difference in points/10) against a player already rated.
11:01:27 <edwinb> chessguy: I'd get bored if it was much longer I think... I prefer faster
11:01:39 <xerox> edwinb: so you also play go, we should play sometime!
11:01:48 <therp> chessguy: points=end result points
11:01:49 <dpiponi> The question is: is rank linear in the sense that if A>B by m stones and if B>C by n stones, is A>C by m+n stones?
11:01:59 <emu> i started playing 9x9 at one point because i was so sick of long games, but that's not really the same
11:02:03 <chessguy> ah, what xerox said is what i wanted to know
11:02:08 <therp> dpiponi: it's supposed to be yes.
11:02:13 <Cale> ah, okay
11:02:14 <edwinb> xerox: yes, indeed...
11:02:22 <Cale> yeah, kyu is negative ability
11:02:29 <Cale> dan is positive ability
11:02:32 <psi`> i prefer 9x9 games, i think
11:02:39 <Cale> is the basic idea
11:02:42 <psi`> they're hard enough, and quicker to play
11:02:45 <Cale> but 0 is missing
11:02:46 <xerox> dpiponi: yeah, the difference is bounded at 9, usually.
11:02:52 <Cale> you go from 1 kyu to 1 dan
11:03:03 <emu> Go predates the notion of zero
11:03:15 <Cale> People are basically 30 kyu after they've played a couple of games.
11:03:37 <Cale> emu: indeed :)
11:03:50 <therp> 30 kyu basically means, you know the rules. that's: you don't try to move stones around on the board
11:03:58 <Cale> and said to be 50 kyu before they've played their first game
11:04:21 <emu> i never achieved better than like 15kyu on IGS or KGS.  I lived with someone who was about 5dan on KGS last time i knew him.
11:04:25 <Cale> (though I don't know whether that's a formal convention in most places)
11:06:58 <dpiponi> I once tried 3 way go with Smarties (M&Ms to Americans). But unfortunately what happens is that two people agree to trounce the third player.
11:07:12 <therp> may I slightly abuse this channel for a semantic translation of "Something is subject to the receipt of the paper" by an english native speaker? this basically means this is a conditional/precondition for "something" right?
11:07:37 <astrolabe> yeah
11:07:55 <CosmicRay> yes
11:08:05 <therp> thanks
11:09:38 <xerox> dpiponi: maybe it would work with additional rules :-)
11:10:21 <Cale> dpiponi: We have both Smarties and M&M's, at least in Canada
11:10:26 <Cale> They're different :)
11:10:34 <xerox> Same in Italy too.
11:10:56 <Cale> Smarties are closer to being perfect ellipsoids, whereas M&M's are a bit more irregular.
11:11:54 <Cale> (also, smarties are flatter)
11:12:30 <xerox> data M&M's = YellowBag | BlackBag -- too
11:12:32 <dpiponi> Interesting: http://en.wikipedia.org/wiki/Smarties_(Nestl%C3%A9)
11:13:59 <newsham> deriving(Taste)
11:15:39 <emu> smarties aren't M&Ms
11:15:49 <dylan> does darcs preserve mtimes?
11:15:54 <bos> no.
11:16:02 <dmwit> Huh, for me, smarties are made of pure sugar (not chocolate).
11:16:05 <emu> they're citrusy
11:16:07 <emu> yea
11:16:11 <emu> something like that
11:16:25 <dylan> rather, does darcs push preserve mtimes?
11:16:38 <bos> no.
11:16:45 <dylan> darn.
11:16:53 <bos> preserving mtimes is broken.
11:17:07 <bos> as in, it's something you shouldn't be wanting.
11:17:26 <dylan> I don't want it, but pyblosxom does. :P
11:18:11 <bos> ah. well, blosxom-like blogging tools are pretty broken, too.
11:18:15 <dylan> ... in a test run, it seems it does preserve mtimes.
11:18:28 <dylan> less broken than wordpress, though.
11:18:34 <bos> differently so :-)
11:18:58 <dylan> ah well, I just have to run fixmtimes.py before I run pyblosxom --static, I guess.
11:19:19 <bos> yes, that will do the trick.
11:19:35 <dylan> I'd write my own blog engine, but it seems rather boring.
11:21:15 <fax> hm
11:21:21 <dylan> hmm, I need someway of mktime() knowing the time struct it is passed is UTC, not my local timezoe.
11:27:53 <chessguy> hm, pardon my split personalities
11:32:36 <chessguy> ?losers
11:32:37 <lambdabot> Maximum users seen in #haskell: 339, currently: 315 (92.9%), active: 56 (17.8%)
11:32:49 <bos> any ffi users around?
11:37:51 <moonlite> how do i hide the list monad?
11:38:14 <moonlite> (i'm experimenting a little with implementing my own list monad)
11:38:21 <glguy> newtype List a = [a]
11:38:56 <moonlite> ah
11:39:45 <Zeroth|work> what is an "instance declaration" ?
11:40:22 <glguy> it is how you define how a certain type implements the class methods of a class
11:41:53 <Zeroth|work> > let f 0 = 0; f x = x : f (x - 1) in f 10
11:41:55 <lambdabot>   add an instance declaration for (Num [t])
11:41:55 <lambdabot>     In the expression:
11:41:55 <lambdabot>         le...
11:42:19 <glguy> it is saying that you must explain how a list of things can be a Num
11:42:22 <glguy> for that to work
11:42:41 <glguy> because you are trying to tell it that 0 is a list
11:43:25 <Zeroth|work> > let f [0] = [0]; f x = x : [f [(x - 1)]] in f 10
11:43:26 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
11:43:26 <lambdabot>       Expected...
11:43:40 <glguy> let f 0 = [0]
11:44:01 <Zeroth|work> > let f 0 = [0]; f x = x : f (x - 1) in f 10
11:44:03 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
11:44:07 <Zeroth|work> ahoy
11:44:25 <Zeroth|work> [10..0]
11:44:29 <Zeroth|work> heh
11:44:32 <emu> you made a "typo" meaning type-error or typing error
11:44:33 <glguy> > [10,9..0]
11:44:35 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
11:45:17 <wkh> > let lst = [3,8,2,6] in [1..(length lst)]
11:45:19 <lambdabot>  [1,2,3,4]
11:45:41 <psi`> > [0.0..10.0]
11:45:42 <lambdabot>  [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
11:45:43 <emu> > enumFromTo 0 10
11:45:44 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
11:45:55 <fax> whats methods of parsing are used?
11:46:03 <emu> parsing of what?
11:46:15 <fax> a simple language (LOGO)
11:46:28 <emu> bottom up or top down?
11:46:38 <emu> logo is probably recursive descent
11:46:41 <emu> like lisp
11:46:44 <fax> yeah
11:46:53 <fax> its quite similar to lisp
11:46:59 <wkh> in haskell it might be harder to draw the graphics associated with logo than to parse the language
11:47:08 <fax> I already have GLUT and stuff
11:47:14 <fax> and I can telnet in and talk to it
11:47:30 <emu> turtles are just a "killer app" for logo
11:47:31 <Cale> nah, it's not that bad, ask xerox about it ;)
11:47:35 <emu> it's actually a lisp
11:47:46 <Cale> (or me, but I'm tired :)
11:47:51 <Zeroth|work> > let f 0 = s 0; f x = x : f (x - 1); s 10 = [10]; s x = x : s (x + 1) in f 10
11:47:52 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9,10]
11:47:56 <Zeroth|work> muahah
11:48:00 <fax> im just wondering what functions are useful for parsing
11:48:04 <Cale> There's a wonderful binding to cairo
11:48:12 <emu> @hoogle PParsec
11:48:13 <lambdabot> No matches found
11:48:14 <emu> @hoogle Parsec
11:48:15 <lambdabot> Text.ParserCombinators.Parsec :: module
11:48:15 <lambdabot> Distribution.Setup.parseCleanArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
11:48:15 <lambdabot> Distribution.Setup.parseConfigureArgs :: ConfigFlags -> [String] -> [OptDescr a] -> IO (ConfigFlags, [a], [String])
11:48:16 <Cale> and the cairo graphics interface is logo-like in many ways
11:48:23 <emu> @doc Text.ParserCombinators.Parsec
11:48:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
11:48:28 <Zeroth|work> > let f 0 = s 0; f x = x : f (x - 1); s 10 = f 10; s x = x : s (x + 1) in f 10
11:48:29 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6...
11:48:30 <emu> @where parsec
11:48:31 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
11:48:34 <fax> oh nice thanks :D
11:48:35 <emu> ^ tutorial
11:48:54 <fax> heh
11:48:58 <fax> I scrolled to the bottom of the tutorial
11:49:02 <fax> and it says "LOGO"
11:49:11 <emu> the only thing about the tutorial: he refers to modules with non-hierarchical names; just refer to the real docs for the module names.
11:49:33 <fax> alright cheers again
11:49:48 <Zeroth|work> > 'a' + 1
11:49:48 <lambdabot>   add an instance declaration for (Num Char)
11:49:49 <lambdabot>     In the expression: 'a' + 1
11:49:49 <lambdabot>  ...
11:49:56 <Zeroth|work> I was expecting 'b'
11:49:57 <Cale> > succ 'a'
11:49:57 <lambdabot>  'b'
11:50:07 <Cale> + is only for numbers
11:50:09 <Zeroth|work> > succ 'z'
11:50:10 <lambdabot>  '{'
11:50:18 <Zeroth|work> it only does printables?
11:50:25 <Cale> hm?
11:50:31 <emu> @type succ
11:50:33 <lambdabot> forall a. (Enum a) => a -> a
11:50:35 <wkh> > ord 'z'
11:50:36 <lambdabot>  122
11:50:41 <Cale> > succ '\0'
11:50:41 <wkh> > ord '{'
11:50:43 <lambdabot>  '\SOH'
11:50:43 <lambdabot>  123
11:50:46 <Zeroth|work> succ 122
11:50:48 <Cale> > succ '\SOH'
11:50:50 <lambdabot>  '\STX'
11:50:53 <Cale> > succ '\STX'
11:50:55 <lambdabot>  '\ETX'
11:50:56 <emu> succ works on Enum, of which Char is
11:51:04 <moonlite> glguy: the trick you provided didn't work. Do you know how i actually do to hide the "instance Monad []" ?
11:51:05 <Cale> > iterate succ '\0'
11:51:06 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
11:51:20 <fax> so parsec is already installed for GHC?
11:51:35 <moonlite> specifically i got: "parse error in data/newtype declaration"
11:51:37 <mauke> > ['\0'..]
11:51:39 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
11:51:44 <Zeroth|work> trying to come up with a simple way to do word permutations
11:52:05 <fax> Zeroth|work: you need to find n'th permutation?
11:52:07 <fax> or just any
11:52:13 <Zeroth|work> just any
11:52:28 <fax> I dunno about in haskell, but its probably pretty easy to use knuth shuffle
11:52:32 <Cale> I'm going to take a nap :)
11:52:38 <Zeroth|work> I could write out long complex algorythm..
11:52:44 <fax> just go through each character swapping it with any character not before it
11:52:51 <Cale> There are some easy recursive algorithms
11:52:59 <fax> ^ thats the entire algo :)
11:53:02 <Cale> It's a good exercise.
11:53:19 <glguy> moonlite: instances are global, you need to add a Monad instance to your own newtype or data type
11:53:20 <Cale> Construct the permutations of (x:xs) given the permutations of xs
11:53:37 * Zeroth|work is busy
11:54:07 <fax> Cale: yeah thats a better way to describe it :D
11:54:12 <fax> same algo though
11:54:51 <moonlite> glguy: hm ok. :/
11:54:54 <Cale> depends, yours sounds like it's mutating things :)
11:55:04 <Cale> Mine is constructing a huge list of all of them :)
11:55:27 <Zeroth|work> > flip "asd"
11:55:28 <lambdabot>  Couldn't match expected type `a -> b -> c'
11:55:37 <glguy> > reverse "asd"
11:55:38 <lambdabot>  "dsa"
11:55:40 <Zeroth|work> aha
11:55:51 <fax> oh right its easier to generete all permutations non destructivly
11:58:47 <dmwit> I remember my answer being prettier than this in a previous life.
11:58:54 <dmwit> Or was that for combinations?
11:58:55 <Zeroth|work> :t map
11:58:58 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:00:41 <kscaldef> dylan: I don't know about pyblosxom, but virtually all blosxom users run a plugin that tracks original creation times
12:01:12 <dylan> kscaldef: how does that work?
12:01:45 <kscaldef> so it ends up being irrelevant if your SCM mucks with the mtimes
12:01:57 <Botje> in-band ctimes?
12:02:08 <dmwit> Best way to calculate factorial _ever_:
12:02:14 <kscaldef> basically just a hash-table from entry paths to creation times
12:02:22 <dmwit> fac n = length (perm [0..n])
12:02:36 <psi`> :)
12:02:36 <dylan> kscaldef: you use blosxom? :)
12:02:47 <Japsu> dmwit: heh
12:02:58 <kscaldef> although, some people use a version that embeds the creation time either in the filename, or as metadata in the file
12:02:59 <glguy> dmwit: that doesn't work, does it? fac 0 = 1, fac 1 = 1
12:03:07 <kscaldef> dylan: I maintain blosxom :-)
12:03:07 <glguy> perm [1..n] maybe?
12:03:10 <Japsu> > [0..0]
12:03:12 <lambdabot>  [0]
12:03:14 <dmwit> perm [0] == [[0]]
12:03:18 <Japsu> > perm [0..0]
12:03:19 <lambdabot>   Not in scope: `perm'
12:03:20 <Japsu> bah
12:03:24 <dylan> kscaldef: hmm, it's maintained? I might use that then.
12:03:32 <glguy> needs to be length (perm [1..n])
12:03:47 <dylan> pyblosxom doesn't allow you to use anything other than the mtime.
12:03:47 <dmwit> glguy: I think you're right.
12:04:00 <psi`> > [1..0]
12:04:02 <lambdabot>  []
12:04:09 <dmwit> In fact, looking back, I had compared perm [0..9] and fac 10, so... =P
12:04:17 <Japsu> > let { fac 0 = 1; fac n = n * fac (n-1) } in sum (map fac [1..10])
12:04:18 <lambdabot>  4037913
12:04:24 <dmwit> psi`: perm [] == [[]]
12:04:24 <Japsu> > let { fac 0 = 1; fac n = n * fac (n-1) } in sum (map fac [1..10]) `mod` 12
12:04:26 <kscaldef> dylan: yeah... due to unfortunate history, blosxom.com is horribly out of date.  There is a sourceforge project with current development
12:04:27 <lambdabot>  9
12:04:45 <psi`> dmwit: right...
12:04:48 <dolio> Generating them all gets kind of inefficient for large lists if you only need one permutation.
12:04:59 <dmwit> lazy lists!
12:05:06 <dmwit> but yeah
12:05:23 <dolio> It's still slow for grabbing ones later in the list.
12:12:48 <dpiponi> Is there a library function to chop up a list into sublists of size n. Eg. chopUp 3 [1..9] = [[1..3],[4..6],[7..9]]
12:15:56 <psi`> @hoogle [a] -> [[a]]
12:15:56 <lambdabot> List.inits :: [a] -> [[a]]
12:15:57 <lambdabot> List.tails :: [a] -> [[a]]
12:15:57 <lambdabot> List.group :: Eq a => [a] -> [[a]]
12:16:25 <roconnor> @type unfoldr
12:16:27 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:16:38 <glguy> > let groups n = unfoldr (liftM2 (>>) (guard.not.null) (return . splitAt n)) in groups 3 [1..10]
12:16:39 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
12:17:17 <ClaudiusMaximus> > let chunk _ [] = [] ; chunk n xs = let (a,b) = splitAt n xs in a : (chunk n b) in chunk 4 [1..12]
12:17:18 <lambdabot>  [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
12:17:48 <roconnor> @type (liftM2 (>>))
12:17:50 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
12:17:58 <dpiponi> I think the answer is "no, there isn't one in the library" :-)
12:18:28 <Zeroth|work> > f x = if x 'z' then 'a' else 'x' in f 'z'
12:18:29 <lambdabot>  Parse error
12:18:34 <glguy> > let groups n = unfoldr (\a -> do (_:_) <- return a; return (splitAt n a)) in groups 3 [1..10]
12:18:35 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
12:19:42 <roconnor> > let groups n = unfoldr (\a -> do guard $ not $ null a; return (splitAt n a)) in groups 3 [1..10]
12:19:44 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
12:21:25 <Zeroth|work> > let f x = if x 'z' then 'a' else 'x' in f 'z'
12:21:26 <lambdabot>  Couldn't match expected type `Char -> Bool'
12:22:16 <mauke> against Char
12:22:20 <rahikkala> dpiponi: I think they left that function out of the prelude just so that #haskell regulars can came up with weird definitions of it to scare newbies on this channel
12:22:21 <rahikkala> > let groups _ [] = []; groups n l = let (begin, end) = splitAt n l in begin : groups n end in groups 3 "abcdefgh"
12:22:22 <lambdabot>  ["abc","def","gh"]
12:22:50 <roconnor> > let f x = if x 'z' then 'a' else 'x' in f isUpper
12:22:52 <lambdabot>  'x'
12:23:06 <roconnor> > let f x = if x 'z' then 'a' else 'x' in f isLower
12:23:08 <lambdabot>  'a'
12:23:10 <glguy> rahikkala: I came up with that definition for no such reason!
12:23:10 <glguy> :)
12:23:31 <Zeroth|work> > let f x = if x 'z' then 'a' else 'x' in f 'z'
12:23:32 <lambdabot>  Couldn't match expected type `Char -> Bool'
12:23:48 <Zeroth|work> I want it to take a char ><
12:23:59 <glguy> > let groups n = map take n . takeWhile (not . null) . iterate (drop n) in groups 3 [1..10]
12:24:00 <lambdabot>  Couldn't match expected type `b -> c'
12:24:02 <roconnor> > let f x = if (x=='z') then 'a' else 'x' in f 'z'
12:24:03 <dpiponi> At hallowe'en you guys have to go trick or treating dressed as liftM2's and unfoldr's
12:24:04 <lambdabot>  'a'
12:24:10 <roconnor> > let f x = if (x=='z') then 'a' else 'x' in f 'b'
12:24:11 <lambdabot>  'x'
12:24:21 <Zeroth|work> > let f x = if (x == 'z') then 'a' else 'x' in f 'z'
12:24:23 <lambdabot>  'a'
12:24:33 <glguy> > let groups n = map (take n) . takeWhile (not . null) . iterate (drop n) in groups 3 [1..10]
12:24:35 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
12:25:35 <glguy> > let groups n = (. takeWhile (not . null)) (map (take n)) . iterate (drop n) in groups 3 [1..10]
12:25:36 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
12:25:41 <fasta> Is unsafePerformIO a good way to do IO(e.g. visualisation with external program) that's only used for debugging purposes?
12:27:29 <Saizan> ?ty trace
12:27:32 <lambdabot> Not in scope: `trace'
12:28:24 <roconnor> ?type comaparing
12:28:27 <lambdabot> Not in scope: `comaparing'
12:28:28 <roconnor> ?type comparing
12:28:31 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:28:48 <glguy> > let groups = liftM2 (.) ((. takeWhile (not . null)) . map . take) (iterate . drop) in groups 3 [1..10]
12:28:50 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
12:29:23 <Zeroth|work> is it possible to take a range of elements from a list?
12:29:34 <Zeroth|work> like (list !! 3-5)
12:29:40 <Zeroth|work> 3-to-5
12:29:42 <dmwit> > take 5 . drop 10 . [1..30]
12:29:43 <lambdabot>  Couldn't match expected type `a -> [a1]'
12:29:52 <dmwit> > take 5 $ drop 10 [1..30]
12:29:54 <lambdabot>  [11,12,13,14,15]
12:29:55 <glguy> > take 5 . drop 10 $ [1..30]
12:29:56 <roconnor> let groups n l = map (map snd) groupBy (comparing fst) zip [a|a<-[0..],b<-[1..3]] l in groups 3 [1..10]
12:29:57 <lambdabot>  [11,12,13,14,15]
12:30:00 <roconnor> > let groups n l = map (map snd) groupBy (comparing fst) zip [a|a<-[0..],b<-[1..3]] l in groups 3 [1..10]
12:30:01 <lambdabot>  Couldn't match expected type `[[(a, b)]]'
12:30:11 <roconnor> > let groups n l = map (map snd) $ groupBy (comparing fst) zip [a|a<-[0..],b<-[1..3]] l in groups 3 [1..10]
12:30:12 <lambdabot>  Couldn't match expected type `Bool'
12:30:22 <roconnor> > let groups n l = map (map snd) $ groupBy (comparing fst) $ zip [a|a<-[0..],b<-[1..3]] l in groups 3 [1..10]
12:30:23 <lambdabot>  Couldn't match expected type `Bool'
12:30:42 <Zeroth|work> can you drop from the opposite side of the list?
12:30:46 <roconnor> oh right, comparing isn't right
12:30:46 <Zeroth|work> ie, the end versus the front
12:30:58 <Zeroth|work> > drop 1 "asdas"
12:30:59 <lambdabot>  "sdas"
12:31:04 <Zeroth|work> > drop -1 "asdas"
12:31:05 <lambdabot>        add an instance declaration for (Num ([Char] -> Int -> [a] -> [a]))
12:31:09 <Zeroth|work> > drop (-1) "asdas"
12:31:11 <lambdabot>  "asdas"
12:31:11 <roconnor> > let groups n l = map (map snd) $ groupBy (\x y -> fst x == fst y) $ zip [a|a<-[0..],b<-[1..3]] l in groups 3 [1..10]
12:31:13 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
12:31:14 <fax> > reverse (drop 1 (reverse "abcdef"))
12:31:15 <lambdabot>  "abcde"
12:31:21 <Zeroth|work> fax, mine is better :-)
12:31:31 <roconnor> @pl groups n l = map (map snd) $ groupBy (\x y -> fst x == fst y) $ zip [a|a<-[0..],b<-[1..3]] l
12:31:31 <lambdabot> groups = const (map (map snd) . groupBy ((. fst) . (==) . fst) . zip [a | a <- [0..], b <- [1..3]])
12:31:36 <fax> Zeroth|work: it didnt do anything
12:31:42 <fax> > drop (-1) "abcdef"
12:31:43 <lambdabot>  "abcdef"
12:31:46 <fax> lol.
12:31:49 <Zeroth|work> > drop (-1) "1234"
12:31:49 <roconnor> @pl groups n l = map (map snd) $ groupBy (\x y -> fst x == fst y) $ zip [a|a<-[0..],b<-[1..n]] l
12:31:50 <lambdabot> groups = ((map (map snd) . groupBy ((. fst) . (==) . fst)) .) . zip . (a | a <- [0..] :) . return . (b <-) . enumFromTo 1
12:31:51 <lambdabot>  "1234"
12:31:54 <Zeroth|work> dang
12:31:56 <fax> mine is better :)
12:32:12 <roconnor> let groups = ((map (map snd) . groupBy ((. fst) . (==) . fst)) .) . zip . (a | a <- [0..] :) . return . (b <-) . enumFromTo 1 in groups 3 [1..10]
12:32:14 <fasta> Zeroth|work: a standard list is either nil or an element consed to another list, so you don't have access to the end right away.
12:32:14 <fax> > groups [1..10]
12:32:15 <lambdabot>   Not in scope: `groups'
12:32:17 <Zeroth|work> > drop ((length "1234")-1) "1234"
12:32:18 <lambdabot>  "4"
12:32:33 <Zeroth|work> heh
12:32:58 <icarroll> > last "1234"
12:32:58 <ketil_> > last "1234"
12:32:59 <lambdabot>  '4'
12:33:00 <lambdabot>  '4'
12:33:03 <icarroll> heh
12:33:05 <ketil_> :-)
12:33:20 <icarroll> > head $ reverse "1234"
12:33:22 <lambdabot>  '4'
12:33:43 <fax> > reverse $ drop 1 $ reverse "abcdef"
12:33:44 <lambdabot>  "abcde"
12:33:47 <fax> aha nice
12:34:01 <icarroll> > init "abcdef"
12:34:02 <lambdabot>  "abcde"
12:34:05 <dolio> ?paste
12:34:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:34:11 <int-e> > last . init . tails $ "1234"
12:34:12 <lambdabot>  "4"
12:34:23 <Zeroth|work> > init "brandon"
12:34:24 <lambdabot>  "brando"
12:34:42 <fax> > init [1..10]
12:34:44 <lambdabot>  [1,2,3,4,5,6,7,8,9]
12:34:54 <alexj> @seen musasabi
12:34:55 <lambdabot> I saw musasabi leaving #happs, #ghc, #haskell-blah and #haskell 14h 32m 11s ago, and .
12:35:16 <hpaste>  dolio pasted "permutations" at http://hpaste.org/847
12:35:22 <ketil_> > foldr const undefined $ reverse "1234"
12:35:23 <lambdabot>  '4'
12:36:09 <alexj> @seen musasabi
12:36:10 <lambdabot> I saw musasabi leaving #happs, #ghc, #haskell-blah and #haskell 14h 33m 26s ago, and .
12:36:12 <alexj> lkjlakjsd
12:36:24 <ketil_> ..silly.
12:36:27 <dolio> There, that'll either find all permutations, or just get a random one, depending on what type you request.
12:36:50 <arvid> two quick questions :) I want to try working with haskell, and would like to know: 1) Which compiler to you recomend? 2) is there a decent interpreter out there? I been coding a fair amount of ML in the past - but not, in any way, an expert in functional programming
12:37:09 <icarroll> 1) ghc 2) ghci
12:37:30 <arvid> icarroll: aha - so there is an ghci - must have missed it :)
12:39:05 <fasta> interpretBCO: unknown or unimplemented opcode 60860
12:39:11 <fasta> Same bug I had earlier
12:39:37 <icarroll> http://hackage.haskell.org/trac/ghc/ticket/1013
12:39:39 <lambdabot> Title: #1013 (interpretBCO: unknown or unimplemented opcode 64356) - GHC - Trac
12:40:54 <fasta> I find it quite disturbing that lots of bugs are being interpreted as:"That is only a theoretical construction and that code will never be used in practice."
12:42:11 <Igloo> fasta: Refering to that bug report? What makes you think that?
12:42:21 <fasta> Igloo: not that bug report
12:42:37 <fasta> Igloo: I had another one with that property, but I have seen others.
12:42:51 * Igloo would need examples to comment
12:43:10 <fasta> Igloo: I will see whether I can find it.
12:45:08 <fasta> http://hackage.haskell.org/trac/ghc/ticket/959 <- not really critical, I admit.
12:45:09 <lambdabot> Title: #959 (Debugging info(?) leaks out: &#34;Urk! Inventing strangely-kinded void TyC ...
12:45:39 <mwc> Woohoo! I got into my masters program at UWaterloo
12:45:44 <fasta> I don't know about the polymorphic pattern bindings, though.
12:46:21 * Igloo shrugs - Simon's answer seems reasonable to me
12:46:38 <fasta> Sure, it's reasonable for one person.
12:47:00 <mwc> fasta, lol, I love the Milestone _|_
12:47:03 <fasta> The problem seems to be a shortage of manpower.
12:47:07 <fasta> mwc: I did so too
13:02:13 <fax> head $ drop 1 arr, thats the right way to get the nth?
13:02:43 <mauke> > [10 .. 100] !! 49
13:02:44 <lambdabot>  59
13:02:49 <fax> ohh
13:02:50 <fax> ok thanks
13:05:14 <Zeroth|work> my permute function doesn't quite work. I can pastebin it if it's too hard to read:
13:05:16 <Zeroth|work> > upWord n s = if ((s !! n) != 'z') then (take (n-1) s) : succ (s !! n) : reverse(take ((length s) - n) (reverse(s)))) else upWord (n+1) (take (n-1) s) : 'a' : reverse(take ((length s) - n) (reverse(s)))) in upWord "asd"
13:05:16 <lambdabot>  Parse error
13:05:25 <fax> @doc withArray
13:05:26 <lambdabot> withArray not available
13:05:28 <glguy> > let loeb = (fmap . flip id =<<) in loeb [(*2).(!! 1), const 3, liftM2 (+) (!! 0) (!! 1)]
13:05:29 <fax> :(
13:05:29 <lambdabot>  Couldn't match expected type `f (a -> c) -> a'
13:06:09 <Zeroth|work> @where hbin
13:06:10 <lambdabot> I know nothing about hbin.
13:06:15 <Zeroth|work> @where pastebin
13:06:15 <lambdabot> http://rafb.net/paste
13:06:18 <glguy> !paste
13:06:19 <hpaste> Haskell paste bin: http://hpaste.org/
13:07:28 <Zeroth|work> lines can end with '\' to split them on multiple lines, or am I thinking Tcl?
13:07:45 <glguy> > let loeb = fix (fmap . flip id =<<) in loeb [(*2).(!! 1), const 3, liftM2 (+) (!! 0) (!! 1)]
13:07:47 <lambdabot>  [6,3,9]
13:07:55 <sjanssen> haskell++
13:08:11 <fax> withArray is ill
13:09:32 <hpaste>  zeroth pasted "word permutation" at http://hpaste.org/848
13:10:45 <fax> and tips on using withArray?
13:11:27 <Zeroth|work> anyone know why I'm getting a parse error?
13:12:12 <glguy> too many parentheses
13:12:45 <Zeroth|work> heh
13:12:48 <icarroll> haskell not equal is /=
13:12:53 <Zeroth|work> seriously?
13:13:02 <Zeroth|work> ah
13:13:02 <icarroll> > 1 /= 2
13:13:04 <lambdabot>  True
13:13:14 <icarroll> > "foo" /= "foo"
13:13:15 <lambdabot>  False
13:13:17 <Zeroth|work> still parse error
13:13:36 <glguy> Zeroth|work: you can't do this: "asdf" : j : "kjl;"
13:13:41 <glguy> err 'j'
13:13:59 <Zeroth|work> ?
13:14:07 <fax> > 'c':"abd"
13:14:07 <Zeroth|work> why not?
13:14:08 <lambdabot>  "cabd"
13:14:11 <fax> > "abd":'c'
13:14:12 <lambdabot>  Couldn't match expected type `[[Char]]'
13:14:16 <Zeroth|work> oh
13:14:16 <icarroll> try using ++ instead
13:14:18 <Zeroth|work> ++ instead?
13:14:19 <Zeroth|work> ha
13:14:20 <glguy> :t (:)
13:14:23 <lambdabot> forall a. a -> [a] -> [a]
13:14:23 <icarroll> but that shouldn't give a parse error
13:14:26 <icarroll> should give a type error
13:14:33 <glguy> right, the thing has many errors :)
13:14:37 <icarroll> heh
13:14:46 <Zeroth|work> still parse error
13:14:48 <Zeroth|work> > upWord n s = if ((s !! n) /= 'z') then (take (n-1) s) ++ succ (s !! n) ++ reverse(take ((length s) - n) (reverse(s)))) else upWord (n+1) (take (n-1) s) ++ 'a' ++ reverse(take ((length s) - n) (reverse(s)))) in upWord "asd"
13:14:49 <lambdabot>  Parse error
13:15:06 <icarroll> the in is the problem
13:15:11 <icarroll> needs let
13:15:16 <Zeroth|work> > let upWord n s = if ((s !! n) /= 'z') then (take (n-1) s) ++ succ (s !! n) ++ reverse(take ((length s) - n) (reverse(s)))) else upWord (n+1) (take (n-1) s) ++ 'a' ++ reverse(take ((length s) - n) (reverse(s)))) in upWord "asd"
13:15:16 <lambdabot>  Parse error
13:15:28 <icarroll> ok, not _the_ problem :)
13:15:33 <fax> > let insert char index string = (take index string) ++ [char] ++ (drop index string) in insert 'x' 3 "abcdef"
13:15:35 <lambdabot>  "abcxdef"
13:15:52 <kscaldef> doesn't the compiler tell you where the parse error is?
13:16:05 <Zeroth|work> kscaldef, lambdabot is all I have ftm
13:16:10 <Zeroth|work> for the minute
13:16:11 <Zeroth|work> heh
13:16:20 <hpaste>  glguy annotated "word permutation" with "more like this:" at http://hpaste.org/848#a1
13:16:32 <icarroll> looks like a mismatched paren
13:17:10 <hpaste>  zeroth annotated "word permutation" with "(no title)" at http://hpaste.org/848#a2
13:17:31 <psi`> glguy: /= :)
13:17:33 <fax> how do you pick random numbers?
13:17:39 <fax> or dont you?
13:17:48 <kscaldef> System.Random
13:17:52 <icarroll> @hoogle random
13:17:53 <lambdabot> Random.random :: (Random a, RandomGen b) => b -> (a, b)
13:17:53 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
13:17:53 <lambdabot> Random :: module
13:17:54 <fax> I mean Zeroth..
13:18:04 <fax> but I didnt know that so cheers
13:18:18 * Zeroth|work isnt using random numbers
13:18:52 <icarroll> Zeroth: you have an extra paren at the end of the "then" clause
13:19:11 <icarroll> and the "else" clause
13:19:25 <icarroll> >let upWord n s = if ((s !! n) /= 'z')
13:19:26 <icarroll>                  then (take (n-1) s)
13:19:27 <icarroll>                       ++ succ (s !! n)
13:19:28 <icarroll>                       ++ reverse(take ((length s) - n) (reverse(s)))
13:19:30 <icarroll>                  else upWord (n+1) (take (n-1) s)
13:19:33 <icarroll>                       ++ 'a'
13:19:34 <icarroll>                       ++ reverse(take ((length s) - n) (reverse(s)))
13:19:34 <icarroll> in upWord "asd"
13:19:41 <icarroll> > let upWord n s = if ((s !! n) /= 'z')
13:19:42 <lambdabot>  Parse error
13:19:43 <icarroll>                  then (take (n-1) s)
13:19:44 <icarroll>                       ++ succ (s !! n)
13:19:47 <icarroll>                       ++ reverse(take ((length s) - n) (reverse(s)))
13:19:48 <icarroll>                  else upWord (n+1) (take (n-1) s)
13:19:50 <icarroll>                       ++ 'a'
13:19:51 <icarroll>                       ++ reverse(take ((length s) - n) (reverse(s)))
13:19:52 <icarroll> in upWord "asd"
13:19:54 <icarroll> ok, not done yet
13:19:56 <icarroll> :)
13:20:10 <hpaste>  glguy annotated "word permutation" with "don't repeat yourself" at http://hpaste.org/848#a3
13:20:46 <icarroll> > let upWord n s = if ((s !! n) /= 'z') then (take (n-1) s) ++ succ (s !! n) ++ reverse(take ((length s) - n) (reverse(s))) else upWord (n+1) (take (n-1) s) ++ 'a' ++ reverse(take ((length s) - n) (reverse(s))) in upWord "asd"
13:20:47 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
13:20:57 <icarroll> ok, got past the parse errors
13:21:08 <fax> let string = "abc" in [1 .. (length string)]
13:21:09 <glguy> if ((s !! n) /= 'z')   -- is -- if s !! n /= 'z'
13:21:15 <fax> :S
13:21:19 <fax> > let string = "abc" in [1 .. (length string)]
13:21:20 <lambdabot>  [1,2,3]
13:21:27 <glguy> parenthesis abuse is bad for your health
13:21:47 <fax> > let string = "abc" in [1 .. length string]
13:21:49 <lambdabot>  [1,2,3]
13:21:50 <fax> :D
13:22:28 <glguy> > \n s -> reverse $ take (length s - n) (reverse s)
13:22:29 <lambdabot>  Add a type signature
13:22:37 <glguy> > (\n s -> reverse $ take (length s - n) (reverse s)) 3 [1..10]
13:22:39 <lambdabot>  [4,5,6,7,8,9,10]
13:22:43 <glguy> :t drop
13:22:45 <lambdabot> forall a. Int -> [a] -> [a]
13:23:06 <hpaste>  glguy annotated "word permutation" with "use drop" at http://hpaste.org/848#a4
13:25:23 <OneSadPengWin> can someone tell me if there are limitations on the types of "a" in StablePtr a that are allowed in foreign import declarations?
13:25:29 <hpaste>  glguy annotated "word permutation" with "using splitAt" at http://hpaste.org/848#a5
13:25:38 <OneSadPengWin> I'm getting an "Unacceptable argument type in foreign declaration" error
13:27:43 <fax> > map (map (+) [1..10]) [1..10]
13:27:44 <lambdabot>  Couldn't match expected type `a -> b'
13:27:48 <fax> ;/
13:28:04 <fax> I know zipWith
13:28:06 <fax> but why?
13:28:12 <sjanssen> fax: map (+) [1..10] :: Integer, it isn't a function
13:28:21 <fax> oh.. its a list of functions
13:28:25 <sjanssen> sorry, :: [Integer]
13:28:34 <sjanssen> blah, I'm wrong again
13:28:37 <fax> hehe
13:28:41 <sjanssen> [Integer -> Integer] :)
13:28:43 <fax> yeah I see why
13:28:45 <fax> ok cheers
13:29:01 <sjanssen> maybe you want zipWith (+) [1..10] [1..10]?
13:29:10 <glguy> > foldr id 0 (map (+) [1..10])
13:29:11 <lambdabot>  55
13:29:40 <glguy> > liftM2 (+) [1..3] [1..3]
13:29:41 <lambdabot>  [2,3,4,3,4,5,4,5,6]
13:30:14 <fax> aha liftM2
13:30:46 <fax> wheres liftM2 from?
13:30:51 <glguy> > map (\x -> map (x+) [1..3]) [1..3]
13:30:53 <lambdabot>  [[2,3,4],[3,4,5],[4,5,6]]
13:31:00 <glguy> ?index liftM2
13:31:00 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:31:44 <glguy> > map (flip map [1..3] . (+)) [1..3]
13:31:45 <lambdabot>  [[2,3,4],[3,4,5],[4,5,6]]
13:31:49 <psi`> > let ($$) = zipWith ($) in map (+) [1,2,3,4] $$ [1,2,3,4]
13:31:50 <lambdabot>  [2,4,6,8]
13:32:03 <abz> ?doc Network
13:32:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
13:32:09 <fax> > liftM2 (+) [0..3] [0..5]
13:32:11 <lambdabot>  [0,1,2,3,4,5,1,2,3,4,5,6,2,3,4,5,6,7,3,4,5,6,7,8]
13:32:43 <fax> I cant get liftm2 :/
13:32:48 <fax> ghci wont accept it
13:32:49 <glguy> :(
13:33:01 <icarroll> :t liftM2
13:33:04 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:33:15 <icarroll> :t liftm2
13:33:17 <lambdabot> Not in scope: `liftm2'
13:33:29 <fax> it jsut tells me Not in scope: `liftM2'
13:33:37 <glguy> ugh, wasn't case-sensitivity fixed in Visual Basic??
13:33:38 <Zeroth|work> > let strBefore n s = take (n - 1) s; strBefore :: Int Str; strAfter n s = reverse $ take (length s - n) (reverse s); strPerm n s = if ((s !! n) /= 'z') then (strBefore n s ++ succ (s !! n) ++ strAfter n s) else strPerm (n+1) (strBefore n s ++ 'a' ++ strAfter n s) in strPerm "asd"
13:33:39 <lambdabot>   Not in scope: type constructor or class `Str'
13:33:44 <Jaak> :m + Control.Monad
13:33:47 <Zeroth|work> wrong channel :-/
13:34:08 * glguy is blinded by the parentheses that are being absued!
13:34:15 * glguy dies from the spelling abuse!
13:34:43 <fax> urk :\
13:34:45 <Zeroth|work> :t map
13:34:48 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:35:34 <Zeroth|work> still stumped:
13:35:35 <Zeroth|work> > let strBefore n s = take (n - 1) s; strAfter n s = reverse $ take (length s - n) (reverse s); strPerm n s = if ((s !! n) /= 'z') then (strBefore n s ++ succ (s !! n) ++ strAfter n s) else strPerm (n+1) (strBefore n s ++ 'a' ++ strAfter n s) in strPerm "asd"
13:35:36 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
13:36:02 <Zeroth|work> I wish it would give column number
13:36:05 <glguy> Zeroth|work: did you pay attention to anything that was said in channel or on the pastebin?
13:36:14 <Zeroth|work> glguy, apparantly I did
13:36:15 <icarroll> <interactive>:1:158:
13:36:16 <icarroll>     Couldn't match `[a]' against `Char'
13:36:18 <icarroll>       Expected type: [a]
13:36:19 <icarroll>       Inferred type: Char
13:36:21 <icarroll>     In the expression: s !! n
13:36:22 <icarroll>     In the first argument of `succ', namely `(s !! n)'
13:36:33 <hpaste>  fax pasted "permutation" at http://hpaste.org/849
13:36:39 <fax> can I make it shorter :D
13:37:19 <fax> er can it be made shorter.. I mean
13:37:49 <sjanssen> fax: you should use pattern matching instead of if length string == 1
13:38:07 <fax> what dose it look like
13:38:12 <fax> does*
13:38:26 <fax> case length string ?
13:38:50 <sjanssen> permutation [c] = ... stuff you had in your then clause ...
13:38:57 <fax> aha
13:39:02 <narain> fax: also probably start with  permutation [] = []
13:39:03 <sjanssen> permutation s = ... stuff in the else ...
13:39:17 <Lacrimosa> am I fat ?
13:39:33 <narain> anyone here used visual haskell?
13:41:04 <hpaste>  fax pasted "turtle" at http://hpaste.org/850
13:41:23 <fax> which functions should I use to turn this into an array ? (withArray?)
13:41:33 <sjanssen> @hoogle withArray
13:41:33 <lambdabot> Foreign.Marshal.Array.withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
13:41:34 <lambdabot> Foreign.Marshal.Array.withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
13:41:34 <lambdabot> Foreign.Marshal.Array.withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
13:41:38 <sjanssen> fax: not withArray
13:41:43 <fax> oh good
13:41:47 <sjanssen> @hoogle arrayList
13:41:48 <lambdabot> No matches found
13:41:48 <fax> I cant get withArray
13:41:57 <sjanssen> @hoogle listArray
13:41:58 <lambdabot> Array.listArray :: Ix a => (a, a) -> [b] -> Array a b
13:41:58 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
13:41:58 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
13:42:04 <sjanssen> fax: there is one way
13:42:07 <fax> I need to change ' ' into 0 and '#' into 255 thogh, so I guess I just map it
13:42:48 <icarroll> fax: do you want a 1D or 2D array?
13:42:49 <sjanssen> fax: did you see all the elaborations I made on your pacman function?
13:42:57 <fax> sjanssen: yes!
13:43:00 <Zeroth|work> glguy, seems I missed the last two annotations on hpaste
13:43:07 <fax> sjanssen: its pretty neat:D
13:43:13 <fax> I havent tried to write it since then though
13:43:23 <fax> I thougt I should write somthing 'easier' first
13:43:31 <fax> icarroll: 1D
13:43:35 <sjanssen> http://hpaste.org/814#a2 -- I'm most proud of feed
13:43:47 <Zeroth|work> how long to hpastes live?
13:43:59 <glguy> until shapr decided to blow it away
13:44:04 <glguy> s/d/s
13:44:10 <sjanssen> fax: definitely.  These type class gymnastics are tricky (and usually useless)
13:44:19 <fax> heeh
13:44:25 <glguy> I'll pistol whip the first person that asks what secided means
13:44:36 <Zeroth|work> shapr, leave mine for a day or so :-)
13:44:44 <sjanssen> @dict secided
13:44:45 <lambdabot> Supported dictionary-lookup commands:
13:44:45 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
13:44:45 <lambdabot> Use "dict-help [cmd...]" for more.
13:44:48 <icarroll> fax: listArray (0,length arr') arr' where arr' = map frob (concat arr)
13:44:53 <sjanssen> @web1913 secided
13:44:54 <glguy> Zeroth|work: the idea is "forever" for some value of forever
13:44:55 <lambdabot> No match for "secided".
13:45:17 <fax> icarroll: cool thanks :D
13:46:00 <icarroll> fax: oops, got an off-by-one error in that code
13:46:37 <icarroll> fax: listArray (0,length arr' - 1) arr' where arr' = map frob (concat arr)
13:46:47 <Batterseapower> can anyone point me to a cute implementation of a type inferer in haskell? i've been trying to write my own and all my attempts are unspeakably ugly
13:48:30 <therp> I presume it would be a strange coincidence if anyone in here would have read the paper "Faking it" by Conor McBride and would have also concluded that there is an error in the type of vZipWith on page 3 -- http://citeseer.ist.psu.edu/mcbride01faking.html
13:48:34 <lambdabot> Title: Faking It: Simulating Dependent Types in Haskell - McBride (ResearchIndex)
13:50:17 <therp> where error is: "-> Vector m T" should read "|> Vector m T" ... |> should be the right triangle.
13:51:10 <glguy> has anyone read the book "Formal Methods in Computing" here?
13:53:06 <arvid> so - if I have a buffer with some haskell in emacs. how can I then quickly run it in the interpreter?
13:53:10 <Botje> Batterseapower: if you can find it, the book "Implementation of Functional Programming Languages" by Simon L. Peyton Jones covers it.
13:53:14 <Botje> among other things
13:53:33 <augustss_> Batterseapower: http://citeseer.ist.psu.edu/424440.html
13:53:34 <lambdabot> Title: Typing Haskell in Haskell - Jones (ResearchIndex)
13:54:05 <therp> arvid: use haskell-mode and hit C-c C-l
13:54:27 <arvid> therp: thanks (I already was in haskell-mode)
13:54:29 <Batterseapower> thanks augustss_ and Botje, i'll look at those
13:54:31 <therp> battlerseapower: if you need a copy of the code of typing haskell in haskell, I should have a tarball
13:55:29 <narain> how do i do something like  \list -> [0..length list]  without calling  length ? that doesn't work on infinite lists
13:55:46 <narain> oh wait, fold
13:55:56 <glguy> narain: zipWith const [1..]
13:56:01 <glguy> err
13:56:03 <glguy> [0..]
13:56:05 <augustss_> narain: map fst (zip [0..] list)
13:56:10 <narain> glguy: ah that's very good
13:56:42 <kscaldef> C-c C-l only works if you have hugs installed, right?
13:56:43 <narain> glguy++
13:56:56 <narain> thanks augustss_ too
13:57:06 <Botje> take (length list) [0..]
13:57:07 <augustss_> glguy's is more elegant
13:57:08 <therp> narain:  \list -> enumFromTo 0 (length list) should also work
13:57:23 <therp> narain: but glguy's solution is better as it's more lazy
13:57:39 <icarroll> therp: narain specifically said to not use length
13:57:41 <Batterseapower> therp: a code example would be great, thanks!
13:57:42 <therp> narain: ah sorry, I misread your question
13:57:53 <therp> icarroll: I just found out, sorry
13:57:58 <glguy> now that I have the "correct" answer out of the way...
13:57:59 <fax> :t texImage2D
13:58:01 <lambdabot> Not in scope: `texImage2D'
13:59:18 <glguy> ?type flip evalState 0 . mapM (const (get >>= \x -> modify succ >> return x))
13:59:19 <lambdabot>     Ambiguous occurrence `mapM'
13:59:19 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
13:59:28 <glguy> ?type flip evalState 0 . Control.Monad.mapM (const (get >>= \x -> modify succ >> return x))
13:59:31 <lambdabot> forall s a. (Enum s, Num s) => [a] -> [s]
13:59:36 <abz> ?users
13:59:36 <lambdabot> Maximum users seen in #haskell: 339, currently: 312 (92.0%), active: 49 (15.7%)
13:59:46 <glguy> flip evalState 0 . Control.Monad.mapM (const (get >>= \x -> modify succ >> return x)) $ [3,7,2,7,8,9,1]
13:59:50 <glguy> > flip evalState 0 . Control.Monad.mapM (const (get >>= \x -> modify succ >> return x)) $ [3,7,2,7,8,9,1]
13:59:52 <lambdabot>  [0,1,2,3,4,5,6]
14:00:04 <Saizan> does manyTill a end consumes the input matched by end when it succedes?
14:00:38 <fax> :/
14:00:41 <fax> I cant get it works
14:00:53 <icarroll> > let glguy = "evil" in glguy
14:00:54 <lambdabot>  "evil"
14:01:44 <therp> batterseapower: just give me your email, and I will sent you two tarballs (courtesy of Neil Mitchell)
14:01:54 <glguy> ?karma
14:01:54 <lambdabot> You have a karma of 50
14:02:06 <glguy> thnx narain !
14:02:22 <therp> woot I have a karma of one.
14:02:47 <fax> I need a listArray to turn into a ptr
14:03:14 <narain> i didnt know foo++ incremented karma, i thought it was just a local turn of phrase :p
14:03:29 <narain> oh well enjoy your karma :)
14:03:40 <Saizan> @karma foo
14:03:41 <lambdabot> foo has a karma of 0
14:04:09 <mauke> @karma c
14:04:10 <lambdabot> c has a karma of 15
14:04:19 <glguy> I think that c++ has been "fixed"
14:04:21 <narain> :D
14:04:36 <Saizan> on #c "i" must have a huge karma
14:04:52 <glguy> modifying Java's karma used to decrement your own karma
14:04:59 <fax--> if oyou have a function f, what does "f." mean?
14:05:03 <glguy> and before that it would increment your own
14:05:17 <glguy> the same thing as f .
14:05:21 <glguy> . being the compose function
14:05:21 <fax--> hehe
14:05:24 <cjeris> Asuras with Karma are not permitted to leave the Sea of Milk.
14:05:26 <fax--> Aha!
14:05:27 <fax--> ok thanks
14:06:34 <procyon_> c--
14:07:05 <abz> ?poll-list
14:07:05 <lambdabot> ["EvilPoll","OperatingSystem","RestrictToOneVote","Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
14:08:22 <fax--> "newArray :: Storable a => [a] -> IO (Ptr a)"
14:08:29 <fax--> so I call it newArray somelist
14:08:41 <fax--> but how do you provide a type signiture?
14:08:49 <fax--> (to say the items in the list are Int's)
14:08:54 <sjanssen> fax--: you don't want to use newArray
14:09:04 <fax--> I get (Ptr a)
14:09:05 <sjanssen> that type of array is only used for interfacing with C
14:09:06 <fax--> which I need
14:09:13 <fax--> for calling texImage2D Nothing NoProxy 0  RGBA' (TextureSize2D 16 16) 0 (PixelData RGBA UnsignedByte turtleArray)
14:09:25 <sjanssen> oh, so you're interfacing with C
14:09:32 <fax--> hopefully :[
14:09:39 <fax--> I dont know how to make the array though
14:09:41 <sjanssen> you may proceed
14:09:45 <fax--> hehe
14:10:02 <fax--> can I change "newArray arr" to somthing to make the ghc shut up?
14:10:20 <sjanssen> what is ghc complaining about?
14:10:33 <fax--> Ambiguous type variable `t' in the constraints: `Foreign.Storable.Storable t' Probable fix: give these definition(s) an explicit type signature
14:11:00 <sjanssen> fax--: that means GHC doesn't know the type of the array you're creating
14:11:06 <fax--> yeah
14:11:10 <sjanssen> what should it be?  Ptr Word8?
14:11:26 <fax--> I think so, maybe just Ptr Int
14:11:34 <fax--> actually Word8 sounds more likley
14:11:55 <sjanssen> you can write: newArray arr :: IO (Ptr Word8)
14:11:56 <fax--> I got some example code which uses withArray but I cant work it out at all
14:12:06 <sjanssen> @hoogle withArray
14:12:07 <lambdabot> Foreign.Marshal.Array.withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
14:12:07 <lambdabot> Foreign.Marshal.Array.withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
14:12:07 <lambdabot> Foreign.Marshal.Array.withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
14:12:29 <mauke> withArray list $ \ptr -> do ...
14:12:43 <sjanssen> fax--: yeah, withArray is probably better here.  If you use newArray, you'll have to free that memory later on
14:12:53 <sjanssen> but withArray handles all that for you
14:18:20 <fax--> @hoogle Ptr
14:18:20 <lambdabot> Foreign.Ptr :: module
14:18:21 <lambdabot> Foreign.Ptr.Ptr :: data Ptr a
14:18:21 <lambdabot> GHC.Exts.Ptr :: Addr# -> Ptr a
14:19:45 <hpaste>  fax pasted "texImage2D attempt" at http://hpaste.org/851
14:20:34 <fax--> any ideas what is wrong? ghc says Couldn't match expected type `Ptr a' against inferred type `[Integer]'
14:20:49 <fax--> so its like ptr is actually just the list
14:21:07 <sjanssen> fax--: what is the type of turtleArray?
14:21:28 <fax--> [Integer]
14:22:28 <mauke> (PixelData RGBA UnsignedByte turtleArray) (PixelData RGBA UnsignedByte ptr) looks wrong
14:22:40 <hpaste>  sjanssen annotated "texImage2D attempt" with "(no title)" at http://hpaste.org/851#a1
14:22:58 <fax--> wops
14:23:07 <fax--> cheers mauke I didnt notice that was still there
14:23:23 <sjanssen> fax--: which library are you using?
14:23:36 <fax--> Graphics.UI.GLUT and Foreign
14:23:53 <fax--> I got some working example using withArray..
14:26:11 <kuribas> Why isn't if just a function?
14:28:03 <sjanssen> kuribas: if then else saves parentheses (which is barely a good reason)
14:28:50 <int-e> kuribas: the 'then' and 'else' give visual clues and leaving out 'else' gives a syntax error instead of a weirder type error. also, implementing if as a function is still possible - you don't lose much by adding it as syntax sugar.
14:29:29 <kuribas> Yes, but the if then else syntax looks ugly to my eyes.
14:29:35 <int-e> (arguably, such a function should be in the prelude, say  if' x y z = if x then y else z)
14:29:55 <newsham> well if it looks ugly to you we should get rid of it.
14:30:08 <int-e> I like it.
14:30:31 <int-e> should we create two different Haskell dialects now? :)
14:30:38 <sjanssen> newsham: you look ugly
14:30:46 <sjanssen> can we get rid of newsham?
14:30:49 <sjanssen> ;)
14:30:52 <newsham> we should.
14:30:57 <newsham> newsham is extraneous
14:31:21 <int-e> kuribas: do you have a Lisp background?
14:31:33 <kuribas> I just mean, "if x then y else z" is not a big improvement over "if x y z" is it?
14:31:34 <fax--> any idea how to turn an Integer into a GLubyte?
14:31:43 <kuribas> int-e: yes, I program in scheme also :)
14:31:59 <fax--> kuribas: what about if x y z w
14:32:07 <sjanssen> int-e: yes, we should definitely have if' -- because, if for no other reason, it's the catamorphism for Bool
14:32:08 <fax--> vs if x then y z else w
14:32:10 <newsham> kurib:   if <long expr>\n<tab>then <long expr>\n<tab>else <long expr>    has its advantages
14:32:19 <sjanssen> fax--: fromIntegral might work
14:32:20 <int-e> kuribas: define  if'  as I said and use it. one of the nice things about Haskell (in my opinion) is that it's rather rich on syntax sugar.
14:32:31 <fax--> sjanssen: cheers ill look it up
14:32:36 <emu> syntax sugar rots teeth
14:32:37 <int-e> kuribas: but of course nobody is forced to use it.
14:32:59 <Philippa> emu: and ruins your byte?
14:33:35 <sjanssen> @localtime dons
14:33:38 <lambdabot> Local time for dons is Thu Mar  8 09:31:34 2007
14:33:41 <emu> an apple a day keeps the \bot away
14:34:05 <kuribas> int-e: right.
14:34:20 <newsham> we could also get rid of infix operators and layout formatting
14:34:30 <fax--> I got my turtle to display!
14:34:33 <fax--> Thanks so much for all the help
14:34:48 <sjanssen> newsham: and remove equation style/guards in favor of case and the if function
14:35:25 <kuribas> newsham: I would be in favour of removing the layout formatting :)
14:35:26 <Philippa> and explicit lambdas. Without patterns
14:35:48 <fax--> kuribas: same ;(
14:35:59 <sjanssen> kuribas: you can take layout formatting . . . when you pry it out of my cold, dead hands
14:36:10 <newsham> kuri: of course, cause you want haskell-scheme :)
14:36:19 <augustss_> kuribas: just wait.  I used to hate it.  now i love it
14:36:20 * SamB wonders how smlnj can give type errors when you have unbound variables
14:36:21 <newsham> (which you could write, btw, in 48hrs)
14:36:26 <fax--> haskell scheme is a good idea :)
14:36:31 <kuribas> No, I just want my editor to do the indentation for me.
14:36:34 <Philippa> augustss_: how long did it take you, anyway?
14:36:50 <kuribas> Ruby has nice syntax too IMO.
14:36:51 <augustss_> Philippa: until I started using it :)
14:36:54 <Philippa> it took me about as long as it took to look up the actual definition in the report and thus never make a layout mistake again
14:36:55 <fax--> infact just any scheme as popular as haskell would be great
14:37:25 <Philippa> kuribas: you can have that and a layout rule at the same time, y'know
14:37:58 <Philippa> fax--: I don't know about now, but it certainly wasn't long ago that scheme was definitely more popular
14:38:11 <newsham> kuri: how does the editor know when you intend to indent?
14:38:26 <glguy> newsham: there are a limited number of meaningful indentations
14:38:31 <glguy> and the editor can iterate through those
14:38:34 <glguy> like haskell-mode does
14:38:41 <newsham> true
14:38:50 <kuribas> newsham: because the syntax doesn't depend on indentation.
14:38:50 <Philippa> I thought it might be a bad idea after we'd told James McKinna that IRC's old tech to mention that I've been around more than half #haskell's existance though
14:38:51 <fax--> Philippa: well my scroll bar is half the size in this channel than #scheme :D
14:38:51 <newsham> but there's not one unique one (partial application and all)
14:38:59 <newsham> unless you use lots of silly parenthesis
14:39:06 <newsham> then it would be unambiguous
14:39:17 <eddyp> CosmicRay: yes :-)
14:39:33 * Randroid uses lots of parentheses, but his are never silly.
14:39:41 <Philippa> fax--: true, but #haskell's been central in a way I don't think #scheme ever was
14:39:57 <CosmicRay> eddyp: very good channel, that
14:40:04 <CosmicRay> whoa
14:40:09 <CosmicRay> ok that freaked me out
14:40:14 * eddyp entered today for the first time
14:40:21 <eddyp> :-)
14:40:32 <kuribas> newsham: Ruby doesn't use lots of silly parenthese, but it's syntax doesn't depend on indentation.
14:40:33 <CosmicRay> I am not used to typing something to a person in another channel on another network and have them reply here ;-)
14:41:21 <kuribas> People generally like haskell syntax?
14:41:21 <CosmicRay> eddyp: heard of HSH?
14:41:22 <newsham> kuri: you dont need to use indentation in your syntax in haskell.
14:41:23 * glguy have noticed that those that complain about the haskell layout rules are those that don't understand them
14:41:24 <Philippa> kuribas: there are some obviously sensible places for an editor to try indenting if they preceed a newline though
14:41:24 <newsham> its optional.
14:41:26 <CosmicRay> kuribas: I do
14:41:34 <CosmicRay> kuribas: though the emacs haskell mode stinks
14:41:41 <eddyp> CosmicRay: your latest shell?
14:41:42 <CosmicRay> if you use python, it will look very familiar
14:41:49 <CosmicRay> eddyp: http://software.complete.org/hsh
14:41:52 <lambdabot> Title: HSH
14:42:09 <CosmicRay> eddyp: it's a haskell library for doing shell scripting, including piping between both commands and haskell functions
14:42:12 <therp> glguy: the indention logic in haskell-mode compares to the indention logic of scheme like a 3 day old pizza does to do a fresh lobster menu! haskell-mode does not know how to reindent, that's the biggest problem
14:42:20 <kuribas> CosmicRay: Yes, I have been thinking to write my own indentation engine in elisp.
14:42:47 <therp> glguy: my biggest problem with Haskell is the reindention borkenness. I waste lot of time reindention my code blocks. I should really switch to Liskell ;)
14:43:08 <CosmicRay> therp: you realize that you can use a C-like syntax that doesn't care about indentation, right?
14:43:10 <eddyp> CosmicRay: I have read your blog on both debian and haskell planet :-)
14:43:18 <CosmicRay> eddyp: oh ok, then you've got it ;-)
14:43:20 <therp> cosmicray: If I would like C syntax I would code C.
14:43:32 <CosmicRay> therp: bah, Java uses C syntax.
14:43:34 <CosmicRay> ok bad example.
14:43:38 <therp> I don't code Java :)
14:43:41 <CosmicRay> *perl* uses C syntax ;-)
14:44:03 <sjanssen> therp: use explicit layout
14:44:25 <sjanssen> oops, CosmicRay already has that base covered :)
14:44:30 <therp> (I do code Java, but only for cold hard cash, and I try to do it like one would do it for one night stands, get in and out as quick as possible)
14:44:43 <CosmicRay> therp: excellent
14:44:44 <therp> sjanssen: I dislike explicit layout.
14:44:56 <CosmicRay> therp: you are hard to please
14:45:30 <therp> cosmicray: I'm used to Lisp syntax. There is nothing better (that's only my personal oppinion, not an argument)
14:45:37 <CosmicRay> uh
14:45:39 <CosmicRay> heh
14:45:40 <sjanssen> Haskell layout becomes easier to manage once you become less picky
14:45:57 <CosmicRay> sjanssen: if I became less picky, I might like Java too ;-)
14:46:33 <sjanssen> CosmicRay: you don't have to be /that/ lax
14:46:37 <Zeroth404> someone define "aux"
14:46:39 <CosmicRay> heh
14:46:47 <sjanssen> Zeroth404: it isn't a standard function
14:46:49 <dmead> emacs handles my layout :)
14:46:53 <glguy> aux = undefined
14:46:57 <dmead> just press enter and it read yer mind!
14:46:59 <Zeroth404> sjanssen: that thought just occured to me
14:47:01 <sjanssen> @hoogle aux
14:47:02 <lambdabot> No matches found
14:47:11 <halassocracy> i use notepad
14:47:20 <therp> there will be never stuff like paredit-wrap-sexp paredit-splice-sexp or paredit-forward/backward-barf/slurp-sexp. That does not work with haskell syntax
14:48:02 <sjanssen> therp: (I have no idea what those things do)  are you really confident enough to say "never"?
14:48:02 <therp> also code navigation along sexp nesting/levels is much more convenient (for moving code around)
14:48:05 <Zeroth404> sjanssen: so haskell supports function overloading like as C++ does?
14:48:18 <sjanssen> Zeroth404: not exactly
14:48:21 <sjanssen> why do you ask?
14:48:29 <Zeroth404> http://hpaste.org/848
14:48:34 <Zeroth404> last annotation
14:48:42 <therp> sjanssen: I'm fairly confident yes.
14:49:06 <sjanssen> Zeroth404: that isn't overloading
14:49:26 <sjanssen> Zeroth404: you should probably read up on Haskell syntax
14:49:26 <Zeroth404> sjanssen: aye
14:49:44 <Zeroth404> sjanssen: no I understand it, I'm just not used to seeing that in a "where"
14:49:46 <therp> but I guess the number of people in this channel that have been exposed to Lisp syntax are too small.. so I stop arguing as the arguments don't sound plausible for the rest..
14:49:48 <sjanssen> what aux is doing, is pattern matching
14:50:13 <sjanssen> Zeroth404: oh, where is just for local definitions
14:50:14 <halassocracy> (+) is overloaded
14:50:28 <narain> what's the built-in function that does  \f (x,y) -> (f x, f y) ? i remember it had something to do with functions being arrows
14:50:52 <dino-> :t curry
14:50:52 <sjanssen> @. pl djinn (a -> b) -> (a, a) -> (b, b)
14:50:53 <lambdabot> f = (`ap` snd) . (. fst) . (const .) . (ap =<< ((,) .))
14:50:54 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:51:20 <hpaste>  glguy annotated "word permutation" with "less confusing?" at http://hpaste.org/848#a6
14:51:29 <dino-> mm, doesn't sound like what you're asking for
14:51:33 <narain> @djinn (a -> b) -> (a , a) -> (b, b)
14:51:33 <lambdabot> f a (b, _) = (a b, a b)
14:51:44 <mauke> @type (&&&)
14:51:47 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:51:52 <glguy> therp: I've seen the neat stuff you can do with Lisp in emacs, I just don't think that that is a compelling enough reason to use Lisp
14:51:54 <narain> yes, i tried @pl but it didn't give me what i wanted
14:52:01 <dino-> :t (***)
14:52:03 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:52:04 <narain> mauke: that looks right
14:52:15 <glguy> :t join (***)
14:52:18 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
14:52:32 <narain> :t join (***) (+1)
14:52:33 <icarroll> > join (***) (+1) (+2) 5
14:52:35 <lambdabot>  Couldn't match expected type `t1 -> t'
14:52:35 <lambdabot> forall c. (Num c) => (c, c) -> (c, c)
14:52:39 <therp> glguy: that's why I've done Liskell. or did you mean "compelling enough to use Lisp syntax"?
14:52:55 <icarroll> > join (***) (+1) (17,42)
14:52:57 <lambdabot>  (18,43)
14:53:01 <narain> hey that works
14:53:04 <narain> excellent
14:53:06 <narain> thanks all
14:53:18 <glguy> therp: ah, I don't know anything about Liskell
14:53:31 <dmhouse> narain: a bit unreadable, though. I'd use (\(x, y) -> (x + 1, y + 1)).
14:53:31 <therp> glguy: It's just Haskell with Lisp syntax. (with meta-programming)
14:54:11 <therp> glguy: so instead of (\x y -> x + y) it's (lambda (x y) (+ x y))
14:54:19 <icarroll> narain: when I needed that function, I made my own called mapBoth
14:54:22 <therp> glguy: but underneath it's Haskell.
14:54:25 <glguy> therp: ah...
14:54:37 <siti> wow finally ghc 6.6 in mainline portage!
14:57:33 <therp> siti: masked and so on..
14:57:48 <therp> good and productive night everyone..
15:01:39 <siti> yeah
15:02:46 <glguy> fax--: u there
15:02:56 <fax--> y9i
15:03:21 <glguy> length x == 1 -- is a bad idea
15:03:36 <fax--> somone mentioned pattern matching
15:03:40 <fax--> I tried it and it works very nicely:D
15:03:55 <ndm> glguy: but nothing better in the standard libs...
15:04:05 <glguy> ndm: so?
15:04:14 <fax--> why is it a bad idea though?
15:04:26 <glguy> fax--: because if the list is 100, you have to find that out
15:04:32 <glguy> if the list is a lazy infinite list
15:04:35 <ndm> glguy: so its almost suggesting that Haskell programers have had nothing better forumlated - i have my own eqOne, neqOne etc, but not everyone does
15:04:37 <glguy> you just loose outright
15:04:57 <ndm> if you had lazy natural numbers, you don't
15:05:14 <augustss_> lazy naturals would be nice
15:05:15 <fax--> aha
15:05:16 <sjanssen> and if length were polymorphic in it's return type
15:05:18 <fax--> cool
15:05:37 <nominolo> couldn't you add rewrite rules?
15:05:59 <nominolo> at least for simple cases like length x == 0 / 1 / 2 ... some small number
15:06:03 <icarroll> :t genericLength
15:06:05 <lambdabot> forall b i. (Num i) => [b] -> i
15:06:07 <sjanssen> nominolo: you should never write rules that change semantics
15:06:27 <ndm> augustss_: thats what Colin says...
15:06:34 <nominolo> sjanssen: true ..
15:07:06 <augustss_> i mostly trust colin :)
15:07:10 <glguy> length x == 1 -- is -- not (null x) && null (tail x)
15:07:42 <ndm> glguy: thats dangerous, relying on lazy evaluation and someone not screwing that up...
15:07:56 <glguy> ndm: so you write lengthOne and use that
15:08:12 <ndm> glguy: yes, i have oneLeq, oneGeq etc defined in my lib
15:08:15 <sjanssen> I'm not so sure about lazy Nats
15:08:33 <ndm> glguy: i'm mainly complaining because Catch can't prove the above property - its nothing wrong with it ;)
15:08:37 <Igloo> I tend to define lengthIs/lengthAtMost/lengthAtLeast when I need to do that sort of thing
15:08:39 <glguy> ndm: I just don't want to argue that fax isn't smart enough to get it right, so he should use length x -- 1
15:08:55 <ndm> glguy: indeed, using length is horrible!
15:08:55 <glguy> ndm: ah, I don't know anything about Catch :)
15:09:09 * glguy imagines adding a compiler warning to length
15:09:10 <ndm> glguy: i know more than you could possibly imagine about catch...
15:09:17 <sjanssen> in the presence of numeric defaulting, you have to write 1 :: Nat to make sure that your program doesn't explode
15:09:30 <ndm> sjanssen: (S Z)
15:09:38 <fax--> glguy: wat
15:09:40 <sjanssen> s/defaulting/overloading and defaulting
15:09:45 <fax--> length x -- 1 ? O_o
15:09:46 <sjanssen> ndm: that's hardly better
15:09:54 <glguy> fax--: they are called typos
15:09:55 <ndm> sjanssen: but more pure
15:10:01 <glguy> fax--: look down at your keyboard
15:10:06 <fax--> glguy: well I changed it to use pattern matching like 3 hours ago
15:10:07 <ndm> > length [1..] > 1
15:10:11 <lambdabot> Terminated
15:10:18 <sjanssen> ndm: why is it more pure?
15:10:37 <tessier_> hmm
15:10:38 <ndm> > let xs = [1..] in  not (null xs) && not (null (tail xs))
15:10:39 <lambdabot>  True
15:10:46 <ndm> fax--: see the difference?
15:10:46 * tessier_ is pondering his companies data warehouse problem
15:11:00 <tessier_> And I'm wondering why much greater use of memoization isn't used in data warehousing
15:11:16 <tessier_> I bet the same columns are added up over and over again many times and get the same results each time.
15:11:20 <ndm> sjanssen: everything in Haskell is lazy, apart from numbers, where we use hardware registers because <... insert made up reason here ...>
15:11:48 <sjanssen> ndm: because of representation of numbers that takes O(n) memory is ridiculously expensive
15:11:52 <icarroll> ndm: because unary numbers are skicky-fricky
15:11:56 <sjanssen> s/of/a
15:12:06 <ndm> sjanssen: who said lazy naturals take O(n) memory?
15:12:25 <ndm> sjanssen: i've seen projects doing it as (Int, lazy part), which work just fine
15:12:51 <sjanssen> ndm: then length x > 1 is still ridiculously inefficient
15:13:02 <bos> hmm, i can't get useful haddocks when i try to haddock the network package.
15:13:14 <ndm> sjanssen: no, you lazily evaluate the int, and accumulate - you can get it being both fully lazy, and efficient space/time wise
15:13:15 <augustss_> length x > 1 would be very efficient
15:13:42 <Laney> Can someone enlighten me as to what the @ operator does please?
15:13:47 <glguy> lengthGt n = not . null . drop n
15:13:54 <ndm> @google what about the natural numbers
15:13:56 <lambdabot> http://en.wikipedia.org/wiki/Natural_number
15:13:57 <glguy> lengthLt n = null . drop n
15:14:00 <icarroll> Laney: it's not an operator. it gives a name to a pattern
15:14:01 <ndm> @google what about the natural numbers runciman
15:14:04 <lambdabot> http://citeseer.ist.psu.edu/45669.html
15:14:04 <lambdabot> Title: What About the Natural Numbers - Runciman (ResearchIndex)
15:14:08 <sjanssen> ndm: how?
15:14:14 <Laney> icarroll, right
15:14:16 <ndm> sjanssen: ^^^, that answers all your questions
15:14:28 <glguy> err, LtEqTo
15:14:38 <sorear> hello!
15:14:55 <ndm> sjanssen: after reading that, you'll realise that not having natural numbers is just silly
15:15:02 <ndm> sorear: hello
15:15:33 <glguy> sorear: do you know lambdabot well enough to fix the namespace collision for mapM?
15:16:26 * glguy &
15:16:56 <sjanssen> ndm: this paper answers the question of how to do nats lazily and efficiently?
15:17:37 <astrolabe> Laney: Section 3.17.1 http://www.haskell.org/onlinereport/exps.html
15:17:38 <lambdabot> Title: The Haskell 98 Report: Expressions
15:18:04 <ndm> sjanssen: yes
15:18:26 <sjanssen> I'm not convinced
15:18:59 <sjanssen> in the case of this length comparison, at least
15:19:30 <Laney> Thanks astrolabe, makes sense now
15:19:56 <sorear> glguy: yes
15:21:46 <sjanssen> The pair definition is the same as [Int].  Under the most lazy definition of (+), length (repeat ()) returns repeat 1.  This means that length x > 1 is very quick
15:22:38 <sjanssen> but what happens with: show $ length [1 .. 2^20]?
15:22:45 <sjanssen> ndm: am I missing something?
15:23:24 <newsham> > show $ length [1..2^20]
15:23:26 <lambdabot>  "1048576"
15:24:21 <ndm> sjanssen: length 2^20 requires 2^20 additions of 1, show $ length [1..big] requires big Succ's, then big additions of +1, same complexity
15:24:22 <sjanssen> I suppose show could overcome that, by strictly collapsing the list
15:25:17 <sjanssen> okay, how about: let x = length [1 .. 2^20; do print x; print (x*x)
15:25:39 <sjanssen> let x = length [1 .. 2^20]; do print x; print (x*x) -- rather
15:26:08 <sjanssen> that will probably consume all of your computer's memory
15:26:31 <ndm> sjanssen: you can automatically collapse S ... (100 times) to (100, Z)
15:26:38 <ndm> i.e. in the GC or something
15:26:45 <ndm> which gives you the same memory efficiency
15:27:36 <ndm> sjanssen: colin had a student project that rewrote Int -> (Int, Lazy_Nat) in the Prelude, and it worked fine
15:27:38 <sjanssen> ndm: and can you depend on this GC magic to work 100% of the time?
15:27:43 <ndm> sjanssen: yes
15:28:07 <sjanssen> ndm: is this student's work available?  I'd like to see what happens under pathological cases like this
15:28:22 * SamB wonders whether translating to SML is a reasonable implementation strategy for RML
15:28:24 <ndm> sjanssen: not online, i think, but if you're ever in york i can get you a hard copy....
15:28:29 <fasta> Is there anyone that knows when unsafePerformIO is safe or any document describing it? The GHC FAQ is rather vague and other people asking the same question also only received vague answers.
15:28:47 <sjanssen> ndm: I don't think you can rely on the GC to do this
15:28:50 <SamB> hmm.
15:29:01 <ndm> sjanssen: you could modify the GC, and you can encode it youself - its possible
15:29:01 <sorear> fasta: "If you have to ask, it isn't safe"
15:29:16 <sorear> fasta: actually the FFI spec says when
15:29:19 <dons> morning.
15:29:24 <sorear> h.
15:29:27 <fasta> sorear: fantastic
15:29:35 <ndm> dons: good night
15:29:52 <fasta> sorear: I read that quote earlier, but of course it's just an excuse.
15:31:01 <Philippa> it's safe when it's okay for it to happen in whatever order (including possible duplication) the compiler pulls out of whatever orifices it happens to have
15:31:32 <dons> bah, I was hoping sjanssen would add workspace support to thunk while I was asleep ;-)
15:31:58 <sjanssen> dons: nope :)
15:32:09 <sjanssen> but I can tell you how dwm does it
15:32:19 <dons> ah, that's what I couldn't work out
15:32:27 <dons> how do we hide or make visible sets of windows?
15:32:31 <sjanssen> it moves all the windows that shouldn't be visible offscreen
15:32:45 <dons> oh! literally moves them to some funny location?
15:32:52 * cjay wonders if the xlib binding is enough to write a windowmanager in haskell
15:32:55 <dons> so 'view' restacks the visible windows, andmoves everything else
15:32:58 <dons> cjay, indeed it is.
15:33:02 <cjay> cool
15:33:03 <sjanssen> dons: that's what it seems like to me
15:33:08 <fasta> Philippa: ok, so when I want to visualise something using an external application and don't care whether it's displayed once or more(within certain limits) that would work?
15:33:09 <dons> ok. that's reasonable.
15:33:15 * SamB just remembered that RML has that stupid "taintedness" property...
15:33:21 <cjay> maybe I should write one, since ion dropped xinerama support :(
15:33:37 <syntaxfree> what is the simplest data type for handling date-times in Haskell?
15:33:40 <sjanssen> cjay: it isn't quite good enough.  The stuff that is there works great, but I've had to write extra bindings for several missing functions
15:33:50 <syntaxfree> I'm looking at Data.Time.Localtime and am a bit confused by all the options.
15:34:24 <cjay> sjanssen: you wrote a windowmanager?
15:34:26 <sjanssen> cjay: how complicated is xinerama?
15:34:29 * SamB supposes he might as well just write a slow interpreter in Haskell
15:34:30 <cjay> dunno
15:34:34 <sjanssen> cjay: yeah, we're hacking on one now
15:34:36 <sjanssen> @where thunk
15:34:37 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/thunk/
15:34:43 * cjay looks
15:35:29 <cjay> under 500 lines, wow
15:36:00 <nominolo> SamB: what's RML?
15:36:08 <cjay> sjanssen: I found dwm a bit too limiting, will thunk have more features?
15:36:10 <dibblego> ?where yaht
15:36:11 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
15:36:26 <fasta> "This value should be independent from the environment".
15:36:32 <sjanssen> cjay: thunk intends to be very minimal
15:36:37 <fasta> What environment?
15:36:50 <sjanssen> cjay: what sort of features did you miss?
15:37:22 <cjay> sjanssen: customizing the tiling, I don't like autoatic tiling
15:37:26 <cjay> +m
15:37:51 <cjay> manual splitting
15:38:38 <sjanssen> cjay: I have a theory.  What is the aspect ratio of your monitor?
15:39:00 <sjanssen> ie, is it widescreen?
15:39:04 <cjay> sjanssen: 1.25
15:39:04 <cjay> no
15:39:22 <cjay> but I will buy an additional widesrceen probably
15:39:45 <fasta> AFAIU, setting an ioref in the IO monad once and getting it via unsafeperformio afterwards, is safe.
15:39:59 <sjanssen> cjay: I disliked dwm's auto tiling until I used it on my widescreen laptop
15:40:01 <sorear> fasta: don't do that!
15:40:21 <sjanssen> I think it doesn't work very well for the typical aspect ratio
15:40:21 <sorear> fasta: global state is EVIL, regardless of language!
15:40:25 <sjanssen> anyway, I've got to run
15:40:27 <cjay> hum
15:40:30 <fasta> sorear: Well, I am using the "spec"
15:40:48 <sorear> fasta: it's safe but you still shouldn't do it.
15:40:54 <sorear> @quote SPJ: advanced haskell processor, theory and practice
15:40:55 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
15:40:55 <fasta> sorear: This is just for a theoretical exercise to get familiar with the semantics
15:41:07 <sorear> fasta: it's not safe in theory
15:41:18 <SamB> @quote memorable
15:41:18 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
15:41:29 <fasta> sorear: Why not? The spec doesn't contradict my statement, right?
15:41:29 * SamB misses the good old days
15:41:58 <icarroll> @quote famous
15:41:59 <lambdabot> mbishop says: darn, someone removed my one quote from lambdabot now I'll never be famous :(
15:42:00 <sorear> fasta: it is (relatively) safe only in practice, the compiler can duplicate calls to newIORef (thus fracturing your "global" state into independant pieces"
15:42:09 <syntaxfree> bah, this is confusing.
15:42:20 <fasta> sorear: the newIORef was in the IO monad
15:42:32 <syntaxfree> I want a date-time format that can be both queried as seconds or transformed into dates for "date difference" uses.
15:42:36 <fasta> sorear: that should be set without unsafeperformio
15:42:57 <fasta> sorear: or is it unsafe even in that case, if that's the case I am missing something.
15:43:09 <sorear> fasta: so the IORef is created legitimately?  ok, I hope it is only written once
15:43:19 <fasta> sorear: it is
15:43:21 <sorear> what's claus reinke's nick?
15:43:48 <fasta> sorear: are all the unsafePerformIO "actions" atomic?
15:44:36 <sorear> @quote ClausReinke
15:44:37 <lambdabot> No quotes match. Where did you learn to type?
15:44:49 <fasta> sorear: Since if that's the case, writing the same value with unsafePerformIO should also work
15:44:59 <sorear> @quote SPJ:.advanced.haskell.processor,.theory.and.practice
15:44:59 <syntaxfree> :~how do I get the current time?
15:44:59 <lambdabot> No quotes match. You speak an infinite deal of nothing
15:45:02 <bd_> fasta: No, but they're not lazy either; I'm almost certain, the action in the unsafePerformIO will be fully evaluated before a value is returned.
15:45:03 <syntaxfree> (It's probably on the IO monad)
15:45:11 <bd_> but there's nothing stopping it from interleaving with other threads
15:45:16 <sorear> @remember ClausReinke SPJ: advanced haskell processor, theory and practice
15:45:16 <lambdabot> Done.
15:45:22 <bd_> or for an unsafePerformIO to evaluate another unsafePerformIO
15:45:31 * syntaxfree has major doubts about date-time handling.
15:45:38 <sorear> fasta: it is atomic in the sense that it will be executed an integer number of times
15:45:46 <sorear> syntaxfree: System.Time.getClockTime
15:45:55 <fasta> sorear: right, that's what in the spec.
15:46:12 <syntaxfree> hm. I'm looking on Data.Time all the time.
15:46:18 <syntaxfree> Maybe System.Time is more helpful.
15:46:41 <syntaxfree> oh, boy. System.Time is what I wanted all along.
15:46:41 <sorear> syntaxfree: Data.Time is just data.  you want to interact with the operating System.
15:48:08 <fasta> bd_: assuming that a single writeSTRef is a single instruction, it would work. The question is whether the antecedent is true.
15:48:26 <fasta> bd_: IO*
15:48:44 <sorear> fasta: it isn't, not even close
15:48:52 <sorear> IORefs have threading overhead
15:48:58 <sorear> IIRC
15:49:08 <syntaxfree> how evil is to violate the (return d) >>= f == f d  law?
15:49:13 <bd_> fasta: writeIORefs are atomic, but of course a combination readIORef and writeIORef isn't guarenteed atomic. There is an atomic modification operation iirc though
15:49:17 <sorear> because when you write them, it has to be visible to all processors
15:49:20 <syntaxfree> It's a huge data type, and it's only violated for one record field.
15:49:26 <fasta> syntaxfree: pretty evil
15:49:31 <sorear> syntaxfree: I've done it.  Darcs does it.
15:49:33 <fasta> syntaxfree: the compiler takes is as a theorem
15:49:37 <Cale> syntaxfree: why is it being violated?
15:49:49 <fasta> takes it*
15:49:51 <syntaxfree> because the time of a financial operation is registered the time it's executed.
15:49:54 <Cale> (and can you fix it? :)
15:49:55 <bd_> syntaxfree: >>= needs to be polymorphic; how can you only violate it for one field, while retaining polymorphism?
15:50:25 <fasta> bd_: sure any given sequence of read and writes may not be atomic.
15:50:30 <Cale> syntaxfree: uhh...
15:50:33 <Cale> syntaxfree: what?
15:50:56 <hpaste>  syntaxfree pasted "not definitive code, just testing out design ideas" at http://hpaste.org/852
15:51:01 <Cale> This is a monad over IO?
15:51:23 <Philippa> syntaxfree: don't register returns
15:51:23 <syntaxfree> OH.
15:51:25 <syntaxfree> You're right.
15:51:29 <SamB> fasta: where does the compiler do that?
15:51:38 <syntaxfree> Haha. Now there's a place for unsafePerformIO it seems.
15:51:49 <fasta> SamB: I read that somewhere
15:51:51 <Cale> syntaxfree: Also, uh, this is a kind error.
15:52:00 <syntaxfree> I haven't tried to compile it or anything.
15:52:05 <syntaxfree> I'm just thinking out "loud".
15:52:07 <Cale> data Operation a = ...
15:52:09 <bd_> syntaxfree: If you try to use unsafePerformIO there, you might find that all of your operations happened in the same instant, which also just happens to be the moment you observed the time :)
15:52:10 <fasta> SamB: I didn't read the source to have perfect proof
15:52:22 <Cale> To be a functor or a monad, there has to be a type parameter.
15:52:38 <syntaxfree> hmm. of course, of course.
15:52:39 <Cale> (specifically, the result type of the computation)
15:52:47 <syntaxfree> the type parameter should be money, of course.
15:52:54 <syntaxfree> (fmap is wrong as well)
15:53:18 <syntaxfree> maybe it really isn't monadic. I was hacking away and it seemed so.
15:53:26 <hpaste>  zeroth pasted "wont compile" at http://hpaste.org/853
15:53:29 <syntaxfree> I have to think some more.
15:53:31 <Zeroth404> anyone?
15:54:00 <syntaxfree> Zeroth404: the type of main needs to  be IO ()
15:54:10 <syntaxfree> you probably want to prepend the main definition with print $
15:54:25 <bd_> I thought main :: exists a. IO a ?
15:54:31 <Cale> Zeroth404: that code loads for me
15:54:31 <Zeroth404> why do I get this: Main.c:(.text+0x2): undefined reference to `__stginit_ZCMain'
15:54:33 <syntaxfree> upWord seems to be something like Int -> String -> String
15:54:35 <Zeroth404> Main.c ?
15:54:41 <Cale> Zeroth404: oh, you're compiling it?
15:54:44 <Zeroth404> yes
15:54:44 <abz> ?src forM
15:54:45 <lambdabot> forM = flip mapM
15:54:51 <Zeroth404> Cale: how are YOU using it?
15:54:55 <Cale> GHCi
15:55:02 <Zeroth404> Cale: how ya load it?
15:55:07 <Cale> cale@zaphod:~$ ghci shit.hs
15:55:19 * syntaxfree is back to his cash pseudomonad.
15:55:40 <fax--> > reverse $ map (\x -> x) [1..10]
15:55:42 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
15:55:50 <Zeroth404> Skipping  Shit             ( Shit.hs, Shit.o )
15:55:52 <syntaxfree> maybe I'll refactor it into a monad later. Let me get some running code.
15:55:57 <fax--> lol
15:55:58 <Zeroth404> must be from compiling
15:56:09 <syntaxfree> hahaha. GHC might have some INTERCAL-like rules.
15:56:15 <syntaxfree> If you're not polite enough, Intercal won't compile.
15:56:16 <fax--> PLEASE COME FROM 20
15:56:19 <Zeroth404> how do I execute it? it ... doesnt do anything
15:56:41 <fasta> Zeroth404: is doesn't do shit? :P
15:56:45 <syntaxfree> really. There should be a compiler rule that the word "shit" is banned.
15:56:46 <fasta> it*
15:56:50 <fax--> @hoogle reverse map
15:56:51 <lambdabot> Did you mean: Reverse Map
15:56:51 <lambdabot> Prelude.undefined :: a
15:56:51 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
15:56:51 <Zeroth404> lol
15:57:07 <syntaxfree> a good name for flip map would be "in".
15:57:15 <syntaxfree> > let in = flip map in
15:57:15 <lambdabot>  Parse error
15:57:16 <syntaxfree> hmm.
15:57:26 <fasta> @type flip map
15:57:29 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
15:57:37 <syntaxfree> > let for = flip map in for [1..10] (+1)
15:57:39 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
15:57:54 <syntaxfree> maybe that'd help imperative programmers to better face map.
15:58:01 <fax--> no but map from mthe end
15:58:20 <syntaxfree> hmm. maybe you want map . reverse?
15:58:24 <fax--> well
15:58:27 <Zeroth404> Cale: ?
15:58:33 <fax--> reverse $ map (\x -> x) [1..10]
15:58:35 <fax--> does what I want
15:58:37 <Zeroth404> Cale: module loaded...now what?
15:58:40 <fax--> but is it ok to do that?
15:58:45 <Cale> Zeroth404: oh, haha
15:58:49 * syntaxfree notices that f . map . g == map if f . g == id. I wonder if the map fusion theorem covers it.
15:58:55 <dibblego> fax--, (\x -> x) == id
15:58:55 <Cale> Zeroth404: you wrote main = upWord 1 "asd"
15:59:03 <fax--> ah nice
15:59:03 <Cale> Zeroth404: that's what it'd be complaining about
15:59:07 <fax--> > id id
15:59:08 <lambdabot>  Add a type signature
15:59:10 <Cale> main needs to be an IO action normally
15:59:11 <syntaxfree> yes, it does.
15:59:12 <syntaxfree> silly me.
15:59:15 <Zeroth404> Cale: haha
15:59:16 <fax--> > U U
15:59:17 <lambdabot>   Not in scope: data constructor `U'
15:59:17 <dibblego> fax--, map id xs = xs (forall xs)
15:59:24 <syntaxfree> Cale: that's what I was trying to say :)
15:59:35 <fax--> > let U = (\x -> x x) in U U
15:59:36 <lambdabot>   Not in scope: data constructor `U'
15:59:38 <procyon_> syntaxfree: imperative programmers have no problem with map.. they generally use forall anyway.  It's the folds that melt their brains.
15:59:40 <Cale> Sorry, I was also up from my computer a bit, and might have missed that :)
15:59:40 <fax--> >:[
16:00:04 <Cale> But yeah. In GHCi, you could just type main and it will evaluate your string.
16:00:20 <Cale> But for a real main action, you'd want  print $ upWord 1 "asd"
16:01:08 <Cale> I think this task may be simpler if you use the stuff from the Numeric module to work with integers in base 26.
16:01:40 <Zeroth404> Cale: still wont...compile
16:01:41 <augustss_> fax--: sorry, that won't type check
16:01:57 <fax--> haskell needs more U combinator
16:02:04 <Cale> Zeroth404: hmm
16:02:20 <syntaxfree> nonempty lists are nonstandard in haskell, right?
16:02:21 <Zeroth404> why in the world do I get "Main.c" in parts of the error?
16:02:26 <augustss_> > \x -> x x
16:02:27 <Zeroth404> is haskell translated into C ??
16:02:27 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
16:02:27 <lambdabot>     Probab...
16:02:31 <syntaxfree> I wonder if I should factor out nonempty list handling into some module.
16:02:35 <Cale> Zeroth404: yes
16:02:40 <Zeroth404> :-o
16:02:50 <Cale> Change the module name to Main
16:03:02 <Zeroth404> aaah
16:03:11 <Cale> (or else there's a flag for changing the main module)
16:03:16 <newsham> ?type \x -> x x
16:03:18 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
16:03:18 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:03:30 <augustss_> fax--: you need a better type system to give a type to \ x -> x x
16:03:41 <Cale> The filename can still be whatever you like.
16:03:46 <Zeroth404> user@helix /home/user/src $ ghc Main.hs
16:03:47 <Zeroth404> Main.hs:4:15: Not in scope: `cale'
16:03:53 <Zeroth404> somehow your name ended up in my program
16:03:55 <Cale> uh
16:03:57 <Cale> heh
16:04:17 <procyon_> fax--: and that "better" type system is only "better" for certain values of "better"
16:04:19 <Zeroth404> got it
16:04:41 <newsham> church rosser on a popsicle stick
16:05:42 <syntaxfree> @hoogle unsafePerformIO
16:05:43 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
16:06:55 <procyon_> fax--: the other common combinator that won't check in an HM system is L.
16:07:18 <procyon_> ?type \x y -> x (y y)
16:07:20 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
16:07:20 <lambdabot>     Probable cause: `y' is applied to too many arguments
16:07:31 <syntaxfree> > negate 2
16:07:33 <lambdabot>  -2
16:07:39 <syntaxfree> :t negate
16:07:41 <lambdabot> forall a. (Num a) => a -> a
16:08:10 <resiak> procyon_: what is the "better" type system of which you speak?
16:08:51 <procyon_> resiak: one that allows infinite types.  That opens up a whole slew of halting problems in the type system though.
16:08:52 <syntaxfree> design is hard : /
16:09:37 <procyon_> resiak: and it doesn't neccissarily add much expressivity to the language in return.
16:09:40 <SamB> procyon_: sorear has one of those
16:10:05 <dons> sjanssen: ok. multiple workspaces working!
16:10:07 <procyon_> SamB: Yeah, I've got a copy of it here.
16:10:21 <dons> though the code is getting bloated: 173 lines ;-)
16:10:23 <resiak> procyon_: yeah, i really can't see how that would work in practice :-)
16:10:24 <dons> i'll have to refactor
16:11:51 <procyon_> resiak: it does add some expressivity.  Moving from Lisp, at first I really missed the ability to do some things that weren't typeable in HM.. but those things tend to be of questionable sanity anyway.
16:13:01 * resiak should play with Lisp more
16:14:02 <fax--> is there a thing like fromIntegral for floats?
16:14:15 <abz> ?doc Control.Exception
16:14:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
16:14:18 <dons> realToFrac
16:15:13 <sorear> procyon_: I used to maintain a prototype infinite types unifier, but it turns out HM does support it
16:15:31 <sorear> procyon_: real hm, not the watered-down version in Haskell
16:16:00 <sorear> procyon_: I speak of Standard ML, the granddaddy of all typed functional languages
16:16:31 <fax--> dons: I cant get it to work
16:16:34 <sorear> HM was created (by M) for ML
16:16:36 <fax--> its still complaining abot the same thing
16:16:46 <sorear> ilner
16:16:50 <procyon_> sorear: interesting.  I'm not convinced of the value of such a thing though.
16:17:46 <Cale> There's a trick to encoding recursion with recursive types.
16:17:57 <Cale> So that you can write a proper fix, for example.
16:18:16 <Cale> But it involves use of a data constructor, and not just pure lambdas.
16:18:54 <sorear> procyon_: AIUI ML has no user defined types, so eg lists are  (() + (x,'a)) as 'a
16:19:05 <sorear> but I'm probably *very* wrong there
16:19:38 <prb> Got an STM/IO question if anyone cares to field it -- looking for the "right" (most elegant, most compact, etc.) way to sandwich an IO action between STM actions.
16:19:41 <fax--> I cant convert Float into GLFlaot :/
16:19:57 <procyon_> ?type \f -> let x = f x in x
16:19:59 <lambdabot> forall t. (t -> t) -> t
16:20:39 <syntaxfree> :t sign
16:20:41 <lambdabot> Not in scope: `sign'
16:20:43 <syntaxfree> :t sgn
16:20:45 <lambdabot> Not in scope: `sgn'
16:21:17 <syntaxfree> what's the prelude function for sgn x = if (x = abs x) then 1 else -1 ?
16:21:22 <sorear> signum
16:21:29 <syntaxfree> thanks.
16:21:48 <sorear> fax--: sure you can.  fromRational . toRational.
16:22:18 <sorear> fax--: assuming of course type GLFlaot = GLFloat
16:22:25 <fax--> hrsh
16:22:26 <fax--> heh
16:23:08 <procyon_> Cale: what's improper about? \f -> let x = f x in x
16:23:09 * syntaxfree is gonna try to compile a large chunk of untested code now. Wish me luck.
16:23:20 <sorear> procyon_: that's cheating
16:23:43 <procyon_> It works though :)
16:23:57 <Cale> procyon_: indeed, that works
16:24:07 <Cale> I mean, you can do it without let as well :)
16:24:35 <procyon_> Cale: and have Haskell typecheck it??  Show me please!
16:25:35 <fax--> sorear: It doesnt work
16:25:40 * procyon_ Such a combinator noob I still get giddy at the basics
16:25:48 <Cale> (hang on while I try to recall how it works :)
16:25:50 <sorear> procyon_: it uses fix
16:25:50 <sorear> procyon_: it's as bad as defining ++ using (++) = (Prelude.++)
16:26:16 <dcoutts> xerox, I see cairo 1.4 is out
16:26:40 <dons> ok. i'm switching over to thunk now as my main window manager!
16:26:55 <dons>                       Code  Comments
16:26:55 <dons> Main.hs                 141     73
16:26:55 <dons> W.hs                     37     56
16:26:56 <dons> TOTAL:                  178    129
16:27:17 <dons> hmm. it wasn't too hard to rewrite dwm in the end.
16:27:21 <SamB> someone remind me what the CBV signature means?
16:27:22 <siti> wow that's pretty small
16:27:42 <siti> do you have a link to the code?
16:27:51 <dolio> Wow, 178 lines of code?
16:28:00 <dolio> What does DWM claim? A couple thousand?
16:28:09 <dons> yeah, 1600 lines of C
16:28:22 <dons> it does more though. dwm supports a status bar and floating windows, and tiling
16:28:23 <SamB> dons: what other files are in there?
16:28:34 <dons> thunk only does fullscreen, multiple workspaces
16:28:41 <dolio> Ah.
16:28:50 <fax--> I dont understand why (Vertex3 0.0 0.0 0.0) works but (Vertex3 (l x) 0.0 0.0) does not
16:28:51 <Eelis> got an url for this "thunk" you speak of?
16:28:58 <dons> still, i don't think we'll need 1000 lines of code to add a status bar
16:29:01 <dons> ?where thunk
16:29:02 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/thunk/
16:29:04 <fax--> (l x) is a Float and GLfloat and Float are the same.
16:29:05 <SamB> dons: btw, thunk is a really bad name for a window manager
16:29:06 <Eelis> thank you.
16:29:15 <SamB> or tell sjanssen for me
16:29:21 <dons> SamB: names can be bad?
16:29:32 <SamB> dons: thunk is not very googleable
16:29:34 <hpaste>  zeroth pasted "whats wrong here?" at http://hpaste.org/854
16:29:35 <Zeroth404> ?
16:29:39 <SamB> @google thunk wm
16:29:42 <lambdabot> http://www.multimedia.cx/pre/cedrm2.tree.txt
16:29:48 <SamB> @google thunk window manager
16:29:50 <Zeroth404> Main.hs:9:2: parse error on input `|'
16:29:50 <lambdabot> http://www.geary.com/fixds.html
16:29:51 <lambdabot> Title: FixDS - a bit of Windows history
16:29:52 <sieni> SamB: try googling for c--
16:29:55 <Eelis> i'm currently using Ion3, but its author is halting development on it. i'd be very interested in a Haskell alternative, although tiling is an absolute requirement
16:30:03 <SamB> @google cminusminus
16:30:05 <lambdabot> http://www.cminusminus.org/
16:30:05 <lambdabot> Title: C-- Home
16:30:13 * SamB cheats happily
16:30:27 <Zeroth404> is c-- lower level than C ?
16:30:32 <SamB> Zeroth404: supposedly
16:30:42 <Zeroth404> I wonder how that works
16:31:17 <sieni> Eelis: tuomov at least used to be active on this channel, maybe he can personally give you some ideas?
16:31:18 <SamB> it definately seems to have weaker typing, but it seems to have a few rather complicated features...
16:31:27 <Eelis> sieni: ideas on what?
16:31:37 <beelsebob> Zeroth404: it's not really lower level -- it's C with fewer annoying program constructs
16:31:48 <beelsebob> which makes it good for learning compiler writing etc
16:31:59 <sieni> Eelis: on developing a haskell alternative, since tuomo already knows haskell
16:32:02 <Zeroth404> SamB: it probably just takes advanced compiler features and lets you modify them via code giving you a sense of being at a lower level, when in fact you could do it with a C compiler option...
16:32:04 <sorear> Cale, procyon_:
16:32:07 <sorear> newtype X a = X { x :: X a -> a }
16:32:07 <sorear> fix' f = (\z -> x z z) (X (\z -> f (x z z)))
16:32:07 <sorear> foo = fix' (1:)
16:32:12 <sorear> tested in Hugs
16:32:14 <fax--> type GLfloat = Float
16:32:18 <sorear> I almost never use hugs
16:32:20 <fax--> how do you convert from Float to GLfloat?
16:32:22 <syntaxfree> it would be fun to experiment with the inferred type of parts of uncompileable functions.
16:32:24 <sorear> ghci normally
16:32:24 <SamB> Zeroth404: what?
16:32:29 <sorear> fax--: you don't
16:32:31 <Cale> er, yeah, that's almost what I have here, but GHC's inliner is choking on mine :)
16:32:34 <syntaxfree> for debugging, and all.
16:32:36 <sorear> fax--: those types are the same
16:32:39 <Zeroth404> SamB: things the compiler can do, but you cant do in code (with C)
16:32:43 <fax--> but I get errors
16:32:45 <edwinb> it has lightweight calling conventions and proper tail calls
16:32:53 <beelsebob> anyone here got any experience with the ACM latex styles?
16:32:53 <Cale> (which is a known bug, just trying to work out how to get rid of inlining completely here)
16:32:58 <Zeroth404> was just a speculation
16:33:04 <Eelis> sieni: ah, i see. well, from his recent posts on the mailing lists i doubt he'd be interested. also, i'm not sure he's the kind of guy i would like to cooperate with ;)
16:33:06 <edwinb> beelsebob: I've used them...
16:33:07 <SamB> Zeroth404: Well, that sounds lower level to me.
16:33:09 <beelsebob> or happen to know why the program is being split across two columns here... http://www.cs.kent.ac.uk/people/rpg/tatd2/oddness.png
16:33:21 <syntaxfree> :r
16:33:22 <syntaxfree> oops.
16:33:26 <beelsebob> lol
16:33:32 <beelsebob> syntaxfree meant to be in ghci then
16:33:32 <SamB> but then there are the stack-related things...
16:33:35 <Cale> fix f = (\(Rec x) -> f (x (Rec x)))
16:33:35 <Cale>             (Rec (\(Rec x) -> f (x (Rec x))))
16:33:39 <sieni> Eelis: is any finn? ;-)
16:33:41 <SamB> which seem terribly complicated
16:33:42 <Cale> is what I have, but GHC doesn't like it
16:33:47 <Cale> data Rec a = Rec { unRec :: Rec a -> a }
16:34:10 <Eelis> sieni: i'm half-finn myself ;)
16:34:14 <Cale> it works in hugs anyway
16:34:20 <dibblego> is it Control-D on Windows to escape from ghci?
16:34:24 <sorear> stefan@stefans:/tmp$ ghci -v0 -funfolding-creation-threshold=-1 X.hs
16:34:24 <sorear> *Main>
16:34:30 <sorear> Cale: ^^^
16:34:32 <edwinb> beelsebob: what's the problem there?
16:34:33 <beelsebob> edwinb: any ideas there?
16:34:45 <beelsebob> if you look at the program in the end of the first column
16:34:47 <edwinb> I'm not sure what it's supposed to look like...
16:34:49 <edwinb> right...
16:34:50 <procyon_> Cale: interesting.
16:34:58 <sieni> Eelis: ok, I actually checked your connection address, since "eeli" sounds a finnish version of a jewish name ;-)
16:35:00 <beelsebob> note that the end of it is short enough that it could easily fit in the first column
16:35:04 <edwinb> ah
16:35:07 <fax--> oh ffs I was doing (l x) instead of (x l)..
16:35:08 <beelsebob> why is it not living there?
16:35:09 <fax--> sorry about that
16:35:10 <edwinb> that gap is where the copyright information goes
16:35:20 <Zeroth404> anyone, Main.hs:9:2: parse error on input `|'      http://hpaste.org/854
16:35:21 <beelsebob> ahhhhhhh!
16:35:22 <beelsebob> I see
16:35:27 <beelsebob> now it makes sense
16:35:37 <edwinb> so if you're in draft mode, it's just blank
16:35:37 <beelsebob> hmm, this style was meant to be the one that didn't include any
16:35:39 <mbishop> someone with a bigger scrollback wanna tell me who mentionedm y name?
16:35:47 <Eelis> sieni: really? what jewish name is that? (and i'm stationed in the other half of my nationaly, yes)
16:35:49 * sorear hasINFINITE scrollback
16:35:49 <edwinb> yeah, but it wants to make the layout right for if it gets accepted ;)
16:35:53 <hpaste>  syntaxfree pasted "driving me crazy" at http://hpaste.org/855
16:35:57 <Eelis> *nationality
16:35:58 <sorear> <lambdabot> mbishop says: darn, someone removed my one quote from lambdabot now
16:35:58 <sorear>             I'll never be famous :(
16:35:58 <sorear>  
16:36:05 <mbishop> oh, heh
16:36:08 <beelsebob> edwinb: like that's gonna happen :P
16:36:11 <dolio> Zeroth404: You're missing some closing parens.
16:36:11 * sorear has searchable scrollback
16:36:17 * mbishop doesn
16:36:18 <mbishop> er
16:36:18 <edwinb> beelsebob: is this for ICFP?
16:36:21 <sieni> Eelis: and finns are not non-cooperative by default, I'd rather describe us "cooperatively challenging"
16:36:23 <beelsebob> nope, PPDP
16:36:27 * mbishop doesn't care enough to have searchable scrollback
16:36:29 <Zeroth404> dolio: oh
16:36:37 <edwinb> oh good, I was worried if you were being so keen as to have already started ;)
16:36:42 <Zeroth404> mbishop: apparantly you need it ;-)
16:36:48 <mbishop> heh
16:36:49 <dolio> Zeroth404: On lines 12 and 17, I believe.
16:37:01 <beelsebob> edwinb: roflcakes
16:37:09 <mbishop> Eelis: have you seen dwm? it's sort of similar to ion3, and sjanssen was working on a haskell version of it
16:37:21 <Eelis> sieni: it would be pretty bad if tuomov was representative of finnish cooperation though ;) there's currently a thread on the ion mailing list where users are starting to revolt against him
16:37:42 <Eelis> mbishop: i just learned of its existence. perhaps i'll attempt hacking tiling into it
16:38:01 <procyon_> syntax free: I think you're missing  "3 -> profit"
16:38:03 <Eelis> (in sjanssen's version that is)
16:38:04 <mbishop> heh, tuomov was never known to be a reasonable guy, from what I can tell :P
16:38:08 * procyon_ ducks
16:38:14 <dons> Eelis: re window managers, we'll be adding tiling and a statusbar
16:38:30 <sieni> Eelis: well, he sounded kind of depressive the last time I heard of him :-/
16:38:37 <dons> tuomov's great, he helped write a lot of yi in the early days
16:38:37 <hpaste>  syntaxfree annotated "driving me crazy" with "I try to learn from type inference, to no avail" at http://hpaste.org/855#a1
16:38:38 <procyon_> cale++
16:38:40 <dmwit> Zeroth404: Also, mail -> main, probably.
16:38:53 <Zeroth404> dmwit: that too
16:38:58 <sorear> cale--
16:39:04 <siti> any ideas: Setup.lhs: cannot satisfy dependency X11-extras==0.0
16:39:04 <syntaxfree> I remember tuomov from #gentoo.
16:39:11 <sorear> Cale++
16:39:14 <mbishop> Yeah tuomov always seemed cool, but not always resonable :P
16:39:20 <Eelis> dons: great! how can i keep up-to-date on your development? will there be a thunk homepage and/or mailing list?
16:39:25 <syntaxfree> We used to tease him asking him to write ion3 for OS X, and he'd flip out ranting about capitalism and communism.
16:39:27 <orbitz> sorear: i hope that isnt' icnrement!
16:39:31 <sieni> Eelis: but I'd say that of the capable guys, linus torvals is one of the more polite ones ;-)
16:39:49 <sieni> Eelis: just kidding
16:39:55 <Eelis> hehe
16:39:55 <sieni> linus can be a pita
16:40:10 <sjanssen> @where+ X11-extras darcs get http://darcs.haskell.org/~sjanssen/X11-extras
16:40:10 <lambdabot> Done.
16:40:15 <dmwit> ?karma Cale
16:40:15 <lambdabot> Cale has a karma of 44
16:40:16 <sjanssen> siti: ^^^
16:40:25 <sorear> duno fins, but we've got *plenty* of swedes here
16:40:25 <siti> thanks
16:40:30 <fax--> http://img291.imageshack.us/img291/6189/picture2tq6.png
16:40:32 <fax--> :D
16:41:01 <sieni> Eelis: like the classic: http://www.mail-archive.com/desktop_architects@lists.osdl.org/msg00592.html
16:41:03 <lambdabot> Title: Re: [Desktop_architects] Printing dialog and GNOME, http://tinyurl.com/26t6tg
16:41:16 <hpaste>  sjanssen pasted "snippet from my xinitrc" at http://hpaste.org/856
16:41:28 <beelsebob> edwinb: omg, I finally found an example that actually demonstrates all the different things I need to show
16:41:31 <beelsebob> it's a miricle
16:41:33 <hpaste>  syntaxfree annotated "driving me crazy" with "fixed. I keep wishing I could delete my hpastes to save me the long-term embarassment :)" at http://hpaste.org/855#a2
16:41:35 <sjanssen> dons: you might want to take a look at that, it's been pretty nice for thunk hacking so far
16:42:05 <sieni> finns are considered so closed in personality mainly because otherwise they would rant like hell, and linus just forgot this discretion
16:42:08 <mbishop> http://darcs.haskell.org/~sjanssen/thunk/Main.hs
16:42:09 <mbishop> :o
16:42:22 * SamB wishes he had associated types available
16:42:37 <newsham> ?seen sorear
16:42:37 <lambdabot> sorear is in #darcs, #haskell-overflow, #ghc, #haskell and #happs. I last heard sorear speak 2m 11s ago.
16:42:43 <sjanssen> SamB: soon . . .
16:42:56 <Eelis> sieni: i'll take your word for it :)
16:43:08 <newsham> sorear: how do I abuse image upload for data?
16:43:53 <edwinb> beelsebob: ooh?
16:44:06 <syntaxfree> newsham: steganography apps, maybe, but that'd be inefficient.
16:44:21 <SamB> sjanssen: here I thought someone was going to say "what are you waiting for?" ;-)
16:44:54 <sieni> Eelis: and no, the linus torvalds did not mean his post to be an insult, but a rather colourful criticism, which you might expect from a frustrated finn, but not typically on some other language than finnish
16:45:08 <dons> sjanssen: what am I looking at?
16:45:20 <dons> sjanssen: workspaces work now, Alt-1..5
16:45:24 <beelsebob> edwinb: I've spent about 3 weeks trying to come up with examples that are sufficiently complex that they convince people there's a problem, while also actually fitting on the page
16:45:32 <dons> i'll do moving windows to other workspaces now
16:45:33 <sjanssen> SamB: nah, we've got Manuel Chakravarty to implement ATs for us
16:45:56 <newsham> syntax:  re: putting data files on the wiki
16:45:59 <SamB> sjanssen: I meant, "why don't you install GHC 6.9?" or something like that ;-P
16:46:27 <edwinb> beelsebob: yes, that sounds like a challenge...
16:46:37 <dons> "sjanssen> dons: you might want to take a look at that, it's been pretty nice for thunk hacking" sjanssen, what were you referring to?
16:46:41 <SamB> (yes I know 6.9 is a nonexistant development series)
16:46:45 <sjanssen> dons: http://hpaste.org/856 it's a little script that lets you switch to dwm or restart thunk when thunk crashes
16:46:52 <dons> ah nice
16:46:58 <dons> yes, that's what I need
16:47:04 <sorear> hi?
16:47:07 <nominolo> sjanssen, SamB: they mostly work already
16:47:10 * dons revels in workspaces, and forgets he's not in dwm
16:47:14 <SamB> sjanssen: what are your plans for being googleable?
16:47:26 <sjanssen> SamB: I dunno
16:47:29 <SamB> nominolo: how about them AT synonyms?
16:47:38 <SamB> not that I need particularly need them.
16:47:45 <sorear> newsham: image upload doesn't check data format
16:47:53 <SamB> (The MTL does, though)
16:48:10 <sorear> newsham: so if you tell the system your data file is an image, it will be hosted and served without alteration
16:48:12 <nominolo> SamB: well, I had problems with record update syntax, but it did work for my humble needs
16:48:22 <newsham> how do i upload an image?
16:48:22 <SamB> record update?
16:48:24 <SamB> heh
16:48:37 <sjanssen> nominolo: were you using associated data types, or associated type synonyms?
16:48:52 <nominolo> oh, sorry, data types
16:48:58 <nominolo> not synonyms
16:49:00 <SamB> I suppose I could try that.
16:49:08 <SamB> I have a darcs build with those
16:49:59 <sjanssen> dons: have you noticed any focus issues?  I know you've had trouble with firefox's address bar
16:50:26 * SamB is writing an RML interpreter, and doesn't want to have to hardcode the world model in the interpreter proper
16:51:01 <nominolo> SamB: my recently learned lesson is: start simple
16:51:12 <fax--> nominolo: I think thats a bad lesson
16:51:23 <SamB> nominolo: I want to start *cleaner*
16:51:23 <nominolo> fax--: why?
16:51:25 <dons> sjanssen: yeah, firefoxes addr bar still won't focus
16:51:35 <sieni> Eelis: or the better one: http://lists.osdl.org/pipermail/desktop_architects/2005-December/000395.html
16:51:37 <lambdabot> Title: [Desktop_architects] Printing dialog and GNOME, http://tinyurl.com/9d6op
16:51:38 <fax--> I used to start simple and it just got me a very complete understanding of things
16:51:42 <SamB> and anyway ATs are way simpler than hardcoding world models in the middle of a programming language interpreter
16:51:52 <fax--> but it doesnt mean I can get anything more actually done
16:51:55 <sjanssen> dons: won't focus when you use the mouse?
16:52:02 <Cale> sorear: interesting, NOINLINE pragmas weren't giving me any help
16:52:05 <sorear> newsham: http://haskell.org/haskellwiki/Special:Upload
16:52:06 <lambdabot> Title: Error
16:52:07 <nominolo> fax--: ok, i meant, less generic
16:52:18 <newsham> danke
16:52:25 <fax--> nominolo: hmm?
16:52:30 <dons> sjanssen: well, i can select, but I can't give keyboard input
16:52:57 <Cale> fix f = let {-# NOINLINE g #-}
16:52:57 <Cale>             g = (\(Rec x) -> f (x (Rec x)))
16:52:57 <Cale>             v = (Rec (\(Rec x) -> f (x (Rec x))))
16:52:57 <Cale>         in g v
16:52:59 <Cale> aha
16:53:02 <Cale> that works
16:53:36 <sjanssen> dons: ouch, that'd be annoying :/
16:53:49 <dons> well, i can't use firefox atm :-)
16:53:57 <nominolo> fax--: well, I started with the need for HList-style records
16:54:09 <fax--> I dont know what that is :S
16:54:23 <nominolo> fax--: I still do, but I could find a reasonably useful approximation
16:54:39 <fax--> you still do?
16:54:39 <nominolo> fax--: extendable records
16:54:51 <nominolo> well, ideally
16:54:59 <nominolo> but i can live with the tradeoff
16:55:00 <sorear> LambdaBotZ: @version
16:55:11 <nominolo> isn't that what programming is all about? ;)
16:55:15 * SamB prefers to have *one* type variable that he passes all around his interpreter
16:55:27 <fax--> nominolo: I dunno :(
16:55:32 <fax--> is it?
16:55:50 * SamB looks for ghc6.7
16:55:53 <nominolo> fax--: at least when your system grows
16:55:56 <SamB> what?
16:56:02 <nominolo> SamB: yes, that was exactly my problem
16:56:18 <SamB> locate can't find either ghc6.7 or ghc6.5 :-(
16:56:34 <nominolo> fax--: or your language is still in heavy development/research ..
16:56:43 <sjanssen> SamB: ghc-6.7
16:56:51 <nominolo> @where ghc
16:56:51 <lambdabot> http://haskell.org/ghc
16:56:53 <SamB> oh
16:57:18 <SamB> apparantly mine still goes by "ghc-6.5"
16:57:24 <SamB> even though it is really 6.7
16:57:30 <nominolo> huh?
16:57:45 <SamB> they didn't update all the infrastructure immediate
16:57:48 <SamB> er.
16:57:51 <SamB> immediately
16:58:02 <nominolo> how can that be? some hardcoded paths in the mk/* files?
16:58:37 <SamB> I mean, they didn't tell the development branch "you are now 6.7" quite as soon as they should have ;-)
16:59:13 * SamB hopes this GHC isn't smart enough to have psychological problems as a result
16:59:50 <sjanssen> SamB: that must be a pretty old build
16:59:55 <SamB> yeah
17:00:12 <SamB> but it has the associated ADTs
17:00:26 <SamB> if I have trouble, I'll update
17:02:42 <nominolo> SamB: if you need type synonyms: http://hackage.haskell.org/trac/ghc/ticket/961
17:02:44 <lambdabot> Title: #961 (implement associated type synonyms) - GHC - Trac
17:02:59 <nominolo> "It should be pretty easy to fix if you actually have a clue what you are doing ;-). So, please fix it."
17:03:06 <SamB> nominolo: Is someone doing the MTL port?
17:03:14 <SamB> oh. wait.
17:03:17 <SamB> I made that ticket.
17:03:34 <Cale> whoa, reddit looks ghetto right now, the CSS isn't loading
17:03:42 <SamB> anyway, I don't know what I'm doing, so.
17:05:18 <nominolo> I intend to get into some ghc-backend hacking, but it looks very much like that won't happen anytime soon :/
17:06:14 <SamB> nominolo: that isn't anywhere near the backend as far as I can see
17:07:47 <nominolo> SamB: that comment wasn't really related ;) .. but i guess the confidence to fix some annoyancies would rise, if i'd do so ..
17:08:11 <SamB> I mean, AT synonyms are done with as soon as the code is in System F_C
17:08:30 <nominolo> isn't it already?
17:08:33 <dons> sjanssen: ok. 'tagging', i.e. move to workspace 'n' works :-)
17:08:39 <dons> now, about that status bar.
17:09:01 <dons> ( I only need the status bar and focus to work in firefox, and i'm done :-)
17:09:05 <SamB> nominolo: well, the AT-synonym-using code won't be in System F_C until chak implements AT synonyms ;-P
17:09:32 <nominolo> yes, but mapping this to system F_C should be simple
17:09:33 <syntaxfree> proper modularity sounds stupid until you do it for a while and start seeing the benefits.
17:09:40 <nominolo> if you know where to look
17:10:18 <dons> sjanssen: i think we can really refactor a lot of the window code now to separate the internal data structures from the view of them
17:10:30 <dons> which should shrink the code
17:11:05 <SamB> try to keep it above 100 lines ;-)
17:11:33 <dons> I want to get it down to say, 100. that'd be really nice. 160 would ok, 1/10th of dwm
17:11:42 * nominolo wonders if coercion type operators other than sym are actually being used in F_C
17:11:54 <dons> there's really *no* reason to write a window manager in C -- its all glue code for X anyway
17:12:01 <SamB> nominolo: operators?
17:12:11 <nominolo> dons: tell that the dwm-guys
17:12:29 <nominolo> SamB: combinators
17:12:36 <sorear> SamB: trans, refl, left, right, comp
17:12:41 <nominolo> type-level operators
17:12:43 <sorear> nominolo: yes they are
17:12:46 <nominolo> exactly
17:12:49 <dons> i know, its weird. they're into writing minimal code, but they use a ridiculously low level language
17:12:56 <SamB> I'm pretty sure some others are used somewhere
17:12:59 <dons> when all they're doing is calling X functions and manipluating lists
17:13:15 <nominolo> sorear: from the paper they seemed like they would only be of theoretical interest
17:13:28 <SamB> dons: perhaps they never noticed that they aren't using structs?
17:13:43 <SamB> other than the lists?
17:13:50 <nominolo> dons: i think they consider any kind of runtime as "bloat"
17:13:59 <SamB> er. I mean, that the X API doesn't have structs in it.
17:14:13 <sjanssen> SamB: xlib has plenty of structs
17:14:18 <SamB> sjanssen: oh?
17:14:18 <dons> nominolo: once they've written 1000 lines of redundant code though ...
17:14:25 <SamB> so how come you don't have a C file or anything?
17:14:39 <nominolo> dons: heh
17:14:51 <sjanssen> SamB: you can do the marshaling with hsc2hs
17:15:39 <dons> sjanssen: so are you working on anything in thunk at the moment?
17:16:13 <fax--> whats thunk?
17:16:24 <SamB> sjanssen: dons didn't give stats for any .hsc file earliker
17:16:35 <nominolo> fax--: the soon-to-be kick-ass window-manager
17:16:38 <dons> SamB: that's in the X library binding
17:16:39 <fax--> oh nice
17:16:54 <nominolo> fax--: well, if you like dwm ;)
17:16:55 <dons> SamB: its not part of the wm.
17:17:11 <sjanssen> dons: I'm writing some debug code in X11-extras
17:17:13 <nominolo> fax--: or ion
17:17:13 <hpaste>  sorear pasted "some more uses '~', 'sym', (implicit) refl" at http://hpaste.org/857
17:17:20 <SamB> hmm. can I say that I need an AT to be a Monad?
17:17:21 <fax--> ?karma fax--
17:17:21 <lambdabot> You have a karma of 0
17:17:24 <fax--> damn :(
17:17:28 <dons> ok. cool. i'll try to work out what event we're not handling for my firefox keyboard
17:17:29 <sorear> @karma fax
17:17:29 <lambdabot> fax has a karma of 0
17:17:36 <sorear> hello JohnMeacham_
17:17:42 * fax-- expected -546
17:17:45 <SamB> or should I just associate the types to my monad?
17:17:52 <sorear> @karma george
17:17:53 <lambdabot> george has a karma of 0
17:17:57 <sjanssen> dons: the debug code I'm writing should help
17:18:17 <nominolo> ?karma me
17:18:18 <dons> well i'm just going to trace any unhandled event to the log file
17:18:18 <lambdabot> me has a karma of 0
17:18:40 <dons> also, any thoughts on grabbing windows at start up? i'd like to get xconsole under management
17:18:47 <Zeroth404> How do I catch arguments passed to my main function?
17:19:01 <sjanssen> dons: grabbing windows at start up should work now
17:19:09 <nominolo> ?hoogle args
17:19:10 <lambdabot> Distribution.Simple.Args :: type Args
17:19:10 <lambdabot> System.getArgs :: IO [String]
17:19:10 <lambdabot> Data.Typeable.typeRepArgs :: TypeRep -> [TypeRep]
17:19:16 <sorear> ok, testing ERC - someone ping me
17:19:18 <nominolo> Zeroth404: the second one
17:19:38 <Zeroth404> System.getArgs[0] ?
17:19:41 <Zeroth404> heh
17:20:01 <nominolo> if that's what you meant
17:20:02 <Zeroth404> ooh
17:20:04 * SamB decides to associate everything to his monad
17:20:41 * SamB was going to use a phantom type for that instead
17:21:21 <dons> sjanssen: does the workspace and tagging code work for you?
17:21:38 <dons> sjanssen: No remote changes to pull in!
17:21:42 <dons> did you push some patches?
17:22:53 <sjanssen> dons: seems to work
17:23:09 <sjanssen> dons: yes, I did forget
17:23:26 <sjanssen> you'll need the latest version of X11-extras too
17:23:50 * SamB thinks he is going to need to write classes for pushing values accross the RML boundary
17:23:51 <Zeroth404> :t System.getArgs
17:23:53 <lambdabot> IO [String]
17:24:03 <TomMD> The most effective arguments I have heard against Haskell is the "I can't expect the next guy I get in my division to know that language, and no one else here knows it." argument.  Aside from saying "Learning is good" and "Chicken before the egg, you've got to require it before people will come with it", I've got to admit they've got a point.  Anyone else work in an office and run into this?  How do you handle it?
17:24:31 <Zeroth404> main = print $ upWord System.getArgs!!1 System.getArgs!!2
17:24:36 <Zeroth404> ?
17:24:46 <Zeroth404> well, 0 then 1
17:24:53 <TomMD> I've told them that, it isn't convincing enough... perhaps because they don't understand it.
17:24:56 <SamB> (there are an awful lot of ADTs that the RML program and ./adventure pass back and forth)
17:25:03 <dons> TomMD: hmm. its a general issue with new technology. luckily its widely taught, and easy to pick up (lots of free docs).
17:25:23 <dons> there's an undersupply of haskell jobs though: we've got 100s and 100s of guys who'd love to write haskell, but not enough jobs
17:25:39 <TomMD> Dons: names, I need names.
17:25:46 <TomMD> :-)
17:25:49 <monochrom> The landscape is changing.  It seems that now everyone is either writing "I'm learning haskell" on his blog or reading someone's "I'm learning haskell" blog.
17:26:02 <nominolo> Zeroth404: do args <- getArgs; putStrLn (args !! 1)
17:26:24 <sjanssen> TomMD: you can have my name, in a year or so :)
17:26:35 <monochrom> In fact the next guy to join your division may have very well used paid, office hours to browse such blogs in his previous job, secretly.
17:26:36 <TomMD> Graduating soon?
17:27:03 <nominolo> > do args <- getArgs; return (show $ args !! 1)
17:27:04 <lambdabot>   Not in scope: `getArgs'
17:27:12 <dons> sjanssen: are you using thunk now by default? (and do you need tiling?)
17:27:14 <nominolo> > do args <- System.getArgs; return (show $ args !! 1)
17:27:15 <lambdabot>   Not in scope: `System.getArgs'
17:27:16 <sjanssen> TomMD: in a year or so
17:27:31 <TomMD> sjanssen: what part of the world are you look for or at?
17:27:36 <sorear> <- not graduated yet :(
17:27:49 <dolio> nominolo: lambdabot isn't going to let you run IO code.
17:27:53 <sjanssen> TomMD: USA, probably
17:28:00 <sorear> > System.getArgs
17:28:01 <lambdabot>   Not in scope: `System.getArgs'
17:28:08 <nominolo> dolio: i guessed so .. makes sense
17:28:13 <dolio> :)
17:28:13 <dons> TomMD: if you're serious about testing the market, ping haskell-cafe@ with an opening. you can also put a job vacancy in the haskell weekly news
17:28:20 <sorear> > return () :: IO ()  -- what's the message today?
17:28:21 <sjanssen> sorear: TomMD should ask you in what, 6 or seven years?
17:28:21 <lambdabot>  <IO ()>
17:28:23 <dons> several thousand haskellers will see that then.
17:28:50 <sorear> sjanssen: yeah.  you'll be ready much sooner and more likely :)
17:29:07 <TomMD> dons: I am serious, but now is sadly not good.  I will probably do something similar in a year.
17:29:17 <dons> right. where are you, btw?
17:29:26 <dons> I wonder if I know some locals in your city..
17:29:32 <Zeroth404> :t show
17:29:34 <lambdabot> forall a. (Show a) => a -> String
17:29:58 <TomMD> Know anyone near Baltimore?
17:30:07 <dons> TomMD: also, you could talk to people like Galois and augustss_ at Credit Suisse, about how they go about hiring haskellers
17:30:32 <dons> hmm. I don't know anyone there. but there may well be a few.
17:30:36 <TomMD> I know Galois tactic - its an ambush.
17:30:43 <dons> we should really have a consultancy list available
17:30:52 <TomMD> I found one once.
17:30:53 <Zeroth404> why does GHCI think I'm giving upWord 3 args?   print (upWord show(args!!0) (args!!1))
17:30:56 <sjanssen> dons: I think I can use thunk as my default once tiling works
17:30:58 <TomMD> It seemed... sparse and old.
17:31:05 <Zeroth404> err, nvm
17:31:22 <dons> sjanssen: ah ok on my laptop screen i never use tiling :-) and i use floating spaces only to run gimp.
17:31:27 <dons> the status bar I miss though.
17:31:29 <TomMD> Zeroth404: show and (args!!0) are two separate args, use parans
17:32:02 <nominolo> Zeroth404: maybe you'd prefer a real tutorial/teaching book?
17:32:18 <Zeroth404> nominolo: YAHT isn't real? :-p
17:32:34 <nominolo> oh, no, i guess that's fine
17:32:37 <sjanssen> dons: I'll write tiling, then
17:32:48 <dons> sjanssen: yeah, grabbing xconsole on startup works now
17:32:51 <sjanssen> dons: you wrote that you have ideas about how to represent windows?
17:32:51 <TomMD> sjanssen: unl?
17:32:58 <Zeroth404> I looked at   show(this)  and my brain interpreted it as  (show this)
17:33:00 <nominolo> ?where yaht
17:33:01 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
17:33:21 <dons> sjanssen: represent them abstractly, you mean?
17:33:23 <sjanssen> TomMD: correct. (University of Nebraska at Lincoln)
17:33:45 <dons> I think the main code reduction will be splitting the calls into X from the internal management of data structures
17:33:53 <dons> so i'll ponder some more about how to do that best.
17:33:57 <sjanssen> dons: I just vaguely remember something in the changelog.  Is it related to tile vs fullscreen vs floating?
17:34:14 <dons> if we can get that right, we should have pure internal ops, which we can QuickCheck (just list ops basically)
17:34:27 <dons> oh hmm. i'm not sure I wrote anything on that.
17:34:55 <sjanssen> allright
17:35:57 <dons> i'd like to use STM for the state lock, just for the marketing purposes.
17:36:12 <sjanssen> dons: it's the best way to do it
17:36:17 <monochrom> haha
17:36:26 <sjanssen> did you see my notes in the TODO?
17:36:26 <dons> well, an MVar and takeMVar would work too (i.e. like in yi or hmp3)
17:36:33 <dons> i've not read them. i will do so.
17:36:49 * sorear is writing yet another haskell debugger
17:36:50 <sjanssen> STM is needed to simultaneously poll the three statusbar variables
17:37:08 <dons> ah, you want fine grained locks?
17:37:08 <Zeroth404> :t splitAt
17:37:11 <lambdabot> forall a. Int -> [a] -> ([a], [a])
17:37:32 <nominolo> sorear: details!
17:38:16 <dons> btw, i'm not sold on the name 'thunk'. as SamB pointed out, its also a bit hard to google. i've not thought terribly hard about a better alternative though.
17:38:30 <sjanssen> I'm open to a name change
17:38:31 <sorear> suspension? :p
17:38:35 <nominolo> Zeroth404: that split didn't work too well
17:38:36 <SamB> thunkwm might work
17:38:37 <nominolo> ;)
17:39:03 <sjanssen> SamB: just have to be careful not to abbreviate (twm)
17:39:15 <TomMD> I think we would have to sell any new name to Simon M. or Simon PJ for it to get wide spread... Anyone in England?
17:39:21 <nominolo> LT10K
17:39:31 <nominolo> less than 10 k (of code)
17:39:37 <dons> hmm. so what qualities does it posses: pure functional, monadic, tiny
17:39:49 <dons> LT0.1K ?
17:39:53 <Cale> Is anyone else unable to connect to static.reddit.com?
17:39:53 <dons> hehe
17:40:08 <dons> tinywm?
17:40:22 <sjanssen> dons: I think that name is taken
17:40:24 <nominolo> thinywm
17:40:29 <nominolo> thinkyWM
17:40:43 <nominolo> tinkywm
17:40:51 <monochrom> Cale: I get an XML reply that says "Access Denied"
17:40:54 <nominolo> endless possiblities!!11
17:41:00 <dcoutts> dons, so I found one interesting issue when quickchecking my data.list vs the H98 report, the sortBy test fails because it does different things compared to the spec with comparison operators that are not total orders.
17:41:14 <dcoutts> dons, begs the question of how to generate random total orders...
17:41:35 <dcoutts> probably just pick from a fixed list [(==), (>=), etc]
17:41:41 <Zeroth404> > repeat 5 "s"
17:41:42 <lambdabot>  Couldn't match expected type `[Char] -> t'
17:41:47 <Zeroth404> :t repeat
17:41:50 <lambdabot> forall a. a -> [a]
17:41:54 <nominolo> > repeat 5 's'
17:41:55 <lambdabot>  Couldn't match expected type `Char -> t'
17:42:14 <nominolo> > replicate 5 's'
17:42:15 <Zeroth404> > repeat 's'
17:42:16 <lambdabot>  "sssss"
17:42:16 <lambdabot>  "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss...
17:42:20 <Zeroth404> well
17:42:43 <nominolo> replicate n = take n . repeat
17:42:49 <fax--> > repeat ":)"
17:42:51 <lambdabot>  [":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",...
17:43:11 <fax--> hm lazy is cool
17:43:13 <dons> lambdawm ?
17:43:16 <dons> dcoutts: oh hmm
17:43:25 <nominolo> ?src replicate
17:43:25 <lambdabot> replicate n x = take n (repeat x)
17:43:52 <dcoutts> dons, anyway, I'll leave that thought with you and go fall into bed, g'night.
17:43:54 <sjanssen> > map (:"wm") ['a'..'z'] -- I think every one of these names is taken
17:43:56 <lambdabot>  ["awm","bwm","cwm","dwm","ewm","fwm","gwm","hwm","iwm","jwm","kwm","lwm","mw...
17:43:59 <dons> ok. night dcoutts !
17:44:12 <dons> I kind of like 'lwm'
17:44:17 <dons> dwm but with lambdas
17:44:26 <nominolo> dwim
17:44:29 <fax--> > LiftM3 ['1'..'9'] ['1'..'9'] ['1'..'9']
17:44:30 <lambdabot>   Not in scope: data constructor `LiftM3'
17:44:32 <fax--> :[
17:44:36 <nominolo> ?jargon dwim
17:44:37 <lambdabot> *** "DWIM" jargon "Jargon File (4.3.1, 29 Jun 2001)"
17:44:38 <lambdabot> DWIM /dwim/ [acronym, `Do What I Mean'] 1. adj. Able to guess,
17:44:38 <lambdabot>    sometimes even correctly, the result intended when bogus input was
17:44:38 <lambdabot>    provided. 2. n. obs. The BBNLISP/INTERLISP function that attempted to
17:44:38 <lambdabot>    accomplish this feat by correcting many of the more common errors. See
17:44:39 <lambdabot> [34 @more lines]
17:44:40 <sjanssen> nominolo: not google-able
17:44:49 <nominolo> dwimWM
17:45:14 <nominolo> i guess an interlisp-like dwim feature would be cool for haskell
17:45:28 <fax--> nominolo:what kind of feature?
17:46:29 <nominolo> if there are compiler errors it automatically fixes simple errors
17:46:47 <nominolo> typos, wrong arg count .. etc
17:46:56 <fax--> ah
17:47:00 <nominolo> not sure how well this would work with haskell though
17:47:13 <nominolo> current lisps don't even have it
17:47:51 <fax--> to be honest, I dont really like the sound of it
17:48:06 <fax--> but it might be one of these things that are fantastic and hard to live without
17:48:32 <nominolo> http://catless.ncl.ac.uk/Risks/7.13.html <-- search for "DWIM"
17:48:34 <lambdabot> Title: The Risks Digest Volume 7: Issue 13
17:48:43 <dons> "I'm continuing to experiment with HDirect and the ihc
17:48:43 <dons>    compiler."
17:48:46 <dons> ihc??
17:51:10 <nominolo> > let "y" `soundsLike` "i" in True
17:51:10 <lambdabot>  Parse error
17:51:28 <nominolo> ups, you get the idea ..
17:52:20 <fax--> > LiftM2 (++) ['a'..'d'] ['a'..'d']
17:52:21 <lambdabot>   Not in scope: data constructor `LiftM2'
17:52:24 <fax--> >:D
17:52:34 * SamB wonders how to give a kind signature for an AT
17:52:55 <nominolo> data X a :: * -> * ?
17:53:05 <SamB> I must need a better GHC
17:53:17 <nominolo> ah, it might not work in current ghc either
17:53:27 <nominolo> i think there was some bug
17:53:38 <SamB> nominolo: well, mine won't let me do it *or* not do it
17:53:39 <SamB> so.
17:53:44 <SamB> I think I cannot use ATs
17:54:20 <nominolo> no, works in HEAD
17:54:43 <nominolo> ok, then
17:54:49 * nominolo sleeps
17:55:42 <sjanssen> SamB: I think the AT implementation was quite preliminary around the release of 6.6
17:55:52 <sjanssen> I'm sure that 6.5/6.7 bug wasn't around for too long
17:56:22 * SamB is looking for any local patches in his tree that he can get rid of
18:01:39 <eddyp> hi guys, I am a programmer that knows C, shell, some perl, and some python; I tried starting to learn haskell, but I got stuck at different points due to time, lack of a sensible developemnt environment, lack of explanation about differences between interpretor commands and programms and different issues; could you guide me to a tutorial that is "hands-on" and is appropriate for my backgroung? (I have studied prolog, and kind of understood the prin
18:01:39 <eddyp> ciples, but never got to put it to work)
18:01:43 <fantasma> can I set a variable equal to a `take` of a list?
18:02:19 <fantasma> for example: century = take (99*365) (cycle [1..7])
18:02:27 <sjanssen> fantasma: sure
18:02:35 <SamB> fantasma: what do *you* think?
18:02:37 <fax--> eddyp: prolog :D
18:02:41 <SamB> how do you suppose you would be able to tell?
18:02:50 <fantasma> yes, but ghci is giving me a parse error
18:02:55 <SamB> ah.
18:02:57 <SamB> what?
18:03:14 <sjanssen> fantasma: use 'let x = ...' in ghci
18:03:16 * SamB points out that you can't write Haskell modules in GHCi
18:03:31 <SamB> you have to use a text editor or at least cat(1)
18:03:40 <fantasma> sjanssen, no I am loading a module in ghci
18:04:02 <eddyp> fax--: what?
18:04:08 <sjanssen> fantasma: you must have some other issue then
18:04:15 <fax--> eddyp: I love prolog
18:04:16 <sjanssen> the code you pasted looks correct
18:04:55 <fantasma> yah I know =\
18:05:11 <dons> eddyp: the place to start is haskell.org. do you have ghc installed?
18:05:25 <eddyp> dons: yes, I have ghc
18:05:34 <fantasma> "parse error (possibly incorrect indentation)"
18:05:53 <dons> eddyp: have you read 'Haskell in 5 steps' on haskell.org?
18:05:56 <fantasma> there is no indentation on that line (and there isn't supposed to be
18:06:07 <sjanssen> fantasma: double check your paren nesting
18:06:07 <fantasma> s//)/
18:06:16 <sjanssen> especially on the previous lines
18:06:19 <dons> eddyp: also, you might find something here, http://haskell.org/haskellwiki/Blog_articles
18:06:20 <lambdabot> Title: Blog articles - HaskellWiki
18:06:34 <dons> sjanssen: so I think I'll have a go at the status bar situation
18:06:35 <fantasma> sjanssen, that line is just standing there, no nesting
18:06:49 <eddyp> dons: no, not yet; as I said I got confused big-time
18:07:22 <dons> eddyp: here's a simple ghci session:
18:07:23 <dons> $ ghci
18:07:23 <dons> Prelude> let f x = x + 1
18:07:23 <dons> Prelude> :t f
18:07:23 <dons> f :: (Num a) => a -> a
18:07:25 <dons> Prelude> f 7
18:07:28 <dons> 8
18:07:41 <dons> note that ghci takes *expressions* to evaluate, not top level declarations that you'd put in a file
18:07:54 <eddyp> dons: oh, that "Haskell in 5 steps", I went through that
18:07:56 <dons> so its useful for exploratory stuff, and testing out code and ideas
18:08:05 <eddyp> :-D
18:08:10 <dons> are you able to compile and run a simple program?
18:08:12 * eddyp is still confused
18:08:22 <dons> main = print "hello, world" -- for example?
18:08:57 <fantasma> @pl \x y -> take y (cycle x)
18:08:57 <lambdabot> flip take . cycle
18:09:25 <fantasma> why doesnt @pl put the variables back in?
18:09:48 <dons> that would add points. its pointfree code remember :-)
18:10:05 <fantasma> pointless
18:10:11 <sjanssen> fantasma: the only purpose of @pl is to remove variables
18:10:28 <sjanssen> @unpl flip take . cycle
18:10:28 <lambdabot> (\ f c -> take c (cycle f))
18:10:38 <fantasma> neat
18:10:44 <fantasma> :t flip
18:10:44 <eddyp> dons: yes, I can coompile that
18:10:46 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:11:06 <dons> eddyp: ok. so where do you get stuck?
18:11:51 <eddyp> dons: where to go next and how do can I understand the priciples behind haskell?
18:11:52 <dons> sjanssen: hmm. i'm pondering the status bar running as an externl process, like dmenu
18:12:11 <dons> i.e. it would read from thunk's stdout or from a pipe/file on disk, and display the state, along with any extra stuff it wants
18:12:36 <dons> eddyp: ok. a good place would be to read and work through YAHT and the haskell wikibook
18:12:39 <dons> ?where yaht
18:12:40 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
18:12:42 <dons> ?where wikibook
18:12:43 <lambdabot> http://en.wikibooks.org/wiki/Haskell
18:12:55 <dons> those two should get you to level 3 lambda hacker status
18:13:27 <sjanssen> dons: yeah, thunk could dump it's status to stdout or some such
18:13:56 <dons> right, would make the whole thing more modular, and easier to turn off statusbars for people who don't like them (or to replace them with a custom one)
18:14:04 <eddyp> dons: also the terminology is unknown to me... :-/
18:14:24 <sjanssen> dons: an external process sounds the best, I think.  I've read that xlib + multithreading is very tricky
18:14:27 <sorear> eddyp: all terms can be defined by ask-#haskell
18:14:45 <eddyp> sorear: sorry?
18:14:50 <dons> sjanssen: ok. i think so too. so we can just dump state snapshots to stdout
18:14:53 <eddyp> ?lamba
18:14:54 <lambdabot> Unknown command, try @list
18:14:55 <dons> and run:  exec thunk | statusbar
18:14:59 <dons> for those who want that.
18:15:00 <eddyp> ?lambda
18:15:01 <lambdabot> Plugin `unlambda' failed with: IRCRaised Data.ByteString.last: empty ByteString
18:15:04 <sorear> eddyp: just ask us when you have a question!
18:15:39 <eddyp> sorear: ok
18:15:39 <sjanssen> dons: you want thunk to print all of your statusbar info?
18:15:42 <sorear> also, you're using the wrong dictionary command
18:15:43 <sorear> ?foldoc lambda
18:15:44 <lambdabot> *** "lambda" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
18:15:45 <lambdabot> LAMBDA
18:15:45 <lambdabot>  
18:15:45 <lambdabot>         A version of {typed lambda-calculus}, used to describe
18:15:45 <lambdabot>         semantic {domain}s.
18:15:46 <lambdabot> [4 @more lines]
18:16:08 <Cale> ?foldoc 
18:16:10 <lambdabot> No match for "".
18:16:10 <dons> sjanssen: I want it to print thunk's state
18:16:28 <dons> then you plug in your own statusbar in front, which adds any extra details
18:16:40 <dons> so thunk would just write the workspace and title info to stdout when it changes
18:16:45 <sjanssen> oh right, I see now
18:16:50 <sorear> eddyp: unfortunately most of our documentation is in a fleshy gray format
18:17:12 <dons> eddyp: a lot of definitions are described on hasklel.org
18:17:18 <dons> look up 'Glossary' on haskell.org
18:18:42 <fantasma> > let (--) a b = a**b in 4 `--` 3
18:18:42 <lambdabot>  Parse error
18:19:04 <Cale> heh, that's funny, when static.reddit.com is down, you can't vote on articles, because the UI for that doesn't load
18:21:31 <merus> > let n a b = do a' <- a; b' <- b; return (a' + b') in n [1..3] [1..3]
18:21:32 <lambdabot>  [2,3,4,3,4,5,4,5,6]
18:21:59 <merus> There must be a better way of writing that, hrm.
18:22:15 <Cale> n = liftM2 (+)
18:22:40 <fantasma> :t liftM2
18:22:42 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:22:46 <merus> Oh.  That's what lift* does.
18:22:53 <dons> sjanssen: btw, if you make a change that depends on something in X11-extras, could you mention that in the patch name? something like: "fix XYZ (update X11-extras)"
18:22:55 * merus feels noob.
18:23:30 <fantasma> > liftM2 (+) [1..5] [1..5]
18:23:31 <lambdabot>  [2,3,4,5,6,3,4,5,6,7,4,5,6,7,8,5,6,7,8,9,6,7,8,9,10]
18:23:46 <Cale> http://www.boasas.com/
18:23:47 <lambdabot> Title: [Boy on a Stick and Slither]
18:23:48 <dons> sjanssen: re. stdout/ status, I think the best way is to provide a script, #!/bin/sh thunk | statusbar
18:23:59 <dons> sjanssen: such that then we just exec $HOME/bin/thunk-wrapper
18:24:40 <dons> sjanssen: i'll have a go at writing down a manifesto too
18:24:54 * dons wonders why the authors of minimal window managers always turn into cranks
18:25:21 <dons> Both Anselm and Tuomo can be a bit abrasive. why is that? "No features for you - luser!" ?
18:25:34 <merus> Thanks Cale.
18:25:37 <sjanssen> dons: yes, I've wondered this too
18:25:38 <dino-> @paste
18:25:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:25:40 <greentea> Cranks in what sense?
18:25:42 <Cale> Because if they weren't cranks to begin with, they'd have written more sensible window managers!
18:25:53 <sjanssen> will we be jerks in one month's time?
18:26:02 <dons> i guess so!
18:26:25 <dons> if people ask you for feature bloat 3 times a day for a year, that might turn me cranky
18:26:35 <hpaste>  dino- pasted "HXT, numbering" at http://hpaste.org/858
18:26:41 <SamB> does GHC really still have implicit parameters?
18:26:50 <sjanssen> SamB: oh yes
18:26:53 <dons> it does. but don't use them
18:26:54 <hpaste>  dino- annotated "HXT, numbering" with "the document" at http://hpaste.org/858#a1
18:26:57 <sjanssen> SamB: see the source for @pl
18:26:59 <dons> use a state monad
18:27:11 <hpaste>  dino- annotated "HXT, numbering" with "output" at http://hpaste.org/858#a2
18:27:17 <dons> oh TheHunter was a big implict params fan. possibly the biggest user of them
18:27:32 <dino-> Ok, I'm back with that HXT.
18:27:35 <narain> speaking of minimal window managers, i just switched from gnome to wmii today
18:27:51 <narain> after being inspired towards it by talk on #haskell a couple of days ago
18:27:56 <Cale> dino-: you know that if you don't want to produce XML, you can produce plain text instead, right?
18:28:00 <sjanssen> narain: and one day, you shall switch to thunk
18:28:13 <narain> sjanssen: thunk?
18:28:15 <fantasma> who named it thunk
18:28:16 <sjanssen> dons: are you writing the statusbar in tree?
18:28:16 <dino-> Cale: I'm not sure how to do that exactly either. But one insurmountable problem at a time, eh?
18:28:22 <Cale> hehe
18:28:35 <sjanssen> narain: a window manager dons and I are hacking on
18:28:39 <sjanssen> @where thunk
18:28:40 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/thunk/
18:28:41 <dino-> So, if Cale, anyone else has time..
18:28:50 <narain> sjanssen: ooo, nice
18:29:04 <dino-> Now, see in the source, I have that labelText commented out?
18:29:27 <dons> sjanssen: I'll see if I can rip out dwm's status bar code as an external app
18:29:29 <sjanssen> narain: it isn't ready for prime time yet, but you should check back in a few weeks
18:29:55 <dons> and we can distribute the haskell version with thunk
18:30:08 <dino-> When I have it there, that part before the >>> ( changes to :: ArrowXml a => a XmlTree (String, XmlTree)
18:30:13 <narain> sjanssen: after reading the motivation section in the readme i like it already :)
18:30:34 <dino-> So, I've been having trouble figuring out how to do the part inside the following ( ) so that it can handle the (String, XmlTree)
18:31:24 <dino-> narain, others talking WMs: I've used fluxbox for a long time now, maybe 2+ years. Very minimal.
18:31:55 <Cale> dino-: Not compared to the WMs these people are talking about.
18:31:58 <sjanssen> dino-: you don't know minimal until you've tried dwm :)
18:32:39 <dino-> Hm, I have to check these things out.
18:32:40 <Cale> These things make fluxbox look like emacs.
18:32:46 <dino-> heh
18:33:10 <dons> sjanssen: i find dwm bloated now... too much statusbar gunk. and border! urgh!
18:33:14 <Cale> http://www.nongnu.org/ratpoison/shot2.png
18:33:35 <dino-> Oh yeah, heard of ratpoison, but never tried it.
18:33:48 <dons> ratpoison is bloated
18:33:55 <dons> well, ugly
18:33:59 <dons> doesn't have to be ugly
18:34:05 <fantasma> wmii ftw
18:34:11 <SamB> and here I am using windowmaker
18:34:17 <dino-> I do use screen constantly, which is like a wm in its own way, I suppose.
18:34:22 <SamB> it seems pretty minimal compared to GNOME or KDE though
18:34:41 <Cale> http://www.suckless.org/shots/dwm-20070224.png
18:34:41 <dons> http://www.cse.unsw.edu.au/~dons/tmp/thunk/thunk-live.png
18:34:44 <sjanssen> fluxbox is to thunk as emacs is to cat
18:35:00 <dons> hehe
18:35:08 <sjanssen> dons: that isn't the latest version!
18:35:15 <dons> no. true.
18:35:32 <dons> we've got dmenu support and workspaces now.
18:35:33 <sjanssen> now you're wondering how I know . . .
18:35:48 <dons> hehe
18:35:56 <Cale> I want a really cool Haskell wm, which tries to slowly organise my windows in the background so that I'll always be able to get to them with a single click.
18:35:57 * allbery_b has pretty much moved to KDE.
18:36:32 <sjanssen> KDE is to thunk as eclipse is to cat
18:36:56 <allbery_b> yeh
18:37:00 <fantasma> hmmm that's an understatement
18:37:02 <Cale> KDE and Gnome aren't really window managers though.
18:37:08 * allbery_b likes GUIs, sue him :)
18:37:14 <dino-> ooh, I like that dwm already.
18:37:19 <dons> I find it funny that the two window managers worked on by people at unsw are enlightenment .. and thunk
18:37:34 <allbery_b> no KDE = window manager + task manager + component management framework
18:37:35 <Cale> It's KWM and Metacity.
18:37:40 <sjanssen> Cale: and cat isn't a kitchen sink :).  Good analogy, I think
18:37:41 <dino-> Anybody see that crazy thing with the stacks and gestures, a few months ago?
18:37:50 <dino-> I'll see if I can find a name and link for it..
18:38:01 <Cale> (The default wms for KDE and Gnome.
18:38:03 <Cale> )
18:38:15 <Cale> You can use other window managers with KDE and Gnome just fine.
18:38:17 <allbery_b> I like being able to dcop programs and make them do things from the command line, yet still be able to do standard GUI stuff :)
18:38:22 <Cale> I ran Gnome + Enlightenment for a long time.
18:38:31 <QtPlatypus> dcop?
18:39:17 <allbery_b> command line client to KDE's object/component management protocol (also called DCOP)
18:39:21 <Cale> I want a gui where there are visual analogues of shell pipelines, where I can visibly wire things together.
18:39:34 * QtPlatypus nods to Cale.
18:39:52 <allbery_b> HP had one once upon a time, I'm given to understand
18:40:01 <dmwit> dons: re border: Can't you #define BORDERPX 0 in config.h for dwm?
18:40:10 <allbery_b> well, that was actually wiring shell pipelines together in a GUI fashion, I guess
18:40:26 <fax--> hey how do you best make a variable -> value type hashtable thingy
18:40:26 <allbery_b> I could see someone doing a GUI frontend to dcop
18:40:34 <ClaudiusMaximus> Cale: like this?  http://claudiusmaximus.goto10.org/gallery/coding/d01234/rev201-twofivesixspheres.png   (not for shell commands, though)
18:40:36 <lambdabot> http://tinyurl.com/2al2e7
18:40:43 <dmwit> Data.Map?
18:40:45 <allbery_b> fax--: Data.Map, Data.Hashtable
18:40:53 <fax--> alright thank you two :D
18:41:05 <Cale> ClaudiusMaximus: something like that, though between applications
18:41:18 <ClaudiusMaximus> Cale: ok
18:41:19 <dmwit> ?help index
18:41:20 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
18:41:30 <dons> dmwit: indeed i do.
18:41:44 <dmwit> ah, k =)
18:42:31 <SamB> Cale: I don't think it would be possible to arrange my windows like that
18:42:42 <Cale> SamB: oh?
18:43:08 <SamB> if you define "possible to reach in one click" to involve a reasonably large (in both dimensions) area in which said click can occur
18:43:32 <SamB> and anyway I wouldn't want it rearranging windows I might be looking at...
18:43:46 <allbery_b> hm, there's a gui dcop browser (kdcop) but it doesn't look like it's designed to be usable in scripting stuff on the fly
18:43:51 <monochrom> index unsafePerformIO
18:43:55 <monochrom> @index unsafePerformIO
18:43:56 <lambdabot> System.IO.Unsafe, Foreign
18:43:58 <Cale> Well, that's true, you need it to be smart about it, and not move things very quickly even when it does.
18:44:13 <dino-> Hm. Can't find this gui thing. My bookmarks are a mess. :(
18:44:23 <Cale> and perhaps there needs to be ways to express constraints.
18:44:25 <Cale> (and save them)
18:44:55 <SamB> maybe you could make the windows that you couldn't really see turn into fish
18:45:00 <Cale> hehe
18:45:01 <Cale> :)
18:45:09 <dons> here's a current thunk screenshot, with dmenu: http://www.cse.unsw.edu.au/~dons/tmp/thunk/thunk.png
18:45:12 <dons> sjanssen: ^^
18:45:14 <SamB> (only with a composite manager, though, I think ;-)
18:45:33 <Cale> SamB: that would be incredible eyecandy, though perhaps not terribly practical :)
18:45:52 <SamB> well, I was assuming they would have their contents on there somewhere
18:46:04 <Cale> yeah, I'm thinking deform the window into a fish
18:46:43 <Cale> heh, maybe even tune the appearance of the fish based on the dimensions of the original window. :)
18:46:47 <allbery_b> postmodern window managers implement windows as OpenGL textures so they can do such things :)
18:47:45 <dmwit> So, currently dmenu appears over top of other windows?
18:47:49 <monochrom> Gosh, Thunk is going to be the next window manager to require DirectX 9.1 or something!
18:47:50 <Cale> hmm, I haven't seen the graphics put to really *good* use though
18:48:12 <Cale> It would be nice to see some innovative widgets.
18:48:30 <dmwit> Have you seen the Kiba dock?
18:48:35 <wy> Are there some Haskell developing environments in Windows?
18:48:36 <dmwit> (Maybe sp. Kibo)
18:49:00 <allbery_b> (it says something about X11 that to do interesting things you need to punt to OpenGL)
18:49:09 <monochrom> The web browser is mapped to a sphere.  Kind of matches the Firefox icon, which includes a sphere. :)
18:49:16 <allbery_b> wy: visual haskell?
18:49:18 <dons> dmwit: right. dmenu appears above .
18:49:21 <Cale> dmwit: yeah
18:49:44 <dmwit> Cool.
18:49:51 <dmwit> Cale: That seemed fairly useful to me.
18:50:03 <Cale> Well, sort of. It seems a little messy in its operation.
18:50:18 <wy> allbery_b, I don't really expect that kind of thing. Just need more than a command window ;-)
18:50:34 <Cale> (the demos I've seen had the icons dancing around like crazy)
18:50:57 <narain> wy: no, it actually exists
18:50:58 <Cale> You could make the effect more subtle, and get the same utility
18:51:02 <narain> @where visual-haskell
18:51:02 <lambdabot> I know nothing about visual-haskell.
18:51:08 <narain> @where visualhaskell
18:51:08 <lambdabot> http://www.haskell.org/visualhaskell/
18:51:18 <wy> narain, how is it?
18:51:28 <narain> it's very good
18:51:45 <narain> if you're used to visual studio you'll have no trouble
18:51:50 <SamB> allbery_b: what would you prefer to punt to over OpenGL?
18:52:07 <SamB> also, what other OSes allow you to do interesting things without doing that?
18:52:08 <narain> wy: also it catches type errors in real-time
18:52:33 <wy> narain, So I need to have Visual Studio?
18:52:45 <Cale> actually, the coolest UI I've seen in a while didn't have many visible widgets at all
18:52:53 <narain> wy: um, yes. sorry, i should have mentioned that :(
18:53:07 <SamB> Cale: oh?
18:53:10 <SamB> what UI was that?
18:53:11 <narain> wy: or you could install emacs and haskell-mode :)
18:53:22 <Cale> SamB: a multitouch UI
18:53:43 <wy> narain, it seems interaction from emacs in Windows is a bad idea
18:53:59 <Cale> http://www.youtube.com/watch?v=4nXHdkwgOMs
18:54:03 <SamB> Thu Nov 30 22:42:07 EST 2006  simonpj@microsoft.com
18:54:03 <SamB>   * q
18:54:09 <SamB> what a strange patch name!
18:54:31 <Cale> check that out :)
18:54:34 <dino-> A patch from the Q continuum.
18:54:42 <narain> wy: i didn't have too much trouble last time i tried it
18:54:44 * SamB can't youtube without flash installed
18:54:50 <narain> wy: haven't used emacs in windows a lot though
18:54:55 <narain> wy: what have you heard?
18:55:04 <Cale> SamB: then install flash :)
18:55:18 <SamB> Cale: I uninstalled it because it kept effectively locking up X
18:55:21 <wy> Cale, What's that?
18:55:39 <Cale> SamB: which version?
18:55:48 <SamB> I think it was 7 or 8
18:55:55 <SamB> but I can't imagine 9 is better
18:56:12 <Cale> Probably 7, 9 is out now. I've had few problems since the patch release.
18:56:39 <SamB> (unless it is somehow smaller, or at least requires less things to be mapped in when you right click on it)
18:56:42 <greentea> SamB: Have you tried using the youtube-dl script?
18:57:34 <SamB> no
18:58:05 <greentea> It's a Python script - you give it a YouTube URL, and it downloads the video, in FLV format.
18:58:20 <monochrom> I have no problem with 9.  At 7 or 8, needed an old c++ stdlib or else would crash.  At 9, no need for the old lib.  So I think there was significant change.
18:58:37 <wy> narain, do you know what does Visual Haskell produce? windows programs?
18:58:49 <Cale> http://www.youtube.com/watch?v=UcKqyn-gUbY gives more explicit detail of what's going on
18:59:06 <SamB> monochrom: so you think my X will not be effectively locked up for minutes when I right click, if I install 9?
18:59:20 <Cale> SamB: doesn't happen to me
18:59:27 <SamB> Cale: did it happen in 7?
18:59:40 <monochrom> To be fair, I didn't get 7 or 8 to lock X either.
18:59:41 <Cale> uh, I don't know, sometimes the menu was a little slow
18:59:56 <Cale> Which flash app was it?
19:00:06 <SamB> app?
19:00:19 <narain> wy: it creates cabal packages, compiles to windows exes by default
19:00:19 <SamB> this happened whenever I right clicked on a flashlet
19:00:31 <Cale> always? Okay, no, that doesn't happen for me
19:00:49 <SamB> but it used to happen a little?
19:00:51 <narain> wy: i have no experience with cabal packages but i imagine they could be distributed platform-independently
19:00:52 <SamB> on 7?
19:01:11 <SamB> (when you hadn't done it recently)
19:01:13 <wy> narain, can I create windowed software or just command line?
19:01:47 <Cale> SamB: I don't remember anything too severe, but there were times on some flash applets where the menu would be slow.
19:01:51 <monochrom> You may have bad X driver or bad X settings (e.g. too much acceleration)
19:01:57 <Cale> That hasn't happened with 9 yet.
19:02:05 <SamB> okay, that sounds encouraging
19:02:17 <Cale> The Flash 9 guys actually seem interested in making flash work well on linux.
19:02:33 <SamB> I'm sure you would have experienced much less severe problems with whatever nice amount of RAM you have ;-)
19:02:41 <Cale> Well, I have 1GB.
19:02:52 <narain> wy: visual haskell actually compiles using ghc, so you can do anything ghc supports
19:03:08 <narain> wy: which is mostly anything i suppose :)
19:04:14 <wy> I have homework to do. See you guys later!
19:04:32 * greentea has had no problems thus far running Flash 9 on a system with only 256M.
19:04:37 <SamB> wow. 9.0.31.0.1
19:04:50 <SamB> I think that is the longest version number I've seen
19:05:04 <SamB> not counting dashed numbers from distro patches
19:06:15 <Zeroth404> a lil help, anyone:
19:06:17 <hpaste>  zeroth pasted "Main.hs:20:16:
19:06:23 * SamB wishes flashplugin-nonfree supported license fetching
19:06:30 <Zeroth404> thats funky
19:06:34 <Zeroth404> http://hpaste.org/859
19:06:37 <Cale> uh, whoa, is that an hpaste bug?
19:06:42 <Zeroth404> looks like it
19:06:50 <Zeroth404> potential for injection
19:07:20 <SamB> what? hpaste has the string problem?
19:07:46 <Cale> Zeroth404: hmm, are you sure you're using the term 'permutation' correctly?
19:08:09 <Zeroth404> probably not, but thats the leats of my worries
19:08:24 <Cale> (permutation means rearrangement)
19:08:32 <Zeroth404> then yes
19:08:39 <Cale> So, like swapping a bunch of the letters
19:08:51 <fax--> > convert 0 ("123" ++ "24")
19:08:52 <lambdabot>   Not in scope: `convert'
19:09:08 <narain> > let foo = do word <- []; return word
19:09:08 <lambdabot>  Parse error
19:09:16 <monochrom> Multiple type errors in that paste.
19:09:17 <narain> > do word <- []; return word
19:09:19 <lambdabot>  []
19:09:40 <sorear> hi
19:09:47 <Zeroth404> Cale: like yaa, zaa, abaa, bbaa, cbaa, etc
19:09:53 <narain> > do word <- []; return "+" ++ word ++ "+"
19:09:54 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
19:10:07 <narain> well that's not going to work is it now
19:10:09 <Cale> Zeroth404: I'm not sure what to call that
19:10:13 <dmwit> Zeroth404: in the list monad, doing z <- String will let z be of type (Monad m) => m Char
19:10:22 <Zeroth404> Cale: I've always heard it called permutations
19:10:27 <Cale> Zeroth404: permuteWord has the wrong type
19:10:40 <Zeroth404> I haven't gotten to the Monad section yet :-/
19:10:42 <Cale> If you want to do a putStrLn in the middle of it, it must be in IO
19:10:51 <Zeroth404> permuteWord has stype String
19:11:05 <Zeroth404> I tried to make it IO and got other errors
19:11:09 <Cale> except that strings can't print stuff to the terminal :)
19:11:13 <Cale> Let me give you an introduction to IO
19:11:26 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
19:11:27 <lambdabot> Title: Introduction to IO - HaskellWiki
19:11:37 <dino-> Hey, this is funny. I just wrote this: (\(s, _) -> s) and then thought, hm, suspiciously like const for pairs...
19:11:40 <Cale> that's really short and should give you the gist of the idea
19:11:40 <Zeroth404> Cale: Kind error: `IO' is not applied to enough type arguments
19:11:46 <Zeroth404> stuff like that
19:11:48 <dino-> And then I wrote it like (uncurry const)
19:11:51 <Zeroth404> permuteWord :: Int -> String -> IO
19:11:53 <Cale> Zeroth404: that's because IO is a type constructor
19:11:56 <narain> Zeroth404: also, word <- [] does not do what you think it does
19:11:58 <Cale> IO () is a type
19:12:00 <Cale> IO String
19:12:01 <dino-> And then 20 minutes later thought, hey, isn't that fst?
19:12:02 <Cale> IO Integer
19:12:14 <narain> dino-: haha
19:12:28 <dino-> narain: serious, this just happened. For real.
19:12:40 <Cale> dino-: everyone rewrites half the prelude :)
19:12:54 <narain> dino-: i sympathize wholeheartedly
19:12:56 <dolio> ?pl uncurry const
19:12:56 <lambdabot> fst
19:13:00 <SamB> unfortunately it isn't always the same half
19:13:12 <dino-> heh
19:13:23 <narain> pl is pretty smart, eh
19:13:39 <narain> ?pl flip const
19:13:40 <lambdabot> const id
19:13:52 <Cale> > sum . map (const 1) $ "Hello, there."
19:13:54 <lambdabot>  13
19:14:08 <Cale> hehe
19:14:30 <narain> Cale: it took me a couple of seconds to get that :D
19:14:55 <sorear> > sum . (>>) [1] $ "Hello, there."
19:14:56 <lambdabot>   add an instance declaration for (Num Char)
19:15:10 <dibblego> narain, just remember that const x is the same as \_ -> x
19:15:11 <sorear> > sum . (<<) [1] $ "Hello, there."
19:15:12 <lambdabot>   Not in scope: `<<'
19:15:19 <sorear> what? no <<?
19:15:27 <sorear> > sum . (>>[1]) $ "Hello, there."
19:15:28 <lambdabot>  13
19:15:41 <narain> ?t (>>)
19:15:41 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
19:15:46 <narain> :t (>>)
19:15:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:15:57 <narain> oh right, i completely forgot
19:16:02 <Zeroth404> I have to use  word <- ""  at the beginning of the fucntion or else I get "not in scope" later in the function, but if I DO, then I get soem crap about matching IO agains []
19:16:05 * Zeroth404 pulls his hair out
19:16:38 <sorear> Zeroth404: let word = ""
19:16:43 <Zeroth404> let
19:16:43 <Zeroth404> haha
19:16:45 <Cale> Zeroth404: String is incapable of carrying around information about what IO to do.
19:17:02 <sorear> Zeroth404: only use <- if you want to run a subaction...
19:17:08 <Cale> In particular, there's no way that a String can have a putStrLn in it.
19:17:16 <sorear> the system interpreted "" as nondeterminism
19:17:19 <Cale> It's just a list of Chars.
19:17:22 <Zeroth404> yeah, I couldn't get = to work and I knew why, but "let" escaped me
19:17:39 <Zeroth404> I thought <- was only for capturing output...but...meh
19:17:44 <Cale> It is.
19:17:49 <Zeroth404> yeah
19:17:58 <Cale> You're running the computation ""
19:18:08 <Cale> in the list monad
19:18:12 <Cale> producing no results.
19:18:33 <Zeroth404> Couldn't match `String' against `IO String'
19:18:36 <Cale> then later on, you're doing stuff in the IO monad, which doesn't work, since the monads involved in a do-block have to match
19:18:37 * Zeroth404 drops jaw
19:18:50 <narain> Zeroth404: you should probably avoid trying to do IO within other functions
19:18:52 <Zeroth404> a string was a string last I knew
19:18:54 <Zeroth404> lol
19:19:04 <Cale> @type putStrLn
19:19:06 <lambdabot> String -> IO ()
19:19:29 <Cale> There's no way for putStrLn to be put into a String.
19:19:34 <dmwit> Haha, a string isn't a string when it's a list of characters.
19:19:36 <dmwit> =P
19:20:03 <Zeroth404> dmwit: if its a list of characters and therefor not a string, then it cant be a string to be compared to "string" in the first place.
19:20:11 <Cale> (putStrLn word) is an IO action
19:20:13 <Zeroth404> paradox
19:20:20 <dmwit> > do letters <- "Hi, zeroth"; return . succ
19:20:20 <Cale> that is, it's a program which when run will print word on the screen
19:20:21 <lambdabot>  Couldn't match expected type `[]' against inferred type `(->) a'
19:20:31 <dmwit> > succ 'a'
19:20:33 <lambdabot>  'b'
19:21:10 <Cale> hehe
19:21:18 <greentea> Zeroth404: There's the 'String' type in the context of pure fucntions, and the 'String' type in the content of doing IO, which is a different type.
19:21:18 <Zeroth404> :t putStrLn
19:21:20 <Zeroth404> :t print
19:21:21 <lambdabot> String -> IO ()
19:21:23 <lambdabot> forall a. (Show a) => a -> IO ()
19:21:25 <Cale> > do letter <- "Hi, zeroth"; return (succ letter)
19:21:27 <lambdabot>  "Ij-!{fspui"
19:21:41 <dmwit> There we go.
19:21:56 <Cale> > do x <- [1..3]; y <- [4,5]; return (x,y)
19:21:57 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
19:22:19 <dmwit> :t (>>=)
19:22:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:22:23 <Cale> Zeroth404: basically, in the construction of a plain String, you can't do IO.
19:22:32 <dmwit> > "Hi, zeroth" >>= succ
19:22:33 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Char'
19:22:34 <Cale> Zeroth404: for that, you'd need an IO String
19:22:43 <dmwit> > "Hi, zeroth" >>= return .succ
19:22:47 <Cale> which is not a String, it's a computation which if ever run, would produce a string.
19:23:07 <Zeroth404> all I wanna do is print out each string each time it gets "permuted" in a recursive function
19:23:12 <Cale> (and maybe do some IO along the way)
19:23:20 <Cale> Let's take another approach.
19:23:29 <Cale> Rather than printing the strings, let's build a list of them.
19:23:36 <Zeroth404> ah
19:23:44 <dmwit> Huh, lambdabot stopped telling me I was wrong.
19:23:47 <Zeroth404> but thats a serious waste of memory, if there are a lot
19:23:56 <Cale> Not necessarily
19:24:02 <Cale> Remember that Haskell is lazy.
19:24:04 <Zeroth404> permute aaaaaaa to zzzzzzzz
19:24:06 <Zeroth404> thats a lot
19:24:09 <Zeroth404> yeah
19:24:09 * dibblego yells "lazy"
19:24:16 <Cale> So it won't build parts of the list it doesn't need.
19:24:25 <fax--> hey if you want to use Parsec to get a number
19:24:32 <sorear> fmap read
19:24:35 <fax--> like 42 or 1.618
19:24:35 <sorear> fmap read (many1 digit)
19:24:41 <fax--> would you use http://hpaste.org/657
19:25:03 <sorear> no
19:25:06 <fax--> or can you use naturalOrFloat?
19:25:10 <Cale> Hang on for a moment, and let me try to understand what your program is doing.
19:25:12 <sorear> all good haskell programs are 2 lines :)
19:26:33 <Zeroth404> I'll be here all night
19:26:35 <Zeroth404> heh
19:26:40 <Zeroth404> at least for the next hour
19:26:56 <Zeroth404> back in a few, gunna play some Q3
19:26:58 <Cale> what is the Int for in upWord?
19:27:03 <Cale> oh Q3?
19:27:10 <Zeroth404> Int?
19:27:17 <Zeroth404> here
19:27:18 <Cale> Yeah, that Int parameter
19:27:38 <Cale> It seems to start from there?
19:27:48 <Zeroth404> permuteWord is a recursive function which word calls upWord
19:27:58 <Zeroth404> upWord permutes a word once
19:28:05 <glguy> what sort of section might I use in LaTeX to provide some psuedocode?
19:28:06 <Zeroth404> ie, changes yaaa to zaaa
19:28:15 <Zeroth404> or zaaa to abaa
19:28:18 <glguy> where I need <pre> behavior for newlines and whatnot
19:28:40 <narain> glguy: have you looked at the algorithm package?
19:28:42 <Zeroth404> the Int is there to be told which element of the string to "roll"
19:28:44 <fax--> Zeroth404: thats just a base 24 number
19:28:47 <Cale> This is basically base-26 arithmetic
19:28:48 <glguy> narain: nope, should I??
19:28:53 <fax--> er 26 depending or your alphabets
19:29:03 <narain> glguy: it formats pseudocode nicely
19:29:08 <glguy> nifty
19:29:12 <Zeroth404> yeah, technically
19:29:14 <narain> glguy: not sure what you mean by <pre> behaviour
19:29:28 <narain> glguy; you do have to use explicit \\'s for newlines i think
19:29:29 <Cale> That realisation should actually help quite a bit.
19:29:44 <glguy> narain: algorithm2e, algorithmicx, algorithms?
19:30:02 <glguy> alg?
19:30:10 <hpaste>  dino- annotated "HXT, numbering" with "oh yeah, baby, it works!" at http://hpaste.org/858#a3
19:30:14 <narain> glguy: hmm, i don't recall multiple packages named like that
19:30:20 <narain> glguy: let me check
19:30:24 <glguy> narain: I'm got Miktex installed
19:30:32 <glguy> narain: I want to be able to do this from windows also
19:30:50 <hpaste>  dino- annotated "HXT, numbering" with "new output" at http://hpaste.org/858#a4
19:31:00 <Zeroth404> not sure how to define an int of another base
19:31:17 <glguy> there is also packages: psuedocode, newalg, program
19:31:49 <Zeroth404> would be easy though, I could (read) it and (map) the numbers to chars
19:32:01 <Zeroth404> s/read/show
19:32:15 <Zeroth404> I'll leave that for tomarrow, I gotta play some Q3
19:32:53 <fax--> how do you turn Either Integer Double into a Float?
19:33:14 <Cale> Zeroth404: where are you playing Q3?
19:33:14 <narain> glguy: they should all be reasonable choices
19:33:21 <narain> http://bliss.biology.yale.edu/~zasha/latex.html
19:33:22 <lambdabot> Title: Helpful LaTeX things
19:33:33 <Cale> Zeroth404: I play a bit :)
19:33:33 <narain> i think i used algorithmic
19:33:39 <narain> under windows
19:33:41 <dmwit> let increment [] = [], increment ('z':xs) = 'a':increment xs, increment (x:xs) = succ x:xs in increment "hi"
19:33:49 <dmwit> > let increment [] = [], increment ('z':xs) = 'a':increment xs, increment (x:xs) = succ x:xs in increment "hi"
19:33:50 <lambdabot>  Parse error
19:33:59 * fax-- is in the process of converting lara crofts house into a quake 3 map
19:33:59 <glguy> http://algorithms.berlios.de/screenshots.html
19:34:01 <lambdabot> Title: The algorithms Package for LaTeX
19:34:02 <glguy> looks pretty?
19:34:15 <dmwit> > let increment [] = []; increment ('z':xs) = 'a':increment xs; increment (x:xs) = succ x:xs in increment "hi"
19:34:17 <lambdabot>  "ii"
19:34:20 <narain> glguy: http://www.tex.ac.uk/cgi-bin/texfaq2html?label=algorithms
19:34:22 <lambdabot> Title: TeX Frequently Asked Questions -- question label "algorithms"
19:34:30 <dmwit> Zeroth404: Something like that?
19:34:47 <dmwit> > let increment [] = []; increment ('z':xs) = 'a':increment xs; increment (x:xs) = succ x:xs in increment "za"
19:34:49 <lambdabot>  "ab"
19:35:01 <narain> glguy: that screenshot looks pretty much the same as algorithmic's output
19:35:08 <narain> glguy: i guess they wouldn't differ too much
19:35:11 <dmwit> For most arithmetic, you don't have to tell which index in the array to increment.
19:35:26 <dmwit> Of course, mine increments "zz" to "aa", so it isn't quite the same.
19:35:26 <glguy> The algorithms bundle (which contains packages algorithm and algorithmic...
19:35:29 <narain> glguy: my last link has helpful info i believe
19:35:37 <glguy> narain: that's what I'm reading now
19:38:39 <fax--> convert a double to a float? :(
19:39:16 <fax--> @similar fromIntegral
19:39:16 <lambdabot> Unknown command, try @list
19:40:50 <allbery_b> @ty fromRational . toRational
19:40:53 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
19:41:53 <dmwit> > fromRational 3.57 :: Int
19:41:55 <lambdabot>   add an instance declaration for (Fractional Int)
19:41:55 <lambdabot>     In the expression: fro...
19:41:57 <allbery_b> I think that's as close as you get
19:42:17 <allbery_b> > (fromRational . toRational) :: Double -> Float
19:42:19 <lambdabot>  <Double -> Float>
19:42:25 <dmwit> ?hoogle floor
19:42:25 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
19:42:36 <fax--> thanks again
19:42:41 <fax--> that did actually work
19:42:46 <dmwit> :t toIntegral
19:42:49 <lambdabot> Not in scope: `toIntegral'
19:42:49 <fax--> I tried it a min ago but must have got somthing wrong..
19:42:53 <fax--> works now though :D
19:42:59 <narain> fromRational 3.57
19:43:03 <narain> > fromRational 3.57
19:43:05 <lambdabot>  3.57
19:43:18 <fax--> why can I do case .. of A -> return .. B -> return ..
19:43:20 <allbery_b> alternately there's composing decodeFloat and encodeFloat, I suppose
19:43:28 <fax--> buyt I cant to return case .. of A -> .. B -> ..
19:43:43 <allbery_b> return (case ...)
19:43:52 <allbery_b> or return $ case ...
19:43:54 <TSC> Or "return $ case ..."
19:43:58 <fax--> oh heh
19:44:01 <TSC> @quote stereo
19:44:02 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
19:44:03 <fax--> ok cheers I see why now
19:46:02 <dibblego> ?users
19:46:03 <lambdabot> Maximum users seen in #haskell: 339, currently: 293 (86.4%), active: 41 (14.0%)
19:48:02 <dino-> Cale: Ok, you were saying, lo, those many minutes ago. About producing plain text instead of XML with HXT..?
19:48:22 <Cale> dino-: just don't use selem
19:48:34 <Cale> or those other functions which produce XML trees from arrows.
19:48:38 <dino-> But then I don't get a top-level element. Doesn't matter to writeDocument?
19:48:52 <Cale> Extract the bits of text you want, and you'll get a list of that text back
19:49:02 <Cale> don't use writeDocument either
19:49:06 <dino-> Ah, I see. Don't use write[XML]Document either.
19:49:27 <dino-> Ok. This stuff, it makes me feel silly. Like I don't see a lot of obvious things.
19:49:28 <dibblego> ?users
19:49:29 <lambdabot> Maximum users seen in #haskell: 339, currently: 295 (87.0%), active: 41 (13.9%)
19:49:37 <dino-> I blame the arrows.
19:50:00 <dino-> Kidding, I think a lot of trouble was _still_ not getting list monad.
19:50:20 <dino-> Cale: Thank you.
19:50:37 <Cale> no problem :)
19:54:21 <narain> glguy: picked a package yet? :)
19:54:38 <glguy> narain: I jumped into algorithms, which included the one you recommended
19:55:56 <narain> glguy: good, i guess it's just best to pick one and go with it
19:56:30 <narain> > > let increment [] = ['a']; increment ('z':xs) = 'a':increment xs; increment (x:xs) = succ x:xs in increment "zz"
19:56:31 <lambdabot>  Parse error
19:56:37 <narain> > let increment [] = ['a']; increment ('z':xs) = 'a':increment xs; increment (x:xs) = succ x:xs in increment "za"
19:56:39 <lambdabot>  "ab"
19:56:43 <narain> > let increment [] = ['a']; increment ('z':xs) = 'a':increment xs; increment (x:xs) = succ x:xs in increment "zzzz"
19:56:44 <lambdabot>  "aaaaa"
19:57:00 <fuzan> haha, imaginecup?
19:57:01 <lambdabot> fuzan: You have 1 new message. '/msg lambdabot @messages' to read it.
19:57:11 <chessguy> hi haskellers
19:57:45 <glguy> narain: do you use <= or <- for assignments?
19:57:53 <Daveman> chessguy :)
19:58:03 <glguy> \leftarrow and \Leftarrow (non-respectively)
19:58:35 <chessguy> heh. non-respectively, that's a good word
19:58:54 <narain> glguy: i prefer := actually
19:59:03 <glguy> is there a \command for that?
19:59:26 <narain> glguy: why would you need a \command for an pair of ascii characters?
19:59:35 <glguy> narain: because latex is weird like that
19:59:40 <narain> glguy: :D
20:00:09 <narain> glguy: i've seen <- in places if you're want to use arrows but i've never seen <= used anywhere
20:00:17 <narain> glguy: for assignment i mean
20:06:25 <greentea> Hm, what's the syntax for using guards in GHCi?
20:07:08 <dibblego> same as any other place
20:07:23 <allbery_b> you don't need a newline or semi before |
20:07:51 <allbery_b> > let f x | x == 0 = 1 | otherwise = 2 in (f 0, f 3)
20:07:52 <lambdabot>  (1,2)
20:08:13 <greentea> Ah, okay, thanks.
20:08:37 <SamB> > 1 <= 1
20:08:39 <lambdabot>  True
20:08:44 <fax--> @where AssocLeft
20:08:45 <lambdabot> I know nothing about assocleft.
20:08:47 <fax--> :(
20:08:59 <SamB> @hoogle AssocLeft
20:08:59 <lambdabot> Text.ParserCombinators.Parsec.Expr.AssocLeft :: Assoc
20:09:00 <lambdabot> Language.Haskell.Syntax.HsAssocLeft :: HsAssoc
20:09:16 <kc5tja> That's actually not accurate.  It's actually, let f x | x WHO GOES THERE?! ... umm ... me?  WHO'S ME?!  umm ... x?  WHAT DO YOU WANT?!?! ...   ;D
20:09:34 <chessguy> fax--: @where isn't haskell specific
20:09:37 <kc5tja> Now THAT ... THAT is a *strong* guard.  :)
20:09:47 <chessguy> @where+ banana on the counter downstairs
20:09:48 <lambdabot> Done.
20:09:50 <chessguy> @where banana
20:09:50 <lambdabot> on the counter downstairs
20:09:57 <narain> @where keys
20:09:58 <lambdabot> I know nothing about keys.
20:10:30 <narain> @where waldo
20:10:30 <lambdabot> I know nothing about waldo.
20:10:41 <narain> @where carmen
20:10:41 <lambdabot> I know nothing about carmen.
20:10:43 <narain> :(
20:10:45 <kc5tja> rotf
20:10:53 <chessguy> narain: let's not get carried away, please
20:11:20 <kc5tja> I thought that @where waldo was particularly amusing.  :)
20:11:22 <narain> sorry, couldn't resist
20:11:49 <fax--> lol
20:12:18 <kc5tja> Now, if it had said that Waldo was downstairs on the counter, that would have been even funnier.  :)
20:12:47 <chessguy> kc5tja: lambdabot is a "she", not an "it" :)
20:12:57 <chessguy> @quote she
20:12:57 <lambdabot> S.Behrens says: or maybe she is the Queen of Sciences and he is the Mack Daddy.
20:13:02 <chessguy> @quote she
20:13:02 <lambdabot> pjdelport says: [on qwe1234:] It must be a drag, being the sole beacon of sanity in a field where all the established researchers are unanimously insane.
20:13:05 <chessguy> @quote she
20:13:06 <lambdabot> JohnMeacham says: her name is lambda and she dances on the sand
20:13:12 <chessguy> @quote her
20:13:12 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
20:13:13 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
20:13:13 <fax--> @quote O_o
20:13:14 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
20:13:18 <fax--> :(
20:13:23 <chessguy> bah
20:13:26 <chessguy> @quote lambdabot
20:13:27 <lambdabot> lambdabot says: Beer, it's so much more than just a breakfast drink!
20:13:29 <chessguy> @quote lambdabot
20:13:30 <lambdabot> lambdabot says: fOra11 (t :: (* -> *) -> * -> *) (/\/\ :: * -> *) A. (/\/\oNAd+R4nz0rz t, MoN4D /\/\) => 7 ((->) a) (M a)
20:13:31 <chessguy> @quote lambdabot
20:13:31 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
20:13:34 <chessguy> @quote lambdabot
20:13:35 <lambdabot> lambdabot says: Done.
20:13:36 <chessguy> @quote lambdabot
20:13:37 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
20:13:42 <chessguy> ok, i give up
20:13:51 <narain> "There's no variables!" haha
20:14:45 <SamB> @quote var
20:14:45 <lambdabot> ghc says: Can't splice the polymorphic local variable
20:14:48 <SamB> @quote var
20:14:49 <lambdabot> ghc says: A lazy (~) pattern connot bind existential type variables
20:14:53 <SamB> @quote var
20:14:53 <lambdabot> ghc says: Can't combine named fields with locally-quantified type variables or context
20:14:56 <kc5tja> chessguy: You know, you all keep saying that, but a bot is a bot is a bot.  I don't care what anyone says.  And lambdabot was (and still is sometimes) quite rude to me, so I'm sure it can survive.
20:14:59 <SamB> hmm
20:15:41 <SamB> @where needle
20:15:42 <lambdabot> I know nothing about needle.
20:15:58 <kc5tja> @where+ needle in the haystack.
20:15:59 <lambdabot> Done.
20:16:20 <kc5tja> @where needle
20:16:20 <lambdabot> in the haystack.
20:17:14 <narain> good, now do @where haystack
20:18:21 <sorear> @where haystack
20:18:22 <lambdabot> I know nothing about haystack.
20:18:28 <sorear> @where+ haystack around the needle
20:18:28 <lambdabot> Done.
20:18:46 <fantasma> lets do it
20:18:49 <fantasma> :t curry
20:18:52 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:19:31 <chessguy> ?hoogle (a,b) -> c
20:19:32 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
20:19:32 <lambdabot> Prelude.fst :: (a, b) -> a
20:19:32 <lambdabot> Prelude.snd :: (a, b) -> b
20:19:47 <fantasma> yah
20:20:00 <fantasma> :t splitAt
20:20:03 <lambdabot> forall a. Int -> [a] -> ([a], [a])
20:21:10 <fax--> if f takes 3 parameters
20:21:16 <fax--> is flip (flip f a) b c silly
20:21:42 <narain> :t \f -> flip (flip f a) b c
20:21:44 <lambdabot> Not in scope: `a'
20:21:44 <lambdabot>  
20:21:44 <lambdabot> <interactive>:1:22: Not in scope: `b'
20:21:51 <narain> :t \f a b c -> flip (flip f a) b c
20:21:53 <fantasma> > reverse "Hemingway"
20:21:54 <lambdabot> forall a b b1 c. (a -> b -> b1 -> c) -> b -> b1 -> a -> c
20:21:54 <lambdabot>  "yawgnimeH"
20:22:40 <fantasma> that's my new nick
20:23:36 <rahikkala> > reverse "yawgmoth"
20:23:38 <lambdabot>  "htomgway"
20:24:17 <Cale> > reverse "Orwell"
20:24:19 <lambdabot>  "llewrO"
20:24:19 <yawgnimeh> > reverse "lambdabot"
20:24:21 <lambdabot>  "tobadbmal"
20:24:32 <yawgnimeh> to bad mal
20:24:38 <yawgnimeh> haha
20:24:51 <narain> yawgnimeh: You Ain't Weirdly Gonna Need It. MEH.
20:24:54 <Cale> > reverse "Hermann Hesse"
20:24:55 <lambdabot>  "esseH nnamreH"
20:25:17 <yawgnimeh> haha
20:25:47 <yawgnimeh> @quote+ narain says yawgnimeh: You Ain't Weirdly Gonna Need It. MEH.
20:25:48 <lambdabot> No quotes for this person. My mind is going. I can feel it.
20:25:57 <narain> is it possible to exclaim apathy? MEH!
20:25:59 <yawgnimeh> @remember narain says yawgnimeh: You Ain't Weirdly Gonna Need It. MEH.
20:26:00 <lambdabot> Done.
20:26:24 <narain> i wish i had something slightly more intelligent for my first quote :p
20:26:36 <narain> had *said*
20:26:37 <yawgnimeh> sucks for you :D
20:26:44 <narain> boo hoo
20:27:11 <Zeroth404> Cale: every respecatble gamer that likes FPS deathmatch likes Q3
20:27:23 <Cale> Zeroth404: :)
20:27:24 <Zeroth404> Cale: always play 72.5.248.168
20:27:28 <chessguy> hey Cale, is it possible on KGS to just sort of 'follow' strong games, so a new one opens when one i'm watching finishes?
20:27:48 <Zeroth404> new [sic] war room
20:27:54 <SamB> @quote dave
20:27:54 <lambdabot> No quotes match. Are you on drugs?
20:27:58 <SamB> @quote drugs
20:27:59 <lambdabot> DukeDave says: what, if your kids start doing drugs? or worse, business school
20:28:05 <SamB> @quote school
20:28:05 <lambdabot> DukeDave says: what, if your kids start doing drugs? or worse, business school
20:28:08 <SamB> @quote school
20:28:08 <lambdabot> DukeDave says: what, if your kids start doing drugs? or worse, business school
20:28:11 <SamB> huh
20:28:20 <yawgnimeh> @quote SamB
20:28:20 <lambdabot> SamB says: heh, my ~/.gtkrc.mine is recursive...
20:28:21 <Cale> chessguy: uh, I don't think so, unless it's a new feature I don't know about
20:28:23 <SamB> hay. why didn't that match for "Dave"?
20:28:24 <SamB> er.
20:28:25 <SamB> dave.
20:28:35 <Cale> chessguy: basically, sort games by rank and click the top one :)
20:28:50 <chessguy> Cale: yeah, but i don't want to have to click a new one when one ends
20:28:53 <Cale> (or a top one)
20:29:01 <fax--> ugh
20:29:06 <fax--> adding state to a parser
20:29:10 <fax--> sucks
20:29:23 <SamB> fax--: what kind of parser?
20:29:30 <fax--> using Parsec
20:29:34 <SamB> also, Parsec supports state passing internally
20:29:37 <fax--> I think its a lexer
20:29:38 <chessguy> on icc (for chess), i can just do 'follow *' to always find the next top game
20:29:39 <fax--> yeah
20:29:44 <yawgnimeh> 1 parsec = how many lightyears?
20:29:45 <fax--> its still hard :|
20:29:54 <greentea> yawgnimeh: 3.2?
20:29:59 <fax--> i thought parsec was a 2D..
20:30:07 <SamB> yawgnimeh: well, light years, like sliced bread, do not give very good error messages
20:30:12 <dibblego> ?where plugins
20:30:13 <lambdabot> I know nothing about plugins.
20:30:17 <dibblego> ?where hs-plugins
20:30:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
20:30:18 <SamB> so I'd say you need a lot of light years to replace parsec!
20:30:20 <fax--> oh it is just length
20:30:30 <yawgnimeh> lol!
20:30:30 <narain> "1 Parsec = 3.26163626 light years"
20:30:37 <narain> google++
20:30:49 <yawgnimeh> @karma+ narain
20:30:49 <lambdabot> narain's karma raised to 3.
20:31:11 <yawgnimeh> @karma+ greentea
20:31:12 <lambdabot> greentea's karma raised to 2.
20:31:16 <SamB> @google parsec in light years
20:31:17 <lambdabot> 1 Parsec = 3.26163626 light years
20:31:20 <narain> seriously, you just type "1 parsec in light years" and it comes back with that
20:31:31 <narain> oh hey good lambdabot
20:31:33 <SamB> narain: or "parsec in light years"
20:31:38 <narain> yawgnimeh: thanks
20:31:51 <yawgnimeh> @google lbs to megagrams
20:31:51 <sorear> yawgnimeh: 2.6 IIRC
20:31:51 <sorear> @goo 1 parsec in lightyears
20:31:53 <sorear> @bot
20:31:53 <lambdabot> http://issweb.ci.austin.tx.us:5151/~aeservices/spec_detail/stdfiles/ss/232s081800.rtf
20:31:54 <narain> @go pi parsec in light years
20:31:54 <lambdabot> 1 Parsec = 3.26163626 lightyears
20:31:54 <lambdabot> :)
20:31:55 <lambdabot> pi Parsec = 10.2467325 light years
20:31:55 <SamB> yeah. someone added caculator support to my google plugin a while back ;-)
20:31:59 <sorear> bah.
20:32:01 <sorear> @karma- lag
20:32:01 <lambdabot> lag's karma lowered to -4.
20:32:25 <Cale> @go kilopounds to tons
20:32:27 <lambdabot> http://www.unitconversion.org/weight/kilopounds-to-tons-assay-uk-conversion.html
20:32:35 <narain> @go kilopounds in tons
20:32:36 <lambdabot> http://www.unitconversion.org/weight/kilopounds-to-tons-assay-uk-conversion.html
20:32:53 <yawgnimeh> @google amu to gram
20:32:55 <lambdabot> http://www.newton.dep.anl.gov/askasci/phy99/phy99502.htm
20:32:55 <lambdabot> Title: AMU to Grams
20:33:18 <yawgnimeh> @google phi
20:33:19 <narain> sorear: lag has karma?!
20:33:20 <lambdabot> http://goldennumber.net/
20:33:20 <lambdabot> Title: Phi: 1.618. The 'phinest' source to the golden section, golden mean, divine prop ...
20:33:21 <dibblego> why doesn't hs-plugins build? src/AltData/Typeable.hs:452:0:    parse error (possibly incorrect indentation)
20:33:54 <narain> hmm, someone who joins by the nick of "lag" is going to have to dig him/herself out of a big karma hole
20:34:27 <sorear> @karma- lag
20:34:27 <lambdabot> lag's karma lowered to -5.
20:34:30 <yawgnimeh> everyone should type @karma- lag all at the same time
20:34:31 <SamB> @karma java
20:34:32 <lambdabot> java has a karma of -16
20:34:34 <SamB> @karma Java
20:34:35 <lambdabot> Java has a karma of -2
20:34:40 <SamB> @karma JAVA
20:34:40 <lambdabot> JAVA has a karma of 0
20:34:48 <narain> yawgnimeh: that's funny, searching for "phi" turns up "the golden ratio = 1.61803399"
20:34:56 <dibblego> dons, you about?
20:35:11 <yawgnimeh> google is great
20:35:22 <kc5tja> @karma forth
20:35:23 <lambdabot> forth has a karma of 0
20:35:26 <narain> @karma
20:35:26 <lambdabot> You have a karma of 3
20:35:30 <sorear> @karma
20:35:30 <lambdabot> You have a karma of 24
20:35:36 <yawgnimeh> @google 40 choose 20
20:35:37 <SamB> @quote forth
20:35:37 <lambdabot> 40 choose 20 = 137,846,528,820
20:35:37 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
20:35:37 <lambdabot> of insight hits and it all makes sense.
20:35:41 <yawgnimeh> GODLY
20:35:43 <kc5tja> @karma
20:35:44 <lambdabot> You have a karma of 0
20:35:50 <SamB> @quote forth
20:35:50 <lambdabot> SamB says: Boy, point-free Arrows are worse than Forth...
20:35:53 <kc5tja> Hey, someone took my (only) karma point!
20:35:54 <SamB> @quote forth
20:35:54 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
20:35:55 <lambdabot> of insight hits and it all makes sense.
20:36:02 <SamB> kc5tja++
20:36:04 <lag> @karma
20:36:05 <lambdabot> You have a karma of -5
20:36:11 <sorear> lag--
20:36:13 <narain> well that was fun
20:36:18 <yawgnimeh> @karma
20:36:18 <lambdabot> You have a karma of 0
20:36:26 <SamB> @quote back
20:36:27 <lambdabot> shapr says: Windows users are like the wives of alcoholics, they'll take any amount of abuse and come right back.
20:36:32 <SamB> @quote back
20:36:32 <lambdabot> shapr says: Windows users are like the wives of alcoholics, they'll take any amount of abuse and come right back.
20:36:33 <dibblego> anyone have any idea why hs-plugins 1.0-rc0 won't compile? src/AltData/Typeable.hs:452:0: parse error (possibly incorrect indentation)
20:36:35 <SamB> @quote back
20:36:35 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
20:36:36 <lambdabot> of insight hits and it all makes sense.
20:36:40 <sorear> @karma audreyt
20:36:41 <lambdabot> audreyt has a karma of 330
20:36:41 <SamB> @quote insight
20:36:41 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
20:36:41 <lambdabot> of insight hits and it all makes sense.
20:36:43 <sorear> dibblego: yeah
20:36:51 <SamB> @quote flash
20:36:51 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
20:36:51 <lambdabot> of insight hits and it all makes sense.
20:36:55 <SamB> @quote sense
20:36:56 <lambdabot> gmh33 says: Haskell makes so much more sense now and all I did was figure out the typing thing
20:36:59 <SamB> @quote sense
20:37:00 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
20:37:00 <lambdabot> of insight hits and it all makes sense.
20:37:05 <dibblego> sorear, care to share?
20:37:07 <SamB> @quote typing
20:37:08 <lambdabot> orbitz says: i don't know what the problem is, i'm typing fine, all you crazies are hiting the wron gbuttons everywhere
20:37:11 <SamB> heh
20:37:19 <yawgnimeh> @quote one liner
20:37:20 <lambdabot> No quotes for this person. stty: unknown mode: doofus
20:37:29 <yawgnimeh> @quote liner
20:37:30 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
20:37:43 <SamB> @quote liner
20:37:43 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
20:37:44 <kc5tja> HAHA!  That's awesome!
20:37:46 <SamB> hmm.
20:37:50 <kc5tja> A one pager!
20:38:04 <SamB> @quote JohnMeacham
20:38:05 <lambdabot> JohnMeacham says: Type theory makes totally awesome material for bar room shit talk.
20:38:20 <yawgnimeh> lol
20:38:33 <yawgnimeh> @quote lambdabot
20:38:34 <lambdabot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
20:38:34 <lambdabot> UTF8&s=books  <lambdabot> http://tinyurl.com/root7
20:38:49 <dino-> I will say this, vaguely in its defense: that XSLT "language" is somewhat functionalish.
20:39:11 <dino-> But, programming in XML tags? Minus several million points.
20:39:14 <yawgnimeh> haha what a coincidence "root7"
20:39:30 <narain> XSLT's semantics aren't bad, it's the syntax that's... unspeakable
20:39:48 <syntaxfree> @hoogle assert
20:39:49 <lambdabot> Control.Exception.assert :: Bool -> a -> a
20:39:49 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
20:39:49 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
20:39:57 <jcreigh> I have a rule: Never program in a language the has to be *proved* turing complete.
20:39:57 <syntaxfree> isn't XSLT xml itself?
20:40:24 * sorear vaguely thought the xml lexer was turing complete
20:40:25 <syntaxfree> hmm. don't all language have to be proven turing-cmplete at some point?
20:40:27 <narain> XSLT is a programming language for transforming XML, encoded in XML
20:40:36 <syntaxfree> narain: yes, that was what I meant.
20:40:39 <narain> yes
20:40:44 <fax--> grrrr
20:40:48 <jcreigh> syntaxfree: with some, it's immediately obvious. Not with XSLT.
20:41:01 <SamB> jcreigh: what if it *isn't* turing complete?
20:41:13 <jcreigh> SamB: what, XSLT?
20:41:21 <syntaxfree> well, Haskell is immediately obvious because someone proved the lambda calculus before.
20:41:23 <SamB> I was thinking of Epigram, actually
20:41:38 <syntaxfree> is Control.Exception.assert written in Haskell?
20:41:49 <sorear> syntaxfree: sorta
20:41:57 <sorear> assert True x = x
20:42:03 <QtPlatypus> jcreigh: So I guess your not going to be programing in sendmail config files?
20:42:05 <sorear> with no False equation
20:42:12 <syntaxfree> ok, but it returns a line number. What's with the introspective magic?
20:42:28 <sorear> syntaxfree: but assert has ultra-special magic built in to the compiler :(
20:42:29 <sjanssen> syntaxfree: assert is indeed magical
20:42:39 <dibblego> ?where fps
20:42:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
20:42:45 <syntaxfree> hmm. Maybe there should be a "Magic" module.
20:43:03 <syntaxfree> nah, it wouldn't make sense.
20:43:09 <sorear> dibblego: if you have 6.6, fps is not needed for lambdabot (and will mess up your install)
20:43:25 <dibblego> cabal reckons I need it
20:43:35 <sorear> dibblego: how old is your lambdabot?
20:43:42 <dibblego> 4.0.1
20:43:46 <dino-> I'm sure many people here have heard someone say they know "HTML programming"
20:44:07 <dibblego> should I use the darcs version of lambdabot?
20:44:09 <sorear> dibblego: use the .cabal.ghc-6.6 file.  or just get a fresh pull
20:44:15 <dibblego> ah ok
20:44:16 <dino-> By which I mean said person is talking about writing HTML tags.
20:44:16 <jcreigh> dino-: I cringe everytime I hear that...
20:44:17 <sorear> dibblego: yeah, probably
20:44:29 <glguy> someone care to give their explaination of the difference in a recursive language and a recursively enumerable one?
20:44:51 <sorear> glguy: recursive - you can always say "valid" or "invalid"
20:45:26 <cpst> glguy: a recursive language is one that a turing machine can recognize
20:45:33 <sorear> glguy: recursively enumerable - you can always say "valid", but you might never get an answer for an invalid language
20:45:48 <sjanssen> dons: statusbar done yet? :P
20:45:49 <narain> invalid string, you mean
20:45:56 <sorear> yeah
20:46:06 <cpst> glguy: a recursively enumerable language is one whose valid words will be outputted by a Turing machine that need not necessarily terminate
20:46:11 <sorear> glguy: for instance, the set of halting programs is recursively enumerable, because you will always eventually know if the program halts
20:46:32 <sorear> glguy: but it's not recursive, because if it doesn't halt you can't know in general
20:46:34 <fax--> humpf
20:46:44 <dibblego> ?where arrows
20:46:45 <lambdabot> http://www.haskell.org/arrows/
20:47:47 <sorear> dibblego: you are the first to try using hs-plugins 6.6 (new) with released lambdabot (old).  You have been warned.
20:48:04 <dibblego> sorear, I'm about to give up
20:48:27 <sorear> dibblego: why?  you haven't gotten to the fun part yet!
20:48:46 <dibblego> because arrows is a bunch of make files
20:48:51 <sorear> dibblego: you are either very fast or very unlucky.  getting dependencies should be slow and easy.
20:49:10 <dibblego> I just know that building lambdabot is extremely painful
20:49:10 <sorear> IIRC arrows are in 6.6/extralibs
20:49:15 <dibblego> so I know to give up early
20:49:30 <sorear> it's not hard I thought
20:49:42 <dibblego> I have only ever done it once successfully
20:50:00 <sorear> you do have all of 6.6 ?
20:50:09 <dibblego> not sure now actually
20:50:17 <dibblego> come to think of it, probably not
20:51:05 <dibblego> silly old vmware
20:51:06 <sorear> ok, who decided to pull extralibs out of the 6.6 download.
20:51:08 <sorear> ?
20:51:17 <sorear> super mega negative karma awaits
20:51:25 <bd_> it's a seperate download now or something >.>;
20:51:39 <bd_> but hasn't it been that way since 6.6 was released
20:51:40 <bd_> ?
20:51:48 <sorear> bd_: which NOBODY thinks to install
20:51:51 <dibblego> yes, it just means everybody has their GHC download in two separate threads now
20:51:57 <sorear> bd_: separate downloads BAD
20:52:09 <sorear> jigdo and/or torrent FTW
20:52:22 <bd_> heh
20:52:39 <SamB> yeah
20:52:42 <syntaxfree> error lines from assert aren't that useful.
20:52:44 <bd_> I do think mtl should be in the base install at least
20:52:51 <sorear> at the very least GHC should be rigged to generate an immediate fatal error if you try to use it without all the extralibs.
20:52:51 <SamB> it definately seems to be an unhelpful way to be
20:52:52 <bd_> since approximately everything needs it
20:52:57 <SamB> heh
20:53:15 <syntaxfree> it tells me the line where "assert" was called directly, not the function that called the function that calls assert.
20:53:15 <bd_> sorear: I thought the point of splitting out extralibs was to /remove/ GHC's dependencies on that stuff :)
20:53:22 <SamB> I think maybe they should have a ghc6.6-unusable package for the version without extralibs
20:53:24 <bd_> sorear: maybe a warning would be goof though
20:53:26 <syntaxfree> so I have to trace where the assertion actually failed somehow.
20:53:41 <bd_> -fallow-useless-configuration?
20:53:53 <sorear> syntaxfree: ghc --make myprog.hs -prof -auto-all ; ./myprog +RTS -xc
20:53:55 <SamB> then ghc6.6 would depend on ghc6.6-unusable and ghc6.6-extralibs
20:54:07 <sorear> syntaxfree: that's the magic incantation for "give me a backtrace"
20:54:42 <sorear> yes, special options are needed both at compile time *and* runtime
20:54:59 <sorear> nobody reads the GHC manual straight through anymore :(
20:56:00 * syntaxfree pushes code back and forth between dsl-y modules.
20:56:06 <SamB> considering how the backtraces are implemented, I think it should be fairly obvious why you need to build with profiling ;-)
20:56:17 <yawgnimeh> has the Ctrl-C been fixed in ghci under windows
20:56:25 <SamB> (it uses the cost center stack, since the CPU stack is useless)
20:57:39 <dibblego> yay, 3 hours to build GHC 6.6 last I tried (with extralibs)
20:57:52 <yawgnimeh> nice
20:57:55 <sorear> SamB: how is syntaxfree expected to know that it uses the scc stack?
20:58:19 <sorear> <- 1.5 hourse to build GHC 6.7.20070223 last I tried (with extralibs)
20:59:56 <dmead> :o
20:59:58 <dmead> thats it?
21:01:16 <sorear> yea, 6.7 builds a lot faster
21:01:43 <sorear> it might have something to do with the fact that stage2 no longer is built with -fvia-C
21:02:09 <sorear> (3% perf increase, 100% compile time increase vs. just -O)
21:02:54 <sorear> @users
21:02:55 <lambdabot> Maximum users seen in #haskell: 339, currently: 298 (87.9%), active: 35 (11.7%)
21:03:15 <dmead> ahhh
21:03:17 <dmead> cool ;o
21:04:46 <mwc> sorear, that mean the kickass new native gen is up and running in 6.7?
21:06:54 <ikegami--> hmm, I'm catched in trap for this short program
21:07:03 <sorear> mwc: it's been that good for a long time.  it's just that the Simons have decided -fvia-C is too expensive for day-to-day use.  -O used to imply -fvia-C, now it doesn't.
21:07:08 <ikegami--> main = fdRead stdInput 1 >>= \(c, _) -> putStr c main = fdRead stdInput 1 >>= \(c, _) -> putStr c
21:07:10 <sorear> ikegami--: TRAP?
21:07:15 <ikegami--> oops
21:07:43 <sorear> why are you using fdRead?
21:07:50 <mwc> sorear, indeed, I've been using -O -fasm for a while. I thought they'd done some work on it recently
21:08:06 <mwc> cool that it's not the default in -O now
21:08:31 <fax--> @type Data.HashTable.lookup
21:08:32 <ikegami--> at first I tried getChar, and I realized that it requires the newline
21:08:33 <lambdabot> forall key val. Data.HashTable.HashTable key val -> key -> IO (Maybe val)
21:08:40 <sorear> mwc: the Downside - #1151.  -fvia-C broke and no-one noticed.
21:08:41 <fax--> @type Maybe
21:08:43 <lambdabot> Not in scope: data constructor `Maybe'
21:08:46 <sorear> ikegami--: are you using UNIX?
21:08:48 <fax--> >:@
21:08:50 <ikegami--> yes
21:09:09 <sorear> ikegami--: the newline wait is in the kernel, nothing you can do short of reconfiguring the terminal will avoid it
21:09:23 <sorear> ikegami--: to reconfigure the terminal, use hSetBuffering stdin NoBuffering
21:09:24 <ikegami--> I see
21:09:46 <monochrom> Or use stty and/or ioctl :)
21:09:49 <sorear> standard H98 even!
21:10:03 <ikegami--> very portable
21:10:04 <sorear> monochrom: termios >> ioctl :)
21:10:07 <mwc> What's the point of -fvia-C again?
21:10:17 <ikegami--> thanks
21:10:17 <monochrom> Oh! Forgot termios.
21:10:32 <mwc> GCC knows more intricacies of given CPU's and can pick operations with better scheduling?
21:10:35 <sorear> mwc: Glasgow folks are really lazy and for a while thought they could never beat GCC
21:10:47 <sorear> but it turns out gcc sucks
21:10:52 <fax--> hmm
21:11:04 <fax--> how do I change IO (Maybe Float) into Maybe Float?
21:11:17 <monochrom> There was a time -fasm output much slower code.
21:11:30 <sorear> fax--: do you absolutely, positively know what you are doing?
21:11:41 <mwc> sorear, it would seem to me that much better native code could be generated, especially on something like IA64.
21:11:48 <fax--> no
21:11:49 <sorear> fax--: dont. use >>= instead
21:11:52 <monochrom> There was also a time we needed -fvia-fortran and -fvia-cobol
21:12:02 <fax--> ill look it up, cheers
21:12:07 <mwc> hahaha
21:12:10 <mwc> -fvia-cobol
21:12:18 <monochrom> hehehehe
21:12:19 <sorear> @remember monochrom There was also a time we needed -fvia-fortran and -fvia-cobol
21:12:19 <sorear>  
21:12:19 <lambdabot> Done.
21:12:39 <fax--> @hoogle >>=
21:12:39 <lambdabot> Prelude.(>>=) :: Monad m => m a -> (a -> m b) -> m b
21:13:30 <sorear> Prelude> getLine >>= (\line -> putStrLn (line ++ ", muahahaha!"))
21:13:30 <sorear> foo
21:13:30 <sorear> foo, muahahaha!
21:13:40 <sorear> ^^^ example of use
21:13:53 <fax--> aha
21:13:54 <mwc> -fvia-cobol would be a pretty good Apr1 joke
21:14:15 <sorear> it creates an action by composing two actions, where the second depends on the value returned by the first
21:14:32 <sorear> it is the mechanism do-notation desugars to
21:14:50 <sorear> @undo do { value <- action1 ; action2 value }
21:14:50 <lambdabot> action1 >>= \ value -> action2 value
21:15:09 <sorear> hmm.  should undo do eta-contraction?
21:15:10 * narain sees "foo, muahahaha!" and imagines James Bond captured by a demented computer scientist
21:15:11 <glguy> LaTeX is \command{argument}[optional argument] .. no?
21:15:32 <sorear> \command[optional argument]{argument} IIRC
21:16:09 <glguy> ah, cool
21:16:28 <narain> \documentclass[a4paper]{article}
21:16:46 <narain> \begin{table}[cc]
21:16:49 <narain> hmm
21:17:05 * sorear thought that was a HOF for a moment
21:17:56 <narain> never mind, it's actually \begin{table}{cc}
21:18:05 <glguy> whatever the order is, \FOR[comment]{i = 1 to n} worked
21:18:18 <sorear> idiomicity aside, does TeX even support HO-ness?
21:18:34 <narain> what would that entail?
21:18:43 <sorear> \foldr{foo}
21:19:06 <sorear> passing and returning macros
21:21:51 <dgriffi3> > take 1 $ nub [1..]
21:21:51 <narain> you can have recursive macros but probably not HO macros
21:21:52 <lambdabot>  [1]
21:23:13 <narain> neat use of recursive macros: http://www.tug.org/texshowcase/diminuendo.pdf
21:24:09 <fax--> that is cool
21:24:51 <fax--> hm I just cant get this to work
21:25:09 <sorear> @parse
21:25:10 <lambdabot> Maybe you meant: part paste
21:25:14 <sorear> @paste
21:25:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:25:17 <fax--> does it make sense to use a CharParser with state (IO (HashTable String Float)) to store the values of variables?
21:25:28 <sorear> no
21:25:49 <fax--> do I need to just drop the IO and use HashTable alone (because its mutable)?
21:25:55 <sorear> IO a is an action to produce a value, it is not the value itself
21:26:05 <fax--> oh right
21:26:11 <sorear> fax--: that is what you would do if you could
21:26:22 <fax--> so the state being (HashTable String Float)
21:26:25 <fax--> should be fine?
21:26:31 <sorear> fax--: but parsec needs to backtrack to find the right parse
21:26:36 <fax--> ahhhhh
21:26:43 <sorear> fax--: and to backtrack parsec needs the old state
21:27:02 <sorear> fax--: but after you update a hashtable, the old one no longer exists
21:27:12 <fax--> aha, I see now
21:27:17 <fax--> I guess ill try with a Map then
21:27:38 <sorear> fax--: it would make sense to use a hashtable and not update it during the parse, but unfortunately Haskell does not support immutable hashtables.
21:27:53 <bd_> sorear: What about a hashtable built on Data.Array.Diff?
21:28:11 <bd_> seems like it might be a useful thing to have
21:29:17 <sorear> bd_: I said 'support', not 'need' :)
21:29:23 <syntaxfree> :t error
21:29:26 <lambdabot> forall a. [Char] -> a
21:29:35 <bd_> :)
21:29:41 <syntaxfree> hmm. It's not working in a case expression.
21:29:43 <sorear> bd_: well, D.A.D hashtables aren't supported either
21:29:48 <sorear> syntaxfree: how so?
21:29:54 <bd_> D..D?
21:29:57 <bd_> er, D.A.D*
21:30:13 <sorear> > case True of True -> error "Hi" ; False -> error "unexpected"
21:30:15 <lambdabot>  Exception: Hi
21:31:21 <sorear> > ((\x -> case True of True -> error "Hi" ; False -> error "unexpected") :: Int -> Int) (error "foo")  -- beware of the optimizer
21:31:22 <lambdabot>  Exception: Hi
21:31:25 <hpaste>  syntaxfree pasted "here I come again, embarass myself with stupid errors" at http://hpaste.org/860
21:31:45 <syntaxfree> I'm too sleepy and want to get at least this module working right before going to sleep!
21:31:54 <yawgnimeh> aw
21:31:56 <yawgnimeh> go to sleep!
21:32:09 <sorear> > ((\x y -> case y of True -> error "Hi" ; False -> error "unexpected") :: Int -> Int -> Int) (error "foo") True  -- beware of the optimizer
21:32:10 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
21:32:11 <yawgnimeh> you will have annotations in the morning
21:32:18 <sorear> > ((\x y -> case y of True -> error "Hi" ; False -> error "unexpected") :: Int -> Bool -> Int) (error "foo") True  -- beware of the optimizer
21:32:19 <lambdabot>  Exception: Hi
21:32:26 <yawgnimeh> nice!
21:32:29 * sorear gives up
21:32:38 <yawgnimeh> don't be silly
21:32:50 <narain> syntaxfree: are you sure you don't want  error (...)?
21:32:59 <syntaxfree> hahaha. true.
21:33:00 <syntaxfree> sorry :)
21:33:13 <syntaxfree> jesus, I wish I could delete my hpastes.
21:33:17 <syntaxfree> they freaking embarass me.
21:33:23 <yawgnimeh> me too
21:33:25 <fax--> sorear: got it to work with map, thanks again :D
21:33:47 <sorear> syntaxfree: so, you want to get a paste-delete password?
21:33:49 <sorear>  :)
21:34:15 <sorear> talk to glguy, mine is non-replicable
21:34:21 <narain> generate a random password at paste time
21:34:35 <yawgnimeh> > replicate 1 10
21:34:37 <lambdabot>  [10]
21:34:43 <yawgnimeh> :)
21:34:51 <sorear> > (:[]) 10
21:34:53 <lambdabot>  [10]
21:34:57 <narain> > return 10 :: [Int]
21:34:59 <lambdabot>  [10]
21:35:07 <yawgnimeh> > [10]
21:35:09 <lambdabot>  [10]
21:35:10 <sorear> > pure 10 :: [Int]
21:35:19 <yawgnimeh> :t pure
21:35:22 <narain> tmtowtdi!
21:35:22 <lambdabot>     Ambiguous occurrence `pure'
21:35:22 <lambdabot>     It could refer to either `pure', imported from Control.Arrow
21:35:28 <sorear> dumb bot
21:35:35 <yawgnimeh> @karma+ lambdabot
21:35:35 <lambdabot> lambdabot's karma raised to 42.
21:35:36 <sorear> > Control.Applicative.pure 10 :: [Int]
21:35:37 <lambdabot>  [10]
21:35:57 <narain> 42? ok, nobody karma+ the lambdabot ever again
21:36:13 <yawgnimeh> > reverse "tmtowtdi!"
21:36:15 <lambdabot>  "!idtwotmt"
21:36:25 <yawgnimeh> hmm
21:36:44 <yawgnimeh> @. run karma+ yawgnimeh
21:36:44 <lambdabot>  Parse error
21:36:53 <yawgnimeh> @run karma+ yawgnimeh
21:36:53 <narain> ?help .
21:36:54 <lambdabot>   Not in scope: `yawgnimeh'
21:36:54 <lambdabot> . <cmd1> <cmd2> [args].
21:36:54 <lambdabot> . [or compose] is the composition of two plugins
21:36:54 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
21:37:06 <yawgnimeh> @. karma+ yawgnimeh
21:37:07 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "yawgnimeh"
21:37:14 <yawgnimeh> shutup lambdabot
21:37:18 <lambdabot> nice try
21:37:23 <yawgnimeh> thanks
21:47:47 <fax--> hmm
21:53:00 <glguy> is there a common convention to differentiate |x| when used for absolute value and when used for size?
21:53:15 <glguy> (I'll be needing both)
21:53:56 <dibblego> ?where shootout
21:53:57 <lambdabot> http://shootout.alioth.debian.org/
21:55:48 <sorear> glguy: they are normally considered the same concept
21:56:00 <sorear> glguy: absolute value is-a-kind-of size
21:56:03 <Cale> Maybe the size generalisation would be called norm
21:56:41 <dons> dibblego: you were looking for me?
21:57:04 <dibblego> dons, yeah I was trying to build lambdabot but sorear helped me out (compiling GHC 6.6 atm)
21:57:08 <dons> sjanssen: not done. been in a meeting. i'm actually rewriting the core data type as a seperate pure lib, so we can do some better model/view seperation (and QC the workspace code..)
21:57:14 <dons> ok good.
22:00:06 <fax--> I just wondering if you want to run a parser twice, but retain the state,
22:00:27 <dons> ?users
22:00:27 <fax--> instaed of returning Float, i would return a tuple of Float and my state
22:00:27 <lambdabot> Maximum users seen in #haskell: 339, currently: 286 (84.4%), active: 34 (11.9%)
22:00:36 <fax--> or is there a more sensible way?
22:00:38 <nornagon> ooooh.
22:00:44 <nornagon> max users went up!
22:00:47 <fax--> ive read over the parsec tutorial a few times but I dont see anything
22:01:52 <nornagon> @. karma+ run "Haskell"
22:01:53 <lambdabot> "Haskell"'s karma raised to 1.
22:02:01 <nornagon> @karma- Haskell
22:02:02 <lambdabot> Haskell's karma lowered to 9.
22:02:06 <nornagon> doh
22:02:10 <nornagon> @karma+ Haskell
22:02:11 <lambdabot> Haskell's karma raised to 10.
22:02:14 <sorear> @kmarma- nornagon
22:02:14 <lambdabot> nornagon's karma lowered to 4.
22:02:15 <nornagon> @karma- "Haskell"
22:02:15 <lambdabot> "Haskell"'s karma lowered to 0.
22:02:18 <sorear> @kmarma+ nornagon
22:02:18 <lambdabot> nornagon's karma raised to 5.
22:02:28 <nornagon> karmafest
22:04:36 <hpaste>  fax pasted "state accumulation" at http://hpaste.org/861
22:05:03 <fax--> I was just wondering if there is a way to get the new modified state from the parser
22:05:14 <fax--> (Before I change the return type to be a type of Float and state)
22:08:13 <christine_c> hi people
22:08:33 <fax--> hi
22:08:38 * fax-- goes off and does it the ugly way
22:08:44 <fax--> er..
22:09:09 <christine_c> who knows neural nets here?
22:09:15 <christine_c> i want to ask something
22:09:15 <araujo> has anybody used Haskell for cgi scripts here?
22:09:19 <fax--> I know the very basics..
22:09:34 <fax--> (from several failed implementations a couple of years ago)
22:09:52 <fax--> so I am probably not a good person to ask :S
22:09:54 <Cheery> Do you know some channel for discussing about user interfaces?
22:10:24 <christine_c> good.....fax....do you know some sites where talks about neural implemented in C, that really talks about how it is being program
22:10:26 <christine_c> please
22:11:03 <araujo> Cheery, you can here, if they are written on Haskell :-)
22:11:26 <fax--> christine_c: I dunno start here maybe http://en.wikipedia.org/wiki/Neural_network and read the external links
22:11:48 <fax--> once you know how XOR works thats a good start
22:12:50 <Cheery> araujo: well, I'd like to actually know some general ideas which have been practically good.
22:13:23 <Cheery> I'm not looking for axioms, I'm looking for theories.
22:13:25 <greentea> Cheery: If you're talking Web-based interfaces, Jakob Nielsen's site might be a good place to start.
22:14:19 <greentea> Athough the ideas are probably, at least in part, applicable to UIs more generally.
22:24:39 <Cale> tmoertel: um, I'm seeing 100% packet loss to blog.moertel.com
22:27:13 <fax--> urk
22:27:20 <fax--> annoying when it works in ghci but it work compile with ghc
22:27:51 <Cale> fax--: compile with --make?
22:28:02 <fax--> hey that worked :D
22:28:47 <fax--> so is it just a matter of finding the right imports?
22:30:41 <fax--> I finally got a calculator now http://hpaste.org/862 :D
22:30:51 <fax--> you can do "x := 5" "1+x*2" etc..
22:31:02 <fax--> im sure the code is absolutly awful though
22:31:08 <fax--> at least it works
22:38:22 <tmoertel> Cale: yeah, my secondary line just went down for a while.
22:38:29 <tmoertel> Cale: it should be back up now.
22:39:25 <Cale> http://programming.reddit.com/info/18mm1/comments/c18psb?context=5
22:39:27 <lambdabot> Title: Directory-tree printing in Haskell, part two: refactoring (reddit.com), http://tinyurl.com/2yh58n
22:41:28 <tmoertel> Cale: ha!  You actually "stole" my topic for part 3: http://blog.moertel.com/articles/2007/03/07/directory-tree-printing-in-haskell-part-two-refactoring#comment-403
22:41:33 <Cale> heh
22:57:32 <ski> hm .. is there a reason for the 'unsafe' in 'unsafeInterleaveIO' ?
22:57:46 <Cale> It's unsafe :)
22:57:58 <ski> in what way ?
22:58:16 <Cale> The produced values aren't themselves referentially transparent, for one.
22:58:55 <Cale> The side effects can occur in an arbitrary order
22:58:57 <ski> can't one just attribute that to the general nondeterminism of IO ?
22:59:09 <ski> the same can be said about threads, no ?
22:59:39 <Cale> Well, sure, but this is something which has a pure type.
23:00:11 <Cale> x <- unsafeInterleaveIO k -- I mean the x in that.
23:00:13 <ski> one could possibly think of 'unsafeInterleaveIO' as scheduling a thread that will compute the value
23:00:56 <ski> i'm not sure that 'x' is side-effecting ..
23:01:02 <Cale> The order in which you look at the components of the value can affect its value.
23:01:08 <monochrom> unsafeInterleaveIO (throw some exception)   will throw an exception at the most unexpected place.
23:01:29 <ski> can one come up with an example that destroys the declarativity, by using 'unsafeInterleaveIO' ?
23:01:56 <ski> exceptions, too, are attributed to nondeterminism of IO, iirc
23:02:25 <Cale> I mean, you're still in IO, in some sense, but you get to pass that "pure" value off to other functions, and it has calls into IO embedded in it.
23:02:41 <ski> Cale : hm .. well it is possible that one could argue both ways .. hmm
23:03:21 <ski> (well, i don't care whether the implementation does impure things under the hood .. what matters is the semantics)
23:03:49 <Cale> well, the semantics of that purely-typed value are nondeterministic then.
23:04:03 <Cale> the one which is passed to the second parameter of bind
23:04:52 <ski> i'm thinking we can attribute this nondeterminism to IO, and claim the value is still pure  (but i'm not sure .. i'd like to be refuted .. or affirmed)
23:05:27 <ski> 'unsafeInterleaveST' would, possibly, btw, be another matter
23:06:02 <ski> since one can probably more easily say "this is the semantics of ST" and then claim 'unsafeInterleaveST' breaks it
23:06:36 <ski> (s/breaks it/breaks declarativity or it/)
23:06:46 <ski> do you see what i'm trying to argue ?
23:07:11 <monochrom> I see that you're trying to argue that IO behaviour is completely arbitrary.
23:07:58 <ski> hmm
23:08:11 <mwc> hey Cale, I got my masters program at Waterloo Math today
23:08:18 <Cale> mwc: cool :)
23:08:26 <Cale> *Main> do xs <- funkyList; print (reverse xs)
23:08:27 <Cale> [0,1,2,3,4]
23:08:27 <Cale> *Main> do xs <- funkyList; print xs
23:08:27 <Cale> [0,1,2,3,4]
23:08:39 <ski> ok, it seems it depends on how much stuff one puts into IO ..
23:08:46 <ski> (monochrom : ty)
23:08:48 <mwc> I have two profs offering me positions in control theory.
23:09:02 <mwc> Maybe I'll get yo use some Yampa :)
23:09:27 <Cale> The interesting thing here is that funkyList is actually producing the same list every time :)
23:09:59 <Cale> I suppose you can look at it as a form of nondeterminism
23:10:03 <ski> funkyList = ?
23:10:08 <Cale> funkyList :: IO [Integer]
23:10:08 <Cale> funkyList = do
23:10:08 <Cale>     r <- newIORef 0
23:10:08 <Cale>     let v = unsafeInterleaveIO $ do k <- readIORef r
23:10:08 <Cale>                                     writeIORef r (k+1)
23:10:10 <Cale>                                     return k
23:10:11 <Cale>     replicateM 5 v
23:10:34 <mauke> haha
23:10:41 <robreim> > let unsafeReadIORef = unsafeInterleaveIO . readIORef in do { ref <- newIORef 1; x <- unsafeReadIORef ref; writeIORef ref 2; return x}
23:10:42 <lambdabot>   Not in scope: `writeIORef'
23:11:26 <robreim> boo hoo. Oh well, that returns "2" in GHCi. Probably not what you'd want.
23:11:31 <monochrom> IO disabled.
23:12:38 <sjanssen> ski: information about evaluation order can leak when you use unsafeInterleaveIO
23:12:40 <ski> (if you don't want it that way, then don't write that way)
23:12:52 <Cale> You have to really complicate your view of the type [Integer] in order to understand that program.
23:13:06 <ski> IO is always complicated
23:13:16 <ski> sjanssen : elaborate ?
23:13:19 <Cale> But it's not the IO [Integer] which is complicated here
23:13:29 <Cale> but the [Integer] value produced
23:13:32 <sjanssen> and I'm sure you could somehow violate referential transparency
23:13:53 <ski> Cale : hm .. there's is a point there, i think .. but i think the same holds for exceptions
23:13:54 <Cale> absolutely
23:14:12 <Cale> er
23:14:27 <Cale> (I meant to sjanssen)
23:14:36 <ski> (i.e. you *could* approximate it by just blaming IO .. but if you want more accuracy, you need to reason about evaluation order)
23:14:48 <Cale> Well, exceptions you can at least reasonably model as _|_
23:15:03 * ski nods
23:15:07 <sjanssen> ski: using a function like Cale's funkyList, zipWith (+) xs ys might be different from zipWith (+) ys xs
23:15:16 <Cale> Here, you have values which are in a superposition of states.
23:16:18 <sjanssen> many of the rules for programming with unsafePerformIO apply to unsafeInterleaveIO
23:16:19 <ski> (sjanssen : if we take the "blame IO" path, then that's because in the two tests, the calls to 'funkyList' returned different lists, because of IO nondeterminism)
23:16:41 <ski> (hm .. superposition .. interesting)
23:16:43 <Cale> *Main> do xs <- funkyList; print $ zipWith (-) (tail xs) xs
23:16:43 <Cale> [-1,2,1,1]
23:16:46 <Cale> hmm...
23:17:13 <Cale> seems it's 1's thereafter :)
23:17:13 <sjanssen> I'm trying to think of a really nasty example . . .
23:19:57 <Cale> funkify :: [a] -> IO [a]
23:19:58 <Cale> funkify xs = do
23:19:58 <Cale>     r <- newIORef xs
23:19:58 <Cale>     let v = unsafeInterleaveIO $
23:19:58 <Cale>                 do (y:ys) <- readIORef r
23:19:58 <Cale>                    writeIORef r ys
23:20:01 <Cale>                    return y
23:20:02 <Cale>     replicateM (length xs) v
23:20:04 <Cale> heh
23:20:43 <Cale> hmm, perhaps we can extend this to infinite lists...
23:21:01 <monochrom> use mapM instead of replicateM
23:21:06 <robreim> Output combined with unsafeInterleaveIO will never be executed: unsafePutStrLn = unsafeInterleaveIO . putStrLn
23:21:14 <robreim> that's kinda nasty
23:21:35 <monochrom> And moreover if mapM turns out to be too eager, there is always unsafeInterleaveIO at your service! :)
23:21:36 <sjanssen> robreim: you can make it happen with `seq`
23:22:08 <newsham> ?quote unsafe
23:22:08 <lambdabot> Philippa says: plus who wants to get unsafeHead?
23:22:33 <newsham> ?quote unsafe
23:22:34 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
23:22:57 <newsham> hmmm.. was hoping for a quote about simons
23:23:09 <Cale> @paste
23:23:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:24:01 <robreim> sjanssen: true
23:24:02 <hpaste>  Cale pasted "funkify" at http://hpaste.org/863
23:24:09 <sjanssen> Cale: try to reason about the program: funkify xs >>= funkify >>= funkify >>= funkify
23:24:45 <monochrom> hahahahaha
23:25:25 <sjanssen> and then randomly access the elements of the result with !!
23:26:15 <Cale> ugh, this is annoying, how do I get ghci not to automatically print bound results?
23:26:23 <robreim> ski: I guess you could try using unsafeInterleaveIO for everything and see how it works out for you. Maybe you'll find new ways to use it that are much better than strict IO and you can write a paper on it.
23:26:47 <sjanssen> Cale: ; return () at the end should do it
23:27:08 <Cale> parse error on input ;
23:27:21 <Cale> (unless I write a do-block, which isn't what I want)
23:27:27 <sjanssen> right
23:27:36 <monochrom> a do-block will throw away the binding
23:27:39 <Cale> right
23:27:51 <sjanssen> Cale: what if you run ghci with -fno-extended-defaulting
23:27:53 <ski> robreim:
23:27:55 <ski> er
23:28:08 <ski> robreim : heh, why would i want to use it for everything ? :)
23:28:11 <sjanssen> or whatever it is
23:28:15 <Cale> uh
23:28:30 <monochrom> Use GHC 6.4 :)
23:29:23 <sjanssen> Cale: -fno-print-bind-result
23:29:31 <monochrom> nice
23:30:00 <Cale> ahh, much better
23:31:33 <sjanssen> an even better test: funkify [1..10] >>= randomScramble >>= print will always return [1..10]
23:31:43 <sjanssen> if I understand funkify correctly
23:31:57 <robreim> ski: so it could make IO non-deterministic. Correct me if I'm wrong, but I thought you were saying IO could be considered non-deterministic and allowed to be pure?
23:32:24 <Cale> sjanssen: yes.
23:32:35 <dons> sjanssen: i've almost finished a lovely abstract, pure interface to the multiple workspace/window stack model
23:32:40 <sjanssen> that is wicked
23:32:43 <dons> we should even be able to QC the entire thing.
23:32:56 <sjanssen> dons: cool
23:33:23 <ivanm> dons: did you have a look at my project that I sent you?
23:33:23 <sieni> qc == qarbage collection?
23:33:26 <dons> i feel a lot more confident now that we won't end up in an inconsistent state
23:33:31 <dons> ivanm: haven't had time yet.
23:33:34 <dons> sieni: QuickCheck
23:33:46 <ivanm> dons: OK, no rush... I've finished it after all
23:33:49 <Cale> hehe, qarbage :)
23:33:57 <ski> robreim : IO is already nondeterministic (threads) .. and no, i was saying one could possibly attribute the effects of 'unsafeInterleaveIO' to IO, and claim the returned value was pure
23:34:05 <ivanm> dons: just wanted someone with more experience than me to critique my code
23:34:07 <Cale> try and play that in a scrabble game :)
23:34:41 <Cale> ski: but you can still usually have some chance of proving that IO actions have given effects.
23:34:43 <dons> sjanssen: we should have some nice properties to be able to check.
23:34:59 <dons> e.g. a given window exists only ever on one window stack, uniquely
23:35:02 <Cale> ski: like in that randomScramble case :)
23:35:14 <robreim> ski: Oh! Ok then :)
23:35:38 <ski> Cale : yes .. i'm investigating this line of thought since i want to understand 'unsafeInterleaveIO' better (e.g. "how much safer" than 'unsafePerformIO' is it ?)
23:36:03 <Cale> No IO action written without lazy IO would be able to produce that property.
23:36:20 <ski> which property ?
23:36:20 <sjanssen> ski: one thing that unsafeInterleaveIO can't do is the unsafePerformIO+IORef type coercion trick
23:36:39 <Cale> funkify [1..10] >>= randomScramble always giving [1..10]
23:36:57 <Cale> where randomScramble is what it says it is
23:37:10 <sjanssen> Cale: correction, it's only [1..10] when you evaluate the elements in order
23:37:17 <Cale> well, yes
23:37:24 <Cale> funkify [1..10] >>= randomScramble >>= print
23:37:31 <Cale> always printing [1..10] :)
23:37:49 <ski> randomScramble = ?
23:37:58 <Cale> Random permutation of the list.
23:38:04 <int-e> mix the elements of the list without evaluating them
23:38:13 <Cale> right
23:38:46 <ski> since they are forced from left-to-right by 'print', yes ?
23:38:54 <Cale> funkify is able to preemptively undo the nondeterminism of randomScramble
23:38:56 <sjanssen> ski: yes
23:39:00 <Cale> right
23:39:23 <sjanssen> another good one: funkify [1..10] >>= print . reverse
23:39:53 <Cale> well, yeah, but knowing that it's reverse, one could easily write a plain funkify :)
23:40:10 <Cale> (without unsafeInterleaveIO, just reverse the list)
23:40:25 <sjanssen> true
23:41:47 <Cale> hmm, can we perhaps be even more abusive and somehow entice GHC into duplicating the evaluation of one of the list elements?
23:41:55 <vegai> HList developers, are any here?
23:42:10 <vegai> I'm wondering about any upcoming releases
23:42:24 <sjanssen> Cale: it can happen in GHC 6.6 with the threaded rts
23:42:40 <sjanssen> but that's a bug that will be fixed eventually
23:43:13 <Cale> It is theoretically allowed to reevaluate things though.
23:43:31 <Cale> So semantically, that's not so great :)
23:44:45 <int-e> Cale: the SMP paper mentions a primitive called 'once' that would remedy that - I hope it gets implemented.
23:45:02 <sjanssen> int-e: Simon Marlow is already working on it
23:45:11 * sjanssen lurks in #ghc
23:45:38 <bos_> woohoo! i have IPv6 support working in network!
23:46:35 <int-e> Cale: which would be much better than always having to lock thunks on entering them
23:46:52 <ski> (hm .. possibly one could say that we *can* reason declarativly about 'unsafeInterleaveIO', but if we want any usable accuracy, we have to revert to operational reasoning .. ok, so this could be enough grounds to justify the 'unsafe' prefix)
23:46:59 <Vq^> bos_: congrats
23:47:26 <ski> (s/*can* reason/*can* "reason"/ since there's not much we can say about it :)
23:47:47 <int-e> sjanssen: nice
23:48:08 <Cale> ski: Yeah, you actually need to know various things like whether values will ever be recomputed by accident.
23:49:08 <ski> (otoh one can't reason declarativly (in general) about 'unsafePerfomIO' (unless one wants to blame all on that 'main :: IO ()'))
23:49:19 <Cale> Which kind of rules out the denotational semantics style of reasoning about the program, yeah.
23:49:34 <ski> indeed
23:50:47 <int-e> oooh, sweet. Tue Mar  6 14:31:12 GMT 2007  Simon Marlow <simonmar@microsoft.com> * add noDuplicate#
23:52:58 <dons> yeah!
23:53:52 <ski> (Cale,monochrom,sjanssen : ty for the comments/discussion)
