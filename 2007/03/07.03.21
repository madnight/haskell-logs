00:00:05 <Korollary> Even non-pure functional languages need closures.
00:00:12 <QtPlatypus> newsham: Wouldn't closures mean that you would have to have a heap/stack of some sort?
00:00:33 <QtPlatypus> Korollary: I'm pro closures in almost every case.
00:01:04 <Korollary> @wikipedia funarg problem
00:01:05 <lambdabot> No Result Found.
00:01:08 <Korollary> lies
00:01:13 <newsham> qt: i'm not sure.
00:01:14 <Korollary> @google wikipedia funarg problem
00:01:16 <lambdabot> http://en.wikipedia.org/wiki/Funarg_problem
00:01:58 <newsham> qtplatypus: wouldnt having recursion mean that you would have to have a stack?
00:04:01 <QtPlatypus> newsham: Good point, and if I ban recursion I'm no longer turing compleate.
00:04:05 <QtPlatypus> ...
00:04:13 <sjanssen> dmwit++ I received your patches
00:04:26 <QtPlatypus> Hold On I know the answer to my question.  Yes and its called regular expressions.
00:04:42 <QtPlatypus> Though re's are declaritive.
00:09:49 <dons> sjanssen: should i be testing out these tiling patches?
00:10:51 <sjanssen> dons: it'd be a good idea to take them for a spin, just in case
00:11:01 <sjanssen> you have uncovered a few bugs in the past
00:11:36 <dons> yep
00:12:47 <sjanssen> dons: have you built xmonad since the first tiling patches?
00:13:28 <dons> nope. been super-busy
00:13:33 <dons> i will do so tonight
00:14:01 * earthy smells icfp papers in the air
00:14:04 <newsham> qtplatypus: and since all machines have finite state, no machine can compute anything that a regexp cant!
00:14:10 <newsham> i think you're set!
00:14:50 <sjanssen> dons: cool.  new windows are inserted in a different order in Full mode now.  Let me know what you think on that
00:15:20 <dons> earthy: its that time of the year
00:16:00 <newsham> how many haskell phd's go on to industry vs. staying in academia?  also how many keep doing haskell as opposed to getting into something else?
00:16:18 <sjanssen> dons: can you comment on the topic?
00:16:26 <therp> dons: you are submitting a paper to icfp? I presume the standards are pretty high, right?
00:16:40 * sjanssen has his suspicions with dcoutts in town
00:17:06 <dons> newsham: i don't think we have stats.
00:17:16 <dons> therp: hope so. dcoutts and I are conspiring
00:17:23 * dons hacks..
00:17:33 <newsham> rough guesses?  hunches?
00:18:00 <therp> dons: may I ask what's the title of your paper?
00:18:01 <dons> newsham: hmm. half?
00:18:06 <dons> therp: no titles yet :-)
00:18:14 <therp> dons: well, ok. what's it about :)
00:18:20 <newsham> what's the demand for haskell phds in industry like?
00:18:35 <newsham> and the pay?  pretty decent?
00:18:43 <dons> newsham: you get asked to dinner at conferences :-)
00:18:46 <dons> that's some kind of demand
00:19:30 <newsham> like.. if i wanted to hire a bunch of haskell phd's woudl I be paying top dollar or would they be begging for the job?
00:20:06 <sjanssen> heh, maybe both :)
00:20:17 <newsham> do i have to pay them or can I just give them a cot, some bread and some water?
00:21:07 <QtPlatypus> newsham: Remember that thouse who know Haskell most likely know other more marketable lanauges.
00:21:49 <newsham> *nod* hence my question about them sticking w/ haskell or going off and doing other things.
00:22:28 <newsham> obviously if they're all fine doing erlang and ruby then the job market's pretty wide open ;-)
00:25:13 <dcoutts> newsham: you have to pay them a lot to persuade them to stop hacking on other things
00:25:52 <newsham> are we talking bay area "alot" or like oregon "alot"?
00:26:02 <dcoutts> feh, no idea.
00:26:10 <dcoutts> I don't know how much people get paid
00:26:32 <dcoutts> it's probably better that way or I might get jealous :-)
00:26:51 <newsham> i think bay area wages are probably around $120k for a good developer?
00:27:06 <dcoutts> Â£60k yeah, that's a lot
00:27:21 <dcoutts> I'd be very happy with half that
00:28:07 <newsham> only if there wasnt someone else offering you $120k to work for them instead ;-)
00:29:24 <dcoutts> depends what either wanted me to do
00:29:28 <newsham> yah
00:29:30 <dcoutts> I want to do fun stuff
00:36:27 <Bercilak> Question from a monad noob: Is the implementation/usage of bind/return to manipulate a monad in any way analogous to the usage of a higher order function to define cons in a lisp/Scheme?
00:37:42 <Cale> Bercilak: somewhat, I suppose
00:37:58 <Cale> er.
00:38:11 <Cale> Depends on what you mean by that.
00:38:41 <Bercilak> I keep getting this picture of sussman or abelson presenting that definition of cons in my head whenever I skip do-notation and write it with lambdas.
00:38:47 <Cale> Basically, bind and return abstract over a bunch of operations on different types which behave in a consistent way.
00:38:49 <Bercilak> :-P
00:39:11 <Cale> Well, you saw the streams lecture, right?
00:39:20 <newsham> has there been any news on Haskell/ESC recently?  is it available for use yet?
00:39:31 <Cale> Bind is like a generalisation of concatMap
00:39:36 <Bercilak> Cale: haven't gotten there quite yet. :-P
00:39:53 * Bercilak thinks he'll watch that then
00:39:55 <Cale> and return is a generalisation of the function \x -> [x]
00:41:27 <Bercilak> since I'm asking bare fundamentals... does a monadic function then directly correspond to an arrow (in category theoretic terminology)?
00:41:49 <Cale> a -> m b
00:41:50 <Cale> ?
00:41:58 <Bercilak> I'm trying to get up to speed on category theory as well. :-/
00:42:07 <Cale> Yeah, that's an arrow of the Kleisli category for the monad.
00:43:08 <Cale> As a function, it's also just a plain old arrow in the category we're normally working in.
00:43:26 <Cale> But a value of type m a isn't necessarily an arrow in any way.
00:43:55 <Cale> (or m a itself, I should say)
00:43:56 <newsham> ?type runKleisli
00:43:59 <lambdabot> forall (m :: * -> *) a b. Kleisli m a b -> a -> m b
00:45:20 <Bercilak> That makes sense.
00:46:04 <Bercilak> So does Maybe correspond to the tiny category with one initial and one terminal object?
00:47:21 * Bercilak will shut up and watch some SICP :-D
00:47:32 <dolio> Maybe would have more objects than that, no?
00:47:39 <dolio> Maybe a for all types a?
00:50:52 <Bercilak> Ah. I was kind of thinking that the type somehow was an "annotation" on the initial value object (Just x), but "annotations" on objects can't really exist can they?
00:52:08 <dolio> To be honest, I've only got a vague idea of what I'm talking about either. :)
00:52:52 <dolio> But, I think the (or, one) way people use category theory with Haskell, for example, is that the type system is a category, and the objects are the types.
00:53:18 <dolio> And then Maybe, for example, is a functor that takes types to types.
00:53:55 <dolio> So Maybe Char is an object, Maybe Int, etc.
00:54:52 <Cale> dolio: right
00:54:53 <dolio> Or something like that.
00:54:56 <Bercilak> Fair. I do DSP stuff by day, and I get an intuitive picture of the math. I'm trying to do the same here.
01:09:26 <dolio> Heh, "Big O analysis considered harmful"
01:09:47 <newsham> O'really
01:11:06 <dolio> Yeah, because it doesn't take into account cache misses and stuff.
01:11:16 <newsham> O(h) my
01:16:29 <nornagon> @spell garotte
01:16:30 <lambdabot> garrote Garrott grotto garroter gavotte
01:16:34 <newsham> it would be nice if Haskell/ESC properties could be automatically used with quickcheck as well (or vice versa)
01:16:46 <newsham> especially in cases where ESC cannot decide if the property holds or not
01:24:23 <therp> has anyone read the google SoC terms? imho, it says that google does not have to obey the license. does anyone else reach this conclusion?
01:28:29 <desp> @seen bos
01:28:29 <lambdabot> I saw bos leaving #haskell 10h 53m 15s ago, and .
01:28:34 <desp> @seen bos_
01:28:34 <lambdabot> bos_ is in #haskell. I last heard bos_ speak 4h 15m 13s ago.
01:33:55 <mcflightsuit> Back again.
01:33:59 <mcflightsuit> Can't sleep.
01:43:56 <siti> does anyone know how to use the heap retainer in ghc?
01:44:12 <dolio> > (\f z l -> foldr (\a (x:xs) -> f a x : x : xs) [z] l) (+) 1 [1..5]
01:44:15 <lambdabot>  [16,15,13,10,6,1]
01:44:25 <dolio> > scanr (+) 1 [1..5]
01:44:26 <lambdabot>  [16,15,13,10,6,1]
02:16:45 <dons> re.
02:18:15 <Vq^> hello dons
02:25:17 <dmwit> ?index raise
02:25:17 <lambdabot> bzzt
02:25:32 <dons> raise?
02:25:37 <dons> the xmonad function?
02:27:10 <quicksilver> dmwit: I see your ?index and raise you @pl ?
02:27:33 <dmwit> quicksilver: Hahaha.
02:27:45 <dmwit> dons: Yes, I'm still getting acquainted with the code.
02:28:41 <dolio> @pl \f z l -> foldr (\a xs -> f a (head x) : xs) [z] l
02:28:41 <lambdabot> (. return) . foldr . ((:) .) . flip flip (head x)
02:28:43 <therp> dons: so you are not revealing what your icfp paper will be about? :)
02:30:26 <dons> therp: we're working on one extending stream fusion
02:30:29 <dons> ?where streams
02:30:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/streams.html
02:32:02 <therp> dons: thanks, I will have a look
02:42:55 * dons crosses fingers that spj's patch fixes his .hs-boot bug
02:46:39 <quicksilver> :t flip flip
02:46:42 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
02:49:14 <mauke> @. djinn type flip flip
02:49:17 <lambdabot> f a b c = b c a
02:50:57 <quicksilver> that looks so pretty and simple
02:51:06 <quicksilver> until you realise that it's actually 'applying' b to c and a :)
02:51:12 <quicksilver> well it's still pretty and simple
02:51:26 <quicksilver> but at first you could mistake it for (a,b,c) -> (b,c,a) and it isn't that :)
02:53:02 <mauke> > flip flip 'a' elem "bar"
02:53:03 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
02:53:19 <mauke> ah, another flip
02:54:50 <ski> @. djinn type uncurry (uncurry curry)
02:54:53 <lambdabot> f ((a, b), c) = a (b, c)
02:55:57 <sieni> > let {some = (++); burgers = "my!"; now = "Yum"} in flip some burgers now
02:55:58 <lambdabot>  "Yummy!"
02:56:24 <quicksilver> cute
03:03:02 <ski> @. djinn type uncurry . flip . uncurry . (flip .) . (flip $) . curry . curry $ id  -- associator
03:03:05 <lambdabot> f (a, (b, c)) = ((a, b), c)
03:03:57 <ski> @. pl . djinn type uncurry . flip . uncurry . (flip .) . (flip $) . curry . curry $ id
03:04:00 <lambdabot> f = uncurry ((`ap` snd) . (. fst) . ((,) .) . (,))
03:06:33 <ski> bah, using 'fst','snd' is cheating ..
03:08:50 <quicksilver> pl does all kinds of cheating
03:08:59 <DukeDave> Hello gang :)
03:10:22 <quicksilver> ski: this is the one that really annoys me :
03:10:25 <quicksilver> @pl liftM2 f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
03:10:26 <lambdabot> liftM2 = liftM2
03:10:41 <quicksilver> no! I want to see the pl form of liftM2, I don't want it simplified back to liftM2 :)
03:10:59 <quicksilver> @pl m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
03:10:59 <lambdabot> (`fmap` m2) . f =<< m1
03:11:09 <quicksilver> is a bit more interesting at least
03:11:13 <mauke> @pl liftM2 f m1 m2 = m1 >>=' \ x1 -> m2 >>=' \ x2 -> return' (f x1 x2)
03:11:13 <lambdabot> (line 1, column 16):
03:11:14 <lambdabot> unexpected "="
03:11:14 <lambdabot> expecting variable, "(", operator or end of input
03:11:59 <mauke> @pl liftM2 f m1 m2 = m1 >>=? \ x1 -> m2 >>=? \ x2 -> return' (f x1 x2)
03:12:00 <lambdabot> liftM2 = flip ((.) . (>>=?)) . flip ((.) . (>>=?)) . ((return' .) .)
03:14:56 <quicksilver> ah, neat trick
03:15:10 <quicksilver> although I don't mind it using the properties of >>= that it knows :)
03:15:16 <quicksilver> I just didn't want it to reduce to liftM2
03:15:17 <DukeDave> Can anyone suggest a code example for a looping main function which reads from stdin & prints to stdout?
03:15:25 <quicksilver> DukeDave: interact
03:15:37 <quicksilver> :t interact
03:15:39 <lambdabot> (String -> String) -> IO ()
03:16:13 <quicksilver> DukeDave: "main = interact (\x -> x)" is a complete program, which echoes its input to stdout
03:16:31 <quicksilver> main = interact (\x -> "You typed : " ++ x)
03:16:34 <quicksilver> is slightly more interesting
03:16:51 <DukeDave> I just love this channel sometimes :)
03:17:05 <DukeDave> hell, that even deserves a big one  :D
03:17:11 <DukeDave> cheers!
03:17:35 <quicksilver> :)
03:17:53 <quicksilver> @src interact
03:17:54 <lambdabot> interact f = do s <- getContents; putStr (f s)
03:18:07 <quicksilver> oh, I was wrong. sorry
03:18:13 <quicksilver> interact is whole-input at a time
03:21:47 <quicksilver> DukeDave: line-based is this:
03:21:49 <quicksilver> main = interact (unlines.map (\x -> "You typed " ++ x).lines)
03:23:23 <dolio> That certainly works oddly in ghci.
03:23:39 <dolio> "fYou typed: foooobbaarr"
03:23:46 <dolio> No buffering, I guess.
03:24:21 <quicksilver> yes, it's a bit subtle
03:24:28 <quicksilver> because getContents is running lazily
03:24:37 <quicksilver> ghci 'gets' the line as soon as it starts
03:24:46 <quicksilver> and that triggers it to write "You typed "
03:25:02 <quicksilver> in a real application where you want precise control, you would take control of the IO a bit more tightly
03:25:15 <quicksilver> and probably use hGetLine rather than the lazy hGetContents used by interact
03:25:20 <quicksilver> but it suffices for a demo
03:25:48 <dolio> If you compile it it actually does proper line buffering.
03:25:54 <dolio> Unless you specify otherwise, of course.
03:26:22 * quicksilver nods
03:26:24 <quicksilver> right
03:26:34 <quicksilver> stdio is line-buffered by default, but ghci is unbuffered by default
03:26:43 <quicksilver> ghci does 'maximally eager lazy IO' :)
03:26:49 <dolio> :)
03:27:08 <quicksilver> if you run ghci inside emacs, of course, then emacs line buffers for you
03:32:46 <ejt> hi
03:33:33 <ejt> can anyone help me understand why 'interact id' outputs after each line, but 'interact reverse' waits until the end of input before outputting anything please ?
03:33:54 <quicksilver> because interact reverse tells it to reverse the entire input
03:34:08 <quicksilver> so it can't do start until it's seen the last character
03:35:25 <ejt> grr, I'm being an idiot aren't I
03:35:38 <ejt> I thought interact split into lines for some reasonn
03:35:42 <quicksilver> so did I
03:35:48 <quicksilver> until 5 minutes before you logged on :)
03:35:53 <quicksilver> when I had just made the same mistake
03:35:56 <quicksilver> synchronicity
03:36:07 <quicksilver> 10:20 < quicksilver> main = interact (unlines.map (\x -> "You typed " ++
03:36:07 <quicksilver>                      x).lines)
03:36:28 <ejt> weird
03:47:04 <mux> how would you guys write a function to convert a string representing a Color in hexadecimal RGB format (#ffffff) to a triple of numbers?
03:48:07 <ejt> drop the '#', split into pairs, then map read
03:48:41 <Syzygy-> > map read ["ab","cd","ef"] :: (Int,Int,Int)
03:48:42 <lambdabot>  Couldn't match expected type `(Int, Int, Int)'
03:48:57 <Syzygy-> > map read ["ab","cd","ef"] :: [Int]
03:48:58 <lambdabot>  Exception: Prelude.read: no parse
03:49:01 <ejt> oh there must be a hex read fn
03:49:01 <Syzygy-> Doh.
03:49:14 <quicksilver> > read "0xff" :: Int
03:49:15 <lambdabot>  255
03:49:17 <ToRA> > map (read . ("0x" ++ )) ["ab", "cd", "ef" :: [Int]
03:49:17 <lambdabot>  Parse error
03:49:27 <Syzygy-> ToRA: Closing ]
03:49:32 <ToRA> > map (read . ("0x" ++ )) ["ab", "cd", "ef"] :: [Int]
03:49:33 <lambdabot>  [171,205,239]
03:49:34 <ToRA> ya
03:49:59 <Lemmih> @type readHex
03:50:01 <lambdabot> forall a. (Num a) => String -> [(a, String)]
03:50:15 <mauke> > let z = digitToInt; f ['#',a,b,c,d,e,f] = (z a * 16 + z b, z c * 16 + z d, z e * 16 + z f) in f "#ffffff"
03:50:16 <lambdabot>  (255,255,255)
03:50:21 <ejt> there's a splitEvery defn here: http://lambda-software.com/darcs/programming-challenges/lib/MiscList.hs
03:50:23 <lambdabot> http://tinyurl.com/yvj449
03:59:11 <ToRA> > read . ( ++ ")" ) . ("(" ++ ) . concat . intersperse "," . map ("0x" ++) . takeWhile (not . null ) . unfoldr (Just . splitAt 2) . drop 1 $ "#fafbfc" :: (Int,Int,Int)
03:59:12 <lambdabot>  (250,251,252)
03:59:41 <matthew_-> ToRA: you, sir, should spend more time on your PhD and less time on #haskell ;-)
03:59:53 <matthew_-> ToRA: and stop giggling behind me!
03:59:56 <ToRA> matthew_-: you're just jealous
04:01:21 * ejt applauds ToRA
04:01:24 <matthew_-> ToRA: so is the one-line parsec version coming?
04:03:15 <ToRA> matthew_-: don't say things like that, cos i may have to try...
04:04:58 <matthew_-> meet ToRA: the most easily distractable student EVER!
04:05:29 <Cale> > (\[x,y,z] -> (x,y,z)) . map (fst . head . readHex) . takeWhile (not . null) . unfoldr (Just . splitAt 2) . drop 1 $ "#fafbfc"
04:05:30 <lambdabot>  (250,251,252)
04:06:38 * ToRA tips hat to Cale
04:07:01 <nornagon> wuh
04:07:07 <nornagon> late night cup of haskell
04:07:10 <nornagon> it's bitter :(
04:07:57 * Cale stretches
04:08:23 <vvv> Is there a way to make the function below point-free?
04:08:23 <vvv> updateRateFromHistory :: ExchangeRate -> PerHistoryHome -> ExchangeRate
04:08:23 <vvv> updateRateFromHistory xr history = update xr $ findCorresponding history xr
04:08:49 <nornagon> @pl \xr h -> update xr $ findCorresponding h xr
04:08:50 <lambdabot> liftM2 (.) update (flip findCorresponding)
04:09:48 <vvv> Whoops. :) And what is this `@pl' thing? Some lambdabot's command?
04:09:56 <nornagon> yep
04:10:00 <ejt> very useful
04:10:03 <nornagon> automatic point-free conversion
04:10:20 <int-e> @pointless \x y z -> z x y
04:10:20 <lambdabot> flip . flip id
04:10:33 <vvv> Could you point me to the list of lambdabot's commands? :-)
04:10:42 <ejt> @help
04:10:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:10:47 <ejt> @list
04:10:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
04:11:15 <vvv> Vielen dank!
04:12:01 <dons> Igloo: more hs-boot troubles with the head, still, I think
04:12:30 <ToRA> matthew_-: parsec version:
04:12:32 <ToRA> Prelude Text.ParserCombinators.Parsec> let fn = do { f <- anyChar ; s <- anyChar ; return  (read ("0x" ++ [f,s]) :: Int) } in runParser (do { char '#' ; many fn }) () "blank" "#22ffa3"
04:12:32 <ToRA> Right [34,255,163]
04:12:58 <dons> we should have parsec running in lambdabot
04:13:36 <matthew_-> ToRA: I bet you could do it shorter in happy...
04:13:49 <dons> hah
04:13:51 <ToRA> matthew_-: don't even go there
04:14:02 <matthew_-> ToRA: awwww, you chicken?
04:14:07 <dons> no, you should roll your own parser combinator library
04:14:51 <ejt> dons: is there a parser combinator library that works with your LAzyBytestring stuff ?
04:15:41 <ToRA> dons: :)  my phd supervisor may just kill me if i start...
04:15:52 <dons> ejt: there's a little bit of work done in this area
04:16:01 <dons> but we really need *the* bytestring/parsec solution to be written yet
04:16:06 <matthew_-> ToRA: she's had plenty of motivation so far...
04:16:39 <ejt> dons is there any info on what the problems are ?
04:16:57 <dons> complexity of cons.
04:17:25 <dons> that's the main one. we really need a new combinator set written with the different complexity of strict (or lazy) bytestrings in mind
04:17:26 <int-e> hmm.  replicateM 2 anyChar >>= return . read . ("0x" ++)
04:18:26 <ejt> k
04:18:43 <dcoutts> dons: hmm? parsing is deconstructing a string, what's the complexity of cons got to do with it?
04:19:23 <ToRA> int-e: yeah, thought there was a way to remove the two <-'s
04:20:00 <ToRA> this is the problem with haskell, once you've written something, you end up staring at it wondering if there's a shorter neater way
04:20:01 <ejt> dcoutts: I guess that to take advantage of laziness you need combinators that play nice with cons
04:20:02 <Pastorn> @seen cantadou
04:20:02 <lambdabot> I haven't seen cantadou.
04:20:07 <dons> dcoutts: oh, i thought there were issues with building up lookahead space or something?
04:20:21 <dons> there is *some* complexity issue with parsec, but maybe it isn't cons :-)
04:20:34 <dons> the parsec-bytestring lib should take O(1) sub strings of input tokens, ideally
04:20:52 <dcoutts> dons: lookahead is ok with strict and lazy ByteString
04:21:07 <dons> it might be sensible to have a custom parsec-lexer for bytestring too
04:21:12 <dcoutts> though you pay for keeping those lookahead backtracking points
04:21:12 <dons> rather than trying to use the parser combinators for lexing
04:21:41 <dons> so i gave up for tonight on getting base to build , dcoutts, and sent off a hopeful bug report instead
04:23:33 <nornagon> http://www.dangermouse.net/esoteric/piet/samples.html <- I want a haskell to piet compiler.
04:23:34 <lambdabot> Title: DM's Esoteric Programming Languages - Piet Samples
04:23:56 <dons> you know you've been in haskell too long when .... you always type `seq` when you mean to type `eq`.
04:24:09 <dons> when ... you type 'applicative' instead of 'application'
04:24:35 <dons> i did both of those several times today. weird
04:24:39 <dcoutts> dons: aye, I note that SPJ also fixed a boot hi bug today
04:24:50 <dons> yes. still fails for us though
04:25:12 <jacobian> someone should do decss in piet
04:25:13 <dons> i note he's still working on this area, so maybe if he checks his inbox ...
04:37:16 * dcoutts -> bed
04:46:47 <DukeDave> I really really hate C++
04:46:53 <DukeDave> and I have C++ users even more
04:46:57 <DukeDave> :(
04:47:13 <quicksilver> I heard C++ isn't so keen on you, either
04:47:15 <quicksilver> sorry about that :(
04:47:16 <ejt> you should feel sorry for them rather than hate
04:47:26 <Thunder> Duke: C++ is lovely lispish if you restrict yourself to templates.
04:48:07 <matthew_-> yeah, like Perl is readable if you restrict yourself to about 1% of the language...
04:48:38 <Thunder> Templates of C++ are turing complete.
04:48:54 <ejt> Thunder: y, but very, very verbose
04:48:59 <quicksilver> templates of C++ do type inference, too
04:49:22 <quicksilver> someone wrote a raytracer in the templates :)
04:49:24 <DukeDave> I just want to pipe out text to a Haskell program to deal with it via interact, and get the stdout text back into C++
04:49:29 <quicksilver> compile-time raytracing!
04:49:39 <Botje> DukeDave: do the pipe dance!
04:49:41 <Vq^> quicksilver: neat :o)
04:49:46 <Thunder> ejt: The glue code of C++ and Java is not larger, if your program in the typical imperative style.
04:49:59 <DukeDave> but, no, apparently I can't do that
04:50:24 <Vq^> quicksilver: sometimes i wonder if thats what the compiler is doing, C++ compiles can take quite a while
04:50:42 <quicksilver> Vq^: I think it browses the web when it gets bored
04:50:53 <quicksilver> Vq^: you quite often see blog postings from bored C++ compilers
04:52:07 <ejt> DukeDave: windows or unix ?
04:52:43 <Thunder> Vq: The library is shipped as source code. There is no way to do seperate compilation.
04:52:59 <DukeDave> unix
04:53:19 <DukeDave> it'd be so simple it popen() supported bidirectional communication
04:53:24 <DukeDave> *if
04:54:37 <DukeDave> but it doesn't, and all pleas for help are respectfully answered "You cannot hope to understand anything simpleton!"
04:54:43 <DukeDave> :(
04:54:58 <ozone> it does support bidi comms
04:55:09 <DukeDave> so it looks like I'm going to learn to use sockets
04:55:18 <ozone> just perhaps not very portably
04:55:19 <ejt> I tend to use fork/dup2 directly
04:55:22 <quicksilver> in what sense does popen 'not support bidirection communication' ?
04:55:44 <quicksilver> excerpt: "The popen() function ``opens'' a process by creating a bidirectional pipe forking, and invoking the shell...."
04:56:10 <ozone> quicksilver: all the world is not mac os x
04:56:17 <quicksilver> ah, reading further I discover that old versions of popen were unidirectional
04:56:29 <DukeDave> quicksilver, yeah it hurts :(
04:56:45 <ozone> surely linux has bidi popen() by now?
04:57:13 <quicksilver> anyhow, forking and dup'ing is not hard, as ejt says :)
04:57:17 <DukeDave> ozone, you would think that?    But when I call popen with the r+ (bidi) arg it dies :(
04:57:35 <ozone> DukeDave: get a copy of "advanced programming in the unix environment"
04:57:40 <ozone> it has great code
04:57:49 <ozone> or you can google of course, but you knew that already :)
04:57:58 <DukeDave>  :)
04:58:20 <DukeDave> cool cheers guys, loving the support :)
04:59:05 <DukeDave> would you recommend fork/dup'ing (which I have never encountered) to using sockets (also)
04:59:15 <dons> gee, i even have this in haskell,
04:59:16 <dons> exec cmd args (pr,cw,ce) = do
04:59:16 <dons>         dupTo pr stdInput
04:59:16 <dons>         dupTo cw stdOutput      -- dup stderr too!
04:59:16 <dons>         dupTo ce stdError       -- dup stderr too!
04:59:19 <dons>         executeFile cmd False args Nothing
04:59:21 <dons> :-)
04:59:30 <ozone> dons: http://www.dangermouse.net/cricket/baseball.html
04:59:30 <lambdabot> Title: DM's Explanation of Cricket - Is Cricket like Baseball?
04:59:41 <quicksilver> DukeDave: yes, there's no point using sockets for this
04:59:53 <dons> http://www.cse.unsw.edu.au/~dons/code/hmp3/Utils.hs grep for popen
05:00:10 <dons> yay for bidirectional ipc via pipes
05:00:12 <ejt> DukeDave: dup/fork will be simpler
05:00:16 <ozone> and who said writing yet another mp3 players wasn't useful?
05:00:41 <DukeDave> okay thanks, I'll get right on it :
05:08:52 <dons> ?yow
05:08:52 <lambdabot> Did I do an INCORRECT THING??
05:10:27 <DukeDave> I don't get it :(
05:11:08 <ozone> ?eliza
05:11:08 <lambdabot> Say again?
05:11:14 <ozone> aww
05:12:46 <thartman> I've been reading about getargs: http://www.zvon.org/other/haskell/Outputsystem/index.html
05:12:47 <lambdabot> Title: Zvon - Haskell Reference
05:12:59 <thartman> can I run this sample program from the bash shell, without compiling it first?
05:14:28 <thartman> By skipping the compile, I sacrifice a little speed, but it's easier for playing around.
05:14:46 <ejt> runhaskell <program.hs>
05:14:50 <chessguy> > State 4 >>= modify (*2)
05:14:51 <lambdabot>  Couldn't match expected type `State s b' against inferred type `()'
05:15:17 <chessguy> > State 4 >>= get
05:15:18 <lambdabot>   add an instance declaration for (Show (State s b))
05:16:03 <chessguy> @type (State 4 >>= get)
05:16:06 <lambdabot> forall s a b. (Num (s -> (a, s)), MonadState (State s b) ((->) a)) => State s b
05:19:55 * mux got disconnected after asking a question
05:20:08 <ToRA> > runState (modify (*2)) 4
05:20:10 <lambdabot>  ((),8)
05:21:24 <chessguy> > execState (modify (*2)) 4
05:21:26 <lambdabot>  8
05:21:42 <nornagon> :t execState
05:21:45 <lambdabot> forall s a. State s a -> s -> s
05:21:47 <ToRA> @type (modify (*2))
05:21:49 <lambdabot> forall s (m :: * -> *). (Num s, MonadState s m) => m ()
05:22:11 <mux> oh, great, digitToInt works with hexadecimal digits
05:22:31 <chessguy> @typedigitToInt
05:22:31 <lambdabot> Unknown command, try @list
05:22:35 <chessguy> @type digitToInt
05:22:37 <lambdabot> Char -> Int
05:22:38 <thartman> I tried ghc -e Main.main args.hs 1 2 3 4 5    ... but no.
05:23:09 <dons> you can always runhaskell Foo.hs too
05:23:27 <ejt> @paste
05:23:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:24:04 <LPhas> @type withArgs
05:24:06 <lambdabot> Not in scope: `withArgs'
05:24:09 <mux> > digitToInt 'a'
05:24:11 <lambdabot>  10
05:24:11 <LPhas> uhm
05:24:15 <hpaste>  ejt pasted "(no title)" at http://hpaste.org/1066
05:24:22 <LPhas> @hoogle withArgs
05:24:22 <lambdabot> System.Environment.withArgs :: [String] -> IO a -> IO a
05:24:32 <ejt> ^^ trivial parsec question
05:24:35 <doserj> ghc -e is for evaluation expressions
05:24:38 <mux> how can I convert an Int to a Word16 ?
05:24:46 <mux> with fromIntegral still?
05:24:50 <nornagon> ghc -e is slooooooow :(
05:24:51 <doserj> $ ghc -e "reverse \"blubb\""
05:24:59 <doserj> "bbulb"
05:24:59 <ClaudiusMaximus> @where xmonad
05:24:59 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
05:25:02 <chessguy> @type fromIntegral
05:25:04 <lambdabot> forall a b. (Num b, Integral a) => a -> b
05:25:18 <chessguy> @instances-importing Num
05:25:19 <lambdabot> Double, Float, Int, Integer
05:25:58 <chessguy> ?hoogle Word16
05:25:58 <lambdabot> Data.Word.Word16 :: data Word16
05:26:37 <ejt> Prelude Data.Word> (fromIntegral 32) :: Word16
05:26:37 <ejt> 32
05:26:46 <mux> great, thanks
05:27:12 <thartman> dons: thanks.    runhaskell args.hs 0 1 2    is what I wanted.
05:27:46 <chessguy> hmm, wierd that it doesn't show up as an instance of Num
05:27:54 <thartman> is there a drop-in replacement for runhaskell like "ghc blah blah" ?
05:28:21 <nornagon> runghc :-)
05:28:55 <thartman> maybe that was not such a smart question? :)
05:29:33 <nornagon> not really, i have no idea what you said.
05:29:53 <hpaste>  mux pasted "Parsing hexadecimal RGB colors" at http://hpaste.org/1067
05:30:03 <mux> that may be a bit verbose for such a little thing though
05:30:06 <dons> mux, yes.
05:30:10 <quicksilver> chessguy: lambdabot's different sources of data are not all the same :)
05:30:24 <quicksilver> chessguy: it's @src files are different from its @hoogle files
05:30:33 <quicksilver> @hoogle isInfixOf
05:30:34 <lambdabot> No matches found
05:30:36 <quicksilver> @src ifInfixOf
05:30:36 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:30:43 <quicksilver> @src isInfixOf
05:30:43 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
05:30:55 <quicksilver> typoes jeopardize my ability to make a good point :)
05:30:55 <mux> I'm interested if anyone can simplify that
05:31:36 <quicksilver> mux: I don't see any compelling reason to shorten it
05:31:42 <quicksilver> mux: it's already very clear
05:31:48 <ejt> mux: move fromIntegral into colourComponent ?
05:31:53 <quicksilver> mux: don't value LinesOfCode over clarity :)
05:33:01 <mux> quicksilver: I usually don't, but with Haskell, I often find I'm missing some idiom that would allow me to write things shorter without losing readability
05:33:07 <dolio> ?hoogle readHex
05:33:07 <lambdabot> Numeric.readHex :: Integral a => ReadS a
05:33:08 <lambdabot> Numeric.readHex :: Num a => ReadS a
05:33:08 <lambdabot> Text.Read.Lex.readHexP :: Num a => ReadP a
05:33:17 <mux> readHex is too annoying for my case, I think
05:33:21 <mux> ejt: what do you mean?
05:33:47 <mux> oooh
05:33:48 <mux> right.
05:33:53 <ejt> mux, you could change colourComponent to return a Parser Word16
05:34:05 <ejt> but I agree with the others that it's nice as it is
05:34:06 <dolio> > readHex "ABC"
05:34:08 <lambdabot>  [(2748,"")]
05:34:28 <quicksilver> yes, changing component to Parser Word16 would be slightly nicer I agree
05:34:43 <dolio> > readHexP "ABC"
05:34:43 <lambdabot>   Not in scope: `readHexP'
05:35:11 <thartman> nornagon: I didn't really realize that runghc is a separate program from ghc. But man runghc, info runghc, and google runghc don't turn up much on it. what exactly is it and where is the docu?
05:35:21 <hpaste>  mux annotated "Parsing hexadecimal RGB colors" with "simpler" at http://hpaste.org/1067#a1
05:35:41 <mux> quicksilver: I actually left it polymorphic
05:35:49 <nornagon> thartman: i think runhaskell works when either ghc or hugs is installed, it uses whatever's available
05:35:51 <mux> I could force it to Word16
05:35:56 * quicksilver nods
05:35:57 <nornagon> run(ghc|hugs) uses that one specifically
05:35:59 <quicksilver> well that's up to you
05:36:00 <mux> not sure if that's useful though
05:36:03 <mux> maybe for optimization?
05:36:09 <quicksilver> it seems that in this case your intention is for it to be monomorphic
05:36:16 <quicksilver> after all, it only reads 2 digits
05:36:22 <mux> yeah, i'm probably only going to use it in that case
05:36:23 <mux> yeah
05:36:25 <quicksilver> and you only ever intend it to be used in Colors
05:36:28 <mux> right
05:36:41 <quicksilver> sometimes unneeded polymorphism is slightly distracting
05:36:51 <ejt> anyone have time to look at my parsec question please ?
05:37:02 <thartman> nornagon: well, the main thing is it works for what I want to do. I can work on grokking the details later. thx.
05:37:07 <mux> I think we need yet other bindings in gtk2hs
05:37:15 <mux> I think there is a gdk_color_parse() for that
05:37:18 <mux> anyways, it works.
05:38:02 <thartman> I do think http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html should include a fex lines on what exactly runghc does.
05:38:04 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.6, http://tinyurl.com/y4o7nt
05:38:18 <thartman> I think the mentality there is, it's expected that most users will want to compile and run.
05:38:30 <quicksilver> a precise type can be good documentation
05:38:31 <thartman> But users coming from a scripting language mentality (perl, python, ruby) are used to just running.
05:38:47 <quicksilver> thartman: I mostly just run, inside ghci
05:38:52 <quicksilver> :r
05:38:55 <quicksilver> myFunc "foo"
05:39:03 <quicksilver> <that didn't quite work, edit edit edit
05:39:04 <quicksilver> :r
05:39:09 <quicksilver> myFunc "foo"
05:39:13 <thartman> "Just running" is what runghc does basically, a little slower, but sometimes you don't care, and this way you can keep working the way you're used to, and not clutter up your dir with a.out, .hi, and whatever that crap is. :)
05:39:26 <ejt> I tend to compile regularly as I write, then when I'm ready to run load it into ghci
05:39:34 <ejt> and see what it does
05:39:48 <quicksilver> loading into ghci is quite a bit faster than compiling, though
05:40:07 <quicksilver> (I have a fairly slow computer)
05:40:12 <thartman> I use ghci to mess around, but I like being able to run from the command line. That way I can cron it, pipe it from other (non haskell) stuff, whatever.
05:40:16 <ejt> y, but I can compile from within the editor
05:40:21 <dolio> ejt: I think the problem is that Parsec isn't going to give you results lazily, because it doesn't know if there are errors up ahead.
05:40:42 <ClaudiusMaximus> :t lift
05:40:44 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
05:41:08 <ejt> dolio: I couldn't see a parse function in parsec that returns the unparsed input
05:41:11 <dolio> ejt: So if you just have it parse all input, it won't give you anything back until it's seen everything.
05:41:48 <ejt> dolio: so I'm not sure how to make an explicit parsing loop
05:42:19 <kuribas> ejt: getInput ?
05:42:51 <dolio> ejt: Well, you do getLine --> parse --> output --> repeat, but at that point, you've implemented all of cat without needing the parse step.
05:43:33 <ejt> kuribas: ah, that's what I'm missing thx
05:44:33 <ejt> kuribas: so I do something like:  line :: Parser (String, String)
05:44:52 <ejt> where it returns both the next line, and remaining input ?
05:45:12 <thartman> exit
05:45:50 * mux wishes Cairo hahd the same type for representing colours than Gdk
05:46:10 <dons> does anyone have a 'windows live ID' who'd like to help this guy out, misteri82.spaces.live.com/Blog/cns!38CA93C110E663D0!198.entry
05:46:39 <dons> i tried to comment on his blog, but hmm. needs scary account set up
05:46:45 <dons> http://misteri82.spaces.live.com/Blog/cns!38CA93C110E663D0!198.entry
05:46:46 <lambdabot> http://tinyurl.com/ytygps
05:46:50 <kuribas> ejt: I'd use something like (noneOf "\n" `sepEndBy` char '\n') for line.
05:47:05 <dons> "Haskell is stupid" :-) (just a beginner programmer needing some advice)
05:47:10 <kuribas> ejt: Or rather, I wouldn't use Parsec at all.
05:47:29 <ejt> kuribas: this is a very cut down version of a problem I have in a bigger program
05:48:02 <quicksilver> dons: "I'm stupid, but I understand the internet, and I imagine someone else will do my homework for me if I insult their favourite language"
05:48:08 <DukeDave> Guys, can I be cheeky and ask a C/Linux question in here? :)
05:48:09 <ejt> kuribas: it's a pretty printer for log files, I want it to work when tailing logs
05:48:25 <dons> quicksilver: well... maybe yes.
05:48:41 <DukeDave> .. it will ultimately lead to the use of Haskell ;)
05:48:42 <dons> i just don't like bad articles to go unanswered
05:48:49 <quicksilver> dons: it's like the old usenet trick. The boring old farts won't answer when you ask
05:48:52 <dons> i.e. let x = 500 -- was all I was suggesting
05:48:56 <quicksilver> dons: so, you have to deliberately post a wrong answer
05:49:03 <quicksilver> dons: (preferably while boasting or insulting)
05:49:09 <dons> true. this is just some undergrad though on their window-sy blog
05:49:16 <quicksilver> dons: and wait for the smug, angry corrections to pour in
05:49:19 <dons> they probably have no idea that #haskell would pick it up.
05:49:22 * quicksilver nods
05:49:23 <quicksilver> true, true
05:49:29 <quicksilver> I'm being unwarrantedly negative about human nature
05:49:31 <quicksilver> as is my wont
05:49:34 <dons> heh
05:49:40 <dons> we do get those kind here though.
05:49:43 <dons> @protontorpedo
05:49:44 <lambdabot> so haskell is new and improved c?
05:49:52 <quicksilver> cynicism is so much easier than real work
05:50:14 <ejt> DukeDave: still having trouble with pipes ?
05:50:26 * dons is buried in real work this week, so doesn't have time to be cynical
05:50:51 <DukeDave> ejt, yeah, just reading up on fork / dup2 but having trouble
05:50:56 <therp> dons: I guess I have such an ID, but imho this is a waste of time
05:51:01 <DukeDave> following this lovely introduction: http://www.gidforums.com/t-3369.html
05:51:09 <dons> therp: ok . i was hoping we had someone at ANU around
05:51:17 <dons> but yeah, its probably not worth it.
05:51:23 <dons> let them fail comp1A :-)
05:51:42 <DukeDave> my issue is the presence of the (never initialised) rv variable in parent.c
05:51:49 * ejt looks
05:52:15 <ejt> the return from the child gets written there by wait()
05:52:23 <DukeDave> I'm guessing it is supposed to hold the 'return value' of the child process, but they forgot to set it. And not being c-savvy I can't see how :S
05:52:43 <ejt> it's passed as an adress
05:52:55 <DukeDave> oh wow, I see :
05:52:55 <DukeDave> :)
05:53:36 <DukeDave> getting a "ârvâ declared as reference but not initialized" on compile time
05:54:04 <ejt> you've put an '&' on the declaration that shouldn't be there ?
05:54:38 <quicksilver> excellent. C++ reference hell.
05:54:48 <mauke> wait, is this ##c++?
05:54:48 <quicksilver> enjoy your stay. It will be a long one.
05:55:06 <DukeDave> I'm so so sorry everyone!
05:55:14 <DukeDave> ejt, cheers!
05:55:33 <DukeDave> I removed 'scary looking ampersand' and it seems to compile
05:55:41 <ejt> DukeDave: move to #c++, I'll help you more there
05:56:05 * DukeDave nods
06:02:02 <hpaste>  ejt annotated "(no title)" with "Interactive parsec parsing" at http://hpaste.org/1066#a1
06:14:52 <Cheery> How would I do something like: Int + Float ?
06:15:03 <Cheery> when I try that, it does not match.
06:15:06 <int-e> @type fromIntegral
06:15:09 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:15:21 <int-e> fromIntegral int + float  will result in a float
06:16:08 <ClaudiusMaximus> > 24 * 60 * 60 * 44100
06:16:09 <lambdabot>  3810240000
06:46:54 <mightybyte> I've had some trouble with negation in Haskell.  Is there a function that should be used instead of the unary '-'?
06:47:06 <Lemmih> @type negate
06:47:08 <lambdabot> forall a. (Num a) => a -> a
06:47:22 <mightybyte> Ok
06:57:17 <DukeDave> Woop, so I've been wrestling with C++ all morning and it looks like we're back on Haskell's side again with: "setNonBlockingFD: invalid argument (Bad file descriptor)"
06:59:04 <DukeDave> can anyone provide a laymans clue as to what the cause might be?
06:59:34 <ejt> what arguments are you giving ?
07:00:57 <DukeDave> Urm, to my Haskell code?
07:01:03 <DukeDave> one sec, I'll paste :)
07:01:14 <DukeDave> (I owe you one btw ejt! :)
07:07:05 <hpaste>  DukeDave pasted "Interaction between C++ and Haskell" at http://hpaste.org/1068
07:08:05 <Botje> I'm officially addicted to haskell.
07:08:12 <Botje> I've longed for the Reader monad in ruby.
07:10:20 <hpaste>  DukeDave annotated "Interaction between C++ and Haskell" with "One mistake fixed" at http://hpaste.org/1068#a1
07:10:26 <DukeDave> Oops,
07:10:37 <DukeDave> announcer is on then :)
07:12:31 <mux> am I right in thinking it is possible to get darcs repos through SSH?
07:13:01 <swiert> mux: yes.
07:13:01 <norpan> yes, you are right
07:13:38 <mux> ok, how am I supposed to have it work this way? ssh:// ?
07:13:47 <mux> darcs get --help not so helpful
07:14:41 <norpan> user@hostname:dir
07:15:12 <mux> oh, just like CVS ;-)
07:15:12 <mux> thanks
07:15:45 <mux> stupid me
07:20:25 <araujo> morning
07:42:33 <[1]chessguy> 'morning haskellers
07:42:38 <[1]chessguy> hrm
07:43:18 <chessguy> grr
07:43:41 <chessguy> i must have forgotten to log off before i left the house
07:46:10 <ClaudiusMaximus> :t modifyIORef
07:46:14 <lambdabot> Not in scope: `modifyIORef'
07:46:22 <ClaudiusMaximus> @hoogle ioref
07:46:23 <lambdabot> Data.IORef :: module
07:46:23 <lambdabot> Data.IORef.IORef :: data IORef a
07:46:23 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
07:47:52 <ClaudiusMaximus> @pl \a -> (a, a+1)
07:47:52 <lambdabot> ap (,) (1 +)
07:48:06 <ClaudiusMaximus> @pl \a -> (a+1, a)
07:48:07 <lambdabot> (,) =<< (1 +)
07:48:08 <Botje> heh, that's cute.
07:48:20 <Botje> ?src ap
07:48:20 <lambdabot> ap = liftM2 id
07:48:58 <ndm> @seen sorear
07:48:58 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc, #haskell and #happs 13h 18m 12s ago, and .
07:49:36 <desp> hrm
07:49:41 <desp> is there a FFI tutorial?
07:49:45 <chessguy> so i've been thinking, this whole notion of a DSL seems overblown to me. i mean, really, it's nothing more than just providing high-level functions that hide the complexity of what the user wants to do, right?
07:49:49 <chessguy> ?where ffi
07:49:49 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
07:50:19 <desp> yes, I'm reading that
07:50:27 <Eelis> chessguy: that's my understanding, yes. i too find it overblown
07:50:32 <desp> but it's a little light on actual examples
07:50:40 <quicksilver> chessguy: is this in context of some particular problem?
07:50:47 <chessguy> quicksilver, not really
07:50:47 <quicksilver> chessguy: or a general observation about DSLs?
07:51:02 <quicksilver> well there's a continuum between 'providing some useful functions in a toolbox'
07:51:06 <quicksilver> 'combinator library'
07:51:08 <chessguy> desp, that wasn't an answer, i was just checking to see if there was anything there :)
07:51:09 <quicksilver> and 'DSL'
07:51:14 <ClaudiusMaximus> @type let cupsOfCoffeeMadeToday = newIORef 4 ; makeCoffee = atomicModifyIORef cupsOfCoffeeMadeToday $ (,) =<< (1 +) in makeCoffee
07:51:15 <desp> chessguy: :)
07:51:16 <lambdabot> Not in scope: `newIORef'
07:51:16 <lambdabot>  
07:51:16 <lambdabot> <interactive>:1:54: Not in scope: `atomicModifyIORef'
07:51:29 <quicksilver> ClaudiusMaximus: LB won't do IO
07:51:39 <desp> aha, http://web.archive.org/web/20040803092013/http://www.reid-consulting-uk.ltd.uk/docs/ffi.html
07:51:43 <lambdabot> Title: A Guide to Haskell's Foreign Function Interface, http://tinyurl.com/2yvmue
07:51:44 <desp> this looks a little more helpful
07:51:47 <chessguy> quicksilver, i'm not sure what you mean
07:52:06 <Eelis> we're talking EDSL's here, right?
07:52:15 <ClaudiusMaximus> quicksilver: i know, but it might be able to find the @type of an expression
07:52:32 <chessguy> Eelis, i'm not familiar with that term, so i'm not
07:52:49 <chessguy> oh, E = embedded?
07:52:52 <Eelis> yeah
07:52:57 <glguy> ClaudiusMaximus: you haveto run newIORef to get the IO ref
07:53:01 <chessguy> oh, then yes
07:53:01 <Eelis> in a host language
07:53:11 <Eelis> ok
07:53:12 <chessguy> specifically in haskell in this case
07:54:07 <ClaudiusMaximus> glguy: true, no wonder my coffee failed to compile
07:54:10 <chessguy> quicksilver, can you clarify what you mean by that continuum
07:57:44 <quicksilver> chessguy: well
07:57:50 <quicksilver> chessguy: if you just provide a few functions
07:57:59 <quicksilver> make_coffee, grind_beans, buy_beans
07:58:05 <quicksilver> then people can just use those functions
07:58:12 <quicksilver> it's a bit like a minilanguage, but not much :)
07:58:15 <quicksilver> mostly it looks like haskell
07:58:35 <quicksilver> then if you add some ways of combining them, especially if you define custom operators, it looks much more like a minilanguage
07:58:52 <quicksilver> ...and less like haskell
08:00:53 <chessguy> whereas if you start involving parsec or regexes, it's more like a full DSL?
08:01:28 <Daveman> Hi Chessguy :)
08:01:46 <chessguy> yo!
08:01:51 <ClaudiusMaximus> @instances Monad
08:01:52 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:02:04 <ClaudiusMaximus> then how come i get     "No instance for (Monad ((->) b))"
08:02:20 <ClaudiusMaximus> (what do i need to import?)
08:02:33 <mux> maybe Control.Monad?
08:02:33 <chessguy> ?hoogle (->)
08:02:34 <lambdabot> Did you mean: (->)
08:02:34 <lambdabot> Prelude.undefined :: a
08:02:34 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:02:35 <mux> just a guess
08:02:37 * Igloo shakes his fist at the English language
08:02:45 <Igloo> I need to write   let age age = age + 1
08:03:02 <DukeDave> !logs
08:03:08 <DukeDave> @logs
08:03:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:03:50 <Igloo> It's in the topic: http://tunes.org/~nef/logs/haskell/
08:03:51 <lambdabot> Title: Index of /~nef/logs/haskell
08:04:01 <chessguy> quicksilver, what would you consider to be a good example of a full-fledged DSL/
08:04:02 <chessguy> ?
08:04:23 <ClaudiusMaximus> mux: nope, not Control.Monad :(
08:05:04 <quicksilver> chessguy: I'm trying to suggest it's not a clear line. But Fudgets would be an example, I think
08:05:19 <chessguy> ClaudiusMaximus, try Control.Arrow
08:05:19 <vincenz> the difference between 'DSL' and 'combinator library' is mostly syntax in a language that allows you to change semantics so much
08:05:31 <DukeDave> Cheers :)
08:05:38 <chessguy> quicksilver, that's why i made it clear i was asking for your opinion
08:06:01 <mux> ClaudiusMaximus: sorry then
08:06:11 <quicksilver> chessguy: there was a music combinator library I saw once but google can't find for me
08:06:21 <vincenz> Igloo: let deteriorate age = age + 1
08:06:37 <quicksilver> chessguy: in fact, I'd argue that even HOpenGL is a DSL
08:06:38 <chessguy> i thought fudgets was considered deprecated
08:06:40 <ClaudiusMaximus> chessguy: nope, not Control.Arrow either (at least it doesn't work in ghci - still get the same error)
08:06:44 <Eelis> chessguy: i think something like roconnor's assembly-language-in-haskell from the monad.reader issue 6 might qualify
08:06:53 <quicksilver> chessguy: albeit, one which is mixed in with haskell
08:07:20 <quicksilver> chessguy: being deprecated doesn't make it less a DSL though :)
08:07:27 <mux> quicksilver: http://doc.gold.ac.uk/~ma503am/alex/haskellmusic ?
08:07:30 <lambdabot> Title: Haskell music | Alex McLean
08:07:45 <chessguy> ok, just wondered because this is the second reference to Fudgets i've heard in 2 days
08:08:44 <Syzygy-> I remember that music library too.... It had a weirdly placed k in the name
08:08:46 <quicksilver> fran would be another, I suppose
08:08:59 <Syzygy-> Haskore
08:09:13 <chessguy> i guess what got me thinking about it was the example DSLs in HSOE
08:09:25 <chessguy> they seem more like combinator libraries to me, but i guess it's a matter of opinion
08:09:32 <quicksilver> mux: not the one I meant, but yes I agree
08:09:33 <vincenz> hence EDSL
08:09:36 <vincenz> embedded DSL
08:10:35 <quicksilver> chessguy: if you look at mux's screen cast, one of the interesting points is that a 'program' has a list type []
08:10:56 <quicksilver> whereas I supose for standard haskell, in some sense, a program has type IO ()
08:11:14 <quicksilver> so it amounts to having a different bootstrap to launch the app
08:11:38 <chessguy> quicksilver, you're looking at the actual code?
08:11:38 <ehird> hmm.. lambdabot should be the advisor for the Prelude. liftM2 = (`fmap` m2) . f =<< m1 is a bit shorter than the prelude version :p
08:12:04 <quicksilver> chessguy: the screencast shows you the code :)
08:12:10 <quicksilver> it's a screencast of an xemacs session
08:12:19 <vincenz> quicksilver: link?
08:12:26 <chessguy> oh, i see what you're saying
08:12:32 <quicksilver> http://doc.gold.ac.uk/~ma503am/alex/haskellmusic
08:12:33 <lambdabot> Title: Haskell music | Alex McLean
08:13:06 <benja_> hmm, what's the right way to delete a file from haskell?
08:13:21 <vincenz> lol
08:13:35 <benja_> I was expecting there to be System.IO.deleteFile or some such, but apparently I'm misguided? =)
08:13:40 <vincenz> quicksilver: I started it, put on my headphones and was like, WOW this is good music, then I realizedd xmms was still playing
08:13:49 <Igloo> vincenz: Ta, but someone elsewhere suggested "wither", which is too cool a word not to use  :-)
08:13:55 <vincenz> Igloo: true :)
08:14:11 <vincenz> Igloo: or wither `and` die
08:14:12 <quicksilver> vincenz: I watched it with the sound off :)
08:15:58 <quicksilver> benja_: System.Directory.removeFile
08:16:06 <chessguy> Igloo, what are you working on, skynet? :)
08:16:50 <Igloo> chessguy: buildbot report collator
08:17:01 <chessguy> naturally
08:25:05 <benja_> quicksilver: thanks
08:52:19 <vincenz> bringert++
08:52:46 <greenrd> Is there anything that generalises join?
08:53:00 <vincenz> greenrd: uhm?
08:53:09 <vincenz> greenrd: generalizes in what sense?
08:53:33 <greenrd> in the sense of being applicable to more things than just monads
08:53:40 <greenrd> not quite sure what such a thing would be
08:54:00 <vincenz> seems rather generic to me already :)
08:55:15 <nmessenger> monads are special in that they *add* join/bind and return to functors.
08:56:03 <quicksilver> note that bind is derivable from join + return + fmap
08:56:20 <quicksilver> and join + return are both rather natural
08:56:34 <quicksilver> you could ask for the name of the structure which had join + return but not fmap, I think
08:56:42 <quicksilver> that would be slightly more general
08:56:56 <greenrd> For Maybe and [], join is kind of a flattening operation
08:56:59 <nmessenger> too bad Monad doesn't inherit Functor, so it can't derive (>>=) from fmap/join :(
08:57:18 <quicksilver> but categorists probably wouldn't be interested in it because it wouldn't be a functor
08:57:20 <nmessenger> greenrd: for all monads, join is a kind of flattening operation
08:58:42 <greenrd> For Tree, which is not a Monad, genericJoin could be :: Tree (Tree a) -> Tree a and could turn the trees at each node into child nodes of that node
08:58:53 <greenrd> So there's a concrete example (if rather contrived)
08:59:06 <quicksilver> that would be a monad, though :)
08:59:27 <quicksilver> it has obvious definitions of return + fmap
08:59:30 <quicksilver> so it's a monad
09:00:26 <greenrd> But does it satisfy the monad laws?
09:00:40 <quicksilver> yes
09:01:02 <greenrd> ok
09:01:05 <quicksilver> I shall prove it by waving my hands around and drawing an intimidating square and two triangles on the blackboard
09:01:08 <greenrd> haha
09:01:11 <quicksilver> (but seriously, it is)
09:01:30 <quicksilver> most (all?) sensible notions of 'structured collection' are monads
09:03:56 <vincenz> Igloo: sorry to ask again, what was the link for "building from sources"
09:04:35 <vincenz> Igloo: ah found it, it's on the wiki
09:06:45 <kolmodin> vincenz: for ghc? http://hackage.haskell.org/trac/ghc/wiki/Building
09:06:48 <lambdabot> Title: Building - GHC - Trac
09:06:55 <vincenz> thx
09:09:52 <vincenz> darcs failed:  Failed to download URL http://darcs.haskell.org/ghc/_darcs/inventories/20060407130411-26c35-3da169c78cee55d4c7c6dcc89487625174c73ee8.gz
09:09:54 <lambdabot> http://tinyurl.com/29obac
09:09:55 <vincenz> libcurl: HTTP error (404?)
09:11:05 <hyrax42> ?where scheck
09:11:06 <lambdabot> I know nothing about scheck.
09:11:15 <hyrax42> ?where smallcheck
09:11:15 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
09:11:39 <kolmodin> vincenz: weird
09:12:04 <vincenz> might be my proxy
09:22:41 <SimonRC> Is there a function a bit like groupBy that will also do things like:   [1,2,3,2,3,1] ---> [[1,1],[2,2],[3,3]]    i.e. re-order things?
09:23:00 <SimonRC> I cannot sort as the things I am working with are not an instance of Ord
09:23:01 <glguy> group . sort
09:23:10 <glguy> :)
09:23:21 <jyasskin> sortBy?
09:23:40 <SimonRC> hmm, I suppose I could
09:23:55 <glguy> ?src nubBy
09:23:56 <lambdabot> nubBy eq []             =  []
09:23:56 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:24:12 <glguy> ?src groupBy
09:24:12 <lambdabot> groupBy _  []       =  []
09:24:12 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:24:12 <lambdabot>     where (ys,zs) = span (eq x) xs
09:24:24 <SimonRC> ?src (:)
09:24:24 <lambdabot> Source not found. It can only be attributed to human error.
09:24:36 <glguy> (:) is a dataconstructor
09:24:41 <SimonRC> I know
09:24:43 <SimonRC> hehehe
09:24:47 <SimonRC> ?src (+)
09:24:47 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:24:49 <earthy> hm. Data.Time doesn't have week code, does it?
09:24:50 <glguy> ?src Num
09:24:50 <chessguy> ?hoogle (:)
09:24:51 <lambdabot> class  (Eq a, Show a) => Num a  where
09:24:51 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:24:51 <lambdabot>     negate, abs, signum     :: a -> a
09:24:51 <lambdabot>     fromInteger             :: Integer -> a
09:24:51 <lambdabot> Did you mean: (:)
09:24:53 <lambdabot> Prelude.undefined :: a
09:24:55 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
09:25:09 <glguy> ?src []
09:25:09 <lambdabot> data [] a = [] | a : [a]
09:25:11 <glguy> so you need that
09:25:30 * nmessenger thinks @src <constructor> should show the datatype source.
09:26:16 <chessguy> nmessenger, there's a lot about @src, @source, and @hoogle (at least) that need some attention
09:26:28 <vincenz> why is Show required for Nunm
09:26:37 <vincenz> seems a bit arbitrary
09:26:44 <nmessenger> vincenz: because it's evil?
09:26:48 <vincenz> or Eq for that matter
09:26:50 <glguy> vincenz: aparently its just there to make debugging easier
09:27:00 <vincenz> glguy: which si great when you have numbers that are hard to show :)
09:27:11 <quicksilver> it's very useful to be able to assume you can show numbers, I think
09:27:21 <vincenz> quicksilver: sure, numbers
09:27:27 <vincenz> who's talking about numbers?
09:27:33 <quicksilver> but there are many ways in which that class is poorly designed for extension
09:27:42 <vincenz> yep
09:27:52 <vincenz> we need a good linear-algebra-founded set of classes
09:27:54 <vincenz> Ring, Group, etc...
09:28:10 <vincenz> with Num being somewheere at the top
09:28:46 <doserj> @where numericprelude
09:28:46 <lambdabot> darcs.haskell.org/numericprelude/
09:30:02 * ddarius would not consider those linear algebra founded.
09:33:20 <quicksilver> it is possible to get rather stupid with axioms though
09:33:45 <quicksilver> there are many many combinations of [LeftUnit,RightUnit,Associative,Commutative]
09:34:03 <quicksilver> oh, and [Zero]
09:34:14 <quicksilver> well that's the other operation, really
09:34:16 <vincenz> doserj: very nice
09:34:38 * ehird sings a song along the lines of "ghc takes hours to compile"
09:34:52 <doserj> well, the class system in haskell is not perfect...
09:35:31 <jyasskin> The class system in Fortress has some interesting features along those lines.
09:35:50 <quicksilver> see also john meacham's class alias proposal
09:35:54 <ClaudiusMaximus> @quote compilation
09:35:55 <lambdabot> No quotes match. The more you drive -- the dumber you get.
09:36:00 <ddarius> ehird: Just put Inna Gadda Da Vidda in
09:36:01 <quicksilver> it seemed eminently sane to me, but maybe there was a hole in it
09:36:26 <ehird> ddarius: i probably  shouldn't be compiling it silently
09:36:43 <ehird> the last line on the terminal for ages has been --->  Building ghc with target all
09:36:57 <ClaudiusMaximus> i will be needing to compile ghc for a linux distro that doesn't yet have a ghc package at some point soon, which should be somewhat interesting
09:37:04 <jyasskin> ehird: `port -v` is very important to keep your sanity. ;)
09:37:18 <ehird> no, port -d
09:37:22 <ehird> port -d is above all others
09:37:26 <ehird> i need pages of useless otuput
09:37:35 <cjeris> ehird: there's a little italian man with a sausage grinder in there, grinding away.  but since the art of sausage making is dying out, he is sadly an old italian man, and has no son to turn the sausage grinder with him.  but it goes slowly.
09:37:56 <ehird> cjeris: that's nice
09:38:10 <quicksilver> ehird: it took me 8 hours to compile ghc with port install :)
09:38:42 <ehird> quicksilver: core 2 duo powah
09:38:47 <ehird> POWAH
09:38:48 <nmessenger> remember cjeris [on compiling ghc] there's a little italian man with a sausage grinder in there, grinding away.  but since the art of sausage making is dying out, he is sadly an old italian man, and has no son to turn the sausage grinder with him.  but it goes slowly.
09:38:55 <nmessenger> @remember cjeris [on compiling ghc] there's a little italian man with a sausage grinder in there, grinding away.  but since the art of sausage making is dying out, he is sadly an old italian man, and has no son to turn the sausage grinder with him.  but it goes slowly.
09:38:56 <lambdabot> Done.
09:39:06 <glguy> @quote
09:39:07 <lambdabot> procyon_ says: God told me that if I didn't stop asking him such questions he would revoke my state monad.
09:39:11 <nmessenger> @bot?
09:39:11 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
09:39:31 <ehird> @pl m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
09:39:32 <lambdabot> (`fmap` m2) . f =<< m1
09:39:39 <nmessenger>  @REMEMBER'D
09:40:52 <nmessenger> liftM2 f x y = liftM f x `ap` y
09:40:52 <doserj> quicksilver: I'm not sure how the definitions in the class alias, the instance declarations for the alias and the intance declaration for the consituents relate.
09:41:10 <ehird> nmessenger: lambdabot's is better because it's entirely done by a machine :)
09:41:20 <quicksilver> doserj: AIUI, you can choose either to give instance decls for the alias, or the underlying classes
09:41:22 <ehird> @undo, @pl, wow that didn't need to be so complex
09:41:22 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) "Parse error"
09:41:26 <ehird> er
09:41:37 <quicksilver> doserj: whichever you do is the same
09:41:56 <quicksilver> doserj: the alias can provide something like a 'default' implementation which ties together some methods if it wants to
09:42:06 <chessguy> @unpl (`fmap` m2) . f =<< m1
09:42:07 <lambdabot> (m1 >>= \ d -> fmap (f d) m2)
09:42:19 <ehird> less impressive :P
09:42:21 <ehird> @pl liftM2 f x y = liftM f x `ap` y
09:42:21 <lambdabot> liftM2 = liftM2
09:42:23 <ehird> heh
09:42:32 <ehird> lambdabot enjoys doing "preludefunc = preludefunc" on @pl
09:42:37 <doserj> quicksilver: what if i have an instance for one of the underlying classes, and for the alias?
09:42:40 <chessguy> @unpl liftM2
09:42:40 <lambdabot> (\ c d e -> d >>= \ b -> e >>= \ a -> return (c b a))
09:42:52 <ehird> @src liftM2
09:42:52 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:42:56 <ehird> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:42:57 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
09:43:01 <ehird> @pl m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
09:43:01 <lambdabot> (`fmap` m2) . f =<< m1
09:43:10 <nmessenger> :)
09:43:16 <opqdonut> :)
09:43:50 <DukeDave> Smart people!
09:44:05 <ehird> @unpl fac = product (. enumFromTo 1)
09:44:05 <lambdabot> fac = product (\ a d -> a (enumFromTo 1 d))
09:44:11 <ehird> heh
09:44:16 <DukeDave> I have a "I think it's probably buffering but I can't put my figure on it" one...
09:45:32 <nmessenger> @type product (. enumFromTo 1) -- I think probably you meant without the parens
09:45:34 <lambdabot>     The section `(. (enumFromTo 1))' takes one argument,
09:45:35 <lambdabot>     but its type `[a]' has none
09:45:52 <jyasskin> Re class aliases: If I have class Num where fromInteger = ..., I don't see a definition for `zero` from Additive.
09:46:10 <jyasskin> Sorry, "instance Num MyNum where fromInteger = ..."
09:47:05 <jyasskin> No, I'm confused. I don't see the type declaration for fromInteger in Num's class alias.
09:47:12 <opqdonut> @. pl undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:47:12 <lambdabot> (`fmap` m2) . f =<< m1
09:47:16 <opqdonut> ehird: ^_^
09:47:25 <ehird> oh cool
09:47:32 <opqdonut> yeah lambdabot wins
09:47:42 <ehird> @. pl unpl (`fmap` m2) . f =<< m1
09:47:42 <lambdabot> flip fmap m2 . f =<< m1
09:47:48 <nmessenger> lambdabot++
09:47:56 <ehird> lambdabot is fun
09:48:04 <ehird> @pl flip fmap m2 . f =<< m1
09:48:04 <lambdabot> flip fmap m2 . f =<< m1
09:48:05 <hpaste>  DukeDave pasted "Confusion - try it at home  :(" at http://hpaste.org/1069
09:48:11 <ehird> @unpl flip fmap m2 . f =<< m1
09:48:12 <lambdabot> (m1 >>= \ g -> fmap (f g) m2)
09:48:18 <ehird> @pl(m1 >>= \ g -> fmap (f g) m2)
09:48:18 <lambdabot> Unknown command, try @list
09:48:19 <nmessenger> hmm, (`blah` x) to flip blah x
09:48:22 <ehird> @pl (m1 >>= \ g -> fmap (f g) m2)
09:48:22 <lambdabot> flip fmap m2 . f =<< m1
09:48:33 <ehird> @pl foldl
09:48:34 <lambdabot> foldl
09:48:36 <ehird> er
09:48:44 <ehird> @. pl src foldl
09:48:44 <lambdabot> (line 1, column 1):
09:48:44 <lambdabot> unexpected end of input
09:48:44 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
09:48:47 <ehird> :(
09:50:43 <ehird> sequence_ = foldr (>>) return
09:51:42 <doserj> quicksilver: if i understand correctly, when you have an instance of one of the underlying classes, you cannot give an instance of the class alias anymore
09:51:56 <ehird> @src sequence
09:51:57 <lambdabot> sequence ms = foldr k (return []) ms
09:51:57 <lambdabot>     where
09:51:57 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
09:52:03 <doserj> because that would result in duplicate instance definitions.
09:52:05 <ehird> k could be replaced with k = liftM2 (:)
09:52:09 <ehird> according to lb :P
09:52:13 <nmessenger> ehird: yep
09:52:28 <nmessenger> ehird: but liftM2 isn't visible in Prelude
09:52:31 <ehird> aww
09:52:37 <doserj> so you would then have to instantiate all other underlying classes by hand
09:52:49 <nmessenger> ehird: that'd cause a dependency cycle
09:52:51 <ehird> i was about to suggest all ghc/hugs code filtered through @pl by darcs on commit haha
09:53:05 <doserj> I'm not sure how much a problem that would be
09:54:00 <ehird> meanwhile, "sequence = foldr (liftM2 (:)) (return [])" wins prize for "most shortened by .", with the @unpl'd version being "sequence = foldr (\ d e -> d >>= \ b -> e >>= \ a -> return ((:) b a)) (return [])"
09:54:46 <quicksilver> doserj: yes, I think that's right
09:54:55 <quicksilver> doserj: but you still 'have' an instance of the alias
09:55:09 <quicksilver> doserj: assuming you provide an instance of the other underlyings
09:55:15 <doserj> true
09:55:32 <DukeDave> hey guys, how would I use hsetBuffering?
09:55:52 <ehird> STILL compiling
09:56:02 <quicksilver> hSetBuffering stdout NoBuffering
09:56:05 <quicksilver> IIRC
09:56:17 <nmessenger> @type let (f >=> g) x = f x >>= g in foldr (>=>) return
09:56:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a -> m a] -> a -> m a
09:56:50 <DukeDave> where does the handle stdout come from?
09:57:01 <nmessenger> @index stdout
09:57:02 <lambdabot> System.IO
09:57:02 <quicksilver> it's in the prelude, I think
09:57:22 <DukeDave> Ah, who could have thought :)
09:57:41 <glguy> is there a more obvious way to do this: sortUsing xs ys = map fst . sortBy (comparing snd) $ zip xs ys
09:57:42 <chessguy> @help index
09:57:42 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
09:57:53 <chessguy> @index Gen
09:57:54 <lambdabot> Test.QuickCheck, Debug.QuickCheck
09:58:07 <doserj> quicksilver: anyways, someone should just implement it so one can find out how it works out in practice
09:58:10 <sjanssen> glguy: looks obvious to me
09:58:10 <ehird> foldr = fix (\ ae bg _ -> (\ r _ -> bg (head r) (ae ys)) >>= \ aw -> tail >>= \ av -> return (aw av)) <-- lambdabot wins obfuscated haskell contents
09:58:12 <ehird> *contest
09:58:49 <chessguy> @type \xs ys -> map fst . sortBy (comparing snd) $ zip xs ys
09:58:51 <lambdabot> forall a b. (Ord b) => [a] -> [b] -> [a]
09:58:53 <nmessenger> fix++
09:59:22 <nmessenger> @pl \xs -> map fst . sortBy (comparing snd) . zip xs
09:59:22 <lambdabot> ((map fst . sortBy (comparing snd)) .) . zip
10:00:10 <DukeDave> oh my God
10:00:27 <DukeDave> 5hours 58mins  :)
10:00:48 <ehird> me
10:00:53 <DukeDave> I think I need a beer :)
10:00:54 <ehird> wtf
10:00:56 <ehird> @src do
10:00:56 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:01:01 <ehird> didn't think do was a func :P
10:01:07 <nmessenger> @type StateT . (return.) . runState -- is there a general version of this anywhere?
10:01:10 <chessguy> ?hoogle do
10:01:10 <lambdabot> forall (m :: * -> *) s a. (Monad m) => State s a -> StateT s m a
10:01:11 <lambdabot> Prelude.do :: keyword
10:01:11 <lambdabot> Directory.doesDirectoryExist :: FilePath -> IO Bool
10:01:11 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
10:01:42 <ehird> forall (m :: * -> *) s a. (Monad m) => State s a -> StateT s m a looks nice and scary
10:01:45 <ehird> @pl forall (m :: * -> *) s a. (Monad m) => State s a -> StateT s m a
10:01:45 <lambdabot> (line 1, column 14):
10:01:46 <lambdabot> unexpected "*"
10:01:46 <lambdabot> expecting space or simple term
10:01:52 <ehird> oh wait
10:01:54 <ehird> it's a type def
10:01:58 <nmessenger> ehird: ignore the parts before => and it's not so bad
10:01:59 <ehird> @src forall
10:01:59 <lambdabot> Source not found. Do you think like you type?
10:02:06 <Lemmih> nmessenger: lift?
10:02:07 <ehird> @src for
10:02:07 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:02:12 <ehird> @src forANYTHING
10:02:12 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:02:21 <ehird> @src putStr
10:02:21 <lambdabot> putStr s  = hPutStr stdout s
10:02:21 <ehird> @src hPutStr
10:02:21 <lambdabot> Source not found. You speak an infinite deal of nothing
10:02:23 <ehird> aw
10:02:29 <ehird> @hoogle hPutStr
10:02:29 <lambdabot> IO.hPutStr :: Handle -> String -> IO ()
10:02:30 <lambdabot> IO.hPutStrLn :: Handle -> String -> IO ()
10:02:37 <nmessenger> Lemmih: not quite, lift puts an action into a transformer, this function promotes an action to its transformed version.
10:02:51 <ehird> @src +
10:02:52 <lambdabot> Source not found. It can only be attributed to human error.
10:02:54 <ehird> @src (+)
10:02:54 <lambdabot> Source not found. stty: unknown mode: doofus
10:03:15 <sjanssen> ehird: lambdabot re
10:03:21 <sjanssen> sponds to private messages
10:03:31 <nmessenger> State s a -> StateT s m a -- by returning into an arbitrary m
10:03:34 <Lemmih> nmessenger: 'its transformed version' is not a clearly defined concept.
10:04:17 <nmessenger> Lemmih: I figured as much, but there is a MonadTrans class, I was wondering if there was a MonadPromote class or something
10:04:42 <vincenz> nmessenger: no, only ManagerPromote
10:04:54 <vincenz> with a unique instance
10:04:59 <vincenz> instance ManagerPromote Self where
10:05:15 <nmessenger> class MonadPromote t m | t -> m where promote :: Monad n => m a -> t n a -- or something, I'm not sure about fundeps
10:05:40 <nmessenger> thus instance MonadPromote (StateT s) (State s) where ...
10:06:18 <nmessenger> basically inserts a return in the appropriate place.
10:06:34 <nmessenger> not sure if this'd be possible/useful
10:08:21 <sjanssen> nmessenger: you probably want m -> t instead
10:08:55 <nmessenger> sjanssen: isn't BaseMonad -> BaseMonadT essentially a one-to-many relationship?
10:09:40 <sjanssen> BaseMonad a -> BaseMonadT m a -- is not
10:10:17 <ddarius> No, I agree more with nmessenger.
10:10:23 <sjanssen> s/m/n
10:10:27 <nmessenger> I think I could understand that an arbitrary MonadT is only based on one monad, but an arbitrary monad might have different MonadT's
10:10:29 <vincenz> I agree with sjanssen
10:10:46 <vincenz> nmessenger: no you typically have one T
10:10:53 <nmessenger> typically, yes
10:10:58 <ddarius> There are different ways of promoting, say State to a different transformers.
10:11:00 <vincenz> for very large values of typically
10:11:03 <sjanssen> nmessenger's approach will have significant type inference issues
10:11:25 <ddarius> Really, it's probably many-to-many, but that's likely not very convenient.
10:12:07 <sjanssen> so you want the ability to promote State s into ReaderT a (State s)?
10:12:35 <nmessenger> hmm, intriguing
10:12:53 <sjanssen> that's the only reason I can imagine for having the fundep in your direction
10:13:30 <nmessenger> Does that match promote's type?
10:13:37 <kmg> how to create a static binary from a .hs file using ghc ?
10:13:51 <ehird> It's STILL compiling!
10:13:51 <sjanssen> but if you really want that, you're going to have to skip the fundep altogether, because that clashes with the obvious instance for Reader/ReaderT
10:13:55 <ehird> kmg: Don't think you can
10:13:57 <ehird> not sure
10:13:57 <ddarius> sjanssen: Cont (State r) a
10:13:58 <ehird> ghc --help
10:14:46 <nmessenger> sjanssen: I don't understand how that unifies with promote's type.  What are m, t, and n?
10:15:08 <sjanssen> ddarius: that doesn't match promote's type
10:15:17 <ehird> WOOT COMPILED
10:15:18 <sjanssen> nmessenger: you're correct, it doesn't unify
10:15:22 <ddarius> sjanssen: It can be made to with ContT
10:15:23 <kmg> ghc -static doesnt do it ?
10:15:34 <ehird> kmg: presumably it does
10:15:54 <sjanssen> ddarius: but then the fundep clashes with the "obvious" instance for Cont -> ContT
10:16:09 <ddarius> As I suggested, no fundeps seems most accurate.
10:16:39 <nmessenger> I've only very little intuition on what the fundep does.
10:16:51 <ddarius> Another case is State-like newtyped Monads.
10:17:11 <ClaudiusMaximus> kmg: ghc-6.4.2 links mostly-statically by default (at least, the binary i made only links to:         linux-gate.so.1 =>  (0xffffe000)        libm.so.6 => /lib/libm.so.6 (0xb7839000)        libgmp.so.3 => /usr/lib/libgmp.so.3 (0xb7804000)        libdl.so.2 => /lib/libdl.so.2 (0xb7800000)        libc.so.6 => /lib/libc.so.6 (0xb76d9000)        /lib/ld-linux.so.2 (0x80000000)    )
10:17:24 <ddarius> nmessenger: t -> m is read as "t determines m" which is mostly self-explanatory.  If you know what t is then you know what m is.
10:17:51 <sjanssen> I think the goal of promote is more narrow.  promote transforms some monad to its corresponding transformed version
10:18:26 <nmessenger> sjanssen: was your "it doesn't unify" re: Cont (State r) a or ReaderT a (State s)?  I was asking about the latter.
10:18:59 <sjanssen> nmessenger: both the Cont and the ReaderT examples are bad ones
10:19:04 <ddarius> sjanssen: Presumably, though, in theory, there isn't a canonical "transformer" for some monad.
10:19:18 <sjanssen> ddarius: but there is, in practice
10:19:57 <nmessenger> perhaps it is a good restriction, though, in practice.  Different promotes could be implemented by newtyping the base monad.
10:21:14 <sjanssen> imagine that newtype State s a = State (StateT s Identity a)
10:21:19 <nmessenger> *shrug*
10:21:37 <sjanssen> then promote becomes the function that swaps Identity for any monad
10:21:44 <nmessenger> cool!
10:21:55 <desp> I have a question regarding lazy evaluation and the FFI
10:22:50 <sjanssen> fire away
10:22:57 <greenrd> Is there a tool which can remove all unnecessary parentheses from a piece of Haskell code?
10:23:05 <desp> is the foreign function returning a String supposed to have the whole String ready at the moment its called?
10:23:25 <greenrd> I am mainly interested in removing parentheses which are not needed due to operator precedence
10:23:50 <ehird> lambdabot :)
10:23:52 <ClaudiusMaximus> @. unpl pl  \a b -> ((((((a + b)))))
10:23:52 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}: Parse error
10:23:54 <nmessenger> greenrd: I'm not sure of anything automated.  There's always the delete key :D
10:23:56 <ehird> @. pl unpl ismilar
10:23:56 <lambdabot> ismilar
10:24:00 <ehird> er.
10:24:02 <ehird> similar
10:24:09 <ehird> @pl  \a b -> ((((((a + b)))))
10:24:10 <lambdabot> (line 1, column 25):
10:24:10 <lambdabot> unexpected end of input
10:24:10 <lambdabot> expecting variable, "(", operator or ")"
10:24:12 <sjanssen> desp: the transformation between C string (char *) and Haskell [Char] will happen immediately
10:24:15 <ehird> @pl  (\a b -> ((((((a + b))))))
10:24:15 <ClaudiusMaximus> @. unpl pl  (\a b -> ((((((a + b)))))))
10:24:15 <lambdabot> (line 1, column 27):
10:24:15 <lambdabot> unexpected end of input
10:24:15 <lambdabot> expecting variable, "(", operator or ")"
10:24:16 <lambdabot> (+)
10:24:20 <ehird> @pl  (\a b -> ((((((a + b))))))
10:24:20 <lambdabot> (line 1, column 27):
10:24:20 <lambdabot> unexpected end of input
10:24:22 <lambdabot> expecting variable, "(", operator or ")"
10:24:23 <ehird> @pl  (\a b -> ((((((a + b)))))))
10:24:24 <glguy> greenrd: if you don't know the operator precedence well enough to do it yourself, you might want to leave them there so you know what the code does?
10:24:24 <lambdabot> (+)
10:24:30 <ehird> @. unpl pl  (\a b -> ((((((a + b)))))))
10:24:30 <lambdabot> (+)
10:24:33 <ehird> heh.
10:24:38 <ehird> @. pl unpl  (\a b -> ((((((a + b)))))))
10:24:39 <lambdabot> (+)
10:24:44 <ehird> @. unpl  (\a b -> ((((((a + b)))))))
10:24:44 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: ""
10:24:48 <ehird> @unpl  (\a b -> ((((((a + b)))))))
10:24:49 <lambdabot> (\ a b -> a + b)
10:24:55 <ehird> whee.
10:24:55 <desp> er
10:25:00 <greenrd> hehe
10:25:01 <desp> is such spamming really necessary?
10:25:06 <nmessenger> @unpl (1 * 2) + (3 * 4)
10:25:06 <lambdabot> ((1 * 2) + (3 * 4))
10:25:13 <ehird> desp: yes
10:25:19 <nmessenger> @slap ehird
10:25:19 * lambdabot beats up ehird
10:25:23 <ehird> @pl 2 + 2 + 2
10:25:23 <lambdabot> 6
10:25:29 <ehird> that's one way of doing it
10:25:31 <nmessenger> lol!
10:25:33 <greenrd> but @pl doesn't necessarily know the operator precedence of, say, an operator I defined myself
10:25:36 <sjanssen> ehird: please use /msg lambdabot if you need to do so many queries in a row
10:25:49 <desp> sjanssen: perhaps I should rephrase my question -- do you know if it's possible to write a foreign function that returns a value "in several tries"
10:26:14 <desp> sjanssen: like an infinite list is calculated only when needed
10:26:59 <sjanssen> desp: does the foreign library have some sort of "chunk" mechanism, that let's you grab portions at a time?
10:27:08 <glguy> I hate wireless keyboards!
10:27:44 <desp> sjanssen: something like that. if a chunk is not ready, it would need to block until it is.
10:28:35 <sjanssen> desp: it's hard to say without knowing the exact function you're trying to wrap.  There isn't an automagic way to turn a strict C function into a lazy Haskell function
10:29:16 <desp> sjanssen: let's say I'm simply reading a text file in C.
10:29:34 <desp> but I don't want to read it in one go, and pass the whole block to Haskell
10:29:52 <desp> I want Haskell to query me for characters when the need arises
10:29:54 <desp> is that doable?
10:30:12 <desp> (ignoring the practicality of such an approach)
10:30:43 <ddarius> glguy: Why?
10:30:50 <sjanssen> desp: say you have the C function: int get_n(handle the_handle, char *buffer, int buffer_len)
10:31:09 <sjanssen> (that function returns the actual number of bytes read)
10:31:11 <vincenz> sjanssen: make a lazy list of get_ns
10:31:14 <vincenz> :)
10:31:31 <sjanssen> desp: then you use unsafeInterleaveIO to gradually call the C function
10:31:53 <glguy> ddarius: they are more likely to miss keystrokes (especially with all the metal in this desk) and they support fewer simultaneous keypresses, generally
10:32:09 <ddarius> glguy: Hmm.
10:32:16 <desp> sjanssen: I see, thanks
10:32:20 <vincenz> wireless keyboard was my biggest moneywaste ever
10:32:20 * ddarius was thinking about getting a Bluetooth keyboard sooner or later.
10:32:29 <glguy> I didn't want a wireless
10:32:36 <desp> sjanssen: do you know any FFI tutorials/sample code?
10:32:45 <glguy> but the keyboard that felt best to type on at the store I went to was wireless
10:32:48 <glguy> and I was tired of looking around
10:32:54 <ddarius> Use codata!
10:32:54 <desp> sjanssen: best thing I found is http://web.archive.org/web/20050405061827/www.reid-consulting-uk.ltd.uk/docs/ffi-Compiling_Linking.html
10:32:59 * ddarius walks away.
10:33:00 <lambdabot> Title: Compiling and Linking, http://tinyurl.com/34ez9k
10:33:19 <sjanssen> desp: I learned my FFI via osmosis and the FFI report (which is suprisingly readable)
10:33:23 <sjanssen> @google haskell ffi report
10:33:25 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
10:33:25 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0 An Addendum to the Haskell 98 Repo ...
10:33:38 <desp> right, I am reading it, but it lacks example goodness
10:34:40 <ehird> foldM = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . liftM2 flip ((flip . (((.) . (>>=)) .)) .) . (flip .)) <-- Now that's cool
10:34:47 <sjanssen> desp: you should look into Data.ByteString and Data.ByteString.Lazy if you want to lazily get bytes from a C function
10:34:58 <desp> right
10:35:05 <nmessenger> @quote flip.?stream
10:35:05 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
10:35:22 <ehird> heh
10:37:13 <quicksilver> desp: there were good FFI examples on -cafe recently
10:37:24 <ehird> unpl doubles up as a lambda-stream: "liftM2 p b c = b >>= \ j -> fmap (p j) c"
10:37:50 <desp> quicksilver: I guess I should probably subscribe, then
10:37:51 <desp> ;]
10:39:11 <quicksilver> desp: http://groups.google.co.uk/group/fa.haskell/browse_thread/thread/3a4e29bc703132a0/3e949a48090d44f7?lnk=st&q=haskell-cafe+FFI+basics&rnum=1&hl=en#3e949a48090d44f7
10:39:14 <lambdabot> Title: FFI basics - fa.haskell | Google Groups, http://tinyurl.com/27fx48
10:39:19 <desp> thank you!
10:39:34 <desp> quicksilver++
10:43:43 <ehird> (^^) = (\ q y -> ((\ f -> f >= 0) >>= \ b -> ((^) q) >>= \ a -> return (if' b a)) >>= \ v -> y >>= \ u -> return (v u)) >>= \ j -> (\ ac ai -> recip (ac ^ (negate ai))) >>= \ i -> return (j i)
10:43:46 <vincenz> nested where clauses are permissible?
10:43:58 <ehird> it's beautiful
10:44:14 <Cheery> I have a little problem here.
10:44:21 <nmessenger> > let x = y where {y = z where z = 1} in x
10:44:22 <lambdabot>  1
10:44:35 <ehird> how amazing
10:44:37 <ehird> :P
10:44:50 <vincenz> nmessenger: thx
10:45:02 <Cheery> when I compile my program, the half screen does not get drawn.
10:45:11 <Cheery> while it works perfectly in ghci.
10:45:17 <Cheery> what's going on here?
10:45:46 <quicksilver> vincenz: the body of a where clause is 'declarations' and declarations may have where clauses
10:45:52 <quicksilver> vincenz: not necessarily good styl, though :)
10:46:18 <ehird> > let upup = (\ q y -> ((\ f -> f >= 0) >>= \ b -> ((^) q) >>= \ a -> return (if' b a)) >>= \ v -> y >>= \ u -> return (v u)) >>= \ j -> (\ ac ai -> recip (ac ^ (negate ai))) >>= \ i -> return (j i) in upup 5 5
10:46:19 <lambdabot>   Not in scope: `if''
10:46:24 <ehird> odd
10:46:28 <vincenz> quicksilver: it is in this case :)
10:46:31 <nmessenger> if' b t f = if b then t else f
10:47:05 <nmessenger> > let if' b t f = if b then t else f; upup = (\ q y -> ((\ f -> f >= 0) >>= \ b -> ((^) q) >>= \ a -> return (if' b a)) >>= \ v -> y >>= \ u -> return (v u)) >>= \ j -> (\ ac ai -> recip (ac ^ (negate ai))) >>= \ i -> return (j i) in upup 5 5
10:47:06 <lambdabot>  3125.0
10:47:10 <ehird> hah
10:47:12 <nmessenger> upup?
10:47:17 <CosmicRay> does anybody have a cabal recipe for installing glade xml files in the correct system location with gtk2hs?
10:47:23 <ehird> it's the result of @unpl @pl ^^, iirc.
10:47:25 <dolio> Cheery: What's your module named?
10:47:35 <hpaste>  vincenz pasted "(no title)" at http://hpaste.org/1070
10:47:40 <vincenz> quicksilver: http://hpaste.org/1070
10:47:44 <Cheery> Main
10:47:50 <hpaste>  Cheery pasted "What is going on here?" at http://hpaste.org/1071
10:47:51 <dolio> Ah, okay.
10:47:52 <vincenz> quicksilver: puttiing those isigs and msigs in a let wouldn't be as pretty
10:48:10 <ehird> also, if' = fix id :)
10:48:13 <ehird> heh
10:48:26 <nmessenger> ehird: ?
10:48:44 <ehird> or rather, it CAN be that
10:48:49 <nmessenger> @pl \b t f -> if b then t else f
10:48:49 <lambdabot> if'
10:48:56 <ehird> > let if' = fix id; upup = (\ q y -> ((\ f -> f >= 0) >>= \ b -> ((^) q) >>= \ a -> return (if' b a)) >>= \ v -> y >>= \ u -> return (v u)) >>= \ j -> (\ ac ai -> recip (ac ^ (negate ai))) >>= \ i -> return (j i) in upup 5 5
10:48:57 <lambdabot>  Exception: <<loop>>
10:49:01 <ehird> hm
10:49:02 <ehird> odd
10:49:03 <nmessenger> ehird: fix id = _|_
10:49:07 <ehird> lambdabot failed me them
10:49:08 <vincenz> quicksilver: no?
10:49:20 <ehird> *then
10:49:42 <Cheery> hmm, when I compile an example, it works well.
10:49:47 <Cheery> I think I'll check in that one. :)
10:49:57 <Cheery> I've guessed this one is solved.
10:51:37 <ehird> <lambdabot> fix = fix id
10:52:40 <nmessenger> @pl fix = let x = x in x
10:52:40 <lambdabot> fix = fix ($ id)
10:53:00 <ehird> @src fix
10:53:01 <lambdabot> fix f = let x = f x in x
10:53:01 <nmessenger> @type ($ id)
10:53:03 <lambdabot> forall b a. ((a -> a) -> b) -> b
10:53:08 <ehird> @pl fix f = let x = f x in x
10:53:08 <lambdabot> fix = fix id
10:53:31 <nmessenger> @pl \f -> let x = f x in x
10:53:31 <lambdabot> fix
10:53:38 <nmessenger> strange
10:53:55 <nmessenger> fix most certainly /= fix id
10:54:08 <ehird> well,
10:54:49 <ehird> fix f = let x = f x in x, so "fix with argument f returns the result of a function executing x. x is defined as applying f to itself"
10:54:58 <ehird> so fix certainly seems to fit the definition of fix id
10:55:07 <tcr> I'm still struck with how best to convert a tree of lots of nested data constructors to another such tree without having to resort to create zillions of convertDat1, convertDat2 and so on. There are no generics in haskell98, but there has to be a better way. Overloading via type classes actually looked exactly right, but they seem to be restricted, or at least I can't get it working. :)
10:55:12 <quicksilver> vincenz: yeah, that looks fine
10:55:12 <ehird> (itself being "x")
10:55:18 <nmessenger> ehird: nope, they're different types
10:55:22 <nmessenger> @type fix
10:55:24 <lambdabot> forall a. (a -> a) -> a
10:55:25 <nmessenger> @type fix id
10:55:26 <ehird> @type fix id
10:55:28 <lambdabot> forall a. a
10:55:29 <lambdabot> forall a. a
10:55:35 <ehird> hm
10:55:42 * vincenz has an obsession with aligned code
10:55:45 <ehird> > fix id
10:55:46 <lambdabot>  Exception: <<loop>>
10:55:54 <ehird> > let x = fix id in x 5
10:55:55 <vincenz> ehird: pm lambdabot?
10:55:56 <lambdabot>  Exception: <<loop>>
10:56:00 <ehird> vincenz: i am
10:56:05 <nmessenger> the only useful member of forall a. a is _|_
10:57:05 <nmessenger> fix . id = fix, but that's only because (. id) = id, so fix . id = id fix = fix
10:57:52 <bakert> I've got to parse and build some very tiny XML documents.  It's dead simple stuff and I could even regex it.  But I thought I'd dip my toe into the world of haskell XML.  What's the best library?
10:58:21 <vincenz> haxml?
10:58:34 <bakert> Is that the standard?  Or is there no standard?
10:58:46 <bakert> Is it nice and simple for a simpleton like me?
10:59:09 <bakert> there's nothing that comes with ghc6.6?
11:00:11 <hpaste>  rjeq pasted "How should I optimise this? (debug output)" at http://hpaste.org/1072
11:00:21 <rjeq> ^^^ that's me
11:00:31 <rjeq> thates the output of +RTS -sstderr
11:00:44 <rjeq> *that's
11:01:35 <rjeq> it says it allocs about 3gb but doesn't spend much time in gc (3%)
11:06:26 * SamB thinks that programming language implementation would work better than fizzbuzz
11:07:00 <tcr> I'd appreciate any hints on my described problem :) I mean it's not any kind of rocket science, just my inexperience with haskell shining through.
11:08:46 <Lemmih> What problem?
11:11:22 <tcr> Lemmih: Just mentioned a few minutes ago. Basically, I've got to convert a tree of nested data constructors to another such tree.
11:12:42 <Lemmih> tcr: Could you elaborate on the problem? Perhaps paste some code on hpaste?
11:13:11 <chessguy> in other words, could you be vague enough to fill us in on the generalities
11:15:17 <tcr> Yes, of course.
11:21:47 <hpaste>  tcr pasted "Converting a tree into another tree." at http://hpaste.org/1073
11:22:15 <tcr> Lemmih, chessguy: There it is.
11:24:42 <dolio> A typeclass may work, but it'll have to be: 'class Convert a b where { convert :: a -> b }' most likely.
11:25:03 <dolio> Or, more than that, probably: 'class Convert a b | a -> b ...'
11:26:20 <dolio> Which will require -fglasgow-exts.
11:27:15 <tcr> I think I've got to be as portable as possible. You said "probably", was that "probably possibly" or "probably certainly"?
11:28:20 <twanvl> The first one (class Convert a b where ...) will work fine (but still require -fglasgow-exts). It should also be quite portable.
11:29:14 <dolio> Yeah, I guess the first would probably be fine.
11:31:54 <tcr> twanvl: What's quite portable exactly? This is for paid work, and I don't think I can bargain for much.
11:32:54 <twanvl> It will work in GHC and Hugs, I don't know about yhc and nhc.
11:33:47 <nmessenger> I'm not sure what the class would buy you.  You'd still need to implement convert.
11:34:09 <tcr> nmessenger: I don't have to create a zillion convertFoo functions.
11:34:32 <tcr> nmessenger: and invoke each of them at the exact right place.
11:35:13 <tcr> nmessenger: I don't see why I should do the dispatching if the compiler got _all_ necessary information anyway.
11:35:53 <nmessenger> okay, I missed that you needed if for a class of types :)
11:35:59 <nmessenger> s/if/it/
11:36:08 <chessguy> i don't get functional dependencies. why couldn't you just do class Convert a a where ...
11:36:37 <tcr> chessguy: Sorry, I can't follow you; what do you mean exactly?
11:37:28 <chessguy> well "class Foo a b | a -> b where ..." means that a and b will be the same type, right?
11:37:46 <glguy> chessguy: no
11:37:54 <glguy> chessguy: it means you can find b from a
11:37:55 <nmessenger> chessguy: class Convert a a is different.  class Convert a b | a -> b implies that you could have (say) an instance Convert Int Integer, but not an instance Convert Int AnythingElse, (I thinkJ)
11:38:33 <chessguy> oh, you can only have one instance of Convert Int _
11:38:57 <ezraburgh> @hoogle [Bool] -> Bool
11:38:57 <lambdabot> Prelude.and :: [Bool] -> Bool
11:38:57 <lambdabot> Prelude.or :: [Bool] -> Bool
11:39:26 <nmessenger> "a determines b" so if you fix "a", you necessarily fix "b"
11:40:07 <tcr> Is there any way to get at the types themselves? I wouldn't mind taking an environment with me a la [a -> b] and then look for each HsFoo type for an appropriate handler in that environment and call the respective transformation function.
11:41:29 <glguy> Haskell's type system compiles away
11:42:07 <nmessenger> unless you represent it somehow, i.e. Data.Typeable
11:42:11 <thief_grr> there was some talk on haskell-based window manager recently, are there any?
11:42:22 <glguy> ?where xmonad
11:42:22 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
11:44:06 <tcr> nmessenger: Then I could just use Data.Generics directly. :)
11:44:11 <nmessenger> chessguy: so there's class MonadState s m | m -> s, so instance MonadState s (State s), i.e. (State s) is the complete monad parameterized over 's', but the 's' also has to be an argument to the class in order to be used in its methods.
11:45:54 <nmessenger> concretely, 'State Blah a' is a member of 'MonadState Blah m => m a'
11:46:08 <tcr> C'm on guys; any idea else? :)
11:49:25 <nmessenger> The fundep prevents an instance MonadState SomeType (State DifferentType)
11:51:48 <ezraburgh> I'm trying to write a one-liner using ghc -e that uses the cmd-line args, but it seems like ghc eats the args for its own purposes; is there any way to say "the rest of the args are for the use of my program"?
11:53:17 <nmessenger> if you're doing a one-liner in -e, couldn't you just include the args in the expression? :)  Also, I'm not sure the answer to your question.
11:54:03 <ezraburgh> yeah, could do; but in order to easily edit the arg part, i want to have the args at the end of the cmd-line...
11:54:51 <ezraburgh> I'm trying to show how Haskell would express this nice Perl one-liner for prime testing:
11:54:54 <ezraburgh> http://montreal.pm.org/tech/neil_kandalgaonkar.shtml
11:54:55 <lambdabot> Title: Perl tricks by Neil Kandalgaonkar
11:54:57 <ezraburgh> perl -wle 'print "Prime" if (1 x shift) !~ /^1?$|^(11+?)\1+$/' [number]
11:55:13 <ezraburgh> and in Perl you can tack the arg on the end of the cmd-line like that.
11:56:08 <Cale> http://video.google.com/videoplay?docid=5442492239822665187
11:56:32 <Cale> Google Video about Software Transactional Memory
11:59:16 <doserj> ezraburgh: additional arguments are interpreted as haskell files to be loaded by ghc -e.
11:59:29 <vincenz> what's the ghc command for Makeefile generation?
11:59:34 <ezraburgh> doserj: yeah--is there any way to get around that?
11:59:45 <SimonRC> Is there already a function that does this?   multiLookup k xs = [ v | (k', v) <- xs, k == k' ]
11:59:54 <SimonRC> Hoogle can't find it.
11:59:57 <doserj> probably not
11:59:58 <Cale> ezraburgh: Build the constant into your expression to be evaluated
12:00:19 <Cale> @type find
12:00:21 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:01:32 <Cale> SimonRC: filter ((==k) . fst)
12:01:47 <Cale> er, map snd of that :)
12:01:58 <Cale> map snd . filter ((==k) . fst)
12:02:09 <Cale> I don't think there's anything builtin.
12:02:38 <xerox> Cale, cool, something new for the ipod :)
12:03:10 <Cale> I kind of dislike that guy's definition of transaction.
12:03:49 <Cale> He only wants to call something a transaction if it's of the form (atomically x)
12:04:09 <Cale> Which makes the discussion a little awkward :)
12:05:23 <dolio> Mmm, contagion.
12:06:36 <chessguy> i think it would have been easier for him to just explain monads :)
12:06:50 <SimonRC> Cale: just what I thought, though I used the comprehension for clarity
12:06:53 * SimonRC has dinner
12:07:54 <Cale> also, when asked about nesting transactions -- while you can't put an 'atomically' inside of an STM computation, you can certainly put other STM computations inside it.
12:07:58 <sjanssen> glguy: have you tried xmonad yet?
12:08:28 <sjanssen> glguy: it has tiles and xinerama support nowadays
12:10:33 <chessguy> who is this guy, in the video?
12:11:34 <Cale> Someone at Google.
12:11:42 <SamB> sjanssen: don't you mean "today"?
12:12:43 <sjanssen> SamB: tiling is about a day old by now
12:13:04 <SamB> sjanssen: yeah, yeah
12:13:18 <SamB> still, "nowadays" sounds like it was added sometime in the past decade
12:13:44 <sjanssen> true
12:13:45 <Cale> SamB: Get with the Internet, man, "nowadays" now means "in the last few hours".
12:14:14 <SamB> @web1913 nowadays
12:14:19 <lambdabot> *** "Nowadays" web1913 "Webster's Revised Unabridged Dictionary (1913)"
12:14:19 <lambdabot> Nowadays \Now"a*days`\, adv. [For now on (OE. an) days. See
12:14:19 <lambdabot>    {A-}, 1.]
12:14:19 <lambdabot>    In these days; at the present time.
12:14:19 <lambdabot>  
12:14:21 <lambdabot>          What men of spirit, nowadays, Come to give sober
12:14:23 <lambdabot>          judgment of new plays ?                  --Garrick.
12:14:30 <sjanssen> xmonad has only been publicly available for about two weeks now
12:15:00 <chessguy> man, this guy's getting roasted
12:15:40 <SamB> what? you can build xmonad with 6.4?
12:16:21 <sjanssen> is there a way to do a "conditional" include with CPP?  I want to include a file iff it exists
12:16:29 <sjanssen> SamB: yeah, it required just a few minor changes
12:16:46 <SamB> what about X11-extras?
12:17:13 <sjanssen> X11-extras builds fine with 6.4 too
12:17:42 <SamB> hmm.
12:18:07 <SamB> I wouldn't have needed to upgrade, then.
12:18:12 <dolio> These examples sure have a lot of syntax. :)
12:18:21 <sjanssen> SamB: you hadn't upgraded yet?
12:18:52 <SamB> well, I upgraded within the last two days
12:19:26 <dadaism> why is Haskell better than Erlang?
12:19:35 <glguy> @proto
12:19:35 <lambdabot> paul graham said static typing and ML types fo lisp hurt exploratory progrmaming
12:19:37 <jacobian> haha
12:19:50 <sjanssen> dadaism: it's a fundamental law of the universe
12:20:13 <dolio> Haskell is named after the cooler mathematician.
12:20:17 <jacobian> proof of intelligent design
12:20:17 <SamB> dadaism: who said haskell is better than erlang?
12:20:28 <glguy> ?quote Erlang
12:20:28 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
12:20:29 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
12:20:30 <glguy> lets find out
12:20:37 <sjanssen> dadaism: one big difference is that Haskell is statically typed
12:20:41 <sjanssen> is Erlang pure?
12:20:50 <glguy> It looks like Haskell is better because #haskell is bigger than #erlang
12:20:52 <SamB> sjanssen: not quite
12:21:07 <Shimei> Oh, is xmonad in a useable state?
12:21:11 <SamB> @quote erlang
12:21:11 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
12:21:11 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
12:21:18 <dadaism> I heard many people say Haskell is better than Erlang, I'm not saying that myself :)
12:21:18 <Shimei> s/in/already in/
12:21:19 <SamB> Shimei: well, are you able to use dwm?
12:21:28 <Shimei> I use wmii, actually.
12:21:38 <Shimei> So kinda sorta? ;)
12:21:41 <sjanssen> Shimei: depends on your defn. of usable.  It is working quite well for several people in this channel
12:21:42 <dadaism> what's the Ruby on Rails framework for Haskell?
12:21:56 <sjanssen> dadaism: there isn't one yet
12:22:07 <Shimei> sjanssen: I see. I shall try it on my dev box then.
12:22:11 <SamB> @quote Rails
12:22:11 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
12:22:25 <SamB> @quote Rails
12:22:26 <lambdabot> SamB says: [<lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane] <SamB> is that a Python web framework?
12:22:29 <glguy> lol
12:22:39 <glguy> well played, lambdabot
12:22:41 <sjanssen> Shimei: compared to xmonad, wmii is super-bloated :)
12:22:44 <SamB> @quote Rails
12:22:45 <lambdabot> SamB says: [<lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane] <SamB> is that a Python web framework?
12:22:48 <SamB> hmm.
12:23:02 <SamB> I think we must not have more quotes about rails?
12:24:01 <dadaism> would you say that Haskell community is a closed one, composed by people that know well each others and not very welcoming of newbies?
12:24:49 <glguy> ?quote stereo
12:24:49 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
12:24:54 <Shimei> dadaism: As a newbie, I think it's very friendly.
12:24:58 <SamB> dadaism: heh
12:25:16 <SamB> dadaism: are you interviewing for an article?
12:25:31 <sjanssen> dadaism: the community is both open and close knit
12:26:05 <glguy> SamB: Would you say you are Very Satisfied, Satisfied, Indifferent, Dissatisfied, Very Dissatisfied with Haskell
12:26:11 <glguy> please choose two
12:26:16 <SamB> heh
12:26:38 <SamB> Very Satisfied and Dissatisfied, I guess.
12:26:49 <dadaism> ahahah
12:26:50 <mightybyte> dadaism: I have found the haskell community very helpful and approachable.
12:27:32 <sjanssen> dadaism: additionally, the community has a culture of teaching.  Probably because so many of it's members are in academia
12:28:17 <mightybyte> That, and if they didn't Haskell probably wouldn't stand much of a chance at being more accepted. :)
12:28:20 <SamB> sjanssen: how do you explain ML?
12:28:44 <sjanssen> SamB: I dunno
12:29:24 <SamB> too much divergance?
12:29:38 <SamB> not enough email/IRC?
12:30:02 <thief_grr> glguy: thanks ;)
12:30:10 <glguy> ?
12:30:19 * glguy scrolls back to remember what he said
12:30:49 <Shimei> mightybyte: Though that seems to strangely not apply to some other more obscure language communities. Lispers are renowned (true or not) of their belligerence, for example. I wonder why.
12:31:00 * vincenz Wishes there was a Data.Map that allowed you to explicitly give the compare function
12:31:13 <SamB> Shimei: is lisp accepted?
12:31:13 <vincenz> cause right now I'm stuck rolling an ugly Ord instance
12:31:41 <sjanssen> vincenz: union (for example) becomes problematic
12:31:42 <Shimei> SamB: Depends on who you ask, but I'd say not really.
12:31:48 <glguy> vincenz: why is it ugly?
12:31:59 <SamB> Shimei: anyway, it isn't because of Baughn that they are renowned for their belligerence
12:31:59 <vincenz> glguy: cause it makes certain data-constructors overlap
12:32:43 <Shimei> SamB: Baughn?
12:33:18 <SamB> Shimei: he hangs out in ##c a lot, and is here right now...
12:36:08 <dolio> Wow, this other transactional memory system looks like a lot of fun.
12:36:15 <glguy> this other?
12:36:16 <SamB> *other* system?
12:36:20 <mightybyte> Shimei: True.  I would say that is probably why Haskel's velocity has been much greater than that if Lisp.
12:36:36 <mightybyte> s/if/of/
12:36:36 <dolio> It appears to be C++.
12:36:47 <SamB> mightybyte: I like to think the typesystem and the modules are related to it, too...
12:37:06 <jyasskin> dolio: ooh, I'm stuck writing in that language. Where's this memory system you speak of?
12:37:21 <SamB> (meaning, the fact that we don't have our whole library in one giant lump is nice)
12:37:21 <dolio> It's on a slide in the google video Cale posted earlier.
12:37:39 <Cale> dolio: It's imaginary
12:37:41 <mightybyte> SamB: That could be.  I don't have enough lisp experience to say in the context of this comparison.
12:37:50 <sjanssen> SamB: I think the One True Base Library for all implementations helps
12:37:54 <jyasskin> dolio: Oh, if it's the STM talk, it's Haskell with C++ syntax. ;)
12:37:54 <drigz> how can i check if my program is overflowing Int?
12:38:06 <SamB> sjanssen: if only that was so
12:38:10 <Cale> dolio: He's just translating the syntax of Haskell so that people will understand better without him having to explain.
12:38:13 <SamB> it doesn't seem to be so yet
12:38:25 <dolio> Right, that's what he stars with, but later on he talks about some other system from Cambridge.
12:38:26 <SamB> I mean, I don't see a darcs repo where I can download the OTBL
12:38:32 <sjanssen> SamB: yhc and jhc don't count
12:38:33 <Cale> ah
12:38:42 <sjanssen> SamB: http://darcs.haskell.org/packages/base/
12:38:43 <lambdabot> Title: Index of /packages/base
12:38:43 <dolio> Where you do all sorts of transaction stuff manually.
12:38:48 <SamB> sjanssen: I think a real OTBL would be able to deal with yhc and jhc
12:39:07 <SamB> That is, yhc and jhc would be able to use it too
12:39:13 <ndm> SamB: that requires Yhc to be designed in a sensible way...
12:39:22 <ndm> SamB: but we'd love to use the OTBL
12:39:22 <SamB> ndm: you have a point
12:39:39 <SamB> using monads might be a good start
12:39:49 <SamB> maybe arrows
12:40:10 <hpaste>  oren pasted "Restriction on multi-type-parameter classes?" at http://hpaste.org/1074
12:40:12 <sjanssen> ndm: what's keeping Yhc from using base?
12:40:24 <ndm> sjanssen: time, and stupidity
12:40:31 <SamB> sjanssen: well, perhaps it is the horror that is the front end?
12:40:33 <ndm> time from the people who would know how to fix it
12:40:49 <ndm> stupidity dating back to the front end of nhc, which bakes in things you wouldn't imagine
12:41:04 <SamB> it used to use *Ints* for identifiers throughout
12:41:04 <oren> Can some kind soul take pity on me and tell me what is wrong with http:://hpaste.org/1074 ? It seems as though it should work... some limitation on the Class system?
12:41:09 <sjanssen> oren: I think you want a functional dependency on your class
12:41:40 <oren> sjanssen: ? how do I do that ?
12:41:41 <sjanssen> oren: is it true that for any 'parameter' type there is only one valid 'result' type?
12:41:46 <oren> Yes!
12:41:52 <oren> That's the idea
12:42:17 <hpaste>  sjanssen annotated "Restriction on multi-type-parameter classes?" with "fundeps encode that restriction" at http://hpaste.org/1074#a1
12:42:20 <ndm> SamB: thats not nearly the most stupid thing in the front end...
12:42:50 <shapr> YAY CODE!
12:42:53 <ndm> SamB: me and tom both spent a day each trying to track down how one particular name was introduced into the front end - we both failed...
12:43:05 <sjanssen> oren: that little | a -> b bit means that for every a there is only one potential b
12:43:11 <SamB> there are several things that are *almost* monads, or even almost state transformer monads...
12:43:24 <shapr> I just installed cabal-install, cabal-test, parallel quickcheck, and some other stuff I can't think of...
12:43:29 <oren> sjanssen: Thanks! You are a life saver. I was going nuts :-)
12:43:54 <SamB> ndm: yeah, I'm just pointing out the grossest things
12:44:15 <ndm> SamB: Yhc predates records and monads, that i can understand
12:44:32 <ndm> the name baking and renaming is just _wrong_, plain and simple, and was never a good idea
12:44:36 <SamB> well, worse than that is that it looks like it would be really hard to *fix*
12:44:51 <SamB> which "name baking"?
12:50:54 <vincenz>     Constraint is no smaller than the instance head
12:50:54 <vincenz>       in the constraint: Ord (Type i t)
12:50:57 <vincenz> ?
12:50:58 <sjanssen> does Yhc support all of Haskell '98
12:51:36 <sjanssen> vincenz: new restriction in ghc to make sure instances with fundeps are decidable
12:51:43 <SamB> vincenz: what does the instance head look like?
12:51:57 <vincenz>     Constraint is no smaller than the instance head
12:51:57 <vincenz>       in the constraint: Ord (Type i t)
12:51:57 <vincenz>     (Use -fallow-undecidable-instances to permit this)
12:51:57 <vincenz>     In the derived instance declaration
12:51:57 <vincenz>       instance (Ord (Type i t)) => Ord (MSig i t)
12:52:00 <vincenz> this is the full thing
12:52:21 <sjanssen> vincenz: obey the compiler and use -fallow-undecidable-instances
12:52:27 <vincenz> sjanssen: don't want to
12:52:29 <hpaste>  drigz pasted "Can this be made tail-recursive?" at http://hpaste.org/1075
12:52:50 <sjanssen> vincenz: what does the Ord instance for Type look like?
12:53:02 <psi> ?where xmonad
12:53:02 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
12:53:03 <LPhas> i've got an idea
12:53:05 <drigz> ^^^ you can make it recursive by getting rid of the /2 optimisation, but it ends up much slower
12:53:12 <LPhas> an universal haskell preprocessor
12:53:23 <LPhas> i mean a preprocessor based on haskell language
12:53:26 <vincenz> sjanssen: doesn't exist
12:53:45 <LPhas> that you can use to preprocess... all
12:53:48 <sjanssen> vincenz: umm, doesn't that mean your instance is impossible to use?
12:54:24 <sjanssen> drigz: tail recursion isn't that important here, your stack will never get very deep
12:54:34 <vincenz> sjanssen: well I could add it later
12:54:40 <drigz> sjanssen: ok, thanks
12:54:41 <dolio> drigz: The standard way would be to add an accumulating parameter.
12:55:06 <drigz> dolio: the squaring messes that up though
12:55:14 <sjanssen> drigz: http://en.wikipedia.org/wiki/Exponentiation_by_squaring or look in your favorite algorithm book
12:55:15 <lambdabot> Title: Exponentiation by squaring - Wikipedia, the free encyclopedia
12:55:40 <sjanssen> drigz: there is an algorithm that is tail recursive, but I can't remember it right now
12:55:48 <drigz> that's one of lambdabots less useful features
12:56:17 <psi> is unix-1.0 good enough for xmonad? that's what's included in ghc 6.6
12:56:25 <sjanssen> psi: should be
12:56:30 <psi> ok
12:56:32 <SamB> psi: yes!
12:57:03 <psi> what about X11-1.1?
12:57:12 <LPhas> @where xmonad
12:57:12 <drigz> sjanssen: doesn't seem to be on wiki either
12:57:12 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
12:57:12 <sjanssen> vincenz: you'll need to break up the Ord (Type a b) constraint, or use undecidable instances.  There is no other way
12:57:24 <vincenz> sjanssen: Type is a GADT :)
12:58:40 <psi> ah no, I need X11-1.2 for X11-extras.
12:58:47 <drigz> i really don't like 'command if condition' syntax
12:58:55 <SamB> psi: but you can build it
12:59:07 <sjanssen> psi: try using X11-1.1
12:59:15 <SamB> sjanssen: it doesn't work
12:59:16 <SamB> remember?
12:59:17 <sjanssen> (or whatever version you have)
12:59:26 <sjanssen> SamB: oh yeah, missing show instance
12:59:35 <sjanssen> psi: scratch that, you'll need X11-1.2
12:59:38 <sjanssen> @where X11
12:59:38 <lambdabot> I know nothing about x11.
12:59:40 <glguy> drigz: You don't like to be surprised by conditionals?
12:59:41 <SamB> but you can build it
12:59:41 <sjanssen> @hackage X11
12:59:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
12:59:48 <SamB> I built it
13:00:42 * psi nods
13:01:10 <chessguy> whoah
13:01:18 <chessguy> when did this @hackage command happen
13:01:32 <chessguy> ?version
13:01:32 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
13:01:32 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:01:33 <sjanssen> chessguy: few weeks ago
13:01:40 <SamB> @hackage FizzBuzz
13:01:40 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FizzBuzz
13:01:42 <sjanssen> it's really stupid:
13:01:46 <psi> :)
13:01:48 <sjanssen> @hackage chessguylib
13:01:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/chessguylib
13:01:53 <chessguy> haha
13:01:56 <SamB> sjanssen: you need to turn your : around
13:02:24 <SamB> @help dummy
13:02:24 <lambdabot> dummy. Print a string constant
13:02:33 <SamB> is it in that plugin?
13:02:50 <sjanssen> SamB: I think so
13:02:57 <sjanssen> SamB: turn by : around?
13:03:00 <chessguy> @dummy am not!
13:03:00 <lambdabot> dummy
13:03:01 <sjanssen> s/by/my
13:03:25 <SamB> sjanssen: you don't like my "@hackage FizzBuzz"?
13:03:39 <sjanssen> ah, I get it now
13:03:55 <glguy> @hackage ++
13:03:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/++
13:04:04 <hpaste>  dolio annotated "Can this be made tail-recursive?" with "does this get correct results?" at http://hpaste.org/1075#a1
13:04:06 <glguy> ?karma http://hackage.haskell.org/cgi-bin/hackage-scripts/package/
13:04:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ has a karma of 0
13:04:30 <doserj> sjannsen, you don't have an email address in you X11-extras package?
13:04:35 <chessguy> @wiki FizzBuzz
13:04:35 <lambdabot> http://www.haskell.org/haskellwiki/FizzBuzz
13:04:43 <sjanssen> doserj: I'll add it now
13:05:01 <Saizan> tray icons are so annoying! they occupy the whole screen like a window in xmonad
13:05:12 <SamB> Saizan: heh
13:05:21 <LPhas> @hackage X11-extras
13:05:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11-extras
13:05:28 <SamB> Saizan: what programs have those?
13:05:45 <Saizan> SamB: amarok for example
13:05:51 <doserj> I have only a trivial fix, but anyways...
13:06:08 <sjanssen> doserj: thanks for reminding me to fix it
13:06:19 <drigz> sjanssen: in case you're wondering, the tail-recursive is to square base when necessary
13:06:32 <drigz> sjanssen: found it in wiki's miller-rabin article
13:06:49 <largos> Saizan: is xmonad usable?
13:06:57 * glguy wonders if anyone else was able to parse that sentense
13:07:04 <largos> (day-to-day usable)
13:07:09 <LPhas> trying to compile xmonads it tells me that i have not X11-extras
13:07:12 <Saizan> largos: yes, read the Main.hs for keybindings
13:07:17 <LPhas> but i can't find this package
13:07:21 <drigz> sjanssen: although looking again, it was in the first article...
13:07:28 <psi> LPhas: see README
13:07:29 <sjanssen> largos: I know at least three people that run it as their main wm
13:07:32 <LPhas> psi: thx
13:07:34 <largos> Saizan: cool, will do :)
13:07:49 <largos> sjanssen: awesome :) I'll check it out tonight
13:08:46 <LPhas> sjanssen: cool
13:09:39 <doserj> hm. darcs could be a bit more informative:
13:09:50 <doserj> "No remote changes to pull in!"
13:10:05 <doserj> but it got the new metadata
13:11:44 <vincenz> heya bringert
13:11:48 <bringert> hi
13:12:10 <drigz> if i'm doing (a*b)%c where a, b, c :: Int, but a*b might overflow Int, what should I do?
13:12:19 <SamB> doserj: it doesn't get that metadata
13:12:26 <SamB> it reads that when you do "darcs send"
13:12:52 <vincenz> drigz: (a%c) * (b%c)
13:12:54 <drigz> is there a nice way to cast a and b to 64-bit Ints or Integers?
13:13:06 <drigz> assume a%c == c and b % c == c
13:13:13 <sjanssen> drigz: fromIntegral
13:13:14 <vincenz> that's impossible
13:13:14 <jochem_> (a%c)*(b%c) != (a*b)%c ?
13:13:21 <drigz> typo
13:13:24 <drigz> meant == a/b
13:13:31 <vincenz> a%c can never be c
13:13:35 <vincenz> jochem_: yes
13:13:37 <vincenz> ==
13:13:42 <drigz> a % c == a and b % c == b i meant
13:13:48 <doserj> SamB: ah, that makes sense, thanks
13:13:52 <vincenz> drigz: then it doesn't matter
13:13:55 <chessguy> hmm, not too much on hackage yet
13:14:09 * SamB would like to be a Yhc project member on Google Code
13:14:11 <drigz> vincenz: why?
13:14:25 <vincenz> oh wait
13:14:26 <vincenz> nm
13:14:41 <vincenz> basically you want that
13:14:50 <SamB> hmm. ndm left :-(.
13:15:24 <vincenz> (a * b ) % (2^32) %c == (a%2^32)*(b%2^32)%c
13:15:30 <vincenz> hmm
13:15:39 <drigz> sjanssen: so fromIntegral (((fromIntegral a :: Int64) * (fromIntegral b :: Int64)) % c) :: Int?
13:16:09 <vincenz> drigz: don't forget to fromIntegral c too to a Int53
13:16:10 <vincenz> 64
13:16:27 <drigz> will * complain about different types?
13:16:36 <vincenz> yes
13:16:39 <vincenz> @type (*)
13:16:40 <drigz> :(
13:16:41 <lambdabot> forall a. (Num a) => a -> a -> a
13:16:42 <SamB> @tell ndm I want to be a Yhc project member on Google Code (so I can edit tickets)
13:16:43 <lambdabot> Consider it noted.
13:17:59 <sjanssen> > let f :: Int32 -> Int64; f = fromIntegral in f maxBound + f maxBound
13:18:01 <lambdabot>  4294967294
13:19:50 <drigz> is Int the same as Int64 on 64-bit machines?
13:19:59 <SamB> no
13:20:06 <SamB> it is almost the same
13:20:10 <sjanssen> drigz: in ghc it is
13:20:22 <SamB> sjanssen: but...
13:20:36 <SamB> @hoogle width
13:20:36 <lambdabot> Text.Html.width :: String -> HtmlAttr
13:20:36 <lambdabot> Text.Html.marginwidth :: Int -> HtmlAttr
13:20:36 <lambdabot> System.Win32.NLS.lCMAP_FULLWIDTH :: LCMapFlags
13:20:36 <sjanssen> oh, right they're not the same *type*, but they're the same implementation
13:20:41 <SamB> @hoogle bits
13:20:42 <lambdabot> Data.Bits :: module
13:20:42 <lambdabot> Data.Bits.Bits :: class Num a => Bits a
13:20:42 <lambdabot> Data.Bits.bitSize :: Bits a => a -> Int
13:20:46 * psi` is in xmonad. yay.
13:20:48 <Cale> Comment on reddit: "I'm sorry I want to read this long but it's freaking 7 pages long, can I get a quick summary?"
13:20:49 <SamB> > bitSize (1 :: Int)
13:20:50 <sjanssen> SamB: agreed?
13:20:50 <lambdabot>  32
13:21:02 <SamB> sjanssen: oh, gotcha...
13:21:08 <SamB> yeah!
13:21:11 <SamB> thats true.
13:21:28 * psi` mumbles. "Someone always takes my nick."
13:21:28 <SamB> but that isn't really what drigz asked
13:21:41 <psi`> I wish you could use nickserv's autokill.
13:21:43 <glguy> psi: so knock them off your nick
13:22:19 <psi> yeah, that's what I have to to every time.
13:22:23 <chessguy> hmm. according to the hackageDB introduction page, "Recent additions are also available as an RSS feed."...but it doesn't give the feed URL
13:22:40 <Cale> Why can't you use autokill?
13:23:04 <sjanssen> chessguy: http://hackage.haskell.org/packages/archive/recent.rss
13:23:09 <drigz> how does lambdabot know what to evaluate?
13:23:11 <psi> Cale: when I try to enable it nickserv tells me it's not supported "on this network".
13:23:15 <drigz> 3+6
13:23:25 <chessguy> sjanssen, thanks. that really ought to be noted on that page
13:23:26 <sjanssen> drigz: the "> " prefix
13:23:32 <sjanssen> chessguy: yes
13:23:32 <QtPlatypus> It looks for "> "
13:23:35 <chessguy> or did i miss it somewhere?
13:23:38 <Cale> hmm
13:23:48 <QtPlatypus> > 3+6
13:23:49 <lambdabot>  9
13:23:52 <SamB> <link rel="alternate" type="application/rss+xml" title="HackageDB RSS Feed" href="/packages/archive/recent.rss"
13:23:52 <SamB>      />
13:24:00 <sjanssen> chessguy: there isn't an explicit link, but there's something in the page's metadata
13:24:03 <jochem_> > sqrt 1369
13:24:05 <lambdabot>  37.0
13:24:07 <chessguy> ah
13:24:21 <drigz> sjanssen: thanks
13:24:33 <drigz> it blended in with the <SamB>
13:24:48 <drigz> ?hoogle Int64
13:24:48 <lambdabot> Data.Int.Int64 :: data Int64
13:25:35 <SamB> also, you right click and choose "Page Info", in firefox, and then click on "Links"
13:26:09 <drigz> yay! 3x speed increase
13:27:11 <Saizan> or left-click on the rss icon near the url
13:27:40 <SamB> Saizan: oh, hmm, true
13:27:42 <SamB> I missed that
13:28:18 <chessguy> rss icon where?
13:28:34 <SamB> chessguy: in address bar on http://hackage.haskell.org/packages/archive/recent.html
13:28:34 <chessguy> ohhhhhh
13:28:44 <chessguy> i never knew what that was before
13:29:05 * chessguy is still pretty new to RSS
13:29:54 <SamB> I didn't remember the icon being there either
13:30:15 <SamB> but, it seems kinda useless if you wanted to use the feed in some other program
13:30:43 <shapr> Lemmih just got me started with "darcs setpref test cabal-test", it's great!
13:30:57 <shapr> Hiya Derek!
13:31:18 <chessguy> SamB, at least it gives you a link to paste
13:31:36 <ddarius> heya
13:31:37 <SamB> does it now?
13:31:46 <SamB> It says "Add Live Bookmark" here
13:32:01 <chessguy> if you click on the rss icon, the link in the address bar changes to the rss subscription url
13:32:24 <chessguy> (at least it does for me)
13:32:28 <SamB> hmm
13:32:34 <SamB> maybe your version is different
13:32:41 <Saizan> not for me either
13:32:56 <chessguy> i'm using firefox 2
13:33:16 <SamB> ah
13:33:20 <doserj> sjannsen: I just got xmonad running on this archaic setup here (XFree 4.3)
13:33:36 <chessguy> it also lets me choose another application to use to subscribe to the feed
13:33:38 <SamB> doserj: that is not particularly surprising
13:33:56 <doserj> I needed to add an extra-libraries: "Xext" into the cabal file, though
13:34:01 <SamB> doserj: the fanciest thing it does is, after all, Xinerama
13:34:19 <psi> hmm, what's this? *** Exception: /usr/local/bin/xmonad: copyFile: resource busy (Text file busy). I'm trying to update xmonad while it's running. I didn't think that'd be a problem.
13:34:28 <SamB> and you don't need that on your X server for it to work
13:34:54 <sjanssen> psi: you have to rm the existing binary because cabal is stupid
13:34:58 <doserj> ok, running was not surprising, but building...
13:35:32 <ddarius> Has Google just started doing word stemming this past month or so or something?
13:35:38 <drigz> if my program gets a big figure for 'bytes allocated in the heap', what might be causing that?
13:35:46 <SamB> ddarius: past month?
13:35:57 <drigz> (it's getting a lot %gc time figure)
13:35:58 <ddarius> SamB: Fairly recently, it seems.
13:35:59 <SamB> I think it has been longer than that, at least for singular/plural
13:35:59 <drigz> *low
13:36:15 <ddarius> SamB: I'm talking about program/ming
13:36:30 <psi> SamB, sjanssen: is there a good way to restart xmonad?
13:36:32 <shapr> hej nominolo, god morgon!
13:36:49 <SamB> psi: kill! start again!
13:36:55 <sjanssen> psi: I use this http://hpaste.org/1062
13:37:05 <SamB> psi: I was wondering that myself, actually...
13:37:11 <nominolo> god kväll shapr :)
13:37:21 <SamB> well, actually I was wondering how hard it would be to code one
13:37:26 * nominolo is actually not swedish
13:37:28 <ddarius> shapr: Did you achieve fluency?
13:37:44 <ddarius> nominolo: No problem, neither is shapr.
13:37:46 <sjanssen> SamB: not hard, just call exec
13:37:47 <shapr> ddarius: Nah, I'm probably only at a high school level.
13:38:00 <SamB> sjanssen: hmm.
13:38:09 <ddarius> shapr: Darn.
13:38:12 <shapr> nominolo: VarifrÃ¥n kommer du? Tyskland?
13:38:19 <shapr> ddarius: It's okay, I'm planning to move back in September.
13:38:30 <shapr> ddarius: I'd like to drive down and visit you before that though.
13:38:44 <ddarius> shapr: They can slow you down, but they can't stop you!
13:38:53 <shapr> heh, right :-)
13:39:02 <nominolo> shapr: precis
13:39:17 <shapr> oh hey Derek, did I already ask you about laziness as self modifying programs?
13:39:21 <Saizan> drigz: you should probably try to profile more, you compile with -prof -auto-all and run with +RTS -p as a start, read on the GHC user's manual for details
13:39:47 <psi`> man, that guy is quick.
13:39:51 <ddarius> shapr: You mentioned self modifying programs when I was around once, but I don't remember it being linked to laziness and it wasn't directed at me.
13:40:30 <doserj> No xmonad only needs window titles, focus indication, and "query_attachclient" and it could replace my ion3...
13:40:34 <ddarius> shapr: If you did come down here, you wouldn't be able to see where I work (on the inside).  Not that there is much to see.
13:40:40 <drigz> Saizan: yeah, i'm just getting UDG
13:40:40 <ddarius> Hmm, not much to see on the outside either.
13:40:48 <sjanssen> doserj: what is query_attachclient?
13:40:50 <shapr> ddarius: That's okay, I'd really just show up to hang out with you.
13:40:57 <drigz> ?hoogle !
13:40:58 <lambdabot> Array.(!) :: Ix a => Array a b -> a -> b
13:40:58 <lambdabot> Prelude.! :: keyword
13:40:58 <lambdabot> Data.Array.(!) :: Ix i => Array i e -> i -> e
13:41:09 <dmwit> It also needs to focus a client if you click on it...
13:41:17 <doserj> it queries for a window title and moves it to the current frame
13:41:36 <doserj> with tab-completion of course.
13:41:38 <SamB> @hoogle exec
13:41:38 <lambdabot> Directory.executable :: Permissions -> Bool
13:41:38 <lambdabot> Distribution.PackageDescription.executables :: PackageDescription -> [Executable]
13:41:38 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
13:41:53 <SamB> @hoogle System.*exec
13:41:53 <lambdabot> Hoogle Error: Parse Error: Unexpected character '*exec'
13:41:55 <ddarius> With any luck, I should have my TS by the time you would come down here.  Not that that means anything, but it's cool.
13:41:56 <SamB> hmm.
13:42:08 <sjanssen> doserj: xmonad won't ever have a repl with tab completion
13:42:17 <shapr> ddarius: TS?
13:42:21 <dmwit> sjanssen: dmenu?
13:42:24 <ddarius> Top Secret clearance.
13:42:28 <shapr> ddarius: whoa!
13:42:32 <dmwit> If there's enough state printed to stdout...
13:42:49 <shapr> ddarius: My father had Q Clearance for awhile, dunno if he still does.
13:42:57 <doserj> any interface to remote control xmonad?
13:43:02 <sjanssen> dmwit: there may be some infrastructure for external programs
13:43:06 <shapr> It was cool, we had little white FBI vans following us and our friends around for a few months.
13:43:27 <shapr> Needless to say, I stopped doing, um, network exploration for awhile.
13:43:28 <SamB> yeah, searching could easily be done in a seperate program
13:43:32 <sjanssen> I've also got some ideas for user configuration, such that doserj's Config.hs could have this code in it
13:43:46 <doserj> great
13:44:01 <SamB> sjanssen: wouldn't it make more sense to allow him to import it from a package fetched from hackage?
13:44:44 <chessguy> ddarius, http://www.markcarey.com/googleguy-says/archives/discuss-google-launches-word-stemming.html
13:44:46 <lambdabot> Title: Google launches word stemming, http://tinyurl.com/39pcc7
13:45:00 <chessguy> recent as of November 2003
13:45:22 <sjanssen> SamB: the actual functionality could come from anywhere.  The idea is that you can write full fledged Haskell code attached to keybindings and such
13:45:26 <ddarius> shapr: The... weird parts of my life may slow down me getting it.
13:45:45 <ddarius> chessguy: Hmm, I don't remember google stemming in ways that pissed me off until very recently.
13:46:03 <SamB> ddarius: ah. ways that piss you off!
13:46:08 <SamB> you didn't mention that before did you?
13:46:16 <chessguy> ddarius, it's not hard to get around
13:46:32 <ddarius> chessguy: I imagine, but I didn't have to get around it before.
13:46:44 <ddarius> SamB: No, I didn't.
13:47:00 <SamB> they could easily have started that in the last month
13:47:55 <shapr> ddarius: I'll ask you about that in person sometime. Sounds Interesting.
13:48:17 <shapr> Aha, the correct line is "darcs setpref test 'cabal-setup configure;cabal-test'"
13:48:27 <drigz> wierdly, the Int -> Int64 procedure is taking up most of the time in the code
13:48:32 <drigz> isn't it just a sign-extension?
13:49:19 <Cale> and probably reboxing
13:49:45 <drigz> can't the compiler unbox it?
13:50:18 * shapr hugs Cale
13:50:29 <Cale> hi
13:50:53 <Cale> Not usually, I don't think.
13:54:15 <drigz> reckon it's worth manual unboxing? i'll paste the code
13:54:31 <hpaste>  drigz pasted "Unboxing candidate?" at http://hpaste.org/1077
13:54:54 <sjanssen> drigz: try bang patterns before you manually unbox
13:55:18 <sjanssen> and even then, you should check the core before you unbox
13:55:38 * shapr dances cheerfully
13:55:57 <drigz> sjanssen: check the core for what? (i've tried looking at the core, but i'm not sure what i'm looking for)
13:56:10 <drigz> the core doesn't have 'to64' in it
13:57:53 <hpaste>  sjanssen annotated "Unboxing candidate?" with "some speculative changes" at http://hpaste.org/1077#a1
14:00:19 <Cale> sjanssen's changes save about a second on the 6 and a half that it takes to run that code on my machine
14:02:29 <TSC> In xmonad, M-S-c works to close, say, an xterm window, but doesn't work on Firefox.  I guess Firefox is broken?
14:02:39 <chessguy> 15% improvement, that's not bad
14:02:44 <Cale> yeah
14:03:03 <Mushy-pea> Hi.
14:03:04 <tarantoga> TSC: I also noticed that
14:03:11 <drigz> sjanssen: nice, thanks
14:03:31 <drigz> is there an easy way to make it use both cores of my computer?
14:03:56 <drigz> i've heard all this stuff about how well functional code scales
14:05:11 <ddarius> `par`
14:06:37 <Baughn> SamB: Ah, but it's such a small, well-factored library
14:06:58 <Cale> btw, reform x = foldl' (\u v -> u * 10 + v) 0 x
14:07:02 <Mushy-pea> I've found a way to use Haskell in conjunction with my website, even though the host doesn't support it.
14:07:16 <Cale> Mushy-pea: cool
14:07:31 <Mushy-pea> The search engine for my forum software will consist of two parts....
14:07:34 <Cale> Does the host support arbitrary CGI executables?
14:07:39 <SamB> Baughn: are you talking about the CL library or the Haskell library?
14:07:45 <Baughn> SamB: The CL library.
14:08:00 <SamB> I think the documentation could use work
14:08:31 <drigz> ?hoogle foldl'
14:08:32 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
14:08:35 <Mushy-pea> One: A search catalogue generator that will run on my home comp.
14:08:56 <Baughn> SamB: The haskell documentation or the CL documentation?
14:08:59 <Mushy-pea> (written in Haskell).
14:09:03 <SamB> Baughn: CL
14:09:06 <sjanssen> drigz: I think you can find a faster permutation function
14:09:15 <SamB> it is too hard to get lost
14:09:18 <SamB> er.
14:09:20 <SamB> easy.
14:09:30 <SamB> to hard to find what you want, too easy to get lost
14:09:35 * SamB feels rather dim
14:09:42 <Cale> fastPrimeIter xs n = all (fermatTest n) xs
14:09:47 <Mushy-pea> Sequence: Download post database from my website, the Haskell program generates a catalogue of search results from it.
14:10:24 <Mushy-pea> ....Upload catalogue to website.  A simple Perl module accesses the catalogue and can serve search results.
14:11:30 <Baughn> SamB: I'm not sure. I've never had any problems navigating through the hyperspec, but ghc's documentation.. of course, the library is considerably larger in haskell.
14:11:31 <drigz> Cale: thanks :D
14:12:06 <drigz> :( it seems the library functions perform worse than the recursive functions
14:12:11 <SamB> Baughn: well. I just don't like the monolithic approach of CL :-(
14:12:11 <sjanssen> drigz: do you have a multi core processor?
14:12:16 <drigz> sjanssen: yeah
14:12:34 <Mushy-pea> So, the Haskell program will read the post DB and look for matches to a dictionary of words.
14:12:56 <Baughn> SamB: Me neither. Product of its time, though; it had to be backwards-compatible.
14:13:01 <Cale> drigz: really?
14:13:12 <drigz> Cale: yeah, core duo
14:13:15 <Cale> drigz: On my machine, performance was completely unaffected.
14:13:15 <SamB> Baughn: I get lost in the monolithic docs
14:13:24 <Cale> (by using the library functions in this way)
14:13:27 <sjanssen> drigz: give me 5 minutes and I'll show you a parallel algorithm
14:13:33 <SamB> I also dislike that you import *symbols*, not *things*
14:13:51 <SamB> (or maybe I dislike that the symbols have multiple slots)
14:14:13 <Mushy-pea> Then build / update a list of word matches vs. pointers to records in the DB.
14:14:16 <Baughn> SamB: I'd go for the latter. Having a single namespace seems to buy more than it loses.
14:14:18 <drigz> maybe there's more background processes now, but it seems that it has gone from about 3.45s -> 3.53s
14:14:22 <drigz> *there are
14:14:41 <Mushy-pea> Sounds feasible?
14:14:54 <SamB> Baughn: if by "single namespace", you mean "single value for each name at the global scope"
14:15:13 <SamB> I like what they call namespaces in C++
14:15:28 <SamB> (which are just places to keep names)
14:16:04 <Baughn> SamB: Going by cl/scheme nomenclature, those are packages
14:16:21 <Cale> oh, check this out
14:16:26 <Cale> fastPrimeIter xs n = foldl' (&&) False $ map (fermatTest n) xs
14:16:32 <SamB> scheme has nomenclature for that?
14:16:46 <Cale> That's a close to 40% savings on my machine.
14:16:55 <Cale> er, oop
14:17:11 <newsham> > --
14:17:11 <lambdabot>  Parse error
14:17:26 <Baughn> SamB: R6RS does.. or was that just in the draft?
14:17:33 <Cale> no
14:17:37 <SamB> Baughn: haven't read it
14:18:00 <SamB> this could be pretty sweet
14:18:22 <SamB> I don't suppose it has #ifdef yet?
14:18:38 <Cale> That should be a True, and it's slower.
14:18:46 <Baughn> Nope. Nor *features*.
14:18:50 <drigz> > foldr (:) [] [1..5]
14:18:51 <lambdabot>  [1,2,3,4,5]
14:19:02 <Cale> foldr is better
14:19:05 <SamB> yeah, I meant those feature-test macros...
14:19:16 <Cale> (of course, if you think about it)
14:19:55 <Cale> foldr gives the same result as any here
14:21:20 <Baughn> SamB: Actually, R6RS has libraries, not packages. http://www.r6rs.org/document/html/r6rs-Z-H-9.html#node_chap_6 concurs.
14:21:22 <lambdabot> Title: r6rs
14:21:40 <drigz> i just compiled something and got /tmp/ghc973_0/ghc973_0.hc:793:0: warning: implicit declaration of function 'newSpark'
14:22:42 <Baughn> drigz: Just a single file? Try it with --make
14:23:16 <drigz> Baughn: same error, i'll paste the code
14:23:42 <Cale> drigz: Are you importing Control.Parallel?
14:23:59 <hpaste>  drigz pasted "implicit declaration of function 'newSpark'" at http://hpaste.org/1078
14:24:02 <drigz> Cale: yeah
14:24:27 <drigz> incidentally, it doesn't make it use both cores
14:25:06 <sjanssen> drigz: you can ignore the implicit decl. thing
14:25:21 <drigz> sjanssen: should i report it somewhere?
14:25:32 <sjanssen> drigz: to take advantage of two cores you need to compile with -threaded, and run with +RTS -N2
14:25:52 <sjanssen> drigz: it's a known  bug, fixed for 6.6.1, I think
14:26:00 <sjanssen> drigz: you are using 6.6, yeah?
14:26:09 <drigz> yeah
14:26:52 <Cale> main = print . head . filter isPrime . parFlatMap (parList rnf) pandigitalLen $ [9,8..1]
14:26:55 <Cale> try that
14:27:25 <Cale> That's actually a good little chunk faster than the nonparallel code on my single processor machine.
14:27:52 <drigz> ?hoogle parFlatMap
14:27:52 <lambdabot> Control.Parallel.Strategies.parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
14:28:29 <SamB> Cale: odd
14:28:39 <SamB> do you have hyperthreading that actually helps or something?
14:29:00 <SamB> or is it just crap nonparallel code?
14:29:11 <Cale> I don't know. I thought hyperthreading was turned off, but I might be wrong.
14:29:34 <drigz> is there an equivalent of \<newline> in haskell?
14:29:55 <Cale> Just a new line, indented more deeply.
14:30:31 <Cale> main = print . head . filter isPrime
14:30:32 <Cale>              . parFlatMap (parList rnf) pandigitalLen $ [9,8..1]
14:30:39 <Cale> You could write it like that, for instance.
14:31:05 <drigz> Cale: slower :( just under 4s now
14:31:10 <Cale> odd
14:31:17 <drigz> that's with the -threaded and -N2
14:31:51 <Cale> It went from 5.5s to a little under 5s on my machine.
14:31:51 <drigz> taking them away drops it back to about 3.6
14:32:17 <Cale> huh
14:33:26 <drigz> Cale: what does the rnf mean?
14:33:34 <Cale> Reduce to Normal Form
14:33:45 <Cale> basically, completely evaluate the thing, whatever it is
14:33:52 <drigz> incidentally, neither shows the other core being used much
14:35:43 <drigz> ooh it showed using the other core a little bit this time (no changes)
14:35:50 <drigz> and ran it about 3.6
14:36:12 <drigz> the equality of core usage seems to drop off towards the end
14:37:02 <Cale> pandigitalLen l = parMap rnf reform (permutations [l,l-1..1])
14:37:05 <Cale> how about that?
14:37:39 <Cale> I can't really tell how the changes I'm making will affect things, obviously :)
14:38:08 <drigz> :p equal usage on both cores, but never more than about 50%, takes >4s
14:38:32 <Cale> hmm
14:38:45 <Cale> that's odd :)
14:38:45 <triplah> for hyperthreading?
14:38:53 <drigz> core duo
14:38:58 <triplah> you will only get high cpu usage on both if there are lots of cache misses
14:39:01 <triplah> oh ok
14:39:05 <triplah> ignore that then
14:39:28 <drigz> maybe if i can nice the priority up just after running it...
14:39:46 <Cale> after?
14:39:55 <Cale> You could just run it with nice
14:40:20 <drigz> ah can you do that?
14:40:31 <drigz> that's not surprising, in hindsight
14:40:59 <drigz> there are some really basic things i don't know about unix...
14:41:34 <sjanssen> we need to determine the most expensive part of the program
14:41:47 <sjanssen> my intuition says that "filter isPrime" is it
14:41:58 <drigz> same problem
14:42:33 <sjanssen> isPrime and the functions that it calls
14:43:29 <drigz> has anyone written an hpaste script?
14:44:08 <hpaste>  drigz pasted "profile" at http://hpaste.org/1079
14:44:16 <ddarius> drigz: To post a file to hpaste or what?
14:44:22 <drigz> ddarius: yeah
14:44:46 <Cale> We could try: fastPrimeIter xs n = and $ parMap rnf (fermatTest n) xs
14:45:06 <ddarius> I don't think so (some stuff for emacs and/or vim though).  It would be dirt simple to do in Haskell.  Literally taking only a few minutes if you are familiar with the relevant libraries.
14:45:07 <drigz> do they really need to format the hpaste html without any newlines?
14:45:09 <Cale> This *really* hurts performance on my single processor machine
14:45:51 <Cale> (with the threaded runtime)
14:46:18 <drigz> 5.5s here
14:46:23 <Cale> ah, okay, so worse
14:46:33 <drigz> (that's with all the other par bits
14:47:29 <sjanssen> Cale: usually you only have to test a few of the random numbers before you get a False
14:47:41 <Cale> sjanssen: yeah.
14:47:42 <sjanssen> so doing that in parallel will usually be a loss
14:47:47 <Cale> right.
14:48:21 <Cale> So that makes sense.
14:48:39 <Cale> So what's left to try? Turn these iterative algorithms into divide and conquer somehow?
14:49:03 <drigz> can't we make it do isPrime parallelly?
14:49:07 <drigz> like a parFilter?
14:49:21 <sjanssen> I'm attempting to write parFilter, but it's very tricky
14:49:25 <Cale> filter doesn't parallelise easily
14:49:44 <drigz> seems like a good reason to include it in the library :p
14:49:45 <drigz> why not?
14:49:46 <Heffalump> map and catMaybes?
14:50:08 <Cale> Heffalump: yeah, I think that's probably the best way to go
14:50:16 <Heffalump> with infinite machines you can do the catMaybes in log n time, presumably
14:50:17 <sjanssen> drigz: is the real problem to find every prime, or just the first?
14:50:24 <drigz> first
14:50:32 <sjanssen> it is easier to find every prime in parallel
14:51:02 <drigz> the problem is to find the largest
14:51:22 <Heffalump> I meant infinite CPUs
14:52:59 <drigz> i tried using filter (/=0) . parMap rnf (\x -> if isPrime x then x else 0)
14:53:36 <drigz> seems about the same, still only using half each core
14:54:26 <drigz> maybe it's being bottlenecked by something else, and that's why the cores aren't filling up?
14:55:49 <drigz> 125mb/s sound like a ram access speed on a laptop?
14:56:03 <sjanssen> that's far too slow
14:56:12 <drigz> that's what i thought
14:57:12 <drigz> i think it might be about time to make some dinner and go to bed...
14:57:26 <Lemmih> A fifteen year old laptop, perhaps?
14:57:48 <sjanssen> Cale: is there a way to get every permutation in a nice tree structure?
14:58:02 <Sgeo> I suppose there's no way to pattern match for functions or anything?
14:58:15 <nominolo> > let data F = F { bla :: Bool, blub :: Int8 } deriving Enum
14:58:15 <lambdabot>  Parse error
14:58:48 <sjanssen> nominolo: data decls must be at the top level
14:58:57 <nominolo> > data F = F { bla :: Bool, blub :: Int8 } deriving Enum
14:58:57 <lambdabot>  Parse error
14:59:01 <nominolo> heh
14:59:07 <nominolo> well, my question is:
14:59:35 <Cale> sjanssen: Well, yes, where the permutations are paths from the root to the leaves.
14:59:41 <nominolo> can Enum instances autoamtically be derived for records?
14:59:44 <pejo> 125 Mb/s coincides with 1 Gigabit/s, if it's without overhead.
15:00:18 <sjanssen> nominolo: you can only derive data types with nullary constructors AFAIR
15:00:36 <nominolo> yes, i guess it's ambiguous otherwise
15:00:53 <nominolo> ie. do you fill bits or not, and if so, how?
15:01:28 * nominolo prepares for writing lot's of boring instance decls ...
15:01:43 <SamB> nominolo: why are you going to do that?
15:02:33 <SamB> @src (,)
15:02:33 <lambdabot> Source not found. You type like i drive.
15:02:37 <SamB> @src (,,)
15:02:37 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:02:40 <nominolo> SamB: I have legacy code with a class 'ToBinary'.  And I am going to change a lot of data structures
15:03:03 <nominolo> Maybe Data.Generic might help though
15:03:50 <SamB> hmm.
15:03:59 <nominolo> @where SIB
15:03:59 <nominolo> @where SYB
15:03:59 <nominolo> lambdabot: ping?
15:03:59 <SamB> @instances Enum
15:03:59 <lambdabot> I know nothing about sib.
15:03:59 <lambdabot> I know nothing about syb.
15:04:00 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
15:04:12 <SamB> oh.
15:04:34 <SamB> no Enum instances for tuples, I see.
15:06:29 * nominolo had a lag
15:07:05 <Cale> !paste
15:07:05 <hpaste> Haskell paste bin: http://hpaste.org/
15:07:59 <hpaste>  Cale pasted "permutation trees" at http://hpaste.org/1080
15:08:07 <sorear> hello.
15:08:51 <Cale> hi
15:10:24 <dons> moin
15:10:37 <araujo> hello dons
15:13:44 <nominolo> > maxBound (undefined :: Int)
15:13:45 <lambdabot>   add an instance declaration for (Bounded (Int -> a))
15:13:45 <lambdabot>     In the expression:...
15:13:54 <nominolo> @instances Bounded
15:13:56 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
15:14:15 <nominolo> :t maxBound
15:14:17 <lambdabot> forall a. (Bounded a) => a
15:14:34 <nominolo> > maxBound :: Int
15:14:36 <lambdabot>  2147483647
15:16:17 <TomMD> Has anyone here used the PCap found on hackage?  It looks like it shouldn't work to me.
15:17:42 <TomMD> Damn, only the crickets I guess.
15:18:07 <nominolo> > let bitsNeeded = ceiling $ logBase 2 $ fromEnum $ maxBound in bitsNeeded :: Char
15:18:08 <lambdabot>   add an instance declaration for (Floating Int)
15:19:04 <sorear> TomMD: the dev frequents here
15:19:13 <sorear> (his name slips my memory :( )
15:19:47 <TomMD> I'll ask again at a busier time in a ruder manner to make sure he'll respond loud and clear :-) (j/k of coarse).
15:20:09 <sorear> grep++
15:20:22 <sorear> @seen nrb23
15:20:22 <lambdabot> Last time I saw nrb23 was when I left #darcs, #gentoo-haskell, #gentoo-uy, #ghc, #happs, #haskell, #haskell-blah, #haskell-overflow, #haskell.de, #haskell.dut, #haskell.es, #haskell.fr, #jtiger, #
15:20:22 <lambdabot> montevideolibre, #oasis, #parrot, #perl6, #scannedinavian and #unicycling 17d 17h 30m 12s ago, and .
15:20:34 <sorear> ooh, the bot restarted!
15:20:43 <sorear> oh, 'd'
15:20:55 <sorear> @let x = 2 -- sigh
15:20:58 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
15:21:22 <dons> busy busy.
15:21:40 <dons> as much as it would be nice to be paid to maintain lambdabot full time ... ;-)
15:21:54 * Heffalump is gettingodd profiling results with ByteString
15:22:08 <vincenz> dons: competing in icfpc?
15:22:09 <Heffalump> though I'm most impressed with it in general, I replaced some Strings and things got magically faster :-)
15:22:10 <dcoutts> Heffalump: mm?
15:22:18 <TomMD> dons: I am happy you are contributing to the world in even greater ways than lambdabot, so don't worry about it :-)
15:22:24 <vincenz> dcoutts: I heard there might be problems with duncosmiloop
15:22:39 <dcoutts> vincenz: did you, what was that?
15:22:45 * Heffalump perks up his ears ;-)
15:22:48 <TomMD> sorear: Is that their nicks?  grep++ and nrb23 (the latter of whom I have seen before)
15:22:48 <vincenz> well that it might not go at it this yaer
15:22:56 <Heffalump> who told you that?
15:23:01 <vincenz> Igloo
15:23:04 <Heffalump> ah
15:23:08 <sorear> TomMD: karma!
15:23:08 <dcoutts> he didn't tell us :-)
15:23:13 <sorear> @karma TomMD
15:23:14 <lambdabot> TomMD has a karma of 0
15:23:15 <Heffalump> I may have told him I probably wouldn't, I can't remember
15:23:16 <sorear> TomMD++
15:23:16 <vincenz> fact that Heffalump has to travel 2 hours etc..
15:23:17 <dcoutts> mind you, I might be pretty busy too
15:23:22 <sorear> @karma TOmMD
15:23:22 <lambdabot> TOmMD has a karma of 0
15:23:26 <Heffalump> I'm certainly currently thinking I probably won't.
15:23:27 <sorear> @karma TomMD
15:23:27 <lambdabot> TomMD has a karma of 1
15:23:28 <vincenz> I'll be in greece
15:23:32 <sorear> TomMD--
15:23:37 <sorear> @karma grep
15:23:37 <lambdabot> grep has a karma of 2
15:23:52 <sorear> TomMD: nrb23 is real however
15:24:10 <Heffalump> dcoutts: something that calls the ByteString code indirectly is coming up as using 48% of the time.
15:24:16 <TomMD> @karma nrb23
15:24:16 <lambdabot> nrb23 has a karma of 0
15:24:18 <Heffalump> But it has no children in the profile output.
15:24:28 <Heffalump> and I'm pretty sure it's not doing any other work itself
15:24:39 <vincenz> Heffalump: poor bastard
15:24:48 <vincenz> no children, no work
15:24:50 <Heffalump> vincenz: but I get to use Haskell in my day job :-)
15:25:06 <vincenz> Heffalump: I meant the 'it' you were talking about :)
15:25:09 <Heffalump> ah, not the travelling, the profile :-)
15:25:10 <TomMD> Wow, impressive accomplishment.
15:26:17 <dcoutts> Heffalump: I sometimes get incomprehensible results from profiling too
15:26:43 <Heffalump> I should probably try a later ghc, and possibly recompile fps with -auto-all, assuming it doesn't already have that.
15:26:54 <Heffalump> (which IIRC the cabal default is not to)
15:27:28 <vincenz> dcoutts: still down under? How long are you staying tehre?
15:27:36 <Heffalump> dcoutts: one interesting feature of what I'm doing is sort of partially parsing a binary format, producing a structure with lots of ByteString chunks from the original file left in
15:27:50 <dcoutts> vincenz: 'til the end of next month.
15:27:53 <Heffalump> then I process that result, and it's that step that's apparently taking up a lot of time
15:28:14 <vincenz> dcoutts: wow, I thought it was a conference
15:28:25 <dcoutts> Heffalump: so that's going to hold onto the whole input
15:28:46 * vincenz envies dcoutts 
15:28:54 <vincenz> dcoutts: I bet the weather is super there and you go to the beach every day
15:29:00 <dcoutts> Heffalump: since taking a substring keeps the original
15:29:14 <dcoutts> vincenz: erm, nope, writing a paper for a deadline
15:29:24 <Botje> mm
15:29:25 <vincenz> dcoutts: ah yeah, I know the feeling
15:29:31 * vincenz is working on his fricking ++C compiler in haskel
15:29:40 <vincenz> unaptly named SIMPLE
15:29:40 <Heffalump> dcoutts: wouldn't it have to copy it given the different tail?
15:29:46 <dcoutts> Heffalump: perhaps the first bit is getting done lazily so the cost doesn't turn up 'til your second phase
15:29:59 <Heffalump> I was kind of hoping it'd fuse, though that was probably rather optimistic
15:30:15 <Heffalump> in principle I could have parameterised the first reader with the function the second processing step uses
15:30:26 <Heffalump> ah, yes, laziness might explain a lot
15:30:42 <pjd_> vincenz: ++C?
15:30:52 <dcoutts> Heffalump: at the moment only stuff like maps, filters and folds fuse. General recursive definitions do not
15:31:09 <Heffalump> oh yeah. Duh.
15:31:22 <dcoutts> Heffalump: so you're building one lazy bytestring by extracting chunks from another right?
15:31:23 <vincenz> pjd_: well yes :)
15:31:24 <Heffalump> I'd have known that if I'd thought about it for 30 seconds.
15:31:27 <dons> yeah, only explicit pipelines of fusible functions. more likely though , a slowdown would be a complexity issue, or a strictness one
15:31:34 <Heffalump> dcoutts: I'm building multiple ones by doing that
15:31:57 <dcoutts> Heffalump: but each substring chunk that you take holds onto the whole chunk it's a substring of
15:32:00 <Sgeo> @source (>>==)
15:32:01 <lambdabot> (>>==) not available
15:32:05 <Sgeo> @source (>>)
15:32:05 <lambdabot> (>>) not available
15:32:13 <Sgeo> @source (>>=)
15:32:13 <lambdabot> (>>=) not available
15:32:16 <dcoutts> Heffalump: so unless you explicitly copy you are holding the whole input
15:32:24 <Heffalump> ah, right
15:32:41 <Heffalump> I didn't realise that making a chunk with take and drop wouldn't be a copy.
15:32:41 <dons> we have 'copy' for this purpose, btw.
15:32:45 <dcoutts> Heffalump: you can take substrings and call copy, that unshares the chunk
15:32:51 <dons> right, its a O(1) substring op.
15:32:56 <pjd_> vincenz: is it an existing language, or what?
15:32:58 <dons> just tweaks the ptr offset
15:33:00 <dcoutts> Heffalump: take and drop are cheap
15:33:03 <Heffalump> I didn't actually want to copy, I wanted it to fuse. I should have thought it through better :-)
15:33:05 <pjd_> not exactly the most googlable name :)
15:33:21 <sorear> pjd_: it's C++ done right, and mentioned in the logs
15:33:28 <dcoutts> Heffalump: if you can write it as a fold it will :-)
15:33:28 * sorear tries to find it
15:33:44 <nmessenger> @src [] (>>=)
15:33:44 <lambdabot> m >>= k     = foldr ((++) . k) [] m
15:33:46 <nmessenger> ^^ Sgeo, you need to specify a type
15:33:55 <Sgeo> @source (>>=)::IO
15:33:55 <lambdabot> (>>=)::IO not available
15:33:57 <Sgeo> @source (>>=)::IO a
15:33:58 <lambdabot> (>>=)::IO a not available
15:33:58 <pjd_> "C++ done right" doesn't quite compute
15:33:59 <vincenz> sorear: ooh my own marketing guy :)
15:34:03 <nmessenger> @src IO (>>=)
15:34:03 <lambdabot> m >>= k     = bindIO m k
15:34:09 <sorear> Sgeo: you're using the wrong command
15:34:18 <Sgeo> hm?
15:34:21 <Heffalump> darcs get http://urchin.earth.li/darcs/ganesh/gps/ if you're interested in looking (and only if you're interested)
15:34:22 <lambdabot> Title: Index of /darcs/ganesh/gps
15:34:30 <dons> vincenz: re. icfp. not sure yet. i probably don't have a team this year :-)
15:34:31 <sorear> Sgeo: @source is for whole modules (only)
15:34:36 * dons looks around for teams with missing members
15:34:39 <vincenz> dons: ;)
15:34:40 <sorear> Sgeo: @src is for individual functions
15:34:40 <Sgeo> @src (>>=)::IO
15:34:41 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:34:43 <Sgeo> @src (>>=)::IO a
15:34:44 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:34:49 <vincenz> dons: Lazy Bottoms..
15:34:52 <vincenz> ..
15:34:53 <Igloo> Heffalump, dcoutts, vincenz: I didn't say there might be problems, I just said we hadn't talked about it (and mentioned the travel thing, but that's the same as last year)
15:34:56 <Heffalump> dcoutts: yeah. I'll have to think about it some more, cos currently the readers are structured as a monad (quite similar to Binary, but I'm not using that atm because I started beforehand)
15:34:58 <sorear> Sgeo: alas, that syntax doesn't work
15:34:59 <SamB> icfp???
15:35:02 <sorear> @src IO >>=
15:35:03 <SamB> already?
15:35:03 <lambdabot> Source not found. Take a stress pill and think things over.
15:35:06 <sorear> @src IO (>>=)
15:35:06 <lambdabot> m >>= k     = bindIO m k
15:35:14 <vincenz> SamB: no, but I get excited 3 months in advance
15:35:15 <sorear> Sgeo: @src is very tempermental
15:35:17 <nmessenger> @src bindIO
15:35:17 <lambdabot> bindIO (IO m) k = IO ( \ s ->
15:35:17 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
15:35:25 <sorear> @src++
15:35:25 <lambdabot> src <id>. Display the implementation of a standard function
15:35:29 <Sgeo> unIO?
15:35:30 <sorear>  @src++
15:35:32 * SamB is still working on *last* years
15:35:35 <sorear> Sgeo: yea, unIO
15:35:38 <sorear> @src unIO
15:35:38 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:35:39 <vincenz> what if we started a haskell-lambdabot?
15:35:40 <nmessenger> @src IO
15:35:40 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:35:41 <Heffalump> Igloo: ah, ok. Well, I'm suffering from sleep deprivation every day right now, so I'm not sure I want to add to it...
15:35:48 <Sgeo> What's the #?
15:35:49 <vincenz> and muted lambdabot in #haskell?
15:35:52 <sorear> unIO (IO a) = a, I guess?
15:35:58 <nmessenger> I'd guess unIO (IO x) = x
15:36:02 <SamB> vincenz: hmm?
15:36:29 <SamB> vincenz: just edit the source to turn off the snide comments and send dons a patch, and he should apply it
15:36:33 <sorear> vincenz: nah, just auto-kickban people who use the bot three times in sixty seconds for three hours
15:36:41 <Sgeo> @type unIO
15:36:43 <lambdabot> Not in scope: `unIO'
15:36:46 <nmessenger> Sgeo: # is a ghc primop
15:36:52 <sorear> @type GHC.IOBase.unIO
15:36:54 <lambdabot> forall a. IO a -> GHC.Prim.State# RealWorld -> (# GHC.Prim.State# RealWorld, a #)
15:36:55 <dcoutts> Heffalump: right. Yeah I was going to say you might want to look at the Binary package. It depends somewhat on the file format if that'd be appropriate, it's tuned for reading files with lots of small records, not big chunky things really.
15:37:05 <vincenz> SamB: no that's not it, it's just getting spammy
15:37:11 <SamB> vincenz: oh.
15:37:11 <vincenz> SamB: the snide comments are funny )
15:37:13 <Heffalump> I'm trying to read Palm databases, so it'd probably do the job ok
15:37:37 <Heffalump> but instance Binary Double put me off a bit, cos it's not the standard IEEE representation (unless I'm confused)
15:37:57 <SamB> dcoutts: also Binary isn't so great for tree-structured files
15:37:57 <sorear> Heffalump: nope, quite far from it
15:38:07 <malsyned> is mfail the same as [] in the List monad?
15:38:13 <sorear> SamB: what is tree-structured?
15:38:14 <SamB> or graph structured, or what have you...
15:38:18 <sorear> malsyned: there is no mfail
15:38:21 <sorear> @src [] fail
15:38:21 <malsyned> or it it mzero?
15:38:22 <lambdabot> fail _      = []
15:38:25 <sorear> @src [] mzero
15:38:25 <lambdabot> mzero = []
15:38:26 <dcoutts> Heffalump: that's a nightmare to do portably, double I mean
15:38:29 <Heffalump> (I went to some trouble to implement a proper reader for the IEEE representation, and I bet it doesn't get optimised to a no-op :-)
15:38:31 <SamB> sometwo: well, any in which the file contains offsets
15:38:34 <sorear> dcoutts: really?
15:38:36 <SamB> er.
15:38:36 <malsyned> ah.  so I was spelling it wrong, but both.
15:38:37 <SamB> sorear: .
15:38:37 <Heffalump> really? It didn't seem that hard to me.
15:38:48 <sorear> dcoutts: IEEE 754 is well defined
15:38:52 <dons> Heffalump: for IEEE hmm, might be easier to ffi call to a C function to do it, then CDouble -> Double it?
15:39:15 <vincenz> @pl \a b c -> c b a
15:39:15 <lambdabot> flip (flip . flip id)
15:39:16 <Heffalump> dons: yeah, I did consider that, just didn't feel like dealing with the hassle
15:39:19 <dcoutts> Heffalump: the main problem is we don't know it's aligned in memory
15:39:19 <vincenz> @pl \a b c d -> d c b a
15:39:20 <sorear> dcoutts: it might not be native double, but it does satisfy the Principle of Least Suprise for a portable format
15:39:20 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
15:39:27 <vincenz> @pl \a b c d e -> e d c b a
15:39:27 <lambdabot> flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))
15:39:29 <dons> :t decodeFloat
15:39:31 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
15:39:35 <dons> is what we use, of course.
15:39:38 <vincenz> I see a pattern
15:39:39 <sorear> dcoutts: how hard can it be to bitpack an unaligned value
15:39:45 <Heffalump> I don't think my code handles all the different infinities and NAs correctly, but apart from that it's ok
15:40:12 <Heffalump> dcoutts: does x86 expect them to be 8-byte aligned?
15:40:17 <dcoutts> sorear: right, converting from IEEE format in the file to whatever the native Double format is, how do you do that in Haskell portably?
15:40:27 <Heffalump> dcoutts: by decoding IEEE format
15:40:27 <sorear> Heffalump: x86 has no alignment reqs
15:40:29 <dcoutts> Heffalump: x86 doesn't mind unaligned loads
15:40:33 <SamB> vincenz: Haskell has the things you would need to take a Float/Double apart and put it back together again
15:40:37 <Heffalump> I don't see why you care about alignment then
15:40:39 <sorear> Heffalump: they're slower, but work
15:40:47 <dons> Heffalump: so hmm, how do you get at the bits in the Double from haskell in the first place?
15:40:47 <dcoutts> Heffalump: not all the world is x86 :-)
15:40:53 <dons> decodeFloat then munge?
15:40:57 <Heffalump> dons: yes
15:41:00 <sorear> dons: that's what I'd do
15:41:03 <SamB> vincenz: at least, if it doesn't, then it should...
15:41:05 <vincenz> SamB: thanks, erm context?
15:41:08 <sorear> dons: with a platform ifdef for speed
15:41:15 <dcoutts> @type decodeFloat
15:41:15 <Heffalump> (right now I just read them, so my code just does encodeFloat after reading words)
15:41:17 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
15:41:22 <dons> > decodeFloat pi
15:41:23 <lambdabot>  (7074237752028440,-51)
15:41:23 <Heffalump> but I wrote code that did this at ARM too which went both ways, IIRC
15:41:29 <sorear> dons: ieee754 is the defacto standard for portable float storage
15:41:32 <Heffalump> I just don't have the code any more
15:41:44 <SamB> vincenz: you seemed to think there was some portability problem with reading/writing IEEE floating-point numbers portably?
15:41:50 <vincenz> SamB: wrong person
15:41:53 <SamB> oh.
15:41:55 <SamB> sorry!
15:41:55 <sorear> SamB: dcoutts
15:41:56 <Heffalump> the only problem is with all the different bit representations of NA and Infinity
15:41:57 <vincenz> np
15:41:59 <dcoutts> sorear: we know, it's just not easy to do in Haskell because the format of Dobule is not specified
15:42:05 <Heffalump> since Double doesn't distinguish them (or even promise to have them, IIRC?)
15:42:06 <sorear> dcoutts: sure it is
15:42:09 <SamB> vincenz: you are both of the same color and size
15:42:23 <Heffalump> dcoutts: but encodeFloat/decodeFloat are specified
15:42:33 <Heffalump> so at least non-exceptional values can be handled fine
15:42:33 <sorear> dcoutts: decodeFloat + Data.Bits
15:42:35 <Heffalump> even denormals
15:42:46 <dcoutts> Heffalump: right, but that doesn't make it easy to convert into IEEE for storage in the file.
15:42:50 <sorear> dcoutts: I am not conflating ieee with native
15:42:58 <sorear> dcoutts: that's what Data.Bits is for :)
15:43:02 <Heffalump> how do you define "difficult"?
15:43:06 <dons> > decodeFloats (1/0)
15:43:07 <lambdabot>   Not in scope: `decodeFloats'
15:43:10 <dons> > decodeFloat (1/0)
15:43:11 <lambdabot>  (4503599627370496,972)
15:43:15 <Heffalump> my verbose code looks like it's about 10 lines long
15:43:18 <alexj> @seen glguy
15:43:18 <lambdabot> glguy is in #happs and #haskell. I last heard glguy speak 2h 21m 34s ago.
15:43:19 <SamB> dcoutts: that isn't going to be much trouble to do portably
15:43:29 <SamB> sure, maybe it will be troublesome
15:43:36 <SamB> but the portability problems are not there
15:43:49 <Heffalump> troublesome and inefficient, unless your compiler is really smart
15:43:59 <dcoutts> so I take my Double and I want to convert it to IEEE format to put in the file, how does encodeFloat or decodeFloat help? that gives me something else I need to convert into IEEE format
15:44:03 <sorear> dcoutts: IMO the principle of least suprise says we shouldn't use a custom float format
15:44:08 <Heffalump> dcoutts: but IEEE format is well defined
15:44:17 <SamB> dcoutts: something which you have hope of converting, though
15:44:23 <Heffalump> and decodeFloat gives you precisely the information you need to construct the IEEE format
15:44:25 <dons> sorear: no. its a serialisations library for haskell values
15:44:29 <dons> we can use any format we want
15:44:43 <dons> it is *not* supposed to be a cross-language marshalling layer
15:44:48 <Heffalump> dons: which is fair enough, but it makes it unsuitable as a library for decoding native formats, which is a shame.
15:44:52 <dons> though people do try to use it like that, and it works for some cases.
15:44:53 <SamB> dons: we need one of those, too, anyway....
15:44:54 <Heffalump> s/native/standard/
15:44:55 <dcoutts> Heffalump: oh but it's so ugly, how much code is it to convert the Int + Integer to IEEE format when it should be just a no-op.
15:45:05 <dons> Heffalump: you basically need a layer on top for all the custom / standard formats you need
15:45:07 <Heffalump> though I could of course just wrap Double with a newtype
15:45:12 <SamB> dcoutts: it might not be a no-op
15:45:20 <sorear> dons: really? I though you said Data.Binary.Get *was* general binary parsing
15:45:22 <Heffalump> dcoutts: you can't have both portable and no-op, it's logically impossible.
15:45:23 <SamB> it might need to involve swapping parts of things
15:45:31 <dcoutts> SamB: right, on some platforms where Haskell's Double is not IEEE then it's not a noop
15:45:44 <sorear> dons: and once we have a Get action for reading the one standard float format ....
15:45:59 <dcoutts> Heffalump: sure, but we can have it a no-op on common platforms
15:45:59 <sorear> dcoutts, Heffalump: #ifdef!
15:46:01 <SamB> dcoutts: does IEEE say what order to store the bits in?
15:46:09 <vincenz> SamB: yes
15:46:10 <dons> sorear: no. its Read/Show. the underlying primops and monad work fine for general binary protocols though
15:46:11 <Heffalump> sorear: or a rewrite rule
15:46:28 <sorear> Heffalump: rewrite rules aren't platform specific
15:46:36 <SamB> sorear: sure they are
15:46:40 <SamB> #ifdef!
15:46:45 <Heffalump> :-)
15:46:55 <sorear> Heffalump: #ifdef __x86__ double2IEEE = unsafeCoerce# #else complicated_code #endif
15:47:08 <Heffalump> I did think about unsafeCoerce#, but I don't think it's quite that simple
15:47:15 <SamB> Heffalump: I think the list would be a bit more inclusive
15:47:17 <Heffalump> what do you unsafeCoerce# to?
15:47:20 <dons> it makes sense to make a seperate IEEE module providing instances of Binary, or instances of a new class, that encode values to ieeee formats
15:47:30 <dons> class IEEE a where
15:47:37 <sorear> dons: wait, you want us to use Read/Show for anything not in Data.Binary.Binary format?
15:47:38 <Heffalump> dons: fair enough
15:48:00 <sorear> Heffalump: unsafeCoerce# :: Double# -> Word64# works fine, from experience.
15:48:02 <Heffalump> though Binary's serialisation format for Double/Float is also relatively inefficient in the common case, presumably.
15:48:07 <Heffalump> sorear: portably across LE/BE?
15:48:12 <dons> sorear: no. Binary is a binary Read/Show. i.e.e serialisation. we pick a format that works for haskell values.
15:48:29 <dons> the underlying monad is useful for arbitrary binary protocol parsing
15:48:41 <dons> but the Binary class and instances itself is specifically for haskell values
15:48:48 <sorear> dons: that's Data.Binary.Binary, the type class.  I think we're talking about the :: Data.Binary.Get.Get Double function.
15:48:50 <sorear> I think.
15:48:51 <Heffalump> that sounds fair enough
15:49:04 <dons> sorear: there's no such function.
15:49:13 <dons> sorear: there's only the Binary Double instance
15:49:14 <SamB> that isn't a function name
15:49:44 * vincenz wants type-level functions
15:49:49 * sorear has them
15:49:54 <dcoutts> Heffalump: aye, so ultimately what we should do is have that ugly code to give us IEEE format via decode/encodeFloat and then #ifdef for the Haskell platforms where we know the Double format is already IEEE
15:50:00 <vincenz> M.Map i $ M.Map i x
15:50:16 <vincenz> fst (a,b)
15:50:29 <Heffalump> hmm, annoyingly my monad has a skip operation which Get doesn't have
15:50:29 <dcoutts> and add code for unaligned reads on platforms that don't like unaligned ops
15:50:45 <Heffalump> or rather, a "skip to absolute offset"
15:51:03 <dcoutts> Heffalump: ah, only "skip n bytes"
15:51:04 <sorear> Heffalump: look into DeferedBinary
15:51:11 <Heffalump> URL?
15:51:14 <sorear> @where DeferedBinary
15:51:14 <lambdabot> I know nothing about deferedbinary.
15:51:16 <sorear> @where DeferredBinary
15:51:17 <lambdabot> I know nothing about deferredbinary.
15:51:21 <sorear> bah
15:51:32 <sorear> @where ndm
15:51:32 <lambdabot> http://www.cs.york.ac.uk/~ndm/
15:51:59 <dcoutts> Heffalump: but we do keep track of the current offset in the file so you can implement skip to absolute location, so long as that location is ahead of the current offset
15:52:05 <dons> yeah.
15:52:39 <dcoutts> Heffalump: we don't do random seeks though, that needs a different data structure (tree rather than list)
15:52:51 <Heffalump> I only need skip forward
15:53:03 <Heffalump> I don't see that in your monad
15:53:14 <Heffalump> oh, yes I do
15:53:15 * Heffalump is blind
15:53:22 <dons> -- | Skip ahead @n@ bytes. Fails if fewer than @n@ bytes are available.
15:53:22 <dons> skip :: Int -> Get ()
15:53:24 <Heffalump> right, I should clearly abandon my monad :-)
15:53:45 <dons> the main thing is that Data.Binary is massively tuned.
15:53:49 <Heffalump> precisely
15:53:58 <Heffalump> will you accept a patch for adding a skip to absolute, then?
15:54:03 <dons> yes.
15:54:17 <SamB> I want something with skip every which way *and* laziness.
15:54:18 <dcoutts> dons: the read side isn't
15:54:28 <dons> well, its tuned. just not massively :-)
15:54:29 * Heffalump puts it on the list to do on the train tomorrow
15:54:29 <SamB> just because it is not possible.
15:54:43 <SamB> well, actually it is possible. just not easy.
15:54:44 <dcoutts> SamB: me too, it's probably a rope of strict chunks, rather than a list of chunks
15:55:11 <Heffalump> any ideas on how to make Get computations that run on chunks produced by another Get computation to fuse?
15:55:33 <dons> gee, how much data are you reading?
15:55:44 <dcoutts> Heffalump: I worry about getting a hodge-podge of an api, skip to absolute should be trivial in terms of relative skip and getting the current offset.
15:55:46 <dons> you want to avoid bounds checks on gets?
15:55:46 <Heffalump> not that much, it's the principle of the thing :-)
15:56:07 <dons> i'd only be worried once you need more than hmm, 500M/s
15:56:08 <Heffalump> dcoutts: oh, you have bytesRead, I missed that to begin with. Sorry.
15:56:24 <dcoutts> Heffalump: you're not generating new data right? just selecting bits from an existing stream?
15:56:26 <dons> dcoutts: i just plan to do an api audit eventually, and remove most things ;-)
15:56:29 <Heffalump> dcoutts: correct
15:56:42 <Heffalump> I have a generic Palm database reader that chops up a PDB into records
15:56:53 <Heffalump> and then another pass that takes the records and parses them into a specific kind of database
15:57:08 <dcoutts> Heffalump: so there's not much to fuse I think
15:57:19 <Heffalump> oh, cos the chunks are O(1) pointers?
15:57:23 <sorear> SamB: you want deferredbinary
15:57:30 <sorear> SamB: ask ndm for the url
15:57:30 * Heffalump is clearly too slow to be any good at this optimisation business :-)
15:57:41 <SamB> last I checked, there was no url
15:57:46 <dcoutts> Heffalump: the best you can do is to fuse the generation/consumption of the list of chunks
15:57:51 <SamB> there was only a blog entry about it
15:58:02 <dcoutts> the chunks are not copied
15:58:05 <Heffalump> right, yeah
15:58:38 <dcoutts> Heffalump: what fraction of the original input stream do you select? it might make more sense to copy
15:58:42 <SamB> @ask ndm is defferredbinary available yet? where?
15:58:42 <lambdabot> Consider it noted.
15:58:49 <Heffalump> each record is typically a few tens of bytes
15:58:52 <dons> sorear: have you used deferredbinary?
15:58:57 <Heffalump> in a file of maybe 1MB size
15:59:01 <dons> sorear: i'm not sure its in  useable state?
15:59:16 <dcoutts> Heffalump: and you grab all the records or just a few ?
15:59:16 <SamB> dons: is it available yet?
15:59:28 <dons> i'm not the author. so i don't know. i suspect not?
15:59:29 <sorear> /var/cache/stefan-downloads/irclogs/www.cse.unsw.edu.au/07.01.13:13:57:20 <ndm_> sorear, http://www.cs.york.ac.uk/fp/darcs/binarydefer/Data/Binary/Defer.hs - lots of unsafePerformIO
15:59:31 <lambdabot> http://tinyurl.com/y23jxr
15:59:32 <dcoutts> Heffalump: and you generate a new list of records or a lazy ByteString ?
15:59:38 <SamB> dons: I know this
15:59:41 <Heffalump> dcoutts: that depends on the consumer of the final database
15:59:42 <sorear> I filally found it...
15:59:46 <Heffalump> but normally all of them
15:59:48 <sorear> no I haven't used it
16:00:01 <sorear> I'm just being a human project database :)
16:00:04 <SamB> if you were the auther, probably you'd know if it could be used. plus probably you'd have a repo with a URL.
16:00:07 <Heffalump> dcoutts: generate at what stage?
16:00:25 <Heffalump> data RawPDB = RawPDB {
16:00:25 <Heffalump>    rpdbHeader :: DatabaseHdrType,
16:00:25 <Heffalump>    rpdbRecordEntries :: [RecordEntryType],
16:00:25 <Heffalump>    rpdbAppInfo :: Maybe Input,
16:00:26 <Heffalump>    rpdbSortInfo :: Maybe Input,
16:00:28 <Heffalump>    rpdbRecords :: [Input]
16:00:31 <Heffalump> } deriving (Show)
16:00:38 <Heffalump> is what the first stage generates, where Input is a lazy ByteString
16:00:50 <sorear> repo with URL: http://www.cs.york.ac.uk/fp/darcs/binarydefer/
16:00:51 <lambdabot> Title: Index of /fp/darcs/binarydefer
16:00:57 <sorear> dunno if it can be used
16:00:57 <Heffalump> and then I turn that into something that completely consumes the bytestrings
16:00:59 <dcoutts> Heffalump: I guess what I'm asking is do you select 50 bytes, then skip 10k then select another 50 bytes? or is it more like chopping a 1Mb file into 1000, few byte records
16:01:01 <SamB> sorear: true
16:01:05 <sorear> it is used by hoogle 4
16:01:08 <Heffalump> the latter
16:01:11 <SamB> but probably dons would have added it to @where ;-)
16:01:12 <sorear> which itself cannot be used
16:01:29 <Heffalump> well, normally, though it would depend entirely on the consumer of the final list of parsed records
16:01:39 <Heffalump> my current application is processing GPS traces, which you tend to want to do linearly
16:01:41 <sorear> SamB: would he have added it under the incorrect name I used in the quesy
16:01:47 <sorear> @where binarydefer
16:01:48 <lambdabot> I know nothing about binarydefer.
16:01:54 <dcoutts> Heffalump: ok, so sharing is probably best, you'd not save much by allowing the original input to be GC'ed
16:01:57 <Heffalump> if you had something that was more random access, you'd probably want to jump around more
16:02:01 <SamB> sorear: I'm not sure!
16:02:06 <SamB> @hwre deferred binary
16:02:07 <lambdabot> Maybe you meant: more where
16:02:13 <Heffalump> yes, that's certainly the case, the records take up almost all the initial input normally anyway
16:02:13 <SamB> @where deferred binary
16:02:14 <lambdabot> I know nothing about deferred.
16:02:30 <SamB> I think he called it "deferred binary" in the blog entry
16:02:30 <Heffalump> oh, but I guess if many of them weren't ever used they might get GCed early
16:03:13 <dcoutts> Heffalump: no, because we read the input in 32k chunks, so any substring in that chunk retains the whole chunk
16:03:32 <Heffalump> sorry, I meant "might get GCed early if we copied"
16:03:39 <dcoutts> Heffalump: right
16:04:36 <Heffalump> hmm, getting these lists to fuse will be tricky, there's a zipWith involved in the production end
16:05:23 <dcoutts> Heffalump: our new list lib can fuse zipWith
16:05:28 <SamB> yeah. I Wonder how long until we have a fusion system that can handle that?
16:05:28 <SamB> ho?
16:05:34 <Heffalump> does it make me breakfast too?
16:05:36 * SamB spoke too late
16:05:40 <dcoutts> hah hah hah
16:05:53 <SamB> Heffalump: if you want breakfast made of non-existant lists, yes
16:06:12 <Heffalump> does it fuse zipWith as a producer and a consumer of both its arguments?
16:06:19 <dcoutts> yes
16:06:21 <Heffalump> wow
16:06:36 <SamB> I don't think it counts as "fusing zipWtih" if it doesn't do that, Heffalump ;-)
16:06:57 <SamB> er. modulo orbitz
16:07:01 <dcoutts> well eg we can only fuse unzip on the consuming side
16:07:07 <dcoutts> @type unzip
16:07:09 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
16:07:27 <dons> we could fuse fst . unzip / snd . unzip
16:07:38 <dons> it'd be a special case
16:07:41 <reilly> is "undefined" the correct way to reference â¥ in a haskell program?
16:07:48 <dcoutts> we can just rewrite those to map fst
16:07:48 <Heffalump> ok. I think what I need fused is "\x -> foldr f e (zipWith g x (map h x))" or something like it
16:08:11 <Heffalump> (there's some monads involved, but that's what the computation looks like if you ignore those)
16:08:15 <SamB> don't people write map fst and map snd for that anyway?
16:08:17 <dcoutts> Heffalump: that should all fuse under our system
16:08:35 <SamB> Heffalump: why are we ignoring monads?
16:08:35 * Heffalump hands over his credit card details
16:08:40 <TSC> reilly: I think so
16:08:41 <dcoutts> hah hah
16:08:55 <Heffalump> SamB: cos I'm hoping that the fact that the lists are generated inside a monad wouldn't matter. Probably optimistically.
16:09:04 <dons> foldr  zipith . map should be pretty simple
16:09:04 * SamB indicates the PayPal Donate button
16:09:07 <dcoutts> it does matter :-(
16:09:09 <pejo> Heffa, is that foldr "typical" for your application?
16:09:31 <SamB> yeah. Monads suck.
16:09:31 <dons> it'd fuse in streams right now, i think.
16:09:35 <Heffalump> well, most cases that foldr will just be a map and then I'll use the list in a non-good consumer kind of way
16:09:55 <reilly> TSC: thanks ... some times it's difficult to translate haskell typography to compilable text
16:10:25 <dcoutts> our general rule of thumb is that we should be able to fuse all cases where lists are used as control structures, not data structures
16:10:35 <SamB> reilly: usuaully you just have to unmash some punctuation ;-)
16:10:39 <Heffalump> what's the distinction?
16:10:47 <dcoutts> Heffalump: sharing
16:10:57 <Heffalump> well, there's no sharing here
16:11:03 <SamB> Heffalump: places where, in C, you would just use control structures
16:11:05 <Heffalump> at least there isn't in sensible uses
16:11:08 <dcoutts> Heffalump: single producer consumer per element
16:11:24 <Heffalump> it's just a pipeline as you describe. Except for the duplication of x as you see above.
16:11:24 <pejo> dcoutts, are control structures not shared?
16:11:39 <SamB> or *wish* you could
16:11:50 <Heffalump> oh, is listArray a good consumer?
16:12:00 <dcoutts> Heffalump: not at the moment but it could be
16:12:02 <SamB> should be
16:12:11 <SamB> I thought it was?
16:12:30 <reilly> TSC: yeah, i know.  bottom (â¥) is annoying because it's neither "bottom", nor _|_
16:12:40 <dcoutts> SamB: array is, listArray is not. Currently under build/fold that is. With streams both would be fusible.
16:13:02 <SamB> dcoutts: wouldn't they both be fusable with build/fold?
16:13:08 <dcoutts> pejo: I don't know what you mean.
16:13:14 <SamB> just not necessarily implemented?
16:13:41 <dcoutts> SamB: no, because listArray as a fold is too higher-order to be implemented efficiently
16:13:49 <pejo> dcoutts, you said you're able to fuse all cases where lists are used as control structures and not data structures, Heffalump asked what the difference was and you said sharing.
16:13:58 <SamB> dcoutts: even if it was crushinated afterwards?
16:14:09 <dcoutts> SamB: that bit is exactly the problem.
16:14:10 <pejo> dcoutts, or did I misinterpret?
16:14:19 <dcoutts> SamB: that passing of n, n+1, from one iteration to the next is done as a higher order thing.
16:14:28 <SamB> oh.
16:14:49 <dcoutts> pejo: so I mean sharing of elements and tails of lists for example
16:15:00 <SamB> and you couldn't flatten this out with an order-lowering pass?
16:15:05 <dcoutts> pejo: where something needs to inspect a list element more than once
16:15:30 <dcoutts> SamB: could do, but ghc doesn't at the moment, nor for the last 10 years since build/fold was added
16:15:53 <Heffalump> dcoutts: so how does my lambda expression above fuse?
16:16:13 * SamB wonders how hard an order-lowering pass is to integrate with seperate compilation
16:16:15 <dcoutts> \x -> foldr f e (zipWith g x (map h x))
16:16:38 <Heffalump> oh, and I failed to mention that x itself is a good producer, sorry.
16:16:39 <dcoutts> SamB: it's only a local anaylsis that's needed for this case
16:16:52 <dcoutts> Heffalump: that doesn't help since it's duplicated
16:17:06 <sorear> SamB: specializing/inlinining, aka Mitchell defunctionalization
16:17:07 <dcoutts> Heffalump: unless you unshare x
16:17:11 <Heffalump> right
16:17:27 <Heffalump> but you claimed it fused, above
16:17:32 <SamB> hey, is that ndm's name?
16:17:33 <dcoutts> Heffalump: the lambda isn't a problem since we never really look at it
16:17:43 <sorear> SamB: you seem to be having a lot of ndmmy thoughts today ;)
16:17:51 <Heffalump> yeah, I was just trying to draw attention to the duplication bit with it
16:17:51 <dcoutts> Heffalump: we just fuse foldr f e (zipWith g x (map h x)) and x is shared
16:17:52 <sorear> Neil David Mitchell iirc
16:18:12 <SamB> who is this defunctionalization named for?
16:18:30 <dcoutts> Heffalump: right, so we'd say: Stream.foldr f e (Stream.zipWith g (List.stream x) (map h (List.stream x)))
16:18:47 <Heffalump> ah, ok, so map and zipWith are still explicitly consuming x?
16:18:49 <sorear> the original defunc is named for John Reynolds, ndm has a new defunc for Catch
16:18:54 <dcoutts> Heffalump: so x as a list is shared, and we draw from it twice
16:19:06 <Heffalump> ok
16:19:09 <sorear> but I don't think he's ever called it be his name :)
16:19:22 <ehird> @src zipWith
16:19:22 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:19:23 <lambdabot> zipWith _ _      _      = []
16:20:19 <ehird> zipWith = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . ((flip . (ap .)) .)) .) . flip flip head . ((flip . ((flip . ((.) .)) .)) .) . liftM2 flip (((.) . flip . (((.) . (:)) .)) .))
16:20:21 <ehird> it's art
16:20:22 <ddarius_> sorear: If I understand correctly, ndm's defunctionalization doesn't sound like it works anything like Reynold's.
16:20:24 <dcoutts> Heffalump: also as it stands we can't 'see' x anyway we know nothing of its structure so there's no more fusion opportunity unless that lambda abstraction gets applied to a good producer and beta-reduced
16:20:44 <Heffalump> yeah, that's why I said x is actually a good producer, I'd oversimplified
16:20:49 <dcoutts> Heffalump: and even then you'd need to unshare x by passing x twice and applying it to the same producer twice
16:21:13 <Heffalump> I don't follow that
16:21:31 <sjanssen> is there a flavor of multithreading that is deterministic?
16:21:38 <dcoutts> (\x y -> foldr f e (zipWith g x (map h y))) [1..100] [1..100]
16:21:47 <ddarius_> declarative concurrency
16:22:02 <dcoutts> Heffalump: to fuse x we'd need to duplicate it as above
16:22:07 <sorear> ddarius_: and that's a good thing!
16:22:10 <sjanssen> ddarius: is this like ghc's par?
16:22:16 <Heffalump> ah, right
16:22:30 <sorear> ddarius: without open data types, reynolds defunc is necessarily whole program
16:22:31 <Heffalump> and that would destroy the streaming of the actual input it comes from :-)
16:22:38 <sorear> ddarius: ndm's is always local
16:22:44 * SimonRC goes to bed
16:22:46 <dcoutts> Heffalump: we don't change sharing properties since we can't know if it's an improvement
16:22:48 <ddarius> No.  Though, that too is deterministic as it only changes (in theory) performance characteristics.
16:22:49 <Heffalump> I guess I should restructure my code not to use zipWith
16:23:19 <ddarius> sorear: Yes, I understand that.  But the first thing that comes to my head from your description doesn't sound like it's anything like defunctionalization.
16:23:21 <dcoutts> Heffalump: right, a map over x
16:23:36 <sjanssen> whenever I try to use par I find that it isn't powerful enough, so I end up using MVars, forkIO and unsafePerformIO
16:23:41 <Heffalump> it's a bit spread out in actual fact, of course
16:23:43 <pejo> sorear, how can defunctionalization always be local? (Or what does local mean in this context?)
16:24:01 <dcoutts> Heffalump: map (\x -> g x (h x))
16:24:27 <Heffalump> dcoutts: yes, I know that, but it's not so simple when the structure I described is only visible after inlining.
16:24:37 <dcoutts> Heffalump: right
16:24:43 <ddarius> sjanssen: If you want -concurrency- (in Haskell), you want things like forkIO.
16:25:05 <sorear> pejo: in dependency order.  ndm's defunc (actually he calls it the firstifier) needs to see the definition of called functions, but in that respect it is no worse than the Simplifier.
16:25:06 <dcoutts> Heffalump: that's an interesting example actually, ziping over two variations of the same stream
16:25:19 <Heffalump> it arises from the PDB format
16:25:23 <sjanssen> ddarius: I really want parallelism, but with more control
16:25:25 <ddarius> sjanssen: par and co, is just for parallelism and performance.  Declarative concurrency is interesting, though not as powerful as "full" concurrency.  It's covered in CTM.
16:25:30 <Heffalump> it has a list of record entries which describe the offsets of the actual records
16:25:51 <ddarius> sjanssen: Perhaps some of the other Haskell+parallelism extensions/languages?
16:26:01 <pejo> sorear, in what sense is that local?
16:26:34 <sjanssen> ddarius: I'm wondering if I could write something like the ST monad.  unsafePerformIO on the inside, but deterministic on the outside
16:26:40 <sorear> pejo: in the same sense as ghc's separate compilation is local...
16:27:14 <sorear> thought: Streams are purely pull.  unzip can be fused if you push.
16:27:18 <ddarius> sjanssen: Have you read CTM (Concepts, Techniques and Models of Computer Programming)?
16:27:27 <sjanssen> ddarius: nope
16:27:42 <ddarius> A "declarative concurrency" monad would be kinda cool, and may or may not get you what you want.
16:28:03 <ddarius> (Though such a monad would be deterministic on the inside too)
16:28:18 <sorear> foldr/build is push, and can handle unzip (poorly) but not zip.
16:28:35 <sorear> what would a bidi system look like?
16:28:46 * sorear is talking mostly at dcoutts
16:29:44 <ddarius> sjanssen: Earlier drafts of CTM should be floating about the internet.
16:29:46 * Heffalump goes to bed
16:30:46 <dcoutts> sorear: foldr/build can only handle unzip on the consuming side, as can we
16:30:55 <dcoutts> g'night Heffalump
16:31:28 <sorear> oh? that's odd
16:31:30 <ddarius> Definitely worth reading.
16:31:39 <dcoutts> @src unzip
16:31:39 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
16:31:42 <dcoutts> sorear: so how would you fuse unzip?
16:31:58 <dcoutts> sorear: see, it's a foldr so it can fuse on the consuming side
16:32:33 <dcoutts> if you do it by unsharing that's cheating
16:32:43 <dcoutts> so no (map fst xs, map snd xs)
16:33:00 <sorear> @typ build
16:33:02 <lambdabot> Not in scope: `build'
16:33:06 <sorear> @typ GHC.List.build
16:33:08 <lambdabot> Not in scope: `GHC.List.build'
16:33:13 <sorear> @typ GHC.Exts.build
16:33:15 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
16:33:19 <dcoutts> @type GHC.base.build
16:33:21 <lambdabot> Couldn't find qualified module.
16:33:25 <dcoutts> doh
16:33:29 <dcoutts> @type GHC.Base.build
16:33:31 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
16:33:32 <pejo> I have to go to bed as well. Bummer.
16:33:35 <sorear> drat, not polymorphic enough for the trick I was tring to pull.
16:33:44 <pejo> dcoutts, any time plan for writing anything about this, beyond the bytestring paper?
16:33:51 <dcoutts> pejo: ICFP
16:34:03 <dcoutts> deadline comming up shortly
16:34:13 * dcoutts goes off to hack
16:34:15 <sorear> unzip lst = build (\cons1 nil1 -> build (\cons2 nil2 -> foldr (\(a,b) ~(as,bs) -> (a `cons` as, b `cons` bs)) (nil1, nil2) lst))  -- I'm going for something like this, only type correct
16:34:29 <pejo> dcoutts, sweet. Happy hacking!
16:34:53 <sorear> of course, build requires that its type be listish :(
16:35:06 * sorear has idea
16:35:12 * sorear writes Data.Costream
16:37:07 <sjanssen> if Stream is co-data, is Costream co-co-data?
16:37:12 <sorear> ie data
16:37:13 <sorear> yes
16:37:50 * sjanssen is cuckoo for co-co data!
16:38:13 <SamB> sjanssen: co-koo?
16:38:44 <sorear> if you want to change it act now ... @remembering in 15 s
16:39:05 <sorear> @remember sjanssen * sjanssen is cuckoo for co-co data!
16:39:05 <lambdabot> Done.
16:39:05 <sjanssen> I'm happy
16:39:09 * ddarius prefers it the way it is.
16:39:34 <sorear> @quote sjanssen
16:39:34 <lambdabot> sjanssen says: I suspect that planet.haskell.org has more content on catamorphisms than cats
16:39:36 <sorear> @quote sjanssen
16:39:36 <lambdabot> sjanssen says: I suspect that planet.haskell.org has more content on catamorphisms than cats
16:39:37 <sorear> @quote sjanssen
16:39:38 <lambdabot> sjanssen says: * sjanssen is cuckoo for co-co data!
16:39:55 <dmead> @quote sorear
16:39:56 <lambdabot> sorear says: I can actually hold a conversation with chanserv [/talking about NOTICE]
16:40:05 <dmead> @quote dmead
16:40:05 <lambdabot> Cale says: [dmead] yo yo yo yo what it is mother fuckers [Cale] dmead: this isn't #scheme
16:40:47 <sorear> dmead: if it can't get a direct quote it does a global regex substring match
16:43:43 <ddarius> #schemeZ
16:43:48 <jcreigh> dmwit++ on the fly resizing in xmond
16:43:53 <ddarius> s/Z/?/
16:45:23 <sorear> a channel
16:45:33 <ddarius> sorear: I know that.
16:46:25 * ddarius either doesn't get the humor or has a wildly inaccurate view of what #scheme is like.
16:46:56 <ddarius> The latter being quite possible as I've never been on it.
16:48:25 * sorear just mis-typed his root pw 4 times in a row :(
16:48:47 <ddarius> sorear: How exactly were you going to have your raytracer output?  Use typeclasses to generate a term whose value was the image data?
16:48:58 <sorear> ddarius: yes
16:50:04 <ddarius> Were you going to implement floats or somesuch at the type level too or what?
16:50:27 <nominolo> hm
16:50:51 <sorear> ddarius: yes.  which is where it stopped
16:51:02 <sorear> floats seem a bit hard
16:51:15 <sorear> then again, floats have been implemented in INTERCAL
16:51:17 <ddarius> Yeah.  Not really hard, but a bit tricky and some code.
16:51:24 <nominolo> how can an instance (Enum a, Bounded a) => ToBinary a where ...  overlap with an instance ToBinary Foo, although Foo neither is in Enum nor in Bounded?
16:51:32 <sorear> I can't imagine the haskell type system is much eviller :)
16:51:45 <ddarius> Fixed point would probably effective enough though.
16:51:47 <sorear> nominolo: type classes are open
16:52:16 <ddarius> instance ToBinary Int -- overlap
16:52:17 <nominolo> but if i have only these two declarations?
16:52:17 <sorear> nominolo: there is no way the compiler can tell that Foo will never be declared an instance of Enum or bounded
16:52:33 <sorear> nominolo: not without whole-program analysis, anyway
16:52:38 <nominolo> hm
16:52:44 <sorear> nominolo: which is something ghc won't do by design
16:53:41 <nominolo> so whenever i define a typeclass memmbership based on other typeclasses i can only have one such instance declaration?
16:54:14 <sorear> you can have as many as you want, as long as they have nontrivial heads
16:54:25 <sioraiocht> yeah, i HATE trivial heads...
16:54:29 <sorear> single variable heads get very messy
16:54:40 <sorear> and can deadlock the compiler!
16:55:38 <nominolo> well, i had the compiler in a loop because of those problems
16:55:49 <nominolo> fortunately after it spit out the error message
16:56:31 <nominolo> @where Binary
16:56:32 <lambdabot> http://darcs.haskell.org/binary
16:58:27 <mux> dcoutts: here?
17:00:27 <sorear> * *dcoutts goes off to hack [16:33]
17:01:46 <mux> damn :
17:02:10 <mux> make that :)
17:02:13 <mux> http://mu.org/~mux/LambdaChess.png
17:02:29 * mux hearts gtk2hs
17:02:52 <mux> the board and the pieces are SVG files
17:04:41 <mux> if someone with graphical skills can make up a nice SVG tango-like icon for that app that would be great :-)
17:07:38 <dcoutts> mux: looks very nice!
17:08:33 <dcoutts> so do you re-render the svg each time or render those icons to cached surfaces and composite them?
17:08:55 <dcoutts> compositing is much faster, it'd allow you to smootly animate moves etc
17:08:57 <mux> happy that you like it
17:09:03 <mux> it makes a nice gtk2hs screenshot :)
17:09:08 <dcoutts> it does indeed!
17:09:10 <mux> I re-render them every time for now
17:09:13 <dcoutts> right
17:09:20 <mux> I just did a quick showup to have pieces on the board
17:09:25 <dcoutts> check out the cairo clock demo for the caching technique
17:09:28 <dcoutts> right
17:09:47 <mux> and did that little dialog box to get my hands on gconf
17:10:01 <dcoutts> graphics cards are very fast at compositing, rendering svg is v. slow by comparison
17:10:12 <dmead> :o
17:10:17 <dmead> mux: how long did that take you?
17:10:23 <dcoutts> so only re-render the svg if you need to zoom / change the size of the pieces etc
17:10:38 <mux> dmead: really not long, I'm not sure, 5-6 days maybe
17:10:44 <dmead> neat
17:10:54 <dmead> you should get that into portage or apt
17:10:57 <mux> it's actually more of a 2 days work if you can spend all your time on it
17:11:03 <mux> and even less if you're already used to gtk
17:11:12 <mux> dmead: it's not functional at all
17:11:18 <dcoutts> mux: so you're using gconf for the settings or something ?
17:11:22 <dmead> oh
17:11:22 <mux> dcoutts: yes
17:11:28 <dcoutts> neat
17:11:32 <mux> dcoutts: only one setting so far though, the background color
17:11:32 <dmead> can you move the peices at all?
17:11:37 <mux> I have a small schema
17:11:48 <mux> dmead: not yet, but that's really not far away
17:11:53 <dmead> ahh
17:12:01 <mux> I'm going to finish my PGN parser and whip up some code to talk to chess engine
17:12:07 <mux> and I hope, FICS too soon
17:12:08 <dmead> you should try and hook it into a chess AI
17:12:30 <mux> then the only "hard" bit is checking moves validity, which is at least needed for local games
17:12:41 <mux> yes, it'll hook itself to gnuchess, crafty, etc
17:12:46 <mux> there's a standard protocol for that
17:12:51 <dmead> cool
17:13:04 <dmead> yea when you do the network code i'd like to see how thats done
17:13:08 <dmead> for more than small examples
17:14:02 <sorear> dcoutts: how fast is sw composition?
17:14:08 <Gum> newbie question: so because haskell programs require so few LOC compared to other langauges, its a good choice for rapid application development?
17:14:12 <mux> dmead: sure
17:14:15 <dcoutts> sorear: still pretty quick
17:14:23 <sorear> dcoutts: intuitively I'd expect the small inner loop and cache effects to make it v. fast
17:14:30 <dmead> Gum: yes, once you know the language
17:14:37 <mux> oui
17:14:42 <mux> oops, misfire
17:14:54 <dcoutts> sorear: but it's obviously faster if you keep the stuff X -server side since then it can live in the gfx card memory
17:15:01 * sorear doesn't have enough use for a gfx excellerator
17:15:02 <Gum> http://tinyurl.com/yvmysh  i have that book on order
17:15:33 <sorear> dcoutts: my X server runs on a reasonable fast machine, so np
17:15:39 <dmead> Gum: do you know any functional programing?
17:15:43 <Gum> no
17:15:55 <dmead> you might wanna try lisp first
17:15:57 <Gum> i haven't programmed since CIS201 back in 2000
17:15:58 <dmead> because it's so simple
17:16:03 <sorear> I just loathe the concept of specialized processors for making pretty pictures :/
17:16:27 <dmead> i did lisp -> Ml -> Haskell
17:16:34 <dmead> and i feel reasonable confident with FP now
17:16:41 <Gum> i've been reading the scheme programming language 3rd edition
17:16:42 <dmead> *reasonably
17:16:46 <dmead> ahh
17:16:50 <dmead> yes thats similar
17:16:57 <sorear> C -> unlambda -> haskell.  I like to forget the middle stage :)
17:17:16 <nmessenger> you actually wrote things in unlambda?!
17:17:19 <dmead> C++ -> C -> Java -> lisp -> ML -> haskell
17:17:21 <dmead> for me
17:17:57 <dmead> and some bullshit called php and perl
17:17:58 <sorear> nmessenger: not much.  but enough to recognize that the perfect language was lying somewhere under that awful syntax...
17:18:09 <dmead> whats unlambda?
17:18:15 <sioraiocht> dmead: you can't beat perl's regexps =)
17:18:28 <dmead> yea, i can
17:18:37 <sorear> dmead: you heard of INTERCAL?
17:18:41 <nmessenger> @unlambda ``s`ii`s`ii
17:18:41 <dmead> with perl regexps snytax in any other language
17:18:41 <lambdabot> Plugin `unlambda' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:18:45 <dmead> heard of it, not read any about it
17:19:03 <mux> sorear: PLEASE COMEFROM 10
17:19:15 <sioraiocht> dmead: but plays so nicely with strings :)
17:19:28 <mux> dcoutts: btw, the "API search" form on the gtk2hs page still points at the 0.9.10 docs
17:19:53 <dcoutts> mux: aye, I need to update it to the latest release
17:20:10 <dmead> i almost wrote a tool for my internship in haskell
17:20:18 <dmead> but java webstart is too easy to maintain
17:23:03 <dons> mux, very nice!
17:23:20 <dons> mux: dcoutts just showed me the lambdaChess graphics. nifty!
17:23:32 <vincenz> ooh where?
17:24:01 <Sgeo> Is presentation also supposed to be separated from logic, the way IO is?
17:24:21 <sorear> your choice
17:24:41 <sorear> we haven't figured out how to enforce it in the typesystem yet :)
17:27:15 <sorear> wierdly, I'm a much better C programmer post-haskell
17:27:28 <vincenz> s/ C//
17:27:30 <pjd_> s/C //, surely
17:27:34 <pjd_> haha
17:27:44 <vincenz> damn, that was too good
17:27:45 <sioraiocht> lol
17:27:46 <sorear> I only feel 2-3 times less productive
17:28:00 <sorear> while the jump was more like 20-30x starting
17:28:21 <dmead> maybe it's just your standards that have improved
17:28:27 <dmead> :P
17:28:31 <pjd_> > (foldl (+) 0 [1..5])
17:28:32 <lambdabot>  15
17:28:39 <pjd_> > take 5 (foldl (+) 0 [1..5])
17:28:40 <lambdabot>   add an instance declaration for (Num [a])
17:28:40 <lambdabot>     In the expression: 5
17:28:46 <sorear> pjd_: surely you want foldr :)
17:28:47 <pjd_> what's up with that?
17:28:56 <nmessenger> pjd_: 15 isn't a list :P
17:29:00 <vincenz> > foldr (+) 0 [1..5]
17:29:00 <Sgeo> pjd_, foldl is a number
17:29:01 <sorear> pjd_: 15 isn't a list :{
17:29:01 <lambdabot>  15
17:29:02 * pjd_ facethwaps
17:29:04 <pjd_> yeah, i just saw
17:29:09 <pjd_> braino
17:29:25 <sorear> pjd_: aside: foldl is almost never what you want
17:29:33 <pjd_> i was thinking of scan
17:29:43 <nmessenger> "facethwap" and "braino"?  New vocabulary!
17:29:55 <vincenz> braino I had heard before
17:29:58 <vincenz> I call it semantico
17:29:58 <sorear> pjd_: foldwise, 80% you want foldr, 19% you want foldl' (note the ')
17:30:04 <vincenz> typo and semantico
17:30:17 <dmead> whats a facethwap
17:30:22 <sorear> pjd_: as for foldl unprimed, I only know of one use
17:30:23 <roconnor> @google recv: resource vanished
17:30:25 <vincenz> probably a facepaml
17:30:25 <lambdabot> http://ubdata.uni-paderborn.de/ediss/17/2006/heine/disserta.pdf
17:30:29 <dmead> do you bang your head on the keyboard?
17:30:32 * sorear slaps dmead in the face
17:30:34 <nmessenger> sorear: and the remaining 1%?
17:30:38 <dmead> xd
17:30:41 <dmead> xDD
17:30:45 <dmead> :D
17:30:46 <pjd_> sorear: which is?
17:30:46 <TSC> Is there a good place to discuss xmonad (other than here)?
17:30:52 <dmead> doubt it
17:31:05 <sorear> TSC: #haskell-overflow :)
17:31:06 <pjd_> dmead: it's like when you thwap your dog on the head
17:31:10 <pjd_> only without your dog
17:31:13 <roconnor> what does "recv: resource vanished (Connection reset by peer)" mean?
17:31:14 <dmead> oh right
17:31:21 <vincenz> thwap is a bad word
17:31:29 <roconnor> from Network.HTTP presumably
17:31:33 <TSC> Ah, thanks sorear
17:31:33 <Sgeo> In school, during math, I was writing Haskell stuff in my notes
17:31:34 <sorear> roconnor: the remote host (peer) closed (reset) the handle
17:31:53 <pjd_> (descriptor)
17:31:57 <dmead> i was thinking of a dethklock episode during my calc midterm
17:31:58 <roconnor> oh, that's sad
17:31:59 <sorear> roconnor: often, but not always, the result of a remote sw crash
17:32:01 <dmead> and haskell code =/
17:32:42 <Sgeo> I was wondering, can I make a function such as derivAt :: (Num a) => (a -> a) -> Int -> a -> a
17:32:58 <sorear> Sgeo: what's the Int for?
17:33:02 <Sgeo> and define derivAt for specific functions as the first argument?
17:33:08 <sorear> Sgeo: surely you wanted Nat :)
17:33:29 <sorear> Sgeo: anyway, you can only make an approximation
17:33:52 <sorear> Sgeo: or you can reify functions yourself, but you lose the convienience of application that way
17:34:00 <Sgeo> reify?
17:34:23 <sorear> maybe I meant reflect, I always get the two mixed up
17:34:28 * Sgeo doesn'
17:34:34 * Sgeo doesn't know what reify means
17:34:37 <dmead> la la la
17:34:39 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/Prover.hs
17:34:42 <dmead> look ma, i used a monad
17:35:07 <sorear> data Function = Add Function Function | Mul Function Function | X | Const Int | ...
17:35:54 <sorear> dmead: you want tips?
17:36:06 <dmead> yea sure
17:36:08 <sorear> resolveAux looks suspiciously tail recursive
17:36:15 <dmead> indeed
17:36:39 <sorear> result ++ [x] takes O(n), each time
17:36:53 <dmead> yep
17:37:11 <sorear> it looks like this is one of those cases where laziness does well enough and you don't need tr
17:37:21 <dmead> hmm
17:37:22 <thorat> Sgeo: you might be interested in http://www.haskell.org/pipermail/haskell/2004-November/014939.html
17:37:24 <lambdabot> Title: [Haskell] Typeful symbolic differentiation of compiled functions, http://tinyurl.com/2gxa53
17:37:45 <dmead> yea i considered using a foldr as well
17:37:54 <dmead> but it really wouldn't cut down on anything loc
17:37:57 <dmead> and be a bit messy
17:38:28 <sorear> dmead: I see your formalish comments - perhaps you should use haddock syntax?
17:38:39 <dmead> hmm
17:38:43 <dmead> never considered that
17:38:50 <dmead> i'll give it a look
17:38:53 <Sgeo> sorear, ty
17:39:23 <dmead> apparently my proff wrote a similar program in ML
17:39:30 <dmead> but with mutual recursion
17:41:26 <sorear> mutual?
17:41:28 <dmead> also
17:41:28 <dmead> darcs get http://taz.cs.wcupa.edu/~dmead/code/prover/
17:41:31 <sorear> haskell does that too
17:41:38 <sorear> already did :)
17:41:51 <dmead> i know, felt this way is a clearer algorithm
17:41:58 <mdmkolbe> this might be slightly OT, but people around here are generally smart so I'll ask.  What are the known relationships between context sensitive parsing and complexity classes? == P? >= NP? >NP? PSPACE? (Wikipedia is inconsistant on this.)
17:42:19 <dmead> mdmkolbe: if you can prover P  = NP
17:42:23 <dmead> you get a million bucks
17:42:32 <dmead> *prove
17:42:41 <sorear> context free languages can be parsed in O(inputlength^3), so P
17:42:51 <sorear> wikipedia CYK_algorithm
17:43:02 <mdmkolbe> sorear: context *sensitive* languages are what I'm after
17:43:26 <sorear> context sensitive is defined in terms of turing matchines, so >EXPSPACE in general...
17:44:42 <mdmkolbe> sorear: that's what I thought, but I'm not sure sure.  One page on Wikipedia says CSG ~~ linear bounded TM, but other pages claim CSG is PSPACE complete and other claim conflicting stuff
17:45:48 <mdmkolbe> dmead: yeah, but I'd be more worried about destabilizing the world economy if I proved P = NP, because it would crack public key crypto.  bye-bye online banking
17:45:52 <sorear> mdmkolbe: when wp is inconsistant I usualy check google.  not like it's much more likely
17:46:07 <dmead> man that don't matter
17:46:12 <sorear> mdmkolbe: O(n^graham) is P but won't break pkc
17:46:17 <dmead> the US and UK won't use rsa in their crypto
17:46:30 <mdmkolbe> graham == ?
17:46:33 <dmead> so that means they already know how to factor huge numbers
17:46:44 <sorear> @goog graham's number
17:46:45 <lambdabot> http://en.wikipedia.org/wiki/Graham's_number
17:46:46 <lambdabot> Title: Graham's number - Wikipedia, the free encyclopedia
17:47:40 <sorear> dmead: RSA is weak if factorization is easy.  are you saying the converse has been proven?
17:47:58 <sorear> dmead: surely other weaknesses could exist, I'd think..
17:48:26 <mdmkolbe> sorear: I think he's saying that the US and UK spy orgs have already figured out how to factor large numbers which is why they wont use it
17:48:37 <dmead> yea
17:48:48 <dmead> why wouldn't they use it
17:48:59 <dmead> if it is so impossible to crack
17:49:17 <mdmkolbe> sorear: though in truth it may just be that they have *really* big super computers that can do it, or (until 5-10 years ago) it might have something to do with the patent on RSA
17:50:08 <sioraiocht> mdmkolbe: I'm guessing the NSA still can't brute force 4096-bit RSA keys
17:50:11 <mdmkolbe> all public key cryptography is a bet that P!=NP (practicly speaking).  And if 20 years from now someone finds a practicle way to do P=NP, then all the state secrets would be broken retroactively
17:50:51 <sioraiocht> mdmkolbe: key generation techniques almost always outpace cracking power -- todays technology can't always crack yesterday's crypto
17:50:53 <sorear> mdmkolbe: the first wouldn't matter. if the nsa can crack 1024-bit rsa in a week, and current complexity bounds are true, 1044-bit rsa would take 'em 20 years, 1064 20,000 years
17:51:25 <dmead> my secure chat program uses 1024 bits
17:51:26 <mdmkolbe> dmead: when you are a huge spy org, it's cheap enough to use one-time-pad (which *can't* be broken regardless of advances (we think)) that public key is probably an unnessisary risk
17:51:26 <dmead> sooo
17:51:28 <sioraiocht> most of the weaknesses in PKI exist in using dictionary attacks in passkeys
17:51:29 <vincenz> that's why I like 2048 bts
17:51:31 <dmead> if i conspire to do something
17:51:38 <dmead> i got a week to do it before the man comes down on me?
17:51:38 <heatsink> I'm pretty sure factoring numbers is in P.
17:52:02 <heatsink> Oh, that's primality testing. nm.
17:52:10 <dmead> hehe
17:52:26 <sioraiocht> heatsink: I was gonna say... =p
17:52:27 <sorear> I'd like a real nondeterministic computer :)
17:52:39 <vincenz> sorear: just get a jar of coffee
17:52:45 <dmead> the canadians can hook you up
17:52:46 <vincenz> sorear: good luck on observing it
17:52:47 <sorear> factoring numbers IS in P
17:52:57 <sioraiocht> sorear: I read somewhere that it had been proven that quantum crypto is mathematically unbreakable
17:53:25 <vincenz> sioraiocht: in what mathematics?
17:53:55 <sorear> sioraiocht: aiui, quantum crypto is (a) a misnomer (b) does NOTHING to prevent man-in-the-midddle
17:53:57 <dmead> i think thats cause when you observe the data it chaanges?
17:54:00 * QtPlatypus doesn't think we know enought yet about QM to say that quantum crypto is unbrakable.
17:54:09 <Pseudonym> sorear: (b) is not true.
17:54:17 <mdmkolbe> sioraiocht: that is true, but so is one-time-pad.  Basically quantum crypto is a one-time-pad key generator that can always detect wire-taps
17:54:17 <dmead> yea
17:54:19 <pjd_> unbrakable? :)
17:54:19 <dmead> cause of what i said
17:54:20 <sorear> also, remember there is no defense against social engineering
17:54:22 <dmead> man in the middle
17:54:22 <Pseudonym> Quantum communication channels (which is not crypto) can be made tamper-proof.
17:54:28 <dmead> observes quantum stuff
17:54:30 <dmead> changes the state
17:54:31 <Pseudonym> Right./
17:54:35 <dmead> so then it's destroyed
17:54:35 * pjd_ thinks of those slow-light substances
17:54:41 <sioraiocht> Pseudonym: yes
17:54:54 <dmead> ya can fix stupid
17:54:56 <sioraiocht> Quantum KEY generation prevents man in teh middle attacks
17:55:03 <sorear> Pseudonym: you are the nsa, dmead is gchq.  You *think* I am ghcq, dmead thinks I'm the nsa.
17:55:17 <sioraiocht> vincenz: i'd have to ask the computaitonal physicist that told me, i took him for his word =p
17:55:18 <dmead> whats ghcq?
17:55:20 <sorear> Pseudonym: now if I am truly in the middle (not just tapping)...
17:55:33 <sorear> gchq == a british spy agency
17:55:39 <vincenz> ghcq = ghc quarters
17:55:41 <sioraiocht> sorear: that's why authentication exists...
17:55:42 * sorear is an uninformed american
17:55:47 <Pseudonym> sorear: Right.  I'm specifically talking about quantum communication channels.
17:55:48 <mdmkolbe> you mean they're not MI5 anymore?
17:55:57 <dmead> hehe
17:56:01 <Pseudonym> If there's a classical "thing" in the middle, you could theoretically tap that.
17:56:07 <dmead> i was going to apply to the NSA
17:56:19 <dmead> but then i realized i'm better off not working for the man
17:56:23 * sioraiocht refuses to do reserach for the US gov't anymore.
17:56:30 <mdmkolbe> Pseudonym: can you can tap it, but with quantum you can't tap it without the sender and receiver noticing
17:56:31 <Pseudonym> I couldn't imagine working for soemthing like the NSA.
17:56:35 <Pseudonym> It's not even what they do.
17:56:38 <Pseudonym> It's the work environment.
17:56:43 <dmead> they sent some of their guys to my school
17:56:48 <dmead> and gave us a 2 hours speil
17:56:50 <Pseudonym> Imagine not being able to have water cooler discussions about work.
17:57:00 <Pseudonym> Or not being able to IRC.
17:57:08 <Pseudonym> Or not even having a mobile phone in the office.
17:57:09 <dmead> according to him everyone is such an introvert that it doesn't matter
17:57:12 <sioraiocht> Pseudonym: I worked at a military reserach lab for a bit
17:57:17 <dmead> there isn't any desire to like
17:57:19 <dmead> talk to people
17:57:19 <sioraiocht> it sucked
17:57:23 <pjd_> dmead: cause or effect? :)
17:57:26 <mdmkolbe> Pseudonym: I imagine they mostly talk about non-work stuff like maybe sports
17:57:35 <dmead> pjd_: of?
17:57:40 * Pseudonym used to work for a defence contractor that worked with more secretive agencies
17:57:41 <pjd_> introversion
17:57:47 <dmead> ah
17:57:54 <dmead> cause of no conversations
17:58:05 <sioraiocht> Pseudonym: depends on clearance, most people with SCI are authorised to know most anythign else, and they'll talk about their work with each other
17:58:06 <vincenz> Pseudonym: ooh the ones without acronyms?
17:58:21 <dmead> "you know you work at the NSA when the extroverts look at other peoples shoes"
17:58:27 <dmead> is the joke this guy told
17:59:01 <mdmkolbe> googling for "context sensitive parsing complexity" doesn't turn anything up right away to answer the question
17:59:09 <sioraiocht> shocking
17:59:17 <sioraiocht> it's not an esoteric subject or anything =p
17:59:24 <Pseudonym> As I seem to recall, CSGs are equivalent to linear-bounded automata.
17:59:32 <dmead> mdmkolbe: there is programming language theory search engine someplace
17:59:34 <dmead> but i forget the url
17:59:51 <pjd_> googling for "human genome download", on the other hand, does
18:00:05 <pjd_> it's a wonderful world we're in
18:00:05 <mdmkolbe> Pseudonym: Wikipedia does state that, but Wikipedia is inconsitant on this very topic so I'm not sure I can trust it
18:00:06 <Pseudonym> In the same way that CFGs are equivalent to push-down automata and REs are equivalent to finite state automata.
18:00:31 <Pseudonym> I'm 99.9% certain that much is true.
18:00:40 <Pseudonym> And I didn't consult Wikipedia.
18:00:57 <fantasma> what's a creative set of names I can assign to 6 computers?
18:01:35 * sorear prefers _0, _1, _2, _3, _4, _5
18:01:40 * sorear isn't creative
18:02:01 <Pseudonym> fantasma: Do you have a naming convention on any existing machines?
18:02:17 <sorear> fantasma: uuidgen :)
18:02:20 <mdmkolbe> fantasma: comic book characters.  roman or norse gods, burrowing animals (ant, mole) etc.  (These are example from my school) Just make sure they are easy for people to remember how to spell and are short
18:02:29 <fantasma> Pseudonym, no
18:02:37 <heatsink> fantasma: Everyone uses nouns.  Try some non-noun words or phrases.
18:02:50 <fantasma> heatsink, haha that's awesome
18:03:10 <Pseudonym> Six is, unfortunately, an odd number.
18:03:17 <sorear> iirc there are about six common pronouns
18:03:18 <Pseudonym> Not literally, obviously.
18:03:20 <fantasma> six or more
18:03:36 <Pseudonym> But there are lots of instances of seven stuff.
18:03:42 <sorear> @remember Pseudonym Six is, unfortunately, an odd number.
18:03:42 <lambdabot> Done.
18:03:54 <fantasma> I can do 7
18:03:56 <dmead> number six?
18:03:58 <dmead> is a sexy lady
18:04:04 <Pseudonym> How about deadly sins?
18:04:25 <fantasma> @google "deadly sins"
18:04:27 <lambdabot> http://www.deadlysins.com/
18:04:28 <lambdabot> Title: 7 Deadly Sins, 7 Heavenly Virtues
18:04:32 <Japsu> My computers were named Oryx, Crake and Snowman :)
18:04:47 <sorear> my computer is named stefans
18:05:00 <sorear> @ysers
18:05:00 <lambdabot> Maximum users seen in #haskell: 336, currently: 299 (89.0%), active: 43 (14.4%)
18:05:07 <Japsu> oh btw, everyone go read Atwood's Oryx and Crake
18:05:09 <Japsu> a great book
18:05:15 <Japsu> ysers? :D
18:05:19 <Japsu> @suers
18:05:19 <lambdabot> Maximum users seen in #haskell: 336, currently: 299 (89.0%), active: 43 (14.4%)
18:05:21 <procyon_> fantasma: I give all my computers women's names.  They are never quite acting the way I want them to and are very tempermental...
18:05:37 <fantasma> lol
18:05:43 <Pseudonym> My wife suggested once that I call my new work machine "mistress".
18:05:52 <heatsink> haha
18:06:02 <procyon_> My network is named "harem"
18:07:50 <sorear> dmead: "shouldn't get here"
18:07:58 <dmead> wheres that?
18:08:14 <dmead> you mean in my  code right?
18:08:17 <sorear> stefan@stefans:/tmp/prover$ ./Provermain 'a'
18:08:17 <sorear> "shouldn't get here"
18:08:17 <sorear> stefan@stefans:/tmp/prover$
18:08:27 <dmead> oh
18:08:33 <dmead> did you recompile it?
18:08:38 <dmead> or is that the binary from darks
18:08:43 <dmead> darcs
18:08:44 <dmead> woops
18:08:46 <sorear> recompiled
18:08:59 <dmead> ah
18:08:59 <dmead> k
18:09:14 <dmead> i guess i'll just print the help msg in that case
18:09:15 <sorear> the makefile didn't work, so I renamed the module and ghc --maked manually
18:09:22 <nmessenger> mine compy is currently named "smokey".  I once installed an old floppy drive, but it was dark so I plugged the (exposed) power thing in wrong.  Hence the name. :D
18:09:35 <procyon_> Pseudonym: Is there a connection between pure combinators and cellular automata?  I always have that feeling, when dealing with things like SKI calculus, that this is just a form of cellular automata... I can't put my finger on it, but it FEELS similar.
18:09:39 <dmead> sorear: runhaskell on Prover.hs
18:09:43 <dmead> and call testprover
18:09:43 <sorear> also, all your messages arein ""
18:09:51 <dmead> for a better time with it
18:10:02 <dmead> hmm k
18:10:12 <mdmkolbe> procyon_: you may want to take a look at arrows.  They may strenthen that feeling
18:10:19 <procyon_> hehe
18:10:40 <Pseudonym> Well they're both rewrite systems, I guess.
18:10:42 <dmead> what are arrows literally?
18:10:46 <dmead> reverse mapping?
18:11:02 <dmead> ( i haven't looked at them in depth )
18:11:15 <nmessenger> dmead: literally, they're rather abstract :D
18:11:21 <procyon_> Pseudonym: It feels like simple combinators are like Wolframs
18:11:29 <procyon_> 's initial patterns
18:11:39 <mdmkolbe> dmead: arrows are like a generalization of functions.  Like how monads are generalizations of computation yielding values
18:11:54 <dmead> neat
18:11:55 <ClaudiusMaximus> :t &&&
18:11:57 <lambdabot> parse error on input `&&&'
18:12:02 <ClaudiusMaximus> :t (&&&)
18:12:02 <heatsink> Has anyone here used type-level tuples before?
18:12:04 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:12:05 <mdmkolbe> :t (&&&)
18:12:07 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:12:20 <mdmkolbe> :i Arrow
18:12:26 <mdmkolbe> @info Arrow
18:12:26 <lambdabot> Arrow
18:12:32 <dmead> sorear: can you run my test cases?
18:12:34 <ClaudiusMaximus> (+1) &&& (*2) $ [1,2,3,4]
18:12:38 <mdmkolbe> :t arr
18:12:39 <ClaudiusMaximus> > (+1) &&& (*2) $ [1,2,3,4]
18:12:40 <lambdabot>   add an instance declaration for (Num [t])
18:12:41 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
18:12:45 <mdmkolbe> :t first
18:12:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
18:12:55 <mdmkolbe> :t (>>>)
18:12:57 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
18:13:04 <dmead> ooo
18:13:06 <ClaudiusMaximus> > map ((+1) &&& (*2)) $ [1,2,3,4]
18:13:07 <lambdabot>  [(2,2),(3,4),(4,6),(5,8)]
18:13:07 <nmessenger> > runKleisli (arr id) 1 :: [Int]
18:13:09 <lambdabot>  [1]
18:13:10 <dmead> i wanna make this a lambdabot plugin
18:13:35 <sorear> dmead: yes I can run the test cases
18:13:44 <sorear> dmead: but nothing else :)
18:14:00 <sorear> dmead: we already have a first-order theorem prover in lambdabot
18:14:06 <mdmkolbe> the class Arrow requires arr (lifting functions to arrows ~ return), (>>>) (arrow composition) and first (simple but not a single phrase explanations)
18:14:08 <dmead> yea?
18:14:10 <dmead> can we load it from here?
18:14:27 <sorear> @djinn (a -> b) -> (b -> c) -> (a -> c)
18:14:28 <lambdabot> f a b c = b (a c)
18:14:28 <dmead> ./prover check <logic>
18:14:49 <sorear> stefan@stefans:/tmp/prover$ ./Provermain check A
18:14:49 <sorear> Provermain: Prelude.read: no parse
18:15:09 <dmead> ah yea
18:15:16 <sorear> examples!
18:15:16 <dmead> use P
18:15:23 <roconnor> I don't think that djinn is first-order
18:15:38 <roconnor> @djinn (forall x. x=x)
18:15:39 <lambdabot> Cannot parse command
18:15:40 <heatsink> @djinn ((a->a)->a)->a
18:15:40 <lambdabot> f a = a (\ b -> b)
18:16:27 <dmead> sorear: sorry i'll make the instructions more explicit
18:16:29 <dmead> P->Q : Failed
18:16:31 <dmead> err
18:16:37 <dmead> ./prover check "P->Q"
18:17:11 <dmead> i use parsec to get expression types out of strings
18:17:52 <sorear> ((P->Q)->P)->P : Passed
18:18:03 <dmead> look at the bottom of InfixLogic
18:18:08 <sorear> ok, it's not like djinn then
18:18:17 <sorear> @djinn ((p -> q) -> p) -> p
18:18:18 <lambdabot> -- f cannot be realized.
18:18:26 <dmead> right
18:18:29 <dmead> i don't think i'm there yet
18:18:37 <sorear> there?
18:18:43 <dmead> to the point where it's useful
18:18:51 <sorear> I mean, halp is classical
18:19:00 <sorear> djinn is intuitionistical
18:19:06 <dmead> :o
18:19:24 <dmead> whats that mean exactly?
18:19:42 <sorear> intuitionistic logic rejects LEM
18:19:51 <vincenz> yay for acronyms
18:20:00 <dmead> LEM = ?
18:20:01 <roconnor> @djinn (Not (Not p -> p)) -> ((p -> q) -> p) -> p
18:20:01 <lambdabot> f a b = void (a (\ c -> void (c (b (\ d -> void (c d))))))
18:20:13 <sorear> law of the excluded middle
18:20:19 <roconnor> oops
18:20:22 <sorear> aka, Pv~P
18:20:24 <vincenz> ah right
18:20:32 <roconnor> @djinn ((Not (Not p)) -> p) -> ((p -> q) -> p) -> p
18:20:32 <lambdabot> f a b = a (\ c -> void (c (b (\ d -> void (c d)))))
18:20:35 <vincenz> ~~P <= P
18:20:37 <Pseudonym> LEM means combinatorial explosion.
18:20:38 <vincenz> instead of == P
18:20:51 <sorear> @djinn Either p (Not p)
18:20:52 <lambdabot> -- f cannot be realized.
18:21:00 <dmead> whats <=
18:21:08 <roconnor> @scheck \p q -> ((p <= q) <= p) <= p
18:21:10 <lambdabot>   Completed 4 test(s) without failure.
18:21:21 <Pseudonym> @djinn p -> Not (Not p)
18:21:21 <lambdabot> f a b = b a
18:21:26 <Pseudonym> @djinn Not (Not p) -> p
18:21:26 <lambdabot> -- f cannot be realized.
18:21:36 <Pseudonym> At least it's a topos.
18:21:48 <roconnor> @djin ((Not (Not p)) -> p) -> Either p (Not p)
18:21:48 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
18:21:54 <roconnor> @djinn ((Not (Not p)) -> p) -> Either p (Not p)
18:21:54 <lambdabot> -- f cannot be realized.
18:22:18 <roconnor> @djinn (Not (Not p, (Not (Not p)))
18:22:18 <lambdabot> Cannot parse command
18:22:20 <sorear> roconnor: nice try.  you need a forall for that to work right
18:22:20 <roconnor> @djinn (Not (Not p, (Not (Not p))))
18:22:21 <lambdabot> f (a, b) = void (b a)
18:22:24 <Pseudonym> @djinn Either p (Not p) -> (Not (Not p) -> p)
18:22:24 <lambdabot> f a b =
18:22:24 <lambdabot>     case a of
18:22:24 <lambdabot>     Left c -> c
18:22:24 <lambdabot>     Right d -> void (b d)
18:22:32 <sorear> @djinn-env
18:22:32 <lambdabot> Plugin `djinn' failed with: IRCRaised Data.ByteString.last: empty ByteString
18:22:38 <sorear> @djinn-names
18:22:38 <lambdabot> Plugin `djinn' failed with: IRCRaised Data.ByteString.last: empty ByteString
18:22:43 <roconnor> @scheck \p -> p || not p
18:22:44 <lambdabot>   Completed 2 test(s) without failure.
18:22:46 <sorear> what is void :/
18:22:54 <roconnor> void is the empty type
18:23:02 <sorear> Void is the empty type
18:23:07 <roconnor> scheck is our classical logic checker
18:23:08 <nmessenger> @index void
18:23:08 <lambdabot> Foreign.Marshal.Error, Foreign.Marshal, Foreign
18:23:09 <sorear> haskell is case sensitive
18:23:12 <mdmkolbe> Claim, SAT may be solved by a (non-det) linear bounded automita and context sensitive parsers are equivalent to linear bounded automita, thus CSG is NP-hard (NP-complete?).  Sound reasonable?
18:23:17 <roconnor> oops
18:23:31 <roconnor> right void is does case analysis on the empty type
18:23:35 <dmead> hey
18:23:36 <dmead> somebody
18:23:38 <dmead> whats <=
18:23:39 <roconnor> void :: Void -> a
18:23:40 <sorear> dmead: ->
18:23:44 <dmead> oh
18:23:54 <roconnor> @scheck \p q -> ((p <= q) <= p) <= p
18:23:55 <sorear> dmead: because of the way bools are ordered
18:23:57 <lambdabot>   Completed 4 test(s) without failure.
18:24:17 <dmead> whats it checking for?
18:24:23 <sorear> pierce's law
18:24:40 <roconnor> @type \p q -> ((p <= q) <= p) <= p
18:24:45 <lambdabot> Bool -> Bool -> Bool
18:24:53 <nmessenger> @type callCC
18:24:56 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
18:24:59 <roconnor> secheck makes sure the function returns true in all cases
18:26:16 <dmead> sorear: checking that it obeys it. or not?
18:26:38 <dons> that \p q -> ((p <= q) <= p) <= p is True.
18:26:43 <dons> :t \p q -> ((p <= q) <= p) <= p
18:26:48 <lambdabot> Bool -> Bool -> Bool
18:27:03 <dmead> always true?
18:27:12 <roconnor> that function is true in call cases so ((p -> q) -> p) -> p is a tautology
18:27:18 <dmead> ah
18:27:20 <dmead> clear now
18:27:24 <dmead> ty
18:28:42 <mcflightsuit> GrÃ¼Ã Gott!
18:29:39 <dmead> Hmm
18:29:51 <dmead> ./prover check "((P->Q)->P)->P"
18:29:59 <dmead> ((P->Q)->P)->P : Passed
18:30:07 <dmead> i guess thats good
18:30:17 <bd_> ?djinn (p -> q) -> p -> p
18:30:17 <lambdabot> f _ a = a
18:30:39 <dmead> ?type ->
18:30:40 <nmessenger> @djinn ((p->q)->p)->p
18:30:43 <lambdabot> parse error on input `->'
18:30:43 <lambdabot> -- f cannot be realized.
18:31:00 <bd_> ?kind (->)
18:31:02 <sorear> dmead: funciton arrow
18:31:02 <lambdabot> ?? -> ? -> *
18:31:26 <dmead> whats it mean f cannot be realized?
18:31:36 <fantasma> Pseudonym, what's another list of 7 names
18:31:39 * mdmkolbe washes lambdabot's mouth for swearing :-J
18:31:49 <bd_> dmead: It means the djinn can't make the function you want for some reason
18:31:50 <Pseudonym> Wonders of the world?  Dwarves?
18:31:51 <nmessenger> bd_: ((p->q)->p->p) /= (((p->q)->p)->p)
18:31:52 <Pseudonym> I dunno.
18:31:59 <bd_> ?djinn (a -> b) -> [a] -> [b]
18:32:00 <lambdabot> -- f cannot be realized.
18:32:01 <mdmkolbe> fantasma: plantets, asteroids
18:32:02 <Pseudonym> ?djinn-add data Arr a b
18:32:05 <bd_> nmessenger: oh, oops
18:32:07 <mdmkolbe> rivers
18:32:11 <mcflightsuit> Pseudonym, the sons of AulÃ«!
18:32:12 <bd_> ?djinn ((p -> q) -> p) -> p)
18:32:12 <lambdabot> Cannot parse command
18:32:17 <bd_> ?djinn ((p -> q) -> p) -> p
18:32:18 <lambdabot> -- f cannot be realized.
18:32:37 <nmessenger> @djinn ((p -> ((q->r)->r)) -> ((p->r)->r)) -> ((p->r)->r)
18:32:37 <lambdabot> f a b = a (\ c _ -> b c) b
18:33:02 <Pseudonym> ?djinn-add arrId :: a -> Arr a a
18:33:11 <mdmkolbe> fantasma: what quality do you want to embody in the machines (number cruchers, user machines, silly names, etc.)?
18:33:18 <Pseudonym> ?djinn-add arrAssocL :: Arr a (Arr b c) -> Arr (Arr a b) c
18:33:20 <dmead> @hoogle dijnn
18:33:20 <lambdabot> No matches found
18:33:26 <mcflightsuit> Well, over my head.
18:33:27 <dmead> @hoogle djinn
18:33:27 <lambdabot> No matches found
18:33:34 <dmead> ;o
18:33:34 <Pseudonym> ?djinn-add arrAssocR :: Arr (Arr a b) c -> Arr a (Arr b c)
18:33:35 <mcflightsuit> I might be back later though. :)
18:34:02 <Pseudonym> ?djinn a -> Arr a a
18:34:02 <sorear> dmead: hoogle isn't googel
18:34:03 <lambdabot> f = arrId
18:34:06 <fantasma> mdmkolbe, silly :)
18:34:15 <Pseudonym> ?djinn Arr Bool Bool
18:34:15 <lambdabot> -- f cannot be realized.
18:34:26 <Pseudonym> ?djinn Arr (a,b) a
18:34:27 <lambdabot> -- f cannot be realized.
18:34:29 <sorear> Pseudonym: djinn-add doesn't work as well asyou might think
18:34:32 <Pseudonym> Ah.
18:34:49 <mdmkolbe> fantasma: light hearted silly, funny silly or ironic silly?
18:34:49 <sorear> @google djinn augustss
18:34:52 <lambdabot> http://lambda-the-ultimate.org/node/1178
18:34:53 <lambdabot> Title: Djinn, a theorem prover in Haskell, for Haskell. | Lambda the Ultimate
18:35:00 <sorear> @google djinn url:augustss
18:35:01 <lambdabot> http://tunes.org/~nef/logs/haskell/06.12.21
18:35:11 <dmead> ahh
18:35:16 <sorear> @google chalmers djinn
18:35:19 <lambdabot> http://www.s2.chalmers.se/software/desco/install.html
18:35:19 <Pseudonym> ?djinn (Arr (Arr (Arr a b) c) d) -> (Arr (Arr a b) (Arr c d))
18:35:19 <lambdabot> f = arrAssocR
18:35:30 <Pseudonym> OK, that works.
18:35:41 <fantasma> mdmkolbe, light hearted is good, but I don't mind irony either
18:35:42 <dmead> jesus
18:35:45 <dmead> 262 patches
18:35:47 <dmead> i have 6 =/
18:36:13 <Pseudonym> ?djinn-add arrCompose :: Arr a b -> Arr b c -> Arr a c
18:36:31 <mdmkolbe> fantasma: literature is a good source of names for light hearted, e.g. characters from alice in wonder land
18:36:33 <Pseudonym> Ah, crap.
18:36:35 <sorear> dmead: augustss is something of a legend
18:36:39 <Pseudonym> ?djinn-del Arr
18:36:44 <Pseudonym> ?djinn-del arrAssocL
18:36:45 <Pseudonym> ?djinn-del arrAssocR
18:36:50 <Pseudonym> ?djinn-del arrId
18:36:53 <Pseudonym> ?djinn-del arrCompose
18:37:03 <fantasma> mdmkolbe, thanks
18:37:19 <mdmkolbe> fantasma: more ironic might be some of the abbriviations that we use online (e.g. RTFM, BRB, etc.)
18:37:25 <Pseudonym> ?djinn-add data Arr a b
18:37:34 <Pseudonym> ?djinn-add arrId :: a -> Arr a a
18:37:43 <Pseudonym> ?djinn-add arrCompose :: Arr a b -> Arr b c -> Arr a c
18:37:44 <dmead> hmm
18:37:55 <dmead> he doesn't use parsec or anything to look at text
18:38:10 <sorear> sure he does
18:38:17 <sorear> ReadP counts as something
18:38:33 <dmead> where?
18:38:52 <Pseudonym> ?djinn Arr a b -> Arr b c -> Arr c d -> Arr a d
18:38:53 <lambdabot> f = void
18:39:06 <Pseudonym> Oh, that's interesting.
18:39:29 <sorear> Pseudonym: Arr a b is falsity, since it has no constructors
18:39:41 <sorear> Pseudonym: therefore Arr b c -> Arr c d -> Arr a d follows easily
18:39:42 <mdmkolbe> fantasma: clesheyed (sp??), but the seven dwarvs are obvious.  Maybe add a twist.  "Crasher", "Trasher", etc.
18:39:44 <Pseudonym> sorear: I'd like it to be abstract.
18:40:01 <Pseudonym> Defined only in terms of the known functions which operate on it.
18:40:01 <sorear> @spell cliched
18:40:02 <lambdabot> cliched
18:40:11 <sorear> cliche`d, really
18:40:20 <sorear> er cliche'd
18:40:22 <mdmkolbe> thx
18:40:24 <Pseudonym> Gotta go.  Lunch.  BBS
18:40:40 <sorear> where e' is compose notation
18:40:41 * mdmkolbe hates post voul shift spelling
18:40:46 <mdmkolbe> @spell voul
18:40:47 <lambdabot> Vol vol Poul foul soul
18:40:52 <sorear> vowel
18:41:02 <dmead> hmmmmmmmmmmmmmmm
18:41:10 <dmead> @seen augustss
18:41:10 <lambdabot> augustss is in #haskell. I last heard augustss speak 1d 2h 20m 26s ago.
18:41:56 <mdmkolbe> @seen mdmkolbe
18:41:56 <lambdabot> You are in #haskell. I last heard you speak just now.
18:42:00 <fantasma> mdmkolbe, I think I will name them after perl operators: "addition" "subtraction" "division" "modulus" etc..
18:42:03 <abc> @SEEN ABC
18:42:03 <lambdabot> Unknown command, try @list
18:42:04 <sorear> clichÂd
18:42:10 <abc> @seen abc
18:42:10 <lambdabot> You are in #haskell. I last heard you speak just now.
18:42:13 <abc> @list
18:42:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:42:14 <mdmkolbe> @seen lambdabot
18:42:15 <lambdabot> Yes, I'm here. I'm in #gentoo-uy, #happs, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-haskell, #haskell.dut, #haskell.hac07, #haskell-overflow, #haskell-
18:42:15 <lambdabot> blah and #haskell
18:42:18 <Sgeo> > let _'freedom' = "slavery" in _'freedom'
18:42:23 <lambdabot>  "slavery"
18:42:37 <sorear> _'freedom' is one id
18:42:44 <sorear> > let 2 + 2 = 5 in 2 + 2
18:42:48 <lambdabot>  5
18:42:54 <Sgeo> How does that work?
18:43:01 <mdmkolbe> sometwo: bug in lambdabot?
18:43:19 <sorear> sometwo: ?
18:43:22 <mdmkolbe> s/sometwo/ sorear/
18:43:27 <mdmkolbe> autocomplete
18:43:45 <sorear> mdmkolbe: no, let 2 + 2 = 5 in 2 + 2 is legal haskell
18:43:55 <sorear> it defines a local function named (+)
18:44:01 <nmessenger> > let plus 2 2 = 5 in plus 2 2
18:44:03 <lambdabot>  5
18:44:05 <nmessenger> > let plus 2 2 = 5 in plus 2 3
18:44:06 <lambdabot>   Non-exhaustive patterns in function plus
18:44:11 <mdmkolbe> hehe, now I see
18:44:28 <Japsu> > let 2 + 2 = 5 in 2 + 3
18:44:31 <lambdabot>   Non-exhaustive patterns in function +
18:44:33 <Japsu> okay
18:44:41 <Japsu> so it completely shadows the original (+)
18:44:42 <sorear> Sgeo: and yes 2 + 2 = 5 was chosen quite deliberately
18:45:01 <Sgeo> 1984 ref?
18:45:03 <LoganCapaldo> > let 2 + 2 = Nothing in 2 + 2
18:45:06 <lambdabot>  Nothing
18:45:11 * Sgeo was on the humor page
18:45:31 <Sgeo> http://haskell.org/haskellwiki/Humor/1984
18:45:32 <lambdabot> Title: Humor/1984 - HaskellWiki
18:45:38 <LoganCapaldo> > let 2 + 2 = 2 + 2 in 2 + 2
18:45:39 <lambdabot>  Exception: <<loop>>
18:45:41 <fantasma> > let 2 + 2 = 5 in 1 + 1
18:45:42 <lambdabot>   Non-exhaustive patterns in function +
18:45:50 <sorear> Sgeo: yes, TWO AND TWO MAKE FIVE is a 1984 ref
18:46:14 <fantasma> > let 2 + 2 = 4 in 1 + 1
18:46:18 <lambdabot>   Non-exhaustive patterns in function +
18:46:29 <Sgeo> Why does it say "Non-exhaustive patterns in function +" and not "Non-exhaustive patterns in function (+)"?
18:47:12 <fantasma> > let (+) m b = (/) m b 4 in 10 + 2
18:47:14 <lambdabot>        add an instance declaration for (Fractional (t -> t1))
18:47:14 <lambdabot>     In the expr...
18:47:26 <sometwo> damn I'm popular ;)
18:47:48 <fantasma> > let (+) m b = div m b in 10 + 2
18:47:49 <lambdabot>  5
18:48:05 <fantasma> > let (+) m b = (\) m b in 10 + 2
18:48:05 <lambdabot>  Parse error
18:48:10 <fantasma> > let (+) m b = (/) m b in 10 + 2
18:48:11 <lambdabot>  5.0
18:48:21 <nmessenger> > let 2 + 2 = 5; x + y = x Prelude.+ y in liftM2 (+) [1,2,3] [1,2,3]
18:48:22 <lambdabot>  [2,3,4,3,5,5,4,5,6]
18:48:33 <mdmkolbe> let a = 1; b = 2; in let a = b; b = a in (a, b)
18:48:51 <fantasma> > let (+) m b = (/) m b in 100 + 2 + 2 + 2
18:48:52 <nmessenger> let a = b; b = a is mutually recursive
18:48:53 <lambdabot>  12.5
18:48:55 <Sgeo> > let (+) = (/) in 1 + 1
18:48:56 <lambdabot>  1.0
18:49:09 <mdmkolbe> > let a = 1; b = 2; in let a = b; b = a in (a, b)
18:49:09 <mdmkolbe> >let a = 1; b = 2 in (a, b)
18:49:11 <lambdabot>  Exception: <<loop>>
18:49:19 <fantasma> > let 1 = 2 in 1
18:49:21 <lambdabot>  1
18:49:29 <mdmkolbe> >let a = 1; b = 2 in (a, b)
18:49:50 <LoganCapaldo> > let past = future past in past future
18:49:51 <nmessenger> s/>l/> l/
18:49:53 <lambdabot>   Not in scope: `future'
18:50:15 <LoganCapaldo> > let a = b where b = a
18:50:15 <lambdabot>  Parse error
18:50:28 <fantasma> > let past future = future past in past future
18:50:30 <lambdabot>   Not in scope: `future'
18:50:49 <Sgeo> let (^) = (+) in 2^(2^65536)
18:50:54 <Sgeo> > let (^) = (+) in 2^(2^65536)
18:50:58 <lambdabot>  65540
18:51:08 <Sgeo> yay we finally found that large number :D
18:51:52 <fantasma> :t and
18:51:55 <lambdabot> [Bool] -> Bool
18:52:24 <nmessenger> > let r = realToFrac :: Int -> Rational in r 2 ^^ (2 ^^ 65536)
18:52:25 <lambdabot>  Add a type signature
18:55:08 <fantasma> @. elite run ['a'..'z']
18:55:10 <lambdabot> "a8(Def9|-|ijxL/\/\noPqr5+UV\/\/xYs"
18:55:24 <mdmkolbe> :t elite
18:55:26 <lambdabot> Not in scope: `elite'
18:55:31 <LoganCapaldo> @elite now I know my abcs
18:55:31 <lambdabot> N0\/\/ I xNow my a8C5
18:55:55 * LoganCapaldo imagines elite :: String -> String
18:56:06 <LoganCapaldo> but itsacommand not a function
18:56:18 <LoganCapaldo> @help elite
18:56:18 <lambdabot> elite <phrase>. Translate English to elitespeak
18:56:24 <nmessenger> @. elite proto
18:56:25 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "proto"
18:56:30 <mdmkolbe> @elite four score and seven years ago our forefathers came to this land
18:56:30 <lambdabot> FoUR $(0RE And S3vEn Years 4go 0Ur f0ReFaT|-|Erz caME 70 7HiS land
18:56:48 <nmessenger> @. elite protontorpedo
18:56:48 <lambdabot> \/\/I1 HazK3l1 MaKe Mro3 MoR3 /\/\0nEY?
18:57:27 <LoganCapaldo> @. . elite
18:57:27 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "Say"
18:57:31 <LoganCapaldo> oooo
18:58:05 <fantasma> @. quote run ['a'..'z']
18:58:06 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
18:58:09 <LoganCapaldo> @. . elite elite double up?
18:58:09 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "3lite"
18:58:16 <LoganCapaldo> @. elite elite double up?
18:58:16 <lambdabot> D0U8|3 up?
18:58:24 <mdmkolbe> @.
18:58:25 <lambdabot> Not enough arguments to @.
18:58:27 <mdmkolbe> @. .
18:58:27 <lambdabot> Not enough arguments to @.
18:58:30 <mdmkolbe> @. . .
18:58:30 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "Not"
18:58:34 <nmessenger>  @. . <cmd1> <cmd2> <cmd3>
18:58:34 <LoganCapaldo> @. . elite elite elite double up?
18:58:34 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "1337"
18:58:56 <fantasma> @users
18:58:56 <lambdabot> Maximum users seen in #haskell: 336, currently: 302 (89.9%), active: 41 (13.6%)
18:59:02 <fantasma> @name
18:59:03 <lambdabot> Local time for fantasma is Wed Mar 21 20:57:30
18:59:14 <procyon_> @. elite . vixen
18:59:14 <lambdabot> N07 EN0UGH AR9U/\/\eN7$ 7O @.
18:59:19 <nmessenger> :D
18:59:20 <LoganCapaldo> heh
18:59:26 <LoganCapaldo> is that a bug?
18:59:54 <fantasma> @. elite run fix . show
18:59:55 <lambdabot> (0uLdn'7 /\/\a+(H ExpEC7ed typE `4 -> a'
18:59:59 <procyon_> I'd say it's a feature
19:00:06 <fantasma> @. elite run fix show
19:00:07 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:00:33 <LoganCapaldo> it sort of implies error a == a though
19:00:34 <fantasma> @seen
19:00:47 <nmessenger> @. elite yhjulwwiefzojcbxybbruweejw
19:00:47 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
19:00:50 <LoganCapaldo> which I guess is true
19:00:55 <LoganCapaldo> now that I think about it
19:01:01 <fantasma> @. quote seen
19:01:02 <lambdabot> Saizan says: yesterday i was so drunk i was trying to typecheck the people at the party.. "what's your monad!?"
19:01:07 <fantasma> @. quote seen
19:01:08 <lambdabot> elpolilla says: <elpolilla> sali re putito :$
19:01:21 <fantasma> damn
19:01:29 <LoganCapaldo> @seen
19:01:33 <dons> ?users
19:01:33 <lambdabot> Maximum users seen in #haskell: 336, currently: 301 (89.6%), active: 41 (13.6%)
19:01:41 <fantasma> @list
19:01:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
19:01:47 <mdmkolbe> what is the name (or link) of the haskell contract DSEL?
19:01:50 <nmessenger>  @seen was disabled channel-wise for noisiness
19:02:08 <fantasma> ?todo
19:02:08 <lambdabot> 0. SamB: A way to get multiple results from a google search
19:02:09 <lambdabot> 1. dons: improve formatting of @dict
19:02:09 <lambdabot> 2. dons: write Haskell Manifesto
19:02:09 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
19:02:09 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
19:02:10 <lambdabot> [23 @more lines]
19:02:31 <nmessenger> @more
19:02:32 <lambdabot> 5. TheHunter: @type 1 :: Int
19:02:32 <lambdabot> 6. lispy: haddock gives a link from a type signature to the types.  It would be nice if it also let you find functions in the given module that use a type.
19:02:32 <lambdabot> 7. dons: Implement @whatis
19:02:32 <lambdabot> 8. dcoutts: implement @cool list, as a clone of the @todo(-add) commands
19:02:32 <lambdabot> 9. dons: there's some bug in the 'when i left' code of @seen
19:02:33 <lambdabot> [18 @more lines]
19:02:55 <nmessenger> dons: what is @whatis?
19:03:06 <LoganCapaldo> @whatis the matrix
19:03:07 <lambdabot> I know nothing about the.
19:03:10 <fantasma> @whatis the-meaning-of-life
19:03:10 <lambdabot> I know nothing about the-meaning-of-life.
19:03:16 <LoganCapaldo> @whatis fps
19:03:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:03:24 <LoganCapaldo> @where fps
19:03:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:03:28 <LoganCapaldo> hmm
19:03:33 * LoganCapaldo suspects aliasing
19:03:38 <nmessenger> methinks that gets spellchecked into @what
19:03:48 <LoganCapaldo> @what fps
19:03:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:03:57 <LoganCapaldo> @spellcheck whatis
19:03:57 <lambdabot> Unknown command, try @list
19:03:59 <nmessenger> @sepll slpelign!
19:03:59 <lambdabot> Maybe you meant: spell tell
19:04:01 <LoganCapaldo> @spell whatis
19:04:02 <lambdabot> whats what's Wheaties waits whits
19:04:05 <fantasma> ?topic-cons
19:04:05 <lambdabot> I do not know the channel
19:04:12 <LoganCapaldo> @whats fps
19:04:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:04:12 <fantasma> ?topic-cons #perl6
19:04:13 <lambdabot> Topic does not parse. Should be of the form ["...",...,"..."]
19:04:28 * dons thinks people should do some work...
19:07:01 <LoganCapaldo> I did work today
19:07:10 <LoganCapaldo> but not enough
19:11:11 <ClaudiusMaximus> @hoogle Monad ((->) b)
19:11:12 <lambdabot> hoogle: scripts/hoogle/src/Hoogle/MatchType.hs:74:8-45: Non-exhaustive patterns in function asBound
19:11:12 <lambdabot>  
19:11:27 <sjanssen> dons: I've been looking at xcb, and it looks like a perject job for the binary package!
19:11:52 * sjanssen is excited
19:12:11 <nmessenger> ClaudiusMaximus: Control.Monad.Reader
19:15:17 <ClaudiusMaximus> nmessenger: bingo :)
19:22:00 <fantasma> i would kill for a hi-res of tonight's Lost right now
19:22:25 <LoganCapaldo> Is Wadler guest starring?
19:22:37 <sjanssen> heh
19:23:39 <fantasma> hmmm that was the wrong channel
19:23:47 <LoganCapaldo> oh :(
19:23:58 <LoganCapaldo> Larry Wall is guest starring, isn't he?
19:25:17 <fantasma> Guest star:  Mira Furlan (Danielle Rousseau) ,  Brian Goodman (Ryan Pryce),  Cleo King (Goverment Worker),  Stephen Bishop (William Kincaid),  Marlene Forte (Detective Mason),  Don Nahaku (Detective Reed),  Barbara Baehler (Mrs. Talbot),  Patrick J. Adams (Peter Talbot),  Kevin Tighe (Anthony Cooper),  Tania Raymonde (Alex),  Nestor Carbonell (Richard Alpert),  M.C. Gainey (Tom)
19:25:23 <fantasma> guess not
19:26:22 <heatsink> Was Mira Furlan Delenn?
19:26:53 * Nafai is watching Lost right now
19:26:58 <sjanssen> how do you have guest stars on a deserted island?
19:27:21 <fantasma> lol
19:27:25 <heatsink> :)
19:27:33 <LoganCapaldo> heatsink: yes
19:27:48 <heatsink> ah!
19:28:27 <heatsink> sjanssen: I was wondering how lost they could really be if a goverment worker has found them.
19:28:59 <chessguy> hi haskellers
19:29:10 <heatsink> hi haskeller
19:29:25 <fantasma> heatsink, I just realized how cool your name is
19:29:45 <dmead> hihi
19:29:50 <heatsink> fantasma: only on one side.
19:29:55 <nmessenger> greetings earthling!
19:30:03 <fantasma> hahahaha
19:30:29 <chessguy> nmessenger!
19:32:56 <LoganCapaldo> Only on one side. Ha!
19:33:19 * nmessenger didn't get it for a few moments, either :)
19:33:32 <fantasma> someone please do @remember on that
19:33:36 * fantasma can't do it properly
19:33:49 <LoganCapaldo> hey now, I switched windows :)
19:33:54 * chessguy got it but didn't think it was that funny
19:35:03 <chessguy> ?remember heatsink [in response to fantasma's "Heatsink, I just realized how cool your name is"] fantasma: only on one side
19:35:03 <lambdabot> Done.
19:44:08 <LoganCapaldo> @ty callC
19:44:10 <lambdabot> Not in scope: `callC'
19:44:11 <LoganCapaldo> @ty callCC
19:44:13 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
19:44:49 <LoganCapaldo> @instances-importing MonadCont
19:44:50 <lambdabot> Cont r, ContT r m, ErrorT e m, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
19:45:01 <LoganCapaldo> Hmmm
19:46:17 <LoganCapaldo> ErrorT, RWST, etc. are they instances of MonadCont because they just so "happen" to be able to support continuations, and hey might as well make 'em MonadConts, or is there a deeper reason?
19:48:31 <sorear> lifting
19:48:36 <nmessenger> LoganCapaldo: the instances are actually instance MonadCont m => MonadCont (ReaderT r m), etc.
19:48:43 <LoganCapaldo> Oh.
19:48:46 <LoganCapaldo> heh
19:48:55 <nmessenger> LoganCapaldo: i.e. the inner monad transformed over is a MonadCont
19:49:10 <LoganCapaldo> I'm silly
19:49:16 <nmessenger> eventually there's a plain Cont r at the bottom
19:49:25 <LoganCapaldo> @src Cont
19:49:25 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
19:49:50 <LoganCapaldo> @src Cont >>=
19:49:50 <lambdabot> Source not found. Do you think like you type?
19:50:03 <sorear> @src Cont (>>=)
19:50:03 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
19:50:13 * sorear mutters at dons
19:50:28 <LoganCapaldo> I take it Cont's >>= and >> transform it into CPS?
19:50:33 <sorear> yeah
19:50:55 <LoganCapaldo> neato
19:52:18 <LoganCapaldo> > do { cont <- callCC; cont cont }
19:52:19 <lambdabot>      Occurs check: cannot construct the infinite type: m = (->) (m a)
19:52:19 <lambdabot>     Pro...
19:52:30 <LoganCapaldo> > do { cont <- callCC; fix cont }
19:52:31 <lambdabot>      Occurs check: cannot construct the infinite type:
19:52:31 <lambdabot>       a = ((a -> a -> ...
19:52:44 <LoganCapaldo> No infinite loops with callCC?
19:52:49 <LoganCapaldo> Or am I doing it wrong?
19:52:52 <nmessenger> @type callCC
19:52:54 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
19:53:57 <nmessenger> > runCont (callCC (\_ -> return 1)) id
19:53:58 <lambdabot>  1
19:54:09 <sorear> > do { cont <- callCC toDyn ; fromDyn cont undefined cont }  -- shut up the type checker
19:54:10 <lambdabot>  Couldn't match expected type `t1 t' against inferred type `Dynamic'
19:54:17 <sorear> beh.
19:54:20 * nmessenger has no idea what he's doing, he's just matching up types.
19:54:28 <sorear> > do { cont <- callCC (return . toDyn) ; fromDyn cont undefined cont }  -- shut up the type checker
19:54:28 <lambdabot>   add an instance declaration for (Show (m t))
19:54:49 <sorear> > flip runCont (\() -> ()) $ do { cont <- callCC (return . toDyn) ; fromDyn cont undefined cont }  -- shut up the type checker
19:54:50 <lambdabot>   add an instance declaration for (Typeable2 Cont)
19:55:00 <sorear> library maintainer!
19:55:04 <LoganCapaldo> Its not shutting up
19:55:12 <LoganCapaldo> just changing its tune :)
19:57:58 <nmessenger> @type flip runCont (\() -> ()) $ do { cont <- callCC (return . toDyn) ; fromDyn cont undefined cont }
19:58:00 <lambdabot>     No instance for (Typeable2 Cont)
19:58:00 <lambdabot>       arising from use of `toDyn' at <interactive>:1:57-61
19:59:28 <fantasma> anyone know if the AMD slot A k7 is a sixth generation x86 (i686)?
20:00:49 <heatsink> Are there ISA differences from 586?
20:00:55 <heatsink> pentium
20:01:08 <kc5tja> fantasma: I can check...
20:01:48 <fantasma> kc5tja, if you let me know where, I can check (I've tried googling but it's hard to find)
20:02:53 <kc5tja> fantasma: processor       : 0
20:02:53 <kc5tja> vendor_id       : AuthenticAMD
20:02:53 <kc5tja> cpu family      : 6
20:02:53 <kc5tja> model           : 2
20:02:53 <kc5tja> model name      : AMD Athlon(tm) Processor
20:02:55 <kc5tja> stepping        : 1
20:03:13 <kc5tja> It is indeed a 6th revision, from what I can see -- unless I'm interpreting the fields incorrectly.
20:03:29 <kc5tja> (and to think!  I thought I was the last of the slot A users!)
20:03:46 <kc5tja> I did cat /proc/cpuinfo to get the above information in Linux.
20:04:07 <dons> sjanssen: oh?
20:04:10 <dons> you mean the protocol?
20:04:53 <fantasma> kc5tja, I was so surprised to look inside two of my machines the other day....they were both slot A's
20:07:16 <sorear> dons: is this wrt the 64 bit issues?
20:07:47 <hpaste>  sjanssen pasted "xcb and binary" at http://hpaste.org/1081
20:07:54 <sorear> dons: if so: the haskell X11-bindings are borked with *extensive* Int/CInt confusion, ie Not Our Problem
20:08:04 <dons> i know.
20:08:31 <dons> sjanssen: ah ha
20:08:44 <sjanssen> sorear: not exactly.  We want to ditch -package X11 in favor of a new library based on XCB (which comes with spiffy XML specs)
20:09:11 <Sgeo> Would prolog be more suited to math stuff like derivatives than Haskell?
20:09:20 <sorear> Sgeo: a function is opaque
20:09:41 <sorear> Sgeo: the abstraction is one of the defining features of haskell functions
20:10:00 <sorear> Sgeo: this makes it possible to do arcane tricks, like compile them to machine code
20:10:03 <sjanssen> dons: xhsb uses a handrolled state/reader monad
20:10:14 <dons> urgh
20:10:28 <sorear> not xhb anymore?
20:10:32 <sjanssen> well, not exactly handrolled.  They're ReaderT and StateT
20:10:55 <sjanssen> sorear: xhsb is the very rough beginnings of a binding that somebody over at X.org started
20:11:21 <sorear> so x.org gave up?
20:11:29 <sorear> do they know we've taken over?
20:11:33 <sorear> should they?
20:12:04 <sjanssen> by very rough, I mean it supports only two functions
20:12:29 <sjanssen> sorear: nobody is actively working on it.  It's more of a proof of concept, I think
20:12:58 <sjanssen> if I actually start writing a replacement I'll post about it on their mailing list
20:15:41 <sjanssen> dons: the neat thing is that the XML spec describes both their C API and the actual bits-on-the-wire in the X protocol.  So you could start with their C connection layer early on, and graduate to a pure Haskell implementation later
20:17:52 <allbery_b> hah.  the CMU SCS folks are discussing how to do debug printing nicely in SML.  it looks remarkably primitive compared to Haskell
20:18:33 <sjanssen> the connection layer could even be a type class, so you can choose which to use at runtime
20:19:21 <dons> sjanssen: right.
20:19:23 <dons> very nice.
20:21:05 <sorear> wow, with the whole strict impure thing...
20:30:16 <Sgeo> @djinn a -> ()
20:30:16 <lambdabot> f a = void (arrId a)
20:30:25 <sjanssen> dons: X.org has "Finishing the Haskell language binding would be really cool." (referring to xhsb) in their list of SoC project ideas
20:30:33 <Sgeo> @src void
20:30:33 <lambdabot> Source not found. Do you think like you type?
20:30:40 <Sgeo> @src arrId
20:30:40 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:30:55 <dons> sjanssen: hmm!
20:31:31 <sjanssen> dons: looks like a 2 submissions for 1 proposal coupon to me :)
20:32:02 <bd_> ?t void
20:32:02 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
20:32:05 <bd_> :t void
20:32:07 <lambdabot> Not in scope: `void'
20:32:10 <bd_> Hmm!
20:32:17 <bd_> :t arrId
20:32:19 <lambdabot> Not in scope: `arrId'
20:32:22 <bd_> Hmmm!
20:32:24 <ddarius> void and I guess arrId is djinn speak.
20:33:53 <Sgeo> @hoogle void
20:33:54 <lambdabot> Foreign.Marshal.Error.void :: IO a -> IO ()
20:33:54 <lambdabot> System.Win32.Types.LPVOID :: type LPVOID
20:33:54 <lambdabot> System.Win32.Types.MbLPVOID :: type MbLPVOID
20:34:06 <Sgeo> @hoogle arrId
20:34:06 <lambdabot> No matches found
20:34:17 <sorear> ddarius: void is djinn speak, arrId is Pseudonym speak
20:34:37 <Sgeo> sorear, hm?
20:34:49 <sorear> 18:37:34 <Pseudonym> ?djinn-add arrId :: a -> Arr a a
20:35:11 <ddarius> Why the heck was it put there?
20:35:14 <sorear> void is a djinn primitive which (here) has type Arr a b -> c
20:35:37 <sorear> ddarius: Pseudonym was trying to test arrow laws or something
20:35:47 <Sgeo> Why TF was it doing that for a simple a->() ?
20:35:57 <ddarius> No, why did djinn add it to that request?
20:36:02 <bd_> ?djinn-list
20:36:02 <lambdabot> Unknown command, try @list
20:36:05 <bd_> ?help djinn
20:36:05 <lambdabot> djinn <type>.
20:36:05 <lambdabot> Generates Haskell code from a type.
20:36:05 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
20:36:09 <bd_> hmph.
20:36:10 <sorear> ddarius: because it was added
20:36:11 <bd_> ?list
20:36:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:36:14 <sorear> @djinn-clr
20:36:14 <lambdabot> Plugin `djinn' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:36:19 <sorear> @djinn-del arrId
20:36:26 <sorear> @djinn a -> ()
20:36:26 <lambdabot> f _ = ()
20:36:35 <Sgeo> hooray!
20:36:37 <bd_> hmmm
20:36:41 <bd_> ?djinn-add arrId :: a -> Arr a a
20:36:42 <bd_> 23:33 < ddarius> Why the heck was it put there?
20:36:43 <bd_> err
20:36:46 <bd_> ?djinn a -> ()
20:36:46 <lambdabot> f a = void (arrId a)
20:36:50 <bd_> interesting indeed
20:36:53 <bd_> ?djinn-del arrId
20:37:04 <sorear> ?djinn-del doesNotExist
20:37:12 <sorear> ?djinn-del Arr
20:37:14 <sorear> jic
20:37:43 <kc5tja> Is the name "djinn" given after the Islamic "djin" (aka "genie" in the anglecised form)?
20:37:57 <sorear> kc5tja: @ask augustss
20:38:42 <kc5tja> Ooops -- I typed that in, and now augustss has a blank question waiting for him.  :)
20:39:06 * kc5tja thought it was like @quote where it'd respond with something.  :)  
20:39:58 <ddarius> @djinn Functor f => ((b -> a) -> f a) -> f b
20:39:58 <lambdabot> Cannot parse command
20:40:03 <allbery_b> djinn is also a common anglicization, especially in Islamic references
20:40:06 <ddarius> @djinn ((b -> a) -> f a) -> f b
20:40:06 <lambdabot> -- f cannot be realized.
20:40:16 <kc5tja> There is no way to tell X11 to reload its settings without physically quitting and restarting X, is there?
20:40:25 <sorear> kc5tja: define settings
20:40:34 <ddarius> @djinn (a -> b) -> (f a -> f b) -> ((b -> a) -> f a) -> f b
20:40:35 <lambdabot> -- f cannot be realized.
20:40:35 <kc5tja> Turning off Emulate3ButtonMouse
20:40:48 <sorear> kc5tja: x11 makes assumptions that hotpluging vidcards and the like is impossible
20:40:53 <allbery_b> that requires exiting and restarting, I think
20:40:56 <sorear> oh, that would be static
20:40:59 <Sgeo> > True || otherwise -- True or otherwise, the hypothesis has an effect on the world >.>
20:41:00 <lambdabot>  True
20:41:17 * Sgeo is reading the Prelude, incidentally
20:41:26 <kc5tja> sorear: *sigh* X11 just plain needs to go away.  It's decrepit now.  :/
20:41:32 <ddarius> kc5tja: I believe it says something if it records a message.
20:41:46 <kc5tja> ddarius: I don't know what your response is in reference to?
20:42:01 <ddarius> kc5tja: @ask augustss
20:42:07 <kc5tja> ddarius: It said, "Consider it noted."
20:42:09 <kc5tja> :)
20:42:31 <kc5tja> @ask kc5tja
20:42:32 <lambdabot> You can tell yourself!
20:42:40 <kc5tja> Hehe
20:42:44 <ddarius> In a private message then?
20:42:47 <sorear> kc5tja: X11-the-protocol is still pretty nice.
20:42:50 <kc5tja> ddarius: Yeah, I did it via /msg.
20:42:58 <ddarius> Ah, that could be convenient.
20:43:05 <ddarius> @tell ddarius Do the dishes!
20:43:06 <lambdabot> You can tell yourself!
20:43:07 <kc5tja> sorear: It could be less verbose, but overall I'd agree.
20:43:24 <Sgeo> @djinn b -> (a -> b) -> Maybe a -> b
20:43:25 <lambdabot> f a b c =
20:43:25 <lambdabot>     case c of
20:43:25 <lambdabot>     Nothing -> a
20:43:25 <lambdabot>     Just d -> b d
20:43:28 <sorear> kc5tja: however, to the best of my knowledge it has only been implemented once, and the X11 Example Implementation is definitely showing its age.
20:43:35 <kc5tja> ddarius: I meant, I typed "/msg lambdabot @ask augustss" and it just responded with Consider it Noted.  Oops.  :)
20:43:47 <Sgeo> @djinn b -> (a -> b) -> a -> b
20:43:48 <lambdabot> f _ a b = a b
20:43:53 <ddarius> I understood.  That's what I was asking.
20:44:13 <ddarius> @djinn (a -> b) -> (Maybe a -> Maybe b) -> ((b -> a) -> Maybe a) -> Maybe b
20:44:14 <lambdabot> f _ a _ = a Nothing
20:44:37 <Sgeo> @hoogle (a -> b) -> (Maybe a -> Maybe b) -> ((b -> a) -> Maybe a) -> Maybe b
20:44:37 <lambdabot> No matches, try a more general search
20:44:48 <Sgeo> ddarius, is that the type for something?
20:44:53 <kc5tja> sorear: I think the X11 protocol is pretty dated too; I understand that it's really, really verbose.  I seem to recall some initiative in the past where the X11 protocol was going to be rev'ed by using the X11 Extensions protocol as the "master" protocol, and "normal" X11 stuff is just a normal "extension" (kind of like wrapping stuff in HTTP, but not quite)
20:44:53 <ddarius> Is there like a @djinn-more?
20:45:24 <nmessenger> @list djinn
20:45:24 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
20:45:32 <sorear> kc5tja: how can x11 be verbose
20:45:44 <ddarius> Sgeo: One side of the isomorphism that is the Yoneda lemma (specialized to the functor Maybe, "Functor f =>" being handled by explicitly passing "fmap" though I screwed up)
20:45:51 <sorear> kc5tja: it's a variable length binary protocol, with single byte tags...
20:45:55 <ddarius> @djinn ((a -> b) -> (Maybe a -> Maybe b)) -> ((b -> a) -> Maybe a) -> Maybe b
20:45:56 <lambdabot> f _ _ = Nothing
20:45:56 <kc5tja> sorear: Duplicate data?  I don't know.  I personally have never looked at the protocol -- I'm only going on what other X11 hackers have said to me.
20:46:26 <Sgeo> @djinn a -> Maybe a
20:46:26 <lambdabot> f = Just
20:46:30 <sorear> kc5tja: it does make allowances for things that never happen now, and tries to handle too much itself
20:46:31 <Sgeo> @djinn a -> Maybe b
20:46:31 <lambdabot> f _ = Nothing
20:46:43 <sorear> kc5tja: x11 auth shouldn't exist, we should have only ssh
20:46:46 <sorear> for ex.
20:46:55 <allbery_b> x11 is pretty chatty, yes.  even with caching.  take a look at lbx as a way to shrink the protocol.  (or the old sxpc)
20:47:01 <kc5tja> Well, in X11's defense, X existed long before SSH did.  :)
20:47:07 <ddarius> @djinn ((a -> b) -> (Maybe a -> Maybe b)) -> ((b -> a) -> Maybe a) -> Maybe b
20:47:07 <lambdabot> f _ _ = Nothing
20:47:09 <ddarius> @djinn ((a -> b) -> (Maybe a -> Maybe b)) -> ((b -> a) -> Maybe a) -> Maybe b
20:47:10 <lambdabot> f _ _ = Nothing
20:47:10 <sorear> allbery_b: lbx is dead
20:47:14 <sorear> allbery_b: officially
20:47:23 <ddarius> Oh, I wasn't paying attention.
20:47:24 <allbery_b> it doesn't help that fonts used to live on the server side, so the client had to download them to figure out font metrics
20:47:28 <sorear> allbery_b: ssh with gzip takes less cpu and less bandwidth
20:47:29 <allbery_b> sorear: *sigh*
20:47:48 <sorear> @google lbx postmortem
20:47:53 <lambdabot> http://keithp.com/~keithp/talks/lbxpost/paper.html
20:47:53 <lambdabot> Title: An LBX Postmortem
20:47:54 <allbery_b> (modern applications tend to use free type fonts, which live on the client)
20:48:26 <sorear> Xrender is nice - they completely redesigned the graphics part
20:48:32 <allbery_b> well, actually, I suppose that doesn';t surprise me much.  lbx reprtedly didn't do a whole lot
20:48:38 <kc5tja> Strange; why can't the X server just ask the client for the metrics?  I'd assume that capability should exist inside of xlib or some such.
20:48:38 <sorear> eg. they use TRIANGLES now
20:48:55 <allbery_b> it cut down the traffic that could be better handled with compression, and didn't do the harder stuff
20:49:01 * kc5tja really likes the structured graphics idea behind Berlin.
20:50:13 <TSC> Does anyone know what might cause this?  "Bad interface file: /home/chris/local/lib/Symdet-0.0/ghc-6.6/Symdet/Expression.hi ; mismatched interface file ways: expected , found p"
20:51:06 <kc5tja> TSC: It looks like the .hi file was compiled by an older version of a compiler, and/or was from an older version of the source file?
20:51:18 <sorear> that would explain it if there were numbers :)
20:51:31 <sorear> '' and 'p' aren't, afaik
20:51:58 <TSC> I tried recompiling and installing the library; no difference
20:52:14 <sorear> doh, idiot me
20:52:21 <sorear> ways, not versions
20:52:38 <TSC> What is "ways"?
20:52:43 <sorear> that says the library was compiled for profiling, and your code isn't
20:52:52 <TSC> Ohh
20:53:01 <sorear> you're supposed to use a .p_o for profiling objs, and .o for non-prof
20:53:09 <sorear> cabal does that automatically
20:53:15 <sorear> .p_hi vs .hi too
20:53:29 <Sgeo> @djinn (b -> c) -> (a -> b) -> a -> c
20:53:29 <lambdabot> f a b c = a (b c)
20:53:33 <sorear> you can't mix+match profiling and non-profiling code
20:53:45 <TSC> Yes, of course
20:53:46 <sorear> technically, ways are more than just prof/non-prof
20:53:47 <TSC> Thanks sorear
20:54:02 <sorear> there's also tickyticky, debug, maybe more
20:54:03 <sorear> yw
20:55:17 <TSC> But since the library was compiled with profiling, why are all the interface files called .hi ?
20:55:41 <Sgeo> @djinn [[a]] -> [a]
20:55:41 <lambdabot> -- f cannot be realized.
20:55:48 <Sgeo> @src [[a]] -> [a]
20:55:48 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:56:16 <sorear> how did you compile the library for profiling?
20:56:21 <Pseudonym> At least lambdabot is dropping the attitide.
20:56:29 <sorear> Sgeo: djinn doesn't handle recursive types
20:56:37 <sorear> Sgeo: @src only takes names of functions
20:56:38 <TSC> With "Ghc-options:    -O2 -prof -auto-all" in the library cabal file
20:56:42 <sorear> Sgeo: you want hoogle
20:56:48 <sorear> TSC: ah, that explains it
20:56:58 <Sgeo> @src concat
20:56:58 <lambdabot> concat = foldr (++) []
20:56:59 <sorear> TSC: cabal doesn't parse ghc options
20:57:03 <TSC> That is not the way to tell cabal, is it?
20:57:20 <sorear> TSC: you tell cabal by passing the -p option to conflictor
20:57:24 <sorear> *configure
20:57:59 <TSC> And that will do -prof -auto-all to the library + executables?
20:58:19 <sorear> TSC: -prof -auto to all
20:58:29 <TSC> Great, thanks very much
20:58:34 <sorear> yw
20:58:48 <Sgeo> @type fromJust . lookup
20:58:51 <lambdabot>     Couldn't match expected type `Maybe a'
20:58:51 <lambdabot>            against inferred type `[(a1, b)] -> Maybe b'
20:59:12 <sorear> @type (fromJust .) . lookup
20:59:14 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> b
20:59:34 <sorear> (a .) . b if b takes 2 args
20:59:35 <Sgeo> sorear, why does it need to be written like that?
20:59:46 <sorear> Sgeo: because of currying
21:02:03 <Sgeo> When making a type an instance of a class, do all the functions required by the class need to be in the same instance statement?
21:02:28 <sorear> yes and no
21:02:41 <sorear> you may only have one instance statement
21:02:49 <sorear> but you don't need to provide all the functions
21:03:06 <sorear> the rest default to the class default method, or undefined
21:03:27 <Sgeo> I can't provide more of the functions later?
21:03:38 <sorear> no
21:06:04 <Sgeo> What is fixIO?
21:06:33 <sorear> finds fixpoints in the io monad
21:06:49 <mauke> @src fixIO
21:06:49 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:07:36 <sorear> try fixIO (\expr -> do ch <- getChar ; return (ch : expr))
21:08:37 <kc5tja> Pseudonym: You were saying something about its attitude?  :)
21:08:42 <Pseudonym> :-)
21:10:09 <glguy> sorear: that code is equivalent to (return (repeat c)) where c is the character you pressed
21:10:22 <glguy> because mfix only runs the action once, right?
21:11:11 <sorear> right.
21:13:06 <sorear> fixIO k = do   -- source code, may be instructive
21:13:06 <sorear>     ref <- newIORef (throw NonTermination)
21:13:06 <sorear>     ans <- unsafeInterleaveIO (readIORef ref)
21:13:06 <sorear>     result <- k ans
21:13:09 <sorear>     writeIORef ref result
21:13:15 <sorear>     return result
21:13:48 <mauke> hax
21:13:54 <sorear> ?
21:14:35 <brad__> hi, i have a question about a function from missingh. if i use 'rstrip' which strips whitespace from the right side (end) of a string, will this negate laziness of getContents etc (since it seems to mandate that the entire string be read in (??))
21:15:01 <sorear> yes, *if* you look at the whole stripped output
21:15:11 <brad__> ah
21:15:20 <brad__> sort of a schrodinger's cat
21:15:24 <sorear> if the input is "abce"...  we can say the output is "abce"...
21:15:45 <sorear> but if you look further than the e, rstrip has to look further than the input e
21:15:47 <sorear> otoh
21:16:06 <sorear> if the input is "abcde    "...  all we can say about the output is "abcde"
21:16:25 <sorear> since if the ... is actuallly the end, rstrip neeeds to delete the spaces
21:16:26 <brad__> does rstrip defer its execution then until it sees EOF, then moves backward?
21:16:38 <sorear> it won't know to keep the spaces until it sees a non-space
21:16:49 <sorear> I'm guessing it's implemented like tail
21:16:54 <sorear> er, init
21:16:57 <sorear> @src init
21:16:57 <lambdabot> init [x]    = []
21:16:57 <lambdabot> init (x:xs) = x : init xs
21:16:57 <lambdabot> init []     = undefined
21:17:16 <sorear> so it can emit a character as soon as it sees enough input
21:18:33 <brad__> there's a lot of complexity to laziness!
21:18:59 <brad__> a non-lazy language would just indeed read in all the input and then rstrip it
21:19:45 <brad__> i had been under the impression that i should not use rstrip, only lstrip on input i am reading, but it seems laziness is still lazy even if i use rstrip
21:20:59 <brad__> by the way i am working on a toy DOM, as far as i know there is no implementation of w3 DOM in haskell...
21:21:53 <sorear> does HaXML/HXML/HXT count? (dommy interfaces)
21:22:10 <bos> i don't think people want a DOM, to be honest.
21:22:42 <brad__> bos - why not? i agree it is not perfect, but it has the purpose of being a cross-language api
21:23:00 <brad__> i took a look at hxt...just too hard to use
21:23:10 <bos> yes, hxt is crazy moon language.
21:23:29 <brad__> then again, it looks like they wanted to play with Arrows, so thats cool
21:23:47 <bos> it's beautiful in its own way, but very hard to understand.
21:24:16 <brad__> thats one plus of the DOM api, most people already know it from orevious tools
21:24:21 <brad__> even if it is a flawed api
21:24:37 <brad__> maybe i should look again at HaXML
21:24:44 <brad__> never heard of HXML
21:25:45 <brad__> ah i see it here: http://www.flightlab.com/~joe/hxml/
21:26:13 <brad__> not sure how to tell lambdabot that HXML points there, if people wish to preserve that information
21:26:28 <bos> @where+ hxml http://www.flightlab.com/~joe/hxml/
21:26:28 <lambdabot> Done.
21:26:51 <brad__> thanks box
21:26:54 <brad__> sorry bos
21:26:59 <bos> :)
21:27:10 <sorear> brad__: don't feel bad
21:27:24 <sorear> brad__: we've had someone call dmwit dimwit before
21:27:44 <brad__> ouch!
21:27:58 <brad__> well you are kind of asking for it if you call yourself dmwit
21:28:00 <dmwit> It's on purpose. ;-)
21:28:25 <brad__> TOUCHE
21:28:33 <sorear> @all-dicts touche
21:28:34 <lambdabot> No match for "touche".
21:28:45 <dmwit> French for touch?
21:28:57 <brad__> touche, as in "ya got me" (pronounced "two-shay")
21:28:59 <dmwit> (As in fencing, I think.)
21:29:20 <marnes> hi, I am new to HGL... I am not able to compile the hello world in http://start.it.uts.edu.au/w/doc/solaris/haskell/graphics.html
21:29:21 <lambdabot> Title: Faculty of IT / doc / solaris / haskell / graphics
21:29:24 <marnes> can someone help me?
21:29:26 <brad__> i did not even know dmwit was here when i commented on someone miscalling his id
21:29:27 <pjd_> @all-dicts touchÃ©
21:29:28 <lambdabot> No match for "touchÃ©".
21:29:52 <brad__> i think it is touche with a accent above the e
21:29:59 <brad__> not sure how to type that@
21:30:16 <dmwit> brad__: Easy, get a French keyboard.
21:30:19 <sorear> found it in my PAPER DICTIONARY
21:30:20 <mauke> <compose> ' e
21:31:03 <sorear> touche': interj. Used to acknowledge a hit in fencing or a sucessful criticism in an argument.
21:31:17 <sorear> [Fr. < p.part of toucher. TOUCH.]
21:31:24 <brad__> i'll have to mark the date, i knew something people in #haskell didn't, a singular event in history
21:31:57 <sorear> I like paper dictionaries for some reason...
21:32:26 <fantasma> the side of my computer case is over 150 degrees fahrenheit :(
21:32:34 <brad__> trivia: word with longest definition: set
21:32:37 <sorear> M-: (insert-char 130 1)  ; another way
21:32:44 <sorear> Â
21:32:57 <brad__> at least in my concise oxford
21:33:29 <dmwit> A bag is a set with multiplicities?
21:33:37 <sorear> fantasma: the computes at my dad's company get a *lot* hotter than that.  Melting is *such* an original way to destroy data.
21:33:41 <sorear> dmwit: right.
21:33:49 <marnes> a bag is a multiset
21:33:55 <marnes> yes, a set with multiplicity
21:34:01 <fantasma> sorear, so I should not worry and let my kernel finish compiling over night?
21:34:29 <sorear> fantasma: you have a cpu temp meter?
21:34:34 <dmwit> > (150 - 32)*5%9
21:34:36 <lambdabot>  590%9
21:34:49 <dmwit> > 594%9
21:34:50 <fantasma> sorear, yah, the reading is usually in the bios though
21:34:51 <lambdabot>  66%1
21:34:59 <brad__> most systems have a shutoff when the temp gets too high
21:35:00 <dmwit> That's not bad.
21:35:10 <brad__> although you get no warning, it just shuts off
21:35:11 <fantasma> brad__, I turned mine off though
21:35:20 <dmwit> Before I fixed my fan, my CPU was pegged around 73C idle...
21:35:30 <fantasma> that's cpu
21:35:36 <dmwit> true
21:35:39 <fantasma> but the outside of my case is 66
21:35:55 <sorear> fantasma: http://hpaste.org/318
21:36:10 <dmwit> On an unrelated note, everybody should switch to Kelvins.
21:36:13 <sorear> fantasma: you might be able to adapt that for your purposes
21:36:41 <brad__> fantasma - are you in single-user mode when you compile?
21:36:44 <sorear> dmwit: Rankine forever!
21:36:47 <Pseudonym> On the contrary, everybody should switch to Planck temperature.
21:36:54 <fantasma> brad__, no I am not
21:37:09 <sorear> brad__: why do such a thing?
21:37:16 <brad__> if not, you may be able to use 'nice' to starve the compile a bit, which may cool things a bit too
21:37:17 <dmwit> sorear: =((
21:37:17 * sorear ALWAYS runs ghc with a nonzero uid
21:37:34 <brad__> what OS?
21:37:37 <Pseudonym> 1 Planck temperature = 1.41679e32 Kelvin
21:37:40 <Pseudonym> Much saner.
21:37:59 <fantasma> debian
21:38:02 <sorear> fantasma: does my script look adaptable?
21:38:11 <dmwit> Haha, "My computer is running at 2.5e-31 Planck".
21:38:32 <brad__> so i take it you do not want to use debian prebuilt kernels?
21:38:42 <fantasma> brad__, nope, haha
21:38:44 <fantasma> sorear, it does
21:39:08 <kscaldef>   nice will only do anything if there's other stuff that wants to use the cpu
21:39:17 <fantasma> but I need a really quick short term solution, I take it that taking off the side of the case will not help
21:39:46 <brad__> yes kscaldef (are you the yhoo scaldef?), that is why i asked if he was in single-user mode
21:39:57 <kscaldef> it's pretty unlikely for nice to reduce the total CPU utilization of a machine
21:40:11 <kscaldef> brad__: yes, that's me
21:40:16 <brad__> i am the yahoo brad
21:40:41 <kscaldef> the world is way too small :-)
21:40:52 * sorear isn't yahoo anyone
21:41:08 * Pseudonym is the yahoo serious
21:41:12 <brad__> yes the world is small indeed
21:41:15 <sorear> I'm pretty sure noone here knows me
21:41:47 <sorear> (in rl at least)
21:42:04 <fantasma> I will let my kernel compile and if my house burns down, I'll report back in the morning
21:42:07 <brad__> well sorear normally i would use a different handle too, i've already screwed up my karma at work enough
21:42:09 * fantasma goodnight
21:42:13 <sorear> I was a minor contributer to the same minor wiki as Eidolos
21:42:33 <sorear> handles? what are those? :)j
21:42:55 * sorear really is S. O'Rear, and never even considered a pseudonym
21:42:56 <brad__> i am so irc illiterate that i don't even know how to create one
21:44:18 <sorear> brad__: normally if you try to say "/nick bclawsie" or similar it will work
21:44:32 <dmwit> Huh, there are actually quite a lot of temperature scales.
21:44:42 <Agaguk> hi, I am new to HGL and I am not able to compile a simple hello world (linux, ubuntu 6.10, ghc)... can someone help me?
21:44:47 <brad__> hey sorear you know my last name!
21:44:48 <sorear> dmwit: I take it you're not a fan of rankine?
21:44:58 <sorear> brad__: say "/whois <nick>"
21:44:58 <brad__> was it announced or something when i joined the channel?
21:45:12 <kscaldef> it's in your user info
21:45:20 <brad__> ah
21:45:21 <dmwit> The size of a degree Fahrenheit scares me.
21:45:50 <brad__> well fortunately i haven't threatened anyone
21:45:52 * kscaldef thinks about how big a degree fahrenheit is...
21:46:00 <brad__> only dropped the aggregate iq
21:47:01 <kscaldef> well, an inverse degree fahrenheit is pretty frighteningly large, now that you mention it
21:47:19 <brad__> well i have degraded things enough for one night, thanks for discussing laziness, rstrip, hxt and the rest of it
21:47:37 <sorear> yw
21:48:09 * ddarius has finally caught up with haskell-cafe.  It only took half again as long as I was away.
21:48:58 * sorear spends fifteen minutes in the morning catching up after 8h of sleep and fifteen minutes in the afternoon catching up after 8h of schooling
21:49:24 <ddarius> sorear: I was away for a week.
21:49:49 <dmwit> I take it you weren't reading for the entire 3.5 days... ;-)
21:49:49 * sorear shudders
21:50:02 <sorear> dmwit: half again as long means 11.5 days
21:50:13 <sorear> 10.5
21:50:34 <dmwit> Yes, good.
21:51:58 <dmwit> ?yow
21:51:58 <lambdabot> PUNK ROCK!!  DISCO DUCK!!  BIRTH CONTROL!!
22:25:51 <morner> hurrah
22:25:57 <morner> my su doku solver works
22:30:12 <procyon> ?src fmap
22:30:12 <lambdabot> Source not found. Are you on drugs?
22:31:01 <bd_> ?src [] fmap
22:31:01 <lambdabot> fmap = map
22:31:19 <bd_> it's a class function, so you need to specify which instance you mean
22:31:26 <procyon> ahh
22:31:27 <procyon> thx
22:43:29 <newsham> if only there was some language in which you could prototype, model, test properties, statically verify properties, prove theorems and develop your final implementation
22:43:33 <newsham> all in the same language
22:44:07 <ivanm> newsham: B or Z?
22:44:17 <newsham> z notation?
22:44:21 <ivanm> *nod*
22:44:30 <newsham> thats just a spec language
22:44:36 <ivanm> I think B at least can be transformed into C...
22:44:44 <ivanm> don't know about Z...
22:45:12 <newsham> haskell can do prototyping, testing (quickcheck) and almost static verification (esc, not publically available)
22:45:28 <newsham> but you have to transform to something like isabelle to do theorem proving
22:45:52 <newsham> which is close, but still not a direct translation
22:45:55 * ivanm isn't familiar with isabelle
22:46:17 <newsham> proof assistant written in ML using an ML-like syntax.
22:46:57 <ivanm> ahhh
22:47:18 <newsham> sel4/l4.verified used it (one of those, forget which)
22:47:49 <newsham> http://www.ertos.nicta.com.au/publications/papers/Derrin_EKCC_06.pdf
22:47:51 <lambdabot> http://tinyurl.com/2dsd66
22:48:07 <ivanm> isn't there a haskell theorem prover? or is that something else?
22:49:27 <newsham> http://www.haskell.org/haskellwiki/Libraries_and_tools/Theorem_provers
22:49:29 <lambdabot> Title: Libraries and tools/Theorem provers - HaskellWiki, http://tinyurl.com/2bagtw
22:49:37 <abz> how to do I this with cabal and ghc -DLOCALHOST ?
22:50:13 <abz> mainly cabal and the c preprocessor ?
22:51:24 <newsham> ghc-options: -DLOCALHOST   ?
22:51:38 <newsham> Extensions: CPP ?
22:52:10 <abz> thanks.
22:52:49 <jdrake> I finally upgraded to 6.6, decided to compile it myself :p
22:56:31 <procyon> anyone know why ghc is hard-masked in gentoo portage?
22:56:47 <procyon> ghc 6.6 that is.
22:57:14 <desp> :t newForeignPtr
22:57:15 <abz> problem with slots I think (have 6.4 and 6.6)
22:57:16 <lambdabot> Not in scope: `newForeignPtr'
22:57:26 <desp> :t Foreign.ForeignPtr.newForeignPtr
22:57:29 <lambdabot> forall a. GHC.ForeignPtr.FinalizerPtr a -> GHC.Ptr.Ptr a -> IO (GHC.ForeignPtr.ForeignPtr a)
22:57:42 <abz> procyon: you should ask on IRC gentoo-haskell channel
22:57:50 <procyon> ok
22:57:53 <desp> hrm
23:09:38 <sciolizer> Is anybody here familiar with the Q language? (I promise this is a Haskell question.)
23:10:37 <sciolizer> Anyway, my question is this: are there any design patterns for doing general term rewriting in Haskell? (Kind of like how the Visitor pattern allows one to do functional programming in Java.)
23:12:36 <bd_> sciolizer: http://www.cs.vu.nl/boilerplate/ this might be interest to you
23:13:14 <ClaudiusMaximus> > let f 'a' = "abb" ; f 'b' = "bab" in iterate (map f) "a"  -- is this what you mean by term rewriting?
23:13:15 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
23:13:16 <revence> IO.getHashHaskell >>= mapM sayHiTo  -- And then a question rolls ...
23:13:19 <sciolizer> bd_: thanks.
23:13:40 <revence> Now, what is the difference between `currying' and `eta reduction'?
23:14:06 <desp> bd_: does that server work for you?
23:14:14 <Heffalump> revence: not a huge amount at one level
23:14:14 <sciolizer> bd_: It's very slow.
23:14:19 <bd_> hmm
23:14:23 <bd_> site seems to have gone down
23:14:25 <bd_> how inconvenient
23:14:44 <Heffalump> revence: in practical terms currying just refers to partially applying functions, and eta reduction refers to the transformation \x -> f x ===> f
23:14:45 <revence> So, can I use `currying' inter-changeably with `eta reduction'?
23:14:48 <Heffalump> (where x not free in f)
23:14:50 <sciolizer> bd_: Is that the SYB papers? I am familiar with them, but not enough to know how general term rewriting is connected to them.
23:14:50 <Heffalump> no
23:14:52 <bd_> hmm... is archive.org down too?
23:14:57 <bd_> sciolizer: yeah
23:15:13 <Heffalump> sciolizer: I don't really think it is
23:15:35 <bd_> well, they basically let you take some nested data structure, and apply any function (Data a => a -> a) to it, where it automatically recurses and applies the function wherever the types work out
23:15:46 <Heffalump> they give you a way of traversing a typed tree but not a way of matching an arbitrary dynamically specified pattern
23:15:47 <revence> Okay, so currying is the utilisation of eta-reduction, oui?
23:15:59 <Heffalump> revence: kind of, that's why I said they are the same at one level
23:16:29 <revence> Heffalump: Thanks a bunch.
23:18:02 <sciolizer> bd_, Heffalump: perhaps if I embed function application in a custom data structure, I might be able to do my own leftmost, innermost pattern matching? (Just brainstorming outloud.)
23:18:19 <bd_> sciolizer: what kind of pattern matching do you mean?
23:18:20 * Heffalump has to go, sorry
23:18:28 <sciolizer> Heffalump: bye
23:19:28 <sciolizer> bd_: http://q-lang.sourceforge.net/qdoc/qdoc_2.html#SEC6
23:19:29 <lambdabot> Title: The Q Programming Language: 2. Getting Started
23:19:31 <sciolizer> bd_: scroll to the insert function
23:20:07 <sciolizer> bd_: pattern matching on any function application, not just on Constructors like it is in Haskell
23:20:19 <bd_> ahh
23:20:32 <bd_> Can that work in general, though?
23:20:38 <bd_> What if your function is a hash function, for example?
23:21:32 <sciolizer> bd_: I don't really know. I just read about the Q language today, and immediately started wondering if general term rewriting can be done in some form in Haskell.
23:22:06 <bd_> There are rewrite rules, but those are intended not to change the semantics of the expression (they're strictly an optimization)
23:22:22 <bd_> I guess I don't see how they can be made to work in general, as they'd require all functions to be reversible
23:23:07 <sciolizer> bd_: right. Well, the functions that I would want to pattern match would probably have to be encapsulated somehow. I'm not necessarily expecting to do pattern matching against ANY function handed to me from ANYWHERE.
23:23:25 <bd_> Well.. if they're limited, isn't that just a data constructor now?
23:23:57 <sciolizer> bd_: Right. Maybe I should have asked my question like this: Is there a well-understood way to reify function application into data structures?
23:24:47 <bd_> I don't think there's anything built in at the haskell level, no. Function application of the form (a -> b) is an opaque datatype.
23:25:00 <bd_> You could build a pair (a -> b, a)
23:25:15 <bd_> if you wanted to inspect it
23:25:23 <bd_> but, of course, you can't test equality between functions
23:25:26 <desp> Tackling The Awkward Squad is a great read.
23:25:47 <bd_> anyway, I must sleep now
23:25:48 <sciolizer> bd_: unless you are working with something like ((a -> b, String), a)
23:25:58 <sciolizer> bd_: ok. Thanks for your help.
23:26:09 <bd_> sciolizer: The string might not truthfully describe a->b in that case :)
23:26:11 <bd_> anyway afk
23:27:38 <ClaudiusMaximus> > let rabbit 'a' = "b" ; rabbit 'b' = "ba" in map length (iterate (concat . (map rabbit)) "a") -- fibs, the slow and inefficient way...
23:27:41 <lambdabot> Terminated
23:27:58 <desp> quite
23:30:48 <dmwit> ?all-dict reify
23:30:50 <lambdabot> *** "reify" wn "WordNet (r) 2.0"
23:30:50 <lambdabot> reify
23:30:50 <lambdabot>      v : consider an abstract concept to be real
23:30:50 <lambdabot>      [also: {reified}]
23:30:50 <lambdabot>  
23:30:52 <lambdabot> [7 @more lines]
23:31:09 <dmwit> ?more
23:31:10 <lambdabot> *** "reify" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
23:31:10 <lambdabot> reify
23:31:10 <lambdabot>  
23:31:10 <lambdabot>         To regard (something abstract) as a material thing.
23:31:10 <lambdabot>  
23:31:12 <lambdabot>         (1995-03-07)
23:31:14 <lambdabot>  
23:32:22 <dmwit> > let rabbit 'a' = "b"; rabbit 'b' = "ba" in "a" >>= rabbit
23:32:23 <lambdabot>  "b"
23:32:41 <dmwit> > let rabbit 'a' = "b"; rabbit 'b' = "ba" in take 5 . map length . iterate (>>= rabbit) $ "a"
23:32:43 <lambdabot>  [1,1,2,3,5]
23:34:10 <dmwit> ?pl rabbit 'a' = "a"
23:34:10 <lambdabot> (line 1, column 12):
23:34:10 <lambdabot> unexpected "="
23:34:10 <lambdabot> expecting variable, "(", operator or end of input
23:34:32 <dmwit> ?pl \x -> case x of 'a' -> "a"
23:34:32 <lambdabot> (line 1, column 21):
23:34:32 <lambdabot> unexpected ">" or "-"
23:34:32 <lambdabot> expecting variable, "(", operator or end of input
23:35:13 <mauke> > let rabbit False = [True]; rabbit True = [True,False] in take 5 . iterate (>>= rabbit) $ [False]
23:35:15 <lambdabot>  [[False],[True],[True,False],[True,False,True],[True,False,True,True,False]]
23:36:52 <mauke> bla, confused again. what's the difference between ReaderT State and StateT Reader?
23:38:37 <Cheery> Has anybody ever thought about removing that tuple from State Monad?
23:38:55 <Cheery> Suddenly it looks like a common household tool...
23:39:20 <Cheery> return a = \s k -> k a s
23:40:09 <Cheery> bind m f = \s -> m s f
23:40:56 <Cheery> :P
23:41:19 <mauke> @pl f a s k = k a s
23:41:20 <lambdabot> f = flip . flip id
23:41:38 <ddarius> Using continuations to implement multiple return values.
23:42:12 <ddarius> BC(CI)
23:42:58 <Cheery> runStateK m s k = m s k
