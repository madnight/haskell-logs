00:01:52 <dmwit> In that backtracking tutorial, guard seems like magic to me.
00:02:45 <ivanm> dmwit: *nod*
00:02:45 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
00:03:30 <nmessenger> guard True = return (), return x = [x], guard False = [], -- since a False guard results in the empty list, the remaining maps do nothing.
00:03:52 <nmessenger> > map (+1) []
00:03:54 <lambdabot>  []
00:04:16 <dmwit> But why should x and y have different values in the return than in the line before the guard?
00:04:18 <ivanm> nmessenger: the magic bit, IMHO, is how it applies x*y...
00:04:55 <nmessenger> x and y are params to the lambdas on the rhs of (>>=)
00:05:00 <dmwit> It expands to "guard blah >> return (x, y) -- the second argument of (>>) ignores the return value of the first argument..."
00:05:32 <nmessenger> so in guard True = [()], the () is ignored
00:05:48 <nmessenger> in guard False = [], the map doesn't do anything
00:06:07 <nmessenger> > join (map (\_ -> return (2,4)) [])
00:06:08 <lambdabot>  []
00:06:13 <nmessenger> > join (map (\_ -> return (2,4)) [()])
00:06:15 <lambdabot>  [(2,4)]
00:07:27 <nmessenger> does that make any sense?
00:07:34 <dmwit> I'm almost there, but not quite.
00:07:44 <dmwit> Give me a few more seconds to come up with an intelligent question. ;-)
00:08:13 <dmwit> > [] >> return 3
00:08:14 <desp> @src unlines
00:08:15 <lambdabot> unlines = concatMap (++ "\n")
00:08:15 <lambdabot>  []
00:08:20 <dmwit> > [()] >> return 3
00:08:22 <lambdabot>  [3]
00:08:27 <dmwit> > [(), ()] >> return 3
00:08:29 <lambdabot>  [3,3]
00:08:35 <dmwit> Aha.
00:08:42 <dmwit> Okay, now I think I get it.
00:08:43 <nmessenger> > [1,2,3] >>= \x -> [3,4,5] >>= \y -> guard (x*y == 8) >>= \_ -> return (x,y)
00:08:45 <lambdabot>  [(2,4)]
00:08:50 <dmwit> That is _way_ cool.
00:09:03 <desp> is there a handy function that'd work like unlines, but without doing anything when the list contains only one string?
00:09:14 <nmessenger> it's *all* in the definition of join and map.  *THAT'S* what a monad is.
00:09:27 <quicksilver> :t unlines
00:09:29 <lambdabot> [String] -> String
00:09:38 <quicksilver> > unlines ["just one string"]
00:09:40 <lambdabot>  "just one string\n"
00:09:44 <desp> i.e. instead of appending terminating '\n' characters, separate the strings with '\n' characters
00:09:48 <ivanm> @type ignore
00:09:50 <lambdabot> Not in scope: `ignore'
00:09:53 <quicksilver> desp: intersperse
00:09:59 <desp> right
00:10:01 <nmessenger> desp: \xs -> concat (intersperse "\n" xs) -- ?
00:10:05 <dmwit> > concat $ intersperse "\n" ["Hello"]
00:10:07 <lambdabot>  "Hello"
00:10:09 <narain> :t intersperse
00:10:12 <lambdabot> forall a. a -> [a] -> [a]
00:10:14 <desp> thanks!
00:10:16 <dmwit> > concat $ intersperse "\n" ["Hello,", "world."]
00:10:18 <lambdabot>  "Hello,\nworld."
00:10:34 <quicksilver> :t concat . intersperse "\n"
00:10:36 <lambdabot> [[Char]] -> [Char]
00:10:56 <ivanm> nmessenger: so with the guard statement, is the way it works that each value of x and y is inserted in one at a time?
00:11:31 <dmwit> ivanm: Basically, yes.
00:11:45 <ivanm> ahh... that makes more sense now
00:12:48 <nmessenger> concatMap (\x -> concatMap (\y -> concatMap (\_ -> return (x,y)) (guard (x*y==8))) [3,4,5]) [1,2,3]
00:12:52 <nmessenger> > concatMap (\x -> concatMap (\y -> concatMap (\_ -> return (x,y)) (guard (x*y==8))) [3,4,5]) [1,2,3]
00:12:53 <lambdabot>  [(2,4)]
00:14:03 <nmessenger> in the list monad, the "rest of the do block" is mapped over each list element, and the results concatted.
00:15:09 <desp> ?src intersperse
00:15:09 <lambdabot> intersperse _   []     = []
00:15:10 <narain> so a monad is a functor with a  join ?
00:15:10 <lambdabot> intersperse _   [x]    = [x]
00:15:10 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
00:15:21 <quicksilver> narain: and a 'return'
00:15:27 <quicksilver> narain: and certain algebraic laws
00:15:34 <nmessenger> narain: also return, but yes, precisely
00:15:38 <narain> oh, right right
00:15:51 <quicksilver> 'return' is sometimes called pointed
00:15:53 <desp> can lb tell me where is that function defined?
00:16:04 <quicksilver> so you could say that a monad is a pointed functor with a join
00:16:06 <narain> ?source intersperse
00:16:06 <lambdabot> intersperse not available
00:16:07 <nmessenger> @index intersperse
00:16:07 <lambdabot> Data.List
00:16:21 <desp> thanks
00:16:23 <quicksilver> satisfying laws which say that the return is a 'unit' for the join
00:16:24 <narain> "pointed functor" :)
00:16:41 <narain> interesting
00:18:51 <narain> you know how sometimes you can do proofs just by algebraic manipulation without any deep understanding required? i'm like that with monads, i look at the types and what they do and fit them together
00:19:38 <nmessenger> heh, you should see the ap derivation I did about a week ago :)
00:19:40 <narain> but i haven't really internalized what it really is that connects [], Maybe, IO, State and all those under the overarching category of "Monad"
00:20:29 <narain> nmessenger: sure, i'd love to :)
00:20:32 <nmessenger> they can be "returned" into, have their contents "mapped" over, and stacks "joined" together.
00:20:35 <narain> just a moment
00:20:36 <narain> :t ap
00:20:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:21:20 <narain> i hear you, but i don't grok it really
00:21:31 <dons> ?yow
00:21:32 <lambdabot> So this is what it feels like to be potato salad
00:21:43 <dons> sjanssen: so I'm wondering if we can just write xhb using c2hs..
00:21:50 <dons> sjanssen: i've been talking to dcoutts about it :-)
00:22:15 <nmessenger> found it :) http://hpaste.org/833
00:22:34 <ivanm> dons: out of curiosity, do you know of any other uni apart from unsw that has a research group looking at functional programming?
00:22:49 <nmessenger> pjd produced the given just by hooking together types, and I tried to see if I could derive the library definition of ap from it.
00:23:44 <narain> holy
00:23:49 <narain> moly
00:24:00 <dmwit> So, is hpaste just that small that you can still search all of it manually?
00:24:16 <nmessenger> I know, I don't really grok it either, just symbol manipulation :D
00:24:38 <nmessenger> I just clicked "older" 'til I found it :)
00:25:17 <narain> :t liftM2 -- excuse me a moment
00:25:20 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:25:38 <dmwit> Hahaha,
00:25:43 <dmwit> http://hpaste.org/945
00:26:02 <nmessenger> tho' I did make one mistake, the rule that I explained by (x >>= k = join (liftM k x)) is actually (DEF OF liftM)
00:26:38 <desp> Cale: woot, http://pastie.textmate.org/46555 :)
00:26:40 <lambdabot> Title: #46555 - Pastie
00:26:43 <nmessenger> liftM = fmap
00:27:10 <Cale> desp: :)
00:28:17 <dons> ivanm: melbourne, maquarie and ANU do
00:28:28 <ivanm> dons: OK, thanks
00:29:00 <ivanm> dons: At UQ, there's a couple of researchers who look at it, but no one group (the head of ITEE has an ongoing project called "totally functional programming", IIRC)
00:30:21 <narain> nmessenger: it does make a bit of sense when reading it backwards :)
00:30:29 <dons> ivanm: did you see emk's tutorial he wrote for you?
00:30:41 <nmessenger> well that's good I guess :D
00:30:42 <ivanm> dons: yep, and thanked him for it as well
00:31:30 <ivanm> dons: though my biggest problem with monads is understanding the state monad... the actual  operators, do notation, etc. don't confuse me as such, just that all the tutorials cover the state monad pretty early
00:31:52 <desp> yes, I don't think I understand the state monad yet
00:32:56 <kc5tja> Actually, I have plans on writing up a document that should add to the confus...er...tutorials on the state monad.
00:33:05 <narain> if you think of how you would model a stateful computation in haskell, the state monad starts making a lot of sense
00:33:11 <kc5tja> Based on valuable input I received from Cale (to give credit where credit is due)
00:33:22 <dons> > runState (do x <- get ; put (x+1) ; return "done") 7
00:33:24 <lambdabot>  ("done",8)
00:33:31 <dmwit> desp, ivanm: Have you seen "You Could Have Invented Monads! (And Maybe You Already Have.)"?  The first example of debuggable functions is a sort of simplified state monad.
00:33:34 <dons> ?undo do x <- get ; put (x+1) ; return "done"
00:33:34 <lambdabot> get >>= \ x -> put (x + 1) >> return "done"
00:33:38 <dons> ?src get
00:33:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
00:33:51 <ivanm> ?where you could have invented monads
00:33:51 <lambdabot> I know nothing about you.
00:33:58 <narain> > runState (State (\s -> (show s, (s+1)))) 1
00:33:58 <ivanm> @google you could have invented monads
00:33:58 <dmwit> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
00:33:59 <mwc> Hmmm. Let's say I have a C header file that either defines or doesn't LIBFOO_NO_bar, telling me if feature bar is in the lib. I need to exclude some ffi wrappers based on that macro... how can I do this?
00:33:59 <lambdabot>  ("1",2)
00:34:01 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
00:34:01 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
00:34:01 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
00:34:02 <nmessenger> :D
00:34:12 <dons>     get   = State $ \s -> (s, s)
00:34:12 <dons>     put s = State $ \_ -> ((), s)
00:34:28 <ivanm> dmwit: thanks, I'll have a look at that
00:34:32 <mwc> It's like I need to feed the final table of CPP macros from processing that header into the preprocessor that runs on the haskell code
00:35:02 <ivanm> maybe I just need to go through the tutes again now that I've coded a bit of haskell :s
00:35:20 <dmwit> Well, you know what they say about coding vs. reading. ;-)
00:35:38 <desp> dmwit: I understand monads that I write myself
00:35:48 <desp> dmwit: but I don't understand the usage of the built-in State monad
00:35:49 <desp> :)
00:35:58 <mwc> Groking Cont and ContT was the trial by fire for me
00:36:02 <dmwit> =D
00:36:06 <nmessenger> cool, what monads have you written?
00:36:30 <desp> nmessenger: just simple ones...
00:36:56 <desp> nmessenger: and something I wrote earlier, http://desp.night.pl/programy/beautifier/ ;)
00:37:00 <lambdabot> Title: Index of /programy/beautifier
00:37:02 --- mode: ChanServ set +o dons
00:37:06 <desp> (but that's SML)
00:37:07 <narain> > let postincr = State $ \n -> (n, n+1) in runState (postincr >> postincr) 42
00:37:09 <lambdabot>  (43,44)
00:37:09 --- topic: set to '["The Haskell programming language: what monads have you written?","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
00:37:14 --- mode: ChanServ set -o dons
00:37:39 * nmessenger does the topic dance
00:37:43 <kc5tja> One thing that has me puzzled is, there is typically one monad per "object" of state (if you'll pardon the analogy).  How does one handle multiple such monads, especially if the two pieces of state interact?
00:37:45 <dons> :-)
00:37:56 <ivanm> why does so much of Haskell use require monads?
00:37:58 <dons> use a record for the state type?
00:38:03 <desp> dons: that's a pretty good tagline
00:38:21 <dons> ivanm: its a nice abstraction for a lot of interesting coding problems
00:38:28 <desp> ivanm: because all Haskell programmers are secretly longing for some honest imperative programming?
00:38:31 <narain> ivanm: because they simplify code? you can do a lot without monads but things get a lot more elegant with them
00:38:31 <desp> ;)
00:38:39 <sieni> monadic io <3
00:38:58 <ivanm> dons, desp, narain: but doesn't it ruin the whole functional programming paradigm?
00:39:12 <dons> oh, you mean monads for side effects?
00:39:14 <kc5tja> ivanm: Because programs exist to affect changes of state to the world.  If they didn't, there'd be no reason to run the program at all (and that's the ultimate in Haskellian laziness!)
00:39:18 <dons> that's only one small part of where they're used though
00:39:28 <ivanm> kc5tja: lol!
00:39:37 <desp> ;)
00:39:49 <narain> ivanm: i have an example that just happened to me a couple of days ago
00:39:53 <kc5tja> dons: You made the fatal mistake: use a record for the state type.  Again, what if you have more than one record?
00:39:55 <dons> consider they're also used for error handling, continuations, transactoinal memory, encapulsated state, privledge seperation, hmm. .. logging, binary parsers, parsing ..
00:40:02 <ivanm> dons: not just side effects, in general... I thought people would have tried to avoid monads like the devil except for IO
00:40:02 <narain> ivanm: which doesnt even have anything to do with side-effects
00:40:15 <dons> kc5tja: use a type to combine the state values? or use a monad transformer
00:40:17 <ivanm> dons: OK
00:40:21 <ivanm> narain: what for?
00:40:47 <mwc> Crap, do I need to write a CPP to do this?
00:41:06 <dons> there's a lot of nice abstractions we get as libraries, which are keyword/syntax/language/runtime extensions in languages without monads
00:41:15 <dons> that's the main reason for their existence: extensibility
00:41:22 <kc5tja> dons: For example, consider a GUI where you have a window with a set of icons in it (think MacOS-style Finder window).  Each icon is represented by some abstract data type.  A program can affect state changes to one or more of those objects.
00:41:22 <narain> ivanm: i was trying to write a simple recursive-descent parser -- most of my parse functions were of type  String -> (Result, String)  which also gave back the remainder of the string
00:41:36 <dons> consider the list here, http://www.haskell.org/haskellwiki/Monad#Interesting_monads
00:41:37 <lambdabot> Title: Monad - HaskellWiki
00:41:48 <narain> ivanm: so there was a lot of plumbing that had to be done to parse one thing after another
00:41:53 <dons> kc5tja: oh, so like a window manager?
00:41:56 <ivanm> narain: OK
00:42:04 <dons> kc5tja: want to see the state type of our window manager sjanssen and I are writing?
00:42:16 <nmessenger> kc5tja: so State [WindowObject] a?
00:42:18 * ivanm wonders if anyone has written a "monads as plumbing" tutorial, with mario as the main character ;-)
00:42:25 <dons> newtype X a = X (StateT XState IO a)
00:42:26 <dons>     deriving (Functor, Monad, MonadIO, MonadState XState)
00:42:35 <dmwit> Whoa, hey, continuations are kind of a neat idea.
00:42:37 <dons> data XState = XState
00:42:37 <dons>     { display       :: Display
00:42:37 <dons>     , screen        :: {-# UNPACK #-} !ScreenNumber
00:42:37 <dons>     , dimensions    :: {-# UNPACK #-} !(Int,Int)
00:42:37 <dons>     , workspace     :: {-# UNPACK #-} !WorkSpace      -- ^ workspace list
00:42:40 <dons>     }
00:42:42 <dmwit> How come I've never heard of them before?
00:42:52 <dons> kc5tja: so all the windows are stored in a Map in 'WorksSpace'
00:42:54 <ivanm> dmwit: because no one told you before? :p
00:42:55 <narain> ivanm: turns out this is better expressed as a stateful computation, where each parse function takes an input state which is the string to parse, returns a value, and modifies the state to remove the portion it has parsed
00:43:02 <dons> and events from X call handlers which update the state for those windows in our map
00:43:11 <dmwit> ivanm: Yeah, I guess so. =P
00:43:19 <ivanm> narain: OK
00:43:25 <narain> ivanm: once i figured out the State monad and moved over to that, it took care of all the plumbing for me
00:43:32 <ivanm> lol
00:43:42 <narain> ivanm: it was pretty neat, it did exactly what i needed it to do
00:43:48 <dons> kc5tja: so yeah, basically you'd have say, StateT (Map Name Window) IO a
00:43:52 <dons> as your gui monad
00:43:55 <ivanm> narain: is there code available to look at?
00:44:02 <dons> so you could do state, and IO, for multiple windows
00:44:03 <sjanssen> dons: you're talking to dcoutts about binding to the xcb C library?
00:44:05 <kc5tja> dons: I was not thinking of anything like a window manager, but the concept applies (individual icons within a window was my specific context, but any collection of objects will do)
00:44:08 <dons> sjanssen: yeah
00:44:14 <dons> sjanssen: using c2hs to do most of the work
00:44:18 <nmessenger> @unmtl StateT (Map name window) IO a
00:44:19 <lambdabot> Map name window -> IO (a, Map name window)
00:44:24 <dons> kc5tja: so your state is a collection
00:44:40 <narain> ivanm: it was a one-shot parser for reading a specific kind of file, so it's not of general interest, but i can hpaste it if you'd like
00:44:43 <dons> just like it would be a global list or something in C
00:45:02 <ivanm> narain: yeah, thanks, different perspectives are useful at times
00:45:13 <ivanm> probably would help for me to bludgeon through some real code
00:45:13 <kc5tja> Yeah
00:45:28 <dons> sjanssen: xcb seems signifcantly smaller (and it handles errors synchronously?)
00:45:35 <dons> so no random error events like in xlib
00:45:47 <sjanssen> dons: I don't think there's any way to use xcb with XFree86
00:45:48 <dons> kc5tja: btw, did you have a look at my code? did it work ?
00:45:53 <sjanssen> which might not be a big deal
00:46:09 <dons> sjanssen: hmm, dcoutts was saying that new Xlib actually itself uses xcb
00:46:24 <dons> XFree87 or Xorg ?
00:46:56 <dons> s/86/
00:47:28 <mwc> Please tell me a way to avoid putting #include <openssl/opensslconf.h> in my haskell code :(
00:47:33 <sjanssen> dons: Xorg's Xlib uses xcb under the hood, but I don't think the code is packaged such that XFree86 users can use it
00:47:36 <mwc> I mean, it works, but I feel horribly evil
00:48:16 <kc5tja> dons: Sorry, no, I've been installing OSes all night.  Laptop has pissed me off for the last time, and my main box is going senile, so I'm reinstalling here too.  :(
00:48:27 * kc5tja still has the code; I'm installing in another partition.  But, no productivity tonight.
00:48:28 <mwc> I need the #defs in there to conditionally exclude ffi wrappers
00:50:18 <hpaste>  narain pasted "example of recursive-descent parsing using the State monad" at http://hpaste.org/953
00:50:37 <ivanm> narain: thanks
00:50:52 <narain> ivanm: i don't use do-notation at all in that code
00:51:04 <narain> ivanm: i don't know if that's idiomatic
00:51:24 <sjanssen> dons: I might be mixed up on this issue, I find it a bit confusing :)
00:51:52 <ivanm> narain: why did you use 4-element lists rather than tuples?
00:52:01 <ivanm> or 3-element
00:52:24 <narain> ivanm: ah, so i'd be able to use map :)
00:52:25 <ivanm> duh, because readField produces a list :s
00:52:37 <ivanm> narain: or that
00:52:50 <ivanm> @src (>>)
00:52:50 <lambdabot> m >> k      = m >>= \_ -> k
00:52:51 <narain> ivanm: yeah, i felt a tradeoff there
00:52:52 <mwc> aren't tuples functors?
00:53:01 <ivanm> @src (=<<)
00:53:01 <lambdabot> f =<< x = x >>= f
00:53:04 <nmessenger> @src (,) fmap
00:53:04 <lambdabot> fmap f (x,y) = (x, f y)
00:53:05 <narain> ?instances Functor
00:53:06 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
00:53:14 <ivanm> @src (>>=)
00:53:15 <lambdabot> Source not found. My mind is going. I can feel it.
00:53:20 <narain> pairs are functors
00:53:24 <ivanm> lambdabot is going senile...
00:53:25 <nmessenger> hm, maps over the snd element
00:53:36 <narain> does that also apply to general n-tuples?
00:53:53 <nmessenger> doesn't look like it
00:53:55 <narain> oh yeah, and it'd only map over the second element as nmessenger said
00:53:57 <ivanm> narain: prob not, as snd only works for 2-element tuples
00:54:03 <dons> sjanssen: ah ok. so what we need is a user land program that does use xcb?
00:54:10 <dons> to know if it is possible.
00:54:15 <nmessenger> though I don't see why you couldn't define instance Functor (,,) a b
00:54:17 <dons> preferably a window managner
00:54:17 <sjanssen> I guess?
00:54:33 <nmessenger> ((,,) a b) rather
00:54:37 <ivanm> \_ == useless function? as in its there because you need a function but don't need it to do anything?
00:54:42 <sjanssen> dons: do you use XFree86?
00:54:47 <mwc> Oh, the fmap impl. for (,) is different than I expecdted
00:54:56 <mwc> I was expecting one for (a,a,a,a,a)
00:54:56 <dons> sjanssen: nope, Xorg
00:55:09 <nmessenger> > (\_ -> "argument discarded!") "useless argument :("
00:55:10 <lambdabot>  "argument discarded!"
00:55:25 <sjanssen> we might be hard pressed to find a machine without Xorg
00:55:35 <ivanm> > \_ -> 2 $ 3
00:55:36 <lambdabot>   add an instance declaration for (Num (a -> b))
00:55:43 <ivanm> > \_ -> 2 $ 3 :: Int
00:55:44 <lambdabot>   add an instance declaration for (Num (a -> Int))
00:55:50 <nmessenger> that's (\_ -> (2 $ 3))
00:55:56 <ivanm> oh
00:56:02 <ivanm> > (\_ -> 2) $ 3
00:56:03 <lambdabot>  2
00:56:07 <ivanm> k
00:56:16 <narain> you didn't really need the $ there :)
00:56:26 <ivanm> narain: just in case :)
00:56:35 <ivanm> sjanssen: why do you need xfree86?
00:56:49 <dons> sjanssen: do we have any docs on xcb?
00:56:58 <nmessenger> > (\anyNameWillDo -> 2) 3
00:57:00 <lambdabot>  2
00:57:03 <sjanssen> ivanm: do determine whether xcb works on it
00:57:07 <sjanssen> s/do/to
00:57:07 <dons> what's this xhb binding Sven's been talking about?
00:57:08 <scw> > const 2 3
00:57:09 <lambdabot>  2
00:57:10 <dons> oh, dcoutts___ :-)
00:57:10 <ivanm> sjanssen: ahh, k
00:57:13 <nmessenger> _ is just conveniently ignored
00:57:16 <dons> dcoutts___: i see wifi works?
00:57:26 <dcoutts___> @arr
00:57:26 <lambdabot> Swab the deck!
00:57:27 <dcoutts___> yep
00:57:35 <ivanm> narain: what is your grid type?
00:57:41 <sjanssen> dons: http://xcb.freedesktop.org/wiki/
00:57:43 <lambdabot> Title: XCB Wiki - xcb
00:57:47 <dcoutts___> dons: with a bit of a lag
00:58:02 <narain> ivanm: ack, you weren't supposed to see that!
00:58:04 <narain> :)
00:58:05 <dons> dcoutts___: do you know if xcb is usable by X clients?
00:58:10 <ivanm> narain: lol
00:58:15 <dcoutts___> dons: oh, btw, I've got something of yours that you left in Nice
00:58:15 <narain> ivanm: it's a record
00:58:21 <dons> dcoutts___: oh?
00:58:25 <narain> ivanm: not really important
00:58:35 <ivanm> k
00:58:40 <dcoutts___> dons: it's for X clients, perhaps I don't see what you're getting at
00:59:05 <dcoutts___> dons: nothing important, I'll not embarrass you by telling everyone
00:59:12 <dons> ah he. ok.
00:59:21 <ivanm> narain: thanks for that code, but I don't really get it
00:59:24 <sjanssen> dcoutts___: is xcb tied into xorg's distribution
00:59:43 * ivanm will hit the books/tutes again and try and hammer State monad knowledge into his feeble brain by brute force
00:59:44 <narain> ivanm: heh. it would probably make more sense with the file it's supposed to parse
00:59:49 <ivanm> lol
00:59:55 <dcoutts___> sjanssen: well the xcb lib comes with X.org, yes. What is your concern?
01:00:16 <sjanssen> dcoutts___: legacy users on XFree86
01:00:27 <sjanssen> is that even a practical concern?
01:00:35 <dcoutts___> sjanssen: oh, they're stuffed.
01:00:51 <dmwit> :t when
01:00:53 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:00:58 <narain> ivanm: the way i look at the State monad is, it takes a state :: s and computes a value :: a
01:01:03 <ivanm> if someone's on a legacy system, are they likely to be updating many packages?
01:01:06 <narain> ivanm: in doing so, it may change the state
01:01:12 <ivanm> narain: k
01:01:13 <dcoutts___> sjanssen: they can install it of course (it's just a C lib), but if people never upgrade you can't use new stuff, simple.
01:01:26 <narain> ivanm: so, it has to be of type  s -> (a, s)
01:01:45 <narain> ivanm: take the old state, return the result and the new state
01:02:03 <ivanm> OK, I get that... its just the way the tutes were explaining it
01:02:10 <ivanm> but I haven't looked at them much recently
01:02:31 <narain> ivanm: ah, i haven't seen many tutes on State
01:02:45 <ivanm> @where wikibook
01:02:45 <lambdabot> http://en.wikibooks.org/wiki/Haskell
01:02:59 <ivanm> that's got a bit on state using nuclear waste of all things
01:03:06 <dons> "Xlib/XCB is scheduled to soon become the default version of Xlib shipped with X.org/freedesktop.org."
01:03:32 <dons> so we don't care though, since we'd be using *only* xcb calls
01:03:38 <dons> not xlib mixed with xcb
01:04:18 <narain> ivanm: yeah, i didn't find that very helpful
01:05:01 <narain> ivanm: though now it looks like it does explain everything... maybe it's just not laid out in a way that makes the logical jump easy
01:05:11 <ivanm> yeah, probably
01:05:24 <nmessenger> x >>= k = \st0 -> let (v, st1) = x st0 in k v st1 -- bind takes an action and a Kleisli, and makes a function.  That function takes a state, passes into the action and gets the result and new state.  Then the Kleisli is passed the new value to get a second action, which gets the newest state
01:05:38 <nmessenger> (modulo newtypes)
01:06:10 <sjanssen> dcoutts___, dons: it looks like xcb will be packaged with Xorg in the future, but isn't with current releases?
01:06:35 <dcoutts___> sjanssen: I think it is in the latest release, the libX11 uses xcb in the latest release
01:06:42 <narain> ivanm: anyway, one thing i stumbled on in the beginning was that a value of type State doesn't actually represent a state, rather a *computation* that takes a state as input
01:06:56 <ivanm> ahhhh.....
01:06:57 <narain> ivanm: i mean one thing which tripped me up was ^^
01:07:10 <ivanm> "give me a value and I'll tell you what the state is" kind of thing?
01:07:33 <narain> "give me the current state and I'll give you a value and the next state"
01:07:35 <dcoutts___> sjanssen: the latest 'all included' x.org release might not have it yet, but the latest separate libX11 does I think
01:07:38 <nmessenger> State blah goo = give me a blah, and I'll give you an updated blah and a goo
01:08:09 <ivanm> narain: k
01:08:34 <ivanm> nmessenger: blah == the state at that time?
01:08:43 <nmessenger> blah is any type
01:09:03 <nmessenger> for example the state could be (Map Key Value)
01:09:14 <narain> nmessenger: yes, but the point is that we treat it as defining the state of the thing, right? :)
01:09:14 <nmessenger> @unmtl State (Map Key Value) Int
01:09:15 <lambdabot> Map Key Value -> (Int, Map Key Value)
01:10:02 <nmessenger> A (State s a) is an action, that when given an 's', produces an 'a' and a new 's'.
01:10:15 <sjanssen> dcoutts___: and how much of the heavy lifting can c2hs do?
01:10:19 <nmessenger> the (State s a) itself doesn't know what the 's' is yet.
01:11:30 <dcoutts___> sjanssen: for xcb you'd want to generate .chs or .hs files from the xml protocol specs
01:11:49 <nmessenger> you need runState to unwrap the inner function, which you then pass the starting state to
01:12:24 <nmessenger> > runState (do x <- get; put (x*2); return (x+1)) 3
01:12:25 <lambdabot>  (4,6)
01:13:04 <mwc> What do haskell folk use for SSL these days? The openssl bindings I found only cover some of the digest algorithsm and don't even bother to attack the sockets themselves
01:13:08 <ivanm> what is the get getting? the 3 at the end?
01:13:13 * mwc gives some love to hopenssl
01:13:16 <nmessenger> yes
01:13:26 <sjanssen> dcoutts___: so chs serves as a simpler target for another tool to generate
01:13:43 <narain> > runState (do x <- get; put (x*2); y <- get; return y) 3
01:13:45 <lambdabot>  (6,6)
01:13:47 <sjanssen> a tool that reads the XML specifications and such
01:13:55 <dcoutts___> sjanssen: that's what we do for gtk2hs, we generate .chs files. c2hs is a great sanity check on a binding.
01:14:15 <dcoutts___> sjanssen: but someone still has to write the .chs file, that's not automatic
01:14:40 <ivanm> @type runState
01:14:42 <lambdabot> forall s a. State s a -> s -> (a, s)
01:15:00 <narain> i like using State without do-notation, personally
01:15:06 <dcoutts___> well, except for specific instances where we can automatically generate .chs files because we know a lot about the structure of the C lib's api
01:15:17 <nmessenger> newtype State s a = State { runState :: s -> (a, s) }
01:15:55 <narain> > runState (State $ \n -> (show n, n*2)) 3
01:15:56 <lambdabot>  ("3",6)
01:16:30 <nmessenger> remember newtype is just like type, but there is an added State constructor that disappears at runtime.
01:16:41 <nmessenger> also the record syntax is maybe a little confusing
01:16:53 <nmessenger> runState (State f) x = f x -- might be clearer
01:16:58 <dons> sjanssen: right, so we probably look at the xml spec, and write .chs code
01:17:05 <dons> and then use that to generate the full binding
01:17:37 <sjanssen> so we're talking very little automation
01:17:59 <nmessenger> which is equivalent to runState (State f) = f, which is what the record syntax means
01:18:11 <dons> i guess the .chs gets us a fair way? and if we had tools to get .chs from the xml
01:18:11 <nmessenger> runState is an "unpacker"
01:18:15 <dons> ..
01:18:16 <narain> nmessenger: aha, i didn't realize until just now that runState was actually a field accessor. i had been wondering why it hadn't shown up anywhere in the docs :)
01:18:40 <nmessenger> I tried @src State for the type decl but no luck :(
01:18:48 <narain> (...i meant to type that before you said it out loud... :/ )
01:19:01 <nmessenger> no worries :)
01:19:22 <narain> i'm sure i've seen the type decl in the docs
01:19:25 <narain> ?docs State
01:19:26 <lambdabot> State not available
01:19:31 <narain> ?docs Control.Monad.State
01:19:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
01:19:54 <narain> buh. nope
01:20:18 <narain> runState appears under "Contructors". what gives?
01:20:50 <nmessenger> State is the constructor, and runState is the field accessor
01:21:44 <Residual> hey, I have a question on haskell
01:21:51 <nmessenger> @type splitAt 3
01:21:53 <lambdabot> forall a. [a] -> ([a], [a])
01:21:57 <nmessenger> @type State (splitAt 3)
01:22:00 <lambdabot> forall a. State [a] [a]
01:22:29 <nmessenger> > runState (State (splitAt 3)) "boxing wizards"
01:22:31 <lambdabot>  ("box","ing wizards")
01:22:47 <nmessenger> Residual: ask away!
01:22:58 <Residual> thanks, it's just a quick one.
01:23:10 * nmessenger preps for stereo response
01:23:12 <narain> nmessenger: that's useful for parsing things of known length :)
01:23:32 <Residual> I was wondering if there is a way to get the number of characters in a number
01:23:44 <narain> ...in the deciman representation of a number?
01:23:44 <nmessenger> length . show?
01:23:52 <nmessenger> > length (show 219307)
01:23:54 <lambdabot>  6
01:24:03 <nmessenger> > length (show 1e7)
01:24:05 <lambdabot>  5
01:24:05 <Residual> oh, so I have to use both
01:24:17 <Residual> thanks
01:24:18 <narain> well, you could do log 10
01:24:21 <narain> :)
01:24:23 <vegai> > length (show 1e1000)
01:24:27 <lambdabot>  8
01:24:33 <nmessenger> > logBase 10 219307
01:24:34 <lambdabot>  5.341052494025244
01:24:39 <nmessenger> :)
01:24:40 <vegai> yes, "Infinity" has 8 letters :)
01:24:52 <nmessenger> :D
01:24:53 <narain> > ceiling (logBase 10 219307)
01:24:54 <lambdabot>  6
01:25:05 <narain> > ceiling (logBase 10 100000)
01:25:06 <lambdabot>  5
01:25:11 <narain> :(
01:25:12 <nmessenger> ??
01:25:14 <Residual> and to make that equal a parameter, I would just length (show 123) = n
01:25:19 <narain> > floor (logBase 10 100000) + 1
01:25:21 <lambdabot>  6
01:25:49 <nmessenger> Residual: eh?
01:26:03 <narain> Residual: you want to check for equality? that's ==
01:26:32 <Residual> not equality, I want to take that length and use it in another equation
01:26:49 <nmessenger> otherFunction (length (show yourNumber))
01:27:25 <nmessenger> or ... where numDigits = length (show number)
01:27:40 <narain> or  let n = length (show yourNumber) in ...
01:28:09 <nmessenger> or (\numDigits -> ...) (length (show yourNumber)))
01:28:16 <nmessenger> :P
01:28:39 <Residual> I like the where n = length (show number) :)
01:28:42 <Residual> thanks
01:28:47 <narain> nmessenger: ok, there's gotta be a way to turn that into a monadic bind :p
01:29:24 <narain> ?help quickcheck
01:29:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:29:29 <narain> ?help check
01:29:29 <lambdabot> check <expr>
01:29:30 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
01:29:42 <nmessenger> @check 1 == 1
01:29:44 <lambdabot>  OK, passed 500 tests.
01:29:48 <nmessenger> good
01:29:53 <narain> :D
01:30:14 * nmessenger is the master prover
01:30:26 <vegai> is it easy to write QuickCheck tests that seem to work but are horribly wrong?
01:30:27 <narain> how do i check if length (show n) == floor (logBase 10 n) + 1?
01:30:42 <narain> with quickcheck, i mean
01:30:53 <nmessenger> @check (\n -> length (show n) == floor (logBase 10 n) + 1) :: Int -> Bool
01:30:53 <lambdabot>   add an instance declaration for (Floating Int)
01:31:04 <nmessenger> @check (\n -> length (show n) == floor (logBase 10 n) + 1) :: Double -> Bool
01:31:05 <lambdabot>  Falsifiable, after 0 tests: 0.0
01:31:28 <nmessenger> > (length (show 0.0), floor (logBase 10 n) + 1)
01:31:29 <lambdabot>   Not in scope: `n'
01:31:34 <nmessenger> > (length (show 0.0), floor (logBase 10 0.0) + 1)
01:31:35 <lambdabot>  (3,-179769313486231590772930519078902473361797697894230657273430081157732675...
01:31:36 <narain> for ints, dammit :p
01:31:50 <nmessenger> @check (\n -> length (show n) == floor (logBase 10 (fromIntegral n)) + 1) :: Int -> Bool
01:31:50 <narain> uh, positive ints?
01:31:51 <lambdabot>  Falsifiable, after 2 tests: -1
01:31:57 <narain> augh
01:32:03 <nmessenger> @check (\n -> n > 0 ==> length (show n) == floor (logBase 10 (fromIntegral n)) + 1) :: Int -> Bool
01:32:04 <lambdabot>  Couldn't match expected type `Bool'
01:32:09 <nmessenger> @check (\n -> n > 0 ==> length (show n) == floor (logBase 10 (fromIntegral n)) + 1) :: Int -> Property
01:32:10 <lambdabot>  OK, passed 500 tests.
01:32:14 <narain> \o/
01:32:15 <nmessenger> \o/
01:32:24 <nmessenger> *high-five*
01:32:36 <narain> *high-five back*
01:33:01 <narain> ok, let me commit the quickcheck usage to memory.
01:33:06 <nmessenger> @scheck (\n -> n > 0 ==> length (show n) == floor (logBase 10 (fromIntegral n)) + 1) :: Int -> Property
01:33:08 <lambdabot>   Completed 13 test(s) without failure.  But 7 did not meet ==> condition.
01:33:23 <nmessenger> scheck = smallcheck = slightly smarter
01:34:13 <narain> quickcheck is a haskell module, right? the Property type belongs to it i presume?
01:34:22 <nmessenger> @index Property
01:34:22 <lambdabot> Test.QuickCheck, Debug.QuickCheck
01:34:28 <narain> ?src Property
01:34:28 <nmessenger> don't presume nothin' :P
01:34:29 <lambdabot> Source not found. That's something I cannot allow to happen.
01:34:37 <narain> heh. thanks
01:35:06 <nmessenger> @type quickCheck
01:35:09 <lambdabot> forall a. (Testable a) => a -> IO ()
01:35:12 <nmessenger> @instances Testable
01:35:13 <lambdabot> Couldn't find class `Testable'. Try @instances-importing
01:35:25 <nmessenger> @instances-importing Test.QuickCheck Testable
01:35:26 <lambdabot> (), (a -> b), Bool, Property, Result
01:35:38 <nmessenger> oh?  (a -> b)?
01:36:04 <nmessenger> @source Test.QuickCheck
01:36:05 <lambdabot> http://darcs.haskell.org/packages/QuickCheck/Test/QuickCheck.hs
01:38:51 <narain> nmessenger? is that you?
01:39:04 <nmessenger> got disconnected
01:39:34 * nmessenger shakes fist at his ISP
01:39:42 <narain> heh. funny doppelgangeresque transcript, that.
01:40:39 <narain> especially since i just watched "The Prestige" yesterday
01:40:50 <narain> oops
01:40:55 * narain claps hands on mouth
01:41:18 * nmessenger 's interest is piqued
01:41:36 <narain> it's a compelling movie
01:41:49 * nmessenger googles
01:43:29 <nmessenger> instance (Arbitrary a, Show a, Testable b) => Testable (a -> b)
01:43:52 <nmessenger> @check even
01:43:53 <lambdabot>  Add a type signature
01:44:00 <nmessenger> @check even :: Int -> Bool
01:44:02 <lambdabot>  Falsifiable, after 2 tests: -1
01:44:10 <nmessenger> cool
01:44:16 <narain> hmm
01:44:20 <narain> not bad
01:44:20 <dons> QC rocks
01:44:51 <dons> unit tests are for the weak-(ly typed)!
01:45:15 <nmessenger> :o)
01:46:16 <narain> > let prime n = not . any (\i -> n `mod` i == 0) [2..n-1] in prime 11
01:46:18 <lambdabot>  Couldn't match expected type `a -> Bool'
01:46:30 <narain> > let prime n = not . any (\i -> (n `mod` i) == 0) [2..n-1] in prime 11
01:46:30 <quicksilver> :t :t Data.Map.fromList . map (\(x,y) -> (y,x)) . Data.Map.toList
01:46:31 <lambdabot>  Couldn't match expected type `a -> Bool'
01:46:33 <lambdabot> parse error on input `:'
01:46:36 <quicksilver> :t Data.Map.fromList . map (\(x,y) -> (y,x)) . Data.Map.toList
01:46:39 <lambdabot> forall k a. (Ord a) => M.Map k a -> M.Map a k
01:46:46 <quicksilver> ok, thats odd
01:46:49 <narain> > let prime n = not $ any (\i -> n `mod` i == 0) [2..n-1] in prime 11
01:46:50 <lambdabot>  True
01:46:53 <nmessenger> narain: not $ any ...?
01:46:53 <quicksilver> why doesn't that have an Ord k context as well?
01:47:16 <nmessenger> hmm
01:47:32 <narain> ?check (\n -> n > 0 ==> prime (n*n + n + 41)) where prime n = not $ any (\i -> n `mod` i == 0) [2..n-1]
01:47:32 <lambdabot>  Parse error
01:47:34 <nmessenger> @type toList
01:47:37 <lambdabot> Not in scope: `toList'
01:47:37 <narain> ?check (\n -> n > 0 ==> prime (n*n + n + 41) where prime n = not $ any (\i -> n `mod` i == 0) [2..n-1])
01:47:38 <lambdabot>  Parse error
01:47:42 <nmessenger> @type M.toList
01:47:44 <lambdabot> forall k a. M.Map k a -> [(k, a)]
01:47:55 <narain> ?check (\n -> n > 0 ==> let prime n = not $ any (\i -> n `mod` i == 0) [2..n-1] in prime (n*n + n + 41))
01:47:56 <lambdabot>  Add a type signature
01:47:57 <nmessenger> ^^ no Ord k
01:48:05 <narain> ?check (\n -> n > 0 ==> let prime n = not $ any (\i -> n `mod` i == 0) [2..n-1] in prime (n*n + n + 41)) :: Int -> Property
01:48:06 <lambdabot>  Falsifiable, after 142 tests: 41
01:48:08 <quicksilver> nmessenger: ah, right
01:48:18 <narain> good lambdabot
01:48:24 <narain> ?botsnack
01:48:25 <nmessenger> @botsnack
01:48:25 <lambdabot> :)
01:48:25 <lambdabot> :)
01:49:11 <narain> interesting, it took 142 tests to find a counterexample?
01:49:21 <narain> and that too the smallest one
01:49:28 <nmessenger> weird property, I don't recognize it.
01:49:32 <nmessenger> and QC is random
01:49:37 <narain> right
01:49:39 <nmessenger> ?scheck (\n -> n > 0 ==> let prime n = not $ any (\i -> n `mod` i == 0) [2..n-1] in prime (n*n + n + 41)) :: Int -> Property
01:49:41 <lambdabot>   Completed 13 test(s) without failure.  But 7 did not meet ==> condition.
01:49:46 <nmessenger> :(
01:50:00 <narain> n*n + n + 41 is prime for 1,2,...,40 :)
01:50:30 <narain> the case against sloppy induction
01:51:49 <narain> > let prime n = not $ any (\i -> n `mod` i == 0) [2..n-1] in map ((\p -> if p then 'T' else 'F') . prime) [1..40]
01:51:51 <lambdabot>  "TTTFTFTFFFTFTFFFTFTFFFTFFFFFTFTFFFFFTFFF"
01:52:08 <narain> > let prime n = not $ any (\i -> n `mod` i == 0) [2..n-1] in map ((\p -> if p then 'T' else 'F') . prime . (\n -> n*n + n + 41)) [1..41]
01:52:10 <lambdabot>  "TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTFF"
01:52:34 <nmessenger> awesome
01:52:35 <narain> ah, so it's not prime for n = 40 as well
01:53:01 <narain> yeah, neat mathematical fact i like to remember
01:53:24 <nmessenger> mathematics++
01:53:53 <narain> also why you can't prove a thing for all n just by checking it for 1 and 2 and 3 and...
01:54:12 <narain> "look, i got all the way to thirty-nine! how much more evidence do you want?!" :p
01:54:28 <nmessenger> "*all* of it" :P
01:55:00 <narain> man, i should go to bed
01:55:07 <narain> it's almost morning
01:55:13 <narain> :(
01:55:18 <nmessenger> geh, likewise
01:55:19 <DRMacIver> Any polynomial you choose will result in a non-prime if you feed the constant value into it
01:55:42 <DRMacIver> (Although it's mildly neat that that one manages to hit primes for everything smaller than that :) )
01:56:03 <narain> "the constant value"?
01:56:03 <DRMacIver> Oh, sorry. You said it missed 40 as well.
01:56:10 <narain> oh
01:56:12 <quicksilver> narain: 41 :)
01:56:15 <DRMacIver> narain: Like '41' in 'n * n + n + 41'
01:57:16 <narain> right. what's interesting is that it's such a simple polynomial yet hits only primes for a long time
01:57:39 <narain> > 40*40 + 40 + 41
01:57:40 <lambdabot>  1681
01:57:49 <Syzygy-> > 1681/41
01:57:51 <lambdabot>  41.0
01:57:57 <narain> > 39*39 + 39 + 41
01:57:58 <lambdabot>  1601
01:58:24 <narain> ok, all the way till 1601, that's quite far to keep stepping on primes alone
02:00:03 <narain> *yawn* good night all
02:00:10 <nmessenger> 'night
02:01:34 <quicksilver> > findIndices (/= ' ') "abc def ghi"
02:01:35 <lambdabot>  [0,1,2,4,5,6,8,9,10]
02:01:44 <quicksilver> > findIndices (== ' ') "abc def ghi"
02:01:45 <lambdabot>  [3,7]
02:01:57 <quicksilver> > map (+1) . findIndices (== ' ') . "abc def ghi"
02:01:58 <lambdabot>  Couldn't match expected type `a -> [Char]'
02:02:06 <quicksilver> > map (+1) . findIndices (== ' ') $ "abc def ghi"
02:02:08 <lambdabot>  [4,8]
02:02:41 <quicksilver> ok, here's a puzzle: how to find the first number in both those lists
02:02:50 <quicksilver> (elegantly, I can do it longhand)
02:03:28 <quicksilver> I need 'intersection' for sorted lists
02:09:22 <DRMacIver> Hm. Use some sort of list comprehension to find all pairs of elements from the two lists (that is, one in the first and one in the second) and take the first (a, b) with a == b ?
02:11:09 <DRMacIver> Something like (I can't remember the list comprehension syntax) [ (a, b) | a <- x, b <- y, a == b] !! 1
02:14:20 <cragwolf> I'm trying to install lambdabot on my system so that I can use it in ghci, but the configure process complains: "cannot satisfy dependency arrows-any"
02:14:40 <ClaudiusMaximus> @hoogle [a] -> Data.Set a
02:14:41 <lambdabot> No matches, try a more general search
02:14:47 <quicksilver> DRMacIver: that doesn't go through them in the right order
02:14:49 <cragwolf> but I thought arrows was automatically installed with ghc 6.6
02:15:02 <quicksilver> DRMacIver: it tries all possibilities for b before trying any for
02:15:11 <quicksilver> DRMacIver: so it doesn't have the laziness I'm hoping for
02:15:34 <DRMacIver> Ah
02:15:44 <quicksilver> ClaudiusMaximus: there's fromList and fromAscList but they don't have the laziness I want either, I dont think
02:16:35 <ClaudiusMaximus> @type findIndices
02:16:37 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
02:17:33 <ClaudiusMaximus> quicksilver: true, at a guess...
02:18:14 <quicksilver> >  1 `Set.member` (Set.fromAscList [1..])
02:18:14 <lambdabot>   Not in scope: `Set.fromAscList'
02:18:24 <quicksilver> >  1 `Data.Set.member` (Data.Set.fromAscList [1..])
02:18:28 <lambdabot> Terminated
02:18:31 <quicksilver> not lazy :(
02:18:41 <quicksilver> so I can't use Set operations for this
02:19:18 <quicksilver> I think it needs hand coding. I don't think there is a built in recursor for the pattern 'move down two lists at different speeds'
02:19:47 <ClaudiusMaximus> isn't there a mergeSortedLists somewhere?  then you could check for duplicates
02:19:55 <ClaudiusMaximus> @hoogle merge
02:19:55 <lambdabot> Data.Graph.Inductive.Internal.Heap.merge :: Ord a => Heap a b -> Heap a b -> Heap a b
02:19:55 <lambdabot> Control.Concurrent.mergeIO :: [a] -> [a] -> IO [a]
02:19:55 <lambdabot> Text.ParserCombinators.Parsec.Error.mergeError :: ParseError -> ParseError -> ParseError
02:21:35 <DRMacIver> ClaudiusMaximus: But that would fail if the original lists had duplicates
02:21:49 <ClaudiusMaximus> DRMacIver: i think findIndices won't give duplicates
02:22:26 <DRMacIver> Ah, I missed that this was for two specific lists.
02:22:38 <quicksilver> DRMacIver: its for the output of two findIndices, yes
02:22:54 <quicksilver> DRMacIver: except one has been shifted :)
02:23:07 <DRMacIver> Oh well. At this point I'll fall my back on "I don't really know Haskell. Sorry." :)
02:23:25 <quicksilver> I want the 'intersection' of findIndices p l and map (+1) . findIndices q $ l
02:23:40 <quicksilver> i.e those indexes which satisfy p and the index before satisfies q
02:24:04 <ClaudiusMaximus> > let firstDup (x:y:zs) = if x == y then Just x else firstDup (y:zs); firstDup _ = Nothing in firstDup [1,2,3,4,5,6,6,6,7,8,9,10]
02:24:06 <lambdabot>  Just 6
02:24:21 <ClaudiusMaximus> > let firstDup (x:y:zs) = if x == y then Just x else firstDup (y:zs); firstDup _ = Nothing in firstDup [1,2,3,4,5,6,7,8,9,10]
02:24:23 <lambdabot>  Nothing
02:24:52 <quicksilver> ClaudiusMaximus: *nod* but then we still have to write mergeAscLists
02:25:06 <quicksilver> ClaudiusMaximus: not that that is particularly hard, but I could code the whole thing by hand too
02:25:18 <quicksilver> ClaudiusMaximus: I was just curious if someone could come up with something really neat + concisse
02:25:32 <ClaudiusMaximus> @hoogle (Ord a) => [a]->[a]->[a]
02:25:32 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
02:26:10 <malcolmw> do you want the conjunction of the predicates, or their disjunction?
02:27:17 <quicksilver> malcolmw: conjunction
02:27:27 <quicksilver> malcolmw: but there is a map (+1) in the way
02:28:28 <quicksilver> so it's not just findIndices (and p q)
02:28:28 <malcolmw> so you want to keep the index only if p(i) && q(i+1)
02:28:28 <quicksilver> yes
02:28:28 <quicksilver> > map (+1) . findIndices (== ' ') . "abc def ghi"
02:28:28 <lambdabot>  Couldn't match expected type `a -> [Char]'
02:28:45 <quicksilver> > map (+1) . findIndices (== ' ') $ "abc def ghi"
02:28:46 <lambdabot>  [4,8]
02:28:50 <malcolmw> so zipWith3 foo xs (tail xs) [0..]
02:28:54 <quicksilver> > findIndices (/= ' ') $ "abc def ghi"
02:28:55 <lambdabot>  [0,1,2,4,5,6,8,9,10]
02:29:31 <malcolmw> where foo x y i | p x && q y = Just i
02:29:33 <quicksilver> malcolmw: ah, interesting
02:30:27 <malcolmw> hmm, and then you need to squash the resulting [Maybe Int] to [Int]
02:31:57 <quicksilver> > zipWith3 foo l (tail l) [0..] where l = "abc def ghi" ; foo x y i | (x == ' ') && (y /= ' ') = Just i | otherwise = Nothing
02:31:57 <lambdabot>  Parse error
02:32:15 <quicksilver> > zipWith3 foo l (tail l) [0..] where { l = "abc def ghi" ; foo x y i | (x == ' ') && (y /= ' ') = Just i | otherwise = Nothing }
02:32:16 <lambdabot>  Parse error
02:32:47 <malcolmw> semicolon needed before | otherwise
02:32:59 <quicksilver> > zipWith3 foo l (tail l) [0..] where { l = "abc def ghi" ; { foo x y i | (x == ' ') && (y /= ' ') = Just i ; | otherwise = Nothing }
02:32:59 <lambdabot>  Parse error
02:33:12 <quicksilver> > zipWith3 foo l (tail l) [0..] where { l = "abc def ghi" ; { foo x y i | (x == ' ') && (y /= ' ') = Just i ; | otherwise = Nothing} }
02:33:13 <lambdabot>  Parse error
02:33:25 <ClaudiusMaximus> > zipWith3 foo l (tail l) [0..] where l = "abc def ghi" ; { foo x y i | (x == ' ') && (y /= ' ') = Just i ; | otherwise = Nothing}
02:33:25 <lambdabot>  Parse error
02:33:36 <ClaudiusMaximus> hmm
02:33:45 <malcolmw> is there anything between the single quotes?
02:34:04 <quicksilver> a space
02:34:15 <quicksilver> can't have where's at the top-level in an expression, that's what's wrong
02:34:42 <quicksilver> let l = "abc def ghi" ; foo x y i | (x == ' ') && (y /= ' ') = Just i | otherwise = Nothing in zipWith3 foo l (tail l) [0..]
02:34:44 <quicksilver> > let l = "abc def ghi" ; foo x y i | (x == ' ') && (y /= ' ') = Just i | otherwise = Nothing in zipWith3 foo l (tail l) [0..]
02:34:47 <lambdabot>  [Nothing,Nothing,Nothing,Just 3,Nothing,Nothing,Nothing,Just 7,Nothing,Nothing]
02:35:00 <quicksilver> > let l = "abc def ghi" ; foo x y i | (x == ' ') && (y /= ' ') = Just i | otherwise = Nothing in catMaybes $ zipWith3 foo l (tail l) [0..]
02:35:02 <lambdabot>  [3,7]
02:35:10 <quicksilver> malcolmw: neat, thanks
02:35:24 <malcolmw> a pleasure
02:35:40 <quicksilver> > let l = cycle "abc def ghi" ; foo x y i | (x == ' ') && (y /= ' ') = Just i | otherwise = Nothing in catMaybes $ zipWith3 foo l (tail l) [0..]
02:35:41 <lambdabot>  [3,7,14,18,25,29,36,40,47,51,58,62,69,73,80,84,91,95,102,106,113,117,124,128...
02:35:46 <quicksilver> it's lazy, too :)
02:35:55 <quicksilver> which was the objective, in fact
02:43:42 <dmwit> I want to know if any application, ever, has used unzip7.
02:44:47 <dmwit> Going from a Google search on "unzip7 Haskell", I'm going to go with no. =P
02:44:51 <ivanm> lol
02:50:45 <dons> malcolmw: didn't you use zipWith17 in your convex hull stuff?
02:51:38 <quicksilver> dons: would that zipWith3 approach be a reasonable way to find indexes in a lazy bytestring, do you thinkg?
02:53:00 <dons> hmm. in terms of taking the tail and indexing?
02:53:24 <dons> i think it might be.a specialised zipWith might do rather well on strict bytestrings too
02:54:05 <quicksilver> ah, bytestring doesn't have zipWith3, of course
02:54:06 <dons> there's a fast zipWith2 for zipWith' :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString
02:54:22 <dons> in fact, we provide a rewrite rule for it,
02:54:25 <dons> "FPS specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q .
02:54:25 <dons>     zipWith f p q = unpack (zipWith' f p q)
02:54:39 <dons> i.e. map over two bytestrings, building a third
02:54:42 * quicksilver nods
02:55:03 <quicksilver> I'm mapping over two bytestrings (Which are actually the same) building an index list, though
02:55:07 <dons> rather than the general, zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
02:55:15 <dons> yeah, i think that could be efficient.
02:55:38 <dons> it might need to be specialised by hand
02:55:38 <quicksilver> to give more context, what I'm actually doing is filtering a stream
02:55:42 <quicksilver> and doing replacements
02:55:50 <quicksilver> but the replacements need to be word-anchored
02:56:00 <dons> oh ok. interesting
02:56:02 <quicksilver> so it's like "find the first d which is immediately after a non-letter"
02:56:06 <dons> yeah
02:56:35 <dons> quicksilver: so you're doing quite a bit of bytestring hacking?
02:56:48 <quicksilver> dons: just a toy project to see how it all works, really
02:56:56 <quicksilver> it's a filtering TCP forwarder
02:57:02 <dons> oh, sounds nice.
02:57:13 <dons> let me know how it goes.
02:57:25 <dons> and read the core output, if in doubt :-)
02:57:41 <quicksilver> e.g. you could attach it to www.haskell.org port 80, and have it replace all instances of functional with non-functional
02:58:00 <quicksilver> the tricky bits are things like word boundaries broken over chunk boundaries
02:58:59 <quicksilver> and, this subword problem :)
03:03:35 <malcolmw> I use zipWith8 and zipWith12 quite a lot, but it is isosurface extraction, not convex hulls
03:04:23 * mux has fun filing 3 bug reports in a row for glChess
03:04:26 <DRMacIver> Hm. Does Haskell have zipWithn for all n then?
03:05:21 <malcolmw> no, I had to write them myself - the prelude only goes up to 4 I think
03:05:24 <DRMacIver> Ah
03:06:01 <mux> that's a mission for template haskell!
03:06:14 <malcolmw> but the pattern is obvious, indeed generic, and one might hope that a generic programming utility could derive any size you like
03:07:15 <quicksilver> not entirely unrelated is the annoying fact that ((a,b),c) is not isomorphic to (a,b,c)
03:07:48 <malcolmw> i'm quite happy that they are not isomorphic
03:08:14 <quicksilver> malcolmw: why?
03:08:33 <doserj> if anything, (a,b,c) should be isomorphic to (a,(b,c))...
03:08:39 <malcolmw> compilers can easily change the representation from one to t'other
03:09:14 <quicksilver> malcolmw: they can't actually, they have different numbers of elements
03:09:22 <malcolmw> but in my code, if I write on instead of the other, it probably represents a conceptual error in my thinking
03:09:36 <malcolmw> and I'd like the type system to tell me
03:10:00 <quicksilver> malcolmw: I wasn't saying they should be the same type
03:10:08 <quicksilver> malcolmw: I was complaining that they're not even isomorphic types
03:10:41 <malcolmw> actually, I think you'll find that ghc is quite capable of transforming a function of type ((a,b),c) -> foo into a -> b -> c -> foo
03:11:00 <malcolmw> at the core level
03:11:14 <DRMacIver> The lack of a good way of expressing tuple manipulation in HM type systems has always annoyed me.
03:11:27 <DRMacIver> Not that most other type systems have anything better. :)
03:11:41 <malcolmw> dependent typing can solve it
03:11:44 <DRMacIver> Yeah
03:11:50 <DRMacIver> That's why I said 'most' :)
03:14:31 <DRMacIver> (I mean, this isn't any sort of major problem. It's just vaguely annoying)
03:18:33 <araujo> morning
03:55:23 <kuribas> Ghc cannot do crossmodule optimisations, can it?
03:55:34 <kuribas> (like inlining)
04:01:18 <malcolmw> kuribas: sure it can
04:02:15 <malcolmw> ghc stores the rhs of inline-able defns in the interface (.hi) files, so a separate compilation can find them
04:02:32 <kuribas> malcolmw: oh, I see.  And what about object files then?
04:02:57 <malcolmw> kuribas: what about them?
04:03:33 <kuribas> Why are they needed?
04:04:10 <malcolmw> object files contain the compiled code
04:04:53 <malcolmw> if it turns out that an inline-able function is not inlined, then you still need the original version available to run
04:05:23 <kuribas> Oh, I see.
04:11:51 <kuribas> So grouping functions in different modules will not make my code less efficient?
04:12:21 <revence> http://freeshells.ch/~revence/monads.html
04:12:23 <lambdabot> Title: Monads on the Unix Shell &mdash; A Very Short Tutorial
04:12:37 <revence> Say something, lambdabot!
04:14:13 <kuribas> Arg, haskell-mode for emacs is so bad.
04:14:36 <kuribas> It wants to indent after "module MyModule where".
04:17:33 <revence> kuribas: vim.org
04:18:08 <kuribas> hehe :)
04:18:23 <kuribas> Does it have a good indentation engine?
04:19:03 <earthy> a slightly good one
04:19:12 <earthy> doesn't work too splendidly with haskell (yet)
04:19:27 <earthy> have been working on improving that though. :)
04:19:33 <revence> I said: vim.org
04:19:46 <earthy> work does however interfere from time to time. ;)
04:19:56 <revence> I am not complainingU/clear
04:20:23 <xs> kuribas, just from experience, grouping functions in different modules can make things less efficient, but i don't know why.
04:20:34 <Saizan> kuribas: jhc for example do whole program compilation to be able to make specializations and avoid to use dictionaries for typeclasses
04:20:41 <earthy> ooh, schweet, Bram updated his seven habits of effective text editing talk
04:21:00 <revence> I am yet to watch that talk, by the way.
04:21:12 <earthy> lunch entertainment! :)
04:22:34 <quicksilver> malcolmw: GHC performs quite a few semantically incorrect transformations, I believe :)
04:22:38 <earthy> ghe, Bram still looks and sounds the same. :)
04:22:38 <Saizan> kuribas: another thing that follows from this is that if you don't need a function outside the module, you shouldn't export it so that can be specialized
04:22:57 <earthy> slightly balder and greyer though. :)
04:23:25 <malcolmw> quicksilver: yes, but those would be bugs
04:24:46 <quicksilver> malcolmw: in transforming ((a,b),c) into a -> b -> c -> you inevitably force the function 'strict' on the (,) in (a,b)
04:25:01 <quicksilver> malcolmw: so it might behaving differently if the calculation of (a,b) was going to diverge
04:25:26 <malcolmw> quicksilver: I think ghc will only do that transformation if the function is indeed strict in the tuple constructors
04:25:33 <quicksilver> malcolmw: ah, good :)
04:25:51 <quicksilver> malcolmw: although of course, that does mean it's restricted to those cases where it can tell :)
04:25:56 <malcolmw> yup
04:25:58 <kuribas> Saizan: is jhc usable?
04:26:29 <malcolmw> quicksilver: adding strictness annotations (aka `seq`) will help it along sometimes
04:26:33 <Saizan> ?where nobench
04:26:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench.html
04:27:19 <quicksilver> does ghc deforest simple tuples like this: let (a,b) = (head x, tail x) in f a b ?
04:27:20 <Saizan> not so much judging from this http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html , but i don't really know
04:27:20 <lambdabot> Title: nobench: Haskell implementation shootout
04:27:54 <quicksilver> (is deforest even the right word for that?)
04:30:28 <vegai> "16 x amd64" does that mean what I think it means?
04:31:03 <quicksilver> 16 core rather than 16 chip, I think
04:31:13 <quicksilver> quad chip x quad core, perhaps?
04:32:59 <malcolmw> quicksilver: deforest is not quite the right term
04:33:10 <quicksilver> malcolmw: deforest is only recursive data types?
04:33:18 <malcolmw> quicksilver: usually
04:33:42 <quicksilver> malcolmw: you know what I mean though, right? sometimes we use tuples for multiple return types
04:34:14 <malcolmw> quicksilver: if you want to know whether ghc smashes the code down to something smaller, you can always just run it with -ddump-simpl and read the output :-)
04:34:15 <quicksilver> malcolmw: or just as a convenient way to name and group values, but it doesn't mean we actually want the compiler to construct tuples all ove the place at runtime
04:39:58 <quicksilver> malcolmw: I've got Gill, Launchbury, PJ; but that was 1993. Are you aware of any good more recent refs on deforestation?
04:40:10 <quicksilver> malcolmw: I've read the dons/dcoutts paper too :)
04:41:48 <malcolmw> Svenningson 2002 "Shortcut fusion for accumulating parameters and zip-like functions"
04:42:27 <malcolmw> Wadler 1990 "Deforestation: Transforming Programs to Eliminate Trees"
04:42:58 <quicksilver> malcolmw: thanks
04:43:26 <malcolmw> Ohori 2007 "Lightweight Fusion by Fixed Point Promotion"
04:43:33 <quicksilver> I really hope that scholar.google.com doesn't have the eventual affect of making journals crack down on illegal copies of papers :)
04:44:08 <mahogny> I think it would backfire heavily
04:44:09 <malcolmw> Launchbury 2000 "Zip Fusion with Hyperfunctions"
04:44:45 <malcolmw> Sheard 1995 "Warm Fusion: Deriving Build-Catas from Recursive Definitions"
04:48:17 <quicksilver> malcolmw: awesome. Thank you very much.
04:48:22 <quicksilver> malcolmw: that should keep me quiet for a while :)
04:57:57 <quicksilver> ah parametricity. pretty.
04:58:30 <xian> is it not possible to bind a certain match to an identifier, eg  foo (L as (x:xs)) = ..  so that L gets bound to the whole list.
04:59:03 <quicksilver> yes
04:59:06 <quicksilver> use '@'
04:59:08 <quicksilver> (for as)
04:59:25 <quicksilver> > let foo L@(x:xs) = (L,x,xs) in foo [1,2,3,4]
04:59:26 <lambdabot>  Parse error
04:59:39 <quicksilver> > let foo (x:xs)@L = (L,x,xs) in foo [1,2,3,4]
04:59:40 <lambdabot>  Parse error
04:59:41 <miez> L -> l
04:59:51 <quicksilver> > let foo l@(x:xs) = (l,x,xs) in foo [1,2,3,4]
04:59:52 <lambdabot>  ([1,2,3,4],1,[2,3,4])
04:59:55 <quicksilver> malcolmw:
05:00:01 <quicksilver> miez: d'oh thanks :)
05:12:13 <pejo> quicksilver, Gill's thesis is an improved version of the 93 stuff. Chitil's thesis is interesting too.
05:12:48 <quicksilver> pejo: yes, I was just reading Chitil's
05:13:13 <quicksilver> pejo: Chitil's is very readable. At least, the intro was.
05:13:13 <pejo> quicksilver, G.W Hamilton has a bunch of articles on it too. Something from 2006, in Fundamenta Informaticae (sp?).
05:13:55 <pejo> quicksilver, Marlow's thesis is good (and readable) too.
05:14:41 <quicksilver> "Deforestation for Higher-order Functional Programs." Marlow 96?
05:15:18 <pejo> quicksilver, http://www.haskell.org/~simonmar/papers/thesis.ps.gz
05:15:49 <dons> quicksilver: there's a list of fusion papers i prepared earlier, http://www.haskell.org/haskellwiki/Research_papers/Compilation#Fusion_and_deforestation
05:15:51 <lambdabot> Title: Research papers/Compilation - HaskellWiki, http://tinyurl.com/yst9wl
05:16:39 <quicksilver> dons: ah that's handy, thank you
05:16:58 <dons> if there's any missing you find,feel free to add them
05:17:13 <dons> our wiki can bring down corporate publishing forever!
05:17:18 <quicksilver> dons: do I have to write them first? :P
05:17:19 <dons> mwhahaha
05:17:28 <revence> http://freeshells.ch/~revence/monads.html
05:17:28 <dons> quicksilver: that's one way , yes.
05:17:30 <lambdabot> Title: Monads on the Unix Shell &mdash; A Very Short Tutorial
05:17:44 <dons> revence: nice. i'll add it to the HWN this week
05:18:00 <dons> revence: have you seen Oleg's article on how | works as >>= ?
05:18:05 <revence> Tell me what y'all think about that tut there.
05:18:13 <revence> I wrote it.
05:18:29 <pejo> quicksilver, personally, I'd be lazy and just wait and see what the channel cranks out in the 'nearby' future. :-)
05:19:16 <dons> revence: you might be interested in some otes I made a while ago on this, http://www.cse.unsw.edu.au/~dons/code/h4sh/DOC
05:19:42 <dons> just some notes on how to do instance Functor and instance Monad IO (and List?) in the shell.
05:20:43 <dons> revence: the key article on monads for the shell is Olegs, http://okmij.org/ftp/Computation/monadic-shell.html
05:20:44 <lambdabot> Title: UNIX pipes as IO monads
05:21:14 <pejo> dons, actually the Ohori article which malcolmw cited seems missing from there. (Lightweight Fusion by Fixed Point Promotion).
05:21:17 <MarcWebe1> Do you know a tool listing imported modules as graph?
05:21:23 <dons> ah yes, that's quite new. it should be added
05:21:37 <dons> i haven't added anything that's appeared since POPL
05:21:46 <dons> its a wiki, if you have the ref, add it :-)
05:21:52 <JaffaCake> Summer of code folks: should we try to establish the "important" projects before student applications start tomorrow?
05:22:01 <dons> JaffaCake: yeah, that's a good idea
05:22:11 <dons> i've got a bit of a sketch, and a strategy for identifying other things.
05:22:20 <dons> maybe take it onto soc-mentors@ if you've got an initial plan?
05:22:41 <JaffaCake> I don't really have a plan, just noticed that time was short :)
05:23:02 <JaffaCake> oops, I haven't been reading soc-mentors
05:23:21 * JaffaCake frantically reads email
05:23:56 <dons> JaffaCake: oh, I see your darcs comments have hit the #1 spot on the programming.reddit site :} http://programming.reddit.com/
05:23:58 <lambdabot> Title: reddit.com: programming - what&#39;s new online
05:24:32 <mux> revence: you should join #haskell.fr
05:24:41 <JaffaCake> oh dear, I'm not sure that's a good outcome
05:24:54 <revence> dons: No, I hadn't seen it.
05:25:10 <revence> :dons Lemme run a check.
05:25:14 <Saizan> MarcWebe1: it's not the same, but you can get the dependecies in a Makefile format with ghc -M YourRootModule.hs
05:28:36 <revence> This paper on monadic I/O and Unix shell is really good.
05:28:45 <revence> The same thing I was ranting on about.
05:36:13 <ralejs> @elite I hope you guys have noted that it's 1337 day today.
05:36:14 <lambdabot> i HoPe u gUY5 |-|av3 n0ted 7|-|A7 IT'z0rz 1337 D4y +0DaY.
05:36:25 <ralejs> http://en.wikipedia.org/wiki/1337_day
05:36:26 <lambdabot> Title: 1337 day - Wikipedia, the free encyclopedia
05:37:19 <ski> (revence : which paper ?)
05:48:53 <MarcWebe1> Saizan: Saizan Thanks this is exactly what I want.
05:49:19 <MarcWebe1> Is there a ghc --full-help-of-flags argument?
05:50:09 <revence> ski: I was gone for a bit. There is a paper that was linked to before, in here.
05:50:18 <revence> Let me get the URL, if I can still find it.
05:50:29 <revence> No, I have lost it.
05:50:46 <revence> It was about how monads and the Unix shell have so much in common.
05:50:50 <ivanm> MarcWebe1: the user's guide?
05:50:57 <ivanm> or the man page?
05:51:26 <MarcWebe1> ivanm: I don't have manpages about ghc Is my installation broken?
05:51:43 <revence> But there is one I wrote up (which is why I was given the link).
05:51:46 <ivanm> Don't know...
05:51:54 <MarcWebe1> ivanm: The user guide takes more time to open and look things up than a ghc -full-help | less  /keywordtofind
05:51:57 * ivanm has no man pages either
05:52:02 <revence> Okay, I found it.
05:52:05 <revence> http://okmij.org/ftp/Computation/monadic-shell.html
05:52:06 <lambdabot> Title: UNIX pipes as IO monads
05:52:23 <revence> And mine is at:
05:52:33 <ivanm> MarcWebe1: there's meant to be an online version as well: http://www.haskell.org/ghc/documentation.html
05:52:34 <revence> http://freeshells.ch/~revence/monads.html
05:52:34 <lambdabot> Title: The Glasgow Haskell Compiler
05:52:36 <lambdabot> Title: Monads on the Unix Shell &mdash; A Very Short Tutorial
05:52:44 <ivanm> prob is, there's too many different flags available...
05:53:13 <MarcWebe1> ivanm: I know it. But you still have to select that the right subtopic.
05:53:20 <MarcWebe1> ivanm: Why is this a problem?
05:53:28 <ivanm> chapter 4, IIRC
05:53:30 <MarcWebe1> ivanm: I wouldn't mind this list beeing really long.
05:53:43 <ivanm> MarcWebe1: the programmers probably would ;-)
05:53:53 <ivanm> two different lists of all the flags available to maintain
05:53:59 <MarcWebe1> ivanm: Again I know. But there is 4.1 4.2 and so on.
05:54:13 <MarcWebe1> ivanm: Don't you think one could be generated out of the second?
05:54:14 <ivanm> also, explanation of how they're all used...
05:54:22 <ivanm> MarcWebe1: I just used the pdf version...
05:58:01 * kuribas hopes future versions of haskell will have a COND construct.
05:58:16 <ivanm> isn't there a cond construct already?
05:58:25 <kuribas> Using "case () of () | ..." is just so ugly...
05:58:29 <kuribas> ivanm: there is?
05:58:55 <ivanm> oh, that's what I was talking about...
05:59:02 <ivanm> what did you mean?
05:59:47 <kuribas> Something like "cond n < 1 -> 0; otherwise -> 2"
06:00:00 <resiak> if n < 1 then 0 else 2
06:00:19 <resiak> (yes, I know that was a contrived example :-))
06:03:27 <kuribas> It's one of the constructs I use the most in scheme.
06:04:13 <kuribas> Multiple clause with if are ugly: if test then 0 elsif test2 then 1
06:04:44 <kuribas> "else if" even.
06:05:11 <kuribas> "elsif" like in Ruby would be also nice.
06:05:43 <Igloo> It's only a 2 character difference
06:06:57 <kuribas> Igloo: but visually it looks better.
06:07:44 <vincenz> Igloo: not quite, it's also the indenting
06:08:00 <Igloo> vincenz: Huh?
06:08:05 <hpaste>  vincenz pasted "illegal indentation" at http://hpaste.org/954
06:08:11 <vincenz> ack
06:08:25 <vincenz> nm
06:08:28 <vincenz> I forgot the then's
06:08:31 * vincenz shoots himself in the foot
06:08:55 <Saizan> revence: nice tutorial, a bit too specific on the IO monad maybe, the "dirty" analogy doesn't emphasize the fact that the >>= can actually change your computational strategy but it's probably a good start
06:08:57 <Igloo> kuribas: Well, that's just a matter of personal taste, I think
06:09:25 <kuribas> Igloo: wouldn't you think a COND construct would be a nice addition?
06:09:59 <rashakil_> > let cond = maybe undefined id . lookup True in cond [(7 < 5, "Foo"), (5 < 7, "Bar")]
06:10:00 <lambdabot>  "Bar"
06:10:53 <rashakil_> not that that's cleaner.. :)
06:11:29 <hpaste>  Marc Weber pasted "What am I doing wrong? ghc -M no output" at http://hpaste.org/955
06:12:26 <Saizan> MarcWebe1: erm, it creates a Makefile in your current directory
06:12:45 <MarcWebe1> lol. Thx
06:12:51 <Igloo> kuribas: Possibly, I'd have to see the syntax
06:13:06 <MarcWebe1> I just thought it would work like gcc -M which does print to stdout by default.
06:13:22 <Igloo> The changes in Haskell' to get rid of the bad interaction between if and layout will help, I think
06:14:17 <Saizan> MarcWebe1: yeah it would be more intuitive probably
06:14:20 <teehee> greeetings
06:14:22 * teehee is learning about monads
06:14:39 <Saizan> got questions?
06:14:51 <teehee> probably will in a moment
06:15:04 <teehee> but i just noticed this workstation doesn't have ghci, aargh!
06:15:13 <Saizan> :D
06:15:46 * teehee is arke but for some reason I can't ssh home
06:16:31 <teehee> argh
06:16:38 <teehee> none of my shell accounts have ghci :/
06:16:47 <teehee> does lambdabot work in /msg?
06:16:53 <Saizan> yes
06:17:08 <teehee> aah good
06:17:15 * teehee needs to register this nick
06:17:29 <sieni> ahh
06:17:54 <hpaste>  kuribas pasted "cond " at http://hpaste.org/956
06:17:59 <sieni> I was already wondering why you didn't attempt /msg lambdabot > 7 * 6 or something :-)
06:18:32 <teehee> how funny
06:18:33 <Saizan> fyi, some functions of Control.Monad must be used qualified, because of names clash
06:18:38 <kuribas> Igloo: Ghc seems to accept it.
06:18:51 <teehee> the nick is identified already ... but its not my nick :/
06:19:05 <teehee> I'm bound to get ghosted eventually then :D
06:20:15 * teehee tries implementing his first state monad
06:20:27 <dons> omg, "Results 1 - 10 of about 1,010,000 for monad tutorial"
06:20:48 <ivanm> lol
06:21:20 <rashakil_> wow, there's 80 monad tutorials
06:22:54 <earthy> okay, that's not too weird. 'Monad' is also a code name for the Windows Vista power shell
06:23:20 <Stinger> I thought they canned that
06:24:10 <earthy> stinger: the name, but that doesn't mean the codename can't be found anymore
06:24:27 <earthy> however, there is an awful lot of links to what we think of as monads. :)
06:24:32 <ivanm> earthy: yeah, and the gnu version is called GONAD ;-)
06:24:39 <teehee> :D
06:24:43 * earthy laughs
06:24:46 <earthy> it would be ;)
06:25:31 <ivanm> @google define:monad
06:25:32 <lambdabot> No Result Found.
06:27:08 <teehee> argh.
06:27:13 <emk> earthy: You can actually view shell pipelines carrying values of type 'a' as monad, so there may be a connection between Haskell and the Windows shell.
06:27:20 <teehee> lambabot is frustrating ;_;
06:28:04 * teehee sobs
06:28:35 <ivanm> its now called windows powershell: http://en.wikipedia.org/wiki/Windows_PowerShell
06:28:36 <lambdabot> Title: Windows PowerShell - Wikipedia, the free encyclopedia
06:29:01 * teehee curses himself for not reconfiguring port forwarding before leaving the house
06:29:12 <dons> good thing they backed down, otherwise Moggi was going to embrace, extend and conquer
06:29:13 <teehee> guess I'll just be reading thne.
06:30:51 <dons> sjanssen: i seem to have a lot of zombies around, is it possible 'spawn' isn't cleaning up properly?
06:30:57 <dons> no waitForProcess?
06:34:07 <dons> sjanssen: yes, spawn is giving rise to an army of zombies
06:35:38 <MarcWebe1> Saizan: Another option would be printing a message like "Makefile written" or documenting it ;) I'll ask at glasgow user mailinglist wether iths' worth filing a bug report. The documentation is only: -MGenerate dependency information suitable for use in a Makefile.
07:15:13 <sjanssen> dons: ah yes, I forgot to mark that as a todo
07:15:34 <sjanssen> dons: dwm does some kind of double fork() thing that I don't quite understand
07:18:19 <quicksilver> sjanssen: double fork is how you avoid zombies
07:21:39 * sjanssen goes to figure out how the fork in the standard libs works
07:22:28 <hpaste>  kuribas annotated "cond " with "cond using ternary operator" at http://hpaste.org/956#a1
07:23:53 <eulero> @seen dons
07:23:54 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 18m 58s ago.
07:24:22 <quicksilver> sjanssen: http://www.eng.cam.ac.uk/help/tpl/unix/fork.html
07:24:24 <lambdabot> Title: Cambridge University Engineering Department - Fork and Exec
07:24:28 <quicksilver> sjanssen: is a reasonably clear explanation
07:24:37 <quicksilver> sjanssen: the double fork is at the bottom
07:25:41 <sjanssen> thanks
07:26:06 <mux> double fork() is a method from the past
07:26:11 <mux> there are better ways to achieve that
07:26:30 <sjanssen> mux: oh?  anything that might be in the standard libs?
07:26:49 <mux> sigaction() and SA_NOCLDWAIT
07:26:55 <mux> no idea if you can use that in Haskell
07:27:47 <sjanssen> it's simpler to double fork
07:27:47 <mux> I should say that even without that, it isn't hard to just properly wait() for children
07:28:08 <mux> simpler maybe, but I don't see what's so hard about the more correcct methods :)
07:28:27 <sjanssen> mux: it's annoying in a window manager
07:28:37 <mux> sjanssen: fork() is expensive
07:29:04 <mux> calling it two times just to avoid bothering with children processes is clearly wrong
07:29:30 <sjanssen> mux: the processes need to live beyond the original one
07:30:07 <mux> well that's yet another problem, and there are other more correct ways to handle this too :-)
07:30:28 <quicksilver> mux: fork() is really not very expensive
07:30:32 <quicksilver> mux: now you're in the past :)
07:30:37 <sjanssen> mux: do you have any pointers for me?  how would you do this?
07:30:44 <mux> fork() is still expensive, really
07:30:49 <quicksilver> mux: it's expensive if you were thinking of doing it 100 times a second, of course. But I doubt sjanssen is.
07:30:56 <mux> it's not because COW was invented that it removed all the overhead of fork()
07:31:11 <mux> it's still a system call, and it still has quite a lot of work to do
07:31:26 <quicksilver> but, who cares? that's premature optimisation
07:31:27 <mux> sjanssen: look for the daemon() function commonly found in the libc of modern OSes
07:31:31 <glguy> SA_NOCLDWAIT    If this bit is set when calling sigaction() for the SIGCHLD signal, the system will not create zombie processes when children of the calling process exit.  If the calling process subsequently issues a wait(2) (or equivalent), it blocks until all of the calling process's child processes terminate, and then returns a value of -1 with errno set to ECHILD.
07:31:37 <mux> premature optimization? no, it's correct usage of the POSIX APIs
07:31:46 <sjanssen> @hoogle daemon
07:31:47 <lambdabot> No matches found
07:32:05 <glguy> on openbsd: man 3 daemon
07:32:05 <mux> and daemon() is implemented quite easily with setsid() and closing fd's, IIRC
07:32:12 <pitecus> Isnt it annoying that Data.Set isnt a Functor?
07:32:30 <sjanssen> is there any substantial reason not to double fork?
07:32:43 <mux> I think I gave two already :-P
07:32:50 <sjanssen> I understand that it's a little icky, but it seems very practical from my perspective
07:32:51 <mux> but you're free to do it the way you want.
07:33:08 <sjanssen> which is the perspective of an application writer that doesn't want C bindings in his code
07:33:12 <mux> it wouldn't be the only program in the world that does things the wrong way, unfortunately
07:33:18 <quicksilver> mux: are you saying that double fork() is somehow 'not correct usage of POSIX APIs'? How so?
07:33:34 <glguy> hpaste uses sigaction somehow, dons added it
07:33:52 <mux> quicksilver: if you prefer, it is unnecessary expensive and semantically wrong
07:34:09 <mux> but I'm not willing to debate this for ages, I think I made my point already ;-) there's a reason SA_NOCLDWAIT was created
07:34:28 <quicksilver> mux: "unnecessarily expensive" is premature optimisation until it's been shown this is a performance issue for sjanssen's particular program
07:34:37 <sjanssen> mux: expensive isn't really an argument here.  The user will call this maybe every handful of minutes
07:34:45 <quicksilver> mux: and 'semantically wrong' is the part I'm trying to get more details from you on, because I don't understand why it is
07:34:47 * mux sighs and shrugs
07:34:48 <glguy> quicksilver: but semantically wrong is a matter of principal
07:34:54 <glguy> :)
07:35:06 <glguy> if you are just going to hack this thing together, why not just use ruby ;)
07:35:09 <mux> hey, I'm only pointing you at APIs that have been created for that very reason
07:35:19 <mux> if you guys don't want to use those, then fine :-)
07:35:30 <mux> I won't sue you :-)
07:35:58 <quicksilver> glguy: semantically wrong is an excellent argument if someone can explain exactly why it is?
07:36:12 <mux> quicksilver: calling fork() two times asks for two processes
07:36:23 <mux> when you only want one it's kind of obvious that it is semantically wrong
07:36:49 <glguy> Where is the documentation that double forking is right?
07:36:51 <mux> using SA_NOCLDWAIT is more precise and asks just for one wants
07:36:59 <glguy> I've never seen that before
07:37:03 <mux> that's all there is about it
07:37:38 <sjanssen> @hoogle sigaction
07:37:39 <lambdabot> No matches found
07:37:51 <mux> in sjanssen's case, using daemon() is really a perfect match
07:38:24 <mux> or maybe just setsid() if he just wants the process to stay longer than the parent
07:38:31 <mux> well, whatever
07:38:47 <quicksilver> glguy: double forking is the old fashioned way to do it, before the posix api introduced this solution
07:38:59 <mux> right
07:39:15 <mux> who's living in the past now? ;-)
07:39:31 <quicksilver> you were, when you tried to use performance as an argument :P
07:39:48 <quicksilver> that honestly isn't the right argument for this case
07:39:54 <mux> quicksilver: I couldn't know before hand that this was only called one time in a handful of minutes
07:40:03 <sjanssen> hey, setsid looks much simpler!
07:40:10 <mux> so I stand by what I said, and I believe it is a perfectly valid argument!
07:40:24 <mux> there's no need to impose more work on the system just to make code "simpler"
07:40:43 <mux> it's not just the problem of making your code slower, but you're somehow slowing the whole machine down by doing unnecessary forks
07:41:08 <mux> of course, to some extent, and in a probably un-measurable way
07:41:11 <Stinger> so we should all code asm ;)
07:41:13 <sjanssen> so, in the forked process I can just call setsid(); exec(); ?
07:41:18 * mux hits Stinger 
07:41:28 <mux> sjanssen: you should be able to do just this, yes
07:41:28 <sjanssen> @hoogle setsid
07:41:29 <lambdabot> No matches found
07:41:52 <sjanssen> huh, what is the purpose of the double fork then?
07:42:00 <sjanssen> that seems like a huge PITA
07:42:13 <mux> artefact from the past, as I said from the beginning :-)
07:42:39 <balsagoth> hey guys
07:43:26 <balsagoth> anyone can help me with compiling a software that use the package util
07:43:41 <balsagoth> it work on ghc6.4
07:44:05 <balsagoth> but with ghc6.6 i got an error
07:44:20 <balsagoth> sorry with my english
07:44:35 <Lemmih> 'util' is no more.
07:44:36 <mux> no problem; but could you show us the error? paste on hpaste.org
07:44:40 <mux> oh
07:46:22 <balsagoth> it's only one line
07:46:24 <balsagoth> ghc-6.6: unknown package: util
07:46:35 <mux> well, see what Lemmih said, it doesn't exist any more
07:46:44 <Lemmih> balsagoth: Find and remove '-package util'.
07:47:12 <balsagoth> i already do that
07:47:32 <kuribas> > let n = 1; True ? v = const v; False ? v = id in (n < 0) ? "negative" $ (n == 0) ? "zero" $  "positive"
07:47:36 <lambdabot>  "positive"
07:47:59 <Lemmih> balsagoth: Than you should have gotten another error.
07:48:18 <balsagoth> i already do that but i got other error, tell me only if that error is about util package
07:48:21 <balsagoth> ./HaLeX_tool/halex.hs:95:33: lexical error in string/character literal (UTF-8 decoding error)
07:48:25 <balsagoth> make: *** [halex] Error 1
07:49:23 <kuribas> Should I add this to the page on http://www.haskell.org/haskellwiki/Case ?
07:49:24 <lambdabot> Title: Case - HaskellWiki
07:49:48 <balsagoth> thx Lemmih, my portuguese is a lot better :)
07:50:42 <Lemmih> balsagoth: Open halex.hs at line 95 and fix the error.
07:59:00 <balsagoth> thanks again Lemmih
07:59:58 <pitecus> what does this syntax stand for: True ? v ??
08:01:08 <sjanssen> pitecus: I've never seen that before.  The code you're looking at probably defines some extra operators
08:01:09 <quicksilver> pitecus: ? and ?? are sometimes used as bizarre type variables, but they aren't part of haskell syntax as such
08:01:18 <quicksilver> pitecus: what'st he context?
08:02:00 <pitecus> quicksilver, kuribas pasted somethig like that, I'd never seen it before
08:03:03 <quicksilver> pitecus: he was defining a custom operator
08:03:15 <quicksilver> let a ? b = a + b in 3 ? 4 ? 5
08:03:18 <quicksilver> > let a ? b = a + b in 3 ? 4 ? 5
08:03:19 <lambdabot>  12
08:03:23 <quicksilver> magick!
08:03:48 <pitecus> Ah
08:04:09 <sjanssen> why do all the System.Process commands have to fork?
08:04:59 <quicksilver> >  let a ?$%!!? b = a : b in 1 ?$%!!? (2 ?$%!!? (3 ?$%!!? []))
08:05:01 <lambdabot>  [1,2,3]
08:05:22 <quicksilver> sjanssen: because that's how you make new processes under the unix model
08:07:40 <Zeroth|work> a radnom number from 1 to 55?
08:07:43 <Zeroth|work> > rand 1 55
08:07:43 <lambdabot>   Not in scope: `rand'
08:08:17 <quicksilver> Zeroth|work: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
08:08:19 <lambdabot> http://tinyurl.com/eu3xo
08:08:35 <Zeroth|work> quicksilver, I'm only interested in the random numbers, not really learning about it (yet) :-)
08:08:37 <sjanssen> quicksilver: I'd like non forking versions also
08:09:04 <quicksilver> Zeroth|work: that page tells you how to get random numbers :P
08:09:22 <quicksilver> sjanssen: there is no way, on a straight unix system, to make a new process without using fork()
08:09:37 <quicksilver> sjanssen: all processes except init are made by fork(0
08:09:41 <quicksilver> sjanssen: init is made by the kernel
08:09:57 <kuribas> quicksilver: No, (?) was is supposed to be like the ternary operator in C (test ? c : c1)
08:10:29 <kuribas> But with : replaced by $
08:10:45 <quicksilver> kuribas: yes I know I think it was just a syntactic question being raised :)
08:10:50 <sjanssen> quicksilver: yes, I understand this.  I'd like the convenience of System.Process with the power of forking myself (so I can call setsid() before exec)
08:11:01 <kuribas> quicksilver: Oh, I see.
08:11:06 <quicksilver> kuribas: I was explaining to pitecus simply that ? means whatever you want it to mean
08:11:16 <quicksilver> kuribas: rather than being some special syntax :)
08:11:24 <kuribas> yes
08:11:24 <quicksilver> sjanssen: ah *nod* I understand you now :)
08:11:33 <Igloo> sjanssen: Use System.Posix.Process
08:13:52 <sjanssen> Igloo: I suppose I can just stick "/bin/sh" in the front of my command :)
08:15:28 <mux> I guess Haskell has something like system() that does it for you
08:15:38 <mux> (and you most likely mean /bin/sh -c)
08:15:41 <sjanssen> mux: there is runCommand, but it forks
08:16:09 <mux> if you ever want to make something out of the command you ran, you need to fork() anyways
08:16:29 <sjanssen> mux: yes, but I need to call setsid() before forking
08:16:50 <mux> yes? I don't get the contradiction here
08:16:55 <quicksilver> I would have thought you needed to call it after forking, but before execing
08:17:02 <quicksilver> and therein lies a problem, perhaps?
08:17:02 <sjanssen> and it is quite pointless to setsid(), then exec in a forked process
08:17:10 <sjanssen> quicksilver: exactly
08:17:56 <sjanssen> sorry, I meant to say "call setsid() after forking"
08:18:27 <mux> sjanssen: what exactly do you want to accomplish?
08:19:49 <sjanssen> mux: start a process that will live after it's parent exits
08:20:20 <mux> fork() setsid() (or maybe daemon() depending on the kind of process you're creating)
08:20:47 <sjanssen> mux: yes, I know how to do it
08:20:53 <mux> and then execve() of course
08:21:04 <mux> I don't get the problem then :-)
08:21:22 <sjanssen> mux: but you see why it's a problem for me to use a library function that glosses over the forking part?
08:21:39 <mux> nope
08:22:10 <sjanssen> mux: you must do the setsid() after the fork, but before the exec
08:22:23 <mux> well yes, what's the problem with that?
08:23:01 <quicksilver> mux: that the library function combines the fork and exec and has no capability to execute arbitrary code between the two
08:23:05 <sjanssen> library function looks like: if fork() == 0 then exec(stuff)
08:23:21 <mux> ah, but who said to use that library function?
08:23:24 <sjanssen> mux: there is no possible way to use setsid with that high level library function
08:23:32 <mux> and even then, this is logical
08:24:07 <mux> system() is for running commands, *waiting for it to complete* and getting back the exit status
08:24:14 <mux> it would be pointless to setsid() in the child in that case
08:24:20 <mux> since the parent is going to wait for the child anyways...
08:24:32 <sjanssen> I'm not complaining about the library.
08:24:45 <sjanssen> just chatting about my solution as I go
08:24:56 <mux> there's no problem then? :-)
08:25:23 <sjanssen> and maybe grumbling because I have to type a couple characters like "sh" and "-c"
08:25:31 <mux> oki
08:26:01 <sjanssen> though, System.Process ought to have wrappers for this
08:26:14 <sjanssen> does Windows have similar issues with child processes?
08:27:48 <quicksilver> @src liftM
08:27:49 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:28:03 <quicksilver> @. undo src liftM
08:28:04 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
08:28:10 <quicksilver> @undo src liftM
08:28:10 <lambdabot> src liftM
08:28:14 <quicksilver> mutter
08:28:46 <quicksilver> :t \f m1 -> m1 >>= return.f
08:28:49 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
08:31:02 <quicksilver> @pl \f m1 -> m1 >>= return.f
08:31:03 <lambdabot> fmap
08:31:08 <quicksilver> grrr
08:31:16 <quicksilver> that's just wrong!
08:31:20 <quicksilver> bad lambdabot!
08:31:59 <sjanssen> @hackage unix
08:32:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unix
08:50:14 <arke> I'm BACK!
08:50:16 * arke is teehee from earler
08:54:19 <arke> ...
08:54:26 <arke> and I think I'm _slowly_ starting to get these monad things
08:58:37 <arke> Alrighty
08:58:39 <DynWind> arke: congrats!
08:58:45 <arke> for exercise, I'm trying to write my own tree monad
08:58:59 <arke> lets see how this goes
08:59:10 * arke will tackle State monad after I got this working
08:59:12 <glguy> what data type are you going to use?
08:59:24 <arke> I just wrote
08:59:29 <arke> data MyTree a = Leaf a | Branch (MyTree a) (MyTree a)
08:59:52 <arke> (yeah, I know, how stereotypical ... "MyTree" :P)
09:00:15 <sjanssen> arke: looks good.  hack away
09:00:44 <sjanssen> glguy asked because there are other trees that don't have monad instances
09:01:34 <arke> Ah.
09:06:35 <_simon> ls
09:10:38 <arke> aah yay, syntax errors :D
09:12:31 <arke> hmm, ok, parses correctly, no errors
09:12:39 <arke> now, what I haven't thought of ... how to test it ... :)
09:14:27 <SimonRC> arke: nah, if it compiles it'll work
09:14:42 <arke> heh
09:14:44 <arke> ok, cool
09:14:47 <arke> another thing I noticed
09:14:57 <arke> I just defined return and bind for it ... but I never actually say that its a monad.
09:15:03 <arke> I assume that I do have to do this somewhere
09:15:10 <quicksilver> yes
09:15:15 <malcolmw> @tell fasta patches pushed to cpphs today fix it such that your gensym example b##__LINE__ now works
09:15:16 <lambdabot> Consider it noted.
09:15:17 <quicksilver> instance Monad MyTree where ....
09:15:37 <arke> thanks
09:15:40 * arke looks up instance
09:23:28 <ndm> malcolmw: would you be interested in having hscolour be provably total?
09:23:28 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
09:23:55 <ndm> malcolmw: i.e. accepting some patches (hopefully very few) which are a bit nonsense, but getting no crash messages ever afterwards
09:24:26 <ndm> MarcWeber: no, hoogle is GHC 6.4 only - although i do mean to update when i get a chance
09:24:37 <malcolmw> ndm: didn't we make some parts total the other day by adding cases for the empty list?
09:24:51 <mux> is Parsec's maintainer still alive and active?
09:25:04 <ndm> malcolmw: we did, i was wondering if you were interested in other patches like that
09:25:27 <arke> hmm ... forgive me if this is a silly question, but either I haven't seen this mentioned so far, or I'm forgetful ... :D .... how can I add an overload (is that the correct term?) for show?
09:25:32 <ndm> nofib spectral is a bit of a letdown as a benchmark - they aren't interesting at all
09:25:37 <malcolmw> mux: Daan is working in a Microsoft product division in Redmond these days - I don't think he has much time for parsec maintenance
09:25:55 <ndm> arke: instance Show MyType where show MyType = "MyType"
09:26:11 <ndm> Microsoft has all the Hsakell developers...
09:26:31 <malcolmw> ndm: I don't see any harm in adding totality patches, unless they actually obscure the code to a significant degree
09:26:32 <arke> aah, that makes sense ... thanks :)
09:26:39 <mux> malcolmw: I'm wondering because I suggested adding a new combinator for Parsec on haskell-cafe, which seems to have received positive feedback; however I'm not sure what course of actions to take now
09:27:14 <ndm> malcolmw: thats unlikely, i hope...
09:27:21 <malcolmw> mux: do you have commit-access to the parsec repository?  if not, then bug someone who does to apply the patch for you
09:27:40 <ndm> mux: it needs to go through the proper libraries review process, yours was just an informal haskell-cafe discussion
09:27:44 <norpan> adding a new combinator sounds more than a patch
09:28:02 <norpan> of course, everything is a patch depending on how you define it
09:28:03 <mux> ndm: yeah I wanted to first discuss it this way
09:28:14 <ndm> mux: i.e. email libraries@ proposing it, create a trac ticket etc
09:28:18 <ndm> mux: fair enough
09:28:20 <mux> okay
09:28:21 <mux> thanks
09:28:27 <malcolmw> it should probably be applied to the HEAD, but not to ghc-6.6's branch
09:28:40 <sjanssen> mux: http://www.haskell.org/haskellwiki/Library_submissions
09:28:41 <lambdabot> Title: Library submissions - HaskellWiki
09:28:43 <mux> ndm: libraries@haskell.org ?
09:28:45 <mux> oh, great
09:28:48 <mux> sjanssen: thank you
09:29:07 <ndm> mux: yep
09:29:07 * arke puts ghci aside for a few hours, got a few errands to run
09:29:11 <arke> but I got questions once I come back :D
09:29:16 <arke> thanks for being helpful
09:29:17 * arke is off
09:29:37 <kowey> speaking of maintainers, is there anybody here that would be willing to look after YAHT?
09:29:55 <glguy> mux: what combinator?
09:29:55 <norpan> does it need looking after?
09:30:17 <kowey> it gets suggestions from time to time, and on rarer occasions, patches (tex)
09:34:06 <mux> glguy: pmaybe, some kind of option combinator that wraps the type in a Maybe type
09:34:07 <ndm> glguy: pmaybe
09:34:07 <kowey> there's also changes from the wikibook that need to integrated once in a while
09:34:07 <ndm> mux: i think calling it pmaybe is horrible, you really need a better name
09:34:07 <mux> ndm: I wholly agree
09:34:07 <ndm> optionMaybe
09:34:07 <mux> I couldn't find a better one yet :-)
09:34:07 <mux> hmmm
09:34:07 <ndm> mux: pick a good name before you start the patch process
09:34:07 <mux> yes
09:34:07 <ndm> naming is the hardest bit...
09:34:07 <mux> optionMaybe sounds nice
09:34:07 <mux> ndm: don't tell me ;-)
09:34:07 <rashakil> kowey: sure
09:34:07 <glguy> mux: optionalMaybe p = option Nothing (fmap Just p) -- ?
09:34:07 <mux> glguy: I wrote it this way:
09:34:07 <mux> pmaybe :: GenParser tok st a -> GenParser tok st (Maybe a)
09:34:07 <mux> pmaybe p = option Nothing (p >>= return . Just)
09:34:07 <kowey> rashakil: do you have an account on darcs.haskell.org?
09:34:07 <mux> but that's the same I guess
09:34:07 <rashakil> kowey: no
09:34:07 <glguy> mux: eww :-p >>= return .    is a DrHaskell error
09:34:07 <ndm> kowey: i thought it was being moved into a wiki?
09:34:07 <kowey> ndm: there's two versions: the wiki one and the PDF one
09:34:07 <mux> glguy: can you expand on that a bit? whats DrHaskell? :)
09:34:07 <ndm> glguy: does DrHaskell still work? Yhc.Core has changed a bit since i last touched it...
09:34:07 <ndm> @where drhaskell
09:34:07 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
09:34:07 <ndm> it could really do with a proper maintainer
09:34:07 <glguy> ndm: I have no idea, I just know that it is one of the things that it detected
09:34:07 <kowey> ndm: the PDF one takes patches to TeX and is occasionally fed by changes to the wiki one
09:34:07 <ndm> @where+ http://www-users.cs.york.ac.uk/~ndm/projects/drhaskell.php
09:34:07 <lambdabot> Done.
09:34:07 <glguy> ndm: ...
09:34:07 <ndm> glguy: you can replace that with liftM, it was a patch from my office mate
09:34:07 <mux> so what's wrong with return . ? :-)
09:34:07 <ndm> glguy: i'm not totally convinced that you should though, sometimes >>= return . is nicer
09:34:08 <chessguy> ?where+ drhaskell http://www-users.cs.york.ac.uk/~ndm/projects/drhaskell.php
09:34:08 <lambdabot> Done.
11:34:14 --- topic: '["The Haskell programming language: what monads have you written?","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
11:34:14 --- topic: set by dons on [Tue Mar 13 00:36:18 2007]
11:34:14 --- names: list (clog ArthurClemens dgoldsmith segphault flux- beelsebob GeoBesh __xs__ Pastorn cantadou kattana_ merus FZ MarcWebe1 lordrat yuesefa pafcu mrchebas the_dormant alexj potts BCoppens [dlh] seancorfield thorkilnaur nominolo benny Gu1 SyntaxNinja prb_ psi crathman bluestorm_ chessguy kombinator ndm tarantoga george progexp cjeris iblechbot CosmicRay erider sm arjanoosting_ falseep matthew-_ rzoz prb triplah_ waern jfoutz opqdonut Pupeno4 mattrepl)
11:34:14 --- names: list (trez atsampson lekro rashakil__ der_eq_ calvins Uncountable Nshag diffbavis kscaldef_ ergot Igloo jtoy tizoc[w] kpreid fabiim Khisanth twanvl miez Averell ikegami-- dfeuer dolio der_igel bolrod Adamant doserj nomeata Cheery JaffaCake tizoc ozo_ goban astrolabe therp Shurique DRMacIver notsmack arke Ademan ramkrsna Jaak gour cpfr dblog Nioate ludwig- kpk ohub mattam qwr Shoragan lambdabot integral Eelis Spark lucca scw noj desp Shimei cognominal)
11:34:14 --- names: list (_roconnor witten earthy mauke falconair slipstream perspectival znephf Knio liyang Vq^ mathrick MikeJS takuan_dozo wilx gvdm_other subbot @ChanServ Laney Tychom shapr quicksilver Philippa_ araujo jre2 jgrimes Ytinasni pitecus JohnMeacham gal_bolle augustss Lemmih sometwo nich_ mbishop dibblego Forn Saizan Plareplane bos_ Muad_Dib ohmega _jcrigby dcoutts_ tessier_ dmwit woggle abz tmoertel_away mightybyte allbery_b ClaudiusMaximus oklopol)
11:34:14 --- names: list (Daveman tuukkah Narrenschiff Botje Nanar ski PupenoR lispy blackdog_ nattfodd nnunley yosemite Codex_ jmob SimonRC dons resiak jdev kosmikus eno ski_ gaal SamB Nafai petekaz michiel mlh kaol starfruit jcreigh vincenz halassocracy Cale nornagon Krunch__ laz0r cjay greenrd Baughn eyck caustiq cmeme fnordus sabakas1 arvid ozone QtPlatypus hpaste kalven psykotic profmakx Ugarte dany2k mornfall moonlite ToRA sieni bohanlon` ctkrohn lokam dino-)
11:34:14 --- names: list (jethrotcs saccade audreyt drbean xian Tanuk- dvekravy Magical1 matthew_- bohanlon df__ Wallbraker norpan kzm kolmodin Hirvinen dylan rycee bdash levitation[A] Poeir_ newsham nothingmuch dufflebunk dinounix alch` rahikkala bd_ DynWind arcasin wolverian gdsx tWip Syzygy- emu yogan rey_ Lunchy kc5tja magagr ibid tero- benja_ aking delamon sjanssen Odd_Bloke edwinb Mitar ray kirkeby felipe gds Slarba encryptio orbitz arcatan Altair^ Lamperi)
11:34:14 --- names: list (thedward jbalint Lunar^ glguy Eidolos TSC mux pejo ulfdoz Japsu grumpy_old_one shachaf rafl jyasskin-away ksandstr lupo__ zbrown Korollary michaelw cameron osfameron cods)
11:35:07 <Pastorn> oh! now i see it, the value in the list decides how far down the column you should take your number
11:35:09 <sjanssen> ohh, I see it
11:36:30 <Pastorn> but why does matrix #1 look like et does compared with matrix #3? why isn't the third (or second element for that matter) in matrix #3 0?
11:36:50 <glguy> the rows always start filling up with 0
11:36:55 <glguy> err
11:36:57 <glguy> the columns do
11:37:30 <Pastorn> oh, so everything is always done from the top?
11:37:34 <glguy> yeah
11:37:44 <glguy> at least in this attempt at figuring out a clean solution
11:37:46 <cantadou> Jag vill bikta mig, Pastorn!
11:37:58 <Pastorn> cantadou: jag r inte registrerad p freenode, kom till #h4xx0r
11:38:44 <Pastorn> glguy: what's wrong with transpose?
11:39:49 <sjanssen> glguy: I see an O(n log n) solution with a Data.FingerTree (or any binary tree would do)
11:39:50 <chessguy> cantadou, Pastorn, this is an english channel
11:40:02 <glguy> sjanssen: hint?
11:40:46 <sjanssen> glguy: you start with a balanced tree of size n, and you mark all nodes "white"
11:41:07 <sjanssen> and as each row is touched you mark it "black"
11:41:39 <sjanssen> you tell the fingertree to keep track of how many black nodes there are
11:43:22 <sjanssen> then when you want to insert something at i, you split the tree at i, retrieve the number of black nodes to the left of i, and the number for that row is i - blackNodeCount
11:43:40 <sjanssen> the binary tree algorithm is similar
11:44:10 <glguy> I'll play with it
11:44:19 <sjanssen> glguy: what do you need this for?
11:44:22 <glguy> I tried drawing it out as a tree earlier but must have screwed up
11:44:33 <glguy> sjanssen: sample question for a midterm
11:44:41 <glguy> that I'm not *seeing*
11:45:23 <sjanssen> glguy: this sounds like a fun class, what is it?
11:45:32 <glguy> computational geometry
11:45:51 <sjanssen> hmm, usually I suck at computational geometry
11:46:06 <alexj> @hpaste
11:46:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:46:55 <hpaste>  alexj pasted "instance issue with hlist experiment" at http://hpaste.org/961
11:47:09 <encryptio> @pl \a b c d -> (a-b)-(c-d)
11:47:10 <lambdabot> flip flip (-) . (((.) . (.) . (-)) .) . (-)
11:47:19 <sjanssen> glguy: the lines only go to the right?
11:47:22 <encryptio> @pl \a b c d -> (c-d)-(a-b)
11:47:23 <lambdabot> (flip (flip . ((-) .) . (-)) .) . (-)
11:47:24 <alexj> ghc says that I can't do that.
11:48:02 <glguy> sjanssen: I've reduced the problem to having two parallel lines, and I know the order that they cross the first line, and I know the order that they cross the second
11:48:02 <alexj> ghc says "No instance for (JSet MyLabel [Char] JNil obj2)" but my declared instance is actualy more general.
11:48:21 <alexj> am I being dense?
11:48:40 <sjanssen> alexj: sounds like you need a functional dependency
11:48:47 <sjanssen> MPTCs are practically
11:48:54 <sjanssen> useless without them
11:49:19 <alexj> worked!
11:49:27 <alexj> sjanssen: thanx!
11:49:39 <chessguy> sjanssen's on a roll today
11:50:00 <alexj> making hlist inspired JSON implementation.
11:50:02 <sjanssen> chessguy: do you want to see a solution if I write it up?
11:50:12 <chessguy> hm? solution to what?
11:50:29 <sjanssen> your mystery function above
11:50:42 <chessguy> i think you mean glguy
11:50:55 <glguy> sjanssen: that's ok, I think I can take it from here :)
11:51:06 <sjanssen> chessguy: oh, whatever am I doing?
11:51:11 <sjanssen> my apologies
11:51:21 <chessguy> sjanssen, quite alright :)
11:54:47 * shapr flings deleted cookies at chessguy 
11:55:03 <hpaste>  alexj annotated "instance issue with hlist experiment" with "json Functional dependencies conflict between instance declarations" at http://hpaste.org/961#a1
11:55:05 * chessguy eats them
11:55:17 * chessguy looks for a glass of milk
11:55:57 <chessguy> @quote shapr
11:55:58 <lambdabot> shapr says: I dare you to call a substructural type system obvious anywhere outside of #haskell.
11:56:24 <alexj> sjanssen: do you know what conflicitng functional dependencies mean?
11:56:29 <dolio> Is there an #epigram? :)
11:59:14 <sjanssen> alexj: it means that you've written instances such that your functional dependency isn't true
11:59:28 <Pastorn> @hoogle Word
11:59:29 <lambdabot> Data.Word :: module
11:59:29 <lambdabot> Data.Word.Word :: data Word
11:59:29 <lambdabot> System.Win32.Types.WORD :: type WORD
11:59:40 <Pastorn> ?src Data.Word
11:59:41 <lambdabot> Source not found. You type like i drive.
11:59:55 <sjanssen> alexj: in this example, it's because ghc doesn't know that LLT an LGT are opposites
12:00:25 <alexj> why does it need to know? or how do I tell it?
12:01:23 <Pastorn> should i implemet a binary value as a Bool or is there something i can use?
12:01:37 <alexj> I just tested and you are right.  as long as I do any one of EQ LLT or LGT it compiles.  but if I do more than one it breaks.
12:01:38 <sjanssen> alexj: your fundep says: "for any choice of label el obj, there is exactly one possible type for obj2"
12:02:02 <dolio> Pastorn: If you want something more descriptive, you could use something like 'data Foo = Bar | Baz'
12:02:08 <alexj> so?
12:02:22 <dolio> Name them whatever descriptive values would be appropriate for your binary values.
12:02:32 <Pastorn> True, I just figured that there might have been a Word1
12:02:51 <alexj> sjanssen: isn't that true?
12:03:13 <sjanssen> alexj: in ghc's eyes, those three instances look incompatible.  They all share the same patterns for "label el obj"
12:04:26 <alexj> is there an obvious fix that I am missing or am I attempting something ghc doesn't do?
12:05:00 <sjanssen> I don't think there's an immediate fix.  You probably have to do some restructuring
12:05:08 <alexj> hmm ok.
12:05:29 <alexj> I need a different type for each instance?
12:06:58 <sjanssen> or something
12:14:04 <hpaste>  ramas annotated "lempa" with "(no title)" at http://hpaste.org/962#a1
12:16:36 <jyasskin> alexj: http://okmij.org/ftp/Haskell/typecast.html#is-function-type claims to do something like what you want. I don't understand it though.
12:16:37 <lambdabot> Title: Type improvement constraint
12:19:54 <alexj> jyasskin: that looks like what I want but I don't think I understand it either.
12:21:44 <jyasskin> Haskell typeclasses are like C++ templates: You can do anything with them, but it'll make your code unreadable.
12:22:24 <kc5tja> I rather think that typeclasses are nothing like templates, but like COM class definitions instead.
12:22:46 <kc5tja> Instances correspond to COM interfaces almost exactly.
12:32:14 <alexj> jyasskin: worked!  thank you!
12:32:20 <chessguy> typeclasses aren't that bad
12:32:55 <chessguy> Cale, ping
12:33:11 <alexj> now the open question is whether to force the user to use a different function to replace vs insert
12:34:04 <alexj> similarly whether delete should cause a typeerror if the label isn't present.
12:36:17 <hpaste>  sjanssen annotated "Needing ideas for efficiency" with "O(n log n)" at http://hpaste.org/960#a1
12:36:45 <dolio> Typeclasses only get ugly when you start doing type-level programming with them.
12:37:27 <dolio> Although they can make your type declarations (and therefore error messages) ugly before that.
12:42:24 * kc5tja rather likes the idea of typeclasses.
12:42:51 <dolio> ?type fmap show . liftM2 (+) sum length
12:42:54 <lambdabot>     Couldn't match expected type `f a' against inferred type `Int'
12:42:54 <lambdabot>     In the third argument of `liftM2', namely `length'
12:43:37 <sjanssen> ?type fmap show $ liftM2 (+) sum length
12:43:39 <lambdabot> [Int] -> String
12:43:45 <sjanssen> ?type show . liftM2 (+) sum length
12:43:48 <lambdabot> [Int] -> String
12:44:37 <sjanssen> dolio: (.) = fmap
12:49:45 <shapr> dolio: There was an #epigram, don't know if anyone still uses it.
12:49:54 <shapr> dolio: Had about ten people there for awhile.
12:49:55 <dolio> :) I checked, and there wasn't.
12:50:25 <dolio> So announching that substructural type systems are obvious there seemed rather pointless.
12:50:38 <shapr> heh
12:51:00 <shapr> I started #epigram, but it never really took off.
12:52:06 <ohmega> epigram!
12:52:22 <ohmega> shapr: are you playing with that? :)
12:52:34 <Cheery> is there a function for continuously polling something until you catch some desired thing? then giving the stuff you caught during that thing as a list?
12:54:48 <sjanssen> Cheery: you want something in the IO monad?
12:55:41 <Cheery> well, I'd like to process input with Graphics.UI.SDL.pollEvent
12:55:58 <Cheery> pollevent :: IO Event
12:56:13 <sjanssen> Cheery: there isn't to any such function, but it'd be easy to write
12:56:50 <Cheery> I've already written it. :)
13:00:43 <dolio> ?type (fmap show .) . liftM2 (+)
13:00:46 <lambdabot> forall a1 (m :: * -> *). (Functor m, Num a1, Monad m) => m a1 -> m a1 -> m String
13:02:38 <shapr> ohmega: I used to play with Epigram, but it's been awhile.
13:02:49 <shapr> ohmega: Hey, don't I owe you for those t-shirts?
13:03:48 <shapr> ohmega: Oh hey, I met a native Alabama cashier who spoke Swedish to me when she saw my Enhjulingsfolket t-shirt!
13:08:58 <dataangel> I've seen a lot of examples of how to write an infinite length list of fibbonaci numbers, but how would you write an infinite length list of factorials? i.e. the first element is 0!, then 1!, 2!, 3!, etc. I can make a function to do this rather easily but it's not obvious to me how to make a list :/
13:09:27 <dolio> > scanl (*) 1 [1..]
13:09:29 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
13:09:34 <shapr> peti: Hiya! long time no see! How's code?
13:09:36 <Botje> dammit. dolio was too fast :[
13:09:56 <glguy> > scanl1 (*) [1..]
13:09:57 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
13:10:09 <glguy> I guess 0! is 1 :( nvm
13:10:18 <Botje> only by convention.
13:10:24 <Botje> I say it's forty-three
13:10:53 <dolio> Doesn't that make 1! 43 as well? :)
13:10:59 <dataangel> some important things break down if 0! is not 1 :)
13:11:15 <peti> shapr: Hi! Indeed, it's been a while. I'm coding professionally these days, I finally got a job. ;-) As a result, I don't write much in my spare time anymore. It's a shame really, but I don't want to sit in front of a computer all day.
13:11:22 <peti> shapr: How are you doing?
13:11:45 <dataangel> stupid puzzle: Use five 0s to make the number 125
13:12:02 <sjanssen> 0 + 0 + 0 + 0 + 0 + 125
13:12:12 <dataangel> only five 0s
13:12:17 <dataangel> no other constants
13:12:34 <dataangel> ;p
13:13:00 <sjanssen> (0!+0!)*(0!+0!)+0!
13:13:02 <dolio> ((0! + 0!) + 0!)^(0! + 0!)?
13:13:10 <shapr> ooh, I like -fprint-bind-result in ghci
13:13:19 <dolio> Oops, that's not right.
13:13:27 <shapr> peti: Cool! Glad you got a coding job. I'm doing Haskell professionally! It's great fun!
13:13:29 <sjanssen> shapr: and some people really hate it :)
13:13:41 <dolio> I missed a !, and it's still not what I was thinking. :)
13:14:19 <peti> shapr: Count your blessings. I have to write C++, and a very old-fashioned style at that. Anyway, I get paid, that's the important part. :-)
13:14:23 <dataangel> sjannsen: That makes 5, (1+1)*(1+1) + 1
13:14:49 <sjanssen> duh, why did I make 5?
13:15:03 <sjanssen> for some reason I decided 5 is better
13:15:10 <dataangel> ;p
13:15:22 <chessguy> shapr, you should see some of the cool projects Aetion is doing in haskell
13:15:35 <shapr> chessguy: I've heard about a few of them.
13:15:42 <dataangel> whoops, the number is 120 :p
13:16:04 <chessguy> 3-d molecule modelling, analysis of video footage of terrorists, very cool
13:16:09 <dolio> Oh, well, 120 is easier. :)
13:16:13 <dataangel> yes :)
13:16:15 <mauke> just add !
13:16:21 <shapr> peti: I used to do a bunch of Python for uni-erlangen... but that got too painful.
13:16:24 <dataangel> (0! + 0! + 0! + 0! + 0!)!
13:18:45 <peti> shapr: By the way, I finally got that SP arrow right I've struggled with for the last couple of years. At last it has the same performance as the monadic code. I notice there is much going on in terms of I/O library on the lists these days. It would be kinda nice to contribute at least a description of the code. It's a shame the article never made it into Monad.Reader. Anyway, software is never ready on time, thas's a fundament
13:18:45 <peti> al problem.
13:19:08 <shapr> peti: I'd like to see that code!
13:19:42 <peti> shapr: I can e-mail it to you. It's quite short. What's your address again?
13:20:25 <shapr> peti: shae@ScannedInAvian.com
13:20:35 <shapr> Just renewed that domain.
13:20:52 <shapr> peti: Any new dev on Postmaster?
13:22:38 <chessguy> what are lisp macros? is there an equivalent in haskell?
13:22:59 <shapr> chessguy: Er, lisp macros are sort of like Template Haskell, but they do more stuff, and are not type checked.
13:23:05 <peti> shapr: You've got mail. :-) I'm a little torn on Postmaster. To be honest, about 90% of the stuff the daemon does is system programming, and that's actually easier in C than in Haskell. I'd like the program to be used, eventually, so I don't want to create any barriers by choosing a language that people can't compile (and patch). If there is another release, it will be a C version. It's the Haskell design though.
13:23:30 <xs> peti, SP arrow from john hughes' AFP lectures?
13:23:37 <shapr> chessguy: Things like non-strictness and higher order functions cover much of the usefulness of Lisp macros, imho.
13:24:06 <opqdonut> chessguy: see liskell
13:24:15 <peti> XS: Yes. I modified to work with monad computations instead of pure ones (there's no point in doing pure code as Arrows). It's nice for I/O code because it's hard to produce resource leaks.
13:24:16 <shapr> peti: A pure Haskell OS is getting closer to reality. Have you seen the recent dev on House?
13:25:04 <shapr> Grr, my postfix is broken.. I should switch to Postmaster.
13:25:04 <xs> peti, iirc, that SP implementation has a very nasty space leak in its left operator. did you fix that?
13:25:23 * SamB wonders why the "Accidental Centaurs" article on wikipedia was deleted...
13:26:17 <peti> XS: Yes, my SP arrow is not an instance of MonadChoice. ;-)
13:26:39 <peti> Uh, ArrowChoice, that is.
13:27:25 <xs> ah :)
13:28:29 <peti> shapr: It would be nice to have a Haskell smtpd, no doubt, but it's just too much effort ... for me, at least. Writing network code is no fun yet, a lot of stuff is missing.
13:28:38 <shapr> Like what?
13:29:01 <shapr> Did you see the HaskellNet project from last year's SoC?
13:30:10 <peti> SSL/TLS, for instance, is a major effort to implement. Using Boost.Asio, I can do that almost with a single typedef. IPv6 support is also non-standard. I don't know, 70% of Postmaster's code is glue code to do FFI.
13:30:43 <peti> shapr: No, I didn't see that. I notice there's a lot going on though, I recently stumbled across the unified library that is based on epoll(). Very nice.
13:31:07 <shapr> peti: Einar Karttunen's Network.Alt has IPv6 support.
13:31:41 <shapr> But you're the second person to ask me about Haskell SSL/TLS support in the last week. Now I know what project I want to mentor for SoC :-)
13:31:56 <peti> shapr: I didn't look at that yet. I only saw that a guy submitted support for getaddrinfo() to the standard library. That would solve most of the problems.
13:32:18 <dylan> hmm, do I want to go gentoo or debian on my ppc laptop...
13:32:27 <peti> shapr: You'll mentor a project? Very cool. :-)
13:32:53 <alexj> peti: happs actually provides a trivial smptd implementation in demos (though it may not be up to date)
13:33:17 <alexj> needs ssl
13:33:19 <shapr> peti: I was mentor for HaskellNet last year, it turned out quite well.
13:33:28 <shapr> dylan: Ubuntu!
13:33:45 <dylan> shapr: no, ubuntu is going to drop support for ppc.
13:33:48 <Cale> chessguy: pong
13:33:53 <Nafai> shapr: Are you using Ubuntu now?
13:33:58 <shapr> dylan: Oh :-(
13:34:04 <shapr> Nafai: Nah, but I'm considering the switch.
13:34:05 <peti> alexj: My experience is that a running prototype of a network daemon is quite simple to write in Haskell. My perception was, howeve,r that going from there to a production-ready network daemon is still a long way.
13:34:23 <dylan> shapr: debian is also ... incapable of dual-booting on this machine.
13:34:32 <peti> shapr: What kind of project did you mentor?
13:34:33 <shapr> peti: Have you checked out HAppS? It has some very nifty infrastructure.
13:34:40 <Nafai> dylan: What machine?
13:34:49 <peti> shapr: I looked at it, yes.
13:34:51 <shapr> peti: I asked Jun Mukai to write a bunch of missing network libs.
13:34:51 <dylan> Nafai: powerbook G4, 12"
13:35:00 <shapr> peti: Any comments on HAppS?
13:35:02 <Nafai> dylan: I had debian and OS X dual booting on my old Powerbook Pismo
13:35:16 <dylan> Nafai: it's specifically this version.
13:35:29 <dylan> Nafai: mac-fdisk doesn't see the HFS+ partitions.
13:35:33 <Nafai> That sucks
13:35:42 <dylan> yes. Also suspend to ram won't work.
13:35:56 <dylan> but, suspend to ram is less important than a package management system!
13:36:22 <shapr> peti: http://darcs.haskell.org/SoC/haskellnet/
13:36:24 <lambdabot> Title: Index of /SoC/haskellnet
13:36:25 <dylan> I have three versions of perl and two versions of python installed, for instance.
13:36:33 <peti> shapr: I guess I should refrain from commenting. I'm not really qualified; I didn't look at the library in detail.
13:36:41 <sjanssen> dylan: I made the same decision for my MacBook
13:36:50 <sjanssen> I got really tired of macports
13:37:12 <dylan> sjanssen: yes. darwinports + fink is nasty
13:37:21 <dylan> but I need fink to get a working X11 server.
13:38:07 <dylan> I'm just debating between gentoo (never used it for more than a month) and debian (= very used to it)
13:38:20 <sjanssen> I'm probably weird.  I went from loving OS X to being a Gentoo and dwm user
13:38:25 <dino-> Yay, debian
13:38:37 <dylan> I'm running dwm on my mac right now...
13:38:39 <shapr> peti: Well, I'd like to hear your opinion on HAppS.
13:38:45 <nnunley> Gentoo requires a great deal of patience.
13:38:48 <trez> dwm is nice :)
13:38:49 <peti> shapr: The haskellnet repostory looks interesting. I've never seen anyone actually use GNU TLS ...
13:38:51 <shapr> I'm using wmii, I think.
13:39:17 <dylan> how's cabel<->portage integration?
13:39:32 <dylan> is it as nice as cabel<->apt?
13:39:42 <sjanssen> shapr: wmii is the past.  Use xmonad!
13:40:12 <Lamperi> ratpoison on mac :p
13:40:15 <Nafai> dylan: What integration is there between cabal and apt?
13:40:23 <peti> shapr: My impression was that HAppS is a little convoluted. My gut reaction when I saw it was: "Huh? That ought to be a lot simpler." It's just a vague feeling though.
13:40:29 <dylan> Nafai: it's trivial to make a .deb from a cabalized project?
13:40:33 <sjanssen> dylan: the gentoo-haskell team runs a portage overlay that has tons of Haskell software
13:40:36 <Lamperi> even simplier than dwm
13:40:46 <Nafai> dylan: Ah, cool.
13:42:02 <dylan> hmm, I see gentoo has a proper surfraw package
13:42:09 <dylan> unlike darwinports...
13:42:54 <dylan> well, I'll give this a try.
13:42:57 <shapr> sjanssen: xmonad is the Haskell wm?
13:43:01 <shapr> @where xmonad
13:43:02 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
13:43:08 * shapr gets
13:43:47 <sjanssen> dylan: http://www.haskell.org/~gentoo/gentoo-haskell/dev-haskell/zlib/zlib-0.3.ebuild -- it is pretty easy to work with cabal packages in Gentoo
13:43:49 <lambdabot> http://tinyurl.com/2fa6vo
13:43:54 <peti> shapr: About the haskellnet repository, is there any advantage to Text.URI over the URI that's in the standard library?
13:44:00 <sjanssen> shapr: it isn't quite ready for prime time
13:44:12 <ArthurClemens> Using Text.Regex, how do I write a space character \s ? I get the error "lexical error in string/character literal at character '"'". With a double slash I get no results.
13:44:14 <sjanssen> shapr: you probably want to wait a week or two
13:44:37 <peti> ArthurClemens: Did you try '\\s' or '\s'?
13:44:45 <ArthurClemens> both
13:44:49 <shapr> peti: I don't remember about Text.URI, I'll look at it when I get a chance.
13:44:57 <ArthurClemens> do you mean single quotes?
13:45:16 <mauke> ArthurClemens: are you sure Text.Regex supports \s?
13:45:20 <peti> ArthurClemens: No, they won't work for strings. :-)
13:45:31 <ArthurClemens> no...
13:46:16 <mauke> \s is a perl thing AFAIK
13:47:20 <ArthurClemens> alright, [[:space:]] works
13:47:26 <DRMacIver> Oh dear. Haskell's regexp libraries don't use string literals for regexps do they?
13:47:35 <mauke> and it even includes \v!
13:47:46 <mauke> DRMacIver: no, just strings
13:47:49 <ArthurClemens> or I have to unlearn a lot :-(
13:48:14 <DRMacIver> mauke: What I mean is, do they construct the regexps as strings?
13:48:22 <sjanssen> DRMacIver: there isn't special syntax if that's what you mean
13:48:30 <DRMacIver> Ugh
13:48:42 <DRMacIver> I mean, I know there's not going to be native regexp support.
13:48:49 * sjanssen doesn't understand the obsession with regular expressions
13:48:56 <DRMacIver> But you can surely do something sane with combinators
13:49:03 <dolio> > let calc :: Int -> Double -> Double ; calc i d = fromIntegral i * d in calc 1 2.0
13:49:04 <lambdabot>  2.0
13:49:19 <ArthurClemens> sjanssen: wait until you have to plough through texts
13:49:21 <peti> DRMacIver: You can. Noone prohibits constructing a regular expression string using combinators.
13:49:33 <DRMacIver> peti: That's clearly bass ackwards.
13:49:41 <DRMacIver> Anything which constructs code as strings is a terrible idea.
13:49:46 <peti> DRMacIver: Why is that?
13:50:32 <IanYoung> Hello! Could anyone offer some style advice on a little program I'm writing?
13:50:36 <DRMacIver> peti: There's this little thing called 'type safety' that I hear the cool kids are using these days. 'Catching errors at compile time' occasionally gets mentioned. I hear some languages like this sort of thing. Know any examples?
13:51:05 <dolio> Can you type check a regular expression?
13:51:18 <DRMacIver> dolio: Not if it's being constructed as a string you can't...
13:51:58 <peti> DRMacIver: You need compile-time type-checking for regular expressions?
13:52:13 <DRMacIver> peti: Yes.
13:52:35 <mauke> haskell's regex libs are unusable anyway
13:52:44 <peti> DRMacIver: What kind of errors would those compile-time checks catch that compiling the regex from a string won't?
13:52:45 <dolio> What is there to type check even if it isn't a string?
13:53:01 <DRMacIver> dolio: Well, it's more syntax than type checking.
13:53:08 <dolio> Would [[:space:]] be a type?
13:53:29 <DRMacIver> The type checking comment was on the more general subject of embedding code as strings.
13:53:44 <DRMacIver> peti: That you got the syntax right!
13:53:53 <thedward> DRMacIver: why not use a parser combinator library instead? like Parsec?
13:53:57 <DRMacIver> Additionally it solves the "Do I need to escape this string?" problem.
13:53:59 <dataangel> Is there a way to retrieve the last element of a list without coding my own homegrown recursive call of tail over and over? / if I'm tempted to use that am I probably coding haskell badly? :P
13:54:15 <nmessenger> > last [1..10]
13:54:17 <lambdabot>  10
13:54:28 <DRMacIver> thedward: Well I've no intention of using the regexp library. :)
13:54:31 <peti> DRMacIver: compiling the regular expression will check the syntax. And the compiling stage will also remove all unnecessary quotes, because the result of the compilation is a finite state machine.
13:55:06 <arke> Hi. :)
13:55:07 <DRMacIver> peti: Let me paraphrase. "It's ok that this isn't checked at compile time because it will be checked at runtime."
13:55:14 * arke is back and will now continue his studying of monads
13:55:26 <arke> to recap: I've successfully created my own tree monad, yay :D
13:55:39 <DRMacIver> The fact that you're compiling the regexps is irrelevant, because you're doing it after you compiled the rest of your program.
13:55:40 <peti> DRMacIver: You can compile a regular expression at compile-time, if you want. You write [| ... |] around the function call.
13:55:54 <ADEpt> IanYoung: dont ask to ask, just ask :)
13:56:08 * DRMacIver blinks
13:56:10 <DRMacIver> You do what?
13:56:20 <dolio> Use template haskell, apparently.
13:56:23 <nmessenger> Template Haskell
13:56:25 <DRMacIver> Oh
13:56:29 <IanYoung> ADEpt: sorry got distracted by something else!
13:56:30 <peti> DRMacIver: Template Haskell allows you to lift arbitrary computations to compile-time.
13:56:41 <peti> DRMacIver: Not just regular expressions.
13:56:45 <DRMacIver> Well, yes.
13:56:55 <DRMacIver> But last I checked we weren't talking about Template Haskell. :)
13:56:57 <IanYoung> Anyway, this program. it doesn't do much: just take csv input (`-separated really) and output some basic facts about field sizes, character frequencies in the fields, etc.
13:57:09 <DRMacIver> We were talking about a normal Haskell library which is doing something stupid.
13:57:23 <IanYoung> I'll paste it shall I? Yes
13:57:31 <hpaste>  IanYoung pasted "make charfreq better!" at http://hpaste.org/963
13:57:34 <DRMacIver> This isn't just be me being purist and irrational. I know first hand how much of a mess embedding code as strings causes because we do it all the damn time at work and it's a nightmare.
13:58:17 <mauke> it's just a wrapper around regex(3)
13:58:30 <IanYoung> Sorry the test data's a bit silly! Couldn't use real data.
13:58:34 <peti> DRMacIver: You agree that type-checking regular expressions is impossible unless the regular expression itself is compiled into the program, right? You can't check a regex you read from, say a configuration file, at compile-time.
13:59:41 <DRMacIver> peti: Sure. However I question the wisdom of including non-trivial regexps in configuration files. :)
14:00:12 <IanYoung> I've got to a stage where it works, but it's not exactly pretty and I'm wondering what I can make it more idiomatically Haskell
14:00:24 <ADEpt> IanYoung: just a short fix:
14:00:24 <ADEpt> loseNothing f a b = do
14:00:24 <ADEpt>   x <- a
14:00:24 <ADEpt>   y <- b
14:00:24 <ADEpt>   return $ f a b
14:00:25 <peti> DRMacIver: I feel this fact makes a string interface to the library a fairly sensible choice. If you have regexes that _are_ compiled into the program, then you are at liberty to add any number of data types and combinators that can be compiled into a string.
14:01:08 <Philippa_> peti: you can, however, make damn sure that regexes you read in conform to some notion of well-formedness
14:01:23 <dolio> > liftM2 (+) (Just 1) Nothing
14:01:24 <lambdabot>  Nothing
14:01:28 <peti> DRMacIver: Having (only) a typed interface to regular expressions, however, would be incredibly inconvenient if you ever want to compile a regular expression you get from the command line or whereever.
14:01:36 <dolio> > liftM2 (+) Nothing (Just 1)
14:01:38 <lambdabot>  Nothing
14:01:55 <mwc> Well, you could have a coerceRegex :: String -> Maybe Regex that would choke iff your string wasn't a valid regex
14:02:04 <mwc> but that's just Philippa_'s well-formedness notion
14:02:17 <Philippa_> the loosest form thereof, yeah
14:02:19 <DRMacIver> peti: I disagree. Having a "parse regexp" function and providing a type safe and compiled approach is clearly saner and leads to cleaner code.
14:02:30 <dataangel> Is there anyway to implement a list of factorials, 0!, 1!, 2!, etc. using a list comprehension instead of scanl?
14:02:49 <nmessenger> IanYoung: perhaps that massive tuple would be better suited as a record?
14:02:51 <peti> DRMacIver: You _have_ a "parse regex" function which will typecheck anything you give it. ;-)
14:03:20 <sjanssen> I tend to agree DRMacIver, aim for as much compile time assurance as possible
14:03:28 <sjanssen> it's the same argument I have against printf
14:03:43 <DRMacIver> peti: There's a word in the above sentence - 'and'. It implies a conjuction of two terms. :-p
14:03:48 <IanYoung> ADEpt: But won't that propagate the Nothing? Which wasn't what I wanted
14:03:50 <Philippa_> that, and it means stuff that's fixed at compile time is amenable to further optimisation because the optimiser doesn't have to parse everything before it gets to work
14:03:59 <sjanssen> the only problem is implementing this EDSL.  Syntax and typing can get very tricky
14:04:13 <mauke> > let x = 1 : zipWith (*) [1..] x in x
14:04:15 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
14:04:19 <IanYoung> nmessenger: Yeah, I thought that. I don't think Haskell had records last time I used it
14:04:25 <Philippa_> it's amazing what you can do with a few well-placed rules if you start with an AST rep in the first place
14:04:27 <peti> DRMacIver: Well, let's agree to disagree.
14:04:34 <Philippa_> or with a set of ready-to-run combinators
14:04:41 <sjanssen> IanYoung: yikes, when was the last time you used Haskell?
14:04:42 <DRMacIver> peti: I disagree that we need to agree to disagree. ;)
14:05:01 <dolio> > (\f a b -> msum [liftM2 f a b, a, b]) (+) (Just 1) Nothing
14:05:02 <lambdabot>  Just 1
14:05:05 <peti> DRMacIver: We probably don't need to, you are right. :-)
14:05:10 <dolio> > (\f a b -> msum [liftM2 f a b, a, b]) (+) Nothing (Just 1)
14:05:12 <lambdabot>  Just 1
14:05:18 <IanYoung> sjanssen: Kinda kidding, but I did use it in about 1991 for a brief while.
14:05:19 <DRMacIver> Oh well, just using parsec is probably better than regexps anyway. :)
14:05:27 <mux> parsec is hot
14:05:27 <mauke> > let x = 1 : [a*b | a <- x | b <- [1..]] in x
14:05:28 <lambdabot>  Parse error
14:05:31 <mauke> :(
14:05:45 <mux> we just need ParsecT and then we can call it parsex
14:05:50 <mwc> Really all that a regex is a programming language for a VM that's a string-matching NFA
14:05:52 <DRMacIver> Certainly for pure matching problems.
14:05:53 <mwc> or DFA
14:05:59 * peti thinks no parser library produces better error messages than Parsec. 
14:06:12 <mwc> so there's no point typechecking it
14:06:16 <DRMacIver> Yeah, I've been rather impressed by the default level of error reporting for parsec.
14:06:28 <nornagon> Hm, Regex "fo+d" <- "foooooooooood"
14:06:38 <mwc> since it's just a plain, simple, programming language
14:06:40 <nornagon> pattern matching hackery would be awesome
14:06:56 <DRMacIver> mwc: Well the type checking is really not the point here. That's more for other instances of embedding code as strings.
14:07:19 <Philippa_> embedding as a string always gives you performance hiccups though, it makes a parsing phase mandatory
14:07:32 <dataangel> Why can lists only be indexed by Ints and not Integers? Are haskell lists limited to C sizeof(int) in length?
14:07:46 <mwc> Philippa_, use TH to translate the string to an AST
14:07:47 <nornagon> Philippa_: could be done at compile-time
14:07:50 <mwc> or hell, directly to the DFA
14:07:51 <dolio> ?type genericIndex
14:07:53 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
14:07:55 <DRMacIver> The real problem here is mostly syntax screw ups. Particulary because embedding regexps as strings means you need to double escape, which makes them all too easy. :)
14:08:01 <IanYoung> dolio: Thanks (I think) -- I'd sort of figured out it was more MonadPlussy than Monady
14:08:02 <dmwit> > let x = 1 : [a*b | a <- x, b <- [1..]] in x
14:08:04 <lambdabot>  [1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:08:11 <shapr> Hey, HList equality question... if I want {y=2,x=1} to be equal to {x=1,y=2}, how can it be done?
14:08:39 <thedward> nornagon: have you seen HaRP? http://www.cs.chalmers.se/~d00nibro/harp/
14:08:41 <lambdabot> Title: Haskell Regular Patterns
14:08:42 <shapr> The only solution I've thought up is to use Template Haskell to turn the type names into Strings and then sort those, and require that the values are instances of Ord as well. Is there another approach?
14:09:04 <IanYoung> By the way, does the linesBy function in that paste have a canonical name?
14:09:15 <shapr> I guess the essential question is, what's the best way to do type level sorting?
14:09:16 <dolio> dataangel: I think the short answer is that Int is faster, and you'd have trouble actually using a list with more than (maxBound :: Int) elements.
14:09:25 <DRMacIver> thedward: That's rather cool.
14:09:48 <thedward> DRMacIver: yeah, too bad it requires a preprocessor. I'm not even sure if it works with ghc 6.6
14:09:49 <dolio> dataangel: And you can otherwise use genericIndex. Some people advocate making (!!) into genericIndex, though.
14:10:23 <dolio> And switching related functions appropriately.
14:10:25 * shapr pokes Philippa_ 
14:10:27 <hpaste>  glguy annotated "Needing ideas for efficiency" with "first run" at http://hpaste.org/960#a2
14:10:29 <sjanssen> shapr: you should normalize the record value pairs somehow (ie. put them in a sorted list)
14:10:30 <shapr> Philippa_: Any thoughts on type level sorting?
14:10:30 <nmessenger> > let p = (==' ') in unfoldr (let f [] = Nothing; f xs = Just (second (drop 1) $ break p xs) in f) "foo bar baz"
14:10:32 <lambdabot>  ["foo","bar","baz"]
14:10:34 <glguy> ?seen sjanssen
14:10:34 <lambdabot> sjanssen is in #ghc, #haskell-overflow, #gentoo-haskell and #haskell. I last heard sjanssen speak 4s ago.
14:10:40 <dataangel> dolio: I was just seeing if I could make that factorial list with a list comprehension and saw that this worked if fact2 was defined as [Int] but not [Integer] -- fact2 = 1 : [c * (last 1 (take c fact2)) | c <- [1..]]
14:10:41 <sjanssen> shapr: insertion sort should be easy
14:10:45 <sjanssen> yo, glguy
14:10:57 <glguy> sjanssen: I had some time to play with that tree finally, is that paste what you envisioned?
14:11:01 <dolio> ?genericTake
14:11:01 <lambdabot> Unknown command, try @list
14:11:05 <dolio> ?type genericTake
14:11:07 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
14:11:07 <shapr> sjanssen: But HList values are heterogenous...
14:11:11 <dataangel> dolio: Err, well first I tried with c * (fact2 !! (c-1)) but you get the idea
14:11:19 <glguy> sjanssen: I kind of unnecessarily merged everything together which makes it take fewer passes but is less clear
14:11:23 <sjanssen> glguy: yes, and it seems to work
14:11:29 <glguy> sjanssen: and that's going to be resolved in my second go :)
14:11:36 <sjanssen> glguy: yeah, I pondered merging it but was lazy
14:11:40 <dataangel> dolio: Is there a way to do it with a list comprehension without indexing so I can use Integer, or would I have to use genericIndex in that case?
14:11:43 <dolio> dataangel: Yeah, there are a whole bunch of 'genericXXX' functions in Data.List that use more general indexes.
14:11:43 <glguy> I don't care about the constant as much as the order
14:11:45 <thedward> is there a version of Parsec that works with ByteString yet?
14:12:04 <thedward> nevermind, google is my friend
14:12:06 <sjanssen> shapr: oh, so the record labels aren't type witnesses?
14:13:55 <sjanssen> glguy: O(n log n) is the best that I can come up with
14:13:57 <shapr> What's that string equality code that uses laziness and inits?
14:14:03 * shapr can't remember...
14:14:12 <glguy> sjanssen: n log n is the best I need, because to get to that point I need to sort
14:14:18 <IanYoung> > let p=filterM (const [False, True]) in length.p.p.p.p.p$p []
14:14:22 <lambdabot> Terminated
14:14:25 <IanYoung> aw
14:14:38 <dolio> > let fact2 = 1 : [c * (last (genericTake c fact2)) | c <- [1..]] in fact2 `genericIndex` 20
14:14:40 <lambdabot>  2432902008176640000
14:14:52 <dolio> > let fact2 = 1 : [c * (last (genericTake c fact2)) | c <- [1..]] in fact2 `genericIndex` 20 :: Integer
14:14:54 <lambdabot>  2432902008176640000
14:14:57 <dataangel> dolio: Actually... why does 'last' require Int instead of Integer? That makes me think it must be implemented by indexing. Couldn't it be implemented as a recursive call to tail so it didn't need that?
14:15:14 <dolio> dataangel: last shouldn't require any index.
14:15:22 <dolio> ?type last
14:15:24 <lambdabot> forall a. [a] -> a
14:15:32 <dataangel> dolio: Oh... must be take doing it then
14:15:40 <dolio> Right. take is the problem.
14:16:08 <dataangel> dolio: Couldn't take be defined with tail recursively then?
14:16:24 <dolio> ?src take
14:16:24 <lambdabot> take n _      | n <= 0 =  []
14:16:25 <lambdabot> take _ []              =  []
14:16:25 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
14:16:29 <dmwit> You still need to send it an index somehow...
14:16:48 <dolio> Yeah, you need to tell it how many to take.
14:17:46 <dataangel> err yes, but why does that need to be an Int instead of an Integer? Can't it just use an accumulator to tell how many it has taken so far.... actually from that definition I'm not sure what forces it to be Int @_@
14:17:53 <nmessenger> the Prelude list functions just use Int by convention.
14:18:25 <sjanssen> dataangel: they're Int for (dubious) efficiency reasons
14:18:27 <nmessenger> you might use Data.List.genericTake etc.
14:18:33 <dolio> Yeah. Like I said, some people advocate making it (Integral a) => instead of Int.
14:18:38 <dataangel> Ah
14:18:47 <dolio> Essentially, swap them for genericXXX.
14:19:29 <dolio> sjanssen: There are also (possibly dubious) teaching-to-students reasons. :)
14:19:56 <dolio> As I recall.
14:21:01 <dataangel> Hrm, that seems a PITA. I have to import all sorts of stuff to write a list of Integer factorials in list comprehension style as opposed to obfuscated looking scanl style
14:21:25 <dmwit> > take 10 $ product [1..]
14:21:27 <lambdabot>   add an instance declaration for (Enum [a])
14:21:35 <dmwit> > take 10 $ product [1..] :: Int
14:21:36 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
14:21:42 <dmwit> > take 10 $ product [1..] :: [Integer]
14:21:42 <mauke> dataangel: why does it have to be a list comprehension?
14:21:43 <lambdabot>   add an instance declaration for (Enum [Integer])
14:22:01 <dmwit> :t product
14:22:04 <lambdabot> forall a. (Num a) => [a] -> a
14:22:20 <dmwit> > product [1..10]
14:22:21 <dolio> > let facs = 1 : zipWith (*) facs [1..] in facs
14:22:22 <lambdabot>  3628800
14:22:22 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
14:22:27 <dataangel> mauke: It doesn't, I just think it just looks less obfuscated / mysterious.
14:22:36 <nmessenger> > product $ take 10 [1..]
14:22:38 <lambdabot>  3628800
14:23:05 <dolio> > map (product . enumFromTo 1) [0..]
14:23:07 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
14:23:52 <dmwit> > [product [1..n] | n <- [1..10]]
14:23:54 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800]
14:24:00 <dmwit> > [product [1..n] | n <- [0..10]]
14:24:02 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800]
14:24:20 <alexj> @hpaste
14:24:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:24:22 <hpaste>  glguy annotated "Needing ideas for efficiency" with "possibly more readable" at http://hpaste.org/960#a3
14:24:34 <dataangel> bbl
14:24:51 <hpaste>  alexj pasted "hlist code that pegs the cpu" at http://hpaste.org/964
14:27:59 <sjanssen> shapr: did you give xmonad a spin?
14:28:09 <shapr> Not yet, just got done pairing.
14:28:20 <sjanssen> ah
14:29:10 <glguy> sjanssen: did you have a more clean way to build the original tree?
14:30:41 <sjanssen> glguy: you can use any algorithm that produces a tree that is height O(log n)
14:30:52 <sjanssen> that's the quickest one I could hack out with minimal thinking
14:31:52 <glguy> ok
14:32:08 <Lamperi> aa
14:34:39 <sjanssen> glguy: I've seen a nice state monad tree builder
14:37:14 <Gu1> how well does haskell & open gl work together?  sorry i am a neophyte, i've heard there is a haskell open gl implentation or something..
14:43:30 <nmessenger> Gu1: check under the Graphics.UI modules http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:43:53 <Eelis> and check out http://www.haskell.org/haskellwiki/Frag as an example
14:43:54 <lambdabot> Title: Frag - HaskellWiki
14:44:58 <ADEpt> sjanssen: xmonad does not build for me :( "Module `System.Posix.Process' does not export `newSession'"
14:46:04 <shapr> Eelis: Hoi, are you Eelco Visser?
14:46:09 <Eelis> i am not
14:46:14 <Eelis> but hoi nonetheless ;)
14:46:29 <shapr> Eelco Dolstra maybe?
14:46:35 <Eelis> no, my name is actually Eelis
14:46:39 <shapr> Oh
14:46:55 <Eelis> i know, it's hard to believe ;)
14:46:58 <shapr> Well then, nice to meet you Eelis! My name is Shae Erisson.
14:47:14 <Eelis> same to you, comrade
14:47:40 <shapr> hej ohmega, god morgon!
14:47:46 <ohmega> god afton :)
14:47:51 <shapr> Hur mr du?
14:48:32 <ohmega> jag mr bra! hur r det sjlv? :)
14:48:53 <ohmega> jag har inte skickat trjorna frresten, glmde det. sorry.
14:48:55 <shapr> bara bra, eftersom det r dags att cykla p ett hjul!
14:49:00 <shapr> ohmega: No worries
14:49:43 <shapr> oh boy, it's UNICYCLING TIME!
14:52:11 <sjanssen> ADEpt: patch pushed.  Thanks for the report
14:53:03 <Gu1> do you guys recommend reading haskell school of expression?
14:54:21 <dibblego> yes
14:54:59 <largos> is that a book?
14:55:18 <largos> ah, found it :)
14:59:15 <glguy> sjanssen: I found a way to change my buildTree function to: buildTree = Branch 0 buildTree buildTree
14:59:18 <glguy> :)
14:59:34 <_roconnor> @hoogle censor
14:59:35 <lambdabot> Control.Monad.Writer.censor :: MonadWriter w m => (w -> w) -> m a -> m a
14:59:56 <Cale> what a nice name for that :)
15:00:06 <Cale> REDACTED!
15:00:11 <_roconnor> :)
15:03:55 <mwc> Gu1, I got through about 2 chapters of it before I started doing my own stuff
15:04:53 <Gu1> you're probably an experienced programmer though
15:04:56 <Gu1> i am anything but
15:05:05 <sjanssen> glguy: you got away with only three fields for Branch?
15:06:37 <sorear> hello.
15:06:51 <glguy> sjanssen: yeah, I encode all the values into [Bool] first
15:07:43 <glguy> which I can do in n log n time ;)
15:08:40 <sjanssen> glguy: wait till you see this fingertree version
15:09:14 <glguy> sjanssen: using Data.FingerTree?
15:09:32 <glguy> or did you write your own finger tree?
15:09:50 <sjanssen> glguy: using Data.FingerTree
15:10:33 <glguy> sjanssen: that's a library you had to install?
15:10:39 <glguy> it comes with GHC HEAD?
15:11:09 <sjanssen> glguy: just some code I pulled from the internet
15:11:15 <sjanssen> @where fingertree
15:11:15 <lambdabot> http://www.soi.city.ac.uk/~ross/software/html/Data-FingerTree.html
15:11:32 <sjanssen> bleh, Sum is lacking in instances!
15:11:41 <mwc> How stable is GHC-head for day to day use?
15:11:51 <mwc> I assume they only commit when no regressions are found?
15:12:27 <Eelis> i have found it less than stable. (it crashed on me when doing a bit of STM-ing)
15:13:04 <Eelis> ("crash" as in "runtime crash", not "compile-time crash")
15:13:05 <allbery_b> I tried to build pugs with HEAD from Saturday night; it failed miserably
15:13:35 <allbery_b> (6.6 built it fine.  yes, pugs is supposed to be 6.7-compatible)
15:14:38 <Igloo> mwc: Once you have a compiler that works it's generally stable enough, but in general there's a reasonable chance it won't build at any given point
15:14:49 <sorear> I run HEAD continuously without issue.  Perhaps your regression is recent?
15:14:57 <sorear> 6.7.20070223 fwiw
15:15:08 * mwc goes to build HEAD
15:15:35 <allbery_b> 6.7.20070309
15:15:55 <glguy> sjanssen: what is your Measure instance?
15:16:48 <glguy> just measure ZeroLeaf = 0; measure OneLeaf = 1?
15:17:13 <allbery_b> looked like in its selftest many things that used IsString blew up
15:18:14 <dons> re.
15:18:42 <glguy> sjanssen: how do you access an arbitrary element of that data structure?
15:19:39 <dons> i've found the head from March 01 and later pretty stable
15:22:32 <sorear> also, modern HEADs version by date
15:22:56 <sorear> so if I go and reinstall HEAD now, i'll still have 6.7.20070223
15:25:37 <hpaste>  sjanssen annotated "Needing ideas for efficiency" with "with fingertrees" at http://hpaste.org/960#a4
15:25:42 <sjanssen> glguy: there you go
15:25:45 * sjanssen leaves
15:27:19 <chessguy> @hoogle Sum
15:27:20 <lambdabot> Prelude.sum :: Num a => [a] -> a
15:27:21 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
15:27:21 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
15:27:59 <chessguy> @hoogle Measured
15:28:00 <lambdabot> No matches found
15:28:03 <glguy> It's in Data.Monoid
15:28:10 <glguy> Measured is from a link in the scrollback
15:29:45 <manu3000> Hello, i've bought "introduction to functional programming" from Bird and Wadler, in order to learn Haskell but i've just realized this is an old edition (1988) !!!
15:30:15 <glguy> sorry, the channel doesn't issue refunds
15:30:32 <chessguy> Bird and Wadler were at least 20 years ahead of their time anyway
15:30:35 <Pseudonym> manu3000: Thankfully, it's still pertty good.
15:30:36 <manu3000> Should I return it and buy the second edition (1998), they say it uses Haskell 3.1...or it doesn't really matter ????
15:31:12 <manu3000> yeah it looks good ! but nothing about monads !!!
15:31:19 <Pseudonym> I haven't seen the second edition, but updating the language is probably not the only thing they updated.
15:31:30 <sorear> monads are a new feature in Haskell 1.3
15:32:12 <manu3000> @sorear : how different is Haskell 1.3 from Haskell 98
15:32:13 <lambdabot> Unknown command, try @list
15:32:30 <sorear> manu3000: I think the Haskell 98 report has a changes list
15:32:32 <chessguy> @help sorear
15:32:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:32:34 <sorear> @where report
15:32:34 <lambdabot> http://www.haskell.org/onlinereport/
15:32:44 <Pseudonym> But the 1988 version wasn't even for haskell.
15:32:52 <Pseudonym> Haskell was first standardised in 1989.
15:33:05 <sorear> no, not the report itself...
15:33:07 <bos> from a distance, haskell looks like miranda :-)
15:33:07 <ailndx> anyone read Graham's haskell book and got any oppionion about it?
15:33:53 <manu3000> Pseudonym : yes sorry, the second edition !1998) deals with Haskell 1.3. The one i got uses pseudo code and mentions Miranda
15:34:07 <sorear> 98 -> 98revised: http://haskell.org/definition/haskell98-bugs.html
15:34:08 <lambdabot> Title: Haskell 98: ERRATA
15:34:12 <sorear> 1.3 -> 1.4: http://haskell.org/definition/from13to14.html
15:34:13 <lambdabot> Title: Changes from Haskell 1.3 to Haskell 1.4
15:34:25 <Pseudonym> Right.
15:34:27 <sorear> 1.4 -> 98: http://haskell.cs.yale.edu/definition/aboutHaskell98.html
15:34:29 <lambdabot> Title: Haskell 98
15:34:41 <Pseudonym> Miranda is well beyond obsolete.
15:35:30 <Pseudonym> Look, I'd get the new edition if you can.
15:35:31 <manu3000> right, maybe i'll return it, i've already got my share old functional programming books, thanks !
15:35:43 <Pseudonym> If only because it's got more fixes than just updating Miranda to Haskell.
15:40:13 <chessguy> augh! my "Craft of Functional Programming" came today, but i think it got delivered to the neighbors with the insane dogs :(
15:40:16 <sorear> @usrs
15:40:17 <lambdabot> Maximum users seen in #haskell: 339, currently: 320 (94.4%), active: 50 (15.6%)
15:40:32 <dons> i wouldn't know where to get a miranda interpreter these days
15:41:52 <sorear> i think it's possible to get a pretty complete understanding of miranda by reading ifpl
15:42:38 <sorear> no miranda compilers?
15:43:40 <dons> Miranda is (TM) Research Software (in case any lawyers are watching)
15:43:50 <Pseudonym> You can theoretically get Miranda(TM) from David Turner still.
15:43:51 <dons> Haskell is not a trademark of anyone
15:43:57 <Pseudonym> It's not pricey any more.
15:53:45 * Botje discovered that ICFP is available online for free :|
15:53:58 <dataangel> Is there a way to pattern match for when two parameters are equal to each other? So if I have a function that takes two integers, I want one version called when the integers are equal and one when they're not
15:54:15 <Botje> foo a b | a == b
15:54:20 <bos> use a guard.
15:54:23 <dataangel> oic
15:54:37 <wilx> foo a a? Just guessing.
15:54:53 <dataangel> foo a b | a == b = a + b {- Valid? -}
15:55:18 <sorear> > let { foo a b | a == b = a + b } in foo 2 2
15:55:20 <lambdabot>  4
15:55:22 <sorear> > let { foo a b | a == b = a + b } in foo 2 3
15:55:23 <lambdabot>   Non-exhaustive patterns in function foo
15:55:32 <sorear> > let { foo a b | a == b = a + b   | otherwise = a - b } in foo 2 3
15:55:34 <lambdabot>  -1
15:55:50 <Botje> wilx: no, that errors
15:55:53 <wilx> let { foo a _ = 1 ; foo a a = 2 } in foo 1 1
15:55:59 <wilx> > let { foo a _ = 1 ; foo a a = 2 } in foo 1 1
15:55:59 <mauke> > let foo a b|a==b=a+b|otherwise=a-b in foo 2 3
15:55:59 <lambdabot>      Conflicting definitions for `a'
15:56:00 <lambdabot>     In the definition of `foo'
15:56:00 <lambdabot>  -1
15:56:02 <wilx> I see.
15:56:23 <dons> http://programming.reddit.com/info/1a1vq/comments
15:56:24 <lambdabot> Title: The "frame of reference" monad (reddit.com)
15:56:40 <dons> http://programming.reddit.com/info/1a1vk/comments
15:56:41 <lambdabot> Title: Transactional memory and IO redux (reddit.com)
15:57:51 <sorear> wilx: that was actually a feature of Miranda, but it opened too many cans of worms
15:58:25 <sorear>    The set of patterns corresponding to each match must be linear---no variable is allowed to appear more than once in the
15:58:25 <sorear>    entire set.
15:58:33 <sorear> ^^^ 4.4.3.1
15:58:57 <dolio> Miranda did pattern unification?
15:59:06 <roconnor> hey, how come we can't get the new haskell logo on a mug?
15:59:31 <sjanssen> glguy: I'm curious, what's the original problem description
15:59:37 <sorear> dolio: I don't know what this unification of which you speak is.  Miranda desugared to equality guards.
15:59:48 <dons> roconnor: i'm sure we could. we probably could get a better haskell logo too :-)
16:00:15 <sjanssen> dons: I think I fixed the zombie issue
16:00:17 <dolio> sorear: Unification as in prolog.
16:00:18 <roconnor> dons: I'm thinking of getting a mug with the old logo.
16:00:35 <roconnor> dons: or can I convince cafe press to put the new logo onto a mug?
16:00:53 <dolio> Where you can do, say, subtract(x, x, 0)
16:00:54 <dons> sjanssen: ah great. saves me some time doing it :-)
16:01:03 <dons> roconnor: we don't have a new logo yet :-)
16:01:32 <dons> sjanssen: in the repoo yet?
16:01:38 <sjanssen> dons: I used setsid -- you might want to double check it if you've got stronger posix-fu than I
16:01:46 <sjanssen> dons: yeah, it's there
16:01:52 <roconnor> dons: sure we do: http://www.haskell.org/haskellwiki_logo.png
16:02:40 <roconnor> http://www.cafepress.com/haskellnewlogo
16:02:45 <dons> roconnor: that's the old logo (imo)
16:02:51 <dons> not the *really* old logo .
16:02:53 <bos> dons: what do you use to watch for new blog articles?
16:02:58 <roconnor> http://www.cafepress.com/haskell is the old logo
16:03:00 <roconnor> oh
16:03:01 <dolio> Or, if haskell did unification, you could have:  'foo x@(y:x) = ...' which would force x to be an infinite list of y.
16:03:11 <dons> bos, an rss feed to google's blog search facilitiy
16:03:13 <roconnor> dons: is there going to be a new logo?
16:03:18 <bos> dons: heh
16:03:34 <sjanssen> dolio: and how does the compiler/runtime make sure that x is infinite?
16:03:38 <dons> http://www.google.com.au/blogsearch?as_q=haskell+programming
16:03:39 <lambdabot> Title: Google Blog Search: haskell programming
16:03:48 <dons> with about 30 flags to narrow it down further
16:04:17 <dolio> sjanssen: You've got me. How do they solve that in prolog?
16:04:31 <dolio> sjanssen: I suppose you can't really have infinite data structures in prolog.
16:04:37 <dons> bos, i'm pretty sure that's what linuxer does too, he seems to hit the same articles I reject
16:04:39 <sorear> say, has there been any work to make mptc+fd syntax-compatible with Prolog?
16:05:15 <sjanssen> sorear: mptc+fd isn't even semantically compatible with prolog
16:05:41 <sorear> oh.
16:05:46 <sjanssen> dolio: I dunno
16:05:52 <sorear> wonder where I heard it was...
16:06:03 <mwc> Hey, anybody know where to host a darcs repo?
16:06:12 <mwc> GPL Haskell projcet?
16:06:17 <sjanssen> sorear: prolog is more flexible, as I understand it
16:06:34 <dons> mwc,you can currently get an account on darcs.haskell.org and host it there
16:06:34 <sorear> mwc: your private webhost, or d.h.o if you have mega haskell karma
16:06:37 <dons> or you can host it privately
16:06:44 <sjanssen> sorear: I suppose you could embed a prolog interpreter, the class system is turing complete
16:06:47 <dons> in the near future we hope to have a community server for this
16:07:10 <sorear> mwc: you don't need a special server for darcs projects, and we use a party-line system for project mailings
16:07:33 <mwc> d.h.o?
16:07:39 <roconnor> is there a really big copy of http://www.haskell.org/sitewiki/images/8/86/Haskellwiki_logo_big.png that I can use to put on a mug?
16:07:41 <lambdabot> http://tinyurl.com/2cwjf8
16:07:43 <mwc> I'd host it on my PC but it's off 12 hours a day
16:07:50 <sjanssen> mwc: darcs.haskell.org
16:07:58 <roconnor> dons:  you made the old logo right?
16:08:11 <mwc> sjanssen, so who do I talk to?
16:08:11 <dons> roconnor: nope.
16:08:15 <roconnor> oh
16:08:21 <dons> roconnor: i just think it could be more attractive
16:08:28 <dons> too much bevel, funny colours
16:08:35 <dibblego> yeah it's a bit fugly
16:08:39 <mwc> I'll just bug dons, he'll know
16:08:49 <mwc> dons, who can get me an account on darcs.haskell.org?
16:08:52 <roconnor> dons: okay.  Do you know how I can get my hands on a high-res copy of the logo?
16:08:55 <sorear> mwc:
16:08:57 <dons> an account on d.h.o is gained by asking Simon Marlow
16:08:59 <sorear> @wiki Haskell.org
16:09:00 <lambdabot> http://www.haskell.org/haskellwiki/Haskell.org
16:09:08 <dons> roconnor: yeah, hmm, you need to check the mailing list archives
16:09:12 <dons> for when it was announced.
16:10:26 <dolio> sjanssen: 'A = f(A) : Infinite unification, A is unified with f(f(f(f(...)))). In proper first-order logic and many modern Prolog dialects this is forbidden (and enforced by the occurs check)'
16:11:56 <dolio> So I guess the answer is, "don't do that."
16:11:59 <dolio> :)
16:14:04 <dons> Current: 315, Avg: 300, Max: 338
16:14:11 <dons> we now average 300!
16:14:41 <ailndx> i'll make it 299
16:14:50 <dolio> Heh, 'Haskell Eye for the Ruby Guy'
16:14:53 <sjanssen> ha
16:15:08 <sorear> @seen goltrpoat
16:15:09 <lambdabot> I saw goltrpoat leaving #oasis and #haskell 2d 20h 12m 58s ago, and .
16:15:11 <dons> though the article doesn't really talk at all about ruby
16:15:20 <dons> just about how haskell is going to take over the world
16:15:39 <pjd_> dons: is it possible to get some kind of participation quotient from those statistics?
16:16:01 <dons> sjanssen: hmm. slogan for xmonad: "Perfection is attained
16:16:01 <dons> not when there is nothing left to add
16:16:01 <dons> but when there is nothing left to take away
16:16:02 <dons> (Antoine de Saint-Exupry)"
16:16:18 <dons> @users
16:16:19 <lambdabot> Maximum users seen in #haskell: 339, currently: 315 (92.9%), active: 47 (14.9%)
16:16:27 <sorear> bing!
16:16:33 <dons> that's about it, other than grabbing the logs darcs repo and munging it
16:17:10 <malcolmw> does the usercount exclude duplicate IDs like dons and dons_?
16:17:46 <mwc> Hey, I figured out my CPP problem. To get at the feature-present #defines in the lib, I'm just {-\n#include <foo.h>\n-} and including the resulting C code inside haskell comments.
16:18:12 <dolio> Well, the one reported by lambdabot matches the one reported by my IRC client.
16:18:12 <dons> malcolmw: not if they both appear in channel
16:18:20 <mwc> anybody think of a way to make that a little more resilient? AFAIK {- will never appear in C code, but could in comments.
16:18:27 <dataangel> Why is [1, 2] : [] == [[1,2] instead of [1,2] : [] == [1,2] ?
16:18:32 <Philippa_> dons: PM?
16:18:41 <dons> Philippa_: yeah?
16:18:42 <dataangel> err, missing bracket: Why is [1, 2] : [] == [[1,2]] instead of [1,2] : [] == [1,2] ?
16:18:42 <malcolmw> mwc: does cpphs not work for you?
16:18:43 <sjanssen> @type (:) -- this is why
16:18:45 <dons> dataangel: ->
16:18:46 <lambdabot> forall a. a -> [a] -> [a]
16:18:47 <dons> :t (:)
16:18:50 <lambdabot> forall a. a -> [a] -> [a]
16:18:51 <dolio> [1, 2] is 1:2:[]
16:18:53 <sjanssen> @quote stereo
16:18:53 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
16:19:04 <dolio> [1, 2]:[] is (1:2:[]):[]
16:19:07 <dons> so whatever 'a' in the first argument, it will be a [a] once you cons a list onto it
16:19:19 <mwc> malcolmw, can it process a haskell file with the resulting #define set from processing a given collection of C headers?
16:19:25 <mwc> that's really what I need to do
16:19:48 <dataangel> that's screwy @_@
16:19:50 <dons> mwc, hmm, sounds like you should be using hsc2hs?
16:19:55 <dons> > 1 : []
16:19:56 <lambdabot>  [1]
16:19:59 <dons> > "foo" : []
16:19:59 <dolio> You might be thinking of (++)
16:20:00 <lambdabot>  ["foo"]
16:20:01 <mwc> dons, will look into it
16:20:04 <dolio> > [1, 2] ++ []
16:20:05 <lambdabot>  [1,2]
16:20:07 <malcolmw> mwc: is the problem that the header files contain C code as well as #defines?
16:20:07 <dons> > [[2]] : []
16:20:09 <lambdabot>  [[[2]]]
16:20:12 <mauke> dataangel: (:) is prepend. prepending x to an empty list gives you [x]
16:20:14 <dolio> (++) is append, (:) is cons.
16:20:23 <mwc> malcolmw, precisely
16:20:25 <pjd_> dataangel: if you know Scheme/Lisp, that's exactly like (cons '(1 2) '())
16:20:34 <pjd_> => ((1 2))
16:20:35 <dons> > let box = (:[])   in   box [1,2]
16:20:37 <lambdabot>  [[1,2]]
16:20:41 <dons> > let box = (:[])   in   box 7
16:20:42 <lambdabot>  [7]
16:20:44 <dons> > let box = (:[])   in   box ()
16:20:46 <lambdabot>  [()]
16:20:55 <dons> > let box = (:[])   in   box (box (box []))
16:20:57 <lambdabot>  [[[[]]]]
16:21:15 <malcolmw> mwc: sounds like your approach is the handiest then
16:21:42 <ddarius> box = \x -> [x]
16:21:54 <mwc> malcolmw, it works, but it's ugly. I'm just waiting for {- to find its way into a comment, and then the comments won't nest correctly
16:21:55 <pjd_> @pl \x -> [x]
16:21:56 <lambdabot> return
16:21:57 <dataangel> hrm, I would have still been surprised but not puzzled if [1, 2] : [] == [1,2, []]
16:22:00 <pjd_> heh
16:22:17 <wilx> @type Data.List.singleton
16:22:20 <lambdabot> Not in scope: `Data.List.singleton'
16:22:45 <dolio> Yeah, regular lists don't let you append a single element nicely.
16:22:51 <malcolmw> mwc: when that happens, maybe cpphs --text --strip will be your friend
16:22:53 <dons> [1,2, []] that's not well typed
16:23:05 <dolio> Oh yeah, that too. :)
16:23:06 <dataangel> Hmm.. guess the x example makes sense... (:) isn't really associative even if thought of as operating on a set rather than list type
16:23:23 <mwc> actually, hsc2hs looks like it'll do perfectly.
16:23:27 <dolio> ?hoogle snoc
16:23:28 <lambdabot> No matches found
16:24:56 <dataangel> Weird, that means that [1,2] : [] works but not [] : [1,2] @_@
16:25:10 <dolio> > empty |> 1 |> 2
16:25:11 <lambdabot>   Not in scope: `|>'
16:25:15 <mauke> how is that weird?
16:25:22 <mauke> [[], 1, 2] is a type error
16:25:32 <Igloo> dons: Is there a sorted list of SoC proposals somewhere?
16:25:43 <Igloo> (just out of curiousity)
16:26:04 <malcolmw> Igloo: hanging off the SoC trac, in tickets?
16:26:26 <Igloo> malcolmw: What do I sort by?
16:26:46 <malcolmw> Igloo: what do you want to sort by?
16:26:54 * Igloo wonders why the SoC ticket numbers suddenly jumped to about 1000
16:27:06 <malcolmw> Igloo: spam (now dleeted)
16:27:14 <Igloo> Ouch
16:27:21 <dataangel> mauke: Coming from other languages an empty list doesn't seem like a type error. Thinking of it as a type error makes me expect that I should be able to type into ghci: let x = [] <ret> x :: [Integer] <ret> x : [1, 2] <ret> And then have it work, because now x has a defined type, but it still doesn't.
16:27:25 <Igloo> malcolmw: There was talk of ordering them by priority or somesuch, wasn't there?
16:27:41 <shapr> SHAZAM!
16:27:48 <pjd_> dataangel: an empty list isn't a type error
16:27:56 <malcolmw> Igloo: I don't think we have decided a priority yet
16:27:59 <pjd_> but a list can only contain one data type
16:27:59 <shapr> malcolmw: That was punny, dleeted
16:28:01 <Igloo> OK
16:28:04 <pjd_> [[], 1, 2] contains two
16:28:26 <dataangel> oic
16:28:27 <malcolmw> D-l33t-ed
16:28:31 <shapr> malcolmw: yeah :-)
16:28:37 <dataangel> so [] :[[1,2]] works, and it infers the type of [] is [Integer]
16:28:49 <shapr> malcolmw: Hey, got any simple demos of XmlContent hanging around?
16:28:58 <dataangel> interesting..
16:29:10 <shapr> I'd like to write up something to send to the HAppS list for feedback.
16:29:17 <malcolmw> shapr: I think there are some in the Blobs repository
16:29:26 <pjd_> dataangel: well, it's [[Integer]]
16:29:37 <dataangel> hmm, why if I say, let x = [], x ::Integer, and then do :t x does it still say x is of type [a] instead of [Integer]?
16:29:50 <shapr> malcolmw: Spiffy, I'll check it out.
16:29:53 <mauke> > [] :: Integer
16:29:54 <lambdabot>  Couldn't match expected type `Integer' against inferred type `[a]'
16:29:55 <malcolmw> http://www.cs.york.ac.uk/fp/darcs/Blobs
16:29:58 <lambdabot> Title: Blobs diagram editor
16:30:08 <mauke> dataangel: sorry, [] isn't an Integer
16:30:20 <dolio> ?type ([] :: [Integer])
16:30:21 <dataangel> pjd_ The type of [] : [[1,2]] is [[Integer]] but the type of [] in that expression is [Integer] ... right?
16:30:23 <lambdabot> [Integer]
16:30:37 <pjd_> dataangel: right
16:30:57 <dataangel> err, that was a typo, I meant let x = [], x :: [Integer], and then do :t x still gives x :: [a]
16:31:14 <mauke> yes, x :: [Integer] is just an expression there
16:31:18 <mauke> it doesn't change the type of x
16:31:24 <dataangel> oh @_@
16:31:44 <dolio> Do: 'let x = [] :: [Integer]'
16:31:47 <dolio> Then try.
16:31:51 <mux> mmm, my post to libraries@haskell.org was rejected, and it doesn't look as if I can/should register to it
16:31:58 <allbery_b> actually it works in the other order
16:32:03 <shapr> mux: libraries loves you! please repost!
16:32:26 <dons> hey shapr
16:32:26 <mux> shapr: is that a known transient problem then?
16:32:28 <allbery_b> Prelude> let x :: [Integer]; x = []
16:32:29 <allbery_b> Prelude> :t x
16:32:29 <allbery_b> x :: [Integer]
16:32:34 <shapr> g'day dons
16:32:48 <shapr> mux: Yeah, mailman suxx0rs.
16:33:03 <mux> ok, thanks
16:33:07 <sjanssen> mux: why can't you register to it?
16:33:18 <shapr> mux: Also, www.haskell.org has been under a massive load the last few months. dons' reddit dotted it :-)
16:33:19 <dataangel> mauke: Why? If I write a file that does x :: [Integer] x = [] and load it, then do :t x I do get x :: [Integer]. Once x has been assigned is it too late? Why even have x :: [Integer] evaluate as an expression then?
16:33:25 <shapr> Go dons! w00!
16:33:28 <shapr> dons++
16:33:52 <mauke> dataangel: huh? that's what ghci does: it evaluates expressions
16:34:01 <sjanssen> @keal
16:34:01 <lambdabot> i have basically written a proof that shows an assumption is wrong
16:34:03 <sjanssen> @keal
16:34:03 <lambdabot> when i put what i dat recoved from that tile into a ti92. the damn thing blew up
16:34:05 <sjanssen> @keal
16:34:05 <lambdabot> its because the timeline diverges and past events themselves unhappen
16:34:08 <shapr> @protontorpedo
16:34:08 <lambdabot> lazy makes macro not needed?
16:34:15 <mwc> Thank's dons, switching to hsc2hs was done in almost no time at all.
16:34:17 <sjanssen> damn, I need to write keal regex support
16:34:20 <malcolmw> dataangel: I think the comma is the problem (try a semi-colon?)
16:34:23 <shapr> sjanssen: wha?
16:34:34 <mauke> you should turn @keal into @quote keal
16:34:35 <dolio> @quote qwe1234
16:34:36 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
16:34:36 * mux reposts by copy-paste and hearts fmt(1)
16:34:47 <nomeata> @quote me
16:34:48 <lambdabot> SamB says: fworp: next time, load your shirt up in to GHCi *before* having it printed
16:35:05 <shapr> I just used up all my spare drivespace after finding jamendo :-(
16:35:05 <sjanssen> here is the keal quote I was fishing for: "evaluating expressions is ALL haskell does?????"
16:35:11 <shapr> sjanssen: hahah!
16:35:33 <dibblego> sjanssen, it makes coffee too, if you ask nicely
16:35:53 <shapr> dons: Oh hey, I had a thought about my next SoC project, wanted to run it by you.. do know of any SSL/TLS libs in/for Haskell?
16:35:55 <dataangel> malcomw: err, what comma?
16:36:05 <shapr> I know there's some code in HaskellNet that I haven't looked at yet, but anything else?
16:36:19 <dataangel> mauke: I mean, why is x :: [Integer] a valid expression if it's too late to specify the type of x
16:36:24 <malcolmw> dataangel: in x = [], x :: [Integer]
16:36:37 <sjanssen> dibblego: Haskell doesn't actually make the coffee.  It just constructs Appliance monad actions which are interpreted by another system
16:36:37 <shapr> Hm, musasabi wrote hsgnutls
16:36:45 <mauke> dataangel: (2 :: Double) ^ (2 :: Int)
16:37:03 <dataangel> whoa @_@
16:37:09 <dibblego> sjanssen, does GHC compile to coffee machine native code?
16:37:28 <mux> You are not allowed to post to this mailing list, and your message has
16:37:30 <sorear> GHC /= Haskell
16:37:31 <malcolmw> ?type let x = [] ; x :: [Integer] ; in x
16:37:31 <mux> been automatically rejected.
16:37:34 <lambdabot> [Integer] ; in x :: [Integer]
16:37:34 <mux> grrrr
16:37:46 <shapr> mux: Tried becoming a member via mailman interface?
16:37:47 <dons> shapr: SSL is something missing, I think.
16:37:48 <sorear> mux: join the mailing list.
16:37:53 <dons> sjanssen: you sure the zombie code works?
16:37:59 <sjanssen> dons: no
16:37:59 <dons> I think i'm still getting zombies
16:38:04 <mwc> shapr, I'm actually picking up Hopenssl now
16:38:09 * shapr shoots the nearest zombie
16:38:13 <mux> well I thought I wasn't supposed to
16:38:13 <shapr> mwc: Tell me more!
16:38:18 <mux> dang it, one more mailing list
16:38:19 <sjanssen> dons: okay, maybe we actually do need the double fork thing
16:38:20 <sorear> mux: and do the world a favor! shoot a spammer!
16:38:21 <dons> $ ps aux | grep Z | wc -l
16:38:21 <dons>        5
16:38:24 * sorear whines
16:38:29 <shapr> mux: I join the mailing list, suspend my subscription, and then use gmane.
16:38:33 <malcolmw> ?type let { x = []; x :: [Integer] } in x
16:38:35 <dons> just open an xterm. close it. open gain and ps aux | grep Z
16:38:36 <lambdabot> [Integer] } in x :: [Integer]
16:38:40 <mwc> I just finished making it generate the digests using hsc2hs so that I can include functionality depending on what's in the openssl lib. Then I'll do the encryption routines and finally the SSL sockets themselves
16:38:49 <shapr> mwc: Sounds good!
16:39:07 <mwc> I talked to the original developer and he says that I'm welcome to take it over.
16:39:07 <dolio> ?type (let x = []; x :: [Integer] in x)
16:39:10 <lambdabot> [Integer]
16:39:17 <mwc> it hasn't been touched since Jun 2005
16:39:19 <shapr> Ok, what other open problems are there in the Haskell world? What do we need if we want to have all the batteries included that Java or Python has?
16:39:36 <shapr> My server is down :-(
16:39:54 <mwc> shapr, too bad, I need a place to put a darcs repo
16:40:01 <dataangel> Hmm... the only reason I don't get an error from x :: [Integer] though is because the earlier let defined x. After I've letted x to something, what would x :: [Integer] accomplish? Could I set it to an empty list and then... do various things based on the type of things x held? @_@ Guess I'm confused :/
16:40:08 <shapr> mwc: I'll set you up with one soon as it returns.
16:40:10 <dibblego> shapr, we have a problem; my boss colleague spent months writing all this code, ran it on dual core machines all over our office, then got fed up, wrote it in Java in a few days (with some swearing) and outperformed the Haskell code in both time and space
16:40:23 <shapr> dibblego: hm
16:40:30 <dolio> shapr: Haskell will never surpass Java until deserializing a value from a socket may cause arbitrary code to be loaded from said socket. :)
16:40:31 <dons> shapr: i think one way is to find the list of the top 30 python libs
16:40:33 <dibblego> shapr, I'm *most* curious to know why
16:40:36 <dons> and the top 30 perl and ruby libs
16:40:39 <dons> and then intersect them
16:40:43 <shapr> dibblego: Me too, is your Haskell code available?
16:40:48 <dons> and take the difference between that and hackage
16:40:49 <mwc> dibblego, space leaks causing swap thrashing?
16:40:50 <dibblego> shapr, he won't even let me see it :)
16:40:53 <sorear> dibblego: haskell is not meant to be fast-to-run
16:41:04 <encryptio> shapr: a movement to change any error catching routines from specific to general types (for example, Monad m => ... -> m a)
16:41:07 <shapr> dibblego: In that case, I'm not convinced.
16:41:08 <dibblego> sorear, what does that mean exactly?
16:41:10 <mux> finally.
16:41:13 <mwc> sorear, jmeacham will fight you to the death over that comment ;)
16:41:15 <sorear> dibblego: haskell is fast-to-write. are you calling yourself cheaper than a computer
16:41:16 <dibblego> shapr, I'm not either, but I have no explanation yet
16:41:18 <dons> dibblego: sounds very odd.
16:41:29 <dons> dibblego: is the code available? how did it work? what did it do?
16:41:29 <dibblego> sorear, no, but performance is critical for this particular application
16:41:31 <dataangel> dolio: What is the 'in x' doing there?
16:41:43 <mwc> dibblego, then it's 100% straight assembler for you!
16:41:44 <shapr> dibblego: If he won't show you the code then I'm convinced he's using immutable arrays throughout, unsafePerformIO and everything else evil and slow.
16:41:46 <dibblego> dons, indeed it is odd - but unfortunately, I cannot show the code (not even I have seen it yet)
16:41:56 <dolio> dataangel: That's the normal syntax of a let expression.
16:42:03 * mux calls it a day
16:42:07 <sorear> dibblego: what are you doing using haskell directly for?
16:42:09 <dons> ok. its not unheard of for beginner haskell programmers to do odd things
16:42:09 <dibblego> shapr, almost certainly on the first and almost certainly not on the second (since he asks me questions all day)
16:42:12 <dolio> dataangel: 'let <declarations> in <expression>'
16:42:16 <mux> g'nite
16:42:18 <sorear> dibblego: asm arrows can exist
16:42:18 <dataangel> dolio: doh :P
16:42:26 <shapr> dibblego: In that case, it's no surprise it's slow.
16:42:37 <sjanssen> dons: yep, still broken.  I'll give it another shot
16:42:51 <dibblego> sorear, some stock market calculation thing (I have no idea about the stocok market, so even if I did see the code, it wouldn't make sense immediately)
16:42:55 <dons> but we can't really say anything, or offer advice, without code. or they could hire consultants... ;)
16:42:58 <shapr> dibblego: Can't compare random program in unfamiliar language to same program in familiar language and expect equality.
16:43:04 <dons> yeah
16:43:05 <dolio> dataangel: In the context of a do-block in a monad, you can just use 'let <declarations>', which is why that works in ghci.
16:43:11 <sorear> dibblego: ghod.  would this guy expect to learn how to program and write super-fast Java his first week?
16:43:13 <dibblego> shapr, I have told him to use a diff array for one of his particular problems that he explained to me, but he hasn't done that yet
16:43:17 <shapr> dibblego: Oh right, may I offer to be a consultant?
16:43:26 <dataangel> dolio: when I type "let x = 10" into the interpreter though, x stays defined, so I'm guessing it's like saying, "let x = 10 in everything-I-type-after-this" ?
16:43:33 <dons> dibblego: hmm. diff arrays arne't great
16:43:45 <dibblego> shapr, perhaps, I'll talk to him when he comes in - neither of us are convinced about our conclusions by the way - we accept our ignoracne
16:43:58 <shapr> I have about eight years of experience being a self employed consultant, mostly doing web dev and programming. Last six months or so it's been all Haskell.
16:44:00 <dibblego> dons, yeah, but how do you get the equivalent of a C array in Haskell?
16:44:01 <sorear> dons: they beat immutable arrays to a pulp.
16:44:12 <dolio> dataangel: Yeah. Behind the scenes, GHCi is sort of running in the IO monad.
16:44:20 <sorear> dons: constant factors are no substitute for asymptotic complexity
16:44:20 <dons> dibblego: you use Data.Array.Unboxed or Foreign.Marshal.Array
16:44:26 <encryptio> dibblego: often times your algorithm changes enough so you don't need the equivalent
16:44:29 <dons> dibblego: see the C-speed unboxed arrays on the shootout, for example
16:44:34 <sorear> dibblego: {IO,ST}UArray
16:44:39 <dolio> dataangel: So you can think of all the stuff you're typing in as being part of a big 'do { a ; b ; c ...}' block.
16:44:48 <dibblego> dons, OK, I'll figure it out - yeah, he's been reading about yours and SPJ's array stuff (which I haven't done yet)
16:44:49 <dolio> dataangel: Although it's slightly more complex than that.
16:45:00 <chessguy> anybody familiar enough with HSOE to give me a nudge in the right direction for the snowflake fractal exercise?
16:45:02 <shapr> dons: How do we find the top 30 libs for a given language?
16:45:16 <dons> shapr: doesn't CPAN et al have 'sort by most popular' lists?
16:45:24 <shapr> No clue, I don't use Perl much.
16:45:30 <shapr> Like, I used it once in 1999.
16:45:44 <dibblego> dons, the same guy said data MyBool = MyTrue | MyFalse runs faster than Prelude.Bool, which I called bullshit on, and he's yet to prove it to me, so we both know we're probably wrong
16:45:53 <dons> hmm.
16:46:17 <dons> its not the kind of thing i would do, since Bool is just an Int# underneath anyway
16:46:22 <shapr> dibblego: Truly, I cannot think of any corner case where MyBool would be faster.
16:46:28 <dibblego> dons, I said "write a small case that proves it" and he tried and failed
16:46:35 <dons> sticking a Bool in an unboxed array triggers bit packing code
16:46:39 <dibblego> shapr, me neither - believe me, I am as sceptical as you are
16:46:39 <dons> which would be avoided in MyBool
16:46:50 <chessguy> oh dons and company are here now. forget getting any newbie help
16:46:50 <dons> anyway, can't do anything without more data/code
16:46:58 <dibblego> apparently, there are lots of [Bool] in his code with all sorts of transformations on it
16:47:07 <dibblego> dons, yeah I agree, I'll talk to him about it when he comes in
16:47:31 <shapr> On the other hand, if he will let us see the code, a) it'll be faster than anything he can write in Java and b) he won't recognize it.
16:47:51 <LoganCapaldo> too bad about part b)
16:47:57 <dibblego> shapr, agreed
16:48:03 <emk> ?type msplit
16:48:05 <lambdabot> Not in scope: `msplit'
16:48:07 <dibblego> shapr, I called bullshit on him yesterday already
16:48:08 <dons> chessguy: that's an odd thing to say...
16:48:11 <ddarius> LoganCapaldo: It will also be reduced to one line.
16:48:20 <LoganCapaldo> with no points
16:48:30 <shapr> I used to submit my heavily rewritten code for Igloo inspection. After some discussion, I usually ended up with code half the size that I just barely understood.
16:48:32 <dibblego> "it is theoretically impossible for your Java code to be faster, therefore, I conclude that your Haskell is wrong" (without seeing the code)
16:48:32 <dataangel> dolio: So what happens if I do let x = [] and then I just type in by itself x :: [Integer]? If I write x :: [Integer] and then do x = [] in a file, I get a list x of type [Integer] -- the :: usage changes x's type. But what's the difference between that and what the interpreter does that causes x :: [Integer] to seemingly just get thrown into space?
16:48:42 <dibblego> that's what I said yesterday
16:48:42 <shapr> hah
16:48:49 <chessguy> dons: shrug, if the shoe fits...
16:48:59 <shapr> It is possible for Java code to be faster since they use the HotSpot VM these days.
16:49:02 <dons> chessguy: please chcek the logs. I was helping dataangel only 10 mins ago.
16:49:02 <dibblego> of course, my understanding of the "theory" could be wrong, so I'm open to that possibility
16:49:20 <dolio> dataangel: Well, in the context of the interpreter, the type of x is decided when it's defined.
16:49:23 <dons> chessguy: and remember, this is a mixture of newbie and advanced discussion. otherwise we only have newbies talking to themselves.
16:49:23 <shapr> chessguy: Hey, be nice. dons helps everybody!
16:49:42 <chessguy> dons: it's not (usually) a question of whether you personally help newbies. it's that when you're here the channel is full of incomprehensible stuff
16:49:49 <emk> dons has helped me above and beyond the call of duty, from my newbie days onwards
16:49:53 <dolio> dataangel: Then, when you later type 'x :: [Integer]', it's saying "Evaluate the expression x, and restrict the result to type [Integer]"
16:49:54 <shapr> dons not only helps people on #haskell, he writes good code that gets into the standard libs and improves the coding life of everybody.
16:50:03 <sorear> chessguy: do you really want #haskell-idiots and #haskell-smerdies, where neither can communicate?
16:50:05 <Igloo> shapr: I was interested to see that I'm the only person on http://auriga.wearlab.de/~alb/tmp/stats/darcstats.html to delete more lines than I've added
16:50:06 <shapr> chessguy: Ask and ye shall comprehend!
16:50:07 <lambdabot> Title: darcs-unstable darcstats
16:50:17 <dolio> dataangel: Which affects the type of the result, but not the type of the original declaration.
16:50:25 <chessguy> shapr: i did ask, somewhere up there before a few pages of gunk
16:50:37 <jcreigh> does hotspot JIT to native machine code?
16:50:38 <chessguy> i'm sure it's not important though
16:50:43 <shapr> chessguy: Well, keep on asking, keep on learning. Soon it won't be gibberish.
16:50:52 <Cale> Who is running hpaste?
16:50:54 <dolio> dataangel: When you type it into a file, the 'x :: [Integer]' is specifying the type of a function which is to follow.
16:50:57 <dons> hey, emk, congrats on the article you wrote yesterday. i think that really hit the mark for style in a blog post
16:51:01 <dibblego> dons contributes to Haskell as a whole more than I have seen many people in other communities contribut to their passion, ease up
16:51:02 <Cale> There seems to be something odd going on with the routing.
16:51:15 <dons> just the right mix of technical content, problem difficulty and so on, to work on the web
16:51:17 <shapr> jcreigh: More than that, it uses runtime recompilation of type-specific paths, aka poly-inline caching, to improve execution speed as the process runs.
16:51:18 <dataangel> dolio: So the :: operator is overloaded depending on whether you're working in a file or in the interpreter?
16:51:25 <chessguy> Cale: it was written by glguy, running on sjanssen's box, i believe
16:51:34 <Cale> I think it's just fixed itself.
16:51:41 * dataangel suspects syntactic sugar is hiding something
16:51:47 <shapr> Actually, now that I think about it, can't you get GHC to do the same thing with typeclass specialization?
16:51:49 <dolio> dataangel: :: isn't really an operator in the normal sense.
16:52:04 <Cale> For a while there, I wasn't getting through at all, and then my traceroutes started bouncing back and forth in an infinite loop between two boxes.
16:52:05 <LoganCapaldo> dataangel: It's not interperter vs. file its just context sensistive
16:52:24 <jcreigh> oh, so it notices that something is usually called with type x, so it compiles a version of that functions that's statically dispatched. cool. (like psyco. or maybe psyco is like it.)
16:52:31 <ddarius> "Java - We listen to ourselves... eventually."
16:52:34 <dolio> dataangel: It's more like a hint to the compiler/runtime than a function.
16:52:37 <chessguy> dons: anyway, i didn't mean it personally. it's not that i think you're doing something wrong, it's just that when you're active, there's a lot of discussion that goes way over the heads of us newbies
16:52:44 <LoganCapaldo> let f = a:: [Integer] is fine in a file too
16:52:46 <shapr> chessguy: So dive on in!
16:52:54 <emk> dons: Thanks! I got some good feedback from Reginald on the first draft. And I tweaked it slightly this morning, replacing mult456 with pair456 to make the jump from >>= to return a bit smoother.
16:53:06 <LoganCapaldo> but there its acting like it does in the interpreter
16:53:15 <shapr> chessguy: Can you show me something that you don't understand? I'd be happy to give you an info dump if it's something I understand.
16:53:18 <chessguy> shapr: i'm trying
16:53:35 <chessguy> shapr: it's a question from HSOE
16:53:41 <dataangel> LoganCapaldo: I would agree, the distinction being how it acts in top level code versus inside a let, except that putting blarg :: [Integer] into a file does not yield a type error if you haven't prior defined blarg, but in the interpreter it does.
16:53:43 <shapr> Ah, the fractal snowflake?
16:53:51 <dons> emk, right. i plan to use that article as a guide for future articles of mine, actually. on a number of presentational aspects, i think it got the balance right. so its a useful template :-)
16:53:58 <chessguy> yes, he goes from a very simple fractal to a much more complicated one
16:54:15 <LoganCapaldo> dataangel: well thats because in file blarg :: [Integer] declares blarg :)
16:54:31 <dataangel> LoganCapaldo: Why doesn't it do the same in the interpreter?
16:54:32 <chessguy> i understood the sierpinski, but for the snowflake, he seems to be requiring you to rotate a polygon, when he doesn't even define the data structure for a polygon
16:54:45 <dataangel> LoganCapaldo: Is there a way to declare things in the interpreter without let?
16:54:54 <LoganCapaldo> dataangel: Cause the interpreter is a magical mpalce where you can't do everything you can in a file :)
16:54:55 <ddarius> chessguy: Your question required people to know the exact exercise you were referencing though they may not have read that book.
16:55:51 <dataangel> LoganCapaldo: Although it's nice to understand now that it's due to a magical barrier, I can't help but feel this is a step down from say, python, or ocaml, where what you type into the interpreter and what you type into a file you can trust to match up in meaning :/
16:55:52 <dons> yeah, most of us don't have that book. if you can post the code though?
16:56:14 <chessguy> i don't really have any code to speak of yet
16:56:31 <LoganCapaldo> dataangel: its not really "magical", theres just no way for the interperter to disnguish between "evaluate this expression" and "make a top level declaraition"
16:56:37 <shapr> chessguy: Can you post the problem?
16:56:42 <LoganCapaldo> at least in the case of a :: [Integer]
16:56:55 <chessguy> yeah, let me paste the sierpinski code and the problem
16:56:57 <pjd_> dataangel: there's some value in separating interactive interpretation from compilation
16:56:58 <chessguy> !paste
16:57:03 <chessguy> @paste
16:57:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:57:09 <pjd_> most importantly, execution order matters in the former
16:57:12 <dataangel> LoganCapaldo: How does it distinguish it when reading a file?
16:57:21 <pjd_> but doesn't need to in the latter; especially with a language like haskell
16:57:29 <dataangel> pjd_: oooh, hadn't thought of that
16:57:30 <dolio> It doesn't. Everything in a file is a top-level declaration.
16:57:31 <jcreigh> dataangel: suppose you have a file that looks like
16:57:34 <jcreigh> y = x * 2
16:57:36 <jcreigh> x = 42
16:57:37 <LoganCapaldo> because in a file you can't evalute arbitrary expressions so it _must_ be a type annotation
16:57:45 <jcreigh> what is Haskell supposed to do if you type those interactively?
16:57:48 <pjd_> dataangel: Python and such are all imperative anyway, so there's less reason to seperate the two
16:57:52 <LoganCapaldo> You can't just have x + 1 hanging out in a file
16:58:26 <TSC> chessguy: I thought for the snowflake you just need to reflect, not rotate
16:58:32 <dataangel> LoganCapaldo: Well, assuming x is defined, that's perfectly valid in most languages :) in C: x + 1; // Not very useful but compiles
16:58:43 <pjd_> dataangel: that's also why you need the lets in the interpreter, but not in source
16:58:56 <LoganCapaldo> dataangel: Haskell isn't most languages :)
16:59:14 <pjd_> they're actually part of do syntax, which the interpreter is effectively wrapped in
16:59:14 <dolio> dataangel: You couldn't just have that in C unless it was within a function, no?
16:59:30 <LoganCapaldo> also, what dolio said
16:59:55 <dataangel> dolio: Well, it would have to at least be inside main, but that's arguably a syntax issue. It is valid in Python.
17:00:00 <ddarius> Bah. Forget them dataangel.  There is no good reason other than implementation simplicity to not allow the full Haskell language in the interpreter.
17:00:21 <LoganCapaldo> ddarius: I agree with that
17:00:30 <LoganCapaldo> I'm talking about the other way around :)
17:00:36 <dolio> dataangel: Yeah. Python and Ruby and the like are a bit odd in that respect. Making declarations *is* evaluating expressions (to some degree) in those languages.
17:00:38 <dons> Prelude> let x = y + 2 ; y = 7
17:00:38 <dons> Prelude> x
17:00:38 <dons> 9
17:00:38 <dons> Prelude> y
17:00:38 <dons> 7
17:00:41 <LoganCapaldo> with the random x + 1 floating in a file I don't like
17:00:41 <chessguy> TSC: reflect, rotate 180 degrees, makes little difference
17:00:46 <TSC> Doing a reflection around the horizontal axis is just (\ (x,y) -> (x,-y))
17:00:54 <dons> you can enter (mutually recursive) binding groups in blocks
17:01:02 <TSC> That's how I did the snowflake exercise
17:01:16 <dataangel> To be clear  -- anything top level inside a file is assumed to be a declaration?
17:01:34 <sjanssen> dons: can you test the latest xmonad patch?
17:01:40 <sjanssen> it seems to work here
17:01:52 <ddarius> dataangel: I'm not sure.  I believe so, but you could try it fairly quickly.
17:01:53 <dolio> dataangel: Yes, it has to be (I think).
17:01:56 <dons> trying ...
17:01:56 <chessguy> it doesn't seem to be announcing automatically
17:01:57 <chessguy> http://hpaste.org/966
17:02:09 <dons> dataangel: right. other than type or class decls
17:02:11 <dataangel> And haskell is coded for in a declaration context for :: to restrict type and in an expression context to be an expression...
17:02:19 <ddarius> dolio: It doesn't -have- to be, but it is rather pointless to allow top-level expressions.
17:02:33 <shapr> I know I've been doing Haskell too much when I type foo &&& bar in a shell command.
17:02:37 <dolio> ddarius: Well, yeah.
17:02:39 <dataangel> Interesting, so not everything in haskell is an expression then? e.g. a function definition doesn't evaluate to its definition or something like that.
17:02:54 <dons> shapr: i've written:    map foo *.hs
17:02:54 <ddarius> dataangel: Correct.=
17:03:01 <dons> in the shell. that's when you know you're brain is broken
17:03:03 <ddarius> dons: I want that.
17:03:12 <shapr> dons: hah... but wait, it actually worked since you had h4sh, right?
17:03:12 <dataangel> hrm, isn't everything an expression in lisp?
17:03:17 <shapr> dataangel: heck no
17:03:21 <dons> yeah :( it seems an obvious shell combinator
17:03:24 <sorear> i've done . in the shell
17:03:25 <dataangel> didn't code enough lisp ;)
17:03:40 <sorear> dataangel: somethings are macros :)
17:03:47 <dolio> That's better than typing 'exit' to end an IM conversation. I've done that.
17:03:50 <shapr> haha
17:03:55 <allbery_b> :q!
17:03:56 <dataangel> sorear: Err, yes, but once they're expanded?
17:04:08 <shapr> I typed :wq in #emacs once...
17:04:14 <shapr> I nearly got lynched.
17:04:23 <ddarius> shapr: That's great!
17:04:29 * shapr grins
17:04:34 <dataangel> shapr: That's bash.org worthy
17:04:36 <dolio> Back when I was playing a lot of MUDs, I'd sometimes accidentally type "say" before sentences in an IM window, too.
17:04:40 <LoganCapaldo> Everything is an expression in the "lisp" interpreter I wrote over the weekend. But it doesn't have  macros, and the garbage collector is a bunch of // TODO comments. So I don't think that counts ;)
17:04:46 <dons> sjanssen: do we need -threaded for getProcessStatus to be non-blocking?
17:05:01 <dataangel> LoganCapaldo: What does a function definition evaluate to?
17:05:07 <dataangel> (in your lisp)
17:05:08 <dons> (that will kill the zombie when it runs)
17:05:12 <LoganCapaldo> Its body, sort of
17:05:17 <shapr> dataangel: It would have more amusing if I hadn't done it on purpose just to get some levity in the channel :-) It wasn't really spontaneous.
17:05:18 <ddarius> dataangel: Every term has a value in Lisp.
17:05:27 <ddarius> Sort of.
17:05:35 <dataangel> gotta love corner cases
17:05:39 <sorear> some terms have SIDE EFFECTS!
17:05:45 <encryptio> EEK!
17:05:49 * sorear screams in terror
17:05:49 <shapr> But their type does not reflect it!
17:06:00 <sorear> Type?  What type?
17:06:00 <dataangel> it's OK, I'm already scarred up and protected against them from too much C++
17:06:03 * sorear flees
17:06:13 <Philippa_> shapr: careful, you could build a lisp where that was true in a rather unpleasant way
17:06:27 <shapr> Philippa_: oh?
17:06:40 <dons> sjanssen: looks good!
17:06:43 <Philippa_> consider what reflection normally means in a lisp context, and what lisp types are...
17:06:44 <dons> no more zombies.
17:07:03 <dons> sjanssen: so any thoughts on tagging/release schedule?
17:07:18 * shapr builds X11-extras
17:07:19 <dons> i want to strike before dev speed drops
17:07:29 <shapr> I say release it now.
17:07:38 <dons> shapr: i've been using xmonad for a week now . not going back to dwm anymore :-)
17:07:44 <dons> shapr: the issue is missing features.
17:07:45 <shapr> Throw thy bread upon the waters and all that.
17:07:51 <chessguy> ?hoogle round
17:07:51 <encryptio> :t []
17:07:52 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
17:07:52 <dons> it does full screen stacked windows, on multiple workspaces
17:07:52 <lambdabot> Text.Html.background :: String -> HtmlAttr
17:07:52 <lambdabot> System.Win32.Info.cOLOR_BACKGROUND :: SystemColor
17:07:52 <kc5tja> What is xmonad?
17:07:54 <lambdabot> forall a. [a]
17:07:57 <dons> which is ideal for laptop use
17:07:59 <shapr> @where xmonad
17:08:00 <chessguy> ?src Prelude.round
17:08:00 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
17:08:00 <lambdabot> Source not found. The more you drive -- the dumber you get.
17:08:04 <dons> but for larger screens, people can't tile windows
17:08:07 <chessguy> ?src round
17:08:08 <lambdabot> Source not found. You type like i drive.
17:08:11 <dons> kc5tja: its a window manager sjanssen and i've been writing
17:08:18 <shapr> @index round
17:08:19 <lambdabot> Prelude
17:08:20 <dons> and using, actualy. i use it full time now.
17:08:28 <kc5tja> dons: Name was changed?  I thought it was called Thuk.
17:08:30 <kc5tja> Thunk even.
17:08:33 <dons> right.
17:08:37 <dons> hard to google for
17:08:45 <chessguy> @pl -> \x -> r (100*x)
17:08:45 <lambdabot> (line 1, column 1):
17:08:46 <lambdabot> unexpected "-"
17:08:46 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
17:08:48 <dolio> To be honest, I kind of like thunk better. :)
17:08:49 <shapr> Well, I just dumped ion3, and I didn't like dwm so much. wmii is passable, but I'm not enthusiastic either.
17:08:50 <encryptio> is xmonad compatible with rootless X11?
17:08:53 <chessguy> @pl \x -> r (100*x)
17:08:54 <lambdabot> r . (100 *)
17:09:16 <shapr> So it's time for a change!
17:09:21 <dons> encryptio: hmm. its just an X client. i don't know anything about rootless X11 though...
17:09:22 <dataangel> Since the prelude list functions use Int instead of Integer by convention, is most of the Haskell code out there as overflow/underflow vulnerable as C?
17:09:25 <sjanssen> encryptio: would I know if it did?
17:09:34 <kc5tja> dons: Hmm...I'll have to give it a shot.  If I like it, I'll be glad to volunteer as a package maintainer for GoboLinux.  :)
17:09:43 <sjanssen> if I would know, then it probably doesn't
17:09:46 <dons> shapr: its rather stable, and *small*, but missing tiling, the main feature of ion/wmii/dwm/
17:09:46 <LoganCapaldo> @type genericLength
17:09:50 <lambdabot> forall b i. (Num i) => [b] -> i
17:10:00 <shapr> Hm, I do use tiling for kopete.
17:10:04 <shapr> But not anything else.
17:10:16 <kc5tja> In Ion, I use tiling mostly for when I run gimp.
17:10:19 <chessguy> @pl \n -> i (n/k)
17:10:20 <lambdabot> i . (/ k)
17:10:21 <encryptio> rootless X11 is a way to run X11 without a root window - instead those events "fall through" to another windowing system. in my case, aqua/quartz.
17:10:24 <dons> dataangel: usually Int is only used for indicies
17:10:24 <sjanssen> shapr: tiling is Coming Soon To A Darcs Repository Near You
17:10:30 <kc5tja> Put up a tile for the toolbar, and the rest is for the workspace windows.
17:10:38 <dons> and indexing structures is far less common than in array/C-style languages
17:10:40 <encryptio> which means you can't, for example, right click on the desktop
17:10:49 <dons> overflow for Int is an isue, in which case you use the Integer functions
17:10:57 <dons> :t genericLength -- for example
17:10:58 <shapr> sjanssen: Ok!  I'm switching now!
17:11:00 <lambdabot> forall b i. (Num i) => [b] -> i
17:11:11 <shapr> sjanssen: When do you expect tiling?
17:11:16 <kc5tja> dons: Is there going to be a document written about your experiences coding Thunk/XMonad in comparison to other languages?  I'd love to read it if you are.  :)
17:11:27 <dons> kc5tja: yes, we plan to write one for TMR
17:11:29 <kc5tja> A code walk-through document would be cool too.
17:11:30 <shapr> Yay!
17:11:31 <dons> in fact, full source and text
17:11:37 <dons> since the entire code is grokable, imo
17:11:49 <dolio> Well, Bill Mill will be pleased. :)
17:11:53 <sjanssen> shapr: it depends on my productivity, which is incredibly hard to predict :)
17:12:00 <kc5tja> Grokable if you know X, and if you are at a certain minimum level of Haskell competency.  :)
17:12:10 <shapr> sjanssen: I know that feeling..
17:12:28 <shapr> sjanssen: Somedays I'm Productive Coder #1, somedays I am only Waste Of Space.
17:12:32 <dons> sjanssen: if you can stub out the design, i might be able to do some of the grunt work on tiling
17:12:42 <dons> sjanssen: maybe port the tiling algo?
17:12:42 * kc5tja is *usually* waste of space.  :(
17:12:48 <shapr> sjanssen: But I found out something that really helps for me, and probably will help for anyone on #hasell... Pair programming!
17:12:53 <dons> kc5tja: had a change to look at the code I sent... ? :-)
17:12:54 <shapr> er, #haskell
17:13:02 <kc5tja> dons: Not yet; still at work.
17:13:19 <shapr> sjanssen: You got a mic, a voip program and a vnc server?
17:13:32 <kc5tja> And I can't SSH to my box at home, because some *DORK* decided to install OpenSSH on it without turning sshd on.  ;D
17:13:40 <dons> heh
17:13:55 <kc5tja> Like I said -- total waste of space today.  :)
17:14:02 <dons> sjanssen: can you summarise what we need for tiling?
17:14:05 <sjanssen> shapr: I could probably arrange to have those things
17:14:07 <kc5tja> Absolutely no productivity for the past three days.
17:14:11 <dons> i'd be inclined to hold off 0.1 until tiling is done then
17:14:15 <shapr> sjanssen: go for it.
17:14:31 <dons> we need to track the tiling of each stack in the StackSet?
17:14:42 <sjanssen> dons: the StackSet structure needs to change, then I believe there are some things involved with focus
17:14:43 <dons> and then have a mode bit for tiled v floating modes?
17:15:01 <dons> such that 'refresh' renders differently, and 'manage'
17:15:03 <encryptio> is there some document other than the report that explains, in detail, what newtype is for?
17:15:06 <dons> (no full screen resizing)
17:15:18 <sjanssen> yes
17:15:38 <dons> encryptio: it lets you introduce a new type, with the same representation as an existing type
17:15:45 <kc5tja> Here's a question that's been burning in my mind.  Does Haskell rhyme with Pascal?  How *is* it supposed to be pronounced?
17:16:03 <dons> so you can write instances for this new type, for example
17:16:07 <shapr> kc5tja: Simon Peyton-Jones says HASK-ull
17:16:24 <emk> Really awesome backtracking monad paper: http://okmij.org/ftp/Computation/monads.html#LogicT
17:16:25 <lambdabot> Title: Monads
17:16:27 <shapr> I say Has-KELL
17:16:33 <encryptio> dons: awesome. that actually makes sense. =D
17:17:03 <dons> one really nice (advanced) use is newtype'd monads
17:17:11 <dons> you define a new monad type in terms of an existing monad
17:17:18 <dons> and can then *derive* all the instance code for free
17:17:23 <encryptio> i.e. the X monad?
17:17:26 <dons> using ghc's cunning newtype deriving
17:17:29 <dons> i.e. the X monad.
17:18:04 <dons> and yet still be sure you don't mix your new monad code accidentally with the underlying monad you define it in terms of
17:18:05 <sorear> "01001000011000010111001101101011011001010110110001101100"
17:18:20 <ddarius> dons, sjanssen: Is the darcs repo available -somewhere- right yet?  And can you whip up a screen shot?
17:18:25 <kc5tja> shapr: So the jury's still out on that one, I take it.  I tend to pronounce it Has-KELL as well, which is why I was wondering.
17:18:50 <sorear> I (wishfully) pronounce haskell as <modem tones>
17:18:55 <dolio> kc5tja: Just find a .wav of Haskell Curry pronouncing his own name or something. :)
17:18:57 <encryptio> has-kell
17:19:08 <sjanssen> @where xmonad
17:19:08 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
17:19:09 <sorear> @goog Simon PJ Says Haskell
17:19:11 <lambdabot> http://www.mail-archive.com/haskell-prime@haskell.org/msg02096.html
17:19:11 <lambdabot> Title: Re: rank-2 vs. arbitrary rank types
17:19:13 <sjanssen> ddarius: ^^^
17:19:15 <sorear> @goog Simon Says Haskell
17:19:18 <lambdabot> http://www.brics.dk/~amoeller/dProgSprog/Haskell-advanced.pdf
17:19:30 <ddarius> sjanssen: Thanks.
17:19:36 <zbrown> Are there any SS's of xmonad?
17:19:37 <LoganCapaldo> I too was wondering the pronunciation thing
17:19:54 <sjanssen> ddarius, zbrown: a screenshot is useless right now, xmonad makes the active window take up the whole screen
17:20:04 <dons> ddarius: http://www.cse.unsw.edu.au/~dons/tmp/thunk/thunk-bg.png (background), http://www.cse.unsw.edu.au/~dons/tmp/thunk/thunk-live.png (fg)
17:21:04 <dons> note the use of dmenu in the bg shot, to launch apps
17:21:18 <ailndx> dons: is that blue book any good?
17:21:19 <sorear> dons: nice obsolete index :) : http://www.cse.unsw.edu.au/~dons/tmp/index.html
17:21:42 <dons> ailndx: it was a good book to learn programming from.
17:21:46 <ddarius> sjanssen: Good.  dons: Thank
17:21:48 <dataangel> Why does this implementation of scanl keep going until the list is empty and throw a Prelude.head exception? http://hpaste.org/967
17:21:48 <encryptio> okay, "rootless compatibility" question rephrased: is there any functionality that is avaliable solely through clicking on the desktop (root window)?
17:22:07 <zbrown> sjanssen: oic
17:22:12 <dons> nope, encryptio.
17:22:15 <sjanssen> encryptio: no
17:22:22 <dons> clicking??
17:22:27 <dons> what is this 'clicking' you speak of :-)
17:22:30 <sjanssen> heh
17:22:31 <ailndx> dons: was or is.. is Graham's book better?
17:22:35 * ddarius wishes he had programming books lying about his desk.
17:22:44 <dons> Graham's book is equivalent. both would be good.
17:22:54 <encryptio> my desk is my carpet
17:24:23 <Cale> @seen bringert
17:24:24 <lambdabot> I saw bringert leaving #haskell 13h 37m 50s ago, and .
17:24:54 <LoganCapaldo> err is there no more annoucing of things?
17:24:59 <Cale> What is that trailing ", and " for?
17:25:14 <Cale> LoganCapaldo: announcing of what?
17:25:20 <LoganCapaldo> pastes?
17:25:22 <Cale> hmm
17:25:32 <LoganCapaldo> dataangel: http://hpaste.org/967#a1
17:25:37 <Cale> hpaste.org was struggling a moment ago, perhaps the IRC bot died
17:25:46 <dataangel> I told it not to announce
17:25:52 <dataangel> wasn't sure if that was appropriate
17:25:56 <roconnor> @src List
17:25:57 <lambdabot> Source not found. It can only be attributed to human error.
17:26:04 <roconnor> @src List.inits
17:26:04 <lambdabot> Source not found. Take a stress pill and think things over.
17:26:10 <dons> @src init
17:26:11 <lambdabot> init [x]    = []
17:26:11 <lambdabot> init (x:xs) = x : init xs
17:26:11 <lambdabot> init []     = undefined
17:26:14 <sorear> dataangel: if it wasn't appropriate it wouldn't be the default!
17:26:16 <sorear> :)
17:26:18 <Cale> the original code doesn't have a polymorphic enough type
17:26:18 <dons> @source List
17:26:19 <lambdabot> List not available
17:26:23 <Cale> range == []
17:26:26 <dons> @source Data.List
17:26:27 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
17:26:28 <LoganCapaldo> And I made sure to announce my silly annotation
17:26:33 <Cale> that causes range to need an Eq constraint
17:26:41 <roconnor> @src inits
17:26:41 <lambdabot> inits []     =  [[]]
17:26:41 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
17:26:42 <LoganCapaldo> which was why I wondered why I didn't ge tno beeping from my client :)
17:27:00 <shapr> Yay, hpaste.org is back!
17:27:11 <shapr> That's especially nice since it's my mailserver.
17:27:22 <Cale> shapr: how long was it down? It looked like it was having routing issues.
17:27:36 <roconnor> > inits (1:undefined)
17:27:38 <dataangel> Cale: And range doesn't have an Eq constraint?
17:27:38 <lambdabot>  Undefined
17:28:02 <roconnor> > (inits (1:undefined))!1
17:28:03 <lambdabot>  Couldn't match expected type `Array i e'
17:28:04 <Cale> dataangel: well, it's a value of type a in your signature, and you didn't have an "Eq a =>" at the start
17:28:07 <roconnor> > (inits (1:undefined))!!1
17:28:08 <lambdabot>  Undefined
17:28:13 <roconnor> > (inits (1:undefined))!!0
17:28:14 <lambdabot>  []
17:28:19 <Cale> dataangel: never test that a list is empty using == []
17:28:27 <Cale> always use null or pattern matching
17:28:28 <roconnor> how come (inits (1:undefined))!!1 isn't [1]?
17:28:29 <shapr> Cale: Not sure, half an hour maybe?
17:29:01 <ddarius> > inits (1:undefined)
17:29:03 <lambdabot>  Undefined
17:29:22 <Cale> Prelude Data.List> inits (1 : undefined)
17:29:22 <Cale> [[]*** Exception: Prelude.undefined
17:29:23 <ddarius> > head $ inits (1:undefined)
17:29:25 <lambdabot>  []
17:29:33 <dataangel> pattern matching with scanLeftHelper f n [] = [] has the same problem
17:29:45 <nmessenger> > take 1 $ inits (1:undefined) !! 0
17:29:47 <lambdabot>  []
17:30:25 <ddarius> rconnor: The definition of inits given above does force the second element of the list to return the first.
17:30:26 <Cale> dataangel: uh, you also noticed the lowercase l problem?
17:30:26 <encryptio> dataangel: no, it doesn't - the use of == requires the type class Eq. pattern matching doesn't.
17:30:30 <nmessenger> > inits [1..4]
17:30:32 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4]]
17:30:52 <Cale> your spellings of scanLeftHelper aren't the same
17:31:01 <nmessenger> > take 1 $ inits (1:undefined) !! 1
17:31:03 <lambdabot>  Undefined
17:31:03 <dataangel> doh ;_;
17:31:28 <Cale> but yeah, use pattern matching instead of head and tail
17:31:36 <Cale> head and tail are inherently dangerous functions
17:31:54 <Cale> So if you can avoid them, it's usually a good idea.
17:31:55 <shapr> dataangel: What's ;_; ?
17:32:00 <shapr> oh, tears?
17:32:00 <encryptio> crying
17:32:02 <shapr> aha
17:32:14 <shapr> I still think <3 looks like testicles. I guess I need a different font.
17:32:30 <nmessenger> well, not much more dangerous than not handling the null case otherwise
17:32:34 <dataangel> lol
17:32:35 <Cale> <3 looks like less than 3 :)
17:32:42 <shapr> Cale: Oh, good point!
17:32:43 <jcreigh> shapr: 3B5F3B :)
17:32:54 <shapr> jcreigh: er?
17:32:57 <Pseudonym> I am less than 3 (mod NY).
17:33:04 <jcreigh> ;_;
17:33:06 <shapr> g'day Pseudonym!
17:33:10 <Cale> Pseudonym: haha
17:33:10 <Pseudonym> G'day.
17:33:22 <dataangel> Cale: Curious, why is the syntax (x:xs) instead of [x:xs]?
17:33:36 * Pseudonym has had a productive morning
17:33:38 <Pseudonym> Lots of STM
17:33:38 <encryptio> :t (:)
17:33:38 <ddarius> dataangel: Because Haskell isn't Prolog.
17:33:41 <lambdabot> forall a. a -> [a] -> [a]
17:33:42 <dons> Pseudonym: nice.
17:33:44 <Cale> dataangel: [x:xs] is a list with one element which is a list whose head is x and tail is xs
17:33:44 <chessguy> @pl f (E r s) = p * r * s
17:33:45 <lambdabot> (line 1, column 11):
17:33:45 <lambdabot> unexpected "="
17:33:45 <lambdabot> expecting variable, "(", operator or end of input
17:33:46 <nmessenger> [x:xs] = ((x:xs):[])
17:33:50 <shapr> Pseudonym: Awesome! What are you writing?
17:33:53 <dons> Pseudonym: btw, that amd64 offer is still standing, if you need it
17:33:56 <Pseudonym> shapr: Oooh, it's half a secret.
17:33:58 <ddarius> dataangel: Or more seriously, there is nothing special about lists, parens are used for all patterns.
17:33:59 <Pseudonym> Great, thanks dons.
17:34:03 <sjanssen> dataangel: Haskell uses the same syntax for construction and pattern matching
17:34:08 <chessguy> @pl \(E r s) -> p * r * s
17:34:08 <lambdabot> (line 1, column 5):
17:34:09 <lambdabot> unexpected "r"
17:34:09 <lambdabot> expecting operator or ")"
17:34:19 <Pseudonym> shapr: I'll describe it on haskell-blah if you like.
17:34:23 <LoganCapaldo> > let x = 1; xs = [2,3] in ([x:xs], x:xs)
17:34:24 <lambdabot>  ([[1,2,3]],[1,2,3])
17:34:33 <Pseudonym> dons: We're currently downloading data, and we'll probably post you a DVD with it on.
17:34:43 <dons> ah ok. that's a good idea.
17:35:12 * Cale wonders where Hope went.
17:35:19 <Cale> @where hope
17:35:19 <lambdabot> http://hope.bringert.net/
17:35:29 <Cale> hmm, that server seems broken
17:35:34 * ddarius was totally thinking of the programming language.
17:35:55 <bringert> Cale: hmm, that's odd
17:36:20 <dons> anyone want to get into forkIO/par programming, and rewrite this as a haskell tutorial: http://matt.blogs.it/entries/00002513.html
17:36:21 <lambdabot> Title: A first concurrency in Erlang
17:36:39 <encryptio> me me me!
17:36:45 <dataangel> Cale: Oh :P Right. How does it decide that x should correspond to the first element and xs should correspond to the tail? For "myfunc (a:b:c:d) = d" will a b c correspond to the first 3 elements and then d be the tail? I think that's the behavior I'm seeing..
17:36:50 <sorear> bah
17:36:50 <bringert> Cale: try again
17:36:58 <Cale> dataangel: right
17:37:04 <dons> dataangel: right.
17:37:05 <bringert> Cale: I had to kill the fastcgi process for some reason
17:37:10 <sorear> the Hugs grammar has totally broken rules for type precedence :(
17:37:13 <encryptio> (if i was better at haskell in general... i probably would)
17:37:23 <Cale> bringert: ah, cool, now I can safely refer to it in my blog comment :)
17:37:31 <bringert> Cale: I should change the exception handling to kill the process after that sort of error
17:37:44 <dons> > let ls = (1:2:3:[4,5,6]) ; f (a:b:c:rest) = b in f ls
17:37:46 <lambdabot>  2
17:38:03 <dons> dataangel: so the key is that the same syntax is used for building up a data structure, and taking it apart
17:38:05 <nmessenger> (a:(b:(c:d))), (b:(c:d)) is a's tail, (c:d) is b's tail, d is c's tail, etc.
17:38:06 <jcreigh> dataangel: (a:b:c:rest) = (a:(b:(c:rest)))
17:38:18 <dons> which is moderately unusual (and really useful!)
17:38:21 <jcreigh> dataangel: pattern matches can nest
17:38:29 <dons> most languages don't support pattern matching on data like this.
17:38:30 <sorear> man I wish yacc supported `sepBy`
17:38:30 <ddarius> halipeto simply been idling?
17:38:34 <Cale> It seems like two of your "Other web sites using hope" links are broken, not that you can do much about it but bug xerox and jgrimes
17:38:40 <shapr> ddarius: I think so.
17:38:58 <sorear> Cale: *** bringert (n=bringert@3-1-5-7a.gva.gbg.bostream.se) has quit:
17:38:59 <shapr> Cale: He's gone
17:39:07 <dons> > 1 : (2 : (3 : [4,5,6]))
17:39:08 <lambdabot>  [1,2,3,4,5,6]
17:39:09 <Cale> er, oops
17:39:23 <dons> > [1,2,3,4,5,6] -- special syntax for (:) and []
17:39:25 <lambdabot>  [1,2,3,4,5,6]
17:39:25 <roconnor> > let f False = [False,True]; f True = [True,False]; tm = (f False)++(tail tm >>= f) in map (\x -> if x then '1' else '0') tm
17:39:26 <lambdabot>  "011010011001011010010110011010011001011001101001011010011001011010010110011...
17:39:30 <sorear> ooh
17:39:48 <sorear> *** dcoutts__ (n=duncan@wireless-093.wireless.cse.unsw.EDU.AU) <-- unsw eh?
17:39:48 <Cale> > 1:2:3:4:5:6:[]
17:39:50 <lambdabot>  [1,2,3,4,5,6]
17:39:51 <dataangel> Cale: Hmm... functest (a:b:c) = c seems to fail whenever I call it.
17:39:55 <shapr> sorear: I was just wondering that myself.
17:39:59 <dons> > let f False = [False,True]; f True = [True,False]; tm = (f False)++(tail tm >>= f) in map (head.show.fromEnum) tm
17:40:00 <lambdabot>  "011010011001011010010110011010011001011001101001011010011001011010010110011...
17:40:03 <nmessenger> @check (\x y z -> (x : (y : (z : []))) == [x,y,z]) :: I->I->I->Bool
17:40:05 <roconnor> > let f x = [x,not x]; tm = (f False)++(tail tm >>= f) in map (\x -> if x then '1' else '0') tm
17:40:05 <lambdabot>  OK, passed 500 tests.
17:40:06 <lambdabot>  "011010011001011010010110011010011001011001101001011010011001011010010110011...
17:40:09 <Cale> dataangel: are you calling it with a list that has at least two elements?
17:40:13 <mauke> > let functest (a:b:c) = c in functest [1,2,3,4,5]
17:40:15 <lambdabot>  [3,4,5]
17:40:15 <dcoutts__> sorear: aye
17:40:20 <roconnor> > let f x = [x,not x]; tm = (f False)++(tail tm >>= f) in map (head.show.fromEnum) tm
17:40:21 <lambdabot>  "011010011001011010010110011010011001011001101001011010011001011010010110011...
17:40:24 <abz> how do you view the haskell TH generates?
17:40:29 <dons> mornfall: dcoutts__
17:40:30 <abz> can?
17:40:32 <encryptio> dataangel: that's probably because you forgot about the one element list, which doesn't match (_:_:_) or []
17:40:36 <dons> abz, you can -ddump-* something it.
17:40:39 <dcoutts__> hia dons
17:40:43 <dons> abz, there's a flag
17:40:45 <abz> thanks
17:40:47 <sorear> -ddump-splices iirc
17:41:14 <dcoutts__> dons: btw, ghc head also doesn't repect noinline on things defined in a where clause
17:41:19 <dataangel> encryptio: Hrm, adding a generic case doesn't fix it
17:41:26 <dons> dcoutts__: bug report time?
17:41:37 <encryptio> dataangel: post code...
17:41:40 <dataangel> k
17:41:48 <dcoutts__> dons: time to find out what we said last time I asked SPJ about this
17:41:56 <sorear> @paste -- dataangel: here
17:41:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:41:57 <dcoutts__> @localtime dcoutts_
17:41:58 <lambdabot> Local time for dcoutts_ is Wed Mar 14 00:41:03
17:42:06 <dons> @time dcoutts__
17:42:08 <lambdabot> Local time for dcoutts__ is Wed Mar 14 11:41:12
17:42:15 <dons> yikes! you should be asleep!
17:42:16 <sorear> @time dcoutts
17:42:19 <dcoutts__> hah hah
17:42:26 <dcoutts__> dcoutts is offline
17:42:32 <dons> it must be fun having a clone
17:42:37 <dcoutts__> @arr
17:42:37 <lambdabot> Aye Aye Cap'n
17:42:40 <dons> so you can live in timezones 11 hours apart
17:42:52 * dcoutts__ grins
17:43:04 <sorear> what timezone do they use at the South Pole?
17:43:06 <dataangel> http://hpaste.org/968
17:43:14 <shapr> sorear: Depends where you're standing :-)
17:43:22 <sjanssen> sorear: depends on which direction you lean
17:43:24 <dcoutts__> sorear: winter or summer I think :-)
17:43:33 <encryptio> dataangel: that doesn't typecheck
17:43:33 <dons> night or day.
17:43:33 <Igloo> They work in GMT IIRC
17:43:58 <shapr> Though if you live near the arctic circle, you truly have winter and summer, just as dcoutts says.
17:44:03 <encryptio> dataangel: you're returning a number in the first and last, but a list in the second
17:44:13 <LoganCapaldo> dataangel: c is a list
17:44:33 <dataangel> oh right.. :P
17:44:34 <Igloo> How long are you over there for, dcoutts?
17:44:36 <LoganCapaldo> you want [3] and [9] to be your defaults
17:44:41 <dcoutts__> Igloo: 6 weeks
17:44:55 <LoganCapaldo> Or something like that
17:45:45 <dataangel> now it's behaving as expected :)
17:45:59 <LoganCapaldo> How'd you sneak it past the type checker anyway?
17:46:13 <dataangel> no idea, it just didn't complain
17:46:26 <roconnor> > let tm = (f False)++(tail tm >>= flip map [id,not]) in map (head.show.fromEnum) tm
17:46:27 <lambdabot>   Not in scope: `f'
17:46:40 <LoganCapaldo> @type (\(a:b:c) -> c)
17:46:42 <lambdabot> forall t. [t] -> [t]
17:46:49 <LoganCapaldo> @type 9
17:46:52 <lambdabot> forall t. (Num t) => t
17:46:53 <roconnor> > let tm = [False,True]++(tail tm >>= flip map [id,not]) in map (head.show.fromEnum) tm
17:46:54 <lambdabot>  Couldn't match expected type `(Bool -> Bool) -> Bool'
17:47:41 <dataangel> Does haskell not support function overloading because it's intractable to make it work with pattern matching?
17:48:06 <shapr> What do you mean by function overloading?
17:48:13 <LoganCapaldo> depends on what you mean by overloading
17:48:17 <roconnor> @type sequence
17:48:19 <jcreigh> dataangel: no, because then type inference would be really, really hard.
17:48:20 <lambdabot>     Ambiguous occurrence `sequence'
17:48:20 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
17:48:27 <Lemmih> > (show False, show 123)
17:48:28 <lambdabot>  ("False","123")
17:48:33 <roconnor> @type Control.Monad.sequence
17:48:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:48:44 <dataangel> by overloading I mean letting me define another function with the same name but that has different return and parameter types
17:48:48 <roconnor> > let tm = [False,True]++(tail tm >>= sequence [id,not]) in map (head.show.fromEnum) tm
17:48:57 <LoganCapaldo> dataangel: You can do that with haskell
17:49:04 <LoganCapaldo> it just has to be in a type class
17:49:09 <sorear> @faq Can I overload functions?
17:49:10 <lambdabot> The answer is: Yes! Haskell can do that.
17:49:11 <roconnor> @botsnack
17:49:11 <nominolo> ?where SoC
17:49:12 <lambdabot> :)
17:49:12 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
17:49:16 <dataangel> which I assume haskell doesn't, since otherwise it would just assume that's what I was doing with my inconsistent definition, sometimes returning an integer and sometimes returning a list
17:49:18 <Lemmih> dataangel: It interacts badly with typing.
17:49:20 <roconnor> > let tm = [False,True]++(tail tm >>= sequence [id,not]) in map (head.show.fromEnum) tm
17:49:31 <shapr> dataangel: You can get close to that with typeclasses.
17:49:33 <dons> hey shapr, random productivity thought, i think full screen window managers improve concentration
17:49:35 <jcreigh> LoganCapaldo: what? Different return a parameter types?
17:49:36 <roconnor> lambdabot?
17:49:39 <shapr> dons: Oh, I totally agree.
17:49:41 <encryptio> dataangel: there are polymorphic types (with general types and type classes), but nothing like "this can take a pair of ints and sum them or a pair of strings and concantenate them"
17:49:43 <jcreigh> s/\<a\>/and/
17:49:45 <LoganCapaldo> If you couldn't overload like that, >>= would totally suck
17:49:49 <shapr> dons: But sometimes my boss doesn't like that =)
17:49:50 <dons> just reading http://www.thatvoodooyoudo.com/best-practice/flow/
17:49:51 <lambdabot> Title: That Voodoo You Do &middot; Flow: Get into the Zone at Work
17:50:01 <jcreigh> LoganCapaldo: oh, I see what you mean
17:50:06 <LoganCapaldo> encryptio: sure you could
17:50:09 <dataangel> haskell is cool ^^
17:50:10 <Pseudonym> dons: Cool!  I'll read that!  Sounds much more fun than working...
17:50:13 <nmessenger> dataangel: you might also use sum types like Either to return different types
17:50:15 <LoganCapaldo> its just not done generally
17:50:26 <dons> Pseudonym: hehe
17:50:48 <dataangel> Anyone know where I can get an internship coding it over the summer somewhere around detroit? ;)
17:51:03 <nmessenger> @type \x -> if even x then Left "even!" else Right False
17:51:04 <roconnor> > 5
17:51:06 <dons> dataangel: the google summer of code
17:51:07 <lambdabot>  5
17:51:07 <lambdabot> forall a. (Integral a) => a -> Either [Char] Bool
17:51:07 * dataangel is probably going to end up hacking visual basic or some other abomination
17:51:13 <dons> dataangel: we take applications starting tomorrow, iirc
17:51:17 <roconnor> > take 20 $ let tm = [False,True]++(tail tm >>= sequence [id,not]) in map (head.show.fromEnum) tm
17:51:30 <roconnor> :'(
17:51:32 <dons> ?where soc
17:51:32 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
17:52:02 <nmessenger> roconnor: LB for some reason doesn't say the error message, sequence is ambiguous, you need to qualify
17:52:16 <dons> nmessenger: yes. bug.
17:52:23 <roconnor> whose bright idea was it to add a sequence to Control.Monad.Writer?
17:52:27 <shapr> dons: Best way to improve concentration... grab all the source and papers you need and put them into one dir on a newly installed machine... pull the network cable, remove the wifi card, etc. Then make sure you have a steady supply of munchies and drinks.
17:52:36 <roconnor> > take 20 $ let tm = [False,True]++(tail tm >>= Control.Monad.sequence [id,not]) in map (head.show.fromEnum) tm
17:52:37 <lambdabot>  "01101001100101101001"
17:52:39 <nmessenger> @index sequence
17:52:40 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
17:52:44 <dataangel> dons: I've actually thought of that, but I did SoC last year and didn't finish my project due to an RL conflict. Not a ringing endorsement for applying again ;p
17:52:51 <nmessenger> same bright guy who put it everywhere else :D
17:53:15 <roconnor> @type Control.Monad.Writer.sequence
17:53:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:53:19 <shapr> dons: I was horrendously productive the weekend I spammed MAC addresses into my ISPs switch for a network test and got locked out until Monday.
17:53:31 <mwc> The best way for me to improve concentration is to kill irc
17:53:33 <roconnor> nmessenger: what's going on?  Why is it ambiguous?
17:53:39 <mwc> of course, I come on when I get stuck... and I stay on.
17:54:34 <nmessenger> *shrug*  I'm not sure.
17:55:32 <sjanssen> roconnor: there's a conflicting definition exported from Data.Traversable
17:55:46 <roconnor> @hoogle sequence
17:55:47 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
17:55:47 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
17:55:47 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
17:56:03 <sjanssen> I think this hoogle index is too old to have it
17:56:07 <shapr> Other useful ways to improve concentration include, regular daily exercise of 1 hour or more, Regular eating times, regular sleeping and waking times, no caffeine, no nicotine, minimal sugar intake, doing things on time so you know that you can concentrate on this task and not have to worry about something else interrupting...
17:56:18 <roconnor> sjanssen: oh, I see.  It isn't Control.Monad.Writer's fault.
17:56:51 <roconnor> dons: should we have Data.Traversable imported as qualified?
17:56:53 <shapr> I could go on, but it's pretty much the responsible accountant's life.
17:56:58 <roconnor> or hiding sequence?
17:58:36 <sorear> actually, Data.Traversable.sequence is strictly more general
17:58:51 <sorear> so we should just hiding sequence on Prelude, C.M.*
17:58:58 <sorear> hello!
17:59:01 <roconnor> oh
17:59:19 <nmessenger> @type Data.Traversable.sequence
17:59:22 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Traversable t, Monad m) => t (m a) -> m (t a)
17:59:36 <dataangel> Does GHC do any sort of optimization for replacing Integer's with Int's?
17:59:37 <LordBrain> @type run
17:59:39 <lambdabot> Not in scope: `run'
17:59:43 <encryptio> :t finally
17:59:45 <lambdabot> Not in scope: `finally'
17:59:46 <LordBrain> @type Process.run
17:59:49 <lambdabot> Couldn't find qualified module.
17:59:53 <nmessenger> @instances-importing Data.Traversable Traversable
17:59:55 <lambdabot> Maybe, []
18:00:30 <kc5tja> OK, back home.  Now, to play with building a package.
18:00:44 <sorear> dataangel: no.
18:01:09 <sorear> dataangel: however integers are ints if small enough, so all you pay is a conditional
18:01:20 <sorear> does GHC do any kind of points-to analysys?
18:01:42 <LordBrain> dons used the command 'run' on his blog
18:02:02 <LordBrain> http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons
18:02:04 <lambdabot> Title: Haskell hacking, http://tinyurl.com/ywdjsr
18:02:12 <sjanssen> LordBrain: run is a command from a prototype library
18:02:22 <LordBrain> hmm
18:02:54 <roconnor> run :: String -> Shell String
18:02:54 <roconnor>     run = io . Process.run
18:03:22 <roconnor> oh wait
18:03:24 <roconnor> nevermid
18:03:25 <sjanssen> LordBrain: http://www.cse.unsw.edu.au/~dons/code/cpuperf/Process.hs
18:03:27 <LordBrain> Process.run.. thats what he used...
18:03:37 <nmessenger> http://www.cse.unsw.edu.au/~dons/code/cpuperf/Process.hs
18:04:01 <LordBrain> i see
18:04:14 <LordBrain> sort of dons' home grown utilities?
18:04:48 <nmessenger> looks like a handy runInteractiveProcess wrapper
18:05:16 <nmessenger> he links to it in the post
18:05:24 <nmessenger> under "A Haskell translation"
18:06:26 <dons> LordBrain: yeah, its actually based on newpopen
18:06:28 <dons> ?where newpopen
18:06:28 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/newpopen
18:06:36 <dons> which i should finish and release some day.
18:07:02 <dons> before ghc 6.8 comes out
18:07:43 <sjanssen> dons: a handy thing for a process library: add functions that start a process as a non-child
18:08:32 <dons> sjanssen: can you write a plan for what needs to be done to get tiling in? and stick in in the TODO
18:08:34 <ailndx> 6.8? is 6.7 released?
18:08:43 <sjanssen> dons: yeah
18:08:45 <dons> if its simpler and clear, i can maybe break off some of the pieces in my daily bus trips to uni
18:08:52 <dons> ailndx: 6.7 is the unstable branch
18:08:57 <dons> when it goes stable, it gets called 6.8
18:09:02 <ailndx> k
18:09:06 <dons> which is then maintained while 6.9 gets worked on
18:09:15 <dons> until it becomes stable. then 6.8 is abandoned. and 7.0 is release
18:09:24 <dons> ghc 7.0, where all your lambdas belong to us
18:09:27 <encryptio> no 6.10?
18:09:42 <dons> 6.A
18:09:42 <LordBrain> I like that you're writing about doing shell stuff in haskell. I'd like to do my shell scripts that way.. especially since i'm working in c++ now... it's nice to squeeze some haskell in however i can..
18:10:02 <dons> LordBrain: yeah, i've given up on explict sh code now for anything > 10 lines
18:10:12 <dons> it just doesn't scale, and scripts always seem to grow in functionality
18:10:19 <dons> so its worth writing in a proper language from the start
18:10:32 <eddyp_> is there a way to see the definitin of a function I entered in ghci?
18:10:33 <LordBrain> yeah
18:11:03 <nmessenger> eddyp_: other than scrolling up, I'm not sure :P
18:11:18 <LordBrain> we have a 3 times, multiple author, modified version of a perl script here...
18:11:30 <LordBrain> it's a bit nutty
18:11:58 <dons> eddyp_: no way other than scrolling back up
18:12:03 <dons> it would be possible though
18:12:10 <dons> hmm. hmm.... i've an idea.
18:12:23 * nmessenger cowers
18:12:50 <eddyp_> nmessenger: I was surprised to find that "max2 42 32" returns 32 until I realised that consequent lines  part of the same function definition overwrite one another :-/
18:13:27 <nmessenger> ah, yes, you need to seperate cases with semicolons on one line
18:13:54 <eddyp_> then I rewrote on one line and it worked (without semicolons)
18:14:32 <nmessenger> > {-otherwise it's like-} let f [] = 0 in let f (x:xs) = 1 + f xs in f [1,2,3]
18:14:34 <lambdabot>   Non-exhaustive patterns in function f
18:15:31 <eddyp_> nmessenger: dons: thanks.... I'll read and experiment more
18:17:35 * dons `ap` uni
18:18:00 <nmessenger> dons :: f (a -> b); uni :: f a
18:18:18 <narain> ?src ap
18:18:19 <lambdabot> ap = liftM2 id
18:18:30 <narain> liftM2 dons uni
18:18:45 <narain> no wait
18:18:48 <nmessenger> liftM2 id dons uni, rather
18:20:01 <narain> dons >>= \x -> uni >>= y -> return $ x y
18:20:05 <emk> @tell Philippa: My thoughts on error-handling are still gelling, but I haven't forgotten about our discussion. My apologies for being so slow about the summary. Please feel free to ping me if you have some spare time and want the transcript!
18:20:06 <lambdabot> Consider it noted.
18:20:42 <nmessenger> er, will the colon after Phillipa: trip up LB?
18:21:02 <nmessenger> @tell test: something
18:21:02 <lambdabot> Consider it noted.
18:21:14 <test> darn, no /nick test:
18:21:14 <LoganCapaldo> I would advise everyone to /nick Themselves: once a day just to be certain :)
18:22:08 <nmessenger> LoganCapaldo: SamB recently found a message addressed to samb from *eight months ago*!!
18:22:11 <jcreigh> probably needs to be "test:"
18:22:16 <LoganCapaldo> it just dros the colon :(
18:22:18 <LoganCapaldo> *drops
18:22:30 <sorear> @print-notices
18:22:31 <lambdabot> fromList [("Philippa:",(Nothing,[Note {noteSender = "emk", noteContents = "My thoughts on error-handling are still gelling, but I haven't forgotten about our discussion. My apologies for being so
18:22:31 <lambdabot> slow about the summary. Please feel free to ping me if you have some spare time and want the transcript!", noteTime = (1173835362,925691000000), noteType = Tell}])),("TreyHarris:",(Nothing,[Note {
18:22:31 <lambdabot> noteSender = "markstos", noteContents = "Thanks for the unspecced clarification.", noteTime = (1159042987,796842000000), noteType = Tell}])),("agentzh:",(Nothing,[Note {noteSender = "markstos",
18:22:31 <lambdabot> noteContents = "I've made several links to L<S16>, which is described in S29, but doesn't exist. Perhaps these shouldn't be considered errors now since we know the document will eventually exist.",
18:22:33 <sorear> @more
18:22:34 <lambdabot> noteTime = (1158062003,104344000000), noteType = Tell}])),("andara:",(Nothing,[Note {noteSender = "audreyt", noteContents = "does webterminal server actually spawn children? it doesn't look like it",
18:22:37 <lambdabot> [107 @more lines]
18:22:38 <nmessenger> woah
18:22:39 <lambdabot>  noteTime = (1161059780,744336000000), noteType = Tell}])),("augustss:",(Nothing,[Note {noteSender = "astrolabe", noteContents = "Just a sketch http://hpaste.ath.cx:8000/23", noteTime = (1169425156,
18:22:42 <lambdabot> 589759000000), noteType = Tell}])),("dcoutts:",(Nothing,[Note {noteSender = "dons", noteContents = "random public complaint about gtk2hs on freebsd, http://programming.reddit.com/info/11iku/comments/
18:22:45 <lambdabot> c11lf9?context=5", noteTime = (1170056103,478499000000), noteType = Tell}])),("dcoutts_:",(Nothing,[Note {noteSender = "JaffaCake", noteContents = "http://haskell.org/happy/happy-1.16rc2.tar.gz",
18:22:48 <lambdabot> noteTime = (1161767567,43602000000), noteType = Tell}])),("dmq:",(Nothing,[Note {noteSender = "fglock", noteContents = "any ideas on how to get from/to information (like in $-[$n]/$+[$n]), given a
18:22:51 <jcreigh> then why didn't nmessenger-as-test saying something print the @tell?
18:22:51 <lambdabot> perl5.10 named capture?", noteTime = (1173371991,314795000000), noteType = Tell}])),("#haskell",(Nothing,[Note {noteSender = "dmwit", noteContents = "@quote lambdabot", noteTime = (1157929830,
18:22:52 <sorear> @paste-more -- I wish
18:22:54 <lambdabot> [102 @more lines]
18:22:56 <lambdabot> Unknown command, try @list
18:23:10 <LoganCapaldo> hmm
18:23:17 <LoganCapaldo> : seems to be a common oops
18:23:26 * emk tries again
18:23:35 <emk> @tell Philippa My thoughts on error-handling are still gelling, but I haven't forgotten about our discussion. My apologies for being so slow about the summary.
18:23:36 <lambdabot> Consider it noted.
18:24:03 <Philippa_> emk: still here
18:24:03 <emk> @tell Philippa Please feel free to ping me if you have some spare time and want the transcript.
18:24:04 <lambdabot> Consider it noted.
18:24:22 <nmessenger> corner cases!
18:24:22 <emk> Oh, nevermind, then. No need to wrestle with lambdabot.
18:24:23 <jcreigh> hmm, maybe it should strip non-alphanumber (or possibly just non-alphabetical) characters and do a case-insensitive comparision of that.
18:24:44 <jcreigh> err, s/number/numeric/
18:24:51 <Philippa_> anyway, yeah, if you want to mail me the transcript I might have time to do the butchering tomorrow
18:24:58 <nmessenger> does IRC in general restrict specific chars from nicks or just freenode?
18:25:12 <emk> Philippa: What address should I use?
18:25:29 <Philippa_> see PM
18:26:26 <encryptio> nmessenger: irc in general.
18:27:01 <encryptio> specifically, to the regex: /[a-zA-Z][a-zA-Z0-9-\[\]\\`^\{\}]*/
18:27:26 <encryptio> with anchors. (i always forget those...)
18:27:30 <LoganCapaldo> shouldn't there be an _ in there?
18:28:10 <encryptio> according to the irc rfcs, no.
18:28:13 <`> I am backquote!
18:28:28 <encryptio> but... irc is one of the fucked up protocols that's rarely adhered to
18:28:32 <`> I shall infixify you!
18:28:50 <encryptio> (hmm, am i allowed to swear in here?)
18:29:06 * Cale downloads the last episode of SG-1.
18:29:19 <sorear> encryptio: you won't be assassinated if you do.
18:29:29 <mwc> Cale: I've got 8 minutes to go on my torrent
18:29:40 <ndm_ish> encryptio: yes, as long as its worth it - no continual swearing because you've just learnt a new word
18:29:55 <Cale> mwc: cool
18:30:00 <encryptio> kay.
18:30:11 * mwc marks a sad sad day
18:30:20 * ndm_ish points Cale at http://www.tv-links.co.uk/Stargate_links.html#Stargate_10
18:30:24 <lambdabot> Title: TV Links - Stargate
18:30:40 <nmessenger> ndm -ish?
18:30:48 <Cale> ndm_ish: I'm downloading S10E20
18:31:12 <Cale> that's a neat page though
18:31:16 <ndm_ish> nmessenger: i'm using ircatwork.com, and if i try and join with ndm i immediately get kicked off
18:31:30 <jcreigh> encryptio: for instance, when you discover that every object in Java is actually Maybe, and there's implicit fromJusts all over, any one of which might randomly throw NullPointerException, it's okay to vent a little. :)
18:31:32 <ndm_ish> nmessenger: since someone else has that name (i.e. me!)
18:31:37 <nmessenger> :/
18:31:42 * sorear /kill ndm
18:32:03 <sorear> can't you use /msg nickserv recover ndm <password>?
18:32:12 <ndm_ish> although i actually think i might be able to be ndm now
18:32:22 <ndm_ish> yesterday i couldn't, as i was also logged in at work still
18:32:37 * ndm regains his name and karma
18:32:43 <sorear> ndm++
18:33:00 <Igloo> I was just wondering if ndm-- would be too cruel a response  :-)
18:33:09 <ndm> sorear, very clever nubOrd, btw
18:33:25 <nmessenger> Igloo: well, you've done it anyway :D
18:33:42 <ndm> sorear, i just hope that dependancy issues don't keep it from being added
18:33:43 <sorear> ndm: and it's O(#in * log #out) to boot, faster than nub or nubSorted . nub
18:33:44 <Cale> mwc: At least SG-1's had a long run. Firefly didn't even get a chance.
18:33:48 <Igloo> Oh, is it allowed anywhere on a line?
18:34:05 <nmessenger> @karma Igloo
18:34:06 <lambdabot> Igloo has a karma of 11
18:34:10 <nmessenger> testing Igloo--
18:34:13 <nmessenger> @karma Igloo
18:34:16 <lambdabot> Igloo has a karma of 10
18:34:28 <sorear> Igloo: it is.  thank sjanssen++
18:34:31 <nmessenger> Igloo++
18:34:37 <ndm> sorear, yes, but the same speed as the Set.toList/fromList pair - which is what sortNub will have
18:34:59 <sorear> well, that's strict :)
18:35:01 <sm> that's a great karma implementation
18:35:10 <Igloo> ndm: It would be nice to avoid recursive imports if possible, but we can probably shuffle things round somehow if necessary
18:35:30 <ndm> i was actually quite shocked at how bad map head . group . sort is in performance, way worse than nub
18:35:37 <mwc> Cale: true, but at least Serenity had a pretty big budget. I bet it'll still be bigger than both of the SG-1 movies put together
18:35:50 <ndm> Igloo, to make Data.Set a dependancy of Data.List? I would have thought we'll run into issues
18:37:03 * nmessenger just realizes that "very clever nubOrd" isn't some crazy leetspeak
18:37:08 <Cale> ndm: whaaa?
18:37:20 <Igloo> ndm: Well, in the worst case we can just make a cycle
18:37:24 <ndm> although if at all possible, it would be the best way - since having a lazy quick version of a function is always prefered
18:37:25 <Cale> ndm: map head . group . sort should be asymptotically faster than nub
18:37:45 <ndm> Cale: try it, and think of the case where the output is a lot shorter than the input
18:37:45 <sjanssen> Cale: not for certain lists
18:37:46 <mwc> @type group
18:37:48 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
18:38:02 <encryptio> > group [1,2,1]
18:38:02 <sjanssen> nub is much faster on replicate n x, for example
18:38:03 <lambdabot>  [[1],[2],[1]]
18:38:07 <encryptio> > group [1,2,1,1]
18:38:09 <lambdabot>  [[1],[2],[1,1]]
18:38:09 <Cale> well, sure :)
18:38:13 <ndm> Cale: i just posted to libraries with a quick overview of why that isn't the case, despite that you might think so
18:40:35 <lemao> what is the use of the foldr initial value?
18:40:46 <encryptio> to allow it to work on empty lists
18:41:10 <jcreigh> lemao: and you accumulate into a different type than the the type of the list.
18:41:13 <glguy> to allow it to work on any list
18:41:17 <jcreigh> *and to
18:41:25 <Cale> Basically, what foldr f z does is replace each (:) in the list with f and the [] at the end with z
18:42:30 <Cale> > foldr (\x xs -> concat ["(f ", show x, " ", xs, ")"]) "z" [1,2,3,4,5]
18:42:32 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
18:43:11 <Cale> > foldr (\x xs -> concat ["(", show x, ":", xs, ")"]) "[]" [1,2,3,4,5]
18:43:13 <lambdabot>  "(1:(2:(3:(4:(5:[])))))"
18:43:21 <lemao> I see. We need it because the f is a binary function?
18:43:25 <Cale> yeah
18:43:56 * ndm just solved DigitsOfE2 running the entire computation inside hugs!
18:43:59 <lemao> make sense. (sorry for the basic question _ I am starting to learn haskell)
18:44:02 <Cale> There's also foldr1 which uses the last element of the list as the second parameter to f, but that gives a more restrictive type and doesn't work with empty lists.
18:44:17 <Cale> Feel free to ask any questions you have :)
18:44:35 <encryptio> lemao: we all started somewhere.
18:44:38 <lemao> I am already impressed with the responses :-) Thanks a million
18:44:43 <Cale> I made some diagrams of what the various fold and scan functions do: http://cale.yi.org/index.php/Fold_Diagrams
18:44:47 <lambdabot> Title: Fold Diagrams - CaleWiki
18:44:56 <nmessenger> straightforward, too
18:45:00 <nmessenger> @src foldr1
18:45:01 <lambdabot> foldr1 _ [x]    = x
18:45:01 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
18:45:01 <lambdabot> foldr1 _ []     = undefined
18:45:19 <Cale> I also wrote the wikipedia article on folds :)  http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
18:45:20 <lambdabot> Title: Fold (higher-order function) - Wikipedia, the free encyclopedia
18:45:41 <nmessenger> eh?  why not foldr f (x:xs) = foldr f x xs?
18:45:55 <nmessenger> foldr1 f (x:xs) rather
18:46:03 <lemao> thanks for the fold diagrams. Now foldl also makes sense. Left and Right
18:46:31 <ndm> nmessenger, i think thats how the real foldr1 is written, src is a bit misleading sometimes
18:46:33 <Cale> lemao: yeah :)
18:47:17 <lemao> thanks
18:47:43 <Cale> I think the @src plugin should take its code from hand-modified code, selected for clarity.
18:47:47 <Cale> @src foldr
18:47:48 <lambdabot> foldr k z xs = go xs
18:47:49 <lambdabot>     where go []     = z
18:47:49 <lambdabot>           go (y:ys) = y `k` go ys
18:47:52 <glguy> nmessenger: it's not like what you wrote because the last element in the list is used as the zero element
18:47:55 <Cale> that's a terrible looking foldr
18:47:58 <glguy> and not the first
18:48:33 <nmessenger> @src foldl1
18:48:33 <lambdabot> foldl1 f (x:xs) = foldl f x xs
18:48:34 <lambdabot> foldl1 _ []     = undefined
18:48:37 <nmessenger> oh, of course
18:48:48 <sorear> Cale: but, that foldr is non-recursive, so it can be inlined by GHC.
18:48:48 <glguy> > foldr1 (\x y -> y) [1..10]
18:48:50 <lambdabot>  10
18:49:07 <sorear> Cale: exactly the sort of thing we *don't* want the newbies to see...
18:49:07 <Cale> sorear: right, but I don't care about that.
18:49:22 <lemao> lambdabot: I saw a foldr flying over my head... :)
18:49:47 <lemao> there's a bit of sintax I have to digest.
18:49:57 <sorear> sin tax eh?
18:50:10 <glguy> sounds tasty
18:50:19 <narain> Cale: those are some neat fold diagrams
18:50:27 <Cale> narain: thanks :)
18:51:05 <narain> Cale: did you generate the SVG programmatically?
18:51:09 <narain> (sp?)
18:51:12 <Cale> no
18:51:16 <Cale> I used inkscape.
18:51:34 <lemao> well, that foldr code looked sinful to me ;-)
18:51:34 <narain> ah. that would have been even awesomer :)
18:51:45 <narain> ?all-dicts programmatically
18:51:46 <lambdabot> No match for "programmatically".
18:51:57 <nmessenger> @spell programmatically
18:51:58 <lambdabot> pro grammatically pro-grammatically programmatic ally programmatic-ally programmatic
18:52:09 <Cale> Yeah, I'd love to have a Haskell implementation which let you view the graph mutations in real-time or step-by-step.
18:52:17 <nmessenger> :3  programmatic ally <3
18:52:30 <narain> i want one of those
18:53:27 <Cale> lemao: In case you don't have a copy, the pretty version of foldr looks something like:
18:53:30 <Cale> foldr f z [] = z
18:53:46 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
18:54:15 <lemao> btw, what is the recommended editor you use to create Haskell programs? vim? emacs? Something else?
18:54:24 <sorear> vim|emacs
18:54:25 <encryptio> whatever you like best
18:54:25 <Cale> vim and emacs are good choices
18:54:30 <newsham> anybody here active on the wikibooks?
18:54:36 <nmessenger> [] becomes z, (x:xs) becomes (x `f` <recursive call>)
18:54:39 <Cale> newsham: I'm not, but I ought to be.
18:54:59 <narain> Cale: i remember seeing a real-time spreadsheet-like functional programming system somewhere
18:54:59 <sjanssen> glguy: is the full description to that problem available online?
18:55:17 <newsham> i read YAHT and made a bunch of notes on things that could be tidied up, sent them to the author, but he said he's hosed w/ his phd at the moment.
18:55:29 <Cale> narain: possibly vital
18:55:39 <narain> Cale: yes, that one
18:55:50 <Cale> newsham: there's a wikified copy in the wikibooks
18:55:58 <narain> Cale: but it doesn't show you the process of graph reduction, which would be neat
18:56:07 <newsham> yah, and if i was motivated i might do it myself, but alas ;-)
18:56:13 <newsham> (its all in darcs, too)
18:56:13 <glguy> sjanssen: not that I know of
18:56:18 <glguy> sjanssen: I just have a printout
18:56:35 <lemao> Cale: if I understand the code correctly, it means: that foldr with an empty list is z. foldr with a list with a x head and xs tail will recursively call itself on xs
18:56:45 <sjanssen> glguy: can you describe it briefly?  I want to solve the whole thing :)
18:57:05 <Cale> lemao: yeah, applying f to the head and the result of that recursive call on the tail
18:57:12 <newsham> foldr (+) 0 5:6:7:8:9:[]    ->       5+6+7+8+9+0
18:57:41 <newsham> where (:) and (+) assoc the same way
18:57:42 <Cale> lemao: The interesting thing here is that lazy evaluation is outermost-first. So if f for whatever reason doesn't end up needing its second parameter, the recursion stops.
18:58:05 <lokam> What would be the best way to store a non-defined set of strings, where these strings can be added, randomly selected printed and readded, and randomly removed
18:58:27 <lokam> ?
18:58:45 <newsham> ioref/stref to a list? array?  tree?
18:58:52 <Cale> Data.Set?
18:58:52 <lemao> Cale: not sure I understand what you mean by outermost-first here.
18:58:53 <nmessenger> also map?
18:59:14 <lokam> so any of those would be good?
18:59:15 <Cale> lemao: The outermost reducible expression gets reduced first. Let me give an example.
18:59:22 <Cale> Suppose we have double x = x + x
18:59:36 <Cale> and we want to evaluate double (double 5)
18:59:47 <jcreigh> 20
18:59:48 <jcreigh> haha!
18:59:49 <jcreigh> :)
19:00:01 <resiak> jcreigh: that was a bit eager
19:00:08 <Cale> Strict evaluation is innermost-first, we evaluate the parameters and then sub that into the function.
19:00:11 <jcreigh> resiak: heh
19:00:13 <Cale> So it goes:
19:00:17 <Cale> double (double 5)
19:00:21 <Cale> = double (5 + 5)
19:00:25 <Cale> = double 10
19:00:28 <Cale> = 10 + 10
19:00:30 <Cale> = 20
19:00:48 <Cale> With outermost-first evaluation, we start on the outside:
19:00:51 <Cale> double (double 5)
19:01:05 <Cale> = (double 5) + (double 5)
19:01:10 <Cale> = (5 + 5) + (double 5)
19:01:15 <Cale> = 10 + (double 5)
19:01:19 <Cale> = 10 + (5 + 5)
19:01:23 <Cale> = 10 + 10
19:01:25 <Cale> = 20
19:01:25 <newsham> jcreigh is not lazy (or pure)
19:01:36 <jyasskin> Cale: Can't Hat print the graph mutations in step-by-step?
19:02:09 <Cale> jyasskin: I think so, actually, but afaik, not in the very graphical way I'd like to see it :)
19:02:23 <Cale> At first, the outermost-first takes more steps.
19:02:33 <Cale> Lazy evaluation adds another provision to it.
19:02:41 <ndm> Cale, not really, it might be able to with the right viewer, but i'm not sure one exists and works
19:02:56 <ndm> i meant jyasskin ^^^
19:03:04 <Cale> If two things came from the duplication of a parameter to a function, then the work involved in computing them is shared.
19:03:14 <Cale> lemao: following?
19:03:23 <Cale> So with lazy evaluation:
19:03:30 <Cale> double (double 5)
19:03:40 <jyasskin> Ah, ok. I've never actually gotten hat to work, but I didn't try very hard either.
19:03:45 <Cale> = let x = double 5 in x + x
19:03:52 <Cale> = let x = 5 + 5 in x + x
19:03:57 <dino-> Is this where the purity gets involved? double 5 is known and will never change, so that result can be used twice?
19:03:59 <Cale> = let x = 10 in x + x
19:04:02 <Cale> = 20
19:04:14 <Cale> dino-: yeah, that's kind of important :)
19:05:08 <Cale> If things weren't pure, then sharing would end up causing side effects to be a bit confusing.
19:05:10 <nmessenger> dino-: yep, since outermost-first is a little harder to pin down, having side-effects willy-nilly would be kind of unmanageable.
19:05:28 <lemao> yep. So far so good. I am not used to thinking this way but the idea of evaluating it contrary to how other non-lazy makes sense
19:06:19 <Cale> Basically, you take the outermost thing which you know can be reduced somehow, and reduce it first, but if a parameter to a function is duplicated in the body, you share the work.
19:06:29 <jcreigh> when GHC seeks two identical subexpressions at compiletime, does it make them point to the same thunk?
19:06:35 <Cale> Once you know how to do that, you can run Haskell code by hand.
19:06:47 <encryptio> jcreigh: that's CSE, and yes
19:06:48 <Cale> jcreigh: sometimes.
19:07:23 <Cale> CSE stands for Common Subexpression Elimination.
19:07:41 <lemao> Is "in" in let x = 10 in x + x part of the Haskell language?
19:07:46 <Cale> yeah
19:07:59 <nmessenger> > let x = 1 in x +2
19:08:01 <lambdabot>  3
19:08:05 <Cale> I was using the lets there just to represent that internally, there's two pointers pointing at the same x
19:08:23 <nmessenger> let {declarations} in (expression) -- <- this is an expression in itself
19:08:25 <dino-> :t in
19:08:28 <lambdabot> parse error on input `in'
19:08:39 <Cale> let and in are keywords
19:08:43 <goban> http://imgs.xkcd.com/comics/escape_artist.png
19:10:07 <LordBrain> hmmmm... i wonder how quickly the population of haskell programmers is growing.
19:10:20 <jcreigh> fibonacci :)
19:10:28 <nmessenger> lemao: the short-circuit boolean operators you've probably used in many languages behave lazily.  If the result can be determined by the first arg, the second arg isn't evaluated.
19:10:35 <dibblego> factorial!
19:10:36 <lemao> Cale: thanks for the insights. Lazy (outermost-first) evaluation and computation reuse. I am liking this so far !
19:11:16 <nmessenger> > [5, 4, 9, error "Explode!"]
19:11:17 <LordBrain> i could be totally wrong here... but perhaps because there is always someone in here learning the basics, i get a sense that it is exploding.
19:11:17 <lambdabot>  Exception: Explode!
19:11:21 <nmessenger> > take 2 [5, 4, 9, error "Explode!"]
19:11:23 <lambdabot>  [5,4]
19:11:34 <Cale> lemao: strictly-speaking, (no pun intended) this computation sharing is part of the definition of lazy evaluation -- without that, outermost-first evaluation is commonly referred to as normal-order evaluation.
19:11:47 <Cale> (or simply outermost-first)
19:12:28 <nmessenger> indeed, the only reason 5 and 4 are evaluated above is because lambdabot tried to print them.
19:12:32 <Cale> LordBrain: well, not exploding *too* quickly, I hope. :) We want to be able to cope with all the beginners :)
19:12:41 <lemao> np, I am here to be slapped and corrected
19:12:55 <nmessenger> @slap lemao
19:12:56 * lambdabot smacks lemao about with a large trout
19:12:58 <LordBrain> hmmm maybe we should be more secretive about it
19:13:09 <LordBrain> :)
19:13:17 <Cale> Indeed, avoid success at all costs.
19:13:35 <fantasma> is there an LCD monitor that is particularly good at displaying text? (for example code developement and console)
19:13:35 <lemao> hehe: its a double slap: english and haskell
19:14:00 <Philippa_> I think the proportion of comparative newbie discussion in here's lower than it used to be actually
19:14:22 <Cale> fantasma: most of them are pretty good these days, you just turn on subpixel antialiasing.
19:14:32 <Philippa_> we've got a much higher number of experienced regulars who do stuff at least one other experienced regular sees as voodoo now
19:15:15 <Cale> We're all on our individual journeys. :)
19:15:33 <fantasma> Cale, any strong opinions on any LCD?
19:15:44 <nmessenger> @quote vending.machine
19:15:45 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
19:15:45 <lambdabot> of insight hits and it all makes sense.
19:15:46 <Philippa_> yep - I remember a time when neither of us really understood monads properly
19:16:02 <encryptio> lol, that quote is so true
19:16:05 <slowriot> It seems like persistent data structures, by providing an efficient way of storing multiple versions of a data structure, open up a lot of possibilities.
19:16:13 <tuukkah> fantasma, perhaps you want to look for those that have higher dpi and those that adapt to environmental lighting
19:16:24 <slowriot> Does anyone know if persistence has been taken advantage of commercially?
19:16:31 <slowriot> or not just commercially
19:16:35 <LordBrain> well... haskell is maybe like getting a bachelors in math, after 4 years, you are ready for stuff commonly referred to and understood as "elementary"
19:17:11 <slowriot> for anything, really.
19:17:12 <Cale> 2 years, maybe :)
19:17:13 <LordBrain> well not that bad i hope
19:17:15 <LordBrain> :)
19:17:35 <LordBrain> 2 years, but only because you got your AA first
19:17:41 <Cale> AA?
19:17:45 <LordBrain> general ed
19:17:45 <encryptio> i'm having trouble figuring out what i should do next in my haskell learning, now with monads conquered
19:17:52 <Cale> BMath :)
19:17:53 <slowriot> associates of arts
19:18:01 <slowriot> something like that :)
19:18:06 <QtPlatypus> slowriot: I've never seen persistence ever take hold outside of accedmina.  All the persistent modles I've seen are basically wrappers that serizlize and deserilize data for you.
19:18:16 <Cale> encryptio: arrows?
19:18:32 <encryptio> erf.
19:18:42 <encryptio> arrows freak me out.
19:19:00 <LordBrain> encryptio, check out Control.Applicative
19:19:17 <nmessenger> > [(+1), (*3)] <*> [3,4,5]
19:19:19 <lambdabot>  [4,5,6,9,12,15]
19:19:33 <encryptio> kewl.
19:20:42 <Cale> Applicative functors are what you get when you drop bind but keep ap
19:20:47 <jcreigh> QtPlatypus: sorry for the ignorance this shows, but how can you do persistence other than (de)serializing data?
19:21:34 <slowriot> QtPlatypus: The wikipedia article on persistence had kind of an interesting example. Say there's a web-based dictionary that lets you make your own entries and stores them in some kind of tree. Every time you add an entry, it a new entry, a personalized tree is created for you, allowing the "core" dictionary to persist.
19:21:37 <tuukkah> > liftM2 ($) [(+1), (*3)] [3,4,5]
19:21:39 <lambdabot>  [4,5,6,9,12,15]
19:21:57 <Cale> > ap [(+1), (*3)] [3,4,5]
19:21:59 <lambdabot>  [4,5,6,9,12,15]
19:22:06 <slowriot> That is certainly a simple approach, which is good. Somehow, I think there might be a more efficient way to do it.
19:22:33 <ailndx> > let test = proc a -> returnA -< (a+1) in test 5
19:22:33 <lambdabot>  Parse error
19:22:43 <RichN> @type ap
19:22:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:23:00 <encryptio> ...
19:23:06 <encryptio> :t (>>=)
19:23:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:23:12 <encryptio> oh
19:23:19 <LordBrain> i suppose ap is more recognizable than <*>
19:23:58 <dmwit> > ap (Just (+1)) (Just 3)
19:24:00 <lambdabot>  Just 4
19:24:06 <ailndx> > let test = proc a -> returnA -< (a+1) in test 5 why doesnt this work?
19:24:06 <lambdabot>  Parse error
19:24:08 <dmwit> > ap Nothing (Just 3)
19:24:10 <lambdabot>  Nothing
19:24:17 <nmessenger> > (+) <$> [1,2,3] <*> [4,5]
19:24:19 <lambdabot>  [5,6,6,7,7,8]
19:25:11 <dmwit> > liftM2 (+) [1,2,3] [4,5]
19:25:13 <lambdabot>  [5,6,6,7,7,8]
19:25:19 <dmwit> :t <$>
19:25:22 <lambdabot> parse error on input `<$>'
19:25:26 <dmwit> :t (<$>)
19:25:29 <nmessenger> > (+) `fmap` [1,2,3] `ap` [4,5]
19:25:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:25:31 <lambdabot>  [5,6,6,7,7,8]
19:25:38 <nmessenger> (<$>) = fmap
19:25:41 <dmwit> Aha.
19:25:45 <tuukkah> > let test = proc a -> do returnA -< (a+1) in test 5
19:25:45 <lambdabot>  Parse error
19:26:02 <dmwit> > let test = proc a >- do returnA -< (a+1) in test 5
19:26:03 <lambdabot>   Not in scope: `a'
19:26:11 <dmwit> :t proc
19:26:14 <lambdabot> Not in scope: `proc'
19:26:17 <bd_> proc is a syntax form
19:26:21 <Cale> ailndx: it'll work in ghci, it's just that lambdabot can't parse the proc notation
19:26:30 <bd_> :t returnA
19:26:31 <nmessenger> no -farrows in @run?
19:26:33 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b b
19:26:42 <bd_> returnA = app id?
19:26:44 <nmessenger> returnA = arr id -- iirc
19:26:52 <nmessenger> @src returnA
19:26:52 <lambdabot> returnA = arr id
19:26:55 <bd_> arr rather I guess
19:26:59 <RichN> Is anyone aware of a Jabber client library for Haskell?
19:27:40 <slowriot> I got bored, so I decided to mess around with image processing using a persistant quadtree. I've been trying to find some way to take advantage of persistance, but to no avail.
19:28:06 <ailndx> Cale: dont seem to work in 6.4.1 for me
19:28:34 <Cale> Run it with -farrows
19:28:42 <tuukkah> ghc -farrows -e "let test = proc a -> do Control.Arrow.returnA -< (a+1) in test 5"
19:28:49 <Cale> and it'd be a good idea to look into grabbing a 6.6 binary.
19:30:44 <ailndx> hmm how would i write when i've allready opened ghc and it says Prelude>
19:31:04 <ailndx> -farrows -e "blabla.." doesnt seem to work
19:31:13 <sorear> I've dumped and nicely formatted the lambdabot noticeboard... anyone want to see it?
19:31:18 <dcoutts__> @seen dons
19:31:18 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1h 13m 42s ago.
19:31:21 <nmessenger> :! ghc ... -- would be one way
19:31:40 <tuukkah> :set -farrows
19:32:22 <LordBrain> ok, this is a purely emotive inexplicable thing, but arrows seem to make pairs too special to me... i feel like instead of specifying first and second, i should be able to work with tupples and select any subset of the  elements for my function to apply to and do so with a nice elegant notation.
19:32:30 <ailndx> ah now it works
19:33:03 <newsham> lord: the tuples are just needed for the plumbing.  you dont need to use them directly.
19:33:07 <sorear> @seen vincenz
19:33:08 <newsham> do-notation hides the tuples
19:33:08 <lambdabot> vincenz is in #haskell, #oasis and #haskell.dut. I last heard vincenz speak 12h 59m 29s ago.
19:33:16 <sorear> @localtime vincenz
19:33:18 <lambdabot> Local time for vincenz is Wed Mar 14 03:32:23 2007
19:33:25 <LordBrain> where's my third function?
19:33:40 <newsham> you dont need to use first and second
19:33:45 <newsham> thats plumbing
19:33:46 <nmessenger> @type second . second
19:33:48 <lambdabot> forall d (a :: * -> * -> *) b c d1. (Arrow a) => a b c -> a (d, (d1, b)) (d, (d1, c))
19:34:00 <nmessenger> there you go :)
19:34:19 <newsham> "why cant my binary tree have more nodes.  I want to store 3 things!"
19:34:25 <LordBrain> well... i want a different kind of plumbing
19:34:31 <newsham> answer: it can, but it doesnt need it.  just use the abstract data type and forget the implementation.
19:34:39 <tuukkah> Prelude> foreign import "foo" foo :: Int
19:34:39 <tuukkah> <interactive>:1:8: parse error on input `import'
19:34:48 <tuukkah> Prelude> :set -fffi
19:34:48 <tuukkah> Prelude> foreign import "foo" foo :: Int
19:34:48 <tuukkah> <interactive>:1:0: parse error on input `foreign'
19:34:49 <newsham> lord: then nest your pairs
19:34:57 <newsham> (or use do-notation and let the compiler do it for you)
19:35:00 <LordBrain> yeah
19:35:23 <newsham> the pairs arent the point of arrows..  they're the artifacts of an implementation
19:35:30 <LordBrain> yeah i know
19:35:34 <sorear> @tell vincenz googlewords: "Graph Reduction Intermediate Notation"  "Urban Boquist" main url: http://www.cs.chalmers.se/~boquist/ifl96-abstract.html (warning - multi hundred pages)
19:35:34 <lambdabot> Consider it noted.
19:35:41 <dataangel> Is there a guideline for when I should use let and when I should use where?
19:35:42 <ailndx> anyone here using hs-plugins in win?
19:35:55 <LordBrain> well thats what i'm reacting to, not the concept of arrows, i actually like the concept
19:36:04 <newsham> data: mostly it doesnt matter.   sometimes you cant use where, and sometimes where works better than let
19:36:07 <sorear> anyone want to see the list of dead @tells?
19:36:08 <LordBrain> it seems like a pretty natural thing really
19:36:22 <newsham> but in most situations either one is fine
19:36:39 <nmessenger> dataangel: inside a nested expression, you need let, and scoping over several guards, you need where.  Otherwise it's personal preference.
19:36:59 <newsham> data: "where" works well when you have multiple conditional restrictions on arguments and you want something that is scoped over all of them
19:37:08 * nmessenger personally prefers where in those cases
19:37:32 <newsham> ie:   foo x | y < 9 = ...  ;  | y > 9 = ...;    | y == 9 = ....;   where y = x*2
19:37:53 <newsham> that where will be scoped over all of the conditions (unlike let)
19:38:13 <nmessenger> names in a let only scope over the in expression
19:39:15 <newsham> see http://en.wikibooks.org/wiki/Haskell/YAHT/Language_advanced#Local_Declarations
19:39:21 <lambdabot> http://tinyurl.com/y4u7rv
19:39:39 <araujo> hello!
19:40:17 <newsham> hello
19:41:10 <LordBrain> arrows seem natural when you're thinking about solving a problem in a purely functional way... you can send everything in one side of the pipe and it comes out the other, and you dont even have to name the inputs just hook up the plumbing.
19:41:34 <newsham> arrows remind me of discrete time signal processing
19:41:42 <LordBrain> yeah
19:43:26 <LordBrain> thats a nice thing to be able to do
19:43:50 <encryptio> @pl \x->x*x
19:43:51 <lambdabot> join (*)
19:44:23 <LordBrain> then you can reserve names only for those things which represent something semantically important.
19:46:33 <glguy> but we can already do that with a chain of (.)
19:46:52 <glguy> do you have a good example of something that uses what arrows offer
19:47:00 <glguy> other than the combinators
19:47:39 <sorear> there's an arrow parser lib with LALR(1) table generation
19:47:46 <sorear> no idea what it's called
19:47:52 <sorear> can't to that with monads
19:47:58 <glguy> link?
19:48:03 <glguy> oh
19:48:11 <sorear> it's mentioned in the arrows paper
19:48:18 <sorear> probably with a bib link...
19:48:23 * sorear afk : X
19:51:56 <LordBrain> a chain of  (.) and a lot of utilities of the form \x y z-> (z x, y)  etc... but if these utilities are standardized thats better... thats the nice thing about first and second in the arrows package.. but just having those seems stylistically restrictive.... kind of like necessitating that we denote our numbers in binary
19:52:07 <newsham> glguy: there's a robot toolkit using arrows
19:52:16 <sorear> http://citeseer.ist.psu.edu/164365.html
19:52:23 <sorear> and, wow
19:52:25 <lambdabot> Title: Deterministic, Error-Correcting Combinator Parsers - Swierstra, Duponcheel (Rese ...
19:52:36 <sorear> I've found a reliable way to segfault mg
19:52:37 <LordBrain> Yampa uses arrows
19:52:38 <newsham> http://citeseer.ist.psu.edu/hudak02arrows.html
19:52:40 <lambdabot> Title: Arrows, Robots, and Functional Reactive Programming - Hudak, Courtney, Nilsson,  ...
19:53:05 <sorear> you'd expect an editor written for OpenBSD to be a little more robust
19:53:20 <sorear> M-x, 100 x's, C-g, Segmentation fault
19:54:34 <LordBrain> 1 and 0 are seemingly all we need for writing anything, but just because they're the minimum necessary doesnt mean they're the ideal alphabet.... and i feel the same way about first and second
19:55:06 <QtPlatypus> sorear: emacs wasn't written for OpenBSD
19:55:36 <sorear> QtPlatypus: who said anything about emacs?
19:55:47 <dons> re.
19:55:51 <QtPlatypus> Sorry missread the whole " M-x, 100 x's, C-g, Segmentation fault"
19:59:28 <encryptio> does anyone here use Yi as their primary editor?
19:59:30 <glguy> LordBrain: who were you talking to?
19:59:49 <LordBrain> um... anyone
20:00:08 <zbrown> @hoogle dbms
20:00:09 <lambdabot> No matches found
20:00:10 <newsham> lord: but 1 and 0 might be a good alphabet to build a computing system with, even if that computing system usually deals with larger values
20:00:13 <zbrown> @hoogle sql
20:00:14 <lambdabot> No matches found
20:00:16 <zbrown> hmmm
20:00:38 <glguy> LordBrain: so you are saying you like using first and second? or that they might as well be 1 or 0
20:00:49 <LordBrain> both
20:00:55 <RichN> @hoogle jabber
20:00:56 <lambdabot> No matches found
20:01:00 <LordBrain> i like them, but i want more
20:01:20 <newsham> he wants "third"
20:01:24 <LordBrain> not just third
20:01:37 <newsham> i prefer my binary tree to your radix-n tree
20:01:54 <LordBrain> i want to be able to nice and succinctly say things like firstSecondAndFourthButNotThird
20:02:19 <LordBrain> or
20:02:19 <chessguy> "three, sir!
20:02:56 <LordBrain> actually
20:03:11 <LordBrain> it should probably be somehow specified near the parameter
20:03:19 <LordBrain> like
20:03:21 <nmessenger> @type \(x, y, _, z) -> (x, y, z)
20:03:24 <LordBrain> have special parens
20:03:24 <lambdabot> forall t t1 t2 t3. (t, t1, t2, t3) -> (t, t1, t3)
20:03:26 <LordBrain> like
20:03:40 <LordBrain> i'll use { } to demonstrate
20:03:53 <LordBrain> f x means apply f to x
20:05:07 <nmessenger> data (a,b) = (,) { fst :: a, snd :: b }; data (a,b,c) = (,,) { fst :: a, snd :: b, thd :: c } -- etc?
20:05:20 <sorear> class Fstable where...
20:05:31 <sorear> actually I'd rather we had
20:05:36 <LordBrain> and in this hypothetical notation... f { a, b, $ c, d } would mean  [a, b, f c, d]
20:05:52 <LordBrain> something like this
20:05:52 <sorear> data HUnit = HUnit ; data HProd x y = HProd x y
20:05:57 <LordBrain> see what i mean?
20:06:00 <sorear> fst :: HUnit a b -> a
20:06:10 <sorear> snd :: HUnit a (HUnit b c) -> b
20:06:11 <sorear> ...
20:06:15 <LordBrain> kind of?
20:06:17 <sorear> s/HUnit/HProd/g
20:06:32 <LordBrain> only you wouldnt have to specify names... so i could say
20:06:42 <LordBrain> f { _, _, $ c, _ }
20:06:46 <LordBrain> or something
20:06:54 <LordBrain> hmmm
20:07:00 <LordBrain> i dont know, i havent worked it out in my head
20:07:14 <LordBrain> but you can start to see what i'm going for here
20:07:41 <nmessenger> \f (a,b,c,d) -> (a,b,f c,d) -- is succinct and clear
20:07:47 <LordBrain> yeah
20:08:10 <Pastorn> @pl (\f (a,b,c,d) -> (a,b,f c,d))
20:08:11 <lambdabot> (line 1, column 9):
20:08:11 <lambdabot> unexpected ","
20:08:11 <lambdabot> expecting letter or digit, operator or ")"
20:08:11 <lambdabot> ambiguous use of a non associative operator
20:08:15 <Pastorn> fuck
20:08:26 <Pastorn> @pl (\f (a,b) -> (a,f b))
20:08:26 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
20:08:26 <LordBrain> perhaps a bitmask
20:08:35 <Pastorn> nicer :D
20:08:43 <nmessenger> @type (second (second (first ?f)))
20:08:46 <lambdabot> forall (a :: * -> * -> *) b c d d1 d2. (?f::a b c, Arrow a) => a (d2, (d1, (b, d))) (d2, (d1, (c, d)))
20:08:53 <zbrown> Hmmm is there a nice interface to SQL databases for haskell?
20:09:06 <nmessenger> n-tuples for n > 2 should be sugar for nested pairs!
20:09:09 <glguy> I was playing with HDBC this week
20:09:13 <glguy> seemed nice enough
20:09:19 <encryptio> @pl (\f (a,b,c,d) -> (a,b,(f c),d))
20:09:20 <lambdabot> (line 1, column 9):
20:09:20 <lambdabot> unexpected ","
20:09:20 <lambdabot> expecting letter or digit, operator or ")"
20:09:20 <lambdabot> ambiguous use of a non associative operator
20:09:21 <RichN> I've used HSQL...
20:09:22 <sorear> nmessenger: HList should be in base!
20:09:24 <LordBrain> i guess i want something like a map fuction with a restriction argument
20:09:31 <LordBrain> such as
20:09:35 <nmessenger> sorear: is that basically what HList is?
20:09:41 <sorear> nmessenger: yes
20:09:46 <sorear> nmessenger: tuples done right
20:09:48 <nmessenger> kewlz
20:09:57 <zbrown> glguy: ok thanks
20:10:08 <LordBrain> map 101 (*2) [3, 3, 3] = [6,3,6]
20:10:18 <sorear> nmessenger: of course it's super ugly since the aformentioned sugar doesn't exist...
20:10:18 <vincenz> sorear: you called?
20:10:19 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
20:10:29 <Pastorn> encryptio: he can't handle tuples larger than (a,b) when using @pl
20:10:35 <Pastorn> ...it seems
20:10:50 <LordBrain> how could i pull that off?
20:10:58 <sorear> vincenz: yes. it occured to me to download and prettyprint all the dead notices... and JohnMeacham wasn't there...
20:11:08 <Pastorn> encryptio: though, you can use let expressions to get around that
20:11:16 <vincenz> sorear: o.O
20:11:16 <LordBrain> how do i represent numerals in binary in haskell, i've forgotten?
20:11:29 <vincenz> sorear: I am not certain I follow
20:11:35 <nmessenger> > 0b11010101 -- not sure, checking
20:11:36 <lambdabot>   Not in scope: `b11010101'
20:11:38 <sorear> vincenz: @print-notices
20:11:39 <LoganCapaldo> > 0b10 -- does this work?
20:11:40 <lambdabot>   Not in scope: `b10'
20:11:44 <vincenz> @print-notices
20:11:44 <sorear> vincenz: that kind
20:11:44 <lambdabot> fromList [("Philippa:",(Nothing,[Note {noteSender = "emk", noteContents = "My thoughts on error-handling are still gelling, but I haven't forgotten about our discussion. My apologies for being so
20:11:45 <lambdabot> slow about the summary. Please feel free to ping me if you have some spare time and want the transcript!", noteTime = (1173835362,925691000000), noteType = Tell}])),("TreyHarris:",(Nothing,[Note {
20:11:45 <lambdabot> noteSender = "markstos", noteContents = "Thanks for the unspecced clarification.", noteTime = (1159042987,796842000000), noteType = Tell}])),("agentzh:",(Nothing,[Note {noteSender = "markstos",
20:11:45 <lambdabot> noteContents = "I've made several links to L<S16>, which is described in S29, but doesn't exist. Perhaps these shouldn't be considered errors now since we know the document will eventually exist.",
20:11:46 <lambdabot> noteTime = (1158062003,104344000000), noteType = Tell}])),("andara:",(Nothing,[Note {noteSender = "audreyt", noteContents = "does webterminal server actually spawn children? it doesn't look like it",
20:11:50 <lambdabot> [106 @more lines]
20:11:50 <LoganCapaldo> > 2#01 -- ?
20:11:51 <LordBrain> > 010b
20:11:52 <lambdabot>   Not in scope: `#'
20:11:54 <lambdabot>   Not in scope: `b'
20:11:58 <LordBrain> hmmm
20:12:11 <LordBrain> is it even doable
20:12:13 <LordBrain> ?
20:12:19 <vincenz> sorear: So how does that deal with the @tell you sent me, and what does this have to do with me?
20:12:34 <LoganCapaldo> thsi sound sliek a job for the haskell language report
20:12:40 <LoganCapaldo> or google
20:12:44 <nmessenger> zipWith (*) (iterate (*2) 1) . map fromEnum $ [True, False, True]
20:12:49 <LoganCapaldo> @go haskell binary numeric literals
20:12:51 <lambdabot> http://www.cs.kent.ac.uk/projects/vital/overview/index.html
20:12:52 <lambdabot> Title: Vital homepage
20:13:07 <sorear> vincenz        JohnMeacham    Where would I find literature on GRIN? IT's a hard to google term
20:13:07 <dons> um. this print-notices thing doesn't seem right..
20:13:13 <vincenz> oh
20:13:14 <vincenz> :)
20:13:20 <sorear> dons: how so?
20:13:22 <LordBrain> well... thats the idea but i dont want to write [True,False,True], you know
20:13:24 <vincenz> Wow, that's a long time ago
20:13:29 <LoganCapaldo> @where report
20:13:29 <lambdabot> http://www.haskell.org/onlinereport/
20:13:33 <vincenz> sorear: anyways, thanks :)
20:13:48 <LordBrain> i suppose... i could use decimal coded binary
20:13:51 <LordBrain> hahaha
20:14:01 <nmessenger> heh
20:14:03 <dons> noisy.
20:14:14 <vincenz> >>= bed
20:14:21 <LoganCapaldo> "Integer literals may be given in decimal (the default), octal (prefixed by 0o or 0O) or hexadecimal notation (prefixed by 0x or 0X)."
20:14:29 <LoganCapaldo> So, no, no binary literals for you
20:14:37 <LordBrain> aw
20:14:40 <LordBrain> well hex...
20:14:41 <sorear> @purge-notices
20:14:41 <sorear> @tell ! For old dead @messages, see http://members.cox.net/stefanor/tell.dump
20:14:42 <lambdabot> Messages purged.
20:14:42 <lambdabot> Consider it noted.
20:14:44 <encryptio> forkIO sleepCycle
20:14:57 <sorear> there, less noisy
20:14:58 <LoganCapaldo> Unless maybe theres an -fglasgow-exts for it
20:15:32 <LordBrain> i suppose it would be simple to code if i use a string
20:15:42 <LordBrain> map "101" f
20:15:49 <LordBrain> something like that
20:16:34 <LordBrain> that's not too bad
20:16:53 <nmessenger> > let readBin = sum . zipWith (*) (iterate (*2) 1) . map digitToInt in readBin "10101010"
20:16:54 <lambdabot>  85
20:17:00 <nmessenger> > let readBin = sum . zipWith (*) (iterate (*2) 1) . map digitToInt in readBin "101010"
20:17:02 <lambdabot>  21
20:17:09 <LoganCapaldo> > let bin = foldl1 (\a v -> a * 2 + v) in bin "101"
20:17:10 <lambdabot>   add an instance declaration for (Num Char)
20:17:16 <LoganCapaldo> derr
20:17:23 <LoganCapaldo> I forgot the important bit
20:17:26 <LordBrain> i could just use zipWith for my purposes tho.. the fact that its a number isnt so important after all, i'm just looking at them as flags
20:17:33 <LoganCapaldo> > let bin = foldl1 (\a v -> a * 2 + v) in bin [1,0,1]
20:17:34 <lambdabot>  5
20:18:12 <nmessenger> oh, forgot (. reverse)
20:18:36 <Pastorn> has anyone tried projecteuler.net
20:18:59 <narain> Pastorn: fantasma was
20:19:23 <Pastorn> i'm at problem 1 and i KNOW that i have the solution, but the webpage refuses to recognize my greatness
20:19:50 <Pastorn> @paste
20:19:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:20:17 <LordBrain> so i could make my partialmapper function, then i havent ever tried but i could probably make a rule to optimize it away, and i'd have the language feature i want.
20:20:27 <encryptio> Pastorn: below and not including 1000, btw.
20:21:11 <narain> ?t (||)
20:21:11 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
20:21:15 <narain> :t (||)
20:21:18 <lambdabot> Bool -> Bool -> Bool
20:22:06 <LoganCapaldo> > let bin = foldl (\a v -> a * 2 + v ) . map (\x -> case x of '0' -> 0; '1' -> 1; _ -> 0) in bin "101"
20:22:07 <lambdabot>   add an instance declaration for (Num [t])
20:22:09 <Pastorn> http://hpaste.org/969 (announce didn't work...)
20:22:23 <LoganCapaldo> > let bin = foldl (\a v -> a * 2 + v ) $ map (\x -> case x of '0' -> 0; '1' -> 1; _ -> 0) in bin "101"
20:22:24 <lambdabot>  Couldn't match expected type `[Char] -> [t]'
20:22:44 <encryptio> Pastorn: what about multiples of both, 15?
20:22:48 <LoganCapaldo> > let bin xs = foldl (\a v -> a * 2 + v ) $ map (\x -> case x of '0' -> 0; '1' -> 1; _ -> 0) xs in bin "101"
20:22:49 <lambdabot>   add an instance declaration for (Num [t])
20:22:49 <lambdabot>     In the expression:
20:22:49 <lambdabot>         le...
20:22:52 <Pastorn> whoops
20:22:53 <encryptio> [15,30,..]
20:23:24 <nmessenger> > [15,30 .. ] -- note no second comma
20:23:28 <lambdabot>  [15,30,45,60,75,90,105,120,135,150,165,180,195,210,225,240,255,270,285,300,3...
20:23:46 <encryptio> > [-2,-3,..]
20:23:47 <lambdabot>  Parse error
20:23:49 <encryptio> > [-2,-3..]
20:23:50 <lambdabot>  [-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22...
20:24:00 <narain> > let n `divides` m = m `mod` n == 0 in sum . filter (\n -> (3 `divides` n) && (5 `divides` n)) $ [1..999]
20:24:02 <lambdabot>  33165
20:24:05 <fantasma> Pastorn, trying projecteuler :)
20:24:17 <Pastorn> yay!!
20:24:30 <fantasma> i have haskell code for problems 1-30
20:24:35 <encryptio> narain: ||, not &&. =p
20:25:30 <narain> guh. right. i even looked || up. i don't know what happened
20:25:39 <narain> > let n `divides` m = m `mod` n == 0 in sum . filter (\n -> (3 `divides` n) || (5 `divides` n)) $ [1..999]
20:25:40 <lambdabot>  233168
20:25:57 <fantasma> > sum (filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0) [1..999])
20:25:59 <lambdabot>  233168
20:27:14 <Pastorn> i have l3, l5 and l15 made up with [x,2x..] and takeWhile
20:27:42 <Pastorn> not the fastest, but it works
20:27:50 <fantasma> l3 as in problem 3?
20:28:35 <encryptio> fastest would be already folded during compilation.
20:28:50 <Pastorn> l3 = takeWhile (<1000) [3,6..]
20:29:00 <Pastorn> p1 = sum $ (l3 ++ l5) \\ l15
20:29:18 <encryptio> that's wrong too..
20:29:36 <nmessenger> LB!!!!
20:29:43 <nmessenger> @bot
20:29:50 <dons> strange.
20:29:51 <fantasma> > take 20 [3,6..]
20:29:56 <dons> give it some time ...
20:29:56 <lambdabot> :)
20:30:02 <narain> hi lambdabot! welcome to #haskell!
20:30:04 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60]
20:30:26 <fantasma> where did you go bot
20:30:48 <nmessenger> > sum $ takeWhile (<1000) $ union [3,6..] [15,30..]
20:30:49 <lambdabot>  166833
20:31:04 <fantasma> > let fiblist = (0 : 1 : zipWith (+) fiblist (tail fiblist)) in sum (filter (\x -> x `mod` 2 == 0) (takeWhile (<1000000) fiblist))
20:31:08 <lambdabot>  1089154
20:31:35 <fantasma> @poll
20:31:36 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
20:31:39 <dons> "lambdabot: out of memory (requested 1048576 bytes)"
20:31:57 <fantasma> @poll-add
20:31:57 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
20:32:01 <nmessenger> > let t1000 = takeWhile (<1000) in sum $ union (t1000 [3,6..]) (t1000 [15,30..])
20:32:05 <lambdabot>  166833
20:32:07 <fantasma> @help poll-add
20:32:08 <lambdabot> poll-add <name>             Adds a new poll, with no candidates
20:32:32 <fantasma> @help poll-add lambdabot
20:32:32 <lambdabot> poll-add <name>             Adds a new poll, with no candidates
20:32:40 <fantasma> @poll-add lambdabot
20:32:40 <lambdabot> Added new poll: "lambdabot"
20:32:54 <nmessenger> @choice-add lambdabot <3
20:32:54 <lambdabot> New candidate "<3", added to poll "lambdabot".
20:33:10 <fantasma> @choice-add lambdabot </3
20:33:10 <lambdabot> New candidate "</3", added to poll "lambdabot".
20:33:20 <fantasma> @vote lambdabot <3
20:33:20 <lambdabot> voted on "<3"
20:34:02 <fantasma> @poll-list
20:34:02 <lambdabot> ["EvilPoll","OperatingSystem","RestrictToOneVote","Written_a_compiler_or_interpreter?","cheeky-off","jabberName","lambdabot"]
20:34:22 <nmessenger> @poll-show EvilPoll
20:34:22 <lambdabot> ["\\nfoo\\n","\"hello\""]
20:34:27 <fantasma> @poll-show RestrictToOneVote
20:34:27 <lambdabot> ["PerOption","PerPoll","FileNotFound","No","Yes"]
20:35:01 <narain> ?poll-results lambdabot
20:35:02 <lambdabot> Poll results for lambdabot (Open): </3=0, <3=1
20:35:15 <Pastorn> @paste
20:35:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:35:19 <narain> ?poll-results EvilPoll
20:35:19 <lambdabot> Poll results for EvilPoll (Open): \nfoo\n=0, "hello"=0
20:35:25 <dibblego> is a foldl the same efficiency s foldl' if f is strict in its arguments?
20:35:33 <fantasma> @choice-add OS/2 OperatingSystem
20:35:33 <lambdabot> No such poll: "OS/2"
20:35:42 <fantasma> @choice-add OperatingSystem OS/2
20:35:42 <lambdabot> New candidate "OS/2", added to poll "OperatingSystem".
20:36:00 <JohnMeacham> sorear: google boquist + grin
20:36:04 <dons> dibblego: it'd need to force the result, wouldn't it?
20:36:34 <dibblego> hrm
20:36:40 <sorear> JohnMeacham: didn't mean to wake you :)  I was answering vincenz' query.
20:36:47 <sorear> JohnMeacham: (and I found it, even a url)
20:37:00 <dons> ?src foldl'
20:37:00 <lambdabot> foldl' f a []     = a
20:37:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:37:02 <dons> ?src foldl
20:37:02 <lambdabot> foldl f z xs = lgo z xs
20:37:02 <lambdabot>     where lgo z []     =  z
20:37:02 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
20:37:21 <fantasma> ?src show
20:37:22 <lambdabot> show x = shows x ""
20:37:29 <fantasma> ?src shows
20:37:30 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:37:45 <fantasma> @vote lambdabot </3
20:37:45 <lambdabot> voted on "</3"
20:37:52 <dons> boo
20:37:55 <Pastorn> http://hpaste.org/970 no announce LB? shame on you
20:38:03 <lambdabot>  @vote lambdabot <3
20:38:12 <nmessenger> @vot lambdabot <3
20:38:13 <lambdabot> voted on "<3"
20:38:13 <Pastorn> maybe i'm uning the wrong algoritm for fibs
20:38:23 <fantasma> @unvote lambdabot </3
20:38:23 <lambdabot> voted on "</3"
20:38:25 <glguy> hmm, hpaste quit
20:38:29 <fantasma> what???
20:38:37 <nmessenger> hahaha
20:38:37 <fantasma> @unvote
20:38:37 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
20:38:41 <fantasma> wtf
20:38:58 <fantasma> @help unvote
20:38:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:39:10 <narain> Pastorn: yeah, that's a really slow fibs
20:39:11 <nmessenger> unvote --(spellchecker)--> vote
20:39:24 <fantasma> oh lol!
20:39:26 <roconnor> > let tm = [False,True]++(tail tm >>= Control.Monad.sequence [id,not]) in map (head.show.length) $ lines $ map (\x -> if x then '\n' else 'X')
20:39:29 <lambdabot>  Couldn't match expected type `String'
20:39:38 <Pastorn> narain: but should't it remember all the old calculated values of fibs?
20:39:48 <glguy> hpaste: url
20:39:48 <hpaste> Haskell paste bin: http://hpaste.org/
20:39:56 <roconnor> > let tm = [False,True]++(tail tm >>= Control.Monad.sequence [id,not]) in map (head.show.length) $ lines $ map (\x -> if x then '\n' else 'X') tm
20:39:58 <lambdabot>  "101202101210201202102012101202101210201210120210201202101210201202102012101...
20:40:20 <roconnor> > let tm = [False,True]++(tail tm >>= Control.Monad.sequence [id,not]) in map (head.show.length) $ lines $ map (\x -> if x then 'X' else '\n') tm
20:40:24 <lambdabot>  "021020121012021020120210121020121012021012102012021020121012021020120210121...
20:40:27 <narain> Pastorn: apparently not?
20:40:40 <encryptio> @tpye 2
20:40:40 <lambdabot> Maybe you meant: time type
20:41:06 <fantasma> hpaste, what are you thinking
20:41:18 <narain> Pastorn: not that i know anything about haskell compilers, but how many values would it remember in the general case?
20:41:41 <Pastorn> all that was calculated "recently"
20:41:48 <Pastorn> so it SHOULD do this fast
20:41:56 <roconnor> that string has no substring of the form XX for any string X.
20:42:21 <roconnor> @pl let tm = [False,True]++(tail tm >>= Control.Monad.sequence [id,not]) in map (head.show.length) $ lines $ map (\x -> if x then 'X' else '\n') tm
20:42:21 <lambdabot> map (head . show . length) (lines (map (flip (flip if' 'X') '\n') (fix (([False, True] ++) . (Control . Monad . sequence [id, not] =<<) . tail))))
20:43:01 <roconnor> > map (head . show . length) (lines (map (flip (flip if' 'X') '\n') (fix (([False, True] ++) . (Control.Monad.sequence [id, not] =<<) . tail))))
20:43:03 <narain> Pastorn: well i don't know but you should probably try a different fibs algorithm
20:43:04 <lambdabot>   Not in scope: `if''
20:43:06 <Pastorn> heh... seems faster: let fibs = 1 : 2 : zipWith (+) fibs (tail fibs)
20:43:22 <nmessenger> if' a b c = if a then b else c
20:43:33 <roconnor> > let if' a b c = if a then b else c in map (head . show . length) (lines (map (flip (flip if' 'X') '\n') (fix (([False, True] ++) . (Control.Monad.sequence [id, not] =<<) . tail))))
20:43:34 <lambdabot>  "021020121012021020120210121020121012021012102012021020121012021020120210121...
20:43:46 <narain> > fix ((0:) . scanl (+) 1)
20:43:48 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
20:43:52 <fantasma> :t error
20:43:55 <lambdabot> forall a. [Char] -> a
20:44:25 <Pastorn> ?scr fix
20:44:26 <lambdabot> Maybe you meant: arr rc src
20:44:32 <Pastorn> narain: plz?
20:44:44 <fantasma> > map error ['a'..'z']
20:44:45 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
20:44:49 <nmessenger> @type \s -> let _=s :: String; x = x in x
20:44:51 <lambdabot> String; x = x in x :: forall t. String -> t
20:45:18 <fantasma> Pastorn, check the pastebin again
20:45:50 <fantasma> > error 'a'
20:45:51 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
20:45:52 <Pastorn> fantasma: there is a funciton "even"
20:45:55 <narain> Pastorn: fix f = let x = f x in x
20:45:59 <narain> ?src fix
20:45:59 <lambdabot> fix f = let x = f x in x
20:46:01 <nmessenger> > error "wrong type!"
20:46:02 <lambdabot>  Exception: wrong type!
20:46:05 <fantasma> > even [1..10]
20:46:06 <lambdabot>   add an instance declaration for (Integral [t])
20:46:06 <lambdabot>     In the expression: even ...
20:46:15 <nmessenger> > map even [1..10]
20:46:15 <fantasma> > filter even [1..10]
20:46:17 <lambdabot>  [False,True,False,True,False,True,False,True,False,True]
20:46:17 <lambdabot>  [2,4,6,8,10]
20:46:17 <Pastorn> narain: why can you when I can't!?
20:46:21 <Pastorn> unfair!!
20:46:25 <narain> Pastorn: because you wrote scr :p
20:46:34 <Pastorn> haha
20:46:36 <Pastorn> maybe...
20:46:47 <fantasma> even 4
20:46:51 <fantasma> > even 3
20:46:54 <lambdabot>  False
20:46:55 <narain> <Pastorn> ?scr fix<lambdabot> Maybe you meant: arr rc src
20:47:01 <nmessenger> LB even asked if you meant src
20:47:07 <Pastorn> hehe
20:47:19 <nmessenger> @arr!
20:47:19 <lambdabot> I'll crush ye barnacles!
20:47:24 * Pastorn should fetch his reading glasses
20:47:25 <narain> ?yow
20:47:25 <lambdabot> I like your SNOOPY POSTER!!
20:47:27 <fantasma> @rc
20:47:27 <lambdabot> Not enough privileges
20:47:32 <narain> ?arr
20:47:32 <lambdabot> Shiver me timbers!
20:47:37 * Leimy notes this channel's membership seems to have grown a lot since he was last here... 
20:47:44 <Leimy> Is haskell really becoming that interesting to folks? :-)
20:47:58 <Pastorn> fantasma: could you tell me how this fibs that you wrote works?
20:48:05 <narain> Leimy: programming.reddit.com is probably a big influence
20:48:18 <dmwit> ?users
20:48:19 <lambdabot> Maximum users seen in #haskell: 336, currently: 304 (90.5%), active: 16 (5.3%)
20:48:27 <sorear> my olegs are failing...
20:48:35 <dmwit> 16 active users... not so many. ;-)
20:48:50 <fantasma> Pastorn, it does the same thing your's does but with linear complexity
20:48:50 <Pastorn> oh... nevermind
20:49:24 <narain> dmwit: would be nice to compare with maximum active users ever seen :)
20:49:45 <dmwit> I think the most I've ever seen was around 35 or so...
20:49:53 <dons> it wsa 47 earlier
20:50:22 <Pastorn> fuck ME that's fast
20:50:30 <fantasma> > [10..1]
20:50:31 <lambdabot>  []
20:50:31 <Leimy> don't think I've ever seen programming.reddit.com
20:50:40 <dmwit> > [10,9..1]
20:50:41 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
20:50:50 <fantasma> > zipWith (mod) [1..10] [10,9..1]
20:50:51 <lambdabot>  [1,2,3,4,5,1,3,2,1,0]
20:50:51 <narain> what's an "active" user? one who spoke in the last how many minutes?
20:50:58 <sorear> 240
20:51:00 <glguy> 240
20:51:01 <sorear> or 15
20:51:05 <glguy> ?
20:51:06 <sorear> can't remember which :)
20:51:14 <ailndx> anyone here using hs-plugins in win?
20:51:16 <araujo> hello!
20:51:20 <dons> 64 (20.0%)
20:51:23 <dons> is the highest
20:51:24 <sorear> wow, my heterogenous unions are working...
20:51:34 <dons> > 4 * 60 -- active
20:51:35 <lambdabot>  240
20:51:36 <ftegularius> that's what she said
20:51:40 <araujo> dons, hi there , query?
20:51:46 <dons> of course.
20:52:02 <Leimy> > concatMap (\y -> concatMap (\x -> [x + y]) [1..3]) [4..10]
20:52:03 <lambdabot>  [5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12,11,12,13]
20:52:03 <fantasma> why are there so many haskell articles on reddit?
20:52:14 <dons> hey Leimy
20:52:20 <roconnor> > let tm = [False,True]++(tail tm >>= Control.Monad.sequence [id,not]) in let g [False] = []; g [False,False] = [0]; g x = [length x] in map (head.show) $ group tm >>= g
20:52:21 <lambdabot>  "210201210120210201202101210201210120210121020120210201210120210201202101210...
20:52:26 <dmwit> > liftM2 (+) [1,2,3] [4..10]
20:52:27 <lambdabot>  [5,6,7,8,9,10,11,6,7,8,9,10,11,12,7,8,9,10,11,12,13]
20:52:33 <dons> fantasma: there's a lot of new programming research done on haskell? its a playground for programming mind games?
20:52:37 <Leimy> dons: hello :-) Long time no see :-)
20:52:39 <dons> C++ puzzles are boring?
20:52:42 <roconnor> my one liner is getting kinda long
20:52:47 <ailndx> dons would it be able to extract the safe evaluation out of hs-plugins so i can compile it with my own app and just run it through ghci or something?
20:53:03 <dons> ailndx: you can just use the 'runplugs' app provided by lambdabot
20:53:29 <roconnor> What's the best way of counting the number of Trues occuring between each pair of Falses?
20:53:31 <Korollary> dons spams reddit
20:53:47 <Korollary> nonetheless there's more interesting stuff
20:53:55 <nmessenger> roconnor: map length . group?
20:54:10 <ailndx> dons: and what is the requirement of that, do i first have to install lambdabot then?, the problem is i tried hs-plugins before but didnt get it to work
20:54:13 <roconnor> nmessenger: not quite
20:54:29 <dons> ailndx: no, grab the src for lambdabot, look at the scripts/RunPlug.hs file
20:54:31 <JohnMeacham> hmm.. I think I found the bug that was causing most everything to fail, Text.Printf or showing floating point values tickled it and a whole lot of the tests do one of those. fixing.
20:54:32 <dons> and rip it out
20:54:34 <roconnor> nmessenger: I do varient of that
20:54:43 <ailndx> ok
20:54:44 <dmwit> > let z = [True, True, False, True, False, False, True, False] in zip3 z (tail z) (tail (tail z))
20:54:45 <lambdabot>  [(True,True,False),(True,False,True),(False,True,False),(True,False,False),(...
20:54:49 <roconnor> you see that I have to speciall case [False,False] to return 0.
20:55:21 <nmessenger> map snd . filter fst . map (head &&& length) . group
20:55:22 <dmwit> > let z = [True, True, False, True, False, False, True, False] in filter (==(False, True, False)) . zip3 z (tail z) . tail $ tail z
20:55:23 <lambdabot>  [(False,True,False),(False,True,False)]
20:55:31 <dmwit> > let z = [True, True, False, True, False, False, True, False] in length . filter (==(False, True, False)) . zip3 z (tail z) . tail $ tail z
20:55:32 <lambdabot>  2
20:55:46 <ailndx> dons: ok, now ive grabbed it, what to do then?
20:55:59 <dons> ailndx: so in scripts/RunPlugs.hs, that's the program you want
20:56:11 <dons> take it, put it somewhere, and build it using the flags prescribed in the .cabal file
20:56:20 <ailndx> dons: but how can i use that in my own program?
20:56:21 <dons> you'll want to edit it to remove the L.hs stuff (lambdabot local state )
20:56:26 <roconnor> > (map snd . filter fst . map (head &&& length) . group) [False,False]
20:56:27 <lambdabot>  []
20:56:29 <dons> ailndx: ah, right, you then look at Plugins/Eval.hs
20:56:33 <dons> to see how you call 'runplugs'
20:56:34 <roconnor> bzzt
20:56:37 <dons> ailndx: and hack!
20:56:43 <dons> use the src :-)
20:57:00 <roconnor> let g [False] = []; g [False,False] = [0]; g x = [length x] in map g $ group [False,False]
20:57:04 <roconnor> > let g [False] = []; g [False,False] = [0]; g x = [length x] in map g $ group [False,False]
20:57:05 <lambdabot>  [[0]]
20:57:06 <ailndx> dons: well, since i hardly know the basics of either ghc or haskell thats kind of a problem
20:57:09 <glguy> ?let doesthis = "work yet"
20:57:11 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:57:15 <dmwit> roconnor: Seen mine?
20:57:22 <roconnor> > let g [False] = []; g [False,False] = [0]; g x = [length x] in g =<< group [False,False]
20:57:24 <lambdabot>  [0]
20:57:43 <glguy> ?type mapM
20:57:45 <lambdabot>     Ambiguous occurrence `mapM'
20:57:45 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
20:57:53 <narain> ?type (=<<)
20:57:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
20:57:58 <narain> ?type (<<)
20:58:00 <lambdabot> Not in scope: `<<'
20:58:01 <dons> ailndx: ok. well.. hmm. you're asking something technically challenging. so basically, you'll have to hack at it till it works. all the src you need is in RunPlugs.hs and Plugin/Eval.hs
20:58:35 <roconnor> dmwit: I want someting that will transform [False,True,True,False,True,False,False...] into [2,1,0,...
20:58:48 <dmwit> Ahh.... interesting.
20:58:48 <roconnor> 2 trues between the first pair of false
20:58:49 <nmessenger> hmm
20:58:52 <roconnor> then 1 true
20:58:52 <ailndx> dons: got those 2
20:58:53 <glguy> map length . group
20:59:07 <glguy> (half way)
20:59:13 <roconnor> > (map length . group) [False,True,True,False,True,False,False...]
20:59:13 <lambdabot>  Parse error
20:59:17 <roconnor> > (map length . group) [False,True,True,False,True,False,False.]
20:59:18 <lambdabot>  Parse error
20:59:19 <roconnor> > (map length . group) [False,True,True,False,True,False,False]
20:59:20 <lambdabot>  [1,2,1,1,2]
20:59:48 <roconnor> > let g [False] = []; g [False,False] = [0]; g x = [length x] in g =<< group [False,True,True,False,True,False,False]
20:59:49 <lambdabot>  [2,1,0]
20:59:54 <roconnor> that's the best I have so far
21:00:13 <dmwit> But it doesn't do too well for [False, False, False, False]...
21:00:21 <roconnor> dmwit: good point
21:00:34 <glguy> sounds like you just need to use break over and over
21:00:39 <roconnor> ... although that doesn't occur in the sequence that I care about thankfully
21:00:46 <glguy> > break id [False,True,False]
21:00:47 <lambdabot>  ([False],[True,False])
21:00:58 <ailndx> dons: do i first have to compile runplugs.hs to an exe?
21:01:00 <nmessenger> should [False,False,False,False] = [0,0,0] or [0,0]?
21:01:04 <roconnor> some sort of unfoldr with break?
21:01:19 <roconnor> nmessenger: [0,0,0]
21:01:29 <dons> ailndx: that's a good start, yes.
21:01:32 <dmwit> roconnor: Parsec?
21:01:33 <dons> get a working runplugs
21:01:34 <dmwit> =P
21:01:34 <roconnor> nmessenger: although I will never have False three times in a row
21:01:37 <dons> which will eval fragments
21:02:40 <ailndx> dons: hmm so all i have to do is basically modify a few lines in Eval.hs?
21:03:08 <dons> you'd adapt the code in Eval.hs to suit your application
21:03:17 <dons> i.e. port it, using the hints in Eval.hs
21:03:23 <ailndx> since i want it to work in a "lambdabot style" but in my own program, i send in a string and get a string back
21:03:36 <roconnor> I also have map length $ lines $ map (\x->if x then
21:03:37 <dons> yep
21:03:41 <dons> so just like in Eval.hs
21:03:48 <ailndx> yeah i think so
21:03:58 <dons> ailndx: so just take the function 'plugs :: String -> IO String
21:04:00 <roconnor> > map length $ lines $ map (\x->if x then '\n' else 'X') [False,True,True,False,True,False,False]
21:04:01 <lambdabot>  [1,0,1,2]
21:04:11 <roconnor> > map length $ lines $ map (\x->if x then 'X' else '\n') [False,True,True,False,True,False,False]
21:04:12 <lambdabot>  [0,2,1,0]
21:04:21 <roconnor> > tail $ map length $ lines $ map (\x->if x then 'X' else '\n') [False,True,True,False,True,False,False]
21:04:22 <lambdabot>  [2,1,0]
21:04:27 <roconnor> that also seems to work
21:04:28 <ailndx> dons: i havent even made a project of several files before so not sure how to put it together
21:04:34 <roconnor> > tail $ map length $ lines $ map (\x->if x then 'X' else '\n') [False,False,False]
21:04:35 <lambdabot>  [0,0]
21:04:43 <roconnor> but I don't like it so much
21:04:54 <nmessenger> > unfoldr (let f (False:xs) = Just (span id xs) ; f _ = Nothing in f) [False,True,True,False,True,False,False]
21:04:55 <lambdabot>  [[True,True],[True],[],[]]
21:05:31 <dons> ailndx: have a look at 'how to write a haskell program' on haskell.org's wiki
21:05:38 <ailndx> okay
21:05:42 <dons> shows how to set up the build system, packaging and multiple modules
21:05:46 <dons> just dive in and hack :-)
21:05:51 <ailndx> pff :)
21:06:13 <Korollary> dons: btw I figured out how to run tests via cabal
21:06:54 <nmessenger> > map length $ unfoldr (let f (False:xs@(_:_)) = Just (span id xs) ; f _ = Nothing in f) [False,True,True,False,True,False,False]
21:06:56 <lambdabot>  [2,1,0]
21:07:51 <Korollary> dons: http://hpaste.org/789
21:08:02 <dons> ah great
21:08:56 <ailndx> dons: http://haskell.org/ghc/docs/latest/html/building/ is it all this i have to read?
21:08:57 <lambdabot> Title: Building and developing GHC
21:09:31 <dons> no!
21:09:51 <dons> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
21:09:52 <lambdabot> Title: How to write a Haskell program - HaskellWiki
21:09:53 <sorear> I think I've found the perfect solution for errory stuff.  HSet s => Either s a
21:09:57 <dmwit> > let f [] = [], f (False:xs) = f xs, f xs@(True:t) = let (trues, rest) = break id xs in length trues:f rest in f [False, True, True, False, True, False, False]
21:09:57 <lambdabot>  Parse error
21:10:08 <glguy> g [] = (0,[])
21:10:08 <glguy> g [False] = (0,[])
21:10:08 <glguy> g (False:xs) = (0, a : b) where (a,b) = g xs
21:10:08 <glguy> g (True:xs) = (1+a,b) where (a,b) = g xs
21:10:09 <sorear> development of HSet in in progress...
21:10:33 <dmwit> > let f [] = [], f (False:xs) = f xs, f xs@(True:t) = length trues:f rest where (trues, rest) = break id xs in f [False, True, True, False, True, False, False]
21:10:33 <lambdabot>  Parse error
21:10:38 <roconnor> glguy: that's too clearly written.  ;)
21:10:40 <ailndx> hmm, do i have to use this cabal stuff?
21:10:40 <dmwit> Oh, that doesn't work anyway.
21:10:46 <glguy> roconnor: what's the goal ?
21:11:06 <Korollary> ailndx: You don't have to, but eventually you'll want to. And it's rather simple.
21:11:06 <roconnor> glguy: to do it on one line in some strange clever way using the Prelude functions ;)
21:11:18 <LoganCapaldo> sorear: HSet being the Set equivalent to HList?
21:11:18 <ailndx> okay
21:11:25 <roconnor> glguy: well, the standard library functions
21:11:44 <glguy> roconnor: I can make that a fold :)
21:11:48 <dmwit> ?hoogle (a -> Bool) -> [a] -> [[a]]
21:11:49 <lambdabot> No matches, try a more general search
21:11:53 <sorear> LoganCapaldo: yes
21:11:59 <dmwit> ?hoogle [a] -> [[a]]
21:11:59 <lambdabot> List.inits :: [a] -> [[a]]
21:11:59 <lambdabot> List.tails :: [a] -> [[a]]
21:11:59 <lambdabot> List.group :: Eq a => [a] -> [[a]]
21:12:07 <sorear> LoganCapaldo: it doesn't exist, i'm trying to write it now...
21:12:15 <roconnor> > map length $ unfoldr (let f (False:xs@(_:_)) = Just (span id xs) ; f _ = Nothing in f) [False,True,True,False,True,False,False,False,False]
21:12:16 <lambdabot>  [2,1,0,0,0]
21:12:25 <roconnor> nmessenger: I like your solution
21:12:28 <roconnor> span id
21:12:28 <LoganCapaldo> good luck
21:12:37 <LoganCapaldo> may the Olegness be with you
21:12:44 <nmessenger> = break not :P
21:12:50 <dmwit> > map (subtract 1) . map length . group $ intersperse True [False, True, True, False, True, False, False]
21:12:51 <lambdabot>  [0,4,0,2,0,0,0]
21:13:04 <dmwit> Need some way to take only the odd entries, though. =)
21:13:15 <ailndx> dons: what licence stuff do i have to care about when using runplugs/eval?
21:13:34 <roconnor> @type unfoldr
21:13:36 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
21:13:56 <dons> ailndx: its BSD3
21:14:00 <dons> so free for use.
21:14:03 <nmessenger> dmwit: snd . transpose . chunks 2
21:14:09 <dmwit> :t chunks
21:14:12 <lambdabot> Not in scope: `chunks'
21:14:16 <nmessenger> not in the libs :)
21:14:19 <dmwit> =P
21:14:24 <nmessenger> commonly written by #haskellers
21:14:58 <nmessenger> chunks n = takeWhile (not . null) . unfoldr (Just . splitAt n)
21:15:05 <dmwit> > map (subtract 1) . map length . group $ intersperse True [False, False, False, False]
21:15:06 <lambdabot>  [0,0,0,0,0,0,0]
21:15:11 <sorear> @let x = 2
21:15:12 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
21:15:13 <ailndx> dons: i have no clue of those difference licences, just saw eval was GPL, but i aint gonna site and read through all those sites :)
21:15:42 <glguy> > let h = h = snd . foldr (\b -> if b then first succ else (,) 0 . uncurry (:)) (0,[]) in h [False,False,True,False,True,True]
21:15:42 <lambdabot>  Parse error
21:15:43 <dons> i hearby give you permission to use a BSD3 license on it (non GPL)
21:15:52 <ailndx> ok thx
21:15:54 <glguy> > let h = snd . foldr (\b -> if b then first succ else (,) 0 . uncurry (:)) (0,[]) in h [False,False,True,False,True,True]
21:15:55 <lambdabot>  [0,1,2]
21:16:10 <dmwit> > snd . transpose . takeWhile (not . null) . unfldr (Just . splitAt 2) . map (subtract 1) . map length . group $ intersperse True [False, False, False, False]
21:16:11 <lambdabot>   Not in scope: `unfldr'
21:16:18 <dmwit> > snd . transpose . takeWhile (not . null) . unfoldr (Just . splitAt 2) . map (subtract 1) . map length . group $ intersperse True [False, False, False, False]
21:16:19 <lambdabot>  Couldn't match expected type `(a, b)'
21:16:25 <glguy> > let h = snd . foldr (\b -> if b then first succ else (,) 0 . uncurry (:)) (0,[]) in h [False,False,True,False,True,True,False,False,True,False,True,True]
21:16:26 <lambdabot>  [0,1,2,0,1,2]
21:16:28 <dmwit> > (!! 2) . transpose . takeWhile (not . null) . unfoldr (Just . splitAt 2) . map (subtract 1) . map length . group $ intersperse True [False, False, False, False]
21:16:30 <lambdabot>  Exception: Prelude.(!!): index too large
21:16:34 <dmwit> > (!! 1) . transpose . takeWhile (not . null) . unfoldr (Just . splitAt 2) . map (subtract 1) . map length . group $ intersperse True [False, False, False, False]
21:16:35 <lambdabot>  [0,0,0]
21:16:38 <glguy> roconnor: better?
21:16:56 <roconnor> > glguy, that's the spirit!
21:16:56 <lambdabot>  Parse error
21:16:59 <roconnor> er
21:17:02 <roconnor> glguy, that's the spirit!
21:17:03 <nmessenger> silly me, (!!1)
21:17:15 <ddarius> head . tail
21:17:21 <dmwit> > (!! 1) . transpose . takeWhile (not . null) . unfoldr (Just . splitAt 2) . map (subtract 1) . map length . group $ intersperse True [False,False,True,False,True,True,False,False,True,False,True,True]
21:17:22 <lambdabot>  [0,2,4,0,2,3]
21:17:28 <roconnor> > map length $ unfoldr (let f (False:xs@(_:_)) = Just (span id xs) in f) [False,True,True,False,True,False,False,False,False]
21:17:29 <lambdabot>   Non-exhaustive patterns in function f
21:17:48 <nmessenger> er, maybe not map (subtract 1), but map (`div` 2)?
21:17:49 <Pastorn> dmwit: that's what i call readable! :)
21:18:03 <dmwit> Pastorn: =D
21:18:08 <dmwit> nmessenger: Ah, yes.
21:18:25 <dmwit> > (!! 1) . transpose . takeWhile (not . null) . unfoldr (Just . splitAt 2) . map (flip div 2) . map length . group $ intersperse True [False,False,True,False,True,True,False,False,True,False,True,True]
21:18:26 <lambdabot>  [0,1,2,0,1,2]
21:18:35 <dons> so, did we find any Ohio haskell hackers for this guy? http://blogs.teamb.com/craigstuntz/archive/2007/03/09/WantedHaskellDeveloper.aspx
21:18:37 <lambdabot> Title: Wanted: Haskell Programmer, http://tinyurl.com/2yrghp
21:18:47 <Pastorn> and the fact that someon other than you understands that is much too irritating too be good
21:18:54 <dons> (note, he just wanted to use the knowledge of haskell as a filter for good programmers...)
21:19:52 <dmwit> That is some pathological Haskell right there.
21:20:10 <nmessenger1> (mumble, mumble, ISP, hate, death)
21:20:51 <ailndx> dons: i like this line that he wrote:  "It's not like you're going to find any paying employment writing Haskell anyway"
21:20:55 <Korollary> Well, he now has to evaluate whether the application "really" knows haskell. If you're going to do that, why not just conduct the regular C++ interview.
21:21:03 <dons> yeah, that's a bit low.
21:21:33 <glguy> Korollary: he could hire someone to validate the haskell programmer
21:21:44 <dmwit> But who will test the tests??
21:21:47 <dmwit> Stack overflow!
21:21:59 <glguy> eventually, he'll find someone that he knows and trusts
21:22:04 <ailndx> i seriously doubt that a big percentage of all good programmers actually knows haskell though, so i doubt it as a filter
21:22:05 <glguy> who can validate the validator for the validator
21:22:19 * nmessenger reads logs.  "I'm an Ohioan!"
21:22:31 <glguy> but who polices the police police? the police police police police police
21:22:33 <Korollary> Most good programmers don't know many languages.
21:22:36 <dons> ailndx: he wants to find people interested in programming, doesn't he?
21:22:51 <dons> he's stating explicitly he wants to use this as a filter
21:23:02 <glguy> Korollary: most lousy ones don't know many either
21:23:08 <LoganCapaldo> filter knowsHaskell programmers
21:23:10 <glguy> but I guess that's not the point :)
21:23:22 <dons> a similar filter is used on haskell programmers at some place: implement your own monad
21:23:22 <dmwit> LoganCapaldo: You're hired!
21:23:29 <Korollary> Finding good candidates is hard. News at 11.
21:23:29 <dons> to seperate those who've heard of haskell, from those who really know it
21:23:42 <araujo> Korollary, i think he states more the fact of "which" languages you know
21:23:55 <LoganCapaldo> dons: Does it have to be an original monad, or can it be like the Identity monad lets say?
21:23:55 <glguy> finding a good candidate is hard... when you aren't willin to pay for what you want
21:24:12 <ailndx> dons: yeah and thats what i dont agree with him on, him simply tells that all good programmers that dont know haskell just programming to get payed and aint interested in learning new stuff
21:24:40 <Korollary> glguy: Finding good people is hard even when you pay the rate.
21:24:56 <narain> ?check (\programmer -> (programmer `knows` haskell) ==> good programmer)
21:24:57 <lambdabot>   Not in scope: `good'
21:24:59 <glguy> Korollary: but you'd agree that it is harder without?
21:25:04 <araujo> ailndx, i think he doesn't say that
21:25:04 <Korollary> glguy: of course
21:25:08 <glguy> :) settled
21:25:25 <ailndx> araujo: thats pretty much the conclusion of what he says
21:25:45 <araujo> ailndx, he is just using Haskell as 'one' language to filter good pogramers
21:25:51 <dmwit> > let censor x = x >>= const "X" in censor "Hello, world!"
21:25:52 <araujo> programmers*
21:25:53 <lambdabot>  "XXXXXXXXXXXXX"
21:26:03 <araujo> Not that if you don't know Haskell, you are a bad programmer
21:26:11 <araujo> There is a difference there
21:26:14 <dons> dmwit: cute.
21:26:26 <sorear> > let censor = (>>"X") in censor "Hello, world!"
21:26:26 <Korollary> monad abuse heh
21:26:27 <lambdabot>  "XXXXXXXXXXXXX"
21:26:28 <ailndx> araujo: yeah and his reasoning behind that being haskell programmers are interested in programming leading to interested in learning new programming stuff.. and the rest aint
21:26:38 <dons> ?pl censor x = x >>= const "X"
21:26:38 <lambdabot> censor = (>> "X")
21:26:46 <nmessenger> map (const 'X') is simpler and conses less.
21:26:47 <Pastorn> > sieve = 2 : 3 : [ p | p <- [5..], n <- [1..] , notElem (p*n) sieve] -- how do I make this spit out primes
21:26:47 <lambdabot>  Parse error
21:26:55 <dmwit> sorear: ?botsnack
21:26:58 <dons> nmessenger: but not as obfuscated!
21:27:00 <Pastorn> lazyness isn't fun any more...
21:27:02 <sorear> :)
21:27:06 <nmessenger> dons: indeed!
21:27:12 <araujo> ailndx, he is just using 'one' language, in this case Haskell, to find that kind of people
21:27:24 <nmessenger> @quote \>\>\=
21:27:24 <lambdabot> nmessenger says: [hpaste] prepare to die! [nmessenger]  > "aah!" >>= replicate 5
21:27:27 <araujo> ailndx, that's why he also mentioned Erlang at the end
21:27:31 <dons> you could equally ask for scheme, or erlang, or prolog..
21:27:40 <dons> or, hmm. smalltalk
21:27:45 <glguy> or... you could trap them and ask for ruby...
21:27:47 <glguy> and then boot them
21:27:50 <glguy> ha!
21:27:51 <araujo> It actually got nothing to do with Haskell per se
21:27:51 <dons> heh
21:28:08 <araujo> But of the kind of language it is.
21:28:09 <sorear> I'll just retrofit a PC with front panel switches
21:28:09 <narain> ?hoogle Char -> Bool
21:28:10 <lambdabot> Char.isAlpha :: Char -> Bool
21:28:10 <lambdabot> Char.isAlphaNum :: Char -> Bool
21:28:10 <lambdabot> Char.isAscii :: Char -> Bool
21:28:20 <sorear> and ask them to make it do something useful
21:28:22 <LoganCapaldo> what about Oz, or Mercury? Or some other language I don't know like that :)
21:28:27 <ailndx> araujo: yeah.. as i allready rounded upp.. because he thinks those people are interested in programming and others aint(like c/c++ programmers and so on)
21:28:28 <roconnor> > execWriter $ censor (map (const 'X')) $ tell "Hello, world!"
21:28:29 <lambdabot>  "XXXXXXXXXXXXX"
21:28:30 <sorear> without the benefit of a programming language
21:28:43 <narain> > map (\c -> if isAlpha c then 'X' else c) "Hello, world!"
21:28:44 <lambdabot>  "XXXXX, XXXXX!"
21:28:45 <roconnor> dimwit: we already have a censor ;)
21:28:47 <araujo> ailndx, no, i don't see that conclusion
21:29:01 <sorear> roconnor: you misspelt his name
21:29:14 <roconnor> er
21:29:17 <roconnor> sorry dmwit
21:29:23 <araujo> ailndx, it's more because Haskell belongs (currently) to that kind of language you learn and use because you enjoy it
21:29:24 <dmwit> No worries!
21:29:33 <roconnor> kinda embarrasing
21:29:34 <ailndx> araujo: he puts that out pretty clear in the 3 lines ending with: The former are the ones who read up on additional programming languages at night, and they're the ones I want to hire.
21:29:38 <LoganCapaldo> roconnor's nick completion is sneaky :)
21:30:02 <dmwit> I suspect lambdabot's sense of humour has been sneaking into auto-correctors. ;-)
21:30:03 <araujo> C/C++ might be used by people who enjoys it too ; but they are also used for other interests
21:30:25 * nmessenger suspects it's the result of a fingermacro
21:30:27 <Korollary> Also people who learn haskell etc learn it by themselves and people who can bang their heads against documentation and figure things out tend to do well.
21:30:29 <araujo> ailndx, yes, i don't see how that excludes C/C++
21:30:39 <ray> perl is used by a lot of nutcases^Wpeople who really enjoy it
21:30:45 <dons> ailndx: don't worry, just learn haskell and you'll be safe ;)
21:31:01 <ray> learning haskell never hurts
21:31:14 <ailndx> dons: hah, i wont work as a programmer, i just learning for personal usage
21:31:23 * LoganCapaldo disagrees with the not hurting part
21:31:25 <araujo> Haskell is really bad .... It makes hate other programming languages
21:31:25 <narain> ray: on the contrary. learning haskell hurts. your brain. a lot.
21:31:37 <Korollary> no pain no gain?
21:31:44 <dons> it stops hurting after a while
21:31:48 <ray> well, exercising can hurt at first
21:31:49 <dons> then everything else hurts
21:31:50 <narain> ray: as calvin's dad would say though, "it builds character"
21:31:58 <ailndx> arauja: seriously, you say yourself c/c++ programmers have other interests but haskell'ers hasnt
21:32:05 <ray> hah
21:32:05 <ddarius> Haskell builds thunks.
21:32:05 <roconnor> > execWriter $ censor (>>'X')) $ tell "Hello, world!"
21:32:06 <lambdabot>  Parse error
21:32:10 <dons> i can't look at , say, ocaml now without cringing at the side effects in the middle of expressions
21:32:10 <ray> yeah, it builds something
21:32:22 <roconnor> > execWriter $ censor (>>"X")) $ tell "Hello, world!"
21:32:22 <lambdabot>  Parse error
21:32:23 <nmessenger> ray: not according to this guy: http://lukeplant.me.uk/blog.php?id=1107301645
21:32:23 * araujo thinks that after getting currying .... everything is down the hill
21:32:25 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
21:32:27 <dmwit> > execWriter $ censor (>>'X') $ tell "Hello, world!"
21:32:28 <lambdabot>  Couldn't match expected type `m b' against inferred type `Char'
21:32:35 <araujo> And getting currying is a matter of minutes or hours .....
21:32:45 <LoganCapaldo> The other day I was Cing away and I wa slike "Why wasn't this type error caught at compile time!?!?!?!"
21:33:01 <dons> LoganCapaldo: I tried to use tail calls in some C code :-)
21:33:02 <ailndx> of what ive seen most people who works as programmers actually are "nerds" that sit a huge amount of time at their computer no matter of what language they use
21:33:16 <roconnor> > execWriter $ censor (>>"X") $ tell "Hello, world!"
21:33:17 <lambdabot>  "XXXXXXXXXXXXX"
21:33:18 * ddarius wrote some code that relied on laziness in C#.
21:33:25 <dons> then I realised, ah 'return' doesn't box values in a monad, tail calls don't work, random values are returned if you fall of the end of a function
21:33:27 <ray> that guy has a point, but thankfully i don't have to work as a programmer
21:33:27 <rt> if they are any good, they spend a lot of time. :-)
21:33:28 <narain> LoganCapaldo: some C compilers even let you omit a return in a non-void function
21:33:28 <dons> its all rather scary
21:33:32 <ray> :)
21:33:41 <LoganCapaldo> narain: I know!
21:33:47 <LoganCapaldo> thank god I had warnings
21:33:48 <narain> i hate that
21:34:03 <LoganCapaldo> Man C is brutal
21:34:15 <rt> anyone who compiles any C code without warnings is just playing with fire.
21:34:32 <ftegularius> anyone who compiles any C code period is playing with fire
21:34:40 <narain> (foo*) malloc(n*sizeof(foo))
21:34:41 <araujo> C+Haskell isn't such a bad combination
21:34:48 <rt> C is a perfectly reasonable language, better than most of its predecessors and most of its successors.
21:35:09 <nornagon> C++ for example
21:35:13 <Pseudonym> rt: Yes, it's better than both most assemblers and most bytecodes.
21:35:27 <araujo> rt, yes, i also think it is saner than many more claiming to be better than it
21:35:30 <QtPlatypus> rt: Its a perfect language for what it is, a semi-portable assembler.
21:35:58 <Pseudonym> C++ is a very different language from C, though.
21:36:00 <Pastorn> how do i do sqrt of an int
21:36:02 <nmessenger> I was flabbergasted when I learned that evaluation order for function arguments at the callsite was unspecified.
21:36:06 <nornagon> Pastorn: fromIntegral
21:36:19 <Pseudonym> Pastorn: Either you go through a Double, or you roll your own/grab a library.
21:36:24 <Pastorn> nornagon: is there some way to not do that? cheating?
21:36:35 <nornagon> not really, as far as I know
21:36:41 <ailndx> Pseudonym: only that is much bigger, most c code is also valid in c++
21:36:41 <hpaste> The appropriate unification of architecture and congestion control has investigated e-business, and current trends suggest that the analysis of thin clients will soon emerge. In fact, few biologists would disagree with the investigation of rasterization, which embodies the key principles of e-voting technology.
21:36:46 <nornagon> :t sqrt
21:36:49 <lambdabot> forall a. (Floating a) => a -> a
21:36:55 <nornagon> @instances Floating
21:36:56 <lambdabot> Double, Float
21:37:03 <narain> doesn't make sense to take the sqrt of an int and expect an int back, does it?
21:37:05 <sorear> glguy: ping
21:37:12 <nmessenger> > let sqrti = round . sqrt . fromIntegral in sqrti 17
21:37:13 <lambdabot>  4
21:37:15 <sorear> that you?
21:37:32 <glguy> sorear: :)
21:37:39 <rt> I would anticipate that integer sqrt returns the largest n such that n*n <= the number.
21:37:41 <Cale> hpaste is spewing quackery now?
21:37:48 <sorear> glguy: looks like a spammer's dissociator
21:37:56 <roconnor> an integer square root ought to be added to the haskell libraries, it already exists in GMP
21:38:05 <roconnor> as I understand
21:38:09 <glguy> http://pdos.csail.mit.edu/scigen/
21:38:09 <lambdabot> Title: SCIgen - An Automatic CS Paper Generator
21:38:11 <narain> GMP?
21:38:12 <rt> i've been having fun with gmp a lot lately.
21:38:17 <Pseudonym> ?where+ isqrt http://andrew.bromage.org/darcs/numbertheory/Math/Util.hs
21:38:18 <lambdabot> Done.
21:38:31 <Pseudonym> Yes, you could probably also add a GMP binding.
21:38:55 <rt> used it to implement the B-B-P algorithm for hex digits of pi, and computed the billionth hex digit of pi.
21:39:07 <rt> (took about three hours)
21:39:09 <Pseudonym> Note that my version is optimised for insanely large square roots.
21:40:02 <narain> GMP? is that the bignum library?
21:40:03 <sorear> Pseudonym: have you seen my binding to mpn_fib_ui?
21:40:06 <rt> gmplib.org
21:40:08 <Pseudonym> sorear: Yeah.
21:40:11 <roconnor> narain: GMP is the gnu multiprecision library.  It is what GHC uses to implement integers.
21:40:11 <Pseudonym> Very cute.
21:40:18 <ray> hey, cool! scigen included my name in one of the citations as well as as an author
21:40:22 <ray> that's nifty
21:40:30 <Pseudonym> Woo!
21:40:33 <sorear> Pseudonym: the same technique could probably be adapted, if you don't mind the occasional gc-induced segfault...
21:40:41 <Pseudonym> :-)
21:41:06 <sorear> Actually, it might be safe. I do not understand how ghc pinns integers.
21:42:01 <Pseudonym> Oh, and I know that I could have used continued fractions instead of Farey sequences.
21:42:16 <Pseudonym> This seemed easier.
21:46:15 <dmwit> :t (|)
21:46:17 <lambdabot> parse error on input `|'
21:46:23 <dmwit> Oh, right, it's the guard.
21:46:28 * dmwit slaps forehead
21:46:35 <nmessenger> | is reserved for guards and data decls
21:47:30 <lokam> what's the simplest way of having a number of strings, where I can choose a random string to read/remove as well as add new strings to
21:47:59 <icarroll> Data.Set or Data.Map perhaps?
21:48:19 <lokam> I tried looking up data.set on hoogle didn't get anything tangible
21:48:23 <sorear> lokam: Data.Seq
21:48:39 <dons> Data.Map String () -- maybe?
21:48:39 <icarroll> @hoogle Data.Set
21:48:40 <lambdabot> No matches, try a more general search
21:48:44 <dons> yeah, Seq.
21:48:47 <sorear> lokam: you can add elements anywhere, pick random ones (by index), etc.
21:48:50 <dons> @docs Data.Sequence
21:48:50 <lambdabot> Data.Sequence not available
21:48:54 <dons> @docs Data.List
21:48:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
21:48:56 <icarroll> @docs Data.Set
21:48:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
21:48:59 <sorear> @docs Data.Seq
21:48:59 <lambdabot> Data.Seq not available
21:49:02 <dons> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html
21:49:04 <lambdabot> http://tinyurl.com/yz86s7
21:49:13 <sorear> what's wrong with the bot?
21:49:19 <lokam> cool thanks :)
21:49:21 <nmessenger> not in the index I'd suppose
21:49:51 <dons> yeah
21:50:10 <nmessenger> @bot
21:50:10 <lambdabot> :)
21:50:20 <sorear> where is this 'index'?
21:50:29 <icarroll> Is there any information on using GHC's graph libraries?
21:50:42 <icarroll> for example, Data.Graph vs Data.Graph.Inductive
21:51:00 <sorear> also, Cale complained about the @src output.  what would you think if someone rewrote State/src for pedagogical clarity?
21:51:09 <dons> fgl is documented in papers by Erwig
21:51:10 <sorear> @where fgl
21:51:10 <lambdabot> http://www.cs.orst.edu/~erwig/fgl/
21:51:20 <dons> and Data.Graph is documented in a JL paper
21:51:36 <dons> fgl could do with a complete haddockisation..
21:52:14 <Cale> fgl needs an interface-lift
21:52:33 * nmessenger cackles
21:52:38 <Cale> There are too many functions with short and cryptic names.
21:52:42 <icarroll> JL paper?
21:53:03 <lokam> I think dons and Cale are uber-cool
21:53:07 <lokam> :D
21:53:14 <lokam> just wanted to mention that
21:53:50 <nmessenger> /agree
21:53:57 <bos_> i just found myself thinking about teaching haskell in terms of a second life review i read recently: http://www.toothpastefordinner.com/journal/journal.php?user=toothpaste&id=573&readcomment=1
21:54:00 <icarroll> which graph library is recommended for simple use?
21:54:16 <dons> for simple use, Data.Graph if you can get away with it
21:54:24 <dons> Data.Graph.Inductive is very full featured
21:54:27 <icarroll> ok, thanks
21:54:28 <dons> but a bit hard to get into
21:54:39 <dons> (I used in successfully in the ICFP contest a couple of years ago though)
21:54:41 <bos_> in which the haskell apprentice gets to say "how do i hit people? i need that shit you drive."
21:54:48 <dons> heh
21:54:49 <Cale> lokam: :)
21:55:06 <lokam> :)
21:55:14 * sorear wonders if he is cool yet
21:55:15 <dibblego> ?docs foldl'
21:55:15 <lambdabot> foldl' not available
21:55:20 <dibblego> ?docs Data.List
21:55:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
21:55:51 <icarroll> @remember sorear sorear	wonders if he is cool yet
21:55:51 <lambdabot> Done.
21:56:09 * lokam runs away from social awkwardness and goes back to coding random intelligence
21:57:08 <sorear> and I do *not* want to be the next smerdyakov.  I will listen to requests to leave, since I know how hard it is to self-evaluate.  I get a definite impression I'm being Way Too Scary.
21:57:17 <Cale> hehe
21:57:21 <dons> you're scaring me now sorear
21:57:40 <ray> i think it might be the fangs that do it
21:57:43 <bos_> um, i wouldn't worry about losing the popularity contest.
21:58:10 * bos_ googles for "smerdyakov haskell"
21:58:13 <eyeris> What does >>= mean? I've read 3 tutorials and none of them explain it!
21:58:25 <bos_> wow, he was a gabby fellow.
21:58:28 <icarroll> @hoogle >>=
21:58:28 <lambdabot> Prelude.(>>=) :: Monad m => m a -> (a -> m b) -> m b
21:58:35 <nmessenger> eyeris: depends on which type you're using
21:58:41 <nmessenger> @src [] (>>=)
21:58:41 <lambdabot> m >>= k     = foldr ((++) . k) [] m
21:58:42 <Cale> eyeris: well, it's dependent on context what it does *exactly*
21:58:49 <nmessenger> @src Maybe (>>=)
21:58:50 <lambdabot> (Just x) >>= k      = k x
21:58:50 <lambdabot> Nothing  >>= _      = Nothing
21:59:01 <Cale> eyeris: It's a polymorphic function, defined specially for each monad.
21:59:23 <Cale> But if you want an analogy which captures what it does in general, I can try to express it in a few ways.
21:59:37 <eyeris> Hrm. This is crazy. I'm reading an explaination of monads and they used it...
22:00:03 <Cale> Whenever you have x >>= f, the x is some kind of computation, and f is a function from possible results of that computation to further computations.
22:00:18 <Cale> (x >>= f) is then a computation which runs x
22:00:27 <Cale> applies f to the result
22:00:28 <Pastorn> @pl (\pal -> pal == reverse pal)
22:00:29 <lambdabot> ap (==) reverse
22:00:34 <Cale> and runs that
22:00:51 <Cale> The result of the overall computation is the result of that second one.
22:00:53 <Pastorn> ?src ap
22:00:53 <lambdabot> ap = liftM2 id
22:01:19 <Cale> I think it's helpful though, to look at (>>). If x and y are computations, then x >> y is the computation which runs x and then runs y.
22:01:27 <Cale> and it returns the result of y.
22:01:49 <Cale> This is somewhat like ";" in some imperative language (depending on which ones you know)
22:02:35 <eyeris> So 'even [1, 2, 3, 4] >>= ( * 2))` would result in [4, 8]?
22:02:44 <eyeris> I guess I should just go experiment with it
22:02:45 <bos_> think of an imperative language that you program in while wearing a space suit, handling nuclear waste.
22:02:57 <bos_> sorry.
22:03:04 <Cale> even is a predicate, so it probably doesn't do what you think it does there.
22:03:18 <Cale> > [1,2,3,4] >>= (\x -> [x, 10*x])
22:03:18 <Pastorn> Int -> String
22:03:19 <lambdabot>  [1,10,2,20,3,30,4,40]
22:03:24 <Pastorn> @hoogle Int -> String
22:03:24 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
22:03:32 <Cale> > [1,2,3,4] >>= (\x -> if even x then [x, 10*x] else [])
22:03:33 <lambdabot>  [2,20,4,40]
22:03:35 <Pastorn> @type show
22:03:37 <lambdabot> forall a. (Show a) => a -> String
22:03:41 <Cale> eyeris: is that helpful?
22:04:00 <eyeris> Cale: I think so, but why escape x?
22:04:07 <Cale> That's not an escape
22:04:09 <nmessenger> for the list monad, x >>= k = concatMap k x
22:04:10 <hpaste> > fix show
22:04:11 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
22:04:21 <Cale> (\x -> x + 1) is the function which adds one to its parameter
22:04:29 <Cale> \ is ascii art for a lambda
22:04:33 <nmessenger> > (\ x -> x + 1) 5
22:04:35 <lambdabot>  6
22:04:35 <Cale>  is the unicode for it
22:04:40 <eyeris> Oh
22:05:19 <Cale> the thing which goes on the right side of >>= is always a function
22:05:27 <nmessenger> (strange that [] (>>=) reimplements concatMap rather than calling it directly)
22:06:29 <glguy> (>>=) = flip concatMap -- you wanted ?src to return that?
22:06:38 <sorear> @seen ndm
22:06:39 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 10d 1h 7m 44s ago, and .
22:06:42 <eyeris> Thanks Cale.
22:06:51 <Cale> eyeris: is that helping things to make sense?
22:06:56 <sorear> ok, that's nicely bogus
22:06:56 <nmessenger> x >>= k = concatMap k x -- would probably be pedagogically clearer
22:06:56 <eyeris> That explaination was easy to follow.
22:07:05 <Cale> eyeris: Check out my tutorial :)
22:07:12 <Cale> @wiki Monads_as_Containers
22:07:12 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
22:07:31 <Cale> that's the container approach, as opposed to the computation approach
22:07:41 <Cale> @wiki Introduction_to_IO
22:07:41 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
22:07:45 <eyeris> Do you remember in 3rd grade when the instructor would make you write the definition for common words without using the base of the word in the definition? I think every Haskell tutorial should try to do that :)
22:07:48 <Cale> this has some helpful ideas in it
22:07:53 <eyeris> I definitely will check it out
22:07:57 <sorear> dons: ndm spoke <3 hours ago!
22:08:17 <sorear> strangly, forall WIERD_CONCEPT.  .hs files are usually easier to read than .ps files (even with gv)
22:08:18 <Cale> eyeris: It's pretty tricky. :)
22:08:24 <Cale> But I agree.
22:08:44 <Cale> another good one is "You Could Have Invented Monads"
22:08:49 <Cale> @go "You Could Have Invented Monads"
22:08:51 <sorear> @botsnaek
22:08:52 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
22:08:52 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
22:08:52 <lambdabot> :)
22:08:56 <Cale> yeah, that's the one
22:09:20 <Cale> but read my container one first :)
22:09:32 <Cale> All About Monads is also good, but the examples kind of suck
22:09:48 <nmessenger> @where monads
22:09:48 <lambdabot> http://www.haskell.org/all_about_monads/html/index.html
22:10:07 <Pastorn> Cale: i'm doing that "you could have inventet...", but it might need some proofreading
22:10:27 <Pastorn> and maybe an example for each exercise of the desired output
22:10:36 <Cale> yeah
22:10:56 <Cale> It's not perfect. It'd make a good wiki page, but I'll leave that to sigfpe to decide :)
22:11:17 <Pastorn> @paste
22:11:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:13:59 <Pastorn> http://hpaste.org/971 topic: why do i get the empty list?
22:14:26 <Cale> > [999..100]
22:14:27 <lambdabot>  []
22:14:33 <Pastorn> whoops
22:14:34 <Cale> > [999,998..100]
22:14:35 <lambdabot>  [999,998,997,996,995,994,993,992,991,990,989,988,987,986,985,984,983,982,981...
22:14:42 <Pastorn> seems rather silly
22:14:47 <Pastorn> why can't it do that?
22:15:08 <Cale> It makes some definitions where the bounds are variables work better that way.
22:15:23 <Cale> For example, factorial n = product [1..n]
22:15:40 <Cale> > let factorial n = product [1..n] in factorial 0
22:15:41 <lambdabot>  1
22:16:00 <Cale> If it gave [1,0] that would give 0, which would be wrong.
22:16:28 <Pastorn> oh
22:23:22 <sjanssen> Pastorn: you could write your own type that has that behavior
22:23:30 <sjanssen> but I wouldn't really recommend it
22:24:02 <Pastorn> some other time
22:24:05 <Pastorn> good night =)
22:24:30 <sorear> night.
22:34:22 <fuzan> hey all. is there anyway to do this:   data Example = Example { realF :: String } \\ let func = realF ; item = (Example "old") in item { func = "new" }
22:35:30 <nmessenger> nope, readF is the record name so you must use it in the {...} syntax.
22:36:11 <fuzan> nmessenger: figured :\ . How then does one do more complicated polymorphism using record syntax?
22:36:50 <nmessenger> though you might define setFunc x y = y { realF = x }
22:37:24 <fuzan> nmessenger: for example, if I have several datatypes with the same basic functions inheriting from a type class, how would I implement a generic function that modifies any of the datatypes?
22:37:56 <nmessenger> setBlah :: blah -> record -> record
22:38:20 <fuzan> well, it would need to be of the class
22:38:30 <nmessenger> yes, that's what I meant
22:38:53 <fuzan> and then i'd have to reimplemet code using pattern matching, correct?
22:39:03 <nmessenger> as far as I understand
22:39:12 <fuzan> setBlah (ObjectA) stuff stuff  = blabla
22:39:25 <fuzan> setBlah (ObjectB _) stuff stuff = blala
22:39:58 <nmessenger> setBlah newBlah record = record { realBlah = newBlah }
22:40:35 <nmessenger> @quote record.+sucks
22:40:35 <lambdabot> No quotes match. Take a stress pill and think things over.
22:41:17 <dibblego> what's a good beginner level problem to highlight laziness? backtracking algorithms are a little too difficult for this person
22:41:43 <fuzan> > take 10 [1..]
22:41:44 <dons> dibblego: hmm, 'tr'?
22:41:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
22:41:50 <dons> pretty much every unix filter is lazy
22:41:56 <fuzan> more complicated than that? :)
22:42:09 <dons> but they have to manually do blockwise IO. if you just use a lazy language you get those unix filters for free
22:42:11 <dibblego> tr as in /usr/bin/tr?
22:42:15 <dons> yeah
22:42:46 <nmessenger> dibblego: the Nub Games guy illustrated how it allows you to seperate input-generation code from data-bashing cdoe
22:43:01 <nmessenger> @google Haskell IO for the imperative programmer
22:43:03 <lambdabot> http://blogs.nubgames.com/code/?p=22
22:43:03 <lambdabot> Title: Nub Games  Haskell IO for Imperative Programmers
22:43:09 <dibblego> nmessenger, thanks
22:43:56 <dons> cat  /usr/share/dict/words |  ghc -e "interact (unlines . map (map (\c -> if c == 'e' then '#' else c)) . lines)"
22:44:17 <dons> the naive code runs in constant space
22:44:40 <dibblego> what's the not-naive code run in then?
22:44:45 <dons> strict IO
22:44:55 <dons> has to read the entire input in before it can start processing
22:45:05 <dibblego> isn't that the naive version?
22:45:27 <dons> no, the point is the naive code here is optimal :-)
22:45:34 <dibblego> oh right
22:45:35 <dons> if you wrote the naive C version, it would have O(n) space
22:45:41 <fuzan> I have a datatype: "data Object = ObjShip Ship | ObjAsteroid Asteroid | ..." and I'm trying to implement instances for each data constructor, ie. (for ObjAsteroid asteroid, use the asteroid instance). However, I'm only able to implement one instance method (ie. rDraw for ObjAsteroid) until it complains about multiple defined instances. What would one do to avoid this issue?
22:45:41 <dibblego> ah I see
22:45:41 <dons> it has O(1) space in a lazy language.
22:48:01 <byteshack> how can I def a data structure of an N-tree such that tree is: label + [list of trees]?
22:48:21 <nmessenger> data Tree a = Node a (Tree a)
22:48:33 <dons> data Tree a = Leaf | Node a [Tree a]
22:48:37 <nmessenger> er, [Tree a]
22:48:37 <dons> something like that?
22:48:38 <ddarius> fuzan: You would write rDraw (ObjAsteroid ...) = ...; rDraw (ObjShip ...) = ...
22:48:47 <byteshack> do I not need to define Node?
22:48:58 <dons> the above defines the Node constructor
22:49:01 <dons> and the Leaf constructor
22:49:03 <nmessenger> byteshack: that's the definition of Node
22:49:16 <glguy> dons: would what he described have a Leaf?
22:49:21 <fuzan> ddarius: and then you, or maybe only I, would have an error. it only likes one instance of each method to be defined
22:49:31 <byteshack> no leaves, me thinks
22:49:35 <dons> byteshack: consider the binary tree defined with:  data Tree a = Nil | Node a Tree Tree
22:49:37 <nmessenger> Node is a constructor that when you give it an 'a' and a list of 'Tree a', it produces a 'Tree a'
22:49:52 <dons> then generalise it to arbitrary children, data Tree a = Nil | Node a [Tree a]
22:50:07 <nmessenger> @src Tree
22:50:07 <lambdabot> Source not found. Do you think like you type?
22:50:16 * glguy wonders what Node () [Nil, Nil] means
22:50:17 <nmessenger> Data.Tree has this same definition
22:50:24 <dons> where each node has an element and points to a list of subtrees. i guess since the list can be [] you don't need Nil (except for empty trees?)
22:50:30 <fuzan> ddarius: instance Renerable Object where ...
22:50:33 <dons> Node () []
22:50:40 <dons> so the empty tree is still:  Nil
22:50:47 <dons> then Node 1 [] -- depth 1
22:50:57 <dons> then Node 1 [Node 2 [], Node 2 []] -- depth 2
22:51:05 <glguy> dons: in a sitation like this, isn't the empty forest []
22:51:26 <dons> yeah, so you need two types
22:51:27 <glguy> type Forest a = [Tree a] ; data Tree a = Node a [Tree a]
22:51:30 <dons> yep
22:51:39 <glguy> rather
22:51:39 <dons> then no Nil is needed, you reuse []
22:51:42 <ddarius> fuzan: You have one rDraw function with multiple cases.
22:51:43 <glguy> type Forest a = [Tree a] ; data Tree a = Node a (Forest a)
22:52:02 <dons> exactly
22:52:07 <fuzan> ddarius: i'll try again. that was what I assumed would work orginally ;)
22:52:10 <nmessenger> byteshack: do you understand where Node comes from?
22:52:21 <byteshack> trying too
22:52:34 <byteshack> i don's see a: data Node = ???
22:52:39 <dons> no, its not a type.
22:52:53 <dons> Node is the constructor tag for values of type 'Tree a'
22:53:01 <dons> so, Node "foo" [] :: Tree String
22:53:16 <dons> so, Node "foo" [Node "bar" []] :: Tree String
22:53:58 <nmessenger> Node is a new function introduces by the data declaration that constructs Trees
22:54:06 <nmessenger> introduced*
22:54:19 <byteshack> so Node is a funct and not a data struct
22:54:25 <nmessenger> just like (:) is a function that constructs lists
22:55:04 <byteshack> thanks.  I'll go play with that and see where I get
22:55:06 <nmessenger> byteshack: yes.  Node is a function that *makes* a data structure, and you can also use pattern-matching on it to retrieve its parts.
22:55:24 <nmessenger> data List a = Nil | Cons a (List a)
22:55:33 <nmessenger> data [a] = [] | a : [a]
22:56:23 <fuzan> ddarius: you're correct. I must have done something stupid earlier :\
22:57:33 <nmessenger> this introduces two new values [] (nil) and (:) (cons).  [] is a constant representing an empty list.  (:) is defined as a function that accepts a value, and a list, and produces a new list.
22:57:37 * byteshack goes back to more reading of yaht
22:59:54 <byteshack> I tried this a while back and got errors, and could not see why they would not work:  foldr (: . f) list
23:00:02 <byteshack> is that not a valid def for map?
23:00:14 <nmessenger> operators must be surrounded by parens to be used prefix
23:00:18 <byteshack> seems that ghc did not like the syntax
23:00:33 <dons> fold ((:). f ) list
23:01:07 <byteshack> and that would do the composition of cons and f, correct?
23:01:14 <Cale> yeah
23:01:24 <byteshack> cool
23:01:25 <nmessenger> yes, but you'd also need a base case for foldr
23:01:35 <Cale> > let map f = foldr ((:) . f) [] in map (+5) [10,20,30]
23:01:36 <nmessenger> foldr ((:) . f) [] list
23:01:36 <lambdabot>  [15,25,35]
23:01:50 <byteshack> that's what I meant
23:01:56 <Cale> beautiful implementation of map
23:02:26 <byteshack> been reading "Why FP matters" and trying things out in Haskell
23:02:32 <nmessenger> @src concatMap
23:02:32 <lambdabot> concatMap f = foldr ((++) . f) []
23:02:37 <byteshack> this is all new to me, but very beautiful indeed
23:02:37 <nmessenger> ^^ mirrors that :)
23:02:59 <Cale> as well as the identity that  id = foldr (:) []
23:03:47 <nmessenger> (++) = foldr ((.) . (:)) id
23:03:51 <nmessenger> :)
23:04:06 <nmessenger> who needs the Prelude?  I've got foldr!
23:04:09 <ddarius> naturality of fold and id expressed as a fold...
23:04:14 <dons> ?check \f xs -> let _ = xs :: [I] ; _ = f :: I -> I in  foldr ((:) . f) [] xs == map f xs
23:04:16 <byteshack> that looks like ReadOnly Syntax (TM)
23:04:16 <lambdabot>  OK, passed 500 tests.
23:04:30 <dons> ?unpl foldr ((.) . (:)) id
23:04:30 <lambdabot> foldr (\ g b c -> ((:)) g (b c)) (\ d -> d)
23:04:40 <dons> ?. pl unpl foldr ((.) . (:)) id
23:04:40 <lambdabot> foldr ((.) . (:)) id
23:04:40 <Cale> byteshack: which?
23:04:56 <byteshack> (++) = foldr ((.) . (:)) id, that one
23:05:09 <byteshack> I think I see it though
23:05:15 <nmessenger> (++) [] = id, (++) [] xs = xs
23:05:52 <nmessenger> (++) xs ys = foldr (.) id (map (:) xs) ys
23:06:03 <fuzan> ugh. that record syntax limitation is really preventing me from minimizing a lot of code :\
23:06:40 <Cale> To be less clever,  xs ++ ys = foldr (:) ys xs
23:06:43 <nmessenger> map (:) xs makes a bunch of consing functions, foldr (.) id hooks 'em together
23:07:00 <ddarius> (++) = flip $ foldr (++)
23:07:10 <ddarius> er s/(++)/(:)
23:07:23 <Cale> nmessenger: nice way to look at it
23:07:47 <ddarius> Then simply apply naturality (fuse)
23:09:23 <nmessenger> foldr++
23:17:33 <byteshack> well, I guess I didn't get it... http://hpaste.org/972
23:17:56 <nmessenger> DanTree needs a type parameter
23:18:33 <nmessenger> http://hpaste.org/972#a1
23:20:01 <nmessenger> that's like saying "this should be a list".  "A list of what?"
23:20:13 <nmessenger> "a's"
23:20:34 <byteshack> thanks
23:22:14 <nmessenger> > Node "already" [Node "exists" [], Node "in" [Node "Data.Tree" []], Node "btw" []]
23:22:16 <lambdabot>  Node {rootLabel = "already", subForest = [Node {rootLabel = "exists", subFor...
23:23:19 <byteshack> haha
23:23:44 <nmessenger> :: Tree String
23:29:04 <lokam> if I want to read a [String] from a file, can I just do tcidu :: FilePath -> [String] IO
23:29:07 <lokam> tcidu = readFile
23:29:21 <lokam> ?
23:29:31 <nmessenger> @type liftM lines . readFile
23:29:33 <lambdabot> FilePath -> IO [String]
23:29:51 <lokam> cool thanks ;)
23:30:11 <nmessenger> do { contents <- readFile name; let ls = lines contents; ... }
23:30:27 <lokam> hmmm
23:31:10 <encryptio> handleEvent :: Box -> IO () ; events :: [Box] ; sequence_ $ map handleEvent events -- is there a way to trim this expression down?
23:31:25 <nmessenger> mapM_?
23:31:29 <nmessenger> @src mapM_
23:31:30 <lambdabot> mapM_ f as = sequence_ (map f as)
23:31:35 <encryptio> heh.
23:32:01 <encryptio> poifect, thanks
23:32:49 <nmessenger> lokam: readFile gets you the contents in one String, lines splits a String into a [String] at each newline.
23:33:07 <lokam> :D thanks
23:33:24 <nmessenger> lokam: you can either lift lines into the action, or pull down the String and apply lines on it directly.  Both are equivalent.
23:33:55 <nmessenger> @src liftM
23:33:55 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:34:48 <lokam> so if I return ls will I have the IO [String] ?
23:34:57 <lokam> from your previous example
23:34:59 <nmessenger> yep
23:35:08 <nmessenger> return puts a thing back into a monad
23:35:08 <lokam> :D cool
23:37:03 <Cale> return x produces a computation which does nothing but results in x
23:37:46 <ddarius> A computation that does nothing but return x if you will.
23:40:43 <nmessenger> (I still wonder why the name 'return' was chosen.  I'm used to it now, but the word seems a little too overloaded)
23:41:30 <nmessenger> what do category theorists call it?  mu or eta or something?
23:42:27 <kc5tja> It probably sounded better than dropM.  ;)
23:43:16 <sjanssen> nmessenger: return is called unit, I think
23:44:00 <nmessenger> I was just wondering at the usual symbol used to represent it.
23:44:54 <dmwit> I think eta is the one for return.
23:46:33 <lokam> how do I add a brid::String to brilis::[String]
23:46:44 <nmessenger> @ty (:)
23:46:46 <lambdabot> forall a. a -> [a] -> [a]
23:46:59 <nmessenger> > "blah" : ["foo", "bar"]
23:47:00 <lambdabot>  ["blah","foo","bar"]
23:47:45 <lokam> !
23:47:47 <nmessenger> you might also do (brilis ++ [brid]) to put it on the end.
23:47:49 <lokam> .ua(discovery)
23:48:08 <lokam> ki'e(thanks)
23:48:16 <nmessenger> lojban?
23:48:23 <kc5tja> Lojban!
23:48:24 <lokam> yep :)
23:48:43 * kc5tja was studying that for a period.  Didn't get very far though.  Chapter 7 of the LFB book.
23:48:56 <nmessenger> @lojban ki'e
23:48:57 <dmwit> Who wants to take bets on how long it takes somebody to post a link to the xkcd comic?
23:48:58 <lambdabot> Error: 501 Syntax error, illegal parameters
23:49:28 <kc5tja> Cale is looking it up right now, probably.  :)
23:49:40 <Cale> what?
23:49:57 <kc5tja> Cale: xkcd comic.  Assuming you were paying attention to the conversation.
23:50:07 <kc5tja> It was humor.
23:50:11 <dmwit> Oh, are so many people here into Lojban?
23:50:19 <lokam> I'm rather fluent
23:50:30 <Cale> http://xkcd.com/c114.html this one?
23:50:31 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
23:50:35 * kc5tja can barely recite the numbers.
23:50:44 <kc5tja> In fact, I *can't* recite the numbers anymore.  :(
23:50:47 <dmwit> I guess I shouldn't be surprised that people here are interested in esoteric languages. ;-)
23:50:53 <lokam> no pa re ci vo mu xa ze bi so
23:51:04 <lokam> numbers ^ 0 - 9
23:51:26 <kc5tja> I remembered the vowel parts.  The consonants in the numbers are 100% arbitrary though.  Which is a pity.
23:51:32 <lokam> I'm definatly going to program my random intelligence to speak lojban
23:52:19 * kc5tja is in the process of grabbing LFS, and going to install that on my laptop.  The next thing after I get networking running will be GHC and darcs.
23:52:33 <kc5tja> lokam: You in the Bay area by any chance?
23:52:48 <lokam> I'm in Toronto, Ontario, Canada
23:52:59 <kc5tja> OK, thought you might have been someone else.
23:53:04 <dmwit> Cale: This one. http://xkcd.com/c191.html
23:53:05 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
23:53:17 <Cale> ah, right
23:55:18 <kc5tja> Need to reboot to burn ISO.  Then I'm going to bed.
23:55:22 <kc5tja> co'o.
23:56:59 <lokam> I need to get a random number between 0 and (length brilis - 1)
23:57:08 <lokam> kc5tja: co'o
23:57:31 <lokam> how would I get non IO random number?
23:57:45 <nmessenger> use the non-IO random functions.
23:58:09 <lokam> do they work the same as randomRIO in terms of fields?
23:58:43 <lokam> I'm a lil confused by the docs
23:59:13 <nmessenger> > randomR (0, 5) (mkStdGen 42) -- if you want a slightly more random generator, you can use newStdGen to get an IO StdGen, then bind it to your pure functions
23:59:15 <lambdabot>  (5,1720602 40692)
