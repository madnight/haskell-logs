00:04:29 <lokam>  I find tene is usually much nicer .ui.u'i.i'i(happiness amusement togetherness)
00:04:52 <lokam> eh, i should really stop writing out the lojban
00:05:02 <lokam> k i'll go OT somewhere else
00:05:07 <tene> nicer than what?
00:05:54 <lokam> nicer than happy goldfish? depends, I guess you are pretty nice in general is what I was trying to say :)
00:06:04 <tene> Ahh.  'kay.
00:06:24 <lokam> :)
00:06:33 <sorear> Here, people are nice.
00:06:35 <sorear> Period.
00:06:39 <nmessenger> whee! oohee! eehee!
00:06:45 <lokam> :D
00:06:47 * sorear SMILES!!
00:07:13 <happy_nic> sorear: your method makes accessors easier, but another problem is is snails don't have gender.. composing typesclasses like Gendered and Legged would also be even trickier..
00:07:39 <nmessenger> (= anglecized .ui.u'i.i'i if I got the inventory right;  /me is reading the wikipedia page)
00:07:41 <sorear> happy_nic: snails don't?  I thought all animals did?
00:08:09 <tene> sorear: nope, they don't.
00:08:22 <sorear> well, not sponges
00:08:33 <nmessenger> data Animal = Gendered Species Gender NumEars | Nongendered Species NumEars
00:08:46 <sorear> do snails have ears?
00:09:11 <sorear> which clause would $protozoan fall under?
00:09:12 <happy_nic> well i could be wrong about snails and gender, but there are genderless animals me thinks.. genderless creatures at least =]
00:09:18 <nmessenger> or data Animal = Anime Species (Maybe Gender) NumEars
00:09:31 * nmessenger hit a fingermacro at Anime :3
00:09:57 * sorear stares at nmessemger's single tusk
00:10:27 <lokam> well DANlu the Lojban word for animal takes two arguments :: Animal -> Species
00:10:40 <nmessenger> eh?  :3 is the kittycat smile.  joke?
00:11:20 <sorear> now that I look harder it looks cthulish
00:11:26 <nmessenger> :D
00:11:28 <sorear> maybe I'm just tired :)
00:11:34 <tene> nah, cthulhu is :E
00:11:48 * nmessenger laughs aloud
00:12:13 <nmessenger> @spell cthulhu
00:12:15 <lambdabot> thulium Thule Catholic catholic Cathyleen
00:12:15 <sorear> bye.
00:12:22 <nmessenger> catholic!
00:12:51 <sorear> catoholics unite!
00:13:17 <nmessenger> dislexics untie!
00:13:43 <ivanm> lol
00:17:12 <happy_nic> if I have: data Stuff = Stuff1 a | Stuff2 a b c d e f g h i j k
00:17:32 <happy_nic> does a Stuff constructed with Stuff1 use as much memory as a Stuff constructed with Stuff2?
00:21:36 <happy_nic> hmm probably not. it's not like I can assign values to b c d e f and so on later.
00:27:39 <ivanm> out of curiosity, what editors/IDEs to people use to code haskell in? (primarily linux apps)
00:27:58 <tene> vim
00:28:21 <goltrpoat> i use kdevelop when i'm in linux, but i'm pretty sure i'm the only person on the planet who does that
00:28:21 <lambdabot> goltrpoat: You have 1 new message. '/msg lambdabot @messages' to read it.
00:28:38 <QtPlatypus> ivanm: emacs
00:28:50 <ivanm> I'm using emacs + haskell-mode myself, but I'm getting annoyed with some of the haskell-mode stuff
00:29:40 <ivanm> I decided to try using \begin{code}...\end{code} instead of bird style literate coding, but haskell-mode didn't do the syntax highliting of the code
00:30:24 <happy_nic> vim here. but this http://shim.haskellco.de/trac/ might make me give emacs a try.
00:30:26 <lambdabot> Title: shim - Trac
00:31:56 <jyp> @where hoogle
00:31:57 <lambdabot> http://www.haskell.org/hoogle
00:32:23 <paolino> hi, I'm trying to make a small script to download all mails from http://www.haskell.org/pipermail/haskell-cafe/ , which tool/librarie you suggest to use ?
00:32:24 <lambdabot> Title: The Haskell-Cafe Archives
00:32:31 <ivanm> happy_nic: its meant to be for VIM as well...
00:35:06 <happy_nic> ivanm: but "For now, there is only an Emacs mode"
00:35:12 <ivanm> oh, OK
00:35:26 <ivanm> I really should read the whole thing ;-)
00:35:27 <happy_nic> of course the emacs mode might not be all that functional anyway for all I know.
00:35:57 <happy_nic> I haven't tried it. But I've seen slime in action.
00:36:01 <nmessenger> wikipedia++ "Q: How many Lojbanists does it take to change a broken light bulb? A: Two: one to decide what to change it into, and one to figure out what kind of bulb emits broken light."
00:36:58 <goltrpoat> that took me a good minute
00:38:26 <tene> Heh.
00:38:55 <Cheery> how many lojbanist are required to implement a lojban parser in haskell?
00:39:48 <tene> There's a PEG
00:39:52 <Cheery> stupid web, feels so sluggish today.
01:11:55 <ivanm> Anyone know what this error means: Debugger entered--Lisp error: (void-function inferior-haskell-type)
01:12:01 <ivanm> google doesn't seem to have a clue
01:12:09 <ivanm> (its from haskell mode, the latest one)
01:16:09 <kfish> hmm, that lisp is an inferior haskell?
01:18:41 <ivanm> lol
01:18:57 <ivanm> I'll use yi wants its usable
01:19:55 <Lemmih> dons: How's yi going, btw?
01:21:04 <nmessenger> @seen dons
01:21:05 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 7h 5m 53s ago.
01:22:02 <jyp> Ah, nice you ask :)
01:22:22 <jyp> I've been working on Yi since december or so...
01:22:35 <jyp> It's starting to get fun now :)
01:22:49 <jyp> I got the binding to the GHC API done
01:23:14 <gour> jyp: gtk bindings?
01:23:38 <jyp> So one can experiment with new code dynamically, a la emacs.
01:23:54 <jyp> gour: mostly as good as the vty bindings.
01:24:17 <gour> jyasskin: there are gtk bindings?
01:24:29 <jyp> Yes :)
01:25:06 <gour> jyp: is repo available?
01:25:13 <jyp> sure
01:25:15 <jyp> @where yi
01:25:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
01:25:23 <ivanm> jyp: does it work with 6.6?
01:25:27 <jyp> Yes.
01:25:31 <jyp> ivanm: yes
01:25:44 <jyp> not 6.4, mind you.
01:26:04 <ivanm> OK... will have to annoy kolmodin or kosmikus to fix the ebuild in the gentoo overlay then
01:27:01 * gour is get-ing the source
01:27:21 <jyp> gour: have a look at README
01:27:38 <gour> jyp: will do, thank you for that work
01:27:44 <jyp> my pleasure ;)
01:27:58 <gour> i thought yi is (mostly) dead
01:28:24 <jyp> It's alive and better than it has ever been ;)
01:28:33 <jyp> Spread the word!
01:28:48 <ivanm> apparently, hs-plugins doesn't work with 6.6... or that could be one of the gentoo maintainers being cautions
01:28:51 <ivanm> *cautious
01:29:11 <gour> great. i was using pida (http://pida.co.uk/) instead, thinking that haskell solution is not there
01:29:12 <lambdabot> Title: PIDA loves you!
01:29:16 <jyp> The good thing is Yi no longer depends on hs-plugins
01:29:49 <ivanm> jyp: what does it require then?
01:30:09 <jyp> ivanm: GHC 6.6
01:30:13 <gour> jyp: ghc-api?
01:30:17 <jyp> yup
01:30:23 <ivanm> no libraries at all?
01:30:40 <jyp> regex...
01:30:49 <gour> jyp: is it better solutions for plugins than hs-plugins?
01:30:57 <ivanm> I have it (the 20050820 version) requiring hs-plugins, happy and alex
01:31:02 <jyp> and vty or gtk depending on your preferences
01:31:10 <jyp> ah...
01:31:32 <jyp> now that you mention it... there is an alex dependency in the vty version
01:31:40 <jyp> for syntax highlight
01:32:16 <ivanm> I might go have something to eat, then try it out
01:32:23 <ivanm> gour: tell me how it goes, will ya?
01:32:25 <jyp> cool
01:32:43 <jyp> Keep me up to date as well...
01:33:01 <jyp> I don't think there has been a lot of beta testers lately :p
01:33:03 <gour> ivanm: sure. i'm not sure if i'd able to do it now, i've to go out. so stay tuned today afternnon (GMT)
01:33:13 <ivanm> ?localtime gour
01:33:15 <lambdabot> Local time for gour is Sun Mar 25 10:31:31
01:33:20 <jyp> Please email me with bug reports
01:33:26 <jyp> then
01:33:39 <ivanm> jyp: your email is in the README?
01:33:47 <gour> jyp: don't see your email
01:33:58 <jyp> jeanphilippe.bernardy
01:34:02 <jyp> google mail.
01:34:05 <ivanm> k
01:34:25 <jyp> I'm adding it to the readme
01:34:35 <ivanm> depends how much longer I'll be procrastinating for ;-)
01:34:49 <ivanm> one quick thing: how up to date is the tarball version?
01:34:55 <gour> jyasskin: we can send you feature request as well ;)
01:35:03 <jyp> ivanm: way outdated
01:35:12 <jyp> gour: sure
01:35:15 <ivanm> oh..
01:35:23 <ivanm> well, I'll see
01:35:26 <ivanm> dinner time! ;-)
01:36:40 <gour> jyp: s/Setup.lhs/Setup.hs/ in README
01:37:23 <jyp> gour: what version are you using?
01:37:32 <gour> jyp: darcs repo
01:37:43 <jyp> which repo ? :)
01:37:59 <gour> http://www.cse.unsw.edu.au/~dons/yi.html
01:37:59 <lambdabot> Title: yi text editor
01:38:26 <gour> the one from the page ^^
01:38:42 <jyp> Weird, I can't find "lhs" in README
01:39:11 <gour> quick start - chmod +x Setup.lhs configure
01:39:17 <jyp> QUICK START:
01:39:17 <jyp> edit config.mk so it suits your needs;
01:39:48 <gour> jyp: build needs fps which fails on gentoo
01:40:08 <jyp> $ darcs changes | head
01:40:08 <jyp> Sun Mar 18 09:49:24 CET 2007  jeanphilippe.bernardy@gmail.com
01:40:08 <jyp>   * Add example of dynamic reconfiguration
01:40:46 <jyp> Are you sure you're synced?
01:41:03 <gour> pulled few mins ago
01:41:41 <gour> oops, it looks i had old repo hanging around
01:42:16 <gour> so the new got into yi_0
01:42:32 <jyp> Aha :)
01:45:23 <gour> jyp: what's this: setup: Unrecognised flags: --disable-haddock-use-packages
01:45:50 <gour> ahh, i got it
01:46:04 <jyp> Should be latest cabal version
01:46:34 <jyp> I add that to README
01:47:59 <gour> jyp: the problem was prefix for haddock
01:48:09 <gour> now i've to go...bbl
01:48:13 <jyp> k
01:48:19 <jyp> keep me informed
01:59:58 <therp> good morning #haskell!
02:00:23 <Heffalump> ugh.
02:03:33 <gour> jyasskin: while doing something i tried build, but got - http://rafb.net/p/SRGhJ910.html now i go out. will resume in the afternoon
02:03:34 <lambdabot> Title: Nopaste - No description
02:08:10 <gour> jyp: oops, wrong nick -  while doing something i tried build, but got - http://rafb.net/p/SRGhJ910.html now i go out. will resume in the afternoon
02:08:11 <lambdabot> Title: Nopaste - No description
02:19:40 <therp> either my prolog implementation is broken or wrong, but the zebra problem shouldn't take 3 minutes to solve.
02:19:49 <therp> s/wrong/inefficient/
02:21:15 <goltrpoat> i keep meaning to write a prolog, since i can never bring myself to actually learn it, and i figure that'd be a good way to do that.  how'd it go for you?
02:22:46 <therp> goltrpoat: i wrote a syntactic translator in Haskell according to a paper
02:22:51 <goltrpoat> ah
02:22:57 <therp> but I think my unification with the wildcard is a bit wrong
02:23:38 <goltrpoat> oh, i think i know which paper you're talking about
02:23:40 <therp> because even though unifying with the prolog wildcard variable always succeeds for the first time, you do have to instantiate it I think, as there might be another unification that might fail
02:24:03 <therp> Typed Logical Variables in Haskell
02:24:34 <goltrpoat> hmm, i don't think that was it.  trying to wade through my unsorted papers directory.
02:24:56 <therp> there is another one, called "embeddding prolog in haskell" IIRC
02:25:01 <goltrpoat> yes, that's the one
02:25:16 <therp> the TLVIH paper is a followup to this one
02:25:21 <goltrpoat> ah
02:25:40 <therp> it also demonstrates a typed version of prolog using the haskell type system
02:26:06 <therp> but I didn't go for that. I took the translation strategy they give in the TLVIH paper.
02:26:51 <cinimod> ?localtime cinimod
02:26:53 <lambdabot> Local time for cinimod is Sun Mar 25 10:16:10 2007
02:27:07 <therp> bah, generating variable names requires state keeping in my translator. I should have written this as monadic code anyway
02:28:45 <goltrpoat> or pull a IFL and pass the state around as a gigantic tuple
02:28:55 <goltrpoat> jk
02:29:45 <matthew-_> so is it just me, or does template haskell confuse other people?
02:29:50 <mauke> is that a giant tuple in your code or are you just happy to see me?
02:31:06 <matthew-_> I want to be able to, at compile time, declare data types. I'm finding this rather tricky
02:32:11 <matthew-_> eg, something like $(map (\n -> let n' = mkName ("Thing"++n) in [d| data n' = n' String |]) [1..10])
02:32:16 <pm007> hello.... i got a new macbook.... but no clue how to get ghc running... anyone can help?
02:32:37 <matthew-_> but that doesn't quite work. and there seem to be very few examples of data type declarations
02:33:46 <matthew-_> I reckon there should be extra $ in there, but it doesn't like that either
02:35:01 <matthew-_> any ideas anyone? I've been hitting my head against a wall for a while with this...
02:42:31 <goltrpoat> can anyone point me to any research towards RAD-style graph-based "programming" environments with a purely functional language underneath?  DSP filter graphs would be one example, things like electronics workbench are another, i was wondering if there's anything more general purpose though
02:43:15 <goltrpoat> (im aware of that one environment for haskell, whose name ive been trying to remember for a good half an hour now)
02:43:35 <matthew-_> mmm. and now I can reliably make ghci panic with $([d| $(map (\n -> let n' = mkName ("Thing"++n) in DataD [] n' [] [] []) [1..10]) |])
02:43:36 <goltrpoat> (not quite as high level as what i mean)
02:44:13 * matthew-_ desperately needs TH help...
02:46:37 <ivanm> what's the recommended way of writing literate haskell? Bird or LaTeX style?
02:46:59 <goltrpoat> depends on why you're writing it in LH, i'm guessing
02:47:08 <goltrpoat> if it's intended to be read in plain text, then probably Bird
02:47:30 <goltrpoat> if it's intended to be a paper, then probably LaTeX
02:47:39 <ivanm> well, I was considering using lhs2text, but haskell-mode doesn't seem to like it for syntax colouring
02:47:53 <ivanm> I've been using Bird style up to this point, though
02:48:43 <goltrpoat> i haven't had a huge amount of luck with lhs2tex, but ive only needed to use it once, and i didn't really have time to get it working
02:48:52 <ivanm> arrgghhh... I take it back
02:49:19 <ivanm> I just opened up a file with one bit of latex style and the rest bird, and now the syntax colouring is only for the latex'ed bits
02:49:26 <goltrpoat> hah
02:50:49 <twb> ivanm: what editor?  Emacs?
02:51:04 <ivanm> *nod*, with haskell-mode
02:54:15 <paolino> uhm, anyone can help me parsing the cafe archive, I'm having problem avoiding to eat the next mail in the text file
02:55:05 <twb> paolino: you are trying to open an mbox in e.g. mutt?
02:55:10 <paolino> manyTill works but eat the condition
02:55:17 <twb> Oh, never mind.
02:55:50 <paolino> http://www.haskell.org/pipermail/haskell-cafe/2007-February.txt
02:55:55 <paolino> this is the file
02:56:30 <paolino> twb, I'm using parsec
02:56:42 <ivanm> has anyone had success on using the awk bird to latex converter at: http://www.haskell.org/haskellwiki/Literate_programming/Bird_conversion_via_awk
02:56:44 <lambdabot> Title: Literate programming/Bird conversion via awk - HaskellWiki, http://tinyurl.com/2atou5
02:57:09 <dons> re.
02:57:38 <twb> paolino: you realize that file is not an mbox?
02:57:53 * matthew-_ made it work. /me celebrates with embarassing dance
02:57:59 <mauke> my @msgs = $str =~ /^From .*?(?=^From |\z)/smg;
02:58:18 <twb> http://twb.ath.cx/tmp/paolino.sh
02:58:52 <twb> mauke: right.
02:59:59 <paolino> twb, that's what we have, I need to parse threads and bodies mainly
03:01:46 <paolino> uhm, so I must use regular exp to split the file and then parsec each mail ?
03:02:30 <twb> Theoretically, no.  Recursive descent parsers are a superset of regular expressions.
03:03:28 <mauke> string "From " >> manyTillS anyToken (followedBy (string "\nFrom " <||> eof)) except not really
03:04:02 <twb> You could break the file into messages by chopping it into lines, partitioning at lines starting with "From " and then joining the lines back together again.
03:06:10 <paolino> @hoogle followedBy
03:06:11 <lambdabot> Text.ParserCombinators.Parsec.Combinator.notFollowedBy :: Show tok => GenParser tok st tok -> GenParser tok st ()
03:06:11 <goltrpoat> except for those messages that have sentences starting with From, that happen to be on a new line.
03:06:37 <mauke> yeah, parsec's followedBy is broken
03:06:46 <twb> goltrpoat: \n\nFrom
03:07:10 <goltrpoat> that's hardly robust :)
03:07:21 <twb> I don't know how mbox handles PARAGRAPHS starting with "From".
03:07:34 <twb> I suspect this is one reason maildir/mh/imap exist.
03:08:08 <therp> sigh, well the zebra problem seems a bit too hard for my prolog.
03:09:31 <goltrpoat> i'm guessing it can't be made fully robust, but i would start by not trying to extract thread information until well after the parse, and using a grammar for a full header as a terminator
03:10:09 <paolino> that's what I have, but the terminator is eaten
03:10:20 <goltrpoat> oh
03:10:33 <paolino> that's manyTill
03:12:00 * paolino wants to push back in the terminator
03:12:24 <mauke> make your own manyTill
03:12:54 <paolino> first time I make a parser eh
03:13:25 <mauke> manyTill p z = (z >> return []) <|> liftM2 (:) p (manyTill p z)
03:14:44 <goltrpoat> well.. this will be remarkably slow, but why not many1 (try parseHeader <|> anyChar >>= return . MsgChar), with something like data Msg = MsgHeader Header | MsgChar Char, and you get [Msg] out of the parser
03:15:00 <goltrpoat> it'll be stupidly slow, but it'll work, i think
03:15:25 <mauke> manyTillKeep p z = do {t <- z; return ([], t)} <|> do {x <- p; (t, xs) <- manyTillKeep p z; return (t, x : xs)}
03:15:50 <mauke> oops, (x : xs, t)
03:16:14 <ivanm> @hoogle bound
03:16:14 <lambdabot> Network.Socket.Bound :: SocketStatus
03:16:14 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
03:16:14 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
03:16:34 <goltrpoat> actually.. it won't even be that slow.  parseHeader will fail without consuming input, most of the time
03:16:47 <ivanm> that's not what I want... what's the class that lets you place upper and lower bounds?
03:17:23 <dcoutts> Bounded
03:18:19 <goltrpoat> paolino:  the point i'm trying to make is if you had anyChar >>= ... as the first argument to <|>, it'll happily eat the whole file.
03:18:35 <ivanm> dcoutts: thanks
03:18:45 <ivanm> @docs Bounded
03:18:46 <lambdabot> Bounded not available
03:18:53 <ivanm> @docs Data.Bounded
03:18:54 <lambdabot> Data.Bounded not available
03:19:05 <goltrpoat> switching them and using try, makes it look for full headers at every character
03:19:07 <ivanm> fine, I'll look for it manually
03:19:34 <goltrpoat> which is more or less what you have to do, so eh.
03:20:44 <jql> hrm
03:21:59 <paolino> uhm, goltrpoat , I hardly follow :/
03:23:18 <paolino> mauke: that manyTillKeep is not pushing the condition back in the input right ?
03:23:36 <mauke> no, it returns it
03:24:38 <goltrpoat> ohh.  sorry, i misread your question, i think.
03:24:49 <goltrpoat> the issue is not that it eats the header and keeps going, it's that it never returns the header.
03:27:47 <goltrpoat> ive always just used the pattern i typed up:  parse the terminator, if it fails, run p, otherwise return the result of the terminator.  the reason i made a big deal about 'try' was that the terminator here is pretty complex, and may consume some input.  <|> will only backtrack if the parser has consumed none.
03:28:06 <goltrpoat> may consume some input = may consume some input before failing.
03:29:27 <goltrpoat> if you push the try to z, then what mauke typed up is just fine, after the (x:xs, t) switch, so i'll shut up.
03:32:16 <dons> @seen aja
03:32:16 <lambdabot> I haven't seen aja.
03:34:11 <dons> @tell sorear in the last 52 weeks since i've been doing the HWN, there's been 42 editions.
03:34:11 <lambdabot> Consider it noted.
03:34:34 <paolino> mauke , can I use setInput to push the condition back ?
03:35:05 <mauke> paolino: dunno, I'm not that familiar with parsec
03:35:35 <dcoutts> @seen aja
03:35:36 <lambdabot> I haven't seen aja.
03:35:55 <dons> he was here a couple of weeks ago.
03:36:12 <goltrpoat> setInput really should not be used in a non-initial combinator, imo
03:39:52 <goltrpoat> if only for the fact that any use of it will look like this:  getInput >>= consumeSomeInput >>= setInput.  here, consumeSomeInput is something like ([tok] -> Parser [tok]) -> Parser (), so its reason for existence is to fudge things outside the parser
03:42:40 <goltrpoat> i think that's how the tokenPrim stuff works.
03:43:58 <dons> "Sometimes I just want a loop, but instead I'm trying to force myself to use
03:43:58 <dons> things like recursion instead"
03:44:34 <goltrpoat> in what language?
03:44:34 <goltrpoat> hehe
03:44:38 <dons> haskell :/
03:44:46 <dons> got force your loops to be you know, loops..
03:45:20 <goltrpoat> odd.
03:45:34 <goltrpoat> who said that?
03:45:56 <dons> random blogger. already deleted that page.
03:46:00 <goltrpoat> ah
03:46:48 <goltrpoat> sounds like underexposure.
03:47:16 <dons> yeah, he though also you needed to use lifTM to bind pure values in a monad, rather than 'let'. ah well
03:50:55 <kosmikus> ivanm: in the distant past, I once experimented with mmm-mode for emacs to get lhs2tex documents colored correctly.
03:51:48 <ivanm> kosmikus: yeah, it just seems to have been a problem with haskell mode where I shouldn't have mixed bird and LaTeX style :s
03:51:50 <ivanm> or something
03:52:14 <kosmikus> "it" being?
03:52:18 <goltrpoat> so i'll repeat my question from earlier.. is anyone aware of any research into DSP filter graph style environments for purely functional programming?
03:52:48 <mahogny> graph style environments`?
03:53:01 <goltrpoat> i'm basically interested in taking a program's dependency graph, and presenting it nicely, in an editable manner.
03:53:32 <paolino> a dream :P
03:53:45 <mahogny> doesn't sound too difficult to code. but I have never seen it
03:54:00 <goltrpoat> the DSP style stuff with generator/filter graphs seem like a good starting point, since that whole paradigm is purely functional by statement
03:54:14 <goltrpoat> it gets more complex with general-purpose languages though.
03:56:28 <goltrpoat> things like electronics workbench work out rather well too, particularly since you can create components out of basic parts, and you end up with a sort of a module or collection of modules you can zoom into
03:56:45 <goltrpoat> again, very domain specific though.
04:00:46 <goltrpoat> basically, let's say it's running in a vm, and there's a set of primitives that's editable.  so programmer A writes (:) as a primitive, and writes the Maybe type.  ok so then programmer B can write unfoldr as a node in the graph, and package it up in a module.  so then programmer C doesn't need to know what unfoldr does, he really just needs to know the type signature and some documentation.
04:01:57 <goltrpoat> so if you continue the process, you sort of have this RAD-style tool with almost non-programmers at the user tier, and other people implementing things at whatever levels of complexity they're comfortable with
04:05:28 <goltrpoat> parsec is a good example:  it's does stuff that was fairly groundbreaking at the time, and it packages it up in a nice set of combinators.  so let's say i write a parser using those combinators, and expose an interface.  i'd have to have some expertise in how parsec works, in order to do anything non-trivial, but i didn't have to write parsec, so i'm tier 2, say.
04:06:34 <goltrpoat> then the next guy picks up my library that parses, say, the autodesk DXF format.  so they don't have to care much about my implementation, they can just interface their module that does things with the DXF data, that magically comes from my DXF parser
04:06:44 <goltrpoat> so they're level 3.  etc.
04:06:56 <goltrpoat> can't help but think there should be a visual representation for that type of thing.
04:18:02 <augustss> parsec groundbreaking?  gimme a break. ;)
04:19:28 <goltrpoat> hutton/meijer's stuff was groundbreaking.
04:19:46 <goltrpoat> or.. that's my impression anyway, i wasn't around at the time :)
04:19:52 <augustss> in what sense?
04:20:38 <goltrpoat> in the sense that it was the first publication to formalize parser combinators in that manner.
04:20:44 <goltrpoat> afaik.
04:21:56 <augustss> oh, ok.  i might go along with that.  but the parsing combinator idea is from the the early 70s (afaik)
04:24:36 <augustss> It's described as early as Burge's book from 1975
04:29:45 <huschi> when i build a lib using cabal under linux the Paths_...-module is not put into the resulting .a file.
04:29:54 <huschi> is that an error or normal behaviour?
04:37:11 * ejt waves
04:37:34 <ejt> @pl breakOnDir fn = (dirname fn, basename fn)
04:37:34 <lambdabot> breakOnDir = liftM2 (,) dirname basename
04:45:45 <ekidd> Anybody have any favorite category theory books? (I already know about Pierce.)
04:45:46 <lambdabot> ekidd: You have 1 new message. '/msg lambdabot @messages' to read it.
04:46:38 <ejt> I've just started working through 'algebra of programming' by Bird, De Moor
04:46:49 <ejt> good, but not just CT
04:49:30 <ekidd> ejt: I've really liked the Bird papers I've read, so thanks for the pointer!
04:53:42 <ekidd> ejt: Is there a download version of "The Algebra of Programming?" It appears to run about $250 used on Amazon.
04:53:58 <Heffalump> is it out of print, then?
04:54:00 <ejt> I bought a new copy from amazon.co.uk
04:54:10 <ejt> certainly not $250 dollars
04:54:18 <ejt> it was a 'print on demand' edition
04:54:26 <goltrpoat> how do you swing that
04:54:34 <goltrpoat> ive been wanting that book for years
04:54:47 <ejt> I was surprised too
04:54:52 <Heffalump> http://www.amazon.co.uk/Algebra-Programming-Richard-Bird/dp/013507245X
04:54:55 <lambdabot> http://tinyurl.com/2594np
04:55:19 <goltrpoat> oh, nuts.  thanks
04:55:49 <ejt> it came in about a week
04:56:07 <ekidd> Indeed. It's only in stock in the UK.
04:56:10 <tcr> Has anyone written a pretty-printer that prints large nested trees of data constructors indented as Lisp code is commonly indented?
04:56:16 <Heffalump> I don't imagine you'd have any trouble getting them to deliver outside the UK, but if you do I'd be happy to post it on.
04:56:23 <ekidd> Everywhere else, it's a rare used book.
04:56:49 <ekidd> tcr: I think there's something in the standard hierarchical libraries.
04:57:37 <goltrpoat> heffalump:  thanks a ton.  i vaguely remember ordering from amazon.co.uk before, so it *should* be ok, but who knows
04:58:03 <ekidd> Heffalump: Thanks for the offfer! I wouldn't anticipate a problem, though. European bookstores tend to be pretty reasonable about international shipping in my experience.
04:58:24 <goltrpoat> oh, er.
04:58:27 <Heffalump> yeah - as I say I'm sure it should be fine. But send me a mail (ganesh@earth.li) if necessary, I'm not necessarily on IRC a lot.
05:00:07 <ekidd> Does anybody have a favorite category theory book, other than Pierce?
05:00:26 <ekidd> I'm about to order a couple, and I'm looking for recommendations.
05:01:05 <ekidd> @go Haskell "pretty print"
05:01:07 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/haskell-src/Language-Haskell-Pretty.html
05:01:14 <ekidd> tcr: Try that.
05:02:34 <goltrpoat> i keep going back to lambek's "introduction to higher order categorical logic" (going back as in, my brain explodes once a chapter and i have to glue together the little chunks strewn all over the walls)
05:03:30 <goltrpoat> on the other end of the spectrum, fiadeiro's 'categories for sofware engineering' is a very light but oddly thorough introduction
05:05:09 <tcr> ekidd: No, not really; unfortunately, that turns an AST of Haskell into a string of regular haskell code.
05:05:51 <ekidd> tcr: Whoops. Wrong module. Anyway, click on "Contents" and look for pretty printing from there.
05:06:43 <ekidd> tcr: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint-HughesPJ.html
05:06:45 <lambdabot> http://tinyurl.com/yz5hnw
05:07:23 <tcr> ekidd: I looked there already, of course. There's Text.PrettyPrint, but it's module to help writing pretty printers. I asked if anyone has written one such thing (possibly using Text.PrettyPrint) so I could steal that :)
05:07:49 <Heffalump> problem is you need a generic one, right?
05:07:57 <tcr> Yeah
05:08:22 <goltrpoat> ive had very mixed feedback when i recommend http://www.ehcweb.ehc.edu/faculty/jiskra/web/ModernAlgebra.pdf (the "(Really) Modern Algebra" book in progress)
05:08:29 <goltrpoat> it seems to be intended as a sort of a first course on abstract algebra, but the interesting thing is that it views it through the lens of category theory
05:08:38 <goltrpoat> so even if you know the material, it may rewire your brain in interesting ways.
05:08:41 <paolino> aahrgh
05:08:55 <tcr> Heffalump:  I could live with -fglasgow-exts, only.
05:09:28 <meester> what happened just now?
05:09:38 <Heffalump> well, I guess you can do stuff with deriving Typeable, then
05:09:39 <paolino> split
05:09:45 <Heffalump> but I don't know of one that exists
05:09:48 <goltrpoat> bedtime.
05:10:04 <ekidd> goltrpoat: Interesting! Thanks for the pointers.
05:12:08 <tcr> Heffalump: Are generics going to go into the next revision?
05:12:55 <ekidd> @tell goaltrpoat Thanks for the book recommendations!
05:12:56 <lambdabot> Consider it noted.
05:13:30 <tsp> wo, this channel is busy
05:13:39 <tsp> thought haskel was a toy
05:14:10 <nornagon> :)
05:14:19 <tsp> Can it be used for writing network apps? e.g. servers and such
05:14:25 <nornagon> yes.
05:14:53 <nornagon> lambdabot: are you written in haskell?
05:15:07 <nornagon> > map toUpper "yes"
05:15:08 <mahogny> haskell is very nice for networking as it has light weight threads and a very simple to use network API
05:15:09 <lambdabot>  "YES"
05:15:39 <pejo> tsp, there's a JFP article about a webserver by Marlow, if we ignore things like lambdabot. :-)
05:16:03 <tsp> neat
05:16:42 <tsp> I'm a python guy, but am interested in seeing whats out there - I can't code myself out of a paper bag, and can't figure out how .5 and 50 are related though
05:17:57 <QtPlatypus> tsp: There related by *100
05:18:05 <tsp> hmm
05:18:06 <tsp> weird
05:19:02 <tsp> that just seems odd how you can multiply .5 by 100 and get 50
05:20:17 <tcr> tsp: Why does that seem odd?
05:20:24 <DirkjanH> @run 0.5*100
05:20:25 <lambdabot>  50.0
05:20:50 <tsp> it just seems like the decimal point moves somehow
05:21:10 <tsp> we are in base 10, so I guess that sort of makes sense
05:23:34 <tcr> tsp: Haskell is one of the few languages that got it right and read fractional number literals as ratios and not as floats.
05:24:50 <tsp> tcr: so haskel won't give me the floating point offset error problems?
05:25:53 <tcr> tsp: Not unless you explicitly request to trade loss of precision for speed.
05:26:26 <tsp> ah
05:27:31 <tsp> hmm, I can't imagine haskel being useful for what I want to use it for - programming muds
05:27:44 <tsp> but I suppose I need to find some tutorials first
05:28:08 <paolino> muds ?
05:28:18 <QtPlatypus> Multy user dimentions.
05:28:28 <capisce> multi user dungeons :)
05:29:00 <paolino> ah erlang specialities
05:29:11 <tsp> heh erlang
05:29:19 <ekidd> tsp: Haskell has some pretty interesting concurrency support. The STM modules, in particular, are sweet.
05:29:41 <tsp> what could that allow me to do? the standard way of doing things is to keep everything in a list, then loop through it, updating state
05:29:42 <ekidd> tsp: The documentation is all in SPJ paper, though.
05:29:49 <tsp> SPJ paper?
05:30:01 <ekidd> tsp: Simon Peyton Jones, one of the designers of Haskell.
05:30:25 <ekidd> @go Composable Memory Transactions, Peyton Jones
05:30:27 <lambdabot> http://research.microsoft.com/~simonpj/papers/stm/index.htm
05:30:28 <lambdabot> Title: Papers on transactional memory
05:30:50 <tsp> ouch
05:30:59 <ekidd> tsp: I'm assuming that modern MUDs need to be increasingly multithreaded and distributed to handle the load?
05:31:11 <ekidd> tsp: If not, then you won't care about concurrency! :-)
05:31:11 <Heffalump> tcr: errm, not sure
05:31:25 <tsp> ekidd: not yet, but if i had a million players, then sure
05:31:39 <ekidd> tsp: Ah, OK. Never mind then. :-)
05:31:54 <tsp> the biggest text mud I've been on had 600 players - some of them have 200 and run on a 486
05:31:59 <tsp> lol
05:33:49 <Philippa> however, using concurrency in haskell makes writing the single-threaded style app much easier too
05:34:09 <ekidd> tsp: The STM stuff is likely to be ported to a future version of the Unreal Engine, where it will be used for spreading world updates over many processor cores. It's basically a MUD-like problem (10,000 scripted objects all interacting constantly). But again, not so useful if you don't need any concurrency at all.
05:34:42 <ekidd> The other language which has had some distributed AI wins lately is Erlang.
05:34:45 <Philippa> well, it helps if you want a more active world regardless of the user count
05:34:48 * QtPlatypus is currently connected to two mucks "The biggest of the two has 300 players currently connected"
05:35:03 <ejt> does anyone here use Test.HUnit much ?
05:35:04 <mahogny> tsp, haskell is optimal for muds. simple concurrency, a nice Curses library exist and you can write embedded languages for scripting
05:36:38 <tsp> I tried a simple haskel sum [ 1 .. 200000 ] with a huge interpreter, never realized haskel was that slow :)
05:36:44 * tsp tires it with python
05:36:53 <xs> ekidd, where did you get that unreal factoid?
05:37:10 <Philippa> Lambda the Ultimate
05:37:15 <Philippa> Tim posts there
05:37:17 <xs> ah. cool.
05:37:41 <ekidd> http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
05:37:44 <lambdabot> http://tinyurl.com/7cyhz
05:37:47 <Philippa> tsp: if you want fast haskell, you don't run it in an interpreter, you compile
05:38:01 <tsp> ah
05:38:06 <tsp> if i can even figure out how to do that in python
05:38:09 <Philippa> and the compiler will make that sum go rather a lot faster
05:38:26 <Philippa> ...you won't find the equivalent algorithm easily, because haskell's lazily evaluated and python isn't
05:39:09 <xs> ekidd,  thanks :)
05:39:23 <ekidd> xs: It's a really sweet presentation. STM, the ST monad, purely functional code on GPUs, dependent types--Tim Sweeny has thought a lot about how to make 40+ cores doable (since he'll be there in 2009 or so).
05:39:38 <tsp> found an example
05:39:56 <tsp> import operator ; reduce(operator.add,range(1,200001)
05:40:08 <tsp> now to figure out what reduce is - it sounds like something I could use
05:40:30 <ekidd> xs: See also http://lambda-the-ultimate.org/node/1277 once LtU is back up.
05:41:00 <tsp> ah, neat
05:41:17 <Philippa> btw, you'll find haskell is great for parsing work
05:41:35 <Philippa> something like parsec is much more pleasant than working with regexes
05:41:43 <ekidd> tsp: Reduce is pretty cool. (It has a different name in Haskell, though.) Basically, it takes a list, and instructions on how to combine elements of that list.
05:41:48 <ekidd> parsec++
05:41:57 <ekidd> What a lovely parsing library...
05:42:25 <tsp> I wrote a server in python - asyncore, asynchat... it was fast, but I don't know how modifyable iti s
05:42:51 <tsp> does haskel rely on indenting? I use ed as an editor, and indentation is just extra whitespace
05:43:00 <tsp> that gets in my way when I'm trying to do s//
05:44:10 <Heffalump> tsp: afraid so
05:44:25 <Heffalump> you can use { and ; instead of using indentation, if you prefer
05:44:38 <tsp> ah, that'll work
05:44:39 <Heffalump> but the parser will still try to use indentation when you make a mistake
05:44:42 <tsp> damn
05:44:46 <Heffalump> so it's not very satisfactory
05:45:01 <tsp> I relaly need to write a better editor
05:45:12 * QtPlatypus understands that the indenting is one of the things python borrowed from haskell.
05:45:12 <paolino> a python guy should be happy with haskell identation
05:45:23 <tsp> I'm blind, and most of the screen readers I use don't present indentation in a usable way that I like
05:45:29 <Philippa> except python did a worse job of it
05:45:31 <tsp> heh, I got someone to write me a brace processor for python
05:45:44 <tsp> I'll probably convert everything over to that that I've written in python - all 200 lines or so
05:46:09 <tsp> Philippa: how did python do a worse job? as far as I can tell, python got it right - not sure how haskel does it though
05:46:32 <Philippa> haskell has braces and semicolons as part of the actual syntax, with the layout just inferring them
05:46:47 <Igloo> Not being able to write if expressions on one line with python is very frustrating at times
05:46:50 <Philippa> so you can use braces and semis when you want them, including to put stuff on one line
05:47:03 <tsp> ah
05:47:10 <Philippa> also, I think the rules are slightly looser in a nice way
05:47:15 <tsp> I know in python you can do if expr: statement
05:47:17 <Philippa> Igloo just gave an example
05:47:19 <tsp> but not much more than that
05:47:29 <Heffalump> I've never actually tried programming with { and ;, so I dunno how much of a pain it is in practice
05:47:47 <Heffalump> I'd suggest you try and see how you get on.
05:47:52 <tsp> I'm compiling hugs from fbsd ports atm
05:48:22 <tsp> haven't quite converted to metric time yet, confused to many people including me
05:49:04 <Philippa> Heffalump: it's plenty doable once you've flicked through the grammar in the report and know where they go
05:49:25 <Philippa> I'd recommend GHC and GHCi for the kind of stuff you're looking to do
05:49:29 <paolino> tsp, we have ghc 6.6  on ports now
05:49:32 <Heffalump> Philippa: I'm concerned about the quality of error messages, that's all
05:49:51 <Philippa> Heffalump: ah. Yeah, I don't know what they're like if you misplace them
05:50:11 <Philippa> though probably not totally useless so long as you know how parsers in general behave
05:50:30 <tsp> is there a difference between hugs and ghc? I'm trying to find a haskel tutorial
05:51:33 <tsp> guess I'll have to stick with hugs, ghc is i386 only and I'm on sparc64
05:51:58 <tsp> although that doesn't make sense - why would a haskel interpreter care?
05:52:20 <QtPlatypus> ghc's a compiler.
05:52:22 <ekidd> @tell shapr I'm working on a one-page CUFP talk proposal regarding our work with Scheme at IML.
05:52:22 <lambdabot> Consider it noted.
05:53:18 <tsp> ah, it needs some kind of bootstrap
05:53:23 * QtPlatypus 's powerpc is running ghc.
05:53:34 <tsp> the port says i386 only
05:53:38 <shapr> ekidd: yay!
05:53:38 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
05:55:08 <paolino> tsp ftp://ftp.freebsd.org/pub/FreeBSD/ports/sparc64/packages-6.2-release/lang/ghc-doc-6.4.2.tbz
05:55:25 <paolino> uhm
05:55:31 <tsp> that's the docs
05:55:34 <tsp> heh
05:55:38 <paolino> sorry
05:55:49 <ekidd> tsp: ghc is a heavily-optimizing Haskell compiler, and hugs is kinda slow. :-)
05:56:38 <paolino> I think I compiled 6.4.1 once, not sure
05:56:52 <tsp> ekidd: will hugs work for learning?
05:56:58 <ekidd> tsp: Yup!
05:57:08 <tsp> neat
05:57:15 <ekidd> But it can't even begin to optimize stuff like
05:57:30 <ekidd> > sum [1..1000]
05:57:31 <lambdabot>  500500
05:57:57 <ekidd> ...at least not the way GHC can.
05:58:31 <ivanm> @hoogle [a] -> [a] -> [a]
05:58:32 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
05:58:32 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
05:58:32 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
05:58:41 <rubenz> In a list comprehension, is there a way to use an expression to the right and left of the | symbol without computing it twice?
05:58:42 <tsp> can I use > to crash the bot? or will he just eventually give a runtime error cause he ran too long
05:59:00 <Heffalump> he has a timeout
05:59:02 <ivanm> @hoogle String -> String -> String
05:59:03 <QtPlatypus> ekidd: Does ghc do the well known opimization in that case?
05:59:03 <lambdabot> Distribution.PreProcess.Unlit.plain :: String -> String -> String
05:59:04 <lambdabot> Distribution.PreProcess.Unlit.unlit :: String -> String -> String
05:59:04 <lambdabot> Text.Regex.subRegex :: Regex -> String -> String -> String
05:59:12 <Heffalump> > last [1..]
05:59:16 <lambdabot> Terminated
05:59:19 <tsp> ah
05:59:25 <ivanm> is there a command that will give me a common prefix to two strings?
05:59:26 <tsp> can python even do that?
05:59:43 <ivanm> I can always zip them and then take while fst == snd.. but is there one already defined?
05:59:46 <tsp> terminate when something takes too long, that is
05:59:47 <paolino> with generators
05:59:47 <ekidd> QtPlatypus: As far as I know, GHC optimizes foldr/build very, very aggressively.
06:00:02 <tsp> > sum [ 1 .. 100000 ]
06:00:04 <lambdabot>  5000050000
06:00:06 <tsp> wow
06:00:08 <tsp> that was fast
06:00:15 <pejo> QtPlatypus, you mean rewriting sum [1..1000] to 1000*1001/2?
06:01:10 <QtPlatypus> pejo: *nods*
06:01:25 <ivanm> @pl \ xs ys = map fst (dropWhile (\(x,y) -> x == y) (zip xs ys))
06:01:26 <lambdabot> (line 1, column 9):
06:01:26 <lambdabot> unexpected "="
06:01:26 <lambdabot> expecting pattern or "->"
06:01:31 <ivanm> @pl \ xs ys -> map fst (dropWhile (\(x,y) -> x == y) (zip xs ys))
06:01:32 <lambdabot> ((map fst . dropWhile (uncurry (==))) .) . zip
06:02:15 <ekidd> QtPlatypus: I would assume not. But if you needed that optimization, you might be able to do something with rewrite rules.
06:02:56 <resiak> how often in practice is sum [x..y] going to be used?
06:03:20 * QtPlatypus nods
06:03:35 <pejo> Ok, so resiak stole my question. :-)
06:03:39 <tsp> > x=5; sum [ x .. x+5 ]
06:03:40 <lambdabot>  Parse error
06:03:45 <tsp> piece of crap
06:03:50 <resiak> > let x = 5 in sum [ x .. x + 5]
06:03:52 <lambdabot>  45
06:03:52 <Heffalump> tsp: lambdabot uses a second thread to do it, AFAIK
06:03:58 <Heffalump> so I'm sure python could too
06:04:00 <tsp> heh
06:04:06 <Heffalump> though concurrency is really elegant in Haskell
06:04:30 <paolino> almost everything is elegant here
06:05:12 <tsp> heh
06:05:19 <shapr> Except the IRC protocol...
06:05:42 <Heffalump> it's nice and simple and it works
06:05:45 <tsp> the .. in the middle of that sounds ugly
06:06:08 <Heffalump> I think it's really nice
06:06:09 <mahogny> IRC is a bastard kid that just don't want to die
06:06:15 <tsp> I'm assuming I can do something like (guesswork) altsum x y = sum [ x .. y ], or something to that effect?
06:06:37 <ivanm> If I have pairs of type (a,b), is it possible to sort just by the a's without explicitly creating a new ordering function?
06:06:48 <resiak> @pl \x y -> sum (enumFromTo x y)
06:06:49 <lambdabot> (sum .) . enumFromTo
06:06:53 <paolino> it will take some time to get use to haskell syntax anyway
06:07:00 <pejo> tsp, the dots are the same in math though
06:07:07 <xerox> ?type sortBy (comparing fst)
06:07:09 <mahogny> ivanm, sortBy, and then grab the ordering from fst of the tuple
06:07:09 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
06:07:21 <Heffalump> is comparing in the Prelude?
06:07:26 <Heffalump> I always find myself writing it out
06:07:28 <xerox> yup
06:07:31 <ivanm> mahogny: how do I grab the ordering?
06:07:40 <mahogny> ivanm, see xerox code
06:07:40 <ivanm> oh, comparing
06:07:47 <ivanm> just saw it
06:08:03 <Igloo> It's in Data.Ord
06:08:08 <paolino> or rewrite Ord instance
06:08:11 <tsp> @help
06:08:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:08:24 <tsp> hmm, can I pm him? don't want to spam the channel
06:08:32 <ivanm> is it possible to extend a command over multiple lines without explicitly using a let or where?
06:08:34 <xerox> yes, you can pm her.
06:08:37 <tsp> neat
06:09:38 <Pastorn> who started hIRCules?
06:09:56 <shapr> Jens Petersen?
06:10:32 <shapr> Haven't seen him around here lately though.
06:10:46 * xerox . o O ( http://en.shapropedia.org/ )
06:10:52 <shapr> :-P
06:11:01 <shapr> I'm just an index!
06:11:09 <shapr> @quote index
06:11:09 <lambdabot> shapr says: Anyway, I'm just a walking index into the Haskell world. I can tell you a little bit about many things, but I will quickly forward you to the experts for more detail.
06:12:22 <shapr> This is pretty cool - http://lambda-the-ultimate.org/node/2143
06:12:23 <lambdabot> Title: A Topos Foundation for Theories of Physics | Lambda the Ultimate
06:12:57 <ivanm> shapr: OK, lets try you out... is there anyone working on using Haskell for scientific computing purposes?
06:13:01 <shapr> "What Düring and Isham are doing is try to find a way to formulate physical theories with an interface that can be separate from an implementation. That sounds familiar already, but even more familiar is that the interface language is an high-order multi-sorted intuitionistic logic, not far from the ones we use in type systems."
06:13:04 <shapr> ivanm: Sure, lots.
06:13:19 <Heffalump> shapr: is there anything people *aren't* using Haskell for? :-)
06:13:36 <shapr> You'd probably want to start out with kzm here on the channel, he's the nearest biosciences users.
06:13:40 <ivanm> writing OSs? (yet)? ;-)
06:13:40 <shapr> user*
06:13:47 <shapr> ivanm: Yup, at least two
06:14:07 <ivanm> shapr: OK, how bout more towards the physics side of things?
06:14:25 <shapr> One is an L4 kernel (See Rebekah Leslie's work) and one started out as a jNode clone (See House by Hallgren, Tolmach, etc) and became much more.
06:14:34 <ivanm> @pl \ xs ys -> dropWhile (\(x,y) -> x == y) (zip xs ys)
06:14:34 <lambdabot> (dropWhile (uncurry (==)) .) . zip
06:14:51 <shapr> Heffalump: I haven't heard of anyone using Haskell for home automation :-)
06:15:19 <pejo> ivanm, there's a chemistry thing going on at UNSW in the PLS group that dons is in.
06:15:19 <shapr> Heffalump: You could say that Haskell isn't used for hard real time applications, but there was at least one DSL that compiles to hard realtime code.
06:15:31 <Pastorn> ivanm: that's actually the first time i've seen @pl being used and the result was BETTER than the input :)
06:15:31 <ivanm> pejo: OK, thanks
06:15:48 <ivanm> Pastorn: lol!... its an edited version of one I did just before
06:16:06 <ivanm> basically did map fst of the result
06:16:20 <Pastorn> i know what pl does, i'm just saying that what pl gave looks better =)
06:16:39 <ivanm> hmmm... is there a function that will lazily see if the length of a list is less than/equal to/ greater than an Int?
06:16:55 <shapr> I've seen atLeast used pretty often.
06:17:04 <ivanm> Pastorn: I didn't think you didn't know what it meant... just saying that it was based on one I did earlier
06:17:08 <ivanm> @hoogle atleast
06:17:08 <lambdabot> No matches found
06:17:13 <shapr> It's really just an idiom.
06:17:13 <ivanm> @hoogle atLeast
06:17:14 <lambdabot> No matches found
06:17:29 <ivanm> where can I find it?
06:17:37 <shapr> Just write it :-)
06:18:03 <ivanm> lol... just travel through the list, decrementing the value till I get a result?
06:18:20 <shapr> I'd wrap length.
06:18:23 <tsp> ack haskell is ugly
06:18:25 <ivanm> as in I reach 0, and the list still has elements?
06:18:28 <tsp> the syntax
06:18:34 <ivanm> tsp: in what way?
06:18:37 <tsp> its just symbols all over the place
06:18:38 <shapr> tsp: Ugly is a perceptual thing.
06:18:45 <tsp> ivanm: have you ever listened to haskell?
06:18:52 <ivanm> tsp: I like symbols... more mathsy!
06:18:53 <capisce> listened to haskell?
06:18:57 <shapr> tsp: Hey, didn't I meet you before on a channel with delYsid?
06:18:58 <ivanm> tsp: listened?
06:19:01 <tsp> screen reader
06:19:05 <ivanm> tsp: no
06:19:06 <tsp> shapr: #emacs
06:19:19 <tsp> ivanm: compared to python, this is uglier than sin
06:19:32 <ivanm> tsp: well, I read it, not listen to it ;-)
06:19:41 <shapr> tsp: Maybe #blinux as well?
06:19:46 <ivanm> at least its not brainfuck ;-)
06:19:46 <tsp> probably
06:19:55 <tsp> brainf is impossible
06:19:56 <capisce> I just ordered "The Haskell school of expression"
06:19:56 <ivanm> that would be fun to listen to :s
06:20:06 <tsp> capisce: just warez it
06:20:08 <tsp> lol
06:20:14 <ivanm> I just finished reading (really skimming) it
06:20:25 <capisce> but it's nicer to read a book I think
06:20:31 <tsp> I doubt you coudl even find that on warez, haskell is so weird and all
06:20:33 <pejo> tsp, could the screen reader be taught to say different things for certain patterns, like ".."?
06:20:41 <capisce> if you try to read e-books you just get distracted
06:20:42 <tsp> pejo: I want to write a screen reader of my own
06:20:50 <tsp> so that I can make it do whatever I want
06:21:05 <tsp> not limited by emacs or wahtever the newest old rehash of an old technology is
06:21:15 <shapr> Go for it!
06:21:21 <tsp> I'm using jaws for windows - its bloated, buggy and can't even work with vim properly
06:21:48 <shapr> I'd guess that Linux would be easier to modify.
06:22:01 <tsp> shapr: yeah, but I don't want to learn C that much
06:22:14 <capisce> so is "The Haskell school of expression" a good book?
06:22:26 <tsp> I use ed/edbrowse all the time, but both of those need a rewrite
06:22:43 <shapr> You'll probably need to anyway. I didn't want to learn C, but at this point in time it's likely the most popular language in the world.
06:22:52 <shapr> capisce: I like it.
06:22:54 <tsp> I gave emacspeak a try, but its like shoving a screen reader on a screen interface - it can be done, but too many keys
06:23:06 <xerox> ?type (join (ap . ((==) .)) length .) . take -- ivanm
06:23:09 <lambdabot> forall a. Int -> [a] -> Bool
06:23:12 <xerox> ^_^
06:23:25 <tsp> shapr: I can sort of code C, its just that I don't know what I want to code - how its going to fit and all down to the details so I can actually code it
06:23:52 <ivanm> xerox: what does that do? I've asked so many questions I've lost track ;-)
06:24:47 <xerox> Ah, wrong. Nevermind.
06:25:05 <ivanm> apart from an explicit check, is there anyway to ensure only +ve numbers are used for a function?
06:25:20 <Heffalump> use an unsigned datatype?
06:25:27 <Heffalump> e.g. Word32
06:25:42 <ivanm> Heffalump: that's what I want... its just integers?
06:25:58 <ivanm> can I pass a value assigned as an Int to be a Word32?
06:26:08 <ivanm> @doc Word32
06:26:09 <lambdabot> Word32 not available
06:26:24 <Saizan> > fromIntegral ( 5 :: Word32) :: Int
06:26:26 <lambdabot>  5
06:26:52 <ivanm> so I have to explicitly cast it?
06:26:59 <Saizan> yes
06:27:14 <ivanm> > let x = 5 :: Int in y = x + 1 :: Word32
06:27:14 <lambdabot>  Parse error
06:27:30 <shapr> tsp: I have that problem too. I try to start with a higher level language and understand what I want to do first. I used to use Python, but these days I use Haskell.
06:27:30 <ivanm> is that from syntax? not really done lets before... especially on the one line
06:27:31 <Heffalump> fromIntegral (-5) :: Word32
06:27:32 <Heffalump> > fromIntegral (-5) :: Word32
06:27:36 <lambdabot>  4294967291
06:27:39 <ivanm> lol
06:27:44 <Saizan> > let x = 5 :: Int in x + 1 :: Word32
06:27:45 <Heffalump> so be careful about passing in negative numbers
06:27:46 <lambdabot>  Couldn't match expected type `Word32' against inferred type `Int'
06:27:57 <xerox> > (ap (==) . (length .) . flip take) "hello" 3
06:27:59 <lambdabot>  True
06:27:59 <xerox> > (ap (==) . (length .) . flip take) "hello" 10
06:28:01 <lambdabot>  False
06:28:12 <Heffalump> @src ap
06:28:13 <lambdabot> ap = liftM2 id
06:28:29 <ivanm> well, since its only for my use, I could just assume it works ;-)
06:28:39 <resiak> > (ap (==) . (length .) . flip take) [1..] 3
06:28:41 <lambdabot>  True
06:28:44 <xerox> ^_^
06:29:15 <ivanm> > (ap (==) . (length .) . flip take) [1..2] 3
06:29:16 <lambdabot>  False
06:29:30 <resiak> why is that better than  \n -> not . null . drop (n-1)  ?
06:29:39 <QtPlatypus> @type ap
06:29:41 <yuesefa> @help
06:29:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:29:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:29:51 <ivanm> > (ap (==) . (length .) . flip take) [1..3] -1
06:29:52 <lambdabot>   add an instance declaration for (Num (Int -> Bool))
06:29:53 <lambdabot>     In the expression:
06:29:53 <lambdabot> ...
06:29:58 <ivanm> lol
06:30:17 <xerox> resiak: nice one
06:30:35 <ivanm> > \n -> not . null . drop (n - 1) [1..] $ 3
06:30:36 <lambdabot>  Couldn't match expected type `a -> [a1]'
06:30:42 <yuesefa> q
06:30:47 <ivanm> > \n -> not . null . drop (n - 1) $ [1..] $ 3
06:30:48 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
06:30:55 <resiak> ivanm: I have the arguments the other way around
06:31:03 <ivanm> resiak: ahhh, k
06:31:03 <resiak> > let atLeast n = not . null . drop (n - 1) in atLeast 5 [1..5]
06:31:05 <lambdabot>  True
06:31:10 <ivanm> > \n -> not . null . drop (n - 1) $ 3 $ [1..]
06:31:11 <lambdabot>   add an instance declaration for (Num ([t] -> [a]))
06:31:15 <ivanm> lol
06:31:24 <ivanm> @type \n -> not . null . drop (n - 1)
06:31:27 <lambdabot> forall a. Int -> [a] -> Bool
06:31:33 <ivanm> @pl \n -> not . null . drop (n - 1)
06:31:33 <lambdabot> ((not . null) .) . drop . subtract 1
06:32:08 <xerox> > (\n -> not . null . drop (n-1)) (-1) [1..]
06:32:09 <lambdabot>  True
06:32:16 <ivanm> @pl \xs n -> not ( null ( drop (n - 1) xs))
06:32:16 <lambdabot> ((not . null) .) . flip (drop . subtract 1)
06:32:17 <xerox> > (ap (==) . (length .) . flip take) [1..] (-1)
06:32:18 <lambdabot>  False
06:32:49 <xerox> they differ
06:33:16 <ivanm> so the lambda one is satisfied for -ve numbers, which is technically correct
06:33:27 <ivanm> (\n -> not . null . drop (n-1)) (3) [1..3]
06:33:33 <ivanm> > (\n -> not . null . drop (n-1)) (3) [1..3]
06:33:34 <lambdabot>  True
06:33:54 <ivanm> @pl \n xs -> not ( null ( drop (n - 1) xs))
06:33:54 <lambdabot> ((not . null) .) . drop . subtract 1
06:34:34 <ivanm> ^^ I'll use this one then
06:34:43 <ivanm> thanks xerox and resiak!
06:34:45 <ivanm> xerox++
06:34:48 <ivanm> resiak++
06:34:51 <ivanm> shapr++
06:36:31 <matthew-_> so, if I have n,m :: DecQ how do I combine them to make one Q [Dec] ?
06:36:53 <matthew-_> i.e. how do I work within Q?
06:37:03 <matthew-_> this TH stuff is still killing my head...
06:37:19 <shapr> runQ?
06:37:31 <shapr> ivanm: w00, anything else I can do for karma points? ;-)
06:37:42 <ivanm> lol
06:37:45 <ivanm> @karma shapr
06:37:46 <lambdabot> shapr has a karma of 38
06:37:53 <Igloo> matthew-_: liftM2 (++)
06:37:53 <ivanm> @karma xerox
06:37:54 <lambdabot> xerox has a karma of 28
06:38:01 <shapr> @karma Igloo
06:38:02 <lambdabot> Igloo has a karma of 12
06:38:04 <ivanm> @karma resiak
06:38:05 <lambdabot> resiak has a karma of 1
06:38:06 <shapr> Igloo++
06:38:10 <shapr> @karma edwinb
06:38:10 <lambdabot> edwinb has a karma of 0
06:38:14 <shapr> @karma edwardk
06:38:14 <lambdabot> edwardk has a karma of 4
06:38:17 <matthew-_> Igloo, shapr: yes, I've just bothered to notice that Q is in Monad
06:38:18 <Igloo> matthew-_: Or do n' <- n; m' <- m; return (n' ++ m')
06:38:30 <ivanm> shapr: seeing as how the other two have less than you, no sorry.. ;-)
06:38:33 <ivanm> @karma ivanm
06:38:33 <lambdabot> You have a karma of 0
06:38:35 <shapr> aww
06:38:38 <ivanm> lol
06:38:52 <ivanm> shapr: you a karma whore? :p
06:38:52 <matthew-_> ok, anger and frustration obviously make be blind!
06:38:55 <edwardk> is the only way to use c++ from haskell without handcoded stubs the hackish way mentioned on http://www.haskell.org/haskellwiki/CPlusPlusFromHaskell ?
06:38:57 <lambdabot> Title: CPlusPlus from Haskell - HaskellWiki
06:39:38 <shapr> ivanm: Nah, not really.
06:39:54 <edwardk> @karma shapr
06:39:55 <lambdabot> shapr has a karma of 38
06:39:59 <Heffalump> it doesn't explain how to do virtual calls, either
06:40:00 <edwardk> yeah, he's a karma whore ;)
06:40:05 <ivanm> lol
06:40:12 <Heffalump> @karma
06:40:14 <lambdabot> You have a karma of 6
06:40:25 <Igloo> edwardk: I don't know of a nicer way
06:40:27 <edwardk> heff: yeah =(
06:40:29 <Heffalump> clearly a Hefflaump is 3/19ths of a shapr.
06:40:33 <ivanm> @type comparing
06:40:35 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
06:40:38 <Heffalump> s/Hefflaump/Heffalump/
06:40:58 <Igloo> Heffalump: Are you being rude about shapr's weight again?
06:41:08 <edwardk> was thinking about coding something up, but it involes leveraging a monstrous amount of existing c++ code written by a 3rd party, and i'm not sure i could bring myself to code it in haskell if thats the way I have to talk to it =(
06:41:27 <ivanm> @type groupBy
06:41:29 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
06:41:52 <edwardk> no cpp2hs, eh? =)
06:42:25 <ivanm> @pl \xs -> groupBy (\ x y -> f (fst x) (fst y))
06:42:25 <lambdabot> const (groupBy ((. fst) . f . fst))
06:42:43 <ivanm> stupid
06:42:48 <ivanm> @pl groupBy (\ x y -> f (fst x) (fst y))
06:42:48 <lambdabot> groupBy ((. fst) . f . fst)
06:43:09 <Heffalump> surely the best thing would be to write a preprocessor for C++ class declarations
06:43:16 <Heffalump> that makes C stubs you can call
06:44:10 <edwardk> heff: not exactly a low overhead way to go though to bolt in stubs everywhere
06:45:24 <ivanm> someones asked me if there's any way you can treat functions as data in Java.  Is there?
06:45:54 <Heffalump> I don't see how else you can hook into the virtual calling mechanism generically.
06:46:04 <shapr> Igloo: haha
06:46:07 <Heffalump> ivanm: well, you can use anonymous classes to do it, sort of
06:46:15 <shapr> Igloo: Just because I weigh 100 kilos
06:46:26 * Heffalump weighs more than 3/19ths of 100 kilos.
06:46:36 <edwardk> heff: =(
06:47:06 <tsp> damnit, hugs kompilas malrapide
06:47:06 <ivanm> is there any way I can extend a function over more than one line without using let or where?
06:47:32 <Heffalump> just start a new line
06:47:41 <Heffalump> or am I confused about your question?
06:47:48 <ivanm> don't think so
06:47:51 <Heffalump> make sure the start of the new line is more indented than the previous line
06:48:21 <ivanm> nope, that seems to work... without any more indentation (I have a . on the end of the previous line though(
06:48:55 <matthew-_> sheesh, talk about hitting your head against a wall... do I take it TH isn't particularly well used?
06:49:18 <Heffalump> matthew-_: correct
06:49:49 <matthew-_> sheesh, talk about hitting your head against a wall... do I take it TH isn't particularly well used?
06:50:11 <pejo> matthew, yes.
06:50:12 <Igloo> matthew-_: Why do you say that?
06:50:22 <ivanm> matthew-_: Heffalump just anwered your question...
06:50:34 <matthew-_> ivanm, sorry connection problems here
06:50:39 <ivanm> lol
06:50:49 <matthew-_> Igloo: it just feels really confused
06:50:53 <Philippa> it's often not necessary, and often when it is the syntax to use the results is a bit painful still
06:50:58 <matthew-_> Igloo: it's probably just me.
06:51:03 <Philippa> how so? It never struck me that way
06:51:32 <matthew-_> The $(...) and [| blah |] syntax just totally throw me
06:51:43 <matthew-_> particularly in the way they can be combined
06:52:13 <Heffalump> I found some of the restrictions quite onerous, but I forget the details now.
06:52:36 <matthew-_> so, I've been wanting to do [d| $blah = $blam |] which you can't do
06:52:58 <matthew-_> and the way round has taken me some significant time
06:54:00 <matthew-_> and it's a little frustrating that the original paper doesn't talk about Q at all
06:54:33 <matthew-_> and should you try to use varP or VarP - i.e. should you try and construct within Q or outside?
06:54:50 <Igloo> Are you sure it doesn't talk about Q?
06:55:21 <matthew-_> given that the [*| ... |] syntax and the examples are all outside of Q
06:55:35 <matthew-_> Igloo: yup, acroread finds no Q within the entire pdy
06:55:38 <matthew-_> -y+f
06:55:41 <Igloo> [*| ... |] returns a Q t
06:55:46 <matthew-_> exactly
06:56:04 * Igloo doesn't understand what you mean by "outside of Q" then
06:56:14 <Igloo> but normally you'd want varP etc
06:56:23 <matthew-_> right. ok, I wasn't clear
06:57:04 <Igloo> http://www.haskell.org/th/papers/meta-haskell.ps talks about Q in "Secrets Revealed" on p5
06:57:32 <matthew-_> oh ok, I'm looking at the meta-haskell.pdf
06:57:39 <Igloo> Where from?
06:58:00 <matthew-_> oh, I may be going mad.
06:59:38 <matthew-_> awesome, on the pdf, acroread doesn't search the code. Odd
06:59:52 <matthew-_> ok, ignore me, I obviously just need to do more reading. thanks for your help
07:00:36 <ivanm> @pl \ xs@(x1:x2:_) -> (f (fst x1) (fst x2), map snd xs)
07:00:36 <lambdabot> (line 1, column 5):
07:00:36 <lambdabot> unexpected "@"
07:00:36 <lambdabot> expecting letter or digit, operator, pattern or "->"
07:00:50 <ivanm> @pl g xs@(x1:x2:_) -> (f (fst x1) (fst x2), map snd xs)
07:00:50 <lambdabot> (line 1, column 13):
07:00:51 <lambdabot> unexpected "_"
07:00:51 <lambdabot> expecting white space or simple term
07:00:58 <ivanm> @pl g xs@(x1:x2:xs') -> (f (fst x1) (fst x2), map snd xs)
07:00:58 <lambdabot> (line 1, column 18):
07:00:58 <lambdabot> unexpected ">" or "-"
07:00:58 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
07:01:12 <ivanm> @pl g xs@(x1:x2:xs') = (f (fst x1) (fst x2), map snd xs)
07:01:13 <lambdabot> (line 1, column 18):
07:01:13 <lambdabot> unexpected "="
07:01:13 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
07:01:23 <ivanm> arghh!!!!!
07:02:04 <ivanm> @pl \[x1,x2] -> (x1,x2)
07:02:04 <lambdabot> (line 1, column 2):
07:02:04 <lambdabot> unexpected "["
07:02:04 <lambdabot> expecting pattern
07:02:22 <ivanm> @pl \xs -> (xs!0,xs!1)
07:02:22 <lambdabot> liftM2 (,) (! 0) (! 1)
07:02:40 <ivanm> @pl \(x1:xs:xs) -> (x1,x2)
07:02:41 <lambdabot> ap ((`ap` tail) . (. head) . const . const . flip (,) x2 . head) tail
07:03:09 <ivanm> @unpl ap ((`ap` tail) . (. head) . const . const . flip (,) x2 . head) tail
07:03:10 <lambdabot> ((\ p -> (\ ae _ -> (,) (head p) x2) >>= \ ag -> tail >>= \ af -> return (ag af)) >>= \ i -> tail >>= \ h -> return (i h))
07:03:21 <ivanm> now _that's_ ugly!
07:03:49 <paolino>  @hoogle parseFromFile
07:03:59 <kpreid> @. redo unpl ap ((`ap` tail) . (. head) . const . const . flip (,) x2 . head) tail
07:03:59 <lambdabot> (do { i <- (\ p -> do { ag <- (\ ae _ -> (,) (head p) x2); af <- tail; return (ag af)}); h <- tail; return (i h)})
07:04:26 <kpreid> ivanm: @unpl doesn't do type inference, so it can't un-reader-monad things
07:04:40 <ivanm> yeah, I just felt like seeing what it would give me
07:05:10 <UUStudent> hello
07:05:21 <kpreid> if I get back to working on it I'll add an option to assume all monadic operators are reader
07:05:24 <paolino> uhm anyone uses parsec ?
07:05:33 <UUStudent> my compiler says the function chr is not in scope, but I think it should be, what's the problem?
07:05:41 <ivanm> @hoogle chr
07:05:41 <lambdabot> Char.chr :: Int -> Char
07:05:41 <lambdabot> Text.PrettyPrint.HughesPJ.Chr :: Char -> TextDetails
07:05:41 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
07:05:48 <ivanm> import Char ?
07:06:00 <paolino> Data.Char
07:06:35 <Herald> hi, could anyone tell me if there is a prelude function that will simplify : ((div hy h)*h)
07:06:52 <ivanm> floor or ceiling?
07:07:00 <ivanm> probably floor...
07:07:05 <Herald> eh ?
07:07:06 <ivanm> > floor 2.3
07:07:07 <lambdabot>  2
07:07:26 <ivanm> when you say div by h, you mean you want the integer division by h?
07:07:34 <Herald> yes
07:07:40 <ivanm> > (2.3 div 3) * 3
07:07:41 <lambdabot>        add an instance declaration for
07:07:42 <lambdabot>       (Fractional ((a1 -> a1 -> a1) ->...
07:07:52 <ivanm> ummm, probably not floor then...
07:07:56 <ivanm> > (2.3 div 3.0) * 3.0
07:07:57 <lambdabot>        add an instance declaration for
07:07:57 <lambdabot>       (Fractional ((a1 -> a1 -> a1) ->...
07:08:02 <ivanm> lol
07:08:03 <xerox> ?type (\x -> (fromInteger x) `div` 2) pi
07:08:06 <lambdabot>     No instance for (Floating Integer)
07:08:06 <lambdabot>       arising from use of `pi' at <interactive>:1:32-33
07:08:11 <xerox> ?type (\x -> (toInteger x) `div` 2) pi
07:08:13 <lambdabot>     Ambiguous type variable `a' in the constraints:
07:08:13 <lambdabot>       `Floating a' arising from use of `pi' at <interactive>:1:30-31
07:08:15 <rahikkala> > (2.3 `div` 3) * 3 :: Int
07:08:15 <xerox> oops.
07:08:16 <lambdabot>   add an instance declaration for (Fractional Int)
07:08:24 <Herald> > div 5 2
07:08:25 <lambdabot>  2
07:08:34 <tcr> GHC hackers: Is there a way to make the exception message of `Non-exhaustive patterns in function' provide some kind of hint at what the datum actually was?
07:08:37 <Herald> > (div 5 2)*2
07:08:39 <lambdabot>  4
07:08:50 <Herald> you see ?
07:08:58 <ivanm> ummm... I got confused, sorry
07:09:05 <ivanm> wasn't thinking right
07:09:18 <Lemmih> tcr: add 'yourFunc x = error (show x)'
07:09:24 <Igloo> tcr: Only by putting adding a case to print it yourself
07:10:00 <ivanm> > (\ x y -> x - (x mod y) $ 5) $ 2
07:10:01 <lambdabot>      Occurs check: cannot construct the infinite type:
07:10:01 <lambdabot>       a = (a1 -> a1 ->...
07:10:14 <ivanm> > (\ x y -> x - (x mod y)) $ 5 $ 2
07:10:15 <lambdabot>      Occurs check: cannot construct the infinite type:
07:10:15 <lambdabot>       a = (a1 -> a1 ->...
07:10:26 <ivanm> how do you use lambda for multiple values?
07:10:34 <resiak> > (\x y -> x - (x `mod` y)) 5 2
07:10:37 <lambdabot>  4
07:10:39 <tcr> Lemmih, Igloo: Oh, I see. But why do I need to do that explicitly? Are all the necessary information wiped away at runtime?
07:10:42 <xerox> > (\f -> (f pi) `div` 2) `map` [round,floor,ceiling]
07:10:44 <lambdabot>  [1,1,2]
07:10:56 <ivanm> resiak: that's what I was after
07:11:10 <ivanm> Herald: you can subtract the mod...
07:11:13 <Igloo> tcr: I think so
07:11:17 <ivanm> *shrug* best I can think of
07:11:29 <Herald> cheers, doesnt really simplify a huge amount tho
07:11:36 <Herald> thanks anyway :)
07:11:39 <ivanm> no probs
07:11:54 <ivanm> but, IIRC, division is more expensive than mod
07:11:55 <pejo> Herald, do you want to rerwrite (hy/h)*h to hy?
07:12:00 <paolino> anyway, I ask. After introducing user state in parsec , parseFromFile fails typechecking, it wants () as state type, can it be ?
07:12:12 <ivanm> pejo: it will be ((hy + c)/y)*y
07:12:13 <dmhouse> > map ($ pi) [round, floor, ceiling]
07:12:15 <lambdabot>  [3,3,4]
07:12:22 <ivanm> where 0 <= c <= y
07:12:39 <ivanm> i.e. c = h mod y
07:12:49 <paolino> @hoogle Parser
07:12:49 <lambdabot> Language.Haskell.Parser :: module
07:12:50 <lambdabot> Text.ParserCombinators.Parsec.Prim.Parser :: type Parser a
07:12:50 <lambdabot> Distribution.InstalledPackageInfo.ParseResult :: data ParseResult a
07:12:51 <xerox> dmhouse: actually if that map was called . it would have been even better (:
07:13:31 <paolino> Parser a is not parametric on user state
07:19:52 <ivanm> I've got a large chunk of text that I want to use paste into a Haskell program as a String
07:20:13 <ivanm> but its complaining about the character literal '\n'... what can I do?
07:20:44 <ivanm> apart from manually removing the line breaks, that is ;-)
07:21:45 <Saizan> uhm i don't think we have multiline literal strings as in python's """
07:23:08 <ivanm> oh well
07:23:18 <ivanm> I'll just remove the line breaks
07:25:19 <Igloo> You can say
07:25:25 <Igloo> foo = "foo\n\
07:25:28 <Igloo> \bar"
07:25:35 <Igloo> but nothing more pleasant than that
07:25:45 <ivanm> I was hoping I could get away with any editing at all
07:25:51 <ivanm> eventually, it'll read in the text
07:25:59 <ivanm> but for now, its just using a variable
07:35:01 <mattam> Anyone knows how to typeset Â§ in LaTeX ?
07:36:41 <Igloo> I think the start of symbols-a4.ps tells you
07:37:26 <mattam> i'll check that thx
07:38:53 <mattam> \S it is
07:39:53 <ekidd> Whee!
07:40:18 * ekidd is having fun typesetting category theory diagrams with xypic
07:41:11 <mattam> I never had 'fun' doing that :)
07:41:25 <Igloo> I tended to use metapost for similar things
07:41:34 <ekidd> But they're so shiny when they're done! :-)
07:41:59 <Codex_> any good diagrams?
07:42:28 <mattam> xypic is pretty nice though, does metapost have the same kind of interface (a grid and automatic arrangement of arrows, names etc..) ?
07:42:59 <Igloo> I'm not sure I've ever used xypic. The nice thing about metapost is that it will automatically solve equations for you
07:44:05 <Igloo> equations describing the relative placement of things, that is
07:44:51 <mattam> Xypic permits writing diagram using an array-based description language. You put in each cell the names, objects you want there and arrows to other objects (giving the length in cell units).
07:44:52 <Codex_> that sounds really complex....
07:45:21 <mattam> so it calculates these lengths alone ?
07:45:58 <xs> pgf/TikZ is nice.
07:46:10 * earthy seconds TikZ
07:46:39 <earthy> it can also solve equations, plus, it is *not* dependent on PostScript
07:46:39 <mattam> You just have to give names to the nodes like in pgf i guess.
07:46:54 <earthy> so it will generate e.g. pdf directly
07:47:05 <earthy> mattam: yup
07:47:16 <earthy> but you have to do that in metapost as well
07:49:05 <ekidd> Codex_: xypic is extremely reasonable for commutative diagrams once you get used to the syntax. It's a purely declarative language based on an underlying grid structure, with lots of support for customizable arrows, bending lines, and stuff.
07:49:14 <ekidd> It might not work for something with different constraints.
07:52:22 <mattam> TikZ seems the Right Thing ! I was really scared by pgf's verbose syntax :(
07:52:30 <HairyDude> what's the difference between getEnv and getEnvironment, other than that the latter doesn't seem to exist on my system?
07:53:46 <int-e> they have different types
07:54:12 <int-e> @type System.Environment.getEnv
07:54:15 <lambdabot> String -> IO String
07:54:17 <int-e> @type System.Environment.getEnvironmnet
07:54:19 <lambdabot>     Not in scope: `System.Environment.getEnvironmnet'
07:54:19 <int-e> @type System.Environment.getEnvironment
07:54:22 <lambdabot> IO [(String, String)]
07:55:22 <HairyDude> okay, so why doesn't it exist on my system?
07:55:57 <int-e> I don't know. Have you imported System.Environment? And what's your system?
07:55:58 <HairyDude> or rather, it only exists for ghc... sigh
07:56:43 <HairyDude> system is fc6
07:56:44 <int-e> oh.
07:56:47 <Igloo> One of them is posix-only IIRC
07:57:06 <HairyDude> it's a posix system, should be no problem
07:57:26 <int-e> it's true - it's only defined for GHC. I wonder why.
07:58:31 <HairyDude> was trying to use hugs for cgi, but it looks like this library doesn't like hugs
07:59:00 <HairyDude> is it possible to use ghc as an interpreter?
07:59:07 <int-e> ghci
07:59:17 <HairyDude> does that work non-interactively as well then?
08:01:07 <int-e> I think it does - runhaskell (as it comes with ghc) doesn't compile the code afaik.
08:01:09 <HairyDude> ah, there's runhaskell isn't there
08:02:22 <int-e> oh and runghc
08:02:46 <int-e> (same program, different name, and more specific)
08:03:33 <int-e> http://www.haskell.org/ghc/docs/latest/html/users_guide/modes.html#eval-mode
08:03:34 <lambdabot> Title: 4.4. Modes of operation, http://tinyurl.com/2dwnn7
08:15:17 <HairyDude> hrm, I see ByteString is so new that there's no fedora extras package for it
08:17:02 <Igloo> It's in base in ghc 6.6
08:18:38 <HairyDude> which also isn't in fedora extras - all the ghc packages are 6.4
08:19:13 <HairyDude> bah, being a neophile is annoying sometimes :)
08:21:42 <bringert> kosmikus: I guess you're not here, but I've run into a problem with how lhs2TeX handles UTF-8 characters in verbatim blocks
08:22:37 <Igloo> bringert: Presumably you used ghc to compile lhs2TeX?
08:22:54 <bringert> Igloo: yes
08:24:02 <bringert> Igloo: should I use something else? GNU ADA compiler? :-P
08:24:47 <Igloo> bringert: If you'd used hugs I'd have suggested trying GHC, that's all
08:24:59 <bringert> ah
08:27:50 <bringert> I worked around it using Verbatim (fancyvrb) instead of verbatim. cheesy hack
08:28:18 <HairyDude> oh, it's fc5 not fc6, sorry
08:45:04 <shapr> Quote that just happened in our pair programming session:
08:45:11 <shapr> <shae> What's (certInfo':) ?
08:45:19 <shapr> <Lemmih> It's a smiley face, it makes the compiler happy.
08:45:21 * shapr laughs
08:45:44 <Botje> :)
08:50:30 <HairyDude> looks like ByteString doesn't like ghc 6.4, sigh
08:50:58 <Lemmih> HairyDude: Oh but it does.
08:52:13 <HairyDude> ./Data/ByteString/Base.hs:108:33:
08:52:13 <HairyDude>     Module `GHC.ForeignPtr' does not export `mallocPlainForeignPtrBytes'
08:54:54 <Lemmih> HairyDude: Did you get FPS from darcs?
08:56:05 <HairyDude> no, from http://www.cse.unsw.edu.au/~dons/fps.html
08:56:05 <lambdabot> Title: Data.ByteString
08:56:58 <Lemmih> HairyDude: Version 0.7?
08:57:18 <HairyDude> yup
08:58:50 <Lemmih> HairyDude: Do you have -DSLOW_FOREIGN_PTR in fps.cabal?
08:59:09 <Lemmih> HairyDude: How are you building the library, btw?
08:59:24 <HairyDude> ah, I didn't build it, just using it directly using runghc
09:00:07 <Lemmih> Ah, use Cabal or manually set -DSLOW_FOREIGN_PTR.
09:01:28 <HairyDude> During interactive linking, GHCi couldn't find the following symbol:
09:01:28 <HairyDude>   fps_count
09:01:51 <HairyDude> that's with -DSLOW_FOREIGN_PTR in the #! line
09:02:01 <Lemmih> HairyDude: Use cabal.
09:02:08 <HairyDude> okay :)
09:13:10 <sorear> hello.
09:13:11 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
09:13:16 <sorear> @messages
09:13:17 <lambdabot> dons said 5h 39m 6s ago: in the last 52 weeks since i've been doing the HWN, there's been 42 editions.
09:15:07 <sorear> ... must have forgotten a :) or two ... I agree that dons' phdwork is far more important than the hwn
09:19:26 <HairyDude> hwn? hurricane watch net?
09:20:08 <psi> haskell weekly news
09:20:15 <scriptdevil> is jedits indent file for haskell ok??
09:20:35 <HairyDude> ah yes
09:21:14 <scriptdevil> HairyDude: .. thats good.. emacs messes it up when a do branch comes up...
09:22:12 <HairyDude> scriptdevil: wasn't in response to you
09:22:22 <scriptdevil> ... :((
09:23:33 <HairyDude> I've tried using emacs on and off, but I just find it icky :) vim is more friendly somehow
09:23:36 <sorear> scriptdevil: emacs' haskell-mode is v. old, there's a much better one out there
09:23:50 <HairyDude> oh, now that's interesting
09:23:51 <psi> scriptdevil: how does it mess up? if expressions?
09:24:01 <scriptdevil> sorear: .. it kills me.. i love it for one reason.... it shows the type
09:24:26 <scriptdevil> psi: the then brach comes to the same line as if branch.. instead of next indent
09:24:42 <psi> yeah.
09:24:53 <scriptdevil> psi: that is an error....
09:25:06 <scriptdevil> a bug not due to me ... but due to emacs...
09:25:12 <psi> yes, it's well known. someone should fix it :)
09:25:31 <scriptdevil> if i knew elisp.... i would
09:25:55 <dmhouse> sorear: Emacs's?
09:26:14 <dmhouse> The latest haskell-mode from http://haskell.org/haskell-mode is up-to-date, and the only one that I know of.
09:26:16 <lambdabot> Title: Haskell Mode for Emacs
09:26:25 <dmhouse> Emacs has never come with haskell-mode, AFAIK.
09:26:34 <psi> it doesn't.
09:26:53 <HairyDude> mine does
09:27:42 <xerox> carbon emacs does e.g.
09:27:51 <dmhouse> Emacs itself doesn't, but your distro's Emacs might, I guess.
09:28:01 <HairyDude> yes
09:28:09 <beelsebob_> is it safe to ctrl-c a darcs push?
09:28:47 <emu> i fixed it in my copy of haskell-mode, but some people may not like the fix
09:28:56 <sorear> beelsebob_: yes
09:29:02 <sorear> beelsebob_: er, nm, I don't no
09:29:07 <beelsebob_> :/
09:29:09 <dmhouse> beelsebob_: I think so, but you might have to dig in and rm -f a lock file.
09:29:17 <beelsebob_> okay
09:29:26 <sorear> HairyDude: the debian haskell-mode is old and bad...
09:29:29 <beelsebob_> :/ is there a verbose mode for push that shows what it's doing?
09:29:31 <dmhouse> You can always delete the repo on the other end and repush the entire lot.
09:29:37 <dmhouse> beelsebob_: yeah, -v.
09:30:13 <beelsebob_> cool :)
09:30:14 <HairyDude> sorear: aah
09:30:41 <sorear> HairyDude: I have a better h-mode here, lets see if I can figure out where I got it...
09:31:07 <psi> the link dmhouse pasted contains a link to the latest version.
09:31:45 <dmhouse> 2.2 is fairly new, you should upgrade if you haven't already.
09:31:47 <sorear> I also have a mrd-haskell-mode-2006-12-09.tar.gz
09:32:06 <dmhouse> It contains a fix from me to stop indentation from screwing up when you include a blank line in (say) a let-block.
09:33:11 <sorear> it seems I'm using the mrd-haskell-mode right now...
09:33:18 <dmhouse> What is it?
09:34:52 <sorear> looking through the logs, it seems to be emu's fork
09:35:40 * sorear diffs against the haskell.org haskell-mode
09:37:19 <sorear> hmm, emu's haskell-mode is rather different from the h.org latest...
09:38:01 <pejo> Does upstream refuse patches, or is it that simply nobody has tried to merge the changes?
09:38:06 <Herald> whats the square function in the prelude called?
09:38:15 <sorear> there seems to be a lot of new stuff in both
09:38:18 <sorear> Herald: (^2)
09:38:22 <dmhouse> Herald: (^), (**) or (^^) do powers.
09:38:24 <dmhouse> :t (^)
09:38:26 <Herald> ha ofc, thnx
09:38:27 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
09:38:29 <dmhouse> :t (**)
09:38:32 <lambdabot> forall a. (Floating a) => a -> a -> a
09:38:35 <dmhouse> :t (^^)
09:38:38 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
09:39:32 <sorear> emu: what is the status of your haskell-mode?
09:39:48 <sorear> obsolete and I should go to stefan monnier's one?
09:43:53 <xerox> @check \a b -> (a::Integer)^(b::Double) == a^^b
09:43:54 <lambdabot>        add an instance declaration for       (Fractional Integer, Integral Do...
09:44:11 <xerox> @check \a b -> (a::Double)^(b::Integer) == a^^b
09:44:12 <lambdabot>  Exception: Prelude.^: negative exponent
09:44:36 <sorear> xerox: ^ is positive integral, ^^ is integral, ** is arbitrary
09:46:50 <sorear> @botsnack
09:46:51 <lambdabot> :)
09:49:30 <araujo> good morning
09:49:31 <lambdabot> araujo: You have 1 new message. '/msg lambdabot @messages' to read it.
09:50:04 <hyrax42> upgrading packages
09:50:26 <hyrax42> as simple as reinstalling, or does the old version need to be removed?
09:50:44 <sorear> the former
09:51:00 <sorear> the old version will stay around if you ever need it
09:51:27 <sorear> so if a package depends on quux, and you have quux-0.1 and quux-0.2, quux-0.2 will be chosen
09:51:39 <sorear> but, if it depends on quux (<=0.1.5)
09:51:48 <sorear> quux-0.1 will be chosen
09:51:51 <hyrax42> oh wait my cabal was upgraded when I upgraded to 6.6
09:51:53 <sorear> because it's still there
09:51:56 <sorear> neat, eh?
09:52:06 <hyrax42> that is handy, but how does it work for execs?
09:52:14 <hyrax42> you have to decide yourself wich is on PATH?
09:52:44 <desp> is there a built-in factorial function?
09:52:48 <desp> @hoogle factorial
09:52:49 <lambdabot> No matches found
09:52:51 <desp> @hoogle fac
09:52:52 <lambdabot> Text.Html.face :: String -> HtmlAttr
09:52:53 <lambdabot> Distribution.Extension.ForeignFunctionInterface :: Extension
09:52:53 <lambdabot> Distribution.InstalledPackageInfo.haddockInterfaces :: InstalledPackageInfo -> [FilePath]
09:52:54 <dmhouse> desp: nope, but it's pretty easy to define.
09:52:55 <hyrax42> desp:  I don't think so
09:53:01 <desp> dmhouse: sure, just wondering
09:53:01 <dmhouse> desp: fac n = product [1..n]
09:53:05 <hyrax42> > product [1..10]
09:53:07 <lambdabot>  3628800
09:53:08 <desp> aha
09:53:22 <shapr> Where's desrt these days?
09:53:22 <Saizan> ?src product
09:53:22 <lambdabot> product = foldl (*) 1
09:53:50 <Saizan> > product [1..100000]
09:53:51 <dmhouse> desp: see also http://www.willamette.edu/~fruehr/haskell/evolution.html :)
09:53:53 <lambdabot> Title: The Evolution of a Haskell Programmer
09:53:54 <lambdabot> Terminated
09:54:01 <desp> dmhouse: right ;)
09:54:20 <dmhouse> > foldl' (*) 1 [1..100000]
09:54:25 <lambdabot> Terminated
09:54:48 <dmhouse> I think product doesn't use foldl' by default because you can't assume (*) is strict.
09:56:15 <hyrax42> hmm at which version was cabal-install added to cabal
09:58:10 <dmhouse> hyrax42: I think it's still in the darcs version, not as of yet stable.
10:00:12 <ddarius> Electromagnetic Theory and Computation: A Topological Approach hmm
10:02:26 <HairyDude> hrm... does runghc have anything like runhugs's -X?
10:02:47 <HairyDude> (my installation seems to have no manpage for it)
10:02:49 <Lemmih> What does -X do?
10:04:40 <HairyDude> when you have a #! line like #!/usr/bin/runhugs foo bar baz, the "foo bar baz" is passed as all one argument. but if you do #!/usr/bin/runhugs -X foo bar baz, runhugs interprets them as separate arguments instead
10:05:01 <Igloo> No: http://hackage.haskell.org/trac/ghc/ticket/1232
10:05:03 <lambdabot> Title: #1232 (generalise runhaskell to support arbitrary file names, not just those wit ...
10:05:16 <hyrax42> dmhouse: ah ok
10:07:11 <HairyDude> ah, thanks
10:07:17 <HairyDude> that's rather awkward
10:07:41 <beelsebob_> gyah, how would one type UTF characters into an X11 based application?
10:08:06 <Cheery> does there exist some function which simply does this?     cond c a b = if c then a else b
10:08:09 <HairyDude> beelsebob_: the usual way I think, it just has to have the right locale I think
10:08:18 <beelsebob_> arse
10:08:35 <beelsebob_> so you have no idea how I would type an Îµ into Inkscape on OS X?
10:08:44 <beelsebob_> without somehow getting it into a greek locale
10:09:08 <beelsebob_> (which would promptly confuse the hell out of me)
10:09:16 <Cheery> if you toy with continuations, 'if' without the syntax suckgar would be nice standard module element.
10:09:50 * HairyDude shrugs, probably the wrong channel to ask in :)
10:09:55 <beelsebob_> yeh, I know
10:10:04 <beelsebob_> I know of no other channel that might know better
10:10:17 <HairyDude> doesn't OS X use utf-8 by default?
10:10:32 <beelsebob_> my best guess was a crowd of academics who have probably at some point tried to put Îµ in a diagram
10:10:55 <integral> cut and paste it from this IRC client :)
10:11:07 <HairyDude> ah, but academics often use LaTeX, and for them putting Îµ in a diagram is trivial :)
10:11:08 <beelsebob_> integral: X11 doesn't accept OS X's paste buffer
10:11:16 <integral> ouch
10:11:24 <beelsebob_> because the OS X paste buffer is much more complex than the X11 one
10:11:31 <beelsebob_> it stores data in multiple formats
10:11:58 <integral> yeah, but often it works fine
10:12:08 <HairyDude> oh, ignore me, I forgot about that issue... I have no idea how it works :)
10:12:18 <beelsebob_> HairyDude: indeed, this diagram is unfortunately rather too complex to play with LaTeX for me to produce :/
10:12:44 <HairyDude> you can draw some pretty complex diagrams in LaTeX using the xy package
10:13:07 <beelsebob_> integral: you're right -- it does work... sometimes
10:13:09 <beelsebob_> how bizare
10:13:17 <beelsebob_> it appears to only work from certain apps
10:14:04 <bringert> beelsebob_: yeah, I've had the same experience. similar things happen on linux too
10:14:27 <bringert> beelsebob_: OOI, what kind of diagram is it?
10:14:50 <bringert> you can do soe pretty nice things with graphviz
10:14:55 <beelsebob_> it's a graph, with rather nasty annotations
10:15:00 <beelsebob_> my prototype was done in graphviz
10:15:13 <bringert> and use dot2tex to include LaTeX annotations
10:15:16 <beelsebob_> but that has two problems: (a) the node labeling is too complex for dot to deal with nicely
10:15:27 <bringert> did you try dot2tex?
10:15:27 <beelsebob_> ohhh... I've not heard of that?
10:15:32 * beelsebob_ tries it
10:15:43 <bringert> @google dot2tex
10:15:45 <lambdabot> http://www.fauskes.net/code/dot2tex/
10:15:45 <lambdabot> Title: dot2tex - A Graphviz to LaTeX converter| fauskes.net
10:15:49 <bringert> I found it just the other day
10:16:02 <beelsebob_> ah, uses pstricks
10:16:04 <beelsebob_> :
10:16:06 <beelsebob_> :/
10:16:06 <beelsebob_> arse
10:16:09 <bringert> it doesn't appear to be used much, but the results are much nicer than generating .ps with dot
10:16:20 <bringert> beelsebob_, it can also use pgf/tikz
10:16:24 <bringert> which works with pdflatex
10:16:28 <beelsebob_> ah, shiny
10:16:34 <bringert> that what I use
10:16:40 * beelsebob_ plays with it
10:17:02 <paolino> anyone knows if the field "References:" in a mail header always points to the first mail of the thread ?
10:17:49 <bringert> beelsebob_, scaling the graph was a little tricky, but I finally ended up using   d2tgraphstyle="scale=0.68" ;
10:17:49 <bringert>   d2tfigpreamble="\small" ;
10:17:49 <bringert>   nodesep="0.2";
10:17:49 <bringert>   ranksep="0.3";
10:18:10 <beelsebob_> bringert: the really important thing is to be able to have nodes with more than one label
10:18:28 <beelsebob_> i.e. they need a label *in* the node, a label to the upper left of the node, and a label to the lower right
10:18:35 <bringert> I haven't tried that, but you should be able to have arbitrary latex in the labels
10:18:50 <beelsebob_> cool, so some playing with tables and node sizes should get it to do that
10:18:59 <bringert> did you try the new "record" node shape in graphviz?
10:19:05 <ClaudiusMaximus> is it normal that "./configure --with-ghc=../relative-path-to/ghc-6.6" fails to work when building ghc-6.6?  using an absolute path works, so no big deal...   (i'm making a haskell.dyne module for pure:dyne linux distro)
10:19:18 <bringert> beelsebob_: see http://www.graphviz.org/Documentation/dotguide.pdf
10:19:38 <beelsebob_> yeh, already studied that fairly extensively
10:19:53 <beelsebob_> the record stuff isn't quite enough
10:19:58 <beelsebob_> unfortunately :(
10:19:58 <shapr> Yargh!
10:20:05 <bringert> some latex tricks should do it then
10:20:05 <shapr> Is there a maybe to monad function?
10:20:09 <bringert> no
10:20:13 <shapr> :-(
10:20:13 <bringert> there should be though
10:20:17 <beelsebob_> the other problem is that I've hit a bug in dot that means that ordering=out doesn't always work
10:20:27 <shapr> flip maybe return (fail "urk")
10:20:27 <bringert> shapr: I've written that several times
10:20:35 <beelsebob_> I submitted the bug a while ago and the devs went "uhhh... that's weird" and promptly ignored it
10:20:36 <shapr> That's Lemmih writing over my shoulder :-)
10:20:57 <shapr> bringert: You should try pair programming with vnc and voip! It's great fun!
10:21:09 <shapr> Lemmih and I have been doing that for two weeks or so now. It's great fun!
10:21:26 <bringert> shapr: why the flip?
10:21:40 <bringert> @type maybe (fail "Nothing") return
10:21:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
10:22:14 <shapr> Because that's the first thing that Lemmih just threw down? He was just brainstorming I think.
10:22:19 <bringert> I haven't done anything where I care about ordering yet
10:22:51 <shapr> @pl flip maybe return (fail "urk")
10:22:51 <lambdabot> maybe (fail "urk") return
10:23:01 <shapr> Ah bringert has @pl built into his brain.
10:23:01 <beelsebob_> bringert: yeh, it matters somewhat in this instance, in that the nodes getting swapped around means the difference between them representing a function, and it's argument
10:23:04 * shapr grins
10:23:16 <beelsebob_> shapr: which bit of Sweden do you live in?
10:23:23 <shapr> beelsebob_: The part in Alabama.
10:23:30 <beelsebob_> o.O
10:23:32 * araujo throws some sugar lambdas at shapr 
10:23:34 <beelsebob_> O.o
10:23:41 * shapr eats the sugar lambdas!
10:23:46 <araujo> :-)
10:24:05 <araujo> shapr, how you doing?
10:24:29 <bringert> beelsebob_,: ah, that would do it :-)
10:25:16 <shapr> araujo: Life is GOOD! I'm getting paid to write BSD3 Licensed Haskell code! Is that awesome or what?
10:25:26 <araujo> shapr, wowo
10:25:36 <shapr> beelsebob_: I don't live in Sweden at the moment, but I am planning to move back there in September.
10:25:40 <araujo> That's terrific
10:26:44 <beelsebob_> shapr: fun and stuffs :) at some point I need to poke people at Chalmers to see if I can come over and do some work with them
10:27:29 <araujo> shapr, so, world domination is going fine
10:27:49 <bringert> beelsebob_: what would you like to work on?
10:27:58 <Philippa> @tell xerox pong, but I may well be AFK by the time you see this - email me if you're having trouble getting hold of me?
10:27:59 <lambdabot> Consider it noted.
10:28:37 <beelsebob_> bringert: from what I hear from various people, Agda is entirely Haskell 98, and thus would provide an excellent test program for Hat
10:28:50 <beelsebob_> I need to do a load of checking to find out if it works nicely
10:29:05 <beelsebob_> but if it does, I'd want to go and work with someone who knows how agda works doing some Hat testing
10:31:24 <bringert> sounds like a good plan
10:31:42 <beelsebob_> indeed
10:31:50 <bringert> I guess someone like ulfn would be the guy to talk to
10:31:57 <beelsebob_> I'd also like to poke John Hughes about a few things with Quickcheck
10:32:03 <beelsebob_> but that's slightly a side issue
10:34:04 <beelsebob_> in the mean time... gotta finish the paper :(
10:34:08 * beelsebob_ goes to write again
10:41:24 <newsham> ?hoogle scaleFloat
10:41:25 <lambdabot> Prelude.scaleFloat :: RealFloat a => Int -> a -> a
10:45:38 <Pitarou> #haskell-soc is quiet.  Is there anybody in here who can talk about it?
10:51:35 <augustss> > scaleFloat 100 1
10:51:37 <lambdabot>  1.2676506002282295e30
10:53:44 <HairyDude> woo, I finally got the cgi library working, after hours of fiddling with cabal
10:56:03 <emu> @tell sorear stephan merged my changes into cvs and released it a few weeks ago
10:56:03 <lambdabot> Consider it noted.
10:56:18 <Pitarou> Oh, hello people!
10:56:35 <emu> @tell sorear but-- i don't think he made the indentation change because it is somewhat controversial (adds extra indentation to if-then-else)
10:56:35 <lambdabot> Consider it noted.
11:00:22 <shapr> I vaguely recall either a mailing list post or something on irc that combined bytestrings and udp, does anyone remember anything like that?
11:03:09 <newsham> best paper title "chasing bottoms"
11:03:28 <shapr> heh
11:03:39 <shapr> I liked the name of the ICFP team, "The Lazy Bottoms"
11:03:57 <shapr> I wanted to make up a Philippa-themed team called "Top Types" in response.
11:04:21 <Philippa> I should remind you I'm a switch...
11:04:30 <Philippa> (as opposed to a case)
11:05:38 <HairyDude> I take it base-2.0 comes with ghc 6.6 ?
11:06:02 <shapr> Philippa: ahaha
11:06:20 <mgsloan> I've thought of something that somewhat relates to the class hierarchy proposal.  Anyway, my idea is to declare default functions for multiple, non-related classes.  In other words, express that certain functions become defineable under certain conditions, yet it doesn't really make since to have a class that extends the other classes - the function might be declared for something that isn't members of the classes.
11:06:44 <mgsloan> s/members/a member
11:07:06 <newsham> > bottom ** top
11:07:07 <lambdabot>   Not in scope: `top'
11:08:51 <newsham> how hard would it be using the ghc lib to write a program which makes a call-graph of all functions in the std libs?
11:09:20 <shapr> If the ghc-api exports all the information available inside GHC, it'd be really easy.
11:10:41 <shapr> newsham: hIDE was able to do that: http://www.scannedinavian.com/~shae/hIDE.png
11:11:44 <Pitarou> Me wakes up.
11:12:02 <arcatan> Me wakes down.
11:12:17 <newsham> hmm.. hide already does this?
11:12:36 <Pitarou> Anybody willing to talk about last minute applications to Google Summer of Code?
11:12:46 <mahogny> what do you need to know?;
11:13:30 <Philippa> #haskell-soc might be a better place to ask, but ask away
11:13:51 <newsham> when i get to the bottom i go back to the top of the slide
11:13:54 <Pitarou> I'll see y'all in #haskell-soc then.
11:15:59 <desp> "First, colleges are somewhat elitist in the fact that they donât want to teach useful skills in getting a job programming; they want to teach you computer âscienceâ. Most of the major universities have you take plenty of courses that supposedly expand your thinking, but have absolutely no real world relevance. Iâm not sure how many semesters I spent learning things Iâll never use again like lambda calculus first-order logic."
11:16:05 <desp> hah.
11:16:51 <dolio> Heh.
11:16:57 <newsham> people like that shouldn't be in college.
11:16:58 <mgsloan> that's why there are vocational computer colleges, at least, I think there are.  You get to go and use java all the time...
11:17:00 <integral> hehe
11:17:03 <dolio> Sounds like he didn't want to go to a university.
11:17:07 <mgsloan> yeah
11:17:14 <desp> I'm afraid it's a she; first comment down at http://www.venturebeat.com/contributors/2007/01/04/a-modest-proposal/
11:17:17 <lambdabot> Title: Venture Beat Contributors » A modest proposal, http://tinyurl.com/2yy4cg
11:17:22 <newsham> if you just want to learn to program, buy a book and save yourself a few $10k
11:17:39 <mgsloan> hehe
11:17:51 <mgsloan> the best programmers come about in that way
11:18:37 <dolio> Sounds like she had a decent program, though. We never got to the lambda calculus in my curriculum, as I recall.
11:18:54 <newsham> i want to code, but i am getting on a plane for vacation in a few hrs and i have chores to do first
11:18:59 <newsham> *sigh*
11:19:15 <desp> dolio: really? I thought it was first-year material
11:19:29 <dolio> Heh, really? Where did you go?
11:19:44 <dolio> First year material is C++/Java where I went, I think.
11:20:00 <desp> still going, actually.  a polish university
11:20:21 <mgsloan> yeah, US seems to suck for CS
11:20:25 <dolio> Ah, well, I suppose that's less surprising, then. The US seems somewhat different than Europe in that regard.
11:20:46 <Philippa> desp: it was only actually covered in an optional third year module in my time at Nottingham, though we learned Haskell in the first year
11:20:48 <mgsloan> yeah.  Though I wouldn't want to spend more than a week or two on lambda calculus...
11:21:35 <dolio> I actually have a book that goes over lambda calculus from one of my courses, but it's at the end, and we instead did all the material on automata and turing machines.
11:21:57 <mgsloan> well, at least automata are fun
11:22:00 <dolio> But that was still a 3rd year course.
11:22:57 <dolio> Maybe Turing machines are more 'real world'. :)
11:23:19 <desp> :)
11:24:59 <Pitarou> Philippa: Would you mind joining us in #haskell-soc?
11:26:01 <HairyDude> anyone know if base-2.0 is incompatible with ghc 6.4?
11:26:47 <mgsloan> are there any decent CS schools in the US? I'm going to start thinking about applications fairly soon
11:27:31 <HairyDude> MIT has a good reputation :)
11:28:05 <dolio> Carnegie Mellon also has a good reputation, I think.
11:28:06 <Igloo> HairyDude: You'd be best off getting ghc 6.6
11:28:31 <HairyDude> probably
11:28:37 <mgsloan> hah, yeah, but it's on the other coast :) anyway, I probably won't get in.  Even if I do, I'd probably not go - i'd rather have the smart people yet a bit less work
11:29:04 <dolio> Ah. Well, caltech is probably acceptable, too. :)
11:29:07 <dolio> They're on the opposite coast.
11:29:17 <mgsloan> yeah, that's a good idea.
11:29:32 <augustss> MIT, CMU, Stanford, Cornell
11:29:38 <HairyDude> ooh, the generic binary tarball distribution was built on fc5, perfect :)
11:29:47 <mgsloan> I'll probably apply in the Cascadia states, and maybe try for a few of the outstanding eastern
11:30:03 <mgsloan> augustss - thanks
11:30:10 <desp> what about Berkeley?
11:30:24 <mgsloan> yeah, california
11:30:29 <augustss> mgsloan: it's not an exhaustive list.  and it depends on what you want to study in particular
11:30:34 <mgsloan> ah
11:30:44 <augustss> Berkeley is pretty good
11:30:52 <desp> I have a high opinion of CMU after last year's ICFP programming contest :)
11:31:08 <augustss> he
11:31:10 <augustss> heh
11:31:17 <mgsloan> well, I'd like a program that at least knows of functional programming :), and is interested in language design, and has a decent math program
11:31:31 <desp> mgsloan: have you seen http://www.boundvariable.org/ ?
11:31:33 <lambdabot> Title: ICFP Programming Contest, 2006
11:31:45 <mgsloan> nope
11:31:53 <mgsloan> heard about it a lot, though, of course
11:31:54 <desp> more functional language design than you can shake a rake at
11:31:56 <augustss> mgsloan: FP isn't popular in the US
11:32:05 <mgsloan> I know :(
11:32:07 <sorear> hello!
11:32:08 <lambdabot> sorear: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:32:13 <augustss> Portland State has some good FP people now
11:32:20 <ClaudiusMaximus> how many stages does compiling ghc go through?  my compile (running for 2h30m so far) is on stage2, wondering how much longer it'll be...
11:32:22 <mgsloan> heh, oregon :)
11:32:24 <sorear> @messages
11:32:25 <lambdabot> emu said 36m 21s ago: stephan merged my changes into cvs and released it a few weeks ago
11:32:25 <lambdabot> emu said 35m 49s ago: but-- i don't think he made the indentation change because it is somewhat controversial (adds extra indentation to if-then-else)
11:32:28 <newsham> here in the US we look down on math.
11:32:31 <sorear> ClaudiusMaximus: 2
11:32:35 <newsham> FP is too close to math.
11:32:43 <sorear> @karma but
11:32:43 <lambdabot> but has a karma of 0
11:32:55 <pejo> How active is Yale when it comes to fp nowdays?
11:33:00 <ClaudiusMaximus> sorear: excellent *mr burns hand gesture*
11:33:32 <augustss> Can't say I hear much of Yale anymore.
11:33:32 <sorear> ClaudiusMaximus: What version?  I hear 6.6 takes a lot longer than head
11:33:42 <sorear> ClaudiusMaximus: <- 90 mins here for head
11:33:51 <mgsloan> yeah, I will probably apply to that uni in portland... they have a pretty good rep, and I might get to work with that haskell company a bit
11:33:57 <ClaudiusMaximus> sorear: 6.6, compiling on pentium-m 1.6GHz
11:33:58 <desp> @remember sorear 90 mins here for head
11:33:59 <lambdabot> Done.
11:34:19 * desp ducks and runs
11:34:41 <mgsloan> though to tell you the truth I don't have all that much interest in crypto.  I prefer encryption by obfuscation :) Fibonacci byte switches and things
11:34:56 <sorear> desp: why?
11:35:10 <dolio> @quote head
11:35:10 <lambdabot> kyevan says: Emacs makes my head hurt almost as much as haskell!
11:35:18 <dolio> @quote for.head
11:35:19 <lambdabot> sorear says: 90 mins here for head
11:35:35 <sorear> @quote sorear
11:35:35 <lambdabot> sorear says: Haskell-98 style records are widely acknowledged as sucking
11:35:46 <sorear> @quote sorear
11:35:47 <lambdabot> sorear says: Haskell-98 style records are widely acknowledged as sucking
11:35:49 <sorear> @quote sorear
11:35:50 <lambdabot> sorear says: StefanO'Rear says: ...the semantics are what give people named Simon the courage to implement counterintuitive optimizations without losing sleep.
11:35:52 <augustss> @quote
11:35:53 <lambdabot> dolio says: [psnl] its been made worse by uni doing a sexual awareness week [dolio] Some people at your university weren't aware of sex?
11:36:23 <opqdonut> @quote opqdonut
11:36:23 <lambdabot> No quotes match. The more you drive -- the dumber you get.
11:36:25 <opqdonut> aww :(
11:36:47 <ClaudiusMaximus> ooh, it finished - 4822.38s
11:37:40 <coffee-mug> did anyone find that some newsgroups are missing with on verizon's news server?
11:37:45 <coffee-mug> like comp.lang.haskell I can't find
11:37:57 <ddarius> There isn't a comp.lang.haskell last I checked.
11:38:06 <dolio> There is now.
11:38:09 <dolio> It's pretty recent.
11:38:22 <ddarius> Well, "last I checked" was like three years ago
11:38:41 <dolio> Ah. Yeah, it's only a few months old, I think.
11:38:53 <DRMacIver> Hm. What's wrong with Haskell-98 style records?
11:39:34 * DRMacIver wouldn't have thought a record was something that was easy to get wrong. :)
11:39:52 <sorear> uh, everything?
11:39:54 <sorear> :p
11:40:02 <DRMacIver> Well I've not really looked at them.
11:40:15 <sorear> seriously, though, they are OK for what they do
11:40:16 <DRMacIver> I think I just assumed that records in Haskell worked in the obvious way.
11:40:35 <sorear> but they're missing a bunch of widely useful features
11:40:37 * DRMacIver hasn't had a reason to use them though
11:40:39 <coffee-mug> I can't find any haskell groups at all :)
11:40:43 <sorear> like extensibility and stuff
11:40:45 <coffee-mug> on verizon newsserver that is
11:40:45 <DRMacIver> Ah
11:40:47 <ddarius> There isn't too much -wrong- with them, they're just rather simplistic.
11:40:55 <chessguy> hi haskellers
11:41:08 <sorear> Record update is second class, which hurts a lot.
11:42:03 <sorear> aiui, HList is a proper record system for haskell
11:42:16 <ddarius> For some values of "proper"
11:42:19 <sorear> but it's really awkward because it doesn't have the right sugar
11:43:25 <Saizan> is there a O(n) algorithm to take n distinct randomly selected elements from a Set?
11:43:42 <ddarius> toList
11:43:49 <ddarius> take n . toList
11:44:05 <Saizan> well, that's not enough random
11:44:21 <sorear> Saizan: there's a O(n log k) alg, where k = sizeof set
11:44:48 <Saizan> using split?
11:45:03 <ddarius> Saizan: True, but it would be easy enough to just take the elements at randomly generated elements less than sizeof Set
11:45:45 <ddarius> Assuming you can generate n distinct random numbers less than the size of the Set in O(n) time, the whole algorithm should also be O(n).
11:46:14 <sorear> Saizan: http://hpaste.org/783#a1
11:46:40 <sorear> Saizan: not exactly what you're asking for, but probably close enough
11:47:51 <Saizan> uhm, yes, i can steal ideas, i must skip the "compile" part
11:48:39 <sorear> Saizan: the only way you'll be able to skip the O(k) compile phase is if you edit Data/Set.hs and expand the export list
11:48:50 <sorear> Data.Set has a far too narrow API
11:50:02 * Pitarou waves goodnight to all
11:50:11 * sorear waves back
11:50:41 <zbrown> Anyone proficient in C want to look at my code and explain to me whats wrong. Can't get a decent answer in ##C. Code is here: http://rafb.net/p/VQVtLZ80.html
11:50:46 <lambdabot> Title: Nopaste - Why won&#039;t line 43 work?!
11:50:51 <sorear> will do.
11:51:12 <zbrown> getting incompatible type error on line 43
11:51:13 <sorear> line 43 will work
11:51:30 <zbrown> [zlbr322@lee ~/LabTask6]$ gcc -o NewSpecies NewSpecies.c
11:51:30 <zbrown> NewSpecies.c: In function `main':
11:51:30 <zbrown> NewSpecies.c:43: error: incompatible types in assignment
11:51:56 <sorear> are the lnums in the paste correct?
11:52:11 <zbrown> should be, lemme look again
11:52:25 <zbrown> apparently not
11:52:26 <zbrown> doh
11:52:28 <sorear> uck, fixed size buffers :(
11:52:37 <zbrown> line 38
11:52:40 <zbrown> not 43
11:53:14 <sorear> zbrown: you can't assign arrays
11:53:29 <sorear> zbrown: you need to use memcpy or strcpy for this
11:53:33 <zbrown> oh ok
11:53:39 <zbrown> oops
11:53:50 <sorear> zbrown: while I'm at it, let me say large fixed size arrays are very bad style
11:54:05 <sorear> zbrown: even if you check them, they still waste memory...
11:54:17 <zbrown> sorear: meh, not a big deal, teacher asked for it that way
11:54:21 <zbrown> i know they're bad style
11:54:24 <zbrown> i prefer not to use them
11:54:27 <zbrown> but he wanted it that way
11:55:41 <kc5tja> Large fixed arrays are also expedient too, so that in most cases, you don't have to deal with manual memory management.
11:55:54 <kc5tja> "Just gimme a chunk of memory ``big enough''; I don't care how big."
11:56:08 <Philippa> can someone PM me xerox's email address?
11:57:21 <wolverian> 7msg Philippa xerox's email address?
11:57:23 <wolverian> oops
11:57:48 * Philippa slaps wolverian around a bit with a large trout
11:57:51 <tene> Heh.
11:58:30 <Philippa> got it now, cheers
11:58:38 <sorear> google++ darcs++
11:59:01 <sorear> apparently he left a _darcs/prefs/email file lying around in his bytestring parsec repo
11:59:56 <sorear> If you got two msgs, it's because I sent the first to 'philippa' and couldn't remember if irc was case sensitive.
12:01:48 <Cheery> what is this function's name?    \a k -> k (cos a) (sin a)
12:02:01 <sorear> continuation passing sincos
12:02:19 <sorear> @src Floating
12:02:20 <lambdabot> class  (Fractional a) => Floating a  where
12:02:20 <lambdabot>     pi                                                      :: a
12:02:20 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
12:02:20 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
12:02:20 <lambdabot>     (**), logBase                                           :: a -> a -> a
12:02:33 <sorear> mmh, no standard sincos
12:03:14 <sorear> why cps it?
12:04:13 <Cheery> cosine and sin appears so often together.
12:05:55 <Cheery> I've called it cossin this far, but I think that's stupid name.
12:06:15 <sorear> I've only seen it called sincos
12:06:25 <sorear> there's a libm function by that name
12:06:32 <sorear> and a x87 insn FSINCOS
12:08:01 <Cheery> practically thought, it takes an angle and turns it into coordinates in unit circle.
12:08:33 <sorear> exactly.  and the inverse of atan2 at that
12:08:40 <sorear> maybe it should be called tan2?
12:08:56 <sorear> or 2tan?
12:10:54 <dinounix> is there a way to use System.Console.Readline in hugs? i get an error when i try to import it
12:11:48 <Cheery> tan2 sounds neat.
12:12:09 <sorear> dinounix: you can't import modules at the hugs prompt
12:12:15 <sorear> dinounix: you need :also IIRC
12:12:29 <dinounix> i'm importing it in a file
12:13:00 <dinounix> it's saying that it can't find the imported module
12:13:00 <sorear> why hugs? :)
12:13:23 <sorear> works fine in ghci...
12:13:40 <dinounix> hmm, can i use haskell98 mode in ghci?
12:13:50 <sorear> dinounix: ?
12:13:54 <dinounix> no
12:14:01 <dinounix> i mean, haskell98 with extentions
12:14:09 <sorear> dinounix: ghci with no flags is pretty close to h98
12:14:14 <sorear> dinounix: -fglasgow-exts
12:14:20 <dinounix> thanks :)
12:14:25 <sorear> and you can change it at runtime
12:14:29 <sorear> :set -fglasgow-exts
12:14:37 <sorear> :set -fno-glasgow-exts
12:14:41 <sorear> try THAT in hugs :)
12:16:07 <dinounix> yay, my app compiled :D
12:16:51 <Cheery> ok, then, I've functions which convert between euclidean and polar coordinates.
12:17:28 <Cheery> currently called polarToXY and xyToPolar
12:17:50 <jdrake> Is there a way to make a pattern like previous:current:xs where you can cover the very first case where there is no previous element?
12:18:29 <chessguy> hey, can someone with LB ops have it join #FIGS please? i'm working on a haskell project there
12:18:30 <sorear> no
12:18:36 <sorear> @join #figs
12:18:36 <Cheery> fromPolar and fromEuclidean ?
12:18:39 <Lemmih> jdrake: say again?
12:18:39 <Cheery> :)
12:18:52 <chessguy> thanks
12:18:55 <Cheery> this sounds nice, doesn't it?
12:19:20 <zbrown> http://rafb.net/p/83cye249.html <-- sorear can you look at that and see whats goin on with my strcpy's at the end?
12:19:21 <lambdabot> Title: Nopaste - Issues with the for loop at the end?
12:20:05 <zbrown> Basically the issue is trying to print the enum types
12:20:38 <jdrake> Lemmih: I have a function I need to make - scanSum where it sums a list of integers, but does a running total. So [1,2,3] will return [1,3,6]. I am figuring I need a pattern like: previous:current:rest. But I can't seem to cover the case of when it first starts the function (so the first item is itself instead of previous)
12:20:56 <sorear> zbrown: those are correct looking
12:21:02 <zbrown> hmmm
12:21:25 <jdrake> I don't want the complete answer or anything, just sort of the thought process I am missing.
12:21:57 <sorear> > scanl1 (+) [1,2,3]
12:21:59 <lambdabot>  [1,3,6]
12:22:05 <psi> > scanl (+) 0 [1,2,3] -- just testing.
12:22:06 <sorear> jdrake: stop reinventing
12:22:06 <lambdabot>  [0,1,3,6]
12:22:09 <Lemmih> > scanl1 (+) [1,2,3]
12:22:10 <lambdabot>  [1,3,6]
12:22:28 <sorear> jdrake: pedagogy is ok, but if this is practical - it's unnecessary
12:22:32 <jdrake> sorear: I am doing some exercises on the wikibook.
12:22:32 <sorear> @src scanl1
12:22:33 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
12:22:34 <lambdabot> scanl1 _ []     =  []
12:24:03 <zbrown> sorear: kate has size       2.34 and is a ï¿½ï¿½D7ï¿½ <-- its givin me that output
12:24:25 <jdrake> With this:  scanl1 f (x:xs) =  scanl f x xs    What is the breakdown of the syntax on the right hand side? I am not completely sure what it is doing
12:24:25 <sorear> ooh, fun
12:24:33 <sorear> are you sure your case is complete
12:24:34 <sorear> ?
12:24:37 <zbrown> so im getting a random address space because it appears that "String temp;" is not ever being used
12:24:41 <zbrown> it should be...
12:25:04 <sorear> sounds like TheData[Index].Type isn't being initialized
12:25:20 <sorear> ftr, in C we usually prefer names like the_data[index].type
12:25:23 <zbrown> sorear: how would i input an enum type from the comman line?
12:25:24 <HairyDude> zbrown: you might want a \n on that printf... though I don't think that'll fix it
12:25:26 <jdrake> @src scanl
12:25:26 <lambdabot> scanl f q ls = q : case ls of
12:25:26 <lambdabot>     []   -> []
12:25:26 <lambdabot>     x:xs -> scanl f (f q x) xs
12:25:49 <psi> zbrown: temp instead of &temp?
12:25:50 <sorear> zbrown: haha found it
12:26:05 <zbrown> hmm?
12:26:13 <sorear> zbrown: your scanf is reading "%s" - ie a char * - into a int (enum) value
12:26:21 <sorear> zbrown: use -Wall -W -Werror, always
12:26:30 <sorear> zbrown: that would have been a compile error
12:26:33 <newsham> we're doing C?
12:26:35 <dmwit> > let evens [] = []; evens [x] = [x]; evens (x:y:rest) = x:evens rest in evens [0,1,2,3,4,5]
12:26:36 <lambdabot>  [0,2,4]
12:26:43 <zbrown> newsham: ##c is a crap place to ask questions
12:26:49 <zbrown> there are far more intelligent people here to ask
12:26:56 <zbrown> sorear: hmmm ok thanks
12:26:58 <dmwit> jdrake: You can certainly have (x:y:zs) in a function pattern match... see above.
12:27:11 <sorear> zbrown: so, you'll need to write a parser yourself.
12:27:14 <kilimanjaro> I know this isn't the right channel for this, but #haskell-soc seems pretty inactive. I wrote a summer of code proposal, I'd appreciate any comments I can get before I put it up on google. http://paste.lisp.org/display/38687
12:27:15 <HairyDude> typedef char String[MAX_STRING]; seems rather unwise to me
12:27:15 <sorear> zbrown: C is not haskell
12:27:22 <zbrown> sorear: lol
12:27:28 <sorear> zbrown: and does not support deriving(Read)
12:27:38 <sorear> zbrown: but I'm working on that!
12:27:47 <sorear> zbrown: where should I announce DrIFT for C?
12:27:53 <sorear> (once it works)
12:28:00 <zbrown> EVERYWHERE!
12:28:00 <zbrown> lol
12:28:21 <sorear> HairyDude: scrollback a few minutes
12:28:35 <sorear> <sorear> zbrown: while I'm at it, let me say large fixed size arrays are very
12:28:36 <sorear>          bad style                                                        [11:52]
12:29:03 <zbrown> HairyDude: was a requst from the professor
12:29:09 <newsham> answering C questions will only encourage more C questions.
12:29:14 <newsham> see also: #haskell-blah
12:29:53 <newsham> you can factor out perror(msg);exit(EXIT_FAILURE)
12:30:09 <newsham> you can even factor out the test.
12:30:22 <jdrake> sorear: What is wrong with reimplenting some of the basic functions of the language if it helps you understand how and why they work?
12:30:31 <sorear> jdrake: nothing
12:30:35 <HairyDude> ah I see, fair enough
12:30:50 <newsham> p = malloc(size); return dieUnless(p, "cannot malloc");
12:30:51 <sorear> jdrake: as I said, pedagogical reasons are fine.
12:31:02 <jdrake> sorear: I will have to get my dictionary for that one.
12:31:12 <dmwit> ?all-dict pedagogical
12:31:14 <lambdabot> *** "Pedagogical" gcide "The Collaborative International Dictionary of English v.0.48"
12:31:15 <lambdabot> Pedagogic \Ped`a*gog"ic\, Pedagogical \Ped`a*gog"ic*al\, a. [Gr.
12:31:15 <lambdabot>    paidagwgiko`s: cf. F. p['e]dagogique. See {Pedagogue}.]
12:31:15 <lambdabot>    Of or pertaining to a pedagogue; suited to, or characteristic
12:31:15 <lambdabot>    of, a pedagogue.
12:31:17 <lambdabot> [17 @more lines]
12:31:37 <newsham> you dont need to cast the return of Malloc.  void* will promote to other pointers
12:31:47 <vincenz> hah
12:31:49 <jdrake> heh, not quite useful :p
12:31:55 <jdrake> I understand though
12:32:15 <vincenz> isn't it great to have a language where unsafeCoerce is a std pattern?
12:32:29 <HairyDude> hehe
12:33:51 <Philippa> you mean where it infects the rest of your code? ;-)
12:34:14 <newsham> zbrown: why are you doing scanf("%s", &InputType); ?
12:34:33 <kc5tja> newsham: What C compiler do you use where void * auto-promotes?
12:34:45 <kc5tja> I've been using GCC for years, and Lattice C on the Amiga platform, and MSVC on Windows, and none of them do this.
12:34:51 <kc5tja> Not, at least, by defaut.
12:34:54 <kc5tja> default.
12:35:12 <newsham> kc5tja:   struct foo *x = malloc(sizeof *x); <- malloc's return type promoted to struct foo * automatically
12:35:13 <sorear> kc5tja: void auto-promotes in C, not C++
12:35:23 <dmwit> kc5tja: It's in the C standard...
12:35:46 <DRMacIver> Isn't C++ a conservative extension of C? So anything C does should be done in C++ as well...
12:35:59 <vincenz> DRMacIver: no, C++ is more strongly typed
12:36:08 <newsham> c++ needs to resolve overloading
12:36:21 <kc5tja> zzz.c: In function 'main':
12:36:21 <kc5tja> zzz.c:8: warning: incompatible implicit declaration of built-in function 'malloc'
12:36:27 <HairyDude> ObjC is a conservative extension of C
12:36:34 <sorear> kc5tja: #include <stdlib.h> :)
12:36:45 <newsham> #include <Prelude>
12:37:09 <DRMacIver> Hm. I stand corrected.
12:37:15 <kc5tja> So, interesting, all this time, it's because I wasn't including stdlib.h?
12:37:27 <kc5tja> Hell -- it is better to NOT include it then.
12:37:47 * kc5tja thinks auto-promotion of void*s is dangerous; I'd rather be explicit with a cast.  But that's a stylistic issue.
12:37:54 <newsham> scanf("%s", &InputType);    AnimalType InputType;  typedef enum { mammal, insect, bird, fish } AnimalType
12:37:57 <newsham> thats very un-%s
12:38:02 <kc5tja> Thanks for the tip; learn something new everyday.  :)
12:38:14 <pejo> kc5tja, the casts make the codea lot harder to read though. (and more verbose).
12:38:24 <Philippa> kc5tja: C++ doesn't do it automatically, FWIW
12:38:32 <newsham> kc5tja: when you dont include it you're not getting the type signature.
12:38:37 <newsham> naughty naughty
12:39:00 <kc5tja> pejo: Not really.
12:39:08 * kc5tja always factors out uses of malloc.
12:39:13 <dmwit> newsham: Isn't it a shame there's no deriving (Read) for enums in C? =P
12:39:23 <vincenz> http://www.typematrix.com/
12:39:24 <newsham> dmwit: no.
12:39:25 <lambdabot> Title: TypeMatrix Home Page*
12:39:31 <kc5tja> Foo* newFoo() { return (Foo*)(malloc(sizeof Foo)); }
12:39:48 <HairyDude> ah, OO C
12:40:49 <kc5tja> HairyDude: Yup.  Actually, I should have named that allocFoo() instead, since I'll often invoke something like:  aFoo = initFoo(allocFoo());
12:41:10 <kc5tja> And if that is used quite often, I'll write newFoo() to abstract even that out.
12:41:40 <kc5tja> Basic Smalltalk-like convention.  It makes absolutely perfect sense.
12:41:56 <newsham> if you need that many levels of abstraction, you probably shouldnt be coding it in C
12:42:18 <dmwit> Okay, fair enough.
12:42:18 <kc5tja> newsham: If you don't use that many levels of abstraction, you probably shouldn't be coding in C.
12:42:27 <kc5tja> Or at all, for that matter.
12:42:27 <HairyDude> Smalltalk-like? does Smalltalk really make you go that far down?
12:42:54 <kc5tja> HairyDude: I don't understand your question?
12:42:55 <sorear> dmwit: Right now, I'm coding a deriving engine for C.
12:43:02 <jdrake> diff x:y:[] = [y - x]
12:43:09 <HairyDude> as in, make you allocate stuff explicitly
12:43:09 <jdrake> What is wrong with that pattern?
12:43:17 <dmwit> jdrake: diff (x:y:[]) = [y - x]
12:43:21 <sorear> jdrake: precedence
12:43:26 <sorear> jcreigh: it's parsed as
12:43:32 <sorear> (diff x):y:[] = [y - x]
12:43:34 <kc5tja> HairyDude: Smalltalk doesn't directly expose a malloc-line function, but you DO still have to allocate objects when needed.
12:43:38 <sorear> and that just won't do
12:43:48 <newsham> hey jdrake
12:43:55 <jdrake> newsham: hola
12:43:56 <HairyDude> right
12:44:03 <sorear> kc5tja: Even haskell makes you allocate objects.   (2,2)
12:44:28 <newsham> josh: what are you trying to do?
12:44:38 <HairyDude> suppose ObjC is fairly similar, the only difference being that you get malloc if you want it, but you can always fall back on NSObject's alloc method
12:44:43 <kc5tja> HairyDude: And since there are a myriad ways of initializing the state of an object, the act of creating a new object (s <- someClass alloc.) is distinct from its initialization (s <- someClass alloc initWith: x and: y.)
12:45:04 <kc5tja> HairyDude: Objective C is, for all intents and purposes, Smalltalk's runtime grafted into C.
12:45:49 <jdrake> newsham: I am following some of the exercises on the wikibook. Specifically right now doing 'diff', where it returns a list of differences between a list of integer items.
12:46:23 <newsham> what is    diff [1,2,3,4,5] supposed to do?
12:46:34 <dmwit> jdrake: take a look at "tail" and "zip". ;-)
12:46:37 <HairyDude> sorear: the difference there is there's no (m)alloc, you just mention a constructor and it does its magic
12:46:42 <jdrake> [1,1,1,1]
12:46:54 <newsham> you might be interested in zip and zipWith
12:46:58 <newsham> ?src zipWith
12:46:58 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:46:58 <lambdabot> zipWith _ _      _      = []
12:47:10 <HairyDude> zipWith is great
12:47:18 <jdrake> I have already done the zip function a day or two ago
12:47:29 <chessguy> sorear: thanks
12:47:39 <jdrake> My biggest revelation today has been how to do dropInt (drops n items from the list)
12:47:41 <newsham> jdrake: thikn of how to difference adjacent values using zip
12:48:02 <newsham> tail (mentioned by dmwit) is related to drop
12:48:04 <newsham> ?src tail
12:48:04 <lambdabot> tail (_:xs) = xs
12:48:05 <lambdabot> tail []     = undefined
12:48:55 <HairyDude> where does that def come from?
12:48:59 <newsham> > let xs = [1..5] in zip (xs, tail xs)
12:49:00 <lambdabot>  Couldn't match expected type `[a]' against inferred type `(a1, b)'
12:49:12 <newsham> > let xs = [1..5] in zip xs (tail xs)
12:49:13 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
12:49:15 <hpaste>  jdrake pasted "My current non-working model" at http://hpaste.org/1129
12:49:16 <newsham> in C mode now :)
12:49:39 <ClaudiusMinimus> is there a tarball of hs-plugins that works with ghc-6.6?  if not, what darcs command should i run?
12:49:46 <sorear> get
12:49:51 <jdrake> I see how that could work
12:50:07 <newsham> jdrake: you should use zero as your base case instead of one
12:50:11 <sorear> @where hs-plugins
12:50:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
12:50:21 <sorear> ClaudiusMinimus: the darcs command you want is 'get'
12:50:22 <sorear> :)
12:50:24 <HairyDude> mmm, explicit recursion :)
12:50:26 <dmwit> jdrake: You can make your solution work, but you need one more pattern match.
12:50:38 <jdrake> newsham: Referring to dropInt?
12:50:46 <newsham> both dropInt and takeInt
12:50:53 <dmwit> jdrake: But, even if you do get it, you should really try to work out the solution that doesn't use pattern matching at all.
12:51:21 <newsham> your patterns for diff match [], [1,2], and [1,2,....]   but what about [1] ?
12:51:40 <dmwit> jdrake: Look again at the precedence rules that somebody gives above, too, because they apply in the function body as well as in pattern matching.
12:51:47 <ClaudiusMinimus> sorear: thanks, was looking more for a complete command line (never used darcs yet)
12:52:17 <jdrake> dmwit: The latter part of takeInt by chance?
12:52:35 <dmwit> jdrake: I think the very last line you have confuses the order things will happen.
12:52:49 <newsham> example:  diff (1:2:3:[]) = (2-1) : (diff 2:3:[]) = (2-1) : ((3-2) : (diff 3:[]))
12:52:52 <sorear> http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-1.html#node_sec_1
12:52:54 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules, http://tinyurl.com/2gbcwr
12:52:55 <newsham> what's  diff (3:[]) ?
12:53:00 <sorear>      * Darcs repository of the latest code:
12:53:00 <sorear>        darcs get --set-scripts-executable http://www.cse.unsw.edu.au/~dons/code/hs-plugins
12:53:01 <lambdabot> Title: Index of /~dons/code/hs-plugins
12:53:12 <ClaudiusMinimus> sorear: ok, thanks, just found that page :)
12:53:12 <dmwit> newsham: Look again, your expansion doesn't follow his definition. ;-)
12:53:19 <dmwit> His definition doesn't type check.
12:53:19 <newsham> yah, sorry, i'm being sloppy
12:53:22 <jdrake> Now x:xs would override x:y:xs correct?
12:53:33 <newsham> beware that   "func x:xs" ->  (func x) : xs
12:54:10 <sorear> haskell's precedence rules should be spacing sensitive
12:54:18 <jdrake> I tried ocaml back a few years ago, so I might be partially tainted
12:54:23 <newsham> sorear:  great idea!!!! (sarcasm)
12:54:35 * HairyDude suspects diff could be done non-recursively with a fold
12:54:39 <newsham> jdrake: when you recursively call diff in the last line, you're calling diff on y
12:54:42 <newsham> not on y:xs
12:54:57 <newsham> you want:    (y-x) : diff (y:xs)
12:55:20 <sorear> HairyDude: *everything* can
12:55:22 <newsham> that parses as   (y-x) : (diff (y:xs))
12:55:24 <jdrake> Does haskell have a block comment I can just play around without having trouble when :r?
12:55:33 <newsham> {- ... -}
12:55:35 <jdrake> (y-x) being a pattern?
12:55:55 <HairyDude> it's an expression here
12:56:21 <HairyDude> it would only be a pattern if (-) was a data constructor.
12:56:23 <jdrake> oh, sorry I didn't update the paste, I do have (diff y:xs) currently
12:56:35 <newsham> yah, thats wrong
12:56:36 <dmwit> jdrake: That's a bug.
12:56:38 <newsham> diff (y:xs)
12:56:38 <sorear> == ((diff y) : xs)
12:57:03 <hpaste>  jdrake pasted "current diff" at http://hpaste.org/1130
12:57:15 <sorear> we need -Wwarn-inconsistent-spacign
12:57:21 <newsham> > let (y:xs) = [1,2,3] in (*2) x : xs
12:57:22 <lambdabot>   Not in scope: `x'
12:57:26 <newsham> > let (y:xs) = [1,2,3] in (*2) y : xs
12:57:28 <lambdabot>  [2,2,3]
12:57:48 <HairyDude> -Wtypo would be nice too :)
12:58:09 <newsham> > let (y:xs) = [1,2,3] in  map (*2) (y : xs)
12:58:11 <lambdabot>  [2,4,6]
12:58:23 <dmwit> jdrake: (:) binds less tightly than function application, so your code evaluates (diff y) first, and then (: xs) afterwards.
12:58:36 <sorear> I'd like -Wprogrammer-errors
12:58:49 <HairyDude> alas, that would require solving the halting problem
12:58:51 <dmwit> (But (diff y) doesn't make sense, because y is not a list.)
12:58:59 <newsham> -Wnot-verified
12:59:13 <jdrake> dmwit: note the "current diff" paste @ http://hpaste.org/1130
12:59:18 <sorear> HairyDude: no, it would require only a solution to the RYM problem
12:59:24 <dmwit> jdrake: My comment still applies!
12:59:30 <HairyDude> not familiar with that
12:59:30 <jdrake> hmm?
12:59:33 <newsham> jdrake: in paste 1130 its wrong.
12:59:40 <dmwit> Look at the very last line...
12:59:43 <newsham> (diff y:xs) ->    ((diff y) : xs)
12:59:44 <sorear> @google intercal rym
12:59:47 <lambdabot> http://www.catb.org/~esr/intercal/paper.html
12:59:47 <lambdabot> Title: Abstraction and Modularity in INTERCAL
12:59:48 <newsham> which is a type error
12:59:48 <sorear> hello ndm!
12:59:57 <dmwit> On the far right...
12:59:57 <jdrake> oh
13:00:05 <newsham> jdrake: ps, you can annotate existing pastes by clicking "annotate"
13:00:05 <ndm> hi sorear
13:00:08 <sorear> HairyDude: google got the right ref
13:00:10 <newsham> you dont need to start a new one
13:00:24 <jdrake> Sorry, I am trying to look at my code and trying to differentiate between 3 different people saying things
13:00:47 <ndm> @seen hyrax42
13:00:48 <lambdabot> hyrax42 is in #haskell-blah and #haskell. I don't know when hyrax42 last spoke.
13:00:48 <dmwit> Heh, yeah, that's tough. =P
13:01:05 <newsham> #haskell's flaw -- too many good people helping out!
13:01:20 <newsham> this problem is far less well understood than the problem facing many channels
13:01:33 <sorear> Ok, everyone whose name starts with an even numbered letter move to #haskelm
13:01:57 <dmwit> sorear: Is 'a' even or odd?
13:02:03 <sorear> odd
13:02:03 <newsham> jdrake: what happens when you run   "diff [1,2]" ?
13:02:15 <ndm> > even $ ord 'a'
13:02:17 <lambdabot>  False
13:02:18 <Heffalump> surname or given name or nickname?
13:02:31 <dmwit> This problem is underspecified!
13:02:31 <jdrake> I am thinking it should be the same as  diff (x:y:[]) because it is the same as two numbers prepended onto an empty list
13:02:31 <sorear> uh ... uh ... uh...
13:02:45 <dmwit> I say, everybody flip a coin.  If it comes up heads, move to #haskelm. =)
13:02:47 <HairyDude> ah yes, you're right
13:02:48 <newsham> ndm: what about other character sets?
13:02:50 <Heffalump> dmwit: I think you mean this solution is underspecified.
13:02:59 <Heffalump> dmwit: what currency and what denomination?
13:03:01 <newsham> jdrake: right, ok, now what happens with    diff (1:2:[]) ?
13:03:03 <newsham> trace it through
13:03:08 <dmwit> Heffalump: doesn't matter!
13:03:23 <dmwit> Any coin with a 50% chance of coming up heads will do.
13:03:30 <jdrake> (y-x), there is no recursion in this case
13:03:31 <Heffalump> how do I verify that about the coin?
13:03:36 <dmwit> You can even define a die to come up heads if its pips are even!
13:03:43 <dmwit> Heffalump: Ah, now that's a harder question...
13:03:48 <newsham> oops, i'm sorry, i meant what if it was   diff (1:2:3:[])
13:04:11 <newsham> eek, nevermind
13:04:12 <newsham> i'm dumb
13:04:28 <HairyDude> what about coins that don't have a head on either side? like euro coins?
13:04:46 <dmwit> All a matter of definition, really.
13:04:51 <hpaste>  jdrake annotated "current diff" with "works now" at http://hpaste.org/1130#a1
13:05:09 <jdrake> This hurts my head :p
13:05:14 <norpan> i have never seen a coin with a tail on it
13:05:16 <newsham> jdrake: cool.  now another thing: you dont need parens around the diff call
13:05:16 <jdrake> I appreciate everything :-)
13:05:33 <newsham> because:   (y-x) : (diff y:xs))  is    (y-x) : diff (y:xs)
13:05:43 <newsham> also you can write the rules using list notation if you like:
13:05:44 <HairyDude> norpan: there are probably some east asian ones with monkeys on them :)
13:05:49 <newsham> diff [x,y] = [y-x]
13:05:51 <dmwit> norpan: I never mentioned tails... ;-)
13:05:53 <HairyDude> or african
13:06:28 <HairyDude> aha. one of my pound coins has the Three Lions on it. that's three tails right there :)
13:06:33 <jdrake> newsham: oh you can use [x,y] in a pattern?
13:06:44 <jdrake> Must be an ocaml thing I remembered when doing this
13:06:56 <newsham> > let diff [x,y] = [y-x] in diff [3,6]
13:06:57 <lambdabot>  [3]
13:07:00 <Philippa> HairyDude: bet you don't have one with vindaloo on it though
13:07:18 <jcreigh> all sarcasm aside, how *would* you verify that a coin will come up heads (or side A, if you prefer) about half the time? Just by flipping 1000 times, and noting that it was heads 513 (or whatever) times?
13:07:20 <norpan> on the euro the national side is the "heads" side
13:07:27 <jdrake> ok, what is the best way of signalling an error on the case of [x]?
13:07:28 <HairyDude> Philippa: easy enough to arrange, just be clumsy in an Indian restaurant :)
13:07:29 <jcreigh> that doesn't really "prove" anything
13:07:39 <dmwit> jcreigh: Physics.
13:07:55 <Heffalump> I'm not sure how Physics would help.
13:08:04 <dmwit> Actually, a guy recently proved that it comes up heads about 5001/10000 times on average.
13:08:09 <merus> @src replicateM
13:08:10 <lambdabot> replicateM n x = sequence (replicate n x)
13:08:17 <jcreigh> dmwit: link?
13:08:25 <dmwit> Err... and they defined "heads" to be the same side as was on top when you flipped it.
13:08:27 <Heffalump> where is the original source of randomness?
13:08:31 <jcreigh> dmwit: oh, okay
13:08:37 <dmwit> jcreigh: I've been searching for the link since the conversation started... =(
13:08:38 <jcreigh> I could almost believe that
13:08:43 <newsham> jcreigh: first i'd start with an academic paper search on randomness measurement
13:08:47 <jcreigh> heh.
13:08:56 <HairyDude> dmwit: I should think that's highly currency/denomination dependent
13:09:03 <newsham> there's a lot more to measure than just the number of outcomes that are heads.
13:09:17 * dmwit doesn't remember all the details of the research
13:09:25 <jcreigh> newsham: oh! you're right. it would be odd if the first 5000 were heads and the last 5000 were tails, for example.
13:09:57 <ndm> sorear, did you manage to compile my tex document?
13:10:04 <newsham> or if it was alternating heads/tails/heads/tails
13:10:07 <sorear> ndm: nope
13:10:32 <dmwit> Ah, the key search term is "Diaconis", the name of the guy who was working on it.
13:10:35 <sorear> ndm: I have no clue about all this CTAN stuff... and I don't have any part of miktex
13:10:44 <dmwit> For example, http://www.npr.org/templates/story/story.php?storyId=1697475
13:10:46 <lambdabot> Title: NPR : The Not So Random Coin Toss
13:10:47 <ndm> sorear, do you want a copy of it? i'm going to send off to the people who requested it tonight
13:10:52 <Lamperi> tonighy
13:10:57 <newsham> jdrake: are you sure diff [1] is an error?
13:10:59 <sorear> ndm: no, I already read it
13:11:01 <newsham> maybe diff [1] is []
13:11:12 <sorear> ndm: the maths was a little hard to read, but I managed
13:11:24 <HairyDude> diff [1] would cause a pattern match failure
13:11:27 <ndm> sorear, i don't have a clue either - with my tex editor i just click a button
13:11:27 <sorear> ndm: (it == the source file)
13:11:35 <newsham> > let xs = [1,3,2,65,3,4] in zipWith (-) xs (tail xs)
13:11:37 <lambdabot>  [-2,1,-63,62,-1]
13:11:40 <ndm> i'm impressed, and slightly scared :)
13:11:50 <newsham> > let xs = [1] in zipWith (-) xs (tail xs)
13:11:51 <lambdabot>  []
13:12:17 <jdrake> newsham: the diff is defined to be the difference between two or more items in a list. How can there be a difference with a single item?
13:12:20 <sorear> CTAN. CPAN. Gems. Hackage.
13:12:20 <HairyDude> > let xs = [] in zipWith (-) xs (tail xs)
13:12:22 <lambdabot>  []
13:12:24 <newsham> jdrake: if you want to you can use   error "string msg"
13:12:28 <HairyDude> yay for non-strictness
13:12:33 <dmwit> jdrake: How can there be a difference of an empty list?
13:12:39 <sorear> All these 3rd-party pms need to be integrated with apt.
13:12:58 <newsham> jdrake: by observing that diff always returns a list that is one shorter than the input list
13:13:02 <jdrake> dmwit: It good point, when there doesn't need to be there to be an ending case
13:13:11 <newsham> that might be a useful property to preserve
13:13:14 <DukeDave> sorear, that always annoys me too :(
13:13:20 <newsham> > let xs = [] in zipWith (-) xs (tail xs)
13:13:21 <lambdabot>  []
13:13:35 <newsham> of course that breaks it (unless you consider pred 0 to be 0)
13:13:35 <jdrake> perhaps, but could it also not generate a hard to find error in the future?
13:13:38 <dmwit> jdrake: If you have the pattery [x, y] as an ending case, you don't also need [] as an ending case.
13:13:55 <newsham> > let diff [x] = error "I can't diff a single item list!" in diff [3]
13:13:56 <lambdabot>  Exception: I can't diff a single item list!
13:14:21 <ndm> sorear, you can't get much better than Miktex+CTAN, i wish hackage+cabal was as good
13:14:27 <DukeDave> Is anyone available for 5mins to talk through the design of an (exciting!) robot controller with me? :)
13:14:58 <jcreigh> in general, if you think that something is impossible, it's a good idea to have your program give a sensible error message if it does happen.
13:14:59 * HairyDude dislikes language-specific package managers
13:15:17 <jdrake> Would it be kosher to put a _ case at the end with an error statement?
13:15:19 <Cheery> hmm, I think I may end up having some useful toy combinators.
13:15:29 <Cheery> I shall call them GUC - game utility combinators. :)
13:15:31 <sjanssen> jdrake: yes, that's fine
13:15:37 <newsham> diff _ = error "unhandled case!"
13:15:46 * sorear wishes there was a working Apt-Hackage gateway
13:15:51 <sjanssen> jdrake: the compiler automatically generates such an error message anyway
13:15:59 * HairyDude likes the name "impossible" for error-handling functions :)
13:16:00 <sorear> then, I'll extend it to handle CPAN, CTAN, and Gems
13:16:01 <newsham> in a way, the system already does that for you, but with a less informative error message
13:16:20 <jdrake> It might be useful to express that you can't do it with a specific kind of list.
13:16:24 <jcreigh> alias user-cabal-install='runghc Setup configure --user --prefix=$HOME; runghc Setup build; runghc Setup install'
13:16:42 <sjanssen> newsham: the compiler's error message is more informative than "unhandled case!"
13:16:53 <sjanssen> ghc generates line number info and such
13:16:57 <sorear> jcreigh: (a) that's wrong (b) scripts are better for args and whatnot
13:16:59 <HairyDude> jcreigh: I'd replace the semicolons with &&, personally
13:17:07 <newsham> sjanssen: thbbttt!
13:17:08 <jcreigh> sorear: wrong?
13:17:17 <sorear> jcreigh: --user needs to go with install, not configure
13:17:24 <sorear> jcreigh: --prefix stays with configure
13:17:31 <jdrake> Are there any more practical (rather than small exercises) exercises that might be useful to try?
13:17:39 <HairyDude> umm, I did exactly those several times today and it worked fine
13:17:43 <jcreigh> sorear: err...works fine for me.
13:17:54 <sorear> jdrake: Write a computer algebra system?
13:17:55 <waern> how do I turn an .lhs into an .hs?
13:18:02 <sorear> waern: unlit
13:18:05 <jcreigh> HairyDude: but good point, && might be a better choice there.
13:18:08 <newsham> jdrake: I like "two dozen short lessons" as an intro.  its exercise oriented, but still kinda simple exercises
13:18:11 <sorear> waern: should be in /usr/lib/ghc*
13:18:16 <waern> sorear, thanks
13:18:16 <jdrake> sorear: Not quite
13:18:19 <newsham> but probably more realistic than "diff items in a list"
13:18:27 <newsham> ?google two dozen haskell
13:18:31 <lambdabot> http://www.cs.ou.edu/cs1323h/textbook/haskell.shtml
13:18:31 <lambdabot> Title: Two Dozen Short Lessons in Haskell
13:18:34 <jcreigh> sorear: --user                          allow dependencies to be satisfied from the user package database. also implies install --user
13:18:36 <dmwit> jdrake: http://community.moertel.com/ss/space/Programming+Fun+Challenge
13:18:43 <jcreigh> sorear: ^^ from runghc Setup configure --help
13:18:57 <HairyDude> sed '/^>/!d;s/^> //' works :)
13:18:57 <sorear> jcreigh: beh.  Why must they keep adding these NEW FEATURES? :)
13:19:13 <jcreigh> heh
13:19:32 <sorear> ndm: has the catch paper changed enought that I shoudl reread it?
13:19:46 <ndm> soear, when did you read it?
13:19:51 <jdrake> dmwit: Thank you!
13:20:03 <dmwit> ?wiki 99_Haskell_exercises
13:20:04 <lambdabot> http://www.haskell.org/haskellwiki/99_Haskell_exercises
13:20:07 <jdrake> sorear: How hard would it be to write CAS in haskell?
13:20:10 <sorear> ndm: a week or so ago
13:20:29 <ndm> soear, its now clearer - but has no new content - apart from the HsColour and FilePath results
13:20:34 <ClaudiusMinimus> @where fptools
13:20:34 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
13:20:35 <sorear> jdrake: depends on how good you want it to be.  Symbolic differentiation took me about an hour
13:20:37 <mgsloan> once you got over the matrix stuff, CAs would probably be pretty easy
13:20:38 <dmwit> jdrake: Not too bad.  You can start pretty simple and work your way up.
13:20:50 <ndm> sorear, those are in the results section and are quite short, but nice results
13:20:55 <mgsloan> ah, CAS is probably something totally different..
13:21:16 <jdrake> I had a thought to try a simple one in C a few weeks ago. Threw out the idea.
13:21:20 <sorear> ClaudiusMinimus: fptools is pure evil
13:21:47 <sorear> ClaudiusMinimus: use cabal for anything other than the one program that uses it for legacy reasons (GHC)
13:21:50 * mgsloan just realized that L-systems are a type of 1-dimensional CA
13:21:53 * HairyDude likes pure evil, so much better than side-effect-happy evil
13:22:12 <dmwit> jdrake: The lessons here have some hints about how to make it easier (don't remember which unit):
13:22:14 * mgsloan qualifies this realization with "well, sorta..." if you have a funky concept of cells
13:22:16 <dmwit> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/external.html
13:22:18 <lambdabot> Title: Programming in Haskell, http://tinyurl.com/fan47
13:22:26 <jdrake> Problem with that 99 questions thing - the answers are right there
13:23:12 <dmwit> Heh, sorry.
13:23:24 <ClaudiusMinimus> sorear: ok, i'm configuring lambdabot (primarily for local use), and the Config.hs mentions it...
13:24:51 <newsham> ?where ghc-api
13:24:52 <lambdabot> http://www.haskell.org/ghc/
13:25:39 <sorear> ClaudiusMinimus: huh?
13:25:55 <sorear> ClaudiusMinimus: Config.hs doesn't have any fptools reference
13:26:17 <sorear> ClaudiusMinimus: are you talking about cabal's verbose list of tools you neither have nor need?
13:26:30 <hyrax42> ?seen ndm
13:26:31 <lambdabot> ndm is in #haskell. I last heard ndm speak 5m 40s ago.
13:26:48 <ClaudiusMinimus> sorear: it does here: Config.hs config = Config {... fptoolsPath = "..."
13:27:14 <sorear> ClaudiusMinimus: ah.  that's pretty much obslete
13:27:29 <ClaudiusMinimus> sorear: ok
13:27:31 <sorear> ClaudiusMinimus: I believe at one time there was a plugin to print a random line of code from ghc
13:27:48 <sorear> ClaudiusMinimus: but to the best of my knowledge that config field is no longer used
13:28:41 * sorear finds himself wondering what, if any, the relation is between ClaudiusMinimus and ClaudiusMaximus
13:29:04 <ClaudiusMinimus> sorear: same person, two machines next to each other
13:33:36 <matthew-_> Announce: Text.HTML.Chunks: statically safe templates: http://www.wellquite.org/chunks/
13:33:38 <lambdabot> Title: Well quite! » Chunks
13:33:45 <matthew-_> any feedback greatfully received ;-)
13:35:23 <sorear> matthew-_: send an announce message to haskell@haskell.org, cc dons@cse.unsw.edu.au, and @tell dons to add it to hackage
13:36:47 <sorear> that said, most of us can template just fine using xhtml ... I'll have to look at your lib to see what the cool new ideas are
13:39:58 <DRMacIver> Statically typed templates sound like they're taking things a bit too far. :)
13:40:01 <Philippa> sorear: do the existing XHTML libs load comments in okay, then?
13:40:08 <HairyDude> hrm, the CGI library segfaults as soon as I try to do any output with it
13:40:25 <Philippa> DRMacIver: I disagree, it's potentially a good way to verify that the template actually takes the right info
13:41:12 <DRMacIver> Hm. I guess.
13:46:05 <hpaste>  HairyDude pasted "ghci segfault on Network.CGI" at http://hpaste.org/1131
13:46:44 <Cale> HairyDude: whoa, that's broken
13:46:49 * matthew-_ growls at his current highly annoying connection...
13:47:35 <jcreigh> that's the nice thing about segfaults...you don't have to wonder, "is this a bug?"
13:47:43 <jcreigh> it's *always* a bug
13:48:37 <Cale> Pretty much.
13:48:37 <ndm> Haskell pattern matchs are like our equivalent
13:49:06 <sorear> matthew-_: is your blog supposed to moderate replies?  I can't see mine.
13:49:13 <matthew-_> sorear: yep
13:49:15 <jcreigh> ha!
13:49:27 <matthew-_> sorear: I get spammed to death otherwise :'(
13:49:38 * jcreigh fixed a xinerama focus bug in xmonad that had been evading him for a while.
13:50:06 * sorear cheers
13:50:31 <jcreigh> as always, a 30-second fix once I figured out what was going on.
13:50:34 <matthew-_> sorear: there you go, thanks for the comment ;-)
13:51:32 <matthew-_> right, there are a couple of bugs I've found today. The first is that haddock can't parse .hs files that use -fth with the [| ... |] syntax. This is a bit of a pain. Is this known?
13:52:15 <Igloo> Yes
13:52:15 <HairyDude> .e gets the ghc source and proceeds to compile it
13:52:23 <HairyDude> oops, wrong talker
13:52:34 <sorear> matthew-_: you want haddock.ghc
13:52:39 <sorear> @where haddock-ghc
13:52:40 <lambdabot> http://darcs.haskell.org/SoC/haddock.ghc
13:52:56 <matthew-_> ahh, woot. ok, I'll look into that
13:53:22 <sorear> matthew-_: it put up a good fight the last time I tried to compile it - be ready
13:53:52 <matthew-_> the other is an issue with -Wall. If you have pattern matches in a guard and -Wall turned on then you get wrong warnings: eg let x = Just 3 in case x of n | (Just a) <- n -> True
13:54:25 <sorear> well, just so you know patterns in guards are a ghc extension
13:54:33 <matthew-_> that will complain (at least if you use a function and not a case - f x | (Just a) <- x = True of a missing case...
13:54:41 <sorear> also, that case IS incomplete (without knowing the value of x)
13:55:03 <matthew-_> sorear: ok, sorry, I meant if you have all the cases. hang on... hpaste
13:55:05 <matthew-_> @hpaste
13:55:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:55:25 <sorear> if you aren't satisfied with complete cases, get in touch with ndm
13:56:16 <sorear> his PhD topic is an automated checker that can propagate conditions around every which way, and is **much** more effective than -Wall
13:56:28 <sorear> warning, alpha is an understatement
13:56:33 <sorear> @where catch
13:56:34 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
13:58:15 <hpaste>  matthew-_ pasted "unnecessary warning?" at http://hpaste.org/1132
13:59:34 <HairyDude> it might indicate a typo, I think
14:00:36 <sorear> matthew-_: what you want ghc to do is documented as basically impossible
14:00:59 <sorear> matthew-_: ghc can't examine the code of guards, halting problem and all that fun stuff
14:01:32 <sorear> matthew-_: in this case you don't want pattern guards, just pattern match directlyJ
14:01:41 <sorear> (I hope that was a simplified example)
14:01:55 <norpan> so if it can't do the analysis, why warn that the matches are non-exhaustive
14:02:13 <jcreigh> norpan: because they might be?
14:02:25 <norpan> or they might not
14:03:03 <Igloo> Am I going mad or should http://urchin.earth.li/~ian/def.hs be a good module, with the type of def being defaulted?
14:03:11 <norpan> it's like giving a warning: "the program might not halt"
14:03:21 <hpaste>  mux pasted "maybeM" at http://hpaste.org/1133
14:03:42 <mux> I believe I'm reinventing wheel here, does anyone know if that's indeed the case?
14:04:04 <mux> I don't get exactly what I need when I try to use liftM? maybe
14:05:05 <norpan> mux: is that not just the "maybe" function
14:05:10 <dolio> ?type maybe
14:05:12 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:05:42 <mux> maybe doesn't allow monadic actions
14:05:52 <dolio> Yeah, maybe with b = mb, no?
14:05:56 <sorear> Igloo: I can't load the page :/
14:05:56 <sorear> at least, it's going very very very slow
14:05:59 <sorear> er, gah
14:06:00 <sorear> @botsnack
14:06:01 <lambdabot> :)
14:06:02 <sorear> oh joy
14:06:03 <HairyDude> b = m b rather
14:06:05 <sorear> @karma- lag
14:06:05 <lambdabot> lag's karma lowered to -7.
14:06:09 <sorear> matthew-_: you don't need pattern guards for the functions in Parser.hs
14:06:13 <sorear> finally!
14:06:17 <sorear> Igloo: you're going mad
14:06:25 <mux> what's 'funny' is that the actual source of maybeM is indeed the very same as maybe
14:06:28 <Igloo> sorear: Why?
14:06:38 <sorear>      * all of these classes are defined in the Prelude or a standard library (Figures 6.2--6.3, pages -- show the numeric
14:06:39 <sorear>        classes, and Figure 6.1, page , shows the classes defined in the Prelude.)
14:06:40 <mux> but I suppose the type annotate helps make it behave like I want
14:06:40 <norpan> mux: they are the same
14:06:48 <mux> annotation
14:06:49 <sorear> Def isn't defined in the prelude.
14:07:02 <Igloo> sorear: But if you have Def then you have Num
14:07:12 <mux> norpan: yeah, that's what I just said, but I don't think I could use maybe here because of the type signature, could I?
14:07:14 <hpaste>  Igloo pasted "def.hs, for those for whom urchin is slow" at http://hpaste.org/1134
14:07:31 <norpan> mux: maybe has a more general type signature, so just use that one instead
14:07:32 <sorear> Igloo: my whole connection stoped working
14:07:44 <dolio> > maybe (return 2) return (Just 3) :: [Int]
14:07:45 <lambdabot>  [3]
14:07:53 <dolio> > maybe (return 2) return (Nothing) :: [Int]
14:07:54 <norpan> b means "any type you want", in your case (m b)
14:07:55 <lambdabot>  [2]
14:07:55 <mux> oh
14:08:00 <sorear> Igloo: the defaulting rule uses a three way conjunction
14:08:08 <mux> thanks
14:08:24 <sorear> Igloo: sure, at least one of the involved classes (Num) is a Num nonstrict subclass
14:08:29 <Igloo> sorear: 4.3.4 in the report says "each ti must be a type for which Num ti holds"
14:08:34 <sorear> Igloo: but you don't meet pasted clause C
14:08:35 <Igloo> sorear: If Def t holds then Num t holds
14:08:40 <mux> I guess I could use
14:09:11 <Igloo> Oh, I'm reading the wrong bit
14:09:15 * Igloo goes to read the right bit
14:09:18 <mux> maybeM_ m f = maybe (return ()) f m
14:09:22 <HairyDude> is it possible to tell darcs to use gzip or something?
14:09:35 <HairyDude> to make transfer a bit less horribly slow
14:09:48 <sorear> darcs optimize --compress
14:09:56 <sorear> on the server repo
14:10:01 <jcreigh> oh, somebody posted xmonad to reddit
14:10:05 <Igloo> Ah, hmm, OK
14:10:19 <jcreigh> hmm, we're not quite under 400 LOC anymore :)
14:10:24 <Igloo> sorear: Ta
14:10:33 <sorear> .li eh?
14:10:45 <HairyDude> ah, you can't tell it to get ghc from the official darcs repo using compression then?
14:10:51 <sorear> don't see many of them around here :)
14:11:02 <sorear> HairyDude: it does use compression for ghc
14:11:13 <HairyDude> oh ok, so it's already going as fast as it can :)
14:11:14 <sorear> HairyDude: it just doesn't use http/1.1 pipelining
14:11:19 <HairyDude> aaah
14:11:22 <sorear> HairyDude: and that *kills* performance
14:11:34 <sorear> HairyDude: can you take a 28mby 7zip file?
14:11:43 <jcreigh> oh, darcs opens up a new HTTP connection for every patch?
14:11:48 <HairyDude> a new connect for each patch, ouch :)
14:12:05 <HairyDude> sorear: yeah
14:12:11 <HairyDude> I think
14:13:39 <sorear> uploading...
14:14:17 <sorear> tcp        0 112944 192.168.1.101:50505     68.99.123.140:ftp-data  ESTABLISHED -- lookie at the sendq!
14:14:22 <HairyDude> ah, it says to use --partial, I didn't see that
14:14:50 <sorear> HairyDude: that will speed it a little, not a huge amount
14:15:14 <dmwit> > ord '1'
14:15:15 <lambdabot>  49
14:16:25 <matthew_> sorear: yep, I agree wrt pattern guards, it seems to be quite comfortable to use them where they're not really necessary...
14:16:55 <jcreigh> @seen dons
14:16:56 <lambdabot> dons is in #haskell and #haskell-overflow. I don't know when dons last spoke.
14:17:23 <ehird> heh: "On a warm Saturday afternoon, sitting by the pool with a margarita, you casually sit up from your chaise lounge chair, reach over and pick up a gun, aim at your foot, and lazily pull the trigger. "
14:18:07 <sorear> The bullet is not fired until ten minutes later when you lean forward to examine the hole.
14:18:28 <jcreigh> ???
14:18:57 <hpaste>  Igloo pasted "def2" at http://hpaste.org/1135
14:18:59 <ehird> jcreigh: how to shoot yourself in the foot... with haskell
14:19:04 <Igloo> sorear: OK, what's wrong with def2 then?
14:19:08 <jcreigh> ah, okay
14:19:18 <sorear> HairyDude: hmm, my upload speed is a lot slower than I realised it was.  you're probably better off downloading it yourself --partially
14:19:35 <HairyDude> sorear: not a huge amount?! it just took me about 20 minutes to get 5000 patches. adding --partial got it in a couple of minutes
14:20:38 <sorear> HairyDude: probably they checkpointed recently or something ... I went from 10m for 15000 to 2m for 3000 or somesuch
14:20:56 <HairyDude> ah, probably
14:21:11 <HairyDude> there were 179 patches
14:21:29 <sorear> Igloo: nothing
14:21:44 <sorear> Igloo: if ghc rejects that, it's a bug by my reading of the repport
14:21:54 <Igloo> ghc and hugs both do
14:22:50 <sorear> and yhc.  but I can't justify it
14:23:08 <Igloo> OK, thanks
14:23:41 <sorear> Igloo: wrt the h' wiki prelude proposal..
14:24:05 <sorear> Igloo: asTypeOf should probably be killed even though it is used fairly often
14:24:12 <Igloo> sorear: The import Prelude one?
14:24:17 <jcreigh> @seen sjanssen
14:24:17 <lambdabot> sjanssen is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 1h 7m 23s ago.
14:24:23 <sorear> Igloo: since all it's used for is faking scoped tyvars, which are in
14:24:39 <sorear> Igloo: the Prelude page, minimal prelude proposal
14:24:43 <Igloo> Ah, right
14:24:58 <sorear> Igloo: asTypeOf is not worthy of being in the kept eight IMO
14:25:35 <sorear> kept 11
14:28:22 <Igloo> sorear: http://hackage.haskell.org/trac/haskell-prime/ticket/67 says they're a maybe
14:28:24 <lambdabot> Title: #67 (add Scoped Type Variables) - Haskell Prime - Trac
14:28:59 <HairyDude> gaah, why is fedora missing so many haskell libraries
14:29:10 <HairyDude> there's no alex or happy :(
14:30:17 <Botje> no happy makes HairyDude .. err .. not happy!
14:30:21 <sorear> odd, since both are in debian (under those names)
14:30:22 <sjanssen> jcreigh: whatup?
14:30:36 <sorear> xmonad's been ...
14:30:39 <sorear> reddited.
14:31:00 <psi`> HairyDude: it's easy to install them manually, luckily.
14:31:05 <ddarius> ? How? Why?
14:31:05 <psi`> @hackage happy
14:31:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happy
14:31:18 <sjanssen> sorear: do we know who asb is?
14:31:41 <dmwit> I was wondering the same thing...
14:32:16 <HairyDude> hooray for cabal! :)
14:32:17 <paulc> hello
14:32:40 <dmwit> Hi, paulc!
14:32:55 <paulc> Hi, I'm a first-time Haskell user
14:33:04 <paulc> just downloaded it today
14:33:19 <paulc> I've been meaning to learn it for a while
14:33:34 <paulc> I have some simple questions...
14:33:39 <sorear> great!
14:33:47 <sorear> we love to answer questions.
14:33:51 <sorear> @quote community
14:33:52 <lambdabot> syntaxfree says: monad tutorials are the "Hello world" of our community.
14:34:01 <Botje> :D
14:34:05 <sorear> hmm, hoping for something more appropriate...
14:34:10 <sorear> anyway, ask away
14:34:12 <Botje> @quote stereo
14:34:12 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
14:34:13 <DRMacIver> The world does not need more monad tutorials. :)
14:34:22 * dmwit steels himself to not answer, so that paulc isn't deluged.
14:34:24 <paulc> what is the typical workflow like in Haskell?
14:34:26 <HairyDude> hehe
14:34:28 <DRMacIver> It needs more people to say "Shut up and use the damn things. You'll understand them when you're older."
14:34:55 <Botje> DRMacIver: actually, that's pretty good advice. just reading about monads doesn't help a lot :)
14:34:56 <sorear> <- write a couple hundred lines, compile, fix, repeat
14:34:59 <HairyDude> write, get type error, edit, get different type error, realise you're an idiot and edit again, it works :)
14:35:02 <paulc> hehe
14:35:31 <Botje> I write a basic skeleton of what my program is to do, then slowly fill in the blanks, and recompile every once in a while
14:35:33 <dmwit> Botje: On the contrary, I learned it all by reading.
14:35:51 <dmwit> Botje: I was never actually able to use them until I learned about them...
14:36:04 <sorear> I'm pretty sure I learned it, but it sure feels like I was born grokking monads
14:36:16 <paulc> okay, I'm used to the following from using python --- I make some changes to a file, and keep an interactive prompt open -- in the interactive prompt I reload the module I'm working on and enter expressions in interactively as I go
14:36:29 <paulc> can I do something like that with Haskell?
14:36:32 <tibbe> I was thinking of writing a string templating system for haskell, just want to survey what has been done already. are there any other templating systems out there?
14:36:41 <Botje> paulc: get ghci or hugs and your workflow is mostly the same
14:36:45 <paulc> or what is the best practice for the edit, compile, run cycle
14:36:48 <sorear> paulc: get ghci
14:37:06 <Botje> tibbe: look into what tmoertel published
14:37:11 <paulc> ya, I have ghci
14:37:15 <Botje> "an end to SQL injections" iirc
14:37:18 <HairyDude> hmm, when did vim's haskell colouring suddenly start to understand LaTeX literate style
14:37:41 <sorear> paulc: edit -> save -> tell ghci ":r" -> fix type errors -> save -> ":r" -> enter expressions -> fix infinite loop bug -> save -> repeat
14:37:44 <tibbe> @google tmoertel
14:37:46 <lambdabot> http://search.cpan.org/~TMOERTEL/
14:37:47 <lambdabot> Title: Tom Moertel - search.cpan.org
14:37:51 <tibbe> Botje, a yes, that one
14:38:08 <tibbe> any others?
14:38:18 <sorear> paulc: the :ring can be automated a bit with shim - C-c C-l to check the current buffer for type errors
14:38:30 <Botje> tibbe: well, you could look at perl's template toolkit
14:38:33 <sorear> paulc: but you don't get to enter expressions that way :(
14:38:37 <Botje> I like their api
14:38:44 <psi`> paulc: if you like emacs, there's a pretty good haskell mode.
14:39:04 <paulc> okay
14:39:17 <paulc> I use textmate on mac usually
14:39:26 <paulc> I don't know how good the haskell support is, tho
14:39:39 <tibbe> Botje, I will have a look at a bunch of different once before doing my design
14:39:41 <psi`> not that great, apparently.
14:39:56 <psi`> at least that's what a user from a few weeks back said.
14:40:37 <HairyDude> I'm told debian's emacs haskell mode is old and bad
14:40:38 <paulc> hmm
14:41:01 <dmwit> Don't worry about it, you don't need much of a "mode".
14:41:22 <dmwit> If there's a feature that keeps the indentation level from the previous line, that's pretty handy and just about all you need.
14:41:47 <DRMacIver> Botje: I know. It's the advice I've taken. :) I still don't entirely understand them (although I'm getting there), but they're pretty easy to use.
14:42:02 <paulc> okay
14:43:54 <paulc> what is the associativity of '->'
14:43:58 <sorear> rigth
14:45:06 <paulc> okay
14:46:35 <paulc> what is the priority of the syntax for function application?
14:46:43 <sorear> priority?
14:46:58 <sorear> apposition is left assoc, precedence 10
14:47:04 <paulc> so, will factorial x+1 be parsed as factorial (x) + 1 or factorial (x+1)?
14:47:06 <dmwit> Function application happens before anything else.
14:47:11 <HairyDude> the former
14:47:21 <sorear> factorial x + 1 = (factorial x) + 1
14:47:27 <HairyDude> what sorear said
14:47:31 <paulc> okay
14:47:41 <sorear> + is infixl 3 iirc
14:47:49 <sorear> infixl 6
14:47:55 <sorear> :i++
14:48:03 <HairyDude> ?fixity infixl
14:48:03 <lambdabot> Unknown command, try @list
14:48:05 <HairyDude> bah
14:48:28 <sorear> you can use ':i +' in ghci, that will tell you
14:48:40 <sorear> or you can add a lambdabot command *hint hint hint*
14:54:14 <jcreigh> sjanssen: oh, I was just wondering if you had seen that somebody had posted xmonad to reddit.
14:55:53 <sjanssen> jcreigh: yes.  It's a little premature, I think
14:55:55 <sjanssen> oh well
14:56:22 <sorear> @seen jyp
14:56:23 <lambdabot> I saw jyp leaving #oasis and #haskell 4h 42s ago, and .
14:56:28 <jcreigh> yeah, we weren't stealth enough. :)
14:56:34 <dmwit> You know, I don't think dwm counts config.h in its LOC; does the 401 figure include knobs you can twist?
14:56:44 <jcreigh> dmwit: yes.
14:56:50 <dmwit> cute
14:57:08 <jcreigh> dmwit: but the "real LOC" is 714, (if you just wc -l *.hs)
14:57:21 <dmwit> o
14:57:32 <sorear> hi!
14:57:35 <jcreigh> exactly 400 non-comment non-whitespace lines ATM, however.
14:58:08 <sorear> is xmonad written in high density haskell or low density haskell?
14:58:47 * Maddas fails to install the X11 package correctly.
14:58:59 <jcreigh> sorear: fairly low density, I think. I didn't try to golf anything, and it doesn't look like anyone else did either.
14:59:02 <Maddas> Does it have any prerequisites it doesn't explicitly check for?
14:59:31 <dmwit> dmenu, probably
14:59:40 <Maddas> X11, not X11-extras
14:59:42 <dmwit> And dmenu_path?
14:59:47 <TSC> You don't need dmenu to make it work
14:59:49 <jcreigh> but a missing dmenu would only cause a runtime failure.
14:59:51 <dmwit> Oh.
14:59:55 <jcreigh> when you hit modkey-p
15:00:08 <dmwit> Sorry, Maddas, I thought you were building xmonad.
15:00:10 <sjanssen> sorear: the code isn't especially dense
15:00:17 <Maddas> dmwit: I'm trying to, yeah :-)
15:00:26 <TSC> Maddas: How does it fail?
15:00:33 <sorear> sjanssen: that needs to be fixed :)  remember, you can have as many comments as you want!
15:00:34 <Maddas> Oh, my error is caused by a GHC header.
15:00:45 <Maddas> /sw/lib/ghc-6.6/template-hsc.h:4:19:      error: HsFFI.h: No such file or directory
15:01:38 <Maddas> ("In file included from Graphics/X11/Types_hsc_make.c:1:0")
15:01:42 * sorear starts the xmonad-100 branch
15:02:15 <sorear> all the features of xmonad-400, but 1/4 the loc!
15:02:19 <sorear> jkoc
15:02:46 <sjanssen> Maddas: it looks like you're building the package with fink?
15:03:13 <Saizan> can text in latin-1 can be interpreted as utf-8 without problems? or that was only ascii?
15:03:27 <sjanssen> Saizan: no, it can't
15:03:45 <Maddas> sjanssen: I'm calling runghc Setup.hs configure --user --prefix=/sw; runghc Setup.hs build
15:03:54 <Maddas> (I generally throw everything I build into /sw as well)
15:04:06 <sjanssen> Saizan: only characters <= 127
15:06:06 <HairyDude> i.e. only ASCII
15:08:10 <HairyDude> ISO 8859-1 is however the same as the first 255 Unicode codepoints
15:08:23 <sorear> HairyDude: not 256?!
15:08:32 <HairyDude> might be
15:08:59 <HairyDude> ah yes, it is the first 256
15:10:40 <Saizan> mmh i've some non-transparent transformation which leads some utf8 input to get badly rendered, a verbatim Word8 -> Char conversion could do that, right?
15:12:53 <HairyDude> there should be some kind of iconv library for haskell
15:12:56 <dpiponi> I've spent too long looking at the same document. Periodically, even Haskell newbies point out that there is an error in my "You could have invented monads..." tutorial in the "debuggable function
15:13:05 <dpiponi> But I can't see it!
15:13:52 <dpiponi> Supposedly I have f anf g the wrong way round somewhere. Can anyone else see the problem?
15:14:03 <Igloo> HairyDude: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/iconv-0.2
15:14:06 <lambdabot> http://tinyurl.com/26o5gf
15:14:20 <dmwit> ?go you could have invented monads
15:14:22 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
15:14:23 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
15:15:02 * HairyDude yawns while still waiting for ghc to build
15:15:08 <Saizan> dpiponi: i think you have something weird in the description of the state bind
15:15:29 <dpiponi> Ah! It's the state one, not the debuggable function one.
15:17:17 <dpiponi> Ah yes, something there is very bad!
15:17:41 * ndm writes the phrase "These performance numbers are from GHC with optimisation turned off and profiling turned on -- surprisingly this beats optimisation on and profiling off"
15:18:41 <DRMacIver> ndm: Heh. What?
15:19:19 <ndm> DRMacIver, in the paper i
15:19:21 <ddarius> Exercise Three?
15:19:39 <ddarius> Wait
15:19:40 <ndm> 'm writing, profiling speeds up execution, optimisation slows it down - i don't understand why
15:19:53 <DRMacIver> ndm: That's... really strange.
15:20:16 <ndm> DRMacIver, yes - i know! was also a bit of a shock
15:20:38 <ddarius> Nevermind
15:21:15 * EvilTerran notes from that "You Could Have Invented Monads" thing that he did in fact invent something very similar for doing IO when tinkering with stdML
15:21:16 <DRMacIver> ndm: What happens if you turn both off? Is it possible the compiler is accidentally doing a bad optimisation?
15:22:11 <sorear> ndm: wasn't this reported a week or so ago?
15:22:15 <ndm> DRMacIver: -O0 -p < -O0 < -O2 -p < -O2 < -O1 -p < -O1
15:22:35 <ndm> sorear, yes - but now I'm producing the final table of numbers in my paper
15:22:37 <sorear> -O11? :)
15:22:45 <ndm> sorear, give it some time yet ;)
15:23:33 <EvilTerran> I had a function that, given a callback, looked at the return value of type Action = ReadStringThenDo (String -> Action) | WriteStringThenDo (String, () -> Action) | Stop
15:23:41 <EvilTerran> or something like that.
15:28:44 <yshhq> @src all
15:28:45 <lambdabot> all p =  and . map p
15:28:59 <yshhq> @src scanl
15:28:59 <lambdabot> scanl f q ls = q : case ls of
15:29:00 <lambdabot>     []   -> []
15:29:00 <lambdabot>     x:xs -> scanl f (f q x) xs
15:29:21 <yshhq> @src and
15:29:21 <lambdabot> and   =  foldr (&&) True
15:29:35 <yshhq> @src foldr
15:29:36 <lambdabot> foldr k z xs = go xs
15:29:36 <lambdabot>     where go []     = z
15:29:36 <lambdabot>           go (y:ys) = y `k` go ys
15:29:46 <yshhq> @src scanr
15:29:46 <lambdabot> scanr _ q0 []     =  [q0]
15:29:47 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
15:29:47 <lambdabot>     where qs@(q:_) = scanr f q0 xs
15:29:55 <dmwit> yshhq: Whatch lookin' for?
15:30:45 * ddarius has yarn.
15:31:10 <yshhq> wanna to test sum(x) == n
15:31:27 <yshhq> and try to see what is the best method
15:31:38 <sorear> > sum [1..10] == 55
15:31:40 <lambdabot>  True
15:31:42 <yshhq> all elements of x is positive
15:31:43 <sorear> that
15:31:54 <yshhq> I want to save some computing time
15:32:04 <sorear> yshhq: is it compute bound?
15:32:21 <yshhq> if partial sum is great than n, so does the total sum
15:32:42 <sorear> yshhq: eliminating the list (use bytestrings instead) will pay off a LOT more than coalescing traversals.
15:33:42 <yshhq> @where bytestrings
15:33:42 <lambdabot> I know nothing about bytestrings.
15:33:53 <sorear> you have 6.6?
15:33:55 <yshhq> @where ByteStrings
15:33:55 <lambdabot> I know nothing about bytestrings.
15:33:57 <yshhq> no
15:33:59 <yshhq> 6.4
15:34:02 <sorear> @where fps
15:34:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
15:34:07 <sorear> @where binary
15:34:08 <lambdabot> http://darcs.haskell.org/binary
15:34:24 <yshhq> will look at that
15:34:34 <sorear> note that if the list is used once, ghc can fuse the consumer and producer
15:34:46 <yshhq> but still i think my question is that difficult
15:34:48 <ndm> sorear, fusion would probably eliminate the list totally, and be much faster than bytestring
15:35:05 <sorear> ndm: not if there are multiple consumption loops
15:35:15 <yshhq> since to calculate sum(x) you need to calculate partial sum
15:35:36 <yshhq> so it should be able to stop in the middle if I only want to test sum(x) == n
15:35:59 <yshhq> because of laziness, right?
15:36:03 <dmwit> yshhq: Take a look at scanl, dropWhile, and null.
15:36:13 <dmwit> Some combination of those should get you what you want.
15:36:29 <yshhq> 3x
15:41:00 <dmwit> > [1..] == [1]
15:41:01 <lambdabot>  False
15:41:21 <dmwit> Probably don't even need null, come to think of it.
15:42:18 <dmwit> > let checkSum n xs = [n] == dropWhile (< n) $ scanl1 (+) xs in checkSum 55 [1..10]
15:42:20 <lambdabot>  Couldn't match expected type `[a]'
15:42:29 <dmwit> :t scanl1
15:42:31 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
15:43:13 <dmwit> > let checkSum n xs = [n] == (dropWhile (< n) $ scanl1 (+) xs) in checkSum 55 [1..10]
15:43:15 <lambdabot>  True
15:43:19 <dmwit> > let checkSum n xs = [n] == (dropWhile (< n) $ scanl1 (+) xs) in checkSum 54 [1..10]
15:43:21 <lambdabot>  False
15:43:25 <dmwit> > let checkSum n xs = [n] == (dropWhile (< n) $ scanl1 (+) xs) in checkSum 56 [1..10]
15:43:27 <lambdabot>  False
15:43:29 <dmwit> > let checkSum n xs = [n] == (dropWhile (< n) $ scanl1 (+) xs) in checkSum 56 [1..]
15:43:31 <lambdabot>  False
15:44:20 <EvilTerran> might you want "scanl (+) 0 xs" ?
15:44:37 <dmwit> Sure, why not.
15:45:12 <dmwit> Seems like he's dealing with some uber-long lists, though, if he's that worried about summing it.
15:46:32 <EvilTerran> might be a "protection from infinite lists" sort of thing. there's no harm in covering the null case, anyway.
15:47:17 <hpaste>  dpiponi pasted "I'm so crap I couldn't have invented monads" at http://hpaste.org/1136
15:47:47 <dpiponi> I still can't find the error. This is going to be so embarassing...
15:48:14 <Cale> I'll have a look
15:48:49 <augustss> error?
15:48:57 <yshhq> how about let runningSum = scanr1 (+) x in if all (<=n) runningSum then head runningSum == n else False
15:49:20 <dmwit> yshhq: IIRC, scanr is exactly the wrong one for your use.
15:49:21 <yshhq> does using scanl or scanr matter here?
15:49:35 <dpiponi> augustss: I've had too many comments that that post has an error for me to ignore them.
15:49:44 <Cale> scanr won't save you any time
15:49:59 <ddarius> > foldM (\x y -> guard (x+y < 10) >> return (x+y)) 0 [1..3]
15:50:00 <lambdabot>   add an instance declaration for (Show (m b))
15:50:01 <ddarius> > foldM (\x y -> guard (x+y < 10) >> return (x+y)) 0 [1..10]
15:50:02 <lambdabot>   add an instance declaration for (Show (m b))
15:50:05 <HairyDude> dpiponi: works for me
15:50:06 <ddarius> > foldM (\x y -> guard (x+y < 10) >> return (x+y)) 0 [1..10] :: Maybe Int
15:50:08 <lambdabot>  Nothing
15:50:14 <dmwit> yshhq: Also, head of the sum won't do the right thing.
15:50:14 <ddarius> > foldM (\x y -> guard (x+y < 10) >> return (x+y)) 0 [1..3] :: Maybe Int
15:50:16 <lambdabot>  Just 6
15:50:23 <sjanssen> dpiponi: you aren't using the typical argument order for bind.  Is that intentional?
15:50:32 <dpiponi> Yeah, the code works. So that part of the tutorial can't be in error.
15:50:34 <augustss> dpiponi: looks ok to me
15:50:43 <yshhq> i am a bit confused right now
15:50:49 <dpiponi> augustss: But can you find an error in the original blog post.
15:50:51 <dmwit> yshhq: I posted one above.
15:51:01 <yshhq> i will try yours
15:51:05 <ddarius> dpiponi: I didn't see anything erroneous in the part of the post you mentioned before.
15:51:34 <allbery_b> works for me in ghc6.6, ghc6.7, hugs
15:51:40 <dmwit> yshhq: But like EvilTerran said, you should probably replace scanl1 (+) with scanl (+) 0
15:51:46 <dpiponi> sjanssen: I deliberately made 'bind' the flip of >>= for pedagogical reasons. I wanted function application to act on the left like it normally does.
15:52:10 <HairyDude> noooooooo
15:52:13 <HairyDude> ghc build failed :(
15:52:14 <allbery_b> I will note that blog aggregators have an annoying tendency to hose your posts, though
15:52:18 <allbery_b> (yours and many others)
15:52:46 <HairyDude> In file included from CPUTime.hsc:37:
15:52:46 <HairyDude> include/HsBase.h:12:26: error: HsBaseConfig.h: No such file or directory
15:52:47 <dpiponi> allbery_b: Aha! Maybe there's a problem with the unicode characters.
15:53:34 <allbery_b> well, the problems I suusally see involve it inappropriately interpreting html-active characters (e.g. >)
15:53:44 <allbery_b> I've sometimes seen backslashes go missing as well
15:54:09 <dpiponi> allberyb: Ironically, whatever you typed at the end of your last sentence came out as an alien face in Chatzilla!
15:54:27 <Cale> haha
15:54:28 <allbery_b> heh.  there is that kind of silliness as well
15:54:53 <dpiponi> Out of curiosity, what did you type (put spaces between chars)
15:55:00 <allbery_b>  > )
15:55:08 <dpiponi> >)
15:55:36 <stepcut> dpiponi: on my system, on your blog, the -> in the bind type signature are all represented as empty squares, but that is my fault for using a font that is missing that symbol...
15:58:21 <HairyDude> or for using a browser that doesn't replace missing glyphs with glyphs from other fonts
15:58:58 <Cale> dpiponi: I don't see any bug in that code.
15:59:05 <dpiponi> stepcut: I agonise over every use of a non-ASCII character! But having fancy characters makes live easier for writing mathematics. (And I wish Haskell supported them better)
15:59:58 <HairyDude> the ghc docs say it doesn't support non-UTF-8, but I find it works fine
16:00:09 <HairyDude> doesn't support UTF-8, sorry
16:00:18 <DRMacIver> I quite like Fortress's decision to support all of unicode. :)
16:00:22 <dpiponi> Cale: The code must be right. So there must be an error somewhere else in the blog post. (Or there is something that is confusing people in the same way.)
16:00:39 <HairyDude> unless it means you can put non-ASCII characters in identifiers
16:00:45 <dpiponi> HairyDude: Yeah, but can you define a new binary operator using funky symbols?
16:00:59 <allbery_b> HairyDude: the compiler supports UTF-8 source; the I/O routines don't
16:01:17 <HairyDude> ah
16:01:47 <allbery_b> and I know ghc < 6.6 doesn't support UTF8 source; I don't know about Hugs
16:02:03 <allbery_b> so using UTF8 in Haskell source examples is somewhat risky
16:02:46 <dons> morning.
16:02:49 <HairyDude> dpiponi: so you want to be able to type â instead of 'forall' ? :)
16:03:32 <dpiponi> HairyDude: That's be cool!
16:04:06 <HairyDude> and â instead of `union` and so forth
16:04:16 <HairyDude> dpiponi: what you really want is APL... ;)
16:04:22 <sjanssen> morning dons
16:04:22 <DRMacIver> Or Fortress. :)
16:04:37 <dpiponi> My first paying programming job was in APL many years ago.
16:04:42 <allbery_b> lamp comments?
16:04:44 <rahikkala> pitÃ¤kÃ¤Ã¤ tunkkinne stn
16:04:56 <HairyDude> wow
16:04:59 <rahikkala> ... whoops, wrong channel
16:05:01 <dons> sjanssen: i see reddit found out about us.
16:05:14 <DRMacIver> I should really learn APL at some point. :)
16:05:20 <HairyDude> didn't know people actually wrote commercial code in APL :)
16:05:22 <sjanssen> dons: yes.  And we've got flames already :(
16:06:02 <Adamant> I think one of the succesors of APL ended up being used in the financial industry
16:06:09 <Adamant> for real-timish stuff.
16:06:09 <dpiponi> HairyDude: IBM made big use of APL
16:06:39 <dpiponi> IBM had a database interface that was APL based called APLDI (I think). Think SQL with APL notation.
16:06:59 <Japsu> hmm
16:07:01 * HairyDude finds it hard to imagine suits using APL syntax for SQL
16:07:12 <Japsu> oh, APL isn't "Aladdin Public License"
16:07:19 <HairyDude> nope
16:07:22 <HairyDude> A Programming Language
16:07:25 <Japsu> this conversation now makes a whole lot more sense to me
16:07:29 <dpiponi> Very good for selecting and summing rows and columns
16:07:32 <HairyDude> or Array Programming Language
16:07:47 <Japsu> hmm the license is AFPL
16:08:43 <jcreigh> hmm, what would that look like: SELECT * FROM FooBar WITHOUT IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
16:08:53 <HairyDude> hehe
16:08:56 <Cale> hahaha
16:08:59 <dons> sjanssen: only from grauenwolf.
16:09:11 <dons> sjanssen: who hates everything, and understands little.
16:09:19 <Cale> @remember jcreigh SELECT * FROM FooBar WITHOUT IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
16:09:19 <lambdabot> Done.
16:09:48 <jcreigh> dons: I'm writing a reply to grauenwolf right now, actually. explaining why I, personally, found other WMs lacking.
16:10:06 <jcreigh> (and pointed out that you guys didn't want to announce xmonad until 0.1 anyway)
16:10:07 <dons> i've already done so. i'm onot sure it warrants much consideration though.
16:11:31 <sorear> who is grauenwolf?
16:11:34 <Cale> endevior
16:11:38 <jcreigh> sorear: reddit troll
16:12:26 <augustss> i considered replying to him.  but i don't think it helps.  he seems to ignore replies
16:12:27 <sorear> (and why do we care about the redditrools?)
16:12:57 <Adamant> reddit has trolls already, huh
16:12:59 <Adamant> sad.
16:13:40 <augustss> i'm not sure if he is a troll or just behaves like one
16:14:03 <sjanssen> lol, three simultaneous replies to j4b's "where's the docs?"
16:14:12 <jcreigh> augustss: and the difference is? :)
16:14:27 <augustss> jcreigh: all in his brain
16:14:27 <sorear> sjanssen: ?
16:14:29 <dmwit> Whoops. =P
16:14:53 <sjanssen> sorear: in the reddit conversation on xmonad.  dons, dmwit and I all responded at roughly the same time
16:15:09 <stepcut> sjanssen: hive mind!
16:15:14 <sorear>  @quote stereo
16:17:19 <byteshack> something to ponder: how would love womanX be executed in a strict vs lazy world?  Oh man, I need to get out and see the sun :)
16:17:46 <dmwit>  ?man womanX
16:18:39 <dmwit> Haha,
16:18:45 <dmwit> % man womanX
16:18:50 <dmwit> man: Don't know about womanX
16:19:35 <stepcut> try, M-x woman in emacs ;)
16:19:52 <dmwit> zsh: command not found: emacs
16:19:54 <dmwit> ;-)
16:20:21 <stepcut> dmwit: hrm, that's a problem, you should get that looked at
16:20:53 <byteshack> haha
16:21:00 <dmwit> Wow, does emacs take a long time to start up, or is the computer I'm connected to just way slow?
16:21:33 <stepcut> no, it takes a long time
16:21:39 <ftegularius> dmwit: emacs can take a while, depending on how many packages it's loading
16:22:19 * dmwit is still waiting
16:22:43 <byteshack> dmwit: it's been said that it is like loading an os on your os :)
16:22:56 <sorear> dmwit: just get a elisp accelerator card
16:23:14 <dmwit> No thanks, I'm keeping that particular puppy off of my CPU altogether.
16:23:15 <ftegularius> Emacs: Eight Megabytes And Constantly Swapping
16:23:36 <sorear> usually only takes ~4s for me.  then again my system can compile ghc in an hour and a half...
16:23:46 <stepcut> dmwit: hrm, perhaps the computer is also just way slow :p
16:23:53 <jcreigh> ...back when eight megabytes was a non-trivial amount of RAM.
16:24:16 <Adamant> emacs is smaller than eclipse or Visual Studio by a long shot.
16:24:26 <stepcut> I tried running, with init=/usr/bin/emacs, but I could not get C-g to work properly
16:24:36 <stepcut> that made life difficult
16:24:53 <dmwit> Ah, I see, M-x woman is man.  Cute. =)
16:25:31 <stepcut> dmwit: it's actually a better version of man ;)
16:25:36 <jcreigh> Unix is mostly built on kludges that work and really bad puns.
16:25:47 <dmwit> But PAGER=most is much faster and probably has just the right capabilities for reading man pages anyway...
16:25:58 <Pseudonym> jcreigh: What's wrong with reaping dead children?
16:25:59 <dmwit> stepcut: Ah. =)
16:26:16 <Pseudonym> Reaping zombie children, even!
16:26:26 <mbishop> Oh wow, I read that totally wrong
16:26:54 * stepcut checks out most
16:27:32 <ftegularius> dmwit: doesn't most have a problem with ANSI color escape codes?
16:27:34 <sorear> I'm working on a port of the yhi to Intel bare-metal.. My goal is to have yi be my OS by 2009.
16:27:36 <Adamant> the zombies cannot be kill -9'ed
16:27:46 <dmwit> ftegularius: dunno, lol
16:27:58 <stepcut> sorear: are you going to remove the dependency on GMP ?
16:27:59 <ddarius> mbishop: I can see one misreading... jesus.
16:28:05 <stepcut> sorear: that would make yhi far more portable
16:28:11 <ftegularius> dmwit: that's what keeps me using less, that way i can pipe commands like 'ls --color' without seeing control chars all over the screen
16:28:17 <sorear> stepcut: what?
16:28:25 <mbishop> ddarius: I was wondering how that would even be possible...I mean, dead kids couldn't say no...
16:28:26 <sorear> stepcut: what makes gmp non-portable?
16:28:39 <sorear> stepcut: surely it has an ANSI C fallback branch?
16:28:40 <stepcut> sorear: I could never get it to compile for PalmOS
16:28:42 <dmwit> ftegularius: ls --color=auto ?
16:28:48 <dmwit> WFM
16:28:51 <sorear> #if .. #elsif ... #elsif ... #else
16:28:55 <Pseudonym> Or you could just not use ls --color
16:29:03 <byteshack> (love womanX) would that create a suspension?
16:29:21 <jcreigh> or explictly use /bin/ls when you want to pipe it somewhere.
16:29:39 <dmwit> Also, ls --color | less still shows control characters for me.
16:29:39 <Pseudonym> Use ls -F like normal people.
16:29:50 <ftegularius> dmwit: you need the "-R" flag
16:30:04 <LoganCapaldo> bah
16:30:07 <LoganCapaldo> > let a = [undefined..undefined] in 1
16:30:07 <stepcut> sorear: libgmp also has potential license issues, and is (as far as I know) only used for supporting 'Integer'... It would be nice if it was, at the very least, optional
16:30:08 <lambdabot>  Add a type signature
16:30:13 <ftegularius> Pseudonym: i do that too
16:31:15 <sorear> dmwit: --color means ALWAYS use color.
16:31:22 <Pseudonym> I actively hate sites with --color turned on by default.
16:31:26 <sorear> dmwit: --color=auto means color iff output to tty.
16:31:41 <Pseudonym> There's always some terminal program that I use which makes it unreadable.
16:31:43 <sorear> Pseudonym: how do you feel about debian and color=auto as an alias?
16:31:44 <dmwit> sorear: Exactly, so ls --color=auto | less will just "do the right thing".
16:31:46 <Pseudonym> Like showing blue on black sometimes.
16:32:07 <Pseudonym> sorear: I think Debian does a lot of things mildly wrong.
16:32:11 <t0mas> hi
16:32:13 <Pseudonym> Not horribly wrong, just mildly annoying.
16:32:14 <tsp> I'm going through http://haskell.org/tutorial, but its confusing as hel
16:32:14 <sorear> hello.
16:32:16 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
16:32:16 * ftegularius likes his colors
16:32:23 <ftegularius> even in less ;)
16:32:28 <jcreigh> cool, I didn't know about --color=auto. thanks for the tip, guys.
16:32:34 <dmwit> tsp: That isn't the most gentle of introductions.
16:32:50 * LoganCapaldo wishes color was transmitted out of band
16:32:57 <tsp> Where can I find a better one?
16:33:20 <thorat> tsp: where does it get confusing?
16:33:24 <t0mas> I think I'm just doing something really wrong because of my C/C++ background... but I can't get my Haskell program to parse a strangely formatted textfile...
16:33:35 <kc5tja> LoganCapaldo: That would require a full-bore protocol to be used (something like HDLC, which was first invented pretty much for exactly this kind of purpose).
16:33:39 <t0mas> it's SWIFT / MT940
16:33:39 <dmwit> ?where yaht
16:33:40 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:33:43 <t0mas> banking information
16:33:51 <dmwit> tsp: Lot's of people like YAHT.
16:33:54 <tsp> thorat: the entire thing
16:33:57 <kc5tja> LoganCapaldo: Not saying I disagree; I've often thought of going that route myself in my own homebrew OSes.
16:34:00 <tsp> its too math-based, I suck at math
16:34:00 <t0mas> does anybody have some time to help me? :)
16:34:11 <dmwit> t0mas: Have you taken a look at Parsec?
16:34:15 <jcreigh> tsp: yes, YAHT is much better to start out with than the "gentle" introduction.
16:34:24 <t0mas> well.. I have, after google for parsing with Haskell
16:34:30 <jcreigh> tsp: the "gentle" introduction is only gentle if you already know some other FP language.
16:34:32 <tsp> jcreigh: is there another version besides pdf?
16:34:33 <LoganCapaldo> kc5tja: yeah it was sort of an idle complaint. I'm not gonna actually _do_ anything about it :)
16:34:35 <t0mas> but I don't think it's the right tool for this..
16:34:42 <Pseudonym> There's also the regex library.
16:34:44 <jcreigh> tsp: I think there's a wikibook version somewhere...
16:34:52 <Pseudonym> But it really depends how strangely formatted your file is.
16:34:52 <dmwit> That said, I used just A Gentle Introduction coming from C, and I've never looked back... =P
16:34:54 <tsp> I don't have a good pdf to text converter
16:35:01 <sorear> @quote jwz
16:35:01 <Pseudonym> t0mas: How would you have done it in C++?
16:35:01 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
16:35:17 <dmwit> ?go wikibook yaht
16:35:19 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
16:35:20 <happy_nic>  hmm. my ubuntu ghc install is missing control.monad.state. has that been officially moved or dropped? or is there something up with this package.
16:35:24 <t0mas> I would have read it line by line.. it has codes at the beginning of a line
16:35:25 <tsp> dmwit: the gentle intro doesn't get you going - I don't even know when I can start running something after all the theory
16:35:29 <t0mas> to indicate what info is at that line
16:35:34 * kc5tja sometimes wishes that XTerms supported MGR's escape sequences.
16:35:37 <Pseudonym> t0mas: Well, we can do that.
16:35:40 <jcreigh> kc5tja: MGR?
16:35:40 <Pseudonym> :t lines
16:35:42 <lambdabot> String -> [String]
16:35:47 <Pseudonym> > lines "hello\nworld\n"
16:35:49 <lambdabot>  ["hello","world"]
16:35:50 <ddarius> Which reminds me
16:35:53 <t0mas> so C++ would be... some vars to keep the data, and set that according to what you read
16:35:54 <Pseudonym> t0mas: Does that help?
16:36:03 <t0mas> I got that part ;)
16:36:07 <Pseudonym> Cool.
16:36:16 <Pseudonym> So you've got the lines.
16:36:33 <kc5tja> jcreigh: http://en.wikipedia.org/wiki/ManaGeR
16:36:39 <dmwit> tsp: Heh, yeah, it's tricky.
16:36:48 <t0mas> do x <- readFile fp
16:36:49 <t0mas> return (parseMT940 (lines x))
16:36:54 <t0mas> is what I'm doing now to read the lines
16:37:02 <dmwit> It isn't until about the eighth chapter that you get to do anything.
16:37:02 <t0mas> problem is.. some lines have a context...
16:37:15 <Pseudonym> t0mas: SWIFT?
16:37:18 * tsp idles
16:37:22 <t0mas> like.. a comment that belongs to the previously read transaction
16:37:33 <t0mas> yes.. MT940 is what it's called by Dutch banks
16:37:36 <Pseudonym> Right.
16:37:41 <Pseudonym> Man, that format is crap.
16:37:45 <tsp> dmwit: I'm currently learning C C++ and python for various things - haskell can't be all that different when you start to code
16:37:45 <t0mas> and that part is hard (for me) in haskell
16:37:48 <Pseudonym> Still, if you gotta, you gotta.
16:37:57 <Pseudonym> Let's look at this a bit.
16:38:03 <jcreigh> tsp: well, it kind of is. :)
16:38:08 <tsp> damn
16:38:26 <dmwit> tsp: Don't panic, use YAHT. =)
16:38:33 <jcreigh> 42!
16:38:38 <t0mas> Pseudonym: do you know the format?
16:39:07 <Pseudonym> This format, I think was designed for COBOL.
16:39:15 <Pseudonym> t0mas: I've seen it before, I don't know it well.
16:39:19 <t0mas> ok
16:39:20 <tsp> dmwit: I'm stuck with hugs, sparc64
16:39:22 <tsp> heh
16:39:23 <t0mas> I can get you an example
16:39:26 <Pseudonym> Sure.
16:39:31 <thorat> tsp: you can get the latex sources for YAHT
16:39:32 <Pseudonym> ?where paste
16:39:33 <lambdabot> http://hpaste.org/new
16:39:41 <Pseudonym> t0mas: Paste some records there.
16:39:56 <dmwit> tsp: That shouldn't really be a problem.
16:40:01 <tsp> thorat: latex sources? cool, if the wikibooks fall through I can just read them with ed
16:40:10 <thorat> tsp: http://darcs.haskell.org/yaht/
16:40:12 <lambdabot> Title: Index of /yaht
16:40:14 <tsp> neat
16:40:23 * tsp goes off to read
16:40:46 <t0mas> Pseudonym: pastebin.com is ehm.. dead..
16:40:54 <Pseudonym> ?where paste
16:40:55 <lambdabot> http://hpaste.org/new
16:40:55 <t0mas> does the channel have a default pastebin?
16:40:58 <t0mas> ah, tnx
16:41:01 <Pseudonym> NP
16:41:12 <ddarius> P
16:41:27 <Pseudonym> ddarius: Same thing.
16:41:44 <sorear> .
16:41:44 <dmwit> tsp: You can also try (a subset of) Haskell here.
16:41:45 <ddarius> Really now?
16:41:48 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1137
16:41:49 <dmwit> > 3 + 3
16:41:51 <lambdabot>  6
16:41:57 <t0mas> ah, forgot the name :)
16:42:12 <Pseudonym> ddarius: I have a marvellous proof of this, but the channel is too small to contain it.
16:42:17 <sorear> tsp: a fellow ed user?
16:42:18 <t0mas> Pseudonym: 876987345 is the accountnumber.. on line 3
16:42:23 <Pseudonym> Right.
16:42:41 <t0mas> and the context lines that were giving me problems are the :86: lines
16:42:51 <Pseudonym> Yeah, this is similar to MARC in principle.
16:43:00 <t0mas> because that description belongs to the transaction on the previous line..
16:43:08 <t0mas> and it can have multiple lines..
16:43:23 <Pseudonym> Right.
16:43:35 <dmwit> Ah, someone else on the channel was trying to solve this problem recently.
16:43:39 * dmwit digs through hpaste
16:43:40 <Pseudonym> Now is it fair to say that "real" record lines start with a colon?
16:43:53 <Pseudonym> After the header, of course.
16:43:53 <jcreigh> dmwit: how did your efforts to get a multi-head setup up and running go?
16:44:09 <t0mas> Pseudonym: yes
16:44:16 <dmwit> t0mas: http://hpaste.org/1122
16:44:19 <dmwit> Is this related?
16:44:36 <t0mas> dmwit: does look like it yes
16:44:38 <dmwit> This groups consecutive lines that have a ':' at the beginning together into one list.
16:44:43 <tsp> man this is dumb
16:44:50 <tsp> you can't reassign a variable once it's used? omg
16:44:51 <dmwit> jcreigh: Haven't started yet, I'm too lazy. =P
16:45:08 <tsp> oh well, I'm not totally put off by this yet
16:45:12 <araujo> hello around here
16:45:12 <thorat> tsp: duck!
16:45:13 <dmwit> tsp: Hahaha, that's one of the foundations of the functional paradigm.
16:45:20 <jcreigh> tsp: see? It *is* different. :) Trust us, that's considered a feature.
16:45:26 <ftegularius> tsp: make sure to breathe ;)
16:45:32 <tsp> heh
16:45:34 <araujo> tsp, destructive updating is over-rated
16:45:38 <Pseudonym> t0mas: How do you close a record?
16:45:41 <ddarius> tsp: Mathematicians seem to get far without mutable state.
16:45:44 <sorear> @quote manual
16:45:45 <lambdabot> PaulAJ says: Mutable state is actually another form of manual memory management: every time you over-write a value you are making a decision that the old value is now garbage, regardless of what
16:45:45 <lambdabot> other part of the program might have been using it.
16:45:48 <t0mas> dmwit: that one is indeed useful
16:45:54 <t0mas> Pseudonym: a transaction?
16:45:56 <t0mas> not..
16:45:58 <Pseudonym> Yes.
16:45:58 <sorear> tsp: ^
16:46:10 <tsp> ddarius: I was taught that math has mutable state
16:46:12 <t0mas> but ":62F:C070307EUR1464,44" is closing the list of transactions
16:46:31 <Pseudonym> There's only one transaction in this file that you pasted, correct?
16:46:38 <tsp> x = 10, x/2 = 5, x = 2 - that's how I was tought to do math
16:46:38 <dmwit> tsp: I don't think so.  If you write "x = 5", then later it is still 5, no matter what...
16:46:45 <Pseudonym> Can you put more than one transaction in a file?
16:46:50 <t0mas> Pseudonym: no, two
16:47:03 <t0mas> Pseudonym: ":61:" is a transaction
16:47:10 <Pseudonym> Ah, right.
16:47:11 <dmwit> tsp: But, in that, x/2 = 5 still preserves x = 10!
16:47:16 <t0mas> ":86:" is a comment to the last transaction
16:47:19 <tsp> heh
16:47:21 <t0mas> (and it's optional)
16:47:26 <Pseudonym> I'm just trying to understand what's logically in a file.
16:47:27 * tsp reads again
16:48:19 <t0mas> Pseudonym: basically some headers.. and then :60F: to signal start of transactions.. then a lot of :61: + :86: and then closing it with :62F:
16:48:23 <Pseudonym> t0mas: I'll tell you the reason why I'm doing this.
16:48:30 <tsp> I started up hugs, it only says "hugs>" - where is the prelude> given by the examples?
16:48:50 <dmwit> tsp: It's okay, only GHCi prints Prelude>
16:48:51 <Pseudonym> If the file has some logical structure, and you can tell what the structure is, it's often best to split up the file into high-level things, then process each of those things independently.
16:48:56 <tsp> ah
16:49:02 <Pseudonym> So it starts off with ABNANL2A
16:49:06 <sorear> Generally, we recommend newbies use GHCi rather than Hugs
16:49:10 <Pseudonym> That's some kind of identifier, I assume.
16:49:13 <t0mas> Pseudonym: tnx, I'm trying to learn haskell.. so it's great if you explain how you would approach the problem.. helps me more than just a solution
16:49:18 <mgsloan> what's the point of hugs anymore?
16:49:19 <Pseudonym> Is it one of those per file?
16:49:23 <tsp> I don't have access to ghc
16:49:24 <Pseudonym> Or can you have more than one?
16:49:26 <tsp> sparc64
16:49:31 <t0mas> Pseudonym: a version identifier for the file format
16:49:31 <sorear> mgsloan: it starts three times faster, and is portable
16:49:35 <mgsloan> ah
16:49:35 <tsp> I have a windows box, but I hate coding on that
16:49:36 <Pseudonym> Right.
16:49:38 <Pseudonym> So that's a file header.
16:49:42 <t0mas> yes
16:49:45 <Pseudonym> Gotcha.
16:49:46 <t0mas> and it's just 1
16:49:50 <Pseudonym> OK, that simplifies things.
16:49:56 <Pseudonym> Because you can process that once.
16:50:02 <t0mas> indeed, but the order is not fixed
16:50:09 <t0mas> so you could interchange lines 2 and 3 for example
16:50:13 <Pseudonym> Sure.
16:50:18 <Pseudonym> But that file header has to come first.
16:50:47 <Pseudonym> So what you actually want here is to split not on lines, but on lines that start with a colon.
16:50:59 <t0mas> but the structure is headers :60F: N transactions :62F:
16:51:05 <Pseudonym> Sure.
16:51:15 <t0mas> where a transaction is :61: on 1 line, and optionally :86: for comments..
16:51:16 <Pseudonym> But the highest-level structure is actually:
16:51:27 <t0mas> oh yeah
16:51:27 <Pseudonym> <File header> <Lines that begin with a colon>
16:51:30 <t0mas> that's a great idea..
16:51:39 <t0mas> split on : would eliminate the multi-line-comment problem
16:51:46 <Pseudonym> Right.
16:51:50 <tsp> holy crap, haskel has bignums by default
16:51:52 <tsp> heh
16:51:54 <Pseudonym> And you can deal with "lines" that contain '\n's.
16:51:58 <tsp> ah, its just my 64 bit platform
16:52:10 <Pseudonym> > 2^129
16:52:12 <LoganCapaldo> > 3438883233731283718371937912737389173721739321
16:52:12 <lambdabot>  680564733841876926926749214863536422912
16:52:14 <lambdabot>  3438883233731283718371937912737389173721739321
16:52:25 <Pseudonym> No problem with bignums here.
16:52:26 <tsp> oh
16:52:28 <LoganCapaldo> Pseudonym's was shorter _and_ more impressive :)
16:52:28 <tsp> lol
16:52:40 <tsp> > 2147483649
16:52:41 <lambdabot>  2147483649
16:52:47 <sorear> > 2147483649 :: Int
16:52:47 <tsp> neat
16:52:48 <lambdabot>  -2147483647
16:52:52 <tsp> crap
16:53:01 <Pseudonym> t0mas: The reason why this "works" in Haskell is because of lazy evaluation.
16:53:06 <sorear> you can tell it to use fixnums, if you want
16:53:14 <Pseudonym> You can logically split the whole file into "lines", but it will actually happen lazily.
16:53:16 <Pseudonym> As you need it.
16:53:33 <t0mas> Pseudonym: yeah, I've read about that... cool when searching in infinite sets etc..
16:53:36 <thorat> tsp: Integer != Int
16:53:36 <Pseudonym> Yeah.
16:53:55 <LoganCapaldo> > 2147483649 :: Integer
16:53:57 <sorear> > 3438883233731283718371937912737389173721739321 :: Integer
16:53:57 <lambdabot>  2147483649
16:53:57 <Pseudonym> In this case, parsing tricky file formats, if you can detect a high-level structure, then it's worth doing that.
16:53:57 <t0mas> feels kind of weird to actually load the entire file in a list.. but not if you know it's not actually doing that until you read the list
16:53:58 <lambdabot>  3438883233731283718371937912737389173721739321
16:54:01 <sorear> > 3438883233731283718371937912737389173721739321 :: Int
16:54:03 <lambdabot>  -540594119
16:54:03 <Pseudonym> Right.
16:54:05 <sorear> > 3438883233731283718371937912737389173721739321 :: Int64
16:54:07 <lambdabot>  -8691564024253960135
16:54:10 <sorear> > 3438883233731283718371937912737389173721739321 :: Word
16:54:12 <lambdabot>  3754373177
16:54:15 <sorear> > 3438883233731283718371937912737389173721739321 :: Double
16:54:17 <lambdabot>  3.438883233731284e45
16:54:20 <sorear> ...
16:54:22 <Pseudonym> t0mas, one more thing.
16:54:27 <Pseudonym> Please keep checking in with this.
16:55:01 <Pseudonym> I can imagine that a working SWIFT-MT940 parser is something that a lot of people might want.
16:55:18 <Pseudonym> And we like it when people contribute libraries.
16:55:26 <t0mas> ok, will do that
16:55:31 <Pseudonym> Thanks.
16:55:32 <dmwit> (And we can all help make suggestions/solutions if the problem is defined well enough.)
16:55:37 <t0mas> I have a working version in Java ;)
16:56:12 <t0mas> hm, 1 problem
16:56:47 <Pseudonym> Yes?
16:56:50 <t0mas> if I read the file.. and split on ":"
16:56:55 <Pseudonym> No.
16:56:59 <t0mas> the first header might give a problem?
16:57:00 <tsp> that is weird, I can't have a dynamic list of different types
16:57:08 <Pseudonym> You first want to read off the file header.
16:57:11 <Pseudonym> And then process the rest.
16:57:12 <dmwit> tsp: Check out tuples.
16:57:16 <t0mas> ok, how do I do that? :)
16:57:19 <dmwit> > (3, "Hi")
16:57:19 <tsp> tuples are neat
16:57:21 <lambdabot>  (3,"Hi")
16:57:30 <Pseudonym> @src lines
16:57:30 <lambdabot> Source not found. I've seen penguins that can type better than that.
16:57:34 <Pseudonym> Hmm.
16:57:40 <tsp> but can you define objects with them? e.g. players for muds, ships for a space system, etc
16:57:43 <Pseudonym> t0mas: You just want one "pass" of lines.
16:57:45 <tsp> or will I get to that eventually
16:57:52 <Pseudonym> firstLine :: String -> (String, String)
16:57:54 <t0mas> ah (head lines)
16:57:55 <t0mas> like that?
16:58:01 <Pseudonym> Something like that.
16:58:03 <dmwit> ?faq
16:58:03 <lambdabot> The answer is: Yes! Haskell can do that.
16:58:10 <dmwit> tsp: ^^
16:58:27 <Pseudonym> Passing it through lines and then merging lines in the tail is a good approach.
16:58:34 <Pseudonym> So long as you don't care about preserving line terminators.
16:58:40 <Pseudonym> Does the spec say what a line terminator is?
16:58:45 <t0mas> \r\n
16:58:49 <Pseudonym> OK.
16:59:06 <QtPlatypus> tsp: For the most part from what I've seen Haskell builds it structured types out of tupples.
16:59:14 <tsp> ah
16:59:20 <Pseudonym> So you pass it through lines, pull off the first line, and then merge lines in the tail, putting the \r\n back.
16:59:32 <t0mas> ok, merge can be done with foldr?
16:59:39 <dmwit> tsp: Well, often with special record syntax that makes accessing various bits easier.  But underneath, it's tuples.
16:59:45 <t0mas> or is that a bad approach? :)
16:59:54 <Pseudonym> t0mas: Probably, but it might be easier to just write a recursive function.
17:00:10 <dmwit> t0mas: What does merge do?
17:00:13 <dmwit> :t unlines
17:00:16 <lambdabot> [String] -> String
17:00:17 <dmwit> That?
17:00:25 <Pseudonym> dmwit: You want to do it selectively.
17:00:30 <dmwit> ah
17:00:30 <t0mas> if unlines adds \r\n back in.. yes
17:00:36 <t0mas> and if I don't really need the header?
17:01:21 <Pseudonym> t0mas: Throw it away, I guess.
17:01:27 <Pseudonym> do f <- readFile fname
17:01:38 <Pseudonym>     let (header:body) = lines f
17:01:45 <t0mas> ok
17:01:57 <Pseudonym> Modulo indentation.
17:02:32 <t0mas> ok
17:02:54 <t0mas> dmwit: you just linked to a hpaste with something quite like this..
17:03:03 <t0mas> was that code made to do the "split on :" part?
17:03:17 <dmwit> I'm not sure it's exactly what you want, now that I know a bit more about what you're doing.
17:04:10 <Pseudonym> @let
17:04:13 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:04:32 <dons> that's a bug in the regex lib, fixed in newer regex-*'s
17:05:15 <dmwit> What the hpaste does is, given a list of lines, concatenate all the consecutive ones that start with ':', and throw away any that don't start with ':'.
17:05:34 * sorear wishes a source of funding for dons to maintain lambdabot full time would just magically appear
17:05:45 <dons> i don't need funding. i need time.
17:05:57 <Pseudonym> t0mas: OK, here's an elegant solution.
17:05:57 <LoganCapaldo> I'd throw in a few bucks
17:06:04 <LoganCapaldo> but thats still not time
17:06:05 <dons> say, 2 extra days a week?
17:06:09 <Pseudonym> grouper _ (':':_) = False
17:06:15 <Pseudonym> grouper _ _ = True
17:06:19 <LoganCapaldo> its too bad you can't paypal time :)
17:06:30 <Pseudonym> map unlines . groupBy grouper $ body
17:06:30 <dons> yeah.
17:06:35 <thorat> dons: you could hire a starving haskell programmer to help
17:06:40 <thorat> with funding
17:06:56 <dons> i'd need funding to buy someone else's time then :-)
17:07:03 * ndm feels the same way as dons
17:07:24 <dmwit> ?hoogle (a -> Bool) -> [a] -> [[a]]
17:07:24 <stepcut> with funding, dons can finally afford a mail-order PhD, and then he'll have plenty of free time...
17:07:25 <lambdabot> No matches, try a more general search
17:07:27 <Pseudonym> t0mas: That basically says to group lines, making sure that lines that start with ':' are put in a different group than the line before.
17:07:34 <ndm> i don't need money, but if someone was to kill my girlfiend, we'd get Hoogle 4 faster
17:07:36 <dons> so, is everyone using xmonad yet.
17:07:37 <Pseudonym> Then apply unlines.
17:07:38 <dons> stepcut: right!!
17:08:05 <ndm> stepcut, more likely to bribe referrees so you have to spend less time polishing papers
17:08:28 <ddarius> ndm: While my girlfriend is a large portion of my time, killing her would not get it back.
17:08:28 <t0mas> Pseudonym: so.. groupBy groups the lines (split on ":"), then unlines concats the lines that end up in the same group?
17:08:39 <t0mas> and grouper is our definition to what groups we need?
17:08:42 <Pseudonym> Right.
17:08:45 <stepcut> maybe sorear can write dons thesis, and dons can work on lambdabot ?
17:08:45 <t0mas> and $ body?
17:08:47 <Pseudonym> ?type groupBy.
17:08:49 <Pseudonym> ?type groupBy
17:08:50 <lambdabot> parse error (possibly incorrect indentation)
17:08:52 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
17:08:58 <ndm> ddarius, if i killed her i'd probablyl have too much police/prison time - but if someone else did...
17:08:58 <t0mas> :t groupBy
17:09:00 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
17:09:05 <Pseudonym> t0mas: Actually, do lines.
17:09:07 <Pseudonym> Split on \r\n.
17:09:17 <dons> we *will* have to find a beginning/keen phd student to look after lambdabot soon.
17:09:19 <Pseudonym> Then group by that group criterion.
17:09:23 <ddarius> ndm: I wasn't talking about me killing her.
17:09:30 <Pseudonym> Then map unlines, to paste the groups back together.
17:09:35 <t0mas> Pseudonym: readFile, lines, then your part?
17:09:39 <Pseudonym> Right.
17:09:42 <sorear> stepcut: While I certainly like dynamic code loading, I have a nasty habit of losing interest in things after 2 months or so.
17:09:48 <t0mas> and... maybe a stupid question..
17:09:53 <t0mas> but what's the $ body part?
17:09:58 <thorat> ndm: can't you teach your gf haskell?
17:09:59 <t0mas> body is holding the file contents..
17:10:01 <t0mas> but ehm $?
17:10:07 <Pseudonym> t0mas: ($) is just function application.
17:10:15 <sorear> stepcut: Also, I have more experience with lambdabot than hs-plugins...
17:10:50 <t0mas> ah, to save some ( )
17:10:54 <Pseudonym> Right.
17:11:00 <Pseudonym> You can do (f . g . h) body
17:11:01 <t0mas> *looks stupid*
17:11:03 <Pseudonym> Or f . g . h $ body
17:11:08 <Pseudonym> Or you can f (g (h body))
17:11:15 <t0mas> could've looked that up ofcourse...
17:11:19 <Pseudonym> t0mas: Actually, that's one of the most frequenly asked questions.
17:11:19 <dmwit> or f . g $ h body
17:11:24 <t0mas> it's just an infix with really high priority?
17:11:28 <dons> sjanssen: http://programming.reddit.com/info/1crqr/comments/c1cta6 ? (our position is that this is true, but works for any modern system)?
17:11:29 <Pseudonym> Yeah.
17:11:29 <lambdabot> Title: xmonad : a lightweight X11 window manager in <400 lines of Haskell (reddit.com)
17:11:34 <t0mas> cool
17:11:35 <dmwit> t0mas: Really *low* priority.
17:11:43 <t0mas> ehm.. sorry.. true
17:11:43 <Pseudonym> Low PRECEDENCE.
17:11:54 <Pseudonym> I'm not sure what "priority" means in an operator precedence scenario.
17:12:08 <dons> Gwern: are you running a window manager without -lXinerama (even if you don't use it?)
17:12:09 <Pseudonym> But I got what you meant./
17:15:49 <t0mas> oh, now I'm here..
17:15:53 <t0mas> I also had another little problem
17:16:10 <t0mas> I have:
17:16:14 <t0mas> import :: FilePath -> IO [String]
17:16:30 <t0mas> map putStrLn (import "/home/tomas/dev/test.mt9")
17:16:30 <ddarius> "Once again grauenwolf, you demonstrate that you are a moron."
17:16:32 <t0mas> error :)
17:16:50 <Pseudonym> t0mas: First off, think about why that is.
17:16:52 <Pseudonym> :t map
17:16:53 <t0mas> Couldn't match `[String]' against `IO [String]'
17:16:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:16:56 <ndm> t0mas, its all in the monads
17:17:05 <Pseudonym> map takes a list as its second argument.
17:17:12 <Pseudonym> You're giving it IO of list of something.
17:17:23 <t0mas> hmhm
17:17:43 <t0mas> but...
17:17:47 <Pseudonym> You want one of the mapM or sequence functions, and I can never remember which is which.  So time to start showing types.
17:17:50 <Pseudonym> ?type sequence
17:17:53 <lambdabot>     Ambiguous occurrence `sequence'
17:17:53 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
17:18:01 <Pseudonym> ?type mapM
17:18:04 <lambdabot>     Ambiguous occurrence `mapM'
17:18:05 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
17:18:09 <Pseudonym> Gah.
17:18:21 <t0mas> :t mapM
17:18:21 <t0mas> mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
17:18:24 <lambdabot>     Ambiguous occurrence `mapM'
17:18:24 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
17:18:25 <t0mas> according to ghci
17:18:31 <Pseudonym> Right.
17:18:46 <t0mas> you mean that one?
17:18:56 <Pseudonym> ?hoogle (Monad m) => (a -> m b) -> [m a] -> m ()
17:18:57 <lambdabot> No matches, try a more general search
17:19:01 <Pseudonym> Erm.
17:19:20 <Pseudonym> Ah, sequence_ does the trick.
17:19:42 <Pseudonym> Or even better, mapM_
17:19:47 <t0mas> sequence_ :: (Monad m) => [m a] -> m ()
17:20:02 <t0mas> ok
17:20:03 <t0mas> mapM_ :: (Monad m) => (a -> m b) -> [a] -> m ()
17:20:04 <Pseudonym> import "whatever" >>= mapM_ putStrLn
17:20:10 <Pseudonym> Should do it.
17:20:43 <Pseudonym> sequence_ would also work.
17:21:33 <t0mas> and that shows that it groups correctly :D
17:22:25 <Pseudonym> You could also just do this:
17:22:37 <Pseudonym> import "whatever" >>= putStrLn
17:22:42 <Pseudonym> Though it wouldn't be prettier.
17:22:43 <Pseudonym> Err.
17:22:50 <Pseudonym> import "whatever" >>= print
17:22:52 <Pseudonym> ?t print
17:22:53 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
17:22:56 <ventonegro> t0mas, http://blogs.nubgames.com/code/?p=22
17:22:57 <Pseudonym> ?type print
17:22:58 <lambdabot> Title: Nub Games » Haskell IO for Imperative Programmers
17:23:00 <lambdabot> forall a. (Show a) => a -> IO ()
17:23:02 <Pseudonym> Yes.
17:23:16 <t0mas> ventonegro: I've read that :)
17:23:34 <t0mas> but only this morning
17:23:49 <t0mas> so it's all still a little new to me :)
17:24:01 <ventonegro> t0mas, http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
17:24:04 <lambdabot> Title: Do-notation considered harmful « Data.Syntaxfree, http://tinyurl.com/tlmrl
17:24:06 <ventonegro> keep reading :-)
17:27:46 <Pseudonym> I automatically tune out anything that ends with "considered harmful".
17:27:58 <t0mas> hehe
17:28:01 <Pseudonym> You just know it's going to be more noise than signal.
17:28:05 <jcreigh> "Considered harmful" considered harmful.
17:28:08 <Pseudonym> All due respect to syntaxfree.
17:28:18 <jcreigh> ...and I think somebody actually wrote an essay along those lines.
17:28:25 <Pseudonym> Probably.
17:28:32 <thorat> Provably
17:29:21 <shoffsta> when running yi, I get the error message:
17:29:24 <shoffsta> error: Could not run YiConfig.yiMain :: Yi.Yi.EditorM ()
17:29:28 <shoffsta> any ideas?
17:29:54 <sorear> how old is your yi?
17:30:04 <shoffsta> I just did a darcs get
17:30:35 <shoffsta> from http://www.cse.unsw.edu.au/~dons/yi
17:30:36 <lambdabot> Title: Index of /~dons/yi
17:30:45 <shoffsta> so it's a few minutes old :)
17:31:01 <LoganCapaldo> its too young!
17:31:05 <meester>  
17:31:09 <sorear> Yi's in fairly active development right now, your best bet is to complain directly to jean-phillipe-bernardy (aka jyp here)
17:31:18 <sorear> darcs changes for his email.
17:31:44 <shoffsta> ok, thanks
17:34:25 <t0mas> Pseudonym: and now I have split it on colons... I'm used to the imperative way of setting properties on an object according to what's in the now split statements
17:34:37 <t0mas> in haskell you would normally use an extra parameter for that right?
17:34:44 <t0mas> accumulating parameter was the word?
17:35:06 <Shimei> sorear: Is there much development on the vim-bindings or is it mostly emacs-directed?
17:35:21 <Shimei> (Yi, that is)
17:35:37 <LoganCapaldo> t0mas: or you could use State or Writer perhaps
17:36:04 <t0mas> *googles*
17:36:55 <t0mas> hm
17:36:56 <t0mas> ok
17:37:54 <ndm> @karma+ dcoutts -- making gtk2hs installation embarassingly easy (much easier than cabal programs!)
17:37:56 <lambdabot> dcoutts's karma raised to 43.
17:39:20 <sorear> cabal programs are hard to install?
17:39:35 <ndm> sorear, not really, but gtk2hs is very easy
17:39:42 <sorear> Shimei: it's supposed to handle both
17:39:54 <happy_nic> i've decided that until haskell gets a better records system, it's not the language for me.
17:40:11 <sorear> xerox: phillipa asked for your email a few hours ago (I told)
17:40:12 <byteshack> how can I play with Data.Set in ghci?
17:40:31 <xerox> sorear, yes thanks
17:40:39 <byteshack> say, I'd like to create a list of 2 sets, but ghci won't let me "import Data.Set"
17:40:50 <sorear> :m + Data.Set
17:40:52 <ddarius> :m +Data.Set
17:41:04 <sorear> the syntax is different for some dumb reason
17:41:20 <byteshack> weird, thanks
17:41:47 <waern> GHC stage restriction: instance for `Typeable1 HsDoc' is used in a top-level splice, and must be imported, not defined locally
17:41:53 <ddarius> Because there is no unimport in Haskell
17:42:01 <waern> ^ does anyone know why that restriction is there?
17:42:22 <ddarius> Simplicity most likely.
17:42:35 <sorear> waern: what are you trying to do?
17:42:42 <ddarius> Everything at the top-level in Haskell programs is (potentially) mutually recursive.
17:42:49 <thorat> what's the most convenient way to experiment with xmonad (xnest, a parallel x session)?
17:42:55 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/template-haskell.html#id3184998
17:42:57 <lambdabot> Title: 7.6. Template Haskell, http://tinyurl.com/29wwbz
17:43:06 <sorear> waern: ^^ explains a clause or two down
17:43:21 <sjanssen> dons: X11-extras does require the Xinerama headers.  We probably need to make this configurable
17:43:22 <dons> thorat: i'd just load it in your .xsession and start using it.
17:43:50 <dons> sjanssen: what systems don't come with Xinerama now?
17:43:55 <sjanssen> dons: on the other hand, I haven't seen a single complaint about this
17:44:39 <dons> right. just Gwern's speculative complaint (which might have been that he though he needed xinerama actually running to use it)
17:45:41 <waern> sorear, I took the binary-derive code and adapted it to GhcBinary and template-haskell. No it turns out you can't stand-alone derive instances for types you import and use in a splice :(
17:45:42 <Shimei> Speaking of X11-extras, it seems to require some pfesetup program that I have no idea how to obtain. Any clues?
17:45:51 <waern> No=Now
17:45:57 <sjanssen> Shimei: pfesetup?
17:45:59 <jcreigh> My thinking is, wait until we actually run into a case where somebody doesn't have Xinerama headers before we start using some really clever conditional compilation stuff.
17:46:06 <sjanssen> Shimei: all that is required is GHC
17:46:09 <dons> i'm just a bit wary, since even my 2 year old openbsd box has xinerama on it, nyone runing linux or a mac will be fine.
17:46:20 <dons> jcreigh: agreed.
17:46:24 <dons> Gwern: more info please.
17:46:33 <dons> Shimei: its a harmless warning.
17:46:44 <dons> typically cabal looks for about 30 things we never use :-)
17:46:58 <Shimei> Ohhhh. That makes sense now.
17:48:33 <ndm> makes sense, but still not a good idea...
17:49:00 <ndm> waern, have you seen the derive library?
17:49:03 <ndm> @where derive
17:49:04 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
17:49:16 <waern> ndm, nope
17:49:21 <dons> ndm, it based on that code, iirc.
17:49:31 <dons> waern: you were looking at the binary-derive stuff in Data.Binary?
17:49:37 <waern> dons, yep
17:49:41 <ndm> waern, it does the binary deriving stuff and more in a framework - if you want to play in that direction, using that is probably better
17:49:42 <waern> I've found the problem though
17:50:07 <waern> ah, okay, I'll look into it
17:50:11 <ndm> dons, similar idea, more generic implementation - i think you were going to move to my copy of deriving Binary since its easier to maintain - not sure if you ever did though
17:50:29 <sorear> ndm: can we have derive consume and produce ASTs?
17:50:34 <ndm> plus mine derives functors ;)
17:50:45 <sorear> ndm: that way we could have an alternate driver using TH
17:50:48 <ndm> sorear, what do you mean by that?
17:50:51 <sorear> ndm: --> less overhead
17:50:55 <dons> ndm, btw, we're getting some numbers now for the stream fusible lists, between 10 and 14%, and about double the number of fusion opportunities
17:51:17 <ndm> sorear, currently not - but patches welcome :) - in theory it shouldn't be too hard
17:51:19 <sorear> ndm: instead of DataType -> [Char], I want DataType -> HaskellAST
17:51:42 <ndm> sorear, you write it, you got it :) - should be easy, defining HaskellAST is the hardest bit, and thats not that hard
17:51:55 <ndm> dons, neat - whats the maximum improvement in any benchmark in nobench?
17:52:07 <ddarius> Language.Haskell.Syntax or whatever
17:52:21 <sorear> ndm: template haskell's AST definition and prettyprinter is theoretically portable - can we depend on it?
17:52:35 <waern> Language.Haskell.TH preferably?
17:52:44 <sorear> ndm: ie the modules will work on yhc even if splicing doesn't
17:52:49 <ndm> sorear, we depend on Data.Typeable and Data.Generics, we can depend on anything for the moment
17:53:11 <sorear> cool. /me gets hacking
17:53:33 <ndm> sorear, less dependencies == better (as always), but for this particular project, its GHC to run/compile etc, but the generated source must run everywhere
17:53:44 <ndm> but thats not a great restriction at all
17:54:15 <dons> there's more than 3000 fusion sites in ghc alone. quite fun!  
17:54:18 <dons> ndm, 55% faster for one.
17:54:25 <dons> several others at 50% faster.
17:54:31 <sorear> I also notice a great dearth of haddocks.  more opportunities!
17:54:39 <dons> but typically is about 10%
17:54:46 <dons> i.e. finding say, 10 fusion sites, instead of 4.
17:54:57 <dons> though happy and alex have a couple of hundred each.
17:55:23 <sorear> so, will I be able to bootstrap ghc in less than an hour now?
17:55:35 <ndm> dons, neat :)
17:55:38 <dons> sorear: no. all the rewrite rules will make compilation slower.
17:55:46 <dons> ;-)
17:55:57 <dons> we've not done list comprehensions either yet.
17:56:06 <sorear> I *LOVE* fancy data structures.
17:56:09 <dons> so some very comprehension-heavy code could improve quite a bit
17:56:10 <waern> hehe... asymptotically we will not be able to bootstrap GHC anymore
17:56:27 <dons> the more ghc has to think, the better the code :-)
17:56:30 <kc5tja> What are "fusions" in this context?
17:56:33 <dons> so you should want slow compile time.
17:56:37 <stepcut> dons: how many are slower ?
17:56:43 <sorear> Maybe someday I'll figure out a way to resolve rewrite rules in sub-linear time.
17:56:44 <dons> kc5tja: deforestation of intermediate data structures
17:56:55 <dons> stepcut: a couple of the really big ones, due to bugs in ghc's optimiser
17:57:00 <sorear> On second thought, maybe I should save that for my PhD ;)
17:57:02 <dons> but no programs should run slower (in theory)..
17:57:14 <ndm> sorear, i have a method that does sub-linear time rule application
17:57:21 <dons> since if fusion doesn't occur, it just reverts to the old implementation
17:57:55 <dons> kc5tja: e.g. map f . map g ==>  let a = map f in let b = map g a in b
17:58:02 <dons> can be fused to, map (f . g)
17:58:07 <dons> i.e. let a = map (f.g)
17:58:21 <dons> so the most costly the allocation for your data structure, the more you gain
17:58:34 <sorear> kc5tja: that's fine, but the fun part is when you have more than 1 function to fuse
17:58:40 <dons> (this is why with O(n) allocation for strict bytestrings, there's such a huge gain)
17:58:54 <dons> in fact, a strict pure type has more to gain, i think, than a lazy list.
17:58:56 <sorear> kc5tja: when you have 40+ functions, you *really* don't want 1600 rewrite rules
17:59:19 <kc5tja> ??
17:59:23 <sorear> kc5tja: the fun part of fusion is doing it with only 80 rules, which dons' system can do
17:59:28 <dons> sorear: i don't think that was kc5tja's question.
17:59:40 <sorear> actually, it can work with only 1 rule, but it is faster with more...
17:59:43 <kc5tja> No, it wasn't.  :)
17:59:45 <dons> sorear: well, it has only 1 rule really ;-)
18:01:10 <dons> kc5tja: here's the library-based rewrite rule for map fusion:
18:01:11 <dons> {-# RULES
18:01:12 <dons>     "STREAM.map/map" forall f g s.
18:01:12 <dons>         map f (map g s) = map (\x -> f (g x)) s
18:01:12 <dons>  #-}
18:01:14 <kyevan> Yay. ghci has history in the interactive mode ^_^
18:01:31 <dons> so, if you ever see two maps applied to each other, you can turn it into a single traversal of a function body that does twice the work
18:01:32 <sorear> kyevan: type \t\t
18:02:09 <kyevan> Oooh. Hmm. Obviously uses libreadline :P
18:02:10 <dons> kc5tja: of course, this is only true if f and g are non-sideeffecting
18:02:57 <sorear> I think it's true even in the lazy effectful case.
18:03:06 <sorear> it's false strict effectfully
18:03:15 <kc5tja> sure
18:03:31 * kc5tja eats solar cooked ravioli.
18:04:25 <t0mas> tnx everybody..
18:04:28 <t0mas> 3am here
18:04:33 <t0mas> so really bed time :)
18:04:44 <Pseudonym> Night.
18:04:47 <Pseudonym> Good luck with it.
18:04:48 <t0mas> I hope I'll get the MT940 parser finished tomorrow
18:05:00 <sorear> Usually at 3am I ought to go to bed -BUT- am too tired to know that
18:05:26 * sorear remembers he was going to hack TH into derive
18:05:48 * araujo packs sorear into a monad
18:06:02 * sorear binds araujo
18:06:08 <araujo> :-)
18:06:13 * kc5tja packs on the pounds
18:07:21 <jcreigh> hmm, I used to be on dialup, but now I'm totally spoiled: "What? A WHOLE HOUR to download an ISO?"
18:08:15 * ddarius downloaded all the Abelson and Sussman lecture videos over a dialup connection.
18:08:19 <sorear> it takes me a WHOLE NINETY MINUTES to compile GHC.  can they make it any slower?
18:08:49 <dons> sorear: no it doesn't. your cpu is deprecated. please upgrade.
18:08:50 <sorear> hm, I haven't recompiled ghc in almost a month.
18:09:05 <ndm> sorear, compile Yhc - much faster
18:09:06 * sorear fixes
18:09:42 <dons> ndm, so has that slowdown wrt. nhc been identified yet?
18:09:43 <sorear> is it safe to nuke a ghc build directory without uninstalling first?
18:09:50 <dons> sorear: sure.
18:10:01 <ndm> dons, not yet - Tom hasn't really tried, we had darcs problems and now he's not been around for a while
18:10:02 <sorear> just checking...
18:10:25 <sorear> Ayhi is currently suffering from a lack of motivation...
18:10:31 <ihope> We all know that nukes are the safest way to go about doing things, especially if they're from orbit.
18:10:40 <sorear> too bad it isn't advanced enough to release
18:10:44 <dons> sjanssen: so who set up xmonad.org for us?
18:10:52 <dons> i think we'll need an account to update the front page.
18:10:53 <sorear> fantasma
18:11:06 <dons> or can we get it redirected to a haskell.org url?
18:11:19 <dons> i.e like to take haskell.org/xmonad actually, and just have xmonad.org redirect there.
18:11:34 <sjanssen> dons: I think a redirect can be arranged
18:11:37 <sjanssen> @seen fantasma
18:11:37 <lambdabot> Last time I saw fantasma was when I left #darcs, #gentoo-haskell, #gentoo-uy, #ghc, #happs, #haskell, #haskell-blah, #haskell-overflow, #haskell.de, #haskell.dut, #haskell.es, #haskell.fr, #jtiger, #
18:11:38 <lambdabot> montevideolibre, #oasis, #parrot, #perl6, #scannedinavian and #unicycling 21d 20h 21m 15s ago, and .
18:11:46 <sorear> lambdabot!!
18:11:49 <sjanssen> that can't be right
18:12:12 * sorear greps
18:12:18 <sorear> /var/cache/stefan-downloads/irclogs/www.cse.unsw.edu.au/07.03.16:20:21:21 <fantasma> sucessful =~ completing the project?
18:12:23 <sorear> most recent in my logs
18:12:27 <jdrake> Is there a way to measure the memory usage in a program? I am trying to compare two different implementations of an algorithm, and would like memory comparisons.
18:12:40 <dons> ghc -prof -auto-all -O ?
18:12:45 <sorear> actually, 07.03.16 is the last day in my logs
18:12:47 <dons> or is this for a non-haskell program?
18:12:53 <ndm> jdrake, yes - +RTS -t
18:12:54 <jdrake> This is on Linux, and the alternative program is in Python, the main is haskell.
18:13:06 <sorear> jdrake: get a real os
18:13:09 <dons> ah, there's 'top', and the gtop lib binding.
18:13:16 <dons> sorear: unhelpful.
18:13:27 <ndm> its easy on windows :)
18:13:27 <sorear> jdrake: OpenBSD 'time' will tell you peak mem usage
18:13:43 <kyevan> Insane, haskell -> clr compilers >_>
18:13:44 <sorear> well, getrusage anyway
18:13:56 <sorear> <- Linux user
18:14:08 <jdrake> sorear: When you can demonstrate accelerated graphics on OpenBSD, then I might consider.
18:14:19 <dons> Gwern: around?
18:14:36 <sorear> Someday I should force myself to use *BSD for a few weeks.
18:14:47 <sorear> It's not like I use graphics period or a laptop.
18:14:51 <dons> sorear: see, not helpful. try to provide accurate, helpful assistance rather than suggesting using a different OS :/
18:15:01 <DukeDave> Hey gang, I don't suppose there exists an inverse to unlit ?
18:15:10 <jdrake> GNU time is supposed to have a --format, but I can't seem to get it to work.
18:15:13 <sorear> sed 's/^/> /'
18:15:30 <sorear> jdrake: it gives 0's, because linux stupidly doesn't track that info
18:15:38 <DukeDave> woop, looks like it's time to learn sed ;)
18:15:48 <ClaudiusMaximus> pure:dyne Linux distro now has a haskell.dyne module :)  https://devel.goto10.org/puredyne/wiki/Haskell
18:15:51 <sorear> jdrake: the Shootout uses a perl binding to libgtop
18:16:07 <DukeDave> sorear, I don't suppose a command to drop all --'s
18:16:16 <jcreigh> DukeDave: you have a .hs, and you want .lhs?
18:16:18 <sorear> Are my disks slow or what?
18:16:20 <DukeDave> yeah
18:16:22 <sorear> stefan@stefans:/usr/local/src$ time rm -rf ghcbuild
18:16:22 <sorear> real    0m30.209s
18:16:22 <sorear> user    0m0.072s
18:16:22 <sorear> sys     0m10.781s
18:16:50 <sorear> DukeDave: why?  seems like an odd request
18:16:52 <DukeDave> so '--' -> '' and '' -> '>'
18:17:18 <dons> yeah, $ /usr/bin/time -l  seems to be useful on my system.
18:18:05 <DukeDave> I'm working on an academic piece (which I always use lit for) and my mess around .hs seems to have turned into a module of it's own right :)
18:18:20 <DukeDave> urm, s/it's/its
18:18:58 <jcreigh> DukeDave: try sed -e 's/^ *-- *//;t;s/^/> /'
18:19:06 <sorear> I'd probably just use M-x replace-regexp twice
18:19:21 <DukeDave> jcreigh, will that over write orig?
18:19:28 <DukeDave> not that I don't trust you ;)
18:19:30 <jcreigh> DukeDave: no.
18:19:31 <sorear> but if your OS doesn't support that command, sed iis your firend
18:19:45 <DukeDave> sorear, vi user :)
18:19:48 <jcreigh> DukeDave: do sed -e 's/^ *-- *//;t;s/^/> /' InputFile.hs > OutputFile.lhs
18:19:56 <sorear> :%s/^/> /
18:20:04 <sorear> :%s/^> --//
18:20:08 <sorear> in sequence
18:20:15 <jcreigh> or that. :)
18:20:49 <kyevan> How well can haskell (theoreticaly) be compiled for extremely limited platforms? (Say, ranging from old palm pilots to the GBA)
18:20:55 * kyevan never liked emacs
18:21:00 <kyevan> in fact...
18:21:01 <TSC> Wouldn't you also have to put space between the comment and code lines?
18:21:15 <kyevan> I think lambdabot has a quote about emacs from me >_>
18:21:27 <sorear> @quote kyevan emacs
18:21:27 <lambdabot> kyevan says: Emacs makes my head hurt almost as much as haskell!
18:21:34 <sorear> that?
18:21:50 <DukeDave> TSC, yup,
18:21:54 <LoganCapaldo> emacs makes my fingers hurt
18:21:54 <DukeDave> but cheers!
18:21:57 <stepcut> kyevan: do you want a haskell compiler running on the platform? Or do you just want to compile Haskell programs for the device ?
18:21:57 <LoganCapaldo> head not so much
18:21:59 <dons> kyevan: nhc98 has been historically used on very small systems.
18:22:16 <dons> its not so much the language per se. but rather the compiler you use.
18:22:56 <sorear> kyevan: Turner had a compiler (for a subset of Miranda) which eliminated garbage collection completely - I think it predated google, but it was called the listless transformer
18:23:02 <sorear> dunno how useful it was
18:23:05 <DukeDave> ah, "emacs: an operating system that can also be used to edit text"
18:23:23 <sorear> I know about it because of a reference in a book itself three years older than I
18:24:22 <kyevan> stepcut: Compiling on a larger system, but to a smaller one.
18:24:31 <kyevan> (CCing)
18:24:44 <sorear> kyevan: you might also be interested in Oleg and Shan's ICFP2007 paper
18:24:55 <sorear> @google Lightweight static resources
18:24:57 <lambdabot> http://lambda-the-ultimate.org/node/2106
18:24:57 <lambdabot> Title: Lightweight static resources | Lambda the Ultimate
18:25:07 <sorear> disclaimer: I haven't read ita
18:25:09 <stepcut> kyevan: the yhi runtime could probably be made to run on a number of small platforms, but the first step would be to remove the dependency on libgmp
18:25:41 <dons> but isn't this what nhc98 was built for?
18:25:46 <sorear> there are ways yhi could be made much smaller
18:25:56 <sorear> stepcut: gmp isn't a yhi dependency
18:26:10 <sorear> stepcut: yhc-base uses the FFI to call gmp functions
18:26:22 <sorear> stepcut: so any york runtime would suffer
18:27:06 * sorear stefan@stefans:/usr/local/src/ghcbuild$ /usr/bin/time make -j2 &> make.log &
18:27:12 <sorear> @botsnack
18:27:12 <lambdabot> :)
18:28:34 <stepcut> sorear: ah, well, yhc-base must be hacked then
18:29:06 * dmwit is using xmonad under a Xinerama-alike!
18:29:14 <jcreigh> dmwit: woot!
18:29:18 <jcreigh> dmwit: how does it work?
18:29:50 <dmwit> Some things are a little bit odd.
18:29:54 <jcreigh> modkey-w to switch to monitor 1, modkey-e to switch to monitor 2, shift+ either of those to move a window to that monitor. (Rather, the workspace on that monitor)
18:29:59 <sorear> Load average at 2.04 and rising.
18:30:19 <stepcut> sorear: this is as far as I got: http://www.mail-archive.com/glasgow-haskell-users%40haskell.org/msg11147.html
18:30:20 <dmwit> For example, if there are no windows open on screen 2, and I type, it appears on screen 1.
18:30:21 <dons> dmwit: "Xinerama-alike" ?
18:30:22 <lambdabot> Title: Re: bignums, gmp, bytestring, .. ?, http://tinyurl.com/yu22t4
18:30:33 <sorear> stepcut: that's a ghc url :)
18:30:35 <dmwit> dons: It's TwinView, which sends Xinerama info to X.
18:30:40 <sorear> stepcut: ghc /= yhc
18:30:42 <dons> oh, interesting.
18:30:53 <dons> dmwit: you're the first user for us, under this system.
18:31:05 <dmwit> Also, dmenu appears along the top of both screens, but I don't think that's xmonad's fault.
18:31:21 <dons> yeah, that's just dmenu doing its thing
18:31:26 <dons> its not designed for Xinerama
18:31:33 <stepcut> sorear: right... but that messages is about trying to build yhc for palmos...
18:31:50 <jcreigh> yes, dmenu does that for me too. My workaround is to not care. :)
18:31:59 <dons> we should write our own :-)
18:32:16 <dons> though a dmenu-like status bar might be an easier place to start
18:32:16 <dmwit> I'm not totally sure yet, but I think you've made a convert. =)
18:32:33 <dons> ooh nice. well, i've switched for the last few weeks and don't miss dwm
18:32:40 <dmwit> I will now have to restructure my entire desk.
18:32:49 <dons> its certainly more stable than dwm was after 2 weeks ;-)
18:32:55 <dmwit> =P
18:33:01 <jcreigh> dmwit: cool! If you have any xinerama-related bug reports/suggestions/feature requests, please ping me with them.
18:33:08 <dmwit> Oh, I will.
18:33:13 <dons> screen shots of multiple screens would be cool.
18:33:14 <dmwit> (But first I'll try to fix 'em. ;-)
18:33:38 <sorear> 2.27 and levelling...
18:33:48 <dmwit> Ooo, knowing which screen is active is WAY confusing when the number of windows open is sparse.
18:34:31 <jcreigh> dmwit: yeah...
18:34:39 <dons> yeah, needs statusbar support
18:35:32 <dmwit> dons: The screenshots aren't too impressive -- they're just two screens, next to each other. =P
18:35:39 <jcreigh> yes, a statusbar is the main thing we're missing.
18:35:51 <dmwit> Well, now I'll have to start hacking on xmonad for real.  Shame on you!
18:36:01 <dons> the plan is an external popup/dmenu style statusbar
18:36:08 <dons> using the state info logged to stderr currently
18:36:25 <dons> so basically take the dmenu framework, and port it to haskell
18:36:28 <dmwit> dons: This means somehow sending xmonad a request to reserve space for it, though, right?
18:36:31 <dons> to simply display text from stdin in a small window
18:36:37 <dmwit> ?go dzen
18:36:40 <lambdabot> http://www.dzentreefarm.com/
18:36:40 <lambdabot> Title: Welcome
18:36:43 <dons> dmwit: that's possible.
18:36:49 <dmwit> ?go gotmor dzen
18:36:52 <lambdabot> http://gotmor.googlepages.com/dzen
18:36:53 <lambdabot> Title: gotmor - dzen
18:36:53 <dons> it wouldn't be hard for xmonad to be aware of the menu bar
18:37:05 <dons> but if its like dmenu, we don't care
18:37:36 <dmwit> I think dzen may already do what we need for a status bar.
18:37:53 <dons> ah dzen. right!
18:38:01 <dons> i was hoping some dwm-ish code had been written.
18:38:21 <dons> yes, we should look into this.
18:39:36 <dmwit> dons: State is really printed to stderr?? =(
18:39:50 <jcreigh> dmwit: well, it's just for debugging right now.
18:40:01 <dmwit> ok
18:40:08 <jcreigh> you can see the log in ~/.xsession-errors
18:40:25 <sorear> @users
18:40:26 <lambdabot> Maximum users seen in #haskell: 337, currently: 291 (86.4%), active: 41 (14.1%)
18:40:58 <dons> dmwit: the point is that the state is serialisable, already.
18:41:13 <dons> jcreigh: hmm. except for the screen/workspace split eh?
18:41:22 <dmwit> So, clicking in a window should focus that window.  (Ditto scrolling.)  Where should I look to figure out how to make this happen?
18:41:22 <dons> since our internal state type isn't unified with the xinerama patches yet.
18:41:27 <dons> clicking?
18:41:38 <dons> (yes, maybe that should work).
18:41:50 <dons> you should grab the dwm 3.8 source, and look at how they handle mouse events.
18:42:07 <dmwit> Okay.
18:42:08 <dons> then add mouse handling to X11-extras, and finally, code in Main.hs to process mouse events.
18:42:17 <dmwit> (I'll use 3.7, though, that's what I have already.)
18:42:33 <dmwit> Ooo... okay, this should be good. =P
18:43:00 * dmwit goes to rearrange his desk.
18:43:47 <jcreigh> hmm, dzen2 isn't xinerama-aware. :)
18:44:11 <dmwit> jcreigh: No surprises there. =)
18:44:47 <jcreigh> oooh, but maybe we can pass geometry in...
18:45:15 <jcreigh> haha, you can.
18:47:55 <hpaste>  chessguy pasted "This code typechecks...but isn'" at http://hpaste.org/1138
18:48:16 <chessguy> bah, did LB just announce a paste from me?
18:48:20 <sorear> no
18:48:23 <chessguy> err, hpaste
18:48:26 <stepcut> yes
18:48:28 <sorear> lb never announces pastes
18:48:47 <chessguy> sorear: i corrected myself, don't be so dumb
18:48:48 <sorear> indeed, it never has
18:49:02 <chessguy> isn't that code dangerous?
18:49:23 <sorear> why would it be?
18:49:29 <chessguy> e.g., what if foo and par actually produced real lists?
18:49:31 <ndm> chessguy, if people abuse something then it can be made safer - always trust people first
18:49:48 <chessguy> s/par/bar/
18:49:57 * ndm grabs a stick from the wrong end
18:50:05 <chessguy> couldn't foobar return a list containing 2 different types?
18:50:28 <sjanssen> chessguy: no
18:50:32 <LoganCapaldo> how?
18:50:41 <sorear> chessguy: if it did, foo and bar would cease to be polymorphic enough
18:50:43 <ndm> chessguy, they both return any Meh, not a particular Meh of their choosing
18:51:23 <chessguy> ohhhh, so the Meh they return would have to be typecast into a specific Meh?
18:51:52 <sorear> typecast is a dirty word here
18:51:58 <stepcut> chessguy: typecast is not really the right word, but yes
18:52:00 <LoganCapaldo> @ty cast
18:52:02 <ndm> chessguy, at the choosing of caller, not foo or bar
18:52:03 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
18:52:08 <chessguy> i meant ::
18:52:16 <chessguy> whatever the correct term is
18:52:20 <ndm> chessguy, but its not a type  cast, they are generated as a different type
18:52:27 <ndm> typecast is changing a type after construction
18:52:34 <ndm> this changes the type before construction
18:52:51 <jcreigh> what *is* the correct term for constraining a type via an explict type signature?
18:52:55 <chessguy> ok, but the point is, the result is a general Meh
18:53:00 <sorear> restricting?
18:53:09 <jcreigh> sorear: oh, okay. :)
18:53:43 <ndm> chessguy, yes
18:53:44 <chessguy> so different items in the result could have different type, as long as all the types are instances Meh
18:54:04 <ndm> chessguy, no - they must all be the same type of Meh
18:54:28 <jcreigh> > map show [1, 'a']
18:54:29 <LoganCapaldo> its a list of ms
18:54:29 <lambdabot>   add an instance declaration for (Num Char)
18:54:29 <lambdabot>     In the expression: 1
18:54:30 <stepcut> chessguy: if you try to use foobar, you will eventually have to specify (directly, or indirectly) specific types for the 'b' and the 'm', which will then select the right instances from Bar and Meh
18:54:34 <jcreigh> ^^ doesn't work
18:54:35 <LoganCapaldo> not a list of mehs
18:54:38 <LoganCapaldo> *Mehs
18:54:58 <LoganCapaldo> its a list of m s where m must be an instance of Meh
18:55:22 <chessguy> but foo and bar could generate different kinds of Mehs
18:55:53 <LoganCapaldo> but they don't
18:56:04 <chessguy> says who?
18:56:09 <LoganCapaldo> says the code
18:56:19 <chessguy> where?
18:56:27 <LoganCapaldo> foo _ = []
18:56:28 <stepcut> chessguy: when you use 'foobar'
18:57:31 <stepcut> chessguy: when you use foobar it your code, the type checker will eventually pick specific types for it, like,  foobar :: Int -> [Char], depending on the context
18:58:00 <stepcut> once it knows the specific types, then that will force it to use instances of foo and bar that also have the type Int -> [Char]
18:58:31 <stepcut> if you code never forces an particular type, then you get an error like:
18:58:32 <stepcut>     Ambiguous type variable `m' in the constraint:
18:58:45 <LoganCapaldo> if you are worried that the equiv to foo _ = [1] and bar _ = [True] might work
18:58:51 <LoganCapaldo> don't be
18:59:05 <sorear> instance Num Bool where ...
18:59:28 <LoganCapaldo> since then it _would_ complain
18:59:51 <chessguy> i'll have to experiment with it to see where exactly it gives an error
18:59:51 <stepcut> yikes, I sure made a lot of typos :(
18:59:51 <tsp> I'm just curious - since haskell is a compiled language and all, does it support intraspection?
19:00:16 <tsp> I guess that's sort of a moot point since it's not OO
19:00:18 <jcreigh> tsp: Haskell has both compilers and interpreters available.
19:00:45 <jcreigh> tsp: and it depends on what you mean
19:00:47 <LoganCapaldo> tsp: Its not really the lack of OOness. the more interesting issue with introspection is the lazy evaluation
19:00:59 <LoganCapaldo> but show is a nice function
19:01:07 <LoganCapaldo> > show True
19:01:09 <lambdabot>  "True"
19:01:13 <LoganCapaldo> > show [1, 2, 3]
19:01:15 <lambdabot>  "[1,2,3]"
19:01:41 <LoganCapaldo> > show . typeOf (3 :: Int)
19:01:42 <tsp> I think I'm put of by haskell not being OO :)
19:01:43 <lambdabot>  Couldn't match expected type `a -> b'
19:01:50 <LoganCapaldo> > show . typeOf $ (3 :: Int)
19:01:51 <lambdabot>  "Int"
19:02:21 <tsp> > show tail (tail (tail [1,2,3,4])))
19:02:21 <lambdabot>  Parse error
19:02:22 <HairyDude> @t typeOf
19:02:22 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
19:02:30 <HairyDude> ?t typeOf
19:02:30 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
19:02:30 <tsp> ? that should have worked
19:02:35 <LoganCapaldo> @ty typeOf
19:02:37 <lambdabot> forall a. (Typeable a) => a -> TypeRep
19:03:03 <tsp> > tail (tail [1,2,3])
19:03:05 <lambdabot>  [3]
19:03:10 <HairyDude> hmm, thought I'd seen people using ?t or @t
19:03:15 <tsp> all that to get the third element, and its a list
19:03:20 <LoganCapaldo> just t is ambigous
19:03:24 <sorear> haskell has some introspection facilities
19:03:26 <HairyDude> yeah
19:03:30 <sorear> :t ?hairyDude
19:03:33 <sjanssen> HairyDude: :t is special
19:03:33 <lambdabot> forall t. (?hairyDude::t) => t
19:03:38 <HairyDude> ah right
19:04:04 <HairyDude> what on earth is ?hairyDude?
19:04:12 <LoganCapaldo> > [1,2,3] !! 2
19:04:14 <lambdabot>  3
19:04:18 <sorear> implicit parameter
19:04:24 <tsp> oh
19:04:34 <sorear> an arcane ghc ext that is mostly useful in :t
19:04:52 <LoganCapaldo> > (\(x:y:z:_) -> z) [1,2,3]
19:04:54 <lambdabot>  3
19:05:07 <sorear> :t do { foo <- ?action False ; print foo } -- what type does action need to have?
19:05:10 <lambdabot> (?action::Bool -> IO Integer) => IO ()
19:05:20 <sorear> defaulting :(
19:05:28 <tsp> how do you guys figure this out?
19:05:38 <tsp> I thought haskell would be easy like python
19:05:41 <tsp> lol
19:05:58 <stepcut> tsp: Haskell is a different kind of easy
19:06:02 <tsp> it could probably find me the hundredth fibonacci number in an hour
19:06:36 * jcreigh waits for someone to fire off a lambdabot one-liner...
19:06:56 * LoganCapaldo is trying to but is afraid of making a mistake
19:07:09 <tsp> heh
19:07:23 <LoganCapaldo> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 99
19:07:25 <lambdabot>  354224848179261915075
19:07:36 <tsp> > let f x = x+5 in [f 1, f 2,f 3,f 4]
19:07:37 <lambdabot>  [6,7,8,9]
19:08:00 <jcreigh> I always thought fib started 0,1 not 1,1
19:08:00 <tsp> LoganCapaldo: that's neat - have you been using haskell for years?
19:08:03 <LoganCapaldo> > let f x = x + 5 in map f [1..4]
19:08:04 <lambdabot>  [6,7,8,9]
19:08:09 <tsp> ah, map
19:08:23 <tsp> I can't get how that works though - your not telling map to map anything
19:08:27 <ventonegro> > map ((+) 5) [1..4]
19:08:28 <lambdabot>  [6,7,8,9]
19:08:32 <LoganCapaldo> tsp: years? ha!
19:08:39 <jcreigh> http://www.research.att.com/~njas/sequences/A000045
19:08:41 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
19:09:01 <sorear> > fix((1:).scanl(+)1) !! 100
19:09:01 * sorear already tested in /msg
19:09:01 <sorear> @botsnack
19:09:02 <lambdabot> :)
19:09:03 <lambdabot>  573147844013817084101
19:09:03 <sorear> @activity 60
19:09:04 <lambdabot> 5*total 5*#haskell
19:09:10 <sorear> @jcreighsnack
19:09:10 <lambdabot> Unknown command, try @list
19:09:15 <sorear> GRR.
19:09:29 <ventonegro> fix, the one I don't get
19:09:37 <tsp> > let square x = x * x in map square [1..5]
19:09:39 <lambdabot>  [1,4,9,16,25]
19:09:44 <jcreigh> sorear: isn't that the 102nd fibonacci number?
19:09:54 <tsp> using haskell for a day and already got that far
19:10:14 <tsp> I'm guessing I can tweak that a bit to
19:10:19 <ventonegro> > map (\x -> x * x) [1..10]
19:10:20 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
19:10:22 <sorear> jcreigh: no, it's the 100th. I count from 0 and my fib seq starts 1, 1, ...
19:10:24 <sorear> :)
19:10:30 <TSC> tsp: You're well on your way
19:10:30 <tsp> > let square x = x * x in map square [5..1]
19:10:31 <nominolo> @pl \x -> x * x
19:10:31 <lambdabot> join (*)
19:10:32 <lambdabot>  []
19:10:32 <jcreigh> off by one for starting 1,1... and off-by-one for !! 100...
19:10:47 <TSC> > map (^2) [1..5]
19:10:48 <lambdabot>  [1,4,9,16,25]
19:10:52 <nominolo> :t join
19:10:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:11:06 <tsp> oops, ^2
19:11:19 <tsp> > map (^2) reverse [1..10]
19:11:19 <lambdabot>  Couldn't match expected type `[a]'
19:11:31 <TSC> > map (^2) (reverse [1..10])
19:11:32 <lambdabot>  [100,81,64,49,36,25,16,9,4,1]
19:11:38 <sorear> tsp: you can't map over a function, map isn't polymorphic enough
19:11:39 <tsp> damn, I was close
19:11:49 <tsp> map over a function?
19:11:50 <ventonegro> > map (^2) $ reverse [1..10]
19:11:51 <lambdabot>  [100,81,64,49,36,25,16,9,4,1]
19:12:01 <tsp> ah, so $ x is the same as (x)
19:12:02 <sorear> > fmap (*20) (+3) 10
19:12:04 <lambdabot>  260
19:12:05 <jcreigh> > (fmap (+2) (*3)) 5
19:12:07 <lambdabot>  17
19:12:14 <LoganCapaldo> @src ($)
19:12:15 <lambdabot> f $ x = f x
19:12:31 <tsp> ?
19:12:42 <nominolo> tsp, it just saves some parens
19:12:43 <sorear> > nubBy(((>1).).gcd)[2..] -- my favorite haskell oneliner
19:12:44 <tsp> ah
19:12:46 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:12:47 <jcreigh> > ((+2) . (*3)) 5
19:12:49 <lambdabot>  17
19:13:06 <tsp> > time
19:13:07 <lambdabot>   Not in scope: `time'
19:13:11 <tsp> > time.time
19:13:11 <lambdabot>   Not in scope: `time'
19:13:15 <jcreigh> function composition can be thought of as mapping a function over another function.
19:13:16 <tsp> piece of shit
19:13:22 <tsp> > Time.time
19:13:23 <lambdabot>   Not in scope: `Time.time'
19:13:29 <tsp> damn, this thing has no way to get he current time
19:13:33 <sorear> > System.Time.getCurrentTime
19:13:34 <lambdabot>   Not in scope: `System.Time.getCurrentTime'
19:13:38 <nominolo> @hoogle time
19:13:38 <lambdabot> System.Time :: module
19:13:39 <lambdabot> Time :: module
19:13:39 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
19:13:40 <sorear> > System.Time.getClockTime
19:13:41 <lambdabot>   Not in scope: `System.Time.getClockTime'
19:13:45 <sorear> @ty System.Time.getClockTime
19:13:45 <tsp> heh
19:13:45 <stepcut> tsp: lambdabot does not allow any IO
19:13:48 <lambdabot> IO System.Time.ClockTime
19:13:58 <sorear> ok, it's just not imported
19:13:58 <tsp> stepcut: it takes IO to get the curren ttime?
19:14:00 <LoganCapaldo> @localtime tsp
19:14:02 <lambdabot> Local time for tsp is Sun Mar 25 19:12:15 2007
19:14:11 <tsp> > import IO
19:14:12 <lambdabot>  Parse error
19:14:14 <tsp> heh
19:14:16 <stepcut> tsp: of course..
19:14:19 <TSC> tsp: Of course, because it will return a different value every time
19:14:20 <nominolo> tsp, mainly the I-part ;)
19:14:24 <tsp> oh
19:14:29 <DukeDave> Gah, stop rubbing it in, I remember when it was still Sunday :(
19:14:30 <tsp> yeah
19:14:58 <sorear> @remember DukeDave I remember when it was still Sunday
19:14:59 <lambdabot> Done.
19:15:22 <tsp> > sum $ map (^2) [1..10]
19:15:23 <lambdabot>  385
19:15:27 <tsp> I didn't think that would work
19:15:43 <tsp> this is cool
19:15:55 <HairyDude> sections are great
19:16:15 <DukeDave> well I think I've left my code in an undocumented and broken enough state; time for bed :(
19:16:33 <tsp> python would be um... print reduce(operator.add,map(lambda x: x ** 2, range(1,11)) I think
19:16:33 <LoganCapaldo> > [ x^2 | x <- [1..10] ] -- Oh honey honey
19:16:34 <stepcut> DukeDave: make sure you do a commit first, so no one else can build ;)
19:16:35 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
19:16:40 <sorear> > sum [ 1 | 5 <- map sum $ replicateM 10 [0,1] ] -- fun with list monad
19:16:42 <lambdabot>  252
19:16:56 <sorear> that's 5 choose 10
19:17:13 <Shimei> @where yi
19:17:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
19:17:34 <TSC> 10 choose 5, surely (:
19:17:46 <DukeDave> Haha, I think that's why whenever there's a group project now I'm always the loser kid left to the end :)
19:18:02 <tsp> ok, interesting proof of concept - I know haskell can do highschool math factors, but I just can't figure out how to do it
19:18:11 <sorear> factors?
19:18:19 <tsp> e.g. fact 12 = [1,2,3,4,6,12]
19:18:24 <DukeDave> that and most people still don't think a language without global variables is a real language :(
19:18:52 <HairyDude> ah, that's an unfold
19:18:58 <sorear> > (\num -> filter (\ fc -> (num `mod` fc) == 0) [1..num]) 12
19:19:00 <lambdabot>  [1,2,3,4,6,12]
19:19:06 <tsp> wo
19:19:18 <HairyDude> oh, sorry, wrong problem
19:19:28 <jcreigh> I think the pythonic way would be sum(x**2 for x in xrange(1,11))
19:19:41 <tsp> ah, sum
19:19:41 <jcreigh> note how (x)range doesn't include its endpoint...grr...
19:19:49 <tsp> they made it a builtin?
19:19:54 <jcreigh> tsp: yeah
19:20:12 <tsp> weird
19:22:16 <tsp> how do I do n mod 2 in haskell?
19:22:22 <tsp> > 10%5
19:22:23 <lambdabot>  2%1
19:22:24 <jcreigh> > 5 `mod` 2
19:22:26 <lambdabot>  1
19:22:27 <LoganCapaldo> > 10 `mod` 2
19:22:29 <lambdabot>  0
19:22:32 <syntaxfree> may I please use a curse word?
19:22:45 <merus> what happened?
19:22:47 <Pseudonym> syntaxfree: So long as it isn't COBOL.
19:22:53 <LoganCapaldo> Only if its not "belgium"
19:23:15 <Pseudonym> Oh, yeah, Holy COBOL!  I forgot about "belgium".
19:23:21 <syntaxfree> JESUS FUCK. Xmonad is impressive.
19:23:28 <tsp> test x = [1]; doesn't want to work
19:23:36 <sorear> no ;
19:23:36 <Pseudonym> syntaxfree: That's not a curse, it's blashphemy.
19:23:37 <QtPlatypus> Only if is a string of charitors that can be described in less then 16 words.
19:23:48 * merus wants to drift from blackbox to xmonad now... but has work to do :(
19:23:51 <HairyDude> ?ty (%)
19:23:53 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
19:24:14 <sorear> QtPlatypus: strings of creditors are generally best described...
19:24:18 <ndm> sorear: http://www.cs.york.ac.uk/fp/darcs/catch/catch.htm
19:24:21 <lambdabot> Title: Catch: A User Manual
19:24:21 <sorear> HairyDude: rational constructor
19:24:29 <tsp> I'm trying to write fact in a slightly more verbose way
19:24:29 <sorear> ndm++
19:24:33 <tsp> http://tspivey.freeshell.org/Test.hs
19:24:34 <HairyDude> ?ty (:%)
19:24:36 <lambdabot> Not in scope: data constructor `:%'
19:24:39 <HairyDude> hm
19:24:47 <tsp> it doesn't even want to compile for some reason
19:24:49 <LoganCapaldo> you can't have :% :(
19:24:56 <ndm> sorear, thats the user manual - with a slight bit of example - if you have any suggestions please let me know
19:25:14 <LoganCapaldo> at least I don't think you're alowed to make arbitrary functions constructors
19:25:20 <sorear> LoganCapaldo: it's private, because there are invariants
19:25:23 <jcreigh> syntaxfree: you like it that much, eh? what do you find so impressive?
19:25:29 <ndm> its hard to believe everyone doesn't know the inner details of a compiler and can't read mon-arity first-order Haskell easily
19:25:31 <LoganCapaldo> yeah that's what I meant
19:25:44 <LoganCapaldo> can't encode the invariants in :%
19:25:47 <HairyDude> a constructor is a constructor if it's defined in a data or newtype declaration, and afaik nowhere else
19:26:01 <TSC> tsp: hpaste is handy for pasting code
19:26:09 <TSC> @where hpaste
19:26:09 <lambdabot> http://hpaste.org/new
19:26:22 <sorear> ndm: your Walkthrough of Risers section is a tad on the short side ;)
19:26:47 <sorear>      * Directory Treated as a list of all the .hs/.lhs files within it.
19:27:03 <sjanssen> syntaxfree: you're running xmonad?
19:27:08 <sorear> does this mean that my binary struct dirents will be interpreted as lines of text?
19:27:38 <HairyDude> ?google xmonad
19:27:40 <lambdabot> http://www.xmonad.org/
19:27:40 <lambdabot> Title: xmonad : a lightweight X11 window manager.
19:27:42 <hpaste>  tsp pasted "(no title)" at http://hpaste.org/1139
19:27:43 <sorear> (I imagine it probably means catch uses every files in the directory, but it seems a tad unclear)
19:27:47 <sorear> ooh, googlejuice!
19:28:08 <tsp> there it is
19:28:12 <TSC> tsp: you need "if n `mod` 2 /= 0 then" for a start
19:28:23 <tsp> oh
19:28:37 <ndm> sorear, it does - i think - although I doubt many people will want to use that
19:28:49 <tsp> it gives me an error with the fact n = [1]; orw ahtever it is
19:28:51 <hpaste>  sorear annotated "(no title)" with "apposition binds tighter than division" at http://hpaste.org/1139#a1
19:29:05 <ndm> sorear, i wasn't sure what else to put in the walkthrough on risers, i just want it to be a case of "this is hello world for catch"
19:29:17 <TSC> tsp: Also, what type is fact supposed to be?
19:29:40 <hpaste>  sjanssen annotated "(no title)" with "style fixes" at http://hpaste.org/1139#a2
19:29:45 <TSC> tsp: (You might want `div` instead of /)
19:29:49 <hpaste>  sorear annotated "(no title)" with "fix comparison (integers are not booleans)" at http://hpaste.org/1139#a3
19:29:59 <tsp> fact? no idea
19:30:04 <tsp> its suposed ot take a number and return a list
19:30:31 <tsp> but I thought type inference would take care of it
19:30:31 <syntaxfree> sjanssen++
19:30:33 <syntaxfree> dons++
19:30:56 <TSC> Not quite; mod is used on integers, but / is used for fractional numbers
19:30:56 <ventonegro> > scanl (*) 1 [2..]
19:30:57 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
19:31:09 <TSC> So using both is going to confuse the type inference
19:31:19 <tsp> piece of crap
19:31:21 <tsp> heh
19:31:33 <LoganCapaldo> :t div
19:31:36 <lambdabot> forall a. (Integral a) => a -> a -> a
19:31:48 <tsp> :t x=5
19:31:50 <lambdabot> parse error on input `='
19:31:55 <tsp> :t 5.1
19:31:55 <LoganCapaldo> :t 5
19:31:58 <lambdabot> forall t. (Fractional t) => t
19:31:58 <lambdabot> forall t. (Num t) => t
19:32:20 <LoganCapaldo> :t (/)
19:32:20 <HairyDude> :t x==5
19:32:24 <lambdabot> Not in scope: `x'
19:32:24 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:32:32 <LoganCapaldo> :t ?x==5
19:32:34 <lambdabot> (?x::Integer) => Bool
19:32:47 <tsp> :t show
19:32:47 <ndm> sorear - wooops, i had forgot to push before sending you the link - try again now!
19:32:48 <sorear> haskell's bi-directional type inference doesn't play nicely with mixed operations
19:32:49 <lambdabot> forall a. (Show a) => a -> String
19:32:50 <HairyDude> ah, that's how it's useful
19:33:14 <tsp> I just want to code sockets :)
19:33:19 <sorear> ndm: oh, so it was shorter than you intended? :)
19:33:22 <tsp> and actually do something useful with this thing
19:33:22 <LoganCapaldo> So code sockets
19:33:34 <tsp> heh, I need to find if hugs has a socket lib
19:33:36 <sorear> @where network
19:33:37 <lambdabot> I know nothing about network.
19:33:40 <sjanssen> @google haskell irc bot tutorial
19:33:42 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
19:33:42 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
19:33:42 <sorear> meh.
19:33:49 <tsp> sweet
19:33:56 <sjanssen> tsp: ^^^ that link should help you
19:34:04 <sorear> lambdabot is written in haskell
19:34:04 <ventonegro> tsp, this list stuff is funny, but also useful
19:34:14 <jcreigh> so, is xmonadUsers > xmonadContributors yet? :)
19:34:39 <ndm> sorear, a lot shorter!
19:34:51 <sorear> I *think* I've contributed to xmonad, but I know I've never used it.
19:34:52 <tsp> I want to do everything in the hugs interactive interpreter to start, but it says syntax error when I type import Network
19:34:55 <ventonegro> tsp, i was very proud the first time i used liftM, zip, seq  and map in the same function :-)
19:35:05 <ndm> seq? yuk!
19:35:06 <sorear> tsp: :also Network IIRC
19:35:10 <sjanssen> compare xmonadUsers xmonadContributors == EQ -- I think
19:35:15 <ventonegro> ndm, i had to :-(
19:35:41 <sorear> tsp: for some dumb reason hugs and ghci use :-commands for other tasks
19:35:51 <sorear> tsp: also, hugs can't make definitions
19:35:54 <tsp> damn
19:36:01 <tsp> so I can't just do server="something"
19:36:01 <sorear> tsp: you need to put them in a file, or use ghci
19:36:06 <tsp> I need a box with ghci
19:36:10 <tsp> I'm on freebsd sparc
19:36:20 <tsp> maybe theres a windows port, as much as I hate windows
19:36:22 <sorear> ooh, sparc still exists?
19:36:25 <sjanssen> tsp: typing in a separate file and using :r to reload it is the standard practice
19:36:37 <sorear> <- i386 linux
19:36:44 <tsp> sjanssen: but I can't do a connect at that stage
19:36:53 <tsp> sock <- connectToServer
19:37:11 <tsp> I'm running on a ultra5
19:37:17 <tsp> ah, windows and vmware
19:37:19 <sorear> ghci works on windows, i386 linux, x86-64 linux, ppc linux, ppc Macosx, i386 macosx, i386 windows, ...
19:37:34 <HairyDude> if the point of dwm is that you customise the window manager by changing the source, isn't the same true for xmonad? hence every user is a developer
19:37:35 <sorear> at one point it supported sparc
19:37:53 <sorear> but that's quite bitrotted now from what I hear
19:38:01 <syntaxfree> bitrotten?
19:38:30 <Shimei> tsp: OT, but how is FreeBSD support for Sparc? I tried to get Linux working on my Ultra1 and more or less failed. ;)
19:38:37 <HairyDude> curse those irregular verbs
19:38:44 <sorear> hehe, ndm saz:
19:38:46 <sorear>    Next check that Yhc is able to compiler your code, if it cannot then fix either the code or Yhc until you have success.
19:38:48 <tsp> Shimei: it rocks - 66 day uptime so far
19:38:54 <HairyDude> hehe
19:38:57 <Shimei> HairyDude: I just changed a few keyboard shortcuts on my xmonad install. So yeah. :P
19:39:11 <tsp>  7:37PM  up 66 days, 15 mins, 10 users, load averages: 0.06, 0.01, 0.00
19:39:11 <tsp> FreeBSD fajrero 6.2-RELEASE FreeBSD 6.2-RELEASE #0: Fri Jan 12 23:30:59 UTC 2007     root@s-dallas.cse.buffalo.edu:/usr/obj/usr/src/sys/GENERIC  sparc64
19:39:47 <sjanssen> HairyDude: I think we can count "developers" as those who contribute patches to the main repository
19:39:52 <HairyDude> whether users actually contribute their patches back is a different question mind
19:40:27 <Shimei> Oh cool. I guess I'll go BSD on my ultra then. My biggest problem was that it just couldn't do DNS at all. Plus it died when upgrading to kernel 2.6.
19:41:08 <thorat> is anyone running dockapps in xmonad yet?
19:41:18 <sjanssen> thorat: what is dockapps?
19:41:32 <thorat> dockapps.org
19:41:34 <HairyDude> does xmonad work at all like wmii?
19:41:36 <thorat> like in window maker
19:41:44 <sjanssen> thorat: dockapps probably won't work well
19:42:44 <sjanssen> HairyDude: xmonad works like dwm.  dwm is like wmii's cousin from what I've heard
19:43:16 <HairyDude> I really ought to get my finger out and apply for an SoC project to implement P9 in Haskell, so I can script wmii in it :)
19:43:39 <sjanssen> HairyDude: you should just learn to love xmonad instead
19:43:49 <HairyDude> you would say that ;)
19:46:20 <QtPlatypus> What's P9?
19:46:51 <HairyDude> where did you get 400 LOC from, anyway?
19:47:15 <falconair> is the yi editor usable for daily newbie haskell experiments ?
19:47:22 <HairyDude> QtPlatypus: filesystem protocol of Plan 9 from Bell Labs, which is also used for controlling wmii
19:47:42 <thorat> HairyDude: isn't it 9p
19:47:52 <HairyDude> oops, yes it is
19:49:18 <jcreigh> HairyDude: we made it up. :) No, really, it's a count of non-whitespace, non-comment lines.
19:50:12 <jcreigh> LOC as a metric is kind of bogus anyway, and it seems like cheating to skip whitespace and comments, but I'm not the one who turned this into a LOC contest. :)
19:51:06 <thorat> how about NOT, number of types?
19:51:16 <HairyDude> [pwb@rhuidean xmonad]$ cat Main.hs | sed '/^\s*--/d;/^\s*$/d' | wc -l
19:51:16 <HairyDude> 275
19:51:17 <HairyDude> nice
19:51:30 <jcreigh> HairyDude: well, count XMonad.hs and StackSet.hs too :)
19:51:34 <LoganCapaldo> NOT seems like it would be confusing
19:51:46 <LoganCapaldo> Is more or less better?
19:51:48 <HairyDude> oh, I didn't notice XMonad.hs
19:52:11 <LoganCapaldo> (its probably some kind of hump like curve)
19:52:12 <HairyDude> [pwb@rhuidean xmonad]$ cat Main.hs StackSet.hs XMonad.hs | sed '/^\s*--/d;/^\s*$/d' | wc -l
19:52:12 <HairyDude> 400
19:52:14 <HairyDude> heh
19:52:40 <tsp> the irc bot tutorial seems fun
19:52:51 <sorear> 83 minutes!!
19:53:03 <LoganCapaldo> cat Main.hs StackSet.hs XMonad.hs | grep -E 'data|newtype|type' | wc -l
19:53:04 <sorear> make: *** No rule to make target `installl'.  Stop.
19:53:07 <tsp> why the hell do people program in C if imparitive languages such as python exist, as well as functional ones like haskell?
19:53:18 <tsp> they are written in C for speed, but for general programming work
19:53:20 <HairyDude> there are things only C can do
19:53:20 <jcreigh> HairyDude: hey, cool, I didn't know \s worked in sed.
19:53:22 <LoganCapaldo> tsp: well python had to be written in something
19:53:33 <sorear> LoganCapaldo: haskell! :)
19:53:36 <tsp> yeah
19:53:50 <thorat> C should only be used to implement something better
19:53:55 <sorear> LoganCapaldo: also, ghc is, like most compilers, mostly self hosting
19:53:59 <tsp> good point
19:54:01 <LoganCapaldo> yep
19:54:06 <LoganCapaldo> self-hosting rawks
19:54:10 <stepcut> @quote stepcut C
19:54:10 <jcreigh> @remember thorat C should only be used to implement something better
19:54:11 <lambdabot> stepcut says: endo-hylo-cata-ana-expi-ali-docious
19:54:11 <siti> yeah python is one of the slowest languages apart from ruby ;)
19:54:11 <lambdabot> Done.
19:54:21 <stepcut> :(
19:54:22 <tsp> I don't think I'll use haskell for serious projects, but I have to atleast give it a chance - it sounds cool
19:54:42 <sorear> <- is writing a haskell implementation in C
19:54:47 <HairyDude> incidentally, I've always thought that shell pipelines felt very like composition of IO functions in haskell
19:54:54 <chessguy> sorear: why?
19:54:56 <tsp> I like shell scripts
19:55:01 <LoganCapaldo> sorear: I thought you were writing one in Haskell?
19:55:02 <sorear> chessguy: ghci is slow
19:55:11 <falconair> while trying to make Yi, i get this error: setup: cannot satisfy dependency vty>=3.0.  how can i resolve it?  vty doesn't show up in my yum or port repositories
19:55:23 <sjanssen> @hackage vty
19:55:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vty
19:55:26 <LoganCapaldo> @where vty
19:55:27 <lambdabot> http://members.cox.net/stefanor/vty/
19:55:42 <sorear> falconair: I only wrote it like two months ago :)
19:55:47 <chessguy> so what are you going to call your new implementation?
19:55:57 <sorear> chessguy: hv
19:56:02 <sorear> chessguy: the Haskell Validator
19:56:18 <sorear> chessguy: alternatively, think of running it as shining light on errors
19:56:47 <siti> I done some very c like code in haskell using ptrs etc, wow, maybe my low level brain is rotting but it was so hard
19:56:48 <falconair> sorear: actually i tried to get vty through darcs but i don't know what else to do to get Yi running (I tried make vim and make emacs ... nothing else) ... is Yi even in usable form for newbies?
19:57:02 <sorear> falconair: I doubt it
19:57:17 <falconair> ok, no need to bother then, thanks sorear :)
19:57:34 <sorear> vty became like ten times faster, instantly, when I switched from lists to ptrs :(
19:57:42 <tsp> in the page http://haskell.org/haskellwiki/Roll_your_own_IRC_bot, is there a way to get the page without all the damn links?
19:57:44 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
19:58:04 <tsp> edbrowse puts {} around the links which makes them hard to listen to in a programming context due to the wiki
19:58:22 <sorear> edbrowse?
19:58:28 <sorear> @goog edbrowse
19:58:30 <lambdabot> http://www.eklhad.net/linux/app/
19:58:30 <lambdabot> Title: Command Line Applications For Blind Users
19:58:47 <siti> sorear: yep, I switched from lists/arrays to ptrs and it's probably more than 10 times faster
19:58:59 <tsp> yup, that's the edbrowse
19:59:19 <falconair> ok, i have a couple of basic monad questions, many tutorial say that monads are 'computations' ... aren't normal functions computations as well?
20:00:03 <sorear> @quote bad.analogies
20:00:04 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
20:00:10 <chessguy> falconair: yes, but monads have some kind of 'extra information' going on. usually some kind of side effects
20:00:46 * merus compiles ghc6.6
20:00:55 <tsp> cxu vi parolas Esperanton?
20:01:10 <sorear> merus: HEAD compiles *much* faster
20:01:16 <falconair> chessguy, so 'computations' or 'sequencing' are not what diffrentiate monads from normal functions...it is that extra information being carried around, correct?
20:01:21 <stepcut> tsp: links -dump -no-numbering http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
20:01:22 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
20:01:31 <tsp> thanks
20:01:34 <sorear> merus: avg 2h vs. avg 7h
20:01:36 <chessguy> well, sequencing is part of it too
20:01:57 <merus> it's going to take 7h to compile?
20:02:10 <chessguy> stepcut: is that a command for edbrowse?
20:02:12 <HairyDude> (->) a is a monad too, so yes, functions are computations :)
20:02:16 <sorear> I've seen 4-12h, depending on processor speed
20:02:19 <stepcut> chessguy: no, links
20:02:44 <merus> oh.  well, looks like I shouldn't hover over it, then.
20:02:48 <chessguy> falconair: ah, one of those linux utilities i don't have a clue about
20:02:55 <tsp> I use /bin/ed to edit my code
20:02:59 <sjanssen> merus: it takes less than an hour for my core duo laptop
20:03:03 <tsp> edbrowse if its on the box
20:03:18 <sorear> <- 83 minutes to compile GHC 6.7.20070325 on my 2.004 GHz p4
20:03:31 <chessguy> tsp: what screen-reader do you use?
20:03:32 <merus> sjanssen, I'm running at .5 GHz :/
20:03:45 <sjanssen> merus: it's gonna be a while, then :)
20:03:46 <sorear> sjanssen: GHC 6.6?
20:03:51 <sjanssen> sorear: yes
20:04:23 * merus has stat mech homework to do anyway.
20:05:12 * sorear thinks statistical mechanics is a Really Neat Idea
20:05:33 * merus <3 Sterling's formula
20:05:52 <sorear> huh? what do factorials have to do with statmech?
20:06:22 * sorear is pretty sure he just looked stupid
20:06:37 <merus> Einstein solids.
20:06:52 <thorat> what does <3 mean?
20:07:00 <sorear> Ok, I'm going to stop talking now :)
20:07:05 <merus> &hearts;
20:07:06 <sorear> @quote <3
20:07:07 <lambdabot> monochrom says:  (<3) is the Haskell love operator :)
20:07:08 <thorat> (never dared to ask before)
20:07:12 <sorear> @quote <3
20:07:13 <lambdabot> monochrom says:  (<3) is the Haskell love operator :)
20:07:14 <sorear> @quote <3
20:07:15 <lambdabot> monochrom says:  (<3) is the Haskell love operator :)
20:07:38 <HairyDude> (<3) is a section
20:07:42 <sorear> stefan@stefans:/usr/local/src/ghcbuild$ ghc -V
20:07:42 <sorear> The Glorious Glasgow Haskell Compilation System, version 6.7.20070323
20:07:53 <HairyDude> :t (<3)
20:07:55 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
20:08:20 <sioraiocht> no
20:08:20 <sioraiocht> way
20:08:25 <sorear> ?
20:08:45 <dmwit> Will my customizations to xmonad get overwritten on every darcs pull?
20:08:55 <HairyDude> he loves you if and only if you give him a 3 :)
20:09:03 <HairyDude> erm, wrong, something less than 3
20:09:05 <sioraiocht> actually something less tan 3 =p
20:09:06 <sorear> not if you push them :)
20:09:19 <dmwit> sorear: That's not an option.
20:09:29 <merus> > (<3) $ tan(3)
20:09:31 <lambdabot>  True
20:09:44 <dmwit> sorear: We can't have three all the contributors to xmonad quabbling about the One True Way to manage windows...
20:10:02 <stepcut> dmwit: I would imagine it merges the new changes with your local changes...
20:10:04 <dmwit> err, s/three//
20:10:08 <merus> but holy wars are fun :)
20:10:14 <sorear> getSettings = getEnv "LOGIN" >>= case of "dmwit" -> ...
20:10:15 <sjanssen> dmwit: darcs record them, then darcs will complain if there are conflicts
20:10:15 <merus> ... kidding ;_;
20:10:16 <chessguy> nmessenger :)
20:10:21 <nmessenger> chessguy!
20:10:26 <sjanssen> dmwit: what sorts of changes are you making?
20:10:36 <sorear> sjanssen: darcs will report unrecorded conflicts
20:11:15 <dmwit> sjanssen: I prefer Mod4Mask to Mod1Mask, 3%5 to 1%2, modKey-Enter to modKey-Shift-Enter, ...
20:11:53 <sjanssen> dmwit: allright, all configuration type changes
20:11:59 <dmwit> sjanssen: Right.
20:12:36 <sjanssen> we'll have a more sane system for config at some point
20:12:50 <dmwit> Until then, just keep an own diff file or so?
20:13:12 <jcreigh> I have unrecorded changes to the config with no problems.
20:13:13 <sjanssen> it should be safe to keep the changes in your local darcs repo
20:13:26 <jcreigh> I just have to hit "n" for them whenever I "darcs record"
20:13:30 <dmwit> But, but... !
20:13:39 <dmwit> Then how did they get overwritten on the last darcs pull??
20:14:16 <sorear> @seen twanvl
20:14:17 <lambdabot> I saw twanvl leaving #haskell.dut and #haskell 3h 16m 47s ago, and .
20:15:11 <sorear> @tell ndm derive "Functor" (undefined :: [Char]) for fun
20:15:12 <lambdabot> Consider it noted.
20:15:30 <jcreigh> dmwit: you lost your local changes?
20:15:39 <dmwit> jcreigh: Yep.
20:15:50 <sorear> @tell ndm ... doesn't work for maybe either
20:15:50 <lambdabot> Consider it noted.
20:16:21 <jcreigh> dmwit: hmm...I haven't had any problems...
20:16:39 <dmwit> Okay, in that case I'll just hope it doesn't happen again...
20:18:43 <sioraiocht> @src (!!)
20:18:44 <lambdabot> xs     !! n | n < 0 = undefined
20:18:44 <lambdabot> []     !! _         = undefined
20:18:44 <lambdabot> (x:_)  !! 0         = x
20:18:44 <lambdabot> (_:xs) !! n         = xs !! (n-1)
20:19:18 * HairyDude finally gets round to looking at the Fortress FAQ and is astonished to see it doesn't mention APL
20:20:46 <Shimei> Humm. Runghc is giving me a weird error: $ runghc Setup.hs build *** Exception: failed to extract ghc path from command line"
20:20:58 <Shimei> I tried supplying the GHC path with -f to no avail.
20:22:03 <sorear> do you even have ghc?
20:22:47 <siti> bytestrings aren't on the GC'd heap, correct?
20:23:03 <sorear> correct.
20:23:24 <dmwit> jcreigh: Try something for me?
20:23:25 <Shimei> sorear: "$ ghc --version The Glorious Glasgow Haskell Compilation System, version 6.6"
20:23:27 <jcreigh> dmwit: suer
20:23:34 <jcreigh> *sure -- you know what I mean
20:23:36 <dmwit> Open a window on workspace one, screen one.
20:23:43 <dmwit> Then open a window on workspace one, screen two.
20:23:58 <dmwit> Now, try moving to workspace 2, 3, 4, etc.
20:24:25 <jcreigh> what do you mean "workspace one, screen two"?
20:24:43 <dmwit> Mod+1, Mod+e
20:25:19 <siti> another question about bytestrings, how lazy are they? if I split a string up in to words and use only some of those words, then compress the string, will the original string still be in memory?
20:25:19 <jcreigh> mod-{w,e,r} and just shortcuts that mean "switch to the workspace that is currently visible on screen N"
20:25:30 <siti> (using the lazy bytestrings)
20:25:36 <jcreigh> s/and/are/
20:25:38 <dmwit> Aha, this explains things a little better.
20:25:43 <sorear> siti: what does compress mean?
20:26:03 <sorear> (and why do you ask if they are in the heap?)
20:26:15 <jcreigh> similarly, shift-mod-{w,e,r} are just shortcuts that mean "move the current window to the workspace that is currently visible on screen N"
20:26:25 <siti> http://www.cse.unsw.edu.au/~dons/fps.html <-- zlib/bzip
20:26:26 <lambdabot> Title: Data.ByteString
20:26:31 <jcreigh> perhaps it's time I document the Xinerama support, now that someone other than me is using it, eh?
20:26:51 <dmwit> jcreigh: It is exceeding strange.
20:26:56 <jcreigh> so when you first start up, you have workspace 1 on screen 1 and workspace 2 on screen 2
20:27:04 <siti> sorear: I am just wondering why when I set a max/min heap size the actual memory usage is much greater...
20:27:09 <jcreigh> dmwit: what did you expect? (not sarcastic; I want to know)
20:27:20 <dmwit> Let me give you one thing that confused me a lot:
20:27:27 <jcreigh> sure
20:27:32 <dmwit> (After you explained the situation.)
20:27:47 <dmwit> When I was on screen two, I found by trial and error that the window there was on workspace 2.
20:28:05 <dmwit> Then I nav'd to workspace 1.  Screen two didn't change, but screen 1 became blank.
20:28:12 <stepcut> siti: I think by default, most BS functions will use the original copy of the data, so if you want that memory freed, you need to do something that does a memcpy of the parts you are still using
20:28:25 <sorear> siti: substring ops, like words, on (lazy or string) bytestrings, are implemented using pointer fudging
20:28:28 <dmwit> Then I nav'd to workspace 2.  Now screen 1 reappears and screen 2 disappears.
20:28:38 <dmwit> Now, trial and error shows that screen 2's workspace number is 5!
20:28:41 <dmwit> (??)
20:28:43 <siti> ok
20:28:53 <siti> thanks
20:29:05 <sorear> siti: so if you keep a ref to any substring, the whole chunk (strict bs have 1 chunk always, lazy bs have 16k chunks) is retained
20:29:24 <jcreigh> hmm
20:29:29 <siti> yep, I think that's what's happening...
20:29:46 <dmwit> Is it possible to have disjoint workspaces for each screen?
20:29:53 <dmwit> I think that would be the least surprising thing for me.
20:29:58 <jcreigh> dmwit: what do you mean?
20:30:07 <sorear> siti: lazy bs have fairly big chunks, and it's easy for a sparse set of refs to wind up hitting and retaining every chunk
20:30:15 <sorear> siti: you might want to look at 'copy'
20:30:22 <siti> I will just use the copy function, hah nice timing
20:30:23 <dmwit> Like, the workspaces are in the set (Screens \times [1..9]) or so.
20:30:41 <siti> sorear: I was just typing it as you sent a reply
20:31:05 <jcreigh> oh, so you've got workspace [1..9] on screen 1, and a *different* set of workspaces [1..9] on screen 2?
20:31:12 <dmwit> yah
20:31:14 <jcreigh> (rather, that's what you'd expect?)
20:31:16 <siti> yeah my strings are all <2KB but there are lots of them
20:32:02 <jcreigh> hmm
20:32:03 <dmwit> I mean, I don't really know, I'm just throwing an idea out there.
20:32:14 <jcreigh> yeah, sure, totally.
20:32:24 <dmwit> I don't really grok how you choose the workspace for each screen currently.
20:32:43 <dmwit> But it's probably really logical, and I'd understand everything if I just took the time to look at the algorithm. =)
20:32:48 <jcreigh> when xmonad starts, workspace 1 is on screen 1, workspace 2 is on screen 2, etc.
20:33:04 <dmwit> Yes, but then what?
20:33:05 <jcreigh> if you switch to a workspace that's visible on some other screen, focus just switches to that screen.
20:33:38 <jcreigh> if you switch to a workspace that's *not* visible, the workspace you're switching to replaces the current workspace.
20:33:44 <dmwit> Errr, empirically false.
20:33:58 <dmwit> (referring to "focus just switches to that screen".)
20:34:24 <jcreigh> dmwit: really? how so?
20:34:54 <dmwit> jcreigh: By me being an idiot. =P
20:35:02 <sorear> jcreigh: sounds like you have the invariant that no two screens display the same workspace
20:35:08 <jcreigh> sorear: yes
20:35:19 <jcreigh> sorear: windows can only be in one place.
20:35:21 <sorear> jcreigh: how badly does xmonad explode if you have >10 screens?
20:35:38 <dmwit> ewww
20:35:45 <jcreigh> sorear: it doesn't, you just have to figure out some extra keys to bind to control them.
20:36:09 <HairyDude> Good grief, why am I still up at 4:37 am?
20:36:13 <sorear> jcreigh: uh ... but it would violate the invariant
20:36:19 <sjanssen> jcreigh: does anything bad happen when number of workspaces < number of screens?
20:36:27 <LoganCapaldo> HairyDude: its only 11:34pm by my clock
20:36:29 <jcreigh> sjanssen: probably yes
20:36:29 <LoganCapaldo> you're still good
20:36:32 <sorear> jcreigh: you just can't put 10 workspaces on 200 screens
20:36:40 <dmwit> Okay, this multiple screen thing is starting to make sense.
20:36:44 <dmwit> Cool.
20:36:46 <jcreigh> sorear: oh, >10 *screens*
20:36:51 <jcreigh> sorear: yes, that would blow up. :)
20:37:11 <merus> What would a human do with >10 screens, anyway...
20:37:18 <jcreigh> but we haven't had a problem with that yet.
20:37:22 <sorear> merus: display wall?
20:37:24 <LoganCapaldo> large porn
20:37:25 <jcreigh> "9 screens should be enough for everyone"
20:37:30 <ddarius> merus: But we have to think of all the non-human users.
20:37:35 <dmwit> Also, the current list comprehension for setting the workspace-switching would probably be bad for more than 9 screens...
20:37:45 <ddarius> LoganCapaldo: At that point, it would cease to be enjoyable.
20:37:50 <merus> bah, most available non-human users don't require screens.
20:38:00 <sorear> screen readers!
20:38:04 <LoganCapaldo> ddarius: that depends on how far away from the screens you are standing
20:38:08 <merus> ._.;
20:38:26 <ddarius> LoganCapaldo: Ah, porn for the whole street.
20:38:27 <sorear> merus: fix your baud setting
20:38:32 <sjanssen> jcreigh: we should probably just ignore the screens in excess of the number of workspaces
20:38:43 <merus> sorear, I don't measure it in baud anymore, that's so 1990
20:38:48 <encryptio> :t catch
20:38:50 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
20:39:03 <sorear> @where catch -- you meant?
20:39:03 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
20:39:04 <Shimei> merus: I have a friend who uses something like 30 workspaces on a laptop.
20:39:15 <merus> Shimei, but those aren't screens
20:39:21 <LoganCapaldo> :t throw
20:39:23 <Shimei> Oh, right. :P
20:39:24 <lambdabot> Not in scope: `throw'
20:39:38 <merus> I've been known to have 15 or so, but I wouldn't interact with them all at the same time.
20:39:41 <LoganCapaldo> :t conistency
20:39:44 <lambdabot> Not in scope: `conistency'
20:39:50 <LoganCapaldo> *consistency
20:39:54 <merus> I wonder if I could.  Probably blow a gasket.
20:39:57 <LoganCapaldo> :t throwError
20:40:00 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
20:40:10 <Shimei> I find that I have a hard time making use of my two screens.
20:40:16 <LoganCapaldo> :t error
20:40:19 <lambdabot> forall a. [Char] -> a
20:40:23 <sorear> I have a hard time using 6 vcs.
20:41:26 <LoganCapaldo> heh
20:41:37 <LoganCapaldo> :t error -- terror!
20:41:40 <lambdabot> forall a. [Char] -> a
20:41:47 <jcreigh> dmwit: I usually just use 3 workspaces on 3 screens. (ie, I hardly use the workspace functionality at all).
20:42:00 <merus> The dept. of homeland security refuses to accept anything of type [Char] -> a
20:42:17 <dmwit> jcreigh: Ah.  I think I'll still be using it though.
20:42:27 <merus> It makes finding the length of strings difficult, but that's the price one pays for freedom...
20:42:29 <dmwit> I only have a 1600x1200 and 1024x768.
20:42:35 <jcreigh> dmwit: okay. well, we should figure what model actually makes the most sense.
20:42:41 <LoganCapaldo> a function from strings to anythings is pretty terrifying
20:42:48 <jcreigh> I have 2 x (1024x768) + 800x600
20:43:07 <dmwit> (Also, I like to separate my schoolwork, my hacking, and my play.)
20:43:08 <merus> I mean, it could be *anything*
20:43:17 <dmwit> Okay, anyway, yes, we should probably think about that eventually.
20:44:19 <LoganCapaldo> @ty let f _ = undefined in f -- even scarier, a function from anything to anything
20:44:21 <lambdabot> forall t a. t -> a
20:44:39 <jcreigh> dmwit: so having disjoint workspaces per screen is one option. what do you think about workspaces covering the entire viewable area?
20:44:55 <dmwit> Yes, I was thinking about that, too.
20:45:03 <dmwit> So, Mod+2 changes both screens, right?
20:45:06 <jcreigh> yeah
20:45:21 <sjanssen> that sounds less useful to me
20:45:31 <dmwit> Then, mod+shift+2 moves the workspace on the same screen?
20:46:08 <sjanssen> you can change your keybindings to emulate that
20:46:08 <dmwit> sjanssen: It's a little more restrictive, but I think it might actually be more useful.
20:46:16 <dmwit> Ah, good point.
20:46:23 <sorear> merus: ahem, you do realize general recursion is pure evil?
20:46:51 <jcreigh> hmm...mod-shift-2 would probably move the current window to workspace 2...
20:46:54 <sorear> sjanssen: I suppose one benefit of the Haskell Way is you can bind keys to arbitrary XM actions?
20:47:05 <sjanssen> sorear: exactly
20:47:10 <jcreigh> we'd have to keep track of which window in each workspace was on which screen...
20:47:13 <jcreigh> hmm...
20:47:45 <dmwit> sorear: You can do it in dwm, too.
20:47:55 <jcreigh> sorear: without any need for explicit thunking, either.
20:47:55 <sorear> so how much functionality can we move into Config.hs?
20:48:07 <sorear> explicit thunking?
20:48:37 <jcreigh> sorear: well, WMs with, eg, lua as their extension language have to do something like bind_key("Mod3+x", "do_something()")
20:48:41 <jcreigh> or pass in a function
20:49:12 <jcreigh> we can just say ((modMask .|. shiftMask, xK_Return), spawn "xterm")
20:49:57 <sorear> so what does dwm do?
20:50:11 <dmwit> function pointers to (void *f(char *)) functions.
20:50:14 <sorear> last I checked C didn't have lambda abstractions :)
20:50:33 <sorear> oh yeah, forgot about lambda lifting
20:50:51 <jcreigh> all the functions that take ints have to atoi() their argument...
20:50:56 <jcreigh> silly
20:51:11 <dmwit> I think the way to do it would be something like this:
20:51:14 <sorear> and read is that much shorter?
20:51:20 <LoganCapaldo> what, it doesn't use void* ? :)
20:51:29 <dmwit> Have (screens * workspaces) total workspaces,
20:51:40 <jcreigh> sorear: no, we just have view :: Int -> X (), and then say "view 3" as the action. (or whatever)
20:51:45 <dmwit> then make the default keybindings modify all screens at once.
20:52:02 <dmwit> This gives the restrictive (but useful) behaviour, while allowing the more free-form behavior.
20:52:17 <jcreigh> hmm
20:52:44 <sorear> So, who's up for implementing Haskell in 1600 lines of C?
20:53:08 <dmwit> Or, we can keep the current behavior.
20:53:23 <dmwit> I'd like to try it out for a few days before I say whether I like it or not... =)
20:53:36 <jcreigh> so if you were on ws 5 screen 2, and you hit modkey-shift-1, it would move the window to workspace 1 of screen 2?
20:53:49 <dmwit> right
20:54:14 <jcreigh> then the shift-modkey-{w,e,r} bindings be how you'd move something from one screen to another.
20:54:25 <jcreigh> (well, it's that way now, but then that would be the *only* way)
20:54:35 <dmwit> Ah, I see.
20:54:53 <dmwit> I'm not sure.
20:54:57 <dmwit> We need usability tests!
20:55:00 <jcreigh> heh
20:55:17 <jcreigh> my usability test is currently named "dmwit" :)
20:55:23 <dmwit> haha
20:55:30 <sorear> Xmonad needs a call-home feature
20:55:37 <sjanssen> let's all set our grandmothers in front of a multi-head xmonad setup :)
20:55:59 <LoganCapaldo> Xmonad: Spying on you so you don't have to complain
20:56:00 <sorear> so every time you run it it sends a specially formatted packet to sjanssen.org
20:56:49 <jcreigh> dmwit: so do you think the current system would still be confusing as heck even if it was documented?
20:56:56 <dmwit> jcreigh: no
20:56:59 <dmwit> It's very clear.
20:57:08 <sorear> you say that NOW
20:57:15 <dmwit> Probably a great deal of my negative reaction comes from my initial confusion.
20:57:53 <jcreigh> okay.
20:58:07 <jcreigh> well, I think I'll write up some docs for it.
20:58:19 <jcreigh> ride on the current system for a couple days, let me know what you think would work better.
20:58:41 <dmwit> Sounds good.  Also, thanks, because this is the first time I've been even motivated to try to get both my screens working. =)
20:59:18 <jcreigh> as I said, I don't really use the workspace system, and I don't want the Xinerama support in xmonad to require that your name be "jcreigh" :)
20:59:38 <dmwit> heh
21:00:07 * dmwit goes to bed
21:01:30 <sjanssen> I should get my second display output working so I can test the xinerama stuff
21:03:26 <jcreigh> sjanssen: I'm going to move the config stuff out of Main.hs into Config.lhs and start to add some documention of the Xinerama support there
21:03:41 <jcreigh> then just have Main.hs import Config
21:05:09 <sjanssen> jcreigh: you'll have to move raise, switchLayout, and such too
21:05:23 <jcreigh> sjanssen: why?
21:05:41 <sjanssen> jcreigh: because keybindings refer to those functions
21:05:41 <jcreigh> oh, or else import Main. Right
21:06:04 <jcreigh> hmm
21:17:04 <sorear> @tell ndm darcs send is broken for catch
21:17:05 <lambdabot> Consider it noted.
21:17:13 <sorear> Who is responsible for haddock-ghc?
21:18:07 <sorear> @tell waern darcs send is broken for haddock.ghc
21:18:08 <lambdabot> Consider it noted.
21:18:46 <waern> dons, ping
21:18:47 <lambdabot> waern: You have 1 new message. '/msg lambdabot @messages' to read it.
21:19:03 <sorear> .
21:19:30 <sorear> waern: what's the correct address to send patches?
21:19:45 <waern> davve@dtek.chalmers.se
21:21:09 <sorear> good, I had to guess
21:21:17 <hpaste>  thoughtpolice pasted "(no title)" at http://hpaste.org/1141
21:21:25 <sorear> (bash tried to execute Setup.lhs as a shell script)
21:22:46 <waern> oh, thanks
21:22:59 <dons> waern: ?
21:23:03 <waern> I allways use runhaskell
21:23:48 <waern> dons, I wanted to ask how to use the binary-derive function on say: (T a)
21:24:00 <dons> no idea, i've not used it :-)
21:24:16 <waern> It's not possible to give it (undefined::(T a)), because GHC will complain
21:24:19 <waern> okay... hm
21:24:56 <sorear> waern: (T A)
21:25:10 <waern> yes... that's what I meant
21:25:13 <waern> sorry
21:25:29 <sorear> waern: no, seriously, (T A) with uppercase A
21:25:31 <hpaste>  thoughtpolice pasted "example of alex; output" at http://hpaste.org/1142
21:25:36 <sorear> waern: that will quiet ghc
21:25:44 <waern> sorear, yes... but it still doesn't work
21:25:57 <waern> might be because of my type though.
21:26:14 <sorear> waern: what kind of type is it?
21:27:30 <waern> it is HsDoc Name, and I have derived Typeable and Data for it using GHC's stand-alone deriving
21:27:38 <waern> I've also done that for Name
21:28:50 <sorear> is ghc complaining about splicing too early?
21:29:23 <waern> ah, that could be it
21:29:34 <waern> i'll test something
21:30:57 <waern> no, that's not it
21:34:01 <sorear> waern:
21:34:01 <sorear> haddock: internal Haddock or GHC error: src/Main.hs:(881,4)-(883,75): Non-exhaustive patterns in function mkExportItem
21:34:04 <sorear> after stefan@stefans:/usr/local/src/derive$ haddock Data/Derive.hs Data/Derive/*.hs --html -B /usr/local/lib/ghc-6.7.20070323/ --odir=html --ignore-all-exports
21:34:09 <sorear> w/o --ignore-all-exports it worked fine
21:34:19 <waern> ah, found the problem. Need to add more instances. Though I only got an error message that told me so when moving the application to the point where the original instances were defined
21:34:34 <waern> err.. point=module
21:35:23 <waern> sorear, I'll have a look
21:38:57 <sorear> waern: how do you know that only DocEntity s and DeclEntity s will be passed in the second arg to fullContentsOfThisModule?
21:39:31 <waern> They are the only constructors :)
21:39:41 <waern> Its an inner type that's the problem
21:39:52 <waern> I'm looking at it, hang on
21:40:05 <jcreigh> sjanssen: what do you think about just moving view, tag, promote, switchLayout, kill, changeWidth, raise and screenWS into XMonad.hs?
21:40:16 <sjanssen> jcreigh: hmm
21:40:28 <sorear> waern: so, do you want to become a Catch Alpha Tester? ;-)
21:40:40 <jcreigh> sjanssen: (the division between Main.hs and XMonad.hs seems kind of arbitrary to me. What's the intended difference?)
21:40:56 <waern> sorear, hehe... I might need to
21:41:43 <sorear> of course that wouldn't actually work ... not until Yhc can compile GHC
21:42:18 <sjanssen> jcreigh: XMonad.hs is supposed to have the core operations for the monad itself
21:44:08 * sorear away
21:44:24 <jcreigh> well, the alternative is to move a non-trivial amount of code into the "configuration" file, which I don't think is a good idea. I don't suppose there's anyway just to "import Main"?
21:44:43 <sjanssen> cyclic dependencies are a real pain with ghc
21:44:54 <sjanssen> the third option is to introduce another file
21:45:26 <sjanssen> maybe Main.hs should only have the actual main function, and then all other operations are in this other module
21:46:18 <jcreigh> that would work.
21:46:27 <jcreigh> all we need is a good name for this other module
21:46:39 <jcreigh> (or just stuff it all into XMonad.hs)
21:47:42 <jcreigh> Event.hs? XMonadExtra.hs? Fluff.hs? UI.hs?
21:49:34 <sjanssen> Operations.hs?
21:49:59 <jcreigh> sounds okay to me.
21:50:30 <jcreigh> and that would contain all the stuff that actually mucks around and talks to the X11 libs and whatnot? (ie, Main.hs expect for main?)
21:52:28 <sjanssen> hmm
21:52:51 <sjanssen> we could possibly keep the handle function in main
21:53:10 <jcreigh> oh, that makes sense.
21:53:30 <sjanssen> manage and unmanage could stay (but could also go into Operations.hs)
21:54:34 <sjanssen> grabKeys can stay too
21:54:41 <sjanssen> and scan
21:58:17 <jcreigh> gah, tons of "imports"
21:58:35 <kolmodin> morning
22:00:05 <kolmodin> waern: you're up early today
22:00:42 <dcoutts> hah
22:00:46 <dcoutts> @localtime kolmodin
22:00:47 <lambdabot> Local time for kolmodin is Mon Mar 26 06:59:00 2007
22:01:15 <kolmodin> :)
22:01:26 <dcoutts> g'morning waern
22:02:20 <dons> ?yow
22:02:20 <lambdabot> I'm thinking about DIGITAL READ-OUT systems and computer-generated
22:02:21 <lambdabot> IMAGE FORMATIONS ...
22:03:15 <waern> morning...
22:03:23 <waern> actually I just haven't gone to bed
22:03:30 <waern> =)
22:03:35 <kolmodin> waern: ah, that's more like it
22:04:22 <waern> hi kolmodin
22:05:13 <waern> sorear, you could try again now
22:05:23 <kolmodin> hia waern
22:05:29 <kolmodin> working on haddock, I see
22:05:58 <waern> yep
22:11:14 <ddarius> I don't need to read the rest of this.
22:13:36 <sorear> waern: 'k
22:13:54 <merus> So I'm in the middle of compiling ghc6.6 and all of a sudden its spewing a bunch of code prefixed with "Bad eta expand"
22:13:59 <merus> should I stop compiling?
22:14:07 <sorear> @quote eta
22:14:07 <lambdabot> Cale says: alpha beta gamma delta epsilon, zeta eta theta iota kappa lambda mu, nu xi, omicron pi, rho sigma tau, upsilon phi, chi psi omega... now I know my alpha beta gammas, next time won't you
22:14:08 <lambdabot> sing with me?
22:14:09 <sorear> @quote eta
22:14:10 <lambdabot> ghc says: Exotic Stmt in meta brackets
22:14:13 <sorear> @quote eta
22:14:14 <lambdabot> ghc says: Exotic Stmt in meta brackets
22:14:17 <sorear> @quote ghc eta
22:14:18 <lambdabot> ghc says: Bad eta expand
22:14:35 <sorear> That Sounds Bad.
22:14:48 <waern> It says that to me sometimes when compiling HEAD too
22:14:53 <jcreigh> how do I say, "unrecord this patch, but leave the changes in my repo"? (so I can re-record it)
22:14:57 <sorear> is it reported
22:14:59 <jcreigh> darcs unrecord?
22:15:01 <sorear> jcreigh: unrecord
22:15:22 <sorear> jcreigh: also look at the docs for amend-record
22:15:52 <sorear> waern: what's the official way to generate docs for private symbols?
22:15:55 <sorear> --ignore-all-exports?
22:16:31 <waern> yes, I think simon added that flag for that case
22:16:50 <sorear> Unresolved overloading: Simon a => a
22:17:06 <jcreigh> sjanssen: patch sent. (I think this will break dmwit's changes. :P)
22:17:09 <sorear> (fortunately I don't care)
22:17:16 <sorear> (I just had to say that ;-)
22:17:19 <sorear> )
22:17:41 <LoganCapaldo> Haskell: "Simon Says" applied to programming
22:17:52 <waern> hehe
22:18:08 <jcreigh> sjanssen: I didn't add a copyright/author header to either of the new modules...you can add them if you feel it's nessesary.
22:18:19 <sorear> @rmember LoganCapaldo Haskell: "Simon Says" applied to programming
22:18:19 <lambdabot> Done.
22:18:23 <LoganCapaldo> Haskell: Now with even _more_ Simons!
22:18:31 <dons> jcreigh: breaking what now?
22:18:33 <sorear> me needs to write M-x remember for ERC
22:18:50 <jcreigh> dons: oh, I just moved the config into Config.lhs
22:19:10 <jcreigh> dons: (dmwit was wondering if his changes to the config would be wiped out with a darcs pull)
22:19:33 <dons> .lhs??
22:19:42 <jcreigh> dons: yeah, it doubles as documentation
22:19:45 <dons> hmm
22:19:51 <dons> haddock doubles as documentation
22:19:55 <dons> what form of .lhs?
22:20:03 <dons> bird or latex?
22:20:13 <jcreigh> the former, I think. (plain text)
22:20:20 <sjanssen> bird
22:20:23 <dons> i'd not bother with .lhs.
22:20:23 <jcreigh> > with code like this
22:20:26 <lambdabot>   Not in scope: `this'
22:20:30 <sjanssen> we can always change that
22:20:32 <dons> since that's only going to confuse anyway.
22:20:36 <dons> since the rest of the wm's not .lhs
22:20:46 <sjanssen> looks good jcreigh++
22:20:55 <dons> how'd you handle mutual recursion?
22:20:59 <jcreigh> sure, .hs would be fine too. doesn't matter to me.
22:21:02 <sorear> dmwit: pull, and experience the glory of Darcs Conflict Resolution!
22:21:02 <sorear> load average: 1.00 1.00 1.00
22:21:12 <jcreigh> dons: we made another module. Operations.hs, which contains most of what was in Main.hs
22:21:14 <sjanssen> dons: moved most everything into a different module
22:21:34 <dons> ok. that's client.c and event.c in dwm, if you want a nicer name
22:21:45 <sorear> src/Main.hs:882:42: Not in scope: `mkExport'
22:21:45 <sorear> src/Main.hs:884:39: Not in scope: `name'
22:21:45 <sorear> src/Main.hs:884:61: Not in scope: `name'
22:21:54 <sorear> waern: ^ didn't work :(
22:22:28 <waern> sorear, --ignore-all-exports or the patched haddock?
22:22:36 <sjanssen> I don't think client or event capture what's in Operations.hs
22:22:53 <sorear> waern: where don't scope over cases
22:22:58 <dons> i had one idea to provide an abstract event type
22:22:59 <sorear> waern: patched haddock
22:23:02 <dons> that the config.hs would be in terms of
22:23:08 <sorear>     mkExportItem (DeclEntity name) = fmap mkExport (Map.lookup name declMap)
22:23:08 <sorear>     mkExportItem _ = Nothing
22:23:08 <sorear>       where mkExport decl = ExportDecl name decl (Map.lookup name docMap) []
22:23:08 <dons> that we then interpret in Main.hs
22:23:12 <sorear> ^^ the wrong code
22:23:17 <dons> then you don't need operations to be directly visible in config.hs
22:23:23 <jcreigh> sjanssen: anyway, change the filenames and/or literate-ness of Config to whatever you think is best. I don't have any feelings on it one way or the other.
22:23:24 <sorear> since the where only goes to the _ case
22:25:36 <waern> sorear, argh! sorry, couldn't compile it since I have other changes going on
22:26:16 <sorear> heh.
22:26:57 <dons> a simple Config.hs with normal comments should be enough
22:27:07 <dons> since people have to hack it, and most don't use .lhs anyway.
22:27:13 <sorear> night all.
22:27:28 <waern> sorear, I've pushed a fix
22:27:42 <waern> sorear, good night
22:27:47 * sorear tests it as quickly as possible
22:28:10 <sorear> ghc, slow as always
22:29:02 <sorear> waern++ works now
22:29:09 <waern> oh. nice
22:31:59 <dons> otherwise, I like Config.hs. good work.
22:32:18 <dons> would be useful to run haddock over things again
22:33:14 <waern> I don't get how the binary-derive code ever is going to work with composed types
22:34:33 <waern> the derive function in Data.Binary that is
22:34:40 <kolmodin> how so?
22:35:01 <waern> it thinks A in (T A) is a type variable
22:35:20 <kolmodin> in the current code to derive?
22:35:28 <kolmodin> http://darcs.haskell.org/binary/tools/derive/Example.hs <-- ?
22:36:05 <kolmodin> ah, I don't have an example for that
22:36:12 <jcreigh> sjanssen, dons: is one of you doing the Config.lhs -> Config.hs conversion, or should I do that?
22:36:17 <waern> kolmodin, you wrote that?
22:36:20 <kolmodin> yes
22:36:37 <kolmodin> waern: so it might be buggy! :D
22:36:42 <waern> kolmodin, ah... ;D
22:37:47 <jcreigh> too late, I'm doing it. :)
22:39:42 <kolmodin> waern: does that give you trouble?
22:39:59 <kolmodin> derive (Just "") -> instance (Binary a) => Binary (Maybe a) where
22:40:24 <kolmodin> thus it requires String to be Binary too
22:40:34 <kolmodin> that isn't derived automagically yet
22:42:31 <kolmodin> waern: smhi says we're going to have it sunny all week long
22:42:58 <kolmodin> ok, off to work. bye
22:43:20 <jcreigh> sjanssen: Config.lhs -> Config.hs patch sent
22:43:26 <jcreigh> now it really is bedtime
22:43:30 <jcreigh> 'night all
22:43:35 <kolmodin> night jcreigh
22:51:04 * kolmodin `throwTo` work
23:01:43 <Cale> dcoutts: whoa, you've been busy.
23:02:46 <Cale> (My mailbox just got hit with 25 or so c2hs "patch applied" emails.)
23:16:41 <araujo> Cale, that's why you have to be scared when dcoutts isn't too much around on irc
23:18:42 <dons> hack hack hack!
23:18:46 <dons> no time to talk.
23:18:46 <dcoutts> @yarr!
23:18:46 <lambdabot> Arr! Me ship be the biggest brig in the port!
23:19:11 <dcoutts> Cale: that's just what I've been doing in the evenings :-)
23:25:22 <araujo> dcoutts, it looks like the time is more productive on aus? :-P
23:28:55 <pejo> The great thing with going away - very few people bother you with administration. :P
23:29:55 <dcoutts> pejo: exactly
23:30:47 <dons> @unpl (++) . f
23:30:48 <lambdabot> (\ c -> (++) (f c))
23:30:57 <dons> @unpl (\x y -> x ++ y) . f
23:30:58 <lambdabot> (\ c y -> (f c) ++ y)
23:31:21 <dcoutts> dons: looking at concat?
23:32:11 <dons> yeah
23:32:24 <dons> you can tell from my @unpl? ;-)
23:33:15 <dcoutts> of course!
23:44:50 <kolmodin> dcoutts: it's nice to see that you go all the way to .au but that you're still communicating over irc
23:49:48 <dons> kolmodin: we're sitting about 1metre apart too :} irc is easier.
23:50:07 <kolmodin> dons: haha :)
23:50:27 <kolmodin> concat, so you're doing streams atm
23:50:39 <waern> good night
23:50:55 <kolmodin> waern: good morning/night :)
23:51:05 <kolmodin> ?localtime waern
23:51:05 <waern> I'm going to try and sleep some, even though it's 08.50 am here
23:51:06 <lambdabot> Local time for waern is Mon Mar 26 08:49:20
23:51:19 <waern> oh, wait
23:51:42 <waern> its 07.50... my clock isn't working :)
23:51:57 * kolmodin wonders which timezone waern is living in
23:52:04 <kolmodin> waern: naa, it's 8.50
23:52:52 <waern> ah, good :)
23:52:54 <kolmodin> :)
23:53:22 <kolmodin> waern: you're about 12h ahead or behind
23:53:41 <kolmodin> almost the time zone dons and dcoutts lives in
23:55:00 <waern> kolmodin, it makes me proud ;)
23:55:33 <waern> or, actually, no it doesn't.
23:56:25 <waern> if the weather this week is supposed to be good, I wanna see some of it :)
23:57:19 <kolmodin> waern: yeah, very nice this weekend
23:57:31 <kolmodin> waern: you're not working atm? no exams either?
23:57:44 <waern> kolmodin, nope.
23:57:55 <kolmodin> we had ~15 degrees in the shadow this weekend, 20+ in the sun
23:58:50 <kolmodin> ok, go to bed and you might catch the sundown
23:59:19 <kolmodin> g'night waern
23:59:37 <waern> night
