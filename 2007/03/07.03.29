00:00:05 <jkarres> ejt_: i just imagine unix pipes :)
00:00:06 <bitwiseshiftleft> sciolizer: hm.  i guess you're right.  i guess you just need one interpreter or compiler not written in your language.  and you need that anyway to bootstrap
00:00:12 <laziest> bitwiseshiftleft: they can!
00:00:15 <jkarres> ejt_:  wish the rest of haskell were that easy!
00:01:07 <ejt_> jkarres: the @pl command in lambdabot is useful
00:01:10 <Cale> Before I'd properly learned Haskell, I'd written an entire IRC bot as a single, extremely long shell pipeline.
00:01:31 <Korollary> holy jumping you
00:01:43 <ejt_> @pl foo x = return $ String (concat x)
00:01:44 <lambdabot> foo = return . String . join
00:02:25 <ejt_> Cale: impressive!
00:02:27 <bitwiseshiftleft> what's @pl do then?  make things point-free?
00:02:38 <ejt_> y, PointLess
00:02:55 <dons> bitwiseshiftleft: yep
00:02:58 <Cale> There was a fifo to sort of tie the two ends of the pipeline together into a loop.
00:02:58 <LouieG> functions can only return a single value?
00:03:06 <jkarres> ejt_ : that's pretty nifty
00:03:11 <bitwiseshiftleft> LouieG: well, they can always return a pair
00:03:12 <Cale> LouieG: that value might be a tuple
00:03:17 <dons> LouieG: yes, but that may be a composite value, or a list, or a structure
00:03:24 <dons> > let f x = (x,x,x,x) in f 7
00:03:26 <lambdabot>  (7,7,7,7)
00:03:34 <dons> > let f x = (x,x,x,x) in replicate 10 (f 7)
00:03:35 <lambdabot>  [(7,7,7,7),(7,7,7,7),(7,7,7,7),(7,7,7,7),(7,7,7,7),(7,7,7,7),(7,7,7,7),(7,7,...
00:04:05 <jkarres> @pl f x = x * 3
00:04:06 <lambdabot> f = (3 *)
00:04:08 <dons> > let f 0 = Left "zero" ; f n = Right (show n) in [f 2, f 0, f 7]
00:04:09 <lambdabot>  [Right "2",Left "zero",Right "7"]
00:04:25 <dons> > let f 0 = Left "zero" ; f n = Right n in [f 2, f 0, f 7]
00:04:26 <lambdabot>  [Right 2,Left "zero",Right 7]
00:04:46 <dons> what programming dreams are made of.
00:04:54 <Cale> > let f 0 = Left "zero" ; f n = Right n in map f [2, 0, 7]
00:04:55 <lambdabot>  [Right 2,Left "zero",Right 7]
00:05:06 <sjanssen> LouieG: by "a single value", the document probably is saying that for any f and x, "f x" always returns the same value
00:05:39 <Cale> Functions in Haskell are roughly the same concept as functions in mathematics.
00:06:16 <Cale> Up to performance concerns, they could abstractly be represented by a set of (input,output) pairs of values.
00:06:25 <LouieG> Yes, I do realize that, unless they do input they should always return the same values.
00:06:57 <dons> unless they have access to state somehow, yes.
00:07:05 <dons> ?yow -- this is a haskell function
00:07:05 <lambdabot> Please come home with me ... I have Tylenol!!
00:07:10 <dons> ?yow -- that returns a different value
00:07:11 <lambdabot> hubub, hubub, HUBUB, hubub, hubub, hubub, HUBUB, hubub, hubub, hubub.
00:07:12 <Cale> If f x gives the same result as g x for all x, then wherever f occurs in a program, it can be replaced with g, with no ill effects.
00:07:13 <dons> ?yow -- each time
00:07:13 <lambdabot> Boy, am I glad it's only 1971...
00:07:28 <Cale> dons: only it's not a function, but an action
00:07:35 <dons> that is true.
00:07:40 <Cale> and that action is the same action every time
00:07:49 <dons> quite so.
00:07:51 <sjanssen> it's probably a little of both
00:08:09 <LouieG> that action is the same every time? what does this mean?
00:08:11 <dolio> Was yow someone who actually used to frequent #haskell?
00:08:23 <ejt_> heh
00:08:31 <Cale> Consider putStrLn
00:08:32 <sjanssen> yow = do x <- getRandomNumber; return (quoteWithNumber x)
00:08:48 <dons> hehe. dolio, no :-) unless you count shapr.
00:08:49 <Cale> putStrLn is a function from Strings to IO actions
00:09:07 <Cale> When given a string, it produces the action which prints that string on the console.
00:09:08 <ejt_> dolio: http://www.ccil.org/jargon/jargon_40.html
00:09:10 <lambdabot> Title: The New Hacker's Dictionary - = Y =
00:09:20 <Cale> When given a particular string, it always gives the same action.
00:09:27 <LouieG> OH, you mean given the same input it does the same thing every time...?
00:09:42 <sjanssen> LouieG: not exactly
00:09:53 <sjanssen> in Haskell, you don't actually *do* anything
00:09:54 <Cale> the result is an action which (when eventually run) does the same thing
00:10:08 <sciolizer> LouieG: Given a particular string, it always returns the same mapping from input to output.
00:10:11 <dolio> Ah, okay. protontorpedo was, though, correct?
00:10:19 <sjanssen> your program constructs an action, which the compiler then interprets
00:10:27 <Cale> Let me explain it this way... there are two processes involved in running a Haskell program: evaluation, and execution
00:10:35 <ejt_> which Monad class is join from ?
00:10:37 <Cale> evaluation reduces expressions to values
00:10:39 <bitwiseshiftleft> haha, monads are hard...
00:10:58 <sjanssen> ejt_: it isn't in a class.  You can import it from Control.Monad
00:10:59 <Cale> execution is where an IO action is run, and its instructions are actually carried out
00:11:02 <bitwiseshiftleft> ejt: it's a helper function in Control.Monad
00:11:08 <bitwiseshiftleft> err, utility
00:11:13 <Cale> Nothing can be printed due to evaluation.
00:11:28 <Cale> (basically, all side effects occur during execution)
00:11:36 <LouieG> Cale: ok, does that mean everything must be fully evaluated by the time execution occures?
00:11:49 <bitwiseshiftleft> Cale: not really, no
00:11:56 <Cale> Well, not necessarily -- the runtime swaps back and forth between the two processes.
00:12:08 <ejt> so it's just something like: foldr1 ((>>=) id) ?
00:12:18 <dolio> @src join
00:12:19 <lambdabot> join x =  x >>= id
00:12:25 <Cale> bitwiseshiftleft: I know how it actually works, I'm explaining an abstract model :)
00:12:34 <ejt> thx
00:12:56 <sjanssen> LouieG: no, Haskell's laziness avoids this.  The compiler demands parts of the constructed action as it executes it
00:12:58 <bitwiseshiftleft> Cale: yeah, i misaddressed that, i meant to say it to LouieG
00:13:05 <Cale> So it starts off and decides "I need to execute main"
00:13:21 <Cale> To do this, it has to evaluate main enough that it knows the first thing to do.
00:14:07 <Cale> Every IO action is either a primitive, or it is some IO action bound to a function for computing the rest of the things to do.
00:14:13 <revence> LouieG: [putChar 'a', putChar 'b']
00:14:35 <Cale> bitwiseshiftleft: ah
00:14:46 <Cale> What revence typed is just a list of actions.
00:15:01 <LouieG> Cale: yes this is making scense....and without IO thrown in the pure functional model is quite simple.
00:15:02 <Cale> Evaluating that list will give you, well, a list, with no side effects.
00:15:07 <Cale> Right.
00:15:26 <Cale> The manipulation and construction of IO actions is purely functional though.
00:15:31 <Ademan> @everyone: what was the first functional programming language you learned?
00:15:31 <lambdabot> Unknown command, try @list
00:15:32 <Cale> It's just their execution which is not.
00:15:44 <LouieG> Cale: but the putChar must have a side effect?
00:15:55 <Cale> LouieG: Only when executed, not when evaluated.
00:15:56 <bitwiseshiftleft> Ademan: ML
00:16:06 <sciolizer> Ademan: Does Logo count?
00:16:08 <ejt> Ademan: scheme (if that counts)
00:16:11 <revence> Ademan: Unfortunately for me, it was Haskell. The horror!
00:16:19 <dolio> I tried learning haskell, then gave up, and learned scheme instead.
00:16:25 <LouieG> (sorry I read wrong line...I take that back)
00:16:30 <Cale> In fact, [putChar 'a', putChar 'b'] isn't an action, so you can't just execute it straight off.
00:16:55 <Cale> You might apply the sequence function to the list to get an action which performs each of the actions in the list in turn.
00:17:16 <Cale> sequence :: [IO a] -> IO [a]
00:17:44 <Cale> Turns a list of actions returning values of type a, into an action returning a list of results of type a.
00:17:44 <LouieG> Cale: isn't it important for haskall to preserve ordering between input actions and output putchar?
00:18:03 <Cale> It does -- execution happens in an ordered fashion.
00:18:09 <Ademan> revence: so you regret starting with haskell?
00:18:19 <bitwiseshiftleft> let me try my hand at explaining this...
00:18:21 <Cale> The ordering is determined by the >> and >>= operations for combining the actions.
00:18:41 <Cale> The sequence function will not run the things in parallel, but in sequence, the order they occur in the list.
00:18:45 <bitwiseshiftleft> an action is something with type IO a, and it can be one of 3 things
00:19:06 <bitwiseshiftleft> it can either be a primitive action, like getCh, which gets a character from stdin
00:19:10 <Cale> (though it would be easy to write a parallel composition function)
00:19:16 <revence> Ademan: Not really, but I nearly died. :o) Haskell is not where people should learn FP first. Brutal.
00:19:25 <bitwiseshiftleft> or, it can do nothing and give you some fixed value
00:19:35 <Cale> I disagree, Haskell's a perfect place to learn FP :)
00:19:42 <revence> I looked for the while loop, and failed to find it. You have it in ML, but not in Haskell.
00:19:53 <Ademan> revence: what would you recomend instead?  i'm trying to pick a first functional language, so far i've really only looked at ocaml and haskell
00:19:58 <vincenz> while c a = do
00:19:58 <ejt> revence: y, I would definitely recommend people start with Haskell
00:20:07 <vincenz>   t <- c
00:20:07 <bitwiseshiftleft> or it can do one action, get out a value, figure out another action from that value, and then do that action
00:20:08 <revence> The transition kills many people. See this car here? That's Haskell on day one.
00:20:13 <vincenz>   if t then a else return ()
00:20:21 <LouieG> revence: I was made to learn lisp in classes, but haskell would have been so much better
00:20:23 <vincenz> while c a = c >>= \t -> if t then a else return ()
00:20:31 <Cale> vincenz: not quite
00:20:38 <lucca> sciolizer: REPEAT 4 [FD 50 RT 90]
00:20:39 <Cale> vincenz: you missed the recursive call.
00:20:42 <vincenz> oops
00:20:43 <vincenz> :)
00:20:50 <Japsu> LOGO <3
00:20:51 <bitwiseshiftleft> Ademan: an ML family language, like OCaml or Standard ML
00:20:52 <vincenz> while c a = c >>= \t -> if t then a >> while c a else return ()
00:21:12 <Cale> That's the advantage of having IO actions be first class values.
00:21:20 <vincenz> yah
00:21:22 <sciolizer> lucca: :)
00:21:23 <Cale> You can easily whip up your own control structures.
00:21:27 <revence> I have three scars on my forehead. That's from learning Haskell as the first FP. ML would have been gentler.
00:21:30 <Ademan> bitwiseshiftleft: they're lazy fp rigth? is that why?
00:21:31 <revence> :o)
00:21:40 <Ademan> right* even
00:21:44 <vincenz> doWhile a c = a >> while c a
00:21:53 <sjanssen> Ademan: Haskell is fine as a first functional language
00:22:14 <bitwiseshiftleft> Ademan: at least for me, ML languages are the parts of Haskell that are easiest to understand
00:22:18 <vincenz> doUntil a c = a >> while (liftM not c) a
00:22:19 <bitwiseshiftleft> so they're a decent stepping stone
00:22:23 <Cale> Haskell has a really good community to help, use it extensively :)
00:22:33 <bitwiseshiftleft> but Haskell isn't a bad choice
00:22:47 <vincenz> Cale: gotta like that last one :)
00:22:54 <Ademan> well i figure i'll end up learning haskell at some point, i just need to pick a good entry point into functional programming
00:22:54 <Cale> vincenz: yeah :)
00:23:06 <sjanssen> what's the point of learning a functional language with imperative features like while loops?  Will you really learn if you always have that imperative crutch to lean on?
00:23:15 <revence> Yeah. The community. This is the only community where someone can type `do you have a pen there?'
00:23:21 <jkarres> haskell is my first functional language
00:23:22 <LouieG> So apart from IO, are there other functions having side effects (you said shared state?)
00:23:39 <revence> sjanssen: No, but the culture shock is like so:
00:23:41 <Ademan> sjanssen: i suppose so you can learn it bit by bit?
00:23:49 <jkarres> i was afraid if i picked a mixed language, i wouldn't really know which parts are 'functional' and which aren't
00:23:51 <sjanssen> LouieG: nope, only things based on IO can have side effects
00:23:51 <Cale> LouieG: well, there are other monads, which are typically not IO, but other modes of computation.
00:23:59 <bitwiseshiftleft> LouieG: no, functions acnnot have side effects
00:24:07 <vincenz> haskell is my last language, except for the dozen zillion little languages I write compilers for in hasklel
00:24:14 <vincenz> @remember vincenz haskell is my last language, except for the dozen zillion little languages I write compilers for in haskell
00:24:15 <lambdabot> Done.
00:24:17 <Cale> Only the IO monad (and monads built up from it) is allowed to do I/O.
00:24:20 <sjanssen> LouieG: and this is a truly beautiful thing.  Consider this little evaluator in lambdabot:
00:24:25 <sjanssen> > 10 + 2
00:24:26 <lambdabot>  12
00:24:31 <revence> No loops. Okay, I'll use recursion. main = do .... main (throws an error). length(getLine) (throws an error). No! Where's my Java book?
00:24:53 <sjanssen> LouieG: how can dons sleep at night, fearing that we might rm -rf / ?
00:24:56 <vincenz> line <- getLine
00:24:58 <vincenz> length line
00:25:00 <Cale> Well, there's also ST, that allows for no IO, but the creation of mutable cells.
00:25:06 <dons> > readFile "/etc/passwd"
00:25:07 <lambdabot>  <IO [Char]>
00:25:15 * dons goes back to sleep
00:25:17 <dons> phew.
00:25:20 <sciolizer> http://www.arcknowledge.com/gmane.comp.lang.haskell.template/2005-01/msg00009.html <- auto generating deriving instances with Template Haskell (have yet to try)
00:25:22 <bitwiseshiftleft> dons: lol
00:25:23 <lambdabot> Title: Re: example of derive using Template Haskell?, http://tinyurl.com/ypne8t
00:25:24 <ivanm> ?localtime dons
00:25:26 <lambdabot> Local time for dons is Thu Mar 29 17:23:25 2007
00:25:26 <vincenz> > liftM length $ readFile "/etc/passwd"
00:25:26 <LouieG> Can haskell interface at all with external libraries? All of these would have to be treated like IO.
00:25:28 <lambdabot>  <IO Int>
00:25:34 <vincenz> dons: hah!
00:25:37 <Cale> LouieG: yes, there's a great FFI
00:25:38 <ivanm> dons: why are you going to sleep in the middle of the afternoon?
00:25:39 <revence> Yeah, but the guy who just has a series of `Blurb in twenty days' will cry when he gets to the twentieth day, and he hasn't even printed `Hello, World!'.
00:25:45 <vincenz> @localtime dons
00:25:47 <lambdabot> Local time for dons is Thu Mar 29 17:23:46 2007
00:25:52 <Cale> LouieG: there are ways to cheat if you know that the external call is pure
00:25:54 <sjanssen> LouieG: dons *knows* we can't, because only IO can do stuff like that, and lambdabot ignores anything with an IO type
00:25:57 <dons> main = print "hello, world" -- done.
00:26:14 <dons> yeah, the type checker generates a proof the code does no evil IO.
00:26:27 <ejt> revence: I agree that a lot of tutorials/books should introduce IO earlier
00:26:46 <Cale> I don't know. I think that the REPL is decent enough.
00:26:46 <bitwiseshiftleft> > unsafePerformIO (readFile "/etc/passwd")
00:26:47 <lambdabot>   Not in scope: `unsafePerformIO'
00:26:49 <vincenz> I always wonder why "helo world" is considered significative
00:26:53 <bitwiseshiftleft> (as expected)
00:26:55 <Cale> I wasn't unhappy learning in the REPL myself.
00:26:55 <ejt> I found there was a large gap between book code (eg, Bird/Wadler) and real world code
00:27:03 <vincenz> @hoogle unsafePerformIO
00:27:04 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
00:27:10 <dons> yep, you require a trusted base, of course.
00:27:12 <revence> ejt: But yet you can't introduce it without metioning Simon Peyton-Jone's latest papers ... :o(
00:27:16 <vincenz> > Foreign.unsafePerformIO (readFile "/etc/passwd")
00:27:16 <dons> one i trust doesn't have unsafePerformIO in it.
00:27:17 <lambdabot>   Not in scope: `Foreign.unsafePerformIO'
00:27:24 <Cale> vincenz: there are newbies in the channel!
00:27:31 <Cale> hehe
00:27:48 <vincenz> back to my tpyechecker
00:27:53 <LouieG> Guys thanks alot for talking, I will try to learn this beast... maybe I'll be somewhat smarter when I return. For now I must sleep.
00:27:58 <ivanm> vincenz: and spell checker? ;-)
00:27:59 <ejt> revence: I think you can in a recipe book way, just so beginners can produce programs that do something ... the details can be filled in later
00:28:04 <bitwiseshiftleft> gnight LouieG
00:28:07 <kaol> ?users
00:28:08 <lambdabot> Maximum users seen in #haskell: 337, currently: 293 (86.9%), active: 30 (10.2%)
00:28:19 <vincenz> ivanm: no, I only deal with semantics, syntax is overrated
00:28:28 <ivanm> lol
00:29:05 <Cale> Really, unsafePerformIO ought to require a compiler flag, along with everything that uses it, unless there's an explicit pragma to not inherit that property. (and compiling a module with such a pragma should still require the flag, only future modules exempted)
00:29:24 <Cale> -fmy-first-name-is-simon
00:29:36 <sjanssen> -fi-know-what-i-am-doing
00:29:42 <revence> ejt : Yeah. It's nice to show that stuff works, then go into the hard stuff. I write my tutorials by first opening files and so on. People don't have to know what's going on. Just that it is going on. The pleasure of one's code working is responsible for the existence of the computer. Not necessarily the comprehension of what the code is doing. :oD
00:29:53 <sjanssen> -fall-guarantees-are-void-in-the-presence-of-unsafePerformIO
00:30:21 <bitwiseshiftleft> unsafePerformIO breaks the type system, too, not just the referential transparency
00:30:29 <revence> sjanssen: LOL
00:30:35 <sjanssen> yeah, it pretty much breaks everything
00:30:49 <dons> i think you could accumulate `unsafe points' with each program that type checks. ghc would record this count. then you get to spend your 'unsafe' points towards future unsafePerformIO uses.
00:31:09 <dons> say, for every 10 programs that type check, you get one use of unsafePerformIO to spend.
00:31:11 <bitwiseshiftleft> sjanssen: isn't there a debian warning sort of like that?
00:32:49 <revence> dons: Interesting. Also, you can earn unsafePerformIO calls. If GHC is impressed with your code, you get one more. :o)
00:32:53 <bitwiseshiftleft> aha, in Ubuntu
00:32:54 <bitwiseshiftleft> WARNING: Performing this action will probably cause your system to break!
00:32:54 <bitwiseshiftleft> Do NOT continue unless you know EXACTLY what you are doing!
00:32:55 <bitwiseshiftleft> To continue, type the phrase "I am aware that this is a very bad idea":
00:32:56 <revence> :oD
00:33:09 <dons> "cause your *type* system to break"
00:33:14 <sjanssen> Cale: that'd probably be nicer on per function basis
00:33:29 <sjanssen> {-# UNSAFE unsafePerformIO #-}
00:33:58 <sjanssen> {-# PROMISE_IT_IS_SAFE foo #-}
00:34:09 <bitwiseshiftleft> of course, here we are bashing unsafePerformIO, but is there any other way to implement singletons?
00:34:34 <dons> sjanssen: so we need X11>=1.2 now?
00:34:40 <dons> was it bumped by yesterday's patch?
00:34:53 <sjanssen> and then a compiler will only honor recognize the PROMISE pragma if it receives a compiler flag, otherwise the UNSAFE is propagated
00:34:53 <Cale> sjanssen: the point is to make it so that the person who is compiling the code is aware, not just the original programmer
00:35:20 <sjanssen> dons: X11 >= 1.1 works, I think
00:35:34 <dons> Setup: cannot satisfy dependency X11>=1.2
00:35:42 <dons> we've got, build-depends:      base, X11>=1.2
00:35:52 <dons> but is that overly precise?
00:35:56 * dons tries.
00:35:59 <sjanssen> oh, X11-extras is 1.2
00:36:09 <sjanssen> I think 1.1 is missing a Show instance
00:37:52 <sjanssen> dons: yeah, no Show instance for Display -- needed it for Event's Show instance
00:38:31 <revence> GHC error: Please, swipe your thumbprint. And then a check with haskell.org, if you qualify to use unsafePerformIO. Where do we register? Okay, I'm gone, lambdamen. getHashHaskell >>= mapM (\x -> if x == "dons" then whyAreYouAlwaysHereAndSadGoodbye else sadGoodbye)
00:38:45 <Cale> heh
01:18:10 <laziest> any alternative than 'show' for displaying Doubles?
01:18:26 <laziest> any faster alternative?
01:19:50 <sciolizer> Text.PrettyPrint.HughesPJ.double :: Double -> Doc
01:19:59 <sciolizer> (probably no faster though. =/)
01:20:48 <quicksilver> :t showFFloat
01:20:50 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
01:21:08 <quicksilver> laziest: 'faster'? is 'show' really slow?
01:21:11 <laziest> it has similar speed
01:21:15 <laziest> ya...
01:21:19 <quicksilver> how slow?
01:21:31 <laziest> in a program that I profiled, 95% of the time was consumed in show
01:21:39 <laziest> I was generating about 3**15 numbers
01:21:49 <quicksilver> > 3**15
01:21:50 <ndm> @seen sorear
01:21:50 <lambdabot> I saw sorear leaving #darcs, #haskell-overflow, #ghc and #haskell 4h 53m 9s ago, and .
01:21:50 <lambdabot>  1.4348907e7
01:22:15 <quicksilver> laziest: interesting
01:22:34 <laziest> I think I should paste it..
01:23:48 <dons> laziest: print into bytstrings, rather than [Chra]
01:24:01 <dons> since you're producing mb of output.
01:24:11 <quicksilver> ah that makes sense
01:24:21 <laziest> hmm.. let me see whether I have bytestrings...
01:24:23 <quicksilver> surely more likely to be list overhead than show overhead as such
01:24:56 <sjanssen> > 3 ^ 15
01:24:58 <lambdabot>  14348907
01:25:02 <laziest> but the list generating function doesn't take time... Is laziness coming in?
01:25:22 * laziest trying to search the program
01:30:29 <laziest> ?hpaste
01:30:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:30:38 <ndm> @seen Igloo
01:30:38 <lambdabot> Igloo is in #haskell-soc, #haskell, #darcs, #ghc, #gentoo-haskell and #haskell.hac07. I last heard Igloo speak 7h 6m 59s ago.
01:31:18 <ndm> @tell Igloo I can't see any new FilePath patches in darcs.haskell.org/packages/filepath - should i be able to?
01:31:19 <lambdabot> Consider it noted.
01:31:31 <quicksilver> it could even be that show is being 'credited' the time that really belongs to the calculation function
01:31:38 <quicksilver> if the calculation function gets inlines
01:31:53 <quicksilver> (because the actual calculation won't happen until forced by the show)
01:32:28 <hpaste>  laziest pasted "Cantor set generating code (generates about 3 ** 17 points) and the profile" at http://hpaste.org/1179
01:34:41 <laziest> how do you *really* get the times then?
01:35:10 <quicksilver> the fact that cantor only has 18 entries should be a clue, I think
01:35:16 <quicksilver> that something isn't being counted right...
01:36:16 <quicksilver> you should get dons to look at it, he's good with fast benchmark type code :)
01:36:26 <laziest> In fact earlier on a different program the profiler was correct in estimating the time
01:36:26 <laziest> quicksilver: oh ya, I noticed that too..
01:36:45 <laziest> ...estimating the time even when the crucial function was nonstrict...
01:36:47 <laziest> hmm..
01:36:57 <laziest> ?seen dons
01:36:57 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 12m 56s ago.
01:37:33 <laziest> thanks quicksilver! will return soon.
01:42:36 <quicksilver> Oh, I can see why laziest's code is slow
01:42:47 <quicksilver> it's building up huge lifts on the left of ++s
01:44:12 <quicksilver> hmm or is it
01:44:15 * quicksilver shrugs
01:44:28 <vincenz> @hoogle sortBy
01:44:29 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
01:47:39 <vincenz> grr
01:47:44 <vincenz> why can't do something smarter like
01:48:00 <vincenz> sortBy :: (Ord b) => (a -> b) -> [a] -> [a]
01:48:16 <ejt> you can
01:48:21 <vincenz> yeah with comparing
01:50:30 <quicksilver> there is also this idea to add an infix `on`
01:50:43 <quicksilver> which binds the (a->b) in your example
01:50:58 <quicksilver> I think it's in the HEAD version of the libs already?
01:58:53 <profmakx> hey guys! is there a function that parses a String and gives a CalendarTime? (or, Maybe CalendarTime)
01:59:15 <vincenz> or m CalendarTime
01:59:30 <profmakx> whatever ;)
02:00:16 <vincenz> m CalendarTime subsumes Maybe CalenderTime and therefore woudl be more generic and more useful
02:02:05 <profmakx> hm
02:02:05 <profmakx> okay
02:02:16 <profmakx> but is there such a function or do I have to write one?
02:02:40 <vincenz> @hoogle CalendarTime
02:02:41 <lambdabot> System.Time.CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
02:02:41 <lambdabot> System.Time.CalendarTime :: data CalendarTime
02:02:41 <lambdabot> Time.calendarTimeToString :: CalendarTime -> String
02:03:02 <profmakx> thats what I tried first before i asked here
02:03:10 <vincenz> most likely it's roll your own
02:03:18 <profmakx> okay
02:04:03 <quicksilver> vincenz: nah m CalendarTime is *nasty*
02:04:09 <vincenz> quicksilver: how so?
02:04:12 <quicksilver> vincenz: since it assumes every monad is a failure monad
02:04:15 <vincenz> at least you can do
02:04:18 <quicksilver> which is just sloppy :P
02:04:24 <vincenz>  t <- parseDateTime s
02:04:36 <vincenz> quicksilver: don't blame me for the faults in Monad
02:04:37 <quicksilver> it should be (MonadZero m) => or (MonadError m) =>
02:04:52 <vincenz> and it's MonadError e m
02:04:55 * quicksilver nods
02:04:57 <quicksilver> indeed :)
02:05:01 <quicksilver> not quite the point, though
02:05:21 <vincenz>         void      = PSig $ tArr ! 0
02:05:37 <lucca> @arr
02:05:37 <lambdabot> Arrr!
02:08:03 <hpaste>  cragwolf annotated "Project Euler Problem #12" with "Much faster method" at http://hpaste.org/1167#a1
02:10:13 <quicksilver> vincenz: and, I wasn't blaiming you for faults in Monad. But I was merely suggesting that as advice for function type design, MonadZero or MonadError are better things to aim for than Monad
02:12:22 <vincenz> quicksilver: I know, but since it's borked anyways, it'd be useful o make it generic
02:13:09 <vincenz> s/o/to
02:14:06 <vincenz> [0..-1]
02:14:15 <vincenz> > [0..-1]
02:14:16 <lambdabot>   Not in scope: `..-'
02:14:21 <vincenz> > [0..(-1)]
02:14:22 <lambdabot>  []
02:14:35 <ivanm> is there a command to run a haskell command at the prompt?
02:14:46 <quicksilver> > [0,(-1),..(-6)]
02:14:46 <lambdabot>  Parse error
02:14:53 <quicksilver> > [0,(-1)..(-6)]
02:14:54 <lambdabot>  [0,-1,-2,-3,-4,-5,-6]
02:15:08 <quicksilver> ivanm: runhaskell
02:15:30 <ivanm>  # runhaskell 1 + 2
02:15:33 <ivanm> doesn't work...
02:15:45 * quicksilver nods
02:15:54 <quicksilver> runhaskell is for runnign 'haskell scripts'
02:16:44 <quicksilver> ghc -e '1+2'
02:16:53 <ivanm> quicksilver: ahh, quotes...
02:17:10 <quicksilver> no, not quotes. ghc -e instead of runhaskell :)
02:17:16 <quicksilver> but yes, obviously you do need quotes
02:17:23 <quicksilver> otherwise your shell will eat the code
02:17:29 <ivanm> quicksilver: that's what I was missing... thought it was -e
02:17:54 <mux> mmm, binary 0.3
02:19:06 <JohnMeacham> ping.
02:19:09 <JohnMeacham> someone called?
02:19:47 <quicksilver> ghc -e "putStrLn \$ \"Shell Escaping is a \\\"mess\\\"\""
02:20:33 <ivanm> quicksilver: lol
02:44:21 <vincenz> can you use record syntax with newtype's or only data's?
02:46:19 <lemmih> vincenz: You can use record syntax with newtype's.
02:47:10 <vincenz> lemmih: cool, thx, btw, talked to adept, he says he'd like to stick to 'lazy bottoms' as teamname (as would I, to keep some contuinity)
02:47:26 <lemmih> Okay.
02:47:48 <dcoutts> planning icfp contest already I see
02:48:00 <vincenz> dcoutts: yah
02:48:07 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/icfp2007.html
02:48:09 <lambdabot> Title: ICFP Contest 2007
02:48:22 <vincenz> lemmih: apparently not:     The constructor of a newtype must have exactly one field but `TI' has six
02:48:46 <vincenz> (well I guess you could for one field, but then it kinda loses its purpose
02:50:00 <lemmih> vincenz: Having more than one field in a newtype doesn't make sense.
02:50:08 <vincenz> lemmih: true
02:52:52 <vincenz> @hpaste
02:52:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:53:05 <hpaste>  vincenz pasted "techreqs" at http://hpaste.org/1180
02:53:16 <vincenz> lemmih: see any other techrqs than http://hpaste.org/1180?
03:12:01 <ski> @pure
03:12:02 <lambdabot> Maybe you meant: more part url
03:40:24 <tsp> @src takeWhile
03:40:24 <lambdabot> takeWhile _ []                 =  []
03:40:25 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
03:40:25 <lambdabot>                    | otherwise =  []
03:40:40 <tsp> lol that can't be right - that's the entire source for the takeWhile function?
03:40:56 <quicksilver> yup :)
03:40:59 <quicksilver> cute, isn't it?
03:41:11 <quicksilver> very few of the basic library functions are more than, say, 4 or 5 lines
03:41:28 <tsp> I don't udnerstand it though :)
03:41:38 <tsp> what's the | for?
03:41:43 <quicksilver> that's a guard
03:42:01 <tsp> I get the first line - if their is an empty list, return an empty list
03:42:30 <quicksilver> the other case is equivalent to if p x then x : takeWhile p xs else []
03:42:44 <quicksilver> guards are generally felt to be more elegant than top-level if statements
03:42:48 <tsp> ah
03:42:52 <quicksilver> they scale better to more than two possible options
03:43:10 <tsp> so if p x is true, it'll add x to the list and call takeWhile again?
03:43:14 <quicksilver> right
03:43:17 <tsp> wow
03:43:37 <tsp> that function probably took forever to reason through - at least for me, I don't get recursive functions that much
03:44:04 <tsp> unfortunately, haskell can't parse strings - e.g. replace "foo" in some string with bar
03:44:12 <tsp> witout using regexs that is
03:44:34 <quicksilver> haskell can parse strings
03:44:41 <quicksilver> to haskelll, a string is a list of characters
03:45:13 <tsp> yeah, a list of chars - but that's sort of useless
03:45:35 <tsp> if I wanted to replace foo with bar, I'd need to go through the string in groups of 3 and replacing it if it = foo
03:46:24 <tsp> :t take
03:46:27 <lambdabot> forall a. Int -> [a] -> [a]
03:46:35 <quicksilver> that is exactly what any other language would do, though
03:46:40 <tsp> ah
03:46:42 <quicksilver> in some sense that is the 'only' way it can be done
03:46:55 <tsp> > take 3 "foo bar"
03:46:57 <lambdabot>  "foo"
03:47:00 <tsp> neat
03:47:05 <tsp> > take 3 "ty"
03:47:07 <lambdabot>  "ty"
03:47:12 <quicksilver> @src take
03:47:12 <lambdabot> take n _      | n <= 0 =  []
03:47:13 <lambdabot> take _ []              =  []
03:47:13 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
03:47:24 <tsp> wow, 3 lines long
03:47:28 <tsp> for such a useful function
03:47:48 <quicksilver> there's also isPrefixOf
03:47:50 <pejo> tsp, it takes a while to get used to recursion for most of us.
03:48:05 <quicksilver> > "foo" `isPrefixOf` "foobarbaz"
03:48:06 <lambdabot>  True
03:49:46 <tsp> in some ways, haskell is primative - like strings and such - but I guess its just another way of thinking about it
03:50:14 <pejo> tsp, primitive in what way?
03:51:19 <tsp> well
03:51:23 <tsp> you can't do something like
03:51:44 <tsp> s = replaceInString s "foo" "bar"
03:51:53 <tsp> s = replaceInString s "someString" "someOhterString"
03:51:54 <quicksilver> really that's a library issue
03:51:58 <quicksilver> not a language issue
03:52:01 <tsp> you have to string them together or something
03:52:31 <resiak> well, the assigning-back-to-the-same-variable thing is a language issue, surely?
03:52:36 <tsp> it's also a language issue - immutible variables - in other langs, I can just keep diong one calculation after another
03:52:37 <Saizan> well s = replaceInString s "foo" "bar" would be a recursive definition :)
03:53:03 <pejo> resiak, you can shadow definitions in haskell. let x = 5 in let x = 8 in x.
03:53:20 <tsp> I come from a python background :) python and c
03:53:21 <ToRA> tsp; i'd rather have a split function to split on the "foo", and then use intersperse and concat to put in the bar
03:53:29 <tsp> and perl, etc
03:53:31 <resiak> pejo: oh, sure, but tsp's example is a recursive definition, as Saizan said
03:53:32 <quicksilver> I don't think his point was about the s= though :)
03:53:44 <quicksilver> I think the point is about replaceInString not being in the standard libs
03:53:44 <tsp> so doing s.replace ("fo","bar") in python, then s = s.replace, s=s.repalce, etc all through a list
03:53:57 <quicksilver> > let {replace s s' [] = []; replace s s' t@(x:xs) = if s `isPrefixOf` t then s' ++ replace s s' (drop (length s) t) else x:(replace s s' xs)} in replace "foo" "apple" "a foo a bar a baz another foo"
03:53:58 <lambdabot>  "a apple a bar a baz another apple"
03:54:10 <quicksilver> tsp: there you go. it's only about a line long :)
03:54:16 <tsp> quicksilver: how did you come up with that?
03:54:29 <pejo> resiak, you mean let s = replaceInString s "foo" "bar" in ... isn't possible?
03:54:29 <Saizan> tsp: you'll find that there's no need to describe a list of computations to write most of your program :)
03:54:29 <quicksilver> tsp: I have ghci open in another window, I wrote it, tested it, and then pasted it here :)
03:54:41 <quicksilver> pejo: that's a recursive reference to the same 's'
03:54:45 <quicksilver> pejo: probably not what you want :)
03:55:14 <quicksilver> tsp: you make an interesting point though. Haskell is 'primitive' in the following sense:
03:55:36 <quicksilver> tsp: Haskell gives you an incredibly powerful set of primitive, from which it is surprisingly easy and concise to construct more complex programs
03:55:43 <pejo> quicksilver, hm. Doh. Of course.
03:55:43 <tsp> I don't get the s' and the t@'s etc - are those variable names?
03:55:56 <quicksilver> tsp: yes, the ' character is pertmitted in variable names
03:56:00 <tsp> quicksilver: lol, I thought you were gonna bash haskell
03:56:07 <tsp> neat
03:56:08 <quicksilver> tsp: it's a mathmo-thing; people read it as 'prime'
03:56:11 <tsp> and the @?
03:56:17 <quicksilver> tsp: that's to give a name to a pattern
03:56:28 <quicksilver> tsp: so (x:xs) is a pattern, but I want to call the 'whole thing' t
03:56:39 <tsp> x:xs is just a list
03:56:55 <quicksilver> tsp: otherwise I would just write (x:xs) in the two places I wrote 't', but would be fine, but maybe slihtly less clear
03:56:58 <tsp> I'm guessing x maps to head l, and xs maps to tail l
03:57:01 <quicksilver> tsp: x:xs is a non-empty list
03:57:03 <quicksilver> tsp: that's right
03:57:10 <tsp> ah, I'm starting to get this
03:57:28 <Saizan> > (\t@(x:xs) -> (x,xs,t)) [1..3]
03:57:30 <lambdabot>  (1,[2,3],[1,2,3])
03:57:54 <tsp> theoretically in haskell, I could make an infinate list of, say, useless fibonacci numbers?
03:58:12 <Baughn> tsp: Sure, quite easily. More of a process than a list, but it does pretend to be a list.
03:58:45 <Saizan> > fix ((1:) . scanl (+) 0)
03:58:46 <lambdabot>  [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1094...
03:58:55 <tsp> wow
03:59:15 <Baughn> tsp: Or an (oddly useful) tree of Every Possible String. Yes, all aleph-0 of them - that was a rather inefficient parser, actually.
03:59:16 <tsp> I'm no haskell wizard, but even I have to admit the power in that
03:59:18 <pejo> tsp, but why would you want an infinite useless list?
03:59:34 <tsp> pejo: to get the hundredth fib when someone asks for it
03:59:43 <quicksilver> there is of course a closed form for that :)
04:00:03 <Baughn> tsp: If you make an infinite list, the list will stay around and never be GCed (unless you drop all references, of course)
04:00:10 <tsp> oh
04:00:14 <quicksilver> Baughn: erm?
04:00:18 <Baughn> tsp: If you make a function that gives the Nth number, that may not be the case
04:00:20 <tsp> Baughn: but you can't pass it around os it'll die when the function exits
04:00:22 <quicksilver> Baughn: and that is different from finite lists, how?
04:00:27 <quicksilver> Baughn: or any other kind of list?
04:00:30 <Baughn> quicksilver: It isn't
04:00:33 * quicksilver nods
04:00:41 <quicksilver> seems curioius to emphasise the point on infinite ones :)
04:00:48 <Baughn> It's just that, in many cases, you can make a function to calculate the Nth number /without/ having all the previous numbers stick around forever
04:00:52 * quicksilver nods
04:01:10 <Baughn> It's sort of useful for memoizing, though
04:01:11 <tsp> another piont is that I can't keep global variables in haskell - e.g. isRunning, currentLine, etc
04:01:15 <quicksilver> equally if I write the version nthfib n = let fibs = ... in fibs !! n
04:01:20 <quicksilver> then the list won't stay around
04:01:27 <lemmih> tsp: That's a feature. (:
04:01:39 <tsp> lemmih: not really - that precludes me from writing, say, a screen reader
04:01:39 <Baughn> I had a tree of every possible string, each one mapped onto a parser, that neatly memoized my parsing without a stitch of imperative code in sight
04:01:53 <quicksilver> it's a local let bound variable and the reference I return doesn't leak anything
04:02:00 <quicksilver> tsp: of course you can write a screen reader :)
04:02:09 <lemmih> tsp: How so?
04:02:11 <quicksilver> tsp: there are other ways to store state than global variables
04:02:22 <tsp> quicksilver: how? I'd need to keep synth-specific info like current index mark etc
04:02:23 <quicksilver> tsp: there are IORefs in the IO monad, for example
04:02:30 <quicksilver> tsp: and there are State monads
04:02:40 <tsp> yes, but I'd need to thread a monad with the IORef through everything
04:02:44 <Baughn> tsp: You /can/ store state as global variables (IORef), but that is frowned on even in imperative languages - much more so in haskell. It just isn't clean.
04:02:51 <tsp> and the code would get ugly
04:03:00 <quicksilver> tsp: typically, the code gets beautiful
04:03:10 <tsp> synthSpeakString monad "test"
04:03:15 <tsp> compared to synthSpeakString "test"
04:03:26 <quicksilver> tsp: each function advertises exactly what state (or none at all) it depends on
04:03:28 <Saizan> you don't use monads that way :)
04:03:38 <quicksilver> tsp: which makes everything re-entrant, and easy to optimise and understand
04:03:53 <tsp> damn, I can't remember what I was going to code in haskell
04:03:58 <tsp> oh, an esperanto supersigno replacer
04:04:03 <Baughn> tsp: Try a TCP stack
04:04:11 <tsp> Baughn: heh
04:04:37 <Baughn> tsp: I've got the most obscure possible bugs here, caused by overuse of unsafeInterleaveIO
04:04:56 <tsp> Baughn: your writing a tcp stack?
04:04:59 <tsp> in haskell? why
04:05:40 <Baughn> tsp: For very sad reasons. Someone wrote a server that badly misuses udp, supposedly so they can have two services on the same port. (!)
04:05:44 <quicksilver> Baughn: Is your name Simon?
04:05:59 <Baughn> quicksilver: No.
04:06:07 <quicksilver> Baughn: Did nobody explain to you that the unsafe functions are only for people called Simon?!
04:06:13 <quicksilver> Baughn: Someone could get hurt.
04:06:39 <tsp> Baughn: heh
04:06:41 <psnl> dcoutts: have you ever used the function menuPopup in gtk2hs?
04:06:50 <Baughn> quicksilver: At some point I'm pretty sure it ACKed packets before receiving them
04:06:56 <dcoutts> psnl: not myself
04:06:58 <quicksilver> Baughn: that's an optmisation! :)
04:07:02 <quicksilver> Baughn: much faster that way...
04:07:07 <quicksilver> Baughn: optimistic ACKing...
04:07:17 <Baughn> quicksilver: Riiight
04:07:23 <tsp> Baughn: how could it ack before receiving them?
04:07:24 <psnl> dcoutts: I'm wondering if it works...
04:08:02 <Baughn> tsp: Well, unsafeInterleaveIO removes time constraints on the IO in question, meaning it can happen at any time, se...
04:08:12 <Baughn> tsp: Apparently that includes "before the event that triggered it"
04:08:27 <Baughn> tsp: No, I have no idea, but I've got the packet log to prove it
04:08:35 <dcoutts> psnl: I thought it did, but you might know better
04:08:52 <hpaste>  psnl pasted "menPopup" at http://hpaste.org/1181
04:09:15 <psnl> dcoutts: that look right to you?
04:10:21 <dcoutts> psnl: try showing everything, setting them to be visible
04:16:29 <tsp> Baughn: lol, acks before the packet got received - how did haskell know it was received to ack it
04:17:26 <Baughn> tsp: Time-loop logic?
04:17:55 <psnl> dcoutts: ok, I'm not seeing how to do that
04:17:56 <tsp> hmm
04:18:04 <tsp> learning haskell is worse then learning swedish
04:18:14 <tsp> tried swedish but gave up
04:18:46 <therp> I gave up on Japanese, but not on Haskell.
04:19:14 <therp> This was the right choice, as I'm able to talk to japanese haskell programmers in haskell now.
04:19:30 <therp> I wonder what "go and have a drink tonight" look like in lambda calculus?
04:19:48 <tsp> therp: how so?
04:20:58 * therp .oO("would you show a girl your Y combinator?")
04:21:48 <psnl> dcoutts: ooh, thanks, got it
04:21:55 <ski> .. and what's the 'X' combinator ?
04:22:41 <dcoutts> psnl: oh good
04:22:41 <ski> .. '\x -> x x' ?
04:23:53 <therp> ski: I presume when you combine XX and XY, after 9 month, you get something that keeps you busy for the next 20 years.
04:24:07 <vincenz> therp: and if you live in italy, for the next 40 years
04:24:08 <therp> so basically, apply (XX) to (XY).
04:24:30 <tsp> waht does combine xx and xy mean?
04:24:35 <therp> vincenz: only if you are the part that contributed XX :)
04:24:40 <tsp> I'm sorta lost
04:24:46 <quicksilver> tsp: they're talking about sex chromosomes
04:24:47 <vincenz> tsp: therp is being an ultrageek
04:24:51 <therp> tsp: I'd say function application.
04:25:04 <quicksilver> Anyone know who tom moertel is?
04:25:13 <tsp> quicksilver: oh
04:25:16 <ski> let x = \x -> x x in \f -> let y = \y -> f (y y) in x y  -- ?
04:25:44 <Igloo> ndm: The changes are only in darcs.haskell.org/ghc-6.6/packages/filepath at the moment
04:25:52 <earthy> ski: no, actually, X = \ f . f S (\xyz.x) where S = X (X X)
04:25:53 <therp> ski: let y = \f -> (f (y f))
04:26:20 <earthy> but see also http://www.cs.uu.nl/people/jeroen/article/combinat/combinat.ps
04:26:50 <ski> quicksilver : 'tmoertel' on freenode, i think
04:27:20 <quicksilver> ski: I don't really agree with his comments on IO values :)
04:27:23 <ski> earthy : no that 'X' ..
04:27:23 <therp> ski: oh, nice. I didn't know that Y combinator form.
04:27:32 <earthy> ski: :)
04:27:34 <ski> quicksilver : .. comments ??
04:27:43 <quicksilver> ski: in a blog post
04:27:50 <ski> (earthy : s/no/not/ ..)
04:27:52 <earthy> why not?! it's a full one-combinator base. :)
04:28:05 <earthy> you *need* X for life, right? :)
04:28:26 * ski was renaming 'Omega' into 'X'
04:28:36 <earthy> um, small omega
04:28:44 <ski> uh, right
04:28:54 * earthy saw that ;)
04:28:58 <ski>  (:
04:29:27 <ski> quicksilver : let me guess .. another monad tutorial ?
04:29:57 <ski> (Nickname: tmoertel
04:29:59 <ski>  Last Seen: 18 hours 29 minutes 30 seconds ago)
04:30:55 <quicksilver> ski: no, he's doing a recursive directory tree thingy
04:31:04 <tsp> gonas
04:31:07 <tsp> s/gonas/gonads
04:31:07 <ski> mhm
04:31:08 <tsp> heh
04:31:09 <earthy> > let x = \f -> f (\ x y z -> x z ( y z ) ) (\ x y z -> x) in let k = x x in let s = x ( x x ) in let i = k k in (s i i) (s i i)
04:31:10 <lambdabot>      Occurs check: cannot construct the infinite type:
04:31:10 <lambdabot>       t = t3 -> t1 -> ...
04:31:16 <earthy> hm. right. :)
04:31:24 <ski> earthy : try 'ocaml -rectypes' ..
04:31:41 <earthy> no thanks. :)
04:32:43 <desp> heh
04:32:47 <ski> @run (\x -> x) "foo"
04:32:49 <lambdabot>  "foo"
04:32:54 <ski> or that ^
04:33:09 <ski> or, hm ..
04:33:33 <tsp> >let s = "feli'caj kolbasoj" in replace "'c" "cx" s where replace str1 str2 mainstr = if isPrefixOf str1 mainstr then str1 else str2 endif
04:33:34 <vincenz> any easy way of growing arrays?
04:33:41 <tsp> damn, I think that died
04:33:48 <resiak> tsp: you need a space after >
04:33:52 <quicksilver> tsp: you missed a space after you '>'
04:33:56 <tsp> I doubt that would evaluate anyway
04:33:58 <ski> hm .. was the LC evaluator removed ?
04:34:09 <ski> (there used to be one)
04:34:34 <tsp> > filter (< 5) [1,,6]
04:34:35 <lambdabot>  Parse error
04:34:45 <tsp> that should have worked
04:34:55 <earthy> should it?
04:34:58 <tsp> > filter (\ x -> x < 5) [1..6]
04:35:00 <lambdabot>  [1,2,3,4]
04:35:03 <tsp> there we og
04:35:05 <earthy> > filter (< 5) [1..6]
04:35:06 <tsp> s/og$/go
04:35:06 <lambdabot>  [1,2,3,4]
04:35:15 <tsp> what did I miss in mine?
04:35:22 <earthy> [1,,6] != [1..6]
04:35:29 <vincenz> @hoogle (!!!)
04:35:30 <lambdabot> Did you mean: (!!!)
04:35:31 <lambdabot> Prelude.undefined :: a
04:35:31 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
04:35:31 <vincenz> earthy: /=
04:35:38 <earthy> yeah
04:35:52 * earthy is still c-stumped
04:35:59 <tsp> can haskell do utf-8?
04:36:03 <earthy> where it comes to /=
04:36:06 <tsp> earthy: heh, same here - recursive functions are the shits
04:36:39 <earthy> oh, recursion I grok, higherorderness as well. the *stupidity* of /= where all the rest of the world uses !=...
04:37:08 <ski> Prolog uses '\='
04:37:16 <earthy> makes it hard to adapt at least. ;)
04:37:16 <sieni> earthy: if you are annoyed by /=, then look what standard ml has instead of && and || :-)
04:37:28 <earthy> sieni: I don't like standard ml's syntax *at* *ALL*
04:37:32 <ski> (some ?) Basic(s) uses '<>' .. hm, maybe Pascal and Ada, too ?
04:37:35 <mux> Modula-3 uses # for != :-)
04:37:45 <vincenz> people people
04:37:47 <vincenz> people
04:37:52 <vincenz> syntax = pointless
04:38:09 <mux> and you can still do (!=) = (/=) if you want I guess
04:38:29 <earthy> otoh, algol 68 had :/=:
04:38:35 <earthy> but that was for conformity checking
04:38:36 * vincenz propos
04:38:38 <vincenz> notEqual
04:38:48 <mux> ne? :)
04:38:53 <vincenz> or
04:38:58 <vincenz> slashEqual
04:39:08 <mux> eq = (==) and ne = (/=)
04:39:15 <ski> BNE
04:39:21 <vincenz> ne `eq` (/=)
04:39:29 <mux> heh
04:39:37 <vincenz> eq `ne` (/=)
04:39:43 <vincenz> notice how (/=) is ubiquitous
04:39:49 <quicksilver> > let (!=) = (/=) in 1 != 2
04:39:51 <lambdabot>  True
04:40:17 <quicksilver> still, I don't find /= hard; it looks like a real =/= sign to me
04:40:43 <mux> yeah, I never had a problem with /= even though it is the first language I use that has this convention
04:42:32 <tcr> earthy: Lisp and Fortran use /=, too. So judging by true traditionalism, Haskell actually got it right.
04:43:21 <tsp> mux: you code in modula-3? never herad that one in a while
04:43:41 <quicksilver> I didn't know lisp even had a symbolic form
04:43:47 <quicksilver> I thought it was all eqp and neqp and suchlike
04:43:59 <quicksilver> mapq lambdaq mapcarq eqqqq!
04:44:01 * earthy nods
04:44:04 <tcr> quicksilver: = and =/ are numeric  comparasion operators.
04:44:07 <earthy> it's just that it's hard for me. :)
04:44:10 <quicksilver> tcr: *nod*
04:44:14 <earthy> and I like Haskell to be easy. :)
04:44:21 <quicksilver> tcr: my only experience of lisp is elisp, which is broken :)
04:44:22 <mux> tsp: no, but I've been porting some Modula-3 code to C in the past
04:44:42 <quicksilver> tcr: well, I used XLISP for a while but that was some 16 years ago and I don't remember much about it
04:44:44 <tcr> quicksilver: Not in that regard, though.
04:44:59 <earthy> fortunately the compiler tends to help me out there
04:46:58 <tcr> quicksilver: And Elisp is not broken, it's merely traditionally wrong. ;^)
04:47:43 <pejo> mux, cvsup?
04:48:14 <quicksilver> tcr: I found it surprisingly lacking in combinators
04:48:21 <quicksilver> tcr: it doesn't even have 'filter', IIRC?
04:48:53 <tsp> elisp is a piece of crap
04:48:56 <tsp> so is emacs
04:49:10 <tsp> but that's just because I live and die by the command line
04:49:26 <mux> pejo: yes
04:50:42 <tcr> quicksilver: Emacs is nowadays bundled with quite a complete implementation of CL in Elisp. So it got CL's remove-if-not (filter), and reduce (both foldr and foldl) etc
04:51:38 <quicksilver> tcr: yes, but no one seems to use it
04:51:54 <quicksilver> tcr: I wasn't sure if it was considered 'unidiomatic' or something
04:52:05 <quicksilver> tsp: I live and die by the commandline too, and consider emacs to be a powerful tool
04:52:24 <quicksilver> tsp: if you were to tell me 'it doesn't work well with a screenreader', though, I'd consider that a valid argument :)
04:53:01 <tcr> What is a screen reader?
04:53:35 <tsp> tcr: screen reader helps blind people read a screen :)
04:53:53 <tsp> well, a virtual screen - my monitor is in a closet somewhere
04:53:53 <tcr> Then take a look at Emacsspeak.
04:53:58 <tsp> lol emacspeak is crap
04:54:03 <tsp> I tried it, but don't likei t much
04:54:09 <tsp> its too cursor keys oriented
04:54:21 <tsp> I can get far faster results by typing s/x/y than I can by finding the x with th earrows
04:55:33 <quicksilver> hmm
04:55:46 <quicksilver> well I can't speak for emacspeak, but emacs really isn't like that
04:55:52 <quicksilver> you can do s/x/y in emacs, too
04:56:12 <quicksilver> I would most commonly just do control-S x (search for x) then just edit it in place
04:56:25 * mux :%s/foo/bar/cg
04:56:30 <quicksilver> but for more than one replacement, use control-%, which is replace
04:56:33 <earthy> 'th earrows' is an interesting typo to make in this context.
04:56:43 <tsp> earthy: how so
04:56:48 <flux-> quicksilver, you mean meta-% ;-)
04:56:53 <quicksilver> mux: right. But to be honest, there isn't much difference between emacs and vi there, is there?
04:56:56 <earthy> ear-rows :)
04:57:01 <flux-> (but it's in the backbone, who remembers those)
04:57:02 <tsp> oh
04:57:02 <tsp> heh
04:57:11 <tsp> at least in irssi, it'll read my text when I hit enter
04:57:12 <mux> quicksilver: I can't really tell, I think features-wise they are about the same, and it's a matter of feeling
04:57:19 <quicksilver> mux: meta-instead of :, <RET> instead of the /s
04:57:29 <quicksilver> mux: one fewer keypressed, very similar otherwise
04:57:30 <tsp> but then I hear a typo, and automatically do s/x/y but without the final /, since that causes ed to print the new line
04:57:40 <mux> quicksilver: I for one likes the way you type commands in vi* better than in emacs, but that's 100% subjective
04:57:50 <tsp> mux: you might like ed
04:57:53 <mux> I don't much like the ctrl alt shift etc dance
04:57:56 <mux> I know ed
04:57:58 <mux> I use it
04:58:00 <quicksilver> mux: emacs *used* to be absolutely streets ahead of vi in features
04:58:11 <earthy> then vim came along
04:58:11 <mux> quicksilver: yeah, like for M-x doctor? :D
04:58:13 <quicksilver> mux: but that's not true in the post-vim world
04:58:15 * mux chuckles
04:58:22 <quicksilver> mux: no, before vim, vi-clones were really weak
04:58:32 <quicksilver> mux: and people still loved, them, even then :)
04:58:51 <earthy> emacs has the *huge* advantage that people have been working on them a looong long time
04:58:57 <mux> yeah, because all in all, you often just use a very small subset of the available features in everyday's hacking
04:59:02 <earthy> vim also has that advantage
04:59:05 <earthy> most vi clones don't
04:59:15 <earthy> and vi itself was closed software
04:59:16 <quicksilver> mux: but sometimes you may be missing out on something which can really make your life easier
04:59:29 <mux> quicksilver: yes.  I think this time is over now though
04:59:31 <tsp> quicksilver: emacspeak also shelters you from emacs
04:59:32 <quicksilver> mux: I still learn new emacs commands quite often which make me more productive
04:59:42 <quicksilver> tsp: right, so it's probably not great
04:59:43 <mux> yeah, same here with vim :-)
04:59:47 * earthy has been using vim for 10 years and still has that ;)
04:59:50 <EvilTerran> I suspect I'm too dependent on visual-mode in vim...
04:59:58 <earthy> over 10 years actually
04:59:58 <mux> there are a few really really good keys to know in vim
05:00:01 <quicksilver> tsp: maybe it's written by people who don't use emacs very well
05:00:01 <mux> % is one
05:00:07 <quicksilver> tsp: and is therefore not very good :)
05:00:18 <tsp> ekzemple, in previous versions, if you typed m-x, it woudl say "command" - and it still doesn't do everything I like. Also, it totally ignores c-h - I didn't even know a menu pops up
05:00:21 <quicksilver> tsp: or, is a bad advertisement for the editor, at least
05:00:23 <mux> * is another
05:00:29 * mux hearts * and %
05:00:37 <tsp> quicksilver: I admit that a lot of people love it :)
05:00:38 <EvilTerran> but it's so nice to be able to see exactly what a motion's picked up before running a command on it
05:00:39 <gour> what about haskell-mode in vim vs. emacs?
05:00:47 <mux> * does a word search (\<foo\>) on the word your cursor is on
05:00:56 <quicksilver> earthy: I've been using emacs for 14 years, I think, and still learning :)
05:00:58 <mux> and % moves your cursor to the matching parens/bracket
05:01:06 <EvilTerran> mux, wow, neat. i'll remember * -- i didn't know about that.
05:01:14 <quicksilver> gour: I think the emacs one has a more powerful indentation engine. Not sure, since I've never used the vim one
05:01:18 <mux> those single-key commands are so neat
05:01:19 <tsp> quicksilver: problem with emacs - if you lose your .emacs, its all over
05:01:38 <tsp> I never could get used to the fact that the most used command was c-x o
05:01:47 <quicksilver> tsp: problem with email - if you lose your mailbox, it's all over
05:01:52 <quicksilver> tsp: <hint> backups :)
05:02:05 <tsp> quicksilver: heh, I lost all my bookmarks when I did w ~/ad instead of w+ ~/ad in edbrowse
05:02:08 <ivanm> What's C-x o do? I never remember using it in emacs...
05:02:13 <gour> quicksilver: i've heard the same. however being vim user, it would be nice to improve it. yi is probably not there (yet)
05:02:15 <quicksilver> ivanm: other 'window'
05:02:17 <ivanm> s/never/don't
05:02:21 <EvilTerran> quicksilver, you can use ex commands in indentation scripts in vim
05:02:22 <ivanm> ahhh...
05:02:24 <mux> there is one cool commonality between emacs and vim
05:02:28 <tsp> ivanm: you can just see the other window - I had to switch to it
05:02:30 <ivanm> as in creating a new one, or changing to it?
05:02:32 <EvilTerran> so vim's system's turing complete :D
05:02:42 <quicksilver> EvilTerran: the hard part is the source code analysis to find the correct indentations (plural) in the first place
05:02:46 <mux> the first time someone runs either of the editors, their first question is: "how the hell do I quit?"
05:02:51 <tsp> mux: heh
05:02:53 <tsp> same with ed
05:02:59 <tsp> but its worse - all you get is ?
05:03:02 <mux> ,p
05:03:03 <mux> :D
05:03:08 <quicksilver> mux: emacs now (and for some versions) tells you how to quit on the welcome page that loads :)
05:03:20 <nornagon_> if you press ^C, vim tells you how to quit
05:03:21 <mux> g/^foo/d
05:03:28 <nornagon_> also on the welcome message
05:03:29 <EvilTerran> vim tells you to do :help on the startpage
05:03:31 <mux> I'm not sure my ed is still correct :-)
05:03:32 <mux> but that should be
05:03:42 <EvilTerran> and the first page of :help explains how to quit, iirc
05:03:45 <mux> HELP POOR CHILDREN IN UGANDA
05:03:46 <mux> sorry
05:03:51 <mux> nervous outbreak
05:03:53 <earthy> ~                type  :q<Enter>               to exit
05:03:53 <nornagon_> heh
05:04:00 <EvilTerran> mux, yes, quite. what's that about?
05:04:08 <EvilTerran> odd place to put a nagscreen...
05:04:11 <tsp> yeah
05:04:13 <tsp> if you type vim without a file
05:04:16 <tsp> it prints the nag
05:04:26 <mux> dunno, I think Bram is sentimental about Uganda's childrens or something
05:04:27 <tsp> unless you have set nointro in your .vimrc - I only use vim for wordwrapping emails though
05:04:29 <EvilTerran> so generally only new vimmers see the nagscreen
05:04:43 <tsp> speaking of which, I need to add set bs=2
05:04:43 <earthy> Bram was a volunteer in the ICCF childhome in Uganda
05:04:47 * EvilTerran generally uses ZZ to quit vim
05:04:59 * mux is more of a :wq guy
05:05:01 <EvilTerran> (does the same as :wq)
05:05:02 * earthy generally uses :x
05:05:08 <mux> habits
05:05:13 <tsp> :wq
05:05:20 <tsp> or I end up typing . in insert mode
05:05:23 <tsp> then ahve to get rid of it
05:05:37 <earthy> anywho, time to go perform
05:05:59 <tsp> earthy: perform what?
05:06:06 <nornagon_> :wq here
05:06:14 <mux> now that I write Haskell code, I tend to use different commands than when I was doing C hacking with vim :-)
05:06:39 <mux> with C I heavily rely on auto-indenting customized to my needs
05:06:46 <mux> and with Haskell, I have a lot of code space-aligned by hand
05:06:50 <mux> so I use the R command often
05:06:56 <mux> to edit stuff without breaking the layout :-)
05:07:08 <quicksilver> I manage to get away without hand aligning 99.9% of the time
05:07:14 <quicksilver> so the emacs mode is pretty close to good enough
05:07:17 <matthew-_> mmmm. emacs and <tab> works fine for me
05:07:47 <quicksilver> I don't like the way it does nested ifs, though
05:07:48 <quicksilver> :)
05:07:51 <mux> I'm following the advices I read on not using tabs
05:07:52 <tsp> yahoogroups needs to die
05:07:54 <quicksilver> but then again, I try to avoid nested ifs
05:08:00 <quicksilver> mux: <tab> doesn't use tabs, though
05:08:08 <EvilTerran> I don't generally use R that much... i tend to do c{motion} instead
05:08:09 <quicksilver> mux: <tab> is just the key you type to say 'indent this line correctly'
05:08:13 <tsp> how can you misconfigure an email system so bad that it puts out 5 emails per 1 you send out?
05:08:14 <mux> it depends on how your editor is configured
05:08:24 <Cale> I use tab to mean 4 spaces.
05:08:25 <quicksilver> mux: I assumed you were responding to matthew-_ :)
05:08:27 <vincenz> woo
05:08:29 <tsp> at least their list server sends me back 5 copies for each one I send out
05:08:32 <mux> oh
05:08:40 <EvilTerran> tsp, one's your recipt :P
05:08:41 <mux> :set sw=2
05:08:45 <Cale> and then adjust the indentation from wherever I tab to.
05:08:46 <mux> ex:sw=2
05:09:12 <mux> then I use the > command
05:09:17 <quicksilver> a simple algorithm for an editor that can layout haskell is simply to indent each line exactly as was the last
05:09:24 <quicksilver> that's sufficient, and better than nothing
05:09:31 <quicksilver> getting it *right* is hard, though :)
05:09:59 <EvilTerran> vim:set sw=4 sts=4 autoindent
05:10:54 * mux also uses vi keybindings with his shell
05:11:54 <quicksilver> I would like to have a bit of refactoring
05:12:36 <quicksilver> for all the arguments that java needs refactoring only because its crap [*]
05:12:46 <quicksilver> (* I shortened that argument a bit for brevity)
05:13:02 <quicksilver> I'd like stuff like 'convert top-level-if to guards'
05:13:13 <quicksilver> 'float let-bound to top level'
05:13:21 <quicksilver> (well, up-one-level possibly)
05:13:36 <dcoutts> @seen dons
05:13:36 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 3h 49m 34s ago.
05:14:44 <tsp> mux: how the hell do you use vi keybindings with shell?
05:14:50 <tsp> do you have to go into insert mdoe every time you hit enter?
05:15:03 * cpoucet looks at his new nick
05:15:06 <mux> tsp: no :)
05:15:11 <mux> you are in insert mode by defult
05:15:39 <mux> but if you hit esc you are in vi mode then
05:15:56 <EvilTerran> or ^O?
05:16:04 <EvilTerran> ^o?
05:16:08 <EvilTerran> (whatever)
05:16:11 <mux> doesn't seem to work here
05:16:14 <quicksilver> I never really understood the business about vi as a modal editor and emacs supposedly not
05:16:18 <mux> tsp: oh, and you do that with set -o vi
05:16:22 <quicksilver> emacs is a modal editor too
05:16:26 <quicksilver> just different modes :)
05:16:40 <quicksilver> even MS Word is a modal editor, or it was in version 4
05:16:46 <quicksilver> it's just most people didn't use command-mode
05:16:48 <EvilTerran> ^o in insert mode -- does one vi command, then returns to insert mode
05:17:04 <mux> doesn't work with the shell, at least here with zsh
05:17:26 <norpan> vi mode in the shell rocks
05:17:31 * mux nods
05:17:43 <norpan> people have the wrong impression about vim
05:17:52 <norpan> they think that insert mode is somehow the "normal" mode
05:18:05 <norpan> but the reality is that you are not that often in insert mode when editing
05:18:14 <nominolo> @instances Binary
05:18:15 <lambdabot> Couldn't find class `Binary'. Try @instances-importing
05:18:33 <nominolo> @src Data.Binary
05:18:33 <lambdabot> Source not found. Wrong!  You cheating scum!
05:18:42 <nominolo> me no scum
05:18:42 <quicksilver> nominolo: you can't "src" an entire module (thank god)
05:18:48 <tsp> quicksilver: heh
05:18:54 <quicksilver> nominolo: but I don't think lb has Data.Binary
05:18:56 <tsp> @src map
05:18:56 <lambdabot> map _ []     = []
05:18:57 <lambdabot> map f (x:xs) = f x : map f xs
05:18:57 <mux> 298292 @more lines
05:19:10 <tsp> wait, map is a function in the lib, and not a builtin haskell feature?
05:19:17 <nominolo> quicksilver: it could give a link
05:19:23 <mux> tsp: in haskell, very few things are builtin :-)
05:19:33 <mux> even exceptions are implemented as a library (monad)
05:19:39 <tsp> ouch the gonads
05:19:41 <tsp> monads
05:19:45 <mux> which really impressed me
05:19:48 <tsp> I should fix irssi so it replaces gonads with monads
05:19:56 <tsp> :src filter
05:19:59 <mux> I guess imprecise exceptions are builtin though
05:20:02 <tsp> @src filter
05:20:02 <lambdabot> filter _ []     = []
05:20:02 <lambdabot> filter p (x:xs)
05:20:02 <lambdabot>     | p x       = x : filter p xs
05:20:02 <lambdabot>     | otherwise = filter p xs
05:20:05 * cpoucet wishes haskell had growable arrays :/
05:20:34 <nominolo> tsp: monads are not scary.  after all, you could have invented them yourself (hint! hint!)
05:20:36 <tsp> I'm guessing that tail is
05:20:40 <tsp> tail (x:xs) = xs
05:20:43 <tsp> @src tail
05:20:43 <lambdabot> tail (_:xs) = xs
05:20:43 <lambdabot> tail []     = undefined
05:20:48 <tsp> close
05:21:08 <EvilTerran> if could've been defined as a function, too
05:21:10 <mux> tail (_:xs) = xs
05:21:16 <nominolo> tsp: not even : is
05:21:32 <tsp> @src :
05:21:32 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:21:41 <mux> @src (:)
05:21:42 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
05:21:49 <nominolo> tsp: it's a constructor
05:21:49 <tsp> @src !!
05:21:50 <lambdabot> xs     !! n | n < 0 = undefined
05:21:50 <lambdabot> []     !! _         = undefined
05:21:50 <lambdabot> (x:_)  !! 0         = x
05:21:50 <lambdabot> (_:xs) !! n         = xs !! (n-1)
05:21:52 <EvilTerran> if' True = const; if' False = flip const -- :P
05:21:57 <nominolo> @src []
05:21:57 <lambdabot> data [] a = [] | a : [a]
05:22:56 <tsp> @src http://silenceisdefeat.org/~tspivey/mypic.png
05:22:57 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:23:05 <nominolo> tsp: it might be treated specially by the compiler, though.  but only for efficiency
05:23:08 <tsp> lol, thats a picture of me that a friend made up
05:23:12 <quicksilver> @where Data.Binary
05:23:12 <lambdabot> I know nothing about data.binary.
05:23:13 <tsp> from the output of a webcam
05:23:15 <quicksilver> @where Binary
05:23:16 <lambdabot> http://darcs.haskell.org/binary
05:23:18 <mux> @src cond
05:23:18 <lambdabot> Source not found. My pet ferret can type better than you!
05:23:32 <mux> @let cond b x y = if b then x else y
05:23:33 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
05:23:38 <mux> funny that
05:23:50 <tsp> mux: what, does my pic not work?
05:23:54 <tsp> mux: ah, the irc error
05:24:24 <quicksilver> mux: exceptions are built in
05:24:48 <mux> quicksilver: imprecise ones? but the monadic ones are just a library, aren't they?
05:24:55 <quicksilver> mux: 'pure' haskell has no way of telling apart one kind of _|_ frmo another
05:25:11 <quicksilver> mux: so you need a primitive to implement catch
05:25:43 <quicksilver> mux: the 'clever bit' is deciding that it's sufficient to use _|_ (which a lazy language has anyway) to implement exceptions
05:25:53 <quicksilver> mux: meaning you don't need to add stuff to your core semantic model
05:26:03 <quicksilver> mux: you still need to add a language support to catch and throw them
05:26:33 <mux> I'm so disappointed now
05:26:35 <quicksilver> mux: as for library, well: You can argue that use of 'Either' amounts to a pure haskell exception library
05:26:44 <tsp> > let n = map in n + [1..3]
05:26:45 <lambdabot>  Couldn't match expected type `(a -> b) -> [a] -> [b]'
05:26:46 <quicksilver> mux: but it doesn't encode them as _|_
05:26:52 <tsp> ? that should ahve aliased
05:26:59 <quicksilver> mux: it encodes them as Left "error"
05:27:04 <rahikkala> > let n = map in n (+) [1..3]
05:27:04 <quicksilver> tsp: it did
05:27:05 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
05:27:12 <mux> quicksilver: right
05:27:31 * rahikkala nods
05:28:19 <quicksilver> mux: Control.Exception is 'mostly' pure haskell, but it uses underlying language support
05:28:27 <quicksilver> @src throwIO
05:28:28 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:28:35 <DRMacIver> Hm.
05:28:37 <DRMacIver> @src fix
05:28:37 <lambdabot> fix f = let x = f x in x
05:28:53 <tsp> wtf is fix
05:29:01 <tsp> @where fix
05:29:01 <lambdabot> I know nothing about fix.
05:29:05 <tsp> @doc fix
05:29:05 <lambdabot> fix not available
05:29:07 <EvilTerran> fix f = f (f (f (f (f...
05:29:14 <tsp> what good is it
05:29:17 <rahikkala> I prefer to define it as fix f = f (fix f)
05:29:19 <mux> fix is for when you thought yo uwere understanding haskell :-)
05:29:24 <mux> heh
05:29:24 <quicksilver> tsp: it's not necessary
05:29:33 <EvilTerran> it's the Y-combinator (?)
05:29:35 <quicksilver> tsp: it has (exactly) the same expressiveness as recursive definitions
05:29:36 <EvilTerran> it's maths. :P
05:29:38 <tsp> @src fix
05:29:38 <lambdabot> fix f = let x = f x in x
05:29:47 <tsp> ?
05:29:50 <quicksilver> tsp: but it's a way of exposing the 'essence' of recursion into the language
05:29:50 <rahikkala> It's good for writing oneliners and scaring newbies
05:30:00 <EvilTerran> > let fix f = f (fix f) in fix (1:)
05:30:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:30:07 <quicksilver> tsp: compare these two possibilities:
05:30:14 <quicksilver> > let x = 1 : x in x
05:30:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:30:17 <quicksilver> > fix (1:)
05:30:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:30:28 <tsp> all it prints are 1's
05:30:32 <quicksilver> tsp: indeed
05:30:36 <quicksilver> tsp: two ways to write it, though
05:30:42 <tsp> I assume its not used often
05:30:52 <quicksilver> explicitly? not often, by most people
05:30:52 <rahikkala> > take 10 (fix (\c -> 0 : 1 : zipWith (+) c (tail c)))
05:30:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
05:30:57 <quicksilver> some people love it, though
05:31:01 <tsp> goddamn fibonacci numbers
05:31:03 <mux> > fix (\x f -> if x == 0 then 1 else x * (f (x - 1))) $ 4
05:31:04 <lambdabot>      Occurs check: cannot construct the infinite type:
05:31:04 <lambdabot>       t = (t -> t1) ->...
05:31:06 <mux> dang
05:31:11 <tsp> I swear if i find th eperson who made them I'll put their head on a pike
05:31:12 <EvilTerran> we've had sessions in here where we try to come up with the most obscure ways to making infinite lists of ones...
05:31:15 <quicksilver> personally I use recursive definitions in preference to fix
05:31:49 <tsp> the fibonacci series - its not used for anything practical, just like dividing and multiplying polynomials isn't used for anything but highschool math
05:31:50 <ski> > let loeb' fs = fix (\as -> zipWith ($) fs (scanl (flip (:)) [] as)); (f <+> g) n = g n + g n in take 20 $ loeb' $ [const 0,const 1] ++ repeat ((!! 0) <+> (!! 1))   -- :D
05:31:52 <lambdabot>  [0,1,0,2,0,4,0,8,0,16,0,32,0,64,0,128,0,256,0,512]
05:32:11 <mux> > fix (\f -> \x -> if x == 0 then 1 else x * f (x - 1)) $ 4
05:32:12 <ski> oops
05:32:13 <lambdabot>  24
05:32:14 <mux> haha!
05:32:16 * mux > fix
05:32:17 <EvilTerran> ski, ZOMG
05:32:18 <ski> > let loeb' fs = fix (\as -> zipWith ($) fs (scanl (flip (:)) [] as)); (f <+> g) n = f n + g n in take 20 $ loeb' $ [const 0,const 1] ++ repeat ((!! 0) <+> (!! 1))   -- :D
05:32:19 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
05:32:39 <ski> (that's what you get for last-second rewrites ..)
05:32:46 <mux> > fix (\f -> \x -> if x == 0 then 1 else x * f (x - 1)) $ 5
05:32:47 <lambdabot>  120
05:32:52 <tsp> ski: the last second rewwrite was cool though
05:33:04 <tsp> ski: it printed 1,0,2,0,4,0... is that the easiest way to do that?
05:34:07 <EvilTerran> > concat [[2^i, 0] | i <- [0..]]
05:34:08 <quicksilver> tsp: certainly not the easiest, no :)
05:34:08 <ski> > do x <- [0..]; return 0 `mplus` return (2^x)
05:34:08 <lambdabot>  [1,0,2,0,4,0,8,0,16,0,32,0,64,0,128,0,256,0,512,0,1024,0,2048,0,4096,0,8192,...
05:34:10 <lambdabot>  [0,1,0,2,0,4,0,8,0,16,0,32,0,64,0,128,0,256,0,512,0,1024,0,2048,0,4096,0,819...
05:34:32 <mux> god damn it, Haskell is going to get me fired
05:34:36 <tsp> mux: how so
05:34:46 <mux> I just can't work on what I have to do, I *need* to work on Haskell code
05:34:50 <mux> :-)
05:35:16 <ndm> Igloo: are you going to push them to the main filepath repo after?
05:35:29 <Igloo> ndm: Yup
05:35:40 <ndm> cool :)
05:35:43 <EvilTerran> > intersperse 0 (map (2^) [0..])
05:35:44 <lambdabot>  [1,0,2,0,4,0,8,0,16,0,32,0,64,0,128,0,256,0,512,0,1024,0,2048,0,4096,0,8192,...
05:35:45 <tsp> mux: what do you code in, norme?
05:35:46 <tsp> normally
05:35:51 <Saizan> do you think is possible to make a pseudorandom number generator for a range 0..n with the guarantee that it won't give the same number twice before n/2 calls? (without explicit filtering)
05:35:51 * ndm crashes FiniteMap using Catch, yay!
05:36:02 <EvilTerran> ^ that's probably my preferred way of doing it
05:36:09 <ndm> Saizan: [0..n] would work
05:36:13 <tsp> > @src intersperce
05:36:13 <lambdabot>  Parse error
05:36:17 <tsp> @src intersperse
05:36:18 <lambdabot> intersperse _   []     = []
05:36:18 <lambdabot> intersperse _   [x]    = [x]
05:36:18 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
05:36:20 <mux> tsp: oh, these days I'm writing a bunch of administrative perl scripts...
05:36:23 <ski> tsp : he's dead long since
05:36:32 <tsp> ski: damn so I can't put his head on a pike
05:36:38 <tsp> maybe on a python
05:36:42 <tsp> since pike is weird
05:36:48 <Saizan> ndm: a little too much pseudo
05:37:12 <Syzygy-> Algebraic topology for concurrency modeling. Squeeeee!
05:37:47 <ski> Syzygy- : where, where ?
05:38:15 <Syzygy-> ski: In the seminarroom at the Humboldt-Uni Berlin where I'm sitting right now
05:38:16 <quicksilver> Saizan: that's a nonrandom generator :P
05:40:34 <Syzygy-> > let nonrandom = 4 in nonrandom
05:40:35 <lambdabot>  4
05:40:55 <quicksilver> Saizan: you could consider using a random shuffle
05:41:13 <rahikkala> but http://xkcd.com/c221.html
05:41:14 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
05:41:21 <quicksilver> Saizan: partiotion the number (randomly) into two partitions
05:41:26 <quicksilver> Saizan: shuffle each, alternately
05:41:27 <Syzygy-> Cubical complexes with building blocks representing processes/processor distributions
05:42:01 <EvilTerran> i guess theoretically it should be possible to create a generalised-fibbonacci generator with no cycles <n/2
05:42:05 <EvilTerran> wouldn't be easy, tho
05:43:25 <quicksilver> EvilTerran: no cycles doesn't equal no repition, surely
05:43:36 <EvilTerran> er... yes, true.
05:43:36 <quicksilver> EvilTerran: there is state hidden beyond what is exposed
05:43:46 <quicksilver> EvilTerran: otherwise there is a guaranteed cycle of length n :)
05:44:33 <EvilTerran> i think you'd have to maintain O(n) items of state to fit the requirements...
05:44:40 <EvilTerran> in any simple way, anyway
05:44:53 <EvilTerran> if you wanted to maintain some approximate semblance of white noise
05:48:39 <EvilTerran> huh. i'm sur ethat happened yesterday, too
05:53:09 <quicksilver> EvilTerran: yes, you would, or use an algorithm with an obvious pattern
05:53:17 <quicksilver> EvilTerran: like my split-into-2 and shuffle pattern
05:53:47 <EvilTerran> yeah, i was thinking the other alternative would be writing a single-variable-state algo that was easy to analyse
05:54:08 <EvilTerran> or something similar to that. that method'd be sorely lacking in entropy, tho
05:59:52 <mux> hey, I've wanted to ask that several times
06:00:12 <mux> is it true that GADTs can be "emulated" with only ADTs and smart constructors?
06:00:22 <mux> or would I lose something?
06:05:07 <ndm> Stephen Adams: Efficient Sets - A Balancing Act. 553-561
06:05:14 <ndm> anyone know where i could get that paper from?
06:05:33 <ndm> we have a subscription to JFP, but its the one we haven't got (grr!)
06:05:39 <ndm> Volume 3, Number 4, October 1993
06:05:50 <ndm> i can literallly find all the issues before and after it
06:06:32 <Saizan> http://swiss.csail.mit.edu/~adams/BB/ <-- this?
06:06:33 <lambdabot> Title: Weight balanced binary trees
06:07:39 <quicksilver> ndm: the author appears to be violating convention and respecting the journal's copyright (shame!) but saizan's link is an expanded version
06:07:48 <ndm> Saizan: cheers, i'd still like a copy of the JFP one
06:07:52 <quicksilver> ndm: there's always "ask around your faculty" and "email the author" :)
06:08:07 <ndm> i want to see if he's got an error in his work, so have to be very careful on citations
06:08:21 <ndm> quicksilver: if its in our department, it would be behind my desk, its not :(
06:08:33 <mux> that question must be utterly stupid, since it's the second or third time I'm asking it and I get no answers :-) please tell me if I'm being dumb
06:09:03 <quicksilver> mux: I'm too stupid to understand GADTs so I can't answer your question
06:09:49 <Igloo> I think you need existentials, but IANAO
06:10:06 <mux> IANAO?
06:10:13 <Igloo> I Am Not An Oleg
06:10:20 <mux> hah
06:10:29 <quicksilver> Igloo: but h98 + typeclasses has existentials, doesn't it?
06:10:33 <quicksilver> Igloo: they're just hidden a bit
06:10:47 <mux> I guess this is haskell-cafe material
06:10:58 <Igloo> quicksilver: I'm still not an Oleg  :-)
06:11:04 <quicksilver> Igloo: :)
06:11:05 <Igloo> But typeclasses are part of H98
06:11:09 <mux> but I'd better check that this RT is working ok or the boss is going to have my head on a pike if we lose customer mails
06:11:14 <quicksilver> Igloo: indeed, that was for emphasis :)
06:12:15 <tsp> hmm, anyone good at poetry?
06:12:21 <tsp> can song lyrics be put in this form?
06:12:28 <tsp> Jag ser en syn s underbar/Svastika fanan p standal/Jag ser ett ariskt folk s fritt
06:12:31 <tsp> Ett rike byggt p sund moral/Med rasmedvetna ideal/Dr svart r svart och vitt r vitt
06:12:37 <tsp> damn, what's up with all the ?'s
06:12:40 <ClaudiusMaximus> what would you call the design pattern of returning functions with state embedded?  like mkObject = do {state<-newIORef state; return Object{foo = objFoo state; bar = objBar state} }
06:13:03 <tsp> did those chars come up as ?'s for anyone else?
06:13:10 <matthew-_> tsp: ? here.
06:13:13 <quicksilver> tsp: no, the swedish chars were fine for me
06:13:18 <quicksilver> tsp: but I can't read swedish :)
06:13:19 <rahikkala> tsp: Your IRC client or terminal sucks - it worked for me - and so does your ideology ;)
06:13:22 <tsp> quicksilver: at least I think that was swedish
06:13:27 <kpreid> tsp: fine, but you're sending iso-8859-1, not utf-8
06:13:28 <ClaudiusMaximus> tsp: yes  (i have charset set to UTF-8)
06:13:30 <quicksilver> I know it was swedish :)
06:13:44 <quicksilver> I know enough swedish to recognise it
06:13:52 <tsp> kpreid: how can you tell the difference between 8859-1 and utf-8?
06:14:02 <tsp> quicksilver: lol, better than me - I don't know a word of swedish
06:14:07 <tsp> I just know that song sounds good
06:14:13 <kpreid> tsp: because my client tries utf-8, and if that fails, uses 8859-1, which can't fail, and tells me so
06:14:19 <rahikkala> tsp: You see, I don't recognise that song and even my Haskell is better than my Swedish, but... that seems to be a Nazi supremacist song :)
06:14:23 <quicksilver> tsp: 'Jag' is swedish for 'I'; AFAIK it's the only language which uses that work :)
06:14:36 <tsp> rahikkala: heh, i think its an anti-nazi song
06:14:37 <rahikkala> tsp: (that is, I don't know what song it is, but I can understand what it's about)
06:14:48 * rahikkala shrugs
06:14:58 <Syzygy-> It turned out that the guy was using homotopy theory to analyze critical concurrency systems in france....
06:15:00 <rahikkala> I can recognise words but not enough meaning to detect sarcasm, so...
06:15:05 <tsp> kpreid: lol, so every time you get a message in 8859-1 it says so
06:15:08 <mux> iso-8859-1 is dead, long live iso-8859-15
06:15:13 <quicksilver> ClaudiusMaximus: I wouldn't really call it anything
06:15:19 <Syzygy-> tsp: Just WHERE did you get hold of that text?
06:15:21 <quicksilver> ClaudiusMaximus: you're just returning something in the IO monad
06:15:25 <mux> all your euro symbols are belong to us
06:15:29 <Syzygy-> It's the worst kind of neonazi lyrics...
06:15:31 <quicksilver> ClaudiusMaximus: stuff in IO has state, whether it's explicit or implicit :)
06:15:33 <tsp> Syzygy-: its song lyrics to this song I really like
06:15:44 <Syzygy-> Who sings it?
06:15:53 <pejo> tsp, it's about an aryan race, "where black is black and white is white". Not very poetic imho.
06:16:00 * mux ponders using  as an Haskell operator
06:16:14 <tsp> here's the url
06:16:15 <tsp> http://www.lyricsondemand.com/p/plutonsvealyrics/stveltramplyrics.html
06:16:17 <mux> it slightly resembles 'included in'
06:16:18 <lambdabot> Title: Pluton Svea - Stveltramp Lyrics - Stveltramp - Lyrics On Demand, http://tinyurl.com/yptqe5
06:17:06 <tsp> pejo: ouch
06:17:20 <Syzygy-> "I see a view so wonderful / the swastika banner on a standart / I see an arian people so free / A "reich" built on sound morals / With racially conscious ideals / Where black is black and white is white "
06:17:24 <quicksilver> mux: that came across to me as a universal currency symbol
06:17:34 <ClaudiusMaximus> quicksilver: thanks
06:17:37 <tsp> Syzygy-: omg
06:17:39 <quicksilver> mux: which suggests that your 8859-15 is being interpreted as 8859-1 :)
06:17:45 <Syzygy-> Pluton Svea is one of the largest white supremacist bands in sweden
06:17:57 <tsp> Syzygy-: someone told me it was on the top hits charts in sweden
06:18:05 <Syzygy-> Yeah, right.
06:18:16 * Syzygy- doesn't think so.
06:18:17 <mux> quicksilver: you're probably running -1 ? :-)
06:18:53 <quicksilver> mux: not sure. I can't even type a euro symbol in this window
06:18:58 <quicksilver> mux: although I can in others :)
06:19:04 <tsp> Syzygy-: is mjolnir also a white supremecist band? lets see... http://mjolner.letras.terra.com.br/letras/652844/
06:19:06 <lambdabot> Title: H&Auml;MDENS S&Ouml;TMA letra (Mj&ouml;lner) &#9835;
06:19:14 <Syzygy-> tsp Oh yes.
06:19:18 <tsp> lol what kind of a title is that
06:19:29 <quicksilver> mux: hmm, interestingly I can't type a euro symbol in any X11 window. I blame Apple.
06:19:29 <Syzygy-> "The sweetness of revenge"
06:19:57 * tsp runs that through a swedish translating site, if he can find one
06:20:03 <mux> quicksilver: Apple sounds like a good suspect :-)
06:22:40 <quicksilver> mux: Ah no, I retract that. I can type a eurosign into an xemacs window
06:22:45 <quicksilver> mux: I blame xterm, instead
06:22:53 <quicksilver> mux: apple is apparently sending the right keyevent
06:22:59 <tsp> Syzygy-: at least that song doesn't appear to be racist from the translation, unless the song has a deeper meaning from what I can tell
06:23:25 <mux> quicksilver: the application might also be involved
06:23:50 <tsp> lol
06:23:53 <tsp> Historien now is told of men deep in in forest  A statement about gods and banana the betrayal took During times of dreams that siar evil things About Balders destiny and odes' granna ring
06:24:08 <tsp> gods and bananas
06:29:22 <tsp> I somehow don't see those two being able to mix
06:29:58 <ski> ah .. not banana
06:31:21 <Syzygy-> tsp: Ok. That's "just" manhandling old norse mythology. An area that's getting aggressively coopted by the white supremacist movement.
06:31:38 <tsp> hmm
06:31:45 <tsp> maybe this entire archive is racist
06:31:53 <dons> hmm.
06:31:59 <dons> what happened to #haskell?
06:33:06 <ski> "The story will now be told of men deep in a forest. A tale of gods and the path took by deceit, During times without dreams, prophesizing about evil thinfs, About the destiny of Balder and the grand ring of Odin"
06:33:14 <tsp> most of it is weird rock music... Vit Ungdom, Angriff 2004 Forbidden Rage, and some ones that I can't even pronounce like Brsrkarna and Frn Flykt Till kamp
06:33:16 <kpreid> dons: one off-topic question leads to unpleasant discoveries
06:33:18 <Syzygy-> dons: I've been asking that for a while now.
06:33:21 <kpreid> s/leads/led/
06:33:35 <dons> perhaps take the off topic stuff to #haskell-blah then.
06:33:36 <Syzygy-> tsp: "Vit ungdom" will certainly be offensive.
06:34:32 <ski> m, yes, haskell instead ..
06:35:51 <ski> quicksilver : i don't think you can encode existentials in h98
06:36:39 <dons> isn't there a trick to do that?
06:36:44 * dons scratches head.
06:36:51 <dons> ski, put out an oleg challenge ;-)
06:36:56 <ski> thinking of leibniz ?
06:37:20 <tsp> esperanto is way cooler than swedish :) but there's hardly any music in it
06:37:26 <tsp> I only have ~700mb
06:37:30 <dons> tsp. #haskell-blah please.
06:39:22 <quicksilver> ski: I could be wrong, I thought I read it somewhere in an oleg
06:39:41 * ski smiles .. "an oleg" :)
06:39:52 <chessguy> 'morning haskellers
06:40:00 <ivanm> evening
06:40:01 <quicksilver> ski: it was something like data MkT a =
06:40:09 <mux> hello chessguy
06:40:20 <chessguy> anybody seen this site? i just stumbled across it for the first time: http://okmij.org/ftp/Haskell/
06:40:22 <lambdabot> Title: Haskell Programming: Miscellanea
06:40:49 <quicksilver> chessguy: that is 'oleg' :)
06:41:05 <chessguy> ah
06:41:05 <ski> (hm, by a proper encoding, i want the "outer" type to not need a type parameter ..)
06:41:09 <chessguy> well it still seems interesting
06:41:18 <ski> @quote oleg
06:41:19 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
06:41:21 * Saizan was just looking for a shuffling algorithm
06:41:45 <mux> dons: am I understanding GADTs right when I think that I could "emulate" them with bare ADTs and smart constructors?
06:41:53 <chessguy> Saizan, you're welcome :)
06:42:03 <quicksilver> chessguy: it's extremely interesting
06:42:21 <mux> knuth's shuffling is a perfect shuffling, O(n)
06:42:36 <mux> knuth also has a sub-linear shuffling algorithm that is quite good, although obviously not perfect
06:42:36 <gotaku> Anyone know if there is a NEAT implementation in Haskell?
06:42:37 <chessguy> quicksilver, yeah, there's lots of good stuff there
06:42:43 <Saizan> O(n)? how?
06:43:41 <mux> Saizan: you loop through the list of values to shuffle, and pick a random number between n being the index of the current element, to the last index, and shuffle the current element with the one at the random index
06:44:16 <mux> I'm not sure if this is understandable, it's hard to express those things in english
06:44:36 <xs> gotaku, NEAT = ?
06:44:39 <Saizan> the last shuffle is a swap, right?
06:44:58 <gotaku> Neuro-Evolution of Augmenting Topologies
06:45:10 <mux> Saizan: the last shuffle is shuffling the last element with itself
06:45:11 <Syzygy-> Huh?
06:45:13 <mux> so it's a no-op
06:45:14 <chessguy> wow, there's a mouthful
06:45:27 <Syzygy-> What sense of topology is used there?
06:45:46 <Saizan> no, i mean in your sentence
06:45:51 <quicksilver> Saizan: yes, he means swap
06:45:52 <gotaku> The connections of the neural net.
06:45:53 <xs> gotaku, is this for optimising neural network topologies?
06:45:55 <mux> yes, sorry
06:45:58 <mux> I got myself confused
06:46:13 <quicksilver> what is very non-trivial is to prove that that is indeed a perfect shuffle
06:46:14 <gotaku> http://en.wikipedia.org/wiki/NeuroEvolution_of_Augmented_Topologies
06:46:16 <lambdabot> http://tinyurl.com/234y8z
06:46:20 <quicksilver> at least, it didn't look right to me the first time I saw it :)
06:46:23 <mux> quicksilver: Knuth already proved it :-)
06:46:29 <quicksilver> mux: I know he did
06:46:32 <mux> but it's true it's not trivial
06:46:39 <quicksilver> mux: knuth doesn't publish things unless he's proved them :)
06:46:44 <chessguy> Syzygy-, network topology
06:46:56 <Syzygy-> Ah.
06:46:57 <mux> it's funny how often people try to implement Knuth's shuffle, but take a random index always between 1 and the last index
06:46:58 <xs> gotaku, i do not think there is, alas. but many of the parts might get written this summer as part of google SoC
06:47:02 <quicksilver> Hence the famous quotation "Warning, I haven't tested this code, only proven it correct"
06:47:05 <mux> thus, they don't implement a perfect shuffle anymore
06:47:18 <xs> gotaku, (there are several student applications concerning machine learning, i think.)
06:47:20 <ski> mux : 'data E :: * -> * where {C :: a -> E a; L :: (a -> E b) -> E (a -> b); A :: E (a -> b) -> E a -> E b}; eval :: E a -> a; eval = ..obvious..' can you emulate this ?
06:47:47 <mux> someone call 911, my brain imploded
06:48:24 <gotaku> I did Haskell get into the google soc anyway? I thought it was for single projects?
06:48:29 <gotaku> How did.
06:48:49 <mux> single projects? what do you mean?
06:49:17 <gotaku> It's like C being part of the SoC.
06:49:38 <chessguy> there is no 'C' organization
06:49:48 <quicksilver> gotaku: haskell isn't in the SoC
06:49:48 <chessguy> there is a 'haskell.org'
06:49:48 <rahikkala> I think it's specifically Haskell.org as a project, not Haskell in general
06:49:51 <quicksilver> gotaku: haskell.org is :)
06:49:58 <mux> ski: I guess you mean that I'm wrong in thinking that? :-)
06:50:09 <gotaku> Oh ok.
06:50:27 <chessguy> so, what is type unification?
06:50:34 * chessguy asks timidly, afraid of the answer
06:50:34 <ski> mux : i'm not sure .. but i have a hunch you can't emulate it
06:50:40 <gotaku> I'm totally stumped on how to create a neural network in Haskell.
06:50:53 <chessguy> gotaku, it's been done
06:50:59 <chessguy> gotaku, in 30 lines of code :)
06:51:06 <xs> gotaku, do you require NEAT? i have an implementation of hidden layer networks with backprop.
06:51:10 <mux> ski: maybe it's possible to emulate simple GADTs this way, I think I'm going to ask this to haskell-cafe@
06:51:16 <ski> chessguy : it's just like any term unification
06:51:18 <rahikkala> Also, at this rate we need a @quote about 5.1 to go with the one about stereo
06:51:25 <mux> ski: it's not that I want to emulate GADTs, I just want to make sure I'm getting them right
06:51:30 <xs> chessguy, 30 lines? where? :)
06:51:33 <gotaku> chessguy: Where?
06:51:35 <ski> mux : ok
06:52:14 <chessguy> i haven't actually seen it, but it was mentioned in a thread on haskell-cafe recently
06:52:28 <tapas> noob here: how can i define functions in interactive mode?
06:52:35 <mux> tapas: with let
06:52:38 <tapas> mux: ok
06:52:58 <mux> Prelude> let fac n = product [1..n]
06:52:58 <mux> Prelude> fac 5
06:52:58 <mux> 120
06:53:14 <tapas> and the type is implicit then?
06:53:24 <mux> yes, but you can still add type annotations
06:53:52 <mux> but maybe you need -fglasgow-exts for that
06:53:58 <tapas> ok
06:54:09 <ski> let {fac :: Integer -> Integer; fac 0 = 1; fac n = n * fac (n-1)}
06:54:52 <ski> (hm, braces not needed, here)
06:55:02 <xs> gotaku, there's an implementation here for classification: http://perception.inf.um.es/darcs/darcsweb.cgi?r=easyVision;a=annotate_shade;f=/lib/Classifier/Neural.hs and a general implementation here http://www-student.cs.york.ac.uk/~cb224/machinelearn/MachineLearning/NeuralNetwork/MLP.hs
06:55:05 <lambdabot> Title: darcs - easyVision, http://tinyurl.com/3ydtmw
06:55:06 <tapas> the curly ones you mean i suppose
06:55:47 * ski nods
06:56:18 <chessguy> ski, i don't know what term unification is either
06:57:59 <ski> chessguy : basically, you expressions such as e.g. syntax trees (or types), that can contain variables
06:58:53 <ski> and then you have a question : 't0 = t1' ?   where 't0' and 't1' are such trees/types
06:59:37 <chessguy> where by '=' you mean 'evaluate to the same value'?
06:59:50 <quicksilver> chessguy: simple example. If I have a list [a,b], then 'a' and 'b' must be the same type
06:59:52 <ski> and you either want to know that for any value of the variables, the two types can't be equal .. or you want to know specifically what "simple" equalities on the variables must hold for it to be true
06:59:56 <quicksilver> chessguy: (because haskell lists are uniform)
07:00:07 <quicksilver> chessguy: so the type checker tries to 'unify' the types of a and b
07:00:12 <ski> by '=' i mean syntactically equal (upto the variable parts)
07:00:15 <quicksilver> chessguy: that is, find a type which fits both of them well
07:01:00 <chessguy> hmm, ok
07:01:27 <ski> a "simple" equality is either of the form 'v = t' ('v' being a variable, and 't' being any type) or 'v0 = v1' ('v0','v1' being syntactically different variables)
07:01:42 <ski> example
07:02:28 <quicksilver> chessguy: for example, supose the type system already had deduced that a was a 'Num' and b was a 'Show'. Then it would unify those contraints to get (Num x, Show x) => x
07:02:41 <quicksilver> chessguy: and the type of the whole list is (Num x, Show x) => [x]
07:03:18 <ski> (Either [Int] b,Maybe a,a -> b)  =  (Either a c,b,[d] -> c)  ?
07:03:43 <ski> answer in this case is
07:04:49 <ski> yes, assuming  a = [Int]  /\  b = Maybe [Int]  /\  c = b  /\  d = Int
07:05:42 <chessguy> so there's an algorithmic way to determine those constraints?
07:05:47 <ski> yes
07:05:53 <quicksilver> yes, it's fairly simple
07:06:03 <vincenz> just a simple type inference
07:06:07 <quicksilver> if top-level constructors are different, through incomprehensible error
07:06:08 <vincenz> I can give you the code
07:06:11 <vincenz> it fits within 50 lines
07:06:13 <ski> (btw, usually one doesn't allow cyclic types in this solution)
07:06:15 <quicksilver> if they are the same, recurse down one level
07:06:31 <quicksilver> if one is a variable, 'decide' that that variable is the other one
07:06:33 <vincenz> ski: btw, for your case you are in correct, due to the Maybe a == b
07:06:55 <vincenz> oh wait, nm
07:06:58 <vincenz> I misread your results
07:07:44 <vincenz> @hpaste
07:07:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:08:00 <chessguy> vincenz, i don't need the code right now
07:08:08 <hpaste>  vincenz pasted "Simple complete typechecker" at http://hpaste.org/1182
07:08:12 <vincenz> chessguy: http://hpaste.org/1182
07:08:49 <chessguy> (which is why i didn't ask for it)
07:09:11 * vincenz shrugs
07:09:15 <vincenz> maybe someone else might find it interesting
07:12:11 <tsp> Blotta ter fanan
07:12:25 <tsp> now that is one rockin swedish song
07:12:27 * ski *sighs*
07:12:42 <Vq^> tsp: never heard that one
07:12:58 <tsp> I dunno if it has any online lyrics though - some band called Midgard
07:13:10 <gotaku> I'm having a really hard time trying to convert C++ programs into Haskell... I just don't know how some things can be done.
07:13:15 <chessguy> uh, i think this is a discussion for #haskell-blah
07:13:24 <tsp> gotaku: I have the same problem, its confusing as hell
07:13:30 <tsp> haskell-blah?
07:13:38 <xs> gotaku, for example?
07:13:49 <quicksilver> gotaku: try to give us some specfici examples and we'll help
07:13:49 <chessguy> @topic-tell haskell-blah
07:13:50 <lambdabot> Do not know that channel
07:13:55 <chessguy> @topic-tell #haskell-blah
07:13:56 <lambdabot> Anything BUT Haskell (even SEX!) -|- add yourself to the collection -> http://www.elis.ugent.be/~kehoste/haskell-blahSouthPark.html -|- lambdabot's first words: "Ooh, functional programmers are so
07:13:56 <lambdabot> hot" -|- current topic: "A eux je montre mon derriere (Arno)"
07:14:12 <quicksilver> gotaku: it's possible to program in qiute a C++ way in haskell if you want, but that's not necessarily idiomatic haskell then :)
07:14:43 <arcatan> hey, uh, what GUI lib would you recommend?
07:14:52 <gotaku> Well a neural network for example.
07:15:18 <Vq^> arcatan: gtk2hs
07:15:48 <xs> gotaku, did you see those two links i posted?
07:16:15 <gotaku> xs: Yes I'm trying to understand them.
07:16:29 <xs> goban, cool. what's problematic?
07:16:39 <gotaku> Another thing I'm still having trouble with is reading Haskell code.
07:17:23 <chessguy> xs, are those links your code?
07:17:54 <xs> chessguy, one is, the other isn't
07:18:55 <chessguy> xs,  can the AI Strike force use them?
07:19:16 <gotaku> Because of Haskell's code density it's really hard to understand other peoples code.
07:19:28 <xs> chessguy, sure? :) both are BSD3 or GPL afaik
07:19:36 <xs> chessguy, they are parts of larger libraries
07:19:56 <tsp> gotaku: good point
07:19:57 <quicksilver> gotaku: I don't think that's right
07:20:07 <quicksilver> gotaku: I think it hard to understand because you're not yet familiar with it :)
07:20:07 <pejo> gotaku, why would it be easier to understand the same amount of signal in more space?
07:20:14 <chessguy> ok cool
07:20:16 <xs> gotaku, your eye usually moves less ;-)
07:20:22 <chessguy> we may rip them apart, but we're collecting such code
07:20:26 <quicksilver> I can write hard-to-understand code in most languages
07:20:38 <gotaku> Yes, but it's easier in Haskell.
07:20:43 <xs> chessguy, it would be nice to merge it all into one big library.
07:20:48 <quicksilver> I dispute that :)
07:20:55 <gotaku> Hard to understand code seems to be the norm.
07:21:01 <chessguy> xs, that's the idea
07:21:03 <quicksilver> gotaku: hard to understand for you, maybe
07:21:10 <quicksilver> gotaku: but that doesn't mean it always will be..
07:21:26 <quicksilver> gotaku: I can point a perl developer at some C++ and he'll say it's hard to understand
07:21:37 <gotaku> I've been trying to understand Haskell off and on for the last few months.
07:21:45 <quicksilver> gotaku: yet that doesn't mean that that is due to a fault in C++... certainly not that C++ is dense
07:21:56 <xs> chessguy, i think documentation is a big issue for ai. you need to state what assumptions you are making about inputs and the environment. much ai code for haskell that i've seen does not include such things, usually not even references to the origin of the algorithm...
07:22:01 <quicksilver> it's much 'more different' than the C-like languages, that's true
07:22:24 <gotaku> And i'm not even talking about monads yet.
07:23:22 <chessguy> xs, you should sign up to the group
07:23:24 <chessguy> ?wiki AI
07:23:25 <lambdabot> http://www.haskell.org/haskellwiki/AI
07:23:28 <tsp> gotaku: python vs haskell on the readability front is definately python 1000%
07:23:43 <tsp> but haskell does have useful things like map and filter that fit seemlessly with the language
07:24:08 <pejo> tsp, you're talking about having the code read to you now though, aren't you?
07:24:13 <Saizan> i think is just a matter of getting the intuition of the abstraction that the code is using, without worrying too much about the details
07:24:46 <chessguy> does python have HOFs?
07:25:34 <Saizan> chessguy, you can pass functions as values, but it's not as often used as in haskell
07:25:53 <tsp> pejo: yeah
07:25:57 <xs> afaik, map is being deprecated in python 3000
07:26:20 <gotaku> When I was trying to convert that twogtp.py program to haskell I spent days trying to figure out how to do in Haskell what I saw in the python source.
07:26:35 <tsp> import operator
07:26:37 <pejo> tsp, [1..10] is rather compact in text. I imagine it's not when read out loud.
07:26:48 <quicksilver> tsp: I, on the other hand, find haskell 1000% more readable than python
07:26:50 <tsp> it reads like
07:26:55 <tsp> all I hear is this:
07:26:59 <chessguy> gotaku, don't you think there's a good chance that's more of a function of your lack of experience in haskell than it is some kind of fundamental imcompatibility between the languages?
07:27:02 <tsp> left bracket one dot dot ten right bracket
07:27:04 <tsp> relaly fast
07:27:19 <rahikkala> How about "the numbers from one to ten"?
07:27:30 <quicksilver> tsp: which is primarily due to the relative numbers of lines of code and hours of time I've spent with each language, and not much to the actual properties of either
07:27:34 <chessguy> rahikkala, screen-readers are rather dumb
07:27:39 <pejo> I'd side with rahikkala on how to pronounce it.
07:27:50 <rahikkala> Then we need Haskell-aware screenreaders :)
07:27:56 <kpreid> "the numbers from False to True"
07:27:56 <quicksilver> one of the things tsp wants to do is write a better screenreader :)
07:28:06 <gotaku> chessguy: Like I said, I've been trying off and on for months.
07:28:38 <chessguy> gotaku, haskell is a tough language. you can't expect to learn it overnight
07:28:45 <tsp> I tried forth, and that was almost as bad
07:28:48 <kombinator> hello #haskell, I'm playing with arrow transformers. Does anyone have an idea if I could implement state switching using Control.Arrow.Transformer.Automaton? I have no idea how to do it without using the data constructor of Automaton which is hidden by the module. Paste on the way.
07:28:57 <tsp> the swaps overs and drops are weird
07:29:01 <hpaste>  kombinator pasted "state switching by Control.Arrow.Transformer.Automaton" at http://hpaste.org/1183
07:29:25 <gotaku> chessguy: Do you know of any tutorials that actually show how to use Haskell and not only explain the featues of the language?
07:30:17 <chessguy> gotaku, at what level?
07:31:22 <chessguy> in my experience, you can read lots of tutorials, but you don't learn nearly as much as when you start writing your own code
07:31:33 <tsp> I was thinking of writing all my tools in python, but either way I need to write down how they work first
07:31:36 <gotaku> It's the same with all the monad tutorials... They mostly do a good job explaining them but none of them actually shows how they are used and they don't have any examples.
07:31:46 <tsp> gotaku: thats why they're called Gonads
07:31:48 <tsp> lol
07:31:56 <chessguy> lots of monad tutorials have lots of examples
07:31:59 <gotaku> And you wonder why so many people have trouble with them.
07:32:22 <chessguy> http://www.haskell.org/haskellwiki/Meta-tutorial
07:32:24 <lambdabot> Title: Meta-tutorial - HaskellWiki
07:32:30 <gotaku> chessguy: Besides "All about Monads".
07:32:42 <quicksilver> the wikibook has examples, I think
07:32:50 <gotaku> The examples in All about Monads are poor.
07:32:51 <quicksilver> ISTR the wikibook is a pretty good tutorial
07:32:57 <gotaku> I'll take a look.
07:33:09 <chessguy> yes, there's lots of great stuff in the wikibook
07:33:18 <Saizan> gotaku: do you know a little of lisp?
07:33:19 <quicksilver> the examples in all about monads are excellent
07:33:24 <gotaku> Have they drastically changed from the last time I looked at the wikibook?
07:33:29 <quicksilver> but they're for people who have already written programs in haskell
07:33:29 <tsp> where do I find all about gonads? the site went down
07:33:31 <tsp> moands
07:33:33 <tsp> monads
07:33:34 <quicksilver> not for people new to the language
07:33:35 <gotaku> quicksilver: No they aren't.
07:33:52 <rahikkala> http://haskell.org/all_about_monads/html/index.html
07:33:53 <lambdabot> Title: All About Monads
07:33:53 <gotaku> Ok.
07:33:56 <tsp> ah
07:34:09 <quicksilver> for example, the maybe monad example gets *right* to the point
07:34:17 <quicksilver> but it's only illuminating if you've actually written code like that
07:34:28 <quicksilver> i.e. if you've written haskell code using Maybe but without realising it was a monad
07:34:44 <quicksilver> then you can see how the monad instance abstracts a natural use very cleanly
07:35:33 <gotaku> Ok, I'm looking at the wikibook and the section on Monads i s as bad as it was before.
07:35:46 <quicksilver> gotaku: don't try to learn monads until you're happy with the language itself
07:35:51 <quicksilver> gotaku: that's walking before you can run
07:36:24 <gotaku> quicksilver: I am happy with the language itself...
07:36:50 <quicksilver> gotaku: the comments you've made in that discussion make me question that
07:37:09 <gotaku> quicksilver: Which comments would those be?
07:37:21 <quicksilver> gotaku: you say that you've been trying to understand the language for months, and in your opinion hard to understand code is the norm
07:37:30 <quicksilver> gotaku: that doesn't, to me, sound like someone who is happy with the language
07:37:53 <gotaku> quicksilver: Other peoples code. I can of course understand my own code.
07:38:24 <quicksilver> right. Nonetheless I stand by my point
07:38:31 <quicksilver> although of course, it does depend which code :)
07:38:57 <gotaku> And I stand by my point that all current monad tutorials suck.
07:39:36 <gotaku> Saizan: Yes I understand a little bit of lisp.
07:39:36 <hpaste>  paulius pasted "broken rsa" at http://hpaste.org/1184
07:40:08 <quicksilver> gotaku: I haven't read them all. I've read some that I liked, but I'm no longer a beginner and hence probably not a good judge
07:40:18 <quicksilver> gotaku: what don't you like about 'all about monads'?
07:40:59 <gotaku> quicksilver: Part 1 is fine, Part 2 and 3 are horrible.
07:41:10 <Saizan> gotaku: i found this article http://www.defmacro.org/ramblings/lisp-in-haskell.html quite well written and "pratical" when starting to learn monads
07:41:12 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell
07:41:54 <quicksilver> gotaku: well I'd think if you're through part I, you do understand monads, more or less
07:42:00 <quicksilver> gotaku: what about them do you feel you don't understand?
07:43:07 <gotaku> quicksilver: After Part 1 you think he is going to explain the standard monads. Nope, he it just going to past an example of each one without any commentary.
07:44:52 <quicksilver> gotaku: true, he ran out of steam
07:45:09 <quicksilver> gotaku: still if you understand Maybe, List, Either, State, and IO, then that's good enough
07:45:38 <quicksilver> most people think the 'hardest' is Cont, but that's not needed very commonly in my experience
07:45:50 <tsp> > let x = Just 3
07:45:50 <lambdabot>  Parse error
07:45:52 <tsp> lol
07:46:01 <tsp> I thought just was a gonad that just returned its value
07:46:15 <quicksilver> well, in a sense it is
07:46:23 <quicksilver> but lambdabot is for expressions
07:46:26 <quicksilver> you just want to type
07:46:28 <quicksilver> > Just 3
07:46:29 <lambdabot>  Just 3
07:46:38 <quicksilver> > let x = Just 3 in x
07:46:40 <lambdabot>  Just 3
07:46:40 <quicksilver> if you prefer :)
07:46:42 <tsp> what is Just used for? why not just type 3?
07:46:52 <quicksilver> it's used for 'might be Nothing'
07:46:54 <glguy> > Nothing :: Maybe ()
07:46:55 <lambdabot>  Nothing
07:47:00 <glguy> > Just ()
07:47:01 <lambdabot>  Just ()
07:47:05 <quicksilver> i.e. something might have gone wrong
07:47:16 <glguy> > find (>10) [1..10]
07:47:17 <lambdabot>  Nothing
07:47:24 <tsp> ah
07:47:34 <quicksilver> > find (>5) [1..10]
07:47:36 <lambdabot>  Just 6
07:47:46 <quicksilver> either I find it (return the first one, wrapped in Just) or I don't (return Nothing)
07:48:44 <mightybyte> tsp: It's an elegant way to eliminate the C programmer's dilemma of choosing which return codes to use for success and failure.
07:49:11 <mightybyte> ...at least *some* of the dilemmas.
07:49:50 <ski> (and for the 'NULL' case, it eliminates domain contagion)
07:52:40 <ski> (see e.g. the '2006-02-03' entry at <http://mumble.net/~campbell/blog.txt>)
07:58:37 <jacobian> common lisp uses multiple return values to deal with domain contagion
08:01:18 <quicksilver> jacobian: right, and haskell can use that too
08:01:26 <quicksilver> jacobian: Maybe is a very very specific case
08:01:30 <quicksilver> jacobian: it's a useful one
08:05:05 <ski> multiple alternative current continuations would be nice for some of this
08:05:38 <ski> (which i think could be thought of as "unboxed" (counboxed ?) variant types)
08:06:14 <quicksilver> like a fake threading system which maintains a pool of continuations and selects the right one for each event?
08:06:25 <ski> no, not like that
08:06:34 <ski> consider
08:06:38 <ski> @type lookup
08:06:38 <quicksilver> :t either
08:06:38 <ski> e.g.
08:06:41 <quicksilver> or like that?
08:06:42 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
08:06:42 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:07:10 <ski> now, when this is called with two arguments, it gives back a value of type 'Maybe b'
08:07:20 * quicksilver nods
08:07:28 <ski> which can be inspected, handling the two cases
08:07:41 <ski> case lookup k kvs of
08:07:46 <ski>   Nothing -> ...
08:07:56 <ski>   Just v  -> ..v..
08:07:58 <quicksilver> while you want the version which is composed with maybe?
08:08:04 <ski> but
08:08:19 <ski> one can also store the result directly inside some other datastructure
08:08:28 <quicksilver> :t \a b k al -> maybe a b (lookup k al)
08:08:31 <lambdabot> forall b a a1. (Eq a1) => b -> (a -> b) -> a1 -> [(a1, a)] -> b
08:08:37 <quicksilver> like that?
08:08:47 <ski> now, what we want is to "short-circuit" the 'case' distinction
08:09:01 <quicksilver> :t \k al a b -> maybe a b (lookup k al)
08:09:03 <lambdabot> forall b a a1. (Eq a1) => a1 -> [(a1, a)] -> b -> (a -> b) -> b
08:09:04 <quicksilver> or maybe like that :)
08:09:12 <ski> so, that, in the implementation, we don't need to tag by 'Nothing' or 'Just' at all !
08:09:25 <ski> instead we "pass two return adresses", ..
08:09:48 <ski> and if 'lookup' returns 'Nothing', then that actually selects the first return address, and returns through that
08:10:02 <ski> otherwise, in the 'Just' case, it should return through the other one
08:10:35 <ski> only in the case where we actually insert the result into a datastructure do we need to materialize the top constructor
08:10:38 <quicksilver> ski: isn't that what my example is?
08:11:14 <ski> quicksilver : well, if you're sure to get fusion, then i think it is similar, yes
08:11:19 <quicksilver> ski: *nod*
08:11:43 <ski> i'm suggesting that maybe we could extend the kinds of unboxed types we can have
08:11:45 <quicksilver> ski: especially if you instantiate 'b' in my example to 'x -> r'
08:11:55 <quicksilver> (type b not variable b)
08:12:00 <ski> so instead of just unboxed tuples, we can also get unboxed variants
08:12:45 * quicksilver nods
08:12:50 <quicksilver> right
08:12:54 <ski> data Maybe# :: ? -> #
08:12:57 <ski>   where
08:13:01 <quicksilver> so you're really talking about a compiler feature, not a language feature
08:13:04 <ski>   Nothing :: Maybe# a
08:13:08 <ski> er
08:13:11 <ski>   Nothing# :: Maybe# a
08:13:17 <ski>   Just# :: a -> Maybe# a
08:13:22 <ski> well
08:13:37 <quicksilver> at least, the language features and the compiler feature are technically orthogonal
08:13:45 <ski> maybe it could be turned into a language feature, if deemed good enough
08:13:51 <ski> but at least compiler feature, yes
08:14:27 <ski> so, just as for e.g. unboxed tuples, we have restrictions in what we can do with these kind of things
08:14:32 <ski> if you have
08:14:56 <ski> lookup# :: Eq k => k -> [(k,v)] -> Maybe# v
08:15:05 <ski> then you can't say
08:15:26 <ski> [lookup# k0 kvs,lookup# k1 kvs]
08:15:34 <ski> you have to say
08:16:23 <ski> [case lookup# k0 kvs of Nothing# -> Nothing; Just# v0 -> Just v0
08:16:27 <ski> ,case lookup# k1 kvs of Nothing# -> Nothing; Just# v1 -> Just v1]
08:16:44 <ski> thereby explicitely saying where you materialize the constructors
08:17:00 * quicksilver nods
08:17:25 <ski> otoh, you should still be able to put 'lookup# k kvs' in tail-position
08:17:31 <quicksilver> definitely something we'd rather have the optimiser working out on our behalf :)
08:17:36 <ski> yes
08:18:20 <ski> this is sortof the basic raw thing, that one could hopefully get a nice sugar wrapper above in certain circumstances
08:18:34 <ski> (similar to the tail-call guarrantees in Scheme)
08:19:21 * quicksilver nods
08:19:23 <ski> anyway, the point of this would be to get better guarrantees about certain efficiency issues, instead of just hoping the optimizer will catch it
08:20:13 <ski> i.e. you should be able to look locally at code and detect (quite easily) whether you will get this benifit or not
08:20:32 <quicksilver> @pl \k al a b -> maybe a b (lookup k al)
08:20:32 <lambdabot> (flip (flip . maybe) .) . lookup
08:20:39 <quicksilver> @pl \a b k al -> maybe a b (lookup k al)
08:20:39 <lambdabot> flip flip lookup . (((.) . (.)) .) . maybe
08:20:54 <quicksilver> intriguing
08:21:14 <quicksilver> I wonder if haskell needs better function swapping parameters
08:21:19 <quicksilver> ala dip dup and swap
08:21:48 <ski> (hopefully, one would get nonpervasive, but easily-checked conditions, just like conditions for tail-positions)
08:24:16 <ski> (possibly one doesn't need the 'Either#' level at the surface at all .. but i think it is a good way to think about the issue)
08:25:00 <quicksilver> isn't there a sense in which 'either' is 'Either#' ?
08:25:03 <quicksilver> :t either
08:25:05 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:25:36 <ski> (i'm not sure if 'Maybe# :: ? -> #' would be right, though, or maybe 'Maybe# :: ? -> <#>', where '<#>' is a new kind, sortof a parallel to '(#)' for unboxed tuple types)
08:26:09 <ski> quicksilver : yes, but now we're explicitely passing around closures, which ew have to create (and which can be used more than once)
08:26:33 <ski> so it probably isn't so easy to stack-allocate them anymore (which we probably want)
08:29:34 <ski> the point of the multiple alternative current continuations hiding behind a return type like 'Either# a b' would be that they're not first-class, and thus the implementation knows they will only be used once (one of them) .. instead of having to do some analysis to determine whether this holds
08:30:36 <ski> anyway .. i'm speculating much here .. i don't know much details of how e.g. ghc handles these situations
08:30:52 <quicksilver> ski: yes, I see what you mean
08:31:23 <ski> (just like unboxed tuples is not first-class)
08:32:07 <quicksilver> but a boxed cat isn't first-class...
08:33:06 <ski> cat(egory ?) ?
08:33:49 <quicksilver> no, a boxed cat. You don't know if its dead or not until you unbox it.
08:33:58 <ski> haha
08:34:22 <ski> collapsing the wave-function as forcing a thunk :)
08:34:39 <ski> (you never know if it'll terminate or not)
08:34:59 <Nanar> Hi, what is a easier way to parse/read an xml document ?
08:35:20 <Nanar> and if someone have an example, he is welcome ;)
08:35:51 <quicksilver> Nanar: there are several haskell XML parsers
08:36:05 <Nanar> quicksilver: yes, but documentation is light
08:36:23 <Nanar> so an example to start would help
08:37:11 <Saizan> ?goog site:hpaste.org saizan HXT
08:37:13 <lambdabot> http://hpaste.org/1151
08:37:13 <lambdabot> Title: HxT example - hpaste
08:37:16 <vincenz> Anyone know how to tar files inuch a way that symlinks are deep-copied?
08:37:25 <Nanar> Saizan: thanks
08:37:32 <quicksilver> http://www.haskell.org/haskellwiki/HXT
08:37:33 <quicksilver> ?
08:37:33 <lambdabot> Title: HXT - HaskellWiki
08:37:45 <resiak> vincenz: --derefence ?
08:37:57 <vincenz> resiak: thank you
08:43:21 <revence> ?yow
08:43:22 <lambdabot> This PIZZA symbolizes my COMPLETE EMOTIONAL RECOVERY!!
08:45:59 <revence> @seen dons
08:45:59 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 2h 8m 29s ago.
08:46:20 <revence> @seem revence
08:46:21 <lambdabot> You are in #haskell. I last heard you speak just now.
08:47:37 <phoniq> You are standing in an open field west of a white house, with a boarded front door.  There is a small mailbox here.
08:48:05 <matthew-_> ?north
08:48:05 <lambdabot> Unknown command, try @list
08:48:21 <revence> @list
08:48:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:49:20 <matthew-_> You have entered a monad. You see a binder and a value on the floor. There is one exit.
08:50:31 <vincenz> unsafeExit!
08:51:03 <Baughn> > unsafeExit
08:51:04 <lambdabot>   Not in scope: `unsafeExit'
08:51:10 <matthew-_> You are swimming in radioactive gunk. You have polluted the world's ocean. No apples for you. You die.
08:51:13 <vincenz> You hae entered a monad transformer.  You see a binder and a value on the floor, as well as an exit and an elevator (or lift for you anglicans).
08:51:55 <matthew-_> you wouldn't get lift inside the monad, that's just silly! ;)
08:52:02 <vincenz> monad transformer
08:52:11 <matthew-_> ahh yes, oops.
08:53:38 <vincenz> Welcome to RealWorld, please unbox your life.
08:54:29 <quicksilver> Welcome to the ST RealWorld/ You can check out any time you like/ But you can never leave?
08:55:03 <vincenz> Sounds very much like hinduism
08:55:13 <vincenz> Checking out = death, never leaving = infinite reincarnations
08:55:53 <matthew-_> I thought you did if you were reincarnated in certain casts? (my Religious Education is shakey at best...)
08:58:11 <ski_> You're investigating a comonadic passion that seems to change, as you look at if from different angles. There is a camera and a preserve hanging in the ceiling.
08:59:03 <revence> @seen Korollary
08:59:03 <lambdabot> Korollary is in #haskell, #haskell-overflow and #haskell-blah. I don't know when Korollary last spoke.
08:59:11 <matthew-_> Picasso enters the room.
09:00:56 <vincenz> matthew-_: it was a coarse analogy at best
09:01:20 <vincenz> You look around and see that you're in (forall a.a) then you look down and realize you're not actually standing but falling.
09:01:33 <shapr> malcolmw: Silly question, how do I turn HaXml RefEntitys into something real in a string?
09:01:48 <shapr> Or if someone else knows, I won't have to bug the author of HaXml :-)
09:02:38 <vincenz> Two phantoms walk into the bar, says one ot the other "You look so much the same", says the other annoyedly "Oh but we're so very different"
09:04:30 <vincenz> What do you get when you cross two different species? ... A pair.
09:05:06 <matthew-_> this could just run and run...
09:06:15 <lispy> shapr: hmm..
09:06:21 <lispy> shapr: a RefEntity?
09:06:28 <vincenz> matthew-_: :(
09:06:42 <lispy> shapr: i don't think i've dealt with those...which version of HaXml?
09:07:34 <lispy> shapr: but i do remember reading the source code to figure out a lot of HaXml
09:08:55 <shapr> Yay! We figured it out!
09:09:04 <lispy> cool
09:09:08 <shapr> We used attr2str from Xml2Haskell
09:09:14 <lispy> because i'm about to leave so i would be no help :)
09:09:22 <shapr> Then we could turn RefEntity into an actual string.
09:09:31 <lispy> that makes some sense
09:09:38 <lispy> kinda backwards, but i see how it could work
09:10:08 <lispy> Xml2Haskll.attr2str <-- this seems backwards
09:42:07 <shapr> Has anyone made an instance of Random for Word64?
09:43:32 <shapr> Aha, Data.Binary has one.
09:47:01 <shapr> @seen bringert
09:47:01 <lambdabot> I saw bringert leaving #haskell 3h 8m 1s ago, and .
09:47:40 <vincenz> heya beelsebob_
09:47:45 <vincenz> erm
09:47:46 <vincenz> shapr:
09:47:50 <beelsebob_> o.O
09:48:01 <vincenz> shapr -> bringert -> tab-complete on b
09:48:10 * vincenz hasn't slept last night, all night working
09:50:21 <beelsebob_> hehe
09:51:25 <ndm> who thinks you can put a smilie in an ICFP paper
09:51:31 <ndm> its totally deserving in this case!
09:51:35 <vincenz> ndm: I do
09:51:40 <vincenz> ndm: use the smiley character
09:51:43 <vincenz> the one with a circle around it
09:51:57 * vincenz might submit to HW 
09:52:00 <vincenz> \o/
09:52:03 * ndm hopefully will too
09:52:05 <vincenz> when's icfp btw?
09:52:12 <ndm> vincenz: with Compos n+1 ?
09:52:16 <vincenz> ndm: yeah
09:52:18 <ndm> vincenz: deadline is the 6th
09:52:22 <vincenz> ndm: of?
09:52:23 <ndm> vincenz: i'm submitting with Play
09:52:28 <ndm> vincenz: April (soon)
09:52:31 <vincenz> oy
09:52:34 <vincenz> no way, I have another paper deadline
09:52:36 <vincenz> but Ithought HW was later
09:52:46 <vincenz> ndm: but I meant, when is the conference?
09:53:10 * vincenz has a paper deadline for the 15th which is requiring LOTS of work
09:53:24 <ndm> vincenz: early october, 3rd ish i think
09:53:31 <vincenz> whew
09:53:35 <ndm> oh, hw deadline is july
09:53:36 <vincenz> after I'm back from greece
09:53:50 <vincenz> and not too far :)
09:54:04 <vincenz> ndm: june 15th
09:54:05 <ndm> i have the code, i have the becnhmarks, i have some of the paper
09:54:18 <vincenz> I have the code (my ++c typechecker)
09:54:29 <vincenz> though actually that's more of a benchmark, my Compos.s is the code
09:54:32 <vincenz> +h
09:54:34 <ndm> i even have some theorems
09:54:54 <vincenz> it'd be cool to go to a HW conference, I tend to submit in a TOTALLY different field
09:55:14 <yaarg> hi
09:56:02 <vincenz> ndm: fifnally meet some of you peeps face2face
09:56:10 <ndm> vincenz: cool :)
09:56:36 <vincenz> tho maybe I might get invited anyways to ICFP...what with lazy bottoms :P
09:56:36 <ndm> vincenz: i've met quite a few peeps face to face at HW2005, various fun in the afternoons, hackathon 07
09:56:50 <ndm> but there is always someone i've never met!
09:56:56 <ndm> (loads, actually)
09:57:08 <vincenz> ndm: well yeah, but I don't work ini that field, though I'd like to move in that direction
09:57:57 * vincenz tends to write all this crap like Compos n+1 out of necessity
09:58:43 <vincenz> s/crap/fancy stuff requirinig lots of work
10:03:30 <pejo> Heh, I don't think any research is little work.
10:05:20 <vincenz> pejo: my point is that it's not research for me, this stuff, it's stuff I require for my resaerch :/
10:05:37 <vincenz> though I'm happy to have the opportunity of spinning it off into a paper
10:05:54 <vincenz> Anyone know the effort required to write a H98 frontend ? (down to Tcheck?)
10:08:16 <araujo> morning!
10:08:21 <ndm> vincenz: crap loads
10:08:28 <vincenz> ndm:  :)
10:08:29 <ndm> vincenz: its a lot harder than you might first think
10:08:38 <ndm> vincenz: i wrote Play out of necessity
10:08:45 <ndm> and Yhc.Core as well
10:09:05 <ndm> i do want to write the perfect haskell compiler one day
10:09:36 <ndm> but need the perfect parsing technology (still working on it), the perfect desugarer (diagrams only so far), the perfect type checker (chameleon may be it)
10:09:53 <ndm> along with the "perfect" versions of other stuff that do exist, like lambda lifting and generics (Play)
10:10:02 <vincenz> ndm: tell me when you get started, I'd like to play along
10:10:03 <ndm> plus the perfect optimiser, which is stage n+1 of my phd
10:10:12 <ndm> @google basic haskell compiler neil
10:10:15 <lambdabot> http://neilmitchell.blogspot.com/2006/12/bhc-basic-haskell-compiler.html
10:10:16 <lambdabot> Title: Neil Mitchell's Haskell Blog: bhc: Basic Haskell Compiler
10:10:28 <ndm> vincenz: that was my "mission statement" for this compiler, if you will
10:11:16 <vincenz> ndm: dictionaries are desugared post-tcheck?
10:11:58 <ndm> vincenz: yes
10:12:24 <ndm> vincenz: they have to be, they require the type signature for the desugaring - its one of the few type directed desugarings
10:13:25 <vincenz> ndm: oh
10:15:00 <ndm> vincenz: i'd love to write a compiler which had type checking as an option, not a requirement, but its impossible (i think)
10:15:21 <ndm> if anyone does come up with such a desugaring scheme, no matter how inefficient, i'd be interested to see it
10:16:58 <vincenz> ndm: no small goals ... bhc
10:17:20 <ndm> vincenz: its not an active goal, its more what i would consider the ideal way to do everything
10:17:38 <ndm> i'll probably develop each section in isolation, and if it all slots together, i win :)
10:18:02 <ndm> the hope is also to develop the correct principles for compiling a language like haskell, so i suspect even if the langauge changes, the compiler doesn't really need to
10:18:24 <ndm> compiling clean and ml would probably be in bhc 2, along with all the crazy backends you could ever want
10:19:19 <ndm> anyway, dinner calls - bye
10:19:22 * vincenz has a miniml compiler, though with haskell-style top-level recursion, and haskell-style module
10:19:28 <vincenz> s+s
10:23:42 <shapr> Wow, Lemmih knows COOL magic!
10:23:54 <chessguy_work> @quote magic
10:23:55 <lambdabot> bakert says: i think it's a question of where you are looking from.  from the magician's point of view no one got sawn in half and from the audience's point of view someone did and they both like it
10:23:55 <lambdabot> that way around.
10:24:38 <chessguy_work> @quote spell
10:24:38 <lambdabot> ghc says: Plugin/Spell.hs:35:31: Not in scope: `spellineNazi'
10:24:49 <shapr> wha?
10:24:49 <chessguy_work> @quote spells
10:24:50 <lambdabot> No quotes match. That's something I cannot allow to happen.
10:25:22 <chessguy_work> @quote goat
10:25:23 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
10:31:04 <shapr> haha
10:31:07 <shapr> I like that one.
10:31:37 <opqdonut> tying the know?
10:31:40 <opqdonut> *knot
10:31:56 <shapr> aka The Credit Card Transform
10:33:17 <opqdonut> not a clue
10:33:52 <Saizan> ?google site:haskell.org tying the knot
10:33:53 <lambdabot> http://haskell.org/hawiki/TyingTheKnot
10:33:54 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
10:34:58 <chessguy_work> <wcdo hidebind="coregconfirm">
10:34:58 <chessguy_work> 	<div id="&OCS_NAMESPACE;subcoregconfirm">
10:34:58 <chessguy_work> 		<table width="600" border="1" align="center" cellpadding="3" cellspacing="0" bordercolor="#cccccc">
10:34:58 <chessguy_work> 			<tr>
10:34:59 <chessguy_work> 				<td width="596" colspan="2" align="left" valign="top" bgcolor="#F5F5F5">
10:34:59 <chessguy_work> 					<table width="64%"  border="0" cellspacing="0" cellpadding="0">
10:35:01 <chessguy_work> 						<tr id="ocs_elt_maingraphic">
10:35:03 <chessguy_work> 							<td><img src="$FILE_LOCATION/head.jpg" width="589" height="173" /></td>
10:35:05 <chessguy_work> 						</tr>
10:35:07 <chessguy_work> 						<tr>
10:35:09 <chessguy_work> crap
10:35:10 <opqdonut> errrr
10:35:11 <chessguy_work> i hate this client
10:35:12 <opqdonut> thanks
10:35:16 <chessguy_work> sorry
10:36:31 <chessguy_work> i like xchat, used it for a while, but the windows version expires :(
10:37:00 <NichardRixon> chessguy_work, that's because you get it from the wrong places
10:37:07 <NichardRixon> the official one is bogus and dumb
10:37:18 <chessguy_work> NichardRixon, got a link for me?
10:37:32 <NichardRixon> let me do some searching
10:37:37 <NichardRixon> I just know about the issue second-hand
10:38:20 <chessguy_work> i guess i could download mirc
10:39:20 <ski> http://www.silverex.org/
10:39:24 <lambdabot> Title: X-Chat 2 for Windows
10:39:26 <opqdonut> ok that tying the knot goes well over my head :S
10:39:47 <chessguy_work> nice
10:40:28 <NichardRixon> yeah, it's silverex
10:40:33 <sjanssen> shapr: has the latest xmonad fixed your problems?
10:40:35 <twanvl> I use http://paces.podzone.net/xchat-win32/
10:40:37 <lambdabot> Title: X-Chat 2 for Windows :: Index
10:40:41 <NichardRixon> uses the gtk runtime
10:41:08 <stepcut> sjanssen: the latest xmonad is broken for me
10:41:38 <sjanssen> stepcut: upgrade X11-extras
10:42:02 <sjanssen> stepcut: you'll want to follow the commit messages, I generally make a note when an upgrade is required
10:42:24 <stepcut> sjanssen: I did upgrade, but maybe something is cached
10:43:03 <stepcut> sjanssen: If I have two windows open on the screen, often the menus in windows will not respond to mouse clicks -- though the window does see that the mouse is there (for example, widgets that respond when you hover the mouse over them)
10:43:15 <stepcut> is that the problem that needs X11-extras ?
10:43:36 <sjanssen> oh, I thought you meant doesn't compile
10:43:55 <stepcut> no, I think the patches for click-to-focus, and stealing my mouse button presses
10:44:04 * chessguy_work tries to mass-dump his clipboard into the channel by accident again
10:44:06 * chessguy_work fails
10:44:11 <chessguy_work> woohoo!
10:44:21 <sjanssen> stepcut: so you have the problem in tile mode, yeah?  Which applications do it?
10:44:35 <shapr> Oh, you gotta see Lemmih's magic of the moment!
10:44:47 <chessguy_work> ?version ski
10:44:47 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
10:44:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:45:05 <waern> shapr, huh?
10:45:07 <chessguy_work> oops, wrong command
10:45:32 <ski> (fyi .. CTCP VERSION reply from ski: irssi v0.8.9 - running on Linux i586)
10:45:53 <stepcut> sjanssen: yes, tile mode only. So far, konsole and kopete, I have not tried much else
10:46:43 <stepcut> sjanssen: In tile mode, keyboard events go where I expect, and mouse hovering works, but only one window will get the mouse clicks
10:47:12 <sjanssen> stepcut: I can reproduce your problem with kpdf and konqueror
10:47:44 <hpaste>  shapr pasted "magic threadDelay amounts" at http://hpaste.org/1186
10:48:03 <shapr> waern: Lemmih wrote a cute way to do threadDelay amounts.
10:48:16 <sjanssen> stepcut: as a workaround, you can change the focus with alt+j/k, that seems to fix the mouse focus
10:48:16 <shapr> Lets you do threadDelay 2m for example.
10:48:21 <Cheery> I can read stuff with parsec, but what if I want to generate code?
10:48:54 <stepcut> sjanssen: yeah, kpdf and konqueror also have the problem. It seems that which ever window was openned last is the only one that gets mouse clicks
10:49:20 <sioraiocht> anyoen know of a quick way to calculate large exponents (mod n) in haskell?
10:49:24 <Cheery> I've gotten sick of inflexible CSS, so I'd like to take a different approach.
10:49:37 <sjanssen> stepcut: xmonad is stealing the clicks to do click to focus.  I know how to fix it
10:50:00 <stepcut> sjanssen: yeah, alt+j/k sort of fixes it -- it just changes which window gets all the clicks
10:50:09 <sjanssen> right
10:50:28 <shapr> sjanssen: btw, the keymap fix also fixes the gnome-theme-manager problem.
10:50:39 <stepcut> sjanssen: will click-to-focus vs focus-follows-mouse be a Config option ?
10:50:45 <sjanssen> shapr: ah, that makes sense
10:50:56 <sjanssen> stepcut: do you prefer one?
10:51:07 <Cheery> I'm going to replace the fainting manner of writing stupid CSS with few combinators.
10:51:33 <stepcut> sjanssen: I always use focus follows mouse or sloppy focus follows mouse, though sloppy focus does not make much sense in a tiling window manager
10:51:54 <stepcut> Cheery: oh ? Someone I work with is trying to do that
10:52:12 <Cheery> stepcut: does it do it by generating CSS itself?
10:52:14 <EvilTerran> is there an elegant way of writing the merge for mergesort in haskell? something cunning with no explicit recursion, maybe?
10:52:17 <sjanssen> stepcut: the plan is to have a hybrid approach.  I'd call it "focus on click or entry"
10:52:28 <waern> shapr, ah ok
10:52:42 <stepcut> sjanssen: what does that mean?
10:52:55 <sjanssen> stepcut: have you used dwm?  We're going to do that
10:53:21 <stepcut> Cheery: I think the plan is to first create a low-level set of combinators that can express all of CSS, and then create smart combinators that 'do what you mean', and perhaps include multibrowser work-arounds
10:53:37 <stepcut> Cheery: but, if you want this soon, you would be better off doing it yourself ;)
10:53:57 <stepcut> sjanssen: no, I have never used dwm.
10:54:05 <sjanssen> EvilTerran: check out the source for Data.List
10:54:09 <sjanssen> @fptools Data.List
10:54:09 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
10:54:15 <EvilTerran> > let merge (x:xs) (y:ys) = (if x < y then (x:).(y:) else (y:).(x:)) (merge xs ys); merge xs [] = xs; merge [] ys = ys in  merge [0,3..21] [5..10] -- is there a better way?
10:54:16 <lambdabot>  [0,5,3,6,6,7,8,9,9,12,10,15,18,21]
10:54:33 <EvilTerran> wait, that doesn't even work. okay, ignore me, i'll look at that. =/
10:54:42 <Cheery> stepcut: I'm going to put some effort on it immediately
10:55:10 <Cheery> with low level, what kind of set of combinators are you talking about?
10:55:14 <stepcut> Cheery: excellent! I would like to see what you come up with
10:55:40 <EvilTerran> sjanssen, okay, that looks like a no, then. thanks!
10:55:53 <stepcut> Cheery: I think he was trying to write a program to parse the CSS spec and create type-safe functions for all the CSS properties.
10:56:01 <sjanssen> stepcut: focus will change in any of these ways: alt+j/k, window creation (new window gets focus), window deletion (next window in stack gets focus), the user moving the mouse into another window, the user clicks on a window that doesn't have focus
10:56:35 <Cheery> stepcut: but shouldn't those be quite simple? :)
10:57:13 <stepcut> sjanssen: hrm, I think I see. At first I was confused as to how you could click on a window that does not have focus -- since it would already have focus when you moved the mouse into it. But now I see that you could have used alt+j/k to switch the focus to another window
10:57:43 <stepcut> Cheery: yes, but somehow harder in practice
10:57:59 <stepcut> sjanssen: but that sounds like a system I would like
10:58:24 <sjanssen> stepcut: workspace and layout switching might also cause the focus to be away from the mouse
10:59:00 <Cheery> I guess first thing I'd need is better specs about css than what my skill in writing css is...
10:59:09 <Cheery> that can be solved by google, lets see
10:59:21 <stepcut> sjanssen: yeah
11:00:05 <sjanssen> stepcut: but xmonad doesn't actually work like this yet, due to some sloppy code
11:00:11 <stepcut> Cheery: keep we posted
11:00:42 <stepcut> sjanssen: :p
11:01:06 <stepcut> sjanssen: It was usuable yesterday, but today, it's a bit painful ;)
11:01:21 <Cheery> hmm... http://www.w3schools.com/css/css_reference.asp
11:01:22 <lambdabot> Title: CSS2 Reference
11:01:31 <Cheery> ... http://www.w3schools.com/css/css_syntax.asp
11:01:32 <lambdabot> Title: CSS Syntax
11:01:38 <stepcut> sjanssen: is there any desirable place to log 'bugs' and wishlist stuff ?
11:02:25 <stepcut> sjanssen: I have noticed a few applications that act weird
11:02:37 <sjanssen> stepcut: mmm, not really
11:03:00 <Cheery> First I need to write some swedish text for my teacher.
11:03:32 <Cheery> the basic things about CSS2 seem so utterly simple that one could practically make very clean combinators for them all, I guess
11:03:35 <stepcut> sjanssen: I realize it's still mostly a fix-it-yourself operation ;)
11:04:59 <sjanssen> stepcut: if you can narrow the problems down to concrete issues, you can edit the TODO and send me the patches
11:05:22 <sjanssen> email is fine too
11:07:33 <shapr> sjanssen: Looks like there might be more xmonad bugs
11:07:40 <shapr> sjanssen: Suddenly all the keybindings are gone
11:07:52 <sjanssen> hmm
11:07:55 <shapr> Is there a command line way to restart xmonad?
11:07:59 <shapr> Can I HUP it or anything?
11:08:11 <sjanssen> no, we haven't finished it yet
11:08:14 <shapr> ok
11:08:32 <sjanssen> shapr: for now, I recommend running xmonad inside a while loop
11:08:40 <shapr> AHA
11:08:42 <shapr> I found the problem!
11:08:59 <sioraiocht> @src (.)
11:09:00 <lambdabot> (.) f g x = f (g x)
11:09:06 <shapr> When scrolllock is on, suddenly none of the bindings work anymore.
11:09:58 <sjanssen> oh, right
11:10:32 <shapr> Why is that?
11:11:09 <sjanssen> scroll lock counts as a modifier key
11:11:10 <sjanssen> like alt, ctrl, shift, etc.
11:11:19 <shapr> weirdness...
11:11:28 <shapr> But I can think of several perverted uses for that.
11:11:45 <shapr> For example, I could put a qwerty mapping under scroll-lock.
11:11:52 <sjanssen> this is X11's choice, mind you
11:12:00 <shapr> very odd
11:12:39 <sjanssen> we explicitly ignore numlock, probably need to do that for scroll lock too
11:14:22 <shapr> Yeah, probably a good idea.
11:14:44 <sjanssen> actually, I've got an idea to end this crap once and for all
11:15:08 <stepcut> sjanssen: voice recognition?
11:15:11 <sjanssen> we're going to ignore all mask bits that xmonad doesn't explicitly bind
11:15:48 <shapr> smart!
11:15:58 <tuukkah> at least gdk has a list of modifiers that are *not* ignored
11:16:14 <sjanssen> tuukkah: yeah, I should probably do that too
11:16:26 <tuukkah> "The default mod mask is GDK_CONTROL_MASK | GDK_SHIFT_MASK | GDK_MOD1_MASK | GDK_SUPER_MASK | GDK_HYPER_MASK | GDK_META_MASK"
11:16:55 <shapr> btw, this paper and its related papers are VERY COOL: http://lambda-the-ultimate.org/node/2157
11:16:56 <lambdabot> Title: Type Directed Concurrency | Lambda the Ultimate
11:24:47 <Cheery> http://www.fury.fi/~raven/html/pics/valokuvat/swim.png
11:25:55 <Cheery> swim over atlantic ocean if you want to get to Washington from London
11:26:53 <shapr> Cheery: haha, that's great!
11:26:55 <Cheery> it's only 5000 kilometers to go!
11:27:03 <fantasma> lol!
11:29:43 <Cheery> I know who IS NOT GOING TO schedule my next holiday trip
11:30:57 <Cheery> I guess it'd may be entertaining to swim from Finland to Australia coast according to google...
11:32:12 <shapr> Probably so.
11:32:30 <sm> that's pretty funny :)
11:32:44 <sm> my favourite part is the "slight right at EO5" afterwards
11:32:55 <sioraiocht> @src id
11:32:56 <lambdabot> id x = x
11:34:04 <tibbe> > Data.ByteString.pack "test"
11:34:05 <lambdabot>   Not in scope: `Data.ByteString.pack'
11:35:06 <tibbe> hmm
11:35:27 <tibbe> isn't pack supposed to take a String to a ByteString?
11:35:39 <bos31337> depends on the pack you use.
11:35:48 <tibbe> hmm
11:36:45 <tibbe> I see no String -> ByteString in Data.ByteString
11:36:57 <sjanssen> tibbe: Data.ByteString.Char8
11:36:58 <bos> there are different versions of pack in each of Data. ByteString, Data.ByteString.Lazy, Data.ByteString.Lazy.Char8, etc
11:37:26 <tibbe> sjanssen, ah, I was using just Data.ByteString
11:38:15 <shapr> Hm, either the Show instance for Network.URI is wrong, or I'm wrong...
11:38:26 <shapr> > show $ nullURI { uriScheme = "http:", uriPath = "/startSession", uriAuthority = Just URIAuth { uriUserInfo = "", uriRegName = "www.lastid.net", uriPort = "5" }}
11:38:27 <lambdabot>   Not in scope: `uriPort'
11:38:34 <shapr> > show $ Network.URI.nullURI { uriScheme = "http:", uriPath = "/startSession", uriAuthority = Just URIAuth { uriUserInfo = "", uriRegName = "www.lastid.net", uriPort = "5" }}
11:38:35 <lambdabot>   Not in scope: `uriPort'
11:38:37 <Igloo> Data.ByteString has pack :: [Word8] -> ByteString
11:40:01 <augustss_> @seen ndm
11:40:02 <lambdabot> ndm is in #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard ndm speak 1h 20m 42s ago.
11:41:26 <sjanssen> Data.ByteString when you want to treat it as a list of bytes, .Char8 when you want to treat it as a list of characters
11:42:17 <sjanssen> tibbe: we have that convention because Data.ByteString is a bit naughty when interpreting Chars >= 256
11:42:43 <tibbe> ok
11:43:38 <sjanssen> @seen alec
11:43:38 <lambdabot> I saw alec leaving #haskell 2d 23h 22m 29s ago, and .
11:47:33 <shapr> EXCITEMENT!
11:47:56 <stepcut> YAY!
11:48:02 * stepcut boings
11:48:17 <sjanssen> shapr: huh?
11:48:29 <shapr> sjanssen: Just happy about getting lots of code written and working.
11:48:46 <sjanssen> xmonad just got window borders from a nice new contributor
11:48:52 <stepcut> shapr: more HAppS stuff ?
11:49:15 <stepcut> sjanssen: nice!
11:49:51 <sjanssen> I should count the number of contributors
11:49:54 <shapr> stepcut: Yup, lots of good HAppS stuff.
11:49:58 <shapr> sjanssen: yay!
11:50:14 <shapr> Soon it'll rival Enlightenment in the number of features... and all in less than 400 lines!
11:50:24 <stepcut> shapr: ince!
11:50:40 <tibbe> hmm, how do I define a class Context with one function lookup which is paramterized by a data type plus the key and value type? i.e. instance Context (Map String String) where ...
11:50:52 <tibbe> so I can use both Maps of String and ByteString for lookup
11:54:18 <tibbe> shapr, what's happening with happs? it sounds very exiting with the S3 stuff
11:56:55 <tibbe> ping, anyone there?
11:57:00 <tibbe> I think I lost my connection
11:57:12 <kpreid> "no"
11:57:34 <kpreid> you left after "shapr, what's happening ..." and came back, nobody said anything
11:57:58 <tibbe> ok, phew ;)
11:58:17 <tibbe> I'm on a really shaky connection here, loose connection like every 30 mins
12:00:19 <Orphi> greetings fellow Haskell addicts :)
12:00:29 <Orphi> (and all you other people)
12:01:32 <Codex_> (f 1 2) 3
12:01:50 <Orphi> can anyone think of a do expression that works with Maybe and [] and does something moderately 'useful' in both cases?
12:02:37 <sjanssen> pretty much any search type application
12:02:44 <mauke> \m -> do { x <- m; guard (even x); return x }
12:02:53 <sjanssen> Maybe can return the first match, [] will return every match
12:02:59 <kc5tja> Well, x <- [1, 2, 3]; 4*x will produce the scalar multiplication of the list against 4.
12:03:04 <chessguy_work> sjanssen: you're nuts
12:03:16 <Orphi> @type guard
12:03:18 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
12:03:27 <chessguy_work> @type  \m -> do { x <- m; guard (even x); return x }
12:03:28 <Orphi> ...and you learn a new function every day!
12:03:29 <sjanssen> chessguy_work: why am I nuts?
12:03:30 <lambdabot> forall (t :: * -> *) t1. (Integral t1, MonadPlus t) => t t1 -> t t1
12:03:41 <chessguy_work> sjanssen: how in the world do you come up with stuff like that?
12:03:46 <Orphi> @src guard
12:03:46 <lambdabot> guard True  =  return ()
12:03:46 <lambdabot> guard False =  mzero
12:03:51 <Orphi> oooohhhh....
12:04:11 <LPhas> :T guard
12:04:14 <mauke> > (\m -> do { x <- m; guard (even x); return x }) [1 .. 10]
12:04:14 <LPhas> :t guard
12:04:15 <lambdabot>  [2,4,6,8,10]
12:04:17 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
12:04:22 <mauke> > (\m -> do { x <- m; guard (even x); return x }) (Just 5)
12:04:23 <lambdabot>  Nothing
12:04:26 <sjanssen> chessguy_work: I don't think I invented that one myself.  I probably saw it in All About Monads or something
12:04:49 <chessguy_work> sjanssen: yeah, but still, to just remember it out of the blue like that...
12:04:57 <Orphi> man I wish this IRC client had an easy way to reply to particular people! >_<
12:05:21 <Orphi> well searching in Maybe is easy using the 'lookup' function
12:05:31 <Orphi> but then you'd need to modify the code to make it work in []
12:05:40 <Orphi> (presumably replace lookup with filter or something)
12:05:48 <kc5tja> Hiding otherwise explicit error propegation is one application.
12:05:54 <Orphi> I'm having trouble coming up with a concrete non-contrived example
12:05:56 <sjanssen> Orphi: Data.Map's lookup returns a monadic result
12:06:08 <Botje> &
12:06:23 <Orphi> ooo...
12:06:26 * Orphi checks it out
12:06:35 <kc5tja> do someResult <- someMaybeProducingOperation; return workOnResultWith someResult
12:06:47 <kc5tja> E.g., code is written as if it always succeeds, even if it doesn't.
12:07:09 <mauke> s/\QE.g./I.e./
12:07:28 <chessguy_work> @type do ?someResult <- ?someMaybeProducingOperation; return ?workOnResultWith someResult
12:07:30 <lambdabot> Parse error in pattern
12:07:36 <chessguy_work> @type do ?someResult <- ?someMaybeProducingOperation; return ?workOnResultWith ?someResult
12:07:38 <lambdabot> Parse error in pattern
12:08:00 <chessguy_work> @type do ?someResult <- ?someMaybeProducingOperation; return $ ?workOnResultWith ?someResult
12:08:03 <lambdabot> Parse error in pattern
12:08:07 <chessguy_work> ok, i give up
12:08:20 <Botje> what's with the question marks?
12:08:22 <Orphi> authorise users passwords username password = do user_id <- lookup username users; pw <- lookup user_id passwords; return pw == password
12:08:31 <Orphi> ...is the best I could think of
12:08:39 <chessguy_work> Botje: implicit parameters'
12:08:47 <chessguy_work> @type map ?f ?ls
12:08:49 <lambdabot> forall a b. (?f::a -> b, ?ls::[a]) => [b]
12:09:14 <shapr> Warning: orphan instances!
12:09:30 <shapr> Contribute your extra $ calls to support the orphan instances today!
12:09:30 <mauke> @type do someResult <- ?someMaybeProducingOperation; return $ ?workOnResultWith someResult
12:09:32 <lambdabot> forall t a (m :: * -> *). (?someMaybeProducingOperation::m t, ?workOnResultWith::t -> a, Monad m) => m a
12:09:33 * shapr grins
12:10:29 <Orphi> hmm... seems if I import Data.Map then lookup will have a better type signature...
12:10:35 <Orphi> @type Data.Map.lookup
12:10:38 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
12:10:58 <sjanssen> @remember shapr Contribute your extra $ calls to support the orphan instances today!
12:10:58 <lambdabot> Done.
12:11:15 <chessguy_work> ok, time to quit playing and get back to work (ugh)
12:11:27 <nominolo> Hm, too bad (.) can not be overleaded
12:11:37 <sioraiocht> @src (>>=)
12:11:38 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:11:53 <sioraiocht> @src join
12:11:54 <lambdabot> join x =  x >>= id
12:12:12 <Orphi> another question... (to anybody who feels like answering)
12:12:25 <Orphi> I want to make a monad instance for a type involving Data.Set
12:12:41 <Orphi> however, Data.Set only accepts elements having an Ord instance
12:12:52 <Orphi> as you can imagine, the type checker is NOT happy about all this...
12:13:13 <Orphi> but I can't add a context to the monad instance because... well... it doesn't mention the monad element type
12:13:15 <Orphi> um
12:13:21 <Orphi> help! x_x
12:13:21 <nominolo> instance Ord a => Monad (Foo a) where .. doesn't work?
12:13:27 <sjanssen> Orphi: well known problem
12:13:33 <nominolo> oh
12:13:39 <Orphi> sjanssen: any known solutions?
12:13:40 <sjanssen> there isn't a good solution
12:13:46 <Orphi> ack.
12:13:52 <Orphi> oh dear... lol!
12:14:07 <Orphi> nominolo: wrong kind
12:14:20 <Orphi> (OMG I sound intelligent saying that!)
12:14:31 <twanvl> See http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
12:14:35 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
12:14:36 <nominolo> Orphi: data Foo a b = ... ;)
12:14:42 <sjanssen> I think you can you can trick GHC HEAD into doing it.  You can also use -fno-implicit-prelude and provide your monad class (very complicated, not at all recommended)
12:14:58 <Orphi> eeeeps! o_O
12:15:09 <sjanssen> s/monad/own monad
12:15:31 <Orphi> similar problem happens when trying to add an instance of Functor to a collection that only holds one type of element...
12:15:42 <Orphi> the Functor class expects a higher kind
12:15:47 <sjanssen> right
12:15:51 <Orphi> again, I can't think of a way out
12:16:06 <Orphi> and yet, intuitively, there's no particular reason why it shouldn't be a functor
12:16:06 <glguy> it makes sense that you can't since what you've defined isn't a Functor
12:16:45 <Orphi> well, you can define a map function on it; it just can't be the fmap method from Functor. lol!
12:17:02 <glguy> right, since things that are functors are generalized containers
12:17:15 <glguy> so if you don't define such a container, then you can't define fmap on it
12:17:39 <Orphi> hmm... category theory makes my head hurt. :S
12:17:44 <Orphi> anybody else find that?
12:17:54 <LPhas> Orphi: yeah ...
12:18:02 <sioraiocht> Orphi: I'm in a lecture about it right now, and yes
12:18:03 <Orphi> LPhas: glad it's NOT just me!
12:18:22 <Orphi> sioraiocht: sympathy!
12:18:28 <LPhas> Orphi: i feel like only moggi knows what really is a monad :P
12:18:50 <Orphi> <Neo>what...is...the...monad?</Neo>
12:18:51 <Philippa> if category theory doesn't work for you, just stop thinking in terms of it
12:18:55 <sjanssen> Orphi: probably the best solution is to use the list monad and uniq intermediate results yourself
12:19:23 <Orphi> yeah, perhaps
12:19:37 <sioraiocht> Orphi: read all about monads
12:19:38 <Orphi> just a pitty I can't use the nice set implementation that already exists, is all
12:20:01 <Orphi> OK, the next question...
12:20:19 <Orphi> in Java/C++/Eiffel/Smalltalk/etc, people obsess for weeks about which collection type to use
12:20:34 <Orphi> and yet in Haskell, everybody just uses lists - as if no other type of collection exists
12:20:35 <sjanssen> where uniq xs0 = foldr (\x xs s -> if Set.elem x s then xs s else x : xs (Set.insert x s)) (const []) xs0 Set.empty
12:20:36 <Orphi> why is that?
12:20:42 <mauke> Orphi: I don't!
12:20:44 <astrolabe> heh
12:21:00 <sioraiocht> Orphi: they can do most of the things you want
12:21:05 <mauke> my last program used lists, sets, maps and sequences
12:21:13 <LPhas> Orphi: does exists other things than lists?
12:21:21 <astrolabe> Maybe we're more interested in code which looks good than code that runs quickly.
12:21:36 <Orphi> astolabe: hmm, possibly!
12:21:52 <Orphi> but it would be best to have code which does *both* - can that be possible? ;)
12:22:28 <sjanssen> Orphi: use Edison if you want to write code that works on all sorts of data types
12:22:30 <sjanssen> @where edison
12:22:30 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
12:22:38 <Orphi> in, say, Smalltalk, you can easily switch between all the different collection classes (depending on what features you're actually making use of)
12:22:50 <clanehin> Orphi: most of the time, the performance issues are make-believe
12:22:50 <Orphi> in Haskell, it doesn't appear to be so readily possible to change types like that
12:22:52 <astrolabe> It could, but it would look like lists and compile into arrays etc.  So it is the compiler's problem.
12:23:35 <nominolo> wha, grey text
12:23:41 <nominolo> it almost vanishes ..
12:24:24 <sjanssen> Orphi: it's easy to make changes if you use type classes
12:24:30 <byteshack> Orphi: If all you are doing is changing the interface to the collection, then that is fine.  If you have to keep on converting thins back and forth between different underlying data-types, you might see more costs
12:24:34 <sjanssen> and write polymorphic code
12:24:56 <Orphi_> wow... what the hell??
12:24:59 <Orphi_> power cut
12:25:22 <EvilTerran> @hoogle IArray -- hmm?
12:25:22 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- hmm?'
12:25:30 <EvilTerran> bah. well, you get the idea.
12:25:49 <Orphi> did I miss anything good? :}
12:26:01 <kpreid> Orphi: yes.
12:26:07 <Orphi> awwww! :(
12:26:17 <kpreid> Orphi: so consult the logs.
12:26:27 * Orphi is already doing it ;)
12:27:43 <Orphi> a while back, I did try and sit down and write a bunch of classes to capture the basic properties that various collections have
12:27:54 <Orphi> so that you could give instances for various collection types
12:28:11 <Orphi> the thing that trips me up is collections like ByteString
12:28:17 <Orphi> which types can that contain, exactly? ;)
12:29:10 <Orphi> ooo... I just had an evil thought... I found use fundeps at get round that o_O
12:29:19 * Orphi shivers
12:30:27 <EvilTerran> ByteString's a funny one, 'cos it's got to type parameter...
12:30:29 <sjanssen> Orphi: use Edison instead of reinventing the wheel
12:31:01 <EvilTerran> s/to/no/
12:31:11 <Orphi> @where edison
12:31:12 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
12:31:53 * Orphi examins
12:32:27 <Orphi> hahahaha... oh. they used fundeps too. :S
12:39:55 <Orphi> well... certainly a lot of stuff to munch through anyway! lol
12:41:58 <Orphi> goodness knows what they do if Haskell' uses ATs rather than FDs... ;)
12:42:49 <Orphi> BTW, is Haskell' likely to "happen" any time soon?
12:43:17 <Igloo> No, depending on what you mean by "soon"
12:43:25 <Japsu> Haskell' is some next-generation version of haskell?
12:43:28 <Orphi> ok. figures...
12:43:38 <Japsu> thank you very much for choosing an ungoogleable name
12:43:46 <sjanssen> Edison will adapt to ATs quite well, I think
12:43:53 <Igloo> haskell-prime is googlable
12:43:53 <sjanssen> Japsu: you're welcome
12:44:03 <Orphi> what are their aims for it anyway? just a minor revision, or major overhaul?
12:44:04 <rahikkala> It's also spelled "Haskell Prime" by some
12:44:07 <Japsu> yay
12:44:09 <Igloo> As I well know, because I am incabale of remembering the URL
12:44:13 <sjanssen> Igloo: is there an ETA on Haskell' right now?
12:44:20 <Igloo> An incapable of typing too, apparently
12:44:24 <Igloo> sjanssen: No
12:44:44 <Orphi> I did look at the Haskell' page, but didn't find much intelligable data
12:44:49 <sjanssen> the original goal was by Haskell Workshop this year, wasn't it?
12:44:59 <Orphi> I'm sure it means something to the peeps who are working on it...
12:45:39 * Igloo thought the original goal was last year's HW
12:45:47 <Igloo> but I might misremember
12:45:53 <sjanssen> heh, maybe you're right
12:45:57 <Orphi> lol... so a normal committee project then? ;)
12:47:54 <Orphi> seriously... if they remove type classes, I'm not going to use it. :P
12:48:15 <sjanssen> Haskell' is a conservative update
12:48:56 <sjanssen> it's supposed to capture the extensions that everybody uses that aren't in the report
12:49:05 <Orphi> right, I see.
12:49:30 <stepcut> I think one original goal of Haskell' was to make a new standard that people in the industry could use, knowing that their code would (in theory) work on multiple compilers
12:49:36 <sjanssen> Haskell' is about the same as -fglasgow-exts
12:49:42 <wolverian> sjanssen, does it change the library?
12:49:48 <Orphi> I gather they're having fun with fundeps...
12:50:09 <sjanssen> fundeps are controversial
12:50:19 <Orphi> wolverian: my personal wish is that they rename 'filter' to 'select'...... but they won't.
12:50:27 <sjanssen> Igloo: do you know why Haskell' is being held up?
12:50:30 <Orphi> fundeps are complicated. heh.
12:50:39 <wolverian> Orphi, I like grep. ;)
12:50:49 <wolverian> but that kind of a thing is very minor.
12:50:52 <rahikkala> No, filter should obviously be called remove-if-not :)
12:51:00 <glguy> find_all
12:51:08 <Orphi> the number of times I've writted filter (\x -> x == ".")
12:51:16 <Igloo> sjanssen: Lack of time, basically, I think
12:51:19 <Orphi> and THEN realised I meant the opposite! >_<
12:51:20 <sjanssen> everyElementOfTheListSuchThatThePredicateIsTrue
12:51:21 <glguy> *actually* find and filter should be merged
12:51:31 <sjanssen> @hoogle ifnd
12:51:31 <lambdabot> No matches found
12:51:33 <sjanssen> @hoogle find
12:51:34 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
12:51:35 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
12:51:35 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
12:51:54 <Orphi> filter f = select (not . f)
12:51:58 <Orphi> how hard is that? :P
12:52:02 <stepcut> Orphi: I dunno.. in audio signal processing, a high-pass filter lets the high's through
12:52:22 <DRMacIver> Nah. Filter should be an infix |
12:52:41 <Orphi> stepcut: it's called a 'filter' because it filters stuff out; it's called 'high-pass' because that's what it does ;)
12:52:43 <sjanssen> @check (\p xs -> listToMaybe (filter p xs :: [Int]) == find p xs)
12:52:45 <lambdabot>  OK, passed 500 tests.
12:53:01 <sjanssen> @scheck (\p xs -> listToMaybe (filter p xs :: [Int]) == find p xs)
12:53:08 <lambdabot> Plugin `small' failed with: IRCRaised Data.ByteString.last: empty ByteString
12:53:18 <glguy> lambdabot is rusting!
12:53:28 <DRMacIver> Bitrust? :)
12:53:28 <stepcut> Orphi: yes but 'high' is get's through the filter, just like "." is what gets through your filter
12:53:44 <stepcut> Orphi: dotPassFilter = filter (== '.')
12:53:56 <Orphi> stepcut: let's put it this way... 'select' works find for the SQL standard :)
12:54:04 <Orphi> *fine
12:54:10 <glguy> only air is supposed to get through an *air filter*
12:54:26 <waern> I'm binding a c library to Haskell that needs libstdc++, should I add -lstdc++ to ld-options in the package.conf file or what's the proper way to handle this?
12:54:26 <sjanssen> pssh, select is for waiting on file descriptors
12:54:45 <waern> I want it to work on all platforms also
12:54:47 <Orphi> what the...? o_O
12:55:26 <Orphi> Smalltalk uses select and reject; never had a problem there.
12:55:46 <sjanssen> hmm, what does lisp call it?
12:55:48 <Orphi> hmm... select, reject, collect, detect... heh
12:56:09 <Orphi> LISP? no idea... I avoid that language :S
12:56:27 <glguy> select doesn't make sense, does it? its the WHERE clause that matches up with filter
12:57:02 <Orphi> well anyway, it's moot; they'll never ever rename such a widely-used function.
12:57:26 <Orphi> although I did see a proposal to remove (.)...!
12:57:39 <sjanssen> that will never happen either
12:57:48 <glguy> (.) = fmap?
12:58:19 <sjanssen> there have been plenty of crackpot proposals for Haskell'
12:58:19 <Orphi> for me, the annoying thing is when you try to use (.), and find that the end function has TWO args, not 1, and then it won't work...
12:58:36 <glguy> f (g x y) = (f .) . g
12:58:36 <shapr> SHAZAM!
12:58:38 <sioraiocht> glguy: no...
12:58:44 <sioraiocht> oh, maybe
12:58:47 <glguy> ?yow
12:58:48 <lambdabot> What I want to find out is -- do parrots know much about Astro-Turf?
12:59:04 <sioraiocht> @src (.)
12:59:05 <lambdabot> (.) f g x = f (g x)
12:59:10 <sioraiocht> @src fmap
12:59:11 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:59:19 <sioraiocht> @src Control.Functor.fmap
12:59:20 <lambdabot> Source not found. stty: unknown mode: doofus
12:59:24 <glguy> > fmap (*2) (+3) 4
12:59:25 <lambdabot>  14
12:59:42 <glguy> > (.) (*2) (+3) 4
12:59:43 <sjanssen> @check \f g x y -> let _ = f :: Int -> Int; _ = g :: Int -> Int -> Int in f (g x y) == ((f .) . g) x y
12:59:44 <lambdabot>  14
12:59:44 <lambdabot>  OK, passed 500 tests.
13:00:01 <sioraiocht> wow
13:00:02 <sioraiocht> lol
13:00:28 <Orphi> OK, I will probably regret this for the rest of my life, but... what is a gadt?
13:00:52 <sjanssen> generalized algebraic data type
13:00:54 <Philippa> it's like an algebraic datatype...
13:01:19 <Philippa> but if it's a parameterised type, the constructors don't have to all be 'general'
13:01:24 <Orphi> ...which leads to "what is an algebraic datatype"...
13:01:29 <Philippa> what data declares
13:01:35 <sjanssen> data Maybe a = Nothing | Just a -- is an ADT
13:01:46 <Orphi> um... ok... what's a non-algebraic datatype? :-}
13:02:04 <Philippa> just a type for data
13:02:20 <Philippa> arguably, foo -> bar isn't a datatype
13:02:29 <sioraiocht> newtype Data a = MkData a
13:02:46 * Orphi feels horribly lost
13:03:05 <sioraiocht> algebraic datatypes can have multiple values, for one
13:03:15 <sioraiocht> Maybe a can be Nothing OR Just a
13:03:25 <sjanssen> http://en.wikipedia.org/wiki/Algebraic_data_type
13:03:27 <lambdabot> Title: Algebraic data type - Wikipedia, the free encyclopedia
13:03:38 <sjanssen> hmm, where's the tinyurl
13:03:49 <sioraiocht> who wrote lambdabot?
13:03:57 <dolio> Maybe that's too short for a tinyurl.
13:04:08 <sioraiocht> ?
13:04:13 <sjanssen> sioraiocht: a bunch of people
13:04:13 <sioraiocht> ?tiny
13:04:14 <lambdabot> Url not valid.
13:04:23 <sjanssen> dons is the maintainer right now
13:04:33 <sioraiocht> ?tiny http://en.wikipdia.org/wiki/Algebraic_data_type
13:04:35 <lambdabot> http://tinyurl.com/2xty8s
13:04:46 <Orphi> "an algebraic datatype is a sum type of product types"
13:04:46 <dolio> lambdabot only automatically produces tinyurls if the link is long enough.
13:04:51 <Orphi> ok, I think I should stop now :S
13:05:13 <sjanssen> Orphi: sum is choice, like the | in data
13:05:55 <sioraiocht> Orphi: it's really not that bad :) just know how to use them
13:06:03 <Orphi> yeah, true...
13:06:13 <sioraiocht> ADTs let you build Data Structures in haskell
13:06:20 <Orphi> so... a GADT is like an ADT - but more general.
13:06:24 <sjanssen> product is like the cartesian product.  Several types stuck in one data structure
13:06:36 <Orphi> sjanssen: finally something makes sense...
13:06:45 <Orphi> <= database nerd
13:06:51 <sioraiocht> e.g. a tree is usually data Tree a = Node a Tree a Tree a | Leaf a | Nil
13:07:11 <sioraiocht> or Node a [Tree a] | Leaf a | Nil
13:07:28 <Orphi> so each constructor is a product, and together they form a sum, which is the complete type...?
13:08:15 <sjanssen> essentially
13:08:16 <dolio> That sounds about right.
13:08:23 <sioraiocht> Orphi: careful with the word constructor, there are type constructors and data constructors =)
13:08:35 <Orphi> ok... so how is a GADT more G than an ADT?
13:08:43 <Orphi> (jees, enought TLAs??)
13:09:06 <Orphi> sioraiocht: just so long as nobody waves kind constructors at me...
13:09:15 <sjanssen> with GADTs, you can write your own types for the constructors
13:09:16 <sioraiocht> yeah about those..
13:09:56 <earthy> Orphi: in an ordinary ADT each constructor has a fixed result type
13:10:17 <earthy> in a generalized ADT, this need not be the same result type
13:10:18 <Orphi> I immediately find myself deeply wondering "and WHY would you want to do this?"
13:10:38 <sioraiocht> earthy: provide an example?
13:10:50 <sioraiocht> I'm kinda lost in the syntax/notational idea of that
13:11:16 <sjanssen> Orphi: http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html has the canonical example
13:11:17 <lambdabot> Title: 7.5. Generalised Algebraic Data Types (GADTs)
13:11:20 <Orphi> actually, it seems there's a lot of really bizzare-sounding type extensions out there - Haskell seems to attract them or something
13:11:28 <Orphi> and I always sit there wondering "WHY is this useful?"
13:11:57 <earthy> well, suppose you have a type Expr a  where a is the set of underlying values
13:12:02 <earthy> the type of values
13:12:07 <Philippa> in fact...
13:12:10 <Philippa> suppose you're writing a monad
13:12:18 <Philippa> and you want to implement it as an interpreter
13:12:19 <earthy> and then you  have expressions that can have booleans and integers
13:12:35 <sioraiocht> yeah, that's pretty awesome, i never knew that about haskell
13:12:38 * sioraiocht is a haskell lowbie.
13:12:38 <Philippa> so you want a datatype with a constructor for Return that take a value for a parameter, one for Bind with the obvious type (which you can do)...
13:12:53 <Philippa> and constructors representing all the new operations on your monad
13:12:56 <earthy> then eg. BoolExpr would take a boolean into an Expr a whereas you *know* beforhand that a can only be Bool
13:13:15 <Philippa> once you've got that, you just write a runMyMonad function that's an ordinary interpreter and bingo! Valid monad implementation
13:13:16 <earthy> now you can document (and require!) that in the ADT itself
13:13:45 <Philippa> (if you really want to be picky, wrap it in a module and don't expose the constructors themselves so nobody can break the monad laws by distinguishing the things that're supposed to be equal)
13:14:08 * Orphi attempts to grok GADTs
13:14:17 <earthy> philippa: that's also a nice one
13:14:30 <sioraiocht> Orphi: where are you from?
13:14:34 <earthy> Orphi: do you understand ADT's?
13:14:49 <earthy> if you do: do you understand parameterised ADT's?
13:15:08 <Orphi> I'm from an unpopular country known as England
13:15:19 <sioraiocht> Orphi: where? =)
13:15:28 <Orphi> the middle of it
13:15:32 <earthy> what's so unpopular about it? :)
13:15:40 * glguy never understood if England was a country or if the UK was the country
13:15:43 <Orphi> apparently you can never get more than 120 miles from the coast... and that's approximately where I am
13:15:50 <glguy> or if Great Britan was a country
13:15:51 <Philippa> glguy: sort of both
13:15:59 <Philippa> it depends on exactly what you mean by country
13:16:01 <Orphi> define 'country' ;)
13:16:11 <sioraiocht> glguy: Great Britain is an ISLAND
13:16:17 <glguy> Like Mexico and The United States of America
13:16:31 <sioraiocht> which contains Scotland, England, and Wales
13:16:36 <earthy> sioraiocht: so northern ireland is not part of Great Britain? :)
13:16:38 <Philippa> however, there is a nation: the United Kingdom of Great Britain and Northern Ireland
13:16:46 <sioraiocht> earthy: No, it's not.
13:16:46 <Igloo> earthy: Correct
13:16:49 <Philippa> earthy: precisely correct
13:16:52 <earthy> ah. okay.
13:16:53 <sjanssen> glguy: you problably mean the United Mexican States
13:16:57 * Orphi wonders what just started here...
13:16:59 <Igloo> earthy: UK = United Kingdom of Great Britain and Northern Ireland
13:17:01 <earthy> nor is the Isle of Man?
13:17:07 <sioraiocht> earthy: No
13:17:09 <earthy> or Guernsey and Jersey and such?
13:17:11 <earthy> good to know
13:17:24 <Philippa> Orphi: whereabouts in the midlands, anyway? There're a few people in Nottingham here
13:17:33 <earthy> (I'll not go into Sealand... :))
13:17:42 * sioraiocht is moving to England in September..
13:17:51 <Orphi> ever heard of Luton?
13:17:55 <sioraiocht> I have
13:18:03 <Philippa> yeah. My ex lives in Harpenden
13:18:05 <Orphi> I don't live in Luton any more :)
13:18:08 <sioraiocht> LOL
13:18:09 <earthy> luton's got an airport, right? :)
13:18:20 <Philippa> yep, I take a train straight through on a regular basis
13:18:21 <Philippa> suits me
13:18:39 <Orphi> heh... why don't we just ASL the whole room? >:-)
13:18:39 <Igloo> earthy: http://en.wikipedia.org/wiki/British_Isles_%28terminology%29 answers these sorts of questions
13:18:40 <lambdabot> Title: British Isles (terminology) - Wikipedia, the free encyclopedia
13:19:03 <earthy> Igloo: thanks. that whole uk, gb, england/wales/etc stuff is just a royal mess
13:20:19 <Orphi> Hi, I'm Orphi, I had my 27th birthday yesterday, and I live just outside Northampton
13:20:28 <Orphi> NB. Northampton is nowhere near Southampton.
13:20:55 <earthy> oh, and you don't grok GADT's. :)
13:21:00 <glguy> so, all english people are british but not all british people are english? :)
13:21:08 <Heffalump> correct.
13:21:09 <Igloo> glguy: Right
13:21:17 <Heffalump> Orphi: it is by American standards.
13:21:29 <Philippa> and the rest are often fed up of having a little english in them
13:21:37 <Orphi> lol @ heffalump
13:21:58 * Heffalump lives near Cambridge, moving to near Bedford soonish (St Neots to be precise), FWIW.
13:22:07 <Orphi> by American standards, Moscow is near London because they're both "outside America"
13:22:18 <Philippa> 24, Nottingham. And no thanks, I'm tired
13:22:27 <Orphi> lolz!
13:22:37 <earthy> hm. 'having a little english in them'... that's a bit... badly put around philppa
13:23:03 <Philippa> earthy: okay, the blunt version - "fed up of being fucked (around) by the english"
13:23:48 <glguy> the queen is english?
13:24:00 <earthy> no, the queen is austrian
13:24:32 <earthy> as is most current royalty in europe, really
13:24:50 <Philippa> interesting question: is she technically a citizen of the UK?
13:24:57 <glguy> queen of england, prince of wales (those are just two of the terms that seem familiar)
13:25:01 <Orphi> bugger Haskell - let's discuss geography and politics :-}
13:25:16 <tibbe> are there any simple parser combinators based on ByteString out there?
13:25:22 <Heffalump> Philippa: does it matter?
13:25:35 <tibbe> I have a really simple grammar I want to parse, it's propably even a regular language
13:25:41 <earthy> tibbe: not really, but you could easily write a bytestring based tokenizer for uulib
13:25:45 <tibbe> but I want it to be fast
13:25:55 <tibbe> earthy, I see, what's uulib?
13:25:58 <earthy> and the uulib parsers are the fastest around
13:26:12 <earthy> http://www.cs.uu.nl/wiki/HUT/
13:26:13 <tibbe> basically I want to match strings with {{ var }} templates in them
13:26:13 <lambdabot> Title: HUT: Haskell Utrecht Tools
13:26:48 <earthy> (to be honest, ask me next week and I might already have done so :))
13:27:04 <Philippa> Heffalump: it might for some unlikely legal purposes
13:27:34 <Philippa> I take it UUlib's improved since the parsec paper?
13:28:13 <Heffalump> Philippa: like what?
13:28:31 <earthy> err... yeah. Doaitse's been working on it quite a bit lately in fact
13:28:51 <Philippa> *nod*
13:28:52 <earthy> he's working towards a new release with some Extra Features
13:29:07 <Philippa> it should do better in theory, certainly - it's got more room to do analyses than parsec has
13:29:13 <Heffalump> did an arrow-based parser library ever get written?
13:29:14 <earthy> (he wants to automatically print grammar diagrams e.g.)
13:29:21 <mux> GHC apparently embeds the modification time of source files somewhere, which makes comparing binaries with md5 to see if they are the same impossible
13:29:28 <mux> can I disable this behaviour somehow?
13:29:36 <earthy> hef: there's some trouble doing that with the uulib parsers
13:29:49 <Heffalump> how come?
13:29:50 <earthy> because at some point the type system just gives up and throws in the towel
13:29:54 <Philippa> hmm. Sounds like he's playing with some of the stuff I wanted to do and concluded I couldn't without some thoroughly evil hacks or an unpleasant interface for the coder
13:29:54 <Heffalump> ah.
13:30:01 <earthy> things get too general
13:30:56 <mux> I wanted to know if ordinary ADTs get desugared into GADTs by GHC
13:31:23 <earthy> and once they're that general, basically the type system can't deduce the types anymore and the interface gets bogged down with type annotations that do nothing to clarify the parser but a lot to make the type system grok what's happening
13:31:27 <Philippa> they're the same thing in Core now, IIRC
13:31:41 <Igloo> mux: Re timestamps, NAFAIK (and I think it's some part of gcc that does it, BICBW; if so then it would be a gcc option you're looking for)
13:31:58 <earthy> (there's some interesting shit that crops up when parsing empty strings... :))
13:32:10 <mux> Igloo: sorry, BICBW?
13:32:17 <earthy> 'but i can be wrong'
13:32:20 <mux> thanks
13:32:30 <mux> I can only see gcc doing this when -g get passed
13:32:37 <mux> maybe stripping the binary would help
13:32:40 <mux> let me try that
13:33:00 <earthy> philippa: I should pressure Doaitse about it when he gets back from Braga
13:33:08 <mux> it does :-)
13:34:03 <mux> and indeed, whether I write this as an ADT or as a GADT, I get the same resulting binary
13:34:06 <mux> thanks
13:36:17 <mux> heh, there's a lot of debugging info in the binaries produced by ghc, stripping the binary makes it go from 1.6MB to 910kB
13:49:35 <shapr> I have a Host. I want a SockAddr. I need a brain or a solution. Does anyone have advice?
13:49:47 <shapr> @djinn Host -> SockAddr
13:49:48 <lambdabot> -- f cannot be realized.
13:49:51 * shapr cries
13:49:54 <Japsu> :<
13:50:10 <shapr> Hyv huomenta Japsu!
13:50:15 <Japsu> moikka shapr
13:50:19 <shapr> mitta?
13:50:31 <Japsu> "what" is "mit", not "mitta" :)
13:51:24 <shapr> whoops
13:51:30 <earthy> what is mitta? :)
13:51:34 <shapr> Min en puhu suomea
13:51:34 <emu> lists are strange creatures.  they have a head, a tail, but no body
13:52:20 <monochrom> Network.BSD.hostAddress gives a HostAddress.  Network.Socket.SockAddr has a constructor SockAddrInet that takes a PortNumber and a HostAddress.
13:52:34 <monochrom> Of course you have to cough up a PortNumber.
13:54:53 <monochrom> Excuse. You also need getHostByName to go from HostName to HostEntry, before you can use hostAddress.
13:54:59 <shapr> monochrom: Thanks, that's pretty much what we came up with.
13:55:08 <shapr> hostAddress . getHostByName
13:55:19 <Japsu> shapr: figured that much already :)
13:55:26 <Japsu> shapr: "moikka" is just a greeting
13:56:01 <dolio> @remember turkourjurbs I was always told when I was young, 'if you want to work in computers you have to be really good at math'. It turns out, no. You need to know math but don't have to be a calculus major.
13:56:01 <lambdabot> Done.
13:56:49 <monochrom> Is there such a thing as "calculus major"?
13:57:04 <dolio> Heh. Not that I'm familiar with.
13:57:06 <glguy> fuck the government and taking 40% of my paycheck
13:57:11 <ddarius> monochrom: Obviously mathematics, but specialize yourself into analysis.
13:57:47 <Cheery> help me, lets say I have instance Show (Blah a) where show (Blah x) = "BLAA" ++ show x
13:57:56 <earthy> glguy: so little? lucky bastard.
13:57:58 <Cheery> it teases me about thisone
13:58:12 <nominolo> > let f `pfJoin` g = \x -> maybe (g x) id (f x); f1 1 = Just 1; f1 _ = Nothing; f2 3 = Just 0; f2 _ = Nothing in map (f1 `pdJoin` f2) [1,2,3]
13:58:12 <Cheery> @src List
13:58:13 <lambdabot>   Not in scope: `pdJoin'
13:58:13 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:58:28 <nominolo> > let pfJoin f g = \x -> maybe (g x) id (f x); f1 1 = Just 1; f1 _ = Nothing; f2 3 = Just 0; f2 _ = Nothing in map (f1 `pdJoin` f2) [1,2,3]
13:58:29 <Cheery> ...
13:58:29 <lambdabot>   Not in scope: `pdJoin'
13:58:32 <glguy> I'm a 40% slave aparently
13:58:35 <nominolo> > let pfJoin f g = \x -> maybe (g x) id (f x); f1 1 = Just 1; f1 _ = Nothing; f2 3 = Just 0; f2 _ = Nothing in map (f1 `pfJoin` f2) [1,2,3]
13:58:36 <lambdabot>   add an instance declaration for (Num (Maybe t))
13:58:42 <Cheery> @src Data.List
13:58:42 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:58:47 <ddarius> ndm: Here? I started at your paper yesterday and there were some things that struck me immediately.
13:59:03 <monochrom> I have not heard of "calculus major" or "lambda calculus major" or "web major".
13:59:10 <earthy> actually, if I do the math, I pay about 29 percent
13:59:30 <earthy> but the going rate for the top slice is 41.somesuch
13:59:35 <Cheery> @src []
13:59:35 <lambdabot> data [] a = [] | a : [a]
13:59:49 <stranger> Is there a straightforward way to figure out the space complexity of a Haskell function?
13:59:59 <earthy> that is my top slice. my gf earns more, her top slice gets taxed at 43.somesuch, and if you earn even more it goes up to 52ish
14:00:26 <monochrom> stranger: Yes, to me.
14:00:36 <stranger> How?
14:00:41 <Laney> What should I be googling for if I want to keep the state of two things at once? (A stack and memory in this case)
14:00:55 <monochrom> I have not written it up.
14:01:05 <earthy> Laney: Control.Monad.ST (stack,heap)
14:01:12 <earthy> errr...
14:01:20 <ddarius> Laney: Depending on the nature of the program use State(T) with a pair or stack two StateTs or use ST.
14:01:31 <earthy> err. State, not ST
14:01:35 <Cheery> yay! found it out myself
14:01:38 * earthy always confuses those
14:02:08 <Laney> Ah a pair, cunning
14:02:20 <glguy> If you use a record
14:02:21 <Cheery> *CSSGen> generate $ textAlign Center
14:02:21 <Cheery> "text-align:center;"
14:02:24 <glguy> you can say things like:
14:02:28 <glguy> gets stack
14:02:32 <glguy> gets memory
14:02:42 <glguy> modify (\s -> s { memory = x })
14:05:09 <Laney> Thanks glguy, I'll check it out
14:07:13 <nominolo> > let pfJoin f g = \x -> maybe (g x) Just (f x); f1 1 = Just 1; f1 _ = Nothing; f2 3 = Just 0; f2 _ = Nothing in map (f1 `pfJoin` f2) [1,2,3,4]
14:07:15 <lambdabot>  [Just 1,Nothing,Just 0,Nothing]
14:07:33 <nominolo> ^ is this a common way to define partial functions?
14:07:53 <monochrom> Yes
14:08:17 <nominolo> k, any standard namings for "pfJoin"
14:08:19 <ddarius> pfJoin = mplus
14:08:24 <nominolo> oh
14:08:49 <ddarius> Or a variation thereo
14:08:50 <ddarius> f
14:08:54 <nominolo> > let pfJoin f g = \x -> maybe (g x) Just (f x); f1 1 = Just 1; f1 _ = Nothing; f2 3 = Just 0; f2 _ = Nothing in map (f1 `mplus` f2) [1,2,3,4]
14:08:55 <lambdabot>   add an instance declaration for (MonadPlus ((->) a))
14:09:17 <ddarius> I forgot that you still need to lift it to functions.
14:09:32 <ddarius> pfJoin f g x = f x `mplus` g x
14:10:10 <nominolo> > let pfJoin f g = f x `mplus` g x f1 1 = Just 1; f1 _ = Nothing; f2 3 = Just 0; f2 _ = Nothing in map (f1 `pfJoin` f2) [1,2,3,4]
14:10:10 <lambdabot>  Parse error
14:10:21 <nominolo> > let pfJoin f g = f x `mplus` g x; f1 1 = Just 1; f1 _ = Nothing; f2 3 = Just 0; f2 _ = Nothing in map (f1 `pfJoin` f2) [1,2,3,4]
14:10:22 <lambdabot>   Not in scope: `x'
14:10:35 <nominolo> > let pfJoin f g = \x -> f x `mplus` g x; f1 1 = Just 1; f1 _ = Nothing; f2 3 = Just 0; f2 _ = Nothing in map (f1 `pfJoin` f2) [1,2,3,4]
14:10:36 <lambdabot>  [Just 1,Nothing,Just 0,Nothing]
14:11:15 * nominolo needs a haskell typechecker plugin for his irc-client
14:11:17 <abz> ?users
14:11:18 <lambdabot> Maximum users seen in #haskell: 337, currently: 322 (95.5%), active: 51 (15.8%)
14:11:33 <ddarius> :t foo
14:11:35 <lambdabot> Not in scope: `foo'
14:11:48 <abz> :t foo :: Int
14:11:51 <lambdabot> Not in scope: `foo'
14:11:52 <ddarius> If you don't want to flood the channel /msg lambdabot
14:12:16 <monochrom> I need a computer in my brain.
14:12:42 <xerox> Bored of calculating? (:
14:12:59 <monochrom> Bored of making mistakes.
14:15:01 <sciolizer> @type everywhere $ mkT id
14:15:03 <lambdabot>     Couldn't match expected type `forall a. (Data a) => a -> a'
14:15:03 <lambdabot>            against inferred type `a -> a'
14:15:27 <sciolizer> ??
14:15:35 <dolio> @type everywhere
14:15:37 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
14:15:49 <dolio> @type everywhere (mkT id)
14:15:51 <lambdabot>     Ambiguous type variable `b' in the constraint:
14:15:52 <lambdabot>       `Typeable b' arising from use of `mkT' at <interactive>:1:12-17
14:16:24 <dolio> sciolizer: $ doesn't play nice with higher-ranked polymorphic functions yet.
14:16:24 <sciolizer> dolio: ok, Thanks. I guess I get into the habit of thinking that $ is syntax.
14:16:50 <dolio> I think the next ghc release might fix it? 6.8 that is.
14:16:57 * xerox wanders off to bed - stomachache--
14:16:59 <dolio> With some black magic.
14:17:48 <Heffalump> really?
14:17:56 <Heffalump> doesn't it require impredicative types?
14:18:05 <Heffalump> I didn't think it was going through that radical a change.
14:18:47 <dolio> Didn't 6.6 already include some sort of impredicative extension?
14:21:44 <dolio> Section 7.4.9 of the latest docs, or 7.5.8 of the current ones...
14:23:47 <Heffalump> hmm, ok
14:24:28 <dolio> I must admit, though, I don't know what else goes into making $ work nicely with that.
14:25:24 <ddarius> Impredicative types should be all that's necessary, albeit I'm not sure if it would require annotations.
14:36:39 <dino-> Does anyone know offhand how the * field width flag works for Text.Printf.printf ?
14:37:41 <glguy> > printf "%*d" (3 :: Int) (5 :: Int ) :: String
14:37:43 <lambdabot>  "  5"
14:37:56 <glguy> > printf "%0*d" (3 :: Int) (5 :: Int ) :: String
14:37:57 <lambdabot>  "005"
14:38:12 <dino-> Ah, I didn't get that it gets passed with the rest of the data being formatted.
14:38:13 <dino-> cool
14:38:54 <dino-> Saving you from having to ++ show a lot of nonsense into the format string.
14:39:23 <waern> does anyone know the proper way to bind libraries to Haskell that need libstdc++?
14:40:22 <waern> so that users don't have to add -lstdc++ to the ghc command line themselves
14:40:41 <thedward> ?seen sjannsen
14:40:41 <lambdabot> I haven't seen sjannsen.
14:41:12 <thedward> ?seen sjanssen
14:41:12 <lambdabot> sjanssen is in #haskell-soc, #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 3m 7s ago.
14:41:13 <glguy> "I want to apologize in advance; your midterms (and hw3's) are not yet all graded because of my lack of time management, and, to some extent, because of the astonishing creativity of some of the answers.  I will return them by tuesday."
14:41:13 <dino-> glguy: Thank you!
14:42:33 * glguy hopes his midterm doesn't qualify as "astonishing creativity"
14:43:24 <ddarius> glguy: Is that a bad thing?
14:43:58 <glguy> it is if he's being sarcastic
14:44:18 <glguy> I don't remember the questions being so complicated that you'd want to use such an answer
14:44:30 <thedward> sjanssen: in xmonad, is there a reason that numlockMask is KeySym instead of KeyMask? In trying to further cleanup the X11 stuff, it seems destined for those types to be incongruent.
14:44:38 <glguy> in my estimation, an astonishingly creative person is one who didn't know the answer but had lots to say
14:45:00 <Cheery> damn
14:45:07 <Cheery> the selector -field in CSS2 is stupid
14:45:21 <Cheery> what is the actual grammar for it?
14:45:26 <TSC> Creativity could just be an unexpected interpretation of the question
14:49:27 <sjanssen> thedward: xmonad is probably wrong, feel free to change it
14:50:38 <hpaste>  kc5tja pasted "Parse produces truncated result." at http://hpaste.org/1188
14:51:05 <kc5tja> In working some more on CUT, I've been trying to debug a problem that's been plaguing me for a few weeks.
14:51:14 <kc5tja> I can't seem to work around it either.
14:51:37 <kc5tja> I'm using unfoldr to recursively parse a list of tokens.
14:51:38 <thedward> sjanssen: just making sure. I'm still figuring out all this stuff.
14:52:44 <kc5tja> However, giving an input [Bringup "foo", Test "bar", Takedown "foo", Bringup "baz", ...], everything from Bringup "baz" on is discarded.
14:52:47 <kc5tja> Any ideas why?
14:53:04 <kc5tja> There is nothing obvious from the code that suggests this should be the case.
14:54:52 <TSC> thedward: I (Chris Mears) just sent my patch, and then read your suggestion.  It seems like a good idea; if my patch works, then we can clean it up using your idea
14:55:08 <TSC> I especially like not having to change X11-extras, because my patch to that is ugly
14:57:14 <tsp> what on earth is a  ?
14:57:52 <sjanssen> > length " ?"
14:57:53 <lambdabot>  13
14:58:04 <sjanssen> > " ?"
14:58:06 <lambdabot>  "\193\224\237\228\251 \204\238\241\234\226\251?"
14:59:00 <Saizan> kc5tja: from your code the rest of the [L.CutToken] is put as the children of Bringup
14:59:53 <Cheery> I'd want to turn a number into a string representing the number as a hex number.
15:00:01 <tsp> I think thats a russian something or other
15:00:10 <tsp> its the name of a folder on my hard drive
15:00:31 <Cheery> is there a function which does what I specified?
15:00:55 <Saizan> ?hoogle showHex
15:00:55 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
15:01:04 <TSC> Or printf, maybe?
15:01:10 <kc5tja> Saizan: No, the children (parse ts') are.
15:01:10 <Cheery> ie: f 10 should give "A", etc.
15:01:40 <sjanssen> > showHex 81231 ""
15:01:42 <lambdabot>  "13d4f"
15:02:50 <sjanssen> > showHex (-81231) ""
15:02:51 <lambdabot>  Exception: Numeric.showIntAtBase: applied to negative number -81231
15:03:58 <dolio> Everybody knows hexadecimal numbers can't be negative. :)
15:05:53 <dolio> > showSigned (showHex) 0 (-81231) ""
15:05:55 <lambdabot>  "-13d4f"
15:13:35 <sorear> hi!
15:22:18 <Cheery> how could I simply get my number bounded between 0 and 255?
15:22:32 <sorear> ?
15:22:38 * sorear reads log...
15:23:22 <Saizan> you can use a Word8 to enforce that
15:23:23 <sorear> like `mod` 256?
15:23:30 <sorear> or Word8 :)
15:23:39 <Cheery> nah, I want to enforce.
15:23:49 <Gn> hi!
15:23:52 <sorear> hello!
15:23:55 <LordBr4in> hmmm is there a showHex?
15:24:00 <sorear> yeah!
15:24:04 <LordBr4in> :hoogle showHex
15:24:12 <sorear> > showHex 25 ""
15:24:13 <lambdabot>  "19"
15:24:18 <sorear> > showHex 255 ""
15:24:20 <lambdabot>  "ff"
15:24:25 <Gn> anyone use hat and  quick check ?
15:24:36 <Gn> i need an example :(
15:24:37 <sorear> nobody uses hat afaict
15:24:52 <sorear> quickcheck everyone but me knows how to use...
15:25:01 <sorear> ?check 2 + 2 == 4
15:25:03 <lambdabot>  OK, passed 500 tests.
15:25:17 <sorear> ?check \x -> x + (0::Int) == x
15:25:18 <lambdabot>  OK, passed 500 tests.
15:25:40 <sorear> ?check \x -> x == reverse (reverse (x :: [I]))
15:25:41 <lambdabot>  OK, passed 500 tests.
15:25:52 <Gn> ohhh .. thanks
15:25:58 <Saizan> I?
15:26:05 <sorear> type I = Int
15:26:16 <Laney> ?check \x y -> x + y == y + x
15:26:17 <lambdabot>  Add a type signature
15:26:17 <sorear> it's in one of lambdabot's quickcheck modules
15:26:25 <Saizan> oh, k
15:26:28 <Laney> bah
15:26:40 <LordBr4in> i asked about showHex for Cheery's benifet
15:26:58 <sorear> @uses
15:26:59 <lambdabot> Maximum users seen in #haskell: 337, currently: 314 (93.2%), active: 51 (16.2%)
15:27:02 <sorear> @seen
15:27:09 <LordBr4in> > let f x = showHex x "" in f 10
15:27:11 <lambdabot>  "a"
15:27:29 <sorear> > ($"") . showHex $ 10
15:27:31 <lambdabot>  "a"
15:27:41 <LordBr4in> oh sjanssen already told him
15:28:05 <Laney> ?check \(x::Int) (y::Int) -> x + y == y + x
15:28:06 <lambdabot>  Parse error in pattern
15:28:12 <Laney> :(
15:29:41 <Gn> do yuo know how install a package like hmake in ghc 6.6 for windows?
15:29:48 <dolio> @scheck 2 + 2 == 4
15:29:49 <lambdabot>   Completed 1 test(s) without failure.
15:29:52 <Gn> what i need?
15:30:18 <LordBr4in> ?scheck 1 == 2
15:30:19 <lambdabot>   Failed test no. 1. Test values follow.:
15:30:40 <LordBr4in> s for single?
15:30:41 <thedward> TSC: I responded your patch with a patch. Thanks for spotting the XSERVER64 thing, again. I was being silly.
15:30:53 <dolio> s for small.
15:30:55 <TSC> Yeah, I just saw the mail
15:31:52 <Gn> help:do yuo know how install a package like hmake in ghc 6.6 for windows?
15:31:57 <Saizan> Gn: i couldn't make it compile on windows, you'll need something like msys or cygwin however
15:32:00 <Igloo> thedward/TSC: Does the most recent patch to the libraries list do wht the mail suggests?
15:32:25 <Gn> ok, i have cywin ? and what i do ?
15:32:49 <Igloo> thedward/TSC: Ah, no, it doesn't; it changes uses of Modifier rather than the type synonym, right? So it shouldn't be applied?
15:33:21 <thedward> TSC: I just now sent off another one. That changes Modifier to be a synonym of CUInt
15:33:31 <sorear> Igloo: I've found a way to panic GHC 6.4.2.  Should I bother reporting it?
15:33:37 <thedward> (to be applied instead off, instead of in addition to the other one)
15:33:41 <sorear> Igloo: given that it does not affect 6.6 or HEAD
15:33:46 <TSC> Igloo: The good one is called "Turn off _SERVER64 and change Modifier to CUInt"
15:33:50 <Igloo> sorear: No, no point
15:34:00 <sorear> Ok.
15:34:47 <chessguy> ?seen procyon112
15:34:48 <lambdabot> I saw procyon112 leaving #haskell 17h 17m 3s ago, and .
15:34:57 <chessguy> hi all
15:35:01 <sorear> hi!
15:35:26 <Saizan> Gn: you can try following this http://www.cs.york.ac.uk/fp/hmake/#install inside your cygwin prompt (aka sh), but why do you need hmake? to compile hat?
15:35:27 <lambdabot> Title: hmake - a make tool for Haskell programs
15:35:33 <chessguy> sorear: how come you're never on here when i leave work, and you're always here when i get home? :)
15:35:52 <Gn> Saizan
15:36:02 <Gn> yes , is for
15:36:07 <Gn> hat
15:36:11 <sorear> chessguy: This part of my schedule is very rigid
15:36:30 <sorear> chessguy: HS lets out at 2:25PM every single day
15:36:43 <chessguy> ?localtime sorear
15:36:44 <lambdabot> Local time for sorear is Thu Mar 29 15:34:41 2007
15:36:50 <chessguy> ah
15:37:07 <Saizan> #haskell: is hat usable?
15:37:19 <chessguy> Saizan: not from what i've heard
15:37:30 <Saizan> thought so..
15:37:46 * sorear greps the logs for 'time for chessguy'
15:37:56 <sorear> @goo GHCI debugger hat ndm
15:37:59 <lambdabot> http://neilmitchell.blogspot.com/2007_01_01_archive.html
15:37:59 <lambdabot> Title: Neil Mitchell's Haskell Blog: January 2007
15:38:35 <sorear> "Debugging and crying" - is the post I was looking to reference
15:38:53 <sorear> that's what ndm thinks of the state of the hat
15:40:12 <Saizan> ndm is also the only source of a win32 hat binary afaik
15:41:47 <Igloo> thedward, TSC: OK, applied, thanks!
15:42:01 <Gn> ummmm , you have a very closed comunity .... :D
15:42:29 <Igloo> tight but open, I would say
15:43:19 <chessguy> ?localtime
15:43:20 <lambdabot> Local time for chessguy is Thu Mar 29 18:38:32
15:43:30 <chessguy> sorear, no more grepping needed :)
15:44:01 <sioraiocht> ?localtime
15:44:02 <lambdabot> Local time for sioraiocht is 2007-03-29 18:41:53 -0400
15:44:14 * sioraiocht pets lambabot.
15:44:18 <sioraiocht> err
15:44:31 * sioraiocht pets lambdabot. [tab completion is your friend]
15:44:59 * sorear not uncommonly sends @-commands to lamby
15:45:08 <sorear> tab completion is my frend
15:45:29 <qwr> fiend?
15:46:02 <sorear> I also often find myself trying to use > ... in queries :)
15:46:11 <sioraiocht> hahaha
15:46:47 <sioraiocht> I often have some calc I wanna do cuz someone asks me in a nother channel and I try > <haskell-expr> and it's really depressing when I get no response, lol
15:47:42 <chessguy> i'm always trying to tab-complete long words that aren't nicknames
15:47:44 <Saizan> that points to the ultimate quest of using lambdabot as an irc client
15:48:05 <sioraiocht> chessguy: me too
15:48:31 <jimcrayne> hmmmm yeah, irc clients should implement vims ctrl-p
15:48:31 <sorear> emacs can do that
15:48:32 <sioraiocht> Saizan: I love it
15:48:54 <emu> abbrev-expand works in any buffer
15:48:57 <sorear> unfortunately M-TAB isn't as useful as it might sound
15:49:16 <sorear> dabbrev-expand works in any buffer too, and is IME more useful
15:49:21 <emu> yea that
15:49:35 <sorear> implemen M-TAB gives 11 completions!
15:49:42 <emu> i hit emacs keybindings in Irssi all the time, i really should switch
15:49:50 * sorear <3 erc
15:50:21 <sorear> implemen M-/ dtrts
15:50:23 <emu> has ERC's support for multiple windows improved? it was ok the last time i tried a few years ago.
15:51:29 * sorear usually doesn't use windows
15:51:51 <sorear> full screen buffer, C-c C-@ quick switching
15:53:15 <emu> ok channel buffers i mean
15:53:23 <nominolo> C-c C-@ is quick? ;)
15:53:30 <emu> C-@ is ctrl-spc
15:53:30 <sorear> yeah
15:53:36 <nominolo> oh
15:53:37 <nominolo> ok
15:53:41 <emu> that's quick=)
15:53:48 <nominolo> i was thinking of C-S-2
15:53:59 <sorear> emu: yeah, I'm on a half dozen channels
15:54:13 <sorear> emu: C-c C-@ takes me to the most recently active one
15:54:17 <emu> i used to be on 3 irc servers and a dozen channels. i've pruned it a bit
15:54:21 <emu> yea that i remember.
15:54:22 <sorear> emu: or back to my work if none are active
15:54:45 <sorear> emu: and my modeline lists all active chans...
15:54:55 <emu> istr issues with kill/yank in erc, does that cause any problems
15:55:07 <emu> yea i had that setup too.  irssi numbers things for quick access: alt-#
15:55:11 * sorear checks
15:55:24 <sioraiocht> is there an implementation of euler's phi function in haskell?
15:55:30 <emu> also does it support autoident to nickserv
15:55:38 <sioraiocht> meh, i'll do it myself
15:55:44 <sorear> yeah it autoids
15:55:59 <emu> maybe i will just install it now then
15:57:20 <sioraiocht> is there an Integer version of length?
15:57:22 <sioraiocht> @src length
15:57:23 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:57:35 <sioraiocht> @src Data.List.length
15:57:36 <lambdabot> Source not found. Where did you learn to type?
15:57:37 <resiak> @type genericLength
15:57:40 <lambdabot> forall b i. (Num i) => [b] -> i
15:57:43 <sioraiocht> thanks
15:58:03 <sioraiocht> hrm, is that in the prelude?
15:58:11 <resiak> @index genericLength
15:58:11 <lambdabot> Data.List
15:58:16 <sioraiocht> thanks =)
15:59:54 <sioraiocht> ?check
15:59:55 <lambdabot>  Parse error
16:00:01 <sioraiocht> @help
16:00:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:00:06 <sioraiocht> @help check
16:00:07 <lambdabot> check <expr>
16:00:07 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
16:00:34 <TomMD> > check True
16:00:35 <lambdabot>   Not in scope: `check'
16:00:47 <chessguy> @check True
16:00:48 <lambdabot>  OK, passed 500 tests.
16:01:16 <TomMD> I think 500 is excessive given the number of unique inputs to that test.
16:01:49 <TomMD> @check x < 0
16:01:49 <lambdabot>   Not in scope: `x'
16:02:00 <xs> @scheck True
16:02:01 <resiak> @check (<0)
16:02:01 <lambdabot>   Completed 1 test(s) without failure.
16:02:03 <lambdabot>  Add a type signature
16:02:06 <sorear> emu: http://tunes.org/~nef/logs/haskell/07.03.17, scroll down to 23:12
16:02:06 <TomMD> @check \x -> x < 0
16:02:07 <lambdabot>  Add a type signature
16:02:08 <resiak> @check (<(0::Int))
16:02:09 <lambdabot>  Falsifiable, after 0 tests: 0
16:02:20 <TomMD> I see
16:02:27 <sorear> emu: that the kind of yank problem you wer having?
16:02:29 <xs> TomMD, @check samples. @scheck checks to a certain depth
16:02:50 <sioraiocht> check let phi = genericLength [x | x <- [1..n-1] gcd x n == 1] in (\ x -> 2^phi x `mod` x == 1 `mod` x)
16:02:57 <sioraiocht> ?check let phi = genericLength [x | x <- [1..n-1] gcd x n == 1] in (\ x -> 2^phi x `mod` x == 1 `mod` x)
16:02:58 <lambdabot>   Not in scope: `n'
16:03:17 <sioraiocht> ?check let phi n = genericLength [x | x <- [1..n-1] gcd x n == 1] in (\ x -> 2^phi x `mod` x == 1 `mod` x)
16:03:18 <lambdabot>   Not in scope: `x'
16:03:32 <sioraiocht> ...i hate you, lambdabot
16:03:37 <resiak> you're missing a comma in the list comprehension
16:03:41 <sioraiocht> thanks
16:03:47 <emu> hehe
16:03:48 <sioraiocht> ?check let phi n = genericLength [x | x <- [1..n-1], gcd x n == 1] in (\ x -> 2^phi x `mod` x == 1 `mod` x)
16:03:49 <lambdabot>  Add a type signature
16:04:07 <sioraiocht> ?check let phi n = genericLength [x | x <- [1..n-1], gcd x n == 1] in (\ x -> 2^phi x `mod` x == 1 `mod` x) :: Integer -> Integer
16:04:08 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Bool'
16:04:18 <sioraiocht> ?check let phi n = genericLength [x | x <- [1..n-1], gcd x n == 1] in (\ x -> 2^phi x `mod` x == 1 `mod` x) :: Integer -> Bool
16:04:20 <lambdabot>  Exception: divide by zero
16:04:24 <sioraiocht> ...orly?
16:04:35 <xs> > 1 `mod` 0
16:04:37 <lambdabot>  Exception: divide by zero
16:04:37 <sioraiocht> does ?check start at 0?
16:04:41 <sioraiocht> bummer
16:04:54 <resiak> check chooses a bunch of values
16:05:00 <xs> no, it doesn't start anywhere. afaik, it randomly samples the types involved.
16:05:11 <sioraiocht> I'll just do this myself, my haskell skills aren't l33t enough to subject you all to it =)
16:05:20 <resiak> you can /msg the bot
16:05:25 <sioraiocht> resiak, thakns
16:05:47 <xs> sioraiocht, you can restrict the domain of the test using the ==> operator.
16:06:05 <sioraiocht> xs: example?
16:08:15 <resiak> ?check \x -> (x > 0 ==> abs x == (x :: Int))
16:08:17 <lambdabot>  OK, passed 500 tests.
16:08:32 <sioraiocht> resiak: THANKS
16:08:35 <sioraiocht> err
16:08:35 <sioraiocht> no caps
16:08:55 <resiak> sioraiocht: THAT@S OKAY
16:09:18 * sioraiocht is a disaster, today.
16:12:26 <chessguy> just be glad you can take a sentence like that and put ", today." the end of it
16:12:43 <sioraiocht> hahah
16:18:09 <chessguy> hm, slow night around here
16:18:14 <sorear> @yow
16:18:15 <lambdabot> Once upon a time, four AMPHIBIOUS HOG CALLERS attacked a family of
16:18:15 <lambdabot> DEFENSELESS, SENSITIVE COIN COLLECTORS and brought DOWN their PROPERTY
16:18:15 <lambdabot> VALUES!!
16:18:48 * sorear verbs!
16:23:10 <sioraiocht> wtf?
16:23:20 <resiak> @yarr
16:23:21 <lambdabot> Ahoy mateys
16:23:40 <chessguy> ?vera wtf
16:23:41 <lambdabot> *** "wtf" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
16:23:42 <lambdabot> WTF
16:23:42 <lambdabot>      What / Where / Who / Why The Fuck (telecommunication, Usenet, IRC)
16:23:42 <lambdabot>  
16:24:13 <sioraiocht> ?vera stfu
16:24:13 * chessguy washes LB's mouth out with soap
16:24:15 <lambdabot> No match for "stfu".
16:24:21 <sioraiocht> LAME
16:24:30 <chessguy> ?vera rtfm
16:24:30 <sioraiocht> ?vera omg
16:24:31 <lambdabot> *** "rtfm" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
16:24:32 <lambdabot> RTFM
16:24:32 <lambdabot>      Read The Flaming / Fucking Manual (telecommunication-slang, Usenet,
16:24:32 <lambdabot>      IRC)
16:24:32 <lambdabot>  
16:24:33 <lambdabot> *** "omg" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
16:24:35 <lambdabot> OMG
16:24:37 <lambdabot>      Object Management Group (IBM, HP, DEC, Tandem, Sun, org.)
16:24:39 <lambdabot>  
16:24:46 <sioraiocht> hahah orly?
16:25:27 <procyon112> @seen chessguy
16:25:28 <lambdabot> chessguy is in #haskell, #ghc, #haskell-overflow, #figs, #haskell-blah and #ai. I last heard chessguy speak 57s ago.
16:25:31 <chessguy> procyon112!
16:25:37 <sorear> hi procyon112!
16:25:38 <procyon112> yo!  Get my email?
16:25:47 <procyon112> hey sorear!
16:25:56 <chessguy> i did. looks like a great list. though i'm not sure what some of the things i "own" are
16:26:29 <procyon112> hehe.  You were working on the GUI and Configuration, so I said you "own" them...
16:26:44 <chessguy> that's fine. what's "pluggable fitness"?
16:27:10 <procyon112> Being able to specify a fitness function.
16:27:32 <chessguy> isn't that how it is now?
16:28:27 <procyon112> I'm not sure.. I haven't looked at the (official) code in a couple days.  If so, congratulations!  Check it off the list! ;)
16:28:35 <chessguy> haha
16:28:43 <chessguy> that part hasn't changed in weaks
16:28:51 <chessguy> part of the specification of a problem is a fitness function
16:29:17 <procyon112> Well, I remembered population was hardcoded, so I just assumed that the fitness was too.
16:29:33 <chessguy> nope
16:29:55 <chessguy> are you going to be hacking on my code tonight? i'd like to work on module'izing it
16:30:51 <procyon112> Probably not tonight.  I'm still working in my own sandbox, but I've got all the hard stuff done.
16:31:08 <chessguy> cool!
16:31:52 <chessguy> we could also grab a wiki page to put that list on, so we could have a central location to update what features are being worked on
16:31:58 <procyon112> I have a function that, given a polymorphic type, will return all the primitive nodes that can be an instance of that type... that's the root of a polymorphic, strongly type GP tree generator right thar that is.
16:32:22 <chessguy> sweet!
16:33:26 <procyon112> Mixing your list style node with mine should be trivial, as your nodes are all monotypic, they will just slip through the typechecker trivially, so I don't anticipate any issues combining the various node types.
16:34:43 <chessguy> sounds great
16:36:42 <procyon112> Lists, etc probably don't need to be primitives right now.  Once I add my stuff, they can be defined church-style.  Somone else can mess with native lists if they really want them.
16:37:17 <chessguy> so what primitive types would we have now?
16:37:34 <sorear> procyon112: ooh?  Note that church lists require rank-2 types or no types at all.
16:37:58 <sorear> procyon112: what do you think of explicit typing?
16:38:16 * sorear is just too curious, not intensionally pressurign
16:38:40 <procyon112> sorear: cons x xs = \c n -> c x (xs c n)  -- Should typecheck just fine in my ML style checker... although I haven't mucked with it yet.
16:39:36 <sorear> well, cons is just fine. it's the folds where things get messy.
16:40:21 <sorear> @ty \list -> (list (&&) True, list (+) 0) -- you do have both bool and int, right?
16:40:24 <lambdabot>     No instance for (Num Bool)
16:40:24 <lambdabot>       arising from use of `+' at <interactive>:1:31-33
16:41:03 <procyon112> sorear: nil = \x y -> x; foldr f c l = l f c; null l = l (const $ const false) true; map f l = \c n -> l n (\x xs -> c (f x) xs)
16:41:17 <procyon112> ^^^ Syntax only a Genetic Program could love :)
16:41:25 <sorear> procyon112: so far so good.
16:42:16 <sorear> procyon112: now fold the same list with two differently-typed accumulators
16:42:25 <procyon112> sorear: no bool.  true = const; false = const id;
16:42:27 <chessguy> procyon112: what basic types are supported by your evaluator, and how hard is it to add a new one?
16:44:09 <procyon112> chessguy: I added Int and Real.  Bool can be trivially defined as I just did.. and they act as their own if.. eg, ifelse c x y = c x y -- c, being either const or const id will execute the appropriate branch.
16:44:19 <procyon112> Adding new ones is easy.
16:44:41 <sorear> procyon112: real eh?  which lib?
16:44:53 <procyon112> I just used double for reals.
16:45:01 * sorear thinks reals ought to be in core
16:46:11 <sorear> @seen ndm
16:46:12 <lambdabot> ndm is in #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard ndm speak 6h 26m 51s ago.
16:46:38 <procyon112> sorear: The list thing works, because lists can be defined in terms of their fold (church gave some weird proofs on that That I have no idea what they mean) so We just define a function that is fold, ie, the one I gave above.
16:47:00 <procyon112> sorear: The only problem with that is "tail
16:47:13 <chessguy> procyon112: i'm assuming that adding a type is more than just changing the data Exp = ...
16:47:16 <procyon112> tail is really slow complexity wise
16:47:33 <sioraiocht> @src tail
16:47:34 <lambdabot> tail (_:xs) = xs
16:47:34 <lambdabot> tail []     = undefined
16:47:43 <sioraiocht> procyon112: why?
16:47:46 <sorear> @ask ndm Which is more important - having a current repo, or a working repo? (IE, should I wait to push my changes?)
16:47:47 <lambdabot> Consider it noted.
16:47:54 <procyon112> chessguy: Adding a type is adding it to data, and adding it to the type checker.
16:48:07 <sorear> procyon112: if you allow equirecursive types, tail can be made very fast
16:48:41 <procyon112> sioraiocht: Because defining in terms of fold doesn't give easy access to tail.  Try writing tail using only foldr.
16:49:15 <sorear> make lists fix a. (Maybe (a, t)) == fix a. ((a -> t -> r) -> r -> r
16:49:21 <procyon112> chessguy: adding it to Exp, rather, and adding a pattern match to the typechecker.
16:49:38 <sorear> then tail is naturally \list -> list const ERROR
16:49:48 <sorear> head = \list -> list (const id) ERROR
16:50:32 <sorear> foldr = \f z list -> list (\l' v -> f v (foldr f z l')) z
16:50:59 * sorear knows this from his Unlambda experience
16:51:27 <dmead> point.
16:51:33 <procyon112> sorear: That forces us to put error handling into the evaluator... and in GP, my hypothesis is that trusting randomly generated code to always end on the base case properly is probably not so realistic.  I'd rather give the programs easy access to foldr, and make them work to try to walk off the list.
16:51:51 <sorear> procyon112: huh?
16:51:56 <sorear> procyon112: this won't crash
16:52:14 <procyon112> sorear:  No.. it's not going to crash, but we are worried about more than just crashes.
16:52:18 <chessguy> procyon112: what function at http://hpaste.org/1174 are you calling the typechecker?
16:52:29 <sorear> procyon112: it might _|_, but if you restrict yourself to total programs you're losing a lot more than just error handling
16:52:37 <sorear> procyon112: church-turing thesis
16:53:03 <sorear> procyon112: any system which cannot express NT'ing progs, canot express some Ting prongs
16:53:25 <dcoutts> sorear: how many useful non-total programs do you know of?
16:53:39 <procyon112> chessguy: typeof returns the type of a tree.  findTypeMatch matches takes a type and returns a list of primitives.
16:53:52 <sorear> dcoutts: ghci
16:54:11 <dmead> ( 1 +
16:54:14 <dmead> is a non total program
16:54:14 <dmead> right?
16:54:19 <sorear> dcoutts: bash, yhi, ... any tc prog
16:54:27 <sorear> dmead: no, that's just plain wrong
16:54:31 <dmead> :<
16:54:41 <sorear> dmead: it makes demons fly out of your nose at compile time
16:54:47 <dmead> poo
16:55:05 <dcoutts> sorear: but those are just interpreters for other turing complete languages, that doesn't really answer the question
16:55:22 <procyon112> sorear: I'm not restricting it to total programs... but I want it to be easier to foldr than to tail for randomly generated programs because foldr is probably more useful for the programs I am trying to evolve.
16:55:40 <dcoutts> sorear: the epigram folk make the point that people don't write non-terminating programs (on purpose)
16:55:46 <Igloo> dcoutts: It depends what you mean by non-total; If a program prints something to stderr and then exit's with exit code 1, does that make it non-total?
16:55:56 <QtPlatypus> sorear: No it doesn't, it just doesn't parse.  To summon demons you need something that parses but doesn't sence in the lanugage.
16:55:57 <dcoutts> Igloo: on, terminating
16:56:00 <dcoutts> on/ok
16:56:02 <chessguy> procyon112: this was supposed to be a general-purpose library
16:56:14 <QtPlatypus> make sence
16:56:26 <Igloo> dcoutts: OK, cat
16:56:44 <procyon112> chessguy: What do you see as not general purpose?
16:57:11 <chessguy> procyon112: you're talking about making design decisions based on the kind of programs you want to evolve
16:57:31 <dcoutts> Igloo: and this is because you don't know the input is bounded, but you typically don't want the whole of an infinite stream
16:57:39 <procyon112> chessguy: The list representation is ansulary... those are just *my* list function primitive nodes.  Other people can make any ones they want ;)
16:57:57 <sorear> QtPlatypus: int foo attribute((...)); doesn't parse in ANSI but doesn't "just fail"; in a certain well known conforming C compiler it does arbitrarily interesting things.
16:58:05 <QtPlatypus> The firmware driving a pacemaker, you don't wish that to terminate.
16:58:24 <sorear> QtPlatypus: there are ways around that.
16:58:56 <sorear> QtPlatypus: it's possible in System Fw to define a type of infinite stream processors that can always say what to do next in finite time.
16:59:17 <chessguy> hm. i wish i had a better idea how all this strong typing stuff worked
16:59:18 <procyon112> sorear: I take back the total aspect... I want the GP lib to be able to evolve total, or non-total programs.  Most GP research deals with total.
17:00:51 <sorear> System FW is not known for being a total programming language, but it is the best strongly normalising language I know
17:01:00 * sorear doesn't grok dependent types
17:01:21 * sorear gets along just fine with GADTS + totality
17:01:41 <sorear> Church encoded gadts anyway.
17:05:19 <procyon112> chessguy: The important thing to note about all that type code is that in the unify function, if we take out those 2 lines that do "occursIn", we allow infinite types.  This gives us 2 strongly typed systems.  1 system where termination is guaranteed (as long as you don't put in a primitive node that doesn't terminate), and 1 where termination is not guaranteed.  I will generalize the function to allow both as a configuration paramet
17:06:33 <procyon112> chessguy: We need to make the evaluator stop evaluating after it exceeds some threshold when we allow non-terminating programs... otherwise no GP run using that type system will ever finish.
17:06:43 <sorear> procyon112: how comfortable are you with church-encoding ints?
17:07:22 <sorear> procyon112: if you'll accept that, than you can replace the no-occurs-check unifier with (const True)
17:07:32 <procyon112> sorear: I'm comfortable with it, but for my purposes, I want the primitive ints available for efficiency.
17:07:48 <sorear> procyon112: if you only have (->) as a primitive type, and allow recursive types, there is NO WAY to create a type error
17:07:55 <chessguy> hmm. if A imports B, and B imports C, can A use things in C without importing it directly?
17:08:00 <sorear> no
17:08:17 <chessguy> ugh. that's dumb
17:08:19 <int-e> chessguy: only if B exports the module A
17:08:29 <sorear> ChanServ: I think it's smart
17:08:38 <chessguy> you mean B exports C
17:08:50 <sorear> chessguy: Whether B imports C or not is an implementation detail
17:08:57 <procyon112> sorear: yes, but most GP code needs to deal with primitives of some sort.
17:09:05 <sorear> chessguy: why should A care what modules B uses to do its job?
17:09:46 <chessguy> sorear: it's even worse for A to have to import C directly though
17:09:46 <sorear> procyon112: ah...
17:10:42 <sorear> chessguy: why?  the Prelude imports Data.List. Suppose something is added there.  do you want to have it show up in your namespace?
17:11:36 <chessguy> your usage of 'there' is ambiguous
17:11:56 <sorear> Data.List
17:12:15 <TSC> thedward: Changing numlockMask to KeyMask seems like the right change (and is needed to make it compile here)
17:12:34 <chessguy> hm, in that case, probably not. but in this case it's useful
17:12:52 <sorear> you can always re-export modules
17:12:55 <chessguy> unless i'm totally abusing the module system
17:13:13 <sorear> like the way Text.ParserCombinators.Parsec re-exports all the small pieces of parsec
17:13:25 <chessguy> yes, that's what int-e suggest 5 minutes ago :)
17:13:29 <sorear> just write "module C, " in B's export list
17:19:05 <siti> can bytestrings or other weird structures that use unsafePerformIO be used inside STM?
17:19:29 <sorear> yeah
17:19:30 <bd_> Provided they use unsafePerformIO safely.
17:19:36 <siti> ok cool :)
17:19:41 <bd_> That is, the overall interface must be pure
17:19:44 <sorear> it's the other way around that simon won't implement
17:19:44 <siti> yep
17:19:45 <bd_> even if the implementation isn't
17:19:57 <sorear> STM-inside-unsafePerformIO = pester simon
17:20:05 <bd_> sorear: allowing STM in unsafePerformIO gives deadlock conditions
17:20:29 <siti> I don't need stm in unsafePerfo....
17:20:57 <bd_> consider: inside a STM transaction, we read/write to a variable x, then do somehting with a data structure which uses unsafePerformIO and STM internally. This read/writes variables x and y. We then read/write to y in the outer transaction.
17:21:33 <bd_> If there are data dependencies which force the unsafePerformIO to be evaluated each time through the STM block, then the transaction can never complete
17:22:57 <sorear> So?  People who use unsafePerformIO without understanding the implementation deserve whatever they get.
17:23:11 <siti> lol
17:23:19 <Pseudonym> I don't think it's a question of understanding the implementation.
17:23:19 <sorear> It is, after all, *unsafe*PerformIO
17:23:21 <Pseudonym> Just the implications.
17:23:25 <siti> but it's fun getting segfaults in haskell :)
17:24:19 <siti> pity there is no valgrind for haskell :(
17:24:34 <dmead> valgrind?
17:24:40 <sorear> siti: sure there is
17:24:42 <dcoutts> there is valgrind of course
17:24:45 <sorear> siti: it's called 'grep'
17:24:54 <siti> sure there is?
17:25:20 <siti> if you play with ptrs and it segfaults how do you know where it segfaults?
17:25:36 <dcoutts> siti: you can actually use valgrind
17:25:43 <sorear> hat?
17:25:49 <siti> does it actually give a back trace?
17:25:49 <sorear> ghci-db?
17:26:01 <thedward> TSC: yeah, I went ahead and sent him a patch.
17:26:12 <sorear> Also, anywhere you can put poke, you can put printf.
17:26:21 <siti> lol
17:26:27 <dcoutts> siti: no, nothing gives backtraces for compiled ghc progs
17:26:33 <siti> printf debugging rocks :D
17:27:00 <sorear> dcoutts: +RTS -xc.  Now if only we could reflect segfaults into error calls :)
17:27:16 <dons> siti: valgrind wsa written for haskell (well, for ghc, by julian seward )
17:27:34 <dcoutts> sorear: if you compiled with profiling and it doesn't tell you everything
17:27:58 <stepcut> is there a function like, (f a -> f b) -> (g a -> g b)
17:28:04 <siti> http://en.wikipedia.org/wiki/Julian_Seward
17:28:17 <dcoutts> @type liftM
17:28:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:28:27 <sorear> stepcut: No.
17:28:34 <dons> cacheprof is a nofib benchmark too, btw.
17:28:39 <dcoutts> stepcut: you'd need some way of getting the value out of the 'f' wrapper
17:28:58 <stepcut> sorear: yes, I expect it would be a class like Functor -- but different
17:29:00 <dcoutts> stepcut: if you knoe nothing about f then you're stuffed
17:29:03 <siti> you feel important when you get your own wikipedia page ;)
17:29:14 <dons> http://www.cse.unsw.edu.au/~dons/code/nobench/real/cacheprof/cacheprof.hs
17:29:16 <lambdabot> http://tinyurl.com/2apwt2
17:29:41 <stepcut> class ReWrap f g instance where rewrap :: (f a -> f b) -> (g a -> g b)
17:30:18 <TomMD> siti, you now have one?
17:30:29 <siti> no :p
17:30:40 <siti> I was saying about the link I posted
17:30:41 <stepcut> I have a Monad similar to dons Shell monad, but now I can't use 'try'
17:30:48 <TomMD> got it
17:31:20 * stepcut ponders
17:31:31 <sorear> stepcut: oh!
17:31:45 <sorear> stepcut: look at lambdabot's LBState.hs module
17:31:53 <sorear> stepcut: specificially the impl of liftLB
17:32:10 <sorear> stepcut: It only works on reader-like monads
17:32:34 <stepcut> sorear: well, look for me, I have a reader monad :p
17:32:42 <stepcut> s/look/lucky/
17:32:53 <dons> bwhahaha, "I discovered a Haskell tutorial that took the
17:32:54 <dons> reader through the construction of a Scheme interpreter, allegedly in 48 hours. This didn't help me
17:32:57 <dons> much with my Haskell, but it did cause me to wander off and look at Scheme."
17:33:02 <chessguy> lemmih: ping
17:33:09 <stepcut> dons: haha
17:33:30 <chessguy> dons: did you get my note about LB in #ai?
17:33:46 <sorear> @uptime
17:33:47 <lambdabot> uptime: 6d 6h 35m 59s, longest uptime: 6d 6h 35m 59s
17:33:56 <sorear> hi dons
17:35:29 <siti> how "good" is stm, e.g. if read a TVar (Data.Map), do lots of operations on the map, then write the TVar, is this basically the same as a lock or is it really fast?
17:35:51 <sorear> It won't look inside a map
17:36:01 <siti> ok
17:36:02 <sorear> it will effectively lock the whole map
17:36:07 <siti> hmm ok :(
17:38:08 <siti> so in the case of my above example, is it better to use STM style concurrency or message parsing/erlang style concurrency?
17:38:38 <bd_> for accessing a single map?
17:39:42 <TSC> thedward: Did you also have to change the dimensions field in XMonad.hs from (Int,Int) to (CInt,CInt) ?
17:40:50 <siti> bd_: yep doing operations on a single map..
17:41:13 <bd_> siti: Probably STM. If you use message passing, you'll still only have one operation going at a time, and you'll have message passing/context switch overhead as well
17:41:21 <bd_> STM is quite fast in the unconsted case from what I understand.
17:41:39 <bd_> MVars are also an option, but I think they're slower if you don't expect much contention.
17:41:59 <siti> what I am making will probably have super high load...
17:42:57 <siti> although one advantage with message parsing now that I think of it, is that with only "write" operations on the map you can do it async :)
17:43:10 <bd_> How high load will there be on this one map?>
17:43:29 <sorear> siti: profile!
17:43:29 <siti> I don't know exactly yet...
17:43:31 <bd_> If the answer is any signifigant amount of CPU time across multiple threads, you need to rethink your design.
17:43:36 <bd_> If you don't know, find out! :_)
17:43:38 <bd_> :)*
17:43:46 <sorear> siti: you sound like you are making premature optimizations!
17:43:50 <sorear> ;-)
17:43:52 <siti> lol
17:43:58 <siti> nah it's really good atm
17:44:18 <siti> in 3 weeks I have accomplished more than probably a year in another language...
17:44:20 <thedward> TSC: in Main.hs I just added a couple calls to fromIntegral
17:44:23 <chessguy> procyon112: ok, i've successfully separated GPLib into several modules
17:44:39 <TSC> Ah, ok
17:45:08 <thedward> I'm not sure which is better, honestly. I'd rather not use Foreign types explicitly without need though.
17:45:25 <procyon112> chessguy: cool!  I will try to keep it that way when I integrate ;)
17:45:29 <siti> sorear: when I was getting massive memory usage, fixing it is not premature :p
17:45:50 <chessguy> sounds good. the darcs repo is up to date whenever you want to get it
17:46:01 <chessguy> i'm off for now
17:46:06 <procyon112> ttyl
17:46:44 <TSC> Yours seems like a nice fix, because then users of XState don't have to use foreign types
17:47:36 <sorear> Haskell programmers shouldn't have to know Xlib is written in C ;)
17:48:58 <int-e> CInt is just like any other type ;)
17:48:59 <kc5tja> It'd be neat to have a native Haskell binding.
17:49:31 <alec> if it was just recently discovered that it almost doesn't work on amd64, I don't think there's a lot of demand :)
17:49:32 <sorear> @goo xhsb
17:49:34 <lambdabot> http://webcvs.freedesktop.org/xcb/xhsb/
17:49:34 <lambdabot> Title: [xcb] Index of /xhsb
17:49:53 <sorear> native haskell.  (useless, but native)
17:50:36 <dons> haven't we fixed the 64 bit issues now? i see patches flying around
17:50:45 <TSC> dons: It seems fixed now
17:51:00 <TSC> At least, I am running xmonad now and nothing is breaking
17:51:28 <alec> I'm also running xmonad on amd64 and it's working
17:52:13 * kc5tja still has to compile xmonad.  :(
17:52:25 * kc5tja keeps wanting to, but I keep getting distracted.
17:52:27 <dons> great.
17:52:34 <dons> good work guys.
17:53:23 * kc5tja loves darcs pull.  :) 
17:53:23 <TSC> Now, to figure out what all the keys do... (:
17:53:25 <kc5tja> OK, I'm going home now.
17:54:03 <dons> dcoutts: you should sign up as a mentor quick smart!
17:54:12 <dcoutts> ah yes
17:56:22 <dcoutts> dons: are you an admin? can you accept me? I've applied
17:57:22 <dcoutts> dons: btw, this morning I'm looking at whether we can fuse things that use the parr desugaring and adding List.cross
17:57:56 <dons> yep. doing so.
17:58:05 <dons> ok. great. i'll do some writing today.
17:58:51 <dibblego> dons, what do you think of a 'professional doctorate'? I was reading some docs from UNSW on it - it may be offered at QUT up here mid-2007
17:59:05 <dons> hmm. sounds suspicious...
17:59:08 <dons> :-}
17:59:13 <dons> i don't know anything about it.
17:59:17 <dibblego> I know, that's wy I ask :)
18:01:38 <dons> dcoutts: you should be a mentor now.
18:04:42 <whaleofconfusion> does anybody know the proper definition of a branch point in complex variables?
18:12:10 <dcoutts> dons: got it
18:12:33 <dcoutts> dons: btw, parr desugaring with cross doesn't work :-)
18:12:59 <dons> oh interesting...
18:13:06 <dcoutts> dons: the bug is cross, you can't use it if the generators are dependent, you have to use concatMap instead :-)
18:13:22 <dons> hmm. is tht the bug Chilli talked about?
18:13:26 <dcoutts> yes
18:13:35 <dons> good 'ole concatMap
18:13:38 <dcoutts> dons: so I'm writing out the other desugaring we looked at yesterday that builds a big stream function with a nested state
18:13:47 <dons> yeah ok. good.
18:14:03 <dons> i'll catch the train in 10 mins or so, and be in around 12.
18:14:03 <dcoutts> dons: and bungs all the other streams into the state, so we'll rely on rl to make that produce good code
18:14:08 <dcoutts> dons: 'k
18:14:15 <dons> ok. good.
18:18:25 <tsp> hmm
18:18:30 <tsp> maybe I should get a listening script going
18:19:24 * tsp auxskultas al - Saga - My Tribute to Skrewdriver Vol.1 - Son of Britain
18:19:45 <dons> off topic.
18:20:05 <tsp> dons: is this channel on topic all the time? 99% of irc channels aren't
18:20:37 <dons> this channel is, yes.
18:20:42 <dons> we have -blah for off tpoic stuff.
18:20:45 <tsp> ah
18:20:58 <dons> see haskell.org/haskellwiki/IRC_channel for details
18:36:50 <dibblego> is there a Haskell btree implementation out there? googling reveals binary trees only
18:41:23 <siti> dibblego: isn't Data.map a btree?
18:42:03 <bd_> siti: No, it's a binary tree.
18:42:06 <dibblego> dunno, is it? I was under the impression is was a binary tree
18:42:19 <bd_> siti: btrees are inefficient in memory, usually
18:42:54 <siti> I am confused, what's the difference?
18:43:11 <bd_> siti: btrees have a large number of children at each node
18:43:15 <bd_> binary trees have only 2
18:43:17 <dibblego> a btree is a very different beast, usually used for persistent storage
18:43:23 <siti> I see
18:43:36 <siti> I always assumed btree == binary tree, oops !
18:43:54 <dibblego> google turns up binary trees, because people shorten it to 'btree', but they are very different
18:44:02 <siti> I see
18:44:24 <dibblego> the 'b' is not short for anything in particular, but some people say 'balanced'
18:44:36 <siti> ok
18:44:51 <dibblego> googling for haskell balanced btrees still turns up binary trees (balanced ones) :)
18:44:56 * SamB wonders what is a good DNS server
18:44:56 <Excedrin> are btrees like rose trees?
18:45:13 <Pseudonym> Err... kinda.
18:45:31 <Pseudonym> B-trees are more like 2-3 or 2-3-4 trees.
18:45:38 * kc5tja is trying to build X11 1.2 for Haskell; configure worked OK, but make does nothing -- no rules.
18:45:39 <SamB> my ISP's DNS server seems to be out... again... and I bet the DHCP server is out too!
18:45:43 <kc5tja> Am I missing something?
18:46:22 <TSC> kc5tja: Use cabal, not configure/make
18:46:33 <TSC> runhaskell Setup.hs configure [options]
18:46:44 <TSC> runhaskell Setup.hs build, runhaskell Setup.hs install
18:47:16 <kc5tja> There is no Setup.hs
18:47:25 <kc5tja> Oh,
18:47:26 <kc5tja> duhh.
18:47:28 <kc5tja> never mind.
18:47:56 <Pseudonym> B-trees are balanced search trees, but the node sizes are actually controlled by the amount of data in them, not the number of children.
18:47:57 <dibblego> so nobody has come across a Haskell implementation of a btree?
18:48:10 <Pseudonym> dibblego: Watch this space.
18:48:14 <Excedrin> SamB: do you want to setup a dns server, or just one to use while your ISPs is down?
18:48:17 <dibblego> Pseudonym, ok cheers
18:48:39 * int-e wonders whether the 2-3-fingertrees count.
18:48:52 <SamB> actually, it looks like my ISP's DNS isn't down.
18:49:03 <SamB> I think it is my "router"
18:49:17 <SamB> (this computer)
18:49:35 <Pseudonym> dibblego: But if you'd liek a sneak preview, there's a really good paper on this which I will just find for you.
18:49:45 <ivanm> @hoogle trie
18:49:46 <lambdabot> Test.HUnit.Base.tried :: Counts -> Int
18:49:54 <dibblego> Pseudonym, thanks
18:49:55 <Pseudonym> http://citeseer.ist.psu.edu/51205.html
18:49:58 <lambdabot> Title: B-Trees with Relaxed Balance - Larsen, Fagerberg (ResearchIndex)
18:49:59 <ivanm> is there a trie datatype anywhere?
18:50:06 <SamB> hmm, or maybe my windows box is just acting wierd...
18:50:11 <Pseudonym> ivanm: Yes, there are a few.
18:50:15 <dibblego> Pseudonym, cheers
18:50:21 <TSC> dibblego: http://portal.acm.org/citation.cfm?doid=286860.286872 mentions using lazy btrees
18:50:30 <lambdabot> Title: The bits between the lambdas
18:50:50 <Pseudonym> ivanm: TernaryTrie is in the latest Edison.
18:50:54 <ivanm> Pseudonym: such as? where can I find them? every time I google, I get "hugs tries to"
18:51:05 <ivanm> @google ternaryTrie
18:51:07 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/docs/edison/Data-Edison-Assoc-TernaryTrie.html
18:51:36 <SamB> or I guess maybe my dog knocked the cable out of the switch ;-)
18:51:39 <ivanm> I want it for actual String prefixes, not maps... does this matter?
18:51:52 <SamB> since she *was* rooting around back there for her ball, and it seems to have been knocked out...
18:52:02 <Pseudonym> ivanm: Probably not, the implementation will work.
18:52:08 <SamB> I thought programmers were supposed to blame hardware!
18:52:17 <Pseudonym> Just so you know, a ternary trie is basically a trie where each "level" of the trie is a binary search tree.
18:52:21 <Pseudonym> So it's a sparse trie.
18:52:27 <ivanm> OK
18:52:59 <ivanm> I'm wanting to find common substrings in a chunk of text for a vigenere cipher cracker using kasiskis method
18:53:15 <Pseudonym> Why are you using the Kasiski method?
18:53:22 <Pseudonym> Seriously.
18:53:28 <ivanm> I have to use both kasiski and friedman for an assignment
18:53:34 <Pseudonym> Ah, fair enough.
18:53:38 <Pseudonym> Friedman is really, really superior.
18:53:44 <ivanm> it doesn't have to be coded, but I figured I might as well
18:53:58 <Pseudonym> http://andrew.bromage.org/crypto/ic.cgi
18:54:04 <Pseudonym> My hacked-up Friedman analyser.
18:54:05 <ivanm> *nod*... except the approximation form of Friedman doesn't work on my text (gives m = 6 instead of 4)
18:54:06 <lambdabot> Title: Coincidence analyser
18:54:18 <Pseudonym> What's your text?
18:54:23 <Pseudonym> Could be hitting harmonics.
18:54:28 <ivanm> *shrug* friedman will be relatively simple to implement
18:54:49 <ivanm> the text is an extract from pride and prejudice, with a 4 letter keyword
18:54:57 * Pseudonym nods
18:54:58 <kc5tja> How can I check to see if my X11-1.2 install is installed correctly?
18:55:18 <ivanm> kc5tja: if X-Windows programs work properly? *duck*
18:55:19 <Pseudonym> Hang on, actually, there are two Friedman tests.
18:55:34 <Pseudonym> One uses the overall IC to guesstimate the key length.
18:55:34 <kc5tja> ivanm: The X11-1.2 Cabal package.
18:55:40 <ivanm> oh...
18:55:46 <Pseudonym> The other one splits the text into columns and computes ICs for the columns.
18:55:56 <jcreigh> kc5tja: I don't know of any programs that use the X11 bindings other than xmonad...but of course xmonad requires the X11-extras package, so it's not a test of X11 proper.
18:55:57 <Pseudonym> It's the latter one which is unbeatable.
18:56:08 <ivanm> Pseudonym: yeah, the mutual index of coincidence fails for me... (I have to do kasisiki + both friedmans)
18:56:10 <Pseudonym> Because it actually subsumes the Kasiski test.
18:56:10 <kc5tja> Well
18:56:30 <kc5tja> the problem (if it even is) is that I installed the package into its own directory at the root-level, to keep things organized.
18:56:56 <kc5tja> e.g., runhaskell Setup.hs configure --prefix=/Programs/GHC-X11/1.2
18:57:06 <Pseudonym> Clearly we need #haskell.crypto
18:57:12 <kc5tja> However, GHC is installed at /Programs/GHC.
18:57:21 <ivanm> Pseudonym: so, AFAIK, using a trie will be the best way of getting the substrings for use with kasiski
18:57:29 <kc5tja> well...I'll give ti a shot.
18:57:33 <Pseudonym> You could also use a suffix tree.
18:57:48 <ivanm> isn't a suffix tree the same as a trie?
18:57:53 <Pseudonym> Kinda.
18:57:57 <Pseudonym> In fact...
18:58:00 <TSC> kc5tja: Try running "ghc-pkg list" and see if X11 is there
18:58:04 <ivanm> all I'm doing is tails message, then analysing that
18:58:14 <ivanm> since there's no spaces in the ciphertext
18:58:16 <Pseudonym> I wonder if you could do a Kasiski test from the Burrows-Wheeler transform?
18:58:30 <kc5tja>     QuickCheck-1.0, X11-1.1, X11-1.2, base-2.0, cgi-2006.9.6, fgl-5.2,
18:58:33 <Pseudonym> That's an intriguing thought.
18:58:40 <ivanm> never heard of it, and not sure if the lecturer will accept it (probably will though, if its valid)
18:58:42 <kc5tja> Looks like it is.  But, X11-1.1 is there too.  Will that cause any conflicts?
18:58:48 <ivanm> @google burrows-wheeler transform
18:58:49 <lambdabot> http://en.wikipedia.org/wiki/Burrows-Wheeler_transform
18:58:50 <lambdabot> Title: Burrows-Wheeler transform - Wikipedia, the free encyclopedia
18:59:04 <kc5tja> (Thanks TSC for pointing that out)
18:59:06 <Pseudonym> I'm not suggesting that you do it. :-)
18:59:21 <TSC> I'm not sure what it will do if there are two versions
18:59:25 <ivanm> lol
19:00:03 <ivanm> so, is there a String based trie implementation anywhere? or is ternary tries my best bet?
19:00:42 <Pseudonym> You know, the first Turing-hard-modulo-storage-limitations computer was designed to do Friedman tests.
19:00:45 <ivanm> I've found a minutes meeting to suggest that richard bird once developed one, but can't find any code, etc
19:00:56 <ivanm> really?
19:01:06 <Pseudonym> ivanm: Here's a suggestion.
19:01:29 <Pseudonym> > tails "WILLYOUWONTYOUWILLYOUWONTYOUWILLYOUJOINTHEDANCE"
19:01:30 <lambdabot>  ["WILLYOUWONTYOUWILLYOUWONTYOUWILLYOUJOINTHEDANCE","ILLYOUWONTYOUWILLYOUWONT...
19:01:34 <Pseudonym> So far so good.
19:01:37 <siti> :S
19:01:42 <Pseudonym> > sort . tails $ "WILLYOUWONTYOUWILLYOUWONTYOUWILLYOUJOINTHEDANCE"
19:01:44 <lambdabot>  ["","ANCE","CE","DANCE","E","EDANCE","HEDANCE","ILLYOUJOINTHEDANCE","ILLYOUW...
19:01:50 <Pseudonym> > tail . sort . tails $ "WILLYOUWONTYOUWILLYOUWONTYOUWILLYOUJOINTHEDANCE"
19:01:50 <ivanm> yeah, that's what I was doing...
19:01:51 <lambdabot>  ["ANCE","CE","DANCE","E","EDANCE","HEDANCE","ILLYOUJOINTHEDANCE","ILLYOUWONT...
19:01:57 <Pseudonym> > groupBy head . tail . sort . tails $ "WILLYOUWONTYOUWILLYOUWONTYOUWILLYOUJOINTHEDANCE"
19:01:57 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> Bool
19:01:58 <lambdabot>     Pr...
19:02:04 <Pseudonym> Erm.
19:02:34 <ivanm> but it had some problems, where if there's a string "abcd" which occurs twice, and "abc" occurs twice as well, I'll just be told that "abc" occurs four times
19:03:03 <ivanm> also, I'll also be told that "bcd" occurs twice... which I really don't care about
19:03:05 <Pseudonym> > groupBy (\x y -> head x == head y) . tail . sort . tails $ "WILLYOUWONTYOUWILLYOUWONTYOUWILLYOUJOINTHEDANCE"
19:03:07 <lambdabot>  [["ANCE"],["CE"],["DANCE"],["E","EDANCE"],["HEDANCE"],["ILLYOUJOINTHEDANCE",...
19:03:13 <Pseudonym> Bingo.
19:03:19 <Pseudonym> That's one level of a trie constructed.
19:03:26 <ivanm> hang on, what did you do there?
19:03:29 <Pseudonym> Then just apply that operation recursively.
19:03:35 <ivanm> ahhh, k, I think I get it...
19:03:52 <ivanm> @hoogle tail
19:03:52 <lambdabot> Prelude.tail :: [a] -> [a]
19:03:53 <lambdabot> List.tails :: [a] -> [[a]]
19:03:53 <lambdabot> Data.PackedString.tailPS :: PackedString -> PackedString
19:04:05 <ivanm> > tail "hello"
19:04:07 <lambdabot>  "ello"
19:04:10 <ivanm> duh, that's right...
19:04:30 <ivanm> why did you drop the first char?
19:04:31 <Pseudonym> You might need to modify it to keep track of positions.
19:04:38 <Pseudonym> I didn't.
19:04:48 <ivanm> *nod*... just use flip zip [1..] after the tails
19:04:50 <Pseudonym> I dropped the last tail from tails (which is always the empty string).
19:05:04 <ivanm> oh, sorry, I get it now...
19:05:23 <ivanm> I'll try that...
19:05:27 <Pseudonym> OK
19:06:03 <ivanm> probably do a take 10 or something after tails to get rid of the excess characters (since no common substring is > 6, IIRC)
19:06:22 <ivanm> (we're given the sub strings, but I wanted to code it in myself as well)
19:06:30 <ivanm> OK, thanks Pseudonym!
19:06:35 <Pseudonym> No problem.
19:06:42 <ivanm> Pseudonym++
19:06:56 <Pseudonym> I'm curious to know what my coincidence analyser reports, too.
19:07:01 <Pseudonym> Does it give you a peak at k=4?
19:07:02 * ivanm has to go see his quantum lecturer now, then have lunch
19:07:37 <ivanm> 4 	6.46% 	
19:07:58 <heatsink> In HUnit, is there a way to make a test be a conjunction of assertions?
19:07:59 <ivanm> 8 	6.56% 	 :(
19:08:15 <ivanm> but I'm comparing it to friedman's anyway
19:08:34 <Pseudonym> Right.
19:08:35 <ddarius> (&&) ?
19:08:35 <ivanm> OK, might get back on when I get home
19:08:38 <ivanm> cya!
19:08:47 <Pseudonym> Mind you, if you try for k=8, you'll still succeed in a decrypt.
19:08:50 <Pseudonym> Bye.
19:09:26 <heatsink> Oh, I've got it.
19:09:37 <ddarius> Gah!  Disease-ridden peers.
19:09:45 <heatsink> ddarius: Assertion is IO (), so (&&) won't do it.
19:10:12 <heatsink> did someone cough on you or something.
19:10:27 <ddarius> heatsink: Wouldn't assert foo >> assert bar be a conjunction?
19:10:32 <heatsink> yea
19:11:09 <ddarius> heatsink: No, I've just had cold-like symptoms since a temporary change of environment that puts me in contact with a different set of my peers.
19:11:41 <heatsink> Darn foreign bacteria.
19:12:08 <TomMD> @users
19:12:08 <lambdabot> Maximum users seen in #haskell: 337, currently: 300 (89.0%), active: 35 (11.7%)
19:13:21 <jcreigh> nobody leave!
19:14:05 <int-e> @seen chanserv
19:14:05 <lambdabot> chanserv is in #haskell, #gentoo-haskell, #jtiger and #gentoo-uy. I don't know when chanserv last spoke.
19:14:16 <ddarius> heatsink: In general, (>>) is conjunction-like
19:17:51 <sorear> hello!
19:17:55 <sorear> whaleofconfusion: you still want to know what a branch point is?
19:18:04 <ddarius> This should be interesting.
19:20:47 <ddarius> sorear: If you are referring to the ones from analysis, I don't want to know, but I'm curious as to how you'd describe it.
19:21:30 <sorear> He was talking about complex functions in the logs.
19:21:42 <ddarius> Those would be the ones.
19:21:45 <sorear> I've never studied analysis, but I have a strong suspicion this is it/
19:21:53 <ddarius> This is complex analysis.
19:22:22 <sorear> Imagine the graph of \x -> phase(x).
19:22:50 <sorear> If you trace a circle around the origin, the phase must take on each value from 0 to 2pi exactly once.
19:23:13 <sorear> But that's topologically impossible if we insist phase() is continuous.
19:23:31 <sorear> So we pick an arbitrary line to break continuity at.
19:23:54 <sorear> Just like with trig function signs, where the line is isn't important, but that people agree is.
19:24:13 <sorear> So we have conventions... phase is IIRC usually broken on the negative real axis.
19:24:24 <sorear> End of explanation.
19:24:46 <kc5tja> Finally building xmonad.
19:24:53 <ddarius> @google "Riemann Surface"
19:24:55 <lambdabot> http://en.wikipedia.org/wiki/Riemann_surface
19:24:55 <lambdabot> Title: Riemann surface - Wikipedia, the free encyclopedia
19:25:46 * sorear remembers that riemann surfaces are an older and less general formulation of complex manifolds, but that's it.
19:26:14 * sorear still doesn't grok the geometric distinction between (say) C^3 and R^6
19:26:46 <heatsink> Is anyone here able to visualize a projective plane?  I can visualize a klein bottle but the projective plane is beyond me.
19:26:57 <sorear> Sure.
19:27:16 <sorear> A projective plane to me looks like a square with teleporters on the side.
19:27:25 <sorear> Marked "Orientation reverses here"
19:27:41 <sorear> I suppose you wanted an imbedding however :)
19:27:46 <ddarius> sorear: If you can find it at a library, while I'm ambivalent about it, Roger Penrose's Road to Reality is a good read.
19:28:03 <heatsink> yea.  But that approach works too.
19:28:50 * heatsink didn't know about the difference between C^3 and R^6
19:29:08 <sorear> Identifying antipodal points of a sphere is head-spinning fun too.
19:29:49 <heatsink> Actually, I thought it was really weird that topology comes in to the explanation of (mathematical) monads.
19:31:37 <Gwern> any idea why I am persistently getting the error "Could not find module `HSH': it is a member of package HSH-1.2.1, which is hidden", which I can load the HSH module just fine in ghci and even run a basic little thing?
19:31:47 <Gwern> (I'm trying to do this in xmonad's Config.hs, if it helps)
19:31:50 <sorear> You are using Cabal.
19:31:58 <sorear> You forgot to add a Build-depends.
19:32:04 <paulc> hello!
19:32:08 <Gwern> ~wah?
19:32:17 <Gwern> an import is insufficient?
19:32:22 <sorear> Gwern: Have you ever been frustrated with a program that didn't declare a dependency?
19:32:32 <sorear> Gwern: Cabal actually makes that impossible.
19:32:44 <Gwern> sorear: yes, that's why I'm always very clear what I'm importing with "import HSH (run)" and so on...
19:32:48 <sorear> Gwern: if you don't declare a dependency, you can't import the module!
19:32:55 <Gwern> but I did!
19:33:08 <sorear> Re-check the build-depends line.
19:33:15 <sorear> Cabal does not parse haskell.
19:33:25 <ddarius> sorear: Complex spaces have (locally) an i for each dimension, the complex structure.
19:33:36 <Gwern> sorear: xmonad.cabal, that is?
19:33:51 <ddarius> heatsink/sorear
19:34:14 <sorear> ddarius: what can you do with i?  It's not like multiplication is defined for manifolds.  And the affine structure of C is the same as R^2.
19:34:22 <sorear> Gwern: yeah.
19:34:25 <ddarius> heatsink: Category theory came from homology (one of two major subbranches of algebraic topology)
19:34:36 * sorear senses an incorrect tone use.
19:35:37 <Gwern> \cursed cabal. what has it ever done for me but get in me way? oh well, editing xmonad.cabal propitiates it
19:35:50 <Gwern> if only the xmonad guys had added this functionality in the first place
19:36:34 <sorear> Gwern: cabal-devel@haskell.org hasn't seen a decent complaint thread in months, you should start one
19:37:21 <sorear> You might get an answer from someone who (unlike me) knows the why of cabal
19:37:24 <sjanssen> Gwern: what's the problem with xmonad.cabal?
19:37:27 <sorear> I know only how.
19:37:27 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
19:37:29 <Gwern> sorear: what could I say? "Uh hey guys, if a program declares an import in one file and it can be satisfied, then maybe cabal shouldn't cause an epic fail and let it compile?"
19:37:37 <sorear> Gwern: exactly.
19:38:06 <sorear> Gwern: complain as loud as you want, email is asynchronous and hotheads are nonexistant here.
19:38:23 <Gwern> sjanssen: I'm trying to set up some shell functionality in Config.hs  in Xmonad, and I was going to use the HSH library to do it
19:38:24 <sorear> Gwern: cabal needs more complaints
19:38:29 <sjanssen> cabal *should* fail
19:39:02 <Gwern> sorear: see, sjanssen is sort of what I'm talking about w/r/t emailing the cabal guys
19:39:09 <sjanssen> Gwern: if you forgot to add it to the .cabal, when you send the patch to me I wouldn't be able to build it
19:39:20 <sorear> sjanssen: Gwern is a user
19:39:20 <Gwern> (how could I know the whys and wherefore of cabal, designed by greater minds than mine?)
19:39:28 <sorear> Gwern: stop it
19:39:40 <sorear> Gwern: there is no such thing as comparable minds
19:39:41 <sjanssen> sorear: no, Gwern is a developer.  He's changed the code in some way
19:39:50 <sorear> sjanssen: ... cabal's code?
19:40:05 <Gwern> sry. when haskell stuff works well, it's pleasing, but when it doesn't work, it can be quite frustrating
19:40:10 <sorear> sjanssen: don't dissuade Gwern from giving feedback on cabal
19:40:21 <sjanssen> sorear: xmonad's code
19:40:39 <sorear> sjanssen: cabal doesn't get feedback from people who have actually tried to use it anywhere near as often as it should
19:40:40 <sjanssen> I have no problem with complaints, I just don't think that particular one is valid
19:40:59 <Gwern> sjanssen: isn't the idea of xmonad and dwm that you have to change the source code to make it usable?
19:41:01 <ddarius> sorear: The "i" is represented by a linear transformation on the tangent space of the manifold that lets you interpret the "i" in the complex scalars.
19:41:23 <sorear> sjanssen: do you also believe dmwit should not be allowed to complain about the design decisions of multi-screen?
19:41:23 <Gwern> so by such a definition, all users are developers?
19:41:37 <sorear> sjanssen: just because it is the design doesn't make it right
19:41:59 <sjanssen> sorear: I'm not removing Gwern's right to speak
19:42:06 <araujo> hello!
19:42:07 <sjanssen> I am also voicing an opinion
19:42:21 <paulc> hi araujo
19:42:27 <QtPlatypus> ?src tails
19:42:27 <lambdabot> tails []         = [[]]
19:42:27 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
19:42:42 <araujo> :-)
19:42:48 <sorear> ddarius: By my interpretation of that definition, R^6 *is* isomorphic to C^3, with the complex structure being satisfied by rotation operators.
19:43:00 <sorear> ddarius: and that conclusion just seems bogus.
19:43:05 * QtPlatypus has never seen a patten like that before xxs@(_:xs)
19:43:07 <Gwern> sjanssen: any idea how I can take a normal little monadic thing returning IO () (since it's running a shell command), and have it return X () so it is acceptable for binding a key to?
19:43:17 <QtPlatypus> What does the @ mean?
19:43:17 <sjanssen> Gwern: io
19:43:26 <sorear> Gwern: don't let sjanssen tell you what complaints are and aren't valid.
19:43:33 <sorear> QtPlatypus: as pattern
19:43:41 <sjanssen> sorear: yeah, valid wasn't a very nice word
19:44:06 <Gwern> sjanssen: the IO module?
19:44:10 <sorear> IMO a user-unfriendly design is a bug.
19:44:23 <Gwern> oh, you meant the io function
19:44:26 <sjanssen> Gwern: the io function
19:44:39 <paulc> how are tuples represented?
19:44:53 <sjanssen> sorear: and I don't think the module restriction is a user unfriendly feature
19:45:00 <paulc> are they singly linked lists?
19:45:03 <sorear> sjanssen: Gwern thinks it is
19:45:07 <sorear> paulc: no, vectors
19:45:24 <Gwern> sorear: I'm not sure if it's a bad thing, but I certainly found it unexpected
19:45:24 <sjanssen> I'd buy that the package hiding should be configurable
19:45:25 <ddarius> Every even dimensional real space admits a complex structure that turns it into a complex space.
19:46:12 <paulc> so, if a tuple is a vector, I'm assuming that ':' isn't supported efficiently?
19:46:13 <sorear> so cabal-devel will remain silent. *sigh* *melodrama*
19:46:25 <sorear> paulc: : doesn't work on tuples
19:46:31 <sjanssen> sorear: I think you're overreacting a bit
19:46:31 <Gwern> sorear: oy, I'll think about sending one if it'll make you happy
19:46:32 <ray> tuples are fixed length anyway, right?
19:46:40 <sorear> ray: yes
19:46:41 <sioraiocht> ray: yes
19:46:47 <paulc> oh, okay
19:46:50 <Gwern> (you've given me enough help in the past I owe you something anyway)
19:46:51 <paulc> that makes more sense
19:47:03 <paulc> and [1,2,3] lists are singly linked lists
19:47:09 <heatsink> yea
19:47:10 <sorear> yes.
19:47:25 <paulc> ?
19:47:30 <paulc> ok
19:48:25 <sorear> Gwern: or even haskell-cafe.  more people will see it, and cabal is very general now.
19:48:26 <sioraiocht> paulc: so does > tail [1,2,3] create a new list when it returns?
19:48:52 <sioraiocht> or does it just point to the remaining nodes
19:49:01 <sorear> remaining nodes.
19:49:02 <sjanssen> sorear: do you dislike the package hiding behavior?
19:49:06 <Gwern> sorear: I read haskell-cafe, so maybe there
19:49:24 <Gwern> oh hey, I just remembered something that bothered me a lot a while ago
19:49:30 <sorear> sjanssen: no, I like it.  But I see people suffering in #haskell once a month.
19:49:31 <sioraiocht> sorear: so tail is O(1)'?
19:49:38 <sorear> sioraiocht: right.
19:49:44 <sioraiocht> thanks
19:50:15 <sioraiocht> @src last
19:50:16 <lambdabot> last [x]    = x
19:50:16 <lambdabot> last (_:xs) = last xs
19:50:16 <lambdabot> last []     = undefined
19:50:39 <Gwern> some programs when your messing around, it's just easier to not give type sigs for new functions or modifed ones, right? but they're too hard to load into ghci and go :t on those functions, because of complex build stuff. is there any way to have GHC just spit out whatever type sig it came up with whenever it warns you that a function doesn't come with a type sig?
19:50:56 <ddarius> sorear: Going R^2n -> C^n -> R^2n is fine, but going C^n -> R^2n -> C^n results in us forgetting the particular complex structure.
19:51:20 <heatsink> Gwern: you mean :type?
19:51:36 <sorear> heatsink: :t :ty :typ :type are all equiv
19:51:48 <Gwern> heatsink: yah
19:52:41 <heatsink> Oh, if there's a way to do it in compiler mode.  I don't know of one.
19:53:17 <Gwern> heatsink: well, I did look over the docs, but I didn't have any luck, and I gave up on it, until just now when I remembered and was in #haskell
19:58:33 <roju> i have a total newbie question.  i'm trying to take the square root of some integers, and running into some type problems
19:58:44 <dons> > sqrt 4
19:58:45 <lambdabot>  2.0
19:58:48 <roju> specifically, Paul> map (\(x,y,z) -> (sqrt x, sqrt y, sqrt z)) [(a,b,c) | a<-(sub 1000 squares), b<-(sub 1000 squares), c<-(sub 1000 squares), a+b==c, a<b, b<c]
19:59:02 <roju> gives me ERROR - Cannot infer instance
19:59:07 <Gwern> hey, sjanssen, are you still here?
19:59:37 <roju> Do I need to convert x,y,z into Floating? If so, how do I do it?
20:00:09 <heatsink> roju: fromIntegral
20:00:41 <heatsink> > sqrt $ fromIntegral $ succ 3
20:00:43 <lambdabot>  2.0
20:00:48 <sioraiocht> succ?
20:00:51 <sioraiocht> > :t succ
20:00:52 <lambdabot>  Parse error
20:00:54 <roju> heatsink: thanks, that works
20:00:54 <sioraiocht> :t succ
20:00:57 <lambdabot> forall a. (Enum a) => a -> a
20:01:02 <chessguy> ?src succ
20:01:02 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:01:03 <roju> What does the $ operator mean?
20:01:06 <sioraiocht> @src succ
20:01:06 <lambdabot> Source not found. My mind is going. I can feel it.
20:01:08 <heatsink> sioraiocht: successor
20:01:30 <sioraiocht> roju: it means treat everything to the right as one arg
20:01:32 <heatsink> roju: It's function application. (f $ x) is (f x).  It lets us use fewer parenthesis.
20:01:47 <heatsink> sioraiocht's explanation is good.
20:01:58 <sioraiocht> @src ($)
20:01:58 <lambdabot> f $ x = f x
20:02:16 <sioraiocht> is $ infixr or infixl?
20:02:19 <Randroid> sioraiocht: Your name looks Gaelic. Is it?
20:02:31 <sioraiocht> Randroid: yes, it's irish for 'eternity'
20:02:41 <Randroid> Thought so.
20:02:48 <heatsink> sioraiocht: infixr
20:02:55 <sioraiocht> Randroid: An gaeilge agat?
20:03:14 <roju> ah that makes sense
20:03:15 <Randroid> sioraiocht: Nag ydy. Cymraeg.
20:03:35 <sioraiocht> Randroid: Ah =) Cymru. (that's all i know)
20:04:10 <Randroid> sioraiocht: Kewl. :)
20:04:13 <sioraiocht> my knowledge of welsh is only how it grammatically compares to irish
20:04:24 <sioraiocht> (we have contact mutation, too)
20:04:36 <sioraiocht> roju: ($) is just an operator like any other
20:04:48 <sioraiocht> > ($) not 3
20:04:49 <lambdabot>   add an instance declaration for (Num Bool)
20:04:54 <Randroid> Well, grammar is what interests me the most, and ultimately it's how I got into programming, and thus Haskell, which has the most elegant 'grammar' of any programming language I know of.
20:05:06 <sioraiocht> Randroid: I'm a fan of Pascal =)
20:05:14 <Randroid> sioraiocht: No way.
20:05:27 <Randroid> Haskell is so much prettier than Pascal.
20:05:38 <sioraiocht> oh, i would agree
20:05:44 <sioraiocht> but they accomplish different things
20:05:52 <Randroid> I love its minimalism. Haskell is almost poetic in its conciseness.
20:06:03 <sioraiocht> It can be, in the right hands =)
20:06:11 <sioraiocht> and at least it has no contact mutation, heh
20:06:14 <Randroid> hahah
20:06:50 <Randroid> Yeah, I was aware of the different mutations in Irish, an fear, an fhir, na fir, etc.
20:07:11 <sioraiocht> aye, unlike welsh they're integrated into the orthography
20:07:39 <sioraiocht> for example, conai > i gconai
20:08:02 <sioraiocht> and the C is eclipsed, but it tells you it came from a mutation and isn't talking about the word gonai
20:09:04 <sioraiocht> > ($) (+1) 3
20:09:06 <lambdabot>  4
20:09:10 <sioraiocht> there we go...
20:09:33 <sioraiocht> > (+1) ($ 3
20:09:34 <lambdabot>  Parse error
20:09:42 <sioraiocht> > (+1) $ 3
20:09:43 <lambdabot>  4
20:09:53 <dmwit> > (+ 1) ($ 3)
20:09:54 <lambdabot>   add an instance declaration for (Num ((a -> b) -> b))
20:09:54 <lambdabot>     In the expression...
20:10:12 <sioraiocht> that's odd
20:10:16 <Randroid> sioraiocht: Yeah, I've studied enough Irish to be aware of that. I can conjugate verbs and decline nouns, etc., and I know most of the mutations. My vocabulary is small. That's the only problem.
20:10:36 <dmwit> :t ($ 3)
20:10:39 <lambdabot> forall a b. (Num a) => (a -> b) -> b
20:10:41 <Randroid> sioraiocht: If you want to study a complex language, try Din Bizaad (Navajo).
20:10:45 <dibblego> is an order 1 btree simple a binary tree?
20:10:45 <dmwit> That's why it isn't odd. ;-)
20:11:01 <sioraiocht> ($ 3) (+1)
20:11:08 <sioraiocht> > ($ 3) (+1)
20:11:10 <lambdabot>  4
20:11:12 <sioraiocht> ah
20:11:23 <dibblego> I read about Navajo in a book on world war 2 and the Australia/Japanese fighting
20:11:34 <sioraiocht> yeah, it's ridiculous
20:11:43 <sioraiocht> Randroid: there are languages in africa with 5 moods
20:12:11 <Randroid> sioraiocht: Navajo has at least five, although they shade into aspects in a very complex way.
20:12:22 <chessguy> ?seen lawman
20:12:23 <lambdabot> I haven't seen lawman.
20:12:26 <sioraiocht> and of course there's finnish, 15 cases =)
20:12:43 <chessguy> ?seen Lawman
20:12:43 <lambdabot> I haven't seen Lawman.
20:12:56 <Randroid> sioraiocht: Suomelinen is easy compared to Navajo. There aren't many languages I'm not at least passingly familiar with, human or computer.
20:12:59 <roju> thanks for the help with sqrt and $. i'm off
20:13:19 <kc5tja> regarding xmonad -- I must be missing something with respect to how to use it.  Do I launch exec xmonad &, or exec xmonad?  And, if I use the &-form, do I then launch dmenu immediately afterwards?
20:13:26 <kc5tja> I'm asking, because *nothing* is happening when I launch xmonad.
20:13:40 <kc5tja> I have the stippled background and a big fat X for a mouse pointer.  :)
20:13:56 <sioraiocht> Randroid: neat :)
20:14:47 <heatsink> kc5tja: I don't know how xmonad works, but if it's like twm, right-click to get a menu.
20:15:04 <Gwern> kc5tja: xmonad doesn't do anything by default
20:15:06 <kc5tja> (... verbs and decline nouns, etc....) "NO!  You may NOT have corresponding verb agreement.  NOT YOURS!"
20:15:19 <Gwern> you'll want to try M-s-Ret
20:15:25 <Hirvinen> Randroid: The language is suomi or suomen kieli. A finn would be suomalainen. But suomelinen is a non-word.
20:15:31 <Gwern> read the Config.hs or the dwm man page for the bindings
20:15:39 <kc5tja> heatsink: mouse buttons are dead functionally.
20:15:53 <sjanssen> kc5tja: nothing is supposed to happen
20:15:55 <kc5tja> Gwern: I don't have dwm installed.
20:15:57 <Gwern> M-1, M-2, and so on change virtual desktops, M-C kills windows, and so on
20:16:05 <sjanssen> mod+shift+enter to make an xterm
20:16:15 <Gwern> kc5tja: well, it imitates dwm
20:16:17 <sjanssen> kc5tja: read Config.hs to learn the keybindings
20:16:17 <kc5tja> Ah -- I'll try that.
20:16:33 <Hirvinen> Randroid: And as for its comlexity: check these out: http://www.cc.jyu.fi/~hetahein/tiede/verbikaava.html http://www.ling.helsinki.fi/~fkarlsso/genkau2.html
20:16:35 <lambdabot> Title: Henri Heinonen - Suomen kielen verbien taivutuskaava
20:16:50 <kc5tja> Gwern: Well, I didn't install dwm.  :)  I'm aware that it's an imitation of dwm, but I also expected some kind of visual feedback for random mashing of the keys too.
20:16:51 <Gwern> sjanssen: oy, do you mind if I email you with an idea for an xmonad feature/function?
20:17:00 <Gwern> kc5tja: don't think so :)
20:17:03 * kc5tja tries again.
20:17:05 <kc5tja> Thanks.
20:17:07 <sioraiocht> Finnish is the third most beautiful language i've ever heard
20:17:17 <sjanssen> Gwern: sure, if there's that much to explain :)
20:17:29 <Gwern> kc5tja: for a background and stuff you need to have an .xinitrc that reads like "xmonad & aterm & xbindkeys & xsetbg foo" and so on
20:17:31 <Hirvinen> Randroid: The first one's in Finnish, but it shows the amount of verb forms.
20:17:43 <Gwern> sjanssen: well, alright, I discuss it here then
20:18:03 <sioraiocht> > @src $!
20:18:03 <lambdabot>  Parse error
20:18:11 <sioraiocht> > @src ($!)
20:18:12 <lambdabot>  Parse error
20:18:13 <Gwern> hmm. where's the paste site again?
20:18:17 <dibblego> ?paste
20:18:17 <sjanssen> @hpaste
20:18:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:18:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:18:23 <ddarius> @src ($!)
20:18:24 <lambdabot> Source not found. Where did you learn to type?
20:18:41 <ddarius> Anyways, f $! x = x `seq` f x
20:18:54 <sioraiocht> $! forces evaluation of it's second argument, then?
20:19:10 <hpaste>  Gwernx pasted "xmonad idea" at http://hpaste.org/1189
20:19:11 <ddarius> sioraiocht: Application already forces it's first arg.
20:19:11 <sioraiocht> @src seq
20:19:12 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:19:21 <sioraiocht> ddarius: then what's the point of $!
20:19:42 <ddarius> > const 0 undefined
20:19:44 <lambdabot>  0
20:19:46 <dibblego> sioraiocht, $! is strict application
20:19:47 <ddarius> > const 0 $! undefined
20:19:49 <lambdabot>  Undefined
20:19:50 <Gwern> sjanssen: the basic idea is to allow one to hit a key combo, input some text, and then have some sort of shell command ran using it.
20:20:09 <sioraiocht> ddarius: I thought that meant that it forced eager evaluation of x
20:20:20 <ddarius> The first arg of application, in f x, is f.
20:20:35 <Gwern> I find such a feature to be *extremely* useful in stumpwm and ratpoison, but I didn't see any way to do it just in xmonad. I don't like using dmenu, but it's there...
20:20:40 <sioraiocht> ddarius: okay
20:21:34 <sjanssen> Gwern: is there any reason this couldn't be an external program?
20:21:40 <sioraiocht> @src Data.Control.Parallel.par
20:21:40 <lambdabot> Source not found. Where did you learn to type?
20:21:48 <sioraiocht> @src Control.Parallel.par
20:21:49 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:21:51 <sioraiocht> boo
20:22:02 <Gwern> sjanssen: sure
20:22:07 <dmwit> Gwern: Doesn't M-p do this already?
20:22:14 <Gwern> what if you wanted to search wikipedia for "PT & Barnum"?
20:22:29 <Gwern> or any string with any sort of shell metacharacter?
20:22:34 <Gwern> dmwit: I'm not sure
20:22:36 <ddarius> lambdabot should be made smart enough to search the internet for source and never fail at @src again, except for when you actually are wrong.
20:23:01 <dmwit> Gwern: do you need to see the output from your shell command?
20:23:26 <Gwern> dmwit: no, I don't think it does, since as it is, it runs the selected program, but I don't see any way of passing an argument, unless I missed something
20:23:40 <dmwit> Gwern: just type a space, then the argument.
20:24:02 <Gwern> dmwit: but that still pasess through the shell, right?
20:24:16 <sjanssen> what is the problem with passing through the shell?
20:24:20 <dmwit> Gwern: well, yes
20:24:20 <Gwern> metacharacters
20:24:21 <dons> Gwern: should really be an external program, right?
20:24:24 <dons> dmenu-ish?
20:25:06 <dons> hmm, or does dzen allow this kind of thing?
20:25:06 <hpaste>  dmwit annotated "xmonad idea" with "For when you need to see the output" at http://hpaste.org/1189#a1
20:25:10 <dons> Gwern: have you looked at dzen?
20:25:12 <Gwern> I don't really care if it's external, but I do care not having to worry about metacharacters
20:25:15 <Gwern> dons: never heard of it
20:25:31 <dons> ?google dzen window
20:25:33 <lambdabot> http://www.mail-archive.com/dwm@suckless.org/msg01150.html
20:25:34 <lambdabot> Title: Re: [dwm] dzen2 latest release
20:25:44 <dmwit> ?go gotmor dzen
20:25:47 <lambdabot> http://gotmor.googlepages.com/dzen
20:25:48 <lambdabot> Title: gotmor - dzen
20:26:46 <Gwern> the googlepages link seems down
20:27:08 <dmwit> wfm, try again?
20:28:52 <Gwern> hmm. dons, does dzen allow keyboard input? all the examples seem to use the mouse
20:29:15 <jcreigh> grr...sometimes xmonad grabs the mouse and doesn't let go...
20:29:37 <sjanssen> Gwern: anyway, I'm sure this belongs in an external program
20:29:47 <dmwit> jcreigh: Is it on workspace switches?
20:30:13 <sjanssen> stepcut reported a similar bug earlier
20:30:16 <Gwern> sjanssen: metacharacters... :(
20:30:31 <jcreigh> dmwit: don't know at this point. sometimes, the application doesn't recieve my clicks.
20:30:47 <sjanssen> kde apps seem to be most affected
20:30:47 <jcreigh> (can't reproduce it reliably yet)
20:30:55 <jcreigh> firefox in my case.
20:30:56 <dmwit> Hmm, I thought I had fixed that.
20:31:04 <jcreigh> heh, yeah, I hear you. :)
20:31:14 <dmwit> For me, I could reproduce reliably by doing this:
20:31:19 <sjanssen> simple to reproduce with konqueror
20:31:38 <dmwit> 1. Move mouse from one workspace to another.
20:31:43 <dmwit> 2. There is no step 2.
20:31:54 <dmead> 3. profit!
20:31:58 <jcreigh> heh
20:32:00 <merus> dmwit, yay!
20:32:07 <sjanssen> start two konq's in Tile mode, mouse to opposite one.  Then try to click on the menu bar
20:32:15 <Korollary> In Soviet Russia ...
20:32:26 <chessguy> the space works you?
20:32:36 <dmead> the mouse clicks you?
20:32:41 <Korollary> the mouse grabs xmonad
20:32:53 <jcreigh> sjanssen: yay, that "works" with firefox as well. (Works, as in, the bug shows up with firefox as well.)
20:32:54 <thedward> you can't mouse between workspaces?
20:32:56 <thedward> err, can?
20:32:59 <sioraiocht> In Soviet Korea...Cat eats you
20:33:12 <dmwit> thedward: two screens ;-)
20:33:18 <thedward> oh. gotcha.
20:33:30 <thedward> I should get another one, so I can help with debugging.
20:33:31 <jcreigh> n > 1 screens, anyway. :)
20:33:32 <thedward> :)
20:33:57 <dmwit> I would like to give out some props to the modkey-shift-F12 guy.
20:34:06 * jcreigh raises his hand
20:34:12 <jcreigh> :)
20:34:21 <dmwit> jcreigh++
20:34:23 <dmwit> =)
20:34:26 <thedward> I need to use that when I rotate my display.
20:36:06 <bd_> hmm
20:36:18 <bd_> what was that arrows-based declarative gui library for haskell again?
20:36:44 <jcreigh> so yeah, if I do as sjanssen says, except with firefox, I run into that bug.
20:37:09 <bd_> nm, found it, 'phooey'
20:38:01 <dmwit> jcreigh: I don't see this problem...
20:38:50 <jcreigh> hmm. bugger.
20:39:17 <jcreigh> where do the mouse button grabs happen/
20:39:29 <dmwit> refresh
20:39:45 <sjanssen> refresh isn't called on enternotify
20:40:05 <sjanssen> we need to pull the button/focus stuff into some new function
20:40:10 <dmwit> sjanssen: It is called on safeFocus... in my buggy fix.
20:40:11 <sjanssen> call it refocus
20:40:56 <sjanssen> dmwit: I didn't push that patch because it breaks other stuff (infinite loops sometimes)
20:41:02 <dmwit> Ah, got it.
20:41:07 <kc5tja> hmmm
20:41:15 <kc5tja> it looks like the mouse works only in the primary, left-hand pane.
20:41:19 <dmwit> jcreigh: That is why our behavior is different. =P
20:41:39 <sjanssen> kc5tja: it will work in another window if you mod+j to it
20:42:17 <kc5tja> hmmm
20:42:20 <kc5tja> That's weird.
20:42:35 <jcreigh> kc5tja: yes. a "bug", one might even go so far as to say. :)
20:42:45 <jcreigh> sjanssen: then "refresh" would call "refocus", right?
20:42:53 <dmwit> ugh, I made a real mess with that
20:43:02 <sjanssen> jcreigh: yeah
20:43:04 * kc5tja will see if he can fix that then.  Might as well try.  :)
20:43:11 <kc5tja> Unless you already have the fix.
20:43:17 <sjanssen> and stuff that can't safely call refresh will call refocus instead
20:44:25 <jcreigh> sjanssen: hmm, I'll try that refactor real quick...
20:45:14 * sjanssen <3 contributors
20:51:48 <jcreigh> yay
20:52:52 <sjanssen> jcreigh: patches for my inbox yet?
20:53:12 <jcreigh> not quite yet...but in a couple minutes
20:54:41 <dons> we need an rss feed of changes to xmonad. i find it hard to keep up.
20:54:46 <jcreigh> heh
20:54:48 <dons> or sjanssen should blog ;-)
20:55:11 <sjanssen> dons: it's called darcs pull :)
20:55:27 <jcreigh> actually, a mailing list might be nice for some things...IRC doesn't seem well suited to discussing design descions with many pros and cons to consider..
20:55:43 <sjanssen> yeah, an ML would be cool
20:55:47 <dons> yeah, depends on how long the xmonad code feeding frenzy goes for.
20:56:03 <dons> i could set up a quickie ML, hmm, itd be dons.xmonad@cse...
20:56:17 <dons> we could get a haskell.org one perhaps.
20:56:45 <sjanssen> any free decent free services?
20:56:56 <sjanssen> s/free decent/decent
20:57:14 <dons> xmonad-dev@haskell.org ?
20:58:30 <jcreigh> sjanssen: sent. A simple "refocus" that's called from "refresh" and "safeFocus"
20:58:38 <sjanssen> jcreigh++
20:58:53 <sjanssen> I wouldn't mind having an address to point support emails to
20:59:49 <dons> sjanssen: ok. i'll see if i can get a xmonad@haskell.org addr, eh?
20:59:58 * ddarius considers an email to #haskell converter.
21:00:00 <sjanssen> dons: cool
21:00:08 <jcreigh> I don't know if there's anywhere else we need to call it...I think "safeFocus" took care of most of the cases.
21:00:48 <jcreigh> Is it my imagination or is the Haskell weekly news not...weekly?
21:01:13 <ddarius> jcreigh: You are stuck in a particularly strong gravitational field.
21:01:27 <TSC> Like the magazine the Women's Weekly in Australia
21:01:33 <TSC> It's published monthly
21:01:43 <dons> it is weekly, but depending on conferences and paper deadlines, gravity increases, and time slows down.
21:02:00 <dons> so .e.g POPL in Jan, and ICFP deadline . omg , next friday!!! means no HWN till then, i suspect.
21:03:56 <ddarius> email to hpaste converter should do it...
21:07:05 <hpaste>  jcreigh pasted "xmonad development model :-)" at http://hpaste.org/1190
21:07:17 <araujo> hello around here
21:07:32 <jcreigh> dons: ^^ I kinda feel like that when I do "darcs pull". "What new features do we have today?"
21:07:38 <araujo> dons, also add a small page for xmonad!
21:07:59 <jcreigh> err, that wrapped really badly. oh well.
21:08:02 <dons> jcreigh: right. me too.
21:08:11 <dons> xmonad.org, you mean, araujo ?
21:08:18 <dons> we should redirect that to haskell.org/xmonad ,imo.
21:08:28 <araujo> dons, no, an dyes, i was thinking about haskell.org/xmonad
21:08:31 <dons> and that would just list the src code :-)
21:08:35 <araujo> i meant, a web page for xmonad
21:09:02 <jcreigh> xmonad is a really good name, BTW, as far as Google goes.
21:09:06 <araujo> @where xmonad
21:09:07 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
21:09:10 <Korollary> Hmm. There exists a comp.lang.haskell nowadays.
21:09:15 <jcreigh> The factor WM is named "factory"
21:09:21 <sjanssen> @seen fantasma
21:09:22 <lambdabot> I saw fantasma leaving #haskell 4h 23m 40s ago, and .
21:09:49 <dons> jcreigh: actually, we optimised the name for that ;-)
21:10:57 <jcreigh> so how does darcs know when to stop offering to "darcs send" a patch?
21:11:01 <sjanssen> yeah, me and dons are SEO kingpins
21:11:10 <sjanssen> jcreigh: it checks the inventory of the remote repo
21:12:01 * dmead is away: quake...
21:13:45 <dmwit> ?where xmonad
21:13:46 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
21:17:26 * jcreigh wonders if multiple monitors can broadcast AM better than one...
21:26:34 <sorear> .
21:26:38 <sorear> hello glguy!
21:27:11 <glguy_> hello to you!
21:27:37 <sorear> Why does hpaste truncate now?
21:27:43 <glguy> it has always
21:29:04 <glguy> if you want to host >5K files, hpaste is the wrong place
21:30:39 <sorear> So only the warning is new?
21:30:39 <sorear> where new == several months
21:30:39 <sorear> it wasn't there in the beginning
21:30:53 <glguy> no, in the beginning it truncated at 1K
21:30:57 <glguy> I upped it to 5K
21:31:03 <glguy> the warning is new
21:31:11 <glguy> I didn't want it to be a surprise
21:31:33 <glguy> s/no//
21:31:45 <sorear> ok. more sense now.
21:31:50 <jcreigh> has there been much actual problems with problems with people trying to post huge files?
21:32:01 <sorear> it was mentioned a couple days ago
21:32:07 <jcreigh> s/with problems//
21:32:18 <glguy> jcreigh: some people misunderstood the point of hpaste in the paste
21:32:19 <glguy> past
21:32:27 <glguy> it hasn't been a big deal, however
21:33:16 <Korollary> My symphonies have been truncated.
22:03:12 <sorear> @botsnack
22:03:13 <lambdabot> :)
22:04:42 <dolio> Someone should probably tell paolino that haskell-cafe has received his message, despite the fact that gmail isn't indicating it. :)
22:05:14 <sorear> My reply suggests that he should not sextuple post.
22:05:26 <sorear> Let's hope he doesn't misread my ;-)
22:11:31 <jdrake> Is haskell 'utf-8' aware?
22:11:38 <sorear> define
22:11:47 <sorear> in source code, utf-8 is mandatory
22:11:57 <jdrake> Processing text files
22:11:58 <sorear> inside programs, all strings are unicode
22:12:12 <jdrake> perfect
22:12:13 <sorear> in the standard IO lib, everything is truncated to 8 bits
22:12:26 * sjanssen wants to change that
22:12:37 * sorear wants to see less talk more patches
22:12:42 <jdrake> hmm, that is not so good
22:12:43 <sjanssen> :)
22:12:50 * sorear wants people to do as he says, not as he does
22:12:52 <jdrake> But not bad for what I am trying to do
22:13:25 <sjanssen> jdrake: if you need to do UTF-8 IO google for UTF8.lhs
22:13:33 <sjanssen> that seems to be the standard hack
22:14:18 <jdrake> I am not really in need of it, I am processing a text file as an exercise.
22:15:14 <dolio> > maxBound :: Char
22:15:15 <lambdabot>  '\1114111'
22:17:16 <jdrake> What exactly is the function of 'folding', specifically I do not understand what foldl actually says it is doing.
22:17:52 <sorear> don't use foldl
22:17:52 <glguy> foldl drags an accumulator through a list
22:18:04 <bd_> jdrake: I think http://foldl.com/ and http://foldr.com/ do a good job of explaining it in a perhaps different way
22:18:06 <lambdabot> Title: foldl.com
22:18:10 <sorear> folds reduce lists to summaries
22:18:25 <sorear> > foldr (++) "" ["foo", "bar", "baz"]
22:18:27 <lambdabot>  "foobarbaz"
22:18:29 <ddarius> > foldl (\acc x -> "("++acc++" "++show x++")") "z" [1,3,4]
22:18:31 <lambdabot>  "(((z 1) 3) 4)"
22:18:36 <glguy> while foldr replaces the (:) and [] with a function and a value
22:18:39 <ddarius> > foldl (\acc x -> "(f "++acc++" "++show x++")") "z" [1,3,4]
22:18:39 <bd_> > foldl (flip (:)) [] [1,2,3]
22:18:40 <sorear> > "foo" ++ "bar" ++ "baz" ++ ""
22:18:42 <lambdabot>  "(f (f (f z 1) 3) 4)"
22:18:42 <lambdabot>  [3,2,1]
22:18:43 <lambdabot>  "foobarbaz"
22:19:15 <sorear> gee, jdrake might just understand if we weren't using three different examples at the same time ;)
22:19:19 <jdrake> Too many people trying to say their own thing to me.
22:19:28 <ddarius> @oldwiki WhatIsAFold
22:19:29 <lambdabot> http://www.haskell.org/hawiki/WhatIsAFold
22:19:35 <ddarius> @oldwiki StackOverflow
22:19:36 <lambdabot> http://www.haskell.org/hawiki/StackOverflow
22:19:49 <jdrake> foldr/l.com is a waste of a domain registration
22:19:56 <centrinia> > foldr (\a b -> b++a) ["a", "b", "c", "d"]
22:19:58 <lambdabot>  <[[[Char]]] -> [[Char]]>
22:20:02 <merus> It's cute nonetheless.
22:20:10 <centrinia> > foldr (\a b -> b++a) "" ["a", "b", "c", "d"]
22:20:11 <lambdabot>  "dcba"
22:20:15 <centrinia> > foldl (\a b -> b++a) "" ["a", "b", "c", "d"]
22:20:17 <lambdabot>  "dcba"
22:20:24 <centrinia> That does not make sense. :(
22:20:28 <jdrake> ddarius: that link should be 'WhatIsaFold'
22:20:36 <Cale> centrinia: hm?
22:20:40 <centrinia> Why would foldr and foldl give the same thing for my function? :(
22:20:41 <ddarius> Dart
22:20:45 <ddarius> s/t/n/
22:21:00 <Cale> because ++ is associative
22:21:12 <Cale> a ++ (b ++ c) = (a ++ b) ++ c
22:21:13 <centrinia> But I reversed b and a in ++
22:22:00 <Cale> It's still associative.
22:22:06 <centrinia> Hmmm.
22:22:16 <Korollary> you passed the same b++a to both anyway
22:22:46 <Cale> Let (+++) = flip (++)
22:22:57 <ddarius> No
22:23:26 <Cale> then a +++ (b +++ c) = (c ++ b) ++ a = c ++ (b ++ a) = (b ++ a) +++ c = (a +++ b) +++ c
22:23:45 <centrinia> Ah, that makes sense.
22:24:29 <ddarius> If * is associative then flip (*) is as well.
22:24:52 <Cale> yep
22:25:23 <centrinia> > foldl (+) 0 (1) (1e-17) (1e-18)
22:25:23 <jdrake> What would be the right function to remove list items based on a criteria? (specifically removing specific characters from a string)
22:25:24 <lambdabot>   add an instance declaration for (Num [t -> t1 -> a])
22:25:37 <ddarius> filter?
22:25:40 <centrinia> > foldl (+) 0 (1) (1e-17) (1e-18::Double)
22:25:41 <lambdabot>        add an instance declaration for (Num [t -> Double -> a])
22:25:56 <Cale> > filter isLower "Hello, World!"
22:25:58 <lambdabot>  "elloorld"
22:26:05 <jdrake> ok, that works for me
22:26:11 <centrinia> I know that floating point arithmetic is not associative.
22:26:26 <Cale> foldl takes a list.
22:26:36 <ddarius> centrinia: Neither are most functions.
22:26:38 <jdrake> When readFile says it is "read lazily, on demand" that means it does not use up an ungodly amount of ram right?
22:26:59 <Cale> jdrake: so long as you don't manage to hold on to the whole file
22:27:01 <sjanssen> jdrake: that depends
22:27:47 <jdrake> I am thinking it might be better to use readLn, easier for me to know what it is doing
22:28:04 <ddarius> safer too
22:28:15 <sjanssen> a program like: do f <- readFile; print (length f); putStrLn f -- will use up an ungodly amount of ram
22:28:33 <sorear> jdrake: readFile/readLn consumes 12/20x the size of the file in ram, due to the inefficiency of [Char]
22:28:47 <sorear> jdrake: thats 12 OR 20
22:28:47 <siti> bytestrings ftw ;)
22:28:48 <ddarius> Though lazy IO can be fairly slick upon occasion.
22:28:54 <sorear> jdrake: if you hold on to it all.
22:29:03 <sorear> jdrake: lazy bytestrings are MUCH faster
22:29:23 <sorear> jdrake: and are no more broken than the rest of the IO lib unicodewise
22:29:40 <jdrake> ok, is there a nice easy way of getting started with these
22:30:08 <sorear> dons' blog probably has some good stuff
22:30:14 <sorear> @goo dons blog
22:30:21 <lambdabot> http://www.exc-el.org.uk/content/index.php/main/weblogs/don_s_blog
22:30:22 <lambdabot> Title: Don's Blog / Weblogs / Home - Exc-el :: promoting excellent teaching in East Lot ...
22:30:27 <sorear> byech.
22:31:01 <ddarius> Did you really think that that would work?
22:31:22 <Korollary> @goo dons blog lambdabot
22:31:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:31:23 <lambdabot> Title: lambdabot
22:31:58 <sorear> @tell dons your blog has no history link!
22:31:59 <lambdabot> Consider it noted.
22:35:15 <centrinia> Haskell is one of the easier languages for writing parallel programs. :)
22:39:01 <jdrake> What is the best way to ensure that I don't have ambiguous things when using Data.ByteString?
22:40:04 <dons> import qualified ...
22:40:05 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
22:40:54 <jdrake> Is there any null expression that is good at the end of a do?
22:41:11 <centrinia> return ()
22:41:15 <jdrake> k
22:43:19 <hpaste>  jdrake pasted "import qualified" at http://hpaste.org/1191
22:43:38 <jdrake> When doing that, why is :t main an IO String instead of a ByteString?
22:46:02 <Korollary> ?type readFile
22:46:05 <lambdabot> FilePath -> IO String
22:46:55 <Korollary> ?type Data.ByteString.readFile
22:46:58 <lambdabot> FilePath -> IO Data.ByteString.Base.ByteString
22:47:24 <Korollary> You need to qualify your usage
22:47:44 <jdrake> dons indicated above about 'import qualified', but I do not otherwise know what that means.
22:47:54 <dcoutts> jdrake: main but always be IO (), not IO String or anything else
22:48:07 <dcoutts> jdrake: import qualified Data.ByteString as ByteString
22:48:21 <Korollary> dcoutts: iirc, the standard says 'IO a' ;)
22:49:06 <Korollary> jdrake: He maybe didn't understand what you meant by ambiguous.
22:49:38 <jdrake> I think he did, because the statement got rid of the ambiguity that was being flagged.
22:51:18 <Korollary> jdrake: When you import a module qualified, you need to refer to its symbols with the module name as a prefix.
22:51:38 <dons> jdrake: sorry, yes, the missing bit was the ... part
22:51:41 <dons> import qualified Data.ByteString as S
22:51:44 <dons> is what I usually do
22:51:52 <dons> then you have, S.putStr S.map and so on
22:54:19 <jdrake> ok, now when I do it :t main is main :: IO ByteString.ByteString
22:54:38 <jdrake> Would that be the right thing?
22:55:02 <Korollary> Are you trying to print the contents out?
22:55:19 <dons> main should really be :: IO ()
22:55:21 <jdrake> No, just return it to make sure it is being of the right thing
22:55:25 <dons> with a S.putStr or something at the end.
22:55:38 <jdrake> dons: It is not being used like that for real, just testing
22:59:49 <jdrake> Is it just me or are the documented functions sometimes hard to actually understand what they are trying to say?
23:00:22 <jdrake> This for example: or returns the disjunction of a Boolean list. For the result to be False, the list must be finite; True, however, results from a True  value at a finite index of a finite or infinite list.
23:00:23 <dibblego> it's not just you
23:00:48 <dibblego> that makes perfect sense to me however
23:00:54 <ddarius> What's hard to understand there?
23:01:06 <jdrake> I have no idea what a disjunction of a Boolean list is.
23:01:15 <dibblego> disjunction is 'or'
23:01:39 <dibblego> the disjunction of [True, False, False] is True
23:01:55 <jdrake> Is it essentially, it is True if any of its members are True.
23:02:02 <dibblego> yes
23:02:13 <dibblego> so you see clearly that False is only possible on a finite list
23:02:18 <jdrake> It would be quite helpful if it were to infact just say that.
23:02:22 <dibblego> it does
23:02:28 <sjanssen> the actual code is much easier to read and immediately understand
23:02:30 <ddarius> > or (repeat False ++ [True])
23:02:35 <lambdabot> Terminated
23:02:38 <jdrake> dibblego: I am not a computer scientist.
23:02:47 <sjanssen> @type let or = foldr (||) False in or
23:02:48 <dibblego> I learned what disjunction means at school
23:02:50 <lambdabot> [Bool] -> Bool
23:02:52 <dibblego> when I was about 14
23:02:57 <dibblego> you don't need to be a computer  scientist
23:03:06 <jdrake> dibblego: What class was that?
23:03:11 <dibblego> mathematics
23:03:18 <dibblego> it's in the first chapter of my text iirc
23:03:22 <dibblego> under first-order logic
23:03:23 <jdrake> That must be some special mathematics then.
23:03:38 <dibblego> hardly
23:03:41 <ddarius> jdrake: It's just vocabulary.
23:03:41 * kc5tja could never get the differences between conjunction and disjunction down pat.
23:03:54 <jdrake> You learned that in mathematics at that age?
23:03:54 * kc5tja always thought in terms of "and" and "or".
23:04:02 <dibblego> sure
23:04:22 <dibblego> maybe
23:04:24 <dibblego> I forget :)
23:04:30 <ddarius> kc5tja: You don't understand what someone means, in normal English, when the say something like "a conjunction of circumstances"?
23:04:51 <jdrake> ddarius: I am not sure I do.
23:05:12 <jdrake> Probably because nobody around here would ever speak like that.
23:05:17 <dibblego> conjunction is 'and'
23:05:21 <kc5tja> ddarius: I honestly never heard that expression before until now.  However, I can figure it out with some conscious thought.
23:05:36 <dibblego> if the conjunction of a list is True, then the list is finite
23:05:50 <ddarius> jdrake: People never say anything like "a disjunction of circumstances"...
23:06:17 <kc5tja> ddarius: Don't be so quick -- that expression makes perfect sense too.  :)
23:06:22 <kc5tja> (with some thought)
23:06:31 <kc5tja> And it'd make a kick butt title to a novel.
23:06:31 <ddarius> kc5tja: Yes, it does, but people don't say it.
23:06:33 <jdrake> I am thinking that the library documents would be very much easier to read (and thus more accessible) if it were written in more common language.
23:06:36 <dibblego> there is also http://en.wikipedia.org/wiki/Grammatical_conjunction
23:06:37 <lambdabot> Title: Grammatical conjunction - Wikipedia, the free encyclopedia
23:07:12 <ddarius> jdrake: Anyway, my initial comment was sarcastic.  I do agree with you, even though I do understand the definition of or with no trouble.
23:07:45 <kc5tja> Yeah, I've heard of grammatical conjunctions, but I've always envisioned them as being the butting of two pieces of syntax end-to-end to form a single concept (a AND b, a OR b, etc, where AND and OR are "grammatical conjunctions").
23:08:21 <kc5tja> ddarius: Well, it gets me confused periodically, because I just don't think in those terms.
23:08:37 <dibblego> I think in terms of the little symbols
23:09:13 <kc5tja> dibblego: /\ and \/ and their set-notation rounded equivalents?
23:09:31 * kc5tja really wishes those, and the `elem` symbol, were part of standard ASCII.
23:09:34 <jdrake> I am having a slight mental block - I need to filter out certain characters. From my thoughts, I believe I have to use filter, and thus have something to tell it what *is* valid. Is there an easy way of doing so without writing all the letters of the alphabet? (I am also thinking of using 'any', but I am kind of getting caught up in the presentation of the definition).
23:09:40 <dibblego> kc5tja, yeah that :)
23:09:48 <dibblego> kc5tja, me too
23:10:08 <kc5tja> See, to me /\ is *and*.  ;D Hahah  I guess I've just grown up reading the wrong books.
23:10:09 <ddarius> :t filter . not
23:10:12 <lambdabot>     Couldn't match expected type `a -> Bool'
23:10:12 <lambdabot>            against inferred type `Bool'
23:10:33 <sjanssen> jdrake: you have a list of characters that you want to get rid of?
23:10:41 <jdrake> It is also the ByteString filter.
23:11:31 <jdrake> sjanssen: I am thinking it might be safer to specify what I do want to keep, which is [A-Za-z0-9\'] in some form of regex :p
23:11:39 <sjanssen> > filter (not . (`elem` "aeiou")) "this is some sample text"
23:11:41 <lambdabot>  "ths s sm smpl txt"
23:11:46 <dons> .. filter (\x -> x `elem` "aeiou") ..
23:11:50 <dons> ah yes, as sjanssen says :-)
23:11:53 <ddarius> Somehow "/\c:circumstances.c" does not have the same ring.
23:11:59 <dons> see also notElem.
23:12:11 <jdrake> What is `elem` doing
23:12:22 <dibblego> ?src elem
23:12:23 <lambdabot> elem x    =  any (== x)
23:12:26 <sjanssen> jdrake: the ` turns on infix syntax
23:12:29 <kc5tja> sjanssen: I tried to peruse the xmonad source, and find out why clicking a window isn't setting the focus of a window, but the code to make it happen is there, as is focus-follows-mouse.
23:12:55 <ddarius> That definition is actually very readable.
23:13:02 <jdrake> ok, I will give this a shot
23:13:03 <dibblego> ?src any
23:13:04 <lambdabot> any p =  or . map p
23:13:05 <kc5tja> This seems to be one of those debugging issues like my CUT parser, where it's chomping the tail-end of its input stream instead of continuing to parse it.
23:13:14 <sjanssen> jdrake: by writing (`elem` x), I'm saying use x as the second parameter
23:13:15 <kc5tja> Despite the equations not expressing it.
23:13:21 <ddarius> That is less so.  Understandable, but less readable.
23:13:25 <sjanssen> kc5tja: you're running the latest code and all that?
23:13:35 <kc5tja> sjanssen: I just grabbed it before coming home from work.
23:13:39 <kc5tja> So it's a few hours old.
23:13:45 <jdrake> :t any
23:13:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
23:14:08 <dibblego> > let f x = x `elem` "aeiou" in f "are any (disjunctive) of these characters a vowel?"
23:14:09 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
23:14:17 <dibblego> bleh
23:14:17 <jdrake> When I see (a -> Bool) in there, I know it is a function taking any type and returning a Bool, but in the actual use of that I get lost.
23:14:22 <sjanssen> kc5tja: you probably want to pull again
23:14:26 <ddarius> any p xs -- Does any element of xs satisfy the predicate p.
23:14:30 <kc5tja> Was the bug fixed?
23:14:47 * kc5tja is smack in the middle of a Miles Davis album.  Now is not a good time to restart X.  :D
23:15:02 <sjanssen> click to focus works for me.  If you have steps to reproduce it let me know
23:15:08 <sjanssen> kc5tja: oh, which album?
23:15:10 <kc5tja> Yeah.
23:15:13 <kc5tja> sjanssen: Kind of Blue.
23:15:17 <dibblego> > let f x = x `elem` "aeiou" in f 'a' -- is 'a' a vowel?
23:15:19 <lambdabot>  True
23:15:21 <kc5tja> Step 1.  open xterm
23:15:25 <kc5tja> 2.  Open another.
23:15:27 <sjanssen> kc5tja: understandable
23:15:30 <kc5tja> err
23:15:39 <kc5tja> 2.  Open something like Gimp or xmms
23:15:50 <kc5tja> 3.  Set focus on the xterm.
23:15:54 <jdrake> Is there any way of doing ["A".."Z"] validly?
23:15:56 <kc5tja> 4.  Click any button in Gimp, etc.
23:16:04 <ddarius> > ['a'..'z']
23:16:05 <sjanssen> we also have alt+shift+F12 to restart xmonad
23:16:05 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
23:16:25 <jdrake> ah, single quotes?
23:16:26 <sjanssen> it'll shuffle your windows around, but everything will remain running
23:16:44 <kc5tja> I can't install over the currently running binary though.
23:16:56 <sjanssen> kc5tja: make sure xmonad is in your PATH before you try the restart thing
23:16:59 <dons> rm -f `which xmonad` ; ... install ...
23:17:10 <jdrake> >['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9']
23:17:17 <kc5tja> dons: Of course; hence my comment about needing to restart X.  :)
23:17:20 <jdrake> > ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9']
23:17:21 <lambdabot>  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
23:17:22 <dons> :-)
23:17:32 <dons> > ['a' ..]
23:17:33 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
23:18:22 <kc5tja> sjanssen: I'm using GoboLinux; programs placed in /Programs/whatever will get symlinked into the path automatically.
23:18:48 <jdrake> What is the best way to have a single function call that happens to be long, on multiple lines without ugliness?
23:18:56 <sjanssen> kc5jta: just a warning, I don't want to kill Freddie Freeloader or anything
23:19:04 <ddarius> "where"
23:19:13 <kc5tja> sjanssen: Very true.  It's almost done.
23:19:52 <kc5tja> But, for example, I have noatun running, and I just can't click on any buttons.  It sees mouse events, but ButtonEvents aren't propegated to the window.
23:19:56 <kc5tja> So far as I can tell, at least.
23:20:08 <ddarius> jdrake: If it's highly structured there are ways, otherwise break it apart and name the substeps.
23:20:15 * kc5tja checks there...
23:20:22 * kc5tja hadn't thought to check the ButtonPress handler.
23:20:26 <Cale> jdrake: perhaps align the parameters to the function vertically
23:20:32 <sjanssen> kc5tja: yeah, that's fixed in the new code
23:20:43 <jdrake> filter (not . (`elem` ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'])) fileData
23:20:59 <jdrake> hmm, I think I know what to do
23:21:31 <ddarius> jdrake: Use notElem and name that list.
23:21:43 * kc5tja does a darcs diff to see how...
23:22:08 <kc5tja> ummm
23:22:18 <kc5tja> it looks like I already have the correct version, if darcs diff is to be believed.
23:22:28 <jdrake> :t notElem
23:22:31 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
23:22:37 <kc5tja> kc5tja@aldeberan ~/xmonad]darcs diff
23:22:38 <kc5tja> diff -rN old-xmonad/Config.hs new-xmonad/Config.hs
23:22:38 <kc5tja> 71c71
23:22:38 <kc5tja> <     [ ((modMask .|. shiftMask, xK_Return), spawn "xterm")
23:22:38 <kc5tja> ---
23:22:40 <kc5tja> >     [ ((modMask .|. shiftMask, xK_Return), spawn "xterm -fg white -bg black")
23:22:41 <lambdabot>  Parse error
23:22:43 <kc5tja> kc5tja@aldeberan ~/xmonad]
23:23:01 <sjanssen> kc5tja: the change isn't in Config.hs
23:23:07 <kc5tja> No, of course not.
23:23:13 <kc5tja> It'd be in Main.hs or Operations.hs.
23:23:36 <kc5tja> Although, black-on-white xterms should be considered an offense worthy of hanging.  :)
23:23:46 <jdrake> Does notElem cover not . (`elem` [...])
23:23:56 <ski> > ['\255'..]
23:23:57 <lambdabot>  "\255\256\257\258\259\260\261\262\263\264\265\266\267\268\269\270\271\272\27...
23:24:09 <sjanssen> kc5tja: the very last patch you have is "* refactored "focus changed" code into "refocus""
23:24:13 <sjanssen> ?
23:25:25 <jdrake> If I do a where clause, can I define things in there where clause that are used in the where clause?
23:25:37 <sjanssen> yep
23:29:16 <kc5tja> I have that too; but I don't see how it fixes the problem.
23:29:22 * kc5tja is compiling shortly.
23:31:53 <hpaste>  jdrake annotated "import qualified" with "The last statement in a 'do' construct must be an expression" at http://hpaste.org/1191#a1
23:31:59 <jdrake> Unsure about this one
23:32:02 <jdrake> Probably something stupid
23:32:19 <sjanssen> jdrake: looks like layout
23:32:31 <sjanssen> try indenting the where one more level
23:32:40 <jdrake> Ignore some at the top, it pasted in there wrong
23:32:56 <jdrake> So that where is lining up with the allowed = ?
23:33:23 <sjanssen> are you using tabs?
23:33:59 <hpaste>  jdrake annotated "import qualified" with "nice big error now" at http://hpaste.org/1191#a2
23:34:09 <jdrake> sjanssen: No, spaces
23:35:06 <Cale> jdrake: you're concatenating a list with a Char
23:35:16 <Cale> that should be "\'"
23:35:34 <hpaste>  sjanssen annotated "import qualified" with "this gets more interesting errors :)" at http://hpaste.org/1191#a3
23:36:45 <hpaste>  jdrake annotated "import qualified" with "shorter error now" at http://hpaste.org/1191#a4
23:36:57 <kc5tja> Sure 'nuff, it fixed the bug.
23:37:04 <kc5tja> Though, I still don't know what it's doing to do it.
23:37:04 <kc5tja> :)
23:37:19 * kc5tja will have to ask jcreigh tomorrow.
23:37:21 <kc5tja> Bedtime for me.
23:37:28 <sjanssen> we weren't changing the button listening on EnterNotify
23:37:38 <sjanssen> this patch changes that
23:37:55 <Cale> jdrake: (`notElem` allowed)
23:38:15 <Cale> and possibly using Data.ByteString.Char8
23:38:17 <kc5tja> sjanssen: Shouldn't that be something the applications manage though?
23:38:30 <jdrake> Cale, how do I get it to use Char8?
23:38:40 <Cale> Import Data.ByteString.Char8
23:38:46 <sjanssen> kc5tja: xmonad steals the button click events -- we have to give them back
23:39:00 <Cale> (that is, just tack ".Char8" on to the end of your existing import)
23:39:31 <kc5tja> sjanssen: I'll review tomorrow after some rest.  But now that that issue is fixed, I think this is a wm I can use for regular use now.
23:39:34 <jdrake> ok, it compiles
23:39:53 <jdrake> So what exactly did this do
23:40:44 <Cale> well, Data.ByteString is a string of Word8's, which are unsigned integers
23:41:11 <Cale> Data.ByteString.Char8 will let you work with Chars. (those representable with 8 bits)
23:42:24 <fuzan> what's the name of the portage-alternative written in haskell?
23:42:34 <fuzan> can't seem to find it on the goog.
23:43:18 <jdrake> It appears my thing doesn't work quite right, I haven't looked at the output data, but the size of it is 79340 going in, and 5623 coming out. So, this shall be fun - for tomorrow.
23:43:22 <jdrake> Bed time tonight.
23:43:27 <jdrake> I thank all of you for your help.
23:45:19 <jdrake> `notElem` is definitely working backwards to what I need
23:46:09 <jdrake> `elem` will work, but I must get newlines to stay
23:54:09 <gour> fuzan: exi ?
23:55:13 <fuzan> gour: yah. i just found it too :)
23:55:16 <fuzan> gour: thanks
23:55:20 <gour> fuzan: or himerge too
