00:00:03 <nmessenger> I didn't understand it before, I've had no real training in this stuff.
00:00:20 <ski> join ((a:_):ass) = a : join (map tail ass)
00:00:24 <nmessenger> But it looks right, yes, for infinites.
00:01:04 <ski> > let join ((a:_):ass) = a : join (map tail ass) in take 10 (join [[(x,y) | y <- ['a'..]] | x <- [0..]])
00:01:06 <lambdabot>  [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g'),(7,'h'),(8,'i'),(9,...
00:01:34 <nmessenger> so join is "zip-like" the way (<*>) is?
00:01:57 <ski> yes
00:02:07 <nornagon> nmessenger: it's using a Map now
00:02:19 <nornagon> *MPC> withMPD (liftIO.print =<< currentsong)
00:02:22 <nornagon> fromList [("Id","573"),("Pos","10"),("Time","0"),("Title","^Music Is My Remedy^"),("file","mod/a-remedy.it")]
00:02:25 <ski> since '(<*>)' is 'liftM2 ($)' for monads
00:02:33 <nmessenger> right.
00:02:48 <ski> and 'liftM2' will "zip" in this monad
00:03:02 <ski> so, assume we have
00:03:09 <ski> [[0,1,2,3,4]
00:03:16 <ski> ,[5,6,7]
00:03:20 <nmessenger> wait, I understand how (<*>) works in ZipList, I'll have to try coming the other way 'round, deriving (<*>) from this join and map :)
00:03:25 <ski> ,[8,9,10,11,12,13]
00:03:31 <ski> ,[14,15]
00:03:41 <ski> ,[16,17,18,19,20,21,22]
00:03:45 <ski> ,[23,24,25]
00:03:45 <ski> ]
00:04:03 <ski> what should 'join' give here ?
00:04:10 <nmessenger> my intuition is that [14,15] will cause a null error
00:04:31 <ski> yes, so even if rows after that is long enough, the 'join' will be over by then
00:04:40 <ski> a list can't "skip" some elements
00:05:04 <nmessenger> [0,6,10,_|_,19,_|_]?
00:05:07 <ski> recall that since we're zipping, the exact position in the lists are important, so we can't just leave out missing elements
00:05:14 <ski> so, i'd say
00:05:17 <ski> [0,6,10]
00:05:50 <ski> if you want, you can say that we have an 'uncons :: [a] -> Maybe (a,[a])' and this fails in the '[14,15]' row
00:06:04 <ski> so later rows will not be tried
00:06:31 <ski> (i believe we should not have to resort to partial values like '_|_' here ..)
00:07:31 <ski> if you want '_|_' for missing elements, then why not '[0,6,10,_|_,19,_|_,_|_,_|_,...]' ?
00:07:49 <ski> the rows after '[23,24,25]' are missing, too
00:08:24 <nmessenger> would the truncation preserve the behavior of ap as defined in terms of liftM (in terms of (>>=) (in terms of join and map))?  I'd need to check step-by-step.
00:08:47 <ski> yes, that would be a good idea
00:09:28 <nmessenger> gr, I didn't want to do *actual* work, just absorb information that others had already worked on :P
00:09:39 * ski chuckles
00:09:53 <ski> well, we want some laws to hold, anyway
00:10:00 <ski> join . return = id
00:10:05 <nmessenger> yes
00:10:05 <ski> join . map return = id
00:10:49 <ski> would these seem to hold, informally, in my (or your) hopefully-reasonable extension of the infinite-case definition of 'join' ?
00:11:09 <ski> say
00:11:11 <ddarius> Prove them.
00:11:36 <ski> ddarius : yes, i'm going to try that, just after i've tried some simple cases :)
00:12:06 <ski> (join . return) [0,1,2]
00:12:32 <ski> = join [[0,1,2]
00:12:36 <nmessenger> I've seen the monad laws given in terms of (>>=) and return in the report, what do the full compliment look like in terms of join and map?
00:12:37 <ski>        ,[0,1,2]
00:12:38 <ski>        ,[0,1,2]
00:12:40 <ski>        ,[0,1,2]
00:12:43 <ski>        ,...
00:12:45 <ski>        ]
00:12:58 <nmessenger> = [0,1,2]
00:13:14 <ski> yes
00:13:35 <ski> nmessenger : those two above laws (the "identity" laws), plus an "associativity" law
00:13:45 <nmessenger> what's it look like?
00:13:51 <ddarius> join . return = join . map return  = id; join . map join = join . join
00:13:58 <nmessenger> oh wait I may have seen it, yeah that's it
00:13:59 <ski> (the natural transformation laws should hold automatically, provided we're not doing evil things like 'seq')
00:14:06 <ddarius> @type join . map join
00:14:08 <lambdabot> forall a. [[[a]]] -> [a]
00:14:11 <ski> what ddarius said
00:14:17 <ddarius> @type join . join
00:14:19 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m a)) -> m a
00:14:34 <nmessenger> @type join . liftM join -- for general monads
00:14:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
00:14:42 <ddarius> fmap
00:15:11 <nmessenger> that would introduce Functor m =>, since Monad doesn't subclass Functor in the implementation :/
00:15:12 <ski> the "associativity" law says that it should not matter if we start by collapsing the outer two 'm', or the inner two 'm' first
00:15:32 <nmessenger> yes, I understood it when I saw it once before.
00:15:35 <ddarius> nmessenger: Good, because we also need the functor laws.
00:15:50 <ddarius> fmap id = id; fmap (f . g) = fmap f . fmap g
00:16:33 <nmessenger> oh yeah!  them.
00:17:03 <ski> (i think the functor laws are implied by the monad laws in the 'return','(>>=)' formulation)
00:17:47 <ski> anyway, we can't do squat until we'd defined 'join'
00:17:50 <nmessenger> (side note, when someone says "class A implies B" does that mean "class A a => B a" or "class B a => A a" in Haskell syntax?)
00:18:02 <nornagon> gr, records infest my namespace :(
00:18:07 <ddarius> the latter
00:18:12 <ski> nmessenger : the latter :/ ..
00:18:20 <nmessenger> :/ counterintuitive!
00:18:25 <ski> .. (which is why i don't like the use of '=>' in that way there)
00:18:59 <ddarius> Yeah, that has been noted for many years
00:19:02 <nmessenger> Monad would imply Functor
00:19:21 <nornagon> records suck!
00:19:27 <nmessenger> (as makes sense intuitively to me, but as the notation disagrees)
00:24:04 <sebell> ToRA: ping
00:24:05 <philipta> Hey, suppose I have data Things = A | B | C | D deriving (Enum); things = enumFrom A
00:24:49 <philipta> I have a function permute2 a = filter (uncurry (/=)) (concat [[(x,y) | y <- a] | x <- a, ]) that returns every non-reflexive pair
00:25:02 <philipta> But there's got to be a better way to write that
00:25:38 <sjanssen> permute2 a = [(x, y) | x <- a, y <- a, x /= y]
00:26:16 <philipta> Where can I read about what-all I can do using the list comprehension syntax?
00:26:26 <philipta> Cause that's just beautiful
00:26:44 <dmwit_> philipta: That's pretty much it. =)
00:26:51 <sjanssen> there should be a section in whichever tutorial/book you're learning from
00:27:25 <sjanssen> and yeah, that example is practically the whole enchilada
00:27:30 <philipta> It only gives an example: it doesn't give the full syntax. In particular, it didn't tell me I could use a comma. :)
00:27:33 <philipta> OK
00:27:46 <sjanssen> philipta: oh, what're you using?
00:28:49 <philipta> The haskell wikibook and YAHT. I may not be looking in the right place in the YAHT book--that's happened several times now.
00:29:25 <sjanssen> there's probably more info in a later section
00:30:19 <dmwit_> I used A Gentle Introduction to Haskell.  Guess what.  Not gentle.
00:31:09 <philipta> Is the list comprehension syntactic sugar for some function calls?
00:31:18 <ddarius> Yes
00:31:20 <sjanssen> philipta: it is indeed
00:31:36 <ddarius> Incidentally, essentially the same ones as do notation
00:32:47 <philipta> What would permute2 look like sans sugar?
00:32:47 <hpaste>  sebell pasted "Should be in Parsec?" at http://hpaste.org/979
00:32:47 <ddarius> [(x,y) | x <- a, y <- a, x /= y] <=> do x <- a; y <- a; guard (x /= y); return (x,y)
00:32:47 <ddarius> philipta: concatMaps and filter
00:32:47 <dmwit_> Huh, does that generalize to other monads?
00:32:47 <ClaudiusMaximus> > let a = [1..3] in catMaybes ( liftM2 (\x y -> case x == y of True -> Nothing ; False -> Just (x,y) )  a a ) -- another way
00:32:47 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
00:33:05 <ddarius> dmwit_: List comprehensions used to be monad comprehensions, but they decided to specialize it in Haskell 98
00:33:16 <dmwit_> Really?  Why?
00:33:32 <sjanssen> concatMap (\x -> concatMap (\y -> if x /= y then [(x, y)] else []) a) a -- approximately
00:33:34 <ddarius> dmwit_: It generated ambiguous type errors that were confusing to beginners.
00:33:56 <dmwit_> Aah.
00:34:15 <dmwit_> Still, that's kind of a neat idea.
00:34:31 <audreyt> are there existing RSS1/RSS2/Atom parsers written in Hs?
00:34:31 <lambdabot> audreyt: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:34:50 <ddarius> Probably
00:34:52 <ski> > let consM Nothing = []; consM (Just (a,as)) = a:as; unConsM [] = Nothing; unConsM (a:as) = Just (a,as); join ass = consM $ do (as,ass) <- unConsM ass; (a,_) <- unConsM as; return (a,join . map fromJust . takeWhile isJust . map (liftM snd . unConsM) $ ass) in join [[0,1],[2,3]] -- (headM =<< headM ass,join . map fromJust . takeWhile isJust . map tailM $ ass)
00:34:53 <lambdabot>  [0,3]
00:34:54 <ddarius> @where hrss
00:34:55 <lambdabot> I know nothing about hrss.
00:35:01 <ski> > let consM Nothing = []; consM (Just (a,as)) = a:as; unConsM [] = Nothing; unConsM (a:as) = Just (a,as); join ass = consM $ do (as,ass) <- unConsM ass; (a,_) <- unConsM as; return (a,join . map fromJust . takeWhile isJust . map (liftM snd . unConsM) $ ass) in join [[0,1],[2,3],[4,5,6],[7,8],[9,10,11,12]]
00:35:02 <lambdabot>  [0,3,6]
00:35:10 <audreyt> gotcha.
00:36:02 <ClaudiusMaximus> > let a = [1,2] in catMaybes ( liftM3 (\x y z -> case x == y || y == z || z == x of True -> Nothing ; False -> Just (x,y,z) )  a a a )
00:36:03 <lambdabot>  []
00:36:22 <ClaudiusMaximus> > let a = [1,2,3] in catMaybes ( liftM3 (\x y z -> case x == y || y == z || z == x of True -> Nothing ; False -> Just (x,y,z) )  a a a )
00:36:23 <lambdabot>  [(1,2,3),(1,3,2),(2,1,3),(2,3,1),(3,1,2),(3,2,1)]
00:36:40 <philipta> that's AWESOME.
00:37:23 <ski> > let a = [1,2,3] in catMaybes ( liftM3 (\x y z -> do guard (not (x == y || y == z || z == x)); return (x,y,z)) a a a)
00:37:25 <lambdabot>  [(1,2,3),(1,3,2),(2,1,3),(2,3,1),(3,1,2),(3,2,1)]
00:42:21 <philipta> @src uncurry
00:42:21 <lambdabot> uncurry f p = f (fst p) (snd p)
00:43:59 <ski> uncurry f ~(x,y) = f x y
00:46:20 <philipta> ski: ooooooh
00:46:37 <philipta> that lets me write uncurry4
00:47:26 <sjanssen> > uncurry (const $ const ()) undefined
00:47:27 <lambdabot>  ()
00:47:44 <philipta> what the heck is that?
00:48:33 <sjanssen> I wanted to know if the real definition uses the ~ match on the tuple (and it does)
00:50:36 <ddarius> sjanssen: Modulo seq it'd better
00:52:54 <ClaudiusMaximus> > let isUniq q = length q == length (nub q) in (\l -> filter (isUniq) (liftM5 (\a b c d e -> [a,b,c,d,e]) l l l l l)) "abcde" -- taken to extremes...
00:52:55 <lambdabot>  ["abcde","abced","abdce","abdec","abecd","abedc","acbde","acbed","acdbe","ac...
00:56:25 <QtPlatypus> @type nub
00:56:28 <lambdabot> forall a. (Eq a) => [a] -> [a]
00:56:41 <QtPlatypus> @src nub
00:56:41 <lambdabot> nub = nubBy (==)
00:56:51 <QtPlatypus> @src nubBy
00:56:51 <lambdabot> nubBy eq []             =  []
00:56:51 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:58:15 <QtPlatypus> > nub [1,2,3]
00:58:16 <lambdabot>  [1,2,3]
00:58:28 <QtPlatypus> > nub [1,2,3,3]
00:58:29 <lambdabot>  [1,2,3]
00:59:11 <ClaudiusMaximus> > nub "why isn't there a liftM6?"
00:59:12 <lambdabot>  "why isn'teralfM6?"
00:59:54 <QtPlatypus> >nub "The quick red fox jumped over the lazy brown dog"
01:01:10 * QtPlatypus broke Lambda?
01:01:14 <nornagon> > nub "The quick brown fOx jumps ovEr the lazy dog"
01:01:15 <lambdabot>  "The quickbrownfOxjmpsvEtlazydg"
01:01:22 <nornagon> QtPlatypus: needs spaces
01:01:27 <nornagon> between > and code
01:07:50 <zeeeee> any reason why runghc insists on the script ending in .hs? any workarounds?
01:10:04 <philipta> Can I ask lambdabot to convert a function into pointsfree style?
01:10:53 <ClaudiusMaximus> @pl (\x y z -> x + y - z)
01:10:54 <lambdabot> ((-) .) . (+)
01:11:33 <philipta> @pl (\a b -> (<) (fromEnum a) (fromEnum b))
01:11:33 <lambdabot> (. fromEnum) . (<) . fromEnum
01:12:42 <philipta> Kooky!
01:13:36 <newsham> > (sort.map toLower.nub) "The quick brown fOx jumps ovEr the lazy dog"
01:13:37 <lambdabot>  " abcdeefghijklmnoopqrsttuvwxyz"
01:13:54 <newsham> > take 8 $ nubBy (\a b -> b `mod` a == 0) [2..]
01:13:56 <lambdabot>  [2,3,5,7,11,13,17,19]
01:15:29 <jdkk> hi
01:17:00 <jdkk> what's the recommended alternative to Text.Regex.Posix. I hear that their usage is discouraged because they are very slow and too strict.
01:19:13 <jdkk> > sum (map ord "al gore")
01:19:14 <lambdabot>  666
01:20:26 <TSC> How inconvenient
01:21:30 <jdkk> TSC: eheh
01:22:25 <jdkk> what's the recommended alternative to Text.Regex.Posix. I hear that their usage is discouraged because they are very slow and too strict.
01:29:18 <ski> philipta : hm ?
01:29:37 <philipta> what's that?
01:29:48 <ski> <philipta> that lets me write uncurry4
01:30:03 <ski> (couldn't you anyway .. ?)
01:30:14 <philipta> oh--I didn't quite grok the syntax until that example. :)
01:30:29 <ski> syntax of '~' ?
01:30:33 <philipta> Yeah
01:30:36 <ski> ok
01:42:36 <augustss> > sum $ map ord "Al Gore"
01:42:37 <lambdabot>  602
01:45:10 <siti> pfft lower case :p
01:49:27 <ski> someone should write a program to help gematrians and numerologists in finding just the transformation to get the desired result
01:50:56 <opqdonut> > sum $ map ord "algore"
01:50:57 <lambdabot>  634
01:51:02 <opqdonut> yeah it's kinda fabricated
01:51:15 <quicksilver> > sum $ map ord "al gore"
01:51:16 <lambdabot>  666
01:51:55 <opqdonut> quicksilver: yeah we got that already
01:52:24 <philipta> Thanks for all the insight guys. Night.
02:02:21 <dons> ?yow
02:02:21 <lambdabot> LOOK!!  Sullen American teens wearing MADRAS shorts and "Flock of
02:02:21 <lambdabot> Seagulls" HAIRCUTS!
02:03:09 * araujo `catch` dons 
02:07:34 * dons `handle` (\e -> return araujo)
02:07:34 <araujo> haha
02:14:02 <dons> mmm http://programming.reddit.com/info/1an4y/comments
02:14:03 <lambdabot> Title: How to make Data.Set a monad (reddit.com)
02:34:38 <Cheery> Is there other things than lambda calculus where things to calculate would be first-class?
02:36:21 <Cheery> like, algebra where 'numbers' would be algebraic sentences themselves.
02:37:33 <gh_> can't we type directly (data)types in ghci ?
02:37:52 <gh_> or is there a special syntax different from the usual one ?
02:39:21 <dons> nope, you have to load them from a file
02:39:27 <dons> ghci is basically a do-block
02:39:34 <dons> so you can type in monadic expressions, and other do notation stuff
02:40:04 <gh_> hmm ok
02:40:10 <gh_> i didn't know that
02:40:15 <gh_> thanks
02:40:22 <gh_> (that sucks! :) )
02:44:31 <DRMacIver> One of the things I miss in using Haskell over ML is the quality of the repl environment.
02:44:47 <araujo> I find the repl very nice
02:44:52 <DRMacIver> ghci is still very very useful for testing.
02:45:21 <DRMacIver> But with most ML environments you can basically cut and paste your entire module into the interpreter and expect it to work. :)
02:46:18 <araujo> You need to think of the ghci , like a function
02:46:28 <araujo> You don't define data types inside functions
02:46:30 <DRMacIver> You're missing the point.
02:46:37 <DRMacIver> It's not that I don't understand and like ghci.
02:46:38 <araujo> I think that keeps consistency
02:46:53 <DRMacIver> It's that ML's repls are still way better. :)
02:47:25 <DRMacIver> This is mainly because Haskell would be very difficult to make work in that manner.
02:48:15 <dons> mutually recursive bindings, for one. unevaluated thunks, for another. we could probably do better though
02:48:27 <DRMacIver> Yeah
02:48:40 <DRMacIver> It's not the end of the world. ghci is still good enough once you get used to it.
02:49:19 <quicksilver> I wish it did better when loading a file with errors
02:49:27 <DRMacIver> But I think it gives ML an advantage for quick prototyping tasks.
02:49:47 <quicksilver> I wish, for example, it loaded all the definitions which weren't part of the mutually recursive group containing the error
02:49:59 <mux> dons: it would be nice if we could define types in LB with @data and @newtype :-)
02:50:25 <mux> binding them to some specific namespace like for @let
03:00:18 <jdkl> what's a fast and recommended alternative to Text.Regex.Posix?
03:00:33 <ben_m> Hi there :) Can anyone recommend a good haskell tutorial?
03:00:39 <Cale> sure
03:00:44 <opqdonut> !where yaht
03:00:45 <balodja> hi, is there any russian-speak channels about haskell on freenode?
03:00:52 <Cale> YAHT is pretty good, and the Wikibook as well
03:00:57 <opqdonut> @where yaht
03:00:57 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
03:01:02 <opqdonut> ^^^ ben_m
03:01:10 <Cale> @where wikibook
03:01:10 <lambdabot> http://en.wikibooks.org/wiki/Haskell
03:01:11 <ben_m> what?
03:01:24 <ben_m> thanks
03:01:26 <sebell> jdkl: Did you check out http://haskell.org/haskellwiki/Regular_expressions?
03:01:27 <lambdabot> Title: Regular expressions - HaskellWiki
03:01:28 <opqdonut> :) np
03:01:51 <jdkl> sebell: I did not, thanks :)
03:02:36 <jdkl> another quick question: I'm reading about Marlow's fast and simple web server in Haskell. I see his paper but I don't see the code. do you know where can I get the code?
03:02:49 <sebell> jdkl: I think that should give you a good overview of the different packages in terms of features and speed.
03:03:04 <balodja> oh, by the way, about yaht. how to convert "func2 f g l = filter f (map g l)" to point-free style? (ex 7.1) :)
03:03:25 <opqdonut> ?pl \ f g l -> filter f (map g l)
03:03:25 <lambdabot> (. map) . (.) . filter
03:03:28 <opqdonut> :)
03:03:34 <Cale> don't go all the way though
03:03:40 <sebell> jdkl: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/hws/ I think, not sure if it has a new home
03:03:42 <lambdabot> Title: fptools/hws/
03:03:58 <Cale> You can remove some of the pointedness while keeping things sane
03:04:15 <sebell> jdkl: Perhaps darcs.haskell.org/hws/ I think
03:04:28 <Cale> func2 f g l = filter f (map g l) = (filter f . map g) l
03:04:37 <jdkl> sebell: awesome. thanks.
03:04:38 <Cale> So func2 f g = filter f . map g
03:05:20 <balodja>  <lambdabot> (. map) . (.) . filter
03:05:25 <balodja> omg! that's awful
03:05:27 <sebell> Whoa. Middle-click on the Mighty Mouse rules!
03:06:03 <quicksilver> squeeze the side of the might mouse by mistake and watch all your windows fly around
03:06:26 <balodja> Cale: why do you not remove g?
03:06:40 <sebell> quicksilver: Hmm. I think I bound that to nothing.. but mine is surprisingly difficult to squeeze anyway, maybe it's just how I hold it :)
03:07:22 <Cale> I suppose I could
03:07:33 <Cale> It would be  \f -> (filter f .) . map
03:07:43 <Cale> which is less readable, imo
03:07:50 <opqdonut> yeah
03:08:58 <quicksilver> it's all relative to what you're used to
03:09:09 <quicksilver> but I'm not that keen on the (f .) . pattern :)
03:09:16 <balodja> lamdabot's variant is a very mistic one :) composition is one of the members of another composition. omg :)
03:09:43 <opqdonut> yeah i never get all theses ((.) .) . forms
03:10:42 <Cale> \f -> (filter f .) . map
03:10:59 <Cale> = \f -> (. map) ((.) (filter f))
03:11:04 <quicksilver> well if you have, e.g. foo y = f x . g y
03:11:13 <Cale> = \f -> (. map) . (.) . filter $ f
03:11:19 <Cale> = (. map) . (.) . filter
03:11:31 * quicksilver shrugs. Cale's explaining it now :)
03:11:57 <opqdonut> gah, i think i've misunderstood . in some way, that doesn't make sense
03:12:42 <opqdonut> \ x y -> f x . g y = \x -> f x . g  i understand
03:12:54 <quicksilver> you understand wrongly then ;)
03:12:54 * balodja bits his head against the wall
03:13:00 <quicksilver> because those aren't equivalent
03:13:04 <opqdonut> oh okay
03:13:10 <opqdonut> missing parenthesis?
03:13:10 <Cale> \f g -> filter f . map g = \f g -> (filter f .) (map g) = \f g -> (filter f .) . map $ g = \f -> (filter f .) . map
03:13:13 <quicksilver> yup
03:13:33 <quicksilver> (f x . g) would be equivalent to \y -> (f x . g) y
03:13:43 <quicksilver> but (f x . g) y is not (f x . g y)
03:13:52 <opqdonut> yeah i meant what Cale just said actually
03:13:55 <opqdonut> that i can handle
03:13:57 * quicksilver nods
03:14:33 <Cale> \f -> (filter f .) . map = \f -> (. map) (filter f .)
03:14:34 <quicksilver> I find it helps to desugar the infix
03:14:46 <quicksilver> so you convert (f x) . (g y) into (.) (f x) (g y)
03:14:48 <jdkl> how come that for most packages that I want to install, I need to have Cabal?
03:14:49 <quicksilver> and then work on it
03:14:50 <Cale> \f -> (. map) ((.) (filter f))
03:15:06 <opqdonut> quicksilver: ahhh now i think i see
03:15:10 <Cale> \f -> (. map) . (.) . filter $ f
03:15:24 <Cale> (. map) . (.) . filter
03:15:35 <sebell> jdkl: Because Cabal is the preferred build/install mechanism for Haskell programs
03:15:38 <Cale> perhaps that had enough steps? :)
03:15:38 <quicksilver> (f x) . (g y) ==> (.) (f x) (g y) ==> (.) (f x) g y ==> (f x.) g y
03:15:44 <opqdonut> Cale: yeah thanks
03:15:52 <quicksilver> opqdonut: and now the 'y' is properly exposed at the end and you can reduce it
03:15:58 <opqdonut> quicksilver: yeah, i see
03:16:06 <quicksilver> you don't want the top-level term to be infix
03:16:11 <jdkl> sebell: so I pretty much have to install Cabal even on Windows, irght?
03:16:14 <quicksilver> since you can't reduce that firectly
03:16:32 <sebell> jdkl: Which Haskell system are you using?
03:16:38 <jdkl> ghc 6.6
03:16:44 <sebell> jdkl: Then you already have it
03:17:14 <jdkl> sebell: but I tried to install HDBC and I got error about reference to Cabal that doesn't exist
03:17:34 <jdkl> sebell: on the other hand it seems that ghc is not in my path, could that be the cause?
03:17:53 <balodja> one more little question. is the yaht incomplete by now? i mean 10th chapter
03:18:14 <balodja> about exceptions, regexps and other useful staff
03:18:38 <sebell> jdkl: Not knowing what the error is, or how you are trying to install HDBC, tough to stay. It's a good start, though, to add <ghc-dir>/bin to your %PATH%.
03:19:08 <Cale> YAHT is still incomplete, I think, but it's more of a good launching pad so you can read other tutorials anyway.
03:19:15 <jdkl> ok thanks
03:19:45 <lordrat> I think \f -> (. map) ((.) (filter f)) is not point-free ... there is still f ... I think poin free is func2 = (.) ((.) (flip (.) map) (.)) filter
03:19:49 <jdkl> by the way, I didn't see .hs source file for the standard library in my installation of ghc. but I see a lot of .hi. Is .hi the binary form of a Haskell module?
03:20:12 <balodja> Cale: great thanks
03:20:13 <lordrat> hm... i'm too slow :(
03:20:40 <lordrat> and sorry for prefix-only notation
03:22:12 <Cale> However, \f g -> filter f . map g  is what the problem actually wants.
03:22:48 <Cale> It's not completely points-free, but has the flavour of good points-free code.
03:24:35 <jdkl> so .hi is a binary module?
03:24:36 <lordrat> :) ok... I only tried to fresh knowledge from studying functional programming :)
03:25:39 <sebell> Hmmm. `Write yourself a Scheme in 48 hours' calls (>>) "bind" :(
03:25:54 <matthew-_> typeo?
03:26:19 <dons> hmm >>= is bind,
03:26:23 <dons> >> is `then`
03:26:44 <nornagon> >> is bind
03:26:49 <nornagon> @src (>>)
03:26:49 <lambdabot> m >> k      = m >>= \_ -> k
03:26:52 <nornagon> behold!
03:26:54 <matthew-_> mmm. is it just me or do other people read (<-) as "unpack" ?
03:27:02 <nornagon> matthew-_: i read it as 'comes from'
03:27:31 <sebell> nornagon: :P
03:27:31 <matthew-_> except in list comprehensions, where it's elemOf
03:27:32 <dons> me too
03:27:41 <dons> f x | Just y = f x = ...
03:27:45 <jdkl> ok I'll try in a different way, maybe my question is too simple and I'm phrasing it wrongly. What are the files with extension .hi?
03:27:48 <dons> f x | Just y <- f x = ...
03:28:03 <dons> i mean. in a pattern guard, "comes from" is a good name :-)
03:28:26 <matthew-_> jdkl: from man ghc:        .hi    Interface file; contains information about exported symbols
03:28:29 <nornagon> that guard is... a little weird
03:28:47 <matthew-_> nornagon: glad I wasn't the only one thingking that!
03:29:01 <dons> hmm?
03:29:06 <dons> ah yes
03:29:12 <dons> :-D
03:29:20 <matthew-_> you can do "do" syntax in a guard?
03:29:26 <nornagon> heh
03:29:26 <dons> nope.
03:29:27 <quicksilver> no, it's pattern-match syntax
03:29:37 <quicksilver> it's a ghc extension isn't it?
03:29:50 <matthew-_> what what what?
03:29:51 <nornagon> f x | Just y <- x = ... would sort of make sense
03:29:59 <nornagon> but not as much sense as f Just y = ...
03:30:04 <quicksilver> (that particular one was particularly weird since it recursed on f with the same argument without making progress)
03:30:06 <nornagon> with extra brackets, i mean
03:30:07 <matthew-_> or even f x | Just y <- x' = ...
03:30:08 <dons> Prelude> let f x | Just y <- f x = Just y
03:30:09 <dons> <interactive>:1:8:
03:30:09 <dons>     Warning: accepting non-standard pattern guards (-fglasgow-exts to suppress this message)
03:30:12 <dons>                  Just y <- f x
03:30:14 <jdkl> matthew_: translated in plain english are those the file that I distribute when I want to export .hs files?
03:30:14 <dons> Prelude> f 2
03:30:17 <dons> *** Exception: stack overflow
03:30:19 <dons> :-)
03:30:22 <quicksilver> f x | Just y <- g x =  --- this makes sense
03:30:47 <matthew-_> jdkl: no, you only ever want to ship and move around .hs files.
03:31:05 <jdkl> matthew-_: thanks
03:31:26 <bvd> Hello I'm reading: http://en.wikibooks.org/wiki/Haskell/Zippers and I think I spotted an error but I'm not sure. Shouldn't: turnRight :: Zipper a -> Maybe (Zipper a); turnRight (t, Fork x l r) = Just (TurnLeft x r : t, l) be: turnRight (t, Fork x l r) = Just (TurnRight x l : t, r) ? If so I will update it.
03:31:51 <matthew-_> @type \f g h-> case h of f x | Just y <- g x -> True
03:31:53 <lambdabot> Parse error in pattern
03:31:56 <matthew-_> grr
03:32:20 <quicksilver> matthew-_: guards are only in definitions
03:32:27 <quicksilver> matthew-_: a case isn't a a definition
03:32:35 <matthew-_> quicksilver: that's really inconsistent
03:32:36 <quicksilver> I think?
03:32:41 <matthew-_> you can use "normal" guards in cases
03:33:09 <matthew-_> > case 3 of n | n < 2 -> True; _ -> False
03:33:10 <lambdabot>  False
03:33:17 <quicksilver> it's also wrong
03:33:21 <quicksilver> sorry, I lied :)
03:33:29 <matthew-_> that's ok then! ;-)
03:33:41 <quicksilver> matthew-_: you can use pattern guards there too
03:33:53 <quicksilver> > case True of True | 1 <- 1 -> 1 ; False -> 3
03:33:54 <lambdabot>  Parse error
03:34:01 <quicksilver> but maybe LB has them turned off :)
03:34:09 <quicksilver> in ghci that works
03:34:16 * matthew-_ gets out the glasgow-hammer
03:34:45 <matthew-_> ok, what is the <- doing there?
03:34:47 <jdkl> should i use hsql or hdbc for mysql?
03:35:09 <matthew-_> @hoogle pattern guards
03:35:10 <lambdabot> Did you mean: Pattern Guards
03:35:10 <lambdabot> Prelude.undefined :: a
03:35:10 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
03:35:18 * matthew-_ blushes
03:35:22 <matthew-_> @where pattern guards
03:35:23 <lambdabot> I know nothing about pattern.
03:35:24 <quicksilver> matthew-_: in my example, it's doing nothing
03:35:39 <quicksilver> matthew-_: in general, what is means is : if this pattern matches, then use it as a binder
03:35:48 <quicksilver> matthew-_: if it fails, then this guard fails, try next guard
03:36:16 <matthew-_> quicksilver: ok, so it's an inplace let where the let binding carries through to the body of the guard?
03:36:30 <matthew-_> s/guard/result/
03:36:36 <quicksilver> or it's an inplace-case
03:36:40 <matthew-_> yep
03:36:45 <quicksilver> with the property tha other cases 'fallthrough' to the next guard
03:37:34 <quicksilver> "f x | PATTERN <- e =" is something like "f x | (case e of PATTERN -> True ; _ -> False ) =
03:37:42 <quicksilver> except that the binding in PATTERN scopes over the RHS
03:37:49 <quicksilver> instead of only inside the case
03:37:52 <matthew-_> > let n = Just (3,5) in case n of (Just (x,5)) <- x -> True
03:37:52 <lambdabot>  Parse error
03:38:00 <quicksilver> LB can't do it
03:38:23 <matthew-_> ok, neither can ghci on that on. what have I done wrong?
03:38:34 <matthew-_> oh, I'm being really dumb
03:38:44 <quicksilver>  let n = Just (3,5) in case n of _ | (Just (x,5)) <- n -> True
03:38:48 <quicksilver> this works in my ghci
03:38:56 <quicksilver> you missed out the _ | bit
03:39:04 <quicksilver> and swapped an n for an x
03:39:30 <quicksilver>  let n = Just (3,5) in case n of _ | (Just (x,5)) <- n -> x
03:39:39 <quicksilver> this version is more interesting, it actually uses the extracted 'x' :)
03:39:50 <matthew-_> that's foul though as you're referring to the n - surely let n = Just (3,5) in case n of n' | (Just (x,5)) <- n' -> True is better?
03:40:16 <quicksilver> what's the point of case n of n' ?
03:40:22 <matthew-_> or is it haskell style to refer to the value on which you're doing the case?
03:40:28 <quicksilver> why give a new time to n with n' which is never going to fail to match :)
03:40:34 <quicksilver> s/time/name/
03:40:41 <matthew-_> well it just feels odd to me to do case n of _ -> something with n
03:40:51 <quicksilver> it is odd :)
03:41:05 <quicksilver> you were just using 'case' as a way to insert the guard
03:41:11 <quicksilver> that was the odd part
03:41:14 <matthew-_> I'd rather write case n of n' -> something with n'
03:41:29 <matthew-_> maybe it's just me...
03:41:29 <quicksilver> don't see the point of that
03:41:31 <quicksilver> :)
03:41:40 <quicksilver> I quite often refer to the original
03:41:58 <quicksilver> case t of Branch t' t'' -> do_something_with_all_three t t' t''
03:41:59 <matthew-_> can you put multiple guards on the same case?
03:42:04 <quicksilver> yes
03:42:46 <matthew-_> mmm. I'm getting the one-liner syntax wrong then
03:42:52 <matthew-_> let n = Just (3,5) in case n of n' | (Just (x,4)) <- n' -> x; | (Just (3,y)) <- n' -> y
03:43:10 <quicksilver> no need for a ;
03:43:11 <matthew-_> oh, drop the ;
03:43:17 <quicksilver> the | is the separator
03:43:19 <quicksilver>  let n = Just (3,5);  f m | (Just (x,5)) <- m = x in f n
03:43:30 <quicksilver> this seems neater to me: your 'case' is pointless :)
03:43:46 <matthew-_> yup. I'm more comfey with doing cases on 1-lines
03:43:46 <matthew-_> ;-)
03:44:09 <matthew-_> so there, the <- gets desugared in the normal way?
03:44:29 <quicksilver> 'normal' compared to what?
03:44:34 <matthew-_> monad-land
03:44:37 <quicksilver> no
03:44:41 <quicksilver> nothing to do with monads
03:44:45 <quicksilver> it's just a pattern match
03:45:02 <matthew-_> oh. ok. so >>= is not involved?
03:45:05 <quicksilver> using pattern matchs in guards is a special hack to combine pattern matching and guarding
03:45:10 <quicksilver> nope, no monad in sight
03:45:27 <quicksilver> the idea is to have the power of pattern matching, and if the pattern fails to match the guard is said to have failed
03:45:33 <matthew-_> yep
03:45:33 <quicksilver> and we go on to the next guard
03:45:59 <matthew-_> more syntax should be overloaded. it's just too clear otherwise...
03:46:05 <quicksilver> :)
03:46:48 <quicksilver> well there is a strong analogy with the monadic syntax
03:46:54 <quicksilver> I suppose that's why the some notation was chosen
03:47:34 <matthew-_> yes, but given the general cleanliness of haskell, it's not surprising that having seen the example I just assumed you could just whole do-notation in there
03:47:41 * quicksilver nods
03:48:00 <matthew-_> oh well, thanks for your help.
04:03:57 <therp> oh google SoC application for students opened today.. hmm any nice Haskell project I could join?
04:05:44 <earthy> yes! do! there's a proposal for haskell support in swig, if I'm not mistaken
04:06:02 <earthy> which would be of *great* benefit to wxhaskell
04:06:34 <therp> ah swig. but swig is written in C right?
04:06:42 <earthy> yeah. so? :)
04:06:59 <therp> I guess 5k$ are not enough in this case
04:07:01 <earthy> you'd have to learn a shitload of advanced haskell trickery to generate nice haskell
04:07:02 <quicksilver> clearly the attitude of any haskell hacker will be to rewrite swig in haskell :)
04:07:13 <quicksilver> rather than to add haskell support to the C code
04:07:39 <quicksilver> if that sounds tricky, how about rewriting the linux kernel in haskell? that would be a useful SoC
04:07:39 <therp> maybe that's even quicker.
04:09:09 <earthy> http://hackage.haskell.org/trac/summer-of-code/ticket/30 is nice
04:09:11 <lambdabot> Title: #30 (Haskellnet) - Haskell.org Google Summer of Code - Trac
04:09:17 <therp> uuh a haskell partial evaluator ..
04:09:33 <therp> that would be nice, but I'm not sure if I'm capable of doing that
04:10:29 <therp> hmm the c-- code manipulation library doesn't sound hard
04:11:58 <earthy> I'd also like to see http://hackage.haskell.org/trac/summer-of-code/ticket/46
04:11:59 <lambdabot> Title: #46 (Shared libraries in GHC) - Haskell.org Google Summer of Code - Trac
04:12:17 <therp> ah that would be really nice.
04:12:42 <therp> I was looking at the code two days ago, and was wondering why shared linking isn't default
04:12:57 <earthy> well, now you know :)
04:13:16 <quicksilver> I'd like to see a heap-usage visualiser
04:13:29 <quicksilver> to help people understand lazy algorithms and constant space usage
04:14:05 <quicksilver> If I have a good consumer (like fold' (+) 0) consuming a lazily produced list, I have a picture in my head like this:
04:14:30 <quicksilver> (64) .. 5 : {{ :-> }}
04:14:34 <quicksilver> the monster is the thunk
04:14:52 <quicksilver> is the consumer consumes numbers, the thunk moves back, producing the next number
04:15:10 <quicksilver> would be lovely to have pretty pictures like that for more complex cases
04:15:20 <quicksilver> (map sum) . transpose $ m
04:17:12 <therp> hmm. reading the terms of google SoC takes a while..
04:27:14 <sebell> quicksilver: Animated, I assume? :)
04:28:10 <quicksilver> sebell: oh yes, absolutely
04:28:15 <quicksilver> sebell: that's the point :)
04:28:30 <quicksilver> sebell: it would be *really* pretty to see an animation of transpose on a lazy list of lazy lists
04:37:55 <opqdonut> hehe
04:59:22 <vincenz> @tell Adept We have to talk
04:59:22 <lambdabot> Consider it noted.
05:00:30 <nornagon> ominous.
05:22:10 <vincenz> nornagon: :P
05:30:51 * emk is pleased to discover -fno-implicit-prelude.
05:34:19 * doserj would also like to have rebindable syntax for if-then-else...
05:37:54 <dons> emk, really makes writing stuff in base/ simpler.
05:38:38 <emk> dons: I'm just happy that I can make Data.Set a monad.
05:38:41 <dons> emk, btw, you might be interested in our stream fusion framework for [a], http://www.cse.unsw.edu.au/~dons/streams.html (lots of -fno-implicit-prelude :)
05:38:42 <lambdabot> Title: Data.List.Stream
05:38:50 <dons> yeah, very nice.
05:39:50 <emk> dons: Monads are so central the Haskell Experience<tm> you really ought to be able to define them whe
05:40:00 <emk> wherever they actually exist.
05:40:04 <dons> I agree!
05:40:08 <dons> rebindable syntax for all!
05:40:40 <emk> dons: Well, I'd like Data.Set to be a monad right out of the box, ideally. :-)
05:40:56 <emk> But rebindable syntax is also one of the basic necessities of life.
05:41:24 <dons> it should be. i think a reasonable way to achieve it would make a good HW paper ... ;-)
05:41:49 <kuribas> Data.Set like the List Monad?
05:42:07 <emk> Particularly with some of the monad <-> algebra connections I've been poking at recently, it really is super-useful to have a commutative collection monad.
05:42:54 <quicksilver> emk: Yes, I suspect the resistance to it is mostly the 'relatively' heavy machinery needed to implement Set
05:43:07 <quicksilver> emk: compared to List being almost the simplest rectype there is :)
05:43:26 <merus> () is the simplest rectype :D
05:43:37 <quicksilver> what recursive in the definition of () ?
05:43:58 <merus> It's a secret.
05:44:27 <emk> dons: Hmm. My probability monad posts are examples from an unpublished draft paper. I wonder if it's worth cleaning everything up (including the forthcoming post) and submitting it somewhere? (There are at least a few details which I've never seen in the literature, which doesn't mean I haven't overlooked something.)
05:45:07 <emk> quicksilver: Well, once you 'import Data.Set' you've already paid for the complexity, and you might as well get the monad! :-)
05:45:36 <quicksilver> emk: true; I think I was explaining why 'list comprehensions' and not 'set comprehensions' are given as basic sugar though
05:46:31 <dons> emk, some of the stuff would be ideal HW paper material (see the functional pearls from previous years, for example)
05:47:11 <emk> dons: That would be fun! I'll have to go track down submission guidelines.
05:47:54 <dons> http://www.cse.unsw.edu.au/~keller/haskellws/HaskellWorkshop.html
05:47:54 <lambdabot> Title: Haskell Workshop 2007
05:48:13 <dons> "Functional Pearls, being elegant, instructive examples of using Haskell.", for example.
05:48:36 <dons> Submission Deadline: Friday, June 15th 2007
05:48:56 <dons> plus, you get to hang out at icfp and the haskell hackathon :-)
05:49:29 <kuribas> @pl \x y z -> x:y:z
05:49:30 <lambdabot> (. (:)) . (.) . (:)
05:49:58 <emk> dons: Yummy.
05:50:31 <hpaste>  MathematicalOrc pasted "Class system is stopping me..." at http://hpaste.org/980
05:50:33 * emk pencils in submission deadline on calendar.
05:50:45 <flowolf> hi all
05:51:42 <dons> hi flowolf. welcome.
05:52:02 <Orphi> hi peeps.
05:52:08 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint!
05:52:09 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
05:52:09 <Orphi> any help for http://hpaste.org/980 ?
05:52:21 <dons> looking...
05:53:01 <dons> can you paste actual code?
05:53:11 <Orphi> well, it's a tad long, but ok...
05:53:15 <dons> the body of method in particular
05:53:26 <dons> and the types Foo, Bar and so on.
05:54:09 <quicksilver> I don't understand (Magic m) => Magic [Foo f]; 'm' doesn't appear in the RHS of the constraint?
05:54:26 <Orphi> quicksilver: eeps... typo o_O
05:54:33 <quicksilver> ah
05:54:36 <quicksilver> Magic [Foo m] ?
05:54:39 <doserj> the problem is that Magic [Foo f] has more than one type constructor
05:54:40 <Orphi> yah
05:54:47 <Orphi> doserj: indeed.
05:55:00 <quicksilver> you can do newtype MagicListFoo a = Magic [Foo a]  I believe?
05:55:14 <Orphi> quicksilver: ah... maybe.
05:55:19 <quicksilver> although that isn't what I meant :)
05:55:28 <quicksilver> newtype ListFoo a = [Foo a]
05:55:32 <Orphi> ok guys, http://hpaste.org/981
05:55:35 <quicksilver> instance (Magic m) => ListFoo m
05:55:43 <dons> sjanssen: i note after a couple of days uptime, xmonad memory use dropped by half (GC eventually kicked in)
05:55:47 <quicksilver> instance (Magic m) => Magic (ListFoo m)
05:55:52 <dons> down to dwm-levels
05:56:29 <Orphi> if you comment out the bit for lists, it compiles fine; but it doesn't like the list instance
05:57:02 <Orphi> *thinks about newtype*
05:58:04 <Orphi> hmm... hold on. you can't do newtype ListFoo a = [Foo a]
05:58:09 <Orphi> you'd need a constructor in there
05:58:26 <Orphi> newtype ListFoo a = MkListFoo [Foo a]
05:58:41 <quicksilver> yes, I wasn't sure if you could get away with a mere synonym or not
05:59:09 <Orphi> S4.3.2 in the Haskell report claims you can't use type synonyms in instance declarations
06:00:02 <quicksilver> I *think* the problem is just that Magic [Foo f] doesn't 'obviously' have the right kind
06:00:24 <quicksilver> since we don't have a type-level lamba, and you can't write L f . Magic [Foo f] which is what you mean
06:00:29 <quicksilver> so maybe the newtype solves that?
06:00:35 <doserj> it should
06:01:22 <Orphi> w00t! it seems to work
06:01:33 <Orphi> ok, now gotta insert the newtype constructor everywhere... :S
06:02:05 <Orphi> *bends mind*
06:02:27 <Orphi> my WORD that smarts! x_x
06:02:31 <uccus> Orphi... it looks kind of kool if you write / me bends mind
06:02:36 * uccus bends mind
06:02:39 <kombinator_> hello #haskell, has anyone done incremental lexing in haskell?
06:02:47 <Orphi> ah, so that's the correct command...
06:02:53 <Orphi> long time since I used IRC ;)
06:02:58 <flux-> dons, hm, couldn't that stream fusion-thingy be useful also with other than character arrays, such as sequences of integers? in any case, pretty impressive performance numbers
06:03:27 <flux-> (sequences of integers or floats could be useful for example in dsp applications)
06:04:22 <dons> you mean, arrays?
06:04:36 <earthy> ndp? :)
06:04:56 * araujo throws a lambda at CosmicRay 
06:05:03 <dons> yeah, there's an entire project on this. hopefully roman will release the ndp array lib tomorrow or monday.
06:05:40 * CosmicRay deftly deflects it with his pattern guard
06:05:40 <lambdabot> CosmicRay: You have 1 new message. '/msg lambdabot @messages' to read it.
06:05:54 <dons> guard your patterns!
06:05:57 <araujo> :-)
06:07:16 <ikegami--> hello
06:07:45 <ikegami--> I wonder whether System.Posix.* works on Windows, or not.
06:08:20 <ikegami--> for ghc
06:10:27 <quicksilver> I would assume not
06:10:43 <quicksilver> It's a library to expose the posix api, not a library to emulate it, AFAIK
06:11:23 <ikegami--> hmm
06:12:03 <kuribas> @pl \c -> (['\\', c]++)
06:12:04 <lambdabot> (++) . ('\\' :) . return
06:13:13 <kuribas> @pl \c -> (['\\', c])
06:13:13 <lambdabot> ('\\' :) . return
06:14:12 <quicksilver> personally I dislike the use of 'return' when it's the monkey face you want
06:14:22 <quicksilver> I prefer to use the special case explicitly
06:14:31 <quicksilver> ('\\':).(:[])
06:14:46 <quicksilver> to me that's quite a bit clearer, in fact
06:15:34 <kuribas> Yes, for me the lambda expression is the clearest.
06:15:51 <quicksilver> I don't mind ('\\':).(:[])
06:16:19 <quicksilver> I sometime write stuff like ("begin {"++).(++"} end")
06:16:31 <quicksilver> for the process of 'sandwiching' between two strings
06:17:01 <kuribas> hm, yes, if you recognise the idiom.
06:17:15 <quicksilver> yes
06:17:24 <quicksilver> clarity of code is necessarily subjective ;)
06:23:40 <hpaste>  kuribas pasted "parsing a string" at http://hpaste.org/982
06:24:05 * kuribas wonders if this is the best way to parse a string using Parsec.
06:25:36 <hpaste>  mux pasted "how I do it" at http://hpaste.org/983
06:26:08 <mux> omit the lexeme bit if you're not using lexical parsers
06:26:17 <mux> but I find this clearer
06:26:40 <mux> it's not exactly the same parser as yours but you see the point
06:26:47 <quicksilver> I do lexing in a separate phase from force of habit
06:27:01 <quicksilver> and then write my parsers over tokenlists
06:27:18 <mux> quicksilver: I was pondering doing that
06:27:26 <mux> kuribas: also, you're doing unnecessary work
06:27:32 <mux> you have the string in d
06:27:47 <kuribas> yes?
06:27:48 <mux> but you enclose it into " and then call read on it
06:27:54 <mux> it's the same as just returning d
06:28:06 <quicksilver> except fo rthe way it handles esacpes...
06:28:19 <mux> ah, must have missed that
06:28:30 <mux> anyways, my version looks much better ;-)
06:29:22 * kuribas should probably use a lexer...
06:30:09 <kuribas> mux: well, I let read handle converting \n etc...
06:30:22 <mux> yeah
06:31:25 <mux> you know about the "string" parser bundled in parsec I guess?
06:32:40 <mux> I only wrote that code because I couldn't just use string
06:33:25 <dcoutts__> dons: is it just me who thinks ArtemGr is actually Bulat in disguise?
06:33:35 <kuribas> mux: you mean stringLiteral?  Yes, I should use that.
06:33:44 <mux> kuribas: no, I mean string
06:33:47 <hpaste>  quicksilver pasted "simple lexer" at http://hpaste.org/984
06:34:22 <kuribas> mux: string doesn't do what I want.
06:34:26 <mux> ah.
06:35:11 <kuribas> string parses a sequence of characters, it doesn't have anything to do with parsing strings.
06:37:50 <dons> anyone have any other thoughts on this: http://programming.reddit.com/info/1aomv/comments
06:37:51 <lambdabot> Title: Ask Reddit: There are tons of Haskell tutorials online. Which ones have you foun ...
06:37:53 <dons> dcoutts__: hah!
06:43:00 <hpaste>  Toxaris pasted "one-line string parser" at http://hpaste.org/985
06:44:18 <chessguy> 'morning, haskellers
06:44:25 <bos> 'ello.
06:44:32 <merus> morning chessguy!
06:44:37 <Vq^> chessguy: goodafternoon
06:44:54 <chessguy> "and i case i don't see you..."
06:45:16 <kuribas> Toxaris: that deletes the backslash.
06:45:49 <Cheery> Has anyone written a simulator from "To Dissect a Mockingbird" -article?
06:46:11 <chessguy> that sounds messy
06:46:23 <Toxaris> kuribas: it interpretes all backslashes as escapes
06:47:24 <Toxaris> kuribas: and escape + simple char => simple char only
06:47:44 <Toxaris> kuribas: unlike haskell, like other languages
06:47:56 <kuribas> Toxaris: yes, but I want \n to become newline, not n.
06:50:33 <Cheery> it would be messy, yes.
06:50:37 <chessguy> quicksilver, not much comment on my kind question last night :(
06:50:57 <chessguy> just oleg with his usual babbling
06:51:16 <Cheery> It's because the graphs aren't such that one could easily animate them and make them work from any direction.
06:51:40 <chessguy> i meant that actually dissecting a mockingbird would be messy
06:52:01 <Cheery> ah, ok.
06:53:38 <hpaste>  Toxaris annotated "one-line string parser" with "three lines more to decode escapes" at http://hpaste.org/985#a1
06:54:47 <Toxaris> is it ok (good practice; efficient) to use pattern matching in this way?
06:56:18 <loggi> how I can write this in a nicer/more compact way? putStrLn (show ((read $ args !! 0) / (read $ args !! 1)))
06:57:08 <quicksilver> Toxaris: yes, pattern matching is very fast
06:57:23 <Cheery> putStrLn $ show $ (read $args !! 0) / (read $ args !! 1)
06:57:45 <loggi> Cheery: that's what I wanted. Thanks
06:58:14 <int-e> putStrLn . show == print
06:58:22 <quicksilver> let [a,b] = map (read . (args!!)) [0,1] in print a/b
06:58:51 <loggi> quicksilver: that's wild
06:58:59 <int-e> let a:b:_ = map read args in ... :)
06:59:27 <Toxaris> quicksilver: thanks good to know
07:03:32 <Orphi> ack... well, newtype solved my problem.
07:03:37 <quicksilver> Orphi: good
07:03:40 <quicksilver> Orphi: bit messy though :(
07:03:44 <Orphi> but now my *new* problem is that a list can only contain values of *one* type :(
07:04:09 <kombinator_> dons: ping
07:04:22 <quicksilver> Orphi: that's why we have algebraic data types, surely?
07:04:38 <Orphi> I'm trying to write a unification algorithm (irony?), and I want to gather up all the bindings found
07:04:41 <Orphi> but they have different types
07:04:48 <quicksilver> Orphi: [Thing] where data Thing = ThisThing Foo | ThatThing Bar | OtherThing Hip
07:04:58 <Orphi> quicksilver: yeah, but that means it can't be extended later.
07:05:29 <doserj> other solutions are existentially quantified types
07:05:34 <doserj> or Data.Dynamic
07:05:39 <Orphi> x_x
07:05:39 <quicksilver> right
07:05:43 <doserj> or HList
07:05:47 <quicksilver> But I hate people using those when they don't really need to :P
07:05:53 <doserj> sure :)
07:05:55 <quicksilver> which is why I tend to suggest them as a last resort
07:06:00 <Orphi> ...maybe I should just give up now?
07:06:25 <Orphi> at the very least, I'm starting to see why the examples don't do it this way!
07:06:39 <quicksilver> Orphi: I've written unification algorithms in haskell and I've never hit the problem, so I'm not sure I fully understand it
07:07:05 <hpaste>  MathematicalOrc annotated "This is broken." with "Nearly works..." at http://hpaste.org/981#a1
07:07:28 <Orphi> I wanted the algorithm to work over any possible Haskell type
07:07:34 <Orphi> but it seems the type system isn't keen to let me
07:07:58 <Orphi> I was hoping to be able to just write a suitable class declaration for each Haskell type to allow the unifer to work on it
07:08:14 <Orphi> but you still can't gather up the bindings thus generated because they have different types
07:08:30 <Orphi> have a look my the hpaste I just did
07:09:21 <quicksilver> hmm
07:09:30 <quicksilver> well you're confusing the language and the meta-language
07:09:35 <quicksilver> that's bound to get things in a knot :)
07:09:35 <Orphi> affirmative
07:10:06 <Orphi> ...what, like MY BRAIN? :P
07:10:33 <Orphi> "help - the type checker can't unify my unifier's type!"
07:10:39 <quicksilver> what is the intended meaning of Unify Int ?
07:10:43 <ClaudiusMaximus> Orphi: what about encapsulating all the operations you need into a record?  something like makeFooBar x = Foo{ fooX= fooBarX x; fooY = fooBarY x }, similarly makeFooBaz y = Foo{ fooX = fooBazX x, fooY = fooBazY x }
07:10:47 <quicksilver> why would I be unifying ints?
07:11:07 <Orphi> quicksilver: you won't.
07:11:13 <Orphi> quicksilver: you'll unify "Term Int"
07:11:18 <quicksilver> are they indices on type variables?
07:11:30 <Orphi> quicksilver: which will either be "Val 3" or "Var Named 'x'"
07:12:18 <Orphi> so for example, "unify (Val 3) (Var Named "x") []" yields [(Var Named "x", Val 3)]
07:13:07 <Orphi> if I could make it work in lists, then unifying "[1,2,3]" against "[x,y,z]" would result in "x=1, y=2, z=3"
07:13:21 <quicksilver> hmm
07:13:27 <quicksilver> this isn't type unificiation
07:13:30 <quicksilver> it's value unification
07:13:48 <Orphi> indeed yes
07:13:53 <quicksilver> right.
07:13:54 <quicksilver> hmm :)
07:14:09 <Orphi> ...unless you "values" are type structures ;)
07:14:22 <quicksilver> well yes, true
07:14:28 <Orphi> the idea is to be able to unify *anything*
07:14:47 <quicksilver> I suspect this is in fact a case for HList
07:14:56 <Orphi> (or at least, anything in Eq)
07:14:58 <quicksilver> as if your brain wasn't already knotted
07:15:25 <quicksilver> but I would be inclined, personally, to stick to unifying within a fixed type
07:15:29 <Orphi> quicksilver: I'll tell you what... now I think I understand why you can do type arithmetic.
07:15:32 <quicksilver> like your Int example already works
07:15:51 <quicksilver> and as you point out that can be exteneded to any Eq type
07:15:55 <Orphi> quicksilver: it's because Haskell's type deduction uses a unifyer! ;)
07:16:07 <quicksilver> Orphi: right
07:16:29 <Orphi> quicksilver: still fuzzy on precisely why you would *want* to do type arithmetic, but still...
07:18:26 <quicksilver> Orphi: So, why are you trying to make [Term t] an instance of unify?
07:18:32 <quicksilver> instead of, extending the Term type
07:18:36 <quicksilver> to have a List constructor?
07:19:11 <Orphi> ...and then have a tree constructor, and then have a hashtable constructor, and then...
07:19:20 <quicksilver> right
07:19:31 <quicksilver> but your way involves a tree instance, then a hashtable instance, then...
07:19:31 <Orphi> not very extensible, eh?
07:19:43 <Orphi> ...which can be written independently
07:20:11 <Orphi> hmm - how the heck does Prolog do this stuff?? :S
07:20:21 * Orphi thinks about atoms
07:20:25 <Toxaris> dynamic typing?
07:20:36 <Toxaris> there is nothing but terms in prolog
07:20:37 <Orphi> Toxaris: ...oh yeah :|
07:20:58 <Orphi> oh well, it appears I have to leave now...
07:21:03 <Orphi> I'll have to think on this lot
07:21:15 <Orphi> later peoples
07:21:16 <chessguy> holy cow. what's so stinking fascinating about System.FilePath
07:21:34 <kpreid> I would think one could make a statically-typed Prolog
07:25:17 <sjanssen> chessguy: the debate isn't really about filepath anymore
07:25:53 <sjanssen> now everybody is arguing about monolithic base v. very modular libraries
07:32:22 <joelr1> good day! does anyone know of a parsec grammar for pascal?
07:36:38 <Spark> @eval fix ((1:) . scanl (+) 1)
07:37:00 <Spark> > fix ((1:) . scanl (+) 1)
07:37:09 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
07:37:16 <Uncountable> @hoogle foldl'
07:37:17 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
07:37:20 <Uncountable> @hoogle foldr'
07:37:21 <lambdabot> No matches found
07:37:29 <Uncountable> is a foldr' not needed?
07:37:36 <Spark> @type fix
07:37:37 <Uncountable> @hoogle foldl1'
07:37:39 <lambdabot> forall a. (a -> a) -> a
07:37:39 <lambdabot> Data.List.foldl1' :: (a -> a -> a) -> [a] -> a
07:40:24 <quicksilver> Uncountable: a strict foldr doesn't make much sense, since no 'left-chunk' is ever a complete expression
07:41:22 <quicksilver> Uncountable: nonetheless by the magic of lazy evaluation even partial expressions can be computed and used, so that's OK!
07:41:47 <Uncountable> okay
07:42:31 <sjanssen> foldr' would be guaranteed to use O(n) stack
07:44:36 <Uncountable> hm, foldl1' is in Data.List but not List
07:46:49 <quicksilver> List is an obsolete module I believe
07:50:01 <shapr> sjanssen: xmonad sure is nifty. But I got it to segfault
07:50:14 <sjanssen> shapr: wow, segfault?
07:50:32 <LoganCapaldo> mmmmmmpressive
07:50:41 <sjanssen> @quote segfault
07:50:41 <lambdabot> No quotes match. Are you on drugs?
07:50:48 <sjanssen> QED
07:50:50 <shapr> Yeah, it segfaulted yesterday when I ran gnome-theme-manager.
07:50:57 * LoganCapaldo applauds
07:51:05 <dylan> xmonad is don's thing, right?
07:51:14 <shapr> It's a window manager.
07:51:18 <sjanssen> shapr: hmm, can you reproduce?
07:51:32 <sjanssen> maybe startx -- :2 so you don't have to kill all your open stuff
07:51:40 <shapr> sjanssen: Haven't had time to try it again, had to sleep and then work, but I'll try it again later.
07:51:44 <shapr> Did you get my patch?
07:52:03 <sjanssen> shapr: the stuff about abstracting modMask?
07:52:13 <shapr> yup
07:52:21 <sjanssen> yep, applied
07:52:25 <dylan> hmm, I should try porting dmenu to haskell.
07:52:54 <sjanssen> dylan: yes please
07:53:07 <shapr> I like xmonad more than either dwm or wmii, it's way spiffy.
07:53:40 <sjanssen> we still need to write a statusbar for xmonad, dmenu-like code would be a great starting point :)
07:53:46 <LoganCapaldo> plus its an Xtreme Monad! How can you not love it?
07:54:00 <LoganCapaldo> what do you mean that's not what X stands for?
07:54:14 <shapr> From what I understand, xmonad has multiple workspaces, and then each workspace has a bunch of fullscreen windows that you can page through, is that correct?
07:54:26 <sjanssen> shapr: correct
07:54:31 <dylan> hmm.
07:54:33 <shapr> Does it do anything else?
07:54:47 <dylan> I pretty much like exactly the way DWM works.
07:54:47 <sjanssen> other layout styles (tiling, and floating later on) are in the works
07:55:13 <dylan> will xmonad have tags like dwm?
07:55:17 <shapr> Yesterday I didn't think I needed tiling, but then I realized kopete requires drag'n'drop for some stuff.
07:55:33 <shapr> And I can't seem to drag, page to another window, and then drop.
07:55:41 <sjanssen> dylan: it remains to be seen
07:57:04 <shapr> sjanssen: I know that gnome-theme-manager does some WM decoration stuff, maybe that's why xmonad crashed?
07:57:33 <LoganCapaldo> tags I'm +- about. On the one hand the sort of ad hoc workspace thing is cool, on the other, the layout is always a shcok, you neve know what you are gnna get, although I suppose that if theres o tiling you know exactly what you are going to get :)
07:57:46 <LoganCapaldo> s/o/no/
07:57:52 <sjanssen> shapr: http://hpaste.org/856 is very handy if you need to switch between dwm and xmonad (also helps if xmonad keeps crashing)
07:58:16 <sjanssen> shapr: perhaps.  Was it an actual segfault, or did it exit in some other way?
07:58:27 <shapr> It was an actual segfault.
07:58:37 <mauke> while [ 1 ]; better written as while :;
07:58:41 <shapr> And it happened as soon as gnome-theme-manager started to do something.
07:58:45 <dylan> I think I'll stick with dwm until xmonad has tags and tiling.
07:59:01 <shapr> dylan: You could add tags and tiling :-)
07:59:29 <dylan> I don't know enough xlib. ;)
07:59:56 <dylan> btw, I have haskell versions of swarp... and some other tools, somewhat.
08:00:01 <sjanssen> I don't actually know any xlib.  Didn't stop me from writing a window manager!
08:00:03 <dylan> *somewhere
08:02:41 <shapr> @google swarp
08:02:42 <sjanssen> hmm, I wonder which package gnome-theme-manager is in
08:02:45 <lambdabot> http://terapix.iap.fr/rubrique.php?id_rubrique=49
08:02:45 <lambdabot> Title: Terapix - SWarp
08:05:15 <Igloo> Wow, people are queueing up to write a y/nhc typechecker
08:06:40 <malcolmw> Igloo: really?
08:07:20 <Igloo> Well, there are 2 interested students on the SoC ticket at least  :-)
08:08:11 <shapr> dylan: Is that really the swarp you meant? for FITS images?
08:08:40 <sjanssen> shapr: it's a utility to move the mouse pointer
08:09:04 <shapr> ohh
08:09:20 <dylan> shapr: noo, swarp on suckless.ort
08:09:22 <dylan> *org
08:09:42 <dylan> bah, looks like I'll have to rewrite it. all 20 lines.
08:10:21 <sjanssen> dylan: does X11 have all the bindings you need?
08:10:29 <dylan> for swarp? yes
08:10:33 <dylan> for dmenu? no
08:10:44 <shapr> sjanssen: It seems that Qt/KDE drag'n'drop doesn't work with xmonad
08:10:50 <sjanssen> what is missing for dmenu?
08:11:09 <dylan> sjanssen: not sure; I think the event interface is not complete enough
08:11:26 <dylan> I'd also like to add clipboard support to dmenu
08:11:35 <shapr> What does dmenu do?
08:11:49 <shapr> I've only started using gmrun since I started with xmonad last night.
08:11:50 <dylan> shapr: difficult to explain.
08:11:51 <sjanssen> shapr: not entirely surprising, we still need to handle some more X events
08:12:06 <shapr> dylan: Ok, I'll just try and see if my head explodes.
08:12:15 <sjanssen> shapr: it's often used as a program launcher thing
08:12:24 <dylan> it can be used for more than that.
08:12:24 <sjanssen> @where X11-extras
08:12:25 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/X11-extras
08:12:31 <mauke> dmenu displays a menu and prints the selection to stdout
08:12:43 <dylan> a complete-as-you-type menu
08:12:53 <mauke> you can select with the arrow keys or type characters to filter the displayed entries
08:13:22 <shapr> Ah, I have used dmenu.
08:13:24 <dylan> I have a front-end for it called pmenu that gives me layered menus.
08:13:27 <sjanssen> dylan: that's a collection of bindings we've needed for xmonad.  It features a totally overhauled event data structure
08:13:45 <dylan> win+p sr<enter>google<enter>query<enter> -> does a google search using surfraw.
08:14:07 <ski> mauke : is it somewhat like 'iswitchb-mode' in emacs ?
08:14:25 <roconnor> runhaskell Setup.lhs install --user isn't working for me for Network.HTTP
08:14:27 <mauke> I don't know iswitchb-mode
08:14:28 <roconnor> :'(
08:15:51 <quicksilver> ski: something a little along those lines, yes
08:15:58 <shapr> mauke: If you use emacs, iswitchb-mode is way better than other flavors of buffer switching, imho.
08:16:12 <quicksilver> ido-mode is quite fun, too
08:16:17 <ski> http://www.emacswiki.org/cgi-bin/wiki/IswitchBuffers
08:16:19 <lambdabot> Title: EmacsWiki: IswitchBuffers
08:16:20 <quicksilver> since it does similar things to find-file
08:16:50 <mauke> I don't use emacs
08:16:55 <roconnor> @help cabal
08:16:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:17:47 <chessguy> @hoogle Char -> Char -> String
08:17:48 <lambdabot> No matches, try a more general search
08:18:07 <chessguy> @pl -> \x y -> x : [y]
08:18:07 <lambdabot> (line 1, column 1):
08:18:08 <lambdabot> unexpected "-"
08:18:08 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
08:18:15 <chessguy> @pl \x y -> x : [y]
08:18:15 <lambdabot> (. return) . (:)
08:18:19 <chessguy> eww
08:19:19 <shapr> Oh, I like palindromic nick names.
08:20:14 <chessguy> shapr, ?
08:20:17 <shapr> flowolf
08:20:33 <chessguy> oooook then
08:20:53 <shapr> Isn't that a palindrome?
08:21:01 <shapr> hej psi`, god morgon!
08:21:14 <chessguy> yes it is, that was just a really random comment
08:21:16 <psi`> morrn
08:21:37 <shapr> chessguy: I'll ask you one of the interview questions I got (and did badly on)... How would you write a palindrome checking function in Haskell?
08:21:41 <hpaste>  eddyp pasted "bluelock.hs:10:32: Not in scope: `ttyis'" at http://hpaste.org/986
08:21:51 <chessguy> ?seen flowolf
08:21:52 <lambdabot> I saw flowolf leaving #haskell 2m 56s ago, and .
08:21:58 <eddyp_> why doesn't that work?
08:22:00 <shapr> amanaplanacanalp: haha
08:22:32 <shapr> chessguy: Oh, you wonder what prompted that comment? flowolf had just left the channel.
08:22:34 <chessguy> @pl \str -> (reverse str) == str
08:22:35 <lambdabot> (==) =<< reverse
08:22:35 <sjanssen> blast, I was cut off!
08:22:36 <psi`> hm, I didn't even react that it's far from morning. shows how much i've done today.
08:22:36 <quicksilver> eddyp_: <- bindings only scope over the do block itself
08:22:53 <eddyp_> what is the difference between that and evaluating lock before using it?
08:23:02 <chessguy> ahh, i missed that
08:23:15 <ToRA> @type (.(:)) (.(:[]))
08:23:17 <lambdabot> forall a. a -> a -> [a]
08:23:24 <quicksilver> eddyp_: I don't understand your question
08:23:34 <quicksilver> eddyp_: this is just a scope issue, not a semantic one
08:23:47 <chessguy> shapr, how's that implementation?
08:24:12 <eddyp_> quicksilver: so I need to evaluate lockcmd before "result <- .."?
08:24:18 <shapr> chessguy: Yup, it's good.
08:24:41 <chessguy> what did you say?
08:24:43 <shapr> chessguy: I overcomplicated mine :-(
08:24:43 <hpaste>  sjanssen annotated "bluelock.hs:10:32: Not in scope: `ttyis'" with "do/let instead" at http://hpaste.org/986#a1
08:25:00 <Uncountable> shapr: is there a faster one?
08:25:00 <sjanssen> eddyp_: the problem is scope, not evaluation order
08:25:24 <chessguy> Uncountable, i don't think so
08:25:50 <shapr> Uncountable: I think I tried to come up with a faster one during my interview, but I think code as communication with other humans is most important in most situations.
08:25:51 <sjanssen> you could be clever about splitting the string in half
08:26:05 <Uncountable> hm, you could do both reverse and length at the same time, and then only compare with half of the original string, so it would take 1.5 n operations
08:26:16 <chessguy> sjanssen, asymptotically irrelevant
08:26:17 <sjanssen> but reverse xs == xs is the same order
08:26:36 <eddyp_> sjanssen: aha... I see... I guess
08:26:47 <shapr> Uncountable: Yeah, that's the sort of thing I did, but it's really not necessary.
08:26:51 <sjanssen> chessguy: but on occasion, constant factors count :)
08:26:53 <Uncountable> okay
08:27:10 <chessguy> pff, computer science isn't really real
08:27:55 <psi> ?pl \s -> sort s == sort s
08:27:55 <lambdabot> liftM2 (==) sort sort
08:28:11 <psi> neat :)
08:29:15 <shapr> hiya narain
08:29:19 <mauke> :t reverse >>= (==)
08:29:22 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
08:29:29 <narain> hi shapr
08:29:59 <shapr> sjanssen: What's up with window ordering in a workspace? I expect new windows to be added to the tail of the stack, but it does something different.
08:31:36 <sjanssen> @type \xs -> let xs' = zip xs [0..] in all (\((x, _),(y, _)) -> x == y) . takeWhile (\((x, i),(y, j)) -> i < j) $ zip xs' (reverse xs') -- fast version
08:31:39 <lambdabot> forall a. (Eq a) => [a] -> Bool
08:33:10 <sjanssen> shapr: right now windows are treated like a cyclic list.  When a window is added it is inserted before the current window
08:33:17 <shapr> ah, that explains it.
08:33:18 <ski> (balodja : #haskell.ru, i think ..)
08:33:23 <sjanssen> this will probably change with the tiling update
08:33:31 <shapr> I'd rather it were inserted at the end of the ring, or after the current window.
08:33:40 * shapr looks at the code
08:34:02 * eddyp_ feels that haskell needs some dedicated time to learn, not the windows got during the week .... the time is this weekend
08:34:38 <shapr> eddyp_: You'll probably enjoy Haskell! It can teach you some nifty mental tricks!
08:34:46 <sjanssen> if we follow dwm closely the window will always be inserted at the top of the stack (and the stack's order remains the same)
08:34:49 <shapr> I even started sorting my socks differentely after I learned Haskell.
08:35:12 <eddyp_> shapr: heh, now that's a quote for bash.org
08:35:14 <chessguy> ?remember shapr I even started sorting my socks differentely after I learned Haskell.
08:35:15 <lambdabot> Done.
08:35:20 <shapr> :-)
08:35:22 <sjanssen> shapr: mergesort?
08:35:27 <edwinb> I wonder what langauge I'd have to learn to start sorting my socks at all
08:35:57 <eddyp_> @list
08:35:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:36:20 <shapr> sjanssen: Yeah, and I switched most processes in my life to have just one base case and one iterate case. That makes things simpler. Then I can think about fun stuff while I'm doing those processes.
08:37:02 <narain> shapr: man, i'll have to try that
08:37:41 <eddyp_> chessguy: how do you use that quote now?
08:37:49 <narain> ?quote socks
08:37:49 <lambdabot> shapr says: I even started sorting my socks differentely after I learned Haskell.
08:37:59 <eddyp_> cool
08:38:07 <chessguy> @quote shapr
08:38:08 <lambdabot> shapr says: I even started sorting my socks differentely after I learned Haskell.
08:38:09 <narain> my socks are in an unordered bag with linear access time
08:38:10 <chessguy> @quote shapr
08:38:11 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
08:38:11 <lambdabot>  what you just said?"
08:38:27 <shapr> Heh, that was at the last Haskell Workshop.
08:38:52 <chessguy> @quote shapr
08:38:52 <lambdabot> shapr says: Academics are continually chewing pieces off of impossible and making them merely difficult.
08:39:00 <quicksilver> my socks are in a bag with nondeterministic access time
08:39:26 <chessguy> see what you started, shachaf
08:39:32 <chessguy> err, shapr
08:39:36 <Vq^> http://arda.no-ip.org/burkopt.png <- HaskellCharts candy
08:39:49 <sjanssen> I use bogosort on my socks
08:40:24 <sjanssen> sometimes I'm up all night sorting my socks
08:40:32 <flux-> my sock sorting algorithm became much more efficient, after I dumped all non-conforming socks and bought a few dozen black socks
08:40:46 <flux-> O(1), infact!
08:40:58 <eddyp_> my socks are on the clothline
08:41:40 <flux-> (actually I also have white socks, but only a few, but I suppose it still makes my algorithm O(n)..)
08:41:57 <Uncountable> flux-: you still need to find left and right socks
08:42:33 <flux-> uncountable, um, no :)
08:42:38 <chessguy> what? who has left and right socks?
08:42:46 <Uncountable> i do :(
08:42:56 <Uncountable> if i've worn a sock on my left foot, i can't wear it on my right foot
08:43:15 <sjanssen> I hang my shirts and pants in a hashing like scheme
08:43:29 <flux-> sjanssen, apartment = the hash table?
08:43:38 <LoganCapaldo> My algo is O(n^2). Everything is one giant pile of clothes ;)
08:43:46 <flux-> sjanssen, I'm curious about the lookup algorithm tough
08:44:11 <zbrown> Uncountable: how?
08:44:12 <LoganCapaldo> I'm surprised at the hashing, I would think a heap or a tree would be better in meatspace
08:44:12 <zbrown> lol
08:44:13 <shapr> Uncountable: Oh, I have left foot right foot socks too.
08:44:33 <earthy> there's walking socks that are actually created to be worn on one particular foot
08:44:36 <earthy> left or right
08:44:43 <earthy> these tend to also be marked as such. :)
08:44:58 <sjanssen> flux-: okay, I'll give an example.  Obviously the hash for "khaki pants with the ink stain near the left pocket" is 19
08:45:43 <Uncountable> zbrown: my foot modifies the shape of the sock. if i wear a left sock on my right foot i get big hole where my left big toe usually is
08:45:45 <sjanssen> so I look at index 19 in the closet.  Oh no! there's a collision with "blue polo shirt".  I resort to scanning the closet after the shirt, and find the pants at 21
08:45:50 <shapr> Vq^: Pretty HaskellChart... is there a repo or other online version of Graphics.Rendering.Chart ?
08:46:08 <Botje> data Sock = Left | Right | Both
08:46:20 <chessguy> you guys are seriously wierd
08:46:22 <shapr> Botje: I have data Sock = Left | Right | New
08:46:23 <Uncountable> no, no
08:46:25 <Uncountable> Sock = Either
08:46:43 <dylan> type Sock = Maybe Either
08:46:47 <sjanssen> I'm really surprised at this left/right sock thing
08:46:48 <shapr> dylan: right!
08:46:51 <sjanssen> dylan: kind error!
08:47:01 <sjanssen> @kind Maybe Either
08:47:03 <dylan> hmm, yes.
08:47:03 <lambdabot>     `Either' is not applied to enough type arguments
08:47:03 <lambdabot>     Expected kind `*', but `Either' has kind `* -> * -> *'
08:47:04 <LoganCapaldo> sjanssen: The amount of clothes in your wardrobe doesn't change often though, right? Why not use a perfect hash?
08:47:08 <eddyp_> chessguy: weird is another word for "different than what I'm accustomed to"
08:47:09 <shapr> sjanssen: I thought most people did that. My girlfriend has type Sock = Maybe Either also.
08:47:21 <vincenz> type Sock smelly cheesy = Maybe (Either smelly cheesy)
08:47:24 <fantasma> sjanssen: how would you feel about having a DNS entry for darcs.xmonad.org which points to the IP of darcs.haskell.org?
08:47:40 <vincenz> shapr: what's a maybe either sock?
08:47:48 <sjanssen> fantasma: that's okay
08:47:59 <sjanssen> (meaning affirmative)
08:48:05 <shapr> vincenz: The first time I put on a sock, it tends to deform permanently to being a left or right footed sock.
08:48:14 <earthy> Just Left a, Just Right b or Nothing
08:48:21 <fantasma> sjanssen: I have darcs installed on the host but there can only be one account per site
08:48:22 <Vq^> shapr: http://dockerz.net/twd/HaskellCharts
08:48:23 <lambdabot> Title: HaskellCharts - twd
08:48:27 <chessguy> shapr, must be from all the unicycling
08:48:29 <vincenz> earthy: get your parens right
08:48:34 <shapr> vincenz: So type Sock = Maybe Either means that a new sock is not yet deformed, but a used sock is not set one way or the other.
08:48:37 <shapr> chessguy: Actually, yes.
08:48:47 <Vq^> shapr: it uses cairo as backend
08:48:52 <vincenz> shapr: no you need dependent types for that (ifUsed Either )
08:49:01 <sjanssen> vincenz: or you're sock-bidextrous
08:49:06 <shapr> chessguy: I try to do at least one hour of unicycling each day. That puts a lot of wear and tear on socks.
08:49:30 <vincenz> shapr: go sockless
08:49:35 <shapr> I'm quite picky about unicycling socks. The short Nike extra-wicking sport socks are my favorite.
08:49:39 <dylan> vincenz: blisters?
08:49:41 <shapr> vincenz: I'd have no skin on my feet.
08:49:45 <chessguy> shapr, why does it put more wear on one than the other though?
08:49:50 <vincenz> flipflops!
08:50:04 <dylan> unicycling in flip flops sounds dangerous
08:50:24 <vincenz> <nerd> depends what kind of flipflop HUHHU </nerd>
08:50:24 <chessguy> dylan, in my case, s/ in flip flops//
08:50:25 <shapr> chessguy: Wear is equal per side, but permanently deforms the sock.
08:50:30 <mauke> > flip flop
08:50:30 <lambdabot>   Not in scope: `flop'
08:51:26 <sjanssen> I wonder if I could increase the life of my socks by assigning them sides
08:52:20 <shapr> chessguy: I weigh about 220-230 pounds (100-105 kilos) and I jump over stuff and drop off stuff. Sadly, I don't have the math in my head to figure out how much weight is applied to my socks after I drop a third of a meter.
08:52:50 * shapr thinks 9.9 meters per second squared squared. hmm
08:52:55 <eddyp_> sjanssen: probably the oposite, if one damagesm you'll have to drop the pair
08:52:57 <Botje> i'd say friction is a much bigger problem wrt socks
08:53:02 <vincenz> 9.81
08:53:06 <vincenz> if you're talking grav
08:53:07 <shapr> vincenz: Ah, thanks.
08:53:43 <vincenz> shapr: but to get that kind of calculation... you need momentum
08:53:48 <sjanssen> @google acceleration due to earth's gravity
08:53:51 <lambdabot> http://en.wikipedia.org/wiki/Standard_gravity
08:53:51 <lambdabot> Title: Standard gravity - Wikipedia, the free encyclopedia
08:53:56 <narain> @google g
08:53:59 <eddyp_> vincenz: depends on the location and altitude, but roughly, yes...
08:54:00 <lambdabot> http://gmail.google.com/
08:54:03 <sjanssen> oh, c'mon, that should be a constant
08:54:19 <sjanssen> @google speed of light in hogsheads per fortnight
08:54:21 <lambdabot> http://www.waxy.org/archive/2003/08/14/fun_with.shtml
08:54:21 <lambdabot> Title: Waxy.org: Daily Log: Fun with Google's Calculator
08:54:41 <sjanssen> oops, hogshead is volume
08:54:48 <narain> actually what you'd need to reckon is your momentum, stopping time, lateral force, coefficient of friction, ...
08:55:01 <narain> shapr: ^^^
08:55:07 <sjanssen> @google speed of light in rods per fortnight
08:55:08 <lambdabot> the speed of light = 7.21047 x 10^13 rods per fortnight
08:55:28 <shapr> narain: Yeah, but a rough approximation would be 100 kilos falling one third of a meter.
08:55:30 <chessguy> that's a lot of rods
08:55:45 <vincenz> Eelis brings up a good point.  Why doesn't the tuple operator (,) support slicing?
08:55:54 <vincenz> > (3,) 3
08:55:54 <lambdabot>  Parse error
08:56:02 <shapr> Because you can only slice sequences?
08:56:02 <fantasma> what's a good way to go about finding dedicated colo hosting?
08:56:02 <mauke> because it's not really an operator
08:56:07 <narain> shapr: unit error
08:56:12 <quicksilver> > (,) 3 3
08:56:13 <vincenz> mauke: I know but you could give slicing to the , `operator` as well
08:56:13 <lambdabot>  (3,3)
08:56:14 <sjanssen> @google 40 rods per hogshead in miles per gallon
08:56:15 <lambdabot> 40 (rods per hogshead) = 0.00198412698 miles per gallon
08:56:18 <LoganCapaldo> vincenz: I think you mean sections
08:56:24 <vincenz> LoganCapaldo: yes, thx
08:56:25 <quicksilver> you can't do infix sections with it, no, it's true
08:56:35 <sjanssen> whoa, Abe's car has terrible gas efficiency!
08:56:39 <quicksilver> I can't think of a good reason, though
08:56:44 <shapr> fantasma: I use tektronix, they're decent. $15 a month gets me a virtual server running Debian.
08:56:45 <mauke> (a, , c) b would be cool
08:56:45 <quicksilver> I suspect Simonic Laziness
08:57:04 <fantasma> shapr: wow that is a fantastic deal
08:57:14 <narain> @google 1 mile per gallon in 1/centimeters^2
08:57:16 <lambdabot> http://www.smogsite.com/calculators.html
08:57:16 <lambdabot> Title: Free Automotive Calculators
08:57:17 <sjanssen> quicksilver: tuple sections aren't in the Haskell report either
08:57:24 <vincenz> sjanssen: wait...rod is a distance
08:57:30 <Eelis> so then, looks like we've found a new feature for Haskell prime ;)
08:57:33 <vincenz> sjanssen: so hoghshead = time/quantity?
08:57:36 <narain> you know mileage has the units of inverse area?
08:57:46 <narain> length/volume
08:57:48 <shapr> fantasma: It's okay, you can get equally good deals if you want to tradeoff towards more bandwidth, more peformance, etc.
08:57:52 <mauke> @google 1 mile per gallon in km/l
08:57:53 <lambdabot> 1 mile per gallon = 0.425143706 kilometers / l
08:57:53 <earthy> there's some problems with tuple sections however
08:58:04 <vincenz> @google 2 hogshead in kilo per second
08:58:04 <quicksilver> sjanssen: right. I was joking about the simons :)
08:58:05 <lambdabot> http://www.unc.edu/~rowlett/units/dictB.html
08:58:05 <lambdabot> Title: Units: B
08:58:06 <narain> @google 1 mile per gallon in 1/cm/cm
08:58:07 <earthy> there was some stuff about it on the haskell' mailing list a while ago. ;)
08:58:07 <lambdabot> No Result Found.
08:58:08 <quicksilver> earthy: what's that?
08:58:20 <Nafai> Morning
08:58:21 <Nafai> I couldn't sleep last night...so instead of watching TV I read a couple chapters of "The Craft of Functional Programming"!
08:58:31 <fantasma> shapr: do you know of a site where I can compare different deals?
08:58:32 <shapr> Nafai: Cool!
08:58:33 <sjanssen> by "some stuff" earthy means "medium sized flamewar"
08:58:34 <earthy> quicksilver: the basic problem is that they introduce ambiguity that you might not want
08:58:58 <shapr> fantasma: No, but I'd suggest you ask here on #haskell once every twelve hours or so, and then collate the responses.
08:59:09 * earthy 's flamewar tolerance must've gotten higher due to having hung out on netnews for a couple of years
08:59:10 <vincenz> by "medium sized flamewar" sjanssen means "hardly a blip on the radar w.r.t. standard cll discussions"
08:59:19 <fantasma> hahaha
08:59:32 <quicksilver> earthy: example?
08:59:36 <fantasma> well I can't seem to find tektronix
08:59:43 <shapr> I'll get the url...
08:59:47 <vincenz> earthy: well get onto the gentoo-dev list or the cll list :)
08:59:53 <vincenz> earthy: you'll recover soon enough
09:00:11 <shapr> fantasma: Ah, probably because I misspelled it - http://www.tektonic.net/wiki/index.php/Main_Page
09:00:14 <lambdabot> Title: Main Page - TekPedia
09:00:16 <sjanssen> quicksilver: (3,4,) -- did the user intend a tuple section, or is there a stray comma?
09:00:33 <vincenz> sjanssen: typing will sovle that
09:00:36 <vincenz> s/sovle/solve
09:00:40 <Eelis> sjanssen: the same could be said about (3:)
09:00:46 <shapr> fantasma: Tektonic was suggested to me via #haskell and debian developer connections.
09:00:47 <earthy> vincenz: I am not that masochistic. ;)
09:01:00 <vincenz> earthy: or #ocaml
09:01:01 <fantasma> thanks shapr
09:01:06 <quicksilver> sjanssen: ah. Hmm. I'd be happy to call that a tuple section.
09:01:14 <dylan> this sister company, unixshell, was sucky as heck.
09:01:15 <shapr> fantasma: Sure, if you need anymore info, feel free to ask me.
09:01:18 <dylan> *their
09:01:25 <sjanssen> there are also people who want (1,2,3,) to be the same as (1,2,3)
09:01:33 * quicksilver nods
09:01:35 <Eelis> kill those people
09:01:36 <vincenz> sjanssen: there are some people that like perl
09:01:39 <mauke> those people are wrong
09:01:46 <mauke> however [1,2,3,] could be the same as [1,2,3]
09:01:47 <shapr> dylan: Tektonic is flaky sometimes.
09:02:09 <sjanssen> mauke: doesn't that seem a bit inconsistent?
09:02:13 <mauke> no
09:02:14 <shapr> dylan: Their tech support people aren't especially clueful either. But I can do almost everything by myself, so I don't argue much.
09:02:22 <mauke> lists and tuples are totally different things
09:02:30 <vincenz> smart people are welcome to #oasis :)
09:02:41 <sjanssen> mauke: they have incredibly
09:02:46 <mauke> (x*2 | x <- (1,2,3)) doesn't work either
09:02:46 <sjanssen> similar syntax
09:03:26 <sjanssen> the same arguments for extra commas in lists apply to tuples
09:03:32 <mauke> [] is full of special cased syntax: comprehensions, enumerations, etc
09:03:47 <mauke> sjanssen: no, they don't
09:03:50 <ndm_ads> @seen malcolmw
09:03:50 <lambdabot> malcolmw is in #ghc, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell. I last heard malcolmw speak 57m 9s ago.
09:03:51 <sjanssen> mauke: and how do you feel about extra commas in record syntax?
09:04:01 <mauke> sjanssen: better
09:04:08 <ndm_ads> malcolmw, i've applied to be a mentor - is it you who can accept me?
09:04:23 <malcolmw> ndm_ads: yup
09:04:51 <sjanssen> mauke: the primary argument is that it makes it easier to swap the order of elements.  Is it truly inconceivable that you'd want to do this for a tuple?
09:04:58 <malcolmw> ndm_ads: I can see your application now
09:05:36 <ndm_ads> can anyone access http://www.intellectbooks.co.uk/
09:05:56 <mauke> sjanssen: I thought the primary argument is that you might want to add/remove elements
09:06:01 <Igloo> ndm_ads: I can't
09:06:10 <earthy> ndm_ads: seems unresponsive
09:06:12 <ndm_ads> :( - i can't see if my paper has been published yet
09:06:13 <mauke> which changes the type of your tuple
09:06:20 <ndm_ads> (from TFP 2005...)
09:06:23 <sjanssen> mauke: that too, they're nearly equivalent statements
09:06:30 <shapr> malcolmw: I just applied also.
09:06:45 <sjanssen> mauke: and sometimes you need to change your types
09:07:12 <mauke> yeah, but you shouldn't use huge tuples
09:07:19 <Nafai> I'm feeling slow :(
09:07:20 <ndm_ads> malcolmw, i'm now accepted
09:07:29 <mauke> I don't think the language syntax needs to make that easy
09:07:36 <shapr> sjanssen: Two things, Python allows trailing commas in both list and tuple. It also has a one element tuple written as (,)
09:07:55 <ndm_ads> do we work in the trac, then only move over to the google system after?
09:08:24 <shapr> mauke: It seems to me that when I'm trying to solve a problem, adding new commas in the right place is only part of the accidental difficulty, not the essential difficulty
09:08:33 <Nafai> I'm trying to write something that will use map to return a list of 1's the same size as an existing list
09:08:46 <Nafai> But for some reason map (1:) [1,2,3,4] doesn't work
09:08:56 <mauke> > map (1:) [1,2,3,4]
09:08:56 <lambdabot>   add an instance declaration for (Num [t])
09:08:56 <lambdabot>     In the expression: 4
09:09:00 <malcolmw> shapr: accepted now
09:09:02 <sjanssen> @type (1:)
09:09:05 <lambdabot> forall t. (Num t) => [t] -> [t]
09:09:06 <psi> > map (const 1) [1..10]
09:09:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
09:09:20 <glguy> > [1..10] >> [1]
09:09:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
09:09:25 <mauke> > [ 1 | _ <- [1,2,3,4] ]
09:09:26 <lambdabot>  [1,1,1,1]
09:09:28 <encryptio> @src liftM
09:09:28 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:09:38 <sjanssen> Nafai: (1:) is a function from lists to lists.  The list you're mapping on isn't filled with lists
09:09:38 <Nafai> Thanks! :)
09:09:59 <Nafai> sjanssen: Okay, thanks.
09:10:09 <encryptio> @src fmap
09:10:09 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:10:11 <mauke> > map (1:) [[1],[2],[3],[4]]
09:10:12 <lambdabot>  [[1,1],[1,2],[1,3],[1,4]]
09:10:15 <Nafai> Woot.
09:10:20 <chessguy> @pl \x -> 1:[x]
09:10:20 <lambdabot> (1 :) . return
09:10:24 <shapr> mauke: For example, a chunk of code for haskell-mode that would automatically add a new item to a tuple/list would be simpler if it could just find a comma, add a CR, indent, put in a new comma, and put the cursor before that comma.
09:10:28 <Nafai> That helped me write length in terms in map and sum! :)
09:10:49 <chessguy> > map ((1:).return) [1,2,3,4]
09:10:51 <lambdabot>  [[1,1],[1,2],[1,3],[1,4]]
09:11:07 <mauke> shapr: yes, I just don't think it should be easy for tuples
09:11:26 <shapr> Because they're types instead of sequences?
09:11:29 <kokr> @pl \f g l -> filter f (map g l)
09:11:30 <lambdabot> (. map) . (.) . filter
09:11:31 <glguy> > map concat . mapM (([]:).(:[]).(:[])) $ [1..3]
09:11:37 <mauke> shapr: yeah
09:11:39 <shapr> hmm
09:11:44 <glguy> > map concat . Control.Monad.mapM (([]:).(:[]).(:[])) $ [1..3]
09:11:45 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
09:11:55 <shapr> That's an interesting point.
09:11:56 * glguy is surprised that the namespace has remained broken for so long
09:12:08 <mauke> shapr: and if you have tuples with, say, >5 elements, you're probably doing something wrong
09:12:09 <shapr> hiya glguy!
09:12:15 <glguy> lo :)
09:12:49 <shapr> mauke: How so? Do you think large tuples should be type declarations instead?
09:13:04 <shapr> mauke: I'm discounting HList for this discussion of course...
09:13:05 <encryptio> @src mapM
09:13:05 <lambdabot> mapM f as = sequence (map f as)
09:13:10 <roconnor> usually if you have tupples >2 elements, you are probably doing something wrong
09:13:12 <Philippa> they should probably be records instead
09:13:12 <mauke> shapr: yeah, or records
09:13:15 <roconnor> er tuples
09:13:23 <roconnor> that's why I always use nested pairs
09:13:24 <mauke> something that you can access unposititionally
09:13:24 <ski> lightweight records !
09:13:31 <Philippa> nested pairs're no better, IMO
09:13:33 <roconnor> (a,(b,(c,(d,e))))
09:13:36 <roconnor> ;)
09:13:43 <ski> (a,(b,(c,(d,(e,())))))
09:13:44 <Philippa> and suggest lisp addiction
09:13:52 <chessguy> ?spell pairs're
09:13:54 <lambdabot> pair's parser pairs parse praiser
09:13:58 <mauke> > foldr (flip id) 0 (map (const succ) [1 .. 10])
09:13:59 <lambdabot>      Occurs check: cannot construct the infinite type: c = a -> c
09:13:59 <lambdabot>     Probabl...
09:14:00 <sjanssen> the only advantage to nested pairs is that they're slower ;)
09:14:09 <shapr> Yeah, we had a discussion about nested pairs and equality recently...
09:14:15 <roconnor> sjanssen: you can use fst and snd on pairs
09:14:18 <mauke> > foldr id 0 (map (const succ) [1 .. 10])
09:14:19 <lambdabot>  10
09:14:21 <Philippa> chessguy: it's a contraction, perfectly grammatically valid english. "pairs're" => "pairs are"
09:14:24 <shapr> (a,(b,()) is not equal to (b,(a,())
09:14:36 <glguy> nested pairs seems like an awful hack just to use fst and snd
09:14:56 <shapr> Nested pairs seem like the only hack to get heterogenous lists in Haskell.
09:15:07 <roconnor> glguy: often I want to pull a layer of data off and pass the rest on
09:15:25 <uccus> shapr: I thought existential types do the trick, don't they?
09:15:27 <shapr> roconnor: Couldn't you do that with a monad transformer?
09:15:30 <Philippa> shapr: give or take, yeah. But only in the same way lists're "nested pairs" in the first place
09:15:36 <shapr> uccus: Oh yeah
09:15:38 <ski> roconnor : but you have to decide an appropriate ordering of the data
09:15:45 <glguy> uccus: only if the elements all implement a common typeclass
09:15:48 <Philippa> no, they just redefine 'homogenous' slightly
09:15:50 <sjanssen> uccus: they give you heterogenous lists in other situations
09:16:02 <roconnor> ski: the order is the order that I want to peel data off.
09:16:17 <sjanssen> nested tuples are for lists where the type reflects the structure of the list
09:16:25 <ski> what if you want different orders in different (but communicting) places ?
09:16:35 <shapr> roconnor: You could nest Reader/Writer monads as is done in lambdabot, yeah?
09:16:38 <roconnor> ski: then I have to do a bit of work :(
09:16:59 <shapr> ski: cry?
09:17:21 * shapr gråter
09:17:50 <ski> (hm .. maybe antassanassow(spelling ??)'s automatic isomorphism idea could help ..)
09:18:04 <quicksilver> I use nested pairs on my old-fashioned parser combinators
09:18:08 <shapr> ski: What's that?
09:18:15 <shapr> franka comes up with a bunch of nifty ideas.
09:18:16 <quicksilver> but that's only because I haven't drunk deeply enough of the arrow/monad koolaid
09:18:17 <sjanssen> roconnor could also use HList records
09:18:18 <uccus> what if we had a typeclass that has all the small types included? a typeclass with no functions?
09:18:37 <Philippa> quicksilver: it's likely you either have an arrow or have something easily refactorable into one, FWIW
09:19:02 <quicksilver> Philippa: yes, I know :)
09:19:05 <quicksilver> Philippa: and/or a monad
09:19:18 <ski> shapr : well, afaik, it's not definite (yet) .. but loose idea that the type-system should be able to insert appropriate isomorphisms between "almost-matching" pieces of code .. at least in some cases (maybe when O(1) conversion ??)
09:19:31 <quicksilver> Philippa: I just have an old fashioned sequence combinator with type Parser a -> Parser b -> Parser (a,b)
09:19:41 <shapr> ski: How would that work?
09:19:44 <quicksilver> Philippa: when you compose it deeply, you get nested pairs aplenty :)
09:19:51 * ski doesn't know .. ask franka :)
09:19:55 <shapr> ski: Too much magic means people don't understand what happening.
09:19:59 <quicksilver> Philippa: I think I learnt this stuff from Paulson's ML book and I never got out of the habit
09:20:08 <ski> shapr : could be
09:20:12 <chessguy> shapr, that sounds deep
09:20:33 <shapr> In fact, monads are very simple once people stop skipping the 'magic' parts.
09:21:05 <sris> Anyone here know if there exist an irc channel about formal language theory?
09:21:12 <quicksilver> ski: various languages do varioius kinds of automatic converssion and it often leads to pain :)
09:21:24 <quicksilver> ski: that's not to say that it might not be possible to design something elegant which didn't
09:21:26 <Philippa> quicksilver: as-is, it's not an Arrow and it'd require major surgery to become a monad. Not too hard to refactor into an arrow, though
09:21:41 <shapr> sris: You could try it here.
09:21:58 <Philippa> sris: depending on what you mean, #ltu might be useful if anyone's talking
09:22:00 <quicksilver> Philippa: I thought it was a monad? Parser a expands into toks -> (a,toks)
09:22:01 * ski thinks there should be a type class for 'm a -> m b -> m (a,b)'
09:22:10 <quicksilver> Philippa: I thought it was just a state monad
09:22:22 <shapr> hei esap!
09:22:28 <esap> hei shapr!
09:22:29 <ski> esap : hiya
09:22:31 <sris> shapr: if i have a langunage L does the notaion L^R mean somethings special, and not "all strings with length R"?
09:22:35 <Philippa> quicksilver: fair enough, yeah, that probably is a monad - your sequence op's unconventional for a monad though, there's no point in having it if you have bind
09:22:37 <shapr> ski: Arrows have that idea already, yeah?
09:22:38 <esap> ski: hi!
09:22:49 <shapr> sris: In what context?
09:23:00 <quicksilver> Philippa: right :) my sequence op is a broken version on bind. This I know :)
09:23:04 <quicksilver> Philippa: but old habits die hard.
09:23:09 <sris> shapr: "formal languages" so none really
09:23:11 <ski> (sris : wondering .. is 'R' a language there ?)
09:23:19 <sris> ski: not that i know
09:23:32 <shapr> sris: Are you looking at a particular book or paper?
09:23:32 <Philippa> sris: if R's a natural, I'd expect L^2 = LL
09:23:59 <sris> shapr: yeah it's an exercise and i haven't been able to buy the litterature, so im trying to find a resource for this kind of things
09:24:49 <sris> T = {0,1},  { X \in T* | \existsY \in T^2, X = YY^RY }
09:24:54 <sris> that's the kind of thing im looking at
09:24:56 <chessguy> > const 0 (undefined :: Set (Int -> Int))
09:24:57 <lambdabot>   Not in scope: type constructor or class `Set'
09:25:47 <shapr> sris: That looks a bit like the definitions in Types and Programming Languages.
09:26:38 <quicksilver> Philippa: which is best paper about arrow parsers?
09:26:39 <sris> that's a book?
09:26:42 <shapr> sris: Yup
09:26:45 <chessguy> ?where TAPL
09:26:45 <lambdabot> http://tinyurl.com/282m6x
09:27:03 <malsyned> is there an automatic way to derive predicates for the various tags in a data declaration?
09:27:04 <shapr> sris: It's a very nifty book if you have an interest in how type theory applies to programming languages.
09:27:09 * chessguy has his eye on that book next
09:27:12 <quicksilver> chessguy: Data.Set requires Ord instances, and (Int -> Int) doesn't have an ord instance
09:27:23 <sris> allright, well, i'll just until i get my hands on a book, it pretty hard googles stuff, or maybe i just try the wrong stuff. but thanks anyway
09:27:24 <shapr> sris: Also, TaPL clearly describes how its notation behaves.
09:27:33 <quicksilver> chessguy: mind you, it's not very hard to supply a slightly arbitrary Ord instance for (Int -> Int)
09:27:34 <sris> i see, thanks
09:27:43 <quicksilver> might be a slow one, if you plan to store expensive functions :)
09:27:50 <shapr> sris: I *think* it's denotational semantics, but let me grab the book off of my shelf and check...
09:27:54 <chessguy> quicksilver, yeah, i just realized that Set in this case refers to a custom data type
09:28:00 <quicksilver> chessguy: ah
09:28:08 <sris> oh, nice, thanks a lot
09:28:20 <chessguy> quicksilver, finally another answer to my kind question
09:28:46 <chessguy> and a hair less incomprehensible than Oleg's
09:29:07 <doserj> malsyned: Drift
09:29:24 <malsyned> ?hoogle Drift
09:29:24 <lambdabot> No matches found
09:29:29 <malsyned> ?where Drift
09:29:30 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
09:30:17 <malsyned> doserj: thanks
09:30:46 <shapr> sris: I can't find exactly what it's called, but if you start at page 26 of "Types and Programming Languages" you'll understand the notation you just described.
09:31:04 <shapr> I still think it's denotational semantics...
09:31:09 <sris> ok, it seem to be availabe at google book so i have a look, thanks
09:31:27 <chessguy> what? TAPL is available online?
09:31:31 <shapr> sris: It's a wonderful book. Worth purchasing.
09:31:46 <quicksilver> :t \f g -> head . filter (/=EQ) . map (\x -> compare (f x) (g x)) $ [0..]
09:31:55 <lambdabot> forall a a1. (Ord a1, Num a, Enum a) => (a -> a1) -> (a -> a1) -> Ordering
09:32:25 <quicksilver> chessguy: there's an ordering on Int -> Int with the TEENSTY disadvantage that it diverges on equal functions :)
09:33:31 <sjanssen> ndm_ads: ping
09:35:01 <vincenz> quicksilver: TEENSTY?
09:35:18 <quicksilver> :)
09:35:27 <vincenz> what doesthat mean?
09:35:32 <quicksilver> maybe that word is better spelty teensie?
09:35:36 <quicksilver> it means 'very small'
09:35:53 <vincenz> you have a virus introducing random 'ty's?
09:36:06 <quicksilver> it's a (n informal) diminutive form of teeny which is itself a familiar form of tiny
09:36:21 <quicksilver> I've never thought of trying to write it down before, it's mostly a spoken form :)
09:36:28 <quicksilver> chessguy: yes
09:36:36 <kc5tja> Long live Dvorak layout!
09:36:37 <quicksilver> chessguy: I was on the right general track, wasn't I?
09:36:46 <kc5tja> Then you can have virii that introduce TNs instead.  :)
09:36:55 <mauke> s/virii/viruses/g
09:37:04 <quicksilver> chessguy: the contrainst is on the constructors not really on the type
09:37:07 <mauke> VIRII IS NOT A WORD
09:37:09 <kc5tja> mauke: Whatever.  I enjoy wallowing in my ignorance.
09:37:21 <mauke> where do people get the "ii" from?
09:37:21 <kc5tja> mauke: Well, it ought to be.
09:37:23 <glguy> mauke: do you have the capslock virii?
09:37:40 <mauke> kc5tja: no, because there is no "virius"
09:37:40 <malsyned> glguy: there's more than one?!
09:37:49 <sjanssen> what's the problem maukii?
09:37:49 <kc5tja> mauke: Virus is a word that sounds an awful lot like a Latin word.  And most latin words, in the plural, have ii as a suffix.
09:37:51 <chessguy> quicksilver, how do you figure?
09:37:56 <mauke> kc5tja: bullshit
09:38:01 <quicksilver> chessguy: that's what Pablo was saying, basically
09:38:07 <chessguy> the type is parameterized over only some types, not all
09:38:12 <kc5tja> mauke: If you are going to get hostile over it, you have personal problems.
09:38:14 <quicksilver> chessguy: that's why undefined :: Set (Int -> Int) is permitted in haskell
09:38:19 <shapr> kc5tja: aoeuhtns?
09:38:22 <quicksilver> chessguy: no, that's what you *want* to believe
09:38:26 <mauke> virus is a latin word but only some words ending in -us have an -i plural
09:38:30 <mauke> -i, not -ii
09:38:32 <quicksilver> chessguy: that's what *should* be the case
09:38:38 <quicksilver> chessguy: but it's not what haskell actually does :)
09:38:50 <kc5tja> mauke: Fine.  But you didn't need to get violent.
09:39:02 <mauke> e.g. magnus -> magni, filius -> filii
09:39:12 <mauke> but tempus -> tempora
09:39:22 <mauke> virus doesn't even have a plural form
09:39:22 <chessguy> well, whatever, the fact remains that the notation should reflect the language
09:40:02 <kc5tja> Languages need to become less arbitrary.
09:40:14 <quicksilver> lojban!
09:40:26 <roconnor> perl!
09:40:34 <quicksilver> kc5tja: http://xkcd.com/c191.html
09:40:36 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
09:40:36 <kc5tja> .ui go'i
09:40:57 <shapr> xu do tavla bau la lojban
09:41:00 <kc5tja> quicksilver: I've seen it before.
09:41:19 <quicksilver> kc5tja: xkcd comics are always worth reading again though :)
09:41:19 <shapr> mi djica lenu mi gunka
09:41:42 <kc5tja> shapr: .i na go'i
09:42:08 * kc5tja has to look up gunka.
09:42:45 <shapr> go'i ri'a ma
09:42:54 <kuribas> quicksilver: Is it possible to write a lexer and a Parser both using Parsec?
09:43:00 <quicksilver> kuribas: yes, it is
09:43:26 <kuribas> How do you pass the information like sourceposition, etc.?
09:43:26 <sjanssen> won't that lexer be really slow?
09:45:07 <malcolmw> better to write a lexer by hand, and pass a Token stream into the parser
09:45:35 <kuribas> Can the Token stream be a list of strings to be parsed later?
09:46:04 <quicksilver> the token stream can be whatever you like
09:46:26 <quicksilver> I use something like Token = Name String | Symbol String | StringLit String | NumLit Int
09:46:48 <quicksilver> (on the other hand, I don't use parsec at all)
09:47:06 <kuribas> What do you use?
09:47:13 <quicksilver> I just write parser combinators by hand
09:47:32 <quicksilver> using a 20-year style I picked up from Paulson :P
09:47:45 <jyasskin> "in the snow, uphill both ways"?
09:47:50 <quicksilver> nah, it isn't
09:47:55 <quicksilver> writing your own combinators is really easy
09:48:00 <quicksilver> and you get to choose the syntax you like
09:48:06 <quicksilver> I'm not fond of parsec syntax
09:48:21 <quicksilver> I always write infinite-lookahead full-backtracking parsers
09:48:29 <quicksilver> which is inefficient but I don't often care :)
09:48:38 <quicksilver> (if I cared about efficiency I could go back and fix it)
09:48:46 <malcolmw> quicksilver: it is quite easy to get bad performance and poor error messages out of roll-your-own combinators
09:48:55 <quicksilver> malcolmw: the performance has never mattered to me
09:49:01 <quicksilver> malcolmw: since parsing has never been a critical path
09:49:07 <ndm> is there any way for a program to tell if its running under ghc or ghci?
09:49:11 <quicksilver> malcolmw: as for error messages, I plead guilty as charged :)
09:49:12 <malcolmw> the error messages are more important to me as well
09:49:19 <mauke> the advantage of not using parsec is that you get a working notFollowedBy
09:49:31 <kuribas> There is also http://www.cs.uu.nl/wiki/HUT/ParserCombinators
09:49:33 <malcolmw> quicksilver: but I did write my own parser combinators :-)
09:49:34 <lambdabot> Title: HUT / Parser Combinators
09:49:49 <malcolmw> http://www.cs.york.ac.uk/fp/polyparse
09:49:51 <lambdabot> Title: polyparse: alternative parser combinator libraries
09:50:05 <kc5tja> DANG!  There goes my idea of naming my CUT prototype in Haskell HUT.  ;D
09:50:05 <hpaste>  quicksilver pasted "paulson style parser combinators" at http://hpaste.org/987
09:50:13 <sjanssen> ndm: what do you mean by "add the appropriate magic to Cabal" in your recent FilePath email?
09:50:36 <quicksilver> jyasskin: that's how long it takes me to write parser combinators :)
09:50:48 <quicksilver> it's really only a few lines of code
09:50:53 <ndm> sjanssen: so that compiling a program with file that imports System.FilePath just works - i.e. you don't have to specify that you depend on filepath as well
09:51:04 <encryptio> what's the relation between mzero and fail?
09:51:17 <quicksilver> but the sequence operator builds you these lovely nested pairs which isn't really as smart as arrows or monads
09:51:22 <quicksilver> encryptio: fail takes a String argument
09:51:29 <quicksilver> encryptio: and fail (stupidly) is available in every Monad
09:51:31 <sjanssen> ndm: you mean you don't want the user to include it in the build-depends file?
09:51:35 <quicksilver> encryptio: but they represent the same thing
09:51:40 <ndm> sjanssen: yes
09:51:50 <sjanssen> ndm: I don't understand why you would want this
09:52:12 <ndm> sjanssen: the user doesn't have to specify they want to use Data.Map, why should they specifiy they want to use System.FilePath in their .cabal file?
09:52:32 <ndm> sjanssen: its another barrier to people using it, when if we stop people from using it they'll use much worse alternatives (i.e. string hacking)
09:52:39 <sjanssen> you're talking about typing exactly one word in a file that you write once per project
09:52:41 <malcolmw> ndm: I don't think that is the issue with Cabal - isn't it more about the fact that Distribution.Compat.FilePath is obsolete?
09:52:55 <ndm> malcolmw: thats a side issue
09:53:01 <sjanssen> ndm: I think implicit deps is a very bad idea
09:53:05 <ndm> sjanssen: yes, a barrier to people using it
09:53:16 <quicksilver> kuribas: does there exist up to date docs, or some examples, of HUT?
09:53:32 <ndm> malcolmw: that could do with being killed, but that is for the future
09:53:43 <ndm> currently cabal can't depend on anything outside of base, that is also an issue
09:53:44 <sjanssen> ndm: normal users use ghci or ghc --make (and both automatically add -package filepath)
09:53:45 <kuribas> quicksilver: There is a paper which is not very up to date.
09:53:58 <quicksilver> kuribas: yes, that's what I saw :(
09:54:19 <sjanssen> ndm: this automatic dep business means your package might build with cabal 1.x, but not cabal 1.y (where y < x)
09:54:24 <ndm> sjanssen: maybe its less of an isuse that i think - quite possible
09:55:36 <Igloo> ndm: Most Setup.hs's already depends on things outside of base, e.g. Cabal
09:55:53 <sjanssen> ndm: and you do have to write a dependency if you want to use Data.Map in a cabal package -- base
09:56:13 <ndm> Igloo: dcoutts always said filepath had to make it into base to be used by cabal, if he's changed his opinion then maybe thats different now
09:56:28 <jyasskin> quicksilver: Yeah, not much snow there. I stand corrected.
09:56:54 <quicksilver> jyasskin: :)
09:57:15 <quicksilver> jyasskin: equally, it's not very good. Esp. w.r.t error handling and so on
09:57:24 <quicksilver> jyasskin: but then, sometimes it's interesting to work this stuff out yourself
09:57:36 <quicksilver> jyasskin: my haskell programming is only a hobby so I can afford to get distracted by interesting stuff
09:58:54 <therp> quicksilver: getting distracted easily by interesting stuff is a good attitude :)
09:59:08 <fasta> How can I, given a graph that has not been specialized for the operation I want to implement, find a cycle of length k in this graph in O(k) in Haskell?
09:59:46 <quicksilver> therp: as long as actually getting things done isn't a priority :P
10:00:05 <quicksilver> therp: my PhD supervisor would have preferred me to get distracted a little less in the final few years of it :P
10:01:16 <quicksilver> fasta: I don't believe that's possible
10:01:18 <therp> quicksilver: my PhD efforts are a series of distractions. I wanted to do computer automatized stock/derivate trading in high-volume markets. now I have written half of my own programming language? FTW?!
10:01:27 <fasta> quicksilver: In a typed language it isn't.
10:01:43 <fasta> quicksilver: (well, at least I don't think so)
10:01:43 <quicksilver> fasta: are you saying that if I had a graph with 10 million nodes, and a cycle of length 5, I could find that cycle in a short time?
10:01:49 <quicksilver> because I don't believe that is possible
10:02:09 <fasta> quicksilver: no
10:02:16 <quicksilver> Surely O(nk) at best
10:02:24 <quicksilver> where n = number of nodes, k = cycle length
10:02:41 <fasta> quicksilver: I am saying that I want to find any cycle of any length k as long as it's in O(k)
10:02:53 <quicksilver> eh?
10:03:09 <jyasskin> fasta: Do you have code to do that in another language?
10:03:09 <quicksilver> but suppose there is only one cycle? and the graph is very big?
10:03:17 <fasta> quicksilver: so, if the algorithm finds a 9 million long cycle in the 10 million node graph, in O(g million) that's ok
10:03:17 <quicksilver> how can you hope to find it in O(k) ?
10:03:30 <quicksilver> oh, I see
10:03:33 <fasta> er O(9 million) (abusing notation)
10:03:38 <quicksilver> you don't know the cycle length in advance
10:03:41 <fasta> no
10:03:42 <quicksilver> you just want to find 'some cycle'
10:03:49 <quicksilver> and you're happy for it take as long as the cycle is big
10:03:55 <fasta> I don't know the cycle length in advance.
10:04:00 <fasta> Yes
10:04:07 <quicksilver> I still don't think that's possible :)
10:04:17 <quicksilver> if my 10 million node graph is almost completely acyclic
10:04:19 <fasta> I know how I could do it in Scheme.
10:04:24 <quicksilver> with just one single very small cycle
10:04:27 <fasta> Or in any other untuped language.
10:04:31 <fasta> untyped
10:04:37 <quicksilver> I don't see what types have to do with it
10:04:38 <fasta> Or dynamically typed
10:04:46 <quicksilver> I can imagine immutability being relevant, but not types
10:05:12 <kc5tja> @seen dons
10:05:12 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3h 27m 18s ago.
10:05:15 <fasta> Well, that implies I could also do it in Haskell, but that's a Turing tarpit argument.
10:05:27 <chessguy> hmm. some kind of finite-state machine?
10:05:35 <quicksilver> the turing argument makes no promise about execution time :P
10:05:36 <jgrimes> fasta: how would you do that at all? I don't understand how it could be O(k)
10:05:46 <quicksilver> jgrimes: I don't believe it can, personally
10:06:03 <chessguy> fasta, show us your scheme code
10:06:03 <fasta> quicksilver: are you sure you understand the problem?
10:06:04 <chessguy> !paste
10:06:05 <hpaste> Haskell paste bin: http://hpaste.org/
10:06:11 <quicksilver> fasta: no, I'm not sure
10:06:15 <fasta> chessguy: I don't have the Scheme code, but that doesn't matter.
10:06:24 <quicksilver> but suppose a 10 million node graph with only *one* cycle, and that cycle is of length 3
10:06:25 <chessguy> then pseudocode
10:06:26 <chessguy> or something
10:06:30 <shapr> Ohh, I know what SoC project I want to mentor!!
10:06:30 <quicksilver> I don't see how you can expect to find that cycle fast
10:06:32 * shapr boings furiously
10:06:45 <quicksilver> you'll have to check every node but 3, in the worst case
10:06:52 <fasta> quicksilver: hmm, oh, right, I forgot to mention some nice property of the graph
10:06:53 * chessguy administers a sedative to shapr
10:06:59 * shapr falls over asleep
10:07:06 * shapr snores quietly
10:07:07 <fasta> quicksilver: in a general graph you are trivially right
10:07:10 * chessguy switches shapr's socks while he sleeps
10:07:14 <shapr> AAH
10:07:14 <kc5tja> shapr: Sorry to be a bore.  :D
10:07:20 <fasta> quicksilver: simply take the graph without any edges.
10:07:26 <shapr> kc5tja: That was in response to chessguy sedating me ;-)
10:07:35 <kc5tja> Ahh
10:07:37 <quicksilver> fasta: well without any edges except one 2-cycle
10:07:38 <fasta> quicksilver: hmm, well, that's not true either
10:07:42 <kc5tja> I didn't see that.
10:07:44 <jyasskin> fasta: So what's your nice property?
10:07:44 <quicksilver> fasta: which is what I was thinking of :)
10:07:58 <quicksilver> unless you don't permit 2 cycles, in which case, 3-cycle
10:08:08 <shapr> chessguy: Seriously though, putting socks on the wrong feet for me is like putting shoes on the wrong feet. I've seen people do it, but I don't understand how they can survive that way.
10:08:22 <fasta> quicksilver: It doesn't matter what edge you take, since you will always find a cycle if you continue that way.
10:08:30 <fasta> quicksilver: (in the graph I am talking about)
10:08:39 <fasta> quicksilver: every edge lies on some cycle.
10:08:42 <shapr> kc5tja: Actually, that discussion with you reminded me of the SoC project I want to mentor!
10:08:46 <quicksilver> fasta: then Im' sure that algorithm can be translated into haskell
10:09:05 <fasta> quicksilver: the problem is that I need to mark whether something is already part of the cycle.
10:09:11 <quicksilver> fasta: I doubt there is anything in scheme which can' tbe translated into haskell at the same complexity, unless you're using metaprogramming
10:09:38 <fasta> quicksilver: I need to decide in constant time for a given vertex whether it has already been visited.
10:09:55 <quicksilver> fasta: then use an array to store visitedness
10:09:58 <fasta> quicksilver: if the graph doesn't contain a field for this apriori, it's not going to work.
10:10:04 <fasta> quicksilver: that doesn't work.
10:10:09 <quicksilver> why not?
10:10:28 <fasta> quicksilver: Suppose I have a graph containing node 1, 1000000000000, and 3. and it contains one cycle 1 100000*  and 3
10:10:36 <fasta> quicksilver: how is your array going to fit?
10:10:39 <thorkilnaur> fasta: Floyd cycle-finding?
10:10:49 <quicksilver> fasta: I shall renumber the nodes as I go
10:11:01 <quicksilver> fasta: into something sequential
10:11:03 <fasta> thorkilnaur: I remember that. I will look it up again.
10:11:11 <quicksilver> fasta: and accumulate the lookup table back to original names, obviously
10:11:15 <quicksilver> but that's only a constant overhead
10:11:17 <jyasskin> Or use an IntMap so a lookup is O(bits)
10:11:19 <fasta> quicksilver: again: that doesn't work.
10:11:24 <quicksilver> fasta: why not?
10:11:29 <chessguy> @go floyd cycle finding
10:11:31 <lambdabot> http://en.wikipedia.org/wiki/Floyd's_cycle-finding_algorithm
10:11:32 <lambdabot> Title: Floyd's cycle-finding algorithm - Wikipedia, the free encyclopedia
10:11:36 <chessguy> woohoo!
10:11:42 <chessguy> @karma+ wikipedia
10:11:43 <lambdabot> wikipedia's karma raised to 0.
10:11:50 <shapr> Does Floyd have a unicycling finding algorithm also?
10:12:03 <chessguy> @go floyd unicycle finding
10:12:06 <lambdabot> http://deadspin.com/sports/competitive-unicycling/oh-so-this-is-where-floyd-landis-has-been-190491.php
10:12:06 <lambdabot> Title: Oh, So This Is Where Floyd Landis Has Been - Deadspin
10:12:10 <chessguy> haha
10:12:25 <shapr> :-)
10:12:34 <matthew_-> > 'Z' == 'Ζ'
10:12:34 <lambdabot>  Improperly terminated character constant
10:12:39 <matthew_-> rotfl
10:12:53 <mauke> heh
10:13:06 <mauke> U+0396 (0xce 0x96): GREEK CAPITAL LETTER ZETA [Ζ]
10:13:18 <matthew_-> cheat! you weren't meant to reveal what it was!
10:13:27 <mauke> oh, sorry
10:13:32 <matthew_-> ;)
10:13:50 <mauke> > "Z" == "Ζ"
10:13:51 <lambdabot>  False
10:14:12 <mauke> > length "Z" == length "Ζ"
10:14:13 <lambdabot>  True
10:14:21 <malcolmw> fasta: did my fixes to cpphs solve your gensym-like problem?
10:14:53 <fasta> malcolmw: I stopped using cpphs and solved it using a large number of options.
10:15:15 <fasta> malcolmw: But my problem was fixed
10:15:20 <malcolmw> fasta: shame - it seems to work nicely for me
10:15:22 <matthew_-> mauke, my ghci (6.7.something) won't even parse "Ζ"
10:15:45 <mauke> matthew_-: that sucks
10:16:31 <fasta> malcolmw: When it "hits" the Debian repos, I might use it again.
10:17:07 <shapr> fasta: apt-get install cpphs ?
10:17:12 <malcolmw> fasta: ok, no problem.  It showed up lots of little bugs in cpphs's treatment of linenumbers anyway, all now fixed
10:17:26 <fasta> shapr: I don't assume that a version of cpphs that is days old is already there..
10:17:29 <malcolmw> shapr: he means the bugfixes of two days ago
10:17:31 <shapr> ik begrijp het niet?
10:17:33 <shapr> ahh, ok
10:17:58 <shapr> You could ask the maintainer if he has time to update the package.
10:18:17 * malcolmw is pleased to see we have 5 SoC proposals from students in the Google system already
10:18:59 <fasta> quicksilver: suppose that the graph contains the nodes 1 to 2^32. Your renaming scheme breaks down.
10:19:22 <quicksilver> fasta: well, I use Int64 then
10:19:30 <quicksilver> fasta: any computing algorithm needs to know its data types
10:19:36 <quicksilver> fasta: I'll just using Integer if you prefer
10:19:46 <shapr> Hm, my idea for an SoC project sounds too small...
10:19:46 <fasta> quicksilver: Ok, you are right, that could work.
10:19:51 <fasta> quicksilver: nice idea.
10:20:12 <quicksilver> that imposes a log n overhead --- as do all other algorithms, ever :) It's just people gloss over word-size issues
10:20:19 <shapr> I want to mix hpaste with the Haskell eval in lambdabot, but I want it to work in a browser.
10:20:47 <quicksilver> most algorithms are analysed assuming unbounded constant-time word operations and then unimplemented in languages with fixed word lengths...
10:20:48 <fasta> quicksilver: Integer has a log n size overhead?
10:20:58 <quicksilver> fasta: all unbounded data types do, obviously
10:21:06 <quicksilver> fasta: they require log n space to store...
10:21:21 <fasta> quicksilver: I was just checking what you meant.
10:21:36 <fasta> quicksilver: I don't think most algorithms assume that.
10:21:54 <abz> ?doc Network.HTTP
10:21:54 <lambdabot> Network.HTTP not available
10:22:26 <fasta> quicksilver: do you know whether that method you described has a name?
10:24:07 <quicksilver> fasta: no, not really. It's a bit like waht the machine does behind the scenes anyway (i.e. it gives each memory cell a unique address)
10:24:17 <quicksilver> fasta: I was just making that concrete
10:24:20 <malcolmw> shapr: so you want to be able to use ghci from a web browser rather than a command-line?
10:24:35 <fasta> quicksilver: my graph type also uses "pointers".
10:24:54 <fasta> quicksilver: it are just functional pointers.
10:25:14 <fasta> quicksilver: that array does need to automatically grow
10:25:22 <fasta> quicksilver: that has some constant overhead.
10:25:26 <shapr> malcolmw: More than that. I want an hpaste page to have a connection to a lambdabot-style safe ghci with the hpaste contents loaded, and I want all clients to see the same interpreter and history. I think it'd be an excellent tool for teaching
10:25:28 <fasta> quicksilver: otherwise it's quite nice.
10:25:56 <malcolmw> shapr: more like a Haskell IDE, but written in AJAX?
10:26:08 <shapr> malcolmw: Yeah, but I think a full IDE is too lofty a goal
10:26:25 <shapr> malcolmw: If you just think of a simple mix of lambdabot's eval command and hpaste, then it sounds sane :-)
10:26:58 <quicksilver> fasta: yes, as long as you grow the array sensibly you get constant-time amortized overhead
10:27:12 <quicksilver> fasta: if you grow it stupidly then you don't, of course :)
10:27:27 <fasta> quicksilver: yes,by any factor
10:27:35 <fasta> quicksilver: (> 1)
10:28:28 <fasta> "and now we grow the array by one to keep the CPU working" ;)
10:28:31 <shapr> malcolmw: I could write it myself, I have experience with Flash and Ajax. But I'd rather stay away from Flash entirely, and maybe even find some way to include voice chat.
10:29:04 * shapr thinks about how to include voice chat....
10:29:25 <chessguy> what in the world
10:29:30 <chessguy> applyAll::a->[a->a]->a
10:29:30 <chessguy> applyAll a [] = a
10:29:30 <chessguy> applyAll a (f:xs) = applyAll (f a) xs
10:29:44 <chessguy> some sort of inside-out fold?
10:29:44 <shapr> Is there a jabber / libjingle url convention?
10:29:56 <DynWind> url convention?
10:30:25 <shapr> DynWind: Like voip://servername/groupchatname ?
10:30:40 <shapr> Then you could just add an url handler configuration value to the browser.
10:30:54 <shapr> And when you visited the page, you could join the voice chat too.
10:30:58 <DynWind> not to my knowledge
10:31:08 <DynWind> are you planning on writing a firefox extension or something?
10:31:25 <shapr> Hey, that's a good idea!
10:32:22 <DynWind> :)
10:33:13 <DynWind> maybe I could do it as my summer of code project ...
10:33:53 <philipta> hey, I want a function that does f g (h x y) = h (g x) (g y) -- is there one of those in the Prelude?
10:34:20 <philipta> It's like (.) but for two arg functions
10:34:44 <shapr> I've seen (.) for two and more arg functions, but I forget what it looks like.
10:35:00 <shapr> You could check the mailing lists.
10:35:06 <quicksilver> philipta: do you mean h (f x) (g y)
10:35:07 <quicksilver> ?
10:35:31 <philipta> quicksilver: No... I mean there's a function f that does the application that I gave...
10:35:38 <quicksilver> ah
10:35:58 <quicksilver> @pl \g h -> h (g x) (g y)
10:35:58 <lambdabot> ap (flip . flip id . ($ x)) ($ y)
10:36:04 <quicksilver> not very pleasant :)
10:36:16 <quicksilver> @pl \h g -> h (g x) (g y)
10:36:16 <lambdabot> (`ap` ($ y)) . (. ($ x))
10:36:40 <philipta> *gulp*
10:36:47 <quicksilver> philipta: I don't believe there is, no
10:36:54 <philipta> OK. Thanks.
10:36:57 <quicksilver> I'm sure someone could build it with arrow combinators
10:37:05 <quicksilver> but it's late on a friday, so that someone isn't me
10:37:17 <jyasskin> @pl \f g x y -> f (g x) (g y)
10:37:17 <kc5tja> quicksilver: Wow, in J that'd be written simply as (hg).  :)
10:37:17 <lambdabot> join . ((flip . ((.) .)) .) . (.)
10:37:59 <jyasskin> @pl \f g x y -> f (g x y)
10:38:00 <lambdabot> (.) . (.)
10:38:03 <philipta> That looks like a cow's udder in ASCII art
10:38:07 <kc5tja> That would be g swap g swap f in Forth.  :)
10:38:13 <chessguy> @type unfoldr
10:38:15 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:38:16 <kc5tja> OK, I'll get back to work.  :)
10:38:18 <chessguy> @type unfoldTree
10:38:20 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
10:39:56 <quicksilver> kc5tja: which part does the dup? the . ?
10:40:20 * eddyp_ realizes that where is used for functions... is this correct
10:40:40 <kc5tja> quicksilver: dup and . are implied; any time you reference a lambda variable more than once, for each occurance less one, there is an equivalent to DUP.
10:40:47 <kc5tja> Composition is simply concatenation.
10:40:58 <chessguy> eddyp_, what do you mean? where can be used essentially like let
10:41:26 <eddyp_> chessguy: than I am still confused :-/
10:41:26 <quicksilver> kc5tja: but, in "(hg)." where did you mention anything twice?
10:41:33 <liquidengineer> Hello everyone
10:41:41 <Vq^> hello liquid
10:41:54 <quicksilver> eddyp_: where and let are essentially the same, they just occur in slightly different parts of syntax
10:42:02 <chessguy> eddyp_, our crystal ball is out of order today. you'll have to actually ask your question
10:42:02 <quicksilver> eddyp_: 'where' is only in 'definitions'
10:42:04 <kc5tja> quicksilver: Oh, you thought I wrote that to be Forth.  No; I said "in J".  In J, that is a hook, which is expanded to an equivalent form by the interpreter.
10:42:06 <quicksilver> eddyp_: 'let' is in expression
10:42:06 <dcnstrct> question:  has anyone here used Haskell to write programs that run on the PS3 and take advantage of parallelism ?   Or is there still work to be done before haskell will take advantage of the PS3's SPUs ?
10:42:41 <shapr> dcnstrct: The PS3 has two separate CPUs, the boss and the sidekicks. You could run GHC on the boss, but not directly on the sidekicks.
10:42:55 <quicksilver> s/CPUs/kinds of CPUs/
10:43:04 <eddyp_> quicksilver: thanks ...
10:43:08 <shapr> dcnstrct: You could probably hack up the data paralell arrays from UNSW to emit code to run on the sidekicks.
10:43:20 <shapr> yeah, what quicksilver said. two flavors of CPUs
10:43:37 <eddyp_> chessguy: I am so confused that I don't know what I want to ask
10:43:51 <shapr> dcnstrct: Did that help any?
10:44:46 <dcnstrct> shapr, arn't the sidekicks the important CPUs though ?
10:45:11 <quicksilver> > let f n = n+m where m = 1 in f 5
10:45:12 <lambdabot>  6
10:45:20 <quicksilver> eddyp_: see that? silly mixture of let and where
10:45:32 <quicksilver> eddyp_: you wouldn't normally write that, but just making a point
10:45:32 <dcnstrct> hrmm.. ok well all I wanted to hear was "it's possible to use the sidekicks and the boss"  thats enough for me to justify buying a PS3
10:45:51 <dcnstrct> if I have to hack up some parallel arrays from UNSW so be it
10:46:49 <eddyp_> quicksilver: oh, that looks even more confusing :-) (joking)
10:47:14 <dcnstrct> I'm terribly underinformed on how the PS3 actually works... but I'm working on that..  MIT rules! http://cag.csail.mit.edu/ps3/lectures.shtml
10:47:15 <lambdabot> Title: 6.189 Multicore Programming Primer: Lectures
10:48:58 <shapr> dcnstrct: The boss cpu is a real PPC chip, and the sidekicks are mostly limited by their incompatible instruction set, tiny pipeline, and inability to directly access main memory. But they do have a direct line to each of the sidekicks next to them, and you can DMA stuff into and out of main memory.
10:49:00 <eddyp_> quicksilver: so "where" can be used when you use a function that is not yet defined
10:49:36 <Vq^> what?
10:49:36 <quicksilver> eddyp_: that's certainly true, in that 'where' comes afterwards and 'let' comes before
10:49:43 <byteshack> anyone know if there is a "Why functional programming matters" with the samples in haskellL
10:49:44 <quicksilver> eddyp_: however, haskell never cares about definition order
10:49:45 <shapr> dcnstrct: Each sidekick has 512k of local memory.
10:49:46 <byteshack> ?
10:49:56 <quicksilver> eddyp_: so you can alway do stuff backwards
10:50:03 <shapr> dcnstrct: It's an interesting critter, if you get Linux running on it, I want an account =)
10:50:09 <quicksilver> > let m = n; n = 5 in m
10:50:10 <lambdabot>  5
10:50:20 <quicksilver> > let n = 5; m=n in m
10:50:21 <lambdabot>  5
10:50:30 <quicksilver> eddyp_: see? order of definition doesn't matter
10:50:42 <quicksilver> eddyp_: they can circularly depend, too
10:50:52 <quicksilver> > let n = 2:m; m = 1:n in m
10:50:53 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
10:50:56 <eddyp_> quicksilver: well, I kind of figurd that out myself, but your examples are more clear
10:51:17 <eddyp_> quicksilver: thanks, again
10:51:23 <shapr> > let ones = 1:ones in ones
10:51:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:51:26 <quicksilver> eddyp_: anytime :)
10:51:37 <chessguy> hmm, i think the most recent chess post on haskell-cafe has me incensed and inspired in just the right combination
10:51:38 <dcnstrct> shapr,  you can have a shell when I get it running.. I'm writing down your name
10:51:49 <kc5tja> > foldr1 (+) [1..]
10:51:51 <lambdabot>  Exception: stack overflow
10:51:55 <kc5tja> Booyah!
10:52:13 <kc5tja> > foldl1 (+) [1..]
10:52:17 <lambdabot> Terminated
10:52:25 <shapr> dcnstrct: yay!
10:53:23 <dcnstrct>  shapr, I wish I could run a desktop linux on it, but it looks like it can't even do 800x600 resolution =/
10:53:34 <roconnor> has anyone got runSetup install --user to work?
10:54:13 <dcnstrct> if I was going to use it as a server I'd rather put NetBSD on it, I'll have to check into how much work it would be to make that happen
10:54:30 <Igloo> roconnor: Works for me
10:54:32 <shapr> I know it'll run Linux, don't know about the rest.
10:54:33 * eddyp_ wonders why kc5tja's second evaluation got a different result
10:54:41 <Igloo> roconnor: Assuming you means Setup.hs's install --user
10:54:44 <eddyp_> ah, forget it
10:54:49 <kc5tja> dcnstrct: PS3?  That's designed for TV sets; TVs can only display 368 pixels by 400 or so (NTSC resolution) assuming no color fringing; 736 x 400 if you can deal with the fringe and a bit of chroma-crawl.
10:54:51 <eddyp_> left and right
10:54:58 <kc5tja> You're lucky you can see ANYTHING on TV sets.
10:55:36 <roconnor> $ runhaskell Setup.lhs install --user
10:55:36 <roconnor> Installing: /usr/local/lib/HTTP-2006.7.7/ghc-6.6 & /usr/local/bin HTTP-2006.7.7...
10:55:36 <roconnor> *** Exception: /usr/local/lib/HTTP-2006.7.7: createDirectory: permission denied (Permission denied)
10:59:51 <roconnor> Do I need to set some enivronment varaible?
11:05:20 <shapr> roconnor: Yeah, you need to give it your user install directory.
11:05:32 <shapr> --user=/home/roconnor/haskell/ ?
11:06:01 <Igloo> roconnor: configure with --prefix=/somewhere/you/can/write
11:07:19 <roconnor> shapr: the help doesn't say that the syntax works like that
11:07:37 <roconnor>            --user                          allow dependencies to be satisfied from the user package database. also implies install --user
11:08:00 <roconnor> well, I guess it is only the install we care about
11:08:17 <roconnor>           --user                upon registration, register this package in the user's local package database
11:18:01 <shapr> roconnor: Yeah, what Igloo said
11:20:01 <roconnor> why do I need to do that
11:20:07 <roconnor> can I use /tmp?
11:20:37 <roconnor> or do I need somwhere permenent?
11:21:15 <eddyp_> this is funny...
11:21:29 <eddyp_> ? foldl1 (+) (take 100 [1..])
11:21:56 <eddyp_> > foldl1 (+) (take 100 [1..])
11:21:57 <lambdabot>  5050
11:22:06 <Igloo> roconnor: You have to tell it where you want it to put the compiled files
11:22:21 <eddyp_> now I know where from did yahoo took the port number for messanger
11:22:27 <merus> > take 10 (map (uncurry (*)) zip [1..] [1..]
11:22:28 <lambdabot>  Parse error
11:22:36 <merus> Oh, right.  Duh.
11:22:44 <roconnor> Igloo: does registration with ghc-pkg copy the libs? or do I need to keep the compiled files around?
11:23:00 <Igloo> You need to keep them
11:23:23 <chessguy> > take 10 $ map (uncurry (*)) $ zip [1..] [1..]
11:23:24 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
11:23:38 <merus> Yeah.
11:24:23 <sfogarty> Hi. I've just been given a good chunk of haskell code which includes a "foreign import unsafe". This doesn't make the parser happy unless it change it "foreign import ccall unsafe". But as I have no clue what ccall means, I am not sure this is a valid fix. Anyone that can perhaps reassure me?
11:24:27 <xerox> > take 10 . join (zipWith (*)) $ [1..]
11:24:28 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
11:25:05 <chessguy> xerox, show-off :)
11:25:26 <roconnor> Igloo: hmm, there is no configure --local comand
11:25:27 <xerox> sfogarty: the user guide explains the FFI very well
11:25:44 <ClaudiusMaximus> @type join
11:25:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:26:52 <sfogarty> xerox: Heh. I'm afraid I didn't fiind it quite so clear, as it doesn't actually mention was ccall does either, although it does appear there. (assume you mean the http://www.haskell.org/ghc/docs/latest/users_guide.pdf)
11:27:46 <xerox> I mean http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi.html
11:27:47 <lambdabot> Title: Chapter 8. Foreign function interface (FFI)
11:28:18 <sfogarty> Tis the same document
11:29:56 <roconnor> Igloo: thanks for your help, I got it installed now.
11:29:56 <Igloo> If it's not a Windows thing then ccall is what you want
11:29:58 <sfogarty> I'll keep poking around, thanks
11:30:00 <danb`> @type join . zipWith
11:30:02 <lambdabot> forall b c. (b -> b -> c) -> [b] -> [c]
11:30:07 <roconnor> @karma+ Igloo
11:30:08 <lambdabot> Igloo's karma raised to 12.
11:30:13 <Igloo> It's short for "use the C calling convention" I assume
11:30:28 <xerox> Yeah.
11:30:31 <roconnor> Igloo: don't you think there should be a configure --local flag?
11:31:04 <danb`> @type zipWith
11:31:06 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:32:15 <Igloo> roconnor: Perhaps, you might want to suggest it (or send a patch) to cabal-devel
11:34:32 <roconnor> Igloo: would it be fair to make --local the same as --prefix=(location of Setup.hs) ?
11:34:45 * roconnor isn't so familiar with build issues
11:35:21 <Igloo> roconnor: No, it should go in ~/.cabal/<something dependent on the compiler and package> on *NIX, I'd say
11:35:24 <Igloo> No idea on Windows
11:35:36 <Igloo> Or maybe .haskell, I don't know
11:37:04 <roconnor> Igloo: I thought configure --local generally meant build in-place, but I sort of forget.
11:43:16 <Igloo> roconnor: If you want it to be in-place then for consistency the flag should be --inplace
11:44:48 <roconnor> hmm
11:44:51 <roconnor> ok
11:46:29 <DynWind> there is no XMPP (jabber) library for Haskell, yes?
11:47:37 <DynWind> ah, looks like there is
11:47:51 <ndm> how do i pass arguments to a GHC executable, i.e. RTS arguments
11:47:56 <ndm> i thought -RTS did it...
11:48:28 <ndm> ah, +RTS...
12:04:54 <shapr> DynWind: ADEpt was working on one.. I think you can find it on google.
12:05:14 <jfoutz> !where hackage
12:05:19 <jfoutz> @where hackage
12:05:19 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
12:05:27 <DynWind> shapr: yes, found it
12:11:14 <malsyned> so at this point, is it safe to say that ParsecPerm is no longer "experimental" since it's been in Parsec since 2001?
12:12:18 <CosmicRay> malsyned: I'm not familiar with that particular code, but probably.  I have found many haskellers to be exceptionally conservative about marking things release-worthy
12:17:10 <ClaudiusMaximus> > let insertAt x n xs = ys ++ [x] ++ zs where (ys, zs) = splitAt n xs in (\l -> nub (foldr (\a b -> liftM2 (insertAt a) [0..(length b)] b) [[]] l)) "abcd" -- this finds permutations of arbitrary length lists, but is woefully inefficient, how could it be optimized?
12:17:11 <lambdabot>  ["abcd","abdc","acbd","adbc","acdb","adcb","bacd","badc","cabd","dabc","cadb...
12:31:41 <dolio> ?paste
12:31:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:34:09 <hpaste>  dolio pasted "A somewhat better permutation." at http://hpaste.org/988
12:38:06 <hpaste>  dolio annotated "A somewhat better permutation." with "monadic permutations" at http://hpaste.org/988#a1
12:39:42 <malsyned> OK, this is a weird question, but I'm trying to use Parsec to tokenize a file, then use it again to parse it.  I'd like to know if there's a function, or an easy way to build a function, with this type signature: GenParser tokI st1 [tokO] -> GenParser tokO st2 a -> GenParser tokI st1 a
12:40:01 <malsyned> the purpose of which is to combine the lexer and the parser.
12:40:36 <malsyned> anybody have any ideas?
12:41:01 <ClaudiusMaximus> dolio: cool :)
12:41:16 <malcolmw> let lexed = runParser x input; parsed = runParser y lexed; in parsed
12:41:28 <malcolmw> or something like that
12:41:36 <dolio> :) That second one makes reference to MonadRandom, which you should be able to find on the wiki.
12:43:54 <dolio> I haven't looked at yours too much, but it seems to have a space leak (in ghci) somewhere, since I ran it on "1234567" and it started making my machine swap. :)
12:45:47 <ClaudiusMaximus> dolio: i was trying with lambdabot, and running it on "abcde" ran out of time...
12:46:22 * ClaudiusMaximus has a knack for writing inefficient code...
12:46:32 <ClaudiusMaximus> @quote 28
12:46:32 <lambdabot> ClaudiusMaximus says: compiling with -O2 reduced the time taken by my program's execution from 28mins to 17secs
12:46:58 <ClaudiusMaximus> ...and hoping compiler magic fixes it
12:47:00 <dolio> :) Well, practice makes perfect.
12:47:12 * SamB wants a higher-order HDL
12:47:23 <dolio> If I had to guess, I'd say the nub in there is a bad idea.
12:47:37 <dolio> Just at a cursory glance.
12:47:51 <shapr> sjanssen: Is there some way to move a window from one workspace to another?
12:47:52 <ClaudiusMaximus> yes, it shows i'm generating far too many candidates, instead of thinking of a decent algorithm
12:48:06 <SamB> ... one that doesn't insist on being used to generate hardware...
12:48:24 <sjanssen> shapr: mod+shift+wsnumber
12:48:27 <shapr> ahh
12:48:49 <shapr> sjanssen: xmonad works fine with x11vnc also :-)
12:48:56 <sjanssen> shapr: the only documentation is a quite terse list comprehension :)
12:49:16 <SamB> I suppose there is nothing for it but to major in EE...
12:49:23 <sjanssen> have you had a chance to try gnome-theme-manager again?
12:53:09 <shapr> sjanssen: Nah, not yet.
12:54:47 * glguy joins #ruby to "know thy enemy"
12:54:55 <mbishop> heh
12:55:13 <Gu1> keep your friends close, and your enemies closer
12:55:33 <malsyned> can someone with better type chops than me tell me what is wrong with "instance Monad (Either ParseError) where...
12:55:42 <jfoutz> it's like smalltalk, but with the added lexical beauty of perl.
12:55:55 <kc5tja> malsyned: Either is a type constructor with TWO sub-types, not one.
12:56:01 <kc5tja> Either ParseError or ... ?
12:56:15 <dolio> malsyned: What's the error message.
12:56:38 <roconnor> malsyned: ParseError is not an instance of Error
12:56:47 * roconnor had this problem yesterday
12:56:54 <malsyned> Illegal instance declaration.  "(The instance type must be of the form (T a b c) ...)"
12:57:05 <roconnor> Instance (Error e) => Monad (Either e)
12:57:45 <malsyned> roconnor: I don't get it.  Why does ParseError need to be an instance of Error in order for me to define my own monad instance for it?
12:57:55 <roconnor> malsyned: you cannot make (Either ParseError) into a instance (in haskell 98) because all parameters must be variables
12:58:19 <dolio> Yeah. -fglasgow-exts might allow your instance declaration.
12:58:20 <kc5tja> off to lunch -- back in about an hour.
12:58:27 <malsyned> ohhhh
12:58:29 <roconnor> malsyned: It's just that (Either e) is already an instance of Monad when e is an instance of Error
12:58:45 <roconnor> ... which now that I think about it is very odd.
12:58:49 <malsyned> so my time would be better spent making ParseError an instance of Error?
12:59:02 <dolio> Strictly speaking, e doesn't have to be an instance of Error for Either e to be a monad.
12:59:05 <roconnor> malsyned: Well, I tried that yesterday, and didn't get to far
12:59:22 <roconnor> too far
12:59:24 <dolio> At least, I think.
12:59:29 <malsyned> that article about the myriad different ways to work with errors in Haskell is resonating with me right now.
13:00:21 <roconnor> The problem was that ParseError requires a source position
13:00:28 <roconnor> @src Error
13:00:29 <lambdabot> class Error a where
13:00:29 <lambdabot>     noMsg  :: a
13:00:29 <lambdabot>     strMsg :: String -> a
13:00:50 <roconnor> this makes it hard to be an instnace of Error
13:03:10 <chessguy> hi haskellers
13:04:39 <Vq^> hello chessguy
13:07:03 <glguy> hmm.. the enemy is terribly quiet, I bet someone warned them!
13:07:53 <opqdonut> hi chessguy
13:08:05 <jfoutz> glguy, try saying: rounded corners are cool huh?
13:08:05 <hpaste> hello
13:08:45 <jfoutz> maybe that's more of a rails thing.
13:08:59 <dolio> Start a debate about whether Ruby should have aspect-oriented programming.
13:09:10 <dolio> That was a big issue on the mailing list when I was reading it. :)
13:09:19 * chessguy is beginning to think he shouldn't have added programming.reddit to his RSS feed
13:09:32 <glguy> too much of a distraction?
13:09:57 <chessguy> too much, period
13:10:05 <allbery_b> I found reddit annoying and eventually scrapped it; anything interesting shows up here anyway :)
13:10:16 <allbery_b> ...it would perhaps be less annoying if they had useful previews
13:11:19 <chessguy> perhaps
13:11:30 <glguy> allbery_b: but I want to hear the unwashed massed fawn over their terrible languages!
13:12:25 <jfoutz> the erlang stuff is kinda interesting. i think the seaside style websites is pretty neat too.
13:12:51 <jfoutz> but programming.reddit is a lot of noise for the worthwhile signal.
13:13:14 <glguy> I don't have an opinion on Seaside, the only things I've seen about it on reddit were information free videos
13:13:18 <glguy> that just told me it was awesome
13:15:50 <dolio> Well, if it's so awesome, how does it compare to yaws? :)
13:15:58 <shapr> hiya SyntaxNinja!
13:16:08 * glguy boings for shapr
13:16:43 * shapr hOps around glguy 
13:16:52 * thedward three
13:16:57 <thedward> erg
13:17:04 <shapr> dyne a centimeter?
13:17:12 <thedward> I blame the cat.
13:17:38 <allbery_b> so slug schrodinger?
13:18:06 <SyntaxNinja> hi shapr
13:18:16 <balodja> \f -> filter f . = (.) (filter f) = ((.) . filter) f -- is that right?
13:18:48 <jfoutz> glguy, the key feature is abstracting away webpages. you write a function like do{ a <- askNum; b <- askNum; return $ showNum (a + b)} and all of the junk about displaying webpages is abstracted away. askNum shows the user a page that asks for a number. It's more like writing a application that randomly connected webpages.
13:18:58 <opqdonut> balodja: seems so
13:19:06 <opqdonut> ?pl \ f -> filter f .
13:19:06 <lambdabot> (line 1, column 18):
13:19:06 <lambdabot> unexpected end of input
13:19:06 <lambdabot> expecting white space or simple term
13:19:08 <dolio> ?pl \f -> filter f .
13:19:08 <lambdabot> (line 1, column 17):
13:19:08 <lambdabot> unexpected end of input
13:19:08 <lambdabot> expecting white space or simple term
13:19:11 <opqdonut> ?pl \ f -> (filter f .)
13:19:11 <lambdabot> (.) . filter
13:19:12 <Cale> balodja: except that the section at the beginning isn't in parens
13:19:15 <opqdonut> yeah it is
13:19:47 <balodja> Cale: could you point out precisly, please :)
13:20:20 <opqdonut> balodja: \f -> (filter f .)
13:20:33 <balodja> oh, thanks
13:20:35 <opqdonut> because of the partially applied infic
13:20:37 <opqdonut> *infix
13:20:39 <Cale> (* x) and (x *) where x is an expression, and * is some infix operator are caleld sections
13:20:42 <Cale> called*
13:20:53 <shapr> SyntaxNinja: You gotta try vnc & voip pair programming with us sometime, it's great fun!
13:21:07 <Cale> The parens are part of the syntax and aren't optional
13:21:49 <balodja> every partially applied infix must be enclosed in parenthesis? hm, understood :)
13:22:21 <SyntaxNinja> shapr: sounds awesome.
13:24:10 <encryptio> shapr: i've done skype and screen pair programming
13:24:48 <glguy> ?seen bos31337
13:24:48 <lambdabot> bos31337 is in #haskell. I don't know when bos31337 last spoke.
13:24:57 <glguy> bos31337: you about?
13:25:09 <chessguy> ?uptime
13:25:09 <lambdabot> uptime: 2d 16h 55m 39s, longest uptime: 5d 3h 40m 45s
13:25:48 <encryptio> although whenever i do that i get asked a lot of questions about how i'm changing things so fast in vim
13:26:22 <sjanssen> encryptio: stop pairing with noobs, they'll only bring you down! :P
13:27:13 <Gu1> pairing is basically collaboration?
13:27:18 <shapr> er, yeah..
13:27:27 <shapr> Two people sitting at the same computer working on the same source code.
13:27:30 <Gu1> sorry i'm a newbie
13:27:37 <shapr> Pair programming has a variety of advantages.
13:27:42 <shapr> But some people can't stand it.
13:27:46 <chessguy> isn't that big in XP?
13:27:55 <opqdonut> well in one vein of xp at least
13:28:01 <opqdonut> pair programming is kinda nice
13:28:10 <shapr> Yeah, but pair programming didn't start with XP.
13:28:13 <opqdonut> esp. when there's an exprerience gap
13:28:26 <opqdonut> and when the project is too small for an effective division of work
13:28:34 <shapr> Pair programming started with the master/apprentice system in the middle ages.
13:28:52 <glguy> back when they programmed with an anvil?
13:29:07 <shapr> I've learned a bunch of nifty new things for Haskell, shell scripting, emacs, and more from Lemmih over the last coupla weeks.
13:29:15 <shapr> I think he learned a few things from me too.
13:29:50 <shapr> glguy: Yeah, book learnin doesn't always teach thought processes, ya know?
13:30:11 <glguy> sure
13:30:31 * Heffalump waves
13:31:13 <shapr> hiya Heffalump!
13:31:41 <shapr> Speaking of master/apprentice system, Oxford does a good job of communicating knowledge efficiently through very small classes.
13:31:44 <psi> argh! how can the profiling report show calls to a function I don't even use anymore? it's even commented out!
13:32:54 <tuukkah> psi, you're not running the same source you're editing ?-)
13:33:19 <malsyned> rawr!  the type inference engine is a harsh mistress
13:33:47 <psi> tuukkah: ah, man. I was compiling with --make before, but I stopped. I didn't notice that the binary was now called a.out :)
13:33:57 <integral> shapr: Cambridge favours the trio over the pair though
13:39:58 <tuukkah> psi, oops :-) i always make mistakes like that so i need to use a makefile with a target run-program so i can be sure the binary is up to date and reflects my latest edits
13:40:06 <malsyned> ?paste
13:40:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:41:53 <hpaste>  malsyned pasted "How can I fix this function so that it doesn't give a typing error?" at http://hpaste.org/989
13:42:20 <malsyned> (hint: the answer is not "replace 'a' with [tok1] in the type declaration)
13:42:56 <encryptio> sjanssen: (re: noob pairing) yeah, but i'm (explicitly) teaching sometimes. i have a perl apprentice.
13:43:37 <Heffalump> shapr: it does?
13:45:05 <syntaxfree> jeez. You know we've either made it or are screwed when they're discussing Haskell on 4chan/
13:45:13 <encryptio> lol
13:45:40 <syntaxfree> I mean, really.
13:45:56 <syntaxfree> next thing Colbert will be making jokes about comonads.
13:46:11 <LoganCapaldo> Colbert made fortran jokes!
13:46:29 <LoganCapaldo> I don't think comand jokes are that far off
13:46:34 <LoganCapaldo> *comonad
13:46:45 * encryptio adds comonads to his "list of things to do"
13:47:03 <syntaxfree> comonads rock, apparently. I just can't find any.
13:47:25 <syntaxfree> I still get dizzy when I look at sigfpe's CA comonad.
13:48:00 <LoganCapaldo> Is Identity its own Comonad?
13:48:17 <doserj> data Stream a = a :*: Stream a
13:53:41 <malsyned> is there a way, short of a case statement, to test whether an object is an instance of a particular constructor?  something like "if x | Left _ -> ... else ..." ?
13:54:28 <LoganCapaldo> You could write a whole buncha functions in terms of case statements
13:54:39 <LoganCapaldo> but no, I don't think so
13:54:51 <shapr> Heffalump: Well, seems that way to me.
13:54:54 <LoganCapaldo> (as f (Left x) = is just sugar for case)
13:55:12 <shapr> Heffalump: You don't have 400 students in a class with little or no chance to ask the prof questions.
13:55:21 <malsyned> LoganCapaldo: yeah, that's what I figured.
13:55:40 <malsyned> I'm surprised that's not part of the language, though.  seems like a handy bit of sugar.
13:55:58 <shapr> syntaxfree: comonads are in excel.
13:56:07 <bos31337> glguy: you called?
13:56:16 <bos31337> ?seen glguy
13:56:16 <lambdabot> glguy is in #happs and #haskell. I last heard glguy speak 26m 5s ago.
13:56:22 <sjanssen> malsyned: yes, I have the feeling that Haskell could do more with patterns
13:56:34 <sjanssen> what if patterns were somehow first class citizens?
13:57:16 <malsyned> sjanssen: like, a pattern is also a function which returns a boolean?
13:57:56 <sjanssen> malsyned: something like that
13:58:07 <Cale> I like the 'sections of @' notation for that
13:58:08 <Heffalump> views..
13:58:35 <sjanssen> Heffalump: but you can only have views where patterns appear
13:58:53 <sjanssen> Cale: can you elaborate?
13:58:57 <Cale> (Just x @) (Just 5) = True
13:59:04 <Cale> (Just x @) Nothing = False
13:59:26 <bos31337> huh?
13:59:54 <bos31337> Cale: what's that supposed to mean?
13:59:55 <LoganCapaldo> Thats a fun syntax
13:59:59 <sjanssen> it'd be interesting to compose patterns too
14:00:03 <ddarius> @google First Class Pattern Haskell
14:00:05 <lambdabot> http://www.cs.yale.edu/homes/tullsen/patterns.ps
14:00:13 <Cale> In general (<pat> @) would be an expression for a function returning True when <pat> matches.
14:00:16 <Heffalump> that's not very interesting though, it's patterns that bind things that are hard
14:00:16 <glguy> bos31337: hi
14:00:23 <ddarius> sjanssen: But essentially, using the maybe monad and guards you can do that today fairly cleanly.
14:00:24 <bos31337> glguy: what can i do for you?
14:00:36 <Cale> Yeah, maybe we need a typeclass.
14:00:42 <glguy> bos31337: we were talking about moving hpaste to a different server, and I knew that that owuld require having you update the domain name
14:00:44 <malsyned> ooh, I like that.
14:00:45 <sjanssen> ddarius: you can do it somewhat cleanly, it still sucks a little bit
14:00:50 <malsyned> (the @ syntax)
14:00:54 <Cale> (Just x @) (Just 5) = [("x",5)]
14:00:59 <Cale> that would be interesting :)
14:01:04 <LoganCapaldo> eeek
14:01:11 <bos31337> glguy: it takes about 30 seconds to update dns. just email me with the new address whenever you need it done.
14:01:15 <Cale> But also limited
14:01:19 <glguy> bos31337: ok, cool
14:01:29 <Cale> Because the parts would all have to match at the same type.
14:01:40 <sjanssen> null (\x -> do (Just _) <- x; return ()) -- is a mouthful compared to (Just _ @)
14:01:56 <ddarius> @google Barry Jay Pattern Calculus
14:01:57 <lambdabot> http://www-staff.it.uts.edu.au/~cbj/patterns/wrc_slides.pdf
14:02:17 <bos31337> dammit, why does everyone else get to write a calculus?
14:02:21 <glguy> sjanssen: Where di you get the code for that finger tree?
14:02:28 <sjanssen> @where fingertree
14:02:28 <lambdabot> http://www.soi.city.ac.uk/~ross/software/html/Data-FingerTree.html
14:02:29 <bos31337> join calculus, pi calculus, lambda calculus.
14:02:39 <glguy> sjanssen: does that have the source code?
14:02:54 <glguy> sjanssen: nvm, found it
14:03:10 <ddarius> bos31337: Pick an unused Greek letter and get at it!
14:03:22 * bos31337 dances the lambada calculus
14:03:24 <LoganCapaldo> (Just x @) (Just 5) = 5; (Left (x:xs) @) (Left [1,2,3]) = ([1,2,3], [1], [2,3]) ???
14:03:35 <LoganCapaldo> maybe
14:03:48 <LoganCapaldo> would sure have a complicated type signature
14:04:22 <ddarius> bos31337: Also Cardelli has the sigma calculus
14:04:31 <jfoutz> sjanssen: cleaner?  null (x >>= Just >> return ())
14:04:43 <LoganCapaldo> they're gonna run out of greek letters
14:05:24 <ddarius> LoganCapaldo: The Greeks are still around; they can make more.
14:05:52 <roconnor> make more Greeks?
14:06:04 <ddarius> roconnor: They already do that.
14:07:00 <LoganCapaldo> Is there a rho calculus?
14:07:11 <LoganCapaldo> Cause if not, I'm so calling it!
14:07:14 <ddarius> I think their might.
14:07:24 <allbery_b> resurrect the ancient Greek annotations?  add in Armenian letters?
14:07:26 <ddarius> @google rho calculus
14:07:33 <lambdabot> http://rho.loria.fr/
14:07:33 <lambdabot> Title: The Rho-Calculus Home Page
14:07:38 <ddarius> Taken
14:07:48 <kc5tja> <humor type="sugar induced">Rho, rho, rho your boat, gently down the IO Stream...</humor>
14:07:50 <opqdonut> :D
14:10:02 <sjanssen> jfoutz: that doesn't scale to every pattern.  What if the pattern I want to match is (_:(Just (Left _)):_)?
14:10:04 <ddarius> Hebrew characters are used a bit in math.  Maybe we need a yod calculus.
14:10:05 <roconnor> Is there a data type Stream = a :> Stream a  ?
14:10:16 <ddarius> roconnor: No.
14:10:20 <roconnor> data Stream a = a :> Stream a  ?
14:10:24 <roconnor> :(
14:10:37 <kc5tja> What is the :> operator?
14:10:37 <ddarius> You can easily declare it.
14:10:44 <kc5tja> @hoogle :>
14:10:44 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':>'
14:10:47 <ddarius> kc5tja: An infix constructor.
14:10:49 <roconnor> kc5tja: I just declared it as a constructor
14:11:14 <roconnor> constructors can be infix in GHC if they begin with :
14:11:19 <kc5tja> How would it typically be used?
14:11:26 <encryptio> > fail "foo" :: Either String String
14:11:27 <lambdabot>  Left "foo"
14:11:32 <encryptio> > return "foo" :: Either String String
14:11:34 <lambdabot>  Right "foo"
14:11:40 <roconnor> kc5tja: ones = 1:>ones
14:12:07 <roconnor> the nice thing about streams is that head and tail are total
14:12:13 <ailndx> !paste
14:12:13 <hpaste> Haskell paste bin: http://hpaste.org/
14:12:48 <LoganCapaldo> but length takes forever to evaluate :)
14:12:55 <kc5tja> Hmm...  I guess I just don't see how it'd typically be used.  Except as an academic excuse to reconstruct the list type.  :)
14:13:20 <chessguy> ermm, i'm sure this should be obvious, but it's not coming to me. i want to define an interface for a data structure, so that, as long as the data structure has instances of certain operations, the implementation of the data structure is irrelevant to the user of it...is this a type class?
14:13:40 <LoganCapaldo> no, this is an academic exercise to reconstruct the list type, data List a = a <: List a | Nil
14:13:41 <kc5tja> chessguy: Type classes?
14:13:58 <roconnor> kc5tja: Streams have no null type
14:14:01 <ailndx> what is this in Eval.hs... "import Plugin" ?
14:14:03 <roconnor> er no null element
14:14:06 <pafcu> Hi. I want to create a type for three-value logic (i.e possible values are True,False and Unknown). Since it's a special case of a Bool I also want to be able to pass a Bool to any function expecting a three-value "trit". How would I do this?
14:14:09 <chessguy> kc5tja: complete sentences?
14:14:26 <kc5tja> chessguy: Maybe can.  ;)
14:14:31 <sjanssen> chessguy: it may be a type class
14:14:37 <LoganCapaldo> pafcu: type class...
14:14:46 <kc5tja> chessguy: You were looking for expressing interfaces to an abstract data type.  Type classes come to mind.
14:15:05 <pafcu> LoganCapaldo: I'm a beginner. Could you be more specific?
14:15:35 <LoganCapaldo> you create a type class with a function to convert from instances of that class to trits
14:15:37 <chessguy> but the data structure itself isn't really a bunch of methods, they're only an interface to it
14:15:47 <LoganCapaldo> you then make trits and bools instances of that class
14:16:14 <sjanssen> chessguy: what do you mean by "an interface"?
14:16:33 <chessguy> sjanssen: the operations that will change and query the data structure
14:16:45 <sjanssen> chessguy: typeclass, I think
14:16:59 <roconnor> pafcu: I would recommend using (Maybe Bool)
14:17:14 <roconnor> Just :: Bool -> Maybe Bool
14:17:22 <kc5tja> chessguy: The data structure is an opaque type though, right?  And can come from multiple sources?  (E.g., different kinds of objects, which all have a similar interface)
14:17:25 <pafcu> LoganCapaldo: But then I'd have to call that function every time I pass a Bool to a function expecting a trit?
14:17:36 <LoganCapaldo> no
14:17:41 <roconnor> that is your injection :(but it won't automagically be infered for you)
14:17:56 <LoganCapaldo> you call that function in every function expecting an instance of the type class
14:17:56 <sjanssen> chessguy: typeclasses are used for groups data types that support similar operations
14:18:00 <chessguy> so like Class DataStructure where oper1 :: DataStructure -> Int -> Bool, oper2 :: Int -> Int -> DataStructure -> DataStructure, etc.
14:18:27 <sjanssen> class Structure a where oper1 :: a -> Int -> Bool, etc.
14:18:46 <roconnor> LoganCapaldo: The type class approach doesn't make Bools and Trits interchangable.
14:18:56 <chessguy> but then a isn't constrained
14:19:04 <sjanssen> chessguy: it is
14:19:10 <chessguy> ohhh, ok
14:19:13 <LoganCapaldo> roconnor: I'm pretty sure you cant make them interchangeable
14:19:14 <chessguy> sorry, now i've got it
14:19:18 <sjanssen> by the "class DataStructure a" part
14:19:35 <chessguy> a IS a DataStructure if you can perform these operations with it
14:19:54 <chessguy> ok, now i think i've got my head on straight.
14:20:14 <sjanssen> chessguy: yes, you'll write an instance that both says it is a DataStructure, and provide the implementations too
14:20:30 <sjanssen> instance DataStructure ConcreteImplementation where oper1 x y = ...
14:20:31 <chessguy> yes
14:21:03 <pafcu> No way to completely automatically allow a Bool to be passed to a function expecting a Trit?
14:21:06 <chessguy> is there much overhead involved in all that?
14:21:38 <hpaste>  LoganCapaldo pasted "pafcu: Like this" at http://hpaste.org/990
14:21:42 <pafcu> I guess just using a typeclass and a conversion function would do, but it just seems a bit too complicated
14:21:44 <chessguy> i mean as opposed to just writing the implementations
14:22:19 <sjanssen> chessguy: it depends.  ghc -O does a pretty good job of eliminating the overhead at compile time (and you can do some things to help it along)
14:22:31 <pafcu> LoganCapaldo: Thanks. I'll try that
14:23:45 <ddarius> pafcu: There are no implicit conversions in Haskell.
14:24:29 <LoganCapaldo> nor is there a way to make a Trit a subtype of Bool (afaik)
14:24:48 <doserj> ddarius: there are...
14:24:52 <roconnor> pafcu: thats why you see us writing fromInteger and fromRational and fromIntegral everywhere
14:25:00 <Cale> data Bool = True | False | FileNotFound
14:25:33 <doserj> roconner: except for literals, where they are implicit
14:25:59 <ddarius> It's not an implicit conversion, it's just the definition of literals.
14:26:12 <roconnor> doserj: does (0::Rational) really stand for (fromInteger 0::Rational)?
14:26:27 <roconnor> I suppose it does
14:26:31 <sjanssen> roconnor: yes, it does
14:26:48 <roconnor> neat
14:26:52 <sjanssen> the zero in the second example is probably something like COMPILER_PRIM_CONSTANT_0, or something
14:27:05 <sjanssen> ie, it's not representable in regular Haskell
14:27:09 <therp> roconnor: yes, I have seen the code of GHC recently that provokes this behaviour
14:30:00 <ailndx> Cale: but how would cabal help in this case?
14:30:29 <Cale> Well, it serves a similar purpose to make.
14:30:33 <Cale> (in this case)
14:30:49 <ailndx> but i would still have to download all the files 1 by one
14:30:55 <Cale> Actually, provided you have hs-plugins installed, runplugs shouldn't be too hard to compile.
14:31:09 <ailndx> well i dont have hs-plugins installed
14:31:18 <Cale> ah, okay, so you need to do that.
14:31:19 <sjanssen> ailndx: you'll need it to build runplugs
14:31:58 <sjanssen> ailndx: which ghc version do you have?
14:32:36 <ailndx> 6.6 now, i tried installing it and use with 6.4.2 but it was a pain to use
14:33:22 <sjanssen> there are some issues with hs-plugins and 6.6 ... I've heard that the latest darcs version works
14:33:39 <Cale> yeah, I think it does
14:33:53 <sjanssen> @version
14:33:53 <lambdabot> lambdabot 4p517, GHC 6.6 (OpenBSD i386)
14:33:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:34:02 <sjanssen> > "it must work, somehow!"
14:34:04 <lambdabot>  "it must work, somehow!"
14:34:05 <LoganCapaldo> hey, pafcu why not use Maybe Bool instead?
14:34:10 <Cale> darcs get --set-scripts-executable http://www.cse.unsw.edu.au/~dons/code/hs-plugins
14:34:10 <lambdabot> Title: Index of /~dons/code/hs-plugins
14:34:17 <ailndx> but the problem wasnt ghc for me it was hs-plugins not liking windows
14:34:26 <Cale> oh
14:34:45 <Cale> er, hmm
14:35:00 <hyrax42> is there a list of soc projects up yet?
14:35:08 <hyrax42> I'm getting some ticket doesn't exist error
14:35:13 <Cale> I wonder if dons is up yet.
14:35:24 <sjanssen> @localtime dons
14:35:26 <lambdabot> Local time for dons is Sat Mar 17 08:34:18 2007
14:35:42 <ski> @yow
14:35:43 <lambdabot> Jesuit priests are DATING CAREER DIPLOMATS!!
14:35:46 <Cale> ailndx: dons is the guy who you should talk to about this -- he's the maintainer of both hs-plugins and lambdabot
14:35:48 <sjanssen> I think he's usually around in another hour or two
14:36:00 <kaol> @quote yow
14:36:00 <lambdabot> SamB says: <SamB> @. bf . id . pl . v . wn yow  <lambdabot> Done.
14:36:03 <ailndx> hs-plugins was whining about libwsock32.dll and stuff
14:36:19 <Cale> huh, that's odd.
14:37:17 <sjanssen> ailndx: you're just trying to build lambdabot?  Do you absolutely need code execution support?
14:37:43 <malcolmw> hyrax42: click on the "short list" link, not on the "view tickets"
14:38:23 <Cale> Based on what he's said, I think he's looking to get hs-plugins support in his own application.
14:38:38 <jyasskin> @. bf . id . pl . v . wn yow
14:38:40 <hyrax42> malcolmw: I do, it tells me ticket 792 doesnt' exist
14:38:50 <lambdabot> Plugin `compose' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:38:55 <sjanssen> hence hs-plugins is certainly a requirement :)
14:39:50 <Igloo> hyrax42: What URL?
14:39:57 <bd_> ?where soc
14:39:57 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
14:40:06 <hyrax42> I start there
14:40:11 <hyrax42> I scroll down to where it says project ideas
14:40:14 <hyrax42> and click "short list"
14:40:16 <hyrax42> and get an error
14:40:27 <hyrax42> http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&type=proposed-project&order=priority
14:40:30 <lambdabot> Title: Custom Query - Haskell.org Google Summer of Code - Trac, http://tinyurl.com/fl2dw
14:40:35 <hyrax42> that url is what I get
14:40:52 <hyrax42> if I click "ideas page" in middle of students: paragraph
14:40:56 <hyrax42> or "short list" further dow
14:40:57 <hyrax42> n
14:42:38 <sjanssen> hyrax42: that looks fine to me
14:42:42 <ailndx> Cale: yeah i want the eval function that lambdabot has in my own program
14:42:59 <hyrax42> sjanssen: then something is messed up somewhere between me and server
14:43:13 <hyrax42> all I get is this: Invalid Ticket Number
14:43:13 <hyrax42> Ticket 792 does not exist.
14:43:32 <Cale> I don't have much experience working with Haskell on windows, since I've been running flavours of linux for the last 6 years.
14:43:47 <sjanssen> hyrax42: are the results different if you log in to the wiki?
14:44:28 <hyrax42> hmm the results are different if I open it with firefox
14:46:43 * syntaxfree draws attention to #haskell-blah
14:46:55 <chessguy> ?hoogle enum
14:46:55 <lambdabot> Prelude.Enum :: class Enum a
14:46:55 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
14:46:55 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
14:47:50 <ailndx> Cale: yeah, seems like almost noone here has
14:47:59 * Heffalump uses it on Windows at work
14:48:27 <Cale> Heffalump: any hs-plugins? :)
14:48:27 <kc5tja> You know, you can write some pretty unmaintainable code in Haskell.  But compared to what I'm going through right now, it's quite substantially preferable.
14:48:30 * kc5tja sighs
14:48:34 <Heffalump> using ghci without working ^C and without a proper shell is annoying :-(
14:48:46 <Heffalump> Cale: errm, not that I've used. But I think augustss might have.
14:55:34 <encryptio> how do you read this out loud?  do foo <- bar
14:55:53 <opqdonut> this was discussed earlier today
14:55:59 <encryptio> really
14:56:05 <encryptio> when?
14:56:13 <opqdonut> 1225.18  nornagon$ matthew-_: i read it as 'comes from'
14:56:28 <Cale> "is the result of"
14:56:29 <opqdonut> 1225.47  matthew-_$ except in list comprehensions, where it's elemOf
14:56:43 <mbishop> I'd say "is"
14:56:47 <mbishop> but I'm weird :P
14:56:53 <Cale> "run bar getting foo"
14:56:59 <Cale> Depends on the monad.
14:57:07 <opqdonut> personally, i'd say something like bar into foo
14:57:07 <encryptio> i was thinking of saying "foo binds to the result of bar"
14:57:14 <encryptio> but that's really longwinded
14:57:41 <LoganCapaldo> I think of it as a sound effect
14:57:49 <LoganCapaldo> its kind of whoosh sucking noise
14:58:14 <opqdonut> :DD
14:59:00 <hyrax42> who is in charge of soc stuffs?
15:01:34 <opqdonut> hyrax42: depends on the task
15:01:37 <opqdonut> see the soc page
15:01:48 <hyrax42> I mean generally
15:02:02 <doserj> google...
15:02:16 <hyrax42> well the specific question is which of the old projects are still good?
15:02:22 <hyrax42> or rather, were the completed ones removed from the list?
15:07:17 <ndm> hyrax42, i think they were - any interest in any specific ones?
15:07:36 * ndm is now an official mentor, entirely for the t-shirt :)
15:07:43 <chessguy> !paste
15:07:43 <hpaste> Haskell paste bin: http://hpaste.org/
15:08:38 <hpaste>  chessguy pasted "I've never seen this error before..." at http://hpaste.org/991
15:08:46 <chessguy> why won't it let me do this?
15:09:17 <ndm> chessguy, because its illegal
15:09:26 <chessguy> @slap ndm
15:09:26 * lambdabot slaps ndm
15:09:32 <ndm> chessguy, which p does the Piece refer to
15:09:49 <ndm> either do type PieceOnBoard p = Piece p =>
15:09:54 <ndm> or add a forall p
15:10:03 <chessguy> there is only 1 p
15:10:08 <ndm> (if you want to go all existential on the code)
15:10:08 <chessguy> in the type
15:10:18 <ndm> no, there are no p's in the type
15:10:26 <ndm> you have to introduce p, then use it
15:10:32 <chessguy> the type is (p, Square)
15:10:35 <ndm> type PieceOnBoard p = ....
15:10:43 <ndm> type PieceOnBoard = forall p . ....
15:10:55 <ndm> I suspect you mean the former
15:12:02 <chessguy> type PieceOnBoard p = Piece p => (p, Square) -- this doesn't solve it
15:12:38 <ndm> chessguy, what is the error for with the p being present?
15:12:57 <ndm> are you allowed constraints on type's? I would have thought it was a bad idea anyway though
15:13:07 <chessguy>  Illegal polymorphic or qualified type: (Piece p) => (p, Square)
15:13:10 <ndm> type PieceOnBoard p = (p, Square) would be how i did it
15:13:19 <glguy> sjanssen: still on?
15:13:28 <ndm> then to all the type sigs add Piece p => PieceOnBoard p -> PieceOnBoard p
15:14:11 <chessguy> bah, i'll just write out the tuple where i need it
15:14:24 <opqdonut> make a type alias for it!
15:14:37 <ndm> chessguy, a type alias is handy still
15:14:43 <chessguy> opqdonut: that's what i'm trying to do
15:14:48 <glguy> ?seen sjanssen
15:14:49 <lambdabot> sjanssen is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 31m 1s ago.
15:14:56 <chessguy> but i don't want just anything to be where the p is
15:15:14 <opqdonut> ah okay
15:15:47 <sorear> hello.
15:15:50 <ndm> chessguy, you can state that later - adding context to data is a really bad idea, it appears adding it to type is impossible
15:15:52 <ndm> hello sorear
15:16:06 <hyrax42> ndm: working through the list
15:16:08 <chessguy> hi sorear
15:16:16 <ndm> sorear, i've tweaked catch_1 quite a bit since yesterday - more reliable now in various problems
15:16:30 <ndm> sorear, plus -memory and -time flags, if you are interested in benchmarks
15:17:14 <chessguy> i don't understand why this is such a bad idea.
15:17:25 <ndm> i also intend to do an "interpetting constraints" manual/tutorial
15:17:41 <ndm> chessguy, i tried it once, i got bitten every time...
15:17:52 <chessguy> bitten how?
15:18:04 <ndm> chessguy: consider data Ord a => Data a = Zero | One a
15:18:11 <ski> it doesn't work as one expects
15:18:20 <ndm> now try writing "Zero" - you can't because it doesn't have an Ord for a
15:18:32 <ndm> despite the fact it doesn't have an a, it still wants to order nothing!
15:18:50 <ski> and it doesn't alleviate one from writing the 'Ord a' context for 'One a' ..
15:18:51 <chessguy> huh.
15:19:18 <ndm> yes, thats the other issue - the code gets longer only, never shorter
15:19:23 <ski> it only enforces that one must always state the context on all uses of the constructor
15:19:34 <ski> s
15:20:26 <ski> Data :: (a :: *) -> Ord a => *  -- something like this is what we'd like, i think
15:20:48 <chessguy> well, i could always do data PieceOnBoard = PieceOnBoard :: { piece :: Piece p => p, square :: Square }
15:21:01 <Heffalump> show [] is the standard one that catches people out there
15:21:02 <ski> you still need to bind 'p'
15:22:13 <chessguy> so it would have to be PieceOnBoard p = ... ?
15:22:16 <ndm> data Piece p => PieceOnBoard p = PieceOnBoard { piece :: => p, square :: Square }
15:22:19 <ski> the 'Piece p' only constrains the 'p', it doesn't bind it
15:22:27 <fasta> We could add this to the topic too :P http://irc.tnet.no/img/13425.jpg
15:22:27 <ndm> data Piece p => PieceOnBoard p = PieceOnBoard { piece :: p, square :: Square }
15:23:14 <hyrax42> ndm: to answer your question, refactoring stuff sounds very interesting
15:23:42 <ndm> hyrax42, HaRe stuff?
15:24:07 <hyrax42> ndm: yeah I think so
15:24:11 <hyrax42> I've never looked at it much
15:24:42 <hyrax42> but it seems like a really fertile ground for stuff that would make quite a difference to programmers
15:24:49 <ski> chessguy : if you want that each 'PieceOnBoard' could contain it's own 'p' of a possibly different type than other 'PieceOnBoard', then you want to go existential .. otherwise i think you want what ndm said
15:25:14 <chessguy> yeah, i think he's right
15:25:19 <chessguy> (no surprise)
15:25:47 <hyrax42> where is this chess stuff coming from
15:25:53 <ski> if you want to enforce that a list (say) of 'PieceOnBoard' all have the same 'p' inside, then you really need to have '[PieceOnBoard p]'
15:26:02 <chessguy> hyrax42: coming from?
15:26:13 <chessguy> ski: yes, that makes sense now
15:26:15 <ndm> hyrax42, i think the hard bit about HaRe is getting a good way for programmers to decide to apply to it - i.e. an appropriate user interface to encourage people to use it, rather than the underlying refactors
15:26:37 <hyrax42> ndm: yeah that's my big qualm iwth it
15:26:46 <hyrax42> there's no standard IDE, nor do I think there should be
15:26:56 <hyrax42> everyone hates leaving their little world
15:27:02 <ndm> hyrax42, part of my idea for GuiHaskell is to solve that (its one of the projects)
15:27:05 <ski> (so integration with current ones is needed)
15:27:19 <ski> GuiHaskell ?
15:27:20 <ndm> aimed at bringing everyone together, without forcing them to leave their world
15:27:27 <ndm> @where guihaskell
15:27:28 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php
15:27:34 <hyrax42> ndm: I'll read the description
15:27:34 <ski> danke
15:29:12 <ski> hm .. how about emacs ?
15:29:35 <chessguy> hyrax42: as for where this "chess stuff" is "coming from", i was vexed and inspired by the chess post on the haskell-cafe mailing list today, enough that i decided to write my own little chess engine this weekend
15:29:54 <hyrax42> chessguy: sorry I forgot to explain: I meant was there a post or source you were talking about
15:29:55 <chessguy> err, was it on -cafe?
15:30:10 <hyrax42> I'll be backin a bit, food time
15:31:21 <chessguy> oh, it was just on haskell@haskell.org
15:36:00 <psi> ?djinn Int -> a
15:36:01 <lambdabot> -- f cannot be realized.
15:36:39 <mauke> f = undefined
15:36:57 <psi> that's what I thought
15:38:02 <LoganCapaldo> djinn really doesn't try hard enough in my opinion :)
15:38:25 <LoganCapaldo> and its f _ = undefined, no?
15:38:36 <LoganCapaldo> well f = undefined works too
15:38:38 <mauke> > undefined :: Int -> a
15:38:39 <lambdabot>  Add a type signature
15:38:41 <roconnor> @instances Monad
15:38:42 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:38:52 <LoganCapaldo> but f _ = undefined is clearer
15:38:55 <LoganCapaldo> :)
15:39:25 <LoganCapaldo> @type undefined 1 :: a
15:39:27 <lambdabot> a :: forall a. a
15:39:32 <LoganCapaldo> hehehehe
15:40:12 <shapr> SHAZAM!
15:40:27 <LoganCapaldo> Would it be possible to get the undefined literal removed from the language? Or does it serve some purpose I don't understand?
15:40:45 <Cale> undefined is defined in the Prelude
15:41:01 <LoganCapaldo> @src undefined
15:41:01 <lambdabot> undefined =  error "Prelude.undefined"
15:41:09 <mauke> LoganCapaldo: it's great for prototyping
15:41:26 <LoganCapaldo> well ok then I have nothing to complain about :)
15:41:34 <sorear> LoganCapaldo: haskell is partial.  we hate it too
15:41:45 <Cale> I use it copiously whenever someone here is trying to get something to typecheck and doesn't provide complete code.
15:42:06 <roconnor> :type let undefined = fix id in undefined 1 :: a
15:42:13 <sorear> hv will use it on renamer errors
15:42:15 <roconnor> @type let undefined = fix id in undefined 1 :: a
15:42:17 <lambdabot> a :: forall a. a
15:42:22 <LoganCapaldo> hv?
15:42:41 <LoganCapaldo> @where hv
15:42:42 <lambdabot> I know nothing about hv.
15:42:48 <roconnor> LoganCapaldo: as long as we have fix, we might as well have undefined.
15:43:00 <sorear> @seen dons
15:43:00 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 9h 5m 6s ago.
15:43:14 <LoganCapaldo> I know
15:43:39 <LoganCapaldo> Its just the idea of being able to type it so easily :)
15:43:50 <ClaudiusMaximus> > typeOf (undefined:: Int->Int)  -- undefined can be useful sometimes
15:43:51 <lambdabot>  Int -> Int
15:44:00 <monochrom> @remember Cale undefined is defined in the Prelude
15:44:00 <lambdabot> Done.
15:45:01 <monochrom> "import Prelude hiding (undefined)" will free up the name.
15:45:02 <roconnor> ah cool
15:45:33 <Toxaris> http://haskell.org/hawiki/ReifiedType
15:45:34 <lambdabot> Title: ReifiedType - The Haskell Wiki
15:46:30 <LoganCapaldo> Yeah, its that member of every boxed type bit that bothers me the most
15:46:54 <LoganCapaldo> feels dirty :)
15:47:15 <fasta> Undefined sometimes takes the role of NULL in other languages.
15:47:26 <ski> obviously we need a 'NonTermination' monad
15:47:33 <sorear> fasta: the fact you can't test for it keeps people honest
15:47:53 <monochrom> Every boxed type has a bottom.  These bottoms are all different.  But they all happen to have the same name: "undefined".
15:47:56 <ski> (hm, doesn't Coq have something like that ? or was it Epigram ?)
15:48:05 <LoganCapaldo> this is more convincing actually http://haskell.org/hawiki/TraitsTypeclass
15:48:06 <lambdabot> Title: TraitsTypeclass - The Haskell Wiki
15:48:12 <fasta> sorear: I think R6RS Scheme will include a test of undefined.
15:48:14 <roconnor> ski: yes!
15:48:14 <Toxaris> that's it: data-wise, it's nothing, but type-wise, it's everything
15:48:26 <sorear> ski: Epigram
15:48:30 <ski> ok
15:48:30 <hyrax42> :t typeOf
15:48:32 <roconnor> ski: I've seen in implemented in Coq
15:48:33 <lambdabot> forall a. (Typeable a) => a -> TypeRep
15:48:35 <fasta> sorear: I don't know whether it's a good thing.
15:48:45 <roconnor> or at least read a paper about it.
15:48:59 <ski> hm .. that reminds me of the "Algorithm" comonad ..
15:49:29 <hyrax42> hm so undefined :: Int# is bad?
15:49:36 <ski> yes
15:49:39 <ski> :t undefined
15:49:42 <lambdabot> forall a. a
15:49:45 <ski> that is
15:49:46 <fasta> When the algorithm is done I don't use undefined, though. I use error "Never ever evaluate this (with some nice message)".
15:49:51 <ski> forall a :: *. a
15:49:54 <ski> while
15:49:58 <ski> :k Int#
15:50:01 <lambdabot> Not in scope: type constructor or class `Int#'
15:50:18 <hyrax42> ski: I see
15:50:30 <hyrax42> are there other "kind types" than * and #?
15:50:33 <ski> @kind GHC.Prim.Int#
15:50:36 <lambdabot> #
15:50:58 <ski> hyrax42 : yes, 'k0 -> k1' for any kinds 'k0' and 'k1', as well as '(#)' and '?' and '??'
15:51:00 <fasta> Meta kinds FTW.
15:51:02 <ski> :k (->)
15:51:04 <lambdabot> ?? -> ? -> *
15:51:24 <monochrom> Bottom is not dirty.  It's very elegant.  Imagine a system of whole numbers without 0; that would be yucky, you would have no suitable initial value for counting lengths of lists.  Imagine a boxed type without bottom; that would be yucky, you would have no suitable initial value for approximating fixed points by iteration.
15:51:30 <ski> '??' is the superkind of '*' and '#'
15:51:37 <ski> '?' is the superkind of '??' and '(#)'
15:51:44 <hyrax42> what the ug
15:51:51 <ski> '(#)' is the kind of unboxed tuple types
15:52:05 <hyrax42> ?kind (Int,Int)
15:52:08 <lambdabot> *
15:52:16 <sorear> there's also !
15:52:25 <sorear> @kind GHC.Prim.MutVar#
15:52:26 <ski> :k (# Int# , Bool #)
15:52:28 <roconnor> monochrom: fixed points are yucky
15:52:29 <lambdabot> * -> * -> !
15:52:29 <lambdabot> Not in scope: type constructor or class `Int#'
15:52:31 <roconnor> :)
15:52:41 <ski> :k (# GHC.Prim.Int# , Bool #)
15:52:43 <lambdabot> (#)
15:52:54 <hyrax42> arg
15:52:56 <ski> sorear : oh, didn't know that ..
15:53:08 <hyrax42> this ?? ? is coming from nowhere for me
15:53:21 <ski> sorear : where does that fit into the subkinding hierarchy ?
15:53:22 <fasta> hyrax42: I have seen it before.
15:53:32 <LoganCapaldo> 1) I don't think 0 is bottom for the integers 2) useful things can be yucky
15:53:51 <monochrom> The integers have no bottom.
15:53:54 <Toxaris> monochrom: is it important that all boxed types have different bottoms?
15:54:08 <LoganCapaldo> I don't think 0 is analogous to bottom rather
15:54:16 <monochrom> It is not important, Toxaris.
15:54:21 <ski> (Toxaris : all distinct types are disjoint ..)
15:54:45 <monochrom> In the usual order of the whole numbers, 0 is the bottom.
15:54:49 <hyrax42> ski: what about Nothing?  Or []?
15:54:50 <sorear> ski: (wrt ! and subkinding) I have absolutely no clue.
15:55:06 <sorear> ski: I've seen it myself, but I've never read about it
15:55:09 <hyrax42> aren't they members of infinitely many types?
15:55:16 <LoganCapaldo> IOW I don't like your example, also I'm not complaining about bottom I'm complaining about being able to refer to undefined by name :)
15:55:27 <LoganCapaldo> so easily
15:55:31 <LoganCapaldo> :)
15:55:32 <hyrax42> ?seen ndm
15:55:32 <lambdabot> I saw ndm leaving #haskell 25m 42s ago, and .
15:55:40 <allbery_b> enh.  it's a useful way t stub stuff
15:55:54 <allbery_b> perl6 even imported it as the "..." operator
15:55:57 <sorear> hyrax42: he often sleeps around now :)
15:56:15 <hyrax42> it's only 11
15:56:20 <hyrax42> not thaat late
15:56:20 <Toxaris> if it's exist, and is usefull, it should have a standard name
15:56:21 <monochrom> Consider the polymorphic function id = \x -> x.  You could say: this is shared by all types of the form "a->a".  You could say: different types have different id's, they just happen to have the same name and copy from the same code.
15:56:23 <sorear> @localtime dcoutts
15:56:23 <LoganCapaldo> Ah but if you make it hard to stub things people will have no choice but to finish their programs :)
15:56:24 <hyrax42> and a friday at that
15:56:32 <allbery_b> (sub notImplYet {...})
15:56:40 <Toxaris> what's the point with everyone writing their own undefined = undefined
15:56:46 <sorear> hyrax42: 22:55 in ndm's tz
15:56:53 <fasta> Did anyone ever prove that everything computable in O(f(n)) on a Turing machine is computable in that same time in Haskell (without using the Turing tarpit argument)?
15:56:56 <hyrax42> sorear: exactly
15:56:57 <hyrax42> 11
15:57:09 <hyrax42> not terribly late
15:57:15 <hyrax42> so there was a chance
15:57:27 <ski> hyrax42 : 'Nothing' and '[]' are polymorphic .. i.e. you get specific monomorphic instances in each case
15:58:05 <Toxaris> ski: yes i know this for "normal values", but at the other hand, i know undefined as being something added "later" to all types (in my student-like-view of semantics being defined step by step)
15:58:17 <ski> :k (# GHC.Prim.Int# , Bool , GHC.Prim.MutVar# () () #)
15:58:19 <lambdabot> (#)
15:58:28 <hyrax42> fasta: it won't be the same f generally I'd say
15:58:36 <sorear> fasta: haskell can emulate a TM at O(1) per step, so yes
15:58:38 <ski> :k GHC.Prim.Int# -> Bool -> GHC.Prim.MutVar# () () -> ()
15:58:41 <lambdabot> *
15:58:45 <ski> :k GHC.Prim.Int# -> Bool -> GHC.Prim.MutVar# () ()
15:58:47 <lambdabot> *
15:58:56 <LoganCapaldo> sorear: Wasn't that the tarpit argument?
15:58:56 <fasta> sorear: that's the Turing tarpit argument.
15:59:05 <ski> ok, so '!' is under '??' and '?'
15:59:47 <sorear> ok, well, I invoke proof-irrelevance :(
16:00:08 <monochrom> A Turing machine is not that fast anyway.  Takes like cubic time to increase a number by 1.
16:00:10 <fasta> hyrax42: that's not really relevant. It's interesting whether you can create an f' then that only is a constant slower.
16:00:44 <sorear> fasta: then they'd be the same.  big-oh notation ignores constant multipliers
16:00:59 <hyrax42> fasta: well actually O-wise it'd be same, I was thinkign theta
16:01:00 <fasta> sorear: yes, and that's what I am asking...
16:01:16 <hyrax42> you can generally do stuff a good deal faster if you don't have to go up and down a stupid tape
16:01:23 <fasta> monochrom: eh>
16:01:24 <ski> Toxaris : well .. '[False,undefined]' is also a member of '[Bool]'
16:01:26 <fasta> monochrom: eh?
16:01:35 <monochrom> People say O when they mean Θ.  Probably because they can't type Θ in ASCII.
16:01:37 <lucca> theta ignores constant multipliers
16:01:39 <hyrax42> or even going from 1-tape to 2-tape can change running time a lot
16:02:01 <sorear> fasta: I don't believe "without using the XYZ argument" is valid in logic, and I'm having difficulty formalizing it to myself...
16:02:04 <roconnor> hyrax42: how do you avoid going up and down the tape without using a fixed sized address space and destroying your TM nature?
16:02:08 <sorear> monochrom: sure you can. 0x3F :)
16:02:20 <kc5tja> sorear: I often take to using decibels to measure relative performances of two (or more) implementations.
16:02:26 <hyrax42> e.g. reversing on one tape is O(n^2) but O(n) on 2 tape
16:02:32 <kc5tja> Something that is 13dB faster than X is a solid 20x as fast.  :)
16:02:54 <monochrom> "man ascii" is very handy.  try to have windows beat that!
16:03:23 * monochrom also beats up sorear
16:03:48 <fasta> sorear: It's a pretty practical question. It basically answers whether one would ever need to implement an interpreter for a different language in Haskell, because it cannot be expressed on the Haskell efficiently.
16:03:50 <sorear> 0x3F matches what I saw exactly...
16:04:04 <fasta> on the Haskell level*
16:04:19 <monochrom> Yeah, I'm beating you up for using obsolete software :)
16:04:33 * roconnor wonders if Haskell is one of the few languages that is acutally Turing complete.
16:04:47 <encryptio> one of the few?
16:04:55 <roconnor> Presumably the fixed sized pointers makes C not Turing complete?
16:04:57 <sorear> fasta: As far as I'm concerned, interpreters prove equivalence...
16:05:01 <sorear> roconnor: correct.
16:05:14 <monochrom> But C also has stdio.
16:05:24 <sorear> roconnor: and fixed PATH_MAX means you can't cheat with stdio :)
16:05:30 <fasta> sorear: That's the Turing tarpit argument.
16:05:53 <lucca> sorear: you can send out over the network...
16:06:05 <shapr> @seen bringert
16:06:05 <lambdabot> I saw bringert leaving #haskell 6h 30m 18s ago, and .
16:06:22 <sorear> lucca: not in C
16:06:27 <shapr> So, anyone planning on being in Sweden, near Stockholm between April 3rd and April 17th?
16:06:44 <shapr> Lemmih just suggested EuroHaskell 07, and I'll be in Stockholm anyway...
16:06:49 <monochrom> Oh yeah, a bunch of communicating processes with unlimited message buffers is more than Turing complete. :)
16:06:51 <sorear> lucca: and even if you could, it would still be a FSM, albiet with IO
16:06:56 <lucca> sorear: well in those terms C cannot do IO either
16:07:17 <monochrom> This proves that Haskell is more than Turing complete.  Just forkIO like crazy!
16:07:21 <fasta> It's a philosophical question how powerful a machine connected to the universe is.
16:07:30 <sorear> lucca: C can do IO, see stdio.h, which is specced as part of the C spec.
16:07:36 <sorear> sockets.h is not
16:07:36 <roconnor> So, what's the answer?  Can't haskell simulate all operations of a TM by using a pair of lists each in O(1) time?
16:07:38 <monochrom> It cannot be more powerful than the universe :)
16:07:46 <fasta> Some people think it goes beyond Turing.
16:07:48 <chessguy> shapr: shucks, i'm always in stockholm, but not at that time, what a shame
16:07:54 <shapr> chessguy: Seriously?
16:08:01 <chessguy> no :)
16:08:05 <Toxaris> ski: wich reminds me of not understanding the implications of lazyness for formal semantics
16:08:07 <shapr> chessguy: Du talar inte svenska.. du bara skojar med mig!
16:08:08 <lucca> yargh, sophistry
16:08:18 <chessguy> yo mama!
16:08:44 <Toxaris> ski: unlike in strict languages, we may actually need these undefined "values" to describe some not so undefined ones
16:09:21 <sorear> @all-dicts sophistry
16:09:23 <lambdabot> *** "Sophistry" gcide "The Collaborative International Dictionary of English v.0.48"
16:09:23 <lambdabot> Sophistry \Soph"ist*ry\, n. [OE. sophistrie, OF. sophisterie.]
16:09:23 <lambdabot>    1. The art or process of reasoning; logic. [Obs.]
16:09:23 <lambdabot>       [1913 Webster]
16:09:23 <lambdabot>  
16:09:25 <lambdabot> [73 @more lines]
16:09:28 <ski> > take 2 ([5,8,0/0,undefined] ++ undefined)
16:09:30 <lambdabot>  [5.0,8.0]
16:09:47 <fasta> roconnor: The answer to what question? The one I posed initially?
16:09:47 <roconnor> > [5.0,8.0]
16:09:48 <lambdabot>  [5.0,8.0]
16:10:36 <sorear> fasta: yes. roconnor is using my argument...
16:10:36 <roconnor> fasta: yeah, it seem like haskell can simulate the operations of a TM.
16:10:53 <fasta> roconnor: that's known as the Turing tarpit argument.
16:11:03 <fasta> roconnor: which I specifically excluded
16:11:09 <roconnor> oh, ... what does that mean?
16:11:23 <roconnor> it makes it sound like a bad argument.
16:11:35 <fasta> roconnor: It's often used in language wars.
16:11:35 <ski> you need to also exclude enough so that one can't derive "the Turing tarpit argument"
16:11:48 <Toxaris> i bet it's undecidable to know if an argument is used in a proof
16:12:03 <chessguy> shapr: heh, you use the work 'naked' when talking about joking in swedish?
16:12:12 <roconnor> fasta: do languages get in wars about who is and isn't Turing complete?
16:12:14 <fasta> ski: I did that by saying that you cannot build an interpreter for another language in Haskell and use that to evaluate the actual program.
16:12:16 <shapr> chessguy: Huh?
16:12:26 <chessguy> bara
16:12:28 <shapr> chessguy: Naken?
16:12:33 <shapr> chessguy: Nah bara is "only"
16:12:36 <fasta> roconnor: ...
16:12:51 <chessguy> oh, whoops
16:12:53 <chessguy> bar is naked
16:13:04 <shapr> Yup, "bare"
16:13:31 <chessguy> and yes i am
16:13:35 <roconnor> fasta: you said ``It basically answers whether one would ever need to implement an interpreter for a different language in Haskell, because it cannot be expressed on the Haskell efficiently.''
16:13:36 <chessguy> ...only joking, that is
16:13:48 <ski> fasta : what is an interpreter ?  (in some sense, a program pattern-matching over a tree (or a list) is an interpreter)
16:13:53 <sorear> fasta: every time you add a definition, you are changing the language and creating an interpreter for the new one in terms of the old.  by your criteria, I can't use toplevel lets
16:14:09 <QtPlatypus> One can emulate lamba calculis within Haskall trivally, Lambda Calculis is known to be turing equiverlent, so Haskell is turing equiverlent.
16:14:10 <roconnor> fasta: how can an interpreter for a language evaluated in Haskell be faster than solving the problem in Haskell?
16:14:40 <sorear> roconnor: an interpreter for a language in haskell *is* solving the problem in haskell.
16:14:44 <roconnor> I mean, an interpted language inside Haskell is solving the problem in Haskell.
16:14:51 * sorear lives by the as-if rule
16:15:00 <shapr> sorear: sha! as if!
16:15:13 <sorear> aka proof irrelevance, aka blackboxism
16:15:17 * roconnor is confused
16:15:17 * QtPlatypus nods "Its meta programing, a rather standard way of solving problems."
16:15:28 <sorear> ok I made that last one up, but I kinda like it
16:15:40 <shapr> chessguy: So, did you ask a Swede you know to translate for you?
16:15:40 <sorear> blackboxism ftw!
16:15:57 <ski> @wtf ftw
16:15:57 <lambdabot> Maybe you meant: bf ft wn
16:16:04 <sorear> for teh win
16:16:05 <chessguy> @vera ftw
16:16:06 <lambdabot> No match for "ftw".
16:16:14 <sorear> standard around here...
16:16:19 <shapr> It is?
16:16:26 <dmwit> Internets!
16:16:28 <chessguy> i know i've heard it
16:16:30 <shapr> Where are you?
16:16:38 <ski> here !
16:16:40 <Gu1> integrate urban dictionary into lamdabot
16:16:42 <shapr> oh, of course.
16:16:56 <sorear> in this context #haskell.  I failed a pick-up-dialect check, didn't I?
16:17:21 <shapr> I don't know. I've seen ftw on sites like slashdot, but nowhere else.
16:17:28 <hyrax42> ?users
16:17:28 <lambdabot> Maximum users seen in #haskell: 336, currently: 301 (89.6%), active: 42 (14.0%)
16:17:31 <Gu1> it's big in online games
16:17:51 <dmwit> I'm big in Japan.
16:18:02 <shapr> I have been playing World of Warcraft some lately. I discovered that English is rarely spoken by people on there.
16:18:18 <shapr> I do get a lot of "lfg 4 sm plz"
16:18:36 <chessguy> looks like swedish!
16:18:36 <hyrax42> ahha
16:18:38 <shapr> or "u gve me 1g plz?"
16:18:53 <dmwit> It takes time to type properly!
16:19:02 <dmwit> If I had that kind of time, would I be playing WoW?
16:19:04 <Gu1> what i like to do is put the gold in the trade window, then go afk but not press trade
16:19:09 <Gu1> they will sit their for hours waiting
16:19:12 <Gu1> or leave
16:19:12 <hyrax42> time better spent leveling of course
16:19:15 <shapr> Gu1: You're mean.
16:19:19 <shapr> Very very mean.
16:19:21 <shapr> I like it.
16:20:01 <Gu1> i guess playing a troll makes you mean
16:20:13 <LoganCapaldo> its a double entendre
16:21:04 <shapr> Some people communicate so badly that I have been unable to figure out what they're saying even after the fifth time they repeat themselves.
16:21:23 <chessguy> sounds like some of my professors
16:22:46 <fasta> I think the real question is whether adding the rule to Haskell that one can subvert the type system makes some things asymptotically more efficient to compute (even when ignoring constant factors).
16:23:14 <lucca> ski: i've seen ftw most frequently used by the imgboard crowd
16:23:28 <fasta> By "type system" I mean the Haskell 98 type system.
16:23:33 <LoganCapaldo> shapr: wh4vr >>= u mn?
16:23:41 <fasta> LoganCapaldo: cute
16:24:01 <LoganCapaldo> fasta: cute?
16:24:38 <Toxaris> what do you mean by "subvert"?
16:24:39 <ski> (another question would be if it can improve the asymptotic time to compute the wrong answer, or no answer at all)
16:24:40 <fasta> LoganCapaldo: nice, fun, well thought of, how do you want it to hear?
16:25:19 <LoganCapaldo> fasta: well thanks. A lot of the time cute is sarcastic though. Was just checking :)
16:25:19 <fasta> LoganCapaldo: 1. Clever; sharp; shrewd; ingenious; cunning. [Colloq.]
16:26:26 <fasta> Toxaris: I mean that you can do things like: given a value::[a] you can change some of the values to (a,b) for example.
16:26:37 <ski> (imagine getting all bottoms in constant time !)
16:27:26 <Toxaris> getting a bottom in finite time should be impossible due to the halting problem
16:27:38 <ski> > let x = x in x
16:27:39 <lambdabot>  Exception: <<loop>>
16:27:40 <Toxaris> it's all too deep: you can't dive to the bottom
16:27:53 <ski> that's constant time
16:27:59 <Toxaris> and what does it tells me?
16:28:17 <fasta> For some computations, bottom is easy to find.
16:28:18 <ski> that you can get some bottoms in constant time
16:29:14 <Toxaris> ok, i will change my statement to "gettin all bottoms in finite ..."
16:29:51 <Toxaris> let's consider transforming our program as follow:
16:29:56 <Toxaris> (1) merge all data-definitions
16:30:01 <Toxaris> (includign prelude)
16:30:31 <Toxaris> (2) add a Construction Function (UniversalDataType -> UniversalDataType)
16:30:48 <Toxaris> and we have dynamic typing inside the static typesystem
16:31:28 <vincenz> Who here uses bsd?
16:32:04 <Toxaris> so allowing dynamic typing by some language extension brings no speedup, because we could have written our program with merged data types already
16:32:21 <edwardk> @seen ski
16:32:21 <lambdabot> ski is in #haskell. I last heard ski speak 4m 3s ago.
16:32:21 * shapr waves at edwardk
16:32:25 <edwardk> how goes?
16:32:29 <ski> edwardk : hiya
16:32:31 <shapr> Life is exciting!
16:32:34 <edwardk> heh
16:32:45 <edwardk> sounds like something has changed in the life of shapr =)
16:33:15 <edwardk> Has anyone applied the trick in http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros to arrows yet?
16:33:17 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
16:33:32 <edwardk> started doing so then i thought i should ask =)
16:33:37 <shapr> edwardk: Well, I'm going to visit my girlfriend in a few days...
16:34:15 <edwardk> ah, now the exceptionally perky shapr makes sense =)
16:34:33 <shapr> :-)
16:34:50 <shapr> Not that I'm anything less than hyperactive most days...
16:34:55 <edwardk> heh
16:35:06 <emk> shapr: Congrats! I'm not so lucky; my girlfriend can't fly home for her birthday because of the massive snowstorm on the east coast. :-(
16:35:07 <shapr> C'mon we were roommates for a day, what did you think?
16:35:34 <shapr> emk: aha! it's YOU!
16:35:57 <shapr> emk: I've been trying to find you on #haskell to respond to one of your blog entries... but I forget which entry or what I was going to say...
16:35:59 * shapr thinks hard
16:36:01 <edwardk> not much going on here, getting my couch tomorrow, my roomba has all but polished my floors, work is going well, got bored and started playing with haskell again the other day
16:36:19 <edwardk> ah emk = eric kidd?
16:36:25 <edwardk> liked the monad blog entry
16:36:27 <sorear> edwardk: ye
16:36:40 <emk> edwardk: You'll definitely want to use -fno-implicit-prelude (and read the warnings in the Haskell manual) instead of using Template Haskell. That simplifies the trick somewhat.
16:36:48 <mbishop> eric kidd that ruby lover?
16:36:49 <mbishop> :P
16:36:50 <jcreigh> emk++ always seems to have insightful, well-written blog postings
16:36:52 <emk> edwardk: Thanks!
16:36:55 <edwardk> emk: yeah definitely =)
16:37:03 <sorear> edwardk: btw, you pretty much don't need to ask ... people don't lie in /whois around here
16:37:11 <edwardk> emk: too bad that doesn't work for the arrows though
16:37:16 <mbishop> sorear: I do :)
16:37:30 <edwardk> sorear: heh helps to actually remember to whois before asking ;)
16:37:36 <sorear> you're not martin bishop?
16:37:46 <edwardk> emk: the -fno-implicit thing anyways, or maybe it will hrmm
16:38:04 <shapr> Does anyone not know who I am?
16:38:06 <sorear> drats, cloak, can't $ whois ...
16:38:14 <sorear> shapr: I do!
16:38:15 <edwardk> heh
16:38:22 <sorear> shapr: oh, *not* know
16:38:28 <sorear> shapr: makes a difference :)
16:38:34 <emk> edwardk: There's a whole bit in the GHC manual on -fno-implicit-prelude and arrows, which basically says, "This should work, but you'll need to get the details exactly right."
16:38:35 <mbishop> sometwo: nope
16:38:38 <mbishop> er
16:38:46 <mbishop> sorear: nope, and I'm not Martin Bryce either :)
16:38:47 <shapr> emk: Hi, I'm Shae Erisson, you may have heard of me.. or maybe not.
16:39:01 <sorear> @go shapr
16:39:05 <lambdabot> http://www.scannedinavian.com/hope/
16:39:13 <sorear> wow, that was good
16:39:20 <edwardk> yeah i tried to hack up a sort of 'proto-arrow' to get the same sort of deal you are doing with Monads now to work with Arrows then, but had problems getting the sugar to work
16:39:26 <edwardk> even with the -fno-implicit stuff
16:39:40 <Limbic_Region> anyone here hacking on pugs and/or perl 6?
16:39:51 <Limbic_Region> actually, I don't believe either is a prerequisite
16:40:01 <Limbic_Region> there was a question on PerlMonks regarding Haskell
16:40:02 <Limbic_Region> http://perlmonks.org/?node_id=604642
16:40:04 <lambdabot> Title: can you use perl6 from haskell?
16:40:50 <emk> sharpr: Hi! I like the Sweden annecdote on your website.
16:40:55 <Limbic_Region> the question is not specific to perl 6 but rather perl(ish) techniques in haskell - if anyone is interested
16:41:10 <shapr> emk: Oh yeah! Have you seen nanevski's calculus that includes possibility and necessity? That should allow commutative monads.
16:41:20 <edwardk> the main use was something someone had posted on the haskell wiki involving an arrows as pipes problem for inter process communication, which you would need to require the inputs of all arrows as Read and outputs as Show, same kind of trick as your Ord requirement
16:41:23 <sorear> Limbic_Region: afj, but:
16:41:26 <sorear> @google haskerl
16:41:29 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
16:41:29 <lambdabot> Title: The Haskerl index
16:41:47 <shapr> edwardk: That's the same as the outstanding problem with  Hughes' CGIArrow, yeah? Did you find a solution?
16:42:06 <jcreigh> sorear: "afj"? April Fool's Joke?
16:42:10 <allbery_b> there's already Text.Regex.PCRE
16:42:15 <sorear> @vera afj
16:42:16 <lambdabot> No match for "afj".
16:42:23 <sorear> @jargon afj
16:42:24 <lambdabot> *** "AFJ" jargon "Jargon File (4.3.1, 29 Jun 2001)"
16:42:24 <lambdabot> AFJ // n. Written-only abbreviation for "April Fool's Joke". Elaborate
16:42:24 <lambdabot>    April Fool's hoaxes are a long-established tradition on Usenet and
16:42:24 <lambdabot>    Internet; see {kremvax} for an example. In fact, April Fool's Day is the
16:42:24 <lambdabot>    _only_ seasonal holiday consistently marked by customary observances on
16:42:26 <sorear> and yes
16:42:26 <lambdabot>    Internet and other hacker networks.
16:42:28 <lambdabot>  
16:42:34 <edwardk> i think i may be able to rip of emk's trick to make it work, started putzing on it again 20 minutes ago or so, may not be able to get the sugar right, but the use of template haskell there wouldn't suck too badly
16:42:35 <allbery_b> and I've seen people post combinators for it to give you ~=-ish stuff
16:42:47 <allbery_b> substitution is a bit harder to do in a perlish style
16:42:48 <shapr> emk: Yeah, that was pretty depressing... Happily, two weeks ago I met a cashier in (and from) a tiny Alabama town who spoke Swedish to me.
16:43:20 <allbery_b> since perl s/// modifies its argument, which is a haskell no-no
16:43:27 <shapr> edwardk: If you can get it to work, it'll allow seaside-style continuation based websites among many other interesting things.
16:43:47 <emk> shapr: I saw possibility and necessity just recently. :-) Since they look like well-behaved measure spaces, it should be possible to define a reasonable monad over them--just replace the math part of Perhaps with the new rules.
16:43:49 <edwardk> i'll continue to play with it and let you know
16:44:08 <shapr> emk: So, are you coming to the next ICFP?
16:44:21 <edwardk> emk: modal possibility and necessity?
16:44:41 <shapr> edwardk: btw, I think it was stepcut, aka Jeremy Shaw, who posted that problem involving arrows as shell pipes.
16:45:00 <edwardk> shapr: k, couldn't find it when i went to go back and look for it
16:45:01 <liquidengineer> has anyone seen dons?
16:45:06 <shapr> Meaning that if you can figure it out, Linspire will probably start using it immediately :-)
16:45:07 <edwardk> @seen dons
16:45:07 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 10h 7m 12s ago.
16:45:07 <emk> edwardk: Template Haskell doesn't seem to know about some of the more obscure GHC syntax extensions, so you might not be able to reuse the arrow-related sugar the same way I reused do. But the '-fno-implicit-prelude' docs strongly suggest you can get by without it.
16:45:26 <liquidengineer> edwardk: ah.  Thanks.
16:45:52 <edwardk> emk: heh, well, i tried a pretty braindead arrow replacement that didn't work even when it was almost identical to the basic arrow implementation, we'll see
16:46:03 <emk> edwardk: I was thinking of http://en.wikipedia.org/wiki/Possibility_theory , which is related to more to set theory than to old-fashioned modal logic.
16:46:03 <lambdabot> Title: Possibility theory - Wikipedia, the free encyclopedia
16:46:32 <emk> shapr: Germany, in late September?
16:46:42 <shapr> I think edwardk pointed me to nanevski's possibility and necessity calculus.
16:46:45 <shapr> emk: Yup, I think that's it.
16:46:50 <edwardk> emk: ah ok, i was going to say the modal versions already have a nice definition as a monads and comonads
16:46:59 <shapr> I wonder if they give funding to committee members so they can fly over.
16:47:23 <shapr> emk: oh HEY! Are you using Haskell for your 2d/3d work? I'm a committee member for Commercial Users of Functional Programming 2007, so...
16:48:20 <emk> shapr: Some folks here suggested that the (unpublished & unfinished) paper I've been ripping the probability posts out of might be worth finishing and submitting to Haskell Workshop.
16:49:03 <shapr> Yeah, I think it would be worth submitting to HW.
16:49:25 <emk> So I might make it to Germany.
16:49:36 <shapr> But I'm not on that committee... so that's why I'm hoping you're using Haskell to do something commercially useful and I can persuade you to come talk about it at CUFP.
16:49:56 <emk> shapr: The 2D/3D stuff is in Scheme and C++, actually.
16:50:07 <shapr> Well, scheme is fine.. want to talk about it at CUFP?
16:50:33 <shapr> I'm hoping alexj will talk about HAppS as well.
16:50:52 <shapr> It seems like the guy from IBM is really showing up at CUFP, yay!
16:51:13 <dons> http://programming.reddit.com/info/1atf6/details ;-)
16:51:13 <shapr> edwardk: You using any FP at your cool new job?
16:51:13 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
16:51:14 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (reddit.c ...
16:51:37 <edwardk> shapr: heh, well i started banging out an implementation of OLAP in Haskell
16:52:04 <edwardk> shapr: when its done or near done we can talk. served as a good way to learn MDX and it mapped nicely into functional concepts
16:52:19 <shapr> Ok, think it'll be done before people gather in Freiburg?
16:52:25 <edwardk> as soon as I can parameterize an OLAP cube over an arbitrary HList of dimensions and an arbitrary monad i'll be happy.
16:52:29 <emk> shapr: Hmm. That's an interesting suggestion. We've gotten a lot of good mileage out of Scheme; there's certainly enough material for a talk (with a focus on DSLs for simulations).
16:52:32 <edwardk> dunno, when is that?
16:52:41 <shapr> Um
16:52:51 <shapr> I had some ACM spam in my mailbox recently...
16:53:03 <sorear> dons: hi.  jm has updated jhc, again. supposedly there's a new 'fgrin' backend to test.  alas, until laziloading is re-implemented I can't test it.
16:53:12 <shapr> aha! http://cufp.galois.com/
16:53:14 <lambdabot> Title: Commercial Users of Functional Programming
16:53:22 <dons> sorear: ah ok. good
16:53:34 <shapr> Talk proposals are due June 1st, 2007
16:53:53 <emk> shapr: We're a weird group--university affiliated, but all our funding comes from the outside and we make shrinkwrap training software that actually gets sold in boxes. Does that meet your criteria for "commercial"?
16:54:04 <edwardk> hrmm
16:54:13 <shapr> It's seriously weird to see my name in the committee member listing...
16:54:31 <mbishop> ohh Xavier Leroy is on that committee
16:54:48 <shapr> Yeah, that guy kicks butt.
16:54:59 * mbishop <3 ocaml
16:54:59 <shapr> emk: That's definitely commercial.
16:55:15 <shapr> Did you see his recent paper where he really exercises the CH correspondence?
16:55:25 <shapr> I think he used NuPRL to turn some proofs into programs.
16:55:36 <shapr> It was a rollicking read.
16:55:40 <dons> http://wadler.blogspot.com/2007/03/three-ways-to-improve-your-writing.html
16:55:42 <dons> (!)
16:55:42 <lambdabot> Title: Wadler's Blog: Three ways to improve your writing, http://tinyurl.com/2y2l4q
16:56:49 <psi> profiling doesn't seem to slow down execution in any noticable way. is that a correct observation?
16:56:53 <mbishop> shapr: who?
16:56:54 <emk> shapr: Then I'm definitely interested in submitting a talk proposal.
16:57:03 <dons> psi, hmm. *no*
16:57:12 <dons> it should really get in the way of good optimisations
16:57:20 <dons> i find typically 2 to 3x slower with -prof
16:57:29 <dons> you are compiling with -O or -O2?
16:57:33 <psi> okay, my program isn't very complex.
16:57:36 <psi> -O
16:57:37 <dons> ok.
16:58:04 <dons> the kind of programs I seem to write get much slower under profiling. but that's usually libraries that are obsessively tuned.
16:58:19 <dons> so particular critical optimisations won't occur
16:59:02 <Igloo> dons: Even with no cafs?
16:59:09 <psi> i remember profiling some python code once, and it became drastically slower, 10x, maybe more.
17:00:00 <jcreigh> just be glad it's not like Ruby's profiler, which, IIRC, hits you for something like two orders of magnitude.
17:00:21 <jcreigh> (of course, that was the pure-ruby profiler; I think there's been some recent effort to write one in C that actually works)
17:01:03 <glguy> If you are using a language like Ruby, slow performance is the least of your concerns!
17:01:07 <sorear> I like the C profiler, which carries no overhead except the incrementing of bucket vars on timer interrupts. (assuming you don't want procedure entry counts)
17:02:07 <fasta> dons: is the time as reported with "excluding profiling overheads" about the same as the time that would be obtained when compiled without -prof?
17:03:41 <emk> The Ruby VM is basically the slowest thing out there, and fixing that is hard--there's a huge 1800-line rb_eval function that walks the AST. But once somebody rewrites Ruby to generate bytecodes, further optimizations should follow quickly.
17:04:31 <jcreigh> well, there's YARV
17:04:36 <emk> The theoretical performance limit is approximately that of Self, one of the optimizing SmallTalk descendants. Self got the same 25%-50% of C performance that GHC tends to get (if you refrain from doing something stupid like using String).
17:04:55 <emk> Yeah, once YARV runs Rails, things will start to improve quickly.
17:05:51 * emk seriously investigated writing a native-code backend for Ruby using the amazing LLVM, but gave up in despair at the sheer size of the AST walker.
17:06:06 <emk> http://llvm.org/
17:06:07 <lambdabot> Title: The LLVM Compiler Infrastructure Project
17:06:39 <emk> I'd love to do a Haskell DSL for generating strongly-typed LLVM bytecode, which could then be optimized and JITed at runtime.
17:06:48 <pejo> dons, woah, nice link. Thanks!
17:06:53 <Nafai> emk: That could be cool!
17:07:44 <emk> Nafal: Yeah, the assembly DSL in the latest Monad Reader would be just the trick!
17:08:26 <Gu1> ciao
17:09:15 <balodja> ?pl \f l -> l ++ map f l
17:09:16 <lambdabot> ap (++) . map
17:10:02 <dons> ?src ap
17:10:02 <lambdabot> ap = liftM2 id
17:10:03 <jcreigh> part of the problem with trying to get Ruby to compile to something is that a lot of the extensions are written in C and are expect to be able to interface with Ruby via C functions. That's why I think YARV has a chance; it just bolts onto the existing C AST interpreter and adds a bytecode compiler/interpreter
17:10:26 <dons> the language designer in me cringes
17:10:41 <emk> shapr: Do you know what day CUFP talks will fall on?
17:11:23 <edwardk> emk: someone finished up an assembly monad before me? =)
17:11:24 <edwardk> heh
17:11:25 <edwardk> cool
17:11:26 <Eelis> in ghc's template haskell, Q is a monad but not a functor. is there some deep reason for this, or is it an oversight?
17:11:27 <edwardk> i need to go look
17:11:55 <ski> instance Functor Q where fmap = liftM
17:12:21 <Philippa> Eelis: a big big language-wide oversight. Oh, and just occasionally you want the Functor instance to be a different one to the functor a monad's formed around
17:12:22 <shapr> emk: Seems to be Oct 4, 2007
17:12:26 <balodja> is there any suitable way in intepreter to get help about library functions?
17:12:51 <emk> dons: Well, the Ruby community don't face any unsolved research problems, and they've got a decent amount of momentum, so they'll sort it all out within a few years.
17:13:10 <edwardk> emk: where is that assembly dsl you are talking about?
17:13:15 <sjanssen> glguy: you rang a few hours ago?
17:13:24 <emk> Philippa: liftM /= fmap? Can I go hide in the corner and whimper? ;-)
17:13:30 <Philippa> emk: give or take - there's only so fast there'll be the momentum to get it, I suspect
17:14:00 <Philippa> emk: overloading is your fiend! Happiness is mandatory!
17:14:32 <jyasskin> Philippa: Do you have an example of liftM /= fmap?
17:14:32 <glguy> ?hoogle viewl
17:14:33 <lambdabot> No matches found
17:14:59 <glguy> sjanssen: I lost your FingerTree implementation in the great hpaste loss of a day or two ago
17:15:00 <dons> emk, agreed.
17:15:09 <glguy> sjanssen: I wanted ot show mine and see if you had any improvements I missed
17:15:10 <emk> edwardk: See the latest issue of the Monad Reader: http://www.haskell.org/hawiki/TheMonadReader
17:15:11 <lambdabot> Title: TheMonadReader - The Haskell Wiki
17:15:22 <pejo> emk, what do you mean with that a certain community doesn't face any unsolved research problems?
17:15:25 <shapr> glguy: Heh, I thought hpaste was all about temporary storage? :-)
17:15:27 <dons> "This is simply because minimal LISP is almost certainly simpler than minimal Haskell." ... I think we can implement let/case/apply/lambda in under 100 lines. who's with me?!
17:15:31 <hpaste>  glguy annotated "intersection counting" with "revised" at http://hpaste.org/992#a1
17:15:36 <Philippa> jyasskin: not to hand, but I can construct one sometime I'm more awake
17:15:38 <Eelis> Philippa: i see. still, shouldn't the Functor instance for Q be part of the library?
17:16:00 <Philippa> Eelis: no particular reason for it in practice if you accept the original language/library design
17:16:23 <Eelis> all i really wanted was to use fmap on Q's, really :)
17:16:24 <emk> pejo: Specifically, making Ruby run much faster is a well-understood problem--it just requires a re-implementation of the old Self compiler technology.
17:16:33 <Philippa> dons: you still get a more complex AST, though I grant that case is probably easier than cond and eq separately
17:16:42 <Philippa> don't forget you need a type declaration facility though
17:17:25 <ski> inside 'let'
17:17:29 <hpaste>  sjanssen annotated "intersection counting" with "mine" at http://hpaste.org/992#a2
17:18:00 <ski> (or, hm you meant 'data' ..)
17:18:05 <Philippa> right
17:18:23 <vincenz> why is't it
17:18:24 <Philippa> though you can blag it by forcing constructor applications to be saturated
17:18:29 <ski> lexically scoped types ! :)
17:18:30 <vincenz> class Functor m => Monad m where
17:18:30 <Philippa> and then just working untyped
17:18:31 <vincenz> ?
17:18:41 <vincenz> s/is't/isn't/
17:19:00 <emk> dons: But can you get 11 Haskell interpreters and two compilers in one book? http://www-spi.lip6.fr/~queinnec/WWW/LiSP.html :-)
17:19:01 <lambdabot> Title: C. Queinnec's L.i.S.P book and code
17:19:26 <sorear> glguy: great hpaste loss?
17:19:29 <thorat> emk: most of those are written in Lisp itself
17:19:32 <Philippa> dons: modulo parser I'm certain I *have* implemented that in rather less than 100 lines btw
17:19:40 <Philippa> I've got all but case *and* monadic IO in about that, for example
17:19:47 <glguy> sorear: hpaste stopped announcing and then lost about 30 pastes when I restarted it
17:19:55 <glguy> haven't really figured out why that happened
17:20:06 <sorear> asked on #happs?
17:20:17 <thorat> a minimal haskell in haskell is fairly easy right?
17:20:32 <ndm> thorat, no, its a big task to tackle
17:20:41 <Philippa> thorat: depending on what you think a minimal haskell is it's still pretty big. Per the report? Big.
17:20:42 <glguy> sorear: I asked about it
17:20:45 <emk> thorat: The type system is a huge pain just by itself.
17:20:46 <thorat> ok, haven't read the haskell in haskell paper
17:20:56 <Philippa> emk: I wouldn't go quite that far, THIH is sensible
17:21:01 <thorat> the, typing haskell in haskell that iis
17:21:05 <emk> "Typing Haskell in Haskell" is a great paper.
17:21:06 <thorat> ok
17:21:09 <ndm> thorat, that details how to type check a small desugared core, nothing more
17:21:12 <emk> Quite sensible.
17:21:12 <jcreigh> there's a reason you see "Simple Lisp in Haskell" but not "Simple Haskell in Lisp" blog postings. :)
17:21:21 <ndm> plus it doesn't cover all the haskell' stuff...
17:21:22 <sorear> ndm: it helps if you break it up into good pieces.
17:21:38 <sorear> ndm: I never would have thought I could reasonably implement haskell...
17:21:53 <ndm> sorear, i haven't seen a minimal and principled haskell compiler written yet...
17:21:54 <Philippa> ndm: it's a /sensible/ desugared core though, at least. You can see how to do it. Though I know what you mean
17:22:03 <sorear> ndm: but by sheer accident I have most of a yhc bytecode interpreter and half of a yhc bytecode compiler
17:22:23 <timthelion> with function types, there are a, b, c, d; so when I make a function fun :: a -> b do I have to use symbols from the alphabet. are there a maximum of 26 types a function can deal with?
17:22:25 <ndm> sorear, thats doing the bytecode level though - the haskell -> bytecode translation is a big pain
17:22:27 <emk> Whereas a minimal Lisp is about 20 lines of Lisp, which was really the whole point of McCarthy's paper. It was optimized to make a self-hosting interpreter as short as possible.
17:22:35 <ndm> timthelion: aa is valid too :)
17:23:01 <ndm> timthelion: as is any word which starts with a lower case letter
17:23:02 <_dolio> ?type (undefined :: foo -> bar)
17:23:04 <lambdabot> forall foo bar. foo -> bar
17:23:14 <timthelion> ndm so is it an enumeration that goes to double char, then tripple char just like the collumns of a spreadsheat?
17:23:15 <sorear> @kind forall foo bar. foo -> bar
17:23:17 <lambdabot> *
17:23:29 <sorear> timthelion: no, any VARID
17:23:41 <ndm> timthelion, no, they are just names - thats just what lazy people do
17:23:54 <timthelion> ok, any word. but when it generates the type of the function an with :t it will use that kind of enumeration?
17:23:59 <ndm> although miranda demanded *, **, *** ....
17:24:09 <jcreigh> :t (\x -> x + x)
17:24:10 <_dolio> I'm not sure I'd want to see a function that uses more than 26 parametric types.
17:24:11 <lambdabot> forall a. (Num a) => a -> a
17:24:16 <sorear> timthelion: :t will try to use the same names you did.
17:24:22 <timthelion> ok
17:24:25 <sorear> timthelion: it doesn't usually suceed...
17:24:37 <timthelion> hmm
17:24:50 <Philippa> _dolio: \a b c d e... -> a
17:24:57 <timthelion> that seems like a failing, that it would not suceed, but I guess
17:25:08 <shapr> emk: So, do you want to submit a talk proposal to CUFP?
17:25:19 <jcreigh> hmm, are there (,,,,) functions up to arbitrary N?
17:25:25 <jcreigh> (ghci seems to think so)
17:25:25 <shapr> jcreigh: 42, I think
17:25:36 <timthelion> so with these definitions the arrow really means -> (rest of definition) right?
17:25:40 <jcreigh> shapr: what a handy arbitrary N. :)
17:25:40 <shapr> jcreigh: Or can generate larger sizes dynamically with TH.
17:25:45 <timthelion> in terms of lambda calculus
17:26:07 <shapr> jcreigh: It used to be something small like 12, but that tripped up a bunch of people.
17:26:11 <timthelion> just like $ is parens around the rest of the expression
17:27:12 <sorear> yhc is limited to size 20 tuples
17:27:14 <sjanssen> jcreigh: ghc supports tuples up to 200 something, but there aren't show instances for the higher ones
17:27:26 <vincenz> So why isn't it "class Functor m => Monad m where ..." ??
17:27:34 <sorear> vincenz: humans
17:27:46 <vincenz> heh
17:27:50 <vincenz> just like the bloated Num?
17:27:51 <ndm> i thought GHC had it defined up to 63 or 64
17:27:58 <sorear> vincenz: yes :(
17:28:05 <emk> shapr: Definitely.
17:28:08 <vincenz> sorear: we need class aliases
17:28:40 <sorear> vincenz: I think the Class_system_extension_proposal is a much more elegant design - have you seen it yet?
17:28:49 <vincenz> sorear: I fear not
17:30:04 <timthelion> so how exactly does $ work?  is it mearly replace .*eol with (.*)eol?
17:30:21 <emk> shapr: I'll take a look at the submission guidelines and write something up.
17:30:22 <dolio> ?src ($)
17:30:22 <lambdabot> f $ x = f x
17:30:24 <ndm> @src $
17:30:24 <lambdabot> f $ x = f x
17:30:32 <vincenz> timthelion: pretty much
17:30:38 <jyasskin> :info ($)
17:30:39 <sorear> @quote stereo
17:30:39 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
17:30:40 <vincenz> timthelion: but
17:30:41 <Philippa> I think timthelion means the other $, guys
17:30:51 <Philippa> timthelion: it takes a single expression, with no space
17:30:58 <sorear> jyasskin: nice try :)
17:30:59 <Philippa> so $identifier or $(exp)
17:31:01 <timthelion> what other $
17:31:05 <Philippa> the TH one
17:31:10 <sorear> Philippa: no he's not
17:31:14 <timthelion> the one that gets rid of the need for parens
17:31:18 * jyasskin was trying for the infixr 0 declaration
17:31:23 <Philippa> oh, wait, I didn't read up far enough, my bad
17:31:30 <Philippa> timthelion: forget what I wrote, you don't want to know yet :-)
17:31:42 <dons> emk, hehe. 11 eh/ I think there's 4 compilers in SPJ's 1990 book, implementing FP languages
17:31:57 <timthelion> ok
17:32:20 <timthelion> haskell seems so full that the programer would get bloated
17:32:27 * emk likes having lots and lots of compilers for interesting languages
17:32:46 <ndm> dons, 4 back end implementations, it doesn't cover parsing/typechecking/classes etc. at all
17:32:48 <jyasskin> timthelion: I don't think anyone answered this: (->) is right-associative, so (a->b->c->d) means (a->(b->(c->d))).
17:32:52 <sorear> dons: a bunch of pieces of compilers.  you could probably put everything together to make a couple hundred miranda compilers, but there is no "complete presentations"
17:32:58 <ndm> (in fact it was before type classes!)
17:33:05 <hpaste>  thief_grr pasted "laziness" at http://hpaste.org/993
17:33:08 <emk> timthelion: There's a small core of Haskell that you need to know to get started.
17:33:13 <sorear> ndm: no classes or parsing, but quite definitely type checking
17:33:31 <thorat> dons: you mean the book (1987) or the tutorial (1992)?
17:33:31 <timthelion> jyasskin ok, and so right associative is whitespace dependant
17:33:32 <emk> But you could spend years learning all the amazing things you can do--it's a deep language.
17:33:37 <sorear> ndm: indeed one of the chapters was "Polymorphic type checking\nPhil Wadler"
17:33:39 <vincenz> > let {double x = 2*x; square x = x*x} in map ($ 5) [double, square]
17:33:41 <lambdabot>  [10,25]
17:33:48 <dons> ah, 87, yes.
17:34:00 * sorear was assuming 87
17:34:13 <jyasskin> timthelion: Usually not... although sometimes layout makes it seem like that.
17:34:13 <ndm> sorear, ah, i was thinking of the spjl book
17:34:29 <sorear> ndm: I was talking slpj-book-1987
17:34:29 <ndm> that has most of the details on STG etc
17:34:41 <sorear> ndm: no, this one didn't cover stg atall
17:34:47 <sorear> just regular G
17:34:56 <thorat> then there's also http://research.microsoft.com/copyright/accept.asp?path=/users/simonpj/papers/spineless-tagless-gmachine.ps.gz&pub=34
17:34:58 <lambdabot> http://tinyurl.com/2zkx4c
17:34:59 <emk> Wouldn't it be cool if there were a small, all-inclusive core of Haskell that could be explained in a page or two, with everything syntactic sugar? But I don't think we have the theory to simplify the type system that much yet.
17:35:02 <sorear> I think there were refs to <v,G>
17:35:09 <thief_grr> http://hpaste.org/993#a0  The == in the "prime" definition, when does it stop?
17:35:10 <emk> s/everything/everything else/
17:35:14 <jyasskin> timthelion: For instance, {myFunc :: a -> b ->c \n          d -> e} is eqivalent to myFunc::a->b->c->d->e.
17:35:24 <ndm> emk, you don't need types in a small core of Haskell
17:35:30 <thief_grr> I mean, once "factors" is to generate anything longer than two, will "prime" stop?
17:35:44 <sorear> emk: it exists.  you probably couldn't understand it now, it took me years to learn the notation
17:35:47 <Philippa> if you just want a dynamic core, it's doable with a 5-constructor AST
17:35:55 <thorat> sorry: http://citeseer.ist.psu.edu/peytonjones92implementing.html
17:35:59 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
17:36:09 <Philippa> so long as you don't mind there being the odd little niggle, anyway
17:36:21 <ndm> although apparently GHC is adding back the tags
17:36:22 <sorear> I've read the CoC paper ... dependant types and everything in *half* a page
17:36:37 <emk> Philippa: Where's the fun in a dynamic core? :-)
17:36:45 <Philippa> interesting, I'd've thought the info table pointer effectively doubles as tags anyway?
17:36:49 <emk> sorear: Oooh. Shiny. Where?
17:37:12 <ndm> emk: CoC>
17:37:14 <ndm> ?
17:37:16 <Philippa> Calculus of Constructions
17:37:20 <ndm> sorear, i meant
17:37:21 <emk> Ah, thanks!
17:37:24 <dons> see also, http://research.microsoft.com/Users/simonpj/Papers/pj%2Dlester%2Dbook/
17:37:26 <Philippa> sorear: got an URL for the paper?
17:37:26 <lambdabot> Title: Simon Peyton Jones: book, http://tinyurl.com/zf2d7
17:37:33 <sorear> Philippa: no, googling...
17:37:38 <dons> "four distinct implementations of the Core language"
17:37:52 <timthelion> jyasskin, {x z= z+2}=={x z =z+\n\t2}!={x z= z+\n2} right, so you need the \t
17:38:07 <shapr> emk: Spiffy! I look forward to it!
17:38:13 <Philippa> emk: there's a surprising amount of fun in using a dynamic core as a base for stuff. This is why I have one implemented :-)
17:38:17 <Toxaris> thief_grr: it will stop as soon as possibly
17:38:22 <Philippa> adding monadic IO was nice and trivial, too
17:38:48 <emk> Oooh, certified computation.
17:38:53 <sorear> INRIA uses kO, neat
17:39:22 <jyasskin> timthelion: You probably only need a space, but yes, that's layout. It desugars into a {stuff; more-stuff} syntax, and expressions are terminated at the semicolons.
17:39:24 <jyasskin> @where layout
17:39:24 <lambdabot> I know nothing about layout.
17:39:28 <sorear> http://www.inria.fr/rrrt/rr-0530.html
17:39:29 <hpaste>  sjanssen pasted "d" at http://hpaste.org/994
17:39:29 <lambdabot> Title: RR-0530 : The calculus of constructions
17:39:37 <sorear> emk: ^^
17:39:40 <sjanssen> oops
17:39:42 <thorat> well, regarding Calculus of Constructions, from LtU: http://www.metaocaml.org/concoqtion/
17:39:44 <lambdabot> Title: Concoqtion
17:39:44 <augustss> heh
17:40:11 <emk> sorear: Would CoC be a reasonable system for getting the smallest possible Haskell core (including types)?
17:40:17 <timthelion> hmm, maybe haskell should be taught de-sugared, and then you would learn the sugar after
17:40:45 <ndm> timthelion, learn lisp if that is what you want
17:40:45 <thief_grr> Toxaris: So, when factors has, say 15 as an input, it will generate a list of 1, which won't stop the "prime" function, then move to 3, which will instantly stop the "prime" function?
17:41:04 <sorear> emk: you could desugar haskell to the CoC (augmented with value fix), but CoC can't be typeinfered, so the desugarer would have to do it
17:41:12 <Toxaris> yep
17:41:21 * ndm thinks an untyped core is the way forward
17:41:25 <jyasskin> @where+ layout http://haskell.org/onlinereport/lexemes.html#sect2.7
17:41:25 <lambdabot> Done.
17:41:30 <thief_grr> Toxaris: ok, thanks
17:41:30 <jyasskin> @where layout
17:41:30 <lambdabot> http://haskell.org/onlinereport/lexemes.html#sect2.7
17:41:47 <dons> http://programming.reddit.com/info/1atpx/comments
17:41:48 <lambdabot> Title: Implementing functional languages: a tutorial by Simon Peyton Jones and David Le ...
17:41:55 <jyasskin> timthelion: Other people here probably have a better link for it, but that's the spec.
17:42:14 <emk> sorear: Yeah, I would assume that type inference is a lot cause in any Haskell core < 1 page long. :-)
17:42:17 <Toxaris> thief_grr: it's a sensible implementation of "try all factors" prime test
17:42:29 <Toxaris> thief_grr: wich is not sensible at all, of course.
17:42:35 <timthelion> just a far out theoretical question: would it be possible to make 'safe' haskell moduals that where made up of pure functions. so I could have a haskell modual at www.dictionary.com/dict.hs that would have a pure function definition word = bunch of stuff. and that wolud be compleatly 'safe' and so you could have a webbrowser that used the answers fetched with pure functions provided by webse
17:42:35 <timthelion> rvers
17:42:39 <ndm> Philippa: I can't see private chats at the mo, i'm using a web IRC client...
17:42:49 <dons> :t fmap fix
17:42:51 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
17:44:30 <sorear> timthelion: no :(
17:44:36 <timthelion> sorear why not?
17:44:54 <timthelion> why aren't pure haskell functions safe?
17:45:09 <jyasskin> > unsafePerformIO (putStrLn "Hello World")
17:45:09 <lambdabot>   Not in scope: `unsafePerformIO'
17:45:13 <sorear> stefan@stefans:~/hv/src$ ghc -e "Array.array (0, maxBound::Int) [(10000,'a')]"
17:45:13 <sorear> Segmentation fault
17:45:13 <sorear> stefan@stefans:~/hv/src$
17:45:14 <ndm> timethelion, they may consume a lot of cpu/memory
17:45:24 <jyasskin> I suspect lambdabot has some way around that.
17:45:34 <sorear> timthelion: ghc bugs of the defacto wontfix variety
17:45:39 <jyasskin> > factorial 1000000000
17:45:39 <lambdabot>   Not in scope: `factorial'
17:45:48 <glguy> ?pl a . b (c . d $ e)
17:45:48 <lambdabot> a . b (c (d e))
17:45:51 <ndm> but I think Yhc could be made very safe, quite easily
17:45:53 <dons> well, you can always exhaust memory...
17:45:54 <jyasskin> > product [1..1000000000]
17:45:58 <lambdabot> Terminated
17:46:20 <sorear> > array (0, maxBound :: Int) [(10000, 'a')]  -- runplugs dies with SEGV, but lb itself is safe because of forking
17:46:23 <timthelion> I think there are endless possibuilities with a safe pure language
17:46:23 <dons> or diverge
17:46:38 <sorear> timthelion: like Java? :p
17:46:49 <timthelion> sorear yes
17:46:54 <thief_grr> Toxaris: yes, just trying to understand what it will go through before the function will return
17:47:48 <sorear> ndm: so yhc has a policy of "fix all crash bugs"? :)
17:47:53 <thorat> timthelion: Haskell hasn't solved the halting problem
17:48:16 <timthelion> thorat the halting problem?
17:48:25 <thorat> timthelion: well it's provably insolvable
17:48:33 <jyasskin> thorat: We don't have to. We have timeouts. :)
17:49:08 <timthelion> obviosly as was said before lambdabot evaluates pure functions safely
17:49:25 <timthelion> but at the expence of recursion :(
17:49:38 <timthelion> but javascript has the same problem
17:49:40 <thorat> timthelion: primitive recursion is fine
17:51:07 <timthelion> what is primitive recursion?
17:51:47 <thorat> http://en.wikipedia.org/wiki/Primitive_recursive_function
17:51:48 <lambdabot> Title: Primitive recursive function - Wikipedia, the free encyclopedia
17:51:59 <hpaste>  thief_grr pasted "scope and <-" at http://hpaste.org/995
17:52:27 <Botje> thief_grr: you're correct.
17:52:58 <thief_grr> Botje: ok that was surprising :)
17:53:19 <thief_grr> Botje: i mean, i hadn't noticed that hpaste reports pastes, so i just got an answer before i asked :)
17:53:22 <thief_grr> thanks ;)
17:53:27 <Botje> you're welcome :p
17:53:28 <augustss> thorat: the halting problem is provably solvable.  on the finite machines we have.
17:53:46 <augustss> just not very practical
17:53:51 <thief_grr> would be useful to work though, i dont see a reason to let the "<-" override the already bound variables
17:53:52 <Botje> you could also write it like map snd $ filter ((== k) . fst) ps
17:53:59 <Philippa> not least because my finite machine isn't the same as yours
17:54:13 <thief_grr> Botje: i'm not friends with "$" yet, it's on a later chapter ;)
17:54:13 <Botje> or map snd $ filter (\(k',_)-> k == k') ps
17:54:38 <Botje> thief_grr: it basically means "everything after this $ is one parameter"
17:54:51 <Botje> keeping operator precedences in mind, of course
17:55:08 <thief_grr> aha, noted.
17:55:30 <Toxaris> thief_grr: it's the way of haskell. you have either use or definition of a variable, not both in a single place. this is not prolog
17:55:36 <thorat> augustss: oh, well, it's undecidable right?
17:56:11 <thief_grr> Toxaris: ok, havent played with prolog ever..  it would just seem handy in situations like these
17:56:15 <augustss> thorat: the computers we have are finite state machines.  you can determine if a finite state machine loops
17:56:26 <hpaste>  glguy annotated "intersection counting" with "using foldr" at http://hpaste.org/992#a3
17:56:37 <thorat> ah, ok, "on the finite machines we have"
17:56:42 <thorat> now I get it
17:56:57 <augustss> thorat: but the state space is rather large :)
17:57:01 <Botje> thief_grr: it could cause annoying errors when your list items don't belong to Eq.
17:57:02 <thorat> right
17:57:05 <Botje> i think
17:57:17 <glguy> sjanssen: I'm sure you have plenty of practice doing this, but I posted the basically same solution using foldr instead of foldl'ing a tuple
17:57:31 <Botje> what? fondling tuples?
17:57:53 <glguy> Botje: yeah, that
17:58:06 <glguy> using foldr I don't need to use the tuple
17:58:11 <glguy> was the point :-p
17:58:29 <thief_grr> Botje: that made sense!  thanks
17:58:57 <Botje> hmm
17:59:25 <sorear> augustss: question on dependant types.. \x . if x (3::Int) ('a'::Char).  type is |~|x : Bool . if x Int Char.  but that requires if to be instantiated at *, but if has type |~| x : *. Bool -> x -> x -> x ... and * !: *.  what gives?  (guess: pattern matching must be builtin)
17:59:26 <Botje> I have time to implement one easy version sort in ruby
18:02:35 <augustss> sorear: there are several solutions: have pattern matching built in (like Cayenne), use a separate IF on the type level (also available in Cayenne), have some thing of polykinded functions the can be instantiated to different kinds (Lego), or give up on stratification and smash things together (I can't remember if the If example works like that in Coq or not).
18:03:44 <dons> I cabalised Steffen's chess program,  if anyone is interested, darcs get http://www.cse.unsw.edu.au/~dons/tmp/chess
18:03:44 <lambdabot> Title: Index of /~dons/tmp/chess
18:05:14 <LoganCapaldo> Lazy chess! woo
18:06:23 <sorear> preemptive stmt: please do not confuse Steffen with Stefan, Stefan, Stefan, Stefan, or Stefan.
18:06:38 <dons> :-)
18:06:44 <LoganCapaldo> What about Steffan?
18:06:49 <sorear> I'm still somewhat boggled by the number of Stefans here...
18:07:18 <dons> this Steffen, http://www.haskell.org/pipermail/haskell/2007-March/019247.html
18:07:19 <lambdabot> Title: [Haskell] Haskell Chess
18:07:55 <jcreigh> sjanssen: why is "reveal" needed? it's only used in view in Main.hs, and won't "windows $ W.view" (which calls refresh) take care of moving the right window into place?
18:08:31 <dons> jcreigh: yes, I guess so.
18:08:35 <dons> it seems a useful combinator
18:08:54 <dons> reveal exists as the dual to hide, that's the reason.
18:09:16 <LoganCapaldo> what about revel?
18:09:17 <jcreigh> well, my version doesn't call it at, with appearently no ill effects. maybe I just need to test more.
18:09:33 <dons> hmm...
18:09:33 <jcreigh> LoganCapaldo: xmonad development. I'm hacking xinerama support into xmonad presently.
18:09:39 <dons> you have to have the order right.
18:09:45 <jcreigh> *at all
18:09:45 <dons> i.e. reveal first, then hide
18:09:51 <LoganCapaldo> xinerama
18:09:53 <dons> otherwise you get flicker
18:10:16 <glguy> ?pl eachNode i go = (\(l,_ :< r) -> go (l >< Unmarked <| r) . mappend (snd (measure l))) . second viewl . split ((> Sum i) . fst)
18:10:16 <lambdabot> (line 1, column 15):
18:10:16 <lambdabot> unexpected "="
18:10:16 <lambdabot> expecting variable, "(", operator or end of input
18:10:20 <LoganCapaldo> I revel in reveal in xinerama, and I don't want to hide how I feel
18:10:20 <glguy> oh yeah :(
18:10:59 <LoganCapaldo> @pl (\i go -> (\(l,_ :< r) -> go (l >< Unmarked <| r) . mappend (snd (measure l))) . second viewl . split ((> Sum i) . fst))
18:10:59 <lambdabot> (line 1, column 19):
18:10:59 <lambdabot> unexpected "<"
18:10:59 <lambdabot> expecting natural, identifier, "_" or "("
18:11:11 <jcreigh> dons: oh, maybe I am doing it the wrong way. lemme check...
18:11:21 <LoganCapaldo> I tried
18:13:52 <jcreigh> dons: well, I found a different bug while I was trying to test that.
18:14:48 <xpika> how can i get -fglasgow-exts on runhaskell?
18:15:06 <glguy> add it to the {-# OPTIONS_GHC ?
18:17:20 <xpika> yep
18:17:51 <jcreigh> dons: you're right, it does cause flicker. good catch. I'll fix it.
18:19:21 <xpika> what version did mdo notation come in?
18:21:53 <xpika> dont worry. my runhaskell is 6.6
18:22:09 <thorat> xpika: apparently since 6.0: http://www.cse.ogi.edu/PacSoft/projects/rmb/usage.html
18:22:11 <lambdabot> Title: How to use the mdo-notation in Hugs and GHC
18:32:11 <xpika> how can i get something to loop forever?
18:32:40 <sorear> > let loop _ = loop () in loop ()
18:32:41 <lambdabot>  Exception: <<loop>>
18:32:50 <sorear> bah, ghc is too smart
18:32:51 <LoganCapaldo> fix?
18:32:57 <xpika> inside a monad
18:33:00 <sorear> > last [1..]
18:33:03 <LoganCapaldo> Infinite recursion
18:33:04 <lambdabot> Terminated
18:33:09 <xpika> :)
18:33:23 <dons> xpika: I use the 'forever' function
18:33:25 <sorear> sequence_ . repeat
18:33:27 <Botje> fix (+1)
18:33:29 <LoganCapaldo> something = do_stuff >> something
18:33:30 <dons> forever a = a >> forever a
18:33:32 <sorear> dons: not standard! :(
18:33:37 <xpika> @index forever
18:33:37 <lambdabot> bzzt
18:33:38 <Botje> my infinite loop is shortest!
18:33:39 <sorear> dons: repeatM_ is iirc
18:33:45 <xpika> @hoogle forever
18:33:45 <lambdabot> No matches found
18:33:46 <dons> sorear: try to be helpful... last [1..] is clearly not what he wanted.
18:33:50 <dons> sorear: 'forever' is standard.
18:33:56 <dons> i wrote the patch.
18:34:07 <dons> -- | @'forever' act@ repeats the action infinitely.
18:34:07 <dons> forever     :: (Monad m) => m a -> m ()
18:34:07 <dons> forever a   = a >> forever a
18:34:16 <sorear> dons++ dons++ much thanks!
18:34:31 <Botje> dons: not if forever returns mzero :)
18:34:43 <dons> that's true.
18:34:48 <Botje> (or is my understanding of monads out of whack again?)
18:34:55 <Botje> oh. yay
18:34:58 <roconnor> dons: shouldn't forever return [a] ?
18:34:58 <xpika> which library is forever in?
18:35:11 <roconnor> oh wait, maybe we've had this discussion before.
18:35:15 <LoganCapaldo> forever young
18:35:19 <dons> right. too strict.
18:35:38 <sorear> dons: wouldn't it be nicer to express the fact that it doesn't return at the type level, with a 'b' return type?
18:35:43 <dons> 'forever' is basically the daemon combinator
18:35:55 <LoganCapaldo> hehehhe
18:36:01 <LoganCapaldo> daemon combinator
18:36:02 <glguy> forever ::  Monad m => m a -> m b
18:36:17 <xpika> where is forever?
18:36:24 <glguy> in the patch that dons wrote
18:36:28 <dons> its in ghc head, or you can use the above implementation
18:36:43 <LoganCapaldo> for now, you can just type forever a = a >> forever a
18:36:44 <dons> in Control.Monad
18:36:46 <sorear> forever is *almost* too long to be useful
18:36:52 <sorear> forever = fix.(>>)
18:36:57 <sorear> @ty fix.(>>)
18:37:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
18:37:17 <dons> no one understands fix.(>>) though. ;-)
18:37:25 <glguy> seems that we'd have a repeatM and repeatM_
18:37:35 <glguy> to compliment replicateM and replicateM_
18:37:39 <glguy> as we have in Data.List
18:37:41 <LoganCapaldo> @ty fix.(>>) :: (Monad m) => m a -> m ()
18:37:44 <lambdabot> (Monad m) => m a -> m () :: forall (m :: * -> *) a. (Monad m) => m a -> m ()
18:37:44 <dons> glguy: write something that uses repeatM's result
18:38:14 <sorear> let it be known I am against the fact that integer doesn't include infinity
18:38:24 <dons> sorear: it does if you wait long enough
18:38:24 <sorear> dons: what if the monad is lazy?  like Writer?
18:38:30 <roconnor> > take 5 $ repeatM (return 1)
18:38:31 <lambdabot>   Not in scope: `repeatM'
18:38:33 <LoganCapaldo> integer as in Integer ?
18:38:40 <sorear> dons: ?
18:38:41 <sorear> LoganCapaldo: y
18:38:51 <dons> :t sequence . repeat
18:38:53 <lambdabot>     Ambiguous occurrence `sequence'
18:38:53 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
18:38:57 <dons> bah
18:38:58 <xpika> its not here  http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
18:38:59 <LoganCapaldo> Float and Double do don't they?
18:38:59 <lambdabot> http://tinyurl.com/ykyqfl
18:39:05 <roconnor> > let repeatM = sequence . repeat in take 5 $ repeatM (return 1)
18:39:07 <dons> xpika: its in the *head* only
18:39:20 <sorear> latest is head, i thought?
18:39:23 <roconnor> > let repeatM = Control.Monad.sequence . repeat in take 5 $ repeatM (return 1)
18:39:24 <lambdabot>  Exception: <<loop>>
18:39:36 <roconnor> :/
18:39:47 <dons> sorear: i don't think its regenerated very often
18:39:55 <dons> ?source Control.Monad
18:39:55 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
18:40:01 <LoganCapaldo> > {-# OPTIONS -funroll-loops #-}  let repeatM = Control.Monad.sequence . repeat in take 5 $ repeatM (return 1)
18:40:02 <lambdabot>  Exception: <<loop>>
18:40:20 <roconnor> I don't get why it loops.
18:40:44 <dons> ?src sequence
18:40:45 <lambdabot> sequence ms = foldr k (return []) ms
18:40:45 <lambdabot>     where
18:40:45 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:40:49 <roconnor> oh wait, sequence isn't right
18:40:49 * glguy is glad to know that jyasskin-weekend is experiencing a weekend
18:40:59 <glguy> looks like all's right in the timeline
18:41:05 <roconnor> hmm
18:41:20 <dons> glguy: the time space continuum appears to be in order
18:41:23 <dons> phew!
18:41:26 <roconnor> @type let repeatM = Control.Monad.sequence . repeat in take 5 $ repeatM (return 1)
18:41:28 <lambdabot> forall t. (Num t) => [[t]]
18:41:44 <dons> heh
18:41:48 <sorear> > let repeatM = Control.Monad.sequence . repeat in take 5 $ flip evalState 0 $ repeatM $ do { x <- get ; put (x+1); return x }
18:41:49 <lambdabot>  [0,1,2,3,4]
18:41:50 <roconnor> @type sequence . repeat
18:41:52 <sorear> dons: ^^
18:41:52 <lambdabot>     Ambiguous occurrence `sequence'
18:41:52 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
18:41:57 <dons> sorear: good :-)
18:42:03 <roconnor> @type Control.Monad.sequence . repeat
18:42:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
18:42:18 <sorear> not all monads are strict!
18:42:23 <LoganCapaldo> > fix (
18:42:24 <lambdabot>  Parse error
18:42:31 <sorear> you need a )
18:42:44 <LoganCapaldo> I slipped
18:42:47 <emk> dons: I like Wadler's first two links on writing. And he does write some lovely papers, so O
18:43:03 <emk> I'm inclined to pay attention carefully to his advice. -)
18:43:35 <LoganCapaldo> > fix ("Pete and Repeat went out on the lake in a boat. Pete fell out, who was left in the boat? "++)
18:43:36 <lambdabot>  "Pete and Repeat went out on the lake in a boat. Pete fell out, who was left...
18:43:39 <glguy> > let repeatM m = sequence (repeat m) in runIdentity (repeatM (return ()))
18:43:56 <dons> emk, me too!
18:44:08 <dons> he is the author-ity !
18:44:16 <emk> *groan*
18:44:22 <dons> hehe
18:44:22 <Philippa> emk: his papers might be good, but I didn't think they were worthy of a big O? :-)
18:44:56 <LoganCapaldo> what about a theta?
18:45:08 <emk> Philippa: My fingers are starting to fumble. No more technical writing for tonight!
18:45:40 <chessguy> emk: it's not even football season yet!
18:46:42 <Philippa> emk: well not if it leaves you typing one-handed, anyway ;-)
18:47:15 <xpika_> what is the *head*?
18:47:58 <LoganCapaldo> Its the current in development version of a piece of software
18:48:57 <dons> http://programming.reddit.com/info/1au38/comments
18:48:59 <lambdabot> Title: Wadler&#39;s three ways to improve your technical writing (reddit.com)
18:49:09 <dons> if not us. who? the javascript guys? :-)
18:49:27 <emk> Philippa: I'm so not going there.
18:49:33 <ailndx> dons: so do i need hs-plugins to include eval/runplugs in my app?
18:49:34 <xpika_> who here uses the *head*?
18:49:51 <dons> me :-)
18:49:54 <dons> for research purposes
18:50:02 <dons> xpika_: just use a local binding for forver
18:50:04 <dons> ailndx: yes.
18:50:22 <ailndx> dons: ok then i might as well forget about is, hs-plugins and win dont like eachother
18:50:47 <dons> emk, you interested in mentoring a SoC Haskell.org project?
18:51:04 <dons> sjanssen: or you?
18:51:18 <emk> dons: Do you have some nice small projects picked out already?
18:51:45 <dons> not yet. at the moment we just collect potential mentors, and wait for students to apply
18:51:55 <dons> then the mentors pick which ones they'd like to help with
18:52:04 <dons> and everyone who applies as a mentor gets a tshirt :-)
18:52:13 <dons> ?where soc
18:52:13 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
18:52:16 <Philippa> I thought it was only everyone who's accepted?
18:52:18 <dons> the basic list of projects is there
18:52:23 <dons> Philippa: apparently not?
18:53:06 <ailndx> if you do it for a tshirt you must be desperate
18:53:28 <dons> that's very true. you need to have some experience managing haskell projects, and connections to the community, ideally
18:53:29 <emk> dons: I've learned not to recommend undergraduate thesis ideas ("Making macros work right in infix languages" is _not_ a feasible project).
18:54:10 <dons> hehe
18:54:18 <emk> dons: So I'm hoping that the students bring their own project ideas. :-)
18:54:24 <dons> i've had "write an extensible window manager in haskell" as a thesis project idea open for 3 years now
18:54:34 <dons> no takers :/
18:54:40 <dons> though lots want to work on Frag. which is nice.
18:56:46 <bd_> Do you think this would be an appropriately sized project for SoC? http://hackage.haskell.org/trac/summer-of-code/ticket/1118
18:56:48 <lambdabot> Title: #1118 (Debian package autobuilder for hackage packages) - Haskell.org Google Sum ...
18:57:21 <dons> that, or other hackage / cabal work, would be. yes.
18:57:59 <sorear> bd_: oh, that's been on my todo list for months
18:58:01 <bd_> *nod* I remember someone (sorear?) mentioning wanting to see something like that a few months back...
18:58:05 <bd_> heh
18:58:12 <sorear> bd_: not sure if I'll actually ever do it though
18:58:50 <bd_> Hence why it's good for a SoC project, right? :)
18:58:51 <Igloo> bd_: If you're interested in working on it then you might find it useful to start from http://urchin.earth.li/pipermail/debian-haskell/2006-October/000261.html
18:58:53 <lambdabot> Title: [Debian-haskell] GHC 6.6, http://tinyurl.com/2cq9ng
18:58:55 <emk> bd_: That looks like a reasonably-sized project for an ambitious student.
19:00:26 <bd_> Igloo: Thanks, I'll keep it in mind. Doesn't look particularly scalable as-is but I'm sure it'll be a useful starting point. Of course, building the source packages would need to come first...
19:00:40 <sorear> bd_: you Bryan Donlan?
19:00:46 <bd_> Yeah
19:00:55 <Igloo> bd_: Sure, it's just a quick hack
19:01:08 <thorat> bd_: has the autobuilder approach been successful for other languages in Debian?
19:01:25 <roconnor> > fix ("It was a dark and stormy night.  And the captain shouted, ‘Jack!  Tell us a story!’  And this is the story that Jack told: \")
19:01:25 <lambdabot>  Improperly terminated string
19:01:27 <bd_> I'm not sure it's been tried.
19:01:42 <roconnor>  fix ("It was a dark and stormy night.  And the captain shouted, ‘Jack!  Tell us a story!’  And this is the story that Jack told: \""++)
19:01:46 <sorear> we probably won't make it into debian automagically, but having a aptage.haskell.org/debian would still be nice
19:01:49 <roconnor> > fix ("It was a dark and stormy night.  And the captain shouted, ‘Jack!  Tell us a story!’  And this is the story that Jack told: \""++)
19:01:50 <lambdabot>  "It was a dark and stormy night.  And the captain shouted, \8216Jack!  Tell ...
19:02:37 <bd_> sorear: Right, I don't expect it to upload into debian automatically - debian packages, without exception, are vetted by actual humans, but I do want the generated packages to be easily polishable to an uploadable state
19:03:40 <bd_> That said I might be out for a week or two in june for surgery :/
19:03:42 <emk> bd_: With a few extra fields in the Cabal format, it might be possible to reduce human intervention to sanity-checking the final builds.
19:03:47 <sorear> bd_: you might consider creating a patch database mechanism, so the debian maintainer for apt-hackage can easily keep polished versions of everything and make uploadable foo
19:04:16 <bd_> emk: I'm not sure additional fields would be needed - we have dependency and copyright information, so I can generate the debian/control fields from that.
19:04:29 <bd_> emk: of course, any dependencies on C libraries will require intervention
19:04:35 <xpika_> why are infix operators easier to read?
19:04:46 <emk> bd_: Ironically, you might only need a Debian-compatible package name. :-)
19:04:47 <sorear> xpika_: tradition for a start
19:05:09 <bd_> emk: heh, true. s/[^a-zA-Z0-9-]//g? :)
19:05:33 <thorat> xpika_: natural language is infix; except german
19:05:36 <emk> xpika_: And some syntactic variation makes it easier to tell things apart.
19:06:12 <bd_> sorear: What do you mean by a patch database? My general plan was to have it autogenerate packages by default, but to allow  overrides in certain fields (eg, package name, dependencies, etc), or to replace it entirely with a manually-maintained package.
19:06:12 <sorear> for aptage (the no-upload version I was imagining) I planned to just have libghc6-aptage-foo
19:06:31 <sorear> bd_: you are familiar with the .diff.gz system?
19:06:32 <dpiponi> thorat: Actually you get natual languages with all kinds of orders: SVO VSO SOV and so on (S=subject, V=ber, O=object)
19:06:43 <bd_> sorear: Yes...?
19:06:44 <sorear> bd_: I mean a Map PackageName Patch
19:06:55 <thorat> dpiponi: I was oversimplifying, but thanks
19:07:01 <Philippa> and then you get latin?
19:07:01 <thorat> ;)
19:07:08 <bd_> sorear: A deb-src archive would include that functionality...?
19:07:15 <sorear> bd_: so when the global maint pulls a package from hackage, it keeps patches
19:07:37 <sorear> bd_: and so you only need to maintain the changes, not re-polish each version from scratch
19:07:42 <bd_> sorear: Do you mean debianizing patches?
19:07:56 <sorear> yes, debianization patches
19:07:58 <emk> dpiponi: But no more than about 2 layers of center recursion (right recursion seems to be almost unbounded, amusingly).
19:08:13 <sorear> (debianizing could mean debianizing the patches themselves...)
19:08:39 <dpiponi> emk: yup. Now where did I just read a discussion about that? Must have been on reddit.
19:08:56 <emk> I think I saw something on Language Log...
19:09:06 <bd_> sorear: I think there may be some confusion about what the automation would do... initially I was thinking of using a rather standardized template - so the debian maintainer wouldn't need to re-pull for a new version, just update the upstream tarball. If it turns out to be widely useful, though, I have no problems with adding a system to add in dpatch patches or something.
19:09:17 <thorat> but infix seems to be preferred in natural language...
19:10:21 <bd_> sorear:
19:10:22 <bd_> er
19:10:38 <bd_> sorear: Hopefully, though, good cabal packages shouldn't need much debianization ;)
19:10:41 <sorear> bd_: I don't think we want to use dpatch as is, too complicated for non-DDs like me to understand
19:11:33 <bd_> sorear: Drop the patch in debian/patches, add it to debian/patches/00list ;) I personally mostly like it because it has a convenient patch editor utility.
19:12:43 <sorear> bd_: I'm thinking aptage would take the form of a set of debian/foo files with support utilities (similar pattern to dh_make et al), which would read information from any cabal files it finds, and a debian/aptagerc file with overrides.  the overrides should be done somehow that when you pull a new version, you can ekep the old overrides, ...
19:13:19 <conal> dons: i got the latest hs-plugins to compile.  has AltData.Typeable gone away?
19:13:53 <thorat> bd_: sorear: how does debian interact with the ghc pkg tools?
19:14:13 <sorear> thorat: look at ./Setup.hs register --gen-script
19:14:36 <sorear> thorat: beyond that, ?, I'm only a debian-user :(
19:14:49 <sorear> debian-lover, *not* debian-developer
19:14:55 <bd_> thorat: there's a dh_haskell tool which helps a lot. However, one must generate the debian/control and debian/rules manually currently.
19:15:19 <thorat> ok, tanks
19:15:33 <bd_> sorear: I was thinking more of a system which can generate a standalone debian/rules and debian/control, but yeah, that could work. However, it must not alter debian/control except on manual control, due to debian policy.
19:15:33 <sorear> conal: hs-plugins darcs + ghc-6.6  uses regular Data.Typeable
19:16:14 <bd_> Ideally it should generate a debian/rules which is independent of aptage at build-time, to make it easier to use in debian (until haskell-package or whatever goes in)
19:16:14 <conal> sorear: glad to hear it, thanks.  did the old problem with hs-plugins + Data.Typeable get fixed somehow?
19:16:35 <sorear> conal: yes, the tweaks in AltData were merged into base
19:16:45 <conal> sorear: wonderful.  thanks.
19:17:57 <dons> conal: it has.
19:18:13 <dons> sorear: not quite. the proper fix was implemented.
19:18:25 <dons> so the hack in AltData could be abandoned
19:18:40 <sorear> bd_: in the long term I think using separate utilities is better for upgradability.  (I agree with you on the shortterm solution)
19:19:33 <conal> dons: groovy.  i had to tweak hs-plugins/configure to get it to build on WinXP.
19:20:56 <conal> dons: any idea why i'd get this result from hs-plugins:
19:20:57 <conal> c:\Haskell\packages\Haskell\plugins-1.0\ghc-6.6/HSplugins-1.0.o: unknown symbol `_memcmp'
19:20:57 <conal> Eros.exe: unloadObj: can't find `C:\cygwin\usr\local\lib/wxcore.o' to unload
19:20:57 <conal> Eros.exe: user error (unloadObj: failed)
19:21:26 <dons> no. but i've heard rumours of it.
19:21:35 <dons> oh. actually. yes. the package loading isn't working in 6.6 yet.
19:21:49 <dons> Lemmih mentioned that it symbols in external packages won't work (at all?)
19:21:53 <dons> Lemmih: around?
19:23:16 <glguy> he said he'd be back at 11am (GMT-5)
19:23:58 <conal> dons: urk.  thanks.
19:24:18 <glguy> > mapM return [()]
19:24:19 <dons> hmm. i'll see if I can find out more details
19:25:08 <glguy> dons: is there any technical reason why the Control.Monad and Control.Monad.Writer namespaces have been colliding?
19:25:15 <glguy> (for so long)
19:25:15 <sorear> glguy: they aren't
19:25:24 <glguy> oh, what is it
19:25:31 <sorear> glguy: it's Control.Monad and Data.Traversable
19:25:37 <glguy> oh
19:25:38 <sorear> glguy: but the message is truncated
19:25:59 <glguy> is Data.Traversable broken?
19:26:01 <sorear> glguy: and because dons has been too lazy to add import Prelude hiding(mapM) etc
19:26:05 <glguy> or is this the expected behavior?
19:26:08 <sorear> glguy: (to Pristine.hs)
19:26:20 <sorear> glguy: no, Data.Traversable is a proper generalization
19:26:28 <conal> dons: thanks.  i'm not aware of using an external package in the generated code.  i don't know why wxWidgets (wxcore) is in that message.
19:27:12 * sorear wonders when conal first became aware of the Extremely Reliable Operating System
19:28:06 * vincenz pokes sorear 
19:28:15 <dons> sorear: Eros is a successor to Pan. makes sense to me.
19:28:16 <conal> dons: oh, never mind.  i do see where wxWidgets comes in.  when i stop using any module imports in unsafeEval_, i get this message: c:/ghc/ghc-6.6/HSbase.o: unknown symbol `_free'
19:28:25 <dons> ah that one.
19:28:34 <conal> familiar?
19:28:43 <dons> Igloo was looking into that. yes, there's been a few reports on windows of this.
19:28:49 <glguy> CapROS is the successor to EROS?
19:28:51 <dons> something we're not doing right, that ghci is doing.
19:29:15 <Excedrin> how can I express: for (int i=0;i<10;i++) for (int j=i+1;j<11;j++) for (int k=j+1;k<12;k++)... in Haskell and achieve something similar to C speed?
19:30:01 <glguy> [undefined | i <- [0..9], j <- [i+1..10], k <- [j+1..11]]
19:30:03 <glguy> so not that?
19:30:04 <vincenz> > [(i,j,k) | i <- [0..10], j <- [i..11], k <- [j..12])
19:30:04 <lambdabot>  Parse error
19:30:09 <oren> Hi guys, any idea why my Haskell programs work fine on small inputs but die ("Killed") with exit status 137 when given large files? The program runs Parsec on the input, I tried to sprinkle the parser with $! to no avail...
19:30:10 <sorear> > )
19:30:11 <lambdabot>  Parse error
19:30:18 <vincenz> > [(i,j,k) | i <- [0..10], j <- [i+1..11], k <- [j+1..12])]
19:30:18 <lambdabot>  Parse error
19:30:21 <vincenz> grr
19:30:23 <sorear> parse error, and just as fast as the C parse error
19:30:24 <vincenz> > [(i,j,k) | i <- [0..10], j <- [i+1..11], k <- [j+1..12]]
19:30:25 <lambdabot>  [(0,1,2),(0,1,3),(0,1,4),(0,1,5),(0,1,6),(0,1,7),(0,1,8),(0,1,9),(0,1,10),(0...
19:30:36 <sorear> > 137 - 128
19:30:37 <lambdabot>  9
19:30:38 <Excedrin> glguy: the "similar to C speed" part excludes that solution
19:30:43 <sorear> ouch, 9
19:30:45 <vincenz> sorear: that was as fast as C!
19:30:48 <sorear> oren: dmesg
19:31:00 <sorear> oren: look for oom_killer get_free_page etc
19:31:54 <oren> I see "out of memory". The program did just breach the 1GB RAM, but I have 1.5GB and virtual memory...
19:31:58 <sorear> oren: are you using X/emacs/etc?
19:32:06 <oren> X
19:32:12 <oren> VI, not emacs :-)
19:32:26 <sorear> oren: so you DID trip the oom killer (and didn't notice because it only shows up on the console)
19:33:05 <oren> I guess what I'm asking is why Parsec is taking so much memory. I expected it to be able to start feeding results to the program before it was completely done
19:33:07 <sorear> oren: naive haskell reduction is big and slow ... try recompiling with -prof, and rerunning (on smaller inputs) with +RTX -hp
19:33:26 <oren> Ok, will try.
19:33:31 <dons> oren: yeah, you'll need to identify whatever nasty space leak is happening
19:33:33 <sorear> oren: no, since it has to return Left if there are any parse errors
19:33:36 <dons> you are using -O ?
19:33:41 <dons> how big is the input file?
19:33:53 <sorear> oren: so it therefore has to parse the entire file before parse evaluates to Right
19:34:00 <oren> OUCH!
19:34:24 <Excedrin> sorear: there's no C parse error?
19:34:25 <sorear> oren: if you want to parse a big file lazily, you'll need to give up parsec's mandatory error detection ...
19:34:30 <bd_> sorear: [late]I do expect the actual packaging-generation scripts to be seperable from the automatic-downloading-updating-etc system, at least.
19:34:31 <oren> Makes sense now that you mention it, but... this is a 7MB input file... and I'm parsing it to bits...
19:34:41 <sorear> oren: Bits == bool?
19:34:43 <dons> oren: hmm. what format is the file in?
19:34:49 <oren> Any way to turn this off without hacking into Parsec sources?
19:35:02 <oren> No, bits as in Unicode characters
19:35:04 <sorear> oren: remember [Bool] takes 12 bytes per bit, under ideal conditions
19:35:18 <sorear> oren: [Char] takes 12|20 bytes/character
19:35:19 <Philippa> sorear: in fairness, you could hypothetically go an awful long way towards that with the right top-level grammar
19:35:21 <dons> oren: any chance you can just use bytestrings instead of String ?
19:35:27 <oren> Basically I'm doing very complex lexical analysis
19:35:35 <TSC> If I have a Handle to a network connection, is there a non-blocking way to tell whether the other end of the connection has been closed?
19:35:39 <Philippa> something of the form "many foo" without an explicit eof check afterwards, say
19:35:46 <oren> The problem is that Parsec expects list of tokens as input (iun my case, list of Char)
19:35:54 <sorear> Philippa: but how will parsec know to return Right?
19:36:00 <dons> ah. you're using parsec as a lexer?
19:36:03 <sorear> Philippa: error detection prevents laziness
19:36:05 <oren> Yes
19:36:18 <sorear> oren: try using alex, that's lazier...
19:36:26 <oren> Is there a way to disable error detection in Parsec?
19:36:37 <dons> hmm. given the input is more than 1M, I'd consider either writing it over bytestrings, or using alex
19:37:07 <sorear> oren: alex is a lexer generator, like C f?lex.  @where alex for location
19:37:18 <oren> Can't use alex, I think - I'm using the full recursive-descent power of Parsec.
19:37:26 <Philippa> sorear: you can deduce that it's returning Right from the top-level being many. It's impossible for many to fail
19:37:36 <oren> It is a context-free language (just barely)
19:37:52 <dons> oren, can you write your own recursive descent lexer/parser on bytestrings?
19:37:58 <dons> hmm. or maybe the stub parsec-bytestring
19:38:21 <Philippa> however, that's hypothetical in that you'd probably have to make maybe a primitive
19:38:21 <oren> I suppose I could, the reason I did this in Haskell was that it was so easy to do (basically copy the BNF)
19:38:22 <dons> ?where http://hackage.haskell.org/~paolo/darcs/ByteStringParser
19:38:22 <lambdabot> I know nothing about http://hackage.haskell.org/~paolo/darcs/bytestringparser.
19:38:57 <dons> oren: yeah, 7M is a bit stressful for String-based programs though (although you should be able to greatly improve parsec's performance here). I'd use bytestrings though. and work from there.
19:39:08 <oren> Or I could copy the Parsec sources and hack them to avoid the error-detection
19:39:14 <dons> yeah
19:39:26 <dons> still, you need to get a way from Char/ String
19:39:31 <sorear> Philippa: if many (string "aa") is applied to an odd-length string?
19:39:36 <sorear> bah, lag
19:39:36 <dons> the above bytestringparser might be of more use
19:39:49 <Philippa> sorear: yeah. You're confusing many and many1 :-)
19:40:23 <sorear> Philippa: nah, I'm expressing my naivete - of course a parser has to consume all the input!
19:40:40 <glguy> parsec doesn't mind not consuming all input
19:40:49 <glguy> unless you end it with a oef
19:40:50 <glguy> eof
19:40:58 <Philippa> sorear: heh. Yeah, there's a reason I stated "and doesn't look for eof" :-)
19:41:24 <Philippa> glguy: yup, you sure remember having forgotten to require that the first time you get a different error message to the one you expected
19:41:35 <Philippa> it so happens that many's a primitive, too
19:41:46 <Philippa> or at least, it's in the primitives module
19:41:54 <Philippa> anyone want to fire up ghci and test behaviour?
19:41:57 <glguy> Philippa: when I first started readind your statement with "you" in it
19:42:06 <glguy> I took it as "direct" you
19:42:10 <glguy> and not "generalized"
19:42:13 <oren> Ok, I'll try to move away from [Char] somehow. Either hack Parsec or try ByteStringParser or something...
19:42:17 <oren> Thanks!
19:42:18 <glguy> started wondering what I did
19:42:55 <Philippa> mmm. Parsing != understanding, news at 11? :-)
19:43:41 <glguy> naw, I don't want the news, its too much about entertainment ;)
19:44:21 <cdsmith> Anyone up for a dumb question?
19:44:28 <glguy> too late!
19:45:19 <Philippa> I'm only really up for my laundry now - it's late her
19:45:20 <Philippa> *here
19:46:00 <cdsmith> ok, ne'er mind then.
19:46:07 <glguy> I'm let down that we weren't immediately ?remembered for our cleverness just now
19:46:11 <emk> oren: If you've got 7MB of data, you definitely want to stay away from String and anything which uses it. My horror story: http://www.randomhacks.net/articles/2007/01/22/high-performance-haskell
19:46:12 <glguy> cdsmith: you should just ask
19:46:18 <lambdabot> Title: High-Performance Haskell, http://tinyurl.com/ywg98e
19:46:25 <cdsmith> Okay, I have:
19:47:42 <cdsmith> data LexAnalyzerState = ...
19:47:42 <cdsmith> type Lexer m = StateT LexAnalyzerState m
19:47:42 <cdsmith> data ParserState = ...
19:47:42 <cdsmith> type Parser m a = StateT ParserState (Lexer m) a
19:47:47 <dons> oren: i'd consider writing the parser by hand, using bytestring-bsaed list functions. if its a bit too complex for that, hack on the bytestring parsec
19:47:57 <cdsmith> Is that sensible?  I can't make this work.
19:47:57 <glguy> !paste
19:47:57 <hpaste> Haskell paste bin: http://hpaste.org/
19:48:24 <sorear> cdsmith: it's quite reasonable BUT
19:48:33 <cdsmith>     Inferred type is less polymorphic than expected
19:48:33 <cdsmith>       Quantified type variable `m' is mentioned in the environment:
19:48:33 <cdsmith>  parseSession :: StateT ParserState
19:48:33 <cdsmith>           (StateT LexAnalyzerState m)
19:48:33 <cdsmith>           ParseTree
19:48:34 <cdsmith>    (bound at SyntaxAnalyzer.hs:22:0)
19:48:35 <sorear> cdsmith: don't hand-hack those things
19:48:36 <cdsmith>     When trying to generalise the type inferred for `runParser'
19:48:38 <cdsmith>       Signature type:     forall (m :: * -> *).
19:48:39 <oren> emk, don: Makes perfect sense. I need to use the same productions, but in a parser framework that uses ByteString or some such and that is fully lazy (at least, incremental)
19:48:40 <cdsmith>      (Monad m) =>
19:48:41 <sorear> cdsmith: STOP!
19:48:42 <cdsmith>      String -> Lexer m ParseTree
19:48:44 <cdsmith>       Type to generalise: String -> Lexer m ParseTree
19:48:46 <cdsmith>     In the type signature for `runParser'
19:48:48 <cdsmith>     When generalising the type(s) for `runParser'
19:48:50 --- mode: ChanServ set +o glguy
19:48:52 --- kick: cdsmith was kicked by glguy (glguy)
19:48:53 <sorear> cdsmith: PLEASE DO NOT PASTE INTO YOUR IRC WINDOW
19:48:56 <dons> oren: or just more efficient.
19:48:59 --- mode: glguy set -o glguy
19:49:17 <cdsmith> sorear: sorry!
19:49:32 <sorear> cdsmith: it's nearly impossible to read it when you do that
19:49:38 <dons> cdsmith: put your code on hpaste.org
19:49:39 <Igloo> dons: I'm not actually looking into the _free thing
19:49:42 <oren> Paolo's parser still makes a distinction on errors, it wouldn't be "streaming" either
19:49:53 <sorear> cdsmith: those of use with broken IRC clients that lack scrollback mind it just a bit more...
19:49:58 <dons> oren: yeah, you should be able to jsut customise it for your needs though?
19:50:04 <dons> Igloo: ah ok.
19:50:14 <sorear> cdsmith: anyway, don't feel bad, every other newbie makes that mistake (once)
19:50:16 <oren> But I see how one can hack the parser to do what I want. In my case I return a list of tokens (rather than a tree) so error could be just a token at the end. That would be "streaming"
19:50:40 <oren> The nice thing it is so easy to write your own parser frameworks in Haskell :-)
19:50:49 <dons> yeah :-)
19:50:53 <sorear> cdsmith: I'd suggest using Parsec (or alex/happy, if you're of the lex/yacc persuation)
19:51:03 <dons> if you want performance help with the bytestring parser, just ping me, oren.
19:51:49 <oren> dons: Thanks! Let me play with it a bit first. I like a challange :-)
19:52:11 <emk> (dons is amazingly good at Haskell optimization. And he helps so many people I'm beginning to suspect he's a benevolent collective.)
19:53:45 <hpaste>  cdsmith pasted "test code that generates error" at http://hpaste.org/996
19:54:06 <cdsmith> I'm trying to understand that error message.  The context is irrelevant.
19:54:07 <Cale> emk: You mentioned in your blog post that ByteString can get things within 1/2 the speed of C. I think it's worth pointing out that it's also sometimes getting twice the speed of C. :)
19:54:29 <dons> emk, heh. it helps having written the library, and spent several months looking at how to optimise it :-)
19:54:31 <cdsmith> (As in, I'm not REALLY trying to build a parser, so I know Parsec exists, but that doesn't help me much)
19:54:39 <emk> Cale: This is true. If you have a good benchmark link, feel free to add it to the comment thread.
19:54:53 <dons> ah yes, that post was before I rewrote the shootout results
19:54:58 <dons> to use bytestrings ..
19:55:08 <Cale> sum-file is pretty impressive :)
19:55:20 <dons> yes, i wrote a faster version yesterday, in fact:
19:55:24 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
19:55:26 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
19:55:42 <Cale> hahaha
19:55:45 <dons> go bytestrings1
19:57:20 <dons> Cale: 3.7x C :-)
19:57:33 <Cale> yeah
19:57:57 * dons cheers for ghc!
19:58:06 * sorear cheers for gcc!
19:58:14 <dons> its nice, the sum-file benchmark is basically a lexer problem
19:58:15 <Cale> I find it amazing that C is getting pwned by functional languages at such a simple task.
19:58:45 <Cale> (of course, it's not really that simple, which is why)
19:58:54 <dons> the lazy programs, too :-)
19:58:59 <Cale> yeah
19:59:34 <Cale> cdsmith: where's the error?
19:59:41 <dons> the new list lib we're hacking on should improve main = print . sum . map read . lines =<< getContents too
19:59:44 <dons> since
19:59:48 <dons> sum / map and lines should fuse.
19:59:48 <Cale> cdsmith: could you annotate your paste with it?
19:59:55 <dons> which they don't under build/foldr
20:00:01 <Cale> yeah, that'd be nice
20:00:13 <Cale> That program is currently right at the bottom of the results.
20:00:14 <desp> what does the "as" keyword do?
20:00:22 <Cale> It would be nice if it were at least somewhere in the middle
20:00:26 <hpaste>  cdsmith annotated "test code that generates error" with "(no title)" at http://hpaste.org/996#a1
20:00:37 <Cale> desp: renames an imported module
20:00:46 <desp> thanks
20:00:48 <sorear> Cale: C would do MUCH better were it not for shootout caprice
20:00:59 <emk> A new revision of the "Programming Erlang" beta is out (nice book, BTW). There's a chapter on memory- and disk-based tuple stores (Ets and Dets). I wonder if something like that would make it easier to work with large data sets in Haskell?
20:01:08 <cdsmith> Cale: done
20:01:18 <edwardk> have any of the haskell database projects tried using template haskell to verify table and field names at compile time,  build record types, define the types used in joins, etc?
20:01:19 <dons> emk, hmm. thanks for the reference.
20:01:34 <dons> sorear: so would haskell :-)
20:02:05 <hpaste>  Excedrin pasted "dumb iteration" at http://hpaste.org/997
20:02:29 <Excedrin> I know the Haskell code there isn't equivalent, help me improve it
20:04:34 <Cale> cdsmith: It's complaining about the type signature for runParser not being fulfilled by its implementation.
20:04:40 <Cale> hmm
20:05:17 <LoganCapaldo> edwardk: I think HaskellDB does something close to that
20:05:17 <Cale> The inferred type for runParser, if you delete the type signature, and turn the monomorphism restriction off, is runParser :: (Monad t1, Monad (StateT ParserState t1)) => t -> t1 ()
20:05:33 <Cale> oh, it's all the MR's fault
20:05:38 <cdsmith> MR?
20:05:50 <glguy> monomorphism restriction
20:05:55 <LoganCapaldo> monomorphism restricition
20:06:02 <LoganCapaldo> except with less is
20:06:09 <Cale> Monomorphism restriction. Pattern-bound variables are required to be monomorphic unless their type signatures say otherwise.
20:06:21 <edwardk> logan will look again, thought there was more runtime stuff there
20:06:22 <Cale> So it'll default things stupidly sometimes.
20:06:30 <glguy> ?quote stereo
20:06:30 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
20:06:33 <emk> Excedrin: Hmm. I'm trying figure out how to get rid of the lists.
20:06:35 <fantasma> Hi.
20:06:52 <Cale> -fno-monomorphism-restriction will fix your program. also, adding  parseSession :: (Monad m) => m ()
20:07:00 <narain> hi fantasma
20:07:10 <cdsmith> Oh, okay.
20:07:21 <glguy> the MR is trying to protect you from yourself
20:07:48 <Excedrin> emk: it should use the state monad I suppose
20:07:49 <cdsmith> Cool!  The type signature for parseSession is easy enough.
20:07:51 <emk> Excedrin: You're probably paying some overhead for consing the lists.
20:08:07 <LoganCapaldo> it is? I had this vague idea that the MR existed cause it was easier to implement Haskell that way
20:08:11 <cdsmith> I still don't really understand what monomorphism is, but at least it seems I wasn't completely confused.
20:08:11 <emk> Excedrin: Maybe even a "do n times" function would help speed it up.
20:08:38 <glguy> LoganCapaldo: that you can override it with a type signature suggests that it isn't a techincal issue
20:08:39 <Cale> cdsmith: What the monomorphism restriction does is to make sure that whenever you have something like  x = ..., x will never have to be evaluated more than once.
20:09:06 <cdsmith> Umm... hmm.
20:09:08 <Cale> cdsmith: Polymorphism screws that up, by allowing the definition to apply at more than one type.
20:09:20 <LoganCapaldo> well it was vague
20:09:22 <glguy> because it has a seemingly hidden parameter, the instance
20:09:26 <Cale> right
20:09:36 <LoganCapaldo> (the idea)
20:09:44 <LoganCapaldo> that I had
20:09:52 <Cale> When the typeclasses are desugared, that Monad m constraint turns into a function parameter
20:09:56 <glguy> when you write the type signature yourself, you are (in effect) admitting that it has this parameter
20:10:19 <cdsmith> Okay, I think I see a little bit of what's going on.
20:10:22 <narain> typeclasses are sugar?
20:10:33 <emk> Excedrin: I'm thinking about something with import Data.List and fold'. (Notice the ' symbol, it's critical here--you want strictness.)
20:10:34 <glguy> m is just a dictionary
20:10:37 <Cale> narain: at some level, yes
20:10:42 <sorear> at the source level - no, they are required for typechecking
20:10:51 <sorear> at core - yes, they're just tuples
20:11:04 <sorear> emk: foldl'
20:11:11 <sorear> emk: don't forget the l
20:11:13 <Cale> I think the MR should be something which is explicitly turned on by a compiler switch.
20:11:14 <emk> sorear: Thanks!
20:12:07 <cdsmith> So if parseSession took parameters, then this wouldn't have happened?
20:12:15 <Cale> right
20:12:26 <emk> Excedrin: Hmm. I think I see how to make that go faster, but it requires more brain cells than I have tonight.
20:12:26 <sorear> Cale: I actually think it should take the form of -fwarn-unobvious-polymorphism
20:12:45 <sorear> Cale: er, -Wdangerous-polymorphism
20:12:54 <cdsmith> Is that, then, a difference between "f a b = ..." and "f = \a b -> ..."?
20:12:59 <sorear> Cale: not a restriction but a warning flag
20:13:01 <sorear> cdsmith: yes
20:13:08 <cdsmith> Interesting.
20:13:10 <Cale> It would also be nice if the compiler could figure out that the polymorphism is actually going to harm the performance.
20:13:18 <Cale> sorear: I agree.
20:13:41 <Cale> cdsmith: This sort of thing is quite irritating :)
20:13:43 <emk> Excedrin: If you see me around here on another day, feel free to ask me when my brain is turned on. :-)
20:13:53 <cdsmith> Thanks for the help!  And sorry for causing problems before...
20:13:55 <Cale> Those really "should" be equivalent.
20:14:11 <sorear> cdsmith: I don't think you saw something I said earlier
20:14:20 <cdsmith> sorear: what was that?
20:14:24 <sorear> <sorear> cdsmith: anyway, don't feel bad, every other newbie makes that mistake
20:14:24 <sorear>          (once)                                                           [19:49]
20:14:58 <cdsmith> sorear: Oh, alright then.  Won't happen again!
20:14:59 <desp> is it possible to do "deriving Eq"?
20:15:01 <glguy_> *and only once*!
20:15:04 <glguy_> ;)
20:15:09 <sorear> desp: yes
20:15:21 <desp> and both Eq and Show at the same time?
20:15:31 <Cale> deriving (Eq, Show)
20:15:37 <desp> ah
20:15:44 <sorear> desp: like with contexts, you need parens if there are more than one
20:15:49 <desp> thanks
20:15:52 <desp> was trying a list
20:15:55 <sorear> desp: actually I always use parens :)
20:17:01 <glguy_> deriving is one of the few cases I will use parentheses that I don't need
20:17:52 <desp> I noticed that the parens are required for "hiding", even when it's only one value
20:18:54 <sjanssen> dons: mentoring is out for me -- I plan to apply :)
20:19:00 <dons> sjanssen: ah!
20:19:15 <dons> we should probably talk then about what you'd like to work on.
20:19:20 <desp> hmm, does Haskell need SoC guys?
20:19:20 <desp> :)
20:19:38 <dons> ?where soc
20:19:39 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
20:19:51 <dons> we have one of the largest SoC programs, in fact.
20:19:55 <desp> awesome
20:20:14 <dons> libraries libraries libraries.
20:20:26 <Excedrin> emk: ok
20:20:31 <fantasma> do you get paid from SoC?
20:20:43 <dons> fantasma: the student does. yes.
20:20:56 <dons> the mentors do it for the love of lambdas.
20:21:01 <sorear> $4500 if successful, $0 if not
20:21:04 <sorear> motivation!
20:21:08 <sorear> :)
20:21:20 <LoganCapaldo> I do it for the love of sheep fathers
20:21:21 <fantasma> sucessful =~ completing the project?
20:21:28 <sorear> aiui
20:21:44 * sorear has never participated, or even researched
20:21:44 <dons> sjanssen: hmm, have you looked at 'st', Anselm's new xterm clone?
20:21:46 <desp> so there's no longer half now, half then?
20:21:49 <dons> in under 2k loc ;-)
20:22:02 <dons> desp: its 1/3 now, 1/3 mid way, 1/3 at the end, iirc
20:22:08 <desp> aha
20:22:29 <desp> that's sensible
20:22:32 <sjanssen> dons: no, I haven't.  Have you tried it?
20:22:46 <dons> nope. it might do so now actually
20:23:14 <sorear> it?
20:23:18 <sorear> do?
20:23:27 <sorear> s/it/i/p?
20:23:34 <dons> btw, in case anyone is interested, I'm really excited by, http://www.cse.unsw.edu.au/~dons/streams.html :-)
20:23:34 <lambdabot> Title: Data.List.Stream
20:23:36 <sjanssen> sorear: I think it == dons
20:23:46 <desp> ha!
20:23:51 <dons> ah yes.
20:23:55 <dons> unit 9 will do so now.
20:24:02 <dons> oops. i mean: i will do so now
20:24:04 <desp> I see that my my friend from university has already applied for the  LLVM Binding project
20:24:08 <desp> :)
20:25:26 <sorear> dons: I've figured out how to stream newtype Fix f = Fix (f (Fix f)) - stream fuse any ADT, with no special case code!  to bad haskell adts aren't really like that :(
20:26:00 <desp> http://hackage.haskell.org/trac/summer-of-code/ticket/71
20:26:01 <lambdabot> Title: #71 (NES emulator) - Haskell.org Google Summer of Code - Trac
20:26:03 <desp> that's weird
20:26:14 <desp> :)
20:26:16 <dons> hmm. probably not a good one to apply for though
20:26:24 <sjanssen> desp: yeah, I don't think that's a great project to choose
20:26:26 <dons> since its unlikely to get accepted. you pretty much have to work on libraries
20:26:35 <dons> or infrastructure
20:26:39 <Cale> Uh, tried mednafen?
20:26:39 * glguy_ wonders if the encyclopediadramatica.com article on TL;DR has the longest picture on the internet or not
20:26:40 <desp> of course
20:26:42 <bos_> dons: unscrap your boilerplate :-)
20:26:45 <desp> just pointing it out
20:26:57 <bos_> the code is nice looking.
20:27:09 <sjanssen> dons: it might be a good idea to mark those projects that seem "offtopic"
20:27:15 <dons> hmm. yes.
20:27:20 <dons> bos_: oh?
20:27:30 <Cale> Well, mednafen looks like it's probably a mess inside, but it works well, and emulates a whole lot of systems.
20:27:47 <bos_> oh, i was just noticing that there are many local declarations of loop, all subtly different :)
20:28:07 <dons> indeed. the entire list api
20:28:33 <bos> this is the same streams interface that y'all are basing the new parallel stuff on, looks like.
20:28:36 <chessguy> what does 'boxed' mean with respect to a data type?
20:28:42 <dons> bos, right.
20:28:52 <monochrom> has bottom
20:29:03 <sorear> monochrom: not exactly...
20:29:05 <dons> chessguy: also, its allocated on the heap
20:29:14 <sorear> chessguy: is represented as a pointer to a heap object
20:29:17 <dons> chessguy: like an object in java.
20:29:26 <sorear> chessguy: unboxed objects are represened 'inline'
20:29:35 <monochrom> haha, "has bottom" isn't exactly the spirit :)
20:29:46 <chessguy> hmm
20:29:52 <sorear> chessguy: so a Int# (unboxed) is a C int, and a Int (boxed) is a heap-allocated lazy int (*)()
20:29:52 <monochrom> the heap object is the box.
20:30:13 <LoganCapaldo> I like big _|_ and I can't deny
20:30:26 <chessguy> @quote bottom
20:30:26 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
20:30:28 <ddarius> Those other brothers can't apply
20:30:39 <glguy_> {-# INLINE [0] sum #-}
20:30:42 <glguy_> what does that mean
20:30:56 <dons> its says inline the body of 'sum' only in the last phase of simplification
20:30:56 <monochrom> the box probably contains something more than the data.  E.g., if your data type has several constructors, need something in the box to say which constructor.
20:30:56 <glguy_> inline when it's used on numbers?
20:31:00 <desp> is there a image loading/writing library for Haskell?
20:31:00 <sorear> monochrom: AIUI objects with bottom are called "lifted".  In current GHC boxed objects are lifted and vice versa, but (to quote the Commentary) "there is no technical reason this must be the case"
20:31:01 <glguy_> oh
20:31:06 <dons> glguy_: no, [0] is a phase annotation
20:31:15 <chessguy> ?where picasso
20:31:15 <lambdabot> I know nothing about picasso.
20:31:17 <dons> the simplifier/inliner has 4 phases
20:31:20 <sorear> desp: gtk2hs might have an imlib binding
20:31:27 <dons> the later you inline something, the longer you have to match rules against it
20:31:28 <bos> dons: it's really nice how the rewrite rules leave the code untouched, so it's still clean and simple to read.
20:31:30 <Excedrin> glguy_: that's a pretty good article
20:31:33 <Excedrin> er, picture
20:31:37 <sorear> desp: also, gtk2hs/cairo can write pngs
20:31:45 <dons> bos, the list code, you mean?
20:31:53 <bos> dons: yes
20:31:55 <desp> sorear: dons said libraries would make good SoC project
20:32:09 <dons> bos, yes, you have this nice declaratoin pattern language, that doesn't affect the basic library code
20:32:09 <emk> dons: I put myself down as an interested mentor for the LLVM bindings project (having messed around with LLVM quite a bit a year or two ago)>
20:32:28 <dons> s/declarative/. grr
20:32:31 <desp> but I don't see an image library on the list
20:32:35 <desp> of ideas
20:32:38 <sorear> desp: libraries nobody uses are like 5ft wide 5ft deep holes in Siberia
20:32:42 <bos> i think the soc projects have quite a few more mentors than students at the moment.
20:33:11 <emk> bos: Really? Most of the ones I clicked on had at least two students, and many had no mentors.
20:33:14 <desp> sorear: er. do you suggest working with images is an obscure thing to do? :)
20:33:29 * sorear thinks he may have accidentally mixed up two job creation schemes...
20:33:39 <dons> one great idea would be to find the best libraries in erlang, ocaml, python, ruby etc and port their functionality
20:33:40 <sorear> desp: yes, since noone has asked to do it yet
20:33:44 <bos> emk: really? i didn't find that. but it's hard to tell projects that got interest last year from those that have interest this year.
20:33:47 <sorear> ie no expressed demand
20:33:47 <dons> since that's probably a good clue as to their usefulness
20:33:50 <mwc> Well, it's happened... I've finally grokked arrows
20:33:51 <glguy_> dons: is there something I can read about some of the goals and ideas behind the Streams.hs? so that I don't have to just pester you?
20:33:54 <bos> hexpect, isagn.
20:33:55 <emk> dons: But there's a couple of others I could mentor instead.
20:34:04 <dons> glguy_: yeah, check the bytestring paper.
20:34:08 <emk> bos: Ah, fair enough.
20:34:08 <dons> i'll try to put up some more info today
20:34:11 <sorear> @go rewriting haskell string
20:34:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
20:34:12 <lambdabot> Title: Rewriting Haskell Strings
20:34:14 <mwc> I think my assember monad is now going to become an assember arrow to deal with the ugliness of my monad plumbing
20:34:26 <dons> glguy_: we want to make the entire list library fusible, meaning faster list code
20:34:33 <emk> mwc: Did you see the latest Haskell Reader issue?
20:34:39 <dons> also, we're reimplementing some of the basic list ops to take advantage of new optimisations
20:34:40 <mwc> emk, nope
20:34:45 <dons> so they should be faster, even without fusion.
20:34:56 <glguy_> dons: so Streams will be a generalization of ByteString?
20:35:09 <sorear> dons: example?  (of new opt)
20:35:22 <dons> nope. its a basic fusion abstraction. any sequence type you can convert into a Stream will be fusible.
20:35:26 <emk> mwc: There was a really sweet assembly DSL in it, IIRC, using MonadFix to link all the jumps up correctly in a single pass.
20:35:31 <dons> so bytestrings, arrays, lists , hmm, sets maybe.
20:35:33 <mwc> emk, ah, yeah, that's what I'm looking at now
20:35:38 <mwc> just downloaded it
20:36:00 <dons> sorear:
20:36:00 <glguy_> dons: what is the timeline for integrating this into GHC?
20:36:01 <dons> concat xss0 = to xss0
20:36:01 <dons>   where go []     xss = to xss
20:36:01 <dons>         go (x:xs) xss = x : go xs xss
20:36:01 <dons>         to []       = []
20:36:03 <dons>         to (xs:xss) = go xs xss
20:36:12 <dons> glguy_: by hmm. end of april.
20:36:37 <dons> there's an open trac ticket for it already
20:36:53 <glguy_> so it will be all the functionality of Lists without the pattern matching?
20:37:02 <glguy_> similar to how bytestrings work?
20:37:04 <dons> no . you have the same lists
20:37:05 <glguy_> in that regard
20:37:09 <dons> they'll just be faster
20:37:11 <glguy_> oh
20:37:16 <dons> your code will be unchnaged.
20:37:34 <sorear> glguy_: I do plan to write a generalized streams lib however - fast strict/chunked [a]
20:38:06 * glguy merges back with glguy
20:38:23 <dons> http://hackage.haskell.org/trac/ghc/ticket/915
20:38:24 <lambdabot> Title: #915 (Implement list fusion using streams instead of foldr/build) - GHC - Trac
20:38:29 <dons> is the job description
20:38:31 <chessguy> glguy: you mean fuses :)
20:38:35 <desp> dons: so I understand I could just add myself to "Interested Students" before submitting a proposal?
20:38:40 <LoganCapaldo> why is concat so complicated?
20:38:44 <dons> desp. right.
20:39:05 <chessguy> ?src concat
20:39:05 <dons> LoganCapaldo: to get better code.
20:39:05 <lambdabot> concat = foldr (++) []
20:39:20 <chessguy> that doesn't look complicated
20:39:23 <desp> dons: do you suppose the ByteString layer for Parsec is an important project?
20:39:27 <LoganCapaldo> not that one!
20:39:35 <chessguy> oh, dons' concat
20:39:46 <dons> desp, I do.
20:39:58 <glguy> dons: last question.. will we actually use "Stream" or is this something that will exist in the background?
20:40:06 <dons> glguy: its not exported nor visible.
20:40:21 <dons> so you never see it. the compiler just turns your code into it , and back again
20:40:26 <sorear> dons: will it be exported from any exposed module?
20:40:30 * chessguy hands glguy a towel to wipe up the drool
20:40:35 <sorear> dons: like data.bytestring.base kinda thing
20:40:37 <dons> and every pair of:  f . stream . unstream . g
20:40:41 <glguy> chessguy: you bet
20:40:42 <dons> gets turned into  f . g
20:40:47 <dons> avoiding an allocation
20:40:56 <dons> sorear: yeah.
20:40:58 <sorear> dons: I want to write my own sort of fusable sequence type, and I don't want to modify streams
20:41:15 <sorear> good.
20:41:45 <sorear> is this the kind of thing that I should wait before using if i don't want my cabals to break?
20:41:51 <hyrax42> dons: how is that concat faster?
20:41:56 <sorear> merging fps into base sucked :(
20:42:00 <dons> it compiles to better code in ghc.
20:42:36 <hyrax42> hm
20:42:42 <hyrax42> significantly?
20:42:48 <bos> desp: sjanssen has got that mostly done, but it's very slow.
20:42:51 <dons> 20% or so, iirc.
20:43:09 <bos> desp: investigating why it's so slow would be worthwhile.
20:43:28 <bos> desp: but if you want universal love, add decent character codec support.
20:43:39 <sorear> dons: so can I just write my FastPackedList and depend on 'streams', or should I wait and depend on 'base>=2.2'?
20:43:48 <bos> (not to parsec, but as a library to provide the same functionality you get in e.g. python)
20:43:56 <dons> sorear: there's no external streams package yet.
20:44:09 <dons> Stream.hs needs to end up in base though, since bytestring, [a] and array will all depend on it
20:44:17 <dons> i'd wait.
20:44:44 <bos> @type `par` dons
20:44:46 <dons> bos, btw, do you have some nice haskell project ideas for soc?
20:44:46 <lambdabot> parse error on input ``'
20:44:54 <dons> or are you available to mentor... ? :-)
20:45:12 <bos> dons: yes, i've been looking through the project list for something to glom onto :-)
20:45:40 <dons> have you registered as a mentor for haskell.org ?
20:45:46 <bos> not yet.
20:46:28 <sorear> dons: how does rewriting edison to 'fit in' to the Data.* sound?  (ie remove the difference-of-attitude between Map/List/Set/IntMap/IntSet/Seq and edison)
20:46:41 <desp> bos: what do you mean by "character codec"; character encodings?
20:46:58 <dons> sorear: that'd be a good one. breaking up edison/ making it first class.
20:47:03 <dons> that'd be a rather good project actually
20:48:09 <desp> bos: i.e. the matter handled by iconv?
20:48:28 <chessguy> how many students is haskell going to get?
20:49:00 <dons> chessguy: around 10.
20:49:07 <dons> we'll have around 150 applications, I suspect.
20:49:20 <chessguy> wow, that many
20:49:24 <hpaste>  jaredj pasted "already written code?" at http://hpaste.org/998
20:49:33 <bos> ok, now i've signed up.
20:49:37 <dons> we're one of the biggest projects, in the top 10 or so.
20:49:40 <dons> bos, great!
20:49:45 <bos> desp: yes, unicode <-> other encodings.
20:49:50 <dons> bos, ping isaac about getting on the soc-mentors@ mailing list
20:49:56 <bos> dons: will do
20:50:36 <chessguy> i still think SOC should focus on developing tools for hacking on haskell, rather than actually hacking on it. not that anybody cares what i think
20:50:59 <desp> I'm a bit baffled
20:51:24 <desp> I'd think making a wrapper around iconv wouldn't be worthy of a SoC project?
20:51:36 <jaredj> http://mssls7.mssl.ucl.ac.uk/more/baffle/
20:51:37 <lambdabot> Title: The Baffle
20:51:45 <desp> :)
20:52:01 <desp> yes, I'm trying to escape from a tube.
20:52:09 <jaredj> there are probably two ways
20:52:24 <dons> chessguy: a combinatoin of tools (e.g. debuggers, haddock) and libraries are expected to be worked on
20:52:29 <dons> chessguy: its a balance.
20:52:33 <jaredj> (from a strictly topological standpoint)
20:52:35 <desp> ;D
20:52:44 <dons> desp, we have an IConv wrapper already.
20:52:59 * desp pokes bos
20:53:01 <chessguy> well, yeah, i didn't mean just tools. i meant they should be a priority
20:53:08 <bos> desp: hang on
20:53:13 <dons> find the most important libraries from python, erlang, ruby , .... and then work out which ones aren't available in haskell
20:53:16 <dons> that's what i'd do ...
20:53:23 <bos> got a baby to get to sleep
20:53:33 <glguy> Excedrin: you about?
20:53:33 <jaredj> dons: MissingH?
20:53:53 <Excedrin> yes
20:54:09 <jaredj> i wrote a recursive file-finder thingy. i think it was in missingh
20:54:18 <jaredj> (not mine, another one)
20:54:21 <glguy> Excedrin: that code you pasted is using Integer
20:54:22 <jaredj> (already)
20:55:02 <Excedrin> it's someone elses code, whoever suggested that in channel
20:55:12 <jaredj> oops, my question scrolled off the screen, http://hpaste.org/998
20:55:13 <monochrom> I would add: design and implement the found missing library for haskell, except with a kick-ass interface or abstraction that makes the python, erlang, ruby folks jealous. :)
20:55:19 <glguy> Excedrin: well, you asked why it was slower
20:55:23 <jaredj> oops, my question is out of context still
20:55:54 <Excedrin> not really, I want someone to implement the C code in Haskell while retaining similiar performance
20:56:09 <bos> the problem with the iconv wrapper is its non-portability
20:56:41 <Excedrin> I'm sure it's slower due to some combination of laziness and whatever else
20:56:51 <dons> and there are more important libraries to write in the top 10 list.
20:57:04 <jaredj> where's that?
20:57:08 <dons> to be successful, the applicant should be proposing to work on something from the top 10 missing libs and tools
20:57:16 <desp> dons: what would those be? :)
20:57:39 <dons> hmm. http, matrices, web frameworks, graphs, ...
20:57:46 <chessguy> > 1.87 / 0.02
20:57:47 <lambdabot>  93.5
20:57:57 <dons> i proposed an algorithm above for finding the top 10 list
20:58:06 <jaredj> chessguy: yes, your two cents can be powerful?
20:58:25 <desp> yes, unfortunately I don't know much about the current state of Haskell libraries, since I'm very new to it
20:58:26 <LoganCapaldo> You should make one of the projects implementing the top ten list algo. in haskell
20:58:31 <dons> go to cpan, python, erlang, ruby .. find the top 10 libs for each, take away those already in haskell. rank by popularity
20:58:33 <chessguy> jaredj: ?
20:58:42 <jaredj> chessguy: x / 0.02
20:58:51 <chessguy> oook then
20:58:59 <jaredj> HASKELL ON RAILS!!!1
20:59:00 <bos> haskell already has decent pythonesque coverage.
20:59:11 <LoganCapaldo> Haskell on Hangars
20:59:12 <desp> dons: you're saying that http is missing -- but ticket #30 says thet "we've got cgi, ftp, http and irc"
20:59:17 <bos> you want to do something way useful? native tls.
20:59:34 <chessguy> ?vera tls
20:59:35 <dons> desp, a good http library. providing: get "http://www.google.com"
20:59:36 <lambdabot> *** "tls" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
20:59:36 <lambdabot> TLS
20:59:36 <lambdabot>      Thread Local Storage
20:59:36 <lambdabot>  
20:59:36 <lambdabot> *** "tls" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
20:59:38 <lambdabot> [3 @more lines]
20:59:40 <lambdabot> Title: Google
20:59:40 <bos> not an openssl wrapper
20:59:44 <monochrom> http client side is still not quite the right interface.
20:59:48 <LoganCapaldo> I
20:59:52 <bos> tls == ssl
20:59:52 <LoganCapaldo> oops slipped
21:00:11 <LoganCapaldo> I'd like to see a monadic web framework thingy that was nothing like rails :)
21:00:11 <emk> desp: The HTTP library has a bizarre, inconvenient interface, and I'm not so sure about the implementation.
21:00:26 <jaredj> yeah and it uses the wrong error reporting mechanism out of the eight
21:00:33 <jaredj> says the blags
21:00:41 <jaredj> ;)
21:00:43 <emk> It's certainly not suitable for either quick&dirty download scripts, or for high-end HTTP clients that download massive amounts of data.
21:00:44 <dons> it wasn't meant to be the official http lib. it wsa just the first one.
21:00:47 <desp> this is the library in question? http://www.haskell.org/http/
21:00:47 <dons> and people added to it :/
21:00:48 <lambdabot> Title: Haskell HTTP package
21:00:48 <chessguy> quoth the blaggers: nevermore
21:01:01 <monochrom> yeah, that one, desp.
21:01:05 <bos> and it uses string.
21:01:06 <dons> let's never speak of that library again.
21:01:06 <jaredj> oh! people probably know 'blag' here
21:01:12 * emk blags, blags, blags
21:01:25 <jaredj> quoth the server: 404
21:01:40 <desp> okay then, would someone apply as a mentor if I submitted an idea to replace the accursed HTTP library with a better one?
21:01:46 <bos> yep.
21:01:49 <monochrom> Heh, it wasn't meant to be the only one, but it ended up being the only one. :)
21:01:58 <LoganCapaldo> This here HTTP lib be accursed
21:02:00 <LoganCapaldo> @arr
21:02:00 <lambdabot> Aye
21:02:01 <sorear> LoganCapaldo: is #happs anything like rails? it sure is monadical
21:02:23 <LoganCapaldo> HAppS is nothing like rails, but not in the right ways :)
21:02:42 <jaredj> well - that's the thing really; <thing hundreds of people have opined before>
21:02:44 <bos> desp: yes, suggest it.
21:03:04 <jaredj> you have to play to the strengths of the language; rails is strong for ruby; not so much directly for other langs
21:03:06 <emk> jaredj: I'm the one who was complaining about the mishmash of error-handling conventions, so I could probably be talked into acting as a backup mentor.
21:03:10 <LoganCapaldo> sorear: I dream of a HAppS that's as brain dead easy to use as Parsec
21:03:12 <jaredj> </thing hundreds of people have opined before>
21:03:16 <jaredj> emk: bahahaha
21:03:18 <jaredj> ic
21:03:23 * jaredj blushes
21:03:33 <LoganCapaldo> If that analogy makes any sense
21:03:34 <desp> bos: thanks, I'll do that soon
21:04:01 * emk ritually burns the haddock documentation for the HTTP API.
21:04:11 <bos> desp: have you much haskell or network protocol experience?
21:04:25 <chessguy> "HAppS is a framework for developing Internet services quickly, deploying them easily, scaling them massively, and managing them ziplessly."
21:04:28 <chessguy> great summary
21:04:36 <jaredj> ziplessly?
21:04:41 <desp> bos: I'm new to Haskell, but I have two years of experience with SML/OCaml
21:04:46 * jaredj looks at fly
21:05:21 <bos> yay sleeping baby!
21:05:21 <emk> jaredj: Also, a new HTTP library would need to support ByteString, which is like 20x faster than String.
21:05:34 <jaredj> *nod*
21:05:46 <bos> new http wants teh stringablezor
21:06:05 <desp> bos: I have 7 years of C/C++ experience, including networking -- I authored a networkable image editor.  But perhaps I should leave the boasting to my application ;)
21:06:11 <emk> jaredj: dons was threatening to build it as a wrapper around cURL, which is probably a good idea (we've had good luck so far with cURL at work). Reimplementing a world-class HTPP client is a pretty big project.
21:06:22 <bos> because building replies and requests from ropes is very natural.
21:06:34 <jaredj> emk: good idea but.
21:06:39 <LoganCapaldo> Hey if you import Data.ByteString do string literals magically become bytestring literals?
21:06:44 <bos> no.
21:06:48 <jaredj> emk: curl does http fine, and https such as is used on the internet
21:06:57 <dons> LoganCapaldo: nope. unfortunately.
21:06:59 <jaredj> emk: but iirc does not support client certificates
21:07:03 <bos> LoganCapaldo: you have to pack them.
21:07:07 <jaredj> emk: actually, not much besides firefox does :(
21:07:23 <emk> jaredj: Hmmm. I thought the C library for cURL had at least some certificate support. I'd have to go look again.
21:07:30 <dons> i think a full curl wrapper with proper docs, complete api, and good examples, would be a good SoC project
21:07:36 <dons> one that has a chance to completely suceed.
21:07:39 <jaredj> emk: wait, let me rephrase
21:07:42 <glguy> pack on literals is a place where Lisp's macro system would do well
21:07:46 <jaredj> emk: client certs only in files.
21:08:20 <jaredj> e.g. no PKCS#11
21:08:31 <jaredj> libneon is similar
21:08:46 <bos> client certs are a corner case of a corner case's corner case.
21:08:48 <emk> dons: Yeah. Writing an HTTP client from scratch would either (a) give us another toy or (b) require insanely massive amounts of work from whoever volunteered.
21:09:09 <LoganCapaldo> @hoogle String -> ByteString
21:09:10 <lambdabot> No matches, try a more general search
21:09:20 <glguy> LoganCapaldo: pack
21:09:25 <bos> LoganCapaldo: it's called pack
21:09:30 <emk> jaredj: I've only heard libneon mentioned a few times, but at least those few mentions were reasonably positive.
21:09:34 <bos> @quote stereo
21:09:34 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
21:09:37 <LoganCapaldo> Then why did it yell at me :(?
21:09:49 <bos> LoganCapaldo: old database
21:09:55 <emk> I made the mistake of using the W3C's libwww for xmlrpc-c, and wound up deeply regretting the choice.
21:09:59 <LoganCapaldo> old database??
21:10:07 <bos> LoganCapaldo: ghc 642
21:10:11 <glguy> @quote
21:10:11 <lambdabot> SamB says: <SamB> @. bf . id . pl . v . wn yow  <lambdabot> Done.
21:10:21 <hpaste>  jaredj pasted "why client certs matter" at http://hpaste.org/999
21:10:33 <dons> emk, right.
21:10:37 <LoganCapaldo> Your cryptic answers do not discourage me!
21:10:46 <LoganCapaldo> @go haskell ghc 642 old database
21:10:48 <lambdabot> http://hackage.haskell.org/trac/ghc/attachment/ticket/885/fix-windows-DEP-violations-bug-885.dpatch
21:10:49 <lambdabot> Title: #885: fix-windows-DEP-violations-bug-885.dpatch - GHC - Trac
21:10:53 <bos> jaredj: not very convincing :-)
21:10:56 <glguy> LoganCapaldo: hoogle uses an old database of functions
21:11:01 <jaredj> bos: that's the whole DoD
21:11:04 <LoganCapaldo> Oh no
21:11:08 <LoganCapaldo> not hoogle
21:11:10 <LoganCapaldo> ghci
21:11:30 <bos> jaredj: i know.
21:11:45 <jaredj> bos: i care.
21:11:48 <hpaste>  LoganCapaldo pasted "ByteString, Huh?" at http://hpaste.org/1000
21:11:59 <wolverian> libsoup is nice too, although I don't know much about its features.
21:12:03 <jaredj> bos: i have to dance around this crap all the time just to try to use open source software
21:12:04 <bos> jaredj: you work for dod?
21:12:13 <desp> it appears that neon is receiving less developer attention than libcurl, judging by the release dates
21:12:16 <jaredj> bos: yes.
21:12:37 <jaredj> desp: it's rather stable, and i've only heard of its use in subversion
21:12:52 <jaredj> desp: advantage over libcurl is mostly that it does full DAV, i believe.
21:12:55 <emk> Personally, I'm interested in a web-crawler-grade HTTP client library--something which can download constantly, all day long, with the option to eventually support something like http://curl.haxx.se/libcurl/c/libcurl-multi.html
21:12:57 <bos> well, my attitude is that if the military wants a piece of decent software, they can sacrifice 1/20 of a cruise missile and get it...
21:12:57 <lambdabot> Title: libcurl - multi interface overview
21:13:10 <wolverian> (libsoup is at http://live.gnome.org/LibSoup)
21:13:11 <lambdabot> Title: LibSoup - GNOME Live!
21:13:23 <jaredj> bos: theirs isn't :(
21:13:35 <wolverian> neon looks very nice though. the soup page recommends it too. :)
21:13:36 <LoganCapaldo> well it obviously yelled at me because it wanted a [GHC.Word.Word8] and I gave it a [Char]
21:13:38 <jaredj> bos: i take your meaning though
21:13:57 <emk> jaredj: Hmm. Subversion HTTP performance used to be truly awful, thought I think that was a higher-level protocol problem.
21:14:02 <mwc> http://www.jameslaver.com/php_vs_python.png
21:14:04 <ddarius> jaredj: indeed
21:14:07 <mwc> I suspect it might actually be true
21:14:22 <LoganCapaldo> @where fps
21:14:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:14:42 <emk> mwc++ Hilarious.
21:14:51 <jaredj> bos: if the DoD does sacrifice 1/20 of a cruise missile for the functionality they need, odds are it won't make it back out to the internet
21:15:06 <bos> LoganCapaldo: you need Data.ByteString.Char8
21:15:17 <bos> jaredj: aye
21:15:33 <jaredj> mwc: baahahaha
21:15:40 <LoganCapaldo> bos: thank you
21:15:51 <bos> i exist to serve.
21:16:09 <glguy> who runs DARPA?
21:16:09 <nornagon> @src liftM
21:16:10 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:16:17 <bos> glguy: dod
21:16:24 <mwc> glguy, I'd wager DoD
21:16:26 <jaredj> glguy: D is for Defense
21:16:32 <glguy> bos: so it's not unheard of for them to support public projects
21:16:36 <glguy> ?
21:16:40 <jaredj> glguy: it used to be ARPA but i guess someone got confused :)
21:16:42 <glguy> maybe I'm asking the wrong person :)
21:16:45 <bos> glguy: true.
21:16:55 <mwc> Weren't they gonna change their name to ARPA? Hmmm, wait, ARPANet... Did ARPA become DARPA
21:16:58 <glguy> they used to help fund OpenBSD
21:16:59 <jaredj> true. but it's the exception not the rule
21:17:02 <jaredj> mwc: yes, that
21:17:09 <ddarius> jaredj: We are in a time of war now so it was probably changed back (again)
21:17:20 <jaredj> oh? k
21:17:44 <jaredj> i think that was mildly funny and went over my head
21:17:47 <ddarius> DARPA/ARPA is apparently constantly being flipped between
21:17:58 <jaredj> nod ic
21:18:48 <emk> jaredj: Hmm. Does libneon support some sort of 'select', for handling more than a handful of ongoing downloads?
21:19:27 <LoganCapaldo> Can you do qualified M as N somehow in ghci?
21:19:43 <jaredj> emk: i don't know. all i know about its api is that it exports functions with parameters for the filename of the key :(
21:20:10 <emk> jaredj: Ouch.
21:21:30 <jaredj> emk: that was where my essays into svn + PKCS11 stopped
21:21:48 <Shimei> Yay. Got my copy of Haskell School of Expression via amazon today. :)
21:22:29 <bos> neon is icky. it handles webdav as well as http.
21:22:30 <LoganCapaldo> Is there a Haskell impl. that uses type information to distinguish between ambiguous identifiers?
21:23:07 <ddarius> Yay! Kan extensions and Haskell.
21:23:12 <glguy> let a = 1 ; a = 'a' -- like that?
21:23:30 <LoganCapaldo> Cause I'm pretty sure map pack ["a", "b"], map can't be the one from Data.ByteString.Char8
21:23:35 <dons> grr. haddock doesn't like ! patterns
21:23:44 <LoganCapaldo> Just curious
21:23:54 <LoganCapaldo> I realize its probably a PITA to actually do
21:24:23 <desp> dons: btw... I think you have a broken link on http://www.cse.unsw.edu.au/~dons/streams.html -- "<a ref" instead of "<a href"
21:24:23 <lambdabot> Title: Data.List.Stream
21:24:26 <LoganCapaldo> glguy: I think I just mean from different modules
21:24:59 <jaredj> bos: are you implying dav is icky? :)
21:25:08 <LoganCapaldo> I don't want to increase the number of ways I can be confused :)
21:25:11 <bos> jaredj: you betcha :)
21:25:25 <dons> desp, cheers
21:25:39 <nornagon> @src Monoid
21:25:39 <lambdabot> class Monoid a where
21:25:40 <lambdabot>     mempty  :: a
21:25:40 <lambdabot>     mappend :: a -> a -> a
21:25:40 <lambdabot>     mconcat :: [a] -> a
21:25:42 <sorear> jaredj, bos: AIUI Defense is a propaganda term and isn't likely to change to reflect conditions.  BITD (by which I mean WWII), the DoD was called the War Department.  That didn't last :)
21:25:51 <jaredj> bos: meh beats frontpage :)
21:26:07 <jaredj> ?vera aiui
21:26:09 <lambdabot> *** "aiui" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
21:26:09 <lambdabot> AIUI
21:26:09 <lambdabot>      As I Understand It (telecommunication-slang, Usenet, IRC)
21:26:09 <lambdabot>  
21:26:17 <bos> sorear: yes, i know. i expect it to become the peace dept spme day.
21:26:19 <jaredj> ?vera bitd
21:26:20 <lambdabot> No match for "bitd".
21:26:25 <jaredj> :d
21:26:29 <sorear> bos: not minipax? :)
21:26:31 <monochrom> fmap is a name ambiguous and resolved by type information.
21:26:36 <jaredj> ?vera bitd is "back in the day"
21:26:39 <lambdabot> No match for "bitd".
21:26:39 <lambdabot>  
21:26:39 <lambdabot> *** "is" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
21:26:39 <lambdabot> IS
21:26:39 <lambdabot>      Intermediate System (ATM)
21:26:40 <bos> sorear: well, yes...
21:26:41 <lambdabot> [10 @more lines]
21:26:43 <jaredj> dooh
21:27:05 <bos> vera is rather chatty.
21:27:19 <jaredj> sorear: i have a friend who is fond of pointing out that a war/armed conflict has not yet been won by the DoD
21:27:30 <jaredj> bos: yeah. sorry :P
21:28:02 <yshhq> ?hoogle union
21:28:09 <lambdabot> List.union :: Eq a => [a] -> [a] -> [a]
21:28:16 <lambdabot> Data.IntMap.union :: IntMap a -> IntMap a -> IntMap a
21:28:24 <lambdabot> Plugin `hoogle' failed with: IRCRaised thread killed
21:28:26 <glguy> @
21:28:38 <bos> libcurl, btw, is gorgeous.
21:28:38 * sorear recognizes the problem
21:28:43 <glguy> @losers
21:28:43 <lambdabot> Maximum users seen in #haskell: 336, currently: 292 (86.9%), active: 40 (13.7%)
21:28:44 <sorear> @activity-full 90
21:28:44 <lambdabot> 28*total 15*jaredj 8*glguy 5*#haskell
21:29:02 <sorear> ok, people, less load on the bot please :)
21:29:15 <glguy> sorear: what's the 8 mean?
21:29:24 <bos> #requests
21:29:28 <sorear> 8 messages to glguy in the last 90 seconds
21:29:32 <glguy> ahh
21:29:46 <sorear> bos: actually requests is a little hard to measure, so I do responces instead
21:29:50 <glguy> yeah, I got hit by the "if you type @ in /query, lamdabot chats your ear off"
21:30:11 <jaredj> bos: mintruth, minpeace, minlove, was it?
21:30:23 <sorear> minitrue, minipax, miniluv, miniplenty
21:30:33 <LoganCapaldo> No minimax?
21:30:35 <bos> sorear: ah
21:30:43 * sorear has 1984 as mandatory reading at high school atm
21:31:11 <jaredj> :)
21:31:13 <glguy> @quote sorear
21:31:13 <lambdabot> sorear says: sorear	wonders if he is cool yet
21:31:30 <sorear> 1984, animalfarm, brave new world, fahrenheit 451, ...
21:31:41 <bos> fine books all.
21:31:41 <dmwit> Classics!
21:31:42 <sorear> all the books a politically savvy person needs to read
21:31:58 <dmwit> They're really good, until they're assigned to you.
21:31:59 <dmwit> =)
21:32:03 <glguy> @quote
21:32:03 <lambdabot> conal says: monochrom: maybe that's only because computers program people as much as vice versa.
21:32:04 * dolio has seen the Animal Farm movie.
21:32:13 <dolio> That's what we did in high school. :)
21:32:22 * ddarius_ is not a Ray Bradbury fan.
21:32:30 <jaredj> sorear: i've read a bunch of bradbury short stories and not f451. i think the stories are quite cool too
21:33:32 <dmwit> I liked the "Quicker than the Eye" collection.
21:33:57 <dmwit> It had a fun one about this guy that made money by selling houses (repeatedly) above earthquake faults.
21:33:59 <dmwit> Delightful!
21:34:48 <bos> ok, just chucked the baby in bed, so i can type with two hands again.
21:34:58 <jaredj> heh
21:35:05 <dmwit> ?help vera
21:35:05 <lambdabot> I perform dictionary lookups via the following 13 commands:
21:35:05 <lambdabot> all-dicts ... Query all databases on dict.org
21:35:05 <lambdabot> devils ...... The Devil's Dictionary
21:35:05 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
21:35:07 <lambdabot> elements .... Elements database
21:35:09 <lambdabot> [9 @more lines]
21:35:14 <sorear> jaredj: so, if you're still curious, here's what's happening: lambdabot is a normal client and suffers from server side flood control.  5 messages every 10 seconds.  Someone asked the bot to do more than that, so it had to wait.  @Hoogle was slowed down enough waiting for the semaphores that it went over the 15 second time limit and was killed.
21:35:29 <bos> writing a native haskell iconv-alike library would be useful, and scoped tightly enough to have a hope of succeeding as an SOC project.
21:35:46 * sorear rewrote the code in question quite recently
21:35:54 * sorear is also responsible for @activity
21:35:59 <bos> use the design of python's codecs library, which is really quite nice, as a basis, and just start plugging away.
21:36:21 <jaredj> sorear: ah, quite good, quite good.
21:36:24 <bos> and provide both fps and string interfaces.
21:37:03 <jaredj> the spine of my algorithms book is broken :(
21:37:28 * LoganCapaldo feels like theres a joke invovling evaluating the spine of a list
21:37:36 <LoganCapaldo> But I can't come up with it
21:38:08 <jaredj> http://sequence.complete.org/node/263
21:38:09 <int-e> I was thinking about divide and conquer.
21:38:09 <lambdabot> Title: Dynamic Programming in Haskell | The Haskell Sequence
21:38:32 <jaredj> i don't quite understand this knapsack thing
21:38:35 <sorear> LoganCapaldo: maybe also consider evaluation spines?  eg. in the Spineless G-Machine
21:38:47 <sorear> @quote JohnMeacham less
21:38:47 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
21:38:52 <sorear> :(
21:38:57 <thief_grr> are there any widely accepted coding styles for haskell?
21:39:05 <nornagon> thief_grr: point free! :)
21:39:12 * jaredj runs screaming
21:39:45 <jaredj> http://www.madore.org/~david/programs/unlambda/
21:39:47 <lambdabot> Title: The Unlambda Programming Language
21:39:52 <thief_grr> :) i meant things like "there should be space there, and that type of indentation, and leave a blank line then and then, and don't do so then and then"
21:40:02 <dons> thief_grr: there's a Style page on the wiki
21:40:03 <thief_grr> jaredj: this is fun :)
21:40:11 <thief_grr> dons: ok thanks
21:40:16 <bos> thief_grr: read the libraries, and follow their example. it's pretty loosey-goosey.
21:40:35 <dons> http://haskell.org/haskellwiki/Category:Style
21:40:36 <lambdabot> Title: Category:Style - HaskellWiki
21:40:44 <jaredj> why thanks dons
21:41:57 <bos> thief_grr: http://www.haskell.org/haskellwiki/Programming_guidelines
21:41:58 <lambdabot> Title: Programming guidelines - HaskellWiki
21:42:21 <sorear> jaredj: I love it
21:42:35 <sorear> jaredj: I actually discovered haskell through that page
21:42:42 <jaredj> oho
21:42:44 <araujo> hello
21:42:59 <sorear> jaredj: I used to be quite into that kind of thing.
21:43:15 <sorear> jaredj: "Write an INTERCAL compiler in INTERCAL" is still on my TODO list
21:43:21 <jaredj> that makes me feel old.
21:43:27 <sorear> I think that'll get me eternal fame
21:43:37 <jaredj> intercal, that doesn't make me feel old. but unlambda does.
21:43:46 <sorear> ?
21:43:58 <LoganCapaldo> sorear: I believe the word you were looking for was infamy ;)
21:43:59 <sorear> It takes a lot to make me feel old
21:44:08 <ddarius> Yay, my favorite example of polymorphic recursion in a good paper.
21:44:08 <jaredj> that's because you aren't
21:44:15 <jaredj> um i think
21:44:52 <sorear> oh, yeah.  I think I kinda gave it away with the required reading at highschool comment.
21:44:54 <jaredj> if i thought about higher-order functions enough perhaps i could dig unlambda
21:45:02 <LoganCapaldo> If sorear is old than the average person in this room has died of old age :)
21:45:02 <sorear> 16.  Normally I try to make people guess.
21:45:20 <jaredj> sorear: meheh. i wouldn't have known without that
21:45:39 * ddarius never felt old at 16 but does occasionally now.
21:45:51 <monochrom> In the hands of this young generation, Haskell has a long future. :)
21:45:59 <jaredj> i spend a bunch of time at work railing within my own head against fortran
21:46:05 <thief_grr> bos: thanks :)
21:46:05 <bos> enjoy being young and bright while it lasts :-)
21:46:18 <mwc> I'm 22. My bones ache after long sprawl sessions on the floor with pencil and paper
21:46:25 <jaredj> and i imagine the fortran programmers thinking, "yeah i should learn c++ but i never have"
21:46:34 <mwc> should hear the crack I get out of my sternum afterwards
21:46:39 <int-e> jaredj: what's your trouble with that knapsack implementation?
21:46:48 <sorear> in 65 years I expect to be the last one using haskell, while everyone else uses languages that make haskell look like fortran
21:46:49 <jaredj> woohoo sternum
21:46:58 <dons> sorear: heh
21:47:04 <monochrom> When I wa 11 my bones also ached after long sprawl sessions on the floor with Lego. :)
21:47:10 <mwc> I'm hoping next year while I'm in my masters program in control theory, I get to bring YAMPA into it somehow
21:47:14 <jaredj> sorear: that's just it, i almost feel like python is my fortran
21:47:31 <jaredj> monochrom: w00t me too
21:47:44 <sorear> ./07.02.24:15:20:41 <sorear> @remember JohnMeacham no matter what I name a AM.. it can never be as cool a name as 'spineless tagless g-machine'.
21:47:49 <sorear> @remember JohnMeacham no matter what I name a AM.. it can never be as cool a name as 'spineless tagless g-machine'.
21:47:49 <lambdabot> Done.
21:47:54 <jaredj> is vera teachable?
21:47:59 <sorear> darn forgetful bot
21:48:16 <sorear> jaredj: no
21:48:23 <jaredj> aw.
21:48:24 <jaredj> mwc: YAMPA?
21:48:34 <sorear> jaredj: Yampa.  It's just a name
21:48:44 <jaredj> nuh uh.
21:48:46 <sorear> jaredj: Functional reactive programming with Arrows
21:48:51 <sorear> @where yampa
21:48:52 <lambdabot> http://www.haskell.org/yampa/
21:48:55 <mwc> it's a functional "reactive" programming DSL done by Hughes
21:48:56 <jaredj> it starts with a ya, that means yet another, it has to
21:49:05 * allbery_b watches the kids natter...
21:49:07 <monochrom> I'm cynic.  In 65 years I expect sorear to be the last one using haskell, while everyone uses languages that make haskell look like magic. :)
21:49:17 <mwc> Oops, it's Hudak
21:49:27 <jaredj> heh
21:49:48 <jaredj> i need to read about 12 more arrow tutes before i can get them
21:50:04 <jaredj> and there aren't as many of those as with monads
21:50:15 <LoganCapaldo> I wonder if these were the kind of comments thrown about in prehistoric lisp irc channels
21:50:27 <jaredj> - so haskell requires you to write a monad tutorial, what language requires an arrow tut?
21:50:37 <monochrom> haskell'
21:50:44 <jaredj> LoganCapaldo: do they not still?
21:50:54 <jaredj> ;)
21:51:11 <LoganCapaldo> well they can't be still, since its not prehistory anymore ;)
21:51:17 <jaredj> lol
21:51:52 <LoganCapaldo> I'm afraid of Haskell'
21:51:59 <jaredj> i could say something about history coming with literacy... but i probably couldn't get away with zinging lispers that bad
21:52:01 <ddarius> I guess since IRC is a volatile medium, it could still be prehistory.
21:52:13 <sorear> @where logs
21:52:13 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
21:52:27 <jaredj> HISTORY IS BEING MADE
21:53:10 <jaredj> cue scene at end of indiana jones ark movie, with old man carting the ark of the covenant into a city of boxes
21:53:13 <dolio> :) Don't say anything dumb. It's going on your permanent record.
21:53:49 <mwc> jaredj, do you grok Control.Monad.State?
21:54:22 <mwc> because I just went through Control.Arrow.Transformer.State until I groked it
21:55:14 * jaredj goes off to grok things
21:55:49 <ddarius> mmm, Stranger in a Strange Land
21:56:20 <sorear> hmm.  sounds like a pratchett title.  /me has a hunch what it's being references...
21:56:23 <sorear> @jargon grok
21:56:25 <lambdabot> *** "grok" jargon "Jargon File (4.3.1, 29 Jun 2001)"
21:56:25 <lambdabot> grok /grok/, var. /grok/ vt. [common; from the novel "Stranger in a
21:56:25 <lambdabot>    Strange Land", by Robert A. Heinlein, where it is a Martian word meaning
21:56:25 <lambdabot>    literally `to drink' and metaphorically `to be one with'] The emphatic
21:56:25 <lambdabot>    form is `grok in fullness'. 1. To understand. Connotes intimate and
21:56:27 <lambdabot> [12 @more lines]
21:56:56 <jaredj> mm, i'm going to grok a cheerwine now
21:57:51 <fantasma> hm.
21:58:28 <jaredj> oh noes! 404 http://darcs.haskell.org/packages/mtl/Control/Monad/State.raw-hs
21:58:40 <fantasma> that's not good
21:58:44 <sorear> s/raw-//
21:58:47 <sorear> known bug
21:58:53 <jaredj> oh kthx
21:59:46 <monochrom> Yeah, generally every time you get 404, edit the url with obvious guesses, and as a last resort, browse the directory instead.
22:00:08 <fantasma> all that is missing is an Haskell irc client
22:00:12 <monochrom> another obvious guess is replace "hs" with "lhs"
22:00:13 <jaredj> it is?
22:00:25 <bos> if someone wanted to do a decent but small haskell web app server framework, web.py would be a nice thing to look at for ideas.
22:00:43 <bos> http://webpy.infogami.com/src
22:00:44 <lambdabot> Title: code samples (web.py wiki)
22:00:55 <ddarius> @google hircules
22:00:58 <lambdabot> http://freshmeat.net/projects/hircules/
22:00:58 <lambdabot> Title: freshmeat.net: Project details for Hircules
22:03:43 <jaredj> can you do lhs with haddock?
22:03:46 <dons> conal: around?
22:03:56 <dons> how do you ge those [code] links in your haddock docs?
22:03:57 <hyrax42> :t Data.Map.Size
22:03:59 <lambdabot> Not in scope: data constructor `Data.Map.Size'
22:04:01 <dons> (anyone know?)
22:04:05 <hyrax42> :t Data.Map.size
22:04:07 <lambdabot> forall k a. M.Map k a -> Int
22:04:21 <hyrax42> :t Data.Map.singleton
22:04:23 <lambdabot> forall k a. k -> a -> M.Map k a
22:04:40 <hyrax42> :t Data.Map.insert
22:04:42 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
22:04:50 <hyrax42> interesting
22:05:08 <hyrax42> so you can have singleton maps without the Ord constraint on keys
22:05:10 <hyrax42> but that's about it
22:05:17 <hyrax42> :t Data.Map.lookup
22:05:20 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
22:06:00 <jaredj> and then you can't look it up?
22:06:16 <hyrax42> yeah
22:06:20 <hyrax42> apparently not
22:06:30 <jaredj> heh
22:06:50 <hyrax42> > M.singleton (+) 3
22:06:52 <lambdabot>  fromList [(<Integer -> Integer -> Integer>,3)]
22:07:36 <hyrax42> > M.lookup (+) $ M.singleton (+) 3
22:07:37 <lambdabot>   add an instance declaration for (Show (m a))
22:07:38 <sorear> dons: wiki cabal-make I imagine
22:07:40 <bos> Map requires that keys be Ord. the lack of constraint on singleton is meaningless.
22:07:49 <hyrax42> > M.lookup (+) $ M.singleton (+) 3 :: Maybe Int
22:07:50 <lambdabot>   add an instance declaration for (Ord (a -> a -> a))
22:07:54 <desp> wow, HTTP really *is* ugly currently
22:07:55 <dons> sorear: ah right.
22:08:25 * hyrax42 is reading the "Programming guidelines" wiki page
22:08:44 <hyrax42> saw the bit about not putting constraints on datatype so wanted to check Map
22:09:11 <bos> there's just a handful of unconstrained things you can do on a Map.
22:09:33 <hyrax42> yeah, like size
22:09:56 <hyrax42> :t M.toList
22:09:58 <lambdabot> forall k a. M.Map k a -> [(k, a)]
22:10:12 <hyrax42> :t M.fromList
22:10:14 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
22:11:10 <desp> is Eric Kidd here?
22:12:26 <dons> @seen emk
22:12:26 <lambdabot> emk is in #haskell. I last heard emk speak 52m 16s ago.
22:12:29 <desp> ah.
22:12:54 <bos> hyrax42: btw, i wouldn't take the stuff in "programming guidelines" too seriously. it's observed much more in the breach than in conformance.
22:12:55 <emk> ?
22:13:19 <desp> emk: nothing, just wanted to connect the author behind some articles I enjoyed to the IRC nick ;)
22:13:30 <jaredj> -- >  type Parser a = StateT String [] a
22:13:30 <jaredj> -- >     ==> StateT (String -> [(a,String)])
22:13:39 <jaredj> what's the ==>?
22:13:49 <hyrax42> bos: the breach than in conformance?
22:14:20 <bos> hyrax42: i.e. about half those guidelines are silly, and not actually followed much.
22:14:30 <hyrax42> oh
22:14:35 <hyrax42> well I'm just reading to se
22:14:53 <hyrax42> the better thing would be to get some recent projects by "respectable" people
22:15:01 <desp> jaredj: I'm really tempted to say "it appears to be an arrow"
22:15:02 <hyrax42> and look through
22:15:24 <dons> hey, does anyone have some list-heavy programs I can use for benchmarks?
22:15:26 <hyrax42> since mostly I'm interested how people organise bigger projects
22:15:28 <hyrax42> well medium
22:15:34 <dons> i need listy things for the new stream fusion lib
22:15:40 <dons> the more list functions you use the better :-)
22:15:59 <jaredj> it looks like a "this is what it comes out to" annotation, but it's not commented
22:16:26 <jaredj> http://darcs.haskell.org/packages/mtl/Control/Monad/State/Lazy.hs
22:16:32 <bos> hyrax42: download ghc and look around in the libraries subdir
22:16:33 <sorear> @botsnack
22:16:34 <lambdabot> :)
22:16:43 <sorear> bah.
22:16:45 <sorear> @karma- lag
22:16:46 <lambdabot> lag's karma lowered to -7.
22:16:48 <desp> jaredj: what do you mean it's not commented?
22:16:54 <hyrax42> bos: I've looked at a bunch, I find them too uncommented
22:17:11 <hyrax42> well some
22:17:13 <bos> hyrax42: oh, you want comments too :-)
22:17:18 <jaredj> desp: well, it's after a >
22:17:34 <desp> jaredj: perhaps the author thought multiple --s within one line would be redundant
22:17:36 <sorear> dons: @pl is pretty standard-list-function-heavy
22:17:45 <jaredj> desp: k
22:17:51 <desp> jaredj: just my best guess
22:17:57 <dons> sorear: ah indeed.
22:17:57 <jaredj> *nod*
22:18:14 <jaredj> > :t ==>
22:18:14 <lambdabot>  Parse error
22:18:24 <bos> hyrax42: take a look at fps and binary, then
22:18:26 <hyrax42> bos: hey, complaining never killed anyone
22:18:27 <bos> @where fps
22:18:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
22:18:30 <bos> @where binary
22:18:30 <lambdabot> http://darcs.haskell.org/binary
22:18:33 <sorear> dons: I've got a pretty ugly and slow life program which uses the standard list funcs
22:18:42 <dons> sounds good!
22:19:03 <hyrax42> my awful ai project was pretty list heavy I think
22:19:05 <sorear> If you want me to act on this ...
22:19:19 <hyrax42> but it's coupled to some server
22:19:27 * jaredj stops grokking and returns to knapsack problem
22:19:37 <dons> sorear: post the code somewhere. tar.gz or darcs
22:19:55 <dons> anyone else with code that's list heavy, and would like to see it used to speed up haskell lists...
22:21:08 <jaredj> oho, that's what i couldn't understand well
22:21:09 <sorear> http://members.cox.net/stefanor/hslife
22:21:10 <lambdabot> Title: Directory listing
22:21:41 <jaredj> the problem i have is not exactly this knapsack problem
22:21:59 <sorear> The code is some of the first I wrote, based on a misunderstood algorithm (does asymptotically significant redundant work), and is too ugly to refactor.
22:22:05 <sorear> you have been warned.
22:22:11 <sorear> (first == first haskell)
22:23:35 <sorear> @botsnack
22:23:35 <lambdabot> :)
22:25:35 <bos> dons: in refactoring the network ipv6 changes so that ipv6 lookup code now lives in Network.Socket, i had to move some type declarations out of Network.BSD, because Network.Socket needed them.
22:26:03 <bos> dons: so i created a new non-exported Network.Internal module, and put them there. i assume this was a normal and sane thing to do?
22:26:50 <bos> (the goal was to avoid cyclic module dependencies, and to not re-export a name from a module it hadn't been exported from before, thereby breaking old client code that imported both modules.)
22:32:30 <wolverian> damn, darcs doesn't work on an sshfs mount
22:33:48 <hpaste>  jaredj pasted "redundant! how to fix?" at http://hpaste.org/1001
22:34:24 <ddarius> jaredj: lambda
22:34:31 <sorear> ugly! :)
22:34:57 <jaredj> ddarius: (\x -> x) and (\x -> x - 1) sort of thing?
22:35:00 <jaredj> sorear: suggestions?
22:35:11 <jaredj> sorear: (i agree)
22:35:18 <dons> sorear: cheers
22:35:21 <sorear> jaredj: you might want to look at my quick traversal hack - http://members.cox.net/stefanor/GenDirListings.hs
22:35:28 <sorear> dons: ?
22:35:32 <ddarius> Abstract out everything that is redundant and pass it back in as a HOF.
22:36:11 <jaredj> oic
22:36:50 <bos> jaredj: your HOF might take a seed of some kind, and a list of directories and files, and return a new seed and list of directories.
22:37:11 <ddarius> Alternatively, allFilesUnder should equal shallowFilesUnder maxBound
22:37:13 <bos> you can then limit the depth of traversal by using an integer as the seed.
22:37:15 <sorear> jaredj: my dumb webhost doesn't do directory listings, so I have to generate tgen
22:37:40 <bos> and you can eliminate directories from being recursed into by removing them from the list your function returns.
22:37:51 <jaredj> sorear: move your right hand to the right one letter :)
22:38:05 <bos> that gives you a fully general walky talky directory recursor doodad.
22:38:12 <sorear> jaredj: in which letter?
22:38:18 <jaredj> tgen -> them
22:38:28 * ddarius goes to lie in bed and do nothing.
22:38:51 <bos> ddarius: would that be what we call sleep, or do you have other kinds of nothing plans? :)
22:38:58 <vincenz> ddarius: that in the MAybe monad?
22:39:26 <vincenz> sleep != doing nothing, sleep = defrag
22:39:36 * jaredj is fragged
22:39:42 <vincenz> or major GC cycle
22:39:56 <vincenz> that's why we dream, all the pointer traverlsa
22:39:56 <bos> goToBed :: Sleep -> Maybe Dream
22:40:07 <TSC> Perchance Dream
22:40:15 <vincenz> goToBed :: Maybe (Either Male Female) -> Maybe Sex
22:40:16 <jaredj> bos: *groan*
22:40:43 <vincenz> or better is the list monad
22:40:49 <desp> whew
22:40:52 <jaredj> vincenz: (Left me) -> Nothing
22:40:57 <desp> bos: are you still awake?
22:41:03 <bos> yep.
22:41:06 <desp> http://hackage.haskell.org/trac/summer-of-code/ticket/1122
22:41:08 <lambdabot> Title: #1122 (HTTP Library Replacement) - Haskell.org Google Summer of Code - Trac
22:41:26 <bos> desp: +1
22:42:00 <jaredj> i have never seen that sort of an 'a' before
22:42:04 <desp> I'm not 100% certain at this point that I will be submitting a proposal
22:42:16 <desp> I should have this resolved in a few days
22:42:24 <desp> but I would certainly love to
22:42:54 <jaredj> U+0105 LATIN SMALL LETTER A WITH OGONEK
22:42:55 <desp> jaredj: that's a Polish nasal vowel
22:43:07 <jaredj> @gucharmapsnack
22:43:07 <lambdabot> Unknown command, try @list
22:43:13 <jaredj> cool
22:44:03 <desp> jaredj: and my full name would be Mieczysław, but for some reason Anglophones prefer the shorter version :)
22:44:36 <jaredj> Mieczys?aw
22:44:52 <jaredj> http://www.bash.org/?244321
22:44:54 <lambdabot> Title: QDB: Quote #244321
22:45:02 <desp> heh
22:45:20 <jaredj> i'm guessing that ? is a tricky 'l'
22:45:37 <jaredj> one of the sort that anglophones have trouble pronouncing
22:45:59 <jaredj> i'm all for trying
22:46:08 <desp> I could've sworn it was called L-with-dash
22:46:10 <desp> but google fails me
22:46:13 * sorear habitually typos links as linsk, and ....
22:46:45 <jaredj> if i were ircing from within acme it would have worked fine
22:47:05 <desp> U+0142 LATIN SMALL LETTER L WITH STROKE
22:47:17 <jaredj> http://swtch.com/plan9port/screenshots/acme.png
22:47:21 <desp> anyhow.
22:47:29 <jaredj> t
22:47:30 <vincenz> U+176 GREEK BIG LETTER G WITH A BUTTERFLY
22:47:35 <jaredj> nuh uh
22:47:55 <desp> emk: would you be interested in co-mentoring, as you said before? :)
22:48:25 <jaredj> sorear: i'm trying to implement mine without setCurrentDirectory
22:48:29 <vincenz> jaredj: with an ULCER then?
22:48:33 <jaredj> bahahaha
22:48:37 <emk> Well, I want to see what happens with the LLVM project first.
22:49:04 <desp> emk: okay
22:49:09 <emk> But depending on how things work out, it's entirely possible I could be talked into it. :-)
22:49:09 <bos> http://blogamundo.net/dev/index.php?tag=loonicode
22:49:34 <desp> emk: did I mention I'm friends with the LLVM guy? ;)
22:49:45 <vincenz> loonicode :D
22:50:01 <emk> desp: Cool!
22:50:08 <jaredj> lol
22:50:29 <emk> If there's anything you want to discuss, ping me tomorrow and we can talk.
22:50:36 <desp> emk: okay, thanks.
22:52:07 <desp> ah, right, forgot to mention the ByteString goodness.
22:53:21 <mauke> what's a good file descriptor allocation algorithm?
22:53:44 <bos> mauke: huh?
22:54:06 <bos> you mean for within a kernel?
22:54:25 <mauke> for anything, really
22:54:56 <desp> @where ByteString
22:54:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
22:54:58 <bos> the usual thing to do is just store an array of pointers and scan it linearly until you find one that's null, then use that as your new fd.
22:55:13 <mauke> I don't want a linear search
22:55:18 <mauke> can it be made O(1)?
22:55:49 <bos> yes, just store a queue of unused numbers.
22:56:32 <mauke> that doesn't give me the lowest unused number
22:56:54 <bos> a heap queue.
22:56:57 <TSC> Maybe you should state your preferred properties upfront
22:57:11 <bos> not a regular queue.
22:58:05 <mauke> preferred properties: an "open" function that returns the lowest unused descriptor; a "close" function that unuses a descriptor; both of them should run in O(1) if possible
22:58:25 <mauke> simple underlying data structure is a bonus
22:58:27 <sorear> O(log n) is achievable
22:58:33 <sorear> with a heap/tree
22:58:42 <bos> you want a min heap queue.
22:58:50 <sorear> either open or close (but not easily both) can be O(1)
22:59:41 <sorear> open O(1) with a ord fingertree + deleteFindMin
22:59:58 <sorear> close O(1) with a normal heap
23:00:15 <bos> mauke: are you doing this in haskell, or an imperative language?
23:00:33 <sorear> I'm allowing for imperative...
23:00:48 <mauke> bos: it's only in my head so far
23:00:57 <bos> if in haskell, take a look at the edison library's implementation of a lazy pairing heap.
23:01:26 <bos> if in an imperative language, see python's heapq module.
23:02:36 <mauke> reading ...
23:10:35 <hpaste>  (anonymous) pasted "big file finder code" at http://hpaste.org/1002
23:11:57 <bos> that's not as general as i'd write, but it's a start.
23:12:12 <jaredj> did i abstract the wrong thing?
23:12:17 <bos> no.
23:12:48 <bos> but you can do more interesting stuff with a more complex predicate.
23:12:56 <jaredj> t
23:13:12 <bos> and it doesn't make the code significantly more complex.
23:15:41 <bd_> hm, does Control.Exception.bracket not catch ExitException?
23:15:53 <bd_> ... thrown asynchronously
23:18:41 <jaredj> bos: brainfart. what are some more interesting predicates?
23:18:57 <bd_> ... okay, this is weird. If I change it to throw a dynamic exception, and print that exception before returning from main, bracket runs the cleanup operation correctly. If I instead use `catchDyn` throw, it exits directly
23:19:52 <sorear> bd_: you should generally use throwIO instead, when available
23:19:53 <bos> jaredj: your predicate might take a seed of some kind, and a list of directories and files, and return (new seed, filtered list of directories)
23:20:17 <bd_> :t throwIO
23:20:19 <lambdabot> Not in scope: `throwIO'
23:20:33 <sorear> :t Control.Exception.throwIO
23:20:36 <lambdabot> forall a. GHC.IOBase.Exception -> IO a
23:20:37 <bos> so it would have type a -> [FilePath] -> (a, [FilePath])
23:20:38 <jaredj> bos: ah yes, that's what you said
23:20:46 <bd_> oh
23:20:47 <bd_> aha
23:21:04 <bd_> ... didn't help
23:21:09 <bd_> ?paste
23:21:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:21:37 <bos> and each invocation gets passed the seed returned from the prior invocation.
23:21:41 <hpaste>  bd_ pasted "weird issues with throwTo and ExitExceptions... take a look at unwrapDyn" at http://hpaste.org/1003
23:21:41 <sorear> I didn't expect it to help in this case, but as a general rule the optimizer is allowed to take more liberties with throw than throwIO
23:23:03 <bos> jaredj: so then your "find with depth" predicate would become \depth dirs -> if depth == maxDepth then [] else dirs
23:23:12 <bd_> note that socketLoop occurs in the main thread, so the exception should pass through bracket before hitting unwrapDyn
23:23:18 <bd_> and indeed it does - provided I do not re-throw!
23:24:17 <jaredj> bos: if i just make it a -> [FilePath) -> (a, IO [FilePath]), then it could be my whole find function ... ?
23:24:19 <bos> jaredj: and your "always recurse" predicate is just (,)
23:24:36 * jaredj may be too tired
23:24:47 <bos> why would you want to put IO in there?
23:24:54 <jaredj> so the predicate can stat things
23:27:09 <bos> jaredj: you could do that, i suppose.
23:30:29 <dons> ?users
23:30:29 <lambdabot> Maximum users seen in #haskell: 336, currently: 292 (86.9%), active: 36 (12.3%)
23:31:16 <dons> hi ho, hi ho, its off to QuickCheck I go. da de da de da
23:31:30 <bd_> okay, I'm a fool. Note to self, stdout is not flushed on termination.
23:32:20 <bos> it's a bit odd that the routines in System.Directory that look at a getFileStatus result aren't pure
23:33:05 <jaredj> ?hoogle getFileStatus
23:33:05 <lambdabot> No matches found
23:33:14 <jaredj> ?hoogle System.Posix.Files.getFileStatus
23:33:15 <lambdabot> No matches, try a more general search
23:33:19 <jaredj> wth?
23:33:32 <bos> old database.
23:33:38 <jaredj> muh.
23:34:32 <jaredj> how different is haskell' going to be?
23:34:42 <encryptio> how would i define the fractal sequence [1,2,1,4,1,2,1,8,1,2,1,4,1,2,1,16,...] ?
23:35:42 <dolio> It probably wont' be very different from GHC with all its extensions.
23:35:52 <dolio> Although, it may lack some of them.
23:36:35 <int-e> > let xs = 1:xs >>= \x -> [2*x, x] in xs
23:36:36 <lambdabot>  [2,1,4,2,2,1,8,4,4,2,4,2,2,1,16,8,8,4,8,4,4,2,8,4,4,2,4,2,2,1,32,16,16,8,16,...
23:36:48 <int-e> > let xs = 1:(xs >>= \x -> [2*x, x]) in xs
23:36:49 <lambdabot>  [1,2,1,4,2,2,1,8,4,4,2,4,2,2,1,16,8,8,4,8,4,4,2,8,4,4,2,4,2,2,1,32,16,16,8,1...
23:38:13 <int-e> > let xs = 1:(xs >>= \x -> [2*x, 1]) in xs
23:38:14 <lambdabot>  [1,2,1,4,1,2,1,8,1,2,1,4,1,2,1,16,1,2,1,4,1,2,1,8,1,2,1,4,1,2,1,32,1,2,1,4,1...
23:38:31 <jaredj> woot
23:38:43 <encryptio> sweet. now i just have to understand it. =p
23:39:23 <int-e> > let xs = concat $ transpose [repeat 1, map (2*) xs] in take 20 xs
23:39:24 <lambdabot>  [1,2,1,4,1,2,1,8,1,2,1,4,1,2,1,16,1,2,1,4]
23:39:40 * jaredj bows
23:42:16 <int-e> > fix ((1:) . (>>= (:[1]) . (2*))) -- because everyone loves pointfree code.
23:42:18 <lambdabot>  [1,2,1,4,1,2,1,8,1,2,1,4,1,2,1,16,1,2,1,4,1,2,1,8,1,2,1,4,1,2,1,32,1,2,1,4,1...
23:42:45 <desp> wow
23:42:53 <encryptio> that one actually makes more sense than the first working one
23:42:55 <jaredj> point free .... or pointless?
23:42:58 * desp discovers probabilistic programming in Haskell
23:43:06 <int-e> encryptio: that is the first working one
23:43:22 <encryptio> let xs = 1:(xs >>= \x -> [2*x, 1]) in xs -- does it
23:43:25 * jaredj bows then runs away
23:43:28 <desp> is anyone using Haskell on Mac OS X here?
23:43:32 <encryptio> desp: yo
23:43:42 <desp> encryptio: are you using Cabal?
23:43:53 <encryptio> i'm not developing for it
23:43:55 <encryptio> but i use it
23:44:12 <desp> cause I installed ghci from fink, hugs from darwinports, and I have no Cabal, nor any idea how should I be setting up my Haskell env
23:44:23 <desp> I'm inclined to hate darwinports
23:44:36 <encryptio> install ghc-dev from fink - that'll give you an actual compiler.
23:44:49 <desp> right, I have that.
23:45:11 <encryptio> you should be able to just runghc the Setup.hs wherever and it will work.. it does for me
23:45:26 <desp> I keep reading about this nice Cabal system for installing packages
23:45:31 <desp> is that included with ghc?
23:45:45 <encryptio> yes.
23:45:57 <encryptio> there isn't a general interface to a "package list" or anything like that
23:46:00 <desp> ahh.
23:46:03 <encryptio> it's more distributed, like rpm
23:46:22 <desp> okay, thanks.
23:46:55 <encryptio> there is hackage, which is a site that collects cabal packages (i think)
23:47:07 <encryptio> @where hackage
23:47:07 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
23:49:02 <desp> right, so I just download them from there, and run the included file. ok
23:49:27 <jaredj> concatMapM?
23:49:37 <desp> I mistakenly assumed it'd be more similar to RubyGems
23:51:13 <int-e> > 1 : fix (([2,1]++) . intersperse 1 . map (2*))
23:51:14 <lambdabot>  [1,2,1,4,1,2,1,8,1,2,1,4,1,2,1,16,1,2,1,4,1,2,1,8,1,2,1,4,1,2,1,32,1,2,1,4,1...
23:52:31 <int-e> sadly, intersperse is stricter than it could be; intersperse 1 (2:undefined)  is  undefined, not  2:undefined.
23:53:18 <jaredj> what's the opposite of (,)
23:53:44 <encryptio> fst and snd, or pattern matching
23:53:44 <int-e> fst and snd, or curry :)
23:53:49 <jaredj> i have (a,b) and i want to call f a b
23:53:49 <encryptio> ah, curry too
23:54:02 <encryptio> :t curry
23:54:04 <int-e> @type uncurry
23:54:04 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
23:54:06 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
23:54:41 <jaredj> ah, so (uncurry f)
23:55:59 <jaredj> i think the way i'm thinking about this finder, it's going to need the list monad
