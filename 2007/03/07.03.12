00:00:20 <encryptio> functional as opposed to raster. like raytracing vs. scanline.
00:02:15 * encryptio has long been a fan of abstracting away pixels from graphics, despite its disadvantages in sharpness
00:02:32 <Pastorn> @instances IO
00:02:33 <lambdabot> Couldn't find class `IO'. Try @instances-importing
00:02:39 <Cale> sharpness?
00:02:41 <Pastorn> @instances IO a
00:02:42 <lambdabot> Couldn't find class `IO a'. Try @instances-importing
00:02:48 <dons> IO isn't a class
00:02:49 <encryptio> Cale: font hinting is a good example
00:02:54 <dons> @instances Monad
00:02:56 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
00:03:06 <Cale> oh, sure -- but that's more a property of the filtering you do at the end
00:03:14 <Pastorn> @src Monad.IO
00:03:14 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
00:03:30 <dons> @src IO
00:03:31 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
00:03:31 <encryptio> Cale: but without the pixels going down to the text drawing engine, you can't have font hinting work
00:03:40 <Cale> right
00:03:41 <dons> @src IO (>>=)
00:03:41 <lambdabot> m >>= k     = bindIO m k
00:03:46 <dons> @src bindIO
00:03:47 <lambdabot> bindIO (IO m) k = IO ( \ s ->
00:03:47 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
00:03:48 <encryptio> and if you do that, you've ruined the whole "abstract away pixels" thing
00:04:06 <Cale> Well, you can still abstract them away for most of the program.
00:04:33 <encryptio> but what if you rotate text?
00:04:42 <Pastorn> i'm doind this http://www.haskell.org/tmrwiki/PhilippaCowderoy_2fWIP_2fMonadArticleThingy but I can't get the first code box to load i ghci
00:04:42 <dons> people interested in mentoring SoC projects should add their names to http://hackage.haskell.org/trac/summer-of-code/wiki/People
00:04:45 <lambdabot> Title: People - Haskell.org Google Summer of Code - Trac
00:04:45 <lambdabot> Title: PhilippaCowderoy/WIP/MonadArticleThingy - TmrWiki, http://tinyurl.com/ywrst3
00:04:52 <dons> bos_: .... :-)
00:05:00 <Cale> Well, most hinting doesn't really deal with that well does it?
00:05:10 <encryptio> nope.
00:05:15 <Cale> There are probably ways to try.
00:05:26 <kc5tja> I have defined a dyadic operator +++ in one of my own modules.  How do I import it via import Foo (blah)?
00:05:33 <kc5tja> Do I have to wrap it in back-ticks?
00:05:45 <Cale> I'd like to see a hinting engine which didn't involve so many hints :)
00:05:49 <dons> import Foo ((+++))
00:05:55 <kc5tja> Ahh, thanks.
00:06:31 <sjanssen> dons: when does Haskell.org know for certain that they're a mentoring organization?
00:06:36 <Pastorn> nevermind, i should read my error messages more carefully
00:07:10 <encryptio> i first tried the abstraction thing with a continuous function of time for an audio synthesis program in perl... lots of lambdas... porting it was my first big haskell project.
00:07:17 <dons> "The list of selected organizations will be shown here on March 14th."
00:07:37 <glguy> I think that articles like this one http://programming.reddit.com/info/19kq3/comments are great if they serve to filter out the kind of people who would be filtered out by them :)
00:07:39 <lambdabot> Title: Why a career in computer programming sucks (reddit.com)
00:07:41 <dons> then
00:07:41 <dons>  March 14: Student application period opens
00:07:41 <dons>  March 24: Student application deadline
00:08:19 <sjanssen> yikes, that's coming up soon
00:08:39 <dons> ok. so my plan wrt. the network lib, dcoutts arrives here tomorrow, i'm going to tie him down until c2hs can generate a basic binding to libcurl
00:08:44 <dons> then we'll package that up and sell it :-)
00:08:56 <dons> hscurl, easy bytestring network io
00:09:31 <sjanssen> poor dcoutts
00:09:37 <dons> sjanssen: feel like fixing X11, xhb or something for SoC :-)
00:09:42 <dons> or bossing someone else into doing it?
00:11:15 <kc5tja> :t Prelude.map
00:11:18 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:11:19 <dolio> So, computer programming sucks because it's all building e-commerce apps in the flavor of the week language?
00:11:31 <sjanssen> I need to ask Sven Panne where he got with xhb
00:11:41 <mwc> It's an art. It's fun.
00:12:32 <sjanssen> dons: the idea of a "100% Haskell" window manager is sexy
00:12:39 <Korollary> It's definitely not all e-commerce.
00:12:48 <sjanssen> no stupid xlib to hold us back
00:13:16 <kc5tja> :t Data.ByteString.concat
00:13:19 <lambdabot> [Data.ByteString.Base.ByteString] -> Data.ByteString.Base.ByteString
00:13:19 <mwc> Korollary: that article seems to focus on grunt work too. Coding little one off things in VB
00:13:37 <kc5tja> So, I'm confused.
00:13:44 <mwc> Clearly the software engineering experience you develop doesn't depreciate
00:13:51 <kc5tja> Why is my code, which is given a list of byte strings, not type-checking?
00:13:53 <dons> sjanssen: working out a proper high level combinator set for X would be worth it (Fudgets or something?)
00:13:58 * kc5tja rams head into wall.
00:14:00 <dons> since X11 as it is is too low
00:14:09 <mwc> I could probably write haskell at the same level as dons or even Hughes
00:14:23 <mwc> the ability to create working efficient designs isn't even close though
00:14:24 <Korollary> Wow. This guy hasn't been around for long, but he seems to have figured out everything...
00:14:32 <sjanssen> dons: a window manager probably needs to be at a fairly low level
00:14:42 <Korollary> "This sucks, that sucks, too." Who is this? The next Steve Yegge?
00:14:44 <mwc> sjanssen: just Xlib and ICCCM
00:14:50 <dons> sjanssen: i think there's some basic window manager abstractions in there though
00:14:52 <sjanssen> and anything above that I'd use a sane toolkit, like gtk
00:15:04 <dons> at least, it could all be cleaner
00:16:07 <ozone> @karma+ Korollary
00:16:07 <lambdabot> Korollary's karma raised to 7.
00:16:11 <ozone> (for the next Steve Yegge quote)
00:26:20 <Cale> I've never been all that impressed with Steve Yegge. I don't get what people see in his articles.
00:26:39 <Cale> I haven't read too many of them though.
00:26:41 <Botje> he's just paving the road for Haskell world domination.
00:26:58 <Botje> and taking a chunk out of Java weenies while he's at it
00:27:16 <Cale> Has he ever said anything about Haskell?
00:27:38 * dufflebunk wishes there was a better environment for making GUIs easily than Java
00:28:09 <Botje> he said one sentence about it two or three articles ago
00:28:16 <Adamant> he likes the Lisps better than Haskell, I think.
00:28:24 <Adamant> but he hates everything.
00:28:29 <Botje> something about haskell being "nice to play with, but not
00:28:32 <hpaste>  sm pasted "how to condense this?" at http://hpaste.org/942
00:28:33 <Botje> much else"
00:28:48 <Cale> "It's true that with some effort you can build beautiful, lithe marionettes with Haskell. But they will forever remain little wooden Pinocchio, never to be granted their wish for boyhood by the Good Fairy. Haskell has little or no notion of dynamic code loading or runtime reflection; it's such an alien concept to them that it's difficult even to discuss why they might be useful with a Haskell fan: their world-view jus
00:28:48 <Cale> t doesn't incorporate the idea of software that grows while it's alive and breathing."
00:28:51 <Botje> sm: heat up until it vaporizes, then go stand under a cooling plate
00:29:01 <Cale> Apparently he's never heard of hs-plugins.
00:29:06 <sjanssen> sm: use fmap
00:29:09 <Adamant> yeah, I think Phillipa had some words about that.
00:29:14 <Cale> Yeah, looks like it
00:29:27 <sm> > :t fmap
00:29:27 <lambdabot>  Parse error
00:29:38 <Korollary> You dont understand. SY doesn't need to read about anything to render judgment.
00:29:46 <dons> i guess he just doesn't do his research
00:29:48 <sm> aiee.. that again :)
00:30:03 <dons> @slap SteveYegge
00:30:04 <Cale> His articles on programming are full of words with no code.
00:30:04 * lambdabot beats up SteveYegge
00:30:11 <sm> how would it help me here sjanssen ?
00:30:21 <dons> Cale: yeah, that's a bit suspicious
00:30:22 <hpaste>  sjanssen annotated "how to condense this?" with "use fmap" at http://hpaste.org/942#a1
00:30:23 <Cale> Those words also don't seem to say all that much.
00:30:36 <Cale> The concept density is very low.
00:30:43 <Korollary> Cale: what matters is that it's "loooooooong".
00:31:12 <pejo> What amazes me is why you waste your time with his works, since you know what it will contain beforehand. :-)
00:31:25 <Adamant> here is a weird idea I have. I want to write an application in dynamic typing to speed development. then be able to migrate the application to a fully typed fancypants static typing system when I am done and trying to improve reliability, security, etc.
00:31:26 <Cale> Paul Graham tends to annoy me in the same way.
00:31:36 <Cale> pejo: I haven't wasted too much time.
00:31:39 <Adamant> gradually, of course.
00:31:51 <sjanssen> sm: is that better?
00:31:54 <hpaste>  dolio annotated "how to condense this?" with "Perhaps?" at http://hpaste.org/942#a2
00:31:58 <Korollary> What's with dynamic typing = fast development ?
00:32:00 <Adamant> has anyone done any work on this in theoretical CS?
00:32:07 <dons> Adamant: just use strong static typing, but use 'unsafeCoerce#' whenever you get stuck
00:32:23 <sm> sjanssen: beautiful, thx
00:32:38 <sm> it's getting clearer
00:32:47 <sm> (fmap & friends)
00:32:47 <dons> Adamant: well, i certainly tend to start out kind of untyped (lots of strings and so on), and then move to more structured types as the program domain becomes more understood
00:32:56 <Botje> Adamant: or use lisp, which has optional typing
00:33:19 <dons> its questionable though, the idea of using dynamic typing to 'speed development'
00:33:29 <dons> i'd like some data on that
00:33:29 <Cale> Optional typing in the sense of lisp is worth only about 10% of what real types are.
00:33:43 <dons> and the only thing i can think of is the ICFP contest, where haskell types don't seem to get in the way
00:33:57 <Adamant> dons, I'm just talking personal experience
00:33:58 <sjanssen> dons: you can certainly develop bugs more quickly with dynamic typing
00:34:02 <dolio> Some lisp can probably do something like that.
00:34:12 <Adamant> my first really "advanced" languages were dynamic
00:34:21 <Adamant> so I've kind of imprinted on them
00:34:29 <Adamant> I'm not saying it's true for everyone.
00:34:54 <sm> dolio: nice also.. that's what I was shooting for but missed
00:35:07 <Korollary> But you expect people to publish papers on it as if it's true for everyone.
00:35:09 <dolio> sm: Yeah. fmap is probably nicer.
00:35:18 <narain> i have a feeling that migrating a dynamically typed application to a strong type system would ... not be enjoyable
00:35:26 <Cale> People seem to like the idea that you can write code and modify the system as it's running. If types are a problem there, because the type of something is changing, then they'd probably still be a problem in an untyped language, it's just that your program will break.
00:35:31 <dons> well, you'd find the bugs as you went along
00:35:35 <sm> my other question: is this still lazy on stdin ? will it stream ?
00:35:44 <dons> it would be a good way to identify flaws (a bit like using QuickCheck on haskell)
00:35:52 <dons> of course, once you're done, you'd still hvae to use QuickCheck
00:35:59 <dons> so just use the strong types in the first place :-)
00:36:04 <sjanssen> sm: yes, hGetContents is lazy
00:36:09 <sm> very cool
00:36:11 <Botje> sm: that's what your do notation desugars to
00:36:50 <Cale> Also, you have the problem that when you're changing a system as its running, you might put it into a working, but unreachable state.
00:36:50 <dolio> "WHY PUBLISH CS PAPERS WITHOUT CODE?" :)
00:37:10 <dufflebunk> Does math count as code?
00:37:15 <Botje> Type-level binary arithmetic library O_O
00:37:20 <Cale> dolio: Most of the CS papers I read have code in them. Snippets, at least.
00:37:26 <Korollary> code is math in a sense
00:37:36 <dolio> I don't think math counts as far as the article goes, no.
00:37:42 <Cale> I usually don't want to read pages and pages of code in the context of an article.
00:37:47 <dolio> Yeah, I haven't seen a lot of papers without code, either.
00:37:57 <kc5tja> OK, testing the CUT parser with ByteStrings.  Let's see what kind of performance boost we get.
00:38:10 <dolio> The one that pops to mind is Banannas, Lenses ...
00:38:11 <Cale> I'd rather read the equations and logical reductions behind that code.
00:38:14 <dons> wow, that took a while, kc5tja. i'm surprised it was so long to rewrite
00:38:24 <dons> kc5tja: what cause the difficult in porting?
00:38:32 <kc5tja> dons: I didn't rewrite it; I incrementally patched it.
00:38:34 <dolio> But that was all about a beginner's guide to category theory as applied to functional programming.
00:38:44 <Cale> The rest is implementation details, unless that's what you're actually discussing.
00:38:55 <kc5tja> dons: I had to "ripple" propegate type changes, inserting B.packs here and B.unpacks there, etc.
00:39:13 <kc5tja> Make one change, compile, make another change, compile, etc. until everything worked.
00:39:14 <Cale> I actually don't understand how Bananas/Lenses/etc. relate to category theory yet.
00:39:15 <dons> hmm. unpacks eh
00:39:19 <dons> that's not a good sign...
00:39:29 <Cale> Other than their use of the postfix -morphism.
00:39:30 <kc5tja> dons: I only have 2 unpacks in Main.hs, so I can putStr.
00:39:36 <kc5tja> Everything else is done packed.
00:39:38 <dons> hmm? use B.putStr
00:39:46 <dons> you really really don't want to unpack to do IO
00:39:47 <Korollary> Cale: I don't remember it well, but I don't remember any CT in it.
00:39:51 <kc5tja> Oh, I also needed to unpack for the benefit of matchRegex.
00:39:52 <Cale> I can see that there likely are category-theoretic interpretations of them.
00:39:54 <kc5tja> So make that 6 unpacks.
00:39:58 <dons> use the bytestring regex lib
00:40:03 <Cale> But what those are escapes me. :)
00:40:04 <dons> again, unpacking just to call into C is bad
00:40:12 * dons rules: never use unpack
00:40:24 <dons> if you do, expect slow downs
00:40:32 <dolio> Maybe I'm remembering the wrong paper.
00:40:36 <dons> kc5tja: if you want I can take a peep at the code
00:40:43 <kc5tja> Well, unpacking ought not cause substantial performance losses, I'd think.  The majority of the code is tacking strings together with appends.
00:40:55 <dons> oh, lazy or strict bytestrings?
00:41:05 <dons> appen is O(n) on strict bytestrings
00:41:06 <dons> best to avoid it
00:41:09 <kc5tja> Whatever is in Data.ByteString.Char8
00:41:12 <dons> use a dlist, or a lazy bytestring
00:41:21 <dons> yes, so append for that is O(n)
00:41:26 <kc5tja> dons: You don't offer any alternative for ByteStrings.
00:41:28 <dons> it has to allocate a new arra, and copy
00:41:36 <dons> kc5tja: yes, Data.ByteString.Lazy
00:41:49 <dons> much cheaper append
00:41:58 <dons> anyway, see how it goes, ping me if you want a review
00:42:27 <kc5tja> If it's this hard to get any kind of string performance from Haskell, I have to wonder how anyone would want to use it.  :)
00:42:28 <dons> its important not to treat strict ByteStrings as strings (the complexity is quite different)
00:42:41 <kc5tja> Sounds like it's more efficient at number crunching than string crunching.
00:43:00 <dons> well, i'm talking about how to get C like performance
00:43:06 <kc5tja> Right.
00:43:08 <dons> if you just want python speed, do proceed.
00:43:17 <kc5tja> I don't see how lazy bytestrings will offer C-like performance via thunks.
00:43:38 <dons> they have better complexity for many key operatoins
00:43:40 <dons> in space and time
00:43:49 <dons> than the euqivalent C string ops
00:44:13 <kc5tja> Is it hard to change from Char8 to Lazy?
00:44:17 <sjanssen> kc5tja: the rules for efficient ByteString code is quite similar to the rules in writing efficient C string code
00:44:19 <kc5tja> Or can I just change the qualified import?
00:44:24 <Cale> There's a lazy version of Char8
00:44:30 <dons> get some numbers for your strict code first
00:44:38 <sjanssen> kc5tja: change the import to Data.ByteString.Lazy.Char8, and you should be good to go
00:44:49 <dons> but if you really are using a lot of 'append' then try the .Lazy.Char8 data type instead
00:44:59 <dons> here's what I mean about lazy bytestrings, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
00:45:02 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
00:45:06 <kc5tja> When would I want to use Char8 versus Lazy.Char8?
00:45:07 <Pastorn> @type (>>=)
00:45:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:45:13 <dons> kc5tja: you wouldn't
00:45:26 <sjanssen> kc5tja: Lazy is generally the best choice
00:45:46 <Pastorn> why does that b have to be in a monad?
00:45:49 * kc5tja is curious: why offer the strict choice then?
00:45:50 <dons> its useful to pay attention to the complexity annotations in the docs
00:46:05 <dons> strict is also useful for some things. and you need them to build lazy bytestrings
00:46:14 <sjanssen> kc5tja: because there are other cases where you want strictness
00:46:19 <dons> they optimise a bit better too
00:47:02 <kc5tja> I should note that IO is restrained to the Main module; everything else is written pure functionally.
00:47:18 <kc5tja> It's currently at 100MB of heap usage.
00:47:30 <kc5tja> brb -- laundry run (last one)
00:47:31 <dons> the idea is that you should never need to unpack. any unpack will kill performance.
00:47:47 <dons> as will excessive append
00:47:59 <narain> how can i write  (f $ g $ h x) y  in a clearer manner?
00:48:13 <dons> ?pl (f $ g $ h x) y
00:48:14 <lambdabot> f (g (h x)) y
00:48:24 <sjanssen> narain: I'd write f . g $ h x y
00:48:39 <dons> f . g . h x $ y
00:48:52 <dons> though that might be a bit obfuscated
00:49:06 <narain> sjanssen: isn't that  f (g (h x y)) ?
00:49:33 <sjanssen> narain: yes, it is.  The original code is also equivalent to that
00:49:35 <narain> dons: maybe...
00:49:49 <sjanssen> oh no, I'm wrong
00:50:23 <sjanssen> narain: yes, that code is a bit tricky :)
00:50:34 <narain> dons: that doesn't work either
00:50:45 <dons> ?check \f g h x y -> let _=(x::I);_=(y::I);_=(g::I->I);_=(f::I->I); in f (g (h x y)) == (f . g $ h x y)
00:50:45 <narain> hmm, i have  (f (g (h x))) y
00:50:46 <lambdabot>  OK, passed 500 tests.
00:50:54 <narain> oh
00:51:04 <narain> clearly i must have mistyped something then
00:51:14 <dons> ?check \f g h x y -> let _=(x::I);_=(y::I);_=(g::I->I);_=(f::I->I); in f (g (h x y)) == (f $ g $ h x) y
00:51:15 <lambdabot>  Couldn't match expected type `I' against inferred type `I -> I'
00:51:21 <dons> ?check \f g h x y -> let _=(x::I);_=(y::I);_=(g::I->I);_=(f::I->I); in f (g (h x y)) == ((f $ g $ h x) y)
00:51:22 <lambdabot>  Couldn't match expected type `I' against inferred type `I -> I'
00:51:44 <dons> ?check \f g h x y -> let _=(x::I);_=(y::I);_=(g::I->I);_=(f::I->I); in (f (g (h x)) y) == ((f $ g $ h x) y)
00:51:45 <lambdabot>  Couldn't match expected type `I -> a' against inferred type `I'
00:51:57 <sjanssen> narain: f (g $ h x) y reads the best to me
00:52:06 <dons> ah, @pl bug?
00:52:17 <sjanssen> dons: pl bug?
00:52:23 <dons> ?pl (f $ g $ h x) y
00:52:23 <lambdabot> f (g (h x)) y
00:52:32 <dons> oh, my type inf. bug
00:52:39 <sjanssen> dons: we just misread narain's original request
00:53:05 <narain> sjanssen: ah that looks good
00:53:41 <dons> ?type \f g h x y -> f (g $ h x) y
00:53:44 <lambdabot> forall t t1 a b t2. (b -> t1 -> t2) -> (a -> b) -> (t -> a) -> t -> t1 -> t2
00:54:04 <sjanssen> @type \f g h x y -> f . g $ h x y
00:54:06 <lambdabot> forall t t1 b c a. (b -> c) -> (a -> b) -> (t -> t1 -> a) -> t -> t1 -> c
00:54:09 <narain> well in my code i actually have  (f $ f $ f x) y
00:54:21 <narain> ?ty \f x y -> (f $ f $ f x) y
00:54:24 <lambdabot> forall t t1. ((t -> t1) -> t -> t1) -> (t -> t1) -> t -> t1
00:55:33 <dons> ?check \f g h x y -> let _=f::I->I->I;_=g::I->I;_=h::I->I;_=x::I;_=y::I in (f (g $ h x) y) == ((f $ g $ h x) y)
00:55:34 <lambdabot>  OK, passed 500 tests.
00:55:48 <kc5tja> Huh, it actually took LONGER with ByteString than it did with normal Haskell strings.
00:55:52 <kc5tja> 16 minutes versus 11.
00:56:11 <sjanssen> kc5tja: those unpacks and appends are probably killing you
00:56:19 <narain> i guess this sort of thing doesn't come up that often
00:57:00 <narain> how about f . f . f ?
00:57:08 <narain> is there a neat way to write that?
00:57:26 <dons> kc5tja: that's not surprising if you're using append as you'd used in on [Char]
00:57:46 <dons> the complexity changes, but the code didn't, so you lose on the roundabouts
00:58:06 <sjanssen> narain: f . f . f is as good as you'll get
00:58:31 <sjanssen> narain: for much deeper nestings I'd use iterate f x0 !! n
00:58:49 <sjanssen> or (!! n) . iterate f
00:59:01 <narain> ah. ok then
00:59:13 <dons> take n . foldr (.) (repeat f) -- or something :-)
00:59:16 <narain> i thought something to do with replicateM
00:59:25 <narain> dons: whoa
00:59:34 <dons> nah, that code doesn't work :-)
00:59:35 <narain> what does replicateM do on functions?
00:59:43 <dons> :t replcateM
00:59:44 <dolio> foldr (.) id (replicate 3 f)
00:59:46 <lambdabot> Not in scope: `replcateM'
00:59:56 <dons> :t replicateM
00:59:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
01:00:01 <sjanssen> @type replicateM `asTypeOf` (\_ -> undefined)
01:00:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
01:00:30 <sjanssen> @type \x -> replicateM (x `asTypeOf` (\_ -> undefined))
01:00:33 <lambdabot>     Couldn't match expected type `Int' against inferred type `t -> a'
01:00:33 <lambdabot>     In the first argument of `replicateM', namely
01:00:54 <sjanssen> @type \n x -> replicateM n (x `asTypeOf` (\_ -> undefined)) -- last time, I promise
01:00:56 <lambdabot> forall t a. (Monad ((->) t)) => Int -> (t -> a) -> t -> [a]
01:01:41 <narain> > replicateM 3 (+1)
01:01:43 <lambdabot>  <Integer -> [Integer]>
01:01:46 <narain> > replicateM 3 (+1) 0
01:01:47 <lambdabot>  [1,1,1]
01:01:52 <sjanssen> narain: replicateM in the ((->) a) monad isn't very useful
01:02:00 <narain> that didn't do much at all!
01:02:15 <dolio> > foldr (.) id (replicate 3 (+1) 0
01:02:16 <lambdabot>  Parse error
01:02:21 <dolio> > foldr (.) id (replicate 3 (+1)) 0
01:02:22 <lambdabot>  3
01:02:25 <narain> sjanssen: yes, i see now. anticlimactic
01:03:44 <sjanssen> > replicateM 3 "01" -- much more interesting in the [] monad
01:03:46 <lambdabot>  ["000","001","010","011","100","101","110","111"]
01:04:16 <dolio> ?t filterM
01:04:16 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
01:04:21 <dolio> ?type filterM
01:04:23 <narain> > replicateM 3 "abc"
01:04:24 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
01:04:25 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
01:04:45 <sjanssen> > filterM (const [True, False]) "abc" -- another fun one
01:04:47 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
01:05:06 <dolio> > filterM (const [False..]) [1..5]
01:05:06 <lambdabot>  Parse error
01:05:35 <dolio> > [False ..]
01:05:37 <lambdabot>  [False,True]
01:05:42 <dolio> > [False..]
01:05:42 <lambdabot>  Parse error
01:05:48 <dolio> > filterM (const [False ..]) [1..5]
01:05:49 <lambdabot>  [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,3...
01:05:54 <dolio> > filterM (const [False ..]) [1..]
01:05:57 <lambdabot>  Exception: stack overflow
01:06:01 <narain> even though i'm rather comfortable with using Maybe, IO and State, i still can't understand foldM, replicateM and the like.
01:06:12 <sjanssen> dolio: False.. parses as the '.' operator from the False module
01:06:23 <dolio> Ah, of course.
01:06:56 <narain> :t False..
01:06:58 <lambdabot> parse error on input `False..'
01:07:00 <narain> :t (False..)
01:07:03 <lambdabot> Couldn't find qualified module.
01:07:06 <narain> :t False..()
01:07:06 <sjanssen> and you get a parse error because that isn't a valid place for an operator to appear
01:07:09 <lambdabot> parse error on input `False..'
01:07:11 <narain> :t False.(.)
01:07:14 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
01:07:14 <lambdabot>     In the first argument of `(.)', namely `False'
01:07:25 <narain> :(
01:07:42 <dons> sjanssen: i've been hammering xmonad all day today, only one issue spotted (and fixed) so far :-)
01:08:14 <dons> getting xerror handlers right is  kinda important, since X really doesn't guarantee to do sensible things wrt. race conditions
01:13:14 <sjanssen> dons: my C is a bit rusty, should the last line in xerror have return defaultErrorHandler(dpy,ee); ?
01:13:29 <sjanssen> I'm talking about the cbits in X11-extras
01:14:37 <dons> oh hmm.
01:15:20 * dons scratches head at higher order programming in C
01:15:32 <sjanssen> is there some sort of explicit return rule in C?
01:15:44 <sjanssen> s/explicit/implicit
01:15:55 <dons> ah no tail calls eh :-)
01:16:03 <dons> yeah, i think it needs a return. dwm has that
01:16:19 <dons> and late last night I was thinking: hmm? return? just call the IO action and be done
01:16:24 <dons> you don't want to box up your function
01:18:15 <dons> how good's your FFI code, sjanssen ? can we even register a haskell function to XsetErrorHandler?
01:18:46 <sjanssen> I don't really understand all the FunPtr stuff
01:18:58 <dons> its scary that I can add or remove a 'return' and still hvae things type check
01:19:02 * dons is spoilt by types
01:20:57 <mwc> dons: well, there's an implicit return at the end of a void function. If the return isn't there there'll be a warning
01:21:14 <mwc> "Warning, control reaches end of non-void function." IIRC
01:21:23 <dons> it was supposed to be a tail call, now I'm not sure what it was doing.
01:21:44 <mwc> falling off the end... it returns to the caller but the return value is undefined.
01:21:52 <dons> yeah :-)
01:21:56 <dons> oops.
01:21:58 <mwc> besides, you can't tail call
01:22:02 <mwc> gotta write that as a loop
01:22:12 <dons> hunk ./cbits/XUtils.c 26
01:22:12 <mwc> go to it, boy.
01:22:12 <dons> -    defaultErrorHandler(dpy,ee);
01:22:12 <dons> +    return defaultErrorHandler(dpy,ee);
01:22:12 <dons> Shall I record this change? (1/?)  [ynWsfqadjkc], or ? for help: y
01:22:12 <dons> What is the patch name? C doesn't work like that
01:22:36 <sjanssen> dons: I see that there is freeFunPtr, but I have no idea how to create one
01:22:55 <dons> I think they wrap C functions as Haskell values, sjanssen
01:23:17 <dons> so you can foreign import a function ptr, and get a FunPtr type
01:25:16 <ClaudiusMaximus> sjanssen: you create them like this:  foreign import ccall "wrapper" wrapNew :: NewMethod -> IO (FunPtr NewMethod)
01:26:05 <dons> ClaudiusMaximus: oh, a ffi decl soley to get the FunPtr wrapper?
01:26:07 <dons> tricksy
01:26:33 <ClaudiusMaximus> dons: yes
01:26:46 <sjanssen> CladiusMaximus: and you'd also write an accompanying defininition for wrapNew?
01:27:04 <ClaudiusMaximus> sjanssen: afaik, that *is* the definition
01:27:40 <dons> sjanssen: yeah, it just generates a wrapper stub.
01:27:43 <sjanssen> ahh, so NewMethod is a typedef for some function type?
01:27:49 <dons> ClaudiusMaximus: where'd you pick up that trick?
01:27:56 <dons> sjanssen: yeah, (Int -> Bool) say?
01:27:59 <ClaudiusMaximus> dons: reading the manual?
01:28:03 <mwc> Nir, why is SSL not part of the standard commpiler libs?
01:28:12 <ClaudiusMaximus> dons: or asking here
01:29:13 <ClaudiusMaximus> in my code, i have "type NewMethod = Ptr Symbol -> CInt -> Ptr Atom -> IO (Ptr Object)"
01:29:23 <sjanssen> this is good news
01:29:33 <sjanssen> die cbits, die!
01:29:50 <dons> ClaudiusMaximus: that's precisely what I was looking for last night
01:30:01 <dons> sjanssen: note we need a bunch of #enum's for the types to inspect in the error handler
01:35:54 <sjanssen> dons: of course, more FFI boilerplate.  sigh.
01:36:17 <dons> swings and roundabouts
01:40:45 <Cheery> I have a set, one in order, what ways do I have to represent permutations for the elements of that set?
01:41:51 <Cheery> I'd rather like to represent permutations so that the elements of that set does not matter.
01:44:31 <kolmodin> don't you want to write a pure haskell X client while you're at it, instead of wrapping the C libs? :)
01:45:01 <kolmodin> there was some traffic about this on the mls, didn't it lead anywhere?
01:56:38 <benja_> dons: would you have any comments on http://hackage.haskell.org/trac/summer-of-code/ticket/1114 ?
01:56:40 <lambdabot> Title: #1114 (Sandboxed Haskell) - Haskell.org Google Summer of Code - Trac
02:03:41 <sjanssen> kolmodin: Sven Panne might be working on it
02:10:54 <dmwit_> Does anyone have a link explaining the syntax for records in Haskell?
02:15:44 <Vq^> dmwit_: http://www.haskell.org/onlinereport/decls.html#field-labels
02:15:45 <lambdabot> Title: The Haskell 98 Report: Declarations
02:16:18 <dmwit_> Great, thanks!
02:18:26 <boegel> somebody native French-speaking in here?
02:27:02 <lispy> not i
02:27:12 <lispy> i'm native not able to sleep tonight :)
02:30:26 <quicksilver> NO, it can't be true!
02:30:40 <quicksilver> This program type-checks but it doesn't work :(
02:30:43 <quicksilver> They lied to me!
02:31:02 <lispy> quicksilver: oh, you must have used 'undefined'  somewhere :)
02:33:40 <earthy> that happens to me so often
02:33:54 <earthy> the canonical bug to happen to me is called 'off by one'
02:34:13 <earthy> which you will not catch in a type. :)
02:34:22 <tuukkah> earthy, do you use for loops in your haskell code ;-)
02:34:35 <lispy> i found an 'off by one' bug in a large C++ program in code that was over a decade old the other day :)  (and it was my first time looking at the code)
02:35:24 <malcolmw> earthy: unless you use type-level peano arithmetic
02:35:33 <tuukkah> hmm, i had to write some drop 1's lately with scanl
02:37:51 <dmwit_> ?pl f s = newline >> return s
02:37:51 <lambdabot> f = (newline >>) . return
02:37:57 <xs> ah. but can a type system detect race conditions?
02:38:11 <lispy> xs: use STM :)
02:38:49 <xs> lispy, i have. i don't think it precludes race conditions though?
02:39:12 <lispy> xs: it automatically handles them in a sense
02:39:48 <lispy> xs: we're talking about software transational memory right?
02:40:00 <xs> lispy, yup. some, yes. but not all i think. IO is not permitted in STM.
02:40:24 <lispy> xs: right, it has to know how to undo and restart
02:40:35 <quicksilver> yes, type systems can detect race conditions
02:40:54 <quicksilver> whether type systems can simultaneously detect all race conditions and permit all useful programs is an open question, I think
02:41:42 <xs> quicksilver, that's interesting. do you perhaps have a reference for that?
02:42:11 <quicksilver> xs: no, not of the top of my head. It's a pretty wide + deep area
02:42:21 <quicksilver> the pi calculus guys think about this kind of stuff, I believe
02:42:52 <quicksilver> things like linear types for semaphores help
02:42:55 <xs> ah, and CSP. okay.
02:43:04 <lispy> pi calc? d(pie)/d(tasty)
02:44:20 <sm> night all
02:58:55 <dmwit_> :t lift
02:58:57 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
02:59:04 <dmwit_> :t liftM
02:59:07 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
03:01:30 <vincenz> ADEpt: ping
03:01:55 <ADEpt> vincenz: pong
03:02:25 <vincenz> ADEpt: oasis
03:05:28 * mux thinks this combinator would be a nice addition to parsec :
03:05:31 <mux> pmaybe :: GenParser tok st a -> GenParser tok st (Maybe a)
03:05:31 <mux> pmaybe p = option Nothing (p >>= return . Just)
03:09:31 <mux> any opinions?
03:10:22 <Thunde1> mux: This will work?
03:10:43 <Thunde1> IBTD: fail will skip option, too.
03:11:47 <Thunde1> mux: Sorry, option is in GenParser. It will work.
03:11:52 <mux> Thunde1: it works just fine :)
03:11:54 <mux> I'm using it.
03:26:22 * mux posts to haskell-cafe for opinions
03:27:53 <ClaudiusMaximus> :t mapM
03:27:55 <lambdabot>     Ambiguous occurrence `mapM'
03:27:56 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
03:29:44 <ClaudiusMaximus> @hoogle [a] -> (a -> IO ()) -> IO ()
03:29:44 <lambdabot> No matches, try a more general search
03:29:57 <ClaudiusMaximus> @hoogle [a] -> (a -> m b) -> m b
03:29:57 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
03:29:58 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
03:29:58 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
03:30:18 <ski> :t Control.Monad.mapM
03:30:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:30:43 <ski> :t Control.Monad.mapM_
03:30:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
03:31:12 <ClaudiusMaximus> ah, mapM_ is the one i want...
03:31:37 <ski> istr there's a 'forM' and 'forM_' in a recent GHC, too, with args swapped
03:33:27 <hpaste>  vincenz pasted "eg" at http://hpaste.org/943
03:35:25 <cpfr> hey how do i pluck a random element from a list
03:38:28 <quicksilver> :t l !! (randomRIO (0,(length l)-1))
03:38:30 <lambdabot> Not in scope: `l'
03:38:30 <lambdabot>  
03:38:30 <lambdabot> <interactive>:1:27: Not in scope: `l'
03:38:37 <quicksilver> :t \l -> l !! (randomRIO (0,(length l)-1))
03:38:37 <norpan> pluck it indeed
03:38:39 <lambdabot>     Couldn't match expected type `Int' against inferred type `IO Int'
03:38:39 <lambdabot>     In the second argument of `(!!)', namely
03:38:52 <quicksilver> :t \l -> (l !!) =<< (randomRIO (0,(length l)-1))
03:38:55 <lambdabot> forall b. [IO b] -> IO b
03:39:03 * quicksilver laughs at himself
03:39:07 <cpfr> huh
03:39:10 <norpan> by pluck, do you mean access, or do you want it removed too
03:39:25 <quicksilver> :t \l -> { do i <- randomRIO (0,(length l)-1) ; return l !! i }
03:39:27 <lambdabot> parse error on input `{'
03:39:34 <quicksilver> :t \l -> do  { i <- randomRIO (0,(length l)-1) ; return l !! i }
03:39:37 <lambdabot>     Couldn't match expected type `IO' against inferred type `[]'
03:39:37 <lambdabot>       Expected type: IO t
03:39:40 <quicksilver> too early for me, it seems
03:39:51 <quicksilver> :t \l -> do  { i <- randomRIO (0,(length l)-1) ; return (l !! i) }
03:39:51 <norpan> don't you have a haskell interpreter of your own?
03:39:54 <lambdabot> forall a. [a] -> IO a
03:40:03 <quicksilver> norpan: yes, sorry. Was trying to answer cpfr's question
03:40:06 <quicksilver> cpfr: there it is
03:40:10 <vincenz>     Could not find module `Distribution.Compat.FilePath':
03:40:10 <vincenz>       it is hidden (in package Cabal-1.1.6)
03:44:56 <vincenz> Anyone know where FilePath is in 6.6?
03:46:29 <vincenz> @hoogle splitFileExt
03:46:30 <lambdabot> Distribution.Compat.FilePath.splitFileExt :: FilePath -> (String, String)
03:46:36 * vincenz mutters
04:16:06 <matthew_-> can you do an or in a case statement?
04:16:41 <matthew_-> so I want 2 or more predicates to cause the same body to be executed. like one of those really disgusting switch statements in C
04:18:08 <Eelis> > if (True || False) then return () else return ()
04:18:09 <lambdabot>   add an instance declaration for (Show (m ()))
04:18:21 <Eelis> you get the idea
04:18:22 <ToRA> refactor the two rhs's out into a where clause?
04:18:23 <lambdabot> ToRA: You have 1 new message. '/msg lambdabot @messages' to read it.
04:19:12 <matthew_-> no, it's a case statement. I'll refactor into a common function...
04:19:34 <AtnNn> you caan use guards
04:19:35 <AtnNn> > case 3 of a | a == 3 || a == 5 -> True
04:19:37 <lambdabot>  True
04:20:26 <ToRA> wow
04:20:32 * ToRA learns a new syntax construct
04:21:18 <matthew_-> > case 3 of a | a < 3 -> True; otherwise -> False
04:21:20 <lambdabot>  False
04:21:28 <matthew_-> super, that's brill, many thanks AtnNn
04:21:45 <sebell> I have a regular expression that I want to match, except that I would like to describe it in a more functional way (ala Parsec). Does anyone know how I can achieve the behavior of a regexp match, where my parser takes the place of the regular expression, and the result is the matched string?
04:21:59 <AtnNn> np
04:22:29 <matthew_-> sebell: there are some regex engines that use parsec in the background
04:23:00 <sebell> matthew_-: I was under the impression that it was a transparent background, with no interface change to the user
04:23:18 <sebell> matthew_-: (IE still takes regexp strings instead of Parsec parsers)
04:26:40 <matthew_-> sebell: yep, that's my understanding too ;-)
04:27:35 <sebell> matthew_-: So I guess I'm looking for quick-fix within Parsec to get that behavior, without taking 1-2 extra steps myself to achieve it :)
04:29:12 <AtnNn> sebell: you could map the parser over the tails
04:30:43 <sebell> AtnNn: I'm sorry, I'm not sure I get what you mean
04:32:03 <AtnNn> > tails "abc"
04:32:04 <lambdabot>  ["abc","bc","c",""]
04:32:12 <Philippa> map parse (tails "this is a string")
04:32:29 <sebell> I was thinking of using `manyTill anyChar myParser' for example, but then I have to deal with the fact that anyChar overlaps with myParser, and consumes one extra token.
04:32:32 <Philippa> it's not the most efficient way to do it, but it's a start
04:33:30 <matthew_-> what's the syntax for lazy pattern matching? eg I want the following to work: let foo@(Just n) = Nothing in isJust foo
04:34:44 <ToRA> let ~(foo@(Just n)) = Nothing in isJust foo
04:34:49 <ToRA> > let ~(foo@(Just n)) = Nothing in isJust foo
04:34:51 <lambdabot>   Irrefutable pattern failed for pattern ((foo@(Data.Maybe.Just n)))
04:36:12 <ToRA> oh no
04:36:14 <ToRA> that's not what you want
04:36:32 <ToRA> > let (foo@(~(Just n))) = Nothing in isJust foo
04:36:33 <lambdabot>  False
04:36:46 <matthew_-> ta
04:40:49 <sebell> In that case, does anyone know how to use manyTill p n that doesn't consume input on p when n succeeds?
04:41:06 <sebell> (or achieve the same effect somehow)
04:46:07 <matthew_-> mmm. how to make operations on the file system lazy
04:46:27 <matthew_-> I'm doing a createDirectory, but I only want it to be created if I actually make some files in it!
04:47:36 <sebell> matthew_-: That is logic you will have to include in your code
04:48:10 <matthew_-> mmm. I think it's an opportunity to write new and funky filesystems...
04:48:16 <ToRA> matthew_-: createDirectoryMonad
04:48:35 <matthew_-> @hoogle createDirectoryMonad
04:48:35 <lambdabot> No matches found
04:48:39 <ToRA> you wish
04:48:48 <matthew_-> mmm. that solution needs fleshing out a bit ;-)
04:54:01 <kuribas> Isn't Monad.Fix a lazy monad?
04:55:11 <ToRA> @paste
04:55:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:56:02 <hpaste>  ToRA pasted "For sebell: regex matching-ish" at http://hpaste.org/944
04:56:17 <ToRA> sebell: was that kinda what you were looking for?
04:57:24 <sebell> ToRA: Almost. manyTill will consume `m' in more, though it's not returned.
04:57:55 <sebell> ToRA: And you wouldn't need tails in that situation, if I'm not mistaken
04:59:26 <kuribas> I have a problem with Parsec: parsing (char 'a' `sepBy1` space) on "a a a " fails, while it succeeds on "a a ab"
05:00:47 <kuribas> How can I write a parser which succeeds on both?
05:01:14 <earthy> kuribas: it probably succeeds on "a a a"
05:01:17 <ToRA> sebell: in that example you do need tails
05:01:35 <ToRA> and it doesn't seem to consume the m in more
05:01:37 <Thunde1> kuribas: Parsec does not try backwards. You have to provide a <try> explizitly.
05:01:43 <earthy> you need an optional char ' ' at the end.
05:02:35 <hpaste>  ToRA annotated "For sebell: regex matching-ish" with "a variation" at http://hpaste.org/944#a1
05:02:42 <sebell> ToRA: You can avoid it, I mean
05:02:43 <fax> hi
05:03:49 <ToRA> sebell: ah, i think i see what you're getting at
05:03:59 <sebell> ToRA: Ok, in that example, string "more" will match when the parser is mapped to the element containing "more"
05:04:03 <ToRA> sebell: but i can't seem to make it swallow the m
05:04:46 <hpaste>  ToRA annotated "For sebell: regex matching-ish" with "Take 3" at http://hpaste.org/944#a2
05:05:11 <kuribas> Thunde1: (char 'a' `sepBy1` try space) will not work either.
05:05:13 <ToRA> right
05:05:35 <ToRA> do you want it to return all the possible matches
05:05:36 <ToRA> ?
05:06:01 <kuribas> earthy: ((char 'a' `sepBy1` space) >> optional space) also doesn't work.
05:06:09 <ivanm> IS there a monad-free way of implementing Donald Knuth's Dancing Links algorithm in Haskell?
05:06:14 * ivanm is still scared by monads
05:06:51 <earthy> hm
05:07:10 <earthy> ivanm: I seriously doubt that
05:07:19 <earthy> kuribas: well, my parsec is way too rusty
05:07:30 <kuribas> It looks like sepBy1 is unable to do backtracking.
05:07:45 <earthy> I'd guess it is greedy
05:07:48 <ivanm> earthy: so do I... there's a dancing links program for sudoku on the web page, and IIRC it didn't make any sense to me last time I looked at it
05:07:57 <sebell> ToRA: I'm sorry, I thought you were searching until `more'. In my case, I don't know the last token, I just want to skip any leading text that doesn't match my parser
05:09:05 <ToRA> right
05:09:21 <ToRA> is your parser wrapped in a try?
05:09:59 <sebell> Yes, but it's the p in `manyTill p n' that consumes input even when n matches
05:10:15 <sebell> This is not what manyTill is designed to do it seems.
05:10:24 <ToRA> manyTill tries n
05:10:35 <ToRA> if n fails it does p and then tries n again
05:10:46 <ToRA> i don't see what it's consuming that you don't want
05:11:04 <earthy> ivanm: well, obviously you could do it without monads, but you'd be threading state by hand... and it'd get quite inefficient and not be a 'true' dancing links algorithm
05:11:17 <sebell> ToRA: I'm finding that when n succeeds p is still applied and consumes input
05:11:31 <ivanm> earthy: yeah.... if only OHaskell had worked out
05:11:40 <earthy> why?
05:11:41 <ToRA> sebell: can you paste a small code example?
05:11:59 <sebell> ToRA: Sure, I'm not on a machine with GHC right now - it'll take me a minute or two
05:12:05 <quicksilver> ivanm: so you'd be happier if they hid the monads deep inside 'object-oriented' structures that no one understands? :P
05:12:10 <ivanm> earthy: because dancing links is all about doubly-linked lists...
05:12:35 <ivanm> quicksilver: not quite... but doubly-linked lists are sometimes handy, rather than singly-linked lists like in normal Haskell
05:13:26 <quicksilver> you can certainly build doubly-linked lists in haskell, although there are often other better data structures
05:13:38 <ivanm> quicksilver: how?
05:13:43 <dons> yeah, they're so rarely used
05:15:08 <dmwit> kuribas: sepEndBy and friends might do the trick for you.
05:15:10 <Eelis> is there a commonly used Haskell equivalent of gettext?
05:15:11 <earthy> why the heck would you need OHaskell for doubly linked lists?
05:15:19 <ivanm> I just wanted to try out dancing links, but as far as I can tell, it requires an OO language to get the doubly-linked-lists working
05:15:26 <dons> emk wrote an article on double ended queues, iirc, http://www.randomhacks.net/articles/2007/02/08/haskell-queues-without-pointers
05:15:28 <lambdabot> Title: Haskell: Queues without pointers, http://tinyurl.com/ypdolk
05:15:34 <dons> ivanm: nope :-)
05:15:38 <earthy> the original is in CWeb, which is *not* OO at all
05:15:43 <dons> OO is not a requirement for data structures ;-)
05:15:44 <ivanm> my mistake then
05:16:00 <ivanm> I just thought the whole link pointers was an OO trait..
05:16:05 <mauke> haha
05:16:06 <quicksilver> ivanm: Data Node = Nil | DoubleCons Node Value Node
05:16:08 <ivanm> oh, wait, that's right, C and Fortran have them as well
05:16:13 <ivanm> quicksilver: Doh!
05:16:17 <ivanm> didn't think of that...
05:16:26 <quicksilver> it's a bit tricky to 'build' them, of course
05:16:27 <emk> Dancing links is a sweet technique. But it's based on mutation (or so I understand), so it might be easiest to write in the IO monad.
05:16:33 <dons> hehe, you can't even pattern match on data in most OO languages: data isn't first class there ;-)
05:16:34 <quicksilver> you'd use a custom constructor in practice
05:16:53 <ivanm> emk: yeah, I think its mutation...
05:17:12 <ivanm> haven't really looked at it too much, as not even the wikipedia article made much sense to me from a quick skim
05:17:15 <earthy> it *lives* by the grace of mutation of a datastructure
05:17:25 <dons> ivanm: then you'd use mutation (e.g. like Data.HashTable)
05:17:32 <earthy> the dancing links datastructure really is quite simple
05:17:37 <emk> Dancing links is how you solve Sudoku puzzles in about a millisecond--it's basically a highly-optimized backtracking technique.
05:17:40 <earthy> the trick is in flipping the links
05:17:47 <ivanm> yeah...
05:17:49 <quicksilver> As a general rule for every algorithm which depends on mutation, there is an immutable algorithm which is only (log n) worse
05:18:14 <ivanm> someone suggested I should try it for my Latin Squares problem, but I can't really see how it'd relate... but I have to learn how to use it first!
05:18:16 <earthy> qs: O (log n) I presume? :)
05:18:18 <quicksilver> and frankly, who cares about log n? it's really hard to tell the difference between log n and a constant factor
05:18:23 <quicksilver> earthy: right, that's what I meant
05:18:30 <ivanm> quicksilver: where did that statistic come from?
05:18:33 <earthy> because constant factors *DO* matter
05:18:36 <quicksilver> earthy: multiplicatively not additively worse
05:18:36 <dons> and O(n) easier to reason about :-)
05:18:48 <quicksilver> earthy: ah but if you don't know your constant fact
05:18:55 <emk> Of course, the easy-but-slow way to solve Sudoku involves a constraint language, like Oz. Just explain the rules, and the runtime will do the inference (and any necessary backtracking) for you.
05:18:58 <earthy> true enough. :)
05:19:00 <quicksilver> earthy: it could well be that my O(log n) is *less* that your constant factor :)
05:19:10 <quicksilver> earthy: for all n under (some large number)
05:19:23 <emk> quicksilver: Not if his constant factor is Knuth's dancing links. :-)
05:19:23 <kuribas> Is there no constraint library for haskell?
05:19:31 <earthy> oh, but there is
05:19:32 <quicksilver> ivanm: It's an anecdotal statistic
05:19:37 <ivanm> emk: but how good is dancing links at generating all possible solutions for sudoku?
05:19:40 <ivanm> quicksilver: k
05:19:57 <quicksilver> ivanm: but generally things like trees and tries and fingertrees are only log(n) worse than mutable structures
05:20:13 * ivanm has never heard of fingertrees
05:20:20 <dons> Data.Sequence is really nice, actually
05:20:25 <dons> i was playing with it a bit last week
05:20:28 <ivanm> also, don't trees require you to copy the whole tree all over again in Haskell?
05:20:33 <earthy> kuribas: in Bastiaan Heeren's PhD thesis is a constraint solver based type inferencDe engine
05:20:38 <emk> ivanm: I would assume that it's very quick. Dancing links is basically an implementation technique for highly-optimized backtrackers that use mutation.
05:20:40 <dons> the whole tree? no no. that would be a *strict* language :-)
05:20:59 <quicksilver> ivanm: haskell never requires copying
05:21:01 <Philippa> and even then, no
05:21:04 <quicksilver> ivanm: therein lies its beauty :)
05:21:16 <ivanm> I thought that, since there was no state, any time you alter part of a data structure, the whole data structure needs to be re-created
05:21:22 <quicksilver> you thought wrong :)
05:21:24 <Philippa> you never need to copy the /whole/ tree, only part of it - the rest gets reused
05:21:29 <ivanm> quicksilver: obviously ;-)
05:21:31 <quicksilver> when you alter it, the pointers are retained to the 'unaltered' parts
05:21:43 <quicksilver> e.g let y = 'foo' : (tail x)
05:21:45 <ivanm> so its got inherent pointer manipulation?
05:21:47 <quicksilver> y 'shares' the tail of x
05:21:51 <quicksilver> ivanm: yes, it does
05:22:00 <ivanm> ahhhh... that makes sense now...
05:22:07 <emk> kuribas: I'm sure there's a constraint library for Haskell somewhere. But if you're into that stuff, there's some gloriously elegant work in the Oz community. In particular, they've gotten very good at separating search strategies (e.g., branch and bound) from the specification of constraints and inference rules.
05:22:10 <hpaste>  (anonymous) annotated "For sebell: regex matching-ish" with "(no title)" at http://hpaste.org/944#a3
05:22:11 <Eelis> i've always wondered: is there any copying involved when i do "somelongstring" ++ "someotherlongstring"  ?
05:22:19 <quicksilver> emk: yes, sadly
05:22:23 <ivanm> so changing "Node <foo> a" to "Node <bar> a" just replaces foo with bar, not the whole tree?
05:22:24 <dons> > let x = [1..] ; y = 42 : x in take 3 y -- we better not *copy* 'x' :-)
05:22:25 <quicksilver> Eelis: yes, sadly
05:22:25 <lambdabot>  [42,1,2]
05:22:28 <emk> Eelis: Yes.
05:22:28 <Philippa> yes, somelongstring gets copied
05:22:32 <quicksilver> Eelis: the first string is copied in full
05:22:35 <Eelis> i see, as i expected
05:22:39 <quicksilver> Eelis: Lazy Bytestrings solve this, though
05:22:48 <Eelis> quicksilver: interesting. i shall have to have a look at them
05:22:49 <sebell> ToRA: That's what I'm experiencing
05:22:54 <kuribas> emk: Yes, I was looking at alice, which is kind of like Oz, but using Standard ML.
05:23:04 <ToRA> sebell: ok, that's correct behaviour
05:23:20 <ToRA> the anychar isn't swallowing that
05:23:22 <ToRA> the (try digit) is
05:23:41 <quicksilver> dons: if you append two 'very large' bytestrings, is there some copying 'around the middle'? or no copying at all?
05:23:46 <quicksilver> dons: lazy, I should say
05:23:47 <ivanm> > let x = [1..] ; y = x ++ [42] in take 3 y
05:23:49 <lambdabot>  [1,2,3]
05:23:51 <ToRA> alter to something like: manyTill anyChar (try digit) >>= (\h -> h : (many anychar)
05:23:52 <dons> lazy ones? hmm
05:24:04 <ivanm> > let x = [1..] ; y = [2..] ++ x in take 3 y
05:24:05 <dons> the initial part of the spine will be copied
05:24:05 <lambdabot>  [2,3,4]
05:24:06 <quicksilver> part of the spine would be copoied, clearly
05:24:07 * quicksilver nods
05:24:10 <ToRA> sebell: and you should find your 2 comes back
05:24:11 <dons> which is n/cache-size
05:24:16 <dons> so usualy very small
05:24:22 <quicksilver> yes, that's fine
05:24:38 <dons> append (LPS []) (LPS ys) = LPS ys
05:24:38 <dons> append (LPS xs) (LPS ys) = LPS (xs ++ ys)
05:24:39 <quicksilver> I suppose I'm wondering if the two 'middle components' might be combined?
05:24:43 <dons> its just normal append, on the spine
05:24:48 * quicksilver nods
05:24:52 <quicksilver> answer is no, then
05:24:59 <emk> kuribas: Alice is also very nice, but doesn't quite commit to the concurrent logic paradigm in quite such a gonzo way. You have all different sorts of variables that support different kinds of unification and laziness, instead of a single type of variable that does everything. It's certainly more optimizable and type-safe, but I enjoy the purer form of the paradigm more. (One reason why I prefer Haskell to ML...)
05:25:04 <quicksilver> Eelis: yes, lazy bytestrings solve that problem completely :) they are very nice
05:25:16 <sebell> ToRA: Ah, precisely :)
05:25:18 * dons notes the complexity annotation is wrong in the src
05:25:29 <dons> O(n) instead of what it should be O(n/c)
05:25:41 <quicksilver> dons: although there are pathological use cases where using that a lot ruins your average chunk size
05:25:42 <ivanm> anyway, back to my original question... the only example of dancing links in haskell I could find was: http://haskell.org/haskellwiki/Sudoku#Just_guessing
05:25:44 <lambdabot> Title: Sudoku - HaskellWiki
05:25:49 <ToRA> sebell: problem solved?
05:26:15 <ivanm> are there any others that people know about? possibly based on recursive data structures rather than monads?
05:26:18 <dons> yeah. in fact, we had an interesting case today where kc5tja wanted to tokenise a file into a lazy bytestring
05:26:27 <dons> so each 10-char token became a new chunk size
05:26:37 <emk> ivanm: Well, standard dancing links is only going to work in the IO or ST monads, because it's inherently stateful.
05:26:53 <dons> so basically a [Token] that looked like a lazy bytestring
05:26:57 <ivanm> emk: OK, how about non-standard? (i.e. no mutation)
05:27:06 <quicksilver> emk: or some other monad which is encapsulating the state :)
05:27:23 <dons> so it might make a nice ST monad implementation then?
05:27:33 <dons> hide the mutation fully
05:27:34 <quicksilver> I think you can probably program 'something like' dancing links which uses standard functional immutable techniques for its backtracking
05:27:34 <emk> ivanm: Yeah. You'd have to represent pointers as integers, or something, and use a lookup table.
05:27:45 <quicksilver> and there doesn't need mutation
05:27:52 <quicksilver> but is (I would guess) O(log n) slower
05:27:52 <quicksilver> :)
05:27:57 <mux> dons: can we easily use ByteString with Parsec?
05:27:59 <ivanm> quicksilver: lol
05:28:09 <ivanm> emk: pointers as integers? lookup table?
05:28:20 <sebell> ToRA: Nearly, but I can't cons a character onto a Parser, in your lambda expression
05:28:22 <dons> mux, there's been some attempts. i think its doable
05:28:50 <mux> sebell: yes, you need to something like a <- ...; b <- ...; return (a:b)
05:28:51 <mauke> ivanm: memory is just a mapping from addresses to storage
05:28:57 <dons> you can get some pretty good /lexing/ speeds on (strict) bytestrings, that's what kc5tja and I were looking at today
05:29:11 <dons> went from 2mins to 7s by switching to strict bytestrings for the lexer
05:29:16 <mux> I use Parsec's lexeme parsers
05:29:21 <ToRA> sebell: as mux says, though shouln't your "match" parser be entirely within the try and not have anything following it
05:29:21 <mux> to deal with whitespace
05:29:25 <ToRA> ?
05:29:27 <dons> (basically the same loop generated as in the sumcol shootout benchmark)
05:29:28 <emk> quicksilver: Oh, yeah. But the only point of dancing links is that it's an ultrafast implementation technique using pointer mutation. Haskell has very nice support for purely functional backtracking--just use any data structure with good persistence behavior (in the Osaki sense).
05:29:37 <quicksilver> emk: right
05:29:50 <ivanm> mauke: yeah, I know... but in what way would I use integers as pointers? and as for a lookup table, should that be one of those fancy memoisation-style ones?
05:29:53 <quicksilver> emk: however, some of the beauty of the algorithm would remain, witht he 'functional backtracking' version
05:29:57 <sebell> ToRA: Yes, that's the way to do it
05:30:02 <emk> dons: Yeah, dancing links Sudoku might be very nice to see in ST.
05:30:09 <quicksilver> emk: the reason knuth woudln't do it that way, is the book-keeping of maintaining that all by hand
05:30:21 <quicksilver> emk: if your language maintains all that for you, then you have an elegant algorithm
05:30:22 <sebell> ToRA: Since I don't care about that the first parser returns, I can even omit the try
05:30:22 <dons> emk, oh, re. http/network stuff, i'm going to writthe libcurl binding, I think
05:30:29 <dons> using c2hs to get most of the binding generated
05:30:30 <emk> quicksilver: Well, purely functional backtracking is just staggeringly gorgeous, however you do it.
05:30:36 <ToRA> sebell: no, you need the try
05:30:39 <dons> and have a nice overloaded string/bytestring interface
05:31:07 <ivanm> emk, quicksilver: so dancing links is just a backtracking approach?
05:31:07 <dons> unless we can get a SoC student to do it ...
05:31:13 <emk> dons: That's really good news! I can't wait until the Haskell library situation is on par with, say, Ruby's standard library.
05:31:15 * ivanm already kinda uses something like that
05:31:24 <ToRA> sebell: oh, well if you do (manyTill anyChar oneCharacter)  then putBackThatCharacterAndParseTheRest then you don't need the try
05:31:29 <dons> emk, hackage/cabal really helps put things in focus
05:31:30 <ivanm> dons: I'd like to do SoC... but it doesn't really fit into an Aussie winter :(
05:31:50 <dons> i've a much clearer idea now of what is missing and what needs work
05:31:53 <ToRA> sebell: but i would have thought it would be better to do manyTill anyChar (try theActualThingIWantToParse)
05:32:02 <dons> hey, quicksilver , want to mentor a project for the SoC?
05:32:05 <dons> ivanm: right :/
05:32:11 <sebell> ToRA: Why? If I do (manyTill anyChar myCompleteParser) I don't care if myCompleteParser fails and consumes input
05:32:24 <dons> its easy to be a mentor, but we have very few .au students (and southern hemisphere in general)
05:32:35 <Philippa> sebell: yes you do
05:33:04 <Philippa> there might be a match that starts in some of the consumed chars
05:33:17 <emk> ivanm: Basically, at least in the forms I've seen it. Dancing links is really clever and really fast, and certainly a good choice if you want to write a super-optimized constraint-solver by hand. But the Haskell approach to backtracking is drop-dead gorgeous, too.
05:33:31 <quicksilver> ivanm: yes, a very elegant way of storing backtracking in zero space
05:33:42 <quicksilver> ivanm: are you familiar with schorr-waite tree traversal?
05:33:45 <ivanm> emk: do you know any decent examples off hand of backtracking?
05:33:47 <ivanm> quicksilver: nope
05:33:53 <mux> Parsec is a great tool for Haskell proselytism
05:34:08 <mux> take any coder that had to deal with lex/yacc etc
05:34:12 <quicksilver> schorr-waite (I may have spelt it wrong) is the canonical example of zero-space backtracking
05:34:12 <mux> show him Parsec
05:34:21 <quicksilver> you hide your state inside the tree links
05:34:24 <mux> and you get a Haskell fanatic
05:34:26 <quicksilver> and fix them on the way back
05:34:31 <dons> mux, is parsec our 'rails' ? :-)
05:34:37 <mux> dons: it's our gem :-)
05:34:42 <quicksilver> dancing links is I think, a development of similar ideas
05:34:43 <emk> ivanm: Oddly, one of the nicest examples of purely-functional backtrackers is actually written in Scheme. See "The Reasoned Schemer". It's basically a Haskell program translated into Scheme--monads, lazy lists, you name it.
05:34:43 <dons> mux, we need more docs for it..
05:34:50 <sebell> ToRA: Ah. If I have myCompleteParser as the second argument, it will return the list of all the matches of the first
05:35:08 <quicksilver> incidentally, lex/yacc do suck but tehre are other decent parser generators for non-haskell languages :)
05:35:09 <mux> dons: yes, some combinators are missing from the reference guide (but are described in the haddock reference)
05:35:15 <quicksilver> sableCC was pretty good last time I used it
05:35:18 <dons> emk, ... every large scheme program contains an ad hoc implementation of monads, type classes, static typing ...
05:35:19 <ivanm> quicksilver: thanks, I'll have a look
05:35:22 <mux> quicksilver: jparsec ? :D
05:35:42 <ivanm> emk: I was hoping for a monad-free one... OK, I'll have a look, thanks
05:35:48 <emk> ivanm: Or take a look at the probability monad in PFP (or the variants on my site http://www.randomhacks.net/ ). That's basically just weighted backtracking.
05:35:49 <lambdabot> Title: Random Hacks
05:35:50 <ivanm> @google "The reasoned schemer"
05:35:54 <lambdabot> http://mitpress.mit.edu/0262562146
05:35:54 <lambdabot> Title: The Reasoned Schemer - The MIT Press
05:35:56 <ToRA> sebell: ?
05:36:10 <fax> oh thats a really great book
05:36:20 <mux> I wonder how good jparsec is
05:36:26 <mux> or if Java gets in the way
05:36:40 <fax> hey my first haskell program is almost finished :D
05:36:41 <fax> http://img134.imageshack.us/img134/2299/coshqz0.gif
05:36:49 <emk> ivanm: Well, backtracking is one of those things that really shows off the power of monads.
05:36:56 <sebell> ToRA: Since I care about what the second parser matches, it doesn't make sense for me to have (manyTill anyChar myParser) since it will return a list of all the matched anyChar
05:37:08 <mux> LOGO!
05:37:11 <emk> dons: I can't wait until library error-reporting is a bit more under control.
05:37:12 <fax> yeah :D
05:37:13 <ivanm> emk: sigh, looks like I have to bite the bullet and learn monads then :(
05:37:16 * mux drops a tear out of nostalgy
05:37:21 <ToRA> out there question: is there a reason why GenParser in parsec isn't an instance of MonadState but has it's own getState / setState methods?
05:37:27 <mux> man, I've been doing some LOGO when I was a kid, on TO7 computers!
05:37:31 <ivanm> emk: excellent, my uni's library has exactly one copy of the reasoned schemer and its available!
05:37:35 <mux> it was grrrreat
05:37:38 <Philippa> ToRA: yeah, it's old enough not to
05:37:39 <fax> hehe yeah
05:37:40 <earthy> ToRA: yes. history. ;)
05:37:41 <fax> its so much fun
05:37:51 <ToRA> sebell: no, manyTill anyChar myParser will return the parse match of myParser
05:37:53 <emk> ivanm: "The Reasoned Schemer" is a great place to start.
05:37:55 * mux remembers choplifter on the TO7
05:37:56 <mux> mmm
05:37:58 <earthy> Parsec was written in 1997 or somesuch.
05:38:03 <quicksilver> ivanm: monads really aren't hard
05:38:10 <earthy> MonadState came after
05:38:13 <sebell> ToRA: Are you sure?
05:38:18 <quicksilver> ivanm: it helps to have written some code first which needed them when you didn't know they existed
05:38:31 <ivanm> quicksilver: well, I get list and maybe, but I still haven't gotten my head around ST
05:38:35 <fax> if you want to know about declarative programming I think the best book I have read is "The Art of Prolog"
05:38:43 <ToRA> sebell: i take that back
05:38:46 <ivanm> quicksilver: I think I'm in that boat then ;-)
05:38:48 <quicksilver> ivanm: if you'd ever had to thread environment or unification state through a bunch of procedure calls
05:38:49 <sebell> ToRA: :)
05:38:56 <quicksilver> ivanm: then you've seen what monads are for
05:39:00 <quicksilver> ivanm: Monads Hide Plumbing
05:39:00 <ivanm> quicksilver: probably not then...
05:39:01 <sebell> ToRA: Thanks a lot for your help, gotta run
05:39:06 <emk> dons: I wasn't terribly impressed by the error-hanlding proposals that required all sorts of little helper-functions in mainline code to convert the errors to a standard type. That's an ingenious workaround, but it rubs the language designer in me the wrong way...
05:39:09 <ToRA> sebell: np
05:39:11 <ivanm> quicksilver: so haskellers == plumbers? ;-)
05:39:18 <ivanm> quicksilver: plumbing in what way?
05:39:29 <quicksilver> ivanm: suppose you're evaluating an expression in a side-effectful language like C
05:39:37 * ivanm has seen "monads as containers", "monads as functions", but not "monads as plumbing" ;-)
05:39:43 <ivanm> quicksilver: k
05:39:43 <fax> hahaha
05:39:45 <quicksilver> evaluate Plus a b = (evaluate a) + (evaluate b)
05:39:54 <quicksilver> this is the rule for the primitive operation '+'
05:39:59 <emk> dons: Error-reporting isn't important enough to deserve a token or two on every single line of code.
05:40:04 <ivanm> quicksilver: yep
05:40:09 <quicksilver> but, C has state, and 'a' and 'b' might contain global variables
05:40:14 <quicksilver> so it becomes
05:40:22 <quicksilver> evaluate Plus a b env = (evaluate a env) + (evaluate b env)
05:40:28 <Philippa> I want a variant of MonadError that supports a catch that can change the error type
05:40:32 <ivanm> think I'm with you
05:40:42 <quicksilver> so far, so good. But since C has side-effects, evaluate 'a' or 'b' is allowed to mutate the environment
05:40:44 <ivanm> env == where the globals are stored?
05:40:46 <quicksilver> yes
05:40:50 <emk> dons: Especially for newbies trying to combine lots of Hackage libraries--do we really want to explain the glue layers over and over?
05:40:51 <ivanm> k
05:40:52 <quicksilver> so you really need this:
05:40:54 <Philippa> the whole /point/ is that we interface code with different sets of possible errors
05:41:37 <quicksilver> evaluate Plus a b env = let (aval,newenv) = evaluate a env in let (vbal,newerenv) = evaluate b new env in (newerenv,a+b)
05:41:41 <dons> emk, agreed. i think we can probably just identify odd libraries out one by one
05:41:53 <dons> and convert them over to Maybe /Either or error.
05:41:54 <quicksilver> ivanm: each subsidiary 'evaluate' has to be allowed to modify env
05:41:59 <dons> and have new ones not do funny things
05:42:01 <ivanm> quicksilver: OK, its getting very ugly very quickly
05:42:06 <quicksilver> ivanm: and you have to 'thread' the continuously changing 'env' through each call
05:42:07 <emk> dons: How do we handle the ConnError/ParsecError/etc. problem?
05:42:16 <earthy> shouldn't this then be in the guidelines for library code?
05:42:18 <ivanm> quicksilver: got that
05:42:18 <dons> set errno
05:42:29 <quicksilver> ivanm: notice that I've now made explicit that 'a' is evaluated first, since the mutated env coming out of a goes into b
05:42:31 <dons> earthy: yes, once we work out something to guide people :-)
05:42:32 <emk> dons: Where we can't use Either in it's current form, because we have mulitple errors ADTs?
05:42:36 <ivanm> yep
05:42:39 <quicksilver> ivanm: well this is exactly the mess which monads hide
05:42:48 <ivanm> yeah, I understand that
05:42:48 <quicksilver> ivanm: for a suitable monad, it becomes
05:43:12 <quicksilver> evaluate Plus a b = do { aval <- evaluate a; bval <- evaluate b; return (a+b) }
05:43:14 <Philippa> emk: what I suggested
05:43:25 <quicksilver> ivanm: the 'env', 'newenv' mess has vanished into the monad
05:43:35 <quicksilver> ivanm: that's what I mean by 'Monads Hide Plumbing'
05:43:50 <ivanm> quicksilver: I understand that part about monads... just not the State monad as yet
05:43:50 <emk> ivanm: Check http://www.randomhacks.net/ in a day or two, and I'll try to post a second explanation of the backtracking monad.
05:43:51 <lambdabot> Title: Random Hacks
05:44:00 <Philippa> you need a class related to MonadError that covers monads polymorphic in their error type and has a catch that can change the error type - the error handler can re-throw a new type or be polymorphic in what it yields, we already know succeeding code succeeds
05:44:07 <quicksilver> ivanm: that example could be the State Monad
05:44:08 <ivanm> and since its the first real monad most books/tutorials cover, it gets very confusing to me
05:44:11 <ivanm> emk: OK, thanks!
05:44:15 <quicksilver> ivanm: it could be State Env
05:44:19 <emk> Philippa: Ah, that was your proposal? I really liked that one.
05:44:23 <earthy> http://www.haskell.org/haskellwiki/Programming_guidelines seems like guidelines to me...
05:44:25 <lambdabot> Title: Programming guidelines - HaskellWiki
05:44:26 <quicksilver> ivanm: State x hides a value of type x inside the monad :)
05:44:33 <quicksilver> ivanm: (and allows you to change it)
05:44:44 <Philippa> I don't think I posted it anywhere myself, though I could be wrong :-)
05:44:48 <ivanm> quicksilver: its mainly t he whole "it returns a function but takes a function" bit that screwed me up
05:44:49 <quicksilver> ivanm: Reader x hides a value of x but doesn't allow you to change it
05:44:51 <Philippa> it's "obvious" enough to get reinvented
05:44:57 * ivanm 's head is still on too tight to get it yet ;-)
05:45:18 <ivanm> quicksilver: OK, I'll have another look through it then in a day or so
05:45:31 <quicksilver> Philippa: there are already some constructs like that in Control.Exception, they just haven't been generalised to MonadError, right?
05:45:41 <quicksilver> ivanm: I think you're very nearly there, to be honest :)_
05:45:53 <Philippa> quicksilver: I wouldn't know, I'd have to look :-)
05:46:02 * mux thinks ivanm seems to be much closer to understanding than he used to be
05:46:05 <ivanm> quicksilver: maybe its just the explanations... the "nuclear waste" scenario on the wikibook confused me with its metafors :D
05:46:32 <quicksilver> :t Control.Exception.mapException
05:46:34 <lambdabot> forall a. (GHC.IOBase.Exception -> GHC.IOBase.Exception) -> a -> a
05:46:40 <ivanm> mux, quicksilver: thanks... assuming its a good thing for heads to be rolling around on necks loosely :P
05:46:41 <quicksilver> Philippa: that's what I was thinking of
05:46:50 <quicksilver> Philippa: not quite what you said, but getting warm
05:46:58 <mux> monads require some minimal time to decant in brain :-)
05:47:03 <mux> after that it's OK
05:47:24 <quicksilver> of course IO doesn't have the equivalent of 'throws'
05:47:26 <ivanm> mux: how bout booze? is that usually required? if so, I'm outta luck (don't drink)
05:47:36 <quicksilver> our type system can't say : IO a CanThrow Fileexception
05:47:45 <araujo> hello
05:47:46 <mux> ivanm: hehe, I don't know for that :-) never tried getting drunk while doing Haskell
05:48:10 <mux> quicksilver: but it can say ErrorT (IO a)
05:48:14 * earthy did some drunk Clean coding back in the day
05:48:25 <ivanm> earthy: did it help?
05:48:27 <quicksilver> mux: I shouldn't have said 'our type system', that was foolish
05:48:30 <mux> quicksilver: isn't that somehow the same?
05:48:32 <earthy> yeah... I was rather productive
05:48:36 <quicksilver> mux: I meant 'the current IO exception setup'
05:48:40 <mux> oh.
05:48:45 <earthy> the type system prevents the drunkenness-mistakes
05:48:57 <quicksilver> mux: i.e. that basically exceptions are monomorphic
05:49:07 <quicksilver> mux: and you have to code around that with Dynamic if that's not what you want
05:49:12 * mux nods
05:49:14 <mux> I get the point
05:49:35 <quicksilver> the obvious model of exception  typing needs subtypes
05:49:41 <quicksilver> (well, supertypes, but that's mostly the same thing)
05:49:50 <ivanm> anyway, I should get to bed so I stop falling asleep in lectures
05:49:55 <Philippa> and failing that, somewhere to insert the coercions
05:49:55 <ivanm> g'night all!
05:50:03 <quicksilver> and experience with java's explicit throws clauses suggests it may be a bit of a pain
05:50:13 <quicksilver> although we have type inference which java lacks, so it may be less of a pain
05:50:40 <Philippa> rather a lot less
05:51:16 <quicksilver> if every use of >> or >>= had to be annotated with the coercion to unify the two classes of exceptions thrown by the two parameters
05:51:19 <quicksilver> that could be painful :)
05:52:04 <earthy> ouch
05:52:05 <Philippa> true, but you can leave no exception as "throws forall a.a"
05:52:16 <earthy> even bigger ouch. :P
05:52:19 <Philippa> (with the forall liftable to the leftmost)
05:52:31 <quicksilver> ]then there's the generic problem of such exception systems
05:52:50 <Philippa> not really - that translates to "doesn't throw anything, so can be fed into something that expects /anything/"
05:52:53 <quicksilver> like the fact that readFile might be expected to only throw FileExceptions
05:53:01 <quicksilver> but what if we're using NFS?
05:53:09 <quicksilver> suddenly readFile can throw NetworkExceptions too
05:53:42 <quicksilver> which, roughly, is the problem that exceptions-thrown can leak over what might otherwise be abstraction layers
05:54:04 <quicksilver> (maybe that's not a problem if every layer is designed properly)
05:54:16 <mux> well
05:54:26 <mux> low-level system calls aren't supposed to return network errors in case of NFS
05:54:34 <mux> it's supposed to be abstracted away
05:54:36 <quicksilver> mux: it's only a toy example
05:54:41 <mux> sure :-)
05:54:42 <quicksilver> mux: but, yes
05:54:46 * mux keeps quiet
05:54:50 <quicksilver> (it's stroustrup's example, in fact)
05:55:12 <Philippa> you'd wrap it: ESomethingScrewedUp theRealError, with polymorphism and/or dynamic typing as (in)appropriate
05:55:18 * quicksilver nods
05:55:41 <mux> I like this sentence from Stroustrup: "In C++ it's harder to shoot yourself in the foot than in C, but when it happens, you blow your whole leg off."
05:55:42 <Philippa> and develop a framework for querying for the set of errors you understand fast
05:56:11 <quicksilver> Philippa: yeah, it could be very nice indeed
05:56:12 <Philippa> yeah, when C++ leaks it leaks bad
05:59:10 <emk> Philippa, quicksilver: It's perfectly reasonable that (say) Network.HTTP and Parsec each want to have their own set of errors (which the represent with an ADT).
05:59:35 <emk> And it's perfectly reasonable to download something, parse it, and pass any errors back to the caller.
06:00:36 <emk> But right now, that requires a non-standard song-and-dance that varies with each library. And there's no established convention for saying, "Well, you got either a ConnError or a ParsecError, or something else."
06:00:55 <emk> Java's "throws" is vastly overrated, and most Java programmers seem to work around it.
06:01:54 <emk> It's pretty rare that you actually care about having an exhaustive list of all the kinds of error that might be thrown.
06:02:01 <quicksilver> emk: that's what I meant about needing supertypes
06:02:09 <quicksilver> emk: for the (ConnError or ParsecError) part
06:02:15 <emk> Usually, you just have one or two kinds that you care about, and just want to propagate the rest to your caller.
06:02:18 <Thunde1> emk: And Javas execptions are not even annotated, because it's to hard to write down the union of all possible exceptions. Therefore a lot of Java programmers subclass Exception.Runtime.
06:02:25 <emk> quicksilver: Or even just "Error".
06:02:40 <quicksilver> emk: 'just one or two kinds you care about' is well supproted in haskell
06:02:49 <emk> quicksilver: The closest Haskell approximation is something like "(Shows e, Error e) => Dynamic e".
06:02:53 <quicksilver> emk: we have catchJust
06:03:06 <quicksilver> emk: which takes an exception-selecting predicate
06:03:12 <mux> yeah, catchJust is nice
06:03:24 <emk> quicksilver: No, I mean "one or two kinds I care about, and an arbitrary number of kinds I'm going to just pass along."
06:03:40 <quicksilver> emk: that's exactly what catchJust does
06:03:55 <matthew_-> right, things Haskell needs for a better web: a) Network.HTTP and Network.CGI agreeing on requests and responces and how to get and set headers; b) a version of Network.URI that is not _incredibly_ annoying.
06:04:06 <emk> quicksilver: That's the most common case--you know how to recover from a transient DNS failure, but have no idea what to do when you run out of disk space, or whatever.
06:04:06 <quicksilver> emk: "...Any other exceptions which are not matched by the predicate are re-raised..."
06:04:34 <Philippa> emk: what I'm doing will deal with the boundaries by letting you build the unions as appropriate. Anything better requires a new type system
06:04:59 <emk> quicksilver: Yeah, but how do you declare the type "ConnError or ParseError or FooError or BarError or any one of a half-dozen more obscure things"?
06:05:38 <emk> quicksilver: And why should Haskell code be burdened with all that weight, if you're just trying to do something simple? Again, Java programmers subvert 'throws', and C++ programmers almost never use it.
06:06:16 <Philippa_> a big pile of Eithers or something isomorphic to it
06:06:28 <Philippa_> 'lo beelsebob, we're talking error handling
06:06:35 <emk> Philippa: Well, if handling the errors thrown by three or four libraries is an ugly mess in Haskell's type system, then we have a problem.
06:06:38 <beelsebob> lo Philippa
06:06:55 <Philippa_> emk: the short answer is that it's ugly but not /that/ ugly
06:07:08 <Philippa> emk: big pile o'Eithers
06:07:13 <emk> Philippa: Some of the solutions with Dynamic or extistential types might be promising.
06:07:14 <Philippa_> and you rarely truly need to propagate the errors of three or four libraries very far
06:07:19 <ski> catch :: Either e0 a -> (a -> Either e1 a) -> Either e1 a  -- ?
06:07:23 <Philippa_> yeah, but you can blend that in to the same thing
06:07:36 <emk> Philippa: I have higher aspirations for my Haskell code then "not that ugly".
06:07:39 <Philippa_> ski: is roughly what I'm suggesting
06:07:56 <ski> (s/a ->/e0 ->/ obviously)
06:08:14 <Philippa_> emk: sure. Some of mine include a level of type safety that isn't present in the dynamic and existential cases
06:08:38 <Philippa_> we still need a version of that catch whatever else we do
06:08:56 <mux> I want Haskell to be able to warn me about possible exceptions that aren't handled
06:09:05 <mux> I guess that shouldn't be hard
06:09:26 <emk> Philippa: I've written plenty of code of code that needs to transmit dozens of kinds of rare errors back to a main loop (admittedly, after a while, most of them just need to support serialization as a string). This is incredibly common in big programs.
06:09:28 <Philippa_> at the moment, beyond that odds are we need to let the possible solutions evolve a bit because there isn't a One True Way yet
06:09:28 <mux> with an ADT?
06:10:00 <Philippa_> emk: right, by the time you hit the stage where they just need serialisability then feel free to wrap 'em in one generic existential wrapper. No big deal
06:10:06 <emk> Philippa: Yeah, the real solution involves subtyping or extensible ADTs, which amounts to the same thing.
06:10:30 <emk> Philippa: Yeah, but why should every Haskell program ever have to be larded up with this stuff?
06:10:33 <ski> (possibly polymorphic variants)
06:10:35 <mux> extensible ADTs, as in open data types?
06:10:44 <pejo> Wooohoo, subtyping!
06:11:10 <Philippa_> mux: catch' :: Either e a -> (e -> Either () a) -> Either e a?
06:11:20 <Philippa_> emk: because the alternatives break things fast
06:11:30 <Philippa_> because Haskell's about doing things the hard but right way
06:11:35 <emk> I mean, why can't Haskell be as graceful about error-reporting as the average scripting language?
06:11:45 <Philippa_> sure, want dynamic typing while you're at it?
06:11:47 <fax> which average scripting language?
06:12:10 <fax> id be impressed to see _any_ scrip language with "graceful" error handing
06:12:43 <QtPlatypus> fax: How do you define scripting lanaguage?
06:12:45 <Philippa_> (catch and catch' above need generalising to an Error class, of course)
06:12:51 <emk> Philippa: How does, say, the existing DynException break things? It allows the use of arbitrary error ADTs in the IO monad, and programs can (a) catch the ones they care about and (b) propagate everything else.
06:13:09 <fax> QtPlatypus: I dont, I just wanted to know what emk was referring to
06:13:17 <emk> fax: Python and Ruby both have a class hierarchy of exceptions, with the expected throw/catch forms.
06:13:27 <Philippa_> emk: and is useless outside the IO monad - which is good, because it's also missing all the type safety we're used to. It's not appropriate for non-IO errors
06:13:33 <fax> emk: isnt that quite simple to implement in haskell?
06:13:57 <emk> fax: Well, that's what I'm arguing for. :-)
06:13:59 <fax> (Im quite nwe to haskell so I really dont know)
06:14:37 <Philippa_> emk: except you're not so far, you're just saying "can't we call everything Dynamic?". Well no, I can't. I want to be able to tell what range of errors I might have to deal with - I want to know when I've written a total function
06:15:18 <emk> Philippa: Writing a total function that involves, say, malformed URLs, IO failures, parse failres, etc., etc., gets silly.
06:15:36 <Philippa_> fine. But don't force sloppy typing on everyone else
06:15:37 <emk> After a while, you've got 9 different types of things which might have gone wrong.
06:15:44 <fax> cant you use a more general catagory for errors?
06:15:54 <fax> put IO an parse failure in one section..
06:15:57 <emk> Philiipa: The problem domain forces the sloppy typing.
06:16:05 <Philippa_> emk: *Your* problem domain does
06:16:11 <Philippa_> I don't need it for parsing
06:16:14 <Philippa_> I don't need it for an interpreter
06:16:25 <emk> As soon as you start combing a half-dozen libraries off of Hackage, you get a half-dozen types of errors.
06:16:29 <Philippa_> I can get my typing right, and I'm going to be exceedingly annoyed if the standards prevent it for the next decade
06:17:25 <Philippa_> now, we're going to need the throwDyn stuff anyway, I don't think anyone doing IO'll argue with that
06:17:37 <emk> Philippa: And I'm equally dismayed about writing Either a (Either b (Either c (Either d (Either e)))) in the signature to every function. We need some better support at the typing level to resolve this.
06:17:50 <Philippa_> I don't think a single call to coerce errors to dynamics at library boundaries is much to ask
06:18:09 <Philippa_> emk: so build your own ADT representing the possible set of errors
06:18:12 <emk> Philippa: Yeah, but I've got a library boundary on every single line of code, sometimes.
06:18:19 * mux would use an ADT too
06:18:40 <Philippa_> to go a step further, build type classes to query the ADTs. Do the encoding thing, we know how
06:18:51 <emk> So I've got write a whole pile of little error-coercers, and use them on every line.
06:19:07 <Philippa_> sounds like you can afford to refactor a little there
06:19:22 <Philippa_> most of these errors're coming from different monads anyway
06:19:40 <Philippa_> in effect, you're already coercing
06:19:43 <ski> (emk : "positional variants" (beelsebob referred to them as "disjunctive tuples" i think) could maybe help a little .. though lightweight variants could be better (especially polymorphic ones))
06:19:50 <emk> And of course, everybody else who encounters the same problems I do will invent a _different_ convention. I know this song and dance from the Scheme world (where there are about 10 common ways to declare ADTs) and I hate it.
06:20:14 <emk> ski: Yeah, and O'Haskell could eat this problem for breakfast without breaking typing.
06:20:23 <Philippa_> but in the absence of a type system we don't have, *we aren't ready to standardise*
06:20:34 <emk> ski: But there are good reasons why Haskell doesn't have subtyping, and won't get them soon.
06:20:38 <Philippa_> the best we can standardise without fucking up is the existance of the generalised catch
06:21:32 <Philippa_> what you /can/ do, however, is request Dynamic-error versions of library boundary funcs where that's sane
06:21:52 <emk> Philippa: At a minimum, we need some sort of standard convention for doing 'Either Dynamic a' in a single way, so that people working with a mix of IO and lots of Hackage libraries don't reinvent it 10,000 times.
06:22:17 <Philippa_> okay, I'll buy that so long as it's not the One True Error-Handler
06:22:23 <emk> I mean, one ugly solution is bad, but 10,000 ugly solutions that all do the same thing is a crime against all that's good and holy.
06:22:50 <ski> emk : what about polymorphic rows, as in OCaml ?
06:23:03 <Philippa_> it *must not* be the underlying mechanism on everything, or we sacrifice things for everyone whose software can be made to work right
06:23:32 <emk> Philippa: I can buy that, too. There's lots of code which really wants to write 'Monad m => blah -> m blah' and just call 'fail'.
06:24:11 <emk> And there's no reason why that should have to pay the price of Dynamic, which would just be silly.
06:25:05 <Philippa_> the current fail's a Wrong Thing, IMO. It's uncatchable far too often, and effectively implies the existance of a string error form in all error types.
06:25:06 <Philippa_> but sure
06:25:25 <emk> Philippa: It's not really a matter of correctness, per se. I can give reasonable correctness proofs for code that handles N kinds of errors explicitly and propagates the rest.
06:26:19 <emk> Philippa: Yeah, fail should really take an ADT as an argument. But that brings us full-circle to the subtyping problem, which Haskell (rightfully) won't standardize in the next decade.
06:27:08 <Philippa_> but not too critically, because you only get it at the computation boundaries for that monad anyway
06:27:23 <Philippa_> you just need a trivial mod to your wrap function, no biggie
06:27:23 <emk> I fully grok why the "right" solution is simply unobtainable at the current state of theory, and why things have to stay that way. And I understand your reluctance to standardize the wrong solution.
06:27:29 <Philippa_> run func, even
06:28:02 <Philippa_> the interesting cases're when we have monads where we want to change the possible error set within a computation, we already have to pay interfacing costs between different monads
06:29:06 <emk> Philippa: I'm only griping because I've been trying to write programs that dig data off the web and do various sorts of inference/probability/whatever. And I'm just getting sick of the endless conversions between different error types. It's really a bigger problem in or near IO, where there are more types of errors.
06:29:35 <ski> mapExn :: MonadExn m => (e0 -> e1) -> m e0 a -> m e1 a  -- something maybe alike this .. ?
06:29:36 <emk> Deep in functional code, the problem doesn't really exist.
06:29:50 <Philippa_> *nod*
06:30:06 <Philippa_> I write a lot of stuff that's either deep in functional code or wrapping IO but only using it for not-really-IO purposes
06:30:30 <Philippa_> or where what actual IO occurs isn't /my/ IO - interpreters for code that does IO, say
06:31:08 <emk> Philippa: I'd really hate to have to write all these programs in Ruby (I need probability monads!), but with the current state of things, Haskell is taking far more code and time to accomplish simple tasks. And I'm not satisfied with being driven away from Haskell just because I need to use a bunch of libraries and write some code in IO.
06:32:06 <Philippa_> it's possible to type an "oh fuck it, I'm not going to catch any of this anyway" monad, FWIW
06:32:06 <emk> I want to stay in Haskell, without sacrificing my time or the (relative) clarity of my code.
06:32:26 <Philippa_> I get the impression that for most of what you're doing that's probably not totally inappropriate anyway
06:33:02 <emk> Philippa: Yeah, and that's really helpful. But I don't want to write a ninth Haskell error-hanlding convention unless I can get some standardization. I hate the way Scheme has ~10 common ways to declare ADTs.
06:33:13 <Philippa_> *nod*
06:33:56 <Philippa_> actually, that's a worthy addition to the current set of proposals
06:34:17 <Philippa_> as a desirable feature at the least
06:34:23 <emk> Philiipa: Because with N ways to do something, you need either 2N or 2^N glue functions, depending on how you approach the problem... It's better to generalize.
06:34:37 <mux> dcoutts_: ping
06:34:50 <emk> Try to find 1 or 2 or 3 good ways to do something, and establish conventions and standard APIs.
06:34:50 <Philippa_> yeah, I know
06:34:59 <Philippa_> I'm just suggesting our generalisation should cover the "oh fuck it" case
06:35:22 <emk> And the current state of things in Hackage just plain sucks. Error-handling is all over the map.
06:36:13 <Philippa_> anyway, would you like to summarise this for the mailing list? I'd offer but I'm unlikely to get it done - I'm happy to look over something before it gets posted though
06:36:23 <Philippa_> you might want to rename the don't-care case :-)
06:36:31 <emk> That's a good case to cover, as is the "deeply functional code where only two types of things can go wrong".
06:37:05 <Philippa_> often I've got more than two by the end, but sometimes it's appropriate to coerce all the errors I've caught to a simple error message format and dump 'em
06:38:12 <emk> Philippa_: Hmm. That feels a lot like encoding Dynamic as Show. Interesting.
06:38:47 <Philippa_> having identified the "many possible errors, need subtyping" case as a sub-issue does mean we can standardise the rest and rip/replace just the one part of the convention when something better comes along, too
06:39:02 <Philippa_> odds are I'll actually just be converting it to String
06:39:10 <Philippa_> but yeah, same idea
06:39:21 <Philippa_> I just don't have the subtyping to deal with
06:39:33 <Philippa_> because I'm expecting to catch the lot and just print
06:39:50 <emk> Philippa: I'm not horribly optimistic that we'll see subtyping in Haskell for a long time to come. The theoretical problems are just to messy, and few good solutions exist.
06:40:35 <pejo> emk, there doesn't seem to be much research going on in the field, rather than "it's too hard".
06:40:36 <emk> But I've copied this discussion to an Emacs buffer and I'll try to summarize some of the high points for the list.
06:41:29 <Philippa_> pejo: I'm not sure that's fair - we've got to the point where there are some "good as they're likely to get" solutions but they're all complicated for reasons that're known to be fairly unavoidable
06:41:48 <Philippa_> the bit where type constraints become inequalities rather than equations is a real PITA
06:42:18 <emk> pejo: Well, subtyping breaks the usual assumptions involved in H-M type inference pretty irrevocably. You can make a different set of assumptions and get O'Haskell, which I think is pretty spiffy. But it's definitely a different "flavor" than regular Haskell because of those changes assumptions, and there's a lot of places where the theory is still a mess.
06:42:41 <pejo> Philippa_, so there needs to be a good constraint solver.
06:43:06 <emk> pejo: The constraint solver turns out to be O(2^N), where N is the number of expressions in the program.
06:43:42 <pejo> emk, HM type inference is exponential too, studying worst case complexity isn't always meaningful.
06:43:48 <emk> pejo: O'Haskell solves this by abitrarily turning all inequalities into equalities unless explicitly declared otherwise.
06:43:53 <Philippa_> pushing HM(X) out into extensions that do things like local type inference would be a good piece of work to have done though
06:44:02 <pejo> emk, and most of all - the ordo-notation hides a lot of interesting information, like huge constants.
06:44:08 <Philippa_> well, IIRC some of that's been done but it's not a generally-understood thing yet
06:44:26 <emk> pejo: Yeah, but the exponential case in regular HM inference is obscure. With subtyping, the exponential behavior is the unavoidable common case.
06:45:11 <emk> The inequalities don't cancel out, they just keep multiplying forever.
06:45:17 <pejo> emk, well. I'll throw out a thesis - in reality, with real programs, the complexity isn't an issue. Neihter of us have any proof.
06:45:20 <emk> Your principle types become pages long.
06:45:57 <emk> I'm talking about typing half-page Haskell programs, not some special case.
06:46:29 <emk> Inequalities prevent unification from actually unifying, so the amount of type constraints just keeps exploding for ever.
06:46:35 <emk> Anyway, gotta run.
06:46:44 <pejo> emk, the option of making an incomplete but sound type inference algorithm (like O'Haskell) where you sometimes have to annotate your programs exist.
06:46:47 <emk> ttyl!
06:47:58 <pejo> Philippa_, local type inference where, in leaves of let-nodes?
06:48:50 <Philippa_> pejo: on the 'inside' of annotations that provide structure
06:48:53 <emk> pejo: Yeah, and I love that approach. But the Haskell community is unlikely to adopt it any time soon. Losing completeness is big step, and not one to be undertaken lightly (especially when the incomplete solution types a poorly-understood subset of programs correctly--there's still a lot of murk).
06:49:24 <Philippa_> pejo: it's the basic idea behind how we do rank-n types, GADTs and stuff like that
06:49:38 <emk> O'Haskell works great in practice, but nobody can explain why, exactly it breaks so infrequently.
06:50:44 <pejo> emk, my impression is that it's rather well understood when the inference algorithm cuts a corner.
06:51:16 <DRMacIver> What's O'Haskell like? I've vaguely looked at it and thought it looked interesting but not actually looked at any code.
06:52:30 <pejo> DRMacIver, O'Haskell is not very well supported, basically. By all means, look at it - but don't write your next mission critical system in it unless you have staff that are prepared to fix Hugs-internals. :-)
06:53:11 <DRMacIver> Yeah, I note that the site was last updated in 2001. :)
06:53:29 <DRMacIver> I'm more interested in it theoretically.
06:54:13 <DRMacIver> I've an interest in hybrid languages with hindley milner + subtyping.
06:54:25 <DRMacIver> Nice got me hooked and now I'm looking for what is needed to make them actually work. :)
06:55:53 <pejo> DRMacIver, theoretically it's an extension of the Haskell type system with subtyping, and the reactive objects that are documented in a separate article (probably in Nordlander's thesis too). The "Haskell typesystem" I'm talking about is what was implemented in a late hugs (1.3x?) iirc.
06:57:06 <pejo> late? I must mean early hugs there. This is the late 90's we're talking about.
06:59:09 <bits64> ?
07:00:23 <ski> ?yow
07:00:24 <lambdabot> Uh-oh!!  I forgot to submit to COMPULSORY URINALYSIS!
07:06:06 <DRMacIver> pejo: Well, that's a nice theory. :) Nice used something broadly similar - it has most of hindley milner + type classes + subtyping (which nicely leads into multiple dispatch).
07:06:36 <DRMacIver> (Problem is that the waters were muddied with all sorts of Java constructs)
07:06:54 <fax> Java only has one construct the OBJECT
07:07:06 <fax> :S
07:07:13 * fax flashbacks from classes
07:10:27 <bits64> set newuser on
07:11:09 <bits64> whois haskell
07:11:33 <Guest25023> bits64: ?
07:11:47 <DRMacIver> fax: Well in this case what I had in mind was that as well as its type classes it had Java-like interfaces.
07:12:38 <DRMacIver> Also semi Java like construcotrs.
07:12:46 <DRMacIver> (I suppose I shouldn't really be using the past tense here)
07:13:09 <bits64> names haskell
07:14:11 <pejo> Let's separate issues here, implementation inheritance and subtyping don't necessarily go hand in hand, for example.
07:17:49 <vincenz> heh
07:18:05 <vincenz> I'm contaminated by haskell
07:18:15 <vincenz> today there was an article on neonomads and I read it as neomonads
07:18:24 <mux> I just read it likewise
07:18:29 <mux> in your sentence :)
07:18:31 <fax> haha
07:18:34 <fax> same
07:19:43 <glguy> woohoo, I had a career high score on a reddit post :)
07:19:49 <glguy> 61 pts
07:19:50 <yaarg> lo
07:19:55 <glguy> lo
07:28:46 <DRMacIver> pejo: Sure
07:35:23 <Saizan> > let x = 1 + 0.5*x in x
07:35:25 <lambdabot>  Exception: <<loop>>
07:35:38 <Saizan> gah, fix doesn't do limits
07:36:01 <yip> STM is trying to kill me :/
07:37:26 <fax> x = 2
07:37:27 <fax> :D
07:37:47 <fax> referential transparency or somting
07:39:37 <Saizan> heh
07:40:10 <Saizan> today i saw that equation and stared at it saying "we're screwed! it's an endless strict recursion!"
07:40:55 <Saizan> then i remembered my algebra and moved the RHS x to the left :)
07:41:05 <fax> hahahaha
07:43:43 <yip> @seen roconnor
07:43:44 <lambdabot> roconnor is in #haskell. I last heard roconnor speak 20h 53m 53s ago.
07:45:10 <yip> anyone here good with STM?
07:45:34 <Eelis> is it worth reporting as a defect that cabal's auto-generated Paths_* modules don't contain type signatures for the symbols they export, causing annoying warnings (and even errors if the user is compiling with -Werror) ?
07:46:10 <Saizan> Paths_*?
07:46:37 <Eelis> Saizan: http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#paths-module
07:46:39 <lambdabot> Title: 2. Creating a package, http://tinyurl.com/yv8xjt
08:01:31 <Eelis> how do i find out what cabal version i have?
08:03:12 <glguy> yip what question did you have?
08:03:31 <glguy> I don't know if I can answer it, but you are really better off just asking
08:03:50 <yip> glguy: well i actually have this cool idea
08:03:59 <roconnor> hi yip
08:04:08 <vincenz> Lemmih: hi
08:04:14 <roconnor> I don't know STM :(
08:04:20 <vincenz> Lemmih: move to oasis, we're all there ;)
08:04:39 <yip> roconnor: do you know what ensureIOManagerIsRunning is?
08:04:51 <roconnor> never heard of it before
08:05:31 <roconnor> dear Haskell', can we have a strict version of hGetContents too?
08:05:35 <yip> roconnor: 30th June, 2006, 02:34am?
08:06:43 <roconnor> wow, apparently I have heard of it before
08:06:51 <roconnor> obviously it didn't stick
08:07:27 <yip> roconnor: you are the only lead i have... please tell me what ensureIOManagerIsRunning does
08:07:52 <roconnor> @hoogle ensureIOManagerIsRunning
08:07:53 <lambdabot> No matches found
08:08:01 <roconnor> where is it?
08:08:43 <quicksilver> GHC.Conc
08:08:51 <yip> http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html#v%3AensureIOManagerIsRunning
08:08:52 <lambdabot> http://tinyurl.com/ys92tb
08:09:15 <roconnor> yip: to be fair, I did say ensureIOManagerIsRunning with a question mark ;)
08:11:00 <yip> please man.... you gotta help me, i don't know where else to go
08:11:50 <roconnor> I think I was trying to ask what it does.  I'm afraid I have no idea
08:12:03 <glguy> Anyone have a recommendation on which library I should use to dump some data into a MSSQL db?
08:12:10 <ToRA> yip: i know nothing, but if this http://darcs.haskell.org/packages/base/GHC/Conc.lhs contains the current definition it doesn't look like much?
08:12:37 <mux> does GHC use Parsec for parsing .hs and .lhs files?
08:13:45 <yip> ToRA: hm....
08:13:56 <Philippa_> mux: nope, GHC seriously predates Parsec
08:14:03 <ToRA> yip: forces pendingevents to be evaluated...whatever that means
08:14:37 <mux> Philippa_: sure, but that wouldn't prevent GHC from using it if someone had taken care of rewriting the parser :-) anyways, thanks
08:14:45 <yip> what's the difference between unsafePerformIO and unsafeIOToSTM?
08:15:39 <roconnor> @type unsafePerformIO
08:15:41 <lambdabot> Not in scope: `unsafePerformIO'
08:15:51 <roconnor> @hoogle unsafePerformIO
08:15:52 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
08:15:58 <roconnor> @hoogle unsafeIOToSTM
08:15:58 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
08:32:51 * glguy wonders if any of the database interfaces are still being maintaned
08:34:01 <mahogny> has anyone yet bothered to update the SOC wiki project tickets?
08:34:06 * mahogny just cleaned up his -_-
08:39:09 <quicksilver> glguy: yes, they are
08:39:17 <quicksilver> glguy: takusen and hdbc, certainly
08:39:34 <glguy> sweet, I'll focus my search on those two
08:42:45 <glguy> It would seem that HDBC is the one of those two that support ODBC
08:43:59 <quicksilver> brOken DataBase Connectivity?
08:44:02 <quicksilver> lucky you :)
08:44:31 <glguy> I don't pick the database servers
08:44:33 <glguy> I just use them :)
08:46:54 <bakert> Howdy folks. Anyone ever done anything with SOAP and Haskell?  Or perhaps HAIFA?
08:47:10 <bakert> I need to make some (dead simple) calls to SOAP web services.  I'm trying to decide how to go about it.
08:47:27 <bakert> They are actually so simple that I might just hardcode a bit of XML and do it via Network.HTTP.
08:47:41 <bakert> But if there's a good way to do SOAP "properly" that would be nice.
08:47:49 <bakert> Any ideas?
08:48:23 <Saizan> uhm
08:48:54 <quicksilver> no, although there are a couple of XML-RPC modules in hackage
08:50:07 <quicksilver> bakert: google says that HAIFA has some SOAP stuff
08:50:14 <quicksilver> http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/08num.pdf
08:50:24 <Saizan> http://www.haskell.org/haskellwiki/Libraries_and_tools/Web_programming#XML-RPC_and_CORBA <--
08:50:26 <quicksilver> no idea if that's ancient + obsolete or new + shiny :)
08:50:27 <lambdabot> Title: Libraries and tools/Web programming - HaskellWiki, http://tinyurl.com/m537m
08:51:30 <Pastorn> ?src error
08:51:31 <lambdabot> error s = throw (ErrorCall s)
08:51:38 <Pastorn> @type throw
08:51:41 <lambdabot> Not in scope: `throw'
08:52:31 <quicksilver> Pastorn: that throw is some GHC internal throw
08:52:40 <Pastorn> oh
08:52:44 <quicksilver> at least, I think it is
08:52:55 <Pastorn> @type error
08:52:57 <lambdabot> forall a. [Char] -> a
08:53:03 <quicksilver> but there is Control.Exception.throw
08:53:07 <quicksilver> :t Control.Exception.throw
08:53:10 <lambdabot> forall a. GHC.IOBase.Exception -> a
08:53:25 <Pastorn> ok
08:53:28 <Pastorn> thanks
08:55:52 <bakert> quicksilver, thanks
08:56:00 <bakert> Saizan, thanks also!
09:01:42 <glguy> ?index bracket
09:01:43 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
09:04:30 <shapr> Good morning #haskell!
09:04:47 <therp> good afternoon :)
09:04:54 <tuukkah> good morning shapr :-)
09:06:33 <shapr> How's code?
09:08:15 <tuukkah> knallar och går
09:12:24 <tuukkah> > length "å"
09:12:25 <lambdabot>  1
09:12:51 <tuukkah> so where does lambdabot get its utf-8 powers
09:12:59 <tuukkah> from
09:13:04 <cjeris> clean living and a pure heart
09:13:07 <mauke> > length "€"
09:13:08 <lambdabot>  1
09:14:59 <glguy> ?t bracket
09:14:59 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:15:03 <glguy> :t bracket
09:15:06 <lambdabot> Not in scope: `bracket'
09:15:09 <chessguy> hi haskellers
09:15:12 <Saizan> tuukkah from an unpublished utf8.lhs module, but there's Data.CompactString now, on this haskell weekly
09:15:14 <glguy> :t Control.Exception.bracket
09:15:16 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:15:45 <xtruppaw> is there a place where you do submit haskell articles ?
09:16:08 <xtruppaw> I have heard of the haskell sequence for instance
09:16:10 <xtruppaw> other places?
09:16:25 <chessguy> TMR?
09:16:29 <chessguy> ?where tmr
09:16:29 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
09:16:38 <fasta> How can I see the intermediate output of cpp applied to my code?
09:17:00 <fasta> I already tried cpp <haskell code> | less, but that seems to give other output.
09:17:42 <xtruppaw> thanks chessguy ;)
09:18:06 <tuukkah> Saizan, thanks!
09:18:52 <Saizan> fasta: try with cpphs
09:18:57 <chessguy> and of course on the wiki would be great too
09:19:01 <fasta> Saizan: I already understand the problem.
09:19:09 <fasta> Saizan: I use // as an operator
09:19:16 <fasta> Saizan: CPP interprets that as a comment.
09:19:48 <fasta> So, the big question is: is it possible to use // as an operator in Haskell code, but not have CPP delete all the useful code?
09:20:02 <Saizan> but ghc doesn't use cpp, it uses cpphs, i'm not sure that it uses // as a comment marker
09:20:10 <mauke> run cpp in c89 mode?
09:20:42 <shapr> Isn't // already used as an operator?
09:20:51 <fasta> shapr: I redefined it.
09:20:54 <shapr> ah
09:22:10 <fasta> Saizan: Ok, then the question is how can I see the output of the code after the cpphs stage, and if that's incorrect code, how can I make sure that // isn't interpreted as a comment by it?
09:23:31 <fasta> Ok, I see the problem now.
09:23:54 <fasta> cpphs and cpp behave differently on the macro.
09:26:26 <fasta> mauke: do you know how the macro I asked about earlier looks in cpphs syntax?
09:27:30 <mauke> what macro?
09:30:12 <matthew_-> mmm. so would anyone support a proprosal to add a default variable to haskell, a la Perl?
09:31:26 <tuukkah> matthew-_, who could that work?
09:31:35 <tuukkah> how
09:32:14 <quicksilver> matthew_-: that sounds like a subset of implicit parameters
09:32:20 <quicksilver> matthew_-: (a single implicit parameter)
09:32:31 <quicksilver> matthew_-: sounds horrible to me, but please, convince me! Why would it be useful?
09:32:55 <fasta> mauke: The CONCAT macro
09:33:00 <tuukkah> i saw keyword parameters implemented for haskell somewhere
09:33:24 <glguy> SqlError {seState = "[]", seNativeError = -2, seErrorMsg = "execute allocHandle: []"}
09:33:28 <glguy> has anyone seen that error?
09:33:42 <Philippa_> matthew-_: sure, for as long as it took to carry the proposal towards an appropriate cliff to throw it over :-)
09:34:18 <matthew_-> err, it'd be useful because if you forgot to apply a value into a function, it'd try the "default variable" which may or may not work. Thus saving you from the annoyance of "oh damn it, isn't it obvious I meant to write that there?!"
09:34:30 <matthew_-> compelling.
09:35:05 <Philippa_> and if I deliberately didn't apply it?
09:35:12 <matthew_-> that would be obvious too
09:35:16 <mauke> fasta: oh, that was you?
09:35:51 <matthew_-> it would analyse the deliberateness of your typing so as to work out where you forgot to add the extra variable
09:36:00 <matthew_-> in fact, this shouldn't be limited to just a single variable
09:36:16 <matthew_-> there should be a whole set which it should try, where it was clear you meant something that's missing
09:36:23 <matthew_-> of course, it would choose the right one
09:36:25 <Philippa_> you're 19 days early, 'mafraid
09:36:43 <Philippa_> no, 20
09:36:55 <mauke> fasta: I've never used cpphs. doesn't it work as-is?
09:36:59 <matthew_-> Philippa_ ?
09:37:19 <fasta> mauke: no, I get foobar ## 54 instead of foobar54
09:37:33 <Philippa_> matthew-_: you're supposed to propose things like this on the 1st
09:37:48 <matthew_-> oh bother
09:37:54 * matthew_- feels a little slow
09:38:19 <quicksilver> matthew_-: that particular little misfeature of perl has in my personal experience been the root cause of a number of obscure bugs :) I'd only copy it if my intention was to confuse.
09:39:05 <tuukkah> matthew-_, this was the one i think: http://darcs.haskell.org/HList/keyword-arguments.lhs
09:39:09 <mauke> fasta: that's weird. the docs say  " ## ANSI-style token catenation"
09:39:11 <matthew_-> and monads aren't there to confuse?! ;-)
09:39:12 * matthew_- ducks
09:39:57 <fasta> mauke: I know, I checked the docs too.
09:39:59 <tuukkah> all of functional programming exists simply to confuse our von neumann brains
09:42:44 <mauke> fasta:  The ANSI ## token-pasting operator is available with the --hashes flag. This is to avoid misinterpreting any valid Haskell operator of the same name.
09:42:54 * sjanssen 's brain works via graph reduction
09:43:19 <kc5tja> Living it large at the new offices.  Oh yeah.  :)
09:43:24 <Saizan> (xslt: a semi-functional language where the if-equivalent is a statement and not an expression ==> pain)
09:43:28 <glguy> anyone used hdbc-odbc with ghc-6.6?
09:43:34 <malcolmw> fasta: there is a bug in cpphs that "x ## y" gives you "x y" (with spaces) rather than "xy"
09:43:36 <tuukkah> sjanssen, now that's some inside insight
09:43:58 <quicksilver> @quote research
09:43:58 <lambdabot> shapr says: I think the Haskell approach works fine. That is, stick with research and do the best you can. Then after fifteen years of gestation, take over the world.
09:44:04 <quicksilver> @quote research
09:44:05 <malcolmw> fasta: the bug was only reported on Thursday
09:44:05 <lambdabot> wkh says: why does the haskell webpage link to "research papers" under the "getting started" section?
09:44:26 <mauke> ok, so you need x##y or x/**/y?
09:44:59 <malcolmw> fasta: and indeed I was completely unaware of this usage pattern of cpp ## until then, so it is no wonder it it wrong :-)
09:47:22 <fasta> malcolmw: heh (I was just sending a mail to you)
09:47:23 <mauke> malcolmw: does it support line continuation in comments?
09:47:47 <fasta> malcolmw: Any "workarounds"?
09:47:49 <malcolmw> mauke: yes
09:48:08 <mauke> as in /\
09:48:09 <mauke> * this is a comment */
09:48:09 <malcolmw> fasta: you could use x##y (no spaces) or x/**/y
09:48:18 <fasta> malcolmw: ok
09:48:37 <mauke> what does _\
09:48:38 <mauke> _LINE__ turn into?
09:48:53 <malcolmw> mauke: line continuations are only in the Haskell part of the file
09:49:11 <malcolmw> mauke: not within the cpp parts
09:49:12 <fasta> malcolmw: that doesn't work here.
09:49:25 <fasta> malcolmw: I get foobar##54 back
09:49:27 <mauke> malcolmw: docs say "line continuations within all # directives"
09:49:32 <fasta> malcolmw: instead of foobar54
09:49:35 <malcolmw> fasta: cpphs --hashes
09:49:53 <fasta> malcolmw: How can I tell GHC that?
09:51:53 <malcolmw> fasta: -pgmPcpphs -optP--hashes
09:52:12 <mauke> AIIRRR
09:52:57 <malcolmw> mauke: what I mean is that if you #define a macro, then the rhs can contain line continuations, and these will be interpreted exactly like in Haskell
09:53:23 <mauke> haskell doesn't do line continuations
09:53:40 <malcolmw> mauke: and in Haskell, _\\n_LINE__ doesn't mean anything
09:53:57 <malcolmw> mauke: oh wait, am I getting confused with string continuations?
09:54:24 <mauke> string gaps?
09:54:27 <malcolmw> mauke: hmm,  and probably with layout as well
09:54:45 <malcolmw> mauke: OK, let's see if I can clear up the confusion
09:55:33 <malcolmw> a backslash at the end of a line containing a cpp directive means that the next line is considered as part of the same directive
09:56:16 <glguy> The HDBC-ODBC isntall says to modify your .cabal to point to your ODBC install... what is that on windows??
09:56:19 <malcolmw> with cpphs --layout the backslash disappears, but the newline remains, so that Haskell layout will be as expected
09:57:23 <mauke> "part of the same directive" - how is it joined?
09:57:32 <malcolmw> with cpphs --nolayout, both the backslash and the newline disappear
09:58:46 <malcolmw> so yes, I've just tested _\\n_LINE__, and it works (to my surprise)
09:59:40 <malcolmw> (albeit with the line number off-by-one)
10:00:02 <hpaste>  mauke pasted "cpphs test" at http://hpaste.org/945
10:00:20 <mauke> malcolmw: how does it handle that?
10:01:15 <malcolmw> mauke: hmm, it doesn't cope with a split comment
10:01:44 <mauke> the real cpp is a bit evil
10:02:08 <mauke> I haven't even started using trigraphs :-)
10:02:09 <malcolmw> mauke: probably because comment removal is done whilst parsing the line, whereas __LINE__ expansion is done at the usage site
10:02:50 <malcolmw> if you are doing anything that evil with cpp, then you probably need to rethink your Haskell coding style :-)
10:03:16 <kuribas> Wouldn't it be nice to have a function unfoldList in the standard libs?
10:03:26 <kuribas> like:  unfoldList f lst = if null lst then [] else let (hd, tl) = f lst in hd : unfoldList f tl
10:03:35 <vincenz> you mean map
10:03:50 <vincenz> map f [] = []
10:03:54 <kuribas> no
10:03:58 <vincenz> map f (x:xs) = f x: map f xs
10:04:07 <mauke> kuribas: unfoldr?
10:04:32 <kuribas> no:  unfoldList f = takeWhile (not.null) . unfoldr (Just . f)
10:04:39 <mauke> malcolmw: what's the point of having a preprocessor that still sucks and isn't compatible with cpp? :/
10:04:58 <sjanssen> kuribas: that doesn't seem very useful to me
10:05:04 <malcolmw> mauke: it sucks less? :-)
10:05:13 <mauke> no, at least I know how cpp works
10:05:36 <Cale> The variant of unfoldr I wish we had is  unfoldr p f g = map f . takeWhile p . iterate g
10:05:37 <malcolmw> mauke: you seem to know more about cpp than the average
10:05:38 <mauke> cpphs is kind of arbitrary (and buggy, it seems)
10:06:01 <malcolmw> mauke: the real cpp does all kinds of horrible things to haskell code
10:06:13 <kuribas> sjanssen: for example: unfoldList (splitAt 4) [1..12] => [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
10:06:17 <mauke> that's because cpp is really a C tokenizer
10:06:21 <malcolmw> mauke: and it keeps changing to break in new ways
10:06:28 <malcolmw> hence cpphs
10:06:31 <sjanssen> kuribas: ahh, now you've shown us a nice example :)
10:06:32 <quicksilver> Cale: although map f . takeWhile p . iterate g is nice and clear to me :)
10:06:40 <mauke> just use a sane preprocessor
10:06:59 <malcolmw> to iron out some of the horribleness of cpp, and restrict the suckiness to just the # directives
10:07:08 <Cale> quicksilver: Well, yeah, but it's a pattern that arises fairly often.
10:07:32 <malcolmw> mauke: you are welcome to use m4, or anything else :-)
10:08:04 <sjanssen> @type let unfoldList f = (\xs -> do (y:ys) <- f xs; return y) in unfoldList
10:08:07 <lambdabot> forall t (t1 :: * -> *) t2. (Monad t1) => (t -> t1 [t2]) -> t -> t1 t2
10:08:37 <malcolmw> cpphs is only designed to handle the common cases (although obviously I try to iron out bugs that hit anyone in practice)
10:09:10 <malcolmw> what on earth use is a C comment with a line break between the / and *
10:09:17 <sjanssen> @type unfoldr (\ys -> do (y:ys) <- splitAt 3 ys; return (y, ys)) [1..10]
10:09:20 <lambdabot>     Couldn't match expected type `Maybe t'
10:09:20 <lambdabot>            against inferred type `([a], [a])'
10:09:29 <Botje> needs more Just
10:09:49 <sjanssen> @type unfoldr (\ys -> do (y:ys) <- return $ splitAt 3 ys; return (y, ys)) [1..10]
10:09:52 <lambdabot>     Couldn't match expected type `([a], [a])'
10:09:52 <lambdabot>            against inferred type `[a1]'
10:10:23 <sjanssen> @type unfoldr (\xs -> do (y:ys) <- return $ splitAt 3 xs; return (y, ys)) [1..10] -- last time, I promise!
10:10:25 <lambdabot>     Couldn't match expected type `([a], [a])'
10:10:25 <lambdabot>            against inferred type `[a1]'
10:10:34 <Botje> > takeWhile(not.null) $ unfoldr (Just . splitAt 3) [1..10]
10:10:36 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
10:11:00 <quicksilver> Botje: as kuribas said, yes :)
10:12:22 <kuribas> splitAt returns a tuple...
10:12:56 <vincenz> curry
10:13:49 <malcolmw> mauke: your cpp example has been added to the cpphs regression test suite, and hopefully I'll get round to fixing it soon
10:13:52 <sjanssen> kuribas: ah yes, that was my issue!
10:14:57 <mauke> malcolmw: nice!
10:16:02 <xs> malcolmw, do you think there is still interest in a new type checker for yhc? (re: recent yhc ml discussions)
10:16:12 <kuribas> UnfoldList could be also useful with span.
10:16:25 <malcolmw> xs: well I'm still interested
10:16:53 <xs> malcolmw, ok! cool.
10:17:02 <malcolmw> xs: whilst I can appreciate that the easier route is just to steal ghc's front end, ultimately that isn't very healthy for the language as a whole
10:17:50 <matthew_-> grr. is there no splitBy ?
10:18:13 <xs> malcolmw, so it is perhaps more worthwhile aiming for something like a constraint-based type checker instead of another hindley-milner based one?
10:18:26 <malcolmw> xs: if the yhc folks don't want a new typechecker, then I'll happily incorporate it into nhc98 instead :-)
10:18:35 <sjanssen> @pl (\xs -> let ys = splitAt 3 xs in (guard . not . null . fst $ ys) >> return ys)
10:18:35 <lambdabot> ap ((>>) . guard . not . null . fst) return . fix . const . splitAt 3
10:18:41 <xs> heh :)
10:18:43 <sjanssen> clear as mud.
10:19:13 <quicksilver> > map fst . takeWhile (not.null.snd) . iterate (splitAt 4.snd) $ ([],[1..12])
10:19:15 <lambdabot>  [[],[1,2,3,4],[5,6,7,8]]
10:19:21 <malcolmw> xs: I think if we want to be able to keep up with GADTs and wotnot, then we at least need the power of System Fc, which has equality constraints
10:19:25 <quicksilver> this is just not quite the right way to put this example into Cale's format :)
10:19:29 <Igloo> xs: I think best would be whatever is easiest and simplest, bearing in mind the sorts of things Haskell' is likely to want to add in
10:20:11 <malcolmw> xs: so using constraints more generally might be a good thing, especially since they seem to be able to provide better error messages
10:20:30 --- mode: irc.freenode.net set +o ChanServ
10:20:50 <xs> Igloo, simplest as it can be changed easily?
10:21:08 * mnislaih cries for a constraint based typechecker like Chamaleon in GHC
10:21:12 <malcolmw> xs: but I'll be happy with an ordinary(!) H-M + MPTC + rank-2 + existentials + ... typesystem
10:21:13 <xs> malcolmw, is there perhaps something i can read about constraint resolution type checking? i'm going through TaPL at the moment.
10:21:13 <Igloo> xs: simplest meaning it's easy for someone else to come along, work out how it works and change it
10:21:24 <xs> ah, yes :)
10:22:01 <mnislaih> xs: look for Martin Sulzmann work on Chameleon two or three years ago
10:22:23 <shapr> Yeah, Sulzmann's CHR for type checking is fun.
10:22:26 <xs> mnislaih, :) was just checking that out :)
10:22:40 <malcolmw> xs: bernie pope suggested that it might be possible to join Chameleon up to yhc/nhc
10:23:06 <mnislaih> that'd be awesomeish
10:23:06 <xs> hm, interesting.
10:23:16 <xs> thanks!
10:23:34 <roconnor> @hoogle zipWith
10:23:35 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
10:23:35 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
10:23:35 <lambdabot> List.zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
10:23:59 <yip> Igloo: maybe you know what ensureIOManagerIsRunning is?
10:24:25 <vincenz> @google ensureIOManagerIsRunning
10:24:28 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/base/GHC-Conc.html
10:25:04 <vincenz> yip: it's to ensure that you have windows running
10:25:17 <Igloo> yip: I'm not sure when you'd use it, if that's what you mean?
10:26:07 <yip> hm...
10:27:46 <fasta> malcolmw: cpphs --hashes => foobar__LINE__ instead of foobar<line number>
10:28:40 <malcolmw> fasta: from what source?  foobar##__LINE ?
10:29:10 <Igloo> That sounds like the same difference as there was between OS X's cpp and gcc's cpp that we were talking about the other day
10:38:28 <fax> hey I wrote some atrocious haskell code
10:38:56 <chessguy> join the crowd
10:39:01 <fax> should I add error checking and release it or just dispose of it humanely?
10:39:02 <Philippa_> keep it for the next IOHCC?
10:39:03 <fax> hehe
10:39:18 <fax> its not even IOHCC its just "This person has no clue what they are doing"
10:39:29 <fax> (but its my first program so I dont care so much0
10:39:51 <fax> I mean, is it useful to release what is clearly _bad_ code?
10:40:03 <chessguy> why not refactor it and clean it up first?
10:40:15 <fax> yeah I was going to add some more error checking and so o n
10:41:06 <yip> bad code is better than no code
10:41:15 <fax> hm ok :D
10:41:23 <yip> ... sometimes
10:41:25 <Philippa_> yip: depends on how bad
10:41:27 <fax> heh
10:41:28 <Philippa_> is it /correct/ code?
10:41:39 <fax> em not yet
10:41:46 <fax> I dont have every pattern match  I need
10:41:48 <fax> but I would fix that
10:42:23 <fax> does this: http://img45.imageshack.us/img45/4925/logocooluq0.gif
10:42:26 <Philippa_> get it correct and patch up things that look like they've been done for a good-but-obscure reason but haven't?
10:42:26 <yip> how come some runtime errors give you the source location and lots of helpful information and other runtime errors tell you nothing?
10:42:35 <fax> haha
10:42:42 <fax> sounds like a good plan
10:44:30 <fasta> yip: I think you mean that when you use "error", you get bad run-time errors.
10:45:09 <yip> fasta: well, an invalid (!!) call gives a bad error, but i remember experiencing a previous error that gave me the source location
10:45:13 <Lemmih> yip: Helpful information isn't always available.
10:49:33 <glguy> has anyone knows that HXT's readDocument changes the cwd?
10:50:03 <glguy> hmm
10:50:11 <glguy> that was a poorly worded "sentense"
10:50:40 <monochrom> It doesn't change the cwd.
10:50:46 <SyntaxNinja> dons: malcolmw: we have to apply to soc before today, right?
10:50:57 <glguy> monochrom: it seems to for me, at least on windows
10:51:34 <monochrom> I cannot get it to change the cwd.
10:51:42 <glguy> monochrom: when I load 10 files in a row in the same arrow
10:51:52 <glguy> it changes the directory it's looking for 10 deep
10:51:58 <glguy> that directory doesn't actually exist though
10:52:15 <malcolmw> SyntaxNinja: application already filled in
10:52:19 <glguy> fatal error: file ".../surveys/surveys/surveys/surveys/sur..."
10:52:23 <glguy> not found
10:52:39 <glguy> where the filename is "surveys/something.xml"
10:52:54 <malcolmw> SyntaxNinja: I have four more tries if there was anything wrong with the first one
10:52:58 <glguy> maybe it doesn't change the cwd
10:53:06 <glguy> just hxt's path
10:53:16 <SyntaxNinja> malcolmw: yay
10:53:19 <SyntaxNinja> you rock :)
10:55:46 <kc5tja> Speaking of error handling, what IS the best/recommended approach to error handling in Haskell?
10:56:09 <monochrom> Haha, interesting, glguy.
10:56:56 <glguy> monochrom: you were able to replicate?
10:57:03 <monochrom> Yes.
10:57:08 <ray> ooh, someone had a flog post on that error stuff
10:57:20 <ray> it was super fascinating! i forgot whose it was though
10:57:39 <vincenz> flog post?
10:57:49 <ray> i replace some words
10:57:50 <ray> :)
10:57:51 <vincenz> a place to flog people for their errorandling?
10:58:02 <ray> i could use about..3 of those
10:58:17 <ray> one for general use, and two for web developers
10:58:49 <vincenz> web developer....hehe
10:58:54 <vincenz> that's like ... personal hygiene engineer
10:59:16 <ray> same principle, yeah
10:59:17 * glguy wonders if there is a better way to write: catA (map constA xs)
11:00:43 <glguy> ?hoogle changeDirectory
11:00:43 <lambdabot> No matches found
11:01:11 <glguy> ?hoogle setCurrentDirectory
11:01:11 <lambdabot> Directory.setCurrentDirectory :: FilePath -> IO ()
11:01:12 <lambdabot> System.Win32.File.setCurrentDirectory :: String -> IO ()
11:01:12 <lambdabot> System.Win32.File.c_SetCurrentDirectory :: LPCTSTR -> IO Bool
11:04:03 <glguy> ugh, readDocument doesn't even respect setCurrentDirectory
11:04:04 <monochrom> glguy: it's hxt's own stateful path.
11:04:11 <glguy> ah
11:05:15 <glguy> monochrom: and how do I set that?
11:05:30 <monochrom> It is consistent with web browser expectations. E.g., you browse "x/x.html", then you browse "y.html", you expect the latter to be under "x/".
11:05:41 <monochrom> Supposed you should try to use absolute paths.
11:05:48 <vincenz> monochrom: pm
11:05:55 <vincenz> monochrom: not idented :)
11:06:04 <monochrom> Sorry, I don't do pm.
11:06:12 <vincenz> Well just curious which toronto uni
11:06:39 <monochrom> There is only one "University of Toronto"
11:06:43 <glguy> ?hoogle Absolute
11:06:43 <lambdabot> System.IO.AbsoluteSeek :: SeekMode
11:06:44 <lambdabot> Network.URI.isAbsoluteURI :: String -> Bool
11:06:44 <lambdabot> Network.URI.parseabsoluteURI :: String -> Maybe URI
11:06:56 <roconnor> @pl (\n -> fromJust $ lookup n valueData)
11:06:56 <lambdabot> fromJust . flip lookup valueData
11:07:15 <roconnor> @pl fmap f . g
11:07:15 <lambdabot> fmap f . g
11:08:26 <glguy> monochrom: recommendations for making a FilePath absolute?
11:08:29 <roconnor> @pl (map (fmap (fromJust . flip lookup valueData) . name) cs)
11:08:29 <lambdabot> map (fmap (fromJust . flip lookup valueData) . name) cs
11:08:32 <monochrom> glguy: how about this.  use getCurrentDirectory to fetch the cwd, henceforth prepend that to your "survey/xxx.xml" to form an absolute path.
11:08:50 <vincenz> monochrom: anyways, went to toronto last year and loved it, but I guess it gets less nice in the winter?
11:09:00 <glguy> ok, it's barbaric , but I'll do it ;)
11:09:49 <monochrom> It may sound like inconvenient.  But I'm sure the WWW people has a reason for it.
11:10:19 <monochrom> At least it makes sense for a web browser.
11:11:38 <glguy> liftM2 (map . (</>)) getCurrentDirectory (glob "*.xml")
11:11:57 <monochrom> Here is a reason.  You fetch file:///foo/x/x.xml.  Inside you find a hyperlink saying "y.xml" and you want to fetch it.  Where do you expect y.xml be?
11:12:24 <glguy> monochrom: from that point of view it makes sense
11:12:29 <glguy> I just wasn't using it like that
11:12:33 <glguy> so it was confusing
11:12:47 <monochrom> A good library should let you modify the base uri at will.
11:13:14 <monochrom> HXT may even have that, I just haven't found out how.
11:13:55 <monochrom> vincenz: due to global warming, Toronto has nicer winters than the rest of the world :)
11:14:27 <vincenz> monochrom: Alright, anyways, it's a stunning city :)
11:18:53 <glguy> invalid URI file://c:/this/that ?
11:19:01 <monochrom> glguy: setBaseURI and getBaseURI
11:19:11 <glguy> what namespace?
11:19:16 <glguy> I have the docs open
11:19:23 <monochrom> Text.XML.HXT.Arrow.XmlIOStateArrow
11:20:17 * glguy wonders if hxt is win32 friendly
11:20:22 <monochrom> runInLocalURIContext is of great use :)
11:21:05 <glguy> monochrom: that might help a lot
11:21:40 <monochrom> runInLocalURIContext (readDocument [(a_validate,"0")] filename)  is nice :)
11:23:08 <monochrom> HXT is immense :)
11:23:27 <glguy> monochrom: I think there is a (.) between the first command and the (
11:23:30 <glguy> OH
11:23:31 <glguy> nvm
11:23:34 <glguy> you had the filename in there
11:23:37 <glguy> I'm using it in a map
11:23:43 <glguy> fatal error: illegal URI : "surveys/abcd.xml"
11:24:57 <monochrom> Oh, point.  May need \, i.e., \\
11:28:16 <glguy> ugh, I think that the base url (the starting one) is invalid
11:28:44 <glguy> and MissingH doesn't honor the FilePath conventions
11:28:57 <glguy> I have to map normalise `fmap` glob "surveys/*.xml"
11:30:34 <therp> why is orElse part of Data.Generics.Aliases and not Data.Maybe?
11:33:13 <fantasma> > let fac n = product [1..n] in filter (isCurious) [1..1000] where isCurious x =  x == (sum . map fac . digitsToInt . show) x
11:33:13 <lambdabot>  Parse error
11:34:16 <roconnor> fantasma: can't use a where clause like that
11:34:27 <fantasma> roconnor: hmmm ok
11:34:38 <roconnor> you can use a let instead
11:35:10 <fantasma> > let fac n = product [1..n] in filter (\x -> x == (sum . map fac . digitsToInt . show) x) [1..1000]
11:35:11 <lambdabot>   Not in scope: `digitsToInt'
11:35:24 <fantasma> :t digitToInt
11:35:26 <lambdabot> Char -> Int
11:35:37 <fantasma> > let fac n = product [1..n] in filter (\x -> x == (sum . map fac . digitToInt . show) x) [1..1000]
11:35:38 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
11:35:49 <fantasma> ohhh yah
11:36:21 <fantasma> > let fac n = product [1..n] in filter (\x -> x == (sum . map (fac . digitToInt) . show) x) [1..1000]
11:36:22 <lambdabot>  [1,2,145]
11:36:27 <fantasma> PERFECT
11:36:31 <fantasma> ;)
11:36:57 <roconnor> 1 + 2*3*4 + 2*3*4*5
11:37:01 <roconnor> > 1 + 2*3*4 + 2*3*4*5
11:37:03 <lambdabot>  145
11:37:06 <roconnor> :)
11:37:35 <fantasma> yup
11:37:52 <fantasma> 40585 too
11:38:22 <fantasma> > let fac n = product [1..n] in fac 4 + fac 0 + fac 5 + fac 8 + fac 5
11:38:24 <lambdabot>  40585
11:38:36 <roconnor> > product [1..9]
11:38:38 <lambdabot>  362880
11:39:06 <roconnor> curious numbers cannot exist too far beyond 9!
11:39:38 <fantasma> I think so too but I am checking to 1 billion
11:40:05 <fantasma> because I can't seem to prove it
11:40:09 <roconnor> I think 10 million is more than enough
11:42:31 <fantasma> hugs is churning
11:42:47 * fantasma hopes for something beyond 40585
11:43:24 * glguy determines that HXT isn't going to be able to do what he wants
11:49:00 <pitecus> @hoogle Set (k, v) -> Map k v
11:49:01 <lambdabot> No matches, try a more general search
11:54:40 <sjanssen> @type Data.Map.fromAscList . Data.Set.toAscList
11:54:42 <lambdabot> forall k a. (Eq k) => S.Set (k, a) -> M.Map k a
11:55:01 <sjanssen> pitecus: ^^^, the fastest way to do it
11:55:22 <pitecus> sjanssen, thanks
11:55:36 <sjanssen> pitecus: you might have trouble with overlapping elements, though
11:55:53 <resiak> @type nubBy
11:55:55 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
11:56:01 <pitecus> sjanssen, there shouldnt be any
11:56:36 <resiak> @pl \x y -> snd x == snd y
11:56:37 <lambdabot> (. snd) . (==) . snd
11:56:47 <sjanssen> > M.fromAscList . S.toAscList . S.fromList $ [(1, 'a'), (2, 'b')]
11:56:48 <lambdabot>   Not in scope: `S.fromList'
11:59:26 <desp> what would you recommend for parsing xml in haskell?
12:02:06 <fantasma> there is HaXml, Haskell XML Toolbox, HXML, among others I would imagine
12:08:20 <thedward> I'm using ghc6 (6.6) from debian testing, and am trying to run a Cabal Setup.lhs and it complains that it can't find Distribution.Simple (despite the fact that it appears to be installed); Any ideas?
12:09:07 <Saizan> you can load that module in ghci?
12:09:16 <thedward> nope
12:09:54 <thedward> but, there is a /usr/lib/ghc-6.6/imports/Distribution/Simple.hi
12:10:10 <thedward> but. hmm. with -v it says it is looking for Distribution/Simple.hs
12:10:21 <Saizan> is Cabal listed in your ghc-pkg list? and not between parentesys?
12:12:03 <thedward> hmm. not listed at all.
12:13:02 <Saizan> so it has not been registered, at least
12:14:49 <thedward> I wonder how I managed to break this. It has worked fine in the past.
12:15:56 <glguy> monochrom: still there?
12:16:05 <sjanssen> does Debian have a separate cabal package?
12:16:07 <thedward> well, reinstalling (the same version) of ghc6 seemed to fix it.
12:16:15 <thedward> sjanssen: nope, it is part of the ghc6 package
12:16:17 <monochrom> yes
12:17:13 <glguy> monochrom: do you know how I might wite a function that either returns the found element, or a default value, instead of acting as a filter for the value?
12:17:17 <glguy> example:
12:17:39 <glguy> deep (hasName "aName" <<< isElem)
12:17:54 <glguy> so that for each thing searched I get the thing found or a default
12:18:14 <glguy> I do 6 of those
12:18:40 <glguy> but if any of them fails , I still want the others with the failed one having a Nothing in it's slot on the data constructor
12:19:35 <glguy> using orElse maybe?
12:20:42 <monochrom> orElse is good.  there is also withDefault
12:21:02 <glguy> withDefault is better than: `orElse` constA ""
12:21:04 <glguy> :)
12:21:05 <glguy> cool, thnx
12:24:44 <resiak> Why is orElse in Data.Generics.Aliases not Data.Maybe?
12:24:58 <glguy> monochrom: last issue, any tips for URI's with spaces in them?
12:25:09 <glguy> I'm running my URIs through mkAbsURI
12:25:13 <monochrom> %20
12:25:17 <glguy> and I'm using runInLocalURIContext
12:25:18 <monochrom> err %32
12:25:20 <sjanssen> @hoogle orElse
12:25:20 <lambdabot> GHC.Conc.orElse :: STM a -> STM a -> STM a
12:25:21 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
12:25:31 <glguy> mkAbsURI does the %20 replacement
12:25:43 <sjanssen> resiak: it probably shouldn't be exported from Data.Generics.Aliases
12:25:59 <sjanssen> resiak: you can use mplus from Control.Monad instead
12:26:03 <sjanssen> @hoogle mplus
12:26:04 <lambdabot> Control.Monad.mplus :: MonadPlus m => m a -> m a -> m a
12:26:07 <resiak> yeah, I figured it was equal to mplus
12:26:18 <monochrom> Network.URI has functions for escaping special characters in URIs.
12:26:30 <glguy> OH
12:26:33 <resiak> (and I already use `mplus`, but `orElse` is more obvious!)
12:26:42 <glguy> you have to encode the input to mkAbsURI
12:26:44 <glguy> yourself
12:28:50 <Orphi> greetings, assorted cognitive entities!
12:29:22 <Orphi> can anybody explain to me what a "combinator" is?
12:30:55 <quicksilver> Orphi: yes
12:31:09 <quicksilver> Orphi: typically it's a higher order function
12:31:23 <quicksilver> Orphi: which enables you to construct new functions without using 'formal parameters'
12:31:25 <fasta> "Run the C pre-processor on Haskell source files" <- what C pre-processor is meant by this?
12:31:52 <kc5tja> fasta: The one that handles #include
12:31:56 <kc5tja> #define etc.
12:32:04 <Orphi> ...ok, so when somebody says "Parsec is a combinator library"... what exactly are they saying?
12:32:15 <fasta> kc5tja: I mean what binary or what program is being called.
12:32:21 <fasta> kc5tja: I know its purpose.
12:32:29 <kc5tja> Hey, I can't be expected to know EVERYTHING now... ;D
12:32:30 <resiak> `cpp`, presumably
12:32:52 <quicksilver> Orphi: that it contains a bunch of higher-order functions which are you expected to use to combine your functions
12:32:55 * kc5tja just popped in after spending about two hours hacking a Python script.  Now, it's time to enjoy some hardcore Java coding.  Uugh.
12:32:59 <quicksilver> Orphi: (in order to produce parsers, in this case)
12:33:17 <quicksilver> Orphi: combinators combine functions :)
12:33:27 <Orphi> right. so... a library following the idiom of defining a few base cases plus a systemic way to combine them?
12:33:38 <quicksilver> yes
12:33:43 <Orphi> I see...
12:33:49 <quicksilver> that's not precise, but it's close
12:34:05 <Orphi> fasta: it's probably a switch to the main system C compiler
12:34:05 <quicksilver> you make bigger parser out of smaller parsers
12:34:19 <quicksilver> rather that making bigger parsers out of some external definiton format
12:34:22 <Orphi> quicksilver: or make bigger financial constracts out of smaller ones
12:34:28 <quicksilver> Orphi: right
12:34:33 <Orphi> quicksilver: (can you guess what I'm reading? heh.)
12:34:35 <quicksilver> Orphi: or probability distributions
12:34:46 <quicksilver> Orphi: or 3D models
12:34:53 <Orphi> ...or music..
12:34:54 <quicksilver> Orphi: or music, or GUIs, or .... :)
12:35:13 <Orphi> ...or transactions, apparently
12:35:19 <fasta> If that's the case, then how can I pass options to the C preprocessor?
12:35:41 <Orphi> faster: erm... more command-line switches, as a guess. not something I've ever tried :|
12:36:07 <dylan> fasta: -Dfoo=bar?
12:36:18 <Orphi> ok, next question... what is "type arithmetic", and why in the name of God would you want this?
12:36:35 <quicksilver> Orphi: it's arithmetic-in-the-type-system
12:36:47 <Orphi> quicksilver: that answers part #1...
12:36:48 <quicksilver> Orphi: it's useful for tricks like 'List-of-length-n' as a type
12:37:06 <quicksilver> a.k.a. dependent types
12:37:29 <fasta> dylan: I mean in the {-# OPTIONS_GHC part
12:37:39 <Orphi> quicksilver: you mean I can, like, write some function that takes two lists containing at least 4 items and return a list containing at least 8 items or something?
12:38:17 <quicksilver> Orphi: well, you can, but it's really not very pretty IMO
12:38:27 <Orphi> quicksilver: I noticed.
12:38:33 <quicksilver> Orphi: the haskell type system wasn't designed for this, it just turned out to be possible
12:38:40 <Orphi> quicksilver: somebody has released a library for it.
12:38:43 * quicksilver nods
12:38:45 <quicksilver> right
12:38:47 <Orphi> quicksilver: I'm still left wondering why you'd bother
12:38:48 <bd_> fasta: "Additional arguments to the pre-processor can be passed in using the -optF option. These are fed to cmd on the command line after the three standard input and output arguments."
12:39:00 <quicksilver> It looks a bit better in languages which were always designed to have it
12:39:10 <Orphi> quicksilver: and also... doesn't this just mean it's now extremely likely that compilation will never terminate?
12:39:17 <quicksilver> although it always involves proof obligations, which are irksome without tool support
12:39:28 <quicksilver> Orphi: no, haskell compilation is terminating
12:39:36 <quicksilver> Orphi: there might be a bug in GHC, but I haven't heard of it
12:39:37 <fasta> bd_: Isn't that the _Haskell_ preprocessor?
12:39:44 <Orphi> quicksilver: right - so there are conditions that can never be implemented then.
12:39:48 <quicksilver> Orphi: correct
12:39:48 <Cale> "Who do you want to invite to the party?" -> "Who do you wanna invite to the party?". "Who do you want to come to the party?" -> "Who do you wanna come to the party?". Interesting that the second transformation makes no sense, while the first is okay.
12:40:06 <Orphi> quicksilver: e.g., I can't say "this function takes any point belonging to the Mandelbrot set"
12:40:16 <bd_> fasta: oh, point
12:40:34 <bd_> fasta: -optP
12:40:56 <quicksilver> Orphi: you can probably say that. But good luck encoding the rationals into the type system, and then a rational-version of the mandelbrot criterion
12:41:04 <fasta> bd_: In what section is -optP? I can't find it.
12:41:16 <quicksilver> Orphi: and then, anyone calling that function has to provide a 'proof' in the type system that it is in the mandelbrot set
12:41:18 <Orphi> quicksilver: the number of iterations required to determine membership of the M set is unbounded.
12:41:20 <bd_> fasta: http://people.reed.edu/~carlislp//ghc6-doc/users_guide/options-phases.html 4.10.2
12:41:22 <lambdabot> http://tinyurl.com/2ac9l2
12:41:41 * fasta needs a PDF version of the user guide
12:41:47 <quicksilver> Orphi: right, *checking a proof* that a point is in the set is decidable
12:41:53 <quicksilver> Orphi: providing that proof is unbounded
12:42:01 <quicksilver> Orphi: but the programmer has to provide the proof, not the compiler :)
12:42:13 <quicksilver> Orphi: all the compiler has to do is check the proof
12:42:31 <Orphi> quicksilver: ok, another question... given that proof is impossible, why does anybody care about trying to prove things?
12:42:50 <quicksilver> Orphi: because it's possible to prove enough interesting things
12:43:04 <Orphi> quicksilver: what kinds of useful things can be proved then?
12:43:20 <quicksilver> Orphi: that a tube signalling system will never allow two trains within 1 mile of each other
12:43:39 <quicksilver> Orphi: that a financial market platform will never sell the same shares twice
12:43:44 <Orphi> quicksilver: surely that only works assuming that the stuff the computer controls works properly?
12:43:53 <quicksilver> Orphi: right. it's still interesting though.
12:44:02 <Orphi> quicksilver: and that the Galliliean transform is in fact valid for non-relativistic speeds...
12:44:05 <quicksilver> Orphi: you can be quite precise about your assumptions
12:44:15 <Cale> I wonder whether there are points which are undecidable relative to the M-set.
12:44:33 <Orphi> Cale: how do you mean?
12:44:38 <fasta> I have: {#- OPTIONS_GHC -cpp -optP -std=c89 #-}, but I don't get the same code out when I do cpp -std-c89 <the file>
12:44:52 <Cale> That is, it's impossible to construct a proof that they either lie inside or outside it.
12:45:21 <Orphi> Cale: it is always possible to tell, theoretically. it just requires arbitrary amounts of time and computational precision.
12:45:28 <Orphi> Cale: oh, wait - irrational numbers! ;-)
12:45:46 <Cale> :)
12:46:01 <Orphi> quicksilver: it just seems to me that usually in programming, specifying what the program is *supposed* to do is the hard part.
12:46:17 <Cale> The inside of the M-set is defined by points such that the sequence of iterates is bounded.
12:46:19 <Orphi> quicksilver: you can never prove that that part is right, so it all seems a tad... hopeless.
12:47:02 <quicksilver> Orphi: proof always has to start somewhere
12:47:04 <Orphi> Cale: right. for an infinite number of iterations.
12:47:04 <Cale> So "it's not escaped within a billion iterations" is still not a proof that it won't eventually escape.
12:47:13 <Orphi> Cale: exactly.
12:47:24 <quicksilver> Orphi: you may not be able to prove 1+1=2, you may choose to take that as an axiom, for example
12:47:29 <Cale> One can imagine a theorem-prover version of an M-set generator.
12:47:32 <quicksilver> Orphi: that doesn't make arithmetic useless
12:47:32 <Orphi> Cale: for many points, the orbit goes into a repeating loop, so that's your "proof"
12:47:38 <Cale> right
12:47:54 <quicksilver> Orphi: program proof has to accept the program spec as an 'axiom'
12:47:57 <Orphi> quicksilver: I see.
12:48:00 <quicksilver> Orphi: but again, that doesn't make it useless
12:48:31 <quicksilver> my statement 'this financial market software will never sell the same shares twice' can be expressed quite precisely
12:48:45 <quicksilver> and believe me, a bank would pay money to prove that was true :)
12:48:47 <Orphi> quicksilver: I still think that trying to "prove" that a program works is overkill; a very strong assurance would seem quite adaquat.
12:49:11 <Cale> Oh, interesting, the area of the M-set is conjectured to be sqrt(6 pi - 1) - e
12:49:37 <Orphi> Cale: there are many conjectures about M. most are very hard to prove ;)
12:49:40 <Cale> It's been shown to be 1.50659177 +- 0.00000008
12:49:51 <Cale> > sqrt (6*pi - 1) - exp 1
12:49:53 <lambdabot>  1.5065916514855036
12:50:20 <Orphi> quicksilver: so, realistically, what can you use type arithmetic for?
12:50:30 <Orphi> quicksilver: banning that damn "head []" error? ;)
12:51:15 <Orphi> Cale: as it so happens, I'm currently attempting to write a Mandelbrot plotter...
12:51:24 <Orphi> Cale: ...but being kinda thwarted by Gtk :S
12:53:32 <monochrom> use SOE first :)
12:53:44 <Orphi> monochrom: thanks - that doesn't work either. :P
12:55:39 <Orphi> mmm... way to kill a conversation :|
12:56:25 <Orphi> eeps! I killed #haskell... run away! x_x
12:56:38 <sjanssen> ha
12:57:35 <sjanssen> @quote
12:57:36 <lambdabot> BjarneStroustrup says: Within C++, there is a much smaller and cleaner language struggling to get out.
12:58:17 <knobo> Hi, what is the difference between the to "take" functions in A Gentle Introduction to Haskell: http://haskell.cs.yale.edu/tutorial/patterns.html
12:58:18 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
12:58:20 <knobo> ?
12:58:45 <sjanssen> knobo: try running them
12:59:05 <knobo> I see the result in the doc, but I dont get the theory
12:59:17 <sjanssen> compare "take 3 [1..]" and "take1 3 [1..]
12:59:30 <sjanssen> knobo: the idea is that Haskell matches patterns from top to bottom
12:59:38 <narain> knobo: the patterns are tested one by one and the first one that matches is used
12:59:42 <opqdonut> > take1 3 [1..]
12:59:44 <lambdabot>   Not in scope: `take1'
12:59:52 <opqdonut> ah
12:59:58 <opqdonut> missed the bit about yaht
13:00:53 <sjanssen> actually my example wasn't a good one
13:01:10 <monochrom> the examples in the same tutorial are good ones.
13:01:19 <knobo> "take? _ [] = []" will never match "take? 3 [1..]"
13:01:42 <monochrom> try to explain why "take1 0 undefined" aborts.
13:01:46 <knobo> because the last param wil never be []
13:01:47 <sjanssen> knobo: you should ignore my examples
13:01:54 <knobo> sjanssen: pl
13:01:58 <knobo> sjanssen: ok
13:03:46 <knobo> but "_ []" and "0 _" (as args) does the same
13:04:18 <sjanssen> knobo: they aren't quite the same in the presence of _|_ (read as bottom, same as undefined and calls to error)
13:04:55 <sjanssen> has this tutorial taught about things that result in _|_?  pattern match failures, etc.
13:04:58 <knobo> sjanssen: but bot is not evaluated until it's needed. which is never in this case
13:05:26 <knobo> sjanssen: not as far as I can see
13:05:30 <CosmicRay> how do I get smart indent in vim for haskell?
13:05:30 <sjanssen> knobo: bottom is forced whenever you pattern match against it
13:06:20 <knobo> Divergence occurs when a value needed by the pattern contains an error (_|_).
13:07:23 <sjanssen> right, and when you have "take1 _ [] = []" and you apply "take1 0 undefined", the pattern match forces that undefined
13:07:28 <knobo> Now it think I understand what Divergence is.
13:08:13 <knobo> so when ever you try to match anything to bot (_|_), you get an error?
13:08:57 <quicksilver> possibly
13:09:00 <Cale> knobo: yeah, or, theoretically, nontermination
13:09:09 <sjanssen> a diverging computation is a computation that results in: pattern match failure, non-termination, calls to error or undefined, or pattern matching against another diverging computation
13:09:09 <Cale> You get _|_
13:09:12 <quicksilver> that's the behaviour on a specific (_|_)
13:09:23 <quicksilver> but it might be an infinite computation
13:09:28 <quicksilver> like length ([1..])
13:09:44 <quicksilver> the compiler/runtime are able to catch certain obvious kinds of non-termination
13:09:54 <quicksilver> but many will slip past
13:10:01 <quicksilver> > length [1..]
13:10:08 <lambdabot> Terminated
13:10:14 <sjanssen> knobo: you can think of the bottomness "tainting" every expression that tries to pattern match against a bottom
13:10:21 <Cale> If length was written so as to produce a Nat, then that could be productive.
13:10:27 <knobo> ok, this can happen to non-strict functions.
13:10:42 <fasta> The GHC + CPP => nightmare. CPP with the same options without GHC produces the right output.
13:10:43 <chessguy> ?src length
13:10:44 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:10:50 <chessguy> @type length
13:10:58 <lambdabot> forall a. [a] -> Int
13:11:32 <sjanssen> knobo: the trickiness with take is that it is conditionally strict
13:11:49 <sjanssen> @src take
13:11:50 <lambdabot> take n _      | n <= 0 =  []
13:11:50 <lambdabot> take _ []              =  []
13:11:50 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:12:15 <quicksilver> it's strict on its first argument unless called on the empty list
13:12:19 <chessguy> ?src drop
13:12:19 <lambdabot> drop n xs     | n <= 0 =  xs
13:12:19 <lambdabot> drop _ []              =  []
13:12:19 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
13:12:27 <quicksilver> on its second argument it's only strict on the first 'n' elements
13:12:31 <sjanssen> knobo: the usual defn. is always strict in the first argument, but only strict in the second argument in certain cases
13:12:59 <sjanssen> quicksilver: drop is never strict in the elements, only the spine of the list
13:13:17 <sjanssen> same with take
13:13:24 <quicksilver> sjanssen: this is a good point, I was not speaking very precisely
13:13:46 <quicksilver> strict on the first 'n' places of the spine, you might say
13:13:53 <quicksilver> (bones?)
13:14:20 <monochrom> > map (const 'x') (take 1 (undefined: undefined))
13:14:21 <lambdabot>  Undefined
13:14:37 * monochrom re-thinks
13:15:05 <xerox> > map (const 'x') (tail (undefined:undefined))
13:15:06 <lambdabot>  Undefined
13:15:11 <xerox> dang.
13:15:19 <sjanssen> hmm, is GHC cheating?
13:15:29 <monochrom> My code works in ghci 6.6
13:15:43 <abz> ?doc Network.URI
13:15:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-URI.html
13:15:51 <monochrom> err I mean in ghci 6.6 I get "x" and it is the only correct answer!
13:15:55 <quicksilver> length . take 1 $ undefined:undefined
13:16:00 <quicksilver> > length . take 1 $ undefined:undefined
13:16:02 <lambdabot>  1
13:16:06 <xerox> lambdabot! Now with 40% more strictness!
13:16:13 <monochrom> haha
13:16:16 <quicksilver> > map (const 'x') . take 1 $ undefined:undefined
13:16:17 <lambdabot>  Undefined
13:16:29 <quicksilver> yes, that's right
13:16:31 <Cale> data Nat = Zero | Succ Nat; length [] = Zero; length (x:xs) = Succ (length xs); take Zero xs = []; take _ [] = []; take (Succ n) (x:xs) = x : take n xs
13:16:35 <sjanssen> yikes!
13:16:35 <quicksilver> > take 1 . map (const 'x') . take 1 $ undefined:undefined
13:16:37 <lambdabot>  Undefined
13:16:44 <sjanssen> this is a ghc -O bug!
13:16:46 <quicksilver> that, however, is not right
13:16:47 <Cale> Then take (length [1..]) [1..] should work properly
13:17:02 <sjanssen> I bet this has to do with fusion . . .
13:17:04 <monochrom> But it's ok, it's a side point.
13:17:19 <monochrom> > map (const 'x') (take 1 [undefined,undefined])
13:17:21 <lambdabot>  "x"
13:19:34 <knobo> so if you match bot against _ it does not diverge. but if you match it against [] ut diverges?
13:19:42 <monochrom> Right.
13:20:03 * knobo thinks he'll understand haskell some day :)
13:20:09 <xerox> > let length (x:xs) = () : (length xs); take [] xs = []; take _ [] = []; take (() : n) (x:xs) = x : take n xs in take (length [1..]) [1..]
13:20:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:20:18 <quicksilver> knobo: [] is a constructor, so to match it has to evaluate bot into WHNF
13:20:23 <monochrom> If you match against [] or (x:xs), then the computer really needs to find out: is it truely a []?
13:20:23 <quicksilver> knobo: to see if it's the right constructor
13:20:25 <xerox> just () instead of Succ and [] instead of Zero
13:20:38 <chessguy> > take (length [1..]) [1..]
13:20:42 <lambdabot> Terminated
13:21:12 <Cale> length = map (const ())
13:21:47 <araujo> knobo, be careful
13:22:02 <araujo> knobo, once you do it .... there is no way back
13:22:02 <sjanssen> of course this representation can have huge space issues
13:22:10 <quicksilver> Calse : take = zipWith K
13:22:15 <quicksilver> Cale: or is it K1 :)
13:22:39 <knobo> I have tried once before, then I saw some video of sussman explaining about streams
13:22:56 <knobo> Then I understood something about haskell I did not understand before
13:22:59 <Cale> zipWith (flip const) perhaps
13:23:08 <knobo> so now I'm back.
13:23:21 <monochrom> streaming video is a good call.  (pun intended)
13:23:34 <Cale> > let length = map (const ()); take = zipWith (flip const) in take (length [1..5]) [1..]
13:23:36 <lambdabot>  [1,2,3,4,5]
13:23:42 <Cale> > let length = map (const ()); take = zipWith (flip const) in take (length [1..]) [1..]
13:23:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:23:49 <quicksilver> nice :)
13:24:46 <araujo> knobo, once you have seen the light ... you don't get back , it's fate
13:25:04 <Cale> araujo: hehe
13:25:35 <knobo> Right now I'm working with lisp.
13:25:48 <knobo> or, now right now, but at work :)
13:26:10 <knobo> s/now right/not right/
13:26:59 <sjanssen> knobo: my condolences
13:27:00 <monochrom> This is gay!  I try "map (const 'x') (take 1 undefined: undefined)" again in ghci, now it gives "x*** Exception: Prelude.undefined"
13:27:01 <sjanssen> :)
13:27:14 <therp> knobo: Lisp? Fine, then you are better off than other people (and not that far from Haskell)
13:27:37 <araujo> Cale, :-)
13:27:44 <sjanssen> monochrom: that is correct behavior
13:27:55 <sjanssen> monochrom: you probably mean take 1 $ undefined : undefined
13:28:08 * yip is fighting a loosing battle with STM :\
13:28:08 <monochrom> Oh!  I had typos.
13:28:09 <knobo> therp: I think it is far from haskell, scheme is closer
13:28:14 <pejo> "It is not sound" or "It is unsound"?
13:28:26 <quicksilver> pejo: unsound, normally
13:28:27 <therp> knobo: scheme is one of thinks that can be called "Lisp"
13:28:30 <quicksilver> pejo: not sound is fine though
13:28:37 <knobo> therp: ok :)
13:28:44 <glguy> She's the lady they refer to when they cut the ace of spades
13:28:48 <therp> s/thinks/things/ ... terrible mistakes today
13:31:14 <knobo> Does haskell pay? (i.e do you work with haskell)
13:31:20 <glguy> She's the lady that they think of when the night pulls down its shades.
13:31:59 <glguy> People who program because they want cash money can stick with Java please, (but yes, it does pay)
13:32:43 <SamB> some people think Haskell works better than FizzBuzz...
13:33:12 <sjanssen> knobo: yes (at least for some people)
13:33:21 <glguy> ?protontorpedo
13:33:22 <lambdabot> please expalin pure and lazy a little (im igonorant i know)?
13:35:23 <pejo> quicksilver, thanks.
13:35:24 <Cale> @keal
13:35:24 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
13:35:28 <Cale> @keal
13:35:28 <lambdabot> better be atleast 16x16 color with extended ascii set
13:35:39 <Cale> @keal
13:35:39 <lambdabot> 99% of my book has been erased by faulty hdd's
13:35:41 <pejo> knobo, large chunks of the channel are in academia, and they get paid in some sense.
13:35:45 <Cale> ah, there we go :)
13:36:05 <sjanssen> it isn't a keal quote unless it mentions the NSA
13:36:06 <sjanssen> @keal
13:36:06 <lambdabot> all i know is i have experienced my own death unhappening...
13:36:15 <sjanssen> @keal
13:36:16 <lambdabot> just seeing how offtopic i could get everyone
13:36:18 <sjanssen> @keal
13:36:18 <lambdabot> how do i search for someone saying 'Keal' in mirc
13:36:31 * sjanssen goes to add regular expression features to @keal
13:37:41 <sjanssen> @help quote
13:37:41 <lambdabot> quote <nick>
13:37:41 <lambdabot> remember <nick> <quote>
13:37:41 <lambdabot> Quote somebody, a random person, or save a memorable quote
13:38:05 <narain> hey, that's ungrammatical
13:38:44 <narain> it parses as  map quote [somebody, random-person, save-memorable-quote]
13:39:31 <glguy> oh noes! no one will be able to figure it out!
13:39:34 <monochrom> They can be merged into "save a memorable quote from somebody"
13:39:51 * monochrom a great grammatist
13:40:00 <monochrom> err grammartist!
13:40:05 <yip> what do you guys think of the idea of custom getter/setter functions for TVars?
13:40:09 <monochrom> err nevermind
13:40:21 <sjanssen> yip: hmm?
13:40:31 <sjanssen> you want to set fields inside a TVar?
13:40:32 <monochrom> custom accessors are great!
13:40:41 <yip> sjanssen: no
13:40:53 <xerox> @arr
13:40:53 <lambdabot> Drink up, me 'earties
13:41:00 <yip> actually getter might not be all that useful. but a custom set IO action could be really cool
13:41:12 <Cale> yip: It's a rather nice way to only allow one type of access in part of the code.
13:41:35 <Cale> This is also common with Chans
13:41:59 <knobo> well, thank you for the help. must sleep(8h)
13:42:32 <yip> i'm thinking that when a transaction commits, instead of having the TVar being updated, a custom IO action could be run that is supposed to update the value, or do other interesting side effects
13:43:41 <therp> what's so hard with multi-line regular expressions in sed? I don't get it.
13:43:53 <therp> any recommendations what to use instead of sed?
13:44:09 <chessguy> so my interviewer the other day asked me this question: "Could there be something in haskell similar to Design Patterns in imperative languages?"
13:44:27 <chessguy> i'm curious how ya'all would answer it
13:44:53 <sjanssen> I'd probably roll my eyes
13:44:57 <shapr> I say yes, and there already is.
13:45:17 <chessguy> shapr, what?
13:45:18 <therp> of course, but I would take different shapes. For instance continuation passing style is certainly a design pattern
13:45:34 <therp> using monads is another one
13:45:35 <Igloo> Bah, I need to be able to say "type Id =", I think
13:46:24 <glguy> Are there design patterns in *? yeah
13:47:12 * Igloo sighs and uses a newtype
13:47:20 <chessguy> see, i would consider those just idiomatic ways of doing things in haskell, i wouldn't really consider them 'design patterns' as such. i guess it depends on how you define a design pattern
13:47:55 <quicksilver> chessguy: the answer is "Yes, Design Patterns"
13:48:05 <alexj> i'd say there are fewer design patterns in haskell than in most other languages because the type system and first class functions allow you to instantiate patterns as libraries.
13:48:14 <quicksilver> this whole functional-languages-dont-need-design-patterns is just blogosnobbery
13:48:27 <glguy> they just obviate some of the design patterns used in OO languages
13:48:34 <quicksilver> right
13:48:48 <quicksilver> and arguably they don't always obviate them, just make them much easier
13:48:48 <Philippa_> I wouldn't go quite that far
13:48:50 <SamB> quicksilver: not just blogsnobbery
13:48:59 <quicksilver> and abstractable into libraries
13:48:59 <SamB> it is more of an exaggeration
13:49:00 <alexj> SYB is a good example of eliminating classes of patterns that remain in haskell.
13:49:08 <Philippa_> it's true that the claim as typically phrased doesn't stand up though
13:49:13 <chessguy> i basically said that things like design patterns in haskell are just abstracted out, which is much harder to do in imperative languages
13:49:22 <quicksilver> SamB: exaggeration based in snobbery, I think :) But yes
13:49:45 <quicksilver> chessguy: I think that's (often) true, but I'm not sure that abstracting something out makes it stop being a pattern
13:49:55 <quicksilver> it just becomes a simpler and easier-to-reuse pattern
13:49:57 <SamB> FP allows you to factor certain types of patterns out of your program
13:49:58 <chessguy> true
13:50:00 <Philippa_> it does stop it being a Design Pattern though
13:50:24 <chessguy> yeah, to me, design patterns only exist because you can't abstract out the core similarity
13:50:32 <SamB> but we still haven't managed to scrap our boilerplate
13:50:49 <SamB> and we have some patterns of our own, of course
13:50:52 <glguy> I don't think that Haskell necessarily abstracts out the "Structural Patterns" of the GOF book
13:50:54 <quicksilver> SamB: and I imagine we never will
13:50:55 <glguy> for example
13:50:58 <dylan> the phrase "design pattern" just sounds too markety. they should've used the term "design monkey" or something..
13:50:59 <SamB> we have the FoldPattern
13:51:01 <Philippa_> we'll never truly capture the observer pattern's non-OO generalisation because some instances're in the hardware...
13:51:19 <dylan> or drop the word "design" and replace it with "code".
13:51:21 <Philippa_> dylan: there was an existing piece of terminology they were lifting
13:51:40 <Philippa_> and they wanted to talk about patterns that most coders would think of as "design-level"
13:51:46 <quicksilver> SamB: I imagine that in any formalism there are boiler-plate constructs which are clearly abstractable in the meta-language but not the language
13:52:06 <quicksilver> SamB: indeed, I suspect that's Godel Incompleteness restated, although Im not sure
13:52:15 <dylan> perhaps it's because I sometimes forget what a refridgerator is called, but I like simple names for things.
13:52:17 <SamB> hrmm. may be!
13:52:36 <Philippa_> quicksilver: nope, you have the option of being unsound or undecidable instead. Here, have a lisp.
13:52:43 <SamB> heh
13:53:06 <dylan> "the thing what keeps food cold box" is easier to remember. ;)
13:53:07 <quicksilver> Philippa_: ah, good point
13:53:21 <quicksilver> Philippa_: I had unconciously excluded that idea :)
13:53:38 <Philippa_> so *that's* why you're in here ;-)
13:53:42 <Philippa_> shift to Epigram when you can, though
13:53:48 <SamB> even if you can push things to the meta level, likely you will eventually discover that you have patterns that must be dealt-with on the meta-meta level...
13:53:57 <glguy> another pattern that Haskell doesn't elimiate is the Facade
13:54:10 * Philippa_ hands SamB a small infinity
13:54:29 <SamB> Philippa_: how do I plug this into my Haskell compiler?
13:55:02 <Philippa_> data Nat = Succ Nat | Zero; smallInfinity = Succ smallInfinity
13:55:10 <SamB> fortunately, you don't have to deal with every pattern
13:55:14 <QtPlatypus> SamB: Every day in every day my code gets meta and meta ?
13:55:14 <Philippa_> (and yes, that's the one I had in mind)
13:55:14 <SamB> I think some patterns are good
13:55:17 <dylan> about meta-meta level patterns... I've noticed this in software that heavily uses design monkeys.
13:55:34 <mauke> Nat = Fix Maybe?
13:55:44 <dylan> Sometimes the result of using all these patterns is actually something that is even harder to factor to a simple solution.
13:56:47 <dylan> I think file i/o in java is an example of this.
13:56:53 <quicksilver> glguy: hard to imagine how to eliminate Facades completely even in principle
13:57:43 <glguy> quicksilver: I'm not arguing that it should :)
13:57:47 <SamB> refactorings involving pushing something into a level with an extra meta- probably should wait until you have a significant number of instances of the pattern...
13:57:54 <yip> if i have an IORef, that will sometimes hold a value, is it better to have it hold a Maybe value, or have it hold undefined when there is no value. the application is structured so that when the value is read i know that it will always have a value
13:58:00 <glguy> quicksilver: but yeah, not all design patterns are flaws
13:58:21 <glguy> I just think that to say that Haskell doesn't have them just suggests that you don't know what they are
13:58:42 <SamB> glguy: well, it doesn't have *those* patterns
13:58:50 <glguy> SamB: which *those*?
13:58:55 <SamB> except if maybe the fold pattern is a visitor pattern?
13:59:10 <sjanssen> yip: undefined
13:59:16 <SamB> glguy: the ones the OO people are alyways going on about
13:59:21 <dylan> haskell doesn't have design patterns, it has type classes. ;)
13:59:27 <glguy> SamB: it doesn't have some of them, sure
13:59:34 <sjanssen> yip: if you're really sure that the IORef will be filled
13:59:35 <SamB> dylan: we don't have a Foldable typeclass
13:59:44 <SamB> just try and make one ;-)
13:59:46 <glguy> SamB: yeah we do
13:59:55 <SamB> glguy: where?
13:59:58 <dylan> Foldable is a type class.
14:00:01 <dolio> Data.Foldable
14:00:03 <glguy> Data.Foldable, lol
14:00:03 <SamB> @hoogle Foldable
14:00:05 <lambdabot> No matches found
14:00:07 <dylan> I used it just the other day.
14:00:16 <yip> sjanssen: ok thanks. but later i empty it and later on fill it again
14:00:18 <glguy> :t Data.Foldable.any
14:00:20 * SamB thinks there must be a catch
14:00:21 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => (a -> Bool) -> t a -> Bool
14:00:26 <SamB> @doc Data.Foldable
14:00:26 <lambdabot> Data.Foldable not available
14:00:31 <glguy> :t Data.Foldable.for_
14:00:34 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Applicative f, Data.Foldable.Foldable t) => t a -> (a -> f b) -> f ()
14:00:53 <glguy> :t Data.Foldable.foldlM
14:00:55 <lambdabot> forall a b (m :: * -> *) (t :: * -> *). (Monad m, Data.Foldable.Foldable t) => (a -> b -> m a) -> a -> t b -> m a
14:01:08 <dylan> I found Foldable when looking for an fmapM :)
14:01:52 <SamB> hmm.
14:01:53 <dylan> can we quote "dylan: we don't have a Foldable typeclass" ? :)
14:01:58 <SamB> It looks kind of limited.
14:02:08 <quicksilver> Foldable + Traversable: I recommend reading the paper cited in the haddock for those
14:02:30 <SamB> I mean, can I fold over the AST Monad with that?
14:03:06 <SamB> hmm. maybe that is a bad example.
14:03:18 <dylan> I think Foldable works on Data.Tree or whatever.
14:03:34 <SamB> well, I mean, could I fold over an AST type in a meaningful way?
14:03:44 <quicksilver> Data.Tree is an example of something Foldable works over
14:04:10 <SamB> @instances-importing Data.Foldable Foldable
14:04:11 <sjanssen> SamB: Data.Foldable isn't expressive enough for those sorts of traversals
14:04:11 <lambdabot> Maybe, []
14:04:18 <sjanssen> gfoldl is better
14:04:18 <SamB> sjanssen: yes. that was my point.
14:04:56 * SamB got sidetracked due to the existance of a class called Foldable
14:05:09 <sjanssen> SamB: it's a good compromise for plenty of simpler data types
14:05:10 <SamB> gfoldl doesn't work on Data.Map, though...
14:05:11 <quicksilver> Data.Traversal is more expressive
14:05:26 <sjanssen> arrays, Data.Sequence, lists, etc.
14:06:41 <SamB> quicksilver: where is that?
14:06:50 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/
14:07:13 <SamB> I see Data.Traversable, but that has a Traversable typeclass with Foldable as a superclass.
14:07:30 <jyasskin> Foldable and Traversable are purely linear. You need something like gfoldl to really catch the Visitor pattern.
14:07:37 <jyasskin> (as sjanssen said)
14:07:42 <quicksilver> yes, it's more restricted that foldable and therefore more expressive, in a sense
14:08:10 <quicksilver> of course I don't actually know what you're trying to do :)
14:08:51 <sjanssen> you might be able to write a "deepest fold" combinator with some heavy class magic
14:09:22 <jyasskin> Haskell's analogue of Visitor is functions like `maybe`, `either`, and `foldr` (renamed to `list`...) that consume a type to a summary value. IIRC, those are called "algebras"?
14:09:34 <quicksilver> catamorphism
14:09:40 <jyasskin> quicksilver: That too.
14:09:41 <sjanssen> catamorphism++
14:10:06 <quicksilver> what kind of thing is SamB (or anyone else) trying to do with a visitor than Foldable isn't enough for?
14:10:09 * Philippa_ got dumped by a catamorphism once
14:10:15 <ibid> jyasskin: haskell's analogue to Visitor is pattern matching
14:10:35 <ibid> jyasskin: in that visitor is a hack to get around the fact that java &co don't have pattern matching :)
14:10:37 <Mitar> is there a foldr function which would fold a list until the end of the list or until one of the components of the value reaches 1 (summing up the pixels with alpha channel=
14:10:37 <Philippa_> ibid: don't forget visitor does the graph traversal bit too
14:10:40 <quicksilver> ibid: and maybe and either are pattern matching lifted to the higher order
14:11:00 <SamB> quicksilver: well, I wouldn't call it a visitor
14:11:08 <quicksilver> Mitar: that's probably not a fold, it's a custom recursion
14:11:19 <sjanssen> Mitar: perhaps you want to combine a scan and take?
14:11:23 <sjanssen> @hoogle scanl
14:11:24 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
14:11:24 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
14:11:28 <ibid> Philippa_: i suppose it does. i always used it as a straight case emulation :)
14:11:31 <SamB> but a fold over an AST would have a different argument for each kind of AST node
14:11:47 <quicksilver> SamB: oh right, I understand now
14:12:07 <Mitar> i do not know in advance where the value of that component would reach 1 ...
14:12:34 <Mitar> so there is no fold which would take for example a maybe type ...
14:12:36 <Philippa_> lazy evaluation'll get that for you
14:12:55 <Philippa_> once it reaches 1 you just stop using the relevant values
14:13:15 <Mitar> but i have to write my own recursive function?
14:13:28 <quicksilver> you could do it with find and scanl, probably
14:14:05 <dolio> Isn' the question like:
14:14:07 <sjanssen> @where hlist
14:14:07 <lambdabot> http://homepages.cwi.nl/~ralf/HList
14:14:08 <quicksilver> well except if you want the last where it was larger than 1 instead of the first where its greater than one
14:14:21 <Mitar> i do not want the element ...
14:14:23 <quicksilver> then you have to backtrack 1 step, which is annoying (but not a problem)
14:14:41 <Mitar> i want the sum of all elements until one of the components reaches 1
14:14:43 <glguy> ?src spaces
14:14:43 <dolio> > foldr (||) False ([False, False, True] ++ repeat False)
14:14:43 <lambdabot> Source not found. My pet ferret can type better than you!
14:14:45 <lambdabot>  True
14:14:55 <quicksilver> Mitar: that's what the scan functions do, yes
14:15:08 <quicksilver> Mitar: they keep going building up the result
14:15:15 <glguy> skipMany space -- is -- spaces -- no?
14:15:18 <quicksilver> Mitar: then you use find or something to pick out the first greater than one
14:17:03 <Mitar> foldr (\a b -> if component a == 1 then a else a + b) list
14:17:12 <Mitar> ehm, ok there is missing an initial value
14:18:01 <Mitar> but this is something i would like to do ...
14:18:12 <Mitar> sum the elements until one of the components reaches 1
14:18:22 <dolio> > foldr (\a b -> if a > 1 then a else a + b) 0 (repeat 0.1)
14:18:24 <lambdabot>  Exception: <<loop>>
14:18:45 <dolio> > foldl (\a b -> if a > 1 then a else a + b) 0 (repeat 0.1)
14:18:49 <lambdabot> Terminated
14:19:32 <Mitar> so in my case they are pixel with alpha channel and there is no need to sum it when it reaches the solid alpha value
14:20:25 <ClaudiusMaximus> > foldr (\b a -> if a > 1 then a else a + b) 0 (repeat 0.1)
14:20:27 <lambdabot>  Exception: <<loop>>
14:20:47 <quicksilver> what you are describing is not sensibly a foldr
14:20:48 <Mitar> so i have to write my own recursive foldr, which takes into account this?
14:20:58 <ClaudiusMaximus> quicksilver: d'oh, of course
14:21:02 <quicksilver> since foldr is not really designed to 'stop early'
14:21:38 <quicksilver> scanl (+) (repeat 0.1)
14:21:41 <quicksilver> > scanl (+) (repeat 0.1)
14:21:42 <lambdabot>   add an instance declaration for (Num [t])
14:21:50 <quicksilver> :t scanl
14:21:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
14:21:55 <quicksilver> > scanl (+) 0 (repeat 0.1)
14:21:57 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999...
14:22:12 <quicksilver> > take 1 . filter (>=1) . scanl (+) 0 (repeat 0.1)
14:22:13 <lambdabot>  Couldn't match expected type `a -> [a1]'
14:22:19 <quicksilver> > take 1 . filter (>=1) . scanl (+) 0 $ (repeat 0.1)
14:22:21 <lambdabot>  [1.0999999999999999]
14:22:21 <dolio> But foldr does stop early if you're folding with an appropriate function.
14:22:24 <xerox> eek, fp is crazy.
14:22:35 <quicksilver> dolio: true, but it's not a sane use of foldr :)
14:22:44 <quicksilver> dolio: it still evaluates the entire spine of the list
14:22:51 <Cale> xerox: hm? :)
14:22:58 <dolio> any isn't a sane use of foldr?
14:23:14 <ClaudiusMaximus> @src any
14:23:14 <lambdabot> any p =  or . map p
14:23:17 <xerox> Cale, he he... why is 3 the one with '0000000004' appended, and not 4? or... well, you get the point.
14:23:24 <quicksilver> ah, hmm I'm wrong
14:23:31 <quicksilver> dolio: sorry, good point
14:23:34 <Mitar> why is there no foldr_maybe :: (a -> Maybe b -> Maybe b) -> Maybe b -> [a] -> Maybe b
14:23:43 <quicksilver> Mitar: did you see my answer?
14:23:46 <quicksilver> > take 1 . filter (>=1) . scanl (+) 0 $ (repeat 0.1)
14:23:48 <lambdabot>  [1.0999999999999999]
14:23:49 <Cale> xerox: ah, floating point
14:24:09 <dmwit> :t foldM
14:24:11 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:24:23 <Cale> xerox: has to do with the fact that 0.1 can't be represented exactly
14:24:37 <xerox> Cale, yeah, I'm studying the details these days
14:25:00 <fasta> Cale: 0.1 can ;)
14:25:01 <xerox> This is my textbook http://www.as.ysu.edu/~faires/Numerical-Analysis/
14:25:02 <lambdabot> Title: Numerical Analysis -index.html
14:25:13 <dolio> But I suppose foldr will only properly exit early if you can quit based on a single value.
14:25:30 <dolio> Rather than on an intermediate result.
14:26:16 <quicksilver> :t foldr
14:26:18 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:26:42 <dmwit> Okay, so the Maybe monad essentially lets you "stop" at the first failure, right?
14:26:51 <dmwit> Is there an idiomatic way to "stop" at the first success?
14:26:54 <quicksilver> dolio: nah, 'b' is the intermediate value, so as long as your function can return without examining its first argument at all, in at least one case
14:27:01 <quicksilver> dmwit: `mplus`
14:27:04 <sjanssen> dmwit: msum
14:27:05 <TSC> dmwit: Use the list monad + head
14:27:11 <quicksilver> > Just 3 `mplus` Just 4
14:27:13 <lambdabot>  Just 3
14:27:23 <dmwit> > Just 3 `mplus` Nothing
14:27:24 <lambdabot>  Just 3
14:27:28 <dmwit> Sweet!  Thanks.
14:27:39 <dolio> quicksilver: You mean without examining the second argument?
14:27:41 <quicksilver> dmwit: msum is foldr mplus
14:27:47 <quicksilver> dolio: no, the first, as it happens
14:27:58 <quicksilver> dolio: look at the type of foldr :)
14:28:20 <quicksilver> dolio: oh bothering
14:28:22 <dolio> quicksilver: Right, but b is the result from the tail of the list.
14:28:22 <quicksilver> dolio: hmm
14:28:26 <TSC> > foldr (const 2) 0 [1..]
14:28:26 <lambdabot>   add an instance declaration for (Num (b -> b))
14:28:29 <quicksilver> dolio: maybe only foldl can stop early?
14:28:42 <sjanssen> quicksilver: only foldr can stop early
14:28:43 <dolio> So if you can get a result without examining that, you quit early.
14:29:11 <sjanssen> > foldr (||) False (repeat True)
14:29:13 <lambdabot>  True
14:29:17 <TSC> > foldr (const (const 2)) 0 [1..]
14:29:19 <lambdabot>  2
14:29:26 <sjanssen> > foldl (||) False (repeat True)
14:29:30 <lambdabot> Terminated
14:30:37 <quicksilver> @src foldl
14:30:37 <lambdabot> foldl f z xs = lgo z xs
14:30:38 <lambdabot>     where lgo z []     =  z
14:30:38 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
14:30:54 <Mitar> > foldr (\a b -> if a > 1 then a else a + b) 0 (repeat 0.1)
14:30:55 <quicksilver> clearly :)
14:30:56 <lambdabot>  Exception: <<loop>>
14:31:02 <cjeris> @src foldr
14:31:03 <lambdabot> foldr k z xs = go xs
14:31:03 <lambdabot>     where go []     = z
14:31:03 <lambdabot>           go (y:ys) = y `k` go ys
14:31:40 <sjanssen> these "go" versions are unnecessarily convoluted
14:31:48 <dolio> There you are: if k quits after its first argument, you never recurse.
14:32:25 <Cale> foldl f z [] = z; foldl f z (x:xs) = foldl f (f z x) xs
14:32:50 <Cale> foldr f z [] = z; foldr f z (x:xs) = f x (foldr f z xs)
14:32:54 <quicksilver> dolio: nod, I see it now :) I was being dense
14:32:57 <cjeris> it's funny that the one that starts from the infinite end is the one that can stop early on an infinite list
14:33:15 <Cale> It doesn't start from the infinite end
14:33:21 <quicksilver> cjeris: that's essentially what I was getting twisted up over :)
14:33:28 <Cale> Lazy reduction is outermost first.
14:33:29 <quicksilver> Mitar: did you see my take 1 . filter version?
14:33:34 <dolio> :)
14:33:49 <cjeris> Cale: but you understand the naive sense in which foldr starts from the right end?
14:34:00 <Cale> Under strict evaluation, sure.
14:34:22 <sjanssen> bleh, how am I going to submit a patch when the lambdabot's state is stored as gzip?
14:34:36 <quicksilver> cjeris: there is, however, a naive sense in which it starts from the left, too
14:34:39 <cjeris> no, by "naive" i mean "idiot, undergraduate, or me, looking at a piece of paper that says 4 + (3 + (2 + (1 + 0)))
14:34:52 <quicksilver> cjeris: that's if you view foldr as 'replace : with +'
14:36:02 <sjanssen> quicksilver: that is how I view foldr
14:36:06 <Cale> Suppose we do foldr (:) [], and end up writing 4 : (3 : (2 : (1 : []))) -- now which end is it starting at? :)
14:36:18 <quicksilver> exactly
14:37:08 <quicksilver> > last . takeWhile (<=1) . scanl (+) 0 $ (repeat 0.1)
14:37:09 <lambdabot>  0.9999999999999999
14:37:15 <quicksilver> Mitar: there's another one
14:37:35 <cjeris> Cale: the right one, obviously :D
14:37:42 <xerox> goodnight
14:37:47 <Cale> Only it's not :)
14:38:08 <dolio> No, it starts at the correct end. :)
14:38:27 * cjeris is still stuck in an eager mindset
14:38:31 <quicksilver> > foldr1 (flip const) [1..10]
14:38:32 <lambdabot>  10
14:38:42 <quicksilver> another cool use for flip const! define last!
14:38:55 <xerox> quicksilver: define tail in terms of foldr
14:39:21 <dmwit> > last []
14:39:22 <lambdabot>  Exception: Prelude.last: empty list
14:39:27 <Cale> !paste
14:39:28 <hpaste> Haskell paste bin: http://hpaste.org/
14:39:43 <hpaste>  Cale pasted "what the list looks like" at http://hpaste.org/948
14:40:08 <dolio> > foldr1 (flip const) []
14:40:09 <lambdabot>  Exception: Prelude.foldr1: empty list
14:40:09 <Cale> Start at the top :)
14:41:04 <cjeris> Cale: actually, that helps a little bit.  i'm used to thinking of the 'r' in foldr as meaning 'traverse right-to-left' but it could just as easily mean 'build a right-biased tree'.
14:41:16 <Cale> yes, and that's what it does stand for here
14:41:25 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
14:41:27 <lambdabot> Title: Fold Diagrams - CaleWiki
14:42:15 <dolio> Wow, that scanl diagram is something.
14:42:30 <Cale> Scroll down to see a streched out version of the same
14:42:47 <cjeris> dolio: it's actually a pattern for a lovely tweed greatcoat
14:43:07 <quicksilver> @src foldr1
14:43:07 <lambdabot> foldr1 _ [x]    = x
14:43:07 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
14:43:07 <lambdabot> foldr1 _ []     = undefined
14:43:34 <Mitar> quicksilver: i saw your solution, it seems nice
14:43:51 <Cale> By following the arcs, one can determine some things about scanl rather quickly from that.
14:44:24 <Cale> First of all, that the first element is easy to compute, and then, following it down, that successive elements involve one more f and one more element of the original list.
14:44:30 <quicksilver> Mitar: whether you can last . takeWhile (<=1) or head . filter (>=1) depends if you want the first greater than 1 or the last less than :)
14:46:10 <Mitar> what is better to use, scanl or scanr?
14:46:17 <Cale> Usually scanl.
14:46:19 <Mitar> i thought I know the difference
14:46:30 <Cale> It's interesting that it flips relative to fold.
14:46:32 <Mitar> but now you get me fuzzy
14:46:42 <sieni> Mitar: they do a bit different things
14:46:48 <Cale> foldr and scanl are the two popular ones.
14:46:54 <Mitar> http://en.wikipedia.org/wiki/Fold_(higher-order_function) << i am reading this
14:47:03 <Cale> I wrote that :)
14:47:08 <Mitar> great :-)
14:47:45 <Cale> Well, mostly anyway :)
14:47:57 <Mitar> so if I understand correctly, foldl is better because it is tail recurse
14:48:14 <Mitar> but what is then the problem with initial value and the strict version/
14:48:18 <Cale> Better in a strict language
14:48:23 <Cale> Not in a lazy one
14:48:25 <mauke> foldl is worse because it is tail recursive
14:48:27 <sjanssen> Mitar: foldl is also worse because it is tail recursive
14:48:37 <mauke> @quote stereo
14:48:37 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
14:48:40 <sjanssen> Mitar: it all depends on the function that you're folding
14:48:41 <Cale> foldr is better in Haskell
14:48:46 <Cale> (usually)
14:49:28 <glguy> foldl is worse because of tail recursion
14:49:29 <Mitar> so why would anybody use foldl?
14:49:31 <Cale> I'd say that when you want a fold, about 75% of the time, it'll be foldr, 20% of the time, it'll be foldl', which is the strictified left fold, and the rest, something else.
14:49:49 <dmwit> Mitar: If you function is left-associative. ;-)
14:50:01 <quicksilver> Cale: is scanr useful at all? it just seems weird to me
14:50:27 <Cale> I don't think I've ever actually used scanr, but it's sort of natural to have it around.
14:50:52 <dolio> Yeah, I was trying to figure out an example of where you'd want to use it, but nothing's coming to mind.
14:50:58 <quicksilver> the relationship between scanr and scanl isn't the same as that between foldl and foldr, though
14:51:14 <Cale> They're pretty closely related.
14:51:17 <quicksilver> foldr and foldl calculate the same value if `f` is associative, it's just the evaluation strategy which is different
14:51:33 <quicksilver> scanr is like reverse . scanl f b . reverse
14:51:38 <quicksilver> which just seems odd, to me ;)
14:51:47 <Cale> Well, look at my diagram.
14:51:49 <cjeris> not scanl (flip f) b ?
14:51:54 * glguy 's personal best (in terms of score) reddit comment continues to grow!  91 points 16 hours ago by glguy  
14:51:57 <glguy> :-D
14:52:00 <Cale> Compare the foldr diagram with the scanr one.
14:52:07 <Cale> glguy: which one?
14:52:09 <dibblego> glguy, 92, I just read it :)
14:52:10 <glguy> man, I wish those points had actual value ;)
14:52:11 <quicksilver> cjeris: no, it isn't
14:52:18 <glguy> http://programming.reddit.com/info/19kq3/comments/c19l3p
14:52:19 <lambdabot> Title: Why a career in computer programming sucks (reddit.com)
14:52:24 <glguy> it isn't particularly insightful
14:52:28 <Mitar> which diagram?
14:52:28 <glguy> but seems to score well :)
14:52:38 <Cale> Oh, I just modded that article down without looking at it :)
14:52:39 <dibblego> glguy, I think you under-estimate just how insightful it is
14:52:50 <kuribas> Tail recursion isn't useful in haskell?
14:53:03 <dolio> :) It's insightful in the right audience.
14:53:15 <Cale> It had the words "career" and "sucks".
14:53:22 <dolio> The problem with tail recursion in haskell is that it builds a bunch of nested thunks.
14:53:36 <dolio> Rather than evaluating in constant space.
14:53:42 <glguy> Cale: I love articles like these, for all the people that it sways, probably at least one, that's one less loser in the field ;)
14:53:45 <dolio> Unless it's properly strictified.
14:53:53 <Cale> I must use some sort of Bayesian filtering on the link titles. :)
14:53:55 <rashakil_> poor tail recursion, getting blamed for laziness
14:54:26 <Mitar> > last . takeWhile (<=1) . scanr (+) 0 $ (repeat 0.1)
14:54:28 <lambdabot>  Exception: stack overflow
14:54:31 <Mitar> :-)
14:55:08 <Mitar> > last . takeWhile (<=1) . scanl' (+) 0 $ (repeat 0.1)
14:55:08 <lambdabot>   Not in scope: `scanl''
14:55:09 <Cale> kuribas: It's useful if you add strictness annotations, or if the compiler is sufficiently smart (which it often still isn't at the time being, but this is alwasy improving)
14:55:29 <Cale> But let me show the problem with an example...
14:55:34 <Cale> foldl f z [] = z
14:55:43 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
14:55:49 <ddarius> Tail recursion is not the cause.
14:55:50 <Cale> foldl (+) 0 [1,2,3]
14:55:51 <glguy> dibblego: I modded your comment up :) I might be the only one, but hear hear!
14:56:01 <dibblego> tail recursion won't execute in constant stack space without seq?
14:56:04 <Cale> = foldl (+) (0 + 1) [2,3]
14:56:05 <dibblego> glguy, yeah I'm having a shocker :)
14:56:11 <Cale> = foldl (+) ((0 + 1) + 2) [3]
14:56:16 <quicksilver> dibblego: that depends on your compiler
14:56:18 <Cale> = foldl (+) (((0 + 1) + 2) + 3) []
14:56:22 <Cale> = ((0 + 1) + 2) + 3
14:56:27 <Cale> = (1 + 2) + 3
14:56:28 <quicksilver> dibblego: the compiler may spot the strictness, but it probably won't :)
14:56:30 <Cale> = 3 + 3
14:56:32 <Cale> = 6
14:56:37 <Cale> That's how the evaluation runs.
14:56:53 <Cale> Note that it builds a large expression the size of the original list.
14:56:58 <Cale> and then evaluates it.
14:57:10 <quicksilver> tail recursion is still perfectly sensible in haskell if it's not thunk-building
14:57:19 <Cale> It builds that expression in a tight loop, but that doesn't change the allocation ehaviour.
14:57:21 <Cale> b*
14:57:44 <quicksilver> if the tail is *just* the recursive call and nothing else, then there is no thunk (I hope)
14:57:48 <Cale> So to fix this, we use foldl', which forces its 'z' parameter before recursing.
14:57:59 <quicksilver> but you better make sure you aren't building thunks in the arguments too :)
14:58:06 <dibblego> ?src foldl'
14:58:06 <Cale> quicksilver: but you're *changing* the parameters, which means thunks
14:58:06 <lambdabot> foldl' f a []     = a
14:58:07 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:58:18 <quicksilver> Cale: *nod*
14:58:20 <Cale> Unless you've written an infinite loop.
14:58:27 <bringert> is richard cameron here?
14:58:39 <bringert> (I can't remember your irc nick)
14:58:40 <ddarius> Cale: Or your function is already strict in it's arguments.
14:58:54 <Cale> ddarius: yeah
15:00:43 <cjeris> > let l = [1,2,3,4]; in (scanl (-) 0 l, scanr (-) 0 (reverse l))
15:00:45 <lambdabot>  ([0,-1,-3,-6,-10],[2,2,1,1,0])
15:00:59 <cjeris> > let l = [1,2,3,4]; in (scanl (-) 0 l, scanr (flip (-)) 0 (reverse l))
15:01:00 <lambdabot>  ([0,-1,-3,-6,-10],[-10,-6,-3,-1,0])
15:01:05 <SamB> hmm. $ probably *should* associate the other way...
15:01:17 <cjeris> quicksilver: i think the flip is necessary
15:01:38 <quicksilver> cjeris: yes, it is
15:01:38 * SamB was thinking of what would happen if you tried to go f $! arg1 $! arg2
15:01:42 <quicksilver> cjeris: my function was commutative :)
15:01:54 <quicksilver> cjeris: reverse . scanl (flip f) b . reverse :)
15:02:07 <dmwit> ?src seq
15:02:07 <lambdabot> Source not found. Do you think like you type?
15:02:09 <cjeris> oh, sorry, i misspoke.  what you said there was what i meant; i just neglected to repeat the 'reverse' on either side.
15:03:50 <dmwit> Well, I guess it isn't "seq _ a = a", anyway.
15:04:19 <Cale> SamB: indeed
15:04:41 <Cale> Eventually, everyone will come to agree with me on this, and by that time, it will be too late to change it :)
15:04:49 <SamB> Cale: no
15:05:00 <cjeris> Cale: that's what violence is for
15:05:03 <SamB> we will figure out how to write a tool to fix code
15:05:18 <Cale> It's quite easy actually.
15:05:29 <Cale> In any chain of $'s, replace all but the last with .
15:05:47 <SamB> ... complicated by the fact that there are other operators besides $ and . ...
15:05:57 <dmwit> Ooooo, my code doesn't have to change! =P
15:06:00 <Cale> right.
15:06:22 <SamB> or, we could maybe get away with this tool called "the typechecker"
15:06:24 <Cale> So you really need to parse the expressions.
15:06:41 <Cale> Nah, taking it to the typechecking level seems like overkill :)
15:06:44 <SamB> that will alert you to most code that no longer works properly
15:06:48 <Cale> oh
15:06:51 <Cale> in that sense, sure
15:07:17 <SamB> (but, watch out if you are using printf!)
15:07:32 <SamB> well, maybe
15:07:38 <Cale> hmm, are there f,g,x such that f $ g $ x makes sense under either associativity?
15:07:48 <Cale> Probably under the presence of typeclasses.
15:07:54 <dmwit> Aha, the online report says, "seq = ... -- Primitive".
15:07:55 <Cale> But it would be exceedingly rare.
15:07:56 <SamB> s/makes sense/typechecks/
15:08:07 <Cale> SamB: right :)
15:08:09 <dmwit> I was having trouble imagining how it could be implemented...
15:08:18 <Cale> dmwit: Yeah, you can implement it at given types using case
15:08:35 <Cale> For instance, for Maybe, it would look like:
15:08:50 <Cale> seq x = case x of Nothing -> x; _ -> x
15:09:01 <SamB> hmm.
15:09:05 <Cale> (and hope that the compiler isn't too smart for its own good)
15:09:15 <Cale> It used to be implemented with a typeclass in this way.
15:09:16 <SamB> I think the compiler is not permitted to be so smart?
15:09:25 <Cale> Probably.
15:09:41 <Cale> However, you still can't implement it properly for function types like that.
15:09:58 <quicksilver> for function types isn't seq a nop?
15:10:02 <Cale> and it's less convenient in that it creates typeclass constraints
15:10:06 <dmwit> Err, wouldn't it be like seq x y = case x of Nothing -> y; _ -> x `seq` y?
15:10:07 <SamB> I don't understand why it works that way for function types...
15:10:11 <quicksilver> aren't non-fully-applied things automatically in WHNF?
15:10:22 <SamB> I would have expected it to work... the way quicksilver thinks it works ;-)
15:10:34 <Cale> It works the same way as for everything else for function types. seq _|_ x is required to be _|_
15:10:36 <SamB> and *did*, actually
15:11:14 <quicksilver> ah yes, it reduces until it can 'see a lambda'
15:11:19 <Cale> right
15:11:20 <quicksilver> speaking rather informally
15:11:50 <SamB> Cale: I just don't see why you should be able to tell _|_ from const _|_...
15:12:12 <Cale> SamB: it is of questionable usefulness.
15:12:21 <Cale> and breaks eta-conversion
15:12:26 <quicksilver> indeed, it is possible to argue that it's harmful :)
15:12:27 * quicksilver nods
15:12:38 <quicksilver> and breaks various equations that we would like to hold
15:12:44 <sorear> hello
15:12:47 <SamB> I want to see if there are any arguments for why it is this way, besides "that is what the report says"
15:12:48 <quicksilver> stuff like monad laws, and fusion equations, so on
15:13:03 <Cale> foldr seq () :)
15:13:05 * sorear slaps polymorphic seq
15:14:44 <Cale> I think mostly we sort of ignore seq when it comes to dealing with equations, even though it's rather disingenuous to do so.
15:15:02 <Cale> Compiler authors obviously can't ignore it.
15:15:44 <ddarius> @google Fast and Loose reasoning haskell
15:15:46 <lambdabot> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/fast+loose.pdf
15:16:11 * ddarius wonders if that is about strictness as he thinks it is.
15:16:33 <quicksilver> SamB: yes, there are semantic/denotational reasons
15:16:47 <quicksilver> SamB: I can't reconstruct them without revisiting the papers, though
15:16:49 <sorear> ping: http://darcs.haskell.org/
15:16:52 <Saizan> is darcs.haskell.org half-down?
15:16:55 <lambdabot> Title: Index of /
15:17:10 <quicksilver> SamB: but there are reasons why WHNF is a sensible notion of 'force evaluation'
15:17:18 <sorear> Saizan: was that a response to me, or indepentent!?
15:17:33 <sorear> @where HList -- this is stuck. dho?
15:17:33 <lambdabot> http://homepages.cwi.nl/~ralf/HList
15:17:34 <Saizan> sorear: indipendent
15:17:46 <SamB> it seems counter-intuitive that, given a function of type Void -> a, I can tell whether it is _|_ or not.
15:17:58 <SamB> I mean, I can never pass a Void to it...
15:18:01 <dmwit> > f x = case x of Nothing -> id; (Just y) -> f y
15:18:02 <lambdabot>  Parse error
15:18:07 <SamB> (There are no Voids)
15:18:13 <dmwit> > let f x = case x of Nothing -> id; (Just y) -> f y in f
15:18:14 <lambdabot>      Occurs check: cannot construct the infinite type: t = Maybe t
15:18:14 <lambdabot>       Expe...
15:19:48 <quicksilver> SamB: I quite agree
15:20:03 <quicksilver> SamB: personally I'd rather we didn't have seq :)
15:20:21 <sorear> I'd rather we hadj
15:20:24 <SamB> granted, this particular example is not valid Haskell anything-in-particular
15:20:26 <quicksilver> SamB: I'd rather strictness annotations were merely compiler directives, 'outside of' the language
15:20:35 <SamB> quicksilver: erm.
15:20:36 <alexj> sorear: einar created a cleaned up version of hlist available as: darcs get http://happs.ord/hlist
15:20:40 <SamB> I don't think that is quite workable.
15:20:44 <alexj> sorear: einar created a cleaned up version of hlist available as: darcs get http://happs.org/hlist
15:21:00 <Cale> seq really does change the semantics of things though
15:21:08 <sorear> alexj: cleaned up?!  we forked it!?
15:21:27 <sorear> alexj: and anyway this is just my daily pull-everything complaining
15:21:28 <Cale> Not that there aren't other compiler directives that can.
15:21:30 <SamB> I merely desire to know why seq works on functions
15:21:47 <alexj> sorear: it is derived from oleg's darcs repo.
15:22:05 <alexj> but it actualy has cabal etc.
15:22:05 <quicksilver> SamB: I believe you will find your answer in papers which explain why WHNF is a good choice for lazy evaluation
15:22:13 <quicksilver> SamB: it's not the only choice
15:22:19 <rubenz> what is a good text editor for haskell on linux?
15:22:20 <alexj> not been very well played with yet.
15:22:21 <Cale> http://www.boasas.com/?c=773
15:22:24 <lambdabot> Title: [Boy on a Stick and Slither]
15:22:28 <Cale> rubenz: vim, emacs
15:22:45 <malcolmw> the beauty of darcs: forks are easy to make, and cheap to re-merge too
15:22:46 <alexj> I tried to make the hlist example work and am currently hitting runniing out of memory on trivial use.
15:22:51 <rubenz> Cale: How about one with a gui?
15:22:52 <Cale> rubenz: anything which can be configured to convert tabs to spaces (and which has reasonable syntax highlighting)
15:23:07 <quicksilver> rubenz: emacs has a gui
15:23:16 <alexj> if you are interested in playing with hlist for happs I will send you code that compiles and works until it runs out of memory.
15:23:41 <rubenz> quicksilver: Do you mean xemacs? (I thought emacs was just a command line program)
15:23:51 <sorear> alexj: does it fill with thunks, or something more serious?
15:23:51 <quicksilver> rubenz: you were wrong, then :)
15:23:56 <quicksilver> rubenz: emacs and xemacs both have guis
15:24:04 <quicksilver> rubenz: rather similar ones, in most respsects
15:24:05 <alexj> @hpaste
15:24:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:24:15 <sorear> rubenz: both have terminal interfaces.  LONG LIVE VT220!
15:24:21 <Cale> rubenz: gnu emacs has a gui too
15:24:27 <rubenz> quicksilver: What is the difference between xemacs and emacs then?
15:24:35 <alexj> sorear: I've only played with it very briefly so have not figured out what exactly is failing.
15:24:35 <sorear> rubenz: xemacs is a fork, not a port
15:24:49 <rubenz> sorear: and gnu emacs?
15:25:00 <rubenz> sorear: how is gnu emacs different from emacs?
15:25:13 <qwr> xemacs is forked from gnu emacs
15:25:23 <sorear> rubenz: gnu emacs == original C version, anything that doesn't need a lispm is derived from this
15:25:23 <Botje> one contains a secret nude pic of RMS.
15:25:29 <hpaste>  alexj pasted "hlist example" at http://hpaste.org/949
15:25:29 <Cale> gedit can be configured so as to be good for Haskell editing.
15:25:43 <sorear> rubenz: xemacs == JWZ and RMS couldn't get along
15:26:05 <chessguy> ?losers
15:26:06 <lambdabot> Maximum users seen in #haskell: 339, currently: 296 (87.3%), active: 57 (19.3%)
15:26:13 <pejo> sorear, I wonder why! :P
15:26:19 <rubenz> sorear: So was gnu emacs forked from emacs as well?
15:26:20 <alexj> Botje: no that is the Gnu Development Environment AKA GNUDE
15:26:30 <sorear> rubenz: GNU Emacs *IS* Emacs
15:26:46 <alexj> sorear:   http://hpaste.org/949
15:27:18 <alexj> it uses current happs and the hlist repo at http://happs.org/hlist
15:27:29 * qwr thinks there were the original teco Editor MACroS also...
15:27:37 <chessguy> wow, nearing 1000 pastes
15:28:14 <sorear> qwr: ah right teco.  I had it confused briefly with gosper's hashlife.  in any case it's ancient and childless
15:28:52 <alexj> sorear: are you playing with hlist?
15:28:57 <sorear> alexj: no
15:29:14 <Cale> If you're going to use gedit, I'd recommend getting some plugins. Smart spaces is good, because it lets you treat multiple spaces as if they were tabs.
15:29:16 <pejo> sorear, isn't the gnu emacs later than the one Stallman wrote in 75, and not the same code base?
15:31:04 <ddarius> alexj: What the heck is going on with the where clause in oo?
15:31:41 <sorear> alexj: Every day I run a script that darcs pulls all my copies of darcs repos.  hlist failed.
15:31:41 <sorear> pejo: Emacs, unqualified, means Stallman's implemented in C, extended in Lisp, later forked by Zawinski, Emacs.
15:31:43 <sorear> pejo: TECO emacs may have been the original, but it is no longer the default meaning
15:31:47 <sorear> pejo: or so I thought, anyway
15:34:08 * qwr . o O ( maybe vim should add some lisp dialect to its plugin-writing languages... )
15:34:40 <ddarius> yi
15:35:28 <alexj> ddarius: ?
15:35:36 <rubenz> So is gnu emacs the same as emacs or different?
15:35:49 <ddarius> oo x = encode x where a = HBinaryPut ?
15:35:56 <qwr> last time i looked at yi, it needed badly to get the term library support fixed for xterm...
15:36:16 <sorear> oh?
15:36:29 * ddarius has never tried yi, but has pulled the source recently.  However, he usually uses Windows.
15:36:29 <sorear> it doesn't work in xterm?
15:36:32 <alexj> sorear: darcs get http://happs.org/hlist just worked fine for me.  what are you doing?
15:36:38 <qwr> sorear: not very nice
15:37:02 <sorear> alexj: same thing, but a little longer ago. :)
15:37:34 <alexj> ddarius: I dunno.  This was originally  einar's experimental code before he dissappeared.  I got it ot compile and run until it runs out of memory. not sure what is happening.
15:37:44 <sorear> qwr: what did I do that wasn't nice?  (or are you not talking about my manners?)
15:38:11 <qwr> sorear: special keys like home/end
15:38:22 <sjanssen> sorear: are you still working on synhl for yi?
15:38:22 <qwr> maybe i'm stupid in trying to use them :)
15:38:48 <sorear> sjanssen: no
15:38:57 <sjanssen> sorear: that is unfortunate
15:39:15 <sjanssen> my wm is in Haskell, I want a Haskell editor too!
15:39:34 <alexj> ddarius: oo never gets used so I assume it is not contributing to the out of memory error.
15:39:53 <sorear> qwr: yes, it's a known problem... I can't find a way to dispatch on $TERM without dramatic slowdowns or breaking modularith.
15:40:03 <ddarius> alexj: I was just wondering about it.
15:41:18 <qwr> and for special effects, try DEL in screen
15:41:36 <qwr> (gives YIKES: tried to put nongraphic)
15:42:02 <sorear> old debug message
15:42:14 <qwr> hmm. same for xterm
15:42:25 <sjanssen> sorear: how far did you get with synhl?
15:42:28 <sorear> I got rid of it in the most recent rewrite of the display code
15:42:31 <rubenz> How do I enable haskell syntax coloring in emacs?
15:42:48 <sorear> sjanssen: it works, and the api would allow incremental.  very slow.
15:43:05 <sorear> rubenz: apt-get install haskell-mode, then M-x haskell-mode
15:43:29 <sorear> @where haskell-mode
15:43:29 <sjanssen> sorear: how did it work?  Did it use an existing Haskell lexer?
15:43:29 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
15:44:15 <sorear> sjanssen: yes.  I used one of the old alex lexers.  it saved the start state so (in principle again) it can stop anywhere
15:46:12 <sjanssen> sorear: did you actually cache the lexer state, or did you lex the file again after every insert?
15:46:35 <dons> you have to save the state yourself, right.
15:46:40 <sorear> neither, I lexed the file at every repaint
15:46:54 <sjanssen> I see
15:47:14 <sorear> If it was just inserts scrolling would be fast :)
15:47:31 <sjanssen> yeah, that'd really suck
15:47:36 <rubenz> Are there any good editors for haskell on linux besides emacs (or xemacs)? Emacs is ridiculously difficult to learn how to use.
15:48:05 <sorear> I hope you're speaking from experience...
15:48:12 <sorear> vim has good hl support
15:48:17 <pejo> rubenz, somehow I don't think you'll like vim.
15:48:30 <rubenz> pejo, why?
15:48:55 <sorear> rubenz: emacs is the easiest *nix editor to us
15:49:07 <sorear> er, I meant to C-k not C-j
15:49:20 * sorear curses keyboard
15:50:01 <sorear> no emacs, no vim --> no editors popupular enough for a proper haskell mode to have been written
15:50:19 <sorear> gedit, etc have highlighting, but I think that's it
15:50:29 <dylan> jed, perhaps?
15:50:46 <sjanssen> vim doesn't have much more than synhl
15:51:01 <dylan> there's vim plugins for indenting.
15:51:03 <dylan> and stuff.
15:51:32 <sjanssen> there are?
15:51:39 * sjanssen wonders how he didn't know this
15:52:00 <dylan> it's on the haskell wiki, I think.
15:52:00 <rubenz> Doesn't nedit do haskell highlighting?
15:52:23 <thedward> I checked out the shim codebase and it appears to have some minimal vim support now, but I haven't used it yet.
15:52:50 <thedward> one of the haskell vim plugins I played with even had a command to automatically add type information for the current function.
15:53:15 <sjanssen> @where shim
15:53:15 <lambdabot> http://shim.haskellco.de/trac/
16:06:52 <mgsloan> what's the point of 'fail' in monads?
16:07:10 <mgsloan> is it an error handling attempt?
16:07:10 <sorear> so do 1 <- return 2 can give a good error message
16:07:14 <sorear> yeah
16:07:17 <sjanssen> mgsloan: it is called on pattern match failure
16:07:29 <mgsloan> ah
16:07:49 <int-e> > do Just x <- [Just 1, Nothing, Just 2]; return x
16:07:51 <lambdabot>  [1,2]
16:07:51 <sjanssen> for some monads fail = error, but others have a more useful definition
16:08:15 <mgsloan> Well, I'm going to have a crack at an advanced error monad
16:08:21 <mgsloan> mm
16:10:19 <glguy> is it just me, or have there been relatively few "what is a monad" questions in channel lately
16:10:40 <glguy> maybe I've just been less helpful
16:11:25 <int-e> glguy: we have better tutorials.
16:13:18 <Zeroth404> > [1..6]
16:13:19 <lambdabot>  [1,2,3,4,5,6]
16:13:50 <dibblego> what's the equivalent of runhaskell on windows?
16:14:02 <glguy> runhaskell
16:14:02 <Saizan> runhaskell?
16:14:11 <dibblego> oh I have it
16:14:15 <int-e> runhaske ? ;-)
16:14:29 <dibblego> :)
16:14:49 <glguy> it was a BEAUTIFUL day today, and still is
16:14:57 <sjanssen> @yow
16:14:58 <lambdabot> I wonder if BOB GUCCIONE has these problems!
16:15:10 <glguy> I drove home w/ my top down with the music turned up smiling from ear to ear
16:15:17 <glguy> and after I finish this dinner, I'm heading back out!
16:15:24 <sjanssen> glguy: the weather is really nice here too
16:15:31 <glguy> ?localtime sjanssen
16:15:45 <glguy> whoa, you don't live on earth??
16:16:24 <sjanssen> glguy: CDT
16:16:28 <sjanssen> Nebraska
16:18:11 <chessguy> hmm, i didn't think you were a USer
16:25:04 <dons> hey David_Feuer !
16:25:16 <David_Feuer> Hello, dons.
16:25:43 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint!
16:25:44 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:26:44 <dons> ?users
16:26:45 <lambdabot> Maximum users seen in #haskell: 339, currently: 303 (89.4%), active: 55 (18.2%)
16:27:08 <chessguy> ?where stats
16:27:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
16:29:03 <glguy> She's the *lady* with the action if you think you've got the nerve!
16:29:20 <glguy> *piledriver* don't you worry, she treats every man the same.
16:30:24 <kuribas> Is there a way to stop ghci from displaying a long list of modules at the prompt?
16:31:52 <sjanssen> kuribas: :set prompt "some string"
16:32:34 <kuribas> sjanssen: Great, thanks!
16:33:38 <int-e> > let s n f g xs = take n xs ++ zipWith f (drop n xs) (g xs); m d e = s d (+) . s e (-) $ m (d+1) (e+2) in fix ((1:) . m 1 3)
16:33:40 <lambdabot>  [1,1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,1...
16:36:02 <dons> David_Feuer: so how's the haskell hacking coming along?
16:36:26 <narain> ?type foldl.foldl.foldl
16:36:26 <dons> ghc 6.6 got built in the end? ghci works?
16:36:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [[[b]]] -> a
16:39:24 <fatman2>  hello i am fatman and i weigh 400 pounds.  you can see videos of my supreme fatness at www.fatman.tk
16:39:38 --- mode: ChanServ set +o dons
16:39:38 <Botje> fatman2: you must be a functional programmer.
16:39:41 --- mode: dons set +b *!*n=none@*.hsd1.vt.comcast.net
16:39:41 --- kick: fatman2 was kicked by dons (dons)
16:39:46 --- mode: ChanServ set -o dons
16:40:04 <David_Feuer> dons, I haven't been hacking Haskell lately :-/
16:40:28 <dons> ah well, no time like now :-)
16:40:39 <sorear> dons: how broken is the hugs parser?
16:40:46 <dons> sorear: hmm. i've not looked at it
16:40:50 <sorear> just fixities?
16:40:53 <sorear> oh ok.
16:41:17 <sorear> well, it's yacc syntax, so it's the one I'm starting from
16:41:34 <dons> seems an odd thing to do ... ?
16:41:55 <sorear> well, hv needs to parse haskell to typecheck it :)
16:42:00 <malcolmw> dons: the header of the nobench results page looks odd: results from Mar 11, started at Mar 5, ended at Mar 5
16:42:37 <sorear> malcolmw: didn't you know haskell compilers travel through time?
16:43:33 <malcolmw> dons: also, ru_list is not in the amd64 results yet
16:43:51 <dons> malcolmw: ah oops. fixing ...
16:43:59 <dons> malcolmw: yes, that happens if I rerun a specific test
16:44:09 <dons> it doesn't update the last 'fresh' run time
16:44:26 <malcolmw> so, not a complete run, more a "last updated" time
16:44:32 <glguy> looks like Clean and OCaml are ahead of Haskell on the shootout again :(
16:44:33 <dons> yeah
16:44:52 <dons> glguy: right .they disqualified (correctly) ones test, and changed the spec  for another
16:45:08 <dons> and someone worked on the clean entries
16:45:08 <sorear> wow, I had no idea context lists could be empty
16:45:27 <malcolmw> I like ru_list, cos nhc98 is only 3x slower than ghc
16:45:28 <sorear> ashamed a non-UT lang could be faster, eh? :)
16:45:40 <Uncountable> is there a function that merges two lists [x1,x2,x3..] and [y1,y2...] to x1:y1:x2:y2:...?
16:45:53 <glguy> dons: what was disqualified?
16:45:55 <sorear> almost
16:46:17 <dons> glguy: the nsieve-bits entry used Bool arrays
16:46:20 <sorear> > concat . transpose $ [ [0..], [-1,-2..] ]
16:46:21 <lambdabot>  [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13,...
16:46:25 <dons> which are packed as bits in GHC Haskell
16:46:32 <dons> this leads to really good cache performance
16:46:41 <dons> such that haskell was twice as fast as its nearest rival
16:46:51 <dons> so the spec was changed to disallow bit packing libraries
16:47:00 <dons> and we have to use type BoolT = Word8
16:47:05 <sorear> > concat . zipWith (\(a,b) -> [a,b]) $ [ [0..], [-1,-2..] ]
16:47:05 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[a]'
16:47:10 <dons> then the result is more inline with expectactions
16:47:10 <glguy> dons: why don't they just tell everyone else to use bits
16:47:17 <sorear> > concat . zipWith (\(a,b) -> [a,b]) [0..] [-1,-2..]
16:47:18 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[a]'
16:47:22 <sorear> > concat $ zipWith (\(a,b) -> [a,b]) [0..] [-1,-2..]
16:47:23 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[a]'
16:47:31 <dons> glguy: they could. just as long as the tell everyone to do the same thing
16:47:32 <sorear> > concat $ zipWith (\a b -> [a,b]) [0..] [-1,-2..]
16:47:33 <lambdabot>  [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13,...
16:47:34 <int-e> glguy: because the shootout is about testing the performance of stupid code :/
16:47:58 <dons> its semi arbitrary, the haskell code was the odd man out, if you're fast, and the odd man out, you get disqualified :-)
16:48:14 <glguy> I don't see what the point of benchmarks are if you don't allow the programmer to use the built in features of the language
16:48:19 <Uncountable> okay. i find myself doing that kind of merge often, so i wondered if it already existed
16:48:23 <glguy> that's like telling the tcl people they can't use their customer regex engine
16:48:30 <glguy> custom*
16:48:34 <dons> glguy: ah well, they can, iirc.
16:48:39 <int-e> glguy: now there's a thought.
16:49:16 <dons> they are useful though. I don't think we appreciated just how bad [Char] was till we tried to compete in the shootout
16:49:29 <sorear> dons: why do we care about the shootout?  it's close to a law of nature that machine-fast languages are programmer-slow; i'd forgive someone for taking our current position as a reason to leave Haskell
16:49:48 <dons> its useful for spotting when ghc is doing something suboptimal
16:51:31 <emu> do vim users typically have a shell open with ghci, or is there some other trick they use?
16:51:41 <dons> the former.
16:52:18 <dibblego> "you're allowed to use Haskell, but if it has a feature that many others don't that contributes to a successful result, it must be omitted to be fair"
16:52:32 <dons> yep.
16:52:45 <dibblego> I remember a similar attitude to that when I was at school
16:52:49 <emu> like referential transparency?
16:52:59 <dons> laziness, in particular, has been a contentious point
16:53:21 <emu> urk, why don't they just benchmark different C implementations if they want the same language always
16:53:25 <dibblego> other languages will be emulating laziness in areas I imagine
16:53:44 <sorear> that's funny, hugs' grammar allows ZERO parameter type classes
16:53:50 <sorear> > () :: Num
16:53:50 <lambdabot>      Class `Num' used as a type
16:53:51 <lambdabot>     In the type `Num'
16:53:51 <lambdabot>     In an expression ty...
16:53:55 <sorear> > () :: (Num) => ()
16:53:56 <lambdabot>      `Num' is not applied to enough type arguments
16:53:56 <lambdabot>     Expected kind `*', but...
16:54:09 <sorear> no syntax error, wow
16:54:49 <sorear> ghci rejects class Foo where {}
16:54:57 <sorear> hugs -98 accepts it
16:55:12 <dons> sjanssen: so how do we want to proceed with xmonad?
16:55:26 <dons> tag it now? test it for a few days and tag it?
16:55:30 <dons> wait till we have tiling?
16:55:37 <dons> wait till we have tiling and a statusbar?
16:55:55 <dons> get rid of the C stuff
17:02:44 <MarcWeber> emu: Trick to do what ?
17:03:23 <emk> @seen ivanm
17:03:24 <lambdabot> I saw ivanm leaving #gentoo-haskell and #haskell 11h 12m 46s ago, and .
17:04:17 <emk> @tell ivanm Here's the monad/backtracking tutorial I promised you! Enjoy: http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes
17:04:17 <lambdabot> Consider it noted.
17:04:53 <dons> emk++
17:04:59 <emu> MarcWeber: load/test code?
17:05:01 * emk has finally given into peer pressure and written the 5,982nd monad tutorial.
17:05:20 <dons> yay!
17:05:27 <dons> emk, you want me to drop it by reddit?
17:05:29 <TomMD> emk: make sure it hits HWN.
17:05:44 <dons> it will.
17:05:45 <emk> dons: Sure!
17:05:58 <narain> :t join
17:06:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:06:04 <MarcWeber> emu: I've mapped ghci on Fx and cabal build/ run resulting executable. To test code I set up vim using the make command to run ghc. Works well ;)
17:06:20 <dons> http://programming.reddit.com/info/19spr/comments
17:06:21 <lambdabot> Title: Monads in 15 minutes: Backtracking and Maybe (reddit.com)
17:06:42 <emk> This one builds everything up from 'join'. At least for me, the mathematical approach is actually simpler than starting with >>=, which is a bit of weird duck.
17:07:00 <MarcWeber> emu: So I don't have to invoke ghci that often. Are you interested in vim haskell completion features?
17:07:03 * araujo back
17:07:05 <araujo> hello
17:07:42 * dons tosses another monad tutorial on the pile at http://haskell.org/haskellwiki/Blog_articles#Monads
17:07:43 <lambdabot> Title: Blog articles - HaskellWiki
17:08:57 * sorear gives up, declares it easier to start from the Report
17:09:17 * araujo thinking to write one on spanish
17:09:27 <dons> araujo: hmm!
17:09:46 <araujo> dons, hi!
17:10:08 <dons> araujo: so thinking about SoC this year?
17:10:09 <emu> MarcWeber: oh, i'm used to working in ghci.  i can see the :make feature working with Cabal though.
17:10:14 <araujo> ive really not found many (any?) on the web
17:10:27 <araujo> dons, yay! .. i will give it another try :-)
17:10:31 <emu> MarcWeber: completion would be cool. i don't think i have time to set it up atm, but what does it do?
17:10:37 <emu> (besides normal vim completion)
17:10:41 * araujo has some cool ideas
17:10:55 <dons> we're really interested in libraries this year, in particular
17:11:20 <araujo> dons, yes , though it'd be nice if you make some room for some applications too
17:11:25 <dons> so, one idea, take the intersection of the ruby and python libs, then diff that against hackage, and you've got a list of things we need doing
17:11:26 <araujo> i mean, it wouldn't hurt
17:11:28 <emu> i want to see how far i get with plain ol' vim 7
17:11:38 <emu> i don't even think i have haskell syntax coloring on this
17:11:43 <MarcWeber> emu: I'll puload a screenshot. Then you can see it.
17:11:45 <emu> k
17:11:46 <dons> araujo: right. its just hard to get people to vote for apps
17:11:53 <dons> since they by nature only appeal to a few people
17:11:57 <dons> whereas libs help everyone :-)
17:12:07 <dons> libs and tools
17:12:10 <emu> i can find libs which help very few people!
17:12:13 <araujo> dons, i have on my box some libs/bindigs proposal
17:12:17 <araujo> let's see how it goes
17:12:51 <dons> also, just looking over libs that people have asked for on the mailing list
17:12:52 <narain> emk: in your new tutorial, isn't the mult345 function supposed to be mult456?
17:13:01 <dons> so things like, ssl, good http, matrix/math
17:13:17 <emk> narain: Ooops.
17:13:18 <Botje> emu: you know about http://www.cs.uu.nl/people/arthurvl/haskell.vba , right?
17:13:18 <emk> One sec.
17:13:19 <dons> xhb
17:13:39 <araujo> dons, yeah, get it
17:13:44 <emu> no, whats that
17:13:56 <dons> I was dreaming about monads this morning
17:14:01 <araujo> haha
17:14:06 <Botje> emu: it asks ghci for the type of a given expression.
17:14:07 <dons> in my dream, I was hacking on the X11 bindings
17:14:11 <araujo> Beautiful dream :-)
17:14:18 <sorear> dons: do you think there's demand for a nice expressive command line engine - if it doensn't have support for --help generation?
17:14:23 <dons> and noticed that XSetErrorhandler was basically half of >>= for ErrorT
17:14:28 <emu> ah ok. but does it run ghci as a subprocess or something?
17:14:30 <dons> this was very beautiful to me, in my dream
17:14:31 <sorear> hehe.  still no haskell dreams for me
17:14:33 <Botje> emu: yup
17:14:48 <emu> it has to load your file and all its dependencies?
17:14:54 <dons> sorear: hmm. command line eh?
17:15:18 <Botje> emu: yes ..
17:15:18 <dons> sorear: if in doubt, see if anyone needed it in python or ruby ...
17:15:34 <Botje> ruby needs some serious developers.
17:15:46 <Botje> people who make good documentation, for a change
17:15:48 <narain> emk: also it seems like a big jump from a hardwired mult456 function to the arbitrary f in the (>>=)
17:16:05 <narain> emk: which is supposed to come from the remainder of the do-block
17:16:21 <dons> more SoC thoughts, we should come up with a list of the top 10 libs from other languages (based on the CPAns and what have you)
17:16:25 <dons> then suggest similar things
17:16:27 <emk> narain: Let me take a look.
17:16:43 <emk> Botje: Sadly, all the good Ruby docs are in books from the Pragmatic Press.
17:16:44 <dons> emk, btw, are you able to use haskell at work yet?
17:16:50 <dons> hmm, say, for generating test cases?
17:16:57 * dons ponders how emk would use haskell at work
17:17:09 <emu> ok, i've seen this.  but for right now, i'm keeping it simple.  stuck on someone else's computer so trying to be minimally intrusive
17:17:09 <emk> dons: No, but I get to use Scheme and Ruby and mess around with open source 3D engines, so I don't get to complain. :-)
17:17:14 * emk loves his job
17:17:17 <dons> yeah, that's nice.
17:17:51 <emu> i used haskell (QuickCheck) to find a bug in a library not even written in Haskell!
17:17:58 <dons> I think it would be nice if the "Three Laws of Monads" were numbered 1 to 3, and the first included something about doing no harm to values
17:18:14 <chessguy> there's a guy at aetion who's developing a 3-d modelling program for the atoms in molecules
17:18:14 <MarcWeber> emu: http://mawercer.de/marcweber/vim/ss/vim/
17:18:16 <lambdabot> Title: Index of /marcweber/vim/ss/vim
17:18:20 <emu> three laws of monadics?
17:18:21 <chessguy> (in haskell)
17:18:24 <dons> and neither through inaction, allowing harm to values
17:18:29 <MarcWeber> emu: Notice the file location and type signature on top.
17:18:38 <Botje> and the zeroeth would be "no harm to values, unless it's for the good of all values?"
17:18:41 <dons> unsafePerformIO would be the 0th law.
17:18:51 <emk> narain: I think the jump to >>= is probably OK, but you're right that the next step is a bit big.
17:19:00 <emu> MarcWeber: cool, where does it extract that data from? is this ctags trickery?
17:19:06 <emk> But it's hard for me to be sure, because I wrote it. :-)
17:19:23 <narain> emk: i like the idea of explaining monads via  join  but i found the article a bit hard to follow
17:19:27 <MarcWeber> emu: No: vimscript regex trickery. It does parse all those files and use some simple caching.
17:19:37 <emk> narain: Hmm. I'll see if I can do anything.
17:19:42 <emu> you run it on ghc sources?
17:19:49 <emu> or jhc
17:19:49 <narain> emk: yes, (>>=) as a combination of map and join is fine
17:19:51 <MarcWeber> emu: Sure ;)
17:19:56 <emu> i see
17:20:04 <emu> hoogle could do something like this too?
17:20:14 <chessguy> emk and emu in the same conversation...way too confusing
17:20:31 <narain> emk: but to see how the rest of it works you have to make the correlation between mult456 and  choose [4,5,6] >>= (\y -> x*y)
17:20:31 <emk> Botje: The zeroeth law is probably 'fmap id == fmap' or another of the functor laws. ;-)
17:20:48 <MarcWeber> emu: I'm not sure. I haven't set up hoogle. But it doesn't do it depending roughly on your import statements. This way you get a filtered list (compared to tags)
17:20:49 <narain> emk: and that's tricky
17:20:58 <emk> narain: I agree.
17:21:00 <emu> MarcWeber: do you use 2-space tabs btw?
17:21:10 * emk is trying to carefully fix mult345 -> mult456
17:21:11 <MarcWeber> emu: Yes I do.
17:21:16 <emu> how does that work out
17:21:56 <MarcWeber> emu: set sw=2 or tabstop the first to use spaces the latter to set tabwidth to two characters
17:21:59 <Daveman> Botje :p
17:22:01 <emu> does ghc get confused? for some reason i keep thinking there is a 4 space requirement
17:22:06 <Botje> hello, Daveman
17:22:17 <emu> MarcWeber: oh, i set expandtab and ts=4. should i do it different?
17:22:31 * glguy uses softtabstop=2
17:22:49 <MarcWeber> emu: I don't know. Have look at ghc sources how they do it .. I'm no expert on style
17:22:51 <glguy> if ts is tabstop, it should be set at 8 so that if you come across tabs they render properly
17:23:00 <emu> true
17:23:12 <emu> ok, so how do i make hitting the tab key give 4 spaces?
17:23:37 <MarcWeber> emu: You can get the whole stuff here: http://www.mawercer.de/marcweber/ . If you have trouble setting it up write again or drop me a mail.
17:23:38 <lambdabot> Title: Homepage of Marc Weber
17:23:52 <MarcWeber> emu: You told me how to do it. Doesn't it work that way?
17:23:55 <glguy> emu: with softtabstop
17:24:03 <mauke> emu: :set ts=4 et
17:24:08 <emu> i see
17:24:16 <glguy> :set ts=8 softtabstop=4 et
17:24:17 <Cale> dons: hmm, the new monad article is down
17:24:30 <glguy> so that tabs work, new tabs are spaces, and your tab key is 4 spaces
17:24:38 <dons> Cale: hmm, on emk's blog?
17:24:41 <dons> works for me.
17:24:54 <Cale> hmm, I suppose it was temporary
17:24:57 <Cale> I got a 503
17:25:06 <emk> Cale: You hit the refresh.
17:25:08 <chessguy> new monad article??? ooooh
17:25:34 <roconnor> co-inductive or coinductive?
17:25:41 <roconnor> to hyphen or not to hyphen?
17:25:53 <dons> i'd not use a hyphen
17:25:54 <emu> camel cache matching looks good
17:26:02 <chessguy> ,wait, you mean the one on errors?
17:26:10 <emk> randomhacks.net is 1/30th of a server, running four Rails processes under User Mode Linux. When I'm editing, all the processes may be busy for a few seconds...
17:26:24 <Cale> ah
17:26:57 <Cale> This Choice type synonym is a little funny :)
17:26:57 <MarcWeber> emu: It is. Just type CMS to get Control.Monad.State. I love it. But as you saw on the screen shot there is still a minor bug.
17:27:42 <Cale> Ah, I see, you're avoiding typeclasses altogether.
17:28:04 <emk> Cale: But once the pages are rendered, they're served from static cache. So it can take some pretty insane loads for such a dinky box.
17:28:30 <emk> Cale: Yeah, I tried about 4 different things, and that was the least ugly I could think of.
17:29:19 <Cale> > do {x <- [1,2,3]; y <- [4,5,6]; guard (x * y == 8); return (x,y) }
17:29:20 <lambdabot>  [(2,4)]
17:29:27 <narain> ?type guard
17:29:30 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:29:49 <narain> what does join do on IO?
17:29:59 <Botje> travel backwards in time
17:30:05 <mauke> (>>= id)
17:30:13 <Cale> Turns an IO action computing an IO action into a single IO action by running the result immediately after
17:30:18 <emk> narain: Not much. As far as I know, the actual magic is in fmap, conceptually speaking.
17:30:37 <emk> I couldn't tell you how it's actually implemented.
17:30:42 <Cale> join act = do { act' <- act; v <- act'; return v }
17:30:57 <desp> ugh
17:31:00 <mauke> @src join
17:31:00 <lambdabot> join x =  x >>= id
17:31:02 <emk> Cale: Yup, that's how to define it if you start with '>>='.
17:31:02 <Cale> join is just as important as fmap to the operation of a monad
17:31:05 <narain> Cale: ah, that helps
17:31:26 <narain> @do x >>= id
17:31:27 <lambdabot> x >>= id not available
17:31:36 <Botje> ?t id
17:31:37 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
17:31:42 <Botje> ?type id
17:31:44 <lambdabot> forall a. a -> a
17:31:45 <Cale> mauke: Of course, I know the shorter definition, but operationally in the IO monad, I think the do-notation is clearer for beginners.
17:31:53 <chessguy> @pl \x -> x >>= id
17:31:53 <lambdabot> join
17:31:57 <emk> You can also define it the other way around, which is what I do: m >>= f = join (fmap f m)
17:31:59 <jcreigh> :t id
17:32:01 <lambdabot> forall a. a -> a
17:32:05 <mauke> Cale: I just wanted to see which version @src uses
17:32:05 <Botje> i'm confused. how does id's type match up with the expected (a -> m b) ?
17:32:08 <Cale> I've also learned to put the return in :)
17:32:21 <emk> That's a bit more natural, mathematically speaking.
17:32:27 <Cale> join x = do { v <- x; v } has confused people before :)
17:32:54 <heatsink> Botje: x :: m (m b); id :: m b -> m b
17:32:58 <Cale> emk: yes, I agree with you in most cases
17:32:59 <arke> greetings. :)
17:33:03 <jcreigh> :t join
17:33:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:33:16 <Cale> emk: Occasionally >>= ends up more natural, but that's actually pretty rare.
17:33:44 <Botje> that .. makes sence, i guess
17:33:50 * Botje grabs the duct tape
17:33:51 <jcreigh> > join [[1,2,3], [4,5,6]]
17:33:53 <lambdabot>  [1,2,3,4,5,6]
17:33:57 <emk> Cale: Yup. And all the deep math papers use 'join', so it's not a bad thing to know about.
17:34:19 <Cale> join is multiplication from the monoid-object perspective.
17:34:21 <arke> I have just begun the quest to learn Monads. I have several reference sites that I will read through and do the examples, and I'll peek back here occasionally to ask a question, since my intelligence is limited and I might be a bit hard-headed trying to understand this. Just a warning. :)
17:34:41 <Cale> arke: Maybe start with my tutorial :)
17:34:49 <Cale> @wiki Monads as Containers
17:34:50 <lambdabot> http://www.haskell.org/haskellwiki/Monads as Containers
17:34:56 <Cale> @wiki Monads_as_Containers
17:34:57 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
17:34:57 * arke adds it to his list ... thanks :)
17:35:52 * arke starts out with wikibooks
17:35:53 <roconnor> Botje: join doesn't travel backwards in time, mfix does.
17:36:07 <jcreigh> @where lambdabot
17:36:07 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:36:14 <chessguy> @quote time
17:36:14 <lambdabot> _Stinger_ says: sometimes Haskell seems like an arms race between weird mathematical constructs and my brain
17:36:15 <Cale> It takes a bit of a different approach which seems good for beginners trying to get off the ground with the abstraction.
17:36:23 <chessguy> @quote merlyn
17:36:23 <lambdabot> No quotes match. I feel much better now.
17:36:45 <heatsink> When they figure out how to create wormholes, they will implement mfix in IO.
17:36:49 <Botje> roconnor: could you point me to a good read on that?
17:37:15 <sjanssen> dons: you mean tagging for a 0.1 release?
17:37:39 <dons> yeah
17:37:51 <jcreigh> if I do a darcs get --partial, does that still have enough information to do a "darcs send"?
17:37:54 <roconnor> Botje: um, you mean the like the article in the latest issue of the monad reader?
17:38:00 <sjanssen> jcreigh: yes
17:38:46 <roconnor> heatsink: mfix is implemente for IO
17:38:51 <roconnor> implemented
17:38:56 <jcreigh> sjanssen: thanks
17:38:59 <roconnor> @instances MonadFix
17:39:00 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:39:39 <sjanssen> dons: hmm.
17:39:59 <Botje> roconnor: thanks! I'll print it out and read it on the train tomorrow.
17:40:18 <chessguy> > let getIt [] _ = 0; getIt (x:xs) 1 = x; getIt (x:xs) n = getIt xs (n-1) in getIt [1..] 1
17:40:20 <lambdabot>  1
17:40:22 <roconnor> Botje: I'm a little biased because I wrote the article
17:40:25 <chessguy> > let getIt [] _ = 0; getIt (x:xs) 1 = x; getIt (x:xs) n = getIt xs (n-1) in getIt [1..] 0
17:40:29 <lambdabot> Terminated
17:40:42 <chessguy> > [1..] !! 1
17:40:43 <heatsink> > mfix (\x -> do putStr x; getLine)
17:40:43 <lambdabot>  2
17:40:44 <lambdabot>  <IO [Char]>
17:40:50 <Botje> roconnor: i'm willing to read _ANYTHING_ that discusses monads
17:41:03 <Botje> i'm currently at the "okay-so-they're-nice-tools" stage
17:41:25 <kc5tja> arke: Oh noes!
17:41:29 <roconnor> heatsink: it took me a few hours before I could figure out how to do anything useful with mfix
17:41:34 <arke> kc5tja: Oh noes!
17:41:37 <dons> kc5tja: did you get the code I sent?
17:41:40 <arke> kc5tja: you? here!? :D
17:41:44 <dons> i was really happy with the speed up :-)
17:41:55 <roconnor> It's like trying to figure out how to use fix
17:41:56 <heatsink> roconnor: If that program above didn't produce Exception:<<loop>> it would be VERY useful :)
17:42:00 <roconnor> by playing with it
17:42:00 <kc5tja> dons: I got it, but I'm at work presently.  Haven't had time to play with it.
17:42:22 <dons> kc5tja: well, down to 7s here, but if you care, we can actually do a fair bit better still
17:42:26 * kc5tja is ramming his head against the wall due to (a) Java, (b) IS mishaps, and (c) general moving-between-buildings mayhem.
17:42:27 <roconnor> heatsink: you created a temporal paradox!
17:43:04 <emk> Cale: Haskell connected the math part of my brain to the programming part. And since the math part was comparatively weaker, I'm very thankful.
17:43:11 <kc5tja> dons: Let me take a look at your code, and I'll toy with it.  7s on your box translates to about 30s on mine, assuming it's a linear conversion.
17:43:51 <chessguy> @type join
17:43:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:44:16 <Cale> emk: For me, it worked in the opposite direction.
17:44:30 <chessguy> ?hoogle choose
17:44:31 <lambdabot> Test.QuickCheck.choose :: Random a => (a, a) -> Gen a
17:44:38 <emk> Cale: That's cool, too! :-)
17:44:38 <roconnor> > join [[5],[6,7]]
17:44:40 <lambdabot>  [5,6,7]
17:44:42 <heatsink> Haskell... bringing programmers and mathematicians closer together.
17:44:50 <dons> kc5tja: what kind of performance do you require/
17:45:04 <emk> chessguy: Are you looking for the 'choose' from my article? You can just use 'id'. :-)
17:45:06 <Botje> heatsink: so do powerful magnets, but nobodie's lauding *THOSE*
17:45:17 <Philippa_> heatsink: see, there's this girl at uni I like who has the right kind of mathematical background... :-)
17:45:18 <Botje> *nobody
17:45:59 <chessguy> emk: it's a little confusing that you give that programming snippet first without really explaining that that's what you want to write, and the rest of the article will build up to how to be able to write that
17:46:06 <heatsink> :)
17:46:21 <Botje> mrr
17:46:24 <chessguy> i get it now though
17:46:24 <Botje> one more episode
17:46:29 <emk> heatsink: Mutable state is the original sin of computer science. Until I mastered Haskell, I never understood just how far we had fallen from the Eden of mathematics.
17:46:35 <Botje> 6 hours of sleep is more than enough for tomorrow's lecture
17:46:42 <dons> emk, agreed
17:46:50 <sorear> mh. quote?
17:46:52 <roconnor> variables shouldn't
17:47:03 <Botje> .. and constant's aren't.
17:47:07 <Botje> *constants
17:47:08 <glguy_> This space, wherein the essay ought to argue that Java compensates for its closed base classes by providing a more powerful substitute feature, left intentionally blank.
17:47:12 <Botje> i'll get me coat.
17:47:30 <heatsink> emk: but it's kind of unavoidable until we invent infinitely large computers.  Large haskell programs use mutable state too.
17:47:59 <Pseudonym> Large Haskell programs use mutable state sparingly.
17:48:01 <dons> where required, not by default
17:48:08 <Pseudonym> And hide it carefully.
17:48:21 <dons> the way large C programs use 'goto' sparingly
17:48:27 <Pseudonym> Right.
17:49:21 <heatsink> I agree there.
17:49:25 * Pseudonym looks at /usr/src/linux/fs/pipe.c and scrolls down to do_pipe
17:49:31 * Pseudonym winces a bit
17:49:46 <Pseudonym> Global mutable state is certainly the natural enemy of concurrency.
17:49:52 <kc5tja> dons: It doesn't require a whole lot
17:49:59 <Pseudonym> All managable programs get rid of one or the other.
17:50:03 <kc5tja> dons: It will usually be used like so:
17:50:22 <dons> kc5tja: btw, i think this is a perfect use case for haskell, parsing / translation/ analysis
17:50:22 <Pseudonym> To a first approximation.
17:50:22 <kc5tja> dons: cutgen -o myTestRunner.c *.c
17:50:41 <emk> Pseudonym: Oh, yeah. Concurrency is a quick way to discover the sinfulness of state.
17:51:02 <kc5tja> dons: Unfortunately we're going to switch from Haskell to C(++) after the implementation is complete in Haskell.
17:51:10 <heatsink> When I look at kc5tja, I see a GHC unique name momentarily.  Then I remember that GHC's unique names are only four characters.
17:51:13 <dons> kc5tja: well, .... if it works, you never know ... ;)
17:51:14 <kc5tja> (one of the requirements is that it be buildable via MSVC)
17:51:16 <Pseudonym> Actually, that's a good use case too.
17:51:25 <Pseudonym> Write in it Haskell and get it working, then rewrite it.
17:51:27 <kc5tja> dons: but the Haskell version is always going to be the "reference" implementation.
17:51:29 <desp> how would I go about implementing a parser that does not care about whitespace?
17:51:33 <kc5tja> We've agreed already on that.
17:51:42 <dons> kc5tja: yeah cool. i'm happy to help anyway i can
17:51:45 <QtPlatypus> emk: Mutable state comes as an unfortunite result that its easyer to build things that look like turning mecheans then things that look like lambda functions.
17:51:47 <emk> When you begin to worry about the speed of light restricting your notion of "simultaneous" (which happens in a multi-processor system), state gets unpleasant quickly.
17:51:52 <sorear> haskell is great ... it actually prohibits mutable state
17:52:01 <desp> specifically, I'd like to use Parsec, but not to feed it with getLines
17:52:01 <Pseudonym> As a former boss pointed out to me: If you're going to write a throwaway copy, write it in another programming language.  That way, you can ensure it will be thrown away.
17:52:13 <emk> sorear: And then gives it right back to you in a mathematically reasonable way.
17:52:19 <emk> It's very cool.
17:52:21 <kc5tja> dons: However, I have other projects where I'm VERY interested in using Haskell, including a ROX-Filer-inspired (or maybe OS/2 WPS) desktop environment.
17:52:29 <sorear> and FTR my soul burns every time I see "unsafePerformIO $ newIORef
17:52:40 <MarcWeber> desp: You want to feed it with?
17:52:50 * dons `ap` uni
17:52:54 <Pseudonym> sorear: So stop looking inside module implementations, and just look at the interfaces.
17:52:57 <kc5tja> However, the fact that Haskell doesn't grok dynamically loadable modules is a problem for me in that department.
17:53:03 <desp> MarcWeber: that's the problem I have
17:53:07 <Pseudonym> Your soul will be much less singed.
17:53:22 <Pseudonym> kc5tja: Oh ye of little faith.
17:53:48 <kc5tja> Pseudonym: OK, let me rephrase.  Dynamically loadable modules that doesn't depend on which version of GHC you compiled it with.  :)
17:53:50 <Pseudonym> Haskell does dynamically loadable and swappable modules well enough.
17:53:54 <Pseudonym> Ah. :-)
17:53:57 <Pseudonym> Yes, that's a problem.
17:53:58 <desp> MarcWeber: I'm thinking a lazy list (stream) of characters
17:54:12 <Philippa_> so's GCing dead code, IIRC
17:54:16 <Pseudonym> Haskell isn't popular enough for its binary API to stagnate yet.
17:54:22 <Philippa_> there're potential systems that's an issue for
17:54:23 <kc5tja> I really wish, in fact, that Haskell *DIDN'T* compile to .o files until the final binary is to be built.
17:54:41 <kc5tja> I think GHC would work better if it compiled to an AST or GSSA representation instead.
17:54:41 <sorear> just use yhc :)
17:54:57 <sorear> kc5tja: -fext-core
17:54:57 <Pseudonym> This is the same situation that C++ was in 10 or so years ago, BTW.
17:55:02 <MarcWeber> kc5tja: There is a script on haskell org putting everything into one huge module file.. Would that help?
17:55:03 <kc5tja> sorear: What is that?
17:55:18 <kc5tja> MarcWeber: That defeats the purpose of modules though.
17:55:30 <kc5tja> I wrote an e-mail on this topic to a friend of mine.
17:55:42 <sorear> kc5tja: it tells ghc to output a file in intermediate language (still pure+functional, but with most optimizations done)
17:55:56 <MarcWeber> kc5tja: Perhaps I'm wrong but doesn't this let the compiler do more optimizations?
17:56:02 <sorear> kc5tja: the re-parser for -fext-core is broken atm, but that's being actively worked on
17:56:31 <kc5tja> Right now, GHC does this: exe = link $ map compileGCC $ map compileGHC [moduleA, moduleB, ...]
17:56:33 <sorear> kc5tja: yhc is the York Haskell Compile
17:56:59 <kc5tja> I'd like to see this: exe = link $ compileGCC $ foldr compileGHC [moduleA moduleB ...]
17:57:00 <sorear> kc5tja: it uses a portable, stable bytecode format
17:57:32 <sorear> kc5tja: heard of jhc?
17:57:56 <kc5tja> Heard of yhc and jhc, but not used them, because all sources indicate GHC as being "the best."  So I went with that.  Plus darcs uses GHC.  :)
17:58:00 <sorear> kc5tja: jhc compiles each module to a private and portable .ho format, then links and re-optimizes
17:58:05 <heatsink> Is there a way to change the install path of a source build of GHC without rebuilding it?
17:58:22 <sorear> kc5tja: GHC is the best only by virtue of working.
17:58:38 <sorear> kc5tja: JHC is 95% less reliable and 150% faster output
17:58:48 <kc5tja> sorear: When you say links, do you mean it links the .ho files into a single .ho file, then emits C code on the back-end?
17:58:52 <sjanssen> @remember sorear GHC is the best only by virtue of working.
17:58:52 <lambdabot> Done.
17:59:03 <chessguy> > [(x,y) | x <- [1,2,3], y <- [4,5,6], x*y==8]
17:59:04 <lambdabot>  [(2,4)]
17:59:08 <kc5tja> I don't want to deal with experimental compilers when I'm still learning the basic language.
17:59:16 <chessguy> avoiding monads in 15 seconds :)
17:59:22 <jcreigh> kc5tja: a wise choice, IMO
17:59:44 <kc5tja> At some point, though, I would like to see how to port Haskell to the 65816 processor.
17:59:45 <jcreigh> chessguy: that's not avoiding monads, that's hiding monads behind sugar.
17:59:46 <dolio> How can you avoid monads by using monad comprehensions?
17:59:55 <chessguy> lol
17:59:57 <sorear> kc5tja: sorta.  it links the .ho files to an intermediate repr, which isn't written out.  then it emits either Glasgow Haskell or C
17:59:58 <chessguy> it was a joke, sheesh
18:00:04 <dolio> :)
18:00:17 <sorear> kc5tja: does the 65816 have an ansi-ish c compiler?j
18:00:37 <MarcWeber> emu: Did you succeed? There is also some kind of tag support
18:01:07 <kc5tja> sorear: Not really; the 6502 does though.  But that's a much, much more restricted subset of the 65816.
18:01:36 <kc5tja> Does the C-- output rely on C--'s innate support for garbage collection?
18:01:56 <kc5tja> Maybe it's possible to write a C-- compiler for it.
18:02:03 <sorear> kc5tja: C-- doesn't support garbage collection any more than C does
18:02:18 <Pastorn> i'm trying to do exercise one here, but i don't get what (gx,sx) is and what type it should be: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
18:02:18 <ClaudiusMaximus> > [Just (x,y) | x <- Just 4, y <- Just 5] -- wonder if this works...
18:02:20 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Maybe t1'
18:02:20 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
18:02:23 <sorear> kc5tja: however, there's less compilers are allowed to do behind your back, so it's easier to write a GC
18:02:30 <Pastorn> it seems to me, that given a function, f' i should return a new function and not data
18:02:59 <jcreigh> Pastorn: sepends on the type of the function
18:03:05 <jcreigh> :t map
18:03:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:03:10 <jcreigh> :t map (*2)
18:03:13 <lambdabot> forall a. (Num a) => [a] -> [a]
18:03:30 <Pastorn> jcreigh: i know that f' :: Float -> (Float,String)
18:03:35 <dolio> Is -fmonad-comprehensions still being worked on?
18:03:43 <Pastorn> so that covers the first part of binds type
18:03:49 <kc5tja> C-- has primitives that support GC.
18:04:08 <Pastorn> but that tuple (gx,gs) makes no sense
18:04:09 <kc5tja> It's possible to declare "managed" pointers, for example.  (I forget the precise syntax)
18:04:23 <jcreigh> Pastorn: ah, sorry, missed your link to sigfpe's blog entry
18:04:32 <kc5tja> Still, if Haskell implements GC without relying on C--'s capabilities, (which it obviously has to if it's compiling to C), then that makes my job that much simpler.
18:05:13 <ray> emk: nice job on the 5 billionth monad tutorial :)
18:05:26 <emk> ray: Thanks! :-)
18:05:47 <ClaudiusMaximus> :t lift
18:05:47 <sorear> kc5tja: don't equate haskell with ghc.  yh*i* is quite small, and easy enough to rewrite (nevermind port)
18:05:49 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
18:06:02 <ClaudiusMaximus> :t liftM
18:06:05 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:06:15 <kc5tja> sorear: I'm not equating anything with anything.
18:06:46 <kc5tja> I have problems staying focused while writing a Forth environment.  The easier it is to write a backend for Haskell, the better.
18:08:09 <jyasskin> @karma
18:08:09 <lambdabot> You have a karma of 0
18:08:20 <sorear> @karma
18:08:21 <lambdabot> You have a karma of 24
18:08:22 <kc5tja> sorear: how well does yhc work compared to ghc?
18:08:24 <sorear> @karma dons
18:08:24 <lambdabot> dons has a karma of 128
18:08:30 <sorear> kc5tja: fairly.
18:08:54 <sorear> kc5tja: it supports the base language, but good luck getting ghc-specific packages like mtl working..
18:09:04 <chessguy> emk++ yet another nice blog
18:09:14 <sjanssen> s/ghc-specific/hugs and ghc specific
18:09:16 <kc5tja> So it's complete with respect to the language report, though.
18:09:33 <emk> chessguy: Thanks!
18:09:34 <kc5tja> I don't know what mtl is, so it probably won't concern me that much.  :)
18:09:35 <sorear> well, as complete as any haskell compiler is :)
18:09:46 <emk> Oooh, karma queries.
18:09:48 <emk> @karma
18:09:49 <lambdabot> You have a karma of 4
18:09:54 <sorear> > let x = 2 in x == x == True  -- Valid Haskell 98!
18:09:55 <lambdabot>      precedence parsing error
18:09:56 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
18:10:35 <sjanssen> sorear: it is?
18:10:42 <kc5tja> What should that construct do though?
18:10:49 <sorear> return True
18:11:09 <sorear> > (let { x = 2 } in x == x) == True  -- the only valid parse
18:11:11 <lambdabot>  True
18:11:17 <jyasskin> > let x = 2 in True == x == x
18:11:18 <lambdabot>      precedence parsing error
18:11:18 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
18:11:28 <jyasskin> The parser doesn't do typechecking.
18:11:30 <sjanssen> ah, I see
18:11:48 <sorear> the let is supposed to extend as far as possible, but it doesn't because ghc fails to handle fixities during parsing
18:11:49 <sjanssen> jyasskin: it isn't type checking
18:12:08 <kc5tja> I think that would be parsed as let x = 2 in (x == x) == true
18:12:19 <kc5tja> > let x = 2 in (x == x) == true
18:12:21 <lambdabot>   Not in scope: `true'
18:12:26 <kc5tja> > let x = 2 in (x == x) == True
18:12:27 <lambdabot>  True
18:12:29 <sorear> kc5tja: right.
18:12:30 <MarcWeber> Which is the way to convert a String to a ByteString? read . show ?
18:12:32 <jyasskin> sjanssen: True, it's the 'infix' declaration.
18:12:36 <sorear> MarcWeber: pack
18:12:55 <kc5tja> MarcWeber: Data.ByteString.___.pack and ___.unpack
18:13:14 <jyasskin> Oh, sorear's explanation makes more sense. Hmm.
18:14:13 <kc5tja> > let x = 2 in $ x == x == True
18:14:13 <lambdabot>  Parse error
18:14:24 <kc5tja> > let x = 2 in (x == x == True)
18:14:25 <lambdabot>      precedence parsing error
18:14:26 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
18:14:46 <kc5tja> It almost looks like it's choking on a hidden type error.
18:14:59 <MarcWeber> sorear: So I still have to convert Char8 to Char (unicode). Then I can use packWith.
18:15:32 <sorear> MarcWeber: Do NOT import Data.ByteString if you are working with characters.
18:15:41 <sjanssen> MarcWeber: use Data.ByteString.Char8
18:15:42 <sorear> MarcWeber: use Data.ByteString.Char8 instead
18:15:46 <dcoutts__> @yarr!
18:15:47 <lambdabot> I'd like to drop me anchor in her lagoon
18:15:51 <sorear> hi!
18:16:00 * dcoutts__ has arrived in .au
18:16:27 <sjanssen> uh oh, dcoutts__ and dons are on the same continent . . .
18:16:37 * sjanssen prepares for the onslaught of code
18:16:39 <araujo> dcoutts__!!!!!!!
18:16:45 <araujo> dcoutts__, g'day mate
18:16:56 <dcoutts__> araujo: g'day
18:17:26 <dcoutts__> araujo: I've been practising my "no worries mate" in my best Australian accent :-)
18:17:32 <araujo> haha
18:18:10 <heatsink> dcoutts_: can you say the "no"?  That's a hard one.
18:18:30 <heatsink> "yea" on the other hand is easy.  I still say it.
18:19:53 <MarcWeber> sjanssen, sorear Thx. I still wonder why hoogle doesn't find it.. Thats' why I've missed pack and unpack of Data.ByteString.Char8
18:20:18 <sorear> MarcWeber: complain to ndm, he'd be interested in this
18:20:25 <Pseudonym> dcoutts__: There's one phrase you truly need to know to pass as Australian.
18:20:26 <sorear> (and he maintains hoogle)
18:20:38 <Pseudonym> And that's "Awwwyeah?"
18:20:45 <jcreigh> "Hi, I'm from Austrailia"?
18:21:00 <Pseudonym> It means "Well I didn't have it in mind, but now that you mention it, that's a good idea."
18:21:10 <Pseudonym> It's the most useful phrase in the Australian dialect, IMO.
18:21:15 <sorear> jcreigh: I think that would disqualify you imediately :)
18:21:19 <MarcWeber> >remember ndm Have you added Data.ByteString to hoogle yet?
18:21:22 <jcreigh> sorear: most likely. :)
18:21:35 <MarcWeber> ?help remember
18:21:35 <lambdabot> quote <nick>
18:21:35 <lambdabot> remember <nick> <quote>
18:21:35 <lambdabot> Quote somebody, a random person, or save a memorable quote
18:21:37 <jcreigh> MarcWeber: you probably want @tell
18:21:38 <sorear> jcreigh: esp. the "ailia" :)
18:21:42 <Pseudonym> But the secret in delivering it properly is in the inflection.
18:21:47 <MarcWeber> ?tell
18:21:48 <lambdabot> Plugin `tell' failed with: IRCRaised Prelude.head: empty list
18:22:00 <sorear> @tell MarcWeber hello!
18:22:01 <lambdabot> Consider it noted.
18:22:04 <sorear> MarcWeber: talk
18:22:20 <kc5tja> @tell kc5tja Talking to yourself, eh?
18:22:20 <jcreigh> sorear: yeah, presumably most Australians can spell the name of their own country.
18:22:20 <lambdabot> You can tell yourself!
18:22:39 <MarcWeber> @tell ndm Have you added Data.ByteString to hoogle yet?
18:22:39 <lambdabot> Consider it noted.
18:22:41 <Pseudonym> Apparently you _can't_ tell yourself, otherwise lambdabot would allow that.
18:22:54 <sorear> jcreigh: I doubt many (US) Americans can however :p
18:23:00 <chessguy> Pseudonym: you can tell yourself, you just can't @tell yourself
18:23:10 <MarcWeber> @tell MarcWeber ||: remember @tell :|| ^x100
18:23:10 <lambdabot> You can tell yourself!
18:23:25 <jcreigh> sorear: what, spell "United States of America" or spell "Australia"? :)
18:23:37 <sorear> jcreigh: fst
18:23:48 <Pastorn> could a tuple be considered a monad? seing how it is a container for data
18:24:04 <sorear> Pastorn: no
18:24:05 <MarcW> @tell MarcWeber ||: remember @tell :|| ^x100
18:24:05 <lambdabot> Consider it noted.
18:24:20 <dolio> A tuple is the writer monad, no?
18:24:30 <jcreigh> hmm...I'd be inclined to doubt that, expect that the lower half of the bell curve is very depressing here in the US.
18:24:37 <dolio> Or, that's what they were doing in the article.
18:24:38 <jyasskin> Pastorn: (Monoid w => (,) w)  is a writer monad, iirc.
18:24:55 <MarcWeber> lambdabot: doesn't recognize nick name changes .. :(
18:25:06 <sorear> MarcWeber: deliberately
18:25:08 <Pastorn> :instances Monoid
18:25:14 <Pastorn> @instances Monoid
18:25:15 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
18:25:35 <sorear> MarcWeber: due to ultra-dumb clients, lambdabot's @tell only reacts to privmsgs.  say something!
18:25:58 <sorear> MarcWeber: (and due to lambdabot design issues, something can't start with "@" "?" or "lambdabot: ")
18:26:25 <Pastorn> @hoogle Monoid w => (,) w
18:26:25 <lambdabot> hoogle: scripts/hoogle/src/Hoogle/MatchType.hs:74:8-45: Non-exhaustive patterns in function asBound
18:26:26 <lambdabot>  
18:26:30 <sjanssen> sorear: what's the story behind the ultra-dumb client remark?
18:26:34 <Pastorn> @hoogle Monoid w => (,) -> w
18:26:35 <lambdabot> Prelude.fst :: (a, b) -> a
18:26:35 <lambdabot> Prelude.snd :: (a, b) -> b
18:26:35 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
18:26:50 <dolio> ?instances MonadWriter
18:26:52 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
18:26:55 <sorear> sjanssen: * chessguy is now known as chessguy_away
18:27:07 <chessguy> ?
18:27:24 <sorear> sjanssen: * augustss has quit (Connection timed out) ... * augustss has (auto-re) joined #haskell
18:27:36 <jyasskin> Pastorn: It's not an instance of monad in the existing libraries, but it is an instance of Applicative and could be a Monad if someone got a round tuit.
18:27:43 <sorear> sjanssen: so should it tell someone for joining or nicking if it's automatic?
18:27:55 <Pastorn> jyasskin: ok, thank you
18:28:11 <sorear> Pastorn: actually, it is. Import Control.Monad.Instances
18:29:16 <chessguy_away> since you mention it :)
18:30:10 <sjanssen> sorear: your client is broken if it rejoins channels?
18:33:09 <kdunn__> Feel free to make fun of me.  I'm a total haskell nub.  For all intents and purposes, day one.  I've been prodding at this code (http://hpaste.org/950#a0) for too long, and I don't know how to get rid of the little nubby IO error I'm causing in the directoryToPairs function.  Help? :-P
18:33:32 <araujo> kdunn__, nobody will make fun of you here
18:33:33 <Cale> kdunn__: don't worry, everyone's new at some point :)
18:33:35 <sjanssen> @type nub
18:33:38 <lambdabot> forall a. (Eq a) => [a] -> [a]
18:33:45 * sjanssen is done poking fun now :)
18:33:46 <araujo> Or from anyone else asking _any_ question
18:34:00 <Cale> kdunn__: okay, what's the type of getDirectoryContents?
18:34:23 <Cale> Presumably, it's  String -> IO [String]
18:34:25 <Cale> right?
18:34:38 <chessguy_away> @type \haskell -> nub
18:34:41 <lambdabot> forall t a. (Eq a) => t -> [a] -> [a]
18:34:49 <kdunn__> Aye
18:35:03 <Cale> the problem is that filterDir wants a list of Strings, not an IO program which will compute such a list.
18:35:12 <Cale> So you have to run that IO action which you get.
18:35:20 <jcreigh> kdunn__: as a side note: you can get the type of any expression by firing up ghci (or hugs, if you prefer) and typing ":t <expr>"
18:35:37 <Cale> contents <- getDirectoryContents dir
18:35:44 <Cale> as a line of your do-block
18:35:55 <Cale> then contents will be a list of Strings, like you want
18:36:19 <kdunn__> Cale: Ah, I thought it was something like that.  So the <- operator executes an IO program?
18:36:23 <Cale> yes
18:36:32 <Cale> (it's not an operator, but part of syntax)
18:36:44 <Cale> But yeah, that's the idea.
18:36:55 <MarcWeber> kdunn__: Have a look at getDirectoryContentsWithoutSpecial
18:36:55 <lambdabot> MarcWeber: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:36:59 <Cale> Also, directoryToPairs has an incorrect type signature. Because it's doing IO, it has to be an IO action itself.
18:37:09 <gvdm_other> how would you convert "1" to 1? say reading it in from getChar or whatever
18:37:15 <Cale> gvdm_other: read
18:37:25 <Cale> > read "1" :: Integer
18:37:25 <jcreigh> and you can't just do "map fileToPair", since fileToPair :: String -> IO (String, String)
18:37:27 <lambdabot>  1
18:37:38 <gvdm_other> cool, thanks
18:37:38 <jcreigh> (well, you *can* do map fileToPair, but you end up with a list of IO actions)
18:37:46 <gvdm_other> ?type read
18:37:48 <lambdabot> forall a. (Read a) => String -> a
18:37:54 <kdunn__> Cale: Thanks a bunch!
18:38:05 <kdunn__> jcreigh: Ah, yeah, I see that now.  heh.
18:38:14 <Cale> kdunn__: mapM is what you want for that
18:38:25 <Cale> or you could apply sequence to the list you get from map
18:38:38 <Cale> sequence :: [IO a] -> IO [a]
18:38:38 <jcreigh> (which is what mapM does anyway)
18:38:41 <Cale> right
18:38:50 <Cale> mapM :: (a -> IO b) -> [a] -> IO [b]
18:39:17 <Cale> actually, their types are more general, and the IO's there could be any monad, but you don't have to worry about that here :)
18:39:35 <Cale> mapM is essentially a foreach loop
18:39:49 <Cale> There's also a forM which swaps the parameters around, if that's more comfortable.
18:40:04 <Cale> (provided you're using a new GHC/Hugs)
18:40:16 <kdunn__> Cale: Doesn't that type signature on mapM mean that it returns a list of IO action? I thought I wanted to get execute each IO action and get the list of results.
18:40:26 <kc5tja> hmmm...
18:40:34 <Cale> no, IO [b] means an IO action returning a list when it runs
18:40:44 * kc5tja ponders throwing GoboLinux on his laptop, and maintaining GHC and darcs packages for it.
18:41:00 <Cale> [IO b] is a list of IO actions
18:41:04 <jcreigh> [IO b] is a *list* of IO actions
18:41:12 <Cale> @quote stereo
18:41:13 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
18:41:22 <kdunn__> haha
18:41:25 <kdunn__> Thanks you all
18:41:30 <dibblego> http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes <-- that's excellent
18:41:31 <jcreigh> ...and after that, someone will @quote stereo :)
18:41:32 <lambdabot> Title: Monads in 15 minutes: Backtracking and Maybe, http://tinyurl.com/2xlyze
18:41:45 <Cale> No problem, let us know if you have any more trouble.
18:42:41 <MarcWeber> kdunn__: When using map instead of mapM you would get a list of IO actions ([IO a]) which you can transform to an IO action returning a list (IO [a]) by using sequence. in fact: mapM = sequence . map
18:43:06 <kc5tja> @src sequence
18:43:06 <lambdabot> sequence ms = foldr k (return []) ms
18:43:07 <lambdabot>     where
18:43:07 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:43:39 <Cale> sequence = foldr (liftM2 (:)) (return [])
18:43:48 <Cale> Or:
18:43:52 <Cale> sequence [] = return []
18:44:09 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
18:44:29 <Cale> I think both of those are clearer than src's version.
18:48:30 <ndm_ish> i
18:48:32 <ndm_ish> hi
18:49:01 <ndm_ish> has anyone managed to connect using http://www.cs.uu.nl/wiki/FP/ChatHaskell
18:49:03 <lambdabot> Title: FP / Chat Haskell
18:49:15 <ndm_ish> i failed miserably, null pointers gone wrong...
18:49:35 <ndm_ish> if thats not just me i'll edit the wiki to point at ircatwork.com (which does work)
18:50:50 <MarcWeber> ndm=ndm_ish?
18:51:23 <sjanssen> yikes . . .
18:51:30 <UUStudent36> (but really jcreigh)
18:51:36 <jcreigh> so yeah, it works.
18:51:41 <jcreigh> (for me)
18:51:46 <UUStudent> Seems to work. This text was sent from webinterface http://www.cs.uu.nl/wiki/FP/ChatHaskell
18:51:47 <lambdabot> Title: FP / Chat Haskell
19:04:10 <ndm_ish> @seen lambdabot
19:04:10 <lambdabot> Yes, I'm here. I'm in #happs, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell.hac07, #haskell-overflow, #haskell-
19:04:11 <lambdabot> blah and #haskell
19:08:06 <dmwit_> #unicycling?
19:08:19 <dcoutts__> > 1+1
19:08:20 <lambdabot>  2
19:08:32 <lambdabot> Yes, #unicycling. Your problem is...?
19:08:40 * dcoutts__ is looking at the actual box lambdabot runs on
19:08:50 <dmwit_> Haha.
19:09:17 <lambdabot> Pay no attention to the man behind the beige front panel.
19:09:19 <desp> the #erlang bot is also on #multicycling
19:09:20 <desp> ;p
19:09:26 <ndm_ish> dcoutts__ testing that maths works the same down under?
19:09:38 <sjanssen> > maxBound :: Int
19:09:39 <lambdabot>  2147483647
19:09:47 <ndm_ish> os
19:09:51 <ndm_ish> > os
19:09:52 <lambdabot>   Not in scope: `os'
19:09:52 <Pseudonym> ndm_ish: It does, except that our vector products use a left-hand rule.
19:10:01 <dmwit_> > maxBound :: Float
19:10:02 <lambdabot>   add an instance declaration for (Bounded Float)
19:10:02 <lambdabot>     In the expression: maxB...
19:10:16 <dmwit_> > maxBound :: Char
19:10:17 <lambdabot>  '\1114111'
19:10:29 <dmwit_> !
19:11:39 * ndm_ish cries that Haskell authors don't seem to think you can have windows without mingw
19:11:48 <allbery_b> mmm, unicode
19:11:56 <ndm_ish> (even though a reasonable number work for MS...)
19:17:59 <desp> does haskell support parametrized modules?
19:18:09 <Lemmih> No.
19:20:03 <dmwit_> ?ind fromJust
19:20:04 <lambdabot> Data.Maybe
19:21:18 <Cale> desp: However, it does have typeclasses, which are equivalent in some sense, though the "weight" associated to different uses is different.
19:21:27 <MarcWeber> Anyone familiar with wash? I can't get how askContinuously is to be used
19:21:46 <Cale> Typeclasses favour small interfaces, but provide very lightweight application of those interfaces.
19:21:47 <desp> Cale: right
19:30:31 <sjanssen> typeclasses can certainly have large interfaces
19:30:45 <sjanssen> see edison, for example
19:30:56 <Cale> well, yes, but they favour smaller ones
19:31:08 <Cale> (at least, it seems that way)
19:31:28 <sjanssen> I think the idea is to be as flexible as possible
19:31:44 <Cale> I think this is due to the fact that usually there is a fairly small core of functionality which is needed to implement other polymorphic functions.
19:32:23 <Cale> So you choose your "axioms", and the other parts of your interface arise as "theorems".
19:32:53 <Cale> (and yeah, that maximises flexibility)
19:33:08 <jfoutz> is there a buffering mode like getLineOrLimit Int - i don't want somebody to send gigs of data with no newlines at a socket... or do i need to inspect each char myself?
19:33:11 <sjanssen> on the other hand, default methods allow for instances that might be considerably more efficient
19:33:40 <ndm_ish> @hoogle buffer
19:33:41 <lambdabot> System.IO.BufferMode :: data BufferMode
19:33:41 <lambdabot> Network.Socket.RecvBuffer :: SocketOption
19:33:41 <lambdabot> Network.Socket.SendBuffer :: SocketOption
19:33:55 <ndm_ish> @hoogle a -> BufferMode
19:33:56 <lambdabot> No matches, try a more general search
19:33:59 <sjanssen> jfoutz: could you use one of the normal buffer modes in combination with getLine?
19:34:19 <Cale> Yeah, it's tricky to know where to draw the line. It might be nice if the functionality of the SPECIALIZE pragma was somehow built into the language, such that the line wouldn't have to be drawn so clearly.
19:34:26 <mgsloan> twould be nice if you could override/define defaults for inherited classes though
19:34:49 <mgsloan> err, ancestor rather
19:35:17 <sjanssen> mgsloan: you can already override class defaults
19:36:55 <jfoutz> sjanssen: i don't think it works that way... I've been poking around for a while. I think i have to read 1 char at a time, if it's a newline return the string i'm accumulating, otherwise if i over run some arbitrary length error out. but thanks. i have to remember hoogle.
19:38:17 <sjanssen> jfoutz: do you need the linebuffering to make sure your program doesn't block at inappropriate times?
19:38:42 <mgsloan> sjanssen - so i can have a class that declares a function, and then have a class which depends/inherits(dunno the terminology) it and defines a default for that function in terms of its functions?
19:39:05 <jfoutz> sjanssen: no, more like silly network protocols who's commands are terminated with\n
19:39:31 <sjanssen> jfoutz: you can certainly use LineBuffering with getLine
19:39:36 <dons> > last [1..]
19:39:37 <jcreigh> isn't it usually \r\n?
19:39:41 <lambdabot> Terminated
19:39:50 <jfoutz> like GET http://www.slashdot.org\n\n
19:39:57 <sjanssen> erm, I mean you can block based buffering with getLine
19:40:00 <dibblego> no, that's \r\n\r\n
19:40:00 <dmwit_> > last [1..] :: Int
19:40:06 <lambdabot> Terminated
19:40:57 <kc5tja> Even so, why not just grab the whole kit-n-kaboodel and just use 'lines' to fragment the packet into individual lines?
19:41:08 <jcreigh> kc5tja: think SMTP
19:42:06 <kc5tja> jcreigh: Ahh, then you'll want to set your buffer mode to GimmeEverythingAndAnticipateIntoTheFuturePerfectlyForMaximumBufferingBenefit.  ;D
19:42:31 <jcreigh> dons: I sent you a trivial (making @wiki translate spaces to underscores) patch to lambdabot via a "darcs record" and then "darcs send"; I had never used darcs before; is that the usual way to submit a patch to a Haskell project?
19:42:47 <jfoutz> sjanssen: i don't understand what you mean, block buffering with line buffering. i would like to read 4k bytes or something, if there's a linebreak earlier, that's fine, i'll take everything up to the line... but i don't see a mode like that. what am i missing?
19:43:22 <jcreigh> kc5tja: 640K should be enough for everyone, right? (I know, Gates didn't really say that, but the principle holds.)
19:43:33 <jfoutz> is there something incredibly clever about lazyness i'm missing?
19:43:38 <kc5tja> jfoutz: You want line buffering.  If a single line happens to be 4K in size, that's what you'll get.
19:44:01 <kc5tja> jcreigh: Actually, he DID say that.
19:44:06 <jfoutz> no, the spec says, i get nothing until i get a newline.
19:44:12 <jcreigh> kc5tja: really? link?
19:44:19 <jfoutz> so if you send me 10 gigs of zero... i'm hosed.
19:44:44 <jcreigh> ISTR finding that was an urban legend the last time I tried to track it down.
19:45:00 <jfoutz> i want line buffering unless you send me way more than i want.
19:48:43 <allbery_b> urban legend.
19:48:44 <kc5tja> jfoutz: You can't get that without writing it yourself as far as I'm aware.  You'll have to use block buffering, I'm afraid.
19:49:11 <jfoutz> ok, that's what i was starting to think, just double checking. thanks!
19:49:43 <dino-> > take 20 [1..]
19:49:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
19:49:57 <allbery_b> don't recall the details, I think it was axctually said about the PC *hardware* (i.e. IBM, not Gates) by one of the folks who couldn't understand why anyone would care about the amount of memory in "toy computers"
19:50:09 <jcreigh> but 640K quote is an important lesson regardless: arbitrary limits always come back to bit you.
19:50:14 <jcreigh> *bite
19:50:50 <jfoutz> psh. 4 bytes of address space will be enough forever! er for ints. whaterver.
19:51:15 <allbery_b> (it must be understood that, as far as IBM was concerned, the PC was introduced as an interface to a mainframe.  it took them years to figure out why the thing became so popular.)
19:52:29 <allbery_b> (and the only reason it was introduced was to keep their big customers from buying non-IBM stuff, without any real understanding of *why* they were doing so)
19:56:27 <jcreigh> the tempting thing is, eg, when 64bit machines are common, thinking: okay, *this time* machine word-size ints are big enough.
19:59:43 <Lemmih> 17179869184 gigs of memory isn't enough?
19:59:51 <kc5tja> jcreigh: I couldn't find a link, sorry, but I did find this, which is almost as good.  http://www.youtube.com/watch?v=nvZIoiFwK1k
19:59:54 <kc5tja> :)
20:00:00 <jcreigh> ints, not address-space. :)
20:00:20 <jcreigh> I think address-space is going to be fine for a while.
20:00:51 <sorear> jcreigh: (looking at logs) Yes.
20:00:59 <Pseudonym> And even then, address-space isn't memory.;
20:01:03 <sorear> darcs record ; darcs send is correct.
20:01:11 <jcreigh> sorear: okay, thanks
20:01:21 <jcreigh> does that just send them an email in a format darcs can grok?
20:01:51 <sorear> right.
20:01:58 <sorear> darcs send sends emain
20:02:25 <sorear> darcs send -o /tmp/my_mailsystem_is_broken_so_I_promise_to_mail_this_myself too
20:02:34 <sorear> unless you're using MacOS
20:02:45 <jcreigh> that's cool that darcs has a "send a patch" command. It's like darcs is designed for open source projects.
20:02:45 <sorear> darcs send -o /tmp/my_mailsystem_is_broken_so_I_pr
20:02:49 <sorear> in that case
20:03:00 <jcreigh> haha. MacOS are filename length limits?
20:03:03 <sorear> remember, 31 char limit :)
20:03:21 <sorear> dos is dead so we have to poke fun at hfs+ now
20:03:45 <desp> uh.
20:03:46 <sorear> such a shame ext2 was modified to reduce the length limit from 65535 to 255
20:03:56 <desp> HFS+ does not have a 31 char limit
20:03:59 <Cale> sorear: why the heck was that done?
20:04:23 <desp> only if you're using obsolete software
20:04:32 <desp> written in pre-Carbon days
20:04:36 <sorear> Cale: to free up a byte in struct dirent to hold the filetype cache
20:13:26 <falconair> hi folks, are any of you familiar with monetdb?  it is a 'vertically decomposed' database.  I've been wondering if it is feasible to use Haskell's bytestrings to duplicate the functionality of monetdb...perhaps with far less code ...
20:13:33 <falconair> any one know of any obvious problems with this idea?
20:20:14 <Cale> falconair: I don't know anything about MonetDB, but another option to consider would be using FFI to bind to it.
20:20:30 <Cale> Or writing a driver for HDBC.
20:22:16 <falconair> well, i don't actually want to access it, i was thinking that it might be cool to duplicate it ... as it is, the query engine is far more appropriate for functional programming languages rather than imperative languages (algebraic properties being optimized, etc.) ... this is the same one Prof. Grust (profteggy or similar #haskell nick) uses for his xquery stuff
20:24:01 <Lemmih> Rewriting MonetDB in Haskell seems like a non-trivial undertaking.
20:26:11 <falconair> let's say the 'idea' of monetdb ... bunch of columns stored on disk and read into memory, while queries are parsed, optimized and answered by a haskell system on top ... i'm also thinking of recent papers on the DODO query flattening ...
20:26:37 <falconair> frankly i'm surprised there aren't already 3 different haskell implementations of this idea ... perhaps because bytestring is rather new?
20:27:04 <ddarius> @where self
20:27:04 <lambdabot> http://research.sun.com/self/papers/papers.html
20:28:35 <sorear> @users
20:28:35 <lambdabot> Maximum users seen in #haskell: 339, currently: 281 (82.9%), active: 45 (16.0%)
20:29:18 <sorear> Argh, yac << parsec
20:30:20 <mgsloan> so 'yac' is executed after parsec then, eh, curious!
20:30:27 <sorear> +c
20:30:36 <Lemmih> falconair: Data.ByteString is just a pretty interface to old functionality.
20:30:41 <sorear> and s/<</`isMuchWorseThan`/
20:31:34 <Lemmih> falconair: I doubt that lack of it would have been a show stopper.
20:31:38 <falconair> Lemmih, i thought ByteString had super optimized, memory mapping C code underneath it, no?
20:32:03 <sorear> falconair: optimized, yes.  memory mapping, no.
20:32:32 <sorear> falconair: appearantly under windows mmap bypasses ALL caches --> extremely low performance
20:32:34 <Lemmih> falconair: It uses very little C.
20:32:51 <sorear> and even less now than it used to
20:33:16 <falconair> sorear: why less now?  due to something in ghc 6.6?
20:33:22 <sorear> since dons/rl/forgotten have figured out how to coerce ghc into generating good code
20:33:34 <sorear> falconair: no, just some *really* good ideas
20:33:41 <sorear> @go rewriting haskell strings
20:33:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
20:33:43 <lambdabot> Title: Rewriting Haskell Strings
20:35:10 <falconair> hm...doing a little query engine may still be an interesting (motivating) idea ... perhaps even useful since i can't even get monetdb to compile ... i'll prolly have to write more than 3 lines of haskell before i can do a project such as that though :)
20:40:57 <falconair> sorear: it looks like bytestring does do memory mapping: http://www.cse.unsw.edu.au/~dons/tmp/Data-ByteString.html#v%3AmmapFile
20:40:58 <lambdabot> http://tinyurl.com/2dunlv
20:42:35 <jfoutz> @hoogle dotimes
20:42:36 <lambdabot> No matches found
20:46:32 <Lemmih> falconair: Still, that's nothing new.
20:47:26 <brad_> can anyone provide a decent explanation of Arrows? or are they too complicated for this type of communication?
20:48:37 <jfoutz> i think they're like an underwater space suit nuclear waste processing... oh nevermind.  I don't understand them :)
20:49:08 <brad_> your humor is appreciated anyway jfoutz
20:49:28 <Lemmih> Arrows are to functions what monads are to data.
20:50:06 <brad_> hmm, interesting Lemmih
20:50:10 <brad_> thanks
20:50:51 <sorear> Lemmih: An arrows is an abstraction which is a lot like a monad, but makes input operations explicit.
20:50:58 <sorear> s/Lemmih/brad_/
20:51:20 <sorear> brad_: this makes it feasable to do a lot more static operations in an arrow.
20:51:58 <brad_> hmm, thanks sorear, that's something to chew on!
20:52:15 <sorear> brad_: for instance Parsec (monadic parsers) needs to use naive recursive descent, while arrow parsers have been written that perform yacc(1) style LALR(1) compilation for speed
20:52:52 <brad_> interesting you mention Parsec, as i am investigating Arrows via HXT
20:53:15 <bos_> it seems like the speed advantage of table-driven parsing is something of a myth, though.
20:53:27 <brad_> as an aside, do people have an opinion of Parsec vs HXT? it seems they could both be used to digest XML
20:53:51 <bos_> totally different tools.
20:54:00 <bos_> parsec is for parsing. hxt is for parsing xml.
20:54:25 <brad_> thats what i figured, thanks bos_.
20:54:26 <bos_> so if you wanted to write an xml parser in parsec, you'd have to do a fair bit of work.
20:54:38 <brad_> we definitely want to avoid work
20:54:55 <brad_> HXT is a brainful though!
20:55:03 <sorear> wow, google++
20:55:11 <bos_> que?
20:55:24 <sorear> "daan pretty" gives Daan Leijen's pretty printer
20:55:30 <bos_> heh
20:55:36 <bos_> @goo daan pretty
20:55:37 <sorear> you'd think that was an unlikely result
20:55:38 <lambdabot> http://repetae.net/john/recent/src/hsdocs/Doc-Pretty.html
20:57:19 <brad_> thanks for the answers and help folks!
21:00:13 <sorear> @localtime dcoutts
21:00:31 <sorear> beh, /me remembers date --utc
21:06:53 <sorear> Wow, PPrint is pre-hier-mods
21:07:17 <bos_> PPrint dates back to the early 1990s.
21:09:09 <dons> localtime dcoutts: 3.08pm
21:10:46 <sorear> dons: actually I wanted the time in England; I had momentarily forgotten about --utc :)
21:13:01 <ClaudiusMaximus> it's 4:12am in london
21:13:12 <Lemmih> dcoutts is in Australia?
21:13:19 <sorear> Lemmih: yeah!
21:13:48 <sorear> 18:16:00 * dcoutts__ has arrived in .au
21:13:55 <sorear> clog++
21:14:31 <jcreigh> "clog"? oh, is that your IRC client's equivilent of irssi's /lastlog?
21:14:31 <sorear> some kind of conference, or did he just want to see dons? :)
21:14:46 <sorear> jcreigh: /whois clog
21:14:51 <sorear> jcreigh: it's a logger bot
21:14:57 <jcreigh> oh. :)
21:15:04 <sorear> jcreigh: writes tohttp://tunes.org/~nef/logs/haskell/07.03.12
21:15:05 <sm> evening all
21:15:08 <sorear> hi.
21:15:43 <sm> I'm looking for some kind of DateTime in the std lib.. a general date & time type
21:16:00 <sorear> Data.Time
21:16:05 <sorear> @docs Data.Time
21:16:06 <lambdabot> Data.Time not available
21:16:14 <sorear> @slap @docs
21:16:14 * lambdabot slaps @docs
21:16:29 <sm> might UniversalTime be what I want ?
21:16:33 <dons> dcoutts is visiting us for a couple of months
21:16:39 <jcreigh> months?
21:16:43 <jcreigh> us?
21:16:51 <jcreigh> define your terms. :)
21:17:00 <dons> @web1913 month
21:17:02 <lambdabot> *** "Month" web1913 "Webster's Revised Unabridged Dictionary (1913)"
21:17:02 <lambdabot> Month \Month\, n. [OE. month, moneth, AS. m[=o]n?, m[=o]na?;
21:17:02 <lambdabot>    akin to m[=o]na moon, and to D. maand month, G. monat, OHG.
21:17:02 <lambdabot>    m[=a]n[=o]d, Icel. m[=a]nu?r, m[=a]na?r, Goth. m[=e]n[=o]?s.
21:17:02 <lambdabot>    [root]272. See {Moon}.]
21:17:02 <jcreigh> speak of the devil
21:17:04 <lambdabot> [61 @more lines]
21:17:07 <sorear> visiting could also use clarification
21:17:21 <dons> @web1913 visit
21:17:22 <lambdabot> *** "Visit" web1913 "Webster's Revised Unabridged Dictionary (1913)"
21:17:23 <lambdabot> Visit \Vis"it\, n. [Cf. F. visite. See {Visit}, v. t., and cf.
21:17:23 <lambdabot>    {Visite}.]
21:17:23 <lambdabot>    1. The act of visiting, or going to see a person or thing; a
21:17:23 <lambdabot>       brief stay of business, friendship, ceremony, curiosity,
21:17:24 <lambdabot> [36 @more lines]
21:17:25 <jcreigh> lol
21:18:08 <bos_> so do dons and dcoutts constitute the dph ninja strike team?
21:18:10 <sorear> context: <sorear> some kind of conference, or did he just want to see dons? :)
21:18:10 <sorear> <dons> dcoutts is visiting us for a couple of months
21:18:22 <dcoutts__> @yarr
21:18:23 <lambdabot> Shiver me timbers!
21:18:31 <dons> bos_, well, stream fusion strike team, + roman l.
21:18:43 <bos_> mmmm, stream fusion.
21:18:46 <sorear> bos_: emmanuel chakravarty is on dph
21:18:57 <Lemmih> dcoutts__: You're staying in .au for a couple of months?
21:19:00 <dcoutts__> bos_: yeah, I don't do ndp stuff directly, but the stream fusion is obviously closely related
21:19:12 <dcoutts__> Lemmih: yep, 6 weeks.
21:19:27 <bos_> the ndp stuff makes me want to go back to graduate school :-)
21:19:33 <sm> UTCTime and NominalDiffTime looks like the ticket
21:19:33 <bos_> it's very very interesting looking
21:22:42 <dons> http://edge-loop.spaces.live.com/Blog/cns!8F028CC27525BEA1!1175.entry
21:22:44 <lambdabot> http://tinyurl.com/27mwk5
21:28:38 <sm> what's a good way to parse/read a LocalTime from a string ?
21:28:57 <dons> http://programming.reddit.com/info/19ucg/details (some nice things on haskell)
21:28:58 <lambdabot> Title: Fundamental Ideas of Computing (reddit.com)
21:29:04 <dons> sm, with the 'time' lib?
21:29:06 <dons> ?hackage time
21:29:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/time
21:29:12 <desp> ?src space
21:29:12 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:29:18 <sm> aha, thx
21:29:21 <dons> ?src isSpace
21:29:21 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:29:23 <dons> :-)
21:29:28 <dons> ?source Data.Char
21:29:28 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
21:29:29 <desp> ?src Text.ParserCombinators.Parsec.space
21:29:29 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:29:33 <desp> ugh
21:29:39 <dons> ?source Text.ParserCombinators.Parsec
21:29:39 <lambdabot> http://darcs.haskell.org/packages/parsec/Text/ParserCombinators/Parsec.hs
21:29:43 <sm> though, I don't want to require too many libs just yet
21:29:44 <desp> ah
21:29:45 <desp> thx
21:29:46 <dons> (most things aren't in @src)
21:30:22 <sm> ah, this looks like what I have in Data.Time (ghc 6.6)
21:30:33 <jcreigh> yeah, mostly it's just Prelude/stdlib type stuff. But still darn handy.
21:30:50 <jcreigh> dons++ for @src, even though I'm sure my @karma+ for dons has been used up already. :)
21:32:57 <MarcWeber> dons++ ;)
21:33:26 <sm> I haven't found any parser though..
21:33:40 <dons> sm, hmm. there's definitely a time parser
21:33:45 <dons> maybe its in one of the other packages?
21:33:50 <dons> 'parsedate'? is that a package?
21:33:58 <sm> cool, I'll keep digging
21:33:59 <sm> "Note that the sun itself may be up to 16 minutes off UT0 due to the  "equation of time", that is, the motion of the earth on its elliptical  orbit."
21:34:12 <sm> jeez. noone is punctual.
21:34:45 <sm> time is an amazingly intricate phenomenon. :)
21:36:24 <MarcWeber> sm http://haskell.org/haskellwiki/Libraries_and_tools/Operating_system#Time "ParseDate" ?
21:36:27 <lambdabot> Title: Libraries and tools/Operating system - HaskellWiki, http://tinyurl.com/wpeo9
21:37:39 <sm> thank you
21:38:32 <sorear> sm: time is very simple, at a low level.  but most people don't like to deal with the natural coordinates of Minkowskian spaces .... UIs are challengine
21:39:07 * sm is reading http://www.haskell.org/pipermail/libraries/2005-January/002908.html
21:39:09 <lambdabot> Title: Time, http://tinyurl.com/2csydx
21:41:29 <sm> I just need a simple clocktime parser though, I think I'll make one
21:46:13 <jcreigh> date/time handling seems like one of those things that's really hard to get 100% correct, but 90% is still pretty useful.
21:47:24 <sm> like money..
21:48:43 <ddarius> "There's clearly no avoiding it, it's time for me to learn Haskell. It seems as if everyone who's anyone in the FP world seems to use this language. Haskell appears to be the tool of choice when exploring language / compiler / runtime design." Self-propagating/fulfilling meme.
21:55:10 <jcreigh> mapM toHaskell realWorld
21:56:45 <ClaudiusMaximus> some technomusicvideos i made in part with Haskell (embedded in Pd to generate translation vectors)  http://www.archive.org/details/ClaudiusMaximus_-_d0-_d1-_d2-_d3-_d4__2007-03-12_  (note: has a flash player that might start playing automatically)
21:56:46 <lambdabot> Title: Internet Archive: Details: d0->d1->d2->d3->d4 (2007-03-12), http://tinyurl.com/22pxxr
21:57:21 <witten> can someone familiar with uniqueness typing explain how it might work on a lazily evaluated language? for instance, how can you statically determine whether a particular variable is uniquely references without strictly evaluating everything?
21:57:35 <witten> s/references/referenced/
21:58:00 <Cale> ClaudiusMaximus: Is it supposed to have that overwhelmingly loud additional tone?
21:58:15 <Cale> okay, perhaps it is
21:58:31 <russells> Can someone tell me (or point to an explanation) why "x=1" doesn't work at the ghci or hugs prompt?  Is it because assigning to x would be a side effect and I'd be keeping state where it's not allowed?
21:58:45 <desp> unexpected ")"
21:58:46 <desp> expecting space, letter, "_", "\"", "(" or ")"
21:58:46 <jcreigh> russells: try "let x = 1"
21:58:50 <desp> sigh
21:58:55 <ClaudiusMaximus> Cale: yeah, i need to work on it some more, it's rather raw...
21:59:06 <desp> can someone give me a little hand with Parsec?
21:59:41 <russells> jcreigh: thanks
21:59:46 <jcreigh> russells: but in general, it's tricky to define function interactively. you can do simple stuff easily enough: "let f x = x * x" or whatever; but for anything othat than a simple one-liner, I usually stick it into a file and then load it with ghci.
21:59:50 <bos_> witten: the older clean papers explain this stuff.
22:00:16 <witten> bos_: ok, I'm looking at the clean reference manual, so maybe I should continue reading that
22:00:19 <hpaste>  desp pasted "simple Parsec problem" at http://hpaste.org/951
22:00:23 <witten> I just haven't found the answer thus far
22:00:26 <Cale> russells: basically, ghci and hugs are aimed at evaluating expressions given a file of declarations which you load into them
22:00:49 <russells> yes, I've been editing files using :e and :l, (seen in yaht, I think) but was trying to do stuff interactively.
22:00:50 <desp> my code fails to parse "( )" into a List []
22:00:54 <bos_> witten: the reference manual is not going to tell you anything interesting.
22:01:01 <desp> the excess space foils it
22:01:10 <Cale> russells: they'll also perform IO actions when they come across them. GHCi simulates the rest of the do-block syntax in allowing you to make local bindings with let
22:01:13 <witten> bos_: oh, what do you recommend then for finding out how uniqueness typing works in a lazy language?
22:01:23 <bos_> you're going to have to dig into citeseer for the original papers describing clean and uniqueness types. they date back to the early 1990s.
22:01:26 <hpaste>  (anonymous) pasted "mfix IO?" at http://hpaste.org/952
22:01:30 <Cale> (but you can't do things like declare new types)
22:01:43 <witten> bos_: ok
22:01:45 <Cale> ClaudiusMaximus: the second one is fairly cool :)
22:03:05 <ddarius> witten: As far as I know Clean (a lazy language) is the only significant language using uniqueness/linear typing.
22:03:05 <desp> hello? :)
22:03:25 <russells> So is ``putStrLn "foo"'' also given an implicit do block by ghci?
22:03:32 <witten> ddarius: right
22:03:34 <Cale> witten: I think the basic idea is that you can only literally refer to it once.
22:03:42 <ClaudiusMaximus> Cale: thanks.  they're both edited from the same 45minute session, the plan is to improve meta-control mechanisms so that people don't get bored listening to a live performance...
22:03:45 <bos_> witten: but the early clean papers are heavily theoretical.
22:03:58 <Cale> I could be wrong at that, but it seems likely to me.
22:04:05 <Lemmih> (anonymous): mfix (\myThreadId -> forkIO (...))
22:04:28 <witten> cale: it seems though that technically you could refer to something multiple times while still retaining uniqueness, as long as you don't save of a reference to it
22:04:34 <witten> s/of/off/
22:04:42 <ddarius> desp: There should be lexer combinators that will eat the whitespace around lexical tokens.
22:04:42 <desp> Lemmih: can you take a look at the previous paste, as well?
22:05:11 <desp> ddarius: I hoped I could eat the whitespace myself
22:05:23 <bos_> so if you don't have a bit of grounding in type theory, they're going to read like gobbledygook. try "Conventional and Uniqueness Typing in Graph Rewrite Systems", which is pretty early, and heavy stuff.
22:05:36 <ddarius> desp: You can, it's just usually easier to use the predefined combinators.
22:05:39 <Cale> witten: hmm. You mean if the thing only ends up actually used once?
22:06:03 <ddarius> Anyways, spaces gets backtracked so you don't eat any if there are no Values.
22:06:16 <witten> cale: yeah, that would be one way
22:06:22 <Cale> (for instance, duplicating a function parameter in each of the elements of a list, but then only using one of the list elements)
22:06:24 <bos_> beware, that paper is about a million pages long.
22:06:36 <ddarius> desp: There are a couple of quick hacky ways to dealing with this, e.g. just throw 'spaces' before the many
22:06:54 <witten> bos_: ok thanks :)
22:07:04 <Lemmih> desp: It doesn't work?
22:07:38 <witten> cale: yeah that makes sense in a lazy context
22:08:02 <witten> I guess my misunderstanding stems from the fact that you can do static analysis at compile-time even if you do lazy evaluation at run-time
22:08:04 <Lemmih> desp: 'parseTest parseValue "(atom \"string\")"' seems to work fine.
22:09:04 <Cale> I'm not sure that any such analysis is done though. I think it just doesn't permit any syntactic duplication. (Still, I could be wrong, it's been a while since I've played with clean at all)
22:09:34 <witten> hmm
22:10:28 <bos_> cale is correct.
22:10:32 <witten> I'm reading a paper (not about Clean, but about uniqueness typing in general) and it talks abou the idea of "alias killing: when a unique field is read, any existing aliases are required to be dead"
22:12:17 * mgsloan rides the netsplit wave
22:15:01 <desp> ddarius, Lemmih: thanks
22:15:01 <desp> not sure if that got lost in the split
22:15:29 <hpaste>  Cale annotated "mfix IO?" with "example of use in constructing cyclic structure" at http://hpaste.org/952#a1
22:18:44 <sm> is this a reasonable way to convert a NominalDiffTime to Double ? read $ init $ show ndt :: Double
22:18:56 <sorear> bye.
22:19:20 <Cale> @index NominalDiffTime
22:19:57 <Cale> sm: I don't know what that is.
22:20:07 <Cale> oh I see
22:20:10 <Cale> Data.Time.Clock
22:20:23 <sm> yup
22:20:39 <sm> a difference of UTCTimes
22:20:48 <Cale> Use realToFrac, I think
22:21:03 <Cale> @type realToFrac
22:21:13 <Cale> oh, lb is dead
22:21:14 <lambdabot> bzzt
22:21:14 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
22:21:17 <Cale> ah
22:21:23 <Cale> there we are :)
22:21:41 <Cale> It's an instance of Real, and Double is an instance of Fractional
22:21:50 <Cale> So you can convert that way.
22:25:46 <sm> thank you
22:26:14 * sm still juggling utcs, localtimes, nominaldifftimes, io..
22:28:52 <sm> darn.. a bit of a puzzle here
22:29:32 <sm> I want to parse a time log of clockin, clockout entries, and automatically provide a clockout entry if missing
22:30:10 <Cale> How to provide the clockout?
22:30:21 <sm> exactly.. getting the current time is in IO.. this seems to muck up my parser a bit
22:30:29 <Cale> oh
22:30:37 <Cale> You don't want to do that bit in the parser
22:30:44 <ddarius> @ft foldr
22:30:46 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
22:30:47 <lambdabot>    forall T3,T4 in TYPES. forall h2 :: T3 -> T4, h2 strict.
22:30:47 <lambdabot>      forall f1 :: T1 -> T3 -> T3.
22:30:47 <lambdabot>        forall g1 :: T2 -> T4 -> T4.
22:30:47 <lambdabot>          (forall x3 :: T1.
22:30:48 <lambdabot> [5 @more lines]
22:30:49 <Cale> do it after
22:31:04 <sm> alright.. thx
22:32:27 <sm> could I intermix those monads, in theory ?
22:34:26 <ddarius> @ft (a -> a) -> (a -> a)
22:34:28 <lambdabot>  There was an error in the type: (line 1, column 7):
22:34:28 <lambdabot>  unexpected "e"
22:34:28 <lambdabot>  expecting "->" or end of input
22:34:41 <ddarius> @ft n :: (a -> a) -> (a -> a)
22:34:43 <lambdabot>  There was an error in the type: (line 1, column 4):
22:34:44 <lambdabot>  unexpected type constructor 'Not' (this type constructor is not declared)
22:41:33 <Pseudonym> ?free foldr
22:41:35 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
22:41:56 <Pseudonym> That makes a bit more sense if you un-pointefree the first part.
22:42:04 <Pseudonym> un-pointsfree
22:55:36 <mgsloan> ?free map
22:55:38 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
22:57:06 <mgsloan> ?free lines
22:57:08 <lambdabot> $map $id . lines = lines
22:57:17 * mgsloan has no idea what it's doing
23:00:35 <Cale> haha, that's the dumbest free theorem ever
23:00:47 <Cale> (the one for lines)
23:01:06 <mgsloan> hehe, yeah :)
23:01:15 <Cale> It's generating theorems from the types. The $'s before identifiers just mean that it's the prelude version.
23:01:23 <mgsloan> ?free filter
23:01:26 <lambdabot> $map f . filter (g . f) = filter g . $map f
23:01:30 <mgsloan> ahh
23:01:36 <mgsloan> that clears things up a bit
23:02:46 <Cale> ?free map
23:02:49 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
23:02:54 <Cale> ?free mapM
23:02:56 <lambdabot> Extra stuff at end of line in retrieved type "\n    Ambiguous occurrence `mapM'\n    It could refer to either `mapM', imported from Control.Monad.Writer\n\n"
23:03:04 <Cale> ?free Control.Monad.mapM
23:03:05 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
23:03:59 <desp> hrm
23:04:24 <desp> I want to write a function that'd pretty-print S-expressions, with the appropriate indent
23:04:38 <emu> check out Text.PrettyPrint
23:04:45 <desp> I thought that I could use the State monad to keep the indent together with the string
23:05:19 <sjanssen> desp: you could do that too
23:05:36 <desp> emu: I don't appear to have a module Text
23:05:38 <sjanssen> Text.PrettyPrint has nice high level functions to do all of this, though
23:05:49 <sjanssen> desp: the module is Text.PrettyPrint
23:06:41 <desp> okay, I'll check it out
23:06:43 <desp> for the time being
23:06:56 <desp> I'm a little stumped by State
23:07:09 <desp> I'm rereading http://www.haskell.org/all_about_monads/html/statemonad.html#motivation
23:07:11 <lambdabot> Title: The State monad, http://tinyurl.com/2g4v8r
23:08:40 <mgsloan> part of understanding the State monad is probably that it's not really all that hugely useful on its own
23:08:56 <desp> but I can't really understand when State ends and the random number generator begins
23:09:07 <desp> mgsloan: I simply want to associate an Int with a String
23:09:31 <nmessenger> @unmtl State StdGen Int
23:09:32 <lambdabot> StdGen -> (Int, StdGen)
23:09:36 <nmessenger> "A function that takes a StdGen and results in an Int and a new StdGen"
23:09:48 <desp> one function would take a String and return a State Int String, with the Int set to 0
23:09:50 <emu> Reader is better for a pretty printer anyhow
23:10:29 <Cale> desp: the Int isn't necessarily set to anything specific in a State Int String
23:10:35 <emu> with state, you have to change the state, recur, and change the state back
23:10:46 <Cale> @unmtl State Int String
23:10:46 <lambdabot> Int -> (String, Int)
23:10:47 <nmessenger> @type \s -> put s >> return 0
23:10:49 <lambdabot> forall s (m :: * -> *) t. (Num t, MonadState s m) => s -> m t
23:11:13 <emu> but really, just use the pretty printer library. it's nice.
23:11:36 <desp> emu: I'm trying to learn here, ssh :)
23:12:21 <Cale> A value of type State Int String is a function from Ints to (String, Int) pairs.
23:12:41 <desp> hm
23:12:43 <Cale> (where the Int in that pair is the final state)
23:12:57 <Cale> and the parameter is the initial state
23:13:40 <desp> perhaps the State monad isn't the best fit , then
23:13:48 <Cale> When you connect State computations together with (>>), the final state of the thing on the left becomes the initial state of the thing on the right
23:14:01 <Cale> Well, in the end, you'll supply an initial state of 0
23:14:38 <nmessenger> @type \s -> put (0::Int) >> return (s::String)
23:14:41 <lambdabot> forall (m :: * -> *). (MonadState Int m) => String -> m String
23:14:48 <Cale> However, emu is right about Reader being a better fit.
23:14:57 <Cale> You can use local to modify the indentation locally.
23:15:22 <Cale> and when you come out of that block of code, the indentation goes right back to where it was
23:15:23 <desp> ok, I'll check out Reader
23:16:28 <Cale> (It gives you less control, but also less chances to mess things up)
23:17:25 <Cale> If you'd like, I could point you at a paper which discusses the design of a really nice pretty printer library.
23:17:39 <sm> ok, enough brainless hacking.. night all
23:17:41 <Cale> http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf
23:20:43 <desp> Cale: that's very interesting, thanks
23:21:20 <Cale> IMO, the result is a better pretty printer than currently exists in the hierarchical libraries.
23:29:26 <mwc> Hey, who wrote http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes
23:29:32 <lambdabot> Title: Monads in 15 minutes: Backtracking and Maybe, http://tinyurl.com/2xlyze
23:29:39 <mwc> Didn't recognize Eric Kidd
23:29:47 <mwc> so Eric Kidd, please self-identify
23:30:03 <kowey> he seems to go by emk on reddit
23:32:01 <nmessenger> he's also here on #haskell sometimes
23:32:14 <nmessenger> as emk
23:32:31 <Korollary> @seen emk
23:32:31 <lambdabot> I saw emk leaving #haskell 2h 32m 59s ago, and .
23:35:07 <mwc> cool, never saw him say anything
23:40:44 <narain> ?quote silence
23:40:45 <lambdabot> shapr says: I was chatting with someone who writes Haskell and at some point they said they're not an academic, and I said that too. And then there was what I perceived to be a small disbelieving
23:40:45 <lambdabot> silence...
23:40:49 <Cale> http://support.microsoft.com/default.aspx?scid=kb;en-us;261186
23:41:20 <Cale> You'd think that Award/Unicore would have selected something more urgent sounding, like continuous beeping.
23:42:22 <desp> that's a cool tutorial
23:42:30 <desp> the backtracking one
23:42:35 <Cale> yeah :)
23:45:01 <nmessenger> emk++
23:47:34 <nmessenger> also, HAHAHAHAH @ Classical music fan death!
23:48:12 <nmessenger> Award/Unicore++
23:48:48 <Cale> Please relax and listen to this classical music. Your computer is about to catch fire.
23:49:13 <nmessenger> *hums Fur Elise*
23:52:15 <desp> how can I print a string with embedded '\n' chars across multiple lines?
23:52:45 <dmwit> > unlines ["Hello,", "world."]
23:52:46 <lambdabot>  "Hello,\nworld.\n"
23:52:46 <dmwit> Like that?
23:52:48 <nmessenger> putStr?
23:53:03 <dmwit> o
23:53:08 <desp> like nmessenger said; thanks
23:53:20 <nmessenger> also putStrLn
23:53:34 <nmessenger> print is just show then putStrLn anyway
23:53:38 <nmessenger> @src print
23:53:39 <lambdabot> print x = putStrLn (show x)
23:54:32 <desp> can I get hugs to show me the source of things, too?
23:54:38 <desp> (or ghci)
23:54:48 <ivanm> ?seen emk
23:54:49 <lambdabot> I saw emk leaving #haskell 2h 55m 17s ago, and .
23:54:58 <ivanm> @help list
23:54:58 <lambdabot> list [module|command]
23:54:59 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
23:55:12 <Korollary> I think there's a ghci-lambdabot integration module.
23:55:17 <Korollary> The name escapes me.
23:55:18 <nmessenger> that's a lambdabot feature, you might try compiling her and using GOA (ghci on acid = ghci + lambdabot)
23:55:27 <desp> the best thing I see is :find for now
23:55:29 <nmessenger> @where goa
23:55:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
23:55:35 <desp> ok, thanks
