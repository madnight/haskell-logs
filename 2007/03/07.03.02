00:07:27 <earthy> nah. it had already been deprecated by bitrot. :)
00:09:26 <cpfr> hey is there anyway in ghci to enter functions that are multiple lines
00:10:34 <notsmack> cpfr: indent the lines after the first one
00:10:47 <Lemmih> cpfr: Use ';' as a separator.
00:12:49 <cpfr> thanks
00:12:57 <cpfr> how would indent work?
00:21:34 <dons> cptchaos: its probably more useful to load from a file though, once you reach that point
00:44:41 <dons> JaffaCake: those patches seem to have done a trick or two on amd64 :)http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
00:44:42 <lambdabot> Title: nobench: Haskell implementation shootout
00:44:46 <dons> some good speedups
00:45:04 <dons> nsieve looks good, sumcol got better
00:45:31 <JaffaCake> nice :)
00:46:34 <JaffaCake> I might look at recursive next
00:47:31 <dons> nsieve got better on x86 too, and sumcol beats -fvia-C there
00:47:36 <dons> http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
00:47:36 <lambdabot> Title: nobench: Haskell implementation shootout
00:48:12 <dons> oh there's some x86 numbers that need to be updated though
00:48:18 <dons> bernouilli is out of date
00:56:06 <hpaste>  Kaji pasted "type coercion" at http://hpaste.org/752
00:56:51 <dons> Kaji: fromIntegral
00:57:01 <dons> :t length . show
00:57:04 <lambdabot> forall a. (Show a) => a -> Int
00:57:07 <dons> :t fromIntegral . length . show
00:57:10 <lambdabot> forall b a. (Num b, Show a) => a -> b
00:57:16 <dons> :t genericLength . show
00:57:18 <lambdabot> forall i a. (Num i, Show a) => a -> i
00:57:43 <Kaji> dons: Thanks, let me try that...
00:58:14 <dons> the constraint to Int is produced by length
00:58:16 <dons> :t lenght
00:58:18 <dons> :t length
00:58:19 <lambdabot> Not in scope: `lenght'
00:58:21 <lambdabot> forall a. [a] -> Int
00:58:26 <dons> as you can see.
00:58:43 <ivanm> why can't length be Integer?
00:58:47 <Kaji> Gotcha. I need to "promote" the result of length to an Integer from an Int.
00:59:33 <dons> so its for hysterical reasons
00:59:48 <dons> since its is felt unlikely you'd have a list in memory larger than word sized
01:00:02 <fishkandy> word up!
01:00:04 <dons> however, genericLength is here to save the day
01:00:20 <dons> > genericLength "haskell" :: Double -- even
01:00:22 <lambdabot>  7.0
01:00:34 <ivanm> "hysterical" reasons? Oh no, what are we going to do, I have to find the length of a list, how am I going to do this...
01:00:36 <ivanm> ;)
01:00:36 <dons> so its a premature optimisation.
01:01:08 <dons> though it doesn't hurt introducing a bit of Int into your code, it runs faster
01:01:25 <fishkandy> http://bother.kfish.org/ticket/38
01:01:26 <lambdabot> Title: #38 (learn to use word) - kfish - Trac
01:01:37 <Cale> I'm not sure if Int actually deserves to be in the Prelude though.
01:01:58 <dons> you would say that
01:02:00 <dons> ;)
01:02:10 <dons> we should just have S and Z, no?
01:02:23 <Cale> Integer is great.
01:02:37 <dons> yeah, though only if you're using libgmp
01:02:47 <Cale> When are you not?
01:02:53 <dons> i suspect there were performance issues much greater than today back in the early 90s
01:02:58 <dons> well, then you have say, hugs,.
01:03:02 <Cale> ah
01:03:04 <dons> hugs' Integer is really bad
01:03:28 <dons> check pidigits, http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
01:03:29 <lambdabot> Title: nobench: Haskell implementation shootout
01:03:42 <dons> that's an Integer benchmark, and basically comes down to whether your use libgmp, or something else
01:03:53 <dons> now I guess that no one used libgmp in the early 90s?
01:03:59 <dons> making the penalty for Integer much greater?
01:04:02 <dons> hence Int.
01:04:15 <dons> nowdays, we'd probably just go with Integer. then have Data.Int
01:04:17 <Cale> Yeah, that seems probable
01:04:48 <dons> it'd be interesting to find out how much of the Prelude uses Int
01:04:51 <Cale> libgmp is a C library, I wonder why hugs doesn't use it.
01:05:10 <dons> it implements its own, slightly more accurate version, malcolm told me
01:05:29 <dons> then again, it also gets more stuff wrong according to the benchmarks
01:05:45 <Cale> More accurate?
01:07:40 <dons> it had rounding the way the h98 reported wanted (/me tries to remember)
01:09:28 <dons> JohnMeacham: so i've got today's jhc. should I be using -ffast ?
01:09:36 <dons> (is that the fgrin backend?)
01:14:00 <quicksilver> @pl \x y z -> (x,y,h z)
01:14:00 <lambdabot> flip flip h . ((.) .) . (,,)
01:14:14 <quicksilver> is that really the best answer? using flip there seems unidiomatic
01:14:55 <quicksilver> especially when you compare with this:
01:15:01 <quicksilver> @pl \x y z -> [x,y,h z]
01:15:02 <lambdabot> (. ((. (return . h)) . (:))) . (.) . (:)
01:15:24 <dons> @pl \x y z -> ((x,y),h z)
01:15:25 <lambdabot> flip flip h . (((.) . (,)) .) . (,)
01:15:33 <dons> there's a *** in there somwhere :)
01:15:52 <quicksilver> :t (***)
01:15:54 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
01:15:59 <quicksilver> *** is specialised for 2-tuples, I think
01:16:08 <dons> somethig like (id *** h) ((x,y), z)
01:16:17 <dons> quite so
01:16:17 * quicksilver nods
01:16:38 <quicksilver> but, composing in 2nd or 1st component is fairly easy:
01:16:46 <quicksilver> @pl \x y -> (x, h y)
01:16:47 <lambdabot> (. h) . (,)
01:16:50 <dons> (((,)x), h) (y,z)
01:16:52 <quicksilver> @pl \x y -> (h x, y)
01:16:52 <lambdabot> (,) . h
01:17:10 <quicksilver> seems strange that composing it third is so much worse
01:17:19 <dons> @pl \x y z -> (((,)x) *** h) (y,z)
01:17:19 <lambdabot> (. (,)) . (.) . (*** h) . (,)
01:17:50 <dons>  @pl doesn't think very hard about non-2-tuples
01:18:01 <Thunder> @unpl (.h)
01:18:01 <lambdabot> (\ a d -> a (h d))
01:19:54 * quicksilver nods
01:20:04 <quicksilver> well it's not only tuples, I was just using a tuple as a concrete example
01:20:12 <quicksilver> @pl \x y z -> f x y (h z)
01:20:13 <lambdabot> flip flip h . ((.) .) . f
01:20:30 <Kaji> Anyone know of an easy way to return Boolean True for all non-zero-length strings?
01:20:39 <quicksilver> Kaji: (not.null)
01:20:43 <dons> not . null
01:20:51 <Kaji> :t null
01:20:53 <lambdabot> forall a. [a] -> Bool
01:20:59 <Kaji> Ah-ha! Thanks!
01:20:59 <dons> > map (not.null) ["","a","abc","adfef"]
01:21:00 <lambdabot>  [False,True,True,True]
01:21:14 <dons> ?src not
01:21:15 <lambdabot> not True   =  False
01:21:15 <lambdabot> not False  =  True
01:21:17 <dons> ?src null
01:21:17 <lambdabot> null []     = True
01:21:18 <lambdabot> null (_:_)  = False
01:21:22 <dons> yeah?
01:21:41 <dons> > map (\x -> case x of [] -> False ; _ -> True) ["","a","abc","adfef"]
01:21:43 <lambdabot>  [False,True,True,True]
01:21:44 <dons> same thing
01:21:59 <dons> yay for structural induction ;)
01:22:08 <Kaji> Wonder if "null" will work on an IO monad...
01:22:12 <Kaji> > null IO
01:22:13 <lambdabot>   Not in scope: data constructor `IO'
01:22:23 <Kaji> null putStrLn "Moo!"
01:22:23 <quicksilver> Kaji: you have an IO String?
01:22:24 <dons> on the result of an IO actoin?
01:22:31 <dons> :t getLine >>= return . null
01:22:33 <lambdabot> IO Bool
01:22:35 <dons> :t getLine >>= return . not . null
01:22:38 <lambdabot> IO Bool
01:22:44 <dons> ?pl getLine >>= return . not . null
01:22:44 <lambdabot> (not . null) `fmap` getLine
01:22:45 <dons> liftM
01:22:53 <quicksilver> :t fmap (not.null) getLine
01:22:55 <lambdabot> IO Bool
01:22:57 <quicksilver> bah I was slower
01:23:30 <quicksilver> although actually many people would probably write something more like do { x <- getLine; if (not . null) x then ... else ... }
01:23:39 <Kaji> I have a function that needs to return a Bool, but also print a string. I'm trying to coerce the IO returned from putStrLn to a true value.
01:23:56 <quicksilver> :t putStrLn
01:23:59 <lambdabot> String -> IO ()
01:24:08 <quicksilver> note that putStrLn does not return the string it printed :)
01:24:12 <quicksilver> it just returns the empty tuple
01:24:30 <quicksilver> :t do { putStrLn "hello Kaji"; return True }
01:24:33 <lambdabot> IO Bool
01:24:53 * Kaji tries to check his understading of IO monad usage... "IO ()" is the IO monad and an empty tuple, am I right?
01:25:28 <quicksilver> IO () is an IO action which, when performed, returns the empty tuple
01:25:31 <mux> not really an empty tuple, we call () 'unit'
01:25:41 <Kaji> Oh, that's the unit function, Okay.
01:25:42 <mux> but I guess it can be seen as such
01:25:54 <mux> it's just nothing anyways :)
01:26:11 <quicksilver> I think 'empty tuple' is reasonable terminology :) It's a value with no information.
01:28:11 * Kaji thinks this is going to be a pastebin thing again, I'm so not getting it...
01:28:27 <quicksilver> :)
01:28:31 <quicksilver> paste away, we're here to help
01:28:40 <quicksilver> @where hpaste
01:28:40 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
01:28:49 <quicksilver> hmphf
01:29:08 <quicksilver> not really the answer I was looking for
01:29:14 <astrolabe> !paste
01:29:14 <hpaste> Haskell paste bin: http://hpaste.org/
01:29:15 <mux> hpaste.org :)
01:29:44 <hpaste>  Kaji pasted "converting IO to Bool" at http://hpaste.org/753
01:30:13 <astrolabe> mux: I think it is deliberatly the same as an empty tuple
01:30:33 <quicksilver> Kaji: has factors is not in the IO monad
01:30:44 <quicksilver> Kaji: so it can't do IO
01:30:54 <Kaji> Shoot.
01:31:00 * Kaji tries to think of another way around...
01:31:35 <Cale> Kaji: how about having it return a list of what it would otherwise output?
01:31:36 <quicksilver> well you could put it in the IO monad, if you really want to
01:31:42 <Cale> Then you can decide how to do the IO later.
01:31:44 <Kaji> :t putStrLn "Foo"
01:31:46 <lambdabot> IO ()
01:31:51 <quicksilver> it looks to me like you're trying to "put in debugging print statements" ?
01:32:09 <sieni> Kaji: the result type should be IO Bool if you want to do IO in the function
01:32:13 * Kaji nods, "Yeah, this is obviously exactly what monads were invented for. I think I should go re-read that paper..."
01:32:16 <Cale> factors :: Integer -> Integer -> Integer -> [Integer]
01:32:39 <quicksilver> Kaji: are those print statements supposed to be for debugging, or are they really part of the result?
01:33:06 <Kaji> For debugging. I'm getting some weird behavior where it's telling me prime numbers have factors. I want to know what it thinks the factors of my prime number are.
01:33:24 <Cale> Still, there's a useful factorisation of your program here :)
01:33:53 <quicksilver> that particular pattern (inserting debugging printfs) doesn't translate terribly well. There *are* ways of doing it with, e.g., writer monads and stuff
01:34:08 <quicksilver> but it's generally easier to pull your program apart into smaller functions (factor it)
01:34:13 <Lemmih> How about using Debug.Trace.trace?
01:34:14 <quicksilver> and test the functions individually in ghci
01:34:16 <Cale> I'd probably go for a version which has result type Maybe Integer, or [Integer]
01:34:26 <Cale> and then write hasFactors in terms of that.
01:34:36 <Kaji> I can certainly return a list of factors as Cale suggests... but then I have to modify the caller of hasFactors to print things out. Seems like I'm not really solving the problem, just moving it.
01:35:38 <Kaji> Maybe putting this guy in the IO monad is the right idea after all...
01:36:47 <notsmack> (it's probably not)
01:37:13 <malcolmw> tracing where wrong result come from sounds like exactly the job for Hat
01:37:27 <Kaji> I've seen some patterns using $ and <- ... something about wrapping a closure around several functions... is that any help here?
01:38:23 <Cale> Kaji: I can see your bug already
01:38:32 <Kaji> Can I do something stupid and confusing like: null c <- { putStrLn (show m) } ?
01:38:40 <Kaji> Cale: Give me a hint...
01:38:44 <Cale> Kaji: You're swapping n and sqrtn
01:38:54 <Cale> on the recursive call
01:39:00 <Kaji> Oh christ... thanks!
01:39:13 <Kaji> What a dumb-ass mistake.
01:39:40 <Kaji> I must have screwed that up recently. This code worked as little as two days ago.
01:39:44 <hpaste>  Cale annotated "converting IO to Bool" with "refactor" at http://hpaste.org/753#a1
01:40:22 <Cale> It manages to find 29 as a supposed divisor of 59, which is false.
01:40:58 <narain> is there an easy way to read from IO word by word?
01:41:20 <Cale> interact (f . words)
01:41:36 * Kaji thinks you're going to have to read a whole line and cut it up into words... what Cale said.
01:41:40 <Cale> Or  x <- fmap words getContents
01:41:58 <Cale> (in a do-block)
01:42:16 <narain> well i just realized i could actually work with that for what i need to do
01:42:30 <narain> but it wouldnt work if i needed to read exactly n words
01:42:35 <Cale> hm?
01:42:36 <Cale> why?
01:42:36 <narain> and then read the rest line by line say?
01:42:41 <Cale> take n x
01:42:52 <narain> sorry, hadnt finished my sentence
01:42:53 <Cale> oh
01:43:03 <Cale> then you should break things up by line first, and then by words
01:44:09 <narain> yes, that's kind of messy though
01:44:21 <narain> ...or maybe not
01:44:30 <malcolmw> do { xs <- fmap words getContents; let begin = take n xs; let end = unwords (drop n xs); ... }
01:44:58 <Cale> malcolmw: words destroys information about newlines though, doesn't it?
01:45:29 <malcolmw> Cale: oh, yeah, you're right
01:45:38 <narain> well, i guess it's time for me to think about it a bit more rather than bothering everybody here
01:45:39 <Cale> > unwords . words $ "a\nb\nc"
01:45:40 <lambdabot>  "a b c"
01:45:50 <Cale> > lines "a\nb\nc"
01:45:52 <lambdabot>  ["a","b","c"]
01:45:57 <Cale> > lines "a b\nc\nd"
01:45:59 <lambdabot>  ["a b","c","d"]
01:46:01 <narain> because i just realized that interact & words might just work fine
01:46:04 <Cale> > map words . lines $ "a b\nc\nd"
01:46:06 <lambdabot>  [["a","b"],["c"],["d"]]
01:57:57 <Kaji> :t $ "a b c"
01:57:59 <lambdabot> parse error on input `$'
01:58:13 <malcolmw> do { xs <- fmap (map words . lines) getContents; let begin = take n (concat xs); let end = (map unwords) (drop n (concat xs));
01:58:17 * Kaji chuckles, so much to learn, so little clue...
01:58:56 <quicksilver> Kaji: $ is just function application
01:59:04 <quicksilver> Kaji: f $ "a b c" is a funny way to write f "a b c"
01:59:25 <quicksilver> Kaji: the reason people use it is (a) different precedence and (b) can take sections of it
01:59:33 <Kaji> Huh. Is there a benefit in terms of precedence? Does it insure a function gets applied or something... ah, right. Thanks!
01:59:51 <Kaji> "ensure" even...
02:00:13 <Kaji> Oh, I have another stupid syntax question... about pattern matching.
02:00:17 <Kaji> You often see code like:
02:00:34 <Kaji> myFunc = myFunc [] = 0
02:00:50 <Kaji> myFunc (x:xs) = 1 + myFunc xs
02:00:58 <Kaji> Not sure if I got the syntax right, but I trust the intent is clear.
02:01:33 <Kaji> My question is, why do you use parens with the (x:xs) bit? It makes it look like a tuple, when in fact you're probably dealing with a list?
02:01:45 <Kaji> Or are lists really tuples underneath?
02:02:40 <quicksilver> because, if you didn't use parens
02:02:44 <quicksilver> it would mean this:
02:02:51 <quicksilver> (myFunc x) : xs
02:02:55 * Kaji was thinking the second pattern might make more sense as "myFunc x:[xs] = etc"
02:03:13 <quicksilver> [which would in turn be illegal, because myFunc isn't a constructor)
02:03:22 <Kaji> Since x:[xs] is more like 5:[4, 3, 2, 1]
02:03:39 <quicksilver> ah, but xs is a single value
02:03:48 <quicksilver> x:[xs] *is* a valid pattern
02:03:53 <quicksilver> but it only matches two-element lists
02:03:56 <DynWind> a patter like x:[xs] would match 1:[[2,3]]
02:04:10 <DynWind> (for example)
02:04:16 <quicksilver> well, or more simply 1:[2]
02:04:20 <DynWind> yeah
02:04:22 <Kaji> Oh, the brackets are implied around the thing after the colon. Okay.
02:04:29 <quicksilver> Kaji: no, wrong :)
02:04:39 * Kaji laughs, "I am so clueless."
02:04:48 <quicksilver> the thing is that [1,2,3,4] is a special notation
02:04:54 <quicksilver> that's the key point, I suppose
02:04:58 <quicksilver> it's not regular
02:05:05 <quicksilver> the regular form is 1:2:3:4:[]
02:05:09 <DynWind> [1,2,3] is shorthand for 1:2:3:[]
02:05:13 <quicksilver> [1,2,3,4] is just a convenient syntactic sugar
02:05:16 <Kaji> Okay... now I understand.
02:07:20 <Kaji> I guess I need to understand (x:xs) as something along the lines of "(head x : tail x)"
02:07:29 <quicksilver> hmm
02:07:33 <quicksilver> yes, you could
02:07:37 <Kaji> From my brief forays into scheme, I understand that "tail x" is a full list.
02:07:40 <dons> > (:) 1 [2,3,4]
02:07:41 <lambdabot>  [1,2,3,4]
02:07:50 <quicksilver> it would be better to understand list as a recursive data type
02:08:04 <quicksilver> data List a = Nil | Cons a (List a)
02:08:07 <dons> ?src []
02:08:08 <lambdabot> data [] a = [] | a : [a]
02:08:20 <quicksilver> A list is either empty, or a 'cons' of a head element, and another list (the tail)
02:08:25 <quicksilver> but in haskell we write [] for Nil
02:08:28 <quicksilver> and (:) for Cons
02:08:39 <quicksilver> and [a] for List a
02:08:47 * Kaji nods, the analogy to Scheme/Lisp is pretty obvious on the first two there.
02:08:48 <quicksilver> finally, (:) is allowed to be written infix
02:09:00 <quicksilver> which takes you all the way to the notation in lambdabot's answer
02:09:17 <quicksilver> one confusing thing (IMO) is that [] is used both for values and for types
02:09:25 <quicksilver> and slightly inconsistent syntax
02:09:42 <quicksilver> [a] means 'a list with one item, a' if a is a *value*
02:09:55 <quicksilver> but it means 'the type of lists with items of type a' if a is a *type*
02:10:01 <dons> though once you've used it, the value/type syntax becomes quite intuitive
02:10:08 <dons> > (1,'x') :: (Int,Char)
02:10:09 <quicksilver> true, it's convenient, and concise
02:10:10 <lambdabot>  (1,'x')
02:10:24 <dons> no need for funny synonyms like ML
02:11:02 <dons> and of course, with so much programming on the type level now, its good to have syntax :-)
02:11:05 <Kaji> The value/type distinction doesn't bug me so much, I guess because imperative code sort of does the same thing. We say "i is an int" even though i's value is 7.
02:11:55 <Kaji> I think it's using [] to mean Nil that gets me.
02:13:55 <DynWind> it's just like '() in Scheme
02:14:15 <Kaji> And if I can think of it that way, I think my confusion will evaporate.
02:16:08 <narain> Kaji: Nil == empty list == []
02:16:11 <narain> what's not to like? :)
02:16:38 <Kaji> I like the convenience and the clean look of it... I just need to wire my head properly to understand the correct meaning of [].
02:17:14 <alxb> hi, is there a way to benchmark a function?
02:17:39 <Kaji> In terms of time, you can do ":set +t" before you run the function.
02:18:03 <Kaji> Well, most people can. It doesn't work for me under Win98 SE for some reason, neither HUGS or GHCI will do it right.
02:18:27 <alxb> and what about memory
02:18:29 <alxb> ?
02:18:51 * Kaji looks around, "Out of my league there... anyone?"
02:19:04 <DynWind> :set +s
02:19:27 <DynWind> though you might want a more sophisticated profiler to actually do optimizations
02:19:34 <alxb> and after the function?
02:20:22 <Kaji> Are you doing this interactive, or writing code to be compiled to do it?
02:20:29 <Kaji> :set +s will only work interactive.
02:21:31 <alxb> oh, thant won't work for me because I have to compute my function lots of times
02:21:41 <alxb> get min, max and avg time
02:22:00 <Kaji> Someone gave me a web page that showed a non-interactive way to do it, let me see if I can find it again...
02:22:36 <alxb> thanks
02:23:14 <Kaji> http://www.haskell.org/haskellwiki/Timing_computations
02:23:15 <lambdabot> Title: Timing computations - HaskellWiki
02:23:22 <Kaji> Looks like there's a similar page at
02:23:57 <Kaji> Oh, no, I'm wrong. The other one is about how to implement IO timeouts via System.CPUTime.
02:24:23 <alxb> great, lemme give it a try
02:25:58 * Kaji ponders "v <- a" ... makes a closure named v around a ... does that guarantee that a gets run?
02:26:28 <narain> woohoo! i just got my first largish Haskell program to compile without type errors
02:26:36 <Kaji> Okay, ten minutes for "isPrime 21167397384723757
02:27:01 <Kaji> That makes GHCI slightly more than an order of magnitude faster than HUGS on my particular code.
02:27:31 <quicksilver> Kaji: no, v <- a doesn't guarantee that a gets run, in general
02:27:45 * Kaji puts the bullet in this @#$% Newton-Rapheson root estimation crap and goes to write the Seive of Erastosthenes... this shouldn't take long.
02:27:47 <quicksilver> Kaji: in the IO monad in particular it does, though. At least for a weak definition of 'run'
02:28:10 <solcom> how does map.map work in haskell? im struggling to get my head around it
02:28:23 <Kaji> Ah, very interesting. And since this "time" function that the "v <- a" code is inside does return "IO t"...
02:28:23 <quicksilver> :t map
02:28:26 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:28:37 <quicksilver> map takes a function, and returns a 'list function'
02:28:45 <Cale> map :: (a -> b) -> ([a] -> [b])
02:28:46 <quicksilver> then when you compose that with another copy of map
02:28:55 <quicksilver> that takes a 'list function' and returns a 'list list function'
02:28:57 <quicksilver> speaking loosely
02:29:01 <quicksilver> solcom: doest that help?
02:29:07 <Kaji> Hehehe.
02:29:16 <Cale> :t map . map
02:29:19 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
02:29:27 <narain> it also makes sense if you try to derive what a map for lists of list would be
02:29:48 <narain> map2 f l = map (map f) l
02:30:00 <narain> map2 f = map (map f) = (map . map) f
02:30:03 <narain> map2 = map . map
02:30:57 <Cale> :)
02:31:05 <osfameron> function composition hurts my brane
02:31:06 <Cale> @pl \f l -> map (map f) l
02:31:07 <lambdabot> map . map
02:31:31 <solcom> yeah that kinda helps, im more confused how it takes only one function for the inner one
02:31:39 <solcom> eg map(map function) list
02:31:41 <Kaji> :t map
02:31:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:31:51 <Cale> solcom: perhaps you're confused by partial application?
02:32:05 <Cale> solcom: Every function in Haskell is really a function of one parameter.
02:32:29 <xpika_> > ((+2).(+1)) 0
02:32:30 <lambdabot>  3
02:32:33 <Cale> Functions of multiple parameters take the first parameter and return a function which will take the rest.
02:32:45 <quicksilver> as Cale said earlier you can read that type as "(a->b)   ->   ([a]->[b])
02:32:55 <narain> :t (+1)
02:32:58 <lambdabot> forall a. (Num a) => a -> a
02:33:19 <osfameron> why is that "forall"?  I thought forall was a looping type?
02:33:19 <vincenz> Anyone know how to still have scroll fucntionality within a screen session?
02:33:19 <Cale> :t let add x y = x + y in add 5
02:33:22 <lambdabot> forall t. (Num t) => t -> t
02:33:35 <osfameron> vincenz: C-a <ESC> sort of does it
02:33:42 <vincenz> osfameron: thx
02:33:53 <solcom> ahh rite yeah that kinda helps
02:34:06 <osfameron> vincenz: it puts you in "copy/paste" mode.  There's apparently a better mapping for PgUp/PgDn, but I've never worked it out... let me know if you do!
02:34:09 <Cale> osfameron: forall is just quantifying the type variable explicitly -- you'd read it as "for all types a,..."
02:34:11 <solcom> is there anythign else i could use instead of map.map?
02:34:29 <Ulfalizer> solcom: a nice way to think of partial application is that all functions in reality take exactly 1 argument. functions that seem to take more arguments simply take 1 argument and return a function whose first argument is the next argument, and so on, till all arguments have been covered.
02:34:32 <Cale> solcom: nothing simpler
02:34:33 <osfameron> Cale: but aren't lower-case types already polymorphic ?
02:34:55 <Cale> osfameron: yes, it's just making that explicit because -fglasgow-exts is turned on.
02:35:08 <osfameron> ah! ok
02:35:21 <Cale> There's an implicit forall on all type variables in Haskell 98.
02:35:42 <Cale> (You can't even write the forall yourself)
02:35:44 <LPhas> can someone suggest me a convenient way to rappresent the directed acyclic graph of the dependencies of a module?
02:35:54 <Cale> But GHC lets you put it in explicitly.
02:36:08 <Kaji> Classic DAG representation is a matrix...
02:36:13 <Ulfalizer> solcom: instead of  (map . map)  you could write  (map (map fn)). the inner (map fn) is a function which will take a list and map fn over it. the outer map then maps this list-transforming function over a list, thus transforming all the sublists.
02:36:19 <Kaji> Or an edge list.
02:36:49 <Kaji> You could make a list of lists. Edges from vertex 1 to 7 and 3 to 5 would be [[1,7], [3,5]]
02:36:51 <solcom> ah cheers ulfalizer, i get it now
02:36:59 <Ulfalizer> solcom: no problem :)
02:37:15 <xpika_> @src (.)
02:37:15 <lambdabot> (.) f g x = f (g x)
02:37:35 <Botje> LPhas: have you looked at Data.Graph.Inductive ?
02:38:01 <xpika_> ie (.) map map x = map (map x)
02:43:51 * Thunder suddently understands the pointfree construct (.h)
02:45:45 <quicksilver> :t \f h -> (.h) . f
02:45:48 <lambdabot> forall b c a a1. (a1 -> b -> c) -> (a -> b) -> a1 -> a -> c
02:46:09 <vincenz> :t \f -> (ap . ap (return (:)) . f) (return [])
02:46:11 <lambdabot> forall a (m :: * -> *) a1 (m1 :: * -> *). (Monad m, Monad m1) => (m1 [a1] -> m a) -> m [a] -> m [a]
02:46:17 <quicksilver> "precompose on second parameter" :)
02:46:49 <quicksilver> > ((.(+1)) . (,)) 4 10
02:46:50 <lambdabot>  (4,11)
02:47:56 <narain> @pl \f h x y -> f (h x) y
02:47:57 <lambdabot> (.)
02:48:35 <vincenz> :t \f -> ( ap (return (:)) . f) (return [])
02:48:38 <lambdabot> forall a (m :: * -> *) a1 (m1 :: * -> *). (Monad m, Monad m1) => (m1 [a1] -> m a) -> m ([a] -> [a])
02:48:51 <narain> how come "precompose on first parameter" is simply  f . h  but "precompose on second parameter" is the convoluted  (. h) . f  ?
02:49:07 <vincenz> oh duh
02:49:21 <vincenz> :t \f -> foldr (ap . ap (return (:)) . f) (return [])
02:49:24 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a -> m a1) -> [a] -> m [a1]
02:49:36 * dcoutts notes that there have bee 73 download of Gtk2Hs-0.9.11 in ~3 days since it was announced
02:50:36 * narain wonders what "precompose on third parameter" looks like
02:50:44 <narain> @pl \f h x y z -> f x y (h z)
02:50:45 <lambdabot> flip . ((flip . ((.) .)) .)
02:50:56 <narain> @pl \f h x y -> f x (h y)
02:50:56 <lambdabot> flip . ((.) .)
02:51:04 <narain> never mind.
02:54:22 <vincenz> @sseen bringer
02:54:23 <vincenz> [At
02:54:23 <lambdabot> I haven't seen bringer.
02:54:37 <vincenz> @seen bringert -- ARGH LAG
02:54:38 <lambdabot> I saw bringert leaving #haskell 1d 2h 7m 58s ago, and .
02:55:47 <solcom> what exactly does a stack overflow error mean?
02:56:17 <narain> it usually means your recursion went out of control
02:56:45 <Kaji> :t length
02:56:47 <lambdabot> forall a. [a] -> Int
02:57:04 <Ulfalizer> solcom: data such as arguments and where to return is saved on the stack, so in case of an infinite recursion you often run out of stack sapce
02:57:08 <Ulfalizer> *space
02:57:48 <solcom> ahk cheers
02:59:51 <Kaji> :t (7 `mod`)
02:59:51 <lambdabot> forall t. (Integral t) => t -> t
03:02:30 <Kaji> :t zip
03:02:32 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
03:02:45 <Kaji> :t null
03:02:47 <lambdabot> forall a. [a] -> Bool
03:03:27 <Kaji> :t filter
03:03:29 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
03:04:30 <notsmack> wow, trac ticket spam.  that's something i hadn't seen before.
03:04:51 <notsmack> http://hackage.haskell.org/trac/summer-of-code/ticket/1073
03:04:53 <lambdabot> Title: #1073 (college girls naked) - Haskell.org Google Summer of Code - Trac
03:05:08 <Kaji> Hahaha.
03:05:18 <Kaji> Wow man, these Google SoC parties must be pretty wild.
03:05:33 <quicksilver> nah, it's only a project *idea*
03:05:41 <quicksilver> they have no real way of implementing it
03:05:42 <Ulfalizer> i got one about a "chick pumping gas naked"
03:06:25 <Botje> where'd she put her card, then?
03:06:35 <narain> apparently it's going to take 3 people 4 weeks to get college girls naked
03:06:46 <Kaji> Well, they ARE probably CS majors. ;D
03:06:48 <Ulfalizer> you don't want to know :/
03:07:41 <quicksilver> it'll take them 4 weeks to try
03:07:45 <quicksilver> they won't succeed
03:07:51 <quicksilver> as Kaji points out, they're CS majors
03:08:11 <Kaji> (I can make fun of CS majors because I was one. I'm really self-bashing, you see...)
03:08:29 <quicksilver> I can make fun of CS majors because I taught them. I know whereof I spea.
03:08:30 <quicksilver> k.
03:08:42 <dcoutts> tarantoga, ping, I've found more detail on the bug you found
05:21:07 --- topic: '["The Haskell programming language: tip over the vending machine!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
05:21:07 --- topic: set by dons on [Fri Feb 23 19:32:08 2007]
05:21:07 --- names: list (clog ddarius MarcWebe1 mutanton jberg yip Return2Zero Ulfalizer nominolo uebayasi jrib goban bluestorm emk russo beelsebob_ pejo mkhl diffbavis caustiq moonlite huschi chris2 |newbie| ikaros kombinator wilx Averell ji-heitch Tychom Stinger malcolmw ski solcom noj Eighty ksandstr mux genneth LPhas miez roconnor JaffaCake Cheery cptchaos matthew_- Thunder mauke Procyon_ amiddelk vstranger gh_ nornagon erider _giksos_ dporter TSC Eidolos)
05:21:07 --- names: list (Jaak dgoldsmith tizoc luka mbishop rashakil Knio GeoBes1 glguy noclouds pstickne Lunar^ Khisanth largos Ytinasni Gwern Pupeno5 lupo__ user317 bohanlon Lemmih augustss Japsu MikeJS__ sad0ur __xs__ neonse ment flux- PupenoR kpreid slipstream-- jgrimes JohnMeacham takuan jbalint perspectival ClaudiusMaximus mr_ank oklofok gigamonkey Poeir arjanoosting therp bdash mathrick_ rufius thedatabase eretan cpfr araujo TomMD thedward_ Lamperi Altair^)
05:21:07 --- names: list (arcatan orbitz rahikkala ttmrichter tarantoga hpaste Shimei ohmega bd_ ozone saccade xinming_ tessier_ Vq^ liyang GeoBesh ski_ xerox dgriffi3 bryanl levitation[A] ADEpt Korollary michaelw integral allbery_b notsmack jcreigh Baughn hyrax42 Narrenschiff dufflebunk encryptio Slarba eno Xgc dblog lordl Daveman nothingmuch progexp206196 nich_ gaal nnunley df__ yosemite Codex_ znephf jmob SimonRC dons Boney resiak jer Nioate jdev SamB tessier)
05:21:07 --- names: list (svens dfranke Adamant atsampson vincenz xian nattfodd audreyt kosmikus cjay quicksilver david_ gabor muddybike gds dibblego quetzal nrb23 NichardRixon lambdabot Laney cmeme LoganCapaldo greenrd fnordus DynWind felipe rycee Tigge Yamaoka hefner dcoutts mlh cods newsham osfameron ctkrohn dino- kaol petekaz Saizan woggle Kattana Cale cameron Botje @ChanServ kirkeby ray Mitar edwinb Odd_Bloke sjanssen robreim mornfall norpan delamon Shoragan)
05:21:07 --- names: list (arasinen eyck AvengerX profmakx _jcrigby boulez qwr dany2k bolrod matthew-_ mightybyte aking ketil_ dylan astrolabe earthy ricebowl Eelis Hirvinen MarcWeber mattam Ugarte benja_ kfish lispy kolmodin ohub tero- Nafai rafl ibid falconair_ dinounix magagr lucca musasabi kalven mahogny Wallbraker kc5tja dropdrive sabakas1 Lunchy ludwig- kpk rey_ yogan psnl arcasin Spark sieni wolverian mattiast gdsx opqdonut dcoutts_ tuukkah Igloo bhall tWip)
05:21:07 --- names: list (Syzygy- scw emu Philippa kzm)
05:21:30 <benja_> vincenz: yep
05:22:00 <benja_> ...and just one month until it's officially released and I can upgrade my whole system to it, too =)
05:23:36 <benja_> (looks) hrm, April 19th -- 1.5 months actually :-/
05:25:00 <vincenz> benja_: well sorta busy with stuff so I'd rather not risk it now :)
05:25:05 <vincenz> but cool to know
05:26:31 <benja_> =)
05:28:50 <vincenz> Eurgh, phantomtypes with GADTs are annoying
05:29:38 <vincenz> thank god for undeined :)
05:32:03 <pxfont> is IORef safe until when use unsafePerformIO?
05:32:07 <pxfont> i.e. safe on the top level?
05:33:21 <Eighty> pxfont: i asked that question here just like one hour ago
05:33:23 <Eighty> apparently, yes.
05:33:53 <quicksilver> IORefs are totally safe, yes
05:34:03 <quicksilver> although it's still preferable to avoid them
05:34:13 <quicksilver> (since they force code into the IO monad which has nothing to do with IO)
05:34:44 <pxfont> thanks for that
06:06:28 <earthy> ummm... is there any way to get at the Visual Haskell source codes other than installing Visual Haskell itself?
06:24:30 <vincenz> :t unzip
06:24:32 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
06:33:35 <solcom> is there anyway to tell haskell that i am definitly passing an int rather than a floating int when trying to do a square route because all the numbers will return whole numbers?
06:34:16 <quicksilver> no, because it can't check that
06:34:26 <quicksilver> :t sqrt
06:34:36 <lambdabot> forall a. (Floating a) => a -> a
06:34:55 <quicksilver> you can't pass an Int to sqrt, in fact
06:35:04 <solcom> ah nevermind
06:35:05 <quicksilver> what you certainly can do is round it to an int afterwards, though
06:35:12 <quicksilver> :t round.sqrt
06:35:14 <lambdabot> forall b a. (RealFrac a, Integral b, Floating a) => a -> b
06:35:30 <solcom> ah rite cheers
06:35:35 <quicksilver> and possibly take it from an integer on the way
06:35:42 <quicksilver> :t round.sqrt.fromIntegral
06:35:44 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
06:36:14 <quicksilver> > round.sqrt.fromIntegral 25
06:36:16 <lambdabot>   add an instance declaration for (Num (a -> b))
06:36:20 <quicksilver> > round.sqrt.fromIntegral $ 25
06:36:22 <lambdabot>  5
06:37:01 <vincenz> WOOT
06:37:07 <vincenz> ghc-6.6:     My brain just exploded.
06:37:15 <vincenz>     My brain just exploded.
06:37:16 <vincenz>     I can't handle pattern bindings for existentially-quantified constructors.
06:37:59 <vincenz> \o/
06:38:01 <vincenz> Yay for breaking ghc
06:40:35 <hpaste>  vincenz pasted "what does this mean/" at http://hpaste.org/755
06:40:40 <vincenz> http://hpaste.org/755
06:41:37 <vincenz> Is it me or is GADT support in 6.6 seriously lacking?
06:41:49 <quicksilver> interface file compiled by different compiler version, perhaps?
06:43:36 <vincenz> nope
06:46:49 <ttmrichter> One question which has been bugging me for some time: why is there both "let" and "where" syntax in Haskell?  Where would I choose the one over the other?
06:48:11 <vincenz> ttmrichter: personal preference, I think where is cleaner in general
06:48:16 <Saizan> where works at the definition level, let .. in is an expression instead
06:48:17 <vincenz> ttmrichter: but let is allowed as a moandic statement
06:49:07 <quicksilver> where scopes over guards, which let can't for simple syntactic reasons
06:49:28 <ttmrichter> OK, so what's the general pundit's view of which should be used when?  Let in monadic code and where elsewhere?  What does let provide, as an expression, that I can't do with where or vice versa?
06:49:37 <quicksilver> I prefer let
06:49:49 <quicksilver> because I prefer to give intermediate values up front, than behind
06:50:01 <quicksilver> but sometimes, if I don't care about them so much, I use where
06:50:02 <Saizan> for example you can use let in a lambda abstraction
06:50:04 <quicksilver> so they come behind :)
06:50:53 <earthy> the rationale I have for use of 'where' is when the naming makes it mostly clear what's happening when reading the function
06:51:00 <earthy> if it doesn't, then I use let
06:51:09 <earthy> because in that case the naming needs to be specified up front
06:51:11 <Saizan> > (\x -> let x2 = 2*x in x2*x2) -- you can't use where here
06:51:12 <lambdabot>  <Integer -> Integer>
06:51:21 <Saizan> > (\x -> let x2 = 2*x in x2*x2) 1
06:51:22 <lambdabot>  4
06:51:46 <earthy> > (\x -> x2 * x2 where x2 = 2 * x) 2
06:51:47 <lambdabot>  Parse error
06:51:50 <earthy> hm. indeed.
06:53:16 <quicksilver> >  (\x -> let x2 = f where f=2*x in x2*x2) 1
06:53:17 <lambdabot>  4
06:53:21 <quicksilver> just to be perverse :P
06:54:21 <Saizan> heh :D
06:57:12 <ttmrichter> OK, thanks.  That actually clears things up for me.
06:57:23 <ttmrichter> I'd use let most often because it "front-loads" my definitions.
06:57:31 <chessguy> g'morning, haskellers
06:57:46 <ttmrichter> I'd use where in cases where perhaps the finicky definitions would interfere with understanding the logic, and rely on a good name instead?
06:58:01 <quicksilver> ttmrichter: that sounds about right
06:58:07 <quicksilver> ttmrichter: just like if you were writing prose
06:58:23 <quicksilver> ttmrichter: you make a choice between defining terms up-front, and giving an overview followed by defining terms later
06:59:01 <chessguy> TMTOWTDI
06:59:13 <chessguy> @vera TMTOWTDI
06:59:15 <ttmrichter> Which means what, chessguy?
06:59:16 <lambdabot> *** "tmtowtdi" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
06:59:16 <lambdabot> TMTOWTDI
06:59:16 <lambdabot>      There's More Than One Way To Do It (slang, PERL)
06:59:16 <lambdabot>  
06:59:27 <chessguy> woohoo
06:59:42 <ttmrichter> OK, lambdabot's beginning to frighten me.
06:59:57 <chessguy> @quote fear
06:59:57 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
06:59:59 <ttmrichter> @vera DRY
07:00:00 <lambdabot> No match for "DRY".
07:00:05 <chessguy> @quote afraid
07:00:05 <lambdabot> JaffaCake says: I'm afraid I'm completely IA64-ignorant (and hoping to remain that way until IA64 goes away :-)
07:00:06 <ttmrichter> Bah!
07:00:18 <ttmrichter> No quote for "Don't Repeat Yourself"?
07:00:25 <araujo> morning
07:00:28 <ttmrichter> How do I add to lambdabot's knowledge base there.
07:00:35 <chessguy> hola araujo!
07:00:43 <chessguy> ttmrichter, don't think you can add to vera
07:00:45 <araujo> hola chessguy !
07:00:47 <araujo> :-)
07:01:46 <chessguy> que hay?
07:01:57 <quicksilver> So Miranda had no IO features at all?
07:02:05 <araujo> chessguy, nothing much, just woke up :-)
07:02:21 <quicksilver> they just expected you to call the miranda runner to evaluate expressions in, e.g., a shell pipeline?
07:04:05 <ttmrichter> quicksilver, That's what I seem to read into it.
07:04:19 <ttmrichter> I think that's why monads were such an important discovery.  ;)
07:11:50 <ttmrichter> Another silly question: is there any batch of literate programming tools that do full-literate instead of semi-literate style?
07:12:30 <norpan> what is what?
07:13:03 <a-priori_> you can use some language-agnostic literate programming tool... maybe noweb or nuweb?
07:13:19 <a-priori_> I only do literate programming in C, so I don't know about tools other than cweb
07:14:09 <ttmrichter> Noweb/nuweb/et al don't give you some of the features that would be nice in a custom tool like pretty-printed source and tagging and indexing and the like.
07:14:36 <ttmrichter> I wonder if you couldn't supplement them in some way with the various pretty-printing tools available, though.
07:14:41 <a-priori_> do any of them allow you to customize the pretty-printing?
07:15:04 <a-priori_> through external tools, etc.
07:17:23 <chessguy> ?src State
07:17:23 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:17:32 <chessguy> ?src Control.Monad.State
07:17:33 <lambdabot> Source not found. You type like i drive.
07:17:40 * chessguy kicks lambdabot 
07:17:45 <emk> ttmrichter: I've been quite happy with lhs2TeX's polycode modes.
07:18:08 <kombinator> dcoutts_: hello
07:18:15 <ttmrichter> I've never managed to get lhs2TeX to produce anything intelligible in output.
07:18:34 <dcoutts_> kombinator, g'afternoon
07:19:09 <earthy> ttmrichter: not?
07:19:13 <earthy> that's odd
07:19:16 <emk> ttmrichter: Hmm. I think you might be able to use "Typing Haskell in Haskell" as a starting point, if it's just a matter of getting past the errors.
07:19:55 <kombinator> dcoutts_: I have just started to look at TextBuffer and it seems that I can track changes using onBufferInsertText but there is nothing like stopInsertText for it
07:19:59 <emk> I've gotten some very "math-like" code out of lhs2TeX, with all kinds of custom operators and notations.
07:20:19 <dcoutts_> kombinator, stop? I don't know what you mean
07:20:21 <cperfumo> does anybody work with ConjureÂ¿?
07:20:31 <ttmrichter> Gotta run.  Closing in on midnight here.
07:20:36 <kombinator> dcoutts_: I want to have complete control over what end up in the TextView
07:21:37 <quicksilver> audreyt: ping
07:22:10 <kombinator> dcoutts_: if you look at the example at the end of Entry.Entry doc page, there is a call to stopInsertText to suppress automatic updating of entry
07:22:39 <kombinator> dcoutts_: I have to use it if I want to override the inserting action
07:22:42 * dcoutts_ reads the docs
07:23:29 <dcoutts_> kombinator, where is that stopInsertText in the example? I'm looking at the GtkEditable interface example.
07:24:11 <dino-> Can anyone here help with some HXT and arrow problems I'm having?
07:24:11 <kombinator> dcoutts_: oh, yes, right
07:24:37 <dcoutts_> kombinator, ok, so that example is just stopping emission of a signal
07:25:07 <kombinator> dcoutts_: not only, then it calls stopInsertText id
07:25:45 <kombinator> dcoutts_: which is important because otherwise the entered text will be automatically inserted
07:27:27 <dcoutts_> kombinator, I don't see the code you're looking at
07:27:52 <kombinator> dcoutts_: what do I use for paste?
07:27:55 <kombinator> @paste
07:27:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:29:35 <hpaste>  kombinator pasted "gtk2hs, stopEnteredText" at http://hpaste.org/756
07:29:59 <dcoutts_> kombinator, so the C docs for the "insert-text" signal say that insertion actually happens in the default signal handler, so if we stop the emission then no text will be inserted.
07:30:37 <kombinator> dcoutts_: yes, it works like that, but I would like it to work for TextBuffer, does it?
07:30:51 <dcoutts_> kombinator, so stopInsertText is just signalStopEmission obj "insert_text"
07:31:13 <dcoutts_> kombinator, so we can do that on the insert-text signal on the TextBuffer too
07:31:14 <kombinator> dcoutts_: it is defined in Entry.Editable, so I'm not sure if it works for TextBuffer
07:31:39 <dcoutts_> kombinator, no, that one is specific to Editable, but the underlying implementation in terms of signalStopEmission is generic
07:32:19 <dcoutts_> kombinator, you'll notice in the C docs for the GtkEntry example it uses g_signal_stop_emission
07:32:32 <dcoutts_> erm GtkEditable example, which does the upper case thing
07:33:00 <kombinator> ok, I'll look at the internals of Gtk2Hs
07:34:29 <dcoutts_> kombinator, signalStopEmission is exported by System.Glib.Signals
07:34:36 <dcoutts_> signalStopEmission :: GObjectClass obj => obj -> SignalName -> IO ()
07:34:59 <dcoutts_> kombinator, yeah, it's rather internal looking, sorry about that. We've not used it much so not made a nice api for it.
07:35:37 <dcoutts_> kombinator, so currently it takes a signal by name, ie a string. Our signal revamp will allow it to take the signal as an opaque value.
07:36:13 <kombinator> dcoutts_: but I will have to recompile gtk2hs in order to use it (I'll have to add sth?)?
07:37:54 <dcoutts_> kombinator, no, just import System.Glib.Signals
07:38:16 <audreyt> quicksilver: pong
07:38:33 <kombinator> dcoutts_: oh, that's nice!
07:38:48 <dcoutts_> kombinator, and then use: signalStopEmission buffer "insert-text"
07:39:12 <quicksilver> audreyt: http://www.imperialviolet.org/binary/bitsyntax/
07:39:17 <quicksilver> audreyt: lazily-unpacked bitfields :)
07:40:26 <kombinator> dcoutts_: that's quite different from what happens for Editable, because stopInsertText takes callback id as an argument
07:40:27 <audreyt> quicksilver: ooh!
07:40:47 <kombinator> dcoutts_: but if it will work, that's absolutely ok with me!
07:41:02 <dcoutts_> kombinator, that was an attempt at a higher level api, but only for that once case, and only because someone asked for something similar previously, so we hacked it in.
07:41:31 <dcoutts_> kombinator, if you look at the code for stopInsertText it just takes the object out of the callback and calls signalStopEmission
07:54:39 <notsmack> Prelude> :m + Graphics.GD
07:54:39 <notsmack> module main:Graphics.GD is not loaded
07:54:45 <notsmack> what does that mean?
07:55:38 <yip> try it without the space between the + and G
07:55:52 <notsmack> same
07:56:51 <notsmack> hm, works in a couple of my bash instances, must be some environment thing
08:11:19 <araujo> hi CosmicRay
08:11:28 <CosmicRay> morning araujo
08:11:32 <araujo> :-)
08:12:03 * araujo will give a talk about OOP and he is trying to see where/how to mention Haskell
08:12:29 <quicksilver> renamed the talk to 'why OOP is a poor idea' and conclude with a slide saying 'use haskell instead'
08:12:41 <CosmicRay> heh
08:12:48 <Syzygy-> Hehe
08:12:51 <ndm> @seen dcoutts
08:12:51 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 4h 40m 22s ago.
08:13:00 <matthew_-> just start talking about how bad shared mutable state is and that'll lead you on to Erlang and then you might be able to slide haskell in there too
08:13:01 <CosmicRay> araujo: it probably wouldn't hurt to mention that oop is not the only paradigm
08:13:20 <CosmicRay> araujo: is this something for undergrad CS students?
08:13:27 <araujo> yes CosmicRay
08:13:36 <araujo> quicksilver, i would like to do  that for sure :-)
08:13:49 * araujo but probably can't
08:14:03 <quicksilver> the good things about OOP are encapsulation and abstraction
08:14:05 <CosmicRay> araujo: "when you get to be seniors, we'll show you why Haskell makes all this OOP stuff look obsolete" ;-)
08:14:11 <araujo> hahaha
08:14:22 <quicksilver> languages like haskell have a wider selection of abstraction techniques than languages like C++/Java
08:14:24 <araujo> CosmicRay, i can say that at the end ;-)
08:15:05 <tarantoga> dcoutts_: hey, good news!  works now, thank you very much
08:15:09 <matthew_-> quicksilver: I agree. I actually think that oop is a leaky abstraction from the ground up.
08:15:13 <araujo> I am going to talk about abstract data types. So i was thinking to mention that other languages implement sch a abstractions too.
08:15:27 <araujo> Haskell in this case.
08:15:55 <quicksilver> matthew_-: I think that's a 'morally right' but rather imprecise statement
08:16:01 <quicksilver> matthew_-: oop isn't "an abstraction"
08:16:18 <quicksilver> matthew_-: it's a programming methodology which relates a set of characteristic abstraction techniques
08:16:30 <matthew_-> yep. and I think they're fundamentally flawed
08:16:33 <quicksilver> some of those abstractions are good, some less so
08:16:44 <araujo> @where oohaskell
08:16:44 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
08:17:25 <matthew_-> I think that as soon as you realise you need something like AOP, you know that you've got more problems than a little refactoring can solve
08:19:11 <dino-> I acknowledge that I'm only a beginner with the FP, but I wonder why people get excited about melding OO with Haskell.
08:19:31 <dino-> I feel sadly like OO has failed me overall over the past almost 20 years of development. :(
08:20:05 <quicksilver> dino-: I don't think many people do
08:20:29 <quicksilver> dino-: some people want to explore it theoretically, to understand better what might be a semantic underpinning for OO metaphors
08:20:48 <quicksilver> dino-: while other people simply want to know "what is the best way of doing this, that I sued to do the following way in Java"
08:21:04 <dino-> I understand.
08:21:32 <dino-> I guess I'm wary also of Frankenstein monsters. Like C++, where limbs got sewed onto that poor C.
08:22:20 <araujo> Ive been reading about this language called Eiffel lately. It has some nice similarities with Haskell. For example, a class is just an abstract data type that might be generic (parametric polymorphism)
08:22:50 <quicksilver> eiffel  has some very nice things about it
08:24:09 <araujo> You even can constrain that genericity , similar to the context restrictions you do on Haskell with the class types.
08:24:20 <araujo> yeah, not that bad
08:24:59 <araujo> er, types classes
08:25:57 <araujo> Much of the misunderstanding with OOP is because of insane languages design.
08:27:48 <araujo> For example, imho, proper object oriented languages responds more to a declarative approach than an imperative one.
08:28:25 <quicksilver> I wonder if dcoutts_ and dons (and others) work on ByteString and so on shows the way to a future where we will finally unlock the performance power of pure languages
08:28:47 <dino-> araujo: Yes, I think that's a problem I personally have: never having been exposed to any OO whatsoever outside of C++ and Java.
08:29:01 <quicksilver> for so long people have said "it must be possible to write really good optimisers on pure programs because of all the transformations we can do"
08:29:11 <araujo> dino-, yeah :-(
08:29:25 <osfameron> what is the current state of the art on performance of pure langauges?
08:29:33 <araujo> dino-, check pure oo languages.
08:29:49 <osfameron> every now and then you see "can compile to code as fast as C!" but then people still complain that they are "slow"
08:30:03 <araujo> dino-, that might help you to understand better the thing
08:30:46 <quicksilver> osfameron: the current state of the art is about clever fusion and deforestation
08:30:59 <fantasma> how can I multiply every integer from 1 through 10 with every other integer from 1 through 10 resulting in a list of 100 ints
08:31:00 <quicksilver> osfameron: and ByteString/Lazy.Bytestring are good examples
08:31:18 <quicksilver> > [ x*y | x <- [1..10], y<- [1..10] ]
08:31:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,2,4,6,8,10,12,14,16,18,20,3,6,9,12,15,18,21,24,27,30,4...
08:31:41 <quicksilver> fantasma: there you go
08:31:45 <fantasma> thanks :)
08:31:52 <osfameron> quicksilver: cool.  I think I misthought/misphrased the question.  I probably mean, what are good articles/papers/benchmarks currently available to learn more
08:32:09 <quicksilver> osfameron: the bytestring paper is good
08:32:33 <quicksilver> osfameron: http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
08:32:33 <lambdabot> Title: Rewriting Haskell Strings
08:32:48 <quicksilver> osfameron: it also contains a short but useful bibliography
08:32:54 <quicksilver> osfameron: if you're really in a reading mood :)
08:33:54 <osfameron> heh :-) I'm sure the desire will pass soon enough
08:34:14 <osfameron> bookmarked, but I think I'm best off concentrating on SoE till I at least master that, thinking about it.
08:35:07 <quicksilver> it's a pretty readable paper IMO
08:36:57 <chessguy> ?src words
08:36:58 <lambdabot> words s = case dropWhile isSpace s of
08:36:58 <lambdabot>     "" -> []
08:36:58 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
08:37:12 <chessguy> hoo-boy
08:38:15 <chessguy> ?src break
08:38:16 <lambdabot> break p =  span (not . p)
08:38:20 <chessguy> ?src span
08:38:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:38:27 <chessguy> how deep does the rabbit hole go?
08:38:45 <chessguy> ?hoogle span
08:38:46 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
08:38:47 <lambdabot> Data.PackedString.spanPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
08:38:47 <lambdabot> Text.Html.colspan :: Int -> HtmlAttr
08:39:24 <quicksilver> span is takeWhile,dropWhile
08:39:30 <quicksilver> well, takeWhile *** dropWhile, I guess
08:39:42 <quicksilver> > span (<5) [1..10]
08:39:44 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
08:40:07 <chessguy> who's going to explain this to the poor guy on -cafe :)
08:40:17 <quicksilver> I don't know how to answer his question
08:40:32 <quicksilver> I'm not interested in answering questions unless I can pinpoint what people have understood
08:40:39 <quicksilver> and help them around the difficult they are hitting
08:40:44 <quicksilver> he appears to have understood nothing
08:40:48 <quicksilver> so I don't know where to start :P
08:41:00 <chessguy> it's not a trivial function to write, either, IMHO
08:41:20 <quicksilver> his question reads to me like it was pasted together out of the 'homework question' wiki page
08:41:28 <chessguy> lol, yeah
08:41:34 <quicksilver> to attempt to satisfy the requirements there without actually doing so
08:41:38 <chessguy> except for the typos
08:41:50 <quicksilver> while his code looks like it randomly cobbled together from the general 'shape' of other haskell programs
08:41:56 <quicksilver> with zero understanding of the content
08:42:20 <quicksilver> however, since I'm a grouchy and generally unforgiving type, I'm restraining myself
08:42:35 <quicksilver> i.e. I'm not flaming him and hopefully someone more tolerant than me will provide a useful answer
08:42:51 <glguy> flame who?
08:42:52 * glguy returns
08:43:00 <chessguy> i'm tempted to write a thorough explanation of how to think about the problem from start to finish, if i thought he wouldn't scroll to the bottom, and copy and paste my solution without reading anything else
08:43:10 <quicksilver> glguy: iliali16
08:43:15 <glguy> which mailing list?
08:43:19 <chessguy> -cafe
08:43:29 <quicksilver> chessguy: then do that, but don't provide the solution
08:43:29 <glguy> I archive that list in my gmail
08:43:44 <quicksilver> chessguy: merely provide a few building blocks and some ghci examples of how they work
08:43:47 <glguy> Hi I need help for very simple question! this one?
08:43:51 * quicksilver nods
08:43:52 <chessguy> yeah
08:44:01 <quicksilver> (if you're feeling generous enough to spend the time :)
08:44:17 <chessguy> i probably can't right now, because it's non-trivial
08:44:29 <chessguy> but maybe if nobody has by tonight, i'll try hacking it up
08:44:37 <glguy> ?src words
08:44:38 <lambdabot> words s = case dropWhile isSpace s of
08:44:38 <lambdabot>     "" -> []
08:44:38 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
08:44:49 <chessguy> glguy, we've just been through all that
08:44:51 <glguy> there is no way that this person is going to figure that out :)
08:45:01 <chessguy> glguy, exactly
08:45:13 <glguy> chessguy: I'm not giving hte answer, I was using it for illustrative purposes :)
08:45:34 <glguy> Tell him the solution is to delete "intoW" and add "w"? :)
08:45:41 <chessguy> especially since break is defined in terms of another function, which is defined in terms of yet another function, which is defined in terms of two more functions
08:45:41 <MarcWebe1> do you know wether its possible to not only install library and hi files when registering ghc packages but also the source files (eg to be used be DrIft or to generate some tag files?)
08:46:30 <chessguy> glguy,  huh?
08:46:51 <chessguy> oh
08:47:07 <chessguy> s/intoW/w/ you mean :)
08:47:20 <chessguy> i should just reply that, for kicks
08:49:29 <chessguy> that is a nice solution though, in words above
08:51:24 <fantasma> is a single digit considered a palindrome, ie. 5
08:51:36 <chessguy> sure
08:51:38 <quicksilver> >  unfoldr (\x -> if null x then Nothing else Just (takeWhile (/= ' ') x,(dropWhile(==' ').dropWhile(/=' ')) x)) "abc def ghi"
08:51:39 <lambdabot>  ["abc","def","ghi"]
08:51:43 <chessguy> reverse "5"
08:51:48 <chessguy> > reverse "5"
08:51:50 <lambdabot>  "5"
08:51:50 <quicksilver> because everybody loves unfoldr, right?
08:52:22 <fantasma> alright, secondly, how can I do a base case with a guard
08:52:37 <fantasma> | xs == [] = [] is not good
08:52:53 <chessguy> ?src length
08:52:53 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:52:57 <chessguy> sigh
08:53:06 <chessguy> ?src Prelude.length
08:53:06 <lambdabot> Source not found. Where did you learn to type?
08:53:16 <quicksilver> fantasma: why do you want to do a base case with a guard?
08:53:23 <quicksilver> fantasma: what's wrong with foo [] = []
08:53:37 <fantasma> quicksilver, can you do pattern matching and guards with the same function?
08:53:41 <quicksilver> yes
08:53:44 <fantasma> ah ok
10:53:36 --- topic: '["The Haskell programming language: tip over the vending machine!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
10:53:36 --- topic: set by dons on [Fri Feb 23 19:32:08 2007]
10:53:36 --- names: list (clog ji-heitch fasta malcolmw basti_ falconair_ ulfdoz reinier mascht psi SyntaxNinja Nshag matthew_- __xs__ judahj merus obsethryl ADEpt jlhamilton wilx` seancorfield rashakil jyasskin bos diffbavis stefanha benny shapr Pastorn kombinator arjanb rzoz_ dfeuer Axioplase bd_ lekro ndm cognominal cptchaos miez perspectival kpreid beelsebob der_eq tizoc der_igel kuribas Z4rd0Z MarcWebe1 maskd a-priori_ chessguy emk noj bluestorm_ thedatabase_)
10:53:36 --- names: list (tensh int-e BCoppens erg0t twanvl eamelink jtoy_ giksos iblechbot gour jberg Return2Zero russo pejo mkhl caustiq moonlite chris2 ikaros Averell Tychom ski ksandstr mux genneth LPhas JaffaCake Cheery mauke Procyon_ vstranger erider TSC Eidolos Jaak dgoldsmith mbishop Knio glguy pstickne Lunar^ Khisanth largos Ytinasni Gwern Pupeno5 lupo__ user317 bohanlon Lemmih augustss Japsu MikeJS__ sad0ur neonse ment flux- PupenoR JohnMeacham takuan)
10:53:36 --- names: list (jbalint ClaudiusMaximus mr_ank oklopol gigamonkey Poeir arjanoosting therp bdash mathrick_ rufius eretan cpfr araujo TomMD thedward_ Lamperi Altair^ arcatan orbitz rahikkala ttmrichter tarantoga hpaste Shimei ohmega ozone saccade xinming_ tessier_ Vq^ liyang GeoBesh ski_ xerox dgriffi3 bryanl levitation[A] Korollary michaelw integral allbery_b notsmack jcreigh Baughn hyrax42 Narrenschiff dufflebunk encryptio Slarba eno Xgc dblog lordl)
10:53:36 --- names: list (Daveman nothingmuch progexp206196 nich_ gaal nnunley df__ yosemite Codex_ znephf jmob SimonRC dons Boney resiak jer Nioate jdev SamB tessier svens dfranke Adamant atsampson vincenz xian nattfodd audreyt kosmikus cjay quicksilver david_ gabor muddybike gds dibblego quetzal nrb23 NichardRixon lambdabot Laney cmeme LoganCapaldo greenrd fnordus DynWind felipe rycee Tigge Yamaoka hefner dcoutts mlh cods newsham osfameron ctkrohn dino- kaol)
10:53:36 --- names: list (petekaz Saizan woggle Kattana Cale cameron Botje @ChanServ kirkeby ray arcasin Spark sieni wolverian mattiast gdsx opqdonut dcoutts_ tuukkah Igloo bhall tWip Syzygy- scw emu Philippa kzm psnl yogan rey_ kpk ludwig- Lunchy sabakas1 dropdrive kc5tja Wallbraker mahogny kalven musasabi lucca magagr dinounix ibid rafl Nafai tero- ohub kolmodin lispy kfish benja_ Ugarte mattam MarcWeber Hirvinen Eelis ricebowl earthy astrolabe dylan ketil_ aking)
10:53:36 --- names: list (mightybyte matthew-_ bolrod dany2k qwr boulez _jcrigby profmakx AvengerX eyck arasinen Shoragan delamon norpan mornfall robreim sjanssen Odd_Bloke edwinb Mitar)
11:01:42 <Igloo> dcoutts_: I don't really have any more details. We just need to work out how to make the darcs plugin work. One way is to upgrade the machine (python in particular) and see if going the egg route Just Works. The other is just to fix whatever it is that was making it not work.
11:02:35 <dcoutts_> Igloo, so the Trac plugins are deployed as 'egg's, and the version of python on hackage.haskell.org doesn't support making 'egg's ?
11:02:55 <dcoutts_> so we could try a local installation of Python for example
11:03:15 <Igloo> dcoutts_: IIRC the recommended route is eggs, yes, but there were also instructions for doing it by hand
11:03:35 <dcoutts_> and the doing it by hand method didn't work with the available version of python
11:10:10 <allbery_b> wheee
11:10:20 * allbery_b has gtk2hs finally, on the box he needs it on
11:10:29 <dcoutts_> yay :-)
11:14:12 <fasta> How far lags GTK2HS behind C-GTK?
11:14:32 <dcoutts_> fasta, we don't cover Gtk+ 2.10 apis yet
11:14:45 <dcoutts_> and there are some other bits missing like drag&drop
11:14:53 <fasta> dcoutts_: it's still not being auto generated?
11:15:01 <dcoutts_> it's partially auto-generated
11:15:18 <fasta> What are the main reasons for incomplete auto generation?
11:15:19 <dcoutts_> next round of improvements will include greater coverage
11:15:39 <fasta> Is parsing the C used too difficult?
11:15:43 <dcoutts_> there's not enough information available in the C header files to generate all the binding code
11:15:54 <dcoutts_> eg, it tells you little about memory management
11:16:08 <dcoutts_> and some types are not straightforward to marshal
11:16:23 <dcoutts_> or the same C types can sometimes be marshaled differently
11:16:40 <fasta> Can you give an example of the first?
11:16:42 <dcoutts_> eg if you have a GList in the C API, you have no idea of the element type
11:16:53 <dcoutts_> that extra info needs to be added
11:17:18 <dcoutts_> another example is not knowing when a value can be NULL or not
11:17:28 <dcoutts_> so should we marshal it a Foo or Maybe Foo?
11:17:39 <dcoutts_> that info has to be added manually
11:17:55 <dcoutts_> then there are cases where you'd just do the api differently in Haskell
11:18:03 * vincenz sighs at his code
11:18:28 <fasta> dcoutts_: NULL is used for testing existence too, right (in this particular library)?
11:19:05 <hpaste>  glguy annotated "playing around with words" with "more fun with words" at http://hpaste.org/758#a1
11:19:33 <dcoutts_> fasta, I mean things like a NULL C pointer, sometimes functions that take pointers accept NULL as a meaningful value (eg to reset to some default) sometimes they do not.
11:19:59 <dcoutts_> similarly some pointer-returning functions can return NULL and other's never return NULL.
11:20:40 <fasta> dcoutts_: this is semantic analysis and can be automated, right?
11:20:53 <dcoutts_> no, I do not believe that can be automated
11:21:26 <dcoutts_> it's usually documented in human readable documentation
11:21:32 <dcoutts_> but not in a machine readable format
11:22:09 <vincenz> @google (a -> Maybe b) -> (a -> Maybe b) -> a -> Maybe b
11:22:13 <lambdabot> http://www.ajc.com/living/content/living/food/stories/fit-to-eat/2007/02/20/022207FDfittoeat.html
11:22:13 <lambdabot> Title: Benefits of B-12 may be hard for some to absorb | ajc.com
11:22:23 <vincenz> @hoogle (a -> Maybe b) -> (a -> Maybe b) -> a -> Maybe b
11:22:23 <lambdabot> No matches, try a more general search
11:22:30 <dcoutts_> fasta, semantic analysis of C code is notoriously hard
11:22:37 <vincenz> dcoutts_: its' been done
11:22:37 <ADEpt> so, any hints to the library that will allow pixel-level disassembly of PNG files? :)
11:22:48 <fasta> dcoutts_: that depends on the tools at hand
11:22:49 <vincenz> dcoutts_: google for papaspyrou
11:23:04 <vincenz> He defined a full denotational semantics for C as his phd thesis
11:23:21 <quicksilver> vincenz: \f g x -> f x `mplus` g x
11:23:23 <dcoutts_> right, it's PhD level work
11:23:24 <quicksilver> vincenz: perhaps?
11:23:32 <vincenz> quicksilver: thx
11:23:40 <fasta> dcoutts_: PhD level work?
11:23:48 <fantasma> if you do filter list, does the original list become modified?
11:23:49 <vincenz> fasta: C has very yucky corners
11:23:50 <fasta> dcoutts_: I am not sure what there is to "discover" about it
11:23:56 <fasta> dcoutts_: it's just "work"
11:23:58 <ADEpt> fantasma: no
11:23:59 <vincenz> fasta: Read the phd thesis, he uses haskell
11:24:03 <dcoutts_> fasta, yeah, lots of work :-)
11:24:04 <fasta> dcoutts_: and you need to be a good programmer
11:24:05 <vincenz> fasta: it's not rivial
11:24:10 <quicksilver> a full denotational semantics for C need not generate the semantic information that dcoutts_ is after :)
11:24:11 <fasta> I wouldn't use Haskell for it
11:24:19 <emu> here's a blast from the past: I was going through some conference proceedings from '75 and I came across this title: "Control Structures and Monadic Languages"
11:24:22 <fantasma> ADEpt: what about for dropWhile?
11:24:27 <ADEpt> fantasma: no
11:24:32 <fantasma> thanks
11:24:33 <fasta> denotational semantics can be generated from a compiler
11:24:33 <quicksilver> fantasma: haskell functions never alter the original list
11:24:35 <vincenz> fasta: anyawys, the point is, it was a lot of work and it is not trivial
11:24:36 <emu> by Indermark
11:24:39 <vincenz> fasta: no it can not
11:24:46 <ADEpt> fantasma: original list is never modified :)
11:24:49 <quicksilver> fantasma: haskell is a pure language
11:24:49 <dcoutts_> fasta, well I tell you what, I've got a full C parser written in Haskell, you're welcome to try to do the analysis to recover the missing API information.
11:24:55 <vincenz> fasta: you're thinkign of operational semantics
11:25:06 <fantasma> quicksilver / ADEpt: alright
11:25:15 <fasta> vincenz: well, I have seen someone write a Scheme interpreter and he generated the denotational semantics from it
11:25:29 <vincenz> fasta: scheme isn't C :)
11:25:48 <vincenz> there's a reason people say scheme is pretty
11:25:54 <vincenz> (on a semantical level)
11:25:58 <hpaste>  glguy annotated "playing around with words" with "cleanup" at http://hpaste.org/758#a2
11:26:08 <fasta> vincenz: I agree it's non-trivial, but there's little to "research" about it.
11:26:15 <int-e> fasta: try it.
11:26:17 <vincenz> fasta: well then let us disagree :)
11:26:21 <fasta> vincenz: sure
11:26:28 <vincenz> fasta: accroding to your definition nothing is 'reasearch' it's all just hard work
11:26:40 <quicksilver> fasta: there was undoubtedly plenty to research, otherwise the guy wouldn't have a got a PhD for it
11:26:41 <fasta> vincenz: no
11:26:45 <emu> this paper from 1975 talks about monadic languages, actions, conditions, and program iteration
11:26:51 <quicksilver> PhDs are only awarded for original research
11:26:56 <glguy> Did you two just agree to disagree?
11:27:02 <fasta> glguy: yes
11:27:03 <glguy> is that different than agreeing to argue?
11:27:12 <vincenz> glguy: no it's agreeing not to argue
11:27:24 <glguy> right :)
11:27:25 <vincenz> @google papaspyrou denotational sematnics of ANSI C
11:27:26 <lambdabot> No Result Found.
11:27:30 <vincenz> He has a nice monad-layering
11:27:36 <vincenz> @google papaspyrou denotational sematincs of ANSI C
11:27:38 <vincenz> grr
11:27:38 <lambdabot> No Result Found.
11:27:39 <vincenz> stupid lag
11:27:40 <int-e> http://www.softlab.ntua.gr/~nickie/Thesis/
11:27:44 <lambdabot> Title: Nikolaos S. Papaspyrou: Doctoral Dissertation
11:27:44 <vincenz> int-e: thx
11:27:51 <vincenz> he has a shorter paper as well
11:28:02 <vincenz> @google papaspyrou "denotational semantics of ANSI C"
11:28:05 <lambdabot> http://citeseer.ist.psu.edu/497062.html
11:28:05 <lambdabot> Title: Denotational Semantics of ANSI C (ResearchIndex)
11:28:10 <vincenz> there we go
11:28:33 <quicksilver> still, I"m not convinced that a denotational semantics gets you much close to the answer to dcoutts_'s problem :)
11:28:47 <vincenz> quicksilver: I fear I joiend too late for that bit :)
11:28:53 <quicksilver> that's got more to to with intentional semantics, or something like that
11:29:08 <vincenz> quicksilver: what does he want to do?
11:29:12 <dcoutts_> vincenz, so a couple examples, I'd like to know for each C function, if it can ever call back into Haskell land. Also for each C function, can it take NULL as a valid pointer parameter value (ie not print an error) and can it return NULL as a result.
11:29:42 <glguy> sounds like a question for the man pages :) (when it comes to C)
11:29:47 <vincenz> dcoutts_: the first seems like a flow analysis (or pososibly not even flow but static)
11:30:02 <dcoutts_> glguy, exactly, we just read the docs and add the info by hand.
11:30:08 <vincenz> dcoutts_: the second part seems to be related to separation logic
11:30:11 <int-e> glguy: yes, which is why gtk2hs uses manually extracted information there.
11:30:40 <vincenz> dcoutts_: though most likely a flow analysis will suffce?
11:30:45 <dcoutts_> vincenz, yes, the first seems easier, we can compute the static call graph and look for unknown control flow (ie jumps through function pointers)
11:31:06 <vincenz> dcoutts_: those that you do not know can then be handled by set-analysis to cut down on the unknowns
11:31:18 <int-e> vincenz: the analysis can be arbitrarily complex. if you're really unlucky, the parameter is just copied to some struct and another thread will later use it in some way or another.
11:31:23 <tiglionabbit> is there a fixed-point type in haskell?
11:31:33 <vincenz> int-e: really, separation logic
11:31:49 <tiglionabbit> or a floating point of expanding precision?
11:32:11 <glguy> reading stock market logs?
11:32:12 <vincenz> tiglionabbit: those are tow separate types :)
11:32:24 <tiglionabbit> I know
11:32:27 <vincenz> tiglionabbit: the second one seems much harder than the first ;)
11:32:51 <dcoutts_> .vincenz, yes, I fear it'd require figuring out if any other function can ever set this struct member to NULL.
11:33:11 <tiglionabbit> well, Haskell has Integer.  It would be neat if it had, perhaps, a Rational type that would generate decimals as you asked for them
11:33:14 <dcoutts_> vincenz, since many possibly-NULL-returning functions just get things out of structs
11:33:18 <vincenz> dcoutts_: well first use a simple flow analysis, if you then notice that what you mention is the case, then separation logic should you get out of the problem a bit more.
11:33:22 <glguy> ?hoogle Rational
11:33:23 <lambdabot> Prelude.Rational :: type Rational
11:33:23 <lambdabot> Text.PrettyPrint.HughesPJ.rational :: Rational -> Doc
11:33:23 <lambdabot> Language.Haskell.TH.RationalL :: Rational -> Lit
11:33:35 <vincenz> but separation logic isn't easy :/
11:33:58 <tiglionabbit> yey
11:34:00 <dcoutts_> vincenz, my point of course is that this is all probably harder work that just translating the info in the docs into machine readable stuff which we can then feed into the code gen
11:34:36 <vincenz> dcoutts_: ah...hmm...well what you can do is a simple flow analyis to get you x% of the cases (hopefully a big x) and then do the rest with doc-manglign
11:34:44 <fasta> dcoutts_: How long did it take you to implement a full C parser in Haskell?
11:34:59 <vincenz> fasta: good question :)
11:35:04 <vincenz> and more importnatly, is it open source?
11:35:10 <dcoutts_> fasta, a few weeks part time
11:35:12 <dcoutts_> vincenz, sure
11:35:27 <dcoutts_> vincenz, I'm gradually merging my changes into the c2hs C parser
11:35:27 <fasta> dcoutts_: that is fas
11:35:29 <fasta> dcoutts_: t
11:35:34 <dcoutts_> fairly fast
11:35:42 <dcoutts_> it's an Alex + Happy parser
11:35:45 <tiglionabbit> neat
11:35:49 <vincenz> dcoutts_: nice :)
11:35:52 <dcoutts_> on my box it's about 10kloc/s
11:35:55 <vincenz> dcoutts_: custom monad?
11:36:04 <vincenz> (and does it loc-annot the ast?)
11:36:05 <tiglionabbit> so I guess there isn't a better way of storing irrational numbers than in Doubles
11:36:41 <dcoutts_> vincenz, yes custom state monad, but not revolutionary. Yes it annotates every AST node with the file/line/column position
11:36:48 * vincenz nods
11:37:03 <vincenz> dcoutts_: do you happen to use GADTS for AST representation?
11:37:07 <dcoutts_> no
11:37:12 <vincenz> ah
11:37:17 <dcoutts_> same old c2hs C AST
11:37:22 <vincenz> dcoutts_: so how do you representat annotated ASTs?
11:37:35 <dcoutts_> attribute tables
11:37:51 <dcoutts_> each node has an attribute which you can use to index and attribute table
11:37:56 <vincenz> ah I see
11:37:59 <vincenz> hmm, interesting
11:37:59 <dcoutts_> and/an
11:38:06 <vincenz> ggme has been using a GADT with a phantom type
11:38:11 <vincenz> s/gg//
11:38:12 <dcoutts_> that's a ctk trick
11:38:22 <vincenz> well it reuses bringgert's SYB work
11:38:26 <dcoutts_> c2hs is built with the ctk stuff
11:38:28 <vincenz> but then I rwrote Compose for the new GADT
11:39:08 <vincenz> (in the sense, I rewrote his Compos stuff for a GADT that takes 2 parameters, one of which is phantom for all data-constructors except the Tag one)
11:39:18 <ddarius> tiglionabbit: You can't store irrational numbers in doubles at all.
11:39:45 <hpaste>  glguy annotated "playing around with words" with "less is more" at http://hpaste.org/758#a3
11:39:47 <ndm> vincenz: what about the Compos stuff, what did you rewrite?
11:39:50 <tensh> vincenz: you mean björn bringert?
11:40:11 * ddarius wonders if it would be possible to -run- the C, passing NULL parameters and catching the "exceptions" to automatically handle that case well enough.
11:40:14 <vincenz> tensh: indeed
11:40:22 <vincenz> ndm: well his only works for a GADT that has one parameter
11:40:31 <tensh> vincenz: cool... he's one of the assistants to the course I'm taking right now :)
11:40:48 <dcoutts_> ddarius, that'd probably work actually. The returning NULL case is harder though.
11:40:53 <ndm> vincenz: ok, i've been working on a competitor - wondering if there was some good extensions to it since then
11:40:59 <vincenz> ndm: oh?
11:41:00 <ndm> vincenz: a competitor which doesn't require GADT
11:41:05 <vincenz> ndm: how does it work?
11:41:06 * dcoutts_ -> home
11:41:22 <vincenz> ndm: I gthought about writing a paper abougt it with bringert to some workshop
11:41:37 <ddarius> dcoutts_: Yeah.
11:41:40 <ndm> vincenz: differently :) - i'm writing a paper on it now, so probably best to announce it once thats done
11:41:44 <vincenz> He said it might require more examples to pass so  I gave up on that (It was about a gyear ago)
11:41:46 <ndm> vincenz: yours is just a 2 type GADT version?
11:41:53 <vincenz> ndm: heh, that doesn't help me much
11:42:09 * vincenz is working on a denotational semantics for a subset of C, so sort of needs a good AST repre
11:52:43 * glguy is trying to think of a new word to paste to the 70s chair... [PROFOUND] seems to be wearing off
12:03:42 <fantasma> I want to do the following: filter (isDivisible) [1..1000] where isDivisible y = y `mod` [1..20]
12:04:02 <fantasma> that code obviously doesnt work though because mod doesnt take lists
12:04:32 <vincenz> isDivisible y = and (map (\x -> 0 == y `mod` x)  [1..20])
12:05:43 <Igloo> and (map f xs) == any f xs
12:06:00 <Igloo> Err, IM all, not any
12:06:24 <vincenz> s/IM/?
12:06:28 <Igloo> I mean
12:06:29 <ddarius> I mean
12:06:32 <vincenz> :)
12:06:33 <nmessenger> all (y `mod`) [1..20] -- ?
12:06:44 <vincenz> mod returns an int
12:06:48 <nmessenger> all ((0==) . (y `mod`)) [1..20] -- rather
12:06:53 * ddarius listens to lead singer of Bad Religion sing "and keep a 'lovin Jesus".
12:06:54 * vincenz nods
12:07:05 <fantasma> nmessenger, do you understand what I need it to do?
12:07:13 <vincenz> fantasma: he does
12:07:23 <fantasma> ok
12:07:34 <nmessenger> just those numbers in [1..1000] which are divisible by all of [1..20]?
12:07:38 <fantasma> i don't understand the code so I'm just making sure
12:09:05 <nmessenger> er, it might be (`mod` y), my brain is mushy at the moment
12:09:37 <nmessenger> @bot?
12:09:37 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
12:10:04 * ddarius thinks the command guessing should be turned off.
12:10:14 <glguy> > foldl' gcd 1 [1..20]
12:10:15 <lambdabot>  1
12:10:18 <glguy> > foldl' lcm 1 [1..20]
12:10:19 <lambdabot>  232792560
12:10:30 <glguy> > foldl' lcm 1 [1..10]
12:10:32 <lambdabot>  2520
12:10:36 <glguy> > foldl' lcm 1 [1..5]
12:10:37 <fantasma> :(
12:10:37 <lambdabot>  60
12:10:52 <fantasma> i dont understand how you all make it so simple :(
12:11:01 <glguy> > filter (flip all [1..5] . (((0==).) . mod)) [1..10000]
12:11:06 <lambdabot>  [60,120,180,240,300,360,420,480,540,600,660,720,780,840,900,960,1020,1080,11...
12:11:10 <ddarius> > 2*3*5
12:11:11 <lambdabot>  30
12:11:11 <glguy> > filter (flip all [1..10] . (((0==).) . mod)) [1..10000]
12:11:13 <lambdabot>  [2520,5040,7560]
12:11:25 <ddarius> @type lcm
12:11:27 <lambdabot> forall a. (Integral a) => a -> a -> a
12:11:37 <fantasma> @src lcm
12:11:37 <lambdabot> lcm _ 0     =  0
12:11:38 <lambdabot> lcm 0 _     =  0
12:11:38 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
12:11:39 <nmessenger> > lcm 2 3
12:11:41 <lambdabot>  6
12:12:18 <nmessenger> > lcm 12 10
12:12:19 <lambdabot>  60
12:12:36 <fantasma> what is the equivilant of foldl' in hugs?
12:12:41 <glguy> foldl'
12:12:48 <ddarius> List.foldl' or Data.List.foldl'
12:12:48 <glguy> :also Data.List
12:12:50 <nmessenger> it's in Data.List
12:13:38 <fantasma> ERROR - Undefined qualified variable "Data.List.foldl'"
12:13:57 <nmessenger> import or :also
12:14:04 <ddarius> foldlStrict?
12:14:16 <nmessenger> ddarius: yep
12:14:36 <vincenz> @paste
12:14:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:14:52 <nmessenger> or were you asking if it had a different name in Hugs?
12:14:52 <fantasma> what do I import..prelude?
12:15:00 <hpaste>  vincenz pasted "vincenz's compos2 (extension of bringert's compos)" at http://hpaste.org/761
12:15:05 <nmessenger> import Data.List
12:16:34 * ddarius considers putting his watch in the washer.
12:16:43 <fantasma> do inport statements have to be before all of the code or can it go in the "body"
12:17:01 <nmessenger> the former
12:17:07 <fantasma> thanks
12:19:27 <monochrom> would be fun to permit arbitrary placement.
12:20:00 <monochrom> programmer goes crazy hunting for import statements!
12:20:11 <fantasma> haha
12:20:44 <monochrom> but is it that deplorable?  placement of function definitions and data type declarations and a whole lot other things are already arbitrary.
12:21:58 <fantasma> foldl1 != foldl' ?
12:22:07 <monochrom> right, different.
12:22:13 <nmessenger> nope, it doesn't
12:22:26 <monochrom> foldl' is an optimization of foldl.  accepts empty list.
12:22:39 <monochrom> foldl1 rejects empty list.
12:22:43 <nmessenger> foldl1 op (x:xs) = foldl op x xs
12:23:54 <mwc> Did they take anywhere-import off the docket for Haskell'?
12:24:18 <fantasma> @src foldl'
12:24:18 <lambdabot> foldl' f a []     = a
12:24:19 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:24:46 <mwc> Seems like a really bad idea. Unless you bring some sanity to the idea like imported bindings are visible only below the import that brought them in. But then that kind of breaks the beauty of haskell's recursive binding at module-level
12:25:35 <nmessenger> the `seq` makes it strict, so it's useful for things like numbers.  In most all other cases, you want foldr
12:26:00 <fantasma> nmessenger: what do you mean by strict
12:26:41 <ddarius> foldl' is not an optimization it's a different function.
12:26:45 <nmessenger> in (foldl' (+) 0 [1..3]) the additions get performed immediately, instead of piling up on the stack.
12:27:11 <fantasma> I see
12:27:37 <ddarius> Did you mean foldl' when you said foldr.  Otherwise, most cases split very roughly half and half between foldr and foldl'.
12:28:23 <nmessenger> Cale has at least one demonstration of the difference between foldl and foldl', lemme see if I can find it.
12:29:25 <emu> > foldl (flip (:)) [] [1..10]
12:29:27 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
12:29:45 <emu> > take 5 $ foldl (flip (:)) [] (undefined:[1..10])
12:29:46 <lambdabot>  [10,9,8,7,6]
12:29:53 <emu> > take 5 $ foldl' (flip (:)) [] (undefined:[1..10])
12:29:54 <lambdabot>  [10,9,8,7,6]
12:30:25 <fantasma> > 1==1==1
12:30:26 <lambdabot>      precedence parsing error
12:30:26 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
12:30:38 <nmessenger> (1==1)==True :P
12:30:50 <fantasma> ;)
12:31:08 <ddarius> @oldwiki StackOverflow goes over them fairly well.
12:31:08 <lambdabot> http://www.haskell.org/hawiki/StackOverflow goes over them fairly well.
12:31:13 <fantasma> > foldl1 lcm 1 [1..10]
12:31:14 <lambdabot>   add an instance declaration for (Num [[t] -> a])
12:31:20 <fantasma> > foldl' lcm 1 [1..10]
12:31:22 <lambdabot>  2520
12:31:27 <fantasma> > foldr lcm 1 [1..10]
12:31:28 <lambdabot>  2520
12:31:29 <monochrom> I made no typo. I said what I meant.
12:31:29 <ddarius> At least I think so, but I'm biased.
12:32:17 <fantasma> i feel bad asking help on every single euler problem
12:32:41 <monochrom> Yeah, you should unplug your internet. :)
12:33:14 <fantasma> yah
12:33:24 <fantasma> it doesnt feel right to submit the answe now
12:33:28 <monochrom> solitude is how I learned all things
12:33:39 <fantasma> s/answe/answer
12:34:15 * emk will post another probability article after work
12:36:26 <emu> here!
12:36:29 <emu> > take 2 $ foldl (\xs x -> if x < 5 then x:xs else xs) [] $ undefined:[1..10]
12:36:30 <lambdabot>  [4,3]
12:36:32 <nmessenger> > foldl lcm 1 [1..10000000]
12:36:32 <emu> > take 2 $ foldl' (\xs x -> if x < 5 then x:xs else xs) [] $ undefined:[1..10]
12:36:34 <lambdabot>  Undefined
12:36:37 <lambdabot> Terminated
12:36:39 <nmessenger> > foldl' lcm 1 [1..10000000]
12:36:43 <lambdabot> Terminated
12:37:18 <fantasma> > foldl' lcm 1 [1..10000]
12:37:20 <lambdabot>  5793339670287642968692270879166240098634860297998518825393138351148979300145...
12:37:20 <emu> that forces it to examine list elements somehow
12:38:16 <fantasma> > foldl' (*) 1 [1..10000]
12:38:18 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
12:38:31 <emu> @src product
12:38:32 <lambdabot> product = foldl (*) 1
12:38:42 <emu> > product [1..10000]
12:38:43 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
12:38:53 <emu> > foldl (*) 1 [1..10000]
12:38:54 <fantasma> yah I wasn't sure
12:38:55 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
12:39:33 <Cale> > foldl (+) 0 [1..100000000]
12:39:37 <lambdabot> Terminated
12:39:39 <Cale> > foldl (+) 0 [1..1000000]
12:39:41 <lambdabot>  500000500000
12:39:44 <Cale> > foldl (+) 0 [1..10000000]
12:39:48 <lambdabot> Terminated
12:39:54 <Cale> Hmm, that's better than before :)
12:39:59 <fantasma> > foldl
12:39:59 <nmessenger> I couldn't blow stack either :D
12:40:00 <lambdabot>  Add a type signature
12:40:20 <Cale> Perhaps it's compiling with -O
12:40:20 <fantasma> > foldl' (/) 1 [1..10000]
12:40:22 <lambdabot>  0.0
12:40:31 <monochrom> > > foldl (+) 0 [1..10000000] :: Int
12:40:32 <fantasma> > foldl' (/) 1000 [1..10000]
12:40:32 <lambdabot>  Parse error
12:40:33 <lambdabot>  0.0
12:40:36 <monochrom> > foldl (+) 0 [1..10000000] :: Int
12:40:41 <Cale> Prelude> foldl (+) 0 [1..1000000]
12:40:41 <Cale> *** Exception: stack overflow
12:40:41 <lambdabot> Terminated
12:40:45 <Cale> that's in GHCi 6.6
12:40:51 <monochrom> > foldl (+) 0 [1..10000000] :: Int#
12:40:51 <lambdabot>  Parse error
12:40:55 <fantasma> > foldl' (/) 1000 [1..10]
12:40:56 <lambdabot>  2.7557319223985884e-4
12:41:19 * fantasma has to go to class
12:41:43 <monochrom> quadruple quotes? :)
12:42:27 <int-e> > runState (replicateM_ 1000000 (modify succ)) 0
12:42:29 <lambdabot>  Exception: stack overflow
12:43:15 <monochrom> State treats its state nonstrict, too.
12:43:37 <JimiDini> hi everyone :) I have some problems with running demo's from latest gtk2hs. can anyone help me with that?
12:43:51 <int-e> monochrom: yes. I was deliberately trying to get a stack overflow.
12:44:03 <monochrom> Oh!
12:44:22 <dcoutts> JimiDini, I can, but not this moment. Ping me later if no one else can help you.
12:45:00 <JimiDini> dcoutts: ok :)
12:45:01 <ddarius> > runState (replicateM_ 1000000 (modify succ) :: State Int# ()) 0
12:45:01 <lambdabot>  Parse error
12:45:13 <ddarius> Bah no -fglasgow-exts
12:48:30 <int-e> ddarius: fwiw, it wouldn't work. You'd get a kind error.
12:49:18 <dino-> Cale: If you a little time, I have some more questions wrt arrows and HXT.
12:49:22 <dino-> ^have
12:49:32 <Cale> dino-: okay, give me a few minutes
12:49:37 <dino-> @paste
12:49:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:50:49 <notsmack> @seen bringert
12:50:49 <lambdabot> I saw bringert leaving #haskell 1d 12h 4m 8s ago, and .
12:51:15 <hpaste>  dino- pasted "HXT, arrows and numbering" at http://hpaste.org/763
12:51:32 <monochrom> whee, hxt
12:51:48 <hpaste>  dino- annotated "HXT, arrows and numbering" with "XML document" at http://hpaste.org/763#a1
12:51:55 <monochrom> already!
12:52:26 <ddarius> int-e: I was wondering about that.
12:52:27 <monochrom> Does it work?
12:52:52 <ddarius> > execState (replicateM_ 1000000 (modify succ) :: State Int ()) 0
12:52:54 <lambdabot>  Exception: stack overflow
12:53:10 <ddarius> @list track
12:53:11 <lambdabot> No module "track" loaded
12:53:30 <int-e> > evalState (replicateM_ 1000000 (modify succ) :: State Int ()) 0
12:53:32 <lambdabot>  ()
12:53:38 <lordl> ?type guard
12:53:40 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
12:53:55 <ddarius> int-e: Well, yeah, but that's not interesting.
12:55:29 <vincenz> yay for code reuse :)
12:56:16 <monochrom> dino-: IMO you need the xml file to have the proper xml requirements e.g. <?xml blahblah>  Are you sure it doesn't matter?
12:56:24 <craigmarshall9> *** highlyInterested (~ijones) has joined channel #haskell
12:56:24 <craigmarshall9> <highlyInterested> hi! I'm highly interested, but have no attention span!!!
12:56:24 <craigmarshall9> <highlyInterested> Can anyone help me?!?!?
12:56:24 <craigmarshall9> * highlyInterested runs around!!
12:56:53 <craigmarshall9> Ignore that please! Sorry
12:57:10 <dino-> monochrom: HXT is able to deal with it without the XML decl, but yeah, I know what you mean.
12:57:17 <dino-> monochrom: My problem doesn't lie with parsing it in.
12:58:39 <monochrom> I see.
12:59:31 <dino-> If you see that process2, the difference between that and process1 is that the text call is replaced with the labelText. What I'm trying to achieve there is numbering the output sequentially.
13:00:06 * araujo off to give the talk ina few minutes
13:00:11 <dino-> What happens is each line is numbered "01", every single one.
13:00:58 <dino-> I'm still having difficulty with this list arrow business.
13:02:57 <dino-> It's really astounding how hard this XML stuff has been with the Haskell XML libraries. :o
13:03:22 <Gwern> strings aren't fun either. I'm trying to figure out to produce a string with \ in it
13:03:23 <monochrom> You need state.
13:03:26 <Gwern> > "\\"
13:03:28 <lambdabot>  "\\"
13:03:37 <Gwern> > "\a"
13:03:39 <lambdabot>  "\a"
13:03:44 <int-e> Gwern: that's right
13:03:47 <Gwern> > "\"
13:03:48 <lambdabot>  Improperly terminated string
13:03:53 <Gwern> > "\ "
13:03:53 <lambdabot>  Illegal character in string gap
13:03:54 <int-e> > show "\\"
13:03:55 <lambdabot>  "\"\\\\\""
13:04:10 <int-e> Gwern: it's quoted when you print it
13:04:11 <Cale> > length "\\"
13:04:12 <lambdabot>  1
13:04:24 <Cale> > head "\\"
13:04:26 <lambdabot>  '\\'
13:04:35 <int-e> Gwern: (but putStr & co. will not do that)
13:04:35 <dino-> monochrom: Yeah. I would need state or the listA code that's in there. Cale was helping me with trying to understand how listA turns a nondeterministic list arrow into a deterministic one.
13:04:39 <Gwern> oy
13:04:40 <Cale> dino-: let's have a look
13:04:56 <Cale> dino-: hmm, IOSArrow?
13:05:14 <dino-> Cale: I got much of this code from some of the "gentle" HXT documentation.
13:05:29 <nmessenger> @read "\\"
13:05:29 <lambdabot>  \
13:06:01 <nmessenger> @show this is \ a bunch \ of characters \ with backslashes
13:06:01 <lambdabot> "this is \\ a bunch \\ of characters \\ with backslashes"
13:06:21 <monochrom> XML is trivial.  State is difficult.  This is caused by functional programming rather than haskell or hxt.
13:06:40 <hpaste>  dino- annotated "HXT, arrows and numbering" with "the output" at http://hpaste.org/763#a2
13:06:46 <Cale> dino-: ah, okay, IOSArrow is really an IOSLA in disguise.
13:07:03 <monochrom> IOSArrow is IOSLA with state being ()
13:07:23 <dino-> While we're here, let me ask you this:
13:07:23 <monochrom> IOW by choosing IOSArrow you have denounced state.
13:07:29 <dino-> My task here is to explicitly NOT have an output XMl document. I don't want an XML declaration, I don't want a top-level element. I want plain-text output, period.
13:07:49 <dino-> Is this a good use of HXT and/or HaXml? It seems like a huge problem with this runX/runLA/whatever stuff or processing the XML in general through these filters/arrows etc.
13:08:03 <Gwern> thankfully, after a while these type errors are starting to make sense
13:08:13 <dino-> Like being stuck in a situation where something structured has to come out at the end.
13:08:15 <hpaste>  vincenz pasted "clean reusable lexer" at http://hpaste.org/764
13:08:18 <Cale> dino-: It should be fine. You don't have to produce an XML document at all.
13:08:26 <monochrom> It's perfectly OK to output anything other than xml.  IOSLA contains IO too.  Just lift your hPutStr's.
13:08:29 <nmessenger> Gwern: '\\' is just a notation for a single backslash character.  '\n' is the newline character, so \ is magical.  In order to make it unmagical, you have to use it to unmagicify itself.
13:08:30 <Cale> dino-: You can produce a list of values of any type.
13:08:56 <SamB> also, you can probably make a tree that consists of (almost) nothing but a textnode?
13:09:09 <SamB> oh, right, that...
13:09:10 <dino-> SamB: That's what it does now, but seems like an ugly hack.
13:09:14 <Gwern> nmessenger: which is what I originally thought, but it dreadfully confused me when I tried it out in the interpreter
13:09:16 <Cale> dino-: just don't use selem/txt/etc.
13:09:24 <Gwern> seeing \\ when you expect \ is quite disturbing
13:09:46 <dino-> Cale: Ok, I was doing this originally with HaXml and it was very picky about the output being real XML. Maybe I can get away with something less well-formed here.
13:10:08 <Cale> You can use HXT just for input of XML.
13:10:15 <malcolmw> in HaXml, you don't need to produce XML at all
13:10:17 <nmessenger> if it's represented as a Haskell Char or String literal, it needs the second backslash to escape itself.  If you putStr it, it prints normally
13:10:23 <malcolmw> that is just the common use case
13:11:02 <dino-> malcolmw: I ended up writing my own processXmlWith that wouldn't reject anything that was more than one top element.
13:11:29 <craigmarshall9> (luthier == Guitar-maker and repairer.)
13:12:09 <monochrom> Two solutions.  Either use state.  Or re-arrange the placement of listA: move it one level up.
13:12:21 <malcolmw> dino-: processXmlWith was only ever intended to be a pattern for others to copy and tweak
13:12:28 <dino-> Cale: Anyway, back to the listA. I have the zipping in there and I suspect it's a problem with my "g" function which is trying to combine the (String, String) into one String.
13:12:37 <monochrom> Your current position of listA is too deep.  So it only see very local things.
13:14:34 <dino-> monochrom: What do you mean by too deep?
13:18:26 <Cale> dino-: let me post a much simplified example
13:19:35 <hpaste>  Cale annotated "HXT, arrows and numbering" with "example" at http://hpaste.org/763#a3
13:21:02 <Cale> That's just getting the c's, but you can see how it works.
13:21:16 <dino-> This is calling labelText with the (atTag "c" >>> text) instead of binding the label thing 'after' the atTag "c".
13:21:31 <dino-> ok
13:21:39 <Cale> you need to pass the right thing to listA
13:21:57 <Cale> Specifically, you have to pass listA the arrow which you want to number the results from.
13:22:35 <Cale> In your old code, it was applying listA to text, which was going to return probably only one result.
13:22:51 <Cale> (Because there's usually only one text node per tag.)
13:22:54 <dino-> Hm. So even though there were three of them, each one was getting its own zip operation?
13:22:59 <Cale> yes
13:24:33 <Cale> So you were applying the numbering operation too "deep"
13:24:55 <Cale> It needs to be applied directly to the arrow whose results you're numbering.
13:26:26 <dino-> Part of my troubles with these things is not understanding how to compose these expressions with the binding and ( ) separating the arrows (or filters). I had the same problems with HaXml and malcolm was saying that it's the way I'm doing the bracketing and associativity. It's been very tricky stuff.
13:27:20 <Zeroth|work> haskell seems mostly math-oriented. no?
13:27:27 <ddarius> no
13:27:35 <kpreid> math-*derived*
13:27:38 <ddarius> no
13:28:01 <tibbe> math-*deprived*?
13:28:08 <ddarius> no
13:28:17 <tibbe> hmm, that's probably not the word I was looking for...
13:28:55 <malcolmw> algebraic
13:29:01 <Zeroth|work> is it interpreted or compiled?
13:29:06 <Cale> Zeroth|work: both
13:29:11 <ddarius> It's a language.
13:29:17 <kpreid> Zeroth|work: *any* language can be either interpreted or compiled.
13:29:23 <kpreid> Haskell implementations usually compile.
13:29:35 <Cale> There's an interpreter called Hugs
13:29:44 <Gwern> ok, I want to do this: list <- words $ readFile "~/bin/pywikipedia/redirect-list.txt", but the type sigs don't match up (String and IO String). How can I make them do so?
13:29:45 <Zeroth|work> kpreid, show me a compiled Tcl app :-p
13:29:47 <ddarius> What implementations only support compiling?  jhc, and ...?
13:29:51 <Cale> and GHC, the compiler, comes with an interpreter/object loader called GHCi
13:29:53 <nmessenger> compiling highly runtime-oriented languages is mostly not done, though
13:30:01 <glguy> Gwern: liftM words $
13:30:03 <dino-> Thanks for help again Cale, malcolmw, monochrom and everyone else. I will keep at it.
13:30:04 <Cale> There's a bytecode compiler called yhc
13:30:07 <glguy> :t words
13:30:09 <lambdabot> String -> [String]
13:30:10 <glguy> :t liftM words
13:30:12 <lambdabot> forall (m :: * -> *). (Monad m) => m String -> m [String]
13:30:28 <kpreid> Zeroth|work: Okay, some languages aren't amenable to useful compilation. :)
13:31:04 <Cale> Even with eval though, you can build a copy of the compiler into the runtime :)
13:31:22 <ddarius> See Smalltalk, Self.
13:31:26 <nmessenger> alternatively, if you didn't know about liftM, you could do what it does:
13:31:27 <nmessenger> @src liftM
13:31:27 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:31:49 <nmessenger> do {xs <- ...; return (words xs)}
13:31:51 <glguy> If you can't bring the data to the function, take the function to the dat
13:31:52 <glguy> a
13:32:23 <Cale> Zeroth|work: Even though Haskell isn't really a mathematical language, it tends to be good at representing abstractions from mathematics. It's nothing like a computer algebra system though.
13:33:17 <Zeroth|work> I'm trying to determine what good Haskell is, and whether I want to learn it or not. Wikipedia's article leads me to believe that it is most commonly used for mathematics.
13:33:34 <Zeroth|work> s/what good Haskell is/what Haskell is best suited for
13:33:37 <Cale> That's sort of odd. It's a general purpose language.
13:33:42 <monochrom> Haskell is good for opening your mind.
13:33:51 <nmessenger> @go Haskell wikipedia
13:33:52 <lambdabot> http://en.wikipedia.org/wiki/Haskell_(programming_language)
13:34:09 <Cale> It's a really good language to learn if you're interested in programming languages. :)
13:34:10 <Zeroth|work> lamda, as in Half-Life? :-p
13:34:23 <Cale> Lambda as in Lambda calculus.
13:34:41 <Zeroth|work> Cale, I've got C/C++, PHP, ASP, some JavaScript, and Tcl/Tk under my belt
13:34:53 <vincenz> Zeroth|work: all imperatigve languages :)
13:34:56 <Cale> Haskell is rather different from all of those
13:34:58 <vincenz> Zeroth|work: time to leanr FPLs
13:35:03 <Zeroth|work> FPL?
13:35:07 <Cale> I suspect that it will be rather like learning to program all over again.
13:35:09 <vincenz> Functional programming languages
13:35:16 <vincenz> Cale: yeap:)
13:35:20 <Cale> But it should be fun :)
13:35:22 <Zeroth|work> Tcl/Tk was like learning all over again :-)
13:35:26 <vincenz> Cale: haha .. fufn
13:35:29 <vincenz> fun ... ;)
13:35:49 <nmessenger> Zeroth|work: have you written any Haskell or read much about it?
13:36:06 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
13:36:07 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
13:36:13 <Zeroth|work> nmessenger, I've glazed over the wikipedia article and heard much good things about it (mostly praises without much example)
13:36:16 <monochrom> If you've got all that much under your belt...  boy, you'll have much entrenched presumptions to unlearn before you understand basic Haskell.  It'll take 5 years.
13:36:24 <vincenz> monochrom: :)
13:36:24 <monochrom> Learning is unlearning.
13:36:28 <kpreid> Zeroth|work: I personally recommend learning Haskell, Common Lisp, and something strongly OO
13:36:28 <vincenz> monochrom: very zen
13:36:33 <vincenz> "empty the cup before you can fill it again"
13:36:35 <glguy> Haskell doesn't assume you are brain-dead and allows you to take advantage of more advanced programming concepts :)
13:36:39 <monochrom> I am old and wise.
13:36:44 <vincenz> kpreid: I prefer scheme over CL, but that's like emacs vs vim
13:36:53 <Zeroth|work> I'm also interested in Perl
13:36:55 <nmessenger> Zeroth|work: if you want example, there was recently an excellent blog post I enjoy: http://blogs.nubgames.com/code/
13:36:57 <lambdabot> Title: Nub Games
13:37:07 <vincenz> back to my denotationall compiler
13:37:13 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
13:37:14 <nmessenger> er, specifically: http://blogs.nubgames.com/code/?p=22
13:37:15 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:37:16 <lambdabot> Title: Nub Games » Haskell IO for Imperative Programmers
13:37:19 * vincenz should make a compiler compiler framework, all this compiler-coding is getting old
13:37:25 <kpreid> vincenz: I personally find CL to have more visible lispy brain-stretching bits
13:37:30 <Cale> So you're right, it is pretty good at mathematics :)
13:37:33 <kpreid> but, yes, taste
13:37:37 <Zeroth|work> lol codepoet
13:37:41 <Cale> But it's actually pretty good at lots of things.
13:37:44 <monochrom> I also had a lot of pre-knowledge before Haskell, but mine was a much more balanced diet.  basic, pascal, c, lisp, prolog, perl, sml.
13:37:45 * ddarius prefers vim and Scheme.
13:37:48 <vincenz> ddarius: me too
13:37:50 <augustss> Zeroth|work: yes, read that blog post nmessenger recommends
13:37:57 <vincenz> vim scheme, emacs and smalltalk
13:38:01 <vincenz> thoug hthe latter is new on my menu
13:38:05 <vincenz> ack
13:38:06 <glguy> ?lusers
13:38:06 <lambdabot> Maximum users seen in #haskell: 332, currently: 314 (94.6%), active: 47 (15.0%)
13:38:08 <vincenz> s/emacs/haskell
13:38:13 <Cale> heh
13:38:18 <Cale> what a strange mixup :)
13:38:26 <vincenz> Cale: mental typo
13:38:28 <ddarius> @google BIG2
13:38:30 <lambdabot> http://www.softempire.com/big2-to-net.html
13:38:31 <lambdabot> Title: Big2 to NetBig2. Card Game
13:38:35 <monochrom> I forgot mathematica.  It also provided much perspective.
13:38:35 <ddarius> Bah.
13:38:36 * Zeroth|work bookmarks the page
13:38:37 <vincenz> or should that be a semantico?
13:38:49 <Zeroth|work> thanks for the advice guys
13:38:53 <malcolmw> Zeroth|work: http://blogs.nubgames.com/code/?p=22
13:38:54 <lambdabot> Title: Nub Games » Haskell IO for Imperative Programmers
13:39:04 <malcolmw> it's good on examples
13:39:08 <ddarius> Cale: In reference to monochrom?
13:39:17 <ddarius> Oh vincenz.
13:39:20 <nmessenger> malcolmw: beat you to it ;)
13:39:23 <Cale> ddarius: yeah, vincenz
13:39:45 <monochrom> moi?!
13:40:02 <vincenz> Cale: I'm megacoding, it's friday night and nearing 11pm and I'm still at the office...soo
13:40:16 * vincenz wants to get the front-end to his 'compiler' done
13:40:18 * ddarius thought Cale was referring to the languages you knew before Haskell.
13:40:20 <monochrom> so you write design patterns instead of code? :)
13:40:36 <dmhouse> dons: pingeroo
13:40:39 <vincenz> monochrom: design patters are holes in a lagnguage
13:40:45 <nmessenger> Zeroth|work: though if you'd like to get your hands dirty start here:
13:40:47 <nmessenger> @wiki Haskell_in_5_steps
13:40:47 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
13:41:06 <monochrom> Every language has a hole.
13:41:25 * Zeroth|work has no idea who Erik Meijer is
13:41:40 <monochrom> The hole is caused by a religion.  The religion of decidability.  "Oh the compiler has to terminate."
13:41:54 * vincenz peers at monochrom 
13:42:03 <vincenz> monochrom: no seriously, many 'design patterns' cease to exist in other languages
13:42:13 <vincenz> cause they can actually be written in the language
13:42:26 <vincenz> it's cause java is so strictly and yet unpowerfully typed
13:42:43 <vincenz> singelton...factories...etc...
13:42:51 <vincenz> all wayss around the language
13:42:56 <monochrom> Haskell enjoys the design pattern of "smart safe constructors"
13:43:01 <Zeroth|work> if I were going to buy an all-in-one haskell book, whats a good one?
13:43:12 <vincenz> monochrom: eh?
13:43:19 <vincenz> Zeroth|work: the freeo ne YAHT
13:43:24 <vincenz> @where yaht
13:43:24 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
13:43:32 * vincenz sighs at his ssh-induced lag to his irc-clent
13:43:52 <opqdonut> haha
13:44:20 <glguy> My ssh is fast, it's when I have to use Tor that I experience the lag pains
13:44:31 <nmessenger> @wiki Books_and_tutorials lists the most recommended ones.
13:44:31 <lambdabot> http://www.haskell.org/haskellwiki/Books_and_tutorials lists the most recommended ones.
13:44:33 <Cale> Zeroth|work: YAHT is pretty good for the early chapters. The Wikibook is also rather good.
13:44:53 <dmhouse> Anyone know how the state for the Haddock plugin in lambdabot gets populated?
13:45:01 <glguy> does lambdabot support mdo?
13:45:16 <vincenz> glguy: my ssh is fafst too, it's the other side
13:45:21 <glguy> ah
13:45:24 <dmhouse> Wait, it's in the State folder.
13:45:29 <Zeroth|work> now I've got something to do all weekend :-)
13:45:51 <nmessenger> I mostly see "School of Expression" and "Craft of FP"
13:46:04 <nmessenger> though I've not read any dead-tree books
13:46:12 <Cale> Zeroth|work: As for physical books, I probably can't make reasoned recommendations, as it's been a while since I looked at the books I had, and I haven't seen it myself, but Graham Hutton's new book looks good: http://www.cs.nott.ac.uk/~gmh/book.html
13:46:13 <lambdabot> Title: Programming in Haskell
13:46:20 <vincenz> Zeroth|work: eh...it's gonna take more than a weekend to grok haskell :)
13:46:54 <Cale> Took me a couple months before I was able to program properly, and about a year to become comfortable, and I already knew 15 other languages.
13:46:54 <monochrom> It takes you N years.
13:46:56 <dmhouse> Zeroth|work: Haskell's a pretty hard language in comparison to most mainstream languages, because it's so different.
13:47:00 <Cale> Still, it was very worth it :)
13:47:08 <monochrom> N is the number of languages you already know.
13:47:18 <vincenz> Cale: liekwise
13:47:19 <Cale> I'm off to dinner :)
13:47:23 <vincenz> not likewise
13:47:25 <Zeroth|work> dmhouse, then I suppose it looks quite nice on a resume in the right employer's hands :-)
13:47:25 <dmhouse> Cale: about the same for me.
13:47:31 <nmessenger> monochrom: so if you've never programmed before, you already know it :D
13:47:33 <dmhouse> Zeroth|work: that's the idea :)
13:48:12 <monochrom> But you already know English or something.  That needs to be unlearned too.
13:48:20 * glguy hopes that it is never the case that people start "learning" Haskell enmass for their resumes
13:48:23 <shapr> Zeroth|work: Heck yeah, Haskell rocks. It's the gateway between programming and computer science!
13:48:44 <chessguy> heh
13:48:48 <chessguy> that doesn't even make sense
13:48:52 <monochrom> But you are right.  If never programmed before, takes no time.
13:49:48 <shapr> chessguy: You mean the gateway comment?
13:49:48 <monochrom> The catch: everyone has programmed before, namely, using mother tongue to instruct other people to do things.  that's programming, though highly broken, and since highly broken, needs the biggest unlearning.
13:49:53 <chessguy> shapr, ya
13:50:07 <shapr> chessguy: Writing php sure isn't CS.
13:50:16 <chessguy> it's not really programming  either
13:50:25 <shapr> It is to some degree.
13:50:36 <nmessenger> THIS NEEDS MONAD TRANSFORMERS AND APPLICATIVE FUNCTORS!!
13:50:47 * shapr staples nmessenger to the floor!
13:50:59 <nmessenger> ow
13:51:01 <monochrom> > floor nmessenger
13:51:01 * chessguy feeds nmessenger some sedatives
13:51:01 <lambdabot>   Not in scope: `nmessenger'
13:51:28 <chessguy> ?remember nmessenger Not in scome: `nmessenger`
13:51:28 <lambdabot> Done.
13:51:36 <chessguy> @quote nmessenger
13:51:36 <lambdabot> nmessenger says: Not in scome: `nmessenger`
13:51:41 <chessguy> d'oh
13:51:42 <nmessenger> scome?
13:51:46 <chessguy> haha
13:51:48 <shapr> chessguy: In any case, Haskell focusses on CS, php does not.
13:51:49 <nmessenger> and LB said that!
13:51:55 <opqdonut> @quote lol
13:51:55 * nmessenger is in a drooling, bloody-stapled heap on the floor.
13:51:55 <lambdabot> glguy says: lol, making lambdabot fight your battles
13:51:58 <opqdonut> @quote lol
13:51:59 <lambdabot> xerox says: > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
13:51:59 <chessguy> nmessenger, no it iddn't
13:52:06 <opqdonut> @quote lol
13:52:07 <lambdabot> glguy says: lol, making lambdabot fight your battles
13:52:12 <opqdonut> ok
13:52:13 <chessguy> > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lo
13:52:13 <lambdabot>  Parse error
13:52:18 <shapr> nmessenger: I'd only staple your clothes to floor, not you directly! That would be cruel.
13:52:20 <chessguy> > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
13:52:21 <lambdabot>  Parse error
13:52:30 <chessguy> xerox--
13:52:37 <monochrom> I staple your hair.
13:52:47 <chessguy> > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") in lol
13:52:47 <lambdabot>  Parse error
13:52:52 <chessguy> bah
13:52:53 <opqdonut> > intersperse 'o' $ cycle "l"
13:52:55 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
13:53:04 <chessguy> opqdonut, nice one
13:53:17 <nmessenger> > cycle "lo"
13:53:18 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
13:53:27 <opqdonut> zipWith (:) (intersperse 'o' $ cycle "l") (intersperse 'o' $ cycle "l")
13:53:31 <opqdonut> > zipWith (:) (intersperse 'o' $ cycle "l") (intersperse 'o' $ cycle "l")
13:53:32 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
13:53:43 <opqdonut> yeah, that's what i thought
13:54:03 <opqdonut> yeah,
13:54:05 <opqdonut> xerox--
13:54:16 <nmessenger> > zipWith ((:[]) . (:)) (intersperse 'o' $ cycle "l") (intersperse 'o' $ cycle "l")
13:54:17 <lambdabot>  Couldn't match expected type `b -> c'
13:54:43 <nmessenger> why is xerox getting decremented?
13:54:51 <chessguy> > map (\(x,y) -> [x]++[y]) $ zip (cycle "l") (cycle "o")
13:54:52 <lambdabot>  ["lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo",...
13:55:02 <chessguy> > concatmap (\(x,y) -> [x]++[y]) $ zip (cycle "l") (cycle "o")
13:55:02 <monochrom> because someone didn't like his code
13:55:03 <lambdabot>   Not in scope: `concatmap'
13:55:09 <chessguy> > concatMap (\(x,y) -> [x]++[y]) $ zip (cycle "l") (cycle "o")
13:55:11 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
13:55:19 <chessguy> stupid scoming rules
13:55:37 <nmessenger> @remember chessguy stupid scoming rules
13:55:37 <lambdabot> Done.
13:55:46 <nmessenger> :P
13:55:52 <chessguy> heh
13:56:46 * chessguy tries to remember what real work he was doing before getting distracted by #haskell
13:56:53 <nmessenger> @botsnack
13:56:54 <lambdabot> :)
13:57:38 <nmessenger> @quote bo\+
13:57:38 <lambdabot> lambdabot says: i 4M THe cooLES+ bo+ e\/eR
13:57:39 <chessguy> hey, i'm pretty proud of myself, i never would've been able to write code like that above code a couple months ago
13:57:55 <chessguy> even if it's crap
13:58:24 <nmessenger> cycle "l" = repeat 'l'
13:58:57 <chessguy> > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l")
13:58:57 <lambdabot>  Parse error
13:59:02 <chessguy> ?type intersperse
13:59:05 <lambdabot> forall a. a -> [a] -> [a]
13:59:18 <nmessenger> no where clause in expressions
13:59:32 <nmessenger> only equations
13:59:53 <chessguy> > let lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol in take 10 lol
13:59:54 <lambdabot>  ["ol","lol","olol","lolol","ololol","lololol","olololol","lolololol","ololol...
14:00:04 <chessguy> still crap
14:00:34 <nmessenger> > iterate ("lo"++) "l"
14:00:37 <lambdabot>  ["l","lol","lolol","lololol","lolololol","lololololol","lolololololol","lolo...
14:01:01 <Vq^> heh
14:01:03 <augustss> > "lol"
14:01:05 <lambdabot>  "lol"
14:01:11 <nmessenger> augustss wins!!
14:01:11 <chessguy> > take 10 $ intersperse 'o' $ cycle "l"
14:01:12 <lambdabot>  "lololololo"
14:01:23 <chessguy> still the best solution
14:01:46 <chessguy> > 'b':cycle "o"
14:01:48 <lambdabot>  "boooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
14:01:55 <nmessenger> nah, cycle "lo" is simpler than intersperse 'o' $ repeat 'l'
14:02:16 <chessguy> but not nearly as much fun :)
14:02:33 <nmessenger> and remember cycle [x] = repeat x !
14:02:48 <augustss> > fix ("lo"++)
14:02:49 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
14:03:29 <nmessenger> hmm, so \xs -> fix (xs++) = cycle xs?
14:03:37 <nmessenger> seems right
14:03:52 <ndm> @quickcheck \xs -> fix (xs++) = cycle xs
14:03:52 <lambdabot> Unknown command, try @list
14:04:03 <nmessenger> the conses!  They are numerous!
14:04:07 <chessguy> ?help check
14:04:07 <lambdabot> check <expr>
14:04:07 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
14:04:17 <chessguy> haha
14:04:22 <chessguy> ?help check
14:04:23 <lambdabot> check <expr>
14:04:23 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
14:04:31 <chessguy> nice
14:04:34 <ndm> @tell dons "You have QuickCheck and 3 seconds. TEST something" - proof is way too strong
14:04:34 <lambdabot> Consider it noted.
14:04:56 <chessguy> @remember lambdabot You have QuickCheck and 3 seconds. Prove something
14:04:56 <lambdabot> Done.
14:05:01 <nmessenger> @help scheck
14:05:02 <lambdabot> scheck <expr>
14:05:02 <lambdabot> You have SmallCheck and 3 seconds. Test something.
14:05:14 <ndm> now smallcheck is an _actual_ proof
14:05:18 <nmessenger> too bad (==) breaks on infinite lists
14:05:23 <monochrom> @tell dons I like "You have QuickCheck and 3 seconds. Prove something."
14:05:24 <lambdabot> Consider it noted.
14:05:46 <ndm> (for small finitely enumerable values)
14:05:50 <chessguy> ok, time to get back to the real world.
14:06:23 <QtPlatypus> Does haskell have a built in set type, or an idomatic way of implementing sets?
14:06:31 <ndm> ok, time to get back to a fake academic world for me :)
14:06:33 <nmessenger> the RealWorld?  What's that?  Isn't that an implementation detail?
14:06:34 <ddarius> No, ?, Data.Set.
14:06:35 <ndm> @hoogle Set
14:06:36 <lambdabot> Data.Set :: module
14:06:36 <monochrom> quickcheck is an actual proof for randomly picked values.
14:06:36 <lambdabot> Data.Set.Set :: data Set a
14:06:36 <lambdabot> Distribution.Setup :: module
14:07:08 <ndm> QtPlatypus: people often use lists for idiomatic sets, or you can use Data.Set - depends on what you want to do
14:07:39 <ddarius> Actually, sorted lists are not a bad representation of sets.
14:07:50 <ndm> ddarius: but sorted means more work processing them
14:09:58 <dons> QtPlatypus: we have lists and Data.Set
14:10:06 <ddarius> ndm: ?  It means more constraints, but by maintaining sortedness (and no duplicates?) it can be rather quick.
14:10:09 <dons> > S.toSet [1,2,1,2,3,42,1,2,1]
14:10:10 <lambdabot>   Not in scope: `S.toSet'
14:10:21 <emu> > S.fromList [1,2]
14:10:22 <dons> > S.fromList [1,2,1,2,3,42,1,2,1]
14:10:22 <lambdabot>   Not in scope: `S.fromList'
14:10:23 <lambdabot>   Not in scope: `S.fromList'
14:10:26 <emu> boo
14:10:30 <dons> > Set.fromList [1,2,1,2,3,42,1,2,1]
14:10:31 <lambdabot>   Not in scope: `Set.fromList'
14:10:36 <ndm> ddarius: i know, its trading quickness for simplicity - and usually if you care enough, its best to move to Data.Set
14:10:36 <dons> > Data.Set.fromList [1,2,1,2,3,42,1,2,1]
14:10:37 <lambdabot>  fromList [1,2,3,42]
14:10:47 <quicksilver> ddarius: maintaining sortedness is very expensive, though
14:10:58 <quicksilver> ddarius: inserting an element becomes O(n) for example
14:11:14 <ndm> quicksilver: but merge becomes O(n) as well, its a trade off scenario
14:11:29 <ddarius> ndm: The sorted list representation is fairly simple as well.
14:12:02 <nmessenger> oh noes! ioerror! somebody catch him!
14:12:06 <quicksilver> ndm: merge is O(n) for most set reps though, isn't it? e.g. trees or whatever
14:12:43 <rashakil> yes it is
14:12:56 <LoganCapaldo> merge could be O(log n) if you were willing to ruin the future
14:12:59 <LoganCapaldo> heh
14:13:45 <LoganCapaldo> no wait
14:13:51 <LoganCapaldo> no it couldn't
14:13:58 <LoganCapaldo> oh well
14:14:36 <dons> wow, jyp++ jyp++
14:14:37 <dons> -->
14:14:38 <dons> Thu Mar  1 19:02:07 CET 2007  jeanphilippe.bernardy@gmail.com
14:14:38 <dons>   * Add possibility to dynamically interpret Editor actions
14:14:38 <dons>   This means Yi is fully scriptable in haskell.
14:14:41 <dons>   Editor expression evaluation is bound to M-x in emacs mode.
14:14:54 <ndm> quicksilver: not unordered lists, if you want to guarantee that they don't have dupes in the result
14:14:59 <LoganCapaldo> egads
14:15:00 <ddarius> @where yi
14:15:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
14:15:11 <sieni> @karma dons
14:15:11 <lambdabot> dons has a karma of 123
14:15:13 <sieni> dons++
14:15:15 <sieni> @karma dons
14:15:16 <lambdabot> dons has a karma of 124
14:15:26 <thorat> thorat++
14:15:35 <dons> thorat: doesn't work like that ;)
14:15:39 <thorat> hahah
14:15:50 <nmessenger> @karma+ nmessenger
14:15:50 <dons> ?karma thorat
14:15:50 <lambdabot> You can't change your own karma, silly.
14:15:51 <lambdabot> thorat has a karma of 0
14:16:10 <LoganCapaldo> thorat: yeah you have to do /nick NotThorat first :)
14:16:24 <nmessenger> LoganCapaldo: shush!  That's my evil trick!
14:16:44 <dons> ?users
14:16:44 <lambdabot> Maximum users seen in #haskell: 332, currently: 315 (94.9%), active: 50 (15.9%)
14:16:54 * ddarius might actually get some papers read and Haskell coded on the flight to Hawaii.
14:17:24 <ddarius> Of course, that will be followed by a week of leaving you all to your own devices and not looking at research papers, theses, or code at all.
14:17:43 <monochrom> hurray
14:18:11 * ddarius is also happy that he won't be here.
14:20:21 <dons> ndm: so any thoughts on improving yhc performance ?
14:20:27 <dons> i'm keen to bring those numbers down.
14:20:45 <dons> ndm: nhc keeps improving .... (see the bytestring support!)
14:20:49 <ndm> dons: we need to figure out the regression, but darcs won't let us get at old copies of Yhc, so we can't comparatively benchmark...
14:21:15 <dons> how about fp/bytestring support?
14:21:17 <ndm> dons: we also have some -O support, the code is getting there slowly to do the recompilation
14:21:21 <dons> could you steal the patches from nhc?
14:21:31 <dons> ah, so you're working on a quick optimiser?
14:21:36 <ndm> but no optimisations yet, although there are various ones floating around
14:21:40 <ndm> there are a few issues
14:21:49 <dons> yhc doesn't have an interactive mode, does it?
14:21:52 <ndm> 1) the runtime is 20% slower than it should be - that's tom's problem
14:22:08 <ndm> 2) optimising Yhc Core - thats my problem
14:22:09 <dons> ok.
14:22:17 <ndm> 3) compiling Yhc Core - thats almost done
14:22:27 <ndm> once 3 is done, we can add a -O flag, and run the simplifier and inliner on it
14:22:38 <ndm> number 2 is a chapter of my phd
14:22:49 <ndm> number 1 is outside my hands, but if darcs worked it would be a lot easier!
14:24:10 <dons> i don't understand, can't you rollback a month at a time till it starts going slow :-)
14:24:43 <ndm> dons: we have a particular tag, but darcs doesn't seem to let us get at it
14:24:59 <ndm> dons: it entirely ignores the --tag command
14:25:13 <dons> hmm. what tag?
14:25:19 <dons> i might have a look today.
14:28:15 <ndm> dons: "Stable 1"
14:28:26 <ndm> dons: if you check out that version it should be 20% faster
14:28:40 <dons> ok. i'll see if I can do that.
14:33:08 <tibbe> I'm trying to get HXT to parse html documents but without much luch
14:33:11 <tibbe> luck*
14:33:44 <tibbe> there are a couple of different function, parseHtmlDocument, readDocument, etc and although the first one sounds right it doesn't work
14:34:02 <dino-> tibbe: I haven't been doing html documents, but I have been using that stuff lately. What's it doing?
14:34:07 <dons> tibbe: hmm, should be really simple, afaik. have you got a) the src and b) seen Cale's feed aggreagator demo?
14:34:26 <Cale> readDocument
14:34:28 <glguy> or my adaptation into a happs application? :)
14:34:29 <dino-> That would be reading in XML, though, that hrss thing.
14:34:46 <Cale> I think the relevant option is a_parse_html
14:35:37 <tibbe> dons, yes and yes
14:35:39 <tibbe> Cale, ok
14:35:52 <tibbe> also it's a bit unclear what attribute values to use
14:35:59 <tibbe> I've seen v_1 and "1"
14:36:06 <Cale> v_1 = "1"
14:36:10 <tibbe> my current theory is that they are equivalent
14:36:12 <tibbe> :)
14:36:21 <tibbe> and 1 = True
14:36:33 <Cale> I think the abstraction is only there in case it's replaced by a less-stupid mechanism in the future.
14:36:35 <tibbe> how about partial documents?
14:37:12 <Cale> partial documents?
14:37:23 <tibbe> ie no <html> tag
14:37:36 <tibbe> a part of the tree
14:37:42 <tibbe> a few elements
14:37:45 <Cale> Should be okay.
14:37:50 <tibbe> hmm
14:37:58 <Cale> Turn off validation too
14:38:05 <tibbe> yeah
14:38:12 <tibbe> I'll run some more tests
14:38:41 <tibbe> sometimes I miss """ strings for testing
14:38:42 <ADEpt> @hoogle String -> ByteString
14:38:43 <lambdabot> No matches, try a more general search
14:39:35 <hpaste>  vincenz pasted "Odd ghc error" at http://hpaste.org/766
14:39:46 <largos> is anyone aware of any haskel window manager / desktop shell projects?
14:39:46 <vincenz> Anyone know anything about that error?
14:40:27 <dons> there are both, yes.
14:40:32 <dons> shells you can find on haskell.org
14:40:43 <vincenz> dons: Any comments on that error?
14:40:51 <Cale> vincenz: maybe out-of-date interface files are getting left around?
14:40:52 <dons> for a window manager, there's a complete one distributed with the House haskell kernel
14:40:55 <largos> ah, cool :) (that was a completely random question -- just popped to mind)
14:41:00 <dons> and sjanssen's working on one.
14:41:05 <vincenz> Cale: hmm... don't thik so
14:41:06 <dons> we hope to rewrite dwm in haskell
14:41:10 <tibbe> @paste
14:41:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:41:14 <nmessenger> if it's ONLY for testing, you could do: testString = unsafePerformIO (readFile "testFile") -- again, ONLY TESTING!!
14:41:38 <vincenz> Cale: well yes, but nothing else is recompiling
14:41:49 <vincenz> basically I have a GADT
14:41:52 <hpaste>  tibbe pasted "HTML parsing attempt" at http://hpaste.org/767
14:41:59 <vincenz> data AST :: * -> * -> * where
14:42:08 <vincenz>   ABC :: String -> AST ABC_ tag
14:42:18 <vincenz>     Tag :: tag -> AST a tag -> AST a tag
14:42:26 <vincenz> and it's that 'tag' bit that it's complaining about
14:42:34 <largos> dons: ah.. it came to mind when I ran across your fully dynamic applicaitions in haskell paper.
14:42:37 <tibbe> could someone please have a look
14:42:49 <tibbe> I've stared at it for too long, probably something obvious
14:44:25 * vincenz grumbles "Never stay too long at the office, you risk that it starts raining"
14:44:34 <Cale> hmm
14:45:05 <glguy> > let wrds = filter (not . null) . snd . foldr aux ([],[]) where aux x | isSpace x = (,) [] . uncurry (:) | otherwise = first (x:) in wrds " | otherwise = first "
14:45:06 <lambdabot>  ["|","otherwise","=","first"]
14:45:10 <vincenz> Cale: I guess cause 'tag' is localized?
14:45:24 <tibbe> Cale, see something wrong?
14:45:50 <tibbe> don't assume I know what I'm doing, I don't ;)
14:46:04 <glguy> > let wrds = filter (not . null) . snd . foldr aux ([],[]) . (' ':) where aux x | isSpace x = (,) [] . uncurry (:) | otherwise = first (x:) in wrds "| otherwise = first " -- fixed
14:46:06 <lambdabot>  ["|","otherwise","=","first"]
14:47:00 <chessguy_work> glguy, looks like the same result to me :)
14:47:46 <glguy> chessguy_work: that's because the input changed
14:47:52 <glguy> > let wrds = filter (not . null) . uncurry (:) . foldr aux ([],[]) where aux x | isSpace x = (,) [] . uncurry (:) | otherwise = first (x:) in wrds "| otherwise = first " -- same fix
14:47:53 <lambdabot>  ["|","otherwise","=","first"]
14:48:06 <tibbe> my understanding of arrows is not good enough to understand why that doesn't work
14:48:31 <norpan> i think of arrows as functions
14:48:40 <dmhouse> That's a good intuition.
14:49:11 <tibbe> norpan, me too but it doesn't work right now :)
14:49:23 <tibbe> I really liked the conveyor belt tutorial
14:49:24 <norpan> that's too bad
14:49:59 * ddarius thinks of arrows as the arrows of a Freyd category.
14:50:08 <dino-> I liked that too, but got lost when it got to the static/dynamic parser part.
14:50:14 <Cale> tibbe: Okay, it's something to do with the url extraction
14:51:01 <Cale> tibbe: commenting out "url <- maybeA ..." as well as "href = ..." and replacing the url in the output with Nothing ends up getting a result.
14:51:18 <Cale> So I suspect that perhaps maybeA isn't doing its job?
14:51:59 <Cale> oh, no, that's not it
14:52:07 <Cale> atClass "url" is failing completely
14:52:14 <Cale> so there's no way to recover
14:52:18 <chessguy_work> ?hoogle atClass
14:52:19 <lambdabot> No matches found
14:52:24 <Cale> so you want to wrap that whole thing in maybeA
14:52:37 <Cale> aha
14:52:40 <Cale> url <- maybeA (href <<< atClass "url") -< x
14:52:42 <Cale> like that
14:52:46 <Cale> then it works
14:53:18 <Cale> (do you see why?)
14:53:43 <tibbe> Cale, hmm
14:54:09 <tibbe> yes :)
14:54:13 <tibbe> I see it now
14:54:15 <tibbe> thanks!
14:54:36 <Cale> maybeA href will produce Nothing in the event that href fails to produce a result, but the maybeA href never gets a result to process in the first place.
14:54:41 <tibbe> I was thinking that maybeA probably exist already, does it?
14:54:50 <Cale> hmm, good question
14:55:33 <Cale> Doesn't look like it.
14:55:49 <Cale> There's a lot of stuff which you'd expect to find in the arrow libraries which is mysteriously missing.
14:56:05 <vincenz> Lemmih: join #oasis
14:56:06 <tibbe> :)
14:56:13 <tibbe> could it be more general?
14:56:22 <tibbe> or written in a better way or with a better name?
14:56:25 <dino-> You were saying that the other day, a lot of things from HXT's Control.Arrow?
14:57:02 <tibbe> I'm thinking of writing something that's helpful to do XML -> record conversions
14:57:09 <tibbe> a very common use case I'd say
14:57:35 <ddarius> replace Just with return and Nothing with fail?
14:57:45 <Cale> ugh, not fail!
14:57:51 <ddarius> mzero I mean
14:57:56 <Cale> :)
14:58:03 <norpan> fail is ugly
14:58:23 <ddarius> norpan: yes
14:59:30 <largos> does anyone have suggestions for xml editors? (perhaps the wrong place to ask.. but with the increase in haskell web programming I thought I'd ping the channel..)
14:59:55 <tibbe> hmm
14:59:58 <tibbe> I use emacs
15:00:11 <Cale> I use vim :)
15:00:20 <tibbe> "use"
15:00:21 <Cale> (and occasionally emacs too :)
15:00:26 <largos> tibbe: what major mode do you use? sgml is so-so, and I haven't found anything better :(
15:00:30 <int-e> Avoid XML ;)
15:00:34 <lordl> nxml-mode
15:00:39 <tibbe> largos, nxml
15:00:41 <tibbe> eh
15:00:44 <largos> ok, I'll check that out
15:01:01 * tibbe sends and inverted nxml-mode message to cancels lordl's message.
15:01:04 * tibbe wins.
15:01:08 <Cale> I've never touched an XML file that didn't fit on a screen though.
15:01:24 <Cale> If I did, I'd do it with a program. :)
15:01:49 <largos> Cale: yeah, I've been living "in" xmlstarlet lately -- processing 20-100mb xml files :(
15:02:20 <Cale> That's definitely not the sort of scale of thing you want to edit by hand.
15:02:21 <largos> but it'd be very nice to have emacs-like scratch buffers for collecting the output of xpath/xslt queries
15:02:43 <merus_> emacs ftw
15:02:45 <JohnMeacham> dons: ah. I didn't introduce a new bug, my new backend is just more picky about its input thus exposing a previous bug. that is nice, I know I am not making things worse at least
15:02:59 <Cale> I'd probably use HXT ;)
15:03:04 <vincenz> Any GHC expert around?
15:03:05 <largos> hehe
15:03:20 <LoganCapaldo> Would HAppS be an appropiate platform for a MUD?
15:03:28 <LoganCapaldo> Or is it all HTTP?
15:04:09 <largos> LoganCapaldo: iirc, it can do other protocols.
15:04:12 <ddarius> @google higher order programming in xslt
15:04:17 <lambdabot> http://www.idealliance.org/papers/extreme/Proceedings/html/2006/Novatchev01/EML2006Novatchev01.html
15:04:18 <lambdabot> Title: Proceedings of Extreme Markup Languages&reg;
15:04:59 <largos> ddarius: interesting link
15:05:15 <dmhouse> LoganCapaldo: it can do about a thousand and one protocols, which is one of my frustrations with it.
15:05:38 <ddarius> largos: There's a more entertaining version around.
15:06:02 <ddarius> Half a page of Haskell reproduced in 76 pages of XSLT
15:06:45 <ddarius> To give it some credit, actually using the HOFs isn't -that- bad.
15:07:00 <vincenz> dmhouse: come to #oasis?
15:07:19 <int-e> @quote XSLT
15:07:19 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
15:08:01 <Gwern> does it make sense to go like this:
15:08:02 <Gwern>  where
15:08:03 <Gwern>       x = replicate (length z) article
15:08:03 <Gwern>       z = generateCaps article
15:08:21 <ddarius> Gwern: Why not?
15:08:33 <Gwern> ddarius: I was unsure I could call z before it was defined
15:09:01 <ddarius> Gwern: All binding forms (other than do-notation, but mdo...) are mutually recursive.
15:09:27 <ddarius> > let a = 1 : b; b = 0:a in a
15:09:28 <lambdabot>  [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
15:09:41 <fantasma> is there a faster way to do a sieve than: sieve (x:xs) = x : sieve [ y | y <- xs, y `mod` x > 0 ]
15:09:43 <ddarius> Gwern: Occasionally, that bites you in the ass though.
15:09:51 <Gwern> ddarius: what should I watch out for?
15:10:27 <nmessenger> > let x = x + 1 in x -- '=' isn't assignment!
15:10:28 <lambdabot>  Exception: <<loop>>
15:10:31 <ddarius> Occasionally, usually when you are reusing variable names, you'll write something like x = f x when you mean something more like x' = f x
15:10:45 <Gwern> righto then
15:10:53 <int-e> fantasma: there is a recent thread on haskell-archive about prime sieves. in short, yes it's possible to do much better thant that.
15:11:06 <Gwern> I'm actually kind of proud I figured out how to use zipWithM_ all by myself
15:11:34 <fantasma> int-e, thanks I will check there
15:11:34 <dmhouse> Gwern: nice :) Haskell is good like that, there's always a challenge for when you need one.
15:11:53 <fantasma> @where haskell-archive
15:11:54 <lambdabot> I know nothing about haskell-archive.
15:11:54 <Gwern> it makes me feel a little better after things like that mess with HSH earlier today
15:12:07 <fantasma> @google haskell-archive
15:12:10 <lambdabot> http://www.haskell.edu/archive/haskell_archive.htm
15:12:10 <lambdabot> Title: Haskell Archive
15:12:11 <int-e> fantasma: in long, look at the thread starting here: http://www.haskell.org/pipermail/haskell-cafe/2007-February/022347.html
15:12:13 <lambdabot> Title: [Haskell-cafe] Optimization fun, http://tinyurl.com/2xxrpz
15:12:40 <Gwern> (not to be too cliched, but it certainly seems true for my current program at least, the longer you work on them the shorter they get)
15:12:42 <int-e> @where haskell-cafe
15:12:43 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
15:12:52 <sorear> hello.
15:13:13 <tibbe> @pl foldr (\(a,b) y -> if not a then (a,b) else y)
15:13:14 <lambdabot> foldr (uncurry (ap ((.) . if' . not) (,)))
15:13:17 <tibbe> eh
15:13:41 * LoganCapaldo decides to ask in #happs
15:14:35 * LoganCapaldo notices that happs is a subset of #haskell
15:16:23 <fantasma> my processor is going to hate me after calculating a million primes with this crappy algorithm
15:18:14 * fantasma will come back in an hour
15:23:42 * kc5tja would like to fine a complaint against himself.  I've been meaning to continue to hack on my Haskell stuff, but have been entirely too busy doing other things.  This is unacceptable and must be stopped.  I'll have to get right on this issue, as soon as I'm done with my other projects.
15:23:43 <tibbe_> records are suprisingly poorly documented
15:23:53 <notsmack> @where hsxml
15:23:53 <lambdabot> I know nothing about hsxml.
15:24:23 <largos> @where haxml
15:24:24 <lambdabot> http://haskell.org/HaXml
15:24:30 <tibbe_> I'm trying to "update" a record
15:25:24 <dmhouse> tibbe_: let rec = oldrec { field = newval }
15:25:26 <dmhouse> E.g.:
15:25:39 <ddarius> @oldwiki UsingRecords
15:25:39 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
15:25:45 <dmhouse> data Record = RConst { int :: Int, bool :: Bool }
15:25:53 <dmhouse> r1 = RConst { int = 3, bool = False }
15:25:56 <tibbe_> dmhouse, thanks
15:25:58 <dmhouse> r1 = r1 { bool = True }
15:26:06 <dmhouse> Err, I meant r2 = r1 { bool = True }
15:26:12 <nmessenger> infinite loop!
15:26:24 <dmhouse> Then r2 = RConst { int = 3, bool = True }.
15:26:54 <nmessenger> which also = RConsts 3 True
15:27:02 <dmhouse> Yep.
15:27:05 <nmessenger> s/s//
15:27:07 <dmhouse> You can pattern match like this:
15:27:16 <dmhouse> foo :: Record -> Bool
15:27:23 <dmhouse> foo (RConst { bool = b }) = b
15:27:34 <dmhouse> Which is the same as writing foo _ b = b, but clearer.
15:27:44 <nmessenger> foo (RConst _ b) = b
15:27:50 <dmhouse> Yeah, sorry.
15:27:55 <ddarius> > case "a" of ((:) {}) -> "foo"
15:27:57 <lambdabot>  "foo"
15:27:58 <dmhouse> Note that foo = bool, as well (as bool doubles up as a selector function).
15:28:16 <ddarius> Holy crap! That was the right syntax?=
15:29:37 <int-e> ddarius: _:_ is prettier
15:29:41 <largos> ddarius: huh, how does that line parse?
15:30:02 <int-e> largos: the pattern uses record syntax, specifying a constructor but no fields
15:30:07 <largos> is {} bottom?
15:30:13 <ddarius> int-e: I was just trying to think up a standard data constructor with two or more fields.
15:30:17 <largos> hm..
15:30:35 <SamB> (,)
15:30:41 <ddarius> largos: You can use record pattern matching syntax on constructors without named fields.
15:30:46 <largos> oh.. I see.  (_:_) is a list where you ignore both the head and tail
15:30:53 <SamB> oh, record constructor?
15:30:58 <nmessenger> *grumble*
15:31:18 <largos> my mental haskell parser needs much training...
15:31:20 <SamB> ddarius: I believe you have accidentally invoked a GHC extension
15:31:31 <ddarius> SamB: I don't believe that that's a constructor name. (:) definitely is.
15:31:47 <ddarius> SamB: Possibly.
15:31:58 <SamB> that (:) {} thing
15:31:58 <rag3> hi guys
15:32:12 <sorear> SamB: Don't be silly! Lambdabot runs with -fno-glasgow-exts! (Sigh, if only it were that easy :( )
15:32:15 <SamB> I'm pretty sure it is a GHC extension for that to be usable with non-record constructors
15:32:23 <ddarius> > case ('a',32) of ((,) {}) -> "foo"
15:32:24 <lambdabot>  "foo"
15:32:26 <int-e> largos: the usual use of that syntax is when you have, say   data Foo = Foo { fooVal :: Int, fooStr :: String } and you want to extract just fooVal:   case foo of Foo { fooVal = i } -> <expression using i>
15:32:34 <nmessenger> last thing I tried to say was before disconnected was: ":O !! I think I just now understand the Contructor {} pattern!"
15:32:42 <rag3> @version
15:32:42 <lambdabot> lambdabot 4p509, GHC 6.6 (OpenBSD i386)
15:32:42 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:32:49 <sorear> > bitSize 0
15:32:50 <lambdabot>  Add a type signature
15:32:55 <sorear> > bitSize $ 0::Word
15:32:56 <lambdabot>  Couldn't match expected type `Word' against inferred type `Int'
15:33:00 <nmessenger> (,) {} --(desugarer)--> (,) _ _
15:33:01 <sorear> > bitSize (0::Word)
15:33:03 <lambdabot>  32
15:33:05 <sorear> :(
15:33:07 <int-e> largos: but you don't have to specify any record selector in the {}, so  Foo {}  is a valid pattern. (:) {}  is just another step in that direction.
15:34:15 <rag3> @why
15:34:15 <lambdabot> Maybe you meant: ghc what wn
15:34:55 <rag3> @quote rag3
15:34:55 <lambdabot> No quotes match. You speak an infinite deal of nothing
15:35:01 <rag3> ahahah
15:35:07 <ddarius> @quote Darius
15:35:07 <nmessenger> apropos
15:35:07 <lambdabot> No quotes match. Where did you learn to type?
15:35:14 <ddarius> @quote darius
15:35:14 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
15:35:19 <ddarius> @quote ddarius
15:35:20 <lambdabot> No quotes match. Do you think like you type?
15:35:39 <rag3> ddarius: brilliant quote
15:35:42 <sorear> @quote
15:35:43 <lambdabot> state says:  ?. ++ . read . show . state ?. ++ . read . show . state
15:35:51 <int-e> @poll-show cheeky-off
15:35:51 <lambdabot> ["MakeItAbuseCowboyNeal","AddFlag","No","Yes"]
15:35:54 * ddarius wonders how the @quote database was initialized.
15:36:08 <int-e> @poll-result cheeky-off
15:36:08 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=1, AddFlag=2, No=4, Yes=13
15:36:13 <rag3> @remember
15:36:14 <lambdabot> Incorrect arguments to quote
15:36:28 <rag3> @remember lambdabot test
15:36:28 <lambdabot> Done.
15:36:34 <rag3> @quote lamdbabot
15:36:35 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
15:36:42 <rag3> @quote lambdabot
15:36:42 <lambdabot> lambdabot says: Occurs check: cannot construct the infinite type: a
15:36:55 <ddarius> People don't want lambdabot to be cheeky?
15:37:01 <rag3> @quote test
15:37:01 <lambdabot> bos says: [dons] and stricify, specialise and inline as appropriate till the raw bytestring Addr# start appearing [bos] um, is that next to the dilithium crystals?
15:37:02 <nmessenger> @quote lambdabot test
15:37:02 <lambdabot> lambdabot says: test
15:37:18 * LoganCapaldo waits for a type system that _can_ construct infinite types
15:37:22 <int-e> @quote ghc
15:37:22 <lambdabot> ghc says: Simplifier reached fixed point
15:37:38 <ddarius> LoganCapaldo: It's not hard at all.
15:37:39 <sorear> http://members.cox.net/stefanor/fixtypes/
15:37:40 <lambdabot> Title: Directory listing
15:37:45 <sorear> LoganCapaldo: or just use ML
15:37:50 <sorear> I re-invented it
15:37:51 <nmessenger> LoganCapaldo: they'd have to have finite kinds or the compiler'd diverge.
15:38:01 <ddarius> You kinda have to go out of your way to avoid them.
15:38:13 <LoganCapaldo> I wasn't being all that serious <g>
15:38:20 <sorear> nmessenger: well GHC already diverges, what's the big deal? :)
15:38:27 <LoganCapaldo> but thats what I get for saying things like that in this channel
15:38:38 <nmessenger> @slap LoganCapaldo
15:38:39 * lambdabot slaps LoganCapaldo
15:38:51 <LoganCapaldo> such violence
15:39:01 * LoganCapaldo turns the other cheek
15:39:16 <ddarius> LoganCapaldo: You do realize it's a daily occurrence for infinite datastructures to be played around with here.  I don't think any other IRC channel does that.
15:40:20 <nmessenger> @. elite protontorpedo
15:40:20 <lambdabot> h0\/\/ d30$ HasKel| DiphphEr phR0m m| OR 1iSP?
15:40:36 <LoganCapaldo> ddarius: I'm pretty sure what you just said was in perfect accordance with everything I've said :)
15:42:25 <ddarius> I know.
15:43:56 <int-e> @quote dibblego logic
15:43:56 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
15:44:09 <nmessenger> :)
15:45:17 <chessguy> > "i'm b" ++ (replicate 5 'a') ++ "ck"
15:45:19 <lambdabot>  "i'm baaaaack"
15:45:27 <chessguy> bah
15:45:32 <chessguy> > "i'm b" ++ (replicate 15 'a') ++ "ck"
15:45:34 <lambdabot>  "i'm baaaaaaaaaaaaaaack"
15:45:40 <chessguy> much more dramatic
15:45:55 <tibbe_> @srcs and
15:45:55 <lambdabot> and   =  foldr (&&) True
15:46:04 <Zeroth404> what advantages does haskell have over a procedural language?
15:46:13 <int-e> > map ("i'm b" ++) (iterate ('a':) "ack")
15:46:14 <lambdabot>  ["i'm back","i'm baack","i'm baaack","i'm baaaack","i'm baaaaack","i'm baaaa...
15:46:27 <newsham> > zipWith (++) (iterate (++"a") "i'm ba") (const "ck")
15:46:28 <lambdabot>  Couldn't match expected type `[[Char]]'
15:46:34 <nmessenger> > printf "i'm b%sck!" (replicate 20 'a') :: String
15:46:36 <lambdabot>  "i'm baaaaaaaaaaaaaaaaaaaack!"
15:46:45 <Japsu> hehe
15:47:32 <merus_> lol.
15:47:47 <nmessenger> Zeroth404: one simple thing is that pure functions are much more restricted, so the compiler optimizes the *fsck* out of 'em.
15:47:59 <largos> > :t const
15:48:00 <lambdabot>  Parse error
15:48:47 <Zeroth404> nmessenger: so haskell would be an ideal language to write a game engine?
15:48:50 <tibbe_> > foldr ((&&) . fst) (True,"") [(True,"hi")]
15:48:51 <lambdabot>  Couldn't match expected type `Bool' against inferred type `(a, b)'
15:49:19 <largos> Zeroth404: pure functional programming also lets you keep a *much* smaller set of variables / state in mind, since you don't have to worry about side effects
15:49:29 <nmessenger> http://haskell.org/haskellwiki/Libraries_and_tools/Games
15:49:30 <lambdabot> Title: Libraries and tools/Games - HaskellWiki
15:50:41 <ddarius> @index enumWindows
15:50:42 <lambdabot> bzzt
15:50:52 <ddarius> @index findWindow
15:50:52 <lambdabot> bzzt
15:51:19 <nmessenger> unfortunately, execution order is *entirely different* from what you're used to, so optimizing enough for game-ish things would take practice.
15:51:42 <yip> yeah, performance is probably the biggest problem for haskell in game programming
15:52:03 <chessguy> s/in game programming/
15:52:06 <chessguy> s/in game programming//
15:52:21 <yip> that, and also lack of tools/support/libraries. like, you don't have much options for integrating a scripting language into your haskell game engine
15:52:22 <Zeroth404> nmessenger: how in the world can you write a program that doesnt do things in order?
15:52:32 <yip> Zeroth404: it's called functional programming =)
15:52:43 <nmessenger> Zeroth404: it does do things in order, you just have to get used to a different order.
15:53:05 <Zeroth404> add a to b, then devide b by 3; or, it might device b by 3 first, then add a to b......
15:53:10 <yip> but haskell has the clear advantage that it's the most powerful mainstream languages, and you can use concepts like functional reactive programming that aren't possible in any other language
15:53:11 <Zeroth404> there MUST be soem order
15:53:20 <chessguy> Zeroth404, there is
15:53:24 <yip> Zeroth404: it's just like mathematical equations
15:53:25 <Syzygy-> Zeroth404: It fetches all dependencies before calculating each step.
15:53:26 <chessguy> Zeroth404, nobody said there isn't
15:53:29 <allbery_b> there is an order.  it's data dependency order
15:53:38 <allbery_b> based on I/O actions
15:53:52 <Syzygy-> So > (a+b)/3 is divide_by(add(a,b),3) - and before divide_by can execute, we need the result of add.
15:53:53 <chessguy> or other actions
15:53:56 <ddarius> yip: -Techniques- to optimizing Haskell code performance are the bigger issue.
15:54:04 <nmessenger> I/O actions and State actions are there for when you need to specify "x then y then z"
15:54:07 <allbery_b> this order may have little to do with what order you wrote things in
15:54:24 <yip> ddarius: hm.... i would prefer for compilers to get smarter about optimizations. there is a *ton* of room for them to improve
15:54:40 <augustss> yep
15:54:41 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
15:54:59 <nmessenger> (though they're not magical, they use some strange-sounding techniques to acheive this, but it's all plain Haskell)
15:55:01 <Syzygy-> One illustrative easy point to this is the expressio (a+b)/(c+d) -- a+b and c+d must both be evaluated before the division, but their relative order is not under the control of the programmer in pure functional programming.
15:55:41 <ddarius> yip: The compilers are pretty smart, people just aren't used to coding for Haskell.  If you took (some) idiomatic Haskell and translated it to C++ (say) and compiled it, it would be ridiculously inefficient.
15:56:16 <yip> ddarius: yes, but you shouldn't have to code haskell in the style of c if you want good performance
15:56:54 <ddarius> yip: That's not what I was saying.  I'm saying most people -do- code Haskell in the style of C (or somewhat higher languages) and -don't- get performance.
15:57:17 <nmessenger> Not to say Haskell is *incapable* of performance, it's just not immediately obvious how to acheive it for a beginner.  The shootout code compares reasonably well with C.
15:57:59 <yip> ddarius: in my experience, if you want to do a simulation type program with haskell, you can forgot about pure functions of type World -> World, and you will have to use mutable IORefs or STRefs, or mutable arrays.
15:58:09 <yip> this is if you want good performance
15:58:36 <int-e> at which point I think I'd rather code in C :/
15:58:39 <chessguy> ?where hat
15:58:39 <lambdabot> http://www.haskell.org/hat/
15:58:40 <yip> this is why the haskell shootout code is fast. because it is coded in an imperative style
15:58:42 <ddarius> yip: So?  That doesn't mean you are writing in C.
15:59:16 <yip> right. imperative haskell is still nicer then c. but it would be even nicer if ghc were able to compile pure much faster :)
15:59:18 <chessguy> ?where haskellgui
15:59:19 <lambdabot> I know nothing about haskellgui.
15:59:37 <LoganCapaldo> plus you could always write pure code and transform it to the imperative when you were done :)
16:00:12 <sorear> and PLEASE remember the 90/10 rule
16:00:13 <yip> LoganCapaldo: yes, this is an interesting approach, and i guess it's possible with template haskell. the future though, is for the compiler to do this automatically
16:00:15 <sorear> think of the kittens
16:00:26 <chessguy> ndm, what's your website again?
16:00:32 <sorear> @where catch
16:00:33 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
16:00:37 <chessguy> ah, there it is
16:00:42 <sorear> drop the last two components
16:00:42 <hpaste>  vincenz pasted "Failing on GHC -- bug" at http://hpaste.org/769
16:00:46 <qwr> int-e: ML is much nicer than C
16:01:04 <nomeata> OT, but seems useful for an Haskell-Article-Reader: What program do you recommand for this use case: I see an online article (PDF or HTML). I want a very quick way to save it, together with simple meta information (mostly the URL and maybe tags). The articles should be stored on my hard drive and also be full-text searchable. Console programs perferred.
16:01:38 <sorear> google! :)
16:01:46 <nomeata> :-)
16:01:59 * ddarius made a full-text database for his papers once.
16:02:08 <nomeata> Iâve started writing it in bash, but after 80 lines I thought that something like this got to exist already.
16:02:08 <timthelion> so if a list is {n = x : y : z : []} then if you do {n : k : []} then will you have problems because there is a [] between the z and the k?  if so, how do I remove the [] from the end of a list?
16:02:10 <emu> i know of a tleas tone person who uses gmail to do that
16:02:11 <sorear> I actually had a script google 'foo bar' that invoked elinks :)
16:02:13 <MarcWebe2> nomeata: Add another file doc.info where you add additional info ;)
16:02:26 <ddarius> It was interesting.  But generally I just keep a text file of the titles and file names.
16:02:34 <nomeata> MarcWebe2: thatâs what I want, but semi-automatic
16:02:43 <sorear> timthelion: lists are'nt linear, they are hierarchal
16:03:03 <nomeata> just ânodoc get URLâ, and it saves the file, extracts the title, saves the original url, maybe updates indexes. tags would be useful as well.
16:03:04 <MarcWebe2> sorear: On gentoo there is an ebuild providing access to some search machines from shell
16:03:09 <timthelion> sorear, what do you mean by that?
16:03:11 <sorear> timthelion: n = a : [] ; m = n : b : []  -->  m = ((a : []) : (b : []))
16:03:30 <sorear> typeof b had better be [typeof a]
16:03:50 * sorear > ayhi
16:04:11 <timthelion> sorear, so how do I concatinate an item onto the end of a list?
16:04:19 <MarcWebe2> nomeata: So are you using elinks as main browser?
16:04:27 <sorear> > (++"x") foo
16:04:28 <lambdabot>   Not in scope: `foo'
16:04:34 <sorear> > (++"x") "foo" -- :)
16:04:35 <lambdabot>  "foox"
16:04:43 <sorear> > "foo" ++ "x"
16:04:44 <lambdabot>  "foox"
16:04:50 <MarcWebe2> timthelion: "a":('c':[]) ;)
16:05:06 <monochrom> xs ++ [1] puts 1 at the end.
16:05:08 <nomeata> MarcWebe2: elinks? no, whatâs that?
16:05:11 <sorear> MarcWebe2: type error!
16:05:14 <MarcWebe2> timthelion: sorry the first : should have been a ++
16:05:19 * sorear  <3 elinks
16:05:37 <monochrom> It is not very fast. You should avoid doing it. Re-think your algorithm and data structure.
16:05:41 <sorear> nomeata: a bad webbrowser
16:05:48 <MarcWebe2> nomeata a console web browser (similar to lynx and w3c)
16:05:58 <sorear> nomeata: but better than all the others I've tried
16:06:05 <monochrom> Of course, once in a while is ok.
16:06:18 <nomeata> no, but I always have consoles around where I can type ânodoc get â and paste the URL to get an article
16:06:25 <timthelion> I use w3m for almost everything
16:06:30 <nomeata> (ânodocâ being the assumed program name)
16:06:43 <timthelion> if I can't I fall back to conkeror
16:06:44 <nomeata> I still do browse with something graphical (galeon in my case)
16:07:01 <monochrom> elinks is a good browser.
16:07:15 <monochrom> it is better than lynx IMO
16:07:21 <MarcWebe2> nomeata: Try dog ;) Like cat but it also retrieves http content. (Though you have to read html text then)
16:07:30 <timthelion> I like elinks, but it doesn't work inside emacs
16:07:40 <nomeata> I think you are misunderstanding what I want.
16:07:40 <timthelion> otherwise, I would use it any day over w3m
16:07:57 <monochrom> w3m is also ok
16:08:12 <MarcWebe2> nomeata: No. I just don't know a better solution (unless coding it)
16:08:15 <nomeata> I have a browser all right, but Iâd like to keep an organized offline collection of good article with a little bit of management around.
16:08:47 <nomeata> MarcWebe2: thats ok, I just fail to see how text browsers help
16:10:13 <MarcWebe2> nomeata: You need a firefox button "save with meta data" .. where metadata contains url and keywords.. You also need a offline desktop search engine. Then you're done, right?
16:10:55 <nomeata> yes, thatâs close
16:11:14 <MarcWebe2> How is nodoc get related to organizing the data? Is noget intendet to gather the articles or should it just launch appropriate applications (such as ff on http files)
16:11:48 <nomeata> nodoc get should get the file and store it with some automatic meta data (assume I just found it and want to keep it)
16:12:12 <nomeata> other operations I think would be useful could be nodoc search (full text search), nodoc tag (tag manipulation), notdoc update (check for new versions)
16:12:44 <nomeata> from the way I call the commands you can see Iâm using debian and Iâm used to apt-get etc :-)
16:12:45 <MarcWebe2> nomeata: So you can use a echo "$@" file.info and a wget -p ?
16:12:58 <MarcWebe2> "$@" > file.info
16:13:15 <tibbe> How hard would it be to port HTTP to use ByteString?
16:13:19 <nomeata> MarcWebe2: yes, I got that already, but before I code the rest I was wondering whether I re-invent the wheel
16:14:22 <MarcWebe2> nomeata You know that you don't need the url most of the time because you can use google and search for quotes "some text from the document" which works really well.. ?
16:14:48 <hpaste>  nomeata pasted "nodoc beginnings" at http://hpaste.org/770
16:15:17 <nomeata> MarcWebe2: well, I have the info anyway, so I think I should keep it. also for automatic updates
16:16:21 <MarcWebe2> I'll be back in 20m
16:16:40 <fantasma> is there any infinite prime number generator that runs in 0.1 seconds for Haskell as there is for C?
16:17:27 <nomeata> 0.1 seconds for an infinite amount of prime numbers? wow!
16:17:35 <fantasma> yah it's the best
16:17:36 <nomeata> (SCNR)
16:18:01 <fantasma> is that the name of an algorithm?
16:18:16 <nomeata> no, SCNR = sorry, could not resist
16:18:19 <yip> i've seen a perl program that generates double that amount in only 30 milliseconds
16:18:29 <nomeata> an excuse for my non-constructive comment
16:18:40 <ddarius> Google <title> works very well too.
16:18:44 <fantasma> i don't think there's any excuse for that
16:19:03 <nomeata> @hoogle excuse
16:19:03 <lambdabot> No matches found
16:19:11 <nomeata> Hmm. at least not for haskellâers
16:19:25 <nomeata> @hoogle Light this candle.
16:19:26 <lambdabot> Did you mean: Light This Candle.
16:19:32 <nomeata> @hoogle Light this Candle.
16:19:33 <lambdabot> Did you mean: Light This Candle.
16:19:35 <nomeata> @hoogle Light This Candle.
16:19:36 <lambdabot> No matches, try a more general search
16:19:38 <fantasma> case-sensitive silly
16:19:39 <mbishop> heh
16:19:42 <nomeata> darn
16:19:47 <nomeata> @hoogle Light!
16:19:48 <lambdabot> No matches, try a more general search
16:19:53 <fantasma> @hoogle hoogle
16:19:54 <lambdabot> No matches found
16:20:05 <nomeata> I canât make it reply âNo matches foundâ to a suitable question.
16:20:17 <nomeata> @hoogle the_candles_are_out
16:20:18 <lambdabot> No matches found
16:20:27 <fantasma> bad
16:20:29 <nomeata> ok, lambdabot, thx for trying
16:20:32 <Zeroth404> is "haskell" pronounced closer to "pascal" or "postal" ?
16:20:48 <mbishop> @hoogle Got-a-light?
16:20:48 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-a-light?'
16:20:51 <nomeata> Iâd say neither, but Iâm German
16:20:51 <mbishop> :/
16:20:57 <ddarius> "Postal"?
16:20:57 <fantasma> i don't know how to pronounce haskell
16:20:59 <Zeroth404> heh
16:21:08 <ddarius> @google Simon Peyton Jones saying Haskell
16:21:10 <Zeroth404> in regards only to stressing of particular syllables
16:21:11 <nomeata> @hoogle Did You See The Tennis Game?
16:21:12 <lambdabot> http://www.powells.com/cgi-bin/biblio?inkey=4-0521826144-0
16:21:12 <lambdabot> Title: Powell's Books - Haskell 98 Language & Libraries by Simon Peyton Jones
16:21:12 <lambdabot> No matches, try a more general search
16:21:20 <ddarius> bugger
16:21:31 <sorear> @google Simon Peyton Jones says Haskell
16:21:34 <lambdabot> http://www.newsforge.com/article.pl?sid=01/07/03/0117248&mode=thread
16:21:34 <chessguy> i don't suppose anyone here has tried to build hIDE lately
16:21:34 <lambdabot> Title: NewsForge | GHC developer Simon Peyton Jones on working for, gasp!, Microsoft
16:21:44 <sorear> @google Simon says Haskell
16:21:46 <lambdabot> http://www.twitchfilm.net/archives/008476.html
16:21:47 <lambdabot> Title: Twitch - 2nd trailer for William Dear's SIMON SAYS
16:21:50 <fantasma> nomeata, how far are you on the project euler problems
16:21:55 <nomeata> @hoogle Matches Found?
16:21:55 <lambdabot> No matches, try a more general search
16:22:05 <nomeata> @hoole anything
16:22:06 <lambdabot> No matches found
16:22:22 <nomeata> fantasma: nowhere. what problems?
16:22:38 <fantasma> nomeata, http://projecthaskell.com
16:22:42 <ddarius> There's a much better one with @where that I haven't seen anyone do and that I have consistently resisted doing.
16:22:56 <nomeata> @where is that joke?
16:22:57 <lambdabot> I know nothing about is.
16:23:03 <nomeata> @where haskell
16:23:04 <lambdabot> http://haskell.org
16:23:08 <nomeata> ;-)
16:23:14 <nomeata> @where RealWorld
16:23:14 <lambdabot> I know nothing about realworld.
16:23:19 <nomeata> Iâd thought so.
16:23:28 <mwc> I believe it's BSD make where "make love" results in "Don't know how to make `love'. Stop.
16:23:52 <nomeata> fantasma: that url is dead for me
16:24:03 <nomeata> @where loops
16:24:03 <lambdabot> I know nothing about loops.
16:24:10 <fantasma> nomeata, holy crap I didnt even see what I was typing wow
16:24:12 <nomeata> @where goto
16:24:12 <lambdabot> I know nothing about goto.
16:24:21 <fantasma> nomeata, http://projecteuler.net
16:24:22 <nomeata> @where basic
16:24:22 <lambdabot> I know nothing about basic.
16:24:23 <lambdabot> Title: Project Euler
16:24:31 <nomeata> @where anything
16:24:31 <lambdabot> http://www.google.com/
16:24:34 <nomeata> :-)
16:24:43 <fantasma> @where "make love"
16:24:43 <lambdabot> I know nothing about "make.
16:24:52 <ddarius> The lambdabot authors think of everything.
16:25:04 <fantasma> @where make love
16:25:05 <lambdabot> I know nothing about make.
16:25:28 <fantasma> @hide
16:25:28 <lambdabot> Maybe you meant: dice id time
16:25:42 <fantasma> @dice
16:25:42 <lambdabot> unexpected end of input: expecting number
16:25:47 <fantasma> @dice 34
16:25:47 <lambdabot> 34 => 34
16:26:00 <nomeata> fantasma: interesting tasks. maybe Iâll try them later
16:26:07 <fantasma> yes
16:26:09 <fantasma> ;)
16:26:27 <nomeata> @where nothing
16:26:28 <lambdabot> I know nothing about nothing.
16:26:39 <nomeata> @where you
16:26:39 <lambdabot> I know nothing about you.
16:26:46 <fantasma> @where myself
16:26:47 <nomeata> Thatâs comforting
16:26:47 <lambdabot> You tell me.
16:26:49 <chessguy> geez, get enough of playing with the bot
16:26:57 <nomeata> @where playing
16:26:57 <lambdabot> I know nothing about playing.
16:27:13 <nomeata> @localtime lambdabot
16:27:13 <lambdabot> I live on the internet, do you expect me to have a local time?
16:27:24 <nomeata> oh, that late!
16:27:28 <nomeata> good night everyone.
16:27:34 <tibbe> what's the state of ByteString and utf8?
16:27:34 <fantasma> good night
16:28:11 <rufius> Whats the best way to access data in a tuple with elements >2
16:28:23 <chessguy> rufius, pattern matching
16:28:31 <rufius> chessguy: thank you
16:28:54 <fantasma> chessguy, how many years have you been using haskell
16:29:15 <chessguy> fantasma, about .5
16:29:43 <fantasma> interesting
16:29:48 <chessguy> maybe a little more. why?
16:30:05 <fantasma> you know a lot :)
16:30:11 <chessguy> ha!
16:30:14 <chessguy> now that's funny
16:30:38 <mbishop> he's knows plenty more about cheese
16:30:40 * mbishop hides
16:30:52 <chessguy> don't mind the cheese dip
16:31:06 <fantasma> are you into chess?
16:31:20 <chessguy> wow, how'd you ever guess
16:31:25 <fantasma> lol
16:34:03 <fantasma> im attempting to dig up a great link to this chess site
16:34:42 <fantasma> http://turbulence.org/spotlight/thinking/chess.html
16:34:43 <lambdabot> Title: Thinking Machine 4: Play the Game
16:35:07 <fantasma> chessguy check that out
16:35:39 <chessguy> what is it
16:36:14 <fantasma> did you click on it?
16:36:21 <chessguy> what is it?
16:37:34 <sorear> @seen
16:37:35 <chessguy> @bot
16:37:35 <fantasma> it's a java applet, a chess game
16:37:35 <lambdabot> :)
16:37:35 <yip> fantasma: that's pretty awesome
16:37:35 <fantasma> yah
16:37:36 <chessguy> i forget, how do i list the packages that are installed on my GHC build?
16:37:42 <fantasma> shows all possible moves on the board
16:37:48 <timthelion>  help, I'm stuck on exercise 4.8 of YAHT! http://rafb.net/p/j038NS18.html
16:37:50 <lambdabot> Title: Nopaste - No description
16:38:04 <yip> fantasma: how does it work? simple minmax?
16:38:04 <timthelion> No instance for (Num (List a))
16:38:22 <fantasma> yip, no idea
16:38:23 <timthelion> I get No instance for (Num (List a))
16:38:43 <yip> would be really great if you could compile java programs to java applets =]
16:38:51 <yip> er, i mean haskell programs :)
16:38:55 <Botje> timthelion: that's haskell-talk for "you're trying to use a list as a number"
16:39:02 <LoganCapaldo> timthelion: try some more parens
16:39:07 <LoganCapaldo> parens are always good
16:39:17 <Saizan> chessguy: ghc-pkg list?
16:39:34 <chessguy> yeah, that's the one i wanted
16:40:45 <Botje> timthelion:
16:40:55 <rag3> I'm aware of the keyword let for defining local definitions. But how can I specify the type of a function and the definition of a function in ghci?
16:40:57 <ddarius> @scheme (define (fib n) (cond ((= n 0) 1) (+ (fib (- n 1)) (fib (- n 2)))))
16:40:58 <lambdabot>  Parse error
16:40:58 <Botje> why does your listFoldl return a list?
16:40:59 <Gwern> hey timthelion. enjoying haskell?
16:41:10 <chessguy> fantasma, what in the world do the lines mean?
16:41:11 <timthelion> Gwern, it's odd.
16:41:12 <TSC> timthelion: I'm not sure your fold is right; it seems to be making a new list as it goes along
16:41:32 <Gwern> (timthelion: can't gainsay that)
16:41:44 <Botje> listFoldl _ _ Nil = 0 #promises listFoldl returns something num-like
16:41:50 <TSC> The first pattern returns an int; the second a List
16:41:54 <Botje> listFoldl p n (Cons x Nil) = Cons (x `p` n)  Nil # promises listFoldl returns a List
16:42:00 <timthelion> Botje, I think I just realised that.
16:42:01 <fantasma> chessguy, they are possible moves and probability lines--the more lines the more probable the move, it also takes into account moves in the future
16:42:21 <rag3> how do i specify the type of a function in GHCi?
16:42:32 <Botje> function :: Foo -> Bar
16:42:45 <fantasma> rag3, i think you can use a semicolon {;}
16:42:45 <LoganCapaldo> let (function :: happy -> ness) = ...
16:42:57 <Botje> oh; in ghci
16:42:59 * Botje shuts up
16:43:04 <LoganCapaldo> (assuming it wasn't the colons that were the problem)
16:43:55 <chessguy> what does it do, just draw a line every time it finds a move in the game tree?
16:44:22 <rag3> sorry I'm missing something here
16:44:43 <rag3> let (f:: Int -> [Int]) f n = [n]
16:44:47 <fantasma> chessguy, not sure, I didn't write it, it's just cool :)
16:44:49 <LoganCapaldo> yeha sorry
16:44:54 <LoganCapaldo> my fault :)
16:45:00 <LoganCapaldo> I shold try out my suggestions first
16:45:05 <chessguy> oooook, just ignore me then
16:45:19 <chessguy> oh, missed your answer
16:45:30 <mbishop> did anybody here that?
16:45:34 <mbishop> sounded like cheese
16:45:44 <chessguy> it's interesting, not that avanced
16:46:18 <LoganCapaldo> rag3: this cumbersomeness seemed to work: let f = (\x -> x + 1) :: Int -> Int
16:46:34 <fantasma> has anyone ever written an advanced chess player in haskell?
16:47:17 <rag3> LoganCapaldo: I see, but should this be just easy in GHCi? I mean, why can't I say f::Int->[Int] and then next line do let f n = [n]
16:47:30 <MarcWebe2> nomeata: Do you want to save two revisions? (The last "reviewed" one and a current?) In case how "This page has moved" you don't want to loose the data.
16:47:41 <LoganCapaldo> You'll have to ask someone who knows more about ghc that
16:47:49 <LoganCapaldo> but heres another cumbersome way: let f = f' :: Int -> Int where f' x = x + 1
16:47:53 <chessguy> ?seen Lemmih
16:47:54 <lambdabot> Lemmih is in #oasis and #haskell. I last heard Lemmih speak 43m 29s ago.
16:47:58 <chessguy> Lemmih, ping
16:48:15 <fantasma> ?seen fantasma
16:48:15 <lambdabot> You are in #haskell. I last heard you speak just now.
16:48:21 <rag3> ?seen dons
16:48:21 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 1h 50m 17s ago.
16:48:41 <fantasma> ?seen lambdabot
16:48:41 <lambdabot> Yes, I'm here. I'm in #haskell.de, #haskell.fr, #happs, #haskell.es, #montevideolibre, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #
16:48:42 <lambdabot> haskell.dut, #haskell-overflow, #haskell-blah and #haskell
16:48:54 <ddarius> > let f :: Int -> Int; f x = x +1 in f 3
16:48:56 <lambdabot>  4
16:49:14 <ddarius> Why is lambdabot so popular?
16:49:23 <chessguy> > let f = (+1) in f 3
16:49:24 <lambdabot>  4
16:49:30 <fantasma> isnt lambdabot supposed to be in #math too??
16:49:43 <chessguy> no, that's mbot's territory
16:49:48 <emu> @vixen why are you so popular?
16:49:48 <lambdabot> <undefined>
16:49:52 <chessguy> mbot is a lambdabot, but it's not under that name
16:49:54 <emu> @vixen
16:49:54 <lambdabot> <undefined>
16:50:04 <LoganCapaldo> theres a bot to do people's math homework now?
16:50:06 <chessguy> runs on a separate machine and everything
16:50:10 <fantasma> lets get mbot in here
16:50:11 <emu> lambdabot is being too non-strict
16:50:15 <rag3> ddarius: thanks so much
16:50:22 <chessguy> LoganCapaldo, it's an interface to mathematica
16:50:39 <fantasma> @list
16:50:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:50:52 <chessguy> % bot
16:50:53 <LoganCapaldo> mathematica? Is that legal?
16:51:07 <chessguy> LoganCapaldo, beats me. ask Cale
16:51:22 <timthelion> arn't all these recursions really inefficient?
16:51:30 <fantasma> yes
16:51:41 <fantasma> @unlambda
16:51:41 <lambdabot> Plugin `unlambda' failed with: IRCRaised Data.ByteString.last: empty ByteString
16:51:51 <fantasma> good job bot
16:52:31 <fantasma> @pretty
16:52:49 <rag3> timthelion: in what programming language do you usually develop?
16:53:05 <emu> @unlambda sk
16:53:06 <lambdabot> Plugin `unlambda' failed with: IRCRaised Data.ByteString.last: empty ByteString
16:54:00 <fantasma> @karma
16:54:01 <lambdabot> You have a karma of 0
16:54:02 <LoganCapaldo> TCO == what recursion? :)
16:54:13 <fantasma> @karma+ chessguy
16:54:13 <lambdabot> chessguy's karma raised to 4.
16:54:31 <fantasma> @karma- lambdabot
16:54:31 <lambdabot> lambdabot's karma lowered to 41.
16:54:54 <chessguy> lambdabot++
16:55:24 <rag3> hey guys, it looks like we're getting a lot of free exposure for Hugs: http://youtube.com/watch?v=vr3x_RRJdd4 :-P
16:55:25 <mbishop> funny how we use crappy C sugar for karma
16:55:26 <mbishop> :P
16:55:48 <fantasma> @elite
16:55:49 <lambdabot> Say again?
16:55:54 <fantasma> @elite fantasma
16:55:54 <lambdabot> FAN745/\/\A
16:55:58 <Gwern> @karma
16:55:59 <lambdabot> You have a karma of 0
16:56:06 <rag3> @karma
16:56:06 <lambdabot> You have a karma of 0
16:56:09 <rag3> @karma police
16:56:10 <lambdabot> police has a karma of 0
16:56:13 <rag3> :-D
16:56:21 <Gwern> > map @karma #haskell
16:56:22 <lambdabot>   Not in scope: `haskell'
16:56:47 <fantasma> > 1+1 = 3
16:56:48 <lambdabot>  Parse error
16:56:59 <fantasma> > let 1+1 = 3 in 1+1
16:57:00 <lambdabot>  3
16:57:11 <fantasma> > let 1+1 = 3 in 1+2
16:57:12 <lambdabot>   Non-exhaustive patterns in function +
16:57:31 <rag3> fantasma: Hakell is bloody smart
16:57:32 <fantasma> is it possible to kill the bot?
16:58:01 <chessguy> @tell Lemmih know anything about build hIDE? when i `sh build.sh`, i get src/Hide/Plugin/LoaderMidLevel.hs:126:26: Not in scope: `moduleFS'
16:58:02 <lambdabot> Consider it noted.
16:58:32 <fantasma> @figlet
16:58:32 <lambdabot> usage: figlet <text>.
16:58:38 <fantasma> @figlet hello world
16:58:39 <lambdabot> Couldn't run the figlet command.
16:58:42 <fantasma> @figlet hello
16:58:43 <lambdabot> Couldn't run the figlet command.
16:58:46 <Gwern> fantasma: well, lambdabot and the software and hardware it runs on top of have not been formally verified, so I would guess yes you could kill lambdabot
16:58:50 <sorear> > array (0::Int , maxBound) [(0,'a')]
16:58:52 <lambdabot> Terminated
16:58:56 <sorear> > array (0::Int , maxBound) [(1,'a')]
16:58:58 <lambdabot> Terminated
16:59:00 <sorear> > array (0::Int , maxBound) [(1,'a')]
16:59:09 <yip> anyone know david mccabe?
16:59:18 <fantasma> sorear killed him
16:59:22 <mbishop> yip: depends on what you mean by "know"
16:59:22 <sorear> each of those 'Terminated' is a SIGSEGV, fantasma
16:59:25 <LoganCapaldo> > fix fix -- lambdabot has just been
16:59:25 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
16:59:26 <lambdabot>     Probabl...
16:59:28 <yip> mbishop: heard of him?
16:59:30 <LoganCapaldo> grr
16:59:32 <mbishop> yip: yes
16:59:40 <yip> mbishop: did you hear the talk he gave?
16:59:47 <mbishop> @seen davidmccabe
16:59:47 <lambdabot> I haven't seen davidmccabe.
16:59:49 <LoganCapaldo> > let a = a :: () in a
16:59:50 <lambdabot>  Exception: <<loop>>
16:59:51 <mbishop> liar!
16:59:53 <LoganCapaldo> gah
17:00:03 <mbishop> he's usually on with that name I believe
17:00:12 <rag3> @tell lambdabot @tell lambdabot
17:00:12 <lambdabot> Nice try ;)
17:00:17 <rag3> ahahah
17:00:23 <fantasma> lol!
17:00:39 <mbishop> yip: anyway no, didn't hear his talk
17:00:46 <fantasma> @slap fantasma
17:00:46 <lambdabot> why on earth would I slap fantasma
17:00:54 <yip> mbishop: is he a bug celebrity within the haskell community?
17:01:08 <timthelion> @slap lambdabot
17:01:08 * lambdabot slaps lambdabot
17:01:15 <mbishop> [18:58] [Notice] -NickServ-            Nickname: davidmccabe
17:01:15 <mbishop> [18:58] [Notice] -NickServ-          Registered: 4 years 6 weeks 2 days (5h 44m 1s) ago
17:01:15 <mbishop> [18:58] [Notice] -NickServ-           Last Seen: 1 day (17h 34m 7s) ago
17:02:03 <fantasma> @babel hola
17:02:03 <lambdabot>   bzzt.
17:02:21 <ddarius> @babel es en hola
17:02:22 <lambdabot> Plugin `babel' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:02:56 <ddarius> Ahhh banjoes.
17:03:02 <fantasma> @babel es en "hola"
17:03:03 <lambdabot> Plugin `babel' failed with: IRCRaised Data.ByteString.last: empty ByteString
17:03:18 * mux belatedly learns GADTs and notes they are quite cool
17:03:49 <mux> in the GHC wiki example though, I don't see anything that can't be done with smart constructors though, am I missing something?
17:04:17 <chessguy> ?where hIDE
17:04:17 <lambdabot> http://haskell.org/haskellwiki/HIDE
17:09:26 <rag3> how did you learn Haskell guys?
17:09:43 <chessguy> dcoutts, ping
17:10:14 <chessguy> rag3, you gotta learn by hacking
17:10:25 <chessguy> reading a lot is good, but it just doesn't do it
17:10:46 <rag3> have you good exercises that could be followed?
17:11:01 <chessguy> check out the haskell wikibook
17:11:04 <chessguy> ?where wikibook
17:11:04 <lambdabot> http://en.wikibooks.org/wiki/Haskell
17:11:15 <chessguy> lots of great tutorials and exercises there
17:11:18 <ddarius> rag3: Just start a program that you would want or the type of program you normally write.
17:11:52 <rag3> ddarius: I write stuff for databases. I doubt I could do it in Haskell to start with
17:12:03 <chessguy> @tell dcoutts know anything about the status of hIDE? is it buildable? when i try, i get src/Hide/Plugin/LoaderMidLevel.hs:126:26: Not in scope: `moduleFS'....is there a hack to get around this?
17:12:03 <lambdabot> Consider it noted.
17:12:18 <tensh> rag3: write black jack
17:13:00 <ddarius> rag3: Just do it.
17:13:02 <mbishop> rag3: morse code
17:13:28 <mbishop> rag3: in fact, if you wanted, you could build it as a module to interface into lambdabot, because it could use a @morse command
17:14:06 <rag3> mbishop: is way behind my abilities
17:14:11 <rag3> beyond
17:14:45 <mbishop> rag3: nah, it's simple really
17:15:06 <astrolabe> a lot of tutorials have exercises.  yaht for example
17:15:07 <ddarius> rag3: You have all of #haskell and Haskell-Cafe to help you.
17:16:03 <ddarius> Or how about this, how do you normally go about learning and programming language (or anything for that matter?)
17:16:06 <tensh> rag3: you could also check out the lab assignments from various schools that teach haskell
17:16:43 <rag3> ddarius: how about I get started with the 99 problems in HAskell?
17:17:13 <ddarius> I've never looked at them.  If that way works best for you then do it.
17:18:04 <rag3> ddarius: could you take a quick a look at them here: http://haskell.org/haskellwiki/99_Haskell_exercises and let me know if you think they could be a good starting point?
17:18:05 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
17:18:37 <nicodaemos> I want to import parseHeader from Network.HTTP, but it doesn't export it.  What should I do?
17:20:47 <chessguy> rag3, there are some great problems there
17:21:04 <mbishop> the 99 problems in haskell are a little...weird
17:21:17 <rag3> mbishop: how so?
17:21:18 <mbishop> they come from the lisp/prolog problems, and didn't really change some of the ideas too well heh
17:21:30 <ddarius> rag3: From a glance, I would recommend something Haskell specific.
17:21:47 <rag3> ddarius and mbishop: thanks.
17:21:49 <mbishop> they mention "boxes"
17:22:01 <rag3> I'll try to do some Euler project problems in Haskell
17:22:08 <rag3> I had many of them done in Ruby
17:22:13 <Axioplase> one might try problems at http://www.spoj.pl/  (not haskell specific, but some are great exercices)
17:22:17 <lambdabot> Title: Sphere Online Judge (SPOJ)
17:22:37 <mbishop> rag3: redo the ones you have in haskell :)
17:22:44 <mbishop> I did that for some of the lisp answers for project euler
17:22:59 <rag3> mbishop: yeah, that's a good idea
17:23:01 <rag3> I'll try that
17:28:25 <nicodaemos> help.  Any thoughts on my question?
17:29:02 <rag3> how do I do modulo in Haskell?
17:29:20 <emu> > 3 `mod` 2
17:29:21 <lambdabot>  1
17:30:23 <rag3> thanks emu, and is there a prefix operator?
17:30:29 <sorear> > mod 3 2
17:30:30 <lambdabot>  1
17:30:42 <sorear> `prefixOp` is a infix op
17:30:51 <sorear> (infixOp) is a prefix op
17:30:54 <sorear> > (+) 2 3
17:30:55 <lambdabot>  5
17:31:05 <emu> all functions of two (curried) params can be made infix by using backticks
17:31:13 <rag3> thanks
17:31:19 <emu> and all operators can be made prefix by using parens
17:31:23 <LoganCapaldo> No postfix though :(
17:31:25 <ddarius> emu: All functions can be made infix.
17:31:34 <emu> that's true, but might confuse
17:31:37 <ddarius> LoganCapaldo: Perfectly doable.
17:31:54 <monochrom> How to make "not" infix?
17:31:55 <emu> > succ `id` 1
17:31:56 <lambdabot>  2
17:32:04 <sorear> > foo `not` bar
17:32:05 <lambdabot>   Not in scope: `bar'
17:32:09 <rag3> YES!!! I did the first problem
17:32:13 <rag3> in Haskell
17:32:14 <ddarius> > (True `not`)
17:32:14 <sorear> > False `not` True
17:32:15 <lambdabot>  Couldn't match expected type `Bool -> t'
17:32:16 <lambdabot>  False
17:32:27 <LoganCapaldo> > 2 3 something + ?
17:32:28 <lambdabot>  Parse error
17:32:43 <sorear> monochrom: it may be a type eror, but it's syntactically fine
17:32:47 <ddarius> That is wonderfully evil.
17:32:54 <monochrom> ...
17:33:08 <sorear> ddarius: and a GHC extension
17:33:20 <ddarius> ? How so?
17:33:34 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/syntax-extns.html#postfix-operators
17:33:36 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/yp3yy9
17:33:37 <Adamant> that's a good part message.
17:33:37 <rag3> @hpaste
17:33:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:33:38 <LoganCapaldo> sections of `f` are ghc extenssions?
17:33:52 <emu> call-with-current-monad-tutorial?
17:34:13 <ddarius> Does GHC not turn them off when in Haskell 98 mode?
17:34:15 <monochrom> call-with-current-call
17:34:38 <LoganCapaldo> > 2 (3 +)
17:34:38 <lambdabot>   add an instance declaration for (Num ((t -> t) -> a))
17:34:39 <lambdabot>     In the expression...
17:34:41 <LoganCapaldo> :(
17:34:51 <ddarius> @google Typed Quote/Antiquote
17:34:52 <LoganCapaldo> > 2 (3 `+`)
17:34:52 <lambdabot>  Parse error
17:34:54 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf
17:35:06 <LoganCapaldo> > 2 (3 `(+)`)
17:35:06 <lambdabot>  Parse error
17:35:14 <hpaste>  rag3 pasted "The first problem in Hakell" at http://hpaste.org/771
17:35:40 <rag3> could you please advise on the style, if changes are required or better ways are possible?
17:35:57 <rag3> oh, I just had an idea
17:36:00 <rag3> how to improve it
17:36:03 <rag3> hold on a sec
17:36:28 <monochrom> I think it's quite ok!
17:36:32 <ddarius> LoganCapaldo: See that paper.
17:37:11 <monochrom> Any code I can understand in O(n) time is good code. :)
17:37:20 <rag3> monochrom: thanks
17:37:41 <ddarius> rag3: Slight stylistic nit: Most Haskellers write print (sum (three_and_five 1000)) -- note space
17:37:54 * LoganCapaldo was gonna rewrite it with filter but it just got uglier, so decided not to
17:38:14 <rag3> ddarius: space after each function?
17:38:44 * Zeroth404 emerge's hugs98
17:38:49 <Cale> spaces between basically all terms
17:38:58 <ddarius> rag3: Yes.  Since juxtaposition is application it's more consistent to write f (1+2) matches f 3 than f(1+2)
17:38:59 <LoganCapaldo> print . sum $ three_and_five 1000 -- parens? bah! ;)
17:39:38 <monochrom> We write "f x" instead of "f(x)".
17:39:43 <Cale> Zeroth404: btw, if you get GHC, don't compile it unless there's really no other option :)
17:40:05 <monochrom> But of course by the time you get to f (x+3), f (g (h (i (....  the point becomes moot.
17:40:06 <rag3> ddarius: http://hpaste.org/771#a1 better?
17:40:10 <Cale> (especially as you'll need a binary for it to compile it anyway)
17:40:23 <Zeroth404> Cale: ghc-bin it is. is it huge?
17:40:30 <Zeroth404> s/huge/tiem consuming
17:40:40 <Cale> Zeroth404: It just takes a long long time to compile.
17:40:49 <Zeroth404> longer than KDE? :-)
17:40:57 <Cale> I'm not sure.
17:41:21 <monochrom> The average is 90 minutes.
17:41:26 <Cale> Longer than most of the kernel compiles I've ever done.
17:41:28 <ddarius> rag3: Usually there wouldn't be the trailing space between the parens.
17:42:00 <rag3> ddarius: got you
17:42:08 <Cale> Don can compile it in 9 minutes, but he has a 16 core machine.
17:42:21 <Cale> It's not really fair :)
17:42:22 <monochrom> But mine took an afternoon.
17:42:28 <Cale> yeah
17:42:37 <ddarius> Holy crap! A registered GHC build in 9 minutes from nothing?
17:42:39 <rag3> ddarius: http://hpaste.org/771#a2
17:42:42 <LoganCapaldo> ghc compilation is that parallelizable?
17:42:48 <Cale> apparently
17:43:01 <LoganCapaldo> That seems impressive
17:43:02 <sorear> Zeroth404: GHC bin is 52M on my pc *BUT*
17:43:11 <sorear> Zeroth404: that's no excuse to compile
17:43:18 <rag3> I'm going to try from work on a 64 way server :-) Just to break the record.
17:43:45 <LoganCapaldo> well if it takes 90 minutes with 1 proc
17:43:51 <LoganCapaldo> and 9 minutes with 16
17:44:20 <rag3> it should complete in -3 minutes on a 64 LOL
17:45:00 <LoganCapaldo> rag3: careful, theres a lot of those mathematicians that hang around this joint
17:45:27 <LoganCapaldo> As soon as they stop thinking about natural transformations on functors they're gonna realize what you just said
17:45:41 * LoganCapaldo averts his eyes
17:45:56 <emu> inconsistency, nooooooo!
17:45:59 <rag3> LoganCapaldo: it was intentionally a joke. -3 minutes doesn't exist.
17:46:06 * Zeroth404 eyes his averts
17:46:23 <LoganCapaldo> rag3: That's why I ran with it
17:46:59 <rag3> what the hell just happened?
17:47:03 <emu> netsplit
17:47:04 <LoganCapaldo> netsplit
17:47:06 <Zeroth404> netsplit, fool.
17:47:08 <Zeroth404> :-p
17:47:14 --- mode: irc.freenode.net set +o ChanServ
17:47:15 <emu> now now
17:47:21 <emu> welcome to IRC
17:47:26 <emu> a server disconnected briefly
17:47:32 <yip> woohoo netsplit!
17:47:32 <Cale> dons: actually, are you around?
17:47:36 <chessguy> geez
17:47:50 <sorear> @bot
17:47:50 <lambdabot> :)
17:48:02 * allbery_b already did that in private message :)
17:48:16 <emu> please feed the lambdabot
17:48:32 <allbery_b> > fix (1:)
17:48:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:48:35 <monochrom> @botsnack
17:48:36 <lambdabot> :)
17:48:39 <sorear> @btt
17:48:39 <lambdabot> Maybe you meant: bf bug ft let
17:48:44 <Cale> > fix ((0:) . scanl (+) 1)
17:48:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:48:50 <rag3> @slap someone
17:48:50 * lambdabot smacks someone about with a large trout
17:49:02 <monochrom> @smack anyone
17:49:02 <lambdabot> Unknown command, try @list
17:49:02 <rag3> > [1,3..]
17:49:04 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
17:49:09 * monochrom smacks himself
17:49:12 <Zeroth404> I never calculated fibonacci that far heh
17:49:16 <emu> :t scanl
17:49:19 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
17:49:28 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
17:49:29 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:49:32 <monochrom> scanl is underappreciated
17:49:35 <rag3> product[1..1000]
17:49:41 <rag3> > product[1..1000]
17:49:43 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
17:49:47 <ddarius> @google an algebra of scans
17:49:49 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/MPC2004.pdf
17:49:58 <Cale> > length . show . product $ [1..1000]
17:49:58 <Laney> @src scanl
17:49:59 <lambdabot> scanl f q ls = q : case ls of
17:49:59 <lambdabot>     []   -> []
17:49:59 <lambdabot>     x:xs -> scanl f (f q x) xs
17:49:59 <lambdabot>  2568
17:50:08 <Zeroth404> [5,9,17,29..]
17:50:08 <LoganCapaldo> > let fibs = 1 : 1 : [ x + y | x <- fibs, y <- tail fibs ] in fibs
17:50:09 <lambdabot>  [1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:50:16 <LoganCapaldo> hmm
17:50:21 * Zeroth404 has no idea what's going on
17:50:23 <allbery_b> @pl \x y -> y `mod` x == 0
17:50:23 <lambdabot> flip flip 0 . ((==) .) . flip mod
17:50:33 <LoganCapaldo> I suck at list comprehensions
17:50:37 <emu> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
17:50:37 <lambdabot>  Parse error
17:50:40 <emu> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:50:41 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:50:45 <LoganCapaldo> right
17:50:50 <LoganCapaldo> the zipper
17:51:02 <emu> or (x,y) <- zip fibs (tail fibs)
17:51:02 <ddarius> LoganCapaldo: You'd need parallel list comprehensions which are a GHC extension.
17:51:04 <monochrom> We are testing lambdabot.
17:51:20 <LoganCapaldo> > let fibs = 1 : 1 : [ x + y | x <- fibs | y <- tail fibs ] in fibs
17:51:20 <lambdabot>  Parse error
17:51:32 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } } in shred "foobar"
17:51:33 <lambdabot>  ("foa","obr")
17:51:36 <LoganCapaldo> I guess lambdabot no knows parallel list comps
17:51:47 <ddarius> @list track
17:51:47 <lambdabot> No module "track" loaded
17:51:57 <allbery_b> no, LB doesn;'t do -fglasgow-exts
17:52:05 <allbery_b> so no parallel list comprehensions
17:52:44 <Cale> > fix ((0:) . (1:) . ap (zipWith (+)) tail)
17:52:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:52:51 <LoganCapaldo> I find it interesting that it counts as a parse error
17:52:56 <emu> > [ floor $ product [1..(2*n)] / (product [1..n] * product[1..(n+1)]) | n <- [1..] ]
17:53:05 <lambdabot>  [1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674439,9694844,353...
17:53:13 <LoganCapaldo> i'd figure it would be like "You need to enable extensions for that!"
17:53:29 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = uncurry (++) . unzip . bitRev . group2 $ xs where group2 [] = []; group2 (x:y:xs) = (x,y):group2 xs in bitRev [0..15]
17:53:31 <lambdabot>  [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]
17:53:39 * ddarius likes that example of polymorphic recursion.
17:53:54 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in shred "foobar"
17:53:55 <lambdabot>  ("foa","obr")
17:54:10 <Cale> > drop 2 . map (\p -> 2^(p-1) - 1) $ nubBy (\x y -> y `mod` x == 0) [2..]
17:54:11 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 0 [1..1010]
17:54:12 <lambdabot>  [15,63,1023,4095,65535,262143,4194303,268435455,1073741823,68719476735,10995...
17:54:12 <lambdabot>  4250570777436050362662259650887916477466379532155037570642131548253288108525...
17:54:21 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 0 [1..1020]
17:54:23 <lambdabot>  4957116863516391937732107839355085999671938129715579353648636919444702233589...
17:54:28 <LoganCapaldo> looooong number
17:54:36 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 0 [1..2000]
17:54:37 <lambdabot>  3316275092450633241175393380576324038281117208105780394571935437060380779056...
17:54:50 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in foldr (*) 1 [1..2000]
17:54:51 <lambdabot>  3316275092450633241175393380576324038281117208105780394571935437060380779056...
17:54:52 <Cale> sorear: what is that?
17:54:55 <ddarius> sorear: What's with the {}'s?
17:54:57 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in foldr (*) 1 [1..3000]
17:54:58 <lambdabot>  4149359603437854085556867093086612170951119194931809917689467657697558565123...
17:55:01 <sorear> ddarius: layout
17:55:08 <sorear> Cale: note `par`
17:55:20 <ddarius> sorear: You should be able to drop at least some of them I'd think.
17:55:22 <sorear> oh wait this isn't amdbot :(
17:55:25 <Cale> parallelised factorial?
17:55:39 <sorear> Cale: *Muahaha* divide and conquer
17:56:16 <Cale> > map (floor . ((17**(1/5))**)) [1..]
17:56:17 <lambdabot>  [1,3,5,9,17,29,52,93,163,289,509,897,1581,2787,4913,8658,15259,26891,47392,8...
17:56:17 <emu> divide by zero and founder
17:56:25 <ddarius> Hmm
17:56:39 <Cale> Zeroth404: is that the 5,9,17,29 you were thinking of?
17:56:42 <sorear> actually it should be faster even on a uniprocessor, since it allows use of sub-quadratic Karatsuba/Strassen mults
17:56:43 * ddarius thinks about playing with NTT over Z/2
17:56:52 <Zeroth404> Cale: no
17:56:59 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in foldr (*) 1 [1..10000]
17:57:01 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
17:57:04 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in foldr (*) 1 [1..20000]
17:57:06 <lambdabot>  1819206320230345134827641756866458766071609901478752648918062218634569461038...
17:57:09 <Zeroth404> Cale: I just picked 5 at random, and added 4, then added 4 and 4 again, then 4 and 4 and 4, ...
17:57:11 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in foldr (*) 1 [1..100000]
17:57:12 * LoganCapaldo tries to run what sorear just said thru a translator
17:57:14 <Cale> ah :)
17:57:15 <lambdabot> Terminated
17:57:22 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..100000]
17:57:25 <lambdabot>  2824229407960347874293421578024535518477494926091224850578918086542977950901...
17:57:36 <sorear> see how much faster pfold is!
17:57:39 <Zeroth404> Cale: amazing tho thar you actually found a different way... what;s behind it?
17:58:27 <Cale> Hehe, I cheated :)
17:58:31 <Cale> http://www.research.att.com/~njas/sequences/
17:58:32 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
17:58:43 <LoganCapaldo> OMG
17:58:48 <Cale> There's actually quite a few other ways :)
17:58:52 <LoganCapaldo> that has to be the best website ever
17:58:53 <sorear> LoganCapaldo: ?
17:59:03 <sorear> @where oeis
17:59:04 <lambdabot> I know nothing about oeis.
17:59:13 <sorear> @where+ oeis http://www.research.att.com/~njas/sequences/
17:59:13 <lambdabot> Done.
17:59:20 <Cale> @where+ sloane http://www.research.att.com/~njas/sequences/
17:59:20 <lambdabot> Done.
17:59:27 <sorear> hm.
17:59:28 <ddarius> @where danvy
17:59:28 <lambdabot> I know nothing about danvy.
17:59:29 <emu> its funny i learned about the soare sequences recently too
17:59:39 <sorear> we need @oies
17:59:59 <Cale> Online Integer Encyclopedia Sequence?
18:00:09 <LoganCapaldo> oh
18:00:14 <LoganCapaldo> my god
18:00:21 <LoganCapaldo> @oies 1,2,3
18:00:21 <lambdabot> Unknown command, try @list
18:00:32 <LoganCapaldo> spits out [1..]
18:00:47 <Cale> actually, it'd probably give you fibs
18:00:51 <ddarius> Should be easy as pie to make it.
18:00:52 <LoganCapaldo> @. run oeis 1, 4, 9, ...
18:00:52 <Cale> http://www.research.att.com/~njas/sequences/?q=1%2C2%2C3&language=english&go=Search
18:00:52 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "oeis"
18:00:54 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences, http://tinyurl.com/2gaukq
18:01:16 <LoganCapaldo> Cale: yeah, I know the natural numbers are way down at the bottom of the page
18:01:24 <LoganCapaldo> it was just an example
18:01:45 <LoganCapaldo> and theres already mathematica code there
18:01:52 <LoganCapaldo> could feed it into mbot directly
18:02:10 <Adamant> > [1, 1, 2, 3]
18:02:11 <lambdabot>  [1,1,2,3]
18:02:13 <Cale> I find it odd that they didn't include 0 in the natural numbers
18:02:22 <Adamant> > [1, 1, 2, 3 ..]
18:02:23 <lambdabot>  Parse error
18:05:40 <LoganCapaldo> > [1,1..]
18:05:41 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:05:48 <emu> > fix (\x -> True:map not x)
18:05:49 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
18:06:09 <sorear> > fix ((True:) . map not)
18:06:11 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
18:06:11 <LoganCapaldo> > iterate not True
18:06:13 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
18:06:27 <emu> > fix (\x -> not x)
18:06:29 <lambdabot>  Exception: <<loop>>
18:06:40 * LoganCapaldo is proud of his soln.
18:06:53 <LoganCapaldo> way to use the prelude, wooo
18:07:02 <sorear> emu: tsk tsk. don't you know to stay away from black holes? :)
18:07:04 <mbishop> > let foo = 1 in 1 : (head foo)
18:07:05 <lambdabot>   add an instance declaration for (Num [[t]])
18:07:06 <lambdabot>     In the expression: 1
18:07:06 <lambdabot>     In...
18:07:16 <emu> i'm actually pondering the fixed-pt theorem atm
18:07:22 <emu> so, no
18:07:46 <sorear> emu: which one?  Brower's? Kleene's?
18:07:57 * sorear suspects Kleene's
18:08:24 <emu> for computable functions
18:08:36 <sorear> the one on the quinepage?
18:08:42 <LoganCapaldo> @type unfoldr
18:08:44 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:08:55 <emu> um, quines are related i guess
18:08:58 <sorear> LoganCapaldo: that's not in the prelude :)
18:09:02 <emu> recursion thm and all that
18:09:15 <LoganCapaldo> sorear: iterate isn't?
18:09:18 <LoganCapaldo> @source iterate
18:09:18 <lambdabot> iterate not available
18:09:19 <mbishop> > 1 : [1..]
18:09:20 <lambdabot>  [1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
18:09:30 <sorear> LoganCapaldo: iterate is.  unfoldr isn't.
18:09:34 <yip> @seen shapr
18:09:35 <lambdabot> shapr is in #haskell and #happs. I don't know when shapr last spoke.
18:09:40 <LoganCapaldo> I was jsut being curious about unfoldr :)
18:12:28 <monochrom> fix not = _|_  is right
18:12:35 <emu> yea
18:12:48 <ddarius> Y not = Russel's Paradox.
18:13:10 <emu> i think that's the example Church came across to show that lambda-calculus does not make a suitable foundation for arithmetic
18:13:14 <emu> and yea
18:13:49 <monochrom> > fix (\() -> ())
18:13:50 <lambdabot>  Exception: <<loop>>
18:14:01 <monochrom> this is also right
18:14:11 <ddarius> > fix (\_ -> ())
18:14:12 <vincenz> 3.5 hours to make a compiler frontned \o/
18:14:12 <lambdabot>  ()
18:14:56 <monochrom> this is also right
18:15:15 <shapr> yip: need something?
18:15:33 <yip> shapr: have a moment to check out the haskell chat web app?
18:15:35 <monochrom> 3.5 hours may be enough for a compiler frontend.  school project due in 3.5 hours? :)
18:15:42 <shapr> yip: Sure!
18:16:05 <vincenz> monochrom: heh...not quite...
18:16:10 <vincenz> monochrom: researchign a novel denotational semantics
18:16:10 <yip> http://feld.sh.nu:2000/
18:16:38 <vincenz> monochrom: and I think 3.5 hours for lexer/parser + locatable AST is pretty good
18:18:13 <LoganCapaldo> I made a calculator
18:18:29 <LoganCapaldo> heh :)
18:18:45 <monochrom> a calculator is a simple denotational semantics.
18:19:14 <LoganCapaldo> So what the Haskell code for said calculator == denotational semantics?
18:19:19 <shapr> yip: nifty
18:19:25 <vincenz> LoganCapaldo: yah
18:19:34 <LoganCapaldo> woo
18:19:41 <ddarius> LoganCapaldo: It depends on how you write it and you need a bit more, but essentially.
18:19:41 <vincenz> The great thing about haskell is: statically scoped  behaviour = ReaderT, dynamically scoped behaviour = StateT
18:19:53 <vincenz> That goes for any den-sem interpreter
18:20:07 * LoganCapaldo decides to learn Data.Map to add bindings to his calcalator
18:20:28 <yip> shapr: thanks
18:20:37 <vincenz> Anyways, later
18:20:52 <rag3> I solved the second problem but it sucks
18:20:54 <monochrom> You're going to grow it into excel.  I can see it now.
18:22:21 <LoganCapaldo> well I'd need to add domain relational calculus to turn it into a proper excel
18:22:28 <LoganCapaldo> else it couldn't be used as a db ;)
18:22:40 <monochrom> Whenever Graham Hutton writes a paper on denotational semantics he uses a calculator as an example. :)
18:23:02 <LoganCapaldo> @doc Data.Map
18:23:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
18:23:26 <monochrom> "Consider this grammar  e ::= e+e | e*e | literal"
18:24:23 <monochrom> Then when he wants to teach you how to add exceptions he goes "now add e/e so you can have division by zero errors"...
18:24:54 <LoganCapaldo> lol
18:25:14 * LoganCapaldo just realized that his calculator does nothing on that front
18:25:41 <LoganCapaldo> Maybe I should fix that before I add variables
18:26:14 <ddarius> LoganCapaldo: Have you read The Essence of Functional Programming
18:26:22 * ddarius thinks that's the one he's thinking of.
18:26:27 <LoganCapaldo> I don't believe so
18:26:38 <ddarius> @google The Essence of Functional Programming
18:26:42 <lambdabot> http://citeseer.ist.psu.edu/wadler92essence.html
18:26:42 <lambdabot> Title: The Essence of Functional Programming - Wadler (ResearchIndex)
18:26:56 <LoganCapaldo> So shall I make my evaluate return an either then?
18:27:16 <chessguy> hmm, that looks interesting
18:27:23 <hpaste>  Laney pasted "I'd like to be shown Haskell voodoo to turn this into a one liner if possible :)" at http://hpaste.org/772
18:27:59 <hpaste>  rag3 pasted "Second Euler problem (works but I need to understand a few things)" at http://hpaste.org/773
18:28:21 * ddarius wants to (re)implement LolliMon in Haskell.
18:28:59 <LoganCapaldo> gah
18:29:04 <LoganCapaldo> is Either a monad?
18:29:12 <chessguy> ?instances Monad
18:29:13 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:29:22 <LoganCapaldo> thank goodness
18:29:23 <monochrom> Either is sometimes a monad.
18:29:23 <chessguy> no, but Either e is :)
18:29:33 <LoganCapaldo> err
18:29:41 <chessguy> monochrom, Either it is, or it isn't, come on
18:29:43 <LoganCapaldo> I take it bind has the expect semantics?
18:29:46 <ddarius> Laney: Probably a takeWhile or some such over an unfoldr.
18:29:58 <chessguy> ?src (>>=) Either
18:29:58 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:29:59 <monochrom> Either it is sometimes, or it is never.
18:30:12 <LoganCapaldo> ?src Either (>>=)
18:30:12 <lambdabot> Left  l >>= _ = Left l
18:30:12 <lambdabot> Right r >>= k = k r
18:30:17 <chessguy> oh, whoops
18:30:19 <LoganCapaldo> goody
18:30:19 <allbery_b> rag3:  haskell is lazy.  try [1..]
18:30:35 <rag3> allbery_b: I tried... it went in loop
18:30:54 <mbishop> > [1..] !! 200
18:30:56 <lambdabot>  201
18:31:08 <allbery_b> oh.
18:31:14 <allbery_b> list comprehensions use filter.
18:31:18 <allbery_b> you want takeWhile
18:32:31 <allbery_b> (filter will keep going after the condition goes false, not realizing that it will never again become true)
18:32:31 <mbishop> > takeWhile (< 1000) [1..]
18:32:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:32:31 <jcreigh> > length $ takeWhile (<1000) [1..]
18:32:31 <lambdabot>  999
18:32:31 <rag3> ah I didn't know there was takeWhile
18:32:31 <jcreigh> > length $ filter (<1000) [1..]
18:32:31 <lambdabot> Terminated
18:34:24 <rag3> what's the dollar?
18:34:55 <allbery_b> magic parens, more or less
18:34:59 <int-e> a $ b = a b
18:35:08 <int-e> an infix operator with very low precedence
18:35:13 <dino-> Function application. In the above case it's like: length (takeWhile (< 1000) [1..] )
18:35:14 <fantasma> dollah
18:35:18 <allbery_b> a $ b = (a) (b)
18:35:22 <Laney> i like to read it as 'after'
18:35:29 <monochrom> $ is evil
18:35:33 <int-e> @src ($)
18:35:33 <lambdabot> f $ x = f x
18:35:42 <Laney> @src (.)
18:35:42 <lambdabot> (.) f g x = f (g x)
18:35:43 <fantasma> monochrom, can I have all of your $
18:36:00 <rag3> ok, I really have to read the F manual before I try to code or I get too frustrated
18:36:00 <monochrom> I wouldn't want to spread evil to you.
18:36:01 <chessguy> @quote extra
18:36:01 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. \n <souwh> oooh, those can be saved and reused later!
18:36:20 <araujo> hello
18:36:31 <sorear> hello!
18:36:33 <fantasma> araujo, hey, good evening to you sir
18:36:44 <araujo> hi sorear !
18:36:46 <araujo> hola fantasma !
18:36:48 <araujo> thanks :-)
18:36:58 * araujo _very_ tired from univ
18:37:25 <fantasma> lot's of work?
18:37:58 <chessguy> araujo, mejor cansado que casado!
18:38:05 <araujo> chessguy, hahaha
18:38:11 <LoganCapaldo> eeek
18:38:21 <araujo> fantasma, yeah, and little time
18:38:21 <LoganCapaldo> no instance for Monad (Either String) :(
18:38:23 <araujo> :-(
18:38:53 <fantasma> chessguy, por que no quieres hacer casado? :D
18:39:05 <fantasma> s/hacer/estar/
18:39:12 <araujo> :-)
18:39:30 <chessguy> i wasn't serious. in fact 1 year from yesterday, i will be
18:39:56 * araujo thinks it is a serious joke
18:40:05 <fantasma> haha
18:40:08 * araujo prefers to be tired
18:40:08 <allbery_b> er?
18:40:27 <fantasma> being tired is the worst :(
18:40:29 <allbery_b> @instances-importing Control.Monad.Error Monad
18:40:31 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:40:35 <araujo> off to eat, brb
18:40:36 <chessguy> anyway, back to haskell :)
18:40:37 <allbery_b> hm, right.
18:40:42 <allbery_b> EIther e is a monad, for any type e
18:40:49 <allbery_b> so Either String is covered
18:40:53 <fantasma> i haven't learned about monads yet
18:41:01 <chessguy> allbery_b, oh good, you've caught up :)
18:41:13 <allbery_b> <LoganCapaldo> no instance for Monad (Either String) :(
18:41:17 <beelsebob_> anyone here ever had appendicitis?
18:41:23 <ddarius> Either e is a monad for any type e -that's an instance of Error-.
18:41:25 <allbery_b> just a couple seconds ago
18:41:35 <allbery_b> so I pointed out that, well, yes, it is
18:41:40 <chessguy> hrmm
18:41:42 <allbery_b> @instances Error
18:41:43 <lambdabot> IOError, [Char]
18:41:45 <chessguy> ?src Either
18:41:45 <lambdabot> Source not found. My pet ferret can type better than you!
18:41:47 <allbery_b> threr
18:41:48 <fantasma> @remember chessguy mejor cansado que casado!
18:41:48 <lambdabot> Done.
18:43:37 <LoganCapaldo> you coulda just said "you need to import Control.Monad.Error" :)
18:43:49 <dons> re.
18:44:01 <chessguy> you coulda been grateful that he answered you at all
18:44:42 <fantasma> is LISP easy to pickup after learning haskell or would there be no point in doing so?
18:44:42 <LoganCapaldo> chessguy: I am grateful
18:45:20 <LoganCapaldo> I'm just so used to getting intelligent friendly answers in here that perhaps I took it for granted for a moment
18:45:24 <LoganCapaldo> for that I apologize
18:45:48 <sorear> hi dons!
18:45:54 <fantasma> i know, I've never seen such a friendly channel on irc in my life
18:45:59 <allbery_b> <allbery_b> @instances-importing Control.Monad.Error Monad -- I did :)
18:46:05 <thorat> fantasma: http://www.defmacro.org/ramblings/lisp-in-haskell.html
18:46:06 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell
18:46:11 <fantasma> the people here will write the code for you!
18:46:34 <fantasma> thorat, thanks for the link
18:47:53 <Laney> How would I go about running over a list replacing each cons alternately with - then +? ie [1, 2, 3, 4] -> 1 - 2 + 3 - 4
18:48:36 <sorear> > sum $ zipWith (*) (cycle [1, -1]) $ [1,2,3,4]
18:48:38 <lambdabot>  -2
18:48:59 <LoganCapaldo> huzzah, it compiled and worked
18:49:02 <LoganCapaldo> thanks
18:49:58 <fantasma> how do I return to ghci prompt after breaking a program with ^C
18:50:02 <Cale> fantasma: it's not so bad
18:50:11 <Cale> (learning lisp after Haskell)
18:50:21 <fantasma> Cale, would there be any reason to do so?
18:50:38 <Cale> Hmm, to learn another language? :)
18:50:47 <thorat> fantasma: it's simpler to implement
18:50:49 <Laney> Thanks, sorear! That kind of trickery still eludes me sadly :(
18:50:50 <humasect> does haskell prime have a direction and/or goal ?
18:51:02 <Cale> Lisp has a nice macro system, and some lisps are easier to implement than Haskell.
18:51:14 <fantasma> i see
18:51:21 <allbery_b> @where haskell-prime
18:51:22 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
18:51:26 <jcreigh> Lisp is cool because it's fairly powerful (compared to C-like languages, anyway) but the whole thing comes from very simple axioms.
18:51:28 <yip> Cale: hi, did you see my haskell web chat application?
18:51:32 <allbery_b> it should all be there.
18:51:36 <Cale> humasect: To write down standards based on current practices.
18:51:41 <Cale> yip: no, I haven't
18:51:56 <yip> Cale: if you are interested, join us now: http://feld.sh.nu:2000/
18:52:01 <humasect> Cale: ah, great! thanks.
18:52:41 <allbery_b> now, whether they';rre going to fix sme of the warts in the layout rule (cf. recent cafe messages), or that bizarre brace insertion thing...
18:54:19 <thorat> fantasma: well, do you mean Common Lisp (HUGE) or Scheme (fairly advanced) or just something lispy
18:54:43 <Laney> Woohoo, one line pi calculator!
18:54:45 <fantasma> thorat, I am not quite sure of the difference between those
18:54:46 <Laney> > let x = 1000 in sum $ zipWith (*) (cycle [1, -1]) $ take x $ map (\n -> 4 / fromIntegral n) [1, 3 ..]
18:54:47 <lambdabot>  3.140592653839794
18:55:17 <thorat> fantasma: LISP in general is an open term AFAIK
18:55:40 <thorat> fantasma: it's a family of languages that have a lot of parentheses
18:55:40 <fantasma> thorat, more like a standard you mean?
18:55:43 <mbishop> LISP is no longer used
18:55:55 <thorat> ;)
18:56:03 <mbishop> It's 'Lisp'
18:56:06 <thorat> ok
18:56:22 <fantasma> i just like it because of the (((((
18:56:29 <fantasma> looks fun
18:56:59 <allbery_b> sorry, recent cafe stuff was on literate haskerll.  layout rule was a couple months ago
18:57:22 <ddarius> Good ole Frank Pfennig
18:57:37 <thorat> fantasma: http://www.joeganley.com/code/jslisp.html
18:57:38 <lambdabot> Title: Joe Ganley's Lisp in JavaScript
18:57:46 <thorat> fantasma: have fun
18:58:51 <fantasma> thorat,  :)
19:00:06 <Laney> @src fix
19:00:06 <lambdabot> fix f = let x = f x in x
19:02:51 <tensh> 99 questions is great
19:03:30 <ddarius> "Given the central role of types in modern programming language design and analysis, Types and Programming Languages is probably the single most important book in the area of programming languages in recent years."
19:03:54 <fantasma> > let factors n = filter (isDivisible) [1..n] where isDivisible x = n `mod` x == 0 in factors 100
19:03:55 <lambdabot>  [1,2,4,5,10,20,25,50,100]
19:04:36 <emu> ddarius: well Pierce was one of his students
19:11:47 <LoganCapaldo> So I says to myself, self, I don't want to add state to my calculator
19:12:11 <LoganCapaldo> mmm
19:12:42 <dons> ?users
19:12:42 <lambdabot> Maximum users seen in #haskell: 332, currently: 284 (85.5%), active: 42 (14.8%)
19:12:43 <ddarius> Why would you?
19:13:20 <LoganCapaldo> Trying to inch toward an interpreter ;)
19:13:34 <ddarius> Of?
19:13:47 <LoganCapaldo> of whatever ad hoc little language I come up with
19:13:51 <LoganCapaldo> heh
19:14:11 <matt__r> hi peeps
19:14:35 <dons> hey matt__r
19:14:38 <dons> how's code?
19:14:41 <matt__r> anyone know how to capture the stdout output of commands you invoke with system?
19:14:46 <matt__r> dons: hey
19:14:49 <dons> yeah, don't use system.
19:14:52 <dons> use System.Process
19:14:53 <LoganCapaldo> @hoogle popen
19:14:53 <lambdabot> No matches found
19:14:56 <LoganCapaldo> dra
19:14:59 <LoganCapaldo> *drat
19:15:04 <matt__r> dons: legend
19:15:07 <matt__r> dons++
19:15:09 <allbery_b> dons has an alternative to System.Process somewhere, I think
19:15:21 <dons> e.g to catch stderr and stdout,
19:15:23 <dons> run s = do
19:15:24 <dons>     (ih,oh,eh,pid) <- runInteractiveCommand s
19:15:24 <dons>     hClose ih
19:15:24 <dons>     so <- hGetContents oh
19:15:24 <allbery_b> (or rather a wrapper for it)
19:15:26 <dons>     se <- hGetContents eh
19:15:28 <dons>     map length [so,se] `seq` return ()
19:15:31 <dons>     return (lines $ so ++ se)
19:15:34 <dons> yeah, i've a wrapper, in semi complete state:
19:15:36 <dons> ?where newpopen
19:15:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/newpopen
19:16:00 <LoganCapaldo> runInteractiveCommand is the name for popen eh?
19:16:04 <dons> map length [so,se] `seq` return () looks bogus, actually
19:16:09 <dons> LoganCapaldo: yeah. roughly
19:16:13 <dons> ?docs System.Process
19:16:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
19:16:16 <LoganCapaldo> or does rIC also do a pty?
19:16:33 <dons> lexical error in sentence: rIC
19:17:08 <LoganCapaldo> I'm sorry, I don't have code completion in my irc client
19:17:13 <LoganCapaldo> runInteractiveCommand :)
19:17:46 <LoganCapaldo> dons: You are quite prolific
19:18:04 <matt__r> System.Process is ghc-specific right?
19:18:04 <dons> there's 3 of us.
19:18:17 <dons> hmm. you want it for nhc or yhc?
19:18:21 <dons> it should be portable
19:18:24 <dons> since its in base.
19:18:37 <matt__r> dons: no, just explains why i could not find it from hugs
19:18:39 <matt__r> :)
19:18:53 * LoganCapaldo wonders if the 3 dons thing was true or a joke
19:19:06 <matt__r> if only ghci could get faster I could stop having issues like this
19:19:15 <matt__r> \me thinks it is
19:19:20 <matt__r> oops
19:19:23 <Uriko04> lol.
19:19:26 <matt__r> too much texing
19:19:28 <Uriko04> is haskell even a real language?
19:19:28 <lawl> o funny i thot haskell was a type of dog
19:19:32 <Uriko04> lmfao
19:19:45 <dons> matt__r: hugs ain't so great these days, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
19:19:45 <lambdabot> Title: nobench: Haskell implementation shootout
19:19:53 <lawl> course im no dog specialist
19:19:58 --- mode: ChanServ set +o dons
19:20:22 <matt__r> nah - but for little hacky scripts where I have to start interpreter, do something, then close interpreter, it is wonderful
19:20:27 <lawl> u guys know 90% of females are males
19:20:29 <matt__r> all in the startup speed
19:20:33 --- mode: dons set +b *!*i=fkoff@*.cpe.net.cable.rogers.com
19:20:33 --- kick: lawl was kicked by dons (dons)
19:20:58 <dons> my nop benchmark had ghci at 0.5s and hugs at 0.3s
19:21:01 <dons> for startup
19:21:18 <xerecks> hello
19:21:22 <xerecks> is this internet explorer 7 support??
19:21:24 <Uriko04> du du du
19:21:32 <Uriko04> so..haskell
19:21:34 <isxerxeshot> DCC SEND OMFGLOLROFLLOLOLLOLLLERSKATESLOLOLOLILOVEXERXES
19:21:38 <Uriko04> who is haskell?
19:21:38 <matt__r> dons: is that on a million-core athlon?
19:21:39 <dons> hmm
19:21:41 <xerecks> is this internet explorer 7 support?? ???????
19:21:43 <dons> 16 core.
19:21:43 <araujo> wtf is this?!
19:21:45 <xerecks> or wrong chan????
19:21:52 <dons> xerecks: yes.
19:21:53 <Uriko04> this is the right chan
19:21:57 <Uriko04> i think
19:21:59 <Uriko04> idk
19:22:04 <Uriko04> haskell==internet eplorer 7
19:22:10 <allbery_b> ???
19:22:10 --- kick: Uriko04 was kicked by dons (dons)
19:22:11 <bd_> @remember xerecks hello. is this internet explorer 7 support??
19:22:12 <lambdabot> Done.
19:22:17 --- mode: dons set +b *!*n=uriko04@*.dsl.bell.ca
19:22:17 <regecks> i think isxerxeshot exploited the channel :\
19:22:17 --- kick: Uriko04 was kicked by dons (dons)
19:22:21 <xerecks> so
19:22:21 <xerecks> ok
19:22:30 <xerecks> i have this problem i had this internet explorer 7 on the desktop
19:22:32 --- mode: dons set +b *!*n=heloto@*.telia.com
19:22:32 --- kick: xerecks was kicked by dons (dons)
19:22:44 <matt__r> dons: indeed, I think the difference is a little more substatial on my old g4
19:22:48 <regecks> so anyway
19:22:49 <regecks> my ie7
19:22:50 <regecks> isnt working
19:22:50 * allbery_b notes the date and wonders...
19:22:53 <dons> re	no.
19:22:54 <regecks> tryed getting cracks
19:22:56 <regecks> but ti dun start?
19:22:59 --- mode: dons set +b *!*n=irc@unaffiliated/regecks-x1337
19:22:59 --- kick: regecks was kicked by dons (dons)
19:23:05 <ddarius> Why?
19:23:08 <dons> ok. haskell channel. no DOS attacks thanks
19:23:25 <dons> ddarius: 8 people with cloaked urls join in 5 mins to ask about ie and trol?
19:23:25 <matt__r> ahhhh, that's better
19:23:33 <allbery_b> xerxes = achashverosh (ahasuerus)
19:23:37 <allbery_b> purim is Sunday
19:23:46 <yip> hm.... purim
19:23:50 <dons> allbery_b: ?
19:23:51 * LoganCapaldo feels like he just narrowly escaped from a bad episode of the twilight zone
19:23:54 <ddarius> dons: I was asking Why? they did it.  What is the allure?
19:24:17 <allbery_b> dons: remember the story of Esther?
19:24:17 <dons> rather strange.
19:24:31 <matt__r> same reason kids pinch their sister and then run away laughing
19:24:35 <allbery_b> just musing on what is probably coincidence
19:25:29 <dons> i seem to remember lawl before, actually. /me checks the logs
19:25:37 <matt__r> dons: that nobench is wonderful
19:25:46 <matt__r> I could stare at those numbers all day
19:25:55 <matt__r> and then they would update and could start all over again
19:26:00 <dons> nothing like public competition to drive open source dev :-)
19:26:04 --- mode: ChanServ set -o dons
19:26:26 <moonlite> :)
19:26:32 <sorear> @users
19:26:33 <lambdabot> Maximum users seen in #haskell: 332, currently: 292 (88.0%), active: 49 (16.8%)
19:27:08 <dons> ah.
19:28:38 <dons> matt__r: note the ghc -fasm backend does pretty well on amd64
19:29:04 <dons> there's also x86 results if you click on the title
19:29:12 <ddarius> It has a NCG for AMD64?
19:29:17 <dons> yeah
19:29:24 <dons> a pretty good one
19:29:43 <ddarius> Yeah, I think I remember it being implemented a few minor versions ago.
19:30:29 <matt__r> dons:  that's really impressive.  I think you have to keep up with new architectures - even if it all academic from my pov :)
19:30:45 <matt__r> NCG for PowerPC? :)
19:30:50 <dons> yes, that too
19:31:49 <ihope> You know, this channel has rather a lot of bans.
19:32:19 <ihope> The banlist is twice to three times as long as #math's...
19:32:27 <allbery_b> this channel has its share of intruding kooks like the above
19:33:00 <dons> ihope: we really really try to keep the signal high
19:33:12 <dons> so we're very active about this.
19:33:28 <ihope> The signal-to-noise ratio?
19:33:28 <audreyt> $&!(%*$(@*!(#@#NO CARRIER
19:33:43 <audreyt> (sorry, can't resist)
19:33:47 <dons> :)
19:34:27 <dons> ihope: first principle of maintaining an open source community -- don't let your core devs get distracted
19:34:42 <ddarius> ihope: How big is #math?  Anyways, #math is presumably not "partisan" in any explicit way.
19:34:53 <dons> so anyone not interested in helping the community is of no interest here
19:35:15 <ihope> #math is almost as big as #haskell. 250-some.
19:35:24 <ihope> Rather, 250+some. :-)
19:35:30 <dons> there's a reason people cite #haskell as one of the most useful channels around, we foster the core contributors, and are ruthless with pests
19:35:44 <dons> so you can drop in here and still find the lead devs of major haskell projects
19:36:05 <yip> like me :P
19:36:11 <dons> that's key, and we'll keep banning pests to maintain that.
19:36:22 <dons> like yip, for example. if you want gameboy-in-haskell advice, he's your man
19:36:41 <dons> ?wiki Protect_the_community
19:36:41 <lambdabot> http://www.haskell.org/haskellwiki/Protect_the_community
19:36:42 <sorear> \NUL
19:36:54 <yip> exactly. or if you want to know how to take the length of an infinite list
19:36:56 <ClaudiusMaximus> and #haskell is helpful and polite to near-clueless (but willing to learn) newbies like me :)
19:37:25 <ClaudiusMaximus> #haskell++
19:37:28 <dons> yeah! so we pass on the good will, train the newbies to become the next generation of teachers, and the irc cycle of life goes on
19:37:33 <bd_> ?karma #haskell
19:37:34 <lambdabot> #haskell has a karma of 5
19:37:41 <yip> ok when i act like this it means it's my bedtime... gnight all!
19:38:16 * nrb23 just got The Haskell School Of Expression in the mail :->
19:38:21 <dons> nice.
19:38:45 <nrb23> now I just need to find time to read it
19:39:02 <nrb23> and work on etherbunny, which I've finally put into hacakge
19:39:16 <nrb23> ?where Etherbunny
19:39:16 <lambdabot> I know nothing about etherbunny.
19:39:31 <nrb23> ?where+ Etherbunny http://etherbunny.anytini.com
19:39:31 <lambdabot> Done.
19:39:33 <dons> ah yes! I saw
19:39:38 <dons> verygood, nrb23
19:39:44 <nrb23> :->
19:39:49 <nrb23> it's still really crappy
19:39:55 <nrb23> but I'd appreciate any feedback on coding style
19:40:15 <dons> you should announce it on haskell-cafe@ too
19:40:23 <nrb23> probably
19:40:29 <dons> otherwise its only the obsessives who read the hackage rss feed who know about it
19:40:33 <nrb23> I was thinking of waiting until my next release
19:40:54 <nrb23> in which I plan to add an expression parser for filtering its output
19:41:19 <yip> interesting
19:41:30 <nrb23> also, while I'm here, I should plug http://anytini.com :->
19:41:33 <lambdabot> Title: Welcome to Anytini.com
19:41:38 <dons> ihope: does all the above make sense?
19:42:20 <ihope> Yeah, I think so.
19:42:23 <dons> nrb23: oh? is it written in haskell+happs+haxml?
19:42:31 <nrb23> dons: I wish :-<
19:42:38 <nrb23> dons: It's Ruby on Rails
19:43:09 <sorear> nrb23 has a hackage account?
19:43:15 <yip> it's only a matter of time until HAppS kills rails :)
19:43:17 <nrb23> sorear: yeah, it's "nickburlett"
19:43:24 <dons> ihope: we learnt some lessons early on, e.g. with smerdyakov, who then went on to damage #ocaml, so we're hyper vigilent about keeping the core community operating well now. hence the rapid bans, hence the wiki with policy and so on
19:43:32 <ndm>     conflict: module `System.FilePath.Version_0_10'
19:43:34 <ndm>     belongs to the current program/library and also to package FilePath-0.11
19:43:38 <dons> particularly in light of the rapid growth in here, we want to keep the good stuff working, even under load
19:43:45 <sorear> ndm: hi!
19:43:46 <ndm> any idea what that means?
19:43:48 <ndm> sorear: hi
19:43:58 <nrb23> nrb23 was my username at Cornell, so I continue to use it from my mac
19:44:00 <ihope> What happened with smerdyakov?
19:44:08 <ndm> other than the obvious, i'm certain that the module isn't in teh current project
19:44:09 * ddarius doesn't generate very much code.
19:44:25 <sorear> ndm: Ayhi.BCLoader can trace deps from the YHC Prelude, and parse the whole thing
19:44:29 <ndm> i'd like to know where GHC thinks it is, but it doesn't say with 0v
19:44:34 <ndm> sorear: neat :)
19:44:37 <dons> check the logs from a few years ago, he was very harsh on newbies, and damaged the friendliness of the channel. so despite being technically sound, he was banned.
19:44:50 <ndm> sorear: i'm currently rewriting the build system for Yhc :)
19:45:03 <sorear> ndm: btw I noticed an inconsistency between the .hbc format and Yhc/RTS/hbc
19:45:10 <sorear> ndm: very cool. scons--
19:45:24 <ndm> sorear: email it to the list, telling tom
19:45:26 <nrb23> well, I'm certainly glad this community is as awesome as it is
19:45:31 <moonlite> dons: nice policy. Unfortunately a bit uncommon i think
19:45:31 <sorear> ndm: ?
19:45:43 <ddarius> nrb32: As am I.
19:45:48 <ddarius> Bah 23
19:45:57 <sorear> I've never known different :)
19:46:04 <nrb23> ddarius: bah 23?
19:46:08 <ndm> sorear: email the list with any inconsistencies in the documentation, there are likely to be some, since its quite a lot of depth in the docs
19:46:12 <ddarius> nrb32 v. nrb23
19:46:41 * sorear 's only prior IRC experience was a #osdev on I-forget-which-network, also pretty nice but nowhere near this big
19:46:45 <nrb23> ddarius: ooh, I didn't even notice! which is weird, because Colloquy hi-lights things for me
19:47:15 <dons> ihope: I think the difference is #math is that they don't have an external project and set of community goals they're trying to achieve. its just random math guys. here though we have a core group trying to push haskell forward, which is a uniting force, but also means we have to be more active at maintaining that
19:47:20 * ddarius had very little IRC experience before #haskell, but is referring to the community at large.
19:47:21 <nrb23> I'm often on #python, #twisted, and #twisted.web as nickburlett or nburlett
19:47:58 <ddarius> dons: Haskell and thus #haskell has a visibility that #math can't have.
19:48:03 <dons> yeah.
19:48:06 <ddarius> As well as detractors.
19:48:11 <nrb23> aww crud.. I was going to email ijones before I left work. He ever show up here?
19:48:25 <dons> @seen SyntaxNinja
19:48:25 <lambdabot> I saw SyntaxNinja leaving #darcs, #haskell, #haskell-blah and #haskell-overflow 1h 52m 16s ago, and .
19:48:32 <dons> nrb23: ^^
19:48:35 <nrb23> ahh
19:48:53 <nrb23> he still working for Galois?
19:48:58 <dons> he is, yes.
19:49:06 <nrb23> good then
19:49:12 <dons> ddarius: also the size of #haskell is enough now on its own to warrant unwelcome attention
19:49:25 <ddarius> The size of Haskell as well.
19:49:34 * allbery_b got tired of the usual IRC crap years ago
19:49:44 <dons> allbery_b: so do you find things work here? can we improve?
19:49:50 <dons> what can we do better?
19:49:54 <allbery_b> the channels I'm in are either small or well patrolled (like here and #lopsa)
19:50:11 * ddarius 's programming community experience besides #haskell mostly comes from web forums or newsgroups.
19:50:21 <nrb23> is #haskell registered-users only?
19:50:26 <ddarius> Heck no.
19:50:36 <dons> ddarius: and any thoughts on how the channel has changed since the early days, given your absence? are we doing things right still?
19:50:57 <dons> nrb23: no, its a free for all, of course. open to all. free cpu time for all :-)
19:51:00 <allbery_b> #lopsa doesn't quite have the same level of focus, but we're all sysadmins, we're all rather tired of crap, and as a result we react to it quickly and decisively :)
19:51:38 <dons> > (\x -> x) 7 -- pure lambdas for everyone!
19:51:39 <lambdabot>  7
19:51:48 <nrb23> I believe #python is registered only. I've been impressed by the lack of ***holes there
19:51:52 <nrb23> (here too)
19:52:32 <nrb23> > 7 -- optimized version of dons' code
19:52:33 <lambdabot>  7
19:52:41 <sorear> betaconversion++
19:52:44 <dons> :-)
19:52:48 <dons> @pl (\x -> x) 7
19:52:48 <lambdabot> 7
19:53:00 <nrb23> is that beta conversion? I can never keep track of the names
19:53:04 <ddarius> dons: Obviously it's grown.  Since I left there's a lot more focus on newbies (or rather much more of them to focus on, #haskell has always been -very- friendly to them).  Also a lot of focus on specific projects (again in part because there are a lot more visible ones). The freewheeling idea churning/brainstorming seems less than before though perhaps that's just the cross section of people I get now.
19:53:34 <ddarius> nrb23: Beta-reduction, yes.
19:53:36 <allbery_b> that still happens here sometimes, other times it's on #haskell-overflow from what Ive' seen
19:53:50 <dons> yeah.
19:53:57 <nrb23> ?karma nrb23
19:53:57 <lambdabot> You have a karma of 0
19:53:58 <Cale> Alpha's the trivial renaming one and eta is adding/removing parameters.
19:54:04 <dons> a bit of technical stuff happens on #haskell-overflow
19:54:07 <nrb23> :-<
19:54:12 <dons> maybe it should be called #haskell-tech
19:54:29 <ndm> i like the fact that the mailing lists have very ambiguous names
19:54:33 <ndm> keeps it more free
19:54:34 <dons> as much as possible though, its good to have technical stuff here too
19:54:36 <ddarius> allbery_b: So far as I've seen, though I may not have been here long enough. #haskell-overflow captures the more one-on-one think-things through part.
19:55:01 <dons> yeafor eample, we wrote a lot of the bytestring paper in #haskell-overflow
19:55:11 <allbery_b> I've seen both, although the most recent stuff has indeed been more one-on-one brainstorming
19:55:19 <ddarius> I noticed you a dcoutts working on the next version there yesterday.
19:55:25 <dons> yep.
19:55:39 <dons> list fusion redone
19:55:42 <ddarius> #haskell seems a bit more serious than before.
19:55:44 <dons> faster, more fusion
19:55:58 <ddarius> A little less bouyant.
19:56:06 <allbery_b> well, it has gotten a bit large
19:56:09 <dons> less shapr  around to @yow us
19:56:20 <nrb23> what is list fusion?
19:56:24 * ddarius was thinking that less shapr may be a significant part of that.
19:56:28 <dons> i guess i'm more serious than shapr too, maybe that affects things.
19:56:37 <allbery_b> some ways it might make sense to split it more.  -tech -fun (as distinct from -blah!) -theory maybe
19:56:42 <ddarius> dons: Almost everyone is more serious than shapr.
19:56:47 <dons> that's true
19:56:52 <yip> <-
19:57:08 <dons> allbery_b: so fun is #haskell-blah, and -overflow is -tech
19:57:08 <allbery_b> (the latter for the occasional outbreaks of category theory which leave me wachingt he discussion soaring waaaay overhead :)
19:57:17 <dons> we could make the -overflow goals a bit more explicit
19:57:32 <ddarius> allbery_b: I wouldn't like that. Anyways, there usually isn't enough traffic to warrant it.
19:57:44 <ddarius> allbery_b: Those were fun.
19:58:05 <ddarius> And they usually pulled some people in.
19:58:10 <allbery_b> we also have -newbies but t hasn't gotten any use that I've seen (I didn't even bother to rejoin last time  had to restart)
19:58:23 <ddarius> @seen lambdabot
19:58:23 <lambdabot> Yes, I'm here. I'm in #haskell.de, #haskell.fr, #happs, #haskell.es, #montevideolibre, #parrot, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #
19:58:24 <lambdabot> haskell.dut, #haskell-overflow, #haskell-blah and #haskell
19:58:37 <LoganCapaldo> theres a -newbies?
19:58:42 <nrb23> there's a gentoo- ?
19:58:55 <allbery_b> wrong name, I guess, neither -newbie nor -newbies
19:59:10 <allbery_b> #haskell-new*something* that I've forgotten and forgot to register with xchat
19:59:13 * LoganCapaldo feels very lonely in nerwbies
19:59:17 <allbery_b> and never had many members or any activity
19:59:22 <LoganCapaldo> I'm the only newbie in the world
19:59:25 <allbery_b> oh, stil lthere?
19:59:41 <LoganCapaldo> heh
19:59:41 <nrb23> LoganCapaldo: I'm mostly newbie
20:00:12 * ddarius is newbie at QFT.
20:00:20 <ventonegro> i'm a complete newbie
20:00:36 <allbery_b> looks gone to me
20:00:40 <LoganCapaldo> Quantum Field Theory?
20:00:41 * allbery_b just did a channel list
20:01:01 <ddarius> LoganCapaldo: Yes.
20:01:08 <nrb23> Quoted For Truth?
20:01:19 <nrb23> http://www.urbandictionary.com/define.php?term=QFT
20:01:19 <lambdabot> Title: Urban Dictionary: QFT
20:01:30 <nrb23> @google QFT
20:01:33 <lambdabot> http://www.queensfilmtheatre.com/
20:01:33 <lambdabot> Title: Queens Film Theatre, Belfast cultural cinema Northern Ireland
20:01:47 <nrb23> weird.. that's not what I get
20:02:01 <ndm> woohoo, i just compiled the yhc executable with the new build system!
20:02:04 <LoganCapaldo> @acronymfinder QFT
20:02:04 <lambdabot> Unknown command, try @list
20:02:12 <LoganCapaldo> it was worth a shot
20:02:20 <mbishop> I think lambdabot doesn't have safe search on :P
20:02:25 <allbery_b> @dict-all QFT
20:02:25 <lambdabot> Unknown command, try @list
20:02:30 <mbishop> @google naked
20:02:32 <lambdabot> http://www.nakednews.com/
20:02:32 <lambdabot> Title: Naked News ~ news sports entertainment games movies travel
20:02:34 <allbery_b> @list dict
20:02:34 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
20:02:36 <mbishop> heh
20:02:39 <nrb23> naked news is hardly SFW
20:02:40 <allbery_b> @all-dicts QFT
20:02:41 <lambdabot> No match for "QFT".
20:02:54 <LoganCapaldo> nrb23: I think that depends where you work
20:03:10 <nrb23> LoganCapaldo: yes, I suppose if you work in the Porno industry
20:03:19 * LoganCapaldo begins work on philosophy, NSFW Relativism
20:03:32 <allbery_b> nobody's going to say anything if I view it in my office at CMU...
20:03:39 * nrb23 visits the reddit #1 link (from home)
20:03:47 <dons> ndm, ooh? more info please?
20:03:52 <dons> ndm, make -j support ??
20:03:54 <mbishop> reddit is not safe for anywhere
20:04:09 <ndm> dons: does ghc have make -j support?
20:04:10 <dons> and do you want -j support tested?
20:04:14 <dons> no.
20:04:21 <dons> but ... ghc -M does
20:04:23 <ndm> dons: build system written in haskell
20:04:35 <dons> ok. so hmm, it uses ghc --make underneath?
20:04:41 <ndm> yeah, pretty much
20:04:50 <ndm> just going for much more reliable
20:04:52 <dons> ok.
20:05:00 <ndm> and much simpler - we have a 1300 line build system at the mo...
20:05:18 <dons> when you have 15/16ths of your machine idle during a build, you might start to care though ;)
20:05:42 <nrb23> so, when does the Evil Mangler die a horrible death?
20:05:42 <ndm> get ghc --make to have -j, and we will
20:05:51 <LoganCapaldo> You can send the idle processors over to me, I'll make use of em
20:06:39 * ddarius proposes to set up a Haskell compilation service on dons' machine.  Send your code in and get back object files.
20:06:41 <yip> what about parallel compilation? :o
20:07:38 <ddarius> ndm: How big is the Haskell build system right now?
20:08:16 <ndm> ddarius: 400 lines, so far, will probably grow to about 600 by the time its finished
20:08:20 <ndm> maybe 800
20:08:27 <ndm> but its nicely modular so far
20:11:07 <ddarius> Cool.
20:11:39 * ddarius suggested an idea to someone but can't remember it and thinks it was something he wouldn't mind doing himself.
20:11:48 <ndm> it will also support cross compiling much easier, you can do neat things like "build os=mac" and thats valid
20:12:25 <nrb23> what about direct code gen?
20:15:08 <bos> wowie zowie.
20:15:23 <bos> there are going to be haskell talks at oscon this year.
20:15:44 <ddarius> bos: Link to program?
20:15:51 <nrb23> now if we could just get talks about haskell at ESC West
20:16:07 <bos> i'll post more details when the programme is finalised.
20:16:17 <ddarius> bos: teaser
20:16:26 <bos> i only just found out.
20:16:53 <yip> bos: please change the topic here at that time, if appropriate
20:17:03 <dons> bos, oh?
20:17:13 <bos> i think it'll be the first presence of haskell in a mainstream setting like that. oscon is usually swarming with web/python/ruby geeks.
20:17:15 <dons> the L4 kernel guys?
20:17:44 <bos> no, someone else.
20:18:00 <dons> bos, i see you made the top 10 list (or something like it) for kernel modifications, well done :-)
20:18:07 <bos> yeah, busy year :-)
20:18:39 <dons> bos, so native STM support in kernel next? ;)
20:18:48 <bos> you betcha :-)
20:19:25 <yip> that reminds me: is it possible to have an STM implementation for c?
20:19:34 <bos> sure, people have done it.
20:19:38 <bd_> yip: Possible? Yes. But probably a bad idea :)
20:19:41 <yip> implemented as a regular c library?
20:19:45 <ddarius> yip: The "original" STM implementation was C++ or C.
20:19:46 <dons> would be nice to have an lkm for the ghc runtime too. so haskell progs just run directly on the kernel, instead of their own runtime in userland ..
20:19:48 <bos> google for "word-level software transactional memory".
20:19:55 <bos> that's what maurice herlihy originally did.
20:20:05 <bos> heh.
20:20:07 <ddarius> @google Practical Lock Freedom
20:20:09 <lambdabot> http://www.cl.cam.ac.uk/~kaf24/lockfree.html
20:20:09 <lambdabot> Title:
20:20:43 <bos> is that keir fraser's stuff?
20:20:44 <yip> bos: so retry ends up as a function call? how does orElse end up?
20:20:45 <bos> yeah.
20:20:47 <ddarius> hai
20:20:57 <bos> yip: no, the combinators came much later, via simonpj.
20:21:12 <yip> bos: oh... without retry and orElse, then the system is useless :\
20:21:42 <bos> there's also an STM system available for java.
20:22:16 <ddarius> bos: That thesis was great for making it possible to think about lock free data structures.
20:22:24 <yip> does that have retry and orElse?
20:22:41 <ddarius> yip: No, I don't think so.
20:22:49 <bos> no, only haskell's STM has.
20:23:07 <nrb23> woot dinner
20:23:27 <ddarius> yip: retry relies on purity.
20:23:29 <yip> bos: guess i'm sticking with haskell then :)
20:23:45 <bos> yip: yeah.
20:24:04 <ddarius> yip: retry and orElse are the -only- reasons to prefer Haskell to Java.
20:24:07 <yip> ddarius: i would imagine that even without retry you need to rely on purity since a transaction can be retried without exclicitly being told to do so
20:24:20 <dons> ddarius: how do you guarantee purity in Java though?
20:24:36 <ddarius> dons: ?
20:25:31 <yip> bos: why is retry and orElse so difficult to implement in java?
20:25:51 <bos> everything is difficult to implement in java.
20:26:17 <yip> bos: why is retry and orElse so difficult to implement in c?
20:26:18 <bos> but, you know, some ideas take a while to percolate around.
20:26:29 <sorear> because people in #haskell are forbidden to praise java and strongly discouraged from knowing it.
20:26:30 <bos> if you want them, write them. it's all just typing.
20:26:52 <yip> ok. so i guess it won't be long until c/java/c# have full STM support
20:26:58 <bos> i wrote an STM implementation in python on a lark. it's not hard.
20:27:54 <yip> would be interesting to design a c-like language where all variables are transactional
20:27:55 * sorear momentarily considered the difficulty of getting the lark to hold still long enough, then felt very silly for having done so
20:28:09 <dons> ddarius: oh, I thought there were issues with rerunning side effecting code. but is that the retry stuff that's not provided elsewhere?
20:28:59 <allbery_b> pythons are good at holding their prey :)
20:29:01 <ddarius> From what bos was saying, a brief glance, and the stuff in Fraser's thesis, retry and orElse are only in Haskell.
20:29:50 <bos> the problem with writing STM in another language is that you can't restrict side effects.
20:30:16 <bos> so the all-or-nothing advantage is denied you.
20:30:31 <yip> bos: well, even in haskell you can never be sure that some function doesn't have unsafePerformIO hidden below
20:30:50 <ddarius> yip: But then the programmer gets what he/she deserves.
20:30:55 <bos> sure, but that's a very different level of problem.
20:31:12 <bos> in one case, you're screwed all the time, in the other, only if you're not careful.
20:31:42 <ddarius> Only if you explicitly say screw me. (Ignoring libraries that might misuse it, but then...)
20:32:02 <dons> whereas side effects are little understood, and actively encouraged, most everyhere else
20:32:11 <dons> so there's a good chance arbitrary code does have some side effect
20:32:33 <dons> a matter of docs and teaching versus type checking ;)
20:32:42 <yip> yeah, obviously haskell is superior at this. i'm just saying that there it shouldn't be that much of a problem in other languages, if you have discipline
20:33:13 <ddarius> yip: Even with other languages many times you don't have too much of a choice about using side effects.
20:33:26 <dons> programmers don't have discipline though ;) that why we have type systems in the first place
20:33:46 <LoganCapaldo> I thought we had type systems so we could be lazy when we did proofs?
20:33:51 <ddarius> Anyways, the first HOF, Strategy pattern, Template pattern and you're screwed.
20:34:13 <ddarius> yip: You can't force your users to be disciplined.
20:34:16 <LoganCapaldo> Now you're telling me its because I'm undisciplined :(
20:34:28 <yip> but transactions should be short and minimal anyway, it should be clear that they don't perform side effects
20:35:09 <LoganCapaldo> tell that to the lemme not put a lock on this programmers, or the lemme put one giant lock around everything programmers :)
20:35:57 <yip> anyway i really should get to sleep
20:37:00 <sorear> methinks lambdabot should automatically kick+8h ban people who say they need to sleep
20:37:13 <sorear> would certainly help me :)
20:37:31 <dons> go to bed sorear !
20:37:41 <LoganCapaldo> @bed
20:37:42 <lambdabot> Maybe you meant: bf bug id let read redo
20:37:49 <LoganCapaldo> @help bed
20:37:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:37:55 <sorear> well, not yet today, in the past :)
20:38:10 <LoganCapaldo> @bed. Kick-bans you for a period of 8 hours
20:38:10 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 28}) "Parse error"
20:38:31 <allbery_b> make it tunable?  6h for me :)
20:44:07 <dons> ndm, around?
20:44:20 <dons> ndm: I'm not sure I can run very many things without System.Environment :/
20:44:26 <dons> i.e. getArgs
20:44:37 <ndm> dons: we gave you getArgs didn't we?
20:44:45 <dons> not in Stable-1
20:44:55 <dons> is there a way to use getArgs back then?
20:45:07 <ndm> dons: only Tom would know, i'm afraid
20:45:09 <ddarius> 4h would work for me.
20:45:16 * dons pokes around in the yhc-base
20:46:47 <dons> ndm, can you get Tom in here more often?
20:46:56 <ndm> dons: i rarely see Tom as it is...
20:47:17 <ndm> dons: hardcode the Queens problem to 10, thats how Tom tested it
20:47:54 * LoganCapaldo wonders about the mysterious Tom person
20:47:58 <dons> ah ok hmm.
20:48:09 <fantasma> i need a fast way to get factors for a number
20:48:26 <dons> i've got a couple here that don't use getArgs as well
20:48:37 <LoganCapaldo> You and the crypto-analytic community :)
20:49:38 <fantasma> anyone :)
20:50:02 <dons> fantasma: use an algorithm :-)
20:50:16 <dons> > gcd 10
20:50:18 <lambdabot>  <Integer -> Integer>
20:50:30 <dons> > gcd 13 26
20:50:31 <lambdabot>  13
20:50:37 <sorear> ndm: we can't unconditionally hardcode numbers
20:50:49 <sorear> ndm: it makes the jhc constant folder go crazy
20:50:52 <fantasma> filter (isDivisible) [1..n] where isDivisible x = n `mod` x == 0
20:51:01 <dons> sorear: just for testing purposes
20:51:02 <ndm> sorear: i just meant for the testing of Yhc-old vs Yhc-new
20:51:11 <ndm> hehe, why not hard code some numbers in there then ;)
20:51:13 <dons> so we can double check if yhc-old really does have a perf advantage
20:51:32 <dons> so i'm checking yhc-old against nhc98-new now, with n=13 hardcoded
20:51:37 <dons> for queens.
20:51:48 <sorear> ndm: it would give jhc an unfair advantage :)
20:52:09 <dons> jhc would just reduce the program down staticaly ;)
20:52:19 <ivanm> so are yhc, jhc and nhc usable or still under development?
20:52:25 <ndm> what if the program is non-terminating
20:52:39 <dons> nhc is useable for most of h98. http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
20:52:39 <lambdabot> Title: nobench: Haskell implementation shootout
20:52:43 <ndm> ivanm: you'd be better off sticking to hugs/ghc, but yhc/jhc may be ones to watch in the future
20:52:57 <ivanm> ndm: so how do they differ? what's so great about them?
20:52:59 <dons> i would argue hugs is to be abandoned now.
20:53:11 <dons> its the slowest by far, ugs.
20:53:12 <ndm> dons: i do all my development in Hugs, nooooooo!
20:53:14 <ivanm> because of ghci?
20:53:24 <ndm> hugs is by far the fastest at load times
20:53:33 <ndm> 7 seconds vs 7 minutes for the Yhc code base
20:53:40 <ndm> that alone makes Hugs worth keeping
20:53:47 <dons> hugs can't run any real data sets though
20:53:58 <dons> no strictness analysis means it fails on just too many things
20:53:59 <fantasma> only small fake ones
20:54:30 <ndm> real data sets don't have to be massive
20:54:38 <ndm> useful programs don't have to take long at all
20:54:47 <ndm> and nhc lacks strictness too
20:55:04 <dons> but nhc is faster. so use that
20:55:31 <sorear> ndm: While designing ayhi I mis-understood the design of yhi; as such I seem forced to implement lazy bytecode loading (I don't think yhi has this.)   "Load" any program in microseconds!
20:55:32 <dons> seriously, haskell is only damaged by people thinking hugs is the canonical implementation.
20:55:49 <brad_> hi, i was reading http://blogs.nubgames.com/code/?p=22 but could not understand  the line: safeRead s = catch (readFile s) $ \_ -> return "".... can someone explain how the catch is working and what \_ is ?
20:55:49 <lambdabot> Title: Nub Games » Haskell IO for Imperative Programmers
20:56:07 <ndm> dons: but not at compile time, which is what i want
20:56:18 <dons> brad, any IO errors is caught and passed to an anonymous function which discards the io error, and returns the empty string
20:56:22 <ndm> sorear: lazy as in only load the bytecodes once they are required?
20:56:30 <sorear> ndm: yeah
20:56:36 <dons> ndm, on the nop program, startup is 0.3s for hugs, 0.5s for ghci. so i'm sceptical
20:56:36 <brad_> dons - so \_ is a lambda with the "default" arg?
20:56:37 <ndm> sorear: isn't that slower, checking every function call?
20:56:46 <dons> brad_, yeah, it just ignores its arg
20:56:51 <brad_> ahhhh
20:56:57 <ndm> dons: thats nop, try loading Yhc's Main
20:57:02 <TomMD> hence the _
20:57:25 <sorear> ndm: nah.  once it is loaded, it is overwritten by a direct pointer.  just like graphreduction laziness.
20:57:41 <ndm> sorear: ah, neat :)
20:57:54 * ndm forgets the assembly code tricks
20:58:10 <dons> the only thing going for hugs is quicker loading time of a fresh tree. the code runs slower, less code runs, you can't bind at the prompt, the FP implementation is inaccurate, and its slower.
20:58:25 <ndm> and it has winhugs
20:58:26 <dons> and once you've compiled your project once in ghc, it reloads faster anyway
20:58:41 <brad_> is there a haskell equivalent to perl's "die"?
20:58:42 <dons> ndm, a yhc-hugs interface could steal the hugs market
20:58:43 <ndm> ghc is horribly slow for me, hugs is much faster
20:58:45 <sorear> error
20:58:48 <dons> brad_, error ""
20:58:51 <brad_> thanks!
20:58:58 <ndm> dons: i know, but we have no reliability
20:59:35 <dons> so, given that hugs is the worst performing bytecode interpreter, i can't recommend it anymore.
20:59:48 <dons> most likely any real code the person writes just isn't going to run.
20:59:51 <ndm> i still use it every day
20:59:58 <ndm> my phd was developed in hugs
20:59:59 <dons> i know. but you're a very special case, ndm.
21:00:00 <ndm> Hoogle is
21:00:01 <brad_> by the way, this page http://haskell.org/haskellwiki/Blog_articles rocks!
21:00:02 <lambdabot> Title: Blog articles - HaskellWiki
21:00:03 <ndm> i know ;)
21:00:14 <dons> you don't use any technology developed since 1998.
21:00:21 <sorear> brad_: "dons" ++ "++"
21:00:33 <ndm> WinHugs was written only 1.5 years ago
21:01:00 <brad_> agreed sorear!
21:01:04 <sorear> ndm: how do you install a Cabal package for yhc?
21:01:18 <ndm> i am getting a new computer this month, that may change my perspective on compilation time :)
21:01:22 <ndm> sorear: you don't, sadly
21:01:25 <sorear> ndm: your build system post says to use cabal...
21:01:40 <ndm> sorear: use cabal to install packages such as filepath for ghc when build yhc
21:01:49 <sorear> ah right.
21:01:53 <sorear> makes sense :)
21:01:55 <ndm> currently we dump them in a near by directory and -i them in
21:02:02 <dons> i give up,
21:02:02 <dons> serenity$ yhi Main.hbc 13
21:02:03 <dons> zsh: segmentation fault  yhi Main.hbc 13
21:02:12 <dons> no benchmarks against old yhc.
21:02:19 <ndm> also makes it much easier to add extra dependancies on Binary etc
21:02:25 <ndm> dons: ah well, tom will get it, hopefully
21:02:34 <ndm> anyway, me sleep, its 5am!
21:02:53 <sorear> ndm: how hard will it be to support wierd build systems?  I have a *very* tricky plan in mind for loaduping ayhi...
21:03:07 <ndm> how do you mean?
21:03:21 <ndm> sorear: what is a weird build system?
21:03:26 <sorear> runghc, -D, unsafePerformIO, generating assembly code, running a compiled program...
21:04:13 <ndm> sorear: should be easy in the haskell build system, just a sequence of system calls
21:04:31 <dons> yeah.
21:04:37 <dons> like the nobench benchmarking proram
21:04:46 <dons> should be easier to maintain and hack on, hopefully
21:04:54 <ndm> yes, i hope so
21:04:58 <sorear> ["use the Ayhi module loader to load all the Ayhi modules, using a fake Ayhi.Primitive module that emits assembly code", "%include the output into ayhi.asm", "assemble ayhi", "run ayhi Redump.hbc"]
21:05:02 <ndm> have designed with future hacking in mind
21:05:24 <ndm> trivial
21:05:46 <ndm> i've also designed in support for additional dependancies
21:06:05 <ndm> i.e. you can depend on nasm and whatever else you like, without people compiling Yhc normally getting hit by it
21:06:08 <sorear> (<ndm> also makes it much easier to add extra dependancies on Binary etc) :)
21:06:22 <nornagon> @index system
21:06:23 <lambdabot> System.Cmd
21:06:35 <ndm> Binary is something we really want
21:06:51 <ndm> Yhc.Core has a crap version which is slow
21:07:04 <ndm> -> sleep
21:11:24 <fantasma> is there a function in prelude which removes repeat elements from a list?
21:11:42 <sorear> nub
21:11:44 <sorear> er, no
21:11:46 <chessguy> ?hoogle [a] -> [a]
21:11:46 <lambdabot> Prelude.cycle :: [a] -> [a]
21:11:47 <lambdabot> Prelude.init :: [a] -> [a]
21:11:47 <lambdabot> Prelude.reverse :: [a] -> [a]
21:11:53 <sorear> Data.List has nub however
21:11:56 <dons> > nub [1,2,1,2,111,2,1,1,1]
21:11:57 <lambdabot>  [1,2,111]
21:11:59 <chessguy> ?hoogle nub
21:11:59 <lambdabot> List.nub :: Eq a => [a] -> [a]
21:12:00 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
21:12:24 <chessguy> why didn't hoogle find nub on my search?
21:12:27 <chessguy> my first one
21:12:35 <chessguy> hoogle--
21:13:27 <ddarius> @hoogle Eq a => [a] -> [a]
21:13:27 <mauke> chessguy: because lambdabot's output is limited to three lines
21:13:27 <lambdabot> List.nub :: Eq a => [a] -> [a]
21:13:28 <lambdabot> List.delete :: Eq a => a -> [a] -> [a]
21:13:28 <lambdabot> List.(\\) :: Eq a => [a] -> [a] -> [a]
21:13:46 <chessguy> ah
21:13:52 <chessguy> ?hoogle [a] -> [a]
21:13:53 <lambdabot> Prelude.cycle :: [a] -> [a]
21:13:53 <lambdabot> Prelude.init :: [a] -> [a]
21:13:53 <lambdabot> Prelude.reverse :: [a] -> [a]
21:13:54 <chessguy> ?hoogle+
21:13:54 <lambdabot> Prelude.tail :: [a] -> [a]
21:13:55 <lambdabot> List.intersperse :: a -> [a] -> [a]
21:13:55 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
21:13:57 <chessguy> ?hoogle+
21:13:57 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
21:13:59 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
21:14:01 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
21:14:02 <chessguy> ?hoogle+
21:14:03 <lambdabot> Prelude.scanr1 :: (a -> a -> a) -> [a] -> [a]
21:14:05 <lambdabot> Prelude.take :: Int -> [a] -> [a]
21:14:07 <lambdabot> List.nub :: Eq a => [a] -> [a]
21:14:11 <chessguy> there it is!
21:14:13 <ddarius> That Unifying Events and Threads paper was better than my initial impression implied.
21:14:14 <chessguy> woohoo!
21:16:12 <sorear> hoogle++ restore proper bracketing
21:16:25 <sorear> @karma+ hoogle -0.5
21:16:25 <lambdabot> hoogle's karma raised to 4.
21:17:04 * sorear now must implement FFI in ayhi.  this "Hello, World" thing is a lot of work :)
21:17:18 <dons> you use the ffi to do helloworld??
21:17:22 <ddarius> sorear: That should be fairly straightforward.
21:17:40 <sorear> dons: indirectly
21:17:44 <dons> oh?
21:17:56 <dons> oh, yhc compiles to code that uses some ffi stuff on startup ?
21:18:04 <sorear> dons: yhc-base-1.0:Prelude.putStr calls into the libc
21:18:26 <dons> ok
21:18:31 <sorear> implementing nop would be a lot easier :)
21:18:51 <sorear> but ndm wants hello world :)
21:19:08 * ddarius considers making a NCG that does no register allocation, but it feels just so dirty.
21:19:18 * ddarius couldn't do it before.
21:20:08 * sorear is going to write an NCG that does no register allocation. the design of the yhc bytecodes makes statically knowing the stack depth impossible until very late in the optimization process. UNPACK--
21:22:26 <ddarius> I may be able to bring myself to it.  Just to get something to play with.
21:23:12 <ddarius> At least I should be able to dodge the opcode selection part.
21:23:35 <dons> oh, huh, the TIOBE index of langs is based on hits for the phrase:  <language> programming
21:23:49 <dons> which might go somewhere towards explaining the 15 place jump in haskell in the last month
21:24:24 <sorear> my JIT-scheme optimizer will be able to optimize an accumulating-parm fac to heaplessness, but only after seeing it called often enough to notice it takes Ints --> can see stack depth
21:24:41 <dons> so everyone should add '.... Haskell programming' to their blog articles, please :-)
21:24:58 <ddarius> sorear: Have you read the Self implementation papers?
21:26:56 <sorear> ddarius: no
21:27:10 * sorear @google "Self implementation papers"
21:27:12 <ddarius> You may want to bump it in your list to "now".
21:28:32 <sorear> ddarius: how many are there?  ie if I read google #1, will that be enough?
21:28:35 <ddarius> @where+ self http://research.sun.com/self/papers/papers.html
21:28:36 <lambdabot> Done.
21:28:53 <sorear> (and I'm still struggling with the bytecode interpreter ftr)
21:29:14 <sorear> http://research.sun.com/self/papers/third-generation.html <-- google found
21:29:15 <lambdabot> Title: Self paper: "Third-Generation Self Implementation"
21:30:30 <ddarius> http://research.sun.com/self/papers/craig-thesis.html this captures a decent chunk, but also later http://research.sun.com/self/papers/type-feedback.html
21:30:31 <lambdabot> Title: Self paper: "Craig Chambers' PhD thesis"
21:31:41 <ddarius> The other stuff (e.g. UI and prototype OO stuff) is also really cool.
21:32:12 <ddarius> I don't remember if I gave Mango enough time, but it didn't grab me as being interesting.
21:33:10 * sorear afk to read it
22:01:17 <sorear> wow, I'm amazed at how similar my design is the theirs
22:02:12 <sorear> the only material difference is that they recompile functions by adding counter update insns to the prologue while my design recompiles the currently executing function at each timer interrupt
22:06:25 <ddarius> Craig Chamber's thesis is jam-packed with things that are obvious once you see them, but you'd never think of.
22:06:47 <ddarius> Well, nowadays you might since the ideas are a bit more widespread.
22:07:47 <ddarius> But I've always wondered how much better their Iterative Type Analysis would do in a typeful environment.
22:21:49 <sorear> I also seem to have something of a knack for reinventing things :)
22:22:58 <sorear> but really ... wow.  customization is my lazy multisuperspecialization.  Data flow analysis? CaTCH-style forward type analysis.  etc etc.
22:23:46 <Zeroth404> Hugs.Base> let fac n = if n == 0 then 1 else n * fac (n-1)
22:23:46 <Zeroth404> ERROR - Syntax error in expression (unexpected end of input)
22:23:48 <Zeroth404> say what?
22:24:31 <sorear> don't use hugs
22:24:41 <sorear> or if you must, append "in fac 10"
22:25:06 <sorear> hugs only evaluates expressions, not general statements like ghci does
22:25:34 <Zeroth404> I expected it to be like tclsh :-/
22:25:38 <Zeroth404> a shell
22:25:56 <sorear> fwih, hbi back in ~92 supported arbitary definitions (imports,fixities, datatypes, defaults, etc) which NO modern implementation supports
22:26:31 <glguy> @get-shapr
22:26:32 <lambdabot> shapr!!
22:26:38 <glguy> @seen Shoragan
22:26:38 <lambdabot> Shoragan is in #haskell. I don't know when Shoragan last spoke.
22:26:43 <sorear> hb[ci] was MASSIVELY ahead of its time
22:26:43 <glguy> @seen Shapr
22:26:44 <lambdabot> I saw Shapr leaving #haskell and #happs 3h 56m 56s ago, and .
22:26:48 <glguy> :(
22:27:24 <sorear> It's been 11 years since hbc was last improved, and GHC (which IS actively developed) is only now about ~20% faster
22:29:16 <sorear> 11 years ahead in compiler technology is, like, spaceships-in-the-middle-ages advanced.
22:29:48 * sorear sacrifices a goat to augustss
22:30:27 <LoganCapaldo> sorear: the stream of mental imagery you have just created will keep me entertained nigh on many years to come
22:30:31 <tessier> sorear: The last 10% takes 90% of the time.
22:31:58 * ddarius will be so happy when his fingers memorize Pachebel's Canon.
22:33:40 <dons> Zeroth404: do you have ghci installed?
22:33:59 <ddarius> Cayenne
22:34:19 <dons> Zeroth404: here's ghci:
22:34:20 <dons> $ ghci
22:34:20 <dons> Prelude> let fac n = if n == 0 then 1 else n * fac (n-1)
22:34:20 <dons> Prelude> fac 42
22:34:20 <dons> 1405006117752879898543142606244511569936384000000000
22:34:40 <dons> while in hugs you can't bind statements, so you must write:
22:34:40 <dons> Hugs.Base> let fac n = if n == 0 then 1 else n * fac (n-1) in fac 42
22:34:41 <dons> 1405006117752879898543142606244511569936384000000000
22:34:59 * sorear doubts it was as fast as dons pasted :)
22:35:12 <dino-> sorear: Might just be on his box.
22:35:27 <sorear> dino-: nah, that's a sequential fac.
22:35:28 <dons> Zeroth404: you can also put the following in a src file:
22:35:29 <dons> main = print (fac 42)
22:35:30 <dons> fac n = if n == 0 then 1 else n * fac (n-1)
22:35:48 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..100000]
22:35:51 <LoganCapaldo> yes., fac is definitely paralleziable :)
22:35:51 <lambdabot>  2824229407960347874293421578024535518477494926091224850578918086542977950901...
22:36:00 <dons> Zeroth404: then compile it:
22:36:00 <dons> $ ghc -O A.hs
22:36:01 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in foldr (*) 1 [1..100000]
22:36:05 <lambdabot> Terminated
22:36:11 <dons> and run it like a normal program,
22:36:11 <dons> $ ./a.out
22:36:12 <dons> 1405006117752879898543142606244511569936384000000000
22:36:19 <sorear> as you can see, the parallel fold runs MUCH faster
22:36:46 <dons> sorear: cute!
22:37:12 <sorear> I suppose it's mostly Schoernhage/Strassen at work, since lambdabot is on a uniprocessor :)
22:37:16 <dons> yeah
22:37:56 <sorear> but once amdbot is online for good ... those factorials will be computed
22:38:54 * LoganCapaldo likes 16bot better as a name
22:39:05 * LoganCapaldo imagines it speaking with an echo
22:39:13 <LoganCapaldo> like creepy demon voices in a movie
22:39:18 <LoganCapaldo> "We are legion"
22:39:26 * sorear wonders if pfac would make a good slap-in-the-face benchmark for implementations w/o a threaded rts
22:39:53 <dons> we use the machine for benchmarking though , so additional random load generated by the bot is undersirable
22:40:03 <dons> however, hmm, i have a legacy 4 way machine
22:40:21 <sorear> ulimit? affinity?
22:40:45 <dons> we need all processors, all the time :-)
22:40:51 <dons> ?version
22:40:52 <amd64bot> lambdabot 4p512, GHC 6.6 (Linux x86_64 870)
22:40:52 <lambdabot> lambdabot 4p509, GHC 6.6 (OpenBSD i386)
22:40:52 <amd64bot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:40:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:40:53 <amd64bot> Title: Index of /~dons/lambdabot
22:40:53 <lambdabot> Title: Index of /~dons/code/lambdabot
22:41:13 <LoganCapaldo> erm
22:41:15 <sorear> > bitSize (0::Word)
22:41:16 <amd64bot>  64
22:41:17 <lambdabot>  32
22:41:29 <dons> but i don't have a spare 64 bit machine.
22:41:29 <LoganCapaldo> why do they disagree about their origin?
22:41:30 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..150000]
22:41:33 <amd64bot>  3189397646307349544087431388655648440056804700867084799462205746849149053068...
22:41:34 <lambdabot>  3189397646307349544087431388655648440056804700867084799462205746849149053068...
22:41:40 <dons> ah, the race is on!
22:41:41 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..200000]
22:41:44 <amd64bot>  1420225345470314404966946333682305976089965356746401622696224744629226778516...
22:41:45 <lambdabot> Terminated
22:41:53 <LoganCapaldo> I think we got a winner
22:42:00 <dons> sorear: though i couldn't get +RTS -N16 working for some unknown reason.
22:42:07 <dons> so you're using the threaded runtime on a single core
22:42:19 * dons tries again
22:42:39 <dons> ooh .ok. maybe it does work now.
22:42:56 <dons> ok. hmm. -N16 on its way...
22:43:03 <sorear> > 2+2
22:43:04 <dons> go nuts!
22:43:05 <amd64bot>  4
22:43:05 <lambdabot>  4
22:43:08 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..200000]
22:43:11 <amd64bot>  1420225345470314404966946333682305976089965356746401622696224744629226778516...
22:43:12 <lambdabot> Terminated
22:43:21 * dons peeks at the load level
22:43:24 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..200000]
22:43:28 <amd64bot>  1420225345470314404966946333682305976089965356746401622696224744629226778516...
22:43:28 <lambdabot> Terminated
22:43:31 <LoganCapaldo> > "AMD64bot is the fasterest"
22:43:33 <lambdabot>  "AMD64bot is the fasterest"
22:43:33 <amd64bot>  "AMD64bot is the fasterest"
22:43:37 <LoganCapaldo> oooo!
22:43:37 <nornagon> heh
22:43:38 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..220000]
22:43:42 <lambdabot> Terminated
22:43:42 <amd64bot> Terminated
22:43:50 <dons> ah, hmm, but runplugs isn't using multiple cores...
22:43:54 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..220000]
22:43:56 <dons> nor is it compiled -threaded
22:43:57 <LoganCapaldo> > haltp haltp
22:43:58 <lambdabot>   Not in scope: `haltp'
22:43:58 <amd64bot>   Not in scope: `haltp'
22:43:58 <amd64bot> Terminated
22:43:58 <lambdabot> Terminated
22:44:07 <sorear> that would do it :)
22:44:16 <LoganCapaldo> amd64bot is so fast, it dies quicker ;)
22:44:34 <sorear> @quote stere
22:44:34 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
22:44:46 <dons> why do the good always die so young?
22:45:02 * dons hacks in -N16 supprot
22:45:42 <dons> megabot from the future will be with you shortly
22:45:49 <glguy> is par like a seq that runs in parallel?
22:45:56 <dons> yeah
22:46:01 <dons> its a paralellism hint
22:46:07 <ddarius> "A candle that burns twice as bright, lasts half as long."
22:46:14 <nornagon> i want a futurebot
22:46:30 <bos> wow, i remember `par` from 1994.
22:46:33 <nornagon> it gives the answers to your commands *before* you press enter
22:46:40 <dons> bos, we can actually do something with it now :-)
22:46:41 <glguy> do you still have to enter them then?
22:46:56 <glguy> if you don't, are the responses retracted?
22:46:57 <bos> i also remember much nofib benchmark joshing with augustss.
22:46:58 <nornagon> glguy: well if you never press enter, there's never a time before you press enter
22:47:07 <dons> bos, hehe. scary
22:47:19 <bos> yeah, hbc regularly creamed ghc back then.
22:47:22 <dons> simonM also mentioned that its been a while since they've raced hbc on the nobench
22:47:50 <dons> http://www.cse.unsw.edu.au/~dons/nobench/i686/results.html
22:47:50 <lambdabot> Title: nobench: Haskell implementation shootout
22:47:55 <sorear> * sorear sacrifices a goat to augustss [22:26]
22:47:58 <dons> so its about 50% down now, after 10 years of work.
22:48:31 <dons> still takes out a few nice results though
22:49:45 <bos> the friendly competation is valuable when it's available.
22:49:52 <bos> er, competition.
22:49:53 <dons> bos, it must be nice to come back to haskell after a decade, and find things like `par` actually working
22:50:05 <dons> yeah, very much so. just putting up that stats page has been a boost
22:50:33 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z ls | null (drop 20 ls) = foldr f z ls ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..220000] -- optimization - only run lists longer than 20 in par
22:50:37 <amd64bot>  1879592091636828805388675328511933834876326529555724367630941008123597868952...
22:50:37 <lambdabot> Terminated
22:50:43 <bos> dons: it's also nice to come back and (a) find a thriving community and (b) finally be able to write productive code :-)
22:51:02 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z ls | null (drop 20 ls) = foldr f z ls ; pfold f z l = (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..220000] -- without pars
22:51:06 <amd64bot>  1879592091636828805388675328511933834876326529555724367630941008123597868952...
22:51:06 <lambdabot> Terminated
22:51:13 <bos> the old CPS style of IO was just too horrible to be worth dealing with.
22:51:23 <dons> sorear: can you try a good `par` versoin?
22:51:24 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z ls | null (drop 20 ls) = foldr f z ls ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..300000] -- optimization - only run lists longer than 20 in par
22:51:28 <amd64bot> Terminated
22:51:28 <lambdabot> Terminated
22:51:35 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z ls | null (drop 20 ls) = foldr f z ls ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..280000] -- optimization - only run lists longer than 20 in par
22:51:39 <amd64bot> Terminated
22:51:40 <lambdabot> Terminated
22:51:43 <LoganCapaldo> too `par`allel
22:51:47 <LoganCapaldo> hehehe
22:51:49 <dons> hmm. i saw 3 cores there briefly in use
22:51:49 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z ls | null (drop 20 ls) = foldr f z ls ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..250000] -- optimization - only run lists longer than 20 in par
22:51:53 <amd64bot> Terminated
22:51:53 <lambdabot> Terminated
22:52:02 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z ls | null (drop 20 ls) = foldr f z ls ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..240000] -- optimization - only run lists longer than 20 in par
22:52:05 <amd64bot>  1292854676925617813955705819854524735725862184281285069531467897910421339014...
22:52:05 <lambdabot> Terminated
22:52:16 <dons> most work seems to get done on one core though.
22:52:21 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z ls | null (drop 30 ls) = foldr f z ls ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..250000] -- optimization - only run lists longer than 30
22:52:25 <amd64bot>  3018229640147039469602050834561832793312184801682231281496486515591546051432...
22:52:26 <lambdabot> Terminated
22:52:42 <LoganCapaldo> darn lazy cores
22:52:46 <dons> yeah, there's a brief flash of 4 cpus in use, then 1 finishes (i guess the main thread prints out the result)
22:52:46 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z ls | null (drop 40 ls) = foldr f z ls ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in pfold (*) 1 [1..250000] -- optimization - only run lists longer than 40
22:52:50 <amd64bot>  3018229640147039469602050834561832793312184801682231281496486515591546051432...
22:52:51 <lambdabot> Terminated
22:52:59 <dons> need :stats
22:54:07 <dons> clearly lambdabot is built with technology so secret even the aliens don't know about it
22:55:00 <sorear> pfac is gonna change the world. GMP bound *and* embarrasingly parallel.
22:55:15 <dons> :)
22:55:24 <sorear> who doesn't like calculating million digit numbers :)
22:55:31 <dons> not me!
22:55:44 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z ls | null (drop 40 ls) = foldr f z ls ; pfold f z l = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in length (show (pfold (*) 1 [1..250000]))
22:55:48 <lambdabot> Terminated
22:56:12 <dons> why reddit is nice "If I had to work on code with performance requirements, Haskell would be my choice (followed by C++). Haskell has functional goodness with the ability to break into imperative mode, and C++ gives me direct memory management with a few functional pieces."
22:57:23 <LoganCapaldo> You know what that means
22:57:26 <sorear> > let { shred [] = ([],[]) ; shred (x:xs) = (x:b,a) where { (a,b) = shred xs } ; pfold f z [] = z ; pfold f z [x] = x ; pfold f z l | null (drop 40 l) = f pa pb | True = pa `par` pb `par` (f pa pb) where { (a,b) = shred l ; pa = pfold f z a; pb = pfold f z b } } in length (show (pfold (*) 1 [1..250000]))
22:57:30 <lambdabot> Terminated
22:57:39 <sorear> oh, duh
22:57:47 <sorear> no wonder it keeps failing
22:57:52 <sorear> lambdabot's back
22:57:56 <dons> :-)
22:58:24 <LoganCapaldo> Haskell++ is the ultimate programming language, combining all the expressiveness of C++ with the awesome bit twiddling power of Haskell ;)
22:58:26 <dons> sorry! if the channel wants to cough up funding for a dedicated multicore box ..
22:58:34 <dons> > 23000 / 320
22:58:36 <lambdabot>  71.875
22:58:40 <dons> 71AU each
22:58:45 <dons> for 16 amd64 cores.
22:58:50 <dons> we only need 4 cores though, maybe 8.
22:59:11 <sorear> > 23000 / 16
22:59:13 <lambdabot>  1437.5
22:59:20 <dons> so i suppose, $10 to /join the channel, and you get dedicated hardware with 60s timeouts :-)
22:59:23 <sieni> LoganCapaldo: Does that look like something like that: http://www.hurmio.org/~ville/template.html
22:59:43 <dons> or, $1 a month for 10 months, per nick
22:59:51 <sorear> wha? 1.4K for a single processor?  wow those are some expensive interconnects
22:59:52 <dons> that's less than a cup of coffee!
23:00:27 <dons> its a pretty elaborate machine
23:00:33 <LoganCapaldo> sieni, you have exceeded my wildest expectations
23:00:42 <dons> why reddit is nice: ""Several people have asked for Darcs repositories of my software. These do exists now:
23:00:46 <dons> http://common-lisp.net/~loliveira/ediware/"
23:00:47 <lambdabot> Title: Ediware
23:00:47 <sieni> LoganCapaldo: that's from actual source code
23:00:51 <sorear> 1240915 <-- the result on my machine, after 20s
23:00:51 <dons> we're winning! ;)
23:01:07 <bos> the 16-core machines are nice, but boy do they not scale well.
23:01:17 <sorear> so amd64bot can compute 7x faster than sorear-lambdabot
23:01:28 <sorear> (I assume ghci v. ghc -O2 doesn't matter)
23:01:42 <dons> bos, yeah, we're having some kernel issues with scheduling at the moment.
23:01:57 <dons> though there's some very nice scaling for data parallel arrays so far (that's the point of them though)
23:02:01 <sorear> bos: we just need to upgrade to GdH! :)
23:02:05 <sorear> and upgrade GdH
23:02:35 <sieni> LoganCapaldo: Look at e.g. http://www-static.cc.gatech.edu/~yannis/fc++/FC++-clients.1.5/monad.cc
23:02:37 <lambdabot> http://tinyurl.com/2bygy9
23:02:45 * sorear ponders data parallel bytestrings
23:02:49 <bos> heh. i think gdh was not all that hot.
23:03:02 * sorear smells a doctoral dissertation :(
23:03:57 * LoganCapaldo thinks he saw a list comprehension in theere
23:04:09 * LoganCapaldo but decides to pretend like he didn't
23:04:37 <bos> dons: i take it you're just using `par` within a single address space, and not trying to do the same stuff that GpH did?
23:05:33 <sorear> we are using (the successor to) GpH
23:05:38 <sorear> GpH == single address space
23:05:43 <sorear> GdH == several
23:05:44 <sorear> IIRC
23:06:40 <bos> gph used to have a layer that sat on top of PVM.
23:08:22 <dons> bos, right, "The expression (x `par` y)  sparks the evaluation of x  (to weak head normal form) and returns y. Sparks are queued for execution in FIFO order, but are not executed immediately. If the runtime detects that there is an idle CPU, then it may convert a spark into a real thread, and run the new thread on the idle CPU. I"
23:08:54 <bos> i remember sparks :-)
23:09:13 <dons> so it was all in place, we just didn't have commodity hardware to support this stuff
23:09:25 <bos> yeah
23:09:27 <dons> now every man and his dog has a dual core laptop ;)
23:09:59 <LoganCapaldo> wooo
23:10:01 <bd_> alas, for my dual core laptop nearly catches on fire every time I push it to full load
23:10:02 <bos> it's true. i have one myself.
23:10:09 * LoganCapaldo has a dual core laptop also
23:10:25 <bd_> or at least it feels that way, maybe it's completely within the hw specs' temperature limits, but it's not very comfortable :)
23:10:31 <LoganCapaldo> I don't have a dog, but I'm pretty sure my mom's cat laptop has 2 cores ;)
23:11:52 <LoganCapaldo> anyone install ghc 6.6 from the binary package for Mac OS X on PPC?
23:12:00 <sorear> I have a 1 core PC
23:12:24 <sorear> ... and still jhc regularly pushes it over the factory presets for the temp alarm
23:12:40 <LoganCapaldo> its making disconcerting noises
23:13:28 <LoganCapaldo> victory: Glasgow Haskell Compiler, Version 6.6, for Haskell 98, compiled by GHC version 6.6
23:14:33 <sorear> I prefer 6.7.20070223
23:14:58 <LoganCapaldo> Send me a binary package and I'll do it :)
23:15:05 * LoganCapaldo is lazy
23:15:13 <LoganCapaldo> plus this is a vast improvement
23:15:21 <dons> sorear: i like 0301 better
23:15:26 <LoganCapaldo> I _was_ using 6.4.1
23:15:26 <dons> nsieve runs faster :-)
23:17:10 * sorear goes back to writing a generic (asm!) ffi stub generator
23:28:21 <bos> woo! http://www.pragmaticprogrammer.com/titles/jaerlang/
23:28:23 <lambdabot> Title: Programming Erlang
23:32:36 <LoganCapaldo> uh oh
23:38:00 * kolmodin fires away a pile of patches to binary
23:45:20 * dons wants some of Oleg's web app server warez
