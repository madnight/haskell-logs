00:01:03 <kolmodin> morning!
00:08:35 <dons> sjanssen: hmm, ~5% faster? hard to say yet.
00:08:40 <dons> we're ironing out performance issues atm.
00:10:31 <kolmodin> why does the dwm guy keep changing the keymapping? I don't like the new one
00:10:45 <dons> kolmodin: xmonad!
00:10:49 <dons> we have tiling.
00:10:52 <kolmodin> luckely I can change them by recompiling everything
00:10:52 <dons> we have QuickChecks!
00:10:55 <dons> we have Xinerama!
00:10:56 <kolmodin> oh, you do! cool!
00:11:00 <kolmodin> how did this happen? :)
00:11:06 <dons> the magic of darcs
00:11:14 <kolmodin> aye, I see
00:11:35 <kolmodin> ?where trunk
00:11:35 <lambdabot> I know nothing about trunk.
00:11:41 <kolmodin> what was it called?
00:11:50 <sjanssen> @where xmonad
00:11:51 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
00:11:51 <kolmodin> thunk
00:12:00 <sjanssen> @where thunk
00:12:01 <lambdabot> thunk is now known as xmonad
00:12:08 <kolmodin> ah, cool
00:12:25 <kolmodin> the new keybindings are driving me crazy
00:12:48 <kolmodin> lines of code?
00:13:01 <dons> 400, iirc.
00:13:01 <sjanssen> kolmodin: you should really try it out, we have most everything that a typical dwm user needs
00:13:09 <kolmodin> sjanssen: I'm impressed
00:13:13 <sjanssen> exactly 400
00:13:19 <kolmodin> haha! cool!
00:13:33 <kolmodin> so less than 1/4 of dwm then
00:13:54 <dons> right.
00:14:05 <sjanssen> right.  But it isn't quite a 1 to 1 comparison
00:14:10 <dons> about 25% of dwm, the least bloated window manager out there ;-)
00:14:11 <kolmodin> aye, but still
00:14:14 <dons> yeah, we support xinerama!
00:14:23 <sjanssen> dwm has a statusbar, but we don't
00:14:29 <dons> yeah.
00:14:30 <kolmodin> xinerama is for several screens?
00:14:33 <sjanssen> yes, on the flip side we have xinerama support
00:14:55 <sjanssen> kolmodin: yeah.  jcreigh runs xmonad on three monitors
00:15:09 <ClaudiusMaximus> does xmonad work with ghc-6.4.2?
00:15:25 <sjanssen> ClaudiusMaximus: yes.  (and if it doesn't let me know)
00:15:36 <ClaudiusMaximus> sjanssen: ok
00:15:45 <sjanssen> you'll need to grab a couple libraries, but that shouldn't take more than 10 minutes
00:16:47 <kolmodin> I'll make an ebuild for it when I get back from work
00:16:54 <kolmodin> does it run in ghc 6.4.2 too?
00:17:25 <sjanssen> kolmodin: yes
00:17:29 <kolmodin> nice
00:17:38 <sjanssen> all the deps in the cabal files should be accurate
00:17:41 <ClaudiusMaximus> kolmodin: ebuild would make my day :)
00:17:46 <kolmodin> :D
00:18:22 * ClaudiusMaximus never used darcs, installing it now...
00:18:58 <kolmodin> ClaudiusMaximus: darcs is easy, you'll pick it up in no time
00:20:10 <kolmodin> sjanssen: you might want to check that there isn't already a wm running
00:21:35 <sjanssen> kolmodin: yeah, probably should :)
00:21:56 <kolmodin> sjanssen, dons: thanks for xmonad, I'll get it installed when I'm back from work!
00:23:07 <Stinger> > do { a <- (+3) ; b <- (*2) ; (a,b) } $ 3
00:23:08 <lambdabot>  Couldn't match expected type `a -> b'
00:23:13 <Stinger> > do { a <- (+3) ; b <- (*2) ; return (a,b) } $ 3
00:23:14 <lambdabot>  (6,6)
00:24:32 <Stinger> @type do { a <- (+3) ; b <- (*2) ; return (a,b) }
00:24:34 <lambdabot> forall a. (Num a) => a -> (a, a)
00:25:07 <Stinger> alright, whats that monad called; (->) yeah? What do I need to import to use that
00:25:38 <ClaudiusMaximus> Control.Monad.Reader provides Monad ((->) r)
00:25:59 <ClaudiusMaximus> @docs Control.Monad.Reader
00:25:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
00:26:02 <Stinger> reader hmmm, not what I would've expected :)
00:26:13 <ClaudiusMaximus> nor me - it stumped me for days
00:27:25 <rahikkala> I thought it was Control.Monad.Instances in ghc 6.6
00:33:14 <dons> strictness properties are tricky!
00:33:41 <dons> mm. you could write some really obfuscated haskell that depended upon precise arguments being lazy in standard functions
00:34:17 <sjanssen> bonus points for distinct behavior across implementations
00:38:14 <kolmodin> sjanssen: does xmonad has floating?
00:39:08 <sjanssen> kolmodin: nope
00:39:17 <kolmodin> :(
00:39:24 <kolmodin> can you use mplayer in full screen?
00:39:44 <kolmodin> so gimp is close to impossible to use then
00:40:23 <sjanssen> kolmodin: mplayer works fine with "Full" layout mode
00:40:40 <kolmodin> and audacious and all other apps not quite following ICCM (or whatever it's called) won't be able to float then
00:41:26 <kolmodin> ok, seems I have totry it
00:41:27 <kolmodin> anyway
00:41:31 * kolmodin is off to work
00:41:55 <sjanssen> we (or you!) will write a float mode eventually
00:42:09 <dons> mplayer -fs foo.mp3
00:49:01 <Korollary> dons: Do you have any haskell parallelization benchmark-y numbers? This guy may like seeing them: http://scienceblogs.com/goodmath/2007/03/an_experiment_with_calculus_an_1.php
00:49:03 <lambdabot> Title: Good Math, Bad Math : An Experiment with &pi;-calculus and Programming Language  ..., http://tinyurl.com/2xwsnf
00:51:42 <dons> the ndp benchmarks came out just the other day
00:52:07 <dons> excellent scaling up to 40 cores for array programs
00:52:16 <Korollary> Is it lazy code?
00:52:19 <twb> In the hypothetical situation where I was foolish enough to try translate a unix script to Haskell (just for kicks), how would I access the chroot(2) system call?
00:52:24 <dons> Korollary: yeah.
00:52:32 <dons> twb, ffi binding
00:52:44 <dons>      int
00:52:45 <twb> That's what I figured.
00:52:45 <dons>      chroot(const char *dirname);
00:52:58 <Korollary> dons: He seems to be under the impression that laziness somehow doesnt work with parallelization.
00:53:09 <dons> foreign import ccall unsafe "unistd.h chroot" c_chroot :: CString -> IO CInt
00:53:23 <dons> Korollary: hmm? that's what Control.Parallel.Strategies is for
00:53:30 <dons> precise control of `par` evaluation.
00:53:36 <dons> maybe point him to that.
00:53:55 <astrolabe> he's quite well known I think, in the sense that a lot of people see his blog
00:54:13 <dons> yes.
00:54:25 <dons> doesn't mean he knows much about parallel haskell though ;-)
00:54:40 <dons> there's a lot of armchair language theorists out there :-)
00:54:55 <astrolabe> You mean the fact that someone blogs about something doesn't mean they're an expert ?!?!
00:54:57 <Korollary> Yeah I didn't have any links handy, so I couldn't post a reply at the time.
00:54:59 * twb puts hand up
00:55:06 <twb> I'm an armchair linguist!
00:55:06 <dons> astrolabe: i know its hard to believe.
00:55:14 <twb> And I'm *always* right!
00:57:29 <Korollary> I am right at any given time in at least one parallel universe.
00:58:30 <desp> hum
00:58:34 <vincenz> Korollary: that's just a corollary
00:58:47 <astrolabe> You claim that in this universe, but how do we know this is the right one?
00:59:43 <Korollary> Does it matter?
00:59:53 <astrolabe> I don't know.  I've confused myself.
01:00:18 <desp> got a problem with compiling a FFI thing
01:00:18 <Korollary> In another universe, you and I are in deep agreement.
01:00:24 <desp> /usr/bin/ld: multiple definitions of symbol _Curl_czueasyGet_closure
01:00:25 <desp> etc
01:03:00 <xpika> whats the easiest way to write to a file in binary
01:03:13 <desp> ah, never mind. the instructions must be obsolete in the FFI Introduction
01:03:22 <xpika> im trying to emulate UTF
01:03:24 <mauke> writeFile and a OS that doesn't distinguish between text and binary
01:04:07 <sjanssen> @hoogle openbinary
01:04:07 <lambdabot> System.IO.openBinaryFile :: FilePath -> IOMode -> IO Handle
01:04:08 <lambdabot> System.IO.openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
01:04:35 <xpika> mauke: thats difficult as writefile takes strings of 7 bit characters and i need to encode 8
01:04:46 <sjanssen> xpika: ^^^
01:04:54 <sjanssen> xpika: what's your operating system?
01:04:55 <xpika> yes
01:04:59 <xpika> fedora
01:05:11 <vincenz> is fail == throwError in the MonadError?
01:05:53 <sjanssen> xpika: writeFile currently does what you want (with GHC and Unix).  Expect this to change at some point in the future
01:05:59 <xpika> sjanssen: doesnt that just 'translate CRLF to LF,'
01:06:09 <vincenz> @hoogle maybe
01:06:09 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
01:06:09 <lambdabot> Maybe :: module
01:06:09 <lambdabot> Prelude.Maybe :: data Maybe a
01:06:14 <sjanssen> xpika: only windows does that transformation
01:06:25 <xpika> sjanssen: but isnt that all it does
01:06:39 <mauke> xpika: why 7 bit characters?!
01:06:39 <xpika> sjanssen: how do i write say 10101010
01:06:49 <xpika> mauke: ASCII
01:06:57 <mauke> writeFile isn't ASCII
01:07:05 <xpika> it takes a string doesnt it
01:07:17 <mauke> > maxBound :: Char
01:07:18 <xpika> mauke: ok ill try it
01:07:18 <lambdabot>  '\1114111'
01:07:31 <mauke> Char doesn't stop at 128
01:07:36 <xpika> ok
01:07:41 <sjanssen> xpika: Char is a unicode code point (something like 21 bits).  The current implementation of IO truncates each Char at 8 bits
01:08:01 <fuzan> I'm trying to use floor in one of my programs, and I CAN"T seem to get around "ambiguous type variable constraints between integral and realfrac"
01:08:01 <xpika> sjanssen: ok that sounds good enough
01:08:19 <mauke> > floor 2.7
01:08:20 <fuzan> I've tried all sorts of inheritence, type declarations, and I'm stumped.
01:08:20 <lambdabot>  2
01:08:30 <mauke> works for me :-)
01:08:36 <sjanssen> xpika: you should consider Data.ByteString instead of taking advantage of the current brokenness of the IO library
01:08:37 <fuzan> yes, i have no issue with ghci. it's when I load the program :'(
01:08:46 <xpika> sjanssen: will do
01:08:50 <fuzan> > floor (2.7 :: Double) -- should work
01:08:51 <lambdabot>  2
01:08:52 <mauke> fuzan: how are you using floor?
01:09:18 <fuzan> b1 = t * (floor (b/t))
01:09:31 <mauke> what are the types of b and t?
01:09:35 <fuzan> b is of same type as t
01:09:39 <fuzan> I've tried double, int, integer
01:09:40 <mauke> @type floor
01:09:42 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
01:09:45 <mauke> ah, yeah
01:10:03 <fuzan> i don't exactly understand how the numeric typeclasses work yet :)
01:10:07 <mauke> fuzan: can't you just use b1 = t * (b `div` t)?
01:10:16 <mauke> assuming b and t are integers
01:10:19 <fuzan> i think I tried that once, let me try again.
01:11:03 <fuzan> still ambigious. "Integral b arising from div", "RealFrac b arising from use of floor"
01:11:24 <sjanssen> fuzan: remove the floor
01:11:41 <mauke> fuzan: what floor?!
01:11:48 <desp> @hoogle peek
01:11:49 <lambdabot> Foreign.Storable.peek :: Storable a => Ptr a -> IO a
01:11:49 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
01:11:49 <lambdabot> Foreign.Storable.peekElemOff :: Storable a => Ptr a -> Int -> IO a
01:11:52 <sjanssen> for any given variable, you can use div XOR floor
01:11:55 <twb> dons: where is the FFI documented?  http://www.cse.unsw.edu.au/~chak/haskell/ffi/ ?
01:11:56 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
01:12:05 <dons> right.
01:12:20 <twb> Thank you.
01:12:44 <fuzan> sjanssen: why not both?
01:12:44 <desp> argh
01:12:58 <fuzan> > :t (5/2)
01:12:59 <lambdabot>  Parse error
01:13:02 <fuzan> :t (5/2)
01:13:04 <desp> would this be correct?
01:13:05 <lambdabot> forall t. (Fractional t) => t
01:13:05 <desp> int easy_get(const char* url, char** out_data, size_t* out_size);
01:13:06 <mauke> fuzan: because div takes integers but floor takes a float
01:13:10 <desp> int easy_get(const char* url, char** out_data, size_t* out_size);
01:13:11 <desp> const char* easy_err_msg(int err);
01:13:18 <sjanssen> fuzan: div only works on Integral types, but floor only works on Fractional types
01:13:21 <fuzan> that's why I was using (/)
01:13:24 <desp> foreign import ccall unsafe "easy_get" c_easyGet :: Ptr CChar -> Ptr (Ptr CChar) -> Ptr CSize -> IO CInt
01:13:27 <desp> foreign import ccall unsafe "easy_err_msg" c_easyErrMsg :: CInt -> Ptr CChar
01:13:29 <desp> pardon for the double line
01:13:53 <sjanssen> desp: looks correct to me
01:14:17 <fuzan> It say's it's a "monomorphism restriction"
01:14:44 <mauke> fuzan: ok, what are the actual types here?
01:14:50 <mauke> what are you trying to do?
01:15:22 <hpaste>  fuzan pasted "monomorphism restriction?" at http://hpaste.org/1096
01:16:39 <desp> ah, peek is also in IO
01:16:50 <hpaste>  sjanssen annotated "monomorphism restriction?" with "correct?" at http://hpaste.org/1096#a1
01:17:33 <fuzan> sjanssen: I suppose that works :)
01:17:39 <sjanssen> desp: it's gotta be.  consider \x -> peek (nullPtr `plusPtr` x)
01:18:13 <hpaste>  mauke annotated "monomorphism restriction?" with "compiles" at http://hpaste.org/1096#a2
01:18:48 <fuzan> argh, I tried a fromIntegral in the wrong spot :'(
01:19:00 <desp> sjanssen: of course
01:19:27 <fuzan> mauke: that compiled without no-monomorphic-restriction?
01:19:55 <mauke> fuzan: yes
01:23:59 <fuzan> mauke,sjanssen: ty.
01:27:46 <xpika> r
01:28:08 <xpika> ok thanks. haskell strings are 8 bit
01:29:42 <xpika> now all i need is a way to display them on the terminal
01:30:40 <sjanssen> xpika: NO THEY ARE NOT 8 BIT
01:30:43 <sjanssen> :)
01:30:48 <ClaudiusMaximus> > maxBound ::Char
01:30:49 <lambdabot>  '\1114111'
01:31:30 <mauke> that's 7 bits
01:31:34 <vincenz> This is just INSANE: http://www.youtube.com/watch?v=95L-zmIBGd4
01:31:34 <sjanssen> type String = [Char] -- Char is an abstract entity that represents a unicode code point
01:31:35 <mauke> but why is one of them 4?
01:32:34 <desp> hm.
01:32:40 <sjanssen> mauke: you better file a bug on the trac
01:32:56 <desp> how big is Int in relation to size_t?
01:33:19 <sjanssen> Int, as in the Haskell type?
01:33:19 <mauke> unspecified
01:33:43 <desp> sjanssen: yep
01:33:52 <sjanssen> desp: you shouldn't use Int when interfacing with C code
01:34:04 <desp> sjanssen: type CStringLen = (Ptr CChar, Int)
01:34:15 <desp> that's what I just ran into
01:34:45 <sjanssen> hmm.  That is a bit questionable, I think
01:34:53 <desp> indeed
01:35:04 <desp> it would appear that I'm better off letting Haskell measure the string again
01:35:13 <desp> but I wanted to avoid that
01:35:54 <desp> @hoogle alloca
01:35:54 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO b
01:35:55 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
01:35:55 <lambdabot> Foreign.Marshal.Array.allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
01:36:21 <sjanssen> desp: it should be okay to store things on the Haskell side as CStringLen, but then convert the Int to CSize before actually calling the FFI'd function
01:36:36 <desp> sjanssen: the problem is, I'm getting a CSize from FFI
01:36:47 <desp> and I intended to convert the CString, CSize pair into a ByteString
01:37:01 <sjanssen> and ByteString takes CStringLen.
01:37:10 <desp> yep
01:37:36 <sjanssen> it should be okay to convert the CSize to an Int
01:37:51 <sjanssen> just make sure that your foreign imports never mention Int in the type
01:37:57 <desp> yes, until someone tries to do a >2GB transfer :)
01:38:02 <desp> but I'll worry about that later, I guess
01:38:38 <sjanssen> ByteString can't handle that size anyway
01:40:36 <desp> hmm
01:42:52 <encryptio> > (log (fromIntegral (maxBound :: Int)))/(log 2) :: Double
01:42:53 <lambdabot>  30.999999999328196
01:43:36 <quicksilver> surely lazy bytestring can handle any size up to 2^64?
01:45:42 <desp> quicksilver: that's what the docs say...
01:46:31 <desp> quicksilver: unfortunately, I fail to see how am I supposed to build a ByteString from a CString
01:48:43 <desp> oh wait, there are some things in Base
01:51:18 <vincenz> question about MonadError
01:51:22 <vincenz> is fail == throwError?
01:53:20 <desp> hmm
01:53:24 <desp> what exactly is a Word8?
01:53:27 <desp> @hoogle Word8
01:53:27 <lambdabot> Data.Word.Word8 :: data Word8
01:55:20 <mauke> an unsigned 8-bit integer
01:55:50 <desp> so a Ptr Word8 would be functionally equivalent to a Ptr CChar?
01:58:18 <kzm> Unless CChar is signed?
02:02:21 <goltrpoat> > -1 :: CChar
02:02:22 <lambdabot>   Not in scope: type constructor or class `CChar'
02:02:25 <goltrpoat> bah.
02:02:28 <goltrpoat> (it's -1)
02:02:53 <desp> > -1 :: Foreign.C.CChar
02:02:54 <lambdabot>      Not in scope: type constructor or class `Foreign.C.CChar'
02:03:44 <goltrpoat> CUChar is unsigned char.  but, i don't think the C standard fixes the width of a char (i could be wrong)
02:04:02 <desp> goltrpoat, I do believe it's at least 8 bits
02:04:07 <goltrpoat> at least, right
02:04:08 <ClaudiusMaximus> i'm fairly sure C language specs say signed char, unsigned char, and char are all different types, and char may be signed or unsigned, and i think char >= 8bits
02:04:30 <desp> I don't think the signedness is of issue here
02:04:46 <desp> since all I want is to treat a Ptr CChar as a Ptr Word8
02:04:58 <desp> and I don't think there are any live platforms where char isn't 8 bits ;)
02:06:00 <desp> :t liftM
02:06:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:06:45 <hpaste>  desp pasted "monad trouble" at http://hpaste.org/1097
02:07:17 <desp> (peek dataPtr) returns in the IO monad...
02:07:28 <desp> should I use unsafePerformIO here or am I missing something?
02:07:59 <mauke> no, just add another line: contents <- peek whatever
02:08:05 <desp> ah.
02:08:18 <desp> thanks
02:10:26 <mux> fwiw, the C language specs indeed don't fix the width of the char type, it's supposed to be >= 8 bits, and you can check that with the CHAR_BITS macro
02:10:37 <mauke> CHAR_BIT
02:10:38 <goltrpoat> ah right
02:10:46 <mux> also, the char type is the only one whose signedness by default is implementation dependant
02:11:07 <mux> ie "char" may be unsigned or signed, unlike all the other types who are signed by default
02:11:22 <Thunder> mux: The C99 standard does no define CHAR_BIT to 8 but requires to be at least eight.
02:11:30 <mux> yes
02:11:38 <mux> that's precisely what I'm saying
02:12:45 <Thunder> If you combine the footnote on page 80 with some aspects of bitfields, you can conclude CHAR_BIT == 8, but I have a full complient C compiler for a DSP which has sizeof short = sizeof long = sizeof char, because CHAR_BIT == 32
02:13:37 <Thunder> unfortunly sizeof ist of type :: a -> Int
02:14:06 <mux> I don't know the c2hs types, but it should be CSizeT or something :-)
02:14:16 <desp> mux: CSize
02:14:23 <mux> okay
02:14:25 <desp> which brings me to another question
02:14:35 <desp> is it possible to convert CSize to Int? :)
02:14:36 * Thunder prefer Ada's 'size, 'storage_size, 'component_size attributes which return bitcounts
02:15:15 <mux> desp: well that could lead to truncation if Int is 32bits and the platform is 64bits
02:15:20 <mauke> fromIntegral?
02:15:26 <desp> mux: I know, I was talking about it earlier
02:15:31 <mux> but practically, that should never happen
02:15:33 <goltrpoat> thunder:  what's 'component_size?
02:15:35 <Thunder> desp: No. CSize can be larger than int. Usualle csize is int, but this is not required. Only ssize_t is required to fit into short.
02:15:36 <mauke> :t toEnum . fromEnum
02:15:38 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
02:15:41 <mux> unless you're dealing with so huge objects
02:15:59 <desp> mux: but apparently Haskell doesn't support larger objects anyway
02:16:00 <mux> ssize_t isn't even C, it's a POSIX hack
02:16:08 <desp> fromForeignPtr also takes an Int
02:16:13 <mux> for read() and friends
02:16:17 <desp> Thunder: ^
02:17:04 <Thunder> C is funny, you can get problems, if you compile your programms with other compiler options than the libraries or the kernel, because the struct representation differs likely.
02:17:52 <mux> only if you use non-standard compiler-specific options such as __attribute__((__packed__))
02:19:14 <Thunder> mux: No the compiler is free to reoder and align the components at will. The only portable way to generate a memory layout is to use a struct of bitfields only.
02:19:55 <mux> I'm not so sure about this
02:20:26 <mauke> bitfields don't guarantee layout
02:20:36 <mauke> reordering members is not allowed
02:20:49 <mux> yes
02:20:51 <mauke> every struct member can be followed by padding
02:20:56 <mux> bitfields suck
02:21:04 <mux> (in C)
02:21:09 <goltrpoat> if it is allowed to reorder, then that's a C-only thing that didn't survive to C++.  seems remarkably unlikely though.
02:21:34 <mauke> C++ allows reordering iff there's an intervening access specifier
02:21:39 <goltrpoat> ah yes.
02:24:50 <Thunder> Reorder is allowed in C99. It's unusual in implementations, but some embedded compilers do this.
02:25:26 <mauke> no, it isn't
02:26:19 <Thunder> mauke: bitfields in structs are required to be concatenated without any padding bit.
02:27:11 <mauke> 6.7.2.1/13
02:27:25 <Thunder> I'm pretty sure about this reorder point, because I run into this problem once. But due to missing standard documents and offtopic I do not insist in this point.
02:27:57 <mauke> Thunder: only if there's enough room for the bitfield
02:28:05 <dons> ?uptime
02:28:05 <lambdabot> uptime: 9d 5h 58m 15s, longest uptime: 9d 5h 58m 15s
02:28:07 <dons> ?users
02:28:07 <lambdabot> Maximum users seen in #haskell: 336, currently: 295 (87.8%), active: 28 (9.5%)
02:29:36 <mux> if you've ever used bitfields in code that is supposed to run on both big-endian and little-endian architecture, you are forced to know about C not guaranteeing much (if anything) with respect to bitfields
02:30:00 <mux> you generally use macros to switch order of the fields and that only works because GCC works this way
02:30:54 <mux> the /sys/dev/fxp/if_fxpreg.h file in the FreeBSD source tree is a good example
02:31:03 <ibid> struct layout is non-portable in C anyway, bitfields or no
02:31:18 <mauke> :t maybe
02:31:20 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:33:39 <mauke> maybe condFailure ((<< symbol) . return) (lookup x xs)  -- hehehe
02:36:34 <goltrpoat> so i remember reading that ghc defers a lot of common program transformations to a rather late point, in order to generate more sensible error messages.. is there a reason why the result of each transformation doesn't just carry a means of reconstructing the original from it instead, zipper style?
02:37:30 <goltrpoat> seems like doing certain operations on the undesugared AST is a bit of a pain
02:42:43 <ibid> goltrpoat: i believe it is common for optimizations to be done after desugaring. ghc is unsual about doing static analysis on ensugared programs :)
02:43:04 <goltrpoat> right, i'm asking about static analysis and typechecking
02:44:58 <ibid> goltrpoat: i suppose if you tried to do it and it worked they might consider adopting your change :)
02:45:22 <desp> ?seen bos
02:45:23 <lambdabot> bos is in #haskell-overflow and #haskell. I last heard bos speak 5h 33m 53s ago.
02:45:39 <goltrpoat> well.. i guess i'm asking if anything seems immediately wrong with the idea
02:45:54 <ibid> goltrpoat: it seems complicated and brittle to me
02:46:12 <ibid> goltrpoat: ... in a different way than the current one :)
02:46:19 <goltrpoat> haha exactly
02:46:41 <goltrpoat> basically, i was adding binding group extraction to my toy compiler, and it quickly turned into a rather long typing exercise
02:46:47 <desp> hmm
02:46:54 <goltrpoat> i remember doing the same thing for what essentially is my core language, and it took up about a page of code
02:46:57 <desp> how do I say that a module is supposed to export only fooFunction?
02:47:06 <desp> I thought it was  module Foo exports (fooFunction)
02:47:09 <ibid> desp: module Foo (fooFunction) where
02:47:14 <desp> oh
02:47:22 <desp> thanks
02:47:27 <ibid> desp: there is no "exports" keyword, the export list is just in parens
02:49:42 <encryptio> :t join
02:49:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:50:14 <mauke> @. djinn type join (,)
02:50:16 <lambdabot> f a = (a, a)
02:50:31 <encryptio> where might i find an introduction to kinds?
02:51:32 <quicksilver> encryptio: haskell kinds are particularly simple
02:51:39 <quicksilver> encryptio: * means 'any type'
02:51:51 <quicksilver> encryptio: * -> * is a type constructor, i.e. give it a type and it gives you a type
02:52:02 <quicksilver> encryptio: e.g., [] is a type constructor, [Int] is a type
02:52:08 <quicksilver> encryptio: so [] has kind * -> *
02:52:21 <quicksilver> encryptio: * -> * -> * just means it takes two parameters
02:52:29 <quicksilver> encryptio: (,) is a constructor, (Int,Char) is a type
02:52:37 <quicksilver> encryptio: that's really all there is to it, in haskell :)
02:52:48 <quicksilver> of course, more complex kind systems exist....
02:52:59 <encryptio> i mean really really basic stuff, like: what are they for?
02:53:06 <quicksilver> encryptio: as a way of classifying types
02:53:13 <ibid> encryptio: they're types for types
02:53:19 <quicksilver> encryptio: to be a Monad, a type must take a parameter
02:53:24 <quicksilver> encryptio: Int can't be a Monad
02:53:27 <goltrpoat> or classifying type expressions, if you will.
02:53:28 <encryptio> right, i get that
02:53:31 <quicksilver> encryptio: Monads have to have some variable
02:53:39 <quicksilver> sometwo: so in (Monad m) m has kind * -> *
02:53:50 <encryptio> can * be a (* -> *) ?
02:53:54 <quicksilver> yup
02:53:59 <quicksilver> erm
02:53:59 <ibid> encryptio: no
02:54:01 <quicksilver> nope :)
02:54:10 <ibid> encryptio: that's like asking if Int can be Int -> Int
02:54:15 <ibid> :)
02:54:28 <quicksilver> * is a 'real type', that you can actually have values of in a haskell program
02:54:41 <quicksilver> * -> * is only a constructor, it's not a type until you give it an argument
02:55:07 <encryptio> so... kinds let you describe how types are built up
02:55:24 <quicksilver> right
02:55:27 <ibid> encryptio: the reason for kinds is about the same as why have types, it allows ruling out nonsensical type expressions early
02:55:36 <encryptio> ibid: such as?
02:55:40 <goltrpoat> here's a quick definition:  * is the kind of all nullary type expressions.  if k1 and k2 are kinds, then k1 -> k2 is a kind.  a type expression consists of a type constant, type variable, or application of one type to another.
02:55:55 <ibid> encryptio: Monad -> Int
02:56:00 <ibid> grah
02:56:05 <ibid> that's a bad example
02:56:06 <encryptio> >.>
02:56:09 <goltrpoat> so you see how it's basically similar to the type system, in a very restricted way.
02:56:11 <ibid> encryptio: IO -> Int
02:56:21 <desp> type of types of types...
02:56:23 <ibid> goltrpoat: it's exactly a type system, just for types and not expressions
02:56:27 <ClaudiusMaximus> is there a "next level" for classifying kinds?
02:56:31 <ibid> goltrpoat: it's a simpler system, tyes
02:56:38 <ibid> ClaudiusMaximus: there could bem but there is no need
02:56:51 <encryptio> so * could be filled with Int, Float, Char, etc.. right?
02:57:05 <ibid> encryptio: * is the kind of Int, like Int is the type of 4
02:57:08 <matthew-_> ClaudiusMaximus: Omega has index types which are very much like additional layers of type systems
02:57:17 <ibid> encryptio: "filled" is not exactly the right word for it
02:57:23 <goltrpoat> ibid:  "type system" as opposed to "kind system"
02:57:37 <goltrpoat> as in, the haskell type system, not *a* type system.
02:57:44 <encryptio> * could also be IO Int, [Char], etc. (they have kind *) -- no?
02:57:57 <ibid> encryptio: yes, all real types are kind *
02:57:57 <encryptio> but * can't be IO, [], :, etc
02:58:00 <ibid> encryptio: yes
02:58:08 <encryptio> interesting
02:58:09 <matthew-_> just think of it like this: types classify values; kinds classify types
02:58:16 <ibid> goltrpoat: not 100% sure what you mean, but probably yes
02:58:23 <quicksilver> and boring old men classify kinds
02:58:36 <matthew-_> quicksilver: ?
02:59:01 <ibid> quicksilver: could be interesting, young and women too
02:59:20 <goltrpoat> hell, could be a raccoon.
02:59:41 <ibid> not sure about hell :)
02:59:42 <matthew-_> quicksilver: oh, just got that (assuming you were referring to a certain conversation involving Sheard and edwinb)?
02:59:56 <encryptio> so if i have a function that requires forall (m :: * -> *). Monad m => ..., i can't use StateT there
03:00:25 <quicksilver> matthew-_: no, not really. Just a cheap gibe at theory types :)
03:00:44 <goltrpoat> :k StateT
03:00:46 <lambdabot> * -> (* -> *) -> * -> *
03:01:02 <ibid> encryptio: no, but you could use StateT SomeType IO
03:01:23 <quicksilver> encryptio: type constructors can be partially applied just like functions can be partially applied
03:01:30 <encryptio> cool.
03:01:32 <quicksilver> encryptio: with corresponding simplification in kind
03:01:57 <encryptio> quicksilver: do you know of an example where partially applied type constructors would be useful?
03:02:00 <quicksilver> (+) has type Int -> Int -> Int, but (+) 3 has type Int -> Int
03:02:06 <quicksilver> encryptio: yes, that one you just gave :)
03:02:07 <ibid> encryptio: my example above is one
03:02:19 <encryptio> i mean a more fleshed out example
03:02:25 <ndm> @seen hyrax42
03:02:25 <lambdabot> hyrax42 is in #haskell-blah and #haskell. I don't know when hyrax42 last spoke.
03:02:29 <quicksilver> similarly (,) has kind * -> * -> *, but (,) Int has kind * -> *
03:02:43 <edwinb> matthew-_: I've no idea what you mean ;)
03:02:54 <ndm> ping hyrax42
03:03:03 <mauke> newtype FInterp r a = FInterp { runFInterp' :: ReaderT r IO a } deriving (Monad, MonadIO, MonadReader r)
03:03:09 <quicksilver> encryptio: mostly for making instances
03:03:10 <encryptio> :t (,) 'a'
03:03:34 <quicksilver> encryptio: to make something an instance of monad, you need to partially apply it until its kind is *->*
03:03:37 <quicksilver> encryptio: for example
03:05:40 <lambdabot> forall b. b -> (Char, b)
03:05:50 <encryptio> lambdabot: took long enough
03:07:23 <encryptio> quicksilver: interesting
03:07:29 <quicksilver> :k (,) Int
03:07:31 <lambdabot> * -> *
03:07:58 <quicksilver> for example, you can make (,) Int into a functor if you like
03:08:12 <goltrpoat> type IntListState = State [Int];  -- State is partially applied
03:08:18 <quicksilver> but you couldn't make (,) into a functor, per se, it's not the right kind.
03:08:20 <encryptio> :k State
03:08:22 <lambdabot> * -> * -> *
03:08:23 <goltrpoat> then foo :: IntListState Bool; foo = return True
03:09:00 <quicksilver> also, you might define type WithError x = Either Exception x
03:09:08 <quicksilver> which is the same as WithError = Either Exception
03:09:13 <quicksilver> that's partially applying Either
03:09:37 <encryptio> sweet.
03:10:10 <encryptio> so what's ? mean?
03:10:12 <vincenz> withError s a = catchError a (const $ throwError s)
03:10:32 <ndm> @tell hyrax42 - will be back on IRC in about an hour, if you want to discuss soc
03:10:32 <lambdabot> Consider it noted.
03:11:55 <encryptio> as compared to *
03:12:25 <ibid> encryptio: where do you see it?
03:12:49 <encryptio> deliberately causing kind errors to experiment: ghci> (return 'a') :: IO
03:12:53 <encryptio>     `IO' is not applied to enough type arguments
03:12:53 <encryptio>     Expected kind `?', but `IO' has kind `* -> *'
03:13:32 <encryptio> i assume ? is a subtype (word?) of *
03:13:41 <quicksilver> subkind :)
03:13:55 <quicksilver> it's something to do with boxed or boxable or something
03:13:59 <goltrpoat> no, that's #
03:15:06 <ibid> encryptio: http://cvs.haskell.org/trac/ghc/wiki/IntermediateTypes
03:15:08 <lambdabot> Title: IntermediateTypes - GHC - Trac
03:15:25 <ibid> ?    [OpenTypeKind]means any type at all
03:15:47 <encryptio> including (* -> *)?
03:16:12 <quicksilver> no
03:16:16 <quicksilver> any type, not any kind
03:16:20 <ibid> encryptio: that's not a type
03:16:28 <quicksilver> I was write, it was to do with boxable :)
03:16:32 <quicksilver> s/write/right/
03:17:00 <quicksilver> encryptio: it's an implementation detail and not very important to the programmer
03:17:15 <quicksilver> encryptio: it's to do with wh
03:17:24 <quicksilver> how many different kinds of _|_ there are in the type
03:17:29 <goltrpoat> quicksilver:  you mean unboxed?  all native haskell value types are boxed in one way or another, right
03:17:43 <quicksilver> (bad choice of the word using 'kinds' there)
03:17:57 <ibid> goltrpoat: all types in h98 are boxed, but not all ghc types are
03:18:11 <goltrpoat> which then gives rise to the # kinds
03:18:13 <encryptio> quicksilver: unless that programmer is highly interested in compilers
03:18:21 <quicksilver> encryptio: indeed :)
03:18:26 <goltrpoat> or that was my impression anyway
03:18:38 <quicksilver> goltrpoat: but ? is a mixture of * and #
03:18:45 <goltrpoat> right, it's either one
03:18:54 <goltrpoat> oh.. "has to do with unboxed types" in that sense? :)
03:19:01 * quicksilver nods
03:19:04 <goltrpoat> gotcha.
03:20:54 <encryptio> i can't seem to get the kind of (:)
03:21:05 <goltrpoat> (:) is not a type constructor though
03:21:11 <encryptio> data constructor?
03:21:12 <ibid> encryptio: (:) has no kind
03:21:15 <goltrpoat> yes
03:22:00 <encryptio> so [] is a type constructor and a data constructor
03:22:10 <goltrpoat> and a value
03:22:15 <encryptio> ugh
03:22:17 <goltrpoat> hehe
03:22:24 <encryptio> weird.
03:22:32 <ibid> encryptio: so is ()
03:22:45 <ibid> encryptio: a data constructor is always a value too
03:23:05 <goltrpoat> sorry, i meant that [] acts oddly as a data constructor, since it's built in
03:23:49 <goltrpoat> (a fully applied data constructor is a value -- and [] as a data constructor has variable arity, in a way)
03:23:52 <ibid> the only oddity of [] is its syntax
03:24:16 <vincenz> that's odd
03:24:16 <vincenz> ghc --make  -o Main Main.hs
03:24:17 <vincenz> <no location info>: file name does not match module name `Main'
03:24:23 <vincenz> it worked fine before and now suddenly this!
03:24:24 <encryptio> aren't partially applied data constructors values too? functions?
03:24:32 <encryptio> or are functions not considered values for this discussion?
03:24:46 <encryptio> :t Maybe
03:24:48 <lambdabot> Not in scope: data constructor `Maybe'
03:24:52 <quicksilver> :t Just
03:24:52 <quicksilver> :P
03:24:54 <lambdabot> forall a. a -> Maybe a
03:24:55 <vincenz> any clues?
03:24:56 <encryptio> yeah, that.
03:25:24 <ibid> encryptio: yes, data constructors are always values, even partially applied
03:25:32 * vincenz scratches his head
03:25:33 <goltrpoat> ?
03:25:39 <encryptio> kewl
03:25:40 <vincenz> Anyone know why ghc is suddenly fucking up
03:25:57 <vincenz> ghc --make  -o Main Main.hs
03:25:58 <vincenz> <no location info>: file name does not match module name `Main'
03:25:58 <vincenz> make: *** [Main] Error 1
03:26:00 <encryptio> vincenz: is it not module Main in Main.hs?
03:26:05 <vincenz> encryptio: it is
03:26:07 <vincenz> it was
03:26:10 <vincenz> I didn't touch that module
03:26:15 <vincenz> it worked fine before
03:26:30 <ibid> goltrpoat: who are you asking? :)
03:26:35 <vincenz> oh, it's another module
03:27:18 <goltrpoat> ibid:  i think people usually distinguish between value types and function types
03:27:50 <encryptio> :k Num
03:27:52 <lambdabot> Class `Num' used as a type
03:27:56 <encryptio> :k Num a => Maybe a
03:27:58 <lambdabot> *
03:28:25 <ibid> goltrpoat: function types a
03:28:26 <ibid> goltrpoat: gah
03:28:31 <ibid> goltrpoat: never heard of that
03:28:50 <encryptio> goltrpoat: i don't, not in haskell
03:28:56 <ibid> goltrpoat: in lambda calculus derived languages, functions can be values in their own right
03:29:42 <goltrpoat> ibid:  the "value types are types.  if a and b are types, then a->b is a type" definition is common.
03:29:49 <ibid> goltrpoat: never heard
03:29:54 <quicksilver> certainly some people distinguish :)
03:29:59 <ibid> goltrpoat: when formally defining what a value is, usually \x.E (where E is any expression of a good type) is taken as one example of values
03:30:06 <quicksilver> however other people are equally keen not to
03:30:17 <quicksilver> what about data Foo = Foo (Int -> Int), say
03:30:18 <ibid> goltrpoat: in an operational semantics system, anyway :)
03:30:20 <goltrpoat> ibid:  but that's untyped
03:30:23 <quicksilver> is Foo now a 'value' or a 'function' ?
03:30:30 <ibid> goltrpoat: doesn't have to be
03:30:53 <ibid> goltrpoat: in fact, that is independent of whether the system is typed or not
03:31:20 <encryptio> i usually think of a function as a special kind of value. a value can be anything - a function takes (at least one) argument.
03:31:23 <ibid> goltrpoat: what i've heard people use is "basic types" or "atomic types", but not "value types"
03:31:32 <encryptio> quicksilver: yes
03:31:43 <rjeq> if (x:xs) is the common way to name variables in that kind of pattern, what is the common way to name variables in the whole@(head:tail) pattern?
03:31:55 <goltrpoat> ibid:  i was using "basic type" for a while, but then someone corrected me.
03:31:59 <goltrpoat> perhaps incorrectly, then.
03:32:44 <ibid> goltrpoat: pierce uses "base type" in TaPL
03:32:47 <goltrpoat> right
03:32:57 <ibid> or rather, "base types"
03:33:05 <goltrpoat> but ive never seen that outside of TaPL
03:33:20 <goltrpoat> so i dunno.
03:33:33 <ibid> goltrpoat: using "value type" to exclude functions seems counterproductive, as functions are values in LC-derived languages
03:33:40 <mux> base types makes sense, since you usually consider (->) as some kind of function creating new types
03:33:45 <ibid> goltrpoat: can you give a reference for your usage?
03:33:59 <mux> like if a and b are types, a -> b is another type
03:34:23 <quicksilver> rjeq: I use l@(x:xs)
03:34:33 <goltrpoat> ibid:  irc :).  like i said, i was using 'basic type' for some time.  'value type' is a common term in C-derived languages, so i'm guessing that's where it comes from.
03:34:38 <quicksilver> rjeq: and, if needed m@(y:ys) etc
03:34:51 <ibid> goltrpoat: in C it makes sense, as function types are second-class
03:34:55 <goltrpoat> -nod-
03:34:57 <rjeq> quicksilver: ok, makes sense
03:35:03 <ibid> goltrpoat: but we're not in sunch language here :)
03:35:19 <rjeq> thanks
03:35:21 <quicksilver> also, what about data MightBeFun = NotFun Int | IsFun (Int -> Int)
03:35:28 <quicksilver> now, is one of those a value or not ? :)
03:35:32 <goltrpoat> but in haskell, it makes sense as well, because fully applied things are treated differently even at the syntax level.
03:35:39 <encryptio> quicksilver: all are values
03:35:41 <quicksilver> goltrpoat: erm?
03:35:53 <quicksilver> goltrpoat: how are fully applied things treated differently at the syntax level?
03:35:59 <encryptio> goltrpoat: not really
03:36:04 <encryptio> > 1 2
03:36:05 <lambdabot>   add an instance declaration for (Num (t -> a))
03:36:05 <lambdabot>     In the expression: 1 2
03:36:05 <lambdabot>  ...
03:36:05 <quicksilver> the parser doesn't know if things are fully applied or not...
03:36:08 <goltrpoat> (+5) occupies a very different slot in the grammar than True does, and both occupy a different slot than Just 5.
03:36:12 <ibid> goltrpoat: you can treat partially applied things as syntactic sugar for a lambda abstraction
03:36:25 <encryptio> goltrpoat: not in the grammar, in the type system
03:36:26 <ibid> goltrpoat: so, (+5) is sugar for \x -> x+5
03:36:33 <ibid> goltrpoat: and so, (+5) is a value
03:36:38 <quicksilver> goltrpoat: but (f a) (f a b) and (f a b c) and (f a b c d) are all the same point in the grammar
03:36:44 <ibid> goltrpoat: i would not use concrete syntax as a guide for semantic terminology :)
03:36:50 <quicksilver> goltrpoat: and there's not way you can tell me which of those is partially applied and which is not
03:36:58 <quicksilver> (and neither can the parser)
03:37:21 <goltrpoat> well, actually.. we were talking about data constructors when this started, and if it had been F, then the parser does need to tell
03:37:30 <encryptio> not really
03:37:33 <encryptio> the type system does
03:37:53 <quicksilver> you don't need to write a Kind checker to write a H98 parser, as far as I'm aware
03:37:54 <goltrpoat> actually, the type system cares a little bit less than the parser here
03:37:54 <goltrpoat> hehe
03:38:12 <ibid> goltrpoat: we can treat a partially applied data constructor similarly as syntactic sugar for a lambda abstraction wrapping a fully saturated constructor application
03:38:26 <ibid> goltrpoat: i believe that's the common implementation pattern, even
03:38:32 <quicksilver> the only time the parser needs to tell is in patterns, surely
03:38:37 <ibid> goltrpoat: so Maybe is sugar for (\a -> Maybe a)
03:38:44 <quicksilver> well even then, the parser doesn't need to
03:38:46 <ibid> gah
03:38:48 <quicksilver> we can throw an error letter
03:38:49 <quicksilver> later
03:38:55 <ibid> goltrpoat: so Just is sugar for (\a -> Just a)
03:38:56 <goltrpoat> quicksilver:  nullary constructors end up in the APAT rule as patterns.  others end up in PAT^10.  you have to run over the data declarations first and extract arities.
03:38:57 <ibid> obviously :)
03:39:24 <goltrpoat> actually..  "others" = "fully applied constructors"
03:40:04 <goltrpoat> but.. that's in PAT, so that doesn't apply to expressions
03:40:25 <encryptio> quicksilver: are partially applied type constructors part of h98?
03:40:46 <quicksilver> encryptio: yes
03:41:40 <quicksilver> goltrpoat: hmm interesting
03:41:45 <goltrpoat> ibid:  anyway, no, i'm not claiming that partially applied functions are semantically different from basic values in most cases, that'd be silly
03:41:46 <quicksilver> goltrpoat: still that's a special case for constructors
03:41:48 <huschi> ?hpaste
03:41:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:42:04 <quicksilver> goltrpoat: it's not the case that the grammar distinguishes in generlaly between fully applied terms
03:42:48 <goltrpoat> quicksilver:  right.  but we were talking about data constructors.
03:43:00 <quicksilver> and it's not clear to me that the grammar *needs* to do that
03:43:01 <encryptio> do patterns need to be a certain kind? "?", or "*"? or does it matter? do pattern matches even have kinds?
03:43:05 <quicksilver> I guess they just thought it was simpler
03:43:08 <goltrpoat> quicksilver:  that's not clear to me either.
03:43:24 <quicksilver> I dont thinkg (Just a b) means anything in a pattern
03:43:37 <quicksilver> I don't think the ambiguity resolution gained this way is used
03:44:45 <encryptio> from the error messages ghc gives, i'd assume that yes, it does need to be a certain kind, but that kind isn't checked by the typical kind checker
03:45:32 <quicksilver> encryptio: patterns woudln't have kinds
03:45:38 <quicksilver> encryptio: they'd have types at best, surely
03:45:44 <vincenz> Yay for the typechecker catching zillions of errors as I continue to code sleep-deprivatedly
03:45:59 <goltrpoat> quicksilver:  i think it can be refactored to not distinguish between nullary and fully applied patterns in the PAT/APAT productions
03:46:12 <goltrpoat> quicksilver:  you do need to know that it's fully applied in patterns though, obviously
03:46:27 <quicksilver> goltrpoat: the compiler does, yes
03:46:38 <quicksilver> goltrpoat: but there's not reason for the parser to know that, AFAICS
03:46:55 <quicksilver> goltrpoat: the parser can just note the arity with which things are applied, and the compiler can complain if that's wrong
03:47:16 <ibid> encryptio: patterns correspond to expressions so they have types
03:48:16 <vincenz> woo
03:48:21 <vincenz> my function is now 170 lines of code
03:48:30 <earthy> that's a bit big
03:48:31 * vincenz expects it to grow > 200
03:48:43 <encryptio> i hope it's well factored
03:48:48 <vincenz> it is
03:49:09 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/Screenshot.png
03:49:11 <vincenz> gives you an idea
03:49:13 <vincenz> that's part of it
03:50:10 <encryptio> :t fail
03:50:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
03:50:15 <earthy> ah, that's a bit artificial
03:50:20 <goltrpoat> quicksilver:  i think you're right
03:50:36 <earthy> I'd put that in 'TypeCheck.hs' and factor it out in seperate functions
03:50:45 <quicksilver> vincenz: I tend to write such things at top level
03:50:54 <quicksilver> vincenz: mainly so that I can test them independently with ghci
03:50:57 <encryptio> me too
03:51:00 <quicksilver> (which is not a particualrly good reason, but there you go)
03:51:01 * earthy concurs
03:51:09 <earthy> actually, that is a pretty good reason
03:51:13 <encryptio> and for the same reason
03:51:21 <earthy> especially if you add quickcheck properties
03:51:49 <vincenz> quicksilver: I can't
03:51:52 <quicksilver> that's another (better) reason
03:51:53 <vincenz> quicksilver: they depend on input params
03:52:07 <quicksilver> vincenz: typically I'd refactor those, then, as function params
03:52:17 <vincenz> quicksilver: I don't feel like having a shitload of func params
03:52:19 <quicksilver> I value the ability to independently test relatively small pieces of code
03:52:19 <vincenz> for all my functions
03:52:28 <vincenz> quicksilver: well I value a clean design
03:52:38 <quicksilver> whether that testing is manual in ghci, or automatic via a test suite
03:52:47 <vincenz> ..
03:53:02 <vincenz> the toplevel function takes 6 params
03:53:07 <vincenz> I don't feel like having ALL my functions inside
03:53:12 <vincenz> take 6 + all those things I define params
03:53:14 <vincenz> that's just insane
03:53:40 <quicksilver> as you wish
03:53:40 <encryptio> are those called closures in haskell too?
03:53:54 <quicksilver> I think it's "just insane" to have that many pieces of code you can't independently test :)
03:53:56 <goltrpoat> besides, if something really needs testing, it can be given the extra parameters and lifted outside the scope temporarily
03:55:03 <vincenz> quicksilver: well either way, testing these things would be damn near impossible
03:55:07 <vincenz> too much environment/context
03:55:15 * vincenz works with sample inputs for testing
03:56:17 * quicksilver nods
03:56:24 <quicksilver> well I generally work with sampleinputs too
03:56:42 <quicksilver> but then I can also run makeFSigs . parse $ sampleinput
03:57:12 <quicksilver> and hence test funcResolveMap (makeFSigs . parse $ sampleinput)
03:57:15 <vincenz> heh
03:57:16 <vincenz> nope
03:57:27 <vincenz> there's a shit load of steps that need to be done prior to typeCheckBodies
03:57:32 * quicksilver nods
03:58:00 <desp> http://darcs.haskell.org/http/test/get.hs vs http://hpaste.org/1098 :)
03:58:11 <goltrpoat> i have a whole file's worth of diagnostic functions
03:58:12 <goltrpoat> heh
03:58:23 <goltrpoat> run a sample input, and apply [...]
03:59:38 <goltrpoat> what's really great is when i test something on a complete module passed as a string (without layout rule applied), it works, then test it on a file with the same code (layout rule applied), it breaks
03:59:55 <vincenz> :D
04:00:02 <goltrpoat> so i spend half an hour trying to figure out what's wrong with the lexer, until i realize that i changed something or other in one diagnostic function, and didn't propagate the change to the rest
04:00:03 <vincenz> goltrpoat: layout rule is hard to code
04:00:08 <goltrpoat> happened several times now
04:00:37 <goltrpoat> actually, i coded it from the report description, and never had to change it.  every time something breaks i keep thinking it's the layout rule though
04:01:12 <vincenz> where do you code it? in the lexer or parser?
04:01:16 <goltrpoat> in the lexer
04:01:31 <goltrpoat> (sans note 5)
04:01:43 * vincenz nods
04:01:47 <vincenz> still a bitch
04:01:51 <vincenz> goltrpoat: what language, haskell?
04:01:54 <goltrpoat> yeah
04:03:16 <vincenz> goltrpoat: NHC? YHC?
04:04:31 <goltrpoat> which part?
04:04:31 <goltrpoat> hehe
04:04:41 <goltrpoat> it's my own toy compiler
04:04:42 <vincenz> what do you work on?
04:04:45 <vincenz> oh
04:04:57 <vincenz> I once tried to get layout rule
04:05:04 <vincenz> cause the rest of my parser is quite stable
04:05:06 <vincenz> but :/
04:05:14 <vincenz> it's language specific?
04:05:23 <vincenz> I mean your parser must feedback to the lexer depending on the type of block?
04:05:31 <goltrpoat> only for note 5
04:05:38 <vincenz> and what does your toy compiler handle? h96?
04:05:41 <vincenz> goltrpoat: note 5? link?
04:05:45 <goltrpoat> h98
04:05:58 <goltrpoat> http://haskell.org/onlinereport/syntax-iso.html
04:05:59 <lambdabot> Title: Haskell 98 Syntax
04:06:19 <vincenz> thx
04:06:27 <vincenz> CHR based inference?
04:06:57 <vincenz> or what's the name, well basically, constraint-based?
04:07:04 <vincenz> do you do source-locs?
04:07:10 <vincenz> how do you handle TCs?
04:07:51 <goltrpoat> i'm pretty early in the process.  i wrote a toy compiler for what'll end up as the core language a while back, then read THIH and implemented a fairly toy typechecker from there, wrote a mostly functional parser, trying to tie it all together now
04:08:05 * vincenz nods
04:08:12 <vincenz> closest I got was a miniML based one, once
04:08:18 <vincenz> it was like miniML
04:08:22 <vincenz> but with haskell's module system
04:08:26 <vincenz> and top-level recursion
04:08:28 <vincenz> (ala haskell)
04:08:36 <goltrpoat> ah cool
04:08:49 <vincenz> but then I needed an eager lang, so haskell wasn't the target
04:08:57 <vincenz> now I'm working on a ++c one
04:09:05 <goltrpoat> ++c?
04:09:10 <vincenz> c++ done right :)
04:09:13 <goltrpoat> ah
04:09:23 <vincenz> (or should I say left?)
04:09:25 <goltrpoat> d seems like c++ done right, in a lot of ways
04:09:35 <rjeq> ?pl \a b -> xor (ord a) (ord b)
04:09:35 <lambdabot> (. ord) . xor . ord
04:09:36 <goltrpoat> i haven't looked into it enough to know for sure, though
04:09:50 <rjeq> ?pl \a b -> chr . (xor (ord a) (ord b))
04:09:51 <lambdabot> ((chr .) .) . (. ord) . xor . ord
04:10:08 <vincenz> goltrpoat: yeah but I need my own compiler
04:10:10 <huschi> yesterday i learned (from dmhouse and int-e) that the only value of type (forall a. Show a -> a) is bottom.
04:10:10 <goltrpoat> the goggles!  they do nothing!
04:10:15 <vincenz> goltrpoat: I want to add some extra semantical constructs
04:10:21 <huschi> what about (forall a. Num a -> a)?
04:10:49 <huschi> are 0, 1, 2, ... values of this type?
04:10:54 <int-e> huschi: you get integers for that I think - fromIntegral 0  (or, by desugaring, just 0) inhabits that type.
04:11:23 <goltrpoat> vincenz:  i wrote a compiler for a c++-style language (minus templates, plus yield, and i sort of reinvented python generators for it) a while back
04:11:45 <huschi> yeah, my understanding increases every day.
04:11:54 <int-e> huschi: the difference is that the Num class has functions that construct values. (namely, fromInteger)
04:11:59 <goltrpoat> we were going to use it as a DSL for a number of tasks
04:12:06 <goltrpoat> then, unfortunately, i got exposed to other languages
04:12:28 <vincenz> goltrpoat: link?
04:12:29 <goltrpoat> which made me realize that the design was utterly horrible.  now it looks like eiffel.
04:12:37 <huschi> int-e: that's what brought me to my conclusions that the whole numbers are values of this type.
04:12:46 <goltrpoat> oh, no link, it was an internal project
04:12:53 <vincenz> goltrpoat: pm
04:13:02 <goltrpoat> or.. well, is now, modulo the whole revamping bit
04:13:16 <huschi> int-e: has this already to do sth with rank 2 polymorphism?
04:14:40 <int-e> huschi: yes. although you can reduce the question to standard (HM?) polymorphism with type classes, by asking the question what functions of type  Num a => a you can write.
04:15:15 <kzm> Is it possible to compile an .hc file with gcc?  (I'm trying to use -ftrapv to trap overflow, -fvia-c and -optc- didn't work.)
04:16:22 <huschi> int-e: ok. does rank 2 polymorphism exist in oo languages like c++ and java, too?
04:16:59 <huschi> int-e: afaik you can't express sth like forall a. Num a => a in those languages or am i wrong?
04:17:17 <quicksilver> it might be true that compilers implement '0' as a fromIntegral
04:17:19 <quicksilver> :t 0
04:17:21 <lambdabot> forall t. (Num t) => t
04:17:30 <quicksilver> but technically, '0' is a constructor in the typeclass
04:17:40 <quicksilver> however a compiler might choose to implement it :)
04:17:42 <int-e> huschi: you can simulate it with OO - by making classes out of type classes.
04:18:14 <int-e> quicksilver: IIRC, the haskell report defines 0 as fromInteger 0, where the second 0 is an Integer literal.
04:18:42 <huschi> int-e: simply concerning 1 :: forall a. Num a -> a. i can't imagine how to express this in oo.
04:20:43 <int-e> huschi: well, you can turn the Num class into an interface and that function into a function that takes such an interface and an integer and calls the fromInteger function from the Num interface instance. This is basically how dictionary passing implementations of type classes work.
04:21:20 <huschi> int-e: ah, ok.
04:22:23 <quicksilver> int-e: well maybe I'm splitting hairs but...
04:22:33 <int-e> on the way you probably lose most hopes of preserving the type-safety that Haskell provides.
04:22:36 <quicksilver> int-e: the report says that it is 'equivalent' to fromIntegral 0
04:22:42 <quicksilver> int-e: not that it is 'defined to be'
04:23:00 <int-e> quicksilver: ok.
04:23:13 <quicksilver> int-e: I've always thought of the numbers as genuine type class constructors, at least :)
04:23:35 <quicksilver> :t \n -> case n of 0 -> True ; _ -> False
04:23:37 <lambdabot> forall t. (Num t) => t -> Bool
04:23:40 <huschi> int-e: atm, i'm working with sql databases. so, there is no type safety to loose :)
04:23:48 <quicksilver> int-e: note that you can't use 'fromIntegral' in a pattern match :)
04:24:54 <int-e> quicksilver: I understand that some compiler implementers are unhappy with n-patterns (i.e. literal numbers as patterns), because it desugars to a guard.
04:25:25 <quicksilver> int-e: indeed :)
04:25:48 <quicksilver> int-e: but thinking as a user, not an implementor, I'd say that proved it was a constructor
04:26:00 <quicksilver> int-e: no matter how much I might know about how it was implemented
04:27:32 <huschi> i've got a class "class Value v" with a method "fromSQL :: (forall s. SqlBind s => s) -> v"
04:27:45 <simon__> This might sound like a daft question, but would a backend for Happy which outputted a Parsec parser be a sensible development?
04:27:56 <huschi> that is rank 2 polymorphism, or isn't it?
04:28:11 <huschi> can this also be expressed in OO?
04:28:26 <int-e> heh. this reminds me of another reason why unary minus is bad ... the literal -1 gets desugared to negate (fromInteger 1) if all the compiler has to work with is an arbitrary Num instance.
04:30:51 <vincenz> >  1 /= 2
04:30:51 <vincenz> >  1 != 2
04:30:52 <lambdabot>   Not in scope: `!='
04:30:53 <lambdabot>  True
04:31:23 <quicksilver> intresting.
04:31:25 <desp> interesting
04:31:28 <quicksilver> asynchrony from lamdabot
04:31:35 <desp> @stereo
04:31:35 <lambdabot> Unknown command, try @list
04:31:46 <desp> wah
04:32:05 <desp> why there are so many different prefixes? :)
04:32:09 <quicksilver> @quote stereo
04:32:09 <lambdabot> #haskell says: @quote stereo
04:32:20 <quicksilver> @ is the standard and main prefix
04:32:32 <quicksilver> ':' was added just to make it 'more like ghci/hugs'
04:32:43 <quicksilver> and AFAIK only applies to :t and :k
04:32:44 <desp> and ?
04:33:01 <desp> and >
04:33:01 <ibid> :yow
04:33:07 <ibid> looks like it
04:33:08 <quicksilver> I don't thin there's any time when ? is better than @
04:33:10 <desp> ?yow
04:33:10 <lambdabot> When you said "HEAVILY FORESTED" it reminded me of an overdue CLEANING
04:33:10 <lambdabot> BILL ... Don't you SEE?  O'Grogan SWALLOWED a VALUABLE COIN COLLECTION
04:33:10 <lambdabot> and HAD to murder the ONLY MAN who KNEW!!
04:33:13 <quicksilver> I think @ is the one to use
04:33:26 <quicksilver> desp: well > is totally different; thats to execute code
04:33:31 <desp> right
04:33:39 <int-e> quicksilver: it is on certain keyboard layouts.
04:33:45 <gleb> huschi: I don think there's rank-2 polymorphism there
04:34:12 <gleb> rank-2 polymorphic function must accept polymorphic function as argument
04:34:15 <quicksilver> int-e: ah, fair enough :)
04:34:35 <huschi> gleb: i also can't image how to implement something equivalent in java.
04:35:19 <quicksilver> huschi: isn't SqlBind just a java interface?
04:35:29 <huschi> quicksilver: no, it's from HSQL.
04:35:34 <quicksilver> duh :P
04:35:44 <quicksilver> I mean, if you want something equivalent in Java, woudln't it be...
04:36:11 <quicksilver> class Value { Value fromSQL(SqlBind s); }
04:36:21 <quicksilver> interface SqlBind { ... }
04:36:28 <quicksilver> (I don't remember my java syntax all that well)
04:36:58 <huschi> but this only says that you can access the functions of SqlBind on s in fromSQL.
04:37:33 <huschi> but the haskell version says that you can treat the argument to fromSQL as any special instance of SqlBind.
04:37:50 <huschi> that's the way i understood it. or am i wrong?
04:42:50 <int-e> @quote conspiracy
04:42:50 <lambdabot> mwc says: I can only believe that Java is a conspiracy perpetrated by keyboard manufacturers
04:44:36 <jacobian> lol
04:49:02 <kzm> I tried to adapt "inversion of control" to Haskell, but failed.  Anybody look at that?
04:49:46 <kzm> For me, it just dissolved into good ole HOFs.  But perhaps I don't grok the concepts deeply enough?
04:50:33 <kzm> I have a problem with ghc 6.7 and QuickCheck.  I installed it with cabal, but when I try to build a project depending on it, I get a message claiming it is hidden.  What gives?
04:50:40 <kzm> ghc-pkg expose didn't help, btw.
04:50:44 <robokop> how do i query the bot for functions?
04:51:04 <kzm> (slash)msg lambdabot @list
04:51:11 <kzm> Or did you mean @hoogle?
04:51:33 <robokop> kzm a the @ and not the !
04:51:54 <kzm> the ?
04:52:44 <gleb> huschi: I cannot see the difference in this case
04:53:12 <robokop> kzm: i have to start bot commands with the char @ and not with the char !
04:53:19 <huschi> gleb: you mean the difference between the java and the haskell code?
04:53:22 <robokop> kzm: that was my prob
04:54:02 <gleb> huschi: yes, I think quicksilver translated it pretty close
04:54:50 <kzm> ?hoogle
04:54:50 <lambdabot> HOOGLE - Haskell API Search
04:54:50 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
04:54:50 <lambdabot>  
04:54:57 <kzm> ...also works.
04:55:00 <huschi> the java signature for fromSQL would be "fromSQL :: SqlBind s => s -> Value" in haskell.
04:55:52 <gleb> huschi: there's implicit "forall s" in all polymorphic signatures
04:56:14 <huschi> that means the calling function decides which instance for s should be chosen while "fromSQL :: (forall s. SqlBinds => s) -> Value" means that the implementation of fromSQL can chose this.
04:57:13 <huschi> but "forall s. SqlBind s => s -> Value" is different from "(forall s. SqlBind s => s) -> Value
04:59:57 <huschi> the simplest sample that shows this are functions with the following type:
05:00:10 <huschi> f1 :: forall a. Integral a => a -> Integer
05:00:26 <huschi> f2 :: (forall a. Integral a => a) -> Integer
05:00:46 <huschi> the first one can be called with (1 :: Int) as argument while the second can't.
05:17:11 <kzm> It's not possible to use DEPRECATED on a re-exported entity?  (I.e. I just want to deprecate this particular route of importing it)
05:18:40 <gleb> huschi: You're right, sorry for the noise
05:21:24 <eivuokko> Helloh
05:25:19 <huschi> gleb: you don't need to excuse. explaining it helps me too.
05:27:17 <ndm> @seen hyrax42
05:27:17 <lambdabot> hyrax42 is in #haskell-blah and #haskell. I don't know when hyrax42 last spoke.
05:28:52 <quicksilver> huschi: you could do that in java too, but it might seem like an unnatural abstraction
05:29:12 <quicksilver> huschi: you'd have to have a class or interface for 'AnySqlBind' to represent universal values
05:31:06 <huschi> quicksilver: and then you would need a function that converts this to any class that implements SqlBind.
05:32:02 <eulero> I was reading "Can Programming Be Liberated from the von Neumann Style" by Backus and I've realized how, 30 years later we're still very attached to the von Neumann paradigm. And it seems to me that Haskell is the only candidate able to bring to reality the dream of applicative models in the industry.
05:33:56 <quicksilver> huschi: right.
05:34:19 <quicksilver> huschi: it's not entirely unlike some versions of the 'factory' pattern
05:35:06 <huschi> quicksilver: but that mechanism is restricted to the types that are known at the compile time of the AnySqlBind.
05:35:09 <eulero> what do you think?
05:35:24 <quicksilver> huschi: not necessariliy
05:35:26 <huschi> ok, you can extend with handlers.
05:35:40 <quicksilver> huschi: you could make the SqlBind class have 'construct from AnySqlBind' in it
05:35:48 <quicksilver> then any new subclass would add that
05:35:51 <dolio> eulerio: It might not be the only one...
05:36:33 <eulero> dolio: what are other alternatives?
05:36:50 <dolio> :) I don't know. I'm thinking.
05:37:00 <dolio> There's always J. :)
05:37:11 <eulero> dolio: ahahah
05:37:29 <quicksilver> there's a fair amount of ML, erlang and lisp out in industry
05:38:04 <hpaste>  vincenz pasted "My lexer" at http://hpaste.org/1100
05:38:31 <eulero> quicksilver: but correct me if I'm wrong, none of those are purely functional
05:38:53 <eulero> quicksilver: and by that I mean, without side effects
05:39:08 <dolio> Yeah, it all depends on how closely you think those fit.
05:39:30 <dolio> ML may be moving in the purer direction (I think that's the one).
05:39:48 <dolio> More towards monads, I think.
05:40:19 <vincenz> @localtime goltrpoat
05:40:19 <lambdabot> Local time for goltrpoat is Fri Mar 23 07:38:37 2007
05:40:21 <quicksilver> eulero: some of those languages can be used in a side-effect free fashion if you choose
05:40:36 <ddarius> There is, of course, Clean.  Also Single Assignment C.
05:40:56 <quicksilver> eulero: for example it's fairly common to see programs in ML which are entirely side-effect free, except for a top-level IOful driver function which is only a few lines long
05:40:59 <ddarius> Various pure logic or functional logic languages.
05:41:38 <eulero> quicksilver: I see
05:41:55 <eulero> @localtime dons
05:41:57 <lambdabot> Local time for dons is Fri Mar 23 23:40:21 2007
05:42:07 <eulero> @seen dons
05:42:07 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3h 13m 58s ago.
05:42:32 <dolio> There's Scala, too, which runs on the JVM. But I haven't investigated that enough to know how well it fits.
05:44:00 <eulero> dolio: do you know if Scala uses Monads?
05:44:10 <dolio> I don't know. I sort of doubt it.
05:44:23 <dolio> I suspect it's closer to ML, or Caml.
05:44:36 <dolio> Since it's supposed to be functional/OO hybrid or some such thing.
05:45:03 <eulero> dolio: I see
05:47:19 <ddarius> eulero: Logic languages often combine well with concurrency.
05:47:48 <dolio> Yeah, Oz is logic-ish, no?
05:50:08 <ddarius> Oz is multiparadigm, but contains logic variables and constraint programming.
05:50:46 <edwardk> @seen dpiponi
05:50:46 <lambdabot> I saw dpiponi leaving #haskell 11h 4m 9s ago, and .
05:51:19 <therp> there is no Y combinator like stuff in the Prelude right?
05:51:27 <ddarius> @index fix
05:51:27 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
05:51:37 <quicksilver> I thought fix was in the prelude
05:51:44 <ddarius> @index head
05:51:44 <lambdabot> Data.List, Prelude
05:51:58 <dolio> Nah, it's in Control.Monad.Fix.
05:52:02 <therp> me too, but it's not.
05:52:09 <quicksilver> I wuz wrong :)
05:52:27 <therp> but hmm, actually that's ok too. I just changed my mind about the "in Prelude" part :)
05:52:44 <dolio> That throws me off when I got to ghci.
05:53:07 <dolio> Since lambdabot spoils me by automatically importing all sorts of useful modules.
05:53:15 <quicksilver> bad lambdabot
06:00:35 <chessguy_work> @seen dpiponi
06:00:36 <lambdabot> I saw dpiponi leaving #haskell 11h 13m 58s ago, and .
06:01:39 <ivanm> hey everyone
06:02:02 <ivanm> with all the sudoku solvers on the wiki, does anyone know which one(s) would be the fastest?
06:05:33 <dolio> At a guess, I'd say "Very Smart, with only a little guessing."
06:06:36 <chessguy_work> ivanm, i think some testing would be required :)
06:06:54 <ivanm> chessguy_work: obviously ;-)
06:07:04 <ivanm> but I was hoping someone had already done so
06:07:10 <chessguy_work> hey, ask an obvious question, get an obvious answer
06:07:27 <ivanm> as most entries there are in terms of fancy/small algorithms, and dont mention speed
06:08:25 <dolio> Cale's (the first one) might be the fastest of the backtracking type, though, since he went through the trouble of writing a CPS backtracking monad.
06:08:39 <chessguy_work> what's the link?
06:08:47 <dolio> http://haskell.org/haskellwiki/Sudoku
06:08:48 <lambdabot> Title: Sudoku - HaskellWiki
06:09:36 <chessguy_work> 11 says it can solve any sudoku in an instnat
06:09:38 <chessguy_work> *instant
06:10:09 <ivanm> chessguy_work: you mean birds?
06:10:34 <ivanm> its good for a single solution... but it does a lot of transposition, which takes up run-time
06:10:36 <chessguy_work> yup
06:10:43 <dolio> "Very Smar, with only a little guessing" solves 9.4 problems per second. :)
06:11:05 <ivanm> an interesting test would be to feed each solver a blank grid and see how long it takes to generate all solutions...
06:11:16 <ivanm> of course, we'd be waiting for a few years for each one ;-)
06:11:35 <dolio> Several won't give all solutions, I suspect.
06:11:43 <chessguy_work> and some aren't design to generate all solutions...
06:11:47 <chessguy_work> yeah, what dolio said
06:11:57 <ivanm> bird's does, I know that...
06:12:11 <ivanm> but it basically generates a solution tree...
06:12:30 <ivanm> I based a program of my own off birds because it was easier to understand than anyone elses ;-)
06:12:53 <dons> um. totally wow: http://dis.um.es/~alberto/GSLHaskell/
06:12:59 <lambdabot> Title: GSLHaskell
06:13:05 * ivanm is trying to go through Chris' Dancing Links code... its hard going
06:13:37 <triplah_> dons: nice
06:13:38 <ivanm> btw, what does the @ notation in pattern matching mean? assign the input to a variable, as well as the pattern matches?
06:13:48 <dons> ivanm: it names the  bit that it matches, yeah
06:13:55 <triplah_> hmm lapack
06:13:57 <triplah_> awesome
06:14:01 <triplah_> i wonder if it does svd
06:14:10 <edwardk> trip: it does
06:14:11 <ivanm> dons: was just looking at that site the other day... thats the kind of stuff I'm thinking of doing my honours thesis on possibly
06:14:13 <dons> > let f a@(_:_) = a ; f _ = [] in f (1:2:[])
06:14:14 <lambdabot>  [1,2]
06:14:25 <triplah_> edwardk: cool thanks
06:14:59 <ivanm> dons thanks, that's what I thought, just wanted to check
06:18:47 <chessguy_work> ?src transpose
06:18:48 <lambdabot> transpose []             = []
06:18:48 <lambdabot> transpose ([]   : xss)   = transpose xss
06:18:48 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
06:19:38 <ivanm> chessguy_work: I ended up getting the old, pre-lazy definition and using that instead
06:19:50 <ivanm> it was a bit faster for finite lists of lists
06:20:02 <ekidd> Morning.
06:21:02 <ekidd> @tell ddarius It looks like I should probably figure out universals, too.
06:21:02 <lambdabot> Consider it noted.
06:21:13 <ivanm> morning, ekidd
06:21:19 <ivanm> evening, rather ;-)
06:21:57 <ekidd> ivanm: My blogging has slowed to a crawl while I try to digest more category theory. :-)
06:22:05 <ivanm> lol
06:22:14 <chessguy_work> more writing, less thinking!
06:22:15 * ivanm should probably learn some category theory
06:22:38 <ivanm> I was doing a summer project (for which I learnt haskell), and another guy there was learning category theory
06:22:53 <ivanm> but when I asked him about monads, it was too far ahead of him in the book, so he had no clue ;-)
06:24:10 <ivanm> @hoogle mdo
06:24:10 <lambdabot> No matches found
06:24:24 <dolio> mdo is a variation on do notation.
06:24:25 <vincenz> > 372-148
06:24:26 <lambdabot>  224
06:24:31 <vincenz> 224 line function
06:24:40 <ivanm> dolio: a variant in which sense?
06:24:58 <ivanm> vincenz: lambdabot is your calculator, is she? ;-)
06:25:01 <chessguy_work> vincenz, 372-148 = time to refactor
06:25:02 <vincenz> ivanm: yah
06:25:08 <dolio> Where you can do, for instance "x <- f x" and get a proper answer, even if x isn't previously defined.
06:25:29 <dolio> Provided f is appropriate.
06:25:38 <vincenz> and so far not a single bug
06:25:41 <chessguy_work> dolio, is that H98?
06:25:43 <ekidd> ivanm: Google "MonadFix" to for more information on mdo.
06:25:52 <ivanm> ahhh.... getting rid of the "f (x:x:y) = blah" restraint kinda?
06:25:58 <ivanm> @google monadfix
06:26:00 <lambdabot> http://www.cis.upenn.edu/~bcpierce/courses/advprog/resources/base/Control.Monad.Fix.html
06:26:02 <dolio> chessguy_work: I suspect it needs -fglasgow-exts.
06:26:07 * ekidd heads to work
06:26:15 <ivanm> have fun! :p
06:26:37 <quicksilver> the syntactic sugar is not H98
06:26:52 <quicksilver> the underlying idea of mfix is H98 AFAICR
06:27:04 <quicksilver> but using it explicitly obviously is going to be uglier :)
06:27:09 <ivanm> lol
06:27:33 <ivanm> so its a simpler and more obvious way of defining a fixed point of a calculation?
06:28:01 <dolio> It's the monadic equivalent of "let x = f x in ..."
06:28:18 <ndm> ping malcolmw
06:28:21 <ndm> @seen malcolmw
06:28:21 <lambdabot> malcolmw is in #ghc, #haskell-overflow, #haskell-blah and #haskell. I don't know when malcolmw last spoke.
06:28:30 <ivanm> dolio: that let statement is legal haskell?
06:28:30 <malcolmw> ndm: pong
06:28:48 <opqdonut> ?src fix
06:28:48 <lambdabot> fix f = let x = f x in x
06:28:56 <opqdonut> ?src mfix
06:28:56 <lambdabot> Source not found. You speak an infinite deal of nothing
06:28:59 <ndm> malcolmw: how do i install filepath on the uni system?
06:29:00 <quicksilver> ivanm: yup
06:29:06 <dolio> ivanm: Well, mdo isn't Haskell98, I think. But mfix is legal.
06:29:10 <ndm> malcolmw: i.e. runhaskell Setup configure --prefix= ... ?
06:29:23 <ivanm> @hoogle mfix
06:29:24 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
06:29:24 <malcolmw> ndm: --prefix=/grp/haskell I suppose
06:29:36 <opqdonut> ?src Control.Monad.Fix.mfix
06:29:36 <lambdabot> Source not found. stty: unknown mode: doofus
06:29:40 <dolio> I don't have any good mfix examples, though.
06:29:44 <ivanm> so is mdo == mfix, or something else entirely?
06:30:03 <malcolmw> ndm: (I'm assuming that Cabal will add $prefix/include and $prefix/man etc as appropriate)
06:30:05 <ndm> malcolmw: Unable to rename "/grp/haskell/lib/ghc-6.6/package.conf" to "/grp/haskell/lib/ghc-6.6/package.conf.old"
06:30:05 <quicksilver> mdo is sugar for mfix
06:30:18 <dolio> mdo {X} gets desugared into mfix (Y) (or something like that) somehow.
06:30:19 <quicksilver> it lets you write 'do-blocks' which automatically fix
06:30:23 <ndm> malcolmw: can you give me permission
06:30:27 <malcolmw> ndm: hmm, maybe the permissions are wrong
06:30:31 <ivanm> the way I saw fix define was something like "fix f x = if (x == x') then x else fix f x' where x' = f x"
06:30:48 <ivanm> quicksilver: k
06:30:55 <quicksilver> much like 'all haskell declarations' are sugar for 'fix'  :)
06:31:12 <mux> fix = let x = f x in x
06:31:17 <quicksilver> ivanm: that's fix rotated through about 90-degrees about the axis of your screen
06:31:17 <dolio> That's a different fix. For numerical computations or something.
06:31:18 <mux> (that's what I read somewhere)
06:31:23 <dolio> ivanm's, that is.
06:31:36 <malcolmw> ndm: done
06:31:53 <ndm> malcolmw: success, thanks
06:32:09 <ivanm> quicksilver: "rotated about 90 degrees"?
06:32:17 <ivanm> dolio: how is it any different?
06:32:30 <opqdonut> isn't that just a fix that terminates
06:32:35 <quicksilver> ivanm: taking a fixed point does indeed mean 'find a value which doesn't change'
06:32:49 <opqdonut> that is, actually a fix of a function f modified so that f x' = x'
06:32:52 <quicksilver> ivanm: however the 'fixed point' taken by 'fix' is not a fixed point which can be tested for by Eq
06:32:58 <quicksilver> ivanm: since functions are not members of Eq
06:33:07 <ivanm> ahhh, k
06:33:16 <quicksilver> ivanm: the 'fixed point' taken by fix is tested for in the world of 'domains'
06:33:27 * ivanm didn't realise you _could_ do something like let x = f x
06:33:31 <quicksilver> which are partially-ordered sets which underly the semantics of functional languages
06:33:53 <ivanm> *shrug* that's just how I saw it defined in birds sudoku solver
06:33:56 * quicksilver nods
06:34:00 <quicksilver> it is 'a fix'
06:34:04 <quicksilver> but it's not 'this fix' :)
06:34:04 <ivanm> which is the only place I'd seen it before
06:34:07 <ivanm> lol
06:34:11 <dolio> :)
06:34:19 <ivanm> so birds one is specific to Eq, whilst this one is general?
06:34:22 <quicksilver> yes
06:34:31 <ivanm> how does the x = f x know when to stop?
06:34:33 * chessguy_work gets his fix by fixing fix
06:34:36 <quicksilver> ivanm: it doesn't
06:34:40 <quicksilver> ivanm: sometimes, it doesn't stop
06:34:47 <opqdonut> ?fix \x -> x+1
06:34:47 <lambdabot> Maybe you meant: faq ft id
06:34:53 <opqdonut> >fix \x -> x+1
06:34:53 <ivanm> so your program hangs?
06:34:53 <quicksilver> > let x = (x+1) in x
06:34:54 <lambdabot>  Exception: <<loop>>
06:34:58 <quicksilver> ivanm: right :)
06:35:03 <opqdonut> >fix \x -> x^2
06:35:14 <uccus> > fix (\x -> x+1)
06:35:14 <opqdonut> like so
06:35:16 <lambdabot>  Exception: <<loop>>
06:35:16 <ivanm> I know it won't always work... but in the cases it does, how does it know its found a fixed point?
06:35:22 <quicksilver> it doesn't, actually
06:35:22 <uccus> > fix (\x -> x+1)
06:35:24 <ivanm> > fix \x -> x^2
06:35:24 <lambdabot>  Exception: <<loop>>
06:35:24 <lambdabot>  Parse error
06:35:25 <quicksilver> it's a bit subtle :)
06:35:27 <quicksilver> it just happens
06:35:31 <quicksilver> there is nothing more to evaluate
06:35:31 <ivanm> > fix (\x -> x^2)
06:35:32 <lambdabot>  Exception: <<loop>>
06:35:43 <quicksilver> in practice, haskell 'calculates' fixed points by the algorithm of recursion
06:35:52 <quicksilver> (just as you use recursion in an imperative language)
06:35:56 <ivanm> @type fix
06:35:58 <lambdabot> forall a. (a -> a) -> a
06:36:06 <mux> quicksilver: I really wish I could understand that -- "it just happens" :-)
06:36:07 <quicksilver> recursion has the property that, if there is a fixed point, it will find the least
06:36:19 <quicksilver> if there is no (finite) fixed point, then recursion diverges
06:36:21 <ivanm> so why doesn't the one I passed in work? (solution is x = 0,1)
06:36:59 <quicksilver> because 'fix' isn't calculating fixed points over numbers
06:37:07 <quicksilver> (which requires a different algorithm)
06:37:13 <quicksilver> it's calculating fixed points over functions
06:37:18 <quicksilver> (for which recursion is the algorithm)
06:37:22 <ivanm> ahhh
06:37:31 <ivanm> so what's an example that actually works? ;-)
06:37:52 <quicksilver> > let fact 0 = 1; fact n = n * (fact (n-1)) in fact 4
06:37:53 <lambdabot>  24
06:37:58 <chessguy_work> > 3^1000
06:37:59 <lambdabot>  1322070819480806636890455259752144365965422032752148167664920368226828597346...
06:38:20 <chessguy_work> > drop 50 $ show $ 3^1000
06:38:21 <lambdabot>  "481676649203682268285973467048995407783138506080619639097776968725823559509...
06:38:34 <chessguy_work> > drop 100 $ show $ 3^1000
06:38:35 <lambdabot>  "963909777696872582355950954582100618911865342725257953674027620225198320803...
06:38:48 <quicksilver> > (fix \fact -> \n -> case n of {0 -> 1; n -> n * (fact (n-1))}) $ 4
06:38:48 <lambdabot>  Parse error
06:38:55 * chessguy_work takes it to /msg's
06:38:56 <pjd_> is show for big integers lazy?
06:39:15 <dolio> > let fact = \f -> return $ \n -> if n == 0 then return 1 else (*n) `liftM` f (n - 1) in mfix fact >>= \g -> g 5 -- ugly deluxe
06:39:16 <lambdabot>   add an instance declaration for (Show (m a))
06:39:28 <dolio> > let fact = \f -> return $ \n -> if n == 0 then return 1 else (*n) `liftM` f (n - 1) in mfix fact >>= \g -> g 5 :: [Int] -- ugly deluxe
06:39:28 <ivanm> lol
06:39:29 <lambdabot>  [120]
06:39:33 <sieni> > 1000 * log 3 / log 10
06:39:34 <lambdabot>  477.12125471966243
06:39:49 <sieni> > drop 450 $ show $ 3^1000
06:39:52 <lambdabot>  "4366132173102768902855220001"
06:40:03 <quicksilver> A[A[B[A           
06:40:03 <ivanm> quicksilver: I asked for a _working_ example ;-)
06:40:12 <quicksilver> > (fix $ \fact -> \n -> case n of {0 -> 1; n -> n * (fact (n-1))}) $ 4
06:40:14 <lambdabot>  24
06:40:16 <quicksilver> ivanm: there you go
06:40:31 <quicksilver> ivanm: can you see the connection between that and the 'standard' definition I gave earlier?
06:40:39 <ivanm> the $?
06:40:48 <quicksilver> > let fact 0 = 1; fact n = n * (fact (n-1)) in fact 4
06:40:49 <lambdabot>  24
06:40:56 <ivanm> so the function has to be evaluated before fix works?
06:41:03 <ivanm> oh, you meant that standard definition
06:41:32 <ivanm> that's a pretty crap way of defining factorials... (using fix, I mean)
06:41:36 <quicksilver> fix takes a function (\fact -> ...). That function I gave it takes a 'poor approximation' to fact, and turns it into a 'better' approximation of fact
06:41:50 <ivanm> so how is it different in general from explicit recursion?
06:41:53 <quicksilver> each time you run your function through that function
06:41:56 <quicksilver> ivanm: in no way
06:42:08 <quicksilver> ivanm: fix *is* explicit recursion, there is no difference
06:42:18 <quicksilver> ivanm: it just externalises it into the language so we can talk abotu it
06:42:27 <quicksilver> > fix (1:)
06:42:28 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:42:32 <dolio> ivanm: The difference is that your language doesn't need to explicitly support recursive definitions.
06:42:36 <ivanm> but your lambda expression has explicit recursion anyway...
06:42:41 <ivanm> dolio: ahhh, k
06:42:51 <quicksilver> in the lambda expression, there is no recursion
06:42:52 <dolio> ivanm: It can just support lambda expressions, and give you fix, and you can do everything.
06:42:56 <ivanm> quicksilver: OK, I see that
06:42:57 <quicksilver> 'using your parameter' is not recursion
06:43:03 <ivanm> it just tells haskell to recurse, right?
06:43:13 <quicksilver> @src fix
06:43:13 <lambdabot> fix f = let x = f x in x
06:43:22 <quicksilver> fix is the 'universal recursive function'
06:43:28 <dolio> Or, in the untyped lambda calculus, you can defined fix in terms of just lambda expressions, so no recursion primitives are needed.
06:44:26 <ivanm> quicksilver: so in the fact exapmle, it stopped recursing because the lambda expression didn't recurse anymore?
06:44:37 <ivanm> i.e. didn't return another lambda?
06:44:53 <ivanm> dolio: what would that form look like?
06:45:05 <dolio> Humm, it's something like...
06:45:21 <quicksilver> ivanm: yes, that's true
06:45:32 <quicksilver> ivanm: although you shouldn't say 'the lambda expression didn't recurse any more'
06:45:39 <dolio> Y = (\f -> \x -> f (x x)) (\f -> \x -> f (x x))
06:45:40 <quicksilver> ivanm: because the lambda expression isn't recursive :)
06:45:58 <dolio> But "x x" doesn't type in haskell, so you can't do it that way.
06:46:17 <dolio> Actually, that's wrong, I think.
06:46:44 <dolio> Y = \f -> (\x -> f (x x)) (\x -> f (x x)) -- I think that's right.
06:46:44 <ivanm> lol
06:46:52 <ivanm> Y == fix?
06:46:56 <dolio> Right.
06:47:35 <ivanm> how is the \f (...) (...) read?
06:47:44 <ivanm> first bit is variables, second bit is how they're used?
06:49:08 <dolio> Y g ==> (\f -> (\x -> f (x x)) (\x -> f (x x))) g ==> (\x -> g (x x)) (\x -> g (x x)) ==> g ((\x -> g (x x)) (\x -> g (x x)) ==> g (Y g)
06:49:15 <scriptdevil> hey... what do i do if Char.toUpper isnt in scope???
06:50:14 <scriptdevil> it works off prelude... but when i load a file... it doesnt work
06:50:14 <dolio> Yeah '\f -> e' is a lambda expression.
06:50:15 <ivanm> scriptdevil: import Char?
06:50:38 <ivanm> dolio: g is the parameter for f?
06:51:41 <dolio> And '(\f -> e) x' gets reduced to 'e[x]', where e[x] is the result of replacing the fs in e with xs (roughly).
06:51:44 <scriptdevil> ivanm thanks..
06:51:55 <ivanm> *nod*
06:51:59 <scriptdevil> actually i did a require Char... :( ruby...
06:52:15 <dolio> Or, you could think of it as '\f -> e' is a function with argument 'f' and body 'e'.
06:52:23 <ivanm> dolio: how did this bit get reduced down: (\x -> g (x x)) (\x -> g (x x)) ==> g ((\x -> g (x x)) (\x -> g (x x))
06:52:26 <dolio> Which works as normal.
06:52:38 <dolio> Oh, that's the tricky bit.
06:52:55 <dolio> That's an application of '(\x -> g (x x))' to the same thing.
06:53:07 <dolio> So you replace all xs in the first one with '(\x -> g (x x))'
06:53:10 <EvilTerran> fix only really works with lazy evaluation (or human intervention), right?
06:53:26 <dolio> Which turns into the same expression, only with g applied.
06:53:35 <norpan> EvilTerran: not if there is a fixpoint
06:53:48 <EvilTerran> eh, true.
06:53:57 <EvilTerran> > fix (const "ebbeteh!")
06:53:58 <lambdabot>  "ebbeteh!"
06:54:10 <dolio> So, essentially, it constructs g (g (g (g (...))))
06:54:40 <ivanm> dolio: OK, I think I get it now...
06:55:07 <EvilTerran> and (const x) doesn't use its parameter, so it works
06:55:29 <ivanm> so \f -> (\x -> f (x x)) (blah) ==> \f -> f ((blah) (blah)) ?
06:55:58 <dolio> Yes.
06:57:34 <pjd_> EvilTerran: you get formulations of it that work with eager evaluation too
06:57:57 <ivanm> dolio: yeah, didn't think about function application for the \x function
06:58:26 * ivanm should probably learn lambda calculus... once he's finished with monads, category theory, and a whole bunch of other stuff ;-)
06:58:56 <dolio> EvilTerran: I believe the difference between lazy and strict evaluation with regard to fix is that in a lazy language, you can fixed-point values (fix :: (a -> a) -> a), whereas in a strict language, you can only find fixed-point functions (fix :: ((a -> b) -> a -> b) -> a -> b)
06:58:58 <ivanm> thingsToDo = oldThingsToDo ++ [lambda calculus]
06:59:01 <dolio> At least, I think I read that somewhere.
06:59:10 <kzm> How do I specify URLs to haddock?
07:00:32 <EvilTerran> dolio, that's an interesting thought. i'll look into that sometime.
07:00:34 <pejo> ivanm, I'd say lambda calculus is easier than ct, and probably more  useful as well in case you happen to study anything else that's pl-related.
07:00:49 <ivanm> true...
07:01:08 <ivanm> pl == programming?
07:01:16 <dolio> EvilTerran: I suppose it's easily seen by what people do with haskell.
07:01:21 <Saizan> and it's very useful to understand those (r (->)) monad tricks
07:01:47 <dolio> EvilTerran: 'ones = 1 : ones' is commonplace in Haskell tutorials, but you can't do such a thing (so easily) in, say, Scheme.
07:02:52 <dolio> But the Y combinator for functions works fine in scheme.
07:03:12 <dolio> And you can define recursive functions.
07:03:29 <EvilTerran> scheme isn't lazy...
07:03:48 <dolio> Right. Hence why you can't define recursive values.
07:03:55 <EvilTerran> quite.
07:04:03 <pjd_> no, you can
07:04:06 <dolio> (Unless the values do laziness themselves)
07:04:32 <EvilTerran> i can't remember, is it the (delay ...) macro in scheme?
07:04:40 <pjd_> right
07:05:00 <pjd_> and streams
07:05:02 <EvilTerran> but you have to manually un-lazy it with (force) when you want to use it, right?
07:05:04 <pejo> dolio, one could take a language that had variables included in the values - and form a circular structure that way.
07:05:53 <pjd_> EvilTerran: implementations are permitted to force the values implicitly
07:06:03 * EvilTerran notes that it's possible to do lazy structures implicitly in perl with tie()
07:06:27 <dolio> pejo: Hmm, what do you mean "variables included in the values"?
07:06:45 <pjd_> you can also do the forcing as an implicit part of other code, like stream implementations usually do
07:06:47 <JPMoresmau> Hello everybody, is there a way to implement Eq functions (==) so that it returns true only for the exact same instance. I want to put objects in the map that have no identity as such. Does that mean anything in Haskell?.
07:07:48 <EvilTerran> JPMoresmau, that doesn't really make sense in Haskell.
07:07:53 <pejo> dolio, for the language semantics, define values along the lines of v ::= n | C v | \x.e | x, where x is variables.
07:08:19 <EvilTerran> let f x = x in f y -- are x and y the same instance?
07:08:51 <dino-> JPMoresmau: At the risk of being confusing, there isn't really the concept of instantiating something a-la OO. As far as I understand it.
07:09:21 <EvilTerran> let apply f x = f x in apply f y -- what about now? what if f = id?
07:09:22 <dolio> pejo: Oh, I think I see.
07:09:43 <pejo> dolio, I think Leroy has a paper about circular structures for ocaml.
07:09:44 <EvilTerran> wait, that's not quite right. i think you can figure what i was trying to do, anyway.
07:10:00 <JPMoresmau> EvilTerran, yes
07:11:36 <EvilTerran> i think the probllem  is that the haskell mindset (indeed, the purely functional mindset) relies on considering values purely as _values_, not as variables/constants with distinct slots in memory or whatever
07:12:05 <JPMoresmau> yes, I understand
07:12:10 <EvilTerran> okay. :)
07:12:28 <JPMoresmau> I have the feeling I'm taking my problem in totally the wrong way for Haskell
07:12:34 <ski> dolio : in strict languages, one usually has an implicit 'fix' over records of functions, as well
07:12:51 <EvilTerran> JPMoresmau, what are you trying to do? can you explain it easily?
07:12:52 <ski> (hence some strange things with 'letrec' in Scheme)
07:13:31 <pjd_> (letrec in Scheme?)
07:13:47 <JPMoresmau> I'm trying to do someting too complex for my Haskell skills (-: I'm trying to transform a graph into another one
07:13:58 <beelsebob> JPMoresmau: why is this complex?
07:14:03 <beelsebob> are you trying to maintain sharing?
07:14:05 <ski> JPMoresmau : you can use 'IORef MyType', those will be compared by identity of the reference cell .. maybe that does what you want
07:14:30 <ski> pjd_ : how do you implement 'letrec' ?
07:14:48 <pjd_> ski: i mean, what strange things are you referring to?
07:14:50 <beelsebob> JPMoresmau: what is your graph representation?
07:14:56 <ski> pjd_ : also, some such implementations, in conjunction with 'call/cc' allows one to define 'set-box!'
07:15:18 <JPMoresmau> beelsebob, I'm struggling with following edges in my graph
07:15:36 <beelsebob> JPMoresmau: okay, what representation are you using?
07:15:41 <JPMoresmau> I need in several places to find the new node from the old node, and not knowing how to identify node
07:15:53 <JPMoresmau> I have Types that have lists of children
07:16:02 <beelsebob> okay
07:16:08 <quicksilver> I think you're going to need to give your nodes unique names
07:16:11 <quicksilver> you can make them up
07:16:17 <ski> pjd_ : well, the first implementation that comes to mind uses intialization with some dummy, and then assigning the proper values .. but why should something as "functional" as mutually recursive functions need (re-)assignment ?
07:16:17 <quicksilver> (i.e. they can be artificial names)
07:16:23 <quicksilver> and you need never show them to the user
07:16:30 <quicksilver> but I think the algorithm needs them temporarily
07:16:39 <beelsebob> JPMoresmau: well, I'd suggest that that's not a briliant representation for a graph in haskell, because you will quickly lose sharing
07:17:02 <beelsebob> JPMoresmau: instead, I'd suggest you have a node data structure, and an edge data structure
07:17:38 <beelsebob> the node data structure should contain a tag to uniquely identify the node, and it's contents
07:17:49 <beelsebob> the edge data structure should contain two unique node names
07:18:24 <EvilTerran> Data.Graph?
07:18:39 <beelsebob> also possibly a good solution -- I've never looked at that
07:19:02 <EvilTerran> a graph is represented by [(node, key, [key])]
07:19:23 <beelsebob> sounds sensible
07:19:38 <EvilTerran> that's (<label>, <tag>, <tags this node has edges to>) as a representation of a node
07:19:44 <JPMoresmau> ok, seems reasonable
07:20:05 <ndm> @seen glguy
07:20:05 <lambdabot> glguy is in #happs and #haskell. I last heard glguy speak 17h 28m 44s ago.
07:20:26 <JPMoresmau> but if I want my API to hide the labels and just use objects
07:21:06 <JPMoresmau> ok I'll look into a better graph representation
07:21:53 <EvilTerran> well, that's the input to Data.Graph. i presume it does something else under the hood
07:22:09 <beelsebob> yeh, it appears to store it in an Array rather than a []
07:22:22 <ski> (pjd_ : ok ?)
07:22:27 <rjeq> is there a builtin that will search an ordered list?
07:22:45 <rjeq> (for a given element)
07:22:52 <Saizan> ?type find
07:22:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:22:58 <quicksilver> rjeq: not specifically ordered, no
07:23:11 <EvilTerran> I'd be inclined, if i were implementing graph algos myself, to use an array (...) [(<key>,(<data>,[<neighbour>]))]
07:23:29 <Saizan> well, in a list the fact that it's ordered is of little help
07:23:34 <rjeq> quicksilver: ok, thanks
07:23:44 <rjeq> quicksilver: seems strange, given that 'insert' was included
07:23:58 <Saizan> it helps termination if the search fail
07:24:04 <EvilTerran> rjeq, binary search doesn't really work with lists because finding the middle element is a O(n) operation
07:24:42 <JPMoresmau> EvilTerran, beelsebob, quicksilver et al thanks I have ideas on how to continue
07:24:42 <flux-> evilterran, well, it could potentially return 'not found' earlier, but I agree that it'd be of limited use
07:24:48 <beelsebob> JPMoresmau: np
07:25:27 <vincenz> we need haskell in here: http://clintonforbes.blogspot.com/2007/03/what-does-hot-girl-at-party-think-of.html
07:25:30 <lambdabot> Title: The rantings of Clinton Forbes: What does the hot girl at the party think of you ..., http://tinyurl.com/2ack2m
07:25:33 <EvilTerran> yes, in the case of a sorted list you could return sooner, but you'd still be doing a linear search
07:25:57 <quicksilver> rjeq: well, there isn't an efficient way to do it :)
07:29:19 <shapr> malcolmw: Hey, why not use http://www.cs.ru.nl/A.vanWeelden/bi-arrows/ for XmlContent ?
07:29:20 <lambdabot> Title: There and Back Again: Arrows for Invertible Programming
07:29:37 <shapr> malcolmw: Then you may not need separate definitions for toContents and parseContents
07:29:52 <chessguy_work> ?where soc
07:29:52 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
07:30:01 <vincenz> 235 lines and only 5 undefines left
07:30:01 <malcolmw> shapr: looking now...
07:30:01 <vincenz> \o/
07:30:35 <chessguy_work> Artificial Intelligence: A Modern Approach	
07:30:35 <chessguy_work> 	
07:30:35 <chessguy_work> Table of Contents for AI: A Modern Approach
07:30:35 <chessguy_work> Part I: Artificial Intelligence
07:30:35 <chessguy_work> 1. Introduction ... 1
07:30:36 <chessguy_work> 1.1. What is AI? ... 1
07:30:37 <chessguy_work>        Acting humanly: The Turing Test approach ... 2
07:30:39 <chessguy_work>        Thinking humanly: The cognitive modeling approach ... 3
07:30:42 <chessguy_work>        Thinking rationally: The ``laws of thought'' approach ... 4
07:30:43 <chessguy_work>        Acting rationally: The rational agent approach ... 4
07:30:45 <chessguy_work> crap
07:30:48 <chessguy_work> i hate this client
07:30:51 <chessguy_work> sorry
07:31:23 <ski> @yow
07:31:24 <lambdabot> PEGGY FLEMMING is stealing BASKET BALLS to feed the babies in VERMONT.
07:31:25 <dolio> :) I have that book.
07:31:29 <malcolmw> shapr: hey, I've been suggesting a unified parser/pretty-printer as a student project for years now.  Someone has finally done it elsewhere.
07:31:37 <chessguy_work> dolio, i bought it. should be here any day now
07:31:38 <shapr> malcolmw: oh?
07:31:52 <malcolmw> shapr: that paper you pointed me to
07:31:57 <shapr> ah!
07:32:09 <ski> which paper ?
07:32:31 <malcolmw> shapr: one grammar defn (in combinator style) can be used bi-directionally to either parse or print.
07:32:53 <shapr> Anyway, Lemmih and I just looked at XmlContent, and it just collects the parseContents and toContents into one place rather than unifying the code, so I thought I'd suggest bidirectional arrows as a way to write the code only once.
07:33:02 <shapr> ski: http://www.cs.ru.nl/A.vanWeelden/bi-arrows/
07:33:03 <lambdabot> Title: There and Back Again: Arrows for Invertible Programming
07:33:16 <shapr> chessguy_work: Hey, did you get that job?
07:33:23 <malcolmw> shapr: it would sure be nice to write the code only once
07:33:29 <jacobian> I've been meaning to read that bi-arrows paper
07:33:45 <shapr> jacobian: It's worth it!
07:33:51 <ski> malcolmw : and left-recursion ?
07:34:04 <ski> shapr : vielen danke schn
07:34:08 <chessguy_work> shapr, not this time around :(
07:34:09 <jacobian> malcolmw: My thoughts exactly!
07:34:10 <malcolmw> shapr: cool, they have a ghc version of the code, as well as in Clean
07:34:21 <shapr> chessguy_work: aww :-(
07:34:30 <chessguy_work> they really liked me, but there was another applicant with more relevant experience, and they couldn't afford to hire us both (they wanted to)
07:34:37 <shapr> Too bad
07:34:44 <chessguy_work> but they're going to keep me on their short list for next time they're hiring
07:36:49 <vincenz> > let (>-) x y = y in  5 >- 5
07:36:51 <lambdabot>  5
07:37:04 <vincenz> > let (|-|) x y = y in  5 >- 5
07:37:05 <lambdabot>   Not in scope: `>-'
07:37:06 <shapr> btw, that bidirectional arrows paper is also available from the authors' homepage or something.
07:37:08 <vincenz> > let (|-|) x y = y in  5 |-| 5
07:37:10 <lambdabot>  5
07:37:21 <vincenz> > let (|^|) x y = y in  5 |^| 5
07:37:22 <lambdabot>  5
07:37:54 <vincenz> > let (>-<) x y = y in  5 >-< 5
07:37:55 <lambdabot>  5
07:38:20 <ski> (the start of that source code looks similar to my experiments with the idea :)
07:38:52 <resiak> vincenz: these are all useful synonyms for flip const!
07:39:09 <shapr> ski: I have a copy of the PDF if you want one.
07:39:17 <malcolmw> shapr: unlike HaXml, the HXT stuff is already based on arrows, so i wonder if the bi-arrows might fit more readily into that.  HaXml is still in the old-fashioned monadic world. :-)
07:39:38 <ski> shapr : ah .. didn't notice it was locked into ACM .. yes, i'd like, ty
07:41:36 <shapr> ski: Which email address are you using these days?
07:41:50 <vincenz> resiak: I was testing names
07:42:42 <resiak> vincenz: heh, I figured :)
07:43:40 <vincenz> so you think
07:49:51 <vincenz> dons: ping
07:49:58 <vincenz> @localtime dons
07:50:01 <lambdabot> Local time for dons is Sat Mar 24 01:48:24 2007
07:50:03 <vincenz> damn
07:50:08 <kolmodin> vincenz: good luck :)
07:50:30 <kolmodin> @seen dons
07:50:30 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1h 36m 17s ago.
07:50:45 <vincenz> just wonered about
07:50:45 <vincenz> 15:41 -!- returnofheiaai [n=reef@60-241-252-87.static.tpgi.com.au] has joined  #oasis
07:50:48 <vincenz> 15:41 < returnofheiaai> hi unsw buddies
07:50:57 <vincenz> +d
07:51:46 <vincenz> that was so nonsequitur
07:57:51 <opqdonut> life tends to be
07:58:10 <alexj_> kolmodin: did my email make sense?
07:58:23 <kolmodin> alexj_: did my reply make sense?
07:58:37 <vincenz> does this conversation make sense?
07:58:48 <alexj_> oh didn't get reply!  perhaps spam.  hold on.
07:59:14 <alexj_> ah got it.  spam folder.
07:59:17 <kolmodin> hah
07:59:29 <alexj_> my point is that I don't want to have to cabal install everything as an administartor.
07:59:43 <kolmodin> and you don't have to
07:59:53 <kolmodin> install it locally
07:59:55 <alexj_> I like using sp.  if you have sp installed then this should work: $ sp runhaskell --sp HAppS.Protocols.HTTP.FileServer
07:59:59 <mux> alexj_: use the --user flag
08:00:06 <mux> and an appropriate --prefix, of course
08:00:13 <kolmodin> what's sp?
08:00:33 <alexj_> my point is that cabal shouldn't be necessary for this and that haskell that requires special options should say so in the header.
08:00:39 <alexj_> searchpath
08:00:39 <alexj_> sp==searchpath
08:00:58 <kolmodin> alexj_: I usually do this when I want to install locally: configure, build, then register with --user --inplace
08:00:59 <alexj_> http://searchpath.org
08:01:01 <lambdabot> Title: SearchPath
08:01:09 <kolmodin> that way you don't even have to move the files anywhere
08:01:24 <kolmodin> and you just recompile when a new version is out
08:01:32 <kolmodin> (if no modules are present)
08:01:35 <alexj_> with searchpath I don't have to think about it.  if FileServer needs binary then searchpath takes care of downloading it.
08:01:40 <kolmodin> *no new modules
08:02:37 <alexj_> any reason not to put the {-#options -cpp -fglasgow-exts -#} in the files themselves?
08:02:47 <kolmodin> yes, because that's cabals job
08:02:49 <alexj_> then you don't have to go through a cabal step just to used them.
08:03:21 <alexj_> cabal is not hte only build tool out there.
08:03:42 <kolmodin> it's the one we use. it abstracts over all compilers
08:03:49 <alexj_> here is the workflow I owuld like to achieve: 1. you read the HAppS tutorial and write a short happs program call MyProgram.hs
08:04:03 <alexj_> you then do: sp runhaskell MyProgram.hs
08:04:14 <kolmodin> -fglasgow-exts doesn't play nice with other compilers than ghc
08:04:36 <alexj_> and sp takes care of downloading all the modules reuired including happs and data.binary.
08:05:20 <alexj_> does the code work in those other compilers?
08:05:25 <kolmodin> yes
08:05:42 <kolmodin> or it did anyway, I think it still does
08:05:44 <alexj_> does {-# OPTIONS_GHC -fglasgow-exts #-} work in those other compilers?
08:05:53 <kolmodin> no, that would be ignored
08:06:15 <alexj_> so at very least it makes ghc work better.
08:06:23 <alexj_> without hurting operation of the others?
08:06:49 <diffbavis> @type System.Info.os
08:06:52 <lambdabot> String
08:07:02 <diffbavis> shouldn't it be IO String?
08:07:07 <kolmodin> so sp downloads the other modules and does what?
08:07:53 <alexj_> adds them to your file search path and compiles.
08:08:40 <nattfodd> how come I get a system load >5 when compiling e.g. binary?
08:08:41 <alexj_> sp runhaskell MyProject.hs gets translated to runhaskell -i.haskell-cache/mapurl.cache MyProject.hs
08:08:46 <kolmodin> how does it know where the source files of binary is? ie, in which dir?
08:08:47 <nattfodd> can it come from ghc-6.6, maybe?
08:08:59 <alexj_> you can pass map files on the command line.
08:09:09 <alexj_> by default it automatically adds http://searchpath.org/default.map
08:09:24 <kolmodin> so basically you're writing a package management system but just for haskell packages?
08:09:32 <alexj_> or to be precise --internet http://searchpath.org/default.map
08:09:59 <alexj_> I don't think of it as a package management system.   I think of it as a way to map module names to URLs.
08:10:30 <alexj_> It only downloads the modules actually imported by some haskell file that is required.
08:11:04 <EvilTerran> it's kinda a just-in-time package manager?
08:11:17 <kolmodin> so the difference with your system is that you don't have to know which projects your using?
08:11:20 <alexj_> it doesn't really have a concept of packages.
08:11:33 <kolmodin> if I'd like to use binary I'd write 'emerge binary' in gentoo
08:12:12 <alexj_> if you import a module and that module is locatable using one of the maps passed on the command line or by the default map then it will download that module and put it in your localpath for that compile
08:13:09 <alexj_> if that module imports another locatable module, it will proceed recursively.
08:13:41 <kolmodin> ah, so you'd like the specific compiler flags in *all* the source files
08:13:48 <kolmodin> instead in one cabal file?
08:13:52 <alexj_> exactly!
08:14:02 <kolmodin> well then, no :)
08:14:41 <kolmodin> how does your system handle versioning of packages?
08:14:44 <alexj_> in the case of Data.Binary, it is 3 files.
08:14:45 <chessguy_work> woohoo! http://www.haskell.org/haskellwiki/AI
08:14:48 <lambdabot> Title: AI - HaskellWiki
08:15:08 <alexj_> it uses the version available at the URLs in the map.
08:15:27 <alexj_> if you have the URL of a specific version, then it uses that version.
08:16:27 <kolmodin> do you find the OPTION_GHC in many other projects?
08:17:17 <alexj_> {-#OPTIONS is pretty common.
08:17:27 <kolmodin> in projects that doesn't use cabal then
08:17:32 <alexj_> I don't knwo.
08:17:41 <alexj_> or perhaps other projects don't need them.
08:17:56 <vincenz> > let a ?<= b = a in 1 ?<= 2
08:17:57 <lambdabot>  1
08:18:05 <vincenz> > let a =<? b = a in 1 ?<= 2
08:18:06 <lambdabot>   Not in scope: `?<='
08:18:06 <alexj_> as a matter of style, I think it makes sense to have the file itself identify what compiler features it required.
08:18:12 <vincenz> > let a =<? b = a in 1 =<? 2
08:18:13 <lambdabot>  1
08:18:18 <kolmodin> the thing is that it gives extra overhead in maintanance and package distribution
08:18:23 <alexj_> putting it in cabal means that it is harder to reuse files.
08:18:40 <alexj_> what is the overhead?
08:18:46 <kolmodin> and it's easier to maintain if the compiler flags are stored in a cabal file
08:19:12 <kolmodin> we don't distribute a bunch of file, we distribute a project
08:19:22 <kolmodin> *files
08:19:46 <alexj_> a haskell file should have meaning on its own.
08:19:59 <alexj_> your "project" is just a set of files.
08:20:25 <kolmodin> you'd have to change all files in order to change a flag. this gives more work when a flag changes, and more work for packagers when a new version is released
08:20:25 <alexj_> what I do right now is: sp runghc -fglasgow-exts -cpp MyProject.hs
08:20:46 <alexj_> how often do flags change?
08:21:13 <kolmodin> alexj_: it's a darcs repos, look at the distory of the cabal file, it has changed quite often!
08:21:14 <alexj_> if flags are changing the function they affect is also probably changing so you have to look at the file anyway.
08:21:51 <alexj_> what is the uRL of the repo again?
08:21:58 <alexj_> @where data.binary
08:21:59 <lambdabot> I know nothing about data.binary.
08:22:13 <alexj_> @where Binary
08:22:13 <lambdabot> http://darcs.haskell.org/binary
08:22:14 <kolmodin> http://darcs.haskell.org/binary I think
08:22:16 <lambdabot> Title: Index of /binary
08:22:47 <alexj_> did the compiler flags change or your need for them?
08:23:18 <alexj_> (downloading the repo right now)  note that using sp is much faster than darcs get followed by cabal install.
08:23:55 <alexj_> with sp, the user isn't even aware that Binary is being used.
08:24:20 <alexj_> all the required activity is handled automatically in teh background.
08:25:16 <vincenz> @hoogle unless
08:25:17 <lambdabot> Monad.unless :: Monad a => Bool -> a () -> a ()
08:25:17 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
08:25:17 <lambdabot> System.Win32.Types.failUnlessSuccess :: String -> IO ErrCode -> IO ()
08:26:13 <alexj_> in darcs, how do i look at the changes of one particular file rather than the entire repo?
08:26:27 <kolmodin> darcs changes binary.cabal
08:27:13 <alexj_> yeah did that.  added -v so I could see the actual changes made but then it showed me changes in all files.
08:29:12 <alexj_> in any case, my brief review doesn't show me a lot of flag changing relevant to this particular conversation.
08:29:36 <kolmodin> I count 13 times changed
08:29:48 <alexj_> can you enumerate?
08:29:54 <kolmodin> sorry?
08:32:12 <kolmodin> why don't you get the flags from the cabal file instead
08:32:47 <kolmodin> that way you don't have to poke on every project that uses cabal in its intended way
08:32:49 <alexj_> because not everything is distributed with cabal and because not all the files in the project necessarily need it.
08:33:29 <alexj_> and because every repo is shaped differently so mapping from URL to src hierachy and cabal file gets harder.
08:35:01 <kolmodin> if a particular file needed a flag that would inflict badly on other modules, as changing inlining threshold, then I'd put it in OPTIONS_GHC
08:35:10 <kolmodin> or something that cabal couldn't describe
08:35:51 <alexj_> I am saying that model is correct generally because cabal is not general enough.
08:36:19 <alexj_> conceptually I could have the map go from module hierarchies to cabal file URLs but cabal doesn't really support that either.
08:36:51 <alexj_> and the basic model of searchpath will also work with java, python, etc if I ever get to it.
08:37:17 <kolmodin> java and python doesn't need compile flags
08:37:30 <kolmodin> in the same way that you use them with ghc
08:37:39 <alexj_> correct.
08:37:42 <alexj_> that is my point.
08:37:59 <alexj_> every other language requires that special stuff be put in the module files themselves.
08:38:11 <alexj_> e.g. from future import blah in python.
08:40:12 <kolmodin> saying "from future import blah" isn't the same thing as giving a compiler flag
08:42:01 * malcolmw wishes Cabal worked with compilers other than ghc
08:43:05 <kolmodin> it does?
08:43:05 <kosmikus> so we all agree? ;)
08:43:22 <kolmodin> hah, I can agree on that, if that's the case
08:44:01 <vincenz> kosmikus kolmodin
08:44:05 <vincenz> aaaah
08:44:28 <kolmodin> alexj_: look, as a gentoo developer i package haskell libs all the time. cabal is very very common and you'll have a hard time if you're not going to support it
08:44:34 * koincenz grins
08:44:41 <kosmikus> hi there, koincenz
08:44:46 <koincenz> hello kosmikus
08:44:55 * koincenz is a bit silly today, allnight coding
08:45:00 <kolmodin> hia koincenz :)
08:45:13 <koincenz> hello kolmodin
08:45:21 <kosmikus> resistance is futile. you will be kossimilated.
08:45:35 <koincenz> or kombinated
08:45:54 <kolmodin> kombinated with a bucket of concrete
08:46:04 <koincenz> konkrete
08:46:06 <rjeq> if my program ought to be running in constant memory but isn't, that's a space leak, right?
08:46:11 <quicksilver> rjeq: yes
08:46:13 <koincenz> rjeq: most likely
08:46:18 <kolmodin> sounds so
08:46:35 <Igloo> malcolmw: Is there a SoC project for Cabal+(y|n)hc?
08:46:41 <rjeq> how can i work out what's causing it?
08:46:54 <malcolmw> Igloo: what a great idea - no there is no project for that yet
08:47:22 <koincenz> I love coding in haskell
08:47:25 <koincenz> you set your type-defs
08:47:30 <koincenz> and then slowly reduce your number of undefines
08:47:36 <koincenz> or the size of the undefineds
08:47:37 <kolmodin> rjeq: it's probably something in your code, but it could also be the position of the moon or other planets
08:47:45 <koincenz> when none are left, your program is written :)
08:47:56 <kolmodin> rjeq: er.. you could compile your app with profiling perhaps
08:48:13 <rjeq> kolmodin: yeah i realised it was something i should be looking up myself, sorry
08:48:26 <kolmodin> I must say I haven't debugged an app for space leaks
08:48:48 <kolmodin> np, it'd be interesting to hear your experiences
08:50:11 <malcolmw> Igloo: ok, idea added to the trac tickets
08:50:41 <Igloo> malcolmw: Cool, although sadly too late in the process I fear  :-(
08:50:43 <rjeq> kolmodin: when i tried it before, i couldn't get any useful info out of the heap profile
08:50:55 <malcolmw> Igloo: there are still three days to the deadline
08:51:06 <Igloo> Oh, I had the 24th in my head
08:51:06 <rjeq> the heap profiles don't give it based on individial list or anything...
08:51:24 <malcolmw> Igloo: see email on haskell-cafe :-)  Google extended it
08:51:38 <Igloo> Ah, OK
08:51:42 <kolmodin> #haskell: any hints for rjeq who tries to debug a space leak?
08:52:22 <Igloo> rjeq: What do the profiles look like?
08:52:25 <kolmodin> I've only debugged space leaks in java apps using netbeans. very very plesent experience
08:52:39 <Igloo> rjeq: Looking at different sorts of heap profile can sometimes help too
08:53:00 <koincenz> 275 linecount for my function
08:53:02 <koincenz> \o/
08:53:10 <rjeq> in fact, i just realised that maybe it won't be constant memory :p
08:53:36 <kolmodin> koincenz: a single function?
08:53:50 <alexj_> kolmodin: i recgonize that cabal is very common, but that doesn't make it either good or necessary.
08:53:51 <koincenz> kolmodin: yes
08:54:18 <alexj_> kolmodin: in particular, it adds substantialy complexity for users in the case where searchpath works.
08:55:00 <alexj_> I can always have searchpath default to adding all sorts of flags or have searchpath hunt up the url directory hierarchy for a cabal file but that seemsnot good.
08:55:18 <alexj_> especially because cabal files do not have consistent names.
08:55:32 <alexj_> eg like makefile does.
08:55:47 * malcolmw wrote a little utility called 'cabal-parse' that can be used from the command-line to extract arbitrary fields from the command-line
08:56:11 <malcolmw> * from the Cabal file
08:56:32 <Igloo> alexj_: sp may work in teh common case, but part of the attraction of cabal is that it will always work
08:56:49 <alexj_> but that isn't actually true.
08:56:59 <Igloo> How so?
08:57:10 <alexj_> cabal will break because the underlying packages have some dependency that doesn't build well on your box.
08:57:19 <alexj_> I am having that problem with crypto stuff right now in fact.
08:57:37 <Igloo> OK, assuming non-broken packages
08:58:01 <alexj_> cabal also imposes a lot more work on the user.
08:58:27 <alexj_> with searchpath, you just pass a module name and it takes care of everything else.
08:58:33 <kolmodin> alexj_: as a gentoo dev, I find cabal extremely plesent to work with. all packags works in exactly the same way, ie *removing* complexity for users
08:58:41 <Igloo> But tools like cabal-install (and sp, if it knew about cabal) will hopefully handle that work in the future
08:58:48 <koincenz> kolmodin: yes
08:58:50 <koincenz> ack
08:59:29 <alexj_> the work flow I want is: 1. write Module.hs 2. sp runhaskell Module.hs
08:59:36 <alexj_> that is all that is required with searchpath.
09:00:11 <alexj_> with cabal, I have to 1. write module 2. write cabal file descibring module 3. hunt for URLs of packages I require 4. download them 5. cabal install them.
09:00:17 <kolmodin> why not have sp work kind of like cabal-install then, to download the package and install it, possibly locally
09:00:31 <alexj_> and then 6. runhaskell Module.hs
09:00:57 <Igloo> alexj_: Ah, OK, so you are using cabal to install things. I must have misunderstood what you said earlier
09:01:12 <alexj_> I am not using cabal to install things if I can avoid it.
09:01:22 <kolmodin> alexj_: that's not true either. your package manager handles 3-5
09:01:24 <Igloo> I don't understand step 5 then  :-)
09:01:28 <alexj_> I don't want random dependencies on my installed environment.
09:01:43 <Igloo> Ah, so you want to just compile with -i...?
09:01:53 <koincenz> kolmodin: not good?
09:02:02 <Igloo> That'll break if the packges you need require C wrappers etc
09:03:01 <kolmodin> alexj_: and your project is likely to be bigger than one module anyway. gathering the building scheme into one .cabal files makes sense in my world
09:03:02 <alexj_> searchpath runhaskell MyModule.hs ---> searchpath runhaskell MyModule.hs --internet http://searchpath.org/default.map ---> {modules downloaded} --> runhaskell -i .haskell-cache/default.map.cache MyModule.hs
09:03:17 <kolmodin> koincenz: yes, package managers are good :)
09:03:45 <koincenz> kolmodin: I meat the one func
09:03:59 <kolmodin> hmm?
09:04:02 <alexj_> igloo: yes what I actually use in my projects is:  sp ghc Main.hs -isrc
09:04:10 <koincenz> 16:52 < kolmodin> koincenz: a single function?
09:04:16 <kolmodin> koincenz: ah, ok
09:04:39 <kolmodin> koincenz: my brain isn't wired to backtrack 10 min on a friday :)
09:04:40 <alexj_> igloo: and yes searchpath doesn't work if I need to call out to clibs.
09:05:26 <koincenz> @localtime kolmodin
09:05:28 <lambdabot> Local time for kolmodin is Fri Mar 23 17:03:52 2007
09:05:38 <alexj_> the reason I am having a crypto problem is that I need to call out to c libs and that doesn't work with cabal either.
09:05:41 <kolmodin> koincenz: (it's been a looong week)
09:05:43 <koincenz> @where kolmodin ?
09:05:43 <lambdabot> I know nothing about kolmodin.
09:05:52 <koincenz> kolmodin: tell me about it :/
09:05:57 <kolmodin> koincenz: gothenburg, sweden
09:06:59 <alexj_> igloo: but in the 90% case, I don't need C libs and things work just fine with searchpath.
09:07:06 <kolmodin> Igloo: can cabal install to a local package file and then possibly make ghc pick it up when compiling?
09:07:41 <alexj_> and in the other 10% most of the time the cabal install doesn't work either.  and it is probably closer to 99%/1%
09:08:14 <kolmodin> @where kolmodin http://www.dtek.chalmers.se/~kolmodin/
09:08:14 <lambdabot> I know nothing about kolmodin.
09:08:39 <kolmodin> @where+ kolmodin http://www.dtek.chalmers.se/~kolmodin/
09:08:39 <lambdabot> Done.
09:08:45 <kolmodin> there we go
09:08:53 <Igloo> kolmodin: Yes
09:09:03 <kolmodin> alexj_: would that be a solution then?
09:09:06 <Igloo> kolmodin: configure with --prefix=somewhere_you_can_write and install --user
09:09:20 <waern> I need to come up with an idea for a small PLT project to do in about 2 weeks, preferably in Haskell. Any suggestions? :)
09:09:34 <kolmodin> Igloo: yeah, but I don't mean to a user, I mean to a completaly separate file
09:09:35 <Igloo> Oh, sorry, you mean a particular local package file? I don't think so
09:09:42 <koincenz> @where vincenz
09:09:43 <lambdabot> http://www.esat.kuleuven.ac.be/~cpoucet/
09:10:01 <alexj_> kolmodin: no because it still requires manual futzig for every package I might happen to want to use and every package those packages might want to use.
09:10:18 <Igloo> But it would be useful functionality for other reasons (building projects that are made of multiple cabal packages)
09:10:35 <kolmodin> alexj_: cabal-install does it by pulling libs from hackage
09:10:38 <Igloo> alexj_: It could all be done by cabal-install and/or sp
09:10:59 <kolmodin> alexj_: and by the looks of it you still have to write search paths for each package in your map files
09:11:36 <alexj_> "sp runhaskell HAppS.Protocols.HTTP.FileServer" wll start a file server running in the current directory.  can you do something like that with cabal?
09:12:05 <alexj_> kolmodin: yes, I keep adding projects to default.map
09:12:34 <alexj_> but that simply requires a module expression and a URL added to a file.
09:13:14 <kolmodin> alexj_: cabal doesn't solve that problem. you could use cabal to do it though
09:13:39 <alexj_> not trivially.
09:13:42 <kolmodin> it's not the aim of that build system to pull deps and execute the project
09:13:56 <kolmodin> it could be done with an app similar to cabal-install
09:14:24 <alexj_> ok then "sp ghc -o foo.exe MyProj.hs" will also work fine.  but I don't think cabal does that.
09:15:12 * SamB wonders what is the best way to deal with ELF files coming in 32- and 64-bit, big- and little-endian formats...
09:15:41 <koincenz> SamB: santa
09:16:08 <SamB> ... really?
09:16:19 <Cheery> > randomIO
09:16:20 <lambdabot>  Add a type signature
09:16:23 <kolmodin> alexj_: you mean to pull all deps and compile?
09:16:28 <Cheery> > :t randomIO
09:16:29 <lambdabot>  Parse error
09:16:35 <Cheery> > randomIO 2
09:16:35 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `IO a'
09:16:38 <kolmodin> alexj_: then no, it doesn't do that
09:16:50 <bd_> > randomIO :: In t
09:16:51 <lambdabot>   Not in scope: type constructor or class `In'
09:16:51 <bd_> > randomIO :: Int
09:16:52 <lambdabot>  Couldn't match expected type `Int' against inferred type `IO a'
09:16:57 <bd_> > randomIO :: IO Int
09:16:58 <lambdabot>  <IO Int>
09:17:01 <bd_> there :p
09:17:10 <alexj_> kolmodin: searchpath does do that.
09:17:34 <Cheery> in what module Random was?
09:18:00 * SamB does not think koincenz is being completely honest
09:18:11 * SamB finally detects bad holiday-related joke
09:18:33 <kolmodin> alexj_: I see
09:19:03 <Cheery> I'd just like to get few random numbers between 0 and 1
09:19:11 <shapr> @index anyM
09:19:12 <lambdabot> bzzt
09:19:16 <shapr> @index foldM
09:19:16 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:19:21 <shapr> @type foldM
09:19:24 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
09:19:44 <Cheery> But I understand about nothing how random -module works.
09:19:52 <alexj_> kolmodin: so does my request make more sense now?
09:19:56 <kolmodin> alexj_: why didn't crypto work with cabal?
09:20:07 <kolmodin> alexj_: yes, but I still don't agree
09:20:29 <alexj_> komodin: crypto didn't work because there was no build of something or other for OS/X.
09:20:33 <quicksilver> @seen syntaxfree
09:20:34 <lambdabot> I saw syntaxfree leaving #haskell-blah and #haskell 6d 18h 29m 41s ago, and .
09:21:17 <alexj_> ok.  can we not agree, but would you put the flags in the actual haskell files anyway?
09:22:22 <kolmodin> are you going to ask this of every project that uses nontrivial flags?
09:22:56 <alexj_> I'm only going to ask it of projects that I want to use with searchpath.
09:23:01 * ndm makes an alpha release of his phd, woohoo!
09:23:08 <kolmodin> ndm: about time! :)
09:23:29 <alexj_> HAppS has a big dependency on Data.Binary so I am asking here.
09:23:34 <SamB> ndm: is it capable of trashing hard drives or rendering systems unbootable
09:23:42 <kolmodin> alexj_: I'm flattered, but I recon you should think about cabal support
09:24:14 <kolmodin> ndm: yes, it'll even make your wife divorse you
09:24:18 <alexj_> I recon you should think about searchpath support :-/.  but either way, would you be willing to do it for Data.Binary?
09:24:20 <kolmodin> crap, SamB ^^
09:25:36 <ndm> the previous alpha release came with the warning:
09:25:39 <ndm> "It might eat your hard drive, use your credit card to buy expensive stuff on the internet or start a war with a nearby super-power."
09:26:07 <Igloo> alexj_: I actually want to propose that extensinos are required in both .cabal files and sources, but I'm not sure if it will get support or not
09:26:16 <ndm> this one doesn't, soaking up your CPU time until you hit Ctrl+C is about the worst it gets
09:26:55 <kolmodin> alexj_: I'll be the one that has to make sure the project is consistent. I gave you reasons above, they still hold
09:27:23 <malcolmw> SamB: what are you doing with ELF files?  I started writing a Haskell library for parsing ELF recently.
09:27:49 <kolmodin> alexj_: how about using malcolmw's app to fetch compiler flags from .cabal files then?
09:28:26 <SamB> malcolmw: oh?
09:28:31 * SamB was hoping to write a linker
09:28:50 <Igloo> SamB: For fun?
09:28:58 <SamB> in any case, if you have already started I would do better to use that
09:29:00 <kolmodin> alexj_: you have to do something for each project. otoh, I have to do something for each modurle in each of my projects every time I change a flag or want to support another compiler
09:29:03 <alexj_> igloo: I strongly believe that a haskell file should have all the information needed to run it unless it is doing something with foreign.
09:29:21 <SamB> Igloo: becuase GNU ld is so slow
09:29:31 <alexj_> kolmodin: how about a script that updates your source files from a cabal file?
09:30:22 <SamB> alexj_: why would he need to use such a script?
09:30:33 <SamB> could you not do so on your own?
09:30:37 <malcolmw> I too strongly believe that a haskell module should contain all the information needed to compile it (apart from search path for other modules).
09:31:08 <Igloo> The main problem I currently have is that modules can have options pragmas that turn on extensions the .cabal file doens't know about
09:31:17 * Igloo should get arond to writing all this in an e-mail
09:31:43 <SamB> malcolmw: so, where is this library?
09:31:47 <malcolmw> Igloo: that would just be a Cabal bug though, no?
09:31:51 <alexj_> malcomw: searchpath is actually the result of the discussion we had on this issue a couple of years ago.
09:32:17 <scriptdevil> can more than one pattern be made to evaluvate a single expression in case??
09:32:28 <Igloo> malcolmw: What do you mean by "a Cabal bug"?
09:32:30 <scriptdevil> like a mark of 9 or 8 is good
09:32:34 <malcolmw> SamB: still pretty incomplete: I only got as far as extracting the section header table, sections, and symbol tables so far.
09:32:41 <alexj_> samb: because the haskell files don't have the flags they require.
09:32:49 <quicksilver> scriptdevil: f n | (n==8 || n==9) = "PASS"
09:32:51 <malcolmw> Igloo: the fact that Cabal does not know about all compiler extensions
09:33:13 <SamB> malcolmw: well, I'd still like to hack on yours rather than start from scratch
09:33:25 <Igloo> malcolmw: Sorry, I don't mean cabal doesn't have a name for the extension, I mean the user hasn't put the name in the "Extensions:" field
09:33:37 <malcolmw> Igloo: oh, I see
09:33:43 <SamB> this also makes it far more likely for work I do to actually be of use to others
09:33:51 <quicksilver> scriptdevil: f n | (n==8 || n==9) = "PASS" | otherwise = "FAIL"
09:34:06 <alexj_> kolmodin: would you accept a patch from me that had the appropriate flags on the individual files?
09:34:21 <malcolmw> Igloo: but presumably one could write a little Cabal consistency-checker that trawled all the soruces looking for such errors
09:34:39 <alexj_> I assume command line flags take precedence so having flags in the files would do no harm if you changes the cabal file.
09:34:40 <SamB> malcolmw: little?
09:34:59 <SamB> malcolmw: with -fglasgow-exts being the catch-all that it is?
09:35:15 <Igloo> malcolmw: I'd prefer that cabal told the compiler "These extensions are permissible" and they are then enabled in each module by pragmas. That way you can ghci a module and be guaranteed that it will work, for example
09:35:24 <malcolmw> SamB: I'll make up a darcs repo of my ELF stuff
09:35:24 <SamB> you'd need a parser and a typechecker
09:35:39 <SamB> malcolmw: cool
09:36:10 <kolmodin> alexj_: no, all flags are used. I think the flags in the file takes precidence over command line options
09:36:31 <kolmodin> alexj_: you'll only send me this patch, not maintain it
09:36:55 <alexj_> I'll maintain it as long as happs depends on data.binary.
09:37:01 <quicksilver> Igloo: also, to the extent that the flags actually specify the dialect the file is written in, the file is actually nonsensical without them
09:37:16 <oklopol> can someone show me as short a haskell quicksort as possible?
09:37:17 <quicksilver> Igloo: if the flags merely specify a sensible way to optimise that's different
09:37:17 <SamB> alexj_: why don't you write that script, then...
09:37:36 <kolmodin> alexj_: I still don't like the idea.
09:38:26 <quicksilver> oklopol: qsort (x:xs) = qsort (filter (<x) xs) ++ [x] ++ qsort (filter (>x) xs); qsort [] = []
09:38:29 <alexj_> SamB: because I don't do cabal stuff.  as quicksilver says, the haskell files should identify their dialect.   technically, they are nonesensical otherwise.
09:38:40 <SamB> oklopol: you mean the silly one that used to be in the vicinity of the front page of haskell.org?
09:38:49 <oklopol> no
09:38:51 <scriptdevil>             else case tries of
09:38:51 <scriptdevil>                               0 -> putStrLn "BullsEye"
09:39:00 <oklopol> i'm just wondering how short it can be made in haskell
09:39:07 <scriptdevil>                        else case tries of
09:39:07 <scriptdevil>                               0 -> putStrLn "BullsEye"
09:39:10 <Igloo> quicksilver, alexj_: They aren't non-sensical, they just can't be used out of their context (the cabal package)
09:39:11 <oklopol> if there's a shorter one, please tell me :)
09:39:11 <SamB> alexj_: yeah, but I don't think {-# GHC_OPTIONS #-} really counts as identification
09:39:15 <scriptdevil> sorry..
09:39:19 <scriptdevil> i did not loook...
09:39:41 <SamB> oklopol: well, that was probably about as short as it gets
09:39:45 <quicksilver> Igloo: can we compromise on 'nonsensical out of context' ? :)
09:40:01 <Igloo> If you like  :-)
09:40:02 <alexj_> igloo: so now we have a new language called cabal that involves files that look vaguely like haskell.
09:40:13 <SamB> alexj_: heh. no.
09:40:21 <quicksilver> I would favour calling this language 'hamster'
09:40:31 <malcolmw> SamB: darcs get http://www.cs.york.ac.uk/fp/darcs/ELF
09:40:33 <alexj_> perhaps we should be in #cabal?
09:40:34 <lambdabot> Title: Index of /fp/darcs/ELF
09:40:35 <SamB> the cabal simply identifies the dialect of Haskell
09:41:09 <alexj_> how about a new file extension .chs for cabalized haskell?
09:41:32 <SamB> I still don't think {-# GHC_OPTIONS #-} is better
09:41:38 <Igloo> You could equally say that Haskell files that use Control.Monad.State are non-sensical are you don't know the type of runState
09:41:40 <SamB> then we are using the language "GHC"
09:42:07 <Igloo> You want {-# LANGUAGE ... #-} rather than OPTIONS_GHC
09:42:09 <malcolmw> SamB: forgot to mention that my ELF library requires the polyparse package, which can be found from the same URL (replacing ELF by polyparse)
09:42:17 <waern> wasn't Haskell' going to add the LANGUAGE pragma?
09:42:18 <alexj_> SamB: it would be much nicer if there was a standard way to add these options to haskell files, but GHC_OPTIONS is better than nothing.
09:42:30 <SamB> perhaps we are expected to embed the URL of each package we use in the source?
09:43:03 <hpaste>  ScriptDevil pasted "Case" at http://hpaste.org/1102
09:43:07 <kolmodin> waern: don't make this more complicated than it already is :D
09:43:12 <scriptdevil> will my paste work??
09:43:13 <alexj_> SamB: i assume that module names actually refer to some particular concept.  searchpath provides a way to map module names to the URLS of their implementations.
09:43:17 <SamB> I suppose, after {-# OPTIONS stops #-} working, we can ressurect it with Cabal extension names
09:43:38 <SamB> (which would then be standardized in an addendum)
09:43:42 <Igloo> SamB: That's LANGUAGE, and it already exists...
09:43:48 <SamB> oh?
09:43:48 <alexj_> samb: Foo.Bar.Baz actually refers to a particular meaning.
09:43:51 <SamB> does GHC do that?
09:43:56 <Igloo> Yes
09:44:11 <SamB> alexj_: two packages could both offer such modules, you know...
09:44:20 <SamB> or two versions of the same package, even
09:44:20 <Igloo> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#language-pragma
09:44:23 <lambdabot> Title: 7.10. Pragmas, http://tinyurl.com/y9jo69
09:44:38 <SamB> ooh
09:44:48 <SamB> okay, so, now we need that standardized
09:44:52 <scriptdevil>  http://hpaste.org/1102
09:45:00 <scriptdevil> will this work?
09:45:02 <alexj_> samb: and if you try to use both packages simultaneously, things break.  right now the module namespace is global.
09:45:20 <SamB> alexj_: no it is not
09:45:32 <alexj_> samb: did that change recently?
09:45:34 <SamB> the problem is if you have two versions of the same package
09:45:52 <SamB> since for some reason they don't include the version of the package in the symbol name...
09:46:17 <SamB> alexj_: how recently?
09:46:18 <alexj_> samb: you also have the problem if the same module name is in two different packages that you want to use in the same program.
09:46:24 <kolmodin> alexj_: of the 181 libraries in the gentoo haskell overlay 107 uses cabal
09:46:28 <SamB> alexj_: ah, yes, that too
09:46:46 <SamB> well, from the same other package
09:46:52 <alexj_> samb: so module names are global.  therefore module names uniquely identify particular meanings.
09:47:25 <SamB> that doesn't signify
09:47:31 <kolmodin> alexj_: and you'll have this problem with projects using makefiles too if they specify flags in the makefile. that's the second most common alternative
09:47:40 <SamB> next you will tell me that C symbol names uniquely identify particular meanings!
09:48:18 <alexj_> samb: python and java module names are also global, I believe.
09:48:28 <audreyt> import D581B51D.F379.A4B3.A056.F85B95605102; -- </troll>
09:48:49 <SamB> and I suppose you think that Python module names uniquely identify particular meanings?
09:48:55 <alexj_> yes.
09:49:03 <kolmodin> audreyt: nice :)
09:49:19 <audreyt> that essentially is what .NET does :)
09:49:22 * SamB points at mmap
09:49:24 <kolmodin> audreyt: is that part of the weird file format you're reading?
09:49:34 <audreyt> heh no, that was just trolling
09:49:41 <SamB> audreyt: eh.
09:49:46 <SamB> don't they look more like...
09:49:47 <audreyt> the AFP format is more crazy than that.
09:49:54 <SamB> 6a6081fb-a06e-4a3e-a3dd-ab3867597f65
09:50:03 <kolmodin> heh
09:50:06 <audreyt> er, sure, but that won't parse.
09:50:10 <SamB> oh.
09:50:15 <SamB> you have a point.
09:50:48 <alexj_> java uses domain names as a pattern to avoid collisions in module namespace.
09:51:06 <audreyt> ...and perl6 uses URIs. :)
09:51:36 <alexj_> audreyt: with searchpath, module names are implicit URIs so we are on the same page there!
09:51:57 <audreyt> alexj_: er no, not exactly; they are URLs
09:52:11 <kolmodin> alexj_: how many of the packages your searchpath defines uses cabal? probably quite a lot
09:53:00 <kolmodin> ok, I'm going home to eat and sleep. sorry for being so grumpy
09:53:06 <alexj_> audreyt: actually they are uris.  the map files resolve them to being urls.
09:53:09 <malcolmw> SamB: eventually, I want to be able to manipulate Mach-O files as well as ELF, with a common API
09:53:20 <audreyt> alexj_: fairy nuff.
09:53:37 <mux> audreyt: I've been really disappointed by Perl6 from what I read in WP (maybe that wasn't accurate)
09:53:43 <alexj_> kolmodin: perhaps all, but data.binary is what is breaking searchpath right now.
09:54:28 <alexj_> kolmodin: good night.  sleep well.  feel better.
09:55:04 <malcolmw> alexj_: you could always fork Data.Binary (and still keep in sync with future changes using darcs)
09:55:16 <audreyt> mux: interesting. what do you find most disappointing? :)
09:55:32 <kc5tja> @seen Cale
09:55:32 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 12h 7m 13s ago.
09:55:55 <alexj_> malcolmw: I may end up doing that.
09:55:58 <mux> audreyt: I thought they were going to clean syntax by removing stupid operators and I didn't see that mentioned in WP; also, the new type-system is completely optional
09:56:17 <mux> which amounts to say practically noone is going to use it
09:56:32 <alexj_> malcolmw: but I also wanted to campaign for flags in haskell files generally because I don't want to have to do that in the future and because I think it is the right thing to do.
09:56:37 <quicksilver> it's completely option to not use Data.Dynamic for everything in haskell :P
09:56:39 <audreyt> mux: er, "gradual", not optional :)
09:56:49 <mux> audreyt: gradual?
09:57:07 <malcolmw> alexj_: FWIW, I agree with you that flags in files are good (or something equivalent, like the LANGUAGE pragma)
09:57:32 <audreyt> mux: types are inferred and honoured for the parts that does carry annotations (which is like, the entire standard library). also, what stupid operators? :)
09:57:38 * SimonRC just wrote an even shorter quicksort that the one above:   q(x:s)=(\(y,z)->q y++x:q z)$partition(<x)s;q[]=[]
09:57:49 <SimonRC> It assumes you've imported Data.List though, which most modules of a Haskell program will do anyway.
09:57:56 <mux> audreyt: qq qr qw q<blah>
09:58:06 <mux> are some of those :)
09:58:34 <mux> I'm also not happy with them changing the way type prefixes work
09:58:47 <mauke> @pl \(y,z)->q y++x:q z
09:58:47 <lambdabot> uncurry ((. ((x :) . q)) . (++) . q)
09:58:51 <audreyt> mux: oh, those are gone :)
09:58:51 * quicksilver opines that using emotive words like 'stupid' about a language whilst talking to one of the implementors may not move the debate forward.
09:58:54 <mux> I found it quite nice to refer an array by @foo and an item in the array by $foo[...]
09:58:58 <alexj_> malcolmw: :-)  I wish it was better enforcfed.  In particular, I wish the compilers did not use command line flags at all.
09:59:12 <mux> audreyt: I'm happy for that part then, the WP page should be updated if it's not already done
09:59:24 <shapr> quicksilver: I bet you're right.
09:59:52 <mux> audreyt: but, talking about the "gradual typing" part, it sounds more or less like it's already working
09:59:53 <SimonRC> uncurry((.((x:).q)).(++).q)  -- in fact that is still longer
09:59:56 <mux> maybe a tad less dynamic
10:00:02 <alexj_> audreyt: out of curiosity, how embeddable will pugs be in other haskell code?  I am a vague vision of allowing people to write perl code for happs applications.
10:00:13 <alexj_> s/am/have
10:00:15 <shapr> Yeah, that would be cool!
10:00:22 <shapr> Like Zope, but it would actually work!
10:00:22 <SimonRC> haskell would get a scripting language than
10:00:24 <SimonRC> *then
10:00:44 <quicksilver> Not that it woudln't be cool, but I don't think haskell needs perl6 to be its scripting language
10:00:55 <kc5tja> Zope works just fine.
10:00:59 <quicksilver> a chosen subset of haskell would also be a good scripting language :)
10:01:04 <jmelesky> i'm not sure haskell needs a scripting language at all
10:01:08 <alexj_> quicksilver: I agree with you.  I just want happs to be useful to perl developers.
10:01:08 <audreyt> alexj_: extremely easily -- we are cabalized
10:01:12 <quicksilver> nonetheless, embedded perl6 would be a cool trick
10:01:13 <kc5tja> But, why, oh WHY, would anyone want to write Perl code for a Haskell application?  I'd very much rather use Haskell for the scripting.
10:01:21 <audreyt> alexj_: so a "make install" followed by "make register" will let you simply "import Pugs" etc
10:01:24 <audreyt> (bbiab) :)
10:01:40 <mux> it's so easy to define a scripting language in haskell anyways :)
10:01:42 <audreyt> I need to write something about how I deploy Pugs as the scripting language of Hs codebase in $job for eg OpenAGP :)
10:01:48 <audreyt> er openAFP
10:01:49 <SimonRC> "< kc5tja> Zope works just fine."  -- which "zope"?
10:01:54 <kc5tja> mux: The trick is to make it available dynamically at runtime.
10:02:35 <mux> kc5tja: I don't quite get what that means, practically
10:02:38 <kc5tja> SimonRC: I haven't used any recent versions, but I've used it since it started eons ago, and Zope has always worked for me.  I'm referring to the Python-based web application package.
10:03:17 <kc5tja> mux: I can define a "scripting language" in any language I like.  But what good is it if I can't run scripts in response to me, say, clicking File >> Open Script... >> select filename here
10:03:17 <SimonRC> I thought that... so what does it have to do with Haskell as a scripting language?
10:03:24 <kc5tja> 09:58 < shapr> Like Zope, but it would actually work!
10:03:29 <alexj_> kc5tja: i prefer haskell to perl as well but there are lots of perl developers who may want to take advantage of the plumbing that we are adding to happs.
10:03:46 <SimonRC> kc5tja: ah, ok
10:03:57 <mux> kc5tja: I don't see the problem with having it working like that in Haskell, or in any other language
10:04:02 <shapr> kc5tja: I mean that Zope attempted to add Perl scripting, but it never really happened.
10:04:31 <jmelesky> alexj_: my experience with perlers is that, if they like it, they'll half-port it and put it on CPAN
10:04:39 <kc5tja> mux: You have to write a full-on interpreter if you do, including adding your own bindings between Haskell and the scripting language.
10:04:42 <quicksilver> perl5 was a *horrible* embedded language
10:04:43 <kc5tja> mux: That's a lot of work.
10:04:47 <quicksilver> (and now I'm using emotive words)
10:04:54 <shapr> quicksilver: The horror!
10:04:55 <kc5tja> mux: I'd much rather just use Haskell, and let Haskell itself take care of the bindings.
10:04:58 <quicksilver> it was good for scripting, but not that kind of scripting
10:05:01 <mux> kc5tja: I guess I'm not seeing what you have in mind here - why Haskell bindings?
10:05:03 <shapr> quicksilver: Er, I mean "That's inexact."
10:05:04 <kc5tja> The less code that needs to be written, the better!  :)
10:05:16 <quicksilver> perl6 will embed better, though
10:05:29 <mux> I was considering writing a standalone scripting language
10:05:46 <quicksilver> mux: if you wish to be taken serious round here, you should write several :)
10:05:46 <kc5tja> mux: How do you propose to actually *do* stuff in your scripting language, unless it has bindings to some functionality of your program?  Why write a scripting engine at all if you don't expose any functionality of your scriptED environment?
10:05:50 <mux> I think we're not talking about the same thing :)
10:06:01 <quicksilver> That's something steve yegge says which I actually agree with
10:06:08 <quicksilver> writing a compiler makes you a better programmer
10:06:13 <quicksilver> (even if you never finish it, actually)
10:06:20 <shapr> Writing a programmer on the other hand...
10:06:26 <kc5tja> quicksilver: I've written plenty of compilers -- albeit most of them Forth.  :)
10:06:26 * shapr ran out of Ritalin yesterday...
10:06:27 <mux> kc5tja: ah, I see what you mean by bindings now
10:06:33 <quicksilver> kc5tja: I know you have :)
10:06:40 <quicksilver> kc5tja: and respect you for it, too
10:06:48 <shapr> I just disrespect you!
10:06:51 <mux> quicksilver: I'm not actually considering that - I meant to say I was talking about that kind of scripting language
10:06:56 <quicksilver> shapr: In soviet Russia, language programs you?
10:06:58 <kc5tja> Now, if only I can *finish* the Kestrel Forth project, I'll be much happier.  *sigh*
10:07:05 <SimonRC> In this context, I think a scripting language is defined as one which does no real work, but just glues stuff together, and acts as a DSL for specifying some king of thing.
10:07:06 * kc5tja hates coders block!  :(
10:07:08 <shapr> quicksilver: Yeah!
10:07:33 <shapr> kc5tja: See, if you refactor that into a bunch of little chips instead, it's much easier.
10:07:38 <alexj_> kc5tja: in the case of HAppS, we would have the perl code run inside the MACID monad and provide them with ACID semantics for their app and the amazon back end stuff we are doing.
10:07:49 <quicksilver> SimonRC: I was thinking more of scripting language as 'exposes rather simplified API enabling consumers to write complex functionality without worrying about details'
10:08:10 <SimonRC> quicksilver: yes, that too
10:08:10 <kc5tja> shapr: Nahh, the problem is, I'd like it to be ANSI Forth compatible to some degree, but Chuck Moore is right, ANSI Forth is horrifyingly complex under the hood.
10:08:18 <hyrax42> ?seen ndm
10:08:18 <lambdabot> ndm is in #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard ndm speak 42m 2s ago.
10:08:27 <kc5tja> Simple to implement, but hard to get it *right*.
10:08:40 <ndm> hyrax42: hi
10:08:44 <SimonRC> maybe this conv should be send to -overflow.
10:08:47 <hyrax42> hey
10:08:47 <lambdabot> hyrax42: You have 1 new message. '/msg lambdabot @messages' to read it.
10:08:56 <ndm> hyrax42: hi, want to move to overflow?
10:09:06 <ndm> hyrax42: or haskell-soc?
10:09:25 <hyrax42> sure either
10:09:37 <quicksilver> #haskell-two-left-socs
10:11:01 <ski> > Left "socs"
10:11:05 <lambdabot>  Left "socs"
10:11:28 <opqdonut> haha
10:17:16 <SimonRC> random hack: whichPerm xs ys = sort $ zip (map snd $ sort $ zip xs [0..]) (map snd $ sort $ zip ys [1..])
10:17:38 <SimonRC> it gives you an assoc which is a permutation from the one list to the other.
10:17:44 <SimonRC> I think
10:18:20 <SimonRC> it runs in O(n log n) time which must surely be optimal
10:19:30 <SimonRC> oops, I meant:
10:19:35 <SimonRC> whichPerm xs ys = sort $ zip (map snd $ sort $ zip xs [0..]) (map snd $ sort $ zip ys [0..])
10:19:51 <SimonRC> the output is a list of the coresponding indexes in the two lists
10:20:11 <chessguy_work> @type sort $ zip (map snd $ sort $ zip xs [0..]) (map snd $ sort $ zip ys [0..])
10:20:13 <lambdabot> Not in scope: `xs'
10:20:13 <lambdabot>  
10:20:13 <lambdabot> <interactive>:1:65: Not in scope: `ys'
10:20:25 <chessguy_work> @type \xs ys -> sort $ zip (map snd $ sort $ zip xs [0..]) (map snd $ sort $ zip ys [0..])
10:20:28 <lambdabot> forall b a b1 a1. (Ord (b, b1), Ord (a, b), Num b, Enum b, Ord (a1, b1), Num b1, Enum b1) => [a] -> [a1] -> [(b, b1)]
10:21:24 <doserj> > let whichPerm xs ys = sort $ zip (map snd $ sort $ zip xs [0..]) (map snd $ sort $ zip ys [0..]) in whichPerm [1..10] [11..20]
10:21:25 <lambdabot>  [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9)]
10:22:45 <SimonRC> it assumes the two inputs are permutations of each other
10:23:11 <SimonRC> > let whichPerm xs ys = sort $ zip (map snd $ sort $ zip xs [0..]) (map snd $ sort $ zip ys [0..]) in whichPerm "asdf" "afsd"
10:23:13 <lambdabot>  [(0,0),(1,2),(2,3),(3,1)]
10:23:59 <doserj> ah
10:25:24 <enkrav> how can I convert an Int to a Float?
10:26:27 <chessguy_work> ?type fromIntegral
10:26:30 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:27:02 <chessguy_work> > fromIntegral (3 :: Int) :: Float
10:27:03 <lambdabot>  3.0
10:27:37 <enkrav> thx
10:28:34 <shapr> In honor of functional programming typos, I propose that the first day of every week be called Monady.
10:30:14 <chessguy_work> @remember shapr In honor of functional programming typos, I propose that the first day of every week be called Monady.
10:30:14 <lambdabot> Done.
10:31:04 <jacobian> malcolmw: Have you tried working out printer/reader pairs yourself?
10:31:32 <quicksilver> SimonRC: I think that's cute
10:31:45 <quicksilver> SimonRC: now make it output the minimal set of swaps :)
10:31:57 <malcolmw> jacobian: no
10:32:39 <SamB> @quote monad
10:32:40 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
10:32:40 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
10:33:05 <malcolmw> jacobian: but there is a nice tool/language called TXL (transformation language) in which you specify a language grammar once, and it uses it for both parsing and printing.
10:33:21 <quicksilver> that last should be ST RealWorld is not enough
10:33:47 <SamB> @quote monad
10:33:48 <lambdabot> Tela says: ... tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day
10:34:14 <dolio> @quote qwe1234 monad
10:34:14 <lambdabot> No quotes match. My mind is going. I can feel it.
10:34:33 <dolio> @quote qwe1234 monads
10:34:33 <lambdabot> No quotes match. Take a stress pill and think things over.
10:34:42 <mauke> @quote qwe1234.*monad
10:34:42 <chessguy_work> @quote qwe1234.monad
10:34:42 <lambdabot> No quotes match. It can only be attributed to human error.
10:34:42 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
10:35:13 <SamB> @help quote
10:35:13 <lambdabot> quote <nick>
10:35:13 <lambdabot> remember <nick> <quote>
10:35:13 <lambdabot> Quote somebody, a random person, or save a memorable quote
10:35:33 <kpreid> I liked lambdabot better without the insults
10:35:36 <SamB> we could also attribute it to insufficient documentation
10:35:39 <chessguy_work> @quote samb
10:35:39 <lambdabot> SamB says: [<lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane] <SamB> is that a Python web framework?
10:35:43 <SamB> kpreid: fix it and send in a patch
10:36:02 <chessguy_work> SamB, i'm sure someone already has
10:36:12 <dolio> @quote IO focus
10:36:12 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
10:36:19 <SamB> chessguy_work: when I complain about it, that is what dons tells me to do!
10:36:20 <chessguy_work> @quote focus
10:36:21 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment.
10:36:21 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
10:36:28 <SamB> the implication being that he would accept the patch
10:37:02 <jacobian> malcolmw: I wrote a language that was like a prolog DCG for doing this
10:37:08 <SamB> perhaps I was only talking about for @quote, though
10:37:29 <jacobian> malcolmw: I think that bidirectional tree transformations are the way to think about it
10:37:33 <SamB> so, maybe if someone took it out everywhere it appeared, he would not accept that patch
10:37:49 <merus> Artificial communication devices aren't quaint until they randomly insult people.
10:38:12 <Syzygy-> Yes! Yoneda's lemma!
10:38:33 <quicksilver> @quote Yoneda
10:38:34 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment.
10:38:34 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
10:38:36 <SamB> well, I don't think any command that takes a regex (or recently did) should be allowed to insult the user
10:39:03 <dolio> @quote using.perl
10:39:03 <lambdabot> SimonRC says:  if performance was that important, people would be using perl, python, or the JVM
10:39:06 <sioraiocht> is there a function in haskell to find the nth root of a number?
10:39:28 <mauke> yeah, ** (1/
10:40:08 <sioraiocht> thanks mauke
10:40:23 <mauke> > 10 ** recip 3
10:40:24 <lambdabot>  2.154434690031884
10:40:48 <quicksilver> :t recipt
10:40:50 <lambdabot> Not in scope: `recipt'
10:41:32 <chessguy_work> ?where stats
10:41:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
10:41:58 <quicksilver> :t recip
10:42:01 <lambdabot> forall a. (Fractional a) => a -> a
10:42:09 <quicksilver> :t (**)
10:42:11 <lambdabot> forall a. (Floating a) => a -> a -> a
10:42:39 <dolio> > let root = flip $ (. recip) . (**) in root 3 10
10:42:41 <lambdabot>  2.154434690031884
10:45:22 <jacobian> python is nearly the ideal language for a parser/printer pair
10:45:35 <jacobian> since whitespace is significant, the pretty printing is really easy
10:53:19 <waern> I need to come up with an idea for a small (1 to 2 weeks) PLT-related project for school, preferably something written in Haskell. Any ideas? It would be nice to be able to do something that could benefit the community.
10:55:25 <chessguy_work> you could write some kind of parser
10:56:28 <chessguy_work> @where parsec
10:56:28 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
10:56:34 <waern> yes
10:56:41 <kolmodin> port it to bytestrings?
10:56:42 <waern> any language suggestion?
10:57:09 <waern> hmm
10:57:22 <waern> how much work would that take?
10:57:26 <chessguy_work> hmm, there's no real to-do list for parsec
10:57:46 <chessguy_work> waern, 47.283 man-hours
10:57:52 <chessguy_work> how are we supposed to know?
10:58:18 <kolmodin> waern: about 7 in arbitrary units
10:58:56 <jmelesky> waern: one's week-long project is another's month-long project
10:58:57 <waern> someone who knows both bytestrings and parsec well would know
10:59:24 <kolmodin> waern: I'd guess it's not that much work
10:59:30 <kolmodin> if you know parsec a little
10:59:52 <kolmodin> I ported ReadP to bytestrings in less than a weekend
10:59:58 <waern> ah, okay
11:00:35 <waern> wait a minute, I think I saw some bytestring version of parsec somewhere
11:00:48 <kolmodin> parsec is bigger than ReadP though
11:01:09 <sjanssen> waern: http://darcs.haskell.org/~sjanssen/genparsec is an attempt I made a while back
11:01:11 <lambdabot> Title: Index of /~sjanssen/genparsec
11:01:14 <kolmodin> waern: I've seen something too, except that wasn't really parsec but a new thing
11:01:54 <sjanssen> waern: its performance is complete crap (lazy bytestrings were slower than [Char])
11:02:35 <waern> sjanssen, ah. a fundamental problem or a problem with your implementation?
11:02:50 <sjanssen> but the initial hacking of making the storage type polymorphic and making everything type check only took one evening
11:02:55 <kolmodin> sjanssen: that's probably due to that lazy bytestrings doesn't keep the head of the string strict
11:03:22 <sjanssen> waern: I think it needs tuning.  INLINEs and SPECIALIZEs, I think
11:03:30 <sjanssen> kolmodin: yes, this is another potential problem
11:03:43 <kolmodin> sjanssen: as you know, we got much better performance in binary when we handled the head separately
11:04:14 <kolmodin> it'd be nice to se the lazy bytestring handle that instead of every library doing it
11:04:19 <encryptio> what's the difference between Type and !Type?
11:04:28 <sjanssen> encryptio: ! means strict
11:05:00 <sjanssen> when you see that in a constructor declaration, it means the compiler evaluates that component to WHNF when you construct the data type
11:05:30 <encryptio> WHNF?
11:06:00 <sjanssen> weak head normal form -- which means evaluated enough to reveal the top constructor
11:06:48 <encryptio> so the !Types (is there a name for these?) let you add strictness easily, no?
11:06:59 <sjanssen> yes
11:07:27 <sjanssen> encryptio: I call them "strict components"
11:08:34 <kolmodin> food!
11:08:43 <Saizan> mmh strange bug, xmonad suddenly ceased to intercept keys
11:09:54 <sjanssen> Saizan: I haven't seen that one.  any idea what caused it?
11:11:45 <encryptio> "Unexpected strictness annotation: !Double" -- ?
11:12:27 <sjanssen> encryptio: ! can only appear in data declarations
11:12:34 <procyon_> @seen chessguy
11:12:34 <lambdabot> I saw chessguy leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 19d 14h 56m 55s ago, and .
11:12:47 <encryptio> it is in a data declaration: data Color = RGBA (!Double, !Double, !Double, !Double)
11:12:58 <Saizan> sjassen: really, no, i was screen in a konsole
11:13:00 <procyon_> @seen chessguy_
11:13:00 <lambdabot> I haven't seen chessguy_.
11:13:09 <sjanssen> encryptio: it can't appear inside another data type
11:13:21 <procyon_> @seen chessguy_work
11:13:22 <lambdabot> chessguy_work is in #haskell-overflow and #haskell. I last heard chessguy_work speak 15m 29s ago.
11:13:35 <sjanssen> (,,,) is your "another data type" here
11:13:51 <encryptio> so... !(Double, ...) ?
11:14:00 <sjanssen> data RGBA = RGBA !Double !Double !Double !Double is what you really want
11:14:23 <audreyt> @type Any
11:14:26 <lambdabot> Bool -> Any
11:14:36 <sjanssen> encryptio: that is valid syntax, but that doesn't do exactly what you want
11:14:53 <roconnor> > product [39..34] `div` product [1..5]
11:14:54 <lambdabot>  0
11:15:34 <dolio> > [39, 38 .. 34]
11:15:35 <roconnor> > product [39..35] `div` product [1..5]
11:15:36 <lambdabot>  [39,38,37,36,35,34]
11:15:36 <lambdabot>  0
11:15:44 <sjanssen> encryptio: the tuple adds an extra layer of indirection
11:16:00 <roconnor> > product [39,38..35] `div` product [1..5]
11:16:01 <lambdabot>  575757
11:25:55 * SamB wishes cabal-setup would skip building the "default" Setup.lhs file
11:31:19 <chessguy_work> ?where shootout
11:31:20 <lambdabot> http://shootout.alioth.debian.org/
11:31:24 <SamB> (because, you know, it is a good deal faster to just run the routine from cabal-setup than to link a program against the libraries)
11:34:44 <procyon_> chessguy: about your GP library
11:34:52 <kc5tja> I'm trying to code up another dummy example monad, and I just can't get the dang thing to compile.
11:35:03 <procyon_> chessguy: I have some interesting ideas for it
11:35:03 <kc5tja> type ExState s a = (s->(a,s))
11:35:04 <tapple> how comprehensive is that language parser Summer of Code project? Is it to be able to parse the language, interpret it, or to have it be running on the same VM as haskell?
11:35:13 <kc5tja> instance Monad ExState s where ...
11:35:17 <kc5tja> That instance declaration fails.
11:35:21 <kc5tja> Any ideas why?
11:35:23 <dolio> That's a type synonym. Wont' work.
11:35:27 <dolio> You need newtype.
11:35:49 <dolio> Type synonyms aren't allowed to be partially applied.
11:35:58 <dolio> And probably aren't allowed to be declared instances, either.
11:36:32 <kc5tja> That seems very arbitrary to me.
11:36:34 <jyasskin> You would also need "instance Monad (ExState s) where ..."
11:36:51 <kc5tja> jyasskin: 11:33 < kc5tja> instance Monad ExState s where ...
11:36:55 <kc5tja> I already have it.
11:37:24 <dolio> Well, the partial application isn't totally arbitrary, at least.
11:37:47 <dolio> Since you can construct things with partially applied type synonyms that would never work raw.
11:37:53 <SamB> dolio: GHC will let you use type synonyms to declare instances
11:38:09 <SamB> but, of course, you can't do it with the same type twice using different synonyms ;-)
11:38:19 <sjanssen> SamB: I don't think you can write the instance that kc5tja wanted to write
11:38:23 <dolio> For instance: ExState s == /\a. s -> (a, s), which is a type level lambda, which Haskell doesnt' really do, generally.
11:38:48 <SamB> oh, no, you can't do that with type synonyms, no
11:40:35 <dolio> You can do partial application, like ((->) r), but not fully general type lambdas.
11:40:59 <kc5tja> Well, shucks, that just totally ruins the latter half of my paper.
11:41:07 * kc5tja is going to have to retrofit all the code.  >:(
11:41:25 <SamB> typecheck before paper next time maybe?
11:41:30 * kc5tja originally used a ``data`` construct, but that proved to be *rediculously* complicated -- I never, in fact, got it to ever typecheck.
11:41:56 <dolio> newtype ExState s a = S (s -> (a, s)) will work, although you'll have to stick destructors/constructors all over the place, unfortunately.
11:41:58 <kc5tja> SamB: No.
11:42:16 <kc5tja> SamB: I have to write the paper concurrently with the code or else I lose context.
11:42:23 <encryptio> :t join . return
11:42:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
11:42:27 <SamB> kc5tja: hmm.
11:42:32 <dolio> But that actually creates a new datatype, of sorts, that can be partially applied, instead of just being, essentially, a type-level macro.
11:42:58 <sjanssen> kc5tja: what sort of paper is this?
11:43:21 <kc5tja> sjanssen: Just my own interpretation of what monads are.
11:43:24 <sjanssen> most papers would gloss over the type v. newtype issue -- it really isn't that key to the issue
11:43:27 <kc5tja> Nothing overly academic.
11:43:57 <sjanssen> but if you want to provide exact code that the reader can run you need to use a newtype
11:44:00 <allbery_b> hm, apparently I'm being stupid.  or the documentation and the examples for the ListView stuff in gtk2hs are not so closely related
11:44:10 <SamB> sjanssen: cheap ass papers!
11:44:38 <sjanssen> SamB: good papers
11:44:39 <allbery_b> I'm failing to understand how to connect a column in the view to a column in the model, so currently I have a bunch of empty columns :/
11:45:19 <Cheery> hmm. I'm somehow unhappy to what I have for drawing stuff.
11:45:30 <sjanssen> SamB: a good paper will cut out all the extra details that aren't directly tied to the subject at hand
11:45:42 <SamB> hmm.
11:45:49 <kc5tja> dolio: See, now nothing at all typechecks.
11:45:58 <dolio> It is somewhat disappointing. I wanted to create "type ComposeT u v m a = u (v m) a" and then do "instance (MonadTrans u, MonadTrans v) => MonadTrans ComposeT u v where..." but no such luck.
11:46:21 <largos> hm.. what do people suggest for parsing xml in Haskell? (there appear to be at least three libraries that will do it: HXT HaXml and HXML)
11:46:53 <dylan> I think HXT is the most magical and interesting (to me)
11:46:58 <Saizan> i'll use HXT
11:47:06 <SamB> dolio: ... what would that buy you?
11:47:13 <eulero> largos: HXT is very good
11:47:15 <largos> ok, HXT seems to have the best documentation, at first glance anyway
11:47:17 <SamB> an ambiguity in the type of "lift"?
11:47:26 <largos> thanks for the input
11:47:54 <dolio> SamB: I was shooting for free lifting through arbitrarily nested transformers.
11:48:04 <dolio> I don't know if that would even work that way.
11:48:08 <SamB> dolio: I'll take that as a "yes"
11:48:19 <dolio> :)
11:48:28 <eulero> @seen dons
11:48:29 <lambdabot> dons is in #haskell-overflow and #haskell. I don't know when dons last spoke.
11:48:41 <eulero> @seen xerox
11:48:42 <lambdabot> xerox is in #perl6, #haskell-overflow, #haskell-blah and #haskell. I don't know when xerox last spoke.
11:49:13 <dolio> kc5tja: Well, if you switch to newtype, your code for just 'type' certainly won't work, because it doesn't handle the extra constructor introduced by newtype.
11:50:11 <dolio> In general you'd need to switch "f sa = e" to something like "f (S sa) = S (e)"
11:50:23 <sjanssen> you can save plenty of boilerplate by writing newtype State s a = State {runState :: s -> (s, a)}
11:51:05 <kc5tja> dolio: Obviously, I've tried to adjust the code accordingly.  I'm not that thick.  :)
11:51:14 <dolio> :)
11:57:09 <Gwern> hmm. someone should tell dons that xmonad doesn't seem to compile right now
11:57:21 <sjanssen> Gwern: update X11-extras
11:58:50 <Gwern> jawohl, mein fuhrer
11:59:34 <Cheery> what properties does two dimensional shapes have?
11:59:38 <sjanssen> hmm.  I've never been called Fuhrer
12:00:21 <Gwern> sjanssen: don't take it too seriously. It is merely an expression fo my abject lack of knowledge and experience with haskell
12:00:47 <sjanssen> Gwern: too bad, I like the title :)
12:01:19 <nominolo> why don't people always pick up the wrong german quotes .. :/
12:01:36 <sioraiocht> Gwern: are you welsh?
12:02:15 <Gwern> sioraiocht: only distantly
12:02:31 <Gwern> sjanssen: so what is X11-extras anyway that it isn't a debian package but also isn't part of xmonad?
12:02:34 <procyon_> Cheery: Length and Width?
12:02:36 <sioraiocht> Gwern: I take it your name is inspired by the Second Branch of the Mabinogi?
12:02:41 <roconnor> Cheery: when you scale them by a factor alpha, their area increases by a factor of alpha squared.
12:02:52 <Gwern> sioraiocht: you would be correct
12:02:59 <sioraiocht> neat =)
12:03:02 * Gwern kudos sioraiocht for literary knowledge
12:03:16 <sjanssen> Gwern: the X11 package is incomplete.  X11-extras is the stuff that X11 is missing
12:03:19 <sioraiocht> haha, I'm in the middle of the Mabinogion =)
12:03:25 <_Stinger_> who or what is a Mabinogi?
12:03:26 <procyon_> Cheery: Color... number of sides.. convexity/concavity
12:03:42 <sjanssen> eventually we'll move all the new stuff from X11-extras to X11 and X11-extras will die
12:03:43 <_Stinger_> area
12:03:46 <Gwern> oh. so it's not as impressive a feat as I thought, but so few people read the mabinogi anyway that it is meritorious
12:03:49 <sioraiocht> _Stinger_: the mabinogi is a collection of medieval welsh stories from the welsh oral tradition
12:04:09 <_Stinger_> sounds delightful :|
12:04:10 <Gwern> sjanssen: I see. that sounds good, but I hope the move won't really break much
12:04:20 <sioraiocht> Gwern: I agree.  I'm readinga rather new translation and I have to say, though, I'm rather disappointed with it
12:04:21 <Cheery> procyon_: I'm looking for some properties which I could exploit when drawing infinite and perfect shapes with openGL.
12:04:41 <Gwern> sioraiocht: in what way?
12:04:43 <sjanssen> Gwern: no, it'll just mean deleting a couple imports and updating the cabal file
12:05:06 <cwenner> what library should i use for [mathematical] graph structures?
12:05:10 * Gwern sees
12:05:20 <sioraiocht> Gwern: It's very dry.  I feel it doesn't express the imagery that the original poets were probably tryingto convey
12:05:32 <Gwern> ah, ok. with an updated X11-extras, xmonad compiles now. I wonder how well the new tiling stuff works?
12:05:54 <sjanssen> Gwern: pretty well.  Focus is a little inconsistent sometimes
12:06:42 <Gwern> sjanssen: btw, I was meaning to ask. how is the prefix key defined? I tried compiling with a different keysym (Insert), but that didn't work
12:07:20 <_Stinger_> whats xmonad? haskell wm?
12:07:27 <sjanssen> _Stinger_: correct
12:07:29 <sjanssen> @where xmonad
12:07:29 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
12:07:35 <_Stinger_> interesting :)
12:07:36 <roconnor> wow, hackageDB is really something!
12:08:11 <_Stinger_> unfortunately I havent been using linux too much lately
12:08:21 <_Stinger_> too addicted to games :(
12:08:30 <Gu1> to bad there are no screenshots of xmonad
12:08:31 <sjanssen> Gwern: it's possible that the value of insert key defined in the Xlib isn't the same value that your keyboard actually sends
12:08:32 <_Stinger_> and ghci in win isnt that fun either
12:08:52 <sjanssen> Gwern: you can use xev to figure out what the mask should actually be
12:08:58 <Gwern> sjanssen: I'm also considering the possibility that xmodmap isn't working aright
12:09:19 <Gwern> but where can I find a list of symbols acceptable as a prefix key? like I said, everythiing I tried would not compile
12:09:31 <sjanssen> oh, wouldn't compile?
12:10:10 <Gwern> sjanssen: well, there's no other way to customize it as far as I can tell
12:10:11 <roconnor> cwenner: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fgl-5.3
12:10:14 <lambdabot> http://tinyurl.com/2yjtuj
12:10:16 <Saizan> is orizzontal tiling available?
12:10:28 <Gwern> (i haven't tried the updated xmonad yet though. cursed fglrx driver!)
12:10:29 <sjanssen> Gwern: you can write literal values in modMask
12:10:42 <sjanssen> Gwern: like 0x01, or whatnot
12:10:54 <Gwern> ick.
12:14:17 <sjanssen> Gwern: that might be the only way to do it if you have nonstandard modkeys
12:14:17 <SamB> Gwern: xmodmap will tell you what keys are mapped to which mask bits
12:15:34 <mwc> Does anybody know of any results in applying dynamic programming to generating optimal permuations of a set?
12:15:52 <SamB> what is an optimal permutation?
12:16:52 <mwc> a particular order of some set that's either a minimum or a maximum of some function of that permutation
12:17:07 <mwc> I've found a couple of articles on google that sort of apply
12:17:35 <SamB> it is probably not possible unless you know something about the nature of the function ;-)
12:18:25 <monochrom> yeah
12:19:07 <mwc> Well, to use dynamic programming, you need optimal subprogramming. That's the bit I have trouble here
12:19:31 <xerox> P(monochrom knows) = 1 - P(monochrom don't knows) = 1.
12:19:36 <mwc> basically I'm trying to come up with a satisfactory algorithm for generating an optimal renumbering of mesh nodes to produce the narrowest possible bandwidth in a related matrix calculation
12:20:00 <monochrom> That probability is too high. :)
12:20:37 <cwenner> thank you, roconnor
12:22:00 <SamB> xerox: that made sense up until the "= 1."
12:22:12 * xerox recently discovered probability axioms.
12:22:49 <monochrom> probability axioms are nice. if you actually go all the way to measure axioms, that's the best.
12:22:55 <SamB> hmm
12:23:25 <mwc> shudder. Stats 257 was one of my most loathed courses
12:23:31 <xerox> right, every text I found begins with measure theory, sigma-algebras, and other stuff.
12:24:37 <monochrom> mwc: why was it loathed?
12:24:37 <_Stinger_> ooh fun :)
12:26:15 <dmwit> I'm surprised forever hasn't made it into the Prelude yet.
12:26:22 <SamB> hmm. cabal can't find the documentation from ghc6-doc in Debian :-(
12:26:26 <xerox> most of the second-year students here are going crazy with statistics
12:26:31 <SamB> Igloo: this maketh me sad
12:26:41 <mwc> I just didn't like it as much as other courses that year: advanced linalg, numerical analysis for intance
12:26:59 <Igloo> SamB: I understand what needs to happen now, so I'll probably try to fix it for 6.6.1
12:27:33 <xerox> mwc, what is "advanced" about?
12:27:33 <SamB> Igloo: you don't need to have a meeting with some DDs and some Cabla developers (and maybe some gentoo developers too?) to figure out what needs to be done?
12:27:36 <SamB> thats nice
12:28:37 <SamB> so what may that be?
12:29:31 <SamB> dmwit: it might be in Control.Monad under a strange name
12:29:47 <SamB> repeatM_ or something
12:29:58 <SamB> :t repeatM_
12:30:00 <lambdabot> Not in scope: `repeatM_'
12:30:13 <xerox> For our linear algebra course we have covered for example only finite spaces, I guess the advanced implies covering things like infinite dimensional spaces, and maybe things I don't know yet :)
12:30:16 <dmwit> :t ?forever a = a >> forever a
12:30:19 <lambdabot> parse error on input `='
12:30:27 <dmwit> :t a >> ?forever a
12:30:30 <lambdabot> Not in scope: `a'
12:30:30 <lambdabot>  
12:30:30 <lambdabot> <interactive>:1:14: Not in scope: `a'
12:30:37 <SamB> :t let forever a = a >> forever a in forever
12:30:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
12:30:46 <mwc> xerox: advanced as in it's the last undergraduate course in linear algebra an applied math major takes.
12:30:52 <SamB> @hoogle (Monad m) => m a -> m b
12:30:52 <lambdabot> Prelude.id :: a -> a
12:30:53 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
12:30:53 <lambdabot> Prelude.asTypeOf :: a -> a -> a
12:31:00 <SamB> maybe not then
12:31:06 <SamB> @hoogle (Monad m) => m a -> m ()
12:31:07 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
12:31:08 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
12:31:08 <lambdabot> Prelude.id :: a -> a
12:31:32 <dmwit> That's okay, it's really easy to write. =)
12:32:19 <SamB> I don't think it would be very difficult to get "repeatM_ :: Monad m => m a -> m ()" into Control.Monad
12:32:34 <SamB> @hoogle repeatM
12:32:35 <lambdabot> No matches found
12:32:36 <monochrom> infinite dimension spaces enjoy significantly fewer theorems, unless you add extra axioms, but then you end up specializing, and so for example you'll find infinite dimension spaces in "hilbert spaces".
12:32:39 <int-e> I have a type class  class Nat n where nat :: n -> Integer; I want to write a function  reflect :: Integer -> (forall n . Nat n => n -> a) -> a  which satisfies  reflect x nat == x for all x >= 0. Can this be done in constant time? (doing it in logarithmic time - O(log(x)) isn't that hard).
12:32:40 <SamB> hmm.
12:32:51 <SamB> you might need to also do a repeatM
12:33:31 <SamB> repeatM :: Monad m => m a -> [m a]
12:33:52 <SamB> (but would only be usefull in lazy monads)
12:35:00 <SamB> Igloo: anyway, good to hear it ;-)
12:35:26 <SamB> it has always been annoying the way haddock would complain about not being able to resolve things from the standard library ;-)
12:35:31 <monochrom> int-e: how do you implement it presently? actually I don't see how at all.
12:35:56 <monochrom> (oh haha, "presently" doesn't mean what I want it to mean!)
12:37:15 <SamB> int-e: what do you want to do?
12:37:30 <hpaste>  int-e pasted "reflecting Integers" at http://hpaste.org/1103
12:38:16 <monochrom> who is NatI?
12:38:46 <int-e> huh. type NatI n = Mark n Integer
12:38:49 <int-e> where'd that go?
12:39:11 <int-e> ah. I deleted the wrong line; import Util.Mark  is still there.
12:39:57 <int-e> monochrom: it serves the same purpose as the dummy argument above; you can think of it as  type NatI n = n -> Integer  with little difference
12:40:18 <int-e> monochrom: anyway the code encodes the number into a type and then gets the value back through the 3 Nat instances that I provide.
12:41:22 <EvilTerran> ?hoogle [Char] -> (a -> b)
12:41:23 <lambdabot> No matches, try a more general search
12:41:24 <int-e> monochrom: and it's optimized for speed rather than clarity I'm afraid - I wanted to do that trick with large prime numbers.
12:42:00 <EvilTerran> hm. is there a way of interpreting an arbitrary string as haskell, in haskell?
12:42:10 <EvilTerran> short of invoking an interpreter as a subprocess?
12:42:23 <EvilTerran> (or, say, a file)
12:42:30 <dmwit> ?where hs-plugins
12:42:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
12:42:51 <mauke> hs-plugin?
12:42:53 <dmwit> Mmmm... basically no.
12:43:05 <alexj> dmwit we have a darcs cabalized hsplugin package if you wat.
12:43:07 <alexj> want
12:43:30 <alexj> oops.  sorry I meant hlist.  I am too tied ignore me.
12:43:33 <alexj> tired.
12:43:39 <EvilTerran> hsplugin looks like what i'm after. i was thinking "i want my haskell program to be extendable... with haskell".
12:44:06 <dmwit> Yep, that's probably what you want,then.
12:44:12 <int-e> monochrom: anyway to solve the problem the way I want I'd have to construct a class dictionary directly. I think that's not possible without doing *really* dirty stuff, i.e. unsafeCoerce# and some dark rituals.
12:44:55 * xerox gets three black mana
12:45:06 <EvilTerran> schmrrr... that works with ghc, i see. okay.
12:46:02 <int-e> xerox: I'm afraid I understand what you mean.
12:46:10 <dmwit> EvilTerran: Every eval around uses *some* implementation of that language...
12:46:23 <EvilTerran> dmwit, yes, i know.
12:46:46 <EvilTerran> i had slightly disturbing visions of a pure-haskell haskell evaluator
12:47:06 <dmwit> EvilTerran: Guess what GHC is written in. ;-)
12:47:19 <EvilTerran> well, yes, but it is compiled
12:47:32 <EvilTerran> and surely it's not _all_ haskell
12:48:03 <dolio> Why not?
12:48:22 <mauke> maybe it's lupus
12:48:33 <EvilTerran> at some stage you've got to interface with the operating system...
12:48:41 <EvilTerran> mauke, hehe. house?
12:48:51 <mauke> @where house
12:48:51 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
12:49:32 <dolio> Well, a compiler just has to write out binaries of an appropriate format.
12:49:34 <dolio> In theory.
12:49:47 <dolio> I suppose parts of the runtime system might not be written in haskell.
12:50:50 <EvilTerran> well, you could write the whole compiler in pure haskell, but the IO module'll need something closer to the system in it, as would Graphics.HGL, etcetc
12:51:39 <dolio> Yeah. GHC uses GMP for its integers, for example, which is written in C, I imagine.
12:51:57 <mauke> oh, that reminds me
12:52:06 <mauke> is there a modpow function?
12:52:37 <monochrom> int-e: I agree with your assessment.  If you convert value to type-rep safely, there is no escape from logarithmic time.  If you use backdoors, there is more freedom.
12:52:40 <dolio> Not that I'm aware of.
12:53:19 <kolmodin> ClaudiusMaximus: xmonad-darcs ebuild in the gentoo overlay. works with >=ghc-6.4
12:56:44 <hpaste>  int-e annotated "reflecting Integers" with "motivating example for reflecting integers" at http://hpaste.org/1103#a2
12:57:01 <integral> mauke: GHC's normal pow uses an algorithm that's efficient if you use it on a type that's doing modular arithmetic
12:57:02 <SamB> *are* there any backdoors?
12:57:30 <int-e> SamB: if you can guess the right representation, maybe. implementation specific of course.
12:57:43 <mauke> integral: no, I need it for Integer -> Integer -> Integer -> Integer
12:57:54 <SamB> hmm...
12:57:55 <integral> mauke: well, that's just a trivial wrapper function away.
12:58:42 <dolio> ?src (^)
12:58:42 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:58:52 <SamB> I suppose data Nat# = Nat# { nat# :: foo, base# :: foo }
12:59:01 <SamB> or something like that
12:59:28 <int-e> SamB: yes. something like that. (and I wouldn't need the base# - that's just an implementation detail. it's the nat# I want.)
13:00:13 <SamB> int-e: yeah, I guess you could trash base at that point
13:00:30 <SamB> but I'm not sure what you'd put for foo
13:01:06 <int-e> SamB: hmm. a function, a -> Integer; or, in my case, just a newtyped constant.
13:01:28 <SamB> I guess just the underlying type of the newtype, then
13:01:30 <int-e> I'm rather happy with that Mark newtype trick - I actually get a constant into a class dictionary that way.
13:02:05 <int-e> which is evaluated exactly once per constructed dictionary.
13:03:08 <pafcu> Is it normal that Debug.Trace.Trace output doesn't show up if optimizations are turned on in GHC?
13:03:08 <int-e> ah maybe I'll just sit down and play with unsafeCoerce# a bit.
13:03:20 <SamB> now, to actually use that pseudo-dictionary... you'd need to unsafeCoerce something *very carefully*
13:03:49 <SamB> something which ordinarily has a type starting with "Nat n =>"
13:04:10 <int-e> an existentcial data type, I think.
13:04:16 <SamB> yes
13:04:33 <pafcu> It seems like only some of the trace output is shown when using -O, which seems strange to me
13:05:54 <SamB> pafcu: no. less evaluation happens when the code is optimized.
13:06:08 <SamB> (Isn't that the point of optimization?)
13:08:31 <pafcu> SamB: But I can see no reason why the code wouldn't be evaluated
13:08:47 <SamB> pafcu: well, perhaps it was floated out
13:08:52 <SamB> to the top level
13:09:01 <SamB> so that it only needed to be evaluated once
13:09:12 <alexj> kolmodin: just looked at the ghc docs.  "NOTE: the contents of OPTIONS_GHC are prepended to the command-line options, so you do have the ability to override OPTIONS_GHC settings via the command line."
13:09:42 <SamB> alexj: are there flags to turn off extensions?
13:10:27 <alexj> samb: good question looking.
13:11:00 <alexj> out of curiosity, in what contexts would you want extensions turned off.  do they cause harm?
13:11:54 <SamB> alexj: well, cabal would want to turn them all off (and then turn the listed-in-cabal-file ones on) to make sure that you weren't using any that weren't listed in the cabal file
13:12:21 <SamB> similarly to what it does with packages
13:12:22 <Igloo> alexj: Things like allowing overlapping instances may be unwanted
13:12:32 <Igloo> Or undecidable instances, if you like your compiler to terminate  :-)
13:13:27 <alexj> if you program compiles without the extensions.  will adding the extensions then cause it to fail?
13:13:31 <Igloo> I think all extensions have an -fno variant to turn them off
13:13:54 <Igloo> Ermm, it's rare that that would happen
13:14:12 <Igloo> Normally it'll be because an extension introduces a new sort of syntax so it gets parsed incorrectly
13:15:00 <alexj> do any of the common extensions break haskell98 code?
13:15:02 <Igloo> Extensions that fiddle with things like monomorphism and defaulting might mean compilation fails for typing reasons, I'd have to think about each in turn
13:15:05 * SamB wonders why GHCi is referring to base and haskell98 with no version number, but polyparse and ELF have version numbers
13:16:05 <SamB> alexj: I gathered that it was for the same reason as Cabal disallowing use of all packages not explicitly mentioned in the build-depends
13:16:32 <Igloo> SamB: GHC removes the version numbers for some packages that are wired in, so it only has to say base:Data.List.[] rather than base-2.1:Data.List.[]
13:16:33 <SamB> (i.e., keeping the cabal file is accurate)
13:16:36 <SamB> er.
13:16:41 <SamB> s/is //
13:17:36 <SamB> Igloo: eww
13:18:02 <alexj> ok.  but the point here is that cabal can turn off all the extensions and then turn on the ones it wants regardlesss of what is in the sourcefle so there is no reason not to put flags in the source file.
13:18:25 <alexj> am I missing something?
13:19:03 <xerox> int-e - prop x = x >= 0 ==> reflect x getNat == x
13:20:10 <int-e> xerox: I didn't want to import QuickCheck
13:21:01 <hpaste>  int-e annotated "reflecting Integers" with "doing it with unsafeCoerce# (for ghc)" at http://hpaste.org/1103#a3
13:21:08 <xerox> aye
13:22:41 <SamB> is that going to be removed when they get it so that you can build different versions of "base" with the same version of GHC?
13:22:48 <Igloo> alexj: People developing with cabal wouldn't necessarily keep the flags in the file up-to-date then. I'll write my mail to cabal-dev about it
13:22:48 <xerox> int-e: what do you gain by implementing type values?
13:23:39 <int-e> xerox: see the example: Num instances for rings Z/nZ for arbitrary n, fixed at run time.
13:23:43 <SamB> that elimination of the version number from "special" packages
13:24:23 <SamB> (besides perhaps the "reallybase" package, or whatever they call the place they put things that don't belong in *that* base
13:24:25 <SamB> )
13:24:28 <xerox> int-e: I see the example, I just wonder why they must be individually represented in the type system
13:24:39 <alexj> igloo: if the flags are there, I assume cabal can give warnings when flags are not up to date.  alternatively, if the flags are there, then you don't need t specify flags in the cabal file
13:25:35 <int-e> xerox: without resorting to unsafeCoerce# that does seem to be the only way to get the effect of the  reflect  function.
13:28:09 <int-e> xerox: well, I guess the answer is that if two types are equal, you get the same number out of  nat , so you need a type for each number.
13:30:02 <ndm> @seen Cale
13:30:02 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I don't know when Cale last spoke.
13:31:04 <Ashsong> I have a question about people's favorite debugging techniques. More specifically, how do you like to inspect intermediate results of somewhat-involved computations when you're trying to track down an error?
13:31:33 <SamB> Ashsong: well, I'd prefer not to have to do that.
13:31:34 <chessguy> Ashsong, don't you think that depends a lot on the particular code and the particular error involved?
13:31:35 <ndm> Ashsong: trace
13:31:39 <SamB> but if I have to do that, Debug.Trace
13:31:51 <ndm> Ashsong: i would use Hat, but its too broken (/me hopes a SoC project will fix that)
13:32:50 <Ashsong> chessguy: Actually, no. I'm working on a toy problem which I can certainly solve by brute force techniques. I wanted to talk to the community about finding something that would scale better.
13:33:29 <SamB> Ashsong: you use the simplest way that is not too simple, usually...
13:33:44 <SamB> at least, that you can think of
13:34:04 <chessguy> which...depends on the code and the error
13:34:06 <Ashsong> ndm: I considered it, but it has some limitations that bother me. In particular, I want to do some non-string based output.
13:34:15 <xerox> int-e: and this stuff also happen to be fast?
13:34:17 <ndm> Ashsong: as a community, we suck at debugging
13:34:21 <SamB> It has some things that bother me, too
13:34:33 <SamB> like, the tendancy of the viewer to crash...
13:34:38 <SamB> (or is that not there anymore?)
13:34:56 <Ashsong> ndm: I disagree. As a community, we've structured Haskell to allow for effective debugging-by-mental-simulation.
13:35:23 <ndm> Ashsong: we have a good language, thats no excuse for not having a debugger
13:35:32 <SamB> the trouble is we also get the nastiest bugs
13:35:39 <ndm> SamB: hat just whines like a 2 year old at everything
13:35:54 <int-e> xerox: well, for all the hoops it goes through I was quite happy to be able to reflect a 15k digit number in 0.1 seconds.
13:36:01 <ndm> SamB: we suck at debugging head [], thats not a nasty bug
13:36:04 <SamB> ndm: when I was trying it, the trace viewer crashed on me a lot
13:36:15 <Ashsong> ndm: My point is, in my experience, I fix bugs in my Haskell programs by reasoning about fragments of execution traces.
13:36:18 <ndm> SamB: everything about hat crashes, the question is where
13:36:23 <SamB> hmm, well, okay, head [] is not a particularly nasty bug
13:36:25 <int-e> xerox: which is acceptable for what I used it for - the actual calculation took 3 minutes.
13:36:31 <SamB> maybe it does head []
13:36:33 <ndm> Ashsong: yes, but i think thats because we lack debuggers
13:36:37 <SamB> except with a Ptr
13:36:44 <ddarius> SamB: -No- we don't.
13:37:15 <SamB> ddarius: hmm?
13:37:29 <Ashsong> ndm: I still respectfully disagree. I think it's because we're basically doing math. The task is very similar to finding holes in proofs.
13:37:36 <ddarius> I've never had a bug in a Haskell program that is anywhere near as nasty as the ones I have had in C++.
13:37:44 <ddarius> I don't think that is particular to me.
13:37:49 <SamB> ddarius: oh, well. a different kind of nasty bug.
13:38:09 <ndm> Ashsong: i think if people could automatically have a tool for debugging mathematical proofs, they would - i suspect that because maths proofs are not (usually) formal
13:38:35 <Ashsong> At least for mis-designed pure code, which is all I'm dealing with at the moment, we're basically asking: "Does this collection of equations compute what I want? If not, where is the first difference?"
13:38:45 <SamB> yeah, the debugger support for english is pretty damn lousy
13:38:50 <Ashsong> The style of reasoning is the same.
13:38:53 <jacobian> debugging purely functional lisp code in CMUCL is nicer than haskell in my opinion.  Unfortunately writing purely functional code in CMUCL is 10*harder than in haskell.
13:39:00 <ndm> Ashsong: i agree that debugging by reasoning is useful, but i think there is still scope for tool support - rather than reasoning what happens in a particular case you can see if that case occured, and if it did, what hte answer was
13:39:16 <Ashsong> ndm: No argument at all. I'm just explaining what problem I'm working on here. :)
13:39:16 <SamB> ndm: tools to help with reasoning are lovely.
13:39:24 <SamB> witness typecheckers ;-)
13:39:31 <ndm> Microsoft has the best debuggers, English and programming!
13:39:35 <ddarius> So, jacobian, does it come to a wash or what?
13:39:43 <jacobian> I prefer haskell
13:39:44 <SamB> ndm: that isn't a debugger. that is a lint tool.
13:39:44 <ndm> Ashsong: yes, i know what you are saying, and agree that it saves haskell
13:40:06 <ddarius> jacobian: And eventually Haskell will have nice(r) debugging tools...
13:40:15 <xerox> int-e: I forgot, is it right to call n phantom type?
13:40:22 <int-e> xerox: yes
13:40:26 <jacobian> yup, and I'm banking on it, but it shouldn't ignore the fact that things could improve
13:40:31 <Ashsong> ndm: Great. So what I'd like to talk about next is good techniques for reifying execution traces so that I can better inspect them.
13:40:48 <Ashsong> See, I've found that this problem comes up in every kind of programming I do.
13:41:12 <Ashsong> In C++, you see great big logging frameworks with fancy channels or logging levels in order to filter out the mess - to let you zoom in on the fragment you want to examine.
13:41:16 <ndm> Ashsong: have you seen Hat?
13:41:20 <SamB> xerox: phantom types are types which (in a given usage) do not actually type any values that matter
13:41:32 <ndm> Ashsong: when i say debugging, thats exactly what i mean in Haskell - not the typical breakpoint debugging
13:41:53 <Ashsong> ndm: Not in great detail. I had a lot of difficulty installing it the last time I tried. Also, I think it solves a different problem than the one I'm interested in. But please correct me if I'm wrong.
13:42:04 <ddarius> SamB: A better way to say that, in my opinion, is that they are type parameters that are completely independent of the structure of the data type.
13:42:20 <SamB> ddarius: yeah, perhaps
13:42:26 <ndm> Ashsong: it does the logging thing, no one can install it, once you do it never works - but in principle i think it may solve what you are after
13:42:32 <jacobian> debugging in CMUCL is probably the most enjoyable experience I've ever had, since you can step up through the function stack and look at local variables and even perform computations on them.
13:42:33 <SamB> well. what if a function takes a phantom argument?
13:42:54 <ddarius> SamB: Is A -> B not a data type?
13:42:58 <Ashsong> ndm: Anyway, a different style, supported by Mathematica, Excel, and Subtext is to basically to compute the intermediate results in cells, then to link up the cells appropriately.
13:43:29 <ddarius> jacobian: O'Caml is supposed to have a nice debugger (I hear, I've never really used O'Caml)
13:43:37 <xerox> int-e: nice work
13:43:37 <SamB> ddarius: well, it isn't that (->) doesn't care about a parameter
13:43:56 <procyon_> I can't see that it would be too hard to have a zero optimization compile, and then trace the evaluation of the abstract syntax tree, step by step, and tie that back to the code.
13:44:04 <SamB> so much as that a given function doesn't actually use the value of a parameter
13:44:14 <dylan> ocaml's debugger has time travel power.
13:44:16 <Ashsong> procyon_: You can do that, but there are some obvious problems.
13:44:25 <ddarius> SamB: To an extent, arguably the "structure of the data type" does.
13:44:31 <Ashsong> procyon_: Too much data is the biggest one, I think.
13:44:54 <ndm> procyon_: its a nice theory, but what does zero optimisation mean?
13:44:56 <SamB> ddarius: well, I mean, it only uses the type
13:44:57 <Ashsong> ndm: Anyway, it occurred to me that there are a lot of other people who work on problems related to this. The people doing randomized testing, and those doing code coverage, for example.
13:44:58 <ddarius> jacobian: Also, Smalltalk's debugging system (or rather the whole system) is interesting.
13:45:17 <procyon_> Ashsong: Lots of data is a problem, but you can hide that by stepping through it in a tool like a core file analyzer.
13:45:32 <ndm> procyon_: what do you think f x y = g z where g i = x + i gets turned into
13:45:51 <ndm> procyon_: unless you know the meaning of the phrase lambda lifting, you'd be in for a shock ;)
13:46:02 <procyon_> ndm: zero optimization in that there are no AST transformations going on.
13:46:03 <Ashsong> procyon_: Perhaps. A better solution, I think, is to only generate the data you need. Remember that I'm working with pure functions here which simply fail to compute what I want them to compute.
13:46:41 <SamB> procyon_: well, kinda hard to desugar then...
13:46:41 <ndm> procyon_: how do you compile a pattern match without optimisations? i don't know of any compiler for Haskell thats anywhere near that - its basically writing a new compiler
13:46:43 <Ashsong> procyon_: Most of the time, I just want them to run happily along with full optimization. Only some times, I want more detail.
13:46:46 <ddarius> For a totally different perspective on debugging certain types of errors (not for Haskell though): http://citeseer.ist.psu.edu/cadar06exe.html
13:46:50 <lambdabot> Title: EXE: A System for Automatically Generating Inputs of Death Using Symbolic Execut ...
13:47:20 <mauke> what's lambda lifting?
13:47:28 <alexj> igloo: it has to be okay to have all extensions turned on otherwise specifying them in the cabal file wouldn't work because some modules could be incompatible with extensions required by other modules in the same package, right?
13:47:34 <ndm> @google lambda lifting
13:47:36 <lambdabot> http://en.wikipedia.org/wiki/Lambda_lifting
13:47:36 <lambdabot> Title: Lambda lifting - Wikipedia, the free encyclopedia
13:47:41 <ndm> mauke: ^^^
13:47:50 <xerox> mauke: putting toplevel definition into where clauses
13:47:54 <Igloo> alexj: You lost me
13:47:56 <SamB> hmm.
13:48:04 <ddarius> mauke: Getting rid of (some) lexical scoping by passing closed over variables in as parameters (thus "lifting" the lambda up lexically)
13:48:06 <SamB> GHCi in 6.6 doesn't do file completion anymore?
13:48:10 * SamB thinks this is annoying
13:48:26 <Igloo> alexj: In practice its rare that an extension will break anything, anyway
13:48:27 <alexj> with cabal you specify the extensions to use for compiling every module in the package, right?
13:48:28 <ndm> SamB: its a bug, that will be fixed shortly
13:48:40 <Igloo> alexj: Right (except as overridden by pragmas)
13:48:42 <SamB> now, obviously this is because it now actually does something regarding completion
13:48:43 <SamB> but...
13:49:03 <alexj> except command line options actually supercede pragmas according to the ghc docs.
13:49:26 <Cale> ndm: hello
13:49:32 <alexj> so the cabal assumption is that no module will be hurt by having any particular extension turned on.
13:49:33 <Cale> looking for me?
13:49:42 <Igloo> alexj: Ah, yes, true
13:49:48 <ndm> Cale: yes, going to see if we could agree on a common zeroText/control name on IRC
13:50:03 <Igloo> aking: Well, any extension used by the package
13:50:10 <ndm> Cale: i don't like control because of the Control.Monad heirarchy - suggests the wrong thing
13:50:10 <Ashsong> ndm: I'd gotten this far in my reasoning. My question basically turned into: "How to represent the simulation" so that I can extract refer-to and extract intermediate results as needed without remembering the intermediate results unless asked for.
13:50:14 <Igloo> Sorry, that was meant to go to alexj
13:50:16 <SamB> alexj: well, at least, that you shouldn't have such code in a package that uses such an extension
13:50:17 <Cale> ah, that's a good point
13:50:37 <ndm> i'm not overly tied to the name zeroText, but couldn't think of anything better
13:50:39 <procyon_> In my perfect debugger world, zero optimizations would mean that pattern matches are expressed as cases, and lambda lifting is not allowed... basically, haskell is parsed into a single root AST and evaluation is stepped through normal order.  It would be slow, but it would be functually equivelent to what GHC does, without hiding any steps from the observer.
13:51:06 <ndm> procyon_: i think you underestimate how hard that would be - much of haskell is only defined as a translation to a lower level
13:51:07 <kc5tja> @seen dolio
13:51:07 <lambdabot> dolio is in #haskell. I last heard dolio speak 52m 25s ago.
13:51:14 <alexj> igloo: yes, but you don't want a cabal build to break because you added some haskell file that requires an incompatible set of extensions.
13:51:17 <procyon_> let and where could be inlined for the debugger
13:51:20 <Ashsong> procyon_: Subtext works much like that.
13:51:30 <ndm> i don't like out-of-band though, sinec that requires you to know networking protocols
13:51:30 <Cale> ndm: I'm not overly tied to control either, I was just adding a data point to the discussion.
13:51:50 <Cale> Yeah, oob is a bad name. Perhaps 'invisible'?
13:51:50 <kc5tja> Cale: Just the person I need to speak to.
13:51:52 <ndm> Cale: just wondering if we could come up with something better still
13:51:53 <alexj> so cabal must implicitly believe that it is ok to turn every extension on all the time.
13:52:03 <Igloo> alexj: Well, that's the situation we're currently in (but as I said, it's rare that any breakage will occur)
13:52:09 <ndm> Cale: invisible is possibly the best out of all of these
13:52:10 <kc5tja> Cale: May I send you a text file for review?
13:52:11 <procyon_> ndm: baskell does that, albeit on a not-quite-haskell-complexity scale.
13:52:23 <Igloo> alexj: And it can always be fixed by tweaking the source slightly
13:52:26 <Cale> kc5tja: hm? Uh, okay.
13:52:38 <kc5tja> Cale: Can you /msg me your e-mail address?
13:52:52 <ndm> procyon_: i think its possible, and might be ideal, but could be a lot of work - esp in the details
13:53:06 <xerox> Cale, don't eat too many homeworks :D
13:53:11 <ndm> procyon_: plus what do you do when GHC adds a new feature? since you take the whole AST you have to add it as well, a nightmare
13:53:26 <procyon_> ndm: the devil is always in the details.. which is why I'm chatting about it on IRC instead of writing it ;)
13:53:40 <alexj> igloo: the fix would involve telling cabal not to use extensions specified in the cabal file but instead to rely on language pragmas OR it would entail a change to cabal file format that allowed per module specification of extensions.
13:53:49 <alexj> that doesn't seem so minor.
13:56:09 <SamB> hmm.
13:56:19 * SamB wonders why this "polyparse" thing uses lists
13:56:58 <SamB> ndm: do you know anything about polyparse?
13:57:15 <ndm> SamB: malcolm wrote it, i know not much else
13:57:36 <SamB> well, yes, I gathered that from the URL ;-)
13:57:56 <dolio> kc5tja: You rang?
13:58:23 <kc5tja> dolio: Yeah; I was wondering if you wanted to review the monad document I was writing today.
13:58:33 <dolio> I can do that.
13:58:51 <SamB> ndm: it doesn't seem like a particularly efficient basis for parsing ELF files
13:59:04 <Igloo> alexj: Before I send it, what do you think of http://urchin.earth.li/~ian/language.txt ?
14:00:49 <alexj> thats funny, I was writing something similar.  hang on and I'll send you mine.
14:01:11 <Ashsong> Igloo: There's a typo: "Ciritcisms" just above the signature.
14:01:27 <Igloo> Ashsong: ta
14:03:53 <alexj> igloo: just emailed you the message I was about to post to the haskell list.
14:06:13 <alexj> igloo: I like your proposal a lot.  it makes a lot of sense.
14:06:26 <alexj> but I'm sure you could have guess that.
14:06:35 <alexj> s/guess/guessed/
14:07:38 <alexj> our mails cover the same material but are different enough that we could probably send both.
14:07:49 <alexj> do you agree or should we merge the content in some way?
14:08:56 <hpaste>  int-e annotated "reflecting Integers" with "using unsafeCoerce# more directly" at http://hpaste.org/1103#a4
14:09:28 <Igloo> alexj: I think separate is fine, I really just wanted to make sure that you agreed that my proposed changes would satisfy your needs
14:10:52 <alexj> well technically what I want is to force module authors to put the required flags in the modules themselves.  Your proposal doesn't actually do that it just prevents them from using the cabal file for that purpose instead.
14:11:12 <alexj> what I really want is for the compiler writers to turn off command line flags to specify extentions.
14:11:14 <int-e> SamB: in the end it turns out that using an existencial type is not necessary. :)
14:11:30 <SamB> int-e: what about unsafeCoerce#?
14:11:50 <Igloo> alexj: With my proposal you couldn't build a module with Cabal if you don't have appropriate LANGUAGE pragmas in it
14:11:52 <kolmodin> Igloo: your proposal makes sense, it's more or less how packages are used in cabal
14:12:02 <int-e> SamB: I'm using unsafeCoerce# now.
14:12:58 <kolmodin> not all flags turns on extensions though, how would -fliberate-case-threshold=1000 be handled?
14:13:05 <ddarius> Since you are still using rank-2 types, in certain respects you have not really saved much.
14:13:21 <Igloo> kolmodin: Not an extension, so can go in Ghc-Options
14:13:22 <alexj> igloo: true but not everyone uses cabal.  I fully support having cabal work that way and think most people wil handle that change in the manner I want.  I am just saying that the actual correct answer is to turn off the feature in the compilers.
14:13:29 <SamB> kolmodin: hmm, well, you could just have it -fzap-extensions or something...
14:13:44 <int-e> ddarius: who me?
14:13:53 <ddarius> int-e: Yes you.
14:13:55 <SamB> Igloo: I think he meant in GHC_OPTIONS
14:14:03 <SamB> or whatever
14:14:06 <SamB> OPTIONS_GHC
14:14:15 <int-e> ddarius: I didn't want to get rid of the rank-2 types. what I want isn't even expressible without them.
14:14:21 * SamB never did understand the reasoning behind calling it OPTIONS_GHC
14:14:40 <Igloo> Oh, OPTIONS_GHC would be better than Gghc-Options, true
14:15:01 <Igloo> Sent, anyway
14:15:36 <ddarius> SamB: Perhaps you should read it as OPTIONS<sub>GHC</sub>
14:15:56 <SamB> but, I think his question boils down to "how do we tell the difference between -fglasgow-exts and -funpack-strict-fields"
14:16:06 <hpaste>  ramas pasted "mano cipheris" at http://hpaste.org/1104
14:16:14 <SamB> ddarius: I still think GHC_OPTIONS would make more sense
14:16:51 <ddarius> SamB: I was joking, but taking that view the pragma would be one of a compiler indexed collection of OPTIONS.
14:17:04 <SamB> well.
14:17:22 <SamB> personally, I think compilers should be given their own namespaces for options
14:18:00 <int-e> does GHC's language extension of allowing # in variables have a name?
14:18:19 <SamB> -fglasgow-exts
14:18:25 <int-e> (for the LANGUAGE pragma)
14:18:32 <SamB> dunno!
14:18:44 <SamB> should be something like SharpPointyThings
14:19:21 <EvilTerran> allow-octothorpes
14:19:24 <EvilTerran> i dunno
14:19:28 <mauke> -foctothorpe-is-a-letter
14:19:33 <Ashsong> Thanks for the thoughts on my question, everyone.
14:19:43 <EvilTerran> that'd be a problem, actually; no-one would be able to agree on the name of the character
14:20:03 <EvilTerran> and calling it "-f#-is-a-letter" would feel vaguely circular
14:20:28 <SamB> DangerWillRobinson?
14:20:34 <shapr> danger!
14:20:49 <EvilTerran> danger! high voltage!
14:20:54 <mauke> hmm, gcc uses -fdollars-in-identifiers
14:21:02 <SamB> anyway, the # denotes "sharp!"
14:21:13 <mauke> just call it "pound"
14:21:18 <SamB> it means "sharp"
14:21:19 <dmhouse> Or "hash"?
14:21:30 <mauke> as in C-Pound
14:21:30 <SamB> notice how it is used on all these dangerous functions
14:21:34 <SamB> like unsafeCoerce#
14:21:43 <shapr> SamB: Yeah, that's why Microsoft calls that language C#
14:21:47 <dmhouse> mauke: isn't that C-Sharp (as in the musical note?)
14:21:59 <dmhouse> shapr: hehe :)
14:22:02 <shapr> dmhouse: Or as I like to say, the D-flat language.
14:22:09 <shapr> De Flat Language...
14:22:10 <int-e> and (+#)
14:22:18 <mauke> http://worsethanfailure.com/Articles/5_years_C-pound_experience.aspx
14:22:20 <lambdabot> Title: 5 years C-pound experience - Worse Than Failure, http://tinyurl.com/23z85x
14:22:25 <SamB> (#+) I think I've seen
14:22:25 <EvilTerran> sharp us U+266F
14:22:30 <SamB> (+#), no.
14:22:38 <EvilTerran> s/us/is
14:22:42 <SamB> oh, is that an illegal section?
14:22:50 <dmhouse> SamB: it should be the latter; # is appended to identifiers to indicate unboxed types.
14:23:13 * SamB was thinking of common lisp's feature test macros
14:23:51 <SamB> okay, that is valid...
14:23:55 <EvilTerran> the unicode consortium calls U+0023 "NUMBER SIGN"
14:24:17 <int-e> ddarius: Oh I guess you meant that I didn't win much compared to using the existencial type. Yes, that's right of course. I just make the optimizer's job a little bit easier.
14:24:20 <SamB> I don't think the unicode consortium should be deciding what we call things ;-)
14:24:34 <int-e> ddarius: and save some code.
14:25:27 <EvilTerran> goes on to list other names as "pound sign, hash, crosshatch, octothorpe"
14:25:42 <twb> Octothorpe has always been my favourite.
14:25:54 <kc5tja> And don't forget the @ symbol: cinnamon buns!
14:26:01 <EvilTerran> i tend to say "hash", personally. it's short, and it opens the road for such delightful puns as "#|".
14:26:07 <EvilTerran> (it's a hash pipe)
14:26:20 <twb> It's a sword!  It's only a pipe in sh.
14:26:26 <EvilTerran> and who could forget the unix "shebang".
14:26:30 <dmhouse> http://www.bugbash.net/comic/12.html :)
14:26:34 <lambdabot> Title: Bug Bash
14:26:50 <SamB> octothorpe -- isn't that those creatures in Zelda?
14:27:02 <shapr> Hiya sigfpe!
14:27:16 <dpiponi> hello shapr
14:27:38 <EvilTerran> twb, U+2020 is a dagger. I don't think i've ever heard anyone call "|" a sword, tho
14:27:47 <dpiponi> shapr: what's new?
14:27:52 <twb> Maybe it's from nethack
14:27:54 <EvilTerran> I tend to call it either pipe or bar
14:28:22 <EvilTerran> or "shift-backslash" for the non-programmers :P
14:28:46 <dmhouse> EvilTerran: hehe, yep :)
14:29:12 <EvilTerran> but then they reply "which one's backslash?", and i end up beating them with their keyboard.
14:29:30 <SamB> twb: aren't the swords shaped like ) or (?
14:29:36 <twb> Dunno
14:29:37 <SamB> I'm obviously not a very avid nethacker
14:29:43 <EvilTerran> SamB, i thought ) was bows...
14:29:44 <procyon_> The correct pronunciation of "C#" is "coctothorpe"
14:29:44 <twb> I was always a zangband dude
14:29:48 <mauke> | is obviously AltGr+<
14:29:51 <twb> procyon_: fuck yes!
14:30:02 <SamB> what is AltGr again?
14:30:03 <twb> procyon_: that's going in my fortune file
14:30:11 <procyon_> :)
14:30:19 <twb> SamB: it's one of the eighteen mod keys on a space cadet keyboard
14:30:25 <mauke> the key between <space> and <win_r>
14:30:40 <SamB> twb: where do I get "X for space cadets"?
14:30:40 <twb> SamB: it's the same as what Meta does on MacOS
14:30:53 <SamB> I think my X only has 6 or possibly 7 mod bits!
14:31:11 <twb>  <-- like that
14:31:27 <mauke> yay, I can see that
14:31:57 <EvilTerran> it's mostly the same as Ctrl+Alt on 'doze, afaict
14:33:27 <EvilTerran> altho AltGr+Del doesn't work.
14:34:27 <hpaste>  shapr pasted "xml example, missing instances" at http://hpaste.org/1105
14:40:56 <shapr> dpiponi: LOTS of new code for HAppS the last week, and likely more over the next two days.
14:43:30 <dpiponi> shapr: Is there a summary of what HAppS is about that doesn't involve a lot of scary acronyms? :-)
14:44:45 <hpaste>  shapr annotated "xml example, missing instances" with "xml example updated" at http://hpaste.org/1105#a1
14:45:10 <shapr> dpiponi: It's a web application server.
14:45:31 <shapr> It include lots of useful functionality for building webapps.
14:45:37 <dpiponi> shapr: so where's a web application I can try out?
14:45:43 <shapr> http://hpaste.org/
14:45:49 <shapr> That's built on top of HAppS.
14:46:07 <dpiponi> shapr: Cool!
14:46:27 <shapr> I built a wiki on top of HAppS in three evenings, that was nifty.
14:46:40 <shapr> I don't know if it still works though, in the meantime I got hired to work on HAppS and much has changed.
14:48:06 <shapr> The next step up in simple descriptions is that HAppS lets you define a state type, mappings to XML and from POST and GET for that state type, and then you give it a list of cases to try whenever that app gets a request.
14:48:12 <shapr> That's pretty much how you build an app in HAppS.
14:48:40 <stepcut> shapr: spiffy
14:48:42 <shapr> I'm hacking on a not-quite-complete example for the tutorial right here - http://hpaste.org/1105#a1
14:49:01 <twb> Does hpaste only grok Haskell markup?
14:49:48 <shapr> Among the many changes hoped to be in HAppS, alexj is working on getting the state to be an HList. The plan is for both the state and cases of an application to be easily concatenable with other HAppS applications.
14:50:05 <shapr> But the cool future plans for HAppS are too numerous to easily describe.
14:50:25 <shapr> The cool present functionality is also extensive.
14:50:39 <shapr> twb: As far as I know, yes.
14:50:45 <shapr> twb: But you could grab the source and fix that.
14:51:44 <shapr> dpiponi: I can probably clear up any scary acronyms too, if you wish.
14:52:11 <shapr> Though alexj is the dreamer and brain behind HAppS.
15:08:40 <sorear> hello!
15:09:20 <dpiponi> shapr: It's all the standard jargon stuff that I'm ignorant about. I don't have to do anything with XML, say in my job.
15:12:51 <shapr> dpiponi: Some of the motivations behind the acronyms are stuff like "We don't want a user to pay by credit card and then have the recording of that payment get lost"
15:14:00 <dpiponi> shapr: That's ACID right?
15:14:14 <ehird> dpiponi: That's atomic transactions, no?
15:14:18 <ehird> Correct me if i'm wrong
15:16:07 <dpiponi> ehird: The A in ACID stands for "Atomicity".
15:16:09 <augustss> Mr Piponi! :)
15:16:11 <twb> ehird: you're right.  ACID is a set of four requirements (the first being atomicity) that are regarded as critical for a persistence mechanism (read: database).
15:16:59 <ehird> (atomicity should probably be regarded as critical for a LOT more things than it is...)
15:17:47 <dpiponi> augustss: hello August Lennartsson (that's my mental nickname for you, for some reason by brain keeps transposing parts of your name).
15:17:58 <shapr> heh
15:18:06 <shapr> My brain just has nightmares about Lennart!
15:18:09 <twb> ehird: you take a huge performance hit for it, though.  That's why MySQL and most filesystems aren't atomic.
15:18:32 <twb> I'm curious: is there an "Erlang in Haskell" project a la Termite Scheme?
15:18:47 <augustss> Oh well, better than my boss's boss's boss who calls me "The Swedish Computer Scientist"
15:18:57 <ehird> twb: considering hardware specs of today, I think atomicity of most things is feasible
15:19:00 <sorear> Write yourself a erlang in 48 hours :)
15:19:09 <ehird> we could all write in asm, but there's a reason we don't :)
15:19:27 <twb> ehird: probably because you don't grasp what "most things" includes.
15:19:42 <sorear> your boss' boss' boss refers to you specifically.  I suppose that by itself is an upside...
15:19:45 <dpiponi> augustss: did you enter the ioccc this year?
15:20:35 <augustss> dpiponi: no, I didn't even look at the rules.  I need to have some good idea so I can make a great come back in IOCCC
15:20:59 <monochrom> It is possible to have fast atomicity. The algorithms are advanced. Most people who know such algorithms are theorists.
15:21:09 <augustss> But you are allowed so many characters these days
15:21:13 <Heffalump> augustss: did you sort out your complex numbers?
15:21:31 <shapr> monochrom: You should write a TMR article and explain it to those who aren't theorists!
15:21:38 <augustss> Heffalump: yes, it worked once I defined my own atan2
15:21:39 <twb> monochrom: as usual, researchers are lightyears ahead of industry :-/
15:21:46 <Heffalump> cool
15:22:02 <twb> Some people still use Java
15:22:04 <z0d> Hello.
15:22:05 * Heffalump needs to work out to calculate great circles efficiently from longitude and latitude
15:22:08 <sorear> twb: isn't the defining characteristic of researchers the use of haskell?
15:22:24 <shapr> You could always steal the last IOHCC winner's idea and write a MetaSteganographic Obfuscator in C.
15:22:26 <twb> sorear: maybe that's been the case for the last two decades
15:22:35 <z0d> Is there a Haskell for Windows Mobile 5?
15:22:37 <augustss> Heffalump: why efficiently?  nobody cares anymore
15:22:38 <twb> sorear: I doubt aristarchus used Haskell, for example.
15:22:39 <roconnor> Heffalump: vectors!
15:22:51 <sorear> z0d: why not?
15:22:53 <monochrom> I had to take two courses to learn the algorithms. And afterwards I slowly forgot them...
15:23:04 <sorear> z0d: does windowes mobile 5 support ANSI C?
15:23:04 <roconnor> Heffalump: cross products!
15:23:27 <augustss> cross products!  we discussed them at work today
15:23:30 <shapr> dpiponi: BTW, HAppS has MACID, monadic ACID support.
15:23:33 <Heffalump> I care, I have GPS traces each with several thousand points in them
15:23:42 <Heffalump> and a slow laptop
15:23:50 <pejo> Heffalump, you trying to do it in real time?
15:23:52 <shapr> I'm just cross and unproductive.
15:23:59 <Heffalump> pejo: not yet, but I will be, probably
15:24:08 <procyon_> augustss: so did we!  We had to make this dam wizard work 'cross products.
15:24:13 <pejo> Heffalump, software GPS?
15:24:16 <Heffalump> at which point it'll be on an even slower Palm
15:24:36 <Heffalump> pejo: software GPS in what sense? I have a device that tells me lat/lon, I want to do stuff with it.
15:24:53 <augustss> sigfpe:  I'm eagerly awaiting your nest installment of quantum Haskell.  you are just beyond what I did when I fiddled with quantum computing in haskell, so I can still kinda follow what's happening
15:25:47 <sorear> I'm still waiting for an explanation of the double cover of SO(3) I can actually understand.
15:25:50 <dpiponi> augustss: I was going to take a digression into mathematics and physics to explain the theta/2 in my rotate function. But it'll take a while to write up.
15:25:55 <sorear> or was it SO(2)?
15:26:03 <dpiponi> sorear: That's exactly what I'm talking about! Are you reading my mind.
15:26:08 <augustss> it's interesting how cross products can be trivial in some languages (e.g. Haskell) and difficult enough in others to probably merits a design pattern (Nested Loops!)
15:26:14 <z0d> sorear: I don't know, but Pocket Scheme runs on it.
15:26:25 <sorear> in any event, it's something that becomes sour when it hits water :)
15:26:28 <Delta-Force> hi
15:26:39 <Delta-Force> I nee some help in outputing the result of a function into a string
15:26:48 <Heffalump> show
15:26:57 <sorear> :t show
15:26:59 <lambdabot> forall a. (Show a) => a -> String
15:27:08 <augustss> > show 5
15:27:12 <lambdabot>  "5"
15:27:14 <dpiponi> sorear: I've already started to write an explanation of universal and double covers in a way that a kid could understand.
15:27:20 <Delta-Force> parse :: RegExp	-> String -> Maybe(String,String)
15:27:20 <Delta-Force> parse _ [] = Nothing
15:27:20 <Delta-Force> parse (Chr tmp ) (x:xs)
15:27:20 <Delta-Force>             |tmp == x      = Just([tmp], xs)
15:27:20 <Delta-Force>             |otherwise     = parse (Chr tmp) xs
15:27:20 <Delta-Force> parse Any (x:xs) = Just ([x],xs)
15:27:22 <Delta-Force> parse (exp1 :>: exp2) (x:xs)
15:27:24 <Delta-Force>             |(parse exp1 (x:xs)) == Nothing          = Nothing
15:27:26 <Delta-Force>             |(parse exp1 (x:xs))
15:27:36 <dpiponi> sorear: (Though I qualify what I mean by 'kid' a little bit.)
15:27:50 <procyon_> augustss: We've decided to move out Christian Bookstore website to HAppS because we heard that Haskell was so much better at handling cross products.  /ducks
15:28:04 <sorear> dpiponi: how does 16 and hs-junior in a ld school sound? :)
15:28:27 <Delta-Force> my output is in the format of JUST ([char],STRING)
15:28:34 <Delta-Force> now somehow I need that STRING, for reusabililty
15:28:49 <dpiponi> sorear: We'll have to see!
15:29:00 <augustss> Procyon_: ugh!
15:29:07 <sorear> Delta-Force: generally hpaste is preferred for pastes, because it doesn't get interleaved with conversations
15:29:11 <sorear> @paste
15:29:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:29:41 <Delta-Force> ik'm sorry
15:30:01 <kpreid> Delta-Force: if you have a possibly-failing parse result, use case to handle the success and failure cases
15:30:05 <hpaste>  Delta pasted "Delta assignment" at http://hpaste.org/1106
15:30:16 <augustss> sorear: when it comes to understanding weird shit we'll just have to not count you.  You skew the statistics
15:30:17 <siti> is there a haskell data structure for basically an ordered list?  what I need is something that takes up almost no memory, e.g. a map consumes to much, also I don't mind O(N) update...
15:30:26 <Delta-Force> i'm in a begginers course of haskell
15:30:30 <Delta-Force> so don't be to hard on me :)
15:30:34 <kpreid> Delta-Force: There are other ways, but case is usually suitable
15:30:47 <sorear> siti: map doesn't use much memory
15:30:53 <Delta-Force> i tried using expression into IO
15:30:55 <procyon_> Delta-Force: use pattern matching to get it back out again.. case result of (Just (_,x))->x
15:30:59 <Delta-Force> parseOut :: RegExp -> String -> IO()
15:30:59 <Delta-Force> parseOut exp str = putStr(parse exp str)
15:31:02 <sorear> siti: a plain list takes 12 bytes overhead, per element
15:31:05 <Delta-Force> but i got an error
15:31:10 <sorear> siti: a map takes <checking>
15:31:10 <siti> that's to much
15:31:21 <EvilTerran> siti, you could maintain a sorted array manually
15:31:34 <EvilTerran> dunno how memory-intensive that'd be
15:31:39 <siti> yeah I am trying to figure out haskell arrays but they are confusing
15:31:53 <siti> especially with updating them using a sorted list
15:32:11 <sorear> siti: map --> 24 bytes/key
15:32:14 <siti> when it's sorted*
15:32:28 <sorear> siti: [(a,b)] --> 24 bytes/key
15:32:31 <pejo> augustss, the rest of us skew the statistics back!
15:32:36 <sorear> wow, that's interesting
15:32:59 <Delta-Force> can I speak to someone peronally on my problem/
15:33:00 <sorear> if you want small, an array has 8 bytes/pair overheat
15:33:05 <siti> ok
15:33:14 <siti> I think I will keep trying to figure out array...
15:33:25 <EvilTerran> siti, haskell is memory intensive. it's punishment for being so nice to use.
15:33:33 <EvilTerran> buy a RAM upgrade. :P
15:33:54 <siti> I have 2GB of memory, it's for a project with alot of data
15:34:04 <sorear> siti: rethink
15:34:06 <kpreid> Delta-Force: it should be something like parseOut exp str = case parse exp str of ... -> putStr result
15:34:19 <sorear> siti: do you really need to have all your data in ram at once?
15:34:34 <procyon_> Is there no packed data structures with no overhead?!?
15:34:50 <sorear> procyon_: no.
15:34:52 <siti> yes, because I want it fast, and also a fast development time so I don't want to touch the disk
15:34:54 <twb> EvilTerran: yesterday johnw was complaining that Java needed 8GB (he "only" had 3GB)
15:35:05 <twb> ...and that was just to run the IDE
15:35:05 <sorear> procyon_: well, UArray, but that's not general
15:35:25 <EvilTerran> twb... 8GB of RAM? O.o
15:35:43 <procyon_> And that
15:35:47 <sorear> I use asm.  <10k
15:35:51 <SamB> WHAT IDE USES 8GB OF RAM?
15:35:55 <siti> lol
15:35:59 <procyon_> Eclipse
15:36:02 <siti> not even eclipse uses that
15:36:03 <siti> :p
15:36:05 <twb> SamB: intellij something, I think he said
15:36:14 <siti> it's the borland one
15:36:17 <Gu1> holy toledo that is alot of ram
15:36:19 <siti> together
15:36:25 <EvilTerran> siti, surely you can cache the bits you need a lot or something? think up an algo that doesn't need all the data at once...
15:36:28 <SamB> I only have 256 MB on this machine
15:36:35 <monochrom> Any IDE can be convinced to use 8GB of RAM.  Just load a 8GB file.
15:36:40 <siti> it's the biggest java code base, and they're proud of it
15:36:44 <twb> monochrom: emacs can'
15:36:46 <SamB> so, that is like 4*8 = 32 times as much RAM as I have
15:36:48 <twb> can't
15:36:54 <twb> Because Emacs can't open 8GB files :-)
15:37:05 * sorear has 384M, and won't give up his 364M disk cache
15:37:05 <SamB> twb: is that so?
15:37:07 <monochrom> ok, "some restrictions apply" :)
15:37:10 <sorear> SamB: yes!
15:37:10 <EvilTerran> 512MB here. also, iirc, vim can load only part of large files at a time
15:37:14 <sorear> SamB: tag bits
15:37:21 <procyon_> "8GB.. and that's just to cover our visitor pattern objects!  Then we load the ORM, with 3 layers of caching to access our data..."
15:37:29 <siti> EvilTerran: I need all the data at once it's just the project I am doing...
15:37:32 <SamB> sometwo: how does that prevent 8GB files on 64-bit systems?
15:37:38 <sorear> SamB: emacs can only open files whose sizes fit in 24 bits, cause 8 bits are needed to tell that it is an int
15:37:48 <twb> Emacs can only open files that are entirely addressable within it's int space, because it uses an int for the point.  On 32-bit machines, it's about 2**30 (a couple of bits are to record the type)
15:37:48 <SamB> wow!
15:37:50 <monochrom> haha
15:37:55 <sorear> SamB: ain't lisp grand? :)
15:38:01 <sorear> (this one anyway)
15:38:12 <SamB> sorear: I've never heard of a system that used more than two tag bits!
15:38:27 <twb> sorear: elisp is hardly an exemplary dialect.
15:38:34 <Delta-Force> kpreid: is  parseOut :: RegExp -> String -> IO()  correct, ro shall I change IO()?
15:38:45 <twb> It was originally called "mocklisp", after all
15:38:50 <EvilTerran> siti, if you've got to fit a lot of data in memory at once, i think the thing to do would be write in C.
15:38:57 <SamB> anyway, a 32-bit int can't go past 2gb
15:38:57 <procyon_> 3 GB here... but that's because I'm running Windows Vista 64.  2GB on my laptop, because I'm a RAM slut.
15:38:57 <monochrom> elisp + e + c = eclipse
15:39:17 <kpreid> Delta-Force: that type signature is fine if you're going to print the result of the parse
15:39:24 <twb> procyon_: obscene
15:39:50 <procyon_> SamB: 32-bit int goes to 4GB.. pinters are unsigned.
15:39:56 <procyon_> pointers even
15:40:05 <kpreid> Delta-Force: the part your program is missing is that you need to handle the success and failure cases from your parse result, using a 'case' expression or something similar. once you do that, your program will compile
15:40:11 <siti> hmm, I can't be bothered with c, I am going to be able to fit it all in haskell if I try hard enough
15:40:19 <SamB> procyon_: I said ints
15:40:55 <procyon_> twb: My laptop runs gentoo.... with 2 GB. I never swap.
15:41:28 <ddarius_> Use a ramdisk as your swap space.
15:42:06 <SamB> ddarius: isn't that kind of expensive?
15:42:33 <siti> what I want is instead of swapping it just compresses memory
15:42:53 <ddarius> SamB: It would be kind of pointless.
15:42:59 <siti> there is some project to do that but it's not in mainline
15:43:04 <SamB> ddarius: I mean, those ram drives are expensive
15:43:23 <Delta-Force> parseOut :: RegExp -> String -> IO() -- the type is apparently wrong -- error msg beingSyntax error in declaration (unexpected `;', possibly due to bad layout)
15:43:23 <monochrom> ramdisk for swap? that must be a joke or a prank...
15:43:39 <SamB> monochrom: or you have a ramdisk that you hook up to your disk bus
15:43:47 <procyon_> I took it as a joke.
15:44:08 <twb> procyon_: does it MATTER if you swap occasionally?
15:44:16 <EvilTerran> siti, what about using a database of some description?
15:44:23 <monochrom> It's almost like: lets translate the State monad to an imperative language!
15:44:32 <procyon_> I have seen a ramdisk used for /tmp though, although I think it's not much of an optimization when you consider file caching.
15:44:48 <deadbeef> hi there
15:44:50 <Delta-Force> kpreid -- parseOut :: RegExp -> String -> IO() -- the type is apparently wrong -- error msg beingSyntax error in declaration (unexpected `;', possibly due to bad layout)
15:44:53 <SamB> monochrom: I'm not seeing why that would be a bad idea
15:44:53 <siti> I made the decision not to use a database to save development time
15:44:58 <deadbeef> i was minding to apply to SoC this year
15:45:06 <kpreid> Delta-Force: your syntax error is somewhere else; that line is fine
15:45:20 <deadbeef> with an application for inductive logic programming, since my thesis was about it
15:45:41 <procyon_> twb: It doesn't matter, but I have been known to fill up a whole lot of ram with some of my crazy ass programming, and ram is cheap, so why not.
15:45:55 <kpreid> Delta-Force: put the entire file you're trying to compile on hpaste
15:46:06 <SamB> kpreid: that can be hard
15:46:25 <kpreid> SamB: ?
15:46:26 <twb> procyon_: it strikes me as rather wasteful.
15:46:32 <monochrom> w00t, hpaste!
15:46:42 <EvilTerran> siti, are you entirely sure that'll have the desired effect? you seem to have made this task rather difficult with all the constraints you've given yourself in the interests of "saving development time"
15:46:49 <twb> Like owning an automobile instead of a bicycle.
15:47:22 <Gu1> depends if you have a 50 mile commute
15:47:40 <procyon_> SamB: It's a bad idea because the idea of swap is if you run out of ram, you use the disk... the idea of a ramdisk is storing a filesystem in memory.  That takes up memory, which will CAUSE you to swap when you wouldn't have.  It's a silly idea, and overall slower (because of the overhead of having an extra filesystem indirection)
15:48:04 <siti> EvilTerran: yeah it seems a bit insane, but what I have done already shows that haskell is about 5-10 times faster than any other language I have used...
15:48:08 <twb> Gu1: indeed, but I'd rather fix the overlong commute than throw more resources at it :P
15:48:17 <Gu1> sure
15:48:21 <twb> Brute forcing is, by definition, inelegant.
15:48:37 <Gu1> but isn't that what government does?
15:48:39 <EvilTerran> righto.
15:48:41 <procyon_> SamB: or were you talking about his state monad comment.  Nevermind. /hides in corner
15:48:41 <Delta-Force> kpreid - thanks .. i fixed most of it, but an error still
15:48:41 <Delta-Force> parseOut exp str
15:48:41 <Delta-Force>              | str /= "" = putStr(parse exp str)
15:48:41 <Delta-Force>              | otherwise = putStr("")
15:49:02 <rahikkala> But Unix is elegant and mostly brute force :(
15:49:03 <ailndx> anyone here using runplugs in win/ghc6.6?
15:49:08 <siti> and the only reason I am doing this is because it's so fast, I could not bare to work on a project for 6 months stright
15:49:11 <twb> rahikkala: unix is hardly elegant
15:49:30 <kpreid>  Delta-Force : you need to handle the output of parse, which is not a string!
15:49:40 <twb> rahikkala: you may want to read the Worse is Better paper if you feel that way :-)
15:49:43 <Delta-Force> so what is it?
15:50:00 <Delta-Force> how can i convert it to string then, with another function
15:50:01 <Delta-Force> ?
15:50:01 <kpreid> Delta-Force: it's a Maybe (String,String), like your code says it is
15:50:11 <kpreid> Delta-Force: you need to match the two cases of Maybe.
15:50:36 <Delta-Force> any hints on that, I was jsut introduced to Maybe function couple of hrs ago, so I don't really know how to use it
15:50:51 <kpreid> Delta-Force: Read your Haskell introductory document's section on pattern matching.
15:51:10 <procyon_> twb: It is wastefull, but I can run firefox with 50 tabs open, full KDE, emacs with all the fixings, and test my space leaky haskell genetic programming program and watch porn without bringing the machine to it's knees.
15:52:15 <monochrom> with 50 tabs open, the computer's ram is no longer the limiting factor. the brain's ram is. :)
15:52:55 <procyon_> My firefox tabs are more of a "task list" ;)
15:53:08 <monochrom> so you do linear search on it? :)
15:53:22 <twb> That's what org mode is for.
15:53:33 <procyon_> It's a delta time queue
15:53:48 <twb> Firefox tabs aren't even hierarchical, bleh.
15:53:58 <monochrom> ah, queue is easy
15:54:00 <EvilTerran> twb, that's an interesting idea
15:54:11 <twb> EvilTerran: it's been done, see kazehakase
15:54:17 <monochrom> Gosh, next year you'll be asking for symlinks between tabs.
15:54:24 <EvilTerran> i currently heirarchise by windows and tabs, but then i run out of layers...
15:55:03 <twb> monochrom: actually I'd rather have a powerful command-line-driven, database-backed (e.g. sqlite) task management utility.
15:55:27 <twb> Something that can also produce timesheets and do critical path analysis and send reminders by email
15:55:42 <twb> Stuff like Emacs' planner really doesn't cut it.
15:55:45 <procyon_> twb: as a lambdabot plugin ;)
15:56:28 <EvilTerran> ?todo
15:56:28 <lambdabot> 0. SamB: A way to get multiple results from a google search
15:56:29 <lambdabot> 1. dons: improve formatting of @dict
15:56:29 <lambdabot> 2. dons: write Haskell Manifesto
15:56:29 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
15:56:29 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
15:56:31 <lambdabot> [23 @more lines]
15:56:32 <EvilTerran> eh.
15:56:36 <EvilTerran> <_<  >_>
15:56:52 <twb> Nor do web apps thrill me, because they aren't even slightly programmable.  Hopefully this XML RPC stuff will take off, so I can stop using a web browser altogether.
15:57:50 <twb> (Web apps don't work to well in my default browser, html2pdf)
15:58:11 <procyon_> Web apps don't work well period.
15:58:14 <twb> Yeah.
15:59:02 <twb> But to their advantage, they are server-side.  That means you don't need to install Common Lisp on client machines :-)
15:59:23 <EvilTerran> implement an interpreter in a 256x256char block of javascript >:]
16:00:05 <procyon_> twb: so is X.. and X is *way* better than AJAX (and FAR from perfect... far from "good" even)
16:00:21 <twb> procyon_: you mean NeWS
16:00:36 <EvilTerran> (actually, 64x64'd probably be sufficient, given that javascript's so high level and scheme is so simple)
16:00:48 <twb> EvilTerran: I said Common Lisp, not Scheme.
16:00:53 <procyon_> NeWS?
16:01:08 <EvilTerran> twb, oh, my bad. better make it 1024x1024 \:P
16:01:10 <twb> procyon_: the windowing system that X was invented to kill
16:01:16 <procyon_> ahhh
16:01:39 <twb> The other Unix vendors didn't like that Sun already had NFS, so they ganged up to kill NeWS with an inferior design
16:02:01 <procyon_> MS has the right idea (and I cringe to utter that) with XAML.
16:02:29 <twb> procyon_: you mean HTML forms on acid?
16:02:56 <Delta-Force> How can I convert an output like  just(a,"hello") into a full string "just(a,hello)" .... mind you I just need to access hello string in the end
16:03:07 <twb> Delta-Force: show
16:03:26 <Delta-Force> i did already .. repasting
16:03:27 <twanvl> You mean XUL without modularity and with styles interspersed?
16:03:30 <twb> \Just(_,s) -> s
16:03:40 <sorear> Delta-Force: haskell is case sensitive
16:04:00 <sorear> just (a, "hello") is a function call, not a value
16:04:05 <EvilTerran> Delta-Force, no, the _function_ called show().
16:04:08 <EvilTerran> ?type show
16:04:10 <lambdabot> forall a. (Show a) => a -> String
16:04:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1107
16:04:33 <UUStudent> hi
16:04:38 <sorear> hi.
16:04:39 <EvilTerran> > show Just(True,3.14)
16:04:39 <UUStudent> I get a parse error in this expression:
16:04:40 <lambdabot>  Couldn't match expected type `(Bool, t1) -> t'
16:04:44 <Delta-Force> that's mine anonymous
16:04:46 <EvilTerran> > show (Just(True,3.14))
16:04:47 <lambdabot>  "Just (True,3.14)"
16:04:48 <procyon_> twb: They are MUCH better than forms.  XAML is just XML access to the underlying objects.  You can express data binding directly through the XAML interface though, and pipe the whole thing as a mime type.  Essentially, you can have a full database frontend, or file editor, or whatever in a very concise peice of XML.
16:04:49 * sorear braces for a long paste.
16:05:06 <UUStudent> sorteer (x : xs)  | vroegerDan = x : sorteer xs  | otherwise = head xs : sorteer x : tail xs
16:05:13 <UUStudent> what have I done wrong there?
16:05:13 <EvilTerran> "concise piece of XML" hehe
16:05:21 <twb> procyon_: so yes, it's basically NeWS reinvented
16:05:38 <procyon_> twb: And that's without putting any javascript into the XML
16:05:44 <sorear> UUStudent: vroegerDan isn't defined anywhere
16:05:46 <twb> procyon_: yes, obviously.
16:05:50 <twanvl> You are trying to call 'sorteer x', but x is not a list
16:05:56 <procyon_> twb: I'm not familiar with NeWS, so I can't compare :(
16:06:24 <twb> procyon_: http://en.wikipedia.org/wiki/NeWS
16:06:26 <lambdabot> Title: NeWS - Wikipedia, the free encyclopedia
16:06:34 <procyon_> twb: It beats the hell out of any other GUI frontend I've seen, and is a very nice thin client.
16:06:50 <sorear> procyon_: what if I don't like your UI?
16:07:01 <JohnnyL> "mathrick has quit ("HULK ANGRY! HULK DISCONNECT!")"
16:07:02 * JohnnyL snickers
16:07:08 * sorear has a console user persecution complex!
16:07:17 * sorear won't run X
16:07:30 <twb> sorear: I'm still waiting for the CLIM curses backend
16:07:59 <sorear> now, I CAN eidt files.  but if you force a presentation-only file editor on me, I can't use it.
16:08:05 <sorear> semantic markup is Good
16:08:19 <twb> sorear: what's a presentation-only editor?
16:08:37 <UUStudent> then this code, why do I get a parse error here?
16:08:42 <sorear> twb: I'm guessing an editor presented in terms of lines and triangles..
16:08:50 <UUStudent> sorteer (x : xs)  | vroegerDan x (head xs) = x : sorteer xs  | otherwise = head xs : sorteer (x : tail xs)
16:08:50 <icarroll> Is there any equivalent of mapWithKey for DiffArray?
16:09:03 <sorear> icarroll: amap? imap?
16:09:05 <sorear> *ixmap
16:09:24 <twb> http://twb.ath.cx/~twb/canon/words/emacs-desktop.html
16:09:26 <lambdabot> Title: Emacs as a Desktop Environment
16:09:26 <sorear> UUStudent: that ought to parse
16:09:27 <icarroll> amap is just a regular map I think
16:09:48 <sorear> UUStudent: maybe a renamer error (vroegerDan isn't defined)
16:09:57 <icarroll> sorear: ixmap is odd and I'm not sure what it's for. I'm pretty sure it's not what I'm looking for though.
16:10:00 <sorear> UUStudent: of a type error, as twanvl pointed out
16:10:04 <procyon_> twb: Yeah... XAML (Windows Presentation Foundation to be precise) looks a lot like NeWS.
16:10:07 <sorear> s/of/or
16:10:28 <twb> procyon_: are there plans for a character-cell renderer for XAML?
16:10:33 <icarroll> I'm looking for something like
16:10:55 <twb> I'm gonna go out on a limb and assume there isn't one already :P
16:11:00 <icarroll> (a -> b -> c) -> DiffArray a b -> DiffArray a c
16:11:07 <procyon_> twb: character-cell... please elaborate, this word means nothing to me.
16:11:20 <twb> procyon_: you know curses?
16:11:32 <twb> procyon_: something that will render on a tty
16:11:34 <JohnnyL> XML as compared to JSON?
16:11:51 <twb> procyon_: as opposed to a graphical display
16:12:19 <procyon_> twb: no.  WPF is GUI only.  (it's from Microsoft.. there is no such thing as a tty as far as they are concerned)
16:12:32 <twb> That's pretty sucky
16:12:57 <Delta-Force> thanks for your help everyone .. show worked like charm
16:12:59 <Delta-Force> ^^
16:13:04 <JohnnyL> JSON is wire friendly.
16:13:39 <twb> JohnnyL: if it doesn't run in a tty, I'm not interested in it.
16:13:47 <procyon_> twb: Although, it probably wouldn't be too hard to make one.  WPF has a grid layout... you could just dynamically update the grid.
16:14:14 <twb> procyon_: but that grid is presumably in pixels, not characters.
16:14:57 <procyon_> twb: No.. it's in "cells".  A cell could be constrained to a single character... or "glyph" to use their terminology.
16:16:16 <procyon_> twb: I could probably hack up a WPF "terminal" pretty easily, and map curses-like commands to WPF commands for manipulating cells and groups of cells.
16:16:30 <twb> procyon_: interesting
16:17:12 <procyon_> twb:  Then your tty would have full 3-D acceleration ;)
16:17:22 <twb> Er, I think you have it backwards.
16:17:42 <twb> The point is to run programs like firefox or acrobat reader inside a terminal emulator, not to write a terminal emulator.
16:18:43 <JohnnyL> twb, um, JSON is a competitor to XML not X.
16:19:02 <twb> JohnnyL: I see, I misunderstood.  In that case, *sexprs*!
16:19:33 <procyon_> twb: AHHHHH.. no then.  WFP is meant specifically as an API to manipulate the Windows Screen canvas (and will probably be cloned by Mono) It's the replacement for GDI.
16:19:50 <twb> procyon_: I know nothing of GDI
16:20:23 <twb> Actually, I haven't even *used* a Windows system for many years.  I've never programmed on one.
16:21:28 <procyon_> GDI => The API that Windows uses to do graphical and text rendering to "Device Contexts"... Where "Device Context" is a canvas to be drawn to, like a printer, bitmap, screen, etc...
16:21:57 <twb> So, something like (Display) PostScript?
16:22:05 <sorear> GDI is like Xrender
16:22:11 <procyon_> precisely like that.
16:22:18 <sorear> where like == inhabits-same-field
16:22:18 <twb> I see.
16:23:14 <twb> I'm curious: are there any X window managers in Haskell?
16:23:20 <sorear> @where xmonad
16:23:21 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
16:23:22 <procyon_> Xmonad.
16:23:38 <sorear> 400 lines of haskell wm goodness
16:23:46 <sorear> obviously, I haven't used it
16:23:55 <sorear> it's supposed to compete with dwm
16:24:08 <nornagon> last i checked, it wasn't quite there yet
16:24:10 <sorear> it uses essentially the same amount of ram and cpu
16:24:23 <sorear> (since Xlib dominates both)
16:24:56 <twb> There's not a 100% Haskell X11 client library? ;-)
16:25:34 <sorear> work in progress
16:25:37 <icarroll> http://lists.freedesktop.org/archives/xcb/2006-January/001278.html
16:25:38 <sorear> @where xhb
16:25:38 <lambdabot> I know nothing about xhb.
16:25:39 <lambdabot> Title: [Xcb] xhsb: X Haskell Binding, http://tinyurl.com/24tguj
16:25:40 <procyon_> Just use house if you want to go that far :P
16:25:44 <twb> Neat.
16:26:18 <JohnnyL> @users
16:26:19 <lambdabot> Maximum users seen in #haskell: 336, currently: 316 (94.0%), active: 39 (12.3%)
16:27:01 <sorear> @uptime
16:27:02 <lambdabot> uptime: 5h 29m 32s, longest uptime: 5d 3h 40m 45s
16:27:02 <twb> Er, 100% as in "does not rely on crappy C libraries like xlib"?
16:27:09 <sorear> yeah
16:27:18 <icarroll> xcb is a replacement for xlib
16:27:22 <sorear> Xcb is non-crappy C, but C the same
16:27:29 <icarroll> xhsb is essentially xcb for haskell
16:28:37 <shapr> twb: xmonad is way cool, I've been using it for a week or so. It does have a few bugs.
16:28:48 <shapr> I guess that's not surprising since I think it's about two weeks old.
16:29:19 <sorear> @seen dons
16:29:20 <lambdabot> dons is in #haskell-overflow and #haskell. I don't know when dons last spoke.
16:29:35 <sorear> one of these days I'll break down and rewrite lambdabot using happs
16:29:50 <sorear> and use the acidy goodness
16:30:10 <sorear> lambdabot now is positively riddled with theoretical threading bugs
16:30:10 <twb> acidic
16:30:25 <sorear> and doesn't seem to fare too much better in practice
16:30:51 <procyon_> twb: Damnit... now you have me contemplating how to make a tty into a canvas. (hmm.  If we take the region being drawn to, and make the character that comprises that region the character with the highest similarity to the desired bitmap we want to blt...)
16:30:54 <sorear> otoh, the infamous netsplit bug turned out to be an irc-parsing thing
16:31:05 <twb> procyon_: wonderful!
16:31:12 <sorear> procyon_: the problem's been solved already
16:31:17 <sorear> procyon_: google aalib
16:31:28 <sorear> procyon_: then run any SDL program with DISPLAY=''
16:31:36 <Saizan> what can be the reason why xmonad randomly stop to react to commands? and let them be used by the windows instead
16:31:38 <shapr> The aalib demo is amazing.
16:31:41 <twb> procyon_: you see, this means you can have a *fast* *detachable* window system (that doesn't have horrible artifacts like VNC) and works anywhere.
16:31:43 <sorear> procyon_: vlc on tty is ... freaky
16:31:54 <shapr> Saizan: I have that problem sometimes too.
16:32:17 <Modius> Anyone on here used Lispworks CAPI?  Assume you're shilling C#/Dotnet - how would you describe its limits vs. using Dotnet native display libs?
16:32:34 <Modius> Representing it from standpoint would best explain the limits.
16:32:37 <Saizan> shapr: and you have to restart it, right?
16:32:42 <Modius> (And I can't ask a C# guy as he doesn't know Lisp)
16:32:43 <twb> Modius: shouldn't you ask #lisp?
16:32:49 <Modius> I apologize, wrong window
16:32:58 <twb> :-)
16:34:17 <procyon_> sorear: aalib looks pretty cool... I may have to try it over ssh.
16:36:15 <procyon_> sorear: hehe... and now I can play video games in emacs.
16:36:27 <twb> procyon_: M-x tetris
16:36:38 <twb> M-x snake
16:36:40 <Gu1> is there anything emacs can't do?
16:36:54 <twb> It's not very good at reading PDFs
16:36:59 <procyon_> twb: I mean like full Quake.. in a buffer.
16:37:11 <twb> Gu1: And the web browsers can't display inline images in an xterm
16:37:38 <twb> procyon_: M-x animate birthday present
16:37:57 <Gu1> ahh well, you can't ask for everything
16:38:09 <twb> Gu1: I damn well can
16:38:27 <Gu1> let me rephrase, can't get everything?
16:38:36 <twb> Not yet, at any rate.
16:38:58 <twb> When mtty and xft branches merge, I'll have inline images without needing a separate Emacs process :-)
16:39:18 <procyon_> Emacs built a time machine once and went back in time to stop the JFK assassination. As Oswald shot, Emacs met all three bullets with M-x bullet-mode-hook, deflecting them. JFK's head exploded out of sheer amazement.
16:39:44 <Gu1> lol
16:40:57 <byteshack> is "all" in prelude optimazied? (ie. is "and (map f xs)"  Does it do something akin to short-circuit logic in an imperative? or does it have to visit all the elements in xs?
16:41:21 <twb> byteshack: all functions "short cut" in Haskell.
16:41:39 <twb> byteshack: "short cutting" = normal-order (lazy) evaluation
16:42:02 <twb> Er, s/cut/circuit/
16:42:07 <byteshack> twb: I have an "intuitive" undestanding of that, but it still is magic to me
16:42:11 <dolio> > all (<5) $ [6, 7, 8, 9, 10, 2, 8, 4, 5] ++ repeat 10
16:42:12 <lambdabot>  False
16:43:19 <twb> Hmm, how do I make a turnstile?
16:43:51 <quicksilver> is there a standard lib way to turn a Int64 into 8 Word8s?
16:44:13 <monochrom> "all" short circuits.
16:44:36 <monochrom> do not trust beginner intuition.
16:44:54 <augustss> twb: |-  ? :)
16:45:18 <twb> I meant _|_
16:45:22 <twb> Maybe my terminology is wrong.
16:45:31 <ndm> twb, bottom
16:45:32 <byteshack> where can I learm more on how, for example, ) [1, 2, 3, 4]
16:45:40 <ndm> twb, and use either undefined or error "bottom"
16:45:41 <monochrom> 
16:45:45 <quicksilver> byteshack: it's important to understand that 'all' and 'any' do not short ciruit becuase the prelude is 'specially optimised'. They do it because that's how lazy works.
16:45:46 <ndm> > error "bottom"
16:45:47 <lambdabot>  Exception: bottom
16:46:05 <twb> byteshack: observe:
16:46:06 <twb> > let f = f in all (<0) [1,f]
16:46:08 <lambdabot>  False
16:46:20 <twb> byteshack: that would loop forever if ALL was normal-order.
16:46:21 <sorear> @quote procyon_ Emacs built a time machine once and went back in time to stop the JFK assassination. As Oswald shot, Emacs met all three bullets with M-x bullet-mode-hook, deflecting them. JFK's head exploded out of sheer amazement.
16:46:22 <lambdabot> No quotes match. You speak an infinite deal of nothing
16:46:34 <sorear> twb: all is normal order
16:46:40 <twb> Uh, sorry
16:46:42 <twb> applicative order
16:46:46 <sorear> twb: are you talking about applicative order?
16:46:53 <sorear> @remember procyon_ Emacs built a time machine once and went back in time to stop the JFK assassination. As Oswald shot, Emacs met all three bullets with M-x bullet-mode-hook, deflecting them. JFK's head exploded out of sheer amazement.
16:46:53 <lambdabot> Done.
16:47:00 <monochrom> It's reassuring that we try very hard to confuse rather than answer.
16:47:18 <twb> monochrom: confusion is an elemental force
16:47:19 <byteshack> twb: that example clearly shows that it is lazy
16:47:26 <twb> byteshack: precisely
16:47:27 <byteshack> thanks
16:47:34 <twb> byteshack: in Haskell, everything is lazy
16:47:41 <sorear> monochrom: agreed.
16:47:47 <sorear> twb: even seq? :)
16:47:57 <sorear> twb: unboxed types?
16:47:59 <twb> confusion, bloody-mindedness, charm, peppermint
16:48:14 <sorear> bytestrings?
16:48:23 <icarroll> don't forget surprise
16:48:27 <augustss> everything as lazy as it can, but not more than that :)
16:48:32 * sorear confuses byteshack 
16:48:43 <twb> icarroll: yes, you got one of the three references.  Can you spot the others?
16:48:46 <aluink> byteshack: do you get it?
16:48:54 <sorear> augustss: case bindings of tuples.  need I say more?
16:49:33 <ndm> sorear, you always have ~
16:49:35 <icarroll> twb: can't remember the others
16:49:38 <augustss> It can't be lazy.  It has to check if the value is _|_ or not :)
16:49:45 <byteshack> my mind wants to turm map into a foreach, and it has a hard time seeing where the "break" is :)
16:50:38 <quicksilver> byteshack: the map doesn't break
16:50:43 <quicksilver> byteshack: the map 'wants' to go on forever
16:50:50 <quicksilver> byteshack: it's just the 'and' stops caring
16:50:51 <sorear> ndm: wrt the interchangable-parts aspect of yhc
16:51:04 <sorear> ndm: how important is it that we only have one compiler?
16:51:06 <quicksilver> byteshack: and because the 'and' stops caring, the 'map' stops being evaluated at that point
16:51:28 <augustss> I think the laziness choices in Haskell makes perfect sense.  But then I would, since they are patterned after LML. :)
16:52:00 <sorear> With a little more experience, I think ~ is brilliant.
16:52:05 <byteshack> quicksilver: thanks
16:52:17 <quicksilver> byteshack: and eventually the map gets garbage collected
16:52:25 <sorear> Miranda tried to decide what semantics everyone needed at language definition time.
16:52:28 <quicksilver> byteshack: it sits there sadly waiting for someone to care about the next value
16:52:37 <ndm> sorear, how do you mean "only one compiler"
16:52:39 <sorear> ... and needed to be revised (at least) once!
16:52:42 <quicksilver> byteshack: and when the runtime notices no references to it exist
16:52:47 <quicksilver> byteshack: it gets collected
16:53:12 <ndm> sorear, as to Yhc.Core and Yhc.ByteCode they are pretty much idependant libraries - any compiler (not just Yhc) could implement them
16:53:30 <sorear> ndm: If hv (my fast hugs-killing validator) ever works, I think I'l try to have it emit Yhc.Core/ByteCode
16:53:37 <byteshack> quicksilver: map is executed synchronously, right?  not async in a multi-threaded way
16:53:56 <sorear> ndm: would that be a code duplication disaster?
16:54:06 <ndm> sorear, what is hv written in? does it parse haskell 98 and type check it?
16:54:13 <quicksilver> byteshack: yes, it's singlethreaded
16:54:27 <sorear> byteshack: asynchronously, using demand-driven threading
16:54:30 <quicksilver> byteshack: but because of the way it's written, it gets evaluated one 'item' at a time
16:54:41 <sorear> ndm: C, will (right now it just parses)j
16:54:42 <ndm> sorear, in general code duplication is to be avoided if possible - but if you map to Yhc.Core, then use the standard Yhc.Core->Yhc.ByteCode, then its not that much duplication
16:54:47 <quicksilver> byteshack: as the top item is pulled of, the rest of the map is saved as a 'suspension'
16:54:57 <quicksilver> byteshack: and gets executed when the next item is needed
16:55:05 <quicksilver> (if the next item is never needed, that's never)
16:55:07 <sorear> ndm: how much work happens in Core->ByteCode?
16:55:10 <ndm> sorear, if the things have different purposes, and are written in different languages, then thats better
16:55:15 <ndm> sorear, ask tom....
16:55:30 <ndm> sorear, a reasonable bit, but not a huge amount
16:55:56 <Igloo> Can't sorear just use a yhc package?
16:55:59 <Igloo> OAIC?
16:56:01 <ndm> sorear, code duplication is not that bad at all
16:56:17 <byteshack> this is so cool
16:56:27 <sorear> Igloo: OAIC?
16:56:31 <ndm> Igloo, that should be possible - we don't have a binary format for Yhc.Core - but if the need arises, we will certainly add one
16:56:32 <sorear> @vera OAIC
16:56:34 <lambdabot> No match for "OAIC".
16:56:34 <Igloo> Or Am I Confused
16:57:01 <sorear> ndm: I thought binary was the only yhc.core format?
16:57:20 <ndm> sorear, it is - but the binary produced by DrIFT - the binary format is not stable
16:57:38 <ndm> sorear - or documented - but if the need arises, we will make it stable and documented
16:57:43 <mbishop> ROFL sorear is SOL when it comes to FLA, LOL, but IANAL, BRB ROFLMAO
16:57:45 <mbishop> KTHNX
16:57:45 <_roconnor> quicksilver: I guess it is kinda like automagic coroutines.
16:59:13 <dcoutts> ndm: Tell Collin he needs to Cabalise SmallCheck and get it on Hackage. And tell him I've got a modified version that generates all partial values of types rather than just all the total values.
16:59:24 <dcoutts> in case he's interested in that
16:59:32 <ndm> dcoutts, isn't there a cabal file in there yet?
16:59:36 <dcoutts> nope
16:59:39 <ndm> dcoutts, i thought i added one...
16:59:43 <dcoutts> not in the 0.2 tarball anyway
16:59:53 <ndm> dcoutts, ah - not in the tarball, its in the darcs repo
16:59:59 <sorear> Igloo: Yhc.Core was not my initial goal.  I want a very fast haskell type-checker for development.  Core just looks feasable now
17:00:06 <dcoutts> ndm: a ok
17:00:13 <ndm> dcoutts, have you found the darcs?
17:00:22 <dcoutts> I probably can find it
17:00:31 <ndm> @where+ smallcheck http://www.cs.york.ac.uk/fp/darcs/smallcheck/
17:00:32 <lambdabot> Done.
17:00:54 <ndm> dcoutts, i doubt it - he's never said where it is, no links anywhere etc - i forced him to set it up and sent him the cabal patch myself
17:01:09 <ndm> dcoutts, i guarantee he'll have made local changes, not recorded them and not pushed them...
17:01:28 <dcoutts> ndm: heh. I also think the test driver could be improved, more like the QuickCheck batch driver
17:01:45 <ndm> dcoutts, feel free to send him patches
17:01:47 <dcoutts> right'o
17:01:48 <ndm> dcoutts, although i'll have to go over to show him how to apply them
17:01:52 <dcoutts> :-)
17:02:09 <ndm> plus i'm not doing anything for him until he's finished checking my ICFP paper!
17:02:09 <dcoutts> for starters it needs to be renamed to Test.SmallCheck
17:02:16 <dcoutts> hah hah
17:02:22 <sorear> I wonder if darcs send should automatically prepend instructions
17:02:28 <ndm> that one might be hard to swing...
17:02:43 <sorear> I mean, it already generates 100K of context for any patch...
17:02:45 <ndm> i'll try and persuade him, but remember heirarchical modules is not H98
17:02:46 <dcoutts> sorear: what's what darcs send --edit-description & copy'n'paste is for
17:02:58 <dcoutts> ndm: pfft
17:03:25 * sorear wonders if hv is the only haskell parser that properly implements that
17:03:29 <ndm> dcoutts, the person next to me in work refuses to use Data.Map, instead he copies things out of Osaki's thesis into modules for every application...
17:03:34 <dcoutts> ndm: Test.SmallCheck.Partial will not be H98, for one thing it uses an isBottom function :-)
17:03:42 <dcoutts> nooooo!
17:04:09 <ndm> dcoutts, i just laugh when he typo's something that is type correct, very amusing
17:04:09 <dcoutts> ndm: they need a slap :-)
17:04:26 <augustss> ndm: who is the person next to you?
17:04:29 <ndm> dcoutts, he stores all his important code in /tmp, and doesn't put it in darcs or anything
17:04:52 <ndm> augustss, Mathew Naylor - he wrote Hacle, but other than that has nothing online that identifies him as a person
17:04:53 <encryptio> does ghc do any partial evaluation?
17:05:07 <ndm> no website, no releases, no mailing list posts....
17:05:13 <sorear> no wonder hacle never got contributed to nobench!
17:05:19 <dcoutts> encryptio: not proper PE, some optimisations can be seen as special cases of PE though.
17:05:20 <sorear> ndm: yes ml post
17:05:28 <ndm> sorear, he did actually send a patch for that
17:05:30 <dcoutts> @where hacle
17:05:30 <lambdabot> http://www-users.cs.york.ac.uk/~mfn/hacle/
17:05:34 <encryptio> dcoutts: is it in the pipeline?
17:05:38 <augustss> encryptio: well, depends on what your definition of PE is
17:05:49 <dcoutts> encryptio: no, partial evaluation is not trivial stuff
17:06:08 * ndm hopes partial evaluation is reasonably easy :)
17:06:09 <dcoutts> encryptio: I did the first half of my PhD on PE for Haskell. It's not easy.
17:06:50 <augustss> dcoutts: self application is tricky, but just some online PE isn't difficult
17:07:21 <augustss> tedious, yes
17:07:29 <encryptio> yes, i know it's hard to do properly, generally, and without wasting too much (TimeAmount a => a)
17:08:14 <dcoutts> augustss: yeah, I avoided self-application since the types and tagging get tricky, I wrote the function which constructs generating extensions directly.
17:08:58 <ndm> would it be easier in a first order language?
17:09:02 <dcoutts> yes
17:09:02 <augustss> well, you were into the tricky parts anyway then.  when you get to generating extensions it gets hairy
17:09:19 <ndm> dcoutts, for what reasons? i now have first order haskell, so would like to know ;)
17:09:28 <encryptio> does ocamlopt do PE?
17:09:37 <dcoutts> ndm: the binding time analysis is easier
17:09:45 <dcoutts> encryptio: not so far as I know
17:09:52 <dcoutts> but you also need programmer feedback
17:10:09 <ndm> dcoutts, nah - no programmer feedback - thats too much effort
17:10:22 <dcoutts> the programmer needs to be able to find out why something doesn't optimise or it's mostly useless
17:10:45 <ndm> not if everything optimised optimally :)
17:10:54 <dcoutts> PE is the kind of thing where when it works it gives you a 10x speedup, but when it doesn't it gives you ~nothing
17:10:57 <augustss> once you have to involve the programmer i think you have lost 95% of all applications
17:11:00 * ndm has big goals, and almost no understanding of the research in teh field
17:11:28 <dcoutts> if you can't rely on it and it's just a nice bonus then it's not really useful
17:11:50 <encryptio> too complicated to deal with unless you're doing it right, no?
17:12:02 <dcoutts> it's just another compiler black box where you have to hope and prey that it might optimise the program in the way you thought it should
17:12:05 <augustss> for some applications is works very well in practice.  with no programmer involvement
17:12:42 <ndm> dcoutts, surely -O just gonig faster with no effort is a good thing (TM)
17:13:08 <dcoutts> augustss: I always got the impression that for many things people had to understand too much about the tool/technique for it to be used by non-experts.
17:13:23 <encryptio> i've been writing synthesis programs recently in haskell, and at first i worried that the compiler would simmer all my code down to main = writeFile "..." "..."
17:13:36 <augustss> the only serious PE i've been involved with was for people who had no clue how things worked.  just another box to tick.  it sped up compilation and execution
17:13:40 <dcoutts> ndm: but you can generally rely on -O to give you a certain speedup, it's not a 10x vs nothing situation
17:14:03 <dcoutts> augustss: sounds good
17:14:22 <augustss> dcoutts: but it was a very specialized language
17:14:47 <dcoutts> encryptio: it also can't prove that your code it terminating so it will not reduce it like that
17:15:27 * ndm cries at unsafePerformIO in cpphs
17:15:28 <sorear> encryptio: jhc has been known to try things like that
17:15:40 <augustss> PE is easier for terminating languages :)
17:15:42 <sorear> I ran jhc on exp3_8 once
17:15:58 <sorear> it went forever on case-of-value and inlining
17:16:09 <sorear> basically emergent compile time evaluation
17:16:13 <ndm> yeah, my initial version of yhc -O11 did that too :)
17:16:20 <ndm> on exp3_8 as well
17:16:51 <augustss> exp3_8 is a nasty benchmark :)
17:17:01 <dcoutts> augustss: I was looking at it from the point of view of library authors, where they could build libs that should give progs that partially evaluate well, but the lib authors need to know the "binding-time types" or something similar to guide their design so they can see if things really will sepecialise they way they want.
17:17:06 <sorear> augustss: how so?
17:17:21 <dcoutts> augustss: things like those layered monadic interpreters
17:17:29 <encryptio> is it written in the book of haskell magic that all haskell programmers must eventually write (or attempt) a haskell 98 compiler/interpereter?
17:17:39 <ndm> i got a 9% speed up over GHC on exp3_8
17:17:41 <augustss> sorear: because it's pointless and totally possible to evaluate for the compiler
17:18:02 <augustss> sorear: also because i wrote it
17:18:32 <ndm> augustss, Runciman benchmarks are worse
17:19:09 <augustss> Colin should appreciate benchmarks for naturtal numbers
17:19:17 <sorear> that's why we have nobench
17:19:34 <ndm> Clausify breaks GHC 6.6, i think
17:19:35 <sorear> (augustssonbench + runcimanbench) / 2 = goodbench
17:19:46 <ndm> and broke earlier ghc's
17:20:00 <sorear> breaks or breaks on?
17:20:07 <augustss> i like bulatbench
17:20:12 <dcoutts> :-)
17:20:26 <dcoutts> augustss: what's that then?
17:20:28 * sorear is interested in anything that can break a compiler... esp by the side-effect thing
17:20:33 <sorear> ru-list
17:20:34 <ndm> sorear, they miscompile them
17:20:57 <sorear> dcoutts: ru-list on nobench
17:21:09 <augustss> bulat submitted some pointless list processing a few weeks ago.  hbc is twice as fast as ghc on that
17:21:19 <dcoutts> ah yes, I remember
17:21:39 <dcoutts> sadly none of that fuses iirc
17:22:00 <augustss> you have to be fast even without fusion :)
17:22:26 <dcoutts> augustss: yeah :-) I've been looking at nothing but fusion all week :-)
17:22:28 <sorear> what does TATD stand for?
17:22:49 <dcoutts> running nobench with our new list fusion stuff
17:23:04 <augustss> does it get better?
17:23:05 <ndm> dcoutts, any luck yet?
17:23:22 <dcoutts> well it's still preliminary, but we're getting many more fusion sites
17:23:32 <dcoutts> and we're not doing list comps yet
17:23:52 <ndm> dcoutts, in terms of speed, have you got any numbers? even small numbers so far?
17:23:55 <dcoutts> as for actual perf, we've got some bugs to track down yet
17:24:04 <sorear> dcoutts: list comps?
17:24:08 <ndm> hehe, i've been tracking down catch bugs all weeks
17:24:16 <sorear> dcoutts: you're running this before the desugarer!?
17:24:16 <ndm> sorear, [x | x <- xs, x > 0]
17:24:25 <dcoutts> on the nobench micro-benchmarks we're going faster by a few % on average
17:24:35 <ndm> sorear, they get desugared to _foldl _filter etc - special functions
17:24:46 <sorear> ndm: I'd have assumed comps would fuse automagically, given that concatMap is already done
17:24:57 <dcoutts> sorear: no, but currently ghc desugars list comps into uses of build/fold
17:24:58 <ndm> sorear, they don't yet
17:25:12 <dcoutts> ghc does not desugar list comps into concatMap ever
17:25:41 <sorear> dcoutts: what, they can't be bothered to let the simplifier handle optimization? :)
17:25:42 <dcoutts> it either does build / foldr or the standard Waddler algorithm, but not the H98 spec style
17:26:22 <dcoutts> sorear: build foldr fusion only works when written in terms of those two functions, so desugaring into general recursive code will not help
17:26:43 <sorear> dcoutts: concatMap is build/fold fusible, isn't it?
17:27:02 <sorear> dcoutts: general recursive is for wadlerian hacks
17:27:27 <dcoutts> concatMap is written as a foldr with ++
17:27:33 * sorear is NOT happy with wadler's ad hoc inlining approach
17:27:40 <dcoutts> so the outer one can fuse and that might expose the ++ to fuse too
17:28:03 <dcoutts> we fuse concatMap differently, actually that one of the rather harder ones
17:37:00 <dons> moin
17:38:21 <kpreid> I forget, is there a name for the combinator (\x -> ($ x)) ?
17:39:22 <Saizan> ?type flip id
17:39:25 <lambdabot> forall b c. b -> (b -> c) -> c
17:39:59 <Saizan>  @pl always uses that
17:40:06 <Igloo> or flip ($)
17:40:47 <kpreid> I ask because I just saw someone else define it by hand in a non-Haskell context, and they called it "flip", so I want to suggest something else
17:41:25 <sorear> hello dons.
17:41:31 <norpan> flop?
17:41:38 <sorear> kpreid: |>
17:41:38 <dmwit> :t >>>
17:41:40 <lambdabot> parse error on input `>>>'
17:41:45 <dmwit> :t (>>>)
17:41:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
17:42:02 <sorear> kpreid: or, if you're of a PLEAC persuasion, .
17:42:12 <sorear> kpreid: MS F# uses |>
17:42:14 <dmwit> :t \x -> (. x)
17:42:17 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
17:42:21 <sorear> kpreid: like filehandle |> close
17:42:34 <sorear> @seen dons
17:42:34 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 5m 34s ago.
17:42:37 <kpreid> hm, I left out a requirement: word, not punctuation
17:42:43 <sorear> ok, it works now..
17:42:53 <dmwit> Why not just use (>>>)?
17:43:08 <sorear> <sorear> @seen dons
17:43:08 <sorear> <lambdabot> dons is in #haskell-overflow and #haskell. I don't know when dons
17:43:08 <sorear>             last spoke.
17:43:08 <sorear> ... [16:28]
17:43:22 <dons> ?uptime
17:43:22 <lambdabot> uptime: 6h 45m 52s, longest uptime: 5d 3h 40m 45s
17:43:27 <sorear> dmwit: because it has the wrong type!
17:43:29 <dons> @flush
17:43:34 <dons> ?users
17:43:34 <lambdabot> Maximum users seen in #haskell: 336, currently: 303 (90.2%), active: 41 (13.5%)
17:43:40 <dolio> (>>>) is flip (.) not flip ($)
17:43:51 <sorear> <lambdabot> uptime: 5h 29m 32s, longest uptime: 5d 3h 40m 45s
17:43:57 <sorear> Bah.
17:44:05 <dmwit> Wait, what's the difference?
17:44:07 <dolio> Heh.
17:44:18 <sorear> dons: sorry, if I hadn't read that h as a d I wouldn't have bugged you
17:44:32 <dolio> > negate $ 5
17:44:33 <lambdabot>  -5
17:44:36 <dolio> > negate . 5
17:44:37 <lambdabot>   add an instance declaration for (Num (a -> b))
17:44:58 <dmwit> > let f = flip ($) in f 5 negate
17:44:59 <lambdabot>  -5
17:45:05 <dmwit> > let f = flip (.) in f 5 negate
17:45:07 <lambdabot>   add an instance declaration for (Num (a -> b))
17:45:08 <dolio> $ is application, . is composition.
17:45:14 <dmwit> Huh.
17:45:19 <dmwit> :t ($)
17:45:22 <lambdabot> forall a b. (a -> b) -> a -> b
17:45:45 <sorear> > let (.)=flip($) in 5.negate
17:45:47 <lambdabot>  -5
17:45:55 <sorear> PLEAC++
17:46:16 <JohnnyL> how useful is  > let (.)=flip($) in 5.negate in the real world?
17:46:18 <dmwit> I always thought ($) was just a lower-precedence (.), so it's good to know that.
17:46:40 <sorear> JohnnyL: not at all in a .hs file :P
17:46:46 <sorear> unlit!
17:47:08 <Cale> JohnnyL: I think it's much worse than (.) being composition.
17:47:39 <Cale> It saves essentially nothing in terms of conciseness, at the expense of wiping out one of the most useful operators in the Prelude.
17:47:46 * sorear has 800 lines to catch up
17:48:14 <monochrom> Some people allow OOP to poison their minds.
17:48:35 <sorear> @quote dons fun
17:48:36 <lambdabot> dons says: Don "If it ain't pure, it ain't functional" Stewart
17:48:43 <sorear> @quote dons lambda.gods
17:48:44 <lambdabot> No quotes match. It can only be attributed to human error.
17:48:45 <rubenz> Does anyone know what the equivalent to glPushMatrix is in the HOpenGL module?
17:48:55 <sorear> not of hand
17:48:58 * sorear checks
17:48:59 <Cale> The Haskell PLEAC is (was?) terrible for people who would actually want a cookbook intro to Haskell, because it used a completely nonstandard library.
17:49:24 <Cale> The effect is that everything is done in exactly the way that a typical Haskell programmer wouldn't.
17:49:44 <monochrom> PLEAC--
17:49:56 <sorear> rubenz: will preservingMatrix work?
17:50:12 <sorear> rubenz: I don't see a way to mung the stack yourself :/
17:50:21 <dolio> @karma Java
17:50:21 <lambdabot> Java has a karma of -2
17:50:31 <sorear> @karma java
17:50:32 <lambdabot> java has a karma of -16
17:50:37 <sorear> @karma dolio
17:50:38 <lambdabot> dolio has a karma of 5
17:50:52 <dolio> Wow. I didn't realise I was that high.
17:50:56 <dolio> @karma dons
17:50:56 <lambdabot> dons has a karma of 130
17:51:05 <sorear> @karma audreyt
17:51:05 <lambdabot> audreyt has a karma of 617
17:51:08 <rubenz> sorear: How does preservingMatrix work?
17:51:09 <kpreid> @where pleac
17:51:09 <lambdabot> I know nothing about pleac.
17:51:15 <kpreid> @google pleac
17:51:17 <lambdabot> http://pleac.sourceforge.net/
17:51:17 <lambdabot> Title: PLEAC - Programming Language Examples Alike Cookbook
17:51:22 <sorear> rubenz: bracket, more or less
17:51:30 <rubenz> ok
17:54:53 <newsham> ?karma newsham
17:54:53 <lambdabot> You have a karma of 5
17:55:05 <newsham> ?karma- newsham
17:55:05 <lambdabot> You can't change your own karma, silly.
17:56:13 <rubenz> this seems like a silly question.. but how do I cast from Float to Double?
17:56:35 <rubenz> I can't seem to work out how to do it
17:56:39 <dolio> ?type realToFloat
17:56:41 <lambdabot> Not in scope: `realToFloat'
17:56:56 <monochrom> realToFrac
17:56:58 <dolio> ?type realToFrac
17:57:00 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
17:57:22 <dolio> I suppose real to float would be a bit odd.
17:58:48 <monochrom> http://www.haskell.org/pipermail/haskell-cafe/2007-March/023449.html  by yours truly
17:58:50 <lambdabot> Title: [Haskell-cafe] Mixed-type arithmetic, or type coercion, http://tinyurl.com/2ds7g2
17:59:21 <newsham> > realToFrac (3.14 :: Float) :: Double
17:59:23 <lambdabot>  3.140000104904175
18:02:09 <shapr> I want excitement!
18:02:26 <dolio> @yow
18:02:26 <lambdabot> An air of FRENCH FRIES permeates my nostrils!!
18:02:50 <shapr> Ah, that's better.
18:03:00 <newsham> ?brain
18:03:00 <lambdabot> I think so, Commander Brain from Outer Space! But do we have time to grease the rockets?
18:03:16 <newsham> howdy shapr.
18:03:17 * sorear goes back to writing his haskell@ message
18:03:20 <shapr> hiya newsham
18:03:22 <shapr> How's code?
18:03:24 <sorear> "Why the Prelude must DIE"
18:03:32 <newsham> havent done much code lately... :\
18:03:47 <newsham> lots of document review...
18:04:00 <sorear> how's silcbot?
18:04:56 <shapr> I've done lots of code lately, though much of it has involved writing specs so we can figure out what to code...
18:05:07 <newsham> still running in its duct-tape-and-rubberbands form
18:05:28 <sorear> can't you just use the Haskell spec language?
18:05:37 <sorear> I hear it is directly executable!
18:05:38 <shapr> We've started doing that.
18:05:48 <shapr> But Haskell doesn't communicate everything.
18:05:50 <newsham> there are some things the haskell spec language dosnt do which other spec languages do
18:06:04 <newsham> it would be nice if someone were to augment the haskell spec language to fill the gap :)
18:06:17 <sorear> shapr: Haskell communicates much better than English...
18:06:23 <monochrom> If you have been coding in C for a long time, you begin using Haskell as a spec language.
18:06:26 <shapr> For some things, but not for all things.
18:06:43 <shapr> Also, some parts of Haskell communicate only to the initiated.
18:06:46 <monochrom> If you have been coding in Haskell for a long time, you begin using an even higher-level language for specs.
18:07:02 <shapr> musasabi wrote some powerful STM based code that I just don't understand.
18:07:16 <newsham> shapr: you're not the only one :)
18:07:31 <monochrom> Your level of abstraction keeps going higher and higher.  Today's spec language becomes tomorrow's coding language.
18:07:52 <newsham> i was looking at z-notation recently.  seems somewhat nifty
18:08:22 * edward1 waves hello
18:08:35 <sorear> what would the best list be for a long rant about why the Prelude must die?
18:08:46 <monochrom> /dev/null
18:08:55 <newsham> sorear:  [a]
18:09:00 <edwardk> sorear: list to send to or list of reasons?
18:09:04 <newsham> maybe [String]
18:09:05 <monochrom> Haha sorry, but the libraries mailing list may be the most relevant.
18:09:16 <shapr> musasabi wrote a quick hack to send signals to a some mail sending STM code, and now we're trying to generalize that to async callbacks and cron. I'm having trouble teasing apart his quick hack though. You'd think that a few lines of Haskell wouldn't be that hard to figure out.
18:09:20 <sorear> monochrom: /dev/null doesn't nod its head
18:09:32 <monochrom> /bin/yes :)
18:09:33 <shapr> hiya edwardk
18:09:52 <edwardk> mono: heh
18:09:56 <shapr> I think I'm going to play a game and rest my brain.
18:10:02 <newsham> shapr: sometimes haskell is not very documentary :(
18:10:52 <newsham> one of the reasons i was drawn to haskell is that you can write simple and readable expressions.
18:11:21 <edwardk> @seen dpiponi
18:11:21 <lambdabot> dpiponi is in #haskell. I last heard dpiponi speak 2h 42m 32s ago.
18:11:31 <dpiponi> edwardk: hi
18:11:38 <newsham> but it seems lots of people are more into getting the most source code compression and less interested in easy to read code
18:11:49 <newsham> or possibly my reading skills are not up to snuff
18:11:50 <newsham> or both
18:12:30 <edwardk> heya
18:12:40 <edwardk> did you get a chance to look at the alphabeta/minimax thing any more?
18:12:48 <monochrom> Reading skill is needed to read succint English.  replace English with Haskell.
18:13:10 <dons> dcoutts: so whatcha working on today?
18:13:15 <newsham> yes.  i'm no haskell expert, but i'm not a newbie either.  i've read through a decent amount of code.
18:13:26 <monochrom> And I prefer succint English.  To the point.  Less likely to let fluff creep in.
18:13:31 <dpiponi> I figured out something that fit all of the specifications of what I wanted...
18:13:33 <dcoutts> dons: looking at a room in Lewisham
18:13:38 <dpiponi> ...but it's really stupid.
18:13:43 <dcoutts> dons: and catching up on other stuff
18:13:45 <edwardk> dpip: k, posted a reply to your paste
18:13:53 <monochrom> (For example, management BS can't be in succint English.)
18:14:11 * sorear is trying to write a coherent rant: Why the Prelude must DIE
18:14:16 <newsham> mono: nor can commercial technical standards documents, apparently
18:14:25 <dons> dcoutts: i'll do some housework :-)  and maybe do some mechanical things later.
18:14:27 <edwardk> http://hpaste.org/1094 which mimics the structure of your minimax identically
18:14:50 <dcoutts> dons: mechanical? like getting your hands covered in oil? :-)
18:15:11 <dcoutts> sorear: just make sure you carefully specify what you're replacing it with. The Prelude is quite well refined and understood.
18:15:35 <dpiponi> edwardk: that looks like what I was fumbling towards
18:16:16 <sorear> dcoutts: my proposed replacement has been being refined for twelve-odd times longer than the old prelude
18:16:19 <edwardk> dpip: it works, and dolio pointed out that it does correctly handle codata tree cases that it should handle
18:16:39 <dcoutts> sorear: heh, pure mathematics eh?
18:17:11 <sorear> dcoutts: yes. specifically o^H/ (view on a os-capable terminal)
18:17:14 <monochrom> tech standard docs are a mixed story.  some are legitimately long because there are really 100 distinct cases to cover and therefore the length must be O(100); I call that succint.  some are illegitimately long because there are 100 distinct cases but some dysfunctional human decides he wants to discuss all 100-choose-2 combinations of pairs.
18:17:17 <dpiponi> edwardk: what do you mean by codata friendlier here?
18:17:35 <edwardk> dpip: it was a fit of stupidity on my behalf the last one is the right onw
18:17:36 <edwardk> er one
18:18:17 <edwardk> i kept getting stuck on the nature of foldr and how the terms would reduce for infinite lists, i was mistaken at the time. beat my head against the wall solving a non-problem
18:19:30 <dpiponi> edwardk: it's cool. I think the algorithm looks really simple that way.
18:19:56 <sorear> @spell succint
18:19:57 <lambdabot> succinct squint succincter succulent accent
18:20:34 * edwardk girds himself to suffer through installing linux again
18:20:43 <monochrom> I also like succulent lamb chops.
18:21:04 <monochrom> Though, I haven't tried succulent lambda chops.
18:21:51 <dolio> Installing linux isn't that bad.
18:21:55 <dolio> Unless it's gentoo.
18:21:59 <DangerMouse> lol
18:22:00 <edwardk> heh
18:22:08 <sorear> even debian has cleaned up its act
18:22:16 <dolio> Which isn't bad, just long. :)
18:22:19 <sorear> I'd never go through boot-floppies again
18:22:20 <edwardk> well x86-64 + all the nvidia crap, then loading all the applications, and haskell stuff, etc.
18:22:31 <encryptio> or LFS
18:22:46 <monochrom> I have helped a friend download linux to 80 floppies.
18:22:47 <sorear> but sarge is painless, even with LFS
18:23:01 <DangerMouse> monochrom : LOL
18:23:20 <DangerMouse> hope it was worth it :)
18:23:21 <dolio> What is that, like 8 boxes?
18:23:22 <encryptio> monochrom: really now. a network install wasn't an option?
18:23:24 <sorear> monochrom: <pedant>my copy of linux fits on 1 floppy</pedant>
18:23:41 <monochrom> It was in the mid 90's.
18:23:42 <sorear> monochrom: full sarge is a different story entirely
18:24:04 <sorear> monochrom: oh, mid-90s linux should have fit on half a floppy
18:24:06 <monochrom> debian was probably not even born. it was slackware or something.
18:24:34 <edwardk> monochrom: i remember that era =)
18:24:35 <monochrom> of course by "linux" we mean the whole suite of applications.
18:25:02 <sorear> applications? what are those?
18:25:36 <dolio> It was probably 1 disk for most stuff, and then 79 for emacs.
18:26:34 * QtPlatypus recalls slackware.
18:27:04 <monochrom> An engineering student friend convinced a business student friend to try out linux. (The latter had several boxes anyway.) They had the great idea of recruiting me to help. We went to the business computer room (DOS based). We logged on three computers and downloaded in parallel.
18:27:30 <monochrom> The business student friend ran a BBS. He was considering moving his BBS to linux.
18:27:35 <dpiponi> edwardk: I don't think that alphabeta works!
18:28:10 <edwardk> i learned unix back on sysv, was another 10-12 years after that before i found slackware
18:28:24 <dpiponi> edwardk: it doesn't update alpha as it works its way along the list of subtrees
18:28:25 <edwardk> dpiponi: hah wouldn't be surprised if i f*!cked it up =)
18:29:20 <dpiponi> edwardk: I used fmap to wrap each score with a trace and it seems all of the scores get evaluated. This is true even if I reverse the order of the subtrees.
18:29:48 <edwardk> hrmm
18:30:18 <edwardk> ugh
18:30:45 <waern> hey pepe
18:30:56 <edwardk> and apparently, it'll be another 10-12 years before i get the hang of coding things in haskell. knew i should have written quickechecks for that =)
18:31:33 <monochrom> Actually we didn't download in parallel.  We pipelined.  One computer downloaded.  Another computer wrote to floppies.  (Shared file server.)  We probably also needed a third to format floppies.  We definitely needed a human to label the floppies.
18:32:03 <dpiponi> edwardk: This may be related to Bernie Pope's article on writing dropWhile using foldr. You need to propagate some information along the reduction.
18:32:28 <dpiponi> edwardk: I don't know if anything useful will come of this, but I think this problem makes a nice puzzle!
18:32:33 <edwardk> yeah
18:32:35 <edwardk> it is
18:32:52 <edwardk> trying to rebuild my linux box so i have a place to test it again =)
18:33:08 <Saizan> q lambdabot
18:33:44 <dolio> edwardk: You might have to switch to scanl after all. :(
18:33:49 <edwardk> current design needs a data type definition
18:33:51 <edwardk> yeah =/
18:34:23 <edwardk> man i hate the scanl version though
18:34:37 <dpiponi> yikes! fire alarm! bye!
18:38:45 <dons> sorear: i wouldn't bother trying to change the Prelude. its just not going to happen.
18:38:57 <edwardk> heh
18:38:58 <dons> offer your code as a seperate library, since people can always hide the prelude anyway
18:39:14 <kpreid> What's the best formatting for: function x = bigexpr1 `infix` bigexpr2?
18:39:26 <kpreid> where I'd like to put the big-exprs on two lines.
18:39:35 <Igloo> kpreid: Bind them in a where clause
18:39:43 <edwardk> function x = foo `infix` bar where foo = ... bar = ... =)
18:39:46 <dons> f x = e1 `op` e2
18:39:50 <kpreid> Actually, making it not infix should will work
18:39:52 <dons>    where e1 = ...
18:40:00 <Cale> dons: which change?
18:40:01 <sorear> dons: my proposed replacement for the prelude would be pretty useless as a library
18:40:11 * QtPlatypus asks "Is there a recomened inplementation for hashes/alists?"
18:40:13 <sorear> dons: it exports nothing
18:40:17 <sorear> QtPlatypus: Data.Map
18:40:20 <dons> sorear: in practice you won't be able to replace the Prelude.
18:40:21 <Cale> I'd really like to see the Prelude undergo a few more revisions.
18:40:30 <dons> only maybe small changes
18:40:40 <monochrom> QtPlatypus: Data.Map
18:41:07 <Igloo> dons: It wouldn't be impossible to do something for Haskell'
18:41:34 <stepcut> Do all H98 programs work in Haskell'?
18:41:35 <sorear> Igloo: read my post, and reply...
18:41:37 <Cale> I'd really really like to see the Monad class and interpretation of do-notation change.
18:41:48 <sorear> stepcut: that would defeat the whole purpose :)
18:41:52 <Cale> (back to what we had in 1.4)
18:41:54 <Igloo> stepcut: Probably not, but Haskell' isn't finished yet of course
18:41:54 <resiak> How would you change Monad, Cale ?
18:42:02 <resiak> and he answers my question as I ask it :(
18:42:16 <edwardk> i really do wish that the standard library made use of MPTCs and instead of taking all the good names at least just made a bunch of typeclasses that used them so you could instance it and get access to the name for your type
18:42:18 <Cale> delete fail, add Functor as a superclass
18:42:34 <stepcut> Cale: agreed
18:42:37 <edwardk> Cale: amen
18:42:41 <dons> yes, some things can be changed. but one guy changing the entire hting without consultation with the community is going to fail.
18:43:01 <Igloo> dons: Well, you have to start with someone proposing something...
18:43:01 <Cale> Certainly there has to be consensus.
18:43:31 <dons> indeed. you have to show a wide range of assurances, technical improvement, and community good will, to make progress.
18:43:32 <Cale> I'd also like the associativity of ($) flipped, which I realise is more controversial.
18:43:33 <resiak> Cale: so people would have to use MonadError or something instead to get at fail?
18:43:39 <Cale> resiak: MonadZero
18:43:47 <stepcut> It might be neat to have a non-H98 fork that is supposedly "Done Right", just to see what it would be like
18:43:49 <Cale> (or sure, MonadError)
18:43:53 <edwardk> cale: that one is a tough sell for me
18:43:55 <resiak> hrm, fair play
18:44:12 <dons> and just the performance issues alone are hard enough for 1 person to manage
18:44:26 <Cale> The only reason fail is in Monad is to support pattern matching against refutable patterns on the left side of <- in do-notation.
18:44:34 <DangerMouse> Cale : Hey :)
18:44:49 <Cale> My take on it is that pattern matching on refutable patterns should create a MonadZero dependency.
18:44:50 <resiak> but but that's really useful
18:44:54 <Cale> DangerMouse: hi :)
18:45:25 <DangerMouse> I finished that program, not sure if i used good practice tho
18:45:55 <Cale> cool
18:46:07 <Cale> resiak: what is?
18:46:36 <Cale> Pattern matching against refutable patterns in monads that are not instances of MonadZero is generally dangerous anyway.
18:46:45 <resiak> yeah, I take your ponit.
18:46:48 <Cale> In such monads, fail just crashes.
18:47:23 <hpaste>  DangerMouse pasted "finished simple game" at http://hpaste.org/1108
18:47:32 <Cale> If you really want to crash, I don't think it's all that horrible to have to write a case :)
18:47:34 <DangerMouse> check it out, tell me what you think
18:50:22 <Cale> It looks reasonable to me -- I don't recognise # though, but presumably it's like length.
18:51:31 <DangerMouse> yeah its length
18:52:02 <monochrom> Many convenient features are there just to make newbies lives easier when writing toy programs.  You never use these convenience in production code.
18:52:27 <DangerMouse> Cale : any improvements which would simplify it in your opinion?
18:53:41 <monochrom> Take for example, in C's library's scanf and gets.  Blatant buffer overruns.  You use them in your second C program because you're still some other parts of C.  You never use them again.
18:53:49 <Cale> DangerMouse: nothing obvious
18:54:01 <DangerMouse> ok cool :)
18:54:18 <monochrom> Haskell's "fail" is another one such convenience.
18:54:52 <Cale> I think it's largely an unnecessary one. I don't think most newbies even do pattern match against refutable patterns in do-notation.
18:55:32 <Cale> I suppose the most common case would be with getArgs.
18:55:44 <dolio> getArgs is pretty much the only place I use it.
18:55:51 <monochrom> Precisely.  I do that all the time when I write toy programs.
18:56:12 <dcoutts> Cale: it's handy in the list monad, no?
18:56:12 <monochrom> Note that in production code you use getOpts.
18:56:25 <Cale> dcoutts: oh, sure, but that's a MonadZero, so no problems there :)
18:56:26 <dolio> But list is MonadZero.
18:57:29 <dcoutts> Cale: ah, yes of course. So one design might be to put fail into MonadZero and have refutible patterns introduce a constraint on MonadZero
18:57:39 <monochrom> A feature that pollutes the semantics just so as to please toy programmers is questionable at best.
18:57:40 <Cale> exactly
18:58:10 <dcoutts> I've never liked the fact that people use Monad m => ... -> m Foo, just to get failures
18:58:13 <Cale> Well, you do have to take toy programs somewhat seriously.
18:58:37 <Cale> But here, I don't think the argument that it unduly harms toy programs works all that well.
18:58:43 <Cale> dcoutts: yes, me too
18:58:51 <dcoutts> aye, if you can make your real programs look like toy ones then you win!
18:59:09 <Cale> It really should be MonadZero to indicate potential failure.
18:59:14 <dcoutts> right
18:59:44 <Cale> This all started with the removal of monad comprehensions
18:59:52 <monochrom> by "toy program" I mean: "I don't check input, I don't handle errors, I don't check bounds".
19:00:11 <Botje> monochrom: most real programs don't do that either :]
19:00:23 <dcoutts> monochrom: well if your error handling system is good, then you can write programs that way
19:00:52 <monochrom> Well, then, "real program" /= "production code".
19:00:53 <liquidengineer> Howdy all
19:01:12 <stepcut> howdy
19:01:15 <Eelis> @hoogle MonadZero
19:01:16 <lambdabot> No matches found
19:01:28 <liquidengineer> My professor was asking me something the other day, after I showed him how to update a data record type
19:01:46 <liquidengineer> "How is this purely functional code?  It looks like you're updating a variable."
19:01:48 <dcoutts> monochrom: are you just talking about getting decent human readable error messages?
19:01:58 <liquidengineer> I couldn't really come up with an answer
19:02:10 <monochrom> No. I'm talking about robustness.
19:02:24 <dons> liquidengineer: its not mutating the box, since the old version is still available :-)
19:02:24 <dcoutts> liquidengineer: you're constructing a new value, the old value still exists and can be used.
19:02:40 <edwardk> liquid: you don't update a variable, you transparently make a new value that copies all of the fields except the ones you change
19:02:56 <dcoutts> liquidengineer: is a + 1 mutating 'a'? No, it's an expression that makes a new value.
19:03:10 <monochrom> This professor must be fired.  He can't tell syntax from semantics.
19:03:53 <monochrom> There are even languages in which you write "x := x + 1" and there is no update.
19:03:53 <stepcut> liquidengineer: try something like --> let newrec = oldrec { field = newValue } in print (oldrec, newrec)
19:04:11 <dcoutts> monochrom: robustness isn't a problem if you're using refutible patterns, when it doesn't match you just get an error. sure it might be nice to get a more contextualised error.
19:04:13 <edwardk> its updating a variable in the same sense as \(a,b) -> (tweak a,b)  updates a variable
19:04:55 <liquidengineer> monochrom: he's a very smart professor...he's just not a haskell minutae expert
19:05:09 <liquidengineer> I figured it was something like this, but I wanted to make sure
19:05:29 <twb> minutia?
19:05:32 <stepcut> liquidengineer: minutae!?! It's a humongeous part of haskell !
19:05:43 <liquidengineer> how is it more efficient than explicitly making a new record?
19:05:52 <edwardk> liquidengineer it isn't
19:06:00 <edwardk> liquidengineer its equivalent
19:06:09 <edwardk> just a more terse syntax
19:06:13 <sorear> OMG!! they fixed mtl!!
19:06:19 <sorear> I can't believe it!
19:06:32 <stepcut> liquidengineer: it *is* making a new record, you just don't have to type in all the code that copies the unmodified fields manually
19:06:33 <dons> you get excited about funny things, sorear
19:06:39 <liquidengineer> stepcut: minutae was a bad choice of words....syntactic sugar, then. :)
19:06:55 <sorear> dons: I assumed it was as likely as you say fixing the prelude is :)
19:07:06 <monochrom> It is more efficient to type in on a keyboard.
19:07:10 <dons> shrug. fixing mtl is easy. external package, ghc only.
19:07:11 <kpreid> liquidengineer: I second the recommendation to make a pair of the old and the new record
19:07:19 <liquidengineer> Hmm?
19:07:21 <liquidengineer> as in
19:07:32 <twb> Perhaps the professor doesn't like candy-coating :P
19:07:39 <dons> you can always spot a true mutable update if it destroys the old value, right, liquidengineer ?
19:07:42 <liquidengineer> funct rec {...} = rec { modified fields...}
19:07:49 <liquidengineer> dons: right
19:07:50 <gh_> hi, i'm trying to define a heterogeneous list as described on that page http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
19:07:53 <lambdabot> http://tinyurl.com/f9umb
19:07:55 <dons> so whenever you wonder if something is modifying statefully, ask yourself: is the old value still around?
19:08:08 <liquidengineer> twb: he likes code that makes it explicit what's happening, and I agree with him there
19:08:12 <gh_>  but the problem is that specifying that a type is an instance of the Show class , and then using the "show" function on one of its members being also of the show class yields that GHC error :
19:08:12 <gh_> Ambiguous occurrence `show'     It could refer to either `show', defined at ./src/Rules.hs:26:1                           or `show', imported from Prelude
19:08:16 <dons> gh_: ok. what kind of values do you want to store in your lists?
19:08:28 * ddarius simply asks himself if he is programming in Haskell as the first question.
19:08:31 <twb> Hmph.
19:08:42 <dons> gh_: can to use hpaste to paste the code you're using?
19:08:42 <monochrom> Assembly code is the only code that makes it explicit what's happening.
19:08:43 <liquidengineer> as for candy coating
19:08:43 <dons> ?paste <--
19:08:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:08:48 <gh_> dons: ok
19:09:06 <liquidengineer> I had a professor that insisted let/where statements weren't pure fp enough, and should not be used
19:09:11 <liquidengineer> this was in scheme
19:09:15 <dcoutts> hah
19:09:19 <hpaste>  gh_ pasted "(no title)" at http://hpaste.org/1109
19:09:26 <twb> liquidengineer: he wanted you to use LAMBDA instead of LET?
19:09:29 <monochrom> There are a lot of mediocre professors out there.
19:09:36 <Cale> Eelis: MonadZero is something from Haskell 1.4. The Haskell 98 committee unfortunately killed it.
19:09:37 <liquidengineer> twb: yes.
19:09:41 <gh_> oops i should have added a comment
19:09:42 <twb> liquidengineer: did you ask him about LETREC? ;-)
19:09:49 <liquidengineer> monochrom: stop insulting my professors.
19:09:55 <dcoutts> twb: fix!
19:09:59 <gh_> the problem is the 2nd show on the lines "show (RL r) = show r"
19:10:02 <dons> Cale: i suggest you send hate mail to the h98 committee
19:10:02 <twb> OK, I'll insult them instead
19:10:05 <monochrom> I am not insulting.  I'm telling you the truth.
19:10:06 <Eelis> Cale: i see, interesting
19:10:15 <dons> calling for the freedom of MonadZero, or stern action will be taking
19:10:16 <liquidengineer> It's a matter of style, not skill.
19:10:17 <dons> taken.
19:10:48 <twb> Regardless of liquidengineer's specific staff, there are certainly mediocre teachers out there, and I daresay there is no dearth of them.
19:10:55 <Cale> gh_: Your problem is that show is the name of a Prelude function. Just rename your show, or import the Prelude's show qualified.
19:11:11 <liquidengineer> Cale: forget hatemail.  Send them sheets and sheets of scheme code
19:11:22 <liquidengineer> twb: agreed
19:11:23 <dons> there's no reason is there to have 'show' defined locally
19:11:33 <dons> just define a Show instance on the side, and move your 'show' into that
19:12:49 <liquidengineer> Is there any movement to change how show instances are defined?
19:13:01 <liquidengineer> I've always found it confusing
19:13:05 <merus> confusing?
19:13:12 <dolio> I think Read is more confusing.
19:13:17 <liquidengineer> I don't do it that often, so when I do it seems like space magic.
19:13:17 <gh_> Cale: i've managed to make it work by renaming show to something else, but i'd like to have the implicit "show" when directly using the object
19:13:23 <monochrom> I have found it advanced, not confusing.
19:13:37 <Cale> You can just define 'show', you don't have to define showsPrec
19:13:41 <gh_>  <dons> just define a Show instance on the side, and move your 'show' into that <- sorry i don"t understand
19:13:43 <liquidengineer> monochrom: well, there it is.  I'm not going to label myself advanced quite yet
19:13:48 <gh_> could you precise ?
19:13:53 <liquidengineer> Intermediate, maybe.
19:14:04 <Cale> gh_: He just means to get rid of your 'show' method altogether.
19:14:11 <Cale> gh_: and use the one from the Show class.
19:14:27 <Cale> Unless you're intending on defining it differently.
19:14:48 <gh_> i'd like to change it
19:15:10 <Cale> Well, when you use 'show' in code, which implementation do you want then?
19:15:10 <dons> why subclass Show then?
19:16:26 <hpaste>  dons annotated "(no title)" with "use Show class" at http://hpaste.org/1109#a1
19:16:58 <hpaste>  Cale annotated "(no title)" with "like this" at http://hpaste.org/1109#a2
19:17:21 <Cale> ah, dons beat me to it :)
19:17:46 <Cale> That'll teach me to test my code :)
19:18:21 <dons> heh
19:18:23 <Cale> Indeed, you don't have to add Show to the context on the existential type.
19:18:28 <gh_> hmm
19:18:40 <Cale> It's implied by the fact that Show is a superclass of Rule.
19:18:56 <monochrom> dons has 80 cores to test his code.
19:19:11 <Cale> What? 80 cores now?
19:19:20 <Cale> I thought it was 16.
19:19:21 <dons> monochrom is silly
19:19:26 <dons> 16 it is.
19:19:26 <gh_> only the last "show" line was problematic, so there's no need to separate "instance" declarations instead for RuleL, i think
19:19:30 <mbishop> are you sure these are cores? are you sure they aren't rabbits? :)
19:19:42 <stepcut> On linux, if I want to write a program that uses multiple processors on an SMP box, do I have to use OS-level threads (or even fork()), or is there some other way to get a program to use multiple cores
19:19:52 <monochrom> Let's just call them cores, whatever they be. :)
19:19:57 <gh_> but yes, you're right , i'm going to separate for RuleL
19:19:59 <dons> stepcut: in what language?
19:20:11 <dons> stepcut: haskell? just use the SMP runtime, and forkIO or `par`
19:20:15 <gh_> thanks dons  & Cale
19:20:16 <stepcut> dons: any -- though, in practice Haskell
19:20:31 <dons> then you just use ghc 6.6 and forkIO liberally.
19:20:37 <dons> with +RTS -N8 at runtime
19:20:46 <dons> to use 8 os threads, which linux will schedule
19:20:47 <stepcut> dons: But, underneath, GHC has to use threads, right ?
19:21:15 <dons> right. it maps M Haskell threads onto N OS threads, whihc the kernel schedules on K cores.
19:21:21 <Igloo> Yes, but GHC will efficiently schedule you 100 Haskell threads on the 8 OS threads
19:21:29 <dcoutts> Philippa: re gtk2hs with svg and SourceView on win32, it's a bit bigger but probably not too bad. I'm not near my win32 box to do a build though atm.
19:22:19 <Cale> It's nice that par is working.
19:22:35 <dcoutts> Philippa: if you want to do a gtk2hs build with those components, you have to go grab all the various deps off the gnome site (there are win32 binaries.)
19:23:17 <dcoutts> Philippa: I can't do it easily myself 'til the end of next month when I'm back in Oxford
19:23:41 <dons> ?temp
19:23:41 <lambdabot>   now 33.7, min 22.2, max 34.5, rain 0.0mm, wind 26km/h NNW
19:24:02 <monochrom> ?temp
19:24:03 <lambdabot>   now 33.7, min 22.2, max 34.5, rain 0.0mm, wind 26km/h NNW
19:24:23 <nornagon> @help temp
19:24:23 <lambdabot> Local temperature
19:24:23 <dons> its not super clever. it assumes everyone lives in sydney.
19:24:29 <nornagon> :D
19:24:30 <dons> reasonable heuristic.
19:24:52 <monochrom> Nice "local" temperature...
19:25:05 <stepcut> it's lambdabots local temperature, not yours
19:25:08 <dons> it is the local temperature .. for lambdabot.
19:25:12 <Igloo> So it rounds to the nearest planet; seems reasonable to me
19:25:15 <stepcut> jinx
19:25:18 <dons> Igloo: right.
19:25:26 <monochrom> OK, I have no beef then.
19:25:30 <sorear> stepcut: do note that forkOS will not help at all, it only affects (by slowing down at that) FFI calls
19:26:01 <dons> sorear: yeah and um, some correctness issues with thread unsafe foreign libs... ;-)
19:26:10 <stepcut> sorear: right. I am more interested in the actual implementation details
19:27:03 <stepcut> I think what I really want to know is how I would write an SMP program (in C/asm) that ran on the bare metal
19:27:25 <dons> pthreads and an smp kernel
19:27:46 <sorear> you would use pthread_create to launch N threads where N is your core count, and schedule jobs yourself
19:28:28 <stepcut> hrm, no I don't want a kernel -- just my program
19:28:45 <sorear> @google intel mp specification
19:28:48 <lambdabot> http://www.uruk.org/~erich/mps.html
19:28:48 <lambdabot> Title: Intel MP Specification compatibility
19:29:05 <sorear> find a document with that approximate title
19:29:08 <edwardk> one would think that if it was truly lambdabot's temperature it would be pretty much consistently around room temperature ;) she doesn't get out much =P
19:29:10 <stepcut> threads are a kernel-level abstraction right? The CPUs don't know anything about 'threads', they just provide the primitives that you can build threads with
19:29:11 <stepcut> ?
19:29:20 <sorear> stepcut: right
19:29:27 <dcoutts> stepcut: some new cpus know about threads
19:29:45 <stepcut> dcoutts: is that what hyperthreading is about ?
19:29:54 <dcoutts> they multiplex many (sometimes hundreds) of threads per core
19:29:58 <ddarius> @temp
19:29:58 <lambdabot>   now 34.0, min 22.2, max 34.5, rain 0.0mm, wind 20km/h NW
19:30:03 <sorear> dcoutts: not really. intel's "HT" processors are virtually 2-core, just with usage requirements
19:30:24 <sorear> dcoutts: so the kernel schedules 2 threads onto the physical processor
19:30:31 <dcoutts> sorear: I'm thinking of Cray MTA or latest NVidia things which multiplex 128 threads per core
19:30:42 <stepcut> Are there other abstractions, besides threads, that people use when writing multicore programs ? Or does everyone use threads and build on top of that ?
19:30:53 <sorear> sparks
19:30:58 <dcoutts> you don't want to treat that as 128 processors
19:31:02 <kpreid> Does GHC come with any concurrency libraries other than what's listed in the docs under Control.Concurrent?
19:31:13 <sorear> Control.Parallel
19:31:32 <sorear> which isn't really concurrency, but accomplishes most of the same goals
19:31:33 <dcoutts> you want to treat it as a single processor that can handle some of the job that the OS scheduler would normally do
19:31:55 <kpreid> right, I'm interested in actual concurrency
19:32:09 <sorear> kpreid: what's actual concurrency?
19:32:17 <sorear> Control.Parallel can use multiple cpus
19:32:35 <dcoutts> sorear: unlike a normal OS thread scheduler these cpus can change thread in a single clock cycle or less
19:32:37 <kpreid> the things which you didn't call "isn't really concurrency" :-)
19:33:31 <sorear> dcoutts: so basically it has multiple instruction feeders, and takes instructions from any thread/register set it pleases?
19:33:34 <dons> kpreid: also the high perf 'unified threads and events' lib
19:33:34 <stepcut> dcoutts: you can do things like switch threads whenever one is waiting for something to be read from memory, right ?
19:33:45 <dcoutts> stepcut: yes
19:33:54 <dcoutts> stepcut: great for latency hiding
19:34:00 <stepcut> yeah
19:34:09 <dcoutts> sorear: something like that, yes
19:34:37 <stepcut> ok, I am going to do some reading now. Thanks!
19:34:49 <dcoutts> afterall for a gfx task you really do want one thread per-pixel
19:34:56 <dcoutts> so you end up with a lot of threads :-)
19:35:27 <sorear> embarassingly parallel rocks
19:36:03 <dcoutts> but still requires interesting designs to make it really really fast
19:38:29 <Cale> I want a 1310720 core machine, so that I can have one core drive each pixel of my display :)
19:39:37 <kpreid> hm. what would you recommend, assuming use only of libraries provided with GHC, for implementing a synchronous call between threads? that is, thread A tells thread B to do something and blocks until thread B responds
19:39:47 <stepcut> Cale: a botnet perhaps :p
19:39:59 <Cale> kpreid: an MVar, perhaps.
19:40:06 <Igloo> kpreid: A should read from an MVar that B puts something into (possibly ())
19:40:08 <dcoutts> Cale: though presumably each core isn't so slow that it takes 1/70th of a sec to calculate the pixel colour?
19:40:12 <kpreid> Okay.
19:40:25 <Cale> dcoutts: I suppose it depends on the task.
19:40:25 <kpreid> That's what I was doing; it just didn't seem quite right
19:40:43 <ddarius> Use specialized hardware
19:40:58 <Cale> You could presumably do some pretty awesome realtime raytracing like that.
19:41:09 <dcoutts> aye
19:41:49 <ddarius> Cale: I have thought about that.  I'd be surprised if it hasn't been done before.
19:47:59 <monochrom> A raytraced scene in which the light source (say, the sun) moves from east to west. that will be cool.
19:48:32 <ddarius> @tell ekidd Not the paper I was looking for but worth reading if you haven't already: http://citeseer.ist.psu.edu/pitts01categorical.html
19:48:33 <lambdabot> Consider it noted.
19:50:00 <sorear> commence flamage.
19:51:17 <edwardk> can someone think of something real quick that qualifies as a haskell functor but doesn't have a meaningful definition for return that makes sense? i'm being a bit of a moron atm
19:51:31 <araujo> hello!
19:52:30 <sorear> edwardk: data HomogPair a = HomogPair a a
19:52:33 <mux> @hoogle Monad m => Maybe a -> (a -> m ()) -> m ()
19:52:34 <lambdabot> No matches, try a more general search
19:53:03 <mux> does someone know something like this?
19:53:16 <sorear> oh nm that has return just not bind
19:53:22 <edwardk> sorear: return is easy there =)
19:53:37 <edwardk> technically they should exist for anything thats really a functor, no?
19:53:57 <edwardk> at least in the categorical sense because i should be able to apply the functor to elements, yielding a 'return'
19:53:58 <dolio> Anything that's an applicative functor, no?
19:54:10 <edwardk> well, applicative is the next step on my foodchain right now
19:54:11 <mux> maybeM_ x a = when (isJust x) (a (fromJust x))
19:54:17 <mux> or something like it
19:54:18 <dons> sorear: so your rant is a bit ranty? i'm not sure I see any proposal there.
19:54:21 <edwardk> i'm trying to roll this all the way up to 'functor' if it makes sense
19:54:31 <dons> sorear: I encourage you to write a better prelude, as a library, using -fno-implicit-prelude
19:54:36 <edwardk> just looking for a good reason not to do so
19:54:43 <mux> @hoogle maybeM
19:54:44 <lambdabot> No matches found
19:54:47 <sorear> edwardk: consider \v -> (Ty,v) where ty has no distinguished element
19:54:56 <mux> @hoogle fromMaybeM
19:54:57 <lambdabot> No matches found
19:54:58 <dons> sorear: so start with -fno-implicit-prelude and then work out a better set of glue for the things you need
19:55:02 <sorear> edwardk: no definition of return is more natural than any other
19:55:06 <dons> it could come as a cabal package, and everyone could use it.
19:55:17 <sorear> edwardk: but fmap is well defined
19:55:26 <edwardk> sorear: fair enough
19:55:36 <edwardk> sorear: i figured there had to be a good example
19:55:49 <Cale> Or just pairs.
19:56:02 <sorear> Cale: pairs handle return just fine
19:56:16 <edwardk> no solution that didn't involve cheating and using fix to force me to be able to populate it =)
19:56:16 <Cale> Not where the first element isn't an instance of Monoid.
19:56:55 <Cale> instance Functor ((,) a) where fmap f (x,y) = (x, f y)
19:57:22 <sorear> dons: oh, so write my multiple modules (Control.Function, etc) separately and make a cabal package of 'things needed to complete base-prelude'?
19:58:12 <Cale> That'd be the foundation for the Writer monad, if only a were constrained to be an instance of Monoid
19:58:15 <Philippa> sorear: a prelude-less haskell doesn't work because numerous bits of syntax desugar into something in terms of the prelude
19:58:16 <dons> yeah. really, you can do this as a proper external library. once you've got code that works, let people know.
19:58:34 <edwardk> yeah
19:58:40 <ddarius> Philippa: Rebindable syntax...
19:58:58 <dons> the general rant is a bit bulat-ish , and likely to alienate, rather than produce anything meaningful.
19:59:00 <dcoutts> sorear: nice rant btw, nailed your 14 thesis to the door of the haskell mailing list :-)
19:59:11 <Philippa> ddarius: sure. I'd like to be able to rebind the fixpoint operator in let, while we're at it :-)
19:59:30 <ddarius> Hmm, not a bad idea...
19:59:37 * sorear likes
19:59:47 <Philippa> ddarius: I know. Lennart suggested it at the last FitA, too
20:00:11 <ddarius> That could get very evil... and entertaining.
20:00:33 <edwardk> i still want overloadable application, so you can make things like [1..] 5 make sense or use function application syntax to dereference array elements
20:00:40 <Philippa> yeah, rebinding it to something involving unsafePerformIO would be a great way to break cow-orkers' heads
20:00:47 <dons> dcoutts: seems like chsingBottoms is yours to play with now.
20:00:57 <dcoutts> dons: aye, so it seems
20:00:57 <ddarius> Philippa: We have that to an extent with mdo
20:01:12 <dcoutts> dons: and ndm thinks Collin isn't much interested in SmallCheck
20:01:16 <Philippa> yeah, except most of the neat uses I can think of involve something that isn't a monad
20:01:18 <edwardk> i admit though that i'll never get my particular wish in haskell though
20:01:31 <sorear> edwardk: I want that one too
20:01:35 * ddarius enjoys chasing bottoms.
20:01:45 <Philippa> because involving a monad means you can't do assorted nifty tricks without running into the halting problem
20:01:51 <Philippa> you chase, I'll catch?
20:01:57 <edwardk> sorear: still juggling some typing issues its causing in my toy compiler =)
20:01:59 <dons> dcoutts: right.
20:02:11 <Cale> The *real* problem with developing an alternate prelude isn't that it's impossible to rebind the syntax.
20:02:19 <ddarius> I've caught enough...
20:02:28 <edwardk> the real problem with the prelude is inertia
20:02:42 <Cale> It's that the entirety of fptools has to be recompiled against your new prelude for it to be useful.
20:02:51 <ddarius> I meant mdo with Identity would essentially allow it, no?
20:02:57 <dons> Cale: well, you can provide your own base
20:03:03 <dons> and your own Prelude, with -fno-implicit-prelude
20:03:04 <dcoutts> edwardk: I know the mathematicians love that kind o thing, but they have the advantage of having a syntactical context, if you're in one area of mathematics you can have syntax mean something different to another area without having to unify them in a single (type) system.
20:03:06 <Cale> That's true
20:03:12 <dons> you just ignore the existing base package
20:03:25 <edwardk> so what is a good name for a functor with return?
20:03:27 <edwardk> dcoutts: yeah
20:03:32 <Cale> edwardk: pointed functor
20:03:36 <sorear> I'm going to keep base, just ditch the prelude.
20:03:49 <edwardk> maybe just "Pointed" to keep the class name short?
20:03:59 <dons> sorear: dive in. dcoutts and i've rewritten the entire list package the last two weeks, you could do the same.
20:03:59 <sorear> split it up and move the pieces into meaningfully named modules.
20:04:02 <dons> less talk, more code!
20:04:10 <sorear> dons: good idea.
20:04:30 <dcoutts> edwardk: so although you can make sense of [1..] 5, it'll confuse the hell out of everyone else when they type that by mistake :-)
20:04:30 <Philippa> sorear: most of the pieces're already in other modules anyway
20:04:39 <edwardk> dcoutts: heh
20:04:55 <Cale> I still want a Prelude which gets imported by default when I don't import any modules.
20:04:55 <edwardk> i really do like it for array accesses and things like that, the list case is just an example
20:05:02 <Philippa> though I doubt most users want to have to import Data.Eq just to use n-patterns
20:05:17 <dcoutts> edwardk: there needs to be enough redundancy in a language so that we can figure out what we've done wrong. If every construct means something then we're in trouble.
20:05:26 <edwardk> people use operator overloading in c++ for function application all the time without anything too drastic in the way of consequences
20:05:33 <Cale> Philippa: or just to, say, use basic list operations :)
20:05:50 <edwardk> i'm not saying give EVERYTHING meaning, just a few extra things here and there ;)
20:05:54 <Philippa> you mean ones like :? :-)
20:06:00 <Cale> heh, yeah
20:06:05 <ddarius> edwardk: C++ is more explicit about types, so that helps disambiguate.
20:06:08 <Cale> It's already annoying enough that every program I write has import Data.List; import Control.Monad...
20:06:48 <dcoutts> edwardk: so 'a b' translates to apply a b, where apply is from a MPTC?
20:06:51 <Cale> On the other hand, it's true that people are way too unwilling to change the Prelude.
20:07:04 <edwardk> dd/dc: well, the array dereferencing thing is more a case against the prelude grabbing all the good accessor operators and names so that the current arrays have ugly syntax
20:07:08 <dcoutts> Cale: I want my IDE to fix that for me (nearly automagically)
20:07:25 <kpreid> Will a thread waiting on a MVar which nothing else holds be garbage collected?
20:07:43 <dcoutts> Cale: so I'll just start writing code and when I compile it'll suggest what I need to import to make it work, so I'l just click, click click and be done.
20:08:02 <Cale> That would be nice.
20:08:23 <Philippa> Cale: I'm in two minds about that - being cautious about adding to it is fair play, and removing from it'd mean keeping two preludes and two sets of libraries side-by-side for most implementations due to backwards compatability
20:08:47 <dcoutts> Cale: underneath it'd use something like hoogle to find a name with a suitably compatible type and suggest I import that
20:08:51 <edwardk> dc: in my toy language right now it translates into an infix application of the &apply; function, and that can be in scope with a definition that uses a typeclass. so in essence i don't have traditional function application, just binary sections and everything gets translated into those terms
20:08:54 <sorear> damn lag
20:09:10 <dcoutts> edwardk: mm
20:09:46 <sorear> @botsnake
20:09:47 <lambdabot> :)
20:09:50 <Philippa> what do you do when there's more than one sensible kind of application in a position? How do you disambiguate?
20:10:30 <edwardk> dc: so you could 'almost' let &apply; = (*) in 1 2 3 4  but its hard to write &apply; functions that way coz of circular bindings in let
20:11:44 <ddarius> Hmm... overloading apply to make reflective towers...
20:11:45 <kpreid> send :: MVar a -> (MVar b -> a) -> IO b -- nice message sending abstraction, but I haven't figured out how to receive neatly
20:12:20 <Cale> kpreid: oh, if you're doing message passing, look at Chan
20:12:30 <edwardk> philippa: well, there is only one definition for &apply; in scope, to support the list and array notations above you'd make that something like (bastardizing and mixing back in haskell syntax) &apply; :: Applicable f x y => f -> x -> y   the problem you have is the way types propagate forward and backward through &apply; don't work so well using haskell style MPTCs
20:12:41 <kpreid> Cale: I don't want unboundedness.
20:12:57 <kpreid> Cale: I'm trying to do this in Haskell: http://www.rosettacode.org/wiki/Synchronous_Concurrency
20:12:59 <lambdabot> Title: Synchronous Concurrency - Rosetta Code
20:14:09 <Cale> kpreid: okay
20:14:17 <Cale> kpreid: I'll take a shot at it.
20:14:22 <edwardk> thinking on top of my head right now something like (&apply;) :: Apply a b c => a b c -> b -> c might work but i'd have to think about the loss of flexibility
20:14:28 <kpreid> Cale: want to see what I have so far?
20:14:38 <Cale> sure
20:15:20 <hpaste>  kpreid pasted "'Synchronous Concurrency' solution" at http://hpaste.org/1110
20:15:33 * ddarius thinks, but why stop there! &TypeApply; !
20:15:35 <kpreid> Cale: it works, but it's ugly
20:16:08 <edwardk> ddarius: in my case my type syntax is the same as my base syntax (dep. type system) so that comes along 'for free' ;)
20:17:11 <edwardk> now i just need to make everything work =P
20:17:12 <ddarius> edwardk: Indeed, the next step would be to close the circle to have a tower of applys for ever higher "sorts"
20:18:06 <hpaste>  allbery_b pasted "gtk2hs TreeModelSort overlapping instances?" at http://hpaste.org/1111
20:19:07 <edwardk> anyways i like the apply thing, i'm not sure i'm totally sold on it yet. a 'practical' solution might be to build the application like normal using -> and when the type doesn't match there, THEN hack in a check for a typeclass
20:19:25 <dcoutts> allbery_b: hmm
20:20:04 <allbery_b> if I try to use the List<Model directly it claims it's not sortable
20:20:09 <allbery_b> er, ListModel
20:20:15 <ddarius> edwardk: Base cases are for wusses, coinduction ho!
20:21:09 <allbery_b> (the unsafe init is because I'm using runhaskell for prototyping)
20:21:30 * ddarius doesn't feel like he's being very constructive/productive/useful right currently.
20:21:40 <dcoutts> allbery_b: the ListModel is not sortable
20:21:50 <dcoutts> allbery_b: the new one that is, we've not done that yet
20:22:32 <dmwit_> ?src Monoid
20:22:32 <dons> dcoutts: is the rejig of the testsuite modules in a reasonable state?
20:22:32 <lambdabot> class Monoid a where
20:22:33 <lambdabot>     mempty  :: a
20:22:33 <lambdabot>     mappend :: a -> a -> a
20:22:33 <lambdabot>     mconcat :: [a] -> a
20:22:49 <dons> should it be pushed, or do you want to hang onto it till you're done?
20:23:08 <dcoutts> dons: I'm done, I've pushed it (save some Makefile fixes)
20:23:53 <dons> great. got it.
20:24:29 <sorear> hello.
20:26:01 <dons> so has everyone got their SoC project applications in?
20:26:28 <zarvok> hmm, I might submit one
20:26:34 <dons> better hurry up then!
20:26:43 <zarvok> been working on it a little, but haven't completely decided yet
20:26:54 <zarvok> I think I have a day yet, thankfully
20:27:04 <zarvok> will either move into high gear on it tomorrow or abandon it
20:27:16 <zarvok> lots of people submit for haskell?
20:27:53 <dons> last year, yes.
20:28:15 <zarvok> yeah, they extended the application deadline until monday, otherwise I would have finished it today, but now I have tomorrow and sunday
20:28:30 <zarvok> you guys can't see how many have come in so far?
20:28:33 <dons> we've not had that many applications this time, actually.
20:28:35 <zarvok> ah
20:28:37 <zarvok> well
20:28:44 <zarvok> I am guessing you'll see a big push in the last few days
20:29:24 <araujo> dons, if only we had space for some applications :-)
20:29:45 <dons> araujo: btw, re. PCRE, you're aware of regex-pcre?
20:29:49 <dons> its on hackage.
20:29:49 * araujo still thinking to send one of his favorite idea though
20:30:10 <araujo> dons, yeah, i don't think it wouldn't be _that_ different
20:30:16 <dons> sjanssen: you going to submit some time?
20:30:33 <dons> zarvok: i'd strongly consider submitting. work on libraries would be very welcome.
20:30:56 <zarvok> this last month has been very busy for me, trying to decide where to go to gradschool and visiting places, so I haven't had time to work much on the app until this week.  I bet many others are in the same boat
20:30:56 <dcoutts> dons: right, I'm off to Lewisham to look at a room...
20:31:15 <dons> ok. catching the train?
20:31:15 <vincenz> zarvok: what's the app on?
20:31:27 <dons> its 3 stations in from Newtown.
20:31:31 <dmwit_> Just out of curiosity, are mentors also paid?
20:31:35 <dons> dcoutts: and you might want a hat or sunscreen :-)
20:31:35 <dcoutts> dons: yep, train
20:31:36 <dons> dmwit_: nope.
20:31:58 <dons> we do it for the love of lambdas :-)
20:32:04 <zarvok> heh, it keeps changing, I don't want to reveal to much until I've had time to think about it more
20:32:12 <zarvok> broadly, improvements to parsec
20:32:32 <dons> i'd also consider a backup submission to port a popular library from python or erlang
20:32:53 <dons> a competent FP programmer, planning to work on libraries, has a high chance of acceptance, imo
20:33:08 <zarvok> hmm, thanks for the advice dons, I'll consider that
20:33:13 <zarvok> still have a few days left, so I could write two
20:33:17 <dons> i would.
20:33:30 <dons> go for the one you'd love to do, and one that has a high demand in the community
20:33:48 <dons> i'd take a peek at the top libs from erlang, python, ruby etc, and see which ones are missing, that you'd like to port
20:33:54 <dons> mnesia?
20:33:59 <zarvok> yeah, that makes sense
20:34:33 <twb> I can tell you one thing that Haskell doesn't have yet.
20:34:35 * ddarius can't wait 'til 2010.
20:34:45 <ddarius> subtyping?
20:34:49 <twb> A swank daemon for the Emacs SLIME environment.
20:35:02 <vincenz> I liked ddarius' answer
20:35:06 <CosmicRay> twb: oh, I thought you were going to say a default VM that needs 1GB RAM to do trivial things ;-)
20:35:15 <CosmicRay> not that I have ever been annoyed at java, no siree.
20:35:33 <twb> CosmicRay: I generally refuse to even install Java on my systems.
20:35:50 <vincenz> "Java(tm): Finally show off the capabilities of that brand new computer of yours to your friends"
20:35:54 <CosmicRay> twb: the web interface to our ERP system at work is written in java, runs under tomcat
20:36:09 <twb> >boom<
20:36:12 <CosmicRay> twb: we have no choice but to maintain it.  its process usually uses about 2gb ram
20:36:13 <twb> buzzword overload
20:36:49 <CosmicRay> twb: ERP == enterprise resource planning.  a system that takes orders, tracks accounting, handles purchase orders, optimizes manufacturing resources according to forecasts, etc
20:36:52 <araujo> hah, insane
20:36:57 <CosmicRay> iow, the core of a manufacturing company's business
20:37:10 <CosmicRay> tomcat == apache's java-based web server
20:37:27 <CosmicRay> 2gb == way too much ram to need for a web frontend to a database
20:37:35 <twb> So tomcat isn't part of apache-the-program?
20:37:38 <kpreid> Cale: how's it going?
20:37:44 <CosmicRay> twb: no, completely independent
20:37:45 <Cale> okay
20:37:56 <twb> So you need mod_proxy to bolt it onto apache?
20:38:00 <kpreid> I didn't think this was that complicated :)
20:38:06 <edwardk> twb: thats one way
20:38:12 <CosmicRay> twb: yes
20:38:19 <twb> Ha
20:38:28 <CosmicRay> twb: we are using it infact, because tomcat doesn't seem to be able to grok our ssl cert properly
20:38:38 <edwardk> mod_jk works
20:38:39 <Cale> Well, there's just enough communication to make things somewhat irritating. It's not hard, but it's not a completely trivial example.
20:39:14 <CosmicRay> we chucked a dual dual-core opteron with 8GB RAM at the thing and it runs decently now
20:39:15 <twb> edwardk: ah, I see.
20:39:31 <edwardk> mod_jk you can then just JkMount the appropriate servlet containers
20:39:47 <edwardk> avoids a lot of unpleasantness =)
20:39:48 <kpreid> Cale: I take it you're writing a solution greatly different from mine?
20:39:52 <twb> CosmicRay: how many people work at your company?
20:39:52 <twb> Er, that is, how many employees do you have?
20:39:53 <CosmicRay> right now it's pretty idle, so RSS is "only" 437M and VSZ is 1985M
20:39:56 <Cale> kpreid: yeah
20:40:12 <dons> CosmicRay: scary.
20:40:18 <CosmicRay> twb: we usually have about 50-70 using it simultaneously at peak times.
20:40:31 <CosmicRay> dons: yeah.
20:40:42 <twb> Hmph.
20:40:49 <twb> If it was 1000, 2GB might be justified.
20:40:49 <CosmicRay> right.
20:41:07 <Philippa> depends
20:41:16 <CosmicRay> all the business logic is on a different box.
20:41:26 <CosmicRay> all this thing does is send xml queries to it, and html to the client.
20:41:26 <Philippa> ...that would be part of the depends, yes
20:41:33 <twb> o_O
20:41:59 <twb> Eight Meg and Constantly Swapping used to be an insult
20:42:03 <CosmicRay> hehe
20:42:15 <CosmicRay> we used to have both this piece and the business logic on a single AIX box.
20:42:23 <CosmicRay> that was, shall we say, extremely frustrating.
20:42:32 <Philippa> eight meg doesn't hold my display's frame buffer these days
20:42:51 <CosmicRay> Philippa: hell, it probably doesn't even hold many display *drivers* these days.
20:42:59 <twb> To be fair, emacs is using 60M on my workstation.  It's playing music and IRCing to three servers and browsing the web and running half a dozen comints, tho.
20:43:08 <CosmicRay> hehe
20:44:02 <monochrom> emacs plays music?!
20:44:04 <CosmicRay> the sad thing about java is that it *can* be lean.
20:44:06 <twb> evince is using about 90M :-(
20:44:16 <stepcut> twb: mine's at 93M
20:44:27 <twb> CosmicRay: well duh, that would be called Common Lisp :-)
20:44:27 <stepcut> (my emacs, not evince)
20:44:45 <twb> stepcut: I only started Emacs this week, that may be why
20:44:47 <CosmicRay> 3
20:44:56 <CosmicRay> heh
20:45:52 <monochrom> I knew one could organize one's life around emacs, but .... but ... but music too?  I must be very old.
20:46:16 <twb> monochrom: it doesn't actually play the music.  It just edits the playlist.
20:46:56 <twb> But EMMS was too bloated and unresponsive, so I'm using a teeny little library that just talks to mpd.
20:46:59 <monochrom> Next month you'll be telling me you run Windows Vista inside a VM inside emacs. :)
20:47:11 <vincenz> twb: any helpful tips on how to get started with emacs, I'm a vimmer
20:47:18 <twb> vincenz: C-h t :P
20:47:36 <vincenz> oh that one :/
20:47:37 <CosmicRay> vincenz: heh, I have just been trying vim for the first time.
20:47:41 <CosmicRay> I like it for the most part so far
20:47:48 <vincenz> CosmicRay: me too, I like it a lot
20:48:04 <sorear> hello ChanServ
20:48:12 <sorear> urg, tabcomplete
20:48:16 <monochrom> hahaha
20:48:16 <chessguy> hi all
20:48:16 <sorear> hello chessguy
20:48:20 <chessguy> hi sorear :)
20:48:34 <chessguy> it's ok, ChanServ and i look a lot alike :)
20:48:46 <araujo> chessguy!
20:48:53 <chessguy> sorear: i was just reading your email about Prelude. very interesting
20:48:56 <chessguy> araujo!
20:49:40 <chessguy> i think it should be taken more seriously than Don's flippant response
20:49:48 <CosmicRay> vincenz: I am not very happy with haskell indentation in either vim or emacs.
20:50:10 <vincenz> CosmicRay: I typically manually lay out code
20:50:11 <dons> anyone used openwengo?
20:50:31 <dons> chessguy: hmm. it wasn't flippant. I was trying to suggest something concrete be done
20:50:38 <Cale> !paste
20:50:39 <dons> rather than just another random rant, with no follow up.
20:50:39 <hpaste> Haskell paste bin: http://hpaste.org/
20:51:03 <dons> since I for one found it difficult to work out exactly what sorear was proposing to do.
20:51:18 <hpaste>  Cale annotated "'Synchronous Concurrency' solution" with "another solution" at http://hpaste.org/1110#a1
20:51:24 <dons> much better to just go ahead, show us how an alternate Prelude would work, get people using it, and then see what happens.
20:51:25 <sorear> dons: kill the prelude entirely.  make everyone import Data.Num.
20:51:32 <dons> that's how you GET THINGS DONE with open source.
20:51:36 <chessguy> dons: your suggestion doesn't deal with his major point that "psychology trumps technology"
20:51:51 <chessguy> he wasn't proposing that a new prelude is needed
20:51:58 <Cale> We could section off another "reader" process from main as well.
20:52:00 <chessguy> did you even read it?
20:52:19 <dons> chessguy: of course. and as I said earlier, if you'd been following, that's not going to happen.
20:52:25 <JohnnyL> what's the haskell equivalent of inheritence?
20:52:27 <dons> esp. without actual code to show us how it would work instead.
20:52:34 <chessguy> dons: i haven't been following, i just got here
20:53:13 <chessguy> dons, he's not talking about new code being needed
20:53:21 <chessguy> he's talking about moving the existing code
20:53:27 <hpaste>  Cale annotated "'Synchronous Concurrency' solution" with "section off the reader." at http://hpaste.org/1110#a2
20:53:29 <sorear> dons is a pessimist, people are defending me
20:53:43 <sorear> what parallel universe have I been transported to?
20:53:52 <chessguy> sorear: it would be a bit of a drag though, importing so much stuff
20:54:13 <edwardk> cale: ok, Pointed was ok for a Functor with return, how about one where i have extract and duplicate, but not return. Pointed is to Monad as _ is to Comonad
20:54:27 <edwardk> can't think of a good term
20:54:39 <ddarius> chessguy: Actually, reorganizing the Prelude would only be a transitionary step
20:54:46 <dons> really, you need concrete, precise examples of why the current system sucks, what the new system would look like. how you migrate from one to the other and so on. talk about fundamental language change is too cheap these days , just ask bulat.
20:54:46 <Cale> kpreid: This solution has the nice effect that it's make completely explicit which parts of the code have which permissions to the communication channels.
20:54:55 <twb> The way you get things done in Open Source is by going up to the nearest hacker and say "hey, linux sucks, Windows can do <task> better and easier."
20:54:58 <ddarius> copointed
20:54:58 <edwardk> i realize that extract and duplicate and a functor imply the existence of a comonad, so it may not have a good answer
20:55:09 <edwardk> i suppose i can live with that if i must
20:55:24 <chessguy> ddarius: transitionary to what?
20:55:24 <Cale> edwardk: If you have both extract and duplicate, you have a comonad.
20:55:36 <JohnnyL> does haskell have inheritence?
20:55:37 <Cale> If you have just extract, I don't know.
20:55:55 <ddarius> The way you get things done in Haskell is by going up to Oleg and saying, "hey, Haskell's type system can't do that."
20:55:59 <Cale> JohnnyL: Not really.
20:56:09 <kscaldef> JohnnyL: what do you mean by "inheritance"?
20:56:19 <monochrom> inheritance is a hoax
20:56:20 <Cale> Yeah, the answer sort of depends on what you mean.
20:56:24 <ddarius> chessguy: To a large extent, sorear's suggestion is just a means to an end (though it is also partially an end itself)
20:56:30 <edwardk> cale: i'm applying that kidd/oleg trick and breaking apart Comonad into two pieces so i can build comonads over more limited categories than 'the category of all types'
20:56:38 <Cale> It has ways to ensure that instances of one class are instances of another.
20:56:38 <chessguy> ddarius: what end?
20:56:52 <Cale> edwardk: ah
20:56:58 <JohnnyL> kscaldef, extends in java.
20:56:59 <kpreid> Cale: would you care to post that on the wiki?
20:57:00 <JohnnyL> data [a]        = [] | a : [a] deriving (Eq, Ord)
20:57:05 <twb> JohnnyL: Haskell is not "object oriented" like Smalltalk and Simula
20:57:05 <ddarius> chessguy: The various things he said would be nice to be done that can't be done currently.
20:57:10 <kpreid> the wiki I referred to, I mean
20:57:21 <JohnnyL> twb, oh ok
20:57:31 <edwardk> cale: basically going through and seeing what a minimal Monad/Comonad/Arrow library looks like that has the current structure removed and substituted for by abusing that hack
20:58:03 <chessguy> hmm, maybe i need to go back and re-read. i thought he was saying that putting all the stuff that's currently in the prelude into other modules would fix all the problems he was listing
20:58:30 <ddarius> chessguy: Not immediately.  Rather, it would allow them to be fixed more easily.
20:58:51 <chessguy> ok, fair enough
20:58:59 <Cale> kpreid: okay, adding it.
20:59:10 <edwardk> ddarius: i would like to see a reasonable substitute prelude, even if i wind up writing it myself just to get used to some of the ideas for my own toy language
21:00:00 <chessguy> i think it's a very interesting solution to the catch-22 suffered by the common pattern of "get popular, get stagnant" in many languages
21:00:17 <dons> anyone can fork base, and write programs to target that. cabal has full support for external packages, and you can hide the current Prelude. so just fork, hack, stick it on cabal, and be done with it.
21:00:26 <ddarius> chessguy: I don't see it as really addressing that issue much if at all.
21:00:32 <dons> e.g. here's dcoutt's and my base to use stream fusible lsits, http://www.cse.unsw.edu.au/~dons/code/streams/base/
21:00:33 <lambdabot> Title: Index of /~dons/code/streams/base
21:00:45 <edwardk> dons: ah neat idea
21:00:45 <stepcut> I heard real hackers use -fno-implicit-prelude for all their code
21:00:47 <dons> so, just follow that model. grab base, remove Prelude, fix things that break. iterate.
21:00:55 <dons> stepcut: exactly.
21:01:03 <monochrom> I don't want to be a hacker.
21:01:17 <dons> there's no need to complain about Prelude, when you can hide it and define your own now, without needing to hack ghc
21:01:31 <chessguy> dons: you still haven't gotten the "psychology trumps technology" point
21:01:36 <edwardk> hahaha
21:01:55 <dons> chessguy: the barriers to adoption of new base libs are lessened greatly by cabal and hackage.
21:02:02 <ddarius> As, ironically, chessguy aptly demonstrates right now.
21:02:16 <sorear> ddarius: how so?
21:03:32 <ddarius> sorear: We have a technical solution right now, but chessguy is resistant to it for the pyschological reason that he views others as being resistant to it for psychological reasons.
21:04:09 <monochrom> psychology reaches a fixed point? :)
21:04:32 <JohnnyL> what will premium give us?
21:05:15 <monochrom> who is premium?
21:05:27 <chessguy> ddarius: that doesn't even make sense
21:05:52 <monochrom> I understand ddarius.
21:05:57 <JohnnyL> monochrom, isn't that the new haskell standard?
21:06:01 <JohnnyL> up and coming.
21:06:06 <monochrom> No.
21:06:08 <ddarius> Prime
21:06:12 <JohnnyL> oh prime.
21:06:13 <JohnnyL> haha
21:06:14 <JohnnyL> ok
21:06:18 <dons> sorear: so the way forward I see is to fork base. then provide new-base-0.1, without Prelude, and proceed from there.
21:06:18 <JohnnyL> what will that bring us?
21:06:37 <ddarius> Nothing
21:06:44 <twb> JohnnyL: pasta!
21:06:45 <ddarius> In theory
21:06:54 <dons> that has a chance of having people use it. i can't see any other way to do this.
21:06:56 <JohnnyL> twb, lets make pasta!
21:07:07 <lgbr> how do I make a function with no arguments?
21:07:11 <dons> f = 1
21:07:11 <monochrom> standardization of many GHC extensions
21:07:12 <chessguy> dons: that's a good suggestion
21:07:13 * ddarius has to make pasta soon.
21:07:22 <dons> lgbr: like that?
21:07:30 <dons> > let f = 1 in f -- function with no arguments.
21:07:32 <lambdabot>  1
21:07:52 <sorear> dons: any special magic I need to get a basey package to compile?
21:08:00 <dons> sorear: the other possible route is to proceed piece by piece to move things into non-Prelude.
21:08:05 <lgbr> dons: compiler doesn't like that. Says "Ill-formed left hand side of a clause"
21:08:14 <dons> hmm? clause?
21:08:24 <dons> that doesn't sound like a haskell error message?
21:08:25 <sorear> dons: base includes GHC.Prim etc, and I'm not sure that will be easy in a new base
21:08:28 <dons> ?paste <-- the code.
21:08:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:08:39 <lgbr> dons: It's ML (i was hoping they're close enough)
21:08:47 <monochrom> val f = 1
21:08:54 <dons> sorear: no magic really. though you'll want to either hide base, or move it under Experimenta.* or New.*
21:09:09 <dons> sorear: or maybe start with an empty repo and add things in piece by piece
21:09:21 <dons> starting with the things in GHC.Base you need
21:09:29 <sorear> dons: how do I access unwritable stuff like *#?
21:09:38 <hpaste>  lgbr pasted "(no title)" at http://hpaste.org/1112
21:09:40 <dons> GHC.Prim you mean?
21:09:44 <sorear> I can't copy GHC/Prim.lhs for obvious reasons
21:10:05 <dons> you will need a GHC.* and NHC.* layer at the bottom
21:10:08 <dons> to get at the primops
21:10:22 <dons> it could be quite small, just reexport GHC.Prim, then box values.
21:10:35 <dons> but in practice you'll want most of GHC/*
21:11:02 <monochrom> OK. At present I import Prelude, but it's really a re-export of various things in GHC.*, right?  Under your scheme, you delete Prelude, you use a new module collection to do the re-export.
21:11:11 <dons> also, you might want to peek at the other altenrate preludes out there.
21:11:12 <sorear> dons: AIUI, the name, contents, and package of GHC.Prim is wired in to the compiler, so I *can't* hide base. but if I don't hide base my Data.Map etc will conflict with the like-named packages in base
21:11:15 <lgbr> dons: http://hpaste.org/1112
21:11:37 <sorear> s/last packages/modules/
21:11:39 <dons> sorear: you always have GHC.Prim, yes.
21:12:05 <dons> sorear: I think you should be able to hide base. if that's not possible, move under a name space
21:12:09 <dons> New.Prelude
21:12:12 <dons> New.GHC.*
21:12:38 <dons> i don't see why GHC.Prim prevents you from hiding base though.
21:13:47 <dons> lgbr: eitherTree(1) looks wrongly typed?
21:14:11 <monochrom> I'll put it this way.
21:14:28 <lgbr> dons: ..... whoooooooooooooooooooops
21:14:38 <monochrom> I've never seen "val name = type(1)".  I've only seen "val name = expression(1)".
21:14:55 <sorear> dons: can I re-expose a module?
21:15:22 <sorear> (as opposed to re-exporting all the same names from a new module)
21:15:30 <chessguy> yes you can
21:15:33 <dons> yes.
21:15:36 <dons> module M (module Foo) where ..
21:15:48 <sorear> that just re-exports the name
21:16:02 <sorear> the haddocks for ghc.prim say re-exporting its names will crash the compiler
21:16:03 <dons> oh, you want Foo itself to be importable?
21:16:15 <sorear> so I need to re-export ghc.prim itself
21:16:31 <dons> can you avoid touching GHC.Prim for now, and try to just get base to buidl without the Prelude module ? :-)
21:16:38 <chessguy> you want to export Foo from Foo?
21:16:43 <dons> small steps...
21:17:17 <sorear> dons: if I don't touch GHC.Prim I'll need to call my package base, not new-base :)
21:17:18 <monochrom> I vote for small steps.
21:17:27 <sorear> dons: that'll certainly hinder adoption
21:17:51 <dons> show me the compiler error you get.
21:18:28 <sorear> I'll take that as code for "stop worrying and try it"
21:18:41 <dons> yes.
21:18:52 <dons> try removing Prelude. see what breaks. repeat.
21:19:13 * sorear copies and renames base to new-base, and tries to build it
21:19:27 <dons> and don't try to do grand visionary rebuilding. that'll just fail like bulat's base splitting attempt. there's just too much stuff for 1 person to handle.
21:19:46 <sorear> include-dirs:   include, ../../ghc/includes
21:19:50 <sorear> that looks scary
21:20:21 <twb> How do I resolve an error like "Could not find module `Graphics.X11.Xinerama'" into an apt-get install <package> invocation?
21:20:55 <dons> twb, make sure X11-extras is installed first?
21:21:32 <twb> dons: and what is that package called, in Debian?
21:21:52 <hpaste>  sorear pasted "Why wait for compiling when merely configuring can panic?" at http://hpaste.org/1113
21:22:06 <Shimei> @where pfesetup
21:22:07 <lambdabot> I know nothing about pfesetup.
21:22:33 <sorear> dons: I'm not removing the prelude just yet - I'm waiting to see how hard it is to build base outside libraries/
21:22:47 <sorear> dons: then I'll worry about changing the code
21:23:55 <newsham> anyone here familiar with isabelle/hol?  I have a simple question.
21:24:27 <dons> twm, X11-extras isn't packaged for debian
21:24:30 <dons> ?where X11-extras
21:24:30 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/X11-extras
21:24:34 <dons> nor has it been released yet..
21:25:04 <sorear> dons: even runhugs won't consent to run :/  something about having a file named Prelude.hs in the current dir, I think
21:25:16 <monochrom> I hope I know hol (but not necessarily isabelle/hol) enough to answer a simple question.
21:25:30 <sorear> adding -i to runhaskell fixed it.  Wierd.
21:25:46 <monochrom> The only thing I know about isabelle/hol is it has type classes done right, i.e., with axioms. :)
21:26:19 <sorear> and in less than five seconds base fails to build
21:26:21 <sorear> Data/IORef.hs:37:25: parse error on input `#'
21:26:23 <dons> sorear: i'd consult the docs on using your own Prelude.
21:26:36 <dons> there's something on that in the ghc user's guide
21:26:47 <dons> you'll also need to duplicate any flags from ghc's Makefiles
21:28:12 <newsham> mono: sent in msg.. its kinda a syntax question.. dunno if knowing hol will help.
21:29:06 <monochrom> Sorry, I blocked msgs.  Could you re-send?
21:29:37 <sorear> attempting to compile a renamed (but not otherwise modified!) base:
21:29:43 <sorear> GHC/Base.lhs:91:0:
21:29:43 <sorear>     Failed to load interface for `GHC.Prim':
21:29:43 <sorear>       it is a member of package base, which is hidden
21:29:52 <newsham> how can you irc with msgs blocked?
21:30:14 <monochrom> By using #haskell
21:30:27 <newsham> *sigh*
21:30:41 <waern> sorear, are you using cabal-setup? I think you need to use the makefile, and be in the ghc directory
21:30:47 * ddarius almost never gets msg'ed.
21:30:52 <newsham> resent....
21:31:01 <sorear> waern: what's cabal-setup?
21:31:09 <waern> sorear, GHC.Prim is generated from a primops.txt or something like that
21:31:09 <sorear> waern: I was using runhaskell
21:31:17 <waern> sorear, that's what I meant
21:31:38 <monochrom> Yuck, I don't receive it. So this time it's probably the server disliking me for not registering my nick.  Sorry, sorry.
21:31:38 <sorear> waern: I know about the magic of GHC.Prim, I told dons it wouldn't work, he said don't worry
21:31:45 <waern> Igloo has worked on cabalizing base, maybe he can help you
21:31:48 <sorear> monochrom: set +6 usermode
21:32:15 <sorear> monochrom: +6 means to accept msgs from people who aren't registered, like newsham
21:32:28 <sorear> Igloo: ping?
21:32:36 <sorear> @localtime Igloo
21:32:38 <lambdabot> Local time for Igloo is Sat Mar 24 04:30:58 2007
21:32:38 <dons> sorear: i said, try it, if that fails, move under New.*
21:32:39 <ddarius> As is clearly conveyed by 6.
21:32:57 <waern> I would also like base to work with cabal, since that would make it easy to generate docs for it with haddock.ghc
21:33:17 <waern> or atleast, easier
21:33:26 <monochrom> I'm also in #haskell-blah now.  Perhaps it can be done there.  Sorry.
21:38:50 <lgbr> how do I print, like C's printf?
21:39:14 <monochrom> look into Text.Printf
21:39:39 <monochrom> However, for simpler things, there is putStrLn.
21:39:51 <dons> > printf "%s\n" "foo" :: String
21:39:52 <lambdabot>  "foo\n"
21:39:59 <dons> > print "foo"
21:40:01 <lambdabot>  <IO ()>
21:40:04 <dons> > show 1
21:40:05 <lambdabot>  "1"
21:40:07 <dons> > show pi
21:40:08 <lambdabot>  "3.141592653589793"
21:40:48 <monochrom> Most often I just do: putStrLn ("I am " ++ show 5 ++ " years old")
21:41:15 <bd_> (show 5) >.>
21:41:21 <bd_> which is really kind of annoying :/
21:41:37 <bd_> > ("I am " ++ show 5 ++ " years old")
21:41:39 <lambdabot>  "I am 5 years old"
21:41:41 <bd_> oh
21:41:42 <bd_> hmmm
21:41:49 <bd_> I thought it needed parens oO
21:42:19 <monochrom> Haha
21:42:23 <bd_> though come to think of it I guess ++ doesn't bind tighter than application
21:43:58 <ddarius> Nothing binds tighter than application
21:44:48 <sorear> ddarius: qualifying . :)
21:44:52 <dons> its super glue!
21:45:06 <sorear> > Prelude.negate 5
21:45:08 <lambdabot>  -5
21:45:09 <dons> sorear: heh.
21:45:14 <sorear> > Prelude.(negate 5)
21:45:16 <lambdabot>   Not in scope: data constructor `Prelude'
21:46:47 <ivanm> What does the "I'm writing a raytracer in the typesystem" part of the title relate to?
21:46:56 <ivanm> s/title/topic
21:47:05 <dons> someone was doing that. :-)
21:47:09 <dons> just a #haskell moment
21:47:27 <ivanm> what's a raytracer though?
21:47:34 <ddarius> ivanm: Someone said, in response to sorear, "#haskell: Where "I'm writing a raytracer in the typesystem" is not an idle threat."
21:47:43 <ddarius> @google raytracer
21:47:44 <lambdabot> http://en.wikipedia.org/wiki/Ray_tracing
21:47:45 <lambdabot> Title: Ray tracing - Wikipedia, the free encyclopedia
21:47:47 <ddarius> @google POVRay
21:47:50 <lambdabot> http://www.povray.org/
21:47:50 <lambdabot> Title: POV-Ray - The Persistence of Vision Raytracer
21:47:58 <ivanm> oh, as in vector images?
21:48:04 <ddarius> No.
21:48:24 <ddarius> As in tracing light rays backwards.
21:48:26 <ivanm> oh, yeah, I get it now
21:48:38 * ivanm was meant to know this for a visualisation subject...
21:49:12 <ivanm> is the "raytracer in the typesystem" meant to make any sense?
21:49:23 <monochrom> Someone is writing an X window manager in the type system.
21:49:23 <ivanm> or is that the whole point (that its nonsense)?
21:49:37 <ivanm> in the type system? as in Eq, Show, etc?
21:49:43 <monochrom> Yeah!
21:50:01 <Cale> kpreid: http://www.rosettacode.org/wiki/Synchronous_Concurrency#Haskell
21:50:03 <lambdabot> Title: Synchronous Concurrency - Rosetta Code
21:50:05 <ddarius> ivanm: It wouldn't even be particularly hard to do.
21:50:08 <sorear> Having ranted about the evils of the Prelude, I now have my thoughts gelled enough to understand how to split base
21:50:11 * ivanm is confused... how does a type system let you make a window manager
21:50:19 <sorear> I will now start this project.
21:50:29 <Cale> everyone else, if you have any ideas about how to make that code cleaner, let me know :)
21:50:40 <ivanm> sorear: which project is this?
21:50:40 <monochrom> It is advanced.  First, understand how to do arithmetic in the type system.
21:50:49 <sorear> If it does not soon show hopelessness, I will don a clothespin and enlist Bulat via e-mail.
21:50:53 <ivanm> monochrom: as in Eq + Eq? :s
21:51:08 <sorear> ivanm: base-splitting
21:51:10 <ddarius> monochrom: That's easy.  Or at the very least no harder than understanding how to do arithmetic period.
21:51:12 <monochrom> No. Look for "type-level arithmetic"
21:51:21 <monochrom> Yes ddarius.
21:51:26 <ivanm> sorear: oh, was that you for the "prelude is evil" post in haskell-cafe?
21:51:29 <sorear> IO in the type system is harder.
21:51:40 <sorear> ivanm: yes.  S. O'Rear
21:51:43 <ddarius> The I part is.
21:51:54 <ivanm> sorear: didn't actually see who posted it, just knew there was a post
21:51:59 <ivanm> interesting,  though
21:52:13 <ivanm> @google type-level arithmetic
21:52:15 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg18251.html
21:52:16 <lambdabot> Title: [Haskell] Re: Type-Level arithmetic library
21:52:32 <monochrom> But like I say, Learning is Unlearning.  You have to unlearn value-level arithmetic that you've taken for granted for these 20 years, go back to 3-yo, then re-learn arithmetic, this time at the type level.
21:52:46 <ivanm> lol
21:52:52 <ddarius> It's entertaining that Haskell is the hit you get for that.
21:52:55 <ivanm> is it at all related to church numerals?
21:52:58 <monochrom> If you have been using value-level arithmetic for N years, it'll take you O(N) time to unlearn it.
21:53:16 <ivanm> heh... I'm studying maths, so I don't know what numbers are ;-)
21:53:41 <Cale> type level arithmetic is basically the same as value level arithmetic
21:53:59 <ddarius> It's exactly the same as value level arithmetic.
21:54:14 <ivanm> just using types instead of numbers?
21:54:16 <Cale> It's just that you have type constructors instead of data constructors.
21:54:33 <monochrom> I'd call it isomorphic not equivalent.
21:54:52 <Cale> and typeclasses with functional dependencies instead of functions
21:54:55 <ddarius> Well, not necessarily exactly equivalent to value level arithmetic in Haskell.
21:56:00 <monochrom> Oleg has done this to ad nauseum.  Just try to find his articles on this.  May save you a few years of unlearning.
21:56:35 <lucca> bleh.  peano numbers succ
21:57:07 <sorear> @google type binary oleg march
21:57:11 <lambdabot> http://sequence.complete.org/hwn/20070312
21:57:11 <lambdabot> Title: Haskell Weekly News: March 12, 2007 | The Haskell Sequence
21:57:23 <sorear> @google type binary natural kinds oleg march
21:57:23 <ddarius> lucca: They do, but you aren't limited to them.
21:57:26 <lambdabot> http://www.opensubscriber.com/message/haskell@haskell.org/6228946.html
21:57:26 <lambdabot> Title: [Haskell] ANN: binary arithmetic type library over natural kinds
21:58:25 <ivanm> peano numbers look like what I was told Church numerals are... :s
21:58:26 <monochrom> Doesn't have to be peano numbers.
21:59:07 <ivanm> @google "peano numbers" "church numerals"
21:59:09 <lambdabot> http://orcmid.com/com.orcmid/LLC/pa/pn/J040601a.htm
21:59:09 <lambdabot> Title: J040601a: Peano Numerals Project Diary
21:59:29 <stepcut> hrm, synchronous concurrency -- that sounds like what I am trying to do :-/
21:59:57 <ddarius> That's because they are isomorphic.
21:59:58 <monochrom> Anyway, I believe in reading articles in solitude written by great minds, rather than expressing in public your feelings and speculations.
22:00:48 <ivanm> ddarius: what's the difference between them...
22:00:52 <ivanm> s/.../?
22:01:24 <ddarius> ivanm: Any data type can be Church-encoded.  Church numerals are just the encoding of Peano numbers.
22:01:40 <ivanm> ahhh.... Church numerals are the generalised form of Peano numbers?
22:01:46 <dons> what is it with haskell and unicycles!? http://www.cs.chalmers.se/~nad/
22:01:49 <ddarius> No.  They are isomorphic.
22:02:31 <ivanm> dons: its not just haskell... I know a couple of physics people who are in amateur circuses, etc and ride unicycles and what not...
22:02:46 <dons> yeah, physics and circuses I get.
22:02:48 <Cale> kpreid: let me know what you think of that, eh?
22:02:53 <monochrom> I don't think it's rampant yet, dons.  But do let me know what SPJ is also infected. :)
22:03:08 <monochrom> s/what/when/
22:03:29 <Cale> dons: you've done lots of concurrent stuff -- do you suppose that http://www.rosettacode.org/wiki/Synchronous_Concurrency#Haskell is clean/clear enough?
22:03:30 <lambdabot> Title: Synchronous Concurrency - Rosetta Code
22:03:50 <dons> looking...
22:04:49 <dons> Cale: hmm, could you use a Chan instead?
22:05:00 <dons> and just write all lines into the chan, and have the reader pull them out lazily
22:05:03 <ivanm> "Church numerals are a model of the Peano axioms derived using the lambda calculus."
22:05:16 <Cale> Well, it's supposed to be synchronous thread communication.
22:05:19 <ivanm> so Church numerals are more of a computer based approach, rather than maths based?
22:05:21 <dons> any time you put lists into an MVar elementwise, you're reimplmeenting Chan
22:05:31 <Cale> yeah, I thought that too.
22:05:45 <dons> ah ok. synchronous hmm.
22:06:09 <dons> loop n looks like forM_ ?
22:06:22 <dons> ah no.
22:06:36 <Cale> I suppose sort of. We could use an MVar/IORef for the count.
22:06:53 <ivanm> ddarius: so Church numerals are more of a computer based approach, rather than maths based?
22:07:01 <Cale> Can't use the countVar though, because filling it is meaningful.
22:07:13 <Cale> er, hmm.
22:07:16 <Cale> yeah
22:07:44 <Cale> We don't want the reader to potentially get the old count.
22:07:46 <ddarius> ivanm: The lambda calculus is a mathematical object.  It was made in the 30's, i.e. before computers.
22:08:03 <ivanm> OK, s/computer/computational
22:08:08 <ivanm> that better? ;-)
22:08:36 <Cale> ivanm: yeah, sort of :)
22:08:46 <ivanm> so in what way do they differ?
22:08:49 <ddarius> They are isomorphic to the Peano numbers.  They are just as computational/mathematical as they are.
22:09:00 <Cale> Church numerals are just Peano arithmetic implemented over the lambda calculus.
22:09:06 <ddarius> Church encoding just encodes the structure into functions.
22:11:04 * ivanm is getting confused with the term isomorphic
22:11:06 <stepcut> is there a way to do something like, map cpuIntensiveButPureFunction [1..10], and take advantage of SMP ?
22:11:11 <ivanm> I know it means they are equivalent...
22:11:33 <ivanm> ddarius: so Church numerals are functions, Peano numbers are base-less representations?
22:11:37 <Cale> I'd rather say that the Church numerals satisfy the Peano axioms.
22:11:49 <ivanm> so they're just an alternative representation?
22:12:09 <Cale> In some sense there is no one thing you can point at and say "Peano numbers"
22:12:12 <ddarius> ivanm: s/isomorphic/mathematically equivalent
22:12:26 <Cale> There are just models of the Peano axioms.
22:12:36 <sorear> stepcut: look at Control.Paralell.Strategies and take advantage of parMap
22:12:38 <Cale> The usual model in mathematics is taken from set theory.
22:12:40 <ivanm> yeah, that's what I thought... but how do they differ? what's the difference between them? notation?
22:12:47 <stepcut> sorear: spiffy
22:12:53 <ivanm> Cale: k
22:13:14 <Cale> Well, the Peano axioms are a list of stuff which some system should satisfy in order to represent the natural numbers.
22:13:16 <ddarius> ivanm: As Cale says, it's just different representations of the same thing i.e. different ways of implementing the same interface.
22:13:38 <ivanm> so just a notational difference? k, that's what I thought
22:13:39 <stepcut> sorear: is there a paper that explains Control.Parallel ?
22:13:49 <Cale> Whereas the Church numerals are a particular model of the Peano axioms in terms of LC.
22:13:55 <sorear> @google Algorithm + Strategy = Parallelism
22:13:59 <lambdabot> http://www.macs.hw.ac.uk/~dsg/gph/papers/abstracts/strategies.html
22:14:00 <lambdabot> Title: Algorithm + Strategy = Parallelism
22:14:09 <ivanm> and the traditional definition of Peano numbers are in terms of sets?
22:14:11 <Cale> The set theoretic natural numbers are another implementation.
22:14:16 <dons> Cale: yeah, I'd use Chan, here:
22:14:17 <dons> ?paste
22:14:17 <stepcut> thanks
22:14:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:14:37 <Cale> Well, the traditional view when you say "Peano numbers" is not to choose an implementation.
22:14:41 <hpaste>  dons pasted "its just Chans" at http://hpaste.org/1114
22:15:05 <Cale> and just take it for granted that there's some notion of number satisfying all the axioms
22:15:07 <ivanm> so how would you define negative integers with Peano/Church?
22:15:13 <ivanm> or non-integers?
22:15:18 <Cale> As pairs of naturals.
22:15:30 <Cale> Or, perhaps equivalence classes of pairs of naturals :)
22:16:35 <ddarius> ivanm: There is more significance to it than just notation.
22:16:40 <ivanm> doesn't work for numbers like pi though...
22:16:46 <Cale> (a,b) + (c,d) = (a+c,b+d), (a,b) * (c,d) = (ac + bd, ad + bc)
22:16:50 <ivanm> ddarius: in what way?
22:16:59 <Cale> Then you define rationals in terms of integers.
22:17:05 <Cale> and then reals in terms of rationals
22:17:24 <ivanm> Cale: *nod*, then use one of the summated expressions for pi, e, etc?
22:17:32 <Cale> Yeah.
22:17:36 <ddarius> By modeling them in the lambda calculus, many aspects are revealed and they can be used with the rest of the lambda calculus.
22:17:50 * ivanm tries to remember if there's a formula describing root 2 in terms of rationals
22:17:55 <Cale> The reals don't embed into the lambda calculus though.
22:18:13 <Cale> Well, not in any obvious way.
22:18:30 <ivanm> ddarius: but how often are they used in programs? aren't church numerals too unwieldy to use for everyday calculations?
22:18:30 <Cale> Unless you go about representing proofs and such.
22:18:39 <ivanm> lol
22:18:41 <ddarius> Not all of them, no.  They don't embed in any computational system.
22:18:44 <Cale> There are uncountably many reals, and only countably many lambda terms.
22:19:08 <ivanm> the whole aleph_0 and aleph_1 values of infinity?
22:19:23 <Cale> yeah.
22:19:28 <ddarius> ivanm: Peano numbers are.  But actually, in some respect, Church numerals are not -that- uncommon.
22:19:51 <Cale> Or aleph_0 and c, depending on whether you accept the continuum hypothesis as an axiom.
22:19:56 <ivanm> k
22:20:02 <ivanm> brb
22:20:08 <ddarius> (expanding Peano numbers and thus Church numerals and any other representation)
22:20:48 <ddarius> Having Audacity handy is so useful.
22:21:10 <yshhq> @src inits
22:21:10 <lambdabot> inits []     =  [[]]
22:21:11 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
22:21:15 <Cale> I wonder what a second-order version of lambda calculus that would let you construct the reals would look like.
22:21:31 <yshhq> > inits [1..5]
22:21:33 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
22:21:49 <yshhq> @hoogle [a] -> [[a]]
22:21:50 <lambdabot> List.inits :: [a] -> [[a]]
22:21:50 <lambdabot> List.tails :: [a] -> [[a]]
22:21:50 <lambdabot> List.group :: Eq a => [a] -> [[a]]
22:22:06 <yshhq> @src group
22:22:06 <lambdabot> group = groupBy (==)
22:22:10 <yshhq> @src groupBy
22:22:15 <lambdabot> groupBy _  []       =  []
22:22:16 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
22:22:16 <lambdabot>     where (ys,zs) = span (eq x) xs
22:23:38 <ddarius> Cale: Depending on what you mean, something like Higher Order Type Theory
22:23:52 <ddarius> specifically (or I mean) Classical Type Theory
22:24:25 <ddarius> Alternatively, there are interesting ways of encoding a constructive (meaningful) subset of the reals.
22:24:58 <ddarius> Cale: It's not necessarily the lambda calculus that is lacking, just it's primitives.
22:26:29 <sorear> Why do I care if I don't have "all" the reals?
22:26:42 <sorear> The set I have is closed in almost every imaginable way.
22:26:58 * sorear wonders what math would look like stripped of uncountable sets
22:28:07 <dmead> same thing without the "..."'s?
22:28:09 <ddarius> sorear: Like constructive math.
22:28:15 <Cale> Uh, the constructive reals aren't complete.
22:28:33 <sorear> Complete in what definable sense?
22:28:48 <Cale> In the sense that they satisfy the least upper bound property.
22:28:55 <sorear> Every computable cauchy sequence I'm sure has a limit.
22:29:05 <Cale> Any nonempty set of reals that is bounded above has a least upper bound.
22:29:08 <sorear> Least upper bound of a computable set of reals?
22:29:21 <Cale> Yeah, it might not be computable.
22:29:36 <sorear> even if the set of reals is itself computable?
22:29:37 <Cale> Oh, of a computable set?
22:29:48 <Cale> Well, possibly, but that's quite different.
22:30:02 <sorear> I'll accept that discarding just uncomputable reals will break the system.
22:30:17 <sorear> I'm wondering about discarding uncomputable everything.
22:30:35 <ddarius> Constructive mathematics.
22:30:46 <ddarius> Well, a bit stronger than that, but...
22:31:18 <sorear> Somehow I thought constructive was just a synonym for intuitionistic.
22:31:26 <Cale> I take it you're also giving up the axiom of choice?
22:31:35 <ddarius> sorear: Intuitionistic => Constructive
22:32:05 <ddarius> Cale: For "smaller" Set theories, Choice is quite reasonable.
22:32:06 <sorear> is that a class => or an instance => ?
22:32:14 <ddarius> A math one.
22:32:35 <Cale> I suppose you'd take countable choice.
22:32:50 <ddarius> Cale: I understand why many mathematicians are somewhat hesitant about the Axiom of Choice in ZF.
22:33:11 <Cale> Well, actually that's like 0.01% of all mathematicians who are hesitant :)
22:33:20 <merus> many?
22:33:22 <sorear> I define "reasonable" as "when added to Sys-F does not induce a proof of \/a. a"
22:33:28 <ddarius> Cale: Most of them still note it.
22:33:43 <Cale> Yeah, it's interesting to see how much of mathematics can be done without it.
22:33:55 <Cale> I'd be way more hesitant to throw it away though.
22:34:05 <merus> I would be sad in a world without AC :(
22:34:15 <merus> No ultraproducts
22:34:17 <Cale> I really like my Cartesian products of nonempty sets to be nonempty.
22:35:08 <Cale> If I was going to throw it away, it'd probably be to take something like AD.
22:35:26 <sorear> AD?
22:35:31 <Cale> Axiom of Determinacy
22:35:45 <sorear> @google Axiom of Determinacy
22:35:46 <lambdabot> http://en.wikipedia.org/wiki/Axiom_of_determinacy
22:36:40 <Cale> It's sort of a confusing axiom, but has nice consequences.
22:37:02 <Cale> In particular, that every set of real numbers is Lebesgue measurable and has the Baire property.
22:37:11 <Cale> Sort of trivialises measure theory. :)
23:28:57 <siti> hmm ghc panic
23:48:42 <dcoutts> @localtime dcoutts_
23:48:43 <lambdabot> Local time for dcoutts_ is Sat Mar 24 06:47:04
23:48:47 <dcoutts> bah
23:53:18 <dons> hey dcoutts
23:53:25 <dcoutts> hia :-)
23:53:34 <dons> do we have a fork of smallcheck somewhere?
23:53:37 <dcoutts> dons: I might move to Lewisham
23:53:41 <dcoutts> yeah we do
23:53:48 <dons> i put the darcs versions of smallcheck and chasingbottoms into our streams/
23:53:55 <dcoutts> it's in the repo no?
23:53:56 <dons> but i don't seem to have the hier-lib smallcheck
23:53:59 <dcoutts> I think I comitted it
23:54:01 <dcoutts> hmm
23:54:04 <dons> hmm
23:55:05 <dcoutts> hrm, how do I log into my office box I wonder
23:55:10 <dcoutts> can't get a dns name
23:55:51 <dons> --> #maya
