00:03:26 <Vq^> fuzan: #gentoo-haskell isn't that quiet
00:04:49 <bos> wow, trac on haskell.org is slower than molasses.
00:25:04 <sorear> night.
00:31:31 <fuzan> how do sdl/gtk differ performance wise in an opengl-driven application?
00:49:13 <narain> how do you tell -0 from 0 in IEEE floats?
00:49:15 <narain> > -0
00:49:16 <lambdabot>  0
00:49:21 <narain> > -0 :: Double
00:49:23 <lambdabot>  -0.0
00:49:34 <narain> > (-0 :: Double) < 0
00:49:36 <lambdabot>  False
00:50:27 <lekro> > isNegativeZero (-0 :: Double)
00:50:29 <lambdabot>  True
00:50:43 <narain> ah, they had to special-case it
00:50:57 <narain> thanks lekro
00:51:49 <fuzan> @src isNegativeZero
00:51:50 <lambdabot> Source not found. That's something I cannot allow to happen.
00:52:09 <fuzan> @src read
00:52:09 <lambdabot> read s = either error id (readEither s)
00:52:41 <sjanssen> dons: turns out that dwm's layout mechanism is significantly more complicated than I realized :(
00:55:04 <narain> :t mapM
00:55:06 <lambdabot>     Ambiguous occurrence `mapM'
00:55:06 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
00:55:13 <narain> :t Prelude.mapM
00:55:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:20:54 <fuzan> i just figured out why people like to put list seperation commas on the leftside of the variable when they're multiline.
01:21:00 <fuzan> yay!
01:37:40 <sjanssen> does anybody know a good data structure for a unique sequence?
01:38:40 <sjanssen> something like Data.Sequence, with the invariant that each element appears no more than once
01:38:52 <ivanm> sjanssen: ordered?
01:38:57 <sjanssen> ivanm: yes
01:39:23 <ivanm> possibly some kind of binary tree, where you set it up such that, upon insertion, if it finds that value it fails?
01:39:56 <sjanssen> ivanm: oh, I mean in order of insertion
01:40:28 <ivanm> so, arbitrary objects, presumably insubstantiating Eq?
01:40:34 <sjanssen> it should behave like a stack, except when you push an item that is already in the stack, the old entry is deleted/invalidated
01:40:35 <ivanm> but not neccessarily Ord?
01:40:40 <sjanssen> Ord is fine
01:41:09 <ivanm> but you definitely want LIFO behaviour?
01:41:24 <sjanssen> yes
01:41:38 <ivanm> then, AFAIK, you're left with a stack :(
01:41:57 <ivanm> unless you have a heap or something, with some kind of key for insertion order...
01:42:03 <sjanssen> yeah, I can't figure out a way to do it in better than linear time
01:42:14 <ivanm> duh, priority queues
01:42:16 <sjanssen> ivanm: yes, a virtual "timestamp" is a possibility
01:42:29 <ivanm> then a heap might do...
01:42:39 * ivanm tries to remember the time complexity of heaps
01:43:08 <sjanssen> logarithmic or better, generally
01:43:12 <ivanm> let me dig out my lecture notes from last semester
01:46:16 <sjanssen> so I just need a max priority queue with an increase key operation
01:47:24 <ivanm> yeah, I think so
01:47:38 <ivanm> IIRC, heaps are logarithmic for insertion/deletion
01:47:43 <sjanssen> and I have to keep track of that pesky timestamp
01:47:44 <ivanm> at least for OO languages
01:48:04 <ivanm> sjanssen: have a (heap, previous_timestamp) tuple?
01:48:19 <sjanssen> ivanm: I'll use Data.Map as a standin for a priority queue
01:48:35 <ivanm> sjanssen: or you could do that
01:48:47 <ivanm> I'm not too familiar with Haskell's inbuilt data structures
01:53:06 <triplah_> N log n for heap?
01:54:11 <triplah_> nope, just logN
01:54:57 <sjanssen> depends on the operation and the data structure
01:55:11 <triplah_> right, i thought the discussion was on insert
01:56:30 <triplah_> are haskell lists implemented as C array vectors ?
01:56:41 <sjanssen> no, they're singly linked lists
01:56:56 <triplah_> ah ok
01:57:41 <triplah_> they must be optimised then
01:57:48 <ivanm> so laziness is nice because it saves you jumping around from list element to list element?
01:58:15 <triplah_> ?
01:58:18 <sjanssen> ivanm: laziness is nice because it lets you treat lists like streams/loops
01:58:21 <revence> Which module contains unsafePerformIO? Can't seem to find it.
01:58:30 <sjanssen> @hoogle unsafePerformIO
01:58:31 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
01:58:31 <revence> :t unsafePerformIO
01:58:33 <lambdabot> Not in scope: `unsafePerformIO'
01:58:43 <sjanssen> revence: it's also in System.IO.Unsafe (I think)
01:58:48 <revence> :t Foreign.unsafePerformIO
01:58:51 <lambdabot> forall a. IO a -> a
01:58:51 <ivanm> :t Foreign.unsafePerformIO
01:58:51 <augustss_> sjanssen: I thought Data.sequence could be used as a priority queue as well
01:58:54 <lambdabot> forall a. IO a -> a
01:58:59 <ivanm> revence: ^^
01:59:04 <revence> Thanks a fat bunch, bredren.
01:59:09 <revence> Gone, now.
01:59:22 <sjanssen> augustss_: the underlying FingerTree structure can, but it's not exposed
01:59:32 <augustss_> oh, darn!
01:59:52 <sjanssen> augustss_: Data.Sequence is a hand specialized version, with all the overloaded magic removed
02:00:39 <augustss_> sjanssen: we should have a version that allows PQ operations as well
02:00:47 <sjanssen> augustss_: did you see my problem above?  I need a LIFO with unique elements
02:01:18 <sjanssen> and when a duplicated element is pushed, I want the old one to disappear
02:01:25 <augustss_> hmmm
02:02:01 <augustss_> I've implemented something like that in hardware :)
02:02:48 <augustss_> sjanssen: are the elements in Ord?
02:02:51 <sjanssen> it isn't hard to do in a mutable setting, you just use a mutable linked list
02:03:14 <sjanssen> augustss_: yeah, an Ord constraint is fine
02:03:18 <augustss_> sjanssen: it's not hard at all, unles you want fast operations
02:03:35 <sjanssen> right, I'd like better than O(n)
02:04:36 <augustss_> O(log N) ok?
02:05:23 <sjanssen> augustss_: sure
02:07:33 <augustss_> sjanssen: so you could keep two data structures, a stack where you just push and pop, but when when you push you tag the element with a unique number.  And then a set (map maybe) telling which elements should be in the stack.  So on a push you change the tags in the set, and on a pop you check if it's still there.
02:10:38 <sjanssen> I think this structure will eat too much memory for my application
02:10:58 <sjanssen> I don't plan to pop to the end of the stack very often
02:11:39 <sjanssen> augustss_: the alternative is a max priority search queue with a "timestamp"
02:12:53 <augustss_> well, if removing elements is important then mine is clearly not an option
02:13:12 <augustss_> watch out for laziness if you want elements removed
02:14:55 <hpaste>  sjanssen pasted "UniqueSequence" at http://hpaste.org/903
02:17:00 <ivanm> sjanssen: what's the performance with that like?
02:17:26 <sjanssen> ivanm: log n for both operations
02:17:53 <sjanssen> in practice it will be fine.  The timestamp bothers me, though
02:17:55 <augustss_> sjanssen: that's gonna leak memory
02:18:00 <ivanm> what's the us@ notation do, as in us@(US t m n)?
02:18:10 <sjanssen> augustss_: think I need strictness on the maps?
02:18:49 <augustss_> if you want the delete to happen you need to force it to happen.  I don't know how to do that with Data.Map
02:19:01 <augustss_> Maybe it already does?
02:19:06 <augustss_> then it's ok
02:19:20 <sjanssen> maps are spine strict
02:19:45 <ivanm> sjanssen: what's the us@ notation do, as in us@(US t m n)?
02:20:18 <augustss_> you might need ! on those maps in US.  I don't think UNPACK will do the trick
02:21:38 <sjanssen> ivanm: it's an "as" pattern.  It binds the entire structure to us, and then the individual components to t, m, and n
02:21:41 <augustss_> ivanm: x@(Blah a b c) means that you pattern match as with (Blah a b c), but you also have a name, x, for the whole thing.
02:21:55 <ivanm> ahh, OK, thanks
02:22:51 <augustss_> sjanssen: if you plan on many elements you might wrap around the Int
02:23:07 <sjanssen> augustss_: this is what bothers me about the Int
02:23:20 <augustss_> There's Integer
02:23:28 <sjanssen> but if I use Integer, then I use an unbounded amount of memory!
02:24:01 <sjanssen> (technically unbounded, it's not like I'll ever count high enough for it to be a real issue)
02:24:06 <augustss_> yeah, but not in practise.  the log will help
02:24:42 <sjanssen> I suppose if someone leaves this window manager running for billions of years they might run out of memory
02:26:32 <ivanm> lol
02:29:51 <augustss_> sjanssen: if you add new items at 10GHz it will take 58 years to reach 128 bit numbers
02:30:03 <augustss_> sorry, 64 bit
02:30:04 <mattam> this would be so much nicer with Finger Trees why not use http://www.soi.city.ac.uk/~ross/software/Data/FingerTree.hs ?
02:30:22 <augustss_> sjanssen: Word64 would work too
02:30:25 <vincenz> augustss_: ooh, are you saying "we'll never need more than 64 bit? :)
02:30:46 <augustss_> yep.  We will never need more than 64 bits ;)
02:31:26 <sjanssen> augustss_: yes, we'll probably see the end of the universe before we run out of memory incrementing a couple Integers
02:31:38 <araujo> what if we meet an alien race that needs characters of 256 bits ?
02:31:54 <vincenz> araujo: they'll probably use trits, not bits
02:32:05 <augustss_> araujo: then we'll teach them about compression
02:32:14 <araujo> vincenz, it's for us
02:32:27 <vincenz> araujo: move them to eu then
02:32:35 <araujo> whatever they use, translate to us in 256bits
02:33:03 <vincenz> > 52 * 3
02:33:04 <lambdabot>  156
02:33:08 <vincenz> hmm
02:33:14 <vincenz> we'll never ned more than 157 bits
02:33:23 <araujo> ha
02:33:33 <vincenz> wait, damn, sorry, 52 is the card possibilities
02:33:46 <vincenz> no, that's 80, 10^52 = #atoms
02:33:56 <vincenz> iirc
02:34:30 <vincenz> oh, no, it's 10^80th after all, so yeah, 240 bits, round up to 256 :)
02:35:01 <araujo> :-)
02:35:15 <vincenz> o.O
02:35:17 <vincenz> > (log (10^80)) / log 2
02:35:19 <lambdabot>  265.754247590989
02:35:30 <vincenz> > ((log (10^80)) / log 2)/ 80
02:35:31 <lambdabot>  3.3219280948873626
02:35:35 <vincenz> damn you rounding
02:35:52 <augustss_> > round pi
02:35:54 <lambdabot>  3
02:36:10 <augustss_> > square cake
02:36:10 <lambdabot>   Not in scope: `cake'
02:37:38 <matt__r> kosmikus: here now
02:53:53 <isieo> hi, how do you cast an IO String to a [Char] ?
02:55:05 <xerox> say |foo :: IO String| is your value, then in a do block like |do { xs <- foo; ... }|, in the "..." you have in scope |xs :: String|.
02:55:10 <ski> http://www.haskell.org/hawiki/ThatAnnoyingIoType
02:55:11 <lambdabot> Title: ThatAnnoyingIoType - The Haskell Wiki
02:55:24 <isieo> oh thanks
02:55:44 <ski> (isieo : see that link)
02:55:52 <isieo> yea looking at it
02:55:55 <ski> hi xerox
02:56:18 <xerox> you're welcome
02:56:20 <xerox> hiya ski
02:57:40 <ski> i read an interesting paper yesteryesterday
02:58:24 <ski> "Computational comonads and intensional semantics", Stephen Brookes and Shai Geva
02:59:28 <ski> about using comonads for reasoning about algorithmic behaviours of implementations of functions (in a lazy / on-demand evaluated language)
03:00:16 <ski> an algorithm from 'a' to 'b' was represented as a function from 'W a' to 'b' (where 'W' is the computational comonad)
03:01:12 <ski> they had some extra features, like the comonad should be "computational" meant that you basically had a function "return :: a -> W a"
03:01:30 <ski> (with some laws for coherence of this and the comonad operations)
03:02:23 <ski> so, if you had an algorithm from 'a' to 'b', i.e. a function of type 'W a -> b', you can extract the function part of that, by composing with 'return' so you get a function of type 'a -> b'
03:03:06 <ski> using this, algorithms (of the same type) was collected into equivalence classes of algorithms that compute the same function
03:04:29 <ski> (one could also go in the other direction .. given a function from 'a' to 'b', one could get an algorithm from 'a' to 'b' (i.e. a function from 'W a' to 'b') by composing with 'extract :: W a -> a')
03:06:40 <cragwolf> I'm writing a function that determines if all the numbers in a list have the same sign
03:06:46 <cragwolf> My lame effort so far: sameSigns xs = let ys = map (<0) xs in all (== head ys) ys
03:07:16 <cragwolf> probably there's a more elegant way?
03:07:50 <ski> they showed that this finer / lower-level distinction on function implementations respected the declarative interpretation which only considered functions, in the sense that the composition of two algorithms gives an algorithm that represents the same function as if you instead compose two algorithms that, respectively, lie in the same equivalence classes as the two first ones
03:07:51 <ulfdoz> fold (<0) ls
03:07:56 <ulfdoz> cragwolf: see above
03:08:12 <ulfdoz> ehm, no, stupid. ;)
03:08:27 <ulfdoz> Theres at least an boolean and missing
03:08:33 <alcojol> List.all (<0) youtlist
03:09:33 <ski> cragwolf : what if some numbers are positive ans some are zero .. what should the answer be ?
03:09:50 <cragwolf> ski: treat 0 as positive
03:10:09 <ski> ok .. i wondered if you wanted that or not ;)
03:10:18 <ski> augustss : btw, do you know where i can get lml ?
03:10:38 <augustss> it's part of hbc
03:10:58 <ski> augustss : it is included in the darcs distro you put up ?
03:11:35 <ski> (http://darcs.augustsson.net/Darcs/hbc)
03:11:39 <lambdabot> Title: Index of /Darcs/hbc
03:12:03 <ski> cragwolf : so you only want 'False' when there exists two numbers in the list, one positive, and one negative ?
03:12:14 <augustss> ski: yes
03:12:46 <cragwolf> ski: if all are positive, then True, if all are negative then True, otherwise False
03:13:16 <alcojol> a solution: List.all (<0) l || List.all (>=0) l
03:13:25 <ski> augustss : ty (dons put up one repository, and .. at least from what i could see .. lml was not present there .. but maybe i just looked in the wrong place ..)
03:13:59 <augustss> ski: it's exactly the same compiler, just different flags
03:14:15 <ski> not (any (< 0) xs && any (0 <) xs)
03:14:31 <ski> (er, that is basically the same as alcojol's one, of course)
03:14:38 <ski> augustss : ah, i didn't know this
03:14:51 <alcojol> perhaps you can optimize it evaluating in parallel with `par`
03:15:08 <cragwolf> ski: neat
03:15:52 <ski> hm
03:16:40 <ski> cragwolf : just to make sure .. you want it to give 'True' if all numbers are either negative or zero, yes ?
03:16:53 <ski> (in addition)
03:17:13 <malcolmw> ski: but you do need to have a binary lmlc installed already in order to build lmlc
03:17:49 <ski> malcolmw : oh, hm ..
03:18:07 <ski> augustss : .. can one cross-compile, then ?
03:18:18 <augustss> not easily
03:18:29 <ski> mhm
03:19:14 <ski> so .. what platforms does there currently exist binaries for atm, then ?
03:19:20 <cragwolf> ski: no. I see now that your algorithm returns true for [1,0,0] and [-1,0,0]
03:19:56 <ski> yes .. i assumed you wanted 'True' in the case i mentioned just above
03:19:58 <ski> so
03:20:12 <cragwolf> ski: I was looking at treating 0 as a positive number always
03:20:22 <ski> yes
03:20:48 <mr_tenor> where might I find a description of the syntax "class Add a b ab | a b -> ab, a ab -> b" ? (http://www.haskell.org/haskellwiki/Type_arithmetic) All the documents I'e read describing type classes use "where" and actual named functions of a type class that are actually specified by instances
03:20:49 <lambdabot> Title: Type arithmetic - HaskellWiki
03:21:23 <malcolmw> ski: binaries of hbc available here: http://www.cs.chalmers.se/pub/users/hallgren/Alfa/Haskell/
03:21:24 <lambdabot> Title: Index of /pub/users/hallgren/Alfa/Haskell
03:21:24 <ski> cragwolf : so use alcojol's solution, then, e.g.
03:22:43 <tarantoga> mr_tenor: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#functional-dependencies
03:22:45 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
03:22:58 <cragwolf> ski: yes, it's a nice one, damn font made me misunderstand it the first time
03:23:10 <cragwolf> thanks guys
03:23:20 <mr_tenor> "There should be more documentation, but there isn't (yet)" ;)
03:23:30 <mr_tenor> tarantoga: thanks!
03:26:11 <ski> (malcolmw : that appears to be the same as http://www.cs.chalmers.se/pub/haskell/chalmers/ which i already knew (i was wondering if there was any other/more .. in fact, i din't think directly of this one), but ty anyway)
03:26:12 <lambdabot> Title: Index of /pub/haskell/chalmers
03:27:12 <ski> cragwolf : one can probably make somewhat more efficient one, though (single instead of double traversal (barring deforestation))
03:30:39 <ski> one could be
03:30:44 <ski> sameSign [] = True
03:30:47 <dons> re.
03:30:52 <ski> sameSign xs = zipWith sameSign2 xs (tail xs)
03:30:53 <ski> sameSign2 x0 x1 = (0 <= x0) == (0 <= x1)
03:32:05 <alcojol> I have a problem, excuse me for my poor English, I don't like the show method for the data type Set (fromList [a,b,c,...]) I could change it without change de code of de module Set?
03:32:42 <ski> another could be
03:32:48 <ski> sameSign [    ] = True
03:32:50 <alcojol> Can I change it without change the code of the module Set?
03:32:55 <ski> sameSign (x0:xs) = all (\x -> zeroOrPos == (0 <= x)) xs
03:32:59 <ski>   where
03:33:01 <ski>   zeroOrPos = 0 <= x0
03:33:21 <ski> alcojol : no
03:33:32 <ski> but you can refrain from calling 'show' (in same cases)
03:33:44 <ski> or you can make a 'newtype' with your own 'Show' instance
03:34:09 <cragwolf> ski: thanks again
03:34:24 <alcojol> ski: the problem is that I can't see the definition of data type Set, then I must convert Set in a List and then define my show function over a list, it's more inefficient
03:34:25 <ski> newtype MySet a = MS (Set a) deriving ..all the old instances you want, except Show..
03:34:35 <ski> instance Show a => Show (MySet a)
03:34:36 <ski>   where
03:34:43 <alcojol> is it the only one solutioN?
03:34:46 <ski>   show (MS ..) = ...
03:35:01 <ski> alcojol : from what i know, yes
03:35:25 <alcojol> ok, thanks ski
03:37:12 <ski> (re the comonads above .. i was pondering if one could apply this to haskell .. to get a comonad "under" the normal evaluation, that could be used to reason about complexities etc in some way ..)
03:40:02 <Saizan> (what will it give us?)
03:41:21 <ski> i'm not sure .. maybe it could give one the possibility to check what thunks are evaluated, etc, hopefully without disturbing the reasoning on the function-level
03:42:51 <Saizan> and the optimization level
03:42:53 <ski> maybe the main use is only as a kind of denotational semantics, for reasoning about algorithmic behaviour of code .. and not, (as i was pondering) something to be used in actual code
03:43:48 <ski> well, of course we'd not want to hinder optimizations by introducing more discerning power (that's why i said "without disturbing the reasoning on the function-level")
03:46:30 <Saizan> it could be used to direct the optimization with additional information, maybe
03:46:41 <ski> hm .. this is possibly related to performing debugging effects in pure code .. the effects should not affect the pure code, and optimization of the pure code should not be hindered by the debugging side-effects (since we want to test what effects the optimizations have)
03:46:43 <Saizan> ?
03:46:55 <ski> mayhaps ..
03:47:50 <ski> (of course the debugging effects should be visible at some outer level .. e.g. in a nondeterminism monad that explains the possibly different results on different optimization levels)
03:49:54 <Saizan> anything that helps debugging will be much appreciated i think :)
03:50:29 <ski> maybe one way to represent pure code that could call out to impure debugging operations could be 'forall m. Monad m => (foo -> m ()) -> m a', where 'foo' is some type of things that are noted by the debugging machinery
03:50:33 <uccus> query irrelevant to current discussion (a.k.a. trolling) -- can I compose constructors to define a composed pattern in Haskell?
03:51:13 <fax> using | ?
03:51:15 <ski> if we instantiate 'm' to 'Identity' and pass is '\_ -> return ()' then we just get the pure part (so it doesn't depends on the impurity)
03:51:16 <Saizan> uccus: like foo ((x,y):xys) =?
03:51:45 <ski> but we could also instantiate 'm' to 'Writer foo' and pass in 'tell', e.g.
03:52:31 <ski> @type tell
03:52:33 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
03:52:38 <fax> @paste
03:52:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:52:54 <hpaste>  fax pasted "is this what you mean ski?" at http://hpaste.org/904
03:53:17 <uccus> Saizan: no, I want to *define* something like a pattern MyPattern = Either . (:) -- it gives me, for "abc", MyPattern x y means x = 'a', y = "bc", was that clear?
03:53:31 <fax> x = Add (Value 2.0) (Mul (Value 2.0) (Value 7.0))
03:53:32 <ski> but .. one bad point about this may be that the strictness of the monadic representation above hinders optimizations, even when the 'Identity' monad is used
03:54:16 <ski> maybe that could could be ameliorated by specializing the function for that monad then (and then possibly we'd like specializations for monads with effects, but that are still commutative)
03:54:30 <fax> :S
03:54:46 * fax said ski when he meant uccus .. sorry
03:54:56 <uccus> Saizan: so these composed patterns are somewhat like constructors (in that they can be pattern matched) but you can't construct anything with them (although construction makes sense)
03:55:00 <ski> uccus : you want 'Views' .. there's some paper(s) about this .. i think it was never implemented, though :/
03:55:27 <uccus> ski: why? not useful enough?
03:55:37 <Saizan> patterns are syntactic, right?
03:55:50 <uccus> yeah... [not sure what you mean]
03:56:03 <malcolmw> uccus: there was a long discussion recently on haskell-cafe about abstracting over pattern-matching
03:56:14 <ski> http://www.haskell.org/haskellwiki/Views
03:56:16 <lambdabot> Title: Views - HaskellWiki
03:56:23 <uccus> the PMC proposal? did it work out?
03:56:28 <ski> http://www.haskell.org/development/views.html
03:56:29 <lambdabot> Title: Views: An Extension to Haskell Pattern Matching
03:57:00 <uccus> I'm gonna read about views now thanks guys but before that I just wanted to know why they were not adopted...
03:57:08 <ski> uccus : there were semantic problems with the proposal, which weren't resolved
03:57:22 <uccus> http://www.haskell.org/haskellwiki/Views has nothing in it :s
03:57:23 <lambdabot> Title: Views - HaskellWiki
03:57:30 <ski> er
03:57:40 <ski> http://www.haskell.org/hawiki/Views
03:57:41 <lambdabot> Title: Views - The Haskell Wiki
03:57:41 <ski> i meant
03:58:04 <ski> (checked the other one as well, but noted it was nonexistant)
03:58:53 <uccus> ok, thankx
03:59:16 <uccus> whoa! precisely what I was talking about... [ashamed]
04:01:16 <ski> (also http://www.haskell.org/haskellwiki/Concrete_view and some comment on http://www.haskell.org/hawiki/HaskellTwo)
04:01:18 <lambdabot> Title: Concrete view - HaskellWiki
04:02:36 <ski> (btw, iirc, i think one way to possibly resolve the problem would be to allow views, but only to pattern-match on, not to construct with (OCaml has this, but iirc, for modularity reasons) .. however this is somewhat sad)
04:08:46 <revence> putStrLn $ (show 2) ++ (show 2)     -- Question coming up ...
04:09:35 <revence> Is it true that GHC will not run a func cal twice, if it has the same args, and will just use the first reply?
04:09:51 <revence> I know this should be obvious, since we are dealing with purity, but ...
04:10:09 <revence> You do start to worry, after a while.  :o)
04:10:44 <Igloo> I don't think that GHC will CSE that, but check the core if you want to be sure
04:10:49 <Igloo> Or just explicitly let-bind it
04:11:06 <Igloo> Like   let x = show 2 in putStrLn (x ++ x0
04:11:18 <dons> explicitly floating it out with a let or where is usually safer
04:11:40 <dons> GHC is pretty cautious with its CSE
04:14:32 <norpan> yeah, CSE can have bad memory impact
04:14:44 <revence> Yeah, I use let (actually, I use where, more, because it is sweeter), but I was wondering.
04:15:48 <norpan> you think where is sweeter?
04:15:50 <revence> But it should be the logical way to go. Only, you never know. Okay, thanks a lot, guys. And chics (Audrey Tang could be in here :o)
04:16:08 <revence> Yeah, where is sweeter, because ...
04:16:33 <revence> It can let me define the signature, so as to guide any next devs who may read the source.
04:16:47 <revence> Part of standards for corporate code, over here. My standards.
04:17:42 <norpan> well, you can tack on a type signature to any expression
04:18:23 <norpan> but where is sweet, and let is sweet too
04:18:28 <revence> Even in a let? Nope. Not in a let. Give it a kick, now.
04:18:59 <norpan> > let f = 1 :: Int in f
04:19:00 <lambdabot>  1
04:19:35 <revence> let triple x = x * x * x :: Int -> Int
04:19:47 <revence> I'm tryingit out ...
04:20:03 <norpan> well if you are defining functions and stuff you can go with where
04:20:10 <norpan> to each his own
04:21:04 <revence> Yeah. It is functions that get me to need to do that. To each his own.
04:21:31 <revence> Okay, see ya. I notice you hang around here a lot ... you are a hard-hacking Haskeller?
04:23:55 <norpan> hard-hacking i am not
04:24:08 <norpan> but i do get to use it at work
04:24:45 <norpan> part of our code is in haskell
04:24:50 <revence> You are lucky you don't have to stand stuff like PHP and Java. They are good, but Haskell is great. When it works.
04:24:52 <revence> :o)
04:24:55 <norpan> but mostly c++ :(
04:25:04 <norpan> c++ is the suck
04:25:16 <revence> Oh, C++. Damn.
04:25:32 <ivanm> norpan: which would you prefer, C++, C or assembly? ;-)
04:25:52 <norpan> well
04:26:01 <norpan> that's a trick question, right?
04:26:05 <ivanm> lol
04:26:08 <ivanm> yeah, kinda
04:26:13 <revence> When I start to think of C++, I code in Ruby. Simple as that. Frankly, it is no longer important to get buggy CPU cycles. I'd prefer this order: C, C++, Assembly. ;o)
04:26:31 * ivanm 's never used C++, just a little bit of Assembly and C for microcontroller programming
04:26:42 <revence> C rocks, because it is lean. Something of a super-model language with a bad temper.
04:26:50 <norpan> the problem with c++ is other people's code
04:26:56 <ivanm> lol
04:27:03 <norpan> they do stupid things
04:27:16 <araujo> morning
04:27:19 <ivanm> revence: OK, how about C++ vs Java vs C#?
04:27:24 <revence> C++ comes second, because I just can't go long distances in ASM. I use it to bootstrap stuff, work around stuff, et cetera. But never more than a function's worth in ASM.
04:27:28 <ivanm> araujo: evening
04:27:31 <ski> > let f :: Int -> Int; f x = x*x in f (f 3)
04:27:32 <lambdabot>  81
04:27:34 <araujo> hi ivanm
04:27:37 <norpan> c# is better
04:27:50 <norpan> java 5 is actually usable
04:28:07 <ivanm> araujo: even though we were talking on #gentoo-haskell only a few hours ago ;-)
04:28:14 * ski sometimes would like a 'where' in expressions .. for the ordering
04:28:15 <araujo> :-)
04:28:33 <ivanm> norpan: *nod* but I've never used C# either... assume its similar to Java
04:28:56 <revence> I love C#. Great crap. Better than Java. I run mint (the Mono .NET), and I run my C#. But Java feels more tried-and-true. And C++ is worse than them where I use them, but better where I use it. :o) Portable native-compiled OOP, that's where C++ comes in.
04:29:04 <norpan> we have java code too, and mixing java and c++ via JNI is a real pita
04:29:29 <ivanm> you mix it? why would you do that?
04:29:39 <norpan> because we have a lot of legacy code
04:29:43 <ivanm> lol
04:29:49 <ivanm> migrating from Java to C#?
04:29:53 <norpan> yes, slowly
04:30:02 <ivanm> was that C# or C++?
04:30:06 <norpan> the problem is that more java code is being written than is being migrated :)
04:30:14 <ivanm> LOL!!!
04:30:15 <revence> But, do you think the pure concept of Haskell can happen in a Java-style OOP setting? Or am I just not thinking radically?
04:30:27 <ivanm> isn't there an OHaskell project?
04:30:32 <ivanm> @google ohaskell
04:30:33 <lambdabot> http://www.cs.chalmers.se/~nordland/ohaskell/
04:30:34 <lambdabot> Title: O'Haskell
04:31:12 <revence> Don;'t migrate Java->C#. Not worth it. You end up the same spot, anyway. No, I have chekced OHaskell, and it is a dead project. I saw OCaml, and it is not Java-like.
04:31:26 <vincenz> revence: haskell is even less java like
04:31:37 <vincenz> revence: both ocaml and haskell are FPLs in contrast to OOPls
04:31:40 <norpan> no we're migrating java->c++
04:31:50 <norpan> don't ask me why
04:31:58 <ivanm> revence: I misread norpan's message
04:32:07 <revence> Yeah, Haskell is OOP, in fact. Even C is. (Yes, yes.) But I mean Java-like OOP. Funny, I dunno what I mean, exactly.
04:32:09 <ivanm> norpan: "Ours is not to question why, ..."?
04:32:18 <vincenz> revence: No, Haskell is FP,
04:32:25 <ivanm> Haskell is object oriented? how?
04:32:46 <revence> Yeah, FP, with enough of the OOP idioms. Inheritance, operator overload (plus invention) ...
04:32:52 <vincenz> revence: you overload on TYPES
04:32:54 <vincenz> revence: not on values
04:33:10 <vincenz> revence: it's more like operator overloading without virtual in c++
04:33:17 <vincenz> revence: which is purely type-based (though more adhoc)
04:33:19 <revence> It's not like it cannot be both pre FP and OOP. Ruby is OOP and FP.
04:33:26 <ivanm> revence: http://haskell.org/haskellwiki/O%27Haskell
04:33:27 <lambdabot> Title: O'Haskell - HaskellWiki
04:33:30 <vincenz> revence: Haskell is mainly FP
04:33:32 <ivanm> also mentions others
04:33:45 <ivanm> vincenz: I thought Haskell was fully FP?
04:33:48 <norpan> i find the discussion rather pointless
04:33:53 <ivanm> lol
04:34:00 <norpan> is haskell oop? no, yes, who cares? haskell is haskell
04:34:00 <vincenz> revence: you're reading words and mismatching them to concepts in OOP, not in FP.
04:34:04 <vincenz> ivanm: yes it is
04:34:26 <ivanm> <vincenz> revence: Haskell is mainly FP
04:34:29 <vincenz> revence: overloading and inheritance have a different meaning when you look at type classes vs classes in oopy languages
04:34:36 <ivanm> mainly does not imply fully...
04:34:41 <vincenz> ivanm: mainly ... fully... potay-toe potah-toe
04:34:46 <ivanm> lol, k
04:35:05 <vincenz> Besides, I like to avoid words like "always" and "never"
04:35:10 <vincenz> on a semantical level
04:35:12 <norpan> vincenz: always?
04:35:20 <ivanm> lol
04:35:22 <Eelis> i'm with norpan. also, no two programmers ever agree on what the hell OOP is
04:35:30 <norpan> all generalizations are wrong, remember that
04:35:41 <ivanm> revence: http://homepages.cwi.nl/~ralf/OOHaskell/
04:35:43 <lambdabot> Title: Haskell's overlooked object system
04:35:45 <revence> Well, I happened to match what was in Haskell to what I had learnt in C++, so I figured it was what I had. So, HAskell fills some gaps that OOP filled for me.
04:36:01 <vincenz> revence: You're going to have to do a lot of unlearning then
04:36:10 <vincenz> If you plan to learn haskel
04:36:14 <revence> "All genralisations are wrong - including this one" -- Mark Twain.
04:36:30 <vincenz> But I'm off, have to meet someone
04:36:33 <revence> I have been doing Haskell for long, already.
04:36:36 <ivanm> 97.6% of statistics are made up on the spot ;-)
04:36:50 <revence> Sure, there are subtle differences, but I take care of them gently.
04:36:50 <[vincenz]> ivanm: I bet that has a 0.1% confidence
04:36:55 <ivanm> lol
04:37:10 <norpan> the "including this one" part is redundant and makes the statement less powerful
04:37:45 <revence> norpan: Yeah, but that is where Mark Twain got his word-power from. Self-bashing, so to speak.
04:37:47 <Eelis> i went from C++ to Haskell. no unlearning necessary. obviously Haskell is radically different from C++, but "unlearning" ? i can now program in both, simple as that
04:37:59 <[vincenz]> Eelis: It varies from person to person
04:38:13 <[vincenz]> But you know what they say about the tea cup
04:38:27 <Eelis> what do they say about the tea cup?
04:38:55 <[vincenz]> Have to empty it first before you can fill it again
04:39:10 <ivanm> [vincenz]: hurry up and go if you're going ;-)
04:39:28 <Eelis> hehe, oh my. that analogy is so cheesy and wrong it makes my nose hurt
04:39:31 <revence> They definitely couldn't have replaced `tea cup' with `beer mug'. :o)
04:40:02 <ivanm> or radioactive waste... wait, hang on, that doesn't work ;-)
04:40:11 <[vincenz]> Eelis: if someone is filled with preconceptions...they often are misconceptions
04:40:30 <qwr> Eelis: unlearning as its painful to write C++ in haskell?
04:40:53 <revence> There are only two rivers to cross, when coming from C++ to HAskel. Only two:
04:41:30 <revence> Understanding that looping doesn't have to be for(int not_i = 0; not_i < not_j; ++not_i);
04:41:33 <norpan> and one of them is styx?
04:41:59 <revence> And remembering to run actions, et al, rather than expecting their returns.
04:42:02 <norpan> (backwards)
04:42:18 <revence> The rest are just hills to climb. :o)
04:43:14 <qwr> revence: usual C++ code is all in IO. that is - data manipulations and talking with outside world is thoroughly mixed into one big mess
04:43:17 <[vincenz]> As I understood it, and perhaps I was misunderstanding revence.  He was trying to fit Haskell in an oopy model, having heard of inheritance and classes in the haskell context. And even though existentials do allow such dynamic dispatching, that would be a non-haskell way of coding.
04:43:37 <Eelis> i'll be the first one to say that someone learning Haskell must not assume that any C++ concepts learned can be applied directly in Haskell (on the contrary), but realizing this is not the same as "unlearning" C++. the notion that one can only be competent in one programming language at any given time is quite absurd to me
04:44:04 <[vincenz]> Eelis: You're overfitting my statement to a much larger claim
04:44:28 <[vincenz]> I never said he had to unlearn c++
04:44:55 <Eelis> you said the tea cup had to be emptied! :)
04:45:06 <[vincenz]> Eelis: yes, of some preconceptions
04:45:18 <[vincenz]> Eelis: you're reading things into my words which are not there :)
04:45:24 <revence> Vicenz said I'd have to unlearn what I'd learnt about Haskell, in relation to C++ (as in, like inheritance maps well from C++ to Haskell). But it is unnecessary. I do about 20 languages.
04:45:36 <[vincenz]> revence: well that I did not know :)
04:45:38 <Eelis> [vincenz]: alright, then we probably don't disagree anyway
04:45:46 <revence> They all have subtle differences, and Haskell is but one. I relate one's idioms in another.
04:47:36 <revence> The shift from calling .length in Ruby to calling len([]) in Python, or length(array) inPerl, then count(array) in PHP ... those are more-murderous differences than the ones between C++'s OOP model and the Haskell equivalents.
04:47:37 <[vincenz]> Eelis: yep, and in a sense we both made teh same mistake, communication wise, you towards me, me towrads revence.  We silently assumed what was not said instead of first validating what we had understood.
04:48:15 <Eelis> [vincenz]: perhaps so. oh well, i won't keep you any longer
04:48:31 <[vincenz]> revence: the different is that the class system shifts up one metalevel.  OOP: dispatching on values, typeclasses: dispatching on types
04:48:49 <[vincenz]> and yes, the [] around my nick should imply me gone
04:48:53 <[vincenz]> grr
04:49:30 <Eelis> what a nice, albeit arbitrary and unclear, convention
04:49:43 <revence> [vicenz]: Yeah. And that's easy to co-relate.
04:49:59 <[vincenz]> Eelis: well I made it clear to the people in the channel where I mostly idle :)
04:50:09 <Eelis> [vincenz]: fair enough
04:50:46 <[vincenz]> and now, by lazy evaluation, some people here know as well
04:50:51 <[vincenz]> Eelis: why aren't you in #haskell.dut
04:53:55 <revence> This
04:56:24 * QtPlatypus just thought it ment that there was a list of you.
05:01:23 <[vincenz]> > length [1]
05:01:25 <lambdabot>  1
05:01:36 * [vincenz] is not a type last time he checked ,he's a value
05:04:16 <Saizan> @quote free.man
05:04:16 <lambdabot> shapr says: Hey man, want to toke on a lambda? The first redex is free man!
05:15:18 <xerox> haha
05:23:37 * emk is building Cabal from Darcs to get cabal-install
05:31:14 <dancor> @hoogle [a -> a] -> a -> a
05:31:15 <lambdabot> No matches, try a more general search
05:31:59 <dancor> is there a fcn that takes a list of fcns and applies them in order to an initial element
05:32:06 <xtruppaw> hi all. just a small question. is there any place where I can submit links to articles that I have written about haskell? thanks! :)
05:32:30 <dancor> dlof [f, g, h] x = f $ g $ h x
05:33:56 <emk> Hmm. Hackage Crypto depends on NewBinary, which isn't in Hackage.
05:34:54 <dancor> > let {dlof [] x = x; dlof f:fs x = f $ dlof fs x} in dlof [(+ 2), (* 3)] 5
05:34:55 <lambdabot>  Parse error in pattern
05:35:02 <dancor> > let {dlof [] x = x; dlof (f:fs) x = f $ dlof fs x} in dlof [(+ 2), (* 3)] 5
05:35:04 <lambdabot>  17
05:35:09 <lekro> > foldl (flip ($)) 3 [(*2), (+1)]
05:35:10 <lambdabot>  7
05:36:02 <xtruppaw> test = (+) 1 2
05:36:11 <xtruppaw> (+) 1 2
05:36:16 <dancor> > (+) 1 2
05:36:18 <lambdabot>  3
05:36:29 <xtruppaw> ic ;)
05:36:48 <dancor> good old lb
05:37:45 <alcojol> uhm?
05:37:47 <alcojol> 2*3
05:38:01 <alcojol> > 2*3
05:38:03 <lambdabot>  6
05:38:12 <alcojol> > let a = 2
05:38:13 <lambdabot>  Parse error
05:38:20 <dancor> > let a = 2 in a
05:38:22 <lambdabot>  2
05:38:42 <alcojol> > let a = 3*a in a
05:38:43 <lambdabot>  Exception: <<loop>>
05:38:55 <alcojol> good programmed ;P
05:39:14 <dancor> lb has a built-in halting problem solver :)
05:39:27 <emk> Hackage is _so close_ to being super-useful; I can't wait until cabal-install ships with GHC.
05:40:16 <alcojol> > map (+ 1) [1..10]
05:40:17 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:40:18 <dancor> i just realized that hackage may be a nod to portage
05:40:28 <alcojol> > empty
05:41:26 <xtruppaw> > head []
05:41:27 <lambdabot>  Exception: Prelude.head: empty list
05:41:37 <alcojol> > Set.fromList [1,2]
05:41:38 <lambdabot>   Not in scope: `Set.fromList'
05:41:42 <emk> My exercise for the day: Write a program that plots del.icio.us bookmarks for a given URL as a function of time.
05:42:08 <emk> This requires a whole lot of interesting parts: HTTP, MD5, XML parsing, and an interface to gnuplot process.
05:42:27 <emk> It also requires dealing with RDF, which makes me very, very sad.
05:43:09 <dancor> emk: a w3c thing?
05:43:11 * emk does not believe in the semantic web, and dislikes the RDF serialization format intensely
05:43:39 <emk> dancor: Yup. Basically, it's format for representing graphs that represent statements about URLs.
05:44:57 <dancor> the grammar should be simple right, for those n-triple things
05:45:26 <emk> dancor: Yeah, but the file format is XML, and everything can represented at least three different ways.
05:45:50 <Nanar> Hi, I have a question about haskell module
05:46:05 <emk> So deserialization is more annoying that it should be, because you need namespaces and all sorts of special cases.
05:46:16 <emk> Nanar: Go ahead!
05:46:24 <Nanar> when a module foo need module bar, to I need to have foo installed to use bar ?
05:46:48 <Nanar> (I am trying to see how to solve dependencies to make rpm)
05:47:24 <emk> If foo imports bar, but not vice versa, you should be able to use bar without foo.
05:48:21 <Nanar> ok, so I can ignore cabal dependencies
05:48:35 <emk> dancor: And that's not even getting into the larger philosophical problem about treating the world as a graph of statements about URLs, which is basically just a rehash of failed ideas from 1980s-era AI.
05:48:51 <dancor> emk: hah, yes
05:49:15 <emk> Nanar: If you actually have Cabalized packages, you should probably make one RPM per Cabal package.
05:49:17 <Nanar> emk: but to use foo, I need bar
05:49:28 <emk> Nanar: Yup!
05:49:37 <Nanar> emk: the pb is not making one rpm per module
05:49:56 <Nanar> emk: my problem is to map dependencies into rpm dependencies
05:50:14 <resiak> In a list comprehension, I have [ foo | x<-xs , Just foo <- [f x]] .  Is there a more idiomatic way to do the Just pattern match than listifying a single element?
05:50:21 <Nanar> emk: aka haskell-missingh.rpm requires haskell-hslogger.rpm
05:50:35 <Nanar> emk: and having an automatic finder for that
05:50:59 <emk> dancor: So basically, I object to having to parse the gratuitously overcomplicated RDF-file format just because some over-excitable twits thought that RSS feeds would be better represented as syllogisms...
05:51:13 <Nanar> emk: cabal API don't really help to write a software for that
05:51:57 <dancor> emk: have you seen http://www.well.com/~doctorow/metacrap.htm
05:51:58 <lambdabot> Title: Metacrap
05:52:15 <emk> dancor: Oh, yeah.
05:52:22 <lekro> resiak: perhaps like this: map (fromJust . f) xs
05:52:31 <emk> Nanar: You might be interested in http://www.mail-archive.com/cabal-devel@haskell.org/msg00418.html
05:52:32 <lambdabot> Title: Added RPM generation capability to Cabal
05:52:54 <emk> Nanar: Newer versions of Cabal can apparently generate RPMs automatically, though I haven't tried it.
05:53:39 <resiak> lekro: hrm, yeah, I realise that my example was oversimplified from the true situation.  [ f x z | (x,y)<-xs, Just z<-[g y]] doesn't have such a straightforward function to map
05:54:14 <Nanar> emk: yes but this does not match with what distro does :\, moreover, it does not solve rpm interdepencies
05:54:45 <Nanar> emk: aka if I do rpm -UvH haksell-missingh, this will claim haskell-hslogger
05:54:48 <Nanar> emk: aka if I do rpm -UvH haksell-missingh, this will not claim haskell-hslogger
05:55:09 <Nanar> and register will failed
05:55:38 <emk> dancor: There's also the excellent http://www.shirky.com/writings/semantic_syllogism.html , which argues against syllogistic reasoning as a model for AI. Very nice piece.
05:55:39 <lambdabot> Title: Shirky: The Semantic Web, Syllogism, and Worldview
05:56:14 <emk> Nanar: Hmm. You're getting beyond my current level of RPM knowledge. I wish I could help you more.
05:56:35 <Nanar> emk: which distro/os re you using ?
05:56:37 <emk> Nanar: It might be worth talking to the cabal maintainers on Haskell-Cafe.
05:57:06 <Nanar> I think he is on cabal-devel ;)
05:57:34 <emk> Nanar: I haven't used RedHat much in the past 5 years, so my RPM skills are pretty rusty at this point.
05:58:15 <Nanar> emk: in fact it is to understand, rpm, like dpkg, have dependencies management, my problem is simply to map cabal dependencies into rpm one ;)
05:59:13 <ttmrichter> So....  Anybody interested in a haskell.org.cn domain for about $0.12?
05:59:25 <ttmrichter> For the first year, I mean.
05:59:28 <araujo> hah
05:59:41 <emk> Nanar: Yeah, I see what you're trying to do. It just seems like the cabal RPM support should do the right thing, and if it doesn't, that it might be worth fixing in general (since cabal already has full dependency info for use with cabal-install).
05:59:55 <Nanar> oh, and is there a way extract dependencies information from .hi files ?
06:00:39 <Saizan> ?ty second
06:00:42 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
06:00:42 <emk> Nanar: Well, *.cabal is a packaging format roughly equivalent to RPM, but only for Haskell packages.
06:00:49 <Nanar> emk: http://www.mail-archive.com/cabal-devel%40haskell.org/msg00436.html
06:00:51 <lambdabot> Title: Cabal and rpm packageing, http://tinyurl.com/274tsz
06:01:28 <dons> ?users
06:01:28 <lambdabot> Maximum users seen in #haskell: 339, currently: 300 (88.5%), active: 33 (11.0%)
06:01:31 <Saizan> resiak: [ f x z | (x,Just z)<- map (second g) xs] maybe?
06:01:32 <emk> The cabal package for foo should include a "foo.cabal" file, which contains all the information needed to generate a spec file.
06:01:55 <dons> nice article, http://programming.reddit.com/goto?id=198tb
06:01:59 <emk> dons: cabal-install is seriously sweet.
06:02:01 <lambdabot> Title: metasyntactic variable: Simple Socket Programming 2. Revenge of the chat.
06:02:06 <dons> emk, oh, it worked?
06:02:20 <dons> emk, last time I tried it I had some trouble. how's it now?
06:02:28 <Nanar> emk: yup, and I have a software to extract that, the issue is that file is not installed in DESTDIR
06:02:40 <emk> Well, except for a NewBinary dependency on the Crypto library that I had to handle manually.
06:02:49 <Nanar> emk: but I think I will copy it
06:03:09 <dons> ah ok. yes, newBinary is deprecated :-)
06:03:52 <emk> dons: Hackage is getting really close. I think that cabal-install should ideally be included in the next GHC release.
06:04:13 <dons> it must be, imo.
06:04:16 <resiak> Saizan: Yeah, it transpires that by reversing the argument order on one of my functions that looks very clean, thanks :-)
06:04:16 <emk> Well, NewBinary may be deprecated, but who's volunteering to rewrite Crypto? :-)
06:04:37 <dons> oh, I thought the maintainer was currently porting it to bytestrings + binary?
06:04:45 <emk> dons: Quite possibly.
06:04:48 <dons> at least, that's what he was working on a tthe hackathon.
06:05:01 <emk> dons: You're way more in the loop than I am.
06:05:27 <emk> But at the moment, the Crypto package is in hackage, but the NewBinary dependency isn't.
06:06:28 <dons> ah ok.
06:06:41 <dons> NewBinary has been cabalised though. we could upload it
06:06:59 <dons> you could ask the NewBinary maintainer to tag and release the current version
06:08:13 <emk> dons: Yup! Let me see if I can dig up an e-mail address.
06:17:52 <emk> dons: I sent the maintainer a nice note, and offered to do the upload myself if that was easier for him.
06:18:43 <dons> yep. great.
06:22:26 <dancor> in     f a b = case a of MyConstructor b -> ..    is this a new b
06:22:58 <dancor> or does the pattern matching actually match against b
06:25:19 <dancor> > let f a b = case a of b -> "no"; _
06:25:19 <lambdabot>  Parse error
06:25:34 <dancor> > let f a b = case a of {b -> "no"; _ -> "yes"} in f 3 4
06:25:35 <lambdabot>      Warning: Pattern match(es) are overlapped
06:25:35 <lambdabot>              In a case alterna...
06:26:00 <dancor> > let f a b = case a of {b -> "no"} in f 3 4
06:26:02 <lambdabot>  "no"
06:26:18 <dons> b is a new variable in its second use there.
06:26:19 <dancor> > let f a b = case a of {b' -> if b == b' then "ok" else "hm"} in f 3 4
06:26:20 <lambdabot>  "hm"
06:26:39 <dancor> ok
06:27:27 <dons> > let f a b | a == b = "ok" | otherwise "hm"' in f  3 4 -- ;)
06:27:27 <lambdabot>  Improperly terminated character constant
06:27:40 <dons> > let f a b | a == b = "ok" | otherwise "hm" in f  3 4 -- modulo typos
06:27:40 <lambdabot>  Parse error
06:27:47 <dons> ah too late for me.
06:28:00 <dancor> @time dons
06:28:02 <lambdabot> Local time for dons is Sun Mar 11 01:27:21 2007
06:28:10 <dons> > let f a b | a == b = "ok" | otherwise = "hm" in f  3 4 -- modulo typos
06:28:25 <dons> ?bot
06:28:25 <lambdabot> :)
06:28:25 <lambdabot>  "hm"
06:28:39 <dancor> ?bot!
06:28:39 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
06:28:43 <emk> ?hoogle String -> [Word8]
06:28:44 <lambdabot> No matches, try a more general search
06:29:00 <dons> all of haskell is just sugar for case/let/apply/lambda in the end
06:29:05 <dons> which is useful to know
06:29:28 <dons> :t Data.ByteString.unpack . Data.ByteString.Char8.pack
06:29:32 <lambdabot> String -> [Word8]
06:29:44 <dons> oh, 1.30am, nightly cronjob running on lambdaobt's box
06:29:58 <dancor> lambdabox
06:30:28 <emk> dons: Ah, that's useful to know. The crypto library works entirely in terms of [Word8] lists.
06:31:04 <dons> yeah. it probably should use lazy bytestrings. you could ping Dominic about the darcs repo version he was working for this stuff, actually
06:32:00 <roconnor> emk, my sha-2 implemenation sometimes uses [Word32] IIRC
06:32:00 <dons> mm. xmonad (our little window manager) is really rather nice.
06:32:21 <emk> dons: Yeah, that's probably a good idea.
06:32:35 <roconnor> I just join, so I missed what you were talking about, so maybe you should ignore me
06:32:48 * roconnor is still sleepy
06:32:52 <dons> no no, roconnor, always relevant :-)
06:32:52 <dancor> is there a uniquifier for lists
06:32:56 <dons> nub
06:33:05 <dancor> equiv to Set.toList . Set.fromList
06:33:06 <dons> > nub [1,2,1,2,3,4,1]
06:33:08 <lambdabot>  [1,2,3,4]
06:33:10 <dancor> ah
06:33:24 <dons> or go via Sets/ or sort a Map
06:34:08 <roconnor> > nub [1,2,1,2,4,3,1]
06:34:10 <lambdabot>  [1,2,4,3]
06:34:23 <roconnor> > (Set.toList . Set.fromList) [1,2,1,2,4,3,1]
06:34:24 <lambdabot>   Not in scope: `Set.fromList'
06:34:35 <roconnor> well, they are different
06:34:43 <dancor> :t toList
06:34:46 <lambdabot> Not in scope: `toList'
06:34:46 <roconnor> nub doesn't return a sorted list
06:34:49 <dancor> :t S.toList
06:34:52 <lambdabot> forall a. S.Set a -> [a]
06:35:05 <roconnor> > (S.toList . S.fromList) [1,2,1,2,4,3,1]
06:35:06 <lambdabot>   Not in scope: `S.fromList'
06:35:13 <dancor> !!
06:35:38 <dancor> :t fromList
06:35:41 <lambdabot> Not in scope: `fromList'
06:35:46 <dancor> it boggles the mind
06:35:58 <roconnor> dancor: what does?
06:36:27 <dancor> fromList's out-of-scope-ery
06:36:32 <dons> > Data.Set.fromList [1,2,1,2,4,3,1]
06:36:33 <lambdabot>  fromList [1,2,3,4]
06:36:44 <dons> > Data.Set.toList $ Data.Set.fromList [1,2,1,2,4,3,1]
06:36:44 <roconnor> fromList is defined in both Data.Map and Data.Set
06:36:45 <lambdabot>  [1,2,3,4]
06:37:06 <dons> sounds like we need a web page stating what's in scope and imported as what
06:37:26 <dancor> i'm just confused as to why S.toList is there.
06:37:42 <dons> ndm's cute article, http://programming.reddit.com/info/19a3u/comments
06:37:44 <lambdabot> Title: Describing Haskell (reddit.com)
06:41:29 <dons> i'm really happy about how this page is filling out, http://haskell.org/haskellwiki/Blog_articles
06:41:31 <lambdabot> Title: Blog articles - HaskellWiki
06:41:58 <dons> people should feel free to use it as inspirations to fill out the less covered libs/tools/techniques..
06:42:40 <dons> some stuff on `par` would be nice. the use of xml. more coverage of data structure design
06:43:24 <dons> hmm. xmonad would make a nice tutorial, actually. "Write your own window manager in 100 lines of code"
06:44:31 <emk> dons: Off the top of your head, do you know a way to format bytes as a hexadecimal string, as is typical with MD5 digests? (If there isn't a function in the standard library, I'm quite happy to write it myself.)
06:45:01 <dancor> i'm starting to think (a . b . c) d is cooler than a $ b $ c d
06:45:23 <emk> dancor: Oh, absolutely. Everybody likes a pipeline.
06:45:43 <dons> > showHex 255
06:45:45 <lambdabot>  <[Char] -> [Char]>
06:45:49 <dons> > showHex 255 []
06:45:50 <lambdabot>  "ff"
06:46:06 <dons> in Numeric. but otherwise, no.
06:46:12 <dancor> at first i just wanted no parens whereever possible
06:46:20 <dancor> counterlisp
06:46:28 <dons> how about:    a . b . c $ d
06:46:36 <dancor> oooh
06:47:03 <dons> here's my style:  f a;  f (g a);   f . g . h $ a
06:47:16 <dons> basically that's my rule. 3 or greater applys, use .
06:48:41 <dons> ah, a real example,
06:48:41 <emk> dons: I saw somebody who had a cute backwards-order apply operator (was that you?). It made point-free style look like pipes in a shell.
06:48:42 <dons> rotate o w = w { stacks = M.adjust rot (current w) (stacks w) }
06:48:42 <dons>     where rot s = take l . drop offset . cycle $ s
06:49:08 <Saizan> >>>?
06:49:14 <dons> nah, i'm not a big fan of |> and friends. too set in my ways I guess
06:50:02 <dons> a lot of people find the forward composition more intuitive thoug
06:50:08 <dons> i suppose it is.
06:51:08 <Saizan> mh, and where do you place the base argument? with the first function?
06:51:28 <dons> f a |> g |> h -- ?
06:51:30 <emk> dons: I like anything which allows me to read the code left-to-right without needing more than a 3-element stack. But I haven't yet dared to write all my code with |>.
06:51:43 <dons> i seem to recall hudak using >.> in his textbook
06:52:10 <roconnor> function application ought to be post-fix
06:53:44 <Saizan> with >.> i'll feel like the code is upset with me
06:55:23 <dons> > 1 :(         [])
06:55:24 <lambdabot>  [1]
06:55:42 <resiak> @quote monster
06:55:43 <lambdabot> dcoutts says: (:[]) looks like a monster
06:56:02 <dons> :t ((([]   :)  :) :)
06:56:04 <lambdabot> forall a. [[[[a]] -> [[a]]] -> [[[a]] -> [[a]]]] -> [[[[a]] -> [[a]]] -> [[[a]] -> [[a]]]]
06:56:20 <emk> I'm especially fond of the Ruby approach: foo.map {|x| x*x }.filter {|x| x.blah? }.each { ... }. It reads very nicely from left-to-right with no mental stack overflow and no backtracking. So I should probably just give in and use |> or something...
06:58:08 <dons> foo is the input?
06:58:25 <emk> dons: Yup. It's the same as |>.
06:58:49 <resiak> you could redefine x.f = f x !
06:58:55 <SamB> @quote eat
06:58:56 <lambdabot> robreim says: Great, now we've got to start an IRC channel for lojban-speaking, haskell-coding anarchists
06:59:01 <SamB> @quote eat a comment
06:59:01 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
06:59:06 <SamB> @quote eat\ a\ comment
06:59:06 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
06:59:07 <emk> It's sort of the OO equivalent of point-free style, where "." is the usual method lookup operator.
06:59:07 <pejo> emk, what is the x in there, if foo is the input?
06:59:12 <Saizan> map (\x -> x*x) foo |> filter (\x -> blah x) etc?
06:59:13 <SamB> @quote eat.a.comment
06:59:14 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
06:59:37 <emk> pejo: x is a lambda argument {|x| x*x } => (\x -> x*x)
06:59:56 * SamB really thinks @quote and @src should stop insulting the user
07:00:02 <dons> SamB: submit  patch
07:00:20 <dons> you've written more lines of complaints than it would take lines of code to fix.
07:00:27 <SamB> true
07:00:29 <SamB> however.
07:00:36 <SamB> I need more compilers to fix it!
07:00:37 <emk> Saizan: Or even "foo |> map (\x -> x*x) |> filter (\x -> blah x)"
07:01:07 <emk> Hmm. That's actually not half bad.
07:01:30 <SamB> though maybe this GHC HEAD would work...
07:02:00 <xerox> > (map (*) >>> filter ((`mod` 2) >>> (0==)) [1..10]
07:02:01 <lambdabot>  Parse error
07:02:07 <Saizan> uhm true, very similar to >>= also
07:02:19 <xerox> > (map (*) >>> filter ((`mod` 2) >>> (0==))) [1..10] -- sorry
07:02:20 <lambdabot>   add an instance declaration for (Integral (a -> a))
07:02:36 <xerox> well, is >>> what you're talking about?
07:02:47 <emk> ?type (>>>)
07:02:49 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
07:03:30 <Saizan> |> it's a bit diffrent, like a left associative reversed $
07:04:11 <Saizan> but >>> and . composes functions, instead $ and |> builds values
07:04:26 <Saizan> (wrong use of s)
07:05:17 <Saizan> and i think that composing function leads to more further composability :)
07:05:38 <Saizan> e.g. how do you write (f.) . g in terms of |>?
07:07:26 <emk> Well, Haskell won't let me write (|> f |> g), which takes some of the fun out of it.
07:12:10 <Saizan> heh
07:17:36 <emk> Hmm. Why do the examples in the Text.Printf.printf documentation raise "*** Exception: Prelude.undefined"?
07:17:42 <emk> > printf "%.2f\n" pi
07:17:43 <lambdabot>  Add a type signature
07:18:15 <emk> > Text.Printf.printf "%d\n" (23::Int)
07:18:16 <lambdabot>  Add a type signature
07:19:16 <emk> (Text.Printf.printf "%d\n" (23::Int)) :: String
07:19:31 <emk> > (Text.Printf.printf "%d\n" (23::Int)) :: String
07:19:32 <lambdabot>  "23\n"
07:20:25 <roconnor> @docs Network
07:20:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
07:25:02 <roconnor> @hoogle Handle -> IO String
07:25:03 <lambdabot> IO.hGetContents :: Handle -> IO String
07:25:04 <lambdabot> IO.hGetLine :: Handle -> IO String
07:25:04 <lambdabot> System.IO.hShow :: Handle -> IO String
07:25:22 <roconnor> @docs System.IO
07:25:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
07:27:17 <matthew-_> anyone know where that doc is that dons wrote about using Either?
07:27:26 <resiak> matthew-_: it's on planet.haskell.org atm
07:27:43 <matthew-_> many thanks
07:27:49 <roconnor> @hoogle bracket
07:27:49 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:27:49 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
07:27:49 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
07:29:23 <roconnor> @type hClose
07:29:25 <lambdabot> Not in scope: `hClose'
07:29:32 <roconnor> @type IO.hClose
07:29:34 <lambdabot> GHC.IOBase.Handle -> IO ()
07:30:16 <roconnor> So, (bracket (connectTo "example.com" 7001) hClose) is typical programming style?
07:32:07 <petekaz> ?seen dons
07:32:07 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 31m 47s ago.
07:33:12 <Pastorn> ?src (|>)
07:33:12 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:33:47 <Pastorn> what is |>?
07:33:58 <Saizan> > let x |> f = f x in 1 |> (+1) |> (*2)
07:33:59 <lambdabot>  4
07:34:23 <Saizan> > let x |> f = f x in [1..5] |> map (+1) |> filter even
07:34:25 <lambdabot>  [2,4,6]
07:34:44 <matthew-_> mmm. If I'm trying to sanitise some text, eg reject it if it contains eg ^.*?:// would haskellers use regexps or something else?
07:34:45 * Pastorn shouldn't have asked
07:35:11 <allbery_b> pastorn: normally, it's an operator on Seqs (Data.Sequence)
07:35:30 <Pastorn> Saizan, how do you pronounce "|>"?
07:35:57 <allbery_b> |> adds an item on the right of a sequence; <| adds on the left
07:36:02 <Saizan> don't know i've seen that today for the first time too, it's something like a pipe
07:36:32 <Pastorn> > let x |> f = f x in 1 |> (+1)
07:36:34 <lambdabot>  2
07:36:44 <Saizan> allbery_b: i think Pastorn is referring to the |> from the previous conversation
07:37:19 <Pastorn> does "|>"/"<|" have a name?
07:37:33 <allbery_b> oh, inverted (.)
07:37:36 <xs> matthew-_, any (`elem` "^.*?://")?
07:37:52 <Saizan> more like inverted $
07:38:15 <Saizan> but yes is to write function compositions from left to right
07:38:21 <Pastorn> so it in itself has no name...
07:38:45 <Saizan> it's not a standard operator
07:38:56 <matthew-_> xs: that's a regex, not a simple string
07:39:31 <xs> matthew-_, oops. sorry :)
07:39:34 <Pastorn> Saizan, still, when talking about it it would be better to call it something other than "pipelargerthan"
07:40:37 <xs> matthew-_, Network.URI then?
07:41:38 <matthew-_> no. it's a path, but I want to further restrict it
07:41:56 <Saizan> matthew-_: if the regex is readable i think is fine to use, if not use parsec
07:42:08 <matthew-_> it's the kind of thing I wouldn't think twice about in Perl, I just don't know if using regexps is "the haskell way"
07:42:47 <matthew-_> mmm. The Text.Regexp docs don't say if the regexp needs double escaping
07:42:56 <matthew-_> I reckon mkRegexWithOpts "^([[:alnum:]_-.]+/)*[[:alnum:]_-.]" False False is readable
07:43:15 <matthew-_> agh, need a $ at the end there...
07:44:55 <roconnor> @hoogle (m a) -> (a -> bool) -> [a]
07:44:56 <lambdabot> Did you mean: m a -> (a -> Bool) -> [a]
07:44:56 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
07:44:56 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
07:45:04 <roconnor> @hoogle (m a) -> (a -> Bool) -> [a]
07:45:05 <lambdabot> No matches, try a more general search
07:45:23 <roconnor> how do I repeat a monadic command until a predicate is satisfied?
07:45:49 <xs> @type until
07:45:51 <roconnor> @type whileM
07:45:52 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
07:45:54 <lambdabot> Not in scope: `whileM'
07:47:41 <roconnor> @docs Control.Monad
07:47:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
07:47:43 <sorear> hi.
07:48:08 <xs> matthew-_, i believe neil mitchell has written a module for dealing with file paths in a portable fashion.
07:48:16 <sorear> @where filepath
07:48:17 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
07:48:36 <sorear> and his name can be abbreviated to 'ndm' here :)
07:49:03 <roconnor> @type untilM
07:49:06 <lambdabot> Not in scope: `untilM'
07:49:09 <roconnor> @hoogle untilM
07:49:09 <lambdabot> No matches found
07:49:22 <matthew-_> xs: ahh, thanks. that could be useful
07:51:48 <xs> sorear, okiedokie. full names are usually better search discriminators.
07:52:07 <sorear> agreed on that :)
07:53:44 <Pastorn> @type choose
07:53:46 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
07:54:03 <Pastorn> Data.Random?
07:54:37 <sorear> @index choose
07:54:37 <lambdabot> Test.QuickCheck, Debug.QuickCheck
07:54:43 <Pastorn> oh
07:54:49 <Pastorn> thanks :)
07:55:27 * Pastorn is doing a stocastic L-System lab :D
07:58:15 <Pastorn> @type frequency
07:58:18 <lambdabot> forall a. [(Int, Gen a)] -> Gen a
08:01:36 <Pastorn> ?src Data.Map.map
08:01:37 <lambdabot> Source not found. Take a stress pill and think things over.
08:01:44 <Pastorn> @index map
08:01:44 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
08:02:00 <Pastorn> help?
08:02:03 <fasta> How can I only expert an instance from a module?
08:02:08 <fasta> export*
08:02:14 <sorear> ?source Data.Map
08:02:14 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
08:02:23 <sorear> fasta: module Foo() where
08:02:37 <Pastorn> all you want to export is inside ()
08:02:41 <sorear> fasta: all instances are always exported, that says to export nothing else
08:02:46 <Pastorn> types and functions
08:02:52 <fasta> sorear: ok
08:04:43 <pafcu> How do I convert an Int to a Float?
08:05:21 <pafcu> I want to multiply an Int with a Float, so I have to convert the Int to a Float first
08:05:36 <resiak> @hoogle Int -> Float
08:05:37 <lambdabot> No matches, try a more general search
08:05:40 <resiak> feh!
08:05:55 <sorear> fromIntegram
08:06:07 <sorear> > (fromIntegral (0::Int)) :: Float
08:06:09 <lambdabot>  0.0
08:06:32 <pafcu> sorear: Thanks. Just what I was looking for
08:07:35 <resiak> Hrm, I thought Hoogle could deal with the actual function having a more general type
08:07:53 <kc5tja> hmmm....
08:08:12 * kc5tja cannot find his old CUT-clone parser project in Haskell.  I wanted to hack on that today...
08:11:59 <hpaste>  petekaz pasted "Why does this say path does not exist?" at http://hpaste.org/905
08:12:13 <hpaste>  (anonymous) annotated "Why does this say path does not exist?" with "(no title)" at http://hpaste.org/905#a1
08:12:44 <petekaz> Could someone tell me why this simple program fails?  I annotated to show the error.
08:12:59 <petekaz> All I want to do is open a named pipe, write data to it, then remove it.
08:13:14 <RemiTurk> hi all
08:13:23 <petekaz> But appendFile says it does not exist.
08:13:41 <dcoutts> petekaz, can you openFile on it?
08:13:51 <petekaz> no.  I tried that as well.
08:14:04 <dcoutts> petekaz, I must admit posix named pipes are very confusing
08:14:26 <dcoutts> @hoogle   createNamedPipe
08:14:26 <lambdabot> No matches found
08:15:09 <petekaz> The goal is to create a "file" that is infinite in size so I can test the laziness of readFile in ByteString libraries.
08:15:34 <petekaz> The strange thing is that the pipe is created.
08:15:47 <kaol> /dev/zero is already infinite
08:16:02 <petekaz> I need it to look like a email message.
08:16:09 <petekaz> normal headers, infinite body.
08:16:31 <allbery_b> a fifo can only be opened for write if there is a reader; for read only if there is a writer.  which means you need to initially open it for read+write
08:16:47 <petekaz> that's not true.
08:16:53 <petekaz> mkfifo /tmp/pipe
08:17:02 <petekaz> yes | /tmp/pipe
08:17:05 <kaol> cat header /dev/zero
08:17:13 <petekaz> that will sit there blocking forever UNTIL someone reads from it.
08:17:16 <allbery_b> yeh
08:18:01 <allbery_b> I should have rephrased that:  the opens will block.  but on at least some OSes you can end up with permanent blocking because of stupidity.
08:18:15 <matthew-_> eek, does hs-plugins work with ghc 6.7?
08:18:37 <petekaz> I'll write the same code in python to see if it works, I see no reason why it should not.
08:19:07 <dcoutts> petekaz, see the mkfifo man page and see the notes about non-blocking operation
08:19:08 <allbery_b> the other issue if you open for read only is that when the writer closes, you get infinite EOF --- there is no way to block until another writer appears unless you open r+w
08:19:13 <allbery_b> but then you can'
08:19:16 <petekaz> kaol: I need it to look like a file in a Maildir directory as I have a tool that processes a whole directory, this the pipe.
08:19:20 <allbery_b> t detect that a riter wen away
08:19:30 <allbery_b> ffos are, inb general, a PITA
08:19:53 * allbery_b sighs
08:19:56 <dcoutts> petekaz, see man 7 fifo
08:20:00 <allbery_b> even harder to type around breakfast
08:20:30 <dcoutts> petekaz, "opening  for  write  only will fail with ENXIO (no such device or address) unless the other end has already been opened."
08:21:06 <dcoutts> petekaz, that is if you open in non-blocking mode, and ghc always uses non-blocking mode for all file handles always.
08:21:26 <petekaz> ahh ...
08:21:34 <petekaz> is there a way to do blocking mode in ghc?
08:21:40 <dcoutts> no
08:21:42 <petekaz> oh.
08:21:58 <dcoutts> not without bypassing the Handle stuff completely
08:22:05 <petekaz> ok ... I'll write my test in python then.  Thanks.
08:22:37 <dcoutts> petekaz, or use read+write mode, or open the thing for reading first
08:22:57 <dcoutts> petekaz, it also says: Under Linux, opening a FIFO for read and write  will  succeed  both  in blocking  and non-blocking mode.
08:23:06 <petekaz> good idea.
08:23:09 <petekaz> I'll test.
08:23:46 <dcoutts> petekaz, but when you try to write to the pipe when there's no reader you'll get sigpipe
08:24:29 <xs> gtk2hs appears to have two different TreeStore types (at least in the documentation.) can i use whichever i want?
08:24:31 <kc5tja> OK, I know I've asked this question before, but I cannot, for the life of me, remember the solution.
08:24:36 <kc5tja> Given the following input:
08:24:43 <kc5tja> module CutParse where
08:24:43 <kc5tja> main :: IO ()
08:24:43 <kc5tja> main = print "Hello world!"
08:24:44 <dcoutts> xs, there are two different apis, the old and new
08:25:04 <kc5tja> if I execute ghc --make Main.hs on the command-line, it builds the .o and .hi files, but no a.out!
08:25:11 <xs> dcoutts, aha! which ModelView being preferred?
08:25:21 <kc5tja> This is in direct contradiction to the documentation provided by ghc --help.
08:25:23 <kc5tja> Any ideas?
08:25:25 <xs> er, s/which/with/
08:25:27 <dcoutts> xs, yes, ModelView being preferred.
08:25:45 <dcoutts> simpler more haskelly api, but less tested
08:25:57 <xs> it seems much nicer. thank you very much :)
08:26:20 <sorear> kc5tja: the main module needs to be called Main unless you use --main-is CutParse
08:26:24 <matthew-_> is it legal to use a guard to unpack a Maybe?
08:26:34 <sorear> sure
08:26:36 <kc5tja> sorear: OH, it's capitalized in the source too....
08:26:52 <matthew-_> eg | ((Just x) = in) and (some conditional on x) = blah
08:26:54 <sorear> nothing bound in the guard will be visible in your action of cource
08:26:57 <dcoutts> petekaz, much easier to make the fifo yourself and set up the reader first, then have your haskell prog write to it.
08:27:13 <matthew-_> sorear, can I put a let in the guard?
08:27:17 <matthew-_> oh, that won't help
08:27:32 <matthew-_> ahh, lazy unpack in a where clause I guess
08:27:32 <kc5tja> sorear: No, that's not true either.  It's complaining that Main is out of scope, which makes sense, because it'd be a type name.
08:27:34 <sorear> matthew-_: you might look into the 'pattern guards' ghc extension
08:27:47 <roconnor> how do I strictify hGetContents?
08:27:53 <sorear> roconnor: don't
08:27:57 <kc5tja> I guess I just have to force it with --main-is
08:28:20 <roconnor> sorear: how do I read all the data from a network connection?
08:28:24 <sorear> roconnor: use Data.ByteString.hGet instead if you care about performance enough to want strictness
08:29:24 <roconnor> sorear: My concern is that, and maybe I have an error here, when I go hGetContents, followed by hClose, then I don't get anything.
08:29:27 <xs> sorear, also if you wish to read/write to the same handle reliably, no?
08:29:28 <kc5tja> :(
08:29:30 <kc5tja> This isn't working.
08:29:34 <fantasma> how can one go about finding what 20,000 * 2^7,000,000 is?
08:29:50 <petekaz> dcoutts: I just gave up on the haskell version and write a 5 line python version which works well.  Thanks for the help.
08:29:57 <sorear> roconnor: why do you close it?
08:30:09 <petekaz> Now to play with the bytestring stuff.
08:30:19 <sorear> roconnor: hGetContents always truncates on a closed handle (h98 misfeature)
08:30:19 <roconnor> sorear: so I don't piss off the guy at the other end by keeping a network connection open.
08:30:37 <sorear> roconnor: but hGetContents closes automatically once all the data is read
08:30:45 <kc5tja> fantasma: 20,000 = 2 * 10000 = 2 * 2 * 5000 = 2^2 * 5000 = 2^3 * 2500 = 2^4 * 1250 ...
08:30:58 <roconnor> sorear: I'm not sure I want to read all the data
08:31:02 <kc5tja> That will get you to the point where you can add the exponents of the 2^x terms.
08:31:14 <kc5tja> Then, whatever is left over, you multiply the mantissas.  That's your result.  :)
08:31:19 <sorear> roconnor: then what are you strictifying it for? :)
08:31:30 <roconnor> sorear: so I can close the connection
08:31:37 <fasta> There's a __LINE__ variable, what else is there? (i.e. where is it documented?)
08:31:50 <fantasma> kc5tja, thanks!
08:32:00 <mauke> fasta: any good C book :-)
08:32:09 <qwr> roconnor: hGetContents is lazy. if you close, then it can't read anymore...
08:32:18 <fasta> mauke: I thought it would cpphs, maybe
08:32:19 <sorear> fantasma: 20000 * 2^7000000 works on my ghci, in <10 seconds
08:32:31 <roconnor> qwr: yep, that's why I want to strictify it.
08:32:31 <sorear> fwiw last line is 1285085448146902303364527089455153178381862441902278137854199632970142187520000
08:32:38 <fasta> mauke: or the Haskell C preprocessor (or whatever it's called)
08:32:39 <fantasma> sorear, really? I tried it last night and it broke
08:32:42 <mauke> fasta: http://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html#Predefined-Macros
08:32:44 <lambdabot> Title: Predefined Macros - The C Preprocessor, http://tinyurl.com/29yh6l
08:32:59 <sorear> fantasma: oh? broke?
08:33:05 * kc5tja tries
08:33:46 <kc5tja> It's taking a whole lot longer than 10 seconds on my box.  :)
08:33:51 <sorear> stefan@stefans:~$ /usr/bin/time ghc -e '20000 * 2^7000000 `seq` ()'
08:33:51 <sorear> ()
08:33:51 <sorear> 1.39user 0.06system 0:01.45elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
08:34:10 <sorear> 0.61 for ghc -e '' btw
08:34:22 <kc5tja> Still going on mine.
08:34:28 <mauke> real    0m0.664s
08:34:30 <fantasma> died on mine =\
08:34:43 <qwr> roconnor: you have to decide how much you want read anyway before closeing
08:34:46 <Nicu> Hi, I have a question, why are existential types called like this, when actually they use the universal quantificator (forall)? Did I miss something essential here?
08:34:57 <fantasma> sorear, what specs is your machine?
08:35:08 <sorear> only 30M used
08:35:36 <fantasma> I will try to run it compiled
08:35:39 <sorear> Nicu: apparently they didn't want to add a keyword.  the forall-ness is bogus
08:35:50 <sorear> fantasma: 2Ghz P4, 384M ram
08:35:52 <kc5tja> My box is using only 42MB, fixed, which suggests that it's smart enough to precompute the size of the RAM needed to hold the result.
08:35:59 <sorear> (but ghci only used 30M)
08:36:05 <kc5tja> 800MHz Athlon, 512MB
08:36:30 <kc5tja> Athlon slot-A I should point out.  1st generation.
08:36:35 <sorear> I assume you're using GHC?
08:36:39 <kc5tja> ghci
08:37:03 <fantasma> what is ghc -e?
08:37:08 <Pastorn> cat I case imports? if a file looks in a certain way I want to use module Rules1.hs, otherwise Rules2.hs
08:37:18 <emk> Does anybody know an easy way to download an HTTP URL in Haskell?
08:37:31 <xs> @where Network.HTTP
08:37:32 <lambdabot> http://haskell.org/http
08:37:34 <sorear> well, bignum stuff runs in the same amount of time anyway, because it's all GMP (hand-tuned processor-model-specific assembly)
08:37:53 <fasta> What's wrong with this? #if __FILE__ != "Foobar.hs" import Foobar #endif
08:37:54 <sorear> Pastorn: {-# OPTIONS_GHC -cpp #-} ... #ifdef FOO
08:37:58 <kc5tja> OK, I killed it manually.  It was taking well over several minutes, and still no result.
08:38:02 <matthew-_> so what's the magic fix for ghc spewing "    Ambiguous type variable `m' in the constraints:
08:38:02 <emk> xs: Yeah, but the "simple" example is absolutely insane: http://darcs.haskell.org/http/test/get.hs
08:38:13 <qwr> roconnor: but you could use seq, if you really want strict
08:38:16 <sorear> matthew-_: add a type signature
08:38:28 <matthew-_> sorear:        revision <- fetchPage db pageName version                                                                                    |tidyPath :: (MonadIO m, MonadCGI m) => Maybe String -> Either (m CGIResult) String
08:38:30 <kc5tja> Now, all I need to do is figure out how to convince GHC that it *REALLY* wants to spit out an a.out executable for me.
08:38:49 <sorear> kc5tja: you don't use ELF? :p
08:38:54 <matthew-_> sorear: I have no idea where that first line came from, you want the second there ;)
08:39:25 <kc5tja> sorear: Of course I use ELF.
08:39:34 <fasta> Ok, apparently, " is invalid
08:39:36 <kc5tja> sorear: That doesn't determine the filename used though.
08:39:39 <matthew-_> sorear: and removing either of those type classes really upsets it
08:39:49 <xs> emk, most of that is error handling. it's essentially simpleHttp (request (parseURI addr)) no?
08:39:49 <kc5tja> sorear: Fact is, neither --make nor --main-is is working.
08:39:57 <fasta> I do wonder how to compare __FILE__ to anything then..
08:40:00 <kc5tja> It compiles to .o alright, but it just stops there.
08:40:01 <emk> xs: Hmm, let me try that.
08:40:24 <xs> emk, you'll need the "request" packer function from that file
08:40:33 <xs> emk, and deal with parseURI failing.. oops
08:40:47 <xs> emk, it is a bit fiddly, but it's the error handling.. which is a good thing i suppose :)
08:40:51 <sorear> fasta: you using -cpp?
08:40:55 <fasta> sorear: yes
08:41:02 <sorear> info cpp
08:41:07 <emk> xs: Yeah, but error-handling doesn't need to be that bad, even in Haskell.
08:41:25 <emk> xs: Thanks for the help, though! :-)
08:41:53 <xs> emk: :) one day error handling will be nice.
08:43:03 <emk> xs: What I really want is "getUrl :: ByteString -> IO ByteString", but that's apparently not going to happen.
08:46:11 <fasta> sorear: That's the same as the documentation on the web, and other than "it uses a restricted form of C conditionals" it doesn't tell me what I want to know.
08:46:38 <xs> emk, yes. this has annoyed me before. perhaps string should be a type class.
08:47:16 <sorear> fasta: sure it does.  if cpp only uses a restricted form of c conditionals ... c doesn't support == for string equality :)
08:47:21 <sorear> type classes ftw!
08:47:28 <fasta> sorear: I am using !=
08:47:44 <fasta> sorear: oh, right
08:47:51 <emk> xs: Well, that would be nice. But my more immediate problem is that a 3-line Ruby program is turning into several pages of Haskell, because none of the libraries I need have sane APIs.
08:48:16 <fasta> sorear: should I use C code there then? E.g. strcomp (I don't know all those names by heart)
08:48:16 <emk> Haskell really ought to shine at this stuff.
08:48:29 <qwr> roconnor: ByteString.hGetContents seems to be strict?
08:48:35 <xs> emk, what does the ruby do when you give it invalid urls, closed sockets and broken links?
08:49:15 <dcoutts> qwr, that's because ByteString representation itself it strict, you want ByteString.Lazy.hGetContents which is lazy.
08:49:19 <roconnor> @docs Data.List
08:49:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
08:49:22 <emk> It throws exceptions, which generally have pretty specific classes. I can either catch them, or for small programs, pass the error messages directly to the user.
08:50:24 <fasta> strcmp*
08:50:37 <sorear> fasta: strcmp, and you can't use function calls in cpp conditionals.  I'm afraid it can't be done.  but why? you know what you called the file, can't you unfold __FILE__ and strcmp at writing-time?
08:51:03 <xs> emk, haskell has just made that explicit and forced you to deal with it. i think inside the right monad you could get the same effect. say a transformed over IO and Either Error. but Network.URI uses a different error model to Network.HTTP, iirc.
08:51:12 <fasta> sorear: The idea was to use #include "foo.h" everywhere
08:51:28 <fasta> sorear: instead of import Foo<newline>"include "foo.h"
08:51:32 <sorear> fasta: then __FILE__ would expand (iirc) to "foo.h"
08:51:47 <emk> xs: Oh, I agree completely. It's just that very few Haskell libraries actually have that nice an interface in practice, so I need to reimplement it from scratch every time.
08:52:08 <roconnor> @docs Data.ByteSring
08:52:08 <sorear> haskell has exceptions!
08:52:08 <lambdabot> Data.ByteSring not available
08:52:10 <roconnor> @docs Data.ByteString
08:52:11 <lambdabot> Data.ByteString not available
08:52:36 <fasta> sorear: __LINE__ expands to the call site of the macro, so I would have expected __FILE__ to do the same.
08:52:43 <qwr> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html
08:52:45 <lambdabot> http://tinyurl.com/y58jn8
08:53:12 <xs> emk, this is perhaps because haskell is changing quite a bit still.
08:53:19 <emk> xs: Oh, certainly.
08:53:50 <emk> The only reason the Ruby version is so short is that Matz sat down one day and cloned the entire Python standard library.
08:54:28 <sorear> fasta: that's in macros.  #if is different iirc
08:54:33 <sorear> @where hscpp
08:54:34 <lambdabot> I know nothing about hscpp.
08:54:40 <sorear> @goo hscpp
08:54:40 <emk> Haskell has most of the underlying libraries already (in Hackage). It's just that the APIs are inconsistent, and frequently require 10x to 20x more lines of code to use in the simple cases than they should.
08:54:42 <lambdabot> http://urchin.earth.li/pipermail/debian-haskell/2004-September/000012.html
08:54:42 <lambdabot> Title: [Debian-haskell] Re: [Haskell] hscpp
08:54:54 <fasta> sorear: who invented this crap? :P
08:54:56 <sorear> haskell reimpl of cpp, should be pretty readable :)
08:54:58 <xs> emk, mmhmm :/
08:55:13 <sorear> fasta: kernighan+ritchie
08:55:18 <roconnor> @hoogle ByeString -> String
08:55:19 <lambdabot> No matches, try a more general search
08:55:31 <sorear> fasta: I agree, M4 is much better :)
08:55:37 <fasta> sorear: I read the snd edition of The C programming language.
08:55:47 <sorear> fasta: you might actualy try -pgmF m4
08:55:53 <emk> xs: In general, Haskell should be at least as good as Ruby at all this stuff. I'm frustrated that it isn't, yet.
08:56:01 <fasta> sorear: I just didn't use it as much as Haskell.
08:56:07 <sorear> that'll replace the preprocessor with a real one
08:56:35 <roconnor> @hoogle deepSeq
08:56:35 <lambdabot> No matches found
08:56:39 <sorear> rnf
08:56:51 <sorear> iirc ghc has some wierd conventions for -pgmF, you may need to write a wrapper
08:57:06 <sorear> @ty Control.Parallel.Strategies.rnf
08:57:09 <lambdabot> forall a. (NFData a) => a -> Done
08:57:13 <sorear> > Control.Parallel.Strategies.rnf [1,2,3,4]
08:57:15 <lambdabot>  ()
08:57:18 <sorear> > Control.Parallel.Strategies.rnf [1,2,undefined,4]
08:57:20 <lambdabot>  Undefined
08:57:46 <sorear> it IS a deepSeq, don't let the module fool you
08:58:25 <fasta> sorear: I think I won't use m4 for now. Maybe later. Thanks, anyway.
08:59:13 <fasta> sorear: I already solved it :)
08:59:22 <fasta> sorear: I added a #DEFINE FOO
09:05:55 <roconnor> So I just wrote my own readAll function
09:06:05 <roconnor>   readAll h x = do
09:06:05 <roconnor>    b <- hIsEOF h
09:06:05 <roconnor>    if b then return (x []) else do
09:06:05 <roconnor>      l <- hGetLine h
09:06:05 <roconnor>      readAll h (x . (l:))
09:08:45 <yip> is there something like filter, but that only gets rid of the first matching element?
09:10:33 <kc5tja> Bug report against GHC filed.  :/
09:13:19 <roconnor> @type break
09:13:20 <sorear> @ty delete
09:13:21 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:13:23 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
09:13:34 <sorear> @ty deleteBy
09:13:37 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
09:14:36 <sm> good morning
09:15:22 <abz> ?doc System.Environment
09:15:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
09:19:22 <Pastorn> can i do f (x:'.':ys) = x for "abc.def"
09:19:42 <hpaste>  qwr pasted "getUri in 3 lines" at http://hpaste.org/906
09:19:44 <Pastorn> > let f (x:'.':ys) = x int f "abc.def"
09:19:45 <lambdabot>  Parse error
09:19:50 <Pastorn> thought so...
09:19:54 <qwr> xs: getUri like that?
09:20:11 <kc5tja> ?doc getopts
09:20:11 <lambdabot> getopts not available
09:20:17 <kc5tja> ?doc GetOpts
09:20:18 <lambdabot> GetOpts not available
09:20:20 <kc5tja> hmm
09:20:24 <kc5tja> @hoogle getops
09:20:25 <lambdabot> No matches found
09:20:27 <kc5tja> @hoogle getopts
09:20:28 <lambdabot> No matches found
09:20:32 <kc5tja> Google time
09:20:46 <allbery_b> @hoogle getOpts
09:20:47 <lambdabot> No matches found
09:21:10 <Pastorn> @pl words.lines
09:21:11 <lambdabot> words . lines
09:21:23 <Pastorn> shouldn't that just be words?
09:21:26 <allbery_b> @hoogle getOpt
09:21:26 <lambdabot> Distribution.GetOpt.getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
09:21:27 <lambdabot> Distribution.GetOpt :: module
09:21:27 <lambdabot> Distribution.GetOpt.getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
09:21:39 <allbery_b> @index getOpt
09:21:40 <lambdabot> Distribution.GetOpt, System.Console.GetOpt
09:21:48 <Pastorn> oh wait, nevermind...
09:26:14 <glguy> Pastorn: (x:'a':xs) -- x is a single character
09:26:21 <kc5tja> You know, I'm looking at an example of using getOpts, and it's not at all that much more complicated to deal with them myself.  :)
09:26:46 <kc5tja> @doc Distribution.GetOpt
09:26:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-GetOpt.html
09:27:02 <glguy> @doc System.Console.GetOpt
09:27:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
09:27:57 <matthew-_> is there a way of converting a dynamically linked executable to a static one? (ghc -static -optc-static -optl-static blah... gives errors)
09:30:48 <kc5tja> Is there a type-safe options handling library by any chance?
09:31:06 <kc5tja> Or, is there a facility of converting strings to integers?
09:31:55 <kc5tja> @hoogle String -> Int
09:31:56 <lambdabot> No matches, try a more general search
09:32:02 <kc5tja> @hoogle [Char] -> int
09:32:03 <lambdabot> Did you mean: [Char] -> Int
09:32:07 <kc5tja> @hoogle [Char] -> Int
09:32:08 <lambdabot> No matches, try a more general search
09:32:20 <kc5tja> @hoogle toInteger
09:32:21 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
09:32:23 <thorkilnaur> read "123" = 123
09:32:31 <kc5tja> dang it.
09:32:42 <kc5tja> @doc read
09:32:42 <lambdabot> read not available
09:33:55 <emu> options handling is GetOpt
09:33:58 <emu> @hoogle GetOpt
09:33:58 <lambdabot> Distribution.GetOpt :: module
09:33:59 <lambdabot> Distribution.GetOpt.getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
09:33:59 <lambdabot> Distribution.GetOpt.getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
09:34:16 <emu> hmm that seems out of date
09:34:25 <emu> as for reading strings to ints
09:34:30 <emu> > read "123" :: Int
09:34:31 <lambdabot>  123
09:34:44 <kc5tja> getOpt looks terribly hard to use too.  :(
09:34:48 * kc5tja will roll his own...
09:35:00 <emu> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
09:35:02 <lambdabot> http://tinyurl.com/y3585u
09:35:03 <emu> its easy
09:35:10 <kc5tja> I'm reading that now.
09:36:15 <emu> just use the example
09:36:37 <emu> http://haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
09:36:39 <lambdabot> Title: High-level option handling with GetOpt - HaskellWiki, http://tinyurl.com/ynhvsx
09:37:15 <qwr> rconnor: getAll = unpack . Data.ByteString.Char8.hGetContents
09:49:24 <hpaste>  Pastorn pasted "how do I parse this?" at http://hpaste.org/907
09:50:40 <emu> how about lines,words, and Map.insertWith (++)
09:50:56 <Pastorn> ?type insertWith
09:50:58 <lambdabot> Not in scope: `insertWith'
09:51:03 <emu> @hoogle insertWith
09:51:03 <lambdabot> Data.IntMap.insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
09:51:04 <lambdabot> Data.Map.insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
09:51:04 <lambdabot> Data.IntMap.insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
09:51:31 <Pastorn> wtf is a Key?
09:51:37 <emu> > Map.insert
09:51:38 <lambdabot>   Not in scope: `Map.insert'
09:51:48 <emu> in the IntMap, type Key = Int
09:51:57 <emu> in normal map, it is polymorphic
09:52:06 <emu> with an Ord requirement
09:52:16 <Pastorn> ehm... I don't get it
09:52:31 <emu> alrighty, what it lets you do is, when you insert... instead of replacing the old entry you can combine them
09:52:48 <emu> so if you make your entries lists, then you can combine with (++)
09:52:53 <Pastorn> could you show me something REALLY simple?
09:53:13 <emu> > lines "X 12\n X 1\n"
09:53:15 <lambdabot>  ["X 12"," X 1"]
09:53:21 <emu> > map words $ lines "X 12\n X 1\n"
09:53:22 <lambdabot>  [["X","12"],["X","1"]]
09:53:30 <emu> > Data.Map.empty
09:53:31 <lambdabot>   Not in scope: `Data.Map.empty'
09:53:39 <emu> > M.empty
09:53:41 <lambdabot>  fromList []
09:53:50 <Pastorn> my problem is that I don't know how I should do to make it remember what Char I had on the last line...
09:54:02 <emu> that's why I'm suggesting to use the map
09:54:37 <emu> > [ (x, read y :: Int) | [x,y] <- map words $ lines "X 12\n X 1\n" ]
09:54:39 <lambdabot>  [("X",12),("X",1)]
09:55:01 <emu> > M.fromListWith (++) [ (x, [read y :: Int]) | [x,y] <- map words $ lines "X 12\n X 1\n" ]
09:55:02 <lambdabot>  fromList [("X",[1,12])]
09:55:03 <Pastorn> maybe i could make addnum "X 12" [('X',[1])] = [('X',[12,1])]
09:55:12 <emu> > M.fromListWith (++) [ (x, [read y :: Int]) | [x,y] <- map words $ lines "X 12\n X 1\nY 48" ]
09:55:13 <lambdabot>  fromList [("X",[1,12]),("Y",[48])]
09:55:24 <emu> > M.toList $ M.fromListWith (++) [ (x, [read y :: Int]) | [x,y] <- map words $ lines "X 12\n X 1\nY 48" ]
09:55:25 <lambdabot>  [("X",[1,12]),("Y",[48])]
09:55:56 <emu> fromListWith creates a Map from a list of pairs, but instead of clobbering duplicate keys, it combines them
09:56:04 <Pastorn> my teacher would probably hate that ;)
09:56:48 <qwr> why?
09:57:08 <Pastorn> looks long and clumpsy =)
09:57:16 <emu> then indent it better
09:57:27 <Pastorn> @type indent
09:57:30 <lambdabot> Not in scope: `indent'
09:57:33 <Pastorn> yay
09:57:34 <emu> i mean in your text editor
09:57:39 <Pastorn> ?instances indent
09:57:40 <lambdabot> Couldn't find class `indent'. Try @instances-importing
09:57:42 <Pastorn> oh
09:57:44 <Pastorn> hehe
09:57:59 <Pastorn> ?type M.toList
09:58:01 <lambdabot> forall k a. M.Map k a -> [(k, a)]
09:58:09 <Pastorn> ?type M.fromList
09:58:11 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
09:58:24 <Pastorn> ?type M.fromListWith (++)
09:58:26 <lambdabot> forall a k. (Ord k) => [(k, [a])] -> M.Map k [a]
09:58:47 <Pastorn> what's the k?
09:58:54 <emu> key
09:59:00 <Pastorn> ehm...
09:59:04 <emu> its polymorphic
09:59:07 <Pastorn> riiiiiight
09:59:16 <Pastorn> what's a key?
09:59:19 <emu> anything you want it to be, so long as it can be "Ord"ered
09:59:51 <[1]acp> Hello all. New to haskell, doing the YAHT on GHC. Have a question about type inference.
09:59:54 <qwr> Pastorn: a and k are type variables
10:00:10 <emu> in this case we're doing a Map String [Int]
10:00:19 <Pastorn> qwr: sorry, that doesn't mean much :(
10:00:28 <emu> apparently your prof sucks =)
10:00:51 <[1]acp> mysquare x = x * x <--- claims it's working on Nums when inspected with :t
10:00:55 <Pastorn> heh, this is just an introduction course, normal map should be sufficient
10:01:06 <emu> @type \x -> x * x
10:01:08 <lambdabot> forall a. (Num a) => a -> a
10:01:12 <[1]acp> lamsquare = \x -> x * x <--- claims working on ints
10:01:14 <emu> Pastorn: that is normal
10:01:21 <emu> [1]acp: it's defaulting
10:01:31 <emu> it has to do with the monomorphism restriction.
10:01:48 <emu> basically i'd just recommend writing mysquare x = x * x
10:01:48 <[1]acp> The monowhat? Should I just ignore it for the time being then?
10:01:51 <emu> yea
10:02:03 <audreyt> [1]acp: ghci -fno-monomorphism-restriction
10:02:09 <emu> basically, if you hit that kind of thing, in general, just make your parameters or your types explicit
10:02:13 <audreyt> restores the correct behaviour :)
10:02:27 <[1]acp> Yeah, I haven't arrived at that chapter yet :). I'll try the flag, thanks.
10:02:33 <fasta> audreyt: and introduces unexpected slowness
10:02:45 <audreyt> fasta: for YAHT beginners? not likely.
10:02:51 <Pastorn> emu: I could just use groupBy...
10:02:55 <fasta> audreyt: for everyone.
10:02:56 <emu> the reason behind the monomorphism restriction is that it might introduce a repeated computation
10:03:00 <emu> (without it)
10:03:05 <jcreigh> [1]acp: http://www.cs.auckland.ac.nz/references/haskell/haskell-intro-html/pitfalls.html#sect10.3
10:03:07 <lambdabot> Title: A Gentle Introduction to Haskell: Typing Pitfalls, http://tinyurl.com/2e9t2x
10:03:12 <emu> Pastorn: that sounds good
10:03:21 <audreyt> fasta: I've argued on both sides so I'll skip this particular one :)
10:03:26 <emu> Pastorn: i use Maps a lot, so ... when you got a hammer
10:03:42 <jcreigh> [1]acp: the monomorhism restriction is now generally considered to be a bad idea, but you can avoid it easily by give type signatures.
10:04:02 <Pastorn> emu: I would like to learn more about the Map module, but it seems so very complicated
10:04:08 <emu> it's mroe general because Maps can handle cases where "X 1\nY 2\nX 3" whereas groupBy can only handle adjacent cases
10:04:21 <jcreigh> [1]acp: well, maybe "bad idea" is too strong...let's say "wart"
10:04:32 <emu> Pastorn: it's not
10:04:50 <emu> Pastorn: just sit down at the GHCi prompt, import Map, and give it a shot
10:05:00 <jcreigh> Pastorn: have you ever used, a hash table of associative array in a different language?
10:05:02 <emu> :m + Data.Map
10:05:13 <jcreigh> hash table *or* associative array
10:05:23 <[1]acp> They claim "A simpler explanation follows", but I don't quite follow it. Ignoring it seems much more appealing.
10:05:38 <Pastorn> jcreigh: nope, haskell is my first language (well, second after swedish ;) )
10:05:49 <audreyt> [1]acp: please ignore it for the time being :)
10:06:46 <[1]acp> Thanks
10:07:05 <Pastorn> module Play where; import Data.Map
10:07:32 <Pastorn> emu: what happends to the normal map?
10:07:51 <Pastorn> is it overloaded by the one in Data.Map?
10:08:56 <cod3po37> I'm having a bit of trouble compiling HAppS 0.8.8 and I don't know why (because I just did it the other night on a different computer). I have all of the dependencies, configure seems to go well, build gets to [69 of 72] before it starts linking (which seems problematic but it doesn't complain) but when I try install, I get the following error: 'Setup.hs: Error: Could not find module: HAppS with any suffix: ["hi"]'
10:09:05 <Pastorn> "Ambiguous occurrence `map'" - How do I make it ignore all the functions that are already defined in Prelude that also exists in Data.Map?
10:09:46 <TomMD> :m + Prelude hiding (map)
10:09:51 <kowey> Pastorn: import qualified Data.Map as Moo
10:09:53 <TomMD> but you don't want to do that
10:09:55 <kowey> Pastorn: Moo.map
10:10:05 <Pastorn> what?
10:10:06 <kowey> (I tend to use just M, myself)
10:10:08 <TomMD> "Moo" can be anything in that example
10:10:25 <Pastorn> yeah, I understand that
10:10:41 <Pastorn> import Data.Map as M ?
10:10:53 <TomMD> That work
10:11:13 <TomMD> Just not from the GHCI interface (use it in an actual file, for example)
10:11:26 <TomMD> Anyone know how to import qualified from ghci?
10:11:27 <Pastorn> TomMD: huh?
10:11:55 <TomMD> at the GHCI prompt, you cant use 'import'  but you can load modules with ":m " and the module name
10:11:59 <Pastorn> TomMD: hugs can handle it
10:12:00 <TomMD> > import Data.Map
10:12:00 <lambdabot>  Parse error
10:12:01 <TomMD> see
10:12:19 <TomMD> oh, hugs... bleahh... ok, if it can do it that is great.
10:12:54 <Pastorn> > Data.Map.map (>5) [1..10] -- what?
10:12:55 <lambdabot>   Not in scope: `Data.Map.map'
10:13:11 <Herald> hi im having some trouble with basic list comprehension when im dealing with lists of lists. im trying to seperate a list of ints into a list of lists - each sublist 5 chars long
10:13:11 <TomMD> Pastron: You are confusing your 'map'
10:13:32 <qwr> > let m = M.insert 2 "Y" . M.insert 1 "X" $ M.empty in [ M.lookup 1 m, M.lookup 12 m] :: [Maybe String]
10:13:32 <TomMD> > Prelude.map (>5) [1..10]
10:13:34 <lambdabot>  [False,False,False,False,False,True,True,True,True,True]
10:13:34 <lambdabot>  [Just "X",Nothing]
10:13:58 <Pastorn> @paste --Herald: paste your list and an example of the output you want plz
10:13:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:14:53 <Pastorn> TomMD: how do you write that same line with Data.Map.map?
10:15:07 <TomMD> @type Data.Map.map
10:15:09 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
10:15:40 <TomMD> You see- Data.Map is also called a Binary tree - it is not made to apply functions to lists.  It "maps" a 'key' into a 'value'.
10:16:07 <Pastorn> ehm... what are the intended uses for that?
10:16:08 <Herald> http://hpaste.org/908
10:16:21 <Herald> list and example output
10:16:25 <Herald> appreciate the help :)
10:16:48 <Pastorn> Herald: look at the function splitAt
10:16:53 <qwr> Pastorn: look my lambdabot insert lookup for example - you put things in map and then ask by key
10:17:06 <TomMD> Pastorn: Lets say you run a library and you wish to keep track of all checked out books.  The "key" of your mapping could be the books while the "value" would be the names of people who have checked the book out.  It is just a database.
10:18:03 <Herald> i am able to split them, but im confused by which operator to use to concatenate the new list with the outer list
10:18:32 <Herald> so how to turn [1,2,3] and [4,5,6] into [[1,2,3],[4,5,6]] as opposed to [1,2,3,4,5,6]
10:18:55 <Herald> ?
10:19:16 <Pastorn> > [1,2,3] : [4,5,6]
10:19:17 <lambdabot>   add an instance declaration for (Num [t])
10:19:18 <lambdabot>     In the expression: 6
10:19:27 <Pastorn> > [1,2,3] : [4,5,6] : []
10:19:28 <lambdabot>  [[1,2,3],[4,5,6]]
10:19:54 <Herald> thank you
10:19:55 <mux> @pl \xs ys -> [xs,ys]
10:19:56 <lambdabot> (. return) . (:)
10:20:08 <hpaste>  allbery_b annotated "how do I parse this?" with "there's gotta be a better way" at http://hpaste.org/907#a1
10:20:17 <mux> @type \xs ys -> [xs,ys]
10:20:19 <lambdabot> forall t. t -> t -> [t]
10:20:38 <Pastorn> Herald: check out More About Lists under Elementary Haskell: http://en.wikibooks.org/wiki/Programming:Haskell
10:20:47 <mux> [xs,ys] is syntactic sugar for xs:ys:[]
10:21:06 <TomMD> Yes, the wikibooks are something I wished I found when I was learning Haskell earlier.
10:21:06 <hpaste>  qwr annotated "(no title)" with "(no title)" at http://hpaste.org/908#a1
10:22:31 <kowey> Pastorn: ah, you'll want to be using the new URL now: http://en.wikibooks.org/wiki/Haskell :-)
10:22:59 <Pastorn> kowey: had no clue .)
10:23:01 <Pastorn> :)
10:24:05 <Pastorn> TomMD: please, write the most basic example (using id or whatever) of usage for Data.Map.map
10:27:06 <qwr> > M.fromList [(1,13), (42, 7)] $ M.map (2 *)
10:27:07 <lambdabot>  Couldn't match expected type `a -> b'
10:28:19 <qwr> > M.map (2 *) $ M.fromList [(1,13), (42, 7)]
10:28:20 <lambdabot>  fromList [(1,26),(42,14)]
10:29:01 <hpaste>  Pastorn annotated "(no title)" with "splitEvery (for Herald)" at http://hpaste.org/908#a2
10:29:42 <Pastorn> qwr: okay, what does that do and in what order?
10:29:59 <qwr> > M.fromList [(1,13), (42, 7)]
10:30:01 <lambdabot>  fromList [(1,13),(42,7)]
10:30:09 <Pastorn> but but but!!
10:30:32 <Pastorn> fromList isn't FromList, so it's not a constructor! it can't be standing there alone!!
10:30:40 <Pastorn> *world explodes*
10:30:50 <jcreigh> right, it's a function
10:30:55 <qwr> > (M.lookup 42 $ M.fromList [(1,13), (42, 7)]) :: Maybe Int
10:30:57 <lambdabot>  Just 7
10:31:01 <allbery_b> it's just a (slightly odd) Show instance for Maps
10:31:04 <Pastorn> shouldn't LB evaluate it then?
10:31:14 <allbery_b> I think ghc actually uses a different Show instance these days
10:31:33 <allbery_b> or at least ghci,using braces)
10:31:46 <allbery_b> Pastorn: it does.  then it does "show" on it, which reverses it :)
10:32:21 <Pastorn> qwr: so Data.Map is for use with tables?
10:32:33 <Pastorn> @type M.map
10:32:36 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
10:32:49 <qwr> Pastorn: you could call it a table. or mapping ;)
10:32:58 <Pastorn> big question: where's the fucking list?!
10:32:58 <allbery_b> hm, no, I now ge the sane result from ghci
10:33:07 <allbery_b> er, same
10:33:16 <qwr> Pastorn: nowhere. just an easy way to construct it
10:34:08 <qwr> > (M.insert 1 13 . M.insert 42 7) $ M.empty
10:34:09 <lambdabot>  fromList [(1,13),(42,7)]
10:34:29 <qwr> > M.insert 1 13 $ M.empty
10:34:30 <lambdabot>  fromList [(1,13)]
10:34:48 <Pastorn> @type M.insert
10:34:50 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
10:35:25 <Pastorn> right, so everything I create with Data.Map is a Binary Tree?
10:35:46 <qwr> i think yes
10:35:51 <Pastorn> cool
10:43:56 <fasta> Pastorn: Not everything is a list in Haskell. (It's not Lisp, although some people do call it a Lisp)
10:44:59 <Pastorn> fasta: hehe, I know =)
10:45:58 <ray> some people claim everything is lisp
10:46:16 <ray> one time i was eating some spaghetti and someone came by and said "hey, nice lisp dialect you're hacking in there"
10:46:24 <ray> there wasn't a good way to respond to that
10:46:37 <qwr> even OISC is lisp?
10:46:46 <ray> of course
10:46:49 <ray> (somehow)
10:46:53 <mauke> @remember ray some people claim everything is lisp. one time i was eating some spaghetti and someone came by and said "hey, nice lisp dialect you're hacking in there"
10:46:53 <ray> (don't ask me how)
10:46:54 <lambdabot> Done.
10:48:40 <ray> maybe if you write it (subleq .....)
10:51:00 <matthew-_> ok, someone here yesterday mentioned something about what you use if you need fastcgi
10:51:13 <Pastorn> isn't lisp just a bunch a parentheses with sporadic words here and there?
10:51:57 <dmhouse> Eurgh, I hate overcomplicated module systems.
10:51:59 <rashakil> the words are made of letters, which are made of really tiny parentheses only one pixel tall arranged in the shape of letters
10:52:02 <matthew-_> because I'm trying to compile it from http://www.cs.chalmers.se/~bringert/darcs/haskell-fastcgi/ and that needs the cgi-compat stuff
10:52:04 <lambdabot> Title: Index of /~bringert/darcs/haskell-fastcgi
10:53:36 <qwr> Pastorn: those parenthesis mark lists in lisp - the lisp program is basically parse tree in lisp (data) syntax
10:54:12 <qwr> Pastorn: and then there are some simple semantics
10:54:26 <dmhouse> Lisp syntax is awesome. It's beautiful in a kind of simplistic way, and the simplicity means it's really easy to write tools that actually do the right thing with regard to indentation and such.
10:56:23 <mauke> lisp syntax is impossible to parse
10:56:32 <mauke> because you can completely redefine the parser on the fly
10:56:40 <mauke> (see also: perl)
10:56:41 <kuribas> It's easier to parse than Haskell syntax.
10:56:51 <dmhouse> mauke: for a computer, you mean?
10:57:29 <mauke> what I mean is that you can't parse lisp without being able to run lisp, which means you need to be a complete lisp system
10:58:22 <kuribas> mauke: Why would that be a problem?
10:58:36 * integral thinks the scheme syntax is static enough that enough can be parsed without a scheme impl
10:59:08 <mauke> kuribas: you can't write tools that understand lisp without embedding a complete lisp interpreter
10:59:17 <mauke> and it's obviously unsafe
10:59:25 <Eelis> sounds like C++
10:59:40 <mauke> no, C++ syntax is static
10:59:53 * mbishop considers bringing Riastradh in here to argue
10:59:54 <mauke> it's just insanely complex
11:00:08 <Eelis> mauke: yes, but you also need to write almost a full compiler to be able to parse C++ source code
11:00:40 <kuribas> mauke: you can reasonably assume that people will not redifine (lambda) and (let), etc...
11:00:42 <mauke> I think the only hard part is the name lookup rules
11:01:11 <integral> kuribas: why?  You might want some debugging or performance instrumentation that redefines those
11:01:18 <mauke> irrelevant
11:01:38 <Eelis> mauke: no, it's much more than that. you can write a statement that is either a variable definition or a function declaration, depending on the sizeof() something. and of course, to be able to calculate the sizeof arbitrary types, you need to do object layout, vtables, the works
11:01:47 <mauke> the parser doesn't care what (lambda) means, it just generates a single-element list containing the symbol LAMBDA
11:01:48 <kuribas> integral: yes, but then we are talking about tools, not people :)
11:01:52 <matthew-_> and dbdirectdb / hs-plugins / hdbc folk awake ?
11:01:57 <matthew-_> s/and/any/
11:02:27 <mauke> Eelis: hmm, how do you do that?
11:02:35 <Eelis> mauke: i'm browsing my snippet collection as we speak
11:02:41 <mauke> :)
11:02:56 <kuribas> mauke: how is that different from other languages?  It's not the task of the parser to think about semantics.
11:03:39 <kuribas> I think writing tool support for scheme is much easier than for haskell.
11:03:43 <Botje> kuribas: you can alter the lisp parser *in lisp itself*
11:04:27 <kuribas> you mean reader extensions?
11:04:36 <Botje> yes.
11:04:54 <Eelis> mauke: http://rafb.net/p/O4AKI113.html (i remembered wrong, it's function call vs variable declaration)
11:04:55 <lambdabot> Title: Nopaste - No description
11:04:59 <mauke> (require "implinest.lisp") (print #$ * 2 #$ + 4 5)
11:05:54 <mauke> Eelis: ah, right
11:06:54 <Botje> Eelis: woah. that's pretty obscure.
11:07:26 <Botje> would anyone use it like that?
11:10:38 <kc5tja> You can process C++ syntax without a C++ compiler.  But you DO need the C preprocessor, because of macro expansions.
11:10:50 <kc5tja> (sorry for the late response)
11:11:03 <mbishop> way to be late
11:11:26 <kc5tja> It's just that nobody posted that, so I thought I would, in case the topic comes up again.  :)
11:11:46 <mauke> kc5tja: did you see eelis's code?
11:12:22 <kc5tja> Heh, actually I haven't even followed the conversation.  :)
11:12:43 <Pastorn> @pl (\x y -> head x ==  head y)
11:12:43 <lambdabot> (. head) . (==) . head
11:12:47 <Pastorn> nice
11:13:27 <mauke> @pl \head x y -> head x ==  head y
11:13:27 <lambdabot> flip =<< (((.) . (==)) .)
11:16:02 <kc5tja> Anyone here familiar with HUnit at all?
11:16:07 <vali> hello. is haskell a compiled language?
11:16:20 <kc5tja> Are there alternative, more Haskelly solutions to unit testing?
11:16:40 <abz> vali: yes
11:16:50 <abz> vali: and no
11:17:00 <vali> abz: what is the default?
11:17:06 <kc5tja> vali: Yes, but performance isn't always as good as raw C, as Haskell code is doing a lot more work.  It's the typical high-level vs. low-level language tradeoff.
11:17:40 <mauke> vali: there are no compiled languages
11:17:43 <kc5tja> vali: Use ghci to invoke the interpreter, but use ghc for just the compiler.
11:17:45 * Pastorn is writing a parser for [[[String]]] -> Something Else
11:17:52 <vali> i see. i'm not mostly concerned with performance. i'm more curious about how difficult it is to produce executables. is it a nightmare as in lisp?
11:18:08 <jcreigh> Is the recommend way to test for a NULL pointer in the FFI just to compare it to nullPtr? (eg, "p == nullPtr"?)
11:18:28 <mauke> vali: no, it's trivial with ghc
11:18:31 <kc5tja> That question doesn't mean much without a specific Lisp environment.  That being said, I'm versed in Forth and such, not Lisp.  So I couldn't answer anyway.  :)
11:18:47 <mauke> jcreigh: I think so
11:18:56 <vali> mauke: ah, great. is there a way to see the assembly code it produces? and it is intel syntax?
11:19:39 <sm> kc5tja: http://en.wikibooks.org/wiki/Haskell/Packaging#Testing
11:19:55 <mauke> vali: the -S flag
11:19:57 <kuribas> It doesn't make much sense to look at assembly code generated by a haskell compiler, does it?
11:20:01 <mauke> (I've never used it, though)
11:20:03 <vali> mauke: okay, thank you
11:20:49 * sm loves compiling with ghc.. just works
11:25:29 <stepcut> kc5tja: how about QuickCheck ?
11:26:57 <matthew-_> is there a debian package of haskelldb which is compiled with hdbc rather than hsql?
11:28:18 * Pastorn actually needed to write head $ head $ head x
11:30:16 <mauke> head . head . head $ x
11:30:35 <hpaste>  david_ annotated "how do I parse this?" with "noobie's take on this." at http://hpaste.org/907#a2
11:30:47 <Pastorn> hmmm... if I make f (x:xs) to f xs i can do head . head . head $ head xs
11:31:43 <kc5tja> sm, stepcut: Thanks -- I'll check them out in a bit.  I stumbled across this page, which is very interesting to read: http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem
11:31:46 <lambdabot> Title: A type-based solution to the "strings problem": a fitting end to XSS and SQL-inj ..., http://tinyurl.com/uv94m
11:32:01 <mauke> f (((x : _) : _) : _) = x
11:36:06 <emk> I want to write a rant about API problems, but I don't want to hurt anyone's feelings.
11:36:35 <jcreigh> emk: it is possible you have conflicting goals. :) what API problems?
11:37:13 <emk> I spent several hours this morning translating a 3-line Ruby program to Haskell. But library API lossage caused it to expand to about 2 pages of code.
11:37:39 <Pastorn> yay!
11:37:40 <jcreigh> emk: really? What were the 3 lines?
11:38:04 <Pastorn> @paste -- emk: show
11:38:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:38:07 <emk> The problems were fairly consistent: Too much conversion between different types of strings, and a failure to provide adequate support for the common cases.
11:38:14 <emk> Pastorn: Working on it.
11:38:30 <Pastorn> :D
11:38:44 <xerox> Yeah, what were the 3 lines?
11:38:54 <emk> hpaste DNS is sad. :-(
11:39:04 <emk> Is there another nice Haskell paste site?
11:39:17 <xerox> http://paste.lisp.org/new/haskell
11:40:32 <swiert> How can I catch a failed "read"?
11:40:38 <mauke> you don't
11:40:45 <xerox> you can in IO
11:40:48 <mauke> use reads instead
11:41:24 <Pastorn> @type reads
11:41:27 <lambdabot> forall a. (Read a) => String -> [(a, String)]
11:41:43 <Pastorn> > reads "14" :: Int
11:41:44 <lambdabot>  Couldn't match expected type `Int'
11:42:00 <mauke> > reads "14" :: [(Int,String)]
11:42:01 <lambdabot>  [(14,"")]
11:42:09 <mauke> > reads "1a" :: [(Int,String)]
11:42:11 <lambdabot>  [(1,"a")]
11:42:15 <Pastorn> cool
11:42:18 <xerox> ?type catch . readIO
11:42:19 <mauke> > reads "ia" :: [(Int,String)]
11:42:22 <lambdabot>  []
11:42:22 <lambdabot> forall a. (Read a) => String -> (IOError -> IO a) -> IO a
11:42:32 <xerox> reads is much better (:
11:42:59 <augustss_> reads is the way if you plan to fail
11:43:05 <Pastorn> why does it give a list? seems unnesesary (+spelling)
11:43:17 <swiert> Ok. Fair enough.
11:43:33 <swiert> Why doesn't catch work?
11:43:38 <augustss_> Pastorn: in general there can be several ways to parse something, so this handle ambiguity
11:43:41 <mauke> Pastorn: because some types could have ambiguous reads
11:44:03 <hpaste>  emk pasted "Ruby versus Haskell" at http://hpaste.org/909
11:44:37 <glguy> http://programming.reddit.com/info/19aze/comments -- emk
11:44:39 <lambdabot> Title: So What’s So Special About Ruby, Anyhow? (reddit.com)
11:45:34 <glguy> emk: that is a non comparison
11:45:41 <emk> glguy: There's absolutely _no good reason_ why the Haskell code is so much uglier than the Ruby code.
11:45:55 <emk> There are serious problems here that can be addressed productively.
11:45:55 <glguy> you just demonstrated what happens when you don't bother making a library first
11:45:58 <Korollary> How many libraries are involved in there lol
11:46:27 <emk> glguy: In both examples, I import the standard HTTP client library and the standard MD5 digest library.
11:47:00 <emk> But in the Haskell example, the minimum implementation of HTTP GET from the library's own docs is almost a page long:
11:47:07 <emk> http://darcs.haskell.org/http/test/get.hs
11:47:33 <glguy> so... clearly a library would be needed between what you have and what you need
11:47:35 <augustss_> emk: so improve the library.  it seems possible
11:47:40 <jcreigh> emk: not quite. 'net/http' is the standard HTTP client in Ruby. (but still, you're right: there should be an 'open-uri' in Haskell. We're just waiting for somebody to write it...)
11:47:52 <glguy> which has nothing to do whatsoever with haskell or ruby
11:48:04 <emk> What's going on there: Network.URI and Network.Streams have two different error-handling conventions.
11:49:38 <emk> URI uses Maybe URI. But Streams uses IO (Result a), which is just a broken version of ErrorT ConnError IO.
11:50:05 <emk> ...and this lossage propagates up out of the standard hierarchical libraries to infect the HTTP library.
11:50:51 <emk> There's no fewer than 5 different error-handling conventions in Haskell, and every library seems to use a different one.
11:51:11 <emk> If everybody just used MonadError, or even Monad+fail, this would be easy.
11:52:10 <emk> augustss_, jcreigh: Oh, absolutely. There's no reason in the world why the Haskell example couldn't be as short as the Ruby example.
11:53:59 <kuribas> glguy: your examples can be coded easily in Ruby like that.
11:54:41 <emk> But this isn't an isolated case, either--plenty of Haskell libraries have overcomplicated APIs and a lack of straightforward support for common operations.
11:55:43 <emk> The Regex library, for example, can get pretty awkward.
11:57:10 <emk> The biggest culprits are inconsistent error-handling styles, inconsistent string representations, and highly general APIs that don't handle the common case well.
11:57:12 <emk> But on a happy note, the standard Prelude suffers from none of these problems.
11:57:59 <emk> Anyway, that's my rant for today.
11:58:22 <glguy> kuribas: the point was that that was a lousy blog article
11:58:27 <bos> hpaste is back up, sorry.
11:58:42 <bos> i have a flaky WDS connection between my innanet and my outanet.
11:58:51 <emk> bos: No problem. :-)
11:58:57 <emk> I got it to work.
11:59:00 <glguy> wds?
11:59:41 <bos> wireless distribution, em, um, s.
12:00:08 <bos> it's a way of getting two APs to appear as components of a single network.
12:00:23 <glguy> oh, cool
12:00:34 <bos> emk: your point about the libraries is well taken. i was thinking about just this over the past few days myself.
12:00:46 <kuribas> glguy: yes, that's right.  The code he writes isn't even idiomatic Ruby.
12:01:19 <emk> What might be a worthwhile project: Going through the Ruby standard library, class by class and method by method, and making sure that Haskell has an equivalently easy solution.
12:01:21 <bos> for example, it drives me bonkers that EOF raises an exception on I/O. that's just silly.
12:01:47 <bos> and the python stdlib, too. they all have their warts.
12:02:11 <bos> every language that i've used has some rotting bodies buried in its library basement.
12:02:14 <emk> Apparently, Matz built the Ruby standard library by doing the same thing to Python--going through the standard library a method at a time, making sure that Ruby could do it all.
12:02:59 <bos> john goerzen tried to do the same with MissingH, but the results are not great.
12:03:17 <emk> bos: Well, the Haskell Prelude is just about flawless, with the exception of some of the typeclasses. But the "standard" add-on libraries are frequently much harder to use than the Ruby, Python equivalents.
12:03:18 <bos> there are so many dependencies between little bits of MissingH library that it's not worth using.
12:03:46 <bos> emk: yes, i know. the network library, io, http, haxml, hxt, etc, etc. all pretty iffy.
12:04:22 <emk> I mean, for what earthly reason is ConnError not an instance of Error?
12:06:32 <bos> well, these things are fixable.
12:07:02 <emk> bos: Yup.
12:07:08 <matthew-_> agh! what has happened in the last 6 months to haskelldb? hs-plugins finally gets fixed to work with 6.6 and now haskelldb doesn't seem to support hdbc anymore.
12:07:31 <bos> the problem is inertia, mostly.
12:07:35 <emk> Or a related question: Why do Network.URI and Network.Stream have different error-handling conventions? (I know, there's perfectly reasonable historical reasons for most of this. But we shouldn't be satisfied with the way things stand.)
12:08:19 <sjanssen> emk: do you really want to taint URI parsing with IO?
12:08:32 <abz> Network help needed: I'm trying to send a message to a server, and receive its response. I'd like a function like `sendAndReceive :: Handle -> String -> IO String`. Can anyone point in the right directory?
12:09:12 <emk> sjanssen: Nope. But at least it could have type 'parseURI :: Monad m => String -> m URI', so it would play nicely with IO if you wanted to use it there.
12:09:36 <sjanssen> emk: oh yes, that'd be much better
12:10:22 <sjanssen> which package has Network.URI?
12:10:39 <emk> sjanssen: And similarly, 'IO (Either ConnError a)' would be much more reasonable type if ConnError was actually an instance of Error...
12:11:00 <sjanssen> emk: maybe just IO a is better?
12:11:02 <bos> sjanssen: network
12:11:03 <emk> sjanssen: I think it's in the stuff shipped with GHC.
12:11:13 <sjanssen> and the function could through IO exceptions?
12:11:23 <emk> sjanssen: That would also be excellent.
12:11:34 <bos> abz: you'll need to write it yourself.
12:11:36 <sjanssen> s/through/throw
12:12:14 <abz> bos: just using the System.IO h* stuff?
12:12:43 <bos> abz: Network.Socket lets you turn a Socket into a Handle, then you can use the Handle stuff.
12:13:04 <bos> just be sure to use hFlush after you're finished writing.
12:13:43 <bos> emk: a component of the problem is that cleaning up APIs and internals will inevitable break applications.
12:14:33 <bos> e.g. you can make ConnError an instance of Error probably without any sweat, but the Network.BSD module needs to be taken out to the old module's home entirely.
12:15:06 <bos> and Network.Socket needs retooling to work with non-String data.
12:16:29 <bos> i don't really know how to cut that particular gordian knot.
12:20:51 <fuzan> ?hoogle when
12:20:52 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
12:20:52 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
12:21:37 <sjanssen> why is Bulat always so interested in reimplementing things?
12:22:04 <bos> nothing wrong with that. perhaps it's the russian influence?
12:22:53 <sjanssen> bos: it's just annoying that he rewrites things like arrays, IO systems, etc.
12:23:09 <sjanssen> I'd be much happier if his efforts ended up in base, where people will actually use them
12:23:37 <bos> it seems like the overhead of getting stuff into base is quite high.
12:23:50 <sjanssen> this is true
12:24:05 <desp> hello
12:24:07 <bos> and as he observes, once something goes into base, it becomes fossilized.
12:24:15 <Cale> It's not so much his reimplementing things which bothers me, it's when he answers beginner questions taking an approach which involves this low-level hackery.
12:24:21 <sjanssen> the interface becomes fossilized, yes
12:24:24 <desp> is it possible to write a case expression with guards?
12:24:32 <Cale> desp: yep
12:24:41 <Cale> case foo of pat | guard -> ...
12:24:46 <sjanssen> but I'm not convinced that the interface to IO and arrays is all that bad
12:24:54 <bos> the array interface is fine.
12:25:19 <bos> the IO interface is a bit fugly, and there's the EOF-is-exception silliness.
12:25:34 <sjanssen> bos: how would you handle EOF?
12:25:41 <bos> return an empty string.
12:25:46 <desp> Cale: "->"?
12:25:49 <bos> that's what every other language does.
12:25:50 <desp> Cale: http://pastie.textmate.org/46059
12:25:52 <lambdabot> Title: #46059 - Pastie
12:26:11 <Cale> desp: you forgot the pattern
12:26:14 <sjanssen> @hoogle iseof
12:26:15 <lambdabot> IO.isEOF :: IO Bool
12:26:15 <lambdabot> IO.isEOFError :: IOError -> Bool
12:26:15 <lambdabot> System.IO.Error.isEOFErrorType :: IOErrorType -> Bool
12:26:17 <Cale> desp: in this case _ will do
12:26:44 <Cale> er, also the = signs should be ->
12:26:54 <sjanssen> bos: anything else about IO that bothers you?
12:26:54 <Cale> because it's case
12:27:21 <bos> sjanssen: not really, actually. it would be nice to have ByteString support baked in, but that's kind of present in Data.ByteString already.
12:27:31 <desp> hrm
12:27:55 <bos> although it would be nice to have a select-like interface exposed, now that i think of it.
12:28:40 <sjanssen> certainly
12:28:49 <stepcut> bos: there is hWaitForInput -- which is a little bit similar
12:28:55 <encryptio> i think a message passing interface for haskell threads would be nice to have, instead of this "throw an exception in that thread" weirdness
12:29:05 <desp> Cale: I changed all = to -> and put _ after of; still doesn't compile
12:29:06 <Cale> !paste
12:29:07 <hpaste> Haskell paste bin: http://hpaste.org/
12:29:12 <sjanssen> stepcut: that can't wait on several input sources simultaneously
12:29:17 <bos> stepcut: but that's single-handle only
12:29:26 <hpaste>  Cale pasted "roman" at http://hpaste.org/911
12:29:33 <bos> you'd really like to be able to select on several IO and Network handles all at one time.
12:29:50 <stepcut> bos: yeah, you would have to fork a bunch of threads and have them write to an MVar or something...
12:30:01 <sjanssen> my concern with writing an external IO library is that nobody will use it
12:30:13 <desp> ah... too little indentation.
12:30:14 <desp> thanks.
12:30:18 <bos> sjanssen: that's exactly what has happened to network-alt, which is quite nice.
12:30:39 <sjanssen> it's a bit annoying that we can select across STM TVars, but not handles
12:31:25 <stepcut> encryptio: what about Control.Concurrent.Chan and Control.Concurrent.MVar, etc ?
12:31:29 <sjanssen> bos: does the network library give you plain old handles, or is it something different?
12:31:42 <bos> sockets, which can be converted to handles.
12:32:47 <sjanssen> so the RTS will use select on concurrent blocking reads on file and network handles
12:33:01 <sjanssen> (when using forkIO threads in ghc, that is)
12:33:04 <Cale> encryptio: yeah, you can use Chans to set up message passing rather easily
12:33:29 <Cale> encryptio: What's more, you can even use the STM interface to have "transactional messages"
12:33:32 <encryptio> i really need to just read through the entire base library docs.
12:34:00 <Cale> (because Chans can be filled with any type of value)
12:35:18 <sjanssen> Cale: Chans may only hold one type of value
12:35:45 <bos> sjanssen: he means Chan is polymorphic in the message payload
12:52:27 <sm> no default show method for lists ? that seems odd
12:54:04 <sm> Prelude> [] gives ERROR - Cannot find "show" function for: *** Expression : [] *** Of type    : [a]
12:54:23 <abz> > show []
12:54:24 <Igloo> You need Show a
12:54:24 <lambdabot>  "[]"
12:55:09 <sm> > []
12:55:10 <lambdabot>  []
12:55:29 <sm> I thought ghci did an implicit show
12:57:04 <sm> so, I have a small problem - type Account = (AccountName,[EntryTransaction]) needs a show method, because of the list
12:57:20 <sm> but if I define one, it complains it overlaps with ()'s show
12:57:43 <xerox> define Show instances for AccountName and EntryTransaction
12:58:02 <xerox> there already are instances for (Show a) => [a] and (Show a,Show b) => (a,b)
13:01:41 <sm> xerox: I'm pretty sure I already have
13:01:49 <sm> I can show those things individually
13:02:05 <fax> hi
13:02:54 <Saizan> you can use -fallow-overlapping-instances, but you should use Show for debugging purpouses, mostly
13:02:58 <fax> I wish I could search hpaste :D
13:03:49 <Saizan> fax: ooh it would be nice
13:03:51 <abz> google site:hpaste.org map
13:03:56 <abz> >google site:hpaste.org map
13:04:03 <abz> !google site:hpaste.org map
13:04:06 <mbishop> @google site:hpaste.org map
13:04:08 <lambdabot> http://hpaste.org/700
13:04:08 <lambdabot> Title: ST with State+Data.Dynamic - hpaste
13:04:15 <abz> thanks
13:04:18 <mbishop> :P
13:04:20 <fax> bah google :/
13:05:12 <Saizan> fax: you could also write a patch :)
13:05:23 <Saizan> ?where hpaste
13:05:24 <lambdabot> http://hpaste.org/new
13:07:46 * sm considers switching from type to data all round
13:07:50 <kc5tja> @google site:hpaste.org show
13:07:53 <lambdabot> http://hpaste.org/696
13:07:53 <lambdabot> Title: Saizan: this is probably abusive, but hereyou go - hpaste
13:09:28 <Saizan> ?type fromMaybe
13:09:31 <lambdabot> forall a. a -> Maybe a -> a
13:10:19 <Saizan> typeable is evil.
13:10:27 <fax> hmmmm
13:10:28 <sorear> evil is fun.
13:10:30 <fax> My data types are going out of control
13:10:36 <fax> I have to do somthing like
13:10:43 <fax> (Var (Variable "x"))
13:11:05 <sorear> let q = Var . Variable
13:11:22 <fax> q "x" isnt much better :[
13:11:38 <hpaste>  fax pasted "Variable data definition" at http://hpaste.org/912
13:11:48 <fax> is somthing like that the only solution for my problem?
13:12:16 <sorear> fax: no
13:12:29 <fax> do I need to use type or somthing?
13:12:43 <Saizan> why dont' you just have Var String in Expr?
13:13:03 <fax> I used to but I want to use the same variable type elsewhere
13:13:06 <fax> in anoher data defintoin
13:13:16 <hpaste>  sorear annotated "Variable data definition" with "a better way, if you don't need inspection" at http://hpaste.org/912#a1
13:14:14 <fax> oh I see what you mean
13:14:56 <fax> is there not just a way so that I can use "Variable" instead of some other construct though?
13:15:55 <tuukkah> type Variable = String
13:16:01 <hpaste>  glguy annotated "roman" with "because I like the Prelude ;)" at http://hpaste.org/911#a1
13:16:27 <fax> tuukkah: ah! it was so simple.. thank you
13:17:07 <glguy> Cale: you about?
13:17:43 <fax> hm
13:17:45 <narain> :t find
13:17:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:17:54 <glguy> OOPS
13:18:03 <glguy> that's ( (n >= ) . fst )
13:18:13 <fax> that seems to work very nicley
13:19:44 <fax> so ghc doesnt like pattern matching on x :: Variable
13:19:50 <fax> :S
13:21:40 <tuukkah> well as it doesn't have a constructor you can't match on it
13:22:00 <fax> I really need to match on it though
13:22:06 <fax> hm
13:22:29 <sorear> \ (x :: Variable) -> foo bar
13:22:34 <sorear> or equivalently
13:22:39 <sorear> \ (x :: String) -> foo bar
13:22:45 <hpaste>  glguy annotated "roman" with "correction and further unecessary fun" at http://hpaste.org/911#a2
13:22:51 <sorear> or without ghc exts but still equivalently
13:22:55 <sorear> \x -> foo bar
13:23:06 <sorear> since a type synonym is just that, a synonym
13:23:17 <tuukkah> fax, what kind of situation are you thinking of?
13:23:33 <fax> I have somthing like eval values (Value x) = x
13:23:44 <fax> and before I had
13:23:47 <fax> eval values (Variable x) = values ! x
13:23:59 <fax> but now I have to use x alone in there.. and so I cant pattern match :S
13:24:29 <fax> is it ok to use ghc extentions?
13:24:52 <Saizan> it's ok, but why you can't pattern match?
13:25:03 <tuukkah> you'd need to have several constructors for a type for that to make sense. did you have some other in addition to Variable?
13:25:07 <fax> well i tried eval values (x :: Variable) ...
13:25:25 <fax> data Expr = Val Float | Variable | Add Expr Expr ...
13:25:26 <Saizan> what's the type of eval?
13:25:51 <fax> I suppose ill just have lots of constructors
13:25:54 <Saizan> you can't use Variable like that
13:26:02 <fax> yeah
13:26:05 <Saizan> you need a contructor in Expr
13:26:20 <fax> yaeh I will just use "Var" that should be ok
13:27:01 <hpaste>  Adam pasted "How do I do this in Haskell" at http://hpaste.org/913
13:29:43 <fax> data Variable = String
13:29:44 <araujo> morning
13:29:48 <fax> has some weird consequences
13:29:52 <fax> hi araujo
13:30:02 <araujo> hello fax
13:30:19 * fax growls at haskell
13:30:21 <araujo> what's up?
13:30:22 <encryptio> @src assert
13:30:22 <lambdabot> Source not found. That's something I cannot allow to happen.
13:30:24 <araujo> :-)
13:31:03 <fax> just getting confused about data types :D
13:31:21 <hpaste>  (anonymous) annotated "How do I do this in Haskell" with "(no title)" at http://hpaste.org/913#a1
13:32:39 <fax> ahh I needed type..
13:33:23 <hpaste>  Adam annotated "How do I do this in Haskell" with "(no title)" at http://hpaste.org/913#a2
13:33:43 <kc5tja> I have an algebraic type data CutNode = Test | BringUpNode ... | SetUpNode ...
13:33:56 <kc5tja> I'd like to toy with some functions in ghci, but I need to define show for this type.
13:34:18 <kc5tja> How do I do this?  Do I just define "show" out in the open, or do I need to make it an instance of a class, or ... ?
13:34:32 <kc5tja> I tried Googling, but a lot of noisy returns.
13:34:42 <jcreigh> kc5tja: why can't you do a "deriving (Show)"?
13:34:59 <kc5tja> Because it won't show the structure of the type when displayed.
13:35:23 <allbery_b> that sounds odd
13:35:28 <jcreigh> kc5tja: umm...what? I don't understand.
13:35:38 <allbery_b> but if you need a custom Show:  instance Show CutNode where show = ...
13:35:54 <kc5tja> How do you "show" a Test?
13:35:58 <kc5tja> Test has no parameters.
13:36:05 <glguy> Test
13:36:07 <glguy> like that
13:36:07 <allbery_b> right, so it says Test
13:36:09 <kc5tja> That's why I need a custom show.
13:36:16 <allbery_b> ?
13:36:27 <allbery_b> si Test a type?  then you need a constructor for it
13:36:36 <kc5tja> 13:34 < kc5tja> I have an algebraic type data CutNode = Test | BringUpNode ... | SetUpNode ...
13:36:45 <hpaste>  Adam annotated "How do I do this in Haskell" with "(no title)" at http://hpaste.org/913#a3
13:36:53 <kc5tja> Test is the constructor for it.
13:37:08 <narain> kc5tja: what do you want the output of  show  to be?
13:37:13 <allbery_b> kc5tja: as written, Test is a nullary constructor, its Show value and the only information it conveys is encapsulated by "Test"
13:37:17 <jcreigh> kc5tja: right. But it's a nullary constructor, so what data do you want to show?
13:37:27 <allbery_b> if Test is a value of type Test, then you need a data constructor
13:37:43 <allbery_b> data CutNode = CTest Test | ... deriving (Show)
13:37:51 <allbery_b> and now it will show CTest (your Test value)
13:38:19 <kc5tja> *CutParse> let z = parse ["hello","world"]
13:38:19 <kc5tja> *CutParse> z
13:38:19 <kc5tja> [<BringUpSuite "hello" []>,<BringUpSuite "world" []>]
13:39:18 <glguy> If I didn't know any better, I'd say that there were 3 different channels all being displayed to me a the same time
13:39:25 <glguy> and the each of those channels was isolated from the other
13:39:44 <sorear> @remeber glguy If I didn't know any better, I'd say that there were 3 different channels all being displayed to me a the same time
13:39:44 <lambdabot> Done.
13:39:46 * allbery_b still has no clue what kc5tja is getting at
13:39:54 <allbery_b> and is guessing wildly
13:40:12 <kc5tja> OK, so I really have to know how Haskell knows how to "show" my types when just "deriving" Show.
13:40:21 <allbery_b> (while watching Barca - Real)
13:40:37 <allbery_b> deriving for Show is defined in the haskell98 report
13:40:39 <sorear> kc5tja: http://haskell.org/onlinereport/derived.html
13:40:40 <lambdabot> Title: The Haskell 98 Report: Derived Instances
13:40:51 <kc5tja> So, Show is treated as a special case?
13:42:04 <sorear> yes
13:42:20 <kc5tja> ...
13:42:24 <kc5tja> That's the part I didn't know.
13:42:25 <sorear> Show, Eq, Ord, Enum, Ix, Bounded, Read -- all special cases
13:42:28 <kc5tja> That's why I didn't think it would work.
13:42:34 <kc5tja> :(
13:42:34 <allbery_b> anythingyou can "deriving" is a special case
13:42:45 <glguy> My fist is 11 fluid ounces
13:42:49 <allbery_b> (except newtype dericing, which is itself a special case, and a ghc extension)
13:42:58 <allbery_b> *deriving
13:43:01 <kc5tja> allbery_b: So you can't just "deriving" from any arbitrary type then.
13:43:07 <allbery_b> right
13:43:27 <kc5tja> hmmm  ...
13:43:35 <allbery_b> you can only "deriving" the types orear said (from the report) and Typeabe (extension)
13:43:47 <allbery_b> *sorear
13:43:52 <allbery_b> hard to type while watching the game
13:43:57 <sorear> and Data (also extension)
13:43:59 * allbery_b should back away from the keyboard :)
13:44:00 * kc5tja . o O ( Personally, I think that is a blemish on the otherwise kick-butt type system.  But, something tells me this system probably was introduced *before* type classes came about...)
13:44:45 <kc5tja> But, it will work for my needs.  Thanks for the clarification.
13:44:46 <allbery_b> it's a convenience.  you really want to have to manually derive Show?  or Eq?
13:44:48 <dylan> err, Show is a type class.
13:45:01 <kc5tja> allbery_b: Well, no, but it does make the semantics explicit.
13:45:08 <glguy> Read and Show are only intended to assist debugging
13:45:14 <glguy> not to show to users
13:45:41 <kc5tja> glguy: Right now, I am the user and the debugger.  ;)
13:45:53 <allbery_b> the semantics aren't hard.  as glguy says, Read and Show are mostly for debugging, and are no substitute for a real parser and printer; the others follow bascaly sane rules so why not?
13:46:22 <narain> only for debugging? is it bad if i'm using them to read and write files? (newbie question, if there's a better way i'd like to know about it)
13:46:29 <dylan> deriving with Typeable sounds useful
13:46:46 <kc5tja> So
13:47:13 <kc5tja> What is different about deriving versus making a type an instance (besides the manual method implementation; in other words, what's the black magic?)
13:47:23 <sorear> has Haskell 98 ever been implemented?
13:48:07 <dmwit> Makint it an instance is done by the manual method implementation...
13:48:20 <sorear> I expect the interaction between nested fixity declarations, where-blocks (declaration after use), and the parse-error clause of the layout rule will have particularly fun interations.
13:48:22 <dmwit> s/Makint/Making
13:48:57 * sorear is trying to implent a Haskell 98 parser ...
13:49:43 <allbery_b> kc5tja: no real difference, except that deriving always follows fixed rules; if you do it manually you can do things differently (whichyou might want for a custom Eq, say, but I wouldn't recommend it as it violates the Principle of Least Astonishment)
13:50:40 <kc5tja> allbery_b: Gotcha.
13:50:44 <allbery_b> I think the most common use of doing manual deriving of something you can do automatically is custom Show instances
13:50:57 <sorear> > do False == False == False  -- valid haskell 98!
13:50:57 <lambdabot>      precedence parsing error
13:50:58 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
13:51:06 * kc5tja goes to write a class where = equals not equals, and > is 3 if true and "HELLO" if false.  ;D
13:51:21 <allbery_b> (since Show is for debugging, you might want to highlight particular components)
13:51:25 <sorear> type error: no instance Num [Char]
13:51:45 <narain> instance Num [Char] where ...
13:52:13 <int-e> sorear: hmm, what does that mean?
13:52:15 <encryptio> @pl (\x (y,_) -> x == y)
13:52:15 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==)
13:52:18 <narain> :t >
13:52:20 <lambdabot> parse error on input `>'
13:52:23 <narain> :t (>)
13:52:24 <fuzan> sorear: they give boolean expressions left associativity?
13:52:25 <sorear> cannot match inferred Bool -> [Char] against expected a -> a -> Bool in definition of class method (>)
13:52:25 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:52:41 <sorear> fuzan, int-e: layout rule!
13:52:59 <sorear> do False == False == False  ==>  do { False == False } == False
13:53:06 <sorear> by the parse error clause
13:53:21 <fuzan> isn't that just left-associatitivity? :)
13:53:25 <sorear> which both hugs and ghci fail to implement
13:53:36 <allbery_b> I don't think anyone has implemented the brace rule as documented
13:53:45 <sorear> left assoc would be do (False == False) == False
13:53:45 <allbery_b> I'm not sure it's *implementable* as documented
13:53:46 <int-e> sorear: ok, it'll give a type error with the standard (==) though.
13:54:09 <sorear> > do {False == False} == False  -- type error, you say?
13:54:10 <lambdabot>  Couldn't match expected type `t t1' against inferred type `Bool'
13:54:38 <sorear> > (False == False) == False  -- OK, OK.  but Bool is Eq.
13:54:39 <lambdabot>  False
13:54:41 <allbery_b> fuzan:  there's a weirdie where (a) do, let, etc. insert braces automatically (b) the right brace s auto-inserted when otherwise there would be a parse error
13:55:44 <allbery_b> personally I'm hoping haskell' replaces it with something that can actually be implemented by a parser :)
13:55:45 <sorear> allbery_b: I could very easily implement h98 with a backtracking parser.  but the whole point of hv is faster-than-hugs
13:56:21 <petekaz> When using ByteStrings, is there any flag I can set to the compiler to turn all my literal strings into bytestrings?  My code looks so much uglier with B.pack throw in the mix.
13:57:11 <sorear> petekaz: get 6.7.200702xx, -foverloaded-strings, import Data.String, instance IsString ByteString where fromString = pack
13:57:47 <sorear> no such luck with pre-feb ghcs (that includes 6.6)
13:58:45 <petekaz> ok. thanks.
14:01:38 <Gwern> hey everyone. I'm looking at http://haskell.org/haskellwiki/Simple_unix_tools . Is there any way to have GHC compile it and generate separate binaries for each function entry? so compiling it would get you separate cat, sort', uniq etc binaries (as opposed to the straightforward but tedious way of copying stuff into a myriad of files with the right imports and main statements)?
14:01:39 <lambdabot> Title: Simple unix tools - HaskellWiki
14:02:41 <Botje> Gwern: you could take the busybox road and dispatch on the name of the binary
14:02:44 <hpaste>  qwr annotated "Ruby versus Haskell" with "Simpler MD5 of http get (but http part is still a bit complicated)" at http://hpaste.org/909#a1
14:02:47 <sorear> you could try for x in cat sort' uniq ; do ghc Main.hs --main-is=Main.$x -o $x ; done
14:03:05 <sorear> (that's bash code)
14:03:31 <allbery_b> except escaping the single quote :)
14:03:42 <allbery_b> and it's any sh-like
14:03:46 <Gwern> sorear: that's an interesting approach. is there no pure haskell method for doing it then?
14:03:48 <allbery_b> (as distinct from csh-likes)
14:04:13 <sorear> Gwern: well, 'ghc Main.hs' is sh, not haskell
14:04:36 <sorear> Gwern: there is no pure haskell way to compile any haskell program, without rewriting the compiler
14:05:00 <Gwern> maybe then I'll look at what botje said
14:05:02 <bd_> sorear: Isn't GHC import-able now? :)
14:05:18 <allbery_b> System.Environment.getProgName gets you the name by which the program is invoked; you could then use a big case statement to invoke the appropriate routine and link the executable to all the appropriate names
14:05:24 <Gwern> Botje: are you suggesting that I use some library function figure out what the binary is named and use cases to call the right function?
14:05:29 <xs> sorear, what about hsplugins?
14:05:30 <allbery_b> heck, that's the way unix used to handle cp/mv/rm/ln
14:05:37 <Gwern> ah, nm. allbery_b answered it :)
14:06:36 <sorear> bd_, xs: doesn't your program stop being pure haskell as soon as you import a non {Char, IO, Maybe, List, System, etc} module? :)
14:06:47 <bd_> heh, true
14:07:03 <bd_> unless the module can be implemented in pure haskell...
14:07:18 <yip> hm... what's a good way to get the current time inside STM monad?
14:08:06 <desp> I have a code layout style question
14:08:07 <bd_> yip: You can't do that. If you could, then each execution of the STM monad would be different - which would make retry unsafe.
14:08:13 <desp> how would you format this code?  http://pastie.textmate.org/46084
14:08:14 <lambdabot> Title: #46084 - Pastie
14:09:09 <desp> whoops, I left out two type declarations
14:09:11 <yip> bd_: so what's a good way to do it then? :)
14:09:18 <sorear> yip: the transaction needs to resume as soon as a variable changes, but the time changes constantly
14:09:26 <desp> try this: http://pastie.textmate.org/46085
14:09:27 <lambdabot> Title: #46085 - Pastie
14:09:28 <bd_> yip: Get the time before you enter the transaction :)
14:09:42 <kc5tja> Any ideas on why this code would not type-check?          parsed ("__CUT__":name:"(":s) cns = (Test name):cns
14:09:59 <sorear> yip: so you can discretize the time (with a threadDelay 1000000 ; atomically $ modifyTVar jiffies succ loop)
14:10:18 <sorear> yip: or if possible create a timer with Control.Concurrent.registerDelay
14:10:26 <sorear> @ty Control.Concurrent.registerDelay
14:10:28 <lambdabot> Not in scope: `Control.Concurrent.registerDelay'
14:10:33 <sorear> @ty Control.Concurrent.STM.registerDelay
14:10:33 <Botje>   Gwern pretty much
14:10:35 <lambdabot> Int -> IO (GHC.Conc.TVar Bool)
14:10:56 <sorear> note that for some utterly idiotic reason registerDelay only works with -threaded
14:11:38 <yip> there is a registerDelay???? i made my own implementation of that :O
14:11:44 <yip> where is it? i can't seem to find it
14:12:08 <sorear> @docs GHC.Conc
14:12:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html
14:12:20 <sorear> @docs Control.Concurrent.STM
14:12:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM.html
14:12:23 <sorear> it's in both!
14:12:36 <narain> i'm trying to write a simple recursive-descent parser and am getting tired of plumbing together all the  String -> (Result, String)  parse functions. is there a built-in monad that could help?
14:12:46 <sorear> but the docs are only in the GHC.Conc, because of minor haddock brokenness
14:12:51 <yip> oh, registerDelay is an IO action, my registerDelay works in STM
14:13:03 <sorear> narain: Control.Monad.State.State
14:13:18 <narain> @src Control.Monad.State.State
14:13:18 <lambdabot> Source not found. Are you on drugs?
14:13:30 <narain> @docs Control.Monad.State
14:13:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
14:13:42 <narain> sorear: thanks, i'll have a look
14:17:41 <narain> searching for keywords on hoogle leads to  http://www.haskell.org/hawiki/Keywords  which states that it is obsolete
14:17:43 <lambdabot> Title: Keywords - The Haskell Wiki
14:17:56 <narain> shouldn't it point to  http://haskell.org/haskellwiki/Type  instead?
14:17:57 <lambdabot> Title: Type - HaskellWiki
14:18:03 <narain> oops not that
14:18:15 <narain> http://haskell.org/haskellwiki/Keywords
14:18:16 <lambdabot> Title: Keywords - HaskellWiki
14:24:20 <narain> *crickets chirping*
14:25:52 <Herald> im trying to create a function that creates a list of sublists of length n from a list as input. Seemed quite simple at first but its driving me crazy
14:26:03 <Herald> could someone put me out of my misery ?
14:26:28 <narain> Herald: seems everybody runs into that at some point :)
14:26:30 <Herald> subLists :: int -> [a] -> [[a]]
14:26:35 <araujo> what kind of data yu want to receive as inpput and retuurn as output?
14:26:49 * araujo shoots his typing
14:26:54 <Herald> integers in the lists mainly
14:27:20 <narain> > let subLists n = takeWhile (not . null) . unfoldr (Just . splitAt n) in subLists 3 [1..10]
14:27:21 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
14:27:54 <narain> Herald: is this what you're looking for?
14:28:14 <Herald> yeah thanks a lot
14:28:17 <eulero> @src ($)
14:28:17 <lambdabot> f $ x = f x
14:28:20 <Herald> never seen those operators before though
14:28:38 * narain has seen this problem arise three times in the couple of weeks he's been on #haskell
14:28:40 <Herald> let ? Just ?
14:28:44 <sorear> > let subLists n = filter ((==n) . length) . filterM (\_->[False, True]) in subLists 3 [1..10]  -- so you do NOT want this?
14:28:46 <lambdabot>  [[8,9,10],[7,9,10],[7,8,10],[7,8,9],[6,9,10],[6,8,10],[6,8,9],[6,7,10],[6,7,...
14:28:50 <rahikkala> narain: More like, everyone runs into that in the first week :p
14:29:16 <narain> rahikkala: true, i did too
14:29:25 <int-e> Herald: I'd call it 'chunks'.
14:29:52 <narain> Herald: how about we start with what you had tried and see if we can make that work?
14:30:17 <narain> btw  let  allows you to make temporary definitions
14:30:35 <narain> Just  is a constructor of the  Maybe  monad
14:30:52 <narain> @src Maybe
14:30:52 <lambdabot> data Maybe a = Nothing | Just a
14:31:19 <Herald> ok, one second
14:31:54 <Herald> http://hpaste.org/914
14:31:59 <Herald> was trying to use recursion
14:32:06 <Herald> may be a bad way to go
14:32:41 <xerox> int-e: may I privmsg you?
14:32:43 <Herald> studying haskell at uni, the course hasnt got to monads yet so may not be a great idea to use it
14:32:53 <narain> let me guess, you were getting a type error involving the last  : [] ?
14:33:11 <int-e> xerox: yes
14:33:14 <Herald> no, type error
14:33:14 <narain> your function is perfect except you don't need that at the end
14:33:43 <Herald> type [a] does not match [[a]] because unification would give infinite type
14:34:19 <hpaste>  narain annotated "(no title)" with "this should work" at http://hpaste.org/914#a1
14:35:03 <Herald> nope - Cannot justify constraints in explicitly typed binding
14:35:26 <narain> hmm
14:35:47 <Herald> hugs98, btw
14:36:06 <narain> it works for me
14:36:15 <Herald> strange
14:36:42 <yip> (a `orElse` b) `orElse` c      is that the same as:       a `orElse` (b `orElse` c)
14:36:51 <narain> wait, try removing the type
14:37:15 <kc5tja> yip: Yes.
14:37:48 <yip> kc5tja: cool thanks. retry >> a     is that the same as retry?
14:38:08 <kc5tja> I don't know retry
14:38:17 <Herald> type ?
14:38:18 <hpaste>  narain annotated "(no title)" with "try this" at http://hpaste.org/914#a2
14:38:20 <sorear> yes it is
14:38:26 <sorear> by the mzero law
14:38:47 <narain> i meant the  getRows :: Int -> [a] -> [[a]]  but what i pasted is better
14:38:59 <Herald> that works!
14:39:01 <Herald> fantastic
14:39:05 <Herald> why didnt it work with the guards?
14:39:14 <narain> when you used  list == []  it expected  a  to be an  Eq
14:39:45 <narain> you can only compare two lists for equality if you can compare their contents
14:40:05 <Herald> i see
14:40:06 <narain> if you had used  not (null list)  it would have worked also
14:40:32 <narain> but pattern matching is more idiomatic
14:40:57 <narain> (i mean  null list  not  not (null list)  of course)
14:41:29 <narain> :t \list -> list == []
14:41:31 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
14:41:35 <narain> :t \list -> null list
14:41:38 <lambdabot> forall a. [a] -> Bool
14:42:07 <Herald> thanks
14:44:41 <narain> so... anyone around who knows how hoogle works?
14:45:05 <jcreigh> umm...you search for a type or name?
14:45:19 <narain> not that :p
14:45:36 <narain> i meant anyone who maintains hoogle
14:45:41 <sorear> ndm
14:45:46 <sorear> @seen ndm
14:45:46 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 5h 12s ago, and .
14:46:16 <narain> i noticed something about hoogle that seems like it should be fixed
14:46:22 <narain> searching for keywords on hoogle leads to  http://www.haskell.org/hawiki/Keywords  which states that it is obsolete...
14:46:23 <lambdabot> Title: Keywords - The Haskell Wiki
14:46:31 <encryptio> http://www.haskell.org/haskellwiki/Hoogle/Bugs
14:46:32 <lambdabot> Title: Hoogle/Bugs - HaskellWiki
14:46:39 <narain> ah
14:55:48 <fax> > let l = [1, 1, map (+1) tail l] in l
14:55:49 <lambdabot>  Couldn't match expected type `[a]'
14:57:00 <fax> > let l = [1, 1] :: map (+1) tail l in l
14:57:00 <lambdabot>  Parse error
14:57:46 <rahikkala> > let l = 1 : 1 : map (+1) (tail l) in take 20 l
14:57:47 <lambdabot>  [1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
14:58:19 <fax> > let l = [1..] in zipWith (+) l 0:0:l
14:58:21 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
14:58:21 <lambdabot>       Expected...
14:58:52 <fax> > let l = [1..] in zipWith (+) l 0:0:l in l
14:58:53 <lambdabot>  Parse error
14:58:59 <fax> :"/
14:59:27 <fax> > let l = 1:1:map(
14:59:27 <lambdabot>  Parse error
14:59:55 <narain> > let l = [1..] in zipWith (+) l (0:0:l) -- fax
14:59:56 <lambdabot>  [1,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
15:00:03 <fax> :o
15:00:11 <narain> operator precedence :)
15:00:30 <narain> 0:0:l  vs  (0:0:l)
15:00:42 <fax> > let l = (repeat 1) in zipWith (+) l (0:0:l)
15:00:43 <lambdabot>  [1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
15:01:06 <fax> > let l = (repeat 1) in let m = zipWith (+) l (0:0:l) in zipWith (+) m (0:0:m)
15:01:08 <lambdabot>  [1,1,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
15:01:16 <fax> > let l = (repeat 1) in let m = zipWith (+) l (0:0:l) in zipWith (+) m (0:0:0:0:m)
15:01:18 <lambdabot>  [1,1,2,2,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
15:01:27 <encryptio> > let l = [1, 1, map (+1) (tail l)] in l
15:01:28 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
15:01:28 <lambdabot>       Expected...
15:01:31 <fax> how do you extend it?
15:01:39 <encryptio> > let l = [1, 1] ++ map (+1) (tail l) in l
15:01:41 <lambdabot>  [1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
15:01:58 <encryptio> > let l = [1, 1] ++ map (+1) l in l
15:02:00 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
15:02:04 <fax> :O
15:02:07 <fax> cool
15:02:14 <encryptio> or
15:02:15 <narain> > let l = 0 : (tail l) in l
15:02:16 <lambdabot>  Exception: <<loop>>
15:02:18 <narain> heh
15:02:30 <encryptio> > concatMap (\x -> [x,x]) [1..]
15:02:32 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
15:02:52 <fax> > let l = [1, 1] ++ zipWith l (tail l) in l
15:02:53 <lambdabot>  Couldn't match expected type `[a]'
15:02:59 <fax> > let l = [1, 1] ++ zipWith (+) l (tail l) in l
15:03:01 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:03:14 <narain> that looks about right
15:03:41 <narain> i prefer fibs to start with [0,1,...] but that's just me :)
15:03:54 <fax> > let l = [1, 2] ++ zipWith (*) l (tail l) in l
15:03:56 <lambdabot>  [1,2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,618970019642690...
15:03:58 <int-e> > fix ((1:) . scanl (+) 1)
15:03:59 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:04:05 <fax> scanl?!
15:04:21 <int-e> @src scanl
15:04:21 <lambdabot> scanl f q ls = q : case ls of
15:04:21 <lambdabot>     []   -> []
15:04:21 <lambdabot>     x:xs -> scanl f (f q x) xs
15:04:38 <narain> > iterate ((1:) . scanl (+) 1) [42]
15:04:40 <lambdabot>  [[42],[1,1,43],[1,1,2,3,46],[1,1,2,3,5,8,54],[1,1,2,3,5,8,13,21,75],[1,1,2,3...
15:04:50 <narain> all hail  fix
15:05:11 <fax> > reverse [1..]
15:05:15 <lambdabot> Terminated
15:05:18 <fax> :(
15:05:40 <narain> were you expecting maybe [inf, inf-1, inf-2,...]?
15:05:46 <fax> no
15:06:17 <kc5tja> Does Haskell have any regular expression library/-ies available?
15:06:23 <sorear> Text.Regex
15:06:27 <sorear> @docs Text.Regex
15:06:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
15:06:30 <kc5tja> sorear: Cool, thanks.
15:07:48 <rahikkala> > reverse [((maxBound :: Int) - 10) ..]
15:07:50 <lambdabot>  [2147483647,2147483646,2147483645,2147483644,2147483643,2147483642,214748364...
15:08:15 <narain> > reverse [((maxBound :: Int) - 4) ..]
15:08:16 <lambdabot>  [2147483647,2147483646,2147483645,2147483644,2147483643]
15:08:23 <narain> wow, it stops?
15:08:36 <narain> i was hoping for it to wrap around
15:08:52 <narain> haskell++
15:09:04 <rahikkala> > succ (maxBound :: Int)
15:09:05 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
15:09:19 <narain> :t maxBound
15:09:21 <lambdabot> forall a. (Bounded a) => a
15:09:36 <qwr> Herald: List is also monad, so you'll have hard time without monads :P
15:09:39 <narain> @src enumFrom
15:09:40 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:09:52 <narain> @src succ
15:09:52 <lambdabot> Source not found. My pet ferret can type better than you!
15:11:47 <fax> Rugh
15:11:57 <fax> how do you have motivation to code?
15:12:22 <fax> like on the occosional moments when you dont bother
15:13:14 <sorear> narain:
15:13:28 <sorear> > reverse [0..] :: [Word16]
15:13:30 <lambdabot>  [65535,65534,65533,65532,65531,65530,65529,65528,65527,65526,65525,65524,655...
15:14:16 <sorear> it would work with Int too, but I doubt you have 80GB ram :)
15:14:23 <narain> ah, so Integer is unbounded but Int, Word16 etc are
15:14:26 <narain> i see
15:14:30 <fax> > reverse [0..] :: [Int]
15:14:34 <lambdabot> Terminated
15:14:35 <narain> > last [0..] :: [Int]
15:14:36 <lambdabot>   add an instance declaration for (Num [Int])
15:14:36 <lambdabot>     In the expression: 0
15:14:41 <narain> > last [0..] :: Int
15:14:45 <lambdabot> Terminated
15:15:02 <sorear> last [0..] will run in bounded space
15:15:21 <sorear> it's just lb isn't fast enough to go through all two billion in three seconds
15:15:23 <narain> but terminated because of timeout?
15:15:27 <narain> right
15:15:37 <fax> > let r l1 l2 = (head l1) : (head l2) : (r (tail l1) (tail l2)) in r [0..] [0..]
15:15:38 <lambdabot>  [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15...
15:15:49 <rahikkala> > last [0..] :: Word16
15:15:50 <lambdabot>  65535
15:16:09 <fax> > let r l1 l2 = (head l1) : (head l2) : (r (tail l2) (tail l1)) in r [0..] [1..]
15:16:10 <int-e> sorear: nope, default type is Integer, not Int
15:16:10 <lambdabot>  [0,1,2,1,2,3,4,3,4,5,6,5,6,7,8,7,8,9,10,9,10,11,12,11,12,13,14,13,14,15,16,1...
15:16:18 <lispy> dons: total weirdness...i just noticed my lambdabot was not responding so i killed it and now when i try to start a new instance it says, "Initialising plugins ..................................." and then exits
15:16:25 <alcojol> > [1..]
15:16:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:16:27 <fax> :D
15:16:37 <sorear> lispy: that's a known issue.  rm State/*
15:16:54 <narain> int-e: sorear was speaking in the context of my  last [0..] :: Int
15:16:58 <sorear> lispy: lambdabot corrupts state files, then dies with parse errors
15:17:10 <fax> > let r l1 l2 = (head l1) : (head l2) : (r (tail l2) (tail l1)) in r "hello" "world"
15:17:11 <lambdabot>  Exception: Prelude.head: empty list
15:17:16 <int-e> narain: ah
15:17:34 <fax> > let r l1 l2 = (head l1) : (head l2) : (r (tail l2) (tail l1)) in drop 10 r "hello" "world"
15:17:35 <lambdabot>  Couldn't match expected type `[a]'
15:17:44 <lispy> sorear: oh, lame
15:17:47 <fax> > let r l1 l2 = (head l1) : (head l2) : (r (tail l2) (tail l1)) in drop 10 $ r "hello" "world"
15:17:48 <lambdabot>  Exception: Prelude.head: empty list
15:17:49 <lispy> sorear: thanks
15:17:51 <fax> :(
15:18:11 <narain> > let r = concat . zipWith (\x y -> [x, y]) in r "jello" "world"
15:18:12 <lambdabot>  Couldn't match expected type `[[a]]'
15:18:29 <fax> > let r l1 l2 = (head l1) : (head l2) : (r (tail l2) (tail l1)) in r ("hello" ++ repeat 'O') ("world" ++ repeat 'X')
15:18:30 <lambdabot>  "hwoelrllodXOOXXOOXXOOXXOOXXOOXXOOXXOOXXOOXXOOXXOOXXOOXXOOXXOOXXOOXXOOXXOOXX...
15:18:43 <lispy> sorear: yup, that fixed it
15:18:54 <narain> > let r l1 l2 = concat $ zipWith (\x y -> [x, y]) l1 l2 in r "jello" "world"
15:18:55 <lambdabot>  "jweolrllod"
15:19:12 <int-e> > inits "hello" >>= init . tails
15:19:13 <lambdabot>  ["h","he","e","hel","el","l","hell","ell","ll","l","hello","ello","llo","lo"...
15:19:35 <fax> > inits "abcaf"
15:19:36 <lambdabot>  ["","a","ab","abc","abca","abcaf"]
15:19:48 <narain> > inits "hello" >>= tails
15:19:50 <lambdabot>  ["","h","","he","e","","hel","el","l","","hell","ell","ll","l","","hello","e...
15:20:16 <fax> > init . init . inits [1..]
15:20:17 <lambdabot>  Couldn't match expected type `a -> [a1]'
15:20:30 <fax> > map inits $ inits [1..]
15:20:32 <lambdabot>  [[[]],[[],[1]],[[],[1],[1,2]],[[],[1],[1,2],[1,2,3]],[[],[1],[1,2],[1,2,3],[...
15:20:38 <lispy> > head . head . inits [1..]
15:20:39 <lambdabot>  Couldn't match expected type `a -> [a1]'
15:21:02 <emu> try a $
15:21:13 <fax> > map tails $ inits [1..]
15:21:15 <lambdabot>  [[[]],[[1],[]],[[1,2],[2],[]],[[1,2,3],[2,3],[3],[]],[[1,2,3,4],[2,3,4],[3,4...
15:21:17 <narain> how do i import a builtin module in ghci?
15:21:28 <int-e> narain: :m +Module
15:21:39 <fax> > map tails $ inits $ repeat []
15:21:40 <lambdabot>  [[[]],[[[]],[]],[[[],[]],[[]],[]],[[[],[],[]],[[],[]],[[]],[]],[[[],[],[],[]...
15:22:02 <narain> ah, the + *adds* rather than replaces?
15:22:08 <TSC> Yeah
15:22:14 <fax> ow do you print the level of each []?
15:23:35 <narain> int-e,TSC: there also appears to be a *<module> option, what does the * do?
15:24:13 <narain> as in :m [+/-] [*]<module>
15:24:29 <narain> (i'd never noticed the [+/-] in ghci's help before)
15:26:34 <TSC> Seems like the * does something to do with interpreted/compiled modules
15:26:51 <sorear> narain: * means you can use non-exported symbols
15:27:19 <narain> ah. thanks all
15:27:36 <int-e> ah, but only if the module is not compiled. hmm.
15:28:40 <sorear> yeah, ghc faces tradeoff: allow use of private symbols, or use optimized code?
15:28:58 <sorear> since the optimizer eliminates private symbols (inlining etc)
15:30:27 <int-e> sorear: I'd like to be able to force it to load the source code (interpreted), sometimes.
15:30:39 <int-e> sorear: the only way I've found is to 'touch' the source code.
15:30:51 <int-e> (or delete the compiled objects. touching is faster)
15:31:42 <fax> @doc Parsec
15:31:43 <lambdabot> Parsec not available
15:31:49 <fax> :[
15:32:00 <narain> i'm trying to understand the State monad... as far as i could understand, State actually represents a state *transition* rather than a fixed state?
15:32:10 <sorear> you can force interpretation with :set -fforce-recomp
15:32:38 <TSC> narain: Yes, a computation that uses some state
15:32:52 * sorear checks logs to find out how much he lagged
15:33:19 <sorear> hm, clog shows the same thing I see
15:34:09 <narain> TSC: so i define my computation  s -> (a, s)  as a  State ?
15:34:33 <xerox> ?unmtl State s a
15:34:34 <lambdabot> s -> (a, s)
15:34:49 <narain> ?help unmtl
15:34:50 <lambdabot> unroll mtl monads
15:34:57 <emu> you have your state s, and whatever else as a being carried along
15:36:50 <Cale> ?unmtl ContT r (StateT s (WriterT Rational [])) a
15:36:50 <lambdabot> (a -> s -> [(r, s, Rational)]) -> s -> [(r, s, Rational)]
15:37:08 <emu> fun
15:37:20 <TSC> If your function is f :: s -> (a,s), then you can have a State object "State f"
15:37:27 <Cale> and slightly incorrect -- it joined the nested pairs.
15:37:41 <narain> i was planning to just write my computations as  s -> (a, s)  and hope i could use some monadic operator like  (>>=)  or something to do the plumbing
15:37:48 <narain> would that work?
15:38:01 <narain> if i threw in  State f  instead of  f  at the right places
15:38:05 <Cale> narain: That's exactly what the State monad is.
15:38:08 <Cale> yes
15:38:09 <sorear> with GHC extensions and goat's blood, yes
15:38:20 <Cale> hm?
15:38:27 <narain> sorear: you're scaring me
15:38:32 <Cale> You just work in the State monad, which is certainly H98
15:38:40 <sorear> oh, if you're willing to throw in State calls the goat's blood and extensions can be omitted
15:38:54 <narain> ah. phew
15:39:16 <narain> :t IO
15:39:18 <lambdabot> Not in scope: data constructor `IO'
15:39:24 <narain> @src IO
15:39:24 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:39:30 <narain> ah, newtype
15:39:40 <emu> oh no you've uncovered the secrets of IO
15:39:59 <jcreigh> you must not be allowed to live
15:40:08 <narain> heh. i was just trying to correlate this with the IO inside article
15:40:12 <narain> egads, jcreigh
15:40:16 <jcreigh> :)
15:40:17 <int-e>  @src should just refuse to work if the output contains # ;-)
15:41:15 <MonogamicCALL> hi
15:41:18 <sorear> hi.
15:41:35 <sorear> @src unsafePerformIO
15:41:35 <sorear> ^^ my favorite
15:41:36 <narain> @undo do {a <- get; modify (+1); return a}
15:41:36 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
15:41:36 <lambdabot> get >>= \ a -> modify (+ 1) >> return a
15:42:53 <TSC> @pl get >>= \ a -> modify (+ 1) >> return a
15:42:54 <lambdabot> (modify (1 +) >>) . return =<< get
15:42:59 <TSC> That's more like it
15:43:24 <narain> just to make sure i understand correctly, is this the same as  State (\s -> (s+1, s)) ?
15:43:39 <narain> or vice versa(?)
15:43:47 <int-e> sorear: it's  unsafePerformIO m = unsafeDupablePerformIO (noDuplicate >> m)  in HEAD :)
15:44:23 <TSC> narain: Yeah, modifies the state and returns the previous state
15:44:29 <TSC> Like "x++" in C (:
15:44:42 <narain> TSC: hey, i didn't notice that :D
15:45:01 <narain> feels like it's a lot clearer as  State (\s -> ...) , no?
15:45:32 <TSC> In that case, it seems so
15:45:58 <narain> i assume in more complex computations the monadic notation helps?
15:46:17 <TSC> I think so
15:46:58 <narain> but i can't help thinking of stateful computations as a lambda on the state, it just makes so much sense
15:47:08 <narain> oh well
15:47:13 <TSC> Then think of it that way
15:47:49 <desp> hi, can someone tell me how should I format my Haskell code?
15:48:09 <TSC> http://www.haskell.org/haskellwiki/Programming_guidelines  might help
15:48:09 <desp> here's a very small file that I'm not sure how to format: http://pastie.textmate.org/46085
15:48:10 <lambdabot> Title: Programming guidelines - HaskellWiki
15:48:11 <lambdabot> Title: #46085 - Pastie
15:48:24 <desp> TSC: thanks
15:49:01 <narain> TSC: yeah, i'm trying to silence the urge to yell that the do-notation is useless here... shouldn't criticize things i haven't used :)
15:50:09 <TSC> It is arguably useless there (:
15:50:23 <sorear> desp: btw, this channel has a language-specific pastebin
15:50:49 <sorear> it's even announced in the topic (but you probably can't see it)
15:50:50 <desp> sorear: is there a problem with using another pastebin that supports Haskel language highlighting?
15:50:57 <desp> Haskell*
15:51:27 <sorear> desp: not really; hpaste announces for you (and has diffs)
15:51:47 <desp> I see; on the other hand, TextMate pasties with a single keystroke :)
15:51:49 <sorear> also I've got a shell script so I can just l h 900
15:52:15 <fuzan> hmm, gtk2hs can't support multiple keypress callbacks simaultenously? i'm not even sure if gtk can do this?
15:52:20 <sorear> a single keystroke?
15:52:32 <sorear> didn't seem like such a common command
15:52:35 <sorear> which key?
15:52:42 <desp> yes, shift-option-control-v ;)
15:52:59 * sorear has been tempted to write M-x hpaste-buffer for emacs
15:53:14 <fuzan> that would be pretty clever :)
15:53:48 <desp> ah, so there *is* a preference for using auxiliary top level functions over nesting where
15:54:14 <desp> I thought so, but I don't know yet how to keep them from exporting
15:54:46 <sorear> module MyModule(export1, export2, export3) where
15:54:57 <sorear> note that export lists must be positive
15:54:57 <desp> ah, thank you.
15:56:22 <desp> is there a convention for naming aux functions?
15:56:27 <narain> :t \(x :: State Int String) y -> x >>= y
15:56:30 <lambdabot> forall b. State Int String -> (String -> State Int b) -> State Int b
15:56:45 <sorear> desp: foo'
15:56:54 <sorear> where foo is your main function
15:57:05 <narain> this looks like a win
15:58:22 <fuzan> is there a gtk2hs channel?
15:58:52 <sorear> not afaik
15:59:54 <fuzan> kk, well. i'll try another day!
16:00:17 <fuzan> cannot seem to figure out how to get gtk to handle multiple concurrent keydowns  :(
16:00:34 <sorear> @seen dcoutts_
16:00:35 <lambdabot> dcoutts_ is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I last heard dcoutts_ speak 1d 3h 51m 45s ago.
16:00:37 <sorear> @seen dcoutts
16:00:37 <lambdabot> dcoutts is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I last heard dcoutts speak 7h 11m 21s ago.
16:00:46 <fuzan> and i need to pop some heads to releive some stress. CStime!
16:02:35 <narain> :t return
16:02:37 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
16:03:07 <narain> :t \x -> (return x) :: State Int String
16:03:09 <lambdabot> State Int String :: String -> State Int String
16:03:28 <narain> :t \x -> (return x :: State Int String)
16:03:31 <lambdabot> String -> State Int String
16:08:08 <emk> OK, I just polished up the error-handling half of my earlier rant into a Haskell error tutorial: http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
16:08:10 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
16:08:42 <emk> I figure this is a slightly more productive way to vent. :-)
16:09:55 <dons> moin
16:11:37 <sorear> hi!
16:11:54 <dons> the http package sucks, btw emk. I guess you've noticed that.
16:12:03 <dons> it started out as 'MiniHTTP', a quick hack  that got abandoned.
16:12:14 <dons> then it grew a few modules
16:12:26 <dons> we need a NewHTTP, from scratch, with a modern api
16:12:39 <sorear> I seem to have caught the masochistic code bug ... I'm writing a haskell frontend.  In C.  (I want a ultra-fast haskell validator)
16:12:43 <emk> dons: And if it used ByteString, that would be amazingly sweet.
16:12:47 <dons> right.
16:12:50 <dons> ?where haskellnet
16:12:50 <lambdabot> http://darcs.haskell.org/SoC/haskellnet/
16:13:01 <dons> isn't quite up to it, but it at least supports a both strings and bytestrings
16:13:05 <dons> and a few other things
16:13:19 <jcreigh> how do I actually use a cabal-installed package after I install somewhere in my homedir? (As opposed to a global, root install)
16:13:47 <sorear> ./Setup.lhs configure --prefix=/home/jason
16:13:47 <sorear> ./Setup.lhs build
16:13:47 <sorear> ./Setup.lhs install --user
16:13:53 <sorear> both options are needed
16:13:53 <narain> to no one in particular: the state monad rocks!
16:13:59 <narain> ok, had to get that out of my system :)
16:14:09 <emk> dons: Were you around for my rant earlier?
16:14:12 <glguy> ?get-shapr
16:14:12 <lambdabot> shapr!!
16:14:15 <dons> emk, so regarding the 8 error ways (just read it)
16:14:23 <dons> hmm, not all are used, by a long shot
16:14:52 <dons> you'll see: error/Maybe/Either in small code
16:15:01 <nominolo> dons: wouldn't rewriting http be a nice SoC-project?
16:15:01 <emk> dons: The core libraries are pretty good about sticking to 3, 5 and 6.
16:15:03 <dons> and larger code might instead use ErrorT
16:15:07 <dons> nominolo: indeed it would
16:15:28 <dons> emk, yeah, though throwDyn is a bit icky
16:15:32 <nominolo> this is also was bringert suggested, but i didn't quite know the details
16:15:54 <emk> dons: But I've definitely seen things like 'parseURI :: String -> Maybe URI',
16:16:01 <dons> yeah.
16:16:02 <jcreigh> sorear: okay, now I get "Could not find module"...how do I tell GHC where to look?
16:16:09 <jcreigh> (maybe I'm just being really dense)
16:16:26 <nominolo> dons: so could you name some ideas what you have in mind
16:16:28 <emk> which _really_ should be 'parseURI :: (Monad m) => String -> m URI' for the sake of people working in any monad but Maybe.
16:16:42 <nominolo> (or will you actually fix it yourself before summer? ;)
16:17:09 <dons> emk, yes. so basically the coding styles that have become preferred have developed at different times, and old code hasn't been generalised
16:17:21 <matthew-_> any haskelldb folk around?
16:17:28 <sorear> jcreigh: I hereby force your ...
16:17:33 <dons> emk, *but* it would be pretty easy to identify hard-coded Maybes and replace them with Monad m's via the libraries patch process
16:17:37 <jcreigh> hmm, wait, hold a sec...
16:18:12 <dons> emk, btw, a nice functional pearl, getting a http_proxy env var (all functions happen to use Maybe):
16:18:15 <dons> getProxy = handle (\_ -> return Nothing) $ do
16:18:18 <dons>     env <- M.fromList `fmap` getEnvironment
16:18:20 <dons>     return $! do
16:18:23 <dons>         s <- M.lookup "http_proxy" env
16:18:26 <dons>         a <- parseURI s
16:18:28 <dons>         v <- uriAuthority a
16:18:30 <dons> I was so happy when I was able to string them all together like that.
16:18:43 <dons> so yes, a plea for consistent error handling!
16:18:59 <emk> dons: I agree that most of these problems could be fixed. It's just that I wasted half a day translating a 3-line Ruby program to Haskell, when I could have been writing about probability monads.
16:19:20 <emk> (or skiing)
16:19:20 <dons> the http lib is rather weak. i'm not surprised actually.
16:19:36 <dons> system . ("wget "++) is usually cheaper
16:19:59 <dons> actually, an ffi binding to curl might be a cheap way to get a reasonable interface
16:20:08 <emk> dons: And I wanted to stick a flag in the ground and take a stand for nice, cuspy APIs that don't waste programmer time.
16:20:23 <PseudoCapitana> hi i need an interface for Informix
16:20:26 <dons> yeah. http is an accident. and it looks like one.
16:20:28 <emk> dons: Actually, that's a good idea. Curl is pretty mature and we've been very happy with it as work.
16:20:30 <sorear> @where ffi
16:20:31 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
16:20:42 <sorear> @where hdirect
16:20:42 <dons> emk, ah ok. that's useful to know
16:20:43 <lambdabot> http://haskell.org/hdirect/
16:20:59 <dons> sorear: i think hsc2hs or c2hs would be preferred?
16:21:02 <dons> does anyone use hdirect?
16:21:21 <emk> dons: But really, any time there's N ways to solve a problem, you need O(N^2) glue functions to translate.
16:21:23 <sorear> "Informix" sounds like a windows product name
16:21:39 <sorear> (something tells me it's a database, beyond that, no clue)
16:21:46 <dons> emk, right, I'm thinking we should do an audit of error handling in the core and extra lib bundle
16:21:58 <PseudoCapitana> well its an AIX installation actually
16:22:02 <sorear> emk: O(2N).  with a realllly crufy star center
16:22:03 <dons> to identify any odd-man-out error handling we could ditch
16:22:26 <sorear> PseudoCapitana: what kind of api does it have?
16:22:43 <jcreigh> sorear: I was being dense...spelled the module name wrong in the file I where I was trying to "import" it. :) Thanks for your help.
16:22:44 <sorear> PseudoCapitana: C-callable functions?  socket?  system("..")? other?
16:23:02 <PseudoCapitana> C C++
16:23:08 <emk> sorear: Well, even then we need to distinguish between the IO and non-IO error reporting methods. But, yeah, O(2N) with lots of evil grik will work.
16:23:26 <dons> PseudoCapitana: there's no existing binding. you'd have to write your own using the fFI.
16:23:27 <sorear> PseudoCapitana: there's an existing binding to ODBC ... good enough?
16:23:32 <sorear> @where hdbc
16:23:32 <lambdabot> http://quux.org/devel/hdbc
16:24:01 <emk> dons: Yeah, keeping an eye on this as libraries get standardized would be definitely be a Good Thing<tm>.
16:24:04 <sorear> ffi isn't too painful, but existing libs are easier
16:25:00 <matthew-_> dons: hs-plugins works with ghc6.6 right?
16:25:03 <dons> emk, i'm going to drop your article by the libraries@ list
16:25:13 <emk> dons: And thanks for the recognition that the HTTP library needs major work. I'm glad it's not just me! :-)
16:25:17 <dons> matthew-_: roughly. it doesn't support running code depending on multiple packages, iirc
16:25:20 <emk> dons: Go for it.
16:25:35 <dons> emk, its truly embarassing, the http lib. i'm sorry it is what it is.
16:25:37 <sorear> matthew-_: I also recall failure on 64bit machines
16:25:49 <dons> I may personally write this curl lib though. that seems simple enough
16:25:53 <emk> Hey, we live and learn.
16:25:57 <matthew-_> sorear: ahh. well that's why I've made no progress in the last 6 hours then
16:25:59 <dons> starting with the darcs binding
16:26:24 <matthew-_> any chance it could be made to work on amd64?
16:26:35 <dons> it works on 64 bit machines
16:26:40 <emk> dons: There's a bunch of callback stuff you just need to wade through, but once you do, curl is _way_ better than the evil libwww from the W3C.
16:26:41 <dons> sorear: remember amd64bot?
16:26:52 <sorear> dons: er, yea :)
16:26:55 <Blackfoot> in hopengl, is there a predefined method for GLmatrix * Vector3 ? I've looked all over the docs and can't seem to find one
16:26:55 <sorear> now
16:27:07 <matthew-_> ok. so does the multiple packages bit rule out DBDirect?
16:28:50 <matthew-_> I've tried haskelldb with both hsql and hdbc and can get dbdirect to work with neither, so I'm thinking it's an issue with dbdirect which in turn suggests the dynamic driver in haskelldb
16:30:08 <matthew-_> I get error messages like Couldn't load Database.HaskellDB.HSQL.PostgreSQL.driver from package haskelldb-hsql-postgresql-0.10
16:30:16 <matthew-_> which don't show up on google, which is most odd
16:34:12 <matthew-_> in fact, the line that fails is     res <- loadPackageFunction p m "driver"
16:34:30 <matthew-_> which wraps loadPackage which comes from hs-plugins
16:35:46 <dons> yeah, i'm pretty sure we don't support multiple packages in 6.6 yet
16:36:01 <dons> the package format changed, we haven't caught up yet.
16:36:15 <matthew-_> ok, I'm sorry, but I don't know what that means. What is a package?
16:37:29 <matthew-_> oh, ok, this is an hs-plugins terminology?
16:37:58 <dons> package as in ghc library pcakage
16:38:02 <matthew-_> right
16:38:06 <dons> like the haskelldb package
16:38:16 <dons> i think they're still broken with ghc 6.6
16:38:33 <matthew-_> right
16:38:58 <matthew-_> any sort of time frame for supporting them again?
16:39:39 <dons> I'll talk to Lemmih (he did the 6.6 port)
16:39:52 <dons> since people are asking, "soonish".
16:40:04 <matthew-_> it's the following line that fails: loadFunction_ (encode moduleName) functionName
16:40:21 <matthew-_> loadPackge and resolveObjs seem to be ok
16:40:34 <dons> the failure is expected though.
16:40:39 <matthew-_> though I'm sure it can be much more complex than that...
16:40:40 <matthew-_> sure
16:41:26 <hpaste>  Marc Weber pasted "WASH attribute problem. Whats happening here?" at http://hpaste.org/915
16:41:44 <matthew-_> I'm not sure why dbdirect is trying to load multiple packages though - or is this a transitive thing?
16:42:04 <matthew-_> I'm telling it to load the HSQL.PostgreSQL module, for example, and nothing els
16:42:05 <matthew-_> e
16:43:00 <MarcWebe1> Did you see my paste question? Irssi got disconnected somehow
16:43:02 <dons> it looks at the package.conf deps for the module, and pulls in anything needed
16:43:44 <matthew-_> dons, right, that makes sense. so if the dependencies are already loaded it should be ok right?
16:45:05 <dons> sjanssen: btw, i'd like to write about xmonad for the upcoming TMR (with you too)
16:45:08 <dons> what do you think?
16:45:28 <sorear> yay, I have a proper h98 lexer
16:45:31 <sorear> lex++
16:45:32 <jcreigh> TMR?
16:45:33 <MarcWebe1> ?where xmonad
16:45:33 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
16:45:39 <sorear> the monad reader
16:45:55 <mr_tenor> is that thing still being published?
16:45:56 <dons> ?where TMR
16:45:56 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
16:46:01 <dons> matthew-_: indeed
16:46:06 <dons> sorry, mr_tenor , indeed
16:46:07 <fax> yay :D
16:46:24 <mr_tenor> coolies :)
16:47:36 <MarcWebe1> Can somenone help me understanding this simple compilation issue ? http://hpaste.org/915
16:54:20 <kc5tja> You know, I think Haskell code would be more convenient to write if it were purely right-associative.
16:54:55 <Cale> kc5tja: you mean function application?
16:55:10 <Cale> like, f x y = f (x y)
16:55:10 <Cale> ?
16:55:51 <mr_tenor> how does that fit with currying?
16:56:21 <kc5tja> Cale: Yeah; I'm a bit spoiled by J.  :)
16:56:42 <kc5tja> mr_tenor: I don't know.  How does it?
16:56:43 <Cale> It'd be a bit annoying to work with multiparameter functions.
16:57:29 <kc5tja> Well, I'm not having much luck with currying now, as it is.  :(
16:57:36 <kc5tja> maybeMatch   = maybeHead . matchRegex
16:57:36 <kc5tja> -- testName     = maybeMatch testRegEx
16:57:36 <kc5tja> -- bringupName  = maybeMatch bringupRegEx
16:57:36 <kc5tja> -- setupName    = maybeMatch setupRegEx
16:57:39 <mr_tenor> kc5tja: http://www.haskell.org/hawiki/Currying
16:57:40 <lambdabot> Title: Currying - The Haskell Wiki
16:57:45 <kc5tja> I'm getting a type-error on maybeMatch.  :(
16:58:10 <mr_tenor> to the best o my understanding, one needs to assume left associativity
16:58:35 <roconnor> we need right associativity and post-fix application?
16:58:49 <bd_> @google matchRegex
16:58:51 <lambdabot> http://www.cs.duke.edu/csed/java/biojava-1.4/org/biojava/bio/search/FilterTest.MatchRegex.html
16:58:51 <lambdabot> Title: FilterTest.MatchRegex (BioJava-1.4 API)
16:58:53 <bd_> @hoogle matchRegex
16:58:54 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
16:58:54 <lambdabot> Text.Regex.matchRegexAll :: Regex -> String -> Maybe (String, String, String, [String])
16:58:58 <bd_> >.>
16:59:05 <kc5tja> mr_tenor: In J, currying is supported via special operators.  So it's still possible.  In Haskell, you have to use special operators like $ to "fake" right-associativity.
16:59:18 <bd_> kc5tja: ah, (.) is only really for single-argument functions.
16:59:39 <mr_tenor> hmm
16:59:49 <bd_> kc5tja: probably better to just do: maybeMatch rx string = maybeHead (matchRegex rx string)
17:00:03 <bd_> kc5tja: though I'd use (fmap head) or something for maybeHead myself :)
17:00:12 <kscaldef> bd_: fwiw, I find this issue quite annoying too
17:00:27 <roconnor> @pl maybeMatch rx string = maybeHead (matchRegex rx string)
17:00:28 <lambdabot> maybeMatch = (maybeHead .) . matchRegex
17:00:53 <bd_> kscaldef: hm, maybe .. should be repurposed into a two-argument .? :)
17:01:11 <roconnor> often we define (.:) = (.) . (.)
17:01:20 <bd_> :t (.).(.)
17:01:22 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:01:25 <kc5tja> Now, see, that just doesn't make sense to me.
17:01:31 <kc5tja> I want the equivalent of this:
17:01:32 <kscaldef> hmm
17:01:42 <kc5tja> maybeHead(matchRegex v1 v2)
17:01:52 <kc5tja> So, why should (maybeHead .) appear in parenthesis?
17:01:59 <glguy> ?hoogle matchRegex
17:02:00 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
17:02:00 <lambdabot> Text.Regex.matchRegexAll :: Regex -> String -> Maybe (String, String, String, [String])
17:02:01 <kc5tja> It clearly must be evaluated *last*.
17:02:01 <bd_> Generally if you have to think hard to make something pointfree, maybe you shouldn't bother making it point-free... :)
17:02:20 <glguy> shouldn't that be maybeHead =<< matchRegex a b
17:02:20 <glguy> ?
17:02:34 <kc5tja> bd_: Hmm, that's a pity; point-free in J is trivial.
17:02:37 <roconnor> kc5tja: (maybeHead .) is like (5 +)
17:02:52 <bd_> kc5tja: ((maybeHead . ).matchRegex) v1 v2 = ((maybeHead .) (matchRegex v1)) v2 = (maybeHead . matchRegex v1) v2 = maybeHead (matchRegex v1 v2)
17:02:54 <roconnor> > map (5 +) [0..]
17:02:56 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
17:03:44 <kscaldef> kc5tja: why do you say "it clearly must be evaluated last"?
17:04:08 <kc5tja> kscaldef: Because it operates on the data provided by matchRegex; if matchRegex hasn't provided a result yet, the equation is meaningless.
17:04:28 <kscaldef> aren't you depending on knowing the semantics of the functions, then?
17:04:37 <roconnor> @type maybeHead
17:04:39 <lambdabot> Not in scope: `maybeHead'
17:04:48 <kc5tja> kscaldef: In a *functional* language, isn't that the expectation?  :)
17:05:00 <kc5tja> roconnor: maybeHead is my own definition.
17:05:08 <kc5tja> maybeHead (Just (x:xs))    = Just x
17:05:08 <kc5tja> maybeHead Nothing          = Nothing
17:05:33 <kscaldef> isn't what the expectation?
17:05:35 <SamB> hmm.
17:05:40 <bd_> maybeHead = fmap head :)
17:05:46 <kc5tja> kscaldef: What question did you just ask?
17:05:50 <bd_> oh, wait, it handles Just [] too, I see.
17:05:52 <kscaldef> that the compiler can somehow deduce semantics?
17:06:00 <SamB> I wonder how hard it would be to adapt a hardware description language for writing efficient emulators...
17:06:09 <kc5tja> bd_: fmap head doesn't make sense to me, because fmap applies head to all members inside the list, no?
17:06:36 <bd_> you're using fmap on the Maybe wrapper
17:07:02 <SamB> > fmap head (Just [])
17:07:03 <lambdabot>  Exception: Prelude.head: empty list
17:07:16 <bd_> yeah, hm
17:07:21 <SamB> strange concept of "handles"
17:07:22 <bd_> @hoogle [a] -> Maybe a
17:07:22 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
17:07:23 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
17:07:27 <bd_> ah!
17:07:29 <roconnor> @type fmap
17:07:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:07:40 <bd_> > fmap (join . listToMaybe) (Just [])
17:07:41 <lambdabot>  Just Nothing
17:07:43 <bd_> > fmap (join . listToMaybe) (Just [1])
17:07:44 <lambdabot>   add an instance declaration for (Num (Maybe a))
17:07:44 <lambdabot>     In the expression: 1
17:07:49 <bd_> oO
17:07:54 <roconnor> fmap takes a function from a -> b and turns it into a function Maybe a -> Maybe b
17:07:55 <kc5tja> kscaldef: Correct; which by the definition of function application, it must.
17:08:03 <bd_> :t fmap (join . listToMaybe)
17:08:05 <SamB> > join (fmap listToMaybe (Just [1]))
17:08:06 <lambdabot> forall a (f :: * -> *). (Functor f) => f [Maybe a] -> f (Maybe a)
17:08:07 <lambdabot>  Just 1
17:08:07 <kc5tja> Remember, I'm evaluating maybeHead( regexMatch v1 v2 )
17:08:10 <narain> @src Maybe.listToMaybe
17:08:11 <lambdabot> Source not found. Take a stress pill and think things over.
17:08:14 <bd_> ah hm
17:08:19 <kc5tja> Note that the entirety of regexMatch v1 v2 is the parameter to maybeHead.
17:08:20 <bd_> :t join . fmap (listToMaybe)
17:08:22 <lambdabot> forall a. Maybe [a] -> Maybe a
17:08:28 <bd_> > join . fmap (listToMaybe) (Just [])
17:08:29 <lambdabot>  Couldn't match expected type `a -> [Maybe a1]'
17:08:35 <kc5tja> Anyway, I think we're digressing.
17:08:35 <bd_> > join . fmap (listToMaybe) $ (Just [1])
17:08:38 <lambdabot>  Just 1
17:08:42 <bd_> ^^^ there's your function :)
17:08:46 <bd_> > join . fmap (listToMaybe) $ (Just [])
17:08:48 <lambdabot>  Nothing
17:08:55 <kc5tja> I like my solution better.  It's clearer and easier to read/debug.
17:09:10 <bd_> fair enough
17:09:13 <kc5tja> :)
17:09:14 <SamB> you know how people are liking to write hardware in C these days? I wonder if it wouldn't sometimes make more sense to write software in an HDL...
17:09:18 <roconnor> clarity is important
17:09:54 <kc5tja> SamB: I've often thought this exact thing; Verilog has much in common with an executable form of abstract state machine specification.
17:10:31 <SamB> I was thinking this because of how complicated writing an emulator in C, C++, and/or ASM is...
17:11:00 <kc5tja> Well, an emulator for what?
17:11:10 <SamB> well, like ZSNES
17:11:39 <kc5tja> Ahh
17:11:41 <SamB> basically any emulator that has to deal with timing between more than one device
17:11:57 <SamB> or what act like more than one device
17:12:18 <MarcWebe1> Me stupid fool. I did import the wrong module (from another library having the same name)..
17:12:19 <kc5tja> Well, I don't see how using an HDL for that is going to help much.  :)  In fact, I expect the HDL to actually be slower.
17:13:02 <kc5tja> What's really needed is a nice system of callbacks when the appropriate time has elapsed.
17:13:19 <SamB> well, even just the sound module on an SNES
17:13:21 <kc5tja> Once you have that, most of the rest of the pieces just fall into their places.
17:13:48 <SamB> (it has two processors and two RAM chips on it)
17:14:53 <SamB> anyway...
17:15:10 <kc5tja> I don't know.  I'd be inclined to rely on multithreading in that situation, personally.
17:15:15 <SamB> hah
17:15:20 <sorear> a threaded code interpreter can run much faster than a gate interpreter. are any hdl compilers that good?
17:15:38 <kc5tja> sorear: Verilog.
17:15:47 <SamB> sorear: note that I wasn't thinking an existing compiler would be used
17:15:52 <kc5tja> sorear: Most verilog and VHDL software are not expressed in terms of gates.
17:16:11 <sorear> actually zsnes might be an extra-easy case, since that was back in the era when harvard was more common than von-neumann
17:16:24 <sorear> --> cheap mostly-static translation
17:16:25 <SamB> hmm.
17:17:09 <sorear> otoh, game programmers were probably extremely fond of self modifying code
17:17:53 <SamB> well.
17:18:12 <SamB> let me give an example of the kind of thing I think it might help with.
17:18:35 <fax> see if I have a big long function
17:18:40 <fax> which takes a while to calculate
17:18:54 <fax> you can run that in stages?
17:19:09 <fax> is there a _way_ to do that, or do I have to code it manuall
17:19:12 <sorear> maybe.
17:19:33 <sorear> by "stages", does the rts shut down in-between?
17:19:34 <fax> like could I put waypoints in the code
17:19:41 <bgerm> i'm using ghci.  why does import Text.Printf give a parse error on input `import'
17:19:41 <fax> rts?
17:20:13 <sorear> bgerm: because ghci isn't a toplevel.  you need to use special commands, in this case :m + Text.Printf
17:20:31 <bgerm> sorear, thanks :)
17:20:33 <sorear> fax: runtime system. ie, do you kill the process between stages
17:20:41 <SamB> there is a guy named blargg, and he has an SPC emulator that (almost) only runs the sample generation unit (called the DSP) when the SPC CPU writes to a register on it
17:20:47 <fax> I cant kill the process :|
17:20:54 <sorear> fax: ?
17:21:27 <fax> can I do like f = A; waypoint; B; waypoint; C;
17:21:33 <SamB> I was thinking an HDL compiler might be able to (semi-)automatically perform that kind of optimization
17:21:39 <sorear> fax: you have myFunction, you want to run increment ; increment ; increment.  can you guarantee all this happens in the same call to main?
17:21:39 <fax> so that it will stop execution at the waypoint
17:21:47 <fax> then I can resume execution later
17:22:12 <sorear> fax: does later mean in-the-same-process, or do you need to dump state to disk?
17:22:14 <SamB> (of course, it might be important for programmers to be able to at least see that it is done or why it is not done)
17:22:16 <fax> sorear: I dont know what you mean
17:22:32 <fax> like I dont have any threads or IPC or anything
17:22:37 <fax> this would all be withing on process
17:22:42 <sorear> fax: can the computer be shut down with f stoped at a waypoint?
17:22:47 <fax> o
17:22:48 <fax> on
17:22:49 <fax> no
17:22:56 <sorear> fax: and the function resumed later?
17:23:03 <fax> no......
17:23:08 <bgerm> sorear, what do you use for your haskell interpreter?
17:23:16 <bgerm> hugs?
17:23:17 <fax> I want to call f once, and it gets to the first waypoint
17:23:23 <fax> then call f again, and it gets to the second
17:23:29 <ddarius> Ah, yield
17:23:29 <sorear> bgerm: ghci. it sucks, but it's not like there's anything better
17:23:39 <bgerm> thanks
17:23:44 <SamB> I suppose the programmer might need to be able to specify a read/write barrier between components...
17:23:59 <sorear> fax: do you need all the semantics of yield, or can you make do with implicit stopping?
17:24:09 <fax> I dont know what yield is
17:24:13 <dons> sorear: so have you switched to using xmonad for your window manager yet?
17:24:17 <dons> and if not, why not? :-)
17:24:39 <fax> @hoogle yield
17:24:40 <lambdabot> Control.Concurrent.yield :: IO ()
17:24:50 <ddarius> Wrong yield.
17:25:00 <sorear> dons: I'm used to ion3, and even if you added full RYM support to xmonad it would save me maybe 5% on my day because that's how much time I spend with X
17:25:09 <ddarius> Yield is the typical name for what it sounds like you want waypoint to de.
17:25:18 <ddarius> s/de/do
17:25:32 <sorear> fax: would it be good-enough if f could stop anywhere?
17:25:48 <fax> I suppose
17:25:48 <sorear> like, I run f for one-second, stop it, start it, etc.
17:25:49 <fax> yeah
17:25:54 <dons> you might spend more time in X it behaved more like the console :-) ...
17:25:57 <sorear> fax: is f pure?
17:26:01 <fax> pure?
17:26:05 <sorear> not IO
17:26:11 <fax> it edits the state of some monads
17:26:32 <encryptio> correct me if i'm wrong: the only thing that's special about monads is do notation. everything else is high-level mental fluff.
17:26:35 <sorear> ok, then you need determinism.  oh well.
17:26:42 <sorear> encryptio: you are right
17:26:45 <fax> determinis?
17:26:57 <encryptio> that's soooo sexy
17:27:11 <ddarius> encryptio: Even do notation is hardly special.
17:27:17 <fax> is there nothing like call/cc?
17:27:29 <sorear> fax: it needs to stop at a predictable place, since you can observe side effects
17:27:37 <ddarius> fax: Not in pure Haskell, you can use a Cont monad.
17:29:16 <hpaste>  stepcut pasted "Comparing Existential Values" at http://hpaste.org/916
17:29:38 <stepcut> is there a 'better' way to compare existential values ?
17:31:03 <araujo> hello
17:31:13 <stepcut> hello
17:33:01 <Cale> stepcut: Provide projections down to some other type in the class which the existentials support, and compare on that?
17:33:29 <fax> if I had a function which performs an infinite loop
17:33:38 <fax> could I start running it, but stop it later on?
17:33:49 <fax> (what would you use?)
17:33:57 <encryptio> if it were in another process/thread, sure.
17:33:59 <Cale> fax: does it emit a list as it goes?
17:34:08 <fax> no
17:34:21 <fax> it doesnt return anything, but it would perform side effects
17:34:30 <Cale> ah, okay, so it's an IO process
17:34:44 <Cale> yeah, forkIO, and use killThread, I think
17:34:57 <fax> cool, thanks ill look into it
17:35:03 <sorear> fax: another idea:
17:35:06 <Cale> forkIO :: IO () -> IO ThreadId
17:35:14 <Cale> killThread :: ThreadId -> IO ()
17:35:15 <sorear> use ReaderT (MVar ()) IO a
17:35:19 <sorear> then
17:35:27 <encryptio> (>>=) is bind, (>>) is what?
17:35:39 <sorear> waypoint = ask >>= \mv -> lift (takeMVar mv)
17:35:40 <stepcut> Cale: yeah, that was my other method -- (unsafe version --> (Ex a) == (Ex b) = (show a) == (show b))
17:35:52 <kc5tja> @hoogle ==
17:35:52 <lambdabot> Prelude.(==) :: Eq a => a -> a -> Bool
17:35:53 <lambdabot> Test.QuickCheck.(==>) :: Testable a => Bool -> a -> Property
17:35:59 <fax> sorear: woah
17:36:10 <kc5tja> @hoogle =/=
17:36:11 <lambdabot> No matches found
17:36:13 <kc5tja> @hoogle =\=
17:36:13 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\='
17:36:19 <kc5tja> @hoogle !=
17:36:19 <lambdabot> No matches found
17:36:23 <sorear> > 2 /= 3
17:36:23 <encryptio> (/=)
17:36:24 <kc5tja> @hoogle =~
17:36:24 <lambdabot>  True
17:36:24 <lambdabot> No matches found
17:36:27 <sorear> > 2 /= 2
17:36:28 <lambdabot>  False
17:36:37 <kc5tja> Thanks.
17:37:41 <Cale> stepcut: the whole idea of existentials is that you're throwing away particulars though, so comparing them directly isn't really supposed to be possible
17:37:57 <fax> @doc ReaderT
17:37:57 <lambdabot> ReaderT not available
17:38:01 <fax> >:/
17:38:09 <kc5tja> :(
17:38:18 * kc5tja is just not finding a functional way to express the following:
17:38:44 <fax> sorear: I would pass ReaderT as a parameter?
17:38:49 <kc5tja> if a /= b then (Constructor a) else if a /= c then ....
17:38:53 <kc5tja> any ideas?
17:38:53 <SamB> kc5tja: so is verilog nicer than VHDL?
17:39:07 <jcreigh> kc5tja: guards?
17:39:09 <kc5tja> That depends on your point of view, and whether you prefer Ada versus C.
17:39:24 <kc5tja> jcreigh: I tried guards, but the compiler kept puking at me.
17:39:27 <SamB> what is Ada like?
17:39:33 <sorear> fax: it's a monad transformer
17:39:39 <sorear> @docs Control.Monad.Reader
17:39:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
17:39:59 <stepcut> Cale: yeah, what I really want to do is have a data type like, data Foo = Bar | Baz | .., which I can be extended in third party modules, and which can be easily put in a list [Foo]. Existentials seem pretty close -- and far easier to deal with that HList
17:40:49 <jcreigh> kc5tja: "puking at [you]"? How were you trying to use them?
17:42:09 <fax> @docs MVar
17:42:09 <lambdabot> MVar not available
17:42:29 <kc5tja> SamB: http://www.adahome.com/Tutorials/Lovelace/s12sf.htm
17:42:32 <lambdabot> Title: Ada95 Lovelace Tutorial Section 12.7 - Access Variables: Putting It All Together
17:43:53 <kc5tja> jcreigh:   fooFunc a b | (F a) /= Nothing -> doSomethingWith a    | (G a) /= Nothing -> doSomethingElseWith a  etc.
17:43:59 <kc5tja> (except properly indented of course)
17:44:54 <hpaste>  fax pasted "waypoints" at http://hpaste.org/917
17:44:58 <jcreigh> kc5tja: | f x = whatever
17:45:02 <jcreigh> kc5tja: = not ->
17:45:06 <fax> sorear: would the function be declared like that?
17:45:15 <kc5tja> hmm
17:46:24 <kc5tja> Well, either way, it turns out to not be what I wanted.
17:46:35 * kc5tja sighs -- it's taking me *FOREVER* to write this code.  :)
17:46:40 <sorear> fax: almost
17:47:08 <fax> what differences would there have to be?
17:47:16 <hpaste>  sorear annotated "waypoints" with "unfortunately, all reasonable implementations of io waypoints are transformers" at http://hpaste.org/917#a1
17:47:35 * kc5tja is just going to have to use do-notation and variables, I think.  I can't see any other way of pulling this off.
17:48:09 <SamB> kc5tja: I'm guessing that you mean Verilog :: VHDL as Ada :: C?
17:48:23 <kc5tja> SamB: Uhhh....no.  :)
17:48:28 <SamB> oh.
17:48:29 <kc5tja> SamB: VHDL *IS* a dialect of Ada.
17:48:34 <SamB> oh.
17:48:35 <kc5tja> It's a proper subset of ADa.
17:48:39 <SamB> heh
17:48:52 <kc5tja> Verilog isn't a subset of anything, but it's much closer to C, and therefore, is more lower level.
17:49:02 <SamB> okay.
17:49:34 <fax> I get some errors like "No instance for (MonadReader (MVar a) (t IO))"
17:49:37 <SamB> so which of them has a nicer type system?
17:50:23 <kc5tja> VHDL, by far, is the higher level of the two.  However, Verilog allows you to instantiate modules and sub-modules in arrays if needed, which last time I checked VHDL didn't let you do.
17:50:27 <kc5tja> So it's a tradeoff.
17:50:35 <SamB> huh
17:50:39 <SamB> that seems odd
17:50:53 <kc5tja> I personally have not ever worked with VHDL, so I don't know the ins and outs of the language.
17:50:55 <sorear> fax: byech.  "monomorphism restriction" ?
17:50:59 <kc5tja> I've worked only with Verilog in the past.
17:51:09 <kc5tja> I'm not adverse to learning VHDL though.  I just don't have the resources for it.
17:51:09 <sorear> you may need to add a few type signatures
17:51:19 <fax> hm no mention of monomorphic..
17:51:23 <fax> it does say Urk! Inventing strangely-kinded void TyCon:
17:51:43 <sorear> odd.
17:52:07 <sorear> there's a good (iirc) description of that on the trac
17:52:08 <sorear> @goo "Urk! Inventing strangely-kinded void TyCon:"
17:52:09 <hpaste>  fax annotated "waypoints" with "f" at http://hpaste.org/917#a2
17:52:10 <lambdabot> No Result Found.
17:52:11 <SamB> that reminds me of what happens when I compile GHC HEAD
17:52:15 <sorear> @goo Urk! Inventing strangely-kinded void TyCon:
17:52:18 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/959
17:52:18 <lambdabot> Title: #959 (Debugging info(?) leaks out: &#34;Urk! Inventing strangely-kinded void TyC ...
17:52:22 <SamB> (i.e. lots of strange messages on the console)
17:52:30 <fax> ok nice, reading cheers
17:52:57 <sorear> SamB: how strange?
17:53:10 <sorear> I got strange messages installing firefox 2 yrs ago
17:53:14 <fax> hmm
17:53:15 <SamB> well, I'm pretty sure I've seen that before
17:53:21 <fax> I dont know why its giving me that
17:53:27 <kc5tja> Firefox 2.0 compiles cleanly on my box.
17:53:29 <sorear> ext3fs ERROR: corrupted transaction log! remounting read only!
17:53:39 <sorear> or something like that :/
17:53:44 <kc5tja> I don't recall seeing any warnings.  Which was rather a shock to me, really.
17:53:48 <SamB> hah
17:54:00 <sorear> kc5tja: lemme guess.  CFLAGS=-w ?
17:54:02 <kc5tja> sorear: Umm...that's BAD.  :)
17:54:10 <kc5tja> sorear: No, full warnings -Wall
17:54:17 <fax> any ideas regarding: http://hpaste.org/917#a2
17:54:44 <SamB> I think maybe release builds don't give that warning
17:55:14 <abz> :t either
17:55:16 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
17:55:50 <SamB> the best way to get simon to fix a bug is to come up with a way to make it do something bad ;-P
17:56:16 <SamB> even if you have to hack the compiler, he still might fix it
17:56:37 <dons> ?where yhc-bugs
17:56:38 <lambdabot> http://code.google.com/p/yhc/issues/list
17:58:35 <fax> would you call the function normally?
17:59:07 <hpaste>  kc5tja pasted "Any ideas on how to better write this?" at http://hpaste.org/918
17:59:34 <kc5tja> Subject heading says it all, I guess.  :)
17:59:38 <kc5tja> Ideas welcome.
17:59:49 <dcoutts> dons, ping
17:59:57 <kc5tja> parseLines, btw, is intended to be called via foldr.
18:01:03 <fax> sorear: can you give me some pointers on how to do this because I really dont know
18:01:17 <fax> everything I try just gives me errors I dont understand it seems
18:01:21 <hpaste>  Adam annotated "How do I do this in Haskell" with "How do I do this in Haskell (done)" at http://hpaste.org/913#a4
18:01:32 <hpaste>  glguy annotated "Any ideas on how to better write this?" with "fixed" at http://hpaste.org/918#a1
18:01:59 <glguy> I don't know who adam is, but he doesn't understand "do"
18:02:20 <dons> dcoutts: pong
18:03:08 <dcoutts> dons, we need to talk about meeting up when I arrive etc, perhaps -> #maya
18:03:15 <jcreigh> kc5tja: as a side note, there are "isNothing" and "isJust" functions in Data.Maybe
18:03:35 <glguy> Oops, that wasn't Adam's paste, it was kc5tja
18:03:54 <fuzan> anyone here versed with gtk2hs and onKeyPress? I can't seem to get simaultaneous keyevents working.
18:03:55 <kc5tja> glguy: ??
18:04:06 <kc5tja> glguy: That's what I was originally going for, but the compiler didn't like ->.
18:04:22 <kc5tja> But, it looks like I'm still going to be needing to unMaybe it.
18:04:27 <kc5tja> jcreigh: Looking now.
18:04:40 <glguy> kc5tja: you don't use "do" for any old function, it's a shorthand for monads
18:04:40 <stepcut> kc5tja: unMaybe --> fromJust
18:04:54 <jcreigh> kc5tja: right, guards use = to separate the test and the result, not ->
18:05:12 <kc5tja> glguy: No, that's a typo.  I was trying something out, and it didn't work out.
18:05:27 <stepcut> kc5tja: there is also, 'fromMaybe' and 'maybe', but fromJust makes the most since here because you already know the value must be (Just ...)
18:06:42 <kc5tja> Parse error on "|"
18:07:31 <kc5tja> glguy: Your code won't parse in ghci -- is this a bug in ghci specifically?  I'm using 6.4.2
18:07:47 <kc5tja> Nope -- ghc spews the error too.
18:07:55 <shachaf> kc5tja: Take to "do" out, if it's still in there.
18:08:21 <kc5tja> shachaf: Not there.  Never was there (except when posting to hpaste)
18:08:30 <kc5tja> The problem was I accidentally left a spurious =.
18:08:43 <glguy> kc5tja: my code left the error you made regarding not using fromJust
18:08:48 <kc5tja> A better error message there is definitely in order.  :)
18:08:58 <kc5tja> glguy: Different issue.
18:09:15 <glguy> kc5tja: do you know about mplus?
18:10:20 <kc5tja> glguy: No.
18:10:23 <glguy> > let a = Just 1; b = Just 2; def = 3 in fromMaybe def (a `mplus` b)
18:10:24 <lambdabot>  1
18:10:32 <glguy> > let a = Nothing; b = Just 2; def = 3 in fromMaybe def (a `mplus` b)
18:10:34 <lambdabot>  2
18:10:40 <glguy> > let a = Nothing; b = Nothing; def = 3 in fromMaybe def (a `mplus` b)
18:10:41 <lambdabot>  3
18:10:42 <goltrpoat> hmm.. can someone clarify note 5 of http://haskell.org/onlinereport/syntax-iso.html to me?  it seems to me that i'm in the lexer at this point, so "grammar" refers to the lexical syntax, but then i don't know what "valid prefix" refers to
18:10:43 <lambdabot> Title: Haskell 98 Syntax
18:10:53 <glguy> kc5tja: then you can write:
18:11:18 <glguy> liftM (\x -> Bringup x : state) bringupName line
18:11:50 <glguy> err
18:11:55 <glguy> liftM (\x -> Bringup x : state) (bringupName line)
18:12:41 <goltrpoat> actually.. is it just talking about brace matching?
18:12:51 <allbery_b> goltrpoat: congratulations, you've tripped over the rule that makes haskell parsing impossible :)
18:12:57 <goltrpoat> hah
18:13:02 <allbery_b> it's talking about implicitly inserted braces
18:14:29 <goltrpoat> right..  so basically i make L keep track of the inserted braces, and parse_error is true if the number of open braces is equal to the number of closed braces, counting the next token?
18:14:48 <stepcut> parseLine line state = maybe state (: state) $ (fmap Test (testName line)) `mplus` (fmap Bringup (bringupName line)) `mplus` (fmap Setup (setupName line))
18:14:49 <stepcut> :p
18:14:55 <allbery_b> this is above the level of the lexer.  when the parser is considering valid parses, if it sees an illegal token, it is supposed to look at what it has, and if what it has to that point is legal *and* inserting a '}' token would make the next token legal, it should do so
18:15:05 <goltrpoat> oh jesus.
18:15:25 <stepcut> glguy: ah, I see you had the same idea regarding mplus :p
18:15:36 <kc5tja> glguy: I'm sorry, but I don't understand how it works.
18:16:05 <kc5tja> The dyadic case of fromMaybe is OK, but I don't see how liftM works.
18:16:08 <matthew-_> @hoogle [a] -> Maybe a -> [a]
18:16:09 <lambdabot> No matches, try a more general search
18:16:10 <allbery_b> suffice it to say that no extant haskell compiler implements this rule :)
18:16:19 <goltrpoat> allbery:  so basically, the "lexer" is context-free.
18:16:32 <goltrpoat> haha ok
18:16:38 <goltrpoat> that makes it easier :)
18:16:47 <matthew-_> @pl \l m -> maybe l (:l) m
18:16:48 <lambdabot> ap maybe (flip (:))
18:17:35 <sorear> goltrpoat: you can't separate the lexer and parser in a strictly conformant h98 syntaxer
18:17:46 <sorear> goltrpoat: also, user defined fixities enter in
18:17:54 <sorear> > do False == False == False
18:17:55 <lambdabot>      precedence parsing error
18:17:55 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
18:17:57 <goltrpoat> exactly, user defined fixities are the reason why the lexer is separate
18:18:12 <sorear> > let x = True in x == x == True  -- this is valid h98
18:18:13 <lambdabot>      precedence parsing error
18:18:14 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
18:18:35 <sorear> because == is nonassoc, the parse error rule fires, and we get
18:18:35 <hpaste>  glguy annotated "Any ideas on how to better write this?" with "something like this works" at http://hpaste.org/918#a2
18:18:54 <sorear> er, nm there
18:19:18 <sorear> > do { False == False } == False   -- the h98 layout which no real implementation finds
18:19:19 <lambdabot>  Couldn't match expected type `t t1' against inferred type `Bool'
18:19:26 <goltrpoat> sorear:  yeah, i know where you're going with this.
18:19:27 <sorear> it's a type error, but still
18:19:35 <sorear> goltrpoat: it gets worse
18:19:44 <goltrpoat> i couldn't think of a good way to handle fixities without a separate lexer
18:20:00 <goltrpoat> but that part of the layout rule throws a monkey wrench into that whole plan.
18:20:13 <sorear> foo = bar ? baz where (?) = sam ; infixr 2 ?
18:20:22 <sorear> fixities can be bound in where
18:20:28 <sorear> fixities can come after use
18:20:41 <goltrpoat> i have the after use bit covered
18:20:46 <zanar> I'm interested in Haskell for real world applications (as opposed to the typical research environment)
18:20:47 <goltrpoat> i hadn't thought of local fixity declarations though
18:20:59 <goltrpoat> although..  no, that's still not an issue.
18:21:00 <SamB> :t callCC
18:21:02 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
18:21:03 <sorear> the parser needs to know fixities to handle layout, arbitrarily far after the usage
18:21:09 <sorear> goltrpoat: remember shadowing
18:21:22 <zanar> in order for me to consider and promote Haskell in the industry, I really need to understand a few things
18:21:43 <goltrpoat> that's fine.  lex the program, then gather top-level fixity declarations prior to a topdecl.  gather decl-level fixity declarations prior to a decl.  seems to generalize to local fixity declarations.
18:21:53 <zbrown> zanar: like what?
18:22:04 <SamB> sorear: do you happen to no how to do something like a generator in Python using ContT?
18:22:13 <sorear> SamB: yes
18:22:19 <zanar> I'm sold on the language, taken by itself. But I'd like to know about the current status of the libraries for Haskell
18:22:33 <SamB> fax wants to know how to do it ;-)
18:22:38 <sorear> infixl 4 ? ; (?) = sam ; x = do 1 ? 2 ? 3 where (?) = boo ; infix 4 ?
18:22:49 <sorear> goltrpoat: shadowing - this has one valid lex
18:22:57 <sorear> infixl 4 ? ; (?) = sam ; x = do { 1 ? 2 } ? 3 where (?) = boo ; infix 4 ?
18:23:32 <zanar> I'd like to know what's the current status of the Haskell libraries when compared to a relatively mature language like Python.
18:24:02 <sorear> they're fairly good
18:24:02 <goltrpoat> sorear:  no, i'm following.
18:24:18 <sorear> goltrpoat: "no" means what here?
18:24:43 <sorear> zanar: no http lib fex, but it goes both ways
18:25:17 <stepcut> zanar: the standard libs are quite nice. For domain specific libs, some domains have lots of options, and other domains have nothing...
18:25:26 <sorear> can python do strongly conn comp analysis?
18:25:27 <zanar> sorear: I think it would be beneficial to have some sort of roadmap. A list of "todo" libraries to match the most important and common libraries shared among Python, Ruby, Perl, etc...
18:25:47 <goltrpoat> sorear:  parasite word :)  i hadn't thought of local declarations, like i said, but i've thought of the fact that top-level fixity declarations affect the parse tree retroactively, and that's why there's a lexer.  the idea is to do one or two passes over the token stream to gather fixity declarations
18:25:51 <zanar> sorear: I don't even know what conn comp analysis is :)
18:25:59 <kc5tja> YAY!  First cut at my code is working!
18:26:07 <kc5tja> And it's all pretty-like too.
18:26:11 <sorear> zanar: write it, and but it put it on the wiki! (the todo list)
18:26:26 <kc5tja> Thanks for the help glguy, sorear, and others.
18:26:28 <zanar> stepcut: where can I find the standard library and a set of accepted extended libraries?
18:26:37 <sorear> @docs
18:26:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
18:26:41 <sorear> @where hackage
18:26:42 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
18:26:44 <zanar> sorear: I would, but in order for me to do that, I need to understand what are the missing ones :)
18:26:46 <sorear> in that order :)
18:26:53 <zanar> thanks sorear
18:27:45 <goltrpoat> sorear:  in other words, ive thought of the f x y z = x ? y ? z; infixl 4 ?; a ? b = ... case, it does get more involved with non top-level fixity declarations though
18:27:53 <kc5tja> @hoogle Handle -> IO [String]
18:27:53 <zanar> because, if we have a list in place, we could simply start working on them. Some of them will be complex and take a long time, but I'm sure that there are plenty of modules that could be implemented in a couple of hours while watching CSI Miami :-D
18:27:53 <lambdabot> No matches, try a more general search
18:28:02 <kc5tja> @hoogle IO [String]
18:28:02 <lambdabot> System.getArgs :: IO [String]
18:28:03 <lambdabot> System.Console.Readline.filenameCompletionFunction :: String -> IO [String]
18:28:03 <lambdabot> System.Console.Readline.usernameCompletionFunction :: String -> IO [String]
18:28:21 <stepcut> zanar: Haskell' is defining a new set of 'standard' libraries, but these are pretty well supported 'core' libraries, http://www.haskell.org/ghc/docs/latest/html/libraries/index.html, hackage will eventually host all the common third party libraries. However, hackage is pretty new, so a lot of stuff is not there yet.
18:28:21 <kc5tja> @hoogle andle -> IO String
18:28:22 <lambdabot> Did you mean: Andle -> IO String
18:28:23 <goltrpoat> sorear:  i think that's still ok with my current approach though.
18:28:27 <kc5tja> @hoogle Handle -> IO String
18:28:28 <lambdabot> IO.hGetContents :: Handle -> IO String
18:28:28 <lambdabot> IO.hGetLine :: Handle -> IO String
18:28:28 <lambdabot> System.IO.hShow :: Handle -> IO String
18:28:44 <kc5tja> @doc IO.hGetContents
18:28:44 <lambdabot> IO.hGetContents not available
18:28:51 <kc5tja> @doc IO.hGetLine
18:28:51 <lambdabot> IO.hGetLine not available
18:28:54 <kc5tja> @doc hGetLine
18:28:54 <lambdabot> hGetLine not available
18:29:01 <kc5tja> @hoogle hGetContents
18:29:01 <lambdabot> IO.hGetContents :: Handle -> IO String
18:29:10 <stepcut> zanar: another partial list of third party libraries can be found here: http://www.haskell.org/haskellwiki/Libraries_and_tools
18:29:12 <lambdabot> Title: Libraries and tools - HaskellWiki
18:29:28 <sorear> goltrpoat: how much of a frontend are you trying to write?
18:29:41 <stepcut> zanar: but, really, hackagedb is the future
18:29:54 <goltrpoat> sorear:  the only reason i'm using a lexer at all is the fact that fixity declarations affect the parse tree retroactively, and i wanted a nice intermediate representation to gather them beforehand
18:29:55 <sorear> goltrpoat: I'm working on "hv", a tba high-speed haskell validator
18:29:59 <goltrpoat> sorear:  i'm writing a compiler
18:30:14 <norpan> hick
18:30:49 <zanar> stepcut: would be correct to say that hackagedb is to HAskell what CPAN is to Perl?
18:30:56 <sorear> zanar: yes
18:31:21 <dons> sorear: validator eh?
18:31:29 <dons> so an embedded type checker?
18:31:30 <sorear> dons: yeah
18:31:33 <zanar> sorear: that's an important step for popularizing Haskell I think
18:31:41 <dons> zanar: hackage, you mean?
18:31:43 <sorear> dons: how "embedded"?
18:31:55 <dons> sorear: standalone, and fast, such that we'd call it from an editor?
18:31:57 <zanar> dons: hackage yes
18:31:58 <sorear> dons: i want to make hugs, but faster and less mem-hungry
18:32:02 <sorear> dons: exactly
18:32:05 <dons> zanar: indeed. i think its in fact critical.
18:32:05 <goltrpoat> oh, nice.
18:32:19 <dons> zanar: its the #1 priority for the community, getting a standard, easy to use, library system
18:32:27 <dons> we're makign good progress too, imo.
18:32:34 <sorear> dons: not just standalone - library interface too.
18:32:42 <zanar> dons: are there plans to have something like rubygems?
18:32:55 <sorear> so shim can just use the ffi for quick validate-this
18:33:02 <dons> zanar: so .tar.gz bundles that just install?
18:33:18 <dons> (if so, yes, the cabal-install tool is to be used for this purpose0
18:33:25 <dons> $ cabal-install mtl
18:33:27 <zanar> dons: more or less package that will always install safely
18:33:35 <dons> will grab the mtl package from hackage, unpack it, build it, install and register
18:33:45 <zanar> dons: ok, cabal is the right tool then
18:33:46 <dons> yes, that's what the plan is.
18:33:59 <dons> it should come with ghc 6.8
18:34:14 <sorear> zanar: on my todo is an apt/hackage mirror (with other formats maybe - rpm, gentoo-whatever, msi, etc)
18:34:23 <zanar> dons: what about RI for documentation of Haskell on the fly?
18:34:26 <goltrpoat> sorear:  i might have to bug you later on.  right now i have a reasonably useful backend, a typechecker, and i guess i'm about 50% done with the frontend, but haskell is the weirdest language ive ever come across as far as parsing goes
18:34:29 <sorear> so just apt-get install hackage-mtl
18:34:30 <zanar> sorear: great to hear that
18:34:33 <goltrpoat> so that remaining 50% is going to take a while
18:34:48 <dons> zanar: is that like haddock?
18:34:56 <dons> our doc tool
18:35:14 <sorear> goltrpoat: you have a typechecker? and how good is your backend?
18:35:16 <zanar> dons: not exactly. that's rdoc. RI is a cool tool that let you write... ri gsub and get the documentation for String#gsub
18:35:38 <sorear> goltrpoat: are you trying to be John Meacham or Jack Crenshaw?
18:35:44 <zanar> dons: you probably partially implemented this with lamdbabot already
18:35:51 <goltrpoat> sorear:  the backend is a pretty vanilla g-machine implementation.  the typechecker is straight from THIH, so it'll need some work for common extensions
18:36:04 <goltrpoat> and i was toying with the idea of adding UT, so that's another can of worms
18:36:06 <zanar> dons: but it would be extremely useful to have it as a standalone application that ships with ghc for example
18:36:18 <goltrpoat> sorear:  haha neither, really
18:36:19 <stepcut> zanar: (re: hackage), yes -- a few years ago, ghc hit a real nice spot in terms of features, speed, etc. So the biggest problem now is spotty libraries. Cabal and Hackage have already begun to help tremendously.
18:36:34 <sorear> goltrpoat: what's UT?
18:36:41 <goltrpoat> sorear:  uniqueness typing
18:36:52 <sorear> goltrpoat: I'm a little suprised you got jack crenshaw :)
18:37:04 <goltrpoat> yeah, actually his series is what got me into compilers to begin with
18:37:08 <stepcut> zanar: before cabal it was hard to compile third party libraries, and, in many cases, practically impossible to make .debs and .rpm. With cabal, it's trivial.
18:37:11 <zanar> stepcut: I'd love to introduce HAskell to the corporate and enterprise world, but to do that I need to back it up a little beyond the scope of the language alone
18:37:27 <jcreigh> wait, was that the "let's build a compiler" guy?
18:37:30 <goltrpoat> yeah
18:37:32 <sorear> yes
18:37:47 <sorear> and I thought I was the only one who'd read it :)
18:38:15 <goltrpoat> nah, i actually wrote a single-pass compiler for a C-like language as a result of reading that series, quite some time ago
18:38:28 <goltrpoat> jack was all about the single pass.
18:38:28 <zanar> so GHC ships with Prelude and The Standard Hierarchical Libraries only. right?
18:38:48 <monochrom> Yes.
18:38:49 <psykotic> yo golt
18:38:54 <goltrpoat> hey psyk
18:39:30 <zanar> monochrom the yes was for me?
18:39:36 <monochrom> Yes
18:40:03 <zanar> thanks.
18:40:40 <stepcut> zanar: yeah, Haskell is appropriate for some, but not all segments of corporate/enterprise yet due to missing libraries. However, 3rd party libraries are really starting to develop nicely these days -- so it is only a matter of time
18:41:08 <zanar> ok so this is fair enough. The main implementation of haskell ships a core set of library that we will call "standard". Then there is a bunch of third party libraries available through hackage and installable through cabal and other future tools.
18:41:48 <stepcut> zanar: sounds right
18:42:04 <zanar> stepcut: that why I'd love to come up with a list of libraries taken from other languages so that when you have a couple of hours to spend, you can grab one of the smaller ones and start implementing it.
18:43:06 <zanar> reaching Perl is way too ambitious... CPAN is huge. But even reaching the Ruby or Python level would be a great success.
18:43:36 <fax> http://search.cpan.org/~dconway/Acme-Don-t-1.01/t.pm
18:43:38 <lambdabot> Title: Acme::Don't - The opposite of do - search.cpan.org
18:43:54 <stepcut> zanar: more effective than grabbing smaller ones would be to focus on certain core areas to build up critical mass for certain types of applications
18:44:29 <zanar> stepcut: true, that's a good point.
18:44:33 <stepcut> zanar: for example, ruby on the rails did a lot for ruby's popularity
18:44:47 <zanar> stepcut: what are in your opinions the most lacking areas?
18:44:57 <sorear> @users
18:44:57 <lambdabot> Maximum users seen in #haskell: 339, currently: 309 (91.2%), active: 44 (14.2%)
18:45:49 <emk> zanar: I think the Matz, the author of Ruby, once sat down and cloned most of the Python library.
18:46:07 <emk> It might be worthwhile to close the intersection of the Python and Ruby standard libraries.
18:46:34 <zanar> emk: very possible. Would be great if there was a coordinate effort to do something like that. Even if just 50 people work on it, we could do a lot.
18:46:45 <emk> zanar: Yup.
18:46:58 <sorear> zanar: the best way to reach 50 people is haskell@haskell.org.
18:47:05 <zanar> emk: and that would create a lot of publicity for the language
18:47:19 <zanar> sorear: is haskell@haskell.org the haskell cafe mailing list?
18:47:21 <sorear> zanar: nothing happens in this community except by unilateral action - write a proposal now!
18:47:23 <SamB> emk: isn't most of the python library crap that just got left lying around in the python library directory?
18:47:38 <sorear> zanar: no, haskell-cafe@haskell.org is the haskell cafe mailing list :)
18:47:49 <emk> SamB: Well, it's become increasingly crufty over the years.
18:47:54 <SamB> I think most advanced python users would say so
18:47:55 <zanar> sorear: any special format I should use? I mean, I don't want people telling me "who the hell are you"
18:48:05 <sorear> zanar: haskell@haskell.org is much lower volume, much higher subscriber count
18:48:07 <emk> That's why suggested cloning the intersection of the Python and Ruby libraries.
18:48:13 <sorear> zanar: we don't do that here.
18:48:27 <dons> zanar: i think we can reach 'gems' level this year
18:48:31 <zanar> sorear: that must be lisp :-P
18:48:31 <dons> its almost done.
18:48:46 <sorear> zanar: nobody really cares who you are - spj gets rebuffed as often as j random newbie
18:49:02 <zanar> sorear: sounds cool
18:49:24 <dons> emk, that's interesting. docs and ideas would be best sent to haskell-cafe for discussion, or libraries@ for library people's opinions
18:49:39 <sorear> (spj of course being the mathy-brains of the ghc development group)
18:50:07 <zbrown> hrm
18:51:07 <stepcut> zanar: I would say that the general purpose libraries are in pretty good shape. So, you might look at a specific area (like web development), and see what is missing there
18:51:11 <zanar> sorear: yeah, I'm familiar with its genius
18:52:42 <stepcut> on the other hand, if there are some common libraries that Ruby and Python ship with that Haskell does not -- that does seem like a good thing to pursue
18:53:06 <emk> dons: Yeah, if I had more spare time, I would dig through the Ruby 1.8 docs and try to make a list of useful libs. Hmm.
18:53:38 <emk> stepcut: Well, and there's a lot of places where Haskell has libs, but the APIs require 5x the code to use for common cases. Those could all benefit from patches, too.
18:53:50 <dons> yes. unified lib development
18:53:58 <dons> and common conventions for apis
18:54:15 <stepcut> emk: yeah, that too
18:54:26 <zbrown> If I have something like "xVal <- liftM read getLine" and I later call it again on the issue of xVal not being within a proper range, does that present an issue of calling "xVal <- liftM read getLine"
18:54:29 <zanar> dons: agreed
18:54:30 <zbrown> ?
18:54:58 <zanar> emk: I may do that
18:55:19 <jcreigh> @seen sjanssen
18:55:19 <lambdabot> sjanssen is in #gentoo-haskell, #ghc, #haskell-overflow and #haskell. I last heard sjanssen speak 6h 20m 1s ago.
18:56:14 <stepcut> zbrown: I am not sure if I understand what you mean. But, I think the answer is, no.
18:56:33 <dons> can anyone get this to work in firefox? --> http://129.94.184.76/view_login.html (passwd: gues login: guest)
18:56:33 <lambdabot> Title: User Login
18:57:00 <dons> its supposed to be a public webcam of my uni's bus stop (but it bizarrely says you need IE)
18:57:06 <zbrown> stepcut: let me paste it
18:57:25 <dons> 'guest'
18:57:26 <zbrown> dons: let me login but it shows nothing
18:57:33 <stepcut> dons: I see the control panel, but no image inside
18:57:34 <dons> hmm same here.
18:57:45 <sorear>                                                         500 Server Error
18:57:45 <sorear>  
18:57:45 <sorear>    The server encountered an internal error and could not complete your request.
18:57:45 <sorear>  
18:57:45 <MarcWebe1> dons: Try User Agent Switcher ;)
18:57:53 <dons> MarcWebe1: ah nice idea
18:58:09 <stepcut> dons: // Command to Activex
18:58:13 <stepcut> dons:  from the page source
18:58:19 <kc5tja> Well ... holy cow!
18:58:24 <dons> urgh
18:58:35 <kc5tja> I've got the makings of a new CUT version written in Haskell going.
18:58:58 <hpaste>  zbrown pasted "is doing this with xVal kosher or no?" at http://hpaste.org/919
18:59:09 <dons> stepcut: ah yes I see. gross.
18:59:19 <zbrown> stepcut: ^^ bear in mind th its not complete code really
18:59:23 <dons> can you see the ip of the underlying image source?
18:59:38 <sorear> zbrown: it's legit, but your do's are messed up
18:59:40 <glguy> zbrown: you want "readLn"
18:59:42 <glguy> :t readLn
18:59:44 <lambdabot> forall a. (Read a) => IO a
18:59:55 <jcreigh> @tell sjanssen FYI, I wrote some bindings to Xinerama that I'm going to kick out to the world soon. I don't know if you want to do anything like that for xmonad soon, but if you do, don't duplicate the effort of wrapping libXinerama.
18:59:56 <lambdabot> Consider it noted.
19:00:02 <monochrom> readLn is a combo of getLine and readIO
19:00:11 <glguy> zbrown: and you'd need do after your then
19:00:11 <zbrown> oh ok
19:00:15 <allbery_b> I get a popup that says "http://129.94.184.76" "do control" in safari
19:00:15 <lambdabot> Title: Main Page
19:00:21 <glguy> zbrown: and the change to xVal won't exist outside of the if
19:00:31 <monochrom> readLn is best understood as Pascal's readln :)
19:00:31 <zbrown> thanks
19:00:42 <zbrown> never touched pascal ;)
19:01:14 <Blackfoot> are guards allowed in lambda expressions?
19:01:29 <dons> nope.
19:01:34 <dons> its proposed for haskell' though.
19:01:39 <stepcut> zbrown: yeah, there is no problem with changing what xVal is bound to. But it won't work like you wrote it for other reasons
19:01:46 <dons> > (\x -> case x of True -> 1 ; _ -> 7 )  8
19:01:47 <lambdabot>   add an instance declaration for (Num Bool)
19:01:50 <zbrown> stepcut: ok thanks
19:01:54 <dons> > (\x -> case x of True -> 1 ; _ -> 7 )  False
19:01:56 <lambdabot>  7
19:02:43 <QtPlatypus> Is here a good convention for doing functional pseudocode?  Most my pseydocode ends up looking like algo,  which made it difficult to express what are inherently functional ideas.
19:02:54 <Blackfoot> dons: ok, thanks
19:03:15 <dons> QtPlatypus: hmm, just write the haskell code directly?
19:03:20 <dolio> Haskell isn't close enough to pseudocode?
19:03:21 <dolio> :)
19:03:33 <dons> we usully just write the haskell directly as pseudocode
19:03:42 <stepcut> @quote pseudecode
19:03:42 <Blackfoot> dons: if i have a function expecting a type IO [c], is there a way i can test to see if the list is empty with pattern matching instead of the case statement?
19:03:43 <lambdabot> No quotes match. Are you on drugs?
19:03:45 <dons> and for missing stuff you'd say:    f x = ...
19:04:01 <dons> Blackfoot: you have to extract the list first, by performing the action
19:04:02 <stepcut> <roconnor> damn it, haskell pseudo code is indistinguishable from actual code
19:04:19 <Blackfoot> i'd like to say myfunc IO [] = return []
19:04:20 <Blackfoot> ok
19:04:24 <mr_tenor> dons: if you'e read the papers where the syntax and theory behind its existence is detailed, then writing haskell directly as pseudocode  works
19:04:30 <dons> :t do x <- getLine ; return $ if null x then Nothing else Just x
19:04:33 <lambdabot> IO (Maybe String)
19:04:54 <dons> :t do x <- getLine ; return (if null x then [] else reverse x)
19:04:55 <zbrown> :t readLn
19:04:58 <lambdabot> IO [Char]
19:04:58 <lambdabot> forall a. (Read a) => IO a
19:05:01 <Blackfoot> oh that should be useful, cool
19:05:01 <allbery_b> no image source ip evident in the script
19:05:16 <allbery_b> possibly you can get t by cabextract-ing /bmspx.cab.  maybe.
19:05:16 <dons> yeah, seems very ugly
19:05:24 <dons> i think i'll write a complaint :)
19:05:31 <dons> hmm. ok. let's try that
19:06:54 <dons> if only they'd asked someone in the CS dept to write the code :/
19:07:18 <dons> don't they realise they have 100 PhD students who'd love to hack the uni camera system into good shape? grumble grumble
19:07:39 <stepcut> dons: :p
19:09:17 <Saizan> (talking about labraries, for example Network.CGI.Protocol has a more complete set of functions to parse HTTP requests than Network.HTTP but its api expects CGI environment variables, so it's clumsy to use elsewhere, e.g. HAppS)
19:12:28 <stepcut> heh
19:12:32 <hpaste>  zbrown annotated "is doing this with xVal kosher or no?" with "How do I add an ending epxression for the do's?" at http://hpaste.org/919#a1
19:12:54 <zbrown> ^^ Any ideas?
19:13:11 <zbrown> I wasn't sure how to make the last part statement an expression
19:13:59 <stepcut> zbrown: you need something more like, xVal <- if (x > width - 1) then (putStr "blah" >> liftM read getLine) else return xVal,
19:14:12 <zbrown> oh ok
19:14:25 <zbrown> stepcut: thanks
19:14:33 <stepcut> in haskell, if statements return a value, and you always have to have an else branch
19:14:42 <stepcut> otherwise, it won't know what to return
19:15:22 <Saizan> also you can't end a do with a <- binding
19:15:40 <zbrown> stepcut: oh ok
19:15:55 <stepcut> in your current code, the inner binding of xVal would shadow the outer binding of xVal, but only inside that inner do statement
19:16:08 <stepcut> so, after the if statement returned, the original binding would be back in effect
19:16:24 <zbrown> stepcut: what does ">>" do?
19:16:40 <dons> allbery_b: any thoughts? I cabextract and get some bmsSpeech.dll bmspx.inf     bmspx.ocx
19:16:45 <kc5tja> @hoogle Either
19:16:45 <lambdabot> Prelude.Either :: data Either a b
19:16:46 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
19:16:52 <Saizan> m >> m1 === do { m; m1; }
19:17:07 <stepcut> zbrown: what Saizan said
19:17:17 <zbrown> oic
19:17:33 <allbery_b> dons: if it's not in the inf file then there might be a ucs-2 string in the .ocx.  of course, strings doesn't do ucs-2 last I checked
19:17:53 <allbery_b> doesn't sound good, though :(
19:18:17 <dons> i'm peering around the .ocx now
19:18:38 <stepcut> dons: that web server could be running on the web camera itself, and the activex control is reading from the hardware...
19:19:08 <dons> ah right.
19:19:20 <allbery_b> ug
19:19:38 <dons> lots of interesting things in the .ocx file,  "BMP File (*.bmp)|*.bmp|All File (*.*)|*.*|" , "Live casting is started already."
19:20:38 <monochrom> web server running on web camera?!
19:20:46 <hpaste>  fuzan pasted "gsk2hs- simult keydown ? " at http://hpaste.org/920
19:21:14 <monochrom> next, firewall+router running on DSLR camera? :)
19:21:24 <fuzan> ^-  simple fly a spaceship around opengl app. I can't however seem to get gtk to accept concurrent keypresses though. any ideas?
19:21:26 <dons> bah. too hard. it'd be easier to plug in my own camera :/
19:22:04 <hpaste>  zbrown annotated "is doing this with xVal kosher or no?" with "more issues lol" at http://hpaste.org/919#a2
19:22:21 <monochrom> "I build GHC on my newest camera flip phone"
19:22:24 <stepcut> dons: yeah, that's a brans200 server, you plug the cameras into the back of it: http://www.gzkeling.com/images/brans200.gif
19:23:10 <stepcut> monochrom:  the high end nikons have 802.11bg, so...
19:23:18 <dons> huh ok.
19:23:29 * monochrom snickers evilly
19:23:35 * allbery_b wonders if he compile would go faster than on his g4 mini :)
19:23:43 <dons> now ... just need to head down to the imaging guys and pick up a nice camera
19:23:45 <dons> where's a ladder?
19:24:18 <zbrown> stepcut: can you take a look what i pasted?
19:24:26 <Saizan> zbrown: you don't want liftM there
19:24:31 <Saizan> ?type liftM
19:24:33 <stepcut> zbrown: i think you don't need liftM anymore
19:24:33 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:24:46 <zbrown> oh
19:24:53 <zbrown> ok
19:24:53 <stepcut> readLn = liftM read getLine, or something like that ?
19:25:33 <sorear> @tell goltrpoat no layout rule, but aside from that more conformant than the hugs lexer: http://members.cox.net/stefanor/hv/src/lexer.l
19:25:34 <lambdabot> Consider it noted.
19:25:57 <sorear> or, for that matter, the ghc lexer
19:26:18 <stepcut> sorear: have you looked at the jhc haskell parser at all ?
19:26:23 <sorear> stepcut: no
19:26:45 <stepcut> sorear: I think it uses packrat so it can handle some of the wacky haskell rules better...
19:27:14 <sorear> @index i
19:27:15 <lambdabot> bzzt
19:27:17 <sorear> @index d
19:27:17 <lambdabot> bzzt
19:27:18 <stepcut> s/packrat/frisby/
19:27:23 <sorear> @index o
19:27:23 <lambdabot> bzzt
19:27:25 <sorear> @index le
19:27:26 <lambdabot> bzzt
19:27:28 <sorear> @index cas
19:27:28 <lambdabot> bzzt
19:27:36 <sorear> @index the
19:27:37 <lambdabot> bzzt
19:28:02 <kc5tja> @hoogle drop
19:28:02 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
19:28:03 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
19:28:03 <lambdabot> Data.PackedString.dropPS :: Int -> PackedString -> PackedString
19:28:21 <sorear> completion saves the day :(
19:28:23 <sorear> Find file: /usr/local/src/jhc/FrontEnd/HsParser.y
19:28:32 <sorear> ie, happy
19:32:25 <narain> ?instances Arrow
19:32:26 <lambdabot> (->), Kleisli m
19:32:35 <narain> ?src Arrow
19:32:35 <lambdabot> class Arrow a where
19:32:35 <lambdabot>     arr, pure   :: (b -> c) -> a b c
19:32:35 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
19:32:35 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
19:32:35 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
19:32:37 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
19:32:39 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
19:33:22 <glguy> readLn = readIO =<< getLine
19:33:32 <narain> > ((read . head) &&& tail) [1,2,3]
19:33:33 <lambdabot>   add an instance declaration for (Num String)
19:33:33 <lambdabot>     In the expression: 3
19:33:48 <narain> > (head &&& tail) [1,2,3]
19:33:50 <lambdabot>  (1,[2,3])
19:34:10 <Saizan> ?type readIO
19:34:13 <lambdabot> forall a. (Read a) => String -> IO a
19:34:56 <narain> > ((read . head) && tail) ["1","2","3"]
19:34:57 <lambdabot>  Couldn't match expected type `Bool'
19:35:05 <narain> :t read
19:35:07 <lambdabot> forall a. (Read a) => String -> a
19:35:09 <glguy> &&&
19:35:21 <narain> > ((read . head) &&& tail) ["1","2","3"]
19:35:22 <lambdabot>  (1,["2","3"])
19:35:27 <narain> yay
19:35:35 <zbrown> stepcut: With that statement to have xVal re-entered, how would I have it run repeatedly until the condition is satisfied?
19:35:42 <narain> arrows are pretty cool
19:36:14 <hpaste>  kc5tja pasted "IT WORKS!!  Now, how do I add error reporting?  :-)" at http://hpaste.org/921
19:37:21 <stepcut> zbrown: you could make a helper function that calls itself recursively until it gets a satisfactory answer...
19:37:36 <zbrown> stepcut: hmmm thats what i thought, was wondering if there's another way
19:37:42 <stepcut> zbrown: you could also do something higher order
19:37:50 <zbrown> stepcut: higher order?
19:37:56 <stepcut> zbrown: one moment
19:38:44 <zbrown> stepcut: ok
19:45:52 <narain> ?hoogle while
19:45:53 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
19:45:53 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
19:45:53 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
19:46:01 <narain> ?hoogle until
19:46:01 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
19:46:02 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
19:46:36 <dons> you want a loop?
19:46:47 <narain> not really
19:47:06 <narain> i had a vague idea i saw some function with a name like that
19:47:14 <narain> was trying to pinpoint which it was
19:47:19 <narain> don't mind me
19:47:22 <dons> ?docs Control.Monad
19:47:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
19:47:24 <stepcut> narain: there is also 'when'
19:47:26 <dons> :t unless
19:47:28 <dons> :t when
19:47:29 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:47:31 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:48:44 <narain> well thanks anyway
19:49:26 <kc5tja> 19:36 < hpaste>  kc5tja pasted "IT WORKS!!  Now, how do I add error reporting?  :-)" at http://hpaste.org/921
19:49:34 <kc5tja> Anyone have any ideas on how to properly propegate error conditions?
19:50:04 <kc5tja> My best guess right now is to *somehow* wrap everything into something like an Either-type.  But, I'm wondering if others have any better ideas.
19:50:21 <kc5tja> The problem I have with Either is that "left" and "right" aren't exactly self-documenting.
19:50:39 <sorear> they're as good as any other pair, since Either is symmetric
19:50:46 <heatsink> We normally use Left for errors.
19:50:47 <dons> the docs are self documenting though.
19:50:52 <sorear> and anyway there is an unwritten convention
19:50:56 <dons> ?docs Data.Either
19:50:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
19:51:03 <sorear> Right for right (correct) values
19:51:07 <dons> which has the convention written down :-)
19:51:16 <heatsink> Was there an Either monad?
19:51:18 <kc5tja> dons: The idea is to write code to, preferably, eliminate the need to consult the docs.
19:51:26 <dons> ?src Either >>=)
19:51:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:51:34 <narain> ?instances Monad
19:51:35 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:51:46 <stepcut> zbrown: hrm, I think an explicit recursive loop might be the best way to go...
19:51:46 <dons> the idea of a 2-element sum type is very general though
19:51:46 <dons> at least L
19:51:47 <fuzan> any experienced gtk2hs'rs around now? :)
19:52:06 <dons> at least Left/Right are better than InL InR used in other languages
19:52:18 <dons> ?src Either (>>=)
19:52:19 <lambdabot> Left  l >>= _ = Left l
19:52:19 <lambdabot> Right r >>= k = k r
19:52:44 <heatsink> Is there a predefined monad equivalent of (<<<)?
19:53:00 <stepcut> sorear: I guess he never finished --> http://www.mail-archive.com/peg%40lists.csail.mit.edu/msg00019.html
19:53:02 <lambdabot> Title: [PEG] haskell layout rule, http://tinyurl.com/23tpp4
19:53:49 <stepcut> how about an Either bifunctor ?
19:54:24 <sorear> stepcut: is that his revised layout rule?
19:54:42 <stepcut> sorear: dunno
19:55:11 <heatsink> stepcut, meaning it's a functor in both types?
19:55:19 <sorear> ah ok...
19:55:27 <chessguy> hi haskellers
19:55:36 <sorear> stepcut: i'm implementing john's proposal for a revised layout rul
19:55:37 <heatsink> hi, chesser.
19:55:41 <stepcut> heatsink: yeah, it think it was in bananes, barbwire, and lenses
19:55:49 * chessguy gets back from his haskell job interview
19:56:05 <fuzan> haskell job interview? cool! :)
19:56:34 <fuzan> I bet they don't ask questions like, "how would one reverse the letters in each word of a sentence?"
19:56:41 <heatsink> :D
19:56:53 <heatsink> or "How do you count the number of bits in a 32-bit integer?"
19:57:20 <stepcut> heatsink: class Bifunctor bf where bimap :: (a -> b) -> (c -> d) -> (bf a c) -> (bf b d)
19:57:49 <fuzan> heatsink: how does one do that? repeatedly divide by the largest power of two and then maybe add 1?
19:57:56 <chessguy> more like "which is bigger, the number of 8-letter strings, or the number of stars in the galaxy?"
19:57:59 <fuzan> havn't seen that question :)
19:58:02 <stepcut> (+1) `bimap` (toUpper) (Left 1), (+1) `bimap` (toUpper) (Right 'c')
19:58:40 <chessguy> they didn't know the answer, just thought it was an interesting question, lol
19:58:55 <sorear> stepcut: http://haskell.org/pipermail/haskell-cafe/2006-December/020155.html
19:58:56 <lambdabot> Title: [Haskell-cafe] New Layout Rule take 2, http://tinyurl.com/2uafq5
19:58:57 <fuzan> ascii string?
19:59:14 <chessguy> 26 letters
19:59:25 <sorear> > 26^8
19:59:26 <lambdabot>  208827064576
19:59:30 <fuzan> 26^8 > number of stars in galaxy?
19:59:33 <fuzan> who knows. heh
19:59:42 <sorear> > 26^8 / 80000^3
19:59:43 <lambdabot>  4.078653605e-4
19:59:44 <desp> is there a way to pretty-print Haskell code?
19:59:45 <chessguy> none of us knew how many stars there were in the galaxy
19:59:54 <narain> 10^11 i think
20:00:04 <sorear> well, the afair the galaxy is 80k lyears wide
20:00:06 <fuzan> The exact number of stars in our Milky Way Galaxy is virtually impossable to determine, but best estimates put the number at over 100 billion stars.
20:00:13 <dons> desp, yes, the Language.Haskell module
20:00:15 <fuzan> not sure how true it is.
20:00:17 <sorear> > log $ 26^8
20:00:18 <dons> in the haskell-src librry
20:00:19 <lambdabot>  26.064772304171857
20:00:21 <sorear> > log10 $ 26^8
20:00:22 <lambdabot>   Not in scope: `log10'
20:00:28 <narain> > log 10
20:00:29 <sorear> > log 10
20:00:31 <lambdabot>  2.302585092994046
20:00:31 <lambdabot>  2.302585092994046
20:00:42 <narain> > log (26^8) / log 10
20:00:44 <lambdabot>  11.319786783766544
20:00:45 <sorear> so, more stars.
20:00:47 <sorear> barely
20:00:51 <dons> ?pretty let x = 1 ; y = 2 in x + y -- we ue it here, desp.
20:00:51 <lambdabot> "Unterminated end-of-line comment" at column 26
20:00:58 <heatsink> fuzan, there are some tricks to count bits in an integer fast.  The straightforward way is just to loop (shift right 1; if odd then increment count)
20:01:01 <desp> dons: thanks
20:01:30 <fuzan> heatsink: yah, that way's pretty obvious.
20:01:31 <chessguy> let's see, what other good questions were there? this was a good one, "if you want to keep a whole collection of ordered elements in sorted order, but be able to add to and delete from it in log n time, what data structure would you use?"
20:01:36 <desp> dons: I'm a real Haskel n00b; can you tell me how to feed a file into the pretty printer?
20:01:38 <sorear> i'm familiar with the smasher
20:01:43 <dons> ?pretty let x = 1 ; y = 2 in x + y
20:01:44 <lambdabot>  i = let x = 1
20:01:44 <lambdabot>          y = 2
20:01:44 <lambdabot>        in x + y
20:01:49 <narain> fuzan,heatsink: there's a trick to do it in O(no of on bits)
20:02:08 <dons> desp, yep. hang on ....
20:02:11 <narain> which is ridiculously pointless
20:02:22 <dons> desp, http://www.haskell.org/haskellwiki/Indent
20:02:23 <lambdabot> Title: Indent - HaskellWiki
20:02:27 <desp> dons: thanks
20:02:31 <fuzan> narain: not if you had HUGE integer sizes.
20:02:33 <dons> desp, see sectoin 1.4
20:02:41 <narain> fuzan: ok, here goes then
20:02:42 <dons> note you'll need to get haskell-src from hackage
20:02:43 <dons> ?where hackage
20:02:44 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
20:03:07 <narain> n & (n - 1) is 0 iff n is 0 or a power of two
20:03:11 <narain> for unsigned n
20:03:33 <narain> so... hmm how did it go after that
20:03:42 <sorear> > let smash x = x .&. 0x55555555 + ((x `shiftR` 1) .&. 0x55555555) ; foo = smash.smash.smash.smash.smash in foo 100  -- narain, 20 arith ops and 0 conditional branches
20:03:43 <lambdabot>  Add a type signature
20:03:54 <sorear> > let smash x = x .&. 0x55555555 + ((x `shiftR` 1) .&. 0x55555555) ; foo = smash.smash.smash.smash.smash in foo (100 :: Int32)  -- narain, 20 arith ops and 0 conditional branches
20:03:56 <lambdabot>  84
20:04:13 <sorear> well, obviously I got something a little wrong :)
20:04:22 <narain> i love the smash.smash.smash.smash.smash :)
20:04:23 <sorear> but the algorithm is sound, I've used it before
20:04:41 <sorear> anyway, narain
20:04:55 <sorear> bits (n & (n - 1)) = bits n - 1
20:05:04 <mauke> > sum . map digitToInt . showIntAtBase 2 intToDigit 123 $ ""
20:05:05 <lambdabot>  6
20:05:31 <narain> sorear: right, that's the invariant involved
20:05:35 <sorear> > let narbits 0 x = x; narbits n x = narbits (n .&. (n - 1)) (1+x) in narbits 100 1
20:05:35 <jcreigh> is there a useful application for knowing how many bits are on in a some number?
20:05:36 <lambdabot>  Add a type signature
20:05:43 <sorear> > let narbits 0 x = x; narbits n x = narbits (n .&. (n - 1)) (1+x) in narbits (123::Int32) 1
20:05:44 <lambdabot>  7
20:05:46 <sorear> jcreigh: yes
20:05:47 <fuzan> any gtk2hs users present?
20:06:01 <chessguy> jcreigh: sure there is
20:06:07 <sorear> jcreigh: life algorithm, bitmap storage.  how many on cells?  bitcounting is the inner loop
20:06:32 <fuzan> isn't it somewhat useless in life algorithm?
20:06:39 <sorear> jcreigh: actually the life program I hacked used a memo table Int16 -> Int8 initialized at startup
20:06:44 <chessguy> i know a chess usage for having that ability right off the top of my head
20:06:52 <sorear> fuzan: no, it's very useful in life algorithm
20:06:57 <stepcut> chessguy: so, I actually do need to keep a whole collection of ordered elements in sorted order, and being able to add and delete from it in log n time sounds good to me. What data structure should I use ?
20:07:12 <zbrown> stepcut: how would i do an explicit recursive loop?
20:07:20 <chessguy> stepcut: good question :)
20:07:25 <zbrown> stepcut: sorry, lost my internet conn
20:07:25 <chessguy> i got it right. can you
20:07:30 <sorear> stepcut: Map
20:07:34 <sorear> er, Set
20:07:45 <chessguy> by the way, it's actually amortized log n
20:07:56 <fuzan> you only have 8 possible cells that could contain neighbors limited to ranges of three elements long
20:08:17 <sorear> chessguy: Map is absolute log n
20:08:19 <fuzan> xxx \ xmx \ xxx
20:08:27 <narain> chessguy: is it a skip list?
20:08:32 <stepcut> chessguy: I would just ask on #haskell
20:08:35 <fuzan> wouldn't it just be quicker to map the possible values to integers?
20:08:38 <chessguy> narain: no
20:08:43 <sorear> fuzan: we're talking population here, not neighbors
20:08:50 <chessguy> sorear: how is it implemented?
20:08:58 <sorear> fuzan: how many cells is generation 2^128 of metacatacryst?
20:09:07 <chessguy> finger trees?
20:09:18 <sorear> chessguy: Map uses finger trees, yes
20:09:30 <fuzan> sorear: ah, i see.
20:09:32 <sorear> chessguy: but that's not part of the spec
20:09:42 <narain> chessguy: a skip list does have log n operations as far as i recall
20:09:47 <chessguy> ok, well i didn't know enough about finger trees to talk about them, so i mentioned an amortized log n way
20:09:48 <narain> what's a finger tree?
20:10:17 <narain> that's gotta be one of the most disturbing names in computer science
20:10:18 <sorear> narain: not really important here.  yet another variation of strongly self-banalancing bst
20:10:25 <fuzan> i don't see a reason to count population other than accumalating it during a cycle
20:10:36 <hpaste>  stepcut pasted "recursively check value until a good one is found" at http://hpaste.org/922
20:10:40 <sorear> @quote narain [on finger trees] that's gotta be one of the most disturbing names in computer science
20:10:40 <lambdabot> No quotes match. The more you drive -- the dumber you get.
20:10:43 <chessguy> the solution i came up was 2-3 trees
20:10:47 <sorear> fuzan: you don't need a reason
20:11:01 <sorear> fuzan: counting total pop is a very popular end in itself
20:11:01 <stepcut> zbrown: not very fancy, but it does the job ;)
20:11:23 <chessguy> also, splay trees
20:11:24 <sorear> fuzan: it's like asking "I don't see a need for paintings"
20:11:29 <narain> sorear: you mean @quote+? i finally say something interesting on #haskell and it gets misquoted
20:11:34 <kc5tja> @google 8 ways error
20:11:38 <lambdabot> http://www.nightingale.com/tAE_Article~A~TurnObstaclesintoOpportunities~i~230.asp
20:11:38 <lambdabot> Title: 8 Ways to Turn Obstacles into Opportunities
20:11:39 <fuzan> sorear: i don't mean reason, i mean. i don't see why'd you count the population of a generation other than accumulating it during the calculation from the previous generation.
20:11:40 <sorear> @remeber narain [on finger trees] that's gotta be one of the most disturbing names in computer science
20:11:40 <lambdabot> Done.
20:11:45 <zbrown> stepcut: well fancy isn't important but that'll do ;)
20:11:51 <narain> whee
20:12:03 <kc5tja> @hoogle 8 ways to handle errors
20:12:04 <lambdabot> Hoogle Error: Parse Error: Unexpected character '8 ways to '
20:12:08 <kc5tja> @google 8 ways to handle errors
20:12:11 <lambdabot> http://www.code-magazine.com/Article.aspx?quickid=0301072
20:12:11 <lambdabot> Title: CoDe Magazine - Article: Structured Error Handling in VFP 8
20:12:14 <sorear> fuzan: because (a) you don't always need the pop, only at intervals (b) thhere are very fancy algorithms
20:12:17 <kc5tja> @google 8 ways to handle errors Haskell
20:12:20 <lambdabot> http://nedbatchelder.com/text/exceptions-vs-status.html
20:12:20 <lambdabot> Title: Ned Batchelder: Exceptions vs. status returns
20:12:32 <sorear> kc5tja: it's a couple days old.  do you really think it's in google yet?
20:12:32 <kc5tja> bugger -- I lost the link.
20:12:39 <chessguy> oh, red-black trees are absolute log n too
20:12:44 <sorear> randomhacks.net
20:12:50 <sorear> kc5tja: ^
20:12:53 <sorear> top article
20:13:00 <kc5tja> sorear: Yes.  You'll be amazed at how fast the spider at Google is sometimes.
20:13:09 <dons> sorear: a couple of *hours* old
20:13:28 <kc5tja> OK, it's not that fast.  :)
20:13:28 <dons> http://programming.reddit.com/goto?id=19d4u
20:13:35 <lambdabot> Title: 8 ways to report errors in Haskell
20:14:22 <dons> as usual its already on our blog article page
20:14:28 <dons> ?google Haskell blog articles
20:14:29 <lambdabot> http://haskell.org/haskellwiki/Blog_articles
20:14:30 <lambdabot> Title: Blog articles - HaskellWiki
20:14:44 <dons> that page is a little underutilised, but i do keep it up to date
20:15:30 <dolio> It's at the top of Planet Haskell, too.
20:15:36 <dons> ah yes
20:18:41 <narain> :t unfoldr
20:18:44 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:19:34 <dolio> So the #1 article of interest in programming at the moment is a home-built one-wheel segway skateboard? :)
20:21:59 <emu> don't take too much stock in reddit
20:22:10 <dolio> :) I don't.
20:22:27 <emu> especially dot-com stock :/
20:22:40 <emu> i haven't figured out their business plan
20:22:52 <narain> has anyone felt the need for a HOF of type  (a -> b -> (c,a)) -> a -> [b] -> ([c],a) ? fold a value of type  a  through a list of  b  and collect a list of  c
20:23:22 <heatsink> :t mapAccumL
20:23:25 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
20:23:34 <heatsink> :t mapAccumR
20:23:35 <narain> brilliant
20:23:37 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
20:23:43 <heatsink> :)
20:23:47 <narain> thanks! :)
20:23:49 <emu> @yow
20:23:50 <lambdabot> In 1962, you could buy a pair of SHARKSKIN SLACKS, with a "Continental
20:23:50 <lambdabot> Belt," for $10.99!!
20:24:07 <narain> ?index mapAccumL
20:24:08 <lambdabot> Data.List
20:24:17 <dons> dolio: the main problem is cross posting 'tech' articles onto the programming reddit
20:24:20 <dons> and the main page
20:24:26 <dons> which means whatever it is will be in the top 2 or 3 articles
20:24:36 <dons> i'd like to be able to filter articles that are aslo on the main reddit page
20:24:53 <narain> ?src mapAccumL
20:24:54 <lambdabot> mapAccumL _ s []        =  (s, [])
20:24:54 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
20:24:54 <lambdabot>    where (s', y ) = f s x
20:24:54 <lambdabot>          (s'',ys) = mapAccumL f s' xs
20:25:08 <narain> ?src mapAccumR
20:25:08 <lambdabot> Source not found. Are you on drugs?
20:25:40 <hyrax42> question: statically linking libraries, possible?
20:25:59 <hyrax42> and runtime
20:26:02 <hyrax42> and everything
20:26:11 <sorear> i think so
20:26:19 <sorear> -optl-static work?
20:26:47 <hyrax42> sorear, thanks, will check
20:27:02 <hyrax42> just realised I'm going to be handing a binary, and all the libs I'm going to use are in my $HOME
20:28:00 <sorear> looks like:
20:28:00 <sorear> -static      statically link haskell libs (this is the only option except on osx)
20:28:00 <sorear> -optl-static statically link c libs
20:28:50 <hyrax42> os x has -optl-static?
20:28:56 <hyrax42> or doesn't
20:29:09 <hyrax42> or never mind I'll work it out
20:29:15 <sorear> all systems have both (assuming a reasonable linker)
20:29:29 <sorear> osx is the only one where -static means something
20:29:45 <sorear> on !osx systems, dynamic linking of haskell libs is unimplemented
20:29:54 <sorear> (that's why your binaries are so big)
20:30:39 <kc5tja> 256KB for my CutParse, CutFiles, and Main modules combined.
20:30:49 <kc5tja> From about 4KiB of source code.  ;D
20:31:33 <sorear> yhc and jhc make small binaries
20:31:49 <sorear> hv will also produce little output, but it doesn't count
20:32:18 <narain> curses! why does haskell always allow the possibility to make everything so darned elegant
20:32:33 <sorear> we even fixed that
20:32:49 <narain> i have this function i have to write which i could have written with case analysis and explicit recursion in a pinch
20:33:08 <sorear> curses?  there's a virtually pure haskell replacement for that.  slow, but nice and pretty
20:33:21 <narain> instead i'm trying to find a way to express it succinctly using folds, scans and/or unfolds
20:33:23 <sorear> @remember narain curses! why does haskell always allow the possibility to make everything so darned elegant
20:33:23 <lambdabot> Done.
20:33:38 <narain> aaargh
20:34:34 <petekaz> ?seen dons
20:34:35 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 9m 58s ago.
20:34:56 <narain> sorear: what did you fix?
20:35:19 <sorear> narain: ?
20:35:33 <narain> <sorear> we even fixed that
20:35:37 <narain> i guess you werent talking to me
20:35:45 <narain> nm then
20:35:51 <sorear> <*narain> curses! why does h...
20:36:06 <sorear> curses is also a very crufty terminal interface library
20:36:08 <narain> that was "fixed"? :)
20:36:16 <narain> oh libcurses you mean
20:36:31 <narain> heh
20:36:50 <dons> petekaz: ?
20:37:37 <fantasma> ?seen fantasma
20:37:38 <lambdabot> You are in #haskell. I last heard you speak just now.
20:38:00 <petekaz> dons: I changed my program to use bytestrings (the program that reads the contents of a maildir), lazy worked best.
20:38:28 <petekaz> unfortunately, it seems that readFile in ByteString cannot read from named pipes.
20:39:07 <petekaz> I have one named pipe in my maildir as a test case which when read from is infinite.  I wanted to see strict and lazy bytestrings work as advertised.
20:39:37 <dons> named pipes eh? hmm
20:39:52 <dons> 'infinite' meaning what?
20:40:09 <petekaz> regular haskell strings and readfile handle it fine.  It was just neat to see haskell laziness work.
20:40:36 <MarcWebe1> Yeah. From now on I have type signatures in vim completion, too ! *smile*
20:40:37 <dons> oh, you wanted to tried to strictly read the contenst of the pipe?
20:41:39 <petekaz> I have a Maildir (maildir format - thus one mail message per file).  In that dir, is a bunch of emails.  My program just summarizes the threads and senders.  So to do that, there is no need to read the whole file, and in an imperative language, I would code explicitly NOT to read the entire file, just the headers.
20:42:03 <dons> right. so did you use lazy bytestrings too then?
20:42:23 <petekaz> In haskell, I coded it to parse the whole file, headers and body, but because the rest of the program only uses the headers, it was exciting for me to see readFile stop reading the file.
20:42:23 <MarcWebe1> Anyone wants to try ? I'd like to share.
20:42:34 <dons> petekaz: cool.
20:42:35 <petekaz> But I was still able to code in a natural manner.
20:42:44 <petekaz> yes .. lazy worked best.
20:43:12 <petekaz> and to test it all, I have a named pipe in the dir as well, when you read from it, you get mail hearders, then an infiinte body.
20:43:32 <petekaz> So if haskell was doing things right, it shouldn't hang on that file.
20:43:43 <petekaz> And it was exciting to see that as well.
20:43:52 <petekaz> But I couldn't do the same test with ByteStrings.
20:44:25 <petekaz> loosk like you call hFileSize in ByteString library.
20:44:51 <petekaz> no big deal.
20:45:34 <desp> 1ungh
20:45:46 <desp> I'm working through the "Write Yourself a Scheme in 48 hours" tutorial
20:46:00 <kc5tja> Is there a way, in an if construct, to deconstruct a data type?
20:46:04 <desp> and I think I just confused myself permanently
20:46:20 <desp> I need a potion or something
20:46:20 <fax> kc5tja: case (somthing) of .. type thing?
20:47:07 <narain> @quote potion
20:47:08 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
20:47:12 <sorear> don't worry, HConfused is a fixnum, it can't hold infinite numbers
20:47:23 <hpaste>  petekaz annotated "Program to summarize contents of a Maildir (mailbox format)" with "Lazy ByteString version" at http://hpaste.org/902#a2
20:47:39 <sorear> and I don't think there is code for handling the HConfused & FROMOUTSIDE case at all
20:47:55 <desp> hah
20:48:12 <narain> desp: what's the problem?
20:48:41 <sorear> but then, I only know 3.4.3
20:48:56 <desp> the monad syntax
20:49:06 <narain> do-notation?
20:49:38 <petekaz> So one final question with regards to this program.  I can't run it on a directory that has more than 1024 files (my current ulimit setting).  It seems that readFile never closes the file.  Is there a way to make this happen?
20:49:38 <desp> thing is, I implemented my own monadic parsers in SML and OCaml, so it's not like the concept is new to me
20:49:57 <fuzan> gtk2hs users? I'm stumped!
20:50:22 <sorear> System.Mem.performGC I'm afraid
20:50:26 <dons> petekaz: hClose each file handle after you've read it
20:50:37 <dons> so read one file at a time, as you're done with that, hClose the handle
20:50:43 <narain> desp: well then. you're clearly ahead of me
20:50:44 <petekaz> dons: I use readFile, so I don't have a handle.
20:51:12 <desp> narain: but then I knew what exactly the monadic type was composed of :)
20:51:27 <narain> desp: which section are you on in Write Yourself a Scheme?
20:51:33 <petekaz> sorear: is that comment for me?
20:51:33 <dons> forM_ (files) $ do h <-openFile "f" ;  src <- hGetContents h ; let t =  process src ; t `seq` hClose h
20:51:34 <desp> http://halogen.note.amherst.edu/%7Ejdtang/scheme_in_48/tutorial/errorcheck.html
20:51:37 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/22bjvn
20:51:52 <sorear> petekaz: yes
20:52:27 <desp> I think my brain shot itself at "numericBinop op params = mapM unpackNum params >>= return . Number . foldl1 op"
20:52:34 <petekaz> sorear: so in http://hpaste.org/902 the function emailsInDirectory, I should put this call in there?
20:53:19 <sorear> petekaz: inside the mapM
20:53:32 <sorear> but beware, performGC is a pretty big hammer
20:53:36 <petekaz> ok .. I'll give that a try.
20:53:38 <petekaz> oh.
20:54:02 <sorear> it should force all finalizer to run, thus closing your lazy stream
20:54:05 <desp> is this tutorial up to date in terms of using the currently accepted style of coding?
20:54:14 <sorear> but in the process it traces every single cell in your program
20:54:19 <petekaz> Maybe if I call it only every 100 files?
20:54:34 <dons> petekaz: i'd really just hClose explicitly
20:54:38 <dons> rather than relying on the GC
20:54:43 <dons> possibly performGC works
20:54:59 <petekaz> dons: ok.
20:55:01 <dons> strictly force the result of your processing of each file, then hClose, and continue
20:55:03 <narain> desp: i don't fully understand that either
20:55:26 <petekaz> dons: will I still be able to process that infinitely long file?
20:55:58 <narain> :t mapM
20:56:01 <lambdabot>     Ambiguous occurrence `mapM'
20:56:01 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
20:56:08 <narain> :t Control.Monad.mapM
20:56:10 <bd_> heh
20:56:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:56:15 <bd_> @hoogle mapM
20:56:16 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:56:16 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
20:56:16 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
20:56:26 <bd_> @where lambdabot
20:56:27 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:56:42 <desp> perhaps I should try starting with a simpler tutorial
20:56:45 <desp> :)
20:56:45 <sorear> so what does '\v' do to layout?
20:56:46 <fuzan> woot. http://en.wikipedia.org/wiki/Haskell_class_attack_transport
20:57:10 <stepcut> fuzan: nice!
20:57:10 <sorear> i'm implementing the layout rule now :/
20:57:15 <narain> fuzan: awesome
20:57:45 <narain> desp: checking the types of all those scary operators usually aids understanding
20:57:59 <desp> sure
20:58:17 <narain> e.g. i now see what the mapM is doing
20:58:33 <desp> reading "All About Monads" now
20:59:32 <narain> do you want to walk through  mapM unpackNum params >>= return . Number . foldl1 op  right now?
20:59:47 <kc5tja> OK, implemented some limited error reporting ability -- enough to be useful.
20:59:53 <narain> ?src mapM
20:59:53 <lambdabot> mapM f as = sequence (map f as)
20:59:57 <kc5tja> But, man, is it a hack!
21:00:09 <desp> narain: well, if you could spare a moment, sure
21:00:31 <kc5tja> Everything was all nice and algebraic up until errors were introduced.  :(
21:00:49 <kc5tja> But, the nice thing is, everything type-checks, and I'm very pleased that the thing runs exactly as expected.
21:01:01 <narain> desp: ok,  mapM unpackNum params  takes  unpackNum :: LispVal -> ThrowsError Integer  and  params :: [LispVal]
21:01:35 <narain> desp: and maps  unpackNum  on each param and does some magic so that instead of  [ThrowsError Integer]  you get  ThrowsError [Integer]
21:01:56 <narain> i have no idea how :)
21:02:30 <narain> desp: now we're working in the  ThrowsError  monad
21:02:59 <narain> desp: so we pipe that into  (>>= return . Number . foldl1 op)
21:03:35 <narain> desp: i.e. we had a  ThrowsError [LispVal]  and we fed this via  (>>=)  into  return . Number . foldl1 op
21:03:43 <desp> getting it now, thanks
21:04:09 <desp> I got stuck on the magic bit
21:04:45 <narain> yeah, i hadn't given that bit too much thought when i read it
21:05:04 <narain> i only realised that magic is afoot when i checked the type of  mapM  jsut now
21:08:07 <narain> ?src take
21:08:07 <lambdabot> take n _      | n <= 0 =  []
21:08:08 <lambdabot> take _ []              =  []
21:08:08 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
21:09:36 <fax> >  [(x,y) | x <- [1,2,3] , y <- [1,2,3], x /= y]
21:09:38 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
21:10:14 <fax> >  [(x,y) | x <- [1..] , y <- [1..], x*y=360]
21:10:15 <lambdabot>  Parse error
21:10:26 <narain> ==
21:10:30 <fax> >  [(x,y) | x <- [1..] , y <- [1..],x*y==360]
21:10:34 <lambdabot> Terminated
21:10:39 <fax> :[
21:11:03 <fax> >  [(x,y) | x <- [1..] , y <- [1..],x*y==2]
21:11:07 <lambdabot> Terminated
21:11:11 <narain> > head [(x,y) | x <- [1..] , y <- [1..],x*y==360]
21:11:12 <lambdabot>  (1,360)
21:11:23 <narain> > take 2 [(x,y) | x <- [1..] , y <- [1..],x*y==360]
21:11:27 <lambdabot> Terminated
21:11:33 <fax> :/
21:12:03 <narain> clearly we want a diagonal enumeration instead
21:12:07 <fax> yeah
21:13:16 <narain> > [(x,y) | n <- [1..], x <- [1..n], y = n-x+1, x*y==360]
21:13:16 <lambdabot>  Parse error
21:13:28 <narain> > [(x,y) | n <- [1..], x <- [1..n], y <- [n-x+1], x*y==360]
21:13:32 <lambdabot> Terminated
21:13:36 <narain> > take 1 [(x,y) | n <- [1..], x <- [1..n], y <- [n-x+1], x*y==360]
21:13:38 <lambdabot>  [(18,20)]
21:13:40 <narain> > take 2 [(x,y) | n <- [1..], x <- [1..n], y <- [n-x+1], x*y==360]
21:13:42 <lambdabot>  [(18,20),(20,18)]
21:13:46 <narain> > take 5 [(x,y) | n <- [1..], x <- [1..n], y <- [n-x+1], x*y==360]
21:13:48 <lambdabot>  [(18,20),(20,18),(15,24),(24,15),(12,30)]
21:13:56 <fax> :D
21:14:14 <narain> why does it terminate rather than lazily evaluating a prefix?
21:14:40 <narain> i mean, if i don't use take
21:15:32 <hpaste>  petekaz annotated "Program to summarize contents of a Maildir (mailbox format)" with "How do I force parseEmail to execute so I can hClose my handle?" at http://hpaste.org/902#a3
21:15:34 <narain> :t mapAccumL
21:15:36 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:17:15 <fax> > mvLift (*) [1..] [1..]
21:17:16 <lambdabot>   Not in scope: `mvLift'
21:17:23 <fax> > mvLift2 (*) [1..] [1..]
21:17:24 <lambdabot>   Not in scope: `mvLift2'
21:17:38 <narain> liftM2?
21:17:39 <petekaz> dons: how do I force the hClose to take place?  Do I use seq somehow?  I tried a few variants but still get the max open file descriptor error.
21:17:47 <narain> ?src init
21:17:47 <lambdabot> init [x]    = []
21:17:48 <lambdabot> init (x:xs) = x : init xs
21:17:48 <lambdabot> init []     = undefined
21:17:50 <petekaz> (see my annotation)
21:17:51 <narain> ?src inits
21:17:52 <lambdabot> inits []     =  [[]]
21:17:52 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
21:18:07 <fax> > inits []
21:18:09 <lambdabot>  [[]]
21:18:23 <fax> > inits $ inits []
21:18:24 <lambdabot>  [[],[[]]]
21:19:00 <narain> :t inits
21:19:03 <lambdabot> forall a. [a] -> [[a]]
21:19:10 <narain> ?hoogle [a] -> [[a]]
21:19:11 <lambdabot> List.inits :: [a] -> [[a]]
21:19:11 <lambdabot> List.tails :: [a] -> [[a]]
21:19:11 <lambdabot> List.group :: Eq a => [a] -> [[a]]
21:19:12 <Lemmih> petekaz: Let the GC cloce the handle or use strict IO.
21:19:24 <fax> > let initsN n = if n = 0 inits else inits $ initsN (n-1) in initsN 5 []
21:19:24 <lambdabot>  Parse error
21:19:27 <fax> :/
21:19:40 <fax> > let initsN n = if n == 0 inits else inits $ initsN (n-1) in initsN 5 []
21:19:40 <lambdabot>  Parse error
21:20:03 <petekaz> Lemmih: the whole point of my program was to take advantage of the fact that haskell won't bother reading the entire file.  I parse a directory full of hundreds of files (emails).
21:20:47 <fax> > (inits $ fold (repeat inits)) []
21:20:48 <lambdabot>   Not in scope: `fold'
21:20:56 <petekaz> I thought dons had implied there was some other solution, but perhaps I misunderstood.
21:21:41 <fax> > (inits $ pleasefold (repeat inits)) []
21:21:42 <lambdabot>   Not in scope: `pleasefold'
21:21:51 <sorear> @let x = 2
21:21:53 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
21:21:59 <sorear> @botsnack
21:21:59 <lambdabot> :)
21:22:10 <narain> ?help botsnack
21:22:11 <Lemmih> petekaz: Lazy IO is a can of worms. Make one subtle mistake and everything will go to hell.
21:22:11 <lambdabot> botsnack. Feeds the bot a snack
21:22:29 <narain> ?botsnack
21:22:29 <lambdabot> :)
21:22:41 <narain> amusing
21:23:38 <desp> http://www.haskell.org/all_about_monads/html/analogy.html
21:23:39 <lambdabot> Title: A physical analogy for monads
21:23:43 <petekaz> Lemmih: I was very excited about my program then it stopped working when processing directories with more than 1024 (my ulimit) of files.
21:23:45 <desp> can someone help me with this?
21:23:55 <desp> I am greatly confused by the definition of the Tray monad
21:24:00 <desp> instance Monad Tray where Empty        >>= _      = Empty
21:24:06 <desp> why is >>= used here?
21:24:21 <narain> it's defining (>>=)?
21:24:57 <desp> ahh.
21:26:46 <narain> are there ways to transform an explicitly recursive function step-by-step into one which uses a standard HOF for recursion?
21:26:59 <narain> other than staring hard at it and waiting for a flash of insight, i mean
21:27:04 <desp> :)
21:28:28 <desp> do you have a specific function you want to transform?
21:28:37 <narain> yes...
21:28:54 <desp> can I take a look?
21:28:55 <narain> hang on
21:31:16 <narain> desp: i just lost the definition, i'll have to write it again
21:31:24 <narain> desp: i'll get back to you
21:31:44 <desp> :)
21:31:49 <desp> sorry about that
21:32:16 <narain> yeah, i'd written it in a temp buffer which i accidentally erased
21:33:58 <dmwit> ?google HOF
21:34:00 <lambdabot> http://www.profootballhof.com/
21:34:00 <lambdabot> Title: Home Page - Pro Football Hall of Fame
21:34:09 <dmwit> I'm guessing that's not it...
21:34:33 <narain> let take2 0 lists = ([], lists); take2 n lists = let list = head lists; (array, rest) = take2 (n - length list) (tail lists) in if (n < length list) then (take n list, drop n list : tail lists) else (list ++ array, rest) in take2 10 [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
21:34:39 <Lemmih> petekaz: Relying on laziness, or lack thereof, can be (like most other incarnations of black magic) dangerous if not weirded correctly.
21:34:40 <narain> ugh
21:34:45 <narain> > let take2 0 lists = ([], lists); take2 n lists = let list = head lists; (array, rest) = take2 (n - length list) (tail lists) in if (n < length list) then (take n list, drop n list : tail lists) else (list ++ array, rest) in take2 10 [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
21:34:47 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[[11,12],[13,14,15,16]])
21:35:00 <narain> dmwit: higher-order function :)
21:35:08 <dmwit> k
21:35:09 <dmwit> =)
21:35:27 <narain> desp: i have a list of lists which i'm trying to do an analogue of  splitAt  on
21:35:42 <narain> hmm, should have called it splitAt2 or something
21:35:58 <dmwit> How about a combination of concat and splitAt?
21:36:18 <narain> because i want to preserve the structure of the remainder
21:36:37 <dmwit> Ah.
21:36:39 <fax> map split?
21:37:22 <narain> that'll split each internal list at n
21:37:33 <fax> what did you want to do?
21:37:53 <narain> i want  splitAt' 10 [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] = ([1,2,3,4,5,6,7,8,9,10], [[11,12],[13,14,15,16]])
21:38:32 <narain> hmm... now that i have it written out it looks like what i'm trying to do is itself ugly
21:38:39 <fax> very.
21:38:43 <narain> but i do need to preserve the list of lists
21:38:52 <narain> *sigh*
21:39:50 <desp> ok, I formatted your function
21:39:59 <desp> so that I can attempt to read it
21:40:08 <narain> @pretty let take2 0 lists = ([], lists); take2 n lists = let list = head lists; (array, rest) = take2 (n - length list) (tail lists) in if (n < length list) then (take n list, drop n list : tail lists) else (list ++ array, rest) in take2 10 [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
21:40:08 <lambdabot>  i = let take2 0 lists = ([], lists)
21:40:09 <lambdabot>          take2 n lists
21:40:09 <lambdabot>            = let list = head lists
21:40:09 <lambdabot>                  (array, rest) = take2 (n - length list) (tail lists)
21:40:09 <lambdabot>                in
21:40:10 <lambdabot>                if (n < length list) then (take n list, drop n list : tail lists)
21:40:12 <lambdabot>                  else (list ++ array, rest)
21:40:14 <lambdabot>        in
21:40:16 <lambdabot>        take2 10
21:40:18 <lambdabot>          [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
21:40:34 <narain> desp: sorry i didn't think of that before
21:40:35 <desp> nifty
21:40:38 <desp> np
21:41:24 <narain> ?index mapM
21:41:25 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
21:42:16 <dmwit> It doesn't seem like the list monad is a very good fit for this problem. =P
21:42:28 <desp> narain: what exactly are you trying to do?
21:42:30 <hpaste>  kc5tja annotated "IT WORKS!!  Now, how do I add error reporting?  :-)" with "Revised, with error handling, AND documentation" at http://hpaste.org/921#a1
21:42:44 <narain> disp: i want  splitAt' 10 [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] = ([1,2,3,4,5,6,7,8,9,10], [[11,12],[13,14,15,16]])
21:42:50 <fax> woah
21:42:56 <fax> that monads thing is cool
21:43:05 <narain> dmwit: i was thinking of using the state monad
21:43:15 <fax> narain: so everything before 10 is concatted together?
21:43:29 <desp> I see.
21:43:41 <narain> fax: it would be fine if it wasn't either, because i can just concat it later
21:43:44 <desp> not before 10, after the 10th place
21:44:14 <desp> I mean; before the 11th place ;)
21:45:40 <narain> it's kind of stateful as in i'm propagating the number of remaining elements across the list
21:45:47 <narain> so a state monad may help
21:46:08 <narain> if only i knew what all those mapM, forM and other things did
21:46:13 <desp> one moment
21:48:02 <narain> ?src mapM
21:48:03 <lambdabot> mapM f as = sequence (map f as)
21:48:28 <dmwit> :t foldr
21:48:31 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:49:32 <narain> :t \x -> (sequence x) :: State Int [a]
21:49:35 <lambdabot>     Ambiguous occurrence `sequence'
21:49:35 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
21:49:42 <narain> :t \x -> (Control.Monad.sequence x) :: State Int [a]
21:49:44 <lambdabot>     Inferred type is less polymorphic than expected
21:49:45 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
21:49:49 <narain> :t \x -> (Control.Monad.sequence x) :: State Int [String]
21:49:52 <lambdabot> State Int [String] :: [State Int String] -> State Int [String]
21:50:01 <narain> :t \x -> (Control.Monad.sequence x :: State Int [a])
21:50:04 <lambdabot>     Inferred type is less polymorphic than expected
21:50:04 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
21:50:07 <narain> :t \x -> (Control.Monad.sequence x :: State Int [String])
21:50:09 <lambdabot> [State Int String] -> State Int [String]
21:50:17 <narain> :t State sequence
21:50:20 <lambdabot>     Ambiguous occurrence `sequence'
21:50:20 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
21:50:24 <fuzan> how does one say that a datatype a is either datatype b, datatype c [, datatype d .. , datatype z ] ?
21:50:28 <narain> :t State Control.Monad.sequence
21:50:30 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a1, a)
21:50:31 <lambdabot>       Expected type: [(a1, a)] -> (a1, [(a1, a)])
21:51:20 <fuzan> i'm trying obvious things, but im running into redefition errors.
21:51:59 <narain> fuzan: data Foo = Bar Int | Baz String
21:52:14 <narain> is that what you mean?
21:52:38 <fuzan> i'm also using record syntax. emacs mode must might be getting confused.
21:53:07 <fuzan> data Object = Ship { foo :: foot } | Asteroid { foo2 :: foot }
21:53:09 <fuzan> valid?
21:53:48 <dmwit> ...better be :: Foot
21:53:48 <narain> i'm not sure you can mix records and algebraic datatypes like that
21:54:00 <fuzan> dmwit: well, of course.
21:54:11 <dmwit> ok, sorry
21:54:29 <narain> i'm not sure, but i'm not positive either
21:54:55 <narain> but i think since  data Object = Object {foo :: Foo}  generates  foo :: Object -> Foo
21:55:09 <narain> that doesn't seem compatible with what you are doing
21:56:35 <narain> you could do  data Ship = Ship {foo :: Foo}; data Object = ShipObj Ship | ...
21:56:56 <fuzan> > yah, I thought of that
21:56:56 <lambdabot>  Parse error
21:57:03 <fuzan> err
21:57:07 <fuzan> thanks, lambdabot!
21:57:13 <narain> that feels ugly though
21:57:18 <fuzan> i agree.
21:57:19 <narain> ?botsnack
21:57:19 <lambdabot> :)
21:57:31 * narain shrugs
21:57:54 <dmwit> narain: My attempt at writing take' using foldl makes it even uglier than yours... =(
21:57:56 <fuzan> trying to do OO design in haskell is difficult for myself :\
21:58:11 <desp> narain: well, I rewrote your function not to use any built-ins http://pastie.textmate.org/46139
21:58:12 <lambdabot> Title: #46139 - Pastie
21:58:24 <narain> dmwit: i appreciate the effort, thanks
21:58:34 <narain> desp: let me have a look
21:59:20 <desp> not sure if that's an improvement, but it should be faster
22:00:17 <Svrog> fuzan: data Object = Ship { foo :: foot } | Asteroid { foo2 :: foot } <-- that should work - i'm assuming you meant Foot - or forgot to type foot after Object
22:00:17 <narain> desp: thanks, i appreciate it
22:00:26 <narain> desp: but that's even more cases :)
22:00:43 <narain> desp: thanks for taking the time though!
22:00:58 <desp> narain: your function is walking the lists needlessly a lot, in length
22:01:04 <fuzan> Svrog: I found it to work, but you cannot instantiate an object by (Ship foo)
22:01:10 <Svrog> in fact since foo and foo2 have the same signature they can both be called foo
22:01:19 <desp> narain: I'm thinking how to fold this down now
22:01:25 <narain> desp: that's true
22:01:30 <fuzan> Svrog: since the only constructor in scope is Object
22:01:50 <fuzan> Svrog: and I was jsut really lazy in defining hte types in my example :)
22:02:21 <Svrog> what do you mean? Ship and Asteroid are constructors
22:02:45 <fuzan> I may have read the error messages incorrectly.
22:04:50 <desp> ?src take
22:04:51 <lambdabot> take n _      | n <= 0 =  []
22:04:51 <lambdabot> take _ []              =  []
22:04:51 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
22:05:06 <narain> desp: i just thought of generating a sequence of [([],[l1,l2,...]), ([l1],[l2,..]), ([l1,l2],[...]), ...] and working with that
22:05:33 <narain> i mean [([],[list1,list2,...]), ([list1],[list2,..]), ([list1,list2],[...]), ...]
22:05:45 <narain> that might simplify things
22:06:02 <desp> would it really?
22:06:44 <narain> well i could pick the first one for which length . concat [list1,list2,...,listn] > n
22:06:49 <narain> it would be slow though
22:06:52 <desp> yep
22:07:40 <fax> how do you
22:08:00 <narain> uncalled-for slowness is a downer indeed, but i can tolerate it more than ugly code
22:08:22 <dmwit> ?t scanl
22:08:23 <Svrog> i was just reading about polyvariadic functions and how to write a function that takes an arbitrary number of parameters and returns a list - how would i go about writing a function that generates a polyvariadic function based on the structure of a tuple?
22:08:23 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
22:08:28 <dmwit> :t scanl
22:08:31 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:09:49 <Svrog> so that gen (a, b) returns a function a -> b -> String for example and gen ((a, b), c) returns a -> b -> c -> String and so on
22:10:17 <desp> take using fold is ugly beyond all doubt
22:10:18 <desp> I give up
22:10:26 <dmwit> ?hoogle scanl
22:10:27 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
22:10:27 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
22:10:30 <desp> however I stand behind what I pastied ;)
22:10:35 <narain> > let splits list = iterate (\(it,len,tl) -> (it ++ head tl, len + length len, tail tl)) ([],0,list) in splits [1..10]
22:10:36 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
22:10:42 <zbrown> Hrm, does anyone else using vim get a 'parse error on input `|'; ?
22:10:51 <zbrown> minus the semi-colon
22:10:52 <narain> > let splits list = iterate (\(it,len,tl) -> (it ++ head tl, len + length $ head tl, tail tl)) ([],0,list) in splits [1..10]
22:10:53 <lambdabot>  Couldn't match expected type `[a] -> Int'
22:10:59 <zbrown> i can't get vim to work with Guards for some reason
22:11:14 <desp> so is fail a required function for monads?
22:11:20 <narain> > let splits list = iterate (\(it,len,tl) -> (it ++ head tl, len + length $ head tl, tail tl)) ([],0,list) in splits $ replicate 10 [1..10]
22:11:21 <lambdabot>  Couldn't match expected type `[a] -> Int'
22:11:38 <narain> desp: thank you
22:12:07 <narain> > let splits list = iterate (\(it,len,tl) -> (it ++ head tl, len + length (head tl), tail tl)) ([],0,list) in splits $ replicate 10 [1..10]
22:12:08 <lambdabot>  [([],0,[[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]...
22:12:18 <narain> > let splits list = iterate (\(it,len,tl) -> (it ++ head tl, len + length (head tl), tail tl)) ([],0,list) in splits $ replicate 3 [1..3]
22:12:20 <lambdabot>  Exception: Prelude.head: empty list
22:12:21 <kc5tja> Actually, being familiar with J, I find folds to be pretty natural.  Only the name confused me at first.  I still think it's a bad name.  :)
22:12:54 <ddarius> Svrog: Simply use a class
22:13:03 <kc5tja> :t map
22:13:06 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:13:35 <desp> hmm
22:13:44 <desp> ERROR "monad.hs":3 - Illegal type in class constraint
22:14:35 <desp> ah. I needed module Main
22:14:38 <ddarius> kc5tja: I'm just wondering, what name would you find more appropriate?
22:14:41 <desp> to subclass Show
22:14:46 <desp> is that right?
22:14:59 <desp> no.
22:15:13 <Svrog> ddarius: im trying to
22:15:21 <desp> what's wrong with http://pastie.textmate.org/46141 ?
22:15:22 <lambdabot> Title: #46141 - Pastie
22:15:46 <Svrog> but i keep getting fundep conflicts between instances heh
22:16:16 <kc5tja> ddarius: accumulateL or accumulateR would be good choices, but are lengthy.
22:16:52 <dmwit> ?where paste
22:16:53 <lambdabot> http://hpaste.org/new
22:16:53 <kc5tja> overl or overr are other choices; for example: sumOver ns = overr (+) 0 ns
22:17:30 <kc5tja> and instead of foldl1 and foldr1, I'd use betweenl and betweenr.
22:17:35 <narain> desp: maybe  instance Show (Option x) ?
22:17:43 <kc5tja> sumOver2 ns = betweenl (+) ns
22:17:53 * kc5tja shrugs -- kind of a moot point now.
22:18:07 <fax> monads
22:18:10 <fax> tutorials?
22:18:13 <ddarius> kc5tja: accumulate would make a good name for foldl,but not foldr in my opinion, I find over* more confusing than fold*.  between* is ok.
22:18:15 <narain> desp: instance (Show x) => Show (Option x)
22:18:43 <desp> narain: wow, thanks.
22:19:01 <hpaste>  dmwit pasted "take2 :: Int -> [[a]] -> ([a], [[a]]) -- another method" at http://hpaste.org/923
22:19:16 <dmwit> Not necessarily a good method, just a different one. ;-)
22:19:54 <desp> map, scan, zip, span, split, splat...
22:20:08 <desp> :)
22:20:10 <narain> dmwit: hey, that looks good
22:20:53 <narain> neat, it works
22:20:57 <dmwit> Hmmm, there's a bit of a wart with it, though.
22:21:25 <dmwit> Try take2 3 [[1, 2, 3], [4, 5, 6]]
22:21:25 <dmwit> ==> ([1, 2, 3], [[], [4, 5, 6]])
22:22:43 <narain> hmm
22:22:55 <narain> what's span?
22:22:57 <narain> :t span
22:23:00 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
22:23:10 <narain> ?src span
22:23:10 <lambdabot> Source not found. Where did you learn to type?
22:23:12 <bd_> > span (> 0) [1,3,-5,4,2]
22:23:14 <lambdabot>  ([1,3],[-5,4,2])
22:23:20 <dmwit> It's like (takeWhile p, dropWhile p)
22:23:23 <narain> ah
22:23:43 <dmwit> ?src List.span
22:23:43 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:24:29 <narain> dmwit: replacing  <  with  <=  fixes that
22:24:34 <bd_> source is in http://darcs.haskell.org/ghc-6.6/packages/base/GHC/List.lhs
22:24:37 <dmwit> Nice.
22:24:42 <hpaste>  Svrog pasted "how can i fix this?" at http://hpaste.org/924
22:24:43 <sjanssen> dons: what's the timeline for TMR?
22:24:43 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
22:25:02 <narain> dmwit: great, i like your implementation
22:28:01 <dmwit> I'm not convinced it's any better than yours, though.
22:28:03 <dmwit> Anyway.
22:28:25 <narain> dmwit: i'm in the process of simplifying it further :)
22:28:36 <dmwit> narain: Okay, great. =)
22:29:07 <narain> well, more like just inlining all the functions :) but it does shorten it up a bit
22:33:22 <int-e> Svrog: in Test (a, b) x   what is x? you've promised (by adding the functional dependency) that  x  can be determined given (a,b).
22:34:44 <Svrog> hmm.. well x is (a -> b -> String)
22:35:02 <int-e> why isn't it (a,b) -> String  using the first instance?
22:35:14 <desp> okay, I need help understanding do notation
22:35:25 <desp> assemblyLine w = (return w) >>= makeChops >>= polishChops >>= wrapChops
22:35:46 <dmwit> An excellent tutorial. =)
22:35:47 <desp> this is obvious -- return packeges w, >>= unpackages it and passes it to makeChops, etc
22:35:53 <desp> but
22:36:02 <desp> the equivalent using do notation is weird
22:36:19 <desp> c <- makeChops w -- w is not packaged here
22:36:23 <int-e> Svrog: I don't know if there's a way to hack around this without dropping the functional dependency.
22:36:26 <Svrog> because i want to be able to type gen (a, (b, c)) and get a function of type a -> b -> c -> String or if i pass (a, (b, (c, d))) get a function of type a -> b -> c -> d -> String
22:36:26 <desp> c' <- polishChops c -- but c is packaged here
22:36:31 <desp> what gives?
22:37:04 <kc5tja> Because THIS: >>= makeChops >>= polishChops >>= wrapChops
22:37:08 <kc5tja> is equivalent to THIS:
22:37:15 <Svrog> i only added the functional dependancy cause i wasnt getting anywhere without it - im a bit confused by fundeps though
22:37:21 <desp> ahh, no, I'm wrong.  c is also unpackaged!
22:37:30 <dmwit> desp: But c _isn't_ packaged there.
22:37:35 <desp> :)
22:37:52 <kc5tja> ... \c -> makeChops \c1 -> polishChops
22:37:55 <dmwit> Sometimes, you yourself join in with the stereo... =P
22:38:24 <kc5tja> You'll want to use >> instead of >>= in this example.
22:38:41 <narain> dmwit: sometimes the act of writing something out let you see your own mistake
22:38:44 <desp> ok, thanks
22:38:50 <desp> narain: yep
22:39:00 <narain> dmwit: and then you can enjoy the nice feeling that you've just embarrassed yourself :)
22:40:12 <dmwit> =D
22:40:59 <int-e> Svrog: a possible clean way out is to annotate the leafs - i.e.  newtype Leaf x = Leaf { pick x }; instance Show a => Test (Leaf a) (a -> String) where gen _ = show   and then use   gen (Leaf (), Leaf [])
22:41:18 <Svrog> im trying to do the reverse of this: http://okmij.org/ftp/Haskell/vararg-fn.lhs - starting with some value, either a nested tuple or a custom datatype, construct a polyvariadic function
22:41:28 <Svrog> oh
22:43:18 <dmwit> ?quote
22:43:19 <lambdabot> weitzman says: Sometimes it's ok to polish diningware with a hammer, as long as it gets the job done
22:43:38 <fuzan> any gtk2hs experts floating around?
22:43:41 <narain> ?quote hammer
22:43:41 <lambdabot> weitzman says: Sometimes it's ok to polish diningware with a hammer, as long as it gets the job done
22:43:48 <dmwit> ?quot
22:43:48 <lambdabot> joelr says: Fundeps, existential types, HList take a while to grasp
22:44:14 <desp> wow, this is indeed a great tutorial
22:44:28 <desp> all's much more clear now
22:44:30 <desp> :)
22:44:41 <fuzan> desp: which?
22:44:45 <dmwit> I found that one and the "You could have invented monads" one to be the most useful.
22:44:48 <desp> Meet the Monads
22:45:31 <Svrog> int-e: im a bit confused by your example - how is that supposed to work?
22:45:31 <desp> actually, All About the Monads.
22:45:32 <int-e> you mean Warm Fuzzy Things :)
22:46:02 <desp> dmwit: adding that to the TOREAD list
22:46:18 <narain> ?go all about the monads
22:46:20 <dons> sjanssen: april 16 or so
22:46:20 <lambdabot> http://del.icio.us/tag/monad
22:46:20 <lambdabot> Title: Pages tagged with "monad" on del.icio.us
22:46:29 <narain> buh
22:46:34 <dons> sjanssen: i've got firefox delete working, but firefox 'Quit' now fails (or did it always fail?)
22:46:42 <int-e> Svrog: I only meant to replace your instance Show a => Test a (a -> String)  instance. i.e. it sees a pair, uses the pair instance, and then the Leaf instance for the two elements of the pair
22:46:49 <dmwit> ?hawiki all about the monads
22:46:50 <lambdabot> Maybe you meant: gwiki wiki
22:47:13 <narain> nm, i found it
22:47:25 <desp> the spacesuit one looks fun, as well
22:47:44 <Svrog> ooh right - that doesnt really help me though
22:48:12 <hpaste>  (anonymous) annotated "gsk2hs- simult keydown ? " with "(no title)" at http://hpaste.org/920#a1
22:48:23 <desp> night, all
22:48:25 * desp &
22:49:22 <fuzan> alright, i've just annotated my stupid little asteroids-- game. I still can't seem to figure out how to have multiple key events occur simaultaneously. i'm not sure if it's an issue with locking in modifyIORef, or something to do with gtk2hs/gt
22:49:33 <dons> sjanssen: just pushed the atom patches.
22:49:44 <sjanssen> dons: firefox quit doesn't seem to crash for me
22:49:44 <dons> (also to X11-extras)
22:49:49 <dons> currently, it doesn't?
22:49:50 <dons> ok.
22:50:04 <sjanssen> I'll pull your changes and see whether it still works
22:50:08 <dons> can you grab the latest X11-extras and xmonad patches and check again?
22:50:24 <dons> the patches let killclient work
22:50:31 <dons> but quitting seems to behave differently
22:51:12 <sorear> hm. in c, is it legal to have an address point 2 past the end of an array?
22:51:14 <dons> i'm not sure why anything would change, but then again, X is weird.
22:51:28 <fuzan> legal? sure.
22:51:31 <dmwit> sorear: It will compile.
22:51:39 <fuzan> it may or may not segfault depending on the location of the memory
22:51:53 <sorear> I'm not going to access this address
22:51:55 <fuzan> you could use that to modify return values, parameters on the stack, etcetc.
22:52:18 <sorear> I just want to know if I'm triggering undefined behaviour by merely trying to represent the address.
22:52:18 <flux-> it may be undefined behavior. C has tons of it. I'm pretty sure it is in c++.
22:52:34 <flux-> better refer to C faqs?
22:52:34 <dmwit> No, the address will be well-defined.
22:52:47 <dmwit> The behavior of dereferencing it is what is not well-defined.
22:52:51 <fuzan> if you're only representing an address, i don't see the issue.
22:52:57 <icarroll> C doesn't really have the concept of "end of an array"
22:53:12 <sorear> ok, good, less paranoia for me
22:53:14 <fuzan> it has none, rather.
22:55:32 <sjanssen> dons: everything seems to work for me
22:55:34 <dmwit> Haha, from the Wikipedia entry for "undefined behavior":
22:55:46 <dmwit> GCC, upon finding a #pragma directive, would instead attempt to start Emacs running a simulation of the Towers of Hanoi.
22:55:49 <dons> sjanssen: oh! ok. so killclient works, and quitting?
22:56:30 <zbrown> hrm, anyone have trouble with '|' and vim?
22:56:36 <dmwit> zbrown:
22:56:41 <sjanssen> dons: yeah, killclient works on child windows (which didn't work before), and quitting in firefox seems to just work
22:56:45 <dmwit> What does :set et? say?
22:56:48 <narain> dmwit: haha, reminds me of the nasal demons quote
22:56:48 <dons> ok. good
22:56:55 <dons> the bug looks like a race to me anyway
22:56:59 <dmwit> narain: That's what I was looking for originally. =)
22:57:01 <int-e> Svrog: well, you can also provide instances for all expected leaf types separately, i.e. instance Test Int (Int -> String) where gen _ = show, and so on.
22:57:16 <zbrown> dmwit: noexpandtab
22:57:24 <int-e> Svrog: but I don't think it's possible to get the instance you tried to work.
22:57:47 <dmwit> Then do a /\t to visualize where all the tabs are.  You might have a mismatch between GHC's interpretation of tab and yours.
22:57:47 <dons> we close a firefox child, which isn't managed by us anyway, we then get a breif EnterNotify for the main firefox window. so we set focus, but its already been killed by the time we process the EnterNotify
22:58:03 <int-e> Svrog: not without advanced type hackery anyway, I'm not up to that.
22:58:06 <dons> sjanssen: then when the XSetFocus call is processed, too late, that window is gone.
22:58:20 <dmwit> zbrown: (But I'm just guessing, I never had that problem before.)
22:58:28 <dons> but good that you don't get it, at least that means my wmdelete atom code works
22:58:56 <dons> i should update to a newer X server and firefox
22:59:10 <zbrown> dmwit: its really odd
22:59:13 <icarroll> @where memoize
22:59:14 <zbrown> i dunno why it does that
22:59:14 <lambdabot> I know nothing about memoize.
22:59:17 <newsham> ?pl (\x -> x*x)
22:59:17 <lambdabot> join (*)
22:59:21 <icarroll> @quote memoize
22:59:21 <lambdabot> No quotes match. My pet ferret can type better than you!
22:59:26 <Svrog> yeah, thanks anyway - i suspect it's possible to write a function like that im just not sure how
23:00:15 <icarroll> Can anyone point me at info about memoizing in Haskell?
23:00:44 <Svrog> icarroll: http://www.cs.utexas.edu/~wcook/Drafts/2006/MemoMixins.pdf
23:01:10 <icarroll> svrog: thx
23:01:16 <Svrog> np
23:02:24 <zbrown> dmwit: hmm still no dice
23:02:25 <zbrown> damn thing
23:02:32 <dmwit> Hum.
23:02:37 <zbrown> its irritating to not be able to use guards
23:02:37 <dmwit> Care to hpaste your code?
23:02:46 <zbrown> dmwit: mind seeing if it will compile on your box?
23:02:54 <dmwit> Sure.
23:04:02 <zbrown> dmwit: http://zacbrown.org/stuff/mosquito-room.hs
23:05:47 <kc5tja> @hoogle concat
23:05:48 <lambdabot> Prelude.concat :: [[a]] -> [a]
23:05:48 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
23:05:48 <lambdabot> Data.PackedString.concatPS :: [PackedString] -> PackedString
23:06:12 <dmwit> :t max
23:06:14 <lambdabot> forall a. (Ord a) => a -> a -> a
23:07:04 <kc5tja> > ["Hello"]
23:07:06 <lambdabot>  ["Hello"]
23:07:13 <kc5tja> > ["Hello"] ++ ["World"]
23:07:15 <lambdabot>  ["Hello","World"]
23:07:17 <kc5tja> hmm
23:07:25 <dmwit> > "Hello" ++ "World"
23:07:27 <lambdabot>  "HelloWorld"
23:07:30 <kc5tja> That's what I expect -- now why isn't my statement type checking?
23:07:38 <dmwit> :t randomR
23:07:40 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
23:08:12 <dmwit> Aha.
23:08:23 <dmwit> zbrown: You don't put the '=' on the same line as checkVal.
23:08:31 <zbrown> oh
23:09:07 <sjanssen> dons: I've discovered that the window stack data structure may need to be significantly more complicated
23:09:44 <dmwit> ...and I think your un-tabbing mucked with your indentation a little.
23:10:46 <dons> sjanssen: oh, just checked, firefox Quit was already leading to the crash for me anyway
23:10:50 <dons> sjanssen: oh hmm. why?
23:11:01 <zbrown> lambdabot: ?help
23:11:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:11:08 <zbrown> lambdabot: list
23:11:10 <dmwit> > "Hello":["World"]
23:11:10 <sjanssen> dons: currently we handle one dimension of window handling, I think we need two
23:11:11 <lambdabot>  ["Hello","World"]
23:11:23 <zbrown> hrm
23:11:35 <dmwit> zbrown: Commands start with an '?' or '@'.
23:11:40 <zbrown> ok
23:11:43 <zbrown> ?help list
23:11:44 <lambdabot> list [module|command]
23:11:44 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
23:12:12 <zbrown> @pl inRange
23:12:12 <lambdabot> inRange
23:12:15 <zbrown> hrm
23:12:41 <dmwit> What are you trying to do?
23:12:49 <zbrown> dmwit: look up the module that inRange is in
23:12:51 <sjanssen> dons: in tiled mode, there is one ordering that specifies the order for layout, and then another ordering says which window should have focus
23:12:55 <dmwit> ?index inRange
23:12:55 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
23:12:57 <zbrown> dmwit: exercise in futility
23:12:59 <zbrown> ah ok
23:13:14 <narain> ?docs sequence
23:13:14 <lambdabot> sequence not available
23:13:35 <narain> ?docs Control.Monad
23:13:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
23:13:42 <dmwit> ?vixen exercise in futility
23:13:42 <lambdabot> <undefined>
23:15:07 <sjanssen> dons: both of these orderings are used in float mode too (I'm referring to dwm's implementation)
23:15:10 <dons> sjanssen: ah right.
23:15:27 <zbrown> Couldn't match `IO t' against `Int'
23:15:27 <zbrown>       Expected type: IO t
23:15:28 <zbrown>       Inferred type: Int
23:15:31 <dons> yes, you can't reuse the ordering to work out which has focus
23:15:40 <zbrown> ^^ Whats that mean in english?
23:15:56 <dons> zbrown: it means you've not unwrapped your IO action
23:16:03 <sjanssen> dons: yeah, it basically only works for fullscreen mode
23:16:09 <dons> > putStrLn "x" == 7
23:16:10 <lambdabot>   add an instance declaration for (Num (IO ()))
23:16:15 <dons> > putStrLn "x" == (7 :: Int)
23:16:16 <lambdabot>  Couldn't match expected type `IO ()' against inferred type `Int'
23:16:37 <zbrown> hrm
23:16:40 <narain> ?help vixen
23:16:41 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
23:16:45 <narain> ?vixen
23:16:46 <lambdabot> <undefined>
23:16:46 <dons> zbrown: so you're somewhere treating an IO action as an Int, pionted to by the line in the error message
23:16:58 <zbrown> ah i see
23:17:01 <zbrown> fixed :)
23:17:04 <dons> sjanssen: i note (on the topic of firefox) that dwm handles quit properly.
23:17:07 <zbrown> i thought
23:17:09 <zbrown> lol
23:17:14 <dons> so there's something we're still not quite doing right
23:17:31 <dmwit> @vixen Hey there!
23:17:31 <lambdabot> <undefined>
23:17:40 <dmwit> Looks reproducible. =P
23:17:50 <dons> vixen is disabled for now
23:17:53 <dons> for no good reason
23:17:56 <dmwit> k
23:18:03 <narain> dons: what was it supposed to do?
23:18:11 <dons> talk like eliza
23:18:41 <narain> why do you say talk like eliza?
23:18:52 <narain> ok, that was feeble.
23:20:06 <narain> ?src State
23:20:06 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:20:13 <narain> ?src Control.Monad.State
23:20:14 <lambdabot> Source not found. My pet ferret can type better than you!
23:20:20 <narain> ?t State
23:20:20 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
23:20:23 <narain> :t State
23:20:26 <lambdabot> forall s a. (s -> (a, s)) -> State s a
23:20:31 <dmwit> That one isn't in the source.
23:21:28 <narain> is there a reason why  State s a  isn't a synonym for  (s -> (a, s)) ?
23:21:40 <narain> things would be much easier
23:24:32 <zbrown> Whats "Inferred type: m a"?
23:25:28 <narain> @hoogle ([a], [a]) -> (a -> b) -> ([b],[b])
23:25:29 <lambdabot> No matches, try a more general search
23:25:34 <narain> i thought not
23:26:01 <narain> ?t join
23:26:01 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
23:26:04 <narain> :t join
23:26:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:26:26 <dmwit> zbrown: m is usually used for a monad like IO.
23:26:38 <zbrown> oh ok
23:28:20 <zbrown> hrm
23:30:10 <hpaste>  zbrown pasted "problems on line 25 (inRange z = return z)" at http://hpaste.org/925
23:30:16 <zbrown> dmwit: any ideas about htat?
23:30:32 <dmwit> Ugh, I wish clicking links in Xchat worked for me.
23:30:44 <sjanssen> narain: State isn't a type synonym because the Monad instance would overlap with the ((->) a) instance
23:30:47 <zbrown> dmwit: probably have to write it into an extension
23:30:50 <zbrown> thats what i had to do
23:31:17 <dmwit> zbrown: checkVal needs to return an IO Int.
23:31:25 <zbrown> oh
23:31:35 <zbrown> how would i do that again..
23:31:36 <zbrown> ?
23:31:45 <zbrown> lol
23:31:46 <dmwit> checkVal :: (Int, Int) -> Int -> IO Int
23:32:54 <zbrown> dmwit: ah thank you
23:32:56 <zbrown> all better :)
23:33:42 <narain> sjanssen: ah, thanks
23:34:37 <dmwit> zbrown: Just wait 'til you think, "Man, this random stuff would be easier in the State monad."
23:34:45 <dmwit> Then you'll be in pain again for a little bit. =)
23:36:43 <zbrown> dmwit: hehe
23:46:21 <dmwit> tag mmap_destructor
23:46:30 <dmwit> Oops, sorry.
23:49:41 <narain> @hoogle (a -> a) -> Int -> a -> a
23:49:42 <lambdabot> No matches, try a more general search
23:50:16 <dmwit> :t repeat
23:50:19 <lambdabot> forall a. a -> [a]
23:50:25 <dmwit> :t iterate
23:50:28 <lambdabot> forall a. (a -> a) -> a -> [a]
23:51:21 <dmwit> So, something like doNTimes f n x = (iterate f x) !! n
23:51:24 <dmwit> maybe?
23:51:38 <narain> dmwit: yeah
23:52:13 <dmwit> ?djinn (a -> a) -> Int -> a -> a
23:52:14 <lambdabot> f a _ b = a b
23:52:20 <dmwit> Boooo.
23:52:22 <narain> ha!
23:52:54 <dmwit> ?pl f a _ b = a b
23:52:54 <lambdabot> f = const
23:53:06 <dmwit> That's what I thought.
23:54:01 <narain> i couldn't have come up with  f a _ b = a b  :)
23:55:25 <narain> :t replicateM
23:55:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
23:55:45 <dmwit> Oooo...
23:55:52 <dmwit> :t replicate
23:55:55 <lambdabot> forall a. Int -> a -> [a]
23:56:00 <dmwit> Oh.
23:56:02 <dmwit> Wait.
23:56:19 <narain> hmm, it's not replicating the monad then
23:57:03 <narain> > replicateM 3 [1,2,3]
23:57:05 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
23:57:24 <narain> > replicateM 3 (Maybe 1)
23:57:25 <lambdabot>   Not in scope: data constructor `Maybe'
23:57:32 <narain> > replicateM 3 (Just 1)
23:57:33 <lambdabot>  Just [1,1,1]
23:57:47 <dmwit> Huh.
23:58:02 <dmwit> > replicateM 3 [1,2]
23:58:04 <lambdabot>  [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
23:58:19 <narain> > replicateM 3 (State (\x -> (show x, x+1)))
23:58:20 <lambdabot>        add an instance declaration for (Show (State s [String]))
23:58:21 <dmwit> Aaaaah.
23:58:34 <narain> > replicateM 3 (State (\x::Int -> (show x, x+1)))
23:58:35 <lambdabot>  Parse error
23:58:43 <narain> > replicateM 3 (State (\(x::Int) -> (show x, x+1)))
23:58:43 <lambdabot>  Parse error in pattern
23:58:50 <dmwit> ?src replicateM
23:58:50 <lambdabot> replicateM n x = sequence (replicate n x)
23:58:57 <narain> > replicateM 3 (State (\x -> (x, x+1)))
23:58:58 <lambdabot>   add an instance declaration for (Show (State s [s]))
23:59:02 <dmwit> ?src sequence
23:59:03 <lambdabot> sequence ms = foldr k (return []) ms
23:59:03 <lambdabot>     where
23:59:03 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
23:59:51 <narain> > evalState (replicateM 3 (State (\x -> (show x, x+1)))) 1
23:59:53 <lambdabot>  ["1","2","3"]
23:59:57 <dmwit> Some things are too mysterious to decode late at night. =P
