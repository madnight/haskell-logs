00:00:02 <dmwit> Why?
00:00:09 <dons> dmwit: do we have any X11-extras binding to Button event?
00:00:12 <sjanssen> dons: it is incompatible, but I don't think the issues will be significant
00:00:13 <dons> unless you added them, we don't.
00:00:17 <dmwit> dons: I added them locally.
00:00:24 <dons> dmwit: hmm?
00:00:32 <dmwit> (Although I could have easily done it wrong, I guess.)
00:00:37 <sjanssen> applications that use the type defs. in X11 and don't rely on things being Int will work fine
00:01:14 <dmwit> So, yes, I have an X11-extras binding to the Button event.  (Otherwise the thing wouldn't even compile...)
00:01:33 <dons> check against dwm to ensure its the right event you're looking for
00:01:43 <dmwit> ok
00:03:19 <sjanssen> I only had to make one line to make new X11-extras compile with broken X11, I'm checking to see if this change is sane ...
00:04:40 <thedward> external interfaces are changed, so concievaly things could break if people were explicity shoving Ints in (as opposed to using the definitions from the lib)
00:05:44 <thedward> can anyone point me at a non-trivial app using Graphics.X11 besides xmonad?
00:06:47 <sjanssen> thedward: can you pull from my X11-extras repo and see if it still builds with your modified X11?
00:07:35 <thedward> sjanssen: sure
00:08:05 <sjanssen> I don't think it is a huge issue -- just bump the X11 version and include a fat warning in the release notes
00:09:06 <dons> yep
00:09:14 <dmwit> dons: I'm grabbing the right event.
00:09:16 <dons> the 64 bit issue is too big not to fix.
00:09:17 <thedward> sjanssen: it builds fine
00:10:56 <dmwit> In the dwm code, they look for events of type ButtonPress, I'm looking for events of type buttonPress, which is defined in X11-1.2 as buttonPress = ButtonPress.
00:12:10 <thedward> since so much of the interface is based on (C)Int, people could be passing in explicitly typed Int values; (I wholeheartedly understand this implementation choice; The idea of going through and making proper types for everything kind of makes me twitch)
00:12:44 <thedward> but, I think if people are using it as is it meant to be used, it shouldn't be a problem
00:12:57 <sjanssen> thedward: using type synonyms instead of newtypes/data are sound -- but the choice to use Int was very bad
00:13:16 * thedward nods.
00:14:45 <dons> thedward: this is haskell. type should be proper types :-)
00:14:55 <dons> and if they're not, heads should be kicked and/or patches applied.
00:14:58 <thedward> I might have to hack something into xmonad to not maximize transient windows, some dialogs are not meant to be the size of my monitor.
00:15:16 <dons> a proper floating layer would be the best option. though iirc, ion just has a workaround
00:15:39 <thedward> what do you mean by floating layer?
00:17:26 <dons> like dwm.
00:17:34 * dons is too busy for irc today
00:17:50 <sjanssen> thedward: yeah, we'll do this when we have a float mode
00:17:56 <dmwit> thedward: It means a layer that works like every other WM in the world.
00:17:56 * Shimei likes wmii's handling of floating layers, as it enables weird apps like GIMP to still work
00:18:04 <Shimei> Does dwm handle floats like wmii does?
00:18:08 <dmwit> yep
00:18:15 <sjanssen> thedward: can you also test the latest patch for xmonad?
00:18:45 <dons> remember that dwm is the second attempt for the wmii author
00:18:58 <dons> after wmii bloated up like a dead corpse.
00:19:02 * dons is in a funny mood
00:19:13 <dons> hack hack hack!
00:19:16 <thedward> sjanssen: I didn't have to make any changes for it to compile on my end
00:19:35 <dmwit> Oh, hm, do we explicitly have to tell the X server we want to be notified of clicks?
00:19:36 * Korollary wonders whether dons ever lived in New Jersey
00:19:42 * dmwit goes to look at the dwm source again
00:20:02 <sjanssen> thedward: these changes make it build with both new X11 and broken X11
00:20:19 <sjanssen> (I've decided to always call the Int version of X11 broken)
00:20:21 <dons> dmwit: yes. i think so.
00:20:33 <thedward> sjanssen: It build fine both ways for me. (Just the keyboard din't work on the broken version)
00:20:45 <thedward> sjanssen: I am testing it; just jabbering too
00:20:46 <dmwit> That would be nice.  It would mean it wasn't my fault. =)
00:21:22 <dons> dmwit: something like,     wa.event_mask = ButtonPressMask | ExposureMask
00:21:35 <dons> dmwit: look in main.c:setup()
00:21:52 <dmwit> dons: Thanks for all the help.
00:22:59 <thedward> sjanssen: builds fine here.
00:24:07 <thedward> you could alwasy make an X11.WindowManager library, and anything that pushes xmonad over 400 lines just put it in there. :)
00:24:41 <sjanssen> okay.  I'm going to leave these compatibility hacks in until we get a new X11 release.  After that I'll delete them and require X11 >= 1.3 (or 2.0, or whatever)
00:24:53 <thedward> cool deal.
00:25:16 <thedward> I am going to go to sleep.
00:25:36 <sjanssen> yell at me if you ever have trouble building xmonad or X11-extras with the CInt'ified X11
00:25:49 <dons> sjanssen: so that's in the X11 / X11-extras repo?
00:25:56 <sjanssen> thedward++ thedward++ thedward++
00:25:59 <dmwit> Urgh, we have to grab the button press events per-client.
00:26:09 <thedward>  :)
00:26:20 <sjanssen> dons: correct.  They build cleanly with both the broken and good versions of X11
00:26:37 <sjanssen> dmwit: oh, yuck
00:26:52 <sjanssen> this is how dwm does it?
00:26:53 <dons> ok. great.
00:27:10 <dons> dmwit: that's understandable. when we manage, we grab those events too?
00:27:17 <dmwit> Yes, it has a function grabbuttons(Client *, Bool)
00:27:31 <dmwit> dons: Yeah, I think so.
00:27:31 <dons> yeah , like grabkeys and grabenternotify
00:29:08 <sjanssen> we can ignore the if focused stuff for now, looks like it's only for window resizing
00:29:24 <dmwit> Great.
00:36:22 <sjanssen> dons: actually thedward's patches are *not* in the main X11 repo
00:36:54 <sjanssen> dons: we probably need a little bit of consensus before doing that
00:41:55 * sjanssen sleeps
00:43:16 <dmwit> Is it bad to just use 0 as a magic number?
00:43:23 <dmwit> (i.e. in replace of X's None)
00:43:44 <Korollary> like a Maybe Int?
00:44:23 <dmwit> Korollary: Similar, but actually interfacing to X, which has no concept of Maybe.
00:44:46 <Korollary> If you're interfacing, I guess you have to play with X' conventions
00:45:00 <dons> dmwit: we should really bind to it
00:45:02 <dmwit> I know 0 is the right value to pass, the question is whether it is okay to just pass 0 or whether I should define none=0 somewhere, then pass none.
00:45:05 <dmwit> Okay.
00:52:49 <encryptio> :t null
00:52:52 <lambdabot> forall a. [a] -> Bool
00:54:56 <dmwit> C's #define is really type-unsafe.
00:57:18 <tuukkah> dmwit, it has arity, doesn't it ?-)
00:57:41 <dmwit> tuukkah: #define RAH = 0
00:57:49 <dmwit> Now, is RAH an int, a pointer, a button... ?
00:58:11 <tuukkah> sure. but would we say that it's kind-safe :-)
00:58:12 <dmwit> ;-)
00:58:24 <dmwit> Okay...
00:58:47 <dmwit> I'll acknowledge that it's probably kind-safe. =)
00:59:14 <Korollary> The fact that 0 can be a pointer and an int is not #define's fault.
00:59:47 <dmwit> No.  The fact that a #define is used as both a pointer and an int definitely is, though.
01:00:22 <siti> #define = c pre processor that is it...
01:00:27 <dmwit> The particular RAH I'm refering to is passed as a window pointer, a cursor, a button, ... =(
01:00:54 <siti> that's the fault of the type system that 0 can be passed to anything pretty much
01:02:31 <dmwit> Okay, actually, I'm going to calm down a little bit now, because I just discovered that it's only used as an XID.
01:02:48 <dmwit> So at least there's some loose, gentleman's agreement about classes of variables.
01:02:57 <Eelis> #define RAH ((int)0)
01:03:00 <Eelis> presto
01:03:14 <dons> dmwit: that describes the entire C typesystem. :-)
01:03:22 <dons> "a loose, gentleman's agreement about classes of variables"
01:03:36 <dons> type system by old boys club
01:03:37 <dmwit> Eelis: better: static const int RAH = 0;
01:03:54 <dons> lots of nods, winks and secret hand shakes
01:04:02 <dmwit> Heh.
01:04:05 <Eelis> dmwit: naturally.
01:11:31 <dmwit> What's the hsc syntax to import a singleton constant??
01:11:46 <dmwit> #let and #def are definitely not what I want...
01:12:25 <dons> #enum usually
01:12:29 <dons> (I think?)
01:12:45 <dmwit> Even for only one constant?
01:12:46 <dons> have a look in the X11 binding src
01:12:51 <dmwit> But, okay, cool.
01:15:09 <dmwit> Ah, #const
01:23:21 <dmwit> ...and, now, xmonad sees all clicks, clients see none.
01:23:35 <dmwit> It is a little bit tricky to use Firefox without a mouse, though not impossible.
01:23:42 <siti> lol
01:23:48 <siti> quick find makes it nice
01:23:49 <siti> :)
01:24:01 <dmwit> Just the same, I wouldn't mind fixing this. =)
01:24:03 <siti> and ctrl[shift] + tab
01:24:08 <siti> yep
01:28:12 <quicksilver> If GHC can detect at compile time which instance a variable is, does it still pass a dictionary, or can it generate a direct call to the (specialised version of the) method ?
01:28:27 <dons> it can generate a direct call, yes.
01:29:00 <dons> you see this with Num/Int code fairly often.
01:29:49 * quicksilver nods
01:29:59 <quicksilver> Well I imagine it must with Int, or it would never compete
01:30:05 <quicksilver> but I was checking that wasn't a special case :)
01:30:53 <quicksilver> my main concern is that if you abstract a whole bunch of code over a typeclass, you don't lose performance in the static case
01:31:04 <quicksilver> (e.g. replacing String with IsString, or suchlike)
01:35:06 <dmwit> Preference poll: a click on an unfocused window should (a) focus, (b) focus and "fall through," i.e. also do the action that would have happened if that window had already been focused.
01:35:33 <quicksilver> in click-to-focus, the click should focus only
01:35:36 <dmwit> (I prefer (a), in case it sways any of you. =)
01:35:46 <ndm> dmwit: Office 2007 decided a over b
01:35:49 <dmwit> quicksilver: Context is focus-follows-mouse.
01:35:51 <quicksilver> in point-to or sloppy, you can make a case for the click going through
01:36:00 <quicksilver> hmm
01:36:01 <ndm> after usability studies etc
01:36:13 <quicksilver> if focus-follows-mouse then you don't need to focus
01:36:16 <dmwit> ndm: Ooo, good.  That's easier, too. =)
01:36:19 <Eelis> i'd say make it a configuration flag.
01:36:21 <quicksilver> do you mean click-to-raise then?
01:36:51 <dmwit> quicksilver: There's also an Alt+Tab-alike; so not strict focus-follows-mouse.
01:36:53 <quicksilver> ndm: yes, but their usability studies are not based on a corpus of people used to focus-follows-mouse behaviour; but specifically people used to using click-to-focus OSes
01:37:10 <ndm> quicksilver: it is definatley not a focus-follows-mouse result
01:37:18 <quicksilver> i.e. MS Office-running-OSes, i.e. MacOS and windows :)
01:37:51 <quicksilver> dmwit: and click-to-raise isn't relevant because your windows never overlap? or can they in fact?
01:38:03 <dmwit> quicksilver: For now, they never overlap.
01:38:43 <dmwit> I think click-to-focus, no fall through.
01:38:59 <quicksilver> I think the behaviour I expect (but I may not be typical) is that a click will focus, iff the window is not focussed already
01:39:12 <quicksilver> if the window is already focussed, then the click will click
01:39:16 <quicksilver> (maybe that's what you mean)
01:39:23 <dmwit> Right.
01:39:30 <dmwit> Well.
01:39:37 <dmwit> The click will click iff the window is already focussed.
01:40:11 <Eelis> i would expect the behavior to be configurable. saves users from having to patch it up if their preferences happens not to match the author's
01:40:37 <dmwit> Eelis: Hmmm... maybe.  Anyway, I'm going to get one thing working first. ;-)
01:40:46 <Eelis> sounds like a good idea :)
02:00:37 <dmwit> ?hoogle (Monad m) => (a -> b) -> m a -> b
02:00:38 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
02:00:38 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
02:00:38 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
02:01:07 <dmwit> Oh, duh, that's bad.
02:01:25 <dmwit> ?hoogle (Monad m) => (a -> b) -> m a -> m b -> b
02:01:27 <lambdabot> No matches, try a more general search
02:01:32 <dmwit> :t maybe
02:01:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:07:53 <quicksilver> dmwit: I'm pretty sure that function can't exist :P
02:08:09 <quicksilver> dmwit: that would all unwrap :: m a -> a
02:08:13 <dmwit> quicksilver: Which, the first one I hoogled for?  I think you're write.
02:08:18 <dmwit> s/write/right/
02:08:18 <quicksilver> s/all/allow/ :)
02:08:37 <dmwit> (It's why I wrote that it was bad. =)
02:08:45 <quicksilver> :)
02:08:51 <dmwit> Oh, the second one, too, huh?
02:08:53 <dmwit> Yeah.
02:08:55 <dmwit> Bad.
02:09:34 <quicksilver> for any particular monad, there often exist ways of unwrapping
02:09:41 <quicksilver> but there certainly isn't a generic one
02:09:51 <quicksilver> IO, for example, has no unwrappers at all
02:09:53 <dmwit> Yeah.  "maybe" was what I was looking for, anyway.
02:10:01 <quicksilver> 'head' is a partiall-defined unwrapper for List, say
02:13:05 <dmwit> You know, not being able to click is not so much a hindrance as I thought it would be. =P
02:14:40 <laziest_>  /msg nickserv link laziest ComputerTrash
02:36:09 <dsedge> hello. i wrote some code in haskell to solve one of the project euler problems and i'm trying to improve it, can anybody help me with that?
02:37:02 <kaol> ?paste
02:37:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:37:13 <kaol> let us see it ;-)
02:37:28 <hpaste>  dsedge pasted "Project Euler Problem #12" at http://hpaste.org/1167
02:37:43 <dsedge> the problem is it's very inefficient i think
02:37:52 <dsedge> not sure how to improve it though
02:49:57 <ndm> dsedge: i'm not sure either, but find some mathematical properties and exploit them
02:51:02 <ndm> dsedge: it looks like there is a triangle of numbers involved? and at each row you recompute the whole line - try rewriting it so instead of recomputing you track the difference between one line and the next
02:51:08 <ndm> dsedge: and just tweak that bit
02:51:28 <Botje> instead of map (sum . enumFromTo 1)
02:51:29 <Botje> do
02:51:37 <dsedge> ndm: http://projecteuler.net/index.php?section=problems&id=12, this is the problem spec.
02:51:43 <Botje> scanl1 (+) [1..]
02:51:53 <dsedge> Botje: is that faster?
02:51:59 <Botje> much faster.
02:52:22 <Botje> yours recomputes the sum of [1..n-1] everytime too
02:52:33 <Botje> > map (sum . enumFromTo 1) [1..]
02:52:37 <ndm> O(n^2) vs O(n)
02:52:40 <Botje> > scanl1 (+) [1..]
02:52:44 <lambdabot> Title: Project Euler
02:52:46 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
02:52:46 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
02:52:46 * Botje pokes \bot
02:53:54 <dsedge> Botje, ndm: thanks
02:54:02 <dsedge> are there any other improvements you can suggest?
02:54:28 <quicksilver> dsedge: you have an off-by-one error, too
02:54:53 <quicksilver> dsedge: your 'divs' calculates all divisors except the number itself
02:55:15 <quicksilver> dsedge: which is fine,but you need to add '1'
02:55:18 <laziest> a link to what is the problem please?
02:55:36 <quicksilver>  http://projecteuler.net/index.php?section=problems&id=12
02:55:38 <dsedge> quicksilver: ahh, i see
02:56:13 <quicksilver> dsedge: once you've fixed the quadratic behaviour of 'trinums' you now need to optimise 'divs'
02:56:18 <pejo> Does anyone happen to konw how to typeset a \righttriangle with a tilde underneath it in latex?
02:56:35 <quicksilver> dsedge: can you think of abetter algorithm than trying every possible number up to x/2 ?
02:57:16 <dsedge> quicksilver: sorry, no, i'm still in junior high, so no higher-level maths yet...
02:57:42 <Botje> dsedge: have you tried looking for 'divisor' at mathworld.wolfram.com ?
02:58:05 <dsedge> Botje: no, but i will
02:58:23 <quicksilver> dsedge: well as a starter, once you find one divisor, that automatically gives you another
02:58:24 <Botje> ISTR there being an algorithm for computing # of divisors given the prime factors
02:58:45 <quicksilver> dsedge: that helps a bit
02:59:16 <quicksilver> dsedge: but Botje is pointing you towards a much faster solution; you don't actually need to know what the divisors are, just how many
03:00:07 <dsedge> Botje: ISTR?
03:00:09 <quicksilver> of course, you need an efficient algorithm to find all the primes, then, but that was required by problem 7 and kind of problem 3 :)
03:00:14 <quicksilver> I Seem To Remember
03:00:42 <quicksilver> and problem 10, actually
03:01:00 <dsedge> quicksilver: yes
03:01:06 <quicksilver> the euler prolems are designed in many cases so that earlier answers provide tools you need in later answers
03:01:25 <lambdabot> Title: Project Euler
03:02:56 <dsedge> quicksilver: do you know what ISTR stands for, that Botje referred to earlier?
03:03:08 <quicksilver> 10:58 < quicksilver> I Seem To Remember
03:03:20 <dsedge> ahhh
03:03:21 <dsedge> ok
03:03:26 <Cale> It's sort of annoying how the answer to all the Project Euler problems is a number.
03:03:48 <quicksilver> Cale: how so?
03:04:48 <Cale> Well, it means that you can usually get the solution through brute force.
03:04:58 <dsedge> quicksilver: we learned prime factorization in school fairly recently, but, how do i apply it in this problem?
03:05:13 <TSC> That depends on how smart your brute force is
03:05:35 <Cale> Or how patient you are.
03:06:30 <quicksilver> Cale: but in some sense, the idea is to use 'smart' brute force, isn't it?
03:06:41 <quicksilver> Cale: I mean, they've chosen problems such that naive algorithms are too slow
03:06:55 <quicksilver> Cale: and they expect you to poke aronud the problem looking for cleverer tricks
03:07:05 <Cale> I suppose. I'd hope there are more general solutions to most of these.
03:07:05 <quicksilver> dsedge: there is a relationship between prime factors and all factors
03:07:34 <quicksilver> Cale: I don't think that's their intention, though. Their intention is to frame problems which require computer power to solve
03:08:10 <quicksilver> dsedge: consider the number 12. It's prime factors are 2 (twice) and 3 (once)
03:08:38 <quicksilver> dsedge: its full list of factors is [1,2,3,4,6,12]
03:09:07 <quicksilver> dsedge: 2,3 are in the list already as they're prime. 4 is 2*2. 6 is 2*3. 12 of course is 2*2*3
03:09:12 <quicksilver> dsedge: see what's going on there?
03:10:13 <dsedge> quicksilver: yes, you can find all factors by multiplying the prime factors in different combinations?
03:10:48 <Cale> quicksilver: I'd rather call [1,2,3,4,6,12] its full list of divisors.
03:11:03 <Botje> > map product $ filterM (const [True,False]) [2,2,3]
03:11:18 <quicksilver> dsedge: right
03:11:26 <quicksilver> dsedge: and then you don't even need to actually *do* that
03:11:35 <Cale> A factor is part of a product, so saying that you have a list of factors of 12 has the connotation that they multiply to give 12.
03:11:37 <quicksilver> dsedge: because you just need to count how many ways there are of doing it
03:11:49 <quicksilver> Cale: yes, you're right
03:12:04 <quicksilver> dsedge: for each factor you can either include it, or not..
03:12:41 <lambdabot>  [12,4,6,2,6,2,3,1]
03:13:01 <quicksilver> dsedge: if a factor is there multiple times, though, you can include it from 0 times up to the number of times it occurs
03:14:11 <dsedge> quicksilver: i understand the idea, but i don't see the concrete way of finding the number of possible combinations. is this "permutations" (something my teacher mentioned)?
03:14:44 <Cale> well, all you have to do is look at the exponents on the primes
03:15:07 <quicksilver> dsedge: with 12, in particular, '2' can be include 0, 1 or 2 time
03:15:17 <Cale> If you have the prime factorisation p_1^n_1 p_2^n_2 ... p_k^n_k, then there are (n_1 + 1) (n_2 + 1) ... (n_k + 1) divisors.
03:15:20 <quicksilver> dsedge: 3 can be included 0 or 1 times
03:15:39 <quicksilver> dsedge: that's 3 possibilities for '2' and 2 possibilites for '3'
03:15:47 <quicksilver> dsedge: 3*2 = 6 divisors, in total
03:16:05 <dsedge> quicksilver: ok, that's what i was thinking
03:16:17 <quicksilver> which is all cale's formula says
03:16:38 <dsedge> quicksilver: but how to do this algorithmically? and how to find the prime factors in the first place?
03:16:50 <dsedge> on paper i can do it, but i don't know quite where to start with the program
03:17:02 <Cale> Well, I just told you how to do it algorithmically, once you have the prime factorisation.
03:17:25 <dsedge> Cale: sorry, this is all pretty new to me, just trying to sort it out
03:17:30 <Cale> Add one to the number of times each prime occurs and multiply those numbers.
03:18:25 <Cale> product . map ((+1) . length) . group . sort . primeFactors
03:19:36 <dsedge> thank you very much guys! final thing, how do i go about finding the prime factorization first though?
03:20:12 <Cale> The simplest thing to do is to check if each prime number is a factor.
03:20:32 <Cale> If it is, then divide it out, and recurse on what's left.
03:20:55 <Botje> dsedge: google for primes.hs
03:21:20 <dsedge> Botje: http://www.polyomino.f2s.com/david/haskell/hs/Primes.hs.txt?
03:22:10 <Botje> that's the one.
03:23:41 <Botje> it has a primepowerfactors function iirc
03:24:28 <hpaste>  MathematicalOrc pasted "Can you make this shorter?" at http://hpaste.org/1168
03:26:08 <dsedge> alright, i think i know what i need to to work this out. thanks very much Botje, quicksilver, and Cale
03:27:24 <Vq^> who is mr Orc?
03:27:44 <Vq^> welcome back mr Coutts
03:27:50 <dcoutts> hia
03:28:33 <Botje> you're welcome, dsedge
03:30:10 <hpaste>  Cale annotated "Can you make this shorter?" with "how about this?" at http://hpaste.org/1168#a1
03:32:16 <hpaste>  quicksilver annotated "Can you make this shorter?" with "A little short, much prettier" at http://hpaste.org/1168#a2
03:32:50 <quicksilver> who is the phantom orc, anyway?
03:34:39 <hpaste>  laziest annotated "Can you make this shorter?" with "another one" at http://hpaste.org/1168#a3
03:34:51 <quicksilver> Cale: sometimes I find more concrete code prettier, even if another is more generalisable :)
03:40:21 --- mode: irc.freenode.net set +o ChanServ
03:40:30 <dmwit> Well, that was fun.
03:41:43 <dons> ?yow
03:41:44 <lambdabot> I want to perform cranial activities with Tuesday Weld!!
03:41:50 <dons> ?brain
03:41:50 <lambdabot> Are you pondering what I'm pondering?
03:42:52 <dmwit> Yay!  Clicking focuses windows now, and mousing over windows changes the active workspace!
03:43:01 <dons> cool!
03:43:08 <dons> isn't haskell + X11 fun fun!? :-)
03:43:12 <beelsebob> no
03:43:14 <dmwit> Yes!
03:43:17 <dmwit> beelsebob: Lies!
03:43:20 <dons> thedward: i note your patch has been applied to X11
03:43:27 <dons> beelsebob is a grumpy charlie.
03:43:38 <dons> code for all!
03:43:42 <beelsebob> yep
03:44:07 <beelsebob> I was under the impression that X11 was *never* fun
03:44:09 <dmwit> By the way, I think changing workspaces already keeps the focus, no?
03:44:15 <dmwit> Can that line just disappear from the TODO?
03:44:19 <dons> beelsebob: it can be.
03:44:25 <dmwit> beelsebob: It's always fun after you're done dealing with it. =)
03:44:35 <dons> dmwit: seems to work, yes.
03:44:46 <dmwit> I know I was sure complaining a lot earlier tonight, but now I'm happy happy happy! =P
03:44:52 <beelsebob> lol
03:45:05 <dons> and you've contributed to a new project, in only a few hours. that's great.
03:45:10 <dons> small code bases rock.
03:45:19 <beelsebob> that's like saying that installing linux from source code is fun because of the happy smiley feeling you get when it finally does 30% of what you wanted it to do
03:45:22 <dmwit> Yeah, it helped that I could read *the whole thing* before I started.
03:45:23 <beelsebob> like... it boots
03:45:25 <dons> all your code base belong to us!
03:46:02 <dons> beelsebob: the point here is that dmwit went from zero to adding new features to xmonad in only a couple of hours. X11 and all. so that's a *good thing*
03:46:12 <beelsebob> that sounds good
03:46:21 <beelsebob> sounds like a very good thing
03:46:35 <beelsebob> so wait - we have an X11 library for Haskell now?
03:46:43 <beelsebob> does that mean we'll get a real native GUI library?
03:46:49 <dmwit> Errr... on second look, this may not quite be bug free... =(
03:48:22 <earthy> uh, no
03:48:28 <earthy> beelsebob: that would be pointles
03:48:32 <earthy> +s
03:48:46 <earthy> as it'd come with all the problems of a native GUI library as well
03:48:48 <beelsebob> o.O we get a points free Haskell GUI library?
03:48:49 <beelsebob> :DD
03:48:52 <beelsebob> :P
03:49:10 <earthy> tangible values can be composed point free, I think. :)
03:49:17 <earthy> but that's even more beside the point ;)
03:49:23 <beelsebob> hehe
03:50:01 <beelsebob> hmm, trying to install xmonad to stare at it in shininess... I get the error "Setup.lhs: cannot satisfy dependency X11>=1.2"
03:50:06 <earthy> anyway, if you *want* to recreate the mess that is AWT, or even Algol 68's transput... :)
03:50:08 <beelsebob> how do I check my X11 version
03:50:12 <beelsebob> and how do I fix it
03:50:20 <earthy> ghc-pkg describe X11
03:50:38 <earthy> and fixing it is probably a darcs get from sjanssens X11 extras repo, and a cabal build
03:50:53 <beelsebob> ah, so it's ghc's package, not X11 thats wrong
03:51:01 * earthy nods
03:51:02 <beelsebob> and no - it's X11-extras that gives that error on building
03:51:05 <dmwit> ?hackage X11
03:51:05 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
03:51:43 <dmwit> beelsebob: Do you have GHC 6.4?
03:51:47 <beelsebob> nope 6.6
03:51:52 <dmwit> ok
03:53:42 <hpaste>  MathematicalOrc annotated "Can you make this shorter?" with "And the winner is..." at http://hpaste.org/1168#a4
03:54:29 <beelsebob> hmm, linker seems to throw a spack attack now
03:54:36 <beelsebob> in terms of not wanting to link against libX11
03:54:49 <dmwit> Aha, got it!
03:54:51 <beelsebob> anyone got any idea how to tell OS X's linker to behave nicely?
03:54:58 <dmwit> Man, that was a wierd one.
03:55:10 <Vq^> would be nice to have at least one decimal when the output from prettySize is short
03:55:15 <dmwit> Ooo, somebody else was having that problem earlier tonight.
03:55:40 <dmwit> They ended up doing something like cd /usr/lib && ln -s /usr/X11R6/lib/* .
03:55:42 <beelsebob> I'm guessing it just needs a -L/usr/X11R6/lib added to the command
03:55:48 <dmwit> Yeah!
03:55:52 <dmwit> I think you can do this instead:
03:56:03 <dmwit> Put an ld-options: stanza in the cabal file.
03:56:44 <dmwit> (That's what sjanssen suggested, anyway.)
03:56:45 <beelsebob> nope, that gives the same error
03:56:54 <dmwit> Ah, nuts.
03:56:56 <beelsebob> unless I need to reconfigure
03:56:57 <dmwit> One second.
03:57:02 <dmwit> Oh, yes, definitely.
03:57:19 <beelsebob> no, still same error
03:57:59 <dmwit> Try ghc-options: instead.  (Chasing after rainbows...)
03:59:45 * dmwit is encouraged by the silence
04:00:02 <beelsebob> hmm, it would appear that X11.buildinfo.in should do what's required
04:00:55 <beelsebob> in fact, it appears to get it right
04:01:02 <beelsebob> but doesn't include it when calling the linker
04:01:50 <beelsebob> gyah
04:02:03 <beelsebob> I can't see how to get this to actually pay attention to changes to the cabal script
04:02:22 <beelsebob> the options it calls ghc with don't actually change when I change the .cabal file
04:02:39 <dmwit> Did you configure again?
04:02:44 <beelsebob> yep
04:02:49 <dmwit> huh
04:03:00 <beelsebob> and it manages to pick up the right stuff in the ghc-options and ld-options fields
04:03:08 <beelsebob> but it then doesn't actually use it in the build
04:03:36 <dmwit> Hahaha!
04:04:09 <dmwit> Nyah nyah, thbbbthtbt, can't fix me!
04:04:25 <beelsebob> X11.buildinfo contains ld-options:  -L/usr/X11R6/lib\nghc-options:  -L/usr/X11R6/lib, but when it builds it calls  /usr/local/bin/ghc-6.6 -lX11 Graphics/X11/Types_hsc_make.o -o Graphics/X11/Types_hsc_make
04:06:47 <dons> for X11-extras I usually only need to add include-dirs:        include /usr/X11R6/include
04:07:11 <dmwit> beelsebob: Take a look at .setup-config
04:07:25 <dons> oh, and my $ echo $LDFLAGS
04:07:25 <dons> -L/usr/local/lib
04:08:08 <pejo> (The symlinking solution is definitely the wrong way to do it, even if it works).
04:08:29 <beelsebob> well, .setup-config contains nothing about X11
04:08:55 <beelsebob> and the variable LDFLAGS is empty
04:09:37 <dmwit> beelsebob: What about programArgs for "runghc"?
04:09:45 <dmwit> Oh.
04:09:47 <dmwit> Never mind.
04:10:44 <dmwit> Well, I guess you could try LDFLAGS=-L/usr/X11R6/lib ./Setup.lhs build or so...
04:11:07 <dmwit> If that works, maybe export LDFLAGS=-L/usr/X11R6/lib somewhere.
04:12:04 <hpaste>  Niklas annotated "Can you make this shorter?" with "short, but not very sweet" at http://hpaste.org/1168#a5
04:17:02 <paolino> hi, anyone using parsec can tell me if there is something more natural for
04:17:13 <paolino> line = manyTill anyChar newline >>= return.(++ "\n")
04:17:35 <Botje> niklas: hey! i had that too :[
04:18:15 <Botje> doesn't it have a line primitive?
04:18:45 <dmwit> You would think so...
04:19:00 <quicksilver> Botje: did you consider map (:"B") " KMGT" ?
04:19:03 <mux> if I have an ADT of the form data File = A | B | C | D | E | F | G | H
04:19:11 <quicksilver> Botje: pretty sure that saves a couple of chars
04:19:30 <mux> and that I want to be able to convert a value of this type
04:19:33 <Botje> quicksilver: i'm just an amateur :)
04:19:38 <mux> with A -> 0 and H -> 7
04:19:47 <mux> should I derive Enum or is there a better way?
04:20:02 <Botje> what's wrong with derive Enum?
04:20:03 <quicksilver> mux: nothign wrong with deriving enum AFAICS
04:20:06 <laziest> mux: I think Enum should do
04:20:12 <mux> thanks
04:20:15 <quicksilver> allows you to do cute stuff like allVals = [A..H], too
04:20:18 <paolino> Botje: probably,That wasn't the core of the question , the separator could  be anything.
04:20:24 <mux> Botje: fwiw, nothing, I was wondering if thtere was something more natural
04:20:40 <laziest> Enum *is* natural :)
04:20:43 <quicksilver> mux: 'more' natural? this is exactly what Enum is for :)
04:21:45 <mux> no doubt here
04:22:02 <Botje> paolino: there's an endBy primitive?
04:22:29 <dmwit> Botje: It doesn't do what you think...
04:23:01 <Botje> from the description, it looks like it does
04:23:01 <mux> the only thing is that I'll be forced to write things such as fromIntegral (fromEnum x))
04:23:17 <mux> because I'll need Double's, and fromEnum will give me Int's
04:23:24 <mux> so I was considering deriving Num
04:23:29 <quicksilver> NO!
04:23:29 <quicksilver> :)
04:23:50 <rahikkala> paolino: ((++"\n") `fmap` manyTill anyChar newline) ... I'm not sure if it's better but I think it's slightly easier to see what's going on at a glance
04:23:53 <quicksilver> y = fromIntegral.fromEnum
04:23:57 <quicksilver> now you just type 'y x'
04:24:01 <mux> yeah
04:24:02 <laziest> mux: make some top level "eToD = fromIntegral . fromEnum"
04:24:05 <mux> I'll end up doing this
04:24:34 <dmwit> Botje: You may be right, but I remember being very surprised the last time I used it.
04:24:43 <dmwit> (But I'm easily surprised, I'm wrong a lot. =)
04:24:47 <Botje> )
04:24:50 <Botje> :)
04:24:55 <mux> laziest: except I was considering naming it enumToNum :)
04:25:05 <paolino> Botje: still the separator is lost
04:25:17 <quicksilver> I think "takeWhile p (iterate f seed)" is useful enough to get a name, actually
04:25:33 <paolino> (terminator)
04:25:34 <dmwit> paolino: (concat . intersperse "\n") will take care of that.
04:25:42 <quicksilver> since in practice you do normally only want a finite section of what iterate returns
04:26:05 <dmwit> ...or whatever your terminator is.
04:26:22 <quicksilver> I do find parsec ugly
04:26:26 <quicksilver> powerful, but ugly
04:26:40 <quicksilver> I'm really attached to the way paulson-style systems make your program look like the grammar
04:26:56 <quicksilver> I think a lot of the higher-level parsec constructs lose that entirely
04:27:11 <tsp> if I write a function, say, readFile, does it need to return an io list?
04:27:18 <tsp> I wnat to read all the lines from a file into al ist
04:27:29 <laziest> ?help search
04:27:29 <lambdabot> search provides: gwiki google wikipedia gsite
04:27:40 <laziest> ?search paulson
04:27:40 <lambdabot> Unknown command, try @list
04:27:43 <dmwit> tsp: Yes, if it does IO, in needs to return an IO type.
04:27:55 <dmwit> ?hoogle readFile
04:27:56 <lambdabot> Prelude.readFile :: FilePath -> IO String
04:27:57 <lambdabot> System.Win32.File.c_ReadFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
04:27:57 <lambdabot> System.Win32.File.win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
04:28:04 <quicksilver> laziest: he wrote a book on ML; it had an example combinator parser
04:28:08 <mux> quicksilver: PolyParse looks really interesting
04:28:15 <mux> I haven't tried it yet though
04:28:15 <quicksilver> laziest: I don't think he claimed it was his idea, or anything
04:28:21 <quicksilver> laziest: it's just where I happened to learn it from
04:28:36 <laziest> quicksilver: any url?
04:28:56 <malcolmw> mux: I'm restructuring polyparse at the moment, to reduce code duplication
04:29:06 <quicksilver> laziest: http://www.cl.cam.ac.uk/~lp15/MLbook/
04:29:07 <lambdabot> Title: ML for the Working Programmer, 2nd Edition
04:29:17 <paolino> dmwit: what about keeping this terminator ? manyTill anyChar (char '_' >> many letter >> newline)  ?
04:29:22 <quicksilver> malcolmw: do you feel any resonance to the point I was trying to make there?
04:29:25 <rahikkala> tsp: If you're absolutely sure that you never need to care about when and how many times the side effect of reading the file happens, then you can use the function that should be named simonPerformIO, but there's no OS that gives you that guarantee
04:29:36 <malcolmw> mux: what point?
04:29:59 <mux> malcolmw: nice! BTW, I was wondering if PolyParse provides a monad transformer, unlike Haskell
04:30:00 <malcolmw> oops, quicksilver: what point
04:30:01 <dmwit> paolino: I don't really know.  I haven't used Parsec very much.
04:30:22 <laziest> quicksilver: any online resource for similar ideas?
04:30:23 <mux> err, unlike Parsec
04:30:28 <mux> I need sleep
04:30:39 <quicksilver> malcolmw: I do find parsec ugly;  powerful, but ugly; I'm really attached to the way paulson-style systems make your program look like the grammar; I think a lot of the higher-level parsec constructs lose that entirely
04:30:47 <malcolmw> mux: I must admit I haven't got into monad transformers yet
04:31:10 <quicksilver> laziest: probably, but I don't know where :) that web page has the sample code, though, although I haven't looked through it
04:31:12 <malcolmw> quicksilver: oh, and do you think that polyparse might make them look more grammar-like?
04:31:14 <mux> malcolmw: if pp had one it would be a clear and huge advantage over Parsec
04:31:19 <dmwit> paolino: How about defining something like:
04:31:23 <quicksilver> malcolmw: I was wondering if it would :)
04:31:42 <quicksilver> malcolmw: or, 'could' rather than 'would'
04:32:00 <dmwit> terminator t body = do { x <- body; y <- t; return (x, y) }
04:32:11 <dmwit> Then you can make your above things be like
04:32:20 <dmwit> line = terminator newline
04:32:30 <malcolmw> quicksilver: I'm just looking at how I use them within HaXml, to see if I can claim what you want
04:32:37 <tsp> :t lines
04:32:38 <dmwit> strangething = terminator (char '_' >> many letter >> newline)
04:32:39 <lambdabot> String -> [String]
04:32:48 <tsp> damn, it won't take an IO string?
04:32:56 <tsp> :t readFile
04:32:59 <lambdabot> FilePath -> IO String
04:33:21 <dmwit> tsp: If you do "contents <- readFile", then contents has type String. ;-)
04:33:23 <tsp> I did s <- readFile file;
04:33:34 <tsp> I'm assuming that'll return an IO string in s
04:33:38 <malcolmw> quicksilver: e.g. comment = bracket (tok TokCommentOpen) (tok TokCommentClose) freetext
04:33:41 <dmwit> tsp: Kind of.
04:34:22 <tsp> I know IO passes a gonad or whatever
04:34:22 <dmwit> tsp: You can think of "s" as being of type String, inside of an IO computation.  So you can pass it to functions that take a String as their argument.
04:34:29 <quicksilver> malcolmw: yeah, that's pretty close
04:34:35 <tsp> dmwit: ah
04:34:40 <paolino> dmwit , that presume body is not manyTill anyChar, but a well defined parser
04:34:44 <quicksilver> malcolmw: especially since haskell doesn't allow 'outfix' operators without jumping through a lot of hoops
04:34:59 <dmwit> tsp: But you may need to do something to make the return type of that function become an IO computation.
04:35:27 <malcolmw> quicksilver: e.g. xmlProlog = return Prolog `apply` maybe xmldecl `apply` many misc `apply` maybe doctypedecl `apply` many misc
04:35:40 <quicksilver> tsp: there is a sense in which '<-' unwraps the monad
04:35:58 <quicksilver> tsp: so after s <- readFile file; s does in fact refer to a string (not an IO string)
04:36:07 <quicksilver> malcolmw: *nod*
04:36:15 <dmwit> paolino: Good point.
04:36:16 <dons> do we now these guys? --> http://www.iseff.com/2007/03/learning-is-most-important-thing.html and http://blog.mauricecodik.com/2007/03/building-haskell-web-service-part-2.html
04:36:19 <lambdabot> Title: iseff, By Ian Sefferman: Learning is the most important thing, http://tinyurl.com/2drkx6
04:36:33 <dons> "Openomy external API as a web service written in Haskel"
04:37:42 * QtPlatypus from an hour ago "Something to pretty print my data structures, mostly for debugging"
04:38:00 <tsp> can someone go to http://tspivey.freeshell.org/a.hs? it's a test file reading app, but I can't get it to compile worth a shit
04:38:35 <dmwit> tsp: let l = lines s;
04:38:56 <tsp> let? why do I need that? I thought that was only in the interpreter
04:39:15 <dmwit> tsp: This was what I meant when I said that you might need to do something special to get the return type to be in the IO monad.
04:39:28 <dmwit> tsp: Each line of a "do" statement must be an IO type.
04:39:54 <tsp> I tried l <- lines s; also
04:39:55 <dmwit> tsp: So there's a special sugar, "let", that turns normal assignment into IO bindings.
04:40:10 <tsp> I thought <- did that
04:40:23 <laziest> probably the interpreter itself is in a 'do' of IO monad?
04:40:23 <dmwit> tsp: That's the other direction, it turns IO to normal values.
04:40:46 <tsp> hold on, so s <- readFile fname; is actually returning a string?
04:41:13 <dmwit> Hum.  Kind of.
04:41:16 <dmwit> More like:
04:41:27 <tsp> what's the system io module again with putStrLn?
04:41:32 <dmwit> s <- readFile fname; allows you to thread the string s through an IO computation.
04:41:39 <doserj> s <- ... isn't an expression that "returns" something
04:41:47 <dmwit> ?index putStrLn
04:41:48 <lambdabot> System.IO, Prelude
04:42:41 <laziest> tsp: can have a look at 3.14 of the standard which gives a translation of the 'do' construct
04:42:46 <tsp> parse error on putStrLn
04:42:57 <tsp> I'm a haskell newbie, and don't get all this math
04:43:01 <tsp> and gonads and such
04:43:16 * laziest takes his words back
04:44:13 <tsp> :t putStrLn
04:44:15 <lambdabot> String -> IO ()
04:44:39 <tsp> hmm putStrLn shouldn't give me a parse error with import System.IO at the top of the file
04:44:43 <dmwit> tsp: length returns an Int
04:45:02 <dmwit> (but (++) takes a String)
04:45:30 <tsp> I changed the line to putStrLn "hello"; to see if it worked :) but it didn't
04:45:47 <Botje> :t putStrLn "hello"
04:45:50 <lambdabot> IO ()
04:46:10 <Botje> :t do { c <- getContents; putStr c }
04:46:13 <lambdabot> IO ()
04:47:00 <dmwit> tsp: no semicolon after the }
04:47:09 <tsp> I took out the let l = lines s; and it compiles
04:47:19 <dmwit> Hum.
04:47:29 <tsp> I need the ; to end main
04:47:42 <tsp> if I'm going to put another function there, I'll end up forgetting it
04:48:49 <Botje> tsp: main = do { s <- readFile fname; let l = lines s; putStrLn ( "length l = " ++ (show $ length l)) }
04:49:17 <dmwit> Botje: I already suggested it...
04:49:30 <Botje> didn't see that, sorry
04:51:53 <dmwit> tsp: This is odd.
04:52:07 <dmwit> I put it into indentation and it worked fine...
04:52:20 <tsp> http://tspivey.freeshell.org/a.hs
04:53:17 <tsp> I updated it since the first one
04:53:25 <tsp> but it still gives me that parse error unless I remove the let
04:53:48 <tsp> ah, maybe I need let l = lines s in ...;?
04:53:59 <tsp> I don't want my code full of those though
04:54:15 <dmwit> It works, but only for one line.
04:54:23 <tsp> oh
04:54:23 <TSC> Gah, semicolons?
04:55:05 <tsp> TSC: not my fault that ed sucks so bad
04:56:01 <tsp> would let l = lines s in { block }; work?
04:56:10 <tsp> if I wnated to do anything with a block that is
04:56:19 <tsp> or is it a bug somewhere else than my code
04:56:21 <dmwit> tsp: it would have to be
04:56:27 <dmwit> let l = lines s in do { block };
04:56:35 <tsp> oh
04:56:50 <dmwit> It isn't elsewhere.  Like I said, translating it to indentation makes it magically work. =(
04:57:02 <int-e> hmm, but then you can write  do { let l = lines s; block }
04:57:17 <tsp> int-e: that doesn't work with this code for some reason
04:57:32 <resiak> ?paste
04:57:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:57:37 <laziest> tsp: can you paste it on hpaste?
04:57:43 <tsp> I guess, but I hate that thing
04:57:55 <tsp> I have to give it a title, and I don't want it there forever
04:58:13 <dmwit> laziest: tspivey.freeshell.org/a.hs
04:58:17 <int-e> tsp: ah
04:58:37 <int-e> tsp: it's let { l = lines s };
04:58:56 <tsp> int-e: weird
04:59:08 <int-e> tsp: let has its own block, and with explicit markup you have to explicitely say that
04:59:09 <dmwit> Ooooh.
04:59:13 <tsp> ah, that makes sense, you can have more than one thing in a let
04:59:25 <laziest> thanks dmwit; tsp: if you indent everything after 'do', you won't require {, }, ;.
05:00:08 <laziest> int-e: within a 'do' block, let need not have a syntactically separate block
05:00:11 <tsp> laziest: screen readers + indent + ed = bad combination :)
05:00:19 <int-e> laziest: it has one
05:00:31 <int-e> laziest: but usually that fact is conveniently hidden by indentation
05:00:48 <laziest> ya, I said 'syntactically'...
05:01:06 <mux> int-e: hey, got your SVG stripper code. didn't try it yet but it looks cool
05:01:07 <int-e> laziest: well, tsp's program just provided a counterexample to your claim.
05:01:13 <mux> I'll just need to install HXT
05:01:30 <laziest> what is a screen reader?
05:01:30 <tsp> this program is short - I'm not sure what people are going to do with a long program if they need the indents :)
05:01:32 <int-e> mux: nice :)
05:01:54 <tsp> laziest: screen reader is a program that helps blind people read the screen - in basic terms
05:02:38 <laziest> oh! ok. I wasn't aware of this context. sorry.
05:03:08 <tsp> hmm haskell is slow
05:03:23 <tsp> python reads this 20 meg file in about 2.4 seconds - on a 400mhz ultrasparc no less
05:03:36 <tsp> this program chugs along for 4 or 5 seconds on a 2.4ghz P4 under vmware
05:03:47 <dmwit> tsp: For speed, you'll have to switch to ByteStrings.
05:04:16 <tsp> ?doc ByteString
05:04:16 <lambdabot> ByteString not available
05:04:24 <dmwit> ?where ByteString
05:04:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
05:04:34 <tsp> is case really important? I know that's gonna byte me in the ass sooner or later
05:04:41 <dmwit> yep
05:04:53 <tsp> damn
05:04:57 <dmwit> Oh, you mean the "case" keyword, or like case-sensitivity?
05:05:03 <tsp> so putstrln and putStrLn are different?
05:05:07 <laziest> yes
05:05:09 <tsp> case sensitivity
05:05:17 <dmwit> Yes, Haskell is case sensitive.
05:05:31 <siti> but it's very predictable with clear rules...
05:05:36 <dmwit> Case is actually part of the syntax.
05:05:58 <tsp> hmm
05:06:09 <tsp> if I switch to bytestrings, then readFile won't work with i
05:06:10 <tsp> s/$/t
05:06:44 <dcoutts> tsp: Data.ByteString.readFile :-)
05:07:02 <tsp> ah
05:07:20 <tsp> fucking javascript documentation
05:07:31 <tsp> well I should say edbrowse cause it bombs on it
05:09:00 <int-e> tsp: import qualified Data.ByteString.Lazy.Char8 as B  and then use B.readFile and B.lines
05:09:49 <tsp> why not just Data.ByteString.ReadFile/Lines?
05:10:24 <int-e> Data.ByteString would read the whole file into memory
05:10:39 <int-e> and the .Char8 specifies which implementation of 'lines' to use.
05:11:16 <paolino> @pl \x y -> x ++ [y]
05:11:16 <lambdabot> (. return) . (++)
05:11:56 <paolino> @pl \y x-> x ++ [y]
05:11:57 <lambdabot> flip (++) . return
05:12:17 <int-e> return = (:[])  here
05:12:30 <paolino> k
05:12:31 <tsp> hmm, that gave totally different results
05:12:44 <tsp> the file has 314472 lines
05:12:48 <int-e> tsp: x and y were switched
05:12:57 <tsp> this bytestring gave 296617 for length
05:12:58 <int-e> tsp: oh. your program. sorry.
05:13:22 <tsp> maybe bytestrings pruning my file a bit
05:13:31 <tsp> I'll try it with /etc/passwd
05:14:01 <siti> bytestrings are not unicode...
05:14:08 <tsp> that worked
05:14:12 <tsp> this file isn't unicode
05:14:15 <siti> ok
05:14:26 <tsp> its just a cat of *.txt about 20 times
05:14:28 <paolino> dmwit : seen my solution ? (I guess my GPRS was down)
05:14:32 <tsp> that I was using as a python test
05:15:08 <tsp> hmm, time to refactor this code so I can switch from bytestrings to non bytestrings easily
05:15:12 <int-e> tsp: oh. lines strips empty lines :/
05:15:36 <laziest> does it?
05:15:52 <int-e> the lazy bytestring version does.
05:16:06 <dmwit> paolino: Sure, let's see it.
05:16:27 <paolino>  liftM2 (,) (manyTill body (lookAhead terminator)) terminator
05:16:28 <dcoutts> > lines "foo\n\nbar"
05:16:30 <lambdabot>  ["foo","","bar"]
05:16:47 <int-e> > lines (pack "a\n\nn") --> [LPS ["a"],LPS ["n"]]
05:16:48 <lambdabot>   Not in scope: data constructor `LPS'
05:16:55 <tsp> it strips? ah
05:16:57 <tsp> heh
05:17:42 <dmwit> cool
05:17:50 * dmwit heads back to bed
05:17:55 <int-e> strict bytestrings are ok.
05:18:19 <TSC> Is that a bug?
05:18:29 <doserj> it arguably is
05:18:53 <int-e> I'd say so.
05:19:03 <laziest> should be a bug... why should bytestring lines be different from ordinary lines?
05:19:56 <int-e> > lines "\n\na\n\nb\n\n"
05:19:58 <lambdabot>  ["","","a","","b",""]
05:20:22 <dcoutts> laziest: they should be the same, so if they're different it's a bug,
05:22:36 <siti> also words is pretty primitive in bytestrings iirc it only splits with spaces
05:25:49 <doserj> ouch. Data.ByteString.Lazy.Char8.lines is more than 30 lines of code...
05:26:06 <dcoutts> doserj: it's highhly tuned
05:26:12 * dcoutts wrote it
05:26:15 <int-e> looks like a simple oversight to me - lines has to treat 0-length lines separately to preserve the LPS invariant but it fails to add the empty LPS in that case.
05:26:18 <dcoutts> it's got a fast and slow path
05:26:36 <dcoutts> fast path for the common case of a line fitting into the current chunk
05:27:09 <tsp> how do I do a type specifier before a function again?
05:27:11 <doserj> but why is lines different from words?
05:27:24 <doserj> words is a one-liner
05:27:45 <tsp> I tried String -> [String]
05:27:55 <tsp> rfb file = do {.... }; but it died
05:28:41 <tsp> lol so I found a bug?
05:28:57 <flux-> doserj, atleast words folds (bettet word?) consecutive white space into one, whereas lines doesn't do the same for newline
05:28:59 <siti> it's funny how most of the ghc bug reports are really high quality, programmers know how to write them, normal users don't :p
05:29:00 <flux-> s
05:29:12 <int-e> tsp: yup
05:29:16 <tsp> int-e: neat
05:29:26 <tsp> put that at the end?
05:29:31 <tsp> the -> S
05:29:33 <tsp> or s
05:30:06 <tsp> the only bug I found got reported by bugtraq :)
05:30:08 <tsp> s/by/to
05:31:20 <paolino> dmwit: I have a sad connection today sorry
05:31:45 <paolino> anyway , in the end
05:31:47 <paolino> manyTillC2 body terminator compose = ((compose.snd &&& fst) >>> app) `fmap` manyTillC body terminator
05:32:11 <paolino> manyTillC body terminator = liftM2 (,) (manyTill body (lookAhead terminator)) terminator
05:32:40 <paolino> (13:14:43) paolino: now I see it make sense to lose the terminator, if not body and terminator should expose a common joining function
05:34:49 <tsp> couldn't match b.byteString against infered type IO B.Bytestring
05:34:55 <tsp> I know I"m sising something simple, but can't tell what
05:36:16 <doserj> tsp: IO <something> and <something> are different types
05:36:33 <int-e> tsp: you used x <- foo  instead of  let x = foo  ?
05:36:36 <hpaste>  mux pasted "instance Show Square" at http://hpaste.org/1169
05:36:45 <mux> any comments on that?
05:37:01 <int-e> tsp: or vice versa.
05:37:45 <tsp> ack
05:38:16 <mux> it should be shows r . shows f but well
05:38:38 <hpaste>  tsp pasted "fileread" at http://hpaste.org/1170
05:38:40 <mux> err not
05:39:11 <tsp> there it is
05:39:21 <doserj> tsp: rfb simply doesn't return [String]
05:39:37 <tsp> it should
05:39:39 <int-e> tsp: ah. rfb should be of type  String -> IO [String]  (because you're doing IO, you can't escape this)
05:39:48 <tsp> damn
05:40:01 <doserj> rfb :: String -> IO [ByteString]
05:40:11 <tsp> shoulda left the types alone
05:40:18 <int-e> woops. doserj is right of course.
05:40:41 <doserj> well, rfb :: String -> IO [B.ByteString]
05:41:11 <int-e> tsp: if you want a pure function, you could define  countLines :: B.ByteString -> Int  and read the file in Main, then process it, then print the result.
05:41:25 <doserj> but B.lines $ B.readFile actually can't work
05:41:50 <quicksilver> I'd never thought of the screenreader/layout interaction before
05:41:55 <quicksilver> it's an interesting point
05:42:03 <tsp> quicksilver: just curious, is my code hard to read?
05:42:18 * quicksilver scrolls back up to find tsp's URL
05:42:18 <tsp> for the people who can see it and don't use ed that is :)
05:42:23 <tsp> hpsate.org/1170
05:42:25 <tsp> paste
05:42:39 <quicksilver> tsp: no, not at all
05:42:43 <tsp> haskell really isn't that bad
05:42:47 <quicksilver> tsp: but most sighted people use the layout rule
05:42:55 <quicksilver> tsp: so they are unfamiliar with teh exact rules about braces :)
05:42:56 <tsp> I just started to go nuts cause I was trying to go too far too fast
05:43:12 <quicksilver> tsp: in particular, the nested block that 'let' introduces catches lots of people out
05:43:18 <tsp> heh
05:43:45 <tsp> quicksilver: what'll happen when I start writing longer programs? the one I'm writing now I could have done in 10 minutes in python
05:43:56 <quicksilver> tsp: you could have done it in 10 minutes in haskell
05:43:59 <quicksilver> tsp: if you'd known how to :)
05:44:04 <tsp> good point
05:44:13 <quicksilver> tsp: it's not really fair to compare a language you're familiar with, with one that you're not
05:44:17 <tsp> but I"m just getting into functional programming
05:44:24 <tsp> and this stuff about gonads and such are confusing
05:44:45 <quicksilver> fortunately it's not necessary to understand monads to use them
05:44:54 <tsp> heh
05:45:02 <quicksilver> same is true of gonads, in fact
05:45:06 <osfameron> heh
05:45:19 <tsp> I was under the assumption that Gonads and Monads were the same thing if you aliased them
05:45:33 <tsp> they both ahve something to do with math
05:45:54 <tsp> since they have the same end (nads), they must be in the same family of things
05:46:48 <doserj> tsp: rfb file = B.readFile file >>= B.lines
05:46:58 <tsp> ack
05:47:01 <tsp> >>=?
05:47:16 <tsp> I was trying to be smart and nest it :)
05:47:23 <tsp> with the $ trick I heard about from somewhere
05:47:34 <doserj> I don't the $ works here
05:47:40 <int-e> you can use   liftM B.lines $ B.readFile file
05:47:44 <doserj> *think
05:47:58 <int-e> doserj: your's is still wrong - you need to use  return . B.lines
05:48:24 <doserj> right
05:48:25 <tsp> ok, I don't udnerstand how this works. I'm going to turn it simple - to...
05:48:35 <tsp> do { s <- B.readLines file;
05:49:16 <doserj> tsp: that's also fine
05:49:28 <tsp> now... b.Lines will return a [Bytestring], I need it to return an IO [Bytestring]
05:49:36 <doserj> return (B.lines s)
05:49:58 <quicksilver> tsp: I was imagining that you were joking. I suggest you look 'gonad' up in a dictionary, it's quite different :)
05:50:17 <tsp> maybe the bot can do it
05:50:23 <tsp> !google gonad
05:50:59 <doserj> ?google gonad
05:51:00 <tsp> ?google gonad
05:51:01 <lambdabot> http://en.wikipedia.org/wiki/Gonad
05:51:01 <lambdabot> Title: Gonad - Wikipedia, the free encyclopedia
05:51:01 <lambdabot> http://en.wikipedia.org/wiki/Gonad
05:51:02 <lambdabot> Title: Gonad - Wikipedia, the free encyclopedia
05:51:06 <doserj> :)
05:51:16 <tsp> he said it twice
05:51:21 <tsp> ah
05:51:26 <tsp> two of them, irc lcients slow
05:51:38 <tsp> ?google define: gonad
05:51:39 <lambdabot> No Result Found.
05:51:43 <tsp> heh
05:52:30 <tsp> um... testicles?
05:52:43 <tsp> that's a bit strange
05:53:21 <quicksilver> I thought so, too
05:53:25 <quicksilver> that's why I thought you were joking :)
05:53:56 * mux dislikes explicit inlining via pragma
05:54:05 <quicksilver> @remember Andrzej (on Simon Marlow) So YOU are the GOD's angle with the sword!
05:54:06 <lambdabot> Done.
05:54:25 * quicksilver was unsure whether it's funnier to keep the typo as written or fix it before adding :P
05:55:02 <tsp> I don't get it
05:55:28 <quicksilver> tsp: the context is rather long discussion on the haskell-cafe mailing list
05:55:35 <tsp> hmm
05:55:43 <quicksilver> tsp: but even in isolation, the comparison between Simon Marlow and Gabriel is edifying
05:55:58 <tsp> so do {x;y;z }; is the same as x >>= y >>= z?
05:56:08 <quicksilver> tsp: x >> y >> z
05:56:24 <resiak> do {a <- x; y}  is x >>= \a -> y
05:56:31 <quicksilver> tsp: or, x >>= \_ -> y >>= \_ -> z
05:56:36 <tsp> ouch ouch ouch
05:56:48 <tsp> all these symbols
05:56:58 <quicksilver> tsp: '>>' means sequence these two operations, throwing away results
05:56:58 <doserj> I can only imagine a screen reader spelling out these lines...
05:57:12 <quicksilver> tsp: '>>=' means sequence these two operations, binding results from the first into the second
05:57:16 <tsp> doserj: its saying all the \'s and >'s, etc
05:57:31 <tsp> quicksilver: what is the equivalent do {} for x >>= y>
05:57:35 <tsp> s/>$/?
05:57:55 <int-e> tsp: do { t <- x; y t }
05:57:59 <quicksilver> tsp: do { result <- x; y result }
05:58:09 <resiak> doserj: I'm trying to figure out whether Perl would sound worse than >>=-notation.
05:58:29 <quicksilver> tsp: if you can teach the reader aliases, you mind consider reading >>= as 'bind' and >> as 'then'
05:58:38 <doserj> resiak: lol
05:58:51 <tsp> once i write my screen reader, I can do that
05:59:05 <doserj> and <- as 'from'
05:59:23 <tsp> ah
05:59:35 <tsp> python is so much easier, but this is more brain stretching
06:02:09 <tsp> :t split
06:02:13 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
06:02:17 <tsp> ?
06:02:33 <tsp> that made no sense
06:02:47 <doserj> @type splitAt
06:02:50 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:02:57 <tsp> what does splitting a string have to do with a random number generator?
06:03:22 <osfameron> resiak: some Perl is far far worse (and vice versa) ;-)
06:03:30 <tsp> I thought split split strings?
06:03:40 <tsp> > split "test" " "
06:03:41 <lambdabot>  Couldn't match expected type `[Char] -> t'
06:03:48 <tsp> I thought it just did
06:03:55 <resiak> osfameron: I can imagine.
06:04:17 <tsp> @type split
06:04:19 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
06:04:33 <tsp> it takes one arg and produces a tuple
06:04:39 <tsp> > split "test"
06:04:39 <lambdabot>   add an instance declaration for (RandomGen [Char])
06:04:40 <lambdabot>     In the expression: s...
06:04:54 <resiak> tsp: 'split' is not for splitting strings :)
06:04:55 <quicksilver> tsp: there isn't a string split quite like what you're looking for
06:04:58 <tsp> does this split have anything to do with strings?
06:05:02 <quicksilver> nothing
06:05:04 <quicksilver> :unwords
06:05:06 <quicksilver> :t unwords
06:05:09 <lambdabot> [String] -> String
06:05:11 <tsp> ah
06:05:15 <quicksilver> always get them backwards
06:05:17 <quicksilver> :t words
06:05:20 <lambdabot> String -> [String]
06:05:31 <tsp> that doesn't ofer a delimiter though
06:05:32 <quicksilver> there isn't a generic 'split on some particular string or regexp'
06:05:38 <quicksilver> which is often the subject of comment on this channel
06:05:39 <tsp> so I can't tell it waht makes up a word
06:05:59 <tsp> > words "en la komenco, dio kreis la cxielon kaj la teron"
06:06:00 <lambdabot>  ["en","la","komenco,","dio","kreis","la","cxielon","kaj","la","teron"]
06:06:01 <quicksilver> I suspect it's because there are so many obvious variations and it's not obvious which would be best
06:06:36 <int-e> @index span
06:06:37 <lambdabot> Data.List, Prelude
06:06:43 <tsp> > let s = "en la komenco" where words s == unwords s
06:06:43 <lambdabot>  Parse error
06:06:46 <tsp> piece of shit
06:07:01 <tsp> :t span
06:07:03 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:07:21 <tsp> wtf is teh forall x.?
06:07:25 <tsp> :t forall
06:07:27 <lambdabot> Not in scope: `forall'
06:08:07 <int-e> @index splitWith
06:08:07 <lambdabot> bzzt
06:08:32 <tsp> :t splitWith
06:08:34 <lambdabot> Not in scope: `splitWith'
06:08:49 <int-e> Bytestrings have a splitWith;  splitWith (=='a') "aabbaca" == ["","","bb","c",""]
06:09:13 <quicksilver> tsp: forall means that work for any type 'a' you choose to give it
06:09:20 <quicksilver> tsp: e.g.:
06:09:22 <quicksilver> :t length
06:09:24 <lambdabot> forall a. [a] -> Int
06:09:47 <quicksilver> tsp: length works on lists of any type 'a'
06:09:50 <tsp> ah
06:10:12 <quicksilver> tsp: similarly span let's you span on any predicate
06:10:22 <tsp> predicate?
06:10:31 <tsp> math terms invasion lol
06:10:32 <quicksilver> > span (==',') "foo,bar,baz"
06:10:34 <lambdabot>  ("","foo,bar,baz")
06:10:41 <quicksilver> blah
06:10:45 <quicksilver> > span (/=',') "foo,bar,baz"
06:10:46 <lambdabot>  ("foo",",bar,baz")
06:10:48 <quicksilver> tada!
06:10:49 <quicksilver> :)
06:12:10 <tsp> neat
06:12:15 <tsp> so its like filter but for strings
06:12:29 <tsp> damn, that made no sense
06:12:41 <quicksilver> no, filter works fine on strings
06:12:45 <tsp> so its like python's split but better
06:12:48 <tsp> that works
06:12:50 <int-e> tsp: no, it works on lists. it's a combination of takeWhile and dropWhile
06:12:51 <quicksilver> tsp: span is actually a combination of 'takeWhile' and 'dropWhile'
06:13:08 <int-e> @quote stereo
06:13:08 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
06:13:18 <tsp> @quote gonads
06:13:19 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
06:13:36 <tsp> what's a rutabaga?
06:13:44 <tsp> is it a function or something
06:13:47 <tsp> :t rutabaga
06:13:49 <lambdabot> Not in scope: `rutabaga'
06:14:00 <Cale> The rutabaga has already outsmarted you.
06:14:09 <tsp> I'll look it up later in the haskell docs
06:14:10 <Cale> http://en.wikipedia.org/wiki/Rutabaga
06:14:12 <lambdabot> Title: Rutabaga - Wikipedia, the free encyclopedia
06:14:15 <earthy> koolraap!
06:14:51 <tsp> its a vegetable?
06:14:53 <tsp> lol
06:15:51 <tsp> is there something like c's /* */ in haskell?
06:16:02 <mux> tsp: {- and -}
06:16:05 <tsp> oops
06:16:06 <tsp> heh
06:17:37 <dons> Cale: not mentoring SoC projects this year?
06:19:35 <tsp> if I want to define a function with two or 3 statements without using do {}, how do I do it in brace style?
06:19:41 <Cale> dons: I dunno. Is there a need for more mentors?
06:19:42 <tsp> do I just put { after the = and a }; at the end?
06:20:36 <Cale> tsp: uhh
06:20:41 <Cale> tsp: I'm not sure what you mean.
06:20:58 <Cale> The rhs of a function declaration is always an expression
06:21:00 <Igloo> tsp: You still need do
06:21:08 <dons> Cale: not really, I suppose. let me see if there's any mathy things you might like.
06:21:13 <Igloo> f x = do { s1; s2 }
06:22:00 <Cale> braces are used to group blocks of lines as bits of other syntax, let, where, do, case, and such
06:22:18 <tsp> I thought do {} was just for gonads
06:22:22 <tsp> s/gon/mon
06:22:31 <Cale> do-notation is just for monads
06:22:50 <Cale> What is it that you're trying to express?
06:22:56 <Cale> Do you know about let?
06:23:48 <tsp> oh
06:23:54 <tsp> ok... I have a dictionary
06:24:00 <tsp> or something that  is going to look like a dictionary
06:24:08 <tsp> [(word, word),...]
06:24:42 <tsp> and I want to replace all of the words in (words str) with their corresponding value in the dict if they exist
06:25:04 <tsp> I don't know how to express that in haskell though
06:25:20 <Cale> okay
06:25:20 <tsp> its not like I can say dict["key"] :)
06:25:27 <EvilTerran> ?src lookup
06:25:27 <lambdabot> lookup _key []          =  Nothing
06:25:28 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
06:25:28 <lambdabot>                         | otherwise = lookup key xys
06:25:29 <Cale> Look at Data.Map
06:25:43 <Cale> or yeah, you can use the ghetto list lookup
06:25:58 <EvilTerran> (if you want to do it yourself. as Cale says, this is very much a bindun.)
06:26:08 <tsp> heh, I need the experience
06:26:47 <tsp> lookup? lets see, a recursive function would do it
06:27:26 <EvilTerran> lookup's already defined...
06:28:20 <EvilTerran> lambdabot's ?src only pulls stuff out of the libraries, afaik
06:28:27 <Cale> lookup "cat" [("cat", "meow"), ("dog", "woof")]
06:28:30 <Cale> > lookup "cat" [("cat", "meow"), ("dog", "woof")]
06:28:32 <lambdabot>  Just "meow"
06:28:35 <quicksilver> tsp: the standard 'poor-mans' dictionary is just a list of pairs
06:28:45 <EvilTerran> > lookup "elephant"  [("cat", "meow"), ("dog", "woof")]
06:28:46 <tsp> quicksilver: that's all I need
06:28:47 <lambdabot>  Nothing
06:28:53 <quicksilver> tsp: Data.Map is a more sophisticated (and faster) tree-based setup
06:28:57 <tsp> I don't get this Nothing and Just thing
06:29:03 <Eelis> that is one poor man indeed
06:29:08 <tsp> is Nothing a number?
06:29:11 <Cale> Nothing represents failure to locate a value
06:29:20 <int-e> tsp: there's a maybe type.   data Maybe a = Just a | Nothing
06:29:20 <quicksilver> tsp: it's not returning strings
06:29:22 <EvilTerran> ?src Maybe
06:29:23 <lambdabot> data Maybe a = Nothing | Just a
06:29:26 <quicksilver> tsp: it's returning 'Maybe strings'
06:29:28 <Cale> Just x represents success together with the result x
06:30:11 <Cale> In C, you'd do something ridiculous, like return a null pointer when you failed.
06:30:24 <Cale> This just formalises the case where functions might fail.
06:30:46 <mux> that always makes me think of the atoi() mess in C
06:30:52 <Cale> You can then pattern match to handle the two cases.
06:31:01 <Cale> case (lookup word dict) of
06:31:04 <Cale>   Nothing -> ...
06:31:09 <Cale>   Just x -> ...
06:31:15 <tsp> ah
06:31:16 <tsp> got it
06:31:19 <mux> it's a good example of how things go wrong when people try to force values representing failures in types where there isn't room for it
06:31:46 <tsp> mux: how so?
06:31:52 * tsp checks the man page for atoi
06:32:30 <tsp> it says nothing about errors but that it need not effect errno
06:32:52 <mux> man pages for atoi() are likely to just redirect to strtol() these days
06:33:05 <mux> but atoi() has been defined so badly that it isn't really usable
06:33:12 <narain> tsp: if you believe cplusplus.com, atoi returns zero on invalid input
06:33:14 <mux> which is why strtol() was created
06:33:35 <Cale> Wikipedia indicates that when atoi encounters a string with no numerical sequence, it returns a 0.
06:33:37 * narain goes off writing a little program to test
06:33:39 <mux> narain: that's even worse than that even if in practice that's what happens
06:33:51 <mux> atoi() can return 42 in case of a failure if it so wishes
06:34:27 <Cale> Yeah, the man pages are less specific about what it does in the case of failure.
06:34:39 <EvilTerran> well, if you view it as reading off the longest possible numeric prefix, returning 0 on no-string would be the sensible option...
06:34:39 <mux>        [#1] The functions atof, atoi,  atol,  and  atoll  need  not
06:34:40 <mux>        affect  the  value  of  the  integer  expression errno on an
06:34:40 <mux>        error.  If the value of the result  cannot  be  represented,
06:34:40 <mux>        the behavior is undefined.
06:34:52 <narain> heh, there should be an ATOI_ERROR value defined that you can check against ... and you'd have to do things like "Enter a number, any number... as long as it isn't %d"
06:35:05 <mux> EvilTerran: and how do you know if it returns 0 because you called atoi("0") or if there was an error parsing the number?
06:35:21 <Cale> I vote for ATOI_ERROR = 5
06:35:42 <mux> this problem is fixed with strtol() anyways, even if it's in a still sub-optimal way
06:35:55 <EvilTerran> mux, i'm just saying it's a logical degenerate case; seeing as all digits you leave off the start of a number are assumed to be zero, having no digits => whole number's zero
06:36:05 <mux> ah, I see your point
06:36:11 <tsp> damnit - how do I append to a list? if I do let { ...; l = []; } in {...
06:36:19 <EvilTerran> that's probably not what anyone wants, but it's logical. :P
06:36:26 <tsp> then can I do l = l:item?
06:36:26 <quicksilver> tsp: you don't change values of things, in haskell
06:36:31 <quicksilver> tsp: you construct new values
06:36:40 <tsp> and put them where?
06:36:41 <tsp> heh
06:36:41 <quicksilver> tsp: you just use (item:l) as your new list
06:36:49 <narain> well, atoi("forty-two") returns zero under gcc in linux
06:36:56 <quicksilver> tsp: you could do let m = item:l if you want
06:37:01 <tsp> ah, then call it again
06:37:02 <Cale> Setting errno is the dumbest possible system for reporting errors I can think of.
06:37:08 <tsp> recursive functions, forgot about those
06:37:09 <quicksilver> tsp: you actually can do let l = item:l, but it's a new 'l' :)
06:37:37 <quicksilver> tsp: if, for example, you do let m = item:l ; n = otheritem:l
06:37:41 <narain> quicksilver: won't that create an infinite list of [item,item,item,...]?
06:37:46 <quicksilver> tsp: then the two lists 'm' and 'n' share most of their space
06:37:51 <Cale> (other than not at all)
06:37:52 <quicksilver> narain: bah, you're right
06:38:07 <quicksilver> narain: that was an ML-moment :)
06:38:29 <Jonsaveslives> I was wondering if I could get some help regarding a haskell function I am trying to implement..
06:38:40 <narain> quicksilver: an understandable mistake :)
06:39:00 <Cale> Jonsaveslives: absolutely
06:39:08 <Cale> but I'm going to sleep :)
06:39:24 <Cale> ask away, there are plenty of helpful people around :)
06:39:34 <Cale> and if you need to paste code,
06:39:36 <Cale> !paste
06:39:36 <hpaste> Haskell paste bin: http://hpaste.org/
06:39:49 <mux> narain: yes, that's because atoi() ends up calling strtol() in practice, and strtol() has better guarantees
06:40:04 <mux> narain: the point is that the standard allows atoi() to return anything in case of a parse failure
06:40:16 <narain> mux: i didn't know that about strtol()
06:40:19 <Jonsaveslives> I'll paste it using that address.. won't be 2 secs
06:40:26 <mux> and doesn't require atoi() to set errno either
06:41:01 <mux> anyways, that's a bit off-topic I guess
06:42:25 <tsp> :t map
06:42:27 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:42:27 <dcoutts> dons: you about?
06:42:44 <hpaste>  JH pasted "Trouble" at http://hpaste.org/1171
06:42:54 <narain> mux: thanks for letting me know about strtol, it looks good
06:42:57 <tsp> > map (+ 2) [1,2,3]
06:42:57 <dcoutts> dons: I'm getting interesting results from my concatMap experiment
06:42:58 <lambdabot>  [3,4,5]
06:43:01 <mux> narain: you're welcome
06:43:03 <Jonsaveslives> http://hpaste.org/1171
06:43:09 <Jonsaveslives> ohh..hmmm posts that for me :\
06:43:31 <mux> narain: if you are as interested as I am in C nitpicking, you'll see that even calling strtol() correctly in a 100% standard way is a bit of a fight :-)
06:43:51 <resiak> Jonsaveslives: in mode you are calling "total xs", but total has type Int -> [Int] -> Int
06:44:12 <narain> mux: really? i didn't see that, could you explain?
06:44:35 <Jonsaveslives> resiak: ...yes? :\
06:45:09 <mux> narain: since you can still not assume that strtl() returning 0 means failure (it could also be returned in the strtol("0") case), you need to check errno, and thus you need to explicitely clear errno prior to calling strtol(), and then checking if it's EINVAL
06:45:28 <quicksilver> Jonsaveslives: looks like 'total' is supposed to count the number of occurences of 'x'?
06:45:35 <quicksilver> Jonsaveslives: well it can't do that, if you only give it one parameter
06:46:20 <Jonsaveslives> quicksilver: I see what you mean, but I'm not sure how I could retify this.. :\
06:46:33 <hpaste>  tsp pasted "broken code" at http://hpaste.org/1172
06:46:34 <narain> mux: according to the man pages i read, strtol doesn't set errno on failure
06:46:51 <tsp> there's another one :) I almost have it, but some weird case error popped up
06:46:59 <narain> mux: because it isn't actually "failure", more like the number of digits in the number happened to be zero
06:47:01 <mux> narain: your man page is probably broken, this is required by the standard and that's why strtol() is usable unlike atoi()
06:47:34 <mux> oh wait, that's worse than that, I didn't remember that bit
06:47:46 <mux> indeed setting errno to EINVAL isn't required by the standard
06:47:58 <mux> that's why you should use endptr to determine if at least one digit was parsed :-)
06:48:04 <mux> aaah, the joy of strtol().
06:48:11 <narain> mux: are we talking about the same strtol which has prototype long strtol(const char *s, char **end_ptr, int base);
06:48:21 <narain> never mind
06:48:25 <narain> you got it
06:48:28 <mux> there's only one strtol() :-)
06:48:32 <tsp> can someone check out my code, please? the case in particular
06:49:16 <mux> narain: however, most implementations set errno to EINVAL in case of a parse error, which make things easier.  this is an X/Open extension to the standard, IIRC
06:49:18 <narain> tsp: fileread?
06:49:23 <tsp> no
06:49:26 <tsp> hpaste.org/1172
06:49:44 <mux> narain: check the SUSv3 docs if you want all the details
06:49:50 <quicksilver> tsp: (unwords . map (replaceword dict)) lst
06:49:53 <kmg> System.Directory.getDirectoryContents gives me a list with ., .. and dirs included, how to get only the files in dir, is there a isFile function i am missing ?
06:49:58 <quicksilver> tsp: or, use $ instead of an extra level of ()
06:50:33 <tsp> quicksilver: it's the replaceword function that won't compile
06:50:35 <narain> mux: hmm, well this much c lawyery is enough for me :)
06:50:40 <int-e> tsp: and the type will have to be  [(String, String)] -> [String] -> String
06:50:54 <narain> mux: susv3 docs, probably not :)
06:51:19 <mux> heh
06:51:21 <int-e> tsp: swap the arguments of lookup
06:51:35 <narain> :t lookup
06:51:36 <tsp> ah
06:51:38 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:51:41 <mux> narain: I like it when standards have it wrong, it's "fun", for some value of "fun" :-)
06:52:02 <narain> mux: indeed, it can be "interesting"
06:52:24 <mux> narain: my second next favourite is the dlsym() function
06:52:39 <int-e> tsp: btw there is no reason to treat the empty list separately
06:52:40 <narain> mux: though it can be argued that atoi("forty-two") == 0 is not wrong behaviour
06:52:49 <chessguy> 'morning haskellers
06:52:53 <mux> hi chessguy
06:52:59 <narain> mux: i have never heard of the dlsym() function
06:53:04 <narain> hi chessguy
06:53:51 <tsp> int-e: lol, forgot about that
06:53:57 <tsp> since lookup will return nothing
06:54:06 <narain> mux: hmm, dlsym doesn't look like something i want to hear about
06:54:29 * narain goes afk for a bit
06:54:31 <mux> if you're doing C, at some point chances are that you'll need it
06:54:42 <tsp> wy does the unwords . map (...) work?
06:54:44 <tsp> s/dow/sdoesnt
06:54:47 <tsp> doesn't
06:54:57 <tsp> I thought x . y would call y(x)
06:55:43 <doserj> . is function composition
06:55:54 <doserj> not function evaluation
06:55:57 <tsp> same thing
06:55:58 <int-e> tsp: no, $ does that. x . y  is function composition,  (x . y) a = x (y a)
06:56:38 <int-e> @type ($)
06:56:40 <doserj> the problem however is the precedence
06:56:41 <lambdabot> forall a b. (a -> b) -> a -> b
06:56:43 <int-e> @type (.)
06:56:46 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:56:47 <quicksilver> tsp: there is a big different between function composition and function evaluation
06:57:30 <quicksilver> tsp: (+1) f tries to add one to 'f'.  On the other hand, (+1) . f is a function which adds one to the result of applying f to an argument
06:57:37 <tsp> hmm
06:57:50 <tsp> weird
06:57:52 <tsp> I'll get there eventually
06:58:04 <quicksilver> :)
06:58:17 <doserj> your code gets parsed as unwords . (map ... lst)
06:58:21 <Jonsaveslives> bah, I need a break from Haskell
06:58:32 <tsp> I was going to make a blog specifically called haskell hell, but not anymore :)
06:58:41 <doserj> but you want (unwords . map ...) lst
06:59:18 <quicksilver> haskell heaven, and python purgatory
06:59:58 <osfameron> perl paradise :-)
07:00:28 <cragwolf> Is there a continuation character in Haskell for allowing very long strings to span multiple lines or am I stuck with ++ing smaller chunks of it together?
07:00:34 * mux stares at osfameron 
07:01:05 <quicksilver> cragwolf: ++, or I sometimes use concat["long","lines","of","string"]
07:01:11 <tsp> hey, it works
07:01:15 <tsp> the first time I ran it
07:01:22 <mux> tsp: haskell effect
07:01:23 <doserj> > "abcdef\        \ghijk"
07:01:25 <lambdabot>  "abcdefghijk"
07:01:26 <quicksilver> cragwolf: partly because editors line up big [..] blocks nicely
07:01:38 <Wallbraker> 15:55 < tsp> weird
07:01:53 <tsp> ?
07:01:54 <osfameron> quicksilver: can you not define heredocs in haskell?  with the syntax being so flexible.  Well, not that it matters as for anything serious you'd be using templates anyway, but seems odd.
07:02:05 * tsp goes off to rewrite this in python
07:02:09 <mux> osfameron: there is a HereDocuments extension
07:02:10 <cragwolf> thanks, I'll try that
07:02:18 <quicksilver> osfameron: the syntax is flexible, but the lexical structure isn't
07:02:34 <wolverian> heh, I'm such an ass for wanting ratpoison to use freetype to get nice fonts.
07:02:45 <quicksilver> osfameron: heredocs are a lexical issue, unless you embed them inside big strings or something
07:02:45 <therp> tsp: "Programs that compile work" -- this is only false for a statistically insignificant precentage of programs. (my personal experience)
07:03:19 <tsp> therp: I guess the only reason it doesn't work is a off-by-1 error or just not understanding the problem
07:03:31 <therp> tsp: mostly yes.
07:03:33 <osfameron> mux, quicksilver: cool, ta
07:03:34 <tsp> neat
07:03:59 <quicksilver> osfameron: languages with open lexical structures are tricky to make comfortable. TeX is an example of one :)
07:04:12 <tsp> tex is weird
07:04:23 <osfameron> tex is batshit insane
07:04:39 <therp> knuth is almost discreditated for creating TeX (imho)
07:04:39 <osfameron> it amazes me that latex is so unhelpful at pointing out where your errors are
07:04:46 <quicksilver> tex is deeply, profoundly sane
07:05:02 <osfameron> not being able to work out which \begin didn't match with and \end is just stupid
07:05:03 <quicksilver> tex is the most consistent, detailed, accurate language model I've ever seen
07:05:27 <osfameron> he's a computer scientist, how come he can't provide useful error reporting from his parser?
07:05:31 <quicksilver> it's just surprisingly different from modern languages; and predates many useful observations
07:05:40 <ivanm> osfameron: he did TeX, not LaTeX
07:05:43 <quicksilver> osfameron: LaTeX was written by (far, far) lesser men than Knuth
07:05:48 <wolverian> I like texmac's language more than tex.
07:05:48 <ivanm> LaTeX is by lamport, not knuth
07:05:52 <wolverian> s/texmac/texmacs/
07:06:00 <ivanm> wolverian: but texmacs is too slow and cludgy, IMHO
07:06:09 <wolverian> ivanm, it's not slow here. it is cludgy, yes.
07:06:12 <ivanm> if the re-did the interface, I'd rethink using it
07:06:22 <quicksilver> not that I particularly mean to impune lamport
07:06:26 <wolverian> ivanm, yeah, they're doing that.
07:06:29 <quicksilver> most people are lesser men than knuth
07:06:30 <ivanm> wolverian: slow/cludgy: cludgy implies slowing down of usage
07:06:31 <osfameron> quicksilver, ivanm: ah, I thought that Latex was just macros around tex, and so the error reporting/parsing would be based on it
07:06:32 <quicksilver> but still...
07:06:41 <osfameron> in that case, I'll hate latex instead of tex :-)
07:06:49 <wolverian> ivanm, ah, yeah. the keyboard functionality isn't too bad, imho, but the ui is horrid, yes.
07:06:53 <wolverian> er, gui.
07:06:56 <ivanm> osfameron: it is based around it, but it has its own errors and problems
07:07:05 <osfameron> I mean, latex is also lovely, but I really really hate having to debug a *document*, especially if it can't even give me decent error reporting
07:07:06 <quicksilver> osfameron: latex is 'just' macros around tex, but to a greater or lesser extent it has its own (bad) error reporting
07:07:20 <ivanm> osfameron: like its table layout system is a PITA and quite crap
07:07:37 <ivanm> quicksilver: how about ConTeXt? have you used it?
07:07:38 <osfameron> I mean, I *could* write a lint program to check \begin and \end tags (the one single biggest error I keep on making), but it just seems annoying that it's not built in
07:07:58 <ivanm> osfameron: the "$" errors are the worst...
07:08:06 <cragwolf> I should read the Haskell report (2.6):  "A string may include a "gap"---two backslants enclosing white characters---which is ignored"
07:08:39 <xs> auctex for emacs with preview-latex is pretty good. as is lyx.
07:09:31 <therp> I spend a week just to correct obscure layout errors my 100-pages thesis.
07:09:39 <osfameron> ivanm: ah, yeah fair enough - I was laying out a beamer presentation rather than anything mathsy so didn't have problems with that particularly
07:09:43 <quicksilver> cragwolf: someone gave you a demo of that seconds after you asked :P
07:09:58 <wolverian> has anyone tried lout?
07:09:58 <mux> what annoys me with TeX is that it's written in Web and translated to C automatically
07:10:09 <ivanm> osfameron: beamer is a set of macros on top of a set of macros on top of TeX ;-)
07:10:09 <wolverian> looks vaguely like texinfo :)
07:10:20 <mux> doesn't make for a pleasant hacking of the sources
07:10:25 <quicksilver> it certainly didn't take me a week to debug layout errors in my thesis :P
07:10:26 <ivanm> mux: why is that annoying? isn't Web just literate C?
07:10:31 <quicksilver> ivanm: pascal
07:10:34 <ivanm> quicksilver: *nod*
07:10:38 <ivanm> ahhh,
07:10:39 <ivanm> k
07:10:43 <mux> it's some kind of pascal yeah
07:10:44 <wolverian> "The Lout programming language is similar to other functional languages. The core programming language consists of less than 30 primitive operators[1]. Some features make it particularly close to Haskell, notably the fact that Lout expressions are lazily evaluated." --http://en.wikipedia.org/wiki/Lout
07:10:44 <lambdabot> Title: Lout - Wikipedia, the free encyclopedia
07:10:58 <wolverian> (it's a typesetting language.)
07:10:59 <osfameron> ivanm: yeah, I'm thinking I'll probably find a markup langauge that I can preprocess into a set of macros atop a set of macros atop of TeX, just to confuse myself even more.
07:11:06 <cragwolf> quicksilver: yeah, I know, I just wanted to announce to the world how lazy I am for not reading the report more throughly ;)
07:11:17 <osfameron> (that or go back to OO-Impress, the buggy piece of crap)
07:11:30 <mux> but TeX's versioning scheme is the best in the world
07:11:35 <mux> that can't be denied :-)
07:11:43 <therp> mux: that's true :)
07:11:58 <ivanm> osfameron: well, its not a presentation program, but I've been asked to help out an a java preprocessor for LaTeX to generate maths problems ;-)
07:12:14 <ivanm> mux: what, freezing it a pi when knuth dies?
07:12:39 <quicksilver> I think TeX has to be viewed in context
07:12:41 <mux> ivanm: sorry, EPARSE
07:12:48 <quicksilver> it is an *incredibly* long lived program
07:12:53 <quicksilver> which is still used every day all over the world
07:12:57 <quicksilver> and contains (apparently) no bugs
07:13:08 <quicksilver> that's a hard record to get close to
07:13:10 <ivanm> how long did it take him to write? 10 years
07:13:17 <quicksilver> 5-10, yes
07:13:21 <quicksilver> depending what you mean by 'write'
07:13:27 <ivanm> quicksilver: one problem with TeX is that heap size is fixed, IIRC
07:13:31 <ivanm> not dynamic...
07:13:37 <mux> yes, TeX uses static arrays
07:13:52 <ivanm> then again, that helps prevent space leakage, etc when your macros recurse to infinity ;-)
07:15:08 <quicksilver> it's clearly not a big problem given the size of documents people regularly include in it
07:15:20 <quicksilver> including in some cases procedural pictures which make quite a drain on the heap space
07:15:27 <quicksilver> and you can always change it on the command-line, no?
07:15:29 <ivanm> quicksilver: but nowadays, people use eTeX, which has doubled the heap size IIRC
07:15:40 <ivanm> mainly due to the various requirements of the LaTeX macros, presumable
07:15:46 <ivanm> s/presumable/presumably
07:16:03 <ivanm> quicksilver: I think the heap size is built in... could be wrong though
07:16:32 <ivanm> AFAIK, hardly anyone uses Knuth's original TeX, usually just derivatives such as eTeX
07:18:03 <matthew-_> quicksilver: standard latex in debian (texmf ?) can certainly be configured
07:18:19 <matthew-_> I had to do that for some docs I was working on (heap size exhausted)
07:18:37 <ivanm> *shrug* so I was wrong
07:20:48 <Jonsaveslives> :s Sorry guys, I'm still having trouble implementing this damned function: http://www.hpaste.org/1171
07:21:19 <emu> I use teTeX and MikTeX
07:21:45 <quicksilver> Jonsaveslives: which part is giving you trouble?
07:21:54 <matthew-_> emu: mmm. I actually have no idea what I use. It seems to work though ;-)
07:22:00 <ivanm> emu: they're just packages... not actual programs
07:22:22 <ivanm> eTeX is an actual program, AFAIK: they took Knuth's code, made some changes and recompiled
07:22:33 <ivanm> pdfTeX involved a lot more changes ;-)
07:22:49 <wolverian> ewww, lout uses Times as the default font.
07:22:54 <emu> yea, distributions
07:23:41 <Jonsaveslives> quicksilver: I'll add to my what I 'm having trouble with
07:24:14 <doserj> Jonsaveslives: can you say what the function actually should do?
07:24:41 <hpaste>  JH annotated "Trouble" with "(no title)" at http://hpaste.org/1171#a1
07:25:17 <quicksilver> Jonsaveslives: well, I already explained that to you
07:25:24 <quicksilver> Jonsaveslives: total takes two arguments, and you're giving it one
07:25:45 <doserj> to make it compile, you could exchange (total xs) with (mode xs)
07:25:55 <doserj> but I have no idea if that is what you want
07:26:13 <doserj> what should the "mode" of a list be?
07:26:17 <resiak> the most common element
07:26:36 <quicksilver> I could write mode in a dozen ways, I'm sure
07:26:43 <quicksilver> but I was trying to get to find out what Jonsaveslives was trying to do )
07:26:48 <quicksilver> and see if I could help him through that
07:27:21 <Jonsaveslives> I'm trying to understand it, lol.. I know it only gas one argument right now but I'm not toosure how to give it two..
07:27:51 <quicksilver> it's your program, thouhg :) what were your intentions when you wrote that line?
07:29:10 <Jonsaveslives> to get it to add up the same number of appearing ints
07:30:13 <Jonsaveslives> and display it when the evaluation is done
07:30:56 <quicksilver> well total looks like it might work
07:31:03 <quicksilver> although I haven't tested it
07:31:18 <quicksilver> nothing in your code 'displays' anything
07:31:24 <quicksilver> (which is perfectly sensible)
07:31:32 <ivanm> is there a library for tries anywhere?
07:31:35 <ivanm> @hoogle trie
07:31:36 <lambdabot> Test.HUnit.Base.tried :: Counts -> Int
07:31:39 <Jonsaveslives> yea
07:31:40 <ivanm> :(
07:31:42 <quicksilver> it's the 'if' statement in the definition of mode I'm not sure about
07:33:02 <Jonsaveslives> :(
07:33:16 <Jonsaveslives> i've spent a few hours trying to fix it but just can't seemt o budge it
07:33:23 <quicksilver> what condition are you trying to specify?
07:33:32 <quicksilver> can you explain in english what that 'if' is supposed to do?
07:34:55 <Jonsaveslives> quicksilver: the mode 'if'?
07:35:29 <Jonsaveslives> or the 'total' if?
07:40:02 <petekaz> @seen sjanssen
07:40:03 <lambdabot> sjanssen is in #haskell-soc, #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 6h 58m 6s ago.
07:40:21 <petekaz> Does anyone know if the VNC issue has been fixed in xmonad yet?
07:40:58 <xeroxuni> ?where logs
07:40:59 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
07:41:17 <Jonsaveslives> quicksilver: 'if' is suppose to see the total number of ints inputted is no more than 1 and if it is to insert the mode of that input given
07:47:37 <emu> is Miranda IM written in Miranda?
07:47:44 <tsp> heh
08:01:40 <Igloo> Am I missing something or is there no Parsec function that takes a predicate?
08:02:25 <Igloo> Something like satisfies :: (tok -> Bool) -> GenParser tok st tok, used like this: satisfies isAlpha   ?
08:04:16 <kowey> there's satisfy :: (Char -> Bool) -> etc...
08:05:23 <Igloo> Ah! It's just only defined for Char, so I didn't find it
08:05:25 <Igloo> Thanks!
08:09:40 <alexj> @seen glguy
08:09:41 <lambdabot> I saw glguy leaving #haskell-blah and #haskell 17h 40m 37s ago, and .
08:27:21 <ClaudiusMaximus> how would i go about storing plugin state with multiple plugins each having a different type of state?  would   "Typeable a => Data.Map PluginID a" in the main app and using 'cast' in the plugins be a reasonable way to go?
08:28:21 <kpreid> I don't think that'll work; you need an existential. you can get a prebuilt one using Data.Dynamic
08:29:51 <ClaudiusMaximus> ?docs Data.Dynamic
08:29:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
08:31:58 <ClaudiusMaximus> kpreid: yep, that looks like it should do the trick :)
08:39:01 <ClaudiusMaximus> hmm, actually i might not need it at all - if i have a single plugin entry point that i guaranteed to be called only once, setup::IO (a->IO b), and have creator:: c-> a-> IO b; then setup = do { myState <- newIORef ; return (creator myState) }
08:40:30 <ClaudiusMaximus> what's that technique called?
08:45:52 <Mitar> how can i read a list of integers from stdin, delimeted by spaces?
08:45:59 <Mitar> (or newlines)
08:46:31 <Baughn> Mitar: reads, likely
08:47:06 <Baughn> > reads "14 15"
08:47:09 <lambdabot>  [(14," 15")]
08:47:21 <mauke> > map read . words $ "1 2 3 4"
08:47:22 <lambdabot>  [1,2,3,4]
08:47:53 <Baughn> That's cleaner. How come reads wraps the result in a list? Am I missing something?
08:48:12 <ClaudiusMaximus> @type words
08:48:14 <lambdabot> String -> [String]
08:48:31 <earthy> do { input <- getContents; let splitinput = concat . (map words) . lines $ input; let integers = map read splitinputs }
08:49:05 <earthy> baughn: reads is a primitive that stops when parsing fails and returns the partial parse and the rest of the list
08:49:05 <ClaudiusMaximus> oh, nm, i misread
08:49:09 <mauke> > reads "Baughn"
08:49:11 <lambdabot>  []
08:49:55 <Baughn> mauke: Does the list ever have more than one member?
08:50:09 <mauke> for integers? I don't think so
08:51:12 <int-e> > read ('"':repeat ' ') :: Integer
08:51:16 <lambdabot> Terminated
08:55:45 <Mitar> thanks
08:57:20 <CosmicRay> Is there a way with cabal to install arbitrary files that accompany a binary, prefereably to /usr/share/package or some such?
08:57:24 <CosmicRay> I need to install glade files
08:58:00 <chessguy> someone here with bot ops?
09:00:57 <shapr> for what purpose?
09:01:33 * shapr is tired and cheerful!
09:03:36 <dmhouse> shapr: you're tired?! Makes a change from your normal boingy-ness.
09:03:47 <dmwit> Good morning!
09:03:57 <Vq^> evening dmwit
09:04:05 <chessguy> shapr, it's in #ai, and they like it there, but it needs to ignore the bot called ai-depot, because it's making announcements that start with >
09:04:14 <dmwit> Vq^: Nonsense, this is morning dmwit!
09:04:22 <Vq^> ok :/
09:04:24 <dmwit> You'll know evening dwmit by his many mistakes.
09:04:26 <dmwit> ;-)
09:04:48 <fantasma> ?users
09:04:49 <lambdabot> Maximum users seen in #haskell: 337, currently: 323 (95.8%), active: 52 (16.1%)
09:07:43 <chessguy> shapr, can you take care of that?
09:10:29 <DukeDave> 337... we'll be overtaking C++ users soon :)
09:12:51 <rahikkala> Only with the difference that ChanServ doesn't tell you "we all have our segfaults" when you join #haskell :)
09:14:04 <shapr> chessguy: I think changing the prefix char for eval requires a source change rather than an admin command.
09:16:17 <quicksilver> shapr: but just /ignoreing a single speaker?
09:16:22 <quicksilver> shapr: or can't LB /ignore?
09:20:52 <chessguy> shapr, ignoring the bot should be fine
09:23:51 <fantasma> does the bot PM you if it has a message waiting for you?
09:23:59 <chessguy> no
09:24:14 <chessguy> @tell fantasma say something
09:24:15 <lambdabot> Consider it noted.
09:24:32 <fantasma> lambdabot hi
09:24:33 <lambdabot> fantasma: You have 1 new message. '/msg lambdabot @messages' to read it.
09:25:10 <fantasma> hmm I suppose ignoring the bot would not let you get the message
09:25:23 <chessguy> i guess
09:26:38 <ski> or being nonidentified (or is it the other way around ?)
09:27:05 <int-e> it only affects private messages
09:27:05 <chessguy> ski, i always forget which way it goes
09:27:37 <int-e> lambdabot has no ignore command :/
09:27:57 <chessguy> oh, you can't just make it execute an arbitrary irc command?
09:28:09 <int-e> ignoring is a client feature
09:28:19 <dmwit> Heh.
09:28:24 <chessguy> ermmm
09:28:25 <ski> hm, maybe it would be better for it to state the message in public ?
09:28:50 <chessguy> int-e, i suspect you're wrong
09:29:03 <chessguy> though i say that very timidly
09:30:12 <chessguy> no, you are correct. my mistake
09:41:31 <shapr> yarr
09:41:35 <shapr> @Yarr
09:41:36 <lambdabot> Maybe you meant: arr yarr
09:41:39 <shapr> @yarr
09:41:39 <lambdabot> Prepare to be boarded!
09:41:44 <shapr> @yow
09:41:45 <lambdabot> I am covered with pure vegetable oil and I am writing a best seller!
09:41:48 <shapr> oboy!
09:43:07 <shapr> sjanssen: The xmonad crash with vnc has something to do with 28/03/2007 11:19:29 added missing keysym to X display: 092 0xfe08 "ISO_Next_Group" \n 28/03/2007 11:19:31 added missing keysym to X display: 101 0xe5 "aring" \n 28/03/2007 11:24:20 added missing keysym to X display: 114 0xff57 "End" \n 28/03/2007 11:28:09 added missing keysym to X display: 118 0xff50 "Home"
09:43:18 <shapr> root: Are you really irc'ing as root?
09:43:19 <cjay> don't irc as root :>
09:43:31 <root> sorry
09:44:17 <LoganCapaldo> he's sorry
09:44:20 <opqdonut> hah, suits him
09:44:56 <fantasma> woah that was awesome
09:45:03 <fantasma> how did he get the nick root on freenode haha
09:45:17 <fantasma> I've never been able to get the nick root :(
09:45:19 <shapr> fantasma: I think it's like wearing a target on your back while walking through a firing range...
09:45:23 <thedward> I can also consistently crash xmonad by running totem or Xephyr
09:45:50 <root> hmm
09:46:14 <shapr> sjanssen: so, xmonad starts up and sees a particular keymap. Then vnc starts up and modifies the keymap. Then when one of those new keys are pressed, boom, xmonad segfaults.
09:46:26 <thedward> oi. I need to remap my irssi keys (or the xmonad keys); I had alt-<n> setup to switch windows in irssi
09:46:55 <shapr> Lemmih and I specifically tested with PgDn,  because I don't have that in my keymap, and Lemmih does.
09:47:03 <ski> (thedward : esc-<n> also works, i think)
09:47:04 <opqdonut> root!root@C.ROOT-SERVERS.NET would be nice to irc as
09:47:13 <shapr> opqdonut: Yeah, that would be cool.
09:47:31 <opqdonut> or even opqdonut!...
09:47:33 <shapr> I still think Tony Finch has one of the coolest email addresses ever...
09:47:36 <thedward> ski: indeed; thanks; though hardly so easy on the hands. :)
09:47:47 <shapr> Tony Finch is dot@dotat.at
09:47:51 <opqdonut> hehe
09:47:51 <shapr> Is that extremely cool or what?
09:48:34 <Eelis> clever.
09:48:57 <fantasma> cia.com had free email addresses
09:49:18 <shapr> I want an nsa.gov email address.
09:49:24 <shapr> Er, but not enough to actually work there =)
09:49:25 <thedward> I know a fool@w.tf
09:49:26 <fantasma> haha
09:49:53 <ski> > let dot = "."; at = "@" in concat ["dot",at,"dot","at",dot,"at"]
09:49:54 <fantasma> is there SMTP on nsa.gov
09:49:54 <lambdabot>  "dot@dotat.at"
09:50:44 <shapr> Hey you guys gotta see the cool UDP server code that (mostly) Lemmih and (a tiny bit) I wrote yesterday for HAppS.
09:51:20 <shapr> HAppS has this nifty ServerParts idea that's a lot like mzero/mplus where you either handle a request or bail on it.
09:51:24 <shapr> Up until yesterday it was only for HTTP
09:51:44 <shapr> But we got it working for UDP too.
09:52:04 <shapr> I'm sure we can generalize it to TCP, I wonder if it can go further?
09:52:13 <sioraiocht> @t atomically
09:52:14 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:52:19 <shapr> @temp shapr
09:52:21 <lambdabot>   now 17.8, min 17.7, max 26.0, rain 0.0mm, wind 11km/h NNW
09:52:25 <shapr> I'm so HOT!
09:52:27 <sioraiocht> @type atomically
09:52:30 <lambdabot> Not in scope: `atomically'
09:52:32 <shapr> @temp BHM
09:52:33 <lambdabot>   now 17.8, min 17.7, max 26.0, rain 0.0mm, wind 11km/h NNW
09:52:37 <shapr> er, huh?
09:52:40 <chessguy> lol
09:52:45 <shapr> @temp
09:52:46 <lambdabot>   now 17.8, min 17.7, max 26.0, rain 0.0mm, wind 11km/h NNW
09:52:51 <chessguy> @help temp
09:52:52 <lambdabot> Local temperature
09:52:54 <kc5tja> @temp
09:52:55 <lambdabot>   now 17.8, min 17.7, max 26.0, rain 0.0mm, wind 11km/h NNW
09:52:55 <sioraiocht> haha
09:52:55 <sioraiocht> where's that?
09:52:57 <shapr> Is is stuck on lambdabot local?
09:53:01 <chessguy> must be
09:53:04 <sioraiocht> @temp
09:53:05 <lambdabot>   now 17.8, min 17.7, max 26.0, rain 0.0mm, wind 11km/h NNW
09:53:14 <kc5tja> @temp LAX
09:53:14 <lambdabot>   now 17.8, min 17.7, max 26.0, rain 0.0mm, wind 11km/h NNW
09:53:31 * kc5tja is assuming two things: temps are in Centigrade, and the location for it is an airport code.
09:53:43 <shapr> @temp ATL
09:53:44 <lambdabot>   now 17.8, min 17.7, max 26.0, rain 0.0mm, wind 11km/h NNW
09:53:49 <Botje> @temp BRU
09:53:50 <lambdabot>   now 17.8, min 17.7, max 26.0, rain 0.0mm, wind 11km/h NNW
09:53:56 <kc5tja> @temp 94043
09:53:57 <lambdabot>   now 17.8, min 17.7, max 26.0, rain 0.0mm, wind 11km/h NNW
09:53:59 <xs> @type Control.Concurrent.STM.atomically
09:53:59 <Botje> :)
09:54:01 <shapr> ATL is atlanta, and BHM is Birmingham, but it always reports the same...
09:54:02 <lambdabot> forall a. GHC.Conc.STM a -> IO a
09:54:19 <shapr> @temp Cold Day in Hades
09:54:19 <lambdabot>   now 17.8, min 17.7, max 26.0, rain 0.0mm, wind 11km/h NNW
09:54:19 <kc5tja> Huh, look at that.  the entire planet has the same temperature and wind.  Yay global warming!
09:54:23 <shapr> Funny that
09:54:51 <kc5tja> LAX is Los Angeles, and OAK is Oakland International, if I recall correctly.
09:55:24 <xs> how does xmonad compare to wmii?
09:56:07 <chessguy> @type 3::Word512
09:56:10 <lambdabot>     Not in scope: type constructor or class `Word512'
09:56:14 * kc5tja keeps meaning to try compiling xmonad, but so far I've been entirely too lazy.  :(
09:56:18 <chessguy> @type 3::Word128
09:56:21 <lambdabot>     Not in scope: type constructor or class `Word128'
09:56:30 <kc5tja> @type 3::WordEmUp
09:56:33 <lambdabot>     Not in scope: type constructor or class `WordEmUp'
09:56:50 <xs> chessguy, i think data.word only defines it up to Word64.
09:57:05 <chessguy> @type 3::Word64
09:57:08 <lambdabot> Word64
09:57:17 <chessguy> are there any other modules that define bigger ones?
09:57:23 <xs> why not use Integer?
09:57:29 <chessguy> performanc
09:57:30 <chessguy> e
09:57:33 <ski> > let dict = [("dot","."),("at","@")] in concatMap (uncurry $ \i -> if (i - 1) `mod` 3 == 0 then fromJust . (`lookup` dict) else id) . zip [0..] . concat . replicate 3 . map fst $ dict
09:57:35 <lambdabot>  "dot@dotat.at"
09:58:20 <chessguy> ok ski, you're officially wierd :)
09:58:25 <xs> chessguy, but Integer is often backed by gmp which is pretty good? iirc many open source crypto things use it.
09:58:40 <chessguy> oh really? i thought i heard it was pretty slow
09:59:01 <xs> hm, i'll have a look then
09:59:35 <chessguy> i could well be wrong
10:00:42 <chessguy> > let fact n = product [1..n] in fact (999999:Int)
10:00:43 <lambdabot>   Not in scope: data constructor `Int'
10:01:03 <chessguy> eh?
10:01:18 <Ytinasni> double-colon for types
10:01:18 <Ytinasni> this isnt ML :)
10:01:24 <chessguy> > let fact n = product [1..n] in fact (999999::Int)
10:01:26 <chessguy> whoops :)
10:01:26 <lambdabot>  0
10:01:33 <opqdonut> > let fact n = product [1..n] in (fact (999999::Int)%3)
10:01:35 <lambdabot>  0%1
10:01:52 <opqdonut> > let fact n = product [1..n] in (fact (999999::Integer)%3)
10:01:56 <lambdabot> Terminated
10:02:00 <opqdonut> how sad
10:02:03 <chessguy> > let fact n = product [1..n] in fact (999::Int)
10:02:04 <lambdabot>  0
10:02:09 <chessguy> > let fact n = product [1..n] in fact (99::Int)
10:02:11 <lambdabot>  0
10:02:21 <chessguy> > let fact n = product [1..n] in fact (50::Int)
10:02:23 <lambdabot>  0
10:02:29 <chessguy> > let fact n = product [1..n] in fact (200::Int)
10:02:30 <lambdabot>  0
10:02:35 <chessguy> ok, time for /msgs
10:04:37 <doserj> chessguy: why?
10:04:55 <doserj> chessguy: Int is 32bit
10:05:05 <chessguy> doserj, so as not to flood the channel
10:05:21 <doserj> > product ([1..10]::[Int])
10:05:22 <lambdabot>  3628800
10:05:59 <doserj> > product ([1..20]::[Int])
10:06:00 <lambdabot>  -2102132736
10:06:02 <doserj> :)
10:06:41 <chessguy> who says the product of a list of positive numbers is positive :)
10:07:01 <thedward> > maxBound :: Int
10:07:02 <lambdabot>  2147483647
10:07:27 <chessguy> it's much bigger on my PC :)
10:07:46 <thedward> it is 9223372036854775807 on mine
10:07:55 <chessguy> > 2^64
10:07:56 <lambdabot>  18446744073709551616
10:08:13 <chessguy> > 2^63
10:08:14 <lambdabot>  9223372036854775808
10:08:25 <thedward> I think Int is signed
10:08:28 <doserj> > maxBound::Int64
10:08:30 <lambdabot>  9223372036854775807
10:08:38 <doserj> -1
10:08:41 <doserj> :)
10:08:54 <chessguy> > 9223372036854775807 :: Int
10:08:56 <lambdabot>  -1
10:09:12 <chessguy> > 18446744073709551616 :: Int
10:09:13 <lambdabot>  0
10:09:18 <thedward> if Int was consistently 32-bit I wouldn't have had to go through and fix the X11 library to use CInt
10:09:33 <chessguy> ?hoogle cint
10:09:34 <lambdabot> Foreign.C.Types.CInt :: data CInt
10:10:02 <dmwit> ?src CInt
10:10:03 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:10:15 <chessguy> thedward, if it's consistency you want, why not use Integer?
10:10:50 <dmwit> chessguy: Because he wants to interface with X?
10:10:51 <thedward> chessguy: because the X11 library is mainly ffi calls to C...
10:11:03 <chessguy> oh, err, isn't there a CInteger?
10:11:10 <chessguy> ?hoogle cinte
10:11:11 <lambdabot> No matches found
10:11:30 <chessguy> oh duh, c can't do arbitrary precision math
10:12:03 <thedward> > maxBound :: Foreign.C.Types.CInt
10:12:04 <LoganCapaldo> sure it can :)
10:12:04 <lambdabot>      Not in scope: type constructor or class `Foreign.C.Types.CInt'
10:12:14 <LoganCapaldo> just not out of the box
10:12:14 <Abuiles> hi
10:12:21 <dmwit> The next person to say the word "Turing" gets @slapped
10:12:22 <Abuiles> I have a little problem
10:12:29 <chessguy> i don't think Foreign is imported
10:12:35 <chessguy> hi Abuiles, stump us!
10:12:36 <dmwit> Hi Abuiles!
10:12:43 <Abuiles> Im adding up two matrix
10:12:48 <LoganCapaldo> I was gonna say GMP but ok
10:12:54 <chessguy> what's GMP?
10:13:03 <dmwit> A bignum library for C.
10:13:12 <dmwit> (It's what GHC uses behind the scenes, I think.)
10:13:18 <Abuiles> but when end the function, i can't see the last ]
10:13:19 <chessguy> ah
10:13:29 <Syzygy-> @slap Turing
10:13:29 * lambdabot beats up Turing
10:13:33 <chessguy> !paste
10:13:33 <Syzygy-> :P
10:13:33 <hpaste> Haskell paste bin: http://hpaste.org/
10:13:40 <chessguy> Abuiles, can you paste your code there?
10:13:49 <Abuiles> where?
10:13:52 <LoganCapaldo> @slap Turing completely
10:13:53 * lambdabot beats up Turing completely
10:13:58 <dmwit> Haha
10:14:07 <Abuiles> in this site http://hpaste.org/
10:14:12 <chessguy> Abuiles, yes
10:14:19 <Syzygy-> @slap Turing with a quiver of sharp lambdas
10:14:19 * lambdabot smacks Turing with a quiver of sharp lambdas about with a large trout
10:14:26 <Syzygy-> Awww.
10:14:31 <Abuiles> oh yes i can
10:14:38 <Abuiles> is short
10:16:40 <hpaste>  Abuiles pasted "adding up problem" at http://hpaste.org/1173
10:16:49 <Abuiles> ok
10:17:02 <Abuiles> chessguy
10:17:20 <Abuiles> I paste now the code
10:17:58 <dmwit> Abuiles: You'll need terminating pattern on sumamat.
10:18:10 <dmwit> (Much like the one you already have on sumvec.)
10:18:29 <chessguy> bah
10:18:32 <chessguy> i was just about to say that
10:18:45 <Abuiles> terminating,,,?
10:18:45 <dmwit> Abuiles: But even better would be to use Prelude functions.
10:18:52 <dmwit> ?hoogle foldr
10:18:53 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
10:18:53 <lambdabot> Prelude.foldr1 :: (a -> a -> a) -> [a] -> a
10:18:53 <lambdabot> Data.PackedString.foldrPS :: (Char -> a -> a) -> a -> PackedString -> a
10:19:07 <Abuiles> I can't use prelude function
10:19:25 <dmwit> Why's that?
10:19:41 <dmwit> ...Oh, is it some exercises?
10:19:48 <Abuiles> yes
10:19:59 <Abuiles> I just have that problem
10:20:04 <Abuiles> and end
10:20:29 <doserj> Abuiles: did you read the error message?
10:20:59 <hpaste>  LoganCapaldo annotated "adding up problem" with "shortcuts" at http://hpaste.org/1173#a1
10:21:19 <LoganCapaldo> oh oops
10:21:23 <LoganCapaldo> don't look!
10:21:26 <dmwit> zipWith... =(
10:21:35 <Abuiles> yes but i dont understand much
10:21:38 <chessguy> haha
10:21:44 <Abuiles> because Im learning haskell
10:21:48 <doserj> Abuiles: what does the error message say?
10:21:49 <chessguy> i was just poking through the logs to see when i started playing with haskell
10:21:57 <chessguy> 12:55:35 <chessguy> you don't have variables?
10:22:09 <dmwit> Ha!
10:22:30 <Abuiles> non exhaustive patterns in fuction sumamat
10:23:05 <doserj> Abuiles: do you know what "patterns" are?
10:24:03 <doserj> sumamat (xs:xss) (bs:bss)
10:24:09 <doserj>          ^^^^^^^^^^^^^
10:24:14 <Abuiles> i FIX THE PROBLEM
10:24:14 <doserj> these things
10:24:18 <Abuiles> THANK
10:24:31 <Abuiles> I write  sumamat [] bss = []
10:24:42 <dmwit> Abuiles: Perfect!
10:24:54 <chessguy> <chessguy> to me, foldr f b [] = [] would make more sense
10:24:59 * chessguy blushes
10:25:01 <chessguy> yeesh
10:25:22 <dmwit> Type-checking FTW!
10:25:54 <Abuiles> ok
10:25:55 <Abuiles> man
10:25:56 <Abuiles> thanks
10:25:57 <Abuiles> bye
10:27:07 <LoganCapaldo> @ty foldr ?f ?b [] == []
10:27:09 <lambdabot> (?f::a -> [Integer] -> [Integer], ?b::[Integer]) => Bool
10:27:45 <dmwit> ?ty foldr ?f ?b [] = []
10:27:48 <lambdabot> parse error on input `='
10:28:07 <dmwit> ?ty let foldr ?f ?b [] = [] in 3
10:28:10 <lambdabot> Parse error in pattern
10:29:55 <chessguy> so about 7 months now since i started playing with YAHT
10:30:01 <dmwit> ?type let foldr f b [] = [] in foldr
10:30:03 <lambdabot> forall t t1 t2 a. t -> t1 -> [t2] -> [a]
10:30:15 <dmwit> chessguy: Congratulations, you're a fast learner!
10:30:47 <chessguy> doesn't feel fast
10:33:04 <shapr> shazam!
10:33:10 * shapr turns into CAPTAIN LAMBDA!
10:34:18 <dmwit> !yow!
10:34:32 <dmwit> Err...
10:34:33 <dmwit> ?yow?
10:34:34 <lambdabot> Did an Italian CRANE OPERATOR just experience uninhibited sensations in
10:34:34 <lambdabot> a MALIBU HOT TUB?
10:34:43 <opqdonut> !yarr
10:34:51 <opqdonut> ?yarr
10:34:52 <lambdabot> Smartly me lass
10:34:54 <dmwit> ?yarr!
10:34:55 <lambdabot> What be a priate's favourite cheese?
10:34:55 <lambdabot> Yarrlsburg!
10:35:01 <opqdonut> ?. leet yarr
10:35:01 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "leet"
10:35:08 <opqdonut> gah
10:35:12 <dmwit> ?. elite yarr
10:35:12 <lambdabot> i'D 1IKe t0 DR0p /\/\e 4NC|-|OR iN h3R l49OOn
10:35:17 <opqdonut> ahh
10:35:37 <dmwit> Also, that one was pretty good before getting ?elite'd.
10:35:40 <dmwit> =)
10:36:25 <opqdonut> ?. elite . elite yarr
10:36:25 <lambdabot> YaRRR!
10:36:30 <opqdonut> 8)
10:36:52 <chessguy> ?remember dylan <EvilRanter> perl, python etc will pointer all over the place, too  <dylan> they'll pointer on the carpet too!
10:36:53 <lambdabot> Done.
10:37:04 <opqdonut> :)
10:37:11 <dmwit> ?quote
10:37:12 <lambdabot> kilimanjaro says:  the bad kind of laziness is "so they just invent an equivalance class of monotonic continuous functions that `represent' that partial order. but they haven't taken a shower in
10:37:12 <lambdabot> like 10 days!"
10:37:29 <dmwit> ?quote quote
10:37:30 <lambdabot> psykotic says: monochrom, i'm reminded me of that alan kay quote. "i invented the term 'object-oriented' and i can tell you c++ wasn't what i had in mind"
10:37:42 <opqdonut> ?quote laziness
10:37:42 <lambdabot> qwe1234 says: so, to summarize: laziness per your definition is a form of syntactic sugar that saves one or two lines of code while making programs slower.  whoop de doo
10:37:52 <dmwit> ?quote ?quote
10:37:53 <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"repetition-operator operand invalid")
10:38:03 <opqdonut> ?quote \?quote
10:38:04 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
10:38:12 <opqdonut> :DD
10:38:36 <dmwit> ?quote \ ?quote
10:38:37 <lambdabot> No quotes for this person. You type like i drive.
10:38:39 <LoganCapaldo> @quote \@quote
10:38:40 <lambdabot> Taral says: How do you add an @quote?
10:38:53 <dmwit> heh
10:39:29 <trane> ?quote \?remember
10:39:29 <lambdabot> Turks says: i need to read on how the ?remember function work in lambdabot
10:40:28 <LoganCapaldo> @quote \@remember
10:40:28 <lambdabot> No quotes match. Wrong!  You cheating scum!
10:40:39 <kc5tja> @quote kc5tja
10:40:40 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
10:40:48 <kc5tja> Awww shucks.  They got rid of my quote.  :)
10:41:09 <dmwit> ?quote delicious
10:41:10 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
10:41:18 <kc5tja> ?quote kc5tja
10:41:18 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
10:41:24 <dmwit> ?quote fairy
10:41:25 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
10:41:37 <kc5tja> Is there a difference between @-commands and ?-commands?
10:41:42 <chessguy> kc5tja, no
10:41:47 <kc5tja> Didn't think so.
10:41:51 <kc5tja> Just wanted to make sure.
10:48:28 <CosmicRay> bah.  it sucks that ProcessHandle is abstract.
10:51:17 <sioraiocht> @src return
10:51:18 <lambdabot> Source not found. That's something I cannot allow to happen.
10:51:52 <dmwit> sioraiocht: Which monad?
10:52:02 <dmwit> ?src Control.Monad.List.return
10:52:03 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:52:31 <sioraiocht> dmwit: STM
10:52:49 <sioraiocht> @src Control.Concurrent.return
10:52:49 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
10:52:52 <sioraiocht> hrm
10:53:07 <encryptio> > join ["one","two"]
10:53:09 <lambdabot>  "onetwo"
10:53:14 <encryptio> > concat ["one","two"]
10:53:15 <lambdabot>  "onetwo"
10:53:17 <encryptio> join == concat?
10:53:24 <dmwit> :t join
10:53:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:53:35 <dmwit> join is more general.
10:53:53 <dmwit> But for lists, yes, join is concat.
10:54:13 <LoganCapaldo> join x = x >>= id
10:54:36 <LoganCapaldo> x >>= f = concatMap f x
10:54:48 <LoganCapaldo> x >>= id
10:54:54 <LoganCapaldo> concatMap id x
10:54:59 <sjanssen> shapr: thanks for narrowing the bug down a bit
10:55:15 <LoganCapaldo> concatMap id == concat
10:55:30 * LoganCapaldo is done overanalyzing now
10:55:53 * dmwit jumps
10:56:03 <encryptio> performance-wise is there any difference between using join vs. concat for lists?
10:56:34 <ndm> @seen glguy
10:56:34 <lambdabot> I saw glguy leaving #haskell-blah and #haskell 20h 27m 29s ago, and .
10:57:08 <ndm> @tell glguy i'm changing all the names of the operators in Play, and restructuring it all - if you don't want to update your code yet, don't pull
10:57:08 <lambdabot> Consider it noted.
10:58:21 <encryptio> like, for fusion and stuff?
10:58:33 <sjanssen> encryptio: they're probably the same
10:58:57 <sjanssen> @src join
10:58:57 <lambdabot> join x =  x >>= id
10:59:26 <doserj> encryptio: depends whether the optimizer eliminates the dictionary passing
10:59:27 <Saizan> ?src concatMap
10:59:27 <lambdabot> concatMap f = foldr ((++) . f) []
10:59:34 <ndm> @tell glguy i did tag it before changing anything, so you should be ok though
10:59:34 <lambdabot> Consider it noted.
10:59:43 <sjanssen> encryptio: for lists join x = concatMap id x -- this should be as nice as concat
11:00:08 <encryptio> coo.
11:16:03 <stepcut> whoa -- /join #haskel  automatically forwarded me to /join #haskell :p
11:16:24 <dmwit> Nice!
11:18:25 <LPhas> stepcut: what client do are you using
11:21:00 <stepcut> LPhas: erc
11:21:17 <LPhas> stepcut: oh, cool! i used it
11:21:25 <LPhas> stepcut: try circe
11:21:46 <stepcut> LPhas: yes, I have heard that is better, but I haven't gotten around to it yet
11:22:45 <LPhas> http://www.emacswiki.org/cgi-bin/wiki/Circe
11:22:51 <lambdabot> Title: EmacsWiki: Circe
11:23:00 <LPhas> i switched from erc to circe yesterday
11:23:19 <stepcut> has that increased your productivity ?
11:23:38 <stepcut> :p
11:23:50 <LPhas> stepcut: yes :P
11:24:04 <stepcut> hrm, circe does not appear to be in debian :-/
11:24:16 <LPhas> stepcut: it's only a emacs plugin
11:24:23 <LoganCapaldo> see if you switch to circe and its not there your productivity will definitely increase :)
11:24:30 <LPhas> stepcut: you can easily install it by hand
11:24:53 <stepcut> LPhas: yeah, but that's like, a whole extra step
11:24:55 <stepcut> ;)
11:25:46 <dolio> > snd $ foldr (\a (l,_) -> (a:l, l)) ([], undefined) [1..10]
11:25:51 <lambdabot>  [2,3,4,5,6,7,8,9,10]
11:25:58 <sioraiocht> @type (<-)
11:26:01 <lambdabot> parse error on input `<-'
11:26:06 <dolio> > snd $ foldr (\a (l,_) -> (a:l, l)) ([], undefined) (repeat 3)
11:26:08 <lambdabot>  Exception: <<loop>>
11:27:04 <LoganCapaldo> @type (?a >>=)
11:27:06 <lambdabot> forall (m :: * -> *) a b. (?a::m a, Monad m) => (a -> m b) -> m b
11:27:32 <sioraiocht> hrm, I need a printer
11:27:38 <jimblandy> lambdabot: hi
11:27:46 <sioraiocht> sorry, wrong window =)
11:28:18 * LPhas thinks that HaPPS will be better with some type synonymous 
11:28:19 <bos> @pl \f x -> x (f x)
11:28:20 <lambdabot> ap id
11:29:30 <stepcut> sioraiocht: try, Text.PrettyPrint.HughesPJ ;)
11:29:41 <sioraiocht> lol
11:31:06 <shapr> LPhas: Like what?
11:31:08 <LoganCapaldo> Mm
11:31:19 <LoganCapaldo> @type (. fst)
11:31:21 <lambdabot> forall c a b. (a -> c) -> (a, b) -> c
11:31:25 <shapr> sjanssen: Does that bug narrowing actually help any?
11:31:53 <LPhas> shapr: for example for (uri_msg -> req_msg -> m (Either Request (m' res)))
11:31:53 <LPhas>  
11:32:16 <LPhas> shapr: h will look cleaner with a synonumous
11:32:41 <LoganCapaldo> @type (\f (a, b) -> (f a, b))
11:32:41 <jimblandy> @type map
11:32:43 <lambdabot> forall t t1 t2. (t -> t2) -> (t, t1) -> (t2, t1)
11:32:45 <LPhas> shapr: when i first saw the type of h my reaction was to hide under my bed
11:32:45 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:32:54 <LoganCapaldo> @type first
11:32:56 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
11:33:47 <LoganCapaldo> > (\f (a, b) -> (f a, b)) (+ 1) (2, True)
11:33:48 <lambdabot>  (3,True)
11:33:53 <hpaste>  JH annotated "Trouble" with "(no title)" at http://hpaste.org/1171#a3
11:34:01 <LoganCapaldo> > first (+ 1) (2, True)
11:34:03 <lambdabot>  (3,True)
11:34:41 <LoganCapaldo> seems like it has an odd similarity to liftM
11:35:24 <sjanssen> shapr: it seems pretty obvious that there's something wrong with changing keymaps, and that narrows it down quite a bit
11:39:22 <LoganCapaldo> @src arr
11:39:22 <lambdabot> Source not found. Take a stress pill and think things over.
11:39:28 <LoganCapaldo> @arr
11:39:28 <lambdabot> Yeh scurvy dog...
11:39:47 <LoganCapaldo> How can this work: (arr (\x -> x + 1)) 2 ?
11:39:56 <LoganCapaldo> oh nvm
11:40:12 <LoganCapaldo> arr = id for (->) ?
11:40:24 <LoganCapaldo> @src (->) arr
11:40:24 <lambdabot> arr f = f
11:40:55 <resiak> :type arr
11:41:05 <resiak> @type arr
11:41:08 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
11:41:31 <tsp> heh, my 6 lines of haskell can (mostly) be summarized with this one line of python
11:41:34 <tsp> return map(lambda x: d.get(x,x), s.split(" "))
11:42:51 <psi`> what does that do?
11:43:08 <tsp> psi`: splits a string at word boundaries and maps
11:43:13 <tsp> to a dictionary
11:43:29 <tsp> so that it'll return dict[x], but if it's not found, just x
11:43:48 <psi`> ok
11:44:30 <tsp> the haskell in this case sucks because it takes a list, and I don't think it supports overloading
11:45:01 <psi`> what takes a list?
11:45:04 <tsp> unless I can say f str = something; f list = something else;
11:45:11 <tsp> my haskell function
11:45:18 <psi`> a string is a list
11:45:19 <tsp> I wanted it ot take a string, but I was coidng at 5 AM
11:45:23 <LoganCapaldo> map (\x -> maybe x (lookup x d)) (unwords s)
11:45:51 <tsp> wow
11:45:59 <psi`> > words "hello there tsp"
11:46:02 <lambdabot>  ["hello","there","tsp"]
11:46:13 <LoganCapaldo> oops
11:46:17 <LoganCapaldo> I meant words
11:46:20 <LoganCapaldo> obviously :)
11:46:29 <tsp> I got that part, but I want to change my function so that
11:46:39 <tsp> if I give it a list, it'll unwords - otherwise just map
11:46:47 <tsp> s/unwords/leave it alone
11:46:51 <LoganCapaldo> err
11:47:12 <tsp> like ... process dict ["1","2","3"] compared to process dict "1 2 3" should do the same thing
11:47:38 <Syzygy-> tsp: Note that "1 2 3" is also a list
11:48:06 <tsp> damn, so I can't just test if typeof(s) == list
11:48:13 <LoganCapaldo> nooo
11:48:22 <LoganCapaldo> nor should you
11:48:45 <LoganCapaldo> otoh
11:48:51 <LoganCapaldo> you can abuse typeclasses
11:48:58 <LoganCapaldo> but please don't
11:49:03 <LoganCapaldo> it makes me sad
11:49:37 <Syzygy-> It makes all of us sad. And none is sadder than Baby Simon to hear about such things.
11:49:45 <tsp> heh
11:49:46 <tsp> :t Maybe
11:49:49 <lambdabot> Not in scope: data constructor `Maybe'
11:49:54 <tsp> weird
11:49:56 <LoganCapaldo> @kind Maybe
11:49:58 <lambdabot> * -> *
11:49:59 <bos> Maybe is a type.
11:50:08 <tsp> I thought :t did types
11:50:17 <LoganCapaldo> :t tells you the type of something
11:50:20 <dolio> Maybe is a type constructor, not a type.
11:50:20 <lambdabot> parse error on input `type'
11:50:22 <LoganCapaldo> types don't have types
11:50:44 <sioraiocht> :t Maybe
11:50:45 <tsp> is maybe a gonad?
11:50:46 <lambdabot> Not in scope: data constructor `Maybe'
11:50:48 <tsp> monad*
11:50:52 <sioraiocht> tsp:  yes
11:50:57 <tsp> damn I hate those things
11:51:07 <sioraiocht> tsp:  why? Monads are delicious
11:51:13 <tsp> I don't get them
11:51:18 <LoganCapaldo> it doesn't matter that maybe is a monad
11:51:23 <LoganCapaldo> you don't have to use it as a monad
11:52:22 <sioraiocht> tsp: something being a Monad just means that it has a version of (>>=) and return defined for it
11:52:31 <tsp> oh
11:52:38 <psi`> it's still just a regular data type
11:52:43 <LoganCapaldo> let process dict words = processList dict (words words)
11:52:47 <Syzygy-> And it should also mean that these do what they're supposed to.
11:52:51 <sioraiocht> tsp:  http://www.haskell.org/all_about_monads/html/
11:52:52 <lambdabot> Title: All About Monads
11:52:57 <LoganCapaldo> and then define processList to handle the ["1", "2", "3"] case
11:53:15 <tsp> ah
11:53:32 <LoganCapaldo> maybe words was a bad choice of param name there <g>
11:53:36 <encryptio> tsp: list ([], :) is a monad too. you don't have to use it as such.
11:53:43 <tsp> ouch
11:53:54 * sioraiocht never could understand the List monad, though...
11:54:09 <sioraiocht> @src List.return
11:54:10 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:54:12 <tsp> I just want a tekstredaktilo, not monads and gonads and stuff on my way to writing one :)
11:54:12 <sioraiocht> dam
11:54:19 <LoganCapaldo> @src ([]) return
11:54:19 <lambdabot> Source not found. Take a stress pill and think things over.
11:54:21 <encryptio> @src Data.List.return
11:54:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:54:25 <LoganCapaldo> @src [] return
11:54:25 <lambdabot> return x    = [x]
11:54:31 <sioraiocht> @src [] (>>=)
11:54:32 <lambdabot> m >>= k     = foldr ((++) . k) [] m
11:54:36 <sioraiocht> THAT confuses me
11:54:57 <encryptio> seems pretty straightforward to me
11:55:14 <LoganCapaldo> @src concatMap
11:55:14 <lambdabot> concatMap f = foldr ((++) . f) []
11:55:18 <psi`> > [1,2,3] >>= \x -> [x,x]
11:55:19 <lambdabot>  [1,1,2,2,3,3]
11:55:53 <psi`> the list monad is cool to use when list comprehensions gets too complicated.
11:56:01 <tsp> oh
11:56:24 <encryptio> sioraiocht: so in that, m is the list [a] and k is the operation on that list (a -> [a]). they're concat'd (or join'd) afterwards.
11:56:27 <psi`> i mean, the do syntax.
11:56:41 <DRMacIver> Aren't list comprehensions just syntactic sugar over the list monad?
11:56:42 <sioraiocht> encryptio: thank you, that makes much more sense
11:56:46 <sioraiocht> DRMacIver: yes
11:56:51 <LoganCapaldo> > concat [ [x,x] | x <- [1,2,3] ]
11:56:51 <psi`> DRMacIver: yeah, i meant the do syntax
11:56:52 <lambdabot>  [1,1,2,2,3,3]
11:56:56 <tsp> ack this is ugly
11:57:09 <tsp> replaceWord dict word = case... ;
11:57:19 <encryptio> hrm ... actually the operation could be (a -> [b])
11:57:29 <DRMacIver> psi`: Ah, right.
11:57:30 <sioraiocht> encryptio: that makes more sense =)
11:57:30 <tsp> eh, not too bad
11:57:40 <sioraiocht> @type [] (>>])
11:57:40 <LoganCapaldo> > concat . map (\x -> [x, x]) $ [1,2,3]
11:57:44 <lambdabot> parse error on input `]'
11:57:44 <lambdabot>  [1,1,2,2,3,3]
11:57:48 <sioraiocht> @type [] (>>=)
11:57:51 <lambdabot>     Couldn't match expected type `(m a -> (a -> m b) -> m b) -> t'
11:57:52 <lambdabot>            against inferred type `[a1]'
11:57:56 <encryptio> :t (>>=)
11:57:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:58:14 <encryptio> or specific to the list: [a] -> (a -> [b]) -> [b]
11:58:16 <LoganCapaldo> > concatMap (\x -> [x,x]) [1,2,3]
11:58:17 <lambdabot>  [1,1,2,2,3,3]
11:58:18 <sioraiocht> yeah
11:58:29 <sioraiocht> :t concatMap
11:58:32 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
11:59:01 <tsp> what does concatMap -do-? that type doesn't do much to explain waht it does
11:59:14 <LoganCapaldo> @type map
11:59:16 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:59:18 <sioraiocht> [1,2,3]  >>= (+1)
11:59:20 <LoganCapaldo> type concat
11:59:22 <encryptio> tsp: concatMap == (concat . map) -- iirc
11:59:24 <LoganCapaldo> @type concat
11:59:26 <lambdabot> forall a. [[a]] -> [a]
11:59:27 <sioraiocht> > [1,2,3]  >>= (+1)
11:59:29 <lambdabot>   add an instance declaration for (Num [b])
11:59:33 <LoganCapaldo> @type concat . map
11:59:35 <lambdabot>     Couldn't match expected type `[[a]]'
11:59:36 <lambdabot>            against inferred type `[a1] -> [b]'
11:59:54 <tsp> does haskell have a serial port lib?
11:59:57 <LoganCapaldo> @type (concat .) . map
11:59:59 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
12:00:16 <encryptio> :t concat .
12:00:18 <lambdabot> parse error (possibly incorrect indentation)
12:00:26 <sioraiocht> > [1,2,3]  >>= (\x -> x+1)
12:00:28 <lambdabot>   add an instance declaration for (Num [b])
12:00:28 <lambdabot>     In the expression: x + 1
12:00:28 <lambdabot>     ...
12:00:39 <sioraiocht> ahhhhh
12:00:42 <sioraiocht> *gets it*
12:00:56 <sioraiocht> > [1,2,3]  >>= (\x -> [x+1])
12:00:58 <lambdabot>  [2,3,4]
12:01:01 <encryptio> =)
12:01:39 <sioraiocht> know what I don't like, STATE MONADS
12:01:46 <bos> huh?
12:01:47 <encryptio> i <3 StateT
12:01:51 <bos> they're easy.
12:01:54 <tsp> what are state monads
12:01:57 <LoganCapaldo> Don't hate on State
12:02:07 <sioraiocht> bos: next time I need to use them, I'm coming to you
12:02:08 <stepcut> how about FEDERAL COMONADS ?
12:02:15 <bos> sioraiocht: you do that :-)
12:02:22 * LoganCapaldo goran
12:02:26 <LoganCapaldo> *groan, even
12:03:00 <tsp> :t replace
12:03:03 <lambdabot> Not in scope: `replace'
12:03:04 <kc5tja> Dude, what a goran... ;)
12:03:08 <tsp> how do I replace x with y in a string?
12:03:40 <LoganCapaldo> @hoogle String -> String -> String
12:03:41 <lambdabot> Distribution.PreProcess.Unlit.plain :: String -> String -> String
12:03:41 <lambdabot> Distribution.PreProcess.Unlit.unlit :: String -> String -> String
12:03:41 <lambdabot> Text.Regex.subRegex :: Regex -> String -> String -> String
12:03:51 <tsp> that's it?
12:04:09 <tsp> not very powerful string language :)
12:04:12 <LoganCapaldo> @hoogle String -> String -> String -> String
12:04:12 <lambdabot> No matches, try a more general search
12:05:01 <LoganCapaldo> actually
12:05:16 <LoganCapaldo> @hoogle [a] -> [a] -> [a] -> [a]
12:05:17 <lambdabot> Prelude.zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
12:05:17 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
12:05:26 <LoganCapaldo> nope
12:05:34 <encryptio> @hoogle [a] -> (a -> a) -> [a]
12:05:35 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
12:05:36 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
12:05:36 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
12:05:40 <encryptio> ^^
12:05:46 <tsp> heh
12:05:58 <encryptio> too bad it only works with characters if run on a String. =p
12:06:05 <tsp> all these functions that noones gonna use
12:06:14 <tsp> like zip
12:06:18 <LoganCapaldo> What?
12:06:20 <EvilTerran> <_<  >_>
12:06:23 <LoganCapaldo> zip is awesome
12:06:31 <EvilTerran> zip's a really useful one
12:06:32 <tsp> :t zip
12:06:35 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
12:06:42 <LoganCapaldo> zipWith being more useful
12:06:43 <sioraiocht> @src (!!)
12:06:44 <lambdabot> xs     !! n | n < 0 = undefined
12:06:44 <lambdabot> []     !! _         = undefined
12:06:44 <lambdabot> (x:_)  !! 0         = x
12:06:44 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:06:48 <tsp> it takes a list
12:07:01 <sioraiocht> :t zipWith
12:07:04 <EvilTerran> LoganCapaldo, well, both're definable in terms of the other as one line, so there's not much in it...
12:07:04 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:07:16 <tsp> lotta args
12:07:18 <LoganCapaldo> true
12:07:19 <encryptio> > zip [1,2,3] [4,5,6]
12:07:21 <lambdabot>  [(1,4),(2,5),(3,6)]
12:07:27 <tsp> > zipWith [1,2,3] [1,2,3]
12:07:28 <lambdabot>  Couldn't match expected type `a -> b -> c'
12:07:37 <LoganCapaldo> @type map . (uncurry f) $ zip
12:07:40 <lambdabot> Not in scope: `f'
12:07:40 <EvilTerran> zip xs ys = zipWith (,) xs ys
12:07:42 <xerox_> > let m .*. n = [[ sum $ zipWith (*) r c | c <- transpose n] | r <- m] in [[1,2,3],[4,5,6]] .*. [[1,2],[3,4],[5,6]]
12:07:43 <lambdabot>  [[22,28],[49,64]]
12:07:46 <encryptio> > zipWith (\x y -> x + y) [1,2,3] [4,5,6]
12:07:48 <lambdabot>  [5,7,9]
12:07:49 <LoganCapaldo> @type map (uncurry ?f) $ zip
12:07:50 <sioraiocht> >zipWith (+) [1,2,3] [4,5,6]
12:07:51 <lambdabot>     Couldn't match expected type `[(a, b)]'
12:07:51 <lambdabot>            against inferred type `[a1] -> [b1] -> [(a1, b1)]'
12:08:01 <resiak> > zipWith (+) [1..3] [4..6]
12:08:03 <lambdabot>  [5,7,9]
12:08:03 <LoganCapaldo> @type map (uncurry ?f) . zip
12:08:06 <lambdabot>     Couldn't match expected type `[(a, b)]'
12:08:06 <lambdabot>            against inferred type `[b1] -> [(a1, b1)]'
12:08:07 <EvilTerran> zipWith f xs ys = map (uncurry f) (zip xs ys)
12:08:18 <LoganCapaldo> am I on stupid pills?
12:08:23 <LoganCapaldo> oh yes, yes I am
12:08:33 <xerox_> you want .:
12:08:51 <LoganCapaldo> @type (map (uncurry ?f) .) . zip
12:08:54 <lambdabot> forall c a b. (?f::a -> b -> c) => [a] -> [b] -> [c]
12:08:56 <xerox_> ?ty let (.:) = (.) . (.) in map (uncurry ?f) .: zip
12:08:58 <lambdabot> forall c a b. (?f::a -> b -> c) => [a] -> [b] -> [c]
12:09:18 <LoganCapaldo> .: heh
12:09:19 <EvilTerran> hehe... that'd make (.:) = (.)(.)(.)
12:09:23 <LoganCapaldo> I like that one
12:09:40 <xerox_> ?ty let (.::) = (.) . (.) . (.) in map (uncurry ?f) .: zipWith
12:09:42 <lambdabot> Not in scope: `.:'
12:09:47 <xerox_> bang. sorry.
12:10:02 <encryptio> :t (.) . (.) . (.)
12:10:05 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
12:10:09 <xerox_> laters.
12:10:09 <encryptio> D=
12:10:12 <sioraiocht> AHHHHHHHHHHH
12:10:16 <xerox_> (but it works.)
12:10:46 <xerox_> ?ty let (.::) = (.) . (.) . (.) in map (uncurry ?f) .:: zipWith
12:10:48 <lambdabot> forall a b c a1 b1. (?f::a -> b -> c) => (a1 -> b1 -> (a, b)) -> [a1] -> [b1] -> [c]
12:10:50 <xerox_> can't resist
12:11:17 <EvilTerran> ?type flip flip flip flip  -- :P
12:11:20 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
12:11:34 <encryptio> :t flip flip
12:11:36 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
12:11:37 <Daveman> Hey encryptio :)
12:11:40 <LoganCapaldo> @type fix flip
12:11:41 <Daveman> xerox :D
12:11:42 <encryptio> Daveman: =D
12:11:42 <lambdabot> forall b c. b -> b -> c
12:11:50 <xerox_> ?pl \get -> you get off
12:11:50 <lambdabot> flip you off
12:11:58 <encryptio> lol
12:12:10 <Daveman> :o
12:12:22 <Daveman> xerox: naughty >:)
12:12:30 * xerox_ `ap` dinner
12:12:32 <dmwit> > fix flip
12:12:33 <lambdabot>  Add a type signature
12:12:34 <encryptio> :t ap
12:12:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:12:51 <sioraiocht> @src ap
12:12:52 <lambdabot> ap = liftM2 id
12:13:01 <sioraiocht> @src liftM2
12:13:02 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:13:08 <dmwit> ?pl flip flip flip flip flip flip flip flip
12:13:09 <lambdabot> flip flip flip
12:13:18 <Daveman> shake shake shake
12:13:19 <dmwit> birdies!
12:13:46 <LoganCapaldo> > fix flip :: b -> b -> a
12:13:47 <lambdabot>  Add a type signature
12:14:03 <EvilTerran> surely fix flip is useless?
12:14:12 <LoganCapaldo> > fix flip ((-) 2 3)
12:14:14 <lambdabot>  Add a type signature
12:14:24 <dmwit> > fix flip (-) 2 3
12:14:25 <lambdabot>   add an instance declaration for (Num (a -> a -> a))
12:14:26 <LoganCapaldo> > fix flip ((-) 2 3) :: Integer
12:14:27 <encryptio> EvilTerran: there was a discussion on haskell-cafe about what it meant - it was used and was useful
12:14:27 <lambdabot>  Couldn't match expected type `Integer'
12:14:43 <EvilTerran> encryptio, er. okay.
12:14:47 <LoganCapaldo> > (fix flip) ((-) 2 3) :: Integer
12:14:47 <dmwit> :t fix flip
12:14:48 <lambdabot>  Couldn't match expected type `Integer'
12:14:50 <lambdabot> forall b c. b -> b -> c
12:14:53 <LoganCapaldo> > (fix flip) ((-) 2 3)
12:14:54 <lambdabot>  Add a type signature
12:15:02 <dmwit> > fix flip 2 2
12:15:04 <encryptio> EvilTerran: it's there ... somewhere ... out there ... </fool>
12:15:06 <lambdabot> Terminated
12:15:14 <LoganCapaldo> > (fix flip) (-) 2 3
12:15:15 <lambdabot>   add an instance declaration for (Num (a -> a -> a))
12:15:22 <LoganCapaldo> > ((fix flip) (-)) 2 3
12:15:23 <lambdabot>   add an instance declaration for (Num (a -> a -> a))
12:15:27 <LoganCapaldo> hmmm
12:15:30 <LoganCapaldo> mmmmm
12:15:48 <dmwit> LoganCapaldo: fix flip takes two arguments of the same type... (?)
12:15:58 <dmwit> :t fix
12:16:00 <lambdabot> forall a. (a -> a) -> a
12:16:05 <dmwit> :t flip
12:16:06 <LoganCapaldo> right
12:16:08 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:16:17 <LoganCapaldo> i am on stupid pills today
12:16:34 <dmwit> > fix (flip (-)) 2 3
12:16:35 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
12:16:35 <lambdabot>     Probabl...
12:16:37 * EvilTerran suffers a brainmelt
12:16:44 <sioraiocht> what's fix do?
12:16:51 <dmwit> ?src fix
12:16:51 <lambdabot> fix f = let x = f x in x
12:16:58 <LoganCapaldo> > fix (1:)
12:16:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:17:05 <dmwit> sioraiocht: It's the least fixed-point operator.
12:17:26 <dmwit> > fix show ""
12:17:27 <lambdabot>  Couldn't match expected type `[Char] -> t'
12:17:47 <encryptio> sioraiocht: it's the basis for a recursion extension for lambda calculus - in haskell it lets you make recursive functions out of lambdas.
12:17:55 <sioraiocht> ohhhhhhhhh
12:18:03 <DRMacIver> i.e. it's the Y combinator?
12:18:09 <dmwit> > fix show
12:18:11 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
12:18:16 <sioraiocht> LOL
12:18:20 <LoganCapaldo> > fix (\f n -> case n of { 0 -> 1; 1 -> 1; n -> f (n - 1) + f (n - 2) }) 5
12:18:22 <lambdabot>  8
12:18:47 <sioraiocht> weird
12:18:52 <EvilTerran> errr
12:20:17 <EvilTerran> ohhh
12:20:30 * EvilTerran oscillates between enlightenment and confusion
12:21:10 <encryptio> i understood fix once i got that its argument doesn't *have* to call its argument.
12:21:27 <sioraiocht> *head*
12:21:29 <sioraiocht> *hit*
12:21:33 <sioraiocht> *keyboard*
12:21:34 <mauke> > fix (\self n -> if n < 2 then 1 else n * self (n - 1)) 5
12:21:35 <lambdabot>  120
12:21:41 <DRMacIver> Hm
12:21:46 <DRMacIver> > fix
12:21:47 <lambdabot>  Add a type signature
12:22:31 <sioraiocht> > fix (\f x -> if x == 0 then 1 else n*(f (n-1))) 4
12:22:33 <lambdabot>   Not in scope: `n'
12:22:36 <sioraiocht> err
12:22:44 <DRMacIver> How do I get lambdabot to show me the source?
12:22:46 <sioraiocht> > fix (\f x -> if x == 0 then 1 else x*(f (x-1))) 4
12:22:48 <lambdabot>  24
12:22:50 <sioraiocht> w00t
12:22:52 <encryptio> @src fix
12:22:53 <lambdabot> fix f = let x = f x in x
12:23:02 * sioraiocht comprehends.
12:23:10 <sioraiocht> unfortunately, none of this is writing my STM assignment ;)
12:23:17 <DRMacIver> Ha ha. That's fantastic. :)
12:24:16 <LoganCapaldo> let f g = g (f g) in f (\f n -> if n == 0 then 1 else n *  f (n - 1)) 5
12:24:20 <LoganCapaldo> > let f g = g (f g) in f (\f n -> if n == 0 then 1 else n *  f (n - 1)) 5
12:24:21 <lambdabot>  120
12:25:28 <LoganCapaldo> lazy lazy oh so lazy
12:27:40 <DRMacIver> That's really rather cool.
12:29:47 <LoganCapaldo> > (\f -> (\g -> g (f g))) (\f -> (\g -> g (f g))) (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5 -- I wonder if I did this right
12:29:48 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
12:29:48 <lambdabot>     Probab...
12:30:03 <LoganCapaldo> guuuuuuess not
12:30:28 <sioraiocht> lol
12:30:40 <sjanssen> @v
12:30:41 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
12:30:54 <tsp> > [1..] ! [1..4]
12:30:55 <lambdabot>  Couldn't match expected type `Array i e'
12:30:56 <psi`> @help v
12:30:56 <lambdabot> let v = show v in v
12:31:07 <tsp> how do I get items 1-4 of a list?
12:31:19 <sjanssen> > take 4 [1..]
12:31:20 <lambdabot>  [1,2,3,4]
12:31:23 <sioraiocht> @src (!)
12:31:23 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
12:31:24 <sjanssen> tsp: ^^^
12:31:30 <tsp> neat
12:32:26 <LoganCapaldo> > (map fst .) . zip [7..] [1..4]
12:32:27 <lambdabot>  Couldn't match expected type `a -> a2 -> [(a1, b)]'
12:32:37 <LoganCapaldo> > (map fst .) . zip [7..] $ [1..4]
12:32:38 <lambdabot>  Couldn't match expected type `a1 -> [(a, b)]'
12:32:50 <tsp> the big things I" mmissing
12:32:54 <tsp> is stuff like
12:32:59 <LoganCapaldo> > map fst (zip [7..] [1..4])
12:33:00 <tsp> string.replace("foo","bar")
12:33:01 <lambdabot>  [7,8,9,10]
12:33:14 <sioraiocht> > map ((!!) [1..]) [1..4]
12:33:16 <LoganCapaldo> no wait
12:33:16 <lambdabot>  [2,3,4,5]
12:33:24 <LoganCapaldo> I wanted
12:33:25 <sioraiocht> oops, still, just wanted to see if that would work
12:33:26 <sioraiocht> heh
12:33:35 <sioraiocht> > map ((!!) [0..]) [1..4]
12:33:36 <lambdabot>  [1,2,3,4]
12:33:39 <LoganCapaldo> > zipWith (!!) [7..] [1..4]
12:33:40 <lambdabot>   add an instance declaration for (Num [a])
12:33:40 <lambdabot>     In the expression: 7
12:34:11 <Botje> > zipWith (!!) (repeat [7..]) [1..4] -- ;)
12:34:12 <lambdabot>  [8,9,10,11]
12:34:27 <LoganCapaldo> right
12:34:47 <LoganCapaldo> > zipWith (!!) (repeat [7..]) [1,3,2]
12:34:48 <lambdabot>  [8,10,9]
12:35:04 <LoganCapaldo> that was the effect I was looking for :)
12:35:09 <Botje> :)
12:35:43 <Saizan> @pl \x y -> zipWith (!!) . repeat $ x $ y
12:35:43 <lambdabot> ((zipWith (!!) . repeat) .)
12:36:11 <Saizan> ?ty ((zipWith (!!) . repeat) .)
12:36:14 <lambdabot> forall a a1. (a1 -> [a]) -> a1 -> [Int] -> [a]
12:37:11 <LoganCapaldo> ?pl (\list indices -> zipWith (!!) (repeat list) indices)
12:37:12 <lambdabot> zipWith (!!) . repeat
12:37:29 <sioraiocht> orly? lol
12:37:44 <LoganCapaldo> (zipWith (!!) . repeat) [1,2,3,4] [0,3]
12:37:50 <LoganCapaldo> > (zipWith (!!) . repeat) [1,2,3,4] [0,3]
12:37:51 <lambdabot>  [1,4]
12:38:02 <Saizan> $ should really be infixl
12:38:24 <sioraiocht> > (zipWith (!!) . repeat) [1,2,3,4] [0,2..]
12:38:24 <sjanssen> @check (\xs ys -> zipWith (!!) (repeat (xs :: [Int])) (repeat ys) == map (xs !!) ys)
12:38:26 <lambdabot>  Couldn't match expected type `[Int]' against inferred type `Int'
12:38:26 <lambdabot>  Exception: Prelude.(!!): index too large
12:38:48 <LoganCapaldo> heh
12:39:54 <LoganCapaldo> > map ([1,2,3,4] !!) [0,3]
12:39:56 <lambdabot>  [1,4]
12:40:07 <LoganCapaldo> I guess @pl lost this one
12:40:25 <LoganCapaldo> @pl \list indices -> map (list !!) indices
12:40:25 <lambdabot> map . (!!)
12:40:34 <shapr> sjanssen: Does that make it a bug in X11-extras?
12:40:50 <sjanssen> shapr: I'm undecided on that one
12:40:52 <LoganCapaldo> map.(!!) [1,2,3,4] [0..2]
12:40:58 <LoganCapaldo> > map.(!!) [1,2,3,4] [0..2]
12:40:59 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
12:41:06 <sjanssen> shapr: xmonad might not be reacting an an event it's supposed to
12:41:10 <LoganCapaldo> > (map.(!!)) [1,2,3,4] [0..2]
12:41:11 <lambdabot>  [1,2,3]
12:42:04 <LoganCapaldo> > map.(!!)  $ [1,2,3,4] [0..2]
12:42:04 <lambdabot>  Couldn't match expected type `t -> [a]'
12:42:15 <LoganCapaldo> yeah it should
12:42:57 <sjanssen> shapr: are you trying to fix the bug?
12:43:04 <doserj> > map.(!!)  $ [1,2,3,4] $ [0..2]
12:43:05 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
12:43:11 <doserj> > map.(!!)   [1,2,3,4] $ [0..2]
12:43:12 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
12:43:34 <LoganCapaldo> Is there somewhere I can go vote to change the associativity? :)
12:43:49 <doserj> you would lose the vote...
12:43:57 <LoganCapaldo> ah well
12:44:01 <sjanssen> it's really too late to change it
12:44:59 <sjanssen> you could propose a new operator ($$, maybe?) that is infixl
12:45:21 <LoganCapaldo> whaddabout <$
12:45:35 <doserj> @type ($$)
12:45:38 <lambdabot> Doc -> Doc -> Doc
12:45:39 <Saizan> let infixl () 0; () = ($) in  map.(!!)  $ [1,2,3,4] [0..2]
12:45:48 <sjanssen> doserj: ah yes, that's taken
12:45:53 <Saizan> > let infixl () 0; () = ($) in  map.(!!)   [1,2,3,4] [0..2]
12:45:53 <lambdabot>  Parse error
12:45:57 <LoganCapaldo> @type (<$)
12:46:00 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
12:46:11 <sioraiocht> okay
12:46:13 <Saizan> ?index Doc
12:46:13 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
12:46:14 <sioraiocht> wtf is a functor?
12:46:27 <sioraiocht> @src (<$)
12:46:27 <Saizan> ?instances Functor
12:46:28 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:46:29 <lambdabot> (<$) = (<$>) . const
12:46:33 <sjanssen> sioraiocht: thing that have a "map" like operator
12:46:37 <doserj> ?src Functor
12:46:37 <lambdabot> class  Functor f  where
12:46:38 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
12:46:43 <sjanssen> > fmap (+1) [1..]
12:46:44 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
12:46:47 <LoganCapaldo> @src Maybe fmap
12:46:47 <lambdabot> fmap _ Nothing       = Nothing
12:46:47 <lambdabot> fmap f (Just a)      = Just (f a)
12:46:49 <sjanssen> > fmap (+1) Nothing
12:46:50 <lambdabot>  Nothing
12:46:56 <sjanssen> > fmap (+1) (Just 5)
12:46:58 <lambdabot>  Just 6
12:47:00 <sioraiocht> so are most functors monads?
12:47:15 <LoganCapaldo> all monads are functors (thereotically)
12:47:18 <sjanssen> sioraiocht: all monads are *supposed* to be functors
12:47:28 <sioraiocht> but are all functors monads?
12:47:33 <LoganCapaldo> no
12:47:36 <sioraiocht> kk
12:47:38 <sjanssen> but the default Monad classes don't enforce this constraint
12:47:42 <sioraiocht> right
12:48:00 <shapr> Windows is to Linux as Java is to Haskell.
12:48:16 <Saizan> for a monad fmap = liftM
12:49:41 <LoganCapaldo> analogies are to bad as single colons are to double colons
12:55:42 <chessguy> ?seen procyon112
12:55:43 <lambdabot> I saw procyon112 leaving #haskell 4h 47m 21s ago, and .
13:00:19 * shapr cheers furiously!
13:01:37 <Binkley> for...?
13:01:58 <kaol> haskell, obviously
13:02:15 <Binkley> heh
13:02:22 <LPhas> shapr: lol
13:02:56 <Binkley> how controversial!
13:05:36 <sjanssen> shapr: I can trivially reproduce your bug (I think) by running xmodmap
13:06:15 <kolmodin> sjanssen: aye, xmodmap doesn't work
13:06:26 <sjanssen> okay, so now to figure out why
13:06:32 <kolmodin> :)
13:06:44 <kolmodin> I only noticed that it segfaulted
13:06:54 <kolmodin> haven't had time to look into it
13:07:05 <kolmodin> so now I'm typing with a different keymap :)
13:07:20 <kolmodin> ?localtime dons
13:07:22 <lambdabot> Local time for dons is Thu Mar 29 06:05:23 2007
13:07:38 * psi` also hit that bug
13:07:39 <sjanssen> kolmodin: does it work if you run xmodmap before you start xmonad?
13:08:12 <kolmodin> sjanssen: I don't know, haven't tried
13:08:14 <psi`> i'm pretty sure it worked with xmodmap in .xinitrc
13:08:17 <kolmodin> that might be a nice workaround
13:11:23 <kolmodin> @tell dons http://haskell.org/~kolmodin/ANNOUNCE-0.3 aye or nay? I'll send it tomorrow
13:11:23 <lambdabot> Consider it noted.
13:11:30 <kolmodin> @tell dcoutts http://haskell.org/~kolmodin/ANNOUNCE-0.3 aye or nay? I'll send it tomorrow
13:11:30 <lambdabot> Consider it noted.
13:22:55 * allbery_b is using beepy gc to try to figure out why this program ran his machine out of memory overnight (hence his disappearance)
13:22:56 <allbery_b> @bot
13:22:56 <EvilTerran> whoa
13:22:56 <lambdabot> :)
13:22:56 <EvilTerran> you plug your ethernet in, pull your ethernet out, in, out, in, out, netsplit all about...
13:29:52 <tsp> heh, estas kacosucxulo
13:32:28 <LoganCapaldo> that's what its alll about
13:35:03 <chessguy> wow, that was quite a netsplit
13:36:53 <zbrown> Whats the difference between map and mapM_ ? I've looked at their specs and I'm not sure I understand
13:37:05 <LoganCapaldo> Is there a "make"-ish thing written in Haskell?
13:37:13 <chessguy> @type map
13:37:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:37:16 <chessguy> @type mapM_
13:37:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:37:25 <shapr> LoganCapaldo: Yes, several small flavors.
13:37:42 <Saizan> hmake for example
13:37:52 <chessguy> zbrown, are you familiar with monads already?
13:37:59 <zbrown> chessguy: errr not especially
13:38:00 <Baughn> LoganCapaldo: There's also a good chance that ghc --make does what you want, at least for small systems
13:38:03 <LoganCapaldo> are the rule style targets exressed in teh type system?
13:38:15 <LoganCapaldo> Baughn: naw, I don't want to compile haskell code
13:38:27 <LoganCapaldo> f :: CFile -> ObjectFile ?
13:38:36 <Excedrin> http://www.cs.berkeley.edu/~adamc/papers/CtpcPLDI07/ <- I saw this paper on ltu, it's interesting if you're interested in PL stuff
13:38:37 <lambdabot> Title: A Certified Type-Preserving Compiler from Lambda Calculus to Assembly Language
13:38:37 <LoganCapaldo> cause that would just be cool :)
13:38:39 <chessguy> zbrown, ah, ok. you want to explore them before you try to comprehend mapM_.
13:38:44 <zbrown> ok
13:39:46 <LoganCapaldo> and you say make s.o and the program says ok strings of the form .o are object files so I need a function to get an ObjectFile
13:40:00 <LoganCapaldo> and then it sees your "f" functuion
13:40:06 <chessguy> Excedrin, nobody here is interested in PL stuff :)
13:40:10 <LoganCapaldo> and it says ok now I need a CFile named s.c
13:40:15 <LoganCapaldo> etc.
13:40:17 <pejo> chessguy?
13:40:24 <LoganCapaldo> That sort of nonsense
13:40:30 <Excedrin> chessguy: yea, I figured it was a fairly useless link, sorry
13:40:30 <chessguy> </sarcasm>
13:40:54 <chessguy> pejo?
13:42:45 * shapr does the linking dance
13:45:28 * glguy discovers that freenode is available on port 8000... firewall defeated!
13:45:28 <lambdabot> glguy: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:45:39 * shapr dances more for linking!
13:45:43 <norpan> i wish i hade messages
13:45:51 <shapr> @tell norpan YOU HAVE A MESSAGE SIR!
13:45:52 <lambdabot> Consider it noted.
13:46:12 <glguy> @seen ndm
13:46:12 <lambdabot> ndm is in #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard ndm speak 2h 46m 37s ago.
13:46:22 <norpan> wow
13:46:23 <lambdabot> norpan: You have 1 new message. '/msg lambdabot @messages' to read it.
13:46:24 <Binkley> what's #haskell-overflow for, anyway?
13:46:39 <norpan> thanks!
13:46:46 <LoganCapaldo> when this channel fills up some nicks spill into there
13:46:52 <LoganCapaldo> at least thats my guess
13:47:03 <Binkley> odd that there's a limit
13:47:15 <glguy> the limit is for malicious join floods
13:47:26 <shapr> Yeah, we've had that happen before.
13:47:30 <LoganCapaldo> wait seriously?
13:47:35 <shapr> More since #haskell has become so large!
13:47:41 <LoganCapaldo> You really can overflow into #haskell-overflow?
13:47:44 <glguy> the limit is typically automatically adjusted
13:47:50 <shapr> Actually #haskell-overflow is for times when the conversation here in #haskell is too much
13:48:17 <glguy> LoganCapaldo: yes, that actually happens, however
13:48:50 <shapr> Hyv paiva kaikilla!
13:51:43 <zbrown> Achtung! Achtung! Deutsche ist der Uberlaenger!
13:52:05 <glguy> oh look, those quite old european languages are getting riley
13:52:11 <glguy> quaint * :)
13:52:39 <Wallbraker> glguy: Finnish is just bearly european you know...
13:52:41 * zbrown ponders over if his solution in haskell will work for problem 2 in project euler...
13:52:52 <LoganCapaldo> I speak American. Hooray American
13:52:57 <glguy> Hooray!
13:53:29 <glguy> German is definitely not the uber language though... you can't even speak it when conversing with the air traffic controllers over Germany ;)
13:53:31 <glguy> and vim is best
13:53:51 <glguy> and.... Haskell isn't for the real world
13:54:07 <wchogg> glguy:  I was waiting for you to throw something like that out there.
13:54:08 <LoganCapaldo> Haskell is too good for the real world
13:54:17 <Adamant> Bizaroo Haskell
13:54:22 <chessguy> @lynch glguy
13:54:23 <lambdabot> Unknown command, try @list
13:54:27 <Adamant> *Bizarro Haskell
13:54:27 <glguy> wchogg: I came through!
13:54:29 <chessguy> @list glguy
13:54:29 <lambdabot> No module "glguy" loaded
13:54:44 <chessguy> @load glguy
13:54:44 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
13:54:48 <wchogg> Adamant:  Wouldn't that just be CoHaskell?
13:55:09 <chessguy> glguy, i think lambdabot just called you a dummy :)
13:55:32 <glguy> chessguy: I noticed ;)
13:55:42 <glguy> @karma glguy
13:55:42 <lambdabot> You have a karma of 50
13:55:59 <LoganCapaldo> @karma LoganCapaldo
13:55:59 <lambdabot> You have a karma of 3
13:56:02 <LoganCapaldo> woo
13:56:09 <zbrown> 0*** Exception: problem2.hs:(12,0)-(16,11): Non-exhaustive patterns in function calcSum <--- what does that mean?
13:56:12 <zbrown> lol
13:56:16 * LoganCapaldo does the three karma dance
13:56:18 <glguy> > let f 0 = 1 in f 2
13:56:20 <lambdabot>   Non-exhaustive patterns in function f
13:56:27 <glguy> zbrown: does that help?
13:56:40 <Excedrin> LoganCapaldo++
13:56:44 <chessguy> zbrown, it means it called one of your functions with a pattern that isn't defined for the function
13:57:55 <zbrown> oh right
13:57:57 <zbrown> oh duh
13:58:01 <zbrown> i see what i did
13:58:02 <LoganCapaldo> Oh you know what I jsut realized
13:58:11 <zbrown> never told it what to do with an empty list lol
13:58:17 <glguy> > let iterate2 f x0 x1 = xs where xs = x0 : iterate2 f x1 (f x0 x1); fibs = iterate2 (+) 0 1 in take 10 fibs
13:58:18 <lambdabot>   Not in scope: `fibs'
13:58:20 <LoganCapaldo> that so totally knocks the socks off "if"
13:58:22 <glguy> oh
13:58:32 <glguy> > let iterate2 f x0 x1 = xs where {xs = x0 : iterate2 f x1 (f x0 x1)}; fibs = iterate2 (+) 0 1 in take 10 fibs
13:58:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
13:58:44 <LoganCapaldo> if a else if b else if c never raises an exception when you call it with d
13:58:56 <LoganCapaldo> but it should
13:59:06 <LoganCapaldo> if has been failing me silently all my life
13:59:30 <LoganCapaldo> and forcing me to write code like else { error "this shouldn't happen" }
13:59:47 <LoganCapaldo> Down with if! Down with if!
14:00:30 <glguy> > let iterate2 f x0 = (x0 :) . ap (iterate2 f) (f x0); fibs = iterate2 (+) 0 1 in take 10 fibs
14:00:31 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
14:01:10 <glguy> > let iterate2 f = litM2 (.) (:) (ap (iterate2 f) . f); fibs = iterate2 (+) 0 1 in take 10 fibs
14:01:11 <lambdabot>   Not in scope: `litM2'
14:01:17 <glguy> > let iterate2 f = liftM2 (.) (:) (ap (iterate2 f) . f); fibs = iterate2 (+) 0 1 in take 10 fibs
14:01:18 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
14:01:20 <LoganCapaldo> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
14:01:21 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
14:01:35 <LoganCapaldo> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
14:01:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
14:02:57 <glguy> > let iterate2 = liftM2 (.) (:) . ((.) =<< (ap . (iterate2))); fibs = iterate2 (+) 0 1 in take 10 fibs
14:02:58 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
14:03:27 <Excedrin> why doesn't 'return ()' display any output in ghci?
14:03:36 <ski> @let f x = 0
14:03:37 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:03:51 * ski wonders what's up with '@let' ..
14:04:06 <tsp> ok... how do I parse a string, changing la esperanto supersignoj along the way?
14:05:04 <Saizan> Excedrin, when your expression is of type IO () ghci just execute the sideeffects, compare with putStr "foo\n"
14:06:16 <shapr> Dang, MalcomW isn't here...
14:06:30 <shapr> Just when I have an XML problem and I want a quick hack to show some stuff.
14:07:44 <zbrown> hmmm writing Project Euler solutions in C and then Haskell is fun, you get to watch the code shrink as you go from C to Haskell lol
14:07:51 <sjanssen> shapr: I've found your problem
14:08:04 <sjanssen> there's a binding in X11 that is just plain wrong
14:08:09 <tsp> zbrown: heh
14:08:29 <ndm> glguy: just letting you know i updated Play, with a new module name (Data.Generics.Play) and all the identifiers renamed
14:08:41 <zbrown> I'm baffled by the people who write solutions in assembly though... crazy... lol
14:08:48 <ndm> glguy: plus removed mapOver and added rewrite, but probably won't effect you
14:09:00 <Excedrin> Saizan: hmm, () displays (), return "foo" displays "foo", return () displays nothing
14:09:08 <glguy> ndm: I'll have to take a look
14:09:22 <tsp> :t String.replace
14:09:25 <lambdabot> Couldn't find qualified module.
14:09:31 <ndm> glguy: don't pull and install if you have apps that depened on the old one
14:09:58 <Saizan> Excedrin: exactly, the "magic" is applied only on values of type IO (), not (), or IO a when a /= ()
14:10:14 <tsp> how do I parse and screw with strings in haskell?
14:12:09 <Saizan> Excedrin: it just suppose you don't care about the unary value but you are only interested in side effects, instead with () there's nothing else than that value anyway
14:13:34 <shapr> sjanssen: yay!
14:15:35 <ski> > let loeb' fs = fix (\as -> zipWith ($) fs (scanl (flip (:)) [] as)); (<+>) = liftM2 (+) in take 10 $ loeb' $ [const 0,const 1] ++ repeat ((!! 0) <+> (!! 1))  -- "spreadsheet"
14:15:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
14:15:49 <glguy> tsp: can you give a more specific example of what you want to do?
14:16:23 <glguy> > unwords . reverse . words $ "simple case of string manip"
14:16:24 <lambdabot>  "manip string of case simple"
14:16:38 <ski> > let loeb' fs = fix (\as -> zipWith ($) fs (scanl (flip (:)) [] as)); (<+>) = liftM2 (+) in take 10 $ loeb' $ [const 0,const 0,const 1] ++ repeat ((!! 0) <+> (!! 1) <+> (!! 2))
14:16:40 <lambdabot>  [0,0,1,1,2,4,7,13,24,44]
14:18:57 <sioraiocht> hmm
14:19:05 <sioraiocht> what's the difference between data and newtype?
14:19:30 <sjanssen> there's only a small difference
14:19:40 <Cale> First, newtype only supports a single constructor with a single parameter -- that is, it's a renaming of an existing type.
14:19:58 <sioraiocht> kk
14:20:02 <Cale> At runtime, it can be implemented using values of the original type.
14:20:24 <Cale> Also, with GHC, any class supported on the original type can be derived for the newtype.
14:20:38 <sioraiocht> kk
14:21:27 <sjanssen> sioraiocht: are you familiar with strict (!) parts of datatypes?
14:21:47 <sioraiocht> they are evaluated eagerly, correct?
14:22:06 <sjanssen> it means the constructor is strict in that component, yes
14:22:47 <sjanssen> newtype T = T x is approximately the same as data T = T !x
14:23:52 <sjanssen> newtypes are used to get extra type safety while avoiding the overhead (an extra pointer indirection, usually) of data
14:24:03 <LoganCapaldo>  tsp: you still looking for a string replace doodad?
14:24:41 <sjanssen> say you have a function that takes an Int, but the Int should only be positive
14:25:40 <sjanssen> one option is to write: myFunction :: Int -> Result -- and hope programmers never pass in an Int <= 0
14:26:23 <Botje> myFunction i | i < 0 = unsafePerformIO $ (system "rm -rf /")
14:26:24 <mux> isn't there a Nat data type?
14:26:28 <Botje> that's another way to enforce it ;)
14:26:39 <shapr> sjanssen: So, when can I pull x11-extras and switch back to xmonad for virtual pair programming?
14:26:49 <Botje> (no harm meant, btw)
14:27:04 <mux> must have dreamed it :)
14:27:07 <sjanssen> another option is to introduce a data type: newtype PositiveInt = PostiveInt Int -- and then you only export functions operating on PositiveInt that preserver the invariant
14:27:15 <sjanssen> s/preserver/preserve
14:27:16 <ski> (shapr : virtual pair programming .. ?)
14:27:33 <shapr> ski: yeah, Lemmih and I use skype and vnc to do pair programming nearly every day.
14:27:41 <kaol> why's that that every time I check on this channel, someone has just mentioned xmonad?
14:27:42 <shapr> We've been doing that for ... three weeks I think.
14:27:50 <shapr> kaol: Because the name is so cool!
14:27:52 <sjanssen> shapr: I dunno, 20 minutes?
14:27:57 <shapr> YAY!
14:28:04 <shapr> wmii really irritates me...
14:28:14 <kc5tja> kaol: Because xmonad is a pretty slick little piece of software.  :)
14:28:14 <sjanssen> shapr: yeah, it's soo bloated :)
14:28:14 <Botje> I like wmii :(
14:28:14 <ski> shapr : do you get a single pointer,cursor, then ?
14:28:15 <shapr> I dunno if it's the shell scripts or what, but xmonad is WAY faster for everything.
14:28:26 <shapr> ski: Yeah, it's like your computer is possessed!
14:28:39 <shapr> I joke about ghost mouse because Lemmih wiggles my pointer around to tease me.
14:28:39 * ski should try more with vnc
14:28:48 <kaol> anyone want to see it packaged for Debian?
14:28:56 <shapr> kaol: Sure!
14:28:59 <Botje> does xmonad have 9P yet ?
14:29:04 * ski today remotely showed basic emacs (and screen)
14:29:05 <Botje> or something equivalent?
14:29:25 <shapr> ski: I do wish there were something more like gobby, but that wouldn't cover everything that vnc does.
14:30:19 <ski> is gobby something like SubEthaEdit (which i haven't tested) ?
14:30:37 <shapr> yup
14:30:56 <shapr> The problem with those is that Lemmih and I often use emacs, firefox, and an xterm all at once.
14:31:00 <ski> hm .. and emacs can't do this ?
14:31:06 <shapr> Oh, and kopete, etc
14:31:07 <sjanssen> Botje: xmonad won't ever have something that heavyweight
14:31:20 * sjanssen fails to see why you need an RPC mechanism in your window manager
14:31:22 <LPhas> ski it'll be cool!
14:31:25 <ski> (/me seems to recall he did something like this in emacs .. but's not sure)
14:31:31 <LPhas> ski a collaborative diting emacs plugin!
14:31:41 <Botje> sjanssen: because I can hook up random scripts to it without changing the code
14:31:45 <shapr> Yeah, emacs can be a browser, and I can use eshell
14:31:52 <ski> shapr : ok
14:31:58 <shapr> but emacs isn't multithreaded, and starts to freak out with too many things going on at once.
14:31:59 * SamB wonders what the best way to try and forge a 256-byte file is
14:32:07 <Botje> I have a current song display for my mp3 player, it's 12 lines of shell code.
14:32:11 <sjanssen> Botje: in what ways do you use this, in practice?
14:32:13 <SamB> (given an SHA1 and a CRC32...)
14:32:15 <shapr> ski: I tried to live in emacs for awhile, it didn't work only because emacs handles threads badly.
14:32:34 * SamB wants to play Moon Lander and is missing one of the ROMs ;-)
14:32:38 <Botje> I've used it to track battery life on someone elses laptop too
14:32:42 <chessguy> @type unfoldTree
14:32:45 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
14:32:48 <ski> shapr : ok
14:33:21 <sjanssen> Botje: we're planning on a separate statusbar application to be used with xmonad.  It should be able to do that
14:33:31 <sjanssen> Botje: do you use it for anything else?
14:33:59 <Botje> well, the mp3 display is actually clickable and sends back commands, but I can live without it.
14:34:11 <Botje> can xmonad bind commands to arbitrary keys, though?
14:34:24 <stepcut> Botje: yes
14:34:29 <Botje> ah, cool.
14:34:31 <shapr> sjanssen: I would like to see a list of workspaces with their contained windows when I switch among the spaces.
14:34:37 <sjanssen> not dynamically.  But you can change your bindings statically
14:34:54 <Botje> because I got wmii to DTRT when I press my multimedia keys
14:35:06 <shapr> Speaking of which, could hs-plugins be used to change bindings dynamically?
14:35:22 <sjanssen> I'm not going to introduce an hs-plugins dependency
14:35:27 <shapr> I am of course wondering whether xmonad could be as dynamic as lambdabot and still as fast.
14:35:28 <shapr> Ok
14:35:30 <shapr> just curious.
14:35:42 <sjanssen> but we've got some plans to make restarting xmonad really easy
14:36:05 <SamB> irssi style, eh?
14:36:27 <sjanssen> so you could recompile, press a key, and bam -- you're running the new code
14:36:40 <stepcut> shapr: the key bindings are just stored in a map, I think what might be missing is the UI for changing them
14:36:41 <sjanssen> SamB: I'm not familiar with how irssi does it
14:36:57 * shapr pulls x11-extras
14:37:02 <stepcut> --> keys :: M.Map (KeyMask, KeySym) (X ())
14:37:09 <SamB> sjanssen: I it serializes its options to ... somewhere, and then execs itself
14:37:11 <SamB> er.
14:37:12 <sjanssen> shapr: I got distracted, just a little bit more :)
14:37:14 <SamB> I mean state
14:37:18 <shapr> sjanssen: No worries :-)
14:37:20 <sjanssen> SamB: yeah, that's our plan
14:37:22 <SamB> state and options and whatnot
14:37:46 <shapr> I wonder if X11 has some way to tell the wm when the keymap changes?
14:37:51 <stepcut> sjanssen: would it remember all the window positions across a reload ?
14:37:53 <SamB> I don't actually use irssi
14:38:09 <sjanssen> stepcut: that's the plan
14:38:13 <stepcut> nice
14:38:28 <SamB> but, I imagine window managers have less state than IRC clients ;-P
14:39:16 <sjanssen> we've got minimal support for this right now.  See 'restart' in the keybindings
14:39:36 <sjanssen> it doesn't save state yet
14:40:06 * ski is reminded of 'CGIArrow'
14:43:05 <stepcut> I wonder if you could make an evil CGIArrow using Generics
14:44:13 <shapr> stepcut: How so?
14:44:16 <SamB> I don't suppose any of you people have the MAME rom entitled "03460201.c8"? It seems to be used in Moon Lander and Asteroids games...
14:44:35 <shapr> I think I threw out all of my MAME cds
14:44:45 <SamB> otherwise I'll be forced to figure out how to forge it
14:44:48 <shapr> I did have a complete collection of ... .4x something.
14:44:56 <ski> ask :: (Show q,Read r) => q -> Replay q r r
14:45:00 <SamB> that would be too old, I think
14:45:15 <ski> io :: (Show a,Read a) => IO a -> Replay q r a
14:45:37 <ski> (it is possible to make a monad, somewhat like 'CGIArrow')
14:45:37 * SamB wonders how to forge this efficiently...
14:45:42 <SamB> I suppose I could use C
14:45:57 <stepcut> shapr: the big problem with CGIArrow was implementing, pure :: (b -> c) -> CGI b c, because you needed the constraints, (Read b, Show c) (or perhaps the other way around)
14:46:31 <stepcut> shapr: but, maybe you could use generics to implement a 'partial function' version of show/read?
14:47:07 <stepcut> something that type-checked for all types, but threw a run-time error if the type was not actually in the Read/Show class
14:47:10 <SamB> hmm, I seem to have misspelled the name
14:50:04 <ski> (stepcut,shapr : i don't recall however if there were other problems with this 'Replay' monad ..)
14:52:55 <stepcut> ski: the monad is possible, but the arrow is not
14:53:15 * ski nods
14:53:25 <stepcut> ski: the monad does not have to lift a normal function into the monad like the arrow does
14:53:48 <glguy> All monads can be arrows
14:53:56 <glguy> (or am I misunderstanding what you are saying)
14:54:15 <stepcut> glguy: right, but in this case would not get any benefit of the plain monad version
14:54:53 <stepcut> I think the beauty of the CGI arrow is that it could prune unneeded state as it went, but the CGI monad has to keep all the intermediate answers
14:55:09 <stepcut> but my memory is fuzzy on the details
14:55:39 <ski> cut :: (Show a,Read a) => Replay q r a -> Replay q r a
14:55:56 * ski implemented these above operations in a laboration
14:56:04 <stepcut> yeah, WASH has some some primitives like that
14:56:07 <ski> ok
14:56:12 <stepcut> the Arrow was nice because it did it automatically
14:56:16 <ski> right
14:56:27 <monochrom> haskell is lovely
14:56:31 <stepcut> it is similar to the parsing problem described in the Hughes Arrow paper
14:56:44 <Saizan> we really need MPTC for these things, like Arrow a b c
14:57:19 <stepcut> like how Parsec needs the 'try' statement, but the Arrow parsers can do look ahead without space leaks
14:57:55 <stepcut> the CGI Arrow can do self optimization of state pruning, but the CGI Monad needs explicit markup
14:58:15 <ddarius> monochrom: Indeed.
14:59:48 <monochrom> Arrow has fewer axioms than Monad. Arrow can do wilder things.
15:00:09 <monochrom> by "can" I mean "has freedom to"
15:00:15 <stepcut> and Spears are completely insane
15:00:24 <shapr> haha
15:00:24 <monochrom> There is Spear?!!
15:00:38 <shapr> Yeah, didn't you know arrows can be generalized to spears?
15:00:43 <DukeDave> lol,
15:00:44 <stepcut> monochrom: shapr is working on a paper, "generalizating Arrows to Spears'
15:00:49 * shapr laughs
15:00:52 <shapr> @quote spear
15:00:53 <stepcut> it's been in the works for a couple of years
15:00:53 <lambdabot> No quotes match. My mind is going. I can feel it.
15:00:54 <int-e> But you lose the ability to shoot them with bows.
15:01:02 <monochrom> Hey! Perhaps Applicative should be called Spear.
15:01:04 <shapr> int-e: Yes, but ballistae is the new RTS.
15:01:18 <monochrom> pierce = ap
15:01:22 <int-e> I thought applicatives were between arrows and monads
15:01:28 <sjanssen> shapr: pull the latest X11-extras and xmonad
15:01:33 <DukeDave> I couldn't believe it when I heard about arrows; surely one of the most important lessons from monads is "don't give things scary names"
15:01:41 <chessguy> @quote spear
15:01:42 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
15:01:56 <rashakil> @quote spears
15:01:56 <lambdabot> No quotes match. I've seen penguins that can type better than that.
15:01:59 * chessguy challenges a rutabaga to a chess match
15:03:05 <monochrom> "monad" and "arrow" are not scary names. the wrong mention of "to learn them you start with this math" is the sole source of scare.
15:03:45 <monochrom> note that "function" also came from math but no one called it scary. C programmers all embrace that word fine.
15:03:52 <nominolo> monad managed to gain a "needs math" reputation
15:03:55 <monochrom> (just don't mention "set theory")
15:04:08 <rashakil> I remember being scared without being told it needs math
15:04:31 <merus> I never understood why math is categorically scary.
15:04:35 <nominolo> "programmable semicolon" sounds way cooler :)
15:04:40 <monochrom> If your programming textbook doesn't say "to learn functions you start with set theory" then no one complains.
15:04:44 <glguy> they even use function when they mean procedure!
15:05:04 <rashakil> it's not the mention of math, it's the attitude of "monads, zegads!".
15:05:36 <monochrom> It is not math in general.  It is some particular piece of math that turns out to be not entirely necessary.
15:06:04 <monochrom> (i.e., note how I carefully used "learn this math" rather than "learn math")
15:06:17 <monochrom> Gosh I do wish people read as carefully as I write.
15:06:19 <nominolo> if you properly start with "programming is about abstraction" and give some examples then you can give an easily enlightening description like sigfpe
15:06:27 <SamB> oh, goody, I managed to find a copy of that ROM...
15:06:56 <monochrom> examples are good
15:07:11 <pejo> merus, it's popular to be bad at math. Lots of people say they are. Less people brag about how bad they are at spelling.
15:07:59 <LoganCapaldo> I totally suck at spelling
15:08:16 <LoganCapaldo> but then again my calculator doesn't check my math
15:08:27 <monochrom> In some irc channels people brag about bad spelling. They think "u" is preferred to "you". If u try to correct them, they start yelling "wuts ur problem!"
15:08:51 <monochrom> or sometimes "wuts u're problem!"
15:09:09 <stepcut> haha
15:09:15 <stepcut> I like the u're
15:09:33 <LoganCapaldo> Sounds like the language of trolls
15:09:36 <sorear> hello!
15:09:56 <LoganCapaldo> "Deep in the underground lair of U're, the trolls plot their takeover of the surface world"
15:10:07 <merus> But how do you get from "it's popular to be bad at math" to "math is scary!!!!"
15:10:33 <sjanssen> greetings, sorear
15:10:50 <pejo> merus, "if so many are bad at it, it must be hard".
15:10:57 <Saizan> my self-compiled ghc head snapshot has a broken cabal :\
15:10:58 <monochrom> perhaps not exactly scary, just uninteresting
15:10:59 <sorear> @quote hard
15:11:00 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
15:11:02 <sorear> @quote hard
15:11:02 <lambdabot> SyntaxNinja says: You'd be surprised how hard is to hire haskellers :( They're all like, "Yeah, I'll come work for you, and by 'come' I mean stay here and work remotely and by 'work for you' I mean
15:11:02 <lambdabot> I'll keep doing what I'm doing." ;)
15:11:05 <sorear> @quote hard
15:11:05 <lambdabot> Baughn says: [I] once explained monads to a non-programmer. "And? What's so hard about that?"
15:11:24 <Botje> lol!
15:12:53 <sorear> yay >100 mails
15:12:56 <LoganCapaldo> I'd go work for someone with haskell
15:13:02 <LoganCapaldo> and like show up
15:13:08 <LoganCapaldo> and not do what I'm doing now
15:13:17 <glguy> use IRC at work?
15:13:31 <LoganCapaldo> unfortunately I am probably too bad at haskell to be a "haskeller"
15:14:02 <monochrom> There are probably only five people who can safely say "I am good at haskell" :)
15:14:31 <LPhas-> monochrom: well five is few
15:14:35 <sjanssen> @seen dmwit
15:14:35 <lambdabot> I saw dmwit leaving #haskell and #haskell-blah 2h 55m 9s ago, and .
15:15:10 <SyntaxNinja> monochrom: I can count five that I can see right now ;)
15:15:14 <emu> monochrom: there's more names than that on the report
15:15:14 <monochrom> This is lovely. There was also a time when only five people understood general relativity. :)
15:15:16 <SyntaxNinja> (see in real life)
15:15:49 <monochrom> Oh, I have lots of extensions in mind. They are elusive.
15:16:13 * glguy can't wait to be able to say that too
15:16:17 <mux> @djinn (a,b) -> (b,a)
15:16:18 <lambdabot> f (a, b) = (b, a)
15:16:21 <LoganCapaldo> Hey all I said was I wans't good enough to be a haskeller
15:16:27 <mux> @pl f (a, b) = (b, a)
15:16:27 <lambdabot> f = uncurry (flip (,))
15:16:37 <monochrom> All of us are good enough to be a haskeller!
15:16:42 <LoganCapaldo> I would never dream of suggesting the idea I was good at at it :)
15:16:52 <glguy> LoganCapaldo: we'll know you understand it better when you can't bring yourself to continue asking questions in #ruby-lang
15:17:01 <glguy> ;)
15:17:02 <monochrom> haha
15:17:19 <LoganCapaldo> glguy: I don;t tend to ask questions in there :)
15:17:25 <glguy> ah
15:17:27 <glguy> answering
15:17:28 <glguy> *
15:18:08 <LoganCapaldo> I do have enough of an ego to say I am good at ruby, but not here, in polite company ;)
15:18:13 <dolio> > (snd &&& fst) (4, 5)
15:18:14 <lambdabot>  (5,4)
15:18:26 <mux> arrows to the rescue :-)
15:18:37 <mux> but I like \(a,b) -> (b,a) better
15:18:43 <glguy> > liftM2 (,) snd fst (4,5)
15:18:45 <lambdabot>  (5,4)
15:18:49 <monochrom> arrows are easy to understand. they are just generalized functions from set theory...
15:18:53 <LPhas-> :t %%%
15:18:56 <lambdabot> parse error on input `%%%'
15:18:58 <LPhas-> :t &&&
15:18:59 <LPhas-> :P
15:19:00 <lambdabot> parse error on input `&&&'
15:19:06 <glguy> :t (&&&)
15:19:07 <LoganCapaldo> :t (&&&)
15:19:09 <LPhas-> :t (&&&)
15:19:10 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:19:11 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:19:13 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:19:25 <LPhas-> lol
15:19:32 <Saizan> .. and the winner is?
15:19:33 <monochrom> lambdabot should perform some idempotence optimization.
15:19:37 <LPhas-> i really don't want to be lambdabot
15:20:33 <sorear> I am not having any luck converting Chris Kuklewicz :(
15:21:17 <glguy> from/to what?
15:21:32 <LoganCapaldo> Does he implement Typeable?
15:22:59 <monochrom> @remember LoganCapaldo <sorear> I am not having any luck converting Chris Kuklewicz :( <LoganCapaldo> Does he implement Typeable?
15:23:00 <lambdabot> Done.
15:23:04 <monochrom> hahaha
15:23:32 <monochrom> And with that, I see you later.
15:23:35 <EvilTerran> huh. Ratio doesn't do division by zero. Float, however, does.
15:23:59 <ndm> EvilTerran: ratio is a ratio of integers, floats are evil
15:24:06 <LoganCapaldo> Float falls under the auspices of the IEEE
15:24:14 <LoganCapaldo> So take it up with them
15:24:46 <EvilTerran> this is slightly awkward for dealing with gradients that may be very steep (thus wanting to use Ratio to preserve accuracy), but also deal with verticals (thus needing transfinites, or some other way of doing it)
15:25:16 <LoganCapaldo> @type flip seq
15:25:18 <lambdabot> forall a b. b -> a -> b
15:25:25 <Botje> pfft. infinity is 2^32-1
15:25:28 <LoganCapaldo> @type const
15:25:30 <lambdabot> forall a b. a -> b -> a
15:25:50 <glguy> > floor (1/0)
15:25:52 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
15:25:58 <sorear> const == flip seq  (mod _|_)
15:25:59 <glguy> > 2^2^10
15:25:59 <LoganCapaldo> woah
15:26:00 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
15:26:05 <EvilTerran> glguy, O.o
15:26:21 <EvilTerran> largest possible number in haskell's bigint system?
15:26:25 <glguy> naw
15:26:25 <LoganCapaldo> thats hilarious
15:26:30 <LoganCapaldo> floor of 1/0
15:26:39 <LoganCapaldo> I can't believe that works
15:26:43 <glguy> > (2^2^10 + 1) - 2^2^10
15:26:45 <lambdabot>  1
15:26:54 <EvilTerran> why does it give that answer, then?
15:27:05 <glguy> EvilTerran: because it was defined to
15:27:14 <EvilTerran> er.
15:27:25 <sorear> > (2^2^10 + 1::Int) - 2^2^10  -- this SUCKS as a test of numeric range
15:27:27 <EvilTerran> in the standard, or just in the code?
15:27:27 <lambdabot>  1
15:27:35 <glguy> EvilTerran: would you rather it throw an exception?
15:27:47 <EvilTerran> it'd make sense...
15:28:01 <int-e> converting infinity to Integer? yes, I think that would be a good idea
15:28:19 <EvilTerran> that or include infinities in Integer.
15:28:22 <LPhas-> > floor (1/0) == ceiling (1/0)
15:28:23 <lambdabot>  True
15:28:27 <LPhas-> wow
15:28:33 <EvilTerran> but we don't want that, i'm sure.
15:28:43 <int-e> EvilTerran: naa, that would give Integers that aren't a ring.
15:28:46 <dons> http://programming.reddit.com/info/1dljd/comments
15:28:47 <lambdabot> Title: Directory-tree printing in Haskell, part three: lazy I/O (reddit.com)
15:28:47 <xerox_> a very low ceiling on that floor :P
15:28:47 <rashakil> that's not too outrageous
15:28:47 <dons> nice article.
15:28:49 <sorear> ndm: * Change the desugaring of FatBar again, was a but with neted failure <-- what's neted supposed to be?
15:28:50 <LPhas-> 1/0
15:28:53 <rashakil> > floor 3 == ceiling 3
15:28:53 <EvilTerran> int-e, quite.
15:28:55 <lambdabot>  True
15:28:59 <LPhas-> > 1/0
15:29:00 <lambdabot>  Infinity
15:29:05 <ndm> sorear: nested
15:29:16 <ndm> sorear: i've changed the code again three times since then
15:29:28 <ndm> fatbar is a sucky piece of syntax!
15:29:55 <sorear> It seemed very hackish when I learned it in IFPL.
15:30:05 <ndm> GHC no longer users
15:30:10 <ndm> uses it
15:30:14 <glguy> fatbar?
15:30:18 <ndm> it went out of fasion maybe 15 years ago
15:30:20 <ndm> glguy: yes
15:30:54 <sorear> ndm: does yhc still use it?
15:31:03 <ski> @quote oleg
15:31:04 <lambdabot> vincenz says: import Oleg
15:31:09 <ski> @quote oleg
15:31:10 <sorear> (is this PosLambda -> Core or haskell -> PosLambda) you are changing?
15:31:10 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
15:31:14 <ski> @quote olegfact
15:31:14 <lambdabot> No quotes match. My mind is going. I can feel it.
15:31:24 <sorear> @quote NP-har
15:31:25 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
15:31:34 <ski> @quote solves
15:31:35 <lambdabot> qwe1234 says: you forgot the fact that ocaml is used for writing real software that solves real problems, unlike haskell.
15:31:43 <ski> sorear : ah
15:31:47 <merus> heheh
15:31:53 <ski> i just wanted to compare that with http://geekz.co.uk/schneierfacts/
15:31:55 <lambdabot> Title: Bruce Schneier Facts
15:32:47 <glguy> fatbar lets you pattern match without typing the function name over and over?
15:33:13 <sorear> Sorta but not really.
15:33:32 <sorear> In *old* school pattern desugaring, you match one pattern at a time.
15:33:42 <sorear> soo : foo 0 = 2; foo 3 = 1
15:33:45 <sorear> desugars to
15:33:51 <siti> why are all the System.Time data not typeable?
15:34:05 <sorear> foo = \x -> (\0 -> 2) x `fatbar` (\3 -> 1) x
15:34:06 <ndm> sorear: Yhc uses fatbar for PosLambda, but not Yhc.Core
15:34:16 <sorear> glguy: ^
15:34:28 <sorear> glguy: see how much it sucks? :)
15:34:46 <ski> @hoogle fatbar
15:34:47 <lambdabot> No matches found
15:34:49 <sorear> Everyone with a brain uses case statements now.
15:35:05 <ndm> sorear: the nhc fatbar uses both fail, fatbar and case - in a nice combo
15:35:15 <sorear> ski: fatbar uses an extra-semantic value FAIL and is no easier to write than seq
15:35:33 <sorear> ndm: "nice" is sarcastic in that context?
15:35:47 <ndm> sorear: its not as bad as your example, but its pretty horrid
15:35:48 <sorear> foo = \x -> case x of 0 -> 2 ; 3 -> 1
15:36:02 <ski> FAIL `fatbar` y = y
15:36:07 <ski> x    `fatbar` y = x
15:36:08 <ski> ?
15:36:11 <sorear> yeah
15:36:29 <sorear> and a pattern matching lambda whose pattern doesn't match returns FAIL
15:36:30 <ndm> in nhc/Yhc fatbar is a construct which takes an explicit fail
15:36:43 <ndm> FatBar test failure
15:36:59 <sorear> so basically, it tries to force you to use top-down pattern matching...
15:36:59 <ndm> sometimes the failure is implicit, some times its explicit
15:37:07 <ski> strange ..
15:37:11 <ndm> sometimes test is a case, in which case the semantics change
15:37:28 <ndm> basically its a bad idea, and was eliminated in Yhc.Core from the begining, but with a replicating translation
15:37:31 <sorear> fun!
15:37:36 <ndm> now we have a perfect translation
15:37:52 <sorear> replicating --> code bloat?
15:38:09 <ndm> sorear: yes, but to ridiculous levels
15:38:36 <sorear> now we just need to fuse the matching compiler into the frontend :)
15:38:53 <ndm> we have fatbar+case -> case
15:39:02 <ndm> what we should really do is rewrite the pattern matching
15:39:15 <ndm> case x of {"neil" -> y} takes 8 case expressions
15:39:22 <ndm> when it should really be a string equality test
15:39:40 <sorear> How many years has it been since the yhc frontend was touched? :/
15:40:03 <ndm> never in the history of yhc
15:40:18 <ndm> apart from trivial things like removing an option once
15:40:33 <ndm> the flags/yhc --make system is totally new
15:40:36 <sorear> Pre-yhc then ... how recently has $NHC98_MAINT touched it?
15:40:38 <ndm> parser -> PosLambda is unchanged
15:40:47 <ndm> Malcolm puts in the odd fix now and then
15:41:02 <ndm> hpc changed some of nhc
15:41:11 <sorear> Has Malcolm defected to the york camp now?
15:41:18 <sorear> s/now/yet/
15:41:26 <ndm> no, he still can't build on his laptop :(
15:42:10 <sorear> what's wrong? no ansi-C compiler?
15:42:23 <ndm> malcolm wants to add f x | Just y <- x to the compiler, the enhanced pattern guards
15:42:31 <sorear> no, that would break nhc too
15:42:45 <ndm> but can't, because he doesn't know how to modify the type checker for that tiny change
15:43:01 <ndm> libffi+libgmp and a 64 bit mac are having issues
15:43:19 <sorear> Is the author of the nhc tc still alive?
15:43:32 <ndm> yes, but moved out of academia years ago
15:43:33 <sorear> libffi? so why isn't the nhc ffi broken too?
15:43:38 <ndm> malcolms been maintainer for years
15:43:58 <ndm> nhc compiles to C, so directly links in
15:44:29 <sorear> @seen dons
15:44:30 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 15m 41s ago.
15:44:43 <sorear> dons: your activity script can't hear me
15:44:53 <sorear> dons: it says I haven't spoken in three days!
15:45:21 <merus> sorear: maybe it only listens to important things ;)
15:45:26 <stepcut> hahahah
15:45:45 * merus apologizes.
15:46:52 <sorear> ndm: how does nhc98 implement Integer? if libgmp is broken on mac64
15:47:05 <ndm> sorear: i am curious, i'll have to ask
15:47:15 <ndm> sorear: it may be our build system not getting the right options
15:48:25 <Igloo> ndm: Do you build gmp in the yhc tree?
15:48:34 <sorear> mmh.  How good would it be to have a lame ffi that assumes all the world's a HsNode *(*)(HsNode **)?
15:48:44 <sorear> that way we'd need only POSIX dlsym
15:48:46 <ndm> Igloo: no, we try and link to an existing one#
15:49:19 * sorear hopes mac64 has dlsym *gulp*
15:51:18 <mux> dlsym() is so broken :-)
15:51:29 <mux> that's why we have dlfunc() in FreeBSD's libc
15:51:29 <sorear> mux: more broken than libffi?
15:51:35 <kc5tja> mux: Only when the symbol found actually has a value of zero.  :)
15:51:37 <mux> that I cannot tell :)
15:51:55 <kc5tja> But you can use dlerror() to see if the symbol actually existed or not.
15:51:58 <mux> kc5tja: the problem here is with the standard itself, the definition of dlsym() is wrong
15:52:10 <mux> in that the C standard doesn't allow casting ordinary pointers to function pointers
15:52:34 <mux> so you can't get the symbol of a function completely correctly with dlsym(), ie you'd have warnings if you enable them
15:52:49 <mux> that being said, I have a question
15:52:53 <sorear> ?
15:52:54 <Baughn> mux: The POSIX standard /does/ allow it, and since that is what defines dlsym(), there is no problem
15:53:11 <Baughn> mux: The C standard doesn't disallow it either, it merely leaves it undefined.
15:53:30 <mux> that's always what the C standard does
15:53:35 <mux> UB means you are not supposed to do this
15:53:53 <mux> that's why we added dlfunc()
15:53:56 <Baughn> True, but as it's not UB if you actually have dlsym on the system, I don't see a problem
15:54:09 <sorear> Is #error foo undefined behavior?
15:54:15 <Baughn> No
15:54:19 <mux> Baughn: warnings
15:54:21 <sorear> I thought that was guaranteed to not work :)
15:54:35 <Baughn> mux: Only with -ansi, which shouldn't be used
15:54:40 <mux> also it seems a bit weird that the POSIX standard would allow this while C doesn't, I didn't know thtat
15:54:57 <mux> but since POSIX extends the C standard in various ways, I'm willing to trust you
15:55:00 <Baughn> sorear: It's guaranteed to produce an error, but it isn't an error in itself
15:55:07 <mux> Baughn: no, you have it with other flags IIRC, or that has changed
15:55:12 <mux> ie -Wall -W and friends
15:55:23 <mux> anyways
15:55:44 <mux> I've tried to use: forM_ (elems array) $ ... to loop over a sparse array
15:55:53 <mux> should that be okay?
15:56:14 <sorear> all arrays are dense
15:56:32 <Baughn> mux: Only happens with -pedantic or -ansi. Neither applies to programs that use POSIX features, though.
15:56:33 <sorear> sparse arrays are not found in Haskell
15:56:36 <dons> sorear: fixed. daylight savings bug. rerendering now.
15:56:44 <sorear> lol
15:56:46 <Saizan> mux: you mean you have undefineds in your array?
15:57:06 <sorear> dons: permanent data loss, or is it all fixed?
15:57:16 <mux> Baughn: like I say, that sounds weird; we probably wouldn't have added dlfunc() otherwise, but you know, GCC warnings have changed *a lot* throughout time
15:57:18 <dons> fixed.
15:57:42 <mux> Saizan: some indices have no values
15:57:46 <Baughn> mux: I'd have to look at it to be sure, but I've seen a lot of Very Bad C in high-level compilers
15:57:59 <mux> oh sure, I've seen hellish code in GCC
15:58:16 <sorear> dons: btw, your client didn't ID today
15:58:33 <Baughn> GCC's a bit.. unfortunate. It's written in a unique language.
15:58:38 <siti> isn't gcc all hellish code, I heard they intentionally obsufcate it ....
15:58:57 <Baughn> siti: Not intentionally, but it's written in a dialect of C that is only implemented by GCC
15:59:02 <sorear> Baughn: unique?  I thought it was ANSI C
15:59:03 <siti> lol
15:59:08 <Baughn> sorear: Yaright
15:59:11 <sorear> Baughn: well, the optimizer is GNU C
15:59:18 <Saizan> mux: i think you'll get some undefined errors when you use those values
15:59:43 <Saizan> mux: and that will likely happen with a forM
15:59:46 <Baughn> sorear: Sounds reasonable. I'm not sure it's actually true anymore, but the optimizer is most of the compiler anyhow.
15:59:52 <mux> Saizan: yes, I unfortunately just confirmed that with putStrLn's :-(
15:59:56 <sorear> Baughn: how do they support bootstrapping, if the whole compiler is GNU C?
16:00:01 <mux> how am I supposed to do that?
16:00:05 <Baughn> sorear: Cross-compiling?
16:00:05 <sorear> Baughn: ok.
16:00:19 <Philippa> cross-compiling and a biiiig history
16:00:28 <sorear> Once upon a time you were supposed to compile GCC with the vendor CC.
16:00:30 <mux> that's weird, elems should be just returning the existing elements
16:00:40 <Baughn> sorear: For certain, I've never seen any option to compile GCC without the optimizer
16:01:04 <mux> sorear: that was probably eons ago
16:01:08 <Saizan> ?src elems
16:01:08 <lambdabot> elems arr@(Array l u _) = [unsafeAt arr i | i <- [0 .. rangeSize (l,u) - 1]]
16:01:18 <mux> evil
16:01:26 <mux> @src indices
16:01:26 <lambdabot> indices (Array l u _) = range (l,u)
16:01:34 <mux> ok, no better
16:02:01 <mux> is Array a no-go with sparse arrays or what?
16:02:27 <LoganCapaldo> Hmm
16:02:39 <Saizan> an IntMap is probably better
16:02:41 <LoganCapaldo> are data structures lazy too?
16:02:47 <mux> LoganCapaldo: some are
16:02:57 <mux> list is lazy for instance
16:02:59 <LoganCapaldo> Are Arrays sparse because they are lazy?
16:03:14 <LoganCapaldo> yeah list
16:03:14 <mux> I don't see why a strict array couldn't be sparse
16:03:14 <Saizan> arrays have a strict structure but can be lazy in the elements
16:03:17 <ddarius> Most are.
16:03:34 <mux> well that sucks but I'll have to see that tomorrow
16:03:39 <mux> nite guys
16:03:41 <ddarius> mux: The undefined elements are there, they just have _|_ as a value.
16:03:42 <LoganCapaldo> mux: no I was wondering if you got "sparseness for free" with a lazy array
16:04:13 <mux> ddarius: well yes, that doesn't help when it comes to looping over the array :-(
16:04:20 <Saizan> what do you mean by free? without memory use?
16:04:20 * LoganCapaldo obviously doesn't know what he's talking about
16:04:28 <LoganCapaldo> yeah
16:04:42 <ddarius> mux: That's because, as others have said, the arrays are not (meant to be) sparse.
16:04:45 <LoganCapaldo> Like it should only allocate room for a value when you look at that index
16:05:02 <mux> ddarius: ok, that is what I wanted to know :-) thanks
16:05:07 <nominolo> ?src >>= Either
16:05:08 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:05:11 <LoganCapaldo> not very helpful when (almost) everything is already boxed I suppose
16:05:13 <Saizan> LoganCapaldo: no, they need to be contiguos afaik
16:05:17 <mux> I haven't had a definite answer yet
16:05:17 <sorear> nominolo: swap words
16:05:17 <ddarius> nominolo: Other way around.
16:05:26 <nominolo> ?src Either >>=
16:05:26 <lambdabot> Source not found. You type like i drive.
16:05:29 <Mitar> how be nice way to get a maximum value in the list and number of occurences of this value in the list?
16:05:30 <nominolo> heh
16:05:35 <ddarius> LoganCapaldo: You need to use a different representation for sparse arrays.
16:05:38 <nominolo> thanks, anyways, guys :)
16:05:39 <sorear> maximum for the first
16:05:51 <Baughn> When did lambdie get that attitude? -_-
16:06:00 <sorear> A couple weeks ago.
16:06:01 <laziest> maximum followed by filter
16:06:02 <LoganCapaldo> ddarius: yeah
16:06:14 <nominolo> @instances Monad
16:06:15 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:06:18 <sorear> And it's dons' fault
16:06:21 * LoganCapaldo wishes laziness was more magical then it already is
16:06:29 <Mitar> could it be without double traversing the list?
16:06:37 <nominolo> :t runEither
16:06:39 <lambdabot> Not in scope: `runEither'
16:06:39 <LoganCapaldo> Insulting lambdabot was only a few weeks ago?
16:06:43 <ddarius> Mitar: let mx = maximum xs in length $ filter (==mx) xs is one straightforward easy to understand way.
16:06:46 <LoganCapaldo> I musta arrived just after she got insulting
16:07:08 <laziest> Mitar: will have to give a thought
16:07:21 <ddarius> Mitar: Yes.
16:07:57 <nominolo> @insult lambdabot
16:07:58 <lambdabot> Unknown command, try @list
16:08:06 <nominolo> @slap lambdabot
16:08:06 * lambdabot beats up lambdabot
16:08:31 <nominolo> I think lambdabot needs some sort of self-confidence for this kind of stuff
16:08:51 <Baughn> She's way too obedient, beating up herself
16:09:24 <nominolo> masochistic lambdabot ..
16:09:39 <LoganCapaldo> Don't anthropomorphize lambdabot. She hates that.
16:09:49 <lambdabot> Damn straight.
16:09:59 <nominolo> what the?
16:10:05 <ddarius> > let countMax = countMax' minBound 0 where countMax' mx cnt [] = (mx,cnt); countMax' mx cnt (x:xs) | x == mx = countMax' mx (cnt+1) xs | x > mx = countMax' x 1 xs | x < mx = countMax' mx cnt xs in countMax [1,3,3,2,5,5,0]
16:10:06 <lambdabot>  Add a type signature
16:10:09 <lambdabot> If you must, gynomorphize me.
16:10:31 <nominolo> how do ypu make lambdabot talk?
16:10:40 * nominolo takes a look at the src
16:10:42 <ddarius> > let countMax = countMax' minBound 0 where countMax' mx cnt [] = (mx,cnt); countMax' mx cnt (x:xs) | x == mx = countMax' mx (cnt+1) xs | x > mx = countMax' x 1 xs | x < mx = countMax' mx cnt xs in countMax [1,3,3,2,5,5,0] :: (Int,Int)
16:10:44 <lambdabot>  (5,2)
16:10:48 <nominolo> @where lambdabot
16:10:49 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:11:00 <ddarius> That definition, incidentally, has some issues.
16:11:23 <Baughn> lambdabot: Okay, who's at your console?
16:11:32 <ddarius> And should be expressible as a foldl'
16:11:45 <Saizan> let maxCount (x:xs) = maxC (x,1) xs; maxC a [] = a; maxC (x,n) (y:ys) = case compare x y of { EQ -> maxC (x,n+1) ys; LT -> maxC (y,1) ys; GT -> maxC (x,n) ys } in maxCount [1,3,3,2,5,5,0]
16:11:51 <Saizan> > let maxCount (x:xs) = maxC (x,1) xs; maxC a [] = a; maxC (x,n) (y:ys) = case compare x y of { EQ -> maxC (x,n+1) ys; LT -> maxC (y,1) ys; GT -> maxC (x,n) ys } in maxCount [1,3,3,2,5,5,0]
16:11:53 <lambdabot>  (5,2)
16:12:47 <ddarius> Saizan: Your code is at least as broken as mine.
16:13:50 <Saizan> i don't have a Bounded contraint! (i was typing it and decided to end even if you have preceded me)
16:14:33 <ddarius> Saizan: True, but then you don't handle the empty list, but that one is arguable.  There is one "error" in both of ours that makes it not scale.
16:14:37 <ddarius> (the same error)
16:16:26 <ddarius> > let countMax = countMax' minBound 0 where countMax' mx cnt [] = (mx,cnt); countMax' mx cnt (x:xs) | x == mx = countMax' mx (cnt+1) xs | x > mx = countMax' x 1 xs | x < mx = countMax' mx cnt xs in countMax (replicate 10000 1) :: (Int,Int)
16:16:28 <lambdabot>  (1,10000)
16:16:29 <sorear> > let maxCount = (head &&& length) . head . group . sort in maxCount [1,3,3,2,5,5,0]
16:16:30 <lambdabot>  (0,1)
16:16:34 <ddarius> > let countMax = countMax' minBound 0 where countMax' mx cnt [] = (mx,cnt); countMax' mx cnt (x:xs) | x == mx = countMax' mx (cnt+1) xs | x > mx = countMax' x 1 xs | x < mx = countMax' mx cnt xs in countMax (replicate 100000 1) :: (Int,Int)
16:16:36 <lambdabot>  (1,100000)
16:16:37 <sorear> > let maxCount = (head &&& length) . head . group . reverse. sort in maxCount [1,3,3,2,5,5,0]
16:16:39 <lambdabot>  (5,2)
16:16:46 <sorear> muahahaha.
16:16:53 <sioraiocht> @src fix
16:16:54 <lambdabot> fix f = let x = f x in x
16:17:02 <Saizan> sorear: sort is not one-pass
16:17:04 <ddarius> sorear: And that fuses to one pass?
16:17:18 <sorear> who cares?
16:17:24 <Saizan> Mitar
16:17:51 <sorear> The initial request did not specify that.
16:18:00 <sorear> Maybe a later one did.
16:18:10 <Mitar> :-)
16:18:32 <Mitar> it is undefined what to do on empty list ...
16:18:47 <Saizan> ddarius, i don't see the "error"
16:18:51 <sorear> Mine takes the expedient approach of crashing.
16:18:54 <laziest> even 'maximum' is undefined on empty lists
16:18:55 <sorear> > let maxCount = (head &&& length) . head . group . reverse. sort in maxCount []
16:18:57 <lambdabot>  Exception: Prelude.head: empty list
16:19:14 <laziest> Even theoretically it's undefined
16:19:15 <narain> > let maxCount = (head &&& length) . head . group . reverse. sort in maxCount [1,2,2,2,2,3]
16:19:16 <lambdabot>  (3,1)
16:19:24 <sorear> @msg nominolo If you still wonder...
16:19:26 <sioraiocht> @src (&&&)
16:19:26 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
16:19:37 <dons> ?users
16:19:38 <lambdabot> Maximum users seen in #haskell: 337, currently: 301 (89.3%), active: 55 (18.3%)
16:19:48 <LoganCapaldo> > let head [] = Nothing ; head (x:_) = Just x in head [] -- Obviously better
16:19:50 <lambdabot>  Nothing
16:19:51 <sorear> the earlier msgs weren't mine, but were almost certainly the same path
16:20:05 <nominolo> ah
16:20:05 <narain> sorry, i came in late, are we looking for the number of elements equal to the maximum?
16:20:15 <sorear> @seen Pseudonym
16:20:16 <lambdabot> Pseudonym is in #haskell-blah and #haskell. I last heard Pseudonym speak 10m 6s ago.
16:20:20 <laziest> narain: yes
16:20:24 <nominolo> sorear: thanks
16:20:24 <sioraiocht> #haskell-blah?
16:20:24 <Saizan> yeah, and the maximum itself, in one pass
16:20:26 <sorear> ooh, 10m, suspicious!
16:20:41 <Pseudonym> I've been here for about that long.
16:20:58 <Pseudonym> Sheesh.
16:22:06 <ddarius> sorear: A later one did.  I gave a straightforward two (three) pass solution earlier.
16:22:07 * Pseudonym msgs lambdabot all the time; it saves having a ghci running
16:23:14 <narain> so has the one-pass solution been given yet?
16:23:22 <ddarius> Saizan: We are not strict in cnt/n.
16:23:23 <tsp> where did the monad tutorial go?
16:23:24 <ddarius> narain: Yes.
16:23:25 <tsp> http://www.lyricsondemand.com/p/plutonsvealyrics/stveltramplyrics.html
16:23:27 <lambdabot> Title: Pluton Svea - Stveltramp Lyrics - Stveltramp - Lyrics On Demand, http://tinyurl.com/yptqe5
16:23:29 <narain> ok then
16:23:32 <tsp> oops, wrong one
16:23:40 <tsp> does he tinyurl stuff by default?
16:24:12 <sorear> @tinurl-off
16:24:12 <lambdabot> Unknown command, try @list
16:24:21 <sorear> @list tinyurl
16:24:22 <lambdabot> No module "tinyurl" loaded
16:24:25 <sorear> @list url
16:24:26 <lambdabot> url provides: url-title tiny-url
16:24:26 <tsp> I want to know wtf that page says anyway :)
16:24:37 <tsp> its all in swedish though
16:24:41 <sorear> @tiny-url off
16:24:42 <lambdabot> Url not valid.
16:24:59 <sorear> @url-off
16:25:00 <lambdabot> Url disabled
16:25:08 <tsp> neat
16:25:10 <sorear> http://www.lyricsondemand.com/p/plutonsvealyrics/stveltramplyrics.html
16:25:19 <sorear> @url-on
16:25:20 <lambdabot> Url enabled
16:25:21 <sorear> http://www.lyricsondemand.com/p/plutonsvealyrics/stveltramplyrics.html
16:25:22 <lambdabot> Title: Pluton Svea - Stveltramp Lyrics - Stveltramp - Lyrics On Demand, http://tinyurl.com/yptqe5
16:25:24 <tsp> you turned off the enitre subsystem
16:25:29 <tsp> ah, same tinyurl
16:25:31 <tsp> neat
16:25:50 <HairyDude> getTimeZone :: UTCTime -> IO TimeZone
16:25:53 <HairyDude> why is that in the IO monad?
16:26:18 <dons> it hsa to call into C.
16:26:18 <sjanssen> @hoogle getTimeZone
16:26:19 <lambdabot> No matches found
16:26:33 <dons> and is it referentially transparent? what if your time zone changes?..
16:26:34 <laziest> because it does not return the same value for same argument
16:26:42 <sjanssen> dons: I found a nasty nasty bug in X11 today
16:26:47 <dons> fixable?
16:26:53 <laziest> it "peeks into the real world"
16:26:58 <sjanssen> if you change the interface, yeah
16:27:12 <dons> sjanssen: i suggest taking over the X11 package :-)
16:27:17 <dons> so what's the bug? does it hurt us?
16:27:40 <sjanssen> refreshKeyboardMapping didn't have a 'Display' argument -- so when Xlib peeks into the struck it dereferences a null (or random) pointer
16:27:42 <HairyDude> seems to me like it just extracts the time zone from a time value. how is that not pure?
16:27:56 <dons> sjanssen: urgh :/
16:28:04 <sjanssen> it's obvious that nobody has ever used it
16:28:13 <dons> HairyDude: ah, so it takes apart a C struct, just getting a field out?
16:28:17 <laziest> HairyDude: a pure function does not depend upon where you are in the world!
16:28:40 <dons> laziest: but doesn't it just extract the 'tz' field from the UTCTime struct?
16:28:53 <sjanssen> dons: do you think anybody would care if I just started pushing patches to X11?
16:29:13 <laziest> UTCTime has tz? let me make sure myself...
16:29:15 <HairyDude> laziest: so suppose I'd used it 5 days earlier, would it return GMT instead of BST?
16:29:22 <sorear> @src UTCTime
16:29:22 <ddarius> @src UTCTime
16:29:22 <lambdabot> Source not found. My mind is going. I can feel it.
16:29:23 <lambdabot> Source not found. My mind is going. I can feel it.
16:29:29 <Igloo> sjanssen: If you mean things like fixing incorrect types, then no
16:29:41 <HairyDude> laziest: yes, that struck me as odd too
16:29:42 <dons> sjanssen: i'd CC. Sven, and libraries@, and say you'd like to take over the package for the next version.
16:30:01 <dons> Igloo: it needs an active maintainer. so sjanssen could start on X11 2.0, with interface changes.
16:30:18 <dons> morning dcoutts
16:30:20 <sorear> hiya
16:30:23 <thedward> I have to say, darcs is the most awesomest revision control program I've used.
16:30:31 <dcoutts> hia dons
16:30:31 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
16:30:41 <Igloo> dons: Sure, but like you say, that sort of thing needs at least a nod from the appropriate people first
16:31:01 <ndm> why not commit a patch that breaks  it entirely
16:31:01 <Igloo> sjanssen: You know about the XCB(?) discussion/plans from a few weeks ago BTW, right?
16:31:03 <dons> yes. you need to get the old maintainer's consent, and just double check on libraries@
16:31:19 <ndm> from that you can deduce the number of users, and then see if you need to tell anyone
16:31:26 <sjanssen> Igloo: that's what I wanted to know.  I'll send an email to libraries before I make any changes
16:32:05 <sjanssen> Igloo: you mean the discussion more than a month ago?
16:32:08 <laziest> HairyDude: sorry I didn't find it in the standard... Is it GHC specific?
16:32:11 <sorear> ndm: I just noticed a flaw in my naming scheme for derivations (eq for Eq, functor for Functor,etc) - try making a derivation for Show... any ideas? (I want consistency)
16:32:16 <Igloo> sjanssen: Perhaps, I have no concept of time
16:32:25 <sjanssen> Igloo: I don't think anything actually came out of that conversation
16:32:28 <HairyDude> laziest: oh, possibly
16:32:30 <sorear> ndm: and I don't want rediculously long names
16:32:34 <ndm> sorear: deriveEq
16:32:54 <HairyDude> I've found getZonedTime now
16:32:58 <sorear> derive deriveEq ... sounds wonderfully pleasant ;)
16:33:08 <laziest> I didnot find it even in System.Time of ghc
16:33:10 <ndm> you have to include the name of the class, and you obviously need a prefix (because of show)
16:33:14 <Igloo> sjanssen: I got the impression the concensus was that XCB was the way to go, so you might be better in the long run using that. But if you want it now, then X11 is obviously your only choice
16:33:17 <ddarius> Igloo: That's what you get for programming in Haskell too long.
16:33:39 <sjanssen> Igloo: I don't suppose you've seen my SoC proposal to write an X library based on XCB? :)
16:33:40 <ndm> derive is the best prefix i can come up with, in fact the only appropriate one i can think of
16:33:42 <laziest> not even getZonedTime!
16:33:43 <HairyDude> which is pure
16:33:52 <laziest> which module?
16:33:54 <HairyDude> laziest: it's Data.Time
16:33:56 <ndm> sorear: makeEq, perhaps?
16:33:58 <dons> Igloo: i think this means you should vote up the XCB binding project ;-)
16:33:59 <laziest> ok... let me check
16:34:04 <ndm> derive makeEq has a slight ring to it
16:34:05 <laziest> oh you said its pure?
16:34:32 * laziest puzzled
16:34:40 <laziest> no Data.Time?
16:34:43 <HairyDude> erm, I mean the timezone-extranction function for ZonedTime is pure, obviously getZonedTime isn't :)
16:34:50 <dons> mmm. has anyone ever played with the intel C compiler with haskell code?
16:34:53 <dons> its rather spiffy.
16:34:55 <HairyDude> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time.html
16:34:57 <lambdabot> http://tinyurl.com/yzllnx
16:35:03 <Igloo> dons: But /I/ don't want either  :-)
16:35:13 <laziest> oh, I must update the libraries it seems...
16:35:23 <dons> Igloo: you don't use xmonad??!
16:35:28 * Igloo can't remember what I actually did rate it, for the record
16:35:34 <augustss> dons: how do you mean?  as a replacement for gcc when using ghc?
16:35:46 <Igloo> Not yet; I plan to take a look some time though
16:35:50 <dons> augustss: yeah. or maybe yhc
16:35:50 <augustss> icc is really good
16:36:00 <dons> augustss: all the lovely probability tags on branches. mmm.
16:36:03 <ndm> dons: what extensions does icc support?
16:36:18 <ndm> dons: specifically i need storing goto labels in variables
16:36:26 <dons> no idea.
16:36:37 <dons> you got a standalone yhc fragment? i could try to compile it?
16:36:39 <ndm> other than that, my C is pretty and requires no manglisation
16:36:40 <augustss> urk.  so unportable
16:36:46 * sorear would be very peeved if ghc stopped supporting free compilers
16:36:46 <thedward> is xcb like a next-generation xlib?
16:36:54 <dons> thedward: yeah
16:36:57 <ndm> augustss: i can fall back to the continuation returning style, but thats yuk too
16:37:01 <dons> sorear: um. unlikely.
16:37:02 <thedward> neat. about time.
16:37:03 <ndm> and slow
16:37:12 <ndm> dons: not around here, might have at work - not sure
16:37:17 <augustss> ndm: do you jump between functions with your stored labels?
16:37:26 <ndm> augustss: one function :)
16:37:30 <sorear> if we must replace GCC, I'd like something other than binary commercial sw to replace it with :(
16:37:45 <augustss> ndm: within one, or to another one?
16:37:53 <sorear> augustss: within one
16:37:58 <dons> sorear: you're getting ahead of yourself
16:38:08 <augustss> ok, so reasonably portable then :)
16:38:12 <ndm> augustss: the whole program gets compiled to one single function (with extra functions for GC etc)
16:38:16 <sorear> augustss: with lots of CPP abuse to hide the fact that the whole program is one functon
16:38:47 <augustss> C compilers don't usually scale well with function size. :(
16:38:48 <sorear> dons: I'm not sure I get that ...
16:38:54 <ndm> 100% portable, i do the function returning when compiling otherwise
16:39:03 <ndm> augustss: i will add SCC to try and split the functions up a bit
16:40:04 <augustss> ndm: that probably works reasonably well.  unless you run into something really nasty higher order,  but that's unlikely to be large
16:40:15 <ndm> augustss: first order only
16:40:26 <ndm> augustss: i have a haskell -> first order translator which is done first
16:40:29 <sorear> ndm: I thought the default case for !GNUC used a giant switch?
16:40:37 <dons> it'd be interesting to pass ghc's unregisterised output into icc.
16:40:40 <sorear> ndm: oh, we're not talking yhi?
16:40:50 <ndm> sorear: yhi, yes, yhcc, no
16:41:05 <sorear> parse error
16:41:10 <augustss> ndm: ok, but you must have some representation of functions in your first order version
16:41:11 <ndm> sorear: that GNUC switch gains not a huge amount - a small bit on every instruction, but not all
16:41:23 <ndm> augustss: not really
16:41:31 <sjanssen> thedward: so you didn't change all of the Int functions in X11, just the ones that xmonad uses?
16:41:33 <ndm> augustss: i have techniques for making them all go away
16:41:51 <ndm> i have functions, but they are all applied with all their arguments every single time
16:41:58 <ndm> so no higher order values
16:42:05 <thedward> sjanssen: I tried to get all of them.
16:42:12 <sorear> augustss: function pointer variables are stored only by encoding them into the instruction pointer
16:42:25 <sorear> augustss: ie, specialization
16:42:43 <sorear> augustss: with magic I don't understand for the non-constant recursive case
16:42:46 <stepcut> dons: is there a way to talk to a currently running hmp3 process and get it to do things, something like "hmp3 --process id --command pause" ?
16:43:11 <thedward> sjanssen: oh. wait. I am kind of dumb.
16:43:20 <LoganCapaldo> stepcut kill -STOP pid ;)
16:43:29 <augustss> ndm: surely, there will be labels, enumeration types, or something that allows you to pass around representations of higher order values
16:43:33 <ndm> sorear: the paper you have is an old version of hte specialisation - works, but the new one is massively faster
16:43:35 <ndm> augustss: no
16:43:37 <thedward> sjanssen: I did all the .hsc files ,but not the .hs files
16:43:38 <stepcut> LoganCapaldo: hrm...
16:43:49 <dons> stepcut: nope. why?
16:43:54 <dons> stepcut: you coudl wrap it i suppose.
16:44:05 <jcreigh> stepcut: mpd can do that sort of thing...
16:44:06 <augustss> ndm: then I'm quite intrigued.  do you have it written up?
16:44:09 <ndm> augustss: i can pass around thunks, but only first order unevaluated thunks
16:44:15 <stepcut> dons: I wanted to use the multimedia keys on my keyboard to control hmp3
16:44:17 <nominolo> how many gcc-specific features does ghc use (apart from the mangler)?
16:44:27 <augustss> ndm: oh, ok thunks
16:44:37 <sorear> global register variables for a start
16:44:38 <dons> stepcut: ah ok. and they are bound to shell commands?
16:44:41 <LoganCapaldo> well my solution only works for pause and play :)
16:44:53 <sorear> killall -9 hmp3
16:44:55 <LoganCapaldo> and play only when the pausing mechanism was SIGSTOP :)
16:45:15 <ndm> augustss: but first order thunks, still a first order language - thunks only for laziness
16:45:23 <stepcut> dons: essentially, yes.
16:45:31 <ndm> augustss: i have a few pages on it in my draft ICFP paper, i can send you that if you want
16:45:45 <augustss> ndm: please do
16:45:56 <stepcut> dons: There are just keys -- so you have to have something that responds to the keys and runs the shell commands (for example, xmonad)
16:46:04 * nominolo liked the passage in the Data Parallel Haskell report, that the code compiled with the better compiler was 4x(!) faster
16:46:13 <augustss> ndm: so your firstification is different from what has been done in the past?
16:46:26 <sorear> @botsnack
16:46:26 <sorear> damn connection
16:46:27 <lambdabot> :)
16:46:28 <ndm> augustss: compared to Reynolds firstification, yes
16:46:34 <ndm> augustss: its possible you know of something i don't
16:47:02 <augustss> well, there's the GRIN stuff
16:47:16 <ndm> thats just encoding to a data type, i think
16:47:18 <sorear> I already pointed ndm to that
16:47:30 <nominolo> GRIN is evil
16:47:31 <ndm> and then hoping the data type disappears separately
16:47:36 <augustss> ndm: or possibly many types
16:47:46 <ddarius_> ndm: Paper?
16:47:52 <nominolo> whole-program optimazation is evil, for that matter
16:48:01 <LoganCapaldo> what about SMILE?
16:48:02 <jcreigh> stepcut: http://www.musicpd.org/
16:48:02 <sorear> optimazing!
16:48:04 <lambdabot> Title: MPD: Music Player Daemon
16:48:06 <LoganCapaldo> or SMIRK?
16:48:08 <stepcut> dons: another solution would be if xmonad could redirect specific keys to a specific application, even if it is on another screen, etc, but making a command-line tool that can drive hmp3 remotely would make it easier for non-xmonad (l)users
16:48:09 <ndm> ddarius_: email address?
16:48:15 <sjanssen> thedward: I still see some in Graphics.X11.Xlib.{Display, Image, Region, Screen, Window}
16:48:17 <jcreigh> stepcut: then you just bind your multimedia keys to "mpc play", "mpc next", "mpc stop", etc.
16:48:20 <ndm> nominolo: no it isn't, linking is a whole program optimisation
16:48:23 <ddarius_> derek.a.elkins at gmail.com
16:48:24 <augustss> nominolo: while program optimization is evil if there is no esacpe hatch :)
16:48:34 <ndm> nominolo: i have whole program optimisations that compile faster than a normal GHC compiler
16:48:39 <augustss> s/while/whole/
16:48:51 <sjanssen> thedward: I'm not saying you need to go and fix those, I'm just evaluating what might need to be done before we could make a new X11 release
16:49:04 <nominolo> ndm: i tried jhc and it ate up 1GB of ram and then became incredibly slow
16:49:10 <augustss> ndm: whole program optimizers tend to scale badly
16:49:13 <nominolo> i couldn't even compiler the prelude
16:49:16 <sorear> GCC in wpo mode runs two orders of magnitude slower than GHC
16:49:20 <ndm> nominolo: thats jhc, not a whole program optimiser
16:49:33 <stepcut> jcreigh: hrm, but I like hmp3...
16:49:37 <nominolo> ndm: that's the whole-program register allocator
16:49:38 <ndm> augustss: i know :) - i'm hoping to write one which is O(n), which should scale much better
16:49:41 <sorear> nominolo: JohnMeacham can't be bothered to fix jhc, since it's a free time project and he has infinite ram and CPU
16:50:02 <nominolo> sorear: infinite RAM?
16:50:03 <ndm> sorear: where do you get infinite ram and CPU?
16:50:04 <augustss> ndm: I approve of O(n), but O(n log n) is ok too :)
16:50:13 <ndm> (i was going to get an upgrade)
16:50:26 <sjanssen> sorear: then we should all mail our programs to JohnMeacham, and he can return object code
16:50:50 <procyon112> @seen dons
16:50:51 <lambdabot> dons is in #haskell-soc, #haskell-overflow and #haskell. I last heard dons speak 6m 11s ago.
16:50:54 <nominolo> ndm: how do you try to get well-performing O(n) reg-alloc?
16:50:58 <sorear> Not sure, but he assures me in email that if anyone ever actually tried to optimize jhc it would become many times faster with almost zero effort.
16:51:12 <thedward> sjanssen: Yeah. I for some reason skipped the .hs files.
16:51:13 <ndm> nominolo: reg allocation is something i've not got to yet, and probably never will - its a Core optimiser
16:51:17 <procyon112> How many lines can hpaste hold these days?
16:51:22 <sorear> 5000ch
16:51:31 <procyon112> thx
16:51:38 <sorear> talk to glguy, it was his (IMO stupid) idea to add a cap
16:51:52 <sjanssen> there has to be *some* kind of cap
16:51:59 <stepcut> perhaps you max lines should be tied into your karma rating ?
16:52:01 <nominolo> ndm: linear-scan is fast, but I'm not sure how well it performs for Haskell programs
16:52:03 <procyon112> hehe.  *some* cap is usefull.. in case of spammers.
16:52:05 <stepcut> s/you/your/
16:52:10 <sorear> we can already delete pastes!
16:52:16 <nominolo> ndm: for one, it needs linearization
16:52:18 <sorear> we don't need preemptive measures!
16:52:24 <sjanssen> otherwise I'm gone to hpaste copies of my DVDs
16:52:29 <procyon112> lol
16:52:36 <augustss> mmmmmm, free infinite storage!
16:52:46 <augustss> lemme start copying!
16:52:58 <stepcut> augustss: yahoo has unlimited email storage now ...
16:53:13 <sjanssen> I suppose I could chop them into 5k bits with the current hpaste anyway
16:53:19 <thedward> sjanssen: I wouldn't mind doing some more search and replace for this stuff.
16:53:30 <sorear> If you do that we'll figure out how to have hpaste hijack your nick ... you're pretty much the only two who are id'd
16:53:38 <stepcut> sjanssen: I think hpaste ultimately limits you to the amount of virtual memory on the system :p
16:53:43 <Pseudonym> stepcut: Yeah, I think yahoo is outsourced its email storage to the Chinese government.
16:53:56 <sorear> don't try to incite retribution it you don't use security
16:53:57 <augustss> stepcut: I wouldn't be surprised if it's like the guy who had unlimited downloads with his ISP.  but then shut down his connection when he exceeded his monthly quota
16:54:10 <stepcut> heh
16:54:38 <stepcut> yeah, cox has 'unlimited high-speed internet', but they disconnected me for uploading more than 5GB in a month once
16:54:47 <sorear> @remember Pseudonym I think yahoo is [sic] outsourced its email storage to the Chinese government.
16:54:48 <lambdabot> Done.
16:55:04 <Pseudonym> Bleah.
16:55:09 <Pseudonym> At least let me retype it. :-)
16:56:09 <LoganCapaldo> @forget Pseudonym I think yahoo is [sic] outsourced its email storage to the Chinese government.
16:56:10 <lambdabot> Unknown command, try @list
16:56:21 <LoganCapaldo> lambdabot has a perfect memory
16:56:28 <sorear> yeah right
16:56:31 <Pseudonym> stepcut: Yeah, I think yahoo outsourced its "unlimited" email storage to the Chinese government.
16:56:36 <sorear> @karma sorear -- was 40
16:56:37 <Pseudonym> Better?
16:56:37 <lambdabot> You have a karma of 27
16:56:44 <augustss> ndm: don't forget to send me your paper.  or a link :)
16:57:03 <ndm> augustss: just hit the send button - compiling a latex document on this machine takes forever...
16:57:17 <ndm> augustss: its being submitted to ICFP, so if you have any comments before the deadline ;)
16:57:25 <sorear> @quote AM.*spineless
16:57:26 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
16:57:31 <sorear> I quoted that!
16:57:45 <sorear> @where nobench
16:57:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/nobench.html
16:57:48 <augustss> ndm: ok, i'll have a look.  it will take half an hour for the email to get through my grey filter
16:57:55 <sorear> wow, it finally remembered that!
16:58:04 <sorear> forgot it like 5 times
16:58:07 <sjanssen> sorear: write a program to scan the logs and correct lb's state
16:58:29 <sorear> sjanssen: Some people change lb's state in msg
16:58:48 <sorear> sjanssen: dons has logs of everything /msg'd, but won't publish them for some reason
16:59:08 <sjanssen> I'd say that's reasonable
16:59:23 <LoganCapaldo> It would be embarassing to see all the foolish things I msg lambdabot :)
16:59:25 <dons> yeah, cause i'm with the stasi.
16:59:38 <sorear> @all-dicts stasi
16:59:40 <lambdabot> No match for "stasi".
17:00:02 <sjanssen> state police in East Germany, IIRC
17:00:14 <int-e> g.d.r.
17:00:16 <int-e> please :)
17:00:20 <sorear> ?
17:00:27 <dons> sorear: before your time, I think :-)
17:00:43 <sjanssen> int-e: yes, that is certainly more correct
17:01:26 <LoganCapaldo> In soviet germany, /msg's log you
17:01:40 <Pseudonym> "Stasi" is one of those totalitarian partial-acronyms, like "miniluv", "gestapo" or "politburo".
17:01:51 <Pseudonym> Democracies use real acronyms.
17:01:52 <sjanssen> int-e: are you German?  Does that annoy Germans?
17:02:08 <Pseudonym> No, if he was German, it would be DDR.
17:02:37 <sjanssen> in an English speaking context?
17:02:50 <nominolo> Pseudonym: he was just noticing that it's not the _current_ state police ;)
17:02:52 <int-e> sjanssen: not much. the difference is that 'East Germany' still applies to the east part of Germany.
17:02:53 <Pseudonym> Well if you're going to be anal about East Germany -> GDR...
17:03:10 <Pseudonym> How about we just call it Ossiland.
17:03:37 <int-e> sjanssen: well. I'
17:03:44 <int-e> sjanssen: I'm young enough to not care.
17:04:32 <dons> int-e: hey, btw, you interested in being a SoC mentor this year?
17:04:34 <sjanssen> int-e: right, I'm just curious whether I'd tripped over a common annoyance
17:04:34 * sorear is young enough to not have known that GDR refers to communist east germany, *fear*
17:04:38 <int-e> Pseudonym: go ahead. you shouldn't expect anyone to take you seriously though. :)
17:05:07 <Pseudonym> Is it true that "Ossi" is a term of semi-abuse for anyone born east of the Elbe?
17:05:24 * Pseudonym tries to recall
17:05:25 <sjanssen> sorear: they don't cover history after 1950 in your school?
17:05:34 <vincenz> any good way to debug haskell code?
17:05:38 <nominolo> Pseudonym: yes, oppositte is "Wessi"
17:05:40 <int-e> I think it applies to all of the former GDR.
17:05:41 <vincenz> I'm getting an error due to Array.! but no clue as to where
17:05:43 <ndm> vincenz: do you pray?
17:05:48 * int-e shrugs.
17:05:54 <Botje> Debug.Trace!
17:05:56 <Pseudonym> I'm old enough that I was actuall doing a German class at school when the Iron Curtain started to metaphorically crumble.
17:05:58 <nominolo> Pseudonym: then there's "Wossi" for anything in between ;)
17:06:03 <sorear> I know about communist east germany.  I just never realized it had an acronym...
17:06:03 <ndm> vincenz: my Safe library is handy for that kind of thing, Hat-stack would be perfect, Yhc-Stack sometimes works
17:06:06 <Pseudonym> Right. :-)
17:06:10 <dons> vincenz: you could compile with -prof and see where the top of the stack is when it fails
17:06:20 <vincenz> dons: how exactly?
17:06:21 <Pseudonym> sorear: Most countries have a full name.
17:06:28 <vincenz> dons: how do you see the top of the tack?
17:06:33 <vincenz> ndm: does it handle GADTs ?
17:06:37 <Pseudonym> We just say "China" when we mean "People's Republic of China".
17:06:38 <dons> -prof -auto-all to compile, then run with +RTS -p
17:06:40 <Pseudonym> Or PRC for short.
17:06:43 <ndm> vincenz: we're waiting on your patch for that ;)
17:06:44 <dons> and inspect the .prof file
17:06:44 <Pseudonym> This is much the same.
17:06:45 <vincenz> dons: cool, thx
17:07:02 <sjanssen> Pseudonym: be careful, you'll cause an international incident if you admit there's more than one China
17:07:03 <Pseudonym> DDR == Deutsche Demokratische Republik or something.
17:07:23 <int-e> Pseudonym: right
17:07:24 <Pseudonym> sjanssen: Well there's only one Australia, but it has a full name, "Commonwealth of Australia".
17:07:39 <nominolo> Pseudonym: correct
17:07:41 * Pseudonym is not saying anything about how many Chinas there are
17:08:02 <nominolo> do thay all have 1 billion inhabitants?
17:08:07 <sorear> There are as many chinas as you want.
17:08:10 <nominolo> *they
17:08:13 <int-e> anyway I just wanted to clarify the historical context. :)
17:08:18 <Pseudonym> Thansk, int-e and nominolo.  Just checking that I spelled it correctly.
17:08:19 <sorear> Considering that it is also a kind of ceramic :)
17:08:28 <ndm> Pseudonym: i prefer "The UK's Commonwealth of Australia" ;-)
17:08:38 <Pseudonym> ndm: Not true as of 1896.
17:08:41 <Pseudonym> 1986
17:08:56 * dons kicks ndm
17:09:11 * ndm deserved that, but did include a smilie ;-)
17:09:18 <vincenz> yeah
17:09:19 <Pseudonym> Australia is officially an independent nation.  As of 21 odd years ago.
17:09:26 <vincenz> and the UK's commonwealth of the america
17:09:31 <ndm> (and was joking, the UK do a rasonably bad job of controlling countries)
17:09:32 <vincenz> Pseudonym: that's not long ago
17:09:33 <vincenz> damn
17:09:35 <dcoutts> ndm: aye, don't give the brits a bad name over here (at least while I'm here!)
17:09:38 <vincenz> I'm older than Australia!
17:09:43 <Pseudonym> Australia is older.
17:09:45 <vincenz> dons: so you were born english?
17:09:50 <Pseudonym> Australia dates back to 1901.
17:10:12 * LoganCapaldo is pretty sure australia existed before 1901
17:10:12 <Pseudonym> But it wasn't until 1986 that it officially was no longer a British colony.
17:10:25 <dons> vincenz: nope. but i probably could hvae run for UK parliament, iirc.
17:11:03 <nominolo> dons: hey, that would be cool.  a haskell programmer as PM ..
17:11:18 <sorear> Australia has probably existed in its present form for hundreds of millions of years.
17:11:27 <Pseudonym> http://www.cs.uwaterloo.ca/journals/JIS/happy.html  -- Only John Horton Conway could get away with the last sentence in this paper.
17:11:28 <dons> heh. "lambdas for all" is my platform!
17:11:28 <lambdabot> Title: On Happy Factorizations
17:11:53 <sorear> nominolo: (You probably knew this, but) MP does not necessarily imply PM.
17:12:00 <Igloo> That's what he says now, but 2 months into his term and you can be sure there'll be a 10% tax on all lambdas
17:12:16 <dcoutts> dons: I dunno, rules work better with combinator form, giving everyone lambdas might make them hard to control :-)
17:12:19 <dons> oh, i note in the tv show 'medium' last night, the engineer husband of the arquette character was working on "a haskell project"
17:12:25 <LoganCapaldo> no lambda taxation without eta-reduction!
17:12:31 <Igloo> dons: Woah
17:12:35 <Pseudonym> Woo!
17:12:46 <Pseudonym> Haskell has officially crossed over from reality to fantasy!
17:12:47 <nominolo> sorear: no, i didn't know that.
17:12:49 <dons> so he's a defence/aerospace/computer something guy.
17:12:49 <Igloo> You sure you didn't mishear "Pascal project"?  :-)
17:12:58 <sorear> Oh no.
17:13:11 <dons> well, it was "haskell". but whether that's what we think it is.
17:13:12 <sorear> The unwashed masses know we exist.
17:13:17 <dons> maybe they have really good researchers ?
17:13:27 <LoganCapaldo> or really bad reasearchers?
17:13:30 <dons> i wonder if we can get a transcript. hmm.
17:13:32 * sorear sets up fortifications
17:14:19 <dons> i was shocked actually.
17:14:22 <augustss> The Haskell Vineyards!
17:14:23 <sorear> ndm: derive "Eq" makes a pretty bogus context...
17:14:45 <ndm> sorear: how do you mean?
17:15:03 <sorear> data Foo a b = Foo a
17:15:09 <sorear> will reqire a Eq for b
17:15:11 <augustss> http://www.haskellvineyards.com/
17:15:13 <lambdabot> Title: Haskell Vineyards - Fine wine and winemakers
17:15:16 <sorear> etc etc
17:15:59 <sorear> given the restrictions on the form of instances, this might not be possible to fix without scope resolution...
17:16:01 <ndm> sorear: feel free to fix it up, what i have is conservative though?
17:16:24 <sorear> no :(
17:16:38 <sorear> data Foo a = ...   instance (Show a) => Eq (Foo a)
17:16:41 <sjanssen> dons: do you know which episode it is?
17:16:45 <sorear> data Bar a = Bar (Foo a)
17:16:57 <sorear> you'll make instance (Eq a) => Eq (Bar a)
17:17:09 <sorear> but we need instance (Show a) => Eq (Bar a)
17:17:14 <Pseudonym> There you go.  There's a cinematographer/director named Haskell Wexler who directed a film in the 60s named "Medium Cool".
17:17:19 <Pseudonym> See what you learn when you randomly google?
17:17:22 <ndm> sorear: its sensible enough to do what we do, i think, but if you can improve it
17:17:43 <ndm> sorear: perhaps Eq (Foo a) => Eq (Bar a) ?
17:17:48 <sorear> I wonder what drift does
17:17:49 <dons> sjanssen: episode with the evil doll that tells children to kill
17:17:54 <sorear> ndm: that's illegal
17:18:10 <Pseudonym> The episode is called "Very Merry Maggie".
17:18:15 <sorear> ndm: must be Eq (tyvar type*)
17:18:32 <ndm> sorear: can we do any better than we do now?
17:18:35 <sorear> class tyvar | class (tyvar type+) actually
17:18:44 <dons> Pseudonym: yeah. that's it.
17:18:49 <sorear> ndm: yes, with an unreasonable amount of work
17:19:17 <ndm> sorear: i would have thought we capture the common case, but if you can get the correct case working, that would be great
17:19:34 <sorear> Ok. As long as the problem is known...
17:19:46 <sorear> I'm still checking DrIFT's behavior fwiw
17:19:58 <tsp> did anyone manage to get the bytestring line squeezing solved?
17:20:12 <dcoutts> tsp: sorry, no time to look at that
17:20:17 <sjanssen> tsp: which line squeezing?
17:20:22 * nominolo waits for when Haskell is mentioned on Numb3r
17:20:25 <ndm> sorear: wasn't know, but not massively surprising either - if you find a sensible place to document it
17:20:26 <nominolo> +s
17:20:27 <dcoutts> tsp: if you or anyone else have a fix we'll look at it
17:20:38 <tsp> heh, I can't code :)
17:20:53 <dcoutts> tsp: I recall some other people had suggestions
17:21:02 <LoganCapaldo> What is line squeezing?
17:21:04 <tsp> sjanssen: basically if you use the bytestring lines function, it squishes blank lines
17:21:05 <dons> nominolo: when the credits change to say "hask3ll", and include the phrase "we all use haskell every day. its all around us" eh?
17:21:13 <sorear> nominolo: Everything I've seen on that show so far has been 100% bogus.  I do not want haskell bogus by affiliation.
17:21:28 <Pseudonym> sorear: Dude, it's a fantasy show.
17:21:43 <Pseudonym> I bet you thought "Fargo" was based on a true story just because a caption said it was, too.
17:21:53 <sorear> never saw it...
17:21:58 <LoganCapaldo> Fargo was a lie!?!?!?!!!?
17:22:06 <ndm> Pseudonym: did you see the story of the girl who thought it was?
17:22:14 <Pseudonym> No.
17:22:14 * LoganCapaldo weeps unconsolably 
17:22:23 <ndm> Pseudonym: was not a happy story...
17:22:24 <sjanssen> tsp: I think there's an alternative lines function -- something like lines' ?
17:22:41 <nominolo> sorear: well, mostly it wasn't *that* hillarious.  But when they solved a hostage situation useing *UML-State-Diagrams*(!!) I had to LOL
17:23:00 <tsp> hmm
17:23:06 <Pseudonym> LOL!
17:23:12 <Pseudonym> It reminds me of that xkcd comic.
17:23:44 <Pseudonym> http://xkcd.com/c208.html  <- Could be from Numb3rs.
17:23:46 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
17:24:07 <sorear> ndm: Drift does the same bogus thing.
17:24:10 <LoganCapaldo> thanks fo reminding me to check xkcd
17:24:52 <hpaste>  Procyon112 annotated "Evaluator" with "Evaluator" at http://hpaste.org/1174#a1
17:24:59 <ddarius_> Pseudonym: That was underwhelming.
17:25:27 <Pseudonym> ddarius: It's hilarious if you've seen enough Numb3rs.
17:25:35 <procyon112> Is ^^^ my code messy, or is it just me?
17:25:46 <ddarius> I think I've seen 5 seconds of one episode... maybe... ?
17:25:55 <sorear> I stopped watching when the told me combinatory logic involved angles.
17:26:32 <int-e> hmm, there's a W-combinator, that has three angles.
17:26:33 <Pseudonym> procyon: Just a suggestion, but your unification algorithm might benefit from using the Maybe monad.
17:26:38 <ddarius> Pseudonym: But I was hoping for something more like 'factorization of monads' or something way out there.
17:27:04 <procyon112> Pseudonym:  Umm.. I thought I was using the Maybe monad
17:27:13 <ddarius> An occurs check!
17:27:23 <Pseudonym> procyon: Example:
17:27:28 <Pseudonym> = case (foo) of
17:27:35 <Pseudonym>     (Just x) -> Just (f x)
17:27:39 <nominolo> :t occursIn
17:27:39 <ddarius> @oldwiki NotJustMaybe
17:27:40 <lambdabot> http://www.haskell.org/hawiki/NotJustMaybe
17:27:40 <Pseudonym>     Nothing -> Nothing
17:27:41 <lambdabot> Not in scope: `occursIn'
17:27:46 <Pseudonym> Is better expressed as:
17:27:48 <Pseudonym> = do
17:27:53 <Pseudonym>     x <- foo
17:27:56 <ddarius> fmap f foo
17:27:58 <Pseudonym>     return (f x)
17:28:01 <Pseudonym> Or fmap, yes.
17:28:03 <sorear> foo >>$ f
17:28:15 <nominolo> :t (>>$)
17:28:18 <lambdabot> Not in scope: `>>$'
17:28:18 <Pseudonym> The do-notation gives you better layout if f is complex.
17:28:20 <sorear> >>$ = flip fmap, my favorite non-standard combinator
17:28:37 <nominolo> looks .. perlish ..
17:28:40 <Pseudonym> :t flip fmap
17:28:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
17:28:47 <Pseudonym> ?hoogle (Functor f) => f a -> (a -> b) -> f b
17:28:48 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
17:28:49 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
17:28:49 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
17:29:11 <nominolo> why that "$"?
17:29:17 <procyon112> Pseudonym: awesome.  Thanks... I'll try that
17:29:25 <sorear> nominolo: it works on functions?
17:29:38 <nominolo> hm
17:30:02 <sorear> procyon112: you should check out the ST monad - it could make the code much simpler
17:30:11 <nominolo> i guess i have to browse some more functor stuff.
17:30:19 <nominolo> but not today
17:30:51 <sorear> procyon112: or just use IO + unsafePerformIO - slightly less clean, but less confusing type error messages :)
17:30:56 <sorear> @quote formatt
17:30:57 <lambdabot> <skew> says: also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
17:31:11 <narain> > (+1) `fmap` Just 42
17:31:11 <procyon112> I'm sure this code could be simplified to about 10 lines by any non-N00b Haskeller, unlike myself :/
17:31:12 <lambdabot>  Just 43
17:32:12 <Pseudonym> procyon: Once you've done that, you can use NotJustMaybe.
17:32:14 <nominolo> procyon112: you'll grow into it
17:32:17 <tsp> > let s = "   test   " in reverse s
17:32:19 <lambdabot>  "   tset   "
17:32:21 <tsp> neat
17:32:22 <Pseudonym> And replace all invocations of "Nothing" to fail.
17:32:33 <tsp> > let s = "   test   " in strip s
17:32:34 <lambdabot>   Not in scope: `strip'
17:32:37 <Pseudonym> That way, you can drop-in a replacement monad and you've got real type error messages.
17:32:43 <tsp> is there no function that will strip spaces?
17:32:46 <sorear> runST!!
17:32:56 <sjanssen> @hoogle isSpace
17:32:57 <lambdabot> Char.isSpace :: Char -> Bool
17:33:00 <sorear> > let s = "   test   " in filter (not . isSpace) s
17:33:02 <lambdabot>  "test"
17:33:11 <Pseudonym> The catch is that you need a monad that has catchable failure.
17:33:19 <Pseudonym> a.k.a. negation-as-failure
17:33:26 <tsp> hmm, I heard osmething about a dropWhile on here
17:33:30 <tsp> :t dropWhile
17:33:32 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:33:46 <tsp> ah, strings are just lists of chars... I think I have an idea
17:33:47 <sjanssen> tsp: use sorear's suggestion
17:34:06 <tsp> sorear: that won't work if the strings is "this is a test   " though
17:34:08 <sorear> Note that my suggestion will also strip spaces in the middle of your string
17:34:12 <sjanssen> > filter (not . isSpace) "t s c"
17:34:13 <tsp> heh
17:34:14 <lambdabot>  "tsc"
17:34:15 <sorear> which might not be what you want.
17:34:21 <tsp> lets try something
17:34:45 <tsp> > let s = "   blah   " in dropwhile isSpace s
17:34:46 <lambdabot>   Not in scope: `dropwhile'
17:34:52 <tsp> ah, it doesn't exist afterall
17:34:52 <sorear> If you want to preserve internal spaces, get MissingH
17:34:57 <sjanssen> > dropWhile isSpace "    tsc   " -- to kill the spaces in the front
17:34:58 <sorear> @where missingh
17:34:58 <lambdabot> http://software.complete.org/missingh
17:34:59 <lambdabot>  "tsc   "
17:35:04 <nominolo> > let dr = dropWhile isSpace in (reverse . dr . reverse . dr) "  foo bar  "
17:35:05 <lambdabot>  "foo bar"
17:35:13 <sorear> tsp: dropwhile doesn't exist. dropWhile does.
17:35:19 <tsp> ah, case
17:35:30 <sorear> tsp: there is an entrenched tradition of camelCase here
17:35:47 * sorear uses _ whenever he can get away with it, i.e. not group projects
17:35:55 <tsp> ah, camelCase. got it.
17:35:59 <tsp> easier on the ears
17:36:04 <thedward> sjanssen: I don't think a simple search and replace is going to do it for the rest of things. Would it make sense to rename the ffi function foo too fooC, then write a wrapper function foo that calls fooC with fromIntegral as appropriate?
17:36:19 <tsp> I still don't get the x . y . z thing - that's gonna be the death of me
17:36:28 <sorear> composition
17:36:34 <sorear> @unpl x . y . z
17:36:35 <lambdabot> (\ c -> x (y (z c)))
17:36:38 <nominolo> tsp it's like inversed unix pipes
17:36:46 <tsp> ah
17:37:09 <sjanssen> thedward: what's preventing a search and replace?
17:37:23 <tsp> one thing I can say about haskell is it has a supportive user community
17:37:31 <Pseudonym> tsp: You suck.
17:37:37 <tsp> Pseudonym: lol
17:37:46 <tsp> Pseudonym: cxu vi sucxas?
17:37:50 <tsp> Pseudonym: just say jes
17:37:57 <thedward> sjanssen: It would break existing code. (xmonad for example)
17:38:20 <thedward> xmonad could be fixed, of course, but I'm not sure how many things it would break.
17:38:47 <ddarius> procyon112: There is a "library" for typed logic variables that is quicker and cleaner than what you are doing.
17:38:51 <Pseudonym> Mi se suxcas, smegakapon!
17:38:52 <sjanssen> thedward: yeah, that's true.  In a recent libraries@haskell.org discussion, I got the impression that X11 doesn't have a ton of users
17:39:09 <Pseudonym> Mi NE suxcas, smegakapon.
17:39:10 <thedward> sjanssen: all the same, if I can avoid breaking it while making it safer...
17:39:16 <tsp> close enough
17:39:20 <sjanssen> thedward: so it is probably okay to just change those, and bump the version number to 2.0
17:39:23 <tsp> heh
17:39:59 <procyon112> Pseudonym: I'm not too worried about real type errors, as this is not going to be used for humans ;)
17:41:09 <procyon112> Pseudonym:  My next step is, given a non terminal node, filter the primitives for a list of all primitives that will typecheck if made children of the node.
17:41:10 <thedward> sjanssen: Is it really desirable though to use CInt from outside the library code?
17:41:10 <vincenz> @hoogle bind
17:41:11 <lambdabot> Network.Socket.bindSocket :: Socket -> SockAddr -> IO ()
17:41:11 <lambdabot> Language.Haskell.TH.bindS :: PatQ -> ExpQ -> StmtQ
17:41:11 <lambdabot> System.Console.Readline.bindKey :: Char -> Callback -> IO ()
17:41:34 <Pseudonym> procyon112: Sounds like you actually want a nondeterminism monad, then.
17:42:26 <sjanssen> thedward: I don't think there is a sound alternative.  Using Int and potentially converting to a smaller CInt internally isn't any better IMO
17:42:26 <procyon112> ddarius: What is this library, and can it do the filter I just described.  I need it to NOT resort to using underlying haskell types because I want to select functions from a list based on whether the resulting AST will typecheck.
17:43:10 <sorear> procyon112: you might want to look at explicitly typed calculi
17:43:25 <sorear> procyon112: System F can be checked in like five lines of code
17:43:44 <sorear> procyon112: it can express everything HM can, and more (e.g rank2 types)
17:44:24 <sjanssen> thedward: what does this XSERVER64 stuff do?
17:44:48 <Jonsaveslives> hi there... I was wondering if I were to have mode1 :: [Int] -> Maybe Int            how would I implement this in to a prop_test?
17:44:59 <ddarius> procyon112: It simply is a library that provides typed logic variables.  You should just be able to change the TVar case to hold a logic variable.
17:45:18 <ddarius> @google "Typed Logic Variable in Haskell"
17:45:19 <lambdabot> No Result Found.
17:45:21 <sorear> Jonsaveslives: not sure wha you mean
17:45:31 <ddarius> @google "Typed Logic Variables" Haskell
17:45:33 <lambdabot> http://tunes.org/~nef/logs/haskell/05.03.31
17:45:40 <ddarius> Give me a sec
17:45:43 <procyon112> sorear: But system F can't reconstruct types.  I need full reconstruction from no annotations.
17:45:49 <sorear> procyon112: why?
17:46:00 <ddarius> @google "Typed Logical Variables"
17:46:02 <procyon112> sorear: *I think* I do anyway ;)
17:46:03 <sorear> procyon112: just treat annotations as a type of note
17:46:04 <lambdabot> http://citeseer.ist.psu.edu/claessen00typed.html
17:46:05 <lambdabot> Title: Typed Logical Variables in Haskell - Claessen, Ljungl (ResearchIndex)
17:46:09 <sorear> s/note/node/
17:46:09 <Jonsaveslives> mode1 :: [Int] -> Int    i.e.  prop_mode1 = mode1 ([1,2,3]) == Nothing
17:46:15 <Jonsaveslives> i dont think thats right though
17:46:24 <thedward> sjanssen: it enables the flag the X includes use for 64-bit systems; It makes the types hsc2hs produces do the right thing.
17:46:30 <sorear> Jonsaveslives: that will work
17:46:42 <sorear> Jonsaveslives: I assume you're using QC?
17:46:44 <ddarius> procyon112: If there is not an example involving unification in that paper and associated code I can provide one.
17:47:05 <Jonsaveslives> sorear: QC?
17:47:17 <sorear> uick heck, sorry
17:47:44 <ddarius> sorear: Int /= Maybe a for any a.
17:47:56 * sjanssen hates Xlib
17:48:24 <sorear> ddarius: This preposition is true, and as far as I can tell, completely irrelevant.  Please elaborate.
17:48:39 <sioraiocht> @type Control.Concurrent.newTVar
17:48:42 <lambdabot> Not in scope: `Control.Concurrent.newTVar'
17:48:55 <ddarius> [19:43] <Jonsaveslives> mode1 :: [Int] -> Int    i.e.  prop_mode1 = mode1 ([1,2,3]) == Nothing
17:49:13 <sorear> ddarius: get a better client
17:49:19 <sorear> <*Jonsaveslives> hi there... I was wondering if I were to have mode1 :: [Int] ->
17:49:19 <sorear>                 Maybe Int            how would I implement this in to a
17:49:23 <vincenz> @hoogle [(a,b)] -> ([a],[b])
17:49:24 <ddarius> Ah, he changed it from above.
17:49:24 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
17:49:43 <thedward> sjanssen: well, I've got all the other Ints done away with. I didn't touch comments or any docs.
17:49:45 <vincenz> @type unzipM
17:49:48 <lambdabot> Not in scope: `unzipM'
17:49:54 <ddarius> sorear: But both lines were said, my client had nothing to do with it.
17:49:55 <sorear> @ty mapAndUnzipM
17:49:58 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c])
17:49:59 <procyon112> ddarius++ Pseudonym++ sorear++
17:50:09 <sorear> ddarius: I see the line you mention now :)
17:51:30 <procyon112> ddarius: I will read that, but I'm not sure If I will grok it all.  This is the first time I have written a typechecker that actually *works*.  Too much more stress on my brain at this juncture and I'll brak something :)
17:52:12 <sorear> procyon112: you already have "brak"ed something I see :)
17:52:17 <procyon112> lol
17:52:30 <ddarius> procyon112: Have you ever programmed in Prolog or a similar logic language? -Or- do you have a good handle on the unification algorithm you use?
17:53:15 <procyon112> no and no.  I understand the concept of the unification algorithm, and I wrote this one with much anguish and gnashing of teeth.
17:53:49 <ddarius> procyon112: So you have a decent handle on unification in general, not so much this particular implementation.
17:53:57 <procyon112> I was absolutely shocked that it works
17:54:22 <sorear> @quote type.?checked
17:54:23 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
17:56:14 <DukeDave> Haha, that's priceless
17:56:37 <ddarius> Hmm, with sufficiently rich types, programming is simply satisfying the type checker.
17:57:15 <DukeDave> reminds me of a friends lecturer's favourite say: "Remember, if it doesn't compile that means there's something *wrong*, it's not the start of the 'beat the compiler' game"
17:57:15 <DukeDave> :)
17:57:21 <DukeDave> *saying
17:57:30 <procyon112> The way I see unification:  Given a list of Constraints: Xn=Yn, made up of variables: a,b,c..., move all the variables to the left hand side of the constraints: a=Yn.
17:58:09 <sjanssen> DukeDave: that's a good one.  I'll have to use that on some of my friends
17:59:17 <procyon112> ddarius: but really, unification has yet to "gel" in my brain.
17:59:55 <ddarius> Hmm, the way I see unification: Given a diagram, find it's limit.  Seriously though, I just think of it as a two way pattern matching/constraint assertion.
18:00:05 <vincenz> @hoogle fromRight
18:00:05 <lambdabot> No matches found
18:00:12 <vincenz> @hoogle Either a b -> b
18:00:12 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
18:00:17 <ddarius> procyon112: Start learning Prolog.
18:00:43 <sorear> I don't grok unification.  My type checker is unidirectional.
18:01:03 <sorear> IE, the type of (x y) is computed as a function of type of x and type of y.
18:01:26 <sorear> Unification is used, but in an amazingly restricted way.
18:01:45 <ddarius> Elaborate "amazingly restricted"
18:02:16 <sorear> Unify FUNARG and PASSEDARG in FUNRET
18:04:04 <procyon112> ddarius: I'm still learning Haskell!!  Prolog's on the list.  Unfortunately, my chosen project to teach myself Haskell would seem much more suited to me if I knew Prolog. :/
18:04:34 <ddarius> procyon112: Then use it as a Prolog project.  You can learn both at the same time.
18:04:35 <sorear> I have a wonderfully clever way to tc let x = y in z and \x -> y
18:04:45 <sioraiocht> question about GHC -- is the code it produces bytecode and an embedded interpreter?
18:05:00 <sorear> if --interactive, yes
18:05:02 <ddarius> sorear: For that's about the only place you need unification in the more or less typical HM inference.
18:05:09 <sorear> otherise, native code
18:05:17 <sioraiocht> sorear: how does it perform GC, then?
18:05:25 <sorear> sioraiocht: natively!
18:05:53 <sorear> sioraiocht: it has a set of conventions which allow pointers to be id'd, and obeys them in the code generator.
18:05:58 <ddarius> procyon112: The big ideas of Prolog are pretty simple.  Learning to become proficient in "real" Prolog is more of a challenge and not really worth it in my opinion.
18:06:01 <sioraiocht> thanks =)
18:06:02 <ddarius> Prolog is ugly.
18:06:10 <sorear> ddarius: real == impure?
18:06:25 <ddarius> sorear: Very roughly.
18:06:32 <tsp> cxu vi vere scias kion vi faris?
18:06:41 <thorat> ddarius: viewing unification as finding diagram limits - was that in Pierce's book on category theory?
18:06:47 <Pseudonym> Prolog is like Common Lisp.
18:07:02 <ddarius> @google Goguen What is unification
18:07:02 <lambdabot> http://cseclassic.ucsd.edu/~goguen/projs/sem.html
18:07:02 <lambdabot> Title: Semantics of Computation
18:07:05 <tsp> cxu vi vere miras pri la rezult'?
18:07:13 <tsp> lol, esperanto song lyrics
18:07:48 <hpaste>  procyon112 annotated "Evaluator" with "Simplified Unification Function" at http://hpaste.org/1174#a2
18:07:48 <ddarius> Pseudonym: Only lacking a widely popular clean version of itself (i.e. it's Scheme).
18:08:10 <thorat> ddarius: thanks for the link!
18:08:40 <ddarius> thorat: The Categorical Manifesto is worth reading and rereading as one becomes more and more familiar with category theory.
18:09:42 <thorat> thanks, I'll do that
18:10:39 <hpaste>  Excedrin pasted "leak?" at http://hpaste.org/1175
18:11:00 <TomMD> > let connectionIsGood = True in if connectionIsGood then "It's good" else "It dropped AGAIN, so you won't see this, sucker!"
18:11:01 <lambdabot>  "It's good"
18:11:44 <LoganCapaldo> I'm not a sucker
18:11:56 <Excedrin> if anyone can help me understand where/why that leaks, I'd appreciate it... I guess something that I expect to be strict is actually lazy?
18:12:00 <ddarius> You're mother would be proud.
18:12:08 <sorear> How do I make '(==) without -fth?
18:12:38 <sorear> Excedrin: import Control.Monad.State.Strict
18:14:11 <ddarius> sorear: runQ '(==) >>= print
18:14:26 <sorear> ddarius: Show is b0rken
18:14:31 <sorear> ddarius: it prettyprints!
18:14:39 <Excedrin> sorear: thanks very much
18:14:41 <sorear> hmm. bugreportable!
18:14:54 <Excedrin> o.. there isn't one
18:15:14 <ddarius> ... >>= putStrLn . myShow
18:15:16 <Excedrin> ST.Strict?
18:15:16 <sorear> Excedrin: I think it's fairly new
18:15:45 <Excedrin> ugh
18:15:51 <sorear> ddarius: hah.  between PackedString and Int#, I'd really rather not write myShow
18:15:52 <ddarius> gshow or whatever it's called. (Is the syntax finally Typeable/Data ?)
18:15:59 <sorear> PackedString, not ByteString
18:16:30 <ddarius> Excedrin: Implement it yourself really quickly.
18:16:55 <sorear> http://haskell.org/ghc/dist/current/docs/libraries/mtl/Control-Monad-State-Strict.html
18:16:57 <lambdabot> http://tinyurl.com/2dbg4m
18:17:48 <LoganCapaldo> import Data.Unobservable
18:18:04 <ddarius> Circular Coinduction.  Sounds interesting.
18:19:56 <LoganCapaldo> > execState (modify (\x -> x + 1)) 0
18:19:57 <lambdabot>  1
18:23:12 <ddarius> sorear: According to this source, http://darcs.haskell.org/packages/template-haskell/Language/Haskell/TH/Syntax.hs, everything seems to derive Show.
18:23:14 <lambdabot> http://tinyurl.com/2j5lky
18:23:31 <sorear> It doens't do it well :(
18:23:56 <LoganCapaldo> class Show a deriving Show
18:24:40 <ddarius> What is the output for runQ '(==) >>= print or whatever is appropriate to make that work?
18:24:57 <ddarius> :t '(==)
18:24:59 <lambdabot> lexical error in string/character literal at character '='
18:25:00 <sorear> Prelude Language.Haskell.TH> '(==)
18:25:00 <sorear> GHC.Base.==
18:25:19 <ddarius> So, it's just a name.
18:25:37 <sorear> yeah, but mkName "GHC.Base.==" is /= to '(==)
18:25:42 <sorear> and there is no Read
18:26:48 <LoganCapaldo> @ty mkName
18:26:50 <lambdabot> Not in scope: `mkName'
18:28:16 <TomMD> Was a configuration file changed in the dev branch that causes this -->
18:28:16 <TomMD> Time.hsc:370:2: error: #error "Don't know how to get at timezone name on your OS."
18:28:43 <sorear> built fine for me on the 25th
18:28:46 <TomMD> On a fairly typical Linux (Ubuntu 6.10) install.
18:28:51 <TomMD> Hummm
18:29:33 <ddarius> sorear: So make a mini show for names.
18:29:49 <LoganCapaldo> Is a mini show like a puppet show?
18:30:06 <ddarius> No, a puppet show is for kids.
18:30:12 <Pseudonym> Not true.
18:30:18 <Pseudonym> I'm going to Puppet Up next week.
18:30:20 <Pseudonym> It's not for kids.
18:30:21 <sorear> ddarius: I'm using '(==) now. It only adds one more unportable dependency to derive
18:30:30 <ddarius> Well, it's certainly not for names.
18:31:07 <hpaste>  procyon112 annotated "Evaluator" with "Removed Maybe from unify and simplified typeof" at http://hpaste.org/1174#a3
18:32:07 <ddarius> Does lambdabot ignore hpaste somehow?
18:32:31 <sorear> http://hpaste.org
18:32:37 <sorear> the entire server is blacklisted
18:33:22 <sjanssen> @tinyurl http://hpaste.org/1174#a3
18:33:23 <lambdabot> http://tinyurl.com/2z6of3
18:33:38 <ddarius> Ah.
18:33:51 <sjanssen> > map length ["http://hpaste.org/1174#a3", "http://tinyurl.com/2z6of3"]
18:33:53 <lambdabot>  [25,25]
18:36:51 <sioraiocht> lol
18:39:52 * sorear puts in a plea to have Language.Haskell.TH.Syntax properly haddocked
18:40:11 * sorear wonders if this is best expressed as a low-priority bug report
18:40:59 <Excedrin> is it possible to upgrade the mtl without running ghc-head?
18:41:08 <Pseudonym> It's better expressed as a patch, I suspect.
18:41:37 <dibblego> is there a serialization format for a list/set of some type that allows O(log N) seek/insert time?
18:41:39 <sorear> That requires me to understand it :)
18:41:44 <sorear> yeah
18:41:47 <sorear> B-trees
18:42:03 * sorear is an algoholic too!
18:42:28 <Pseudonym> B-trees is good if you actually want an on-disk data structure.
18:42:36 <Pseudonym> And if there's a natural ordering.
18:42:39 <sorear> serialization /= on-disk?
18:42:40 <dibblego> so a B-Tree in one file somehow?
18:43:02 <sorear> Pseudonym: a list has a natural order, and all Haskell sets are totally ordered
18:43:15 <Pseudonym> Sure, but B-trees use some kind of Ord-based ordering.
18:43:27 <sorear> Pseudonym: Sets have Ord
18:43:31 <Pseudonym> It's hard to maintain a B-tree to query by position.
18:43:36 <sjanssen> Excedrin: yes, you can upgrade mtl at will
18:43:36 <sorear> Pseudonym: it is?
18:43:47 <Pseudonym> Well, hard enough.
18:43:55 <Pseudonym> Especially if you care about performance/concurrency.
18:44:04 <laziest> If I understand dibblego right, will 'read' and 'show' not be enough?
18:44:09 <Pseudonym> You could, for example, store the number of items in the tree under each node.
18:44:17 <dibblego> <Pseudonym> It's hard to maintain a B-tree to query by position. (therefore, that's why you define order? is that what you mean?)
18:44:21 <Pseudonym> But that requires modifying the entire spine when you update the tree.
18:44:25 <dibblego> laziest, no it won't be
18:44:39 <sorear> http://www.chiark.greenend.org.uk/~sgtatham/algorithms/cbtree.html -- Where I learned it
18:44:41 <lambdabot> Title: Counted B-Trees, http://tinyurl.com/2gnvl7
18:44:42 <Pseudonym> dibblego: I mean it's hard to maintain a B-tree such that (!!) works rather than (!).
18:45:00 <Pseudonym> Generally, people who use B-trees care about performance in some way.
18:45:08 <dibblego> yes I care about performance
18:45:26 <sorear> Pseudonym: He specified O(log N).  Anything not tree-like will be *MUCH* slower.
18:45:29 <largos> is there a function to change an int into a Double?
18:45:32 <Pseudonym> Are you planning to modify the tree?
18:45:33 <int-e> Pseudonym: so it's O(log(n)) but you don't like the constant factors.
18:45:33 <sorear> fromIntegral
18:45:41 <Pseudonym> int-e: Correct.
18:45:50 <dibblego> Pseudonym, yes
18:45:51 <sorear> <dibblego> is there a serialization format for a list/set of some type that
18:45:51 <sorear>            allows O(log N) seek/insert time?
18:45:54 <largos> sorear: ah, thanks
18:45:59 <sorear> insert seems to imply modificaiton
18:45:59 <Pseudonym> I should also point out that the obvious way to delete from a B-tree is... well, not obvious.
18:46:23 <Pseudonym> Ah, yes.
18:46:30 <Pseudonym> Sorry, I meant "delete".
18:46:33 <Pseudonym> Not "modify"
18:47:02 <dibblego> thanks for the pointers - I'll read up some more
18:47:06 <sorear> Pseudonym: are these constant factors you mention actually bad enough that a different kind of structure (with O(N) insertion) would actually be preferable?
18:47:18 <Pseudonym> No.
18:47:31 <Pseudonym> But if you care about concurrency, for example, then an alternative data structure might be better.
18:47:31 <sorear> Remember, O(log N) translates into English as "scalable"
18:47:39 <Pseudonym> BTW, another option is disk-based skip lists.
18:47:46 <dibblego> yeah I've thought of that
18:47:56 <sorear> Wouldn't that have the same update problems?
18:48:03 <Pseudonym> sorear: "Scalable" means different things to different people./
18:48:22 <sorear> Pseudonym: that's why we don't translate techspeak into English :)
18:48:23 <Pseudonym> "Scalable", to me, may also imply concurrency.
18:50:27 <sorear> As a matter of principle I don't recommend shared mutable data to my enemies.
18:50:33 <dibblego> has anyone ever written an implementation that puts a list/set/whatever to disk and revision controls it?
18:50:45 <sorear> dibblego: yeah, dons
18:50:53 <dibblego> sorear, is there a name/paper?
18:51:10 <sorear> dibblego: maybe it was Pseudonym / shapr / etc, /me checks history
18:51:25 <dibblego> thanks, I've searched *everywhere* (probably for lack of keywords)
18:53:16 <sorear> Pseudonym: I can't find it in AUTHORS. Who created the State/* mechanism?
18:53:34 <dibblego> is that revision controlled?
18:53:46 <sorear> dibblego: yes, it's in darcs and committed weekly
18:53:57 <sorear> dibblego: it's not O(log N) by any means however
18:53:57 <Pseudonym> sorear: What?
18:54:05 <dibblego> the actual State itself is in darcs you mean?
18:54:05 <Pseudonym> I don't remember.
18:54:10 <sorear> Pseudonym: who gave the bot a memory?
18:54:34 <dibblego> State/* is a darcs repository
18:54:47 <sorear> yeah
18:55:26 <dibblego> sounds interesting
18:55:51 <sorear> It used to use a line oriented format so darcs could do diffs.
18:55:58 <sorear> Now, it uses Data.Binary.
18:56:08 <sorear> It is also now extremely forgetful.
18:56:15 <sorear> Coincidence? I think not.
18:56:23 <dibblego> what does it forget?
18:56:36 <sorear> My karma, for a start.
18:56:48 <sorear> @karma sorear -- has reached 40
18:56:49 <lambdabot> You have a karma of 28
18:57:00 <sorear> Quotes, lots of quotes.
18:57:03 <sjanssen> sorear: how could binary possibly cause lambdabot to lose things?
18:57:04 <sorear> Seen stats.
18:57:17 <sorear> sjanssen: error recovery?
18:57:21 <dibblego> binary leading to programmer error?
18:58:06 <sjanssen> sorear: I'm not following you
19:00:07 <dons> sorear: hmm?
19:00:41 <dons> more conspiracy theories?
19:00:42 <sorear> just me being cynical ...
19:00:51 <ddarius> @karma
19:00:51 <lambdabot> You have a karma of 3
19:01:04 <sorear> @karma Darius
19:01:05 <lambdabot> Darius has a karma of 0
19:01:06 <TSC> Hey, xmonad doesn't build
19:01:07 <sjanssen> when does lambdabot flush state to disk?
19:01:15 <dons> lambdabot forgets things if it crashes and hasn't flushed the state to disk
19:01:17 <sorear> @flush
19:01:18 <sjanssen> TSC: update X11-extras
19:01:18 <sorear> now
19:01:21 <dibblego> one of the GHC committers is an alien and changed lamdabot's State mechanism
19:01:25 <sorear> Hopefully.
19:01:39 <Cale> Apparently the entire observable universe is about 2.49 x 10^123 bits.
19:01:39 <TSC> sjanssen: Does your X11-extras have thedward's 64-bit changes?
19:01:46 <dons>   2 -rw-r--r--  1 dons  dons       9 Mar 29 12:03 state
19:01:48 <sjanssen> TSC: yes
19:01:54 <dons>  74 -rw-r--r--  1 dons  dons   36945 Mar 29 12:03 quote
19:01:56 <TSC> Ok, thanks
19:01:58 <dons> i.e. yes, it flushes.
19:02:25 <sorear> I wonder why it doesn't flush on crash...
19:02:30 <sjanssen> can we make lambdabot flush every hour or something?
19:02:47 <dons> sorear: well, um, if it crashes with out of memory exhaustion, which is usually the issue, then what can we do?
19:03:00 <dons> sjanssen: yeah. that'd be reasonable
19:03:02 <sorear> lambdabot runs out of memory!?
19:03:04 <sjanssen> lambdabot has a state leak?
19:03:11 <sjanssen> s/state/space
19:03:27 <dons> people try to do funny things, and then after a week or so, funny things catch up with it.
19:03:28 <sorear> wouldn't suprise me
19:03:37 <sorear> considering all else that ails this bot
19:03:38 <dons> ?uptime
19:03:39 <lambdabot> uptime: 5d 8h 5m 53s, longest uptime: 5d 8h 5m 53s
19:03:40 <dons>  9044 dons       2    0  155M  154M sleep    poll     6:41  0.00% lambdabot
19:04:14 <dons> its a function of the channel activity, if that's useful.
19:04:26 <dons> since the same bot, running in a much smaller channel, uses about 6M heap.
19:04:33 <dons>  6820K sleep    poll     0:14  0.00% lambdabot
19:04:35 <sjanssen> TSC: you'll want to watch the commit messages -- I usually remember to note changes to X11-extras
19:04:53 <sorear> dons: have you ever run the bot with heap profiling?
19:05:08 <dons> a long time ago.
19:06:52 * sorear curses the endpoint-inclusiveness of [a..b]
19:07:10 <Pseudonym> Unfortunately, you can't say [a..b)
19:07:43 <sorear> that would be very nice
19:07:47 <sjanssen> [a .. pred b] isn't so bad
19:07:51 <sorear> you can't even say [a .. pred b]
19:08:06 <sorear> > [0 .. pred 0] -- should be an empty list
19:08:07 <lambdabot>  []
19:08:13 <sorear> wha!
19:08:24 <ddarius> > pred 0
19:08:25 <sorear> > [0 .. -1] -- this is DIFFERENT?!
19:08:26 <lambdabot>  -1
19:08:27 <lambdabot>  []
19:08:31 <sorear> woah
19:08:41 <sorear> it always gave me [0, -1] at home
19:08:44 <ddarius> What did you think it would be?
19:08:51 <sjanssen> sorear: when did you get the impression that [0 .. -1] isn't []
19:09:14 <sorear> sjanssen: ghci
19:09:17 <sjanssen> > [0 :: Float .. -1]
19:09:18 <lambdabot>  []
19:09:25 <sjanssen> sorear: you must be misremembering
19:09:27 <sorear> sjanssen: but apparently it works correctly now
19:10:10 <petekaz> sjanssen: have the vnc issues been worked out of xmonad?
19:10:13 <sjanssen> > [0 :: Word .. pred 0] -- is the only bad case that I can imagine
19:10:15 <lambdabot>  Exception: Enum.pred{Word}: tried to take `pred' of minBound
19:10:29 <ddarius> > [True, True .. False]
19:10:30 <sorear> stefan@stefans:/tmp$ for v in 6.4.2 6.6 6.7 6.7.20070213 6.7.20070223 6.7.20070323 ; do ghc-$v -e '[0.. -1]' ; done | tr '\012' ' '
19:10:30 <sorear> [] [] [] [] [] [] stefan@stefans:/tmp$
19:10:30 <lambdabot>  []
19:10:40 <sjanssen> petekaz: I fixed shapr's issue today, I don't know about yours
19:10:47 <Pseudonym> I wonder what the consequences would be for having a [a..b) syntax.
19:10:54 <petekaz> I'll give it a try tomorrow at work.
19:10:58 <Pseudonym> [(a..b)] would be ambiguous.
19:11:10 <sorear> it would?
19:11:16 <TSC> Ah, I think I might know why I can't build XMonad; I applied thedward's additional X11 patch, that claims to break existing programs
19:11:21 <hpaste>  TSC pasted "Xmonad build error" at http://hpaste.org/1176
19:11:22 <sorear> give me two parses
19:11:24 <Pseudonym> But I think it's not unreasonable if you required the leftmost element to be inclusive.
19:11:49 <Pseudonym> Actually, you're right.
19:11:55 <Pseudonym> I was thinking of soemthing else.
19:12:17 * sorear notes to implement this in hv
19:12:25 <Pseudonym> I guess the biggest problem is it would confuse the percent key in vim.
19:12:49 <sjanssen> TSC: what is the URL for thedward's patch again?
19:13:11 <ddarius> @src Enum
19:13:12 <lambdabot> class  Enum a   where
19:13:12 <lambdabot>     succ                     :: a -> a
19:13:12 <lambdabot>     pred                     :: a -> a
19:13:12 <lambdabot>     toEnum                   :: Int -> a
19:13:12 <lambdabot>     fromEnum                 :: a -> Int
19:13:14 <lambdabot> [3 @more lines]
19:13:14 <TSC> He emailed the most recent one to the libraries ML
19:13:17 <ddarius> @more
19:13:17 <lambdabot>     enumFrom                 :: a -> [a]
19:13:18 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
19:13:19 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
19:13:44 <TSC> Or http://darcs.antejentacular.org/repos/X11
19:13:46 <lambdabot> Title: Index of /repos/X11
19:14:07 <sjanssen> TSC: I'm not prepared to make those changes now, unpull his patch or fix it yourself
19:14:21 <TSC> No problem, I'll try to fix it myself
19:16:53 <hpaste>  procyon112 annotated "Evaluator" with "More unification simplification" at http://hpaste.org/1174#a4
19:17:50 <Pseudonym> "Unification simplification" sounds like nerdcore rap.
19:17:57 <procyon112> hehe
19:18:07 <sjanssen> uh oh, looks like the X11 changes are causing the HEAD builds to barf
19:19:23 <TomMD> So, what is the rest of the Haskell communities feelings on Python?
19:19:48 <sjanssen> this is evidence that X11 and graphics libraries don't belong in a compiler distribution
19:19:54 <sjanssen> TomMD: I'm indifferent
19:20:03 * TomMD Has mixed feelings and feels it would be better if 'python' ment "Haskell in a script"
19:20:06 <Pseudonym> I have no emotional investment in Python.
19:21:05 <Pseudonym> Though I will point out this much: The Haskell community feels a slight affinity with Perl because of Pugs.
19:21:10 <sorear> I never got python.
19:21:10 <Pseudonym> But that's not the language.
19:21:15 <sorear> I tried to learn python
19:21:29 <ddarius> I don't know Python, but I've programmed in it before.
19:21:30 <sorear> then I found out about this funky "Haskell" thing
19:21:37 <sorear> I was permanently distracted
19:21:56 <Pseudonym> I spoke Haskell before Python was made open source.
19:22:10 <newpers> how does haskell's concurrency compare to erlang
19:22:11 <sjanssen> I'm afraid I'll never get around to learning another programming language
19:22:11 <TomMD> And that was so much easier, right?  Because in Haskell if you accidently perform PFA, it will be kind enough to tell you 100 lines later. :-)
19:22:22 <LoganCapaldo> sjanssen: Noooo
19:22:23 <procyon112> Python looks cute.
19:22:23 <ddarius> newpers: Which?
19:22:25 <sorear> @vera PFA
19:22:27 <Excedrin> Pseudonym: people who haven't seen Haskell before sometimes think it's similar to Perl due to lots of punctuation characters
19:22:27 <lambdabot> *** "pfa" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
19:22:28 <lambdabot> PFA
19:22:28 <lambdabot>      Predictive Failure Analysis (HDD)
19:22:28 <lambdabot>  
19:22:28 <lambdabot> *** "pfa" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
19:22:29 <LoganCapaldo> learning programming languages is the fun
19:22:29 <lambdabot> [3 @more lines]
19:22:40 <newpers> no
19:22:40 <sorear> @more+
19:22:41 <lambdabot> PFA
19:22:41 <lambdabot>      Parameter Field Address (Forth)
19:22:41 <lambdabot>  
19:22:42 <Pseudonym> sjanssen: Simple cure for that.  Implement your own DSL in Haskell.  That'll force you to learn another language!
19:22:44 <newpers> heh
19:22:54 <sjanssen> newpers: in what respect?  Haskell threads scale about as well as Erlang's
19:23:07 <Pseudonym> Haskell threads are a bit heavier, IME.
19:23:23 <TomMD> PFA: Partial function application (as I mean it)
19:23:23 <newpers> good question
19:24:00 <ddarius> newpers: There are different, but related ways of dealing with concurrency in Haskell nowadays.
19:25:00 <procyon112> Haskell, AFAIK, doesn't have the resiliency through redundancy aspect of Erlang, nor the near transparant cross-machine threading
19:25:31 <ddarius> @google Haskell ports distributed computing
19:25:34 <lambdabot> http://citeseer.ist.psu.edu/479359.html
19:25:34 <lambdabot> Title: Implementation of Port-based Distributed Haskell - Huch, Stolz (ResearchIndex)
19:25:37 <Pseudonym> OTOH, Haskell has STM.
19:25:50 <procyon112> And strong static typing
19:25:59 <TomMD> and STM ROCKS!  I fell in love with STM in... oh... 15 minutes.
19:26:11 <Pseudonym> Yeah.
19:26:16 <Pseudonym> Me too.
19:26:17 <LoganCapaldo> I worry about STM
19:26:21 <TomMD> Why?
19:26:24 <LoganCapaldo> what if the emperor has no clothes?
19:26:32 <Pseudonym> Sorry?
19:26:41 <LoganCapaldo> its too good to be true
19:26:48 <ddarius> LoganCapaldo: Then he is very forward looking.
19:26:49 <sjanssen> that's a stupid argument
19:27:01 <LoganCapaldo> its not an argument its a feeling
19:27:02 <Pseudonym> As opposed to what?  CAS?  RCU?  LL/SC?
19:27:14 <procyon112> It would be nice to get some of that redundancy through lightweight threads though... Even a provably sound program will segfault if there is a RAM error.  Erlang programs can survive that.
19:27:18 <Pseudonym> It's not too good to be true, because it's not a silver bullet.
19:27:18 <sjanssen> no offense, but just because something is good doesn't mean it's impossible
19:27:41 * LoganCapaldo decides to keep his feelings to himself in the future
19:27:54 <sjanssen> LoganCapaldo: :)
19:27:57 <TomMD> STM is moderately well studied and it works well for me.  I don't claim it will make you leaner and wealthier, but it is a great thing.
19:28:32 <newpers> procyon112, thanks for your comments
19:28:39 <Pseudonym> The real question with STM for me is whether or not CPU manufacturers will adopt it with hardware support.
19:28:50 <ddarius> CAS?
19:28:58 <Pseudonym> Compare-And-Swap
19:29:13 <ddarius> I know.  What does STM need beyond that?
19:29:17 <TomMD> LoganCapaldo: Actually, I consider the perceptions rather useful, please do continue to share as you desire to.
19:29:24 <ddarius> HTM?
19:29:31 <Pseudonym> Yes.
19:29:37 <Pseudonym> CAS works, but it's not cache-friendly.
19:30:03 <Pseudonym> HTM would make each CPU's cache transactional.
19:30:06 <QtPlatypus> Didn't STM evolve out of stimulating HTM?
19:30:13 <Pseudonym> Yes.
19:30:59 <sorear> Pseudonym: STM by definition will never be able to take advantage of hardware support
19:31:09 <Pseudonym> Why not?
19:31:21 <Pseudonym> Take LL/SC as an example.
19:31:21 <sorear> because it is *Software* transactional memory
19:31:25 <Pseudonym> Some CPUs support LL/SC.
19:31:37 <Pseudonym> But a transaction will "fail" if, say, there's a page fault.
19:31:51 <Pseudonym> It's not hard to build a "reliable" LL/SC layer on top of that.
19:31:57 <LoganCapaldo> TomMD: I sorta feel like its kinda like GC. GC is hands down better than manual memory management (at least for everything I do). I'm just waiting for the "no deterministic destructors" equivalent for STM shoe to drop
19:32:00 <TomMD> So you would have software assisted (hardware) transactional memory.  satm... sahtm
19:32:00 <Pseudonym> Which uses the hardware instructions.
19:32:08 <Pseudonym> Yeah, something like that.
19:32:29 <QtPlatypus> @unpf =^_^=
19:32:30 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Parse error
19:33:17 <sorear> LoganCapaldo: something like that has already fallen
19:33:35 <sorear> LoganCapaldo: it's next to impossible to interface STM with external transaction systems
19:34:08 <Pseudonym> I can imagine, for example, that an OS could reasonably "abort" a STM transaction if a certain kind of page fault occurs.
19:34:19 <Pseudonym> One that involves suspending the thread.
19:34:20 <procyon112> why doesn't pattern matching support: f (x,x) = "(a,b) -> a==b"   -- ???
19:34:40 * LoganCapaldo has wondered that too
19:34:52 <Pseudonym> procyon: Miranda did that.
19:35:02 <Pseudonym> Basically, because the semantics are a bit weird.
19:35:08 <TomMD> Pseudonym: So now STM is built into the OS?  Darn feature creep!
19:35:19 <Pseudonym> TomMD: Mutexes are.
19:35:23 <Pseudonym> I don't see why STM couldn't be.
19:35:52 <TomMD> But do you see why it 'must' be?  That is a more appropriate question (depending on your point of view on OS development)
19:36:10 <Pseudonym> I see why STM requires software coordination.
19:36:29 <Pseudonym> pthreads can be implemented as a library, too.
19:36:40 <Pseudonym> It's just not as good as when you have OS support.
19:36:58 <TomMD> Oh, I suppose we should divide between 'OS' and 'kernel'.
19:37:29 <Pseudonym> I suppose, but some OSes have page faults handled outside the kernel. :-)
19:37:42 <TomMD> Yes, those OSes we call 'good'. :-)
19:38:12 <Pseudonym> My point is that it makes sense that if a thread is going to be suspended due to a page fault, and the OS is managing the STM programming model, then it makes sense for that kind of page fault to abort a transaction.
19:39:57 <edwardk> I kinda like the proposition of OS-level STM
19:40:38 <edwardk> the only danger is that you can envision denial of service attacks in the form of page thrashing
19:41:07 <Pseudonym> a.k.a. livelock
19:41:23 <Pseudonym> It's a power feature, like real-time scheduling.
19:41:31 * LoganCapaldo is retty sure page thrashing is already a DDoS
19:41:36 <edwardk> probaby makes sense to consider them more at the level of a kernel thread level page fault manager than in the heart of the OS somewhere
19:41:38 <Pseudonym> It's something that an OS might want to protect mere user-threads from.
19:41:40 * LoganCapaldo listens to his hard drive spin and spin
19:42:24 <procyon112> My Vista box DDoS's *itself* through page thrashing!  It's got all the latest features!
19:42:26 <edwardk> logan: yeah but there is forward progress usually even in the face of thrashing. with the STM-abort on fault model you could see a total lock
19:43:58 <Pseudonym> In our STM B-tree implementation, we're pretty much doing that manually.
19:44:36 <Pseudonym> We have a manually-controlled buffer cache, and if the page you need isn't in the cache, you abort the transaction, read it in, and try again.
19:44:46 <Pseudonym> "In the cache" in this case means it's mmaped.
19:44:55 <Pseudonym> It doesn't mean it's in core.
19:45:04 <edwardk> the b-tree code public? i was just starting to write something like that =)
19:45:12 <Pseudonym> edwardk: Nope.
19:45:16 <edwardk> gah
19:45:17 <edwardk> oh well
19:45:28 <Pseudonym> You can read the paper when it's done. :-)
19:45:34 <ddarius> ETA?
19:45:40 <edwardk> dealing with a similar issue for mapping OLAP style data
19:45:49 <Pseudonym> ddarius: Didn't you hear?  "When it's done."
19:46:01 <Pseudonym> Sheesh.
19:46:05 <Pseudonym> Talk about sense of entitlement.
19:46:08 <edwardk> hehe
19:47:05 <Korollary> Pseudonym: Are you back at the uni?
19:47:24 <edwardk> pseudonym: so you can't perform any transaction larger than your buffer cache?
19:47:49 <Pseudonym> edwardk: Because the buffer cache is what's mmaped, not what's in core, that's not a big problem.
19:47:53 <Pseudonym> Unless you run out of address space.
19:47:57 <edwardk> yeah
19:47:58 <Pseudonym> But you're stuffed if you do that.
19:48:04 <edwardk> just looking for hard core limitations
19:48:09 <edwardk> i like the idea in the abstract
19:48:11 <ddarius> Use a 64-bit computer.
19:48:24 <edwardk> just trying to look at the resource starvation issues you might run into
19:48:41 <edwardk> with STM and big transactions you're already stuffed ;)
19:48:48 <Pseudonym> Korollary: I still work here, if that's what you mean.
19:50:31 <ddarius> Ah, the smell of shoe polish.
19:50:34 <sjanssen> @seen thedward
19:50:35 <lambdabot> thedward is in #haskell. I last heard thedward speak 41m 48s ago.
19:50:46 <dmwit> ?seen jcreigh
19:50:46 <lambdabot> jcreigh is in #haskell. I last heard jcreigh speak 3h 2m 28s ago.
19:51:56 <dmwit> sjanssen: Tell me of the plans for xmonad.  Is it planned to do full dwm-style tagging?
19:52:21 <dmwit> (I.e. each client can have multiple tags, and the view can also be multiple tags.)
19:52:26 <sjanssen> dmwit: I've been back and forth on this
19:52:35 <edwardk> sjannsen++ # props for xmonad =)
19:52:47 <sjanssen> if somebody showed me a really nice design I might be swayed
19:53:00 <sjanssen> edwardk: do you use it?
19:53:17 <edwardk> i have it running on one machine here to try it out
19:53:34 <edwardk> raided it for code and ideas ;)
19:53:52 <sjanssen> ah, you're writing a window manager?
19:54:44 <edwardk> kinda. i had an old 3d project i wanted to dust off at some point, but its largely crippled by the inability of haskell to cleanly interface with large c++ libraries, so i kinda left it shelved.
19:55:32 <sjanssen> dmwit: tagging has some weird interactions with the way we do multiple screens right now
19:55:38 <edwardk> and no, c level thunks aren't an option, too many templates, etc.
19:55:44 <dmwit> sjanssen: Yes, that's why I was asking.
19:55:55 <dmwit> It would be bad to have a window on two (visible) workspaces at once.
19:56:05 <sjanssen> s/bad/impossible :)
19:56:16 <dmwit> heh
19:56:56 <sjanssen> what are you opinions on the xinerama stuff, now that you've used it for a few days?
19:57:15 <dmwit> It's nice and simple, and very usable.
19:57:25 <edwardk> i should throw another screen on there and form one ;)
19:57:28 <dmwit> But I still think the Right Way is to have the workspaces be different per screen.
19:57:35 <sorear> yeah! TH in derive is starting to work!
19:58:20 <dmwit> (This would, as a side effect, mostly solve the problem inherent in full tagging.)
19:59:24 <dmwit> Anyway, I think xmonad has all the killer features for me, now.
19:59:29 <dmwit> From here on, it's all gravy. =)
19:59:40 <sjanssen> the idea that windows are fundamentally attached to screens bothers me a bit
20:00:02 <dmwit> What do you mean?
20:00:23 <sjanssen> s/are/would be in the other model
20:00:34 <dmwit> ah
20:00:53 <dmwit> Yes, but it should still be fine to allow a window to get thrown to another screen.
20:01:11 <dmwit> Yank it off all the workspaces for one screen, put it on the visible workspace of another screen...
20:01:13 <sjanssen> sure
20:01:33 <sjanssen> another option is to only implement partial tagging
20:01:54 <sjanssen> ie a window has exactly one tag, but a screen has a set of them
20:02:24 <dmwit> Then restrict screens to mutually exclusive tag sets, I guess?
20:02:30 <dmwit> That's interesting.
20:02:31 <sorear> I suppose "A window appears on the lowest-numbered screen it could appear on" is unacceptable?
20:02:51 <sjanssen> sorear: that is also an option
20:03:29 <sorear> or, hehe, create proxy windows to subvert the X11 limitation
20:03:56 <sjanssen> dmwit: yeah, trying to add a tag owned by another screen could either steal the tag or switch focus to the screen that currently owns it
20:04:12 <sorear> I suppose that would be a sizable fraction of 400loc, though :)
20:05:25 <dmwit> I have a hard time weighing the options, because for me, I hardly ever use full tagging or move windows between screens.
20:05:37 <dmwit> These are the two problem scenarios, so how can I compare which is more common?
20:05:46 <sjanssen> sorear's greedy screen might be the best option
20:06:14 <dmwit> But the code for this isn't as pretty. ;-)
20:06:19 <sjanssen> dmwit: how do you use tags in dwm?
20:06:40 <jcreigh> dmwit: pong
20:06:45 <dmwit> For me, each window has exactly one tag, and exactly one tag is visible.
20:06:58 <sjanssen> okay, so you don't care about tags
20:06:59 <dmwit> jcreigh: We're discussing how to do screens/workspaces in Xinerama.
20:07:03 <sjanssen> jcreigh: do you use tags?
20:07:12 <dmwit> sjanssen: Right, but I want that it should do the right thing for somebody else.
20:07:20 <jcreigh> sjanssen: naw
20:07:30 <dmwit> ...
20:07:39 <dmwit> Maybe tags are too complex for people to use?
20:07:42 <dmwit> =P
20:07:50 * jcreigh starts to read scrollback
20:08:01 <sjanssen> I've only been asked for tags by glguy, so I'm inclined to table the issue until glguy feels like contributing to xmonad
20:08:29 <dmwit> Oh, has glguy done dwm/wmii before?
20:08:37 <sjanssen> glguy is a dwm user
20:09:01 <edwardk> i'd pipe up for tags but my level of usage is probably exceeded by the overhead of implementing them =P
20:09:16 <dmwit> edwardk: How do you use them?
20:09:49 <edwardk> currently i don't =)
20:10:05 <dmwit> ... four votes against. =D
20:10:07 <edwardk> hence why my level of usage would be exceeded by the overhead of implementation =)
20:11:03 <sjanssen> tags also have nasty interactions with per workspace layout mode
20:11:34 <sjanssen> and I've gotten many positive comments about that
20:11:45 <dons> boo on tags.
20:11:47 <edwardk> dumb question, is it in any way reasonable to try to auto-tag by window title? then you could quickly grab all firefox windows etc by the fact that that word appears in their title
20:12:03 <edwardk> a little sloppy, but less user management, not sure of technical issues
20:12:43 <tstewart> Is combinator pronounced a) com-bine-a-tor b) com-bin-ay-tor c) none of the above?
20:12:44 <sjanssen> dons: yes, I think we've just reached that conclusion :)
20:13:12 <dons> good. :-)
20:13:40 <edwardk> tstewart: I always use (a)
20:13:49 <sjanssen> tstewart: I use b
20:13:53 <vincenz> tstewart: I use b
20:13:54 <dmwit> (b)
20:14:00 <jcreigh> I don't feel any need for tags.
20:14:13 <tstewart> thanks all!
20:14:17 <dmwit> Yay!  A vote of no confidence.
20:14:20 <dmwit> (in tags)
20:14:22 <sorear> (b)
20:14:24 <edwardk> heh
20:15:08 <sjanssen> I feel much better now that we have user interface arguments against tags, rather than "it's hard to implement"
20:18:32 <jcreigh> there's just too many things that become non-obvious with tags.
20:18:42 <jcreigh> maybe we should rename the "tag" function now. :)
20:19:04 <LoganCapaldo> theres user interface arguments against tags?
20:19:31 <LoganCapaldo> but but, I want to pretend like my desktop is a web 2.0 site
20:19:41 <sjanssen> LoganCapaldo: with the other features that xmonad offers, yes
20:19:47 <paulc> hi all
20:19:56 <dmwit> hi paul
20:20:04 <sjanssen> I still like tags for other sorts of categorization
20:20:07 <paulc> I just started learning haskell
20:20:22 <paulc> I'm having some trouble decoding some compiler errors
20:20:34 <sjanssen> paulc: can you paste the code?
20:20:35 <sjanssen> @hpaste
20:20:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:20:40 <edwardk> Logan: that gives me a terrifying visual of a tag cloud on my desktop.
20:20:42 <sjanssen> you can paste the errors too
20:20:48 <paulc> k
20:20:50 <edwardk> actually thats not so terrifying
20:21:11 <Philippa> note to self: upgrading debian distros just before you meant to go to bed doesn't work
20:21:25 <Philippa> even if it is going to get you GHC6.6
20:21:40 <LoganCapaldo> especially if its going to get you GHC 6.6
20:21:54 <Philippa> nah, I've already got 6.6 on my desktop
20:21:57 <jcreigh> Philippa: are you moving from stable to testing?
20:22:05 <sjanssen> dmwit: oh, there's a problem with that last patch you sent
20:22:07 <Philippa> jcreigh: from sarge to etch
20:22:19 <dmwit> sjanssen: uh oh
20:22:29 <Philippa> on a zaurus, if you're wondering
20:22:36 <jcreigh> ah, I had forgotten the name of the latest stable.
20:22:39 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1177
20:22:49 <sjanssen> dmwit: adding the refresh to safeFocus is bad -- we can't call refresh on Enter/LeaveNotify events
20:23:00 <paulc> here's the paste: http://hpaste.org/1177
20:23:06 <sjanssen> dmwit: it leads to this strange infinite loop issue in Full mode
20:23:13 <dmwit> sjanssen: I was wondering if I was going to have to be more careful about when I do that.
20:23:19 <paulc> it is prolly something silly?
20:23:27 <sjanssen> dmwit: what was the refresh supposed to accomplish, anyway?
20:23:54 <sjanssen> theoretically, giving focus to some window should never change the on screen layout
20:23:58 <jcreigh> paulc: you need "merge (x:xs) (y:ys)"
20:24:04 <dmwit> sjanssen: When moving the mouse to a different workspace, it doesn't update which window is focussed (?).
20:24:10 <paulc> can you explain why?
20:24:18 <dmwit> sjanssen: Let me explain more, don't ask yet.
20:25:29 <sjanssen> paulc: otherwise Haskell parses the code like you're declaring the definition of the : operator
20:25:52 <dmwit> sjanssen: The problem is actually this.  refresh grabs the button press event on all windows except the focused one.  When you focus a different window, that still has a buttongrab on it -- so even though it's focused, one click "disappears".  I think it's fixable, but I was very lazy...
20:26:38 <dons> what does dwm do?
20:26:39 <hpaste>  (anonymous) pasted "Merge" at http://hpaste.org/1178
20:26:40 <sjanssen> paulc: it interprets "f x : y = ..." as "(f x) : y = ..."
20:26:49 <paulc> I see
20:27:00 <paulc> now I get a different error...
20:27:11 <dmwit> dons: It changes the grab on the newly focused window and the recently unfocused window.
20:27:11 <paulc> the Merge paste above
20:27:12 <sjanssen> dmwit: perhaps we need to move the button changing stuff out of refresh?
20:27:26 <dmwit> dons: But we don't have a clear memory of what "recently unfocused" means in this code.
20:27:57 <sjanssen> paulc: you should use the "annotate" link to add stuff to related pastes.  And give a title please :)
20:28:14 <dmwit> sjanssen: Yes, I think the real answer is to be more careful, and just change the grab on the windows it ought to change on.
20:28:19 <paulc> okay, sorry!
20:28:39 <hpaste>  sjanssen annotated "Merge" with "parens again" at http://hpaste.org/1178#a1
20:28:45 <dmwit> But the problem is that focusing isn't well unified, so the focus could come from anywhere.
20:28:54 <dmwit> Errr...
20:29:14 <dmwit> Where "could come from anywhere" means "could come from any window", not "could come from any part of the code".
20:29:48 <dmwit> Anyway, enough complaining, time to just dive in and work on it. =)
20:30:02 <hpaste>  sjanssen annotated "Merge" with "minimal parens" at http://hpaste.org/1178#a2
20:30:45 <sjanssen> dmwit: yeah, there's plenty of funky stuff with focus
20:31:05 <sjanssen> oh!  I've got an idea!
20:31:42 <sjanssen> so we explicitly tell Xlib to listen for Enter and LeaveNotify -- we can shut that off during refresh
20:32:07 <paulc> thanks sjanssen
20:32:10 <dmwit> odors
20:32:18 <jcreigh> sjanssen: that sounds promising
20:32:28 <dmwit> I'm skeptical.
20:32:35 <dmwit> It's like fixing the symptoms, not the problems...
20:32:39 <sjanssen> that should fix both the infinite loop issue *and* the focus change on workspace switch
20:33:17 <sjanssen> dmwit: we should probably refactor the focus code anyway.  But this is the way to fix the workspace switch bug
20:33:37 <dmwit> Hmmm... okay.
20:33:42 <jcreigh> workspace switch bug?
20:33:45 * jcreigh hadn't noticed.
20:34:34 <sjanssen> jcreigh: when you switch workspaces, the window under the mouse gets focus.  I'd prefer the last window focused gets it
20:35:07 <dmwit> Ooo, you're right.  That's not nice.
20:35:21 <dmwit> This may solve the similar promote bug, too.
20:35:25 <dmwit> \o/
20:35:26 <sjanssen> (make a ws with two windows, leave the mouse in one and change the focus to another.  Switch to another workspace, then switch back)
20:35:28 <jcreigh> hmm, so it does.
20:35:36 <sjanssen> dmwit: yes, it definitely will
20:36:53 <dmwit> sjanssen: Does this only need to change for the root window?
20:37:24 <sjanssen> hmm, where does the root come in to it?
20:37:40 <dmwit> I see "grabKeys dpy rootw" in Main.hs
20:37:58 <dmwit> O
20:38:06 * dmwit flushes red
20:38:23 <sjanssen> dmwit: it's the selectInput we need to change
20:39:32 <dmwit> sjanssen: Yeah, silly error.
20:40:46 <sjanssen> dmwit: are you doing this, or am I?
20:40:58 <dmwit> sjanssen: Your choice.
20:41:28 <sjanssen> I suppose I'll do it
20:41:36 <dmwit> k
20:43:00 <encryptio> when would i use StateT Writer vs. WriterT State?
20:44:23 <Philippa> that one doesn't matter - they're equivalent
20:45:34 <LoganCapaldo> State YourName, State NewYork, State OfDenial
20:48:06 <paulc> apposition is right associative or left associative?
20:48:33 <jcreigh> Why is the X11 binding so incomplete, as far as our purposes go? Seems like every new thing we do we have to go make a binding to it first...
20:48:44 <paulc> f x y = f ( x y) or (f x) y
20:48:47 <paulc> ?
20:48:52 <dmwit> paulc: left
20:48:56 <dmwit> (f x) y
20:48:57 <jcreigh> (f x) y
20:49:13 <paulc> ok
20:52:22 <sjanssen> jcreigh: it has barely any users, as far as I can tell
20:52:33 <sjanssen> did you see my refreshKeyboardMapping bug?
20:53:11 <sjanssen> the bug is incontrovertible proof that it has never been used
20:53:48 <jcreigh> no. was the binding just totally broken?
20:54:29 <sjanssen> yeah, it didn't set the display in a struct, so it'd always result in a segfault
20:54:48 <sjanssen> (there wasn't even a display argument in the function)
20:55:02 <jcreigh> oh
21:02:06 <TSC> I think I know why my window-managing bug is happening; I'll try to find the cause (it's a 64-bit X11 problem again)
21:10:23 <Excedrin> http://hpaste.org/1175 changing s/Control.Monad.State/Control.Monad.State.Strict/ should be the only required change, correct?
21:10:55 <chessguy> hi all
21:14:26 <Excedrin> ok, so modify inc is not strict, do { st <- get; inc st `seq` put (inc st); ... } is strict
21:14:30 <Excedrin> I'm not sure if that's expected
21:17:37 <Excedrin> I guess: put $! inc st is a little cleaner
21:22:50 <ddarius> Excedrin: You'd need let x = inc st in x `seq` put x
21:23:08 <ddarius> (or $! is fine)
21:23:41 <Excedrin> huh, I'm pretty sure the let isn't needed
21:24:37 <ddarius> f x `seq` g (f x) <=> g (f x)
21:25:40 <ddarius> <=/=> let fx = f x in fx `seq` g fx
21:26:02 <Cale> Well, depending on how the compiler handles CSE, I suppose.
21:26:02 <Excedrin> what's the difference?
21:26:30 <Cale> You want f x to be evaluated just once.
21:26:36 <Cale> The whole point of seq'ing it is so that the result will be available.
21:26:39 <Excedrin> also, Control.State* from darcs mtl seems very slow
21:26:40 <ddarius> The two occurences of f x are not shared, so forcing one does not affect the other.
21:27:28 <ddarius> Cale: The compiler shouldn't CSE that, there's a semantic difference.
21:27:39 <Excedrin> a program that took 2 seconds before installing updated mtl takes approx 38 seconds afterwards
21:27:52 <Excedrin> I wonder if there's some "debug" settings or something
21:31:57 <dons> Excedrin: did you compile mtl with -O2 ?
21:32:06 <dons> it might be missing ghc-options: -O from its .cabal file
21:32:10 <Excedrin> nope, I didn't change the mtl.cabal
21:32:14 <Excedrin> ya, doing that now
21:32:31 <dons> yeah, have a look at it. if its not got a ghc-options flag, then it'll suck.
21:32:39 <dons> the newer cabals now set -O by default
21:35:24 <hpaste>  procyon112 annotated "Evaluator" with "What is wrong here?" at http://hpaste.org/1174#a5
21:35:42 <procyon112> Anyone arround to look at this little problem?
21:35:57 <chessguy> hey procyon112
21:36:03 <procyon112> yo!
21:36:45 <chessguy> wow, looks like you're making good progress
21:36:50 <procyon112> I'm trying to build a strongly typed GP tree generator, but I'm having issues with my unification :/
21:37:17 <procyon112> OOH!  Nevermind.. I found the problem.
21:37:30 <procyon112> I had variable capture in my unification.
21:37:51 <chessguy> sometimes asing the right question is most of the battle :)
21:38:26 <procyon112> I'm close... that evaluator hpaste is 95% of the work.
21:40:15 <chessguy> you're way over my head
21:40:45 <procyon112> I'm way over *my* head!
21:40:54 <chessguy> lol
21:41:29 <procyon112> dude... I don't even really grok monads yet.  My brain is hurting.
21:41:47 <chessguy> heh
21:41:49 <Korollary> It's the lactic acid build-up.
21:41:50 <chessguy> monads aren't so bad
21:42:10 <chessguy> monads just let you be explicit about side effecs
21:42:17 <chessguy> s/cs/cts/
21:42:54 <procyon112> And hide stuff.  I understand the ones like Maybe and Error....  I'm don't get the workings and implications of them yet though.
21:43:19 <chessguy> yeah, the implications are the hard part
21:43:36 <procyon112> and fmap freaks me out still. :)
21:43:47 <chessguy> lol
21:43:57 <chessguy> fmap is just map
21:44:04 <chessguy> except not just on lists
21:44:09 <procyon112> Although I just wished for an ffilter.. so I must be understanding it somewhere on a subconcious level.
21:44:16 <chessguy> > fmap (*2) [1..5]
21:44:18 <lambdabot>  [2,4,6,8,10]
21:44:50 <chessguy> @instances-importing Functor
21:44:51 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:45:28 <procyon112> yes, but conceptualizing an ErrorT Monad as another case of list where mapping applies is where my brain leaks out my ear.
21:45:31 <chessguy> > fmap (*2) $ Right 2
21:45:33 <lambdabot>  Right 4
21:46:09 <chessguy> it's not a case of list
21:46:14 <chessguy> it's more general
21:46:24 <chessguy> functors are just things with elements
21:46:26 <chessguy> containers
21:46:48 <chessguy> and fmap applies a function to every element in the container
21:46:55 <chessguy> ?src Functor
21:46:55 <lambdabot> class  Functor f  where
21:46:56 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
21:47:16 <chessguy> ?src map
21:47:16 <lambdabot> map _ []     = []
21:47:17 <lambdabot> map f (x:xs) = f x : map f xs
21:47:21 <chessguy> err
21:47:23 <chessguy> @type map
21:47:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:47:46 <procyon112> ah ok
21:47:59 <chessguy> here you can see that [] is just one instance of functor, a type of container
21:48:49 <dolio> Hmm, evidently I should go back and take C/C++ Programming 1 before I take C/C++ Programming 2.
21:48:56 <chessguy> now how ((->) r) is a functor is beyon me
21:49:02 <procyon112> lol
21:49:18 <bd_> chessguy: apply a function to its result
21:49:37 <dolio> ?type (.)
21:49:39 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:49:47 <chessguy> bd_: you mean to the result of that function?
21:49:58 <bd_> chessguy: right, it's essentially (.) in reverse
21:50:05 <bd_> well, flip (.) even
21:50:18 <chessguy> hmm
21:50:19 <bd_> > fmap (+1) (+1) 1
21:50:21 <lambdabot>  3
21:50:23 <bd_> > fmap (*2) (+1) 1
21:50:25 <lambdabot>  4
21:50:27 <bd_> > fmap (+1) (*2) 1
21:50:29 <lambdabot>  3
21:50:34 <Pseudonym> chessguy: If you know any category theory, ((->) r) is a comma category.
21:50:42 <chessguy> Pseudonym: i don't
21:50:59 <Pseudonym> In that case, it's not a comma category.
21:51:16 <chessguy> lol. it still is, i'm just blissfully ignorant of it :)
21:51:20 <Pseudonym> I hate it how mathematical provability is dependent on what other people know.
21:51:50 <chessguy> my knowledge or lack thereof of a truth hardly influences whether or not it's true
21:52:20 <chessguy> or are you one of those solipsistic nutcases
21:52:41 <Pseudonym> No, but my consistency and completeness have not yet been proven.
21:52:52 <procyon112> bah!  where clauses don't work in anonymous lambdas?
21:53:10 <Pseudonym> procyon: Nope, where clauses bind to equals signs.
21:53:16 <Pseudonym> There's always let.
21:53:20 <chessguy> anyway, it's time for bed and here i am talking about solipsism
21:53:22 <chessguy> yeesh
21:53:28 <chessguy> 'night all
21:53:33 <Pseudonym> Night.
21:53:40 <ddarius> Pseudonym: I would not let my figments of my imagination back talk me so.
21:54:28 <procyon112> is there a quick way to get the 2nd element in a triple without resorting to a pattern match?
21:54:54 <Pseudonym> @hoogle (a,b,c) -> b
21:54:55 <lambdabot> No matches, try a more general search
21:55:06 <procyon112> guess not :)
21:55:08 <Pseudonym> We used to have fst3, snd3 and thd3 once upon a time.
21:55:23 <Pseudonym> Perhaps in Gofer.
21:57:47 * dmwit prefers frst, scnd, thrd as names.
21:58:17 <dolio> I don't know. Four letters is pushing it.
21:58:20 <Pseudonym> And for 4-tuples, first, secnd, third and forth?
21:58:32 <dolio> Well, then you run up into:
21:58:34 <dolio> ?type first
21:58:37 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
21:58:41 <Pseudonym> True.
21:58:41 <Pseudonym> Damn.
22:00:28 <procyon112> then you would end up really weird, with fiirst second thiird fourth and fiifth
22:00:58 <Pseudonym> At some point we hit a Y2K problem.
22:02:17 <ddarius> (a,b,c) ~ (a,(b,c))
22:02:33 <Pseudonym> Where ~ is what relation, exactly?
22:02:55 <Excedrin> SML tuple selectors are pretty cool, is it impossible to add them to Haskell?
22:03:03 <ddarius> Isomorphism (modulo pretending Haskell is as nice as we like to think of it)
22:03:10 <Pseudonym> I was about to say.
22:03:16 <Pseudonym> (1,bottom) |-> what exactly?
22:03:57 <Pseudonym> Excedrin: There comes a point where maybe you shouldn't be using tuples any more.
22:03:57 <dmwit> fix (1,)
22:04:12 <dolio> If you did that, you could start using some lisp-alike functions
22:04:35 <ddarius> :t fix (1,)
22:04:38 <lambdabot> parse error on input `)'
22:04:47 <ddarius> :t fix ((,) 1{
22:04:48 <lambdabot> parse error (possibly incorrect indentation)
22:04:50 <ddarius> :t fix ((,) 1)
22:04:52 <lambdabot>     Occurs check: cannot construct the infinite type: a = (t, a)
22:04:52 <lambdabot>       Expected type: a -> a
22:04:55 <Excedrin> Pseudonym: what point is that exactly? 3 element tuples? why not simply remove 3 element tuples then?
22:05:03 <ddarius> Now we need equirecursive types.
22:05:09 <Pseudonym> No we don't.
22:05:21 <Pseudonym> Excedrin: Because tuples are handy for intermediate values.
22:05:24 <Pseudonym> Or multiple return values.
22:05:35 <Pseudonym> Not for the long-term storage of data.
22:06:06 <Excedrin> how are tuple selectors related to long-term storage of data?
22:06:29 <Pseudonym> If you're using tuples for intermediate values, generally speaking, you just unpack them.
22:07:03 <Pseudonym> By pattern matching.
22:08:04 <Pseudonym> I'm not saying that tuple selectors are pointless, merely that giving records meaningful names is often better.
22:12:30 <hpaste>  procyon112 annotated "Evaluator" with "Fixed find type matched functions" at http://hpaste.org/1174#a6
22:33:41 <vincenz> @type M.lookup
22:33:43 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
22:36:22 <vincenz> @type (x !)
22:36:25 <lambdabot> Not in scope: `x'
22:36:26 <vincenz> @type \x -> (x !)
22:36:28 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
23:16:32 <bitwiseshiftleft> question: is it possible to use rewrite rules for when a function's argument is in Eq?
23:17:20 <sjanssen> I believe that works
23:17:36 <bitwiseshiftleft> really?  i tried to use
23:17:48 <bitwiseshiftleft> {-# RULES "foo/Eq" foo = fooEq #-}
23:18:14 <bitwiseshiftleft> where foo has type (a -> b) -> C a b
23:18:22 <bitwiseshiftleft> and fooEq has type Eq b => (same)
23:18:26 <bitwiseshiftleft> and it complained:
23:19:02 <sjanssen> the LHS and the RHS need to have the same type
23:19:02 <bitwiseshiftleft> No instance for (Eq b) arising from use of `fooEq' at [place] Possible fix: add (Eq b) to the tcRule
23:19:12 <sjanssen> so you probably need to quantify your variables
23:19:30 <bitwiseshiftleft> how can I quantify them?  like, what's the syntax?
23:19:35 <sjanssen> {-# RULES "foo/Eq" forall f. foo f = fooEq f #-}
23:19:45 <bitwiseshiftleft> i tried it, same error
23:20:07 <dons> bitwiseshiftleft: *possibly*, though it'd be hard
23:20:19 <dons> e.g. you can match monomorphic things, like so:
23:20:37 <dons> {-# RULES sum = sumInt :: [Int] -> Int #-}
23:20:50 <dons> will rewrite polymorphic (in Num) sum, to the specialised sumInt
23:20:59 <dons> by looking up the type, specified in the rule, yeah?
23:20:59 <bitwiseshiftleft> sure
23:21:04 <dons> so you'd have:
23:21:18 <dons> {-# RULES foo = fooEq :: Eq a => a -> ... #-}
23:21:23 <dons> but i've never tried this.
23:21:27 <dons> maybe it works
23:21:41 <dons> it would be nice for say, Ord
23:21:52 <dons> where we can change to a more efficient data structure to implement, e.g. nub
23:21:59 <dons> :t nub
23:22:02 <lambdabot> forall a. (Eq a) => [a] -> [a]
23:22:22 <dons> {-# RULES nub = ordNub :: (Eq a, Ord a) => [a] -> [a] #-}
23:22:25 <bitwiseshiftleft> nah, it's giving me the same error
23:22:30 <dons> where ordNub uses a Map.
23:22:50 <bitwiseshiftleft> yeah, that would be a cool change...
23:22:53 <dons> bitwiseshiftleft: try asking on glasgow-haskell-users@, see what SPJ says.
23:23:09 <bitwiseshiftleft> ah, yeah, right, i should be on that list...
23:23:13 <dons> given that [a]  ===>  [Int]
23:23:14 <dons> works
23:23:22 <dons> maybe its not too hard to match on dictionaries too
23:24:46 <dons> kolmodin: thanks for the announcement!
23:25:03 <bitwiseshiftleft> thanks, dons.  i'll ask on users@
23:25:29 <kolmodin> you're welcome
23:25:40 <bitwiseshiftleft> see, i'm writing a reactive arrow library, and i want to specialize some of the operations when they spit out an Eq
23:25:54 <bitwiseshiftleft> so as to not recompute anything depending on that result if it didn't change
23:25:57 <dons> mmm. yes.
23:26:09 <dons> there's lots of good situations we'd like to match on dictionaries
23:26:16 <bitwiseshiftleft> like the nub one
23:26:17 <dons> the other approach would be to use associated types somehow
23:26:32 <dons> since they provide a user land mechanism to specify different representation types/methods
23:26:45 <dons> and are more robust than the rewrite rules approach
23:27:20 <bitwiseshiftleft> hm.  yeah, i can't do that obviously, because i have to satisfy an Arrow instance
23:27:21 <kolmodin> I'm going to Uppsala to help my brother move to his new appartment. see you in a few days!
23:27:24 <dons> e.g. instance Eq a => C a where data MySpecialEqType ; foo :: a -> ... .; foo = mySpecType internally
23:27:28 <dons> kolmodin: ciao!
23:27:35 <bitwiseshiftleft> kolmodin: cya
23:27:41 <kolmodin> ciao!
23:27:57 <sjanssen> matching on dictionaries is probably difficult
23:28:37 <dons> rules aren't really designed for this  (frankly, i'm surprised the mono/polymorphic trick works)
23:28:53 <dons> sjanssen: btw, any thoughts on chris m's X11/xmonad comment on libraries@ ?
23:30:20 <LouieG> what kind of software is written in haskell?
23:30:41 <Hirvinen> Functional ;)
23:30:54 <sjanssen> dons: my thoughts?  I hate Xlib and -package X11
23:31:33 <sjanssen> dons: but I'm not sure what the correct thing to do is
23:31:58 <sjanssen> dons: did you see that the GHC HEAD build failed because of the X11 changes?
23:32:40 <LouieG> Yes functional... the description reminds me of lisp, but the syntax is more conventional.
23:32:59 <LouieG> Does it perform well?
23:33:31 <dons> sjanssen: yeah :/
23:33:39 <dons> i just want 64 bits fixed for xmonad.
23:34:03 <Cale> LouieG: reasonably so
23:34:16 <LouieG> It is interpreted right?
23:34:19 <sjanssen> LouieG: GHC produces very nice code, considering that Haskell is a very high level language
23:34:29 <Cale> There are both compilers and interpreters.
23:34:32 <sjanssen> LouieG: we have both interpreters and compilers
23:34:50 <bitwiseshiftleft> LouieG: Haskell programs can be fast, but the ones produced by GHC tend to use a lot of memory
23:34:56 <dons> bitwiseshiftleft: really?
23:35:04 <dons> we actually do very well on the shootout.
23:35:15 <bitwiseshiftleft> ah.  well, then i retract my statement
23:35:15 <LouieG> bitwise: why is that?
23:35:18 <dons> memory isn't so much the issue. of course, space leaks use memory, and are obvious.
23:35:26 <revence> Lambdamen, by this time we have all heard of FizzBuzz, the programming test, right?
23:35:26 <sjanssen> memory issues are almost always the programmer's fault
23:35:28 <Cale> Hehe, dons is quite good at getting Haskell code which does better than C code. :)
23:35:39 <dons> ?shootout
23:35:39 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
23:35:45 <sjanssen> but they can be particularly tricky to track down in Haskell
23:35:49 <sjanssen> revence: naturally
23:35:55 <bitwiseshiftleft> certainly if you optimize it carefully, haskell does quite well
23:35:58 <revence> let fb = map (\x -> if and $ map (== 0) $ map (mod x) [3, 5] then "FizzBuzz" else if x `mod` 3 == 0 then "Fizz" else if x `mod` 5 == 0 then "Buzz" else show x)
23:36:00 <dons> LouieG: an example of roughly where your haskell programs could possible end up , performance wise.
23:36:05 <dons> is on the shootout ^^
23:36:07 <revence> :t fb
23:36:10 <lambdabot> Not in scope: `fb'
23:36:18 <revence> fb [1 .. 20]
23:36:20 <LouieG> dons: thanks
23:36:24 <Cale> http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
23:36:26 <lambdabot> Title: sum-file benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/o8pll
23:36:57 <dons> LouieG: haskell is a general purpose language, so its used for just about anything these days, from writing kernels and file systems, to compilers, web apps, tetris and chess games :-)
23:37:14 <revence> dons: Kernels?
23:37:18 <Cale> Of course, people have optimised the hell out of those. You tend not to optimise prematurely.
23:37:27 <revence> It is managed, so how do the kernels get a ... host?
23:37:28 <dons> yeah, there's the L4 kernel written in haskell, and the house OS.
23:37:34 <dons> it runs on bare metal
23:37:36 <sjanssen> dons: don't forget window managers!
23:37:41 <dons> oh yeah, window managers.
23:37:43 <dons> and irc bots!
23:37:46 <revence> Holy gusts! Lemme check ...
23:37:46 <dons> > 1+2 -- yow!
23:37:47 <lambdabot>  3
23:37:50 <dons> ?where house
23:37:51 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
23:38:01 <dons> that's a full OS running on bare metal ^^
23:38:17 <dons> there's a few other kernels around too, check haskell.org's 'applications and libraries' page
23:38:18 <sjanssen> the first working implementation of Perl 6 is written in Haskell.
23:38:44 <Cale> also, the darcs revision control system
23:38:49 <bitwiseshiftleft> i'm working on a database in Haskell
23:38:50 <LouieG> haskell functions have no side effects? how does that work? A function that does i/o needs side effects..?
23:39:02 <Cale> LouieG: There's a type for actions
23:39:06 <revence> Pugs. Rocketh hard. That is the only non-functional language (with Ruby) that I'll be willing to punish myself with. Perl 6.
23:39:23 <sjanssen> @type getChar -- is an example of an action
23:39:25 <Cale> That is, essentially abstract representations of programs which run, producing some side effects together with a result.
23:39:26 <lambdabot> IO Char
23:39:26 <bitwiseshiftleft> LouieG: monads take care of that.  kind of hard to wrap your head around, but once you do, thoy're awesome
23:39:28 <revence> There's F# for .NET. OCaml-compatible!
23:39:40 <Cale> Well, just the IO monad in particular.
23:39:55 <Cale> Monads in general are a great way to structure certain types of libraries.
23:40:00 <bitwiseshiftleft> and everything encapsulating IO.  and occasionally ST.
23:40:09 <Cale> yeah
23:40:33 <revence> Eh, dons, I was wondering if I am correct when I say that every function that comes into contact with the IO monad becomes an action?
23:40:41 <Cale> So we have putStrLn :: String -> IO (), and getLine :: IO String
23:41:00 <Pseudonym> revence: It depends what you mean by "comes into contact with".
23:41:00 <dons> revence: hmm, if it does IO, or your lift it into IO, then it becomes an action , you could say that.
23:41:05 <bitwiseshiftleft> revence: an IO a is an action... it's not the function that's the action
23:41:06 <Cale> The first is a function taking a string, and producing an action which prints that string (and returns an empty tuple)
23:41:21 <Cale> and the second is an action which returns a string when run
23:41:29 <Pseudonym> Obviously you can inoke pure code from IO.
23:41:36 <Cale> evaluation doesn't cause those side effects to occur though
23:41:53 <Cale> Only execution does, and in a compiled app, the only action which really executes is main.
23:42:04 <bitwiseshiftleft> conceptually, anyway
23:42:05 <Cale> (though it's generally built out of other actions)
23:42:27 <Cale> There are some basic ways to combine actions into larger ones.
23:42:32 <Cale> One of these is called >>
23:42:33 <revence> Okay. Merci beaucoup, lambdamen.
23:42:53 <Cale> If x and y are actions, then x >> y is the action which performs x, then performs y, returning the result of y.
23:42:55 * revence getHashHaskell >>= mapM hugAndThank
23:43:15 <bitwiseshiftleft> revence: haha :-)
23:43:24 <bitwiseshiftleft> you're welcome
23:43:38 <Cale> Oh, I'll just link you to the thing I already wrote :)http://haskell.org/haskellwiki/Introduction_to_IO
23:43:39 <lambdabot> Title: Introduction to IO - HaskellWiki
23:43:58 <revence> bitwiseshiftleft: putStrLn "Huh?" -- I only speak Haskell.
23:44:16 * sjanssen wonders if LouieG is still following
23:44:29 <jkarres> if anybody here is knowledgeable about parsec, i could use a little help.  I'm working my way through "Write Yourself a Scheme in 48 Hours", and I've decided to post the answers that I'm coming up with on a wiki.  I don't really know if I'm doing things in a sensible way, so would anybody be willing to look over my answers and see if there's a nicer way of doing things?
23:44:34 <Cale> LouieG: That should explain how IO is handled in Haskell in a hopefully not-too-incomprehensible way, and takes about 5 minutes to read.
23:44:44 <ejt_> jkarres: sure
23:44:58 <jkarres> the site is http://en.wikibooks.org/wiki/Haskell/Write_Yourself_a_Scheme_in_48_Hours/Answers
23:45:00 <lambdabot> http://tinyurl.com/2mnth7
23:45:26 <LouieG> Yes actually I'm following, reading up on monads at the moment.
23:46:08 <jkarres> which refers to stuff on http://en.wikibooks.org/wiki/Haskell/Write_Yourself_a_Scheme_in_48_Hours/Parsing
23:46:11 <lambdabot> http://tinyurl.com/yqwjuo
23:46:54 <revence> Monads are used *every single day* on the Unix shell. Think of Awk as the lambda:
23:47:00 <Cale> LouieG: Perhaps check out the link I posted. It's not about monads in general, but I think it's a good example.
23:47:28 <revence> echo Hello | awk '{print "$1 was received"}'
23:48:08 <revence> Even the shell has eta-reduction, in that Awk returns an thing that takes the missing args (input).
23:48:17 <revence> The pipe is the bind.
23:49:10 <revence> It's just that the currying/eta-reduction on the Unix shell has no syntactic sugar, and requires the receiveing function (that is, util) to expect less args and therefore eta-reduce.
23:50:07 <ejt_> jkarres: just 2 answers ?  they look fine so far, only comment would be that most haskellers tend to use ($) to reduce the number of brackets
23:50:24 <LouieG> The operators such as ">>"? are these entirely customizable (>!!>) or must one use a predetermined set of operators like in c++?
23:50:57 <Cale> LouieG: You can define any sequence of symbol characters as an infix operator
23:51:00 <ejt_> eg, many ((many1 (noneOf "`@``")) -> many (many1 $ noneOf "\"\\")
23:51:01 <jkarres> ejt_:  hehe... but those 2 answers took me quite a few hours!
23:51:08 <revence> @src mapM
23:51:08 <lambdabot> mapM f as = sequence (map f as)
23:51:11 <sjanssen> > let (>!!>) x y = x + y in 2 >!!> 10
23:51:12 <lambdabot>  12
23:51:22 <ejt_> jkarres: y, haskell is like that when you start
23:51:28 <Cale> > let x &*< y = x^2 - y^2 in 5 &*< 2
23:51:30 <lambdabot>  21
23:51:35 <bitwiseshiftleft> LouieG: you can also turn regular functions into infixes with `backtics`
23:51:48 <Cale> > 5 `elem` [1,7,3,7,2,5,9]
23:51:49 <bitwiseshiftleft> so if you have a function contains
23:51:50 <lambdabot>  True
23:51:55 <bitwiseshiftleft> er.  what Cale said
23:51:57 <jkarres> ejt_:  so i guess you're referring to x <- many ((many1 (noneOf "\"\\")) <|> escapedChars)
23:52:05 <ejt_> jkarres: I'm still a beginner, but I think I'm now more productive in Haskell than I am in C/C++
23:52:07 <ejt_> jkarres: y
23:52:16 <LouieG> bitwise: very interesting...
23:52:26 <jkarres> ejt_:  how long have you been at haskell?
23:52:28 <Cale> > 12 `mod` 7
23:52:30 <lambdabot>  5
23:52:38 <revence> let fb = map (\x -> if and $ map (== 0) $ map (mod x) [3, 5] then "FizzBuzz" else if x `mod` 3 == 0 then "Fizz" else if x `mod` 5 == 0 then "Buzz" else show x) in fb [1 .. 20]
23:53:29 <sciolizer> Is there a way to say "instance Data SomebodyElsesDataStructure" without hand coding the boilerplate?
23:53:36 <ejt_> jkarres: hard to say, I played with it for a few weeks a while back, then switched to ocaml for a few years, and came back to Haskell about 6 months ago
23:54:10 <Cale> sciolizer: hmm, I don't think so. Someone might have come up with some template haskell trick for it.
23:54:22 <ejt_> jkarres: working through various simple programming challenges help get me up to speed
23:54:31 <sciolizer> Cale: darn
23:55:37 <sjanssen> > let b _="Buzz";f _="Fizz";i=show in unlines$zipWith($)(cycle[i,i,f,i,b,f,i,i,f,b,i,f,i,i,\_->f()++b()])[1..100] -- how about this one, revence?
23:55:39 <lambdabot>  "1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n16...
23:56:09 <Cale> sciolizer: Yeah, at least if all the constructors of the datatype were exported from the module, it would be nice if implementations allowed you to still derive things in later modules.
23:56:38 <Cale> Possibly the only reason they don't is that nobody's cared deeply enough to write it into GHC.
23:57:08 <sciolizer> Cale: I'll do it! (If I only knew C better.)
23:57:22 <Cale> GHC is written mostly in Haskell.
23:57:31 <jkarres> ejt_:  okay, should be a bit more haskelly now;  thanks!
23:57:33 <sciolizer> Cale: Oh... well in that case...
23:57:40 <Cale> It's self-compiling.
23:57:50 <sciolizer> Cale: like all good languages, I guess.
23:57:59 <Cale> yeah :)
23:58:19 <LouieG> (except perl6 I guess)
23:58:52 <Cale> Perl 6 is eventually supposed to have a Perl 6 implementation, I think.
23:58:54 <bitwiseshiftleft> like all good compiled languages, maybe
23:59:08 <ejt_> jkarres: k, it's good that you've got the hang of function composition
23:59:23 <bitwiseshiftleft> interpreted-only languages sort of can't be self-interpreted
23:59:29 <sciolizer> bitwiseshiftleft: pypy?
23:59:34 <jkarres> ejt_ : thankfully that part isn't too tricky
