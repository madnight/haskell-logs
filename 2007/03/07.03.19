00:05:07 <dolio> I must say, the results you get from the latest ruby quiz are quite fun to watch.
00:05:22 <dolio> Maybe I'm odd, though.
00:09:37 <dmwit> ?src Functor
00:09:37 <lambdabot> class  Functor f  where
00:09:37 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
00:09:45 <dmwit> That's short.
00:10:04 <TSC> dolio: It looks like an interesting simulation
00:10:27 <TSC> Maybe a good excuse to learn the opengl bindings for Haskell
00:10:54 <dolio> Yeah, I didn't go that far.
00:11:09 <dolio> There are, apparently, some ruby solutions that actually rendered with OpenGL.
00:48:39 <dons> ?yow
00:48:39 <lambdabot> I'm into SOFTWARE!
01:51:04 <quicksilver> > do { let f = 1; return 1; } :: Maybe Int
01:51:04 <lambdabot>  Parse error
01:51:12 <quicksilver> what's wrong with that?
01:51:38 <dons> the parser we use doesn't like let x = e; syntax
01:51:41 <nornagon> > do { let f = 1; Just 1 }
01:51:41 <lambdabot>  Parse error
01:51:49 <dons> > do let f = 1 in return f :: Maybe Int
01:51:50 <lambdabot>  Just 1
01:51:51 <nornagon> o.
01:51:55 <quicksilver> my ghci doesn't like it either, though
01:52:16 <quicksilver> <interactive>:1:24: parse error on input `;'
01:52:21 <dons> oh, that's interesting.
01:52:34 <dons> yes, i see that here too
01:53:29 <quicksilver> is that not what a let in a do is supposed to look like?
01:53:50 <quicksilver> I thought it was, but maybe it's too early on a monday...
02:09:10 <dolio> > do { let {f = 1} ; return 1 } :: Maybe Int
02:09:12 <lambdabot>  Just 1
02:09:40 <hpaste>  mux pasted "Cairo and arithmetic" at http://hpaste.org/1038
02:10:24 <lome> if every letter of function name `nub` turns 180 degree, we get a better name - `unq`
02:10:27 <mux> if someone can suggest a better use of fromIntegral to limit the noise in this code, I'd be grateful
02:11:15 <mux> @seen dcoutts_
02:11:16 <lambdabot> dcoutts_ is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
02:15:17 <hpaste>  dolio annotated "Cairo and arithmetic" with "slightly better?" at http://hpaste.org/1038#a1
02:15:46 <dolio> ?type min
02:15:48 <lambdabot> forall a. (Ord a) => a -> a -> a
02:15:55 <mux> dolio: heh, I thought about doing that to map fromIntegral in the pair, but it's relly ugly I think
02:16:06 <dolio> :) Yes it is.
02:16:07 <mux> now maybe less than having fromIntegral everywhere
02:16:22 <mux> @let mapPair f (x,y) = (f x, f y)
02:16:25 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
02:16:29 <dolio> Yeah, it's a tough call.
02:17:08 <mux> @let mapPair f p = (f (fst p), f (snd p))
02:17:09 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
02:17:15 <mux> what the hell is wrong with that
02:18:00 <mux> well it works in ghci
02:18:17 <dolio> > let mapPair = join (***) in mapPair (+1) (3, 4)
02:18:18 <lambdabot>  (4,5)
02:21:21 <mux> dolio: that doesn't even work actually
02:21:46 <mux> Main.hs:68:24: Couldn't match expected type `Double' against inferred type `Int' In the second argument of `(/)', namely `svgWidth' In the first argument of `scale', namely `(sideSize / svgWidth)'
02:21:52 <mux> when I map fromIntegral in the pair
02:22:01 <siti> are there any good data structures in haskell for indexing data with multiple keys?
02:22:14 <dolio> Hmm. Maybe I missed one of them?
02:23:24 <mux> actually, yeah, but that's fixed now
02:23:32 <mux> errr
02:23:46 <mux> you didn't miss anything, I failed to see you applied it to svgWidth svgHeight
02:23:56 <mux> which is what I just did as well :)
02:23:57 <mux> thanks
02:23:59 <dolio> Ah. Does it work then?
02:24:51 <hpaste>  mux annotated "Cairo and arithmetic" with "what about this?" at http://hpaste.org/1038#a2
02:24:56 <mux> yes
02:25:59 <dolio> That looks all right to me. It's probably better than sprinkling fromIntegral around in 8 places, at least.
02:26:33 * mux nods
02:27:33 * mux hugs dolio 
02:27:44 <mux> now moving onto something next
02:27:56 <dolio> :)
02:28:00 <mux> I probably want a GtkViewport instead of a GtkDrawingArea
02:28:07 * mux goes to read docs
02:28:29 <dons> jcreigh: great. the focus bug seems to have gone.
02:29:18 <mux> it's a real pleasure to use gtk2hs
02:29:49 <mux> the code is written quickly, as with Perl and the Gtk2 module, but you also get type-safety
02:30:55 <hpaste>  mux annotated "Cairo and arithmetic" with "better formatting" at http://hpaste.org/1038#a3
02:36:05 <Kobold_> I have a goofy question about compiler implementation... (this seems like as good a place as any to ask)
02:37:24 <Kobold_> I have a really odd architecture that I have to deal with through all ASM code for about 30kLOC. It doesn't seem worth it to port one of the back ends of a real compiler to the arch.
02:37:30 <dolio> ?src liftM
02:37:31 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:37:52 <quicksilver> dolio: thanks  (let inside do)
02:38:03 <dolio> No problem.
02:38:05 <Kobold_> But if I wanted to write a small compiler, would the fastest way just be to do an imperative language, and compile it to a stack machine?
02:38:26 <quicksilver> fastest in your time? or fastest in execution time?
02:38:39 <quicksilver> fastest in programmer time is probably a simple evaluator/interpreter...
02:38:53 <Kobold_> Fastest in my time. I plan on generating piss poor code. :-P
02:39:14 <siti> haskell + parsec = dream
02:39:27 <mux> oh yes
02:39:50 <Kobold_> I <3 parsec. This is a low level thing though, an interpreter would be a pain.
02:40:04 <siti> ok
02:40:06 <mux> Parsec is so great I'd like it to be named Parsex
02:40:13 <Kobold_> mux: ++
02:40:29 <mux> @karma+ Parsex
02:40:29 <lambdabot> Parsex's karma raised to 1.
02:40:48 <mux> to not be confused with `par` sex :D
02:41:22 <Kobold_> I want to do a minimal functional language, like in wadler's implementing functional languages thing, but the price of admission seems to be higher.
02:41:45 <Kobold_> or rather, SPJ, not wadler
02:43:54 <quicksilver> Kobold_: rather depends how clever you're trying to be
02:44:08 <quicksilver> Kobold_: a 'naive' functional language implemented as a 'naive' graph reducer is very very easy
02:44:27 <quicksilver> Kobold_: most of SPJ's book is about making it less naive and more efficient
02:46:49 <Kobold_> quicksilver: I'll have a real read through it. I've probably only spent an hour or two looking at it. Ideally I'd like the compiler to come in at under 1kLOC of haskell (which is a lot).
02:50:00 <quicksilver> Kobold_: an interpreter for lazy lambda calculus can be under 200 lines, including parsing and pretty-printing.
02:50:15 <quicksilver> Kobold_: add a little more if you have a complex type inference scheme in mind
02:52:04 <Kobold_> quicksilver: na, typing was gonna be very simple. I think I will switch up to an interpreter though. The main problem is that as of now I don't have a real IO lib. :-D
02:53:12 <Kobold_> quicksilver: Essentially this is a project to build a modern computer infrastructure (up to a reasonably high language level) in a way comprehensible to an undergrad with a few mos.
02:54:30 <Kobold_> quicksilver: The processor is essentially a closer to modern ISA duct taped onto microcode via Verilog in an FPGA, duct taped onto an odd memory. :-P
02:54:55 <Kobold_> quicksilver: So I have to write routines even to write to the screen.
03:02:23 <narain> ?users
03:02:23 <lambdabot> Maximum users seen in #haskell: 336, currently: 303 (90.2%), active: 28 (9.2%)
03:07:08 <dolio> @quote qwe1234
03:07:09 <lambdabot> qwe1234 says: just because it's inflammatory doesn't mean it's wrong
03:26:10 * mux wonders if the laptop will have finished its update to gnome 2.18 during lunch
03:26:14 * mux doubts it
03:35:06 <LPhas> Hi
03:37:16 <vincenz> ADEpt: ping
03:37:24 <vincenz> ADEpt: @join #oasis
03:37:43 <LPhas> I'm looking on the SoC trac
03:37:53 <LPhas> there isn't a lot of proposal, indeed
03:51:20 <vincenz> @seen dmhouse
03:51:20 <lambdabot> I saw dmhouse leaving #happs, #haskell-blah and #haskell 19h 22m 18s ago, and .
03:58:23 <LPhas> there's a lot of life right here, uh?
03:59:35 <quicksilver> hell yeah
03:59:45 <quicksilver> it's just too small too see
03:59:51 <quicksilver> teaming with micro-lambdas
04:19:07 * mux notes a lot of interest in chess in the haskell community
04:23:43 <LPhas> hi dcoutts
04:23:51 <dcoutts> hia
04:25:53 <kolmodin> hia dcoutts
04:25:56 <kolmodin> ?localtime dcoutts
04:25:57 <lambdabot> Local time for dcoutts is Mon Mar 19 22:24:40
04:25:58 <lambdabot> Local time for dcoutts is Mon Mar 19 22:24:40
04:26:04 <dcoutts> g'evening
04:26:32 <dcoutts> LPhas: easiest to ask here, that way other people can share suggestions
04:27:23 <dcoutts> LPhas: what kind of project would you be interested in? how do you feel your Haskell hacking skills are?
04:27:59 <LPhas> dcoutts: oh, ok, i was asking to you because i know you are on gtk2hs (if i'm not wrong) and C-Haskell bindings and i made something on that
04:28:34 <LPhas> so i thougth that maybe you had "some work" for me
04:28:47 <dcoutts> LPhas: right, so do you have any particular interest / knowledge about some area you might be able to turn into a successful project
04:28:49 <dcoutts> hmm, I see
04:29:17 <dcoutts> well there's the project to make a Language.C library
04:29:48 <dcoutts> it got funded last year but the chap had to withdraw for personal reasons so it didn't get finished
04:30:45 <LPhas> dcoutts, http://darcs.haskell.org/SoC/Language.C/ <----- this?
04:30:45 <lambdabot> Title: Index of /SoC/Language.C
04:30:51 <dcoutts> right
04:31:51 <LPhas> an haskell C parser?
04:32:13 <dcoutts> that project would be easier this year than last since I've just got the first version of a full C parser that can parse the kernel and glibc etc
04:32:37 <dcoutts> but there's still plenty of work to turn that into a reusable, generally useful library
04:33:01 <dcoutts> LPhas: yes, a parser and AST for the C language written in Haskell
04:33:41 <LPhas> AST?
04:33:50 <dcoutts> Abstract Syntax Tree
04:34:34 <dcoutts> as for Gtk2Hs, I can't think of any nice self-contained projects off the top of my head at the moment
04:34:34 <kolmodin> LPhas: the representation of the syntax as a datastructure
04:34:50 <LPhas> oh, ok, i know what it's
04:35:40 <dcoutts> LPhas: what kind of Haskell coding have you done before ?
04:36:40 <LPhas> dcoutts, uhm, little. i wrote a C litte C-binding to libid3. a little popup app
04:37:20 <LPhas> and a little app to monito work load on a cluster
04:37:21 <dcoutts> id3, the thing to get meta-data out of .mp3 files right ?
04:37:26 <LPhas> yes
04:37:29 <dcoutts> ah, networking
04:37:37 <LPhas> esactlu
04:37:44 <LPhas> exactly
04:37:53 <LPhas> i used a little of Parsec, also
04:38:12 <dcoutts> well there's also the project to do a parser on top of ByteStrings
04:38:23 <dcoutts> or develop the Binary library further
04:38:31 <dcoutts> or do fusible unicode strings properly
04:38:54 <dcoutts> or several networking things
04:39:05 <dcoutts> but I'm not the best person to ask about networking
04:39:14 <LPhas> ok
04:39:49 <kolmodin> .. there is also the issue of getting ghc 6.6 into gentoo ... :D
04:40:18 <LPhas> what kind of work there'll be to do on yours Language.C?
04:41:20 <araujo> morning!
04:41:42 <LPhas> and you can mentoring me if i apply on it?
04:44:38 <LPhas> (sorry for my english, i'm sleepy this morning)
04:58:27 <dcoutts> LPhas: designing a decent AST, getting a decent testing framework, polishing, adding a pretty-printer, adding utility functions to traverse the AST, to detect syntax that is valid GNU C but not valid C99 etc
04:58:50 <LPhas> well, sounds interesting
04:58:55 <dcoutts> LPhas: basically turning if from a prototype to a working useful library that other people can pick up and use
04:59:06 <LPhas> mi lesson is finished so i have to stop leeking wi-fi from here
04:59:13 <dcoutts> you'd need to understand a bit about grammars and happy / alex
04:59:21 <dcoutts> oh and doing performance tuning
04:59:27 <dcoutts> which is always fun :-)
04:59:41 <LPhas> i know a little about grammars, nothing of happy alex (but i can learn)
04:59:46 <LPhas> i'll send you a mail
04:59:48 <LPhas> see you
04:59:51 <dcoutts> ok
05:00:23 <vincenz> dcoutts: you're overviewing that?
05:00:47 <dcoutts> vincenz: not especially, though I sort of helped with it last year
05:00:59 <dcoutts> I've not comitted to helping on any particular project yet
05:01:04 <dcoutts> that comes much later
05:01:08 <vincenz> dcoutts: using a GADT ala bringert's icpf'06 paper for AST representation would be neat
05:01:26 <vincenz> what am I looking at?
05:01:28 <vincenz> wrong channel
05:01:34 <dcoutts> I should probably read that then right ?
05:01:40 <vincenz> dcoutts: it's interesting
05:01:45 <vincenz> I use it for most of my aST implementations
05:01:48 <dcoutts> what's the basic idea ?
05:01:49 <vincenz> though I have extended his technique
05:02:01 <dcoutts> remember that C types are a tad fuzzy
05:02:27 <vincenz> dcoutts: the basic idea is that you define one ADT for all what's in the AST, but different dataconstructors have difeferent types, so you still have typesecurity.  And then you can easily write functions to do traversal
05:03:46 <quicksilver> dcoutts: is the gtk2hs OpenGL widget using the existing HOpenGL bindings, or has it been re-bound?
05:04:06 <dcoutts> quicksilver: you use HOpenGL with it
05:04:16 <quicksilver> cool
05:04:29 <dcoutts> so it basically replaces the GLUT layer with a proper toolkit
05:05:16 <dcoutts> quicksilver: you on win32? I can show you a demo
05:05:43 <quicksilver> dcoutts: happily not :) (perhaps sadly in this case, though)
05:06:09 <dcoutts> sadly this demo doesn't have source available since we use it for teaching so don't publish the source
05:06:12 <quicksilver> I wrote the beginnings of an openGL game with haskell a couple of years ago
05:06:24 <quicksilver> I didn't need a toolkit then
05:06:27 <dcoutts> you've seen frag I presume
05:06:31 <quicksilver> it didn' have a UI :)
05:06:37 <dcoutts> :-)
05:06:39 <quicksilver> well, i've seen the frag screen shots
05:07:04 <quicksilver> [my program] was mainly a test of doing something fun in haskell
05:07:18 <quicksilver> I was quite boggled at how much more pleasant it is even writing imperative code, in haskell
05:07:29 <quicksilver> OpenGL in C has so much boilerplate
05:07:44 <quicksilver> and in C you can't spot a repeating pattern in lines of code and map/mapM over them :)
05:08:30 <dcoutts> aye, Haskell is indeed a fine imperative programming language
05:08:53 <quicksilver> I wrote a hybrid Java/SML program when I was an RA
05:09:04 <quicksilver> and I saw then that (even) SML is a better imperative language than Java
05:09:18 <quicksilver> my tendency was very much to keep moving code from the java side to the SML side
05:09:31 <siti> haskell is insane, every single day I am amazed at how awesome it is :D
05:13:27 <ToRA> > runListT (do { x <- ListT . return $ [1,2,3] ; y <- ListT . return $ [1,2,3] ; guard (x == y) ; return (x,y) })
05:13:28 <lambdabot>   add an instance declaration for (Show (m [(a, a)]))
05:13:34 <ToRA> mmm
05:14:02 <ToRA> odd, ghci will show that for me
05:14:25 <ToRA> anybody have an intuitive reason why I need the (ListT . return $) around the lists I'm pulling out?
05:14:29 <mux> dcoutts: hey!
05:14:44 <dcoutts> mux: hia
05:15:14 <mux> dcoutts: I've been looking for you for days so that you can take a look at my cairo usage and tell me if it's good :-)
05:15:18 <ToRA> given that I don't need to do extra magic when going from a State to StateT?
05:15:27 <dcoutts> mux: oh aye?
05:15:27 <mux> dcoutts: I see you saw my mail on -cafe
05:15:32 <dcoutts> yep :-)
05:15:40 <dcoutts> mux: yeah, I'm still tying to get people to write / give us screenshots etc
05:15:50 <mux> I'm not sure I'm doing things properly, if you could give it a shot that would be nice
05:15:57 <quicksilver> never underestimate the value of real eyecandy
05:15:57 <dcoutts> url?
05:16:01 <mux> I can sure make screenshots afterwards; it's a bit empty to do some for now
05:16:05 <dcoutts> quicksilver: quite :-)
05:16:08 <mux> dcoutts: http://mu.org/~mux/LambdaChess/
05:16:09 <lambdabot> Title: Index of /~mux/LambdaChess
05:16:10 <dcoutts> mux: sure
05:16:13 <mux> the cairo code is in Main.hs
05:16:14 <quicksilver> us serious people all know that appearance isn't *really* important
05:16:20 <mux> it's very small actually
05:16:39 <mux> dcoutts: see setupBoard
05:17:02 <mux> for now my UI is a shameless copy of the one in glChess :D
05:17:28 <quicksilver> but somehow when you see a program which looks *really* beautiful and didn't require much code, you can't help being impressed with the language/library/system
05:17:32 <dcoutts> mux: the code looks fine to me
05:17:46 <mux> dcoutts: should I be using a GtkDrawingArea?
05:17:47 <dcoutts> nice and short :-)
05:17:54 <dcoutts> yep
05:18:14 <mux> great, glad to know, thanks :)
05:18:26 <dcoutts> that's the standard blank widget you can do custom drawing on
05:18:51 <mux> dcoutts: I think I'm supposed to use save/restore to improve performancce
05:18:52 <siti> lol I just copied glchess with my draughts app :D
05:18:57 <mux> siti: heh
05:19:15 <dcoutts> mux: I don't see where it'd help
05:19:44 <mux> dcoutts: well I think it would help in the future when moving pieces only, so that we don't redraw the whole board
05:19:49 <dcoutts> mux: if drawing that svg is slow you can cache it in a temporary surface
05:19:56 <dcoutts> right
05:20:22 <mux> I need to complete my PGN/SAN parser, and this can make a nice little "PGN browser" kind of application
05:20:25 <dcoutts> mux: see the clock demo, it caches static things in temporary surfaces to get good performance with complex drawings
05:20:26 <mux> the rest can come later
05:20:33 <mux> dcoutts: oki, thanks
05:20:35 <siti> what I done with my draughts app is make a static temp image when animation was happening...
05:20:47 <siti> and the pieces and the static image would just be rendered each time
05:21:28 <mux> dcoutts: I hope I'll be able to raise enough interest so taht I get help in writing this; it's fun but it's going to take ages if I'm the only one working on it, and on my freetime furthermore
05:21:40 <tibbe> @srcs append
05:21:40 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:21:52 <tibbe> @srcs concat
05:21:52 <lambdabot> concat = foldr (++) []
05:21:57 <mux> dcoutts: btw, using cairo and svgcairo with gtk2hs was just a breeze
05:22:08 <siti> mux: help me on my draughts app ;)
05:22:09 <mux> once I got a grip on how cairo's working, it was delightful
05:22:20 <mux> siti: what's your problem?
05:22:31 <siti> I don't have one it was just a joke
05:22:35 <mux> heh
05:22:40 <dcoutts> mux: great :-)  you could collaborate with the others doing the chess stuff, you do the ui, they can do the other stuff or something.
05:22:43 <mux> help me with LambdaChess then :
05:22:44 <mux> :)
05:23:04 <mux> dcoutts: yep, that's why I'm thinking, since this guy seems to already have a move generator and a few things
05:23:05 <siti> but you should see the code anyway because you will have very similar ideas with chess
05:23:08 <mux> s/why/what/
05:23:33 <mux> siti: you are the hschess guy?
05:23:38 <siti> no
05:23:59 * mux watches build of GNOME 2.18 still going on
05:24:06 <russo> > 256 / 8
05:24:08 <lambdabot>  32.0
05:25:17 <mux> dcoutts: this code could be a nice gtk2hs/glade/cairo/svg demo + a nice Parsec demo once it's done
05:25:46 <mux> the downside is that using Parsec and GTK+, I've written nearly only monadic code :)
05:27:00 <quicksilver> dcoutts: did you catch my idea for a heap visualiser? that would be a fun gtk2hs demo
05:27:28 <siti> parsec is the bet thing ever :p monads are good
05:35:44 <LoganCapaldo> Whose writing a raytracer in the type system? Sounds like a C++ template trick.
05:36:48 <quicksilver> C++ templates are haskell-as-a-mini-language, almost
05:36:52 <quicksilver> (well not quite :)
05:38:36 <LoganCapaldo> I'm sorry I was confused, its a _D_ template trick http://www-users.mat.uni.torun.pl/%7Eh3r3tic/ctrace/
05:38:38 <lambdabot> Title: ctrace
05:49:12 <tibbe> > let concatPairs = foldr appendPairs ([], []); where appendPairs (xs, ys) (xs', ys') = (xs ++ xs', ys ++ ys')
05:49:12 <lambdabot>  Parse error
05:49:25 <tibbe> > let concatPairs = foldr appendPairs ([], []);      where appendPairs (xs, ys) (xs', ys') = (xs ++ xs', ys ++ ys')
05:49:26 <lambdabot>  Parse error
05:49:28 <tibbe> bah
05:49:51 <mux> am I the only one thinking it slightly sucks that we don't have any standard function for applying a function to both elements in a pair? other thn join (***)
05:50:14 <tibbe> mux: I use *** quite often for just that
05:50:19 * QtPlatypus blinks "Thats smarter then i expected of firefox.  I accedenty cut and pasted f∑(x∑f (x x)) (x∑f (x x)) into the address bar.
05:50:23 <tibbe> the Arrow import looks scary though ;)
05:50:44 <QtPlatypus> And up popped the wikipedia page on fixed point combinator
05:50:46 <mux> tibbe: I think join (***) foo pair  looks even scarier :)
05:50:59 <tibbe> @hoogle (&&&)
05:51:00 <lambdabot> Did you mean: (&&&)
05:51:00 <lambdabot> Prelude.undefined :: a
05:51:00 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
05:51:04 <wilx|wrk> Make a TH function for that.
05:51:18 <tibbe> @hoogle Control.Arrow.(&&&)
05:51:19 <lambdabot> Hoogle Error: Parse Error: Unexpected character '&&&)'
05:51:24 <tibbe> @hoogle &&&
05:51:24 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
05:51:32 <rubenz> How canI get access to the standard Haskell complex numbers code (is it in a file Complex.hs?)
05:51:34 <tibbe> @hoogle ***
05:51:35 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:51:44 <rubenz> I want to make a Quaternions module
05:52:13 <tibbe> @hoogle (a -> b) -> (a, a) -> (b, b)
05:52:13 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
05:54:58 <dons> hmm. looks like an arrow
05:55:45 * tibbe curses Python for not having sections.
05:56:54 <QtPlatypus> Sections?
05:59:08 <tibbe> > map (+ 1) [1,2,3]  -- QtPlatypus, (+ 1) is a section, a partial application of an operator
05:59:09 <lambdabot>  [2,3,4]
05:59:40 <xs> @libsrc Data.Complex
05:59:40 <lambdabot> Unknown command, try @list
05:59:47 <xs> @src Data.Complex
05:59:47 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:00:19 <tibbe> Recently heard on #python:
06:00:23 <tibbe> "You need to upgrade your feelings."
06:00:30 <tibbe> "The old version is deprecated and only works with Haskell."
06:01:05 <xs> rubenz, try http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Data/Complex.hs?rev=1.10.2.1;content-type=text%2Fplain
06:01:08 <lambdabot> http://tinyurl.com/2y9qhy
06:01:10 <tibbe> When I said sum() feels a bit ugly as a stand in for concat
06:09:09 <chessguy> 'morning, haskellers
06:09:19 <chessguy> ?losers
06:09:19 <lambdabot> Maximum users seen in #haskell: 336, currently: 309 (92.0%), active: 27 (8.7%)
06:12:43 <quicksilver> Is 'Matthew Brecknell' known to IRC?
06:14:11 <guenni> hi guys
06:14:19 <guenni> and girls if present
06:15:44 <guenni> any recommendations which editor to use for haskell?
06:15:52 <xs> emacs
06:15:53 <xs> vim
06:15:58 <chessguy> gedit :)
06:16:07 <simon__>  kate
06:16:13 <guenni> sry hate to admit it I'm using
06:16:15 <guenni> Windows
06:16:23 <guenni> sry don't kill me
06:16:24 <ikegami--> no one recommends ed
06:16:32 <xs> nah, ed sucks
06:16:34 <xs> ex is good.
06:16:39 <guenni> ex?
06:17:10 <xs> it's like ed, but better
06:17:38 <guenni> link pls?
06:17:56 <xs> heh, it's an old unix thing, sorry :)
06:17:57 <quicksilver> if you're using windows, the answer is still emacs ;)
06:18:11 <quicksilver> you may have to reorient your brain to cope with the UI
06:18:18 <quicksilver> but in the long term it will be good for you :)
06:18:58 <guenni> well I used Xemacs while doing Linux
06:19:53 <guenni> thanks for the tip then quciksilver
06:20:00 <quicksilver> in that case (assuming you got along ok with it) I would defeinitely suggest emacs under windows
06:20:17 <huschi> what's the "best" way to remove n elements at the end of a list?
06:20:17 <huschi> reverse . drop n . reverse?
06:20:17 <huschi> or \xs -> take (length xs-n) xs
06:20:18 <goban> eclipse good 4 haskell
06:20:20 <guenni> ok, will give it a try
06:20:23 <vincenz> guenni: gvim works on windows
06:20:38 <vincenz> guenni: and there''s also emacs for windows if you're an emacser
06:20:43 <vincenz> but quicksilver already said that
06:20:44 <rjeq> relatedly, does anyone know how to get good indenting with vim?
06:21:08 <quicksilver> huschi: depends what you mean by 'best'
06:21:22 <guenni> am a bit spoiled as far as IDE is concerned after years of Smalltalk
06:21:38 <quicksilver> huschi: if you are so vitally worried about performance that you can't bare to traverse the list twice, then a custom recursion would do it
06:21:50 <quicksilver> huschi: otherwise, take (length xs - n) is fine
06:21:52 <earthy> visual studio with visual haskell actually is quite good
06:22:28 <guenni> true, but only apparently if you have the real thing (VS) and not VS Express
06:22:39 * earthy would say that if you are on windows and you don't yet live in emacs or vi then visual studio with visual haskell is The Way To Go for Haskell development
06:22:59 <earthy> wouldn't know about that
06:23:04 <earthy> I'm on mac os x and live in vi. :)
06:23:19 <nominolo> if someone has some ideas of smallish haskell projects (ie. 2-3 weeks fulltime, but not SoC-sized) feel free to state them now :)
06:23:26 <quicksilver> earthy: only if you're prepared to pay $1,000,000 for visual studio, or steal it :P
06:23:30 <guenni> and vi is ok with code completion and so on?
06:23:38 <huschi> quicksilver: thx.
06:23:57 <earthy> guenni: well, code completion... there is identifier search, which works
06:24:21 <earthy> but there isn't a good omni completer yet (which would give *much* nicer options)
06:24:30 <earthy> and it doesn't do on the fly syntax checking at all
06:24:35 <earthy> but it does do syntax highlighting
06:24:46 <earthy> much the same holds for emacs btw
06:25:06 <guenni> so no editor for haskell is doing more than syntax highlighting?
06:25:16 <earthy> well, visual haskell
06:25:19 <earthy> programmatica
06:25:41 <quicksilver> the emacs mode does more
06:25:52 <earthy> yeah, obviously
06:25:57 <earthy> the vim mode does more as well
06:25:58 <quicksilver> it uses an inferior haskell process to get the types of identifiers
06:26:19 <earthy> just not that much more. ;)
06:26:35 <guenni> autsch
06:26:40 <quicksilver> personally I think the line-up of = signs in definitions is pretty cool
06:26:57 <guenni> which one does that?
06:27:01 <quicksilver> emacs
06:27:04 <earthy> both vim and emacs :)
06:27:11 <earthy> vim requires an extra plugin though
06:27:17 <quicksilver> and the use of standard emacs commands to do things like transpose valid sub-expressions
06:27:29 <quicksilver> or bracket (parenthesise) the next 'n' sub-expressions
06:27:47 <quicksilver> these are significant value over mere syntax highlighting, for me
06:27:53 <earthy> that's an emacs nicety yeah
06:28:05 <earthy> (derives from the ability to do lisp editing well)
06:28:10 <guenni> so when it comes to IDEs for haskell there's no "silver bullet"?
06:28:13 <earthy> vim doesn't have that
06:28:16 <quicksilver> and the indent-thing, whilst not *quite* perfect helps a lot with understand the indentation rule
06:28:17 <earthy> nope
06:28:24 <quicksilver> since it actually shows you all the different possibilities
06:28:31 <quicksilver> which helps a lot in understanding what it's all about
06:28:47 <LPhas> there are visual haskell and haskell eclipse
06:29:18 <guenni> hm sounds good, have you tried eclipse?
06:29:29 <rjeq> i tried emacs for a little and found that even with the indenter, i had to press tab every line to indent. is that normal?
06:29:31 <LPhas> i never tried visual haskell because i'm on osx but eclipse is quite good
06:29:33 <earthy> the eclipse stuff is not quite mature
06:29:57 <LPhas> it'll be cool to have cabal+darcs supported in eclipse haskell
06:30:14 <LPhas> *CLICK* make a cabal package
06:30:20 <LPhas> *CLICK* make a patch
06:30:27 <LPhas> *CLICK* update the remote repository
06:31:28 <quicksilver> rjeq: that's configurable
06:31:38 <quicksilver> rjeq: by long-standing tradition, emacs modes always *default* to that
06:31:47 <quicksilver> rjeq: and bind C-j to 'newline-and-indent'
06:31:53 <quicksilver> rjeq: which is probably what you were expecting
06:31:59 <quicksilver> but it's customisable of course
06:32:10 <rjeq> i've been a long-time vim user, is it worth switching to emacs for haskell?
06:32:17 <earthy> rjeq: nope
06:32:24 <quicksilver> rjeq: yes
06:32:25 <quicksilver> :)
06:32:30 <quicksilver> just so you get a balanced view
06:32:35 <earthy> it is worth hunting around (or asking me) for some support code
06:32:36 <earthy> ;)
06:34:12 <earthy> but, switching from vim to emacs is a *big* task
06:34:27 <earthy> and it won't gain you any productivity in any real sense
06:34:48 <guenni> are people here mostly unixers?
06:34:57 <earthy> not that I know
06:35:18 <guenni> I mean using haskell on Linux/Unix?
06:35:31 * mux is a unixer
06:35:45 <mux> I think a fair amount of people in here are under Windows
06:36:08 <guenni> good
06:36:22 * ndm is a windows user
06:36:44 <guenni> cause in that case people here will probably have some GUI/Haskell experience then?
06:36:58 <ndm> guenni: Gtk2Hs is the answer
06:37:08 * sioraiocht thinks Windows is Satan
06:37:18 * LPhas agrees
06:37:32 * mux hasn't touched a windows box in a loooong time
06:37:32 <quicksilver> I'm a 'unixer' but using OSX at the moment
06:37:37 <quicksilver> for pragmatic reasons
06:37:53 <sioraiocht> quicksilver: OSX is darwin for most practical purpose
06:37:53 <dylan> I was using OSX, but it sort of... broke
06:38:09 <LPhas> osx makes me crazy with gtk2hs
06:38:09 <dylan> it had too many package management systems installed.
06:38:13 <mux> *plonk*
06:38:27 <LPhas> dylan, heh, i know what you mean
06:38:33 <guenni> ndm: that works with windows too?
06:38:46 <ndm> @where guihaskell
06:38:46 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php
06:38:59 <sioraiocht> guenni: GTK will work on almost all platforms, including windows
06:39:00 <guenni> ndm: sry?
06:39:02 <quicksilver> pretty boggling that they didn't include a decent package manager with OSX; I had always assumed that was their intention when they hired one of the original dpkg authors
06:39:10 <ndm> guenni: take a look at those screen shots - i wrote the code under windows with Gtk2Hs, works flawlessly on Linux as well
06:39:20 <sioraiocht> quicksilver: agreed! and macports SUCKS
06:39:32 <ndm> guenni: when using Gtk2Hs, you can develop on either, its quite impressive
06:40:03 <mux> hmm, that's pretty good news, neil
06:40:24 <quicksilver> ndm: (Please take this question in the spirit of genuine scientific enquiry and not as adversarial as it sounds) What's the point of GuiHaskell?
06:40:30 <guenni> ndm: thx
06:40:47 <ndm> quicksilver: replacing WinHugs, written in Haskell instead of C, working on Windows/Linux/Mac, and with all compilers/interpetters
06:40:58 <mux> I'll have to test my gtk2hs code under Windows/Mac
06:41:10 <ndm> quicksilver: unless you can see why WinHugs is better than command line hugs, you won't understand
06:41:28 <quicksilver> ndm: well I never used winhugs so I'm probably badly informed; can you outline why?
06:41:36 <sioraiocht> ndm: Why would it be? For that matter, why is hugs better than ghci?
06:42:02 <sioraiocht> (I'm afraid I'll probably reveal some haskell na√Øvete here)
06:42:03 <ndm> quicksilver: easier, more gui - drag and drop to open files, automatic reloading, more comfortable user interface, better integration with the rest of the desktop etc
06:42:07 <earthy> it isn't per se
06:42:17 <ndm> sioraiocht: winhugs, not hugs - winhugs is a GUI around hugs
06:42:22 <earthy> however, winhugs' interface is much cuddlier than ghci's
06:42:50 <ndm> it basically comes down to cuddlieness, as earthy says - for some people they won't notice the difference, for those that do its like a safety blanket
06:43:13 <ndm> plus you can tack great features in, like one click profiling/building/debugging/space-leak detection etc.
06:43:34 <quicksilver> only then does it become interesting :)
06:43:39 <ndm> adding --profile isn't giving an option that anyone can use, cause no one will know it exists
06:43:56 <ndm> adding a button called "time profile" under the profile section makes it really obvious
06:44:19 <guenni> ndm: that looks good
06:44:24 <ndm> quicksilver: yes, you need the basics first, then you can start to add the really interesting things in about 10 lines of code each (its simply reading a manual to find the flags)
06:45:47 <ndm> guenni: not finished yet, if you are a windows user who wants a similar thing, winhugs has some of it now
06:45:49 <ndm> @where winhugs
06:45:50 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
06:46:13 <guenni> ndm: no I meant gtk2haskell
06:46:23 <ndm> guenni: oh, it is
06:47:19 <guenni> I mean if I ever was to create a standalone haskell gui app it would be possible with gtk2haskell
06:47:35 <guenni> that is a bit of a concern to me
06:47:58 <ndm> yes, it is
06:48:12 <ndm> and in fact, its getting substantially easier by the day
06:48:13 <guenni> uff, thanks that *is* good news
06:48:33 <ndm> dcoutts has an installer that will take your gtk app and make an installer with no dependancies
06:48:41 <earthy> so, does gtk2haskell have native Mac OS X widgets already?
06:48:58 <guenni> so all I need right now is to get a good editor set up and keep going
06:49:52 <earthy> any text editor that you are already comfortable in is a good one.
06:50:23 <guenni> well as I said I've been doing Smalltalk for the last years and thus had no need for editors
06:50:59 <guenni> so I have to get back to using editors again
06:52:16 <guenni> vincenz I can't send pr msgs yet
06:52:37 <earthy> register with nickserv
06:53:09 <ndm> guenni: i use textpad, a nice editor for windows
06:53:15 <vincenz> guenni: well answer here then :
06:53:16 <vincenz> :)
06:53:38 <guenni> Dolphin Smalltalk and VisualWorks
06:59:53 <petekaz> can you 'flip' the function 'fix'?  I'm confused.
07:00:06 <petekaz> fix only takes one arg.
07:00:24 <ndm> @type fix
07:00:26 <lambdabot> forall a. (a -> a) -> a
07:00:28 <ndm> @type flip fix
07:00:30 <lambdabot> forall b c. b -> ((b -> c) -> b -> c) -> c
07:00:48 <ndm> petekaz: only if the a type to fix is actually a function
07:01:36 <petekaz> I'm confused.
07:02:45 <ndm> fix takes a function, and returns an answer
07:02:46 <Lemmih> petekaz: Notice how '(a -> a) -> a' is similar to '((b -> c) -> b -> c) -> b -> c'?
07:03:00 <ndm> if the function itself operates on functions, then you'll end up with a function
07:03:19 <petekaz> I see
07:03:30 <petekaz> so flip is really just flipping the resulting function.
07:04:51 <ndm> can GHC be faster in profiling mode than -O?
07:05:14 <quicksilver> petekaz: not quite
07:05:18 <quicksilver> petekaz: that would be flip.fix
07:05:27 <quicksilver> :t flip.fix
07:05:30 <lambdabot> forall a b c. ((a -> b -> c) -> a -> b -> c) -> b -> a -> c
07:05:40 <Lemmih> @type (fix :: ((b -> c) -> b -> c) -> b -> c)
07:05:42 <lambdabot> forall b c. ((b -> c) -> b -> c) -> b -> c
07:07:45 <chessguy> some good haskell chess discussions going on on the mailing list. it's about time!
07:09:16 <rjeq> if i /msg lambdabot with @list, it returns a url that gives me a 404
07:09:19 <rjeq> *403
07:09:24 <rjeq> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:11:00 <quicksilver> chessguy: does 'some good discussions' mean 'lots of posts from you' ? :P
07:11:53 <mightybyte> chessguy: Which mailing list?
07:12:10 <quicksilver> mightybyte: -cafe
07:15:17 <chessguy> and haskell@haskell.org too
07:15:20 <chessguy> and no, it's not just m
07:15:21 <chessguy> e
07:16:36 <lollicide> anything on haskell and go? :)
07:17:27 <chessguy> nothing i've heard
07:17:48 <ndm> lollicide: some haskell jobs have required you to give a go ranking on your application form - it is quite popular
07:18:52 <quicksilver> chessguy: I was joking :P
07:19:08 <quicksilver> I believe it's thought to be quite hard to write go AI
07:19:11 <lollicide> ndm, hah.
07:19:18 <quicksilver> however, go AIs are better than me :)
07:20:01 <mux> writing a string go AI is one of the biggest unsolved problems of computing, as far as I know
07:20:02 <lollicide> it's very hard.. impossible if you do it brute-force style ‡ la chess. but recent go-playing programs have had some success with monte carlo methods.
07:20:05 <mux> s/string/strong/
07:20:19 <lollicide> esp. on smaller boards.
07:20:29 <quicksilver> mux: FSOV 'biggest' ;)
07:20:53 <mux> FSOV?
07:20:58 <quicksilver> for some values of
07:21:02 <mux> oh, yeah :)
07:21:25 <quicksilver> lollicide: it would be more interesting to have a program which works by pattern-spotting, mostly-independent of position
07:21:28 <nominolo> @seen dons
07:21:28 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1h 26m 30s ago.
07:21:33 <quicksilver> lollicide: which is presumably how humans play it
07:22:26 <mux> go is too hard, let's just write a new chess AI called Deep Lambda
07:22:36 <mux> ;-)
07:22:51 <mightybyte> mux: lol
07:23:26 <quicksilver> mostly-independent because the (e.g.) parity of your distance from the edge matters quite often
07:23:39 <quicksilver> and I presume there are higher-order patterns if you're better at go that a complete beginniner :)
07:23:58 <lollicide> quicksilver, that's mostly what a lot of "go-expert"-type AI programs have been doing afaik.. and it's really hard to make them more intelligent than a casual player.
07:24:06 <quicksilver> lollicide: *nod*
07:26:51 <chessguy> yes, go AI is very hard. the branching factor is an order of magnitude larger than chess
07:27:33 <lollicide> plus, a naive pattern engine (even if fuzzy or neural) would fail with ladders.. or more subtly, with giving up undue outside influence to the other player for largely unimportant local gain. (or failing to use one's own such influence on a larger scale.)
07:33:08 <quicksilver> lollicide: I suspect your intended meaning of 'influence' is exactly the kind of thing it is *extremely* hard to make precise and program :)
07:34:45 <cdsmith> @pl \a b c -> a c (b c)
07:34:45 <lambdabot> ap
07:36:02 <resiak> hrm, ap is S?
07:36:03 <lollicide> quicksilver, yeah, exactly. :) it's very hard even for go players. :p but i think it's also where monte carlo methods have gained marginal ground.. take the current position, play 100 000 games to the end with random play and make a note of where each player ends up getting living stones... this can be used to make sorta influence maps (areas that are more likely than not to end up being one player's.)
07:36:15 <quicksilver> ap in the (->) Monad is S, yes
07:36:35 <quicksilver> lollicide: yes, that's quite clever
07:36:51 <quicksilver> lollicide: although your 'random' play has to have weight probabilities, at least?
07:36:55 <benja_> @tell dons you probably know already, but http://www.cse.unsw.edu.au/~dons/ 403's ("access to /~dons/ failed because search permissions are missing on a component of the path") :-/
07:36:55 <lambdabot> Consider it noted.
07:39:27 <lollicide> quicksilver, random is fastest, but gives the poorest estimate. the more intelligent the play (but still "random") e.g. with a pattern-database, the better the estimate, but it's slower.. so much less simulations to pull averages from... and monte carlo is still insufficient since there are many fights and situations where only a single move will kill/turn the game around completely etc.
07:40:06 <quicksilver> lollicide: *nod*
07:40:32 <lollicide> evaluating the board with monte carlo in the middle of a large-scale capturing race or life & death situation etc. will usually just give wildly misleading results.
07:40:47 <lollicide> so go is indeed a challenge. :) it seems so many branches need to come together..
07:41:03 <quicksilver> in a way it would be sad if monte-carlo was the answer :)
07:41:11 <quicksilver> I mean, monte-carlo is a really elegant and clever technique
07:41:18 <psi> gnu go can beat me :)
07:41:23 <quicksilver> but I'd prefer it if there was a way to 'play like a human'
07:41:32 <quicksilver> psi: yes, computer go can beat me too :) join the club!
07:41:39 <lollicide> i can still beat gnu go at 9 stones, so i'm not worried yet. ;)
07:42:04 <SamB> how does one play gnu go?
07:42:14 <psi> I use cgoban 1
07:42:27 <psi> and the go modem mode, which connects to gnu go
07:42:33 <therp> yes cgoban is nice, or your just invoke gnugo
07:42:33 <quicksilver> There is some theoretical classification of games into 'levels' such that level N+1 beats level N (X% of the time); in this classification go has more levels than almost any other game
07:43:14 <SamB> quicksilver: don't you mean players of a game?
07:43:25 <quicksilver> SamB: yes, sort of
07:43:38 <quicksilver> you classify the game by classifying the players and then counting the number of distinct levels
07:43:53 <SamB> yeah, that
07:44:25 <quicksilver> ISTR go has 2-3 times as many levels as chess, according to this criterion
07:44:29 <quicksilver> and chess has plenty
07:45:13 <lollicide> i think it's mentioned at http://en.wikipedia.org/wiki/Go_ranks_and_ratings
07:45:14 <lambdabot> Title: Go ranks and ratings - Wikipedia, the free encyclopedia
07:45:24 <SamB> what is X?
07:45:32 <lollicide> "Therefore, when converted to be on a similar standard deviation, we can say that chess has a depth of about 10.4 compared to a depth of about 25 for Go."
07:46:05 <chessguy> bah, rating systems aren't important
07:46:35 <quicksilver> chessguy: I didn't claim it was important. I just thought it was interesting as a factoid :)
07:47:04 <SamB> What I want to know is:
07:48:05 <SamB> what happpens if you have A beating B 90% of the time, B beating C 90% of the time, and C beating A 90% of the time?
07:48:05 <chessguy> it looks suspicious to me anyway
07:48:15 <chessguy> SamB, you don't
07:48:21 <quicksilver> SamB: if that was the case, your game wouldn't fit into this structure
07:48:28 <quicksilver> SamB: however that doesn't happen in chess or go
07:48:38 <SamB> quicksilver: are you sure?
07:48:55 <SamB> you underestimate bad players, methinks
07:49:14 <flux-> this sounds like it is somewhat related to voting algorithms, condorcet in particular
07:49:22 <lollicide> if it happens it's likely only a localized incident of three specific people and their playing styles. rating systems usually assume many many players playing each other.
07:49:29 <chessguy> SamB, not for any significant number of games anyway
07:49:36 <chessguy> maybe if you only play 10 games
07:49:43 <SamB> what if they are computer programs that play badly?
07:50:41 <lollicide> if they play each other the same amount of time, and all the players of the game were just those particular three players, then they'd end up with the same score?
07:50:41 <flux-> I suppose in that case it would be fair to give them the same ranking. however, if there is also player D, which A beats at all, wouldn't that atleast make A better than B and C?
07:50:58 <cdsmith> Trying to get my head around this?  Anyone have a good example of using the ((->) r) monad?
07:51:09 <quicksilver> cdsmith: it's mainly used for cheap tricks
07:51:18 <quicksilver> cdsmith: like its useful instance of join and ap
07:51:28 <quicksilver> cdsmith: but it is also the same thing as Reader
07:51:41 <cdsmith> Hmm...  thanks.
07:51:42 <quicksilver> cdsmith: that is, it's about functions which are all 'waiting for' the same parameter
07:51:47 <quicksilver> cdsmith: and all get given the same
07:52:12 <quicksilver> > do { a <- (+1) ; b <- (*2) ; return (a,b) } $ 5
07:52:21 <lambdabot>  (6,10)
07:52:43 <quicksilver> cdsmith: two functions which both eventually got given the parameter 5
07:52:59 <cdsmith> Ah!  I begin to see.  Thanks very much.
07:54:33 <cjeris> quicksilver: does this make ((->) r) the Streetwalker monad?
07:54:52 <quicksilver> cjeris: :)
07:55:09 <quicksilver> @remember cjeris does this make ((->) r) the Streetwalker monad?
07:55:10 <lambdabot> Done.
07:55:24 <quicksilver> lollicide: what is your rank, out of interest
07:58:52 <lollicide> quicksilver, low kyu, perhaps. i play as 2 kyu on KGS, but kyu ranks on KGS have gotten a lot softer..
07:59:38 * vincenz plays as a 25kyu
08:00:28 * quicksilver nods
08:03:25 <Stinger>  > do { a <- (+1) ; b <- (+5) . (*2) ; return (a,b) } $ 5
08:03:32 <Stinger> > do { a <- (+1) ; b <- (+5) . (*2) ; return (a,b) } $ 5
08:03:33 <lambdabot>  (6,15)
08:03:41 <Stinger> hmmmm cool
08:04:29 <Stinger> I think there was something I wanted that for a while ago
08:05:16 <dolio> > liftM2 (:) last init $ [1..10]
08:05:17 <lambdabot>  [10,1,2,3,4,5,6,7,8,9]
08:10:40 <nominolo> @seen bringert
08:10:41 <lambdabot> bringert is in #haskell. I don't know when bringert last spoke.
08:10:56 <bringert> hi nominolo
08:11:27 <psi> have you go people seen hikaru no go? it's pretty enjoyable :)
08:11:41 <nominolo> bringert: hi, how much effort do you think would it be to make the HTTP library use ByteStrings?
08:12:04 <benja_> would anybody have a copy of the development version of hs-plugins? (tuukkah said that it might work with GHC 6.6)
08:12:20 <nominolo> (i'm asking you, since you seem to be the maintainer)
08:12:23 <benja_> ...dons' site doesn't work currently, so I can't get it from there
08:12:48 <bringert> nominolo: it's a good idea. just swithcing to ByteStrings wouldn't be that much work I think.
08:13:54 <nominolo> bringert: ok, we're two and we have until the end of the quarter
08:14:23 <bringert> nominolo, what's it for, if I may ask?
08:14:39 <nominolo> bringert: the topics course
08:14:40 <quicksilver> nominolo: I'd be surprised if it took more than a day or two
08:14:51 <nominolo> quicksilver: oh
08:14:52 <nominolo> heh
08:15:00 <bringert> yeah
08:15:09 <nominolo> quicksilver: then we have to come up with some more improvements :)
08:15:12 <lollicide> psi, i downloaded it a couple of months after i had started playing, but it's too competitive for me. (e.g. "arm wrestling" or any kind of martial art would pretty much serve as a drop-in replacement for "go" in the whole series.)
08:15:13 <quicksilver> bytestring is boggling easy to use :)
08:15:17 <nominolo> any suggestions?
08:15:32 <quicksilver> well you could then improve performance by using bytestring more efficiently
08:15:35 <quicksilver> :)
08:15:39 <bringert> nominolo: how about lazy ByteStrings which work correctly with 100-continue?
08:15:48 <quicksilver> that would be sexy
08:15:50 <bringert> i.e. chunked transfers
08:16:04 <psi> lollicide: heh, yeah. that's what makes it funny, imo.
08:16:06 <quicksilver> or even lazy bytestrings which allow the server to go away
08:16:11 <quicksilver> and then use accept-ranges later
08:16:17 <quicksilver> to 'resume' transparently
08:16:21 <bringert> nominolo: a nicer API on to of the HTTP module would also be good
08:16:38 * nominolo takes notes
08:17:09 <earthy> morning cyanex
08:17:17 <bringert> something like httpGET :: URL -> IO ByteString
08:17:25 <cyanex> morning
08:17:25 <mightybyte> Would it be possible to write a chess engine in Haskell that would be competitive on the world level?
08:17:35 <earthy> mightybyte: sure.
08:17:41 <earthy> mightybyte: non-trivial though
08:17:47 <nominolo> bringert: k
08:17:47 <mightybyte> Of course
08:17:54 <bringert> httpPOST :: URL -> ByteString -> IO () or whatever
08:18:13 <bringert> and versions of those which allow setting extra headers maybe
08:18:20 <earthy> uhm. that's an awfully simplified view
08:18:55 <quicksilver> earthy: someetimes it's all you want, though
08:18:58 <bringert> nominolo: a general clean-up and niceification of Network.HTTP and Network.Browser would be very appreaciated
08:18:59 * earthy nods
08:19:22 <bringert> earthy: there is already a lower-level API
08:19:43 <bringert> maybe they should at least return the response code
08:19:51 * earthy nods
08:19:56 <bringert> unless it's a redirect or something, in which case it should just follow it
08:19:57 <earthy> that would definitely be better
08:20:12 <mightybyte> I wonder if this hypothetical world-class haskell chess program would embrace haskell style and idioms or if it would be necessary to use a more imperative approach.
08:20:17 <byteshack> has anyone written a "serious" chess engine in haskell? or is it still in the "could be done" realm?
08:20:19 <nominolo> how about a user-agent monad?
08:20:32 <earthy> nominolo: yes please!
08:20:33 <nominolo> there you can adjust your settings
08:20:38 <earthy> yes please! :)
08:20:47 <bringert> nominolo: there is one in Network.Browser already, but it needs improvement
08:21:23 <earthy> what would be good is for a good set of simple defaults for a standard url getter
08:21:32 <nominolo> bringert: yes, the original code seems to be from 2003
08:22:13 <earthy> import Network.Browser as NB; main = do putStr NB.getURL 'http://www.slashdot.org';
08:22:25 <earthy> ofcourse, those should be double quotes
08:22:28 <earthy> but that would be *great*
08:22:35 <mightybyte> byteshack: There is hsChess that was recently started, but I don't know if it deserves the "serious" title yet.
08:22:36 <bringert> yeah
08:22:50 <bringert> another thing is HTTPS support, maybe using hsgnutls
08:23:13 <bringert> but that could be too much work
08:23:22 <quicksilver> it doesn't deserve the 'serious' title
08:23:28 <quicksilver> and neither did the author intend it to :)
08:23:32 <quicksilver> it was written as a teaching demo
08:23:38 <quicksilver> and, as a teaching demo, it's rather nice
08:23:51 <mightybyte> True
08:24:05 <nominolo> ok, that's a lot of good ideas
08:24:17 <glguy> ?seen sjanssen
08:24:18 <lambdabot> sjanssen is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 8h 42m 22s ago.
08:24:29 <nominolo> we have about 6-8 weeks, we'll see what we can do
08:25:18 <nominolo> i'd also like to switch to haskell instead of perl scripts for those web-scripting thingies
08:25:36 <nominolo> nominolo: ATM, LWP is pretty neat, though
08:26:48 <nominolo> lol
08:27:05 * nominolo talks to himself ...
08:27:13 * nominolo feels old ...
08:28:49 <dylan> LWP is nicer than what most other scripting languages have.
08:28:59 <dylan> there's a lot more consistency.
08:29:05 <mux> byteshack: as mightybyte said, there's hsChess for the engine side, and I'm working on a GTK+ Cairo/SVG based UI
08:29:21 <mux> not anymore serious though :-)
08:29:42 <glguy> ?instances Monoid
08:29:43 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
08:30:04 <quicksilver> LWP and WWW::Mechanize are pretty cool
08:30:28 <nominolo> quicksilver: yes, that's an SoC idea from me
08:30:33 <mux> I've heard many people saying WWW::Curl is far superior to WWW::Mechanize
08:30:46 <nominolo> quicksilver: but we need the basics first :)
08:31:03 <nominolo> mux: is it perl or ruby (or both)
08:32:14 <nominolo> i couldn't get WWW::Mechanize to build on my mac.  neither for ruby nor for perl
08:32:49 <uccus> hi guys, I have a question. :) well actually an idea. :) need collaboration.
08:32:53 <glguy> is there a predefined Monoid that behaves like the monad plus instance of Maybe?
08:33:03 <mux> nominolo: WWW::Curl? it's Perl
08:33:20 <quicksilver> nominolo: odd, I don't recall having that problem
08:34:30 <nominolo> quicksilver: yes it is.  i think some tests failed for perl
08:34:45 <nominolo> and for ruby some dependency didn't build
08:35:52 <glguy> does a Monoid need a right identity to be a Monoid?
08:36:13 <quicksilver> glguy: yes, and it should be the same as the left
08:36:19 <mux> I thought monoids are supposed to be associative
08:36:24 <quicksilver> they are, yes
08:36:24 <mux> so right identity doesn't make sense
08:36:29 <glguy> ok
08:36:31 <mux> well yeah, uh, okay :D
08:36:53 <quicksilver> mux: you can be associative and still have seperate right/left identities
08:37:04 <kaol> http://psi5.com/~geier/1174312893870.jpg
08:37:07 <glguy> Data.FingerTree doesn't require one (as a side-effect of being a 2-4 finger tree)
08:37:14 <kaol> oops, sorry, mispaste
08:37:20 <glguy> since I was only using this Monoid instance for that
08:37:27 <glguy> I wasn't sure if what I was doing was techincally wrong
08:37:33 <glguy> to not define the right identity
08:37:50 <quicksilver> if you understand fingertree's invariant then it isn't wrong :)
08:38:00 <glguy> sweet deal :)
08:38:05 <quicksilver> the haskell class system isn't fine enough to distinguish all the slightly different cases, after alll
08:38:12 <mux> I'm so strong when it comes to confusing myself
08:38:20 <quicksilver> associative-groupoid-with-left-id
08:38:58 <mux> like writing the transformation matrix myself for doing a translation with Cairo, and cursing about the lack of a translate function when there was one just under my nose
08:39:23 <glguy> quicksilver: under my interpretation, this is valid then:
08:39:25 <glguy> instance Monoid Key where mempty      = NoKey mappend _ b = b
08:39:53 <quicksilver> glguy: well the equational laws aren't enforced so you can do what you like :)
08:41:02 <quicksilver> glguy: it's just up to you to understand what invariants the various (Monoid m) => functions you might use, require, though
08:41:11 <quicksilver> glguy: so it's "safer" to obey the laws
08:41:30 <glguy> and it only adds one line
08:41:32 <glguy> so I might as weel
08:41:34 <glguy> well
08:41:52 <quicksilver> what extra line?
08:41:53 <glguy> mappend a NoKey = a
08:42:00 <quicksilver> ah
08:42:06 <quicksilver> above not below the other :)
08:42:11 <glguy> right
08:42:18 <glguy> :-p what do you take me for
08:43:44 <sioraiocht> bah, does anyone else find the haskell summer of code webpage somewhat frustrating
08:44:06 <Igloo> IWW?
08:44:08 <chessguy> ?where soc
08:44:09 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
08:44:58 <sioraiocht> Other organisations have a distinction between project ideas posted by potential mentors versus those by students..
08:45:28 <sioraiocht> this is just one big...mess
08:45:37 <chessguy> why does it matter who submitted the idea?
08:46:06 <sioraiocht> I'd like feedback? heh
08:46:16 <Igloo> feedback on what?
08:46:17 <sioraiocht> I'm not likely to get that from a competing student...
08:46:37 <sioraiocht> on a certain approach to an idea
08:46:41 <sioraiocht> or if an idea is any good..
08:46:47 <sioraiocht> okay I see your point, I could just ask YOU all
08:46:59 <ndm> i find it a mess too, i'd much rather a google bug tracker based one
08:47:06 <chessguy> if you click on it, it tells you who submitted it
08:47:08 <ndm> trac seems to suck more than it reasonably  should
08:47:17 <sioraiocht> yay! someone agrees with me, lol
08:47:50 * chessguy shrugs
08:47:59 <chessguy> i don't use it, or need to use it, so don't go by my opinion
08:48:11 <sioraiocht> ?
08:48:20 <chessguy> it=the page
08:48:22 <sioraiocht> ignore that quesiton mark
08:48:26 <uccus> what do I have to be to take up an SoC project?
08:48:30 * Igloo isn't trac's biggest fan, but I don't really see the problem you describe
08:48:33 <bringert> sioraiocht: yes, it's not very good
08:48:36 <ndm> uccus: a student
08:48:39 <sioraiocht> uccus: a college student
08:48:51 <uccus> ndm: with a CSE major?
08:48:53 <sioraiocht> uccus: you can be "accepted" at a uni and qualify, though
08:48:56 <sioraiocht> uccus: no
08:49:01 <cdsmith> uccus: no, no major requirements
08:49:01 <chessguy> uccus, see http://code.google.com/summerofcode.html
08:49:03 <lambdabot> Title: Google Code - Summer of Code - Google Summer of Code
08:49:19 <Igloo> sioraiocht: Is there something concrete you wanted feedback on?
08:50:01 <sioraiocht> Igloo: i was interested in discussing the approach to an idea that was posted about implementing BSP parallelism in haskell
08:51:11 <Igloo> Well, that one has an interested mentor listed
08:51:19 <vincenz> @seen dmhouse
08:51:20 <lambdabot> I saw dmhouse leaving #happs, #haskell-blah and #haskell 1d 22m 17s ago, and .
08:51:24 <vincenz> @seen zarvok
08:51:24 <lambdabot> I saw zarvok leaving #oasis and #haskell 10h 57m 29s ago, and .
08:51:27 <sioraiocht> Igloo: I emailed him, of course ;)
08:51:34 <uccus> umm... okay, the thing is I have absolutely no demonstratable programming experience
08:51:34 <sioraiocht> a few days ago
08:51:39 <uccus> let alone in Haskell
08:51:42 <sioraiocht> uccus: that could be an issue
08:51:46 <Igloo> OK, cool  :-)
08:52:04 <uccus> I see... should I apply anyway?
08:52:08 <sioraiocht> Igloo: I'm skeptical at this point in hearing a response, though, especially given the looming deadline
08:52:11 <cdsmith> uccus: why not?
08:52:17 <uccus> no seriously
08:52:20 <bringert> what does italics mean in http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&type=proposed-project&order=priority
08:52:23 <lambdabot> Title: Custom Query - Haskell.org Google Summer of Code - Trac, http://tinyurl.com/fl2dw
08:52:23 <sioraiocht> uccus: if you have a good proposal for an iea, why not
08:52:44 <hhalvors> question from a lisp -> haskell convert: is there a way to write code 'interactively' in Emacs?  (I'm used to using 'Slime' for lisp)
08:52:44 <lambdabot> hhalvors: You have 1 new message. '/msg lambdabot @messages' to read it.
08:52:51 <uccus> what if I want to take up an existing idea? I go to the same uni as dons... I could be in direct contact with him
08:52:53 <Igloo> bringert: I think it means that it used to be listed there, but "recently" got moved/closed/...
08:53:19 <Igloo> It should disappear properly shortly
08:53:21 <psi> hhalvors: the is haskell-mode, but it isn't as advanced as slime. it allows integration with ghci, though.
08:53:24 <sioraiocht> hhalvors: do you mean have an interpreter window in emacs?
08:53:29 <cdsmith> uccus: if you're really, truly interested in something, then apply.
08:53:38 <quicksilver> hhalvors: I use a ghci buffer (inf-haskell) and a source buffer and reload and stuff
08:53:47 <quicksilver> hhalvors: it's not as interactive as some lisp setups
08:53:49 <bringert> Igloo, this doesn't seem to be closed/moved: http://hackage.haskell.org/trac/summer-of-code/ticket/1106
08:53:50 <lambdabot> Title: #1106 (Hackage Web Interface, Doc-Browser) - Haskell.org Google Summer of Code - ...
08:53:52 <sioraiocht> hhalvors: in haskell-mode C-c C-l usually opens hugs or ghci, depending on the system
08:54:01 <bringert> for example
08:54:08 <Igloo> bringert: Where is it in italics?
08:54:16 <Igloo> Oh, I see
08:54:18 <kuribas> Do most people here use emacs for programming haskell?
08:54:24 <earthy> many do
08:54:24 * bringert does
08:54:28 <sioraiocht> kuribas: I believe so, I do
08:54:31 * benja_ uses gedit
08:54:32 * earthy uses vim
08:54:32 * arcatan doesn't anymore
08:54:36 * Igloo uses vim
08:54:37 <quicksilver> I'd be rather surprised if it was 'most'
08:54:41 <quicksilver> it's certainly 'many'
08:54:41 <Igloo> bringert: No idea
08:54:42 * sioraiocht fears vim.
08:54:47 <psi> hhalvors: you can send code to the repl, jump to definitions and errors, the basics.
08:54:57 <earthy> then again, I've lived in vim for the past 10 years or so already, and vi for 4 years more
08:55:12 <kuribas> I'd would be nice to have a better indentation engine.
08:55:14 <sioraiocht> I was brought up on emacs, and I haven't had a compelling reason to switch.
08:55:14 <earthy> so I'm a bad sample. :)
08:55:22 <earthy> sioraiocht: There isn't one
08:55:29 <earthy> (in either direction)
08:55:29 <bringert> Igloo: do you think that there is any change that we could make a short list of high-priority projects, to help guide student applicants?
08:55:36 <bringert> chance
08:55:45 <sioraiocht> that's good, because I also use AuCTeX and I couldn't live without it
08:55:47 <bringert> I don't know how we would decide that though
08:55:49 <Igloo> bringert: I thought that was the plan, but I don't know why it didn't happen
08:55:50 * LPhas fears vim
08:56:00 <bringert> Igloo: noone did it I guess :-)
08:56:01 <psi> kuribas: i think emacs indents rather good. it takes some getting used to, though.
08:56:01 * LPhas fears emacs too
08:56:07 <Igloo> Possibly
08:56:12 <earthy> lphas: don't. learn one of the two.
08:56:18 <psi> it does if then else wrong, though :(
08:56:18 <kuribas> psi: I really dislike it.
08:56:21 * LPhas uses emacs
08:56:33 <earthy> well, then stop fearing it! :)
08:56:36 <sioraiocht> kuribas: why?
08:56:39 <LPhas> HOW
08:56:48 <Igloo> bringert: malcolmw and dons are the people to ask, but i suspect neither is here
08:56:50 <sioraiocht> LPhas: RTFM? =p
08:56:58 <LPhas> yeah, of course
08:57:01 <LPhas> it's short
08:57:01 <therp> I'm not sure if I could have a girlfriend that uses vi.
08:57:05 <benja_> so I built and installed hs-plugins 1.0RC1 without problems, but (eval "1 + 6 :: Int" [] :: IO (Maybe Int)) yields Nothing
08:57:08 <kuribas> sioraiocht: well, for example: pressing tab moves to all different directions
08:57:32 <kuribas> sioraiocht: tab should be only to the right.
08:57:32 <sioraiocht> kuribas: they cycle through, you'll find the one you want eventually ;)
08:57:35 <benja_> any ideas?
08:57:47 <sioraiocht> kuribas: That's not the emacs way.
08:58:06 <LPhas> i wonder if someone did read the emacs manual completely
08:58:08 <kuribas> sioraiocht: It is for all the other programming languages I used (not Python though :)
08:58:13 <LPhas> he's to be dead
08:58:17 <psi> kuribas: emacs tab attempts to indent the line properly, it doesn't "move to the right"
08:58:33 * sioraiocht agrees w/ psi.
08:58:36 <quicksilver> that's not his point
08:58:44 <quicksilver> as you cycle between various possible indentations
08:58:48 <sioraiocht> even in java or c mode, tab will find the proper indentation, not move to the right
08:58:50 <quicksilver> it does so in a hard-to-understand order
08:59:00 <quicksilver> sioraiocht: there isn't a single proper indentation, though
08:59:17 * LPhas agrees with quicksilver
08:59:20 <quicksilver> given a line with about 7 possible indentations in my code, it does something like 5-3-6-1-6-4
08:59:22 <sioraiocht> quicksilver: I only use one sort of indentation scheme for a given language, though.
08:59:29 <quicksilver> sioraiocht: you misunderstand me
08:59:37 <kuribas> psi: Here is what I would find easier: tab finds indentation to the right, backspace the left.
08:59:43 <quicksilver> sioraiocht: in haskell, a given line has multiple different possible indentations which mean different things
08:59:52 <sioraiocht> that's true
08:59:53 <quicksilver> sioraiocht: so the mode has no option but to give you the choice
08:59:59 <quicksilver> kuribas: yes, that would be much nicer
09:00:01 <sioraiocht> and it does, you cycle through them )
09:00:10 <quicksilver> sioraiocht: but in no particular order
09:00:18 <sioraiocht> I'm lazy, i'd rather just smash the tab key until I get what I want
09:00:18 <quicksilver> sioraiocht: neither left-to-right nor right-to-left
09:00:22 <quicksilver> and that's bizarre
09:00:27 <quicksilver> sioraiocht: yes, that's fine
09:00:27 <psi> kuribas: i would expect backspace to erase
09:00:32 <quicksilver> sioraiocht: just do it in a sensible order
09:00:36 <kuribas> psi: it does :)
09:00:43 <quicksilver> well tab for right and C-tab for left, maybe
09:00:48 <quicksilver> or Something-Else-tab
09:00:49 <LPhas> is there a emacs-vi war going?
09:00:53 <quicksilver> no, not really
09:01:00 <earthy> no, this is just emacs haskell mode bashing
09:01:02 <quicksilver> this is a 'haskell-indent for emacs is odd' war
09:01:06 <earthy> which is really enlightening
09:01:08 <sioraiocht> LPhas: in this room, or in the larger picture?
09:01:11 <quicksilver> I like emacs haskell mode very much
09:01:17 <LPhas> in the room lol
09:01:24 <quicksilver> but this particular point of indentation order I quite agree is bizarre
09:01:27 <benja_> quicksilver: and in lieu of opposition, your side seems to be winning
09:01:33 <kuribas> psi: It will just treat spaces like a virtual tab.
09:01:34 <sioraiocht> You can't make me abandon Aquamacs, it's pretty, functional, and plays with AuCTeX nicer than mose
09:01:36 <quicksilver> benja_: he who talks most?
09:01:38 <sioraiocht> s/mose/most
09:01:40 <benja_> =)
09:01:46 <LPhas> haskell emacs is the only way
09:01:54 * earthy was thinking about ripping off the haskell-indent in haskell emacs mode and use it in my haskell vim ftplugin
09:02:05 <LPhas> indentation os state of art
09:02:18 * sioraiocht does NOT want to go to Data Networks. WAH
09:02:24 <psi> I'm going to try out some indenting now :)
09:02:57 <quicksilver> earthy: not a very easy thing to rip out
09:03:16 <kuribas> psi: My idea is that the character movement/deletion commands treat whitespace at the beginning of the line like if there are tabs, even if there aren't.
09:03:43 <sioraiocht> does anyone have any other good ideas for some parallel computaitn projects in haskell? I'm running out of ideas, heheh
09:04:03 <mux> SMP-optimized chess engines =)
09:04:06 <LPhas> i don't know why syntax highlighting does not work for me on emacs without GUI
09:04:17 <LPhas> why works in the gui one
09:04:25 <sioraiocht> LPhas: you mean "emacs -nw" mode will not syntax highlight?
09:04:33 <LPhas> mmh
09:04:37 <kuribas> LPhas: Maybe you use X-windows colors?
09:04:42 <LPhas> eheh no
09:04:51 <LPhas> emacs on osx
09:04:56 <LPhas> carbon emacs
09:05:05 <sioraiocht> LPhas: download Aquamacs  =p
09:05:06 <kuribas> LPhas: well, could be the same problem.
09:05:24 * sioraiocht pets his Aquamacs.
09:05:40 <quicksilver> LPhas: are you sure you're using carbon emacs, in non-GUI mode?
09:05:54 <LPhas> meh, i don't know
09:05:54 <quicksilver> LPhas: how do you invoke it?
09:05:58 <bringert> nominolo, have you seen http://hackage.haskell.org/trac/summer-of-code/ticket/1122 ?
09:06:00 <LPhas> emacs in bash
09:06:00 <lambdabot> Title: #1122 (HTTP Library Replacement) - Haskell.org Google Summer of Code - Trac
09:06:04 <quicksilver> LPhas: then you're not
09:06:16 <quicksilver> LPhas: if you type 'emacs' in bash you're invoking the version apple ship with the OS
09:06:26 <LPhas> oh
09:06:36 <sioraiocht> yeah, type "which emacs" =)
09:06:50 <sioraiocht> it's probably "/usr/bin/emacs"
09:06:54 <LPhas> BlueTux:/Volumes/PHAS/amule/GemBoy Phas$ which emacs
09:07:11 <benja_> hmm, if I run my hs-plugins test program with runghc or ghci, eval returns Nothing, but if I try to compile with ghc, I get a linker error: (.text+0x46): undefined reference to `pluginszm1zi0_SystemziEvalziHaskell_eval_closure'
09:07:13 <LPhas>  /usb/bin/emacs
09:07:22 <benja_> (and 3 more undefined refs)
09:07:23 <sioraiocht> yeah, that's the apple version :
09:07:29 <psi> kuribas: ok, i don't really see the benifit.
09:07:38 <benja_> anybody have an idea what's going on? :-)
09:07:38 <quicksilver> LPhas: if you want the carbon one you have to type something odd like /Applications/Emacs.app/Contents/MacOS/bin/emacs
09:07:52 <psi> kuribas: i think the emacs indent mode could certainly be made better. in particular i think it could guess the right intendation more often.
09:07:57 <quicksilver> benja_: the linker couldn't find your hs-plugins package
09:08:03 <kuribas> psi: yes
09:08:07 <LPhas> mmh i see
09:08:15 <LPhas> then i've to use emacs -nw and so on
09:08:19 <quicksilver> and it could cycle through them in a better order
09:08:19 <LPhas> let's try
09:08:22 <psi> kuribas: it seems pretty predictable to me, but often you need to press tab twice to get it right.
09:08:54 <kuribas> psi: One more thing I don't like: I press tab but it doesn't change indentation at first.
09:09:21 <benja_> quicksilver: ok, does that mean I should add -L and/or -l to the command line?
09:09:28 <LPhas> quicksilver, thx
09:09:32 <quicksilver> benja_: Possibly. I don't know :)
09:09:38 <benja_> ok, thanks =)
09:09:45 <hhalvors> thanks for answers about Emacs.  Is there some intro book to Haskell that is good for those coming from lisp?
09:09:51 <psi> kuribas: hm, what does it do?
09:10:09 <kuribas> psi: nothing ...
09:10:28 <psi> hhalvors: the gentle introduction maybe. it assumes familiarity with functional programming, etc.
09:10:42 <sioraiocht> hhalvors: Haskell: The Craft of Functional Programming and is pretty good
09:10:57 <kuribas> psi: I'll have to write my own indentation engine...
09:11:09 <sioraiocht> you'll find a strong difference conceptually is that haskell is strongly, statically typed
09:11:39 <chessguy> hhalvors, you might try some of the tutorials at http://www.haskell.org/haskellwiki/Meta-tutorial#You_have_experience_programming
09:11:41 <lambdabot> Title: Meta-tutorial - HaskellWiki, http://tinyurl.com/22ubbw
09:11:49 <sioraiocht> and syntactically haskell users like infix notation....a lot
09:11:52 <psi> kuribas: cool, i'm sure many people would like something else.
09:11:55 <ClaudiusMaximus> benja_: something like "ghc -package plugins --make TestProgram.hs" should work
09:12:27 <benja_> ClaudiusMaximus: oh, it does. cool, thanks!
09:12:37 <hhalvors> Thanks all! Fun reading ahead ...
09:13:37 <benja_> yikes, now I get 'unknown symbol' when *running* the executable. anyone have advice on that?
09:13:53 <benja_> (Main: /tmp/MJdgZ28357.o: unknown symbol `pluginszm1zi0_AltDataziDynamic_toDyn_closure' [newline] Main: user error (resolvedObjs failed.))
09:14:04 <sioraiocht> hhalvors: also perhaps check out Introduction to Functional Programming using Haskell by Richard Bird
09:14:11 <sioraiocht> i would start off slow, but it's quite good as well
09:14:24 <hhalvors> sioraiocht: thanks
09:14:29 <sioraiocht> AFAIK, there isn't a really good book that sufficiently covers Monads
09:16:15 <earthy> sioraiocht: oh, but there is
09:16:28 <sioraiocht> earthy: what is there?!
09:16:33 <sioraiocht> I'd love to read it
09:16:37 <earthy> however, it's called something like 'Category Theory for the working mathematichan'
09:16:47 * sioraiocht backs away.
09:16:49 <earthy> or 'Category Theory for COmputer Science'
09:16:50 <mightybyte> lol
09:16:51 <sioraiocht> No thanks!
09:17:09 <sioraiocht> I avoid pure mathematics as much as possible
09:17:34 <benja_> (earthy: Basic Category Theory for Computer Scientists?)
09:17:34 <sioraiocht> I had to work with pure mathematicians over the summer, they're the only people weirder than the applied math folks.
09:17:51 <benja_> ah no, the one you said exists too =)
09:17:56 <quicksilver> is that the popkorn book?
09:18:40 <benja_> or does with s/Computer/Computing/
09:18:58 <earthy> benja: yeah, true. I misread it off the spine
09:19:01 <earthy> (my bookcase is behind me)
09:19:16 * sioraiocht wishes Lua had been in the GSoC...
09:19:21 <chessguy> wow, i'm actually very impressed with the 'Write yourself a scheme in 48 hours'. it's not for newbie programmers, but it is well-written
09:19:29 <sioraiocht> haha
09:20:30 <earthy> http://www.haskell.org/all_about_monads/html/index.html, http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/, http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf are the papers that we use to introduce our master's students to monads
09:20:30 <lambdabot> Title: All About Monads
09:20:40 * LPhas is happy because now can use emacs without GUI
09:21:08 <sioraiocht> I'm currently in a "Topics in Functional Programming" course, which is a "My professor wanted to learn more about haskell, so she'll teach the stuff we didn't learn in lower division courses"
09:21:13 <quicksilver> if you want a more mathsy approach, I actually find moggi's paper very readable
09:21:19 <quicksilver> you can skip over the hard stuff
09:21:25 <quicksilver> but he gives good motivation IMO
09:21:28 <sioraiocht> and ps, I have to say that Haskell concurrency sucks...
09:21:40 <quicksilver> sioraiocht: in what way?
09:21:46 <chessguy> huh? concurrency is a strong point of haskell
09:21:51 <LPhas> quicksilver, moggi's paper on monads?
09:21:55 <quicksilver> LPhas: yes
09:21:58 <shapr> Yeah, sucks is an emotional description, how can I unit test that?
09:22:01 <earthy> which of the $n$? :)
09:22:04 <LPhas> quicksilver, moggi is one of my professor
09:22:14 <quicksilver> LPhas: :)
09:22:24 <chessguy> ugh, earthy, one of your links borked my browser
09:22:24 <quicksilver> LPhas: he is a smart man :)
09:22:29 <sioraiocht> I have to say that it's a somewhat parochial point of view, hence the term "sucks".  I don't like forcing programmers to explicitly control threads
09:22:37 <Saizan> where is he from?
09:22:48 <earthy> chessguy: sorry
09:22:49 <LPhas> quicksilver, i'ts like a God in our university lol
09:22:52 <quicksilver> sioraiocht: you want implicit parallelism?
09:22:59 <quicksilver> sioraiocht: because haskell supports that too, to some extent
09:23:00 <sioraiocht> quicksilver: yes
09:23:11 <kpreid> sioraiocht: Control.Parallel
09:23:16 <quicksilver> AFAIK no mainstream language  has good implicit parallelism
09:23:17 <sioraiocht> quicksilver: I know GPH does, I haven't been able to find much else
09:23:20 <chessguy> i'm not sure which one though since i tried to open them all at once
09:23:32 <sioraiocht> quicksilver: I know, I'm hoping to make  a PhD thesis out of that problem =p
09:23:34 <kpreid> Control.Parallel is supported in GHC 6.6
09:23:47 <earthy> chessguy: does your system strip the commas? :)
09:23:58 <shapr> quicksilver: You could say SASL does, but it's really just nested data parallel arrays.
09:24:04 <chessguy> i think
09:24:25 <earthy> http://www.cs.uu.nl/wiki/Afp/CourseLiterature has more
09:24:27 <lambdabot> Title: Afp / Course Literature
09:24:37 <chessguy> i think it's the baastad link that did it
09:24:47 <scriptdevil> is haskell good for programs which often need to recursively list directories.. read from files and create files?
09:24:49 <dufflebunk> I've never understood why implicit paralellism hasn't been done in all pure functional languages... sunce functions are already concurrent I'd think it would be easy
09:24:57 <bos> :type fix
09:25:03 <earthy> dufflebunk: it's not quite that easy
09:25:04 <bos> @type fix
09:25:06 <lambdabot> forall a. (a -> a) -> a
09:25:10 <dufflebunk> earthy: apparently :)
09:25:10 <earthy> the Clean people actually did it
09:25:11 <sioraiocht> dufflebunk: and outside of monads, i believe all haskell code is inherently reentrant
09:25:13 <shapr> kpreid: The only two ways I know of to do explicit parallelism are nested data parallelism and certain combinator systems. Are there more?
09:25:20 <scriptdevil> dufflebunk: are that many pure functional languages
09:25:30 <bos> @src fix
09:25:31 <lambdabot> fix f = let x = f x in x
09:25:41 <shapr> scriptdevil: Yeah, though you may want to start with the hsshellscript, h4sh and other scripting libs.
09:25:44 <earthy> but they haven't ported it away from the transputers and mac os 7 boxes that it ran on.
09:25:54 <chessguy> ok, IE managed to open it
09:26:06 <shapr> sioraiocht: How so?
09:26:20 <kpreid> shapr: I'm not familiar with parallelism in general. You might ask ##concurrency.
09:26:30 <chessguy> earthy, your cs.uu.nl link requires a password
09:26:34 <shapr> kpreid: In any case, it sounds like a fun PhD thesis.
09:26:42 <chessguy> err
09:26:43 <earthy> it does? drat.
09:26:47 <chessguy> it asks for one, but then lets you in
09:26:50 <earthy> ah. :)
09:26:51 <sioraiocht> shapr: If you aren't using monads,  there are no side effects, and everything in Haskell is immutable
09:26:55 <earthy> yeah, it's a silly wiki
09:27:06 <shapr> sioraiocht: Monads are also pure code..
09:27:10 <chessguy> that's kind of funny
09:27:44 <scriptdevil> shapr: you mean.. i have to learn haskell the basics right??  i did hat YAHT book tilll Types.. then was attracted by ruby.. but ruby is complaining of stack level being too deep
09:27:45 <ClaudiusMaximus> benja_: i'm guessing wildly here, but i think your plugin might require a -package that you haven't compiled into your executable?
09:27:49 <sioraiocht> shapr: but with side effects, it's more difficult for a compiler to determine parallel behaviour, that's all
09:29:01 <quicksilver> sioraiocht: you're simplifying some things actually
09:29:10 <quicksilver> sioraiocht: haskell may have a side-effect free semantics
09:29:22 <shapr> scriptdevil: The stack depth problem could probably be fixed in Ruby by using an iterative loop. But for Haskell, I just meant that recursive directory code already exists in several shell scripting libraries, so that would save you some time.
09:29:22 <quicksilver> sioraiocht: but that doesn't mean that evaluation in a real haskell run-time is side-effect free
09:29:39 <quicksilver> sioraiocht: evaluation has side-effects: it replaces thunks by their values
09:29:39 <sioraiocht> quicksilver: give an example?
09:29:49 <sioraiocht> quicksilver: I see your point
09:29:51 <quicksilver> sioraiocht: or, it replaces thunks by somewhat-more-evaluated thunks
09:29:57 <bos> @index fix
09:29:57 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
09:30:01 <quicksilver> this means that parallel execution requires thunk-locking
09:30:05 <shapr> @index break
09:30:05 <lambdabot> Data.List, Prelude
09:30:11 <quicksilver> in case two threads are trying to update the same thunk :)
09:30:16 <sioraiocht> quicksilver: that's a good point.
09:30:35 <quicksilver> of course the intuition that it's "easier" in a pure language is correct
09:30:38 <sioraiocht> had never thought of it that way, but then again I haven't thought of attacking this problem until recently =p
09:30:43 <quicksilver> but it's still not trivial
09:30:54 <sioraiocht> quicksilver: never thought that, or it'd be done already, hehe
09:31:32 <quicksilver> and, w.r.t shapr's point, in *principle*, the IO monad is a pure construct and evaluation is a 'separate phase' from IO action execution
09:31:43 <scriptdevil> shapr: :D great thing..
09:31:53 <quicksilver> however, in *practice* the IO actions are in fact executed in a way which interleaves with evaluation
09:32:05 <shapr> Yup
09:32:06 <quicksilver> so it's complicated :)
09:32:25 <sioraiocht> quicksilver: how is that interleaving done?
09:32:26 <quicksilver> of course, other monads like maybe or list or state have no such problem at all
09:32:52 <scriptdevil> anyway.. i am already reading Modules.. so meet you people later..
09:32:59 <quicksilver> sioraiocht: slightly differently by the different runtimes, but roughly speaking, thunks are evaluated when (and only when) their values are demanded by an IO action
09:33:11 <shapr> scriptdevil: Yeah, come back soon..
09:33:17 <shapr> scriptdevil: Feel free to ask more questions.
09:33:33 <scriptdevil> shapr: this is one thing that i have always loved about haskell... #haskell :D
09:33:37 <shapr> :-)
09:34:48 <alexj> is it possible to define a monad that allows IO only through a limited set of IO primitives provided by the monad?
09:34:50 <scriptdevil> shapr: anyway.. i just remembered one thing.. being lazy, haskell will not waste that stack depth on some unwanted files..
09:35:02 <sioraiocht> quicksilver: ah, thanks =) you learn something new everyday
09:35:05 <alexj> for example, I want an IO monad that allows http requests but not file IO.
09:35:19 <quicksilver> alexj: yes, quite possible
09:36:29 <shapr> Doesn't lambdabot's eval code do something like that?
09:37:35 <bringert> alexj: it's hard to make it secure against unsafePerformIO, but other than that it should be ok
09:38:03 <alexj> any examples?
09:38:11 <quicksilver> the simplest case, just do a newtype
09:38:12 <bringert> you'll want to think carefully about how to do error handling
09:38:18 <quicksilver> newtype MyIO a = IO a
09:38:22 <quicksilver> erm
09:38:34 <quicksilver> data MyIO a = MyIO (IO a)
09:38:36 <bringert> and don't export the constructor
09:38:44 <quicksilver> and, as bringert says, don't export the constructor
09:38:59 <quicksilver> the you have to explicitly export the operations you do wish to permit
09:39:41 <alexj> oic.  so I need to define something like:   getURL::URL->MYIO Content
09:39:47 <quicksilver> yes
09:39:52 <alexj> oh nifty.
09:39:53 <quicksilver> and the definition is easy :)
09:40:08 <quicksilver> getURL = MyIO.realGetURL
09:40:31 <quicksilver> more complex for things which have more IOs in their type. But not too bad.
09:40:54 <sioraiocht> oh this reminds me....difference between data and newtype? anyone?
09:40:57 <alexj> not sure I understand the definition MyIO.realGetURL?
09:41:14 <quicksilver> alexj: realGetURL was pseudo-syntax, for the 'real' getURL function
09:41:27 <dylan> @unpl MyIO . realGetURL
09:41:27 <lambdabot> (\ c -> (MyIO) (realGetURL c))
09:41:42 <quicksilver> alexj: probably it's NB.getURL where import qualified Network.Browser as NB
09:41:58 <quicksilver> alexj: then MyIO is just your constructor, which I composed on the end
09:43:11 <alexj> and as long as I prohibit modules from importing the constructor and using unsafe* I can trust them!
09:43:28 <alexj> very cool, I think.
09:43:34 <alexj> quicksilver: thanks.
09:43:45 * quicksilver nods
09:43:57 <quicksilver> ideally you need to control your modules' import lists
09:44:03 <quicksilver> so you know they don't import anything unsafe
09:44:13 <quicksilver> this is slightly annoying, and people are thinking about it
09:44:51 <alexj> is there a current list of what is unsafe?
09:44:54 <quicksilver> (how can you use a type system for safety if you allow people to hide stuff from the type system?)
09:45:19 <alexj> for now I am conformtable with grepping through code.
09:45:26 * quicksilver nods
09:45:34 <alexj> I want HAppS to be able to run code from uploaded modules.
09:45:37 <alexj> safely.
09:46:02 <alexj> is there a list of unsafe modules?
09:46:02 <quicksilver> but beware of import ANOther.Module where ANOther.Module defines verySafeHappyJoy = System.IO.unsafePerformIO
09:46:19 <alexj> right.
09:46:56 <alexj> I am going to limit imports to the modules being uploaded and the set of modules I approve.
09:47:27 <alexj> so it is just a question of whether there are any standard lib modules that expose unsafety.
09:47:45 * quicksilver nods
09:47:52 <quicksilver> even safer is just to fix the import list yourself
09:47:59 <quicksilver> and then forbid any imports at all :)
09:48:32 <alexj> :- )
09:48:44 <bos> are there any good articles on how to think about using the fixpoint combinator?
09:48:56 <Igloo> alexj: lambdabot probably has the best list we have
09:49:08 <alexj> igloo: ok where is the lambdabot code?
09:49:20 <alexj> s/code/list?
09:49:25 <Igloo> You'd also need to include all the Array modules if you're paranoid, until the problems from a while back are fixed
09:49:28 <Igloo> @where lambdabot
09:49:29 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
09:49:33 <bos> i haven't used fix enough to be able to look at it as a tool i can easily use
09:49:43 <quicksilver> bos: it isn't really a tool you need to use
09:49:48 <alexj> array modules are prohibited?
09:49:51 <quicksilver> bos: its power is included in the language
09:49:59 <quicksilver> (the ability to make recursive definitions)
09:50:13 <xs> i have a file with just "-- | test\n-- > foo\n" in it. haddock shouts parse error. any ideas why?
09:50:26 <alexj> igloo: arrays are unsafe?
09:50:33 <Igloo> alexj: You can trick them into accessing data outside of the array
09:50:38 <bos> quicksilver: sure, i know. but if you're not used to using it, it's not obvious when it might be useful. that's what i'm wondering about.
09:50:39 <Igloo> And writing to it too, for that matter
09:50:40 <chessguy> @type unfoldTree
09:50:42 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
09:50:49 <chessguy> ?hoogle unfoldTree
09:50:49 <lambdabot> Data.Tree.unfoldTree :: (b -> (a, [b])) -> b -> Tree a
09:50:50 <lambdabot> Data.Tree.unfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
09:50:50 <lambdabot> Data.Tree.unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
09:51:07 <vincenz> @seen zarvok
09:51:07 <lambdabot> I saw zarvok leaving #oasis and #haskell 11h 57m 11s ago, and .
09:51:21 <alexj> igloo: as long as they can't access data outside the process, I am ok.
09:51:29 <quicksilver> bos: I'm suggesting that the answre to 'when its useful' is 'never' :)
09:51:30 <Igloo> alexj: http://hackage.haskell.org/trac/ghc/ticket/1046
09:51:31 <lambdabot> Title: #1046 (Make array indexing immune to seg-faults) - GHC - Trac
09:51:44 <Igloo> alexj: Well in theory you could use them to rewrite code on the heap
09:51:47 <quicksilver> bos: there is nothing you need fix for; recursive definitions are much clearer to most human eyes
09:52:38 <benja_> ah cool, dons' page works again :)
09:52:40 <jacobian> do any implementations take a fold in the maybe monad to one that short circuits on failure?
09:52:56 <Igloo> alexj: But it would take some work; it depends how paranoid you are  :-)
09:53:13 * int-e plays with  newtype Mark n t = Mark { unMark :: t }  and thinks that phantom types are fun.
09:53:14 <alexj> igloo: for now I am not *that* paranoid.
09:53:21 <quicksilver> jacobian: the maybe monad always short circuits on failure
09:53:31 <quicksilver> jacobian: you get that for free with lazy evaluation
09:53:36 <bos> jacobian: are you thinking about foldM in the maybe monad?
09:53:59 <quicksilver> maybe that's a bit strong
09:54:14 <quicksilver> but sensible functions in the lazy monad short-circuit on failure :)
09:54:18 <alexj> igloo: well before I say that, how dangerous is this really?  not sure I understand the issue.
09:54:34 <vincenz> augustss: typically when descriping semantics, you might have something like f(\overline{e}).  How do you do this if the overline should span three different possibilities. . For instance, program := \overline{either funcdef or classdef}
09:54:34 <alexj> segfault seems ok
09:55:23 <quicksilver> > foldr (mplus) (Just 1) ((Just 1):Nothing:(map Just [1,..]))
09:55:23 <lambdabot>  Parse error
09:55:39 <quicksilver> > foldr (mplus) (Just 1) ((Just 1):Nothing:(map Just [1..]))
09:55:40 <lambdabot>  Just 1
09:55:57 <quicksilver> jacobian: fwiw, that proves that folds in the lazy monad are pure :)
09:56:16 <quicksilver> jacobian: short-circuitinh
09:56:29 <jacobian> in what sense pure?
09:56:40 <quicksilver> thinko :)
09:56:46 <quicksilver> > foldr (>>) (Just 1) ((Just 1):Nothing:(map Just [1..]))
09:56:47 <lambdabot>  Nothing
09:56:54 <quicksilver> and that proves that bind is short-circuiting
09:56:58 <jacobian> ah!
09:57:00 <jacobian> I see :)
10:02:37 <guenni> guys, about pattern matching ...
10:02:50 <guenni> *does* the order of the patterns matter?
10:02:55 <shapr> yup
10:03:16 <kc5tja> It checks from first-pattern on down.
10:03:23 <Igloo> alexj: Ignoring it is probably what I'd do, and I suspect lambdabot does too
10:03:43 <guenni> autsch!
10:03:50 <kc5tja> Therefore, you should put the most specific patterns at the top of the definition.
10:04:10 <chessguy> @get-shapr
10:04:10 <lambdabot> shapr!!
10:04:12 <alexj> igloo: ignoring it means assume that no one can/will use the array problem to do something bad?
10:04:14 <shapr> chessguy: yes?
10:04:20 <chessguy> howdy!
10:04:20 <guenni> is there some mathematical reasoning behind this?
10:04:24 <shapr> chessguy: hiya!
10:04:29 <Igloo> alexj: Yes
10:04:51 <guenni> or is it just arbirtary ruled so
10:04:52 <shapr> guenni: It's the same as a case expression.
10:05:26 <guenni> yes but case is more sort of arbirtrarily defined so
10:05:27 <kc5tja> guenni: It's not mathematical; it's pragmatic.  It's a syntactical sugar coating for a case expression.  It's also the only way to disambiguate two equal-length patterns.
10:05:41 <guenni> I see
10:05:44 <kc5tja> guenni: Nope -- the case has the same top-down matching rules.
10:05:45 <kc5tja> :)
10:06:05 <quicksilver> guards also use first-match semantics
10:06:10 <kc5tja> (I found this out the hard way once before.  Fun time debugging THAT one.)
10:06:20 <guenni> yes but that case stuff is a case of "because we say so" or "so be it"
10:06:31 <quicksilver> basically it's because it's useful to have overlapping cases
10:06:45 <quicksilver> and since it's useful to have overlapping cases, you need a simple way of choosing
10:07:08 <quicksilver> consider the standard factorial: f 0 = 1; f n = n * f (n-1)
10:07:28 <quicksilver> there's no way of saying, in a pattern 'n except not zero'
10:07:51 <guenni> yes that was exactly where it occured to me
10:08:15 <quicksilver> it's very useful and in no way impairs the mathematics :)
10:09:24 <guenni> are there any other booby traps like this one should be aware of?
10:09:43 <quicksilver> well it's been mentioned that case and guard behave the same
10:10:02 <quicksilver> I'm not sure I'd call it a booby trap, I suppose it's a question of perspective
10:10:58 <guenni> true, maybe I'm a bit to critical at the moment
10:11:42 <vincenz> is there some page detailing the different doc-formats?
10:11:44 <vincenz> like -- ^
10:11:46 <vincenz> and -- |
10:12:39 <quicksilver> http://www.haskell.org/haddock/haddock-html-0.8/index.html
10:12:39 <quicksilver> ?
10:12:39 <lambdabot> Title: Haddock User Guide
10:12:40 <kc5tja> Haddoc appears to be the most popular auto-doc tool for Haskell, based on my (limited) experience.
10:12:58 <vincenz> quicksilver: thx
10:15:02 * mux doesn't like in-code documentation
10:17:35 <jyasskin> mux: out-of-code means out-of-date. ;)
10:17:55 <mux> jyasskin: that's what people say all the time
10:17:56 <mux> it's so wrong
10:18:11 <mux> do you think putting docs in comments actually makes the developers update docs?
10:18:17 <mux> been there, tried that, the answer is no :-)
10:19:02 <jyasskin> in-code is frequently out-of-date too, but it's more likely to be updated than some other file entirely.
10:19:14 <mux> I doubt that "likeliness" pretty much :-)
10:19:16 <vincenz> heh
10:19:20 <vincenz> haddock doesn't like GADTs
10:19:29 <mux> that being said, it's time for me to come home
10:19:29 <vincenz> at least not version 0.7-1
10:19:34 <ddarius> not-code means out-of-date
10:20:43 <shapr> I like literate Haskell.
10:21:36 <guenni> I need some encouragement here
10:21:46 <quicksilver> literate code is excellent, if you are 'telling a story'
10:21:49 <quicksilver> and the code goes along with it
10:21:53 <quicksilver> like some good papers I've read
10:21:55 <guenni> are you guys happy with haskell, is it worth the effort?
10:22:06 <glguy> lol
10:22:10 <quicksilver> guenni: it's the best language you'll ever use
10:22:16 <quicksilver> guenni: it will solve all your problems
10:22:19 <quicksilver> guenni: it will make you rich
10:22:35 <guenni> young and pretty too?
10:22:35 <quicksilver> guenni: it will make you extremely attractive to the opposite and/or same sex (according to your preferences)
10:23:01 <nominolo> guenni: it always Does What You Mean (TM)
10:23:07 <quicksilver> IME literate programming doesn't scale so well to 'frequently modified heavily under development' code
10:23:07 <guenni> thanks there quicky
10:23:19 <vincenz> quicksilver: agreed
10:23:23 <chessguy> ugh, i can't stand literate programming
10:23:23 <quicksilver> especially if it's multiple coders modifying it
10:23:25 <chessguy> wait
10:23:30 <chessguy> are quicksilver and i agreeing on something?
10:23:40 <quicksilver> we agree all the time!
10:23:42 <quicksilver> except when you're wrong
10:23:45 <chessguy> do not!
10:24:05 <nominolo> you usually agree not to agree?
10:29:41 <benja_> oh cool, using the darcs version fixes my problem with hs-plugins!
10:29:53 <benja_> so useful that dons' homepage is working again .)
10:30:47 <ClaudiusMaximus> benja_: oh, were you trying to use the release candidate tarball with ghc 6.6?
10:31:17 <benja_> ClaudiusMaximus: yep, not knowing better I was %-)
10:31:48 <nominolo> :t timeZoneMinutes
10:31:50 <lambdabot> Not in scope: `timeZoneMinutes'
10:32:14 <nominolo> :t Data.Time.LocalTime.timeZoneMinutes
10:32:16 <lambdabot> Data.Time.LocalTime.TimeZone.TimeZone -> Int
10:33:25 <nominolo> :t \x -> let t = Data.Time.LocalTime.utc in t { timeZoneMinutes = x }
10:33:27 <lambdabot> Not in scope: `timeZoneMinutes'
10:33:34 <nominolo> :t \x -> let t = Data.Time.LocalTime.utc in t { Data.Time.LocalTime.timeZoneMinutes = x }
10:33:36 <lambdabot> Int -> Data.Time.LocalTime.TimeZone.TimeZone
10:33:53 <nominolo> is there a way to unify these into one function?
10:34:22 <nominolo> ie. to join a getter and a setter into one?
10:35:17 <nominolo> something like: newtype Modifier r e = Mod (r -> Maybe e -> (Maybe e, r))
10:36:04 <bringert> nominolo: add real records to Haskell?
10:36:37 <nominolo> bringert:  that's what i was hoping to avoid .. :/
10:38:26 <nominolo> though, i guess i can emulate this with template haskell, for now
10:41:57 <sioraiocht> zomg I just had an idea--I'm totally writing a widget for dashboard that has an interactive ghci session...
10:42:15 <glguy> there is already a console widget
10:42:16 <glguy> so..
10:42:20 <glguy> you could just have ghci running in it
10:42:26 <sioraiocht> way to make me SO sad, lol
10:42:31 <sioraiocht> but touche
10:43:13 <sioraiocht> I thoguht I was being x innovative x
10:43:51 <quicksilver> nominolo: various libraries have reimplemented what you're calling Modifier
10:43:57 <quicksilver> nominolo: HOpenGL is one, for example
10:44:51 <nominolo> quicksilver: how do they call it? :)
10:44:53 <quicksilver> although maybe hopengl's are always trapped inside the IO monad
10:44:58 <quicksilver> Attribute, I think?
10:46:47 <nominolo> quicksilver: i see.  they have state vars and type classes
10:47:04 <nominolo> though i was hoping for a one-liner
10:47:34 <nominolo> ie. data Foo = MkFoo { blar :: Boo }   myMod = blar
10:48:28 <nominolo> i think myMod = $(mkMod [| blar |]) might work though
10:49:12 <quicksilver> could be TH-sledgehammer-nut syndrome though :)
10:50:43 * nominolo comes from Common Lisp
10:50:46 <nominolo> :)
10:51:43 <nominolo> it would be pretty elegenat though:  set :: Modifier r e -> r -> e -> r
10:52:10 <nominolo> setM :: Modifier r e -> r -> e -> m
10:52:16 <vincenz> m ()
10:52:20 <nominolo> premature return
10:52:36 <nominolo> + Monad m =>
10:52:42 <vincenz> nominolo: m ()
10:52:51 <nominolo> yes, thanks :)
10:53:46 <nominolo> otoh, very imperative
10:56:24 <vincenz> ok, quick question
10:56:29 <vincenz> class has method, so interface has ...
10:56:50 * vincenz is trying to think for a good name for his datacons
10:56:56 <nominolo> abstract method?
10:57:01 <vincenz> eh
10:57:04 <vincenz> something more concise?
10:57:27 <nominolo> abstrmeth? ;)
10:57:49 <vincenz> CMethod and IMethod
10:57:54 * vincenz mutters
10:58:01 <vincenz> naming, the hardest part of coding
10:58:12 * sioraiocht disagrees.
10:58:18 * nominolo things the distinction between class and interface quite arbitrary/useless
10:58:24 <nominolo> +is
10:58:43 <vincenz> nominolo: not in my case
10:58:44 <sioraiocht> nominolo: in what context?
10:58:55 <nominolo> OOP
10:58:57 <vincenz> nominolo: you make too many assumptions
10:59:12 <sioraiocht> nominolo: in all OOP? I'd rather have interfaces than the multiple inheritance hell in C++
10:59:31 * nominolo likes multiple inheritance heaven in CLOS
10:59:35 * vincenz is using interfaces to model native types
10:59:49 <vincenz> aka, those that are unimplementable as real classes
10:59:58 <Codex_> interface is infinitely thin surface. class is something else...
11:00:00 <vincenz> but still need an interface for typecheck purposes
11:00:22 <nominolo> hm
11:00:31 <vincenz> back to coding
11:01:11 <nominolo> vincenz: from the thesaurus: 1 they use very old-fashioned methods procedure, technique, system, practice, routine, modus operandi, process; strategy, tactic, plan.
11:01:19 <nominolo> routine?
11:02:53 <ddarius> routine is too 1960s/70s
11:03:06 <nominolo> btw: a method is the *implementation* of an overloaded function
11:03:33 <ddarius> Anyways, I am off.
11:03:37 <nominolo> ddarius: time to become fashionate again
11:03:55 <vincenz> nominolo: correct
11:04:53 <vincenz> this is the biggest AST I've ever coded :/
11:04:57 * vincenz curses
11:14:07 <shapr> Does cabal-get really work? If so, is there an intro on how to set it up and use it?
11:15:12 <Lemmih> It's called cabal-install now. And yes, it really does work (I think).
11:15:20 <shapr> Spiffy, is there an intro?
11:17:52 <Lemmih> Seen the INSTALL and README: http://darcs.haskell.org/packages/Cabal/cabal-install/ ?
11:17:54 <lambdabot> Title: Index of /packages/Cabal/cabal-install
11:19:39 <shapr> Lemmih: That would be too easy... I'll try that :-)
11:23:34 <miez> shapr if you manage to make it work, you could write some docs on it ;)
11:26:08 <chessguy> can someone tell me what paper this is? i'd like to google for a pdf version, since i don't have a PS reader
11:26:10 <chessguy> http://web.cecs.pdx.edu/~apt/jfp01.ps
11:27:13 <miez> chessguy ghostview can convert ps to pdf afaik
11:27:34 <chessguy> i'm on a work PC, and don't want to install software on it
11:27:50 <ndm> ghostview also can view ps, so i guess he doesn't have that either
11:27:52 <chessguy> i just need the title
11:28:14 <ndm> modular lazy search for constraint satisfaction problems
11:28:21 <chessguy> thanks
11:28:44 <vincenz> the pain of using GADTs: having to derive your own Eq classes
11:28:59 <chessguy> Andrew Tolmach and Thomas Nordin ?
11:29:19 <ndm> yep
11:29:23 <vincenz> (not to mention show instances
11:29:26 * vincenz sighs
11:29:34 <chessguy> hmm, this PDF looks like a collection of powerpoint slides
11:29:35 * ndm tells vincenz to use H98
11:29:44 <vincenz> ndm: I need GADTs
11:30:01 <ndm> vincenz: what for?
11:30:06 <vincenz> easy traversal
11:30:11 <vincenz> and strong typing
11:30:15 * ndm can do that with haskell 98
11:30:37 <vincenz> no you can't
11:30:42 <ndm> oh yes i can ;)
11:30:43 <vincenz> either you lose easy traveral
11:30:46 <vincenz> or you lose strong typing
11:30:50 <ndm> i don't
11:30:56 <ndm> but they i use Play, which you don't have
11:31:12 <ndm> you loose a few things, but not much
11:31:15 <vincenz> we talked about that
11:31:25 <ndm> and the things you gain with GADT over Play isn't worth the pain of GADT, in  my opinion
11:31:38 <fantasma> can I ask a linux question in here? =\
11:31:49 <vincenz> my gadt is 100 lines of haskell code
11:31:52 <vincenz> the gadt definition alone
11:31:57 <vincenz> granted, I put each parameter on a separte line
11:32:01 <vincenz> liek so
11:32:01 <vincenz>   Ident   :: Ident
11:32:01 <vincenz>           -> AST Ident_ tag
11:32:20 <vincenz> and that's after emptyline and comment removal
11:32:32 <ndm> i'm writing a paper on Play, so that should sell the case for Play quite strongly
11:33:45 <vincenz> ndm: I've seen play, you showed me it
11:34:00 <vincenz> ndm:  it looks quite nice but it doesn't do what I need
11:34:02 <vincenz> gadts do
11:35:55 <ski> 'Play' ?
11:35:56 <lambdabot> ski: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:36:58 <vincenz> anyone know a way to align code?
11:37:01 <vincenz> in vim
11:37:02 <ndm> ski, its my competitor to Scrap Your Boilerplate
11:37:26 <ski> elaborate ? pointer ?
11:37:46 <ndm> http://www.cs.york.ac.uk/fp/darcs/play/play.htm
11:37:47 <glguy> ?type flip . flip foldr id . (flip (.) .) . flip
11:37:49 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:37:50 <lambdabot> Title: Play With Your Boilerplate
11:37:58 <ski> danke
11:38:01 <ndm> ski, ^^  - but its not officially release/announced yet
11:38:06 <ski> ok
11:38:43 <ski> http://www.cs.york.ac.uk/fp/darcs/play/play.htm
11:38:43 <lambdabot> Title: Play With Your Boilerplate
11:38:50 <glguy> > let foldl_ = flip . flip foldr id . (flip (.) .) . flip in foldl_ (flip (:)) [] [1..10]
11:38:50 <ski> er
11:38:51 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
11:42:06 <ray> who's writing a raytracer in the typesystem now
11:42:25 <ski> kc5tja : 'return conventions' ?
11:42:47 <vincenz> yay for vim power
11:43:30 <vincenz> ndm: play is very nice but lacks typing
11:43:58 <vincenz> oh wait
11:44:00 <vincenz> new section at the end?
11:44:19 <glguy> play is the only way that is typechecked
11:44:22 <glguy> one*
11:44:23 <glguy> only one
11:44:33 <glguy> at compile time
11:44:39 <ndm> vincenz: i would have said it was always type checked, but i guess it depends on your definition of type checked
11:44:48 <vincenz> ndm:  explamples of section 4 ... that's what covers it :)
11:44:51 <ndm> vincenz: not much modification to that document in ages
11:45:53 <ski> ndm : ah .. 'replaceChildren' is interesting .. reminds of comonads, somehow
11:46:14 <ndm> ski, thats the basis of the whole library
11:46:16 <vincenz> ndm: I must have read over that section then, cause in the beginning you mostly stick to mono-typed examples :/
11:46:39 <ndm> vincenz: i do, because they are simplest
11:46:39 <ski> replaceChildren :: Play on => on -> Cxt [on] on
11:46:55 <vincenz> ndm: yeah but fail to show the power over many other things
11:47:05 <ndm> vincenz: but are hte most common way to use it
11:47:06 <vincenz> ndm: they don't sell it well, case in point being me :)
11:47:14 <vincenz> otherwise said, they undersell
11:47:19 <ndm> vincenz: i can try and fix that when i write hte paper - thanks for the tip
11:47:28 <vincenz> np
11:47:36 <ndm> ski, i'm not really familiar with comonads...
11:48:02 <ski> ndm : just an idle observation .. i don't know if it has relevance, here
11:48:20 <kc5tja> ski: Return conventions manage how code "returns" to its caller.  It, like calling conventions, are specializations of continuation-passing.
11:49:27 <ski> kc5tja : do you mean alternative return points =
11:49:32 <ski> s/=/?/
11:51:19 <ski> (kc5tja : and where did you get that phrase from ? .. some article ?)
11:52:17 <vincenz> @seen dmhouse
11:52:18 <lambdabot> I saw dmhouse leaving #happs, #haskell-blah and #haskell 1d 3h 23m 15s ago, and .
11:52:21 <vincenz> @seen zarvok
11:52:21 <lambdabot> I saw zarvok leaving #oasis and #haskell 13h 58m 26s ago, and .
11:54:17 <ski> ndm : hm .. looking at '(/\)', etc, i get a feeling that this may indeed be related to the 'Cxt' comonad ..
11:54:42 <ski> '(/\)' is basically a kind of application, yes ?
11:54:50 <icarroll> @src sequence
11:54:50 <lambdabot> sequence ms = foldr k (return []) ms
11:54:50 <lambdabot>     where
11:54:50 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
11:56:21 <icarroll> Where can I find info on the ((->) e) monad?
11:57:15 <nominolo|afk> @instances Monad
11:57:16 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:58:20 <ski> wf /\! x = wf =>> \wf' -> extract wf' x   -- i suspect ..
11:59:13 <kc5tja> ski: Yes.  (Sorry for not being completely responsive; I'm currently at work, fighting with Java.  >:( )
11:59:23 <kc5tja> And, as if that weren't enough, I think Firefox just died.
12:00:04 <ski> kc5tja : ok .. i think it might be related to Olin Shivers' "multi" paper
12:00:21 <kc5tja> ski: Think what is?
12:00:34 <ski> http://www-static.cc.gatech.edu/~shivers/papers/mrlc-jfp.pdf
12:00:46 <ski> 'return conventions'
12:01:03 <kc5tja> ski: I read about "return conventions" eons ago.  Reading it in SPJs paper only reminded me of the concept.
12:01:14 <ski> (but i would like to see the link where you read about it ..)
12:01:22 <ski> which one ?
12:01:38 <kc5tja> It's good that FPL papers are "re-inventing" or "re-discovering" techniques used by "cowboy coders" of the past; the emphasis this time being that they're formalized and well-defined instead of adhoc.
12:01:46 * ski nods
12:02:03 <icarroll> Ok, I know that ((->) foo) is a monad. Where can I find more info?
12:02:15 <ski> Control.Monad.Reader
12:02:54 <kc5tja> ski: The first time I read about return conventions was in an 80s-era programming book I no longer have.  Return conventions also appears in Thinking Forth (although not by that name), by Leo Brodie.  And again, it's mentioned briefly in SPJ's "Implementation of Lazy Functional Programming Languages: The Spineless, Tagless G-Machine, version 2.5".
12:03:14 <ski> kc5tja : ty
12:03:20 <kc5tja> no problem.
12:03:53 <kc5tja> It's not that terribly exciting -- calling conventions are more interesting.  But the two combined can make for some pretty wild optimizations (which Haskell uses to great effect in resolving case statements quickly).
12:04:11 <nominolo> icarroll: http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
12:04:36 <nominolo> but this is not the instance Monad declaration
12:06:09 <icarroll> nominolo: thanks
12:06:12 <nominolo> icarroll: http://www.google.com/codesearch?hl=en&lr=&q=instance%5C+Monad%5C+%5C%28%5C%28%5C-%5C%3E%5C%29+lang%3Ahaskell&btnG=Search
12:06:22 <lambdabot> Title: instance\ Monad\ \(\(\-\>\) lang:haskell - Google Code Search, http://tinyurl.com/2e6tx5
12:06:30 <icarroll> Is there an explanation of it anywhere?
12:07:38 <nominolo> looks like a simple transformation to CPS
12:07:56 <nominolo> hm, makes sense
12:14:31 <chessguy> ?vera svm
12:14:32 <lambdabot> No match for "svm".
12:22:57 <Cheery> I have lots of stuff like: [0, pi/20..] and [0, 0.1.. 1]
12:23:50 <ski> kc5tja : hm, 'resolving case statements', what do you refer to ?
12:24:22 <Cheery> but I'd like to have then dynamic, ie. [0, pi/20..] being [0, pi/n] where n = anything
12:25:37 <psi> Cheery: write a function
12:26:20 <hyrax42> can you even do that with the [..] sugar?
12:26:25 <Cheery> or wait, it seems working like that.
12:26:34 <hyrax42> > [0, 0.1 .. 1]
12:26:35 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999...
12:26:43 <hyrax42> huh
12:26:50 <Cheery> lol
12:26:53 <hyrax42> I thought it required an Enum instance
12:27:01 <hyrax42> ?instances Enum
12:27:02 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
12:27:03 <ski> > let n = 4 in [0,pi/n .. pi]
12:27:04 <lambdabot>  [0.0,0.7853981633974483,1.5707963267948966,2.356194490192345,3.141592653589793]
12:27:15 <hyrax42> what the devil
12:27:19 <Cheery> ok, it seems working, I fucked up somewhere else.
12:27:21 <fantasma> it's beautiful
12:27:34 <hyrax42> > take 10 [0..1] :: [Float]
12:27:35 <lambdabot>  [0.0,1.0]
12:27:54 <hyrax42> > succ 0 :: Float
12:27:55 <lambdabot>  1.0
12:28:05 <fantasma> > fix Nothing
12:28:06 <lambdabot>  Couldn't match expected type `a -> a'
12:28:11 <hyrax42> that's counter intuitive
12:28:29 <psi> what would you have it be?
12:28:49 <hyrax42> well as approximations of the Reals, I wouldn't have them enumerable
12:29:19 <fantasma> > map (/0) [1..]
12:29:20 <lambdabot>  [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Inf...
12:29:34 <hyrax42> but this is more useful, I guess
12:29:34 <Cheery> anyways, I've been thinking lazily today, would anybody happen to have readily made routines to draw spiral out of lines?
12:30:23 <Japsu> > succ ()
12:30:24 <lambdabot>  Exception: Prelude.Enum.().succ: bad argument
12:30:27 <fantasma> Cheery: like a number spiral?
12:30:32 <Japsu> :o
12:30:38 <Japsu> now is that evil or what
12:30:41 <encryptio> :t Infinity
12:30:43 <lambdabot> Not in scope: data constructor `Infinity'
12:30:48 <Cheery> fantasma: well, graphical spiral, with openGL.
12:31:06 <fantasma> ah I see, nevermind then
12:31:09 <psi> fromEnum ()
12:31:12 <hyrax42> Japsu: well a one-element type, that makes sense
12:31:13 <psi> > fromEnum ()
12:31:14 <lambdabot>  0
12:31:27 <hyrax42> > [()..]
12:31:28 <lambdabot>  [()]
12:31:32 <Japsu> hmm why can't it overwrap?
12:31:36 <Japsu> succ () = ()
12:31:51 <ski> > succ True
12:31:52 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
12:31:54 <hyrax42> > succ True
12:31:55 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
12:31:59 <hyrax42> hehe
12:32:19 <fantasma> microsoft is making a shell named Monad, has anyone else heard about this?
12:32:20 <ski> > maxBound :: Float
12:32:21 <lambdabot>   add an instance declaration for (Bounded Float)
12:32:21 <lambdabot>     In the expression: maxB...
12:32:25 <hyrax42> > succ maxBound :: Int
12:32:26 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
12:32:42 <ski> fantasma : i thought they renamed it to 'PowerShell' .. ?
12:33:08 <fantasma> ski: ah I guess you're right
12:33:30 <fantasma> (did it change because of Haskell?)
12:37:44 <ddarius> fantasma: That was brought up a -long- time ago.
12:38:30 <chessguy> in HSOE, it seems to me that the stuff on animations/behaviors is monadic, even though he never defines them as such?
12:39:51 <jyp> I would like to attract people attention on the recent advents in the Yi editor development...
12:40:00 <jyp> http://haskell.org/haskellwiki/Yi
12:40:01 <lambdabot> Title: Yi - HaskellWiki
12:40:04 <hyrax42> ?where HSOE
12:40:04 <newsham> fantasma: they've already made it, and it is now called "PowerShell"
12:40:04 <lambdabot> I know nothing about hsoe.
12:40:09 <newsham> ?google powershell
12:40:11 <lambdabot> http://www.microsoft.com/windowsserver2003/technologies/management/powershell/default.mspx
12:40:12 <lambdabot> Title: Windows PowerShell
12:40:15 <hyrax42> ?google hsoe haskell
12:40:19 <jyp> It's now scriptable in haskell...
12:40:21 <lambdabot> http://www.oluyede.org/blog/2006/11/28/quote-of-the-month/feed/
12:40:48 <jyp> So I thought other people could have a look
12:41:33 * mnislaih gives yi a try
12:41:59 <hyrax42> hm
12:42:15 <jyp> Probably very rough still though
12:42:29 <jyp> so; be prepared to contribute bugfixes :)
12:42:42 * fantasma has to go to class
12:42:45 <hyrax42> the body of emacs lisp code is far too big... though a saner language to write plugins in is interesting
12:43:41 <jyp> The idea is that I should be really easy to link-in regular haskell code;
12:43:49 <jyp> ie. not written with edior in mind
12:43:54 <jyp> editor
12:44:16 <pstickne> emacs lisp isn't .... oh, wait, nvm :p
12:44:58 * pstickne curses the vast amount of elisp which, while make emacs great, act like an anchor :-/
12:45:00 <jyp> that should keep the yi-specific code to manageable sizes
12:47:57 <glguy> can anyone think of a function name for "number of elements less than" as in: f 4 [1..10] = 3
12:48:15 <hyrax42> countLT
12:48:57 <glguy> that's a bit better than my lessThanCount
12:49:00 <glguy> I'll go with it :) Thanks
12:49:10 <hyrax42> heh
12:49:26 <hyrax42> ?pl \x -> length . filter (<x)
12:49:26 <lambdabot> (length .) . filter . flip (<)
12:49:35 <hyrax42> ^^^^
12:49:36 <hyrax42> or that
12:49:38 <hyrax42> ;)
12:49:52 <glguy> well... the operation doesn't actually operate on lists :)
12:50:14 <glguy> countLT i = getSum . snd . F.measure . F.takeUntil (\x -> fst x >= Key i) . getTree
12:50:22 <hyrax42> ah well then
12:51:41 <procyon_> what's the best way to write a function to get the last element in a non-empty list?  I was playing around and came up with foldl (const id) (head a) a but I'm not sure if that's really a good way
12:51:52 <glguy> ?src last
12:51:53 <lambdabot> last [x]    = x
12:51:53 <lambdabot> last (_:xs) = last xs
12:51:53 <lambdabot> last []     = undefined
12:52:28 <procyon_> DOH! The prelude strikes again.
12:52:47 <mauke> @hoogle [a] -> a
12:52:48 <lambdabot> Prelude.head :: [a] -> a
12:52:48 <lambdabot> Prelude.last :: [a] -> a
12:52:48 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
12:52:49 <procyon_> I really need to memorize all the prelude functions.
12:53:14 <glguy> ?type let last_ xs = foldr (\x f -> f x) id xs undefined in last_
12:53:16 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
12:53:17 <lambdabot>     Probable cause: `f' is applied to too many arguments
12:53:47 <psi> procyon_: no, use hoogle :)
12:54:33 <procyon_> is hoogle in ghci somewhere, or at least available as a desktop app?  I don't always have net access, and it would be real nice to access it in the repl
12:55:00 <procyon_> same question in regards to lambdabot's ?src
12:55:01 <psi> good question
12:55:16 <psi> can you install hoogle locally? i think you can.
12:55:34 <glguy> > let last_ = flip (foldr (\x f _ -> f x) id) undefined in last_ [1..10]
12:55:35 <lambdabot>  10
12:55:46 <procyon_> I need lambdabot as a kind of MS Office annoying paperclip assistant ;)
12:57:13 <glguy> (\x f _ -> f x) -- (const .) . flip id
12:57:13 <newsham> you can run lambdabot locally, it has hoogle
12:57:19 <procyon_> glguy: isn't that essentially what I did, except that I used foldl... which is tail recursive and since I'm traversing the entire list in every event, the laziness of foldr doesn't buy me anything?  Am I missing something?
12:57:38 <glguy> procyon_: your version didn't offer anything that the Prelude one didn't
12:57:46 <glguy> I didn't think we were posting solution for that reason
12:57:52 <procyon_> > foldl (const id) undefined [1..10]
12:57:53 <lambdabot>  10
12:57:59 <glguy> I've been on a "foldl is unnecessary" kick
12:57:59 <psi> it would be nice to get hoogle into emacs rather like C-h a.
12:58:09 <glguy> so I post foldr versions of foldl code
12:59:59 <newsham> glguy: let bindings are also unnecessary.
13:00:07 <glguy> newsham: agreed
13:00:13 <procyon_> glguy: Ahh.  I agree foldr is generally superior when lazy eval buys you something... but when you *have* to traverse the entire list anyway, I would think the foldl versions best, since you get tail recursion.. but I am a n00b and often require correction of my invalid assumptions :)
13:00:16 <glguy> that's why I've been following them up with a pointfreed version ;)
13:00:37 <newsham> composition operator is unnecessary
13:00:38 <glguy> procyon_: the tail recursion from foldl is not tail recursion
13:00:52 <newsham> ?src foldl
13:00:52 <lambdabot> foldl f z xs = lgo z xs
13:00:52 <lambdabot>     where lgo z []     =  z
13:00:52 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
13:00:53 <sjanssen> foldl is only useful when the function is strict in the "accumulator" parameter
13:00:58 <glguy> newsham: I'm clearly joking about thinking that foldr is always appropriate
13:01:00 <sjanssen> and even then you should use foldl'
13:01:07 <kc5tja> ski: re: resolving case statements -- deciding which branch of a case statement with minimum time.
13:01:35 <procyon_> glguy: Ahh... see. I'm FULL of invalid assumptions.
13:02:28 <sjanssen> @keal
13:02:28 <lambdabot> can haskell pipe the raw irrational megaequation into an analog device
13:22:20 <shapr> sjanssen: Oh hey, xmonad does reliably crash with gnome-theme-manager. I saved the .xsession-errors files from that, but it doesn't say much.
13:24:35 <SamB> what was xmonad called before? I forgot...
13:24:40 <shapr> thunk
13:24:49 <SamB> ah.
13:25:00 <SamB> yeah, xmonad is WAY more googleable ;-)
13:25:40 <SamB> @go xmonad
13:25:42 <lambdabot> http://darcs.haskell.org/~sjanssen/xmonad/
13:25:43 <lambdabot> Title: Index of /~sjanssen/xmonad
13:25:46 <Cheery> http://mathworld.wolfram.com/LogarithmicSpiral.html
13:25:47 <lambdabot> Title: Logarithmic Spiral -- from Wolfram MathWorld
13:25:55 <defcon8> how are things like changing of databases done in haskell efficiently?
13:26:05 <Cheery> where are the logarithm -stuff for haskell?
13:26:52 <Cheery> I found only log, but didn't found the 'e'.
13:27:02 <shapr> > e
13:27:03 <lambdabot>   Not in scope: `e'
13:28:45 <ndm> > exp
13:28:46 <lambdabot>  <Double -> Double>
13:28:48 <ndm> > exp 1
13:28:49 <lambdabot>  2.718281828459045
13:31:08 <defcon8> anyone?
13:32:06 <augustss> defcon8: changing up databases?  do you mean update?  or switching to a different database
13:32:13 <defcon8> yes updating, sorry
13:32:33 <augustss> it's some IO (or other monad) action
13:33:23 <psi> does lambdabot have less verbose error messages now?
13:33:54 <psi> like it said <Double -> Double>. haven't seen that before.
13:34:14 <psi> nevermind. heh.
13:34:14 <mauke> > show exp
13:34:16 <lambdabot>  "<Double -> Double>"
13:34:20 <shapr> defcon8: There are lots of approaches.
13:34:20 <ndm> psi: i think thats just a show instance for types
13:34:25 <integral> That's not an error message, that's a show instance for functions using magical GHC dynamic typing stuff
13:34:39 <mauke> > iterate show exp
13:34:40 <lambdabot>  Couldn't match expected type `String'
13:34:41 <SamB> has anyone got an O(log(n)) replacement for GNU ld(1) yet?
13:34:48 <shapr> defcon8: You can use monads to prove that a single value can be safely updated in place.
13:35:06 <SamB> or, er, O(n*log(n))
13:35:12 <psi> ndm: cool, i haven't seen that before.
13:35:45 <ndm> integral: you can do it without any magic at all
13:35:57 <psi> is that new in ghc? usually there's no instance for show.
13:36:06 <shapr> defcon8: You can update a value with a bunch of nested values incrementally, and only the new values will be allocated, and only the unused values will be garbage collected.
13:36:16 <ndm> you can write one easily enough
13:36:36 <ndm> > id
13:36:37 <lambdabot>  Add a type signature
13:36:43 <QtPlatypus> SamB: What is the worce then O(n*log n) aspect of the algorthym ld uses?
13:36:49 <ndm> see, its only monomorphic
13:37:01 <ndm> Yhc could do it polymorhicly :)
13:37:09 <defcon8> shapr, I don't get it
13:37:21 <SamB> QtPlatypus: unless it has stopped using alists for symbols?
13:37:48 <shapr> defcon8: Which, the first or the second?
13:38:08 <defcon8> second
13:38:12 <shapr> Is there some famous author named CastaÒeda?
13:38:45 <mauke> http://en.wikipedia.org/wiki/Carlos_Castaneda
13:38:56 * SamB wonders how lousy a linker written in Haskell would be
13:38:59 <shapr> defcon8: The first thing that comes to mind is The Zipper, but I'm sure there are simpler examples.
13:39:12 <defcon8> I think I'll just read the tutorial first
13:39:18 <defcon8> I keep starting and getting dragged back to lisp
13:39:27 <shapr> defcon8: Ok, but if you have any questions about Haskell, feel free to ask.
13:39:38 <defcon8> thanks
13:39:39 <augustss> shapr: Carlos Castaneda.  Weird guy.
13:40:16 <augustss> @users
13:40:16 <lambdabot> Maximum users seen in #haskell: 336, currently: 327 (97.3%), active: 53 (16.2%)
13:40:53 * SamB thinks Setup.lhs ought to be more like setup.py...
13:41:10 <SamB> it should not be required to go through all of these individual steps one by one...
13:41:17 <shapr> cabal-install does that.
13:41:21 <SamB> hmm.
13:41:29 * SamB wonders if his works
13:41:58 <SamB> hmm, my Display has no Show instance...
13:42:05 <psi> shapr: did you have luck with cabal-install>
13:42:24 <psi> i have yet to test it out
13:42:43 <shapr> psi: Nah, I've been distracted by paying work, and non-paying fun.
13:42:51 <psi> ok
13:43:00 <shapr> But if you do try it out, I want to hear about it!
13:43:59 <psi> sure, i'm going to do it later tonight.
13:44:37 <defcon8> here's an example: I have a function that needs all prime numbers up to a certain number. What can be done so that the primes don't have to be calculated if the new number is lower or the ones up to the previous number if the new number is higher
13:45:20 <defcon8> is that done with monads too? is there no other alternative?
13:45:44 <shapr> I think you're talking about memoization.
13:45:47 <SamB> shapr: what version of the X11 package do you have installed?
13:46:08 <shapr> 1.2
13:46:37 <shapr> defcon8: That does not require monads, and is much simpler.
13:47:40 <sjanssen> SamB: does xmonad not build with older X11 packages?
13:47:50 <SamB> sjanssen: precisely
13:47:53 <SamB> well
13:48:00 <SamB> actually, X11-extras doesn't build
13:48:24 <SamB> Extras.hsc:25:5:
13:48:24 <SamB>     No instance for (Show Display)
13:48:24 <SamB>       arising from the 'deriving' clause of a data type declaration at Extras.hsc:25:5
13:48:33 <shapr> defcon8: This might help some - http://www.haskell.org/hawiki/MemoisingCafs
13:48:34 <lambdabot> Title: MemoisingCafs - The Haskell Wiki
13:48:41 <SamB> that is with X11-1.1
13:49:13 <SamB> sjanssen: are you going to fix it or would you like a patch?
13:50:02 <sjanssen> SamB: I'd like to keep the show instance
13:50:09 <sjanssen> it is useful for debugging
13:50:16 <SamB> I meant, are you going to fix the cabal file
13:50:24 <sjanssen> oh yeah, I'll fix the cabal file
13:50:41 <SamB> -build-depends:     base, X11
13:50:41 <SamB> +build-depends:     base, X11>=1.2
13:50:54 <shapr> I sure do like xmonad. It's fast, flexible, and does almost everything I want a wm to do.
13:52:12 <sjanssen> SamB: pushed, thanks
13:56:47 <shapr> defcon8: Did that help?
13:57:27 <defcon8> shapr, sorry, I was replying to a noob on rentacoder who was claiming that I was a liar and that my code doesn't work
13:57:39 <defcon8> turns out he was setting a directory name as a URL the whole time
13:57:45 <defcon8> bloody threatening with arbitration
13:57:45 * SamB builds and installs X11-1.2 by hand...
13:58:42 <shapr> I used to do rentacoder etc, but I couldn't handle the stupidity.
13:58:50 <defcon8> I need money for books
13:59:01 <shapr> There are non-sucky ways to code for books.
13:59:18 <defcon8> I asked him thrice if he was setting the directory properly and if he had chmodded it correctly
13:59:23 * SamB wonders if there is a journeycoder
13:59:30 <defcon8> the guy didn't even know what Debian was and he was asking for something that works for linux
13:59:32 <LPhas> using ghci in emacs haskell mode, there's a way to use last used commands. like with the "up arrow" key in ghci
13:59:34 <LPhas> ?
13:59:38 <defcon8> shapr, what like?
13:59:42 <shapr> LPhas: M-p
13:59:46 <defcon8> I'm under 18, have no qualifications, etc
13:59:54 <dylan> defcon8: "linux" means redhat or suse for that sort, y'know?
13:59:59 <defcon8> no actual company will take me on
14:00:01 <defcon8> dylan, oh yeah
14:00:03 <shapr> defcon8: You're in or beginning college, yeah?
14:00:10 <defcon8> and you know what? this guy is a bloody IT supervisor
14:00:17 <LPhas> shapr, mmh, no
14:00:22 <dylan> defcon8: welcome to the world of IT! :)
14:00:22 <defcon8> shapr, I'm starting college this year I hope
14:00:32 <shapr> LPhas: err, yes?
14:00:37 <defcon8> dylan, please, I may give up studying CS altogether
14:00:45 <dylan> oh, CS is fun
14:00:52 <shapr> defcon8: So, go to the college, hook up with some profs, and do grunt coding for them. And do it really well.
14:00:55 <augustss> CS /= IT
14:01:03 <shapr> defcon8: Soon you will have more work than you can shake a keyboard at..
14:01:05 <defcon8>  The confusing part is that, in the current application, the uploaded zip file is only uploaded for the comparison...It's never saved.
14:01:05 <defcon8> So you want me to create a new directory?
14:01:07 <defcon8> roflmao!
14:01:07 <LPhas> shapr, it says me "end of buffer"
14:01:13 <dylan> IT is my career as I don't want to hate CS. :)
14:01:31 <SamB> so, when will entire operating systems be made available with cabal?
14:01:34 <defcon8> augustss, yeah but where do CS people go?
14:01:37 <shapr> LPhas: Is your cursor in the inferior ghci buffer at the ghci prompt?
14:01:46 <LPhas> of course
14:01:47 <shapr> SamB: I was just thinking about that actually...
14:01:47 <defcon8> I think I'm going to submit these logs to thedailywtf.com
14:01:56 <augustss> defcon8: dunno, McDonald's?
14:02:02 <defcon8> oh
14:02:09 <SamB> shapr: I was doing the inevitable "cabal vs. debian" comparison again ;-)
14:02:09 <shapr> LPhas: What do you get from C-h k M-p ?
14:02:19 <glguy> there are plenty of companies whose business is software
14:02:27 <QtPlatypus> Mostly the same place IT guys go.
14:02:35 <augustss> defcon8: actually, I think there's quite a few interesting jobs you can get after studying CS
14:02:36 <QtPlatypus> glguy: Or places who need coders.
14:02:46 <defcon8> augustss, what like?
14:02:56 <shapr> In my opinion, the really good software jobs require CS cluefulness.
14:03:02 <glguy> IT is the department of a company that supports the actual business goals
14:03:13 <shapr> augustss' current job is pretty dang cool...
14:03:22 <augustss> I don't complain
14:03:27 <Heffalump> I do :-)
14:03:32 <shapr> mmm, clusters running DSLs...
14:03:32 <defcon8> shapr, that link is great, btw. Thanks.
14:03:40 <augustss> Heffalump: that's the commute ;)
14:03:41 * QtPlatypus is a CS guy and has a job as a programer at a network provider.
14:03:54 <defcon8> :(
14:03:55 <Heffalump> and running Windows, and Excel, and... :-)
14:04:09 <augustss> Heffalump: yeah, there is that
14:04:28 <shapr> defcon8: Seriously, hook up with the profs at your college before you start. Find the ones who are doing cool stuff and work for them.
14:04:44 <defcon8> well I'll be starting in a few months anyway
14:04:45 * SamB has writtten what he hopes is the major code for Computer Engineering on this transfer application...
14:04:46 <LPhas> shapr, a new frame on something bound to Ctrl-v
14:05:13 <SamB> ... because I've been playing with VHDL again, and want to learn how to do it right...
14:05:13 <shapr> I had a guy doing physical visual tests at uab who wanted to hire me to code graphics on his SGIs
14:05:25 <augustss> Heffalump: did you see that Ravi has added Id to the BS compiler?
14:05:38 <shapr> LPhas: That's really weird... C-h k is "show me what function is bound to the next key I press"
14:05:39 <Heffalump> yeah
14:05:51 <Heffalump> but I'm convinced he should have had to invent Ids
14:05:56 <LPhas> shapr, yeah i see
14:05:57 <augustss> SamB: you want Bluespec.  Bluespec Classic, that is
14:06:00 <shapr> Is there a non-commercial BS compiler available online?
14:06:14 <SamB> augustss: bluespec, you say?
14:06:39 <shapr> I'm curious as to how BlueSpec compares to Lava, Hawk, etc.
14:06:45 <SamB> oh, did I mention that after I learn how to do it right, I'm probably going to make my own HDL?
14:06:46 <augustss> shapr: no.  there used to be a time limited BS compiler, but no longer
14:06:48 <Heffalump> Lava is just a layout language, right?
14:07:08 <SamB> Heffalump: er, hmm?
14:07:12 <shapr> Yeah, Lava is just layout.
14:07:18 <augustss> SamB: yes, doing a HDL is fun
14:07:23 <SamB> what does "just layout" mean?
14:07:33 <shapr> @google lava singh haskell
14:07:35 <lambdabot> http://citeseer.ist.psu.edu/69503.html
14:07:35 <lambdabot> Title: Lava: Hardware Design in Haskell - Bjesse, Claessen, Sheeran, Singh (ResearchInd ...
14:07:43 <augustss> shapr: well, it's not "just layout"  you describe the circuit, including layout
14:08:06 <Heffalump> I think what I meant was that you still have to write the low-level logic directly.
14:08:06 <shapr> Yeah ok.. but it's mostly layout..
14:08:13 <SamB> no!
14:08:29 <SamB> you can use higher-order functions ;-)
14:08:36 <Igloo> augustss: Your invent-an-Id-to-unify-with sounds scary. I wonder how much ambiguity it would create if things like map really had monadic-style types
14:08:38 <augustss> You can do pretty high level things in Lava.  Abstractions....
14:09:13 <shapr> I'm still miffed that I missed the Lava download..
14:09:16 <SamB> I'd like a copy of Lava, but they don't seem to offer it...
14:09:19 <augustss> Igloo: if you want the Id proposal to work in practice I think you'd need to invent Id
14:09:30 <shapr> I saw it on xilinx.com one day, and the next day I went back to download it, but it'd been pulled.
14:09:36 <SamB> eeek
14:09:39 <SamB> too good?
14:09:48 <augustss> Ask Satnam
14:10:00 <Igloo> augustss: Hmm, possibly
14:10:03 <shapr> I emailed Satnam Singh about it, and he said they were likely to release an OSS version after vetting the code
14:10:09 <shapr> But it never happened
14:10:11 <augustss> ah
14:10:16 <Heffalump> Igloo: but it's a natural consequence of the Id you described
14:10:26 <Heffalump> oh, augustss said that, sorry
14:10:34 <SamB> is this one of those "never got around to it" things, or one of those "not going to happen" things?
14:10:43 <shapr> It was a "not going to happen" thing.
14:10:52 <Heffalump> Satnam left Xilinx a long time ago now
14:10:56 <shapr> Yup
14:10:59 <SamB> hmm.
14:11:17 <augustss> But there are different versions of Lava.  Check with Koen Classen
14:11:18 <shapr> Personally, I wanted the layout code to see if it could work for FPGAs as well.
14:11:31 <shapr> er wait
14:11:31 <SamB> I don't need layout code
14:11:43 * shapr should sleep more often
14:11:50 <shapr> It was designed for FPGAs, wasn't it?
14:11:53 <LPhas> oh #@[# damn, on osx carbon-emacs M il the "apple" key and on the nw version it's catched by the terminal :|
14:12:01 <augustss> shapr: the problem is that the lowest level you have to do with vendor tools.  they don't tell you how it all works
14:12:02 <shapr> LPhas: Ah, that explainsit.
14:12:10 <shapr> Which is really sucky!!
14:12:14 <SamB> I just want to see the core API and the part where you can do something with a circuit besides evaluating it in Haskell
14:12:20 <shapr> Xilinx and friends have a total lock on the industry.
14:12:20 <LPhas> shapr, i agree
14:12:26 <shapr> It's not like they can't release the specs..
14:12:30 <LPhas> no one there that uses carbon emacs in consolle version?
14:12:41 <shapr> They've shut down clone makers already, so that can't be their worry.
14:12:56 <augustss> shapr: I think a problem is that if you program the chip wrong you can destroy it.  they don't want that
14:13:07 <SamB> I bet you can reverse engineer the FPGA fairly easily
14:13:29 <SamB> but, to figure out how to safely use it...
14:13:30 <augustss> SamB: Don't bet on it
14:13:34 <shapr> I'd rather have the freedom to shoot myself in the foot if it gives me the power to shoot something I would otherwise be unable to aim at...
14:13:56 <augustss> shapr: I agree.  I'm just giving you one of their reasons
14:14:12 <shapr> I strongly believe that the next step of OSS would be open source hardware, if the FPGA guys would get their heads out of the sand.
14:14:13 <SamB> hmm. so couldn't they just take that part of the code out?
14:14:40 <SamB> anyway, I think open-source FPGA would be cooler
14:14:51 <shapr> It's slowly starting up.
14:15:06 <shapr> The OpenGraphics project is using a Spartan, I think.
14:15:08 <augustss> SamB: it's tough.  makeing chips is mega-expensive
14:15:26 <Heffalump> making ASICs is, FPGAs aren't that expensive, surely?
14:15:34 <SamB> probably the FPGA manufacturers are afraid that, if they reveal enough info about the FPGAs to program them yourself, people will rip off their designs...
14:15:46 <shapr> SamB: no, that's already happened
14:15:47 <augustss> But who would make these open-source FPGAs?
14:15:55 <shapr> SamB: And in the resulting legal battle, the clone makers were shut down.
14:16:01 <SamB> shapr: oh.
14:16:04 <Heffalump> oh, I see, you want the low-level programming interface to be opensource
14:16:07 <SamB> then I have no idea what they are afraid of
14:16:17 <newsham> i'm not sure what fpga's being closed design has to do with it
14:16:31 <shapr> newsham: netlists suck
14:16:34 <Heffalump> they want another line of defence presumably
14:16:36 <newsham> the languages used to program the fpga's are common
14:16:46 <newsham> ie. verilog and vhdl
14:16:56 <augustss> newsham: yes, but the synthesis tools suck
14:17:00 <SamB> newsham: if you know what all the cells can do, you could probably make your own FPGA with cells just like that...
14:17:04 <kc5tja> Xilinx, et. al., just want to sell their software for the thousands of dollars that they go for.
14:17:24 <augustss> xilinx doesn't make much money on software
14:17:27 <shapr> And those languages compile to the insanely painful netlists spec, and each FPGA maker has their netlist -> my chip tool.
14:17:44 <newsham> cant you already buy common third party core units for all of the popular fpgas?
14:17:59 <shapr> Not that I'm aware of?
14:18:10 <augustss> newsham: what fun is it to buy cores?  we want to program the FPGAs
14:18:34 <defcon8> shapr, what quite is a CAF?
14:18:51 <SamB> newsham: you mean like, you pay $xk, and they give you some Verilog/VHDL files that you can use to integrate the FPGA in your chip?
14:18:53 <shapr> http://www.haskell.org/hawiki/ConstantApplicativeForm
14:18:54 <lambdabot> Title: ConstantApplicativeForm - The Haskell Wiki
14:18:58 <newsham> august: the point being if its open enough for 3rd party commercial parts, its open enough for open source parts
14:19:15 <Gu1> i'm sure you guys have looked at star bridge systems
14:19:27 <SamB> newsham: which party is the third party?
14:19:40 <augustss> newsham: oh, but most of those cores are pretty high level, afaik
14:20:23 <augustss> you can do a lot with the synthesis tools.  they are just slow and wastrels
14:21:14 <shapr> But if we had specs, we could do very cool things...
14:21:35 <newsham> http://digital.ni.com/worldwide/bwcontent.nsf/web/all/EC8CE8D48B878BDF862571BF000E54E3
14:21:38 <lambdabot> Title: IP for FPGA Hardware ‚Äì Build or Buy? - News - National Instruments, http://tinyurl.com/2cnzq7
14:22:14 <shapr> http://wiki.duskglow.com/tiki-index.php?page=OGD1 -- I want to be able to use this FPGA as a Haskell coprocessor.
14:22:15 <lambdabot> Title: TikiWiki : OGD1
14:22:18 <SamB> who was the one using FPGAs for playing classic videogames?
14:22:40 <augustss> shapr: we could.  but don't underestimate the work involved.  once you open the hood it's not digital logic anymore.  you're in the analog world
14:23:13 <shapr> I've read about the two aborted projects that tried to replace the Xilinx tools. One of them had .. seven years of work I think.
14:23:23 <augustss> SamB: we did a Pong demo at a Haskell workshop :)
14:23:38 <shapr> But Xilinx shut 'em down :-(
14:23:48 <SamB> I think it was NES games
14:24:06 <newsham> Like Xilinx.s MicroBlaze and Altera.s Nios, Lattice.s new Mico32 is a soft-core RISC processor that can be easily dropped into an FPGA. Unlike the others, however, Mico32 is completely open. Rather than take the lock-.em-in approach of their competitors, Lattice has gone the open source route
14:24:10 <shapr> Anyway, I should stop ranting and improve the parts of the world I *can* reach.
14:24:21 <shapr> newsham: !!
14:24:36 <SamB> like, depending on what hardware a cartridge had, the FPGA would be programmed for that...
14:24:41 <SamB> maybe it was multiplatform...
14:24:45 <defcon8> shapr, I understand this array stuff but I'd need to update it. How would I do that?
14:24:58 <shapr> defcon8: Update it?
14:25:00 <newsham> http://www.fpgajournal.com/articles_2006/20060926_softcore.htm
14:25:02 <lambdabot> Title: Soft Core War
14:25:06 <defcon8> shapr, how/
14:25:10 <augustss> defcon8: update it?  are you sure?
14:25:28 <defcon8> augustss, what is the alternative?
14:25:42 <shapr> defcon8: I don't think I understand your question.
14:25:42 <augustss> defcon8: define the whole array in one go
14:25:49 <newsham> http://www.latticesemi.com/products/intellectualproperty/ipcores/mico32/index.cfm
14:25:51 <lambdabot> Title: LatticeMico32, http://tinyurl.com/2z8b7q
14:25:57 <SamB> http://www.tripoint.org/kevtris/Projects/console/index.html
14:25:58 <lambdabot> Title: FPGA Console of DOOOOOM!
14:26:06 <shapr> heh, I know kevtris
14:26:23 <SamB> really?
14:26:29 <defcon8> augustss, I need primes up to a certain number. When I later want primes up to a number higher than the previous, I don't want to recalculate previously-calculated primes
14:26:31 <shapr> Yeah, I know all the tripoint.org guys.
14:26:35 <newsham> ?google fpga pdp
14:26:36 <shapr> I used to have a website there..
14:26:40 <lambdabot> http://neil.franklin.ch/Projects/PDP-10/
14:26:40 <lambdabot> Title: PDP-10 Clone Microprocessor in an FPGA
14:27:01 <defcon8> lazy evaluation maybe?
14:27:26 <defcon8> that's it!
14:27:42 <shapr> SamB: Kevtris came down to Birmingham to visit Colby and Scott and I met him then.
14:27:52 <augustss> > let a = array(1,10) ([(1,1),(2,1)] ++ [(i,a!(i-2) + a!(i-1)) | i <- [3..10]]) in a
14:27:53 <lambdabot>  array (1,10) [(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34),(10,55)]
14:28:23 <augustss> defcon8: are you sure you want an array?
14:28:32 <defcon8> augustss, what are the other alternatives?
14:28:37 <augustss> defcon8: a list
14:28:44 <defcon8> yes I meant a list
14:28:50 <augustss> oh, ok
14:29:23 <augustss> defcon8: there are oneliners that define the list of primes.  and they get computed as you access them
14:29:45 <defcon8> augustss, yeah I was thinking of one of those. I'd like to make it myself as I learn, though
14:30:02 <augustss> defcon8: so work one out. :)
14:30:07 <defcon8> yeah
14:30:39 <Cale> > (sum . take 10000 . map (recip . (+1) . snd) . filter (odd . fst) . zip [0..] $ fix ((0:) . scanl (+) 1)) - sqrt 5 / 2
14:30:40 <lambdabot>  -8.881784197001252e-16
14:31:02 <Botje> Cale: that's downright scary.
14:31:10 <chessguy> @quote calculator
14:31:11 <lambdabot> No quotes match. My mind is going. I can feel it.
14:31:22 <chessguy> @quote Calculator
14:31:22 <lambdabot> No quotes match. My mind is going. I can feel it.
14:31:28 <chessguy> bah
14:32:07 <SamB> hmm.
14:32:29 * SamB wonders what these configuration files look like...
14:32:52 <dmhouse> > fix ((0:) . scanl (+) 1)
14:32:53 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:32:53 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
14:32:57 <SamB> http://www.tripoint.org/kevtris/Projects/console/sections/picmicro.html
14:32:59 <lambdabot> Title: FPGA Console of DOOOOOM!, http://tinyurl.com/29slhb
14:33:04 <augustss> defcon8: Here's one not to use:  nubBy(((1/=).).gcd)[2..]
14:33:09 <augustss> > nubBy(((1/=).).gcd)[2..]
14:33:10 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:33:29 <defcon8> augustss, why?
14:33:34 <augustss> It's slow
14:33:40 <defcon8> what is nubBy?
14:34:04 <augustss> It eleminates duplicates from a list, with a given equality predicate
14:34:11 <augustss> > nub "foo"
14:34:12 <lambdabot>  "fo"
14:34:31 <augustss> > nubBy (==) "foo"
14:34:32 <lambdabot>  "fo"
14:34:42 <dmhouse> Cale: \Sum 1/(1+F_i) = phi, where the {F_i} are the Fibbonacci numbers?
14:34:54 <glguy> > nubBy (\x y -> mod y x == 0) [2..]
14:35:06 <defcon8> augustss, ahh okay
14:35:07 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:36:46 <glguy> ?src gcd
14:36:46 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
14:36:46 <lambdabot> gcd x y = gcd' (abs x) (abs y)
14:36:46 <lambdabot>    where gcd' a 0  =  a
14:36:46 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
14:37:59 <ski> Window 33
14:38:07 <ski> er
14:39:24 <LPhas> wow ERC for Emacs is cool
14:39:30 <shapr> :-)
14:39:43 <Cale> dmhouse: nearly -- sum of 1/(1 + F_(2n+1))
14:40:09 <Cale> and it's (sqrt 5)/ 2
14:40:13 <Cale> which isn't quite phi
14:40:17 <dmhouse> Oh, true.
14:40:24 <shapr> LPhas: And my name is in the ERC credits for ideas and testing! yay!
14:40:42 * LPhas bows to shapr
14:42:17 <LPhas> i'm looking for a project that can apply on for the SoC
14:42:27 <LPhas> on the trac i cannot find nothing cool
14:42:28 <defcon8> augustss, actually, could you give me a prime list giver in terms of function definitions?
14:42:35 <LPhas> and suitable for me
14:42:43 <dmhouse> LPhas: me too, it's tricky.
14:42:58 <dmhouse> Although I'm not sure I'll be applying at all. I won't be able to start coding until mid-July.
14:43:22 <LPhas> i've some experience using haskell with networks
14:43:28 <Igloo> You can submit your own ideas too
14:43:41 <LPhas> Igloo, i know but i don't have :P
14:44:21 <dmhouse> Straw poll: does Haskell need more powerful namespacing?
14:45:28 <glguy> I saw that mailing list posting... the arguments didn't do much for me
14:45:37 <shapr> I do wish record field accessors had some sort of namespacing.
14:45:44 <dmhouse> One thing I'd like is a proper recursive module implementation.
14:45:55 <vincenz> dmhouse: !
14:45:57 <vincenz> dmhouse: join #oasis
14:46:06 <dmhouse> shapr: yeah, that sounds like the kind of thing that could be added easily, without breaking backward compatability.
14:46:24 <kc5tja> dmhouse: That would conflict with the use of dots to specify an (OS-independent) directory path for finding a module.
14:46:24 <ski> dmhouse : yes
14:47:00 <dmhouse> kc5tja: what would? Record fields? Who says you have to use dots?
14:47:12 <kc5tja> dmhouse: 13:45 < dmhouse> One thing I'd like is a proper recursive module implementation.
14:47:36 <dfranke> *sigh*
14:47:37 * SamB wants an FPGA console too ;-)
14:47:39 <dfranke> MySQL is such a toy.
14:47:50 <dmhouse> kc5tja: why?
14:48:01 <dfranke> Apparently it doesn't support INTERSECT or EXCEPT.
14:48:03 <Saizan> the qualified names are absolute not relative
14:48:13 <Heffalump> it would be nice if record accessors could be made qualified with the name of the type or something
14:48:15 <dmhouse> By 'recursive modules' I mean two modules, each of which importing the other.
14:48:23 <kc5tja> If you use recursive modules, how do you reference symbols between modules?
14:48:34 <dfranke> meaning I have to completely rework the transaction I just spent four hours writing in HaskellDB.
14:49:10 <dmhouse> kc5tja: just like normal... I'm really not following; recursive modules are in the report, there's nothing wrong with them conceptually/
14:49:23 <Cale> > sum . take 100 $ [(-1)^k/sum (map (^2) t) | (k,t) <- zip [0..] (drop 2 . inits . fix $ (0:) . scanl (+) 1)]
14:49:24 <lambdabot>  0.6180339887498947
14:49:36 <Cale> > (sqrt 5 - 1) / 2
14:49:38 <lambdabot>  0.6180339887498949
14:49:50 <abz> ghc accepts gcc -D type options?
14:50:06 <Heffalump> has anyone got any Haskell code for playing with GPS traces?
14:50:10 <abz> documentation anyone?
14:51:20 <Saizan> judging from the error message on ghc -D, it does
14:51:24 <Igloo> abz: Yes, but you'll need to give it -cpp for it to do anything with them
14:51:31 <Igloo> abz: There's a flag reference in the users guide
14:51:40 <abz> Thanks guys
14:52:18 <kc5tja> dmhouse: I'm thinking if module A has an inner module B, you'd reference it as A.B.  But if there is also a directory named B, you could reference a module A.B.C.  Will the compiler see this as a conflict on the name B?
14:52:30 <dmhouse> kc5tja: 'Inner module'?
14:52:57 <kc5tja> dmhouse: Maybe I'm not understanding the concept of a "recursive module."  To me, the concept means the ability to define a module within another module.
14:52:57 <dmhouse> kc5tja: <dmhouse> By 'recursive modules' I mean two modules, each of which importing
14:52:57 <dmhouse>     the other.
14:53:06 <kc5tja> OOHH.
14:53:14 <kc5tja> In that case, disregard my queries.  :)
14:53:20 <dmhouse> :)
14:54:04 * LPhas wants ICQ and MSN in emacs
14:54:26 <ohmega> run bitlbee in an irc client?
14:54:27 <TSC> LPhas: You can do that via bitlbee
14:54:33 <defcon8> LPhas, bitlbee with erc
14:54:35 <defcon8> it even rhymes!
14:54:43 <TSC> @quote stereo
14:54:43 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
14:55:08 <Saizan> bitlbee?
14:55:10 <Cale> I'm starting to regret having said that :)
14:55:17 <SamB> Cale: why?
14:55:37 <Cale> Because my IRC client distracts me needlessly way more than usual now :)
14:55:43 <SamB> ha
14:55:43 <SamB> er.
14:55:44 <SamB> ah.
14:55:47 * kc5tja wants his questions answered in 7.1 surround.  Complete with laser light-show for extra impact.
14:55:48 <defcon8> haha
14:55:49 <SamB> yeah, that was my guess
14:55:59 <jyasskin> Eventually people will start "@quote stereo"ing in stereo.
14:56:04 <SamB> kc5tja: this is not disney world/land
14:56:20 <defcon8> oh I get it now :|
14:56:44 <kc5tja> jyasskin: I've been waiting for an opportunity to do precisely that, in all honesty.  :-)
14:57:19 <kc5tja> SamB: Just you wait -- it's only a matter of time before people start hugging children dressed in furry Simon suits.  You'll see!  Just you wait!
14:58:17 <TSC> Maybe we should change the quote database so it has "Cale' says: Welcome ..."
14:59:13 <Cale> That'd still set it off, Ca1e would work :)
14:59:31 <ski> elaC
14:59:43 <jyasskin> testing
14:59:47 <jyasskin> bah.
15:00:22 <jyasskin> XChat has a "Nicks not to highlight on" setting. Maybe if you put "Cale says" in there (or the equivalent for your client), it'll stop calling you when you're just quoted.
15:00:38 <Excedrin> Cale says <- does that set it off?
15:00:39 <Cale> hmm
15:00:54 <LPhas> bitlbee seems REALLY cool
15:01:04 <Cale> try again?
15:01:12 <jyasskin> @quote stereo
15:01:13 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
15:01:23 <Cale> nah, still sets it off somehow
15:01:26 <jyasskin> :-(
15:01:36 <Cale> @quote stereo
15:01:36 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
15:01:36 <Eelis> /ignore lambdabot
15:01:38 <Cale> hmm
15:01:45 <Excedrin> did mine?
15:01:58 <Cale> oh well, it's not a big deal :)
15:02:26 <defcon8> what's the | thing called?
15:02:29 <Cale> If I *really* cared, I'd get the X-chat source and hack in an exception.
15:02:29 <defcon8> I mean relative to haskell
15:02:40 <Cale> defcon8: those usually mark guards
15:02:47 <defcon8> yeah thanks
15:02:49 <Excedrin> test
15:02:57 <Cale> well, they're also part of the syntax of list comprehensions
15:03:28 <defcon8> how do I do or?
15:03:30 <Cale> It's read either "when" or "such that", depending on which place it's used.
15:03:33 <Cale> ||
15:03:36 <defcon8> ahh
15:03:53 <Cale> or,  or [...]
15:04:09 <Cale> > or [2 < 1, 1 < 2]
15:04:11 <lambdabot>  True
15:05:20 <ski> @djinn Either (a -> b) (b -> a)
15:05:21 <lambdabot> -- f cannot be realized.
15:06:44 <ski> @djinn Not (Not (Either (a -> b) (b -> a)))
15:06:45 <lambdabot> f a = void (a (Right (\ b -> void (a (Left (\ _ -> b))))))
15:07:26 <ski> interesting ..
15:07:27 <jyasskin> @src Not
15:07:27 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:07:36 <ski> @djinn-env
15:07:36 <lambdabot> Plugin `djinn' failed with: IRCRaised Data.ByteString.last: empty ByteString
15:07:38 <ski> bah
15:07:44 <ski> type Not a = a -> Void
15:07:47 <ski> data Void
15:07:57 <jyasskin> ski: Ah, thanks.
15:08:04 <ski> void :: Void -> a
15:08:11 <ski> void v = case v of { }
15:08:37 <SamB> hrmm.
15:08:45 <SamB> perhaps it is time I upgrade GHC
15:09:19 <sorear> hello.
15:09:31 * SamB wishes he could use Cabal for that :-(
15:11:02 * SamB decides he might as well, after all, he'll only need to recompile just about everything by hand
15:11:21 <defcon8> is it possible to define an infinite list that can look at its previous elements?
15:11:34 <sorear> sure!
15:11:36 <mauke> like the fibonacci numbers?
15:11:49 <defcon8> yeah
15:11:50 <sorear> > let nums = 1 : map (+1) nums in nums
15:11:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:12:08 <defcon8> cool
15:12:08 <mauke> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
15:12:10 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:12:25 <defcon8> thanks
15:12:27 <Cale> Something annoys me about articles written about mathematics in extremely vague terms for laymen. I can imagine reading this thing not knowing anything about what they're talking about and getting almost no sense of what's being discussed.
15:12:44 <Cale> (Specifically, I'm referring to the news about E_8.
15:12:45 <defcon8> @quote stereo
15:12:45 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
15:12:46 <Cale> )
15:12:52 <ddarius> Cale: That they are a waste of (virtual) paper.
15:12:53 <defcon8> sorry, had to do it
15:13:50 <Cale> The only people who are going to care about some computation which was performed regarding E_8 are already going to know what E_8 is, or at least have enough knowledge to comprehend a proper definition.
15:14:14 <defcon8> sorear, what if I need to call a different function for the next element?
15:14:24 <psi> i stumbled upon an article about it earlier today
15:14:34 <psi> the only thing i understood was that it was complex
15:14:36 <ddarius> defcon8: Just assume that you can do what you want to do, you probably can.
15:14:40 <SamB> argh,
15:14:54 <SamB> when I said "just about everything" I didn't mean it quite that literally...
15:14:57 <defcon8> ddarius, I was trying to think how
15:15:04 <SamB> well, either that, or install profiling libraries...
15:15:36 <mauke> > let xs = 1 : zipWith id (cycle [(2 *), sqrt, (1 +)]) xs in xs
15:15:37 <ddarius> > let a = 1:b; b = 2:a in a
15:15:39 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
15:15:39 <lambdabot>  [1.0,2.0,1.4142135623730951,2.414213562373095,4.82842712474619,2.19736822693...
15:16:39 <astrolabe> Cale: do you know why the character table is finite?
15:16:54 <emu> > ['a' ..]
15:16:55 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
15:16:55 <ski> Cale : what about E_8 ?
15:16:56 <ddarius> defcon8: But essentially, you can substitute equals for equals so more or less a different function is just a name convenience.
15:17:40 <astrolabe> ski: http://news.bbc.co.uk/1/hi/sci/tech/6466129.stm
15:17:42 <lambdabot> Title: BBC NEWS | Science/Nature | 248-dimension maths puzzle solved
15:17:46 <mauke> > let xs = 1 : zipWith id (cycle [(1 +), sqrt, (1 /)]) xs in map round xs
15:17:47 <lambdabot>  [1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2,1,1,2...
15:17:49 <hyrax42> am I to understand that drop 1 :: Seq a -> Seq a is O(1)?
15:18:08 <sorear> right
15:18:22 * hyrax42 needs to read this finger tree paper
15:18:28 <Cale> ski: see reddit
15:18:57 <ddarius> hyrax42: If it's written by Ralf Hinze, it's a good bet it's worth reading.
15:19:00 <sorear> @users
15:19:01 <lambdabot> Maximum users seen in #haskell: 336, currently: 321 (95.5%), active: 48 (15.0%)
15:19:07 <ddarius> (in general)
15:19:16 <hyrax42> oh I remember looking at this
15:19:51 <Cale> astrolabe: hmm
15:20:02 <sjanssen> yes, the finger tree paper is certainly worth reading
15:20:25 <defcon8> next lis n = and (map (\x -> mod n x == 0) lis)
15:20:26 <defcon8> primes = 2 : next primes (last primes)
15:20:30 <defcon8> I knew it wouldn't work from the start
15:20:38 <defcon8> actually that's bs
15:21:05 <hyrax42> but I didn't read it for whatever reason
15:21:31 <defcon8> how do I define an infinite list of primes in the normal way?
15:22:41 <LPhas> bitlbee <- lode lode
15:22:45 <mauke> > let primes = 2 : sieve [3, 5 ..]; sieve (p : ns) = p : sieve (filter ((0 /=) . (`mod` p)) ns) in primes
15:22:47 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:22:55 * SamB wonders why there is no ghc6-extralibs debian package...
15:23:06 <sorear> > {- clever trick found a few days ago -} nubBy(((/=1).).gcd)[2..]
15:23:07 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:23:11 <sorear> SamB: it's split
15:23:20 <sorear> SamB: libghc6-mtl-dev, etc
15:23:21 <SamB> sorear: it would be a meta-package
15:23:34 <SamB> for those of us who are afraid we've forgotten something we want
15:23:35 <sorear> ah right.
15:23:58 <SamB> (even if nobody ever installed it, it would still be usefull)
15:24:25 <hpaste>  Excedrin pasted "iteration + state" at http://hpaste.org/1040
15:24:47 <Excedrin> if anyone could help me achieve similar performing code in Haskell, I'd appreciate it
15:24:55 <SamB> okay, I've got arrows, mtl, quickcheck, and x11...
15:24:59 * SamB wonders if he forgot anything
15:26:30 <ddarius> SamB: Is it your mother's birthday today?
15:26:37 <SamB> no
15:27:00 <SamB> because my father's is later this week... and I know they don't have birthdays in the same week...
15:28:09 <sorear> SamB: you using aptitude?
15:28:15 <SamB> yes
15:28:21 <sorear> SamB: 'l' "libghc6-" RET
15:28:29 <SamB> there are lots of those
15:28:34 <sorear> really?
15:29:35 <sorear> on my (sid) system, I only see the two dozen or so extralib packages and their -dev, -prof variants
15:29:54 <SamB> hmm.
15:30:50 <SamB> I'm seeing gtk2hs packages too, at least
15:31:26 <psi> how do I build cabal-install? i tried to build it from the Cabal darcs repo (using Cabal 1.1.6) but i can't run configure.
15:31:36 <Cale> astrolabe: which character table do you mean?
15:31:45 <SamB> psi: build Cabal with Cabal?
15:32:38 <psi> SamB: are you saying that i need to rebuild the entire cabal from the repo?
15:33:22 <SamB> oh, that would probably help too ;-)
15:33:41 <astrolabe> Cale: the character table that they worked out for E8.
15:33:41 <psi> i just wanted cabal-install :)
15:34:04 <Cale> I don't think it was a character table that they constructed, was it?
15:34:36 <astrolabe> "Professor Vogan is presenting the results at MIT in a lecture entitled The Character Table for E8, or How We Wrote Down a 453,060 x 453,060 Matrix and Found Happiness."
15:35:05 <astrolabe> Although news reports are rather dubious when it comes to technical subjects.
15:35:45 <Cale> I don't think it's actually technically a character table, but perhaps something like one in terms of uses.
15:36:26 <Cale> http://www.liegroups.org/kle8.html -- I believe this is what they were computing.
15:36:28 <lambdabot> Title: Kazhdan-Lusztig-Vogan Polynomials for E_8
15:37:36 <chessguy> hi haskellers
15:37:47 <sorear> hello chessguy, dcoutts
15:37:51 <Cale> I've only heard about character tables in the context of finite groups.
15:38:00 <dcoutts> hia sorear
15:38:00 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:38:20 <sorear> I feel dumb.  I've only heard about character tables in the context of ctype.h :)
15:38:26 <Heffalump> E_8 isn't finite?
15:38:45 * sorear probably *really* needs to learn this lie-groups stuff
15:38:53 <astrolabe> Heffalump: It is a Lie group (and hence a manifold, and hence infinite).
15:38:54 * dcoutts doesn't
15:40:07 <Heffalump> ok, fair enough
15:40:16 * Heffalump is ignorant about advanced group theory
15:41:08 <mahogny> lie groups. why would a computer scientist need lie groups? o_O
15:41:14 <astrolabe> Cale: thanks for the link, but it's all gobbledegook to me :)
15:41:28 <Cale> astrolabe: I couldn't understand too much of it either.
15:41:41 <Cale> But it doesn't sound like a character table to me.
15:41:42 <Botje> wow.
15:41:49 <Botje> a concept that baffles even haskell programmers.
15:41:53 <Cale> heh
15:41:58 <astrolabe> I found an application of the representation theory of some Lie groups to independent component analysis.  You never know.
15:42:04 <Cale> There's quite a lot of mathematics which baffles me :)
15:42:22 <jyasskin> Wild guess: maybe "character" is related to "characterization" and not 'q'?
15:42:34 <emu> whew
15:42:34 <astrolabe> I don't suppose there is anyone who isn't baffled by most mathematics.
15:42:38 <Botje> don't worry, oleg will implement a type system extension that makes use of E_8 to solve the halting problem in under two seconds
15:42:43 <SamB> hmm. I think I have a character table that I copied out of my computer's ROM somewhere...
15:43:07 <mahogny> mathematics is uncountable infinite. you will never reach a stage when it doesn't baffle you :P
15:43:11 <mahogny> SamB, wrong type :)
15:43:45 <SamB> mahogny: well, I gathered that. but. it seems bizarre that Cale would not have heard of this kind...
15:44:42 <mahogny> well. as I said, which computer scientist would need lie algebras? although I wouldn't be surprised if someone cooked up a perverse use. I will soon be on a talk when they use lie algebras for systems biology :P
15:45:03 <kc5tja> I just love how the Java IDE I use at work, alone, drives my box' CPU load to 3.0 easily.
15:45:13 <Cale> My background is in pure mathematics, but I haven't really studied Lie algebras in any great depth.
15:45:21 <mahogny> aha
15:45:38 <mahogny> I still have to learn them better to do QM :(
15:45:58 <Cale> (I know the basic definitions, and have a general sense of how the area fits together)
15:47:05 <dons> ?users
15:47:05 <lambdabot> Maximum users seen in #haskell: 336, currently: 318 (94.6%), active: 47 (14.8%)
15:47:22 <chessguy> hi dons
15:47:30 <mahogny> Cale, maybe you know where I should start reading if I want to learn recursion theory?
15:47:32 <sorear> so, if you aren't an expert, that means I can stop worrying about how long it will take me to learn all of pure math? *sigh* :)
15:47:35 <sorear> hi dons
15:47:47 <LPhas> hi dons
15:48:13 <SamB> mahogny: perhaps computer scientists will need lie algebras when they are bioinformaticians?
15:48:25 <mahogny> SamB, pray that it won't happen
15:48:39 <SamB> aren't some of them that already?
15:49:06 <chessguy> sure. there are lots of interesting computational biology questions
15:49:15 <ddarius> mahogny: Physics simulations, computer graphics, massively distributed networked systems are obvious/potential applications that jump to mind.
15:49:19 <Cale> Are you referring to computability theory?
15:49:20 <mahogny> in bioinformatics? gosh. that would be the last place I would expect to find them. bioinformaticians never touch continuous data. biophysicists if anyone
15:49:36 <mahogny> Cale, yup
15:49:54 <ddarius> mahogny: Geometric Algebra (random keyword)
15:49:58 <mahogny> Cale, preferable in the most abstract sense
15:50:04 <mahogny> ddarius, :(
15:50:07 <Cale> I haven't had much formal training in that, but scroll to the bottom of http://en.wikipedia.org/wiki/Recursion_theory
15:50:07 <lambdabot> Title: Recursion theory - Wikipedia, the free encyclopedia
15:50:22 <SamB> hmm
15:50:23 <Cale> There's lots of references to texts at various levels.
15:50:35 <mahogny> hm. that's a few references yes
15:50:50 <SamB> so do they have metadata in bioinformatics yet?
15:51:04 <SamB> I mean, do they deal with those tags?
15:51:05 <Cale> I wonder if there are any good online texts...
15:51:14 <mahogny> well. define bioinformatics and metadata in this context and I can answer :)
15:51:29 <ddarius> For computability theory? There are some, I don't know how good they are.
15:51:35 <SamB> hmm.
15:51:55 <sorear> does *BSD use gcc?
15:52:00 <mahogny> yes
15:52:21 <mahogny> I might be able to ask at a nearby university. they seem to specialize in logic. not to mention martin-l√∂f himself is working around here
15:52:56 * mahogny found that out yesterday :P
15:53:03 <sorear> mahogny: did you actually not type the o-umlaut in martin-lo:f or did my client eat it?
15:53:13 <mahogny> sorear, your client ate it
15:53:21 * sorear kicks ERC
15:53:31 <dmhouse> sorear: I saw it in ERC.
15:53:39 <gabrieldurazo> i saw the umlaut thing
15:53:43 <dmhouse> I can type them to√∂.
15:53:50 <mauke> √§w‚Ç¨√ü√∂¬µ‚Ç¨
15:53:58 <ddarius> http://modelingnts.la.asu.edu/html/GAinQM.html http://modelingnts.la.asu.edu/html/GeoAlg.html
15:53:59 <lambdabot> Title: Selected Papers on Geometric Algebra in Quantum Mechanics
15:54:14 <mahogny> QM. yeah, that uses tons of lie algebra
15:54:14 <fuzan> There's no simple method for using Data.Binary to read from a handle, is there? The issue is the datatypes are of variable sizes and was planning on binary to handle deserialization!
15:54:33 <mahogny> that's what I need it for. can't think of any other obvious applications
15:54:59 <SamB> well. xmonad seems to run
15:54:59 <sorear> fuzan: you can read binary data from a handle
15:55:05 <SamB> hmm...
15:55:22 <ski> mahogny : stockholm ?
15:55:28 <mahogny> yup
15:55:28 <SamB> but it isn't getting along with Xephyr...
15:55:30 <sorear> fuzan: remember haskell is lazy, so if you just use Data.ByteString.Lazy.hGetContents it will DTRT
15:55:35 <ddarius> mahogny: Using the vector derivative they kind of fade off to the side as a different view
15:56:09 <fuzan> sorear: :)
15:56:19 <Saizan> in STM when a transaction call retry awaits only till there's a committed change on at least one of the TVar that it have read, so, isn't there the same efficiency issue as the use of signalAll in monitors?
15:57:01 <fuzan> sorear: would you have to use it in scope of the decode? ie: decode (B.hGetContents handle)
15:57:21 <sorear> fuzan: I don't get what you mean be scope...
15:57:38 <nominolo> @hoogle (a,b) -> (b,a)
15:57:39 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:57:51 <fuzan> sorear: oh, wait. it's lazy such that it doesn't even read until requested
15:57:56 <fuzan> sorear: sorry, i'm an idiot.
15:57:59 <nominolo> :t curry . flip . uncurry
15:58:02 <lambdabot> forall a b c a1 b1. (a1 -> b1 -> (a, b) -> c) -> a -> b -> (a1, b1) -> c
15:58:12 <nominolo> :t uncurry . flip . curry
15:58:14 <lambdabot> forall a b c. ((a, b) -> c) -> (b, a) -> c
15:58:22 <nominolo> :t flip
15:58:24 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:58:27 <LoganCapaldo> :t flip undefined
15:58:29 <lambdabot> forall a b c. b -> a -> c
15:58:51 <fuzan> sorear: i was thinking that I had to call hGetContents along with the decode such that it wouldn't grab the entire contents. I couldn't figure out how that would work, so I realized my misconception.
15:59:14 <nominolo> :t swap
15:59:16 <lambdabot> Not in scope: `swap'
15:59:19 <nominolo> :t mirror
15:59:21 <lambdabot> Not in scope: `mirror'
15:59:30 <fuzan> sorear: thanks.
15:59:53 <ddarius> nominolo: There isn't a standard function for that
16:00:07 <nominolo> laaame
16:00:24 <Saizan> ?pl \(a,b) -> (b,a)
16:00:25 <lambdabot> uncurry (flip (,))
16:00:32 <ski> @djinn (a,b) -> (b,a)
16:00:32 <lambdabot> f (a, b) = (b, a)
16:00:39 <dons> flip (,) is the thing.
16:00:40 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:00:56 <chessguy> ?seen sigfpe
16:00:56 <lambdabot> I haven't seen sigfpe.
16:01:00 <ddarius> dons: As pl said, not quite.
16:01:06 <LoganCapaldo> Does that read as flip comma?
16:01:09 <ski> chessguy : just left ..
16:01:16 <LoganCapaldo> or flip make tuple
16:01:22 <LoganCapaldo> or flip make pair>
16:01:23 <LoganCapaldo> ?
16:01:31 <LoganCapaldo> or something else?
16:01:31 <chessguy> ski, oh, dpiponi?
16:01:36 * ski nods
16:01:39 <chessguy> ah, nice
16:01:49 * ddarius just wouldn't attempt to "read" that.
16:02:15 * LoganCapaldo considers the scenario when discussing code in meatspace
16:02:44 <ddarius> Raising the level of abstraction somewhat is usually called for.
16:03:04 <LoganCapaldo> I surpose
16:03:23 <nominolo> > let toBytes n = take n . uncurry (Just . uncurry (flip (,)) . quotRem) in toBytes 4 257
16:03:24 <lambdabot>  Couldn't match expected type `(a, b)'
16:04:10 <ddarius> nominolo: That code makes no sense
16:04:27 * LoganCapaldo tries to find a list in nominolo's code
16:04:28 <nominolo> > let toBytes n = take n . uncurry (Just . uncurry (flip (,)) . flip quotRem 256) in toBytes 4 257
16:04:29 <lambdabot>  Couldn't match expected type `b -> c'
16:04:34 <LoganCapaldo> @ty quotRem
16:04:36 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
16:04:46 <LoganCapaldo> Nope, not there
16:04:52 <miez> would it be impossible to make bytestring compatible with string?
16:05:00 <nominolo> > let toBytes n = take n . unfoldr (Just . uncurry (flip (,)) . flip quotRem 256) in toBytes 4 257
16:05:01 <lambdabot>  [1,1,0,0]
16:05:26 <LoganCapaldo> hurray
16:05:40 <ddarius> Okay, unfoldr make much more sense than uncurry there
16:05:53 <nominolo> thinkotypo
16:07:09 <dcoutts> augustss: I don't like your Eq instance :-)
16:07:13 <Saizan> isn't that toBits?
16:07:28 <nominolo> @pl (\v -> let (v',r) = quotRem v 256 in Just (r,v'))
16:07:28 <lambdabot> (line 1, column 12):
16:07:28 <lambdabot> unexpected "("
16:07:28 <lambdabot> expecting natural, identifier or "in"
16:07:58 <dcoutts> miez: they are different types, they can't be the same type since String is a concrete type and so fixes the representation. You can convert between them easily using pack/unpack.
16:09:22 <nominolo> is there an offline version of @pl ?
16:09:32 <LoganCapaldo> @where GOA
16:09:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
16:09:49 <dons> well, lambdabot is offline
16:10:58 <miez> dcoutts well, i think they are just different by their implementation. i wonder if there could be a common interface for them so that i could use any functions with bytestring written for string and vice versa
16:11:01 <nominolo> @where lambdabot
16:11:01 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:11:24 <dcoutts> miez: I fear that will make people not think clearly
16:11:37 <pebblestone> how to use lambdabot
16:11:38 <dcoutts> miez: they have very different complexities for instance
16:12:20 <nominolo> the goa repo could use a readme
16:12:24 <nominolo> but looks great
16:12:35 <dcoutts> miez: I'd recommend to use String unless you are handling a very large amount of data and having performance problems
16:12:35 <miez> dcoutts sure, that's why i would choose between them. i'm not asking why dont we drop one over the other but make them compatible somehow
16:12:36 <dons> nominolo: i'd just use the lambdabot binary itself. not sure goa is still working..
16:13:25 <dcoutts> miez: String is great in interfaces if performance doesn't kill you, because everyone else uses String.
16:13:43 <LPhas> hi dcoutts
16:13:48 <dcoutts> hia
16:14:12 <LPhas> for the Language.C that we were talking this morning
16:14:33 <LPhas> can you mentor me if i apply to it?
16:16:04 <dcoutts> LPhas: probably, yes. Or ChilliX did that one last year.
16:16:28 <dcoutts> kolmodin: want to mentor someone for SoC ? Someone wants to do an IDE :-)
16:16:47 <miez> dcoutts i'm thinking about something like edison, where i can choose from different implementations for a certain container
16:17:19 <LPhas> dcoutts only that i don't know very well what you want to be done in that code
16:17:19 <miez> a common class for common string functionality
16:17:35 <LPhas> dcoutts: so i don't know how to write the proposal :P or what to write in the trac
16:17:47 <dcoutts> miez: yes, I know, it gets suggested a lot, but as I say I'm not convinced
16:18:15 <dcoutts> LPhas: I think there's a proposal template somewhere on the SoC wiki
16:18:40 <LPhas> dcoutts: i'll give a look
16:18:46 <rubenz> How can I use field labels to update certain records in a data datatype and leave others unchanged?
16:19:00 <jcreigh> some_var { someField = newValue }
16:19:02 <ski> foo { bar = baz }
16:19:21 <jcreigh> the result of that expression will be a copy of some_var, except with someField set to newValue
16:19:53 <miez> dcoutts actually i wanted to try bytestrings somewhere, and realized their interface was so incompatible that at that point i didnt feel like getting rid of that. now i read the newsgroup that somebody wants to drop parsec because it is inefficient due to string usage.. etc..
16:20:26 <dcoutts> miez: it now exports exactly the same API as Data.List
16:20:27 <miez> some mime-parser stuff i think
16:20:34 <dcoutts> thoughh obviously not [] & (:)
16:21:01 <LPhas> dcoutts: tomorrow i'll give a look to the code, thanks a lot
16:21:35 <dcoutts> LPhas: the code isn't easily available atm, I'm still replacing the c2hs C parser
16:21:47 <dcoutts> LPhas: but it's certainly worth learning about happy & alex
16:21:58 <sorear> LPhas: there are deep magic rules - BS.filter (== '\n') str is nowhere near as expensive as it looks
16:22:13 <miez> dcoutts the bigger problem is that i still need to convert back to string where other apis are involved.
16:22:35 <dcoutts> miez: then use String in the first place, or do you have performance issues ?
16:22:47 <dcoutts> don't use ByteString just for the sake of it
16:24:01 <sorear> Bytestrings should be cheaper for the short-strings case. like c-string cheap :(
16:24:02 <miez> well i just wanted to try how much it was an issue, but didnt bother too much
16:24:02 <LPhas> dcoutts: oh, ok i'll start to give a look at them
16:24:17 <LPhas> dcoutts: maybe you can make an enty at the trac ...
16:24:33 <dcoutts> LPhas: isn't there already a Language.C entry?
16:24:52 <LPhas> dcoutts: for the last year, i think
16:25:03 <dcoutts> ok
16:29:54 <malsyned> is anybody here familiar with Parsec.Perm?
16:30:33 <shapr> I've read about it.
16:31:05 <malsyned> shapr: do you know if there are any bugs wrt nesting permutations?
16:32:03 <malsyned> like, top := << nt1 | nt2 | nt3 >>; nt1 := << nt12 | nt13 >>; ...
16:32:20 <ski> ByteString is cool
16:36:51 <stepcut> malsyned: if any of the permutations consume at least one character before failing, then things will probably not work as you would like
16:37:54 <stepcut> malsyned: e.g. << string "hi" | string "hello" >>, would not work the way you would expect...
16:39:02 <chessguy> @src Monad
16:39:02 <lambdabot> class  Monad m  where
16:39:02 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
16:39:02 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
16:39:02 <lambdabot>     return      :: a -> m a
16:39:02 <lambdabot>     fail        :: String -> m a
16:39:17 <shapr> Hiya stepcut! edwardk said he might have found a way to get your unix pipe arrows to work.
16:39:28 <malsyned> stepcut: yeah, I know about that.  I've actually got a separate lexer, so that that doesn't happen.
16:39:30 <stepcut> shapr: oh ?
16:39:54 <stepcut> malsyned: ok, just checking :) That trips up a lot of people
16:39:59 <shapr> stepcut: Yeah, it was one of the tricks used in http://www.randomhacks.net/ but I forget which one.
16:40:00 <lambdabot> Title: Random Hacks
16:40:36 <malsyned> stepcut: that's not related to permutations, though, that's just general advice about Parsec defaulting to LL(1), right?
16:40:38 <stepcut> shapr: probably the Monad instance for Set
16:40:49 <stepcut> malsyned: right
16:41:32 <stepcut> shapr: unfortunately, I don't think you can use the spiffy do syntax unless you add -fno-implicit-prelude, which is troublesome in its own right
16:42:25 <shapr> Ah, I think that's what he was talking about, yes.
16:42:45 <nominolo> why isn't :t fail :: Error e => e -> m a ?
16:42:45 <sorear> @seen emk -- check lb's memory
16:42:45 <lambdabot> I saw emk leaving #haskell 11h 50m 36s ago, and .
16:42:53 <sorear> :(
16:42:55 <shapr> @seen ekidd
16:42:55 <lambdabot> I saw ekidd leaving #haskell 10h 14m 24s ago, and .
16:43:21 <sorear> nominolo: you'll regret asking that :)
16:43:43 <sorear> nominolo: because of very widely hated decisions by the h98 comittee
16:44:02 <chessguy> ?where sigfpe
16:44:02 <lambdabot>  @seen dpiponi
16:44:07 <chessguy> aww
16:44:14 <stepcut> haha
16:44:22 <sorear> also, I suspect error didn't exist back then
16:44:48 <sorear> however, you can echo just about anything else that way
16:45:00 <sorear> ?where+ sigfpe ?seen dpiponi
16:45:01 <lambdabot> Done.
16:45:07 <nominolo> sorear: i just remember ekidd's rant
16:45:07 <sorear> ?where sigfpe
16:45:08 <lambdabot> ?seen dpiponi
16:45:25 <chessguy> lambdabot must have herself on ignore
16:45:30 <shapr> hackerblinks: hiya
16:45:30 <sorear> unfortunately, irc servers don't tell you what you say
16:45:43 <hackerblinks> hey, shapr.
16:46:24 <nominolo> sorear: and it showed quite some chances for improvement
16:48:04 <nominolo> ?seen nominolo
16:48:05 <lambdabot> You are in #haskell. I last heard you speak just now.
16:48:45 * sorear just figured out how to cause a working bot loop...
16:48:58 <hackerblinks> \me is curious
16:49:14 <hackerblinks> Ping-pong with two bots?
16:49:19 <sorear> yup
16:49:30 <hackerblinks> Thought that we only had one in here...
16:49:37 <nominolo> what's the result?  * lambdabot killed herself?
16:49:38 <chessguy> !paste
16:49:39 <hpaste> Haskell paste bin: http://hpaste.org/
16:49:43 <hackerblinks> sweet
16:49:45 <chessguy> hackerblinks: ^^
16:49:50 <hackerblinks> I see.
16:50:10 <malsyned> stepcut: gah!  I found the problem, but I don't understand how it was compiling at all.  It was a whitespace problem, which I believe was being interpreted as "do {thing; <|> thing2}" instead of "do {thing <|> thing2}"
16:50:20 <stepcut> sorear: yes, that is why bots are supposed to use NOTICE instead of PRIVMSG, but gaim and other irc clients, handle notices in an unfriendly way
16:50:34 <shapr> As in, they freak out...
16:51:09 <shapr> We tried to switch lambdabot to NOTICE for a month or so...
16:51:41 <hackerblinks> Strange.
16:51:51 <hackerblinks> Not implemented, or just implemented wrong?
16:52:10 <nominolo> does that mean that anyone using /notice can kill gaim?
16:52:28 <malsyned> /notice malsyned hork
16:52:33 <malsyned> oops
16:52:38 <shapr> It's implemented incorrectly.
16:52:55 <shapr> iirc, gaim pops up NOTICE in its own buffer that has nothing to do with the channel.
16:52:55 <nominolo> well .. it's gaim
16:53:15 <shapr> But gaim wasn't the only one...
16:53:16 <sorear> malsyned: what happened?
16:53:28 <shapr> I think there were some text clients that also handled NOTICE badly.
16:53:47 <malsyned> sorear, shapr: yeah, that's what just happened when sorear NOTICE'd me.  it just showed up as a normal window, with the IM prefixed by "(notice) "
16:53:59 <malsyned> it's as if he'd IMed me.
16:54:03 * nominolo get's /notice in the connection console
16:54:08 <shapr> So, no connection to channel, server, or protocol?
16:54:25 -mbishop(n=martin@unaffiliated/mbishop)- What?!
16:54:28 * mbishop runs
16:54:31 <sorear> wow
16:54:36 <shapr> Works fine in ERC
16:54:42 <sorear> first time erc handled it right for me
16:54:46 <nominolo> worked somewhat
16:54:47 <sorear> irssi also dtrt
16:54:55 <nominolo> appended a "notice"
16:55:08 <sorear> *** nominolo is/was on server irc.freenode.net (http://freenode.net/)
16:55:08 <sorear> -mbishop- What?!
16:55:08 <sorear> * mbishop runs
16:55:09 <lambdabot> Title: About the Network
16:55:34 -chessguy(n=chessguy@69.242.13.143)- bar
16:55:45 <chessguy> weird
16:55:51 <nominolo> 00:54 [notice(chessguy:#haskell)] bar
16:55:53 <sorear> chessguy: I got your first notice in the server-global buffer, and the second in the channel buffer. what gives?
16:55:54 <malsyned> Is there any way to define permChoice such that <|>:choice::<||>:permChoice ?
16:55:58 <mbishop> everyone's client is gonna be going crazy hehe
16:55:58 <nominolo> (on macirssi)
16:56:08 <chessguy> sorear: the first was to you, the second was to the channel
16:56:58 <sorear> @quote sorear Chan
16:56:58 <lambdabot> sorear says: I can actually hold a conversation with chanserv [/talking about NOTICE]
16:57:25 <shapr> A few people argued that #haskell should use NOTICE anyway and users would just have to get a real client, but people threatened to leave...
16:57:50 <malsyned> people should threaten to patch their IRC clients.
16:57:54 <stepcut> shapr: well, it's getting a bit crowded here these days with 300+ people anyway :p
16:58:11 <sorear> yeah, and there's just too much traffic for me
16:58:31 <sorear> I'd like it split into #haskellnewbies and #haskellarcana...
16:58:44 <chessguy> arcana?
16:58:44 <sorear> but kicking out the gaimers would do as well
16:58:50 <hackerblinks> Nah, you'd have to split it into #lifthaskell and #haskell
16:58:51 <sorear> @web1913 arcana
16:58:53 <lambdabot> *** "Arcana" web1913 "Webster's Revised Unabridged Dictionary (1913)"
16:58:53 <lambdabot> Arcanum \Ar*ca"num\, n.; pl. {Arcana}. [L., fr. arcanus closed,
16:58:53 <lambdabot>    secret, fr. arca chest, box, fr. arcere to inclose. See
16:58:53 <lambdabot>    {Ark}.]
16:58:53 <lambdabot>    1. A secret; a mystery; -- generally used in the plural.
16:58:55 <lambdabot> [5 @more lines]
16:59:00 <sorear> @more
16:59:00 <lambdabot>  
16:59:00 <lambdabot>             Inquiries into the arcana of the Godhead.
16:59:01 <lambdabot>                                                   --Warburton.
16:59:03 <lambdabot>  
16:59:05 <lambdabot>    2. (Med.) A secret remedy; an elixir. --Dunglison.
16:59:15 <Philippa> far too many IRC clients handle NOTICE at least somewhat badly
16:59:23 <sorear> beh, dict needs a better output compressor
16:59:29 <Philippa> it got abused, everyone ignores that part of the RFC
16:59:54 <hackerblinks> Unfortunate.
17:00:05 <mbishop> sorear: lots of the unix tools do, dict, fortune, etc, most can print nonstandard stuff
17:00:37 <shapr> sorear: Yeah, people have been meaning to fix that since.. well, since tmoertel wrote the dict plugin.
17:00:59 <shapr> I agree that #haskell is getting a bit crowded, but I don't know what do about it.
17:01:13 <shapr> Splitting channels means that people might lose some interesting conversations..
17:01:25 <hackerblinks> And it wouldn't stay split --
17:01:25 <shapr> Too much traffic means the same thing...
17:01:30 <sorear> there are far too many uninteresting conversations here.
17:01:40 <shapr> Yeah, we could push the on-topic part.
17:01:48 <shapr> #haskell-blah helped with that.
17:01:51 <Excedrin> there's already haskell-blah
17:01:57 <hackerblinks> ..
17:01:58 <shapr> I should really not talk about unicycling at all in #haskell =)
17:02:07 <Philippa> more use of -overflow would help
17:02:22 <shapr> I've thought about 'focus sessions'
17:02:26 <chessguy> or a less vague description of the purpose of -overflow
17:02:36 <stepcut> other times there are too many on-topic conversations at once :-/
17:02:50 <Philippa> stepcut: that's exactly what -overflow should be for
17:03:04 <shapr> For example, if people want to get together and learn about a particular subject on the weekends. I'd love to learn more about STM, GADTs, etc.
17:03:17 <shapr> But I'd want one person to learn lots about that subject, and then give an 'irc talk' about it.
17:03:19 <Philippa> focus sessions probably want to go in a -focus chan though
17:03:21 <dcoutts> @seen dons
17:03:21 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 50m 45s ago.
17:03:22 <sorear> I think we need more separations between the boring newbie questions (How do I turn a String into an int?) and the deeper stiff that people actually think about.
17:03:36 <Philippa> sorear: that's hard to make work
17:03:37 <Pseudonym> IRC talks are an interesting idea.
17:03:37 <nominolo> shapr: isn't a blog entry better for this kind of stuff?
17:03:43 <Philippa> the boundaries're fuzzier than you think
17:03:44 <shapr> sorear: Problem is, "deeper stuff" depends on your perspective.
17:04:01 <sorear> nominolo: you can't ask questions in a blog entry. it's too non-interactive.
17:04:05 <Philippa> right. An amiga user can tell you the problem with guru meditations
17:04:10 <Pseudonym> There's one thing I'd like to do, though, if I were doing that, and that's allow a kind of flooding from the nominated speaker.
17:04:15 <shapr> nominolo: Yeah, I'm broadcasting a request for suggestions really.
17:04:27 <Pseudonym> Maybe this would be better done with a Jabber-like tool.
17:04:27 <nominolo> sorear: yes, but irc is too low-bandiwdth IMO
17:04:34 <shapr> I want to keep this community together without flooding it.
17:04:36 <Philippa> I'd have an easier time giving talks than writing blog entries, too
17:04:37 <sorear> nominolo: #haskell is about the size of a lecture hall and probably should be treated similarly.
17:04:55 <shapr> sorear: Man, I'd hate being broadcast at...
17:05:03 <shapr> I like the "anyone can contribute" approach.
17:05:20 <shapr> Philippa: Me to
17:05:21 <nominolo> shapr: you think that works in irc?
17:05:30 <shapr> nominolo: Er, which what?
17:05:39 <Philippa> nominolo: I've effectively given talks to audiences of 10-20 on IRC a few times
17:05:53 <shapr> I've seen much larger a few times.
17:05:54 <nominolo> shapr: the everyone can contribute thingy
17:05:55 <Philippa> and those of us who've done the IRC intro to monads a hundred times've... well, you get the idea
17:06:03 <shapr> nominolo: Yeah, I think it does.
17:06:26 <sorear> I think we need a more effective way to refer people to logs.
17:06:29 <shapr> I know more than some but less than others, so I teach some and learn some.
17:06:33 <shapr> sorear: That's a good point.
17:06:42 <shapr> It'd also be nice if threads could be pulled out of logs.
17:06:56 <nominolo> when things need to get detailed on ICQ/Jabber/MSN i usually try to switch to skype
17:07:30 <shapr> My SoC proposal will be a mix of hpaste and lambdabot's eval plugin, I think that would help.
17:07:31 <nominolo> sorear: yes, i was thinking about something similar
17:08:07 <Philippa> it might help, but there're some things that logs won't help with on their own
17:08:46 <Philippa> a -focus could do with a FLM-like wiki with logs held immutable and pages built on top though, I suspect
17:08:54 <Philippa> transcripts and room for commentary
17:08:57 <shapr> hm, that would be cool
17:09:05 <nominolo> we need a real-time threaded web-based chatroom :)
17:09:08 <shapr> That's an excellent idea!
17:09:16 <sorear> written in haskell :)
17:09:18 <shapr> The FLM transcripts...
17:09:27 <mbishop> as long as it's got 2.0 in the name, it's sure to be a hit
17:09:31 <shapr> haha
17:09:40 <Pseudonym> FLM 2.0!
17:09:43 <Philippa> doing it for #haskell itself'd be a really bad idea at the moment though, we generate too much traffic
17:09:59 <shapr> nominolo: Quick, write up a threaded chatroom! I've never figured out how it could thread..
17:10:11 <sorear> nominolo: tcp handshakes are quite a bit of overhead, and AJAX sucks, so I think we should use a custom protocol
17:10:13 <shapr> Gale has the closest thing to threading, and it's pretty arbitrary.
17:10:17 <sorear> (with a web gateway)
17:10:23 <nominolo> pretty much like a live-updated forum i guess
17:10:36 <nominolo> and you'd view the ones you're interested in
17:10:44 <Philippa> that's Gale
17:10:50 <Philippa> didn't find it usable when I tried
17:11:00 * nominolo takes a look at Gale then
17:11:01 <shapr> I didn't mind it so much, but there aren't many people.
17:11:13 <shapr> SILC had the same problem, nifty but few users.
17:11:28 <Pseudonym> I think that IRC plus the ability to "tag" is enough.
17:11:31 <Philippa> if you can follow it but I can't that suggests it's only really usable for a comparative minority of cognitive styles though
17:11:33 <shapr> Yeah, I agree.
17:11:43 <Philippa> Pseudonym: give or take, yeah
17:11:44 <Pseudonym> Ideally, you should be able to tag lines after you deliver them.
17:11:50 <Pseudonym> Not long after, of course.
17:11:53 <araujo> hello!
17:12:00 <Pseudonym> But you sometimes accidentally start a new "thread".
17:12:03 <Philippa> much akin to the existing bot quote systems
17:12:09 <Pseudonym> Right.
17:12:09 <stepcut> idoes ginsu support threaded chats ?
17:12:13 <ddarius> I suggested an idea earlier about having lambdabot spawn log and store to the wiki IRC conversations.
17:12:51 <ddarius> That said, is there an actual problem that needs to be solved?
17:12:53 <stepcut> http://repetae.net/john/computer/ginsu/
17:12:54 <lambdabot> Title: Ginsu
17:13:13 <Pseudonym> ddarius: Yes.  People give interesting speeches in IRC, and it's hard to find them or refer to them later.
17:13:38 <ddarius> Pseudonym: I was referring to the overall conversation.  I do agree that it would be nice to capture those though.
17:13:47 <nominolo> Philippa: what does FLM stand for?
17:13:53 <nominolo> or, what is it?
17:14:01 <sorear> @go FLM
17:14:03 <Philippa> I'll let shapr answer - it's his project
17:14:04 <ddarius> @where logs
17:14:04 <lambdabot> http://www.flmloans.co.uk/
17:14:04 <lambdabot> Title: FLM Loans :: Unsecured Personal Loans :: Welcome to home
17:14:04 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
17:14:06 <nominolo> (i don't dare google for a TLA)
17:14:11 <ddarius> sorear: Fermat's Last Margin
17:14:16 <ddarius> (I assume)
17:14:22 <Philippa> ddarius: yep
17:14:42 * sorear writes DrIFT for C
17:14:43 <vincenz> Igloo: ping
17:15:51 <Philippa> nominolo: the idea was to wikify the notes you'd scribble in the margins of papers you read
17:15:53 <miez> do i have to import Prelude if i want to use Num, Fractional etc..?
17:16:17 <sorear> no
17:16:17 <nominolo> Philippa: ah, hence the name :)
17:16:46 * nominolo is surprised that he knows about fermat's margin notes
17:16:52 <sorear> miez: if you don't explicitly import the prelude in any way, haskell acts as though you specified 'import Prelude'
17:17:19 <defcon8> sorear, thinking that, shouldn't we all be surprised that we even know about haskell and what functional programming is when compared to the whole world?
17:17:44 <sorear> miez: so, if you don't want the prelude symbols, 'import Prelude()' will import 0 symbols from the prelude - and by being explicit it prevents the auto-import
17:17:50 <sorear> defcon8: huh?
17:17:50 <Philippa> there's a problem with that: next thing you know you're surprised you're conscious
17:17:55 <miez> sorear actually i want to import everything except the list-related stuff
17:18:19 <sorear> import Prelude hiding (filter, map, concat, ...)
17:18:28 <miez> omg.. thanks
17:19:10 <sorear> defcon8: what does your argument have to do with my * sorear is writing DrIFT for C?
17:19:22 <defcon8> sorear, no
17:19:22 <sorear> defcon8: (and at that, what does your argument mean?)
17:19:27 <defcon8> nothing
17:19:42 <defcon8> I just wanted to say it's wonderful to know about such things
17:19:51 <sorear> is this a thread: v<sorear> defcon8: (and at that, what does your argument mean?)
17:19:51 <sorear> <defcon8> nothing
17:19:56 <defcon8> I meant nothing malicious
17:20:22 <sorear> defcon8: I'm trying for "curious", not "defensive" :)
17:20:51 <defcon8> :|
17:21:14 * sorear smiles  harder
17:22:29 * nominolo puts "write web-2.0-y betaish realtime threaded forum software Real Soon Now (TM)" on TODO list and goes back to coding
17:22:47 <malsyned> anybody know how in Emacs to jump from an opening bracket to its matching close bracket?
17:23:04 <mightybyte> '%' in vim ;)
17:23:13 <malsyned> mightybyte: sure, everybody knows that.
17:23:21 <sorear> C-h a
17:23:23 <ddarius> hmm, one very low-tech, but works today solution to tag conversations would be to simply say something like "MAKETAG someword"
17:23:25 <jcreigh> hmm, xmms works a little better with xmonad than I expected.
17:24:06 <sjanssen> heh
17:24:08 <malsyned> sorear: I'd have to know a bit about the command name in order for that to work
17:24:25 <jcreigh> a little focus strangeness, but mostly does what you'd expect.
17:24:27 <Igloo> vincenz: Yup?
17:24:37 <emu> malsyned: C-M-f
17:24:38 <sorear> malsyned: (on a whim) would the sexp comments dtrt?
17:24:52 <sorear> s/comments/commands/
17:24:52 <emu> or -b
17:24:59 <vincenz> Igloo: any news on that bug?
17:25:22 <malsyned> emu is is right, and so sorear: yes.
17:25:27 <nominolo> malsyned: M-right-arrow
17:25:40 <malsyned> nominolo: nope, that's forward-word
17:25:48 <nominolo> C-M-arrow?
17:25:48 <emu> M-f M-b is forward/back word
17:26:01 <Igloo> vincenz: I think it got fixed, if you mean the one I think you do
17:26:19 <nominolo> works for me
17:26:55 <nominolo> it's fordward-sexp-nomark
17:27:02 <emu> i got very spoiled by paredit
17:27:17 <vincenz> Igloo: the tag thingy
17:27:21 <nominolo> emu: ooh yes
17:27:27 <nominolo> i miss C-M-q soo much
17:27:34 <emu> C-M-q is emacs standard
17:27:43 <emu> but yes, i miss it too
17:27:45 <nominolo> (which isn't even paredt)
17:27:49 <nominolo> yeah
17:27:54 <emu> but in the presence of layout, it's not really decidable
17:28:10 <nominolo> well, you know the current layout
17:28:37 <emu> in that case, you can use rectanglar region commands to reindent
17:28:38 <nominolo> i used some C-x r k  and C-x r y magic
17:28:54 <emu> i use open- and delete- a lot too
17:29:08 <emu> vim's Visual Block seems to dtrt thing when selecting text though
17:30:06 <ski> C-M-q ?
17:30:14 <nominolo> ski: auto-reindent
17:30:17 <sorear> C-M-q is undefined
17:30:36 <sorear> hello dmead .
17:30:39 <dmead> hi
17:31:22 <ski> nominolo : where is that command ?
17:32:08 <emu> sorear: in haskell-mode ya.
17:32:33 <nominolo> ski: oh, sorry.  it is lisp-mode only
17:32:36 <emu> in other languages, it reindents the current block
17:33:40 <sorear> emu: I tried C-h C-M-q in erc-mode
17:33:54 <emu> try doing it in emacs lisp mode
17:33:58 <emu> and you mean C-h k
17:34:20 <sorear> yes, that's what I actually did (re: c-h k)
17:34:30 <emu> head to *scratch* or something
17:35:14 <emu> C-M-\ is reindent-region
17:35:27 <defcon8> emu, are you trying to be funny?
17:35:32 <defcon8> "head to *scratch*"
17:35:41 <defcon8> tsk tsk
17:35:42 <emu> C-x b *scratch*
17:36:05 <defcon8> joke :|
17:36:06 <emu> either you're being silly, or you never used emacs ? :)
17:36:11 <defcon8> wtf?
17:36:15 <nominolo> emu: C-M-\ fucks up real bad
17:36:20 <defcon8> I've been using emacs for a year and yes, I was being silly
17:36:21 <emu> in haskell-mode, yea
17:36:30 <emu> defcon8: i know, it just doesn't come across well on IRC
17:36:32 <ski> C-M-q runs the command indent-sexp
17:36:41 <defcon8> I guess not
17:37:26 <nominolo> i think emacs is not worth fixing all this.  soon yi will be haskell-ide of choice :)
17:37:41 <defcon8> yi?
17:37:44 <emu> is it? does it have something interesting about the mode?
17:37:46 <defcon8> website please
17:37:54 <ski> @where yi
17:37:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:37:57 <emu> i'm still experimentin
17:38:09 <defcon8> found it
17:38:11 <emu> right now i'm using straight vim7
17:41:32 <nominolo> emu: no but you can script it in haske
17:41:38 <nominolo> *haskell
17:41:46 <nominolo> which means, nice parser combinators
17:42:04 <nominolo> parsing is no fun at all in emacs
17:42:27 <sorear> yi supports haskell synhl, badly
17:42:47 <sorear> hello cdsmith!
17:42:53 <nominolo> but it would probably be a better start, doesn't it?
17:42:57 <cdsmith> sorear: hello
17:50:27 <cdsmith> Whoa!  8 minutes with no messages.  Did the world end?
17:50:34 <malsyned> I'm still alive!
17:50:49 <sorear> f
17:50:50 <sorear> l
17:50:51 <sorear> o
17:50:52 <sorear> o
17:50:56 <sorear> d
17:51:04 <steven_ashley> :o
17:51:14 <sorear> xb
17:51:23 <sorear> er, C-x C-b :)
17:51:46 <cdsmith> That looks like... <gasp> .. emacs-isms.
17:52:06 <zbrown> emacs is a nice OS, but it lacks a decent editor.
17:52:29 <cdsmith> zbrown: :)
17:52:30 <sorear> I am not ashamed of the fact that my OS is written in a garbage collected memory safe language
17:52:34 <ski> @remember cdsmith Whoa!  8 minutes with no messages.  Did the world end?
17:52:35 <lambdabot> Done.
17:52:47 <sorear> s/language/functional \&/
17:53:07 <zbrown> cdsmith: ;) vim FTW!
17:53:19 <emu> someone should implement vim in emacs OS
17:53:19 <nominolo> actually it was only 7 minutes here
17:53:30 <emu> nominolo: are you travelling at 20% the speed of light?
17:53:32 <sorear> emu: they already have, several times
17:53:33 <atsampson> emu: M-x viper-mode
17:53:34 <nominolo> is someone here travelling with light speed?
17:53:37 <nominolo> heh
17:53:38 <emu> i know =)
17:53:57 <atsampson> (unfortunately it's not a complete enough implementation to run vimacs...)
17:53:58 <sorear> emu: also try M-x term :)
17:54:06 * ski idly wonders if one can run vi(m) inside emacs ..
17:54:26 <emu> viper doesn't seem to play well with mode-specific bindings though
17:54:33 <sorear> well, you can run nethack in emacs
17:54:41 <cdsmith> I have to stick up for 'lpe' as world's greatest editor.  It sucks, but I wrote it (about 8 years ago).
17:54:57 <nominolo> @go lpe editor
17:54:59 <lambdabot> http://cdsmith.twu.net/lpe/
17:54:59 <lambdabot> Title: LPE Moved!
17:55:24 <emu> @editorwar lpe vim
17:55:24 <atsampson> cdsmith: cool -- I used to use lpe :)
17:55:24 <lambdabot> Unknown command, try @list
17:55:34 <sorear> ed isn't half bad
17:55:35 <cdsmith> atsampson: really?  Surely you're kidding.
17:55:41 <sorear> I like emacs (a little) better
17:56:31 <atsampson> cdsmith: I used to like it for C/C++ before I became a vim junkie...
17:56:31 <sorear> I think ed-2007 would be the best editor, period.  ed-1970 competes decently with emacs-2007...
17:56:34 * nominolo likes to try out deuce
17:56:39 <chessguy> ?seen dpiponi
17:56:39 <lambdabot> dpiponi is in #haskell. I don't know when dpiponi last spoke.
17:57:13 <procyon_> lol.  I just tried to run vim in emacs on my machine and realized I don't have any vi's installed.  1 year on this machine and I didn't even notice.
17:57:14 * johnnowak wonders if he's the only one using an editor created in this  century 
17:57:16 <cdsmith> atsampson: wow, I thought I was the only one.  I still use it occasionally for emotional value.  I should write a Haskell mode one of these days.
17:57:27 <chessguy> dpiponi: hi! i'm just writing a more thorough response to your game-strategy-as-a-monad blog
17:57:32 <emu> ok i just ran vim in term
17:57:34 <emu> (emacs)
17:57:51 <sorear> johnnowak: which one?
17:57:51 <emu> johnnowak: 21st century vastly overrated!
17:58:00 <johnnowak> sorear: textmate
17:58:16 <johnnowak> and vim for scheme
17:58:44 <procyon_> emu: hehe.  You can run emacs inside emacs using term.
17:58:48 <emu> it doesn't do well with eSC though
18:00:57 <emu> i decided to change my style with vim now though.  i indent "where" more than the bindings.
18:01:04 <emu> anyone else do that?
18:01:49 <malsyned> what's the syntax for "this object, but with this field replaced by this value"?
18:01:52 <steven_ashley> hello siti
18:01:58 <siti> hi :p
18:02:01 <sjanssen> emu: I've never seen that style
18:02:03 <emu> var { fiekld = val }
18:02:08 <malsyned> emu: thanks
18:02:10 <dpiponi> chessguy: Oh, are you the guy I replied to?
18:02:24 <chessguy> yes. and you're the guy i just replied to about 30 seconds ago :)
18:02:27 <emu> sjanssen: i was surprised that it worked
18:03:11 <dpiponi> chessguy: I probably agree. But there's something else I've been wondering about...
18:03:18 <chessguy> i'm all ears
18:03:42 <hpaste>  emu pasted "where indent example" at http://hpaste.org/1041
18:04:14 <nominolo> emu: that looks terrible
18:04:25 <dpiponi> alpha-beta is a kind of lazy minimax that doesn't bother searching pointless parts of the tree
18:04:36 <orbitz> lazy bastids
18:04:47 <dpiponi> so is there a way to take some minimax code and make it alpha-beta by using a clever lazy datastructure
18:04:48 <jcreigh> sometimes I do something like
18:04:53 <jcreigh> f x = z
18:04:54 <emu> hehe
18:04:54 <jcreigh>   where
18:04:57 <jcreigh>     z = whatever
18:05:04 <emu> i kinda got annoyed by the double-tab though
18:05:06 <nominolo> jcreigh: that's my preferred style
18:05:08 <emu> like that ^
18:05:10 <chessguy> mmm, alphabeta is lazy in a different sense from haskell, i think
18:05:33 <sjanssen> emu: I generally indent where less than a tab length, 1 or two spaces
18:05:35 <dpiponi> chessguy: yes. I don't really mean lazy in the Haskell sense.
18:05:41 <chessguy> of course alphabeta is easy to code in haskell, but i don't think you can get it for free
18:05:45 <emu> i might switch to 2 spaces
18:05:50 <dpiponi> chessguy: no, that's not right, I do mean in the lazy sense
18:06:10 <emu> oh well, it was an experiment.  after you get used to it, it kinda looks neat i think.
18:06:24 <dpiponi> chessguy: for example you can write a lazy multiplication function that doesn't evaluate its second argument if the first is zero
18:06:38 <chessguy> sure
18:06:53 <pdet> hello everyone
18:07:00 <dpiponi> is there some interesting datatype that could be used to represent the scores of positions so that when you asked...
18:07:07 <ski> dpiponi : possibly one could derive minimax -> alphabeta by constraints ..
18:07:09 <nominolo> emu: i'd feel annoyed if i had to maintain such code
18:07:22 <nominolo> emu: first thing would be to re-layout
18:07:25 <dpiponi> ..."could this tree produce a better result than what I've seen so far?" it would do so automatically
18:07:52 <nominolo> i think we already have quite a lot of different haskell styles
18:08:07 <dpiponi> ski: what exactly do you mean?
18:08:14 <chessguy> hmm
18:08:35 <emu> mm, i think emacs haskell-mode really encourages braces-and-semicolons style
18:09:09 <nominolo> emu: yes?  i use it and i use it almost never
18:09:17 <emu> neither do i
18:09:23 <nominolo> ie, no { ; }
18:09:28 <dpiponi> chessguy: a trivial example: consider min(3,max(4,x)). You don't need the value of x.
18:09:31 <emu> but when i did try { ; }, it worked really smoothly
18:09:50 <dpiponi> chessguy: so if you had smart implementations of min and max, maybe alpha-beta would just drop out of minimax code. Maybe????
18:09:58 <chessguy> dpiponi: right, but you do have to do some evaluation if the second option
18:10:13 <chessguy> s/option/argument of min
18:11:42 <dpiponi> Yes, just as you have to evaluate the 2nd argument in a*b if a/=0. But lazy multiplication is still useful for some problems.
18:11:59 <ski> dpiponi : constraint (logic) programming ..
18:12:19 <emu> > sum [1..] > 0
18:12:23 <lambdabot> Terminated
18:12:30 <ski> i have a hunch that it could be used to avoid computing the nonneeded parts
18:12:37 <ski> '(a = 3 `min` b) /\ (b = 4 `max` x) /\ ..some complex constraint specifying x..' .. hmm
18:12:47 <chessguy> dpiponi: the thing is, you still have to get to a leaf somewhere in a branch before you know you can skip the branch
18:13:29 <dpiponi> chessguy: yes, I know. It may turn out that the min and max functions would be as complicated as alpha-beta search anyway.
18:13:39 <SamB> whoah...
18:13:53 <SamB> what a strange thing to get from alt-tab...
18:13:58 * nominolo wonders if he's the only one who thinks that lambdabot's "Terminated" message is a bit ambiguous
18:14:31 <kc5tja> nominolo: It's terminated because it took too long to evaluate x, for any x.
18:14:32 <dpiponi> chessguy: But I still have a hunch there is an alternative way of seeing alpha-beta along these lines
18:14:41 * nominolo always things of terminating algorithms
18:15:06 <nominolo> ("Aborted" or "Died" sounds better to me)
18:15:14 <chessguy> dpiponi: possibly. how useful it would be is another question
18:15:24 <emu> nominolo: but less ahnoldesque
18:15:46 <nominolo> ahno..what?
18:15:58 <dpiponi> chessguy: Useful? I hope there aren't any pure mathematicians around :-)
18:16:09 <chessguy> lol
18:17:42 <dpiponi> chessguy: One thing I know for sure. When it comes to writing chess AIs I'm lucky...
18:18:00 <chessguy> how so?
18:18:05 <dpiponi> chessguy: because I think I could write a program in just a few hours that would thrash me.
18:18:10 <chessguy> lol
18:18:23 <pstickne> dpiponi, or maybe you're just ... :p
18:18:24 <dpiponi> chessguy: I'm the kind of guy who could lose by fool's mate two games in a row!
18:18:26 <SamB> Alt-tab is coming out ^√â under xmonad, for me...
18:19:19 <sjanssen> SamB: does Alt+j work?
18:19:20 <SamB> zsh says "zsh: command not found: \u0089"
18:20:07 <SamB> by work, do you mean... produce "√™"?
18:20:20 <jcreigh> > ord '\t' .|. 128
18:20:21 <lambdabot>  137
18:20:21 <dmead> could someone point me to a decent example of a technical writeup for a code project?
18:20:42 <sjanssen> SamB: it should switch to another workspace
18:20:46 <SamB> oh.
18:20:52 <SamB> well, maybe I need to grab the input...
18:20:52 <sjanssen> s/workspace/window
18:21:16 <sjanssen> you might want to adjust the value of modMask in Main.hs
18:21:38 <dons> ?yow
18:21:39 <lambdabot> When I met th'POPE back in '58, I scrubbed him with a MILD SOAP or
18:21:39 <lambdabot> DETERGENT for 15 minutes.  He seemed to enjoy it ...
18:21:45 * SamB is running under Xephyr, fwiw
18:21:53 * araujo `catch` dons 
18:21:53 <dons> sjanssen: so the new xmonad patches seem to work?
18:21:57 <dons> they fix the issue I had anyway.
18:21:59 <dons> hey araujo
18:22:05 <dons> oh, you want me to answer your email?
18:22:09 <araujo> hello dons !
18:22:15 * dons should employ a secretary to process email
18:22:21 <araujo> dons, well, as long as you have had the time to do it :-)
18:22:27 <sjanssen> dons: yeah, things seem to work
18:22:29 <dons> rather than just writing code, and ignoring email for days at a time
18:22:37 <dons> sjanssen: so yay, xmonad with Xinerama support!
18:22:37 <araujo> dons, haha, it's fine ...
18:23:59 <jcreigh> there still seems to be a glitch every now and then when switching to a workspace on another monitor that I'll have to track down...
18:24:23 <jcreigh> is anybody planning on implementing tiling soon?
18:24:33 <jmelesky> anyone know of any support vector machine libraries in haskell? i'd rather not wrap libsvm
18:24:56 <sjanssen> jcreigh: so how does this xinerama stuff work?  I'm having trouble seeing the big picture from the code
18:25:06 <dons> jcreigh: i think you and sjanssen should attack the tiling.
18:25:15 <sjanssen> jcreigh: I've been meaning to do it for a while . . .
18:25:15 <dons> i'd take it on, but i don't use it. so there's no demand on me :-)
18:25:30 <dons> features are demand driven: you need someone to care enough
18:25:43 <dons> ah yes. we will need to sit down and clean up the code again.
18:26:36 <jcreigh> sjanssen: Every screen has a workspace. If you switch to a workspace that is visible on another screen, it just switches focus to that screen. if you switch to a non-visble workspaces, it switches the *current* screen to that workspace.
18:27:22 <sjanssen> ahh, reusing ws switching for screen focus -- very clever!
18:27:51 <sjanssen> jcreigh: is this the optimal setup in your opinion?
18:28:50 <jcreigh> sjanssen: Sometimes it's kind of confusing which workspace is on which screen. I'm thinking some sort of statusbar would help with that.
18:29:20 * SamB wonders if he can get Xephyr to do xinerama...
18:29:30 <sjanssen> SamB: what is Xephyr?
18:29:34 <jcreigh> but for me, it works fine, because I mostly just place windows on different screens. (ie, usually screen 1 has workspace 1, screen 2 has workspace 2, etc.)
18:29:52 <SamB> sjanssen: Xnest's little brother
18:29:59 <SamB> also replacement
18:30:01 <jcreigh> "little" brother?
18:30:09 <jcreigh> Xnest was pretty minimal to start with, wasn't it?
18:30:11 <SamB> jcreigh: younger, if you prefer
18:30:56 <Excedrin> any ideas on my paste http://hpaste.org/1040 ?
18:31:34 <jcreigh> I may add a function to switch to screen N regardless of what workspace is on that screen...but that's trivial, and I haven't felt the need yet.
18:32:05 <araujo> Excedrin, that it isn't haskell?
18:32:08 <araujo> :-)
18:33:10 <dons> jcreigh: yeah, i think a pop-up status bar would be useful too
18:33:21 <dons> its hard enough to remember 5 workspaces on 1 physical screen
18:33:27 <jcreigh> dons: hmm? pop-up? Sounds interesting. How would that work?
18:33:43 <jcreigh> like, you hold down modkey, and it appears?
18:33:46 <dons> you'd hit a key stroke, and the menu would run.
18:33:47 <dons> yes.
18:33:49 <SamB> KeyPress event, serial 23, synthetic NO, window 0xe00001,
18:33:49 <SamB>     root 0x3a, subw 0x0, time 1828366804, (424,477), root:(426,479),
18:33:49 <SamB>     state 0x18, keycode 44 (keysym 0x6a, j), same_screen YES,
18:33:49 <SamB>     XLookupString gives 1 bytes: (6a) "j"
18:33:49 <SamB>     XmbLookupString gives 1 bytes: (6a) "j"
18:33:50 <SamB>     XFilterEvent returns: False
18:33:51 <dons> like dmenu, but with status info
18:33:59 * SamB wonders what this all means...
18:34:08 <TSC> You pressed j
18:34:26 <SamB> yeah.
18:34:36 <jcreigh> dons: would this be an external program, or built into xmonad?
18:35:22 <sjanssen> jcreigh: probably an external program
18:36:04 <Excedrin> araujo: how can I translate that to Haskell and retain C performance?
18:36:17 <dons> i'd like a generic dmenu app, that displays text read from stdin
18:36:25 <jcreigh> Excedrin: main = print 8347680 :)
18:36:28 <dons> so then we write a statusbar script, which just prints text
18:36:35 <dons> and feed that to dmenu to display
18:36:37 <araujo> Excedrin, Recursive functions
18:36:47 <dons> Excedrin: where's the code?
18:36:50 <dons> http://hpaste.org/1040
18:37:10 <dons> urgh
18:37:22 <sjanssen> Excedrin: use list comprehensions
18:37:23 <dons> but yes, you write that to use guards and recursion
18:40:05 <hpaste>  sjanssen annotated "iteration + state" with "list comprehensions" at http://hpaste.org/1040#a1
18:41:15 <dons> Excedrin: basically, ideally, you turn each loop into:
18:41:16 <dons> go_o a o | o < 36    = go_o (a+1)
18:41:16 <dons>          | otherwise = a
18:41:22 <dons> where you pass the variables in stack slots
18:41:35 <dons> which means they're mutated. it should then fallout as a set of gotos in the generated code
18:44:07 <user317> i always find myself creating this function: let scan ff zz ll =  zn : scan ff zn (tail ll) where zn = ff zz (head ll), so i can do take 5 $ scan (+) 0 [1..] => [1,3,6,10,15].  why isn't something like this in prelude, or am i missing something?
18:44:08 <chessguy> dpiponi: there's something else i've been thinking about for games of strategy
18:45:02 <jcreigh> > take 5 $ scanl (+) 0 [1..]
18:45:03 <lambdabot>  [0,1,3,6,10]
18:45:09 <jcreigh> user317: scanl is in Data.List
18:45:37 <user317> jcreigh, duh, i didn't know scanl works on infinite lists :)
18:46:37 <user317> jcreigh, thanks :)
18:46:59 <jcreigh> user317: np
18:48:34 <chessguy> @type (!!)
18:48:36 <lambdabot> forall a. [a] -> Int -> a
18:48:45 <chessguy> ?hoogle Array
18:48:45 <lambdabot> Array :: module
18:48:45 <lambdabot> Data.Array :: module
18:48:45 <lambdabot> Foreign.Marshal.Array :: module
18:49:03 <chessguy> @type Data.Array.(!!)
18:49:05 <lambdabot> Couldn't find qualified module.
18:49:14 <Excedrin> is that the only way?
18:49:40 <chessguy> @type Data.Array.(!)
18:49:42 <lambdabot> Couldn't find qualified module.
18:49:55 <hpaste>  dons annotated "iteration + state" with "Runs at identical speed to gcc t.c on my machine" at http://hpaste.org/1040#a2
18:50:02 <dons> Excedrin: around? ^^
18:50:14 <dons> Excedrin: that translation runs in exactly the same time as gcc t.c on my box.
18:51:04 <dons> $ time ./c
18:51:04 <dons> 8347680
18:51:04 <dons> ./c  0.06s user 0.00s system 95% cpu 0.066 total
18:51:07 <dons> $ time ./H
18:51:07 <dons> 8347680
18:51:07 <dons> ./H  0.06s user 0.00s system 95% cpu 0.066 total
18:51:10 <dons> go GHC, go!
18:51:36 <jcreigh> the problem with writing code that runs as fast as C is that sometimes the Haskell ends up looking like C.
18:51:43 <dons> of course.
18:51:51 <dons> that's the easiest way
18:51:56 <dons> sometimes you get lucky with much higher level code
18:52:02 <jcreigh> but at least the whole program doesn't have to look that way; only the slow parts.
18:53:00 <SamB> hopefuly you can just write some RULES for it
18:53:31 <dons> actually, you can float out the i+1's and beat C:
18:53:32 <dons> $ time ./H
18:53:32 <dons> 8347680
18:53:32 <dons> ./H  0.06s user 0.00s system 99% cpu 0.063 total
18:54:09 <hpaste>  dons annotated "iteration + state" with "more speed, do our own CSE" at http://hpaste.org/1040#a3
18:54:30 <dons> haskell makes a great asm
18:54:54 <SamB> so, what happens when you people run xev and type ^J?
18:54:57 <SamB> er.
18:55:00 <dons> so the nice trick would be to replace these with folds or something
18:55:00 <SamB> alt-J
18:55:02 <SamB> rather...
18:55:07 * SamB confused a bit
18:55:40 <dons> bah, Excedrin left.
18:58:44 <SamB> so...
18:59:07 * SamB wonders what is indicated by the 0x10 in his "state" values
19:00:09 <jcreigh> SamB: what's wrong? (/me assumes that people try to learn about X11 to fix some problem they have, rather than for the joy of learning.)
19:00:18 <jcreigh> but that could just be me. :)
19:00:52 <SamB> well, I want to know why it is set!
19:01:42 <SamB> xmonad doesn't seem to like it
19:01:52 <jcreigh> oh, weird
19:02:01 <jcreigh> so switching windows doesn't work for you?
19:02:04 <SamB> it is set right now
19:02:08 <SamB> no, it does not work
19:03:44 <jcreigh> is this still inside that virtual X server?
19:03:51 <SamB> yeah
19:05:18 <jcreigh> http://tronche.com/gui/x/xlib/events/keyboard-pointer/keyboard-pointer.html
19:05:20 <lambdabot> Title: Xlib Programming Manual: Keyboard and Pointer Events, http://tinyurl.com/ypez6o
19:05:31 <SamB> it works with:
19:05:32 <jcreigh> state is the result of OR'ing a bunch of modifier masks
19:05:36 <SamB> modMask = 0x10 .|. mod1Mask
19:06:07 <SamB> what manpage is this in...
19:08:13 <jcreigh> ??
19:08:46 <jcreigh> grr, those X11 folks shouldn't assume I can spell. Xephyr, indeed.
19:18:30 * SamB apparantly cannot read across join
19:18:42 <TSC> If I have a class "Grid g", and a function "showGrid :: Grid g => g -> String" ...
19:18:55 <TSC> can I write something like :  instance (Grid g) => Show g where show = showGrid   ?
19:19:12 <vincenz> yes
19:19:25 <vincenz> hmm
19:19:31 <vincenz> maybe not
19:19:33 * vincenz ponds
19:19:43 <vincenz> no, you might get overlapping instances
19:19:44 <vincenz> I mean
19:19:51 <vincenz> what if "instance Grid Char"
19:20:21 <chessguy> TSC: it's generally better to just use your showGrid function instead of show
19:20:38 <TSC> Ah, you (both) are right
19:20:50 <vincenz> chessguy: well that's arguable
19:20:52 <SamB> jcreigh: okay, I still can't understand why my events all have a state of at least "0x10"
19:20:57 <glguy> > 2^64
19:20:58 <lambdabot>  18446744073709551616
19:20:59 <TSC> If I turn on glasgow-exts, it complains about undecidable instances
19:20:59 <kfish> a quiet pond / a frog jumps in / the sound of type inference
19:21:22 <vincenz> @remember kfish a quiet pond / a frog jumps in / the sound of type inference
19:21:22 <lambdabot> Done.
19:21:36 <TSC> "Constraint is no smaller than the instance head in the constraint: Grid g"
19:21:41 <chessguy> vincenz: it's pretty obvious from what you just said
19:21:44 <TSC> What does that mean?
19:21:59 <vincenz> chessguy: well tehre's way around that "-fallow-undecidable.."
19:22:05 <chessguy> not to mention, i've fought with it before, and ultimately conceded
19:22:11 <vincenz> chessguy: if you have a list of tuples of these g's, just calling show on it is might eay
19:22:15 <vincenz> easy
19:22:21 <chessguy> vincenz: i prefer sticking with standard haskell
19:22:41 <SamB> TSC: I think that is computer for "it just gets nastier!"
19:22:43 <vincenz> well since I am currently using GADTs, I dont :)
19:22:58 <chessguy> that's nice
19:23:01 <ski_> TSC : the constraints on the lhs of '=>' must be smaller/simpler than the one on the rhs, to ensure termination
19:23:01 <vincenz> ..
19:23:08 <vincenz> chessguy: always so abbrasive?
19:23:18 <TSC> Ah, thanks ski
19:23:23 <chessguy> vincenz: always so contradictory?
19:23:46 <SamB> GADTs are a better direction than -fallow-<bad>-typeclasses
19:23:46 <ski_> > fix not
19:23:47 <lambdabot>  Exception: <<loop>>
19:23:56 <Japsu> hmm
19:23:59 <sjanssen> SamB: just typing a key with no modifier has an 0x10 state mask?
19:24:10 <vincenz> either way, there's other solutions besides just -fallow undecidable
19:24:10 <SamB> sjanssen: just *moving the mouse* has that
19:24:14 <vincenz> you could use existentials
19:24:21 <Japsu> has anyone thought of implementing a "PL/Haskell" in PostgreSQL?
19:24:29 <chessguy> vincenz: i never claimed there weren't other solutions
19:24:36 <SamB> sjanssen: I don't know what it represents though
19:24:37 <vincenz> chessguy: I wasn't talking to you specifically
19:25:22 <Japsu> I mean, an extension to PostgreSQL that would enable one to write PostgreSQL database functions in Haskell
19:25:45 <sjanssen> SamB: perhaps it's a better idea to run xmonad on another display instead of Xephyr
19:25:58 <TSC> I have found a simpler way to do it: instance Show GridMap where show = showGrid
19:26:04 <sjanssen> for example: startx -- :2
19:26:06 <TSC> (where GridMap is an instance of Grid)
19:26:13 <SamB> sjanssen: that tends to crash things
19:26:19 <TSC> But not as nice ):
19:26:21 <vincenz> TSC: that works but will ahve to be done for every specific type
19:26:25 <SamB> I think maybe not many people have Voodoo 3s anymore
19:26:27 <vincenz> TSC: another idea is to use existentials like so:
19:26:32 <sjanssen> SamB: huh?  I've never had that problem
19:26:36 <vincenz> instance Show Griddable where
19:26:40 <vincenz>   show (Grid g) = showGrid g
19:26:45 <SamB> I'm thinking it might be driver bugs
19:26:57 <vincenz> data Griddable = Grid (forall a. Grid a)
19:27:01 <TSC> Yeah, that's a bit awkward too
19:27:10 <mightybyte> What's the difference between the "data" keyword and the "type" keyword?
19:27:17 <vincenz> mightybyte: type introduces a synonym
19:27:22 <mightybyte> They seem to be interchangeable
19:27:28 <vincenz> mightybyte: sort of like typedef
19:27:42 <vincenz> data Foo = Foo Int   is a different type from Int
19:27:49 <vincenz> type Foo = Int   then Foo is just another name for Int
19:28:06 <chessguy> hey mightybyte, check your PM
19:28:21 <mightybyte> In http://www.haskell.org/tutorial/goodies.html under 2.3 Type Synonyms it looks like data can also be used as a type synonym.
19:28:22 <lambdabot> Title: A Gentle Introduction to Haskell: Values and Types
19:28:56 <sjanssen> mightybyte: data isn't a type synonym
19:29:42 <sjanssen> mightybyte: in that Address example, it is a data type with two constructors: None and Addr -- the Addr constructor also takes a String
19:29:45 <vincenz> data Address            = None | Addr String is not a type synonym
19:30:00 <vincenz> right, what sjanssen said
19:30:12 <mightybyte> Ok
19:30:30 <sjanssen> so "foo" does not have the type Address, but (Addr "foo") does
19:30:33 <mightybyte> Can both of those keywords have a "deriving" clause?
19:30:37 <mdmkolbe> @paste
19:30:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:30:41 <sjanssen> data can, but type can't
19:31:01 <SamB> I really don't think that xmonad should be paying attention to mask bits it doesn't care about, personally...
19:31:28 <vincenz> mightybyte: it makes no sense to have a deriving clause for a 'type ...' declaration, as it's just a synonym for another type which might already have class-derivations
19:31:55 <mightybyte> vincenz: Ok, I understand.  I thought it might be possible to add additional class-derivations.
19:32:02 <sjanssen> mightybyte: type is used for didactic purposes -- when you want to have a shorter alias for a long type, or when a special name for a type makes the code easier to read
19:32:12 <mightybyte> But I guess to do that I'd have to make a new type with a type constructor.
19:32:15 <vincenz> mightybyte: overloading is done based on types, now you'd have the same type with two different definitions, how can the compiler choose?
19:32:50 <mightybyte> Gotcha
19:34:33 <mightybyte> So back to my old TTT example http://hpaste.org/675
19:34:35 <siti> can someone take a look at this and tell me how I could fix the memory problems: http://hpaste.org/1042
19:34:35 <siti> it seems all the data is duplicated
19:35:16 <mightybyte> I have to reformulate my Board type if I want to make it derive from...say GamePosition
19:35:40 <hpaste>  mdmkolbe pasted "Using ArrowLoop" at http://hpaste.org/1043
19:35:58 <vincenz> who's competing in icfpc?
19:36:25 <mdmkolbe> Why are the two functions in http://hpaste.org/1043 not equivalent?
19:37:06 <vincenz> oy, arrows, there's one part of haskell I don't know about :/
19:37:11 <chessguy> err, you don't have a GamePosition declaration...
19:37:31 <LoganCapaldo> Arrows, one of many parts of Haskell I don't know about
19:38:26 <sorear> gekki!
19:38:40 * sorear stares at his hands...
19:39:17 <mdmkolbe> Arrows, I didn't know about them so I'm writing an X server replacement with them in hopes that by then end I'll know about them 8-)
19:39:26 <sorear> yay!
19:39:30 <mdmkolbe> s/then end/the end/
19:39:38 <LoganCapaldo>  /me finds the thought of sorear staring at his hands and shouting "gekki!" (whatever that means) oddly cinematic
19:39:44 <LoganCapaldo> woah
19:39:52 <sorear> ?
19:39:54 <LoganCapaldo> did I just not emote my emote?
19:40:02 <sjanssen> siti: I think you want foldl' instead of foldr in that example
19:40:03 <vincenz> CTRL+ENTER
19:40:05 <mdmkolbe> LoganCapaldo: you had a space at the front
19:40:26 <LoganCapaldo> I didn't mean to though :)
19:40:28 <sorear> the latest yhc patch is ten thousand lines :/
19:40:39 * SamB thinks Xephyr may be reading his xorg.conf
19:40:40 <vincenz> sorear: what does it do?
19:40:51 <sorear> vincenz: changes a generated file :)
19:40:52 <sorear> fools
19:40:58 <siti> sjanssen: it still uses lots of memory :(
19:41:08 <vincenz> my ++C frontend is much less than that :)
19:41:12 <sjanssen> SamB: regarding masks, I think xmonad is doing the right thing
19:41:23 <sorear> vincenz: what is ++c?
19:41:28 <vincenz> sorear: c++ done right :)
19:41:30 <hpaste>  siti annotated "(no title)" with "(no title)" at http://hpaste.org/1042#a1
19:41:52 <LoganCapaldo> Because C++ == C;
19:41:59 <sjanssen> SamB: you have to be able to distinguish between alt+shift+enter and alt+enter, for example
19:42:00 <TomMD> Q: In library Foo, how does one use the function 'func' when the type of an argument it requires is not exported?  (As in pcap)
19:42:07 <SamB> sjanssen: hmm.
19:42:07 <vincenz> LoganCapaldo: erm, no
19:42:12 <sorear> LoganCapaldo: no, C++ == C does not evaluate to true
19:42:14 <vincenz> LoganCapaldo: c++ == c is not definable
19:42:15 <SamB> well, I think the shift bit is a bit it cares about.
19:42:17 <vincenz> sorear: nor to false
19:42:19 <sorear> LoganCapaldo: it evaluates to <demons>
19:42:29 <sorear> vincenz: I know. Sequence points!
19:42:33 <vincenz> yah
19:42:35 <vincenz> hence ++C
19:42:36 <vincenz> :)
19:42:36 <dmead> <3 bits
19:43:00 <LoganCapaldo> Because x = C; y = C++; x == y
19:43:04 <sjanssen> TomMD: sounds impossible to me
19:43:06 <sorear> hm.
19:43:08 <TomMD> c++ == c + 1
19:43:24 <TomMD> sjanssen: That is my impression, so I must be missing something.
19:43:28 <sorear> what is the relationship between <demons> and _|_?
19:43:28 <mdmkolbe> vincenz: ++c > c is still not well defined unless c forces the evaluation order (which I don't think it does).
19:43:48 <sioraiocht> wow, you guys are TRUE programming language nerds
19:43:50 <sioraiocht> it's kinda awesome
19:43:58 <sjanssen> heh
19:43:58 <vincenz> mdmkolbe: well according to my language it's fine
19:44:00 <LoganCapaldo> And this is why state is bad
19:44:02 <LoganCapaldo> :)
19:44:03 <vincenz> sioraiocht: if you like tat, come to #oasis
19:44:09 * sorear pulls up a copy of ISO/IEC JTC1/SC22/WG14 N794
19:44:10 <TomMD> sioraiocht: You haven't seen anything until you've watched the Simons talk.
19:44:15 <mdmkolbe> sorear: <deamons> live in the abbis (_|_)?
19:44:44 <sioraiocht> TomMD: which Simons?
19:44:50 <ski> <nasal demons> is what 'unsafePerformIO' and 'unsafeCoerce#' can bring about
19:44:52 <TomMD> Peyton-Jones and Marlow
19:45:06 <sorear> nope, > doesn't make sequence points
19:45:24 <sjanssen> sorear: C compilers often return bogus results in <demons> situations, while Haskell implementations always return _|_ when they're supposed to
19:45:33 <LoganCapaldo> if you out two > right next to each other it makes a sequence point :)
19:45:38 <SamB> sjanssen: oh really?
19:45:43 <sioraiocht> TomMD: thought you might hagve been referring to Simon Thompson
19:45:45 * sorear refers sjanssen to GHC/List.hs
19:45:47 <johnnowak> i think i++ == i is a fairly safe assumption
19:45:54 <SamB> sorear: exactly!
19:45:57 <sjanssen> SamB: modulo bugs
19:46:09 <SamB> sjanssen: you think those RULES are bugs?
19:46:15 <miez> john but wrong
19:46:22 <ski> mdmkolbe : what is the difference in behaviour ?
19:46:30 <LoganCapaldo> johnnowak: its not though. its unsafeAssumption
19:46:35 <sjanssen> SamB: yes
19:46:44 <TomMD> sioraiocht: You have one of his books I am guessing?  I haven't actually met the man.
19:46:50 <LoganCapaldo> unsafeMakeAssumption
19:46:56 <chessguy> mightybyte: i think you have a problem with gameResult
19:46:59 <SamB> sjanssen: I suppose you are entitled to your opinions
19:47:03 <sjanssen> SamB: or bugs in the Haskell report
19:47:15 <sioraiocht> TomMD: I do, and my boyfriend has been accepted for his PhD to with him as his supervisor
19:47:20 <SamB> anyway, the results that might accidentally be returned when _|_ would have been... are usually not very bogus.
19:47:25 <sioraiocht> *work with him, even
19:47:27 <mdmkolbe> ski: well foo2 will actually save the old value, while foo1 doesn't seem to use the old value at all
19:47:28 <ski> unsafePeekExecution :: a -> Execution a  -- /me pondered some about this, recently ..
19:47:32 <mightybyte> chessguy: Oh?
19:47:33 <sorear> IMO haskell needs a <demons> value.  completely specified languages are Bad
19:47:39 <johnnowak> "You write X++ to access the value stored in the object designated by X, add 1 to the value, and store the new value back in the object. The value of the expression is the original value stored in the object."
19:47:42 * mdmkolbe considers posting a more complete (runnable) example
19:47:44 <chessguy> mightybyte: as it is, it can return X, O, or empty
19:47:45 <johnnowak> why is it an unsafe assumption?
19:47:51 <mightybyte> Yes
19:48:05 <chessguy> meaning, respectively, X won, O won, or "Game still in progress"
19:48:12 <chessguy> what if it ends in a tie?
19:48:19 <LoganCapaldo> because you don't know in what order x++ == x the expressions will be evalated
19:48:24 <mightybyte> I have other code to check that
19:48:28 <LoganCapaldo> it could increment x, store the new value
19:48:35 <LoganCapaldo> get that for the expr 'x'
19:48:45 <johnnowak> LoganCapaldo: it doesn't matter
19:48:48 <mightybyte> It's not the best design, I know
19:48:49 <LoganCapaldo> and compare to the old value of x (the return value of x++)
19:49:02 * SamB remembers he is playing FFVII
19:49:05 <johnnowak> LoganCapaldo: the value of the i++ side of the expression is always i
19:49:17 <ski> several updates to the same variable with no sequence points intervening invokes undefined behaviour, iirc
19:49:19 <chessguy> ermm, ok
19:49:22 * SamB goes back to that, it is more fun than arguing about modmask bits he doesn't understand
19:49:22 <LoganCapaldo> i = 3; i++ = i
19:49:29 <LoganCapaldo> 3 == 4
19:49:34 <LoganCapaldo> or 3 == 3
19:49:46 <johnnowak> LoganCapaldo: i don't think that's what the standard says
19:49:47 <LoganCapaldo> its not the i++ thats the problem its the i
19:50:03 <LoganCapaldo> the standard says its undefined, and "don't do that"
19:50:21 <johnnowak> well let me check then...
19:50:53 <miez> john logan is right
19:51:04 <LoganCapaldo> which was why they were right to call me on it when I made the C++ == C comment all the way up in the scrollback :)
19:51:17 <johnnowak> aye. it seems so. :)
19:51:18 <ski> (which e.g. means that compilers are allowed to *assume* you didn't do that, e.g. in order to produce better code)
19:51:31 <mdmkolbe> vincenz: won't limiting the order of evaluation like that limit the transformations the compiler can do?  Keep in mind your code often looks nothing like what you started with when the compiler is done with it and when it's an auto-parallelizing compiler things get even more hairy.
19:51:44 <[vincenz]> mdmkolbe: yes
19:51:56 <[vincenz]> mdmkolbe: otoh, you can ahve higher level transfos cause you know your semantics more clearly
19:52:09 <[vincenz]> they're better defined
19:52:30 <[vincenz]> which I need
19:52:43 <mdmkolbe> [vincenz]: better transforms are also aided by looser semantics (i.e. the compiler can play more games without braking your code)
19:52:56 <[vincenz]> mdmkolbe: only lowlevel trafos
19:53:08 <[vincenz]> mdmkolbe: not ones that span whole blocks and rearrange your ctrlflow
19:53:11 <ski> mdmkolbe : i think in the second case, the "y' <- delay False -< y" at each clock cycle .. while in the first, it only gets executed those clock cycles when 'x' is 'True'
19:53:13 * mdmkolbe descidees to name his next langauge "hairy" so he can point to his "hairy code"
19:53:24 <[vincenz]> mdmkolbe: join #oasis :)
19:53:45 * ski a while ago considered naming a language "contagion" ..
19:54:00 <sorear> #oasis is too busy for me :(
19:54:41 <newsham> lambdabot needs isabelle/hol
19:54:42 <ski> mdmkolbe : but i gotta run .. maybe can look more at it later ..
19:55:11 <ski> s/at each/executes at each/
19:55:28 <mdmkolbe> ski: thx, I'll try that
19:56:15 <newsham> anyone here from the l4verified/sel4 projects?
19:56:48 <mdmkolbe> newsham: not I, but it sounds cool. link?
19:57:03 <sorear> newsham: I've figured out how to embed coq in the typesystem... would that satisfy your perverse goals?
19:57:22 * sorear has been distracted from typeray, alals
19:57:22 <newsham> sorear: maybe.. i'm not that familiar with coq
19:57:31 <newsham> ?google sel4
19:57:32 <lambdabot> http://www.ertos.nicta.com.au/research/sel4/
19:57:32 <lambdabot> Title: Sel4 - ERTOS - National ICT Australia
19:57:52 <sorear> newsham: a theorem system using the calculus of constructions - dependent types and curried howard
19:58:12 <newsham> i've heard of it before but i havent had a chance to look into it
19:59:15 <newsham> the sel4 or l4verified people are doing semi-automated conversion from haskell to hol
19:59:22 <hpaste>  mdmkolbe annotated "Using ArrowLoop" with "(no title)" at http://hpaste.org/1043#a1
19:59:26 <newsham> i'm curious if any of it is public and consumable
19:59:33 <mdmkolbe> ski: that seems to work
20:01:11 <dmead> holy shit
20:01:26 <dmead> backus died today
20:01:26 <dmead> http://www.nytimes.com/2007/03/19/obituaries/20cnd-backus.html?_r=1&oref=slogin
20:01:29 <lambdabot> http://tinyurl.com/2e2ke4
20:01:53 <mightybyte> Oh, where is that?
20:02:08 <newsham> everyone is reduced to normal form sooner or later
20:02:44 <TSC> Or to a terminal
20:03:22 <mightybyte> @src unfoldTree
20:03:23 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:03:41 <chessguy> ?hoogle unfoldTree
20:03:41 <lambdabot> Data.Tree.unfoldTree :: (b -> (a, [b])) -> b -> Tree a
20:03:41 <lambdabot> Data.Tree.unfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
20:03:41 <lambdabot> Data.Tree.unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
20:03:51 * mdmkolbe moves that the ops have the channel observe a minute of silence for Backus
20:04:08 <dons> newsham: :-)
20:04:15 <mightybyte> Where's Data.Tree defined?
20:04:20 <dons> ?source Data.Tree
20:04:21 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
20:04:43 <chessguy> hm, i'm not quite sure how to ask this without it sounding completely stupid, but is there a class for types which contain values that "have (possibly multiple) successors"?
20:04:57 <sorear> enum for the single case
20:05:00 <sorear> > succ 22
20:05:01 <lambdabot>  23
20:05:04 <sorear> > succ 'e'
20:05:05 <lambdabot>  'f'
20:05:09 <sorear> > succ False
20:05:10 <lambdabot>  True
20:05:15 <encryptio> > succ 'z'
20:05:16 <lambdabot>  '{'
20:05:18 <chessguy> but that doesn't allow for multiple successors
20:05:19 <mightybyte> > succ True
20:05:20 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
20:05:24 <newsham> > iterate succ 'a'
20:05:26 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
20:05:39 <TSC> I guess you need mSucc :: a -> [a]
20:05:42 <mdmkolbe> chessguy: like maybe a partially ordered set class?
20:05:42 <chessguy> no, i mean multiple immediate successors
20:05:46 <LoganCapaldo> Now I know my abcs
20:05:51 <chessguy> TSC: right
20:05:54 <chessguy> something like that
20:06:12 <chessguy> though i'm not sure where your m is coming from
20:06:13 <cdsmith> Would the multiple successor class just be a DAG?
20:06:24 <TSC> m for multiple
20:06:29 <TSC> "succs" would be better
20:06:33 <mdmkolbe> chessguy: though technically I guess Ord defines a POSet, I guess it doesn't provide the interface you'd want
20:06:37 <mightybyte> I'm using http://haskell.org/onlinereport/ as my library reference, but it doesn't have Data.Tree.  Where would I find that?
20:06:37 <lambdabot> Title: The Haskell 98 Language Report
20:06:38 <newsham> m for monad.
20:06:41 <newsham> a -> [a]
20:06:43 <LoganCapaldo> instance (Enum a) => MSucc a where mSucc = [succ a] -- I love getting things for "free"
20:07:01 <chessguy> ?hoogle a -> [a]
20:07:02 <lambdabot> Prelude.repeat :: a -> [a]
20:07:02 <lambdabot> List.intersperse :: a -> [a] -> [a]
20:07:02 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
20:07:08 <LoganCapaldo> Dial m for monad
20:07:27 <newsham> the call/cc is coming from somewhere within the do-block!
20:07:33 <TSC> mightybyte: http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:07:51 <chessguy> LoganCapaldo: that's not exactly useful
20:08:01 <mdmkolbe> @docs Data.Tree
20:08:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
20:08:05 <LoganCapaldo> useful?
20:08:10 <jcreigh> SamB: okay, http://tronche.com/gui/x/xlib/events/keyboard-pointer/keyboard-pointer.html says that 0x10 is numlock. So that would explain things
20:08:10 <lambdabot> Title: Xlib Programming Manual: Keyboard and Pointer Events, http://tinyurl.com/ypez6o
20:08:12 <mightybyte> TSC: Excellent.  Thank you.
20:08:15 <chessguy> [succ a]
20:08:21 * LoganCapaldo looks bewildered
20:08:33 <jcreigh> hmmm, xmonad probably should ignore numlock.
20:08:34 <encryptio> > iterate succ '\0'
20:08:35 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
20:08:56 <mightybyte> allbery_b: Thanks for putting up with my stupid questions while I'm learning.
20:09:00 <newsham> ?hoogle iterateM
20:09:01 <lambdabot> No matches found
20:09:19 <LoganCapaldo> oooh
20:09:25 <LoganCapaldo> @src iterate
20:09:25 <lambdabot> iterate f x =  x : iterate f (f x)
20:09:32 <mightybyte> Oops, that was supposed to start with "All:", not "allbery_b"
20:09:37 <LoganCapaldo> hmm
20:10:03 <jcreigh> SamB: rather, it says 0x10 is mod2, which Num_Lock is bound to on my system.
20:11:02 <mdmkolbe> newsham: Hmm, I've had a need for iterateM before.  Could you post what you have in mind so I can see if I was thinking the same thing?
20:11:12 <newsham> > let iterateM act val = do {x <- act val; xs <- iterateM act x; return (x:xs) } in iterateM (\x -> [succ x]) 'a'
20:11:15 <lambdabot>  Exception: stack overflow
20:11:31 <LoganCapaldo> @ty let iterateM f x = do { a <- x; return (a : iterateM f (f a)) } in iterateM
20:11:34 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
20:11:34 <lambdabot>       Expected type: t
20:11:57 <newsham> (a:) `fmap` iteratemM f (f a) ?
20:12:21 <LoganCapaldo> I'm not really sure what it should look like :)
20:12:46 <mdmkolbe> @ty let iterateM act val = do {x <- act val; xs <- iterateM act x; return (x:xs) } in iterateM
20:12:48 <lambdabot> forall t (t1 :: * -> *). (Monad t1) => (t -> t1 t) -> t -> t1 [t]
20:13:14 <LoganCapaldo> I guess somewhat like that :)
20:13:59 <encryptio> :t let iterateM f v = iterate (>>= . f) (return v)
20:14:00 <newsham> except the normal "iterate" also returns the arg as its first value
20:14:01 <lambdabot> parse error on input `.'
20:14:10 <encryptio> :t let iterateM f v = iterate (>>= f) (return v) in iterateM
20:14:12 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m a) -> a -> [m a]
20:14:19 <encryptio> eh, close
20:14:45 <encryptio> :t let iterateM f v = sequence $ iterate (>>= f) (return v) in iterateM
20:14:47 <LoganCapaldo> :t let iterateM f v = sequence $ iterate (>>= f) (return v) in iterateM
20:14:48 <lambdabot>     Ambiguous occurrence `sequence'
20:14:48 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
20:14:49 <lambdabot>     Ambiguous occurrence `sequence'
20:14:49 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
20:14:56 <LoganCapaldo> LOL
20:15:01 <encryptio> :t let iterateM f v = Prelude.sequence $ iterate (>>= f) (return v) in iterateM
20:15:04 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m a) -> a -> m [a]
20:15:45 <newsham> let iterateM f v = Prelude.sequence $ iterate (>>= f) return v) in iterateM (\x -> return [succ x]) 'a'
20:15:55 <newsham> > let iterateM f v = Prelude.sequence $ iterate (>>= f) return v) in iterateM (\x -> return [succ x]) 'a'
20:15:55 <lambdabot>  Parse error
20:16:01 <mdmkolbe> LoganCapaldo, newsham: I think that any iterateM that returns a m [a] would have problems with strictness because the modad would have to be completely evaluated before the first element could be removed
20:16:04 <encryptio> newsham: (return v)
20:16:12 <newsham> > let iterateM f v = Prelude.sequence $ iterate (>>= f) return v) in iterateM (\x -> [succ x]) 'a'
20:16:12 <lambdabot>  Parse error
20:16:18 <mdmkolbe> s/returns a m [a]/reutrns a "m [a]'/
20:16:39 <sorear> mdmkolbe: monads don't make things stricter
20:16:47 <newsham> > let iterateM f v = Prelude.sequence $ iterate (>>= f) (return v) in iterateM (\x -> [succ x]) 'a'
20:16:50 <lambdabot>  Exception: stack overflow
20:16:55 <encryptio> aww.
20:17:00 <sorear> @ty let repeatM a = liftM2 (:) a (repeatM a) in repeatM
20:17:03 <lambdabot> forall (m :: * -> *) a1. (Monad m) => m a1 -> m [a1]
20:17:31 <mdmkolbe> sorear: not always, but often.  Consider a state monad.  Evaluating the resulting state means that the entire list would have to be generated (which in this case would be an infinite list)
20:17:39 <sorear> > let repeatM a = liftM2 (:) a (repeatM a) in flip evalState 0 $ repeatM (do { x <- get ; put (x+1) ; return x}) -- mdmkolbe
20:17:40 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:17:59 <sorear> non strict monads are neat...
20:18:21 * mdmkolbe does a double take
20:18:57 <sorear> of course, this works precisely because I *don't* evaluate the resulting state.
20:19:06 <LoganCapaldo> Beware of sorears, for they are subtle and quick to anger
20:19:16 <sorear> this would never work with IO
20:19:31 <mdmkolbe> LoganCapaldo: is he crunchy when wet?
20:19:48 <mdmkolbe> :t evalState
20:19:49 <LoganCapaldo> I dunno
20:19:50 <lambdabot> forall s a. State s a -> s -> a
20:19:57 <mdmkolbe> :t runState
20:19:59 <lambdabot> forall s a. State s a -> s -> (a, s)
20:20:01 <LoganCapaldo> I've never seen a wet sorear
20:20:21 <LoganCapaldo> :t fst . runState
20:20:24 <lambdabot>     Couldn't match expected type `(a, b)'
20:20:24 <lambdabot>            against inferred type `s -> (a1, s)'
20:20:26 <sorear> I don't think anyone else here has ever seen one, period
20:20:33 <mdmkolbe> @src evalState
20:20:33 <lambdabot> Source not found. My pet ferret can type better than you!
20:20:51 <chessguy> :t fst . runState ?s
20:20:54 <lambdabot> forall a a1. (?s::State a a1) => a -> a1
20:21:19 <sorear> evalState (State action) initialstate = fst (action initialstate)
20:21:24 <sorear> @ty \evalState (State action) initialstate = fst (action initialstate)
20:21:26 <lambdabot> parse error on input `='
20:21:29 <sorear> @ty \evalState (State action) initialstate -> fst (action initialstate)
20:21:31 <lambdabot> forall t t1 t2. t -> State t1 t2 -> t1 -> t2
20:21:39 <sorear> beh, idiosyncracies...
20:21:42 <sorear> @ty \ (State action) initialstate -> fst (action initialstate)
20:21:45 <lambdabot> forall t t1. State t t1 -> t -> t1
20:22:17 <mdmkolbe> lambdabot needs to learn better insults.  they just make it look stoopid.  (Kind of a let down after GHC errors are so good at making the programer realize how much smarter the computer is than him/herself.)
20:22:41 <LoganCapaldo> GHC are like puzzles to solve
20:22:45 <LoganCapaldo> for me anyway
20:22:46 <chessguy> hermmm. does haskell not have the concept of infinity built into it?
20:22:54 <encryptio> "here's the error, find the problem."
20:22:58 <LoganCapaldo> at least lambdabot comes out you straight
20:22:59 <encryptio> > 1/0
20:23:00 <lambdabot>  Infinity
20:23:09 <LoganCapaldo> >1 / 0 :: Double
20:23:11 <chessguy> > 2 < Infinity
20:23:11 <lambdabot>   Not in scope: data constructor `Infinity'
20:23:21 <encryptio> > 1/0 :: Double
20:23:22 <lambdabot>  Infinity
20:23:24 <sorear> chessguy: infinite integers aren't supported, and it sucks
20:23:43 <encryptio> :t inf
20:23:45 <lambdabot> Not in scope: `inf'
20:23:47 <chessguy> sorear: i'm not so much looking for infinite integers as something that's greater than all integers
20:23:47 <encryptio> @hoogle inf
20:23:48 <lambdabot> Prelude.infix :: keyword
20:23:48 <lambdabot> Prelude.infixl :: keyword
20:23:48 <lambdabot> Prelude.infixr :: keyword
20:23:51 <sorear> chessguy: for instance it creates a false dichotomy between replicate n x and repeat x == replicate inf x
20:23:52 <mdmkolbe> LoganCapaldo, encryptio: yeah, but once you find the error, there was usually a very good reason for it complaining at you.  (Unlike some *ahem* other language implementation's error messages.)
20:24:35 <sorear> haskell is just too easy to get wrong in the first place :/
20:24:41 <encryptio> mdmkolbe: there's always a good reason for an error. it just might not show in the error message. ghc likes to take that to the max
20:24:46 <chessguy> ?src Num
20:24:46 <lambdabot> class  (Eq a, Show a) => Num a  where
20:24:47 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:24:47 <lambdabot>     negate, abs, signum     :: a -> a
20:24:47 <lambdabot>     fromInteger             :: Integer -> a
20:25:00 <LoganCapaldo> woah
20:25:07 <LoganCapaldo> you can have commas there?
20:25:17 <encryptio> in type definitions, sure
20:25:19 <chessguy> hmm, you could make data Infinity = Infinity an instance of Num
20:25:20 <nostrademons> yeah
20:25:33 <chessguy> ?src Eq
20:25:33 <lambdabot> class  Eq a  where
20:25:33 <LoganCapaldo> good to know
20:25:33 <lambdabot>     (==), (/=)   :: a -> a -> Bool
20:25:34 <sorear> chessguy: but it wouldn't be comparable with integers
20:25:49 <chessguy> hmm, good point
20:25:55 <LoganCapaldo> data Integer |= Infinity
20:25:57 <encryptio> chessguy: what about -Infinity, or 1/Infinity ? what do you do with those?
20:26:00 <LoganCapaldo> ;)
20:26:07 <sorear> Ideally, haskell would not have native integers ... instead we'd have data Nat = Z | S Nat
20:26:11 <fuzan> How would I convert from an Int64 to an Int ?
20:26:16 <sorear> or better yet, church naturals
20:26:19 <sorear> fromIntegral
20:26:20 <encryptio> :t fromIntegral
20:26:23 <lambdabot> forall a b. (Num b, Integral a) => a -> b
20:26:25 <ddarius> type InfiniteIntegers = Maybe Integer
20:26:28 <chessguy> -Infinity should be another datatype
20:26:29 <LoganCapaldo> @hoogle Int64 -> Int
20:26:30 <lambdabot> No matches, try a more general search
20:26:45 <bd_> encryptio: class PartialEq a => PartialOrd a where maybeCompare :: a -> a -> Maybe Ordering :)
20:26:47 <sorear> with proper numbers, infinity = fix Succ
20:26:49 <chessguy> @type 2
20:26:51 <lambdabot> forall t. (Num t) => t
20:26:55 <LoganCapaldo> > fromIntegral (2 :: Int64) :: Int
20:26:55 <encryptio> bd_: ugh
20:26:56 <lambdabot>  2
20:27:18 <chessguy> could i just make Infinity :: (Num t) => t somehow?
20:27:45 <LoganCapaldo> if you make it an instance of Num
20:28:00 <encryptio> chessguy: as long as you're able to define a value for any instance of Num.. which you can't (Integral a => a)
20:28:01 <LoganCapaldo> but it won't be the _same_ t as the 2
20:28:24 <chessguy> ?src Integral
20:28:24 <lambdabot> class  (Real a, Enum a) => Integral a  where
20:28:24 <lambdabot>     quot, rem, div, mod :: a -> a -> a
20:28:24 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
20:28:24 <lambdabot>     toInteger           :: a -> Integer
20:28:33 <chessguy> oh, that could be a problem
20:28:42 <encryptio> @instances Integral
20:28:43 <lambdabot> Int, Integer
20:29:05 <chessguy> bah. i just want something that i can compare any integer to and have it be <
20:29:16 <chessguy> (or >, in the case of -Infinity)
20:29:29 <encryptio> instance ... where compare = LT
20:29:46 <LoganCapaldo> @check (\x -> x < (maxBound :: Int))
20:29:48 <lambdabot>  OK, passed 500 tests.
20:29:57 <LoganCapaldo> :)
20:30:06 <LoganCapaldo> it must be true!
20:30:21 <mdmkolbe> > let x = maxBound in x < maxBound
20:30:21 <chessguy> encryptio: that doesn't help, because then it will be < itself, but not comparable to other types
20:30:22 <lambdabot>  Add a type signature
20:30:40 <LoganCapaldo> > maxBound :: Integer -- this so doesn't work anyway
20:30:40 <lambdabot>   add an instance declaration for (Bounded Integer)
20:30:40 <lambdabot>     In the expression: ma...
20:30:46 <mdmkolbe> > let x = maxBound :: Int in x < maxBound
20:30:47 <lambdabot>  False
20:31:34 <chessguy> (not to mention, it would be compare = const LT)
20:31:46 <LoganCapaldo> @scheck (\x -> x < (maxBound :: Int))
20:31:48 <lambdabot>   Completed 13 test(s) without failure.
20:31:53 <encryptio> :t const LT
20:31:56 <lambdabot> forall b. b -> Ordering
20:32:03 <encryptio> :t const $ const LT
20:32:05 <lambdabot> forall b b1. b -> b1 -> Ordering
20:32:12 <LoganCapaldo> I thought one of those did it exhaustively or something?
20:32:13 <encryptio> hmm.
20:32:16 <LoganCapaldo> I guess not
20:32:26 <mdmkolbe> are there any proposals for reworking Haskells number classes to be more mathematically sound?
20:33:02 <hyrax42> mdmkolbe: I think the issue is it would break too much code
20:33:19 <zbrown>  
20:33:27 <zbrown> zxcv m,./
20:33:33 <mdmkolbe> hyrax42: mheh.  just make a new module that people can import
20:33:34 <zbrown> DOH
20:33:39 <zbrown> cat got on the keyboard ;)
20:34:14 <chessguy> your cat isn't a very good typist
20:34:33 <zbrown> not particularly
20:34:36 <LoganCapaldo> chessguy: You're just not fluent in Cat
20:35:05 <ddarius> mdmkolbe: yes
20:35:14 <encryptio> GHC doesn't check "minimal complete definition" of instances of typeclasses, does it
20:35:23 <mdmkolbe> does arrow syntax support "let" like monadic do syntax supports "let"?  (Tried a guess and it didn't work, but maybe I have to spell it a special way.)
20:35:30 <ddarius> no it doesn't
20:35:45 <encryptio> ddarius: to who?
20:35:52 <LoganCapaldo> let is just sugar for lambdas anyway :)
20:35:57 <ddarius> you
20:36:17 <LoganCapaldo> let x = 1 in expr ==> (\x -> expr) 1 :)
20:36:29 <encryptio> @pl \x -> 1
20:36:29 <lambdabot> const 1
20:36:31 * LoganCapaldo lies thru his teeth
20:36:45 <sorear> quite easy, since ghc supports impredicative rank-2 polymorphism
20:36:47 <jcreigh> is there another way to lie I don't know about? :)
20:36:48 <mdmkolbe> LoganCapaldo: fixed point
20:36:51 <Pseudonym> Lying through your teeth is a very uncomfortable position to be in.
20:36:55 <sorear> be prepared to add type signatures!
20:37:30 <ddarius> And requires quite a bit of flexibility
20:37:48 <LoganCapaldo> I am pretty flexible
20:38:11 <Cale> http://programming.reddit.com/info/1bc2m/comments/c1bhjt?context=5 -- anyone want to check this for any errors?
20:38:14 <lambdabot> Title: How Not To Teach Recursion (reddit.com), http://tinyurl.com/255at5
20:38:18 <Pseudonym> For the benefit of the record, there is a key difference between lambda and let in Haskell.
20:38:24 <Pseudonym> Lambda bindings are monomorphic.
20:38:47 <Pseudonym> Let bindings may not be.
20:39:29 <mdmkolbe> Pseudonym: Good to know.  (Though monomorphism is the one word related to Haskell that I hate the most.)
20:39:30 <Pseudonym> See also "let-polymorphism".
20:39:40 <Pseudonym> Oh, yes.
20:42:00 <ddarius> monomorphism in lambda bindings is somewhat important
20:42:43 <sorear> For the benefit of the record, there is a key difference between GHC and Haskell.
20:42:57 <ddarius> now
20:43:05 <sorear> Lambda bindings are monomorphic in haskell.  They may not be in GHC
20:44:03 <mdmkolbe> I thought one of the major difference between Haskell and ML was that ML used let-polymorphism and Haskell used parametric polymorphism
20:44:10 <arke> greetings
20:44:21 <LoganCapaldo> Cale: Is that related to the matrix exponetation solution?
20:44:24 <SamB> no, ML has parametric polymorphism too...
20:44:25 <LoganCapaldo> it seems similar
20:44:30 <Cale> LoganCapaldo: absolutely
20:44:40 <TSC> Hello arke
20:44:57 <Cale> In fact, you can derive it from that, by keeping track of what's going on with the matrix entries.
20:45:13 <ddarius> Go SICP
20:45:54 <arke> i must be stupid ... how do i tell haskell that i want a function that takes an int and a list of ints, and returns a list of int?
20:46:02 <arke> or even just any number type
20:46:09 <sjanssen>  
20:46:11 <lokam> say i have a program that accepts input through getLine and then outputs a line. This program works fine on the shell, however when I try to use it with php using shell_exec( "echo $string|./rinr") i get no output
20:46:14 <mauke> foo :: (Num a) => a -> [a] -> [a]
20:46:15 <cdsmith> arke:  Num a => a -> [a] -> [a]
20:46:16 <ddarius> arke: You don't need to do anything.
20:46:16 <encryptio> fun :: Num a => a -> [a] -> [a]
20:46:26 <arke> oh
20:46:28 <cdsmith> Wow, all three of us!
20:46:28 <arke> aaah
20:46:32 <arke> hehe
20:46:33 <arke> thanks :D
20:46:33 <mauke> STEREO
20:46:37 <sorear> ACTUALLY,
20:46:42 <arke> silly me
20:46:44 <sorear> Int -> [Int] -> Int
20:46:45 <SamB> TRIPLICO!
20:46:53 * arke keeps forgetting the => thing
20:46:57 <sorear> er, Int -> [Int] -> [Int]
20:47:03 <mauke> lokam: does shell_exec("echo $string | cat") work?
20:47:10 <sorear> but Num a => a -> [a] -> [a] is probably better
20:47:24 <cdsmith> sorear: he said "or even just any number type"
20:47:28 <lokam> mauke: yep
20:47:29 <SamB> sorear: he said "or even just any number type"
20:47:32 <arke> sorear: actually, that isnt working :/ (the Int -> [Int] i mean)
20:47:36 <SamB> woo, stereo
20:47:43 <SamB> again
20:47:48 <Cale> hehe
20:47:51 <arke> but it seems like its just my mistake
20:47:52 <arke> yeah
20:47:54 <arke> it is :)
20:48:01 * SamB was scrolled up to copy what he'd said exactly ;-)
20:48:29 <lokam> i hava putStrLn output in my haskell file, maybe i have to modify the buffer settings?
20:49:43 <chessguy> hmm, this is a little unsettling. i'm suddenly seeing typeclasses everywhere i look
20:49:43 <SamB> @hoogle flush
20:49:44 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
20:49:44 <lambdabot> System.Win32.File.flushFileBuffers :: HANDLE -> IO ()
20:49:44 <lambdabot> IO.hFlush :: Handle -> IO ()
20:49:52 <mauke> lokam: unlikely
20:50:06 <LoganCapaldo> chessguy: Don't go to sleep.
20:50:12 <LoganCapaldo> You'll have dreams about em
20:50:16 <SamB> hmm.
20:50:20 <chessguy> @quote dream
20:50:21 <lambdabot> dons says: I had a dream about how to write instance Binary Integer last night
20:50:28 <SamB> chessguy: only just now you are doing this?
20:50:38 <SamB> oh.
20:50:44 <SamB> you mean when you are asleep too?
20:50:54 * LoganCapaldo has had dreams in Forth
20:50:58 <chessguy> no, i mean when i'm awake
20:50:59 * SamB is often seeing them in langauges that haven't got those
20:51:04 <SamB> LoganCapaldo: I'm glad I am not you
20:51:07 <LoganCapaldo> which is odd
20:51:18 <SamB> LoganCapaldo: why, don't you know forth?
20:51:32 <LoganCapaldo> I know the basics
20:51:36 <SamB> oh.
20:51:39 <lokam> mauke: so what do you think it might be?
20:51:40 <encryptio> i've dreampt Perl before
20:51:43 <LoganCapaldo> Never used it in anger
20:51:43 <SamB> and they are not nightmares?
20:51:45 <mauke> I've had BASIC dreams
20:51:52 <mauke> about a console minesweeper
20:51:55 * SamB doesn't think he can dream in a programming language properly
20:52:01 <encryptio> but the way i'm going i'll have way more haskell dreams
20:52:04 <SamB> I can't even dream in written english
20:52:05 <mauke> lokam: no idea
20:52:07 <chessguy> it is wierd, i've known what typeclasses were for weeks or months. but suddenly in the last couple days, they're everwhere
20:52:10 <arke> DUP OVER SWAP NIP TUCK ... aagh :D
20:52:22 <SamB> whenever I go back to reread bits, they are different from what they were before
20:52:37 <encryptio> SamB: that's how i tell i'm in a dream, actually
20:52:45 <SamB> hmm
20:52:58 <encryptio> once i know, it's a lucid dream. then i stop programming and do more interesting things.
20:53:05 <SamB> I think I do not have a systematic way to tell
20:53:22 <SamB> I never try to program in dreams, afaik
20:53:22 <chessguy> @quote dream
20:53:23 <lambdabot> therp says: good morning. I think I have been dreaming of shift/reset continuations...
20:53:49 <SamB> though once I had one that had a computer running windows 98 in it... I think it was a flat panel mounted in/on a wall
20:54:00 <LoganCapaldo> Did he say that twice though?
20:54:07 <SamB> (I think the computer I was using at the time ran windows 95)
20:54:21 <chessguy> @quote dream
20:54:22 <lambdabot> lispy says: I just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
20:54:26 <encryptio> lol
20:54:27 <SamB> (also I think it was only nominally windows 98)
20:54:48 * LoganCapaldo tries to imagine a list comprehension and the snooze button
20:54:56 <LoganCapaldo> was it a monadic alarm clock?
20:55:06 <LoganCapaldo> Oh! that reminds me
20:55:11 <LoganCapaldo> category theory
20:55:21 <LoganCapaldo> a*b* is a category!
20:55:25 <LoganCapaldo> I'm pretty sure
20:55:28 <LoganCapaldo> anyway
20:56:03 * LoganCapaldo waits for someone to demonstrate how he is wrong
20:56:05 * SamB goes to watch anime...
20:58:13 <arke> hm, next question
20:58:20 <chessguy> i wonder if this is the first step to thinking in monads
20:58:34 <arke> blah :: [(Int, Int)] -> whatever
20:58:38 <LoganCapaldo> Seeing typeclasses everywhere?
20:58:44 <jcreigh> when dealing with various types of ints (Int32 vs. Int, for example), is there something magic you can do to prevent having fromIntegral all over the place?
20:59:45 <mauke> yay, recompiling ghc
21:00:10 <arke> whats the correct pattern matching syntax to extract the items of the tuple from the head of the list?
21:00:28 <mauke> blah ((a, b) : _)
21:00:35 <LoganCapaldo> ((x, y):xs)
21:00:42 <arke> ah, i was right, whee
21:00:43 <arke> thanks
21:01:00 <chessguy> or blah a@(b@(c,d) : _)
21:01:24 <ddarius> a*b* is hardly the complete definition of a category
21:01:26 <chessguy> depending on exactly what you want to bind
21:01:44 <LoganCapaldo> > (\a@b@c@d@1 -> a + b + c + d) 1
21:01:45 <lambdabot>  4
21:02:08 <dmead> ?losers
21:02:08 <lambdabot> Maximum users seen in #haskell: 336, currently: 299 (89.0%), active: 47 (15.7%)
21:02:21 <mauke> @shapr dmead
21:02:21 <lambdabot> why on earth would I slap dmead
21:02:22 <LoganCapaldo> heh
21:02:32 <dmead> :P
21:02:33 <ddarius> LoganCapaldo: Wow, I didn't even know that was syntactically valid (though why I'd ever even try...)
21:02:50 <LoganCapaldo> ddarius: I was thinking of the associated FSM
21:03:00 <mauke> flying spaghetti monster?
21:03:03 <dmead> flying spaghetti monster?
21:03:10 <LoganCapaldo> with states being the objects and transistions being the morphisms
21:03:11 <dmead> :]
21:03:19 <Pseudonym> This channel has been touched by His Noodly Appendage!
21:03:20 <jcreigh> finite state machine? :)
21:03:21 <mauke> s t e r e o
21:03:21 <chessguy> finite-state machine :)
21:03:37 <dmead> oh, right... computer science
21:03:40 <dmead> gotcha
21:03:40 <chessguy> wtf, everyone's saying things in stero tonight
21:03:46 <chessguy> *stereo
21:03:51 <Pseudonym> Clearly this deserves greater study.  Or at least a side-order of bruschetta.
21:03:59 <dmead> mmmm
21:04:01 <jcreigh> wtf, everyone's saying things in stereo tonight
21:04:13 <dmead> wtf, everyone's saying things in stereo tonight
21:04:31 <dmead> > "wtf, everyone's saying things in stereo tonight"
21:04:32 <lambdabot>  "wtf, everyone's saying things in stereo tonight"
21:04:48 <lambdabot> wtf, everyone's saying things in stereo tonight
21:04:50 <emu> > fix ("wtf, everyone's saying things repeatedly":)
21:04:52 <lambdabot>  ["wtf, everyone's saying things repeatedly","wtf, everyone's saying things r...
21:05:03 <ddarius> LoganCapaldo: More or less yes it is.
21:05:05 <LoganCapaldo> stereomorphism restriction?
21:05:15 <lambdabot> Did you expect a different answer by repeating yourself?
21:05:17 <dmead> > let loltime =  "wtf, everyone's saying things in stereo tonight"
21:05:17 <lambdabot>  Parse error
21:05:18 <chessguy> ?vera FSM
21:05:19 <dmead> > let loltime =  "wtf, everyone's saying things in stereo tonight";;
21:05:20 <lambdabot>  Parse error
21:05:21 <mdmkolbe> > let - = 1 in -
21:05:21 <lambdabot>  Parse error
21:05:23 <lambdabot> *** "fsm" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
21:05:23 <lambdabot> FSM
21:05:23 <lambdabot>      Finite State Machine (TTCN, ...)
21:05:23 <lambdabot>  
21:05:24 <lambdabot> *** "fsm" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
21:05:26 <lambdabot> [3 @more lines]
21:05:34 <mauke> dmead: this is not OCaml
21:05:43 <dmead> woops
21:05:58 <dmead> > let x =  "wtf, everyone's saying things in stereo tonight"
21:05:59 <lambdabot>  Parse error
21:06:04 <dmead> wheres my parse error =/
21:06:06 <emu> in
21:06:08 <dmead> ah
21:06:17 <mdmkolbe> > :-J
21:06:17 * emu waits
21:06:17 <lambdabot>  Parse error
21:06:27 <dmead> > let x =  "wtf, everyone's saying things in stereo tonight" in reverse x
21:06:28 <lambdabot>  "thginot oerets ni sgniht gniyas s'enoyreve ,ftw"
21:06:34 <dmead> ftw!
21:06:38 * lambdabot groans under the pressure
21:06:48 <lambdabot> I only have 16 CPUs, you know.
21:06:52 <fuzan> what would be a elegant method for casting a [Char8] to an integer? not sure how to work around the typing with my limited prelude knowledge :\
21:06:58 <sjanssen> oerets ftw!
21:07:08 <sjanssen> fuzan: read
21:07:08 <chessguy> > length [1..]
21:07:09 <LoganCapaldo> @hoogle Char8 -> Int
21:07:10 <lambdabot> No matches, try a more general search
21:07:10 <emu> fuzan: ord?
21:07:11 <chessguy> muahaha
21:07:12 <lambdabot> Terminated
21:07:15 <sjanssen> > read "123" :: Integer
21:07:16 <lambdabot>  123
21:07:19 <fuzan> ugh
21:07:22 <dmead> fuzan: how do you mean?
21:07:22 <mdmkolbe> > :[#]
21:07:23 <lambdabot>  Parse error
21:07:26 <sjanssen> fuzan: we call this parsing, not casting
21:07:29 <LoganCapaldo> @hoogle (Num a) => Char8 -> a
21:07:29 <lambdabot> No matches, try a more general search
21:07:36 <jcreigh> fuzan: fromEnum, perhaps?
21:07:42 <emu> aye, casting made me think of ord
21:07:42 <jcreigh> > fromEnum 'A'
21:07:43 <lambdabot>  65
21:07:46 <Pseudonym> @type read . fromIntegral
21:07:48 <emu> or enums
21:07:49 <lambdabot>     No instance for (Num String)
21:07:49 <lambdabot>       arising from use of `fromIntegral' at <interactive>:1:7-18
21:07:56 <Pseudonym> @type read . map fromIntegral
21:07:58 * LoganCapaldo continues to bark up the wrong tree
21:07:58 <lambdabot>     No instance for (Num Char)
21:07:59 <lambdabot>       arising from use of `fromIntegral' at <interactive>:1:11-22
21:08:00 <sjanssen> fuzan: oh, you want to treat a bunch of bytes as a number, eh?
21:08:04 <Pseudonym> Hmm.
21:08:05 <jcreigh> fuzan: assuming Char8 is an instance of Enum, which it should be.
21:08:05 <fuzan> sjanssen: yes.
21:08:15 <dmead> the raw bits
21:08:16 <sjanssen> fuzan: big or little endian?
21:08:16 <mauke> > foldl' (\z x -> z * 256 + ord x) 0 "\1\2\3"
21:08:17 <lambdabot>  66051
21:08:20 <fuzan> little.
21:08:20 <dmead> or like
21:08:22 <jcreigh> oh, wait, sorry, I misunderstood as well.
21:08:23 <dmead> "123456"
21:08:31 <fuzan> ie, c code
21:08:32 <Pseudonym> @type read . map (ord.fromIntegral)
21:08:34 <lambdabot>     Couldn't match expected type `Char' against inferred type `Int'
21:08:35 <lambdabot>       Expected type: [a] -> String
21:08:39 <Pseudonym> @type read . map (chr.fromIntegral)
21:08:42 <lambdabot> forall a a1. (Read a, Integral a1) => [a1] -> a
21:08:44 <Pseudonym> Woo!
21:08:44 <Pseudonym> Done.
21:08:48 <fuzan> char *x; .. ; (int)x;
21:09:01 <dmead> isn't there a section in the std library
21:09:05 <mauke> fuzan: you mean char *x; ... int i; memcpy(&i, x, sizeof i);
21:09:06 <dmead> "converting to and from strings"
21:09:15 <sjanssen> fuzan: that C will work differently depending on your architecture
21:09:25 <dmead> use character stream in c++
21:09:27 <dmead> instead
21:09:29 <fuzan> mauke: no. i know my string is only 4 bytes.
21:09:35 <mauke> fuzan: irrelevant
21:09:46 <dmead> atoi(somestuff)
21:10:04 <fuzan> mauke: not really.
21:10:12 <mauke> fuzan: yes, really
21:10:20 <fuzan> mauke: 4 bytes from the beggining of the char pointer is all I want.
21:10:26 <mauke> alignment is important
21:10:26 <fuzan> hence, (int)x;
21:10:35 <mauke> no, that casts the pointer itself
21:10:37 <LoganCapaldo> union { char s[4]; int d; } x; x.s = { '1', '2', '3', '4' }; x.d // I like to be different
21:10:41 <sjanssen> fuzan: you also need to dereference that x
21:10:43 <mdmkolbe> fuzan: char *x; ...; *(int*)x; will work differently depending on endan-ness and how large an int actually is
21:10:50 <mauke> AND ALIGNMENT
21:11:07 <mauke> *(int *)x can crash
21:11:52 * mdmkolbe aligns with mauke
21:11:54 <fuzan> i got you :)
21:12:04 <mauke> unsigned char a[4]; a[0] + a[1] * 256 + a[2] * 256 * 256 + a[3] * 256 * 256 * 256
21:12:07 <sjanssen> @type \xs -> sum $ zipWith (*) xs $ iterate (*2) 1
21:12:08 <mauke> there, always works
21:12:09 <lambdabot> forall a. (Num a) => [a] -> a
21:12:14 <fuzan> mauke: you be right.
21:12:16 <sjanssen> fuzan: ^^^
21:12:31 <LoganCapaldo> (unsafeCoerce :: [Char8] -> Int) "abcd"
21:12:47 <LoganCapaldo> is obviously how to do it
21:12:48 <Cale> haha, I don't think so
21:12:49 <mdmkolbe> :t unsafeCoerce
21:12:51 <lambdabot> Not in scope: `unsafeCoerce'
21:13:07 <sjanssen> oops, my code is wrong
21:13:27 <mdmkolbe> sjanssen: did you mean (*256)?
21:13:29 <sjanssen> @type \base xs -> sum $ zipWith (*) xs $ iterate (*base) 1 -- parametric wrt base
21:13:31 <lambdabot> forall a. (Num a) => a -> [a] -> a
21:13:36 <LoganCapaldo> :t GHC.Prim.unsafeCoerce#
21:13:37 <Pseudonym> BTW, you should probably use Word32 instead of Int here.
21:13:38 <lambdabot> forall t b. t -> b
21:13:43 <sjanssen> mdmkolbe: correct
21:13:55 <fuzan> Pseudonym: I am using Word32 :)
21:13:56 <mdmkolbe> sjanssen: but I don't think there is a Num Char instance
21:14:00 <sjanssen> and you should use Word8 instead of Char
21:14:01 <Pseudonym> Haskell doesn't guarantee a large Int range.
21:14:09 <mauke> sjanssen: foldl' (\z x -> z * 256 + ord x) 0 ?
21:14:35 <sjanssen> mauke: equivalent
21:14:42 <Pseudonym> @type foldl' (\z x -> (z `shift` 8) + fromIntegral x) 0
21:14:44 <lambdabot> forall a b. (Integral b, Bits a) => [b] -> a
21:16:03 <LoganCapaldo> @instances Bits
21:16:04 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
21:16:16 <jcreigh> sjanssen: I'm thinking we should change the type of getScreenInfo in Xinerama to Display -> IO [Rectangle]
21:16:41 <jcreigh> sjanssen: you wouldn't have to do as much fromIntegral casting when calling other X11 functions then.
21:16:44 <jcreigh> sjanssen: thoughts?
21:17:59 <hpaste>  siti annotated "(no title)" with "(no title)" at http://hpaste.org/1042#a6
21:18:13 <sjanssen> jcreigh: sounds appropriate
21:18:37 <siti> sorry about no title, but why does my small example consume massive amounts of memory >700MB?
21:19:45 <sjanssen> siti: try using insertWith'
21:20:20 <sjanssen> siti: I think your program is building giant thunks in the value part of the map
21:20:27 <jcreigh> cool. I'm really liking having moved the getScreenInfo function into the Xinerama lib now. We can have the raw wrapper, which they can use if they really want, and the one, simple, always-works, "Xinerama as it should have been" function.
21:20:46 <siti> sjanssen: yeah, that seems to have worked cheers!
21:20:51 <steven_ashley> :)
21:22:27 <jcreigh> (also, I started to look at tiling a little, and I realized that it will be handy to pass Rectangles around, so this will make that easier too)
21:22:45 <sjanssen> jcreigh: I'm reworking the StackSet structure right now
21:22:59 <jcreigh> oh, okay.
21:23:00 <sjanssen> should be done before I go to bed
21:23:20 <jcreigh> I won't try to do anything in parallel with you, then, aside from the simple datatype change.
21:25:05 * LoganCapaldo performs a natural transformation into his bed
21:29:27 <yshhq> @hoogle sort
21:29:27 <lambdabot> List.sort :: Ord a => [a] -> [a]
21:29:27 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
21:29:27 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
21:29:34 <yshhq> @hoogle qsort
21:29:34 <lambdabot> No matches found
21:29:38 <yshhq> @hoogle quicksort
21:29:39 <lambdabot> No matches found
21:29:44 <yshhq> @hoogle mergesort
21:29:44 <lambdabot> No matches found
21:30:16 <sjanssen> yshhq: Data.List.sort
21:30:23 <sjanssen> it is a merge sort
21:30:34 <yshhq> oh
21:30:52 <sjanssen> > sort "yshhq"
21:30:53 <lambdabot>  "hhqsy"
21:31:07 <yshhq> why doesn't ghc install .hs files as hugs?
21:31:22 <yshhq> they are not always same, right?
21:31:32 <sjanssen> huh?
21:31:57 <yshhq> i use gentoo and install both ghc and hugs
21:32:20 <yshhq> hugs installs .hs files, so I can read their function definitions.
21:32:30 <sjanssen> since GHC is a compiler, it just installs the machine code for those functions
21:32:59 <kc5tja> I'm curious -- is Haskell parsable with an LL grammar?
21:33:08 <sjanssen> hugs and ghc share a common code base, so most library functions have the same implementation
21:33:09 <yshhq> is there a quickway to check ghc implementation?
21:33:21 <dons> run the testsuite?
21:33:22 <emu> @src ghc
21:33:22 <lambdabot> Source not found. You speak an infinite deal of nothing
21:33:29 <dons> or just load up ghci and try a simple program
21:33:36 <yshhq> last time i saw hugs use strict sum, but not ghc.
21:33:44 <sjanssen> yshhq: http://darcs.haskell.org/packages/base/
21:33:45 <lambdabot> Title: Index of /packages/base
21:34:09 <dons> they share the same base library. though with fusion, ghc might end up using a slightly different implementation of say, sum. it should have identical semantics though
21:34:25 <sjanssen> @source Data.List
21:34:25 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
21:34:39 <sjanssen> yshhq: that is another useful lambdabot tool
21:35:01 <yshhq> cool
21:35:02 <yshhq> 3x
21:35:19 <emu> > repeat Nothing
21:35:20 <lambdabot>  [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Not...
21:35:41 <mauke> > don't cry
21:35:41 <lambdabot>   Not in scope: `cry'
21:35:42 <emu> > don't repeat anything
21:35:43 <lambdabot>   Not in scope: `anything'
21:35:47 <bd_> > sequenceM . repeat $ Nothing
21:35:48 <lambdabot>   Not in scope: `sequenceM'
21:35:51 <bd_> > sequence . repeat $ Nothing
21:35:53 <kc5tja> > repeat Just Nothing
21:35:53 <lambdabot>  Couldn't match expected type `Maybe a -> t'
21:36:00 <kc5tja> > repeat (Just Nothing)
21:36:01 <lambdabot>  [Just Nothing,Just Nothing,Just Nothing,Just Nothing,Just Nothing,Just Nothi...
21:36:09 <ddarius> > concat $ repeat []
21:36:11 <bd_> :t (sequence . repeat)
21:36:11 <LoganCapaldo> > repeat repeat
21:36:11 <lambdabot>  Exception: <<loop>>
21:36:12 <lambdabot>  Add a type signature
21:36:13 <lambdabot>     Ambiguous occurrence `sequence'
21:36:13 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
21:36:17 <bd_> :/
21:36:24 <mauke> :t Monad.sequence . repeat
21:36:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
21:36:27 <emu> > repeat (Left Nothing)
21:36:29 <lambdabot>  [Left Nothing,Left Nothing,Left Nothing,Left Nothing,Left Nothing,Left Nothi...
21:36:55 <mauke> :t liftM repeat
21:36:57 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1]
21:37:01 <kc5tja> > repeat (Left Just Right Nothing)
21:37:02 <lambdabot>  Couldn't match expected type `(b -> Either a1 b) -> Maybe a2 -> a'
21:37:12 <kc5tja> > repeat (Left $ Just $ Right Nothing)
21:37:13 <lambdabot>  [Left (Just (Right Nothing)),Left (Just (Right Nothing)),Left (Just (Right N...
21:37:15 <yshhq> @src sum
21:37:15 <lambdabot> sum = foldl (+) 0
21:37:20 <yshhq> @source sum
21:37:20 <lambdabot> sum not available
21:38:42 <kc5tja> @source Ponies
21:38:42 <lambdabot> Ponies not available
21:39:04 <kc5tja> > let m = do putStr "NOT Yours!" in m
21:39:05 <lambdabot>  <IO ()>
21:39:08 <kc5tja> doh
21:39:10 <kc5tja> Oh well.
21:39:11 <kc5tja> I'm off to bed.
21:53:01 <jcreigh> hmm, is anyone else annoyed by the lack of line-editing when entering a patch name in darcs?
21:53:58 <sjanssen> jcreigh: yes
21:54:04 <johnnowak> jcreigh: i usually just hit keys and press enter and say i want a long description so i can edit in vim
21:54:19 <sjanssen> that's a nice trick
21:58:39 <jcreigh> sjanssen: I sent you patches to X11-extras and xmonad to change the type of getScreenInfo
21:59:09 <siti> how do I make Map.unionWith strict?
22:03:51 <dibblego> http://msdn.microsoft.com/vstudio/express/beginner/kids/ Haskell for Happy Maths!!
22:03:52 <lambdabot> Title: Beginner Developer Learning Center: Kids' Corner
22:04:02 <dibblego> s/Maths/Kids
22:04:55 <siti> VB for very bright kids :S
22:06:31 <arke> http://hpaste.org/1045
22:06:34 <arke> woo
22:06:59 <arke> sleep time
22:07:02 <arke> gbught
22:09:01 <sjanssen> jcreigh: aight
22:11:51 <dons> dibblego: ooh!
22:12:04 <dibblego> Java for Juveniles
22:12:05 <dibblego> :)
22:12:19 <dibblego> I think a "Haskell for Happy Kids" would be pretty cool
22:12:33 <dons> haskell for lazy kids?
22:12:54 <dibblego> I just had a pub conversation with someone who doesn't understand laziness
22:13:02 <dibblego> "so you just don't have to think about anything then?"
22:13:09 <dons> heh
22:13:12 <Pseudonym> The trouble is that most kids are not pure.
22:13:15 <dibblego> I suppose though, it could be true
22:14:07 <Pseudonym> The best explanation I got as an undergrad is that lazy evaluation is the undergrad evaluation strategy.
22:14:13 <dons> audreyt++ uploading packages to hackage!
22:14:20 <dons> http://hackage.haskell.org/packages/archive/recent.html
22:14:25 <dons> hackage is really working, imo.
22:14:25 <Pseudonym> They don't do any work until output is demanded, and then only do as little work as possible to produce that output.
22:14:36 <dons> new things are appearing there i just wouldn't know how to get otherwise
22:14:44 <dibblego> I was talking to a Java programmer, trying to point out some things - I failed
22:15:32 <Pseudonym> dibblego: You bastard.  I bet the Java programmer had to propagate the failure right up the call tree, too.
22:15:46 <dibblego> I wonder what a good intro to laziness for Java et. al. would look like
22:15:59 <dibblego> Pseudonym, actually, that statement is a pretty good summarisation of our conversation :)
22:17:00 <lokam> is there an easy way to get the date?
22:17:08 <dons> ?hoogle time
22:17:08 <lambdabot> System.Time :: module
22:17:08 <lambdabot> Time :: module
22:17:08 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
22:17:09 <Pseudonym> lokam: Just ask her.
22:17:11 <dons> ?hoogle date
22:17:11 <lambdabot> System.Locale.dateFmt :: TimeLocale -> String
22:17:11 <lambdabot> System.Locale.dateTimeFmt :: TimeLocale -> String
22:17:11 <lambdabot> Data.HashTable.update :: HashTable key val -> key -> val -> IO Bool
22:17:12 <dibblego> I use a calenda
22:17:13 <dibblego> r
22:17:39 <lokam> ?hoogle calendar
22:17:40 <lambdabot> Time.calendarTimeToString :: CalendarTime -> String
22:17:40 <lambdabot> System.Time.CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
22:17:40 <lambdabot> System.Time.CalendarTime :: data CalendarTime
22:18:12 <ClaudiusMaximus> @hoogle IO CalendarTime
22:18:13 <lambdabot> Time.toCalendarTime :: ClockTime -> IO CalendarTime
22:18:17 <sjanssen> dons: we need an RSS feed of hackage posts
22:18:29 <Pseudonym> ?hoogle getClockTime
22:18:29 <lambdabot> Time.getClockTime :: IO ClockTime
22:18:33 <Pseudonym> ?hoogle toCalendarTime
22:18:33 <lambdabot> Time.toCalendarTime :: ClockTime -> IO CalendarTime
22:18:59 <Pseudonym> I think that's what you want.
22:19:02 <Pseudonym> ?src CalendarTime
22:19:02 <lambdabot> Source not found. That's something I cannot allow to happen.
22:19:08 <Pseudonym> ?src Time.CalendarTime
22:19:08 <lambdabot> Source not found. The more you drive -- the dumber you get.
22:19:18 <Pseudonym> ?hoogle CalendarTime
22:19:19 <lambdabot> System.Time.CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
22:19:19 <lambdabot> System.Time.CalendarTime :: data CalendarTime
22:19:19 <lambdabot> Time.calendarTimeToString :: CalendarTime -> String
22:19:47 <lokam> kk i go try it out
22:19:58 <Pseudonym> lokam: http://haskell.org/onlinereport/time.html
22:19:59 <lambdabot> Title: The Haskell 98 Library Report: Dates and Times
22:20:19 <dons> sjanssen: we do, but i've not been able to use it :-)
22:20:38 <Pseudonym> Not until someone uploads RSS, anyway.
22:21:23 <sjanssen> dons: so it does!
22:21:25 <dons> sjanssen: http://hackage.haskell.org/packages/archive/recent.rss
22:21:30 <dons> ?where+ hackage-rss http://hackage.haskell.org/packages/archive/recent.rss
22:21:31 <lambdabot> Done.
22:21:37 <mauke> ohi stage2
22:22:14 <sjanssen> dons: works fine for me
22:23:15 <sjanssen> dons, jcreigh: the first step towards tiling (refactor of StackSet) is in the repo
22:24:05 <dons> ?where+ strict http://www.cse.unsw.edu.au/~dons/code/strict/
22:24:05 <lambdabot> Done.
22:24:14 <dons> strict data types for all, http://www.cse.unsw.edu.au/~dons/strict/
22:24:23 <dibblego> nice one
22:25:15 <dibblego> does a ! in a data constructor argument bring that argument to WHNF?
22:25:26 <sjanssen> dibblego: yes
22:25:32 <siti> WHNF?
22:25:45 <dibblego> Weak Head Normal Form
22:25:56 <jcreigh> sjanssen: excellent. one step closer to world domination.
22:25:58 <sjanssen> siti: weak head normal form -- means something is evaluated enough to see the constructor
22:26:06 <siti> ok
22:26:20 <dibblego> so if I have a list made up of lots and lots of thunking, then I have a data Foo = Foo ![a], all those thunks are evaluated?
22:26:40 <sjanssen> dibblego: only the first cons cell is evaluated
22:26:51 <dibblego> oh
22:26:59 <sjanssen> a spine strict list looks like: data List a = Nil | Cons a !(List a)
22:27:16 <sjanssen> totally strict: data List a = Nil | Cons !a !(List a)
22:27:46 <dibblego> ah right
22:28:05 <sjanssen> of course that list sucks for lazy programming
22:28:31 <sjanssen> now, do I finish tiling tonight, or do I sleep at a reasonable time?
22:28:39 <revence> And I am willing to kill for lazy eval.
22:28:43 <mauke> do it in your sleep
22:29:47 <dons> sjanssen: you'll write better code if you sleep now, and do it in the morning
22:29:51 <dons> at least i do
22:30:42 <dibblego> given, data MyList a = Nil | Cons !a !(MyList a) how could you write a function [a] -> MyList a so that it is strict?
22:30:46 * revence : IRC.getFellas >>= mapM (\x -> return $ "Hi, " ++ x ++ "!")
22:31:27 <dibblego> since, wouldn't any function be lazy?
22:31:30 <mauke> foldr Cons Nil
22:31:34 <sjanssen> dibblego: toMyList = foldr Cons Nil
22:31:40 <sjanssen> @quote stereo
22:31:40 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
22:31:44 <dibblego> ah of course
22:32:09 <revence> @google unix monad shell
22:32:10 <lambdabot> http://en.wikipedia.org/wiki/Windows_PowerShell
22:32:10 <lambdabot> Title: Windows PowerShell - Wikipedia, the free encyclopedia
22:32:26 <revence> @google unix monad shell -windows
22:32:28 <lambdabot> http://okmij.org/ftp/Computation/monadic-shell.html
22:32:28 <lambdabot> Title: UNIX pipes as IO monads
22:32:50 <revence> Thanks, lambdabot!
22:32:53 <revence> :oD
22:39:15 <sjanssen> dons, jcreigh: which one of you added all these tabs in xmonad?
22:39:21 <dons> not me.
22:39:26 <dons> my tabs are highlighted in red
22:39:34 <fuzan> z2~/quit
22:39:35 <dons> darcs blame -regex '\t'
22:39:36 <dons> ;-)
22:43:12 <sjanssen> @tell jcreigh please don't use tabs in xmonad :)
22:43:12 <lambdabot> Consider it noted.
22:45:32 <kfish> ooh, a tabbed window manager?
22:46:47 <sjanssen> kfish: nope, I'm whining about \t in the source
22:47:22 <sjanssen> but xmonad should be a tiled window manager within the hour
22:47:22 <kfish> ah, heh :-)
22:53:21 <dons> sjanssen: ghc has -Wtabs now
22:53:29 <dons> ah, only in the head i think
22:53:58 <ClaudiusMaximus> does ghc-6.6 support shared runtime?  my binary compiled with ghc-6.4.2 is 10MB, which is a bit excessive, given that it's a plugin for another app, and given that it also requires ghc at runtime...
22:59:45 <dons> the runtime is only 200k though
22:59:52 <dons> 10M implies you've not got split object libraries
23:06:29 <jdrake> If capital letter at the beginning means a type, then what is the story behind True and False?
23:06:52 <siti> data Bool = True | False ?
23:06:52 <ClaudiusMaximus> ok, i don't know what that means exactly, but i do have 126-odd files in /usr/lib/ghc-6.4.2 ...
23:07:06 <Pseudonym> I think it's actually False | True
23:07:12 <siti> true :p
23:07:12 <Pseudonym> That's important for the Enum instance.
23:07:16 <siti> yep
23:08:03 * jdrake is a beginner, data Bool is not 100% understood, although general idea from ocaml is.
23:09:10 <ClaudiusMaximus> @src Maybe
23:09:10 <lambdabot> data Maybe a = Nothing | Just a
23:09:18 <ClaudiusMaximus> @src Either
23:09:18 <lambdabot> Source not found. Take a stress pill and think things over.
23:10:52 <ClaudiusMaximus> data Either a b = Left a | Right b  -- iirc
23:11:23 <jdrake> @src not
23:11:23 <lambdabot> not True   =  False
23:11:23 <lambdabot> not False  =  True
23:11:29 <dibblego> @src Data.Either
23:11:29 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:11:59 <jdrake> Isn't @src a good DOS exploit?
23:14:55 <ClaudiusMaximus> @src Data.Either.Either
23:14:55 <lambdabot> Source not found. stty: unknown mode: doofus
23:37:32 <Pseudonym> http://www.theregister.co.uk/2007/03/19/victorias_finest/
23:37:44 <Pseudonym> Amusing though the story is, it's the Bootnote that I found the funniest.
23:39:18 <Pseudonym> Given that Tom does appear on haskell-cafe every now and then.
23:41:42 <Pseudonym> Nytol!
23:41:59 <dolio> @hoogle intercalate
23:41:59 <lambdabot> No matches found
23:42:15 <dons> its in Data.List
23:42:23 <dons> intercalate x xs = concat (intersperse x xs)
23:55:34 <dolio> So, I have a program that leaks space (apparently) when compiled, but works in ghci. :)
23:56:34 <Cale> That's interesting.
23:56:48 <Cale> Maybe too much CSE?
23:59:37 <dons> ghc -O2 --?
23:59:40 <sjanssen> hmm, tiling is really confusing without window borders
