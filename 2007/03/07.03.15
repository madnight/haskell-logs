00:00:01 * ddarius never wonders if he is insane.  Ahh, the joys of already being insane.
00:06:05 <kc5tja> But, if you're insane, can you truely be sure that you're insane?  What if YOU'RE sane, but everyone else isn't?
00:06:59 <nmessenger> that would be INSANE!
00:07:24 <ivanm> catch 22
00:07:46 <nmessenger> type error: 22 is not an IO action :P
00:08:15 <kzm> that would be undefined?
00:23:48 <kc5tja> It's time for me to return _|_ and get to bed.
00:23:59 <kc5tja> It looks like darcs 1.0.9 is compiling nicely on its own.
00:24:07 <kc5tja> But, it's taking to long for me to babysit.
00:24:19 <kc5tja> night
00:26:27 <araujo> hello
00:26:35 <araujo> @yarr!
00:26:35 <lambdabot> Well Ahoy! thar.
00:26:39 <araujo> :-)
00:26:41 <ivanm> araujo!!!
00:26:46 <araujo> hola ivanm !
00:27:00 <ivanm> hola cola?
00:32:46 <Korollary> Isn't is possible to implement Integral methods with Float? Why isn't Float an instance then?
00:36:24 <nmessenger> Korollary: I guess since toInteger isn't unique, it's safer if you explicitly choose which of round, ceiling, floor, and truncate to use.
00:36:58 <dons> ?instances Integral
00:36:59 <lambdabot> Int, Integer
00:37:03 <dons> ?instances Num
00:37:04 <lambdabot> Double, Float, Int, Integer
00:37:07 <dons> ?src Integra
00:37:07 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
00:37:09 <dons> ?src Integral
00:37:09 <lambdabot> class  (Real a, Enum a) => Integral a  where
00:37:09 <lambdabot>     quot, rem, div, mod :: a -> a -> a
00:37:09 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
00:37:09 <lambdabot>     toInteger           :: a -> Integer
00:37:14 <nmessenger> also Real
00:42:40 <Korollary> nmessenger: I was rounding a Float into Int, but it occurred to me that if I needed a Float result instead then I would have to insert a fromIntegral.
00:43:01 <Korollary> No big deal anyway
00:45:26 <encryptio> @pl \x y -> (x == a) || (y == a)
00:45:26 <lambdabot> (. (a ==)) . (||) . (a ==)
00:45:26 <nmessenger> so you wish you had convenient (round, etc :: (RealFrac a, RealFrac b) => a -> b)?
00:45:36 <nmessenger> encryptio: looks like ((||) `on` (a ==)).  'on' is defined in ghc HEAD.
00:45:56 <nmessenger> on (!) f x y = f x ! f y
00:46:32 <encryptio> coo, what's the ! for?
00:46:40 <nmessenger> just a name binding
00:46:43 <kzm> dons: is it possible to "unslice" bytestrings on GC?
00:46:54 <nmessenger> on op f x y = f x `op` f y -- equivalent
00:47:10 <encryptio> oh. cool.
00:48:47 <dons> kzm, hard question!
00:48:57 <dons> kzm, we have the 'copy' function for this (to be used manually)
00:49:11 <kzm> Ah, right.
00:49:31 <kzm> Anyway, BS.Lazy reduces the maximum per string overhead, so it's not so bad, I guess.
00:49:39 <kzm> (I forget the chunk size)
00:51:26 <dons> yeah
00:53:26 <DRMacIver> Hm. Are there any Haskell libraries for dealing with RSS? (Both reading and serving ideally)
00:54:09 <dons> yeah, there are. lambdaFeed is one
00:54:14 <dons> check hackage.haskell.org first
00:54:23 <dons> then check haskell.org's 'libraries and applications' page
00:54:34 <dons> and there's lots of xml libs too, of course.
00:54:46 <dons> Cale even wrote a tutorial on writing rss aggregators
00:55:17 <DRMacIver> Ah, thanks.
00:55:51 <Cale> I did? :)
00:56:02 <Cale> I wrote a small RSS aggregator
00:59:26 <Cheery> hmm.
00:59:50 <Cheery> I think I just got an idea which would help people with nick completion.
01:00:53 <Cheery> most people type 3 first letters, configure the completion machine so that the last letter is the one in the end of nick.
01:02:26 <Cheery> hmm, thought that may not help. :P
01:02:38 <Cheery> Cheery <-> chessguy
01:04:48 <ivanm> lol
01:05:04 <ivanm> in xchat, it seems to be case sensitive...
01:05:23 <ivanm> oh wait, chessguy isn't online, so that's why it didn't work :s
01:05:30 <DRMacIver> In irssi it appears to be whim sensitive. :)
01:05:53 <DRMacIver> (The whim of the client that is, not the user. The latter would be far more useful)
01:06:25 <osfameron> irssi is software and by definition sucks
01:06:25 <ivanm> lol
01:06:37 <ivanm> osfameron: so why do you use a computer?
01:07:04 <DRMacIver> He uses an IRC client built entirely in hardware. :)
01:07:21 <DRMacIver> Changing his nickname requires him to hot swap one of the components.
01:07:30 <osfameron> actually, even traditional hardware sucks
01:07:41 <osfameron> I use a computer implemented using cellular components.  Mainly ants
01:07:42 <DRMacIver> Yes. Let us break free from the evil von neuman machine!
01:07:53 <osfameron> changing my nick merely involves bribing the queen ant with honey
01:07:58 <nmessenger> I'm not quite sure how "you shouldn't use software" follows from "all software sucks".  It may encourage it, but not imply.
01:08:41 <DRMacIver> In the same way "You shouldn't bash your head against the wall." follows from "Bashing my head against the wall hurts." I guess. ;)
01:08:48 <nmessenger> :D
01:08:53 <DRMacIver> And, on an entirely unrelated topic, I'm off to the gym. :)
01:09:20 <nmessenger> provided the other (usually implied) premise that "you should not do things that are painful"
01:09:41 <osfameron> the "all software sucks" meme is quite common among computer users
01:09:47 <osfameron> see also http://we.hates-software.com/
01:09:49 <lambdabot> Title: we hates software
01:10:05 <nmessenger> such bad grammar!
01:10:22 <Korollary> they-loves-tolkien.com
01:10:35 <osfameron> I had some entries under http://osfameron.hates-software.com/ but the older ones all got eaten (the mail archival system they use is hateful)
01:10:37 <lambdabot> Title: osfameron hates software
01:10:51 <Korollary> how ironic
01:11:24 <osfameron> yes, I laughed till I cried
01:11:32 <Korollary> don' be hatin'
01:11:33 <osfameron> actually, I swore till I got a sore throat
01:25:02 <malcolmw> good news.  haskell.org has been accepted for google summer of code again this year
01:28:31 <the_dormant> Hirvinen, I can't install plugins-1.0 on my macbook (using ghc-6.6), is this a known issue?
01:29:19 <the_dormant> sorry, I pressed the tab after Hi, got Hirvinen, this question was adressed to the channel
01:37:38 <malcolmw> the_dormant: dons might know
01:39:53 <the_dormant> AltData/Typeable.hs:450:0:
01:39:54 <the_dormant>     parse error (possibly incorrect indentation)
01:43:48 <the_dormant> dons, Does the hs-plugins lib run on macbook?
01:48:17 <earthy> that's very good news
02:01:44 <dons> woo!
02:01:45 <dons> Congratulations!
02:01:46 <dons> Your organization "Haskell.org" has been accepted in to the Google Summer of Code(tm) 2007
02:01:54 <dons> lambda party!!
02:02:09 <dons> the_dormant: it should do. with the darcs repo versoin
02:02:20 <dmwit> :t on
02:02:22 <lambdabot> Not in scope: `on'
02:02:32 <dons> full list is here, http://code.google.com/soc
02:02:33 <lambdabot> Title: Google Code - Summer of Code - Google Summer of Code
02:03:25 <dons> malcolmw: i see we're in business :-)
02:03:36 <malcolmw> hooray
02:03:45 <dons> http://code.google.com/soc
02:03:47 <lambdabot> Title: Google Code - Summer of Code - Google Summer of Code
02:03:48 <dons> full list
02:03:51 <malcolmw> no announcement yet on the google soc site
02:04:03 <malcolmw> oh has it appeared in the last 15 minutes?
02:04:05 <dons> yeah, its on code.google.com/soc though
02:04:07 <dons> just now
02:04:12 <kfish> rock, congrats
02:04:18 <dons> lambdas for all!
02:04:25 * dons `throwTo` dinner
02:06:56 <dons> malcolmw: so we should invite submissions soon then
02:07:40 * dons boggles at http://code.google.com/soc/parsec/about.html
02:07:41 <lambdabot> Title: Google Code - Summer of Code - Organization Information
02:07:46 <dons> don't they know parsec is taken!
02:07:59 <dons> "Thousand Parsec aims to be a framework for building space empire strategy games"
02:08:22 <kfish> perhaps they need some space empire combinators? perhaps a thousand of them?
02:11:07 <dmwit> Wow, there are a lot of possible projects for Haskell.org.
02:12:00 <dons> ?users
02:12:00 <lambdabot> Maximum users seen in #haskell: 336, currently: 288 (85.7%), active: 32 (11.1%)
02:12:29 <malcolmw> dons: feel free to email the cafe / edit the frontpage of haskell.org to advertise that we are open for business
02:13:00 <quicksilver> Has anyone written the typeclass Isomorphic a b ?
02:13:02 <dons> ok.
02:13:12 <dons> quicksilver: hmm, is that like NatTrans?
02:13:17 <dons> ah no, that's f a -> g b, iirc
02:13:49 <quicksilver> not sure. I'm thinking Isomorphic a b where lift :: a -> b; unlift :: b -> a
02:13:54 <dons> class (Functor f, Functor g) => NatTransf f g where
02:13:54 <dons>     eta :: f a -> g a
02:14:02 <dons> (old gofer class)
02:14:06 <quicksilver> then you get the very useful conj f = unlift . f . lift
02:14:11 <dons> class (Functor left, Functor right) => Adjoint left right where
02:14:11 <dons>     univ    :: (a -> right b) -> (left a -> b)
02:14:11 <dons>     unit    :: a -> right (left a)
02:14:11 <dons>     couniv  :: (left a -> b) -> (a -> right b)
02:14:11 <dons>     counit  :: left (right a) -> a
02:14:43 <quicksilver> A concrete example is instance Isomorphic Bytestring String where lift = pack; unlift = unpack
02:14:53 <quicksilver> which is exactly the one I wanted :)
02:15:04 <dons> yeah. we have this in Data.ByteString's testsuite:
02:15:27 <dons> instance Model P [Char] where model = PC.unpack
02:15:33 <dons> P = ByteString
02:15:36 <dons> class Model a b where
02:15:36 <dons>   model :: a -> b
02:15:48 <quicksilver> yes, it's like that only two-sided
02:15:49 <dons> instance (NatTrans m n, Model a b) => Model (m a) (n b) where model x = fmap model (eta x)
02:15:59 <quicksilver> your 'Model' is presumably 'injective hom'
02:16:01 <dons> right.
02:16:10 <quicksilver> I'm talking bijective hom
02:16:17 <quicksilver> because conjugate is very useful
02:16:24 <dons> yes
02:16:30 <quicksilver> I keep writing L.pack . foo . L.unpack (or the opposite, in fact)
02:16:43 <dons> oh, you shouldn't do that ;-)
02:16:49 <dons> unpack is the devil. i should ban it
02:16:57 <quicksilver> tis useful for testing
02:17:09 <dons> actually, it'll be ok once [a] is fusible
02:17:12 <quicksilver> it's easier to test stuff in string
02:17:22 <dons> since then bytestring/ Char] boundaries won't mean much
02:17:22 <quicksilver> I'm not advocating it as part of a core algorithm :)
02:17:44 * quicksilver nods
02:17:48 <quicksilver> that will be a happy day indeed
02:17:53 <dons> Model is here, fwiw, http://www.cse.unsw.edu.au/~dons/code/fps/tests/QuickCheckUtils.hs
02:17:56 <lambdabot> http://tinyurl.com/mwg5s
02:17:57 <quicksilver> dons: make it so! quickly!
02:18:13 <dons> done!
02:18:15 <dons> http://www.cse.unsw.edu.au/~dons/streams.html
02:18:15 <lambdabot> Title: Data.List.Stream
02:18:17 <dons> :-)
02:18:29 <dons> dcoutts and I are hacking on this *right now*
02:18:51 * dons plans overthrow of build/foldr ... forever!
02:20:59 <dons> malcolmw: did you get a soc acceptance email?
02:23:11 <stmartin> > scalar_times :: Num -> [Num] -> [Num]
02:23:12 <lambdabot>   Not in scope: `scalar_times'
02:23:34 <malcolmw> dons: yes, to my gmail account
02:24:05 <quicksilver> :t \x -> map (*x)
02:24:08 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
02:24:14 <quicksilver> stmartin: that what you're after?
02:24:18 <stmartin> If I put that in a (literate) haskell file, it complains Class `Num' used as a type.
02:24:32 <quicksilver> right, classes aren't types :)
02:24:41 <quicksilver> you want (Num a) => a -> [a] -> [a]
02:25:21 <stmartin> Oh... I guess I'm not supposed to type my stuff yet...
02:25:31 <stmartin> But I'll use them anyway...
02:25:34 <stmartin> Thanks.
02:30:52 <noj> hi, I've got a question embedded here: http://hpaste.org/986
02:31:12 <noj> why is the first form more general?
02:31:22 <noj> (I know about type classes)
02:31:39 <quicksilver> tis the monomorphism restriction
02:31:40 <kolmodin> dons, dcoutts_: have you got so far that you've got some performance numbers?
02:31:47 <quicksilver> CAFs are always monomorphic
02:31:54 <kolmodin> hia dcoutts__
02:32:01 <noj> quicksilver, ok, in simpler terms? :)
02:32:11 <dcoutts__> hia kolmodin
02:32:13 <noj> what are CAFs?
02:32:19 <quicksilver> noj: it's a stupid annoying language feature :)
02:32:23 <quicksilver> constant applicative forms
02:32:27 <kolmodin> dcoutts__: have you got so far that you've got some performance numbers?
02:32:32 <quicksilver> things with no explicit parameters
02:32:36 <dcoutts__> kolmodin: not yet
02:32:45 <kolmodin> ok
02:32:47 <quicksilver> let z x y = x + y --- this one wouuld have the type you are expedcting
02:32:58 <noj> yeah
02:33:35 <quicksilver> there is a discussion of the monomorphism restriction on the wiki
02:33:41 <quicksilver> which you may find enlightening, or confusing
02:33:46 <noj> :)
02:33:47 <noj> url?
02:34:06 <doserj> @google haskell monomorphism restriction
02:34:08 <lambdabot> http://www.arcknowledge.com/gmane.comp.lang.haskell.general/2003-08/msg00052.html
02:34:08 <lambdabot> Title: Re: Solution to the monomorphism restriction/implicit parameter probl
02:34:14 <doserj> well...
02:34:20 <kalven> @google lolfish
02:34:23 <lambdabot> http://www.tard.biz/
02:34:24 <lambdabot> Title: lolfish - loling the internet since 2006.
02:34:58 <doserj> http://www.haskell.org/haskellwiki/Monomorphism_restriction
02:34:59 <lambdabot> Title: Monomorphism restriction - HaskellWiki
02:35:01 <ivanm> kalven: thank you so very much for that :@
02:35:15 <noj> quicksilver, doserj, thanks
02:35:20 <kalven> ivanm: sorry, I slipped :/
02:38:57 <quicksilver> There is something just a little disturbing about this subject line "Re: small boys performance"
02:39:27 <ivanm> kalven: excuses, excuses ;-)
02:59:25 <quicksilver> dons: hmm that thread about lazy IO and filehandles on -cafe further convinces me that lazy IO is a mess
03:11:38 <malcolmw> quicksilver: lazy IO is a wonderful and highly useful thing. The problem seems to be that mapM does not return its result lazily enough.
03:17:56 <araujo> morning
03:24:37 <quicksilver> malcolmw: I'm not sure I buy that
03:24:52 <malcolmw> quicksilver: nor am i :-)
03:25:27 <malcolmw> but I do think that the knee-jerk reaction of "this isn't working, let's make it stricter" is often wrong
03:25:36 <quicksilver> well hang on, it's not that simple
03:25:38 <quicksilver> lazy IO is BROKEN
03:25:42 <quicksilver> it's semantically unsound
03:25:49 <quicksilver> there are good reasons to be suspicious of it :)
03:25:57 <quicksilver> this isn't knee-jerk anti-lazy sentiment
03:26:10 <malcolmw> only because the underlying OS is semantically unsound
03:26:12 <quicksilver> this is specific anti-mixing-lazy-IO-into-pure-data sentiement :)
03:26:27 <malcolmw> if we had a referentially transparent filesystem, these problems would not happen
03:26:27 <quicksilver> well that's one of looking at it
03:26:34 <quicksilver> but we're not in the business of fixing the OS :)
03:26:36 <ibid> my first wow thought about haskell, back in 1998 or so, was "it is smart enough to not ask the user useless questions!"
03:26:39 <quicksilver> so we better fix our libraries instead...
03:26:40 <QtPlatypus> quicksilver: yet
03:26:51 <ibid> :)
03:27:20 <int-e> hmm, could we trigger a GC when opening a file fails?
03:27:31 <ibid> malcolmw: what's referentially transparent state?
03:28:21 <quicksilver> ibid: state that is 'frozen' to 'time' when the IO action first accessed it
03:28:28 <quicksilver> ibid: much like copy-on-write or MVCC
03:28:37 <malcolmw> ibid: when you execute a file in unix, then delete/overwrite the file before execution has finished, nothing bad happens
03:28:58 <ibid> quicksilver: COW makes sense, sure
03:28:59 <malcolmw> I just think it should be the same for reading as for executing
03:29:18 <quicksilver> malcolmw: it is, if you've already paged it into memory
03:29:26 <quicksilver> malcolmw: (an execution always pages)
03:29:41 <ibid> malcolmw: so changes made to an open file should be invisible to the process? that sounds like a transactional FS, not a R-T FS :)
03:29:44 <malcolmw> then lazy I/O would work perfectly
03:29:48 <quicksilver> ibid: right, it is
03:30:01 <quicksilver> ibid: a transactional FS would be one obvious way to get R-T
03:30:16 <malcolmw> you still have state, in the sense that a filename can map to different contents at different times
03:30:43 <ibid> quicksilver: i'm not sure it qualifies as R-T, but let's not argue, i have work to do :)
03:30:44 <QtPlatypus> malcolmw: I think it is for reading.  Because unix does refcounting GC on files, and unlinking simply drops the ref count by one but your file access has a refrence open as well.
03:31:06 <qwr> main = readFile "xxx" >>= writeFile "xxx" . ('+':)
03:31:14 <qwr> *** Exception: xxx: openFile: resource busy (file is locked)
03:31:21 <qwr> lazy it is ;)
03:31:22 <ibid> QtPlatypus: that protects against deleting but not concurrent writes
03:31:47 <malcolmw> fortunately, haskell does not have lazy writes :-)
03:31:50 * QtPlatypus nods.
03:31:58 <int-e> quicksilver: but lazy IO is just too cute to miss in the cases where it works (which covers a wide range of common uses)
03:32:01 <Cale> what would lazy writes even mean?
03:32:10 <malcolmw> Cale: indeed
03:32:19 <ibid> Cale: that they happen when the RTS gets a round tuit :)
03:32:20 <Cale> Only write when the returned () was forced?
03:32:40 <quicksilver> Cale: transactionally safe lazy reads would be a fun thing, writes could still be immediate.
03:32:41 <ibid> Cale: only write if someone tries to read it?
03:32:51 <quicksilver> (or, as immediate as they are at the moment, given OS caching)
03:33:15 <quicksilver> int-e: I think people overstate the case for lazy IO :P
03:33:34 <quicksilver> int-e: and then, we keep it in because 'it's too cute' and then it causes horrendous problems
03:33:40 <quicksilver> int-e: and then that (IMO) gives haskell a bad name
03:33:48 <Cale> huh?
03:33:50 <malcolmw> quicksilver: I have applications that absolutely rely on lazy I/O for performance
03:33:53 <quicksilver> "They say they're referentially transparent" but their IO fucks up
03:34:18 <quicksilver> malcolmw: I'd rather it was marked unsafe and usable by smart people when they needed it
03:34:29 <quicksilver> malcolmw: than given the aura of safeness and biting newbies all the time
03:34:33 <int-e> quicksilver: the real problem in my opinion is that memory and file descriptors come from different pools of resources.
03:34:50 <quicksilver> int-e: well that's one way of looking at the problem, yes
03:34:53 <Cale> Is this the "why are things going wrong when I hClose the filehandle I passed to hGetContents" thing again?
03:34:55 <malcolmw> int-e that could easily be fixed though, in the GC
03:34:59 <int-e> quicksilver: otherwise the problem that the mailing list thread just discussed wouldn't have happened.
03:35:05 <quicksilver> Cale: no, although it's not unrelated
03:35:17 <quicksilver> Cale: it's the 'help I read too many files and ran out of file descriptors" this time
03:35:25 <quicksilver> Cale: -cafe, thread about lazy IO
03:35:42 <Cale> So, don't read too many files?
03:36:14 * QtPlatypus thinks about this "At its base all the file system is is a bit bunch of trees."
03:36:21 <qwr> anyway, you can always force the IO to unlazy
03:36:46 <int-e> malcolmw: yes, opening a file should try doing a GC if it finds that there aren't any fds left. not sure how difficult that is to actually implement.
03:36:48 <quicksilver> qwr: you can, yes. But I argue we're "luring" our newbies into using unsafe constructs
03:37:05 <quicksilver> qwr: which then gives them an unnecessary bad impression of the language
03:38:14 <Cale> Most applications don't open so many files that they run out of fds, even if you left all the file handles open.
03:38:43 <quicksilver> Cale: true, but with readFile it's quite hard to reason about that
03:38:51 <quicksilver> Cale: since you can't guarantee a close
03:39:01 <Cale> You can. Force the end of the string.
03:39:14 <quicksilver> but maybe I don't want to?
03:39:25 <Cale> Then you don't want to close the file yet.
03:39:26 <malcolmw> you don't need to force the end of the string
03:39:27 <quicksilver> maybe the reason I opened the file in lazy mode was because i only wanted the first few lines?
03:39:36 <quicksilver> that was the case for this particular guy
03:39:40 <quicksilver> he only wanted to read the headers
03:40:08 <malcolmw> it is sufficient to no longer have a reference to the handle, i.e. to bite enough off the file to do what you want to do, and force only that value
03:40:10 <Cale> Oh, then he could hClose after reading what he wanted. Or else just use strict IO, since he only wants the first few lines anyway.
03:40:27 <quicksilver> Cale: which is sort of where I was coming from in the first place
03:40:39 <quicksilver> Cale: about strict IO should be the default and lazy marked as unsafe :)
03:40:45 <Cale> Or yeah, what malcolmw said.
03:40:55 <Cale> Why?
03:41:05 <Cale> Lazy is safe for 99% of the time.
03:41:21 <quicksilver> but haskell should be safe 100% of the time
03:41:45 <Cale> There's no way to completely prevent people from using up resources.
03:42:06 <quicksilver> no, but resource errors should always occur in the IO monad
03:42:18 <quicksilver> not expectly when a piece of functional code forces a thunk
03:42:32 <quicksilver> s/exp/unexp/
03:42:54 <Cale> How is it unexpected?
03:42:59 <Cale> That's how lazy IO works.
03:43:05 <quicksilver> right, and that's what I don't like :)
03:43:21 <quicksilver> Oleg expressed the opinion more clearly than I'm likely to be able to do, but I agree with him.
03:43:28 <malcolmw> resource errors like "out of heap" you mean? :-)
03:43:38 <quicksilver> malcolmw: it's a fair point
03:43:44 <quicksilver> malcolmw: but we do what we can....
03:44:05 <quicksilver> malcolmw: in a C program typically an error like 'out of fds' is a recoverable error, you hope to catch the exception
03:44:20 <quicksilver> malcolmw: to mirror that in haskell, we need that error in the IO monad, not floating out in some pure code
03:45:04 <Cale> :t Control.Exception.evaluate
03:45:07 <quicksilver> I'm happier with 'out of heap' being unrecoverable
03:45:07 <lambdabot> forall a. a -> IO a
03:45:41 <Pseudonym> ?free evaluate :: a -> IO a
03:45:41 <lambdabot> $map_IO f . evaluate = evaluate . f
03:46:11 <malcolmw> quicksilver: yeah, i sort-of agree.  we have a veneer of lazy I/O over an underlying strict filesystem, so occasionally there are gaps where the underlying system shows through
03:46:24 <quicksilver> malcolmw: *nod*
03:46:57 <Cale> There are unfortunately points where any good abstraction will break in the real world.
03:47:05 <malcolmw> but I'd be happier if we found a way to make the lazy I/O veneer more complete, and hide the underlying stuff more totally
03:47:09 <quicksilver> I'm obviously not expressing myself all that clearly, so perhaps I'm wasting your time.
03:47:25 <quicksilver> But to my mind, idiomatic haskell should be pure and referentially transparent.
03:47:42 <quicksilver> If we evangelise a programming style which has holes, then when people hit the holes...
03:47:45 <Cale> The problem here is that the alternative, strict IO, doesn't work very well.
03:47:47 <quicksilver> they stop believing the story.
03:48:19 <Cale> You end up having to read small chunks and manually pass them off to your pure code in smaller pieces. So you end up writing more IO code.
03:48:39 <quicksilver> yes, you do
03:48:45 <quicksilver> but it seems to me that's the price for correctness
03:48:52 <quicksilver> we can abstract those patterns as well
03:49:58 <Cale> You end up doing what are essentially pure transformations on the data in the file from inside the IO monad.
03:50:22 <Cale> Which seems to me like a bigger loss
03:50:35 <quicksilver> but you're accepting the reality that what you're really doing is writing a stream filter
03:50:42 <Cale> than having to worry about opening too many filehandles every once in a blue moon
03:50:44 <quicksilver> writing a stream filter has some knots
03:50:51 <quicksilver> like what you do at chunk boundaries
03:51:09 <Cale> See, that whole problem goes away with lazy IO.
03:51:12 <quicksilver> true
03:52:47 <int-e> quicksilver: lazy IO is just too useful. It won't go away. Maybe more should be done about educating people about its limitations (say, "this will work for a few dozen files but if you deal with thousands, you may run into trouble because <technical explanation follows>"
03:54:37 <quicksilver> int-e: there is a tradition to only permit non ref-transp things in haskell by annotating them with 'unsafe'
03:54:50 <quicksilver> int-e: I don't understand why readFile, getContents choose to violate that
03:55:05 <Cale> Well, getContents :: IO String
03:55:07 <mux> I thought readFile wasn't lazy
03:55:14 <Cale> mux: It is.
03:55:17 <mwc> Hey, does anybody remember what that RSS processor somebody wrote using a haskell xml toolkit
03:55:21 <mwc> was called?
03:55:26 <mwc> Cale: was it you?
03:55:31 <Cale> yeah
03:55:36 <mwc> what tool kit was it?
03:55:42 <Cale> http://cale.yi.org/index.php/HRSS
03:55:44 <Cale> HXT
03:55:44 <mwc> I was actually looking for that
03:55:45 <lambdabot> Title: HRSS - CaleWiki
03:55:46 <mwc> HXT
03:55:55 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/
03:55:57 <lambdabot> Title: Haskell XML Toolbox 7.1
03:56:03 <quicksilver> Cale: ah, but it's still unsafe even when it's outside IO
03:56:16 <mwc> Thanks, I think I might need to use an arrow to do something, and I need to get a feel for what they do
03:56:27 <quicksilver> do { foo <- getContents ; {- foo is now a non-ref-trans String -} }
03:57:05 <Cale> In some sense, it's referentially transparent.
03:57:17 <int-e> quicksilver: well, not really. in a single run of the program it will never change
03:57:34 <quicksilver> true
03:57:35 <quicksilver> hmm
03:57:42 <quicksilver> like I said, I can't express this as clearly as I'd like
03:57:50 <quicksilver> there's something wrong with it nonetheless :)
03:58:16 <Cale> and the string you get from readFile is scarier, but still, characters once read will not change.
03:58:32 <int-e> quicksilver: I agree it's tricky but it doesn't justify the 'unsafe' prefix for me.
03:59:28 <Cale> unsafeInterleaveIO is unsafe, but certainly not anywhere near as unsafe as unsafePerformIO. It's more on the edge of what I'd bother sticking an unsafe label on :)
04:00:02 <Cale> Most of the lazy IO stuff uses unsafeInterleaveIO in relatively safe ways.
04:00:10 <Cale> It's possible to do much worse.
04:00:24 <mwc> @type unsafeInterleaveIO
04:00:26 <lambdabot> Not in scope: `unsafeInterleaveIO'
04:00:38 <Cale> unsafeInterleaveIO :: IO a -> IO a
04:00:45 <mwc> IIRC, interleaving ST threads can be dangerous
04:00:50 <Cale> The returned IO action, when run, returns immediately
04:00:57 <mwc> and ST is convertable to IO by using a special RealWorld state type
04:01:03 <Cale> forcing the value returned will cause the IO to occur
04:01:33 <mwc> so maybe the unsafeness comes from that?
04:01:36 <arjanoosting> shapr: Yeah I patched Setup.hs, I took Setup.hs from the darcs archive
04:01:40 <mwc> oh, I can see how that's unsafe
04:02:10 <Cale> You can create values whose value relies on evaluation order.
04:02:56 <Cale> which sort of throws denotational semantics out the window
04:03:26 <quicksilver> I think that lazy IO is probably inappropriate for long-running processes
04:03:30 <Cale> At least with things like getContents, you can imagine that there is already some string which the user intends to eventually get around to typing in
04:03:31 <int-e> but without time travel it doesn't break referential transparency - to me
04:03:45 <Cale> quicksilver: why is that?
04:03:55 <quicksilver> Cale: because it fubars your resource management
04:04:02 <Cale> Not necessarily.
04:04:06 <quicksilver> Cale: and long-running processes normally need to manage their resources
04:04:17 <Cale> In fact, it might be just the thing to keep resource usage down.
04:04:20 <int-e> you need to tie this stuff to the GC somehow.
04:04:34 <quicksilver> Cale: well it makes it hard to predict when exceptions might be thrown on that resource; and it makes it hard to know when the resource would be released
04:04:50 <quicksilver> int-e: not good enough; a server process has to have to choice to explicitly disconnect resources
04:04:56 <quicksilver> int-e: i.e. perform a higher-level GC all of its own
04:05:09 <Cale> You can do that.
04:05:14 <int-e> quicksilver: you still have that choice, nobody is going to take that away from you
04:05:28 <quicksilver> int-e: I know I have that choice :)
04:05:31 <int-e> quicksilver: but I was thinking of making the mailing list example actually work - because I'd really like it to work.
04:05:42 <quicksilver> int-e: right; sorry; slight cross-purposes
04:06:02 <quicksilver> int-e: I started this line of conversation with : < quicksilver> I think that lazy IO is probably inappropriate for long-running processes
04:06:13 <quicksilver> int-e: I'm think about database servers, web servers, and so on
04:06:38 <int-e> quicksilver: if your point is that lazy IO gives you less control over when exactly what resource is freed, that's certainly true.
04:07:29 <quicksilver> int-e: yes, that is part of the point
04:07:36 <quicksilver> int-e: the other point is control over when exceptions might be thrown
04:08:06 <Cale> You can take control of that from IO if you expect an exception to be thrown in a pure value.
04:08:19 <Cale> It is a hassle though
04:08:31 <quicksilver> right
04:08:40 <quicksilver> better to be explicit about it in the first place
04:08:49 <quicksilver> implicit things are only good when they *always* DTRT
04:08:54 <Cale> Not by default, I don't think.
04:09:00 <Cale> Maybe for some applications
04:10:21 <Cale> Saving people this kind of effort by default is a good thing. Even if it's not perfect yet.
04:10:44 <quicksilver> well enough whining. Cale: would it be nice to have a typeclass Isomorphic a b where lift :: a->b ; unlift :: b->a ?
04:10:51 <int-e> heh, just imagine every third Haskell coder implementing their own lazy IO scheme ...
04:11:17 <Cale> I don't think as much work has been put into the implementation of lazy IO as has been put into garbage collectors yet.
04:11:25 <quicksilver> then conj :: (Isomorphic a,b) => (a->a) -> (b->b); conj f = lift.f.unlift
04:11:38 <Cale> quicksilver: might be nice :)
04:11:43 <kuribas> Isn't recursive do like lazy IO?
04:11:50 * int-e wonders if GHC has a primop to do a garbage collection
04:12:05 <dcoutts__> @google performGC
04:12:07 <lambdabot> http://www.nabble.com/local-ByteArrays:-performGC-do-any-good--tf3367362.html
04:12:07 <lambdabot> Title: Nabble - local ByteArrays: performGC do any good?
04:12:08 <dcoutts__> erm
04:12:14 <dcoutts__> @hoogle performGC
04:12:14 <lambdabot> System.Mem.performGC :: IO ()
04:12:33 <quicksilver> Cale: I keep typing L.unpack . f . L.pack when testing ByteString code :)
04:12:42 <quicksilver> Cale: struck me that conjugation is a common pattern, or might be
04:12:51 <dcoutts__> quicksilver: indeed
04:13:02 <int-e> dcoutts__: thanks. oh, it's a direct foreign import, no wonder I didn't find anything in GHC.Base.
04:13:04 <Cale> quicksilver: I think dons has a NatTrans class for things like that
04:13:12 <quicksilver> Cale: yes, he does
04:13:13 <dcoutts__> quicksilver: see the testing framework we did for ByteString, it has a modeling class
04:13:18 <quicksilver> not quite the same, though
04:13:31 <quicksilver> model is injective hom
04:14:31 <quicksilver> why did Gofer have more cool 'mathsy' type classes and we lost them in haskell?
04:15:15 <quicksilver> (dons said taht NatTrans was from Gofer)
04:15:29 <quicksilver> I seem to remember that there are some gotchas with MPTCs though?
04:16:00 <Cale> quicksilver: man, we lost all kinds of stuff
04:16:09 <Cale> quicksilver: check out even the Haskell 1.4 Prelude.
04:16:29 * quicksilver nods
04:16:31 <quicksilver> But why?
04:16:57 <Cale> People wanting to make the language more accessible to beginners, but unwilling to teach certain things?
04:17:42 <quicksilver> but surely 'hard stuff' could be hidden awway in a module
04:17:51 <Cale> to some extent, yeah
04:18:11 <quicksilver> What's the business about Functors and Monads not being linked, too?
04:18:12 <Cale> But things like (++) :: MonadPlus m => m a -> m a -> m a
04:18:25 <quicksilver> Is the language not quite expressive enough to say 'all Monads are Functors, and furthermore' ?
04:18:37 <Cale> Oh, that's people wanting to be lazy and not write the 2-line functor instance.
04:18:43 <Pseudonym> Yeah.
04:18:56 <quicksilver> ?
04:19:00 <Pseudonym> The only limitation of the language is it doesn't let you be lazy and avoid that.
04:19:31 <Pseudonym> quicksilver: It means that if you want something to be a Monad, you have to declare a Functor instance first.
04:19:38 <Pseudonym> You HAVE to.
04:19:38 <quicksilver> Ah, so you can't say instance (Monad m) => (Functor m) where fmap f = (>>= return.f)
04:19:42 <Pseudonym> Right.
04:19:45 <quicksilver> and have the language automatically cope?
04:20:02 <quicksilver> is there a technical reason why the language can't "automatically fill in" things like that?
04:20:07 <quicksilver> or just that's not how the compilers work?
04:20:12 <Cale> You can actually write them side-by-side and use the monad stuff to define the functor instance though.
04:20:12 * mux thought it could
04:20:30 <Pseudonym> It'd be nice if you could declare the Monad instance as this:
04:20:37 <Pseudonym> instance (Functor m) => Monad m where
04:20:38 <Pseudonym>    ...
04:20:39 <quicksilver> Cale: but for forall m. (Monad m) => (Functor m), where fmap = liftM?
04:20:46 <quicksilver> you can't do?
04:20:48 <Pseudonym>    fmap f = (>>= return . f)
04:20:53 <Cale> class Monad m where
04:21:00 <Pseudonym> Because you can put default instances in class declarations.
04:21:01 <Cale>   instance Functor m where
04:21:07 <Cale>     fmap = liftM
04:21:46 <Pseudonym> The catch is that you could declare two child classes each with their own instance for the parent class.,
04:21:54 <Pseudonym> And the compiler wouldn't know what to do.
04:22:24 <Cale> It could force you to simply implement it yourself.
04:22:26 <Pseudonym> It's not difficult.  It's just that someone has to sit down and work out exactly what to do.
04:22:30 <Pseudonym> And then do it.,
04:22:37 <Pseudonym> And nobody's gotten around to it yet.,
04:22:38 <Cale> yeah
04:22:57 <Cale> It really deserves a solution though
04:23:01 <Pseudonym> I agree.
04:23:14 <quicksilver> because as your type hierarchy gets bigger this is a quadratic problem
04:23:26 <Pseudonym> Right.
04:23:41 <quicksilver> well quadratic in maximum-depth, or something. But the point is taken.
04:23:41 <Pseudonym> One of the proposals is to make a fine-grained type hierarchy for the Prelude.
04:23:49 <Pseudonym> e.g. not putting all the arithmetic stuff in Num.
04:24:01 <quicksilver> Has haskell-prime taken a view on a finer-grained hierarchy?
04:24:02 <Pseudonym> And default instances for parent classes would be great in conjunction with that.
04:24:19 <Pseudonym> Oh, someone proposed it.  I don't think it'll make it.
04:24:27 <Pseudonym> Not haskell-prime.
04:24:46 <Pseudonym> Haskell-prime is for conservative extensions and minor cleanups.
04:24:59 <Pseudonym> We're putting off the inevitable flag day.
04:25:10 <quicksilver> hmm
04:25:12 <int-e> oh, GC on opening files won't help that email header filter program without modification - readFile opens the file before the string is used, so all the files are opened before any processing is done.
04:25:38 <int-e> (IOW, readFile is not as lazy as it could be)
04:25:46 <quicksilver> int-e: heh. so, what you're saying is, readfile ISNT LAZY ENOUGH!
04:25:54 <quicksilver> int-e: and all along I've been trying to say it's too lazy :P
04:25:55 <quicksilver> :)
04:26:01 <int-e> quicksilver: yep.
04:26:18 <quicksilver> Pseudonym: carefully managed, couldn't a type hierarchy refinement be fairly conservative
04:26:19 <int-e> just needs another unsafeInterleaveIO *g*
04:26:44 <quicksilver> Pseudonym: I would think you could be fairly good at not breaking existing code except in small places
04:27:05 <Pseudonym> Possibly.
04:27:14 <Pseudonym> Adding names to the Prelude is always risky, because it's imported everywhere.
04:27:21 <quicksilver> having functor definitions automatically constructed for monads, though
04:27:23 <Pseudonym> So you increase the risk of name clashes.
04:27:31 <Pseudonym> Well, yeah.
04:27:42 <Pseudonym> That's a conservative extension.
04:28:15 <quicksilver> @type mzero
04:28:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
04:28:27 <quicksilver> hmm you see that's another tricky one
04:28:38 <Pseudonym> Right.  Ideally, mzero should default to fail.
04:28:38 <quicksilver> @type fail
04:28:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
04:28:53 <quicksilver> no, ideally fail should be terminated with prejudice
04:29:03 <quicksilver> @info MonadError
04:29:03 <lambdabot> MonadError
04:29:45 <quicksilver> fail = throwError
04:30:16 <quicksilver> > throwError "broke"
04:30:17 <lambdabot>   add an instance declaration for (Show (m a))
04:30:23 <quicksilver> > throwError "broke" :: Either String Int
04:30:24 <lambdabot>  Left "broke"
04:31:00 <quicksilver> > throwError (Right "something odd") :: Either String Int
04:31:00 <lambdabot>  Couldn't match expected type `Either a [Char]'
04:31:26 <quicksilver> oh right, MonadError is parameterised in the class
04:31:33 <quicksilver> which means it can't be haskell98 anyway
04:31:37 <edwinb> I'm trying to find a way to set options to happy with cabal. Is it possible?
04:42:55 <int-e> So I replaced the mapM readFile  by  mapM (unsafeInterleaveIO . readFile) and made parseEmail parse to a strict struct. Now the program works for 20k files. :)
04:44:11 * quicksilver nods
04:44:23 <quicksilver> so you had to add strictness annotations to parseEmail?
04:52:06 <malcolmw> lazier I/O, stricter use of the values gleaned from I/O.  that's the way I would have done it
04:53:28 <kuribas> therp: ping
04:55:17 <quicksilver> but if you force the programmer to care about messy strictness annotations then hmm
04:55:23 <quicksilver> it seems that you're losing some value :)
04:55:40 <quicksilver> also strictness annotations in this context have direct semantic consequences, which is a bit odd
04:55:47 <quicksilver> (instead of merely performance consequences)
04:56:31 <int-e> err, running out of resources is a problem that can often be cured by more lazyness and/or strictness. that includes memory as well.
05:04:25 <dons> re.
05:09:04 <therp> kuribas: pong
05:09:47 <dons> kolmodin: re. numbers, not yet. wrote the benchmark code today. and started um, 2 days ago. numbers in the paper^h^h^h in a few days
05:09:57 <kuribas> therp: you wrote liskell, right?
05:10:02 <therp> kuribas: right
05:10:16 <kuribas> therp: How well does it work together with ghc?
05:10:26 <therp> kuribas: it's part of GHC
05:10:48 <therp> kuribas: so I guess the answer is: 100%
05:10:56 <kuribas> Will it work together with a standard install of ghc?
05:11:06 <kolmodin> dons: yeah, I know you guys just started, but I couldn't help myself asking :)
05:11:25 <therp> kuribas: you have to obtain the liskell branch of GHC to use it.
05:12:22 <kuribas> therp: hmm, I was wondering if it would be possible to translate Liskell to Haskell, so that people that only want to compile my program can use standard ghc.
05:13:14 <therp> kuribas: that's possible, if you restrict yourself to Haskell compatible identifiers. Lisp programmers tend to use identifiers-with-a-lot-of-dashes. these are not Haskell compatible
05:14:09 <kuribas> therp: And would it be possible to rewrite them to IndentifiersWithoutAnyDashes?
05:16:16 <therp> kuribas: could be automatised, but hasn't been implemented yet. so do it manually or if you know you want to export the intermediate Haskell syntax tree into Haskell source code, just don't use any Haskell incompatible identifiers
05:16:39 <kuribas> therp: Ok, I see.  Ghc-Liskell can do that?
05:16:59 <therp> kuribas: yes, just add -ddump-parsed to the command line. it will output the haskell translation
05:17:11 <therp> kuribas: do you plan to use meta-programming?
05:17:26 <therp> because that's not working with -ddump-parsed..
05:17:29 <kuribas> therp: I don't think so, just I prefer the syntax :)
05:17:44 <therp> kuribas: fine, then just try to add -ddump-parsed :)
05:17:47 <kuribas> Does it have cond?
05:17:58 <therp> kuribas: well yes, but as meta-programming construct :)
05:18:32 <therp> it expands to a series of ifs
05:19:16 <kuribas> Liskell compile failed...
05:19:39 <kuribas> liskell/LskToHs.hs:761:29:   Ambiguous occurrence `text'
05:20:56 <therp> hm, let me check. my local working copy is modified to heavily
05:21:00 <therp> too
05:21:05 <dons> kolmodin: so of the reimplemented functions are maybe 50% faster on simple tests
05:21:25 <dons> kolmodin: but its not going to be like the switch to bytestrings: all the speed up will come when they fuse things that don't use with build/foldr
05:21:39 <dons> (which is mainly things with foldl in them)
05:22:01 <kuribas> therp: I like the idea of Liskell, but I think it can be difficult to find Haskell programmers who want to use s-exps.
05:22:30 <dons> kuribas: that's indeed an issue, i think
05:23:06 <dons> therp: have you thought about a haskell syntax to the underlying framework?
05:23:18 <quicksilver> dons: what about zips?
05:23:54 <dons> yeah, they're fusible. we might need specConstr to really kick in though.
05:24:23 <kuribas> dons, :)  On the otherhand I know people who are interested in haskell, but put off by the syntax (scheme/lisp programmers mainly).
05:24:55 <dons> zipWith :: (a -> b -> c) -> Stream a -> Stream b -> Stream c
05:24:56 <dons> zipWith f (Stream next1 xs m) (Stream next2 ys _) = Stream next (xs, ys) m
05:25:39 <therp> kuribas: I don't mind. Liskell's meta-programming is much easier to use. I implemented "user-land" type-inference two days ago. in theory you can create a totally arbitrary type system with the help of meta-programming (dependent types *hint*hint*)
05:26:13 <ailndx> !paste
05:26:13 <hpaste> Haskell paste bin: http://hpaste.org/
05:26:33 <therp> dons: underlying framework? .. there isn't much. my modifications to core GHC are marginal
05:27:17 <ailndx> dons: http://hpaste.org/988 how would i implement here so the app quits if i type in "quit or exit"?
05:27:23 <therp> kuribas: so symbolic expression are much easier to use when it comes to these kind of things. basically I think there is no other choice. to good thing for me personally is that I like Lisp syntax
05:28:54 <dons> ailndx: looking..
05:29:17 <quicksilver> dons: I think you mean (f xs ys) :P
05:29:20 <dons> ailndx: the missing code is from the irc tut?
05:29:49 <ailndx> dons: indeed
05:30:28 <dons> ailndx: so just add a function that reads "quit" from stdin and then exitWith ExitSuccess ?
05:30:36 <dons> i.e. throw an exiting exception
05:31:21 <ailndx> okay, trying
05:32:18 <dons> quicksilver: btw, have you thought about mentoring a project for SoC? would you be interested in doing that?
05:32:41 <quicksilver> dons: I'm flattered but I'm afraid I don't really have the time.
05:32:42 <therp> kuribas: but for the moment, I do not recommend to use Liskell for anything else than experiments. The Liskell branch should see a bit of love after April when I'm back from my trip to Cambridge, where I will present a few nice results based on Liskell (embedded Prolog in Haskell, custom type inference, and hopefully a scheme compiler but that depends on my workload in the next 2 weeks)
05:32:56 <quicksilver> dons: (and in many cases I probably wouldn't have the knowledge)
05:33:45 <dons> ok :-)
05:34:36 <kuribas> therp: Yes, it will be more interesting to show some real examples how sexps can be useful.
05:35:50 <therp> this scheme compiler is really interesting, because it translates scheme into Liskell/Haskell, and then you could benchmark the compilation of GHC of translated scheme code against real scheme compilers.
05:36:00 <dons> that'd be very neat
05:36:31 <therp> I should do that Prolog too.. the embedded Prolog stuff is mostly completed anyway.
05:36:38 <therp> swiprolog would make a good target
05:37:29 <kuribas> Sounds really cool.
05:44:36 <ailndx> bot.hs:58:24: parse error on input `exitWith'
05:45:14 <ailndx> System.exit maybe
05:46:32 <ailndx> obviously not
05:47:27 <xerox__> ?users
05:47:27 <lambdabot> Maximum users seen in #haskell: 336, currently: 302 (89.9%), active: 29 (9.6%)
05:47:32 <quicksilver> ailndx: 'parse error' doesn't mean you got the name wrong
05:47:36 <quicksilver> ailndx: that would be 'unknown symbol'
05:47:46 <quicksilver> ailndx: 'parse error' means you got the syntax wrong, somewhere
05:47:55 <ailndx> !paste
05:47:56 <hpaste> Haskell paste bin: http://hpaste.org/
05:48:39 <ailndx> http://hpaste.org/989
05:49:14 <quicksilver> so, what's the prize for the 1000th hpaste?
05:49:38 <quicksilver> ailndx: you need to indent that line at least as much as the do
05:50:20 <ailndx> ah ok, i dislike haskell indentation(at least with this editor) :/
05:50:37 <quicksilver> don't use it, if you don't like it
05:51:09 <quicksilver> put a { after the do, and a ; before the exitWith, and a } after ExitSuccess
05:51:09 <dons> which editor?
05:51:14 <dons> not the broken emacs mode?
05:51:18 <ailndx> btw it is indented more than the "do" allready
05:51:24 <quicksilver> ailndx: no, it's not :)
05:51:25 <ailndx> im in win, so using notepad
05:51:37 <quicksilver> ailndx: if it looks like it is, then maybe there are a mixture of tabs and spaces or something
05:52:05 <ailndx> quicksilver: ah well, in my editor it was :(
05:52:09 <quicksilver> ailndx: "quit" has two tabs, and "exitWith" has 3 tabs
05:52:18 <quicksilver> but 3 tabs isn't enough to get you past the do
05:52:21 <dons> avoiding tabs is a good idea.
05:52:24 * quicksilver nods
05:52:30 <quicksilver> avoiding notepad is a fairly good idea :)
05:52:39 <ailndx> quicksilver: yep obviously, but in my editor it was :/
05:52:44 <dons> -Wtabs is even available with newer ghc's
05:52:59 <quicksilver> at the bare minimum you just need an editor which cna indent a new line as much as the previous
05:53:00 <ailndx> dons: do you suggest i should press space a hundred timed every time instead?
05:53:10 <dons> you should use an editor that expands tabs to spaces.
05:53:14 <quicksilver> ailndx: no, that you get an editor which indents each line to match the previous
05:53:18 <dons> any good programmer's editor will do this.
05:53:22 <quicksilver> ailndx: then you only have to do 'enough' spaces
05:53:34 <quicksilver> ailndx: or, use an editor with a haskell mode, which knows how to indent for you :)
05:53:41 <dons> ailndx: vim, emacs, hmm, pfe on windows?
05:54:16 <dons> a good editor is one of the most useful tools you can have to improve your productivity as a programmer :-)
05:54:17 <ailndx> dons: well i might start using the VS editor later
05:54:31 <ailndx> !paste
05:54:31 <hpaste> Haskell paste bin: http://hpaste.org/
05:56:16 <ailndx> http://hpaste.org/990
05:58:36 <kuribas> Emacs only thinks he knows how to indent
05:58:42 <Cale> ailndx: the  exitWith ExitSuccess  is part of the hPrint line above it, because it's indented more.
05:58:58 <ailndx> gaah
05:59:04 <ailndx> *darn indentation
05:59:05 <Cale> line the 'e' in exitWith up with the h in hPrint
05:59:36 <Cale> If you have a really hard time with it, you can use braces and semicolons
05:59:53 <Eelis> curse you fixed-width font chauvinist!
06:01:28 <ailndx> what should it be indented with, same as "do"?
06:01:35 <Cale> same as hPrint
06:01:43 <Cale> which is 3 spaces farther than do
06:01:49 <chessguy> 'morning haskellers
06:02:25 <chessguy> i have a dumb question
06:02:31 <diffbavis> both System.Directory.getUserDocumentsDirectory and System.Environment.getEnv "HOME" are returning "". what am I doing wrong?
06:02:54 <ailndx> yikes, now i got shitloads with errors instead
06:03:10 <chessguy> i know if i do data Foo = Foo { bar :: Int }, there's literally a function created bar :: Foo -> Int
06:03:47 <ailndx> http://hpaste.org/994
06:03:56 <chessguy> but if i do data Bar = Bah Int Int, is there really a function created like Bah :: Int -> Int -> Bar
06:04:03 <Cale> ailndx: compile with --make
06:04:15 <ailndx> ooh
06:04:21 <chessguy> or is that just a way to think about it
06:04:28 <Cale> Whenever you see stuff like that, compile with --make :)
06:04:35 <ailndx> pff :D
06:04:41 <quicksilver> chessguy: yes, a function is created
06:04:41 <Cale> chessguy: yes
06:04:53 <quicksilver> chessguy: you can pass it around as a function which 'proves' that it's first-class
06:04:55 <chessguy> wow
06:04:56 <quicksilver> (one
06:05:01 <quicksilver> one of my main annoyance with ocaml
06:05:06 <chessguy> and it can be curried?
06:05:10 <quicksilver> Constructors aren't first-class functions
06:05:14 <quicksilver> yes, it can be curried :)
06:05:18 <quicksilver> :t (,) 4
06:05:18 <Cale> ailndx: the problem is that the appropriate packages aren't loaded. --make will decide which ones for you automatically
06:05:20 <lambdabot> forall t b. (Num t) => b -> (t, b)
06:05:23 <Cale> (ghci does this too)
06:05:43 <chessguy> (,) is a constructor?
06:05:49 <quicksilver> yes
06:05:49 <Cale> yeah
06:05:56 <chessguy> huh.
06:06:02 <Cale> It's both a data and type constructor
06:06:12 <quicksilver> > let f (,) a b = a + b in f (3,4)
06:06:13 <lambdabot>      Constructor `(,)' should have 2 arguments, but has been given 0
06:06:13 <lambdabot>     In t...
06:06:20 <quicksilver> > let f ((,) a b) = a + b in f (3,4)
06:06:21 <lambdabot>  7
06:06:26 <ailndx> dons: the exitWith .. doesnt seem to work so good, the program stops functioning but it doesnt really exit back to prompt
06:06:27 <quicksilver> this proves it is a constructor
06:06:37 <Cale> > (,) 3 "Hello" :: (,) Integer String
06:06:38 <lambdabot>  (3,"Hello")
06:06:41 <quicksilver> since only constructors, and not general functions, may be used in pattern matches
06:06:51 <quicksilver> Cale: that only proves it's a function, though :)
06:06:55 <Cale> right
06:07:20 <chessguy> so what's the difference between data and type constructors?
06:07:21 <Cale> (and a type constructor)
06:07:37 <Cale> data constructors construct values, type constructors construct types
06:07:40 <quicksilver> chessguy: Constructors are a special kind of function; there is a syntactic difference (they start with capital letters) and a semantic difference (you can use them in patterns)
06:07:53 <Cale> For instance, Maybe is a type constructor, Just is a data constructor.
06:07:58 <quicksilver> all Constructors are therefore functions, but in general 'most' functions are not constructors
06:08:15 <chessguy> so Just constructs values of type Maybe
06:08:19 <quicksilver> right
06:08:23 <quicksilver> in some cases, the name is the same
06:08:24 <Cale> @type Just
06:08:26 <lambdabot> forall a. a -> Maybe a
06:08:29 <quicksilver> this is potentially confusing
06:08:35 <quicksilver> (,) constructs values of type (,)
06:08:52 <Cale> @type (,)
06:08:54 <lambdabot> forall a b. a -> b -> (a, b)
06:08:57 <quicksilver> @kind (,)
06:08:59 <lambdabot> * -> * -> *
06:09:10 <Cale> those are different (,)'s though :)
06:09:16 <chessguy> what's the data constructor for (a,b,c) ?
06:09:19 <quicksilver> chessguy: fortunately, haskell's syntax is not ambiguous in this way
06:09:21 <Cale> (,,)
06:09:29 <chessguy> aha
06:09:34 <kzm> QuickCheck isn't distributed by default with GHC?  (I guess I didn't get the extra libs when compiling it)
06:09:34 <quicksilver> chessguy: that is, the parser *always* knows when it's expecting a type or a value
06:09:43 <quicksilver> chessguy: so, there is no risk of technical confusion
06:09:44 <Cale> > (,,) "Hello" 45 [1,2,3]
06:09:45 <lambdabot>  ("Hello",45,[1,2,3])
06:09:57 <kzm> @hoogle QuickCheck
06:09:57 <lambdabot> Test.QuickCheck :: module
06:09:57 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
06:10:01 <quicksilver> chessguy: (there is still risk of non-technical, i.e. human, confusion) :)
06:10:07 <kzm> @where QuickCheck
06:10:07 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
06:10:15 <chessguy> ok, and there are both type constructor classes and type classes, right?
06:10:35 <Cale> chessguy: yeah, but they're both called typeclasses these days
06:10:37 <quicksilver> that's not how I would normally phrase it
06:10:46 <chessguy> why?
06:10:50 <chessguy> (to both of you)
06:10:58 <quicksilver> a typeclass definition might, or might not, contain (type) parameters
06:11:06 <quicksilver> but they are still 'the same sort of thing'
06:11:08 <Cale> The distinction between constructor classes and type classes sort of faded away. They have the same syntax.
06:11:23 <quicksilver> just like a value definition might or might not contain (value) parameters
06:11:30 <Cale> huh?
06:11:36 <quicksilver> isn't that analogous?
06:11:39 <Cale> Typeclasses always have at least one parameter
06:12:07 <quicksilver> then I suspect I'm confused
06:12:09 <quicksilver> :)
06:12:12 <quicksilver> what is a constructor class?
06:12:28 <Cale> a class whose parameter ranges over type constructors
06:12:37 <Cale> for instance, Monad or Functor
06:12:38 <chessguy> isn't Monad an example?
06:12:54 <ailndx> hmm exitWith Exitsuccess dont seem to work so good, my program keeps running, looks like it just killed the one thread
06:13:03 <kzm> Isn't that (@where QuickCheck) misleading?  I.e. - there's a newer version, probably somewhere at haskell.org, no?  A darcs repo, maybe?
06:13:08 <Cale> ailndx: that's odd.
06:13:23 <quicksilver> right, I wasn't confused
06:13:32 <quicksilver> I just didn't spell it out well
06:13:32 <ailndx> it killed the input thread, the others keep running :/
06:13:42 <quicksilver> it's the difference between kind * and kind *->*
06:13:56 <quicksilver> so it is, in some sense, the difference between a value definition with paramters and one without
06:14:20 <Cale> ailndx: maybe try it from the main thread
06:14:46 <quicksilver> or, throw an exception back to the main thread
06:14:51 <quicksilver> I'm not sure what you're trying to do :)
06:14:52 <Cale> yeah.
06:15:03 <quicksilver> I throw exceptions to the main thread if I want everything to die
06:15:15 <Cale> You could throw an exception to the main thread, which when caught, calls exitWith
06:15:17 <ailndx> Cale: cant, the main one dont take stdio
06:15:37 <ailndx> !paste
06:15:37 <hpaste> Haskell paste bin: http://hpaste.org/
06:16:00 <quicksilver> Cale: is there a reason that typeclasses cannot mandate constructors?
06:16:11 <quicksilver> Cale: because Num does it, and that seems to work :)
06:16:44 <Cale> yeah, but that involves extra testing.
06:17:03 <Cale> f 5 = 7 means f x | x == 5 = 7
06:17:18 <quicksilver> really?
06:17:22 <Cale> yeah
06:17:23 <quicksilver> I never knew that
06:17:24 <quicksilver> it cheats!
06:17:28 <ailndx> Cale: here we have it http://hpaste.org/995
06:18:32 <ailndx> the listen thread seem to keep running
06:20:09 <Cale> try just throwing an exception from the ircreader
06:20:41 <ailndx> im not so good at this..
06:21:10 <ailndx> how would i do that?
06:21:30 <Cale> Should be enough to do  error "Shutting down."
06:21:40 <Cale> oh
06:21:50 <ailndx> but where.., insite run or inside main.. or?
06:21:54 <quicksilver> you have to save the ID of the main thread, I believe
06:22:00 <quicksilver> and pass that into your ircreader
06:22:03 <Cale> I was thinking in place of the exitWith
06:22:06 <Cale> but looking at this...
06:22:15 <quicksilver> then you throwTo mainThread
06:22:22 <quicksilver> and your bracket will clean stuff up for you
06:22:30 <ailndx> it is the "run" that keeps running even with exitWith
06:22:34 <Cale> exitWith is supposed to throw an ExitException
06:22:51 <Cale> but perhaps it needs to throw it back to the main thread here
06:23:09 <ailndx> well i got no clue how to do that codewise
06:23:28 <Cale> throwTo mainThread (ExitException ExitSuccess)
06:23:39 <Cale> after passing mainThread into the ircreader loop
06:24:00 <Cale> mainThread being the result of myThreadId from the main thread
06:24:13 <Cale> I'll annotate :)
06:25:03 <ailndx> hehe, yeah it sounds good to me, but since im pretty much total new to haskell i dont know how to implement it
06:26:47 <Cale> er, oops
06:26:51 <Cale> heh
06:26:57 <Cale> made two silly mistakes there
06:27:38 <Cale> I'm tired.
06:27:42 <Cale> Should sleep a bit :)
06:27:52 <ailndx> sleep is for amateurs! :)
06:28:20 <quicksilver> although, most of the amateurs google finds don't seem to be sleeping at all
06:28:24 <ailndx> take something with sugar and you are good to go again
06:28:27 <Cale> quicksilver: haha
06:28:40 <ailndx> ^^
06:30:25 <Cale> oh, it didn't announce?
06:30:32 <Cale> http://hpaste.org/995#a2
06:30:37 <chessguy> it did that to me the other day too
06:30:57 <quicksilver> I believe announce is off at the moment
06:30:59 <Cale> FreeNode does strange things to clients sometimes.
06:31:00 <quicksilver> due to spamming
06:31:04 <Cale> oh
06:32:49 <dons> ailndx: ah right. you have to throw the exception back to the main thread. i guess you're reading in a forked thread?
06:33:02 <dons> the program ends when the main thread exits
06:33:45 <Cale> another way to handle this would be to use some other form of thread communication
06:33:50 <Cale> like an MVar
06:35:05 <Cale> You'd create an empty MVar, and pass an action to the threads which would put a value in it. Then you have your main thread take the MVar, which causes it to block.
06:35:32 <ailndx> io :: IO a -> Net a
06:35:32 <ailndx> io = liftIO
06:35:40 <ailndx> couldnt i just send it to io?
06:36:04 <dons> ?docs Control.Concurrent
06:36:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
06:36:20 <Cale> ailndx: hm?
06:36:23 <dons> grab the thread id of the main thread, throw the exception to it, from the child
06:36:38 <Cale> dons: that's what I implemented in the annotation to his paste
06:36:56 <ailndx> you implemented it also? :)
06:37:00 <dons> ah ok. good :-)
06:37:04 <Cale> http://hpaste.org/995#a2
06:37:05 <ailndx> ah there
06:37:07 <ailndx> didnt see
06:38:16 <Cale> ignore that first annotation, I messed up one of the parameters, and then when I went to fix it, accidentally messed up another. This is what trying to code on no sleep does. Thank Simon for typecheckers :)
06:42:02 <Cale> @pl forever a = a >> forever a
06:42:03 <lambdabot> forever = fix (ap (>>))
06:42:16 <Cale> cute
06:46:51 <chessguy> ni d
06:46:52 <chessguy> nice
06:48:44 <quicksilver> ap (,) is like before-and-after
06:48:47 <quicksilver> I quite like that
06:49:06 <quicksilver> > ap (,) Char.toUpper 'a'
06:49:07 <lambdabot>  ('a','A')
06:49:54 <wolverian> @source ap
06:49:54 <lambdabot> ap not available
06:49:56 <ailndx> Cale: http://hpaste.org/998 parse error on input 'evalStateT'
06:50:01 <wolverian> aw.
06:50:08 <quicksilver> wolverian: ap is liftM ($)
06:50:29 <Cale> ailndx: 3 more spaces before evalStateT
06:50:38 <wolverian> quicksilver, thanks.
06:50:51 <Cale> line it up with the first line of the do-block, which starts "forkIO ..."
06:51:00 <Rugiada> .:::] ShAlOm @T AlL
06:51:26 <Cale> @elite Shalom Rugiada
06:51:26 <lambdabot> $hALOM RUgi4dA
06:51:44 <quicksilver> wolverian: i.e. ap f x  is do { realf <- f; realx <- x; return (realf realx) }
06:51:52 <quicksilver> wolverian: so I should have said 'liftM2' not 'liftM'
06:53:22 <quicksilver> >  ap [(+1),(*2)] [1,2,3,4]
06:53:23 <lambdabot>  [2,3,4,5,2,4,6,8]
06:53:44 <ailndx> Cale: ircreader h mainThread = do
06:54:30 <ailndx> that wont work will it, i should have ircreader h mt mainThread?
06:54:53 <Cale> hm?
06:55:06 <ailndx> i'll paste error
06:55:07 <Cale> oh, perhaps they should be swapped
06:55:15 <Cale> ircreader mainThread h
06:55:27 <Cale> er, no
06:55:34 <Cale> they were the right way round
06:55:40 <Cale> what's the issue?
06:55:50 <ailndx> number of arguments
06:55:55 <Cale> oh
06:56:04 <ailndx> loop mt st    = catch (do forkIO (ircreader h mt)
06:56:04 <Cale> hmm
06:56:12 <ailndx> ircreader :: Handle -> ThreadId -> IO ()
06:56:12 <ailndx> ircreader h mt mainthread = do
06:56:24 <Cale> that's too many
06:56:26 <shapr> @yow
06:56:26 <lambdabot> hubub, hubub, HUBUB, hubub, hubub, hubub, HUBUB, hubub, hubub, hubub.
06:56:31 <quicksilver> should just say ircreader h mt = do
06:56:32 <Cale> remove that excess mt
06:56:40 <ailndx> well then i still get error
06:56:49 <Cale> paste the error
06:57:30 <ailndx> http://hpaste.org/1001
06:57:43 <Cale> oh
06:57:53 <Cale> it's the last line of ircreader there
06:58:01 <Cale> have to pass the mainThread along
06:59:01 <ailndx> ooh finally compiling, testing
06:59:18 <quicksilver> ailndx: do you understand why it was failing?
06:59:34 <ailndx> it works, thanks Cale
06:59:40 <Cale> no problem
06:59:48 <ailndx> quicksilver: well, i dont understand all in my program yet
06:59:53 <quicksilver> ailndx: :)
07:00:00 <ailndx> maybe half of it :)
07:00:06 <quicksilver> ailndx: but these specific errors were because cale changed ircreader to take 1 more parameter
07:00:12 <quicksilver> ailndx: and then failed to update everywhere
07:00:16 <Cale> yeah
07:00:19 <shapr> syntaxfree: You called?
07:00:34 * Cale admits to relying a bit heavily on the typechecker :)
07:01:10 <Cale> anyway, good to hear that it's working, I'm going to catch a bit of sleep
07:01:11 <quicksilver> this is why self-containted compilable pastes are preferable
07:01:20 <dons> ?time Cale
07:01:21 <lambdabot> Local time for Cale is Thu Mar 15 09:56:21
07:01:26 <quicksilver> because nice peple like Cale can actually test their corrections on their own copy of ghc
07:01:28 <dons> bed time.
07:01:33 <shapr> g'nite dons!
07:01:39 <dons> for Cale and dons.
07:01:47 <dons> since Cale lives on tokyo/sydney time
07:01:50 <Cale> @localtime dons
07:01:52 <lambdabot> Local time for dons is Fri Mar 16 01:00:50 2007
07:02:11 <shapr> I just woke up! Good morning #haskell!
07:02:17 <ailndx> Cale: heh got a tricky bugg though, the program actually exits but it dont disconnect from irc
07:02:29 <quicksilver> ailndx: it probably does, but irc doesn't notice yet
07:02:41 <quicksilver> ailndx: it probably just 'closes the connection' without issuing the polite quit message
07:02:47 <shapr> ailndx: Hey, that's a big improvement from compiling hello world yesterday.
07:02:47 <ailndx> yep it will ping out in a while
07:02:48 <quicksilver> (I would guess)
07:03:06 <Cale> so you need to add something to your disconnect handler
07:03:14 <quicksilver> Ah, he IS senting the QUIT
07:03:20 <quicksilver> but he's using print not putstr
07:03:25 <quicksilver> so it's putting quotes around it, I bet
07:03:25 <Cale> oh
07:03:32 <ailndx> shapr: ive programmed haskell like 1 day in the past, cathing up(not that i knew much then but still)
07:03:43 <quicksilver> ailndx: I suspect you need to change hPrint to hPutStr
07:03:55 <quicksilver> ailndx: 'print' is a funny function, it sends things out as haskell data types
07:04:04 <quicksilver> ailndx: which means that strings get wrapped in quotes
07:04:05 <shapr> ailndx: You're catching up quickly! Det gr bra!
07:04:22 <quicksilver> ailndx: so you were really sending "QUIT :Exiting" ...with those quotes... to the IRC server
07:04:31 <ailndx> jor hyfsat ;)
07:04:33 <shapr> ailndx: r du svensk?
07:04:51 <ailndx> ja
07:05:00 <shapr> Okej, jag bara undrar.
07:05:42 <shapr> I'll be back in Sweden in a few weeks! Yay! But I'm only visiting.
07:06:15 <ailndx> quicksilver: yeah thats probably it
07:06:25 <ailndx> so where are you now?
07:06:42 <shapr> Just nu bor jag i Birmingham, Alabama.
07:06:52 <shapr> Jag var fdd dar ocks.
07:07:05 <shapr> Well, right next door in Selma, Alabama actually, but it's close enough.
07:07:13 <ailndx> aha, lngtan tillbaka eller var det jobb som lockade?
07:07:49 <byteshack> good grief! pense que iba a entender lo que se dice en este canal ;)
07:08:15 <shapr> byteshack: Yeah, I guess I should take it to #haskell.se
07:08:29 <shapr> byteshack: Good morning byteshack!
07:08:31 <byteshack> no, it's fun :)
07:08:40 <Cale> shapr: I cracked up the other day when I read your blog post about the customer service rep who thought Sweden was a state in the US.
07:08:53 <shapr> Cale: Yeah, that was hard to believe.
07:08:57 <thief_grr> twice f x = f (f x)   Can someone explain why this has type (a -> a) -> a -> a?
07:09:17 <shapr> thief_grr: Well, what does the type a -> a mean?
07:09:38 <shapr> ailndx: I like Sweden, and I especially like my girlfriend in Stockholm.
07:09:40 <Cale> shapr: http://justelite.blogspot.com/2007/02/americans-are-not-stupid.html
07:09:42 <lambdabot> Title: Just Elite: Americans are NOT stupid, http://tinyurl.com/2cmh4f
07:09:50 <thief_grr> shapr: my problem is that it's not general enough, i'd like it to be something like  (a -> b) -> a -> b  where b is a subtype of a
07:10:05 <Cale> They managed to find some really "bright" individuals there :)
07:10:22 <shapr> thief_grr: Oh, I see.
07:10:35 <Cale> thief_grr: Haskell doesn't have subtypes.
07:10:40 <thief_grr> i don't know how to express that in haskell though
07:10:44 <thief_grr> ah, i can't then ;)
07:10:55 <chessguy> oh that video is hilarious
07:11:11 <chessguy> i love when they're pinning the numbers on the map
07:11:15 <Cale> yeah
07:11:36 <Cale> and the map has Australia labelled as North Korea
07:11:48 <chessguy> and then there was the KFC guy
07:11:49 <Cale> and the people get tricked into thinking that it's actually North Korea
07:12:00 <chessguy> well, "tricked"
07:12:09 <Cale> yeah
07:12:12 <thief_grr> is there a reason why subtypes don't exist, or they just don't?
07:12:19 <Cale> That's not something which anyone should fall for.
07:12:37 <chessguy> thief_grr, because nobody can agree on the best way to standardize their implementation
07:12:38 <Cale> thief_grr: They harm type inference
07:12:51 <Cale> "How many sides does a triangle have?" "Damn... four?"
07:13:06 <chessguy> "none!"
07:13:09 <chessguy> "1?"
07:13:31 <Botje> "a^2+b^2=c^2"
07:13:41 <thief_grr> Cale: harm it in what way?
07:13:42 <shapr> thief_grr: What are you trying to do?
07:13:47 <chessguy> "A country that starts with 'u'....Euthenasia?"
07:13:51 <thief_grr> shapr: trying to understand types and classes ;)
07:14:02 <chessguy> ?spell euthenasia
07:14:03 <lambdabot> euthanasia euthanasia's Ortensia euthenics Eugenia
07:14:06 <Cale> thief_grr: I think it becomes exponential time.
07:14:07 <quicksilver> you can, however, write twice f x = f.inject.f $ x
07:14:19 <quicksilver> where 'inject' is the injection from b back to a
07:14:23 <quicksilver> (since you said b was a subtype of a)
07:14:29 <zbrown> Anyone have any suggestions for building ghc-6.6 on a dual cpu UltraSPARC II sun?
07:14:33 <Cale> well, in a worse way than it already is
07:14:33 <quicksilver> and that will have the type you expect
07:14:36 <thief_grr> oh, by harm you mean in efficiency
07:14:40 <chessguy> Cale, i thought several record systems with subtyping had been proposed
07:14:51 <zbrown> It failed with "architecture mismatch"
07:15:05 <thief_grr> quicksilver: aha
07:15:35 <ailndx> hmpf still dont work
07:16:04 <Cale> chessguy: yeah, but the details are different
07:16:06 <gh_> hi, does haskell have something similar to python's "dict" ?
07:16:15 <Cale> gh_: Data.Map
07:16:20 <gh_> like "Array" but being able to be indexed my anything
07:16:36 <Cale> Arrays can already be indexed by quite a lot too.
07:16:46 <gh_> Cale: thanks
07:17:00 <gh_> yes but you have to give bounds when you create an array
07:17:01 <Cale> (any member of the class Ix)
07:17:06 <Cale> yeah
07:17:15 <gh_> that doesn"t make sense for most structures out there
07:17:17 <dons> > M.lookup "bar" ( M.fromList [("foo",7), ("bar",1)]) :: Maybe Int
07:17:18 <Cale> so what you want is a Data.Map
07:17:19 <lambdabot>  Just 1
07:17:30 <dons> > M.lookup "boob" ( M.fromList [("foo",7), ("bar",1)]) :: Maybe Int
07:17:31 <lambdabot>  Nothing
07:17:32 <dons> oops
07:17:35 <dons> bob
07:17:43 <Cale> heh
07:17:44 <gh_> yep
07:17:44 <gh_> :)
07:17:48 <ailndx> http://hpaste.org/1002 the hPutStr doesnt seem to work, the bot dont disconnect before the program exits
07:17:53 <gh_> thanks!
07:18:06 <Cale> ailndx: maybe hFlush h
07:18:07 <dons> ?docs Data.Map
07:18:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
07:18:21 <Cale> ailndx: just in case it's block buffered or something
07:18:48 <ailndx> do i put that just before hPutStr?
07:18:50 <Cale> or  hSetBuffering h LineBuffering
07:18:52 <Cale> after
07:19:08 <Cale> if you're setting the buffering, then when the handle is created
07:19:20 <Cale> if you're flushing the handle, then after you do the output
07:19:33 <ailndx> oki
07:19:42 <ailndx> how do i separeate those 2 functions?
07:19:51 <ailndx> "quit" -> do hPutStr h ("QUIT :Exiting\r\n") hFlush h
07:20:01 <ailndx> wait nvm
07:20:05 <Cale> the hFlush h should be on the following line
07:20:10 <Cale> you could use a ; if you want
07:21:04 <Cale> It's actually probably a good idea to set the handle to be line buffered given that it's going to be an IRC client.
07:21:42 <ailndx> okay, and that i do .. where?
07:22:00 <allbery_b> zbrown: rebuild with SplitObj=No
07:22:12 <ailndx> or wait, is that so good? what if i want to type 2 lines that should be sent as one
07:22:20 <quicksilver> Cale: explicit close should always flush
07:22:37 <Cale> ailndx: well, I suppose
07:22:44 <quicksilver> at least, that's certainly unix semantics, I'm assuming it's haskell too
07:22:57 <allbery_b> (apparently if you use SplitObj the architecture flag isn't passed on, so it dies on sparcv9 instructions.  there's a thread on glasgow-haskell-users about it)
07:23:00 <ailndx> the hFlush h, didnt work
07:23:06 <ailndx> it didnt disconnect
07:23:07 <Cale> er, okay
07:23:14 <Cale> I don't know what it is then.
07:24:01 <ailndx> well i'll try to remove the exit, and see if the disconnection function works
07:24:26 <quicksilver> ailndx: does one of the pastes have the complete source code in it?
07:24:31 <ailndx> just have to wait a few min for it to disconnect by ping first :/
07:24:40 <ailndx> quicksilver: naah
07:24:49 <quicksilver> ailndx: which one has 'most' of it?
07:25:07 * allbery_b wonders if he wants to tackle building ghc for solaris
07:25:22 <ailndx> quicksilver: that would be the dons Roll_your_own_IRC_bot, which is not exactly like mine but similar
07:25:51 * chessguy starts a pot of coffee for allbery_b
07:26:09 <quicksilver> ailndx: well I suspect you're not closing some of the handles that you open
07:26:27 <allbery_b> heh.  screen exists for a reason :)
07:26:41 <chessguy> screen?
07:26:50 <emu> to run irc sessions indefinitely!
07:26:51 <allbery_b> but actually I'm wondering where I'd find the bootstrap compiler, or if I should start from an unregisterised build
07:27:05 <chessguy> ?spell unregisterised
07:27:06 <lambdabot> unregistered unregisters unregistering
07:27:19 <allbery_b> yeh, I'd start the build on an idle sparc box under screen and let it go until it finishes.  no hurry
07:27:38 <allbery_b> chessguy: I'd spell it "unregisterized" but whoever wrote that code was a Brit :)
07:27:46 <ailndx> quicksilver: why would i need to close them?
07:27:48 <chessguy> i don't know what screen is
07:28:03 <quicksilver> ailndx: if you don't close a handle, then the final data probably wont' get printed
07:28:30 <quicksilver> ailndx: however, I think there's only one handle and you close that in your bracket
07:28:34 <quicksilver> ailndx: so that shouldn't be it
07:29:01 <quicksilver> ailndx: did you say at one point that you were using windows? doesn't windows require this funny withSocketsDo construct?
07:29:17 <allbery_b> chessguy: handy program that starts a detachable session
07:29:42 <allbery_b> @go screen
07:29:44 <lambdabot> http://www.gnu.org/software/screen/
07:29:44 <lambdabot> Title: GNU Screen - GNU Project - Free Software Foundation (FSF)
07:29:46 <quicksilver> chessguy: lets you run multiple terminal windows and reattach from them remotely
07:29:55 <ailndx> quicksilver: not that i know of
07:29:59 <ailndx> but i use win
07:29:59 <quicksilver> chessguy: I imagine it's the mechanism used by most of the people who are here 24/6
07:36:06 <miez> is it possible to download packages with darcs from hackage?
07:37:40 <allbery_b> hackage is for released packages; darcs is for development versions
07:37:53 <Philippa> ailndx: you do need withSocketsDo under windows
07:37:54 <chessguy> interesting
07:37:59 <ailndx> gaah seems i did all these changes for no purpose, changing from hPrint to hPutStr actually disconnects and exists the program :/
07:38:01 <Philippa> really you need it everywhere, it just happens to work under *nix without
07:38:49 <ailndx> Philippa: i dont use it in win, and it works for me
07:40:13 <miez> allbery and how is cabal-install supposed to work? actually that's what i am trying to try out :)
07:40:46 <Philippa> ailndx: hrmm, point. Thinking about it I've done so recently as well
07:40:46 <ailndx> Philippa: so no i dont need it under windows
07:41:05 <Philippa> however, certainly it used to be that all sockets code /should/ happen within a withSocketsDo
07:41:42 <Philippa> also, it might not work under other implementations
07:42:46 <quicksilver> dons: Is specConstr the following? : For (f a), if we can statically determine that a necessarily is of the form Foo b, and the top-level of f is a case on a, then generate a 'direct jump' into that case, like f_Foo b ?
07:45:05 <thief_grr> is there any difference other than looks, between  a -> b -> a  and  a -> (b -> a)  ?
07:45:44 <quicksilver> thief_grr: no
07:45:51 <quicksilver> thief_grr: they are exactly the same
07:46:03 <quicksilver> thief_grr: ghc's pretty printer will omit the brackets
07:46:15 <quicksilver> thief_grr: most people omit the brackets unless to emphasise something
07:46:20 <thief_grr> quicksilver: ok, that's what i thought, hutton's book got me confused :)
07:46:34 <allbery_b> miez: I don't know but I p[resume it downloads and unpacks tarballs
07:46:40 <thief_grr> ah ok, i guess he wanted to emphasize that it returns a function
07:46:42 <allbery_b> much like cpan, ruby-gems, etc.
07:46:44 <quicksilver> not possible! Hutton is the chosen priest and his words are not to be questioned
07:46:47 * quicksilver nods
07:46:52 <quicksilver> yes, for emphasis it's handy
07:46:52 <thief_grr> but it seems pretty obvious without the parentheses..
07:46:55 <mux> the version with parens emphasizes the fact that in haskell function are curried
07:47:01 <quicksilver> only to someone who is used to it :)
07:47:02 <thief_grr> it is?
07:47:09 <mux> and that partial application would yield a new function
07:47:12 <quicksilver> thief_grr: to other people, it might mean (a->b) -> a
07:47:18 <quicksilver> thief_grr: you don't know which, until you've been told
07:47:48 <thief_grr> quicksilver: ok, it's just that it's one ofthe very first things he says, that -> associates to the right, and now 3 chapter laters, he uses parentheses again ;)
07:47:56 <thief_grr> quicksilver: it's for emphasis indeed, thanks
07:48:03 * quicksilver nods
07:48:18 <quicksilver> and because not all students are as retentive as you appear to be :)
07:48:24 <quicksilver> I've told many students that things are right associative
07:48:34 <quicksilver> they don't necessarily recall that 3 chapters later :)
07:48:46 <thief_grr> heheh
07:49:40 <mux> they don't recall what?
07:49:42 <mux> j/k :)
07:50:13 <yonkie> sorry. can I use GHC to produce C output while compiling .hs?
07:50:41 <quicksilver> yes
07:51:10 <thief_grr> and another beginner question:  in defining functions like:  fst (x, _) = x  it is sure nicer than  f (x, y) = x, since it makes apparent that i wont use the second arguement anywhere
07:51:19 <thief_grr> is there an important internal difference?
07:51:29 <Botje> yes, the y doesn't get bound, ergo, faster
07:51:29 <quicksilver> yonkie: http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#keeping-intermediates
07:51:31 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/2y3hr6
07:51:43 <Botje> although i'm sure ghc can see it on its own
07:51:49 <norpan> the generated code will be exactly the same
07:51:56 <quicksilver> 'get bound' doesn't really mean much I don't think
07:51:59 <yonkie> quicksilver: thanks!
07:52:04 <norpan> although you can get ghc to warn with -fwarn-unused-bind or whatever
07:52:08 <thief_grr> Botje: but does this really cost something?
07:52:16 <quicksilver> haskell doesn't have a mapping of variable names to thunks at run time
07:52:21 <quicksilver> thief_grr: I very much doubt it
07:52:30 <thief_grr> ok, so it's just prettier
07:52:47 <norpan> it's prettier and avoids the warning
07:52:58 <thief_grr> what warning?
07:53:08 <thief_grr> nobody warned me :(
07:53:09 <norpan> the warning you get if you enable warnings for unused binds
07:53:11 <thief_grr> ghc?
07:53:19 <thief_grr> aha ok
07:53:21 <thief_grr> nice then
07:54:27 <norpan> -W turns it on
07:55:24 <kzm> Help!  I'm trying to install mtl, from "http://darcs.haskell.org/packages/mtl/".  Running Setup.lhs tries to grab an X window?!
07:55:35 <narain> @unpl \x -> f x && g x
07:55:35 <lambdabot> \ x -> (f x) && (g x)
07:55:40 <kzm> What on earth is wrong here?
07:55:41 <narain> @pl \x -> f x && g x
07:55:41 <lambdabot> liftM2 (&&) f g
07:56:39 <norpan> actually, thatwarning is called -fwarn-unused-matches
07:56:46 <norpan> but it is part of -W
07:56:49 <kzm> Ah, I got it.
08:00:23 <kzm> Prelude> :m + Test.QuickCheck
08:00:23 <kzm> module main:Test.QuickCheck is not loaded
08:00:23 <kzm>  -- what does this mean?
08:01:04 <kzm> Oh, I'm in that directory.
08:01:08 <kzm> Never mind.
08:11:52 <narain> ?hoogle (a -> a -> b) -> m a -> m b
08:11:53 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
08:11:54 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
08:12:56 <resiak> @pl \f x -> f x x
08:12:57 <lambdabot> join
08:13:13 <quicksilver> narain: what are you hoping for?
08:13:24 <quicksilver> @type liftM join
08:13:26 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => m1 (m (m a)) -> m1 (m a)
08:13:44 <quicksilver> @type liftM join :: (Monad m) => (a -> a -> b) -> m a -> m b
08:13:46 <lambdabot>     Couldn't match expected type `b' (a rigid variable)
08:13:46 <lambdabot>            against inferred type `a -> a1'
08:13:58 <quicksilver> @type liftM.join :: (Monad m) => (a -> a -> b) -> m a -> m b
08:14:00 <lambdabot> (Monad m) => (a -> a -> b) -> m a -> m b :: forall a b (m :: * -> *). (Monad m) => (a -> a -> b) -> m a -> m b
08:14:32 <quicksilver> :t liftM.join
08:14:34 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => (a1 -> a1 -> a) -> m a1 -> m a
08:15:23 <bakert> ?seen ekarttun
08:15:23 <lambdabot> I haven't seen ekarttun.
08:15:42 <bakert> Has anyone built/used hsgnutils successfully?
08:16:01 <bakert> I can't build the required network-alt library: http://www.cs.helsinki.fi/u/ekarttun/network-alt/
08:16:03 <lambdabot> Title: network-alt
08:16:03 <bakert> Gives me:
08:16:15 <bakert> Setup.lhs:15:42:
08:16:15 <bakert>     Couldn't match expected type `Maybe Distribution.Simple.LocalBuildInfo.LocalBuildInfo
08:16:28 <bakert> Any clues?
08:16:45 <narain> quicksilver: thanks, i was just looking for something to do  liftM2 f m m
08:16:59 <narain> anyway i just wrote that out explicitly
08:18:12 <kc5tja> bakert: I haven't heard of that library, sorry.
08:18:40 <bakert> It's a wrapper for gnutls which is the GNU TLS libraries.  For doing SSL amongst other things.
08:18:44 <narain> hey, join (liftM2 f) works, thanks resiak
08:19:04 <resiak> narain: yeah, quicksilver showed that (liftM . join) had the type you wanted
08:19:06 <bakert> I just need to send a few simple HTTP requests to SSL-enabled sites.  But Network.Browser only seems to work for the odd one.
08:19:33 <narain> resiak: oh, didn't see that. neat
08:19:37 <bakert> Now I'm thinking of writing a python program to do it and calling that.  Yuk!
08:19:51 <resiak> narain: that's what I thought.  I didn't know if join worked here, but I guess it does!
08:20:17 <resiak> > (liftM . join) (*) (Just 5)
08:20:18 <lambdabot>  Just 25
08:20:54 <narain> hmm, doesn't quite do what i want on lists
08:21:02 <narain> > (liftM . join) (*) [1..3]
08:21:03 <lambdabot>  [1,4,9]
08:21:16 <narain> > join (liftM2 (*)) [1..3]
08:21:17 <lambdabot>  [1,2,3,2,4,6,3,6,9]
08:22:27 <ToRA> how/can  you reference an import qualified infix function?
08:22:27 <narain> clearly a type is not a complete specification :)
08:22:58 <EvilTerran> :type (Prelude.*)
08:23:29 <narain> ?type (Prelude.*)
08:23:31 <lambdabot> forall a. (Num a) => a -> a -> a
08:23:36 <EvilTerran> > (Prelude.*) 6 9
08:23:38 <lambdabot>  54
08:23:39 <narain> ?type Prelude.*
08:23:41 <lambdabot> parse error on input `Prelude.*'
08:23:52 <ToRA> e.g. I have import qualified Text.ParserCombinators.Parsec as P;
08:23:52 <EvilTerran> gotta bracket your infixes
08:23:57 <ToRA> how would i reference <|>
08:24:02 <EvilTerran> (P.<|>)
08:24:14 <EvilTerran> as a prefix fn
08:24:17 <ToRA> ah yeah
08:24:21 <ToRA> excellent cheers
08:24:50 <narain> no way to use qualified operators as infixes?
08:25:08 <kc5tja> narain: I've used `B.append` plenty of times.
08:25:10 <EvilTerran> altho it seems to me that, eg, Prelude.(*) and so forth would make more sense, this is the way haskell does it
08:25:21 <narain> hmm
08:25:31 <EvilTerran> > 6 `(Prelude.*)` 9
08:25:32 <lambdabot>  Parse error
08:25:32 <narain> > 6 `(Prelude.*)` 9
08:25:32 <lambdabot>  Parse error
08:25:35 <EvilTerran> hehe
08:25:40 <narain> heh
08:26:09 <EvilTerran> can't put anything but an identifier in ``s, and the ()s make it an expression rather than an ident, i guess
08:26:32 <quicksilver> > 6 Prelude.* 9
08:26:34 <lambdabot>  54
08:26:45 <EvilTerran> oh! didn't know you could do that...
08:26:48 <quicksilver> ToRA: just P.<|> infix,
08:26:51 <narain> huh
08:26:58 <EvilTerran> that's weird...
08:26:59 <quicksilver> ToRA: (P.<|>) prefix
08:27:01 <narain> well then!
08:27:35 <quicksilver> although I have sometimes wished you could put expressions inside ``
08:27:45 <quicksilver> it's annoying to find non-compositionalities in your language
08:27:53 <ToRA> mmm
08:27:57 <quicksilver> one of the good things about haskell is how compositional it is
08:28:33 <ToRA> mmm ghc can't derive show for data types with no constructors
08:28:34 <ToRA> :(
08:29:25 <quicksilver> what's a data type with no constructors?
08:29:29 <ToRA> data Foo
08:29:38 <quicksilver> it doesn't have any members
08:29:44 <quicksilver> how would you like to Show it? :P
08:29:52 <quicksilver> you'll never actually have anything to show....
08:29:56 <ToRA> exactly
08:30:09 <ToRA> so you know that you'll never actually need to call the function
08:30:10 <quicksilver> so, why do you want to be able to show it when you clearly can't?
08:30:17 <quicksilver> hmm
08:30:21 <ToRA> so i'm incrementally developing code
08:30:27 <quicksilver> I suppose that's one way of looking at it :P
08:30:48 <ToRA> and i could have a Blah { someFoos :: [Foo] }
08:30:57 <ToRA> but i don't know what foo is, but i know that someFoos must exist
08:31:11 <resiak> data Foo = Foo () ?
08:31:36 <ToRA> resiak: yeah, that's a solution
08:31:43 <EvilTerran> or data Foo = Foo
08:31:50 <resiak> heh, yeah
08:32:06 <quicksilver> data Foo = Oof
08:32:31 <ToRA> i wouldn't mind, except it's perfectly valid to write
08:32:35 <ToRA> instance Show Foo where
08:32:38 <ToRA> and leave it blank
08:32:51 <matthew_-> ToRA: sign cate please
08:42:28 <bakert> I think I've made a decision.
08:42:45 <bakert> I'm going to call wget from my haskell program to get around the lack of SSL in Network.Browser.
08:42:58 <bakert> Hideous?  Yes.  Effecive?  Hopefully.
08:43:09 <bakert> Anyone got any idea how I go about that?
08:43:10 <kc5tja> There is some precedent -- darcs uses Curl.
08:43:28 <bakert> wahey.  i am not so evil as i first though!
08:43:31 <bakert> *thought
08:43:50 <ailndx> dons: so how would i go to use eval and runplugs, do i have to build them first(runplugs includes a main)?
08:43:53 <quicksilver> bakert: you could also post a message to -cafe explaining that you've had to do that
08:44:07 <quicksilver> bakert: that might (a) motivate someone to go fix the SSL stuff
08:44:20 <quicksilver> bakert: or even (b) make someone pipe up with a working SSL library they have hidden away somewhere
08:45:40 <bakert> quicksilver, ok good idea.
08:46:27 <ndm> @seen malcolmw
08:46:27 <lambdabot> malcolmw is in #ghc, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell. I last heard malcolmw speak 3h 54m 20s ago.
08:46:43 <ndm> ping malcolmw
08:46:52 <malcolmw> ndm: pong
08:46:59 <ndm> http://www.indiegigs.co.uk:8010/windows/builds/89/step-yhc%20release/0
08:47:01 <lambdabot> Title: Log File contents, http://tinyurl.com/2folqw
08:47:10 <ndm> malcolmw: ^^ your recent changes to cpphs broke Yhc
08:47:30 <malcolmw> ndm: sorry, can't see non-standard http ports like 8010 through the dept firewall
08:47:45 <ndm> malcolmw: it never worked compiling it with ghc with -cpp, but now even trying to get the dependancies fails
08:47:53 <ndm> @paste
08:47:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:48:04 <Igloo> ndm: Is the warning colouring a standard buildbot thing?
08:48:32 * malcolmw wishes buildbot used a standard port 80
08:48:53 <ndm> Igloo: no idea - i had assumed they were
08:49:04 <Igloo> Oh, you didn't enable it explicitly then?
08:49:06 <quicksilver> I wonder if it's sensible to ask for syntax with 'holes' as a shortcut to lambdas
08:49:20 <quicksilver> so instead of writing \x y z -> f (g x y) z
08:49:21 <ndm> malcolmw: is it only because you're using the wireless?
08:49:26 <quicksilver> you could write f (g # #) #
08:49:29 <ndm> quicksilver: what does a hole look like?
08:49:33 * Igloo can give ndm some apache config to proxy the buildbot pages through an apache on port 80, if that would be helpful
08:49:41 <quicksilver> ndm: some uniform (single character) marker, I guess
08:49:46 <ndm> quicksilver: how do you say that hole 1 and 2 are both the same hole?
08:49:47 <malcolmw> ndm: not wireless, just user-administered
08:49:55 <ndm> i.e. \x -> f x x
08:49:56 <quicksilver> ndm: you can't, in draft one
08:50:10 <malcolmw> Igloo: last I looked, the ghc buildbot was on 8010 as well
08:50:10 <quicksilver> ndm: you could number the holes but that is almost as verbose as lambdas
08:50:27 <quicksilver> ndm: I was just trying to win a little conciseness with a little suger
08:50:27 <vincenz> ndm: you numbr the holes
08:50:28 <twanvl> Where does a hole end? is map (f #)  equal to \x -> map (f x) or to map (\x -> f x)?
08:50:31 <Igloo> malcolmw: http://darcs.haskell.org/buildbot/
08:50:33 <lambdabot> Title: GHC BuildBot
08:50:35 <vincenz> f #1 #1
08:50:36 <vincenz> :D
08:50:42 <vincenz> and then you make it flexible
08:50:50 <vincenz> so you can say ahich parameter is which number:
08:50:55 <quicksilver> twanvl: oh. that's the important question
08:50:55 <ndm> Igloo: you'd have to ask our buildbot guy, i was actually expecting him to be in today...
08:50:59 <vincenz> holed #1 -> f #1 #1
08:51:02 <quicksilver> twanvl: I knew there was something :)
08:51:04 <quicksilver> vincenz: :P
08:51:18 <ndm> Igloo: i think we're fine with our buildbot on port 8010, its only because our department doesn't like mac's :)
08:51:31 <vincenz> quicksilver: D
08:51:32 <vincenz> :D
08:51:49 <ndm> malcolmw: http://hpaste.org/1003#a0
08:51:55 * ndm was expecting that to be announced...
08:51:55 <malcolmw> Igloo: I can see it!
08:51:58 <Igloo> ndm: Ah, it's stderr stuff. For some reason the GHC builds all appear as stdout
08:52:01 <quicksilver> twanvl: i forgot that the lambda was a scoper as well as a binder
08:52:05 <quicksilver> speaking loosely
08:52:09 <ndm> Igloo: that is weird
08:52:19 <malcolmw> Igloo: I can see a whole page of white space!
08:52:34 <Igloo> malcolmw: Scroll right a bit  :-)
08:52:58 <LPhas> Hi, someone could suggest me a way to get the CPU load in haskell?
08:53:06 <ndm> @hoogle cpu
08:53:06 <lambdabot> CPUTime.cpuTimePrecision :: Integer
08:53:06 <lambdabot> CPUTime :: module
08:53:06 <lambdabot> CPUTime.getCPUTime :: IO Integer
08:53:11 <malcolmw> Igloo: is that the best place to put the more heavily used bots? :-)
08:53:12 <ndm> LPhas: ^^
08:53:40 <Igloo> malcolmw: The 6.6 and head pages fit in a browser's width (for me at least)
08:53:58 <Igloo> Also, I'm working on a nightly collated report thingy which should reduce the need to look at the page so much
08:54:22 <ailndx> is there any implemented way to format getClockTime/diffClockTimes?
08:54:27 <Igloo> ndm: Is your main building dong with a ShellCommand?
08:54:28 <ndm> Igloo: we have a report everytime a build goes from success to failure
08:54:35 <ndm> Igloo: no idea
08:54:35 <malcolmw> Igloo: so they do.  I looked at 'all' first though
08:54:36 <LPhas> ndm: these are for the current process
08:54:44 <LPhas> ndm: i need for the whole system
08:54:53 <ndm> Igloo: hit the mailing list if you want any deep buildbot answers
08:54:59 <ndm> LPhas: no idea then
08:55:29 <LPhas> oh, damn
08:55:56 <malcolmw> ndm: I was wondering if the cpphs fixes wouuld break anything
08:56:06 <ndm> malcolmw: answer, yes :)
08:56:13 <malcolmw> ndm: but my nhc98 nightly builds were absolutely fine with it
08:56:21 <ndm> malcolmw: they obviously don't pass -cpp
08:56:39 <ndm> malcolmw: that never worked (ghc -cpp to compile it), but now even dependency checking doesn't work
08:56:41 <malcolmw> ndm: they more assuredly do, all over the place
08:56:58 <ndm> malcolmw: ghc -cpp Tokenise.hs has never worked for me?
08:57:04 <malcolmw> if ghc -cpp doesn't work, then you mist be using bad cpp directives
08:58:00 <malcolmw> ndm: oh wait, are you claiming that ghc can't compile cpphs?
08:58:18 <ndm> malcolmw: it can't copmile it if you pass -cpp
08:58:19 <ndm> `ghc -M -optdep-f -optdepsrc\compiler98\.Main.hs.dep -cpp -DyhcVERSION=\"0.7.0-20070315025737\"  -i./src/compiler98:./src/libraries/general:./src/libraries/core:depends/cpphs:depends/filepath:./src/interactive src\compiler98\Main.hs
08:58:28 <ndm> when sending that, it doesn't work
08:59:09 <malcolmw> the command line confuses me - it is building compiler98, not cpphs?
08:59:55 <JohnnyL> x = map (+) [1..5]
09:00:00 <JohnnyL> >x = map (+) [1..5]
09:00:10 <JohnnyL> @\x = map (+) [1..5]
09:00:10 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
09:00:17 <malcolmw> ndm: oh, I see.  that was entirely intentional
09:00:21 <ndm> malcolmw: it is doing -M (generate a make file) starting with the compiler as the root
09:00:46 <malcolmw> ndm: Tokenise.hs has an infix Haskell function called */*
09:00:59 <malcolmw> which "real" cpp breaks on
09:01:07 <quicksilver> JohnnyL: like this
09:01:11 <quicksilver> > map (+) [1..5]
09:01:12 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
09:01:18 <quicksilver> JohnnyL: you need a > and a space
09:01:24 <JohnnyL> quicksilver, thanks man.
09:01:42 <malcolmw> ndm: it was intended as an illustration of why cpp is bad, and cpphs is marginally better
09:02:04 <hpaste> > map (+) [1..5] `ap` [6]
09:02:06 <lambdabot>  [7,8,9,10,11]
09:02:16 <quicksilver> wtf?
09:02:29 <quicksilver> we have a puppeteer!
09:02:40 <ndm> malcolmw: yes, i know - but it appears you've gone from an even number of*/* to an odd number, which breaks even the basic parser
09:02:51 <malcolmw> ndm: ho ho
09:03:17 <malcolmw> these delicate parsing tools that can't cope with a little bit of real haskell :-)
09:03:42 <ndm> i know, but we need to get it fixed some how
09:03:48 <quicksilver> the macro-expansion part of cpp should never have been folded in with the comment-parsing part
09:03:52 <thief_grr> Some more basic questions..  http://hpaste.org/1004#a0
09:03:54 <JohnnyL> what hapens when you apply a data type in place of the function in map?
09:04:07 <quicksilver> JohnnyL: well you can't really 'apply' a data type
09:04:08 <thief_grr> about the "where", i completely understand it in the second definition
09:04:08 <ndm> and we have to use -cpp by this point, since this is the stage where we compile cpphs
09:04:16 <thief_grr> but the first one, which is from hutton's book seems confusing
09:04:17 <quicksilver> JohnnyL: but you can apply a constructor
09:04:22 <quicksilver> > map Just [1..5]
09:04:24 <lambdabot>  [Just 1,Just 2,Just 3,Just 4,Just 5]
09:04:54 <malcolmw> ndm: cpphs does not contain any #define's - for obvious reasons
09:05:04 <quicksilver> thief_grr: sorry, which one are you unsure about?
09:05:05 <thief_grr> and the second question is, if the 3rd and 4th definition are the exact same thing with a different notation, of if there is an internal difference
09:05:19 <malcolmw> ndm: so you really don't need the -cpp option
09:05:40 <thief_grr> quicksilver: hutton uses the "where f x = ..." this is confusing.  I understand it the way i wrote it with lambda
09:05:41 <ndm> malcolmw: yes, its the unfortunate part of our build system that cpphs is simply included, not copmiled separately, as is filepath, which requires cpp
09:05:45 <JohnnyL> quicksilver: what does http://hpaste.org/1005 do with (DBItem "") ?
09:05:49 <malcolmw> ndm: although maybe you need it elsewhere in the compiler
09:06:01 <ndm> malcolmw: not in the compiler, i compiler is intentionally 100% pure
09:06:05 <quicksilver> thief_grr: well they are two ways of saying the same thing
09:06:20 <malcolmw> well now, I would class that as a bug in ghc -cpp then
09:06:21 <quicksilver> thief_grr: f x = ... says "f is a function which takes one parameter, x..."
09:06:45 <quicksilver> thief_grr: f = \x -> ... says "f is a value which happens to be a lambda-expression, which is expecting one parameter x"
09:06:50 <malcolmw> after all, hmake is able to detect whether a file needs cpp or not, so ghc --make ought to do the same
09:07:14 <quicksilver> JohnnyL: DBItem is a function String -> Int -> DBItem
09:07:26 <quicksilver> JohnnyL: give it a String, and an Int, it gives you a DBItem
09:07:33 <thief_grr> quicksilver: it's just that up to now, it seems that "where" needs values, so i can just accept that it can handle and understand arbitrary functions as well?
09:07:38 <malcolmw> ndm: which reminds me - have you tried using hmake -M in preference to ghc -M ?
09:07:56 <malcolmw> ndm: oh of course - hmake doesn't work on windows
09:08:01 <quicksilver> JohnnyL: if you partially apply it, in (DBItem "") then it's of type Int -> DBItem
09:08:09 <ndm> malcolmw: indeed :)
09:08:17 <quicksilver> JohnnyL: it's expecting one more value, of type Int, to give you a DBItem
09:08:18 <malcolmw> (at least not with visual studio - it is fine in mingw/cygwin)
09:08:21 <ndm> malcolmw: our new build system would fix this, since it compiles each project separately
09:08:27 <ndm> malcolmw: mingw is not windows!
09:08:33 <quicksilver> thief_grr: there isn't really an important difference between functions and values
09:08:51 <thief_grr> quicksilver: that's what i thought, and this is why this usage of where is confusing..
09:08:51 <quicksilver> thief_grr: there is no different between the kind of thing you can write in a 'where' and the kind of thing you can write at the top level
09:08:56 <eddyp_> is there a listing somewhere with the functions from each deaful library?
09:09:01 <eddyp_> default, even
09:09:15 <quicksilver> eddyp_: http://haskell.org/ghc/docs/latest/html/libraries/
09:09:37 <eddyp_> quicksilver: thanks
09:09:42 <quicksilver> thief_grr: those two different versions of f are equivalent and 'where' doesn't care which you use
09:10:11 <quicksilver> thief_grr: since you write "odds n = " at the top level you can write "where f x = " in a where clause :)
09:10:23 <thief_grr> quicksilver: "there is no different between the kind ..." <- that's what i needed ;)
09:10:36 <JohnnyL> quicksilver : so DBItem 2 would be String-> DBItem ?
09:10:46 <quicksilver> JohnnyL: no, because the order matters
09:10:53 <JohnnyL> quicksilver, oh, tricky.
09:10:54 <quicksilver> JohnnyL: DBItem expects the string first
09:11:05 <quicksilver> JohnnyL: however you can write \s -> DBItem s 2
09:11:11 <quicksilver> JohnnyL: this has type String -> DBItem
09:11:27 <malcolmw> ndm: I count an even number of */* in Tokenise.hs now, so it ought to be OK
09:11:40 <ndm> malcolmw: it must be something like that...
09:12:49 <thief_grr> quicksilver: http://hpaste.org/1004#a1  had no idea i could "abuse" where like that.. ;)
09:13:24 <quicksilver> thief_grr: right :)
09:13:37 <malcolmw> ndm: theory: a usage of */* on a line which has a '\\' preceding it on the same line, might not count as a comment begin/end :-)
09:13:45 <thief_grr> about the two final definitions of "odds", is there any internal difference?
09:13:51 <malcolmw> ndm: oh the joy of cpp!
09:14:00 <quicksilver> thief_grr: in a sense, that depends on the compiler
09:14:00 <ndm> malcolmw: yeah, i guess its going to be something screwy...
09:14:18 <quicksilver> thief_grr: the second doesn't desugar to quite the same thing as the first
09:14:28 <ndm> malcolmw: {- \n #ifdef 0 -} - wrap the code in that?
09:14:30 <quicksilver> thief_grr: the compiler should produce very similar code though
09:15:57 <malcolmw> ndm: gcc -E -x c confirms my theory was right
09:16:17 <ndm> malcolmw: so would you mind fixing this? despite the fix is a 100% hackfest...
09:18:43 <malcolmw> ndm: can't you just darcs apply a local patch (store the patch in the yhc tree)
09:18:52 <ndm> malcolmw: thats a pain
09:19:15 <ndm> malcolmw: plus its just waiting for a conflict - having long term patches to our libraries is something we are trying to avoid
09:19:29 <ndm> (hence things like the submission of zeroText to libaries@)
09:22:15 <malcolmw> ndm: patch pushed :-)
09:22:58 <ndm> malcolmw: cheers, i've restarted the buildbot, so will let you know success or failure in 10 mins
09:26:11 <Igloo> malcolmw: Do you mean that even if hmake is told to use cpp it will only do so if it thinks it is necessary?
09:26:17 <thief_grr> quicksilver: "the second doesn't desugar to quite the same thing as the first" <- can you explain in what sense they differ?
09:26:52 <quicksilver> thief_grr: semantically they are the same (I think)
09:27:03 <quicksilver> thief_grr: in practice they use slightly different combinations of library functions
09:28:05 <quicksilver> thief_grr: the last one translates to [0..n-1] >>= (\m -> return (m*2+1))
09:28:10 <thief_grr> quicksilver: is there a way to break down any function computation into a primitive step-by-step computation?
09:28:10 <malcolmw> Igloo: exactly - it looks for # directives in the file, and only adds the -cpp option to the compiler if it finds them
09:28:27 <quicksilver> thief_grr: in a technical sense 'yes, obviously; that's what the compiler does'
09:28:39 <malcolmw> Igloo: just one of the ways in which hmake is still better than ghc --make :-)
09:28:50 <thief_grr> quicksilver: heh i meant kinda more interactively, maybe within hugs or something
09:28:54 <quicksilver> thief_grr: no
09:28:58 <ndm> @karma++ malcolmw -- for fixing bugs that are entirely arbitrary, and not really his fault
09:28:58 <lambdabot> malcolmw's karma raised to 1.
09:29:22 <thief_grr> quicksilver: aha ok, would be useful ;)  and i haven't met the " >>= " symbol yet, so i'll just write it down for now to check later
09:29:26 <thief_grr> quicksilver: thanks again
09:29:27 * ndm would have suspected malcolmw's karma to be higher than that
09:29:41 <thief_grr> quicksilver: btw, this "return" you typed is a mistake, right?
09:29:43 <quicksilver> thief_grr: in the case of lists, >>= is concatMap
09:30:06 <quicksilver> so it becomes concatMap (\m -> return (m*2+1)) [0..n-1]
09:30:18 <quicksilver> and return is really \x -> [x]
09:30:24 * malcolmw doesn't want high karma if it is *bad* karma
09:30:34 <quicksilver> so it's concatMap (\m -> [m*2+1]) [0..n-1]
09:30:46 <quicksilver> thief_grr: and concatMap is really just concat.map
09:30:53 <quicksilver> thief_grr: and now it's looking rather similar :)
09:31:04 <quicksilver> > map (\m -> [m*2+1]) [0..n-1]
09:31:04 <lambdabot>   Not in scope: `n'
09:31:05 <hpaste> in the case of lists, (=<<) is concatMap
09:31:16 <quicksilver> > map (\m -> [m*2+1]) [0..8-1]
09:31:17 <lambdabot>  [[1],[3],[5],[7],[9],[11],[13],[15]]
09:31:26 <quicksilver> hpaste: well yes, I did a switch without admitting it :P
09:31:46 <quicksilver> thief_grr: finally that concat strips off the extra level of brackets
09:31:56 <quicksilver> > concat [[1],[3],[5],[7],[9],[11],[13],[15]]
09:31:57 <lambdabot>  [1,3,5,7,9,11,13,15]
09:32:18 <quicksilver> thief_grr: so it's the same, but where it produces exactly the same machine code is up to the compiler...
09:34:06 <Igloo> malcolmw: If I ran hmake -cpp then I'd be quite upset if it didn't run cpp. I might want it to do line continuation stuff, for example
09:34:29 <malcolmw> Igloo: hmake doesn't have a -cpp option
09:34:46 <Igloo> Ah, OK
09:34:56 <malcolmw> Igloo: you can always put {-# OPTIONS -cpp #-} at the top of your file if that's what you want
09:35:16 <malcolmw> Igloo: (or does ghc still not get that right either? :-)
09:36:28 <Igloo> Not sure OTTOMH
09:36:51 <roconnor> > (\m -> [m*2+1]) =<< [0..8-1]
09:36:52 <lambdabot>  [1,3,5,7,9,11,13,15]
09:36:57 <glguy> "(And even this improvement wasn't universally appreciated: some people found error messages they couldn't ignore more annoying than wrong results, and, when judging the relative merits of programming languages, some still seem to equate "the ease of programming" with the ease of making undetected mistakes.)" -- http://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD667.html
09:36:58 <dufflebunk> Yeah, well ICSTRCLT
09:37:00 <lambdabot> Title: E.W.Dijkstra Archive: On the foolishness of "natural language programming". (EWD ..., http://tinyurl.com/2eh4ud
09:37:09 <thief_grr> quicksilver: ok thanks :)
09:37:33 <kc5tja> > [ (2*x)+1 | x <- [0..7]]
09:37:35 <lambdabot>  [1,3,5,7,9,11,13,15]
09:37:48 <roconnor> > [1,3..15]
09:37:50 <lambdabot>  [1,3,5,7,9,11,13,15]
09:38:17 <kc5tja> phssht.
09:38:23 <kc5tja> > [1,3,5,7,9,11,13,15]
09:38:24 <lambdabot>  [1,3,5,7,9,11,13,15]
09:38:33 <kc5tja> Oh yeah -- PH34R m3.  :)
09:38:44 <merus> lol.
09:38:45 <roconnor> > 1:3:5:7:9:11:13:15:[]
09:38:46 <glguy> > take 8 $ fix (1:map(+2))
09:38:46 <lambdabot>  Couldn't match expected type `[t]'
09:38:47 <lambdabot>  [1,3,5,7,9,11,13,15]
09:38:58 <waern> dcoutts_, ping
09:39:03 <glguy> > take 8 $ fix ((1:).map(+2))
09:39:04 <lambdabot>  [1,3,5,7,9,11,13,15]
09:39:08 <dufflebunk> > :t fix
09:39:09 <lambdabot>  Parse error
09:39:20 <mux> @type fix
09:39:22 <lambdabot> forall a. (a -> a) -> a
09:39:29 <mux> @src fix
09:39:29 <lambdabot> fix f = let x = f x in x
09:40:11 <roconnor> fix f = f (f (f (f (f (f ...)))))
09:40:24 <glguy> > iterate (succ.succ) 1
09:40:25 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
09:40:47 <roconnor> @pl \s -> s . s
09:40:47 <lambdabot> join (.)
09:40:59 <EvilTerran> would that defn of fix be the same as
09:40:59 <glguy> > iterate (join (.) succ) 1
09:41:00 <quicksilver> > map head . iterate (drop 2) $ [1..]
09:41:00 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
09:41:01 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
09:41:04 <EvilTerran> fix f = let y = f x in y
09:41:17 <EvilTerran> and if not, why not?
09:41:23 <kc5tja> [1,4,9..]
09:41:26 <quicksilver> because that's a recursively bound 'x' there
09:41:28 <kc5tja> > [1,4,9..]
09:41:29 <lambdabot>  Parse error
09:41:31 <kc5tja> doh.
09:41:32 <kc5tja> ;)
09:41:40 <roconnor> > [1,4..]
09:41:41 <lambdabot>  [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,...
09:41:44 <EvilTerran> er. okay.
09:41:47 <quicksilver> as in left fact n = if n==0 then 1 else n * (fact (n-1))
09:42:05 <quicksilver> that fact there is recursive, it refers to the definition itself
09:42:21 <EvilTerran> oh, wait, i see. ignore me
09:42:33 <EvilTerran> wait, how does that even work?
09:42:39 <roconnor> *l*
09:42:47 <quicksilver> how does it work operationally?
09:42:51 <EvilTerran> yeah.
09:43:00 <quicksilver> it just ties a loop into the evaluation graph
09:43:13 <quicksilver> when it gets back to the inner 'fact' it "jumps " to the outer fact
09:43:17 <EvilTerran> it actually calls the function repeatedly on its return value until it stops changing?
09:43:22 <quicksilver> just like a subroutine calling itself in C
09:43:24 <EvilTerran> not fact, fix.
09:43:34 <glguy> > (fix $ \f n -> if n == 0 then 1 else n * f (n-1) ) 5
09:43:34 <quicksilver> no, not until it stops changing
09:43:35 <lambdabot>  120
09:43:43 <quicksilver> it keeps calling it *forever*
09:43:53 <EvilTerran> operationally?
09:43:54 <glguy> which, in a lazy language
09:43:57 <glguy> might not be that long
09:44:02 <quicksilver> but hopefully the form of the function is such like it produces some values
09:44:06 <quicksilver> in finite time ;)
09:44:10 <EvilTerran> ah, i see.
09:44:14 <quicksilver> look at the 'fact' example
09:44:23 <quicksilver> it terminates because evantually it goes down the 0 branch
09:44:28 <quicksilver> which doesn't contain a recursive call
09:44:41 <glguy> quicksilver: there is no recursion there :-p
09:44:52 <quicksilver> hopefully the function you take a fixed point of also has some kind of 'base case' behaviour
09:44:55 <glguy> in a manner of speaking :)
09:44:56 <quicksilver> glguy: there is, in my version
09:45:00 <glguy> oh, ok
09:45:27 <quicksilver> alternatively it could exhibit co-data behaviour; which is to continue producing data forever which is lazily consumed
09:45:43 <quicksilver> as in fix (1:)
09:45:46 <quicksilver> > fix (1:)
09:45:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:46:00 <EvilTerran> ahhhhhhh.
09:46:02 <quicksilver> as long as it is a 'good producer' that's OK too
09:46:04 <EvilTerran> now i get it.
09:46:29 <EvilTerran> "let x = f x" is like "let x = 1:x" and suchlike.
09:46:35 <quicksilver> yes
09:46:47 <EvilTerran> *lightbulb moment*
09:46:48 <quicksilver> let fix f = let x = f x in x.
09:46:57 <quicksilver> now substititue (1:) into that
09:47:02 <quicksilver> fix (1:) = let x = 1:x in x
09:47:16 <quicksilver> > let x = 1:x in x
09:47:17 <roconnor> fix ((1:).map(+2))  -> ((1:).map(+2)) (fix ((1:).map(+2))) -> 1:map(+2)(fix((1:).map(+2)))
09:47:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:47:40 <glguy> fix and ap are the critical tools for effective point-free code generation
09:47:45 <glguy> :-D
09:47:53 <stranger> Hello
09:47:56 <stranger> Has anyone read Graham Hutton's 'Programming in Haskell'?
09:47:59 <EvilTerran> my head a splode...
09:49:17 <JoshTriplett> > fix ((1:).(map (+1)))
09:49:18 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:51:00 <quicksilver> EvilTerran: one of the nice things about humans is that we lazily evaluate
09:51:15 <quicksilver> EvilTerran: that's why we never going into infinite loops, which is nice
09:51:19 <thief_grr> > take 200 [1,1..] ++ [0] ++ [1,1..]
09:51:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:51:28 <EvilTerran> heh. yes, quite. well, we usually don't, anyway. :P
09:52:12 <quicksilver> > take 5 [1,1..] ++ [0] ++ [1,1..]
09:52:13 <lambdabot>  [1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:52:22 <quicksilver> thief_grr: 200 is too far away, can't see it with lambdabot :P
09:52:41 <thief_grr> quicksilver: was just trying to see if lambdabot uses some kind of "smart" ...
09:53:11 <EvilTerran> what, "oh, hey, these 200 values are all the same, let's stick a ".." in"?
09:53:32 <vincenz> > [1..]
09:53:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:53:51 <vincenz> > [1,5,..]
09:53:51 <lambdabot>  Parse error
09:53:54 <vincenz> > [1,5..]
09:53:56 <lambdabot>  [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,101...
09:53:56 <thief_grr> EvilTerran: something like that, more like "i have a longer scope than i show in this channel, and i will use it sometimes"
09:54:24 <JoshTriplett> thief_grr: use /msg, if you want more.
09:54:27 <EvilTerran> try asking it the same question over /msg
09:54:34 <thief_grr> JoshTriplett: i did ;)
09:55:08 <thief_grr> that's why i wanted to know if it will "catch" the 0 at 200 when in "short" mode
09:55:11 <thief_grr> anyway..
09:55:24 <quicksilver> the general principle of 'show' is to produce data which is valid haskell
09:55:33 <quicksilver> sticking a .. in like that wouldn't be valid code any more :)
09:55:46 <quicksilver> > [1,1,1,1..1]
09:55:47 <lambdabot>  Parse error
09:57:07 <JoshTriplett> Do you have to have some special access to lambdabot to use @topic-snoc ?
09:57:28 <thief_grr> quicksilver: no my guess was that it might respond in the take 200 case with actually showing 200 1's and then a 0 and then go on with 1,..
09:58:19 <vincenz> thief_grr: the ... trick is purely syntactical
09:58:42 <quicksilver> vincenz: what do you mean by purely syntactical?
09:58:44 <EvilTerran> > [1,1..1]
09:58:46 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:59:10 <vincenz> quicksilver: I mean it does not reason on the level of data, just on what it has to print "I will print this much and then ..."
09:59:24 <vincenz> that didn't make any sense.
09:59:34 <quicksilver> Oh, I see
09:59:37 <vincenz> Basically, it does not know anything about the data it has to show, it just knows it has to cut after a while
09:59:40 <EvilTerran> if show returns a string that's too long, it chops it off and sticks a "..." on the end
09:59:41 <quicksilver> yes, it just stop at 80 chars
09:59:43 * quicksilver nods
09:59:45 <quicksilver> absolutely
09:59:45 <vincenz> EvilTerran: right
09:59:56 <quicksilver> will it stops at 77 chars, to make room for 3 dots :)
10:00:13 <vincenz> > cycle "this is a very long string"
10:00:14 <lambdabot>  "this is a very long stringthis is a very long stringthis is a very long str...
10:00:28 <EvilTerran> 76, if you don't count the bonus space at the beginning
10:00:33 <quicksilver> relies on show instances to be good producers
10:00:39 <quicksilver> which, fortunately, they are
10:00:45 <vincenz> it does a 'take' on the strng
10:00:47 <EvilTerran> (usually)
10:00:51 <vincenz> so it no longer knows about integers and all that
10:01:46 <EvilTerran> > "this string (show)s to exactly 76 characters.............................."
10:01:47 <lambdabot>  "this string (show)s to exactly 76 characters.............................."
10:02:03 <EvilTerran> hm. okay. i was wondering if that'd end up with a ... on the end.
10:02:38 <EvilTerran> > "this string (show)s to exactly 79 characters................................."
10:02:39 <thief_grr> vincenz: yeah, figured that out ;)
10:02:40 <lambdabot>  "this string (show)s to exactly 79 characters................................."
10:02:40 <mux> > cycle "123456890"
10:02:41 <lambdabot>      lexical error in string/character literal (UTF-8 decoding error)
10:02:49 <mux> > cycle "1234567890"
10:02:50 <lambdabot>  "123456789012345678901234567890123456789012345678901234567890123456789012345...
10:03:05 <Syzygy-> mux: French keyboard?
10:03:15 <EvilTerran> > "123456789012345678901234567890123456789012345678901234567890123456789012345678"
10:03:16 <lambdabot>  "123456789012345678901234567890123456789012345678901234567890123456789012345...
10:03:19 <EvilTerran> > "12345678901234567890123456789012345678901234567890123456789012345678901234567"
10:03:21 <lambdabot>  "12345678901234567890123456789012345678901234567890123456789012345678901234567"
10:03:32 <EvilTerran> there we go. that's what i was trying to do.
10:03:55 <mux> Syzygy-: yup.
10:04:04 * EvilTerran notes that, although (length xs > n) wouldn't work for infinite xs, it's possible to achieve the same effect
10:04:32 <Syzygy-> length (take n xs) = n
10:04:42 <Syzygy-> > take 3 [1,2]
10:04:43 <lambdabot>  [1,2]
10:04:50 <EvilTerran> well, that's >=, but yeah.
10:05:15 <Syzygy-> EvilTerran: No, but it may well need to be n+1 everywhere.
10:05:35 <Syzygy-> You've guaranteed <= by the take n
10:05:44 <quicksilver> or, to save counting the length
10:05:50 <quicksilver> null (drop n xs)
10:06:05 <quicksilver> (depending exactly what you want)
10:06:18 <EvilTerran> > (null (drop 2 [1,2]), length [1,2] > 2)
10:06:20 <lambdabot>  (True,False)
10:06:20 <Syzygy-> quicksilver: Yeah, that's better.
10:06:26 <EvilTerran> is what i meant.
10:06:30 <EvilTerran> by >=.
10:06:40 <Syzygy-> > (null (drop (2+1) [1,2], length [1,2]>2)
10:06:41 <lambdabot>  Parse error
10:06:52 <EvilTerran> yeah, i see what you mean
10:06:56 <Syzygy-> > (null (drop (2+1) [1,2]), length [1,2]>2)
10:06:57 <lambdabot>  (True,False)
10:07:12 <Syzygy-> No wait .... false way around.
10:07:49 <Syzygy-> null drop will test for <=, I think. So a negation gets you where you want.
10:08:08 <malcolmw> Igloo: ah, I see lots of {-# OPTIONS_GHC -cpp #-} in the base package, so  it must work now
10:08:36 <Igloo> heh
10:08:39 <chessguy> why isn't there a default declaration for return in the definition of Monad?
10:09:11 <ndm> chessguy: what would it be?
10:09:29 <chessguy> just return a = m a
10:09:38 <Syzygy-> chessguy: Because m acts on types, not elements.
10:09:50 <chessguy> ohh, right
10:10:02 <chessguy> well, m typeOf (a)  :)
10:10:06 <vincenz> ADEpt: ping
10:10:15 <chessguy> which would put additional constraints on a, i know
10:10:30 <Syzygy-> ?t typeOf
10:10:30 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
10:10:36 <Syzygy-> ?type typeOf
10:10:38 <lambdabot> forall a. (Typeable a) => a -> TypeRep
10:10:48 <chessguy> wait, a is a type
10:10:54 <Syzygy-> chessguy: And that doesn't even come close to what you need.
10:11:00 <Syzygy-> Wrong function signature.
10:11:05 <chessguy> Syzygy-, the typeOf was a joke
10:11:10 <Syzygy-> chessguy: In return a = ..., a is an element.
10:11:41 <chessguy> yeah, ok
10:12:17 <chessguy> the default implementation of return would have to be something like return x = ...
10:12:19 <quicksilver> chessguy: because there can't be one :)
10:12:35 <chessguy> which doesn't work
10:13:01 <quicksilver> consider data Foo a = Foo (a->b)
10:13:04 <ohub> Anyone else getting "unrecognized auth response from cvs.haskell.org: pam failed to release authenticator" from cvs.haskell.org usingp server?
10:13:28 <chessguy> nobody ever points out that Monad is a _constructor_ class, and not a type class
10:13:57 <vincenz> ADEpt: ping?
10:13:58 <quicksilver> chessguy: I woudl rather say, it's a type class of kind * -> *
10:14:08 <Syzygy-> It's a functor.
10:14:09 <quicksilver> chessguy: rather than distinguish constructor classes from type classes
10:14:27 <chessguy> quicksilver, you might rather that, but i guarantee a newbie wouldn't
10:14:32 * quicksilver shrugs
10:14:39 <quicksilver> a newbie wouldn't know what a constructor class is either :P
10:14:54 <quicksilver> it's just a type class with a variable in
10:14:56 <chessguy> no, but explaining what constructors are is easy
10:15:08 <quicksilver> explaining what value constructors are is easy
10:15:15 <quicksilver> explaining what type constructors are is harder, IMO
10:15:22 <quicksilver> partly because we overload the word so badly
10:15:26 <chessguy> sigh, it's no wonder everyone thinks haskell is only academic
10:15:46 <quicksilver> ?
10:16:03 <EvilTerran> we love our jargon, we do
10:16:22 <EvilTerran> "constructors! overloading! functors! MONADS!"
10:16:48 <quicksilver> it's hard to talk about things without words for them, though
10:17:03 <jyasskin> chessguy: I tried to write a "class Injectable c x where unit :: x -> c" recently, but I discovered that "class (forall x. Injectable m (m x)) => Monad m" was illegal. :-(
10:17:47 <chessguy> jyasskin, um...congratulations? i'm not sure what your point is
10:18:02 <jyasskin> Sorry, that would be a more general way to get a default for return.
10:18:17 <quicksilver> jyasskin: how is the type checker suppose to check that forall x . Injectable m (m x) holds for a given m?
10:18:38 <kc5tja> I liken monads, and other kinds of constructor classes, as the ultimate expression of parametric polymorphism.
10:18:39 <jyasskin> It would have to have an instance of the form "instance Injectable [x] x where ..."
10:18:51 * quicksilver nods
10:19:29 <quicksilver> IYTM Injectable x (m x) actually
10:19:49 <vincenz> IYTM?
10:19:56 <vincenz> ITYM ITYM
10:20:06 <quicksilver> it was yoda-speak
10:20:21 <vincenz> and I didn't know about itym a priori, but that seemed like the most reasonable
10:21:14 <jyasskin> quicksilver: Oops, yes, I actually mean Injectable (m x) x.
10:21:26 <kc5tja> ITHM "I Think You Mean" ;)
10:21:47 <chessguy> kc5tja, ITYM ITYM :)
10:22:00 <kc5tja> Nope.
10:22:05 <kc5tja> I Think He Means.
10:22:06 <kc5tja> :)
10:25:58 <quicksilver> jyasskin: how were you going to derive the '>>=' anyway?
10:28:11 <jyasskin> quicksilver: I wasn't. Just "return = unit".
10:28:45 <jyasskin> Then again, if all Monads were Injectable, you wouldn't need return at all.
10:29:02 <jyasskin> So maybe it's not related to chessguy's suggestion after all.
10:29:47 <quicksilver> jyasskin: you can't half-define a class though
10:29:51 <chessguy> :k MonadState
10:29:53 <lambdabot> Class `MonadState' used as a type
10:29:59 <chessguy> :k State
10:30:01 <lambdabot> * -> * -> *
10:30:05 <quicksilver> jyasskin: you're either declaring an instance, or you're not :)
10:31:05 <chessguy> ?src State
10:31:05 <lambdabot> Source not found. Take a stress pill and think things over.
10:31:11 <jyasskin> quicksilver: I was re-defining class Monad as "class (forall x. Injectable m (m x)) => Monad m", not declaring an instance "instance Injectable (m x) x => Monad m". That instance would be legal.
10:31:50 <jyasskin> Except I made the same mistake again in the class definition. :-P
10:32:32 <quicksilver> you can do this : http://hpaste.org/1006
10:32:38 <quicksilver> I'm not sure if that's what you're trying, or not
10:32:51 <chessguy> State is a type constructor, right?
10:32:59 <quicksilver> chessguy: right
10:33:08 <quicksilver> :k State Int String
10:33:10 <lambdabot> *
10:33:51 <quicksilver> jyasskin: maybe that's backwards from what you are trying to do
10:33:59 <quicksilver> jyasskin: although it seems to convey the content of your idea
10:35:06 <chessguy> @kind my %Mon = (
10:35:06 <chessguy>  Jan => "01", Feb => "02", Mar => "03", Apr => "04",
10:35:06 <chessguy>  May => "05", Jun => "06", Jul => "07", Aug => "08",
10:35:06 <chessguy>  Sep => "09", Oct => "10", Nov => "11", Dec => "12",
10:35:06 <chessguy> );
10:35:06 <chessguy> $ress{BIRTH_DATE}=~ s/,//g;
10:35:08 <chessguy> ($mon,$day,$year,$junk) = split /\s+/,$ress{BIRTH_DATE};
10:35:08 <lambdabot> parse error on input `='
10:35:10 <chessguy> $day = '0'.$day if ($day<10);
10:35:12 <chessguy> $mon = $Mon{$mon};
10:35:14 <chessguy> whoah
10:35:20 <chessguy> i don't know where that came from, sorry
10:35:23 <glguy> ?type State $ \x -> ((),x)
10:35:26 <lambdabot> forall s. State s ()
10:35:27 <jyasskin> quicksilver: Good "point". It's a little annoying that every typeclass has to have a matching class with all the same methods but of a higher kind, but that does work.
10:35:30 <glguy> State is a data constructor too :)
10:40:30 <chessguy> so in data Tree a = Tip | Node a (Tree a) (Tree a) -- Tree is a type constructor, and Tip and Node are data constructors
10:40:51 <jyasskin> quicksilver: http://hpaste.org/1006#a1 is closer to what I'm actually trying to do.
10:41:52 <quicksilver> chessguy: right
10:41:59 <quicksilver> chessguy: are you asking, or telling? :)
10:42:16 <chessguy> quicksilver, yes :)
10:42:47 <quicksilver> chessguy: it's very common in haskell to use the same name for data and type constructores
10:42:56 <quicksilver> chessguy: which is on the one hand an efficient use of the namespace
10:43:03 <chessguy> a terrible practice
10:43:04 <quicksilver> chessguy: and on the other hand, potentially confusing :)
10:43:17 <quicksilver> the worst offender is []
10:43:33 <kc5tja> It's not a terrible practice if you only have one constructor.
10:43:35 <quicksilver> the difference between [a] and [a] is annoyingly subtle, for newbies
10:43:52 <kc5tja> In that case, naming the constructor the same as the record type is the most logical way to use it.
10:43:55 <quicksilver> kc5tja: I don't think it's terrible at all. But I do think it's potentially confusing, for teaching purposes :)
10:44:12 <kc5tja> 09:43 < chessguy> a terrible practice
10:44:17 <kc5tja> I was responding to that.  :)
10:44:23 <quicksilver> kc5tja: One pedagogical path is 'these two things are closely linked, and we will deliberately confuse them'
10:44:43 <quicksilver> another path is 'these two things are actually different, and we should use different names so students aren't confused'
10:44:54 <quicksilver> kc5tja: I know, I was deliberately disassociating myself from chessguy's view :)
10:45:21 <glguy> doing things for the students is great in a class
10:45:34 <glguy> but I don't want the libraries that everyone has to use screwed up for teaching purposes :)
10:45:40 <quicksilver> that's fair
10:45:47 <quicksilver> but all newbies are 'students' at one point
10:45:53 <quicksilver> even if they're self-taught
10:46:04 <glguy> sure, but eventually they grow up
10:46:08 <quicksilver> glguy: and my point was to contrast two valid views
10:46:18 <quicksilver> you can successfully argue both for and against the reuse of names
10:46:21 <quicksilver> pedagogically
10:46:41 <glguy> do you have that word on macro?
10:46:53 <quicksilver> :)
10:46:53 <quicksilver> no
10:47:03 <quicksilver> my mispellings are all my own, without help from artifical aids or aides
10:47:33 <glguy> or AIDS?
10:49:28 <Philippa> generally you don't do things you might actually confuse - you reuse the underlying-concept-name but have a quick way of distinguishing which of the overloading you actually mean
10:49:48 <Philippa> but when you're teaching that's half a lesson's worth on its own
10:51:01 <kc5tja> Eewww!!  quicksilver is a pedagog!
10:52:31 <chessguy> glguy, i'm not saying it should be changed now, i'm saying it shouldn't have been allowed to begin with
10:52:40 <chessguy> there is a big difference
10:54:20 <glguy> ok, I was saying that it is currently correct and shouldn't have been originally made simply to make teaching easier
10:54:32 <glguy> made different *
10:55:32 <chessguy> well, it's not just a pedagogically bad idea
10:55:37 <chessguy> ?spell pedagogically
10:55:38 <lambdabot> pedagogically
10:55:45 <chessguy> whee
10:56:16 <quicksilver> chessguy: in what other respect is it a bad idea?
10:56:40 <chessguy> well, legibility
10:56:51 <quicksilver> ?
10:56:58 <chessguy> things which are different should have different names
10:57:01 <quicksilver> haskell isn't reponsible for your hand-writing skills :P
10:57:23 <chessguy> readability, if you prefer that word
10:57:31 <quicksilver> I don't find that an issue
10:57:38 <glguy> especially in the case of State, you shouldn't be using the State data constructor in your code anyway
10:57:43 <quicksilver> if you want to distinguish, you can
10:57:55 <quicksilver> when it's not ambiguous you don 'thave to
10:58:01 <glguy> so readability wouldn't be a factor
10:58:04 <glguy> maybe for []
10:58:09 <quicksilver> type can occur in very few places in haskell (mostly to the right of ::)
10:58:14 <chessguy> i'm not talking specifically about State
10:58:16 <quicksilver> everywhere else it's a value
10:58:18 <glguy> but [] is very much special cased
10:58:27 <quicksilver> [] is anomalous but it's not too hard to get used to
10:58:36 <chessguy> anyway, unfortunately, i have to get back to perl
10:58:45 <encryptio> heh heh heh
10:58:49 <glguy> lol, and you are fretting about readability
10:58:58 <chessguy> well yeah, perl isn't my choice
10:59:11 <Toxaris> having type names identical to default constructor names is actually quite standard in most languages
10:59:11 <quicksilver> I'd say that when using perl is exactly when you *should* fret about readability
10:59:18 <encryptio> i love perl, but i wouldn't recommend it to anyone
10:59:32 <glguy> C++ and Java are two
10:59:35 <quicksilver> the perl programmer reaps perhaps the greatest benefits from legible code :)
11:00:01 <glguy> List list = new List();
11:00:10 <EvilTerran> perl gets a bad rep because it's really easy to write illegible perl, and people do it for fun
11:00:37 <encryptio> i wouldn't recommend it not because of readability, but because the language has so many exceptions to its rules
11:00:40 <Toxaris> i find type classes named identical to types much more confusing
11:00:45 <EvilTerran> but you can write perl that's perfectly understandable to anyone else who knows a reasonable amount of it
11:01:08 <Toxaris> because type constructors and data constructors are at least both constructors, but classes are something entirely different
11:01:27 <quicksilver> Toxaris: do people use typeclass named identical to types, commonly?
11:01:38 <EvilTerran> i do find the sheer number of special cases rather off-putting, yeah. i like it in a language if you can parse it with something other than the official parser.
11:01:56 <Toxaris> EvilTerran: so you like lisp?
11:02:14 <EvilTerran> not really, no
11:02:23 <EvilTerran> that's gone a bit far the other way.
11:02:31 <EvilTerran> haskell's a happy medium, tho =]
11:02:47 <quicksilver> perl is barely parsed
11:02:57 <quicksilver> since it's heavily context sensitive
11:03:00 <Toxaris> quicksilver: not sure actually, i was confused about it once, but may have written the type class myself
11:03:06 <quicksilver> and evaluate-as-you-go-along
11:03:09 <quicksilver> in some sense
11:03:18 <EvilTerran> interpreting perl is dangerously close to NLP
11:03:19 <quicksilver> (there is a kind of pre-parse, but it's well short of a compile)
11:04:27 <EvilTerran> i like a bit of syntactic sugar in a language, as long as it's all unambiguous and has been specified in a formal grammar, is what i'm trying to say.
11:04:45 <quicksilver> agreed
11:05:01 <quicksilver> haskell is rather easy to parse for the most part (in your head)
11:05:11 <encryptio> yeah, i think we can all agree [1,2,3] is good syntax sugar.
11:05:13 <Toxaris> quicksilver: but it's allowed, so it may be there :-) and confusing type classes with constructors is a mistake i definitively made
11:05:14 <quicksilver> as long as you get over the 'juxtaposition-as-highest-priority' part
11:05:17 <bakert> Help me be functional, gang.  I've got to visit a web page with ?start=0 then ?start=10 then ?start=20 and so on.  I don't know when it will end until I've read the last page.  How can I functionalise that.  My brain sees it in imperative style.
11:06:24 <encryptio> my first instinct tells me: takeWhile (...) [0,10..]
11:06:53 <kc5tja> You know what's funny?  Darcs compiles just fine with readline 5.0 support, even though it complains about missing 4.0 in its configure script.
11:06:54 <bakert> encryptio, interesting idea
11:07:03 <kc5tja> Oh, wait, sorry, that was GHC.
11:07:04 <encryptio> but i don't know how to fit the IO monad into that
11:07:06 <kc5tja> darrr....
11:07:28 <bakert> encryptio, hmm no, me neither
11:08:22 <LoganCapaldo> or getPage n = if isLast p then p else getPage (n+10) where p = getPage' n = <actually do the io>
11:08:58 <bakert> that might be easier
11:09:16 <bakert> i also need to keep a running total but i think i'll be able to work that out.
11:09:17 <bakert> maybe.
11:09:38 <LoganCapaldo> running total is just another parameter, or use the State or Write monad
11:09:41 <encryptio> bakert: and that makes me think a StateT of list
11:09:42 <LoganCapaldo> *Writer
11:10:23 <glguy> can someone explain to me the purpose of trackbacks on blogs?
11:10:29 <glguy> just to influence google?
11:10:38 <glguy> to make your comments section suck?
11:10:39 <glguy> I don't get it
11:11:10 <DRMacIver> To automatically provide links to related posts I suppose.
11:11:24 <EvilTerran> to allow your readers (and spiders) to find similar blogs
11:11:41 <bakert> glguy, I think the idea is that "the web is a conversation" and various high level thoughts like that.
11:11:45 <glguy> it would be like if every time you guys pasted something, I just added 3 annotations to it with little automatically generated quotations
11:12:02 <glguy> that were direct quotes from what you wrote, but too short ot be useful
11:12:13 <bakert> On a practical level it sucks.  And I think most of the people who once proposed it no longer think it is a good idea.
11:12:27 <bakert> Dave Winer for one has taken it all back, if I remember rightly.
11:12:47 <bakert> Although I think their main objection is spam not that it makes comments sections rubbish.
11:13:08 <glguy> it just proves that for every original article you have 10 garbage articles "look what I found"
11:13:18 <bakert> (after all people could choose to put the trackbacks in a "links to this post" section at the end or something ... it's just not the wordpress/movabletype/blogger default.)
11:13:21 <glguy> and the original articles aren't even generally that good
11:13:42 <glguy> much less the ones that offer nothing than to say that they linked back
11:13:53 <glguy> I hate you, blobosphere!
11:13:58 <bakert> I agree with you wholeheartedly.  Trackback is rubbish.  But I can see what they were thinking.
11:14:06 <bakert> And I forgive them.
11:14:43 <bakert> encryptio, thanks.  i will have to look into StateT as i have no idea what it is.
11:15:08 <encryptio> it's pure, unadulterated fun! =p
11:15:21 <glguy> monad transformers are what actually make monads so powerful
11:15:38 <glguy> a good thing to study once the basic monads start to make sense
11:15:48 <encryptio> they turn monads into an asset instead of a liability
11:16:10 <glguy> If you know State s a, then you might as well know: StateT s Identity a
11:16:43 * allbery_b is, for the first time, impure
11:16:43 <lambdabot> allbery_b: You have 1 new message. '/msg lambdabot @messages' to read it.
11:16:51 <allbery_b> I'm writing a program using IORefs
11:17:47 <glguy> that's not so offensive if your application is primarily IO based, is it?
11:18:23 <allbery_b> it is indeed, but I've still managed to avoid it up until now
11:19:13 <encryptio> > Just 3 >>= Just
11:19:14 <lambdabot>  Just 3
11:19:21 <encryptio> > Nothing >>= Just
11:19:22 <lambdabot>  Nothing
11:19:43 <encryptio> kewl
11:19:47 <glguy> > >>= return is id :)
11:19:47 <lambdabot>  Parse error
11:20:14 <LoganCapaldo> > Just Nothing >>= Just
11:20:14 <lambdabot>  Just Nothing
11:20:20 <encryptio> > Just 3 >>= Nothing
11:20:20 <lambdabot>  Couldn't match expected type `t -> Maybe b'
11:20:48 <LoganCapaldo> > (Just (Just 1)) >>= id -- and >>= id is join
11:20:49 <lambdabot>  Just 1
11:21:50 <qwr> > return 3 >>= return
11:21:51 <lambdabot>   add an instance declaration for (Show (m t))
11:22:20 <glguy> > return 3 >>= return :: Maybe Int
11:22:21 <lambdabot>  Just 3
11:22:34 * qwr thinks, that ghci deduced it into IO Int
11:24:37 <LoganCapaldo> ghci worries me with its assumptions
11:24:55 <LoganCapaldo> and lambdabot worries me with her assumptions
11:25:13 <LoganCapaldo> and the non-intersection of the assumptions worries me greatly
11:25:27 <qwr> ;)
11:26:06 <LoganCapaldo> fascinating
11:26:27 <LoganCapaldo> :type in ghc says (Monad m, Num t) => m t
11:26:34 <LoganCapaldo> *ghci
11:27:08 <glguy> > 3^3^3
11:27:09 <lambdabot>  7625597484987
11:27:27 <LPhas> > 3^3^3^3 :: Int
11:27:29 <lambdabot>  1662683451
11:27:33 <LPhas> ehehaheh
11:27:37 <LoganCapaldo> Haskell makes me feel heisenbergy
11:27:47 <encryptio> Haskell makes me happy
11:28:09 <kc5tja> Haskell makes me feel EIGENBERGY!  :)
11:28:28 <kc5tja> (sorry -- I just love that prefix, even if I dont' know what it really means)
11:29:33 <shapr> It means "self".
11:29:45 <shapr> It likes "own"
11:29:49 <shapr> My own something.
11:29:53 <shapr> You've been owned!
11:30:06 <glguy> pwnd?
11:30:10 <encryptio> so... "my"
11:30:51 <LPhas> >mod 3^3^3^3 (maxBound :: Int)
11:31:22 <LPhas> > mod (3^3^3^3) (maxBound :: Int)
11:31:23 <lambdabot>  1662683451
11:31:34 <encryptio> > mod (3^3^3^3^3) (maxBound :: Int)
11:31:38 <lambdabot> Terminated
11:31:40 <encryptio> =
11:31:42 <encryptio> =\
11:31:59 <LPhas> loooooooooong
11:32:35 <shapr> kc5tja: from http://en.wikipedia.org/wiki/Eigenvector - "Eigen" can be translated as "own", "peculiar to", "characteristic" or "individual"%G%@emphasizing how important eigenvalues are to defining the unique nature of a specific transformation.
11:32:37 <lambdabot> Title: Eigenvalue, eigenvector and eigenspace - Wikipedia, the free encyclopedia
11:33:38 * cjeris visualizes a mathematically inclined script kiddie gloating "pwgen'd!!!1!"
11:34:21 <kc5tja> shapr: Heh, that doesn't clear a darn thing up for me :)
11:35:17 <cjeris> kc5tja: i think 'eigen' is essentially a meaning-free nominal adjective, kind of like 'Holy' and 'Roman' on the Empire... :)
11:35:47 <kc5tja> hehe :)
11:52:50 <bakert> > read "3.3" :: Int
11:52:51 <lambdabot>  Exception: Prelude.read: no parse
11:52:55 <bakert> > read "3.3" :: Double
11:52:56 <lambdabot>  3.3
11:53:03 <bakert> > read 3.3 :: String
11:53:04 <lambdabot>   add an instance declaration for (Fractional String)
11:53:16 <bakert> > show 3.3
11:53:18 <lambdabot>  "3.3"
11:53:19 <bakert> tsk
11:53:21 <bakert> silly me
11:55:03 <bakert> ?where liftM
11:55:03 <lambdabot> I know nothing about liftm.
11:55:08 <bakert> ?src liftM
11:55:08 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:55:18 <bakert> ?which liftM
11:55:19 <lambdabot> Unknown command, try @list
11:55:24 <mauke> ?index liftM
11:55:24 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:55:29 <bakert> thanks mauke!
11:55:53 <glguy> suppose I have : data A = B | C { f :: Int }
11:56:00 <glguy> is there a way to define: f B = 1
11:56:01 <glguy> ?
11:56:32 <mauke> I don't think so
11:56:56 <glguy> or would I need: data A = B { f :: Int } | C { f :: Int } ; newB = B 1
11:57:40 <mauke> type A = Maybe Int; f = fromMaybe 1
11:58:09 <glguy> well, in reality, "C" has 4 fields
11:59:27 <mauke> data A = B | C { sekrit_f :: Int }; f B = 1; f (C n) = n
12:26:07 <Cale> glguy: how is what you wrote not suitable for doing that?
12:27:56 <jre2_> does anyone know what Tim Sweeny means when he refers to lenient evaluation?  I wasn't able to find any information on it (or Id90) and was curious if it is equivalent to eager optimizations
12:31:18 <doserj_> http://lists.seas.upenn.edu/pipermail/types-list/2004/000352.html
12:31:19 <lambdabot> Title: [TYPES] Combining lazy and eager evaluation of terms
12:31:23 <kc5tja> Does anyone know of any method of creating "entropy" on a Linux box via SSH?
12:31:35 <kc5tja> Apparently my box doesn't consider network packet arrival events to be sources of entropy.
12:32:03 <opqdonut> kc5tja: cat >/dev/null and then bang on kbd
12:33:02 <chessguy> so a type constructor must be completely polymorphic to be able to be an instance of Monad, right? e.g., data Foo = Bar Int -- Foo can't be an instance of Monad
12:33:30 <mauke> right
12:33:35 <mux> it must have kind * -> *
12:33:42 <xerox> chessguy - Foo :: *
12:33:49 <jre2_> doserj_: thanks
12:33:50 <mux> so it must take a type as a parameter
12:34:49 <chessguy> mux, more than that, it must be able to take ANY type
12:35:28 <monochrom> Even "data (Ord x) => Hey x = ..." doesn't qualify.
12:35:34 <mux> well that's the meaning of kind * -> *
12:35:59 <mux> unless I'm missing something
12:36:09 <monochrom> You aren't missing something.
12:36:25 <Saizan> well, Hey has kind * -> *
12:36:49 <Saizan> but you can't make a Hey monad
12:37:30 <mux> so, you cannot have type classes constraints on the type constructor if you want it to be an instance of Monad?
12:37:53 <Saizan> no, because return :: a -> m a for every a
12:38:00 <mux> I don't see how else you could restrict something of kind * -> * to a subset of the base types
12:39:01 <mux> good to know.
12:41:24 <Saizan> it's also a little of a limitation, you could want a monad that works only on instances of Num as in a sigfpe post for example
12:41:48 <chessguy> so it is more than just saying the type constructor must have kind * -> *
12:42:25 <therp> openoffice is crap
12:42:44 <LoganCapaldo> does this just mean the kind system isn't expressive enough?
12:42:56 <kc5tja> opqdonut: Does nothing.  IP traffic is not considered a source of entropy.
12:43:01 <ndm> therp: correct, Office 2007 is really impressive though
12:43:05 <LoganCapaldo> since you can't distinguish between Hey and Maybe's kinds?
12:43:25 <therp> ndm: unfortunately crossoffice crashes for me. otherwise I would use the MS office suite.
12:43:39 <ndm> therp: you could upgrade to windows ;)
12:43:40 <mattam> data (Ord x) => Hey x = ... should have type/kind (x : *) -> Ord x -> * somehow.
12:43:43 <therp> I'm trying to do my Liskell presentation slides, and it seems like I'm wasting my time.
12:43:51 <therp> ndm: downgrade? :)
12:44:14 <ndm> therp: give it a few months and google will release their powerpoint, that could well be worth using
12:44:29 <monochrom> Consider using black/whiteboard instead of slides.  You still have to prepare.
12:44:42 <therp> ndm: I need a mature product.
12:45:51 <chessguy> is the kind of Hey really * -> *
12:46:12 <mux> yeah, I'd like to know that too :-)
12:46:36 <chessguy> i don't have access to ghc at the moment
12:46:41 <mux> can we define types in LB with @let ?
12:46:47 <therp> chessguy: use lambabot :)
12:46:47 <mux> well, let me try in my ghci
12:46:50 <chessguy> i don't think so
12:46:54 <monochrom> @let monochrom = True
12:46:57 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
12:47:03 <monochrom> Still can't :)
12:48:20 <ndm> therp: google products are always great, i always use powerpoint 2007/2003 for my presentations, it works great
12:48:33 <ndm> 2007 has pdf export, which is handy, since i give most presentations under Linux
12:48:53 <therp> ndm: hm, powerpoint is a bit foreign to my infrastructure..
12:49:16 * ndm is a microsoft whore
12:49:30 <mux> Hey :: * -> *
12:49:35 <chessguy> yuck
12:50:12 <chessguy> that seems broken somehwo
12:50:31 <LoganCapaldo> Woo!
12:50:42 <monochrom> microsoft whore is ok. If I want to commandeer a lot of PCs for the purpose of DDoS attacks, I want more microsoft whores.
12:50:45 * LoganCapaldo newb was right in questioning status quo
12:51:12 <mattam> then you can build Hey's of x where two Ord classes for x would have been used
12:51:14 <chessguy> hmmm. sounds like a thread to start on -cafe
12:51:28 <chessguy> mattam, huh?
12:52:09 <monochrom> parse error
12:52:24 <chessguy> monochrom, ?
12:53:26 <monochrom> parse error on mattam
12:56:03 <mattam> if Ord x doesn't appear in the type, and you can build and use two instances of Ord for the same type in the same program then you can build values of Hey x mixing the operations of the two instances. Is that right ?
12:57:23 <monochrom> No. In the standard, you cannot build two instances of Ord for the same type.  In extensions, you can, but the compiler will choose one and stick with it.
12:58:31 <mattam> so the Ord x => constraint not appearing in the kind is sound if you don't use extensions, but in the other case...
12:58:35 <glguy> ?pl \a b -> (f b a, g b a)
12:58:35 <lambdabot> ap (ap . ((,) .) . flip f) (flip g)
12:58:44 <glguy> ewww :)
12:59:08 <chessguy> mattam, that seems irrelevant to me anyway
12:59:10 <glguy> ?pl \a b -> (f b a, b - g b a)
12:59:10 <lambdabot> ap (ap . ((,) .) . flip f) (ap (-) . flip g)
12:59:17 <glguy> definitely not any better :)
13:00:28 <mattam> chessguy: isn't the fact that the class constraint doesn't appear in the kind what seems broken to you ?
13:01:45 <glguy> ?docs Data.Tree
13:01:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
13:01:59 <chessguy> i don't s=Please Select
13:01:59 <chessguy> 18-24
13:01:59 <chessguy> 25-34
13:01:59 <chessguy> 35-49
13:01:59 <chessguy> 50-64
13:02:00 <chessguy> 65+
13:02:01 <chessguy> grrr
13:02:16 * chessguy hates ctrl+ins
13:02:20 <mauke> hahahWHERE IS SARAH CONNOR
13:02:26 <glguy> chessguy: you going back to those adult dating sites again?
13:02:38 <monochrom> hahaha
13:02:57 <chessguy> glguy, take your pick
13:03:35 <chessguy> mattam, getting back to haskell, you said "<mattam> so the Ord x => constraint not appearing in the kind is sound if you don't use extensions"...why is that?
13:04:45 <mattam> because for any x, there is only one Ord x instance, so it completely determines what would be the Ord x argument in (x : *) -> Ord x -> *
13:05:18 <mattam> ie, it is equivalent to (x : *) -> * or * -> *
13:06:01 <chessguy> but the * should mean ANY types, without restriction
13:06:22 <bd_> ?where soc
13:06:22 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
13:06:23 <chessguy> but Hey has a restriction on what types can be used to build them
13:06:40 <mattam> exactly, the constructor has the constraint too
13:06:58 <chessguy> but to me, if it has a constraint, then it shouldn't have kind * -> *
13:07:42 <chessguy> because it's indistinguishable from, say, Tree a, which also has kind * -> *, but allows a to be of ANY type
13:07:52 <Laney> @src zipWith
13:07:52 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
13:07:52 <lambdabot> zipWith _ _      _      = []
13:08:08 <chessguy> so, e.g., Tree can be a monad, but Hey can't, even though they're both of kind * -> *
13:08:53 <encryptio> how do i split a string into two parts, the part left of the first " -> " and the part to the right? (not including the " -> " itself)
13:09:26 <chessguy> mattam, am i making any sense?
13:09:54 <mattam> maybe the designers had some point making this 'optimization' of forgeting about constraints in kinds
13:11:28 <LoganCapaldo> @hoogle (Eq a) => [a] -> [a] -> Int
13:11:29 <lambdabot> No matches, try a more general search
13:11:49 <LoganCapaldo> @hoogle (Eq a) => [a] -> [a] -> Maybe Int
13:11:50 <lambdabot> No matches, try a more general search
13:12:06 <chessguy> ok, time to take it to the mailing list then
13:12:07 <Grace> hola!!!
13:12:15 <Grace> Hi?
13:12:23 <mattam> yes you are making sense btw
13:12:28 <chessguy> whew!
13:12:29 <quicksilver> chessguy: I don't think constraints on types mean quite what you think they do
13:12:39 <quicksilver> chessguy: although I'm not 100% confident of the details
13:12:44 <chessguy> quicksilver, enlighten me
13:12:54 <quicksilver> chessguy: e.g, I think 'Hey' genuinely has kind * -> *
13:13:00 <quicksilver> but the Hey 'constructor' has a constraint
13:13:08 <Grace> I anyone know how i can use hat and QuickCheck with windows?
13:13:13 <quicksilver> so it turns out you can only apply the constructor to correctly typeclassed types
13:13:16 <chessguy> hmm
13:13:21 <quicksilver> (I appreciate that's splitting hairs)
13:13:26 <chessguy> very much so
13:13:36 <Grace> :(
13:13:48 <quicksilver> I think it's not clear in FC what applying a class restriction to a type should mean
13:13:54 <quicksilver> but applying it to constructors obviously makes sense
13:13:59 <chessguy> FC?
13:13:59 <quicksilver> you can supply a dictionary to a constructor
13:14:05 <quicksilver> you can't supply a dictionary to a type
13:14:12 <quicksilver> (because 'types don't really exist')
13:14:22 <quicksilver> FC is the set-theory GHC works in
13:14:28 <quicksilver> System F + some stuff
13:14:37 <quicksilver> chessguy: anyhow, don't take my word for it
13:14:46 <quicksilver> chessguy: post to the mailing list, I'd be interested to see the answer
13:14:47 <chessguy> don't worry, i don't intend to :)
13:14:51 <quicksilver> from someone smarter than me :)
13:17:35 <chessguy> i'm trying to decide on a good example to contrast with Hey
13:18:01 <chessguy> eh, i'll just make something up
13:18:16 <Grace> help? anyone can help me with Hat and QuickCheck ?
13:19:18 <ndm> Grace: is Hat not working?
13:19:35 <Grace> no , i cant use
13:19:49 <Grace> i'm with ghc6.6 and windows
13:20:00 <ndm> Grace: are you using the Windows Hugs distribution?
13:20:02 <Grace> and i don't know how i can use
13:20:17 <ndm> Grace: http://www-users.cs.york.ac.uk/~ndm/projects/hat.php
13:20:19 <lambdabot> Title: Neil Mitchell - Hat
13:20:32 <ndm> Grace: but realistically, your chances of getting hat going on windows aren't great
13:20:38 <ndm> (they aren't that great on linux either)
13:21:08 <Grace> mmmm ,
13:21:17 <chessguy> ?src Monad
13:21:18 <lambdabot> class  Monad m  where
13:21:18 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
13:21:18 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
13:21:18 <lambdabot>     return      :: a -> m a
13:21:18 <lambdabot>     fail        :: String -> m a
13:21:53 <Grace> thank for the link ndm
13:22:02 <Grace> thank's  :)
13:23:15 <chessguy> ok, it's on -cafe now
13:27:20 <mightybyte> Is there an idiom for creating a list of numbers evenly dividing some interval?
13:28:32 <encryptio> http://hpaste.org/1007 - "do notation question"
13:29:41 <JohnnyL> > zipWith [a,b,c,d]
13:29:42 <lambdabot>   Not in scope: `d'
13:29:58 <JohnnyL> > zipWith ['a','b','c','d']
13:29:58 <lambdabot>  Couldn't match expected type `a -> b -> c'
13:30:10 <monochrom> encryptio: unbalanced parentheses confused the parser.
13:30:10 <sjanssen> encryptio: see my annotation
13:30:31 <sjanssen> hpaste bot is down?  Has anyone told glguy?
13:30:38 <encryptio> funky. didn't see that.
13:31:10 <chessguy> !ne
13:31:12 <chessguy> !new
13:31:36 <sjanssen> @tell glguy hpaste bot seems to be dead
13:31:36 <lambdabot> Consider it noted.
13:32:27 <JohnnyL> @tell humasect dude, Haskell Prime totally rules!
13:32:28 <lambdabot> Consider it noted.
13:36:06 <wilx`> @tell wilx` test
13:36:06 <lambdabot> You can tell yourself!
13:36:12 <wilx`> .
13:36:20 <wilx`> Heh.
13:39:19 <sjanssen> @seen ndm
13:39:19 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 3m 44s ago, and .
13:41:42 <malsyned> hello!
13:44:19 <chessguy> sjanssen, good timing :)
13:44:21 <mightybyte> Is there a foldr equivalent that applies a function to every suffix if a list instead of to every element?
13:44:33 <malsyned> mightybyte: like mapcdr?
13:44:41 <glguy> foldr f z . tails
13:44:41 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
13:44:45 <malsyned> er, no, not quite like that.
13:44:58 <glguy> !paste
13:44:59 <hpaste> Haskell paste bin: http://hpaste.org/
13:45:11 <chessguy> glguy, it's not announcing new pastes
13:45:13 <LoganCapaldo> mapcdr? egads, is that why its called mapcar?
13:45:17 <glguy> oh
13:45:28 <glguy> lisp calls that mapl
13:45:30 <glguy> maplist
13:45:47 <monochrom> mightybyte: perhaps combine tails and foldr
13:46:47 <malsyned> is there a lexing library to compliment Parsec by producing a list of tokens from a list of chars?
13:47:05 <hpaste>  chessguy annotated "(no title)" with "test" at http://hpaste.org/969#a2
13:47:18 <chessguy> ah, there it goe
13:47:18 <chessguy> s
13:47:27 <mightybyte> malsyned: Ahh, mapcdr sounds right
13:48:08 <malsyned> mightybyte: no, I take that back.  you don't want a mapcdr-lookalike, you want to combine tails and foldr.  monochrom was right.
13:48:29 <mightybyte> >:t foldr
13:48:39 <chessguy> :t foldr
13:48:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:48:43 <glguy> bah, I said foldr g z . tails first :-p
13:49:01 <glguy> or
13:49:03 <glguy> map f . tails
13:49:13 * monochrom kisses glguy
13:49:19 * glguy swoons
13:49:21 <chessguy> ewwwwww
13:49:22 <mightybyte> monochrom: foldr is "(a -> b -> b) -> b -> [a] -> b" but I'm looking for "([a] -> b -> b) -> b -> [a] -> b"
13:49:35 <chessguy> take it to -blah!
13:49:43 <glguy> :t \f z -> foldr f z . tails
13:49:45 <lambdabot> forall b a. ([a] -> b -> b) -> b -> [a] -> b
13:49:57 <chessguy> :t foldr ?f ?z . tails
13:50:00 <lambdabot> forall b a. (?f::[a] -> b -> b, ?z::b) => [a] -> b
13:50:13 <glguy> :t (. tails) . ((foldr .) .)
13:50:15 <lambdabot> forall a a1 b a2. ([[a]] -> a2 -> a1 -> b -> b) -> [a] -> a2 -> b -> [a1] -> b
13:50:24 <glguy> :t (. tails) . (foldr .)
13:50:26 <lambdabot> forall a a1 b. ([[a]] -> a1 -> b -> b) -> [a] -> b -> [a1] -> b
13:50:42 <glguy> :t ((. tails) .) . foldr
13:50:44 <lambdabot> forall a b. ([a] -> b -> b) -> b -> [a] -> b
13:50:47 <mightybyte> :t tails
13:50:49 <lambdabot> forall a. [a] -> [[a]]
13:50:50 <glguy> I got there eventually :)
13:51:11 <malsyned> glguy: you were there to begin with.  you were just looking for a pointless version?
13:51:16 <mightybyte> glguy: Your first one was right
13:51:16 <glguy> yeah :)
13:51:22 <glguy> right, the first and last
13:51:24 <malsyned> @pl \f z -> foldr f z . tails
13:51:25 <lambdabot> flip flip tails . ((.) .) . foldr
13:51:26 <mightybyte> glguy: Where is tails defined?
13:51:30 <glguy> Data.List
13:51:39 <LoganCapaldo> @source tails
13:51:39 <lambdabot> tails not available
13:51:49 <glguy>  @pl takes all the joy out of it
13:51:56 <LoganCapaldo> @index tails
13:51:57 <lambdabot> Data.List
13:52:01 <mightybyte> Yeah
13:52:03 <chessguy> ?hoogle tails
13:52:03 <lambdabot> List.tails :: [a] -> [[a]]
13:52:03 <lambdabot> Text.PrettyPrint.HughesPJ.TextDetails :: data TextDetails
13:52:15 <mightybyte> What is @pl exactly?
13:52:26 <glguy> ?help pl
13:52:26 <lambdabot> pointless <expr>. Play with pointfree code.
13:52:31 <malsyned> mightybyte: it rewrites a function in "points-free" style.
13:52:34 <monochrom> converts "\x -> f x" to "f"
13:52:38 <mightybyte> Ok
13:52:54 <sjanssen> mightybyte: removes all lambdas and lets from an expression
13:52:58 <glguy> \f g x y -> f (g x) (g y)   --  ap ((.) . flip (.)) . (.)
13:53:00 <sjanssen> or dies trying
13:53:03 <LoganCapaldo> @pl (\x y -> x ++ "No points for you!" ++ y)
13:53:03 <lambdabot> (. ("No points for you!" ++)) . (++)
13:53:35 <monochrom> @pl \x -> c ++ x
13:53:35 <lambdabot> (c ++)
13:53:36 <glguy>  @pl is a substitute for a good hobby
13:53:40 <monochrom> hehehehe!
13:53:47 <malsyned> so... anybody know of a lexer library to compliment Parsec?
13:53:57 <LoganCapaldo> Parsec?
13:53:58 <glguy> Parsec?
13:53:59 <LoganCapaldo> :)
13:54:01 <liquidengineer> @paste
13:54:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:54:17 <malsyned> just run parse on the input, then parse again on the result?
13:54:30 <LoganCapaldo> it slices, it dices, it juliennes fries
13:54:34 <LoganCapaldo> yerp
13:54:47 <xerox> @pl \x -> you x off
13:54:48 <lambdabot> flip you off
13:55:00 * LoganCapaldo groans
13:55:20 <sjanssen> wouldn't parsec make a horribly inefficient lexer?
13:55:21 <monochrom> hehe
13:56:28 <xerox> @pl \x -> pet x (ite x)
13:56:28 <lambdabot> ap pet ite
13:56:38 * glguy notices that the most recent pastes were lost...
13:56:43 <xerox> :P
13:56:46 <glguy> I wonder how that related to the bot not announcing things
13:56:51 <malsyned> :t ap
13:56:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:57:54 <nornagon> is there any way to specify some haskell on the command line to pass to runhaskell or something? similar to ruby and perl's -e
13:58:15 <sjanssen> nornagon: there is ghc -e
13:58:44 <nornagon> nifty
13:58:47 <nornagon> slow though
13:58:51 <nornagon> to start up
14:01:01 <goltrpoat> how are right sections usually desugared?  i figure i can lambda lift it immediately, or convert it to a local definition and let the lambda lifting pass deal with it later, or convert it to a left section with a flip
14:01:01 <lambdabot> goltrpoat: You have 1 new message. '/msg lambdabot @messages' to read it.
14:01:49 <goltrpoat> right now it has its own constructor in the expression type, but i'm trying to pare down the syntax tree a little due to the proliferation of qtycls/qtyvar/qcon/qconop/gconop/etc etc
14:02:27 <sjanssen> goltrpoat: you're writing a Haskell interpreter?
14:03:00 <goltrpoat> im writing a compiler, sort of a personal edification/r&d vehicle type thing
14:03:10 <sjanssen> neat.
14:04:46 <sjanssen> goltrpoat: the report specifies a transformation via lambda
14:04:55 <goltrpoat> oh it does?  mustve missed that
14:05:10 <sjanssen> http://haskell.org/onlinereport/exps.html#sect3.5 scroll down to translation
14:05:11 <lambdabot> Title: The Haskell 98 Report: Expressions
14:05:23 <malsyned> anybody know of a good example of double-Parsecing that I could go read the source for?
14:05:23 <encryptio> @pl \x (a,b) p -> if p then (a:x,b) else (a,b:x)
14:05:24 <lambdabot> (`ap` snd) . (. fst) . ap (ap . ((ap . ((flip . flip if') .) . (,)) .) . flip (:)) (flip ((.) . (,)) . flip (:))
14:05:58 <LoganCapaldo> eek
14:06:05 <goltrpoat> sjanssen:  left sections too?  im just translating those as (@ op e)
14:06:06 <LoganCapaldo> (a+b+) is valid
14:06:09 <LoganCapaldo> that scares me
14:06:22 <dmwit> ?pl f a b c d = a $ b c d
14:06:22 <lambdabot> f = (.) . (.)
14:06:28 <dmwit> Haha, that never gets old.
14:06:36 <encryptio> heh
14:07:06 <LoganCapaldo> @type (.) (.) (.)
14:07:09 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:07:10 <sjanssen> goltrpoat: you can skip the lambda in that case, they're equivalent
14:07:15 <goltrpoat> makes sense
14:07:15 <dmwit> :t (.) . (.)
14:07:17 <LoganCapaldo> @type (.) . (.)
14:07:18 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:07:20 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:07:43 <hpaste>  mightybyte pasted "Type Problem" at http://hpaste.org/971
14:07:56 <LoganCapaldo> hpaste: Hurray, you're alive!
14:08:02 <dmwit> Ah, the first one applies (.) to (.) and (.), getting (.) . (.).  Neat.
14:08:08 <glguy> about 30 pastes went missing though
14:08:15 <mightybyte> That code compiles, but won't run.
14:08:20 <sjanssen> goltrpoat: you can use any translation you want as long as those identities in the report hold
14:08:21 <glguy> I don't know what happened that causes that + the bot to stop talking
14:08:23 <mightybyte> I'm having trouble figuring out why.
14:08:49 <augustss_> @djinn (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:08:49 <lambdabot> f a b c d = a (b c d)
14:09:05 <Cale> http://programming.reddit.com/info/19xtx/comments/c1ajoo?context=5
14:09:06 <sjanssen> goltrpoat: it can't be a type problem if it compiles :)
14:09:08 <lambdabot> Title: Haskell Eye for the Ruby Guy (reddit.com), http://tinyurl.com/2fplg9
14:09:21 * Cale rants about the importance of laziness.
14:09:31 <mightybyte> Well, then I don't know what the correct term is.
14:10:20 <glguy> Cale: how much time a day to you spend writing Reddit essays? (or do you have them prepackaged for correcting people) :)
14:10:27 <Cale> heh
14:10:35 <Cale> I have them prepackaged in my brain.
14:10:37 <goltrpoat> sjanssen:  pardon? :)
14:10:39 <LoganCapaldo> mightybyte: :t integrate
14:10:40 <LoganCapaldo> integrate :: (Num a, Fractional [a], Ord a, Ord [a])
14:10:42 <Cale> Well, segments of them.
14:10:49 <sjanssen> Cale: "foldl" is arguing against the usefulness of laziness.  Coincidence?  I think not.
14:10:51 <LoganCapaldo> Fractional [a] <-- not good
14:11:00 <Cale> sjanssen: yeah, I pointed that out in my comment :)
14:11:06 <LoganCapaldo> seems to indicate you are trying to divide a list
14:11:06 <sjanssen> goltrpoat: sorry, naughty tab completion
14:11:09 <goltrpoat> ah
14:11:30 <mightybyte> LoganCapaldo: Ok, I don't know how to fix that
14:12:50 <glguy> I think this quote from Dijkstra's essay that was on reddit earlier didn't get enough attention in the comments... that or people didn't udnerstand what it means:
14:12:53 <glguy> And even this improvement wasn't universally appreciated: some people found error messages they couldn't ignore more annoying than wrong results, and, when judging the relative merits of programming languages, some still seem to equate "the ease of programming" with the ease of making undetected mistakes.
14:12:53 <hpaste>  sjanssen annotated "Type Problem" with "I bet this is what you mean" at http://hpaste.org/971#a1
14:13:53 <mightybyte> sjanssen: I just tried that, and it doesn't seem to work either
14:14:07 <sjanssen> mightybyte: paste the error message
14:14:31 <sjanssen> (it is a good idea to do this for every paste you make)
14:15:05 <mightybyte> sjanssen: Ok, thanks for bearing with me
14:16:54 <hpaste>  mightybyte annotated "Type Problem" with "(no title)" at http://hpaste.org/971#a2
14:17:56 <mightybyte> sjanssen: Your version and my new version both gave the same Fractional [a] problem.
14:18:00 <glguy> mightybyte: you might need to be pattern matching on the list fragments you are getting
14:18:15 <glguy> \ (first:second:_)
14:18:24 <mightybyte> Ohhhh, that's it
14:18:28 * glguy is just glancing at the code
14:18:50 <sjanssen> mightybyte: I don't think you want to use foldr at all there
14:19:02 <glguy> zipWith could be appropriate
14:19:19 <glguy> > let xs = [1..10] in zipWith (+) xs (tail xs)
14:19:20 <lambdabot>  [3,5,7,9,11,13,15,17,19]
14:19:33 <glguy> > let xs = [1..10] in zipWith (-) xs (tail xs)
14:19:33 <LoganCapaldo> Figure out the type you want and ask @djinn to write it for you :)
14:19:34 <lambdabot>  [-1,-1,-1,-1,-1,-1,-1,-1,-1]
14:19:49 <glguy> > let xs = map (^2) [1..10] in zipWith (-) xs (tail xs)
14:19:50 <lambdabot>  [-3,-5,-7,-9,-11,-13,-15,-17,-19]
14:20:07 <mightybyte> sjanssen: The possibility of a zip solutions had crossed the far corners of my thoughts
14:20:35 <hpaste>  sjanssen annotated "Type Problem" with "better (but untested)" at http://hpaste.org/971#a3
14:20:47 <glguy> > [b - a | (a:b:_) <- tails (map (^2) [1..10])]
14:20:49 <lambdabot>  [3,5,7,9,11,13,15,17,19]
14:21:29 <glguy> > scanl (+) 0 [b - a | (a:b:_) <- tails (map (^2) [1..10])]
14:21:30 <lambdabot>  [0,3,8,15,24,35,48,63,80,99]
14:22:03 <sjanssen> can I embed a vim window in a firefox text control?
14:22:27 <glguy> I once saw an extension that did that for emacs
14:22:32 <glguy> it might be configurable
14:22:33 <monochrom> wow
14:22:37 <sjanssen> glguy: remember the name?
14:22:42 <glguy> sorry :(
14:22:44 <mightybyte> Ok, let me go think about this some more.
14:22:46 <glguy> I know that it exists
14:23:14 <sjanssen> s'okay, I really should be asking google :)
14:23:32 <glguy> > scanl (+) 0 [(a+b) / 2 | (a:b:_) <- tails (map (^2) [1..10])]
14:23:34 <lambdabot>  [0.0,2.5,9.0,21.5,42.0,72.5,115.0,171.5,244.0,334.5]
14:23:40 <LoganCapaldo> At one point you could have KVim in Konquoror for your textareas
14:25:23 <glguy> lol, if you were *desperate*
14:25:27 <glguy> ;)
14:25:50 <sjanssen> nah, I can't ditch firefox/conkeror
14:26:22 <glguy> you trying to keep someone from being able to use your firefox?
14:26:30 <glguy> *I can't type anything!*
14:26:34 <Laney> @src and
14:26:35 <lambdabot> and   =  foldr (&&) True
14:27:08 <sjanssen> glguy: I'm sure my setup is already difficult for the average joe
14:27:14 <glguy> :t and
14:27:16 <lambdabot> [Bool] -> Bool
14:27:17 <LoganCapaldo> glguy: I'm meaner than that. I've got set -o vi in my shell
14:27:22 <glguy> :t isNothing . find not
14:27:24 <lambdabot> [Bool] -> Bool
14:27:31 <LoganCapaldo> people go nuts
14:27:56 <glguy> LoganCapaldo: I had mine set like that for a little while
14:27:59 <ptolomy> Parsec is quite cool, but when my parser doesn't work as expected, I'm left rather confused. The problem is that I've come to expect things to work magically when they compile, and so I'm doing trial-and-error based on my shallow understanding of parsec..
14:28:02 <sjanssen> LoganCapaldo: that sets vi keybindings in bash?
14:28:16 <LoganCapaldo> sjanssen: not bash no
14:28:25 <LoganCapaldo> you need to edit .inputrc for bash
14:28:31 <glguy> :t not . elem False
14:28:33 <lambdabot> [Bool] -> Bool
14:28:37 <LoganCapaldo> set editing-mode vi or some such
14:28:46 <glguy> :t notElem False
14:28:48 <lambdabot> [Bool] -> Bool
14:29:05 <LoganCapaldo> of course the upside to .inputrc is I got my vi keybindings in ghci too :)
14:29:19 <glguy> > notElem False []
14:29:20 <lambdabot>  True
14:31:11 <glguy> :t not . null . filter not
14:31:14 <lambdabot> [Bool] -> Bool
14:31:32 <glguy> err, ax the first not .
14:31:44 <glguy> hmm... ok, I'm done
14:32:12 <goltrpoat> ptolomy:  probably the main thing to remember about parsec is that p <|> q will only evaluate q if p has not consumed any input
14:32:20 <ddarius> @djinn Int
14:32:20 <lambdabot> -- f cannot be realized.
14:32:49 <chessguy> ?where thunk
14:32:49 <lambdabot> thunk is now known as xmonad
14:32:53 <chessguy> nice
14:32:57 <chessguy> ?where xmonad
14:32:57 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
14:33:12 <glguy> ptolomy: to get around that you'll need to look at try
14:33:13 <LoganCapaldo> @djinn Int -> Int
14:33:13 <lambdabot> f a = a
14:33:14 <goltrpoat> ptolomy:  so something like (thisWillSucceed >>= \e -> thisWillFail >>= \q -> return . (e,q)) <|> someOtherParser will never get to someOtherParser
14:33:26 <chessguy> there's still a typo at the beginning of the README
14:33:38 <chessguy> oh, never mind, they did fix it
14:34:16 <goltrpoat> er.  return (e,q) not return . (e,q)
14:34:27 <ptolomy> Ahh..
14:34:54 <ptolomy> do I need to end with a 'eof' to ensure that all input is consumed?
14:35:13 <goltrpoat> so combinators that can fail at any stage, after consuming input, need a try around them
14:35:20 <goltrpoat> yes
14:35:50 <LoganCapaldo> but don't necessarily go hog wild with the try's either
14:35:55 <goltrpoat> (but then, indiscriminate uses of try tend to produce remarkably slow parsers)
14:35:58 <goltrpoat> right
14:36:01 <LoganCapaldo> try to left factor when possible
14:37:19 <ptolomy> hmm.... so (succeeds >>= \a -> try fails >>= \b -> return (a,b)) <|> anotherParser    will get to someOtherParser, but will give it the input after 'succeeds' did its consuming?
14:37:45 <goltrpoat> (try $ succeeds >>= \a -> fails >>= \b -> return (a,b)) <|> anotherParser
14:37:53 <LoganCapaldo> ptolomy: no
14:38:01 <LoganCapaldo> err
14:38:03 <LoganCapaldo> well maybe
14:38:10 <LoganCapaldo> but I don't think thats a good idea
14:38:19 <goltrpoat> try fails is indistinguishable from fails, assuming fails actually fails :)
14:38:48 <ptolomy> .. so try is only useful in conjunction with <|>, mostly.
14:39:06 <LoganCapaldo> yeah its not optional
14:39:11 <ptolomy> or "when on the same 'level' as <|>".
14:39:19 <LoganCapaldo> its just so you can back track if necessary
14:40:24 <ptolomy> is the explicit optional consumption needed, or in place so that parsec can be speedy?
14:41:38 <LoganCapaldo> are you asking about try?
14:42:00 <LoganCapaldo> the fact that it doesn't backtrack by default is so it can be speedy
14:43:45 <LoganCapaldo> its needed only in the sense that some things are very difficult to write without it
14:44:00 <ptolomy> Ah.
14:44:02 <ptolomy> Neato.
14:44:06 <LoganCapaldo> (if not impossible)
14:44:56 <LoganCapaldo> I suppose you can left factor almost anything, but its gonna end up not looking like your original grammar, and your gonna end up doing more munging of the data once you are done parsing
14:45:27 <liquidengineer> Howdy
14:45:40 <liquidengineer> I've got a problem with a stck overflow when processing a complex record type
14:45:40 <goltrpoat> you shouldn't need try for any LL(k) grammar, right.. since you shouldn't *have to* backtrack
14:46:11 <hpaste>  liquidengineer pasted "stack overflow on datatype" at http://hpaste.org/972
14:46:29 <mightybyte> @src suffix
14:46:29 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:46:36 <mightybyte> @src suffixes
14:46:36 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:46:44 <mightybyte> @src tails
14:46:44 <lambdabot> tails []         = [[]]
14:46:44 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
14:46:58 <glguy> liquidengineer: are you aware that you can alter existing records?
14:47:12 <glguy> liquidengineer: instead of redefining the with the unchanged fields duplicated?
14:47:18 <liquidengineer> glguy: no...
14:47:19 <liquidengineer> how do I do that?
14:47:31 <glguy> let r = Record { a=1, b=2 } in r { a = 3 }
14:47:42 <glguy> the result is Record { a = 3, b = 2 }
14:48:56 <liquidengineer> glguy: does the ! I put on the progPop field do anything?
14:48:58 <LoganCapaldo> well try is how you look ahead the k characters
14:49:12 <liquidengineer> I meant for it to force the interpreter to evaluate the list, instead of doing it lazily
14:49:19 <LoganCapaldo> err tokens
14:49:29 <glguy> liquidengineer: it doesn't force the whole list to evaluate
14:49:59 <ptolomy> Wow. My actual issue couldn't have been stupider. I was returning the result of 'eof' instead of my main parser. Maybe types are there for a reason..
14:50:09 <LoganCapaldo> without try Parsec is (almost) LL(1) (ignoring the fact that it can be context sensitive)
14:50:20 <monochrom> haha ptolomy
14:50:30 <liquidengineer> glguy: then what does it do?
14:50:49 <glguy> I evaluates until it finds a (:) or a []
14:51:14 <glguy> in the case of list
14:51:47 <glguy> liquidengineer: sort (nub xs) == slow
14:52:16 <mauke> what the hell. who sorts nub?
14:52:33 <liquidengineer> mauke: I wanted to sort only after I removed duplicates
14:52:41 <mauke> why?
14:52:41 <liquidengineer> Mauke: me, apparently -_-
14:52:47 <liquidengineer> mauke: because I don't want the duplicates?
14:52:51 <monochrom> nub is slow. yeah.
14:53:01 <glguy> > Data.Set.toList $ Data.Set.fromList [1,4,2,5,123,4,1,2,4,1,2,3]
14:53:01 <mauke> yeah, but it would be a lot faster to sort first, then drop adjacent dups
14:53:02 <lambdabot>  [1,2,3,4,5,123]
14:53:05 <sjanssen> liquidengineer: use Set.toList . Set.fromList instead
14:53:11 <mauke> nub is like O(n^2)
14:53:12 <monochrom> hehe
14:53:20 <glguy> mauke: s/like/
14:53:23 <glguy> :-D
14:53:39 <LoganCapaldo> I thought nub was O(1) :)
14:53:39 <glguy> sjanssen: I'm on board :)
14:53:45 <mauke> @type map head . group . sort
14:53:46 <sjanssen> @quote stereo
14:53:47 <lambdabot> forall a. (Ord a) => [a] -> [a]
14:53:47 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
14:53:59 <LoganCapaldo> > const 1 (nub [1..])
14:54:00 <lambdabot>  1
14:54:01 <sjanssen> mauke: that is often slower than the set version
14:54:14 <mauke> hmm, why?
14:54:15 <Cale> > head (nub [1..])
14:54:17 <lambdabot>  1
14:54:34 <sjanssen> the set version is O(n log m), where n is the size of the input and m is the number of unique elements
14:54:42 <Cale> In that sense, it's O(1), but it's O(n^2) if you force the whole resulting list.
14:54:54 <sjanssen> the sort version is O(n log n)
14:55:03 <glguy> Cale: but that sense is rarely what anyone wants :-p
14:55:24 <hpaste>  liquidengineer annotated "stack overflow on datatype" with "Updated Record Function" at http://hpaste.org/972#a1
14:55:28 <Cale> Well, it can be important to consider.
14:55:36 <Cale> If you only need the start of a nubbed list.
14:55:42 <liquidengineer> glguy: is that what you were talking about?
14:55:47 <glguy> liquidengineer: yeah
14:55:49 <Cale> (maybe more than just the first element)
14:56:05 <LoganCapaldo> well nub [1..] is O(1), even without head, its just that the constant is very very very large :)
14:56:32 <glguy> LoganCapaldo: because the computer has finite memory?
14:56:41 <liquidengineer> glguy: it seems so simple...I'm assuming haskell keeps up with all of enp's fields in the background
14:56:42 <liquidengineer> Very cool
14:56:43 <Cale> It depends on whether you measure the time for reduction to WHNF, or normal form.
14:57:52 <sjanssen> @type filterM (\x -> modify (Data.Set.insert x) >> gets (Data.Set.member x))
14:57:55 <lambdabot> forall a (m :: * -> *). (Ord a, MonadState (S.Set a) m) => [a] -> m [a]
14:58:00 <LoganCapaldo> Its too bad nub [an infinite list generated by ..] isn't evaluated at compile time
14:58:05 <hpaste>  liquidengineer annotated "stack overflow on datatype" with "Update 2: Now with less nub." at http://hpaste.org/972#a2
14:58:16 <LoganCapaldo> nub [1,1..] -> [1]. nub [1..] -> [1..]
14:58:18 <LoganCapaldo> etc.
14:58:22 <glguy> liquidengineer: the output is already sorted
14:58:24 <liquidengineer> Is that better?
14:58:36 <liquidengineer> Set conversion sorts automatically?
14:58:36 <LoganCapaldo> Be a pretty silly optimization I suppose
14:58:55 <ddarius> nub [1,1..] -> 1:_|_
14:58:58 <glguy> LoganCapaldo: there are a lot of things I'd hope that the devs could spend time :)
14:59:11 <sjanssen> liquidengineer: Set maintains the elements in sorted order anyway
14:59:17 <liquidengineer> ah
14:59:20 <liquidengineer> Should've figured that
14:59:27 <liquidengineer> So I can drop the List.sort alltogether
14:59:33 <LoganCapaldo> ddarius: why?
14:59:35 <liquidengineer> I guess I need to import Data.Set?
14:59:35 <sjanssen> you should probably use toAscList if sorted output is important
14:59:39 <liquidengineer> is that the right module?
15:00:35 <ddarius> LoganCapaldo: How is nub to know that a 2 isn't going to pop out.
15:01:00 <LoganCapaldo> because of the definition of [1,1..]
15:01:18 <ddarius> Haskell isn't intensional.
15:01:32 <liquidengineer> toAscList would put things in order [1,2,3...n], right?
15:01:43 <liquidengineer> is there a toDecList?  as in, descending?
15:01:53 <LoganCapaldo> I know its not, _yet_ :)
15:02:06 <glguy> liquidengineer: there is one at least in the Data.Map, but it isn't exported!
15:02:20 <liquidengineer> would it work on a set of arbitrary type?
15:02:33 <glguy> :t Data.Set.fromList
15:02:36 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
15:02:54 <liquidengineer> ah
15:03:10 <liquidengineer> So I need to import Data.Set and Data.Map?
15:03:12 <ddarius> LoganCapaldo: That would lead to violations of referential transparency.
15:03:38 <LoganCapaldo> ddarius: I hadn't thought of that
15:03:46 <LoganCapaldo> point to you
15:05:44 <dons> re.
15:07:58 <MarcWebe1> I've written a small application to print module dependencies (http://mawercer.de/marcweber/haskell/darcs/hmoduledep/) It uses drawTree to pretty print the tree. Might be useful to explore unknown packages ;)
15:07:59 <lambdabot> Title: Index of /marcweber/haskell/darcs/hmoduledep
15:08:21 <liquidengineer> Crap
15:08:26 <liquidengineer> I'm geetting a parse error on this line
15:08:27 <liquidengineer> crossover_mutate enp = in enp { progPop = ansPop }
15:08:32 <liquidengineer> specifically use of the word in
15:09:03 <LoganCapaldo> stop using keywords as identifiers :)
15:09:09 <liquidengineer> ?
15:09:13 <liquidengineer> where?
15:09:21 <LoganCapaldo> > let a = "in is a keyword" in a
15:09:23 <lambdabot>  "in is a keyword"
15:09:34 <liquidengineer> I thought that's how I updated a field in a record
15:09:54 <LoganCapaldo> no its just enp { progPop = ansPop }
15:10:01 <liquidengineer> Oh
15:10:05 <liquidengineer> It just holds everything else over?
15:10:09 <LoganCapaldo> yep
15:10:14 <liquidengineer> Nice. :D
15:10:15 <liquidengineer> Thanks.
15:10:21 <LoganCapaldo> np
15:13:45 <hpaste>  liquidengineer annotated "stack overflow on datatype" with "Record update problem, now with terrifying runtime error." at http://hpaste.org/972#a3
15:14:18 <mauke> that doesn't look like a runtime error
15:14:22 <liquidengineer> Okay, now it's telling me something is wrong with the functional composition (I think...I don't really use functional composition that often...still a newbie)
15:14:25 <liquidengineer> err...compile error
15:14:27 <liquidengineer> sorry.
15:15:05 <mauke> try newPop = Set.toAscList (Set.fromList popParts)
15:15:12 <liquidengineer> Looks like it was expecting a function and got a list.
15:15:12 <liquidengineer> ah
15:15:24 <mauke> or newPop = (Set.toAscList . Set.fromList) popParts if you really like (.)
15:16:15 <liquidengineer> I don't like it that much
15:16:23 <liquidengineer> I would if it didn't give me errors every time I tried to use it. :P
15:16:28 <liquidengineer> though it is nicer than nested parentheses
15:17:30 <ailndx> does visual haskell work with vs express?
15:18:26 <LoganCapaldo> liquidengineer: I find that $ is easier to use for the removing of parens and not so confusing as .
15:18:56 <LoganCapaldo> newPop = Set.toAscList $ Set.fromList popParts
15:19:07 <alcojol> . is confusing?
15:19:10 <vincenz> ADEpt: ping
15:19:32 <LoganCapaldo> alcojol: to me :)
15:19:41 <LoganCapaldo> go ahead point and laugh
15:20:02 <alcojol> well, in haskell prime is proposed change . for `o`
15:20:23 <jyasskin> So then we'd have (.) available for `fmap`? ;)
15:20:31 <Eelis> i don't really consider . and $ competitors..
15:20:48 <LoganCapaldo> I'm pretty sure that won't help me read ((f `o`) `o`) quickly :)
15:20:55 * jyasskin should be ignored by newbies.
15:21:32 <cjeris> so we'd have to type 3 characters?  can't one just make o a keyword like SML did?
15:21:33 <LoganCapaldo> which is usually the level of nesting of (.) at which my brain starts to glaze over
15:21:58 <liquidengineer> damn
15:22:04 <liquidengineer> still getting the stack overflow
15:22:34 <liquidengineer> LoganCapaldo: So when I want to do composition I can just use $?
15:22:43 <LoganCapaldo> no
15:22:52 <LoganCapaldo> when you want to ditch parens you can use $
15:23:06 <LoganCapaldo> @src (.)
15:23:06 <lambdabot> (.) f g x = f (g x)
15:23:12 <LoganCapaldo> @src ($)
15:23:13 <lambdabot> f $ x = f x
15:23:23 <liquidengineer> Oh
15:23:24 <liquidengineer> cool
15:23:49 <liquidengineer> Still can't figure out where this overflow is coming from, if it wasn't all that nub stuff
15:24:02 <liquidengineer> all those functions crossover_mutate calls...I've tested them by themselves, and they work
15:24:15 <alcojol> @src foldl
15:24:15 <lambdabot> foldl f z xs = lgo z xs
15:24:15 <lambdabot>     where lgo z []     =  z
15:24:15 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
15:24:25 <LoganCapaldo> . lets you go from have parens like f (g x) to having parens like (f . g) x :)
15:24:33 <liquidengineer> ah.
15:25:06 <alcojol> LoganCapaldo: when you have more functions its usefull, por example (f .g . h . k) x
15:25:20 <LoganCapaldo> yeah
15:25:41 <LoganCapaldo> its the ((f .) .) g type stuff that makes my head spin
15:26:41 <LoganCapaldo> @type ((?f .) .) ?g
15:26:43 <lambdabot> forall b c a a1. (?f::b -> c, ?g::a1 -> a -> b) => a1 -> a -> c
15:27:31 <LoganCapaldo> hmm
15:27:47 <LoganCapaldo> so ((f .) .) is ".2"
15:27:49 <narain> nice use of ?'s
15:27:59 <LoganCapaldo> Thanks :)
15:28:32 <narain> ?type ?f . ?g
15:28:34 <lambdabot> forall b c a. (?f::b -> c, ?g::a -> b) => a -> c
15:29:34 <liquidengineer> Well, my code is definitely faster now
15:29:41 <liquidengineer> I'm getting the stack overflow much quicker. ;P
15:29:52 <LoganCapaldo> @type (?f `ap` .) ?g
15:29:54 <lambdabot> parse error on input `.'
15:30:03 <LoganCapaldo> @type (?f `ap` (.)) ?g
15:30:05 <lambdabot> forall b b1 c a. (?f::(b1 -> c) -> ((a -> b1) -> a -> c) -> b, ?g::b1 -> c) =>
15:30:13 <dons> ?users
15:30:13 <lambdabot> Maximum users seen in #haskell: 336, currently: 317 (94.3%), active: 46 (14.5%)
15:36:52 <liquidengineer> How does one define an instance of Data.Typeable on a record type?
15:37:26 <dons> derive Typeable ?
15:37:46 <mgsloan> hey, what's the reasoning for not allowing say, a list which holds a particular class - like [Num]?
15:38:15 <ddarius> mgsloan: Because that makes no sense.
15:38:22 <quicksilver> mgsloan: it is allowed, in fact
15:38:30 <quicksilver> at least, what you probably mean is allowed
15:38:35 <liquidengineer> dons: oh.  yeah
15:38:37 <mauke> existentials?
15:38:59 <dons> mgsloan: you'd use an existential type for that
15:39:03 <mgsloan> mm
15:39:06 <dons> data T = forall a. Num a => T a
15:39:23 <dons> let x :: [T] ; [T 1, T 9.2]
15:39:35 <mgsloan> ddarius: it does make sense - if only class functions are used to interact with the list
15:39:39 <dons> which is just about an object in the OO sense
15:39:51 <dons> interface wrapped in with the value
15:39:57 <ddarius> mgsloan: What you were trying to say makes sense, what you actually said makes no sense.
15:40:09 <quicksilver> although for Num in particular, it wouldn't be very useful
15:40:17 <quicksilver> since the interesting functions on Num are binary
15:40:23 <LoganCapaldo> well if type classes were first class values it would be awesome :)
15:40:23 <quicksilver> and you wouldn't be able to invoke them :)
15:40:34 <mgsloan> no? you could define arbitrary ops on lists of things that do +/-
15:40:38 <mgsloan> etc
15:40:43 <LoganCapaldo> let a = [Num, Num] :)
15:40:46 <quicksilver> :t (+)
15:40:48 <lambdabot> forall a. (Num a) => a -> a -> a
15:40:52 <ddarius> LoganCapaldo: What would that even mean?
15:41:02 <quicksilver> mgsloan: note that the two 'a' are the same
15:41:10 <mgsloan> ah
15:41:18 <quicksilver> mgsloan: it *isn't* (Num a, Num b) => a ->b -> b
15:41:29 <LoganCapaldo> nothing I'm just being facetious in order to entertain. I'll stop now
15:41:43 <quicksilver> mgsloan: since you can't prove two elements in the list are the same instance you wouldn't be able to use that
15:41:49 <quicksilver> :info Num
15:41:51 <ddarius> So you have to package proofs of type equality with your values.
15:42:02 <mgsloan> LoganCapaldo: that would actually pretty cool, if we had compile-time code
15:42:12 <LoganCapaldo> Is that not what TH is?
15:42:16 <quicksilver> mgsloan: but yes, it's useful for types with unary functions
15:42:35 <LoganCapaldo> How would you call show on some T for instance?
15:43:02 <LoganCapaldo> (assuming T was data T forall a. Show a => T a)
15:43:20 <ddarius> show (T x) = show x
15:43:28 <sorear> hello.
15:43:28 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:44:07 <sorear> @messages
15:44:07 <lambdabot> benja_ said 7h 22m 26s ago: if you get to the point where you start to have code for IRC please let me now, I'm interested in looking :) [even before it's working]
15:44:28 <sorear> @seen benja_
15:44:28 <lambdabot> benja_ is in #happs and #haskell. I last heard benja_ speak 7h 22m 48s ago.
15:44:48 <sorear> ah that kind of irccode
15:44:54 <hpaste>  liquidengineer annotated "stack overflow on datatype" with "Non-exhaustive patterns on CrossNCouples?" at http://hpaste.org/972#a4
15:45:18 <liquidengineer> I'm covering an empty list and a non-empty list case here
15:45:21 <liquidengineer> what else does it want from me?
15:46:36 <quicksilver> liquidengineer: you have list-of-at-least 2
15:46:41 <quicksilver> liquidengineer: what about list of length 1?
15:46:45 <goltrpoat> sorear:  thanks for the lexer link..  i just ended up writing mine in parsec and cheating by reusing haskellDef for comments and whatnot
15:47:21 <sorear> goltrpoat: what parser are you using?
15:47:23 <liquidengineer> quicksilver: Oh.
15:47:34 <sorear> goltrpoat: I'm stuck on that part :)
15:47:40 <liquidengineer> thanks.
15:47:49 <goltrpoat> sorear:  what do you mean?
15:47:53 <sorear> goltrpoat: I have a working JohnMeacham layout rule, and a lexer...
15:48:13 <goltrpoat> the lexer actually performs layout rule conversions
15:48:23 <sorear> goltrpoat: Haskell-src?
15:48:35 <sorear> goltrpoat: no mine doesn't
15:48:47 <goltrpoat> i mean, my lexer does :)
15:48:54 <goltrpoat> the parser gets through about 300 lines of the prelude so far
15:48:59 <goltrpoat> not a huge amount of work left
15:49:05 <goltrpoat> as far as that's concerned anyway
15:49:09 <ddarius> "JohnMeacham layout rule"?
15:49:26 <sorear> @wher getlaid
15:49:26 <lambdabot> Maybe you meant: where where+
15:49:30 <sorear> @where getlaid
15:49:31 <lambdabot> I know nothing about getlaid.
15:50:29 <sorear> http://www.mail-archive.com/haskell-prime@haskell.org/msg01938.html
15:50:30 <lambdabot> Title: New Layout Rule, http://tinyurl.com/2x7qot
15:51:11 <sorear> goltrpoat: did you write the parser yourself?
15:51:19 <goltrpoat> yep
15:51:25 <sorear> goltrpoat: I'm impressed ...
15:51:41 <goltrpoat> well.. it's not quite finished, like i said it only gets through about 300 lines of the prelude so far
15:52:06 <sorear> goltrpoat: I'm having enough difficulty extracting something useful, starting from the Hugs parser :)
15:54:31 * ddarius considers sleep.
15:55:11 <goltrpoat> once i had the lexer and the layout rule working, it was mostly a matter of translating the context-free syntax in the report into types and parsecese
15:55:35 <goltrpoat> oh.. i also cheated in the lexer and made ( and ) reserved
15:55:52 <sorear> ( and ) *are* reserved
15:55:53 <dons> article for the day, since no one is writing blogs , http://programming.reddit.com/info/1akhl/comments
15:55:54 <lambdabot> Title: Developing a high performance web server in concurrent Haskell (pdf) (reddit.com ...
15:55:57 <sorear> production "special"
15:56:03 <sorear> hi dons
15:56:08 <goltrpoat> sorear:  i thought they would be, but i don't see anything of the sort in the report
15:56:32 <Igloo> dons: Should there be a Haskell SoC announcement or something?
15:56:39 <dons> there should be today, yes.
15:56:41 <goltrpoat> oh my god.
15:56:47 <goltrpoat> i actually managed to miss it, looks like
15:57:02 <Igloo> OK
15:57:11 <goltrpoat> it's under special characters, and i misread it to mean (|), as in the | character, not ( or )
15:57:13 <goltrpoat> haha
15:57:16 <goltrpoat> ok well.. that helps.
15:57:49 <sorear> goltrpoat: and you handle fixities correctly?
15:58:23 <goltrpoat> sort of.  currently, i'm handling top-level fixity declarations correctly
15:58:42 <goltrpoat> i know how i'm going to do local fixity declarations, but haven't gotten around to it yet
16:02:53 <LPhas> hi, I've  a program that forks some threads, i want it to wait until they are all terminated, how can i do it?
16:04:04 <LoganCapaldo> @hoogle join
16:04:04 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
16:04:04 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
16:04:04 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
16:04:10 <LoganCapaldo> eh
16:04:15 <LoganCapaldo> it was worth a shot
16:04:42 <matthew-_> LPhas, with a channel
16:04:48 <dons> LPhas: there's a discussion of this in the docs for Control.Concurrent
16:04:59 <matthew-_> get them to write to the channel before death, then block on receiving from the channel
16:05:03 <dons> using an MVar or Chan, you can signal the main thread when you're done
16:05:12 <dons> ?docs Control.Concurrent
16:05:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
16:05:17 <dons> look for the stuff on children threads
16:05:34 <LoganCapaldo> wait so I was totally off, and theres no equivalent to pthread_join?
16:05:38 <LoganCapaldo> I'm kinda surprised
16:05:42 <LPhas> dons: you mean this? http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#11 it use a spinlock!
16:05:44 <lambdabot> http://tinyurl.com/33wpmr
16:05:54 <mauke> write-on-death sucks
16:06:08 <matthew-_> mauke: why?
16:06:11 <dons> i usually use a Chan
16:06:14 <dons> and wait on it
16:06:23 <mauke> because it's easy to forget
16:06:31 <mauke> I want something like unix pipes
16:06:33 <matthew-_> not if we add in session types
16:06:46 <matthew-_> if you add in session types then it won't compile if you forget
16:06:51 <matthew-_> problem solved ;-)
16:06:58 <mauke> no matter how your process exits, it closes your filedescriptors
16:07:01 <dons> LPhas: its not spinning though, those MVars do block, so only N block sare taken
16:07:09 <matthew-_> well, s/session types/pi-calculus deadlock-free typesystems/
16:07:13 <LPhas> dons: oh
16:07:14 <dons> it just waits on each thread one by one
16:07:20 <mauke> matthew-_: that doesn't help with runtime crashes
16:07:24 <LPhas> dons ok
16:07:29 <dons>     	    putMVar children ms
16:07:29 <dons>     	    takeMVar m
16:07:29 <dons>     	    waitForChildren
16:07:44 <matthew-_> mauke: very true. so you want something like Erlang's bidirectional process links then
16:07:58 <matthew-_> so that even if the worst happens, *someone's* going to hear about it
16:07:58 <mauke> I don't know erlang
16:08:15 <matthew-_> mauke: worth a look - they've been dealing with this kinda issue for a long time
16:08:19 <mauke> I just know how unix pipes work
16:09:13 <matthew-_> right, I'm off to bed. nn
16:09:44 <dons> LPhas: actually, I used exactly this code to wait on a list of chlidren threads:
16:09:48 <dons> wait cs = do
16:09:50 <dons>    xs <- takeMVar cs
16:09:53 <dons>    case xs of
16:09:55 <dons>      []   -> return ()
16:09:58 <dons>      m:ms -> do
16:10:00 <dons>         putMVar cs ms
16:10:03 <dons>         takeMVar m
16:10:05 <dons>         wait cs
16:10:58 <LPhas> ok, thx
16:15:32 <jfoutz> what am i missing here? data Foo a = F { changer :: a -> b }
16:15:51 <jfoutz> how do i introduce b into that datatype declaration, or is that possible?
16:16:11 <kpreid> you mean, make it another parameter?
16:16:14 <kpreid> data Foo a b = F ...
16:16:16 <jfoutz> yeah
16:16:24 <kpreid> just like function arguments
16:16:52 <jfoutz> i'd swear i tried that.
16:16:54 <jfoutz> thanks!
16:17:44 <jfoutz> ohhhh. i tried data Foo (a,b) ... like with typeclass constraints
16:22:09 <ailndx> !paste
16:22:09 <hpaste> Haskell paste bin: http://hpaste.org/
16:22:39 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/973
16:24:12 <sorear> @seen ndm
16:24:12 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 2h 48m 36s ago, and .
16:29:13 <ailndx> hmm does file name has to match module name?
16:29:29 <sorear> ailndx: yes
16:29:44 <sorear> (with one exception: module Main can be called anything)
16:30:36 <ailndx> but that doesnt really make any sence of what ive seen, Eval.hs in lambdabot defines: "module Plugin.Eval where"?
16:30:44 <goltrpoat> Plugin/Eval.hs
16:30:47 <malsyned> There's really no way to build a binary and pull the main function from a module other than Main, is there?
16:31:03 <sorear> sure there is
16:31:08 <malsyned> yeah?
16:31:10 <malsyned> do tell!
16:31:36 <sorear> ghc --make -o fii --main-is Foo.bar Foo.hs  # WARNING: Nonportable!
16:31:57 <ailndx> ooh
16:32:41 <sorear> @susrs
16:32:41 <lambdabot> Maximum users seen in #haskell: 336, currently: 311 (92.6%), active: 52 (16.7%)
16:32:45 <ailndx> But in some files i also seen that they have skipped: module <something> where, when doesnt this has to be defined?
16:33:00 <malsyned> ailndx: it's always defined as "module Main where" when left out.
16:33:13 <ailndx> ah okay
16:33:15 <malsyned> double-ooh.  thanks, sorear
16:34:03 <goltrpoat> sorear:  main-is in cabal is portable though, right
16:34:19 <goltrpoat> or were you referring to something else
16:34:46 <sorear> goltrpoat: something else. the cabal flag selects the *filename* of the Main module, we're using a different module name.
16:35:10 <goltrpoat> ah, gotcha
16:35:23 <sorear> malsyned: note that you can have Bar.hs containing module Main where ... main = ... and stay portable
16:35:25 <ailndx> Could not find module `Data.ByteString.Char8':
16:35:44 <ailndx> import qualified Data.ByteString.Char8 as P
16:35:52 <sorear> ailndx: install fps
16:36:02 <ailndx> fps?
16:36:06 <ailndx> frames per second
16:36:08 <sorear> ailndx: does the message mention hidden-ness?
16:36:16 <sorear> ailndx: no, Fast Packed String
16:36:18 <sorear> @where fps
16:36:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
16:36:20 <dcoutts__> ailndx: or update to ghc-6.6
16:36:35 <ailndx> oh, yeah maybe i should do that
16:36:38 <ailndx> using 6.4
16:36:40 <ailndx> .1
16:36:49 <ailndx> thx
16:37:15 <malsyned> sorear: my interest isn't really in staying portable.  It's in developing a module and using "main" as a tester, without needing to go to the trouble of making a whole other module in order to test out the functions.  Sometimes the REPL is nice, but sometimes it isn't.  I just like to know I've got options when I'm developing.
16:38:01 <sorear> malsyned: ok.  you want --main-is, then.
16:38:10 <malsyned> yup.  that's awesome.  thanks.
16:48:25 <hpaste>  liquidengineer annotated "stack overflow on datatype" with "Stack overflow." at http://hpaste.org/972#a5
16:48:37 <liquidengineer> Okay
16:48:39 <liquidengineer> I'm really confused here
16:48:43 <liquidengineer> this function overflows
16:49:02 <liquidengineer> but if I run each of the individual function calls within the where statement on their own in ghci, everything works.
16:49:48 <LoganCapaldo> maybe its too lazy?
16:52:14 <liquidengineer> LoganCapaldo: Agreed.
16:52:19 <liquidengineer> though I have no idea how to unlazy it.
16:52:33 <LoganCapaldo> throw some seqs around?
16:52:53 <liquidengineer> ?
16:53:11 <liquidengineer> in my data type, I put a ! in front of the field containing a very long list
16:53:19 <liquidengineer> should I put those in front of all the fields?
16:53:24 <liquidengineer> (I don't know what a seq is...)
16:53:34 <LoganCapaldo> @doc seq
16:53:34 <lambdabot> seq not available
16:54:19 <LoganCapaldo> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Aseq
16:54:21 <lambdabot> http://tinyurl.com/ovjef
16:54:43 <LoganCapaldo> maybe even use $!
16:54:51 <LoganCapaldo> > head $ [1..]
16:54:53 <lambdabot>  1
16:55:00 <LoganCapaldo> > head $! [1..]
16:55:01 <lambdabot>  1
16:55:06 <LoganCapaldo> err
16:55:09 <LoganCapaldo> heh
16:55:19 <liquidengineer> I don't really understand how to use seq
16:55:31 <liquidengineer> it's documentation is sort of confusing
16:55:40 <liquidengineer> are there examples somewhere?
16:56:00 <LoganCapaldo> maybe? :)
16:56:05 * LoganCapaldo is mostly guessing
16:56:08 <dons> > length [1..] `seq` 2
16:56:12 <lambdabot> Terminated
16:56:13 <dons> WHNF !
16:56:20 <LoganCapaldo> right
16:56:26 <LoganCapaldo> silly me
16:56:39 <liquidengineer> ?
16:56:51 <liquidengineer> dons: WHNF?
16:57:02 <liquidengineer> I'm not familiar with that acronym
16:57:07 <dons> seq [1..] -->  1 : xs.
16:57:13 <dons> head (1: xs) == 1
16:57:19 <LoganCapaldo> > let lazySeq a b = b in length [1..] `lazySeq` 2
16:57:20 <lambdabot>  2
16:57:22 <dons> seq reduces its argument to weak head normal form
16:57:29 <dons> i.e. to the outermost constructor
16:57:34 <liquidengineer> ah
16:57:35 <dons> so for a list, that is:   1 : (... )
16:57:40 <dons> or,  Cons 1 _
16:57:49 <liquidengineer> OH!
16:58:10 <dons> so its not head normal form, its a weak head normal form. as little evaluation is done as possible
16:58:13 <dons> hence:
16:58:17 <dons> > [1..] `seq` 2
16:58:19 <lambdabot>  2
16:58:25 <dons> only reduces [1..] to 1 : _
16:58:37 <liquidengineer> this looks like it's just for lists
16:58:39 <dons> however, length [1..] `seq` 2 has to reduce length [1..] to an Int constructor
16:58:46 <dons> which it only can get by evaluation of the whole list
16:58:53 <liquidengineer> I'm still confused about how to use this...
16:59:00 <liquidengineer> what do I want to call seq on?
16:59:21 <dons> its first argument is the value you wish to reduce to WHNF
16:59:27 <dons> its second argument is the rest of the expression
16:59:35 <dons> > let x = last [1..1000] in x `seq` x + 2
16:59:36 <lambdabot>  1002
16:59:51 <liquidengineer> Oh
16:59:52 <dons> says to evaluate 'x' to WHNF, then evaluate x+2
16:59:58 <liquidengineer> That makes sense
17:00:05 <dons> so, it really does insert some evaluation order, into our lovely pure haskell
17:00:09 <liquidengineer> so I can put one of those in a where statement, I guess?
17:00:13 <dons> which means you can start to inspect computations that diverge
17:00:27 <dons> so what are you using seq for?
17:00:30 <liquidengineer> dons: is there a reason my code would work in GHCi but overflow in ghc?
17:00:52 <dons> optimisations messing with the code?
17:00:54 <liquidengineer> dons: I've got a function that stack overflows when I try to run it
17:00:59 <dons> you using ghc -O or ghc -O2 ?
17:01:10 <liquidengineer> now, if I take the body of that function and type it into GHCi, everything works
17:01:17 <liquidengineer> no, I'm not.  Should I be?
17:01:19 <dons> yes
17:01:26 <liquidengineer> what do they do?
17:01:29 <dons> there's no reason to use ghc if not for -O
17:01:30 <liquidengineer> and which one do I want?
17:01:37 <dons> they enable 20 years of compiler optimisatoins :-)
17:01:41 <dons> -O usually
17:01:48 <liquidengineer> what's O2?
17:01:52 <dons> -O2 if you know you need one of the more dangerous optimisations
17:01:56 <liquidengineer> ah
17:02:01 <dons> which might potentially slow down the code
17:02:06 <dons> -O should always be (a lot) faster
17:02:06 <liquidengineer> that'd be bad
17:02:22 <dons> ghc should probably be -O by default
17:02:36 <dons> since people use ghc for speed, but don't always know to turn on optimisations
17:03:07 <Lemmih> -O is pretty slow.
17:03:41 <dons> SoC'ers, interesting: http://wiki.squeak.org/squeak/SummerOfCode
17:03:45 <lambdabot> Title: Google Summer of Code 2007
17:03:49 <dons> Lemmih: you betcha, and getting slower :-)
17:03:52 <dons> rewrite rules forever!
17:04:08 <liquidengineer> dons: will this help with my stack overflow problem?
17:04:36 <dons> sorry, i'm off to work. Lemmih can help :-)
17:04:46 <liquidengineer> Okay. :D
17:04:48 <liquidengineer> Thanks.
17:04:51 <liquidengineer> Hmm....
17:04:53 <liquidengineer> still doesn't work.
17:05:03 <liquidengineer> I guess I need to use some seq stuff?
17:05:11 <dons> stack overflows are usually due to space leaks in accumulators in loops
17:05:28 <liquidengineer> it's wierd, though, because I'm using the exact same code from my module
17:05:34 <liquidengineer> I'm just pasting it into ghci
17:05:48 <dons> ghci is a bytecode interpreter though, sometimes it behaves a little differently
17:05:56 <dons> what happens when you load the code in ghci and type 'main' ?
17:06:02 <liquidengineer> there is no main
17:06:09 <dons> how do you compile it then?
17:06:26 <liquidengineer> I just call ghci on it and run my functions in teh command line
17:06:32 <sorear> dons: work?  oh!
17:06:48 <liquidengineer> I'm not to the point of compiling executables yet
17:06:50 <dons> you said it behaves differently in ghc though, liquidengineer ?
17:06:58 <liquidengineer> dons: yeah
17:07:01 <liquidengineer> a bad choice of words
17:07:09 <dons> um yes. what did you mean by 'ghc' ?
17:07:09 <liquidengineer> I've got a bunch of modules full of test code
17:07:23 <liquidengineer> the test code fails when I load it in ghci and run it
17:07:27 <liquidengineer> stack overflow
17:07:30 <dons> ok.
17:07:45 <liquidengineer> but if I take the body of those functions and paste them straight into GHCi they work fine.
17:07:51 <dons> so you mean the data the testcode passes triggers the overflow?
17:07:58 <liquidengineer> no
17:08:01 <liquidengineer> the data is the same
17:08:04 <liquidengineer> Hold on a second.
17:08:06 <dons> is there a bug in the test code?
17:08:08 <liquidengineer> let me put some stuff in the pastebin
17:08:09 <sorear> Lemmih: ghc period is pretty slow.  I was ... dumbfounded by gcc's speed (gcc -O2 -funit-at-a time vs. ghc -Onot) the first time I ran gcc in >6 months...
17:08:12 <liquidengineer> that'll make this easier to explain.
17:08:16 <liquidengineer> sorry. :)
17:08:20 <dons> if you're running both of them in ghci , then they should be identical
17:08:36 <dons> sorear: asm versus lambda calculus ;-)
17:08:41 <dons> though, ocaml's compiler is pretty fast too
17:08:53 <dons> -fasm is a lot nicer on ghc though
17:09:08 <dons> since its actually gcc doing half the slow down, when it gets those 100k lines of C files
17:09:37 <dcoutts__> dons: I want rules with contexts: forall n m f g. read n f >>= \x -> read m g >>=\y -> C[x,y]  = read (n+m) (f >>= \x -> g >>= \y -> return (x,y)) >>= \(x,y) -> C[x,y]
17:10:20 <dcoutts__> dons: and I want unpack on data decls that use function types
17:10:20 <dons> yikes.
17:10:24 <dcoutts__> eg...
17:11:34 <dcoutts__> newtype Put a = Put { runPut :: (a -> {-# UNPACK #-} Buffer -> [B.ByteString]) -> {-# UNPACK #-} Buffer -> [B.ByteString] }
17:12:03 <dcoutts__> the point is that runPut will always take the Buffer in an unpacked form
17:12:10 <hpaste>  liquidengineer annotated "stack overflow on datatype" with "Comparative Code" at http://hpaste.org/972#a6
17:12:10 <dons> ah
17:12:23 <dcoutts__> so if you ever construct one then it get's unboxed automagically
17:12:24 <liquidengineer> There we go
17:12:35 <dons> dcoutts__: hmm. yes. we want a proper worker generated for runPut, no?
17:12:40 <dons> does that ever happen now?
17:12:52 <waern> dcoutts, I compiled gtk2hs from darcs on macosx with GHC HEAD and got a bus error when I ran an example program :/. I figured the problem is probably GHC, but has there been any issues on macosx with gtk2hs?
17:12:53 <liquidengineer> dons: The crossover_mutate function is in one of my modules.  The rest of it is from my testing module, and designed to test each piece of crossover_mutate by itself.
17:13:03 <dcoutts__> dons: so it'd still be ok to take continuations from the outside, but they'd get a wrapper that unpacks them to be able to fit the unpacked form
17:13:05 <liquidengineer> crossover_mutate fails, whereas the other stuff doesn't.
17:13:15 <dons> dcoutts__: right.
17:13:27 <dons> dcoutts__: so if we wrote this monad by hand, without do notation, we could do that.
17:13:34 <dons> our runPut would be a function strict in its buffer arg?
17:13:43 <dcoutts__> dons: but in all other cases we've got the unpacked form available anyway so no unpacking is needed
17:13:48 <dons> which is something we don't get using the record way.
17:14:09 <dcoutts__> dons: so it's obviously not always an optimisation, but in this case we know it is, so a pragma is appropriate
17:14:24 <dons> yeah
17:14:45 <dons> liquidengineer: i'll have a play on the bus. do you have input data?
17:14:54 <dcoutts__> dons: right, it's always strict in its buffer and takes all the contents as separate args, esp the Ints and Addr#
17:15:09 <dcoutts__> dons: that way we get 0 allocations in the fast path
17:15:20 <liquidengineer> dons: aye.
17:15:23 <dons> yeah. but there's no way to get an Addr# if we define it inside the newtype?
17:15:27 <dcoutts__> dons: which also means no heap checks
17:15:34 <liquidengineer> of course, all the functions that crossover_mutate uses aren't in mmy paste
17:15:34 <dons> true!
17:15:41 <liquidengineer> should I paste them too?
17:16:03 <dcoutts__> dons: hmm? we could obviously manually unpack the Buffer and the ForeignPtr inside the Buffer to get the Addr#, I want that done automatically.
17:16:10 <dons> liquidengineer: can you make the entire src available somewhere, including instructions on building and providing test data
17:16:30 <dons> dcoutts__: right.
17:16:30 <liquidengineer> Yeah, I can.
17:16:53 <dcoutts__> dons: to make the semantics right, I might need to put !'s in the data decl
17:16:55 <dons> liquidengineer: i'd start by sticking strict fields in that EvolvableNimPlayers record
17:16:58 <dcoutts__> newtype Put a = Put { runPut :: (a -> {-# UNPACK #-} !Buffer -> [B.ByteString]) -> {-# UNPACK #-} !Buffer -> [B.ByteString] }
17:17:03 <dcoutts__> which is also an extension
17:17:19 <dons> dcoutts__: yes. i see. but we do want this ability, I think.
17:17:25 <dcoutts__> yes
17:22:54 <liquidengineer> dons: I've put a zip of my code with instructions for loading it here
17:22:55 <liquidengineer> http://theliquidengineer.org/nim/
17:22:56 <lambdabot> Title: Index of /nim
17:23:25 <liquidengineer> test data is built in to the TestNim.lhs file.
17:26:07 <liquidengineer> dons: what are strict fields?
17:26:12 <liquidengineer> is that the thing with !?
17:26:16 <liquidengineer> err.. !
17:28:17 <dons> liquidengineer: yeah, T { x :: !Int }
17:28:50 <dons> ok. got the src
17:31:11 <liquidengineer> dons: cool.  Thanks for taking the time to help me with this.  It's been driving me up the wall.
17:33:20 <jcreigh> what does it actually mean for the field to be "strict"? How deeply is it evaluated?
17:33:41 <liquidengineer> dons: I made all the fields strict, btw.  No change.
17:34:08 <dons> jcreigh: WHNF, `seq` on updates
17:34:54 <hpaste>  BSP pasted "weird errors in monadic instance" at http://hpaste.org/974
17:35:12 <Batterseapower> yeah, can anyone tell me what i'm doing wrong there? :)
17:36:03 <sorear> Batterseapower: just use cunning newtype deriving
17:37:15 <Batterseapower> there is something cunning i can do? yay! but how?
17:37:16 <hpaste>  sorear annotated "weird errors in monadic instance" with "eliminate monad instance using a cool ghc ext" at http://hpaste.org/974#a1
17:37:38 <sorear> the deriving(Monad) is the important bit
17:37:49 <Batterseapower> ahh, great..
17:37:54 <Batterseapower> i wonder if that fixes it
17:38:29 <Batterseapower> no ^_^
17:38:37 <Batterseapower> but its another bit of my code i can scrap, at least
17:38:58 <sorear> dons: yay, I can parse 'module Main where {}' :)
17:41:45 <hpaste>  BSP annotated "weird errors in monadic instance" with "(no title)" at http://hpaste.org/974#a2
17:44:24 <goltrpoat> deriving (Monad) ??
17:44:35 <goltrpoat> whoa, i had no idea
17:44:38 <sorear> goltrpoat: isn't it wonderful!
17:44:44 <Batterseapower> it is cute
17:45:02 <Batterseapower> is there a list of what GHC can derive anywhere?
17:45:10 <sorear> goltrpoat: anyway, if you want to parse real haskell, that is one very important extension
17:45:19 <sorear> Batterseapower: for newtypes, absolutely anything.
17:45:44 <sorear> Batterseapower: for data, Eq, Ord, Bounded, Ix, Read, Show, Enum, Data, Typeable, and I think that's it.
17:46:03 <sorear> @where manual
17:46:03 <lambdabot> I know nothing about manual.
17:46:17 <liquidengineer> @where hoffa
17:46:17 <lambdabot> I know nothing about hoffa.
17:46:19 <sorear> @where+ manual http://haskell.org/ghc/dist/current/docs/users_guide/
17:46:19 <lambdabot> Done.
17:46:20 <Batterseapower> hmm, interesting.. thanks :)
17:46:39 <sorear> Batterseapower: http://haskell.org/ghc/dist/current/docs/users_guide/data-type-extensions.html#newtype-deriving
17:46:41 <lambdabot> Title: 7.4. Extensions to data types and type synonyms, http://tinyurl.com/t6nce
17:49:32 <goltrpoat> sorear:  i'll have to read up on it, i had no idea that even existed
17:49:46 <glguy> sorear: what about newtype deriving?
17:50:10 <glguy> hmm, maybe I didn't scroll back far enough
17:50:40 <rahikkala> "The token "derive" is a keyword only when followed by "instance"; you can use it as a variable name elsewhere." <- yayzorz, teh syntax!
17:50:53 <liquidengineer> oh dear
17:50:55 <liquidengineer> I've gotta go
17:50:59 <liquidengineer> I shall return.
17:51:06 <kc5tja> Don't you threaten us...
17:51:07 <kc5tja> ;)
17:51:28 * liquidengineer is not MacArthur
17:51:42 <sorear> glguy: how's hpaste?  done?
17:51:50 <kc5tja> The joke just doesn't have the same punch on IRC as it does in person.
17:52:07 <liquidengineer> heh
17:52:51 <glguy> sorear: how do you mean?
17:53:18 <sorear> glguy: well, no recent patches... big project?  shift of interests?
17:53:58 <sorear> <sarcasm> I love LALR(1).
17:54:07 <glguy> Oh, no big patches, the features that matter are generally there and the only patch I heard of from anyone else related to cosmetic things
17:54:25 <sorear> my Haskell parser will accept data () => Foo = Bar but not data Foo = Bar
17:54:39 <sorear> because Foo is parsed as the beginning of a class context :/
17:55:41 <sorear> glguy: there were other ideas ... like a typecheck-before-pasting checkbox
17:58:47 <ventonegro> any gtk2hs user here to help? :-)
17:58:58 <dcoutts__> ventonegro: one better...
17:59:20 <ventonegro> dcoutts__, ah, you're here, good :-)
17:59:44 <ventonegro> dcoutts__, i'm the one using the custom model with hdbc
17:59:56 <dcoutts__> ventonegro: ah cool
18:00:21 <ventonegro> dcoutts__, the problem is I can't make the treeview refresh
18:00:35 <dcoutts__> ventonegro: you have to notify the view of changes
18:00:43 <ventonegro> i know the treeModelRowChanged, Inserted etc.
18:00:47 <dcoutts__> right
18:00:52 <fantasma> @seen dons
18:00:52 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 26m 44s ago.
18:01:06 <dcoutts__> fantasma: he'll be here in the office soonish
18:01:08 <ventonegro> is there one that invalidates the whole view?
18:01:10 <sorear> hi!
18:01:35 <dcoutts__> ventonegro: no, you have to explicitly notify about all insertaions, deletions, changes etc
18:01:47 <ventonegro> i see
18:01:59 <fantasma> @where xmonad
18:01:59 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
18:02:12 <ventonegro> dcoutts__, when i insert a new element, i don't now where it's gonna be
18:02:26 <ventonegro> dcoutts__, because they are alphabetically sorted
18:02:36 <dcoutts__> ventonegro: you'll have to figure it out, it needs to appear somewhere
18:02:59 <ventonegro> dcoutts__, damn, so it's really as hard as i thought :-)
18:03:00 <dcoutts__> ventonegro: well that's not too hard is it? You just find the location in the sorted sequence
18:03:43 <ventonegro> dcoutts__, i'm not a SQL wiz, but i can't thnk of a query that's gonna give the position of an item
18:03:50 <dcoutts__> ventonegro: so how do you deal with updates? You can't get a 'live' query from the db can you?
18:04:10 <ventonegro> dcoutts__, it's all live from the db
18:04:40 <dcoutts__> ventonegro: so you do requery or something and find if there are new items or something?
18:05:04 <dcoutts__> ventonegro: or you're only updating when you explicitly add things to a table?
18:05:20 <ventonegro> no, when the user presses the save or delete buttons
18:05:43 <fantasma> ?tell dons www.xmonad.org
18:05:43 <lambdabot> Consider it noted.
18:05:47 <dcoutts__> and 'save' might add a new item to a table?
18:05:56 <ventonegro> yep
18:06:50 <ventonegro> the problem is the reverse mapping: given an item, find it's position
18:07:10 <ventonegro> i can't just use the item id
18:07:26 <dcoutts__> ventonegro: right, and ideally without replicating too much data that is kept in the db
18:07:48 <dcoutts__> ventonegro: for example you could keep the query result in a sorted Sequence
18:08:05 <dcoutts__> ventonegro: then do an insert into that and find the index it ends up in
18:08:15 <QtPlatypus> ventonegro: My understanding of SQl is that if the queary is unsorted then the database is free to return the results in any order it sees fit.
18:08:34 <dcoutts__> right, but presumably you're doing a sorted query
18:08:37 <ventonegro> but that defeats the purpose of a custom model, that is manage large amounts of data
18:08:53 <ventonegro> QtPlatypus, the query is sorted
18:08:57 <dcoutts__> ventonegro: right, if the query result is very big
18:09:20 <dcoutts__> ventonegro: though the query result is already kept in your apps memory anyway right?
18:09:42 <dcoutts__> ventonegro: I mean you don't do a query every time the view asks for data do you?
18:09:57 <dcoutts__> you cache the query result and answer request from that right?
18:10:00 <ventonegro> the query is done by the model, row by row
18:10:23 <ventonegro> i just implement the iterator -> row function
18:10:41 <dcoutts__> and what does that do?
18:10:53 <dcoutts__> look it up in a query result or run a new query?
18:10:58 <ventonegro> @paste
18:10:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:11:09 <sorear> ventonegro: I've basically never used SQL, and I know this breaks abstraction, but : SELECT count(key) FROM mytable WHERE key < refkey
18:11:13 <liquidengineer> Hello again
18:11:24 <sorear> that should do the key -> Position, if sorted
18:11:37 <hpaste>  ventonegro pasted "iterator -> row" at http://hpaste.org/975
18:11:55 <ventonegro> dcoutts__, please look at the paste
18:12:41 <hpaste>  ventonegro annotated "iterator -> row" with "(no title)" at http://hpaste.org/975#a1
18:13:08 <ventonegro> sorear,  i see your point...
18:13:49 <ventonegro> sorear, the tricky part is the WHERE clause
18:15:45 <QtPlatypus> Perhaps ventonegro you need to rethink your model?  Accessing via a things via there possision in a query is most likely an indercator that perhaps you should be takeing a diffrent approche.
18:18:00 <goltrpoat> come to think of it, can't ghc-specific newtype deriving instances be generalized to arbitrary data types when there's an "obvious" projection from the type to, say, Num?  eg, data TaggedInt = TaggedInt Int String deriving (Show,Eq,Num)
18:18:01 <ventonegro> QtPlatypus, well, the GTK model expects to give me a number and get an item back
18:18:19 <goltrpoat> by "obvious" i mean unique
18:19:03 <goltrpoat> oh.  actually, the Show and Eq instances already make that ambiguous
18:19:21 <goltrpoat> nevermind.
18:21:04 <hpaste>  BSP annotated "weird errors in monadic instance" with "Solved error" at http://hpaste.org/974#a3
18:22:37 <Batterseapower> right, thats it.. i need to sleep. if i see the word "monad" one more time tonight i'll snap
18:23:59 <dcoutts__> ventonegro: I see
18:27:47 <QtPlatypus> So what I understand is that you do a database query, that spits out something that you display.  They select one of the displayed objects and you get a number indercating where it is on the list from GTK.  You then need to take that number which represents that things possision in the list?
18:28:41 <ventonegro> QtPlatypus, after a use inserts a new item in the database, i must tell the model where my new item is
18:29:05 <ventonegro> QtPlatypus, i guess this is more of a SQL question than a haskell one :-)
18:29:34 <QtPlatypus> ventonegro: Why do you need to do that?
18:29:56 <ventonegro> QtPlatypus, the GTK tree view needs to know to update itself
18:31:18 <liquidengineer> dons: hello?
18:31:35 <sjanssen> fantasma: you registered xmonad.org?
18:32:18 <fantasma> sjanssen, yes
18:32:39 <sjanssen> fantasma++ fantasma++ fantasma++
18:32:40 <QtPlatypus> ventonegro: You know the item that has been updated?
18:33:03 <ventonegro> i've its ID
18:33:14 <QtPlatypus> ventonegro: And its sorted via id?
18:33:24 <fantasma> :)
18:33:33 <ventonegro> QtPlatypus, nope :-)
18:33:40 <QtPlatypus> What is it sorted via?
18:33:40 <ventonegro> http://hpaste.org/975
18:34:11 <sjanssen> fantasma: what sort of hosting does it have?  Is it possible to host the code there?
18:35:01 <fantasma> sjanssen, not sure if you know the host site5, but there's shell access
18:35:14 <fantasma> what are the dependencies for darcs?
18:36:10 <sjanssen> to build it you need ghc and such
18:36:43 * QtPlatypus looks at the code "I realy think your going about this the wrong way.  Doing N SQL quaries to get N rows is ugly."
18:36:45 <sjanssen> fantasma: I think it needs curl and ssh
18:37:27 <sjanssen> fantasma: you might be able to just copy the darcs binary from your system (assuming it's a similar arch and OS)
18:37:44 <fantasma> sjanssen, yeah that is what I'm thinking
18:37:47 <ventonegro> QtPlatypus, i know
18:38:01 <ventonegro> QtPlatypus, if i only could tell GTK that :-)
18:41:35 <sorear> beh.
18:41:48 <sjanssen> beh++
18:41:54 <QtPlatypus> ventonegro: Is there anything forcing you to pass the connection in?  Could you pass instead a list of rows created by a quickQuery before hand?
18:41:55 * sorear defines => as a binary operator on types to get around LALR(1)
18:42:16 <sorear> parsing haskell = fun (in a bad way)
18:42:32 <ventonegro> QtPlatypus, i could pass a list
18:42:46 <dons> bah, just missed liquidengineer
18:42:46 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
18:43:24 <dons> oi! http://www.xmonad.org/
18:43:24 <lambdabot> Title: xmonad : a lightweight X11 window manager.
18:43:30 <dons> sjanssen: what's all this then?? :-)
18:43:40 <QtPlatypus> ventonegro: Also solves your "What has changed" problem, you simply compare the old list to the new list (log n if there both sorted) and that tells you what is new.
18:43:42 <sorear> <sjanssen> fantasma: you registered xmonad.org?
18:43:43 <sorear> <*fantasma> sjanssen, yes                                                 [18:31]
18:43:47 <sjanssen> dons: fantasma has generously made us a website!
18:44:03 <sjanssen> and shapr++ is sending me patches!
18:44:42 <dons> very nice
18:45:00 <ventonegro> QtPlatypus, if i could put all the items in a list, i wouldn't be using a GTK custom model, but a list store
18:47:03 <fantasma> @where darcs
18:47:03 <lambdabot> http://darcs.net/
18:48:10 <QtPlatypus> All I'm sing being returned in your code is the results of "SELECT * ..."
18:48:13 <QtPlatypus> seeing
18:48:43 <ventonegro> QtPlatypus, that function is called by GTK when it needs a new item
18:48:48 <sorear> what gives? yacc is forcing me to inline a rule to give enough context for decisions :(
18:49:35 <fantasma> do RPMs of darcs exist?
18:50:49 <ndm> sorear, yacc is well know for being entirely arbitrary
18:51:07 <ndm> adding actions to nodes can change the properties of things entirely
18:51:16 <ndm> hence why i think my parsing system is better ;)
18:51:39 <sorear> does Helix support output in a reasonably low level (fast) language?
18:52:08 <ndm> sorear, not yet, i'm still at teh algorithms stage, but it will output in everything from Haskell to ASM once its done
18:52:09 <sorear> ie is it a parser generator, or a combinator lib?
18:52:19 <ndm> parser generator
18:52:27 <ndm> and language neutral
18:52:33 <sorear> cool.  I'll be your first user.  Yacc sucks
18:52:50 <sorear> Bison more so, since it has no compatibility docs :(
18:52:51 <ndm> cool, its sadly quite on teh back burner though
18:52:53 <ventonegro> gotta go
18:53:03 <ventonegro> thanks anyway, guys
18:53:16 <ndm> if you use yacc and compile Hugs, it compiles fine, but just recognises the wrong langauge
18:53:25 <ndm> i.e. the Haskell doesn't parse
18:53:43 <ndm> most of it does, but not all - i spent days trying to debug that
18:54:04 <sorear> ndm: I gave in to temptation and tried to build Catch - aside from adding hiding(Prim) to each import of Yhc.Core (new export?) it compiled fine.  failed at runtime though
18:54:21 <sorear> ndm: oh. I'm starting from the hugs .y.  mistake?
18:55:16 <ndm> sorear, are you using yacc? if so it will work and give the wrong answer - i recommend bison (very strongly for that particular file)
18:55:34 <sorear> stefan@stefans:/usr/local/src/catch/src$ ./catch Risers -case 2>&1 | grep -v '^--'
18:55:34 <sorear> catch: Command not found, defunc
18:55:42 <sorear> ndm: no, bison. :(
18:55:54 <ndm> sorear, which copy of catch? catch_1 is the current copy
18:56:15 <ndm> there are at least 6 different code bases in the repo
18:56:16 <sorear> ndm: :( because unlike every other piece of gnu software, catch lacks a "Differences from $UNIX_COUNTERPART" section
18:56:29 <sorear> er, ok, I was using src :)
18:56:35 * sorear tries again
18:56:52 <ndm> catch_1 is nearly useful, make that a binary and do catch Risers (no flags), and it should work
18:56:57 <sorear> btw, how did you get it to build so fast?  I don't think I've ever seen ghc -O0 go that fast...
18:57:15 <ndm> get what to build that fast?
18:57:23 <ndm> the catch program, or the program to analyse?
18:58:50 <ailndx> how do i list packages installed and remove a package?
18:59:02 <ndm> ailndx, ghc-pkg
18:59:16 <ndm> ailndx, and ghc-pkg --help will give you all the other details
19:00:07 <sorear> the catch program
19:00:07 <sorear> yow, 50 less modules in catch_1 than src
19:00:08 <sorear> bam! catch Risers -case finish mind-bendingly fast...
19:00:12 <sorear> now, interpreting the answer gives a type error: _ :: Bool
19:00:14 <sorear> Answer: _
19:00:18 <sorear> oh, wildcard -> no preconditions?
19:00:22 <sorear> s/-case//
19:01:04 <ndm> sorear, yes, _ == no preconditions
19:01:30 <ailndx> unregister = remove?
19:01:33 <ndm> sorear, its now at the stage where something like DigitsOfE2 can be run in hugs, which is how i'm developing it
19:01:37 <ndm> ailndx, yes
19:03:02 <ndm> sorear, the firstify task is a lot slower than it should be though - i think i can do it massively faster, but haven't figured out the details
19:03:27 <araujo> hello
19:03:44 <ndm> sorear, if you do get preconditions, you probably won't understand them - they are in "multi-pattern constraint logic" format, something thats not documented anywhere
19:03:55 <ndm> (to see one with preconditions try something like MapHead)
19:05:58 <sorear> ndm: I take it that's not the form documented in the papers?
19:06:28 <ndm> sorear, the form is rougly documented in the paper in the icfp2007 directory
19:07:05 <ndm> sorear, but its not quite the form in the program - i'll do a separate user document on "interpetting constraints" - i'm also going to do a constraint -> counter example generator
19:08:50 <sorear> ndm: the reason for my recent interest here is that I would describe what catch does as points-to analysis over non flat domains -> AUIU potentially *far* better than what jhc does now ...  I suppose that's -O11's chief mechanism?
19:09:36 <ndm> hmm, not entirely sure, i haven't studied jhc that much
19:09:45 <ndm> and wasn't entirely sure what points-to analysis was?
19:10:05 <ndm> sorear, if you have the paper section 4.4 describes the constraints reasonably well
19:10:21 <ndm> -O11 doesn't really use the catch constraint system
19:10:46 <ndm> it has a different mechanism, using the firstification stuff then adding entropy analysis (something new)
19:16:52 * fantasma just installed ghc on a shared webhost :)
19:23:41 <kc5tja> @seen dons
19:23:41 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 38m 59s ago.
19:24:15 <kc5tja> dons: I just tried out your latest code; on my box, without emitting to the console, it runs in 7 seconds -- just a hair over 4.2 times better.
19:24:31 <kc5tja> dons: (sorry for taking so long -- finally got the OS installation stable)
19:29:36 <glguy> has anyone used Lisp's restartable exceptions?
19:31:31 <ClaudiusMaximus> is there a release tarball of hs-plugins that works with ghc-6.6?  or is darcs the way to go?
19:34:13 <emk> @tell sigfpe A Data.Set monad implementation (kinda hackish): http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
19:34:14 <lambdabot> Consider it noted.
19:34:50 <emk> glguy: Yeah, they're pretty interesting. The final Dylan <restart> design is better, though.
19:35:17 <emk> glguy: They're the sort of thing you rarely need, but when you do need them, they're quite handy.
19:35:35 <emk> (I've worked on a couple of big Dylan and Lisp systems that used restarts extensively.)
19:36:36 <glguy> I watching Peter Seibel (I believe) give a "Google TechTalk" about Lisp
19:36:39 <glguy> and he mentioned it
19:38:48 <mgsloan> glguy - i was recently looking at that
19:38:54 <mgsloan> with relevance to haskell
19:39:16 <mgsloan> I think something could be done on top of IO to produce some haskell error-handling-awesomeness
19:39:28 <glguy> I was trying to imagine implementing that by returning a continuation
19:39:34 <mgsloan> yep, me too
19:40:15 <mgsloan> the problem is, can you just arbitrarily return in the middle of binds?
19:40:29 <mgsloan> i mean, you can start ignoring binds as soon as an error is hit, but..
19:40:34 <mgsloan> well, I guess that's good enough
19:40:57 <glguy> mgsloan: you mean like Maybe does?
19:41:02 <mgsloan> does it?
19:41:02 <glguy> mgsloan: or like Cont does?
19:41:03 <glguy> sure!
19:41:03 <mgsloan> cool
19:41:50 <mgsloan> anyway, I think it could turn out pretty well.
19:42:18 <glguy> I think you could do something like: newtype RestartableT a = ContT (Either RestartType) e
19:42:41 <mgsloan> I actually started coding it at one point, but started messing around with mixing it with the other prelude ;)
19:42:55 <ailndx> dons: could not find Lib.Parser in Eval.hs
19:43:02 <mgsloan> hmm, yeah, I'm not that strong in monadfoo
19:43:10 * glguy sets out to play with it
19:43:24 <mgsloan> the common lisp stuff isn't just restarts
19:43:27 <mgsloan> it's also handlers
19:43:53 <mgsloan> when you throw the error you can also return functions which might be able to do the job better
19:44:03 <mgsloan> eg, lax parser instead of the strict parsing
19:44:59 <mgsloan> perhaps associate strings with functions so that the handler can choose based on name.  Have the first function be 'recommended recovery'
19:45:08 <mgsloan> of course, some of these handlers could just be a retry
19:45:51 <glguy> yeah... I ought to read up on what it does :)
19:46:25 <glguy> @unmtl Cont
19:46:26 <lambdabot> err: No applications
19:46:31 <glguy> oops
19:46:36 <glguy> @unmtl Cont Int Double
19:46:36 <lambdabot> (Double -> Int) -> Int
19:46:55 <glguy> @unmtl ContT Int Maybe Double
19:46:55 <lambdabot> (Double -> Maybe Int) -> Maybe Int
19:47:10 <glguy> @unmtl ContT Int Either Double
19:47:11 <lambdabot> (Double -> Either Int) -> Either Int
19:47:24 <ailndx> dhs/Plugin/Eval.hs:11:7:
19:47:24 <ailndx>     Could not find module `Plugin':
19:47:24 <chessguy> hi haskellites
19:47:34 <glguy> @unmtl ContT Int (Either Float) Double
19:47:34 <lambdabot> err: Unknown MTL(1)
19:47:39 <ailndx> why do i get that error?
19:48:39 <Pseudonym> @unmtl ContT A (ContT B IO) C
19:48:39 <lambdabot> (C -> (A -> IO B) -> IO B) -> (A -> IO B) -> IO B
19:51:17 <fantasma> @seen sjanssen
19:51:18 <lambdabot> sjanssen is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard sjanssen speak 1h 7m 15s ago.
19:54:37 <glguy> emk: so should I look at restarts or whatever it is that Lisp has
19:54:43 <glguy> emk: in your opinion?
19:56:04 <sjanssen> fantasma: pong
19:56:11 <emk> Well, they're a pretty nice approach if that's the sort of thing you need. But see also Dylan's <restart> class, which contains some lessons learned in the intervening decade.
19:56:38 <fantasma> sjanssen, which version of darcs are you using atm
19:56:56 <sjanssen> 1.0.9rc2
19:57:13 <fantasma> nice, will build on xmonad.org now
20:00:32 <chessguy> @pl \lis -> zip ls (tail ls)
20:00:33 <lambdabot> const (zip ls (tail ls))
20:00:39 <chessguy> @pl \ls -> zip ls (tail ls)
20:00:39 <lambdabot> ap zip tail
20:01:17 <chessguy> ?hoogle ap
20:01:18 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
20:01:18 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
20:01:18 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
20:02:08 <pzhang> ?hoogle arrows
20:02:08 <lambdabot> Distribution.Extension.Arrows :: Extension
20:02:43 <chessguy> @pl \(x,y) (w,z) -> (x+w,y+z)
20:02:44 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
20:02:48 <chessguy> woohoo
20:03:13 <fantasma> nice
20:03:54 <fantasma> > (uncurry . fst) 2 4
20:03:55 <lambdabot>   add an instance declaration for (Num (a, b))
20:04:13 <fantasma> > uncurry fst 2 4
20:04:14 <lambdabot>        add an instance declaration for (Num ((b1 -> t -> a, b), b1))
20:04:29 <mauke> @. pl . unpl pl \(x,y) (w,z) -> (x+w,y+z)
20:04:29 <sorear> curry fst is const
20:04:30 <lambdabot> uncurry (flip flip ((snd >>=) . (return .)) . ((>>=) .) . (. (+)) . flip . (((.) . (,)) .) . (. fst) . (+))
20:04:33 <sorear> > curry fst 2 4
20:04:35 <lambdabot>  2
20:04:39 <sorear> > const 2 4
20:04:40 <lambdabot>  2
20:04:56 <fantasma> ah it's curry not uncurry
20:05:12 <fantasma> > uncurry const (1,5)
20:05:13 <lambdabot>  1
20:05:17 <sorear> curry snd is const id, or if you're willing to ignore the effect on strictness, _|_
20:05:26 <sorear> s/_|_/seq/
20:05:41 <sorear> strange typo :/
20:05:47 <fantasma> quite
20:06:36 <fantasma> to make test or to not make test...that is the question
20:06:44 <mauke> /_|_/ is equivalent to /_/
20:07:28 <sorear> mauke: don't alias grep to egrep
20:07:43 <mauke> s/// isn't e?grep
20:07:51 <fantasma> sjanssen, darcs is installed
20:08:09 <sorear> doh! :)
20:10:11 <fantasma> does someone want to test my darcs (or show me how)?
20:10:39 <sjanssen> fantasma: you could start by getting the xmonad repo
20:10:44 <sjanssen> @where xmonad
20:10:44 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
20:10:55 <sjanssen> fantasma: run that ^^^
20:11:02 <fantasma> k :)
20:11:24 <fantasma> this is so awesome
20:11:57 <fantasma> if only I had X...
20:12:07 <jcreigh> lol
20:12:43 <sorear> fantasma: X is overrated
20:13:02 <dibblego> what's another term for "difference list"? (nothing is turning up in google)
20:13:03 <fantasma> I think so too
20:13:09 <jcreigh> "overrated"? Who's going around saying it's good? :)
20:13:17 <fantasma> xmonad should replace X entirely
20:13:25 <sorear> dibblego: fast catenable sequence
20:13:46 <sorear> dibblego: I assume you refer to [a] -> [a] (Data.DList etc)?
20:14:07 <dibblego> sorear, not necessarily, but that as well
20:14:10 <dibblego> sorear, thanks
20:14:57 <araujo> dons, ping
20:18:20 <glen_quagmire> n = 1; n = 2; is that possible?
20:18:21 <jcreigh> hmm, making a Haskell compiler emit good error messages must be really hard, otherwise someone would have done it.
20:18:38 <dibblego> jcreigh, chameleon?
20:18:45 <jcreigh> dibblego: hmm?
20:18:46 * jcreigh googles
20:18:52 <dibblego> glen_quagmire, no, destructive update is not possible in Haskell
20:18:56 <araujo> you have helium
20:19:08 <glen_quagmire> thanks
20:19:09 <bos> not possible outside a monad, anyway.
20:19:14 <dibblego> http://www.comp.nus.edu.sg/~sulzmann/chameleon/download/haskell.html
20:19:23 <lambdabot> Title: A Haskell Programmer's Guide to Chameleon, http://tinyurl.com/weqs4
20:21:27 <chessguy> hey sjanssen, any idea why when i try to install the X11 package that's linked in the dependencies list for xmonad i get this error: Setup.hs: Package X11-1.2 can't be built on this system.
20:22:05 <fantasma> @spell waterfal
20:22:06 <lambdabot> waterfall waterfowl waterfalls waterfall's
20:22:18 <sjanssen> chessguy: hmm, that's a new one for me
20:22:51 <fantasma> @spell unsugared
20:22:51 <lambdabot> unsuccored unsecured insured unshared sugared
20:22:54 <chessguy> not a very informative error
20:23:03 <sjanssen> chessguy: this is when you runghc Setup.hs configure?
20:23:26 <chessguy> runhaskell Setup.hs configure works
20:23:37 <chessguy> runhaskell Setup.hs build produces that error
20:23:48 <sjanssen> what is your system?
20:23:58 <sjanssen> (arch, OS, ghc version)
20:24:08 <chessguy> FC5, 6x86_64
20:24:13 <chessguy> ghc 6.6
20:25:05 <sjanssen> chessguy: and that's the only message you get?
20:25:09 <chessguy> yep
20:25:45 <chessguy> ermm, stupid question...it's not possible for me to not have X11, is it?
20:26:09 <chessguy> i'm using GNOME
20:26:33 <ClaudiusMaximus> chessguy: probably you need some x11-devel package to be able to compile things that need X11
20:26:34 <sjanssen> chessguy: oh, maybe you don't have the X development headers?
20:26:41 <sjanssen> yeah, that's got to be it
20:26:52 <chessguy> is that a haskell thing?
20:27:33 <sjanssen> chessguy: no, it will be a package in your distro.  Probably named "x11-devel", as ClaudiusMaximus suggests
20:27:49 <thedward> @where xmonad
20:27:49 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
20:28:06 <chessguy> ok, i'll look. thanks
20:28:16 <sjanssen> chessguy: xmonad may shock you a bit if you're used to gnome :)
20:28:30 <bos> the code is very cute.
20:28:32 <chessguy> lol
20:28:36 <thedward> does xmonad support opengl compositing? :)
20:28:44 <sjanssen> @slap thedward
20:28:44 * lambdabot slaps thedward
20:28:58 <bos> OpenGLT XMonad
20:29:02 <chessguy> i switched to GNOME from windows :)
20:29:07 <sjanssen> (that is my standard response to frivolous features)
20:29:50 <thedward>  :)
20:32:13 <glguy> http://programming.reddit.com/info/1akhl/comments
20:32:14 <lambdabot> Title: Developing a high performance web server in concurrent Haskell (pdf) (reddit.com ...
20:32:17 <glguy> what a dumb first question
20:32:22 <glguy> (comment)
20:32:33 <thedward> is there a good way to install cabalized stuff on debian without munging up the debian packaged stuff?
20:32:35 <glguy> but interesting article if you are into the topic :)
20:32:47 <sjanssen> it's not an unreasonable question
20:33:20 <glguy> terribly off-topic, and probably unanswerable
20:33:42 <sjanssen> it is pretty fan-boyish
20:34:14 <bd_> thedward: You can install into your $HOME
20:34:16 <glguy> Its no better than if I responded, "Well, not written in Erlang, so there's a plus"
20:34:49 <bd_> thedward: runhaskell Setup.*hs configure --prefix=$HOME/<base directory> --user
20:34:57 <glguy> I'd be more amicable to the comment if the title was "higest performance web server" or something
20:35:17 <hpaste>  sciolizer pasted "stack overflow using Arrows" at http://hpaste.org/976
20:35:18 <thedward> bd_: I've got that far... the problems usually happen when I try to register
20:35:29 <glguy> but it "Developing a high performance webserver .... it about the process of developing one"
20:35:33 <bd_> thedward: are you passing --user to configure?
20:35:36 <glguy> is*
20:36:09 <thedward> bd_: oh. hmm. I think I maybe wasn't adding --user to configure, but only to later stages
20:36:33 <chessguy> sjanssen: aha, getting those libraries did the trick
20:37:37 <bd_> thedward: better to pass it all to configure, it'll make sure they'll be passed in all the right places
20:38:32 <glguy> ?fptools Control.Concurrent.Chan
20:38:32 <lambdabot> http://darcs.haskell.org/packages/base/Control/Concurrent/Chan.hs
20:40:39 <jcreigh> in my .bashrc: alias user-cabal-install='runghc Setup.* configure --user --prefix=$HOME; runghc Setup.* build; runghc Setup.* install'
20:40:53 <jcreigh> Setup.* 'cause I'm too lazy to think of a good way to handle .hs and .lhs
20:41:15 <glguy> how about runghc Setup
20:41:23 <jcreigh> oh...that works?
20:41:41 <jfoutz> so, normally with a non blocking server, there's some sort of function that let's the thread release the cpu... I don't see that in ghc Control.Concurrent... yield doesn't seem to do it, and if i set the thread deleay to anything less that 1 second cpu usage goes way up... where should i look?
20:41:52 <glguy> just like ghc --make Setup does
20:43:04 <bos> jfoutz: what is it you're trying to do?
20:43:20 <jfoutz> understand haskell socket programming
20:43:56 <jfoutz> i have a thread that loops over a list of open handles, checking each one to see if there is any input ready to be read
20:44:11 <sjanssen> jfoutz: "release the cpu"?
20:44:19 <chessguy_> ?where xmonad
20:44:20 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
20:44:26 <bos> ah. well, you don't want to structure your program that way.
20:44:30 <jfoutz> if there is no work to do, i'd like that thread to wait a little bit before continuing the loop
20:44:33 <bos> so there's your first problem :-)
20:45:07 <sjanssen> jfoutz: in Haskell we use multiple threads to read several input sources at once
20:45:20 <jfoutz> yeah, i know.
20:45:25 <bos> haskell doesn't have a native way to poll multiple inputs, so the path of least resistance is to use a thread per connection.
20:45:31 <jfoutz> i was sort of checking out the edge cases...
20:45:33 <bos> however, you can write your own poll wrapper quite easily.
20:45:36 <chessguy_> 102 patches already? :)
20:45:50 <bos> you really, really don't want to loop over your sockets over and over.
20:46:06 <bos> or use network-alt
20:46:09 <bos> @where network-alt
20:46:10 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/network-alt/
20:46:16 <thedward> huh, my ghc6 packages claims to provide libghc6-x11-dev, but doesn't actually seem to
20:47:06 <bos> jfoutz: do you know that haskell threads are pretty tiny? they use about 1k of stack each.
20:47:46 <dons> re.
20:47:52 <jfoutz> yes. i've wrote a threaded version of this first. communication with tchans and whatnot... i'm just trying to sort out this other way.
20:47:53 <ndm> sorear, if you are playing with Catch, please update now - the catch_1 now solves all the results in teh paper (before i used gadget for the back end analysis)
20:48:20 <bos> well, to sort out the other way, you should take a different tack than the one you are. you'd never use it in the real world.
20:49:45 <sjanssen> jfoutz: the other way requires that you use a binding to a function like select
20:50:05 <jfoutz> i think hwaitforinput is what i need.
20:50:10 <jfoutz> but thanks!
20:50:24 <narain_> > last . zip [1..] $ [1..999999]
20:50:26 <lambdabot>  Exception: stack overflow
20:50:34 <narain_> why does this overflow?
20:50:37 <sjanssen> note that you can't use hWaitForInput on multiple handles simultaneously
20:51:06 <sjanssen> narain_: lack of strictness in the enumeration generators
20:51:16 <bd_> You can however use multiple haskell threads and a MVar, MChan, TVar, or TChan to synchronize
20:51:24 <narain_> *lack* of strictness?
20:51:25 <bos> yes, hWaitForInput doesn't solve your problem.
20:51:56 <bd_> oh, someone already mentioned that >.>;
20:52:19 <chessguy_> sjanssen: once i add xmonad to my .xsession file, i just have to reboot?
20:52:29 <glguy> reboot??
20:52:49 <chessguy_> well, re-start x
20:53:09 <chessguy_> which is probably easiest to do by rebooting
20:53:10 <sjanssen> narain_: yes, each number in the list is a thunk that depends on the previous number (which is itself a thunk)
20:53:11 <glguy> .xsession is only read by xdm and friends
20:53:22 <glguy> chessguy_: just press Ctrl Alt Backspace
20:53:34 <narain_> sjanssen: ah. ouch
20:53:38 <allbery_b> or log out
20:53:41 <glguy> he either rebooted or did what I said :)
20:54:50 <narain_> sjanssen: i actually wanted to find the maximum of a function over [1..999999]. the above was a smaller testcase for the stack overflow i was getting
20:54:54 <hpaste>  sciolizer annotated "stack overflow using Arrows" with "refactored to arrow do notation" at http://hpaste.org/976#a1
20:55:02 <narain_> sjanssen: any other way to do it that won't blow my stack?
20:55:13 <sjanssen> narain_: are you compiling with -O?
20:55:20 <narain_> no, i was using ghci
20:55:27 <narain_> hmm, i should try that
20:55:33 <chessguy> i'm not sure what that was supposed to do, but it looked like i restarted gnome
20:55:45 <chessguy> (ctrl-alt-bkspace)
20:55:48 <jcreigh> chessguy: Ctrl+Alt+Backspace kills the X server
20:55:50 <glguy> chessguy: it kills X
20:55:58 <chessguy> ah
20:56:12 <chessguy> so why did GNOME start up and not xmonad
20:56:19 <glguy> because it ignored your .xsession?
20:56:25 <sjanssen> narain_: there also may be a stack overflow in maximum (but this is almost certainly fixed with -O)
20:56:34 <chessguy> why would it do that?
20:56:51 <glguy> some login managers give you a dropdown of window managers to start instead of reading .xsession
20:56:56 <glguy> chessguy: Ubuntu?
20:56:59 <sjanssen> .xsession isn't exactly standard AFAIK
20:57:00 <chessguy> FC
20:57:04 <glguy> ah
20:57:07 <glguy> xdm does .xsession
20:57:11 <glguy> I don't know about any of hte others
20:57:28 <chessguy> oh, lemme see if it gives me a list of window manages
20:58:04 <glguy> silly modern distros separate the user too far from the ground
20:58:23 <chessguy> no, no xmonad option
20:58:53 <sjanssen> chessguy: what happens when you run "startx -- :2"?
20:59:09 <glguy> startx reads .xinitrc
20:59:20 <glguy> generally
20:59:31 <chessguy> sjanssen: from a shell?
20:59:37 <sjanssen> chessguy: yeah
20:59:59 <chessguy> Fatal server error:
20:59:59 <chessguy> Server is already active for display 2
21:00:30 <sjanssen> huh, ubuntu runs multiple X servers by default?
21:00:36 <chessguy> i'm on FC
21:00:39 <allbery_b> take a look in /tmp/.X11-unix
21:01:12 <fantasma> sjanssen, do you use darcs through ssh?
21:01:16 <chessguy> allbery_b: that gives X0 and X2
21:01:23 <sjanssen> fantasma: yes
21:01:31 <glguy> if you did alike a "service stop gdm" or equivalent
21:01:35 <glguy> you'd be at the console
21:01:35 <allbery_b> there you go.  so try screen 1 or 3 instead
21:01:44 <glguy> and could type startx, but you'd have to change your .xinitrc
21:02:08 <chessguy> heh
21:02:22 <allbery_b> you should be able to use lsof to see what has /tmp/.X11-unix/X2 bound; if nothing, then just remove it
21:02:40 <allbery_b> (I often have dead sockts sitting around from temporary VNC sessions)
21:02:41 <chessguy> doing startx -- :3 just about turned my computer inside out, then ultimately came back to this session
21:02:50 <allbery_b> ow
21:03:06 <glguy> Xnest?
21:04:21 * glguy does a sudo tar -zxpf base41.tgz -C /  to update his OpenBSD install to the latest binaries.. crosses fingers :)
21:04:55 <jcreigh> ls: command not found
21:05:00 <jcreigh> :P
21:05:17 <chessguy> oh well, enough messing around for one night, time to get some sleep
21:05:21 <glguy> the only thing that I've really screwed up was forgetting the -p flag
21:05:29 <glguy> so I owned everything
21:05:31 <glguy> instead of root
21:05:35 <glguy> so "sudo" didn't work
21:05:39 <glguy> nor did su
21:05:57 <glguy> but somehow I managed to correct it remotely
21:06:22 <nmessenger> fnauth
21:06:25 <nmessenger> oops
21:06:27 <glguy> this box is 90 miles away , so it isn't convenient to have to drive out
21:06:58 <nmessenger> heh, good thing I hid my auth password behind a macro :D
21:07:11 <glguy> yeah, right
21:07:15 <glguy> we know that your password is fnauth now
21:07:22 <nmessenger> try it :P
21:07:39 <glguy> msg nickserv ghost nmessenger fnauth
21:07:41 <glguy> oh, oops :)
21:09:21 <sciolizer> Has anybody taken a look at my hpaste?
21:11:13 <glguy> are you just looking for a reason to use Arrows?
21:11:30 <sciolizer> I'm just trying to figure them out.
21:11:33 <fantasma> sjanssen, do you and dons (and any other devs) share the same ssh account?
21:11:39 <sciolizer> I don't have any immediate need to use them.
21:12:01 <glguy> I meant in this case, using arrows over Monads was all
21:13:23 <sciolizer> glguy: Well, I'd eventually like to see if I can do dynamic programming using Arrows. (I don't think it's possible with monads.) But right now I just want to know why my program errors out.
21:13:55 <glguy> I don't see where you tell it what fib to calculate
21:14:36 <glguy> i guess you haven't gotten that far before the error hit?
21:14:38 <sciolizer> glguy: I don't. If I wanted it to calculate, I would do main = print $ run fib $ 5
21:16:32 <glguy> not "constA 5 >>> fib"?
21:17:08 <sciolizer> @hoogle constA
21:17:08 <lambdabot> No matches found
21:17:17 <sciolizer> glguy: What is constA?
21:17:20 <nmessenger> I don't really understand the code, but wouldn't fib's count be _|_ since it calls itself recursively?
21:17:22 <glguy> that could be HXT specific...
21:17:26 <glguy> HXT is the only time I use arrows
21:17:41 <sciolizer> glguy: oh, ok
21:17:52 <glguy> I don't understand what the "run" field is for
21:18:12 <sciolizer> glguy: run "unlifts" the Arrow.
21:18:28 <nmessenger> glguy: it's the "unpacker" the way the "runState" unpacks a State monad's underlying function.
21:18:31 <sciolizer> nmessenger: count should return the number of explicit/implicit >>>'s.
21:18:43 <glguy> sure, but then how does that affect the count
21:18:54 <glguy> ah
21:19:00 <glguy> but you don't know that
21:19:06 <glguy> because you haven't done the recursion
21:19:11 <nmessenger> sciolizer: right, and since fib has some (>>>)'s, and is also defined in terms of itself, count should be infinite.
21:19:59 <glguy> sciolizer: constA x is an arrow that ignores its input and returns x
21:20:02 <nmessenger> I'm not sure how to do a "running total of (>>>)'s so far", but it would require an input
21:20:11 <sciolizer> glguy: ok
21:21:18 <sjanssen> fantasma: no, both dons and I have darcs.haskell.org accounts, the permissions are set such that anyone in the "darcs" group can write to the repo
21:21:28 <nmessenger> sciolizer: try "let x = x >>> x in count arr x :: AppCounter", should also blow the stack.
21:21:29 <sciolizer> nmessenger: maybe I just don't understand this yet. My thinking is that since the count field and the run field are independent, then Haskell's lazy evaluation will prevent any function composition (and therefore recursion) from ever happening.
21:21:43 <nmessenger> er, AppCounter () ()
21:22:12 <sjanssen> sciolizer: you can do some dynamic programming with monads
21:22:24 <nmessenger> sciolizer: but you're trying to print an Int, so Haskell has to evaluate that Int, which causes the stack explosion.
21:22:32 <sciolizer> sjanssen: any examples?
21:22:44 <nmessenger> sciolizer: try that example in the REPL
21:23:03 <sciolizer> nmessenger: uh, type error
21:23:17 * nmessenger tries
21:24:12 <sjanssen> sciolizer: I don't have any canned examples.  The idea is to use a state monad that carries around a Map of function results
21:24:41 <sciolizer> sjanssen: ok. I thought of that before (a few months ago), but ran into a wall somewhere. Maybe I just need to visit it again.
21:24:57 <nmessenger> grr, after fixes, it was 1
21:26:00 <sciolizer> nmessenger: Yeah, because x >>> x has 1 ">>>".
21:26:10 <nmessenger> here we go: "let x = x >>> x :: AppCounter () () in count x" blows the stack
21:26:59 <nmessenger> sciolizer: actually, it's because arr starts at 1 and (arr x) has no (>>>)'s, so it doesn't increase.
21:27:01 <sciolizer> nmessenger: You're right. But I still don't understand why.
21:27:29 <nmessenger> > let x = x + x :: Int in x
21:27:31 <sciolizer> nmessenger: oh
21:27:31 <lambdabot>  Exception: <<loop>>
21:27:59 <sciolizer> nmessenger: lol. OK, I feel like an idiot.
21:28:50 <nmessenger> heh, there's a bunch of very abstract things involved.  It's hard to keep it straight.
21:29:00 <nmessenger> Don't beat yourself up.
21:30:00 <sciolizer> nmessenger: Yeah, thanks. If I keep trying to count the >>>'s, what do you think the structure of AppCounter should be?
21:30:19 <sciolizer> nmessenger: ... = AppCounter b -> (c, Int)
21:30:27 <sciolizer> nmessenger: possibly?
21:30:40 <nmessenger> I'm not sure, but I think if you want to count "(>>>)'s so far", count should have type a -> Int
21:30:59 <nmessenger> or what you said probably
21:31:16 <sciolizer> nmessenger: right. count would probably not be a field label.
21:31:39 <LoganCapaldo> existentials are fascinating me
21:31:53 <nmessenger> it might do it somehow, but I wouldn't know where to start.
21:32:23 <sciolizer> nmessenger: ok. Thanks for your help. (and thanks to others here too)
21:33:05 <nmessenger> runAppCounter :: a -> (c, Int) would probably be good, then provide functions run = fst . runAppCounter; and count = snd . runAppCounter
21:33:30 <nmessenger> (er, runAppCounter :: AppCounter a c -> a -> (c, Int))
21:33:30 <sciolizer> nmessenger: yeah
21:33:52 <roconnor> :instances Monad
21:33:59 <roconnor> @instances Monad
21:34:00 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:34:11 <roconnor> where is Either e defined to be a Monad?
21:34:36 <roconnor> @src Either Monad
21:34:36 <lambdabot> Source not found. It can only be attributed to human error.
21:34:42 <roconnor> @src Monad Either
21:34:42 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:34:46 <nmessenger> er, I think it's where the Error class is
21:34:49 <nmessenger> @index Error
21:34:49 <lambdabot> Control.Monad.Error, Graphics.Rendering.OpenGL.GLU.Errors, Graphics.Rendering.OpenGL.GLU, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Graphics.Rendering.OpenGL.GLU.Errors, Graphics.Rendering.OpenGL.
21:34:49 <lambdabot> GLU, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
21:36:10 <roconnor> oh e must be an error in type Either e
21:36:29 <roconnor> @instances Error
21:36:30 <lambdabot> IOError, [Char]
21:36:37 <roconnor> @src ParseError
21:36:38 <lambdabot> Source not found. Take a stress pill and think things over.
21:36:38 <nmessenger> instance (Error e) => Monad (Either e) -- looks that way :D
21:36:59 <roconnor> @src Text.ParserCombinators.Parsec
21:36:59 <lambdabot> Source not found. My mind is going. I can feel it.
21:37:08 <nmessenger> @instances-importing Text.ParserCombinators.Parsec Error
21:37:10 <lambdabot> IOError, [Char]
21:37:18 <sorear> @source  Text.ParserCombinators.Parsec
21:37:18 <lambdabot> http://darcs.haskell.org/packages/parsec/Text/ParserCombinators/Parsec.hs
21:37:21 <sorear> hello.
21:37:27 <roconnor> I want ParseError to be an Error
21:37:48 <sorear> nice try
21:37:58 <sorear> like error handling would be that good
21:38:06 <sorear> @go eric kidd 8 ways
21:38:09 <lambdabot> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
21:38:09 <lambdabot> Title: 8 ways to report errors in Haskell
21:38:25 <roconnor> I'll just make ParseError an instance of Error myself
21:38:44 <narain_> ?src Error
21:38:44 <lambdabot> class Error a where
21:38:44 <lambdabot>     noMsg  :: a
21:38:44 <lambdabot>     strMsg :: String -> a
21:39:20 <nmessenger> not very robust
21:39:37 <roconnor> does noMsg have a default implementation
21:39:40 <roconnor> ?
21:39:43 <nmessenger> @src noMsg
21:39:43 <lambdabot> Source not found. I feel much better now.
21:40:09 <LoganCapaldo> @src String noMsg
21:40:09 <lambdabot> Source not found. That's something I cannot allow to happen.
21:40:19 <nmessenger> @src [Char] noMsg
21:40:19 <lambdabot> Source not found. Where did you learn to type?
21:41:16 <roconnor> oh wait, nevermind
21:41:20 <roconnor> I had it backwards in my head
21:42:00 <philipta> Hey all, is there a good tutorial on haskell data structures?
21:42:28 <dons> on writing your own, or using the standard ones?
21:43:06 <philipta> On writing my own. I think I grok functions now, but representing data... I'm finding not so much.
21:43:43 <dons> YAHT covers the basics of defining data structures
21:43:45 <dons> ?where YAHT
21:43:45 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:44:12 <dons> for writing entire data structure libraries, i'd look at Okasaki's book, "Purely functional data structures"
21:44:28 <dons> but for just learning how to write your own basic data types, yaht should be enough
21:44:39 <philipta> Yeah, I'm looking through http://en.wikibooks.org/wiki/Haskell/Type_declarations and http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics.
21:45:17 <dons> data T = T Int Bool String
21:45:24 <dons> is a basic 'struct' declaration, of type T
21:45:29 <dons> with 3 fields
21:45:44 <dons> data T = T { a :: Int, b :: Bool, c :: String }
21:45:44 <philipta> OK.
21:45:48 <dons> is the same, with labelled fields
21:45:57 <philipta> Oh!
21:45:58 <dons> now, haskell data types can be more complex than this
21:45:59 <philipta> OK.
21:46:08 <dons> for example, the type of binary trees:
21:46:20 <dons> data Tree a = Nil | Node a (Tree a) (Tree a)
21:46:36 <philipta> That a is an unbound type and can be anything, I take it.
21:46:38 <dons> so a tree is *either* the empty tree, or a Node containing some element of type 'a', and two sub trees
21:46:42 <dons> yep.
21:46:51 <dons> so, you could have:  Tree Int or Tree String
21:47:00 <nmessenger> like [Int] or [String]
21:47:06 <ddarius> philipta: Are you familiar with BNF?
21:47:12 <philipta> Yeah
21:47:15 <Cale> It's important to realise that what's on the left of the = sign is the name of a type, and what's on the right are a bunch of constructors for values, each followed by a bunch of types.
21:47:30 <philipta> What's "Tree" then? That looks like a type.
21:47:35 <philipta> on the right side
21:47:52 <nmessenger> yes, it's a type
21:47:53 <dons> yes, that's the type of the two subtree fields
21:47:55 <Cale> well, yeah, it's the type of the parameter to Node
21:48:07 <ddarius> philipta: Haskell data type declarations are similar in syntax and vaguely similar in meaning to BNF productions.
21:48:24 <nmessenger> data Type = Value Type Type | Value | Value Type (Type Type) -- etc.
21:48:43 <Cale> er, probably wanted a , there
21:49:06 <Cale> er, oh, you were just labelling what goes where
21:49:11 <nmessenger> yeah
21:49:27 <sorear> ddarius: hm.  I am suddenly reminded that Miranda's are even more similar - tree a ::= nil | tree a (tree a) (tree a)...
21:49:41 <ddarius> sorear: yep
21:50:18 <nmessenger> ooh!  '... ::= ...' would be great for 'data ... = ...' !
21:50:20 <philipta> Let me try out this knowledge. My goal for myself is to represent a Carcassone board game tile accurately with no illegal tiles.
21:50:25 <sebell> Does anyone have any suggestions for using Parsec in lieu of a regular expression, IE given some parser return the match from a body of text, ignoring all non-matching leading text?
21:50:37 <dons> philipta: ok. so something like a type for valid tiles?
21:50:39 <dons> and a type for the board?
21:50:44 <philipta> Right.
21:51:08 <dons> data Tile = A | B | C | D | ...
21:51:19 <dons> type Board = [[Tile]] -- dead simple
21:51:20 <nmessenger> @google carcassone
21:51:23 <lambdabot> http://www.carcassonne.org/
21:51:23 <lambdabot> Title: Site officiel de Carcassonne - Office de tourisme et ville - Official website of ...
21:51:50 <philipta> @google Carcassonne
21:51:51 <lambdabot> http://www.carcassonne.org/
21:51:51 <lambdabot> Title: Site officiel de Carcassonne - Office de tourisme et ville - Official website of ...
21:52:03 <philipta> @google Carcassonne (board game)
21:52:03 <sorear> Was that a deliberate influence?
21:52:03 * sorear picked up miranda syntax from IFPL, which was based on a deliberately restricted pre-release version.  The book was published three years before sorear was born.  Just so you know.
21:52:05 <lambdabot> http://en.wikipedia.org/wiki/Carcassonne_(board_game)
21:52:05 <lambdabot> Title: Carcassonne (board game) - Wikipedia, the free encyclopedia
21:52:08 <sorear> And yes, I realize a should be *
21:52:10 <Cale> http://russcon.org/RussCon/carcassonne/tiles.html
21:52:12 <lambdabot> Title: Carcassonne Tile Distribution
21:52:38 <sorear> philipta: ah, so you want the typesystem to catch mismatched tiles?
21:52:55 <Cale> oh, that would be hard :)
21:53:05 <philipta> Yes, and flow immediately to laying the tiles together :)
21:53:22 <Cale> Remember that type checking is done at compile time
21:53:33 <philipta> I did the A | B | C | D | ..> method already
21:53:35 <sorear> philipta: what you want can be done pretty easily with GADTs.  I don't know about H98 however.
21:53:55 <philipta> But it wasn't easy to lay tiles together
21:54:04 <Cale> so if you were to somehow represent the ways that tiles fit together in the type system and not allow them to be joined in the wrong way, the compiler would have to prove that any code you wrote would produce a valid board
21:54:07 <ddarius> sorear: Yes
21:54:15 <philipta> What are GADTs? General Abstract Data Structures?
21:54:24 <Cale> while this would be cool, I suspect it's pretty tough.
21:54:28 <mbishop> ?gadt
21:54:29 <lambdabot> Maybe you meant: fact part
21:54:30 <sorear> philipta: what is laying? I've played the game, if that helps with refs
21:54:33 <Cale> sorear: It can?
21:54:41 <sorear> philipta: Generalized algebraic data types
21:54:46 <Cale> How would you do that with GADTs?
21:54:56 <philipta> Tiles go together in any way that makes sense. You can rotate tiles. There is a starting tile.
21:55:05 <sorear> ddarius: I'm sorry, lag has obscured what you are responding to
21:55:06 <Cale> Somehow I'm unconvinced that this is going to be easy :)
21:55:30 <sorear> philipta: so "lay" means to put a tile down somewhere?
21:55:31 <Cale> It's probably easier to check that tile placements are correct at runtime.
21:55:46 <philipta> Tiles are places adjecent to other tiles only.
21:55:50 <philipta> placed*
21:56:19 <sorear> philipta: sides of a tile can be road, castle, water - I'm forgetting any?
21:56:28 <Cale> I forget whether roads can just end or not.
21:56:30 <philipta> Road, City, Field
21:56:46 <Cale> (I don't think they can)
21:56:51 <jcreigh> sometimes it seems like people are trying to stretch the type system so far that compiletime is the new runtime.
21:56:59 <Cale> jcreigh: yeah
21:57:22 <Cale> Usually, these are people used to dynamically typed languages, I think.
21:57:46 <sorear> Cale: it is very easy to enforce in 1D.  2D now seems *much* harder, esp. the contiguity constraint.
21:58:13 <Cale> Okay, right, tiles have either road, city, or field on each edge, and two adjacent tiles have to have matching edge types.
21:58:36 <sorear> Cale: I seem to recall there was some sort of water?
21:58:45 <Cale> maybe in some variants
21:58:57 <Cale> I've only played plain Carcassonne, and only once :)
21:59:21 <philipta> Well, this is an interesting data structure in any language. I haven't implemented it to my satisfaction yet. Given Haskell's types, I just want to write a data structure for the tile that I can do meanful functional ops on
21:59:32 <philipta> Yeah, there's a river expansion
21:59:32 <Cale> oh, and if a tile has city in it, then it may also have a shield.
21:59:53 <Cale> er, city on at least 2 sides.
22:00:26 <philipta> I want to not have "impossible" tiles that have a road and a city on the same edge.
22:00:36 <sorear> philipta: I think you want lightweight static capabilities - the name is harder than the concept - create a module with a datatype and a couple smart constructors that check the conditions, and only exports the smart constructors
22:00:50 <Cale> Well, the natural way to specify them would be something like:
22:00:53 <philipta> hmmm... I think I understand.
22:00:59 <sorear> of course, that will cause runtime issues, if the smart constructors have too general of types
22:01:23 <philipta> Write a data structure that is general and perhaps allows for :"bad" tiles but has a constructor that only makes good ones?
22:01:29 <Cale> data Tile = Tile { shield :: Bool, north :: Edge, east :: Edge, south :: Edge, west :: Edge}
22:01:41 <Cale> data Edge = Field | Road | City
22:02:04 <philipta> Can have a Cloister in the middle of a tile
22:02:13 <Cale> oh, right
22:02:33 <sorear> I thought cloisters were ordinary tiles with some number of roads?
22:02:54 <Cale> oh, actually, this is more complicated
22:03:10 <Cale> You can have city on two adjaent sides, where the cities don't join.
22:03:21 <Cale> adjacent
22:03:32 <Cale> http://russcon.org/RussCon/carcassonne/city11ne.png
22:03:42 <Cale> versus
22:03:43 <Cale> http://russcon.org/RussCon/carcassonne/city2nw.png
22:04:01 <philipta> Yep. There are internal properties of the tile, like that.
22:04:14 <hpaste>  sorear pasted "1d case, with GADTs" at http://hpaste.org/977
22:04:14 <Cale> and on opposite sides with or without joining
22:04:20 <philipta> I thought of making it in layers--a
22:04:27 <roconnor> how do I exit with an error code?
22:04:35 <Cale> sorear: heh, cute
22:04:42 <nmessenger> @index exitWith
22:04:42 <lambdabot> System.Exit
22:04:43 <sorear> roconnor: System.exit.exitWith . System.Exit.ExitFailure
22:04:47 <sorear> @ty System.exit.exitWith . System.Exit.ExitFailure
22:04:50 <lambdabot> Not in scope: `System.exit'
22:04:50 <lambdabot>  
22:04:50 <lambdabot> <interactive>:1:12: Not in scope: `exitWith'
22:04:54 <sorear> @ty System.Exit.exitWith . System.Exit.ExitFailure
22:04:57 <lambdabot> forall a. Int -> IO a
22:05:06 <philipta> sorear: reading
22:05:33 <sorear> philipta: Unfortunately, that doesn't generalize easily to the 2d case
22:06:47 <philipta> That's interesting. You didn't define the tile--you defined the relationship that a tile has with its neighbours
22:07:00 <Cale> It's quite likely that over-representing your tiles and then writing functions to construct valid tiles would be a good idea.
22:07:03 <sorear> philipta: I'm sure it can ... but Haskell becomes very nasty when you try to use it as a proof system.  Took me half an hour to "prove" + :: Integer -> Integer -> Integer was associative...
22:07:38 <sorear> night all...
22:07:41 <Cale> also, writing programs with such types would be annoying :)
22:08:01 <philipta> night sorear, and thanks for the ideas. :)
22:08:20 <roconnor> how do I print the error code from the last program in bash?
22:08:24 <roconnor> echo $??
22:08:25 <sorear> echo $?
22:08:25 <jcreigh> echo $?
22:08:26 <philipta> Cale: OK--I'll try going down that road
22:08:26 <Cale> because you'd have to somehow encode into the type of the functions that act on tiles a proof that they would join them correctly -- doing this sort of thing at compile time is a bit nuts :)
22:08:30 <roconnor> ah
22:08:32 <sorear> @quote stereo
22:08:32 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
22:08:47 <roconnor> cool
22:09:35 <philipta> Cale: Why shouldn't I want that? ;)
22:09:35 * roconnor tries to learn how to make a cron job
22:09:48 <Pseudonym> crontab -e
22:10:32 <Cale> philipta: well, you might not want to actually produce that proof yourself :) Haskell's type system isn't really well-built for proving very sophisticated things.
22:11:09 <bos> such stuff requires a high oleg equivalence.
22:11:33 <Cale> (More sophisticated than most languages, but it's not like Coq or anything)
22:11:42 <philipta> bos: Dare I ask what oleg equivalence is?
22:12:03 <mauke> @quote oleg
22:12:03 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
22:12:06 <Cale> oleg is a guy on the Haskell mailing lists who produces articles with insane type hackery in them
22:12:29 <nmessenger> @quote oleg.+unit
22:12:29 <lambdabot> No quotes match. I feel much better now.
22:12:42 <bos> he makes the type system do arithmetic for fun.
22:12:54 <philipta> Damn, I'd love to see that.
22:12:59 <mgsloan> recently he did binary arithmetic in the type system
22:13:02 <bos> no, it makes your eyes melt.
22:13:10 <Cale> An "oleg" has come to be the base unit for type hackery, it's a fairly large unit.
22:13:15 <mgsloan> binary naturals
22:13:19 <bos> "fairly"? :-)
22:13:37 <Cale> Milliolegs are more convenient.
22:13:45 <mgsloan> they're actually kinda useful, for a simulation of dependent types
22:13:53 <mauke> @quote milli
22:13:54 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
22:14:00 <philipta> Hey, JAPHs are a great way to test your understanding of Perl--I'm sure the same is true for type hacks. :)
22:14:30 <bos> a lot of people get by just fine without the crazier type stuff.
22:14:31 <mgsloan> that'd be 10 centi-Olegs
22:14:32 <nmessenger> @vera japh
22:14:34 <lambdabot> *** "japh" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
22:14:34 <lambdabot> JAPH
22:14:34 <lambdabot>      Just Another PERL Hacker (PERL)
22:14:34 <lambdabot>  
22:14:39 <nmessenger> oh yeah :)
22:15:16 <jcreigh> no, 1 deci-Olged
22:15:24 <jcreigh> *oleg
22:15:38 <glguy> What's a common reason for latex to ignore \title and \author?
22:15:51 <glguy> no \maketitle?
22:15:59 <mgsloan> that'd be likely
22:16:00 <jcreigh> (poor little deci...an oft-ignored SI prefix...)
22:16:02 <bos> glguy: yep
22:16:22 <bos> it's not ignoring them; you're just never telling it to print them.
22:16:26 <mgsloan> yeah, i was gonna say deci, but was afraid I might have mixed it with deca
22:16:33 <dufflebunk> jcreigh: now for the bonus question, is the symbol for deci 'd' or 'D'?
22:16:41 <mgsloan> d
22:17:13 <bos> if qty < 1 then lower else upper
22:17:31 <dufflebunk> k > 1
22:17:43 <jcreigh> D is probably deka, right?
22:17:46 <mgsloan> glguy - already starting a paper about the error stuff, eh ;P
22:17:47 <dolio> You mean K?
22:17:48 <mgsloan> eah
22:18:06 <dufflebunk> dolio: No, lower case k is kilo
22:18:07 <narain_> K is computer-speak
22:18:07 <glguy> mgsloan: heh
22:18:11 <nmessenger> deca is da iirc
22:18:16 * glguy wonders if there is a \subtitle-like command
22:18:30 <dolio> I suppose it is km.
22:18:49 <nmessenger> True Hackers measure time in microfornights :D
22:18:57 <nmessenger> fort*
22:19:04 <narain_> @go 1 microfortnight in seconds
22:19:05 <lambdabot> http://en.wikipedia.org/wiki/1_E0_s
22:19:06 <lambdabot> Title: 1 E0 s - Wikipedia, the free encyclopedia
22:19:11 <narain_> hmpf
22:19:28 <philipta> Is there a way to create a sub type like "all the character except for 'Z'"?
22:19:34 <bos> no.
22:19:37 <narain_> @go 0.000001 fortnights in seconds
22:19:38 <lambdabot> 0.000001 fortnights = 1.2096 seconds
22:19:44 <narain_> google++
22:19:53 <philipta> ok.
22:20:07 <bos> unless you're oleg :-)
22:20:16 <jcreigh> yay!
22:20:23 <philipta> dangit, that qualifies as a tease!
22:20:32 * jcreigh has hacked very-alpha quality Xinerama support into xmonad
22:21:16 <sjanssen> jcreigh: oh yeah?  Can you host your work anywhere?
22:21:26 <sjanssen> how many LOC did it take?
22:22:22 <narain_> ?hoogle a
22:22:23 <lambdabot> Data.Graph.Inductive.Example.a :: Gr Char ()
22:22:23 <lambdabot> Array.accum :: Ix a => (b -> c -> b) -> Array a b -> [(a, c)] -> Array a b
22:22:23 <lambdabot> Array.accumArray :: Ix a => (b -> c -> b) -> b -> (a, a) -> [(a, c)] -> Array a b
22:22:28 <narain_> ?hoogle array
22:22:28 <jcreigh> I don't have anywhere to host it...in any case, it needs more work before other people can look at. ie, it's ugly, and I don't want other people to see it yet. :)
22:22:28 <lambdabot> Array.array :: Ix a => (a, a) -> [(a, b)] -> Array a b
22:22:28 <lambdabot> Data.Array.array :: Ix i => (i, i) -> [(i, e)] -> Array i e
22:22:28 <lambdabot> Data.Array.IArray.array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
22:22:53 <jcreigh> I hope to have it more polished on saturday.
22:23:22 <sjanssen> is it an intrusive change?
22:23:28 <sebell> jcreigh: But typically others can `de-uglify' your code quicker than you can
22:24:20 <jcreigh> not terribly...added a xineScreens :: [XineramaScreenInfo] and visibleWS :: M.Map Int Int to XState
22:24:30 <jcreigh> changed a few functions in Main.hs
22:25:30 <jcreigh> and we need to add my Xinerama bindings to X11-extras or something to make it work.
22:26:07 <sjanssen> and visibleWS is a map from screen number to workspace number?
22:26:16 <jcreigh> sjanssen: yup
22:26:55 <jcreigh> I don't know if that's the best way to do it...I was just throwing code togethering, think, "what's the least it would take to get this working?"
22:27:29 <jcreigh> s/ing, think/thinking/
22:27:47 <philipta> @google togethering
22:27:50 <lambdabot> http://www.wordspy.com/words/togethering.asp
22:27:51 <lambdabot> Title: Word Spy - togethering
22:28:33 <nmessenger> what a quaint word
22:29:24 <jcreigh> anyway...it's bedtime.
22:30:40 <jcreigh> sjanssen: I'll finish making it work (not everything works now) tomorrow night or saturday, then kick it out somewhere for you to take a look.
22:36:13 <sjanssen> jcreigh: okay, feel free to darcs send if that's easiest (and make it obvious the patch bundle is xinerama related)
22:36:46 <hpaste>  nyadadyel pasted "Binary Tree Monad" at http://hpaste.org/978
22:37:06 <nyadadyel> hello, i've been learning haskell and i wrote a binary tree monad recently, can somebody take a look at it and tell me if i got it right?
22:38:37 <Lemmih> nyadadyel: Sure.
22:38:58 <sjanssen> hpaste.org isn't loading for me
22:39:06 <nyadadyel> Lemmih: thank you, it's at http://hpaste.org/978
22:39:21 * mgsloan senses a misunderstanding of what a monad is
22:39:33 * mgsloan checks code before jumping to conclusions
22:39:48 * mgsloan retracts previous statement
22:40:08 <ddarius> nyadadyel: free monad http://lambda-the-ultimate.org/node/1183#comment-12838
22:40:09 <nyadadyel> mgsloan: sorry if i described it incorrectly
22:40:09 <lambdabot> Title: The Haskell Programmer&#039;s Guide to the IO Monad --- Don&#039;t Panic | Lambd ...
22:40:12 <sjanssen> actually, looks like I'm not resolving anything at the moment
22:40:14 <Lemmih> nyadadyel: Looks fine.
22:40:52 <mgsloan> nyadadyel: I just didn't see how it would be possible to do a binary tree monad, i guess it makes sense, if list is a monad...
22:40:56 <ddarius> But, yeah, you're good.
22:41:12 <nyadadyel> mgsloan: i did it as an exercise following a suggestion in the "monads as containers" tutorial
22:41:29 <nmessenger> the name "join" is potentially confusing, since the existing "join" function is different from bind.
22:41:30 * mgsloan has a feeling that in 10 years everything will be monadic - regular function application, everything
22:41:42 <mgsloan> in some language or another, not necessarily haskell :)
22:41:59 <ddarius> mgsloan: That's the case today and for the 60 years.
22:42:00 <nyadadyel> nmessenger: ok, i'll change that next time, thanks
22:42:14 <nyadadyel> thanks mgsloan, ddarius, Lemmih, and nmessenger
22:42:23 <ddarius> mgsloan: ^past
22:42:43 <mgsloan> especially in the case of a container join means something specific in the monad world
22:43:04 <mgsloan> ddarius: true, but it will actually have a monad instance :)
22:43:25 <nyadadyel> mgsloan: it means something different from what it does in my code?
22:44:03 <bos> @type join
22:44:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:44:07 <mgsloan> yeah. join means BinTree (BinTree x) -> Bintree x
22:44:16 <nmessenger> join = (>>= id)
22:44:22 <bos> join removes a layer of wrapping.
22:44:23 <mgsloan> that too
22:44:30 <nyadadyel> but isn't that what mine does?
22:44:35 <bos> no.
22:44:37 <nmessenger> your join = (>>=)
22:44:44 <narain_> nyadadyel: if you remove f from your code
22:44:47 <narain_> that'll be join
22:44:58 <nyadadyel> narain_: ahh, i see
22:45:25 * mgsloan checks if the monad class lets you define join instead
22:45:33 <nmessenger> mgsloan: nope
22:45:38 <mgsloan> argh!
22:45:46 <nmessenger> TheOtherPrelude's Monad does, though :)
22:45:51 <mgsloan> can't believe they'd do that. yeah
22:45:58 <nyadadyel> one last question, should i remove "f" from being passed around in the join calls, since it's already bound?
22:46:24 <nyadadyel> i wasn't sure if i should keep it in, for clarity or something, or not
22:46:55 <narain_> mgsloan: yeah, they should allow fmap and join to derive >>=, but the Prelude doesn't know that all Monads are Functors, right?
22:46:56 <nmessenger> oh, you mean make the local name close over f instead of passing it recursively?  Should be fine.
22:47:23 <mgsloan> narain_ - good point
22:47:26 <nyadadyel> nmessenger: yes, is it better to pass it to join, or just reference it?
22:47:35 <mgsloan> all monads are functors though :)
22:48:00 <narain_> that's what TheOtherPrelude knows and the Prelude doesn't :)
22:48:20 <mgsloan> so, when will the normal prelude be replaced?
22:48:36 <hpaste>  nmessenger annotated "Binary Tree Monad" with "no need for the local name" at http://hpaste.org/978#a1
22:49:19 <nyadadyel> nmessenger: thanks for your annotation
22:49:38 <narain_> mgsloan: i dunno, haskell-prime maybe? if ever?
22:49:57 <nmessenger> Haskell Two
22:49:59 <narain_> other people would know better than me
22:50:11 <nmessenger> @oldwiki HaskellTwo
22:50:11 <lambdabot> http://www.haskell.org/hawiki/HaskellTwo
22:50:20 <nyadadyel> alright, thanks to everybody, i'm off to go read up some more ;)
22:50:44 <mgsloan> narain_: we can only hope
22:50:56 <mgsloan> yeah, Haskell Two maybe
22:51:12 <narain_> nmessenger: what's the difference with Haskell'?
22:51:29 * mgsloan doesn't think Haskell' breaks anything
22:51:37 <narain_> oh.
22:51:43 <mgsloan> plus Haskell' is just standardizing what some compilers already have
22:51:48 <mgsloan> like ghcs extensions
22:51:50 <narain_> "conservative refinement of Haskell 98". right
22:52:01 <narain_> ok then
22:52:47 <dolio> Also, keep in mind "last edited 2005-10-09"
22:53:00 <dolio> And that page is on the old wiki.
22:53:00 <mgsloan> hehe, yeah, a lot of those are already in haskell
22:53:35 <ddarius> mgsloan: "Haskell' is just standardizing what some compilers already have" haha
22:53:42 <narain_> "Edison" is a data structure?
22:53:56 <ddarius> Data structure library from back in the day
22:53:57 <dons> a data structure library
22:54:06 <dolio> It's a library of data structures based on the Purely Functional Data Structures book.
22:54:07 <dons> based on Okasaki's book/phd
22:54:24 <dolio> Recently brought back from the dead by someone else.
22:54:29 <narain_> sounds impressive
22:54:56 <dons> ?where Edison
22:54:57 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
22:59:59 <hpaste>  nmessenger annotated "Binary Tree Monad" with "BinTree join" at http://hpaste.org/978#a2
23:00:22 <nmessenger> nyad left, but could anyone tell me if my annotation seems correct?
23:01:03 <ddarius> It is
23:03:10 <nornagon> i seem to recall seeing a haskell network programming tutorial somewhere
23:03:49 <philipta> Is there a way to say "all values of this type"?
23:04:15 <nornagon> @where network
23:04:15 <lambdabot> I know nothing about network.
23:04:21 <ddarius> Not in general, really.  In theory, yes modulo abstraction.
23:04:24 <glguy> is there a symbol for something like "is contained in" when refering to a vertex and a region?
23:04:40 <glguy> just \in ?
23:05:29 <nmessenger> philipta: if it's in Bounded, then [minBound..maxBound] should get you the whole range.
23:05:50 <philipta> Where can I learn about Bounded types?>
23:06:01 <dolio> ?type \a b -> [a .. b]
23:06:03 <lambdabot> forall t. (Enum t) => t -> t -> [t]
23:06:14 <nmessenger> @type enumFromTo
23:06:16 <lambdabot> forall a. (Enum a) => a -> a -> [a]
23:06:45 <philipta> So I add Enum to the list of deriving types to get use of this function?
23:06:46 <nmessenger> philipta: hmm, not sure.  Bounded is a pretty simple class, it has two members: minBound and maxBound.
23:07:00 <nmessenger> @src Bounded
23:07:01 <lambdabot> class  Bounded a  where
23:07:01 <lambdabot>     minBound, maxBound :: a
23:07:10 <philipta> (I'm still on a pretty basic level here :))
23:07:13 <nmessenger> er, yeah, I guess you'd need Enum, too :)
23:08:27 <nmessenger> instance Bounded Char where minBound = '\0'; maxBound = '\1114111' -- for example
23:08:43 <philipta> ahhhhhh
23:09:49 <nmessenger> > [minBound, maxBound] :: [Char] -- doublechecking :)
23:09:50 <lambdabot>  "\NUL\1114111"
23:12:23 <philipta> Reading prelude on Bounded and Enum...
23:12:47 <robreim> What is each Int return value in Data.ByteString.Base.createAndTrim'?
23:13:09 <dcoutts__> robreim: the actual size
23:13:16 <dcoutts__> so that it trims it to that size
23:13:31 <robreim> Is that the first or second Int? What's the other one?
23:14:07 <robreim> (createAndTrim' rather than createAndTrim btw)
23:25:59 <robreim> dcoutts__: ping? ^^
23:28:17 <dons> he's busy hacking
23:28:23 <dons> createAndTrim' eh?
23:28:44 <dons> first arg is length, second arg is function?
23:29:06 <dons> createAndTrim :: Int -> (Ptr Word8 -> IO Int) -> IO ByteString
23:29:08 <dcoutts__> robreim: the extra int is the offset
23:29:10 <dons> createAndTrim' :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (ByteString, a)
23:29:16 <dcoutts__> the 'a' is the return value
23:29:38 <robreim> Oh cool, thanks :)
23:29:48 <robreim> So I should generally set that second Int to a 0, eh?
23:30:42 <robreim> Oh, one other thing, what might I use as an equivalent to useAsCString for Word8 bytestrings?
23:31:11 <sjanssen> robreim: use the same function, they're the same type
23:31:45 <robreim> ok, I'll try that. Thanks all! dcoutts__++ dons++ sjanssen++
23:34:24 <nornagon> @hoogle split
23:34:25 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
23:34:25 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
23:34:25 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
23:34:30 <nornagon> @hoogle+
23:34:31 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
23:34:31 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
23:34:31 <lambdabot> GHC.Exts.split :: Splittable t => t -> (t, t)
23:35:12 <nornagon> is there a stdlib function from ':' and "foo: bar" to ["foo", " bar"]?
23:35:35 <ddarius> hmm, this paper sounds more interesting than I thought it was
23:38:23 <sebell> Does anyone have suggestions for using a Parsec parser in place of a regular expression? IE, to extract a match from a given body of text, ignoring leading un-matched text? That is -- without using `tails' ;)
23:41:53 <dons> sebell: you could use the parsec-based regex lib that is on hackage
23:41:53 <dons> regex-parsec, iirc
23:42:15 <Korollary> You should be able to get it to work with anyChar or something that accepts the rest, but it would have to read it.
23:42:41 <sebell> dons: But I want to use a Parsec parser, not a regex string
23:43:29 <araujo> dons, hello!
23:43:30 <sebell> Korollary: Right. There is a manyTill parser, but it returns the stuff to skip, not the `Till' part :)
23:44:03 <nornagon> :t fmap
23:44:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:44:22 <nornagon> so, liftM for functors?
23:45:34 <nmessenger> rather liftM is fmap for Monads :D
23:45:38 <nornagon> :)
23:46:14 <nmessenger> since Functor *is* fmap, there's nothing else.
23:47:35 <ptaron> I'm trying to figure out how to write [a -> b] -> [a] -> [b]
23:47:42 <nmessenger> @type ap
23:47:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:47:57 <nmessenger> @type zipWith ($)
23:47:59 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
23:48:08 <ptaron> awesome!
23:48:10 <ski> > [(^2),(^3)] `ap` [4,5]
23:48:11 <lambdabot>  [16,25,64,125]
23:48:31 <ski> > zipWith ($) [(^2),(^3)] [4,5]
23:48:32 <lambdabot>  [16,125]
23:48:32 <nmessenger> zipWith ($) is apply-corresponding elements, liftM ($) is apply-all-functions-to-all-args
23:48:44 <ski> > liftM ($) [(^2),(^3)] [4,5]
23:48:45 <lambdabot>  Couldn't match expected type `[t1] -> t'
23:48:48 <ptaron> How did you know to use ($)?!
23:48:51 <nmessenger> liftM ($) = ap
23:48:52 <ski> > liftM2 ($) [(^2),(^3)] [4,5]
23:48:54 <lambdabot>  [16,25,64,125]
23:49:01 <nmessenger> ($) is function application
23:49:02 <ski> ap = liftM2 ($)
23:49:16 <nmessenger> @src ($)
23:49:16 <lambdabot> f $ x = f x
23:49:17 <sebell> So my next approach would be to try and match my parser, and if it succeeds return the matched text, and if it fails use anyChar >> myRegexSimulatingParser. Sound sane enough? I think it should be called `skipTill'
23:50:23 <ski> ('zipWith ($)' is 'ap' in another monad)
23:50:50 <nmessenger> actaully, it's (<*>) (another name for ap) in the ZipList Applicative Functor
23:50:55 <nmessenger> ZipList isn't a Monad
23:51:06 <ski> yes it is
23:51:16 <ski> return = repeat
23:51:25 <ski> join = ..take the diagonal..
23:51:46 <nmessenger> Cale told me it wasn't, I wasn't sure.
23:52:02 <ski> at least i'm sure of it, for infinite lists
23:52:13 <ski> (i'm almost sure of it for finite lists)
23:52:52 <ski> let's check it ! :)
23:53:11 <nmessenger>  @check?
23:53:25 <ski> hehe, i meant 'prove' by 'check' :)
23:53:48 <nmessenger> not sure how, I've only enough knowledge to be dangerous :D
23:54:11 <ski> we need to define 'join' first, for finite lists
23:54:18 <ski> for infinite lists it is
23:54:37 <ski> join ((a:_):ass) = a : join (map tail ass)
23:54:42 * nmessenger remembers a DiagList somewhere, I think in the bowels of hpaste
23:54:57 <nmessenger> heh, ass :D
23:54:58 <nornagon> *MPC> withMPD (liftIO . print =<< currentsong)
23:54:58 <nornagon> [("file","mod/a-polar.it"),("Time","0"),("Title","\"Polar Wind\""),("Pos","8"),("Id","571")]
23:55:01 <nornagon> :)
23:56:00 <nmessenger> :O  (Name, Value) pairs instead of a record?!  For shame!
23:56:21 <nmessenger> and strings too!
23:56:34 <ski> http://hpaste.org/680
23:57:05 <ski> hm
23:57:10 <ski> no, that's not it, i think
23:57:31 <nmessenger> return is the same as []
23:57:50 <nmessenger> as in the normal list instance, to clarify
23:57:58 <ski> DiagList> diag_join [[0,1],[2,3]]
23:57:58 <ski> [0,1,2,3] :: [Integer]
23:58:13 <dons> hack hack hack!
23:58:14 <ski> that one diagonalizes .. as opposed to taking the diagonal :)
23:58:26 <nmessenger> oh!  taking the diagonal
23:58:53 <ski> (i.e. we want the possibly infinite "forward" diagonal, not all the finite "backwards" diagonals)
23:59:38 <ski> nmessenger : anyway, do you agree with the above partial 'join', for infinite lists ?
