00:10:43 * sorear gives his Haskell 98 parser the ultimate test - a 590 char thmprover
00:11:14 <sorear> aww, syntax error :(
00:11:31 <desp> aww
00:13:27 <sorear> HAH! I have a minimal case
00:16:34 <nornagon> thmprover?
00:17:25 <sorear> eore
00:17:42 <nornagon> i see.
00:17:43 <sorear> in any case, tortured haskell
00:17:45 <rahikkala> You really are being pretty minimal
00:17:57 <nornagon> poor haskell :(
00:18:17 <sorear> rahikkala: I couldn't get it much smaller :(
00:18:38 <rahikkala> No, I think there's still room to improve there
00:18:46 <rahikkala> Think... "thmprvr"
00:20:32 <sorear> heh.  bitty inconsistency ... the decls production required braces, as did its users.  so let {{ would've worked
00:27:50 <araujo> hello
00:36:30 <sorear> and a bug with the ultramagic :, and then, wow, it parses
00:38:00 <sorear> so, 388 lines of yacc -> haskell 98 parser
00:41:37 <JohnnyL> what are the last 5 paragraphs of http://www.cse.unsw.edu.au/~dons/data/RedBlackTree.html considered?
00:41:37 <lambdabot> Title: Haskell RedBlackTree.hs
00:42:17 <sorear> @botsack
00:42:18 <lambdabot> :)
00:42:27 <sorear> tests?
00:45:01 <JohnnyL> what's the technical term? I want to read on that.
00:45:10 <encryptio> test.
00:45:12 <sorear> invariants
00:45:16 <JohnnyL> is it like polymorphic constructors?
00:45:22 <JohnnyL> oh ok. invariants. thanks.
00:57:29 <dcoutts___> dons: about?
00:59:40 <vincenz> @localtime dons
00:59:43 <lambdabot> Local time for dons is Sat Mar 17 18:58:33 2007
01:00:11 <dcoutts___> @localtime dcoutts___
01:00:12 <lambdabot> Local time for dcoutts___ is Sat Mar 17 18:59:03
01:00:54 <dcoutts___> vincenz: it's Saturday night in Sydney.
01:01:11 <vincenz> party time?
01:01:15 <dcoutts___> quite
01:01:28 <dcoutts___> everyone in town has green hair
01:01:31 <vincenz> lol
01:01:39 <dcoutts___> and is singing and drinking Guinness
01:01:53 <vincenz> eww
01:01:58 <dcoutts___> quite
01:02:07 <vincenz> guinness is the worst
01:02:11 <vincenz> don't they have stella or jupiler
01:02:16 <vincenz> or even hoegaarden or leffe
01:02:21 <vincenz> or duvel or chimay
01:02:22 <dcoutts___> it's an acquired taste
01:02:39 <vincenz> dcoutts___: so how come you're not going out?
01:03:00 <dcoutts___> vincenz: trying to find someone to have a beer with
01:03:23 <vincenz> dcoutts___: hence the dons piing
01:03:33 <dcoutts___> aye
01:03:51 <vincenz> dcoutts___: though if he were to go out, would he be on irc?  Don't people there have cells?  And...erm...7pm is REALLY early
01:03:54 * vincenz never goes out before 11pm
01:04:21 <dcoutts___> vincenz: yes 7pm is early to go out, but not too early to make arrangements
01:04:26 <vincenz> true enough
01:04:41 <vincenz> dcoutts___: and possibly get some good food
01:04:55 <dcoutts___> there's lots of that round here
01:06:14 <vincenz> surf+turf?
01:06:19 <vincenz> they don't ahve that in .be
01:06:32 * vincenz should go to .uk for a change..
01:06:35 <vincenz> suggestions?
01:08:42 <vincenz> dcoutts___: ?
01:10:12 <dcoutts___> vincenz: suggestions for surf?
01:10:27 <Heffalump> dcoutts___: how long are you in Sydney?
01:10:43 <dcoutts___> Heffalump: ti; the end of next month
01:11:23 <Heffalump> cool
01:11:38 <vincenz> dcoutts___: well just uk seeing in general, haven't been there yet, but sure, surf sounds great
01:11:59 <dcoutts___> there's not much surf in the uk, just cornwall
01:12:10 <dcoutts___> vincenz: there's lots to see in the uk generally of course
01:12:22 <Heffalump> I thought surf+turf was a kind of meal
01:12:31 <vincenz> when you say surf, you mean fishfood or actual surfing?
01:12:34 <vincenz> Heffalump: it is
01:12:34 <dcoutts___> Heffalump: I've really no idea
01:12:37 <Heffalump> something fishy + a steak
01:12:38 <vincenz> but woot, surfing :)
01:12:45 <vincenz> surf & turf = steak and lobster
01:12:46 <sorear> wow, devotion
01:13:04 * sorear just wrote a 90 line perl script to translate adts into c
01:13:56 <vincenz> why perrl
01:14:21 <sorear> come to think, I'm not sure
01:14:30 <sorear> seemed like a good idea
01:14:54 <shapr> yarr, seven hours from Birmingham to Atlanta and back.
01:17:05 <vincenz> heh, dcoutts___ when you're back in uk I should just jump on the train and catch a pint
01:17:17 <dcoutts___> vincenz: good idea
01:17:24 <vincenz> or viceversa
01:17:26 <dcoutts___> vincenz: come to the next Haskell event in the uk
01:17:29 <vincenz> we got great beers
01:17:32 <vincenz> dcoutts___: when is it
01:17:32 <dcoutts___> vincenz: I know
01:17:43 <Heffalump> York in May, IIRC
01:17:47 <Heffalump> oh no, Cambridge in May
01:17:50 <Heffalump> York in Autumn
01:17:57 <Heffalump> Fun in the Afternoon, that is
01:18:03 <dcoutts___> vincenz: I went to Brussels the other day for FOSDEM and had very nice beer.
01:18:03 <vincenz> cool, last few times was badly scheduled, but I'll keep the schedule open
01:19:01 * Heffalump inconsiderately scheduled a wedding for the same day as FOSDEM :-)
01:19:15 <vincenz> either way, I'll be away from july to september
01:19:20 <vincenz> so it's good it's in may
01:20:30 <Heffalump> hmm, if the York Fun is after Eurostar moves to St Pancras on November 14th, it'll be pretty easy to get to from .be
01:20:47 <dcoutts___> mm, true
01:21:00 <dcoutts___> FOSDEM was easy via the Eurostar
01:21:04 <Heffalump> yeah
01:21:11 * Heffalump went last year
01:21:17 <dcoutts___> ah
01:21:41 <vincenz> what about the dynlang thing in vub
01:26:26 * Heffalump doesn't know anything about that
01:27:16 <vincenz> I think it was in '05 on all these different dynamic languages
01:28:42 <Heffalump> like Haskell... ? ;-)
01:28:48 <vincenz> oh very much so :D
01:32:42 <vincenz> there were some big names there, however.
01:39:07 <dons> Heffalump: your wedding?!
01:39:54 <vincenz> dons: no the one of his gf ;D
01:39:58 <vincenz> dons: dcoutts___ s looking for you
01:40:28 <dons> yep.
01:43:15 <Heffalump> dons, yes, mine :-)
01:43:56 * Heffalump was kind of busy with that and new job so hasn't been on here much to mention it before :-)
01:44:12 <vincenz> Heffalump: will you ask people to give their speech in haskell instead of english?
01:44:25 <Heffalump> bit late now..
01:44:50 <Heffalump> actually, two out of the three speechgivers did know Haskell very well, but the third didn't.
01:45:51 <Heffalump> (my best man being Igloo)
01:51:09 <dcoutts___> Heffalump: congratulations
01:51:29 <Heffalump> thanks :-)
01:58:18 <Eidolos> ?hoogle digits
01:58:18 <lambdabot> Numeric.floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
01:58:19 <lambdabot> Numeric.floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
01:58:19 <lambdabot> Numeric.lexDigits :: ReadS String
01:58:33 <Eidolos> ?hoogle dig
01:58:33 <lambdabot> Char.digitToInt :: Char -> Int
01:58:33 <lambdabot> Text.ParserCombinators.Parsec.Char.digit :: CharParser st Char
01:58:33 <lambdabot> Char.intToDigit :: Int -> Char
01:59:07 <dolio> ?src ap
01:59:07 <lambdabot> ap = liftM2 id
02:02:27 <sorear> goodnight.
02:02:39 <jaredj> good night.
02:02:44 <desp> nite
02:02:57 <desp> what are the possible symbolic components of an infix operator?
02:02:59 <Eidolos> you guys all have the same bedtime? ;)
02:03:04 <hpaste>  jaredj pasted "how to turn into file finder?" at http://hpaste.org/1004
02:03:09 <jaredj> Eidolos: hehe
02:03:12 <desp> no, 10 am here ;]
02:03:13 <sorear> @where report
02:03:13 <lambdabot> http://www.haskell.org/onlinereport/
02:03:20 <desp> aha
02:03:26 <jaredj> woohoo 4am here :P
02:03:31 <sorear> desp: see the lexical syntax section, production varsym
02:03:38 <desp> sorear: thanks
02:04:15 <sorear> you become very familiar with that document when you try to write a compiler...
02:05:20 <desp> constructor must start with a colon? meh
02:06:26 <desp> is ~ used anywhere in Haskell?
02:06:35 <jaredj> :t ~
02:06:37 <lambdabot> parse error (possibly incorrect indentation)
02:06:39 <jaredj> :t (~)
02:06:41 <lambdabot> parse error on input `)'
02:06:45 <jaredj> oo
02:06:50 <nornagon> yes
02:06:56 <nornagon> lazy pattern matches, i believe
02:06:57 <xs> lazy pattern matching
02:06:59 <desp> I noticed (=~)
02:07:02 <desp> oh
02:07:24 <Heffalump> lazy pattern matching is quite scary
02:08:32 <xs> > let f ~(x:xs) = 'a':xs in head (f undefined)
02:08:33 <lambdabot>  'a'
02:08:42 <xs> > let g (x:xs) = 'a':xs in head (f undefined)
02:08:43 <lambdabot>   Not in scope: `f'
02:08:45 <xs> arg.
02:08:48 <xs> > let g (x:xs) = 'a':xs in head (g undefined)
02:08:49 <lambdabot>  Undefined
02:09:00 <desp> hmmm
02:09:03 <Eidolos> hmm, yeah, ~ does mark a "unfailable pattern" or something, but I think that's prefix, not infix
02:10:01 <desp> odd
02:11:04 <jaredj> can i lift a class into a monad?
02:11:46 <jaredj> e.g. class JTree a where { getChildren :: a -> [a] }
02:11:48 <int-e> Eidolos: the word is "irrefutable"
02:11:57 <jaredj> getDirectoryContents :: FilePath -> IO [FilePath]
02:12:50 <jaredj> do i have to make a Monad m => JMTree a where { getChildren :: a -> m [a] }, or can something make it for me?
02:13:22 <JohnMeacham>  sorear: who quotes me?
02:15:11 <vincenz> @quote johnmeacham
02:15:12 <lambdabot> No quotes match. I've seen penguins that can type better than that.
02:15:22 <vincenz> noone
02:15:47 <jaredj> <jaredj> foo
02:15:53 <jaredj> @quote jaredj
02:15:53 <lambdabot> No quotes match. Wrong!  You cheating scum!
02:15:59 <vincenz> @quote vincenz
02:15:59 <lambdabot> vincenz says: I thought the kinkiness of this channel had just gone way up
02:16:05 <JohnMeacham> @quote JohnMeacham
02:16:05 <lambdabot> JohnMeacham says: no matter what I name a AM.. it can never be as cool a name as 'spineless tagless g-machine'.
02:16:10 <JohnMeacham> @quote JohnMeacham
02:16:10 <lambdabot> JohnMeacham says: There will also be a karaoke competition to determine the fate of the monomorphism restriction.
02:16:16 <JohnMeacham> @quote JohnMeacham
02:16:16 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
02:16:16 <lambdabot> of insight hits and it all makes sense.
02:16:24 <vincenz> :)
02:16:27 <JohnMeacham> hmm.. I say too many things.
02:16:28 <vincenz> @quote vincenz
02:16:28 <lambdabot> vincenz says: import Oleg
02:16:51 <desp> @arr
02:16:51 <lambdabot> Yo ho ho, and a bottle of rum!
02:16:56 <int-e> @quote karaoke
02:16:56 <lambdabot> JohnMeacham says: There will also be a karaoke competition to determine the fate of the monomorphism restriction.
02:17:17 <JohnMeacham> I still think 'spineless tagless g-machine' is a better name for a band than an abstract machine.
02:17:41 <dolio> It's rather long for a band name.
02:18:04 <jaredj> rage against the spineless tagless g-machine
02:18:05 <int-e> np: spineless, "tagless g-machine"
02:19:33 <desp> Now, for many programmers, functional purity might seem a ridiculously high price to pay. But there’s a surprisingly large number of functional languages out there already: query languages like SQL, OQL and LINQ; vertex and fragment shaders on your GPU; and even some hardware modeling languages (if you squint at them right).
02:19:41 <desp> I love this guy's writing
02:19:43 <desp> :D
02:19:49 <vincenz> desp: who
02:19:56 <desp> randomhacks.net
02:21:11 <therp> my keyboard lacks a λ key.
02:21:38 <int-e> @quote mainstream
02:21:38 <lambdabot> Lemmih says: inv2004: Haskell isn't like all the other mainstream languages. You really need to read a tutorial.
02:23:18 <dolio> @quote qwe1234
02:23:18 <lambdabot> qwe1234 says: the only reason for 'dispatching, polymorphism and parametrization' to exist at all is for enforcing safety.
02:23:38 <Cheery> therp: mine too, or I've just not found it.
02:23:44 <vincenz> @quote palomer
02:23:45 <lambdabot> No quotes match. I've seen penguins that can type better than that.
02:23:52 <dolio> @quote qwe1234
02:23:52 <lambdabot> qwe1234 says: in my very firm opinion, it's never your business to be figuring out pointer type at runtime.
02:24:02 <Cheery> @quote Cheery
02:24:02 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
02:27:58 <Cheery> People who do not realise what's awesome in functional purity are either Right "ignorant about it" or Left "idiots"
02:28:22 <JohnMeacham> 'Either'
02:28:36 <JohnMeacham> constructors are capitalized. I do declare.
02:29:23 <JohnMeacham> me hungry.
02:30:11 <Cheery> me not tasty.
02:33:28 <jaredj> are multi-parameter classes in haskell' ?
02:34:10 <therp> yes
02:34:33 <therp> well not in Haskell98, but in most popular haskell compilers via an extension
02:35:01 <jaredj> yes, i just had to turn on -fglasgow-exts
02:35:58 <dolio> Were you asking if they're slated to be included in Haskell'? I suspect they are.
02:36:38 <therp> yes, ticket #49 in haskell-prime
02:37:17 <jaredj> ?t memberOf
02:37:17 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
02:37:26 <jaredj> :t memberOf
02:37:27 <lambdabot> Not in scope: `memberOf'
02:37:35 <rahikkala> :t elem
02:37:38 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
02:37:41 <jaredj> thanks
02:42:57 <jaredj> :t (concat . mapM)
02:43:00 <lambdabot>     Ambiguous occurrence `mapM'
02:43:00 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
02:45:58 <dolio> ?pl (concat .) . mapM
02:45:58 <lambdabot> (join .) . mapM
02:46:08 <jaredj> join, of course
02:46:23 <dolio> Well, join and concat are the same for [].
02:47:37 <Heffalump> ?t (join . ) . mapM
02:47:37 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
02:47:41 <Heffalump> ?type (join . ) . mapM
02:47:44 <lambdabot>     Ambiguous occurrence `mapM'
02:47:44 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
02:47:51 <Heffalump> ?type (join . ) . Control.Monad.mapM
02:47:53 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
02:50:08 <dolio> ?src transpose
02:50:09 <lambdabot> transpose []             = []
02:50:09 <lambdabot> transpose ([]   : xss)   = transpose xss
02:50:09 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
02:56:29 <dolio> > concat . transpose $ [repeat 1, repeat 2]
02:56:30 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
02:57:52 <jaredj> :t (not . elem)
02:57:54 <lambdabot>     Couldn't match expected type `Bool'
02:57:54 <lambdabot>            against inferred type `[a] -> Bool'
02:58:15 <jaredj> :t elem
02:58:17 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
02:58:19 <dolio> :t ((not .) . elem)
02:58:22 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
02:58:29 <jaredj> ?!
02:58:29 <lambdabot> Maybe you meant: . v
02:59:12 <dolio> > foldr (\a b -> concat . transpose $ [a, b]) [] $ iterate (*2) 1
02:59:13 <lambdabot>   add an instance declaration for (Num [a])
02:59:33 <dolio> > foldr (\a b -> concat . transpose $ [a, b]) [] . map repeat$ iterate (*2) 1
02:59:34 <lambdabot>  [1,2,1,4,1,2,1,8,1,2,1,4,1,2,1,16,1,2,1,4,1,2,1,8,1,2,1,4,1,2,1,32,1,2,1,4,1...
03:00:44 <xerox> ?where logs
03:00:44 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
03:08:06 <jacobian> is there an interactive haskell shell ala bash
03:08:48 <QtPlatypus> ghci
03:09:09 <QtPlatypus> Or do you mean launch programs ect?
03:09:41 <jaredj> hsh
03:09:45 <jaredj> in that case
03:13:17 <Eidolos> I'm trying to read the first two consecutive-runs-of-digits from a string. (so for example, "blah 100F xx -- F22.. 3030" will return (100, 22).
03:13:29 <Eidolos> and failing. :)
03:13:53 <Eidolos> trying to do some ad-hoc-ery with read and the battle isn't going well.
03:14:13 <rahikkala> Give in and use parsec :)
03:14:32 <Eidolos> hrm.. ok :)
03:15:04 <malcolmw> > (takeWhile isDigit . dropWhile (not . isDigit)) "blah 100F xx -- F22.."
03:15:06 <lambdabot>  "100"
03:15:16 <Eidolos> ah right, isDigit. heh.
03:15:18 <Eidolos> thanks!
03:15:59 <malcolmw> > (takeWhile isHexDigit . dropWhile (not . isDigit)) "blah 100F xx -- F22.."
03:16:00 <lambdabot>  "100F"
03:17:23 <Eidolos> ?src span
03:17:24 <lambdabot> Source not found. Maybe if you used more than just two fingers...
03:30:04 <hpaste>  Eidolos pasted "First two natural numbers in a string" at http://hpaste.org/1005
03:30:08 <Eidolos> well, I ad-hoc-ed my way to a solution. :)
03:30:31 <goltrpoat> dons:  i don't know if i'd particularly endorse mazanek's chess program -- no offense to the author by any means, but it's sort of a toy program (straight minimax, no en passant, no castling, most people could write that in C++ in a couple of hours, honestly)
03:31:00 <Eidolos> IIRC that Haskell program is rather short, where a C++ implementation would be far longer.
03:31:03 <goltrpoat> i suspect chessguy here probably has something a lot more advanced
03:31:43 <goltrpoat> eidolos:  yes, but the c++ implementation would actually run at more than 2 ply or so.
03:34:52 <Botje> Eidolos: you could use unfoldr for more plys.
03:34:54 <Botje> *plies
03:35:08 <Eidolos> In any case, so what if it's a toy program? Seems to me that most of the reddit community loves Haskell but doesn't know it very well (much like myself), the simplifications probably make it more readable.
03:35:33 <Eidolos> s/readable/understandable/
03:36:26 <Botje> regexes make it rather trivial, of course.
03:36:27 <goltrpoat> like i said, i'm not trying to disparage the project or the author by any means.  it's just that haskell has this "slow" stigma, and the chess programming crowd is a fairly performance-oriented bunch, as you'd imagine
03:36:37 <Botje> $str =~ /\d+/g
03:36:51 <jacobian> does haskell have a slow stigma?
03:37:05 <jacobian> seems to me that it hardly even registers on the radar
03:37:07 <Eidolos> Botje: yep, I'm a Perl guy too so doing this kind of thing in Haskell is a pain :)
03:37:15 <Botje> yeah.
03:37:22 <goltrpoat> jacobian:  hmm.  depends on who you talk to, i suppose.
03:37:31 <Botje> luckily, haskell has developed decent regex support recently :)
03:38:22 <Eidolos> I had someone suggest in another channel that Haskell was slow when I told them I was using it. I pointed them to the language shootout. ghc was no more than 5x slower than gcc in most cases, and (somewhat to very) faster than Perl in I think all cases.
03:39:36 <goltrpoat> i'm not making any performance judgements.  i'm just saying that this is like writing a javascript 3d renderer.  people will say "oh that's cute" and move on.
03:40:08 <goltrpoat> except in this case, it's not as much the inherent platform limitations, as the fact that it's a toy project to begin with, which was posted as "haskell chess" on reddit.
03:40:09 <goltrpoat> make sense?
03:40:12 <Eidolos> which is fine! :) I don't think mazanek is aiming to replace GNU chess.
03:40:54 <goltrpoat> of course not.  that's the point :)
03:44:21 <dons> jacobian: yeah, haskell is one of the faster languages around these days. native code compilers, good runtimes. its all fun :-)
03:44:41 <goltrpoat> "minimax in haskell" would've been great.  "introduction to chess programming in haskell"  -- also excellent.  "haskell chess" -- bad.
03:45:42 <Eidolos> hmm, I guess I see your point then. I just think it's a fine example of a nontrivial Haskell app, and you probably agree, just that it could have been labeled better.
03:46:32 <goltrpoat> no, it's an excellent topic for teaching both search problems and haskell
03:46:36 <dons> the chess program is a university assignment, isn't it?
03:46:41 <dons> so yeah, ideal for teaching students
03:46:50 <goltrpoat> like i said, i'm by no means trying to like.. make anyone or anything look bad.
03:47:03 <goltrpoat> i'm just explaining how this looks from a chess programmer's perspective.
03:47:47 <Eidolos> all right, well, I'm not sure what your goal here is, hehe
03:47:54 <goltrpoat> hehe
03:48:20 <Xgc> You have to be careful trying to draw conclusions about the applicability of language implementations based on 10 minutes spent building a system in language X and a few 1000 man years in language Y.
03:48:59 <goltrpoat> i just think that it was a badly named post, and it would be bad to continue to keep that one up, because it forces certain unreasonable conclusions.
03:49:09 <Xgc> Also noting language X is in early stages of development.
03:49:42 <Xgc> and language Y is pretty much at a dead end.
03:50:30 <Xgc> s/dead end/final form/
03:50:51 <goltrpoat> i don't disagree on any particular point.
03:53:23 <goltrpoat> the title just irked me a little, just like the title "c++ compiler" would irk me if it was a 2 hour hack of a compiler for a CL subset.
03:54:50 <goltrpoat> i really don't need to be convinced in haskell's applicability to any particular problem.
03:55:00 <goltrpoat> this one in particular, since i've been working on it on and off for a while.
03:55:56 <kombinator> widac tak
03:56:24 <kombinator> sorry, wrong window
04:51:34 <narain> ?quote
04:51:34 <lambdabot> sjanssen says: "shapr: Erik Kidd == emu? don't quote me on that"
04:59:23 * eddyp_ remembers why he was confused - the difference between hugs and ghci... yaht assumes you're using ghci
05:03:05 <pebblestone> Hi, could anybody tell me where I can find the reference on how haskell's pattern matching is implemented?
05:03:42 <goltrpoat> http://haskell.org/onlinereport/syntax-iso.html is a start
05:03:43 <lambdabot> Title: Haskell 98 Syntax
05:03:52 <pebblestone> ok, thanks!
05:04:02 <goltrpoat> np
05:07:27 <goltrpoat> pebblestone:  the context-free syntax is towards the end of that page, so the parts you'd be interested in are pat, apat and everything that pulls in
05:07:57 <goltrpoat> most of the productions are given in that grammar, so it's fairly self-contained (you may need to go back up to the lexical syntax here and there)
05:09:14 <pebblestone> goltrpoat: i see. thanks for the information.
05:10:53 <araujo> morning
05:12:12 <goltrpoat> is that what they call it these days
05:17:15 <chessguy> 'morning haskellers
05:17:27 <araujo> chessguy!!
05:17:45 <chessguy> araujo! bonne dia!
05:17:55 <araujo> :-)
05:38:04 <eddyp_> how can I turn this into a single [Char] ?
05:38:06 <eddyp_> ["sahld saa"," "]
05:38:42 <vincenz> > head . head $ ["sahld saa"," "]
05:38:43 <lambdabot>  's'
05:38:56 <lemmih> > concat ["sahld saa"," "]
05:38:57 <lambdabot>  "sahld saa "
05:39:03 <eddyp_> thanks
05:39:08 <vincenz> lemmih: come to #oasis
05:56:22 <fasta> Is filterM (\a-> do action; return True) the same as mapM action?
05:57:51 <fasta> It is, never mind.
06:14:07 <fasta> Why does this print both "hi" and "there"? filterM (\e->do putStrLn e; return True) ["hi", "there"]>>= \res -> return (take 1 res)
06:14:38 <fasta> I only want the "side-effect" to happen for the elements I select.
06:15:20 <Botje> you should just map, not mapM, then
06:16:03 <Botje> i think :)
06:16:04 <fasta> It appears filterM is completely strict.
06:16:47 <fasta> Botje: that requires me to use sequence too, then.
06:16:50 <xerox> ?src filterM
06:16:50 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:17:36 <fasta> lambdabot is really annoying with that message ...
06:18:18 <desp> I prefer when it does that pinguin thing
06:18:27 <fasta> @moo
06:18:27 <lambdabot> Maybe you meant: map more msg todo yow
06:18:43 <desp> @quote penguin
06:18:43 <lambdabot> int-e says: PHP is a programming language like penguins are birds. And people try to make it fly.
06:18:44 <fasta> Ok, they got rid of that 1+ years ago
06:18:50 <desp> @quote desp
06:18:51 <lambdabot> psykotic says: Let me get this straight: in your tireless Lisp-bashing efforts you have now dragged out Prolog as an exemplar of practicality? *Prolog*? My goodness, you must be desperate!
06:18:59 <desp> @quote
06:18:59 <lambdabot> <skew> says: also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
06:19:03 <desp> meh.
06:19:14 <fasta> @quote fasta
06:19:15 <lambdabot> No quotes match. You type like i drive.
06:19:19 * qwr thinks, that lambdabot is still very polite, when compared to some bots on other channels...
06:19:19 <desp> ;D
06:19:26 <fasta> @quote lambdabot
06:19:26 <lambdabot> lambdabot says: fOra11 (t :: (* -> *) -> * -> *) (/\/\ :: * -> *) A. (/\/\oNAd+R4nz0rz t, MoN4D /\/\) => 7 ((->) a) (M a)
06:19:49 <chessguy> ?seen dcoutts_
06:19:49 <lambdabot> dcoutts_ is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
06:19:55 <vincenz> @quote denotational
06:19:55 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
06:19:55 <chessguy> dcoutts_: ping
06:20:00 <fasta> @src Control.Monad.filterM
06:20:00 <lambdabot> Source not found. You speak an infinite deal of nothing
06:20:19 <vincenz> @protontorpedo
06:20:20 <lambdabot> that dude is selling u  a book
06:20:20 <fasta> The problem is that it claims to support src, while in fact it doesn't, and then claims user error.
06:20:49 <fasta> That's the same as a Windows user telling an advanced Linux user that Linux suXors.
06:21:31 <fasta> OH nOES I cant play my gAMEZ on THAT!
06:22:02 <vincenz> "Dude, it doesn't even support flash 9, you -soo- need that for pron, man"
06:22:25 <fasta> vincenz: actually it does, but you already knew that, right?
06:22:26 <Cale> Uh, actually, it does support Flash 9.
06:22:39 <fasta> :)
06:22:42 <Cale> (This is recent)
06:22:46 <psykotic> have they fixed the weird video-audio sync issues?
06:23:05 <kalven> yes
06:23:11 <fasta> psykotic: I never had problems (other then the fact that they dropped OSS support)
06:23:21 <vincenz> mine only supports v8
06:23:27 <Cale> yeah, as far as those were issues with flash itself and not specific animations
06:23:49 <psykotic> fasta, the sync was off by a very small amount, but it was enough to make it painful
06:25:29 <chessguy> ?hoogle time
06:25:29 <lambdabot> System.Time :: module
06:25:29 <lambdabot> Time :: module
06:25:29 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
06:25:55 <fasta> psykotic: ok, maybe I am not an audiophile.
06:26:14 <psykotic> fasta, well, the lips didnt match with the speech, it was pretty obvious. :)
06:26:49 <psykotic> i read it was a known issue on the dev blog, but this was before they apparently fixed it in the linux version of flash 9
06:26:49 <fasta> psykotic: Ok, then maybe it worked magically on my machine.
06:26:49 <Cale> psykotic: do you happen to know if this problem was cross-platform or not?
06:26:56 <psykotic> it was linux only
06:27:04 <psykotic> well, it didnt happen on windows anyway
06:27:07 <Cale> hmm, okay, then I'm not sure.
06:27:22 <fasta> I watched a couple of Google presentations on it. I sure must have noticed if it was there.
06:27:43 <kalven> It was pretty obvious in flash7, it's fixed in flash9
06:27:59 <Cale> I know that there used to be cross platform sync issues which seem to have been fixed either by better creation software, or better client implementations.
06:28:24 <fasta> If someone just reimplements Flash 9 in Haskell in a day or so ;)
06:28:37 <chessguy> @go 1 millisecond in picoseconds
06:28:38 <lambdabot> 1 millisecond = 1,000,000,000 picoseconds
06:29:07 <Cale> It's really too bad that Flash is a closed standard.
06:29:09 <psykotic> the other issue was that flash would sometimes try to grab exclusive access to the audio device or something
06:29:29 <psykotic> i think it was using one of the older audio apis where exclusive access was the only mode
06:30:12 <chessguy> @go 1 second in milliseconds
06:30:17 <lambdabot> 1 second = 1,000 milliseconds
06:31:09 <fasta> Cale: Flash 7 isn't AFAIK
06:31:47 <fasta> But you might need to look out for patent torpedos.
06:33:24 <Cale> psykotic: The flash 9 player uses alsa.
06:44:52 <therp> It's scary that my recent update to my world domination plans includes static typing.
06:45:06 <chessguy> what causes this? i have regionToGRegion :: Region -> G.Region, and ghci complains " Not in scope: `regionToGRegion'"
06:45:16 <chessguy> on that line
06:45:59 <fasta> Seen this before? GHC internal error: `foobar' is not in scope
06:48:08 <fasta> Never mind it, I know how to reproduce it.
06:48:35 <chessguy> squish
06:49:02 <fasta> @dict squish
06:49:02 <lambdabot> Supported dictionary-lookup commands:
06:49:02 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
06:49:02 <lambdabot> Use "dict-help [cmd...]" for more.
06:49:23 <fasta> @all-dicts squish
06:49:26 <lambdabot> *** "squish" gcide "The Collaborative International Dictionary of English v.0.48"
06:49:26 <lambdabot> squish \squish\ (skw[i^]sh), v. i. [Perh. imitative. Cf.
06:49:26 <lambdabot>    {Squelch}.]
06:49:26 <lambdabot>    To make the sound of squirting water, like that made by the
06:49:26 <lambdabot>    feet of one walking in mud or slush; to make a kind of
06:49:28 <lambdabot> [34 @more lines]
06:51:09 <chessguy> heh
06:51:24 <chessguy> programmers used to say that whenever they killed a bug in their code
06:52:29 <chessguy> ?hoogle fromint
06:52:30 <fasta> @jargon squish
06:52:30 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
06:52:30 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
06:52:31 <lambdabot> No match for "squish".
06:52:48 <fasta> @jargon squish
06:52:50 <lambdabot> No match for "squish".
06:53:11 <rahikkala> squish sounds like a synonym for join
06:54:01 <emk> Hmm. Should I go snowboarding, or write a very short introduction to category theory?
06:54:15 * emk looks at snow blocking the exit to the driveway
06:54:16 <fasta> snowboarding
06:54:36 <rahikkala> Go snowboarding and write a medium-length introduction to category theory later
06:54:39 <chessguy> definitely category theory
06:54:52 <chessguy> and ping me when you're done :)
06:55:09 <psykotic> try to explain adjoints in a way that everyone will immediately understand intuitively :)
06:55:47 <chessguy> you've been on a roll lately in your blogs, i'd love to see what you can do with category theory
06:56:10 <emk> Well, the problem: If I go snowboarding now, I need to spend an hour shoveling out the driveway (I'm pretty impressively trapped). But I could always write until the plow comes.
06:56:53 <chessguy> @paste
06:56:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:57:34 <hpaste>  chessguy pasted "Is this a reasonable way to get the current time in milliseconds?" at http://hpaste.org/1006
06:58:07 <psykotic> ive been thinking recently about ct, and naturality in particular, from the viewpoint of functional programming. you can understand something like the unnaturality of the dual isomorphism for vector spaces via a kind of parametricity theorem in the presence of typeclasses.
06:59:03 <thorat> psykotic: did dpiponi touch on that in his blog (didn't read it through)?
06:59:47 <psykotic> in the case of the dual isomorphism, you want to produce a V -> (V -> F), and you can justify on parametricity grounds that the only map of that form is the 0 map
07:00:12 <fasta> @type Control.State.put
07:00:14 <lambdabot> Couldn't find qualified module.
07:00:28 <fasta> @type Control.Monad.State.put
07:00:30 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
07:00:43 <fasta> Why is the type m () and not m t?
07:00:55 <fasta> That would be more practical.
07:01:01 <Saizan> m t?
07:01:09 <psykotic> you mean it should return the previous value?
07:01:25 <fasta> forall s t . (m :: * -> *). (MonadState s m) => s -> m
07:01:25 <fasta>                   t
07:01:28 <fasta> I mean this
07:01:36 <fasta> Er m t at the end
07:01:42 <Saizan> and how would it produce that t?
07:01:50 <fasta> Saizan: return undefined
07:02:12 <Saizan> right, and what would the use?:)
07:02:26 <Saizan> +be
07:02:31 <fasta> I.e. new_and_improved_put value  = do put value;return undefined
07:02:51 <fasta> Saizan: can't you really think of that yourself?
07:02:58 <fasta> Saizan: it's pretty obvious.
07:03:03 <Saizan> i don't see why you want that
07:03:23 <fasta> Saizan: then you probably never used a conditional in a monadic context.
07:04:14 <Saizan> i did, and just used () when i had no value to return
07:04:45 <fasta> Saizan: yes, but you need to say explicitly: return () then.
07:05:31 <Saizan> if i have no value it's very common that i'm using a m () already
07:06:01 <Saizan> sequence_, mapM_, put :)
07:26:50 <chessguy> ?hoogle sin
07:26:51 <lambdabot> Prelude.sin :: Floating a => a -> a
07:26:51 <lambdabot> Prelude.sinh :: Floating a => a -> a
07:26:51 <lambdabot> Data.IntMap.singleton :: Key -> a -> IntMap a
07:26:57 <chessguy> ?src sin
07:26:57 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:28:30 <erider> good morning
07:31:17 <lambdabot> chessguy: The source of sin is a fairly religious question and it is outside the scope of my programming.
07:33:55 <chessguy> Lemmih: it might have been hard to guess who was messing with LB if you hadn't had to change your nick to do it :)
07:34:16 <Lemmih> Foo!
07:35:12 <chessguy> > sin 0
07:35:13 <Lemmih> I hoped no one would notice (:
07:35:21 <lambdabot>  0.0
07:43:35 <fasta> How would you write filterMLazy? A function that takes an action returning a list of elements on which the action returned true, and only applies those actions to elements that are actually needed by its called. E.g. filterMLazy (\e-> do putStrLn e; return True) ["hi","there"] >>= (return . Prelude.head) should print "hi" and return "hi"
07:44:53 <kpreid> fasta: with unsafeInterleaveIO
07:45:05 <fasta> How would you write filterMLazy? A function that takes an action returning a list of elements on which the action returned true, and only applies those actions to elements that are actually needed by its caller. E.g. filterMLazy (\e-> do putStrLn e; return True) ["hi","there"] >>= (return . Prelude.head) should print "hi" and return "hi"
07:45:31 <fasta> kpreid: how would that work for an arbitrary monad?
07:45:54 <shapr> Lemmih: haha
07:46:01 <kpreid> fasta: it wouldn't
07:46:17 <fasta> kpreid: then it isn't a solution
07:46:32 <kpreid> I think there is none
07:46:35 <chessguy> hmm, anyone worked through the HSOE examples much?
07:46:57 <kpreid> fasta: a monad without extra features can't have actions inserted depending on whether something's evaluated
07:47:11 <chessguy> it looks like one of the examples is broken, even in the provided source code
07:54:22 <fasta> kpreid: what extra features? You mean for signalling:" I need an extra element"? Shouldn't the signallying ideally happen because of the caller, well ....calling it :)
07:54:56 <kpreid> fasta: yes, but it's having an effect on something independent, namely the monadic value
07:55:37 <kpreid> for example, in the list monad you might get a completely different list if more actions were sequenced
07:55:43 <fasta> kpreid: yes, but that's exactly what I want.
07:56:09 <kpreid> what happens if the resulting list has been evaluated before the filterMLazy-result is forced?
07:56:15 <kpreid> it just doesn't make sense
07:57:05 <fasta> kpreid: how can the resulting list have been evaluated if filterMLazy created the list in the first place?
07:57:38 <kpreid> let me try to make an example
07:59:11 <fasta> filterMLazy is a generalization of the function that takes an action and returns the first element for which this action returns True. I like to be able to write generalized code. When at some point this isn't possible anymore the language isn't working with me anymore, but against me.
08:01:20 <yshhq> ?google callCC
08:01:23 <lambdabot> http://www.madore.org/~david/computers/callcc.html
08:01:23 <lambdabot> Title: A page about call/cc
08:01:27 <yshhq> :hoogle callCC
08:01:49 <yshhq> ?hoogle callCC
08:01:50 <lambdabot> Control.Monad.Cont.callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
08:04:43 <kpreid> fasta: do ys <- filterMLazy (\y -> do [1, 2]; return True) [1,2,3,4]; return ys
08:04:59 <kpreid> fasta: how many elements does the outer list resulting from that expression have?
08:29:23 <chessguy> ?hoogle showsPrec
08:29:24 <lambdabot> Prelude.showsPrec :: Show a => Int -> a -> ShowS
08:30:39 <sorear> hi.
08:30:56 <fasta> hi
08:33:27 <araujo> @where + hmagic http://www.fmap.us/bindings/hmagic.tar
08:33:28 <lambdabot> I know nothing about +.
08:33:33 <araujo> @where add hmagic http://www.fmap.us/bindings/hmagic.tar
08:33:34 <lambdabot> I know nothing about add.
08:33:41 <araujo> @where+ add hmagic http://www.fmap.us/bindings/hmagic.tar
08:33:42 <lambdabot> Done.
08:33:44 <araujo> :-)
08:34:31 <allbery_b> still not quite right
08:34:34 <allbery_b> @where add
08:34:34 <lambdabot> hmagic http://www.fmap.us/bindings/hmagic.tar
08:34:44 <allbery_b> @where+ hmagic http://www.fmap.us/bindings/hmagic.tar
08:34:44 <lambdabot> Done.
08:35:01 <araujo> Thanks allbery_b
08:38:29 <kpreid> fasta: did you see my example?
08:38:35 <cdsmith> Is there a concise way to write a case statement that does the same thing for lots of possibilities?
08:38:39 <fasta> kpreid: yes, 5 minutes ago.
08:38:53 <kpreid> fasta: and what do you think of it?
08:39:01 <fasta> kpreid: I am not familiar with using do [1,2] notation, so I tried that out first.
08:39:06 <Pastorn> @seen cantadou
08:39:06 <lambdabot> I haven't seen cantadou.
08:39:09 <kpreid> it's the list monad
08:39:14 <fasta> kpreid: Yes, I know
08:39:26 <fasta> kpreid: I just don't use it in that way.
08:39:33 <araujo> cdsmith, define a function for all of them?
08:39:46 <fasta> kpreid: Naively, I would say that it would return 4 elements.
08:40:02 <kpreid> fasta: no...
08:40:09 <Pastorn> ?where logs
08:40:10 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
08:40:16 <cdsmith> araujo: you mean like case x of { 1 -> somefunc; 2 -> somefunc; ...} ?
08:40:20 <fasta> kpreid: but probably it returns 2*4
08:40:55 <araujo> yes cdsmith
08:40:57 <kpreid> fasta: but the number of multiplies-by-2 are determined by the number of splits done by the [1,2] action!
08:41:13 <kpreid> fasta: in fact, consider if the list was [] instead of 1,2
08:41:20 <cdsmith> araujo: okay, I just wanted to be sure I wasn't missing some language syntax for the purpose before I did something like that.
08:41:21 <kpreid> er, [] instead of [1,2]
08:41:37 <cdsmith> araujo: thanks
08:41:44 <kpreid> fasta: the result list would contain one copy of [1,2,3,4] only if you never evaluated that, and be empty if you did!
08:41:46 <araujo> cdsmith, you are not. welcome
08:41:53 <kpreid> it contradicts itself
08:42:40 <kpreid> fasta: there could be monads where you *can* do this; I'm showing how it's impossible to do for *every* monad
08:42:45 <fasta> kpreid: ok, that's a non-constructive proof of non-existence.
08:45:27 <kpreid> I admit to not knowing how you'd have a constructive proof of non-existence
08:46:59 <fasta> kpreid: an enumeration can be used an a constructive proof of non-existence?
08:47:11 <fasta> er as an
08:48:14 <kpreid> I suppose
08:48:46 <kpreid> filterMLazy (\x -> do []; return True) [1,2,3] -- better example
08:48:48 <fasta> kpreid: the number of splits for a list of length l is always l, right?
08:49:02 <kpreid> no, because then it wouldn't be lazy
08:49:06 <kpreid> it would just be filterM
08:49:16 <fasta> kpreid: then I don't understand what you mean by "split".
08:49:38 <kpreid> every time you use the action [1,2] in the list monad you split the execution
08:49:46 <kpreid> > do [1,2]; return "hi"
08:49:48 <lambdabot>  ["hi","hi"]
08:49:52 <kpreid> > do [1,2]; [1,2]; return "hi"
08:49:53 <lambdabot>  ["hi","hi","hi","hi"]
08:49:59 <fasta> ok
08:50:11 <kpreid> > do a <- [1,2]; b <- [1,2]; return ("hi",a,b)
08:50:12 <lambdabot>  [("hi",1,1),("hi",1,2),("hi",2,1),("hi",2,2)]
08:50:42 <kpreid> > filterM (\x -> do []; return True) [1,2,3]
08:50:43 <lambdabot>  []
08:50:55 <rahikkala> @compose elite compose elite elite elite elite compose elite compose
08:50:55 <lambdabot> 3|I+E 1337 c0mP0$E 3|i73 (0/\/\P0$E
08:53:39 <fasta> kpreid: the result list would contain one copy of [1,2,3,4] only if you never evaluated that <- isn't this the same as stating falsum -> everything?
08:54:46 <sorear> @. elite . elite . elite . elite elite elite ellit elite elite compose compose
08:54:47 <lambdabot> 31I+e 311i7 3|i7E 31i+3 (0mp0$e (0/\/\POz3
08:55:32 <kpreid> fasta: I'm not sure. the condition is nonsensical and I didn't make much sense explaining it
08:57:42 <chessguy> @tell dcoutts_ you told me to let you know if i had any trouble with using Graphics.SOE.Gtk for the examples from HSOE. there's one example that seems to be broken, even in the source provided by Hudak. pg 166, using rubberBall gives an error: Animation: user error (invalid matrix (not invertible)) ...it works if you try a rectangle instead of an ellipse
08:57:43 <lambdabot> Consider it noted.
08:58:51 <chessguy> @tell dcoutts_ disclaimer: this may be a 64-bit thing, since i'm running 64-bit fedora
08:58:51 <lambdabot> Consider it noted.
09:04:21 <int-e> does the ghc runtime stop all threads when doing a garbage collection in the threaded rts?
09:06:04 <fasta> take :: Int -> Seq a -> Seq a
09:06:04 <fasta> O(log(min(i,n-i))). The first i elements of a sequence.
09:06:24 <fasta> How can taking lets say all elements take only logarithmic time?
09:06:45 <fasta> From documentation from Data.Seq
09:07:29 <sorear> because it returns an object that shares nodes with the original
09:07:40 <int-e> fasta: taking all elements can be constant times - you just give back the same sequence
09:07:48 <sorear> it doesn't need to touch the whole structure to cut it in half
09:07:52 <int-e> eek. my grammar is broken.
09:07:59 <sorear> int-e: yes (wrt gc q)
09:08:10 <int-e> fasta: and basically Data.Seq is a tree.
09:08:12 <int-e> sorear: thx
09:08:19 <fasta> int-e: ok, I am just interested in getting constant time head and tail.
09:08:40 <sorear> fasta: lists have constant time head and tail
09:08:53 <sorear> last is O(n)
09:08:55 <int-e> fasta: there's a nice paper about those 2-3 finger trees.
09:08:56 <fasta> sorear: By tail I mean last
09:09:25 <Cale> fasta: then Data.Sequence is good.
09:09:34 <fasta> Cale: ok
09:09:58 <Cale> You could also do some tricky thing where you keep two lists, and occasionally balance them.
09:10:03 <sorear> fasta: then you probably want the Edison deques, but if you want to stick with base Seq is asymptotically as good
09:10:28 <Cale> (that'd be Edison deques :)
09:10:53 <int-e> Cale: but then you don't get the O(log(n)) take (from both ends)
09:12:21 <sorear> int-e: <fasta> int-e: ok, I am just interested in getting constant time head and tail.
09:12:24 <int-e> I think this is the paper I meant. http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
09:12:26 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
09:12:40 <fasta> Can it do toList in O(n)?
09:12:49 <sorear> yes
09:12:50 <int-e> fasta: sure
09:12:51 <Cale> int-e: right
09:12:59 <hyrax42> can anything *not* do toList in O(n)?
09:13:21 <fasta> Ah, I see viewr
09:13:24 <int-e> hyrax42: that's a silly challenge :)
09:13:29 <fasta> hyrax42: of course
09:13:41 <hyrax42> int-e: should have qualified it  with "in the libs"
09:14:01 <Cale> Data structures which store asymptotically more nodes than they actually hold elements.
09:14:12 <hyrax42> yeah I was giong to say that
09:15:00 <hyrax42> but would that ever give you an advantage?
09:15:12 <Cale> maybe
09:15:18 <int-e> fasta: the 'finger' part is the trick that gets you the O(1) head and tail, by avoiding having to traverse the tree for these operations.
09:15:32 <Cale> Those nodes might contain useful information with regard to finding elements at the leaves.
09:15:42 <int-e> fasta: but it's kinda hard to explain. the paper does a good job for that.
09:15:50 <hyrax42> I suppose you have these really weird heaps and such that I've never considered
09:16:06 <fasta> int-e: I read the paper before, it's just that I can't remember every detail of everything I have read.
09:16:07 <hyrax42> though I think they store same number of nodes as data
09:16:11 <sorear> hyrax42: hashtables
09:16:48 <hyrax42> sorear: that would depend
09:16:59 <fasta> Someone should implement asymptotically optimal hash tables in Haskell.
09:17:00 <sorear> hyrax42: a m-bucket hashtable with n elements will take O(m+n), not O(n), to toList
09:17:06 <hyrax42> if you maintain the load factor in some range
09:17:12 <hyrax42> then m is O(n)
09:17:14 <fasta> I don't think even Python has those.
09:17:16 <sorear> hyrax42: I'm talking about Data.Hashtable.  No such cleverness
09:17:47 <hyrax42> what are those tables used for ?
09:17:49 <hyrax42> I've wondered
09:17:51 <fasta> Another algorithmic trick gone to waste. :(
09:17:55 <hyrax42> I'm sguessing deep dark internals
09:18:14 <hyrax42> fasta: define asymptotically optimal hash table
09:18:20 <sorear> hyrax42: symbol tables, TypeRep cache
09:18:33 <hyrax42> so deep dark internals then :p
09:18:36 <fasta> hyrax42: all operations either amortized constant time or constant time.
09:18:46 <fasta> hyrax42: insert, update, delete, inspect
09:19:09 <fasta> hyrax42: I have never seen anyone implement it before.
09:19:17 <hyrax42> in haskell?
09:19:21 <fasta> hyrax42: in any language
09:19:24 <Cale> fasta: well, sort of
09:19:32 <fasta> Cale: "sort of"?
09:19:34 <int-e> fasta: so where do typical hash table implementations go wrong?
09:19:53 <Botje> :x
09:19:55 <Botje> ah bugger.
09:20:02 <fasta> int-e: they only provide probablistic bounds
09:20:22 <fasta> int-e: i.e. they provide E(O(1)) instead of O(1)
09:20:54 <hyrax42> can you actually have worst case O(1) for everything?
09:20:55 <fasta> probabilistic*
09:20:59 <hyrax42> seems insert would be problematic
09:21:03 <yshhq> @hoogle skipMany
09:21:04 <lambdabot> Text.ParserCombinators.ReadP.skipMany :: ReadP a -> ReadP ()
09:21:04 <lambdabot> Text.ParserCombinators.Parsec.Prim.skipMany :: GenParser tok st a -> GenParser tok st ()
09:21:04 <lambdabot> Text.ParserCombinators.ReadP.skipMany1 :: ReadP a -> ReadP ()
09:21:05 <Cale> Once you run out of buckets, things start tending to O(n), no?
09:21:14 <fasta> hyrax42: no, amortized worst case O(1) for some operations.
09:21:27 <int-e> Cale: you can resize the hashtable as needed - that works with amortized costs
09:21:35 <Cale> ah, okay
09:21:51 <fasta> Anyway, it would obsolete arrays from a software engineering point of view.
09:22:09 <int-e> doubt it. arrays are compact.
09:22:11 <fasta> The only excuse for real arrays is "performance".
09:22:23 <Cale> heh
09:22:26 <fasta> int-e: they have a constant space overhead
09:22:33 <int-e> constant factors do matter
09:22:34 <hyrax42> hashtable would still be 15-20 times worse I'd guess
09:22:36 <hyrax42> time-wise
09:22:40 <fasta> int-e: the hash tables I am talking about.
09:23:00 <int-e> fasta: I'd still like to know how you'd deal with hash collisions
09:23:01 <Cale> In fact, I suspect constant factors matter a whole lot more than asymptotic complexity here.
09:23:17 <Cale> (in most cases)
09:23:18 <hyrax42> Cale: yeah I would think so
09:23:29 <fasta> int-e: read the article (you can find it in the last discussion about hash tables)
09:23:35 <fasta> int-e: it's online.
09:23:38 <hyrax42> sort of on that, has anyone benchmarked Data.HashTable against Data.IntMap?
09:24:01 <int-e> fasta: when was that?
09:24:14 <fasta> int-e: Hmm, I will see whether I can find it.
09:24:25 <Cale> I don't know, but I'd basically never consider using Data.HashTable.
09:24:26 <hyrax42> fasta: last discussion where?
09:24:44 <Cale> The convenience penalty is way too high.
09:24:48 <hyrax42> Cale: because of IO ?
09:24:50 <Cale> yeah
09:25:09 <hyrax42> well what if there were a DiffTable or something is what I've wondered...
09:25:15 <hyrax42> saw someone mention it at some point
09:25:22 <balodja> q. there is a function 'search :: Graph v e -> Int -> Int -> Maybe [Int]', then functions declaration starts in the way 'search g@(Graph v1 e1) src dst | ...'(yaht). what's the meaning of '@' here?
09:25:25 <Cale> Also, Data.Set/Map have a really rich interface.
09:25:37 <hyrax42> this much is true
09:25:49 <Botje> balodja: it allows you to reference the whole Graph v1 e1
09:25:57 <Botje> for recursive calls
09:25:59 <Cale> balodja: g is bound to whatever (Graph v1 e1) matches
09:26:20 <fasta> hyrax42: in this channel
09:26:24 <int-e> > let y@(x:xs) = [1,2,3] in (y, x, xs)
09:26:25 <lambdabot>  ([1,2,3],1,[2,3])
09:26:40 <hyrax42> fasta: ah, that'll be hard to find
09:26:55 <Cale> This saves you from reconstructing that node. It would be interesting to know if GHC looked for things like that automatically.
09:28:02 <balodja> hm, thanks
09:29:49 <fasta> Hmm, Google isn't as good as I assumed.
09:30:12 <fasta> Well, probably it needs to make some smart choices as _what_ to index.
09:30:15 <hyrax42> the @ thing is one that isn't mentioned in a lot of the "getting started" stuff
09:30:48 <fasta> @where hashtables + http://wwwcs.uni-paderborn.de/fachbereich/AG/agmadh/PapersPostscript/DynamicPerfHashing_SICOMP.ps
09:30:49 <lambdabot> I know nothing about hashtables.
09:31:01 <allbery_b> "@where+ hashtables ..."
09:31:01 <Cale> I found out about @ when I read http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
09:31:01 <lambdabot> Title: Tour of the Haskell Syntax
09:31:13 <fasta> @where+ hashtables   http://wwwcs.uni-paderborn.de/fachbereich/AG/agmadh/PapersPostscript/DynamicPerfHashing_SICOMP.ps
09:31:13 <lambdabot> Done.
09:31:19 <psi> ?t drawTree
09:31:19 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:31:26 <psi> :t drawTree
09:31:26 <fasta> int-e: that's the article
09:31:28 <lambdabot> Tree String -> String
09:31:32 <balodja> so @ in g@(Graph v1 e1) allows to refer both to g and to v1, e1 separably?
09:31:42 <allbery_b> yes
09:31:44 <psi> why isn't is Show a => Tree a -> String or something?
09:31:45 <Cale> That was actually quite a ways into learning Haskell for me. I was surprised that there'd been a part of the syntax I'd somehow missed :)
09:34:12 <fasta> I wonder how many bugs there are in that article. Who wants to find out? :)
09:34:24 <hyrax42> Cale: yeah it's strange
09:34:38 <hyrax42> because often you want to reference the whole thing and end up building it up aagin
09:34:39 * sorear complains about the lack of parametric polymorphism in C
09:34:41 <hyrax42> takes way too much space
09:34:47 <Cale> sorear: hehe
09:34:53 <fasta> sorear: what's wrong with void * ?
09:35:34 <fasta> sorear: it's just a lot less convenient
09:35:38 <allbery_b> hm.  I caught on to @-expressions fairly early, but I started from _Gentle Introduction_
09:35:39 * sorear grabs his type safety, glares at fasta, and murmers "my precious"
09:36:13 <Cale> Actually, I'd been annoyed at Java for not having parametric polymorphism back when I was using it, and I didn't even know the term "parametric polymorphism" back then.
09:36:19 <balodja> fasta: making in all structures leading field that detemines the real type? :)
09:37:28 <kc5tja> sorear: You can emulate it with macros.
09:38:11 <allbery_b> hackros
09:38:15 <Cale> You can also emulate it with a Haskell compiler.
09:40:21 <kc5tja> allbery_b: Certain tools may not be convenient to use, but they can still be used.
09:41:15 <allbery_b> sure.  but cpp macros are a hack regardless.  (I thought so even when I was a C programmer)
09:44:43 <psi> i wish google would understand that Data.Tree means Data.Tree and not data Tree
09:45:46 <allbery_b> google code search?
09:45:58 <allbery_b> or that other code search thing (krugle?)
09:47:36 <LoganCapaldo> tried "Data.Tree" ?
09:48:28 <gh_> allbery_b: i believe exalead has a regexp search
09:48:37 <LoganCapaldo> eh "Data.Tree" gets the same results
09:49:13 <helahe> anyone smthg know about comparing binary trees?
09:50:28 <fasta> helahe: just dropping the words in a random order in the channel?
09:51:49 <psi> what the heck is Data.Tree anyway? rose trees? is that not a regular tree?
09:52:06 <hyrax42> > all id []
09:52:07 <sorear> rose, yes
09:52:07 <lambdabot>  True
09:52:21 <fasta> Multi-way trees (aka rose trees) and forests.
09:52:44 <psi> what does that mean?
09:52:58 <sorear> @src Tree
09:52:58 <lambdabot> Source not found. Where did you learn to type?
09:53:04 <hyrax42> data Tree a = Node a [a]
09:53:15 <hyrax42> I mean
09:53:16 <hyrax42> gah
09:53:19 <fasta> psi: find the source if you want details.
09:53:23 <hyrax42> Node a [Tree a]
09:53:31 <sorear> @source Data.Tree
09:53:31 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
09:53:33 <psi> hyrax42: ok
09:53:58 <fasta> sorear: it only finds stuff in base?
09:56:00 <chessguy> @source Tree
09:56:00 <lambdabot> Tree not available
09:56:19 <fasta> @source Data.HashTable
09:56:19 <lambdabot> http://darcs.haskell.org/packages/base/Data/HashTable.hs
09:56:43 <fasta> That must be it.
09:56:50 <chessguy> anybody heard of a module called IOExts?
09:57:05 <fasta> Yes
09:57:09 <chessguy> (non-standard)
09:57:15 <chessguy> fasta: know where i could get it?
09:57:30 <fasta> I think it's a Hugs thingie, but I don't remember well.
09:57:44 <chessguy> @go IOExts.hs
09:57:49 <lambdabot> http://www.arcknowledge.com/gmane.comp.lang.haskell.cvs.all/2003-02/msg00470.html
09:57:49 <lambdabot> Title: cvs commit: hugs98/libraries/Hugs IOExts.hs
09:57:53 <sorear> chessguy: you don't want it
09:58:19 <sorear> chessguy: it contains stuff like unsafePerformIO, and dates from the age when . was illegal in module names
09:58:34 <chessguy> sorear: i'm trying to run code that depends on it
09:58:54 <sorear> chessguy: anything which uses it is pretty obsolete, and will likely require a fullscale porting...
09:59:11 <chessguy> sorear: it's from HSOE
09:59:36 <sorear> any #ifdefs around the import?
09:59:45 <chessguy> no
10:00:16 <chessguy> @paste
10:00:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:00:29 <sorear> I'd delete the import line, try to compile,and add the modern import for each unresolved symbol
10:00:55 <hpaste>  chessguy pasted "Memoization module, dependent on IOExts" at http://hpaste.org/1007
10:01:52 <sorear> chessguy: delete it, and import Data.IORef and System.IO.Unsafe
10:02:41 <sorear> wait, that's not enough
10:03:04 <hyrax42> :t fromMaybe
10:03:05 <sorear> chessguy: you can try using reallyUnsafePtrEq from GHC.Prim
10:03:06 <lambdabot> forall a. a -> Maybe a -> a
10:07:34 <chessguy> ?hoogle unsafePtrEq
10:07:34 <lambdabot> No matches found
10:10:22 <sorear> @ty GHC.Prim.reallyUnsafePtrEq
10:10:24 <lambdabot> Not in scope: `GHC.Prim.reallyUnsafePtrEq'
10:10:29 <sorear> @ty GHC.Prim.reallyUnsafePointerEq
10:10:31 <lambdabot> Not in scope: `GHC.Prim.reallyUnsafePointerEq'
10:11:02 <sorear> @ty GHC.Prim.reallyUnsafePtrEquality#
10:11:04 <lambdabot> forall a. a -> a -> GHC.Prim.Int#
10:11:26 <sorear> @ty GHC.Prim.reallyUnsafePtrEquality# GHC.Prim./=# 0#
10:11:28 <lambdabot>     Couldn't match expected type `GHC.Prim.Int#'
10:11:28 <lambdabot>            against inferred type `a -> a -> GHC.Prim.Int#'
10:11:47 <sorear> @ty ((GHC.Prim./=# 0#) .) . GHC.Prim.reallyUnsafePtrEquality#
10:11:50 <lambdabot>     Couldn't match kind `*' against `#'
10:11:50 <lambdabot>     When matching the kinds of `b :: *' and `GHC.Prim.Int# :: #'
10:14:32 <chessguy> ?hoogle reallyUnsafePtrEq
10:14:33 <lambdabot> No matches found
10:15:29 <LoganCapaldo> completelySafePtrEq
10:15:35 <chessguy> so...what should i use there?
10:15:40 <chessguy> oh
10:15:45 <LoganCapaldo> isItSafePtrEq
10:15:49 <chessguy> ?hoogle completelySafePtrEq
10:15:49 <lambdabot> No matches found
10:15:55 <LoganCapaldo> I was kididng
10:15:57 <LoganCapaldo> sorry
10:16:33 <LoganCapaldo> noLifeGuardAtTheBeachPtrEq
10:16:37 <chessguy> ?hoogle reallyUnsafePtrEquality
10:16:38 <lambdabot> No matches found
10:16:46 <sorear> actually it's called reallyUnsafePtrEquality#, I was misremembering
10:16:55 <sorear> in GHC.Prim
10:17:08 <chessguy> do i need to import GHC.Prim?
10:17:10 <sorear> also look at System.Mem.Stable
10:17:10 <allbery_b> in any case I don' think hoogle does the # internal foo
10:17:31 * LoganCapaldo renames GHC.Prim to GHC.I.Am.Not.Portable.And.Possibly.Foolish
10:17:35 <sorear> S.M.S is a more portable interface
10:17:35 <LoganCapaldo> :)
10:18:02 <sorear> @docs System.Mem.StableName
10:18:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
10:18:12 <sorear> once again, memory error :(
10:18:31 <chessguy> Memo1.lhs:34:30: Not in scope: `#'
10:19:25 <allbery_b> you need some -f flag to make # legal n names
10:19:27 <allbery_b> *in
10:19:37 <allbery_b> -fglasgow-exts
10:19:37 <sorear> yeah, I think that's a relic from the pre-hier days
10:19:53 <sorear> it makes internal names unable to impinge on the h98 namespace
10:20:13 <chessguy> ugh, can i just skip the memoization?
10:20:21 <sorear> but, look at System.Mem.StableName - yhc doesn't do GHC.* :)
10:22:16 <chessguy> i don't particularly care about yhc. i'm running this code here, on GHC, for purely entertainment/educational purposes
10:24:23 <chessguy> ehhhh, screw memoization. it only memoizes the last call anyway
10:29:03 <emk> Heh. _why the luck stiff is my hero. :-)
10:31:13 <arcatan> my hero too o/
10:31:53 <sorear> hello cdsmith!
10:32:23 <gaal> hello. has anyone used mingw32 binary distros of 6.7 snapshots recently? I get lots of '$topdir' mentions in my package.conf that don't look right
10:32:52 <gaal> but 'make in-place' doesn't attempt to fix them up.
10:36:21 <Igloo> Does 6.6 fix them up?
10:37:59 <gaal> I've never tried a snapshot of 6.6... there's no mention of $topdir in the makefile at all
10:38:15 <Igloo> I mean the 6.6 release
10:38:31 <Igloo> Oh, that uses the installer, not a bindist, so might be different anyway
10:39:44 <gaal> oh: 6.6 binary dist has topdir in package.conf too!
10:39:53 <gaal> however, there's no lib/ dir there
10:40:31 <gaal> my actual error is:
10:40:31 <gaal> ghc.exe: Can't find package.conf as C:\apps\ghc\ghc-6.7.20070315.20070315\bin\i3
10:40:35 <gaal> 86-unknown-min\driver\package.conf.inplace
10:40:49 <gaal> during pugs ghc probing
10:41:56 <sorear> Haskell 98 question: is Prelude.(,) a legal name?
10:42:33 <sorear> asked too quickly, no, , is not a valid op cha
10:44:45 <gaal> (fwiw on linux I don't have this topdir business in my package.conf...)
10:50:11 <petekaz> is there a sprintf-like equiv in haskell?  I know there is a printf, but can I generate a string instead of output?
10:51:35 <LoganCapaldo> Printf is sprintf
10:51:46 <LoganCapaldo> its polymorphic in its return type
10:52:00 <LoganCapaldo> a :: String
10:52:04 <LoganCapaldo> a = Printf ...
10:52:20 <LoganCapaldo> (err IO String actually I think)
10:53:04 <LoganCapaldo> @hoogle printf
10:53:05 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
10:53:05 <lambdabot> Text.Printf :: module
10:53:05 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
10:53:21 <LoganCapaldo> @instances PrintfType
10:53:21 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
10:53:30 <LoganCapaldo> @instances-importing PrintfType
10:53:31 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
10:53:49 <sorear> > printf "%d" 200
10:53:49 <lambdabot>  Add a type signature
10:53:55 <sorear> > (printf "%d" 200) :: String
10:53:56 <lambdabot>  "200"
10:54:00 <sorear> > (printf "%d" 200) :: IO ()
10:54:02 <lambdabot>  <IO ()>
10:54:28 <diffbavis> (.text+0x2b99): undefined reference to `ControlziMonadziError_zdfMonadErrore_closure' <--- D:
10:54:31 <LoganCapaldo> its magic!
10:54:32 <sorear> diffbavis: --make
10:54:37 <diffbavis> sorear: thanks
10:55:03 <sorear> diffbavis: always use --make or ghci, unless you have special needs - it takes care of libs automagically
10:55:49 <sorear> diffbavis: that's a haskell mangles name btw for module Control.Monad.Error, (I think) MonadError dictionary objec
10:55:57 <sorear> diffbavis: so --make or -package mtlj
10:56:03 <sorear> s/mtlj/mtl/
10:56:35 <petekaz> LoganCapaldo: thanks.
10:57:04 <LoganCapaldo> petekaz: Thank sorear, he actually demonstrated how to get it to work :)
10:57:22 <petekaz> thanks to everyone :-)
10:58:11 <LoganCapaldo> > (printf "where are my %s dependent types?") :: String
10:58:12 <lambdabot>  Exception: Printf.printf: argument list ended prematurely
11:01:02 <chessguy> ?hoogle newchan
11:01:03 <lambdabot> Control.Concurrent.Chan.newChan :: IO (Chan a)
11:04:55 <chessguy> > (printf "where are my %s dependent types?","darn") :: String
11:04:56 <lambdabot>  Couldn't match expected type `String'
11:05:10 <chessguy> @type printf
11:05:12 <lambdabot> forall r. (PrintfType r) => String -> r
11:05:20 <LoganCapaldo> > (printf "Like this %s" "no comma") :: String
11:05:21 <lambdabot>  "Like this no comma"
11:06:50 <LoganCapaldo> > (printf "I guess printf arguments must be typeables %d" "hmm") :: String
11:06:51 <lambdabot>  Exception: Printf.printf: bad argument
11:08:21 <LoganCapaldo> > let a = 2; b = 3; sum = a + b in (printf "%d + %d = %d" a b sum) :: String
11:08:22 <lambdabot>  "2 + 3 = 5"
11:09:14 <LoganCapaldo> > (printf "a" 1 1 1 1 1) :: String
11:09:15 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
11:10:44 <LoganCapaldo> @doc PrintfType
11:10:44 <lambdabot> PrintfType not available
11:10:48 <LoganCapaldo> @doc Printf
11:10:49 <lambdabot> Printf not available
11:10:54 <LoganCapaldo> @index Printf
11:10:55 <lambdabot> bzzt
11:11:01 <LoganCapaldo> @source Printf
11:11:01 <lambdabot> Printf not available
11:11:28 <LoganCapaldo> @doc Text.Printf
11:11:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
11:12:39 <LoganCapaldo> Hmm, I take you are not supposed  make instances of printftype eh?
11:13:12 <sorear> LoganCapaldo: they don't have to be typeables, no
11:13:31 <sorear> LoganCapaldo: I suppose you could.  I don't think it would be very useful however
11:13:53 <LoganCapaldo> well just guessing based on the impl
11:13:57 <LoganCapaldo> err
11:14:00 <LoganCapaldo> interface not impl
11:14:13 <chessguy> ?hoogle RGB
11:14:13 <lambdabot> No matches found
11:14:28 <LoganCapaldo> but printf "%s" someCustomDatatype might work as long as you were clever about defining the instance
11:14:47 <LoganCapaldo> but I dunno
11:14:53 <LoganCapaldo> maybe it doesn't work liek I think it does
11:15:11 <LoganCapaldo> @source Text.Printf
11:15:11 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
11:15:40 <sorear> LoganCapaldo: it could work, but you're right, not enough is exported.
11:19:05 <LoganCapaldo> (IsChar c) => Printftype [c] looks sneaky
11:19:18 <LoganCapaldo> those sneaky haskell programmers
11:19:27 <petekaz> oooh .. I just used 'uncurry' the first time ever (I'm a newbie obviously) so I didn't have to unpack a tuple being passed to printf!
11:19:36 <cdsmith> @pl \x -> (x, f x)
11:19:36 <lambdabot> ap (,) f
11:23:03 <LoganCapaldo> @ty uncurry printf
11:23:05 <lambdabot> forall b c. (PrintfType (b -> c)) => (String, b) -> c
11:23:05 <shachaf> cdsmith: "id &&& f"
11:23:32 <LoganCapaldo> heh
11:24:00 <LoganCapaldo> I almost feel like the type class constraint is giving away a secret there
11:29:19 <cdsmith> shachaf: thanks
11:31:54 <sorear> @ty uncurry (printf "(%d, %d)")
11:31:56 <lambdabot> forall a b c. (PrintfType (a -> b -> c)) => (a, b) -> c
11:32:09 <sorear> tsk, tsk, bad ghci
11:32:17 <LoganCapaldo> I take it theres no way for me to force it to export things it doesn't want to
11:32:30 <sorear> darcs send :)
11:32:51 <sorear> uncurry (printf "(%d, %d)") :: (PrintfType c, PrintfArg b, PrintfArg a) => (a, b) -> c  -- much better
11:34:43 <LoganCapaldo> It would be nnice if there was an %S or %h or maybe %@ (to steal from Obj-C) for (Show a) => a
11:35:19 <LoganCapaldo> but I suspect that would require even more hackery of the (IsChar c) =>  kind to work
11:36:10 <sorear> worse - it would require undecidable instances
11:36:35 <sorear> and incoherent, come to think of it
11:36:52 <LoganCapaldo> incoherent. We don't anything incoherent
11:36:56 <LoganCapaldo> *want
11:37:02 <LoganCapaldo> that just wouldn't make sense
11:37:22 <chessguy> so...is there a modern way to implement http://hpaste.org/1007 ?
11:38:29 <LoganCapaldo> and wouldn't (printf "%s %@" a a) hit the monomorphism restriction as well?
11:50:13 <Nicu> ?hoogle unsafePerformIO
11:50:13 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
12:00:29 <chessguy> anybody know what the correct usage of reallyUnsafePtrEquality# is?
12:00:55 <jcreigh> is that a joke, or is that the name of a real function?
12:01:11 <Igloo> I don't think you're allowed to use "reallyUnsafePtrEquality#" and "correct" in the same sentence
12:01:14 <chessguy> that's the name of it
12:01:26 <chessguy> Igloo: i'm just trying to hack some ancient code to get it to work
12:01:41 <chessguy> i promise never to look at the code again :)
12:01:42 <LoganCapaldo> the joke function is safetyNotGuranteedPointerEq
12:02:27 <chessguy> it's code directly from HSOE, for pete's sake
12:02:37 <chessguy> i just want to be able to try the examples, and play with them
12:02:57 <LoganCapaldo> @type reallyUnsafePtrEquality#
12:03:00 <lambdabot> Not in scope: `reallyUnsafePtrEquality#'
12:03:53 <sorear> chessguy: http://research.microsoft.com/users/simonpj/Papers/weak.ps.gz
12:04:06 <sorear> chessguy: a full 20-page spjaper on the subject
12:04:37 <sorear> presenting as a worked example... a memo function!
12:04:48 * sorear continues reading it
12:04:58 <hpaste>  chessguy pasted "Almost working. Just need the correct syntax for reallyUnsafePtrEquality in inCache" at http://hpaste.org/1008
12:07:50 <yshhq> ?hoogle try
12:07:50 <lambdabot> IO.try :: IO a -> IO (Either IOError a)
12:07:50 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
12:07:50 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
12:09:23 <jcreigh> Some.ModuleNames.SeemReallyLongToMe.LikeTextDotParserCombinatorsDotParsec
12:10:24 <chessguy> sorear: he says his own code is a disaster in that paper, and never presents working code
12:11:39 <hpaste>  sorear annotated "Almost working. Just need the correct syntax for reallyUnsafePtrEquality in inCache" with "good luck" at http://hpaste.org/1008#a1
12:13:13 <chessguy> sorear++ thanks!
12:15:24 * chessguy puts the code away and hopes he never has to look at it again
12:16:38 <xerox> unsafeHidingCodeUnderTheRug#
12:19:52 <jacobian> :)
12:21:19 <chessguy> ?hoogle newchan
12:21:20 <lambdabot> Control.Concurrent.Chan.newChan :: IO (Chan a)
12:21:27 <abz> Has anyone got any suggestions for doing Haskell + SSL encryption? (point me towards some documation?)
12:22:31 <abz> documentation
12:22:55 <sorear> abz: there was a ml post on the subject v. recently
12:23:14 <abz> sorear: thanks, I'll go look
12:23:18 <sorear> http://haskell.org/pipermail/haskell-cafe/2007-March/023573.html
12:23:19 <lambdabot> Title: [Haskell-cafe] Haskell and SSL
12:24:46 <sorear> @where soc
12:24:46 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
12:25:01 <jacobian> the partial evaluation project looks fun
12:30:38 <abz> how do you search the haskell{,-cafe} mailing list threads?
12:30:49 <sorear> google
12:30:57 <abz> oh
12:31:28 <chessguy> woohoo!
12:31:38 * chessguy gets the "paddleball in 20 lines" example working
12:31:50 * sorear cheers
12:32:42 <chessguy> this code is badly un-maintained and disorganized
12:32:52 <chessguy> i'll have to re-release it once i've got it all cleaned up
12:33:03 <jcreigh> paddleball? pong?
12:33:25 <chessguy> jcreigh: yes, essentially
12:33:31 <chessguy> it's a very simple version
12:36:50 <toki20> hi
12:37:11 <sorear> hi!
12:37:29 <toki20> wassup here ?
12:37:43 <sorear> @topic-tell #haskell
12:37:43 <lambdabot> ["The Haskell programming language: what monads have you written?","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","
12:37:43 <lambdabot> The language of ICFP winners 3 years running"]
12:37:56 <sorear> it's a pl channel...
12:38:05 <toki20> what means pl ?
12:38:13 <sorear> programming language
12:38:18 <toki20> i know
12:41:53 <Shimei> By the way, does haskell.org have any guidelines for SoC proposals somewhere? Or is it basically free-form?
12:46:47 <chessguy> ?hoogle integral
12:46:48 <lambdabot> Prelude.Integral :: class (Real a, Enum a) => Integral a
12:46:48 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
12:53:05 <kc5tja> @src any
12:53:05 <lambdabot> any p =  or . map p
12:53:20 <kc5tja> @src or
12:53:20 <lambdabot> or    =  foldr (||) False
12:54:27 <yshhq> @src sum
12:54:27 <lambdabot> sum = foldl (+) 0
12:54:40 <yshhq> @src try
12:54:40 <lambdabot> try a = catch (a >>= \ v -> return (Right v)) (\e -> return (Left e))
12:54:59 <kc5tja> :t any
12:55:00 <yshhq> @hoogle try
12:55:01 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:55:01 <lambdabot> IO.try :: IO a -> IO (Either IOError a)
12:55:01 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
12:55:01 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
12:55:12 <yshhq> @src Text.ParserCombinators.Parsec.Prim.try
12:55:12 <lambdabot> Source not found. It can only be attributed to human error.
12:55:24 <yshhq> @src Text.try
12:55:24 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:55:29 <yshhq> @src try
12:55:29 <lambdabot> try a = catch (a >>= \ v -> return (Right v)) (\e -> return (Left e))
12:55:49 <yshhq> :t try
12:55:51 <lambdabot> Not in scope: `try'
12:56:37 <yshhq> @src Monad
12:56:37 <lambdabot> class  Monad m  where
12:56:38 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
12:56:38 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
12:56:38 <lambdabot>     return      :: a -> m a
12:56:38 <lambdabot>     fail        :: String -> m a
12:56:51 <yshhq> @src Arrows
12:56:51 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:56:54 <yshhq> @src Arrow
12:56:54 <lambdabot> class Arrow a where
12:56:55 <lambdabot>     arr, pure   :: (b -> c) -> a b c
12:56:55 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
12:56:55 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
12:56:55 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
12:56:56 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
12:56:58 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
12:57:59 <liquidengineer> Hello
12:58:45 <liquidengineer> How is everyone today?
12:59:31 <jcreigh> metaphorically rocking and rolling
12:59:43 <liquidengineer> awesome
12:59:51 <liquidengineer> is dons around?
12:59:58 <jcreigh> @seen dons
12:59:58 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 9h 13m 16s ago.
13:00:10 <liquidengineer> ah.
13:00:26 <liquidengineer> so he's normally on late at night/early in the morning?
13:00:35 <jcreigh> @localtime dons
13:00:36 <lambdabot> Local time for dons is Sun Mar 18 06:59:25 2007
13:01:08 <jcreigh> dons is in .au
13:01:40 <liquidengineer> lambdabot is awesome
13:01:56 <siti> it sure is
13:02:11 <liquidengineer> Is he written in Haskell?
13:02:16 <jcreigh> yup
13:03:44 <Toxaris> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:03:44 <lambdabot> Title: lambdabot
13:11:53 <emk> I've just finished writing all the code and drawing all the diagrams for a category theory tutorial.
13:11:57 <jcreigh> Houston, we have Xinerama
13:12:10 <liquidengineer> Xinerama?
13:12:18 <jcreigh> in xmonad, the Haskell window manager.
13:12:25 <emk> Now I just need to write the prose, finish the bibliography, etc. :-(
13:12:33 <jcreigh> (Xinerama is multi-head support in X11)
13:12:37 <kaol> @where xmonad
13:12:37 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
13:12:38 <liquidengineer> there's a haskell window manager?
13:12:47 <liquidengineer> wow
13:12:56 <jcreigh> I haven't sent my patches yet, so it's only in my repo
13:13:57 <jcreigh> now all we need is tiling, and we can mop the floor with dwm. :)
13:14:13 <ddarius> emk: So where is it?
13:14:38 <liquidengineer> dwm?
13:14:56 <ddarius> emk: Oh, I missed that other part.  Yeah, the prose tends to be the hard part.
13:15:02 <emk> ddarius: Not posted anywhere yet--I might put up a draft sometime this weekend for folks on #haskell if I make good progress.
13:15:38 <ddarius> emk: Where do you intend to disseminate it?
13:15:40 <emk> ddarius: Once I get the right motivating examples and overall structure, the prose isn't too bad.
13:16:17 <emk> ddarius: Well, this version will probably be on http://www.randomhacks.net/ with an accompanying PDF.
13:16:18 <lambdabot> Title: Random Hacks
13:16:37 <emk> I might add some content on monads and submit it to the Monad Reader later.
13:17:17 <jcreigh> @where dwm
13:17:17 <lambdabot> http://www.suckless.org/wiki/dwm
13:17:53 <jcreigh> liquidengineer: dwm is a very minimal WM for X11...xmonad is initially aimed at being a dwm workalike. (we're not quite there yet)
13:18:37 <balodja> is the (>>) function left associative or right?
13:19:21 <jcreigh> :i (>>_
13:19:23 <jcreigh> :i (>>)
13:19:25 <liquidengineer> jcreigh: what about performance?
13:19:26 <ddarius> balodja: If the monad obeys the monad laws, I don't think it actually matters semantically.
13:19:30 <liquidengineer> I assume it's compiled...
13:19:31 <jcreigh> ah, lambdabot doesn't do :i
13:19:46 <liquidengineer> what's :i
13:19:53 <jcreigh> liquidengineer: a command of ghci
13:19:54 <allbery_b> :info in ghci
13:19:55 <ddarius> but left
13:20:39 <emk> Typesetting categorical diagrams takes a while. :-(
13:20:48 <ddarius> emk: Using xypic?
13:20:54 <liquidengineer> info on what?
13:21:00 <liquidengineer> I know :t and :k
13:21:01 <jcreigh> liquidengineer: seems fast to me. I have an 800Mhz athlon PC...Firefox is always going to be the slowest thing I'm running.
13:21:08 <emk> ddarius: Yup. It produces gorgeous output, but it took a while to get used to it.
13:21:20 <liquidengineer> I just wish they'd stop making excuses and *fix* safari
13:22:03 <ddarius> emk: I played with it a few years ago and could make fairly nice diagrams fairly quickly.  I was using it again recently and was a bit rusty, but still it's pretty straightforward and compace.
13:22:22 <jcreigh> liquidengineer: :i gives the type and fixity declaration of a function
13:22:26 <chessguy> man i hate winter
13:22:36 <jcreigh> Prelude> :i ($)
13:22:36 <jcreigh> ($) :: (a -> b) -> a -> b       -- Defined in GHC.Base
13:22:36 <jcreigh> infixr 0 $
13:22:39 <emk> ddarius: Yeah, I had to figure out some semi-documented tricks for one or two of my diagrams, so it took a while.
13:23:02 <ddarius> I have a CT brutal introduction almost done, but I need to fix the typesetting and consider making it completely self-contained (and write that part out then).
13:23:18 <ddarius> emk: What were they doing? (the diagrams)
13:23:24 <jcreigh> so you can use :i whenever you're wondering whether some function is left or right associative, or whether it has higher precedence than some other function...
13:23:50 <liquidengineer> fixity?
13:24:07 * chessguy just dug out three cars that the snowplows plowed in
13:24:13 <liquidengineer> like, pre/in/post?
13:24:14 <emk> ddarius: I had some duplicate nodes on some of them, so I needed to figure out how to assign internal-only names. And there was also the matter of getting 'id' arrows to typeset nicely.
13:24:19 <liquidengineer> that's kinda cool.
13:25:23 <emk> ddarius: There's a really need for a category theory book which doesn't assume any prerequisites beyond basic function functional programming.
13:25:27 <chessguy> i think fixity is the priority, not where it's applied
13:25:32 <jcreigh> liquidengineer: you can set the precedence and left/right/non associativity of an infix function that you define using a "fixity declaration"
13:25:41 <chessguy> precedence, not priority
13:25:45 <emk> There are some lovely books out there already, but they assume grad-level algebra skills at a minimum.
13:25:54 <ddarius> emk: Barr and Wells lecture notes and related books may come close.
13:26:22 * Codex_ likes "Sets for mathematics". Great book.
13:26:29 <jcreigh> so infixr 0 $ sets ($) to be right-assocative with a predence of 0 (the lowest)
13:26:59 <ddarius> My intro is not geared at CS people and is more "pure" category theory, though it's mostly to illustrate less common tools and how to "do" category theory which is rather necessary for applications.
13:27:46 <ddarius> Currently though it assumes you are at the level of a basic understanding of natural transformations.
13:29:01 <emk> ddarius: Well, my tutorial covers objects, arrows, functors, natural transformations and duals, starting from very rudimentary knowledge of Haskell.
13:29:35 <jacobian> emk What do you like to use arrows for?
13:29:35 <emk> I'm concentrating on lots of examples that place Haskell and diagrams side-by-side.
13:29:44 <jacobian> I haven't really learned what they are yet, but I'm curious
13:29:46 <ddarius> Yeah, mine assumes you've read something like that before you use it. (albeit without the Haskell bias)
13:30:19 <emk> ddarius: Well, once mine is up, you're certainly welcome to point at it.
13:30:20 <ddarius> Mine's essentially about indexed (co)limits and Kan extensions.
13:30:54 <emk> jacobian: There are two kinds of arrows: Haskell arrows and category theory arrows. They're not exactly the same thing, but they are related.
13:31:00 <malcolmw> Shimei: student application guidelines for SoC at http://hackage.haskell.org/trac/wiki/StudApply
13:31:30 <liquidengineer> Ah.  The Core is on.
13:31:35 <liquidengineer> I love disaster movies...
13:31:38 <jacobian> By arrows in category theory, you mean in the "objects and arrows" sense?
13:32:03 <emk> jacobian: Yup. Where objects are (roughly speaking) types, and arrows are functions.
13:32:21 <jacobian> right
13:32:37 <emk> (The relationship of Haskell arrows to category theory: http://www.cs.ru.nl/~heunen/publications/2006/arrows/arrows.pdf )
13:32:47 <emk> (Not for the faint of heart.)
13:33:00 <malcolmw> http://hackage.haskell.org/trac/summer-of-code/wiki/StudApply
13:33:01 <lambdabot> Title: StudApply - Haskell.org Google Summer of Code - Trac
13:33:45 <jacobian> thanks emk
13:34:15 <jacobian> wow, it must be hard to get a soc
13:34:57 <emk> ddarius: Well, I'm looking forward to reading about filtered colimits. I know I need to understand them for some monad<->algebra connections, but I'm still totally in the dark.
13:35:20 <emk> So you have at least one eager reader looking forward to it!
13:35:45 <ddarius> emk: I don't really cover filtered colimits or monads in this.
13:36:17 <ddarius> It's more an ode to representability.
13:36:26 <emk> Oops, I misread. Well, I'm sure that I'll need to know about the indexed kind, too. :-)
13:37:06 <emk> ddarius: I have some good references on monad morphisms, but I don't quite have the background to read them yet.
13:38:14 <ddarius> emk: You know the quotation, "All Concepts are Kan Extensions", that applies equally well to indexed (co)limits and my paper demonstrates this and the quote.
13:38:38 <emk> ddarius: I haven't heard that one, actually.
13:39:18 <ddarius> It's the title of the last section of the chapter on Kan extensions (?) in MacLane's Category Theory for the Working Mathematician.
13:39:54 <merus> Yay Kan Extensions!
13:40:07 <merus> Wish I knew what they were, but the name is cool enough.
13:40:44 * merus wants a university that actually has CFTWM in its library. >:(
13:41:38 <Cheery> aww. :( IORef is cheating!
13:41:53 <hpaste>  jaredj pasted "can these be united?" at http://hpaste.org/1010
13:43:19 <Shimei> malcolmw: Thanks. :)
13:45:23 <LoganCapaldo> How do you mean 'united'?
13:46:14 <ddarius> jaredj: Instantiate, the latter to the Identity monad
13:46:54 <chessguy> if you don't specify an export list, does a module automatically not export operators?
13:47:12 <mauke> I think the default is to export everything
13:47:22 <chessguy> i thought so too
13:49:12 <chessguy> ok, it's working now. that was weird
13:49:41 <jaredj> ddarius: cool. uh, can i have a parameterized instance?
13:49:53 <jaredj> instance MJTree Identity a?
13:50:03 <hpaste>  LoganCapaldo annotated "can these be united?" with "Something like this perhaps?" at http://hpaste.org/1010#a1
13:50:16 <chessguy> emk: aren't you done yet? sheesh! we're all waiting
13:50:26 <emk> chessguy: :-)
13:50:35 <emk> Hey, quality takes time...
13:50:52 <chessguy> touche
13:50:53 <jaredj> whoa, MJTree can be a class and an instance?
13:51:20 <jaredj> or wait - those are just trivial default implementations right?
13:51:32 <ddarius> jaredj: I'm not sure exactly what you want, but from the looks of it you shouldn't need either the MJTree or JTree classes.
13:51:48 <jaredj> well -
13:52:19 <LoganCapaldo> what i just did was make  any JTree "automatically" an instance of MJTree
13:52:36 <LoganCapaldo> (for some monad)
13:52:45 <hpaste>  jaredj annotated "can these be united?" with "mjtree with application" at http://hpaste.org/1010#a2
13:52:47 <LoganCapaldo> I dunno if thats what you wnat :)
13:52:56 <jaredj> gyack, oops
13:53:39 <jaredj> i got confused by my file finder trying to do two things at once, (a) find files in a dir, (b) recurse into dirs, (c) recurse into only some dirs
13:54:14 <eddyp_> jaredj: that is three things
13:54:14 <jaredj> whenever i tried to make the "which dirs do i go into" function a parameter, i got it confused with the function recursing over dirs that i was writing
13:54:31 <jaredj> eddyp_: exactly :)
13:54:51 <jaredj> so i wrote the visitLeaves func, with getChildren, isLeaf and isBranch as params
13:54:57 <jaredj> then i pulled out those into the class
13:55:19 <jaredj> then, the actual functions to get those returned IO values so i had to make the MJTree
13:55:56 <jaredj> then i felt redundant, and even though i don't actually need to use the JTree i wanted to know if i could obtain it from the MJTree
13:56:00 <jaredj> *whew*
13:56:38 <Cale> The JTree code looks just like what you'll get if m is the Identity monad.
13:56:58 <Cale> So you could likely get it back using Control.Monad.Identity.
13:57:00 <jaredj> yes, and that's the critical piece i didn't know
13:57:13 <Uncountable> hm, what are iorefs good for?
13:57:28 <Uncountable> the only thing they can do that you can't do with ordinary values is you can send them into a function that will modify them from in there
13:57:32 <jaredj> but how do i write that JTree is an instance of MJTree, with m = Identity, but also a class, with a unknown at writing?
13:57:38 <Cale> Uncountable: Right.
13:57:47 <ddarius> Uncountable: Good question. What good is mutable state?
13:57:48 <Uncountable> but you might as well just return a new value and overwrite the old one, and count on garbage collection to throw away the old one
13:58:07 <jaredj> Uncountable: that gives some people the jitters?
13:58:23 <Uncountable> jaredj: relying on gc?
13:58:28 <Cale> Uncountable: They can be used like pointers in C.
13:58:30 <allbery_b> IORef = mutable global variable, very roughly
13:58:32 <jaredj> yes
13:58:36 <allbery_b> (pointer thereto)
13:58:38 <Cale> -global
13:59:14 <allbery_b> well, the variable is global, the pointer isn't necessarily :)
13:59:14 <Cale> Mutable variable, access to which must be explicitly passed around.
14:00:08 <ddarius> Mutable state can let you significantly decouple program fragments at the cost of making what coupling remains much more implicit.
14:00:14 <jcreigh> but can't you say "topLevelDecl = makeAnIORefSomehow"? (evil, I know)
14:00:29 <ddarius> jcreigh: Yes and no.
14:00:41 <Uncountable> hm, you must use unsafePerformIO for that, don't you?
14:00:52 <jcreigh> ddarius: does it involved the use of unsafeWorshipSatan? :)
14:00:53 <Uncountable> if not, you need to pass the ioref around everywhere
14:01:00 <ddarius> jcreigh: Yes
14:01:04 <jcreigh> ah
14:01:18 <Cale> One cool thing you can do (that would work slightly better with MVars) is pass one "end" of the IORef to some parts of the code and the other "end" to others. By that, I mean passing the action (readIORef r) and function (writeIORef r)
14:01:26 <ddarius> Otherwise you'd just end up with a IORef making IO action which would lead to many different IORefs instead of one shared one.
14:02:18 <Toxaris> one could use local definitions to avoid passing IORef's around
14:02:21 <Uncountable> Cale: can you give an example?
14:02:22 <Toxaris> sometimes :-)
14:02:22 <Cale> So you can give some parts of the code write-only, and some parts read-only access to the ref.
14:02:39 <Uncountable> okay
14:02:57 <Cale> It's more sensible to do with MVars and threads.
14:03:04 <Toxaris> what are MVars?
14:03:04 <chessguy> ?remember jcreigh does it involved the use of unsafeWorshipSatan?
14:03:04 <Uncountable> what are MVars?
14:03:05 <lambdabot> Done.
14:03:07 <Uncountable> haha
14:03:27 <Uncountable> MultithreadedVars?
14:03:31 <Cale> yeah
14:03:35 <chessguy> @quote surround
14:03:35 <lambdabot> No quotes match. My mind is going. I can feel it.
14:03:41 <jcreigh> @quote stereo
14:03:41 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
14:03:46 <Cale> An MVar can be empty or full.
14:03:53 <Uncountable> "M" is used quite a lot in haskell identifiers :)
14:04:04 <Cale> If it's empty, attempting to read from it will cause your thread to block.
14:04:19 <Cale> If it's full, attempting to write to it will also.
14:04:39 <Toxaris> communicating channels with buffersize == 1?
14:04:55 <chessguy> hm, Cale's quote needs modifying. sometimes they're *asked* in stero too
14:05:14 <Cale> Toxaris: yeah
14:05:22 <Cale> The normal way of reading a value from an MVar will also empty it.
14:05:23 <jaredj> what's the M for in MVar
14:05:28 <Cale> Mutable, actually
14:05:36 <Cale> (I think)
14:05:51 <jaredj> ;)
14:05:52 <Cale> The name comes from an ML library, if memory serves me.
14:06:05 <allbery_b> hm, I thought from its behavior that it was a mutex
14:06:18 <jaredj> woohoo my file finder works!
14:06:30 <jaredj> and i understand what the heck it's doing!
14:06:37 <Cale> Well, in any event, there are lots of good things for that M to stand for :)
14:06:42 <Toxaris> it's like rendez-vous channels in promela :-)
14:06:48 <jcreigh> Multipurpose
14:06:52 <Toxaris> (are rather sounds like it -- what do i know)
14:07:11 <chessguy> at least it's not Monad, like most M-words in haskell
14:07:26 <Cale> http://cml.cs.uchicago.edu/pages/sync-var.html
14:07:27 <lambdabot> Title: The SyncVar structure
14:08:04 <Cale> It's M-variable in that sense :)
14:08:25 <jaredj> bahahaha
14:08:35 <jaredj>  mVar ()
14:08:36 <jaredj>     creates a new empty M-variable.
14:09:03 <jaredj> ah - There are two kinds of synchronous variables: I-variables are write-once, while M-variables are mutable.
14:10:43 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
14:10:45 <lambdabot> http://tinyurl.com/2ykhtj
14:10:57 <Cale> I should link to that as well, given that we're actually discussing Haskell :)
14:11:47 <Cale> MVars alone are actually not so terrible a foundation for concurrency (but one can do better)
14:12:22 <chessguy> anyone worth their weight in snot was already on that site anyway :)
14:14:32 <ddarius> They are used to make channels and channels are fun.
14:17:09 <jaredj> channels are cool. Limbo has channels
14:17:22 <jaredj> i think Limbo is what Java should have been
14:17:25 <oren> dons: Well, I tried... and failed :-) I have a core problem which holds for both Monads and Arrows even. I can't short-circuit
14:18:44 <oren> If I want to combine two functions, both of which are basically a->a, and I want to avoid calling the 2nd one at all under some condition... then neither Monads nor arrows let me do that, because they all assume to combine a->b and b->c, so I get a type error
14:19:15 <oren> Is there any way to define a Monad/Arrow where >>= or >>> skip evaluating the 2nd function?
14:19:45 <dmwit> oren: Use Maybe?
14:20:01 <oren> How would that work?
14:20:11 <dmwit> oren: Sorry, I meant mplus.
14:20:20 <allbery_b> @src Maybe (>>=)
14:20:20 <oren> I guess it would work if I was illing to give up on the result....
14:20:20 <lambdabot> (Just x) >>= k      = k x
14:20:20 <lambdabot> Nothing  >>= _      = Nothing
14:20:26 <dmwit> > (Just 3) `mplus` (Just 1)
14:20:28 <lambdabot>  Just 3
14:20:34 <dmwit> > (Nothing) `mplus` (Just 1)
14:20:36 <lambdabot>  Just 1
14:20:59 <jaredj> woohoo, finding with min and max depths!
14:21:03 <dmwit> :t msum
14:21:05 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
14:21:20 <dmwit> That returns the first "Just" from a list.
14:22:20 <oren> dmwit: Thanks! I'll look into MonadPlus then.
14:22:21 <Cale> oren: huh? How is that not possible with monads?
14:22:36 <oren> Seems I need MonadPlus instead of a generic one
14:22:45 <Cale> Do you mean that you have two computations of type  a -> m a ?
14:23:19 <dmwit> :t when
14:23:21 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:23:21 <oren> Cale: Yes (at least I can cast them in this form)
14:23:28 <Cale> Let's call those f and g, and you only want to follow f with g in the event that p :: a -> Bool applies to the result.
14:23:28 <dolio> ?src ap
14:23:28 <lambdabot> ap = liftM2 id
14:24:16 <oren> Exactly
14:24:21 <Cale> composeWhen f g p x = do { y <- f x; if p y then g y else return y }
14:24:43 <Cale> @type let composeWhen f g p x = do { y <- f x; if p y then g y else return y } in composeWhen
14:24:45 <oren> Hmmm....
14:24:46 <lambdabot> forall t (t1 :: * -> *) t2. (Monad t1) => (t -> t1 t2) -> (t2 -> t1 t2) -> (t2 -> Bool) -> t -> t1 t2
14:25:00 <oren> I see. Makes sense.....
14:25:09 <oren> I'll give it a try
14:25:10 <Cale> haha, silly choices of type variables there
14:25:24 <dmwit> oren: But if they are not Monads, you can do it with an if/then/else even more easily.
14:25:44 <Cale> oh, that's a good idea to point out
14:25:49 <oren> dmwit: True, I actually have the code in non-Monad form and am trying to re-cast it as a monad
14:26:01 <dmwit> composeWhen f g p x = let y = f x in if p y then g y else y
14:26:16 <oren> Cale is right, I can do it in a separate function isntead of the bind itself, Makes more sense
14:26:35 <Cale> Essentially, you're just changing the function that you're binding to, a bit.
14:26:38 <oren> Although I want it to "always" happen, it is part of the basic behavior
14:26:50 <Cale> ah
14:27:10 <Cale> So you might want to give this operation a terser name, and specify p.
14:27:30 <oren> Ideally I want do { a; b } to do it automatically
14:27:41 <Cale> That's unlikely.
14:27:44 <oren> I meant do { f; g } of course :-)
14:27:59 <dmwit> You might be able to get f .? g to do it, though.
14:28:07 <oren> Right
14:28:19 <dmwit> Hum.
14:28:22 <dmwit> Definitely in a monad, though.
14:28:29 <oren> Wouldn't MonadPlus help me out here?
14:28:46 <Cale> Well, it might, but you may have to turn your algorithm on its side.
14:28:48 <dmwit> Kind of, but (>>=) /= mplus
14:29:16 <oren> dmwit: Oh :-(
14:29:20 <oren> Cale: How so?
14:29:35 <Cale> Well, the way you'd approach it is to use nondeterminism.
14:29:49 <oren> ?
14:30:48 <dmwit> oren: He means the list monad. ;-)
14:30:56 <oren> Ouch
14:31:09 <Cale> yeah, I'm just trying to work out exactly which operations you'd use
14:31:10 <dmwit> You can view a function of type a -> [b] as one that takes an "a" and returns many possible "b"s.
14:31:27 <chessguy> hmm, this is all much like emk's last blog
14:31:37 <chessguy> ?go monads in 15 minutes
14:31:39 <lambdabot> http://www.dzone.com/rsslinks/monads_in_15_minutes_backtracking_and_maybe.html
14:31:39 <lambdabot> Title: Monads in 15 minutes: Backtracking and Maybe
14:32:21 <dmwit> :t when
14:32:23 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:32:50 <dmwit> ?src when
14:32:50 <lambdabot> when p s = if p then s else return ()
14:32:58 <dmwit> Ah, there has to be a default.
14:33:02 <Cale> not quite what we're looking for
14:33:17 <dmwit> Cale: I was hoping it would be Bool -> m a -> m a
14:33:20 <Cale> guard is closer
14:33:31 <Cale> but still doesn't return a useful value
14:33:56 <dmwit> :t fail
14:33:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
14:34:06 <Cale> We're actually looking for the old version of filter
14:34:13 <dmwit> when_ p s = if p then s else fail "no s" -- ?
14:34:17 <Cale> ugh, no
14:34:17 <Toxaris> is the job to define a short-circuiting monad or to use a monad in a short-circuiting way?
14:34:23 <Cale> use mzero at least
14:34:25 <Toxaris> or did i miss some code / context
14:34:30 <Cale> at which point you have guard
14:34:34 <Cale> @src guard
14:34:35 <lambdabot> guard True  =  return ()
14:34:35 <jaredj> i used a key in a short-circuiting way once
14:34:35 <lambdabot> guard False =  mzero
14:34:37 <dmwit> Oh, right.
14:34:50 <oren> Toxaris: The former (defining a short-circuiting monad)
14:35:03 <Cale> well, actually, I think the latter :)
14:35:17 <oren> Well... that's wnat I'm looking for :-)
14:35:24 <Cale> You're not going to construct a monad which looks at the results of computations to decide to run the rest.
14:35:42 <Cale> Monads just can't do that, because they'd break the monad laws.
14:35:53 <oren> Yes, that's what I figured
14:36:04 <oren> I hoped arrows would help but they have the same limitation
14:36:48 <oren> I could just stick with non-mandic code, it isn't that bad actually
14:36:56 <oren> What with defining my own operators
14:37:03 <Cale> yeah
14:37:23 <Cale> Monads and arrows are something which fall out of some combinator libraries, but they aren't universal :)
14:37:36 <LoganCapaldo> well why not, gosh darn it?
14:37:57 <dmwit> Cale: Where's your monad evangelism??
14:37:58 <Cale> Because useful abstractions restrict what you can do with them in some way.
14:37:59 <oren> I'm actually trying to create a streaming (lazy) parser, one that generates results incrementally
14:38:08 <Cale> That's where the meaning of the abstraction lies.
14:38:15 <oren> So I need a way to not look at parsing choices that are irrelevant
14:38:29 <LoganCapaldo> Hey, could you create a Comonad that looked at the result of computations to decide to run the rest?
14:38:33 <oren> That is, short-circuit them away
14:38:36 <Cale> Have you looked at existing parser combinator libraries?
14:38:42 <Toxaris> of course monads can't react on contained values, because they have to work for all types of values
14:38:43 <ddarius> oren: Each monadic action needs to "apply the predicate" itself and determine whether or not to return a result.
14:38:54 <Cale> There are Arrow-based combinator libraries which do that.
14:38:56 <ddarius> The end result would be something like Maybe, List, or NonDet
14:38:56 <Toxaris> so we don't have to talk about monads laws to see this
14:39:07 <oren> Yeah, they all insist on fully parsing the whole input because they return an error (Either)
14:39:13 <oren> Which kills being incremental
14:39:19 <Cale> Toxaris: right, naturality gives us that.
14:39:33 <oren> naturality?
14:39:34 <jaredj> lol, m a -> (a -> m b) -> m b, it's not just a good idea, IT'S THE LAW
14:40:30 <Cale> oren: essentially, the fact that the 'a' and 'b' in that type are type variables, and so return and bind can't vary their behaviour based on them
14:40:44 <Cale> (well, also in the signature for return)
14:41:14 <oren> Is there no nice syntax for m a -> (a -> m a) -> m a ? :-(
14:41:19 <Cale> Really, there's a category-theoretic definition, but this is essentially what it amounts to.
14:41:29 <jaredj> oren: b doesn't have to /= a
14:41:45 <oren> But in my case it is and I want to make use of the fact....
14:41:48 <jaredj> ah
14:42:02 <oren> That's the point, I can't "restrict" a Monad to only apply is a = b
14:42:11 <oren> It insists that they might be different
14:42:20 <allbery_b> there was something on -cafe about using TH to define magic syntax for restricted monads recently...
14:42:22 <Cale> Yeah, it's not worth struggling to shoehorn things so you get do-notation.
14:42:40 <Cale> You can get quite nice looking code by choosing appropriate infix operators.
14:42:46 <oren> Exactly
14:42:52 <ddarius> If a == b then you wouldn't have a monad.
14:42:53 <oren> Which is what I'll go back to doing :-)
14:42:56 <allbery_b> restricted "monads" that is, since hey're not
14:43:05 <Cale> But look at the arrow-based parsing libraries
14:43:06 <oren> Thanks guys, that has been a lot of help
14:43:18 <Cale> Because there are Arrow libraries (like PArrows) which do what you want.
14:43:25 <Cale> (I think)
14:43:34 <oren> Hmmm... (looking)
14:43:50 <ddarius> If (>>=) :: m a -> (a -> m a)
14:44:03 <Cale>          -> m a
14:44:14 <ddarius> If (>>=) :: Monad m => m a -> (a -> m a) -> m a then join = (>>= id) would not type check.
14:44:35 <Cale> right
14:44:51 <Cale> which would be quite sad
14:44:55 <oren> Naw, PArrows also parses the whole world before returning anything. Sigh. Nobody in Haskell ever parses 7MB files???
14:45:29 <ddarius> That said, if you were to use a different category then you probably could get a monad that would work, but that doesn't help you too much for Haskell.
14:45:44 <LoganCapaldo> I vaguely recall that the packrat combinator lib (not Pappy) wass really lazy
14:45:54 <LoganCapaldo> or claimed to be really lazy
14:46:02 <lucca> is parsec lazy?
14:46:26 <Cale> Well, Parsec and PArrows will do their best not to hold on to the beginning of the input string.
14:46:38 <ddarius> Few combinator parsers should need to parse the whole input if they hit a parse error.  The rest should not have such space leaks.
14:46:46 <Cale> But yeah, they don't return results lazily as they parse.
14:47:00 <Cale> Because there may be a parse error up ahead.
14:47:23 <oren> Cale: Exactly! I'm happy to get a partial parse tree with an error node.
14:47:36 <oren> And no parser lib I've seen so far does that :-(
14:47:46 <Cale> I also think you're going to pay a penalty in terms of nondeterminism if you don't have explicit failure.
14:47:56 <Cale> How do you decide if the first option failed to parse?
14:48:04 <lucca> hm
14:48:11 <Vq^> is there some way to alter that? to construct a parser for a commandline like interface?
14:48:12 <LoganCapaldo> "PEG parsers can deal with infinite input, acting in a streaming manner"
14:48:17 <Vq^> (with parsec that is)
14:48:19 <LoganCapaldo> http://repetae.net/computer/frisby/
14:48:19 <Cale> I think what you're really looking for is a lexing library.
14:48:33 <Toxaris> parsec uses explicit choice points anyway
14:49:13 <oren> The problem is I need the full power of context-free-languages
14:49:31 <oren> If PEG actually does that, frisby may be the solution... looking...
14:50:15 <LoganCapaldo> I don't know if theres a proof that PEGs can parse an CFG but intuitively it seems correct
14:50:26 <LoganCapaldo> if you google for packrat parsers you can find the papers
14:50:31 <Cale> Hmm...
14:50:36 <LoganCapaldo> err express
14:50:40 <LoganCapaldo> not parse
14:50:54 <LoganCapaldo> and by an I of course mean any
14:50:57 <Cale> I suppose you could do partial ability to stream, depending on what the actual language looks like.
14:51:06 <Cale> If it looks like XML, the close tags will kill you.
14:51:43 <Cale> Because you're always going to have to parse the whole thing to know if the first node of the tree is even valid.
14:52:04 <oren> Depends on the structure of the parse tree you are generating. With a little imagination it can be made easily streamable
14:52:13 <Toxaris> fuzzy parsing: there could be a valid node here
14:52:35 <oren> Again, its OK to get "here's an XML element" and then get an error somewhere inside it, as an explicit error DOM pseudo-node
14:52:45 <oren> Even if parsing terminates at that point its OK
14:53:27 <Cale> hmm
14:53:29 <jcreigh> that seems really hard to do...if there was something sensible to do with a parse error, it wouldn't be a parse error, it'd be part of the syntax.
14:53:39 <Toxaris> so given <a><b>text</b></c> you would like to get [B "text", Error "expected /a"]
14:53:48 <oren> Yes!
14:54:09 <ddarius> You can leave aspects of parse checking to a higher level, e.g. returning startTag endTag things and not worrying to much about matching them.
14:54:20 <oren> I'm not being a purist here. One can claim every syntax implicitly defines the rest of the inputs as "errors" and the result accepts every input. Fine... who cares :-)
14:54:42 <Cale> Well, perhaps Node "a" [Node "b" [Text "text"], Error "Expected </a>"]
14:54:54 <LoganCapaldo> Isn't that what the stream style / event based xml parsers do?
14:55:01 <LoganCapaldo> you don't get a dom
14:55:08 <ddarius> LoganCapaldo: Yes
14:55:09 * sorear is having fun parsing unary minus and n+k patterns
14:55:12 <LoganCapaldo> you just get opened "a', closed 'b' events
14:55:14 <oren> You get a DOM+errors
14:55:37 <oren> So the a element contains an error and is terminated at that point
14:55:42 <sorear> error recovery is an exciting field
14:55:44 <LoganCapaldo> So oren, are you parsing XML specifically, or you just want to generalize this concept?
14:55:50 <oren> Small price to pay for being able to parse 100M XMl files :-)
14:55:54 * sorear is writing a error correcting haskell parser!
14:56:13 <ddarius> Anyways, to get error checking and streaming you need to push the errors into the result as opposed to returning either an error or a result.
14:56:17 <oren> I'm not looking to invent a new Haskell parsing library if that's the question :-)
14:56:29 <ddarius> @oldwiki TyingTheKnot has something like this at the end.
14:56:29 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot has something like this at the end.
14:56:43 <Cale> Well, you could explicitly translate your grammar so that it reflects this possibility.
14:56:54 <ddarius> sorear: Swierstra has some error correcting parser combinators.
14:57:24 <ddarius> @google Error correcting parsers Swierstra Haskell
14:57:26 <sorear> ddarius: parser combinators are quite nice
14:57:27 <lambdabot> http://www.cs.uu.nl/~doaitse/Papers/1999/SofSem99.pdf
14:57:33 <sorear> (and I've seen the paper)
14:57:51 <sorear> but my requirements list for this project includes "faster than hugs"
14:58:21 <oren> Yeah, I'm definitely using DLists for this!
14:58:51 <ddarius> oren: Okay...
15:00:24 <Cale> DLists?
15:00:40 <sorear> [a] -> [a]
15:00:44 <oren> Difference lists
15:00:50 <Cheery> What is Graphics.Rendering.OpenGL.GL.StateVar and where do I get such?
15:00:53 <Cale> okay
15:00:56 <sorear> dunno what they're good for here
15:01:05 <sorear> Cheery: like the lighting mode
15:01:18 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html
15:01:19 <sorear> ChanServ: you set them with ($=), which is like IORef
15:01:20 <lambdabot> http://tinyurl.com/24hd3h
15:01:41 <Cale> It's a module in the libraries which come with GHC
15:01:48 <sorear> s/IORef/writeIORef/
15:02:22 <Cale> Seems kind of crazy that that's under OpenGL.
15:02:40 <Cale> Nothing in it has the slightest bit to do with OpenGL.
15:04:22 <Cheery> well, how do I satisfy something like: clearColor :: StateVar (Color4 GLclampf)  ?
15:05:12 <Toxaris> about the parsing
15:05:17 <kc5tja> :t stdIn
15:05:19 <lambdabot> Not in scope: `stdIn'
15:05:22 <kc5tja> :t stdin
15:05:24 <lambdabot> Not in scope: `stdin'
15:05:29 <kc5tja> @hoogle stdin
15:05:29 <Toxaris> what about keeping something like a error checking continuation in the monad
15:05:29 <lambdabot> IO.stdin :: Handle
15:05:41 <Toxaris> a stack of predicates or whatever
15:05:58 <Toxaris> which is appendable by some monadic action
15:06:09 <Toxaris> and gets applied transformed by bind
15:06:17 <Toxaris> and somehow magically applied at the right spot in the future
15:06:55 <Cheery> oh! now I got it. :)
15:06:58 <Cale> Cheery: hmm, I haven't used the library myself, so there might be a far simpler way which I am overlooking
15:07:04 <Cale> but makeStateVar would do it
15:07:24 <sorear> Cheery: you mean set it?
15:07:25 <Toxaris> so you could write parseNode = do char '<'; name <- identifer; expectLater "</" ++ identifer ++ ">"; return Node name
15:07:25 <Cheery> clearColor $= Color4 0.0 0.0 1.0 0.0
15:07:46 <Cale> ah, you just want to assign to an existing clearColor
15:07:58 <Cale> Not make an entirely new one :)
15:08:54 <Cheery> well, I don't know why would I want to make an entirely new one.
15:08:54 <Cheery> :P
15:09:02 <LoganCapaldo> Toxaris: you can do that example with Parsec though...
15:09:26 <Cheery> haskell documentation is weirdly categorized.
15:09:49 <LoganCapaldo> hooray for context sensitive parsing
15:10:47 <Cale> Cheery: yeah, it's just that I don't know the expected context, since I've never actually used the OpenGL library.
15:11:26 <Cale> The initial thing to guess when you say you want a (clearColor :: StateVar (Color4 GLclampf)) is that you don't already have one :)
15:12:23 <Cheery> But now when you mentioned it, these are similar to haskell IORefs?
15:12:46 <Cale> It's a general wrapper around IORef-like things.
15:13:21 <Cale> When you call makeStateVar :: IO a -> (a -> IO ()) -> StateVar a
15:13:39 <Cale> you could pass in  (readIORef r) and (writeIORef r)
15:14:00 <Cale> or any two other suitable functions for reading and writing a mutable value somewhere
15:14:27 <Cheery> I see...
15:14:38 <Cale> For instance, it could be some value in a mutable array, or an MVar
15:15:30 <Cheery> I find IORefs annoying from some reason.
15:15:53 <Cale> They are somewhat annoying, intentionally.
15:16:07 <Cale> They're intended to be used sparingly.
15:16:37 <Cheery> why sparingly?
15:16:49 <ddarius> 'cause this is Haskell
15:16:55 <Cale> because mutable state is bad
15:17:27 <astrolabe> I s'pose they are 'proper' global variables
15:17:40 <ddarius> There is nothing global about them.
15:17:42 <Cale> It's sometimes just what you need, but you really want to carefully consider each bit of it, to see that you can't do things in some better way.
15:17:55 <Cale> So rather than having C-like syntax where pointer dereferencing takes one character, we have readIORef
15:18:17 <Cale> because it's supposed to stand out
15:18:28 <ddarius> let (* ref) = readIORef ref
15:18:28 <astrolabe> ddarius: no?
15:18:29 <Cale> (there could be bugs here!)
15:19:04 <LoganCapaldo> > (!)
15:19:05 <lambdabot>  Add a type signature
15:19:10 <Cale> Mutable state is in some sense, the source of most bugs.
15:19:13 <LoganCapaldo> @type (!)
15:19:16 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
15:19:20 <LoganCapaldo> drat
15:19:27 <allbery_b> naturally I'm using them in my latest code :/
15:19:27 <LoganCapaldo> can't turn Haskell into ML :)
15:19:47 <ddarius> astrolabe: It's actually difficult to make them available in the top-level environment.  They are usually made locally within some IO action and then semi-implicitly passed throughout the code.
15:20:12 <ddarius> LoganCapaldo: You can easily hide, (!).
15:20:34 <LoganCapaldo> Yeah but then you are SOL when it comes to arrays. its lose lose
15:20:49 <astrolabe> ddarius: Ah, yes you are right.
15:20:50 <Cheery> I don't find them too annoying by usage.
15:20:54 <Cheery> I think they are annoying because they allow one to 'loophole' around design issues in their code.
15:21:02 <ddarius> LoganCapaldo: You could hide (!) and replace it with a class method.
15:21:07 <Cale> Heh, if you want to be really horrifically evil, use getStdGen and setStdGen to pass values around your code.
15:21:39 <Cale> Cheery: oh, so you're taking an even harder line than me on this. Sure. ;)
15:21:47 <Shimei> ?hoogle skipLine
15:21:47 <lambdabot> No matches found
15:21:57 <LoganCapaldo> @type getStdGen
15:21:59 <lambdabot> IO StdGen
15:22:10 <ddarius> @src StdGen
15:22:10 <lambdabot> Source not found. Are you on drugs?
15:22:16 <Cale> haha
15:22:22 <LoganCapaldo> @type setStdGen
15:22:25 <lambdabot> StdGen -> IO ()
15:22:28 <Cale> @type mkStdGen
15:22:31 <lambdabot> Int -> StdGen
15:22:58 <LoganCapaldo> How much info can you encode into an int though?
15:23:01 <ddarius> Cale: You are rather limited in what values you could pass around in a StdGen.
15:23:05 <LoganCapaldo> (dont answer that)
15:23:05 <Cale> not a whole lot
15:23:13 <ddarius> If it were an Integer, you'd be set.
15:23:14 <LoganCapaldo> its not liek you can cast it to a pointer...
15:23:18 <Cheery> Cale: Well, since lambda calculus can express any structure, even IORefs themselves, there's a secret in making it do so.
15:23:23 <jcreigh> Ints are at least 29 bits, IIRC
15:23:54 <Cale> 29 bits sounds like the name of an extremely nerdy blues tune.
15:23:57 <Cheery> But if people loophole through the things I'm interested about, it means I have no hope of finding stuff I'm interested about in code.
15:24:44 <Cale> Maybe we could even get Tom Waits to sing it.
15:24:52 <ddarius> @where E
15:24:53 <lambdabot> I know nothing about e.
15:25:00 <ddarius> @where+ E www.erights.org
15:25:01 <lambdabot> Done.
15:25:12 <kc5tja> @hoogle errors
15:25:12 <lambdabot> Test.HUnit.Base.errors :: Counts -> Int
15:25:12 <lambdabot> Control.Exception.ioErrors :: Exception -> Maybe IOError
15:25:12 <lambdabot> Control.Exception.userErrors :: Exception -> Maybe String
15:25:32 <LoganCapaldo> I hate that whole chop off some bits for tags thing
15:25:50 <jcreigh> LoganCapaldo: why?
15:26:02 <LoganCapaldo> In my lame "lisp" interpreter you get as many bits as the machine gives you
15:26:13 <LoganCapaldo> and you get extra bits for all the tag info ;)
15:26:44 <jcreigh> LoganCapaldo: so all your ints are boxed?
15:26:52 <LoganCapaldo> painfully so
15:27:06 <Cale> > (\[x,y] -> x - y) . map read . words . show $ mkStdGen 5714892
15:27:07 <lambdabot>  5714892
15:27:10 * kpreid blinks
15:27:28 <Cheery> good night
15:27:40 <dmwit> > show $ mkStdGen 5714892
15:27:41 <lambdabot>  "5714893 1"
15:27:53 <dmwit> > show $ mkStdGen 571
15:27:54 <lambdabot>  "572 1"
15:28:19 <Cheery> tomorrow we'll hopefully see some spirals and circles with a bunch of verlet physics. ;)
15:28:37 <Cale> interestingly, negative seeds get sent to the same thing as the corresponding positive ones
15:29:01 <Cale> > let abs = (\[x,y] -> x - y) . map read . words . show in map abs [-10..10]
15:29:03 <lambdabot>   Non-exhaustive patterns in lambda
15:29:08 <Cale> oh, hmm :)
15:29:23 <Cale> er, oh
15:29:29 <Cale> > let abs = (\[x,y] -> x - y) . map read . words . show . mkStdGen in map abs [-10..10]
15:29:31 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9,10]
15:29:35 <Cale> heh
15:29:38 <kc5tja>   let (options, files, errors) = CutOptions.lists argv
15:29:44 <Cale> So stupid :)
15:29:48 <kc5tja>   if errors /= []
15:29:56 <kc5tja> Why is the above a parse error?
15:30:09 <sorear> kc5tja: is this in a do-block?
15:30:15 <kc5tja> Yes
15:30:24 <sorear> kc5tja: what's the next line?
15:30:24 <Cale> uh, the if has no then or else :)
15:30:33 <kc5tja> And, the then and else clauses are indented too.
15:30:59 <kc5tja>   if errors /= []
15:30:59 <kc5tja>    then putErrors errors
15:30:59 <kc5tja>    else
15:30:59 <kc5tja>     if CutOptions.HelpRequested `elem` options
15:31:01 <kc5tja> ...
15:31:20 <LoganCapaldo> then can't be on the same level as if
15:31:27 <LoganCapaldo> it has to be indented
15:31:30 <sorear> LoganCapaldo: fix your font
15:31:30 <LoganCapaldo> if e
15:31:31 <kc5tja> LoganCapaldo: Expand your font size. :)
15:31:32 <kc5tja> It is.
15:31:36 <Cale> btw, that's a bad way to test if a list is empty
15:31:42 <LoganCapaldo> aroo
15:31:45 <LoganCapaldo> but but
15:31:47 <kc5tja> LoganCapaldo: :)
15:31:48 <LoganCapaldo> its monospaced
15:31:49 <Cale> use not (null errors)
15:32:01 <Cale> make sure there are no tabs in your file?
15:32:03 <kc5tja> Cale: Thanks.
15:32:08 <kc5tja> Spaces exclusively.
15:32:10 <Cale> hmm
15:32:12 <kc5tja> I *NEVER* use tabs.
15:32:14 <kc5tja> EVER.
15:32:17 <Cale> @paste
15:32:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:32:22 <Cale> paste it :)
15:32:27 <LoganCapaldo> erm
15:32:35 <sorear> kc5tja: is it actually in a do? :)
15:32:35 * LoganCapaldo tries changing fonts
15:33:05 <hpaste>  kc5tja pasted "Parse error on "if errors /= []" line." at http://hpaste.org/1011
15:33:40 <LoganCapaldo> well at least it looks indented in the space
15:33:40 <Heffalump> == [] and /= [] are usually a bad idea cos they require an Eq instance
15:33:43 <LoganCapaldo> err paste
15:33:48 <Heffalump> null and not . null are generally better
15:33:53 <sorear> kc5tja: found it
15:34:01 <kc5tja> Heffalump: Cale already told me.
15:34:12 <Heffalump> but the real point is that you need to introduce your sub-clauses with do too
15:34:16 <hpaste>  sorear annotated "Parse error on "if errors /= []" line." with "need inner do" at http://hpaste.org/1011#a1
15:34:30 <Heffalump> at least all the ones that use multiple lines, e.g. the last bit
15:34:46 <kc5tja> A more helpful error message definitely would have been helpful here.
15:34:49 <kc5tja> Thanks.  :)
15:34:50 <Heffalump> ah, so he did, sorry
15:34:51 <Toxaris> are the parentheses needed?
15:34:55 <Cale> no
15:35:01 <Heffalump> that is a pretty early parse error
15:35:03 <kc5tja> I use () for clarity.
15:35:33 <Cale> This looks like a good place to use a case with guards.
15:35:54 <Heffalump> case () of _ | ... ?
15:35:57 <hpaste>  sorear annotated "Parse error on "if errors /= []" line." with "style - simulating cond" at http://hpaste.org/1011#a2
15:36:42 <dmwit> sorear: You type too fast.
15:36:46 <dmwit> =)
15:36:54 <hpaste>  Cale annotated "Parse error on "if errors /= []" line." with "case" at http://hpaste.org/1011#a3
15:37:26 <Cale> sorear beat me to it :)
15:37:28 <sorear> Cale: your version is seriously buggy
15:37:36 <jcreigh> after I've installed a cabal package into $HOME (with runghc Setup configure --prefix=$HOME --user then build and install), how do I remove it?
15:37:39 <kc5tja> I was looking for a better way than nested ifs.
15:37:41 <Cale> er, oops
15:37:42 <Cale> hehe
15:37:46 <sorear> Cale: consider what happens if there are no errors
15:37:47 <Cale> (x:xs)
15:37:50 <Cale> yeah
15:37:54 <Cale> not []
15:38:00 <sorear> jcreigh: rm -rf
15:38:02 <LoganCapaldo> print all the non existant errors!
15:38:04 <LoganCapaldo> wooo!
15:38:07 <sorear> jcreigh: then ghc-pkg unregister
15:38:30 <Cale> I've only had 3 hours of sleep in the last 24 hours.
15:39:32 <jcreigh> sorear++ that did the trick, thanks
15:39:39 <sorear> @users
15:39:39 <lambdabot> Maximum users seen in #haskell: 336, currently: 319 (94.9%), active: 45 (14.1%)
15:39:46 <hpaste>  Cale annotated "Parse error on "if errors /= []" line." with "(oops)" at http://hpaste.org/1011#a4
15:40:26 <Cale> er, also there's a trailing paren :)
15:40:28 <Cale> heh
15:40:40 <JohnnyL> > (=>)
15:40:40 <lambdabot>  Parse error
15:40:45 <JohnnyL> > src (=>)
15:40:45 <lambdabot>  Parse error
15:40:46 <Cale> I should probably not be trying to code right now :)
15:40:49 <JohnnyL> @src (=>)
15:40:49 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:40:50 <Toxaris> not better (_:_) like in the other case
15:41:02 <sjanssen> jcreigh: so how is xinerama going?
15:41:11 <LoganCapaldo> JohnnyL: Maybe its not (=>)...
15:41:15 <JohnnyL> what's => mean?
15:41:16 <allbery_b> JohnnyL: => is not a function
15:41:17 <Cale> Toxaris: hm?
15:41:29 <allbery_b> it marks a class constraint on a type
15:41:31 <jcreigh> sjanssen: I'm getting ready to submit the patchs to X11-extra (to add Graphics.X11.Xinerama) and xmonad
15:41:47 <Cale> JohnnyL: => is part of the syntax of type signatures which separates class contexts from the rest of the signature.
15:41:48 <JohnnyL> @users
15:41:48 <lambdabot> Maximum users seen in #haskell: 336, currently: 319 (94.9%), active: 47 (14.7%)
15:42:07 <allbery_b> Class a => Type a means the contained type a must conform to the specified Class
15:42:18 <allbery_b> (or Class a => a)
15:42:24 <allbery_b> so, for example:
15:42:26 <JohnnyL> Cale, thanks man.
15:42:26 <allbery_b> :t (+)
15:42:28 <lambdabot> forall a. (Num a) => a -> a -> a
15:42:42 <jcreigh> sjanssen: oh, and I'm running xmonad right now :)
15:42:43 <allbery_b> any type a can be used as log as it conforms to Num
15:46:54 <JohnnyL> :t (^)
15:46:56 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
15:47:11 <LoganCapaldo> Its just a fatter version of ->
15:47:46 <sjanssen> jcreigh: what's the story on xinerama and compatibility?  Do all systems have the needed xlib functions?
15:47:59 <jcreigh> sjanssen: I don't know
15:48:23 <JohnnyL> thanks guys.
15:48:33 <jcreigh> sjanssen: I've been wondering about that...can all X11s reasonably expected to have th xinerama library? It's hard to find hard info on stuff like that.
15:48:57 <sjanssen> jcreigh: yes, I know what you mean
15:49:58 <jcreigh> for now I'm just going to submit a patch that adds a Graphics.X11.Xinerama module to X11-extras...if it turns out that some systems don't have that, we'll have to make it so it's optional somehow.
15:50:39 <sjanssen> yeah.  I wonder if you can check for the needed headers programmatically with the C preprocessor
15:51:09 <kc5tja> What fascinates me is the sheer amount of pure functional logic in an imperative piece of code.
15:51:17 <jcreigh> sjanssen: I think so...ratpoison does a #ifdef HAVE_X11_EXTENSIONS_XINERAMA_H...
15:51:29 <kc5tja> So far, I've found that the imperative code amounts, most often, to a cond-like structure.
15:51:40 <kc5tja> Almost never is it strictly a do this, then this, then this sequence.
15:51:49 <kc5tja> (I mean, such code exists, sure, but it's relatively rare)
15:51:56 <jcreigh> sjanssen: (I wonder if that's set by autoconf. hmm....)
15:52:39 <sjanssen> jcreigh: the ideal situation is that xinerama checking is handled at X11-extras compile time
15:52:41 <jcreigh> oh, yeah, that looks like an autoconf thing
15:53:18 <jcreigh> well, if we could do that, they how do we detect that we don't have the Xinerama module in xmonad?
15:53:40 <sjanssen> what does that Xinerama module provide?
15:54:17 <sjanssen> getScreens :: IO [(Location, Dimensions)], or something?
15:54:29 <jcreigh> sjanssen: four functions: xineramaIsActive, xineramaQueryVersion, xineramaQueryExtension and xineramaQueryScreens
15:54:47 <jcreigh> xineramaQueryScreens is Display -> IO (Maybe [XineramaScreenInfo])
15:55:15 <magnus_> @pl \f g a -> f a (g a)
15:55:15 <lambdabot> ap
15:55:18 <jcreigh> all the other functions aren't really needed, but I exported them anyway, because they're in the C version, and the X11 lib is just supposed to be a wrapper
15:55:25 <sjanssen> on a non-xinerama system, getScreens could be a simple stub that uses standard X stuff to return the single screen info
15:56:00 <jcreigh> sjanssen: yeah, that's what I do in xmonad to make it work for if you don't have xinerama turned on.
15:56:27 <jcreigh> but it feels weird to do magic stuff like that in the library.
15:56:59 <sjanssen> I think it's useful to put it in the library
15:57:45 <magnus_> @pl \f g a -> f (g a) a
15:57:45 <lambdabot> flip flip id . liftM2
15:57:47 <sjanssen> there's no workable solution to have conditional dependencies on Haskell modules
15:58:10 <jcreigh> ah
15:58:44 <allbery_b> well, there sort-of is.  not via cabal
15:59:02 <JohnnyL> i noticed that at some levels haskell source is very familiar to forth.
15:59:08 <sjanssen> you can do some stuff with CPP, but there isn't really a way to programmatically check whether X11-extras has a Xinerama module
15:59:09 <jcreigh> well, there's two issues here:
15:59:11 <allbery_b> you'd ave configure test for xinerama being in ghc-pkg list
15:59:33 <allbery_b> and then use cpp foo in your haskell source to conditionalize on the result
15:59:33 <jcreigh> 1: XineramaQueryScreens() returns NULL if xinerama is turned off. (even if libs are present)
15:59:34 <allbery_b> ugly
15:59:40 <jcreigh> 2: someone might not have xinerama libs
15:59:48 <sorear> hm.
15:59:55 <magnus_> johnnyL: function composition?
15:59:55 <allbery_b> there's that too
15:59:59 <LoganCapaldo> Isn't flip flip id just id?
16:00:01 <allbery_b> I have xinerama libs but only one screen
16:00:08 <sorear> getScreens :: Maybe (IO [(Location, Dimensions)]) anyone?
16:00:23 <allbery_b> @ty flip flip id
16:00:23 <ddarius> @type flip flip id
16:00:25 <lambdabot> forall a c a1. (a -> (a1 -> a1) -> c) -> a -> c
16:00:27 <lambdabot> forall a c a1. (a -> (a1 -> a1) -> c) -> a -> c
16:00:31 <allbery_b> @quote stereo
16:00:31 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
16:00:33 <sorear> Just $ do ... if HAVE_XENORAMA
16:00:44 <sorear> Nothin if !HAVE_XENORAMA
16:00:51 <LoganCapaldo> @type flip flip
16:00:54 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
16:01:06 <LoganCapaldo> weird
16:01:18 <ddarius> @type flip . flip -- is id
16:01:21 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
16:01:22 <sjanssen> sorear: most clients that check xinerama info will fall back and call the standard X screen querying stuff anyway, so it makes sense to roll it into one function
16:02:01 <JohnnyL> magnus, well mostly all the low level function (it's like stacking in forth).
16:02:08 <LoganCapaldo> @typ flip flip flip
16:02:08 <jcreigh> sjanssen: yeah, I think you're right, I should move my getScreens function into X11-extras
16:02:10 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
16:02:24 <sorear> @pl flip flip flip flip flip id
16:02:24 <lambdabot> ($ flip)
16:02:28 <jcreigh> sjanssen: that solves problem 1. I don't know what we can do at this point about missing xinerama libs.
16:02:35 <sorear> @pl flip flip flip id
16:02:35 <lambdabot> ($ flip)
16:02:38 <sorear> @pl flip flip flip flip id
16:02:39 <lambdabot> ($ flip)
16:02:44 <sorear> @pl flip flip flip flip
16:02:44 <lambdabot> flip flip flip
16:02:45 <sjanssen> jcreigh: we can cross that bridge later on
16:02:49 <sorear> @pl flip flip flip flip flip
16:02:49 <lambdabot> flip flip flip
16:02:53 <jcreigh> sjanssen: okay
16:02:54 <LoganCapaldo> sorear: you're scaring the children
16:03:01 <sorear> @quote flip
16:03:01 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
16:04:28 <jcreigh> poll: what should the name of the function f :: Display -> ScreenNumber -> IO [XineramaScreenInfo] be? right now I have getXineScreens
16:05:02 <sjanssen> jcreigh: is this the magic function that yields an answer even when there's no xinerama?
16:05:06 <jcreigh> sjanssen: yes
16:05:15 <LoganCapaldo> why not just screens
16:05:33 <jcreigh> LoganCapaldo: it's in a library, it'd like it be reasonably unique
16:05:40 <LoganCapaldo> but but
16:05:48 <sjanssen> jcreigh: what's the name of the analogous function in the X11 package?
16:05:50 <LoganCapaldo> Haskell's module system is the awesome
16:05:52 <sjanssen> getScreenInfo?
16:06:22 <LoganCapaldo> import qualified Xinerama.Stuff as X
16:06:26 <LoganCapaldo> X.screens
16:06:30 <jcreigh> sjanssen: the C function is named XineramaQueryScreens(). my binding to *that* is named xineramaQueryScreens
16:06:35 <allbery_b> oh, you could have xinerama libs but either extension not loaded or nonexistent (consider remote display)
16:07:05 <allbery_b> (in addition to extent but inactive)
16:07:11 <allbery_b> *extant
16:07:27 <jcreigh> allbery_b: on my system, if you have a single screen, the xinerama extension is off and the C functions return failure.
16:07:33 <jcreigh> *only a single screen
16:08:28 <allbery_b> including XQueryExtension?
16:08:53 <allbery_b> I recall seeing whines from some Xinerama-ish stuff when run in my Xvnc :)
16:09:18 <jcreigh> allbery_b: no, the functions defined in the Xinerama lib. (well, XineramaIsActive() still works, but the others return error codes)
16:09:35 <allbery_b> ok, makes sense
16:09:35 <jcreigh> ie, the functions in X11/extensions/Xinerama.h
16:09:59 <allbery_b> I'd expect XineramaIsActive to throw an XError if the server doesn;t know abotu the extension at all
16:10:12 <JohnnyL> danke allbery_b.
16:11:15 <jcreigh> I'm pretty sure the xinerama lib is just a wrapper around some lower-level xlib functionality.
16:11:53 <allbery_b> partially, but not completely; xinerama is definitely a server extension
16:12:26 <allbery_b> and if the server doesn't know about the extension, the opcodes used by the extension will cause XErrors
16:12:48 <allbery_b> (heck, xlib is a wrapper around the low level X functionality :)
16:13:14 <sjanssen> hmm, I don't seem to have any xinerama manpages on my system
16:14:12 <jcreigh> closest thing to docs I could find was http://umn.dl.sourceforge.net/sourceforge/xinerama/XineramaApi.txt (note that it refers to XineramaGetData(), which doesn't exist, AFAICT. So those docs are old anyway.)
16:14:14 <lambdabot> http://tinyurl.com/youlft
16:14:35 <jcreigh> I basically just read the header file
16:20:01 <jcreigh> ooh, defaultScreenOfDisplay. maybe the wrapper can have the same type signature as the real function...
16:23:53 <petekaz> quick question on style, which is preferred?
16:24:04 <LoganCapaldo> avant garde
16:24:05 <petekaz> a) newline . bolder . subject $ e
16:24:16 <petekaz> b) newline . bolder $ subject e
16:24:22 <sorear> a
16:24:27 <sorear> but that's me
16:24:38 <sorear> this is sadly a very personal issue
16:24:39 <petekaz> c) newline (bolder (subject e))
16:24:58 <sorear> d) newline $ bolder $ subject $ e
16:25:01 <sorear> e) newline $ bolder $ subject e
16:25:14 <petekaz> I definitely like the '.' versions.
16:25:15 <sorear> I and Cale prefer a)
16:25:25 <petekaz> But was unsure of a) or b)
16:25:49 <sorear> @quote Cale asso
16:25:49 <lambdabot> Cale says: Also, I want people to write things using (.) instead of repeated ($) because of my hidden agenda to flip the associativity of ($)
16:26:17 <petekaz> I'll stick with (.) then!
16:26:48 <LoganCapaldo> why does he want to flip the associativity of $ ?
16:27:03 <merus> Why not?
16:27:34 <LoganCapaldo> merus: why (why not)?
16:27:54 <ddarius> Because there are parens you can get rid of that way, while the parens you can get rid of currently can be gotten rid of with (.) and ($)
16:28:24 <Eidolos> ?src foldr
16:28:24 <lambdabot> foldr k z xs = go xs
16:28:24 <lambdabot>     where go []     = z
16:28:24 <lambdabot>           go (y:ys) = y `k` go ys
16:28:49 <sorear> -OR-
16:29:10 <sorear> foldr (<*>) z [] = z
16:29:18 <hpaste>  petekaz pasted "Learning to be idiomatic" at http://hpaste.org/1012
16:29:29 <sorear> foldr (<*>) z (x:xs) = x <*> foldr (<*>) z xs
16:29:45 <Eidolos> :)
16:30:05 <petekaz> That's, in my opinion, the best haskell code I've written.  It's starting to look like someone who knows Haskell wrote it.
16:30:12 <Eidolos> Someone just asked what foldr was, I gave them an implementation in Scheme, then was curious to see how the Prelude has it.
16:30:23 <ddarius> petekaz: Repeated uses of $ is probably more idiomatic currently.
16:30:33 <petekaz> oh.
16:31:17 <LoganCapaldo> mmm, this is awesome: bolder  = ("\27[0;32;40m" ++) . (++ "\27[0m")
16:31:32 <jcreigh> LoganCapaldo: gah! no! make it stop!
16:31:34 <petekaz> I guess I like the (.) better though.  I like the thought of taking a bunch of functions and composing them.
16:31:52 <LoganCapaldo> jcreigh: ?
16:32:01 <jcreigh> LoganCapaldo: hard-coding stuff like that is Bad.
16:32:07 <jaredj> OT: http://www.cowtown.net/mikefirth/bottle.htm
16:32:07 <jcreigh> ncurses is there for a reason.
16:32:08 <lambdabot> Title: Bottle Cutting
16:32:16 <LoganCapaldo> jcreigh: err
16:32:28 <LoganCapaldo> it wasn't the escape codes that was awesome
16:32:34 <jcreigh> oh
16:33:06 <LoganCapaldo> bolder = ("<bold>" ++) . (++ "</bold>") would have equally impressed me with its clever ness
16:33:07 <petekaz> LoganCapaldo: that line would have made my head spin a few months ago.  I'm pretty excited that I actually wrote it with no problem at all.
16:33:54 <sorear> @pl \x -> pfx <> x <> sfx
16:33:54 <lambdabot> (<> sfx) . (pfx <>)
16:34:43 <ddarius> jaredj: Any reason that you mentioned that?
16:34:56 <jaredj> cause i'm reading it, no other reason
16:35:26 <jaredj> well, and it appears useful, for those who want to cut bottles
16:35:41 <jaredj> (i.e., it's good among pages of its type)
16:36:44 <LoganCapaldo> > let greet = ("Hello, " ++) . (++ "!") in greet "world"
16:36:45 <lambdabot>  "Hello, world!"
16:37:58 <jcreigh> sjanssen: where should I send the patch to X11-extras to? (darcs wants to know)
16:42:07 <emu> i prefer "foo . bar $ arg" too, so don't worry about that
16:42:32 <petekaz> > map (length &&& head) . group . sort $ "hello"
16:42:33 <lambdabot>  [(1,'e'),(1,'h'),(2,'l'),(1,'o')]
16:43:27 <dons> moin
16:43:52 <jaredj> :t (&&&)
16:43:54 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:45:52 <jaredj> [] is an instance of Arrow, then, yes?
16:46:16 <petekaz> I won't pretend to understand that type, someone here was kind enough to tell me how to _use_ &&&.
16:46:24 <jcreigh> dons: any idea what email address I should a patch for X11-extras to? (appearently there's no default address set for that repo, because darcs is asking me)
16:46:27 <shachaf> jaredj: "length" and "head" are instances of Arrow.
16:46:41 <jaredj> ur. right.
16:47:01 <jaredj> :t (length &&& head) -- petekaz
16:47:04 <lambdabot> forall a. [a] -> (Int, a)
16:47:05 <LoganCapaldo> Some kind of Arrow head eh
16:47:11 <jaredj> much more normal-looking
16:47:12 <ddarius> (&&&) :: (b -> c) -> (b -> c') -> b -> (c, c')
16:48:45 <jcreigh> okay, too late, they're going to sjanssen@cse.unl.edu :)
16:49:07 <dcoutts__> g'morning dons
16:49:11 <ddarius> (&&&) is one way of the isomorphism that defines the adjunction defining products </abstract nonsense>
16:49:18 <ClaudiusMaximus> @instances Arrow
16:49:19 <lambdabot> (->), Kleisli m
16:49:20 <fdsfsf> http://taleworld.sytes.net Join Please
16:49:28 <lambdabot> Title:  Tale World
16:50:10 <jaredj> whaat?
16:50:23 <jaredj> i feel interloped
16:50:36 <sorear> darn, 8192-wide netmask
16:50:55 <LoganCapaldo> unsafeInterlopeIO
16:50:59 <jaredj> haha
16:51:03 <vincenz> Anyone know where dmhouse is from?
16:51:04 <dons> jcreigh: just send it to me.
16:51:10 <dons> hey dcoutts__
16:51:15 <jcreigh> dons: ah, too late. :)
16:51:16 <vincenz> dons: do you happen to know dmhouse's origins?
16:51:23 <sorear> wow, that address was from latvia!
16:51:27 <dcoutts__> vincenz: (0,0) presumably :-)
16:51:32 <vincenz> :)
16:51:35 <sorear> what a small country to send us spammers!
16:51:37 <vincenz> I mean, which continent/country
16:51:46 <omgomgomg> THE END IS COMING
16:51:56 * vincenz blinks
16:51:58 <vincenz> That was odd
16:51:59 <dcoutts__> heh heh
16:52:01 <jaredj> :)
16:52:15 <vincenz> dcoutts__: is he from the uk?
16:52:15 <sorear> the contact is Romans Mironovs, trickstertr@gmail.com
16:52:27 <sorear> but I suspect that's only an ISP contact
16:52:32 <vincenz> sorear: don't put emails without the <at> bit in irc, they get caught in the log and then caught by spammers
16:52:37 <dcoutts__> jaredj: ta for that, I'll bear it in mind
16:52:52 <sorear> otoh, it's a netblock of 8192 addresses, pretty small isp
16:52:56 <jaredj> dcoutts__: ta?
16:53:03 <dcoutts__> jaredj: though next time you need to do it more anonymously :-)
16:53:08 <jaredj> haha
16:53:16 <vincenz> dcoutts__: no idea?
16:53:32 <dcoutts__> jaredj: erm it's a British Englishism, "ta" meaning thanks
16:53:37 <jaredj> ahhh ic
16:53:39 <jaredj> ta
16:53:45 <jcreigh> @tell sjanssen Okay, I sent the patches to X11-extras and xmonad to sjanssen@cse.unl.edu. Let me know if you don't get them.
16:53:45 <lambdabot> Consider it noted.
16:54:02 <dons> jcreigh: woo!
16:54:09 <dons> jcreigh: can you send them to me, i'll apply them now..
16:54:11 <dcoutts__> vincenz: who? dmhouse?
16:54:15 <vincenz> yeah
16:54:29 <jcreigh> dons: sure...
16:54:39 <dcoutts__> vincenz: erm, not sure
16:54:45 <vincenz> hmm, alrght
16:55:03 <jcreigh> dons: to dons@cse.unsw.edu.au?
16:55:15 <dons> yep
16:55:18 <jcreigh> k
16:55:40 <jaredj> ogh, now with the knapsack again
16:55:41 <jcreigh> sent
16:56:26 <ClaudiusMaximus> ahh, so Arrow a => a b c  is a generalisation of   b -> c  (given that (->) is an instance of Arrow), but what/how/why does it generalize?
16:57:11 <Heffalump> it's kind of analogous to the way Monad m => m a generalises a, if that helps
16:57:23 <jcreigh> dons: you might want to look at our discussion WRT compatibility with systems that don't have xinerama in the scrollback. (starting around "/lastlog story on xinerama", if you're using irssi)
16:57:40 <jcreigh> basically, we're punting for now, but we want to figure out something clever in the long run
16:58:25 <jcreigh> xinerama libs, that is. xmonad should continue to work fine on system without xinerama turned on, it just needs the libs to be there.
16:59:11 <dons> ah ok.
16:59:31 <dons> so perhaps we need a configure.ac file to check for them?
16:59:40 <jcreigh> yeah, something like that.
16:59:51 <jcreigh> I have no idea how (un)common it is for xinerama libs to be missing...
17:00:14 <ClaudiusMaximus> @instances Monad
17:00:15 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:00:17 <jcreigh> (This was my first experience with any sort of X11 programming)
17:00:25 <LoganCapaldo> ClaudiusMaximus: I believe it generalizes the "process" of getting a c from a b
17:00:32 <dinounix> is there a way to pause execution for a few seconds?
17:00:42 <sorear> dinounix: Control.Concurrent.threadDelay
17:00:43 <yshhq> @type @
17:00:45 <lambdabot> parse error on input `@'
17:00:51 <LoganCapaldo> @hoogle Int -> IO ()
17:00:52 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
17:00:52 <lambdabot> System.Console.Readline.setCompletionQueryItems :: Int -> IO ()
17:00:52 <lambdabot> System.Console.Readline.setEnd :: Int -> IO ()
17:00:54 <yshhq> @type ($)
17:00:56 <lambdabot> forall a b. (a -> b) -> a -> b
17:01:05 <LoganCapaldo> threadDelay perhaps?
17:01:08 <dinounix> sorear: thanks
17:01:22 <dons> ok. built for me, jcreigh
17:01:24 <LoganCapaldo> oh sorear said it already :(
17:01:33 <yshhq> @src ($)
17:01:33 <lambdabot> f $ x = f x
17:01:53 <dons> jcreigh: boo, now I have to reset xmonad, after 5 days uptime
17:02:00 <ClaudiusMaximus> LoganCapaldo: thanks, that makes things a little clearer (maybe, i'm still confused)
17:02:00 <jcreigh> dinounix: note that the unit for threadDelay is MICROseconds, not milliseconds as I initially expected.
17:02:23 <sorear> dons: now what was I saying about hs-plugins dynamicity? :p
17:02:23 <dons> its strange, it seems to use less memory as time goes on. now xmonad sits on 1456K
17:02:28 <dons> which is about what dwm uses.
17:02:44 <dons> sorear: don't come at me with that bloatware
17:03:06 <dinounix> jcreigh: ok, no problem, i need to delay for a short time anyway :)
17:03:52 <jcreigh> dinounix: yeah. it's fine as long as you know. I was doing "threadDelay 1000" and was like "what the heck? It's not working!" :)
17:04:02 <dinounix> heh
17:04:25 <jaredj> wawaiwait. what's this thing, dons?
17:04:25 <LoganCapaldo> ClaudiusMaximus: glad I could pretend to help :)
17:04:31 <dons> jcreigh: seems to work!
17:04:51 <jcreigh> dons: cool
17:05:04 <yshhq> @type Cont
17:05:05 <dons> argh. no it doesn't
17:05:06 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
17:05:09 <dons> xmonad just reset
17:05:20 <yshhq> @type Cont ($)
17:05:22 <lambdabot>     Occurs check: cannot construct the infinite type: r = a -> r
17:05:22 <lambdabot>     Probable cause: `$' is applied to too few arguments
17:05:25 <jcreigh> dons: does "reset" mean "crashed"?
17:05:29 <dons> jcreigh: something funny about switching to an empty workspace, then switching back
17:05:41 <dons> jcreigh: yes. it crashed.
17:05:48 <dons> i don't have xinerma, btw.
17:05:48 <yshhq> @type Cont (\x -> ($ x))
17:05:50 <lambdabot>     Occurs check: cannot construct the infinite type:
17:05:51 <lambdabot>       a = a1 -> (a -> b) -> t
17:06:05 <LoganCapaldo> @type Cont
17:06:08 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
17:06:10 <sorear> wait, a haskell program crash?  dons, unsafeCoerce# is not a toy!
17:06:11 <sorear> :p
17:06:15 <jcreigh> yeah, I tested single-screen before I sent...actually, I'm running single screen right now for testing...
17:06:30 <dons> X can crash.
17:06:30 <jcreigh> dons: what does cat ~/.xsession-errors tell you?
17:06:46 <dons> i clobbered it on logging back in, unfortunately.
17:06:48 <dons> trying to reproduce.
17:06:59 <yshhq> @type Cont (\x -> ($ x))
17:07:02 <lambdabot>     Occurs check: cannot construct the infinite type:
17:07:02 <lambdabot>       a = a1 -> (a -> b) -> t
17:07:23 <dons> hmm. seems ok now ...
17:07:27 <sorear> call me naive, but ... if X crashes, isn't it by definition X's fault, not xmonad's?
17:07:34 <yshhq> @type Cont (\(x :: Int) -> ($ x))
17:07:36 <lambdabot>     Couldn't match expected type `a -> r' against inferred type `Int'
17:07:36 <lambdabot>     In the pattern: x :: Int
17:07:37 <dons> sorear: you're so naive
17:07:50 <dons> this X guy, he crashes you when he has an error
17:08:11 <jcreigh> dons: I suspect it's the "let Just curscreen = M.lookup m ws2sc" in Main.hs. But that shouldn't ever be Nothing...
17:08:14 <yshhq> @type Cont (\(x :: Int) -> ($ x))
17:08:16 <sorear> @type Cont ($ ?x)
17:08:17 <lambdabot>     Couldn't match expected type `a -> r' against inferred type `Int'
17:08:17 <lambdabot>     In the pattern: x :: Int
17:08:18 <lambdabot> forall a r. (?x::a) => Cont r a
17:08:20 <jaredj> In Soviet Russia...
17:08:24 <jcreigh> "shouldn't" being the operative word, of course.
17:08:33 <yshhq> @type \(x :: Int) -> ($ x)
17:08:35 <lambdabot> forall b. Int -> (Int -> b) -> b
17:08:44 <sorear> dons: oh, so you're talking XErrors?
17:09:01 <jcreigh> sorear: naw, it's probably a Just x <- foo in my code blowing up
17:09:21 <yshhq> @type Cont ($ (x :: Int))
17:09:23 <lambdabot> Not in scope: `x'
17:09:33 <sorear> @type Cont ($ ?x)
17:09:35 <lambdabot> forall a r. (?x::a) => Cont r a
17:09:40 <dons> jcreigh: i'm applying the patches. we'll see how it goes.
17:09:53 <sorear> @type Cont ($ 0)
17:09:55 <lambdabot> forall a r. (Num a) => Cont r a
17:09:59 <sorear> @src Cont return
17:09:59 <lambdabot> return a = Cont ($ a)
17:10:08 <jcreigh> dons: oh, the crash was before you applied my patches?
17:10:30 <sorear> yshhq: @type doesn't invent types for variables, unless you tell it to with ?
17:10:40 <dons> jcreigh: i don't like the sound of this Just _ stuff. you should at least check the error
17:10:46 <yshhq> got it
17:10:50 <dons> jcreigh: nope, with your code. i'm pushing your patches now to the main repo
17:11:04 <jcreigh> dons: ah, okay.
17:11:21 <dolio> @src ((->) e) (>>=)
17:11:21 <lambdabot> Source not found. Wrong!  You cheating scum!
17:11:22 <dons> i haven't been able to reproduce it yet, so that's enough for now.
17:11:31 <mbishop> http://www.cs.cmu.edu/~dst/DeCSS/Gallery/  What? No haskell? :)
17:11:32 <dons> @src (->) (>>=)
17:11:32 <lambdabot> Title: Gallery of CSS Descramblers
17:11:32 <lambdabot> f >>= k = \ r -> k (f r) r
17:11:47 <dons> jcreigh: applied.
17:11:56 <dons> jcreigh: but can you do a walk over the code for possible failure points?
17:12:05 * dons `ap` coffee
17:12:18 <yshhq> ($ a) should be (r -> a) -> a, right?
17:12:35 * dcoutts__ `ap` tea
17:12:54 <yshhq> but we need (a -> r) -> r in Cont?
17:13:09 <jcreigh> dons: sure
17:13:38 <dolio> (r -> a) -> a is the same as (a -> r) -> r. The variables are just renamed.
17:13:57 <LoganCapaldo> na uh
17:14:14 <LoganCapaldo> (r -> a) -> a is a cheerleader, (a -> r) -> r is a pirate
17:14:46 <merus> ...
17:14:48 <dolio> Heh.
17:15:10 <dolio> Well played.
17:15:47 <merus> "Save the cheerleader, save the world" just took on a whole new meaning.
17:16:35 <vincenz> merus: ah saw that hmm?
17:16:38 <vincenz> how many episodes are there?
17:16:45 <jcreigh> dons: no, I think that line is probably the cause. I guess placing a worried comment above a refutable pattern match doesn't mean it won't fail. :(
17:16:46 <vincenz> I only found upto 18 on gnutella
17:17:17 <jcreigh> dons: well, I'll try to think of a good was to handle Nothing in that case. Let me know if you can reproduce the crash.
17:23:02 <jcreigh> @tell sjanssen nm, dons applied the patches.
17:23:02 <lambdabot> Consider it noted.
17:25:07 * sorear is reading non-executable docs on the css algorithm
17:25:21 * sorear is laughing at the people who designed it
17:25:36 <vincenz> woo, play-by-play account of your day
17:25:53 * mbishop is putting on his robe and wizard hat...
17:27:11 * LoganCapaldo is reading online accounts of other people's lives on IRC
17:30:26 <shachaf> How can I import a module but rename one of the functions it exports?
17:32:12 <mauke> import qualified Module; myname = Module.othername
17:33:10 <Heffalump> and import Module hiding (othername)
17:33:55 <kc5tja> I just spent two hours coding a replacement parser for CUT; it very nearly works the first time.  :)
17:34:40 <shachaf> mauke, Heffalump: Thanks, I didn't think I could both "import qualified" and "import" the same module.
17:35:08 <ddarius> shachaf: You can import a module as much as you like modulo clashes.
17:35:19 <ddarius> (Or are clashes an issue?)
17:35:28 <sorear> You can import a module as much as you like, period.
17:35:52 <shachaf> ddarius: It works now.
17:35:53 <sorear> Clashes just mean that any use of the ambiguous names must be qualified.
17:36:38 <shachaf> ddarius: This isn't my code and I'm not responsible for it, but this person is importing Prelude hiding ((+),(-),(*),(/)).
17:39:11 <kc5tja> @hoogle nub
17:39:12 <LoganCapaldo> Does he then redefine arithmetic in terms of Church numerals?
17:39:12 <lambdabot> List.nub :: Eq a => [a] -> [a]
17:39:12 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
17:39:34 <shachaf> LoganCapaldo: He's using them as postfix operator to have BNF-looking syntax.
17:39:41 <pbx> I love the jokes in #haskell
17:40:07 <LoganCapaldo> that's kinda cool
17:40:17 <LoganCapaldo> what's (-) for?
17:40:32 * LoganCapaldo assumes (/) is or
17:40:52 <shachaf> LoganCapaldo: I don't think he ended up using (-).
17:40:57 <morner> wow, i wasn't expecting this place to be so busy
17:41:00 <shachaf> LoganCapaldo: Yes, (/) is or.
17:45:01 <kc5tja> morner: activity varies.
17:45:18 <pbx> @users
17:45:18 <lambdabot> Maximum users seen in #haskell: 336, currently: 307 (91.4%), active: 44 (14.3%)
17:45:49 <morner> even 300-odd idlers is fair
17:47:20 <sorear> @where stats
17:47:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
17:47:27 <sorear> i think there's an activity chart
17:50:22 <LoganCapaldo> hehhe
17:50:29 <LoganCapaldo> I'm creeping up
17:50:41 <sorear> alas, I'm down to #3
17:50:44 <LoganCapaldo> Comes from spouting a lot of nonsense into the channel ;)
17:50:47 <sorear> blahblah
17:50:51 <sorear> must
17:50:54 <sorear> raise
17:50:55 <sorear> line
17:50:56 <sorear> count
17:51:10 <sorear> must
17:51:12 <sorear> pass
17:51:13 <sorear> dons
17:51:15 <sorear> must
17:51:16 <sorear> pass
17:51:17 <sorear> lambdabot
17:51:19 <dons> bad sorear
17:51:28 <LoganCapaldo> does it weight short lines differently than long ones?
17:52:10 <vincenz> dons: any webpage regarding yorkfun?
17:52:31 <sorear> @where yhc
17:52:31 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
17:52:37 <sorear> er
17:53:16 <ailndx> dons: cant you put someone on hsplugins in win.. to write a small tutorial on how to install/configure and so on?
17:53:49 <vincenz> dcoutts_: or where did you mention the meeting in may was going to be?
17:54:08 <sorear> http://www.cs.york.ac.uk/fp/
17:54:09 <lambdabot> Title: York Functional Programming Home Page
17:54:21 <sorear> vincenz: that your objective?
17:54:42 <vincenz> sorear: not quite, no :)
17:55:05 * vincenz heard mention of a haskell-meet in may in england
17:58:41 <liquidengineer> hi everyone
18:00:28 <dolio> @pl (((. head . uncurry zip . splitAt 1 . repeat) . uncurry) .) . (.) . flip
18:00:28 <lambdabot> (((. (head . uncurry zip . splitAt 1 . repeat)) . uncurry) .) . (.) . flip
18:00:54 <morner> gnnngh
18:00:55 <jcreigh> dons: okay, I sent you a patch that replaces the "Let Just x = ..." with a case that prints an error message and tries to recover gracefully.
18:02:14 <yshhq> @type callCC
18:02:16 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
18:02:17 <jcreigh> dons: (Sorry about that; I didn't think there was a case where that could ever be Nothing...but it looks like there is.) Anyway, if it can't find the current workspace's screen, it just uses the first screen, so single-screen users of xmonad shouldn't see anything amiss even in the "Nothing" case
18:02:34 <liquidengineer> how's everyone tonight?
18:02:45 <allbery_b> drainbead
18:02:45 * jcreigh kicks himself for thinking "oh, that will *never* happen"
18:03:08 <liquidengineer> that bad?
18:04:39 <allbery_b> I presume between my spinning brains and the cats' behavior that I have the weather to blame
18:04:47 <liquidengineer> Yes
18:04:50 <sorear> somewhat energetic, inexplicably achy, feeling productive wrt the 389-line haskell parser he's writing
18:04:51 <liquidengineer> always blame el nino
18:05:00 <liquidengineer> or alternatively, dick cheney
18:05:08 <liquidengineer> who seems to be the new el nino
18:05:55 <sorear> I always sorta thought people here were to far apart to care about each other's weather
18:06:00 <dons> jcreigh: great!
18:06:13 <dons> jcreigh: so yes, that sounds plausible, since the only crash was on initial start up
18:06:44 <liquidengineer> dons: I know you're probably super busy, but I was wondering if you had a chance to look at those files I sent.
18:07:18 <dons> ah yes. i did. i couldn't find the leak, but I narrowed it down.
18:07:27 <dons> let me see if I have the src bundle...
18:08:25 <liquidengineer> Thanks. :D
18:08:46 <dons> wget http://www.cse.unsw.edu.au/~dons/tmp/nim.tar.gz
18:08:55 <dons> $ ghc -O --make Main.hs
18:09:01 <dons> $ ./Main
18:09:01 <dons> Stack space overflow: current size 8388608 bytes.
18:09:01 <dons> Use `+RTS -Ksize' to increase it.
18:09:34 <liquidengineer> It's overflowing on 8.3 megabytes?
18:09:55 <dons> no no. it just overflows. hardly anything is actually allocated.
18:10:05 <liquidengineer> ah
18:10:06 <liquidengineer> what should I do?
18:10:07 <dons> $ ./Main +RTS -K20m
18:10:08 <dons> Stack space overflow: current size 20000000 bytes.
18:10:19 <dons> liquidengineer: just let me find where I was looking at the leak
18:10:26 <dons> then you can continue hunting it down..
18:10:41 <liquidengineer> Thanks. :D
18:11:20 <dons> liquidengineer: can i just stick the src into darcs now?
18:11:24 <dons> it'll make it easier to send you diffs
18:11:53 <liquidengineer> sure....
18:11:57 <liquidengineer> i've never used darcs
18:11:59 <liquidengineer> what do I need to do?
18:12:13 <ddarius> darcs is pleasantly easy to use
18:12:19 <dons> i'll just do that now. its dead easy
18:13:03 * ddarius forgot that he was in the middle of drawing a picture.
18:13:06 <liquidengineer> Ah.
18:15:19 <jacobian> dia dhuit sioraiocht
18:15:42 <sioraiocht> dia 's muire duit, a jacobian =)
18:15:53 <LoganCapaldo> I know this is so blasphemous, but anyone in here use mercurial besides me?
18:16:17 <sioraiocht> Lá Fhéile Pádraig shona duit =)
18:16:26 <liquidengineer> what is it, Logan? Sounds kinda cool.
18:16:39 <LoganCapaldo> distributed scm
18:16:44 <liquidengineer> ??
18:16:47 <liquidengineer> how does that work?
18:16:51 <LoganCapaldo> its like darcs
18:16:56 <LoganCapaldo> but different
18:17:03 <LoganCapaldo> and written in python
18:17:27 <sorear> LoganCapaldo: CosmicRay
18:17:34 <sorear> (john goerzen)
18:17:45 <liquidengineer> do I need to download some software to use darcs?
18:17:50 <dons> liquidengineer: so initially i thought it was 'tournament'
18:17:54 <sorear> yes, darcs :)
18:17:55 <dons> liquidengineer: yeah, you need 'darcs'
18:17:57 <dons> from darcs.org
18:18:00 <liquidengineer> ah
18:18:15 <liquidengineer> dons: me too....but it seemed to work when I ran it on some sample data...
18:19:02 <jacobian> go raibh maith agat agus duit freisin a shioraiocht! :)
18:19:26 <liquidengineer> dons: tournament, that is
18:21:48 <sioraiocht> Is anyone here involved with the Summer of Code projects on concurrency?
18:21:52 <liquidengineer> downloading darcs through darwinports now
18:22:30 <liquidengineer> I hope version 1.0 is sufficient.
18:22:32 <sioraiocht> a jacobian , Cár d'fhoglaim do Ghailge?
18:24:01 <LoganCapaldo> @where xmonad
18:24:01 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
18:24:28 <sioraiocht> *d'fhoghlaim, gabh mo leithsceal
18:24:47 <liquidengineer> damn, this gonna take forever...my computer is terribly slow at building from source... :)
18:24:50 <sorear> liquidengineer: is ports a source-based system?
18:24:59 <sorear> liquidengineer: yech!
18:25:01 <liquidengineer> sorear: source and binary, yes
18:25:12 <liquidengineer> It's the BSD ports system
18:25:24 <sorear> liquidengineer: anyway, anything stable will NOT build with modern ghc
18:25:34 <liquidengineer> ?
18:25:39 <liquidengineer> [I don't understand...
18:25:41 <sorear> liquidengineer: if your ghc is modern (6.6) you *need* 1.0.9rc1 or rc2
18:26:03 <sorear> liquidengineer: they used unstable apis in older darcs...
18:26:03 <liquidengineer> damn it.
18:26:17 <liquidengineer> I'm downloading 1.0.8...
18:26:20 <liquidengineer> CRAP.
18:26:40 <sorear> liquidengineer: fortunately most of these same systems still use ghc 6.4.2
18:26:50 <LoganCapaldo> liquidengineer: I cheated
18:26:58 <LoganCapaldo> theres a binary for OS X out there
18:27:00 <liquidengineer> well, I'll let it finish installing curl (which it seems to think is necessary, even though I've already got wget) and I'll cancel it when it goes for darcs
18:27:16 <liquidengineer> Logan: Oh. -_-
18:27:28 <sorear> I don't get the point of the source-based systems...
18:27:44 <sorear> surely OSX is common enough that cached binaries are better
18:28:09 <sioraiocht> sorear: some people are picky, and caching binaries takes more overhead for the hosts =p
18:28:13 <sorear> maybe for TimBSD/ObscureArch source is better...
18:28:25 <LoganCapaldo> yeah this source nonsense is a pain in my neck
18:28:33 <LoganCapaldo> I don't _want_ to build from source
18:28:44 * sorear mutters something about distributed download systems (eg torrent)
18:28:52 <dons> liquidengineer: ok, here you go:
18:28:54 <dons> $ darcs get http://www.cse.unsw.edu.au/~dons/tmp/nim
18:28:54 <dons> Copying patch 1 of 1... done!
18:28:54 <dons> Applying patch 1 of 1... done.
18:28:54 <dons> Finished getting.
18:28:54 <lambdabot> Title: Index of /~dons/tmp/nim
18:28:56 <dons> $ cd nim
18:28:59 <dons> $ ghc -O --make Main.hs
18:29:07 <dons> liquidengineer: but i haven't found the space leak yet!
18:29:13 * sorear <3 dpkg (a binary system)
18:29:33 * LoganCapaldo has dpkg
18:29:34 <dons> you'll just have to walk through the code from Main on down, until you find some funny recursion that's too lazy in its argument
18:29:52 <LoganCapaldo> but fink seems to feel the need to download the source, compile it, and then make a package to install
18:29:57 <LoganCapaldo> more than half the time
18:29:59 <sioraiocht> aw, jacobian has abandoned our conversation in Irish
18:30:12 <ddarius> ahhh... banjoes
18:30:15 <liquidengineer> @where darcs
18:30:15 <lambdabot> http://darcs.net/
18:30:20 <LoganCapaldo> even when I give it the "binaries pretty please" flag
18:30:31 <sorear> Irish? I never knew there was such a language. :)
18:30:43 <dons> sorear: for shame.
18:30:56 <sioraiocht> ouch, and on st. patrick's day
18:31:00 * sorear has heard of Gaelic and Celtic
18:31:08 * sioraiocht cringes.
18:31:24 * ddarius has wanted to learn Welsh.
18:31:39 <sioraiocht> CELTIC is a _class_ of languages derived from existing languages (Proto-Celtic) by historical linguistic methods.
18:31:54 <yshhq> :t random
18:31:56 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
18:32:04 <sioraiocht> GAELIC is a _class_ of languages that distinguish themselves from Welsh, Cornish, and Breton
18:32:06 <liquidengineer> dons: so once I have darcs installed, what do I need to do?
18:32:10 <sioraiocht> they are Manx, Scottish, and Irish
18:32:24 <sioraiocht> That "Gaelic" is a single language is a common misconception
18:32:25 <dons> liquidengineer: type the above command, darcs get http://www.cse.unsw.edu.au/~dons/tmp/nim
18:32:25 <lambdabot> Title: Index of /~dons/tmp/nim
18:32:42 <LoganCapaldo> instance Gaelic Manx where ...
18:32:54 <sioraiocht> lol
18:32:59 * sorear updates memory
18:33:28 <Igloo> First you insult the Irish, now you're behaving imperatively?
18:33:32 <liquidengineer> command line, yes?
18:34:11 <dons> bos, thanks for applying. you're now a soc mentor.
18:34:34 <LoganCapaldo> let sorear' = sorear { gaelic = "Class of languages" }
18:34:37 <dons> sorear: with a surname like O'Rear, you really should know this stuff!
18:34:42 <sorear> sorry, man. my world is single threaded
18:34:57 <sioraiocht> ha
18:35:21 <liquidengineer> dons: cool.  got it.
18:35:27 <liquidengineer> I notice it runs a patch
18:35:30 <liquidengineer> did you change something?
18:35:35 <LoganCapaldo> S. O'Rear? Really?
18:35:43 <sorear> LoganCapaldo: yes
18:35:49 <dons> liquidengineer: hmm, I changed a few things( just performance tweaks)
18:35:50 <LoganCapaldo> heh
18:35:54 <mbishop> O'rly?
18:35:58 <sioraiocht> Any one of you familiar with the SoC project on developing a BSP library for Haskell?
18:36:02 <sorear> LoganCapaldo: how did you think it lexed?
18:36:02 <dons> liquidengineer: so as you make changes, you can 'darcs whatsnew' to see them.
18:36:06 <dons> darcs record and so on
18:36:17 <LoganCapaldo> I dunno
18:36:22 <dons> ?where soc
18:36:23 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
18:36:25 <liquidengineer> dons: wait...I just downloaded the file onto my desktop
18:36:31 <LoganCapaldo> mentally it was "I guess hes got an earache"
18:36:31 <dons> liquidengineer: hmm?
18:36:36 <dons> liquidengineer: did you 'darcs get ' ?
18:36:49 <liquidengineer> aye
18:37:12 <dons> ok. so it builds then?
18:37:32 --- mode: ChanServ set +o dons
18:37:37 <sorear> And thus we propagate D.A.R.C.S. onto one more helpless mortal's computer.
18:37:39 --- topic: set to '["The Haskell programming language: Summer of Code time!  http://hackage.haskell.org/trac/summer-of-code/","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
18:37:44 <LoganCapaldo> Is it me or does this room have a disproportionate number of "real name" nicks?
18:37:45 --- mode: ChanServ set -o dons
18:37:48 <liquidengineer> dons: you mean with GHC?
18:37:58 <dons> liquidengineer: yeah, e.g. ghc --make -O Main.hs
18:38:09 <sorear> LoganCapaldo: others have commented
18:38:26 * ddarius would be Derek but it's taken.
18:38:28 <sorear> LoganCapaldo: and the fake names we have are almost all obvious fakes
18:38:29 <desp> yowkle
18:38:43 <liquidengineer> okay
18:38:44 <liquidengineer> hold on
18:38:48 <ddarius> But my user name is properly set.
18:39:07 <sorear> LoganCapaldo: only exns I can think of are ddarius (D elkins) and vincenz (Christopher Poucet)
18:39:34 <sorear> (realistic looking fake names)
18:40:00 <liquidengineer> done
18:40:38 <liquidengineer> stack overflow
18:40:40 <liquidengineer> :)
18:40:56 <dons> good. now i note that if you comment out the stuff that calls tournament, we don't oflow.
18:41:03 <dons> so start at tournament, and work down.
18:41:07 <liquidengineer> okay
18:41:11 <dons> looking for suspicious recursive code
18:41:21 <liquidengineer> tournament itself is a recursive nightmare
18:41:41 <dons> liquidengineer: right. its still a bit dodgy.
18:42:36 <LoganCapaldo> Frosted Lambdas: They're suspiciously recursive
18:42:50 * LoganCapaldo wants a big bowl of frosted lambdas
18:43:08 <sioraiocht> They sound like sweet sugary goodness.
18:43:37 <liquidengineer> dons: did you re-write it?
18:43:47 <LoganCapaldo> no the sweet sugary goodness is chocalate flavored operator sections
18:44:08 <LoganCapaldo> I only eat that on the weekends
18:44:44 <dons> liquidengineer: a few things, yes.
18:44:51 <liquidengineer> ah
18:44:51 <dons> liquidengineer: you could vimdiff against your code bsae to see the changes
18:45:40 <anandrd> I had a question regarding the Haddock documentation tools?
18:45:48 <liquidengineer> okay
18:45:50 <anandrd> is there a way to make it resolve names in Prelude?
18:46:21 <dons> liquidengineer: here, http://www.cse.unsw.edu.au/~dons/tmp/diff.patch
18:46:24 <rubenz> For some reason I am having trouble defining an infix operator: "(:+:) :: Vertex -> Vertex -> Vertex". GHC says "Invalid type signature". Why?
18:46:26 <dons> that's the changes I've done.
18:46:37 <dons> anandrd: hmm, yes, you have to pass haddock the path to the base lib docs
18:46:42 <liquidengineer> dons: I didn't write tournament, to be honest, so I'm not really sure what do to to it, but I'm guessing even if it's inefficient it basically works (it worked before, according to the person who gave it to me).
18:46:47 <twanvl> Operators starting with a colon are data/type constructors
18:46:53 <dons> rubenz: hmm, looks like a type constructor
18:46:53 <liquidengineer> maybe it's play game and the functions it calls?
18:47:05 <kpreid> rubenz: ":" is the uppercase punctuation
18:47:05 <dons> rubenz: try, say, (.+.) :: ...
18:47:12 <LoganCapaldo> heheheh
18:47:19 <LoganCapaldo> : uppercase puntuation
18:47:32 <dons> liquidengineer: yeah, i was looking at playGame
18:47:40 <liquidengineer> which module is that in?
18:47:42 <liquidengineer> Game, right?
18:47:44 <LoganCapaldo> @remember kpreid ":" is the uppercase punctuation
18:47:45 <lambdabot> Done.
18:48:01 <dons> liquidengineer: its your code :-)
18:48:16 <dons> liquidengineer: anyway, you can see what changes I made in this diff, http://www.cse.unsw.edu.au/~dons/tmp/diff.patch
18:48:27 <dons> btw, you overuse ( )'s
18:48:39 <liquidengineer> dons: some are unnecessary/
18:48:40 <liquidengineer> ?
18:48:54 <anandrd> dons: you mean, the base docs of ghc?
18:49:33 <dons> liquidengineer: yeah.
18:49:33 <liquidengineer> I'm guessing ! and !$ force strict application?
18:49:43 <dons> anandrd: i believe so, you can link to the standard libs
18:49:45 <dons> liquidengineer: right.
18:49:46 <liquidengineer> dons: I figured as much on the parens, but they make things easier for me to read
18:54:02 <liquidengineer> okay
18:54:05 <liquidengineer> let's see....
18:54:22 <liquidengineer> It's always fun to try to debug code I didn't write.
18:54:27 <liquidengineer> (playGame, etc...)
18:54:51 <dolio> Haskell code?
18:56:18 <liquidengineer> yeah
18:56:29 <liquidengineer> this particular bit that seems to have the memory leak was given to me to use
18:56:33 <liquidengineer> wait a second.
18:56:38 <liquidengineer> dons: look at playGame
18:56:45 <liquidengineer> I see something odd.
18:56:51 <sjanssen> dons: have you tried jcreigh's patch yet?
18:56:52 <lambdabot> sjanssen: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:57:03 <dons> sjanssen: yes, running it now.
18:57:06 <dons> seems to work.
18:57:09 <dons> and its in the repos
18:57:20 <liquidengineer> dons: on line 49, the arguments m and n look reversed, if you take the u v arguments as an example
18:57:36 <sjanssen> it seems to have made something unstable
18:57:36 <liquidengineer> dons: could that be doing iot?
18:57:37 <liquidengineer> it?
18:57:52 <sjanssen> dons: what happens when you switch workspaces rapidly?
18:57:55 <dons> hmm.
18:58:05 <dons> sjanssen: nothing?
18:58:10 <dons> (with the new patch anyway)
18:58:32 <dons> sjanssen: with the initial patch i crashed on the first switch into a workspace, but that seems to be fixed
18:58:49 <dons> liquidengineer: maybe?
18:59:29 <liquidengineer> okay, I changed it.
18:59:33 <liquidengineer> do I run ghc again?
18:59:47 <dons> yeah, ghc --make -O Main.hs
18:59:49 <dons> then ./Main
18:59:55 <dons> or ./a.out, depending on your compiler
19:00:32 <ddarius> lines done
19:00:43 <liquidengineer> dons: no change; that wasn't it. ;)
19:01:31 <sjanssen> dons: yeah, that latest patch seems to fix it
19:01:47 <ddarius> liquidengineer: That wouldn't lead to a space leak (unless it did logically)
19:02:02 <liquidengineer> pairPlay is too simple to possibly be the problem...
19:02:06 <liquidengineer> right?
19:02:49 <sjanssen> hmm, there are some issues with killing windows too
19:03:27 <liquidengineer> dons: I noticed you added an a@ .... what does that do?
19:04:43 <dons> liquidengineer: just reuses the existing pair
19:04:48 <dons> rather than constructing a new one
19:05:06 <dons> so f (x,y) = (x,y)  --->  f a@(x,y) = a
19:05:11 <liquidengineer> ah
19:05:15 <liquidengineer> that makes sense
19:05:26 <liquidengineer> am I right in thinking it's probably too simple to be the problem?
19:08:30 <dons> yeas.
19:08:37 <kc5tja> @hoogle [[a]] -> [a]
19:08:37 <lambdabot> Prelude.concat :: [[a]] -> [a]
19:08:43 <dons> you'll be looking for recursive /loop code
19:08:50 <dons> or possibly a logical conditoin that causes code to loop
19:09:48 <liquidengineer> I notice helpPlayGame gets called a lot
19:10:47 <jcreigh> sjanssen: what happens WRT killing windows?
19:10:56 <liquidengineer> I'm trying to think up a way to test it
19:11:31 <Sgeo> "Indeed, it is possible to write coerce :: a -> b with the help of unsafePerformIO." -- http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.html
19:11:33 <lambdabot> http://tinyurl.com/23okjk
19:11:37 <Sgeo> How would I go about doing that?
19:11:44 <dons> Sgeo: you do it via IORefs, iirc
19:11:47 <desp> is there a tutorial for writing Haskell modules that interface with C code?
19:12:00 <Sgeo> And what would coerce do?
19:12:02 <dons> desp, the FFI spec, and any tutorials you find on the FFI
19:12:10 <desp> dons, thanks
19:12:20 <jcreigh> Sgeo: I think it would be a function that would take *any* a and return *any* b
19:12:27 <desp> @where ffi
19:12:27 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
19:12:51 <Sgeo> But if it were to be written using unsafePerformIO, what would it do? Just crash?
19:12:58 <allbery_b> likely
19:13:13 <liquidengineer> dons: this is probably a dumb question, but if tournament is my problem, then why does tournTest work?
19:13:14 <jcreigh> Sgeo: I imagine so, because you can't have meaningful translations for all type combinations.
19:13:19 <allbery_b> I've collected a few ghci cores from playing with it, and with the internal unsafeCoerce#
19:14:32 <sjanssen> jcreigh: create two windows on an empty workspace, switch to another workspace, then kill one.  At that point there is no window displayed
19:14:34 <petekaz> does ByteString.hGetLine strip the newline?
19:15:13 <sjanssen> jcreigh: but then press alt+j to switch windows
19:15:35 <sorear> petekaz: try it :)
19:15:57 <dons> sjanssen: yes.
19:16:05 <ddarius> Sgeo: unsafeCoerce x = unsafePerformIO (readIORef ref) where ref = unsafePerformIO (newIORef x)
19:16:07 <petekaz> I'm having a problem using the result of hGetLine in a case statement.
19:16:07 <dons> also, create 2 windows, try to swtich to another, and focus is lost
19:16:44 <hpaste>  petekaz pasted "can i do this in the case?" at http://hpaste.org/1013
19:16:45 <jcreigh> sjanssen: I see
19:17:00 <petekaz> ghc complains of overlapping patterns.
19:17:00 <jcreigh> sjanssen: I think I know how to fix it
19:17:28 <Sgeo> ERROR "coerce.hs":1 - Undefined variable "newIORef"
19:17:30 <sorear> petekaz: empty is a variable in this context
19:17:36 <sorear> Sgeo: import Data.IORef
19:17:56 <sorear> Sgeo: (also, hugs has somewhat outdated libs - be aware)
19:18:08 <sjanssen> jcreigh: and how does this work with multiple screens
19:18:13 <liquidengineer> dons: progress ... I've confirmed via sample data that helpPlayGame does NOT overflow when run
19:18:16 <petekaz> sorear: so I cannot do that?
19:18:19 <sorear> petekaz: you can't (usefully) pattern match on bytestrings, because it's an abstract type
19:18:27 <Sgeo> ERROR "coerce.hs":2 - Undefined variable "unsafePerformIO"
19:18:28 <liquidengineer> that's a good sign, right?  Can I rule it out as a potential problem area?
19:18:29 <petekaz> oh.
19:18:41 <sorear> petekaz: it sucks, and no less than three proposals for fixing it have been proposed
19:18:46 <sorear> petekaz: none adopted
19:18:50 <petekaz> how do I accomplish what I am trying?
19:18:52 <sorear> Sgeo: System.IO.Unsafe
19:19:11 <Sgeo> ty
19:19:19 <hpaste>  sorear annotated "can i do this in the case?" with "using interrogation functions" at http://hpaste.org/1013#a1
19:19:39 <petekaz> thanks.
19:19:50 <sorear> dons: woo! *scratch*
19:19:52 <ddarius> Sgeo: That wasn't quite right
19:20:26 <Sgeo> hm?
19:21:27 <sorear> Sgeo: you've just discovered that haskell+unsafePerformIO has a unsound type system ... the MLs, which unsafePerformIO everything, have a massively inclusive variant of the MR that trips everybody to save the typesystem
19:22:02 <liquidengineer> playGame works too...curious.
19:22:36 <jcreigh> hmm
19:23:09 <liquidengineer> is there anyway I can look at the stack?  See what's on it when it overflows?
19:23:27 <sorear> liquidengineer: not in ghc I believe
19:23:38 <sorear> liquidengineer: if you are desparate, gdb will tell you
19:23:48 <liquidengineer> will it give me something usable?
19:23:55 <liquidengineer> that is, something I can translate into a function name?
19:24:08 <sorear> liquidengineer: how quickly does the stack overflow?  slowly enough that you can ^C it?
19:24:18 <liquidengineer> not when compiled
19:24:21 <liquidengineer> but when interpretted, yes
19:24:36 <sjanssen> liquidengineer: you can get something similar to a stack trace
19:24:42 <liquidengineer> how?
19:24:47 <sjanssen> compile with profiling, then run with +RTS -xc
19:24:47 <sorear> liquidengineer: if you can get addresses from gdb/etc, addr2line will produce something that can be demangled
19:24:59 <liquidengineer> ...
19:25:00 <liquidengineer> cool
19:25:03 <sorear> sjanssen: does that work with hard failures like stack overflow?
19:25:05 <liquidengineer> how do I do that?
19:25:12 <sjanssen> sorear: oh, that's a good question
19:25:13 <sorear> ghc -prof -auto-all ...
19:25:23 <liquidengineer> sorear: what are those flags?
19:25:23 <sorear> ./a.out +RTS -xc
19:25:44 <ddarius> Sgeo: unsafeCoerce x = unsafePerformIO (writeIORef ref x; readIORef ref) where ref = unsafePerformIO (newIORef undefined)
19:25:44 <sorear> -prof enables profiling, -auto-all automatically instruments all top level functions
19:25:50 <ddarius> Er add a do
19:26:00 <liquidengineer> and the +RTS thing?
19:26:07 <sorear> liquidengineer: RTS options
19:26:10 <Sgeo> ddarius, whaere?
19:26:10 <ddarius> or replace ; with >>
19:26:30 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/runtime-control.html
19:26:32 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/2hoaa9
19:26:37 <sorear> @where+ +RTS http://haskell.org/ghc/dist/current/docs/users_guide/runtime-control.html
19:26:37 <lambdabot> Done.
19:26:40 <sorear> @where +RTS
19:26:40 <lambdabot> http://haskell.org/ghc/dist/current/docs/users_guide/runtime-control.html
19:26:50 <LoganCapaldo> ddarius: THANK YOU! I've been wondering forever how the heck you write "cast" with unsafePerformIO, I keep hearing that assertion and could never figure it out
19:26:57 <Sgeo> Main> :t unsafeCoerce
19:26:57 <Sgeo> unsafeCoerce :: a -> b
19:27:08 <liquidengineer> runtime stack size?
19:27:09 <liquidengineer> okayh
19:27:12 <sorear> :t GHC.Prim.unsafeCoerce#
19:27:14 <lambdabot> forall t b. t -> b
19:27:24 <jcreigh> sjanssen: well, I think I can either try to make sure that "refresh" is called everytime a window disappears, or I can change "view" to move all the windows to the right screen (like it used to do). Which seems better to you?
19:27:31 <sorear> liquidengineer: no, -xc says to generate stack traces when an exception is thrown
19:27:45 <sorear> liquidengineer: it's a crude hack, which uses the profiling info
19:27:47 <ddarius> unsafeCoerce "hello" :: Int
19:27:50 <sjanssen> jcreigh: view should probably move all windows to one screen
19:28:12 <sjanssen> jcreigh: when we have tiling view will have to move all windows anyway
19:28:21 <sjanssen> jcreigh: unless there's a reason you changed it?
19:28:52 <liquidengineer> sorear....okay
19:29:05 <liquidengineer> that sounds promising
19:29:15 <liquidengineer> I ran ghc with profiling and auto flags set
19:29:27 <liquidengineer> so now I run my program with this -xc thing, yes?
19:29:45 <jcreigh> sjanssen: nope, no real reason. I didn't think we needed "reveal", and I removed because otherwise I'd need to generalize it to handle moving and resizing. (since each screen is at a different origin and can be a different size.)
19:29:47 <Sgeo> Main> (unsafeCoerce "hi") + 5
19:29:47 <Sgeo> INTERNAL ERROR: Bignum expected
19:30:00 <liquidengineer> okay
19:30:01 <liquidengineer> done
19:30:09 <liquidengineer> I get the following
19:30:10 <liquidengineer> Main.main,Main.CAF
19:30:18 <jcreigh> hmmm....so when I tag a window to a different workspace...both screens will need to be updated...
19:30:21 <liquidengineer> what doe sit mean?
19:30:33 <jcreigh> lemme think about this for a bit
19:30:41 <sorear> Sgeo: that's hugs
19:30:47 <LoganCapaldo> liquidengineer: It means "arg!"
19:30:52 <sorear> Sgeo: interpreter with tag bits
19:31:00 <liquidengineer> LoganCapaldo: well, yes...
19:31:04 <Sgeo> sorear, 'tag bits'?
19:31:04 <liquidengineer> but is that useful information at all?
19:31:06 <liquidengineer> what's a CAF?
19:31:18 <sorear> liquidengineer: for some stupid reason ghc doesn't do cafs individually
19:31:19 <Saizan> liquidengineer: a caf is an 0 .arity binfing, like let caf = blah arg1 agr2 in etc..
19:31:35 <sorear> liquidengineer: try again with ghc -prof -auto-all -caf-all
19:31:42 <sorear> liquidengineer: then it should give more info
19:31:51 <sorear> Sgeo: runtime type information
19:32:07 <Sgeo> What would GHC do?
19:32:09 <sorear> Sgeo: if you tried that on ghci (no tag bits) your message would be
19:32:16 <sorear> Sgeo: "Segmentation fault"
19:32:20 <liquidengineer> should it recompile everything wehn I do that?
19:32:25 <sorear> liquidengineer: yes
19:32:29 <liquidengineer> it didn't.
19:32:36 <sorear> liquidengineer: -fforce-recomp then
19:32:45 <liquidengineer> where does that flag go?
19:32:48 <liquidengineer> first thing?
19:32:49 <sorear> liquidengineer: the recompilation checker isn't as smart as it could be
19:32:58 <sorear> liquidengineer: anywhere, this isn't POSIX :)
19:33:05 <liquidengineer> and I'm guessing that's one f on force?
19:33:13 <allbery_b> nope
19:33:15 <Saizan> 2
19:33:20 <allbery_b> -f + force-recomp
19:33:34 <liquidengineer> what's the first f mean?
19:33:42 <allbery_b> -f* are comp[iler optionns
19:33:44 <Saizan> flag?
19:33:52 <allbery_b> for examp[le -fglasgow-exts
19:33:54 <liquidengineer> ah
19:34:04 <liquidengineer> when why isn't it -fO?
19:34:07 <liquidengineer> aside from the obvious reason?
19:34:10 <liquidengineer> ;)
19:34:35 <allbery_b> (actually modifications of compiler behavior/selection of language options)
19:35:10 <chessguy> hi haskellers
19:35:23 <liquidengineer> ah
19:35:27 <liquidengineer> now it gives me this when I run
19:35:28 <liquidengineer> <Main.main,Main.CAF:lvl>
19:35:35 <liquidengineer> wtf?
19:35:58 <allbery_b> personally I suspect force-recomp shouldn't be a -f option, but...
19:36:17 <liquidengineer> what's it telling me here?  something about a level?
19:36:48 <sorear> lvl is a gensym :(
19:36:59 <sorear> re-run the compiler with -ddump-simpl
19:37:07 <sorear> that will show you the definition of lvl
19:37:20 <sorear> hopefully you'll be able to tell where it came from
19:37:28 <sorear> that's two d's :)
19:37:52 <liquidengineer> ....
19:37:54 <liquidengineer> a bunch of code is flying by
19:37:59 <liquidengineer> what's it doing?
19:38:04 <allbery_b> yeh, you need to capture it
19:38:13 <liquidengineer> I've got an incredibly large buffer
19:38:41 <sorear> well, try to understand the code  (and good luck...)
19:38:48 <liquidengineer> heheeh
19:38:50 <sorear> it's almost haskell
19:38:55 <liquidengineer> I've got a horrible feeling it's gonna tell me something I already know
19:38:57 <allbery_b> dump-simpl tells it to dump the "core syntax", i.e. the minimalist typeless Haskell subset the compiler guts actually speak
19:39:09 <liquidengineer> okay
19:39:10 <liquidengineer> it finished
19:39:21 <jcreigh> sjanssen: when we're doing tiling, we're going to have to call "refresh" (or equivilent) whenever a window appears or disappears, right? so just moving the windows into the background so they'll be there when something is unmanaged doesn't seem like it buys us anything in the long run.
19:39:34 <liquidengineer> what should I be looking for
19:39:38 <sorear> x @ y is type application (to resolve polymorphism), everything else is very haskell-ish
19:39:38 <liquidengineer> that lvl thing?
19:39:40 <sorear> yeah
19:40:34 <sorear> also, +# *# /# -# ... are ghc primops - they are to a -1th approx the same as their un-pounded counterparts
19:42:57 <sjanssen> jcreigh: having all the windows in the correct position will reduce flicker when a client dies
19:43:20 <liquidengineer> oh my god
19:43:22 <liquidengineer> they're everywhere
19:43:33 <sjanssen> jcreigh: but that isn't such a big deal, I guess.  You should write whatever you think is best
19:43:36 <liquidengineer> lvls, that is
19:43:39 <petekaz> Data.ByteString question, will 'bracket' catch exceptions from B.hGetLine?
19:43:41 <liquidengineer> should I be looking for main specifically?
19:43:47 <liquidengineer> err...in main
19:43:52 <jcreigh> sjanssen: it's your WM. :)
19:44:04 <LoganCapaldo> Is it possible to even write 1 :: Int# ?
19:44:21 <sjanssen> petekaz: bracket will catch all exceptions
19:44:38 <sjanssen> jcreigh: and you're writing the patch :).  Plus, I can always change anything I don't like
19:44:39 <allbery_b> wouldn't it be 1#?
19:44:53 <LoganCapaldo> that doesn't work
19:44:57 <sorear> LoganCapaldo: you just did it
19:45:01 <petekaz> what is wrong with this function then: http://hpaste.org/1013 (the second one)
19:45:07 <sorear> LoganCapaldo: "1 :: Int#"  Now I have too!
19:45:12 <LoganCapaldo> heh
19:45:34 <sorear> @ty bracket
19:45:37 <lambdabot> Not in scope: `bracket'
19:45:45 <jcreigh> sjanssen: heh. well, the dirt-simple fix to change "modify $ \s -> s { workspace = W.delete w (workspace s) }" to "windows $ W.delete w" Is there a reason unmanage wasn't using "windows" before?
19:45:48 <sorear> petekaz: what bracket are you using?j
19:45:50 <liquidengineer> [I have no idea where it's telling me to look
19:45:54 <liquidengineer> there's lvls everywhere
19:45:57 <liquidengineer> and most of them have numbers
19:46:02 <jcreigh> *is to change
19:46:16 <petekaz> Control.Exception
19:46:20 <petekaz> is that the right one?
19:46:38 <LoganCapaldo> @kind Int#
19:46:40 <lambdabot> Not in scope: type constructor or class `Int#'
19:46:45 <sorear> petekaz: I don't understand the code yet :)
19:46:47 <LoganCapaldo> Oh fine
19:46:50 <sorear> petekaz: so i don't know
19:46:56 <LoganCapaldo> lambdabot: hint, its Int# :: #
19:47:02 <sorear> @ty Control.Exception.bracket
19:47:04 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:47:10 <sorear> @kind GHC.Prim.Int#
19:47:12 <sjanssen> jcreigh: I can't think of any reason not to use windows there
19:47:12 <lambdabot> #
19:47:16 <LoganCapaldo> yay
19:47:39 <LoganCapaldo> @hoogle Int -> GHC.Prim.Int#
19:47:40 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
19:47:47 <jcreigh> sjanssen: okay, I'll submit that as a patch.
19:47:52 <LoganCapaldo> thats new and exciting
19:47:55 <LoganCapaldo> @hoogle Int -> GHC.Prim.Int
19:47:56 <lambdabot> No matches, try a more general search
19:47:57 <hpaste>  petekaz annotated "can i do this in the case?" with "non byte string version that does work" at http://hpaste.org/1013#a2
19:48:08 <jcreigh> sjanssen: BTW, who should I email patches to? you or dons? Or whoever happens to be online ATM?
19:48:11 <dufflebunk> Anyone used Phooey in a non-trivial program and can share the code?
19:48:13 <sioraiocht> anyone know about PVM libraries in haskell?
19:48:38 <sjanssen> jcreigh: whoever seems to be around at the time
19:48:44 <jcreigh> okay
19:49:19 <sorear> petekaz: it looks like it should work, provided you have newline = B.singleton 10 lying around somewhere
19:49:29 <sorear> (or '\n' if B is .Char8)
19:49:30 <petekaz> sorear: this function returns the topmost portion of a file up till a blank line, this corresponds to the header portion of an email.
19:49:43 <petekaz> B is Char8
19:49:52 <sorear> petekaz: I suppose I should tell people when I figure it out ;)
19:50:06 <sorear> beh, I missed newline
19:50:13 <liquidengineer> I don't understand
19:50:14 * sorear uses ghci to find the error
19:50:23 <hpaste>  petekaz annotated "can i do this in the case?" with "error when run" at http://hpaste.org/1013#a3
19:50:28 <liquidengineer> when I run the program it just says lvl
19:50:29 <liquidengineer> why not a number?
19:50:31 <liquidengineer> that'd be nice.
19:50:55 <petekaz> somehow my program seems to be terminating.
19:51:12 <sjanssen> petekaz: oh, bracket doesn't actually *catch* the exception
19:51:37 <liquidengineer> I've got profiling data don't I?
19:51:53 <liquidengineer> shouldn't I be able to look at that and see that an overflowing function is really, really badly performing?
19:52:08 <liquidengineer> 'cause I have no idea where to start looking with just lvl
19:52:11 <petekaz> sjanssen: ah.
19:52:15 <liquidengineer> there's too many of them
19:52:43 <sjanssen> petekaz: it just makes sure that an operation runs, whether an exception is thrown or not
19:53:47 <liquidengineer> wait!
19:53:49 <liquidengineer> I found it! :D
19:53:58 <liquidengineer> I passed it the first two times
19:54:05 <sorear> dons: this is wierd
19:54:07 <sorear> Prelude System.IO Data.ByteString> Data.ByteString.getLine
19:54:07 <sorear> *** Exception: no buffering
19:54:14 <jcreigh> sjanssen: patch sent. but if the flicker annoys you, let me know and I'll write a patch to move windows in an attempt to minimize that. seeing as how this is something that was working before I decided to hijack your project. :)
19:55:02 <dons> jcreigh: right...
19:56:05 <jcreigh> dons: ?
19:56:42 <dons> things that work, shouldn't not work ;)
19:57:12 <LoganCapaldo> @ty ((?a, ?b), ?c)
19:57:14 <lambdabot> forall t t1 t2. (?a::t, ?b::t1, ?c::t2) => ((t, t1), t2)
19:58:16 <robreim> Heh. I just realised that PortNumbers should be referenced directly without using the PortNum constructor from Network.Socket. No wonder my port numbers kept getting reverse-endian-ed...
19:58:20 <liquidengineer> I'm having some trouble making sense of this
19:58:33 <LoganCapaldo> @ty ?a -> ?b :: (?a :: Int, ?b :: Int ) => Int -> Int
19:58:35 <lambdabot> Parse error in pattern
19:58:38 <liquidengineer> if I put it in a pastebin, would someone mind helping me read it?
19:58:46 <jcreigh> well, using "windows" in "unmanage" should fix the disppearing windows problem. There just might be slightly more flicker than there used to be when you switch from workspace A to workspace B, then back to workspace A, then switch windows in workspace A. at least, that's my understanding. <g>
19:58:49 <sorear> liquidengineer: no
19:59:05 <liquidengineer> sorear: no don't put it in, or no you don't mind?
19:59:08 <liquidengineer> (sorry, I'm tired.)
19:59:23 <LoganCapaldo> @ty f :: (?a :: Int, ?b :: Int ) => ?a -> ?b
19:59:24 <sorear> liquidengineer: snd
19:59:26 <lambdabot> parse error on input `->'
19:59:31 <liquidengineer> lol
19:59:33 <liquidengineer> okay
19:59:34 <liquidengineer> @paste
19:59:34 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:00:21 <hpaste>  liquidengineer pasted "The overflowing code." at http://hpaste.org/1014
20:00:23 <emk> OK, I seriously underestimated the amount of work required to write a category theory tutorial for functional programmers. :-)
20:00:54 <LoganCapaldo> woah
20:01:02 <LoganCapaldo> why did I click that paste?
20:01:06 * LoganCapaldo despairs
20:01:18 <petekaz> is there a way to use Text.Printf with ByteStrings?
20:01:21 <liquidengineer> LoganCapaldo: despairs with you
20:01:29 <emk> I've covered arrows, objects, functors, and natural transformations, but I still need to explain duals. And edit everything. And write a nice bibliography.
20:01:32 * emk whimpers
20:01:57 <LoganCapaldo> emk: I'll send you 2$ if you finish it so I can read it
20:02:40 <LoganCapaldo> Is that sufficient incentive, or just insulting? :)
20:02:48 <emk> LoganCapaldo: If you promise not to post it to reddit, I can /msg you the URL.
20:03:09 <emk> I want to finish it before it starts getting passed around too much. :-)
20:03:23 <jcreigh> all right...now I can use xmonad as my primary WM! tiling would be nice, but I have 3 monitors, so I can make do without until someone implements it.
20:03:27 <LoganCapaldo> I do solemnly swear not to post it to reddit
20:03:28 <sorear> beh, I'm not understanding this core
20:03:52 <sorear> I'd wait till dons gets back , /me gives up :(
20:04:26 <jcreigh> sjanssen++
20:04:30 * desp airs
20:04:44 <liquidengineer> lol
20:04:50 * emk groans
20:04:51 <liquidengineer> sorear: any ideas?
20:05:02 <sorear> liquidengineer: nope.
20:05:08 <desp> emk: can I have the URL as well? :)
20:05:10 <liquidengineer> It's not telling us anything useful, is it?
20:05:13 <sorear> liquidengineer: Can you control the data set size?
20:05:14 <sorear> liquidengineer: no
20:05:17 <liquidengineer> I already knew it failed in main
20:05:21 <liquidengineer> sorear: howso?
20:05:24 <LoganCapaldo> desp: He's holding out on us ;)
20:05:34 <liquidengineer> I've already made it pretty much as small as possible.
20:05:42 <emk> LoganCapaldo, desp: I'm looking for feedback on the overall structure and the examples. I know the intro is useless and the prose still needs a good edit.
20:06:13 <sorear> liquidengineer: it suggests the problem may be in the initializedData - can you doublecheck that?
20:06:29 <sorear> liquidengineer: like 5 generations vs. 500 generations
20:06:47 <sorear> liquidengineer: if you set the dataset as small as it will go, does it run in finite stack?
20:07:00 <desp> emk: sure, if I can grok the contents I'll give you feedback
20:07:15 <emk> LoganCapaldo, desp: But if there's someplace that you just get completely lost, I'd love to know where so I can fix it.
20:07:49 <LoganCapaldo> I would be pleased too
20:08:25 <desp> @where xmonad
20:08:25 <lambdabot> darcs get http://darcs.haskell.org/~sjanssen/xmonad
20:09:03 <hpaste>  petekaz pasted "dumb question" at http://hpaste.org/1015
20:09:04 <emk> desp, LoganCapaldo:: I'm trying to make it as accessible as humanly possible--I'm sort of hoping that (say) a Ruby programmer who's messed around with functional programming could more-or-less puzzle out what's going on.
20:09:21 * LoganCapaldo is a ruby programmer, messing around
20:09:23 <LoganCapaldo> heh
20:09:47 <emk> There's already an abundance of _really hard_ category theory texts out there.
20:10:15 * emk wishes he had several terms of abstract algebra and more experience with reading math
20:10:37 <liquidengineer> dons: still there?
20:10:49 <ddarius> The basics of abstract algebra are straightforward enough.
20:10:51 <liquidengineer> sorear: yeah, I will.
20:11:02 <ddarius> It can get very hard, but that's something else.
20:11:24 <narain> emk: i tried reading patryshev's intro to monads via category theory
20:11:39 * dolio took two semesters of abstract algebra and still finds reading Basic Category Theory for Computer Scientists non-trivial.
20:11:56 <emk> ddarius: Oh, yeah. But if you haven't had at least an undergraduate course in it (and made the jump to "thinking like a mathematician"), it's an awfully big hunk of background knowledge to be missing.
20:12:40 <LoganCapaldo> dolio: You discourage me
20:12:45 <narain> math texts would be a lot more accessible if they included some motivating examples
20:12:51 <emk> Once I find a nice, concrete model for something, I usually figure it out pretty quickly.
20:12:52 <LoganCapaldo> I was gonna buy that eventually it being only 25 odd dollars
20:13:00 <liquidengineer> sorear: initializedData runs fine...but I'm recompiling with the smallest possible data set anyway
20:13:06 <emk> LoganCapaldo: It's actually pretty good.
20:13:07 <liquidengineer> I had a thought
20:13:11 <LoganCapaldo> but I have had no semesters of abstract algebra
20:13:23 <liquidengineer> dons thought the error was happening in tournament
20:13:44 <liquidengineer> but tournament runs fine when I test it
20:13:50 <dolio> LoganCapaldo: I bought it for the same reason, but I don't know how good it is.
20:13:52 <liquidengineer> that is, call it by istelf
20:13:53 <emk> LoganCapaldo: Well, I had zero abstract algebra when I read it, and managed to muddle through.
20:14:30 <emk> narain: Did you see that GFDL'd linear algebra textbook from the professor in Vermont? That has really awesome motivating examples.
20:14:35 <dolio> LoganCapaldo: I've heard that it's generally better to struggle through "Math X for Mathematicians" than to buy something like "Math X for Other Majors."
20:14:57 <LoganCapaldo> Mmm
20:15:07 <narain> emk: i think i've heard of the one you're talking about but i haven't gone through it myself
20:15:11 <liquidengineer> so, if tournament works when called by itself, doesn't that mean the problem cannot be in tournament?
20:15:29 <LoganCapaldo> I suspect I'm probably better at math than I want to give myself credit for heh
20:15:32 <emk> dolio: I have a certain fondness for books which say, "Well, you may not be a mathematician now, but you're certainly expected to be one by the end of the book."
20:15:34 <LoganCapaldo> So maybe thats a good idea
20:15:45 <desp> emk: I downloaded that algebra textbook and put in on my todo list :)
20:16:04 <dolio> But I've never seen another category theory text, so I have no comparison, aside from one that seemed like it was written for someone in high school, so was a bit less than detailed.
20:16:30 <emk> "The Haskell Road to Logic, Maths and Programming" is a lovely example of the genre: It assumes nothing beyond high-school algebra, but attempts to give the reader a solid grounding in abstract algebra.
20:16:43 <emk> s/abstract algebra/discrete math/
20:17:34 <emk> The books that aren't so useful are the ones aimed at non-mathematicians that _aren't_ secretly trying to turn their readers into a mathematicians.
20:18:16 <LoganCapaldo> I <3 discrete math
20:18:19 <emk> http://www.randomhacks.net/articles/2007/03/07/hefferon-linear-algebra-review
20:18:21 <lambdabot> Title: Jim Hefferon's Linear Algebra: A free textbook with fascinating applications, http://tinyurl.com/2onbsw
20:18:37 <petekaz> Any takers for my question, I promise, its a yes/no question.
20:18:55 <petekaz> http://hpaste.org/1015
20:19:09 * emk only writes blog posts so he can explain something once and just give people a URL from then on
20:19:14 <liquidengineer> It just doesn't add up for me
20:19:26 <liquidengineer> every constitutent function of crossover_mutate works *when called alone*
20:19:27 <narain> emk: i applaud your strategy
20:19:42 <liquidengineer> but when the function that combines them is used, it's a no go.
20:20:07 <bos> petekaz: that's implementation dependent.
20:21:00 <petekaz> bos: ok. best practice would be to define 'newline' at the top-level then?
20:21:06 <liquidengineer> what would cause something like that?
20:21:47 * narain wishes he had never learned linear algebra so he could properly enjoy hefferson's book
20:21:53 <bos> petekaz: easiest thing to do is look at the output of ghc and see if it's going to memoise the result :-)
20:22:26 <narain> s/hefferson/hefferon/
20:22:27 <petekaz> bos: look at the output?
20:22:30 <bos> even at the top level, ghc could decide to inline it and effectively evaluate it once per inlining site.
20:22:55 <petekaz> bos: you mean look at assembly?
20:23:05 <bos> petekaz: no, not assembly
20:23:29 <bos> i need to look up the term, because i've just forgotten it.
20:23:38 <liquidengineer> at least now I know what's NOT doing it.
20:23:46 <dolio> Seems unlikely that ghc would choose to inline that at the top level.
20:24:01 <dolio> Since using CAFs at the top level to memoize things is standard practice.
20:24:12 <petekaz> CAF?
20:24:38 <liquidengineer> @paste
20:24:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:25:28 <bos> petekaz: i think you might want -ddump-simpl, but i don't fiddle with that stuff enough to have it at my fingertips.
20:25:35 <bos> and a caf is a constant applicative form.
20:25:44 <emk> narain: If your linear algebra is solid, it's still worth skimming Hefferon's book for the notes on applications. There's a lot of fun stuff there!
20:26:14 <hpaste>  liquidengineer pasted "crossover_mutate" at http://hpaste.org/1016
20:26:48 <bos> @seen dons
20:26:48 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 30m 6s ago.
20:26:51 <narain_> emk: yeah, but i'll keep hearing this voice in the back of my head all the time saying "why am i reading this, i know all this already, dammit"
20:27:02 <bos> dons could answer this in a few seconds.
20:27:25 <desp> emk, so... have you decided not to share the preliminary version of your category theory post after all? :)
20:27:30 <emk> bos: Can't dons answer everything in a few seconds?
20:27:35 <liquidengineer> dons is awesome.
20:27:36 <emk> desp: Did you not get the URL?
20:27:39 <desp> nope
20:27:40 <liquidengineer> :)
20:27:42 <liquidengineer> could he perhaps really be donatello?
20:27:54 <emk> Check your private channel messages.
20:28:04 <desp> I didn't get any private messages.
20:28:07 <emk> LoganCapaldo: Did you get the URL?
20:28:15 <LoganCapaldo> no
20:28:20 <emk> Hmmm.
20:28:20 <LoganCapaldo> emk, are you registered?
20:28:25 <bos> emk: pretty much :)
20:28:26 <desp> emk: you need to identify with NickServ
20:28:32 <desp> in order to send privmsgs on freenode
20:28:44 <LoganCapaldo> what desp said
20:28:56 <bos> emk: afraid of someone posting it to reddit before it's cooked? :)
20:29:06 <emk> bos: Pretty much. :-)
20:29:06 <narain_> emk: ah wait. he has bits on applications set out separately as "topics". maybe i should go through those then. cool :)
20:29:24 <sorear> all the cool people register ;)
20:29:52 <liquidengineer> I'm registered. :)
20:29:56 <liquidengineer> Does this mean I'm cool?
20:30:05 <bos> what part of "a monad is an endofunctor on the category of morphisms" hasn't the blogosphere already absorbed?
20:30:17 <desp> liquidengineer: since you appear to have liquified, I'd wager a yes
20:30:22 <hpaste>  sorear pasted "gadts with deriving? " at http://hpaste.org/1017
20:30:30 <narain_> bos: drop 4
20:30:34 <LoganCapaldo> bos: I think its the "a monad..." part
20:30:42 <sorear> can this work?
20:30:44 <liquidengineer> desp: at least you don't think I'm a beer expert or an alcoholic
20:30:50 <liquidengineer> sometimes this nick is more trouble than it's worth
20:30:52 <emk> OK, everybody who wants to look at a draft category theory tutorial, and who promises not to post it to reddit, join me in #categorytheory. :-)
20:31:00 <desp> hah!
20:31:29 <emk> sorear: Hmm. NickServ doesn't seem to be liking my password.
20:36:11 <sorear> ?
20:36:11 <sorear> emk: it has rules?
20:36:11 <sorear> emk: or, you're registered and you don't know your pw?
20:37:16 <sorear> @botsnack
20:37:17 <lambdabot> :)
20:39:06 <liquidengineer> I've gotta go. :(
20:39:18 <liquidengineer> Later. :D
20:44:55 <kc5tja> @where implementation
20:44:55 <lambdabot> I know nothing about implementation.
20:47:21 <sorear> kc5tja: you want ifpl?
20:47:31 <kc5tja> nope
20:47:31 <sorear> @google slpj-book-1897
20:47:32 <lambdabot> No Result Found.
20:47:35 <sorear> @google slpj-book-987
20:47:36 <lambdabot> No Result Found.
20:47:38 <sorear> @google slpj-book-987
20:47:39 <lambdabot> No Result Found.
20:47:42 <sorear> @google slpj-book-1987
20:47:43 <lambdabot> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
20:47:43 <lambdabot> Title: The Implementation of Functional Programming Languages
20:47:45 <sorear> beh fingers
20:48:04 <sorear> implementing functional languages: a tutorial?
20:48:20 <kc5tja> Nope.
20:48:28 <kc5tja> I was testing something, is all.
20:50:02 <emk> sorear: I don't seem to know my password, even assuming it's mine.
20:50:34 <emk> sorear: My IRC client has been dealing with NickServ behind the scenes and not showing me the errors.
20:51:13 <emk> sorear: I've been using this nick for years now without running into another emk, but it's entirely possible that I'm squatting on someone else's nick.
20:51:19 <sorear> emk: you ever heard of new skies networks?
20:52:15 <ray> emk was registered 3 years ago
20:52:18 <sorear> and/or do you live in tanzania?
20:52:24 <ray> at least, nickserv says that..and services here like to screw up the time
20:52:26 <ray> :)
20:53:55 <emk> Hmm. I've been #emk here for way longer than 3 years. I thought I'd registered my nick back in the dawn of time. I shall need to investigate. :-(
20:54:13 <sorear> emk: emk last id'd to nickserv 21 hours ago, you were in #haskell at the time
20:54:48 <emk> sorear: Huh? I doubt it was me that ID'd.
20:55:06 <emk> On the other hand, I was chatting with Philippa using /msg for quite a while.
20:55:13 <emk> Now I'm confused. :-(
20:55:22 <sorear> emk: do you live in Tanzania and/or have heard of newskies networks?
20:55:38 <emk> sorear: No and no.
20:55:38 <kc5tja> The only way for /msg to work on this IRC network is if you were ID'ed.  :)
20:55:43 <sorear> kc5tja: wrong!
20:55:46 <Sgeo> `IO a` doesn't have a constructor?
20:55:48 <sorear> kc5tja: umode +6
20:56:24 <sorear> eg. emk can message me
20:56:28 <ddarius> I /msg people all the tiem.
20:56:32 <kc5tja> Sgeo: return a should do it, assuming you're running inside a monadic function of some kind (e.g., main, or anything else that returns IO a)
20:56:50 <Sgeo> But not a pattern-matching constructor?
20:57:18 <kc5tja> You'd need to have something specific for a; I don't think you can match on a generic 'a'.
20:58:01 <Sgeo> Can I match an `IO String`?
20:58:43 <kc5tja> Nope, I don't think so.
20:59:02 <kc5tja> You'll have to do something like:
20:59:07 <kc5tja> foo <- someIOresult
20:59:10 <kc5tja> case foo of
20:59:15 <kc5tja>   ..pattern match on foo here..
21:00:30 <ekidd> sorear: Ah, they claim to unregister nicks after 60 days inactivity, sometimes. That would explain why my ancient password from the dawn of time no longer works.
21:01:27 <bos> they don't unregister nicks unless someone asks them to.
21:01:46 <sorear> ekidd: did you assoc an email with emk?
21:01:51 <bos> that's how i got bos. previous bos hadn't used it in about 2 years.
21:02:06 <sorear> bos: you're not registered
21:02:17 <sorear> *identified
21:02:54 <ekidd> sorear: I first used freenode so long ago I couldn't possibly remember. :-(
21:02:58 <bos> i often forget.
21:03:36 <magnus_> @pl \a b->compare (length a) (length b)
21:03:36 <lambdabot> (. length) . compare . length
21:03:50 <sorear> cute erc feature:
21:03:50 <sorear> <*bos> that's how i got bos. previous bos hadn't used it in about 2 years.
21:03:50 <sorear> ...
21:03:50 <sorear> <bos> i often forget.
21:04:01 * kc5tja used freenode back when it was still linpeople.org.  :)
21:05:24 <Sgeo> Are there non-monadic polymorphic types around?
21:05:42 <sorear> sure
21:05:46 <sorear> @ty 2
21:05:48 <lambdabot> forall t. (Num t) => t
21:05:48 <sorear> @ty id
21:05:51 <lambdabot> forall a. a -> a
21:06:15 <Sgeo> Um
21:06:21 <sorear> @ty showParen
21:06:24 <lambdabot> Bool -> ShowS -> String -> String
21:06:33 <Sgeo> I meant like `Maybe a` except not a monad
21:07:00 <jcreigh> Sgeo: yes
21:07:49 <jcreigh> data Tree a = Leaf a | Branch (Tree a) (Tree a)
21:08:05 <jcreigh> (of course, you can define an instance of Monad for that data structure. but you don't have to)
21:08:44 <jcreigh> or did you mean, for which there is no reasonable definition of a monad?
21:09:17 * Sgeo now asks given jcreigh's meaning, due to his curiosity
21:10:03 <jcreigh> well, it's trivial to define a polymorhpic type without giving an instace of Monad
21:12:04 <jcreigh> but for the Tree example I gave, there is a very natural definition of Monad
21:12:18 <shachaf> type T a = (MonadPlus m) => a -> (a,m a)
21:12:21 <shachaf> Oops.
21:13:26 <ddarius> @google free monad derek elkins
21:13:28 <lambdabot> http://lambda-the-ultimate.org/node/1183
21:13:29 <lambdabot> Title: The Haskell Programmer&#039;s Guide to the IO Monad --- Don&#039;t Panic | Lambd ...
21:13:54 <roconnor> @google free derek elkins
21:13:56 <lambdabot> http://www.artistdirect.com/nad/music/artist/card/0,,1190198,00.html?src=search
21:13:56 <lambdabot> Title: Derek ELkins - Free Music Downloads, Videos, Lyrics, CDs, MP3s, Bio, Merchandise ...
21:14:41 <jaredj> oh noes, the link is broken
21:16:06 <magnus_> @pl \a b->compare (length b) (length a)
21:16:07 <lambdabot> flip (compare . length) . length
21:16:46 <mauke> @pl \length a b->compare (length b) (length a)
21:16:46 <lambdabot> (.) =<< flip . (compare .)
21:23:50 <jaredj> :t max
21:23:52 <lambdabot> forall a. (Ord a) => a -> a -> a
21:36:01 <jaredj> mleh.
21:36:04 <jaredj> http://sequence.complete.org/node/263
21:36:06 <lambdabot> Title: Dynamic Programming in Haskell | The Haskell Sequence
21:36:14 <jaredj> anyone know where there's an .lhs for that?
21:45:07 <kc5tja> Heh, it looks like the body of the webpage *is* an lhs for it.
21:45:25 <jaredj> it is, but it won't paste properly :(
21:45:35 <jaredj> i typed out the code
21:47:04 <stepcut> I figured out why that nim thing is stack overflowing
21:47:10 <jaredj> AGH NIM
21:47:18 * jaredj runs away screaming
21:47:43 <merus> NIM! :D
21:47:47 <jaredj> NOOO
21:47:53 <jaredj> NO SHRUBBERIES
21:47:59 <stepcut> here is my awesome fix:
21:48:00 <stepcut> hunk ./NimPlayer.lhs 44
21:48:00 <stepcut> +	a <= b  = (playerID a)  <= (playerID b)
21:48:04 <stepcut> yay!
21:48:05 <sorear> neep!
21:48:26 <jaredj> no, you're not doing it properly, it's nim. nim
21:48:47 <stepcut> the Ord instance for NimPlayer does not meet the minimum requirements for a complete Ord instance
21:49:01 <stepcut> "Minimal complete definition: either compare or <=."
21:49:20 <jaredj> is it Eq too?
21:49:59 <dmwit> :t compare
21:50:01 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
21:50:18 <dmwit> Not helpful...
21:50:37 <kc5tja> :t Ordering
21:50:39 <lambdabot> Not in scope: data constructor `Ordering'
21:50:45 <kc5tja> @src Ordering
21:50:45 <lambdabot> data Ordering = LT | EQ | GT
21:50:46 <jaredj> well - an Ordering is a nice type instead of -1, 0, or 1 like e.g. in python
21:50:52 <dmwit> More helpful. =)
21:52:08 <stepcut> jaredj: there is an Eq instance for NimPlayer, but apparently < and == are not enough, but <= is...
21:52:32 <jaredj> henh
21:52:40 <sorear> here's why: vvv
21:52:43 <sorear> @src compare
21:52:43 <lambdabot> compare x y | x == y    = EQ
21:52:43 <lambdabot>             | x <= y    = LT
21:52:43 <lambdabot>             | otherwise = GT
21:52:53 <sorear> that's the defl. method
21:53:01 <jaredj> vvv? what kind of reason is that
21:53:24 * jaredj listens for groans
21:53:41 <sorear> |   |
21:53:41 <sorear> |   |
21:53:41 <sorear>  \ /
21:53:41 <sorear>   Y
21:53:46 <jaredj> lol
21:54:14 <ddarius> string diagram
21:54:14 <merus> v.v.v.v.v.?
21:55:52 <stepcut> @src (<=)
21:55:53 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
21:56:32 <stepcut> there is the other half -- if neither compare nor <= are defined, then they just call each other till things explode
21:59:06 <sorear> and this was liquidengineer's problem?
21:59:06 <sjanssen> @v
21:59:07 <lambdabot> "\""
21:59:17 <sorear> and I made him go all the way to core?
21:59:23 <mgsloan> glguy - had a chance to mess with the error handling stuff?
21:59:55 * sorear sticks his face in a corner and engages in depressedy stuff
22:00:42 <ddarius> I want to do that sometimes, but for far more significant reasons than pointing someone at core.
22:00:53 <sjanssen> sorear: I've been gone for a couple hours -- is this the same stack overflow problem we were talking about two-ish hours ago?
22:01:10 <sorear> sjanssen: yes
22:01:26 <sjanssen> ouch!
22:01:35 <sorear> sjanssen: and he left 1.5h ago!
22:01:42 <Pastorn> @seen cantadou
22:01:43 <lambdabot> I haven't seen cantadou.
22:02:02 <anandrd> How does one achieve defensive programming in haskell?
22:02:16 <ddarius> anandrd: Don't use unsafe*
22:02:21 <anandrd> what if I am defining a function which got illegal input. how should i fail?
22:02:25 <sorear> error
22:02:31 <mauke> mzero
22:02:46 <jaredj> you should define the types it takes so it's impossible to represent wrong values in them
22:02:59 <sorear> if you want to catch the error, use Maybe or Either
22:03:01 <sorear> and read
22:03:06 <sorear> @go emk 8 ways
22:03:08 <lambdabot> http://programming.reddit.com/user/emk/
22:03:08 <lambdabot> Title: overview by emk (on programming.reddit.com)
22:03:14 <anandrd> jaredj: Hmm... is that always possible?
22:03:14 <sorear> @go eric kidd 8 ways
22:03:18 <jaredj> maybe not
22:03:28 <sorear> anandrd: yes.
22:03:30 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
22:03:37 <jaredj> but i'm still having lots and lots of fun with types
22:03:59 <anandrd> sorear: for example I was defining a type (Num a) => (Term a) , representing terms of polynomials
22:04:03 <sorear> anandrd: http://hpaste.org/522#a1
22:04:08 <anandrd> but for that the exponent had to be non-negative
22:04:41 <sorear> It does eventually become easier just to write partial functions :)
22:05:11 <ddarius> anandrd: The type level is Turing complete (enabling various extensions) so technically, you could encode any specification into it.
22:05:15 <sorear> @go eric kidd 8 ways
22:05:16 <lambdabot> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
22:05:16 <lambdabot> Title: 8 ways to report errors in Haskell
22:05:18 <stepcut> epigram!
22:05:21 <sorear> @activity-full 120
22:05:21 <lambdabot> 5*total 3*#haskell 2*nmessenger
22:05:27 <sorear> @activity-full 600
22:05:27 <lambdabot> 11*total 9*#haskell 2*nmessenger
22:05:43 <jaredj> ddarius: *gape*
22:05:49 <nmessenger> ?
22:05:58 <sorear> jaredj: it's common knowledge
22:06:05 <jaredj> sorear: number of seconds to look back?
22:06:09 <sorear> @quote leg.*log
22:06:10 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
22:06:18 <jaredj> haha
22:06:30 <jaredj> he's too kind
22:06:39 <sorear> http://haskell.org/haskellwiki/Type_SK
22:06:40 <jaredj> *snrk*
22:06:40 <lambdabot> Title: Type SK - HaskellWiki
22:07:42 <kc5tja> My Haskell-fu is not strong today.
22:08:11 <bos> does anyone ever use ST for anything these days?
22:08:15 <jaredj> my haskell-fu is yellow-belted
22:08:28 <sorear> bos: yes...
22:08:54 <sorear> bos: the entire ghc immutable array system runs on runST and unsafeFreeze
22:09:13 <mauke> what's freeze?
22:09:14 <desp> @quote OlegFacts
22:09:14 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
22:09:16 <bos> oh, i'd forgottent that.
22:09:23 <desp> only one fact? meh
22:09:44 <desp> @anticookie
22:09:44 <lambdabot> Unknown command, try @list
22:09:48 <bos> mauke: it's what you use to get an array back out of the ST monad so you can use it.
22:09:59 <jaredj> @botsmakc
22:09:59 <lambdabot> Unknown command, try @list
22:09:59 <sorear> @type Data.Array.unsafeFreeze
22:10:01 <jaredj> ?
22:10:01 <lambdabot> Not in scope: `Data.Array.unsafeFreeze'
22:10:02 <ddarius> Just because State Threads are almost as old as Haskell doesn't mean they are obsolete.
22:10:15 <jaredj> @type unsafeWorshipSatan
22:10:17 <lambdabot> Not in scope: `unsafeWorshipSatan'
22:10:23 <mauke> @botsmack
22:10:24 <lambdabot> :)
22:10:48 <jaredj> that's like those african warriors that laughed when you hurt them
22:11:09 <bos> ddarius: sure. there's lazy ST, which you can't emulate with IO.
22:12:35 <ddarius> None of ST can be emulated with IO without using unsafePerformIO.
22:13:02 <bos> really?
22:13:24 <sjanssen> you can do ST with unsafeCoerce#
22:13:47 <sjanssen> oh, I missed the "with IO" part
22:13:49 <kc5tja> :type takeWhile
22:13:58 <kc5tja> :t takeWhile
22:14:01 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:14:10 <desp> sigh
22:14:31 <desp> every time I read LtU I feel that I don't know a thing
22:14:40 <sorear> I don't read LtU
22:14:41 <bos> that's a good feeling.
22:14:42 <jaredj> haha me too
22:14:48 <kc5tja> desp: That's good.  The more that happens, the more you'll eventually know.
22:14:53 <bos> every time ddarius says something, it's confirmed that i don't know a thing :-)
22:14:58 <kc5tja> In martial arts, that's called 'beginners mind.'
22:15:04 <desp> :)
22:15:15 <sorear> unfortunately I've lost mine
22:15:25 <jaredj> the beginner part or the mind part? :)
22:15:49 <sorear> fst
22:16:03 <jaredj> meh you've got time
22:16:11 <sjanssen> snd
22:16:18 <ddarius> bos: Luckily, through the magic of static typing, there really isn' really a difference between (strict) ST and IO and you could easily wrap IORefs/IO to make ST, you just need unsafePerformIO to implement runST.
22:16:41 <jaredj> sorear: the scary part is when you don't know anything and you don't know if you really have time to learn it
22:16:49 <bos> ddarius: ok, so i wasn't far off track. thanks.
22:16:59 <sorear> couldn't lazy ST be implemented using unsafeInterleaveIO?
22:17:00 <ddarius> Rampant use of unsafeInterleaveIO might be able to make lazy ST.
22:17:10 <bos> @quote stereo
22:17:11 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
22:17:58 <ddarius> @quote to
22:17:58 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
22:17:59 <ddarius> @quote to
22:18:00 <lambdabot> metaperl says: if you type check every suitor, you are bound to find an inconsistency somewhere... just get in there and get it over with!
22:18:02 <bos> using unsafeInterleaveIO makes me feel like a teenager sneaking out of their bedroom window at midnight/.
22:18:09 <sorear> ddarius: there are two kinds of unsafePerformIO.  you get strict ST from strict unsafePerformIO, and lazy ST from lazy unsafePerformIO.
22:18:14 <sorear> strict uPIO:
22:18:17 <sorear> @src unsafePerformIO
22:18:17 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
22:18:21 <sorear> lazy uPIO:
22:18:43 <sorear> er, this won't work after all
22:18:49 <bos> um, what?
22:18:57 <sorear> oh, *duh*
22:19:06 <sorear> the problem is State# is unlifted
22:19:06 <edwardk> @seen ski
22:19:06 <lambdabot> ski is in #haskell. I last heard ski speak 1d 5h 33s ago.
22:19:22 <sorear> if State# were lifted, you could have strict and lazy
22:19:24 <sorear> strict:
22:19:35 <sjanssen> @remember bos using unsafeInterleaveIO makes me feel like a teenager sneaking out of their bedroom window at midnight/.
22:19:36 <lambdabot> Done.
22:19:48 <sorear> unsafePerformIO (IO m) = case m RealWorld__ of (st, r) -> st `seq` r
22:19:50 <sorear> lazy:
22:19:53 <sorear> unsafePerformIO (IO m) = case m RealWorld__ of (st, r) -> r
22:20:19 <kc5tja> Dang it; it's looking like I simply *have* to use a state monad for what I'm looking to do.  :(
22:20:52 <bos> ddarius: how long have you been working in haskell?
22:21:58 <jaredj> kc5tja: so much for libertarian programming (;
22:22:20 <kc5tja> jaredj: My mind must not be in the right frame of mind to get the joke.
22:22:41 <jaredj> [libertarians want no state]
22:22:54 <kc5tja> I'm trying to make a parser for a list of input tokens of various kinds.  Some tokens are used to create multiple nesting levels.
22:22:55 <emu> i thought that was anarchist
22:23:10 <sorear> jaredj: thank you.  my punniness feels a lot better about itself.
22:23:11 <jaredj> depends on whom you ask
22:23:12 <kc5tja> emu: There are two dimensions to the political map.
22:23:16 <jaredj> sorear: haha
22:23:23 <ddarius> bos: This was very near the beginning of my Haskell adventure http://www.programmersheaven.com/c/MsgBoard/read.asp?Board=3&MsgID=159284
22:23:26 <lambdabot> Title: Re: What's your opinion?, http://tinyurl.com/yqe4qh
22:23:26 <emu> .oO new idea for functional programming language name: Anarchy
22:23:39 <araujo> hello
22:23:41 <jaredj> emu: e.g. stefan molyneux claims to be a libertarian but wants no state
22:23:51 <jaredj> emu: he talks a lot.
22:24:24 <sorear> kc5tja: somehow doubt that.  when I have more motivation I'm going to feed the political spectrum into a self-organizing map and calculate the true number of dimensions.  I'll accept that it's >2; I believe its >>3
22:24:57 <stepcut> @type (>> 3)
22:24:59 <lambdabot> forall (m :: * -> *) a b. (Num (m b), Monad m) => m a -> m b
22:25:14 <sorear> kc5tja: [on parser] sounds similar to something I've been tring to figure out how to do.  how does your system work?
22:25:25 <kc5tja> sorear: True, but it's patently clear that libertarianism and anarchism both want a stateless society, differing only in their ideal economy.
22:25:49 <kc5tja> sorear: I'm still back-o-the-envelop designing it, because vim is failing me as a drawing board.  :)
22:26:12 <foxy> dons: How's the thesis?
22:26:31 <jaredj> acme is my friend
22:26:55 <jaredj> vim is my lover, but acme is a tantalizing interloper
22:27:13 <kc5tja> sorear: Given [T, T, B, T, T, T, D, T, S, T, T, T, D, T], I'd like the output to be [T, T, B [T, T, T, D], T, S [T, T, T, D], T]
22:27:26 <kc5tja> acme is your mistress?  ;D
22:27:43 <jaredj> yeah we have a fling once in a while
22:27:44 <kc5tja> While I love the concept of Plan 9, I simply and utterly *cannot* get used to any of its editors.
22:28:10 <jaredj> all the sam commands are approximately equal to ed commands, thence to vim :-commands
22:28:13 <jaredj> fwiw
22:28:33 <kc5tja> I tried it, and there is something that is markedly different from normal vim, or even from Emacs.
22:28:37 <jaredj> sam sounded good from the paper but acme is the one i use
22:28:46 <kc5tja> I can deal with vim, and I can kinda sorta deal with Emacs.  acme/sam -- nope.
22:28:57 <jaredj> i think i understand a bit of what you mean
22:29:33 <jaredj> but i spent 30 minutes in the help for emacs trying to find out how to close the help buffer
22:29:51 <jaredj> there aren't 30 minutes worth of help about acme, it's that simple :) i have respect for that.
22:29:55 <kc5tja> Someday, I'm going to try and make myself a THE-inspired text editor, just to play with the concept.  Who knows -- it might even become useful.  :)
22:30:18 <sorear> jaredj: there are at least a dozen ways to do that, no wonder you couldn't find any :)
22:30:23 <jaredj> that has to be the worst thing to google for, evar.
22:30:37 <sorear> jaredj: the humane environment
22:30:39 <sorear> iirc
22:30:42 <jaredj> ahhh yes
22:30:43 <kc5tja> Now called Archie,
22:30:45 <jaredj> ok ok
22:30:47 <kc5tja> which is just as bad to Google for.  :)
22:30:53 <jaredj> haha yeah
22:31:00 <nmessenger> > let f ('T':'T':'T':x:xs) = Just ("[TTT"++x:"]", xs); f (x:xs) = Just ([x],xs); f [] = Nothing in concat $ unfoldr f "TTBTTTDTSTTTDT"
22:31:01 <lambdabot>  "TTB[TTTD]TS[TTTD]T"
22:31:13 <sorear> wasn't archie one of the major networks back before the internet?
22:31:26 <kc5tja> sorear: It was a distributed FTP search engine.
22:31:35 <jaredj> ^^^
22:31:38 <sorear> kc5tja: that sounds right-er
22:31:53 <jaredj> gopher was a big improvement
22:31:58 <kc5tja> nmessenger: Insufficient; you rely on the fact that there are always 3 Ts; but there can be zero or more.
22:32:16 <kc5tja> gopher had the problem of not being searchable.
22:32:30 <jaredj> i wanted to love gopher again but it had this crufty sort of inflexible pre-mime-types thing going on
22:32:31 <kc5tja> There was no, as far as I am aware, gopher searchable indexes.
22:32:54 <jaredj> i thought that was 'veronica'
22:32:58 <kc5tja> nmessenger: Also, I'm using T, B, et. al. as symbols to stand for more complex types.
22:33:10 <nmessenger> kc5tja: I wasn't sure what the problem definition was, I guessed that 3 T's followed by an x should be grouped.
22:33:12 <kc5tja> jaredj: Never heard of it.
22:33:23 <kc5tja> nmessenger: Hehe, yeah, it wasn't precisely specified.
22:33:28 <jaredj> there might also have been a 'jughead' at one point... :P
22:33:59 <jaredj> http://en.wikipedia.org/wiki/Veronica_%28computer%29
22:34:50 <jaredj> oh, did i call it! did i say there was a jughead
22:36:05 <nmessenger> you can use unfoldr like a "map this function over each tail", specifying what's left at each invocation for the next one.
22:36:53 <hpaste>  jaredj pasted "takeWhileAll" at http://hpaste.org/1018
22:37:27 <nmessenger> inits?
22:38:02 <jaredj> so i could... *squint* reverse and then unfoldr, maybe?
22:38:13 <kc5tja> That's going to be very computationally expensive.
22:38:15 <nmessenger> I think sublists = inits lis
22:38:22 <jaredj> oh
22:38:28 <nmessenger> > inits "alkbjasdlk"
22:38:30 <lambdabot>  ["","a","al","alk","alkb","alkbj","alkbja","alkbjas","alkbjasd","alkbjasdl",...
22:38:36 <jaredj> oh, how handy
22:38:58 <kc5tja> > tails "asdfg"
22:38:59 <lambdabot>  ["asdfg","sdfg","dfg","fg","g",""]
22:39:02 <bos> ?seen desp
22:39:02 <lambdabot> desp is in #haskell. I last heard desp speak 23m 57s ago.
22:39:23 <sorear> > let f ('T':x) = first ('T':) (f x) ; f [] = ([],[]) ; f ('D':xs) = ([],xs) ; f (x:xs) | x `elem` "BD" = first (('[':) . (x:) . ('[':) . (blk++) . ("]]"++)) (f rst) where (blk,rst) = f xs in f "TTBTTTDTSTTTDT"
22:39:24 <lambdabot>   Non-exhaustive patterns in function f
22:39:37 <sorear> > let f ('T':x) = first ('T':) (f x) ; f [] = ([],[]) ; f ('D':xs) = ([],xs) ; f (x:xs) | x `elem` "BS" = first (('[':) . (x:) . ('[':) . (blk++) . ("]]"++)) (f rst) where (blk,rst) = f xs in f "TTBTTTDTSTTTDT"
22:39:38 <lambdabot>  ("TT[B[TTT]]T[S[TTT]]T","")
22:39:47 <sorear> kc5tja: ?
22:39:52 <sorear> kc5tja: O(n)
22:40:26 <sorear> > let f ('T':x) = first ('T':) (f x) ; f [] = ([],[]) ; f ('D':xs) = ([],xs) ; f (x:xs) | x `elem` "BS" = first (('<':) . (x:) . ('>':) . (blk++) . ("</"++) . (x:) . ('>':)) (f rst) where (blk,rst) = f xs in f "TTBTTTDTSTTTDT"
22:40:27 <lambdabot>  ("TT<B>TTT</B>T<S>TTT</S>T","")
22:40:32 <kc5tja> sorear: Combined with the search for closing tags, it becomes O(n^2)
22:40:33 <sorear> make nesting clearer :)
22:40:52 <nmessenger> D is like a B and S ender?
22:41:10 <kc5tja> nmessenger: Yes.  B and S open blocks, and D closes them.
22:41:29 <sorear> kc5tja: wait, how is mine O(n^2)?
22:41:39 <desp> bos: you rang?
22:42:03 <bos> wondering if you've spent any more time thinking about SoC
22:42:15 <sorear> kc5tja: I think, modulo laziness, it's a top down recursive descent parser
22:42:28 <desp> bos: yes, I've been browsing through libcurl documentation and the current HTTP package code
22:42:54 <kc5tja> sorear: I don't know; I can't read it.  But, you're using `elem`, which itself is O(n), ++ which is O(n), ...
22:43:37 <jaredj>  :source System.Posix.Types.FileOffset
22:43:42 <jaredj> :source System.Posix.Types.FileOffset
22:43:48 <sorear> kc5tja: ++ is O(n) in the length of its first argument, which is always a constant. `elem` is O(n) in the length of its second argument, which is always a constant.
22:43:54 <mauke> @source System.Posix.Types
22:43:54 <lambdabot> http://darcs.haskell.org/packages/base/System/Posix/Types.hs
22:43:57 <sorear> @pretty let f ('T':x) = first ('T':) (f x) ; f [] = ([],[]) ; f ('D':xs) = ([],xs) ; f (x:xs) | x `elem` "BS" = first (('<':) . (x:) . ('>':) . (blk++) . ("</"++) . (x:) . ('>':)) (f rst) where (blk,rst) = f xs in f "TTBTTTDTSTTTDT"
22:43:57 <lambdabot>  i = let f ('T' : x) = first ('T' :) (f x)
22:43:57 <lambdabot>          f [] = ([], [])
22:43:57 <lambdabot>          f ('D' : xs) = ([], xs)
22:43:57 <lambdabot>          f (x : xs)
22:43:57 <lambdabot>            | x `elem` "BS" =
22:43:58 <jaredj> thx
22:43:59 <lambdabot>              first
22:44:01 <lambdabot>                (('<' :) . (x :) . ('>' :) . (blk ++) . ("</" ++) . (x :) .
22:44:02 <nmessenger>  @src for function source, @source for modules
22:44:03 <lambdabot>                   ('>' :))
22:44:04 <bos> desp: think you're going to submit a student application?
22:44:05 <lambdabot>                (f rst)
22:44:07 <lambdabot>            where (blk, rst) = f xs
22:44:09 <lambdabot>        in f "TTBTTTDTSTTTDT"
22:44:11 <jaredj> baaaa
22:44:21 <bos> this lambdabot spamming is a bit annoying.
22:44:27 <sorear> readable? :)
22:44:29 <sorear> (oops)
22:44:41 <jaredj> heh
22:45:00 <nmessenger> @botnosnack
22:45:00 <lambdabot> :)
22:45:01 <sorear> @tell dons nice and noisy: @pretty let f ('T':x) = first ('T':) (f x) ; f [] = ([],[]) ; f ('D':xs) = ([],xs) ; f (x:xs) | x `elem` "BS" = first (('<':) . (x:) . ('>':) . (blk++) . ("</"++) . (x:) . ('>':)) (f rst) where (blk,rst) = f xs in f "TTBTTTDTSTTTDT"
22:45:01 <lambdabot> Consider it noted.
22:45:34 <nmessenger>  @pretty tends to be noisy
22:45:36 * kc5tja cannot grok pointless code, sorry.
22:45:53 <desp> bos: it depends on whether I will be moving to Australia and starting a full time job during or after SoC...
22:46:16 <bos> poland to australia, eh? quite a change, that.
22:46:23 <desp> bos: I'm trying to get a feel for things right now to see how much time would take to do the project
22:46:33 <desp> indeed.
22:46:41 <bos> desp: you can be sure it would take all of the time allotted.
22:47:04 <bos> it sounds like a noddy little project, but it's not.
22:47:15 <nmessenger> first f (x,y) = (f x, y)
22:47:46 <sorear> kc5tja: if you abstract out the recursion from that code, what you get is a state monad
22:48:14 <desp> bos: do you have some specific difficulties in mind?
22:48:16 <sorear> kc5tja: State [Char] a is sufficient here, because it's deterministic, but parsec is very nice and non-scary
22:48:46 <nmessenger> State makes it prettier and simpler, but entirely equivalent, since State is newtype'd, correct?
22:48:53 <bos> desp: no difficulties, it just won't be any use if it's not done thoroughly, e.g. with good docs, high-level wrappers, etc.
22:49:09 <desp> oh, of course.
22:49:25 <bos> the only potential difficulty is integrating curl's notion of thread safety with ghc's
22:49:46 <bos> but that won't be hard.
22:49:57 <kc5tja> sorear: Hence my comment above, that the only reasonable way of achieving my goal is to use State monad.
22:50:00 <desp> yes, I have no idea ATM how Haskell does threads
22:50:18 <bos> depends on the implementation.
22:50:33 <kc5tja> The only problem is, however, eventually I'll need to pretty-print the result of the parse tree; and that means I'll need to intermingle State and IO, if I'm not mistaken.
22:50:47 <bos> but ghc will farm out a number of haskell threads to one OS thread.
22:51:14 <bos> so if a haskell thread does blocking I/O, that OS thread becomes unavailable to ghc, without ghc knowing.
22:51:39 <bos> this reduces your parallelism.
22:51:46 <nmessenger> kc5tja: I don't see why, use State to parse, then print the result in IO.
22:51:51 <desp> I see.
22:52:17 <bos> so the thing to look at would be how much control curl expects over its sockets.
22:52:26 <jaredj> wtf?!
22:52:37 <ddarius> @type forkOS
22:52:39 <lambdabot> Not in scope: `forkOS'
22:52:42 <ddarius> @index forkOS
22:52:42 <lambdabot> Control.Concurrent
22:53:20 <bos> yep, forkOS is potentially your friend if curl insists that it owns the socket and it can't be non-blocking.
22:53:45 <kc5tja> nmessenger: Because, once you've injected a monad into a type, it's ALWAYS there.
22:53:50 <kc5tja> There's no escaping a monad.
22:53:54 <nmessenger> kc5tja: wrong!
22:53:56 <nmessenger> @type runState
22:53:58 <lambdabot> forall s a. State s a -> s -> (a, s)
22:54:05 <desp> I don't think that libcurl actually gives the user control of its sockets
22:54:15 <nmessenger> IO is peculiar in that it's inescapible.
22:54:28 <desp> all IO appears to be done through callbacks
22:54:31 <ddarius> kc5tja: The "no way out" thing is not a general aspect of monads.
22:54:33 <bos> that's a bit of a shame. we won't be able to scrape 100,000 web sites simultaneously, then :-)
22:54:50 <bos> desp: oh? cool.
22:55:03 <bos> wait. you mean callbacks into curl, or out of it?
22:55:07 <nmessenger> the Monad class doesn't provide a general run :: m a -> a method, but there's nothing to stop a particular type from having one.
22:55:09 <ddarius> How well does select scale for that?
22:55:17 <bos> select is terrible for that.
22:55:18 <nmessenger> for instance, list has infinitely many
22:55:21 <nmessenger> @type head
22:55:23 <lambdabot> forall a. [a] -> a
22:55:24 <nmessenger> @type (!! 1)
22:55:27 <lambdabot> forall a. [a] -> a
22:55:28 <nmessenger> @type sum
22:55:30 <lambdabot> forall a. (Num a) => [a] -> a
22:55:33 <desp> bos: one moment, reading.
22:56:22 <kc5tja> I see; I'm reading up on Control.Monad.State now.
22:56:47 <bos> select develops asthma around a small few thousand file descriptors, emphysema not long after, and its eyes roll back in its head shortly afterwards.
22:56:47 <desp> there are three interfaces to libcurl; the simple "easy" interface utilizes functions passed by the user and called by libcurl at appropriate times
22:57:10 <nmessenger> @type let parser = (undefined :: State String a); input = (undefined :: String) in print $ evalState parser input
22:57:12 <lambdabot> IO ()
22:57:45 <hpaste>  jaredj pasted "pack a knapsack with one item" at http://hpaste.org/1019
22:57:59 <desp> libcurl can write to fd's, but it also can just pass the data to a callback function
22:58:31 <desp> so I think there's no need to involve select()
23:00:53 <desp> especially since libcurl provides a way to do multiple simultaneous transfers in the same thread with its multi interface
23:00:56 <nmessenger> *monads are not special*
23:01:29 <nmessenger> they are class of types that supports some methods, and must satisfy some rules.
23:02:44 <nmessenger> @check (\xs -> (join . return) xs == xs) :: [Int] -> Bool
23:02:45 <lambdabot>  OK, passed 500 tests.
23:03:36 <jcreigh> (with special syntaax)
23:03:46 <nmessenger> syntax is irrelevant!
23:03:54 <jcreigh> no it's not.
23:04:22 <jcreigh> syntax helps shape what is easy in a language, and thus shapes what is actually done in a language.
23:04:35 <nmessenger> syntax *sugar* is irrelevant, semantics-wise.  It doesn't do anything magical.
23:05:02 <desp> nmessenger: Ook
23:05:41 <nmessenger> IO is a strange type, though
23:05:46 <dolio> The syntax is, I suspect, at least part of what makes monads so widely used in Haskell.
23:05:49 <cragwolf> > let pidigits = g(1, 180, 60, 2) where g(q, r, t, i) = let (u, y) = (3*(3*i+1)*(3*i+2), div(q*(27*i-12)+5*r) (5*t)) in y : g(10*q*i*(2*i-1), 10*u*(q*(5*i-2)+r-y*t), t*u, i+1) in take 100 pidigits
23:05:51 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1...
23:06:07 <jcreigh> sure; but it impacts what people actually do. I think we'd see less use of anonymous functions in Haskell if you had to say, for example, "(lambda (x) ...)".
23:06:14 <desp> bos: to me, the most difficult thing seems devising an appropriate, powerful abstraction on the Haskell side
23:06:27 <dolio> In lisp, you write a macro that makes a bit of code easier. In Haskell, you realize what you're doing is using a bunch of monads, so you factor them out, and use do notation to make it handy.
23:07:03 <jcreigh> and I think we'd see less use of monads if you had to say foo >>= (\bar -> baz >>= (\quux ...))
23:07:13 <bos> desp: ok, good. that bit won't be too hard.
23:07:48 <nmessenger> jcreigh: agreed.  I was just on a semantics soapbox.  Monads are often seen as a magical, somehow "dirty" thing necessary to make Haskell useful, instead of the *desirable* thing they are :)
23:07:56 <dolio> With Haskell's infix operators, though, it's not that much worse writing unsugared monadic code, though.
23:08:42 <kc5tja> nmessenger: I prefer to write "pure functional" code because it's easier for me to understand.
23:08:58 <kc5tja> I do not think that monads are "dirty."  I *really* don't know where you got this idea from.
23:08:58 <nmessenger> monads are not impure!
23:09:13 <kc5tja> OK
23:09:24 <nmessenger> kc5tja: sorry, I meant not to imply you.  Just venting in general :)
23:10:22 <bos> desp: have you read lammel's mapreduce paper?
23:10:32 <desp> bos: the Google paper?
23:10:46 <bos> no, ralf lammel's one about the google paper.
23:10:55 <desp> nope, then
23:10:58 <bos> it's much more interesting than the google paper :-)
23:11:23 <desp> @where mapreduce
23:11:24 <lambdabot> I know nothing about mapreduce.
23:11:32 <desp> how do I tell it that it's at http://www.cs.vu.nl/~ralf/MapReduce/paper.pdf ? :)
23:11:34 <bos> it's a great piece of writing on how to take a fuzzy description of a problem and iteratively come up with a decent functional API
23:11:46 <sorear> @where+ mapreduce <jcreigh> and I think we'd see less use of monads if you had to say foo >>=
23:11:46 <sorear>           (\bar -> baz >>= (\quux ...))
23:11:46 <sorear> <bos> desp: ok, good. that bit won't be too hard.
23:11:46 <sorear> <nmessenger> jcreigh: agreed.  I was just on a semantics soapbox.  Monads are
23:11:46 <lambdabot> Done.
23:11:51 <sorear>              often seen as a magical, somehow "dirty" thing necessary to make
23:11:54 <sorear>              Haskell useful, instead of the *desirable* thing they are :) [23:06]
23:11:57 <sorear> <dolio> With Haskell's infix operators, though, it's not that much worse writing
23:12:00 <sorear>         unsugared monadic code, though.
23:12:03 <sorear> <kc5tja> nmessenger: I prefer to write "pure functional" code because it's
23:12:03 * desp slaps sorear with an UNIX manual
23:12:05 <mauke> AIRRR
23:12:06 <sorear>          easier for me to understand.                                     [23:07]
23:12:07 <sorear> <kc5tja> I do not think that monads are "dirty."  I *really* don't know where
23:12:09 <bos> @google lammel revisiting mapreduce
23:12:11 <sorear>          you got this idea from.
23:12:12 <lambdabot> http://lambda-the-ultimate.org/node/1669
23:12:12 <lambdabot> Title: Revisiting Google&#039;s MapReduce | Lambda the Ultimate
23:12:14 <kc5tja> desp: Unix has manuals?
23:12:14 <sorear> <nmessenger> monads are not impure!
23:12:16 <nmessenger> :O
23:12:17 <sorear> <kc5tja> OK
23:12:20 <sorear> <nmessenger> kc5tja: sorry, I meant not to imply you.  Just venting in general
23:12:23 <sorear>              :)                                                           [23:08]
23:12:27 <sorear> <bos> desp: have you read lammel's mapreduce paper?                       [23:09]
23:12:29 <nmessenger> deja vu!
23:12:30 <sorear> <desp> bos: the Google paper?
23:12:31 <dolio> What's going on?
23:12:34 <bos> @smack sorear
23:12:34 <sorear> <bos> no, ralf lammel's one about the google paper.
23:12:34 <lambdabot> Unknown command, try @list
23:12:37 <sorear> <desp> nope, then
23:12:40 <sorear> <bos> it's much more interesting than the google paper :-)
23:12:42 <mauke> sorear: you suck at copy/paste
23:12:43 <nmessenger> dolio: sorear did a copy-paste :(
23:12:43 <stefan> can someone PLEASE kick me
23:12:43 <sorear> <desp> @where mapreduce                                                   [23:10]
23:12:43 <sorear> <lambdabot> I know nothing about mapreduce.
23:12:47 <sorear> <desp> how do I tell it that it's at
23:12:51 <sorear>        http://www.cs.vu.nl/~ralf/MapReduce/paper.pdf
23:12:51 <dolio> Heh.
23:12:56 <stefan> PLEASE
23:13:10 <desp> bos: unfortunately, the server appears to be down
23:13:21 <nmessenger> @quote Monads.are
23:13:21 <lambdabot> gzl says: [on why monads are scary] maybe it's because people look up monad on wikipedia, find the category theory page, and crap themselves
23:13:23 <kc5tja> That was a recursive paste.  :)
23:13:30 <stefan> god that was embarassing
23:13:32 <nmessenger> @quote nmessenger Monads.are
23:13:32 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
23:13:32 <mauke> thank you, emacs
23:13:59 <bos> desp: use google's search results to view it as html, and you can read it
23:14:04 <nmessenger> kc5tja: though, yes, write it with the explicit state-passing yourself so you can understand it, and I encourage you to try your hand at turning it into using a State monad one day.  It'll be a good experience.
23:14:35 <nmessenger> That's what I did. :D
23:14:51 <sorear> and now, I try again
23:14:53 <sorear> @where+ mapreduce http://www.cs.vu.nl/~ralf/MapReduce/paper.pdf
23:14:53 <lambdabot> Done.
23:15:02 <jaredj> argh
23:15:13 <jaredj> Pick.hs: runhaskell: exit 1
23:15:13 <jaredj> out of memory (requested 1447034880 bytes)
23:16:44 <desp> bos: aye
23:19:18 <jaredj> night all
23:19:37 <sorear> bye :(
23:20:24 <sorear> is there actually noone awake with ops/chanserv access?
23:21:04 <sjanssen> I wasn't paying attention
23:21:45 <desp> kc5tja: sure it does, it looks kind of like this: http://www.leatherbooks.info/images/0018s.jpg
23:22:29 <sorear> heh, do /msg chanserv access #haskell list
23:22:50 <sorear> almost half are listed as using powers the same length of time (~5min) ago
23:23:24 <nmessenger> strange
23:24:37 <kc5tja> desp: I think VMS documentation puts even that to shame.  :D
23:24:43 * sjanssen has never used his op privileges
23:25:40 <sorear> sjanssen: you're listed as using them a few minutes ago...
23:26:25 <sjanssen> sorear: probably when I sent "access #haskell list"
23:26:33 <sjanssen> it returned 0s at that time
23:29:04 <desp> google's pdf2html munges footnotes
23:29:16 <desp> footnote refs*
23:31:31 <desp> hm
23:31:36 <desp> :t _|_
23:31:38 <lambdabot> parse error on input `|'
23:31:52 <dmwit> sjanssen: I see that XMonad imports Xinerama headers.
23:32:01 <desp> is "_|_" obsolete notation?
23:32:07 <dmwit> Does this mean XMonad will (eventually) support Xinerama, or is it for convenience of other things?
23:32:16 <sorear> dmwit: it supports Xinerama
23:32:22 <sorear> dmwit: as of today
23:32:27 <mauke> _|_ is mathy notation
23:32:27 <dmwit> Well.
23:32:35 <dmwit> I'll be damned.
23:32:37 <sorear> desp: \bot
23:32:49 <sorear> desp: (in L[a]T^eX)
23:32:52 <desp> sorear: I know, I know, but can you type that in Haskell?
23:32:55 <desp> somehow
23:33:00 <mauke> no, use undefined
23:33:01 <dmwit> They're going to drive be away from dwm!
23:33:04 <desp> ah
23:33:32 <sjanssen> dmwit: thank jcreigh
23:33:44 <dmwit> jcreigh: Thanks!
23:34:01 <dmwit> I'm really excited about XMonad now!
23:34:14 <dolio> ?pl \p -> getRandom >>= return . flip rotate p
23:34:14 <lambdabot> (`fmap` getRandom) . flip rotate
23:34:38 <dmwit> :t fmap
23:34:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:34:48 <mauke> fmap == liftM
23:35:02 <mauke> a.k.a. >>= return .
23:35:25 <dolio> ?pl (ap $ fmap rotate getRandom) . return
23:35:25 <lambdabot> liftM2 rotate getRandom . return
23:35:50 <nmessenger> what's rotate's type?
23:36:00 <rubenz> Can anyone suggest a Haskell quaternions library to look at?
23:36:02 <dolio> Direction -> [[a]] -> [[a]]
23:36:20 <ddarius> rubenz: None, use geometric algebra
23:36:38 <rubenz> ddarius: what is that?
23:36:48 <ddarius> @google Geometric Calculus
23:36:50 <lambdabot> http://modelingnts.la.asu.edu/
23:36:50 <lambdabot> Title: Geometric Calculus R & D Home Page
23:37:13 <ddarius> rubenz: A good introduction is the paper Imaginary Numbers are Not Real
23:37:19 <ddarius> @google Imaginary numbers are not real
23:37:22 <lambdabot> http://www.mrao.cam.ac.uk/~clifford/introduction/intro/intro.html
23:37:22 <lambdabot> Title: Imaginary Numbers are not Real - the Geometric Algebra of Spacetime
23:37:52 <desp> whew
23:38:34 <rubenz> Is anyone aware of a Rigid Body dynamics engine which has been written in Haskell?
23:39:02 <hpaste>  kc5tja pasted "Recursive descent parser" at http://hpaste.org/1020
23:39:21 <sorear> <Cheery> tomorrow we'll hopefully see some spirals and circles with a bunch of
23:39:21 <sorear>          verlet physics. ;)                                               [15:27]
23:39:27 <kc5tja> sorear, nmessenger: I've successfully tested the code at paste #1020
23:39:56 <sorear> that was today, ~8h ago
23:40:07 <Lemmih> rubenz: Some dude wrote a binding to libODE.
23:40:13 <sorear> what is cut?
23:40:17 <sorear> @google CUT parser
23:40:20 <lambdabot> http://www.robotwisdom.com/net/firstcut.html
23:40:21 <lambdabot> Title: The First-Cut Manifesto
23:40:24 <ddarius> There is a ps of the paper I referenced.
23:41:06 <kc5tja> sorear: CUT is my C Unit Tester project; see http://www.falvotech.com/content/cut
23:41:07 <lambdabot> Title: CUT
23:41:47 <mgsloan> verlet physics is fun
23:42:00 <kc5tja> I'm recreating CUT in Haskell so that I can learn the language better.  As an unexpected side-effect, I'm modeling CUT 3.0 (the next version of CUT)
23:42:09 <mgsloan> simple and effective
23:42:51 <desp> ddarius: starts quite interesting
23:43:09 <desp> my toread list grows again
23:46:44 <ddarius> rubenz: Hmm, wrong one. Still good, but I don't think it specifically covers the relationship to quaternions.
23:52:57 <edwardk> @seen dons
23:52:57 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3h 56m 15s ago.
